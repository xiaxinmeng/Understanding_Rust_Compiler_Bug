{"sha": "abcb0cdc2005f2cfb5ac9f1dedd5269b5f51c89f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWJjYjBjZGMyMDA1ZjJjZmI1YWM5ZjFkZWRkNTI2OWI1ZjUxYzg5Zg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@airs.com", "date": "2006-01-11T13:09:13Z"}, "committer": {"name": "Kenneth Zadeck", "email": "zadeck@gcc.gnu.org", "date": "2006-01-11T13:09:13Z"}, "message": "combine.c (struct undo): Remove is_int.\n\n2006-01-11  Ian Lance Taylor <ian@airs.com>\n\n\t* combine.c (struct undo): Remove is_int.  Enumify types of undos.\n\tAllow undoing set of machine mode.\n\t(do_SUBST): Use enums instead of is_int.\n\t(do_SUBST_MODE): New function.\n\t(SUBST_MODE): New macro.\n\t(try_combine): Use SUBST_MODE/PUT_MODE instead of generating a new\n\treg and trying to replace reg_regno_rtx with a new register.\n\t(undo_all): Use new enums, handle undoing a PUT_MODE change.\n\t(simplify_set): Use SUBST_MODE.\n\t(distribute_notes): Remove code that tried to update reg notes\n\tfor regno_reg_rtx changes.\n\nFrom-SVN: r109579", "tree": {"sha": "b73c1561df90c815d1d60a4bb0387bf76970973d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b73c1561df90c815d1d60a4bb0387bf76970973d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/abcb0cdc2005f2cfb5ac9f1dedd5269b5f51c89f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abcb0cdc2005f2cfb5ac9f1dedd5269b5f51c89f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abcb0cdc2005f2cfb5ac9f1dedd5269b5f51c89f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abcb0cdc2005f2cfb5ac9f1dedd5269b5f51c89f/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bc23502b7f6590639be6473b4b8702187cac895d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc23502b7f6590639be6473b4b8702187cac895d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc23502b7f6590639be6473b4b8702187cac895d"}], "stats": {"total": 208, "additions": 158, "deletions": 50}, "files": [{"sha": "e8f5b8a7eed1eb1006da3c90bf9a5ad3bfda33d0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abcb0cdc2005f2cfb5ac9f1dedd5269b5f51c89f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abcb0cdc2005f2cfb5ac9f1dedd5269b5f51c89f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=abcb0cdc2005f2cfb5ac9f1dedd5269b5f51c89f", "patch": "@@ -1,3 +1,17 @@\n+2006-01-11  Ian Lance Taylor <ian@airs.com>\n+\n+\t* combine.c (struct undo): Remove is_int.  Enumify types of undos.\n+\tAllow undoing set of machine mode.\n+\t(do_SUBST): Use enums instead of is_int.\n+\t(do_SUBST_MODE): New function.\n+\t(SUBST_MODE): New macro.\n+\t(try_combine): Use SUBST_MODE/PUT_MODE instead of generating a new\n+\treg and trying to replace reg_regno_rtx with a new register.\n+\t(undo_all): Use new enums, handle undoing a PUT_MODE change.\n+\t(simplify_set): Use SUBST_MODE.\n+\t(distribute_notes): Remove code that tried to update reg notes\n+\tfor regno_reg_rtx changes.\n+\n 2006-01-11  Paolo Bonzini  <bonzini@gnu.org>\n \n \tPR tree-optimization/23109"}, {"sha": "e2e72583fded1df55677b0533d787b0f18f87ceb", "filename": "gcc/combine.c", "status": "modified", "additions": 108, "deletions": 50, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abcb0cdc2005f2cfb5ac9f1dedd5269b5f51c89f/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abcb0cdc2005f2cfb5ac9f1dedd5269b5f51c89f/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=abcb0cdc2005f2cfb5ac9f1dedd5269b5f51c89f", "patch": "@@ -321,15 +321,14 @@ static int nonzero_sign_valid;\n \n \f\n /* Record one modification to rtl structure\n-   to be undone by storing old_contents into *where.\n-   is_int is 1 if the contents are an int.  */\n+   to be undone by storing old_contents into *where.  */\n \n struct undo\n {\n   struct undo *next;\n-  int is_int;\n-  union {rtx r; int i;} old_contents;\n-  union {rtx *r; int *i;} where;\n+  enum { UNDO_RTX, UNDO_INT, UNDO_MODE } kind;\n+  union { rtx r; int i; enum machine_mode m; } old_contents;\n+  union { rtx *r; int *i; } where;\n };\n \n /* Record a bunch of changes to be undone, up to MAX_UNDO of them.\n@@ -490,7 +489,7 @@ do_SUBST (rtx *into, rtx newval)\n   else\n     buf = xmalloc (sizeof (struct undo));\n \n-  buf->is_int = 0;\n+  buf->kind = UNDO_RTX;\n   buf->where.r = into;\n   buf->old_contents.r = oldval;\n   *into = newval;\n@@ -518,7 +517,7 @@ do_SUBST_INT (int *into, int newval)\n   else\n     buf = xmalloc (sizeof (struct undo));\n \n-  buf->is_int = 1;\n+  buf->kind = UNDO_INT;\n   buf->where.i = into;\n   buf->old_contents.i = oldval;\n   *into = newval;\n@@ -527,6 +526,35 @@ do_SUBST_INT (int *into, int newval)\n }\n \n #define SUBST_INT(INTO, NEWVAL)  do_SUBST_INT(&(INTO), (NEWVAL))\n+\n+/* Similar to SUBST, but just substitute the mode.  This is used when\n+   changing the mode of a pseudo-register, so that any other\n+   references to the entry in the regno_reg_rtx array will change as\n+   well.  */\n+\n+static void\n+do_SUBST_MODE (rtx *into, enum machine_mode newval)\n+{\n+  struct undo *buf;\n+  enum machine_mode oldval = GET_MODE (*into);\n+\n+  if (oldval == newval)\n+    return;\n+\n+  if (undobuf.frees)\n+    buf = undobuf.frees, undobuf.frees = buf->next;\n+  else\n+    buf = xmalloc (sizeof (struct undo));\n+\n+  buf->kind = UNDO_MODE;\n+  buf->where.r = into;\n+  buf->old_contents.m = oldval;\n+  PUT_MODE (*into, newval);\n+\n+  buf->next = undobuf.undos, undobuf.undos = buf;\n+}\n+\n+#define SUBST_MODE(INTO, NEWVAL)  do_SUBST_MODE(&(INTO), (NEWVAL))\n \f\n /* Subroutine of try_combine.  Determine whether the combine replacement\n    patterns NEWPAT and NEWI2PAT are cheaper according to insn_rtx_cost\n@@ -2224,10 +2252,15 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t\t\t\t   compare_mode))\n \t    {\n \t      unsigned int regno = REGNO (SET_DEST (newpat));\n-\t      rtx new_dest = gen_rtx_REG (compare_mode, regno);\n+\t      rtx new_dest;\n \n-\t      if (regno >= FIRST_PSEUDO_REGISTER)\n-\t\tSUBST (regno_reg_rtx[regno], new_dest);\n+\t      if (regno < FIRST_PSEUDO_REGISTER)\n+\t\tnew_dest = gen_rtx_REG (compare_mode, regno);\n+\t      else\n+\t\t{\n+\t\t  SUBST_MODE (regno_reg_rtx[regno], compare_mode);\n+\t\t  new_dest = regno_reg_rtx[regno];\n+\t\t}\n \n \t      SUBST (SET_DEST (newpat), new_dest);\n \t      SUBST (XEXP (*cc_use, 0), new_dest);\n@@ -2476,7 +2509,6 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n       && asm_noperands (newpat) < 0)\n     {\n       rtx m_split, *split;\n-      rtx ni2dest = i2dest;\n \n       /* See if the MD file can split NEWPAT.  If it can't, see if letting it\n \t use I2DEST as a scratch register will help.  In the latter case,\n@@ -2491,34 +2523,55 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t possible to try that as a scratch reg.  This would require adding\n \t more code to make it work though.  */\n \n-      if (m_split == 0 && ! reg_overlap_mentioned_p (ni2dest, newpat))\n+      if (m_split == 0 && ! reg_overlap_mentioned_p (i2dest, newpat))\n \t{\n- \t  enum machine_mode new_mode = GET_MODE (SET_DEST (newpat));\n-\t  /* If I2DEST is a hard register or the only use of a pseudo,\n-\t     we can change its mode.  */\n- \t  if (new_mode != GET_MODE (i2dest)\n- \t      && new_mode != VOIDmode\n- \t      && can_change_dest_mode (i2dest, added_sets_2, new_mode))\n-\t    ni2dest = gen_rtx_REG (GET_MODE (SET_DEST (newpat)),\n-\t\t\t\t   REGNO (i2dest));\n+\t  enum machine_mode new_mode = GET_MODE (SET_DEST (newpat));\n \n+\t  /* First try to split using the original register as a\n+\t     scratch register.  */\n \t  m_split = split_insns (gen_rtx_PARALLEL\n \t\t\t\t (VOIDmode,\n \t\t\t\t  gen_rtvec (2, newpat,\n \t\t\t\t\t     gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t\t\t\t      ni2dest))),\n+\t\t\t\t\t\t\t      i2dest))),\n \t\t\t\t i3);\n-\t  /* If the split with the mode-changed register didn't work, try\n-\t     the original register.  */\n-\t  if (! m_split && ni2dest != i2dest)\n+\n+\t  /* If that didn't work, try changing the mode of I2DEST if\n+\t     we can.  */\n+\t  if (m_split == 0\n+\t      && new_mode != GET_MODE (i2dest)\n+\t      && new_mode != VOIDmode\n+\t      && can_change_dest_mode (i2dest, added_sets_2, new_mode))\n \t    {\n-\t      ni2dest = i2dest;\n+\t      enum machine_mode old_mode = GET_MODE (i2dest);\n+\t      rtx ni2dest;\n+\n+\t      if (REGNO (i2dest) < FIRST_PSEUDO_REGISTER)\n+\t\tni2dest = gen_rtx_REG (new_mode, REGNO (i2dest));\n+\t      else\n+\t\t{\n+\t\t  SUBST_MODE (regno_reg_rtx[REGNO (i2dest)], new_mode);\n+\t\t  ni2dest = regno_reg_rtx[REGNO (i2dest)];\n+\t\t}\n+\n \t      m_split = split_insns (gen_rtx_PARALLEL\n \t\t\t\t     (VOIDmode,\n \t\t\t\t      gen_rtvec (2, newpat,\n \t\t\t\t\t\t gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t\t\t\t\t  i2dest))),\n+\t\t\t\t\t\t\t\t  ni2dest))),\n \t\t\t\t     i3);\n+\n+\t      if (m_split == 0\n+\t\t  && REGNO (i2dest) >= FIRST_PSEUDO_REGISTER)\n+\t\t{\n+\t\t  struct undo *buf;\n+\n+\t\t  PUT_MODE (regno_reg_rtx[REGNO (i2dest)], old_mode);\n+\t\t  buf = undobuf.undos;\n+\t\t  undobuf.undos = buf->next;\n+\t\t  buf->next = undobuf.frees;\n+\t\t  undobuf.frees = buf;\n+\t\t}\n \t    }\n \t}\n \n@@ -2547,13 +2600,6 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t  i3set = single_set (NEXT_INSN (m_split));\n \t  i2set = single_set (m_split);\n \n-\t  /* In case we changed the mode of I2DEST, replace it in the\n-\t     pseudo-register table here.  We can't do it above in case this\n-\t     code doesn't get executed and we do a split the other way.  */\n-\n-\t  if (REGNO (i2dest) >= FIRST_PSEUDO_REGISTER)\n-\t    SUBST (regno_reg_rtx[REGNO (i2dest)], ni2dest);\n-\n \t  i2_code_number = recog_for_combine (&newi2pat, i2, &new_i2_notes);\n \n \t  /* If I2 or I3 has multiple SETs, we won't know how to track\n@@ -2624,10 +2670,13 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t     validated that we can do this.  */\n \t  if (GET_MODE (i2dest) != split_mode && split_mode != VOIDmode)\n \t    {\n-\t      newdest = gen_rtx_REG (split_mode, REGNO (i2dest));\n-\n-\t      if (REGNO (i2dest) >= FIRST_PSEUDO_REGISTER)\n-\t\tSUBST (regno_reg_rtx[REGNO (i2dest)], newdest);\n+\t      if (REGNO (i2dest) < FIRST_PSEUDO_REGISTER)\n+\t\tnewdest = gen_rtx_REG (split_mode, REGNO (i2dest));\n+\t      else\n+\t\t{\n+\t\t  SUBST_MODE (regno_reg_rtx[REGNO (i2dest)], split_mode);\n+\t\t  newdest = regno_reg_rtx[REGNO (i2dest)];\n+\t\t}\n \t    }\n \n \t  /* If *SPLIT is a (mult FOO (const_int pow2)), convert it to\n@@ -3328,10 +3377,20 @@ undo_all (void)\n   for (undo = undobuf.undos; undo; undo = next)\n     {\n       next = undo->next;\n-      if (undo->is_int)\n-\t*undo->where.i = undo->old_contents.i;\n-      else\n-\t*undo->where.r = undo->old_contents.r;\n+      switch (undo->kind)\n+\t{\n+\tcase UNDO_RTX:\n+\t  *undo->where.r = undo->old_contents.r;\n+\t  break;\n+\tcase UNDO_INT:\n+\t  *undo->where.i = undo->old_contents.i;\n+\t  break;\n+\tcase UNDO_MODE:\n+\t  PUT_MODE (*undo->where.r, undo->old_contents.m);\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n \n       undo->next = undobuf.frees;\n       undobuf.frees = undo;\n@@ -5160,10 +5219,15 @@ simplify_set (rtx x)\n \t  if (can_change_dest_mode (dest, 0, compare_mode))\n \t    {\n \t      unsigned int regno = REGNO (dest);\n-\t      rtx new_dest = gen_rtx_REG (compare_mode, regno);\n+\t      rtx new_dest;\n \n-\t      if (regno >= FIRST_PSEUDO_REGISTER)\n-\t\tSUBST (regno_reg_rtx[regno], new_dest);\n+\t      if (regno < FIRST_PSEUDO_REGISTER)\n+\t\tnew_dest = gen_rtx_REG (compare_mode, regno);\n+\t      else\n+\t\t{\n+\t\t  SUBST_MODE (regno_reg_rtx[regno], compare_mode);\n+\t\t  new_dest = regno_reg_rtx[regno];\n+\t\t}\n \n \t      SUBST (SET_DEST (x), new_dest);\n \t      SUBST (XEXP (*cc_use, 0), new_dest);\n@@ -11709,12 +11773,6 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2, rtx elim_i2,\n     {\n       rtx place = 0, place2 = 0;\n \n-      /* If this NOTE references a pseudo register, ensure it references\n-\t the latest copy of that register.  */\n-      if (XEXP (note, 0) && REG_P (XEXP (note, 0))\n-\t  && REGNO (XEXP (note, 0)) >= FIRST_PSEUDO_REGISTER)\n-\tXEXP (note, 0) = regno_reg_rtx[REGNO (XEXP (note, 0))];\n-\n       next_note = XEXP (note, 1);\n       switch (REG_NOTE_KIND (note))\n \t{"}, {"sha": "9ef9c2fdd9f9758a6a20a69d609f76e647e09253", "filename": "gcc/testsuite/gcc.c-torture/compile/20060109-1.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abcb0cdc2005f2cfb5ac9f1dedd5269b5f51c89f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20060109-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abcb0cdc2005f2cfb5ac9f1dedd5269b5f51c89f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20060109-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20060109-1.c?ref=abcb0cdc2005f2cfb5ac9f1dedd5269b5f51c89f", "patch": "@@ -0,0 +1,36 @@\n+/* This test exposed a bug in combine where it was improperly changing\n+   the mode of a register.  The bug appeared to be latent until web\n+   was moved after combine.  This is the reduced test that fails \n+   by crashing in reload.  */\n+\n+\n+typedef struct cpp_reader cpp_reader;\n+typedef struct cpp_string cpp_string;\n+struct cpp_string\n+{\n+  unsigned int len;\n+  const unsigned char *text;\n+};\n+struct cpp_callbacks\n+{\n+  void (*ident) (cpp_reader *, unsigned int, const cpp_string *);\n+};\n+static void cb_ident (cpp_reader *, unsigned int, const cpp_string *);\n+init_c_lex (void)\n+{\n+  struct cpp_callbacks *cb;\n+  cb->ident = cb_ident;\n+}\n+cb_ident (cpp_reader * pfile __attribute__ ((__unused__)), unsigned int\n+line\n+          __attribute__ ((__unused__)), const cpp_string * str\n+          __attribute__ ((__unused__)))\n+{\n+  {\n+    cpp_string cstr = {\n+    };\n+    if (cpp_interpret_string (pfile, str, 1, &cstr, 0))\n+      {\n+      }\n+  }\n+}"}]}