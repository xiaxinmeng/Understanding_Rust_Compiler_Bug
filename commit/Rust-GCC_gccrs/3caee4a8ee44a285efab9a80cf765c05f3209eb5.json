{"sha": "3caee4a8ee44a285efab9a80cf765c05f3209eb5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2NhZWU0YThlZTQ0YTI4NWVmYWI5YTgwY2Y3NjVjMDVmMzIwOWViNQ==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@rabi.columbia.edu", "date": "1999-04-26T16:41:02Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "1999-04-26T16:41:02Z"}, "message": "cpphash.c (dump_definition): New function.\n\n1999-04-26 19:16 -0400  Zack Weinberg  <zack@rabi.columbia.edu>\n\t* cpphash.c (dump_definition): New function.\n\t* cpphash.h: Prototype it.\n\t* cpplib.c (handle_directive): Don't output anything here.\n\tStreamline.\n\t(pass_thru_directive): Take a length, not a pointer to the\n\tend.  All callers changed.\n\t(do_define): Handle -dD, -dN, -g3 entirely here.  Streamline.\n\t(do_include): Handle -dI here.\n\t(do_ident): Correct to match cccp.\n\t(do_pragma): Copy the pragma through here.\n\t(do_assert, do_unassert): Tidy.\n\t* cppinit.c (cpp_finish): If -dM was specified, walk the macro\n\thash table and call dump_definition on all the entries.\n\t* cppmain.c: cpp_finish may produce output.\n\nFrom-SVN: r26659", "tree": {"sha": "5c575c1ae52f10bc1eebdcf45ba407212d863336", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c575c1ae52f10bc1eebdcf45ba407212d863336"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3caee4a8ee44a285efab9a80cf765c05f3209eb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3caee4a8ee44a285efab9a80cf765c05f3209eb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3caee4a8ee44a285efab9a80cf765c05f3209eb5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3caee4a8ee44a285efab9a80cf765c05f3209eb5/comments", "author": null, "committer": null, "parents": [{"sha": "641be6fea8860669fb0535babeab8cfbe17b8413", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/641be6fea8860669fb0535babeab8cfbe17b8413", "html_url": "https://github.com/Rust-GCC/gccrs/commit/641be6fea8860669fb0535babeab8cfbe17b8413"}], "stats": {"total": 375, "additions": 229, "deletions": 146}, "files": [{"sha": "007591615f17522662e7a35b567e21af525d2840", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3caee4a8ee44a285efab9a80cf765c05f3209eb5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3caee4a8ee44a285efab9a80cf765c05f3209eb5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3caee4a8ee44a285efab9a80cf765c05f3209eb5", "patch": "@@ -1,3 +1,22 @@\n+1999-04-26 19:16 -0400  Zack Weinberg  <zack@rabi.columbia.edu>\n+\n+\t* cpphash.c (dump_definition): New function.\n+\t* cpphash.h: Prototype it.\n+\n+\t* cpplib.c (handle_directive): Don't output anything here.\n+\tStreamline.\n+\t(pass_thru_directive): Take a length, not a pointer to the\n+\tend.  All callers changed.\n+\t(do_define): Handle -dD, -dN, -g3 entirely here.  Streamline.\n+\t(do_include): Handle -dI here.\n+\t(do_ident): Correct to match cccp.\n+\t(do_pragma): Copy the pragma through here.\n+\t(do_assert, do_unassert): Tidy.\n+\t\n+\t* cppinit.c (cpp_finish): If -dM was specified, walk the macro\n+\thash table and call dump_definition on all the entries.\n+\t* cppmain.c: cpp_finish may produce output.\n+\n Mon Apr 26 15:27:33 1999  Mark Mitchell  <mark@codesourcery.com>\n \n \t* toplev.c (compile_file): Move call to check_global_declarations"}, {"sha": "1d8a104460e406856ad571d4515fd9058b8497f0", "filename": "gcc/cpphash.c", "status": "modified", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3caee4a8ee44a285efab9a80cf765c05f3209eb5/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3caee4a8ee44a285efab9a80cf765c05f3209eb5/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=3caee4a8ee44a285efab9a80cf765c05f3209eb5", "patch": "@@ -1636,3 +1636,100 @@ comp_def_part (first, beg1, len1, beg2, len2, last)\n     }\n   return (beg1 != end1) || (beg2 != end2);\n }\n+\n+/* Dump the definition of macro MACRO on stdout.  The format is suitable\n+   to be read back in again. */\n+\n+void\n+dump_definition (pfile, macro)\n+     cpp_reader *pfile;\n+     MACRODEF macro;\n+{\n+  DEFINITION *defn = macro.defn;\n+\n+  CPP_RESERVE (pfile, macro.symlen + sizeof \"#define \");\n+  CPP_PUTS_Q (pfile, \"#define \", sizeof \"#define \" -1);\n+  CPP_PUTS_Q (pfile, macro.symnam, macro.symlen);\n+\n+  if (defn->nargs == -1)\n+    {\n+      CPP_PUTC_Q (pfile, ' ');\n+\n+      /* The first and last two characters of a macro expansion are\n+\t always \"\\r \"; this needs to be trimmed out.\n+\t So we need length-4 chars of space, plus one for the NUL.  */\n+      CPP_RESERVE (pfile, defn->length - 4 + 1);\n+      CPP_PUTS_Q (pfile, defn->expansion + 2, defn->length - 4);\n+      CPP_NUL_TERMINATE_Q (pfile);\n+    }\n+  else\n+    {\n+      struct reflist *r;\n+      unsigned char *argnames = xstrdup (defn->args.argnames);\n+      unsigned char **argv = alloca (defn->nargs * sizeof(char *));\n+      int *argl = alloca (defn->nargs * sizeof(int));\n+      unsigned char *x;\n+      int i;\n+\n+      /* First extract the argument list. */\n+      x = argnames;\n+      i = defn->nargs;\n+      while (i--)\n+\t{\n+\t  argv[i] = x;\n+\t  while (*x != ',' && *x != '\\0') x++;\n+\t  argl[i] = x - argv[i];\n+\t  if (*x == ',')\n+\t    {\n+\t      *x = '\\0';\n+\t      x += 2;  /* skip the space after the comma */\n+\t    }\n+\t}\n+      \n+      /* Now print out the argument list. */\n+      CPP_PUTC_Q (pfile, '(');\n+      for (i = 0; i < defn->nargs; i++)\n+\t{\n+\t  CPP_RESERVE (pfile, argl[i] + 2);\n+\t  CPP_PUTS_Q (pfile, argv[i], argl[i]);\n+\t  if (i < defn->nargs-1)\n+\t    CPP_PUTS_Q (pfile, \", \", 2);\n+\t}\n+\n+      if (defn->rest_args)\n+\tCPP_PUTS (pfile, \"...) \", 5);\n+      else\n+\tCPP_PUTS (pfile, \") \", 2);\n+\n+      /* Now the definition. */\n+      x = defn->expansion;\n+      for (r = defn->pattern; r; r = r->next)\n+      {\n+\ti = r->nchars;\n+\tif (*x == '\\r') x += 2, i -= 2;\n+\t/* i chars for macro text, plus the length of the macro\n+\t   argument name, plus one for a stringify marker, plus two for\n+\t   each concatenation marker. */\n+\tCPP_RESERVE (pfile,\n+\t\t     i + argl[r->argno] + r->stringify\n+\t\t     + (r->raw_before + r->raw_after) * 2);\n+\n+\tif (i > 0) CPP_PUTS_Q (pfile, x, i);\n+\tif (r->raw_before)\n+\t  CPP_PUTS_Q (pfile, \"##\", 2);\n+\tif (r->stringify)\n+\t  CPP_PUTC_Q (pfile, '#');\n+\tCPP_PUTS_Q (pfile, argv[r->argno], argl[r->argno]);\n+\tif (r->raw_after && !(r->next && r->next->nchars == 0\n+\t\t\t      && r->next->raw_before))\n+\t  CPP_PUTS_Q (pfile, \"##\", 2);\n+\n+\tx += i;\n+      }\n+\n+      i = defn->length - (x - defn->expansion) - 2;\n+      if (*x == '\\r') x += 2, i -= 2;\n+      if (i > 0) CPP_PUTS (pfile, x, i);\n+      CPP_NUL_TERMINATE (pfile);\n+    }\n+}"}, {"sha": "bb306d94e594c1b2955926b8879d9f5b61e244d0", "filename": "gcc/cpphash.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3caee4a8ee44a285efab9a80cf765c05f3209eb5/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3caee4a8ee44a285efab9a80cf765c05f3209eb5/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=3caee4a8ee44a285efab9a80cf765c05f3209eb5", "patch": "@@ -58,3 +58,4 @@ extern MACRODEF create_definition PARAMS ((U_CHAR *, U_CHAR *,\n extern int compare_defs\t\t  PARAMS ((cpp_reader *, DEFINITION *,\n \t\t\t\t\t   DEFINITION *));\n extern void macroexpand\t\t  PARAMS ((cpp_reader *, HASHNODE *));\n+extern void dump_definition\t  PARAMS ((cpp_reader *, MACRODEF));"}, {"sha": "9b2ecca459ac1c77df8897260b34854562fd3def", "filename": "gcc/cppinit.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3caee4a8ee44a285efab9a80cf765c05f3209eb5/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3caee4a8ee44a285efab9a80cf765c05f3209eb5/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=3caee4a8ee44a285efab9a80cf765c05f3209eb5", "patch": "@@ -1094,6 +1094,25 @@ cpp_finish (pfile)\n \t    }\n \t}\n     }\n+\n+  if (opts->dump_macros == dump_only)\n+    {\n+      int i;\n+      HASHNODE *h;\n+      MACRODEF m;\n+      for (i = HASHSIZE; --i >= 0;)\n+\t{\n+\t  for (h = pfile->hashtab[i]; h; h = h->next)\n+\t    if (h->type == T_MACRO)\n+\t      {\n+\t\tm.defn = h->value.defn;\n+\t\tm.symnam = h->name;\n+\t\tm.symlen = h->length;\n+\t\tdump_definition (pfile, m);\n+\t\tCPP_PUTC (pfile, '\\n');\n+\t      }\n+\t}\n+    }\n }\n \n /* Handle one command-line option in (argc, argv)."}, {"sha": "bcf40e1579e8d1e5a4e597b5a3ebb4b34a58cb40", "filename": "gcc/cpplib.c", "status": "modified", "additions": 92, "deletions": 146, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3caee4a8ee44a285efab9a80cf765c05f3209eb5/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3caee4a8ee44a285efab9a80cf765c05f3209eb5/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=3caee4a8ee44a285efab9a80cf765c05f3209eb5", "patch": "@@ -511,117 +511,62 @@ handle_directive (pfile)\n       if (CPP_PEDANTIC (pfile))\n \tcpp_pedwarn (pfile, \"`#' followed by integer\");\n       do_line (pfile, NULL);\n-      goto done_a_directive;\n+      return 1;\n     }\n \n   /* Now find the directive name.  */\n   CPP_PUTC (pfile, '#');\n   parse_name (pfile, GETC());\n   ident = pfile->token_buffer + old_written + 1;\n   ident_length = CPP_PWRITTEN (pfile) - ident;\n-  if (ident_length == 0 && PEEKC() == '\\n')\n+  if (ident_length == 0)\n     {\n       /* A line of just `#' becomes blank.  */\n-      goto done_a_directive;\n-    }\n-\n-#if 0\n-  if (ident_length == 0 || !is_idstart[*ident]) {\n-    U_CHAR *p = ident;\n-    while (is_idchar[*p]) {\n-      if (*p < '0' || *p > '9')\n-\tbreak;\n-      p++;\n-    }\n-    /* Avoid error for `###' and similar cases unless -pedantic.  */\n-    if (p == ident) {\n-      while (*p == '#' || is_hor_space[*p]) p++;\n-      if (*p == '\\n') {\n-\tif (pedantic && !lang_asm)\n-\t  cpp_warning (pfile, \"invalid preprocessor directive\");\n+      if (PEEKC() == '\\n')\n+\treturn 1;\n+      else\n \treturn 0;\n-      }\n     }\n \n-    if (!lang_asm)\n-      cpp_error (pfile, \"invalid preprocessor directive name\");\n-\n-    return 0;\n-  }\n-#endif\n   /*\n    * Decode the keyword and call the appropriate expansion\n    * routine, after moving the input pointer up to the next line.\n    */\n-  for (kt = directive_table; ; kt++) {\n-    if (kt->length <= 0)\n-      goto not_a_directive;\n-    if (kt->length == ident_length\n-\t&& !strncmp (kt->name, ident, ident_length)) \n-      break;\n-  }\n-\n-  /* We may want to pass through #define, #undef, #pragma, and #include.\n-     Other directives may create output, but we don't want the directive\n-     itself out, so we pop it now.  For example conditionals may emit\n-     #failed ... #endfailed stuff.  */\n-\n-  if (! (kt->type == T_DEFINE\n-\t || kt->type == T_PRAGMA\n-\t || (IS_INCLUDE_DIRECTIVE_TYPE (kt->type)\n-\t     && CPP_OPTIONS (pfile)->dump_includes)))\n-    CPP_SET_WRITTEN (pfile, old_written);\n-\n-  (*kt->func) (pfile, kt);\n-\n-  if (kt->type == T_DEFINE)\n+  for (kt = directive_table; ; kt++)\n     {\n-      if (CPP_OPTIONS (pfile)->dump_macros == dump_names)\n-\t{\n-\t  /* Skip \"#define\". */\n-\t  U_CHAR *p = pfile->token_buffer + old_written + 7;\n-\n-\t  SKIP_WHITE_SPACE (p);\n-\t  while (is_idchar[*p]) p++;\n-\t  pfile->limit = p;\n-\t  CPP_PUTC (pfile, '\\n');\n-\t}\n-      else if (CPP_OPTIONS (pfile)->dump_macros != dump_definitions)\n-\tCPP_SET_WRITTEN (pfile, old_written);\n+      if (kt->length <= 0)\n+\treturn 0;\n+      if (kt->length == ident_length\n+\t  && !strncmp (kt->name, ident, ident_length)) \n+\tbreak;\n     }\n \n- done_a_directive:\n-  return 1;\n+  CPP_SET_WRITTEN (pfile, old_written);\n+  (*kt->func) (pfile, kt);\n \n- not_a_directive:\n-  return 0;\n+  return 1;\n }\n \n /* Pass a directive through to the output file.\n    BUF points to the contents of the directive, as a contiguous string.\n-m   LIMIT points to the first character past the end of the directive.\n+   LEN is the length of the string pointed to by BUF.\n    KEYWORD is the keyword-table entry for the directive.  */\n \n static void\n-pass_thru_directive (buf, limit, pfile, keyword)\n-     U_CHAR *buf, *limit;\n+pass_thru_directive (buf, len, pfile, keyword)\n+     U_CHAR *buf;\n+     size_t len;\n      cpp_reader *pfile;\n      struct directive *keyword;\n {\n   register unsigned keyword_length = keyword->length;\n \n-  CPP_RESERVE (pfile, 1 + keyword_length + (limit - buf));\n+  CPP_RESERVE (pfile, 1 + keyword_length + len);\n   CPP_PUTC_Q (pfile, '#');\n   CPP_PUTS_Q (pfile, keyword->name, keyword_length);\n-  if (limit != buf && buf[0] != ' ')\n+  if (len != 0 && buf[0] != ' ')\n     CPP_PUTC_Q (pfile, ' ');\n-  CPP_PUTS_Q (pfile, buf, limit - buf);\n-#if 0\n-  CPP_PUTS_Q (pfile, '\\n');\n-  /* Count the line we have just made in the output,\n-     to get in sync properly.  */\n-  pfile->lineno++;\n-#endif\n+  CPP_PUTS_Q (pfile, buf, len);\n }\n \n /* Check a purported macro name SYMNAME, and yield its length.\n@@ -658,7 +603,6 @@ check_macro_name (pfile, symname, assertion)\n   return sym_length;\n }\n \n-\n /* Process a #define command.\n KEYWORD is the keyword-table entry for #define,\n or NULL for a \"predefined\" macro.  */\n@@ -686,15 +630,9 @@ do_define (pfile, keyword)\n \n   CPP_SET_WRITTEN (pfile, here);\n \n-#if 0\n-  /* If this is a precompiler run (with -pcp) pass thru #define commands.  */\n-  if (pcp_outfile && keyword)\n-    pass_thru_directive (macro, end, pfile, keyword);\n-#endif\n-\n   mdef = create_definition (macro, end, pfile, keyword == NULL);\n   if (mdef.defn == 0)\n-    goto nope;\n+    return 0;\n \n   hashcode = hashf (mdef.symnam, mdef.symlen, HASHSIZE);\n \n@@ -713,35 +651,30 @@ do_define (pfile, keyword)\n       /* Print the warning if it's not ok.  */\n       if (!ok)\n \t{\n-\t  /* If we are passing through #define and #undef directives, do\n-\t     that for this re-definition now.  */\n-\t  if (CPP_OPTIONS (pfile)->debug_output && keyword)\n-\t    pass_thru_directive (macro, end, pfile, keyword);\n-\n \t  cpp_pedwarn (pfile, \"`%.*s' redefined\", mdef.symlen, mdef.symnam);\n \t  if (hp->type == T_MACRO)\n-\t    cpp_pedwarn_with_file_and_line (pfile, hp->value.defn->file, hp->value.defn->line,\n-\t\t\t\t      \"this is the location of the previous definition\");\n+\t    cpp_pedwarn_with_file_and_line (pfile, hp->value.defn->file,\n+\t\t\t\t\t    hp->value.defn->line,\n+\t\t\t\"this is the location of the previous definition\");\n \t}\n       /* Replace the old definition.  */\n       hp->type = T_MACRO;\n       hp->value.defn = mdef.defn;\n     }\n   else\n+    cpp_install (pfile, mdef.symnam, mdef.symlen, T_MACRO,\n+\t\t (char *) mdef.defn, hashcode);\n+\n+  if (keyword)\n     {\n-      /* If we are passing through #define and #undef directives, do\n-\t that for this new definition now.  */\n-      if (CPP_OPTIONS (pfile)->debug_output && keyword)\n-\tpass_thru_directive (macro, end, pfile, keyword);\n-      cpp_install (pfile, mdef.symnam, mdef.symlen, T_MACRO,\n-\t\t   (char *) mdef.defn, hashcode);\n+      if (CPP_OPTIONS (pfile)->debug_output\n+\t  || CPP_OPTIONS (pfile)->dump_macros == dump_definitions)\n+\tdump_definition (pfile, mdef);\n+      else if (CPP_OPTIONS (pfile)->dump_macros == dump_names)\n+\tpass_thru_directive (mdef.symnam, mdef.symlen, pfile, keyword);\n     }\n \n   return 0;\n-\n-nope:\n-\n-  return 1;\n }\n \n \n@@ -1020,7 +953,7 @@ do_include (pfile, keyword)\n   int angle_brackets = 0;\t/* 0 for \"...\", 1 for <...> */\n   int before;  /* included before? */\n   long flen;\n-  unsigned char *fbeg, *fend;\n+  unsigned char *ftok;\n   cpp_buffer *fp;\n \n   enum cpp_token token;\n@@ -1046,7 +979,8 @@ do_include (pfile, keyword)\n       && !CPP_BUFFER (pfile)->system_header_p && !pfile->import_warning)\n     {\n       pfile->import_warning = 1;\n-      cpp_warning (pfile, \"`#import' is obsolete, use an #ifndef wrapper in the header file\");\n+      cpp_warning (pfile,\n+\t   \"#import is obsolete, use an #ifndef wrapper in the header file\");\n     }\n \n   pfile->parsing_include_directive++;\n@@ -1055,28 +989,20 @@ do_include (pfile, keyword)\n \n   if (token == CPP_STRING)\n     {\n-      fbeg = pfile->token_buffer + old_written + 1;\n-      fend = CPP_PWRITTEN (pfile) - 1;\n-      *fend = '\\0';\n-      if (fbeg[-1] == '<')\n-\t  angle_brackets = 1;\n+      if (pfile->token_buffer[old_written] == '<')\n+\tangle_brackets = 1;\n     }\n #ifdef VMS\n   else if (token == CPP_NAME)\n     {\n-      /* Support '#include xyz' like VAX-C to allow for easy use of\n-       * all the decwindow include files. It defaults to '#include\n-       * <xyz.h>' and generates a warning.  */\n+      /* Support '#include xyz' like VAX-C.  It is taken as\n+         '#include <xyz.h>' and generates a warning.  */\n       cpp_warning (pfile,\n-\t\t   \"VAX-C-style include specification found, use '#include <filename.h>' !\");\n+\t       \"`#include filename' is obsolete, use `#include <filename.h>'\");\n       angle_brackets = 1;\n \n       /* Append the missing `.h' to the name. */\n-      CPP_PUTS (pfile, \".h\", 3)\n-      CPP_NUL_TERMINATE_Q (pfile);\n-\n-      fbeg = pfile->token_buffer + old_written;\n-      fend = CPP_PWRITTEN (pfile);\n+      CPP_PUTS (pfile, \".h\", 2);\n     }\n #endif\n   else\n@@ -1088,23 +1014,42 @@ do_include (pfile, keyword)\n       return 0;\n     }\n \n-  token = get_directive_token (pfile);\n-  if (token != CPP_VSPACE)\n+  flen = CPP_WRITTEN (pfile) - old_written;\n+  ftok = alloca (flen + 1);\n+  memcpy (ftok, pfile->token_buffer + old_written, flen);\n+  ftok[flen] = '\\0';\n+\n+  if (get_directive_token (pfile) != CPP_VSPACE)\n     {\n       cpp_error (pfile, \"junk at end of `#include'\");\n       skip_rest_of_line (pfile);\n     }\n \n   CPP_SET_WRITTEN (pfile, old_written);\n \n-  flen = fend - fbeg;\n-\n   if (flen == 0)\n     {\n       cpp_error (pfile, \"empty file name in `#%s'\", keyword->name);\n       return 0;\n     }\n \n+  if (CPP_OPTIONS (pfile)->dump_includes)\n+    pass_thru_directive (ftok,\n+\t\t\t flen\n+#ifdef VMS\n+\t  - ((token == CPP_NAME) ? 2 : 0)\n+#endif\n+\t\t\t , pfile, keyword);\n+\n+#ifdef VMS\n+  if (token == CPP_STRING)\n+#endif\n+    {\n+      ftok++;\n+      flen -= 2;\n+      ftok[flen] = '\\0';\n+    }\n+\n   search_start = 0;\n \n   for (fp = CPP_BUFFER (pfile);\n@@ -1116,7 +1061,7 @@ do_include (pfile, keyword)\n   if (fp == CPP_NULL_BUFFER (pfile))\n     {\n       cpp_fatal (pfile, \"cpp internal error: fp == NULL_BUFFER in do_include\");\n-      return 1;\n+      return 0;\n     }\n   \n   /* For #include_next, skip in the search path past the dir in which the\n@@ -1149,11 +1094,11 @@ do_include (pfile, keyword)\n \n   if (!search_start)\n     {\n-      cpp_error (pfile, \"No include path in which to find %s\", fbeg);\n+      cpp_error (pfile, \"No include path in which to find %s\", ftok);\n       return 0;\n     }\n \n-  fd = find_include_file (pfile, fbeg, search_start, &ihash, &before);\n+  fd = find_include_file (pfile, ftok, search_start, &ihash, &before);\n \n   if (fd == -2)\n     return 0;\n@@ -1165,7 +1110,7 @@ do_include (pfile, keyword)\n \t\t\t\t       (pfile->system_include_depth > 0)))\n         {\n \t  if (!angle_brackets)\n-\t    deps_output (pfile, fbeg, ' ');\n+\t    deps_output (pfile, ftok, ' ');\n \t  else\n \t    {\n \t      char *p;\n@@ -1178,13 +1123,13 @@ do_include (pfile, keyword)\n \t        ptr = CPP_OPTIONS (pfile)->quote_include;\n \n \t      p = (char *) alloca (strlen (ptr->name)\n-\t\t\t\t   + strlen (fbeg) + 2);\n+\t\t\t\t   + strlen (ftok) + 2);\n \t      if (*ptr->name != '\\0')\n \t        {\n \t\t  strcpy (p, ptr->name);\n \t\t  strcat (p, \"/\");\n \t        }\n-\t      strcat (p, fbeg);\n+\t      strcat (p, ftok);\n \t      deps_output (pfile, p, ' ');\n \t    }\n \t}\n@@ -1197,9 +1142,9 @@ do_include (pfile, keyword)\n       else if (CPP_PRINT_DEPS (pfile)\n \t       && (CPP_PRINT_DEPS (pfile)\n \t\t   <= (angle_brackets || (pfile->system_include_depth > 0))))\n-\tcpp_warning (pfile, \"No include path in which to find %s\", fbeg);\n+\tcpp_warning (pfile, \"No include path in which to find %s\", ftok);\n       else\n-\tcpp_error_from_errno (pfile, fbeg);\n+\tcpp_error_from_errno (pfile, ftok);\n \n       return 0;\n     }\n@@ -1410,20 +1355,14 @@ do_undef (pfile, keyword)\n \n   CPP_SET_WRITTEN (pfile, here);\n \n-#if 0\n-  /* If this is a precompiler run (with -pcp) pass thru #undef commands.  */\n-  if (pcp_outfile && keyword)\n-    pass_thru_directive (buf, limit, pfile, keyword);\n-#endif\n-\n   sym_length = check_macro_name (pfile, buf, 0);\n \n   while ((hp = cpp_lookup (pfile, name, sym_length, -1)) != NULL)\n     {\n       /* If we are generating additional info for debugging (with -g) we\n \t need to pass through all effective #undef commands.  */\n       if (CPP_OPTIONS (pfile)->debug_output && keyword)\n-\tpass_thru_directive (name, name+sym_length, pfile, keyword);\n+\tpass_thru_directive (name, sym_length, pfile, keyword);\n       if (hp->type != T_MACRO)\n \tcpp_warning (pfile, \"undefining `%s'\", hp->name);\n       delete_macro (hp);\n@@ -1494,7 +1433,10 @@ do_warning (pfile, keyword)\n   return 0;\n }\n \n-/* Report program identification.  */\n+/* Report program identification.\n+   This is not precisely what cccp does with #ident, however I believe\n+   it matches `closely enough' (behavior is identical as long as there\n+   are no macros on the #ident line, which is pathological in my opinion).  */\n \n static int\n do_ident (pfile, keyword)\n@@ -1505,7 +1447,9 @@ do_ident (pfile, keyword)\n   if (CPP_PEDANTIC (pfile) && !CPP_BUFFER (pfile)->system_header_p)\n     cpp_pedwarn (pfile, \"ANSI C does not allow `#ident'\");\n \n-  skip_rest_of_line (pfile);  /* Correct?  Appears to match cccp.  */\n+  CPP_PUTS (pfile, \"#ident \", 7);\n+  cpp_skip_hspace (pfile);\n+  copy_rest_of_line (pfile);\n \n   return 0;\n }\n@@ -1518,12 +1462,15 @@ do_pragma (pfile, keyword)\n      cpp_reader *pfile;\n      struct directive *keyword ATTRIBUTE_UNUSED;\n {\n-  long here = CPP_WRITTEN (pfile);\n+  long here;\n   U_CHAR *buf;\n+\n+  CPP_PUTS (pfile, \"#pragma \", 8);\n+  cpp_skip_hspace (pfile);\n   \n+  here = CPP_WRITTEN (pfile);\n   copy_rest_of_line (pfile);\n   buf = pfile->token_buffer + here;\n-  SKIP_WHITE_SPACE (buf);\n   \n   if (!strncmp (buf, \"once\", 4))\n     {\n@@ -1547,8 +1494,7 @@ do_pragma (pfile, keyword)\n       else\n \tip->ihash->control_macro = \"\";  /* never repeat */\n     }\n-\n-  if (!strncmp (buf, \"implementation\", 14))\n+  else if (!strncmp (buf, \"implementation\", 14))\n     {\n       /* Be quiet about `#pragma implementation' for a file only if it hasn't\n \t been included yet.  */\n@@ -2831,9 +2777,9 @@ do_assert (pfile, keyword)\n   return 0;\n \n  error:\n-  pfile->limit = (unsigned char *) sym; /* Pop */\n   skip_rest_of_line (pfile);\n-  return 1;\n+  pfile->limit = (unsigned char *) sym; /* Pop */\n+  return 0;\n }\n \n static int\n@@ -2900,9 +2846,9 @@ do_unassert (pfile, keyword)\n   pfile->limit = (unsigned char *) sym; /* Pop */\n   return 0;\n  error:\n-  pfile->limit = (unsigned char *) sym; /* Pop */\n   skip_rest_of_line (pfile);\n-  return 1;\n+  pfile->limit = (unsigned char *) sym; /* Pop */\n+  return 0;\n }\n \n /* Process STR as if it appeared as the body of an #unassert. */"}, {"sha": "e7d82b5429ba2161f3eff280990fd8e60183f593", "filename": "gcc/cppmain.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3caee4a8ee44a285efab9a80cf765c05f3209eb5/gcc%2Fcppmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3caee4a8ee44a285efab9a80cf765c05f3209eb5/gcc%2Fcppmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmain.c?ref=3caee4a8ee44a285efab9a80cf765c05f3209eb5", "patch": "@@ -94,6 +94,7 @@ main (argc, argv)\n     }\n \n   cpp_finish (&parse_in);\n+  fwrite (parse_in.token_buffer, 1, CPP_WRITTEN (&parse_in), stdout);\n \n   if (parse_in.errors)\n     exit (FATAL_EXIT_CODE);"}]}