{"sha": "48c528ae3a2fddd58a7e45b9ef334b42c1ea1686", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDhjNTI4YWUzYTJmZGRkNThhN2U0NWI5ZWYzMzRiNDJjMWVhMTY4Ng==", "commit": {"author": {"name": "DJ Delorie", "email": "dj@redhat.com", "date": "2015-01-17T02:57:53Z"}, "committer": {"name": "DJ Delorie", "email": "dj@gcc.gnu.org", "date": "2015-01-17T02:57:53Z"}, "message": "rl78-real.md (addqi3_real): Allow volatiles.\n\n* config/rl78/rl78-real.md (addqi3_real): Allow volatiles.\n(addhi3_real): Likewise.  Fix [HL+0] syntax.\n(subqi3_real): Likewise.\n(subhi3_real): Likewise.\n(cbranchqi4_real): Likewise.  Allow saddr,#imm.\n(cbranchhi4_real): Likewise.\n(cbranchhi4_real_inverted): Likewise.\n(cbranchsi4_real_lt): Likewise.\n(cbranchsi4_real_ge): Likewise.\n(cbranchsi4_real_ge): Likewise.\n* config/rl78/rl78-virt.md (add<mode>3_virt): Likewise.\n(sub<mode>3_virt): Likewise.\n(cbranchqi4_virt): Likewise.\n(cbranchhi4_virt): Likewise.\n* config/rl78/rl78.c (rl78_print_operand_1): 'p' modifier means\nalways use '[reg+imm]' even when imm is zero.\n* config/rl78/predicates.md (rl78_volatile_memory_operand): New.\n(rl78_general_operand): New.\n(rl78_nonimmediate_operand): New.\n(rl78_nonfar_operand): Use them.\n(rl78_nonfar_nonimm_operand): Likewise.\n(rl78_stack_based_mem): Fix.\n* config/rl78/constraints.md (Ibqi): New.\n(IBqi): New.\n(Wsa): New.\n(Wsf): New.\n(Cs1): Fix.\n* config/rl78/rl78-expand.md (andqi3): Accept volatiles.\n(iorqi3): Likewise.\n(xorqi3): Likewise.\n* config/rl78/rl78-protos.h (rl78_sfr_p): New.\n\n        * config/rl78/constrains (Qs8): New constraint.\n        * config/rl78/rl78.c (rl78_flags_already_set): New function.\n        * config/rl78/rl78-protos.h (rl78_flags_already_set): New prototype.\n        * config/rl78/rl78-real.md (update_Z): New attribute.\n        Update patterns to set it.\n        (cbranchqi4_real): Call rl78_flags_already_set() to determine if a\n        shorter compare and branch sequence can be used.\n        (cbranchhi4_real): Likewise.\n        (cbranchhi4_real_inverted): Likewise.\n\n* config/rl78/predicates.md (uword_operand): Allow symbol_refs.\n* config/rl78/rl78-c.c (rl78_register_pragmas): Register __near\naddress space.\n* config/rl78/rl78.c (rl78_get_name_encoding): New.\n(rl78_option_override): Allow -mes0 only if C.\n(characterize_address): Support subregs of symbol_refs.\n(rl78_addr_space_address_mode): Move.  Add __near.\n(rl78_far_p): Likewise.\n(rl78_addr_space_pointer_mode): Likewise.\n(rl78_as_legitimate_address): Likewise.\n(rl78_addr_space_subset_p): Likewise.\n(rl78_addr_space_convert): Likewise.\n(rl78_print_operand_1): Support 16-bit addressing of 32-bit\nsymbols with -mes0.\n(transcode_memory_rtx): Don't copy ES if -mes0.  Allow symbol[BC]\naddressing.\n(rl78_alloc_physical_registers_op1): Change logic to prefer\nsymbol[BC] addressing.\n(frodata_section): New.\n(rl78_asm_init_sections): Initialize it.\n(rl78_select_section): Put __far readonly symbols in .frodata.\n(rl78_make_type_far): New.\n(rl78_insert_attributes): Force all readonly symbols to be __far when -mes0.\n(rl78_asm_out_integer): New.\n* config/rl78/rl78.h (ADDR_SPACE_NEAR): New.\n* config/rl78/rl78.opt (-mes0): New.\n\n* config/rl78/rl78.h (ASM_OUTPUT_LABELREF): New.\n(ASM_OUTPUT_ALIGNED_DECL_COMMON): New.\n(ASM_OUTPUT_ALIGNED_DECL_LOCAL): New.\n* config/rl78/rl78-protos.h (rl78_output_labelref): New.\n(rl78_saddr_p): New.\n(rl78_output_aligned_common): New.\n* config/rl78/rl78.c (rl78_output_symbol_ref): Strip encodings.\n(rl78_handle_saddr_attribute): New.\n(rl78_handle_naked_attribute): New.\n(rl78_attribute_table): Add saddr.\n(rl78_print_operand_1): Don't print '!' on saddr operands.\n(rl78_print_operand_1): Strip encodings.\n(rl78_sfr_p): New.\n(rl78_strip_name_encoding): New.\n(rl78_attrlist_to_encoding): New.\n(rl78_encode_section_info): New.\n(rl78_asm_init_sections): New.\n(rl78_select_section): New.\n(rl78_output_labelref): New.\n(rl78_output_aligned_common): New.\n(rl78_asm_out_integer): New.\n(rl78_asm_ctor_dtor): New.\n(rl78_asm_constructor): New.\n(rl78_asm_destructor): New.\n\n* config/rl78/rl78-real.md (movqi_es): Rename to movqi_to_es.\n* config/rl78/rl78.c (rl78_expand_epilogue): Update.\n(transcode_memory_rtx): Update.\n(rl78_expand_epilogue): Use A_REG instead of 0.\n\nCo-Authored-By: Nick Clifton <nickc@redhat.com>\n\nFrom-SVN: r219791", "tree": {"sha": "a6dc530575b555ad5687e67f0b30f6cfa3c387ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a6dc530575b555ad5687e67f0b30f6cfa3c387ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/48c528ae3a2fddd58a7e45b9ef334b42c1ea1686", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48c528ae3a2fddd58a7e45b9ef334b42c1ea1686", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48c528ae3a2fddd58a7e45b9ef334b42c1ea1686", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48c528ae3a2fddd58a7e45b9ef334b42c1ea1686/comments", "author": null, "committer": null, "parents": [{"sha": "d31b87976f1722476ae6bfa8e6bcbf78f5350867", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d31b87976f1722476ae6bfa8e6bcbf78f5350867", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d31b87976f1722476ae6bfa8e6bcbf78f5350867"}], "stats": {"total": 1162, "additions": 1001, "deletions": 161}, "files": [{"sha": "9b9053a81b321548ff5258da3f1aad3f1c8a9fd2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48c528ae3a2fddd58a7e45b9ef334b42c1ea1686/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48c528ae3a2fddd58a7e45b9ef334b42c1ea1686/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=48c528ae3a2fddd58a7e45b9ef334b42c1ea1686", "patch": "@@ -1,3 +1,105 @@\n+2015-01-16  DJ Delorie  <dj@redhat.com>\n+\t    Nick Clifton  <nickc@redhat.com>\n+\n+\t* config/rl78/rl78-real.md (addqi3_real): Allow volatiles.\n+\t(addhi3_real): Likewise.  Fix [HL+0] syntax.\n+\t(subqi3_real): Likewise.\n+\t(subhi3_real): Likewise.\n+\t(cbranchqi4_real): Likewise.  Allow saddr,#imm.\n+\t(cbranchhi4_real): Likewise.\n+\t(cbranchhi4_real_inverted): Likewise.\n+\t(cbranchsi4_real_lt): Likewise.\n+\t(cbranchsi4_real_ge): Likewise.\n+\t(cbranchsi4_real_ge): Likewise.\n+\t* config/rl78/rl78-virt.md (add<mode>3_virt): Likewise.\n+\t(sub<mode>3_virt): Likewise.\n+\t(cbranchqi4_virt): Likewise.\n+\t(cbranchhi4_virt): Likewise.\n+\t* config/rl78/rl78.c (rl78_print_operand_1): 'p' modifier means\n+\talways use '[reg+imm]' even when imm is zero.\n+\t* config/rl78/predicates.md (rl78_volatile_memory_operand): New.\n+\t(rl78_general_operand): New.\n+\t(rl78_nonimmediate_operand): New.\n+\t(rl78_nonfar_operand): Use them.\n+\t(rl78_nonfar_nonimm_operand): Likewise.\n+\t(rl78_stack_based_mem): Fix.\n+\t* config/rl78/constraints.md (Ibqi): New.\n+\t(IBqi): New.\n+\t(Wsa): New.\n+\t(Wsf): New.\n+\t(Cs1): Fix.\n+\t* config/rl78/rl78-expand.md (andqi3): Accept volatiles.\n+\t(iorqi3): Likewise.\n+\t(xorqi3): Likewise.\n+\t* config/rl78/rl78-protos.h (rl78_sfr_p): New.\n+\n+        * config/rl78/constrains (Qs8): New constraint.\n+        * config/rl78/rl78.c (rl78_flags_already_set): New function.\n+        * config/rl78/rl78-protos.h (rl78_flags_already_set): New prototype.\n+        * config/rl78/rl78-real.md (update_Z): New attribute.\n+        Update patterns to set it.\n+        (cbranchqi4_real): Call rl78_flags_already_set() to determine if a\n+        shorter compare and branch sequence can be used.\n+        (cbranchhi4_real): Likewise.\n+        (cbranchhi4_real_inverted): Likewise.\n+\n+\t* config/rl78/predicates.md (uword_operand): Allow symbol_refs.\n+\t* config/rl78/rl78-c.c (rl78_register_pragmas): Register __near\n+\taddress space.\n+\t* config/rl78/rl78.c (rl78_get_name_encoding): New.\n+\t(rl78_option_override): Allow -mes0 only if C.\n+\t(characterize_address): Support subregs of symbol_refs.\n+\t(rl78_addr_space_address_mode): Move.  Add __near.\n+\t(rl78_far_p): Likewise.\n+\t(rl78_addr_space_pointer_mode): Likewise.\n+\t(rl78_as_legitimate_address): Likewise.\n+\t(rl78_addr_space_subset_p): Likewise.\n+\t(rl78_addr_space_convert): Likewise.\n+\t(rl78_print_operand_1): Support 16-bit addressing of 32-bit\n+\tsymbols with -mes0.\n+\t(transcode_memory_rtx): Don't copy ES if -mes0.  Allow symbol[BC]\n+\taddressing.\n+\t(rl78_alloc_physical_registers_op1): Change logic to prefer\n+\tsymbol[BC] addressing.\n+\t(frodata_section): New.\n+\t(rl78_asm_init_sections): Initialize it.\n+\t(rl78_select_section): Put __far readonly symbols in .frodata.\n+\t(rl78_make_type_far): New.\n+\t(rl78_insert_attributes): Force all readonly symbols to be __far when -mes0.\n+\t(rl78_asm_out_integer): New.\n+\t* config/rl78/rl78.h (ADDR_SPACE_NEAR): New.\n+\t* config/rl78/rl78.opt (-mes0): New.\n+\n+\t* config/rl78/rl78.h (ASM_OUTPUT_LABELREF): New.\n+\t(ASM_OUTPUT_ALIGNED_DECL_COMMON): New.\n+\t(ASM_OUTPUT_ALIGNED_DECL_LOCAL): New.\n+\t* config/rl78/rl78-protos.h (rl78_output_labelref): New.\n+\t(rl78_saddr_p): New.\n+\t(rl78_output_aligned_common): New.\n+\t* config/rl78/rl78.c (rl78_output_symbol_ref): Strip encodings.\n+\t(rl78_handle_saddr_attribute): New.\n+\t(rl78_handle_naked_attribute): New.\n+\t(rl78_attribute_table): Add saddr.\n+\t(rl78_print_operand_1): Don't print '!' on saddr operands.\n+\t(rl78_print_operand_1): Strip encodings.\n+\t(rl78_sfr_p): New.\n+\t(rl78_strip_name_encoding): New.\n+\t(rl78_attrlist_to_encoding): New.\n+\t(rl78_encode_section_info): New.\n+\t(rl78_asm_init_sections): New.\n+\t(rl78_select_section): New.\n+\t(rl78_output_labelref): New.\n+\t(rl78_output_aligned_common): New.\n+\t(rl78_asm_out_integer): New.\n+\t(rl78_asm_ctor_dtor): New.\n+\t(rl78_asm_constructor): New.\n+\t(rl78_asm_destructor): New.\n+\n+\t* config/rl78/rl78-real.md (movqi_es): Rename to movqi_to_es.\n+\t* config/rl78/rl78.c (rl78_expand_epilogue): Update.\n+\t(transcode_memory_rtx): Update.\n+\t(rl78_expand_epilogue): Use A_REG instead of 0.\n+\n 2015-01-17  Maxim Kuvyrkov  <maxim.kuvyrkov@linaro.org>\n \n \t* config/arm/arm-protos.h (struct tune_params): New field"}, {"sha": "209f1e660a176c343f15671005278484a6ff40eb", "filename": "gcc/config/rl78/constraints.md", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48c528ae3a2fddd58a7e45b9ef334b42c1ea1686/gcc%2Fconfig%2Frl78%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48c528ae3a2fddd58a7e45b9ef334b42c1ea1686/gcc%2Fconfig%2Frl78%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Fconstraints.md?ref=48c528ae3a2fddd58a7e45b9ef334b42c1ea1686", "patch": "@@ -111,6 +111,17 @@\n   (and (match_code \"const_int\")\n        (match_test \"(ival & 0x80) != 0\")))\n \n+(define_constraint \"Ibqi\"\n+  \"@internal\n+   Integer constant with one bit in 0..7 set.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"(ival & 0xff) && (exact_log2 (ival & 0xff) >= 0)\")))\n+(define_constraint \"IBqi\"\n+  \"@internal\n+   Integer constant with one bit in 0..7 clear.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"(~ival & 0xff) && (exact_log2 (~ival & 0xff) >= 0)\")))\n+\n (define_constraint \"J\"\n   \"Integer constant in the range -255 @dots{} 0\"\n   (and (match_code \"const_int\")\n@@ -342,9 +353,11 @@\n \t(and (match_code \"plus\" \"0\")\n \t     (and (and (match_code \"reg\" \"00\")\n \t\t       (match_test \"REGNO (XEXP (XEXP (op, 0), 0)) == SP_REG\"))\n-\t\t       (match_test \"ubyte_operand (XEXP (XEXP (op, 0), 1), VOIDmode)\"))))\n+\t\t       (and (match_code \"const_int\" \"01\")\n+\t\t            (match_test \"IN_RANGE (INTVAL (XEXP (XEXP (op, 0), 1)), 0, 256 - GET_MODE_SIZE (GET_MODE (op)))\")))))\n        )\n   )\n+\n (define_memory_constraint \"Ws1\"\n   \"es:word8[SP]\"\n   (match_test \"(rl78_es_addr (op) && satisfies_constraint_Cs1 (rl78_es_base (op)))\n@@ -357,6 +370,18 @@\n        (match_test \"rl78_far_p (op)\"))\n   )\n \n+(define_memory_constraint \"Wsa\"\n+  \"any SADDR memory access\"\n+  (and (match_code \"mem\")\n+       (match_test \"rl78_saddr_p (op)\"))\n+)\n+\n+(define_memory_constraint \"Wsf\"\n+  \"any SFR memory access\"\n+  (and (match_code \"mem\")\n+       (match_test \"rl78_sfr_p (op)\"))\n+)\n+\n (define_memory_constraint \"Y\"\n   \"any near legitimate memory access\"\n   (and (match_code \"mem\")\n@@ -384,3 +409,9 @@\n (define_memory_constraint \"Qsc\"\n   \"synthetic compares\"\n   (match_code \"gt,lt,ge,le\"))\n+\n+(define_constraint \"Qs8\"\n+  \"Integer constant computed from (SUBREG (SYMREF)).\"\n+  (and (match_code \"subreg\")\n+       (match_test \"GET_CODE (XEXP (op, 0)) == SYMBOL_REF\"))\n+)"}, {"sha": "b89eed22400a3b0c92a9e67d244dd38a540bcd1f", "filename": "gcc/config/rl78/predicates.md", "status": "modified", "additions": 31, "deletions": 8, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48c528ae3a2fddd58a7e45b9ef334b42c1ea1686/gcc%2Fconfig%2Frl78%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48c528ae3a2fddd58a7e45b9ef334b42c1ea1686/gcc%2Fconfig%2Frl78%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Fpredicates.md?ref=48c528ae3a2fddd58a7e45b9ef334b42c1ea1686", "patch": "@@ -18,18 +18,34 @@\n ;; along with GCC; see the file COPYING3.  If not see\n ;; <http://www.gnu.org/licenses/>.\n \f\n-(define_predicate \"rl78_any_operand\"\n+\n+(define_predicate \"rl78_volatile_memory_operand\"\n+  (and (match_code \"mem\")\n+       (match_test (\"memory_address_addr_space_p (GET_MODE (op), XEXP (op, 0), MEM_ADDR_SPACE (op))\")))\n+)\n+\n+; TRUE for any valid general operand.  We do this because\n+; general_operand refuses to match volatile memory refs.\n+\n+(define_predicate \"rl78_general_operand\"\n   (ior (match_operand 0 \"general_operand\")\n-       (match_code \"mem,const_int,const_double,reg\"))\n+       (match_operand 0 \"rl78_volatile_memory_operand\"))\n+)\n+\n+; Likewise for nonimmediate_operand.\n+\n+(define_predicate \"rl78_nonimmediate_operand\"\n+  (ior (match_operand 0 \"nonimmediate_operand\")\n+       (match_operand 0 \"rl78_volatile_memory_operand\"))\n )\n \n (define_predicate \"rl78_nonfar_operand\"\n-  (and (match_operand 0 \"general_operand\")\n+  (and (match_operand 0 \"rl78_general_operand\")\n        (not (match_test \"rl78_far_p (op)\")))\n )\n \n (define_predicate \"rl78_nonfar_nonimm_operand\"\n-  (and (match_operand 0 \"nonimmediate_operand\")\n+  (and (match_operand 0 \"rl78_nonimmediate_operand\")\n        (not (match_test \"rl78_far_p (op)\")))\n )\n \n@@ -47,9 +63,14 @@\n        (match_test \"INTVAL (op) == 2 || INTVAL (op) == 4\")))\n \n (define_predicate \"uword_operand\"\n-  (ior (match_code \"const\")\n-       (and (match_code \"const_int\")\n-\t    (match_test \"IN_RANGE (INTVAL (op), 0, 65536)\"))))\n+  (ior (ior (ior (match_code \"const\")\n+\t\t (and (match_code \"const_int\")\n+\t\t      (match_test \"IN_RANGE (INTVAL (op), 0, 65536)\")))\n+\t    (and (match_code \"subreg\")\n+\t\t (ior (match_code \"symbol_ref\" \"0\")\n+\t\t      (match_code \"const\" \"0\"))))\n+       (match_code \"symbol_ref\")\n+       ))\n \n (define_predicate \"rl78_cmp_operator_signed\"\n   (match_code \"gt,ge,lt,le\"))\n@@ -73,4 +94,6 @@\n \t    (and (match_code \"plus\" \"0\")\n \t\t (and (match_code \"reg\" \"00\")\n \t\t      (match_test \"REGNO (XEXP (XEXP (op, 0), 0)) == SP_REG\")\n-\t\t      (match_code \"const_int\" \"01\"))))))\n+\t\t      (and (match_code \"const_int\" \"01\")\n+\t\t\t   (match_test \"IN_RANGE (INTVAL (XEXP (XEXP (op, 0), 1)), 0, 256 - GET_MODE_SIZE (GET_MODE (op)))\"))\n+\t\t\t   )))))"}, {"sha": "c8410cdb4cc92ef2d49490e1ab47367399f13cbb", "filename": "gcc/config/rl78/rl78-c.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48c528ae3a2fddd58a7e45b9ef334b42c1ea1686/gcc%2Fconfig%2Frl78%2Frl78-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48c528ae3a2fddd58a7e45b9ef334b42c1ea1686/gcc%2Fconfig%2Frl78%2Frl78-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78-c.c?ref=48c528ae3a2fddd58a7e45b9ef334b42c1ea1686", "patch": "@@ -39,5 +39,6 @@\n void\n rl78_register_pragmas (void)\n {\n+  c_register_addr_space (\"__near\", ADDR_SPACE_NEAR);\n   c_register_addr_space (\"__far\", ADDR_SPACE_FAR);\n }"}, {"sha": "ac3939d3ea994808d7ffca5616386de2e9c824a8", "filename": "gcc/config/rl78/rl78-expand.md", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48c528ae3a2fddd58a7e45b9ef334b42c1ea1686/gcc%2Fconfig%2Frl78%2Frl78-expand.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48c528ae3a2fddd58a7e45b9ef334b42c1ea1686/gcc%2Fconfig%2Frl78%2Frl78-expand.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78-expand.md?ref=48c528ae3a2fddd58a7e45b9ef334b42c1ea1686", "patch": "@@ -150,29 +150,29 @@\n )\n \n (define_expand \"andqi3\"\n-  [(set (match_operand:QI         0 \"nonimmediate_operand\")\n-\t(and:QI (match_operand:QI 1 \"general_operand\")\n-\t\t(match_operand:QI 2 \"general_operand\")))\n+  [(set (match_operand:QI         0 \"rl78_nonimmediate_operand\")\n+\t(and:QI (match_operand:QI 1 \"rl78_general_operand\")\n+\t\t(match_operand:QI 2 \"rl78_general_operand\")))\n    ]\n   \"\"\n   \"if (rl78_force_nonfar_3 (operands, gen_andqi3))\n      DONE;\"\n )\n \n (define_expand \"iorqi3\"\n-  [(set (match_operand:QI         0 \"nonimmediate_operand\")\n-\t(ior:QI (match_operand:QI 1 \"general_operand\")\n-\t\t(match_operand:QI 2 \"general_operand\")))\n+  [(set (match_operand:QI         0 \"rl78_nonimmediate_operand\")\n+\t(ior:QI (match_operand:QI 1 \"rl78_general_operand\")\n+\t\t(match_operand:QI 2 \"rl78_general_operand\")))\n    ]\n   \"\"\n   \"if (rl78_force_nonfar_3 (operands, gen_iorqi3))\n      DONE;\"\n )\n \n (define_expand \"xorqi3\"\n-  [(set (match_operand:QI         0 \"nonimmediate_operand\")\n-\t(xor:QI (match_operand:QI 1 \"general_operand\")\n-\t\t(match_operand:QI 2 \"general_operand\")))\n+  [(set (match_operand:QI         0 \"rl78_nonimmediate_operand\")\n+\t(xor:QI (match_operand:QI 1 \"rl78_general_operand\")\n+\t\t(match_operand:QI 2 \"rl78_general_operand\")))\n    ]\n   \"\"\n   \"if (rl78_force_nonfar_3 (operands, gen_xorqi3))"}, {"sha": "56d3649376affb98d39345b8e5c5d20953f3de08", "filename": "gcc/config/rl78/rl78-protos.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48c528ae3a2fddd58a7e45b9ef334b42c1ea1686/gcc%2Fconfig%2Frl78%2Frl78-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48c528ae3a2fddd58a7e45b9ef334b42c1ea1686/gcc%2Fconfig%2Frl78%2Frl78-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78-protos.h?ref=48c528ae3a2fddd58a7e45b9ef334b42c1ea1686", "patch": "@@ -45,3 +45,11 @@ bool\t\trl78_virt_insns_ok (void);\n \n bool\t\trl78_es_addr (rtx);\n rtx\t\trl78_es_base (rtx);\n+\n+bool\t\trl78_flags_already_set (rtx, rtx);\n+void\t\trl78_output_symbol_ref (FILE *, rtx);\n+void\t\trl78_output_labelref (FILE *, const char *);\n+int\t\trl78_saddr_p (rtx x);\n+int\t\trl78_sfr_p (rtx x);\n+void\t\trl78_output_aligned_common (FILE *, tree, const char *,\n+\t\t\t\t\t    int, int, int);"}, {"sha": "8ec2f3d6a6f5a2f91bbb7f522aaa3dceb179a100", "filename": "gcc/config/rl78/rl78-real.md", "status": "modified", "additions": 138, "deletions": 63, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48c528ae3a2fddd58a7e45b9ef334b42c1ea1686/gcc%2Fconfig%2Frl78%2Frl78-real.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48c528ae3a2fddd58a7e45b9ef334b42c1ea1686/gcc%2Fconfig%2Frl78%2Frl78-real.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78-real.md?ref=48c528ae3a2fddd58a7e45b9ef334b42c1ea1686", "patch": "@@ -27,9 +27,17 @@\n ;; patterns - other than the constraints - so that the operand info is\n ;; properly set up for the alloc pass.\n \n+;; This attribute reflects how the insn alters the Z flag,\n+;; based upon the value of the it's output.  The default is NO\n+;; for no change, but other possibilities are UPDATE_Z if it changes\n+;; the Z flag and CLOBBER if the state of the flag is indeterminate.\n+;; The CY and AC flags are not set in the same way as the Z flag, so\n+;; their values are not tracked.\n+(define_attr \"update_Z\" \"no,update_Z,clobber\" (const_string \"no\"))\n+\n ;;---------- Moving ------------------------\n \n-(define_insn \"movqi_es\"\n+(define_insn \"movqi_to_es\"\n   [(set (reg:QI ES_REG)\n \t(match_operand:QI 0 \"register_operand\" \"a\"))]\n   \"\"\n@@ -51,8 +59,8 @@\n )\n \n (define_insn \"*movqi_real\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=g,RaxbcWab,RaxbcWab,a,                          bcx,R, WabWd2WhlWh1WhbWbcWs1v, bcx\")\n-\t(match_operand    1 \"general_operand\"      \"0,K,        M,       RInt8sJvWabWdeWd2WhlWh1WhbWbcWs1,Wab,aInt8J,a,                      R\"))]\n+  [(set (match_operand:QI 0 \"rl78_nonimmediate_operand\" \"=g,RaxbcWab,RaxbcWab,a,                               bcx,R,     WabWd2WhlWh1WhbWbcWs1v, bcx,WsaWsf\")\n+\t(match_operand    1 \"rl78_general_operand\"      \"0,K,        M,       RInt8sJvWabWdeWd2WhlWh1WhbWbcWs1,Wab,aInt8J,a,                      R,  i\"))]\n   \"rl78_real_insns_ok ()\"\n   \"@\n    ; mov\\t%0, %1\n@@ -62,12 +70,13 @@\n    mov\\t%0, %1\n    mov\\t%0, %1\n    mov\\t%0, %1\n-   mov\\t%0, %S1\"\n+   mov\\t%0, %S1\n+   mov\\t%0, %1\"\n )\n \n (define_insn \"*movhi_real\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=g,AB,AB,RSv,A,BDTvSWabWd2WdeWhlWh1WbcWs1, BDT,ABDT,v\")\n-\t(match_operand:HI 1 \"general_operand\"      \" 0,K, M, i,  BDTvSWabWd2WdeWh1WhlWbcWs1,A, BDT,vS,  ABDT\"))]\n+  [(set (match_operand:HI 0 \"rl78_nonimmediate_operand\" \"=g,AB,AB,RSv,A,BDTvSWabWd2WdeWhlWh1WbcWs1, BDT,ABDT,v\")\n+\t(match_operand:HI 1 \"rl78_general_operand\"      \" 0,K, M, i,  BDTvSWabWd2WdeWh1WhlWbcWs1,A, BDT,vS,  ABDT\"))]\n   \"rl78_real_insns_ok ()\"\n   \"@\n    ; movw\\t%0, %1\n@@ -104,33 +113,36 @@\n ;;---------- Arithmetic ------------------------\n \n (define_insn \"*addqi3_real\"\n-  [(set (match_operand:QI          0 \"nonimmediate_operand\"  \"=rvWabWhlWh1,rvWabWhlWh1,a,*bcdehl\")\n-\t(plus:QI (match_operand:QI 1 \"general_operand\"  \"%0,0,0,0\")\n-\t\t (match_operand:QI 2 \"general_operand\" \"K,L,RWhlWh1Wabi,a\")))\n+  [(set (match_operand:QI          0 \"rl78_nonimmediate_operand\"  \"=rvWabWhlWh1,rvWabWhlWh1,a,*bcdehl,Wsa\")\n+\t(plus:QI (match_operand:QI 1 \"rl78_general_operand\"  \"%0,0,0,0,0\")\n+\t\t (match_operand:QI 2 \"rl78_general_operand\" \"K,L,RWhlWh1Wabi,a,i\")))\n    ]\n   \"rl78_real_insns_ok ()\"\n   \"@\n     inc\\t%0\n     dec\\t%0\n     add\\t%0, %2\n+    add\\t%0, %2\n     add\\t%0, %2\"\n+  [(set (attr \"update_Z\") (const_string \"update_Z\"))]\n )\n \n (define_insn \"*addhi3_real\"\n-  [(set (match_operand:HI          0 \"nonimmediate_operand\"  \"=vABDTWh1Wab,vABDTWh1Wab,v,v,A,S,S,A\")\n-\t(plus:HI (match_operand:HI 1 \"general_operand\"  \"%0,0,0,0,0,0,0,S\")\n-\t\t (match_operand:HI 2 \"general_operand\" \"K,L,N,O,RWh1WhlWabiv,Int8,J,Ri\")))\n+  [(set (match_operand:HI          0 \"rl78_nonimmediate_operand\"  \"=vABDTWh1Wab,vABDTWh1Wab,v,v,A,S,S,A\")\n+\t(plus:HI (match_operand:HI 1 \"rl78_general_operand\"  \"%0,0,0,0,0,0,0,S\")\n+\t\t (match_operand:HI 2 \"\" \"K,L,N,O,RWh1WhlWabiv,Int8Qs8,J,Ri\")))\n    ]\n   \"rl78_real_insns_ok ()\"\n   \"@\n-   incw\\t%0\n-   decw\\t%0\n+   incw\\t%p0\n+   decw\\t%p0\n    incw\\t%0 \\;incw\\t%0\n    decw\\t%0 \\;decw\\t%0\n    addw\\t%0, %p2\n    addw\\t%0, %2\n    subw\\t%0, %m2\n    movw\\t%0, %1 \\;addw\\t%0, %2\"\n+  [(set_attr \"update_Z\" \"*,*,*,*,update_Z,update_Z,update_Z,update_Z\")]\n )\n \n (define_insn \"*addqihi3a_real\"\n@@ -140,24 +152,27 @@\n    ]\n   \"rl78_real_insns_ok ()\"\n   \"add\\t%q0, %q1 \\;addc\\t%Q0, #0\"\n+  [(set (attr \"update_Z\") (const_string \"update_Z\"))]\n )\n \n (define_insn \"*subqi3_real\"\n   [(set (match_operand:QI           0 \"nonimmediate_operand\"  \"=a,R,v\")\n \t(minus:QI (match_operand:QI 1 \"general_operand\"  \"0,0,0\")\n-\t\t  (match_operand:QI 2 \"general_operand\" \"RiWabWhbWh1Whl,a,i\")))\n+\t\t  (match_operand:QI 2 \"rl78_general_operand\" \"RiWabWhbWh1Whl,a,i\")))\n    ]\n   \"rl78_real_insns_ok ()\"\n   \"sub\\t%0, %2\"\n+  [(set (attr \"update_Z\") (const_string \"update_Z\"))]\n )\n \n (define_insn \"*subhi3_real\"\n   [(set (match_operand:HI           0 \"nonimmediate_operand\"  \"=A,S\")\n \t(minus:HI (match_operand:HI 1 \"general_operand\"  \"0,0\")\n-\t\t  (match_operand:HI 2 \"general_operand\" \"iBDTWabWh1v,i\")))\n+\t\t  (match_operand:HI 2 \"rl78_general_operand\" \"iBDTWabWh1v,i\")))\n    ]\n   \"rl78_real_insns_ok ()\"\n   \"subw\\t%0, %2\"\n+  [(set (attr \"update_Z\") (const_string \"update_Z\"))]\n )\n \n (define_insn \"*umulhi3_shift_real\"\n@@ -179,30 +194,41 @@\n )\n \n (define_insn \"*andqi3_real\"\n-  [(set (match_operand:QI         0 \"nonimmediate_operand\"  \"=A,R,v\")\n-\t(and:QI (match_operand:QI 1 \"general_operand\"       \"%0,0,0\")\n-\t\t(match_operand:QI 2 \"general_operand\"       \"iRvWabWhbWh1Whl,A,i\")))\n+  [(set (match_operand:QI         0 \"rl78_nonimmediate_operand\"  \"=Wsf,A,R,vWsa\")\n+\t(and:QI (match_operand:QI 1 \"rl78_general_operand\"       \"%0,0,0,0\")\n+\t\t(match_operand:QI 2 \"rl78_general_operand\"       \"IBqi,iRvWabWhbWh1Whl,A,i\")))\n    ]\n   \"rl78_real_insns_ok ()\"\n-  \"and\\t%0, %2\"\n+  \"@\n+   clr1\\t%0.%B2\n+   and\\t%0, %2\n+   and\\t%0, %2\n+   and\\t%0, %2\"\n+  [(set_attr \"update_Z\" \"*,update_Z,update_Z,update_Z\")]\n )\n \n (define_insn \"*iorqi3_real\"\n-  [(set (match_operand:QI         0 \"nonimmediate_operand\"  \"=A,R,v\")\n-\t(ior:QI (match_operand:QI 1 \"general_operand\"       \"%0,0,0\")\n-\t\t(match_operand:QI 2 \"general_operand\"       \"iRvWabWhbWh1Whl,A,i\")))\n+  [(set (match_operand:QI         0 \"rl78_nonimmediate_operand\"  \"=Wsf,A,R,vWsa\")\n+\t(ior:QI (match_operand:QI 1 \"rl78_general_operand\"       \"%0,0,0,0\")\n+\t\t(match_operand:QI 2 \"rl78_general_operand\"       \"Ibqi,iRvWabWhbWh1Whl,A,i\")))\n    ]\n   \"rl78_real_insns_ok ()\"\n-  \"or\\t%0, %2\"\n+  \"@\n+   set1\\t%0.%B2\n+   or\\t%0, %2\n+   or\\t%0, %2\n+   or\\t%0, %2\"\n+  [(set_attr \"update_Z\" \"*,update_Z,update_Z,update_Z\")]\n )\n \n (define_insn \"*xorqi3_real\"\n-  [(set (match_operand:QI         0 \"nonimmediate_operand\"  \"=A,R,v\")\n-\t(xor:QI (match_operand:QI 1 \"general_operand\"       \"%0,0,0\")\n-\t\t(match_operand    2 \"general_operand\"       \"iRvWabWhbWh1Whl,A,i\")))\n+  [(set (match_operand:QI         0 \"rl78_nonimmediate_operand\"  \"=A,R,vWsa\")\n+\t(xor:QI (match_operand:QI 1 \"rl78_general_operand\"       \"%0,0,0\")\n+\t\t(match_operand    2 \"rl78_general_operand\"       \"iRvWabWhbWh1Whl,A,i\")))\n    ]\n   \"rl78_real_insns_ok ()\"\n   \"xor\\t%0, %2\"\n+  [(set (attr \"update_Z\") (const_string \"update_Z\"))]\n )\n \n ;;---------- Shifts ------------------------\n@@ -217,6 +243,7 @@\n    shl\\t%0, %u2\n    cmp0 %2\\; bz $2f\\; 1: shl\\t%0, 1 \\;dec %2 \\;bnz $1b\\;2:\n    inc %2\\;dec %2\\;bz $2f\\;1: shl\\t%0, 1 \\;dec %2 \\;bnz $1b\\;2:\"\n+  [(set_attr \"update_Z\" \"*,clobber,clobber\")]\n )\n \n (define_insn \"*ashlhi3_real\"\n@@ -229,6 +256,7 @@\n    shlw\\t%0, %u2\n    cmp0 %2\\; bz $2f\\; 1: shlw\\t%0, 1 \\;dec %2 \\;bnz $1b\\;2:\n    inc %2\\;dec %2\\;bz $2f\\;1: shlw\\t%0, 1 \\;dec %2 \\;bnz $1b\\;2:\"\n+  [(set_attr \"update_Z\" \"*,clobber,clobber\")]\n )\n \n ;;----------\n@@ -243,6 +271,7 @@\n    sar\\t%0, %u2\n    cmp0 %2\\; bz $2f\\; 1: sar\\t%0, 1 \\;dec %2 \\;bnz $1b\\;2:\n    inc %2\\;dec %2\\;bz $2f\\;1: sar\\t%0, 1\\;dec %2 \\;bnz $1b\\;2:\"\n+  [(set_attr \"update_Z\" \"*,clobber,clobber\")]\n )\n \n (define_insn \"*ashrhi3_real\"\n@@ -255,6 +284,7 @@\n    sarw\\t%0, %u2\n    cmp0 %2\\; bz $2f\\; 1: sarw\\t%0, 1 \\;dec %2 \\;bnz $1b\\;2:\n    inc %2\\;dec %2\\;bz $2f\\;1: sarw\\t%0, 1\\;dec %2\\;bnz $1b\\;2:\"\n+  [(set_attr \"update_Z\" \"*,clobber,clobber\")]\n )\n \n ;;----------\n@@ -269,6 +299,7 @@\n    shr\\t%0, %u2\n    cmp0 %2\\; bz $2f\\; 1: shr\\t%0, 1 \\;dec %2 \\;bnz $1b\\;2:\n    inc %2\\;dec %2\\;bz $2f\\;1: shr\\t%0, 1\\;dec %2\\;bnz $1b\\;2:\"\n+  [(set_attr \"update_Z\" \"*,clobber,clobber\")]\n )\n \n (define_insn \"*lshrhi3_real\"\n@@ -281,6 +312,7 @@\n    shrw\\t%0, %u2\n    cmp0 %2\\; bz $2f\\; 1: shrw\\t%0, 1 \\;dec %2 \\;bnz $1b\\;2:\n    inc %2\\;dec %2\\;bz $2f\\;1: shrw\\t%0, 1\\;dec %2\\;bnz $1b\\;2:\"\n+  [(set_attr \"update_Z\" \"*,clobber,clobber\")]\n )\n \n ;;---------- Branching ------------------------\n@@ -307,6 +339,7 @@\n   \"@\n    call\\t!!%A0\n    call\\t%A0\"\n+  [(set (attr \"update_Z\") (const_string \"clobber\"))]\n   )\n \n (define_insn \"*call_value_real\"\n@@ -317,35 +350,52 @@\n   \"@\n    call\\t!!%A1\n    call\\t%A1\"\n+  [(set (attr \"update_Z\") (const_string \"clobber\"))]\n   )\n \n (define_insn \"*cbranchqi4_real_signed\"\n   [(set (pc) (if_then_else\n \t      (match_operator 0 \"rl78_cmp_operator_signed\"\n-\t\t\t      [(match_operand:QI 1 \"general_operand\" \"A,A,A\")\n-\t\t\t       (match_operand:QI 2 \"general_operand\" \"ISqi,i,v\")])\n+\t\t\t      [(match_operand:QI 1 \"general_operand\" \"A,A,A,A,Wsa\")\n+\t\t\t       (match_operand:QI 2 \"general_operand\" \"M,ISqi,i,v,i\")])\n               (label_ref (match_operand 3 \"\" \"\"))\n \t      (pc)))]\n   \"rl78_real_insns_ok ()\"\n-  \"@\n-   cmp\\t%1, %2 \\;xor1 CY,%1.7\\;not1 CY\\;sk%C0 \\;br\\t!!%3\n-   cmp\\t%1, %2 \\;xor1 CY,%1.7\\;sk%C0 \\;br\\t!!%3\n-   cmp\\t%1, %2 \\;xor1 CY,%1.7\\;xor1 CY,%2.7\\;sk%C0 \\;br\\t!!%3\"\n+  {\n+    gcc_assert (GET_CODE (operands[0]) != EQ && GET_CODE (operands[0]) != NE);\n+\n+    switch (which_alternative)\n+    {\n+    case 0: return \"cmp0\\t%1\\; xor1\\tCY, %1.7\\; sk%C0\\; br\\t!!%3\";\n+    case 1: return \"cmp\\t%1, %2\\; xor1\\tCY, %1.7\\; not1\\tCY\\; sk%C0\\; br\\t!!%3\";\n+    case 4:\n+    case 2: return \"cmp\\t%1, %2\\; xor1\\tCY, %1.7\\; sk%C0\\; br\\t!!%3\";\n+    case 3: return \"cmp\\t%1, %2\\; xor1\\tCY, %1.7\\; xor1\\tCY, %2.7\\; sk%C0\\; br\\t!!%3\";\n+    default: gcc_unreachable ();\n+    }\n+  }   \n+  [(set (attr \"update_Z\") (const_string \"clobber\"))] ;; FIXME: flags are set based on %1 vs %2\n   )\n \n (define_insn \"*cbranchqi4_real\"\n   [(set (pc) (if_then_else\n \t      (match_operator 0 \"rl78_cmp_operator_real\"\n-\t\t\t      [(match_operand:QI 1 \"general_operand\" \"Wabvaxbc,a,              v,bcdehl\")\n-\t\t\t       (match_operand:QI 2 \"general_operand\" \"M,       irvWabWhlWh1Whb,i,a\")])\n+\t\t\t      [(match_operand:QI 1 \"rl78_general_operand\" \"Wabvaxbc,a,              vWsaWab,bcdehl\")\n+\t\t\t       (match_operand:QI 2 \"rl78_general_operand\" \"M,       irvWabWhlWh1Whb,i,a\")])\n               (label_ref (match_operand 3 \"\" \"\"))\n \t      (pc)))]\n   \"rl78_real_insns_ok ()\"\n-  \"@\n-   cmp0\\t%1 \\;sk%C0 \\;br\\t!!%3\n-   cmp\\t%1, %2 \\;sk%C0 \\;br\\t!!%3\n-   cmp\\t%1, %2 \\;sk%C0 \\;br\\t!!%3\n-   cmp\\t%1, %2 \\;sk%C0 \\;br\\t!!%3\"\n+  {\n+    if (which_alternative == 0)\n+      {\n+        if (rl78_flags_already_set (operands[0], operands[1]))\n+          return \"sk%C0\\; br\\t!!%3\\; # zero-comparison eliminated\";\n+\telse\n+\t  return \"cmp0\\t%1\\; sk%C0\\; br\\t!!%3\";\n+      }\n+    return \"cmp\\t%1, %2\\; sk%C0\\; br\\t!!%3\";\n+  }\n+  [(set (attr \"update_Z\") (const_string \"clobber\"))] ;; FIXME: alt 0: flags are set based on %1 vs %2\n   )\n \n (define_insn \"*cbranchhi4_real_signed\"\n@@ -357,62 +407,82 @@\n \t      (pc)))]\n   \"rl78_real_insns_ok ()\"\n   \"@\n-   cmpw\\t%1, %2 \\;xor1 CY,%Q1.7\\;not1 CY\\;sk%C0 \\;br\\t!!%3\n-   cmpw\\t%1, %2 \\;xor1 CY,%Q1.7\\;sk%C0 \\;br\\t!!%3\n-   cmpw\\t%1, %2 \\;xor1 CY,%Q1.7\\;xor1 CY,%Q2.7\\;sk%C0 \\;br\\t!!%3\n+   cmpw\\t%1, %2\\; xor1\\tCY, %Q1.7\\; not1\\tCY\\; sk%C0\\; br\\t!!%3\n+   cmpw\\t%1, %2\\; xor1\\tCY, %Q1.7\\; sk%C0\\; br\\t!!%3\n+   cmpw\\t%1, %2\\; xor1\\tCY, %Q1.7\\; xor1\\tCY, %Q2.7\\; sk%C0\\; br\\t!!%3\n    %z0\\t!!%3\"\n+  [(set_attr \"update_Z\" \"clobber,clobber,clobber,*\")]\n   )\n \n (define_insn \"cbranchhi4_real\"\n   [(set (pc) (if_then_else\n \t      (match_operator                    0 \"rl78_cmp_operator_real\"\n-\t\t\t      [(match_operand:HI 1 \"general_operand\" \"A,vR\")\n-\t\t\t       (match_operand:HI 2 \"general_operand\" \"iBDTvWabWhlWh1,1\")])\n+\t\t\t      [(match_operand:HI 1 \"general_operand\" \"A,A,vR\")\n+\t\t\t       (match_operand:HI 2 \"rl78_general_operand\" \"M,iBDTvWabWhlWh1,1\")])\n               (label_ref (match_operand          3 \"\" \"\"))\n \t      (pc)))]\n   \"rl78_real_insns_ok ()\"\n-  \"@\n-  cmpw\\t%1, %2 \\;sk%C0 \\;br\\t!!%3\n-  %z0\\t!!%3\"\n+  {\n+    switch (which_alternative)\n+      {\n+      case 0:\n+        if (rl78_flags_already_set (operands[0], operands[1]))\n+\t  return \"sk%C0\\; br\\t!!%3\\; # cmpw eliminated\";\n+\t/* else fall through.  */\n+      case 1:\n+\treturn \"cmpw\\t%1, %2\\; sk%C0\\; br\\t!!%3\";\n+      case 2:\n+        return \"%z0\\t!!%3\";\n+      default:\n+        gcc_unreachable ();\n+      }\n+  }\n+  [(set (attr \"update_Z\") (const_string \"clobber\"))] ;; FIXME: Z might be set based on %1 vs %2\n   )\n \n (define_insn \"cbranchhi4_real_inverted\"  \n   [(set (pc) (if_then_else\n \t      (match_operator                    0 \"rl78_cmp_operator_real\"\n-\t\t\t      [(match_operand:HI 1 \"general_operand\" \"A\")\n-\t\t\t       (match_operand:HI 2 \"general_operand\" \"iBDTvWabWhlWh1\")])\n+\t\t\t      [(match_operand:HI 1 \"general_operand\" \"A,A\")\n+\t\t\t       (match_operand:HI 2 \"rl78_general_operand\" \"M,iBDTvWabWhlWh1\")])\n \t      (pc)\n               (label_ref (match_operand          3 \"\" \"\"))))]\n   \"rl78_real_insns_ok ()\"\n-  \"cmpw\\t%1, %2 \\;sk%C0 \\;br\\t!!%3\"\n+  {\n+    if (which_alternative == 0 && rl78_flags_already_set (operands[0], operands[1]))\n+      return \"sk%C0\\; br\\t!!%3\\; # inverted cmpw eliminated\";\n+    else\n+      return \"cmpw\\t%1, %2\\; sk%C0\\; br\\t!!%3\";\n+  }\n+  [(set (attr \"update_Z\") (const_string \"clobber\"))] ;; FIXME: flags are set based on %1 vs %2\n   )\n \n (define_insn \"*cbranchsi4_real_lt\"\n   [(set (pc) (if_then_else\n-\t      (lt (match_operand:SI 0 \"general_operand\" \"U,vWabWhlWh1\")\n+\t      (lt (match_operand:SI 0 \"rl78_general_operand\" \"U,vWabWhlWh1\")\n \t\t  (const_int 0))\n               (label_ref (match_operand 1 \"\" \"\"))\n \t      (pc)))\n    (clobber (reg:HI AX_REG))\n    ]\n   \"rl78_real_insns_ok ()\"\n   \"@\n-   mov a, %E0 \\;mov1 CY,a.7 \\;sknc \\;br\\t!!%1\n-   mov1 CY,%E0.7 \\;sknc \\;br\\t!!%1\"\n+   mov\\ta, %E0\\; mov1\\tCY, a.7\\; sknc\\; br\\t!!%1\n+   mov1\\tCY, %E0.7\\; sknc\\; br\\t!!%1\"\n   )\n \n (define_insn \"*cbranchsi4_real_ge\"\n   [(set (pc) (if_then_else\n-\t      (ge (match_operand:SI 0 \"general_operand\" \"U,vWabWhlWh1\")\n+\t      (ge (match_operand:SI 0 \"rl78_general_operand\" \"U,vWabWhlWh1\")\n \t\t  (const_int 0))\n               (label_ref (match_operand 1 \"\" \"\"))\n \t      (pc)))\n    (clobber (reg:HI AX_REG))\n    ]\n   \"rl78_real_insns_ok ()\"\n   \"@\n-   mov a, %E0 \\;mov1 CY,a.7 \\;skc \\;br\\t!!%1\n-   mov1 CY,%E0.7 \\;skc \\;br\\t!!%1\"\n+   mov\\ta, %E0\\; mov1\\tCY, a.7\\; skc\\; br\\t!!%1\n+   mov1\\tCY, %E0.7\\; skc\\; br\\t!!%1\"\n   )\n \n (define_insn \"*cbranchsi4_real_signed\"\n@@ -426,11 +496,12 @@\n    ]\n   \"rl78_real_insns_ok ()\"\n   \"@\n-   movw ax,%H1 \\;cmpw  ax, %H2 \\;xor1 CY,a.7\\;not1 CY\\;      movw ax,%h1 \\;sknz \\;cmpw  ax, %h2 \\;sk%C0 \\;br\\t!!%3\n-   movw ax,%H1 \\;cmpw  ax, %H2 \\;xor1 CY,a.7\\;               movw ax,%h1 \\;sknz \\;cmpw  ax, %h2 \\;sk%C0 \\;br\\t!!%3\n-   movw ax,%H1 \\;cmpw  ax, %H2 \\;xor1 CY,a.7\\;xor1 CY,%E2.7\\;movw ax,%h1 \\;sknz \\;cmpw  ax, %h2 \\;sk%C0 \\;br\\t!!%3\n-   movw ax, %H1\\; cmpw  ax, %H2\\; xor1 CY, a.7\\; not1 CY\\; movw ax, %h1 \\;sknz\\; cmpw  ax, %h2 \\;sk%0 \\;br\\t!!%3\n-   movw ax, %H1\\; cmpw  ax, %H2\\; xor1 CY, a.7\\; movw ax, %h1\\; sknz\\; cmpw ax, %h2\\; sk%0\\; br\\t!!%3\"\n+   movw\\tax, %H1\\; cmpw\\tax, %H2\\; xor1\\tCY, a.7\\; not1\\tCY\\; movw\\tax, %h1\\; sknz\\; cmpw\\tax, %h2\\; sk%C0\\; br\\t!!%3\n+   movw\\tax, %H1\\; cmpw\\tax, %H2\\; xor1\\tCY, a.7\\; movw\\tax, %h1\\; sknz\\; cmpw\\tax, %h2\\; sk%C0\\; br\\t!!%3\n+   movw\\tax, %H1\\; cmpw\\tax, %H2\\; xor1\\tCY, a.7\\; xor1\\tCY, %E2.7\\; movw\\tax, %h1\\; sknz\\; cmpw\\tax, %h2\\; sk%C0\\; br\\t!!%3\n+   movw\\tax, %H1\\; cmpw\\tax, %H2\\; xor1\\tCY, a.7\\; not1\\tCY\\; movw\\tax, %h1\\; sknz\\; cmpw\\tax, %h2\\; sk%0\\; br\\t!!%3\n+   movw\\tax, %H1\\; cmpw\\tax, %H2\\; xor1\\tCY, a.7\\; movw\\tax, %h1\\; sknz\\; cmpw\\tax, %h2\\; sk%0\\; br\\t!!%3\"\n+  [(set (attr \"update_Z\") (const_string \"clobber\"))]\n   )\n \n (define_insn \"*cbranchsi4_real\"\n@@ -443,7 +514,8 @@\n    (clobber (reg:HI AX_REG))\n    ]\n   \"rl78_real_insns_ok ()\"\n-  \"movw ax,%H1 \\;cmpw  ax, %H2 \\;movw ax,%h1 \\;sknz \\;cmpw  ax, %h2 \\;sk%C0 \\;br\\t!!%3\"\n+  \"movw\\tax, %H1\\; cmpw\\tax, %H2\\; movw\\tax, %h1\\; sknz\\; cmpw\\tax, %h2\\; sk%C0\\; br\\t!!%3\"\n+  [(set (attr \"update_Z\") (const_string \"clobber\"))]\n   )\n \n ;; Peephole to match:\n@@ -480,6 +552,7 @@\n \t\t      (pc)))]\n   \"\"\n   \"bf\\tA.%B0, $%1\"\n+  [(set (attr \"update_Z\") (const_string \"clobber\"))]\n )\n \n (define_insn \"bt\"\n@@ -491,6 +564,7 @@\n \t\t      (pc)))]\n   \"\"\n   \"bt\\tA.%B0, $%1\"\n+  [(set (attr \"update_Z\") (const_string \"clobber\"))]\n )\n \n ;; NOTE: These peepholes are fragile.  They rely upon GCC generating\n@@ -565,4 +639,5 @@\n    ]\n   \"rl78_real_insns_ok ()\"\n   \"xor a, #0xff @ xch a, x @ xor a, #0xff @ xch a, x @ addw ax, #1 @ and a, %Q2 @ xch a, x @ and a, %q2 @ xch a, x\"\n+  [(set (attr \"update_Z\") (const_string \"clobber\"))]\n )"}, {"sha": "fadcbc5043301a0cf306ca4930851b35b9e4c74b", "filename": "gcc/config/rl78/rl78-virt.md", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48c528ae3a2fddd58a7e45b9ef334b42c1ea1686/gcc%2Fconfig%2Frl78%2Frl78-virt.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48c528ae3a2fddd58a7e45b9ef334b42c1ea1686/gcc%2Fconfig%2Frl78%2Frl78-virt.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78-virt.md?ref=48c528ae3a2fddd58a7e45b9ef334b42c1ea1686", "patch": "@@ -88,7 +88,7 @@\n (define_insn \"*add<mode>3_virt\"\n   [(set (match_operand:QHI           0 \"rl78_nonfar_nonimm_operand\" \"=vY,S\")\n \t(plus:QHI (match_operand:QHI 1 \"rl78_nonfar_operand\" \"viY,0\")\n-\t\t  (match_operand:QHI 2 \"general_operand\" \"vim,i\")))\n+\t\t  (match_operand:QHI 2 \"rl78_general_operand\" \"vim,i\")))\n    ]\n   \"rl78_virt_insns_ok ()\"\n   \"v.add\\t%0, %1, %2\"\n@@ -97,7 +97,7 @@\n (define_insn \"*sub<mode>3_virt\"\n   [(set (match_operand:QHI            0 \"rl78_nonfar_nonimm_operand\" \"=vm,S\")\n \t(minus:QHI (match_operand:QHI 1 \"rl78_nonfar_operand\" \"vim,0\")\n-\t\t   (match_operand:QHI 2 \"general_operand\" \"vim,i\")))\n+\t\t   (match_operand:QHI 2 \"rl78_general_operand\" \"vim,i\")))\n    ]\n   \"rl78_virt_insns_ok ()\"\n   \"v.sub\\t%0, %1, %2\"\n@@ -124,7 +124,7 @@\n (define_insn \"*andqi3_virt\"\n   [(set (match_operand:QI         0 \"rl78_nonfar_nonimm_operand\" \"=vm\")\n \t(and:QI (match_operand:QI 1 \"rl78_nonfar_operand\" \"vim\")\n-\t\t(match_operand:QI 2 \"general_operand\" \"vim\")))\n+\t\t(match_operand:QI 2 \"rl78_general_operand\" \"vim\")))\n    ]\n   \"rl78_virt_insns_ok ()\"\n   \"v.and\\t%0, %1, %2\"\n@@ -133,16 +133,16 @@\n (define_insn \"*iorqi3_virt\"\n   [(set (match_operand:QI         0 \"rl78_nonfar_nonimm_operand\" \"=vm\")\n \t(ior:QI (match_operand:QI 1 \"rl78_nonfar_operand\" \"vim\")\n-\t\t(match_operand:QI 2 \"general_operand\" \"vim\")))\n+\t\t(match_operand:QI 2 \"rl78_general_operand\" \"vim\")))\n    ]\n   \"rl78_virt_insns_ok ()\"\n   \"v.or\\t%0, %1, %2\"\n )\n \n-(define_insn \"*xor3_virt\"\n+(define_insn \"*xorqi3_virt\"\n   [(set (match_operand:QI         0 \"rl78_nonfar_nonimm_operand\" \"=v,vm,m\")\n \t(xor:QI (match_operand:QI 1 \"rl78_nonfar_operand\" \"%0,vm,vm\")\n-\t\t(match_operand    2 \"general_operand\" \"i,vm,vim\")))\n+\t\t(match_operand    2 \"rl78_general_operand\" \"i,vm,vim\")))\n    ]\n   \"rl78_virt_insns_ok ()\"\n   \"v.xor\\t%0, %1, %2\"\n@@ -343,8 +343,8 @@\n (define_insn \"*cbranchqi4_virt\"\n   [(set (pc) (if_then_else\n \t      (match_operator 0 \"rl78_cmp_operator_real\"\n-\t\t\t      [(match_operand:QI 1 \"general_operand\" \"vim\")\n-\t\t\t       (match_operand:QI 2 \"general_operand\" \"vim\")])\n+\t\t\t      [(match_operand:QI 1 \"rl78_general_operand\" \"vim\")\n+\t\t\t       (match_operand:QI 2 \"rl78_general_operand\" \"vim\")])\n               (label_ref (match_operand 3 \"\" \"\"))\n \t      (pc)))]\n   \"rl78_virt_insns_ok ()\"\n@@ -367,8 +367,8 @@\n (define_insn \"*cbranchhi4_virt\"\n   [(set (pc) (if_then_else\n \t      (match_operator 0 \"rl78_cmp_operator_real\"\n-\t\t\t      [(match_operand:HI 1 \"general_operand\" \"vim\")\n-\t\t\t       (match_operand:HI 2 \"general_operand\" \"vim\")])\n+\t\t\t      [(match_operand:HI 1 \"rl78_general_operand\" \"vim\")\n+\t\t\t       (match_operand:HI 2 \"rl78_general_operand\" \"vim\")])\n               (label_ref (match_operand 3 \"\" \"\"))\n \t      (pc)))]\n   \"rl78_virt_insns_ok ()\""}, {"sha": "4cf271c9b8372d8bfb1484dc0f3c621f6c4dab28", "filename": "gcc/config/rl78/rl78.c", "status": "modified", "additions": 652, "deletions": 69, "changes": 721, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48c528ae3a2fddd58a7e45b9ef334b42c1ea1686/gcc%2Fconfig%2Frl78%2Frl78.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48c528ae3a2fddd58a7e45b9ef334b42c1ea1686/gcc%2Fconfig%2Frl78%2Frl78.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78.c?ref=48c528ae3a2fddd58a7e45b9ef334b42c1ea1686", "patch": "@@ -85,10 +85,14 @@\n #include \"tm-constrs.h\" /* for satisfies_constraint_*().  */\n #include \"insn-flags.h\" /* for gen_*().  */\n #include \"builtins.h\"\n+#include \"stringpool.h\"\n \f\n static inline bool is_interrupt_func (const_tree decl);\n static inline bool is_brk_interrupt_func (const_tree decl);\n static void rl78_reorg (void);\n+static const char *rl78_strip_name_encoding (const char *);\n+static const char *rl78_strip_nonasm_name_encoding (const char *);\n+static section * rl78_select_section (tree, int, unsigned HOST_WIDE_INT);\n \f\n \n /* Debugging statements are tagged with DEBUG0 only so that they can\n@@ -318,6 +322,29 @@ rl78_asm_file_start (void)\n   register_pass (& rl78_move_elim_info);\n }\n \n+void\n+rl78_output_symbol_ref (FILE * file, rtx sym)\n+{\n+  tree type = SYMBOL_REF_DECL (sym);\n+  const char *str = XSTR (sym, 0);\n+\n+  if (str[0] == '*')\n+    {\n+      fputs (str + 1, file);\n+    }\n+  else\n+    {\n+      str = rl78_strip_nonasm_name_encoding (str);\n+      if (type && TREE_CODE (type) == FUNCTION_DECL)\n+\t{\n+\t  fprintf (file, \"%%code(\");\n+\t  assemble_name (file, str);\n+\t  fprintf (file, \")\");\n+\t}\n+      else\n+\tassemble_name (file, str);\n+    }\n+}\n \f\n #undef  TARGET_OPTION_OVERRIDE\n #define TARGET_OPTION_OVERRIDE\t\trl78_option_override\n@@ -338,6 +365,13 @@ rl78_option_override (void)\n       for (i = 24; i < 32; i++)\n \tfixed_regs[i] = 0;\n     }\n+\n+  if (TARGET_ES0\n+      && strcmp (lang_hooks.name, \"GNU C\")\n+      /* Compiling with -flto results in a language of GNU GIMPLE being used... */\n+      && strcmp (lang_hooks.name, \"GNU GIMPLE\"))\n+    /* Address spaces are currently only supported by C.  */\n+    error (\"-mes0 can only be used with C\");\n }\n \n /* Most registers are 8 bits.  Some are 16 bits because, for example,\n@@ -695,6 +729,51 @@ rl78_handle_func_attribute (tree * node,\n   return NULL_TREE;\n }\n \n+/* Check \"naked\" attributes.  */\n+static tree\n+rl78_handle_naked_attribute (tree * node,\n+\t\t\t     tree   name ATTRIBUTE_UNUSED,\n+\t\t\t     tree   args,\n+\t\t\t     int    flags ATTRIBUTE_UNUSED,\n+\t\t\t     bool * no_add_attrs)\n+{\n+  gcc_assert (DECL_P (* node));\n+  gcc_assert (args == NULL_TREE);\n+\n+  if (TREE_CODE (* node) != FUNCTION_DECL)\n+    {\n+      warning (OPT_Wattributes, \"naked attribute only applies to functions\");\n+      * no_add_attrs = true;\n+    }\n+\n+  /* Disable warnings about this function - eg reaching the end without\n+     seeing a return statement - because the programmer is doing things\n+     that gcc does not know about.  */\n+  TREE_NO_WARNING (* node) = 1;\n+\n+  return NULL_TREE;\n+}\n+\n+/* Check \"saddr\" attributes.  */\n+static tree\n+rl78_handle_saddr_attribute (tree * node,\n+\t\t\t     tree   name,\n+\t\t\t     tree   args ATTRIBUTE_UNUSED,\n+\t\t\t     int    flags ATTRIBUTE_UNUSED,\n+\t\t\t     bool * no_add_attrs)\n+{\n+  gcc_assert (DECL_P (* node));\n+\n+  if (TREE_CODE (* node) == FUNCTION_DECL)\n+    {\n+      warning (OPT_Wattributes, \"%qE attribute doesn't apply to functions\",\n+\t       name);\n+      * no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n #undef  TARGET_ATTRIBUTE_TABLE\n #define TARGET_ATTRIBUTE_TABLE\t\trl78_attribute_table\n \n@@ -707,7 +786,9 @@ const struct attribute_spec rl78_attribute_table[] =\n     false },\n   { \"brk_interrupt\",  0, 0, true, false, false, rl78_handle_func_attribute,\n     false },\n-  { \"naked\",          0, 0, true, false, false, rl78_handle_func_attribute,\n+  { \"naked\",          0, 0, true, false, false, rl78_handle_naked_attribute,\n+    false },\n+  { \"saddr\",          0, 0, true, false, false, rl78_handle_saddr_attribute,\n     false },\n   { NULL,             0, 0, false, false, false, NULL, false }\n };\n@@ -748,6 +829,18 @@ characterize_address (rtx x, rtx *base, rtx *index, rtx *addend)\n       *base = XEXP (x, 0);\n       x = XEXP (x, 1);\n \n+      if (GET_CODE (*base) == SUBREG)\n+\t{\n+\t  if (GET_MODE (*base) == HImode\n+\t      && GET_MODE (XEXP (*base, 0)) == SImode\n+\t      && GET_CODE (XEXP (*base, 0)) == REG)\n+\t    {\n+\t      /* This is a throw-away rtx just to tell everyone\n+\t\t else what effective register we're using.  */\n+\t      *base = gen_rtx_REG (HImode, REGNO (XEXP (*base, 0)));\n+\t    }\n+\t}\n+\n       if (GET_CODE (*base) != REG\n \t  && GET_CODE (x) == REG)\n \t{\n@@ -781,6 +874,18 @@ characterize_address (rtx x, rtx *base, rtx *index, rtx *addend)\n     case REG:\n       return false;\n \n+    case SUBREG:\n+      switch (GET_CODE (XEXP (x, 0)))\n+\t{\n+\tcase CONST:\n+\tcase SYMBOL_REF:\n+\tcase CONST_INT:\n+\t  *addend = x;\n+\t  return true;\n+\tdefault:\n+\t  return false;\n+\t}\n+\n     case CONST:\n     case SYMBOL_REF:\n     case CONST_INT:\n@@ -828,6 +933,27 @@ rl78_hl_b_c_addr_p (rtx op)\n \n #define REG_IS(r, regno) (((r) == (regno)) || ((r) >= FIRST_PSEUDO_REGISTER && !(strict)))\n \n+/* Return the appropriate mode for a named address address.  */\n+\n+#undef  TARGET_ADDR_SPACE_ADDRESS_MODE\n+#define TARGET_ADDR_SPACE_ADDRESS_MODE rl78_addr_space_address_mode\n+\n+static enum machine_mode\n+rl78_addr_space_address_mode (addr_space_t addrspace)\n+{\n+  switch (addrspace)\n+    {\n+    case ADDR_SPACE_GENERIC:\n+      return HImode;\n+    case ADDR_SPACE_NEAR:\n+      return HImode;\n+    case ADDR_SPACE_FAR:\n+      return SImode;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n /* Used in various constraints and predicates to match operands in the\n    \"far\" address space.  */\n int\n@@ -839,7 +965,7 @@ rl78_far_p (rtx x)\n   fprintf (stderr, \"\\033[35mrl78_far_p: \"); debug_rtx (x);\n   fprintf (stderr, \" = %d\\033[0m\\n\", MEM_ADDR_SPACE (x) == ADDR_SPACE_FAR);\n #endif\n-  return MEM_ADDR_SPACE (x) == ADDR_SPACE_FAR;\n+  return GET_MODE_BITSIZE (rl78_addr_space_address_mode (MEM_ADDR_SPACE (x))) == 32;\n }\n \n /* Return the appropriate mode for a named address pointer.  */\n@@ -853,6 +979,8 @@ rl78_addr_space_pointer_mode (addr_space_t addrspace)\n     {\n     case ADDR_SPACE_GENERIC:\n       return HImode;\n+    case ADDR_SPACE_NEAR:\n+      return HImode;\n     case ADDR_SPACE_FAR:\n       return SImode;\n     default:\n@@ -870,23 +998,6 @@ rl78_valid_pointer_mode (machine_mode m)\n   return (m == HImode || m == SImode);\n }\n \n-/* Return the appropriate mode for a named address address.  */\n-#undef  TARGET_ADDR_SPACE_ADDRESS_MODE\n-#define TARGET_ADDR_SPACE_ADDRESS_MODE rl78_addr_space_address_mode\n-\n-static machine_mode\n-rl78_addr_space_address_mode (addr_space_t addrspace)\n-{\n-  switch (addrspace)\n-    {\n-    case ADDR_SPACE_GENERIC:\n-      return HImode;\n-    case ADDR_SPACE_FAR:\n-      return SImode;\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n \n #undef  TARGET_LEGITIMATE_CONSTANT_P\n #define TARGET_LEGITIMATE_CONSTANT_P\t\trl78_is_legitimate_constant\n@@ -906,6 +1017,9 @@ rl78_as_legitimate_address (machine_mode mode ATTRIBUTE_UNUSED, rtx x,\n {\n   rtx base, index, addend;\n   bool is_far_addr = false;\n+  int as_bits;\n+\n+  as_bits = GET_MODE_BITSIZE (rl78_addr_space_address_mode (as));\n \n   if (GET_CODE (x) == UNSPEC\n       && XINT (x, 1) == UNS_ES_ADDR)\n@@ -914,8 +1028,7 @@ rl78_as_legitimate_address (machine_mode mode ATTRIBUTE_UNUSED, rtx x,\n       is_far_addr = true;\n     }\n \n-  if (as == ADDR_SPACE_GENERIC\n-      && (GET_MODE (x) == SImode || is_far_addr))\n+  if (as_bits == 16 && is_far_addr)\n     return false;\n \n   if (! characterize_address (x, &base, &index, &addend))\n@@ -925,7 +1038,7 @@ rl78_as_legitimate_address (machine_mode mode ATTRIBUTE_UNUSED, rtx x,\n      involving a register during devirtualization, so make sure all\n      such __far addresses do not have addends.  This forces GCC to do\n      the sum separately.  */\n-  if (addend && base && as == ADDR_SPACE_FAR)\n+  if (addend && base && as_bits == 32 && GET_MODE (base) == SImode)\n     return false;\n \n   if (base && index)\n@@ -956,14 +1069,13 @@ rl78_as_legitimate_address (machine_mode mode ATTRIBUTE_UNUSED, rtx x,\n static bool\n rl78_addr_space_subset_p (addr_space_t subset, addr_space_t superset)\n {\n-  gcc_assert (subset == ADDR_SPACE_GENERIC || subset == ADDR_SPACE_FAR);\n-  gcc_assert (superset == ADDR_SPACE_GENERIC || superset == ADDR_SPACE_FAR);\n+  int subset_bits;\n+  int superset_bits;\n \n-  if (subset == superset)\n-    return true;\n+  subset_bits = GET_MODE_BITSIZE (rl78_addr_space_address_mode (subset));\n+  superset_bits = GET_MODE_BITSIZE (rl78_addr_space_address_mode (superset));\n \n-  else\n-    return (subset == ADDR_SPACE_GENERIC && superset == ADDR_SPACE_FAR);\n+  return (subset_bits <= superset_bits);\n }\n \n #undef  TARGET_ADDR_SPACE_CONVERT\n@@ -976,29 +1088,44 @@ rl78_addr_space_convert (rtx op, tree from_type, tree to_type)\n   addr_space_t from_as = TYPE_ADDR_SPACE (TREE_TYPE (from_type));\n   addr_space_t to_as = TYPE_ADDR_SPACE (TREE_TYPE (to_type));\n   rtx result;\n+  int to_bits;\n+  int from_bits;\n \n-  gcc_assert (from_as == ADDR_SPACE_GENERIC || from_as == ADDR_SPACE_FAR);\n-  gcc_assert (to_as == ADDR_SPACE_GENERIC || to_as == ADDR_SPACE_FAR);\n+  to_bits = GET_MODE_BITSIZE (rl78_addr_space_address_mode (to_as));\n+  from_bits = GET_MODE_BITSIZE (rl78_addr_space_address_mode (from_as));\n \n-  if (to_as == ADDR_SPACE_GENERIC && from_as == ADDR_SPACE_FAR)\n+  if (to_bits < from_bits)\n     {\n+      rtx tmp;\n       /* This is unpredictable, as we're truncating off usable address\n \t bits.  */\n \n+      warning (OPT_Waddress, \"converting far pointer to near pointer\");\n       result = gen_reg_rtx (HImode);\n-      emit_move_insn (result, simplify_subreg (HImode, op, SImode, 0));\n+      if (GET_CODE (op) == SYMBOL_REF\n+\t  || (GET_CODE (op) == REG && REGNO (op) >= FIRST_PSEUDO_REGISTER))\n+\ttmp = gen_rtx_raw_SUBREG (HImode, op, 0);\n+      else\n+\ttmp = simplify_subreg (HImode, op, SImode, 0);\n+      gcc_assert (tmp != NULL_RTX);\n+      emit_move_insn (result, tmp);\n       return result;\n     }\n-  else if (to_as == ADDR_SPACE_FAR && from_as == ADDR_SPACE_GENERIC)\n+  else if (to_bits > from_bits)\n     {\n       /* This always works.  */\n       result = gen_reg_rtx (SImode);\n       emit_move_insn (rl78_subreg (HImode, result, SImode, 0), op);\n-      emit_move_insn (rl78_subreg (HImode, result, SImode, 2), const0_rtx);\n+      if (TREE_CODE (from_type) == POINTER_TYPE\n+\t  && TREE_CODE (TREE_TYPE (from_type)) == FUNCTION_TYPE)\n+\temit_move_insn (rl78_subreg (HImode, result, SImode, 2), const0_rtx);\n+      else\n+\temit_move_insn (rl78_subreg (HImode, result, SImode, 2), GEN_INT (0x0f));\n       return result;\n     }\n   else\n-    gcc_unreachable ();\n+    return op;\n+  gcc_unreachable ();\n }\n \n /* Implements REGNO_MODE_CODE_OK_FOR_BASE_P.  */\n@@ -1129,19 +1256,20 @@ rl78_expand_prologue (void)\n \tif (TARGET_G10)\n \t  {\n \t    if (i != 0)\n-\t      emit_move_insn (gen_rtx_REG (HImode, 0), gen_rtx_REG (HImode, i * 2));\n-\t    F (emit_insn (gen_push (gen_rtx_REG (HImode, 0))));\n+\t      emit_move_insn (gen_rtx_REG (HImode, AX_REG), gen_rtx_REG (HImode, i * 2));\n+\t    F (emit_insn (gen_push (gen_rtx_REG (HImode, AX_REG))));\n \t  }\n \telse\n \t  {\n-\t    int need_bank = i/4;\n+\t    int need_bank = i / 4;\n \n \t    if (need_bank != rb)\n \t      {\n \t\temit_insn (gen_sel_rb (GEN_INT (need_bank)));\n \t\trb = need_bank;\n \t      }\n-\t    F (emit_insn (gen_push (gen_rtx_REG (HImode, i*2))));\n+\t    F (emit_insn (gen_push (gen_rtx_REG (HImode, i * 2))));\n+\n \t  }\n       }\n \n@@ -1205,7 +1333,7 @@ rl78_expand_epilogue (void)\n   if (is_interrupt_func (cfun->decl) && cfun->machine->uses_es)\n     {\n       emit_insn (gen_pop (gen_rtx_REG (HImode, AX_REG)));\n-      emit_insn (gen_movqi_es (gen_rtx_REG (QImode, A_REG)));\n+      emit_insn (gen_movqi_to_es (gen_rtx_REG (QImode, A_REG)));\n     }\n \n   for (i = 15; i >= 0; i--)\n@@ -1215,7 +1343,7 @@ rl78_expand_epilogue (void)\n \n \tif (TARGET_G10)\n \t  {\n-\t    rtx ax = gen_rtx_REG (HImode, 0);\n+\t    rtx ax = gen_rtx_REG (HImode, AX_REG);\n \n \t    emit_insn (gen_pop (ax));\n \t    if (i != 0)\n@@ -1415,7 +1543,8 @@ rl78_print_operand_1 (FILE * file, rtx op, int letter)\n \t  if (rl78_far_p (op))\n \t    {\n \t      fprintf (file, \"es:\");\n-\t      op = gen_rtx_MEM (GET_MODE (op), XVECEXP (XEXP (op, 0), 0, 1));\n+\t      if (GET_CODE (XEXP (op, 0)) == UNSPEC)\n+\t\top = gen_rtx_MEM (GET_MODE (op), XVECEXP (XEXP (op, 0), 0, 1));\n \t    }\n \t  if (letter == 'H')\n \t    {\n@@ -1449,13 +1578,15 @@ rl78_print_operand_1 (FILE * file, rtx op, int letter)\n \t    }\n \t  if (CONSTANT_P (XEXP (op, 0)))\n \t    {\n-\t      fprintf (file, \"!\");\n+\t      if (!rl78_saddr_p (op))\n+\t\tfprintf (file, \"!\");\n \t      rl78_print_operand_1 (file, XEXP (op, 0), letter);\n \t    }\n \t  else if (GET_CODE (XEXP (op, 0)) == PLUS\n \t\t   && GET_CODE (XEXP (XEXP (op, 0), 0)) == SYMBOL_REF)\n \t    {\n-\t      fprintf (file, \"!\");\n+\t      if (!rl78_saddr_p (op))\n+\t\tfprintf (file, \"!\");\n \t      rl78_print_operand_1 (file, XEXP (op, 0), letter);\n \t    }\n \t  else if (GET_CODE (XEXP (op, 0)) == PLUS\n@@ -1465,6 +1596,8 @@ rl78_print_operand_1 (FILE * file, rtx op, int letter)\n \t      rl78_print_operand_1 (file, XEXP (XEXP (op, 0), 1), 'u');\n \t      fprintf (file, \"[\");\n \t      rl78_print_operand_1 (file, XEXP (XEXP (op, 0), 0), 0);\n+\t      if (letter == 'p' && GET_CODE (XEXP (op, 0)) == REG)\n+\t\tfprintf (file, \"+0\");\n \t      fprintf (file, \"]\");\n \t    }\n \t  else\n@@ -1513,7 +1646,15 @@ rl78_print_operand_1 (FILE * file, rtx op, int letter)\n       else if (letter == 'e')\n \tfprintf (file, \"%ld\", (INTVAL (op) >> 16) & 0xff);\n       else if (letter == 'B')\n-\tfprintf (file, \"%d\", exact_log2 (INTVAL (op)));\n+\t{\n+\t  int ival = INTVAL (op);\n+\t  if (ival == -128)\n+\t    ival = 0x80;\n+\t  if (exact_log2 (ival) >= 0)\n+\t    fprintf (file, \"%d\", exact_log2 (ival));\n+\t  else\n+\t    fprintf (file, \"%d\", exact_log2 (~ival & 0xff));\n+\t}\n       else if (letter == 'E')\n \tfprintf (file, \"%ld\", (INTVAL (op) >> 24) & 0xff);\n       else if (letter == 'm')\n@@ -1597,6 +1738,27 @@ rl78_print_operand_1 (FILE * file, rtx op, int letter)\n \tfprintf (file, \")\");\n       break;\n \n+    case SUBREG:\n+      if (GET_MODE (op) == HImode\n+\t  && SUBREG_BYTE (op) == 0)\n+\t{\n+\t  fprintf (file, \"%%lo16(\");\n+\t  rl78_print_operand_1 (file, SUBREG_REG (op), 0);\n+\t  fprintf (file, \")\");\n+\t}\n+      else if (GET_MODE (op) == HImode\n+\t       && SUBREG_BYTE (op) == 2)\n+\t{\n+\t  fprintf (file, \"%%hi16(\");\n+\t  rl78_print_operand_1 (file, SUBREG_REG (op), 0);\n+\t  fprintf (file, \")\");\n+\t}\n+      else\n+\t{\n+\t  fprintf (file, \"(%s)\", GET_RTX_NAME (GET_CODE (op)));\n+\t}\n+      break;\n+\n     case SYMBOL_REF:\n       need_paren = 0;\n       if (letter == 'H')\n@@ -1620,7 +1782,14 @@ rl78_print_operand_1 (FILE * file, rtx op, int letter)\n       if (letter == 'q' || letter == 'Q')\n \toutput_operand_lossage (\"q/Q modifiers invalid for symbol references\");\n \n-      output_addr_const (file, op);\n+      if (SYMBOL_REF_DECL (op) && TREE_CODE (SYMBOL_REF_DECL (op)) == FUNCTION_DECL)\n+\t{\n+\t  fprintf (file, \"%%code(\");\n+\t  assemble_name (file, rl78_strip_nonasm_name_encoding (XSTR (op, 0)));\n+\t  fprintf (file, \")\");\n+\t}\n+      else\n+        assemble_name (file, rl78_strip_nonasm_name_encoding (XSTR (op, 0)));\n       if (need_paren)\n \tfprintf (file, \")\");\n       break;\n@@ -2488,12 +2657,12 @@ transcode_memory_rtx (rtx m, rtx newbase, rtx before)\n       rtx new_m;\n       rtx seg = rl78_hi8 (XEXP (m, 0));\n \n-#if DEBUG_ALLOC\n-      fprintf (stderr, \"setting ES:\\n\");\n-      debug_rtx(seg);\n-#endif\n-      emit_insn_before (EM (gen_movqi (A, seg)), before);\n-      emit_insn_before (EM (gen_movqi_es (A)), before);\n+      if (!TARGET_ES0)\n+\t{\n+          emit_insn_before (EM (gen_movqi (A, seg)), before);\n+          emit_insn_before (EM (gen_movqi_to_es (A)), before);\n+        }\n+\n       record_content (A, NULL_RTX);\n \n       new_m = gen_rtx_MEM (GET_MODE (m), rl78_lo16 (XEXP (m, 0)));\n@@ -2505,10 +2674,6 @@ transcode_memory_rtx (rtx m, rtx newbase, rtx before)\n   characterize_address (XEXP (m, 0), & base, & index, & addendr);\n   gcc_assert (index == NULL_RTX);\n \n-#if DEBUG_ALLOC\n-  fprintf (stderr, \"\\033[33m\"); debug_rtx (m); fprintf (stderr, \"\\033[0m\");\n-  debug_rtx (base);\n-#endif\n   if (base == NULL_RTX)\n     return m;\n \n@@ -2518,9 +2683,11 @@ transcode_memory_rtx (rtx m, rtx newbase, rtx before)\n   gcc_assert (REG_P (base));\n   gcc_assert (REG_P (newbase));\n \n+  int limit = 256 - GET_MODE_SIZE (GET_MODE (m));\n+\n   if (REGNO (base) == SP_REG)\n     {\n-      if (addend >= 0 && addend  <= 255)\n+      if (addend >= 0 && addend  <= limit)\n \treturn m;\n     }\n \n@@ -2529,8 +2696,11 @@ transcode_memory_rtx (rtx m, rtx newbase, rtx before)\n      address.  */\n \n   if (addend < 0\n-      || (addend > 255 && REGNO (newbase) != 2)\n-      || (addendr && GET_CODE (addendr) != CONST_INT))\n+      || (addend > limit && REGNO (newbase) != BC_REG)\n+      || (addendr\n+\t  && (GET_CODE (addendr) != CONST_INT)\n+\t  && ((REGNO (newbase) != BC_REG))\n+\t  ))\n     {\n       /* mov ax, vreg\n \t add ax, #imm\n@@ -2543,6 +2713,7 @@ transcode_memory_rtx (rtx m, rtx newbase, rtx before)\n \n       base = newbase;\n       addend = 0;\n+      addendr = 0;\n     }\n   else\n     {\n@@ -2554,22 +2725,19 @@ transcode_memory_rtx (rtx m, rtx newbase, rtx before)\n       record_content (base, NULL_RTX);\n       base = gen_rtx_PLUS (HImode, base, GEN_INT (addend));\n     }\n+  else if (addendr)\n+    {\n+      record_content (base, NULL_RTX);\n+      base = gen_rtx_PLUS (HImode, base, addendr);\n+    }\n \n-#if DEBUG_ALLOC\n-  fprintf (stderr, \"\\033[33m\");\n-  debug_rtx (m);\n-#endif\n   if (need_es)\n     {\n       m = change_address (m, GET_MODE (m), gen_es_addr (base));\n       cfun->machine->uses_es = true;\n     }\n   else\n     m = change_address (m, GET_MODE (m), base);\n-#if DEBUG_ALLOC\n-  debug_rtx (m);\n-  fprintf (stderr, \"\\033[0m\");\n-#endif\n   return m;\n }\n \n@@ -2724,7 +2892,13 @@ rl78_alloc_physical_registers_op1 (rtx_insn * insn)\n     {\n       /* If necessary, load the operands into BC and HL.\n \t Check to see if we already have OP (0) in HL\n-\t and if so, swap the order.  */\n+\t and if so, swap the order.\n+\n+\t It is tempting to perform this optimization when OP(0) does\n+\t not hold a MEM, but this leads to bigger code in general.\n+\t The problem is that if OP(1) holds a MEM then swapping it\n+\t into BC means a BC-relative load is used and these 3 bytes\n+\t long vs 1 byte for an HL load.  */\n       if (MEM_P (OP (0))\n \t  && already_contains (HL, XEXP (OP (0), 0)))\n \t{\n@@ -3811,6 +3985,311 @@ static bool rl78_rtx_costs (rtx   x,\n }\n \f\n \n+\f\n+\n+static GTY(()) section * saddr_section;\n+static GTY(()) section * frodata_section;\n+\n+int\n+rl78_saddr_p (rtx x)\n+{\n+  const char * c;\n+\n+  if (MEM_P (x))\n+    x = XEXP (x, 0);\n+  if (GET_CODE (x) == PLUS)\n+    x = XEXP (x, 0);\n+  if (GET_CODE (x) != SYMBOL_REF)\n+    return 0;\n+\n+  c = XSTR (x, 0);\n+  if (memcmp (c, \"@s.\", 3) == 0)\n+    return 1;\n+\n+  return 0;\n+}\n+\n+int\n+rl78_sfr_p (rtx x)\n+{\n+  if (MEM_P (x))\n+    x = XEXP (x, 0);\n+  if (GET_CODE (x) != CONST_INT)\n+    return 0;\n+\n+  if ((INTVAL (x) & 0xFF00) != 0xFF00)\n+    return 0;\n+\n+  return 1;\n+}\n+\n+#undef  TARGET_STRIP_NAME_ENCODING\n+#define TARGET_STRIP_NAME_ENCODING rl78_strip_name_encoding\n+\n+static const char *\n+rl78_strip_name_encoding (const char * sym)\n+{\n+  while (1)\n+    {\n+      if (*sym == '*')\n+\tsym++;\n+      else if (*sym == '@' && sym[2] == '.')\n+\tsym += 3;\n+      else\n+\treturn sym;\n+    }\n+}\n+\n+/* Like rl78_strip_name_encoding, but does not strip leading asterisks.  This\n+   is important if the stripped name is going to be passed to assemble_name()\n+   as that handles asterisk prefixed names in a special manner.  */\n+\n+static const char *\n+rl78_strip_nonasm_name_encoding (const char * sym)\n+{\n+  while (1)\n+    {\n+      if (*sym == '@' && sym[2] == '.')\n+\tsym += 3;\n+      else\n+\treturn sym;\n+    }\n+}\n+\n+\n+static int\n+rl78_attrlist_to_encoding (tree list, tree decl ATTRIBUTE_UNUSED)\n+{\n+  while (list)\n+    {\n+      if (is_attribute_p (\"saddr\", TREE_PURPOSE (list)))\n+\treturn 's';\n+      list = TREE_CHAIN (list);\n+    }\n+\n+  return 0;\n+}\n+\n+#define RL78_ATTRIBUTES(decl)\t\t\t\t\\\n+  (TYPE_P (decl)) ? TYPE_ATTRIBUTES (decl)\t\t\\\n+                : DECL_ATTRIBUTES (decl)\t\t\\\n+                  ? (DECL_ATTRIBUTES (decl))\t\t\\\n+\t\t  : TYPE_ATTRIBUTES (TREE_TYPE (decl))\n+\n+#undef  TARGET_ENCODE_SECTION_INFO\n+#define TARGET_ENCODE_SECTION_INFO rl78_encode_section_info\n+\n+static void\n+rl78_encode_section_info (tree decl, rtx rtl, int first)\n+{\n+  rtx rtlname;\n+  const char * oldname;\n+  char encoding;\n+  char * newname;\n+  tree idp;\n+  tree type;\n+  tree rl78_attributes;\n+\n+  if (!first)\n+    return;\n+\n+  rtlname = XEXP (rtl, 0);\n+\n+  if (GET_CODE (rtlname) == SYMBOL_REF)\n+    oldname = XSTR (rtlname, 0);\n+  else if (GET_CODE (rtlname) == MEM\n+\t   && GET_CODE (XEXP (rtlname, 0)) == SYMBOL_REF)\n+    oldname = XSTR (XEXP (rtlname, 0), 0);\n+  else\n+    gcc_unreachable ();\n+\n+  type = TREE_TYPE (decl);\n+  if (type == error_mark_node)\n+    return;\n+  if (! DECL_P (decl))\n+    return;\n+  rl78_attributes = RL78_ATTRIBUTES (decl);\n+\n+  encoding = rl78_attrlist_to_encoding (rl78_attributes, decl);\n+\n+  if (encoding)\n+    {\n+      newname = (char *) alloca (strlen (oldname) + 4);\n+      sprintf (newname, \"@%c.%s\", encoding, oldname);\n+      idp = get_identifier (newname);\n+      XEXP (rtl, 0) =\n+\tgen_rtx_SYMBOL_REF (Pmode, IDENTIFIER_POINTER (idp));\n+      SYMBOL_REF_WEAK (XEXP (rtl, 0)) = DECL_WEAK (decl);\n+      SET_SYMBOL_REF_DECL (XEXP (rtl, 0), decl);\n+    }\n+}\n+\n+#undef  TARGET_ASM_INIT_SECTIONS\n+#define TARGET_ASM_INIT_SECTIONS \trl78_asm_init_sections\n+\n+static void\n+rl78_asm_init_sections (void)\n+{\n+  saddr_section\n+    = get_unnamed_section (SECTION_WRITE, output_section_asm_op,\n+\t\t\t   \"\\t.section .saddr,\\\"aw\\\",@progbits\");\n+  frodata_section\n+    = get_unnamed_section (SECTION_WRITE, output_section_asm_op,\n+\t\t\t   \"\\t.section .frodata,\\\"aw\\\",@progbits\");\n+}\n+\n+#undef  TARGET_ASM_SELECT_SECTION\n+#define TARGET_ASM_SELECT_SECTION\trl78_select_section\n+\n+static section *\n+rl78_select_section (tree decl,\n+\t\t     int reloc ATTRIBUTE_UNUSED,\n+\t\t     unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED)\n+{\n+  int readonly = 1;\n+\n+  switch (TREE_CODE (decl))\n+    {\n+    case VAR_DECL:\n+      if (!TREE_READONLY (decl)\n+\t  || TREE_SIDE_EFFECTS (decl)\n+\t  || !DECL_INITIAL (decl)\n+\t  || (DECL_INITIAL (decl) != error_mark_node\n+\t      && !TREE_CONSTANT (DECL_INITIAL (decl))))\n+\treadonly = 0;\n+      break;\n+    case CONSTRUCTOR:\n+      if (! TREE_CONSTANT (decl))\n+\treadonly = 0;\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  if (TREE_CODE (decl) == VAR_DECL)\n+    {\n+      const char *name = XSTR (XEXP (DECL_RTL (decl), 0), 0);\n+\n+      if (name[0] == '@' && name[2] == '.')\n+\tswitch (name[1])\n+\t  {\n+\t  case 's':\n+\t    return saddr_section;\n+\t  }\n+\n+      if (TYPE_ADDR_SPACE (TREE_TYPE (decl)) == ADDR_SPACE_FAR\n+\t  && readonly)\n+\t{\n+\t  return frodata_section;\n+\t}\n+    }\n+\n+  if (readonly)\n+    return readonly_data_section;\n+\n+  return data_section;\n+}\n+\n+void\n+rl78_output_labelref (FILE *file, const char *str)\n+{\n+  const char *str2;\n+\n+  str2 = targetm.strip_name_encoding (str);\n+  if (str2[0] != '.')\n+    fputs (user_label_prefix, file);\n+  fputs (str2, file);\n+}\n+\n+void\n+rl78_output_aligned_common (FILE *stream,\n+\t\t\t    tree decl ATTRIBUTE_UNUSED,\n+\t\t\t    const char *name,\n+\t\t\t    int size, int align, int global)\n+{\n+  /* We intentionally don't use rl78_section_tag() here.  */\n+  if (name[0] == '@' && name[2] == '.')\n+    {\n+      const char *sec = 0;\n+      switch (name[1])\n+\t{\n+\tcase 's':\n+\t  switch_to_section (saddr_section);\n+\t  sec = \".saddr\";\n+\t  break;\n+\t}\n+      if (sec)\n+\t{\n+\t  const char *name2;\n+\t  int p2align = 0;\n+\n+\t  while (align > BITS_PER_UNIT)\n+\t    {\n+\t      align /= 2;\n+\t      p2align ++;\n+\t    }\n+\t  name2 = targetm.strip_name_encoding (name);\n+\t  if (global)\n+\t    fprintf (stream, \"\\t.global\\t_%s\\n\", name2);\n+\t  fprintf (stream, \"\\t.p2align %d\\n\", p2align);\n+\t  fprintf (stream, \"\\t.type\\t_%s,@object\\n\", name2);\n+\t  fprintf (stream, \"\\t.size\\t_%s,%d\\n\", name2, size);\n+\t  fprintf (stream, \"_%s:\\n\\t.zero\\t%d\\n\", name2, size);\n+\t  return;\n+\t}\n+    }\n+\n+  if (!global)\n+    {\n+      fprintf (stream, \"\\t.local\\t\");\n+      assemble_name (stream, name);\n+      fprintf (stream, \"\\n\");\n+    }\n+  fprintf (stream, \"\\t.comm\\t\");\n+  assemble_name (stream, name);\n+  fprintf (stream, \",%u,%u\\n\", size, align / BITS_PER_UNIT);\n+}\n+\n+#undef  TARGET_INSERT_ATTRIBUTES\n+#define TARGET_INSERT_ATTRIBUTES rl78_insert_attributes\n+\n+static void\n+rl78_insert_attributes (tree decl, tree *attributes ATTRIBUTE_UNUSED)\n+{\n+  if (TARGET_ES0\n+      && TREE_CODE (decl) == VAR_DECL\n+      && TREE_READONLY (decl)\n+      && TREE_ADDRESSABLE (decl)\n+      && TYPE_ADDR_SPACE (TREE_TYPE (decl)) == ADDR_SPACE_GENERIC)\n+    {\n+      tree type = TREE_TYPE (decl);\n+      tree attr = TYPE_ATTRIBUTES (type);\n+      int q = TYPE_QUALS_NO_ADDR_SPACE (type) | ENCODE_QUAL_ADDR_SPACE (ADDR_SPACE_FAR);\n+      \n+      TREE_TYPE (decl) = build_type_attribute_qual_variant (type, attr, q);\n+    }\n+}\n+\n+#undef  TARGET_ASM_INTEGER\n+#define TARGET_ASM_INTEGER rl78_asm_out_integer\n+\n+static bool\n+rl78_asm_out_integer (rtx x, unsigned int size, int aligned_p)\n+{\n+  if (default_assemble_integer (x, size, aligned_p))\n+    return true;\n+\n+  if (size == 4)\n+    {\n+      assemble_integer_with_op (\".long\\t\", x);\n+      return true;\n+    }\n+\n+  return false;\n+}\n+ \n+\f\n #undef  TARGET_UNWIND_WORD_MODE\n #define TARGET_UNWIND_WORD_MODE rl78_unwind_word_mode\n \n@@ -3820,7 +4299,111 @@ rl78_unwind_word_mode (void)\n   return HImode;\n }\n \n-\f\n+#ifndef USE_COLLECT2\n+#undef  TARGET_ASM_CONSTRUCTOR\n+#define TARGET_ASM_CONSTRUCTOR rl78_asm_constructor\n+#undef  TARGET_ASM_DESTRUCTOR\n+#define TARGET_ASM_DESTRUCTOR  rl78_asm_destructor\n+\n+static void\n+rl78_asm_ctor_dtor (rtx symbol, int priority, bool is_ctor)\n+{\n+  section *sec;\n+\n+  if (priority != DEFAULT_INIT_PRIORITY)\n+    {\n+      /* This section of the function is based upon code copied\n+\t from: gcc/varasm.c:get_cdtor_priority_section().  */\n+      char buf[16];\n+\n+      sprintf (buf, \"%s.%.5u\", is_ctor ? \".ctors\" : \".dtors\",\n+\t       MAX_INIT_PRIORITY - priority);\n+      sec = get_section (buf, 0, NULL);\n+    }\n+  else\n+    sec = is_ctor ? ctors_section : dtors_section;\n+\n+  assemble_addr_to_section (symbol, sec);\n+}\n+\n+static void\n+rl78_asm_constructor (rtx symbol, int priority)\n+{\n+  rl78_asm_ctor_dtor (symbol, priority, true);\n+}\n+\n+static void\n+rl78_asm_destructor (rtx symbol, int priority)\n+{\n+  rl78_asm_ctor_dtor (symbol, priority, false);\n+}\n+#endif /* ! USE_COLLECT2 */\n+\n+/* Scan backwards through the insn chain looking to see if the flags\n+   have been set for a comparison of OP against OPERAND.  Start with\n+   the insn *before* the current insn.  */\n+\n+bool\n+rl78_flags_already_set (rtx op, rtx operand)\n+{\n+  /* We only track the Z flag.  */\n+  if (GET_CODE (op) != EQ && GET_CODE (op) != NE)\n+    return false;\n+\n+  /* This should not happen, but let's be paranoid.  */\n+  if (current_output_insn == NULL_RTX)\n+    return false;\n+\n+  rtx_insn *insn;\n+  bool res = false;\n+\n+  for (insn = prev_nonnote_nondebug_insn (current_output_insn);\n+       insn != NULL_RTX;\n+       insn = prev_nonnote_nondebug_insn (insn))\n+    {\n+      if (LABEL_P (insn))\n+\tbreak;\n+      \n+      if (! INSN_P (insn))\n+\tcontinue;\n+\n+      /* Make sure that the insn can be recognized.  */\n+      if (recog_memoized (insn) == -1)\n+\tcontinue;\n+\n+      enum attr_update_Z updated = get_attr_update_Z (insn);\n+\n+      rtx set = single_set (insn);\n+      bool must_break = (set != NULL_RTX && rtx_equal_p (operand, SET_DEST (set)));\n+\n+      switch (updated)\n+\t{\n+\tcase UPDATE_Z_NO:\n+\t  break;\n+\tcase UPDATE_Z_CLOBBER:\n+\t  must_break = true;\n+\t  break;\n+\tcase UPDATE_Z_UPDATE_Z:\n+\t  res = must_break;\n+\t  must_break = true;\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+\n+      if (must_break)\n+\tbreak;\n+    }\n+\n+  /* We have to re-recognize the current insn as the call(s) to\n+     get_attr_update_Z() above will have overwritten the recog_data cache.  */\n+  recog_memoized (current_output_insn);\n+  cleanup_subreg_operands (current_output_insn);\n+  constrain_operands_cached (current_output_insn, 1);\n+\n+  return res;\n+}\n+ \f\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-rl78.h\""}, {"sha": "d7ec21c0c8535164f299e314db918078aff6068c", "filename": "gcc/config/rl78/rl78.h", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48c528ae3a2fddd58a7e45b9ef334b42c1ea1686/gcc%2Fconfig%2Frl78%2Frl78.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48c528ae3a2fddd58a7e45b9ef334b42c1ea1686/gcc%2Fconfig%2Frl78%2Frl78.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78.h?ref=48c528ae3a2fddd58a7e45b9ef334b42c1ea1686", "patch": "@@ -134,7 +134,8 @@\n \n #define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC)   1\n \n-#define ADDR_SPACE_FAR\t1\n+#define ADDR_SPACE_NEAR\t\t\t1\n+#define ADDR_SPACE_FAR\t\t\t2\n \n #define HAVE_PRE_DECCREMENT\t\t0\n #define HAVE_POST_INCREMENT\t\t0\n@@ -241,6 +242,8 @@ enum reg_class\n   \"ALL_REGS\"\t\t\t\t\t\t\\\n }\n \n+/* Note that no class may include the second register in $fp, because\n+   we treat $fp as a single HImode register.  */\n #define REG_CLASS_CONTENTS\t\t\t\t\\\n {\t\t\t\t\t\t\t\\\n   { 0x00000000, 0x00000000 },\t/* No registers,  */\t\t\\\n@@ -424,6 +427,16 @@ typedef unsigned int CUMULATIVE_ARGS;\n   fprintf (FILE, \"\\t.long .L%d - 1b\\n\", VALUE)\n \n \n+#define ASM_OUTPUT_SYMBOL_REF(FILE, SYM) rl78_output_symbol_ref ((FILE), (SYM))\n+\n+#define ASM_OUTPUT_LABELREF(FILE, SYM) rl78_output_labelref ((FILE), (SYM))\n+\n+#define ASM_OUTPUT_ALIGNED_DECL_COMMON(STREAM, DECL, NAME, SIZE, ALIGNMENT) \\\n+\trl78_output_aligned_common (STREAM, DECL, NAME, SIZE, ALIGNMENT, 1)\n+\n+#define ASM_OUTPUT_ALIGNED_DECL_LOCAL(STREAM, DECL, NAME, SIZE, ALIGNMENT) \\\n+\trl78_output_aligned_common (STREAM, DECL, NAME, SIZE, ALIGNMENT, 0)\n+\n #define ASM_OUTPUT_ALIGN(STREAM, LOG)\t\t\\\n   do\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\\"}, {"sha": "1e4c14c706e0774619d9eb9dfb1c113dc05ec78f", "filename": "gcc/config/rl78/rl78.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48c528ae3a2fddd58a7e45b9ef334b42c1ea1686/gcc%2Fconfig%2Frl78%2Frl78.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48c528ae3a2fddd58a7e45b9ef334b42c1ea1686/gcc%2Fconfig%2Frl78%2Frl78.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78.opt?ref=48c528ae3a2fddd58a7e45b9ef334b42c1ea1686", "patch": "@@ -53,3 +53,7 @@ Enable assembler and linker relaxation.  Enabled by default at -Os.\n mg10\n Target Mask(G10) Report\n Target the RL78/G10 series\n+\n+mes0\n+Target Mask(ES0)\n+Assume ES is zero throughout program execution, use ES: for read-only data."}]}