{"sha": "db525e17caf9c9158ddcefb32ce577b0c4e7e28b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGI1MjVlMTdjYWY5YzkxNThkZGNlZmIzMmNlNTc3YjBjNGU3ZTI4Yg==", "commit": {"author": {"name": "Jason Eckhardt", "email": "jle@cygnus.com", "date": "2000-03-25T02:39:03Z"}, "committer": {"name": "Jason Eckhardt", "email": "jle@gcc.gnu.org", "date": "2000-03-25T02:39:03Z"}, "message": "bb-reorder.c (REORDER_MOVED_BLOCK_END): Removed.\n\nFri Mar 24 20:13:49 2000  Jason Eckhardt  <jle@cygnus.com>\n\n\t* bb-reorder.c (REORDER_MOVED_BLOCK_END): Removed.\n\t(reorder_block_def): New members eff_head and eff_end.\n\t(REORDER_BLOCK_EFF_HEAD, REORDER_BLOCK_EFF_END): New macros.\n\t(verify_insn_chain): New function.\n\t(skip_insns_between_block): Add code to skip deleted insns.\n\tCheck for note before using.\n\t(chain_reorder_blocks): Replace calls to skip_insns_between_block\n\twith references to REORDER_BLOCK_EFF_HEAD and REORDER_BLOCK_EFF_END.\n\tCheck for note before using.\n\t(make_reorder_chain): Use INTVAL rather than XINT to get REG_BR_PROB.\n\t(fixup_reorder_chain): Restructure, clean up, defect removal.\n\t(reorder_basic_blocks): Remove last_insn and references to it.\n\tMoved insn chain verification code into a new function (see above).\n\tDelete defective code that sets last insn.\n\tInitialize REORDER_BLOCK_EFF_HEAD and REORDER_BLOCK_EFF_END for\n\tall blocks.\n\nFrom-SVN: r32737", "tree": {"sha": "e07f1c3fa8c87cf29e6947460594ad7a32fbfaa4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e07f1c3fa8c87cf29e6947460594ad7a32fbfaa4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/db525e17caf9c9158ddcefb32ce577b0c4e7e28b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db525e17caf9c9158ddcefb32ce577b0c4e7e28b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db525e17caf9c9158ddcefb32ce577b0c4e7e28b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db525e17caf9c9158ddcefb32ce577b0c4e7e28b/comments", "author": null, "committer": null, "parents": [{"sha": "0d74d20f09fe604dab922a7061bbc2b18abf42bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d74d20f09fe604dab922a7061bbc2b18abf42bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d74d20f09fe604dab922a7061bbc2b18abf42bc"}], "stats": {"total": 261, "additions": 183, "deletions": 78}, "files": [{"sha": "c59b77d056679a9b1ddd6cda1f1bbb61de482234", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db525e17caf9c9158ddcefb32ce577b0c4e7e28b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db525e17caf9c9158ddcefb32ce577b0c4e7e28b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=db525e17caf9c9158ddcefb32ce577b0c4e7e28b", "patch": "@@ -1,3 +1,22 @@\n+Fri Mar 24 20:13:49 2000  Jason Eckhardt  <jle@cygnus.com>\n+\n+\t* bb-reorder.c (REORDER_MOVED_BLOCK_END): Removed.\n+\t(reorder_block_def): New members eff_head and eff_end.\n+\t(REORDER_BLOCK_EFF_HEAD, REORDER_BLOCK_EFF_END): New macros.\n+\t(verify_insn_chain): New function.\n+\t(skip_insns_between_block): Add code to skip deleted insns.\n+\tCheck for note before using.\n+\t(chain_reorder_blocks): Replace calls to skip_insns_between_block\n+\twith references to REORDER_BLOCK_EFF_HEAD and REORDER_BLOCK_EFF_END.\n+\tCheck for note before using.\n+\t(make_reorder_chain): Use INTVAL rather than XINT to get REG_BR_PROB.\n+\t(fixup_reorder_chain): Restructure, clean up, defect removal.\n+\t(reorder_basic_blocks): Remove last_insn and references to it.\n+\tMoved insn chain verification code into a new function (see above).\n+\tDelete defective code that sets last insn.\n+\tInitialize REORDER_BLOCK_EFF_HEAD and REORDER_BLOCK_EFF_END for\n+\tall blocks.\n+\n 2000-03-25  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n \n \t* config/c4x/c4x.h (CPP_SPEC): Remove erroneous space."}, {"sha": "000053019895cbb109c120f338f49fb4856d2dae", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 164, "deletions": 78, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db525e17caf9c9158ddcefb32ce577b0c4e7e28b/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db525e17caf9c9158ddcefb32ce577b0c4e7e28b/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=db525e17caf9c9158ddcefb32ce577b0c4e7e28b", "patch": "@@ -60,11 +60,26 @@ typedef struct reorder_block_def {\n   rtx end;\n   int block_begin;\n   int block_end;\n+  rtx eff_head;\n+  rtx eff_end;\n } *reorder_block_def;\n \n+static struct reorder_block_def rbd_init\n+= {\n+    0,\t\t\t/* flags */\n+    0,\t\t\t/* index */\n+    NULL,\t\t/* add_jump */\n+    NULL,\t\t/* succ */\n+    NULL_RTX,\t\t/* end */\n+    0,\t\t\t/* block_begin */\n+    0,\t\t\t/* block_end */\n+    NULL_RTX,\t\t/* eff_head */\n+    NULL_RTX\t\t/* eff_end */\n+};\n+\n+\n #define REORDER_BLOCK_HEAD\t0x1\n #define REORDER_BLOCK_VISITED\t0x2\n-#define REORDER_MOVED_BLOCK_END 0x3\n   \n #define REORDER_BLOCK_FLAGS(bb) \\\n   ((reorder_block_def) (bb)->aux)->flags\n@@ -87,6 +102,12 @@ typedef struct reorder_block_def {\n #define REORDER_BLOCK_END(bb) \\\n   ((reorder_block_def) (bb)->aux)->block_end\n \n+#define REORDER_BLOCK_EFF_HEAD(bb) \\\n+  ((reorder_block_def) (bb)->aux)->eff_head\n+\n+#define REORDER_BLOCK_EFF_END(bb) \\\n+  ((reorder_block_def) (bb)->aux)->eff_end\n+\n \n static int reorder_index;\n static basic_block reorder_last_visited;\n@@ -102,6 +123,7 @@ static basic_block get_common_dest\tPARAMS ((basic_block, basic_block));\n static basic_block chain_reorder_blocks\tPARAMS ((edge, basic_block));\n static void make_reorder_chain\t\tPARAMS ((basic_block));\n static void fixup_reorder_chain\t\tPARAMS ((void));\n+static void verify_insn_chain\t\tPARAMS ((void));\n \n \n /* Skip over insns BEFORE or AFTER BB which are typically associated with\n@@ -136,7 +158,6 @@ skip_insns_between_block (bb, skip_type)\n \t  break;\n \t}\n     }\n-\n   else\n     {\n       last_insn = bb->end;\n@@ -153,7 +174,7 @@ skip_insns_between_block (bb, skip_type)\n \t    break;\n \n \t  if (GET_CODE (insn) == BARRIER\n-\t      || GET_CODE (insn) == JUMP_INSN\n+\t      || GET_CODE (insn) == JUMP_INSN \n \t      || (GET_CODE (insn) == NOTE\n \t\t  && (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END\n \t\t      || NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END)))\n@@ -168,6 +189,13 @@ skip_insns_between_block (bb, skip_type)\n \t      insn = NEXT_INSN (insn);\n \t      continue;\n \t    }\n+\n+\t  /* Skip to next non-deleted insn.  */\n+\t  if (GET_CODE (insn) == NOTE\n+\t      && (NOTE_LINE_NUMBER (insn) == NOTE_INSN_DELETED\n+\t\t  || NOTE_LINE_NUMBER (insn) == NOTE_INSN_DELETED_LABEL))\n+\t    continue; \n+\n \t  break;\n \t}\n \n@@ -181,18 +209,21 @@ skip_insns_between_block (bb, skip_type)\n \t\t  && insn == BASIC_BLOCK (bb->index + 1)->head)\n \t\tbreak;\n \n-\t      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END)\n+\t      if (GET_CODE (insn) == NOTE\n+\t\t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END)\n \t\t{\n \t\t  found_block_end = 1;\n \t\t  continue;\n \t\t}\n \n-\t      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_DELETED)\n+\t      if (GET_CODE (insn) == NOTE\n+\t\t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_DELETED)\n \t\tcontinue;\n \n \t      if (GET_CODE (insn) == NOTE\n \t\t  && NOTE_LINE_NUMBER (insn) >= 0\n \t\t  && NEXT_INSN (insn)\n+\t\t  && GET_CODE (NEXT_INSN (insn)) == NOTE\n \t\t  && (NOTE_LINE_NUMBER (NEXT_INSN (insn))\n \t\t      == NOTE_INSN_BLOCK_END))\n \t\tcontinue;\n@@ -255,8 +286,8 @@ chain_reorder_blocks (e, ceb)\n \t     \"Edge from basic block %d to basic block %d last visited %d\\n\",\n \t     sb->index, db->index, ceb->index);\n \n-  dbh_insn = skip_insns_between_block (db, REORDER_SKIP_BEFORE);\n-  cebe_insn = skip_insns_between_block (ceb, REORDER_SKIP_AFTER);\n+  dbh_insn = REORDER_BLOCK_EFF_HEAD (db);\n+  cebe_insn = REORDER_BLOCK_EFF_END (ceb);\n   cebbe_insn = skip_insns_between_block (ceb, REORDER_SKIP_BLOCK_END);\n \n   {\n@@ -265,7 +296,8 @@ chain_reorder_blocks (e, ceb)\n \n     for (insn = dbh_insn; insn && insn != db->end; insn = NEXT_INSN (insn))\n       {\n-\tif (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_BEG)\n+\tif (GET_CODE (insn) == NOTE\n+\t    && NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_BEG)\n \t  {\n \t    block_begins += 1;\n \t    break;\n@@ -283,7 +315,8 @@ chain_reorder_blocks (e, ceb)\n \t{\n \t  if (PREV_INSN (insn) == cebbe_insn)\n \t    break;\n-\t  if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END)\n+\t  if (GET_CODE (insn) == NOTE\n+\t      && NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END)\n \t    {\n \t      block_ends += 1;\n \t      continue;\n@@ -438,9 +471,9 @@ chain_reorder_blocks (e, ceb)\n       REORDER_BLOCK_ADD_JUMP (db) = last_edge->dest;\n     }\n \n-  dbh_insn = skip_insns_between_block (db, REORDER_SKIP_BEFORE);\n-  cebe_insn = skip_insns_between_block (ceb, REORDER_SKIP_AFTER);\n-  dbe_insn = skip_insns_between_block (db, REORDER_SKIP_AFTER);\n+  dbh_insn = REORDER_BLOCK_EFF_HEAD (db);\n+  cebe_insn = REORDER_BLOCK_EFF_END (ceb);\n+  dbe_insn = REORDER_BLOCK_EFF_END (db);\n \n   /* Leave behind any lexical block markers.  */\n   if (debug_info_level > DINFO_LEVEL_TERSE\n@@ -484,7 +517,7 @@ chain_reorder_blocks (e, ceb)\n }\n \n \n-/* Reorder blocks starting at block B.  */\n+/* Reorder blocks starting at block BB.  */\n \n static void\n make_reorder_chain (bb)\n@@ -506,7 +539,7 @@ make_reorder_chain (bb)\n       rtx note = find_reg_note (block_end, REG_BR_PROB, 0);\n \n       if (note) \n-\tprobability = XINT (XEXP (note, 0), 0);\n+\tprobability = INTVAL (XEXP (note, 0));\n       else\n \tprobability = 0;\n \n@@ -577,50 +610,66 @@ fixup_reorder_chain ()\n {\n   int i, j;\n   rtx insn;\n+  int orig_num_blocks = n_basic_blocks;\n \n   /* Set the new last insn.  */\n-  for (i = 0;\n-       i < n_basic_blocks - 1\n-\t && REORDER_BLOCK_INDEX (BASIC_BLOCK (i)) != n_basic_blocks;\n-       i++)\n-    continue;\n-\n-  for (insn = BASIC_BLOCK (i)->head;\n-       NEXT_INSN (insn) != 0;\n-       insn = NEXT_INSN (insn))\n-    continue;\n-\n-  set_last_insn (insn);\n+  {\n+    int max_val = 0;\n+    int max_index = 0;\n+    for (j = 0; j < n_basic_blocks; j++) \n+      {\n+\tint val = REORDER_BLOCK_INDEX (BASIC_BLOCK (j));\n+\tif (val > max_val)\n+\t  {\n+\t    max_val = val;\n+\t    max_index = j;\n+\t  }\n+      }\n+    insn = REORDER_BLOCK_EFF_END (BASIC_BLOCK (max_index));\n+    NEXT_INSN (insn) = NULL_RTX;\n+    set_last_insn (insn);\n+  }\n \n   /* Add jumps and labels to fixup blocks.  */\n-  for (i = 0; i < n_basic_blocks - 1; i++)\n+  for (i = 0; i < orig_num_blocks; i++)\n     {\n+      int need_block = 0;\n       basic_block bbi = BASIC_BLOCK (i);\n       if (REORDER_BLOCK_ADD_JUMP (bbi))\n \t{\n \t  rtx label_insn, jump_insn, barrier_insn;\n \n-\t  if (GET_CODE (REORDER_BLOCK_ADD_JUMP (bbi)->head)\n-\t      == CODE_LABEL)\n+\t  if (GET_CODE (REORDER_BLOCK_ADD_JUMP (bbi)->head) == CODE_LABEL)\n \t    label_insn  = REORDER_BLOCK_ADD_JUMP (bbi)->head;\n \t  else\n \t    {\n \t      rtx new_label = gen_label_rtx ();\n \t      label_insn = emit_label_before (new_label,\n \t\t\t      REORDER_BLOCK_ADD_JUMP (bbi)->head);\n+\t      REORDER_BLOCK_ADD_JUMP (bbi)->head = label_insn;\t \n+\t    }\n+\n+\t  if (GET_CODE (bbi->end) != JUMP_INSN)\n+\t    {\n+\t      jump_insn = emit_jump_insn_after (gen_jump (label_insn),\n+\t\t\t\t\t\tbbi->end);\n+\t      bbi->end = jump_insn;\n+\t      need_block = 0;\n+\t    }\n+\t  else\n+\t    {\n+\t      jump_insn = emit_jump_insn_after (gen_jump (label_insn),\n+\t\t\t\t\t\tREORDER_BLOCK_EFF_END (bbi));\n+\t      need_block = 1;\n \t    }\n-\t  REORDER_BLOCK_ADD_JUMP (bbi)->head = label_insn;\t \n \n-\t  jump_insn = emit_jump_insn_after (gen_jump (label_insn),\n-\t\t\t\t\t    bbi->end);\n \t  JUMP_LABEL (jump_insn) = label_insn;\n \t  ++LABEL_NUSES (label_insn);\n \t  barrier_insn = emit_barrier_after (jump_insn);\n-\t  if (GET_CODE (bbi->end) != JUMP_INSN)\n-\t    bbi->end = jump_insn;\n+\n \t  /* Add block for jump.  Typically this is when a then is not\n \t     predicted and we are jumping to the moved then block.  */\n-\t  else\t\n+\t  if (need_block)\n \t    {\n \t      basic_block nb;\n \n@@ -664,6 +713,70 @@ fixup_reorder_chain ()\n }\n \n \n+/* Perform sanity checks on the insn chain.\n+   1. Check that next/prev pointers are consistent in both the forward and\n+      reverse direction.\n+   2. Count insns in chain, going both directions, and check if equal.\n+   3. Check that get_last_insn () returns the actual end of chain.  */\n+\n+static void\n+verify_insn_chain ()\n+{\n+  rtx x,\n+      prevx,\n+      nextx;\n+  int insn_cnt1,\n+      insn_cnt2;\n+\n+  prevx = NULL;\n+  insn_cnt1 = 1;\n+  for (x = get_insns (); x; x = NEXT_INSN (x))\n+    {\n+      if (PREV_INSN (x) != prevx)\n+\t{\n+\t  fprintf (stderr, \"Forward traversal: insn chain corrupt.\\n\");\n+\t  fprintf (stderr, \"previous insn:\\n\");\n+\t  debug_rtx (prevx);\n+\t  fprintf (stderr, \"current insn:\\n\");\n+\t  debug_rtx (x);\n+\t  abort ();\n+\t}\n+      ++insn_cnt1;\n+      prevx = x;\n+    }\n+\n+  if (prevx != get_last_insn ())\n+    {\n+      fprintf (stderr, \"last_insn corrupt.\\n\");\n+      abort ();\n+    }\n+\n+  nextx = NULL;\n+  insn_cnt2 = 1;\n+  for (x = get_last_insn (); x; x = PREV_INSN (x))\n+    {\n+      if (NEXT_INSN (x) != nextx)\n+\t{\n+\t  fprintf (stderr, \"Reverse traversal: insn chain corrupt.\\n\");\n+\t  fprintf (stderr, \"current insn:\\n\");\n+\t  debug_rtx (x);\n+\t  fprintf (stderr, \"next insn:\\n\");\n+\t  debug_rtx (nextx);\n+\t  abort ();\n+\t}\n+      ++insn_cnt2;\n+      nextx = x;\n+    }\n+\n+  if (insn_cnt1 != insn_cnt2)\n+    {\n+      fprintf (stderr, \"insn_cnt1 (%d) not equal to insn_cnt2 (%d).\\n\",\n+\t       insn_cnt1, insn_cnt2);\n+      abort ();\n+    }\n+}\n+\n+\n /* Reorder basic blocks.  */\n \n void\n@@ -672,7 +785,6 @@ reorder_basic_blocks ()\n   int i, j;\n   struct loops loops_info;\n   int num_loops;\n-  rtx last_insn;\n \n   if (profile_arc_flag)\n     return;\n@@ -708,35 +820,27 @@ reorder_basic_blocks ()\n   reorder_last_visited = BASIC_BLOCK (0);\n \n   for (i = 0; i < n_basic_blocks; i++)\n-    BASIC_BLOCK (i)->aux = xcalloc (1, sizeof (struct reorder_block_def));\n+    {\n+      basic_block bbi = BASIC_BLOCK (i);\n+      bbi->aux = xcalloc (1, sizeof (struct reorder_block_def));\n+      *((struct reorder_block_def *)bbi->aux) = rbd_init;\n+      REORDER_BLOCK_EFF_END (bbi)\n+\t= skip_insns_between_block (bbi, REORDER_SKIP_AFTER);\n+      if (i == 0)\n+\tREORDER_BLOCK_EFF_HEAD (bbi) = get_insns ();\n+      else \n+\t{\n+\t  rtx prev_eff_end = REORDER_BLOCK_EFF_END (BASIC_BLOCK (i - 1));\n+\t  REORDER_BLOCK_EFF_HEAD (bbi) = NEXT_INSN (prev_eff_end);\n+\t}\n+    }\n       \n-  last_insn\n-    = NEXT_INSN (skip_insns_between_block (BASIC_BLOCK (n_basic_blocks - 1),\n-\t\t\t\t\t   REORDER_SKIP_AFTER));\n-\n   make_reorder_chain (BASIC_BLOCK (0));\n \n   fixup_reorder_chain ();\n \n #ifdef ENABLE_CHECKING\n-    {\n-      rtx insn, last_insn;\n-      last_insn = get_insns ();\n-      for (insn = NEXT_INSN (get_insns ());\n-\t   insn && PREV_INSN (insn) == last_insn\n-\t     && NEXT_INSN (PREV_INSN (insn)) == insn;\n-\t   last_insn = insn,\n-\t     insn = NEXT_INSN (insn))\n-\tcontinue;\n-\n-      if (insn)\n-\t{\n-\t  if (rtl_dump_file)\n-\t    fprintf (rtl_dump_file, \"insn chaining error at %d\\n\",\n-\t\t     INSN_UID (last_insn));\n-\t  abort();\n-\t}\n-    }\n+  verify_insn_chain ();\n #endif\n \n   /* Put basic_block_info in new order.  */\n@@ -760,25 +864,6 @@ reorder_basic_blocks ()\n \t  BASIC_BLOCK (j) = tempbb;\n \t}\n     }\n-     \n-    {\n-      rtx xafter = skip_insns_between_block (BASIC_BLOCK (n_basic_blocks - 1),\n-\t\t\t\t\t     REORDER_SKIP_AFTER);\n-      if (xafter)\n-\t{\n-\t  NEXT_INSN (xafter) = last_insn;\n-\t  if (last_insn)\n-\t    {\n-\t      rtx x = last_insn;\n-\t      PREV_INSN (last_insn) = xafter;\n-\t      while (NEXT_INSN (x))\n-\t\tx = NEXT_INSN (x);\n-\t      set_last_insn (x);\n-\t    }\n-\t}\n-      else\n-\tabort();\n-    }\n \n #ifdef ENABLE_CHECKING\n   verify_flow_info ();\n@@ -789,5 +874,6 @@ reorder_basic_blocks ()\n \n   /* Free loop information.  */\n   flow_loops_free (&loops_info);\n+\n }\n "}]}