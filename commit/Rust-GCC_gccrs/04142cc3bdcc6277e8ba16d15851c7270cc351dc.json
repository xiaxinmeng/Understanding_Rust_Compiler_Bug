{"sha": "04142cc3bdcc6277e8ba16d15851c7270cc351dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDQxNDJjYzNiZGNjNjI3N2U4YmExNmQxNTg1MWM3MjcwY2MzNTFkYw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-05-10T20:17:36Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-05-10T20:17:36Z"}, "message": "cgraph.h (cgraph_remove_unreachable_nodes): Rename to ...\n\n\t* cgraph.h (cgraph_remove_unreachable_nodes): Rename to ...\n\t(symtab_remove_unreachable_nodes): ... this one.\n\t* ipa-cp.c (ipcp_driver): Do not remove unreachable nodes.\n\t* cgraphunit.c (ipa_passes): Update.\n\t* cgraphclones.c (cgraph_materialize_all_clones): Update.\n\t* cgraph.c (cgraph_release_function_body): Only turn initial\n\tinto error mark when initial was previously set.\n\t* ipa-inline.c (ipa_inline): Update.\n\t* ipa.c: Include ipa-inline.h\n\t(enqueue_cgraph_node, enqueue_varpool_node): Remove.\n\t(enqueue_node): New function.\n\t(process_references): Update.\n\t(symtab_remove_unreachable_nodes): Cleanup.\n\t* passes.c (execute_todo, execute_one_pass): Update.\n\nFrom-SVN: r187375", "tree": {"sha": "18ba5f9010349d86c117dab0e950fe951713a9c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/18ba5f9010349d86c117dab0e950fe951713a9c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/04142cc3bdcc6277e8ba16d15851c7270cc351dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04142cc3bdcc6277e8ba16d15851c7270cc351dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04142cc3bdcc6277e8ba16d15851c7270cc351dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04142cc3bdcc6277e8ba16d15851c7270cc351dc/comments", "author": null, "committer": null, "parents": [{"sha": "3af2e3b5b222b87032188da8fb05f3fcaa497d66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3af2e3b5b222b87032188da8fb05f3fcaa497d66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3af2e3b5b222b87032188da8fb05f3fcaa497d66"}], "stats": {"total": 389, "additions": 192, "deletions": 197}, "files": [{"sha": "47b258e926004254a13ba8b152fac91d4e6ef076", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04142cc3bdcc6277e8ba16d15851c7270cc351dc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04142cc3bdcc6277e8ba16d15851c7270cc351dc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=04142cc3bdcc6277e8ba16d15851c7270cc351dc", "patch": "@@ -1,3 +1,20 @@\n+2012-05-10  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.h (cgraph_remove_unreachable_nodes): Rename to ...\n+\t(symtab_remove_unreachable_nodes): ... this one.\n+\t* ipa-cp.c (ipcp_driver): Do not remove unreachable nodes.\n+\t* cgraphunit.c (ipa_passes): Update.\n+\t* cgraphclones.c (cgraph_materialize_all_clones): Update.\n+\t* cgraph.c (cgraph_release_function_body): Only turn initial\n+\tinto error mark when initial was previously set.\n+\t* ipa-inline.c (ipa_inline): Update.\n+\t* ipa.c: Include ipa-inline.h\n+\t(enqueue_cgraph_node, enqueue_varpool_node): Remove.\n+\t(enqueue_node): New function.\n+\t(process_references): Update.\n+\t(symtab_remove_unreachable_nodes): Cleanup.\n+\t* passes.c (execute_todo, execute_one_pass): Update.\n+\n 2012-05-10  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR rtl-optimization/53125"}, {"sha": "88ef1f14e93e894f9bb4206d37b68b933ffe2d0d", "filename": "gcc/cgraph.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04142cc3bdcc6277e8ba16d15851c7270cc351dc/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04142cc3bdcc6277e8ba16d15851c7270cc351dc/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=04142cc3bdcc6277e8ba16d15851c7270cc351dc", "patch": "@@ -1162,7 +1162,7 @@ cgraph_release_function_body (struct cgraph_node *node)\n   /* If the node is abstract and needed, then do not clear DECL_INITIAL\n      of its associated function function declaration because it's\n      needed to emit debug info later.  */\n-  if (!node->abstract_and_needed)\n+  if (!node->abstract_and_needed && DECL_INITIAL (node->symbol.decl))\n     DECL_INITIAL (node->symbol.decl) = error_mark_node;\n }\n "}, {"sha": "a4c23b35ec5fdd6cff12174c7f29505f1bd4c952", "filename": "gcc/cgraph.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04142cc3bdcc6277e8ba16d15851c7270cc351dc/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04142cc3bdcc6277e8ba16d15851c7270cc351dc/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=04142cc3bdcc6277e8ba16d15851c7270cc351dc", "patch": "@@ -637,7 +637,7 @@ int compute_call_stmt_bb_frequency (tree, basic_block bb);\n void record_references_in_initializer (tree, bool);\n \n /* In ipa.c  */\n-bool cgraph_remove_unreachable_nodes (bool, FILE *);\n+bool symtab_remove_unreachable_nodes (bool, FILE *);\n cgraph_node_set cgraph_node_set_new (void);\n cgraph_node_set_iterator cgraph_node_set_find (cgraph_node_set,\n \t\t\t\t\t       struct cgraph_node *);"}, {"sha": "7a6fb64241318fd4e56a4372af640bf0401fd9c7", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04142cc3bdcc6277e8ba16d15851c7270cc351dc/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04142cc3bdcc6277e8ba16d15851c7270cc351dc/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=04142cc3bdcc6277e8ba16d15851c7270cc351dc", "patch": "@@ -870,7 +870,7 @@ cgraph_materialize_all_clones (void)\n #ifdef ENABLE_CHECKING\n   verify_cgraph ();\n #endif\n-  cgraph_remove_unreachable_nodes (false, cgraph_dump_file);\n+  symtab_remove_unreachable_nodes (false, cgraph_dump_file);\n }\n \n #include \"gt-cgraphclones.h\""}, {"sha": "52c69b04f160ae18c6e72f829836e297ede83e93", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04142cc3bdcc6277e8ba16d15851c7270cc351dc/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04142cc3bdcc6277e8ba16d15851c7270cc351dc/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=04142cc3bdcc6277e8ba16d15851c7270cc351dc", "patch": "@@ -1836,7 +1836,7 @@ ipa_passes (void)\n      because TODO is run before the subpasses.  It is important to remove\n      the unreachable functions to save works at IPA level and to get LTO\n      symbol tables right.  */\n-  cgraph_remove_unreachable_nodes (true, cgraph_dump_file);\n+  symtab_remove_unreachable_nodes (true, cgraph_dump_file);\n \n   /* If pass_all_early_optimizations was not scheduled, the state of\n      the cgraph will not be properly updated.  Update it now.  */\n@@ -1962,7 +1962,7 @@ compile (void)\n \n   /* This pass remove bodies of extern inline functions we never inlined.\n      Do this later so other IPA passes see what is really going on.  */\n-  cgraph_remove_unreachable_nodes (false, dump_file);\n+  symtab_remove_unreachable_nodes (false, dump_file);\n   cgraph_global_info_ready = true;\n   if (cgraph_dump_file)\n     {\n@@ -1987,7 +1987,7 @@ compile (void)\n   cgraph_materialize_all_clones ();\n   bitmap_obstack_initialize (NULL);\n   execute_ipa_pass_list (all_late_ipa_passes);\n-  cgraph_remove_unreachable_nodes (true, dump_file);\n+  symtab_remove_unreachable_nodes (true, dump_file);\n #ifdef ENABLE_CHECKING\n   verify_symtab ();\n #endif"}, {"sha": "533398b4f7b4dc7de79ac303d039eaef15e31e35", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04142cc3bdcc6277e8ba16d15851c7270cc351dc/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04142cc3bdcc6277e8ba16d15851c7270cc351dc/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=04142cc3bdcc6277e8ba16d15851c7270cc351dc", "patch": "@@ -2445,7 +2445,6 @@ ipcp_driver (void)\n   struct cgraph_2edge_hook_list *edge_duplication_hook_holder;\n   struct topo_info topo;\n \n-  cgraph_remove_unreachable_nodes (true,dump_file);\n   ipa_check_create_node_params ();\n   ipa_check_create_edge_args ();\n   grow_next_edge_clone_vector ();"}, {"sha": "78a8e47cd0d2db65f1bf0a0573122580fd42afcf", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04142cc3bdcc6277e8ba16d15851c7270cc351dc/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04142cc3bdcc6277e8ba16d15851c7270cc351dc/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=04142cc3bdcc6277e8ba16d15851c7270cc351dc", "patch": "@@ -1717,7 +1717,7 @@ ipa_inline (void)\n     }\n \n   inline_small_functions ();\n-  cgraph_remove_unreachable_nodes (true, dump_file);\n+  symtab_remove_unreachable_nodes (true, dump_file);\n   free (order);\n \n   /* We already perform some inlining of functions called once during"}, {"sha": "766b26f03138b0f69e712731c1d711fb08374f2c", "filename": "gcc/ipa.c", "status": "modified", "additions": 166, "deletions": 187, "changes": 353, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04142cc3bdcc6277e8ba16d15851c7270cc351dc/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04142cc3bdcc6277e8ba16d15851c7270cc351dc/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=04142cc3bdcc6277e8ba16d15851c7270cc351dc", "patch": "@@ -33,6 +33,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-iterator.h\"\n #include \"ipa-utils.h\"\n #include \"pointer-set.h\"\n+#include \"ipa-inline.h\"\n \n /* Look for all functions inlined to NODE and update their inlined_to pointers\n    to INLINED_TO.  */\n@@ -49,7 +50,7 @@ update_inlined_to_pointer (struct cgraph_node *node, struct cgraph_node *inlined\n       }\n }\n \n-/* Add cgraph NODE to queue starting at FIRST.\n+/* Add symtab NODE to queue starting at FIRST.\n \n    The queue is linked via AUX pointers and terminated by pointer to 1.\n    We enqueue nodes at two occasions: when we find them reachable or when we find\n@@ -58,8 +59,8 @@ update_inlined_to_pointer (struct cgraph_node *node, struct cgraph_node *inlined\n    reachable.  */\n \n static void\n-enqueue_cgraph_node (struct cgraph_node *node, struct cgraph_node **first,\n-\t\t     struct pointer_set_t *reachable)\n+enqueue_node (symtab_node node, symtab_node *first,\n+\t      struct pointer_set_t *reachable)\n {\n   /* Node is still in queue; do nothing.  */\n   if (node->symbol.aux && node->symbol.aux != (void *) 2)\n@@ -72,21 +73,11 @@ enqueue_cgraph_node (struct cgraph_node *node, struct cgraph_node **first,\n   *first = node;\n }\n \n-/* Add varpool NODE to queue starting at FIRST.  */\n-\n-static void\n-enqueue_varpool_node (struct varpool_node *node, struct varpool_node **first)\n-{\n-  node->symbol.aux = *first;\n-  *first = node;\n-}\n-\n /* Process references.  */\n \n static void\n process_references (struct ipa_ref_list *list,\n-\t\t    struct cgraph_node **first,\n-\t\t    struct varpool_node **first_varpool,\n+\t\t    symtab_node *first,\n \t\t    bool before_inlining_p,\n \t\t    struct pointer_set_t *reachable)\n {\n@@ -97,18 +88,21 @@ process_references (struct ipa_ref_list *list,\n       if (symtab_function_p (ref->referred))\n \t{\n \t  struct cgraph_node *node = ipa_ref_node (ref);\n+\n \t  if (node->analyzed\n \t      && (!DECL_EXTERNAL (node->symbol.decl)\n \t\t  || node->alias\n \t          || before_inlining_p))\n \t    pointer_set_insert (reachable, node);\n-\t  enqueue_cgraph_node (node, first, reachable);\n+\t  enqueue_node ((symtab_node) node, first, reachable);\n \t}\n       else\n \t{\n \t  struct varpool_node *node = ipa_ref_varpool_node (ref);\n-\t  if (!pointer_set_insert (reachable, node))\n-\t    enqueue_varpool_node (node, first_varpool);\n+\n+\t  if (node->analyzed)\n+\t    pointer_set_insert (reachable, node);\n+\t  enqueue_node ((symtab_node) node, first, reachable);\n \t}\n     }\n }\n@@ -162,19 +156,63 @@ has_addr_references_p (struct cgraph_node *node,\n }\n \n /* Perform reachability analysis and reclaim all unreachable nodes.\n-   If BEFORE_INLINING_P is true this function is called before inlining\n-   decisions has been made.  If BEFORE_INLINING_P is false this function also\n-   removes unneeded bodies of extern inline functions.  */\n+\n+   The algorithm is basically mark&sweep but with some extra refinements:\n+\n+   - reachable extern inline functions needs special handling; the bodies needs\n+     to stay in memory until inlining in hope that they will be inlined.\n+     After inlining we release their bodies and turn them into unanalyzed\n+     nodes even when they are reachable.\n+\n+     BEFORE_INLINING_P specify whether we are before or after inlining.\n+\n+   - virtual functions are kept in callgraph even if they seem unreachable in\n+     hope calls to them will be devirtualized. \n+\n+     Again we remove them after inlining.  In late optimization some\n+     devirtualization may happen, but it is not importnat since we won't inline\n+     the call. In theory early opts and IPA should work out all important cases.\n+\n+   - virtual clones needs bodies of their origins for later materialization;\n+     this means that we want to keep the body even if the origin is unreachable\n+     otherwise.  To avoid origin from sitting in the callgraph and being\n+     walked by IPA passes, we turn them into unanalyzed nodes with body\n+     defined.\n+\n+     We maintain set of function declaration where body needs to stay in\n+     body_needed_for_clonning\n+\n+     Inline clones represent special case: their declaration match the\n+     declaration of origin and cgraph_remove_node already knows how to\n+     reshape callgraph and preserve body when offline copy of function or\n+     inline clone is being removed.\n+\n+   We maintain queue of both reachable symbols (i.e. defined symbols that needs\n+   to stay) and symbols that are in boundary (i.e. external symbols referenced\n+   by reachable symbols or origins of clones).  The queue is represented\n+   as linked list by AUX pointer terminated by 1.\n+\n+   A the end we keep all reachable symbols. For symbols in boundary we always\n+   turn definition into a declaration, but we may keep function body around\n+   based on body_needed_for_clonning\n+\n+   All symbols that enter the queue have AUX pointer non-zero and are in the\n+   boundary.  Pointer set REACHABLE is used to track reachable symbols.\n+\n+   Every symbol can be visited twice - once as part of boundary and once\n+   as real reachable symbol. enqueue_node needs to decide whether the\n+   node needs to be re-queued for second processing.  For this purpose\n+   we set AUX pointer of processed symbols in the boundary to constant 2.  */\n \n bool\n-cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n+symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n {\n-  struct cgraph_node *first = (struct cgraph_node *) (void *) 1;\n-  struct varpool_node *first_varpool = (struct varpool_node *) (void *) 1;\n+  symtab_node first = (symtab_node) (void *) 1;\n   struct cgraph_node *node, *next;\n   struct varpool_node *vnode, *vnext;\n   bool changed = false;\n   struct pointer_set_t *reachable = pointer_set_create ();\n+  struct pointer_set_t *body_needed_for_clonning = pointer_set_create ();\n \n #ifdef ENABLE_CHECKING\n   verify_symtab ();\n@@ -191,207 +229,135 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n      This is mostly when they can be referenced externally.  Inline clones\n      are special since their declarations are shared with master clone and thus\n      cgraph_can_remove_if_no_direct_calls_and_refs_p should not be called on them.  */\n-  FOR_EACH_FUNCTION (node)\n-    if (node->analyzed && !node->global.inlined_to\n+  FOR_EACH_DEFINED_FUNCTION (node)\n+    if (!node->global.inlined_to\n \t&& (!cgraph_can_remove_if_no_direct_calls_and_refs_p (node)\n \t    /* Keep around virtual functions for possible devirtualization.  */\n \t    || (before_inlining_p\n \t\t&& DECL_VIRTUAL_P (node->symbol.decl)\n \t\t&& (DECL_COMDAT (node->symbol.decl) || DECL_EXTERNAL (node->symbol.decl)))))\n       {\n         gcc_assert (!node->global.inlined_to);\n-\tenqueue_cgraph_node (node, &first, reachable);\n \tpointer_set_insert (reachable, node);\n+\tenqueue_node ((symtab_node)node, &first, reachable);\n       }\n     else\n       gcc_assert (!node->symbol.aux);\n \n   /* Mark variables that are obviously needed.  */\n-  FOR_EACH_VARIABLE (vnode)\n+  FOR_EACH_DEFINED_VARIABLE (vnode)\n+    if (!varpool_can_remove_if_no_refs (vnode))\n+      {\n+\tpointer_set_insert (reachable, vnode);\n+\tenqueue_node ((symtab_node)vnode, &first, reachable);\n+      }\n+\n+  /* Perform reachability analysis.  */\n+  while (first != (symtab_node) (void *) 1)\n     {\n-      if ((vnode->analyzed || vnode->symbol.force_output)\n-\t  && !varpool_can_remove_if_no_refs (vnode))\n-\t{\n-\t  pointer_set_insert (reachable, vnode);\n-\t  enqueue_varpool_node (vnode, &first_varpool);\n-\t}\n-    }\n+      bool in_boundary_p = !pointer_set_contains (reachable, first);\n+      symtab_node node = first;\n \n-  /* Perform reachability analysis.  As a special case do not consider\n-     extern inline functions not inlined as live because we won't output\n-     them at all. \n+      first = (symtab_node)first->symbol.aux;\n \n-     We maintain two worklist, one for cgraph nodes other for varpools and\n-     are finished once both are empty.  */\n+      /* If we are processing symbol in boundary, mark its AUX pointer for\n+\t possible later re-processing in enqueue_node.  */\n+      if (in_boundary_p)\n+\tnode->symbol.aux = (void *)2;\n+      else\n+\t{\n+\t  /* If any symbol in a comdat group is reachable, force\n+\t     all other in the same comdat group to be also reachable.  */\n+\t  if (node->symbol.same_comdat_group)\n+\t    {\n+\t      symtab_node next;\n+\t      for (next = node->symbol.same_comdat_group;\n+\t\t   next != node;\n+\t\t   next = next->symbol.same_comdat_group)\n+\t\tif (!pointer_set_insert (reachable, next))\n+\t\t  enqueue_node ((symtab_node) next, &first, reachable);\n+\t    }\n+\t  /* Mark references as reachable.  */\n+\t  process_references (&node->symbol.ref_list, &first,\n+\t\t\t      before_inlining_p, reachable);\n+\t}\n \n-  while (first != (struct cgraph_node *) (void *) 1\n-  \t || first_varpool != (struct varpool_node *) (void *) 1)\n-    {\n-      if (first != (struct cgraph_node *) (void *) 1)\n+      if (symtab_function_p (node))\n \t{\n-\t  struct cgraph_edge *e;\n-\t  node = first;\n-\t  first = (struct cgraph_node *) first->symbol.aux;\n-\t  if (!pointer_set_contains (reachable, node))\n-\t    node->symbol.aux = (void *)2;\n-\t  /* If we found this node reachable, first mark on the callees\n-\t     reachable too, unless they are direct calls to extern inline functions\n-\t     we decided to not inline.  */\n-\t  else \n+\t  struct cgraph_node *cnode = cgraph (node);\n+\n+\t  /* Mark the callees reachable unless they are direct calls to extern\n+ \t     inline functions we decided to not inline.  */\n+\t  if (!in_boundary_p)\n \t    {\n-\t      for (e = node->callees; e; e = e->next_callee)\n+\t      struct cgraph_edge *e;\n+\t      for (e = cnode->callees; e; e = e->next_callee)\n \t\t{\n-\t\t  if (node->analyzed\n+\t\t  if (e->callee->analyzed\n \t\t      && (!e->inline_failed\n \t\t\t  || !DECL_EXTERNAL (e->callee->symbol.decl)\n-\t\t\t  || node->alias\n+\t\t\t  || cnode->alias\n \t\t\t  || before_inlining_p))\n \t\t    pointer_set_insert (reachable, e->callee);\n-\t\t  enqueue_cgraph_node (e->callee, &first, reachable);\n-\t\t}\n-\t      process_references (&node->symbol.ref_list, &first,\n-\t\t\t\t  &first_varpool, before_inlining_p,\n-\t\t\t\t  reachable);\n-\n-\t      /* If any function in a comdat group is reachable, force\n-\t\t all other functions in the same comdat group to be\n-\t\t also reachable.  */\n-\t      if (node->symbol.same_comdat_group\n-\t\t  && !node->global.inlined_to)\n-\t\t{\n-\t\t  for (next = cgraph (node->symbol.same_comdat_group);\n-\t\t       next != node;\n-\t\t       next = cgraph (next->symbol.same_comdat_group))\n-\t\t    if (!pointer_set_insert (reachable, next))\n-\t\t      enqueue_cgraph_node (next, &first, reachable);\n+\t\t  enqueue_node ((symtab_node) e->callee, &first, reachable);\n \t\t}\n+\n+\t      /* When inline clone exists, mark body to be preserved so when removing\n+\t\t offline copy of the function we don't kill it.  */\n+\t      if (!cnode->alias && cnode->global.inlined_to)\n+\t        pointer_set_insert (body_needed_for_clonning, cnode->symbol.decl);\n \t    }\n \n-\t  /* We can freely remove inline clones even if they are cloned, however if\n-\t     function is clone of real clone, we must keep it around in order to\n-\t     make materialize_clones produce function body with the changes\n-\t     applied.  */\n-\t  while (node->clone_of && !node->clone_of->symbol.aux\n-\t         && !gimple_has_body_p (node->symbol.decl))\n+\t  /* For non-inline clones, force their origins to the boundary and ensure\n+\t     that body is not removed.  */\n+\t  while (cnode->clone_of && !cnode->clone_of->symbol.aux\n+\t         && !gimple_has_body_p (cnode->symbol.decl))\n \t    {\n-\t      bool noninline = node->clone_of->symbol.decl != node->symbol.decl;\n-\t      node = node->clone_of;\n-\t      if (noninline && !pointer_set_contains (reachable, node) && !node->symbol.aux)\n+\t      bool noninline = cnode->clone_of->symbol.decl != cnode->symbol.decl;\n+\t      cnode = cnode->clone_of;\n+\t      if (noninline && !cnode->symbol.aux)\n \t      \t{\n-\t\t  enqueue_cgraph_node (node, &first, reachable);\n+\t          pointer_set_insert (body_needed_for_clonning, cnode->symbol.decl);\n+\t\t  enqueue_node ((symtab_node)cnode, &first, reachable);\n \t\t  break;\n \t\t}\n \t    }\n \t}\n-      if (first_varpool != (struct varpool_node *) (void *) 1)\n-\t{\n-\t  vnode = first_varpool;\n-\t  first_varpool = (struct varpool_node *)first_varpool->symbol.aux;\n-\t  vnode->symbol.aux = NULL;\n-\t  process_references (&vnode->symbol.ref_list, &first,\n-\t\t\t      &first_varpool, before_inlining_p,\n-\t\t\t      reachable);\n-\t  /* If any function in a comdat group is reachable, force\n-\t     all other functions in the same comdat group to be\n-\t     also reachable.  */\n-\t  if (vnode->symbol.same_comdat_group)\n-\t    {\n-\t      struct varpool_node *next;\n-\t      for (next = varpool (vnode->symbol.same_comdat_group);\n-\t\t   next != vnode;\n-\t\t   next = varpool (next->symbol.same_comdat_group))\n-\t\tif (!pointer_set_insert (reachable, next))\n-\t\t  enqueue_varpool_node (next, &first_varpool);\n-\t    }\n-\t}\n     }\n \n-  /* Remove unreachable nodes. \n-\n-     Completely unreachable functions can be fully removed from the callgraph.\n-     Extern inline functions that we decided to not inline need to become unanalyzed nodes of\n-     callgraph (so we still have edges to them).  We remove function body then.\n-\n-     Also we need to care functions that are unreachable but we need to keep them around\n-     for later clonning.  In this case we also turn them to unanalyzed nodes, but\n-     keep the body around.  */\n+  /* Remove unreachable functions.   */\n   for (node = cgraph_first_function (); node; node = next)\n     {\n       next = cgraph_next_function (node);\n-      if (node->symbol.aux && !pointer_set_contains (reachable, node))\n-        {\n-\t  cgraph_node_remove_callees (node);\n-\t  ipa_remove_all_references (&node->symbol.ref_list);\n-\t  node->analyzed = false;\n-\t}\n       if (!node->symbol.aux)\n \t{\n-\t  struct cgraph_edge *e;\n-\t  bool found = false;\n-\t  int i;\n-\t  struct ipa_ref *ref;\n-\n-          node->global.inlined_to = NULL;\n \t  if (file)\n \t    fprintf (file, \" %s\", cgraph_node_name (node));\n-\t  /* See if there is reachable caller.  */\n-\t  for (e = node->callers; e && !found; e = e->next_caller)\n-\t    if (pointer_set_contains (reachable, e->caller))\n-\t      found = true;\n-\t  for (i = 0; (ipa_ref_list_referring_iterate (&node->symbol.ref_list,\n-\t\t\t\t\t\t      i, ref)\n-\t\t       && !found); i++)\n-\t    if (pointer_set_contains (reachable, ref->referring))\n-\t      found = true;\n-\n-\t  /* If so, we need to keep node in the callgraph.  */\n-\t  if (found)\n-\t    {\n-\t      if (node->analyzed)\n-\t\t{\n-\t\t  struct cgraph_node *clone;\n-\n-\t\t  /* If there are still clones, we must keep body around.\n-\t\t     Otherwise we can just remove the body but keep the clone.  */\n-\t\t  for (clone = node->clones; clone;\n-\t\t       clone = clone->next_sibling_clone)\n-\t\t    if (clone->symbol.aux)\n-\t\t      break;\n-\t\t  if (!clone)\n-\t\t    {\n-\t\t      cgraph_release_function_body (node);\n-\t\t      if (node->prev_sibling_clone)\n-\t\t\tnode->prev_sibling_clone->next_sibling_clone = node->next_sibling_clone;\n-\t\t      else if (node->clone_of)\n-\t\t\tnode->clone_of->clones = node->next_sibling_clone;\n-\t\t      if (node->next_sibling_clone)\n-\t\t\tnode->next_sibling_clone->prev_sibling_clone = node->prev_sibling_clone;\n-\t\t      if (node->clone_of)\n-\t\t\tnode->former_clone_of = node->clone_of->symbol.decl;\n-\t\t      node->clone_of = NULL;\n-\t\t      node->next_sibling_clone = NULL;\n-\t\t      node->prev_sibling_clone = NULL;\n-\t\t    }\n-\t\t  else\n-\t\t    gcc_assert (!clone->symbol.in_other_partition);\n-\t\t  node->analyzed = false;\n-\t\t  changed = true;\n-\t\t  cgraph_node_remove_callees (node);\n-\t\t  ipa_remove_all_references (&node->symbol.ref_list);\n-\t\t}\n-\t    }\n-\t  else\n+\t  cgraph_remove_node (node);\n+\t  changed = true;\n+\t}\n+      else if (!pointer_set_contains (reachable, node))\n+        {\n+\t  if (node->analyzed)\n \t    {\n-\t      cgraph_remove_node (node);\n+\t      if (file)\n+\t\tfprintf (file, \" %s\", cgraph_node_name (node));\n+\t      cgraph_node_remove_callees (node);\n+\t      ipa_remove_all_references (&node->symbol.ref_list);\n \t      changed = true;\n \t    }\n+\t  if (!pointer_set_contains (body_needed_for_clonning, node->symbol.decl)\n+\t      && !DECL_ARTIFICIAL (node->symbol.decl))\n+\t    cgraph_release_function_body (node);\n+\t  node->analyzed = false;\n \t}\n     }\n+\n+  /* Inline clones might be kept around so their materializing allows further\n+     cloning.  If the function the clone is inlined into is removed, we need\n+     to turn it into normal cone.  */\n   FOR_EACH_FUNCTION (node)\n     {\n-      /* Inline clones might be kept around so their materializing allows further\n-         cloning.  If the function the clone is inlined into is removed, we need\n-         to turn it into normal cone.  */\n       if (node->global.inlined_to\n \t  && !node->callers)\n \t{\n@@ -402,25 +368,38 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n       node->symbol.aux = NULL;\n     }\n \n+  /* Remove unreachable variables.  */\n   if (file)\n-    fprintf (file, \"\\n\");\n-\n-  if (file)\n-    fprintf (file, \"Reclaiming variables:\");\n+    fprintf (file, \"\\nReclaiming variables:\");\n   for (vnode = varpool_first_variable (); vnode; vnode = vnext)\n     {\n       vnext = varpool_next_variable (vnode);\n-      if (!pointer_set_contains (reachable, vnode))\n-        {\n+      if (!vnode->symbol.aux)\n+\t{\n \t  if (file)\n \t    fprintf (file, \" %s\", varpool_node_name (vnode));\n \t  varpool_remove_node (vnode);\n \t  changed = true;\n \t}\n+      else if (!pointer_set_contains (reachable, vnode))\n+        {\n+\t  if (vnode->analyzed)\n+\t    {\n+\t      if (file)\n+\t\tfprintf (file, \" %s\", varpool_node_name (vnode));\n+\t      changed = true;\n+\t    }\n+\t  vnode->analyzed = false;\n+\t  vnode->symbol.aux = NULL;\n+\t}\n+      else\n+\tvnode->symbol.aux = NULL;\n     }\n \n-  /* Now update address_taken flags and try to promote functions to be local.  */\n+  pointer_set_destroy (reachable);\n+  pointer_set_destroy (body_needed_for_clonning);\n \n+  /* Now update address_taken flags and try to promote functions to be local.  */\n   if (file)\n     fprintf (file, \"\\nClearing address taken flags:\");\n   FOR_EACH_DEFINED_FUNCTION (node)\n@@ -444,18 +423,18 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n   if (file)\n     fprintf (file, \"\\n\");\n \n-  /* Rest of transformations are undesirable at -O0.  */\n-  if (!optimize)\n-    return changed;\n-\n #ifdef ENABLE_CHECKING\n   verify_symtab ();\n #endif\n \n+  /* If we removed something, perhaps profile could be improved.  */\n+  if (changed && optimize && inline_edge_summary_vec)\n+    FOR_EACH_DEFINED_FUNCTION (node)\n+      cgraph_propagate_frequency (node);\n+\n   /* Reclaim alias pairs for functions that have disappeared from the\n      call graph.  */\n   remove_unreachable_alias_pairs ();\n-  pointer_set_destroy (reachable);\n \n   return changed;\n }"}, {"sha": "c2addb19bd77ca17730471623f769dad7161e737", "filename": "gcc/passes.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04142cc3bdcc6277e8ba16d15851c7270cc351dc/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04142cc3bdcc6277e8ba16d15851c7270cc351dc/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=04142cc3bdcc6277e8ba16d15851c7270cc351dc", "patch": "@@ -1865,7 +1865,7 @@ execute_todo (unsigned int flags)\n   if (flags & TODO_remove_functions)\n     {\n       gcc_assert (!cfun);\n-      cgraph_remove_unreachable_nodes (true, dump_file);\n+      symtab_remove_unreachable_nodes (true, dump_file);\n     }\n \n   if ((flags & TODO_dump_symtab) && dump_file && !current_function_decl)\n@@ -2150,7 +2150,7 @@ execute_one_pass (struct opt_pass *pass)\n       bool applied = false;\n       do_per_function (apply_ipa_transforms, (void *)&applied);\n       if (applied)\n-        cgraph_remove_unreachable_nodes (true, dump_file);\n+        symtab_remove_unreachable_nodes (true, dump_file);\n       /* Restore current_pass.  */\n       current_pass = pass;\n     }"}]}