{"sha": "21b2340908ecd93806e3928ad3ceff208b2e0573", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjFiMjM0MDkwOGVjZDkzODA2ZTM5MjhhZDNjZWZmMjA4YjJlMDU3Mw==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2005-03-07T17:18:33Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2005-03-07T17:18:33Z"}, "message": "re PR java/20215 (gcj does not accept classes with same name fields)\n\n\tPR java/20215:\n\t* include/jvm.h (_Jv_Linker::find_field_helper): Updated.\n\t* link.cc (find_field_helper): Added 'type' argument.\n\t(find_field): Updated.\n\nFrom-SVN: r96032", "tree": {"sha": "eec67b450c55ea60ba41acf7eb8d9097b43f48a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eec67b450c55ea60ba41acf7eb8d9097b43f48a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/21b2340908ecd93806e3928ad3ceff208b2e0573", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21b2340908ecd93806e3928ad3ceff208b2e0573", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21b2340908ecd93806e3928ad3ceff208b2e0573", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21b2340908ecd93806e3928ad3ceff208b2e0573/comments", "author": null, "committer": null, "parents": [{"sha": "7a59efae86cfa74ed45a0a78139082e8443873b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a59efae86cfa74ed45a0a78139082e8443873b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a59efae86cfa74ed45a0a78139082e8443873b1"}], "stats": {"total": 61, "additions": 37, "deletions": 24}, "files": [{"sha": "696167fade8647b6a4eb15b7d1d3a6ccaf84a46e", "filename": "libjava/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21b2340908ecd93806e3928ad3ceff208b2e0573/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21b2340908ecd93806e3928ad3ceff208b2e0573/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=21b2340908ecd93806e3928ad3ceff208b2e0573", "patch": "@@ -1,3 +1,10 @@\n+2005-03-07  Tom Tromey  <tromey@redhat.com>\n+\n+\tPR java/20215:\n+\t* include/jvm.h (_Jv_Linker::find_field_helper): Updated.\n+\t* link.cc (find_field_helper): Added 'type' argument.\n+\t(find_field): Updated.\n+\n 2005-04-07  Scott Gilbertson  <scottg@mantatest.com>\n \t* gnu/gcj/xlib/natXAnyEvent.cc (loadNext): Added timeout.\n \t* gnu/awt/xlib/XCanvasPeer.java (setBackground): Removed"}, {"sha": "7668703f54c2b2d22afe8a7eee1a0a42e5030e2f", "filename": "libjava/include/jvm.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21b2340908ecd93806e3928ad3ceff208b2e0573/libjava%2Finclude%2Fjvm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21b2340908ecd93806e3928ad3ceff208b2e0573/libjava%2Finclude%2Fjvm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjvm.h?ref=21b2340908ecd93806e3928ad3ceff208b2e0573", "patch": "@@ -250,7 +250,8 @@ namespace gcj\n class _Jv_Linker\n {\n private:\n-  static _Jv_Field *find_field_helper(jclass, _Jv_Utf8Const *, jclass *);\n+  static _Jv_Field *find_field_helper(jclass, _Jv_Utf8Const *, _Jv_Utf8Const *,\n+\t\t\t\t      jclass *);\n   static _Jv_Field *find_field(jclass, jclass, _Jv_Utf8Const *,\n \t\t\t       _Jv_Utf8Const *);\n   static void prepare_constant_time_tables(jclass);"}, {"sha": "b916bf3653907a33898ee9582de4d8c2c2443951", "filename": "libjava/link.cc", "status": "modified", "additions": 28, "deletions": 23, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21b2340908ecd93806e3928ad3ceff208b2e0573/libjava%2Flink.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21b2340908ecd93806e3928ad3ceff208b2e0573/libjava%2Flink.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Flink.cc?ref=21b2340908ecd93806e3928ad3ceff208b2e0573", "patch": "@@ -100,6 +100,7 @@ _Jv_Linker::resolve_field (_Jv_Field *field, java::lang::ClassLoader *loader)\n // superclasses and interfaces.\n _Jv_Field *\n _Jv_Linker::find_field_helper (jclass search, _Jv_Utf8Const *name,\n+\t\t\t       _Jv_Utf8Const *type_name,\n \t\t\t       jclass *declarer)\n {\n   while (search)\n@@ -108,7 +109,21 @@ _Jv_Linker::find_field_helper (jclass search, _Jv_Utf8Const *name,\n       for (int i = 0; i < search->field_count; ++i)\n \t{\n \t  _Jv_Field *field = &search->fields[i];\n-\t  if (_Jv_equalUtf8Consts (field->name, name))\n+\t  if (! _Jv_equalUtf8Consts (field->name, name))\n+\t    continue;\n+\n+\t  if (! field->isResolved ())\n+\t    resolve_field (field, search->loader);\n+\n+\t  // Note that we compare type names and not types.  This is\n+\t  // bizarre, but we do it because we want to find a field\n+\t  // (and terminate the search) if it has the correct\n+\t  // descriptor -- but then later reject it if the class\n+\t  // loader check results in different classes.  We can't just\n+\t  // pass in the descriptor and check that way, because when\n+\t  // the field is already resolved there is no easy way to\n+\t  // find its descriptor again.\n+\t  if (_Jv_equalUtf8Consts (type_name, field->type->name))\n \t    {\n \t      *declarer = search;\n \t      return field;\n@@ -119,7 +134,7 @@ _Jv_Linker::find_field_helper (jclass search, _Jv_Utf8Const *name,\n       for (int i = 0; i < search->interface_count; ++i)\n \t{\n \t  _Jv_Field *result = find_field_helper (search->interfaces[i], name,\n-\t\t\t\t\t\t declarer);\n+\t\t\t\t\t\t type_name, declarer);\n \t  if (result)\n \t    return result;\n \t}\n@@ -155,23 +170,14 @@ _Jv_Linker::find_field (jclass klass, jclass owner,\n \t\t\t_Jv_Utf8Const *field_name,\n \t\t\t_Jv_Utf8Const *field_type_name)\n {\n-  jclass field_type = 0;\n-\n-  if (owner->loader != klass->loader)\n-    {\n-      // FIXME: The implementation of this function\n-      // (_Jv_FindClassFromSignature) will generate an instance of\n-      // _Jv_Utf8Const for each call if the field type is a class name\n-      // (Lxx.yy.Z;).  This may be too expensive to do for each and\n-      // every fieldref being resolved.  For now, we fix the problem\n-      // by only doing it when we have a loader different from the\n-      // class declaring the field.\n-      field_type = _Jv_FindClassFromSignature (field_type_name->chars(),\n-\t\t\t\t\t       klass->loader);\n-    }\n+  // FIXME: this allocates a _Jv_Utf8Const each time.  We should make\n+  // it cheaper.\n+  jclass field_type = _Jv_FindClassFromSignature (field_type_name->chars(),\n+\t\t\t\t\t\t  klass->loader);\n \n   jclass found_class = 0;\n-  _Jv_Field *the_field = find_field_helper (owner, field_name, &found_class);\n+  _Jv_Field *the_field = find_field_helper (owner, field_name,\n+\t\t\t\t\t    field_type->name, &found_class);\n \n   if (the_field == 0)\n     {\n@@ -186,12 +192,11 @@ _Jv_Linker::find_field (jclass klass, jclass owner,\n \n   if (_Jv_CheckAccess (klass, found_class, the_field->flags))\n     {\n-      // Resolve the field using the class' own loader if necessary.\n-\n-      if (!the_field->isResolved ())\n-\tresolve_field (the_field, found_class->loader);\n-\n-      if (field_type != 0 && the_field->type != field_type)\n+      // Note that the field returned by find_field_helper is always\n+      // resolved.  There's no point checking class loaders here,\n+      // since we already did the work to look up all the types.\n+      // FIXME: being lazy here would be nice.\n+      if (the_field->type != field_type)\n \tthrow new java::lang::LinkageError\n \t  (JvNewStringLatin1 \n \t   (\"field type mismatch with different loaders\"));"}]}