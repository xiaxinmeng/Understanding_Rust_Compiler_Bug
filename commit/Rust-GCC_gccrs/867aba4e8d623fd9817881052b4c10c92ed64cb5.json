{"sha": "867aba4e8d623fd9817881052b4c10c92ed64cb5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODY3YWJhNGU4ZDYyM2ZkOTgxNzg4MTA1MmI0YzEwYzkyZWQ2NGNiNQ==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2007-12-13T10:26:00Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-12-13T10:26:00Z"}, "message": "exp_ch9.adb (Expand_N_Asynchronous_Select, [...]): Code and comment reformatting.\n\n2007-12-06  Hristian Kirtchev  <kirtchev@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch9.adb (Expand_N_Asynchronous_Select,\n\tExpand_N_Conditional_Entry_Call, Expand_N_Timed_Entry_Call): Code and\n\tcomment reformatting.\n\t(Set_Privals): Inherit aliased flag from formal. From code reading.\n\t(Build_Simple_Entry_Call): Out parameters of an access type are passed\n\tby copy and initialized from the actual. This includes entry parameters.\n\t(Expand_N_Requeue_Statement): Reimplement in order to handle both Ada 95\n\tand Ada 2005 models of requeue.\n\t(Null_Statements): Still connsider do-end block null if it contains\n\tUnreferenced and Warnings pragmas.\n\t(Expand_N_Accept_Statement): Do not optimize away null do end if\n\tdispatching policy is other than defaulted.\n\t(Expand_N_Timed_Entry_Call): When the triggering statement is a\n\tdispatching call, manually analyze the delay statement.\n\t(Find_Parameter_Type): Move subprogram to Sem_Util.\n\nFrom-SVN: r130834", "tree": {"sha": "62d4d8b88808e574399fe1649100a812ea3a3723", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62d4d8b88808e574399fe1649100a812ea3a3723"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/867aba4e8d623fd9817881052b4c10c92ed64cb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/867aba4e8d623fd9817881052b4c10c92ed64cb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/867aba4e8d623fd9817881052b4c10c92ed64cb5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/867aba4e8d623fd9817881052b4c10c92ed64cb5/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fae4d8398825d0d0f7cb641dcd286885058d3a88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fae4d8398825d0d0f7cb641dcd286885058d3a88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fae4d8398825d0d0f7cb641dcd286885058d3a88"}], "stats": {"total": 770, "additions": 446, "deletions": 324}, "files": [{"sha": "de70beed8069c7b0c18d631bada03fc1c79eda50", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 446, "deletions": 324, "changes": 770, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/867aba4e8d623fd9817881052b4c10c92ed64cb5/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/867aba4e8d623fd9817881052b4c10c92ed64cb5/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=867aba4e8d623fd9817881052b4c10c92ed64cb5", "patch": "@@ -730,9 +730,10 @@ package body Exp_Ch9 is\n       Name  : Name_Id;\n       Loc   : Source_Ptr)\n    is\n+      Body_Ent : constant Entity_Id := Corresponding_Body   (Parent (Typ));\n       Def      : constant Node_Id   := Protected_Definition (Parent (Typ));\n+\n       Decl     : Node_Id;\n-      Body_Ent : constant Entity_Id := Corresponding_Body   (Parent (Typ));\n       P        : Node_Id;\n       Pdef     : Entity_Id;\n \n@@ -923,12 +924,12 @@ package body Exp_Ch9 is\n \n       P := Parent (N);\n \n-      while Nkind (P) /= N_Subprogram_Body\n-        and then Nkind (P) /= N_Package_Declaration\n-        and then Nkind (P) /= N_Package_Body\n-        and then Nkind (P) /= N_Block_Statement\n-        and then Nkind (P) /= N_Task_Body\n-        and then Nkind (P) /= N_Extended_Return_Statement\n+      while not Nkind_In (P, N_Subprogram_Body,\n+                             N_Package_Declaration,\n+                             N_Package_Body,\n+                             N_Block_Statement,\n+                             N_Task_Body,\n+                             N_Extended_Return_Statement)\n       loop\n          P := Parent (P);\n       end loop;\n@@ -1521,28 +1522,6 @@ package body Exp_Ch9 is\n             Proc_Param    : Node_Id;\n             Proc_Typ      : Entity_Id;\n \n-            function Find_Parameter_Type (Param : Node_Id) return Entity_Id;\n-            --  Return the controlling type denoted by a formal parameter\n-\n-            -------------------------\n-            -- Find_Parameter_Type --\n-            -------------------------\n-\n-            function Find_Parameter_Type (Param : Node_Id) return Entity_Id is\n-            begin\n-               if Nkind (Param) /= N_Parameter_Specification then\n-                  return Empty;\n-\n-               elsif Nkind (Parameter_Type (Param)) = N_Access_Definition then\n-                  return Etype (Subtype_Mark (Parameter_Type (Param)));\n-\n-               else\n-                  return Etype (Parameter_Type (Param));\n-               end if;\n-            end Find_Parameter_Type;\n-\n-         --  Start of processing for Type_Conformant_Parameters\n-\n          begin\n             --  Skip the first parameter of the primitive operation\n \n@@ -1598,9 +1577,9 @@ package body Exp_Ch9 is\n               Present (Parameter_Specifications (Prim_Op_Spec))\n                 and then\n               Nkind (Parameter_Type\n-                     (First\n-                      (Parameter_Specifications (Prim_Op_Spec))))\n-                        = N_Access_Definition;\n+                      (First\n+                        (Parameter_Specifications (Prim_Op_Spec)))) =\n+                                                          N_Access_Definition;\n \n             if not Is_Out_Present\n               and then not Is_Access_To_Variable\n@@ -2083,9 +2062,8 @@ package body Exp_Ch9 is\n          --  If we fall off the top, we are at the outer level, and the\n          --  environment task is our effective master, so nothing to mark.\n \n-         if Nkind (P) = N_Task_Body\n-           or else Nkind (P) = N_Block_Statement\n-           or else Nkind (P) = N_Subprogram_Body\n+         if Nkind_In\n+              (P, N_Task_Body, N_Block_Statement, N_Subprogram_Body)\n          then\n             Set_Is_Task_Master (P, True);\n             return;\n@@ -2472,12 +2450,12 @@ package body Exp_Ch9 is\n \n             function Is_Call_Or_Raise (N : Node_Id) return Boolean is\n             begin\n-               return Nkind (N) = N_Procedure_Call_Statement\n-                 or else Nkind (N) = N_Function_Call\n-                 or else Nkind (N) = N_Raise_Statement\n-                 or else Nkind (N) = N_Raise_Constraint_Error\n-                 or else Nkind (N) = N_Raise_Program_Error\n-                 or else Nkind (N) = N_Raise_Storage_Error;\n+               return Nkind_In (N, N_Procedure_Call_Statement,\n+                                   N_Function_Call,\n+                                   N_Raise_Statement,\n+                                   N_Raise_Constraint_Error,\n+                                   N_Raise_Program_Error,\n+                                   N_Raise_Storage_Error);\n             end Is_Call_Or_Raise;\n \n          --  Start of processing for Has_Side_Effect\n@@ -3021,11 +2999,11 @@ package body Exp_Ch9 is\n \n                   Set_No_Initialization (N_Node);\n \n-                  --  We have to make an assignment statement separate for the\n+                  --  We must make an assignment statement separate for the\n                   --  case of limited type. We cannot assign it unless the\n-                  --  Assignment_OK flag is set first.\n-                  --  An out formal of an access type must also be initialized\n-                  --  from the actual, as stated in RM 6.4.1 (13).\n+                  --  Assignment_OK flag is set first. An out formal of an\n+                  --  access type must also be initialized from the actual,\n+                  --  as stated in RM 6.4.1 (13).\n \n                   if Ekind (Formal) /= E_Out_Parameter\n                     or else Is_Access_Type (Etype (Formal))\n@@ -3098,8 +3076,8 @@ package body Exp_Ch9 is\n \n             Parm3 :=\n               Make_Attribute_Reference (Loc,\n-                Attribute_Name => Name_Address,\n-                Prefix => New_Reference_To (P, Loc));\n+                Prefix => New_Reference_To (P, Loc),\n+                Attribute_Name => Name_Address);\n \n             Append (Pdecl, Decls);\n          end if;\n@@ -3832,12 +3810,14 @@ package body Exp_Ch9 is\n          end if;\n \n       else\n-         pragma Assert (Is_Concurrent_Type (Ntyp));\n-\n          if Is_Protected_Type (Ntyp) then\n             Sel := Name_uObject;\n-         else\n+\n+         elsif Is_Task_Type (Ntyp) then\n             Sel := Name_uTask_Id;\n+\n+         else\n+            raise Program_Error;\n          end if;\n \n          return\n@@ -4630,8 +4610,9 @@ package body Exp_Ch9 is\n       Block   : Node_Id;\n \n       function Null_Statements (Stats : List_Id) return Boolean;\n-      --  Check for null statement sequence (i.e a list of labels and\n-      --  null statements).\n+      --  Used to check do-end sequence. Checks for equivalent of do null; end.\n+      --  Allows labels, and pragma Warnings/Unreferenced in the sequence as\n+      --  well to still count as null. Returns True for a null sequence.\n \n       ---------------------\n       -- Null_Statements --\n@@ -4643,9 +4624,12 @@ package body Exp_Ch9 is\n       begin\n          Stmt := First (Stats);\n          while Nkind (Stmt) /= N_Empty\n-           and then (Nkind (Stmt) = N_Null_Statement\n+           and then (Nkind_In (Stmt, N_Null_Statement, N_Label)\n                        or else\n-                     Nkind (Stmt) = N_Label)\n+                         (Nkind (Stmt) = N_Pragma\n+                            and then (Chars (Stmt) = Name_Unreferenced\n+                                        or else\n+                                      Chars (Stmt) = Name_Warnings)))\n          loop\n             Next (Stmt);\n          end loop;\n@@ -4668,17 +4652,18 @@ package body Exp_Ch9 is\n       --  If the accept statement has declarations, then just insert them\n       --  before the procedure call.\n \n-      --  We avoid this optimization when FIFO_Within_Priorities is active,\n-      --  since it is not correct according to annex D semantics. The problem\n-      --  is that the call is required to reorder the acceptors position on\n-      --  its ready queue, even though there is nothing to be done. However,\n-      --  if no policy is specified, then we decide that our dispatching\n-      --  policy always reorders the queue right after the RV to look the\n-      --  way they were just before the RV. Since we are allowed to freely\n-      --  reorder same-priority queues (this is part of what dispatching\n+      --  We avoid this optimization when FIFO_Within_Priorities or some other\n+      --  specified dispatching policy is active, since this may not be not\n+      --  correct according to annex D semantics. For example, in the case of\n+      --  FIFO_Within_Priorities, the call is required to reorder the acceptors\n+      --  position on its ready queue, even though there is nothing to be done.\n+      --  However, if no policy is specified, then we decide that the default\n+      --  dispatching policy always reorders the queue right after the RV to\n+      --  look the way they were just before the RV. Since we are allowed to\n+      --  freely reorder same-priority queues (this is part of what dispatching\n       --  policies are all about), the optimization is legitimate.\n \n-      elsif Opt.Task_Dispatching_Policy /= 'F'\n+      elsif Opt.Task_Dispatching_Policy = ' '\n         and then (No (Stats) or else Null_Statements (Statements (Stats)))\n       then\n          --  Remove declarations for renamings, because the parameter block\n@@ -4842,18 +4827,18 @@ package body Exp_Ch9 is\n    --    begin\n    --       Abort_Defer;\n    --       Task_Entry_Call\n-   --         (acceptor-task,\n-   --          entry-index,\n-   --          P'Address,\n-   --          Asynchronous_Call,\n-   --          B);\n+   --         (<acceptor-task>,    --  Acceptor\n+   --          <entry-index>,      --  E\n+   --          P'Address,          --  Uninterpreted_Data\n+   --          Asynchronous_Call,  --  Mode\n+   --          B);                 --  Rendezvous_Successful\n \n    --       begin\n    --          begin\n    --             Abort_Undefer;\n    --             <abortable-part>\n    --          at end\n-   --             _clean;        --  Added by Exp_Ch7.Expand_Cleanup_Actions.\n+   --             _clean;  --  Added by Exp_Ch7.Expand_Cleanup_Actions\n    --          end;\n    --       exception\n    --          when Abort_Signal => Abort_Undefer;\n@@ -4867,9 +4852,9 @@ package body Exp_Ch9 is\n    --       end if;\n    --    end;\n \n-   --  Note that Build_Simple_Entry_Call is used to expand the entry\n-   --  of the asynchronous entry call (by the\n-   --  Expand_N_Entry_Call_Statement procedure) as follows:\n+   --  Note that Build_Simple_Entry_Call is used to expand the entry of the\n+   --  asynchronous entry call (by Expand_N_Entry_Call_Statement procedure)\n+   --  as follows:\n \n    --    declare\n    --       P : parms := (parm, parm, parm);\n@@ -4882,16 +4867,18 @@ package body Exp_Ch9 is\n \n    --  so the task at hand is to convert the latter expansion into the former\n \n-   --  If the trigger is a protected entry call, the select is\n-   --  implemented with Protected_Entry_Call:\n+   --  If the trigger is a protected entry call, the select is implemented\n+   --  with Protected_Entry_Call:\n \n    --  declare\n    --     P   : E1_Params := (param, param, param);\n    --     Bnn : Communications_Block;\n \n    --  begin\n    --     declare\n+\n    --        --  Clean is added by Exp_Ch7.Expand_Cleanup_Actions.\n+\n    --        procedure _clean is\n    --        begin\n    --           ...\n@@ -4903,17 +4890,18 @@ package body Exp_Ch9 is\n \n    --     begin\n    --        begin\n-   --           Protected_Entry_Call (\n-   --             Object => po._object'Access,\n-   --             E => <entry index>;\n-   --             Uninterpreted_Data => P'Address;\n-   --             Mode => Asynchronous_Call;\n-   --             Block => Bnn);\n+   --           Protected_Entry_Call\n+   --             (po._object'Access,  --  Object\n+   --              <entry index>,      --  E\n+   --              P'Address,          --  Uninterpreted_Data\n+   --              Asynchronous_Call,  --  Mode\n+   --              Bnn);               --  Block\n+\n    --           if Enqueued (Bnn) then\n    --              <abortable-part>\n    --           end if;\n    --        at end\n-   --           _clean;        --  Added by Exp_Ch7.Expand_Cleanup_Actions.\n+   --           _clean;  --  Added by Exp_Ch7.Expand_Cleanup_Actions\n    --        end;\n    --     exception\n    --        when Abort_Signal => Abort_Undefer;\n@@ -4924,20 +4912,20 @@ package body Exp_Ch9 is\n    --     end if;\n    --  end;\n \n-   --  Build_Simple_Entry_Call is used to expand the all to a simple\n-   --  protected entry call:\n+   --  Build_Simple_Entry_Call is used to expand the all to a simple protected\n+   --  entry call:\n \n    --  declare\n    --     P   : E1_Params := (param, param, param);\n    --     Bnn : Communications_Block;\n \n    --  begin\n-   --     Protected_Entry_Call (\n-   --       Object => po._object'Access,\n-   --       E => <entry index>;\n-   --       Uninterpreted_Data => P'Address;\n-   --       Mode => Simple_Call;\n-   --       Block => Bnn);\n+   --     Protected_Entry_Call\n+   --       (po._object'Access,  --  Object\n+   --        <entry index>,      --  E\n+   --        P'Address,          --  Uninterpreted_Data\n+   --        Simple_Call,        --  Mode\n+   --        Bnn);               --  Block\n    --     parm := P.param;\n    --     parm := P.param;\n    --       ...\n@@ -4950,7 +4938,7 @@ package body Exp_Ch9 is\n    --       B   : Boolean := False;\n    --       Bnn : Communication_Block;\n    --       C   : Ada.Tags.Prim_Op_Kind;\n-   --       D   : Dummy_Communication_Block;\n+   --       D   : System.Storage_Elements.Dummy_Communication_Block;\n    --       K   : Ada.Tags.Tagged_Kind :=\n    --               Ada.Tags.Get_Tagged_Kind (Ada.Tags.Tag (<object>));\n    --       P   : Parameters := (Param1 .. ParamN);\n@@ -4963,8 +4951,9 @@ package body Exp_Ch9 is\n    --          <triggering-statements>;\n \n    --       else\n-   --          S := Ada.Tags.Get_Offset_Index (Ada.Tags.Tag (<object>),\n-   --                 DT_Position (<dispatching-call>));\n+   --          S :=\n+   --            Ada.Tags.Get_Offset_Index\n+   --              (Ada.Tags.Tag (<object>), DT_Position (<dispatching-call>));\n \n    --          _Disp_Get_Prim_Op_Kind (<object>, S, C);\n \n@@ -4980,7 +4969,7 @@ package body Exp_Ch9 is\n    --             begin\n    --                begin\n    --                   _Disp_Asynchronous_Select\n-   --                     (<object>, S, P'address, D, B);\n+   --                     (<object>, S, P'Address, D, B);\n    --                   Bnn := Communication_Block (D);\n \n    --                   Param1 := P.Param1;\n@@ -4991,7 +4980,7 @@ package body Exp_Ch9 is\n    --                      <abortable-statements>\n    --                   end if;\n    --                at end\n-   --                   _clean;\n+   --                   _clean;  --  Added by Exp_Ch7.Expand_Cleanup_Actions\n    --                end;\n    --             exception\n    --                when Abort_Signal => Abort_Undefer;\n@@ -5012,7 +5001,7 @@ package body Exp_Ch9 is\n    --                Abort_Defer;\n \n    --                _Disp_Asynchronous_Select\n-   --                  (<object>, S, P'address, D, B);\n+   --                  (<object>, S, P'Address, D, B);\n    --                Bnn := Communication_Bloc (D);\n \n    --                Param1 := P.Param1;\n@@ -5024,7 +5013,7 @@ package body Exp_Ch9 is\n    --                      Abort_Undefer;\n    --                      <abortable-statements>\n    --                   at end\n-   --                      _clean;\n+   --                      _clean;  --  Added by Exp_Ch7.Expand_Cleanup_Actions\n    --                   end;\n    --                exception\n    --                   when Abort_Signal => Abort_Undefer;\n@@ -5053,8 +5042,8 @@ package body Exp_Ch9 is\n    --  the entry call. This object is used by the runtime to queue the delay\n    --  request.\n \n-   --  For a description of the use of P and the assignments after the\n-   --  call, see Expand_N_Entry_Call_Statement.\n+   --  For a description of the use of P and the assignments after the call,\n+   --  see Expand_N_Entry_Call_Statement.\n \n    procedure Expand_N_Asynchronous_Select (N : Node_Id) is\n       Loc    : constant Source_Ptr := Sloc (N);\n@@ -5118,8 +5107,8 @@ package body Exp_Ch9 is\n \n       if Nkind (Ecall) = N_Block_Statement then\n          Ecall := First (Statements (Handled_Statement_Sequence (Ecall)));\n-         while Nkind (Ecall) /= N_Procedure_Call_Statement\n-           and then Nkind (Ecall) /= N_Entry_Call_Statement\n+         while not Nkind_In (Ecall, N_Procedure_Call_Statement,\n+                                    N_Entry_Call_Statement)\n          loop\n             Next (Ecall);\n          end loop;\n@@ -5132,10 +5121,9 @@ package body Exp_Ch9 is\n          if Ada_Version >= Ada_05\n            and then\n              (No (Original_Node (Ecall))\n-                or else\n-                  (Nkind (Original_Node (Ecall)) /= N_Delay_Relative_Statement\n-                     and then\n-                   Nkind (Original_Node (Ecall)) /= N_Delay_Until_Statement))\n+                or else not Nkind_In (Original_Node (Ecall),\n+                                        N_Delay_Relative_Statement,\n+                                        N_Delay_Until_Statement))\n          then\n             Extract_Dispatching_Call (Ecall, Call_Ent, Obj, Actuals, Formals);\n \n@@ -5204,8 +5192,9 @@ package body Exp_Ch9 is\n                 Object_Definition =>\n                   New_Reference_To (Standard_Boolean, Loc)));\n \n-            --  ---------------------------------------------------------------\n-            --  Protected entry handling\n+            ------------------------------\n+            -- Protected entry handling --\n+            ------------------------------\n \n             --  Generate:\n             --    Param1 := P.Param1;\n@@ -5229,7 +5218,7 @@ package body Exp_Ch9 is\n                       Make_Identifier (Loc, Name_uD))));\n \n             --  Generate:\n-            --    _Disp_Asynchronous_Select (<object>, S, P'address, D, B);\n+            --    _Disp_Asynchronous_Select (<object>, S, P'Address, D, B);\n \n             Prepend_To (Cleanup_Stmts,\n               Make_Procedure_Call_Statement (Loc,\n@@ -5240,13 +5229,15 @@ package body Exp_Ch9 is\n                     Loc),\n                 Parameter_Associations =>\n                   New_List (\n-                    New_Copy_Tree    (Obj),\n-                    New_Reference_To (S, Loc),\n-                    Make_Attribute_Reference (Loc,\n-                      Prefix => New_Reference_To (P, Loc),\n-                      Attribute_Name => Name_Address),\n-                    Make_Identifier (Loc, Name_uD),\n-                    New_Reference_To (B, Loc))));\n+                    New_Copy_Tree (Obj),             --  <object>\n+                    New_Reference_To (S, Loc),       --  S\n+                    Make_Attribute_Reference (Loc,   --  P'Address\n+                      Prefix =>\n+                        New_Reference_To (P, Loc),\n+                      Attribute_Name =>\n+                        Name_Address),\n+                    Make_Identifier (Loc, Name_uD),  --  D\n+                    New_Reference_To (B, Loc))));    --  B\n \n             --  Generate:\n             --    if Enqueued (Bnn) then\n@@ -5304,7 +5295,8 @@ package body Exp_Ch9 is\n             ProtE_Stmts :=\n               New_List (\n                 Make_Implicit_Label_Declaration (Loc,\n-                  Defining_Identifier => Abort_Block_Ent),\n+                  Defining_Identifier =>\n+                    Abort_Block_Ent),\n \n                 Build_Abort_Block\n                   (Loc, Abort_Block_Ent, Cleanup_Block_Ent, Cleanup_Block));\n@@ -5329,8 +5321,9 @@ package body Exp_Ch9 is\n                 Then_Statements =>\n                   New_Copy_List_Tree (Tstats)));\n \n-            --  ---------------------------------------------------------------\n-            --  Task entry handling\n+            -------------------------\n+            -- Task entry handling --\n+            -------------------------\n \n             --  Generate:\n             --    Param1 := P.Param1;\n@@ -5354,7 +5347,7 @@ package body Exp_Ch9 is\n                       Make_Identifier (Loc, Name_uD))));\n \n             --  Generate:\n-            --    _Disp_Asynchronous_Select (<object>, S, P'address, D, B);\n+            --    _Disp_Asynchronous_Select (<object>, S, P'Address, D, B);\n \n             Prepend_To (TaskE_Stmts,\n               Make_Procedure_Call_Statement (Loc,\n@@ -5365,13 +5358,15 @@ package body Exp_Ch9 is\n                     Loc),\n                 Parameter_Associations =>\n                   New_List (\n-                    New_Copy_Tree    (Obj),\n-                    New_Reference_To (S, Loc),\n-                    Make_Attribute_Reference (Loc,\n-                      Prefix => New_Reference_To (P, Loc),\n-                      Attribute_Name => Name_Address),\n-                    Make_Identifier (Loc, Name_uD),\n-                    New_Reference_To (B, Loc))));\n+                    New_Copy_Tree (Obj),             --  <object>\n+                    New_Reference_To (S, Loc),       --  S\n+                    Make_Attribute_Reference (Loc,   --  P'Address\n+                      Prefix =>\n+                        New_Reference_To (P, Loc),\n+                      Attribute_Name =>\n+                        Name_Address),\n+                    Make_Identifier (Loc, Name_uD),  --  D\n+                    New_Reference_To (B, Loc))));    --  B\n \n             --  Generate:\n             --    Abort_Defer;\n@@ -5431,7 +5426,8 @@ package body Exp_Ch9 is\n \n             Append_To (TaskE_Stmts,\n               Make_Implicit_Label_Declaration (Loc,\n-                Defining_Identifier => Abort_Block_Ent));\n+                Defining_Identifier =>\n+                  Abort_Block_Ent));\n \n             Append_To (TaskE_Stmts,\n               Build_Abort_Block\n@@ -5452,8 +5448,9 @@ package body Exp_Ch9 is\n                 Then_Statements =>\n                   New_Copy_List_Tree (Tstats)));\n \n-            -------------------------------------------------------------------\n-            --  Protected procedure handling\n+            ----------------------------------\n+            -- Protected procedure handling --\n+            ----------------------------------\n \n             --  Generate:\n             --    <dispatching-call>;\n@@ -5463,11 +5460,11 @@ package body Exp_Ch9 is\n             Prepend_To (ProtP_Stmts, New_Copy_Tree (Ecall));\n \n             --  Generate:\n-            --    S := Ada.Tags.Get_Offset_Index (\n-            --           Ada.Tags.Tag (<object>), DT_Position (Call_Ent));\n+            --    S := Ada.Tags.Get_Offset_Index\n+            --           (Ada.Tags.Tag (<object>), DT_Position (Call_Ent));\n \n-            Conc_Typ_Stmts := New_List (\n-              Build_S_Assignment (Loc, S, Obj, Call_Ent));\n+            Conc_Typ_Stmts :=\n+              New_List (Build_S_Assignment (Loc, S, Obj, Call_Ent));\n \n             --  Generate:\n             --    _Disp_Get_Prim_Op_Kind (<object>, S, C);\n@@ -5481,7 +5478,7 @@ package body Exp_Ch9 is\n                     Loc),\n                 Parameter_Associations =>\n                   New_List (\n-                    New_Copy_Tree    (Obj),\n+                    New_Copy_Tree (Obj),\n                     New_Reference_To (S, Loc),\n                     New_Reference_To (C, Loc))));\n \n@@ -5845,9 +5842,10 @@ package body Exp_Ch9 is\n            Make_Implicit_Exception_Handler (Loc,\n              Exception_Choices =>\n                New_List (New_Reference_To (Stand.Abort_Signal, Loc)),\n-             Statements => New_List (\n-               Make_Procedure_Call_Statement (Loc,\n-                 Name => New_Reference_To (RTE (RE_Abort_Undefer), Loc)))));\n+             Statements =>\n+               New_List (\n+                 Make_Procedure_Call_Statement (Loc,\n+                   Name => New_Reference_To (RTE (RE_Abort_Undefer), Loc)))));\n \n          Prepend_To (Astats,\n            Make_Procedure_Call_Statement (Loc,\n@@ -5868,8 +5866,10 @@ package body Exp_Ch9 is\n                Make_Handled_Sequence_Of_Statements (Loc,\n                  Statements => New_List (\n                    Make_Implicit_Label_Declaration (Loc,\n-                     Defining_Identifier => Blk_Ent,\n-                     Label_Construct     => Abortable_Block),\n+                     Defining_Identifier =>\n+                       Blk_Ent,\n+                     Label_Construct =>\n+                       Abortable_Block),\n                    Abortable_Block),\n                  Exception_Handlers => Hdle)));\n \n@@ -5931,11 +5931,11 @@ package body Exp_Ch9 is\n \n    --    begin\n    --       Task_Entry_Call\n-   --         (acceptor-task,\n-   --          entry-index,\n-   --          P'Address,\n-   --          Conditional_Call,\n-   --          B);\n+   --         (<acceptor-task>,   --  Acceptor\n+   --          <entry-index>,     --  E\n+   --          P'Address,         --  Uninterpreted_Data\n+   --          Conditional_Call,  --  Mode\n+   --          B);                --  Rendezvous_Successful\n    --       parm := P.param;\n    --       parm := P.param;\n    --       ...\n@@ -5946,10 +5946,10 @@ package body Exp_Ch9 is\n    --       end if;\n    --    end;\n \n-   --  For a description of the use of P and the assignments after the\n-   --  call, see Expand_N_Entry_Call_Statement. Note that the entry call\n-   --  of the conditional entry call has already been expanded (by the\n-   --  Expand_N_Entry_Call_Statement procedure) as follows:\n+   --  For a description of the use of P and the assignments after the call,\n+   --  see Expand_N_Entry_Call_Statement. Note that the entry call of the\n+   --  conditional entry call has already been expanded (by the Expand_N_Entry\n+   --  _Call_Statement procedure) as follows:\n \n    --    declare\n    --       P : parms := (parm, parm, parm);\n@@ -5971,12 +5971,12 @@ package body Exp_Ch9 is\n    --       Bnn : Communications_Block;\n \n    --    begin\n-   --       Protected_Entry_Call (\n-   --         Object => po._object'Access,\n-   --         E => <entry index>;\n-   --         Uninterpreted_Data => P'Address;\n-   --         Mode => Conditional_Call;\n-   --         Block => Bnn);\n+   --       Protected_Entry_Call\n+   --         (po._object'Access,  --  Object\n+   --          <entry index>,      --  E\n+   --          P'Address,          --  Uninterpreted_Data\n+   --          Conditional_Call,   --  Mode\n+   --          Bnn);               --  Block\n    --       parm := P.param;\n    --       parm := P.param;\n    --       ...\n@@ -5987,26 +5987,6 @@ package body Exp_Ch9 is\n    --       end if;\n    --    end;\n \n-   --  As for tasks, the entry call of the conditional entry call has\n-   --  already been expanded (by the Expand_N_Entry_Call_Statement procedure)\n-   --  as follows:\n-\n-   --    declare\n-   --       P   : E1_Params := (param, param, param);\n-   --       Bnn : Communications_Block;\n-\n-   --    begin\n-   --       Protected_Entry_Call (\n-   --         Object => po._object'Access,\n-   --         E => <entry index>;\n-   --         Uninterpreted_Data => P'Address;\n-   --         Mode => Simple_Call;\n-   --         Block => Bnn);\n-   --       parm := P.param;\n-   --       parm := P.param;\n-   --         ...\n-   --    end;\n-\n    --  Ada 2005 (AI-345): A dispatching conditional entry call is converted\n    --  into:\n \n@@ -6024,10 +6004,11 @@ package body Exp_Ch9 is\n    --          <triggering-statements>\n \n    --       else\n-   --          S := Ada.Tags.Get_Offset_Index (Ada.Tags.Tag (<object>),\n-   --                 DT_Position (<dispatching-call>));\n+   --          S :=\n+   --            Ada.Tags.Get_Offset_Index\n+   --              (Ada.Tags.Tag (<object>), DT_Position (<dispatching-call>));\n \n-   --          _Disp_Conditional_Select (<object>, S, P'address, C, B);\n+   --          _Disp_Conditional_Select (<object>, S, P'Address, C, B);\n \n    --          if C = POK_Protected_Entry\n    --            or else C = POK_Task_Entry\n@@ -6056,7 +6037,6 @@ package body Exp_Ch9 is\n       Loc : constant Source_Ptr := Sloc (N);\n       Alt : constant Node_Id    := Entry_Call_Alternative (N);\n       Blk : Node_Id             := Entry_Call_Statement (Alt);\n-      Transient_Blk : Node_Id;\n \n       Actuals        : List_Id;\n       Blk_Typ        : Entity_Id;\n@@ -6073,6 +6053,7 @@ package body Exp_Ch9 is\n       Params         : List_Id;\n       Stmt           : Node_Id;\n       Stmts          : List_Id;\n+      Transient_Blk  : Node_Id;\n       Unpack         : List_Id;\n \n       B : Entity_Id;  --  Call status flag\n@@ -6118,14 +6099,14 @@ package body Exp_Ch9 is\n          S := Build_S (Loc, Decls);\n \n          --  Generate:\n-         --    S := Ada.Tags.Get_Offset_Index (\n-         --           Ada.Tags.Tag (<object>), DT_Position (Call_Ent));\n+         --    S := Ada.Tags.Get_Offset_Index\n+         --           (Ada.Tags.Tag (<object>), DT_Position (Call_Ent));\n \n-         Conc_Typ_Stmts := New_List (\n-           Build_S_Assignment (Loc, S, Obj, Call_Ent));\n+         Conc_Typ_Stmts :=\n+           New_List (Build_S_Assignment (Loc, S, Obj, Call_Ent));\n \n          --  Generate:\n-         --    _Disp_Conditional_Select (<object>, S, P'address, C, B);\n+         --    _Disp_Conditional_Select (<object>, S, P'Address, C, B);\n \n          Append_To (Conc_Typ_Stmts,\n            Make_Procedure_Call_Statement (Loc,\n@@ -6136,13 +6117,15 @@ package body Exp_Ch9 is\n                  Loc),\n              Parameter_Associations =>\n                New_List (\n-                 New_Copy_Tree    (Obj),\n-                 New_Reference_To (S, Loc),\n-                 Make_Attribute_Reference (Loc,\n-                   Prefix => New_Reference_To (P, Loc),\n-                   Attribute_Name => Name_Address),\n-                 New_Reference_To (C, Loc),\n-                 New_Reference_To (B, Loc))));\n+                 New_Copy_Tree (Obj),            --  <object>\n+                 New_Reference_To (S, Loc),      --  S\n+                 Make_Attribute_Reference (Loc,  --  P'Address\n+                   Prefix =>\n+                     New_Reference_To (P, Loc),\n+                   Attribute_Name =>\n+                     Name_Address),\n+                 New_Reference_To (C, Loc),      --  C\n+                 New_Reference_To (B, Loc))));   --  B\n \n          --  Generate:\n          --    if C = POK_Protected_Entry\n@@ -6231,7 +6214,7 @@ package body Exp_Ch9 is\n \n          Append_To (Conc_Typ_Stmts,\n            Make_If_Statement (Loc,\n-             Condition       => New_Reference_To (B, Loc),\n+             Condition => New_Reference_To (B, Loc),\n              Then_Statements => N_Stats,\n              Else_Statements => Else_Statements (N)));\n \n@@ -6266,7 +6249,8 @@ package body Exp_Ch9 is\n \n          Rewrite (N,\n            Make_Block_Statement (Loc,\n-             Declarations               => Decls,\n+             Declarations =>\n+               Decls,\n              Handled_Statement_Sequence =>\n                Make_Handled_Sequence_Of_Statements (Loc, Stmts)));\n \n@@ -6279,7 +6263,7 @@ package body Exp_Ch9 is\n \n       else\n          Transient_Blk :=\n-            First_Real_Statement (Handled_Statement_Sequence (Blk));\n+           First_Real_Statement (Handled_Statement_Sequence (Blk));\n \n          if Present (Transient_Blk)\n            and then Nkind (Transient_Blk) = N_Block_Statement\n@@ -7803,12 +7787,13 @@ package body Exp_Ch9 is\n    -- Expand_N_Requeue_Statement --\n    --------------------------------\n \n-   --  A requeue statement is expanded into one of four GNARLI operations,\n-   --  depending on the source and destination (task or protected object). In\n-   --  addition, code must be generated to jump around the remainder of\n-   --  processing for the original entry and, if the destination is (different)\n-   --  protected object, to attempt to service it. The following illustrates\n-   --  the various cases:\n+   --  A non-dispatching requeue statement is expanded into one of four GNARLI\n+   --  operations, depending on the source and destination (task or protected\n+   --  object). A dispatching requeue statement is expanded into a call to the\n+   --  predefined primitive _Disp_Requeue. In addition, code is generated to\n+   --  jump around the remainder of processing for the original entry and, if\n+   --  the destination is (different) protected object, to attempt to service\n+   --  it. The following illustrates the various cases:\n \n    --  procedure entE\n    --    (O : System.Address;\n@@ -7818,7 +7803,7 @@ package body Exp_Ch9 is\n    --     <discriminant renamings>\n    --     <private object renamings>\n    --     type poVP is access poV;\n-   --     _Object : ptVP := ptVP!(O);\n+   --     _object : ptVP := ptVP!(O);\n \n    --  begin\n    --     begin\n@@ -7845,12 +7830,12 @@ package body Exp_Ch9 is\n    --        return;\n \n    --        <rest of statement sequence for entry>\n-   --        Complete_Entry_Body (_Object._Object);\n+   --        Complete_Entry_Body (_object._object);\n \n    --     exception\n    --        when all others =>\n    --           Exceptional_Complete_Entry_Body (\n-   --             _Object._Object, Get_GNAT_Exception);\n+   --             _object._object, Get_GNAT_Exception);\n    --     end;\n    --  end entE;\n \n@@ -7886,104 +7871,247 @@ package body Exp_Ch9 is\n    --     when all others =>\n    --        Exceptional_Complete_Rendezvous (Get_GNAT_Exception);\n \n-   --  Further details on these expansions can be found in\n-   --  Expand_N_Protected_Body and Expand_N_Accept_Statement.\n+   --  Ada 2005 (AI05-0030): Dispatching requeue from protected to interface\n+   --  class-wide type:\n+\n+   --  procedure entE\n+   --    (O : System.Address;\n+   --     P : System.Address;\n+   --     E : Protected_Entry_Index)\n+   --  is\n+   --     <discriminant renamings>\n+   --     <private object renamings>\n+   --     type poVP is access poV;\n+   --     _object : ptVP := ptVP!(O);\n+\n+   --  begin\n+   --     begin\n+   --        <start of statement sequence for entry>\n+\n+   --        _Disp_Requeue\n+   --          (<interface class-wide object>,\n+   --           True,\n+   --           _object'Address,\n+   --           Ada.Tags.Get_Offset_Index\n+   --             (Tag (_object),\n+   --              <interface dispatch table index of target entry>),\n+   --           Abort_Present);\n+   --        return;\n+\n+   --        <rest of statement sequence for entry>\n+   --        Complete_Entry_Body (_object._object);\n+\n+   --     exception\n+   --        when all others =>\n+   --           Exceptional_Complete_Entry_Body (\n+   --             _object._object, Get_GNAT_Exception);\n+   --     end;\n+   --  end entE;\n+\n+   --  Ada 2005 (AI05-0030): Dispatching requeue from task to interface\n+   --  class-wide type:\n+\n+   --  Accept_Call (E, Ann);\n+   --     <start of statement sequence for accept statement>\n+   --     _Disp_Requeue\n+   --       (<interface class-wide object>,\n+   --        False,\n+   --        null,\n+   --        Ada.Tags.Get_Offset_Index\n+   --          (Tag (_object),\n+   --           <interface dispatch table index of target entrt>),\n+   --        Abort_Present);\n+   --     newS (new, Pnn);\n+   --     goto Lnn;\n+   --     <rest of statement sequence for accept statement>\n+   --     <<Lnn>>\n+   --     Complete_Rendezvous;\n+\n+   --  exception\n+   --     when all others =>\n+   --        Exceptional_Complete_Rendezvous (Get_GNAT_Exception);\n+\n+   --  Further details on these expansions can be found in Expand_N_Protected_\n+   --  Body and Expand_N_Accept_Statement.\n \n    procedure Expand_N_Requeue_Statement (N : Node_Id) is\n       Loc        : constant Source_Ptr := Sloc (N);\n+      Abortable  : Node_Id;\n       Acc_Stat   : Node_Id;\n+      Conc_Typ   : Entity_Id;\n       Concval    : Node_Id;\n       Ename      : Node_Id;\n       Index      : Node_Id;\n-      Conctyp    : Entity_Id;\n-      Oldtyp     : Entity_Id;\n       Lab_Node   : Node_Id;\n-      Rcall      : Node_Id;\n-      Abortable  : Node_Id;\n-      Skip_Stat  : Node_Id;\n-      Self_Param : Node_Id;\n       New_Param  : Node_Id;\n+      Old_Typ    : Entity_Id;\n       Params     : List_Id;\n+      Rcall      : Node_Id;\n       RTS_Call   : Entity_Id;\n+      Self_Param : Node_Id;\n+      Skip_Stat  : Node_Id;\n \n    begin\n       Abortable :=\n         New_Occurrence_Of (Boolean_Literals (Abort_Present (N)), Loc);\n \n-      --  Set up the target object\n+      --  Extract the components of the entry call\n \n       Extract_Entry (N, Concval, Ename, Index);\n-      Conctyp := Etype (Concval);\n-      New_Param := Concurrent_Ref (Concval);\n+      Conc_Typ := Etype (Concval);\n \n-      --  The target entry index and abortable flag are the same for all cases\n+      --  Examine the scope stack in order to find nearest enclosing protected\n+      --  or task type. This will constitute our invocation source.\n \n-      Params := New_List (\n-        Entry_Index_Expression (Loc, Entity (Ename), Index, Conctyp),\n-        Abortable);\n+      Old_Typ := Current_Scope;\n+      while Present (Old_Typ)\n+        and then not Is_Protected_Type (Old_Typ)\n+        and then not Is_Task_Type (Old_Typ)\n+      loop\n+         Old_Typ := Scope (Old_Typ);\n+      end loop;\n \n-      --  Determine proper GNARLI call and required additional parameters\n-      --  Loop to find nearest enclosing task type or protected type\n+      --  Generate the parameter list for all cases. The abortable flag is\n+      --  common among dispatching and regular requeue.\n \n-      Oldtyp := Current_Scope;\n-      loop\n-         if Is_Task_Type (Oldtyp) then\n-            if Is_Task_Type (Conctyp) then\n-               RTS_Call := RTE (RE_Requeue_Task_Entry);\n+      Params := New_List (Abortable);\n \n-            else\n-               pragma Assert (Is_Protected_Type (Conctyp));\n-               RTS_Call := RTE (RE_Requeue_Task_To_Protected_Entry);\n-               New_Param :=\n-                 Make_Attribute_Reference (Loc,\n-                   Prefix => New_Param,\n-                   Attribute_Name => Name_Unchecked_Access);\n-            end if;\n+      --  Ada 2005 (AI05-0030): We have a dispatching requeue of the form\n+      --  Concval.Ename where the type of Concval is class-wide concurrent\n+      --  interface.\n \n-            Prepend (New_Param, Params);\n-            exit;\n+      if Ada_Version >= Ada_05\n+        and then Present (Concval)\n+        and then Is_Class_Wide_Type (Conc_Typ)\n+        and then Is_Concurrent_Interface (Conc_Typ)\n+      then\n+         RTS_Call := Make_Identifier (Loc, Name_uDisp_Requeue);\n+\n+         --  Generate:\n+         --    Ada.Tags.Get_Offset_Index\n+         --      (Ada.Tags.Tag (Concval),\n+         --       <interface dispatch table position of Ename>)\n+\n+         Prepend_To (Params,\n+           Make_Function_Call (Loc,\n+             Name =>\n+               New_Reference_To (RTE (RE_Get_Offset_Index), Loc),\n+             Parameter_Associations =>\n+               New_List (\n+                 Unchecked_Convert_To (RTE (RE_Tag), Concval),\n+                 Make_Integer_Literal (Loc, DT_Position (Entity (Ename))))));\n+\n+         --  Specific actuals for protected to interface class-wide type\n+         --  requeue.\n+\n+         if Is_Protected_Type (Old_Typ) then\n+            Prepend_To (Params,\n+              Make_Attribute_Reference (Loc,        --  _object'Address\n+                Prefix =>\n+                  Concurrent_Ref (New_Occurrence_Of (Old_Typ, Loc)),\n+                Attribute_Name =>\n+                  Name_Address));\n+            Prepend_To (Params,                     --  True\n+              New_Reference_To (Standard_True, Loc));\n+\n+         --  Specific actuals for task to interface class-wide type requeue\n \n-         elsif Is_Protected_Type (Oldtyp) then\n+         else\n+            pragma Assert (Is_Task_Type (Old_Typ));\n+\n+            Prepend_To (Params,                     --  null\n+              New_Reference_To (RTE (RE_Null_Address), Loc));\n+            Prepend_To (Params,                     --  False\n+              New_Reference_To (Standard_False, Loc));\n+         end if;\n+\n+         --  Finally, add the common object parameter\n+\n+         Prepend_To (Params, New_Copy_Tree (Concval));\n+\n+      --  Regular requeue processing\n+\n+      else\n+         New_Param := Concurrent_Ref (Concval);\n+\n+         --  The index expression is common among all four cases\n+\n+         Prepend_To (Params,\n+           Entry_Index_Expression (Loc, Entity (Ename), Index, Conc_Typ));\n+\n+         if Is_Protected_Type (Old_Typ) then\n             Self_Param :=\n               Make_Attribute_Reference (Loc,\n-                Prefix => Concurrent_Ref (New_Occurrence_Of (Oldtyp, Loc)),\n-                Attribute_Name => Name_Unchecked_Access);\n+                Prefix =>\n+                  Concurrent_Ref (New_Occurrence_Of (Old_Typ, Loc)),\n+                Attribute_Name =>\n+                  Name_Unchecked_Access);\n \n-            if Is_Task_Type (Conctyp) then\n-               RTS_Call := RTE (RE_Requeue_Protected_To_Task_Entry);\n+            --  Protected to protected requeue\n+\n+            if Is_Protected_Type (Conc_Typ) then\n+               RTS_Call :=\n+                 New_Reference_To (RTE (RE_Requeue_Protected_Entry), Loc);\n \n-            else\n-               pragma Assert (Is_Protected_Type (Conctyp));\n-               RTS_Call := RTE (RE_Requeue_Protected_Entry);\n                New_Param :=\n                  Make_Attribute_Reference (Loc,\n-                   Prefix => New_Param,\n-                   Attribute_Name => Name_Unchecked_Access);\n+                   Prefix =>\n+                     New_Param,\n+                   Attribute_Name =>\n+                     Name_Unchecked_Access);\n+\n+            --  Protected to task requeue\n+\n+            else\n+               pragma Assert (Is_Task_Type (Conc_Typ));\n+               RTS_Call :=\n+                 New_Reference_To (\n+                   RTE (RE_Requeue_Protected_To_Task_Entry), Loc);\n             end if;\n \n             Prepend (New_Param, Params);\n             Prepend (Self_Param, Params);\n-            exit;\n-\n-         --  If neither task type or protected type, must be in some inner\n-         --  enclosing block, so move on out\n \n          else\n-            Oldtyp := Scope (Oldtyp);\n+            pragma Assert (Is_Task_Type (Old_Typ));\n+\n+            --  Task to protected requeue\n+\n+            if Is_Protected_Type (Conc_Typ) then\n+               RTS_Call :=\n+                 New_Reference_To (\n+                   RTE (RE_Requeue_Task_To_Protected_Entry), Loc);\n+\n+               New_Param :=\n+                 Make_Attribute_Reference (Loc,\n+                   Prefix =>\n+                     New_Param,\n+                   Attribute_Name =>\n+                     Name_Unchecked_Access);\n+\n+            --  Task to task requeue\n+\n+            else\n+               pragma Assert (Is_Task_Type (Conc_Typ));\n+               RTS_Call :=\n+                 New_Reference_To (RTE (RE_Requeue_Task_Entry), Loc);\n+            end if;\n+\n+            Prepend (New_Param, Params);\n          end if;\n-      end loop;\n+      end if;\n \n-      --  Create the GNARLI call\n+      --  Create the GNARLI or predefined primitive call\n \n-      Rcall := Make_Procedure_Call_Statement (Loc,\n-        Name =>\n-          New_Occurrence_Of (RTS_Call, Loc),\n-        Parameter_Associations => Params);\n+      Rcall :=\n+        Make_Procedure_Call_Statement (Loc,\n+          Name => RTS_Call,\n+          Parameter_Associations => Params);\n \n       Rewrite (N, Rcall);\n       Analyze (N);\n \n-      if Is_Protected_Type (Oldtyp) then\n+      if Is_Protected_Type (Old_Typ) then\n \n          --  Build the return statement to skip the rest of the entry body\n \n@@ -9776,8 +9904,8 @@ package body Exp_Ch9 is\n    --       P  : parms := (parm, parm, parm);\n \n    --    begin\n-   --       Timed_Protected_Entry_Call (<acceptor-task>, X, P'Address,\n-   --         DX, M, B);\n+   --       Timed_Protected_Entry_Call\n+   --         (<acceptor-task>, X, P'Address, DX, M, B);\n    --       if B then\n    --          S1;\n    --       else\n@@ -9795,8 +9923,8 @@ package body Exp_Ch9 is\n    --       P  : parms := (parm, parm, parm);\n \n    --    begin\n-   --       Timed_Protected_Entry_Call (<object>'unchecked_access, X,\n-   --         P'Address, DX, M, B);\n+   --       Timed_Protected_Entry_Call\n+   --         (<object>'unchecked_access, X, P'Address, DX, M, B);\n    --       if B then\n    --          S1;\n    --       else\n@@ -9810,8 +9938,8 @@ package body Exp_Ch9 is\n    --       B  : Boolean := False;\n    --       C  : Ada.Tags.Prim_Op_Kind;\n    --       DX : Duration := To_Duration (D)\n-   --       K : Ada.Tags.Tagged_Kind :=\n-   --             Ada.Tags.Get_Tagged_Kind (Ada.Tags.Tag (<object>));\n+   --       K  : Ada.Tags.Tagged_Kind :=\n+   --              Ada.Tags.Get_Tagged_Kind (Ada.Tags.Tag (<object>));\n    --       M  : Integer :=...;\n    --       P  : Parameters := (Param1 .. ParamN);\n    --       S  : Iteger;\n@@ -9822,8 +9950,9 @@ package body Exp_Ch9 is\n    --          <triggering-statements>\n \n    --       else\n-   --          S := Ada.Tags.Get_Offset_Index (Ada.Tags.Tag (<object>),\n-   --                 DT_Position (<dispatching-call>));\n+   --          S :=\n+   --            Ada.Tags.Get_Offset_Index\n+   --              (Ada.Tags.Tag (<object>), DT_Position (<dispatching-call>));\n \n    --          _Disp_Timed_Select (<object>, S, P'Address, DX, M, C, B);\n \n@@ -9857,7 +9986,7 @@ package body Exp_Ch9 is\n                   Entry_Call_Statement (Entry_Call_Alternative (N));\n       E_Stats : constant List_Id :=\n                   Statements (Entry_Call_Alternative (N));\n-      D_Stat  : constant Node_Id :=\n+      D_Stat  : Node_Id :=\n                   Delay_Statement (Delay_Alternative (N));\n       D_Stats : constant List_Id :=\n                   Statements (Delay_Alternative (N));\n@@ -9876,6 +10005,7 @@ package body Exp_Ch9 is\n       Ename          : Node_Id;\n       Formals        : List_Id;\n       Index          : Node_Id;\n+      Is_Disp_Select : Boolean;\n       Lim_Typ_Stmts  : List_Id;\n       N_Stats        : List_Id;\n       Obj            : Entity_Id;\n@@ -9901,21 +10031,39 @@ package body Exp_Ch9 is\n \n       if Nkind (E_Call) = N_Block_Statement then\n          E_Call := First (Statements (Handled_Statement_Sequence (E_Call)));\n-         while Nkind (E_Call) /= N_Procedure_Call_Statement\n-           and then Nkind (E_Call) /= N_Entry_Call_Statement\n+         while not Nkind_In (E_Call, N_Procedure_Call_Statement,\n+                                     N_Entry_Call_Statement)\n          loop\n             Next (E_Call);\n          end loop;\n       end if;\n \n-      if Ada_Version >= Ada_05\n-        and then Nkind (E_Call) = N_Procedure_Call_Statement\n-      then\n+      Is_Disp_Select :=\n+        Ada_Version >= Ada_05\n+          and then Nkind (E_Call) = N_Procedure_Call_Statement;\n+\n+      if Is_Disp_Select then\n          Extract_Dispatching_Call (E_Call, Call_Ent, Obj, Actuals, Formals);\n \n          Decls := New_List;\n          Stmts := New_List;\n \n+         --  Generate:\n+         --    B : Boolean := False;\n+\n+         B := Build_B (Loc, Decls);\n+\n+         --  Generate:\n+         --    C : Ada.Tags.Prim_Op_Kind;\n+\n+         C := Build_C (Loc, Decls);\n+\n+         --  Because the analysis of all statements was disabled, manually\n+         --  analyze the delay statement.\n+\n+         Analyze (D_Stat);\n+         D_Stat := Original_Node (D_Stat);\n+\n       else\n          --  Build an entry call using Simple_Entry_Call\n \n@@ -9928,19 +10076,7 @@ package body Exp_Ch9 is\n          if No (Decls) then\n             Decls := New_List;\n          end if;\n-      end if;\n-\n-      --  Call status flag processing\n \n-      if Ada_Version >= Ada_05\n-        and then Nkind (E_Call) = N_Procedure_Call_Statement\n-      then\n-         --  Generate:\n-         --    B : Boolean := False;\n-\n-         B := Build_B (Loc, Decls);\n-\n-      else\n          --  Generate:\n          --    B : Boolean;\n \n@@ -9954,23 +10090,12 @@ package body Exp_Ch9 is\n                New_Reference_To (Standard_Boolean, Loc)));\n       end if;\n \n-      --  Call kind processing\n-\n-      if Ada_Version >= Ada_05\n-        and then Nkind (E_Call) = N_Procedure_Call_Statement\n-      then\n-         --  Generate:\n-         --    C : Ada.Tags.Prim_Op_Kind;\n-\n-         C := Build_C (Loc, Decls);\n-      end if;\n-\n       --  Duration and mode processing\n \n       D_Type := Base_Type (Etype (Expression (D_Stat)));\n \n-      --  Use the type of the delay expression (Calendar or Real_Time)\n-      --  to generate the appropriate conversion.\n+      --  Use the type of the delay expression (Calendar or Real_Time) to\n+      --  generate the appropriate conversion.\n \n       if Nkind (D_Stat) = N_Delay_Relative_Statement then\n          D_Disc := Make_Integer_Literal (Loc, 0);\n@@ -10031,33 +10156,32 @@ package body Exp_Ch9 is\n       --  case of entries, the block has already been created during the call\n       --  to Build_Simple_Entry_Call.\n \n-      if Ada_Version >= Ada_05\n-        and then Nkind (E_Call) = N_Procedure_Call_Statement\n-      then\n+      if Is_Disp_Select then\n+\n          --  Tagged kind processing, generate:\n          --    K : Ada.Tags.Tagged_Kind :=\n          --          Ada.Tags.Get_Tagged_Kind (Ada.Tags.Tag <object>));\n \n          K := Build_K (Loc, Decls, Obj);\n \n          Blk_Typ := Build_Parameter_Block (Loc, Actuals, Formals, Decls);\n-         P       := Parameter_Block_Pack  (Loc, Blk_Typ, Actuals, Formals,\n-                      Decls, Stmts);\n+         P := Parameter_Block_Pack\n+                (Loc, Blk_Typ, Actuals, Formals, Decls, Stmts);\n \n          --  Dispatch table slot processing, generate:\n          --    S : Integer;\n \n          S := Build_S (Loc, Decls);\n \n          --  Generate:\n-         --    S := Ada.Tags.Get_Offset_Index (\n-         --           Ada.Tags.Tag (<object>), DT_Position (Call_Ent));\n+         --    S := Ada.Tags.Get_Offset_Index\n+         --           (Ada.Tags.Tag (<object>), DT_Position (Call_Ent));\n \n-         Conc_Typ_Stmts := New_List (\n-           Build_S_Assignment (Loc, S, Obj, Call_Ent));\n+         Conc_Typ_Stmts :=\n+           New_List (Build_S_Assignment (Loc, S, Obj, Call_Ent));\n \n          --  Generate:\n-         --    _Disp_Timed_Select (<object>, S, P'address, D, M, C, B);\n+         --    _Disp_Timed_Select (<object>, S, P'Address, D, M, C, B);\n \n          --  where Obj is the controlling formal parameter, S is the dispatch\n          --  table slot number of the dispatching operation, P is the wrapped\n@@ -10066,7 +10190,7 @@ package body Exp_Ch9 is\n \n          Params := New_List;\n \n-         Append_To (Params, New_Copy_Tree    (Obj));\n+         Append_To (Params, New_Copy_Tree (Obj));\n          Append_To (Params, New_Reference_To (S, Loc));\n          Append_To (Params, Make_Attribute_Reference (Loc,\n                               Prefix => New_Reference_To (P, Loc),\n@@ -10173,7 +10297,7 @@ package body Exp_Ch9 is\n \n          Append_To (Conc_Typ_Stmts,\n            Make_If_Statement (Loc,\n-             Condition       => New_Reference_To (B, Loc),\n+             Condition => New_Reference_To (B, Loc),\n              Then_Statements => N_Stats,\n              Else_Statements => D_Stats));\n \n@@ -10700,8 +10824,7 @@ package body Exp_Ch9 is\n    begin\n       First_Op := First (D);\n       while Present (First_Op)\n-        and then Nkind (First_Op) /= N_Subprogram_Body\n-        and then Nkind (First_Op) /= N_Entry_Body\n+        and then not Nkind_In (First_Op, N_Subprogram_Body, N_Entry_Body)\n       loop\n          Next (First_Op);\n       end loop;\n@@ -10868,8 +10991,8 @@ package body Exp_Ch9 is\n       --  of this type should have been removed during semantic analysis.\n \n       Pdec := Parent (Ptyp);\n-      while Nkind (Pdec) /= N_Protected_Type_Declaration\n-        and then Nkind (Pdec) /= N_Single_Protected_Declaration\n+      while not Nkind_In (Pdec, N_Protected_Type_Declaration,\n+                                N_Single_Protected_Declaration)\n       loop\n          Next (Pdec);\n       end loop;\n@@ -11159,8 +11282,8 @@ package body Exp_Ch9 is\n       --  this type should have been removed during semantic analysis.\n \n       Tdec := Parent (Ttyp);\n-      while Nkind (Tdec) /= N_Task_Type_Declaration\n-        and then Nkind (Tdec) /= N_Single_Task_Declaration\n+      while not Nkind_In (Tdec, N_Task_Type_Declaration,\n+                                N_Single_Task_Declaration)\n       loop\n          Next (Tdec);\n       end loop;\n@@ -11354,8 +11477,7 @@ package body Exp_Ch9 is\n    begin\n       Next_Op := Next (N);\n       while Present (Next_Op)\n-        and then Nkind (Next_Op) /= N_Subprogram_Body\n-        and then Nkind (Next_Op) /= N_Entry_Body\n+        and then not Nkind_In (Next_Op, N_Subprogram_Body, N_Entry_Body)\n       loop\n          Next (Next_Op);\n       end loop;\n@@ -11590,8 +11712,7 @@ package body Exp_Ch9 is\n \n    begin\n       pragma Assert (Nkind (Dec) = N_Protected_Type_Declaration);\n-      pragma Assert\n-        (Nkind (Op) = N_Subprogram_Body or else Nkind (Op) = N_Entry_Body);\n+      pragma Assert (Nkind_In (Op, N_Subprogram_Body, N_Entry_Body));\n \n       Def := Protected_Definition (Dec);\n \n@@ -11611,11 +11732,12 @@ package body Exp_Ch9 is\n                       Chars => New_External_Name (Chars (P_Id)));\n                end if;\n \n-               Set_Ekind     (Priv, E_Variable);\n-               Set_Etype     (Priv, Etype (P_Id));\n-               Set_Scope     (Priv, Scope (P_Id));\n-               Set_Esize     (Priv, Esize (Etype (P_Id)));\n-               Set_Alignment (Priv, Alignment (Etype (P_Id)));\n+               Set_Ekind      (Priv, E_Variable);\n+               Set_Etype      (Priv, Etype (P_Id));\n+               Set_Scope      (Priv, Scope (P_Id));\n+               Set_Esize      (Priv, Esize (Etype (P_Id)));\n+               Set_Is_Aliased (Priv, Is_Aliased (P_Id));\n+               Set_Alignment  (Priv, Alignment (Etype (P_Id)));\n \n                --  If the type of the component is an itype, we must create a\n                --  new itype for the corresponding prival in each protected\n@@ -11733,9 +11855,9 @@ package body Exp_Ch9 is\n \n             return OK;\n \n-         elsif Nkind (N) = N_Defining_Identifier\n-           or else Nkind (N) = N_Defining_Operator_Symbol\n-           or else Nkind (N) = N_Defining_Character_Literal\n+         elsif Nkind_In (N, N_Defining_Identifier,\n+                            N_Defining_Operator_Symbol,\n+                            N_Defining_Character_Literal)\n          then\n             return Skip;\n "}]}