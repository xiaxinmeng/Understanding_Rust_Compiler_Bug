{"sha": "44b6ab2bf9597eb5f02e549d0236b942c007a1b0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDRiNmFiMmJmOTU5N2ViNWYwMmU1NDlkMDIzNmI5NDJjMDA3YTFiMA==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2016-01-22T20:18:59Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2016-01-22T20:18:59Z"}, "message": "re PR tree-optimization/69347 (excessive compile time with -O2)\n\n\tPR middle-end/69347\n\t* tree-ssa-dom.c (back_propagate_equivalences): Factored out of\n\trecord_temporary_equivalences.  Rewritten to avoid unnecessary calls\n\tinto dominated_by_p.\n\t(cprop_into_successor_phis): Avoid unnecessary tests.\n\nFrom-SVN: r232745", "tree": {"sha": "cf8111a865f76a45a4cf32927a96ef14d85eb955", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf8111a865f76a45a4cf32927a96ef14d85eb955"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/44b6ab2bf9597eb5f02e549d0236b942c007a1b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44b6ab2bf9597eb5f02e549d0236b942c007a1b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44b6ab2bf9597eb5f02e549d0236b942c007a1b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44b6ab2bf9597eb5f02e549d0236b942c007a1b0/comments", "author": null, "committer": null, "parents": [{"sha": "f7d2ad6f3cef3706618b3fb5aebcd3c7584a3bda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7d2ad6f3cef3706618b3fb5aebcd3c7584a3bda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7d2ad6f3cef3706618b3fb5aebcd3c7584a3bda"}], "stats": {"total": 139, "additions": 91, "deletions": 48}, "files": [{"sha": "5dfdfc59ba24b6b5da62fd19e9a22332db3b1089", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44b6ab2bf9597eb5f02e549d0236b942c007a1b0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44b6ab2bf9597eb5f02e549d0236b942c007a1b0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=44b6ab2bf9597eb5f02e549d0236b942c007a1b0", "patch": "@@ -1,3 +1,11 @@\n+2016-01-21  Jeff Law  <law@redhat.com>\n+\n+\tPR middle-end/69347\n+\t* tree-ssa-dom.c (back_propagate_equivalences): Factored out of\n+\trecord_temporary_equivalences.  Rewritten to avoid unnecessary calls\n+\tinto dominated_by_p.\n+\t(cprop_into_successor_phis): Avoid unnecessary tests.\n+\n 2016-01-22  Richard Henderson  <rth@redhat.com>\n \n \tPR target/69416"}, {"sha": "b690d927b6cc728bab2dd3a7e053b0c78837e366", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 83, "deletions": 48, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44b6ab2bf9597eb5f02e549d0236b942c007a1b0/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44b6ab2bf9597eb5f02e549d0236b942c007a1b0/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=44b6ab2bf9597eb5f02e549d0236b942c007a1b0", "patch": "@@ -819,6 +819,74 @@ dom_valueize (tree t)\n   return t;\n }\n \n+/* We have just found an equivalence for LHS on an edge E.\n+   Look backwards to other uses of LHS and see if we can derive\n+   additional equivalences that are valid on edge E.  */\n+static void\n+back_propagate_equivalences (tree lhs, edge e,\n+\t\t\t     class const_and_copies *const_and_copies)\n+{\n+  use_operand_p use_p;\n+  imm_use_iterator iter;\n+  bitmap domby = NULL;\n+  basic_block dest = e->dest;\n+\n+  /* Iterate over the uses of LHS to see if any dominate E->dest.\n+     If so, they may create useful equivalences too.\n+\n+     ???  If the code gets re-organized to a worklist to catch more\n+     indirect opportunities and it is made to handle PHIs then this\n+     should only consider use_stmts in basic-blocks we have already visited.  */\n+  FOR_EACH_IMM_USE_FAST (use_p, iter, lhs)\n+    {\n+      gimple *use_stmt = USE_STMT (use_p);\n+\n+      /* Often the use is in DEST, which we trivially know we can't use.\n+\t This is cheaper than the dominator set tests below.  */\n+      if (dest == gimple_bb (use_stmt))\n+\tcontinue;\n+\n+      /* Filter out statements that can never produce a useful\n+\t equivalence.  */\n+      tree lhs2 = gimple_get_lhs (use_stmt);\n+      if (!lhs2 || TREE_CODE (lhs2) != SSA_NAME)\n+\tcontinue;\n+\n+      /* Profiling has shown the domination tests here can be fairly\n+\t expensive.  We get significant improvements by building the\n+\t set of blocks that dominate BB.  We can then just test\n+\t for set membership below.\n+\n+\t We also initialize the set lazily since often the only uses\n+\t are going to be in the same block as DEST.  */\n+      if (!domby)\n+\t{\n+\t  domby = BITMAP_ALLOC (NULL);\n+\t  basic_block bb = get_immediate_dominator (CDI_DOMINATORS, dest);\n+\t  while (bb)\n+\t    {\n+\t      bitmap_set_bit (domby, bb->index);\n+\t      bb = get_immediate_dominator (CDI_DOMINATORS, bb);\n+\t    }\n+\t}\n+\n+      /* This tests if USE_STMT does not dominate DEST.  */\n+      if (!bitmap_bit_p (domby, gimple_bb (use_stmt)->index))\n+\tcontinue;\n+\n+      /* At this point USE_STMT dominates DEST and may result in a\n+\t useful equivalence.  Try to simplify its RHS to a constant\n+\t or SSA_NAME.  */\n+      tree res = gimple_fold_stmt_to_constant_1 (use_stmt, dom_valueize,\n+\t\t\t\t\t\t no_follow_ssa_edges);\n+      if (res && (TREE_CODE (res) == SSA_NAME || is_gimple_min_invariant (res)))\n+\trecord_equality (lhs2, res, const_and_copies);\n+    }\n+\n+  if (domby)\n+    BITMAP_FREE (domby);\n+}\n+\n /* Record into CONST_AND_COPIES and AVAIL_EXPRS_STACK any equivalences implied\n    by traversing edge E (which are cached in E->aux).\n \n@@ -836,19 +904,23 @@ record_temporary_equivalences (edge e,\n   if (edge_info)\n     {\n       cond_equivalence *eq;\n+      /* If we have 0 = COND or 1 = COND equivalences, record them\n+\t into our expression hash tables.  */\n+      for (i = 0; edge_info->cond_equivalences.iterate (i, &eq); ++i)\n+\trecord_cond (eq, avail_exprs_stack);\n+\n       tree lhs = edge_info->lhs;\n-      tree rhs = edge_info->rhs;\n+      if (!lhs || TREE_CODE (lhs) != SSA_NAME)\n+\treturn;\n \n-      /* If we have a simple NAME = VALUE equivalence, record it.  */\n-      if (lhs)\n-\trecord_equality (lhs, rhs, const_and_copies);\n+      /* Record the simple NAME = VALUE equivalence.  */\n+      tree rhs = edge_info->rhs;\n+      record_equality (lhs, rhs, const_and_copies);\n \n       /* If LHS is an SSA_NAME and RHS is a constant integer and LHS was\n \t set via a widening type conversion, then we may be able to record\n \t additional equivalences.  */\n-      if (lhs\n-\t  && TREE_CODE (lhs) == SSA_NAME\n-\t  && TREE_CODE (rhs) == INTEGER_CST)\n+      if (TREE_CODE (rhs) == INTEGER_CST)\n \t{\n \t  gimple *defstmt = SSA_NAME_DEF_STMT (lhs);\n \n@@ -875,45 +947,10 @@ record_temporary_equivalences (edge e,\n \t    }\n \t}\n \n-      /* If LHS is an SSA_NAME with a new equivalency then try if\n-         stmts with uses of that LHS that dominate the edge destination\n-\t simplify and allow further equivalences to be recorded.  */\n-      if (lhs && TREE_CODE (lhs) == SSA_NAME)\n-\t{\n-\t  use_operand_p use_p;\n-\t  imm_use_iterator iter;\n-\t  FOR_EACH_IMM_USE_FAST (use_p, iter, lhs)\n-\t    {\n-\t      gimple *use_stmt = USE_STMT (use_p);\n-\n-\t      /* Only bother to record more equivalences for lhs that\n-\t         can be directly used by e->dest.\n-\t\t ???  If the code gets re-organized to a worklist to\n-\t\t catch more indirect opportunities and it is made to\n-\t\t handle PHIs then this should only consider use_stmts\n-\t\t in basic-blocks we have already visited.  */\n-\t      if (e->dest == gimple_bb (use_stmt)\n-\t\t  || !dominated_by_p (CDI_DOMINATORS,\n-\t\t\t\t      e->dest, gimple_bb (use_stmt)))\n-\t\tcontinue;\n-\t      tree lhs2 = gimple_get_lhs (use_stmt);\n-\t      if (lhs2 && TREE_CODE (lhs2) == SSA_NAME)\n-\t\t{\n-\t\t  tree res\n-\t\t    = gimple_fold_stmt_to_constant_1 (use_stmt, dom_valueize,\n-\t\t\t\t\t\t      no_follow_ssa_edges);\n-\t\t  if (res\n-\t\t      && (TREE_CODE (res) == SSA_NAME\n-\t\t\t  || is_gimple_min_invariant (res)))\n-\t\t    record_equality (lhs2, res, const_and_copies);\n-\t\t}\n-\t    }\n-\t}\n-\n-      /* If we have 0 = COND or 1 = COND equivalences, record them\n-\t into our expression hash tables.  */\n-      for (i = 0; edge_info->cond_equivalences.iterate (i, &eq); ++i)\n-\trecord_cond (eq, avail_exprs_stack);\n+      /* Any equivalence found for LHS may result in additional\n+\t equivalences for other uses of LHS that we have already\n+\t processed.  */\n+      back_propagate_equivalences (lhs, e, const_and_copies);\n     }\n }\n \n@@ -1321,8 +1358,6 @@ cprop_into_successor_phis (basic_block bb,\n \t  new_val = SSA_NAME_VALUE (orig_val);\n \t  if (new_val\n \t      && new_val != orig_val\n-\t      && (TREE_CODE (new_val) == SSA_NAME\n-\t\t  || is_gimple_min_invariant (new_val))\n \t      && may_propagate_copy (orig_val, new_val))\n \t    propagate_value (orig_p, new_val);\n \t}"}]}