{"sha": "abdeafa67a8ec7c99830fd5039d38168abba52a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWJkZWFmYTY3YThlYzdjOTk4MzBmZDUwMzlkMzgxNjhhYmJhNTJhOQ==", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2019-08-21T08:30:53Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-08-21T08:30:53Z"}, "message": "[Ada] Add the System.Bitfield_Utils runtime unit\n\n2019-08-21  Bob Duff  <duff@adacore.com>\n\ngcc/ada/\n\n\t* Makefile.rtl (GNATRTL_NONTASKING_OBJS): Add s-bitutil.o and\n\ts-biutin.o.\n\t* exp_ch5.adb (Expand_Assign_Array_Bitfield): New function to\n\tgenerate a call to Copy_Bitfield. This is disabled for now.\n\t(Expand_Assign_Array_Loop_Or_Bitfield): New function to decide\n\twhether to call Expand_Assign_Array_Bitfield.\n\t(Expand_Assign_Array): Call Expand_Assign_Array_Loop_Or_Bitfield\n\tinstead of Expand_Assign_Array_Loop.\n\t* libgnat/s-bitfie.ads, libgnat/s-bituti.adb,\n\tlibgnat/s-bituti.ads: New units.\n\t* rtsfind.ads: Add enum literals for accessing Copy_Bitfield.\n\nFrom-SVN: r274785", "tree": {"sha": "991871518d9927868f87a35320792b8c36f34d67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/991871518d9927868f87a35320792b8c36f34d67"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/abdeafa67a8ec7c99830fd5039d38168abba52a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abdeafa67a8ec7c99830fd5039d38168abba52a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abdeafa67a8ec7c99830fd5039d38168abba52a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abdeafa67a8ec7c99830fd5039d38168abba52a9/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a1fda1e8752ecbf3b109d851e4a7d7d04159170e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1fda1e8752ecbf3b109d851e4a7d7d04159170e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1fda1e8752ecbf3b109d851e4a7d7d04159170e"}], "stats": {"total": 689, "additions": 686, "deletions": 3}, "files": [{"sha": "62a06d6ce8a1d0a76a4325dc329b2dc57836d63a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abdeafa67a8ec7c99830fd5039d38168abba52a9/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abdeafa67a8ec7c99830fd5039d38168abba52a9/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=abdeafa67a8ec7c99830fd5039d38168abba52a9", "patch": "@@ -1,3 +1,17 @@\n+2019-08-21  Bob Duff  <duff@adacore.com>\n+\n+\t* Makefile.rtl (GNATRTL_NONTASKING_OBJS): Add s-bitutil.o and\n+\ts-biutin.o.\n+\t* exp_ch5.adb (Expand_Assign_Array_Bitfield): New function to\n+\tgenerate a call to Copy_Bitfield. This is disabled for now.\n+\t(Expand_Assign_Array_Loop_Or_Bitfield): New function to decide\n+\twhether to call Expand_Assign_Array_Bitfield.\n+\t(Expand_Assign_Array): Call Expand_Assign_Array_Loop_Or_Bitfield\n+\tinstead of Expand_Assign_Array_Loop.\n+\t* libgnat/s-bitfie.ads, libgnat/s-bituti.adb,\n+\tlibgnat/s-bituti.ads: New units.\n+\t* rtsfind.ads: Add enum literals for accessing Copy_Bitfield.\n+\n 2019-08-21  Piotr Trojanek  <trojanek@adacore.com>\n \n \t* bindo-graphs.ads (Iterate_Edges_To_Successors): Fix typo in"}, {"sha": "e5aa6b8eeaccdf31c2b700adf8f2a60af87ec7db", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abdeafa67a8ec7c99830fd5039d38168abba52a9/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abdeafa67a8ec7c99830fd5039d38168abba52a9/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=abdeafa67a8ec7c99830fd5039d38168abba52a9", "patch": "@@ -502,7 +502,9 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-atopri$(objext) \\\n   s-auxdec$(objext) \\\n   s-bignum$(objext) \\\n+  s-bitfie$(objext) \\\n   s-bitops$(objext) \\\n+  s-bituti$(objext) \\\n   s-boarop$(objext) \\\n   s-boustr$(objext) \\\n   s-bytswa$(objext) \\"}, {"sha": "ba0b793132f907a7c8fa7236b238e3a0c63695b1", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 157, "deletions": 3, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abdeafa67a8ec7c99830fd5039d38168abba52a9/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abdeafa67a8ec7c99830fd5039d38168abba52a9/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=abdeafa67a8ec7c99830fd5039d38168abba52a9", "patch": "@@ -114,6 +114,28 @@ package body Exp_Ch5 is\n    --  Auxiliary declarations are inserted before node N using the standard\n    --  Insert_Actions mechanism.\n \n+   function Expand_Assign_Array_Bitfield\n+     (N      : Node_Id;\n+      Larray : Entity_Id;\n+      Rarray : Entity_Id;\n+      L_Type : Entity_Id;\n+      R_Type : Entity_Id;\n+      Rev    : Boolean) return Node_Id;\n+   --  Alternative to Expand_Assign_Array_Loop for packed bitfields. Generates\n+   --  a call to the System.Bitfields.Copy_Bitfield, which is more efficient\n+   --  than copying component-by-component.\n+\n+   function Expand_Assign_Array_Loop_Or_Bitfield\n+     (N      : Node_Id;\n+      Larray : Entity_Id;\n+      Rarray : Entity_Id;\n+      L_Type : Entity_Id;\n+      R_Type : Entity_Id;\n+      Ndim   : Pos;\n+      Rev    : Boolean) return Node_Id;\n+   --  Calls either Expand_Assign_Array_Loop or Expand_Assign_Array_Bitfield as\n+   --  appropriate.\n+\n    procedure Expand_Assign_Record (N : Node_Id);\n    --  N is an assignment of an untagged record value. This routine handles\n    --  the case where the assignment must be made component by component,\n@@ -314,6 +336,10 @@ package body Exp_Ch5 is\n \n       Crep : constant Boolean := Change_Of_Representation (N);\n \n+      pragma Assert\n+        (Crep\n+          or else Is_Bit_Packed_Array (L_Type) = Is_Bit_Packed_Array (R_Type));\n+\n       Larray  : Node_Id;\n       Rarray  : Node_Id;\n \n@@ -939,7 +965,7 @@ package body Exp_Ch5 is\n \n             else\n                Rewrite (N,\n-                 Expand_Assign_Array_Loop\n+                 Expand_Assign_Array_Loop_Or_Bitfield\n                    (N, Larray, Rarray, L_Type, R_Type, Ndim,\n                     Rev => not Forwards_OK (N)));\n             end if;\n@@ -1092,12 +1118,12 @@ package body Exp_Ch5 is\n                    Condition => Condition,\n \n                    Then_Statements => New_List (\n-                     Expand_Assign_Array_Loop\n+                     Expand_Assign_Array_Loop_Or_Bitfield\n                       (N, Larray, Rarray, L_Type, R_Type, Ndim,\n                        Rev => False)),\n \n                    Else_Statements => New_List (\n-                     Expand_Assign_Array_Loop\n+                     Expand_Assign_Array_Loop_Or_Bitfield\n                       (N, Larray, Rarray, L_Type, R_Type, Ndim,\n                        Rev => True))));\n             end if;\n@@ -1320,6 +1346,134 @@ package body Exp_Ch5 is\n       return Assign;\n    end Expand_Assign_Array_Loop;\n \n+   ----------------------------------\n+   -- Expand_Assign_Array_Bitfield --\n+   ----------------------------------\n+\n+   function Expand_Assign_Array_Bitfield\n+     (N      : Node_Id;\n+      Larray : Entity_Id;\n+      Rarray : Entity_Id;\n+      L_Type : Entity_Id;\n+      R_Type : Entity_Id;\n+      Rev    : Boolean) return Node_Id\n+   is\n+      pragma Assert (not Rev);\n+      --  Reverse copying is not yet supported by Copy_Bitfield.\n+\n+      pragma Assert (not Change_Of_Representation (N));\n+      --  This won't work, for example, to copy a packed array to an unpacked\n+      --  array.\n+\n+      Loc  : constant Source_Ptr := Sloc (N);\n+\n+      L_Index_Typ : constant Node_Id := Etype (First_Index (L_Type));\n+      R_Index_Typ : constant Node_Id := Etype (First_Index (R_Type));\n+      Left_Lo  : constant Node_Id := Type_Low_Bound  (L_Index_Typ);\n+      Right_Lo : constant Node_Id := Type_Low_Bound  (R_Index_Typ);\n+\n+      L_Addr : constant Node_Id :=\n+        Make_Attribute_Reference (Loc,\n+          Prefix =>\n+            Make_Indexed_Component (Loc,\n+              Prefix =>\n+                Duplicate_Subexpr (Larray, True),\n+              Expressions => New_List (New_Copy_Tree (Left_Lo))),\n+          Attribute_Name => Name_Address);\n+\n+      L_Bit : constant Node_Id :=\n+        Make_Attribute_Reference (Loc,\n+          Prefix =>\n+            Make_Indexed_Component (Loc,\n+              Prefix =>\n+                Duplicate_Subexpr (Larray, True),\n+              Expressions => New_List (New_Copy_Tree (Left_Lo))),\n+          Attribute_Name => Name_Bit);\n+\n+      R_Addr : constant Node_Id :=\n+        Make_Attribute_Reference (Loc,\n+          Prefix =>\n+            Make_Indexed_Component (Loc,\n+              Prefix =>\n+                Duplicate_Subexpr (Rarray, True),\n+              Expressions => New_List (New_Copy_Tree (Right_Lo))),\n+          Attribute_Name => Name_Address);\n+\n+      R_Bit : constant Node_Id :=\n+        Make_Attribute_Reference (Loc,\n+          Prefix =>\n+            Make_Indexed_Component (Loc,\n+              Prefix =>\n+                Duplicate_Subexpr (Rarray, True),\n+              Expressions => New_List (New_Copy_Tree (Right_Lo))),\n+          Attribute_Name => Name_Bit);\n+\n+      --  Compute the Size of the bitfield. ???We can't use Size here, because\n+      --  it doesn't work properly for slices of packed arrays, so we compute\n+      --  the L'Size as L'Length*L'Component_Size.\n+      --\n+      --  Note that the length check has already been done, so we can use the\n+      --  size of either L or R.\n+\n+      Size : constant Node_Id :=\n+        Make_Op_Multiply (Loc,\n+          Make_Attribute_Reference (Loc,\n+            Prefix =>\n+              Duplicate_Subexpr (Name (N), True),\n+            Attribute_Name => Name_Length),\n+          Make_Attribute_Reference (Loc,\n+            Prefix =>\n+              Duplicate_Subexpr (Name (N), True),\n+            Attribute_Name => Name_Component_Size));\n+\n+   begin\n+      return Make_Procedure_Call_Statement (Loc,\n+        Name => New_Occurrence_Of (RTE (RE_Copy_Bitfield), Loc),\n+        Parameter_Associations => New_List (\n+          R_Addr, R_Bit, L_Addr, L_Bit, Size));\n+   end Expand_Assign_Array_Bitfield;\n+\n+   ------------------------------------------\n+   -- Expand_Assign_Array_Loop_Or_Bitfield --\n+   ------------------------------------------\n+\n+   function Expand_Assign_Array_Loop_Or_Bitfield\n+     (N      : Node_Id;\n+      Larray : Entity_Id;\n+      Rarray : Entity_Id;\n+      L_Type : Entity_Id;\n+      R_Type : Entity_Id;\n+      Ndim   : Pos;\n+      Rev    : Boolean) return Node_Id\n+   is\n+      Slices : constant Boolean :=\n+        Nkind (Name (N)) = N_Slice or else Nkind (Expression (N)) = N_Slice;\n+   begin\n+      --  Determine whether Copy_Bitfield is appropriate (will work, and will\n+      --  be more efficient than component-by-component copy). Copy_Bitfield\n+      --  doesn't work for reversed storage orders. It is efficient only for\n+      --  slices of bit-packed arrays.\n+\n+      --  Note that Expand_Assign_Array_Bitfield is disabled for now\n+\n+      if False -- ???\n+        and then Is_Bit_Packed_Array (L_Type)\n+        and then Is_Bit_Packed_Array (R_Type)\n+        and then RTE_Available (RE_Copy_Bitfield)\n+        and then not Reverse_Storage_Order (L_Type)\n+        and then not Reverse_Storage_Order (R_Type)\n+        and then Ndim = 1\n+        and then not Rev\n+        and then Slices\n+      then\n+         return Expand_Assign_Array_Bitfield\n+           (N, Larray, Rarray, L_Type, R_Type, Rev);\n+      else\n+         return Expand_Assign_Array_Loop\n+           (N, Larray, Rarray, L_Type, R_Type, Ndim, Rev);\n+      end if;\n+   end Expand_Assign_Array_Loop_Or_Bitfield;\n+\n    --------------------------\n    -- Expand_Assign_Record --\n    --------------------------"}, {"sha": "1b62b9d107753120675aeb02103e8b23f47053c2", "filename": "gcc/ada/libgnat/s-bitfie.ads", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abdeafa67a8ec7c99830fd5039d38168abba52a9/gcc%2Fada%2Flibgnat%2Fs-bitfie.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abdeafa67a8ec7c99830fd5039d38168abba52a9/gcc%2Fada%2Flibgnat%2Fs-bitfie.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-bitfie.ads?ref=abdeafa67a8ec7c99830fd5039d38168abba52a9", "patch": "@@ -0,0 +1,56 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                 S Y S T E M . B I T F I E L D _ U T I L S                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--               Copyright (C) 2019, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Bitfield_Utils;\n+\n+package System.Bitfields is\n+\n+   --  Instances of the generic package in System.Bitfield_Utils. So far\n+   --  we have just one, which defaults to the natural endianness of the\n+   --  machine. We might someday want to support Scalar_Storage_Order.\n+\n+   Val_Bytes : constant := 4;\n+   Val_Bits : constant := Val_Bytes * System.Storage_Unit;\n+   type Val_2 is mod 2**(Val_Bits * 2) with Alignment => Val_Bytes;\n+   pragma Provide_Shift_Operators (Val_2);\n+   type Val is mod 2**Val_Bits with Alignment => Val_Bytes;\n+\n+   package Utils is new System.Bitfield_Utils.G (Val, Val_2);\n+\n+   procedure Copy_Bitfield\n+     (Src_Address  : Address;\n+      Src_Offset   : Utils.Bit_Offset_In_Byte;\n+      Dest_Address : Address;\n+      Dest_Offset  : Utils.Bit_Offset_In_Byte;\n+      Size         : Utils.Bit_Size)\n+     renames Utils.Copy_Bitfield;\n+\n+end System.Bitfields;"}, {"sha": "78e391b9626a226d164d72a115ca9f2fa1a59adc", "filename": "gcc/ada/libgnat/s-bituti.adb", "status": "added", "additions": 320, "deletions": 0, "changes": 320, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abdeafa67a8ec7c99830fd5039d38168abba52a9/gcc%2Fada%2Flibgnat%2Fs-bituti.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abdeafa67a8ec7c99830fd5039d38168abba52a9/gcc%2Fada%2Flibgnat%2Fs-bituti.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-bituti.adb?ref=abdeafa67a8ec7c99830fd5039d38168abba52a9", "patch": "@@ -0,0 +1,320 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                 S Y S T E M . B I T F I E L D _ U T I L S                --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--               Copyright (C) 2019, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body System.Bitfield_Utils is\n+\n+   --  ???\n+   --\n+   --  This code does not yet work for overlapping bit fields. We need to copy\n+   --  backwards in some cases (i.e. from higher to lower bit addresses).\n+   --  Alternatively, we could avoid calling this if Forwards_OK is False.\n+   --\n+   --  ???\n+\n+   package body G is\n+\n+      Val_Bytes : constant Address := Address (Val'Size / Storage_Unit);\n+\n+      --  Get_Bitfield and Set_Bitfield are helper functions that get/set small\n+      --  bit fields -- the value fits in Val, and the bit field is placed\n+      --  starting at some offset within the first half of a Val_2.\n+      --  Copy_Bitfield, on the other hand, supports arbitrarily large bit\n+      --  fields. All operations require bit offsets to point within the first\n+      --  Val pointed to by the address.\n+\n+      function Get_Bitfield\n+        (Src : Val_2; Src_Offset : Bit_Offset; Size : Small_Size)\n+         return Val;\n+      --  Returns the bit field in Src starting at Src_Offset, of the given\n+      --  Size. If Size < Small_Size'Last, then high order bits are zero.\n+\n+      function Get_Full_Bitfield\n+        (Src : Val_2; Src_Offset : Bit_Offset) return Val;\n+      --  Same as Get_Bitfield, except the Size is hardwired to the maximum\n+      --  allowed.\n+\n+      function Set_Bitfield\n+        (Src_Value : Val;\n+         Dest : Val_2;\n+         Dest_Offset : Bit_Offset;\n+         Size : Small_Size)\n+        return Val_2;\n+      --  The bit field in Dest starting at Dest_Offset, of the given Size, is\n+      --  set to Src_Value. Src_Value must have high order bits (Size and\n+      --  above) zero. The result is returned as the function result.\n+\n+      function Get_Bitfield\n+        (Src : Val_2; Src_Offset : Bit_Offset; Size : Small_Size)\n+         return Val\n+      is\n+         L_Shift_Amount : constant Natural :=\n+           (case Endian is\n+              when Little => Val_2'Size - (Src_Offset + Size),\n+              when Big => Src_Offset);\n+         Temp1 : constant Val_2 :=\n+           Shift_Left (Src, L_Shift_Amount);\n+         Temp2 : constant Val_2 :=\n+           Shift_Right (Temp1, Val_2'Size - Size);\n+      begin\n+         return Val (Temp2);\n+      end Get_Bitfield;\n+\n+      function Get_Full_Bitfield\n+        (Src : Val_2; Src_Offset : Bit_Offset) return Val is\n+      begin\n+         return Get_Bitfield (Src, Src_Offset, Size => Val'Size);\n+      end Get_Full_Bitfield;\n+\n+      function Set_Bitfield\n+        (Src_Value : Val;\n+         Dest : Val_2;\n+         Dest_Offset : Bit_Offset;\n+         Size : Small_Size)\n+        return Val_2\n+      is\n+         pragma Assert (Size = Val'Size or else Src_Value < 2**Size);\n+         L_Shift_Amount : constant Natural :=\n+           (case Endian is\n+              when Little => Dest_Offset,\n+              when Big => Val_2'Size - (Dest_Offset + Size));\n+         Mask : constant Val_2 :=\n+           Shift_Left (Shift_Left (1, Size) - 1, L_Shift_Amount);\n+         Temp1 : constant Val_2 := Dest and not Mask;\n+         Temp2 : constant Val_2 :=\n+           Shift_Left (Val_2 (Src_Value), L_Shift_Amount);\n+         Result : constant Val_2 := Temp1 or Temp2;\n+      begin\n+         return Result;\n+      end Set_Bitfield;\n+\n+      procedure Copy_Small_Bitfield\n+        (Src_Address  : Address;\n+         Src_Offset   : Bit_Offset;\n+         Dest_Address : Address;\n+         Dest_Offset  : Bit_Offset;\n+         Size         : Small_Size);\n+      --  Copy_Bitfield in the case where Size <= Val'Size.\n+      --  The Address values must be aligned as for Val and Val_2.\n+      --  This works for overlapping bit fields.\n+\n+      procedure Copy_Large_Bitfield\n+        (Src_Address  : Address;\n+         Src_Offset   : Bit_Offset;\n+         Dest_Address : Address;\n+         Dest_Offset  : Bit_Offset;\n+         Size         : Bit_Size);\n+      --  Copy_Bitfield in the case where Size > Val'Size.\n+      --  The Address values must be aligned as for Val and Val_2.\n+      --  This works for overlapping bit fields only if the source\n+      --  bit address is greater than or equal to the destination\n+      --  bit address, because it copies forward (from lower to higher\n+      --  bit addresses).\n+\n+      procedure Copy_Small_Bitfield\n+        (Src_Address  : Address;\n+         Src_Offset   : Bit_Offset;\n+         Dest_Address : Address;\n+         Dest_Offset  : Bit_Offset;\n+         Size         : Small_Size)\n+      is\n+         Src : constant Val_2 with Import, Address => Src_Address;\n+         V : constant Val := Get_Bitfield (Src, Src_Offset, Size);\n+         Dest : Val_2 with Import, Address => Dest_Address;\n+      begin\n+         Dest := Set_Bitfield (V, Dest, Dest_Offset, Size);\n+      end Copy_Small_Bitfield;\n+\n+      --  Copy_Large_Bitfield does the main work. Copying aligned Vals is more\n+      --  efficient than fiddling with shifting and whatnot. But we can't align\n+      --  both source and destination. We choose to align the destination,\n+      --  because that's more efficient -- Set_Bitfield needs to read, then\n+      --  modify, then write, whereas Get_Bitfield does not.\n+      --\n+      --  So the method is:\n+      --\n+      --      Step 1:\n+      --      If the destination is not already aligned, copy Initial_Size\n+      --      bits, and increment the bit addresses. Initial_Size is chosen to\n+      --      be the smallest size that will cause the destination bit address\n+      --      to be aligned (i.e. have zero bit offset from the already-aligned\n+      --      Address). Get_Bitfield and Set_Bitfield are used here.\n+      --\n+      --      Step 2:\n+      --      Loop, copying Vals. Get_Full_Bitfield is used to fetch a\n+      --      Val-sized bit field, but Set_Bitfield is not needed -- we can set\n+      --      the aligned Val with an array indexing.\n+      --\n+      --      Step 3:\n+      --      Copy remaining smaller-than-Val bits, if any\n+\n+      procedure Copy_Large_Bitfield\n+        (Src_Address  : Address;\n+         Src_Offset   : Bit_Offset;\n+         Dest_Address : Address;\n+         Dest_Offset  : Bit_Offset;\n+         Size         : Bit_Size)\n+      is\n+         Sz : Bit_Size := Size;\n+         S_Addr : Address := Src_Address;\n+         S_Off : Bit_Offset := Src_Offset;\n+         D_Addr : Address := Dest_Address;\n+         D_Off : Bit_Offset := Dest_Offset;\n+      begin\n+         if S_Addr < D_Addr or else (S_Addr = D_Addr and then S_Off < D_Off)\n+         then\n+            --  Here, the source bit address is less than the destination bit\n+            --  address. Assert that there is no overlap.\n+\n+            declare\n+               Temp_Off : constant Bit_Offset'Base := S_Off + Size;\n+               After_S_Addr : constant Address :=\n+                 S_Addr + Address (Temp_Off / Storage_Unit);\n+               After_S_Off : constant Bit_Offset_In_Byte :=\n+                 Temp_Off mod Storage_Unit;\n+               --  (After_S_Addr, After_S_Off) is the bit address of the bit\n+               --  just after the source bit field. Assert that it's less than\n+               --  or equal to the destination bit address.\n+               Overlap_OK : constant Boolean :=\n+                 After_S_Addr < D_Addr\n+                   or else\n+                 (After_S_Addr = D_Addr and then After_S_Off <= D_Off);\n+            begin\n+               pragma Assert (Overlap_OK);\n+            end;\n+         end if;\n+\n+         if D_Off /= 0 then\n+            --  Step 1:\n+\n+            declare\n+               Initial_Size : constant Small_Size := Val'Size - D_Off;\n+               Initial_Val_2 : constant Val_2 with Import, Address => S_Addr;\n+               Initial_Val : constant Val :=\n+                 Get_Bitfield (Initial_Val_2, S_Off, Initial_Size);\n+               Initial_Dest : Val_2 with Import, Address => D_Addr;\n+            begin\n+               Initial_Dest := Set_Bitfield\n+                 (Initial_Val, Initial_Dest, D_Off, Initial_Size);\n+\n+               Sz := Sz - Initial_Size;\n+               declare\n+                  New_S_Off : constant Bit_Offset'Base := S_Off + Initial_Size;\n+               begin\n+                  if New_S_Off > Bit_Offset'Last then\n+                     S_Addr := S_Addr + Val_Bytes;\n+                     S_Off := New_S_Off - Small_Size'Last;\n+                  else\n+                     S_Off := New_S_Off;\n+                  end if;\n+               end;\n+               D_Addr := D_Addr + Val_Bytes;\n+               pragma Assert (D_Off + Initial_Size = Val'Size);\n+               D_Off := 0;\n+            end;\n+         end if;\n+\n+         --  Step 2:\n+\n+         declare\n+            Dest_Arr : Val_Array (1 .. Sz / Val'Size) with Import,\n+              Address => D_Addr;\n+         begin\n+            for Dest_Comp of Dest_Arr loop\n+               declare\n+                  pragma Warnings (Off);\n+                  pragma Assert (Dest_Comp in Val);\n+                  pragma Warnings (On);\n+                  pragma Assert (Dest_Comp'Valid);\n+                  Src_V_2 : constant Val_2 with Import, Address => S_Addr;\n+                  Full_V : constant Val := Get_Full_Bitfield (Src_V_2, S_Off);\n+               begin\n+                  Dest_Comp := Full_V;\n+                  S_Addr := S_Addr + Val_Bytes;\n+                  --  S_Off remains the same\n+               end;\n+            end loop;\n+\n+            if Sz mod Val'Size /= 0 then\n+               --  Step 3:\n+\n+               declare\n+                  Final_Val_2 : constant Val_2 with Import, Address => S_Addr;\n+                  Final_Val : constant Val :=\n+                    Get_Bitfield (Final_Val_2, S_Off, Sz mod Val'Size);\n+                  Final_Dest : Val_2  with Import,\n+                    Address => D_Addr + Dest_Arr'Length * Val_Bytes;\n+               begin\n+                  Final_Dest := Set_Bitfield\n+                    (Final_Val, Final_Dest, 0, Sz mod Val'Size);\n+               end;\n+            end if;\n+         end;\n+      end Copy_Large_Bitfield;\n+\n+      procedure Copy_Bitfield\n+        (Src_Address  : Address;\n+         Src_Offset   : Bit_Offset_In_Byte;\n+         Dest_Address : Address;\n+         Dest_Offset  : Bit_Offset_In_Byte;\n+         Size         : Bit_Size)\n+      is\n+         --  Align the Address values as for Val and Val_2, and adjust the\n+         --  Bit_Offsets accordingly.\n+\n+         Src_Adjust     : constant Address := Src_Address mod Val_Bytes;\n+         Al_Src_Address : constant Address := Src_Address - Src_Adjust;\n+         Al_Src_Offset  : constant Bit_Offset :=\n+           Src_Offset + Bit_Offset (Src_Adjust * Storage_Unit);\n+\n+         Dest_Adjust     : constant Address := Dest_Address mod Val_Bytes;\n+         Al_Dest_Address : constant Address := Dest_Address - Dest_Adjust;\n+         Al_Dest_Offset  : constant Bit_Offset :=\n+           Dest_Offset + Bit_Offset (Dest_Adjust * Storage_Unit);\n+\n+         pragma Assert (Al_Src_Address mod Val'Alignment = 0);\n+         pragma Assert (Al_Dest_Address mod Val'Alignment = 0);\n+      begin\n+         if Size in Small_Size then\n+            Copy_Small_Bitfield\n+              (Al_Src_Address, Al_Src_Offset,\n+               Al_Dest_Address, Al_Dest_Offset,\n+               Size);\n+         else\n+            Copy_Large_Bitfield\n+              (Al_Src_Address, Al_Src_Offset,\n+               Al_Dest_Address, Al_Dest_Offset,\n+               Size);\n+         end if;\n+      end Copy_Bitfield;\n+\n+   end G;\n+\n+end System.Bitfield_Utils;"}, {"sha": "1e446c142b253e76aa07e45023df7d894ad7132f", "filename": "gcc/ada/libgnat/s-bituti.ads", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abdeafa67a8ec7c99830fd5039d38168abba52a9/gcc%2Fada%2Flibgnat%2Fs-bituti.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abdeafa67a8ec7c99830fd5039d38168abba52a9/gcc%2Fada%2Flibgnat%2Fs-bituti.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-bituti.ads?ref=abdeafa67a8ec7c99830fd5039d38168abba52a9", "patch": "@@ -0,0 +1,132 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                 S Y S T E M . B I T F I E L D _ U T I L S                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--               Copyright (C) 2019, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package System.Bitfield_Utils is\n+\n+   --  This package provides a procedure for copying arbitrarily large and\n+   --  arbitrarily bit-aligned bit fields.\n+\n+   --  Type Val is used to represent small bit fields. Val_2 represents a\n+   --  contiguous pair of Vals. Val_2'Alignment is half of its size in bytes,\n+   --  which is likely not the natural alignment. This is done to ensure that\n+   --  any bit field that fits in a Val can fit in an aligned Val_2, starting\n+   --  somewhere in the first half, and possibly crossing over into the second\n+   --  half. This allows us to isolate a Val value by shifting and masking the\n+   --  Val_2.\n+   --\n+   --  Val can be 8, 16, or 32 bits; larger values are more efficient. It can't\n+   --  be 64 bits, because we need Val_2 to be a double-wide shiftable type,\n+   --  and 128 bits is not supported. Instantiating with an 8-bit Val is useful\n+   --  for testing and debugging; 32 bits should be used for production.\n+   --\n+   --  We use modular types here, not because we want modular arithmetic, but\n+   --  so we can do shifting and masking. The actual for Val_2 should have\n+   --  pragma Provide_Shift_Operators, so that the Shift_Left and Shift_Right\n+   --  intrinsics can be passed in. It is impossible to put that pragma on a\n+   --  generic formal, or on a type derived from a generic formal, so they have\n+   --  to be passed in.\n+   --\n+   --  Endian indicates whether we're on little-endian or big-endian machine.\n+\n+   pragma Elaborate_Body;\n+\n+   Little : constant Bit_Order := Low_Order_First;\n+   Big : constant Bit_Order := High_Order_First;\n+\n+   generic\n+      type Val is mod <>;\n+      type Val_2 is mod <>;\n+\n+     with function Shift_Left\n+       (Value  : Val_2;\n+        Amount : Natural) return Val_2 is <>;\n+\n+     with function Shift_Right\n+       (Value  : Val_2;\n+        Amount : Natural) return Val_2 is <>;\n+\n+      Endian : Bit_Order := Default_Bit_Order;\n+\n+   package G is\n+      --  Assert that Val has one of the allowed sizes, and that Val_2 is twice\n+      --  that.\n+\n+      pragma Assert (Val'Size in 8 | 16 | 32);\n+      pragma Assert (Val_2'Size = Val'Size * 2);\n+\n+      --  Assert that both are aligned the same, to the size in bytes of Val\n+      --  (not Val_2).\n+\n+      pragma Assert (Val'Alignment = Val'Size / Storage_Unit);\n+      pragma Assert (Val_2'Alignment = Val'Alignment);\n+\n+      type Val_Array is array (Positive range <>) of Val;\n+\n+      --  It might make more sense to have:\n+      --    subtype Val is Val_2 range 0 .. 2**Val'Size - 1;\n+      --  But then GNAT gets the component size of Val_Array wrong.\n+\n+      pragma Assert (Val_Array'Alignment = Val'Alignment);\n+      pragma Assert (Val_Array'Component_Size = Val'Size);\n+\n+      subtype Bit_Size is Natural; -- Size in bits of a bit field\n+      subtype Small_Size is Bit_Size range 0 .. Val'Size;\n+      --  Size of a small one\n+      subtype Bit_Offset is Small_Size range 0 .. Val'Size - 1;\n+      --  Starting offset\n+      subtype Bit_Offset_In_Byte is Bit_Offset range 0 .. Storage_Unit - 1;\n+\n+      procedure Copy_Bitfield\n+        (Src_Address  : Address;\n+         Src_Offset   : Bit_Offset_In_Byte;\n+         Dest_Address : Address;\n+         Dest_Offset  : Bit_Offset_In_Byte;\n+         Size         : Bit_Size);\n+      --  An Address and a Bit_Offset together form a \"bit address\". This\n+      --  copies the source bit field to the destination. Size is the size in\n+      --  bits of the bit field. The bit fields can be arbitrarily large, but\n+      --  the starting offsets must be within the first byte that the Addresses\n+      --  point to. The Address values need not be aligned.\n+      --\n+      --  For example, a slice assignment of a packed bit field:\n+      --\n+      --     D (D_First .. D_Last) := S (S_First .. S_Last);\n+      --\n+      --  can be implemented using:\n+      --\n+      --     Copy_Bitfield\n+      --       (S (S_First)'Address, S (S_First)'Bit,\n+      --        D (D_First)'Address, D (D_First)'Bit,\n+      --        Size);\n+\n+   end G;\n+\n+end System.Bitfield_Utils;"}, {"sha": "9d5a86cdb72b42561e2425f0e4bcdb98e0aae5c4", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abdeafa67a8ec7c99830fd5039d38168abba52a9/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abdeafa67a8ec7c99830fd5039d38168abba52a9/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=abdeafa67a8ec7c99830fd5039d38168abba52a9", "patch": "@@ -220,6 +220,7 @@ package Rtsfind is\n       System_Atomic_Primitives,\n       System_Aux_DEC,\n       System_Bignums,\n+      System_Bitfields,\n       System_Bit_Ops,\n       System_Boolean_Array_Operations,\n       System_Byte_Swapping,\n@@ -809,6 +810,8 @@ package Rtsfind is\n      RE_To_Bignum,                       -- System.Bignums\n      RE_From_Bignum,                     -- System.Bignums\n \n+     RE_Copy_Bitfield,                   -- System.Bitfields\n+\n      RE_Bit_And,                         -- System.Bit_Ops\n      RE_Bit_Eq,                          -- System.Bit_Ops\n      RE_Bit_Not,                         -- System.Bit_Ops\n@@ -2051,6 +2054,8 @@ package Rtsfind is\n      RE_To_Bignum                        => System_Bignums,\n      RE_From_Bignum                      => System_Bignums,\n \n+     RE_Copy_Bitfield                    => System_Bitfields,\n+\n      RE_Bit_And                          => System_Bit_Ops,\n      RE_Bit_Eq                           => System_Bit_Ops,\n      RE_Bit_Not                          => System_Bit_Ops,"}]}