{"sha": "00dcee0c2b28fcca272fe3e9ad67782022612671", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDBkY2VlMGMyYjI4ZmNjYTI3MmZlM2U5YWQ2Nzc4MjAyMjYxMjY3MQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@bigpond.net.au", "date": "2005-12-16T09:46:22Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2005-12-16T09:46:22Z"}, "message": "re PR driver/20425 (-print-search-dirs doesn't honor mutil-os/multilib settings)\n\n\tPR driver/20425\n\t* gcc.c (for_each_path): New function.\n\t(add_to_obstack, file_at_path): New functions.\n\t(struct file_at_path_info, struct add_to_obstack_info): New.\n\t(build_search_list): Rewrite using for_each_path.  Constify struct\n\tpath_prefix pointer.  Add do_multi param.  Adjust all callers.\n\t(find_a_file): Similarly, but just change existing param to bool.\n\t(putenv_from_prefixes): Add do_multi param, make \"paths\" const.\n\t(do_spec_path): Delete.\n\t(struct spec_path_info): New.\n\t(spec_path): New function.\n\t(do_spec_1): Use for_each_path for %D and %I.\n\t(find_file): Adjust for find_a_file changes.\n\t(main): Search multilibs for specs.  Print multilib lib path for\n\t-print-search-dirs.  Likewise add multilibs to LIBRARY_PATH_ENV.\n\t(read_specs): Search multilibs for %include and %include_noerr.\n\t(is_directory): Remove second string param.  Change last param\n\tto a bool.  Don't use concat.  Remove SMALL_ARG_MAX test, always\n\tcheck path is a dir.  Update all callers.\n\t* doc/hostconfig.texi (SMALL_ARG_MAX): Remove mention.\n\t* system.h (SMALL_ARG_MAX): Poison.\n\t* config.gcc: Don't define SMALL_ARG_MAX.\n\t* config.host: Likewise.\n\t* config.build: Likewise.\n\nFrom-SVN: r108635", "tree": {"sha": "64e99a1a4a1a816c816ed2e0920f6cb911257f1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/64e99a1a4a1a816c816ed2e0920f6cb911257f1a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00dcee0c2b28fcca272fe3e9ad67782022612671", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00dcee0c2b28fcca272fe3e9ad67782022612671", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00dcee0c2b28fcca272fe3e9ad67782022612671", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00dcee0c2b28fcca272fe3e9ad67782022612671/comments", "author": null, "committer": null, "parents": [{"sha": "bd1ef757767f6d9e4b8ba3dfdaf38e89fd282c52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd1ef757767f6d9e4b8ba3dfdaf38e89fd282c52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd1ef757767f6d9e4b8ba3dfdaf38e89fd282c52"}], "stats": {"total": 715, "additions": 376, "deletions": 339}, "files": [{"sha": "f8d5db8025a6d91b40cdfb6a710d3992be7af9e2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00dcee0c2b28fcca272fe3e9ad67782022612671/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00dcee0c2b28fcca272fe3e9ad67782022612671/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=00dcee0c2b28fcca272fe3e9ad67782022612671", "patch": "@@ -1,3 +1,30 @@\n+2005-12-16  Alan Modra  <amodra@bigpond.net.au>\n+\n+\tPR driver/20425\n+\t* gcc.c (for_each_path): New function.\n+\t(add_to_obstack, file_at_path): New functions.\n+\t(struct file_at_path_info, struct add_to_obstack_info): New.\n+\t(build_search_list): Rewrite using for_each_path.  Constify struct\n+\tpath_prefix pointer.  Add do_multi param.  Adjust all callers.\n+\t(find_a_file): Similarly, but just change existing param to bool.\n+\t(putenv_from_prefixes): Add do_multi param, make \"paths\" const.\n+\t(do_spec_path): Delete.\n+\t(struct spec_path_info): New.\n+\t(spec_path): New function.\n+\t(do_spec_1): Use for_each_path for %D and %I.\n+\t(find_file): Adjust for find_a_file changes.\n+\t(main): Search multilibs for specs.  Print multilib lib path for\n+\t-print-search-dirs.  Likewise add multilibs to LIBRARY_PATH_ENV.\n+\t(read_specs): Search multilibs for %include and %include_noerr.\n+\t(is_directory): Remove second string param.  Change last param\n+\tto a bool.  Don't use concat.  Remove SMALL_ARG_MAX test, always\n+\tcheck path is a dir.  Update all callers.\n+\t* doc/hostconfig.texi (SMALL_ARG_MAX): Remove mention.\n+\t* system.h (SMALL_ARG_MAX): Poison.\n+\t* config.gcc: Don't define SMALL_ARG_MAX.\n+\t* config.host: Likewise.\n+\t* config.build: Likewise.\n+\n 2005-12-16  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* combine.c (combine_simplify_rtx <case NOT, NEG, TRUNCATE,"}, {"sha": "4a8f409e4319316bd653a54f7c370f8b8bcda861", "filename": "gcc/config.build", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00dcee0c2b28fcca272fe3e9ad67782022612671/gcc%2Fconfig.build", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00dcee0c2b28fcca272fe3e9ad67782022612671/gcc%2Fconfig.build", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.build?ref=00dcee0c2b28fcca272fe3e9ad67782022612671", "patch": "@@ -90,15 +90,10 @@ case $build in\n     build_install_headers_dir=install-headers-cpio\n     ;;\n   i[34567]86-sequent-ptx4* | i[34567]86-sequent-sysv4* )\n-    build_xm_defines=\"SMALL_ARG_MAX\"\n     build_install_headers_dir=install-headers-cpio\n     ;;\n-  i[34567]86-*-solaris2*)\n-    build_xm_defines=\"SMALL_ARG_MAX\"\n-    ;;\n   i[34567]86-*-sysv4*) \n     # Intel x86 running system V r4\n-    build_xm_defines=\"SMALL_ARG_MAX\"\n     build_install_headers_dir=install-headers-cpio\n     ;;\n   i[34567]86-*-udk*) "}, {"sha": "e443dd0023f0dc608d51a6697cdb8758df659f68", "filename": "gcc/config.gcc", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00dcee0c2b28fcca272fe3e9ad67782022612671/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00dcee0c2b28fcca272fe3e9ad67782022612671/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=00dcee0c2b28fcca272fe3e9ad67782022612671", "patch": "@@ -984,7 +984,6 @@ i[34567]86-sequent-ptx4* | i[34567]86-sequent-sysv4*)\n \tthen\n \t\ttm_file=\"${tm_file} usegas.h\"\n \tfi\n-\txm_defines=\"SMALL_ARG_MAX\"\n \ttm_file=\"${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h ptx4.h i386/ptx4-i.h\"\n \ttmake_file=t-svr4\n \textra_parts=\"crtbegin.o crtend.o\"\n@@ -1115,7 +1114,6 @@ i[34567]86-*-sco3.2v5*)\t# 80386 running SCO Open Server 5\n \tuse_fixproto=yes\n \t;;\n i[34567]86-*-solaris2*)\n-\txm_defines=\"SMALL_ARG_MAX\"\n \ttm_file=\"${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h svr4.h i386/sysv4.h sol2.h\"\n \tcase ${target} in\n \t*-*-solaris2.[0-6] | *-*-solaris2.[0-6].*)\n@@ -1182,7 +1180,6 @@ i[34567]86-*-sysv5*)           # Intel x86 on System V Release 5\n \tuse_fixproto=yes\n        ;;\n i[34567]86-*-sysv4*)\t\t# Intel 80386's running system V.4\n-\txm_defines=\"SMALL_ARG_MAX\"\n \ttm_file=\"${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h svr4.h i386/sysv4.h i386/sysv4-cpp.h\"\n \tif test x$stabs = xyes\n \tthen"}, {"sha": "8d227dd68f6f89561a682a4e88fe421d21c0881e", "filename": "gcc/config.host", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00dcee0c2b28fcca272fe3e9ad67782022612671/gcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00dcee0c2b28fcca272fe3e9ad67782022612671/gcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.host?ref=00dcee0c2b28fcca272fe3e9ad67782022612671", "patch": "@@ -132,17 +132,10 @@ case ${host} in\n   i370-*-opened* | i370-*-mvs* ) # IBM 360/370/390 Architecture\n     host_xm_defines='FATAL_EXIT_CODE=12'\n     ;;\n-  i[34567]86-sequent-ptx4*)\n-    host_xm_defines=\"SMALL_ARG_MAX\"\n-    ;;\n   i[34567]86-*-solaris2*)\n-    host_xm_defines=\"SMALL_ARG_MAX\"\n     out_host_hook_obj=host-solaris.o\n     host_xmake_file=x-solaris\n     ;;\n-  i[34567]86-*-sysv4*) # Intel 80386's running System V Release 4\n-    host_xm_defines=\"SMALL_ARG_MAX\"\n-    ;;\n   i[34567]86-pc-msdosdjgpp*)\n     host_xm_file=i386/xm-djgpp.h\n     host_exeext=.exe"}, {"sha": "1c97ac278e724b4ffa7562ff2bf69c2d962f4e99", "filename": "gcc/doc/hostconfig.texi", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00dcee0c2b28fcca272fe3e9ad67782022612671/gcc%2Fdoc%2Fhostconfig.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00dcee0c2b28fcca272fe3e9ad67782022612671/gcc%2Fdoc%2Fhostconfig.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fhostconfig.texi?ref=00dcee0c2b28fcca272fe3e9ad67782022612671", "patch": "@@ -208,11 +208,6 @@ initialization when @code{collect2} is being initialized.\n If defined, a C statement (sans semicolon) that performs host-dependent\n initialization when a compilation driver is being initialized.\n \n-@item SMALL_ARG_MAX\n-Define this macro if the host system has a small limit on the total\n-size of an argument vector.  This causes the driver to take more care\n-not to pass unnecessary arguments to subprocesses.\n-\n @item HOST_LONG_LONG_FORMAT\n If defined, the string used to indicate an argument of type @code{long\n long} to functions like @code{printf}.  The default value is"}, {"sha": "56f12901fef5669893d663d5c004637b18b855db", "filename": "gcc/gcc.c", "status": "modified", "additions": 347, "deletions": 318, "changes": 665, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00dcee0c2b28fcca272fe3e9ad67782022612671/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00dcee0c2b28fcca272fe3e9ad67782022612671/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=00dcee0c2b28fcca272fe3e9ad67782022612671", "patch": "@@ -287,10 +287,12 @@ static char *load_specs (const char *);\n static void read_specs (const char *, int);\n static void set_spec (const char *, const char *);\n static struct compiler *lookup_compiler (const char *, size_t, const char *);\n-static char *build_search_list (struct path_prefix *, const char *, int);\n-static void putenv_from_prefixes (struct path_prefix *, const char *);\n+static char *build_search_list (const struct path_prefix *, const char *,\n+\t\t\t\tbool, bool);\n+static void putenv_from_prefixes (const struct path_prefix *, const char *,\n+\t\t\t\t  bool);\n static int access_check (const char *, int);\n-static char *find_a_file (struct path_prefix *, const char *, int, int);\n+static char *find_a_file (const struct path_prefix *, const char *, int, bool);\n static void add_prefix (struct path_prefix *, const char *, const char *,\n \t\t\tint, int, int);\n static void add_sysrooted_prefix (struct path_prefix *, const char *,\n@@ -313,13 +315,12 @@ static const char *eval_spec_function (const char *, const char *);\n static const char *handle_spec_function (const char *);\n static char *save_string (const char *, int);\n static void set_collect_gcc_options (void);\n-static void do_spec_path (struct prefix_list *, const char *, int, int, int, const char *, const char *);\n static int do_spec_1 (const char *, int, const char *);\n static int do_spec_2 (const char *);\n static void do_option_spec (const char *, const char *);\n static void do_self_spec (const char *);\n static const char *find_file (const char *);\n-static int is_directory (const char *, const char *, int);\n+static int is_directory (const char *, bool);\n static const char *validate_switches (const char *);\n static void validate_all_switches (void);\n static inline void validate_switches_from_spec (const char *);\n@@ -2041,7 +2042,7 @@ read_specs (const char *filename, int main_p)\n \t\t       (long) (p1 - buffer + 1));\n \n \t      p[-2] = '\\0';\n-\t      new_filename = find_a_file (&startfile_prefixes, p1, R_OK, 0);\n+\t      new_filename = find_a_file (&startfile_prefixes, p1, R_OK, true);\n \t      read_specs (new_filename ? new_filename : p1, FALSE);\n \t      continue;\n \t    }\n@@ -2060,7 +2061,7 @@ read_specs (const char *filename, int main_p)\n \t\t       (long) (p1 - buffer + 1));\n \n \t      p[-2] = '\\0';\n-\t      new_filename = find_a_file (&startfile_prefixes, p1, R_OK, 0);\n+\t      new_filename = find_a_file (&startfile_prefixes, p1, R_OK, true);\n \t      if (new_filename)\n \t\tread_specs (new_filename, FALSE);\n \t      else if (verbose_flag)\n@@ -2357,64 +2358,213 @@ clear_failure_queue (void)\n   failure_delete_queue = 0;\n }\n \f\n-/* Build a list of search directories from PATHS.\n-   PREFIX is a string to prepend to the list.\n-   If CHECK_DIR_P is nonzero we ensure the directory exists.\n-   This is used mostly by putenv_from_prefixes so we use `collect_obstack'.\n-   It is also used by the --print-search-dirs flag.  */\n-\n-static char *\n-build_search_list (struct path_prefix *paths, const char *prefix,\n-\t\t   int check_dir_p)\n+/* Call CALLBACK for each path in PATHS, breaking out early if CALLBACK\n+   returns non-NULL.\n+   If DO_MULTI is true iterate over the paths twice, first with multilib\n+   suffix then without, otherwise iterate over the paths once without\n+   adding a multilib suffix.  When DO_MULTI is true, some attempt is made\n+   to avoid visiting the same path twice, but we could do better.  For\n+   instance, /usr/lib/../lib is considered different from /usr/lib.\n+   At least EXTRA_SPACE chars past the end of the path passed to\n+   CALLBACK are available for use by the callback.\n+   CALLBACK_INFO allows extra parameters to be passed to CALLBACK.\n+\n+   Returns the value returned by CALLBACK.  */\n+\n+static void *\n+for_each_path (const struct path_prefix *paths,\n+\t       bool do_multi,\n+\t       size_t extra_space,\n+\t       void *(*callback) (char *, void *),\n+\t       void *callback_info)\n {\n-  int suffix_len = (machine_suffix) ? strlen (machine_suffix) : 0;\n-  int just_suffix_len\n-    = (just_machine_suffix) ? strlen (just_machine_suffix) : 0;\n-  int first_time = TRUE;\n-  struct prefix_list *pprefix;\n-\n-  obstack_grow (&collect_obstack, prefix, strlen (prefix));\n-  obstack_1grow (&collect_obstack, '=');\n-\n-  for (pprefix = paths->plist; pprefix != 0; pprefix = pprefix->next)\n+  struct prefix_list *pl;\n+  const char *multi_dir = NULL;\n+  const char *multi_os_dir = NULL;\n+  const char *multi_suffix;\n+  const char *just_multi_suffix;\n+  char *path = NULL;\n+  void *ret = NULL;\n+  bool skip_multi_dir = false;\n+  bool skip_multi_os_dir = false;\n+\n+  multi_suffix = machine_suffix;\n+  just_multi_suffix = just_machine_suffix;\n+  if (do_multi && multilib_dir && strcmp (multilib_dir, \".\") != 0)\n     {\n-      int len = strlen (pprefix->prefix);\n+      multi_dir = concat (multilib_dir, dir_separator_str, NULL);\n+      multi_suffix = concat (multi_suffix, multi_dir, NULL);\n+      just_multi_suffix = concat (just_multi_suffix, multi_dir, NULL);\n+    }\n+  if (do_multi && multilib_os_dir && strcmp (multilib_os_dir, \".\") != 0)\n+    multi_os_dir = concat (multilib_os_dir, dir_separator_str, NULL);\n \n-      if (machine_suffix\n-\t  && (! check_dir_p\n-\t      || is_directory (pprefix->prefix, machine_suffix, 0)))\n+  while (1)\n+    {\n+      size_t multi_dir_len = 0;\n+      size_t multi_os_dir_len = 0;\n+      size_t suffix_len;\n+      size_t just_suffix_len;\n+      size_t len;\n+\n+      if (multi_dir)\n+\tmulti_dir_len = strlen (multi_dir);\n+      if (multi_os_dir)\n+\tmulti_os_dir_len = strlen (multi_os_dir);\n+      suffix_len = strlen (multi_suffix);\n+      just_suffix_len = strlen (just_multi_suffix);\n+\n+      if (path == NULL)\n \t{\n-\t  if (!first_time)\n-\t    obstack_1grow (&collect_obstack, PATH_SEPARATOR);\n-\n-\t  first_time = FALSE;\n-\t  obstack_grow (&collect_obstack, pprefix->prefix, len);\n-\t  obstack_grow (&collect_obstack, machine_suffix, suffix_len);\n+\t  len = paths->max_len + extra_space + 1;\n+\t  if (suffix_len > multi_os_dir_len)\n+\t    len += suffix_len;\n+\t  else\n+\t    len += multi_os_dir_len;\n+\t  path = xmalloc (len);\n \t}\n \n-      if (just_machine_suffix\n-\t  && pprefix->require_machine_suffix == 2\n-\t  && (! check_dir_p\n-\t      || is_directory (pprefix->prefix, just_machine_suffix, 0)))\n+      for (pl = paths->plist; pl != 0; pl = pl->next)\n \t{\n-\t  if (! first_time)\n-\t    obstack_1grow (&collect_obstack, PATH_SEPARATOR);\n+\t  len = strlen (pl->prefix);\n+\t  memcpy (path, pl->prefix, len);\n \n-\t  first_time = FALSE;\n-\t  obstack_grow (&collect_obstack, pprefix->prefix, len);\n-\t  obstack_grow (&collect_obstack, just_machine_suffix,\n-\t\t\tjust_suffix_len);\n+\t  /* Look first in MACHINE/VERSION subdirectory.  */\n+\t  if (!skip_multi_dir)\n+\t    {\n+\t      memcpy (path + len, multi_suffix, suffix_len + 1);\n+\t      ret = callback (path, callback_info);\n+\t      if (ret)\n+\t\tbreak;\n+\t    }\n+\n+\t  /* Some paths are tried with just the machine (ie. target)\n+\t     subdir.  This is used for finding as, ld, etc.  */\n+\t  if (!skip_multi_dir\n+\t      && pl->require_machine_suffix == 2)\n+\t    {\n+\t      memcpy (path + len, just_multi_suffix, just_suffix_len + 1);\n+\t      ret = callback (path, callback_info);\n+\t      if (ret)\n+\t\tbreak;\n+\t    }\n+\n+\t  /* Now try the base path.  */\n+\t  if (!pl->require_machine_suffix\n+\t      && !(pl->os_multilib ? skip_multi_os_dir : skip_multi_dir))\n+\t    {\n+\t      const char *this_multi;\n+\t      size_t this_multi_len;\n+\n+\t      if (pl->os_multilib)\n+\t\t{\n+\t\t  this_multi = multi_os_dir;\n+\t\t  this_multi_len = multi_os_dir_len;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  this_multi = multi_dir;\n+\t\t  this_multi_len = multi_dir_len;\n+\t\t}\n+\n+\t      if (this_multi_len)\n+\t\tmemcpy (path + len, this_multi, this_multi_len + 1);\n+\t      else\n+\t\tpath[len] = '\\0';\n+\n+\t      ret = callback (path, callback_info);\n+\t      if (ret)\n+\t\tbreak;\n+\t    }\n \t}\n+      if (pl)\n+\tbreak;\n \n-      if (! pprefix->require_machine_suffix)\n-\t{\n-\t  if (! first_time)\n-\t    obstack_1grow (&collect_obstack, PATH_SEPARATOR);\n+      if (multi_dir == NULL && multi_os_dir == NULL)\n+\tbreak;\n \n-\t  first_time = FALSE;\n-\t  obstack_grow (&collect_obstack, pprefix->prefix, len);\n+      /* Run through the paths again, this time without multilibs.\n+\t Don't repeat any we have already seen.  */\n+      if (multi_dir)\n+\t{\n+\t  free ((char *) multi_dir);\n+\t  multi_dir = NULL;\n+\t  free ((char *) multi_suffix);\n+\t  multi_suffix = machine_suffix;\n+\t  free ((char *) just_multi_suffix);\n+\t  just_multi_suffix = just_machine_suffix;\n \t}\n+      else\n+\tskip_multi_dir = true;\n+      if (multi_os_dir)\n+\t{\n+\t  free ((char *) multi_os_dir);\n+\t  multi_os_dir = NULL;\n+\t}\n+      else\n+\tskip_multi_os_dir = true;\n+    }\n+\n+  if (multi_dir)\n+    {\n+      free ((char *) multi_dir);\n+      free ((char *) multi_suffix);\n+      free ((char *) just_multi_suffix);\n     }\n+  if (multi_os_dir)\n+    free ((char *) multi_os_dir);\n+  if (ret != path)\n+    free (path);\n+  return ret;\n+}\n+\n+/* Callback for build_search_list.  Adds path to obstack being built.  */\n+\n+struct add_to_obstack_info {\n+  struct obstack *ob;\n+  bool check_dir;\n+  bool first_time;\n+};\n+\n+static void *\n+add_to_obstack (char *path, void *data)\n+{\n+  struct add_to_obstack_info *info = data;\n+\n+  if (info->check_dir && !is_directory (path, false))\n+    return NULL;\n+\n+  if (!info->first_time)\n+    obstack_1grow (info->ob, PATH_SEPARATOR);\n+\n+  obstack_grow (info->ob, path, strlen (path));\n+\n+  info->first_time = false;\n+  return NULL;\n+}\n+\n+/* Build a list of search directories from PATHS.\n+   PREFIX is a string to prepend to the list.\n+   If CHECK_DIR_P is true we ensure the directory exists.\n+   If DO_MULTI is true, multilib paths are output first, then\n+   non-multilib paths.\n+   This is used mostly by putenv_from_prefixes so we use `collect_obstack'.\n+   It is also used by the --print-search-dirs flag.  */\n+\n+static char *\n+build_search_list (const struct path_prefix *paths, const char *prefix,\n+\t\t   bool check_dir, bool do_multi)\n+{\n+  struct add_to_obstack_info info;\n+\n+  info.ob = &collect_obstack;\n+  info.check_dir = check_dir;\n+  info.first_time = true;\n+\n+  obstack_grow (&collect_obstack, prefix, strlen (prefix));\n+  obstack_1grow (&collect_obstack, '=');\n+\n+  for_each_path (paths, do_multi, 0, add_to_obstack, &info);\n \n   obstack_1grow (&collect_obstack, '\\0');\n   return XOBFINISH (&collect_obstack, char *);\n@@ -2424,9 +2574,10 @@ build_search_list (struct path_prefix *paths, const char *prefix,\n    for collect.  */\n \n static void\n-putenv_from_prefixes (struct path_prefix *paths, const char *env_var)\n+putenv_from_prefixes (const struct path_prefix *paths, const char *env_var,\n+\t\t      bool do_multi)\n {\n-  putenv (build_search_list (paths, env_var, 1));\n+  putenv (build_search_list (paths, env_var, true, do_multi));\n }\n \f\n /* Check whether NAME can be accessed in MODE.  This is like access,\n@@ -2447,20 +2598,53 @@ access_check (const char *name, int mode)\n   return access (name, mode);\n }\n \n+/* Callback for find_a_file.  Appends the file name to the directory\n+   path.  If the resulting file exists in the right mode, return the\n+   full pathname to the file.  */\n+\n+struct file_at_path_info {\n+  const char *name;\n+  const char *suffix;\n+  int name_len;\n+  int suffix_len;\n+  int mode;\n+};\n+\n+static void *\n+file_at_path (char *path, void *data)\n+{\n+  struct file_at_path_info *info = data;\n+  size_t len = strlen (path);\n+\n+  memcpy (path + len, info->name, info->name_len);\n+  len += info->name_len;\n+\n+  /* Some systems have a suffix for executable files.\n+     So try appending that first.  */\n+  if (info->suffix_len)\n+    {\n+      memcpy (path + len, info->suffix, info->suffix_len + 1);\n+      if (access_check (path, info->mode) == 0)\n+\treturn path;\n+    }\n+\n+  path[len] = '\\0';\n+  if (access_check (path, info->mode) == 0)\n+    return path;\n+\n+  return NULL;\n+}\n+\n /* Search for NAME using the prefix list PREFIXES.  MODE is passed to\n-   access to check permissions.\n+   access to check permissions.  If DO_MULTI is true, search multilib\n+   paths then non-multilib paths, otherwise do not search multilib paths.\n    Return 0 if not found, otherwise return its name, allocated with malloc.  */\n \n static char *\n-find_a_file (struct path_prefix *pprefix, const char *name, int mode,\n-\t     int multilib)\n+find_a_file (const struct path_prefix *pprefix, const char *name, int mode,\n+\t     bool do_multi)\n {\n-  char *temp;\n-  const char *const file_suffix =\n-    ((mode & X_OK) != 0 ? HOST_EXECUTABLE_SUFFIX : \"\");\n-  struct prefix_list *pl;\n-  int len = pprefix->max_len + strlen (name) + strlen (file_suffix) + 1;\n-  const char *multilib_name, *multilib_os_name;\n+  struct file_at_path_info info;\n \n #ifdef DEFAULT_ASSEMBLER\n   if (! strcmp (name, \"as\") && access (DEFAULT_ASSEMBLER, mode) == 0)\n@@ -2472,112 +2656,24 @@ find_a_file (struct path_prefix *pprefix, const char *name, int mode,\n     return xstrdup (DEFAULT_LINKER);\n #endif\n \n-  if (machine_suffix)\n-    len += strlen (machine_suffix);\n-\n-  multilib_name = name;\n-  multilib_os_name = name;\n-  if (multilib && multilib_os_dir)\n-    {\n-      int len1 = multilib_dir ? strlen (multilib_dir) + 1 : 0;\n-      int len2 = strlen (multilib_os_dir) + 1;\n-\n-      len += len1 > len2 ? len1 : len2;\n-      if (multilib_dir)\n-\tmultilib_name = ACONCAT ((multilib_dir, dir_separator_str, name,\n-\t\t\t\t  NULL));\n-      if (strcmp (multilib_os_dir, \".\") != 0)\n-\tmultilib_os_name = ACONCAT ((multilib_os_dir, dir_separator_str, name,\n-\t\t\t\t    NULL));\n-    }\n-\n-  temp = xmalloc (len);\n-\n   /* Determine the filename to execute (special case for absolute paths).  */\n \n   if (IS_ABSOLUTE_PATH (name))\n     {\n       if (access (name, mode) == 0)\n-\t{\n-\t  strcpy (temp, name);\n-\t  return temp;\n-\t}\n-    }\n-  else\n-    for (pl = pprefix->plist; pl; pl = pl->next)\n-      {\n-\tconst char *this_name\n-\t  = pl->os_multilib ? multilib_os_name : multilib_name;\n-\n-\tif (machine_suffix)\n-\t  {\n-\t    /* Some systems have a suffix for executable files.\n-\t       So try appending that first.  */\n-\t    if (file_suffix[0] != 0)\n-\t      {\n-\t\tstrcpy (temp, pl->prefix);\n-\t\tstrcat (temp, machine_suffix);\n-\t\tstrcat (temp, multilib_name);\n-\t\tstrcat (temp, file_suffix);\n-\t\tif (access_check (temp, mode) == 0)\n-\t\t  return temp;\n-\t      }\n-\n-\t    /* Now try just the multilib_name.  */\n-\t    strcpy (temp, pl->prefix);\n-\t    strcat (temp, machine_suffix);\n-\t    strcat (temp, multilib_name);\n-\t    if (access_check (temp, mode) == 0)\n-\t      return temp;\n-\t  }\n-\n-\t/* Certain prefixes are tried with just the machine type,\n-\t   not the version.  This is used for finding as, ld, etc.  */\n-\tif (just_machine_suffix && pl->require_machine_suffix == 2)\n-\t  {\n-\t    /* Some systems have a suffix for executable files.\n-\t       So try appending that first.  */\n-\t    if (file_suffix[0] != 0)\n-\t      {\n-\t\tstrcpy (temp, pl->prefix);\n-\t\tstrcat (temp, just_machine_suffix);\n-\t\tstrcat (temp, multilib_name);\n-\t\tstrcat (temp, file_suffix);\n-\t\tif (access_check (temp, mode) == 0)\n-\t\t  return temp;\n-\t      }\n+\treturn xstrdup (name);\n \n-\t    strcpy (temp, pl->prefix);\n-\t    strcat (temp, just_machine_suffix);\n-\t    strcat (temp, multilib_name);\n-\t    if (access_check (temp, mode) == 0)\n-\t      return temp;\n-\t  }\n-\n-\t/* Certain prefixes can't be used without the machine suffix\n-\t   when the machine or version is explicitly specified.  */\n-\tif (! pl->require_machine_suffix)\n-\t  {\n-\t    /* Some systems have a suffix for executable files.\n-\t       So try appending that first.  */\n-\t    if (file_suffix[0] != 0)\n-\t      {\n-\t\tstrcpy (temp, pl->prefix);\n-\t\tstrcat (temp, this_name);\n-\t\tstrcat (temp, file_suffix);\n-\t\tif (access_check (temp, mode) == 0)\n-\t\t  return temp;\n-\t      }\n+      return NULL;\n+    }\n \n-\t    strcpy (temp, pl->prefix);\n-\t    strcat (temp, this_name);\n-\t    if (access_check (temp, mode) == 0)\n-\t      return temp;\n-\t  }\n-      }\n+  info.name = name;\n+  info.suffix = (mode & X_OK) != 0 ? HOST_EXECUTABLE_SUFFIX : \"\";\n+  info.name_len = strlen (info.name);\n+  info.suffix_len = strlen (info.suffix);\n+  info.mode = mode;\n \n-  free (temp);\n-  return 0;\n+  return for_each_path (pprefix, do_multi, info.name_len + info.suffix_len,\n+\t\t\tfile_at_path, &info);\n }\n \n /* Ranking of prefixes in the sort list. -B prefixes are put before\n@@ -2696,7 +2792,7 @@ execute (void)\n \n   commands[0].prog = argbuf[0]; /* first command.  */\n   commands[0].argv = &argbuf[0];\n-  string = find_a_file (&exec_prefixes, commands[0].prog, X_OK, 0);\n+  string = find_a_file (&exec_prefixes, commands[0].prog, X_OK, false);\n \n   if (string)\n     commands[0].argv[0] = string;\n@@ -2711,7 +2807,7 @@ execute (void)\n \tcommands[n_commands].prog = argbuf[i + 1];\n \tcommands[n_commands].argv = &argbuf[i + 1];\n \tstring = find_a_file (&exec_prefixes, commands[n_commands].prog,\n-\t\t\t      X_OK, 0);\n+\t\t\t      X_OK, false);\n \tif (string)\n \t  commands[n_commands].argv[0] = string;\n \tn_commands++;\n@@ -3649,7 +3745,7 @@ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\\n\"\n \t\t   if appending a directory separator actually makes a\n \t\t   valid directory name.  */\n \t\tif (! IS_DIR_SEPARATOR (value [len - 1])\n-\t\t    && is_directory (value, \"\", 0))\n+\t\t    && is_directory (value, false))\n \t\t  {\n \t\t    char *tmp = xmalloc (len + 2);\n \t\t    strcpy (tmp, value);\n@@ -4397,108 +4493,55 @@ do_self_spec (const char *spec)\n     }\n }\n \n-void\n-do_spec_path (struct prefix_list *pl, const char *option,\n-\t      int omit_if_relative, int separate_options,\n-\t      int only_subdir,\n-\t      const char *dir_for_machine_suffix,\n-\t      const char *dir_for_no_suffix)\n+/* Callback for processing %D and %I specs.  */\n+\n+struct spec_path_info {\n+  const char *option;\n+  const char *append;\n+  size_t append_len;\n+  bool omit_relative;\n+  bool separate_options;\n+};\n+\n+static void *\n+spec_path (char *path, void *data)\n {\n-  static size_t bufsize = 0;\n-  static char *buffer;\n-  int idx;\n-  bool multilib_p = false;\n-\n-  /* Used on systems which record the specified -L dirs\n-     and use them to search for dynamic linking.  */\n-  /* Relative directories always come from -B,\n-     and it is better not to use them for searching\n-     at run time.  In particular, stage1 loses.  */\n-  if (omit_if_relative\n-      && !IS_ABSOLUTE_PATH (pl->prefix))\n-    return;\n+  struct spec_path_info *info = data;\n+  size_t len = 0;\n+  char save = 0;\n \n-  /* Try subdirectory if there is one.  */\n-  if (machine_suffix && dir_for_machine_suffix)\n-    {\n-      if (strlen (pl->prefix) + strlen (machine_suffix)\n-\t  >= bufsize)\n-\tbufsize = (strlen (pl->prefix)\n-\t\t  + strlen (machine_suffix)) * 2 + 1;\n-      buffer = xrealloc (buffer, bufsize);\n-      strcpy (buffer, pl->prefix);\n-      strcat (buffer, machine_suffix);\n-      if (is_directory (buffer, dir_for_machine_suffix, 1))\n-\t{\n-\t  multilib_p = true;\n-\t  do_spec_1 (option, separate_options, NULL);\n-\t  if (separate_options)\n-\t    do_spec_1 (\" \", 0, NULL);\n-\t  do_spec_1 (buffer, 1, NULL);\n-\t  do_spec_1 (dir_for_machine_suffix, 1, NULL);\n-\t  /* Make this a separate argument.  */\n-\t  do_spec_1 (\" \", 0, NULL);\n-\t}\n-    }\n-  if (!pl->require_machine_suffix && dir_for_no_suffix)\n+  if (info->omit_relative && !IS_ABSOLUTE_PATH (path))\n+    return NULL;\n+\n+  if (info->append_len != 0)\n     {\n-      if (is_directory (pl->prefix, dir_for_no_suffix, 1))\n-\t{\n-\t  multilib_p = true;\n-\t  do_spec_1 (option, separate_options, NULL);\n-\t  if (separate_options)\n-\t    do_spec_1 (\" \", 0, NULL);\n-\t  do_spec_1 (pl->prefix, 1, NULL);\n-\t  do_spec_1 (dir_for_no_suffix, 1, NULL);\n-\t  /* Make this a separate argument.  */\n-\t  do_spec_1 (\" \", 0, NULL);\n-\t}\n+      len = strlen (path);\n+      memcpy (path + len, info->append, info->append_len + 1);\n     }\n \n-  if (only_subdir || multilib_p)\n-    return;\n+  if (!is_directory (path, true))\n+    return NULL;\n \n-  if (machine_suffix)\n-    {\n-      if (is_directory (pl->prefix, machine_suffix, 1))\n-\t{\n-\t  do_spec_1 (option, separate_options, NULL);\n-\t  if (separate_options)\n-\t    do_spec_1 (\" \", 0, NULL);\n-\t  do_spec_1 (pl->prefix, 1, NULL);\n-\t  /* Remove slash from machine_suffix.  */\n-\t  if (strlen (machine_suffix) >= bufsize)\n-\t    bufsize = strlen (machine_suffix) * 2 + 1;\n-\t  buffer = xrealloc (buffer, bufsize);\n-\t  strcpy (buffer, machine_suffix);\n-\t  idx = strlen (buffer);\n-\t  if (IS_DIR_SEPARATOR (buffer[idx - 1]))\n-\t    buffer[idx - 1] = 0;\n-\t  do_spec_1 (buffer, 1, NULL);\n-\t  /* Make this a separate argument.  */\n-\t  do_spec_1 (\" \", 0, NULL);\n-\t}\n-    }\n-  if (!pl->require_machine_suffix)\n+  do_spec_1 (info->option, 1, NULL);\n+  if (info->separate_options)\n+    do_spec_1 (\" \", 0, NULL);\n+\n+  if (info->append_len == 0)\n     {\n-      if (is_directory (pl->prefix, \"\", 1))\n-\t{\n-\t  do_spec_1 (option, separate_options, NULL);\n-\t  if (separate_options)\n-\t    do_spec_1 (\" \", 0, NULL);\n-\t  /* Remove slash from pl->prefix.  */\n-\t  if (strlen (pl->prefix) >= bufsize)\n-\t    bufsize = strlen (pl->prefix) * 2 + 1;\n-\t  buffer = xrealloc (buffer, bufsize);\n-\t  strcpy (buffer, pl->prefix);\n-\t  idx = strlen (buffer);\n-\t  if (IS_DIR_SEPARATOR (buffer[idx - 1]))\n-\t    buffer[idx - 1] = 0;\n-\t  do_spec_1 (buffer, 1, NULL);\n-\t  /* Make this a separate argument.  */\n-\t  do_spec_1 (\" \", 0, NULL);\n-\t}\n+      len = strlen (path);\n+      save = path[len - 1];\n+      if (IS_DIR_SEPARATOR (path[len - 1]))\n+\tpath[len - 1] = '\\0';\n     }\n+\n+  do_spec_1 (path, 1, NULL);\n+  do_spec_1 (\" \", 0, NULL);\n+\n+  /* Must not damage the original path.  */\n+  if (info->append_len == 0)\n+    path[len - 1] = save;\n+\n+  return NULL;\n }\n \n /* Process the sub-spec SPEC as a portion of a larger spec.\n@@ -4636,23 +4679,23 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n \t     that we search for startfiles.  */\n \t  case 'D':\n \t    {\n-\t      struct prefix_list *pl = startfile_prefixes.plist;\n+\t      struct spec_path_info info;\n \n-\t      for (; pl; pl = pl->next)\n-\t\t{\n-\t\t  const char *no_suffix_multilib_dir;\n-\n-\t\t  no_suffix_multilib_dir = pl->os_multilib ? multilib_os_dir\n-\t\t\t\t\t   : multilib_dir;\n-\t\t  /* Do not separate options, include non-multilibbed variant.  */\n-\t\t  do_spec_path (pl, \"-L\",\n+\t      info.option = \"-L\";\n+\t      info.append_len = 0;\n #ifdef RELATIVE_PREFIX_NOT_LINKDIR\n-\t\t\t\t1,\n+\t      /* Used on systems which record the specified -L dirs\n+\t\t and use them to search for dynamic linking.\n+\t\t Relative directories always come from -B,\n+\t\t and it is better not to use them for searching\n+\t\t at run time.  In particular, stage1 loses.  */\n+\t      info.omit_relative = true;\n #else\n-\t\t\t\t0,\n+\t      info.omit_relative = false;\n #endif\n-\t\t\t\t0, 0, multilib_dir, no_suffix_multilib_dir);\n-\t\t}\n+\t      info.separate_options = false;\n+\n+\t      for_each_path (&startfile_prefixes, true, 0, spec_path, &info);\n \t    }\n \t    break;\n \n@@ -4889,7 +4932,7 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n \n \t  case 'I':\n \t    {\n-\t      struct prefix_list *pl = include_prefixes.plist;\n+\t      struct spec_path_info info;\n \n \t      if (gcc_exec_prefix)\n \t\t{\n@@ -4912,9 +4955,14 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n \t\t  do_spec_1 (\" \", 0, NULL);\n \t\t}\n \n-\t      for (; pl; pl = pl->next)\n-\t\t/* Separate options, don't include non-suffixed variant.  */\n-\t\tdo_spec_path (pl, \"-isystem\", 0, 1, 1, \"include\", \"include\");\n+\t      info.option = \"-isystem\";\n+\t      info.append = \"include\";\n+\t      info.append_len = strlen (info.append);\n+\t      info.omit_relative = false;\n+\t      info.separate_options = true;\n+\n+\t      for_each_path (&include_prefixes, false, info.append_len,\n+\t\t\t     spec_path, &info);\n \t    }\n \t    break;\n \n@@ -5900,62 +5948,41 @@ give_switch (int switchnum, int omit_first_word)\n static const char *\n find_file (const char *name)\n {\n-  char *newname;\n-\n-  /* Try multilib_dir if it is defined.  */\n-  if (multilib_os_dir != NULL)\n-    {\n-      newname = find_a_file (&startfile_prefixes, name, R_OK, 1);\n-\n-      /* If we don't find it in the multi library dir, then fall\n-\t through and look for it in the normal places.  */\n-      if (newname != NULL)\n-\treturn newname;\n-    }\n-\n-  newname = find_a_file (&startfile_prefixes, name, R_OK, 0);\n+  char *newname = find_a_file (&startfile_prefixes, name, R_OK, true);\n   return newname ? newname : name;\n }\n \n /* Determine whether a directory exists.  If LINKER, return 0 for\n-   certain fixed names not needed by the linker.  If not LINKER, it is\n-   only important to return 0 if the host machine has a small ARG_MAX\n-   limit.  */\n+   certain fixed names not needed by the linker.  */\n \n static int\n-is_directory (const char *path1, const char *path2, int linker)\n+is_directory (const char *path1, bool linker)\n {\n-  int len1 = strlen (path1);\n-  int len2 = strlen (path2);\n-  char *path = alloca (3 + len1 + len2);\n+  int len1;\n+  char *path;\n   char *cp;\n   struct stat st;\n \n-#ifndef SMALL_ARG_MAX\n-  if (! linker)\n-    return 1;\n-#endif\n-\n-  /* Construct the path from the two parts.  Ensure the string ends with \"/.\".\n-     The resulting path will be a directory even if the given path is a\n-     symbolic link.  */\n+  /* Ensure the string ends with \"/.\".  The resulting path will be a\n+     directory even if the given path is a symbolic link.  */\n+  len1 = strlen (path1);\n+  path = alloca (3 + len1);\n   memcpy (path, path1, len1);\n-  memcpy (path + len1, path2, len2);\n-  cp = path + len1 + len2;\n+  cp = path + len1;\n   if (!IS_DIR_SEPARATOR (cp[-1]))\n     *cp++ = DIR_SEPARATOR;\n   *cp++ = '.';\n   *cp = '\\0';\n \n   /* Exclude directories that the linker is known to search.  */\n   if (linker\n+      && IS_DIR_SEPARATOR (path[0])\n       && ((cp - path == 6\n-\t   && strcmp (path, concat (dir_separator_str, \"lib\",\n-\t\t\t\t    dir_separator_str, \".\", NULL)) == 0)\n+\t   && strncmp (path + 1, \"lib\", 3) == 0)\n \t  || (cp - path == 10\n-\t      && strcmp (path, concat (dir_separator_str, \"usr\",\n-\t\t\t\t       dir_separator_str, \"lib\",\n-\t\t\t\t       dir_separator_str, \".\", NULL)) == 0)))\n+\t      && strncmp (path + 1, \"usr\", 3) == 0\n+\t      && IS_DIR_SEPARATOR (path[4])\n+\t      && strncmp (path + 5, \"lib\", 3) == 0)))\n     return 0;\n \n   return (stat (path, &st) >= 0 && S_ISDIR (st.st_mode));\n@@ -6147,7 +6174,7 @@ main (int argc, char **argv)\n \t\t\t   spec_version, dir_separator_str, NULL);\n   just_machine_suffix = concat (spec_machine, dir_separator_str, NULL);\n \n-  specs_file = find_a_file (&startfile_prefixes, \"specs\", R_OK, 0);\n+  specs_file = find_a_file (&startfile_prefixes, \"specs\", R_OK, true);\n   /* Read the specs file unless it is a default one.  */\n   if (specs_file != 0 && strcmp (specs_file, \"specs\"))\n     read_specs (specs_file, TRUE);\n@@ -6283,7 +6310,7 @@ main (int argc, char **argv)\n   for (uptr = user_specs_head; uptr; uptr = uptr->next)\n     {\n       char *filename = find_a_file (&startfile_prefixes, uptr->filename,\n-\t\t\t\t    R_OK, 0);\n+\t\t\t\t    R_OK, true);\n       read_specs (filename ? filename : uptr->filename, FALSE);\n     }\n \n@@ -6312,8 +6339,10 @@ main (int argc, char **argv)\n   if (print_search_dirs)\n     {\n       printf (_(\"install: %s%s\\n\"), standard_exec_prefix, machine_suffix);\n-      printf (_(\"programs: %s\\n\"), build_search_list (&exec_prefixes, \"\", 0));\n-      printf (_(\"libraries: %s\\n\"), build_search_list (&startfile_prefixes, \"\", 0));\n+      printf (_(\"programs: %s\\n\"),\n+\t      build_search_list (&exec_prefixes, \"\", false, false));\n+      printf (_(\"libraries: %s\\n\"),\n+\t      build_search_list (&startfile_prefixes, \"\", false, true));\n       return (0);\n     }\n \n@@ -6630,14 +6659,14 @@ main (int argc, char **argv)\n       /* We'll use ld if we can't find collect2.  */\n       if (! strcmp (linker_name_spec, \"collect2\"))\n \t{\n-\t  char *s = find_a_file (&exec_prefixes, \"collect2\", X_OK, 0);\n+\t  char *s = find_a_file (&exec_prefixes, \"collect2\", X_OK, false);\n \t  if (s == NULL)\n \t    linker_name_spec = \"ld\";\n \t}\n       /* Rebuild the COMPILER_PATH and LIBRARY_PATH environment variables\n \t for collect.  */\n-      putenv_from_prefixes (&exec_prefixes, \"COMPILER_PATH\");\n-      putenv_from_prefixes (&startfile_prefixes, LIBRARY_PATH_ENV);\n+      putenv_from_prefixes (&exec_prefixes, \"COMPILER_PATH\", false);\n+      putenv_from_prefixes (&startfile_prefixes, LIBRARY_PATH_ENV, true);\n \n       value = do_spec (link_command_spec);\n       if (value < 0)"}, {"sha": "ca9c8b4ce5ea282bbfde9e8a3746f268919b493e", "filename": "gcc/system.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00dcee0c2b28fcca272fe3e9ad67782022612671/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00dcee0c2b28fcca272fe3e9ad67782022612671/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=00dcee0c2b28fcca272fe3e9ad67782022612671", "patch": "@@ -730,7 +730,8 @@ extern void fancy_abort (const char *, int, const char *) ATTRIBUTE_NORETURN;\n \tTARGET_OPTIONS TARGET_SWITCHES EXTRA_CC_MODES FINALIZE_PIC\t   \\\n \tPREDICATE_CODES SPECIAL_MODE_PREDICATES HOST_PTR_PRINTF\t\t   \\\n \tEXTRA_SECTIONS EXTRA_SECTION_FUNCTIONS READONLY_DATA_SECTION\t   \\\n-\tTARGET_ASM_EXCEPTION_SECTION TARGET_ASM_EH_FRAME_SECTION\n+\tTARGET_ASM_EXCEPTION_SECTION TARGET_ASM_EH_FRAME_SECTION\t   \\\n+\tSMALL_ARG_MAX\n \n /* Hooks that are no longer used.  */\n  #pragma GCC poison LANG_HOOKS_FUNCTION_MARK LANG_HOOKS_FUNCTION_FREE\t\\"}]}