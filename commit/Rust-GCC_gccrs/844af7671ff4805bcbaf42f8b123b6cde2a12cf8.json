{"sha": "844af7671ff4805bcbaf42f8b123b6cde2a12cf8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQ0YWY3NjcxZmY0ODA1YmNiYWY0MmY4YjEyM2I2Y2RlMmExMmNmOA==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2016-12-15T16:04:08Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2016-12-15T16:04:08Z"}, "message": "[arm] Permit 'auto' in -mfpu\n\nNow we finally have the infrastructure in place we can now derive\ndetails of the FPU from a CPU entry.  This patch enables this for the\nexisting cores that already have an explicit FPU in their product names.\n\n\t* arm-fpus.def: Add CNAME field to all FPU definitions.\n\t* genopt.sh: Use explicit enumeration tags for FPU entries.\n\t* arm-tables.opt: Regenerated.\n\t* arm.opt (mfpu): Provide initial value.\n\t* arm-opts.h (enum fpu_type): Build the enumeration from the list of\n\tavailable FPUs.  Add 'auto' entry on the end.\n\t* arm.c (arm_configure_build_target): Only do explicit configuration\n\tof the FPU features if the selected FPU is not 'auto'.\n\t(arm_option_override): Adjust initialization of arm_fpu_index.\n\tEmit an error if we have a hard float ABI request, but the processor\n\tdoes not support floating-point.\n\t(arm_option_print): Handle -mfpu=auto.\n\t(arm_valid_target_attribute_rec): Don't permit fpu=auto in pragmas\n\tor function attributes.\n\t(arm_identify_fpu_from_isa): Handle effective soft-float when\n\tthe FPU is automatically detected.\n\t* arm-cores.def (arm1136jf-s): Add feature ISA_FP_DBL.\n\t(arm1176jzf-s): Likewise.\n\t(mpcore): Likewise.\n\t(arm1156t2f-s): Likewise.\n\nFrom-SVN: r243716", "tree": {"sha": "161573743b6ded9cdf3c3fa6e9d9923e713821c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/161573743b6ded9cdf3c3fa6e9d9923e713821c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/844af7671ff4805bcbaf42f8b123b6cde2a12cf8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/844af7671ff4805bcbaf42f8b123b6cde2a12cf8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/844af7671ff4805bcbaf42f8b123b6cde2a12cf8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/844af7671ff4805bcbaf42f8b123b6cde2a12cf8/comments", "author": null, "committer": null, "parents": [{"sha": "7eca7f0b4450e8f57d02bc35137c071e22bea7af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7eca7f0b4450e8f57d02bc35137c071e22bea7af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7eca7f0b4450e8f57d02bc35137c071e22bea7af"}], "stats": {"total": 207, "additions": 140, "deletions": 67}, "files": [{"sha": "0aec46ad1abb604272a74a17d9c4a6ac6247a1ba", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/844af7671ff4805bcbaf42f8b123b6cde2a12cf8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/844af7671ff4805bcbaf42f8b123b6cde2a12cf8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=844af7671ff4805bcbaf42f8b123b6cde2a12cf8", "patch": "@@ -1,3 +1,26 @@\n+2016-12-15  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* arm-fpus.def: Add CNAME field to all FPU definitions.\n+\t* genopt.sh: Use explicit enumeration tags for FPU entries.\n+\t* arm-tables.opt: Regenerated.\n+\t* arm.opt (mfpu): Provide initial value.\n+\t* arm-opts.h (enum fpu_type): Build the enumeration from the list of\n+\tavailable FPUs.  Add 'auto' entry on the end.\n+\t* arm.c (arm_configure_build_target): Only do explicit configuration\n+\tof the FPU features if the selected FPU is not 'auto'.\n+\t(arm_option_override): Adjust initialization of arm_fpu_index.\n+\tEmit an error if we have a hard float ABI request, but the processor\n+\tdoes not support floating-point.\n+\t(arm_option_print): Handle -mfpu=auto.\n+\t(arm_valid_target_attribute_rec): Don't permit fpu=auto in pragmas\n+\tor function attributes.\n+\t(arm_identify_fpu_from_isa): Handle effective soft-float when\n+\tthe FPU is automatically detected.\n+\t* arm-cores.def (arm1136jf-s): Add feature ISA_FP_DBL.\n+\t(arm1176jzf-s): Likewise.\n+\t(mpcore): Likewise.\n+\t(arm1156t2f-s): Likewise.\n+\n 2016-12-15  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* arm-fpus.def (ARM_FPU): Remove features field from all definitions."}, {"sha": "544579c47cc8f30ffc0324058e61880088bb78e3", "filename": "gcc/config/arm/arm-cores.def", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/844af7671ff4805bcbaf42f8b123b6cde2a12cf8/gcc%2Fconfig%2Farm%2Farm-cores.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/844af7671ff4805bcbaf42f8b123b6cde2a12cf8/gcc%2Fconfig%2Farm%2Farm-cores.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-cores.def?ref=844af7671ff4805bcbaf42f8b123b6cde2a12cf8", "patch": "@@ -124,13 +124,13 @@ ARM_CORE(\"arm1026ej-s\",\tarm1026ejs, arm1026ejs,\tTF_LDSCHED,\t\t\t  5TEJ,\tISA_FEAT(I\n \n /* V6 Architecture Processors */\n ARM_CORE(\"arm1136j-s\",\t\tarm1136js, arm1136js,\t\tTF_LDSCHED,\t  6J,\tISA_FEAT(ISA_ARMv6j), 9e)\n-ARM_CORE(\"arm1136jf-s\",\t\tarm1136jfs, arm1136jfs,\t\tTF_LDSCHED,\t  6J,\tISA_FEAT(ISA_ARMv6j) ISA_FEAT(isa_bit_VFPv2), 9e)\n+ARM_CORE(\"arm1136jf-s\",\t\tarm1136jfs, arm1136jfs,\t\tTF_LDSCHED,\t  6J,\tISA_FEAT(ISA_ARMv6j) ISA_FEAT(ISA_VFPv2) ISA_FEAT(ISA_FP_DBL), 9e)\n ARM_CORE(\"arm1176jz-s\",\t\tarm1176jzs, arm1176jzs,\t\tTF_LDSCHED,\t  6KZ,\tISA_FEAT(ISA_ARMv6kz), 9e)\n-ARM_CORE(\"arm1176jzf-s\",\tarm1176jzfs, arm1176jzfs,\tTF_LDSCHED,\t  6KZ,\tISA_FEAT(ISA_ARMv6kz) ISA_FEAT(isa_bit_VFPv2), 9e)\n+ARM_CORE(\"arm1176jzf-s\",\tarm1176jzfs, arm1176jzfs,\tTF_LDSCHED,\t  6KZ,\tISA_FEAT(ISA_ARMv6kz) ISA_FEAT(ISA_VFPv2) ISA_FEAT(ISA_FP_DBL), 9e)\n ARM_CORE(\"mpcorenovfp\",\t\tmpcorenovfp, mpcorenovfp,\tTF_LDSCHED,\t  6K,\tISA_FEAT(ISA_ARMv6k), 9e)\n-ARM_CORE(\"mpcore\",\t\tmpcore, mpcore,\t\t\tTF_LDSCHED,\t  6K,\tISA_FEAT(ISA_ARMv6k) ISA_FEAT(isa_bit_VFPv2), 9e)\n+ARM_CORE(\"mpcore\",\t\tmpcore, mpcore,\t\t\tTF_LDSCHED,\t  6K,\tISA_FEAT(ISA_ARMv6k) ISA_FEAT(ISA_VFPv2) ISA_FEAT(ISA_FP_DBL), 9e)\n ARM_CORE(\"arm1156t2-s\",\t\tarm1156t2s, arm1156t2s,\t\tTF_LDSCHED,\t  6T2,\tISA_FEAT(ISA_ARMv6t2), v6t2)\n-ARM_CORE(\"arm1156t2f-s\",\tarm1156t2fs, arm1156t2fs,\tTF_LDSCHED,\t  6T2,\tISA_FEAT(ISA_ARMv6t2) ISA_FEAT(isa_bit_VFPv2), v6t2)\n+ARM_CORE(\"arm1156t2f-s\",\tarm1156t2fs, arm1156t2fs,\tTF_LDSCHED,\t  6T2,\tISA_FEAT(ISA_ARMv6t2) ISA_FEAT(ISA_VFPv2) ISA_FEAT(ISA_FP_DBL), v6t2)\n \n /* V6M Architecture Processors */\n ARM_CORE(\"cortex-m1\",\t\tcortexm1, cortexm1,\t\tTF_LDSCHED,\t  6M,\tISA_FEAT(ISA_ARMv6m), v6m)"}, {"sha": "f07711c365a955ac1a580f0ea75a3cb4a7fb5299", "filename": "gcc/config/arm/arm-fpus.def", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/844af7671ff4805bcbaf42f8b123b6cde2a12cf8/gcc%2Fconfig%2Farm%2Farm-fpus.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/844af7671ff4805bcbaf42f8b123b6cde2a12cf8/gcc%2Fconfig%2Farm%2Farm-fpus.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-fpus.def?ref=844af7671ff4805bcbaf42f8b123b6cde2a12cf8", "patch": "@@ -19,31 +19,33 @@\n \n /* Before using #include to read this file, define a macro:\n \n-      ARM_FPU(NAME, ISA)\n+      ARM_FPU(NAME, CNAME, ISA)\n \n-   The arguments are the fields of struct arm_fpu_desc.\n+   NAME is the publicly visible option name.\n+   CNAME is a C-compatible variable name substring.\n+   ISA is the list of feature bits that this FPU provides.\n \n    genopt.sh assumes no whitespace up to the first \",\" in each entry.  */\n \n-ARM_FPU(\"vfp\",\t\t\tISA_FEAT(ISA_VFPv2) ISA_FEAT(ISA_FP_DBL))\n-ARM_FPU(\"vfpv2\",\t\tISA_FEAT(ISA_VFPv2) ISA_FEAT(ISA_FP_DBL))\n-ARM_FPU(\"vfpv3\",\t\tISA_FEAT(ISA_VFPv3) ISA_FEAT(ISA_FP_D32))\n-ARM_FPU(\"vfpv3-fp16\",\t\tISA_FEAT(ISA_VFPv3) ISA_FEAT(ISA_FP_D32) ISA_FEAT(isa_bit_fp16conv))\n-ARM_FPU(\"vfpv3-d16\",\t\tISA_FEAT(ISA_VFPv3) ISA_FEAT(ISA_FP_DBL))\n-ARM_FPU(\"vfpv3-d16-fp16\",\tISA_FEAT(ISA_VFPv3) ISA_FEAT(ISA_FP_DBL) ISA_FEAT(isa_bit_fp16conv))\n-ARM_FPU(\"vfpv3xd\",\t\tISA_FEAT(ISA_VFPv3))\n-ARM_FPU(\"vfpv3xd-fp16\",\t\tISA_FEAT(ISA_VFPv3) ISA_FEAT(isa_bit_fp16conv))\n-ARM_FPU(\"neon\",\t\t\tISA_FEAT(ISA_VFPv3) ISA_FEAT(ISA_NEON))\n-ARM_FPU(\"neon-vfpv3\",\t\tISA_FEAT(ISA_VFPv3) ISA_FEAT(ISA_NEON))\n-ARM_FPU(\"neon-fp16\",\t\tISA_FEAT(ISA_VFPv3) ISA_FEAT(ISA_NEON) ISA_FEAT(isa_bit_fp16conv))\n-ARM_FPU(\"vfpv4\",\t\tISA_FEAT(ISA_VFPv4) ISA_FEAT(ISA_FP_D32))\n-ARM_FPU(\"neon-vfpv4\",\t\tISA_FEAT(ISA_VFPv4) ISA_FEAT(ISA_NEON))\n-ARM_FPU(\"vfpv4-d16\",\t\tISA_FEAT(ISA_VFPv4) ISA_FEAT(ISA_FP_DBL))\n-ARM_FPU(\"fpv4-sp-d16\",\t\tISA_FEAT(ISA_VFPv4))\n-ARM_FPU(\"fpv5-sp-d16\",\t\tISA_FEAT(ISA_FPv5))\n-ARM_FPU(\"fpv5-d16\",\t\tISA_FEAT(ISA_FPv5) ISA_FEAT(ISA_FP_DBL))\n-ARM_FPU(\"fp-armv8\",\t\tISA_FEAT(ISA_FP_ARMv8) ISA_FEAT(ISA_FP_D32))\n-ARM_FPU(\"neon-fp-armv8\",\tISA_FEAT(ISA_FP_ARMv8) ISA_FEAT(ISA_NEON))\n-ARM_FPU(\"crypto-neon-fp-armv8\", ISA_FEAT(ISA_FP_ARMv8) ISA_FEAT(ISA_CRYPTO))\n+ARM_FPU(\"vfp\",\t\t\tvfp,\t\t      ISA_FEAT(ISA_VFPv2) ISA_FEAT(ISA_FP_DBL))\n+ARM_FPU(\"vfpv2\",\t\tvfpv2,\t\t      ISA_FEAT(ISA_VFPv2) ISA_FEAT(ISA_FP_DBL))\n+ARM_FPU(\"vfpv3\",\t\tvfpv3,\t\t      ISA_FEAT(ISA_VFPv3) ISA_FEAT(ISA_FP_D32))\n+ARM_FPU(\"vfpv3-fp16\",\t\tvfpv3_fp16,\t      ISA_FEAT(ISA_VFPv3) ISA_FEAT(ISA_FP_D32) ISA_FEAT(isa_bit_fp16conv))\n+ARM_FPU(\"vfpv3-d16\",\t\tvfpv3_d16,\t      ISA_FEAT(ISA_VFPv3) ISA_FEAT(ISA_FP_DBL))\n+ARM_FPU(\"vfpv3-d16-fp16\",\tvfpv3_d16_fp16,\t      ISA_FEAT(ISA_VFPv3) ISA_FEAT(ISA_FP_DBL) ISA_FEAT(isa_bit_fp16conv))\n+ARM_FPU(\"vfpv3xd\",\t\tvfpv3xd,\t      ISA_FEAT(ISA_VFPv3))\n+ARM_FPU(\"vfpv3xd-fp16\",\t\tvfpv3xd_fp16,\t      ISA_FEAT(ISA_VFPv3) ISA_FEAT(isa_bit_fp16conv))\n+ARM_FPU(\"neon\",\t\t\tneon,\t\t      ISA_FEAT(ISA_VFPv3) ISA_FEAT(ISA_NEON))\n+ARM_FPU(\"neon-vfpv3\",\t\tneon_vfpv3,\t      ISA_FEAT(ISA_VFPv3) ISA_FEAT(ISA_NEON))\n+ARM_FPU(\"neon-fp16\",\t\tneon_fp16,\t      ISA_FEAT(ISA_VFPv3) ISA_FEAT(ISA_NEON) ISA_FEAT(isa_bit_fp16conv))\n+ARM_FPU(\"vfpv4\",\t\tvfpv4,\t\t      ISA_FEAT(ISA_VFPv4) ISA_FEAT(ISA_FP_D32))\n+ARM_FPU(\"neon-vfpv4\",\t\tneon_vfpv4,\t      ISA_FEAT(ISA_VFPv4) ISA_FEAT(ISA_NEON))\n+ARM_FPU(\"vfpv4-d16\",\t\tvfpv4_d16,\t      ISA_FEAT(ISA_VFPv4) ISA_FEAT(ISA_FP_DBL))\n+ARM_FPU(\"fpv4-sp-d16\",\t\tfpv4_sp_d16,\t      ISA_FEAT(ISA_VFPv4))\n+ARM_FPU(\"fpv5-sp-d16\",\t\tfpv5_sp_d16,\t      ISA_FEAT(ISA_FPv5))\n+ARM_FPU(\"fpv5-d16\",\t\tfpv5_d16,\t      ISA_FEAT(ISA_FPv5) ISA_FEAT(ISA_FP_DBL))\n+ARM_FPU(\"fp-armv8\",\t\tfp_armv8,\t      ISA_FEAT(ISA_FP_ARMv8) ISA_FEAT(ISA_FP_D32))\n+ARM_FPU(\"neon-fp-armv8\",\tneon_fp_armv8,\t      ISA_FEAT(ISA_FP_ARMv8) ISA_FEAT(ISA_NEON))\n+ARM_FPU(\"crypto-neon-fp-armv8\", crypto_neon_fp_armv8, ISA_FEAT(ISA_FP_ARMv8) ISA_FEAT(ISA_CRYPTO))\n /* Compatibility aliases.  */\n-ARM_FPU(\"vfp3\",\t\t\tISA_FEAT(ISA_VFPv3) ISA_FEAT(ISA_FP_D32))\n+ARM_FPU(\"vfp3\",\t\t\tvfp3,\t\t      ISA_FEAT(ISA_VFPv3) ISA_FEAT(ISA_FP_D32))"}, {"sha": "846abad18be3c82689b1747e401d04c8aa79fb25", "filename": "gcc/config/arm/arm-opts.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/844af7671ff4805bcbaf42f8b123b6cde2a12cf8/gcc%2Fconfig%2Farm%2Farm-opts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/844af7671ff4805bcbaf42f8b123b6cde2a12cf8/gcc%2Fconfig%2Farm%2Farm-opts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-opts.h?ref=844af7671ff4805bcbaf42f8b123b6cde2a12cf8", "patch": "@@ -40,6 +40,16 @@ enum processor_type\n   TARGET_CPU_arm_none\n };\n \n+/* The various ARM FPUs.  */\n+enum fpu_type\n+{\n+#undef ARM_FPU\n+#define ARM_FPU(NAME, CNAME, ISA) TARGET_FPU_##CNAME,\n+#include \"arm-fpus.def\"\n+  TARGET_FPU_auto\n+#undef ARM_FPU\n+};\n+\n /* Which __fp16 format to use.\n    The enumeration values correspond to the numbering for the\n    Tag_ABI_FP_16bit_format attribute."}, {"sha": "574eadcaa7bde66493511584c0944df8f43296bf", "filename": "gcc/config/arm/arm-tables.opt", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/844af7671ff4805bcbaf42f8b123b6cde2a12cf8/gcc%2Fconfig%2Farm%2Farm-tables.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/844af7671ff4805bcbaf42f8b123b6cde2a12cf8/gcc%2Fconfig%2Farm%2Farm-tables.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-tables.opt?ref=844af7671ff4805bcbaf42f8b123b6cde2a12cf8", "patch": "@@ -464,69 +464,71 @@ EnumValue\n Enum(arm_arch) String(iwmmxt2) Value(34)\n \n Enum\n-Name(arm_fpu) Type(int)\n+Name(arm_fpu) Type(enum fpu_type)\n Known ARM FPUs (for use with the -mfpu= option):\n \n EnumValue\n-Enum(arm_fpu) String(vfp) Value(0)\n+Enum(arm_fpu) String(vfp) Value(TARGET_FPU_vfp)\n \n EnumValue\n-Enum(arm_fpu) String(vfpv2) Value(1)\n+Enum(arm_fpu) String(vfpv2) Value(TARGET_FPU_vfpv2)\n \n EnumValue\n-Enum(arm_fpu) String(vfpv3) Value(2)\n+Enum(arm_fpu) String(vfpv3) Value(TARGET_FPU_vfpv3)\n \n EnumValue\n-Enum(arm_fpu) String(vfpv3-fp16) Value(3)\n+Enum(arm_fpu) String(vfpv3-fp16) Value(TARGET_FPU_vfpv3_fp16)\n \n EnumValue\n-Enum(arm_fpu) String(vfpv3-d16) Value(4)\n+Enum(arm_fpu) String(vfpv3-d16) Value(TARGET_FPU_vfpv3_d16)\n \n EnumValue\n-Enum(arm_fpu) String(vfpv3-d16-fp16) Value(5)\n+Enum(arm_fpu) String(vfpv3-d16-fp16) Value(TARGET_FPU_vfpv3_d16_fp16)\n \n EnumValue\n-Enum(arm_fpu) String(vfpv3xd) Value(6)\n+Enum(arm_fpu) String(vfpv3xd) Value(TARGET_FPU_vfpv3xd)\n \n EnumValue\n-Enum(arm_fpu) String(vfpv3xd-fp16) Value(7)\n+Enum(arm_fpu) String(vfpv3xd-fp16) Value(TARGET_FPU_vfpv3xd_fp16)\n \n EnumValue\n-Enum(arm_fpu) String(neon) Value(8)\n+Enum(arm_fpu) String(neon) Value(TARGET_FPU_neon)\n \n EnumValue\n-Enum(arm_fpu) String(neon-vfpv3) Value(9)\n+Enum(arm_fpu) String(neon-vfpv3) Value(TARGET_FPU_neon_vfpv3)\n \n EnumValue\n-Enum(arm_fpu) String(neon-fp16) Value(10)\n+Enum(arm_fpu) String(neon-fp16) Value(TARGET_FPU_neon_fp16)\n \n EnumValue\n-Enum(arm_fpu) String(vfpv4) Value(11)\n+Enum(arm_fpu) String(vfpv4) Value(TARGET_FPU_vfpv4)\n \n EnumValue\n-Enum(arm_fpu) String(neon-vfpv4) Value(12)\n+Enum(arm_fpu) String(neon-vfpv4) Value(TARGET_FPU_neon_vfpv4)\n \n EnumValue\n-Enum(arm_fpu) String(vfpv4-d16) Value(13)\n+Enum(arm_fpu) String(vfpv4-d16) Value(TARGET_FPU_vfpv4_d16)\n \n EnumValue\n-Enum(arm_fpu) String(fpv4-sp-d16) Value(14)\n+Enum(arm_fpu) String(fpv4-sp-d16) Value(TARGET_FPU_fpv4_sp_d16)\n \n EnumValue\n-Enum(arm_fpu) String(fpv5-sp-d16) Value(15)\n+Enum(arm_fpu) String(fpv5-sp-d16) Value(TARGET_FPU_fpv5_sp_d16)\n \n EnumValue\n-Enum(arm_fpu) String(fpv5-d16) Value(16)\n+Enum(arm_fpu) String(fpv5-d16) Value(TARGET_FPU_fpv5_d16)\n \n EnumValue\n-Enum(arm_fpu) String(fp-armv8) Value(17)\n+Enum(arm_fpu) String(fp-armv8) Value(TARGET_FPU_fp_armv8)\n \n EnumValue\n-Enum(arm_fpu) String(neon-fp-armv8) Value(18)\n+Enum(arm_fpu) String(neon-fp-armv8) Value(TARGET_FPU_neon_fp_armv8)\n \n EnumValue\n-Enum(arm_fpu) String(crypto-neon-fp-armv8) Value(19)\n+Enum(arm_fpu) String(crypto-neon-fp-armv8) Value(TARGET_FPU_crypto_neon_fp_armv8)\n \n EnumValue\n-Enum(arm_fpu) String(vfp3) Value(20)\n+Enum(arm_fpu) String(vfp3) Value(TARGET_FPU_vfp3)\n \n+EnumValue\n+Enum(arm_fpu) String(auto) Value(TARGET_FPU_auto)"}, {"sha": "f068796dbae5fd39ea523d7cbb2ff83e5f87c773", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 44, "deletions": 11, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/844af7671ff4805bcbaf42f8b123b6cde2a12cf8/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/844af7671ff4805bcbaf42f8b123b6cde2a12cf8/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=844af7671ff4805bcbaf42f8b123b6cde2a12cf8", "patch": "@@ -2328,7 +2328,8 @@ char arm_arch_name[] = \"__ARM_ARCH_PROFILE__\";\n \n const struct arm_fpu_desc all_fpus[] =\n {\n-#define ARM_FPU(NAME, ISA)\t\t\\\n+#undef ARM_FPU\n+#define ARM_FPU(NAME, CNAME, ISA)\t\\\n   { NAME, {ISA isa_nobit} },\n #include \"arm-fpus.def\"\n #undef ARM_FPU\n@@ -3255,12 +3256,19 @@ arm_configure_build_target (struct arm_build_target *target,\n \n   gcc_assert (arm_selected_cpu);\n \n-  arm_selected_fpu = &all_fpus[opts->x_arm_fpu_index];\n-  auto_sbitmap fpu_bits (isa_num_bits);\n+  if (opts->x_arm_fpu_index != TARGET_FPU_auto)\n+    {\n+      arm_selected_fpu = &all_fpus[opts->x_arm_fpu_index];\n+      auto_sbitmap fpu_bits (isa_num_bits);\n \n-  arm_initialize_isa (fpu_bits, arm_selected_fpu->isa_bits);\n-  bitmap_and_compl (target->isa, target->isa, isa_all_fpubits);\n-  bitmap_ior (target->isa, target->isa, fpu_bits);\n+      arm_initialize_isa (fpu_bits, arm_selected_fpu->isa_bits);\n+      bitmap_and_compl (target->isa, target->isa, isa_all_fpubits);\n+      bitmap_ior (target->isa, target->isa, fpu_bits);\n+    }\n+  else if (target->core_name == NULL)\n+    /* To support this we need to be able to parse FPU feature options\n+       from the architecture string.  */\n+    sorry (\"-mfpu=auto not currently supported without an explicit CPU.\");\n \n   /* The selected cpu may be an architecture, so lookup tuning by core ID.  */\n   if (!arm_selected_tune)\n@@ -3295,16 +3303,18 @@ arm_option_override (void)\n     {\n       const char *target_fpu_name;\n       bool ok;\n+      int fpu_index;\n \n #ifdef FPUTYPE_DEFAULT\n       target_fpu_name = FPUTYPE_DEFAULT;\n #else\n       target_fpu_name = \"vfp\";\n #endif\n \n-      ok = opt_enum_arg_to_value (OPT_mfpu_, target_fpu_name, &arm_fpu_index,\n+      ok = opt_enum_arg_to_value (OPT_mfpu_, target_fpu_name, &fpu_index,\n \t\t\t\t  CL_TARGET);\n       gcc_assert (ok);\n+      arm_fpu_index = (enum fpu_type) fpu_index;\n     }\n \n   /* Create the default target_options structure.  We need this early\n@@ -3448,7 +3458,11 @@ arm_option_override (void)\n \tarm_pcs_default = ARM_PCS_AAPCS_IWMMXT;\n       else if (arm_float_abi == ARM_FLOAT_ABI_HARD\n \t       && TARGET_HARD_FLOAT)\n-\tarm_pcs_default = ARM_PCS_AAPCS_VFP;\n+\t{\n+\t  arm_pcs_default = ARM_PCS_AAPCS_VFP;\n+\t  if (!bitmap_bit_p (arm_active_target.isa, isa_bit_VFPv2))\n+\t    error (\"-mfloat-abi=hard: selected processor lacks an FPU\");\n+\t}\n       else\n \tarm_pcs_default = ARM_PCS_AAPCS;\n     }\n@@ -30210,14 +30224,17 @@ static void\n arm_option_print (FILE *file, int indent, struct cl_target_option *ptr)\n {\n   int flags = ptr->x_target_flags;\n-  const struct arm_fpu_desc *fpu_desc = &all_fpus[ptr->x_arm_fpu_index];\n+  const char *fpu_name;\n+\n+  fpu_name = (ptr->x_arm_fpu_index == TARGET_FPU_auto\n+\t      ? \"auto\" : all_fpus[ptr->x_arm_fpu_index].name);\n \n   fprintf (file, \"%*sselected arch %s\\n\", indent, \"\",\n \t   TARGET_THUMB2_P (flags) ? \"thumb2\" :\n \t   TARGET_THUMB_P (flags) ? \"thumb1\" :\n \t   \"arm\");\n \n-  fprintf (file, \"%*sselected fpu %s\\n\", indent, \"\", fpu_desc->name);\n+  fprintf (file, \"%*sselected fpu %s\\n\", indent, \"\", fpu_name);\n }\n \n /* Hook to determine if one function can safely inline another.  */\n@@ -30319,12 +30336,22 @@ arm_valid_target_attribute_rec (tree args, struct gcc_options *opts)\n \n       else if (!strncmp (q, \"fpu=\", 4))\n \t{\n+\t  int fpu_index;\n \t  if (! opt_enum_arg_to_value (OPT_mfpu_, q+4,\n-\t\t\t\t       &opts->x_arm_fpu_index, CL_TARGET))\n+\t\t\t\t       &fpu_index, CL_TARGET))\n \t    {\n \t      error (\"invalid fpu for attribute(target(\\\"%s\\\"))\", q);\n \t      return false;\n \t    }\n+\t  if (fpu_index == TARGET_FPU_auto)\n+\t    {\n+\t      /* This doesn't really make sense until we support\n+\t\t general dynamic selection of the architecture and all\n+\t\t sub-features.  */\n+\t      sorry (\"auto fpu selection not currently permitted here\");\n+\t      return false;\n+\t    }\n+\t  opts->x_arm_fpu_index = (enum fpu_type) fpu_index;\n \t}\n       else\n \t{\n@@ -30465,6 +30492,12 @@ arm_identify_fpu_from_isa (sbitmap isa)\n   auto_sbitmap cand_fpubits (isa_num_bits);\n \n   bitmap_and (fpubits, isa, isa_all_fpubits);\n+\n+  /* If there are no ISA feature bits relating to the FPU, we must be\n+     doing soft-float.  */\n+  if (bitmap_empty_p (fpubits))\n+    return \"softvfp\";\n+\n   for (unsigned int i = 0; i < ARRAY_SIZE (all_fpus); i++)\n     {\n       arm_initialize_isa (cand_fpubits, all_fpus[i].isa_bits);"}, {"sha": "3c877b143e45cb07990963acd625a9f5906705cd", "filename": "gcc/config/arm/arm.opt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/844af7671ff4805bcbaf42f8b123b6cde2a12cf8/gcc%2Fconfig%2Farm%2Farm.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/844af7671ff4805bcbaf42f8b123b6cde2a12cf8/gcc%2Fconfig%2Farm%2Farm.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.opt?ref=844af7671ff4805bcbaf42f8b123b6cde2a12cf8", "patch": "@@ -144,7 +144,7 @@ EnumValue\n Enum(arm_fp16_format_type) String(alternative) Value(ARM_FP16_FORMAT_ALTERNATIVE)\n \n mfpu=\n-Target RejectNegative Joined Enum(arm_fpu) Var(arm_fpu_index) Save\n+Target RejectNegative Joined Enum(arm_fpu) Var(arm_fpu_index) Init(TARGET_FPU_auto) Save\n Specify the name of the target floating point hardware/format.\n \n mhard-float"}, {"sha": "3b757111ff1d9c0c2f42f57f1e5bd32db0b96653", "filename": "gcc/config/arm/genopt.sh", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/844af7671ff4805bcbaf42f8b123b6cde2a12cf8/gcc%2Fconfig%2Farm%2Fgenopt.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/844af7671ff4805bcbaf42f8b123b6cde2a12cf8/gcc%2Fconfig%2Farm%2Fgenopt.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fgenopt.sh?ref=844af7671ff4805bcbaf42f8b123b6cde2a12cf8", "patch": "@@ -77,19 +77,22 @@ awk -F'[(, \t]+' 'BEGIN {\n \n cat <<EOF\n Enum\n-Name(arm_fpu) Type(int)\n+Name(arm_fpu) Type(enum fpu_type)\n Known ARM FPUs (for use with the -mfpu= option):\n \n EOF\n \n-awk -F'[(, \t]+' 'BEGIN {\n-    value = 0\n-}\n+awk -F'[(, \t]+' '\n /^ARM_FPU/ {\n     name = $2\n+    enum = $3\n     gsub(\"\\\"\", \"\", name)\n     print \"EnumValue\"\n-    print \"Enum(arm_fpu) String(\" name \") Value(\" value \")\"\n+    print \"Enum(arm_fpu) String(\" name \") Value(TARGET_FPU_\" enum \")\"\n     print \"\"\n-    value++\n+}\n+END {\n+    print \"EnumValue\"\n+    print \"Enum(arm_fpu) String(auto) Value(TARGET_FPU_auto)\"\n }' $1/arm-fpus.def\n+"}]}