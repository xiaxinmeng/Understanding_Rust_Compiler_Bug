{"sha": "531898c3c23ba05afe22253f9cdee6491882c92c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTMxODk4YzNjMjNiYTA1YWZlMjIyNTNmOWNkZWU2NDkxODgyYzkyYw==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2008-01-09T18:27:27Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2008-01-09T18:27:27Z"}, "message": "iterator.h: Reformat to 80 columns; adjust some inline specifiers.\n\n2008-01-09  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/parallel/iterator.h: Reformat to 80 columns; adjust some\n\tinline specifiers.\n\t* include/parallel/find_selectors.h: Likewise.\n\t* include/parallel/losertree.h: Likewise.\n\t* include/parallel/list_partition.h: Likewise.\n\t* include/parallel/for_each.h: Likewise.\n\t* include/parallel/multiseq_selection.h: Likewise.\n\t* include/parallel/algorithmfwd.h: Likewise.\n\t* include/parallel/for_each_selectors.h: Likewise.\n\t* include/parallel/balanced_quicksort.h: Likewise.\n\t* include/parallel/merge.h: Likewise.\n\t* include/parallel/algobase.h: Likewise.\n\t* include/parallel/find.h: Likewise.\n\t* include/parallel/algo.h: Likewise.\n\t* include/parallel/checkers.h: Likewise.\n\nFrom-SVN: r131431", "tree": {"sha": "920c224ff0f9c9b7cac92a5b66780e964a0d693a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/920c224ff0f9c9b7cac92a5b66780e964a0d693a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/531898c3c23ba05afe22253f9cdee6491882c92c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/531898c3c23ba05afe22253f9cdee6491882c92c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/531898c3c23ba05afe22253f9cdee6491882c92c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/531898c3c23ba05afe22253f9cdee6491882c92c/comments", "author": null, "committer": null, "parents": [{"sha": "c3e203cf80e81a73402d0ae6ba9b3961394c0434", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3e203cf80e81a73402d0ae6ba9b3961394c0434", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3e203cf80e81a73402d0ae6ba9b3961394c0434"}], "stats": {"total": 6483, "additions": 3535, "deletions": 2948}, "files": [{"sha": "81fc6f04e887a659c74a1a4c8e7966b3ddf6586e", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/531898c3c23ba05afe22253f9cdee6491882c92c/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/531898c3c23ba05afe22253f9cdee6491882c92c/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=531898c3c23ba05afe22253f9cdee6491882c92c", "patch": "@@ -1,3 +1,21 @@\n+2008-01-09  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/parallel/iterator.h: Reformat to 80 columns; adjust some\n+\tinline specifiers.\n+\t* include/parallel/find_selectors.h: Likewise.\n+\t* include/parallel/losertree.h: Likewise.\n+\t* include/parallel/list_partition.h: Likewise.\n+\t* include/parallel/for_each.h: Likewise.\n+\t* include/parallel/multiseq_selection.h: Likewise.\n+\t* include/parallel/algorithmfwd.h: Likewise.\n+\t* include/parallel/for_each_selectors.h: Likewise.\n+\t* include/parallel/balanced_quicksort.h: Likewise.\n+\t* include/parallel/merge.h: Likewise.\n+\t* include/parallel/algobase.h: Likewise.\n+\t* include/parallel/find.h: Likewise.\n+\t* include/parallel/algo.h: Likewise.\n+\t* include/parallel/checkers.h: Likewise.\t\n+\n 2008-01-09  Francesco Biscani  <bluescarni@gmail.com>\n \n \t* include/tr1_impl/hashtable (_Hashtable): Fix friend declaration"}, {"sha": "280958818dfb1679b739432d3ea845c88091e2b4", "filename": "libstdc++-v3/include/parallel/algo.h", "status": "modified", "additions": 1689, "deletions": 1352, "changes": 3041, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/531898c3c23ba05afe22253f9cdee6491882c92c/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/531898c3c23ba05afe22253f9cdee6491882c92c/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgo.h?ref=531898c3c23ba05afe22253f9cdee6491882c92c"}, {"sha": "4b3e6eba5595a82a754b7d863d12de821a8bae63", "filename": "libstdc++-v3/include/parallel/algobase.h", "status": "modified", "additions": 189, "deletions": 174, "changes": 363, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/531898c3c23ba05afe22253f9cdee6491882c92c/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgobase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/531898c3c23ba05afe22253f9cdee6491882c92c/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgobase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgobase.h?ref=531898c3c23ba05afe22253f9cdee6491882c92c", "patch": "@@ -1,6 +1,6 @@\n // -*- C++ -*-\n \n-// Copyright (C) 2007 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the terms\n@@ -57,215 +57,230 @@ namespace __parallel\n \n   // Sequential fallback\n   template<typename InputIterator1, typename InputIterator2>\n-  inline pair<InputIterator1, InputIterator2>\n-  mismatch(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, \n-\t   __gnu_parallel::sequential_tag)\n-  { return _GLIBCXX_STD_P::mismatch(begin1, end1, begin2); }\n+    inline pair<InputIterator1, InputIterator2>\n+    mismatch(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, \n+\t     __gnu_parallel::sequential_tag)\n+    { return _GLIBCXX_STD_P::mismatch(begin1, end1, begin2); }\n \n   // Sequential fallback\n-  template<typename InputIterator1, typename InputIterator2, typename Predicate>\n-  inline pair<InputIterator1, InputIterator2>\n-  mismatch(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, \n-\t   Predicate pred, __gnu_parallel::sequential_tag)\n-  { return _GLIBCXX_STD_P::mismatch(begin1, end1, begin2, pred); }\n+  template<typename InputIterator1, typename InputIterator2,\n+\t   typename Predicate>\n+    inline pair<InputIterator1, InputIterator2>\n+    mismatch(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, \n+\t     Predicate pred, __gnu_parallel::sequential_tag)\n+    { return _GLIBCXX_STD_P::mismatch(begin1, end1, begin2, pred); }\n \n   // Sequential fallback for input iterator case\n-  template<typename InputIterator1, typename InputIterator2, typename Predicate, typename IteratorTag1, typename IteratorTag2>\n-  inline pair<InputIterator1, InputIterator2>\n-  mismatch_switch(InputIterator1 begin1, InputIterator1 end1, \n-\t\t  InputIterator2 begin2, Predicate pred, IteratorTag1, \n-\t\t  IteratorTag2)\n-  { return _GLIBCXX_STD_P::mismatch(begin1, end1, begin2, pred); }\n+  template<typename InputIterator1, typename InputIterator2,\n+\t   typename Predicate, typename IteratorTag1, typename IteratorTag2>\n+    inline pair<InputIterator1, InputIterator2>\n+    mismatch_switch(InputIterator1 begin1, InputIterator1 end1, \n+\t\t    InputIterator2 begin2, Predicate pred, IteratorTag1, \n+\t\t    IteratorTag2)\n+    { return _GLIBCXX_STD_P::mismatch(begin1, end1, begin2, pred); }\n \n   // Parallel mismatch for random access iterators\n-  template<typename RandomAccessIterator1, typename RandomAccessIterator2, typename Predicate>\n-  pair<RandomAccessIterator1, RandomAccessIterator2>\n-  mismatch_switch(RandomAccessIterator1 begin1, RandomAccessIterator1 end1, \n-\t\t  RandomAccessIterator2 begin2, Predicate pred, \n-\t\t  random_access_iterator_tag, random_access_iterator_tag)\n-  {\n-    if (_GLIBCXX_PARALLEL_CONDITION(true))\n-      {\n-\tRandomAccessIterator1 res = __gnu_parallel::find_template(begin1, end1, begin2, pred, __gnu_parallel::mismatch_selector()).first;\n-\treturn make_pair(res , begin2 + (res - begin1));\n-      }\n-    else\n-      return _GLIBCXX_STD_P::mismatch(begin1, end1, begin2, pred);\n-  }\n+  template<typename RandomAccessIterator1, typename RandomAccessIterator2,\n+\t   typename Predicate>\n+    pair<RandomAccessIterator1, RandomAccessIterator2>\n+    mismatch_switch(RandomAccessIterator1 begin1, RandomAccessIterator1 end1, \n+\t\t    RandomAccessIterator2 begin2, Predicate pred, \n+\t\t    random_access_iterator_tag, random_access_iterator_tag)\n+    {\n+      if (_GLIBCXX_PARALLEL_CONDITION(true))\n+\t{\n+\t  RandomAccessIterator1 res =\n+\t    __gnu_parallel::find_template(begin1, end1, begin2, pred,\n+\t\t\t\t\t  __gnu_parallel::\n+\t\t\t\t\t  mismatch_selector()).first;\n+\t  return make_pair(res , begin2 + (res - begin1));\n+\t}\n+      else\n+\treturn _GLIBCXX_STD_P::mismatch(begin1, end1, begin2, pred);\n+    }\n \n   // Public interface\n   template<typename InputIterator1, typename InputIterator2>\n-  inline pair<InputIterator1, InputIterator2>\n-  mismatch(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2)\n-  {\n-    typedef std::iterator_traits<InputIterator1> iterator1_traits;\n-    typedef std::iterator_traits<InputIterator2> iterator2_traits;\n-    typedef typename iterator1_traits::value_type value1_type;\n-    typedef typename iterator2_traits::value_type value2_type;\n-    typedef typename iterator1_traits::iterator_category iterator1_category;\n-    typedef typename iterator2_traits::iterator_category iterator2_category;\n-\n-    typedef __gnu_parallel::equal_to<value1_type, value2_type> equal_to_type;\n-\n-    return mismatch_switch(begin1, end1, begin2, equal_to_type(),\n-\t\t\t   iterator1_category(), iterator2_category());\n-  }\n+    inline pair<InputIterator1, InputIterator2>\n+    mismatch(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2)\n+    {\n+      typedef std::iterator_traits<InputIterator1> iterator1_traits;\n+      typedef std::iterator_traits<InputIterator2> iterator2_traits;\n+      typedef typename iterator1_traits::value_type value1_type;\n+      typedef typename iterator2_traits::value_type value2_type;\n+      typedef typename iterator1_traits::iterator_category iterator1_category;\n+      typedef typename iterator2_traits::iterator_category iterator2_category;\n+\n+      typedef __gnu_parallel::equal_to<value1_type, value2_type> equal_to_type;\n+\n+      return mismatch_switch(begin1, end1, begin2, equal_to_type(),\n+\t\t\t     iterator1_category(), iterator2_category());\n+    }\n \n   // Public interface\n-  template<typename InputIterator1, typename InputIterator2, typename Predicate>\n-  inline pair<InputIterator1, InputIterator2>\n-  mismatch(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2,\n-\t   Predicate pred)\n-  {\n-    typedef std::iterator_traits<InputIterator1> iterator1_traits;\n-    typedef std::iterator_traits<InputIterator2> iterator2_traits;\n-    typedef typename iterator1_traits::iterator_category iterator1_category;\n-    typedef typename iterator2_traits::iterator_category iterator2_category;\n-\n-    return mismatch_switch(begin1, end1, begin2, pred, iterator1_category(), \n-\t\t\t   iterator2_category());\n-  }\n+  template<typename InputIterator1, typename InputIterator2,\n+\t   typename Predicate>\n+    inline pair<InputIterator1, InputIterator2>\n+    mismatch(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2,\n+\t     Predicate pred)\n+    {\n+      typedef std::iterator_traits<InputIterator1> iterator1_traits;\n+      typedef std::iterator_traits<InputIterator2> iterator2_traits;\n+      typedef typename iterator1_traits::iterator_category iterator1_category;\n+      typedef typename iterator2_traits::iterator_category iterator2_category;\n+\n+      return mismatch_switch(begin1, end1, begin2, pred, iterator1_category(), \n+\t\t\t     iterator2_category());\n+    }\n \n   // Sequential fallback\n   template<typename InputIterator1, typename InputIterator2>\n-  inline bool\n-  equal(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, \n-\t__gnu_parallel::sequential_tag)\n-  { return _GLIBCXX_STD_P::equal(begin1, end1, begin2); }\n+    inline bool\n+    equal(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, \n+\t  __gnu_parallel::sequential_tag)\n+    { return _GLIBCXX_STD_P::equal(begin1, end1, begin2); }\n \n   // Sequential fallback\n-  template<typename InputIterator1, typename InputIterator2, typename Predicate>\n-  inline bool\n-  equal(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, \n-\tPredicate pred, __gnu_parallel::sequential_tag)\n-  { return _GLIBCXX_STD_P::equal(begin1, end1, begin2, pred); }\n+  template<typename InputIterator1, typename InputIterator2,\n+\t   typename Predicate>\n+    inline bool\n+    equal(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, \n+\t  Predicate pred, __gnu_parallel::sequential_tag)\n+    { return _GLIBCXX_STD_P::equal(begin1, end1, begin2, pred); }\n \n   // Public interface\n   template<typename InputIterator1, typename InputIterator2>\n-  inline bool\n-  equal(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2)\n-  { return mismatch(begin1, end1, begin2).first == end1; }\n+    inline bool\n+    equal(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2)\n+    { return mismatch(begin1, end1, begin2).first == end1; }\n \n   // Public interface\n-  template<typename InputIterator1, typename InputIterator2, typename Predicate>\n-  inline bool\n-  equal(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, \n-\tPredicate pred)\n-  { return mismatch(begin1, end1, begin2, pred).first == end1; }\n+  template<typename InputIterator1, typename InputIterator2,\n+\t   typename Predicate>\n+    inline bool\n+    equal(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, \n+\t  Predicate pred)\n+    { return mismatch(begin1, end1, begin2, pred).first == end1; }\n \n   // Sequential fallback\n   template<typename InputIterator1, typename InputIterator2>\n-  inline bool\n-  lexicographical_compare(InputIterator1 begin1, InputIterator1 end1, \n-\t\t\t  InputIterator2 begin2, InputIterator2 end2, \n-\t\t\t  __gnu_parallel::sequential_tag)\n-  {\n-    return _GLIBCXX_STD_P::lexicographical_compare(begin1, end1, begin2, end2);\n-  }\n+    inline bool\n+    lexicographical_compare(InputIterator1 begin1, InputIterator1 end1, \n+\t\t\t    InputIterator2 begin2, InputIterator2 end2, \n+\t\t\t    __gnu_parallel::sequential_tag)\n+    { return _GLIBCXX_STD_P::lexicographical_compare(begin1, end1,\n+\t\t\t\t\t\t     begin2, end2); }\n \n   // Sequential fallback\n-  template<typename InputIterator1, typename InputIterator2, typename Predicate>\n-  inline bool\n-  lexicographical_compare(InputIterator1 begin1, InputIterator1 end1, \n-\t\t\t  InputIterator2 begin2, InputIterator2 end2, \n-\t\t\t  Predicate pred, __gnu_parallel::sequential_tag)\n-  {\n-    return _GLIBCXX_STD_P::lexicographical_compare(begin1, end1, \n-\t\t\t\t\t\t   begin2, end2, pred);\n-  }\n+  template<typename InputIterator1, typename InputIterator2,\n+\t   typename Predicate>\n+    inline bool\n+    lexicographical_compare(InputIterator1 begin1, InputIterator1 end1, \n+\t\t\t    InputIterator2 begin2, InputIterator2 end2, \n+\t\t\t    Predicate pred, __gnu_parallel::sequential_tag)\n+    { return _GLIBCXX_STD_P::lexicographical_compare(begin1, end1, \n+\t\t\t\t\t\t     begin2, end2, pred); }\n \n   // Sequential fallback for input iterator case\n-  template<typename InputIterator1, typename InputIterator2, typename Predicate, typename IteratorTag1, typename IteratorTag2>\n-  inline bool\n-  lexicographical_compare_switch(InputIterator1 begin1, InputIterator1 end1, \n-\t\t\t\t InputIterator2 begin2, InputIterator2 end2, \n-\t\t\t\t Predicate pred, IteratorTag1, IteratorTag2)\n-  {\n-    return _GLIBCXX_STD_P::lexicographical_compare(begin1, end1, \n-\t\t\t\t\t\t   begin2, end2, pred);\n-  }\n+  template<typename InputIterator1, typename InputIterator2,\n+\t   typename Predicate, typename IteratorTag1, typename IteratorTag2>\n+    inline bool\n+    lexicographical_compare_switch(InputIterator1 begin1, InputIterator1 end1, \n+\t\t\t\t   InputIterator2 begin2, InputIterator2 end2, \n+\t\t\t\t   Predicate pred, IteratorTag1, IteratorTag2)\n+    { return _GLIBCXX_STD_P::lexicographical_compare(begin1, end1, \n+\t\t\t\t\t\t     begin2, end2, pred); }\n \n   // Parallel lexicographical_compare for random access iterators\n   // Limitation: Both valuetypes must be the same\n-  template<typename RandomAccessIterator1, typename RandomAccessIterator2, typename Predicate>\n-  bool\n-  lexicographical_compare_switch(RandomAccessIterator1 begin1, \n-\t\t\t\t RandomAccessIterator1 end1, \n-\t\t\t\t RandomAccessIterator2 begin2, \n-\t\t\t\t RandomAccessIterator2 end2, Predicate pred, \n-\t\t\t\t random_access_iterator_tag, \n-\t\t\t\t random_access_iterator_tag)\n-  {\n-    if (_GLIBCXX_PARALLEL_CONDITION(true))\n-      {\n-\ttypedef iterator_traits<RandomAccessIterator1> traits1_type;\n-\ttypedef typename traits1_type::value_type value1_type;\n-\n-\ttypedef iterator_traits<RandomAccessIterator2> traits2_type;\n-\ttypedef typename traits2_type::value_type value2_type;\n-\t\n-\ttypedef __gnu_parallel::equal_from_less<Predicate, value1_type, value2_type> equal_type;\n-\n-\t// Longer sequence in first place.\n-\tif ((end1 - begin1) < (end2 - begin2))\n-\t  {\n-\t    typedef pair<RandomAccessIterator1, RandomAccessIterator2> pair_type;\n-\t    pair_type mm = mismatch_switch(begin1, end1, begin2, \n-\t\t\t\t\t   equal_type(pred), \n-\t\t\t\t\t   random_access_iterator_tag(), \n-\t\t\t\t\t   random_access_iterator_tag());\n-\n-\t    return (mm.first == end1) || bool(pred(*mm.first, *mm.second));\n-\t  }\n-\telse\n-\t  {\n-\t    typedef pair<RandomAccessIterator2, RandomAccessIterator1> pair_type;\n-\t    pair_type mm = mismatch_switch(begin2, end2, begin1, \n-\t\t\t\t\t   equal_type(pred), \n-\t\t\t\t\t   random_access_iterator_tag(), \n-\t\t\t\t\t   random_access_iterator_tag());\n-\n-\t    return (mm.first != end2) && bool(pred(*mm.second, *mm.first));\n-\t  }\n-      }\n-    else\n-      return _GLIBCXX_STD_P::lexicographical_compare(begin1, end1, begin2, end2, pred);\n-  }\n+  template<typename RandomAccessIterator1, typename RandomAccessIterator2,\n+\t   typename Predicate>\n+    bool\n+    lexicographical_compare_switch(RandomAccessIterator1 begin1, \n+\t\t\t\t   RandomAccessIterator1 end1, \n+\t\t\t\t   RandomAccessIterator2 begin2, \n+\t\t\t\t   RandomAccessIterator2 end2, Predicate pred, \n+\t\t\t\t   random_access_iterator_tag, \n+\t\t\t\t   random_access_iterator_tag)\n+    {\n+      if (_GLIBCXX_PARALLEL_CONDITION(true))\n+\t{\n+\t  typedef iterator_traits<RandomAccessIterator1> traits1_type;\n+\t  typedef typename traits1_type::value_type value1_type;\n+\n+\t  typedef iterator_traits<RandomAccessIterator2> traits2_type;\n+\t  typedef typename traits2_type::value_type value2_type;\n+\n+\t  typedef __gnu_parallel::equal_from_less<Predicate, value1_type,\n+\t                                          value2_type> equal_type;\n+\n+\t  // Longer sequence in first place.\n+\t  if ((end1 - begin1) < (end2 - begin2))\n+\t    {\n+\t      typedef pair<RandomAccessIterator1, RandomAccessIterator2>\n+\t\tpair_type;\n+\t      pair_type mm = mismatch_switch(begin1, end1, begin2, \n+\t\t\t\t\t     equal_type(pred), \n+\t\t\t\t\t     random_access_iterator_tag(), \n+\t\t\t\t\t     random_access_iterator_tag());\n+\n+\t      return (mm.first == end1) || bool(pred(*mm.first, *mm.second));\n+\t    }\n+\t  else\n+\t    {\n+\t      typedef pair<RandomAccessIterator2, RandomAccessIterator1>\n+\t\tpair_type;\n+\t      pair_type mm = mismatch_switch(begin2, end2, begin1, \n+\t\t\t\t\t     equal_type(pred), \n+\t\t\t\t\t     random_access_iterator_tag(), \n+\t\t\t\t\t     random_access_iterator_tag());\n+\n+\t      return (mm.first != end2) && bool(pred(*mm.second, *mm.first));\n+\t    }\n+\t}\n+      else\n+\treturn _GLIBCXX_STD_P::lexicographical_compare(begin1, end1,\n+\t\t\t\t\t\t       begin2, end2, pred);\n+    }\n \n   // Public interface\n   template<typename InputIterator1, typename InputIterator2>\n-  inline bool\n-  lexicographical_compare(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, InputIterator2 end2)\n-  {\n-    typedef iterator_traits<InputIterator1> traits1_type;\n-    typedef typename traits1_type::value_type value1_type;\n-    typedef typename traits1_type::iterator_category iterator1_category;\n-    \n-    typedef iterator_traits<InputIterator2> traits2_type;\n-    typedef typename traits2_type::value_type value2_type;\n-    typedef typename traits2_type::iterator_category iterator2_category;\n-    typedef __gnu_parallel::less<value1_type, value2_type> less_type;\n-\n-    return lexicographical_compare_switch(begin1, end1, begin2, end2, \n-\t\t\t\t\t  less_type(), iterator1_category(), \n-\t\t\t\t\t  iterator2_category());\n-  }\n+    inline bool\n+    lexicographical_compare(InputIterator1 begin1, InputIterator1 end1,\n+\t\t\t    InputIterator2 begin2, InputIterator2 end2)\n+    {\n+      typedef iterator_traits<InputIterator1> traits1_type;\n+      typedef typename traits1_type::value_type value1_type;\n+      typedef typename traits1_type::iterator_category iterator1_category;\n+\n+      typedef iterator_traits<InputIterator2> traits2_type;\n+      typedef typename traits2_type::value_type value2_type;\n+      typedef typename traits2_type::iterator_category iterator2_category;\n+      typedef __gnu_parallel::less<value1_type, value2_type> less_type;\n+\n+      return lexicographical_compare_switch(begin1, end1, begin2, end2, \n+\t\t\t\t\t    less_type(), iterator1_category(), \n+\t\t\t\t\t    iterator2_category());\n+    }\n \n   // Public interface\n-  template<typename InputIterator1, typename InputIterator2, typename Predicate>\n-  inline bool\n-  lexicographical_compare(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, InputIterator2 end2, Predicate pred)\n-  {\n-    typedef iterator_traits<InputIterator1> traits1_type;\n-    typedef typename traits1_type::iterator_category iterator1_category;\n-    \n-    typedef iterator_traits<InputIterator2> traits2_type;\n-    typedef typename traits2_type::iterator_category iterator2_category;\n-\n-    return lexicographical_compare_switch(begin1, end1, begin2, end2, pred, \n-\t\t\t\t\t  iterator1_category(), \n-\t\t\t\t\t  iterator2_category());\n-  }\n+  template<typename InputIterator1, typename InputIterator2,\n+\t   typename Predicate>\n+    inline bool\n+    lexicographical_compare(InputIterator1 begin1, InputIterator1 end1,\n+\t\t\t    InputIterator2 begin2, InputIterator2 end2,\n+\t\t\t    Predicate pred)\n+    {\n+      typedef iterator_traits<InputIterator1> traits1_type;\n+      typedef typename traits1_type::iterator_category iterator1_category;\n+\n+      typedef iterator_traits<InputIterator2> traits2_type;\n+      typedef typename traits2_type::iterator_category iterator2_category;\n+\n+      return lexicographical_compare_switch(begin1, end1, begin2, end2, pred, \n+\t\t\t\t\t    iterator1_category(), \n+\t\t\t\t\t    iterator2_category());\n+    }\n } // end namespace\n } // end namespace\n "}, {"sha": "f4fc1aca825cdb78f3fcdf75ac2d9f8187ce91c7", "filename": "libstdc++-v3/include/parallel/algorithmfwd.h", "status": "modified", "additions": 440, "deletions": 338, "changes": 778, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/531898c3c23ba05afe22253f9cdee6491882c92c/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgorithmfwd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/531898c3c23ba05afe22253f9cdee6491882c92c/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgorithmfwd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgorithmfwd.h?ref=531898c3c23ba05afe22253f9cdee6491882c92c", "patch": "@@ -1,6 +1,6 @@\n // <algorithm> parallel extensions -*- C++ -*-\n \n-// Copyright (C) 2007 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the terms\n@@ -84,291 +84,324 @@ namespace __parallel\n     typename iterator_traits<_IIter>::difference_type\n     count(_IIter, _IIter, const _Tp&);\n \n-  template<typename _IIter, typename T>\n+  template<typename _IIter, typename _Tp>\n     typename iterator_traits<_IIter>::difference_type\n-    count(_IIter, _IIter, const T&, __gnu_parallel::sequential_tag);\n+    count(_IIter, _IIter, const _Tp&, __gnu_parallel::sequential_tag);\n \n-  template<typename _IIter, typename T>\n+  template<typename _IIter, typename _Tp>\n     typename iterator_traits<_IIter>::difference_type\n-    count(_IIter, _IIter, const T&, __gnu_parallel::parallelism);\n+    count(_IIter, _IIter, const _Tp&, __gnu_parallel::parallelism);\n \n-  template<typename _IIter, typename T, typename _IterTag>\n+  template<typename _IIter, typename _Tp, typename _IterTag>\n     typename iterator_traits<_IIter>::difference_type\n-    count_switch(_IIter, _IIter, const T&, _IterTag);\n+    count_switch(_IIter, _IIter, const _Tp&, _IterTag);\n \n-  template<typename _RAIter, typename T>\n+  template<typename _RAIter, typename _Tp>\n     typename iterator_traits<_RAIter>::difference_type\n-    count_switch(_RAIter, _RAIter, const T&, random_access_iterator_tag,\n+    count_switch(_RAIter, _RAIter, const _Tp&, random_access_iterator_tag,\n \t\t __gnu_parallel::parallelism);\n \n \n-  template<typename _IIter, typename Predicate>\n+  template<typename _IIter, typename _Predicate>\n     typename iterator_traits<_IIter>::difference_type\n-    count_if(_IIter, _IIter, Predicate);\n+    count_if(_IIter, _IIter, _Predicate);\n \n-  template<typename _IIter, typename Predicate>\n+  template<typename _IIter, typename _Predicate>\n     typename iterator_traits<_IIter>::difference_type\n-    count_if(_IIter, _IIter, Predicate, __gnu_parallel::sequential_tag);\n+    count_if(_IIter, _IIter, _Predicate, __gnu_parallel::sequential_tag);\n \n-  template<typename _IIter, typename Predicate>\n+  template<typename _IIter, typename _Predicate>\n     typename iterator_traits<_IIter>::difference_type\n-    count_if(_IIter, _IIter, Predicate, __gnu_parallel::parallelism);\n+    count_if(_IIter, _IIter, _Predicate, __gnu_parallel::parallelism);\n \n-  template<typename _IIter, typename Predicate, typename _IterTag>\n+  template<typename _IIter, typename _Predicate, typename _IterTag>\n     typename iterator_traits<_IIter>::difference_type\n-    count_if_switch(_IIter, _IIter, Predicate, _IterTag);\n+    count_if_switch(_IIter, _IIter, _Predicate, _IterTag);\n \n-  template<typename _RAIter, typename Predicate>\n+  template<typename _RAIter, typename _Predicate>\n     typename iterator_traits<_RAIter>::difference_type\n-    count_if_switch(_RAIter, _RAIter, Predicate, random_access_iterator_tag, \n+    count_if_switch(_RAIter, _RAIter, _Predicate, random_access_iterator_tag,\n \t\t    __gnu_parallel::parallelism);\n \n   // algobase.h\n   template<typename _IIter1, typename _IIter2>\n-  bool\n-  equal(_IIter1, _IIter1, _IIter2, __gnu_parallel::sequential_tag);\n+    bool\n+    equal(_IIter1, _IIter1, _IIter2, __gnu_parallel::sequential_tag);\n \n   template<typename _IIter1, typename _IIter2, typename Predicate>\n-  bool\n-  equal(_IIter1, _IIter1, _IIter2, Predicate, __gnu_parallel::sequential_tag);\n+    bool\n+    equal(_IIter1, _IIter1, _IIter2, Predicate,\n+\t  __gnu_parallel::sequential_tag);\n \n   template<typename _IIter1, typename _IIter2>\n-  bool\n-  equal(_IIter1, _IIter1, _IIter2);\n+    bool\n+    equal(_IIter1, _IIter1, _IIter2);\n \n   template<typename _IIter1, typename _IIter2, typename Predicate>\n-  bool\n-  equal(_IIter1, _IIter1, _IIter2, Predicate);\n+    bool\n+    equal(_IIter1, _IIter1, _IIter2, Predicate);\n \n-  template<typename _IIter, typename T>\n-  _IIter\n-  find(_IIter, _IIter, const T&, __gnu_parallel::sequential_tag);\n+  template<typename _IIter, typename _Tp>\n+    _IIter\n+    find(_IIter, _IIter, const _Tp&, __gnu_parallel::sequential_tag);\n \n-  template<typename _IIter, typename T>\n-  _IIter\n-  find(_IIter, _IIter, const T& val);\n+  template<typename _IIter, typename _Tp>\n+    _IIter\n+    find(_IIter, _IIter, const _Tp& val);\n \n-  template<typename _IIter, typename T, typename _IterTag>\n-  _IIter\n-  find_switch(_IIter, _IIter, const T&, _IterTag);\n+  template<typename _IIter, typename _Tp, typename _IterTag>\n+    _IIter\n+    find_switch(_IIter, _IIter, const _Tp&, _IterTag);\n \n-  template<typename _RAIter, typename T>\n-  _RAIter\n-  find_switch(_RAIter, _RAIter, const T&, random_access_iterator_tag);\n+  template<typename _RAIter, typename _Tp>\n+    _RAIter\n+    find_switch(_RAIter, _RAIter, const _Tp&, random_access_iterator_tag);\n \n-  template<typename _IIter, typename Predicate>\n-  _IIter\n-  find_if(_IIter, _IIter, Predicate, __gnu_parallel::sequential_tag);\n+  template<typename _IIter, typename _Predicate>\n+    _IIter\n+    find_if(_IIter, _IIter, _Predicate, __gnu_parallel::sequential_tag);\n \n-  template<typename _IIter, typename Predicate>\n-  _IIter\n-  find_if(_IIter, _IIter, Predicate);\n+  template<typename _IIter, typename _Predicate>\n+    _IIter\n+    find_if(_IIter, _IIter, _Predicate);\n \n-  template<typename _IIter, typename Predicate, typename _IterTag>\n-  _IIter\n-  find_if_switch(_IIter, _IIter, Predicate, _IterTag);\n+  template<typename _IIter, typename _Predicate, typename _IterTag>\n+    _IIter\n+    find_if_switch(_IIter, _IIter, _Predicate, _IterTag);\n \n-  template<typename _RAIter, typename Predicate>\n-  _RAIter\n-  find_if_switch(_RAIter, _RAIter, Predicate, random_access_iterator_tag);\n+  template<typename _RAIter, typename _Predicate>\n+    _RAIter\n+    find_if_switch(_RAIter, _RAIter, _Predicate, random_access_iterator_tag);\n \n   template<typename _IIter, typename _FIter>\n-  _IIter\n-  find_first_of(_IIter, _IIter, _FIter, _FIter, __gnu_parallel::sequential_tag);\n+    _IIter\n+    find_first_of(_IIter, _IIter, _FIter, _FIter,\n+\t\t  __gnu_parallel::sequential_tag);\n \n   template<typename _IIter, typename _FIter, typename _BiPredicate>\n-  _IIter\n-  find_first_of(_IIter, _IIter, _FIter, _FIter, _BiPredicate, __gnu_parallel::sequential_tag);\n+    _IIter\n+    find_first_of(_IIter, _IIter, _FIter, _FIter, _BiPredicate,\n+\t\t  __gnu_parallel::sequential_tag);\n \n   template<typename _IIter, typename _FIter, typename _BiPredicate>\n-  _IIter\n-  find_first_of(_IIter, _IIter, _FIter, _FIter, _BiPredicate);\n+    _IIter\n+    find_first_of(_IIter, _IIter, _FIter, _FIter, _BiPredicate);\n \n   template<typename _IIter, typename _FIter>\n-  _IIter\n-  find_first_of(_IIter, _IIter, _FIter, _FIter);\n+    _IIter\n+    find_first_of(_IIter, _IIter, _FIter, _FIter);\n \n-  template<typename _IIter, typename _FIter, typename _IterTag1, typename _IterTag2>\n-  _IIter\n-  find_first_of_switch(_IIter, _IIter, _FIter, _FIter, _IterTag1, _IterTag2);\n+  template<typename _IIter, typename _FIter,\n+\t   typename _IterTag1, typename _IterTag2>\n+    _IIter\n+    find_first_of_switch(_IIter, _IIter, _FIter, _FIter, _IterTag1, _IterTag2);\n \n-  template<typename _RAIter, typename _FIter, typename _BiPredicate, typename _IterTag>\n-  _RAIter\n-  find_first_of_switch(_RAIter, _RAIter, _FIter, _FIter, _BiPredicate, random_access_iterator_tag, _IterTag);\n+  template<typename _RAIter, typename _FIter, typename _BiPredicate,\n+\t   typename _IterTag>\n+    _RAIter\n+    find_first_of_switch(_RAIter, _RAIter, _FIter, _FIter, _BiPredicate,\n+\t\t\t random_access_iterator_tag, _IterTag);\n \n-  template<typename _IIter, typename _FIter, typename _BiPredicate, typename _IterTag1, typename _IterTag2>\n-  _IIter\n-  find_first_of_switch(_IIter, _IIter, _FIter, _FIter, _BiPredicate, _IterTag1, _IterTag2);\n+  template<typename _IIter, typename _FIter, typename _BiPredicate,\n+\t   typename _IterTag1, typename _IterTag2>\n+    _IIter\n+    find_first_of_switch(_IIter, _IIter, _FIter, _FIter, _BiPredicate,\n+\t\t\t _IterTag1, _IterTag2);\n \n \n-  template<typename _IIter, typename Function>\n-    Function\n-    for_each(_IIter, _IIter, Function);\n+  template<typename _IIter, typename _Function>\n+    _Function\n+    for_each(_IIter, _IIter, _Function);\n \n-  template<typename _IIter, typename Function>\n-    Function\n-    for_each(_IIter, _IIter, Function, __gnu_parallel::sequential_tag);\n+  template<typename _IIter, typename _Function>\n+    _Function\n+    for_each(_IIter, _IIter, _Function, __gnu_parallel::sequential_tag);\n \n-  template<typename Iterator, typename Function>\n-    Function\n-    for_each(Iterator, Iterator, Function, __gnu_parallel::parallelism);\n+  template<typename _Iterator, typename _Function>\n+    _Function\n+    for_each(_Iterator, _Iterator, _Function, __gnu_parallel::parallelism);\n \n-  template<typename _IIter, typename Function, typename _IterTag>\n-    Function\n-    for_each_switch(_IIter, _IIter, Function, _IterTag);\n+  template<typename _IIter, typename _Function, typename _IterTag>\n+    _Function\n+    for_each_switch(_IIter, _IIter, _Function, _IterTag);\n \n-  template<typename _RAIter, typename Function>\n-    Function\n-    for_each_switch(_RAIter, _RAIter, Function, random_access_iterator_tag, \n+  template<typename _RAIter, typename _Function>\n+    _Function\n+    for_each_switch(_RAIter, _RAIter, _Function, random_access_iterator_tag, \n \t\t    __gnu_parallel::parallelism);\n \n \n-  template<typename _FIter, typename Generator>\n+  template<typename _FIter, typename _Generator>\n     void\n-    generate(_FIter, _FIter, Generator);\n+    generate(_FIter, _FIter, _Generator);\n \n-  template<typename _FIter, typename Generator>\n+  template<typename _FIter, typename _Generator>\n     void\n-    generate(_FIter, _FIter, Generator, __gnu_parallel::sequential_tag);\n+    generate(_FIter, _FIter, _Generator, __gnu_parallel::sequential_tag);\n \n-  template<typename _FIter, typename Generator>\n+  template<typename _FIter, typename _Generator>\n     void\n-    generate(_FIter, _FIter, Generator, __gnu_parallel::parallelism);\n+    generate(_FIter, _FIter, _Generator, __gnu_parallel::parallelism);\n \n-  template<typename _FIter, typename Generator, typename _IterTag>\n+  template<typename _FIter, typename _Generator, typename _IterTag>\n     void\n-    generate_switch(_FIter, _FIter, Generator, _IterTag);\n+    generate_switch(_FIter, _FIter, _Generator, _IterTag);\n \n-  template<typename _RAIter, typename Generator>\n+  template<typename _RAIter, typename _Generator>\n     void\n-    generate_switch(_RAIter, _RAIter, Generator, random_access_iterator_tag, \n+    generate_switch(_RAIter, _RAIter, _Generator, random_access_iterator_tag, \n \t\t    __gnu_parallel::parallelism);\n \n-  template<typename _OIter, typename Size, typename Generator>\n+  template<typename _OIter, typename _Size, typename _Generator>\n     _OIter\n-    generate_n(_OIter, Size, Generator);\n+    generate_n(_OIter, _Size, _Generator);\n \n-  template<typename _OIter, typename Size, typename Generator>\n+  template<typename _OIter, typename _Size, typename _Generator>\n     _OIter\n-    generate_n(_OIter, Size, Generator, __gnu_parallel::sequential_tag);\n+    generate_n(_OIter, _Size, _Generator, __gnu_parallel::sequential_tag);\n \n-  template<typename _OIter, typename Size, typename Generator>\n+  template<typename _OIter, typename _Size, typename _Generator>\n     _OIter\n-    generate_n(_OIter, Size, Generator, __gnu_parallel::parallelism);\n+    generate_n(_OIter, _Size, _Generator, __gnu_parallel::parallelism);\n \n-  template<typename _OIter, typename Size, typename Generator, typename _IterTag>\n+  template<typename _OIter, typename _Size, typename _Generator,\n+\t   typename _IterTag>\n     _OIter\n-    generate_n_switch(_OIter, Size, Generator, _IterTag);\n+    generate_n_switch(_OIter, _Size, _Generator, _IterTag);\n \n-  template<typename _RAIter, typename Size, typename Generator>\n+  template<typename _RAIter, typename _Size, typename _Generator>\n     _RAIter\n-    generate_n_switch(_RAIter, Size, Generator, random_access_iterator_tag, \n+    generate_n_switch(_RAIter, _Size, _Generator, random_access_iterator_tag, \n \t\t      __gnu_parallel::parallelism);\n \n   template<typename _IIter1, typename _IIter2>\n-  bool\n-  lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2, __gnu_parallel::sequential_tag);\n+    bool\n+    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2,\n+\t\t\t    __gnu_parallel::sequential_tag);\n \n-  template<typename _IIter1, typename _IIter2, typename Predicate>\n-  bool\n-  lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2, Predicate, __gnu_parallel::sequential_tag);\n+  template<typename _IIter1, typename _IIter2, typename _Predicate>\n+    bool\n+    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2, _Predicate,\n+\t\t\t    __gnu_parallel::sequential_tag);\n \n   template<typename _IIter1, typename _IIter2>\n-  bool\n-  lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2);\n+    bool\n+    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2);\n \n-  template<typename _IIter1, typename _IIter2, typename Predicate>\n-  bool\n-  lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2, Predicate);\n+  template<typename _IIter1, typename _IIter2, typename _Predicate>\n+    bool\n+    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2, _Predicate);\n \n-  template<typename _IIter1, typename _IIter2, typename Predicate, typename _IterTag1, typename _IterTag2>\n-  bool\n-  lexicographical_compare_switch(_IIter1, _IIter1, _IIter2, _IIter2, Predicate, _IterTag1, _IterTag2);\n+  template<typename _IIter1, typename _IIter2,\n+\t   typename _Predicate, typename _IterTag1, typename _IterTag2>\n+    bool\n+    lexicographical_compare_switch(_IIter1, _IIter1, _IIter2, _IIter2,\n+\t\t\t\t   _Predicate, _IterTag1, _IterTag2);\n \n-  template<typename _RAIter1, typename _RAIter2, typename Predicate>\n-  bool\n-  lexicographical_compare_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2, Predicate, random_access_iterator_tag, random_access_iterator_tag);\n+  template<typename _RAIter1, typename _RAIter2, typename _Predicate>\n+    bool\n+    lexicographical_compare_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2,\n+\t\t\t\t   _Predicate, random_access_iterator_tag,\n+\t\t\t\t   random_access_iterator_tag);\n \n   // algo.h\n   template<typename _IIter1, typename _IIter2>\n-  pair<_IIter1, _IIter2>\n-  mismatch(_IIter1, _IIter1, _IIter2, __gnu_parallel::sequential_tag);\n+    pair<_IIter1, _IIter2>\n+    mismatch(_IIter1, _IIter1, _IIter2, __gnu_parallel::sequential_tag);\n \n-  template<typename _IIter1, typename _IIter2, typename Predicate>\n-  pair<_IIter1, _IIter2>\n-  mismatch(_IIter1, _IIter1, _IIter2, Predicate, __gnu_parallel::sequential_tag);\n+  template<typename _IIter1, typename _IIter2, typename _Predicate>\n+    pair<_IIter1, _IIter2>\n+    mismatch(_IIter1, _IIter1, _IIter2, _Predicate,\n+\t     __gnu_parallel::sequential_tag);\n \n   template<typename _IIter1, typename _IIter2>\n-  pair<_IIter1, _IIter2>\n-  mismatch(_IIter1, _IIter1, _IIter2);\n+    pair<_IIter1, _IIter2>\n+    mismatch(_IIter1, _IIter1, _IIter2);\n \n-  template<typename _IIter1, typename _IIter2, typename Predicate>\n-  pair<_IIter1, _IIter2>\n-  mismatch(_IIter1, _IIter1, _IIter2, Predicate);\n+  template<typename _IIter1, typename _IIter2, typename _Predicate>\n+    pair<_IIter1, _IIter2>\n+    mismatch(_IIter1, _IIter1, _IIter2, _Predicate);\n \n-  template<typename _IIter1, typename _IIter2, typename Predicate, typename _IterTag1, typename _IterTag2>\n-  pair<_IIter1, _IIter2>\n-  mismatch_switch(_IIter1, _IIter1, _IIter2, Predicate, _IterTag1, _IterTag2);\n+  template<typename _IIter1, typename _IIter2, typename _Predicate,\n+\t   typename _IterTag1, typename _IterTag2>\n+    pair<_IIter1, _IIter2>\n+    mismatch_switch(_IIter1, _IIter1, _IIter2, _Predicate,\n+\t\t    _IterTag1, _IterTag2);\n \n-  template<typename _RAIter1, typename _RAIter2, typename Predicate>\n-  pair<_RAIter1, _RAIter2>\n-  mismatch_switch(_RAIter1, _RAIter1, _RAIter2, Predicate, random_access_iterator_tag, random_access_iterator_tag);\n+  template<typename _RAIter1, typename _RAIter2, typename _Predicate>\n+    pair<_RAIter1, _RAIter2>\n+    mismatch_switch(_RAIter1, _RAIter1, _RAIter2, _Predicate,\n+\t\t    random_access_iterator_tag, random_access_iterator_tag);\n \n   template<typename _FIter1, typename _FIter2>\n-  _FIter1\n-  search(_FIter1, _FIter1, _FIter2, _FIter2, __gnu_parallel::sequential_tag);\n+    _FIter1\n+    search(_FIter1, _FIter1, _FIter2, _FIter2, __gnu_parallel::sequential_tag);\n \n   template<typename _FIter1, typename _FIter2>\n-  _FIter1\n-  search(_FIter1, _FIter1, _FIter2, _FIter2);\n+    _FIter1\n+    search(_FIter1, _FIter1, _FIter2, _FIter2);\n \n   template<typename _FIter1, typename _FIter2, typename _BiPredicate>\n-  _FIter1\n-  search(_FIter1, _FIter1, _FIter2, _FIter2, _BiPredicate, __gnu_parallel::sequential_tag);\n+    _FIter1\n+    search(_FIter1, _FIter1, _FIter2, _FIter2, _BiPredicate,\n+\t   __gnu_parallel::sequential_tag);\n \n   template<typename _FIter1, typename _FIter2, typename _BiPredicate>\n-  _FIter1\n-  search(_FIter1, _FIter1, _FIter2, _FIter2, _BiPredicate);\n+    _FIter1\n+    search(_FIter1, _FIter1, _FIter2, _FIter2, _BiPredicate);\n \n   template<typename _RAIter1, typename _RAIter2>\n-  _RAIter1\n-  search_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2, random_access_iterator_tag, random_access_iterator_tag);\n+    _RAIter1\n+    search_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2,\n+\t\t  random_access_iterator_tag, random_access_iterator_tag);\n \n-  template<typename _FIter1, typename _FIter2, typename _IterTag1, typename _IterTag2>\n-  _FIter1\n-  search_switch(_FIter1, _FIter1, _FIter2, _FIter2, _IterTag1, _IterTag2);\n+  template<typename _FIter1, typename _FIter2, typename _IterTag1,\n+\t   typename _IterTag2>\n+    _FIter1\n+    search_switch(_FIter1, _FIter1, _FIter2, _FIter2, _IterTag1, _IterTag2);\n \n   template<typename _RAIter1, typename _RAIter2, typename _BiPredicate>\n-  _RAIter1\n-  search_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2, _BiPredicate , random_access_iterator_tag, random_access_iterator_tag);\n+    _RAIter1\n+    search_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2, _BiPredicate,\n+\t\t  random_access_iterator_tag, random_access_iterator_tag);\n \n-  template<typename _FIter1, typename _FIter2, typename _BiPredicate, typename _IterTag1, typename _IterTag2>\n-  _FIter1\n-  search_switch(_FIter1, _FIter1, _FIter2, _FIter2, _BiPredicate, _IterTag1, _IterTag2);\n+  template<typename _FIter1, typename _FIter2, typename _BiPredicate,\n+\t   typename _IterTag1, typename _IterTag2>\n+    _FIter1\n+    search_switch(_FIter1, _FIter1, _FIter2, _FIter2, _BiPredicate,\n+\t\t  _IterTag1, _IterTag2);\n \n-  template<typename _FIter, typename Integer, typename T>\n-  _FIter\n-  search_n(_FIter, _FIter, Integer, const T&, __gnu_parallel::sequential_tag);\n+  template<typename _FIter, typename _Integer, typename _Tp>\n+    _FIter\n+    search_n(_FIter, _FIter, _Integer, const _Tp&,\n+\t     __gnu_parallel::sequential_tag);\n \n-  template<typename _FIter, typename Integer, typename T, typename _BiPredicate>\n-  _FIter\n-  search_n(_FIter, _FIter, Integer, const T&, _BiPredicate, __gnu_parallel::sequential_tag);\n+  template<typename _FIter, typename _Integer, typename _Tp,\n+\t   typename _BiPredicate>\n+    _FIter\n+    search_n(_FIter, _FIter, _Integer, const _Tp&, _BiPredicate,\n+\t     __gnu_parallel::sequential_tag);\n     \n-  template<typename _FIter, typename Integer, typename T>\n-  _FIter\n-  search_n(_FIter, _FIter, Integer, const T& val);\n+  template<typename _FIter, typename _Integer, typename _Tp>\n+    _FIter\n+    search_n(_FIter, _FIter, _Integer, const _Tp&);\n \n-  template<typename _FIter, typename Integer, typename T, typename _BiPredicate>\n-  _FIter\n-  search_n(_FIter, _FIter, Integer, const T&, _BiPredicate);\n+  template<typename _FIter, typename _Integer, typename _Tp,\n+\t   typename _BiPredicate>\n+    _FIter\n+    search_n(_FIter, _FIter, _Integer, const _Tp&, _BiPredicate);\n \n-  template<typename _RAIter, typename Integer, typename T, typename _BiPredicate>\n-  _RAIter\n-  search_n_switch(_RAIter, _RAIter, Integer, const T&, _BiPredicate, random_access_iterator_tag);\n+  template<typename _RAIter, typename _Integer, typename _Tp,\n+\t   typename _BiPredicate>\n+    _RAIter\n+    search_n_switch(_RAIter, _RAIter, _Integer, const _Tp&,\n+\t\t    _BiPredicate, random_access_iterator_tag);\n \n-  template<typename _FIter, typename Integer, typename T, typename _BiPredicate, typename _IterTag>\n-  _FIter\n-  search_n_switch(_FIter, _FIter, Integer, const T&, _BiPredicate, _IterTag);\n+  template<typename _FIter, typename _Integer, typename _Tp,\n+\t   typename _BiPredicate, typename _IterTag>\n+    _FIter\n+    search_n_switch(_FIter, _FIter, _Integer, const _Tp&,\n+\t\t    _BiPredicate, _IterTag);\n \n \n   template<typename _IIter, typename _OIter, typename UnaryOperation>\n@@ -385,7 +418,8 @@ namespace __parallel\n     transform(_IIter, _IIter, _OIter, UnaryOperation, \n \t      __gnu_parallel::parallelism);\n \n-  template<typename _IIter, typename _OIter, typename UnaryOperation, typename _IterTag1, typename _IterTag2>\n+  template<typename _IIter, typename _OIter, typename UnaryOperation,\n+\t   typename _IterTag1, typename _IterTag2>\n     _OIter\n     transform1_switch(_IIter, _IIter, _OIter, UnaryOperation, \n \t\t      _IterTag1, _IterTag2);\n@@ -398,78 +432,87 @@ namespace __parallel\n \t\t      __gnu_parallel::parallelism);\n \n \n-  template<typename _IIter1, typename _IIter2, typename _OIter, typename _BiOperation>\n+  template<typename _IIter1, typename _IIter2, typename _OIter,\n+\t   typename _BiOperation>\n     _OIter\n     transform(_IIter1, _IIter1, _IIter2, _OIter, _BiOperation);\n \n-  template<typename _IIter1, typename _IIter2, typename _OIter, typename _BiOperation>\n+  template<typename _IIter1, typename _IIter2, typename _OIter,\n+\t   typename _BiOperation>\n     _OIter\n     transform(_IIter1, _IIter1, _IIter2, _OIter, _BiOperation, \n \t      __gnu_parallel::sequential_tag);\n \n-  template<typename _IIter1, typename _IIter2, typename _OIter, typename _BiOperation>\n+  template<typename _IIter1, typename _IIter2, typename _OIter,\n+\t   typename _BiOperation>\n     _OIter\n     transform(_IIter1, _IIter1, _IIter2, _OIter, _BiOperation, \n \t      __gnu_parallel::parallelism);\n \n-  template<typename _RAIter1, typename _RAIter2, typename _RAIter3, typename _BiOperation>\n+  template<typename _RAIter1, typename _RAIter2, typename _RAIter3,\n+\t   typename _BiOperation>\n     _RAIter3\n     transform2_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter3, _BiOperation, \n \t\t      random_access_iterator_tag, random_access_iterator_tag, \n \t\t      random_access_iterator_tag, \n \t\t      __gnu_parallel::parallelism parallelism_tag);\n \n-  template<typename _IIter1, typename _IIter2, typename _OIter, typename _BiOperation, typename tag1, typename tag2, typename tag3>\n+  template<typename _IIter1, typename _IIter2, typename _OIter,\n+\t   typename _BiOperation, typename _Tag1,\n+\t   typename _Tag2, typename _Tag3>\n     _OIter\n     transform2_switch(_IIter1, _IIter1, _IIter2, _OIter, _BiOperation, \n-\t\t      tag1, tag2, tag3);\n+\t\t      _Tag1, _Tag2, _Tag3);\n \n \n-  template<typename _FIter, typename T>\n+  template<typename _FIter, typename _Tp>\n     void\n-    replace(_FIter, _FIter, const T&, const T&);\n+    replace(_FIter, _FIter, const _Tp&, const _Tp&);\n \n-  template<typename _FIter, typename T>\n+  template<typename _FIter, typename _Tp>\n     void\n-    replace(_FIter, _FIter, const T&, const T&, \n+    replace(_FIter, _FIter, const _Tp&, const _Tp&, \n \t    __gnu_parallel::sequential_tag);\n \n-  template<typename _FIter, typename T>\n+  template<typename _FIter, typename _Tp>\n     void\n-    replace(_FIter, _FIter, const T&, const T&, __gnu_parallel::parallelism);\n+    replace(_FIter, _FIter, const _Tp&, const _Tp&,\n+\t    __gnu_parallel::parallelism);\n \n-  template<typename _FIter, typename T, typename _IterTag>\n+  template<typename _FIter, typename _Tp, typename _IterTag>\n     void\n-    replace_switch(_FIter, _FIter, const T&, const T&, _IterTag);\n+    replace_switch(_FIter, _FIter, const _Tp&, const _Tp&, _IterTag);\n \n-  template<typename _RAIter, typename T>\n+  template<typename _RAIter, typename _Tp>\n     void\n-    replace_switch(_RAIter, _RAIter, const T&, const T&, \n+    replace_switch(_RAIter, _RAIter, const _Tp&, const _Tp&, \n \t\t   random_access_iterator_tag, __gnu_parallel::parallelism);\n \n \n-  template<typename _FIter, typename Predicate, typename T>\n+  template<typename _FIter, typename _Predicate, typename _Tp>\n     void\n-    replace_if(_FIter, _FIter, Predicate, const T&);\n+    replace_if(_FIter, _FIter, _Predicate, const _Tp&);\n \n-  template<typename _FIter, typename Predicate, typename T>\n+  template<typename _FIter, typename _Predicate, typename _Tp>\n     void\n-    replace_if(_FIter, _FIter, Predicate, const T&, \n+    replace_if(_FIter, _FIter, _Predicate, const _Tp&,\n \t       __gnu_parallel::sequential_tag);\n \n-  template<typename _FIter, typename Predicate, typename T>\n+  template<typename _FIter, typename _Predicate, typename _Tp>\n     void\n-    replace_if(_FIter, _FIter, Predicate, const T&, \n+    replace_if(_FIter, _FIter, _Predicate, const _Tp&,\n \t       __gnu_parallel::parallelism);\n \n-  template<typename _FIter, typename Predicate, typename T, typename _IterTag>\n+  template<typename _FIter, typename _Predicate, typename _Tp,\n+\t   typename _IterTag>\n     void\n-    replace_if_switch(_FIter, _FIter, Predicate, const T&, _IterTag);\n+    replace_if_switch(_FIter, _FIter, _Predicate, const _Tp&, _IterTag);\n  \n-  template<typename _RAIter, typename Predicate, typename T>\n+  template<typename _RAIter, typename _Predicate, typename _Tp>\n     void\n-    replace_if_switch(_RAIter, _RAIter, Predicate, const T&, \n-\t\t      random_access_iterator_tag, __gnu_parallel::parallelism);\n+    replace_if_switch(_RAIter, _RAIter, _Predicate, const _Tp&,\n+\t\t      random_access_iterator_tag,\n+\t\t      __gnu_parallel::parallelism);\n \n \n   template<typename _FIter>\n@@ -511,25 +554,30 @@ namespace __parallel\n     merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, \n \t  __gnu_parallel::sequential_tag);\n \n-  template<typename _IIter1, typename _IIter2, typename _OIter, typename _Compare>\n+  template<typename _IIter1, typename _IIter2, typename _OIter,\n+\t   typename _Compare>\n     _OIter\n     merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare, \n \t  __gnu_parallel::sequential_tag);\n \n-  template<typename _IIter1, typename _IIter2, typename _OIter, typename _Compare>\n+  template<typename _IIter1, typename _IIter2, typename _OIter,\n+\t   typename _Compare>\n     _OIter\n     merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter>\n     _OIter\n     merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);\n \n-  template<typename _IIter1, typename _IIter2, typename _OIter, typename _Compare, typename _IterTag1, typename _IterTag2, typename _IterTag3>\n+  template<typename _IIter1, typename _IIter2, typename _OIter,\n+\t   typename _Compare, typename _IterTag1, typename _IterTag2,\n+\t   typename _IterTag3>\n     _OIter\n     merge_switch(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare, \n \t\t _IterTag1, _IterTag2, _IterTag3);\n \n-  template<typename _IIter1, typename _IIter2, typename _OIter, typename _Compare>\n+  template<typename _IIter1, typename _IIter2, typename _OIter,\n+\t   typename _Compare>\n     _OIter\n     merge_switch(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare, \n \t\t random_access_iterator_tag, random_access_iterator_tag, \n@@ -570,223 +618,277 @@ namespace __parallel\n \t\t       __gnu_parallel::parallelism);\n \n   template<typename _RAIter>\n-  void\n-  nth_element(_RAIter, _RAIter, _RAIter, __gnu_parallel::sequential_tag);\n+    void\n+    nth_element(_RAIter, _RAIter, _RAIter, __gnu_parallel::sequential_tag);\n \n   template<typename _RAIter, typename _Compare>\n-  void\n-  nth_element(_RAIter, _RAIter, _RAIter, _Compare, __gnu_parallel::sequential_tag);\n+    void\n+    nth_element(_RAIter, _RAIter, _RAIter, _Compare,\n+\t\t__gnu_parallel::sequential_tag);\n \n   template<typename _RAIter, typename _Compare>\n-  void\n-  nth_element(_RAIter, _RAIter, _RAIter, _Compare);\n+    void\n+    nth_element(_RAIter, _RAIter, _RAIter, _Compare);\n \n   template<typename _RAIter>\n-  void\n-  nth_element(_RAIter, _RAIter, _RAIter);\n+    void\n+    nth_element(_RAIter, _RAIter, _RAIter);\n \n   template<typename _RAIter, typename _Compare>\n-  void\n-  partial_sort(_RAIter, _RAIter, _RAIter, _Compare, __gnu_parallel::sequential_tag);\n+    void\n+    partial_sort(_RAIter, _RAIter, _RAIter, _Compare,\n+\t\t __gnu_parallel::sequential_tag);\n \n   template<typename _RAIter>\n-  void\n-  partial_sort(_RAIter, _RAIter, _RAIter, __gnu_parallel::sequential_tag);\n+    void\n+    partial_sort(_RAIter, _RAIter, _RAIter, __gnu_parallel::sequential_tag);\n \n   template<typename _RAIter, typename _Compare>\n-  void\n-  partial_sort(_RAIter, _RAIter, _RAIter, _Compare);\n+    void\n+    partial_sort(_RAIter, _RAIter, _RAIter, _Compare);\n \n   template<typename _RAIter>\n-  void\n-  partial_sort(_RAIter, _RAIter, _RAIter);\n+    void\n+    partial_sort(_RAIter, _RAIter, _RAIter);\n \n   template<typename _FIter, typename Predicate>\n-  _FIter\n-  partition(_FIter, _FIter, Predicate, __gnu_parallel::sequential_tag);\n+    _FIter\n+    partition(_FIter, _FIter, Predicate, __gnu_parallel::sequential_tag);\n     \n   template<typename _FIter, typename Predicate>\n-  _FIter\n-  partition(_FIter, _FIter, Predicate);\n+    _FIter\n+    partition(_FIter, _FIter, Predicate);\n \n   template<typename _FIter, typename Predicate, typename _IterTag>\n-  _FIter\n-  partition_switch(_FIter, _FIter, Predicate, _IterTag);\n+    _FIter\n+    partition_switch(_FIter, _FIter, Predicate, _IterTag);\n     \n   template<typename _RAIter, typename Predicate>\n-  _RAIter\n-  partition_switch(_RAIter, _RAIter, Predicate, random_access_iterator_tag);\n+    _RAIter\n+    partition_switch(_RAIter, _RAIter, Predicate, random_access_iterator_tag);\n \n   template<typename _RAIter>\n-  void\n-  random_shuffle(_RAIter, _RAIter, __gnu_parallel::sequential_tag);\n+    void\n+    random_shuffle(_RAIter, _RAIter, __gnu_parallel::sequential_tag);\n \n-  template<typename _RAIter, typename RandomNumberGenerator>\n-  void\n-  random_shuffle(_RAIter, _RAIter, RandomNumberGenerator& rand, __gnu_parallel::sequential_tag);\n+  template<typename _RAIter, typename _RandomNumberGenerator>\n+    void\n+    random_shuffle(_RAIter, _RAIter, _RandomNumberGenerator&,\n+\t\t   __gnu_parallel::sequential_tag);\n \n   template<typename _RAIter>\n-  void\n-  random_shuffle(_RAIter, _RAIter);\n+    void\n+    random_shuffle(_RAIter, _RAIter);\n \n-  template<typename _RAIter, typename RandomNumberGenerator>\n-  void\n-  random_shuffle(_RAIter, _RAIter, RandomNumberGenerator& rand);\n+  template<typename _RAIter, typename _RandomNumberGenerator>\n+    void\n+    random_shuffle(_RAIter, _RAIter, _RandomNumberGenerator&);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter>\n-  _OIter\n-  set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, __gnu_parallel::sequential_tag);\n+    _OIter\n+    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter,\n+\t    __gnu_parallel::sequential_tag);\n \n-  template<typename _IIter1, typename _IIter2, typename _OIter, typename Predicate>\n-  _OIter\n-  set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, Predicate, __gnu_parallel::sequential_tag);\n+  template<typename _IIter1, typename _IIter2, typename _OIter,\n+\t   typename Predicate>\n+    _OIter\n+    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, Predicate,\n+\t      __gnu_parallel::sequential_tag);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter>\n-  _OIter \n-  set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);\n-\n-  template<typename _IIter1, typename _IIter2, typename _OIter, typename Predicate>\n-  _OIter \n-  set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, Predicate);\n+    _OIter\n+    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);\n \n-  template<typename _IIter1, typename _IIter2, typename Predicate, typename _OIter, typename _IterTag1, typename _IterTag2, typename _IterTag3>\n-  _OIter \n-  set_union_switch(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, Predicate, _IterTag1, _IterTag2, _IterTag3);\n+  template<typename _IIter1, typename _IIter2, typename _OIter,\n+\t   typename _Predicate>\n+    _OIter \n+    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Predicate);\n \n-  template<typename _RAIter1, typename _RAIter2, typename Output_RAIter, typename Predicate>\n-  Output_RAIter \n-  set_union_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2, Output_RAIter, Predicate, random_access_iterator_tag, random_access_iterator_tag, random_access_iterator_tag);\n+  template<typename _IIter1, typename _IIter2, typename _Predicate,\n+\t   typename _OIter, typename _IterTag1, typename _IterTag2,\n+\t   typename _IterTag3>\n+    _OIter\n+    set_union_switch(_IIter1, _IIter1, _IIter2, _IIter2, _OIter,\n+\t\t     _Predicate, _IterTag1, _IterTag2, _IterTag3);\n+\n+  template<typename _RAIter1, typename _RAIter2, typename _Output_RAIter,\n+\t   typename _Predicate>\n+    _Output_RAIter\n+    set_union_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2, _Output_RAIter,\n+\t\t     _Predicate, random_access_iterator_tag,\n+\t\t     random_access_iterator_tag, random_access_iterator_tag);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter>\n-  _OIter\n-  set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, __gnu_parallel::sequential_tag);\n+    _OIter\n+    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter,\n+\t\t     __gnu_parallel::sequential_tag);\n \n-  template<typename _IIter1, typename _IIter2, typename _OIter, typename Predicate>\n-  _OIter\n-  set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, Predicate, __gnu_parallel::sequential_tag);\n+  template<typename _IIter1, typename _IIter2, typename _OIter,\n+\t   typename _Predicate>\n+    _OIter\n+    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Predicate,\n+\t\t     __gnu_parallel::sequential_tag);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter>\n-  _OIter \n-  set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);\n-\n-  template<typename _IIter1, typename _IIter2, typename _OIter, typename Predicate>\n-  _OIter \n-  set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, Predicate);\n+    _OIter\n+    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);\n \n-  template<typename _IIter1, typename _IIter2, typename Predicate, typename _OIter, typename _IterTag1, typename _IterTag2, typename _IterTag3>\n-  _OIter \n-  set_intersection_switch(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, Predicate, _IterTag1, _IterTag2, _IterTag3);\n+  template<typename _IIter1, typename _IIter2, typename _OIter,\n+\t   typename _Predicate>\n+    _OIter \n+    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Predicate);\n \n-  template<typename _RAIter1, typename _RAIter2, typename Output_RAIter, typename Predicate>\n-  Output_RAIter \n-  set_intersection_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2, Output_RAIter, Predicate, random_access_iterator_tag, random_access_iterator_tag, random_access_iterator_tag);\n+  template<typename _IIter1, typename _IIter2, typename _Predicate,\n+\t   typename _OIter, typename _IterTag1, typename _IterTag2,\n+\t   typename _IterTag3>\n+    _OIter\n+    set_intersection_switch(_IIter1, _IIter1, _IIter2, _IIter2, _OIter,\n+\t\t\t    _Predicate, _IterTag1, _IterTag2, _IterTag3);\n+\n+  template<typename _RAIter1, typename _RAIter2, typename _Output_RAIter,\n+\t   typename _Predicate>\n+    _Output_RAIter\n+    set_intersection_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2,\n+\t\t\t    _Output_RAIter, _Predicate,\n+\t\t\t    random_access_iterator_tag,\n+\t\t\t    random_access_iterator_tag,\n+\t\t\t    random_access_iterator_tag);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter>\n-  _OIter\n-  set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, __gnu_parallel::sequential_tag);\n+    _OIter\n+    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter,\n+\t\t\t     __gnu_parallel::sequential_tag);\n \n-  template<typename _IIter1, typename _IIter2, typename _OIter, typename Predicate>\n-  _OIter\n-  set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, Predicate, __gnu_parallel::sequential_tag);\n+  template<typename _IIter1, typename _IIter2, typename _OIter,\n+\t   typename _Predicate>\n+    _OIter\n+    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter,\n+\t\t\t     _Predicate, __gnu_parallel::sequential_tag);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter>\n-  _OIter \n-  set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);\n-\n-  template<typename _IIter1, typename _IIter2, typename _OIter, typename Predicate>\n-  _OIter \n-  set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, Predicate);\n-\n-  template<typename _IIter1, typename _IIter2, typename Predicate, typename _OIter, typename _IterTag1, typename _IterTag2, typename _IterTag3>\n-  _OIter \n-  set_symmetric_difference_switch(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, Predicate, _IterTag1, _IterTag2, _IterTag3);\n+    _OIter \n+    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);\n+\n+  template<typename _IIter1, typename _IIter2, typename _OIter,\n+\t   typename _Predicate>\n+    _OIter \n+    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter,\n+\t\t\t     _Predicate);\n+\n+  template<typename _IIter1, typename _IIter2, typename _Predicate,\n+\t   typename _OIter, typename _IterTag1, typename _IterTag2,\n+\t   typename _IterTag3>\n+    _OIter\n+    set_symmetric_difference_switch(_IIter1, _IIter1, _IIter2, _IIter2,\n+\t\t\t\t    _OIter, _Predicate, _IterTag1, _IterTag2,\n+\t\t\t\t    _IterTag3);\n \n-  template<typename _RAIter1, typename _RAIter2, typename Output_RAIter, typename Predicate>\n-  Output_RAIter \n-  set_symmetric_difference_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2, Output_RAIter, Predicate, random_access_iterator_tag, random_access_iterator_tag, random_access_iterator_tag);\n+  template<typename _RAIter1, typename _RAIter2, typename _Output_RAIter,\n+\t   typename _Predicate>\n+    _Output_RAIter\n+    set_symmetric_difference_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2,\n+\t\t\t\t    _Output_RAIter, _Predicate,\n+\t\t\t\t    random_access_iterator_tag,\n+\t\t\t\t    random_access_iterator_tag,\n+\t\t\t\t    random_access_iterator_tag);\n \n \n   template<typename _IIter1, typename _IIter2, typename _OIter>\n-  _OIter\n-  set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, __gnu_parallel::sequential_tag);\n+    _OIter\n+    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter,\n+\t\t   __gnu_parallel::sequential_tag);\n \n-  template<typename _IIter1, typename _IIter2, typename _OIter, typename Predicate>\n-  _OIter\n-  set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, Predicate, __gnu_parallel::sequential_tag);\n+  template<typename _IIter1, typename _IIter2, typename _OIter,\n+\t   typename _Predicate>\n+    _OIter\n+    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Predicate,\n+\t\t   __gnu_parallel::sequential_tag);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter>\n-  _OIter\n-  set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);\n+    _OIter\n+    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);\n \n-  template<typename _IIter1, typename _IIter2, typename _OIter, typename Predicate>\n-  _OIter\n-  set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, Predicate);\n+  template<typename _IIter1, typename _IIter2, typename _OIter,\n+\t   typename _Predicate>\n+    _OIter\n+    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Predicate);\n \n-  template<typename _IIter1, typename _IIter2, typename Predicate, typename _OIter, typename _IterTag1, typename _IterTag2, typename _IterTag3>\n-  _OIter\n-  set_difference_switch(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, Predicate, _IterTag1, _IterTag2, _IterTag3);\n+  template<typename _IIter1, typename _IIter2, typename _Predicate,\n+\t   typename _OIter, typename _IterTag1, typename _IterTag2,\n+\t   typename _IterTag3>\n+    _OIter\n+    set_difference_switch(_IIter1, _IIter1, _IIter2, _IIter2, _OIter,\n+\t\t\t  _Predicate, _IterTag1, _IterTag2, _IterTag3);\n \n-  template<typename _RAIter1, typename _RAIter2, typename Output_RAIter, typename Predicate>\n-  Output_RAIter\n-  set_difference_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2, Output_RAIter, Predicate, random_access_iterator_tag, random_access_iterator_tag, random_access_iterator_tag);\n+  template<typename _RAIter1, typename _RAIter2, typename _Output_RAIter,\n+\t   typename _Predicate>\n+    _Output_RAIter\n+    set_difference_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2,\n+\t\t\t  _Output_RAIter, _Predicate,\n+\t\t\t  random_access_iterator_tag,\n+\t\t\t  random_access_iterator_tag,\n+\t\t\t  random_access_iterator_tag);\n \n \n   template<typename _RAIter>\n-  void\n-  sort(_RAIter, _RAIter, __gnu_parallel::sequential_tag);\n+    void\n+    sort(_RAIter, _RAIter, __gnu_parallel::sequential_tag);\n \n   template<typename _RAIter, typename _Compare>\n-  void\n-  sort(_RAIter, _RAIter, _Compare, __gnu_parallel::sequential_tag);\n+    void\n+    sort(_RAIter, _RAIter, _Compare, __gnu_parallel::sequential_tag);\n \n   template<typename _RAIter>\n-  void\n-  sort(_RAIter, _RAIter);\n+    void\n+    sort(_RAIter, _RAIter);\n \n   template<typename _RAIter, typename _Compare>\n-  void\n-  sort(_RAIter, _RAIter, _Compare);\n+    void\n+    sort(_RAIter, _RAIter, _Compare);\n \n   template<typename _RAIter>\n-  void\n-  stable_sort(_RAIter, _RAIter, __gnu_parallel::sequential_tag);\n+    void\n+    stable_sort(_RAIter, _RAIter, __gnu_parallel::sequential_tag);\n \n   template<typename _RAIter, typename _Compare>\n-  void\n-  stable_sort(_RAIter, _RAIter, _Compare, __gnu_parallel::sequential_tag);\n+    void\n+    stable_sort(_RAIter, _RAIter, _Compare, __gnu_parallel::sequential_tag);\n \n   template<typename _RAIter>\n-  void\n-  stable_sort(_RAIter, _RAIter);\n+    void\n+    stable_sort(_RAIter, _RAIter);\n \n   template<typename _RAIter, typename _Compare>\n-  void\n-  stable_sort(_RAIter, _RAIter, _Compare);\n+    void\n+    stable_sort(_RAIter, _RAIter, _Compare);\n \n   template<typename _IIter, typename _OIter>\n-  _OIter\n-  unique_copy(_IIter, _IIter, _OIter, __gnu_parallel::sequential_tag);\n+    _OIter\n+    unique_copy(_IIter, _IIter, _OIter, __gnu_parallel::sequential_tag);\n \n-  template<typename _IIter, typename _OIter, typename Predicate>\n-  _OIter\n-  unique_copy(_IIter, _IIter, _OIter, Predicate, __gnu_parallel::sequential_tag);\n+  template<typename _IIter, typename _OIter, typename _Predicate>\n+    _OIter\n+    unique_copy(_IIter, _IIter, _OIter, _Predicate,\n+\t\t__gnu_parallel::sequential_tag);\n \n   template<typename _IIter, typename _OIter>\n-  _OIter\n-  unique_copy(_IIter, _IIter, _OIter);\n+    _OIter\n+    unique_copy(_IIter, _IIter, _OIter);\n \n-  template<typename _IIter, typename _OIter, typename Predicate>\n-  _OIter\n-  unique_copy(_IIter, _IIter, _OIter, Predicate);\n+  template<typename _IIter, typename _OIter, typename _Predicate>\n+    _OIter\n+    unique_copy(_IIter, _IIter, _OIter, _Predicate);\n \n-  template<typename _IIter, typename _OIter, typename Predicate, typename _IterTag1, typename _IterTag2>\n-  _OIter\n-  unique_copy_switch(_IIter, _IIter, _OIter, Predicate, _IterTag1, _IterTag2);\n+  template<typename _IIter, typename _OIter, typename _Predicate,\n+\t   typename _IterTag1, typename _IterTag2>\n+    _OIter\n+    unique_copy_switch(_IIter, _IIter, _OIter, _Predicate,\n+\t\t       _IterTag1, _IterTag2);\n \n-  template<typename _RAIter, typename RandomAccess_OIter, typename Predicate>\n-  RandomAccess_OIter\n-  unique_copy_switch(_RAIter, _RAIter, RandomAccess_OIter, Predicate, \n-\t\t     random_access_iterator_tag, random_access_iterator_tag);\n+  template<typename _RAIter, typename _RandomAccess_OIter, typename _Predicate>\n+    _RandomAccess_OIter\n+    unique_copy_switch(_RAIter, _RAIter, _RandomAccess_OIter, _Predicate,\n+\t\t       random_access_iterator_tag, random_access_iterator_tag);\n } // end namespace __parallel\n } // end namespace std\n "}, {"sha": "ac05ec702578b7b70056bd6b09ea2dfdc5a2760e", "filename": "libstdc++-v3/include/parallel/balanced_quicksort.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/531898c3c23ba05afe22253f9cdee6491882c92c/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbalanced_quicksort.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/531898c3c23ba05afe22253f9cdee6491882c92c/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbalanced_quicksort.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbalanced_quicksort.h?ref=531898c3c23ba05afe22253f9cdee6491882c92c", "patch": "@@ -1,6 +1,6 @@\n // -*- C++ -*-\n \n-// Copyright (C) 2007 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the terms\n@@ -102,7 +102,7 @@ template<typename RandomAccessIterator>\n   *  this part.\n   *  @pre @c (end-begin)>=1 */\n template<typename RandomAccessIterator, typename Comparator>\n-  inline typename std::iterator_traits<RandomAccessIterator>::difference_type\n+  typename std::iterator_traits<RandomAccessIterator>::difference_type\n   qsb_divide(RandomAccessIterator begin, RandomAccessIterator end,\n              Comparator comp, thread_index_t num_threads)\n   {\n@@ -164,7 +164,7 @@ template<typename RandomAccessIterator, typename Comparator>\n   *  @param num_threads\n   *          Number of threads that are allowed to work on this part. */\n template<typename RandomAccessIterator, typename Comparator>\n-  inline void\n+  void\n   qsb_conquer(QSBThreadLocal<RandomAccessIterator>** tls,\n               RandomAccessIterator begin, RandomAccessIterator end,\n               Comparator comp,\n@@ -240,7 +240,7 @@ template<typename RandomAccessIterator, typename Comparator>\n   *  @param iam Number of the thread processing this function.\n   */\n template<typename RandomAccessIterator, typename Comparator>\n-  inline void\n+  void\n   qsb_local_sort_with_helping(QSBThreadLocal<RandomAccessIterator>** tls,\n                               Comparator& comp, int iam, bool wait)\n   {\n@@ -418,7 +418,7 @@ template<typename RandomAccessIterator, typename Comparator>\n   *  this part.\n   */\n template<typename RandomAccessIterator, typename Comparator>\n-  inline void\n+  void\n   parallel_sort_qsb(RandomAccessIterator begin, RandomAccessIterator end,\n                     Comparator comp,\n                     typename std::iterator_traits<RandomAccessIterator>"}, {"sha": "b06233992c46551b7f85fc09de8b633170c863c2", "filename": "libstdc++-v3/include/parallel/checkers.h", "status": "modified", "additions": 79, "deletions": 67, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/531898c3c23ba05afe22253f9cdee6491882c92c/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcheckers.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/531898c3c23ba05afe22253f9cdee6491882c92c/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcheckers.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcheckers.h?ref=531898c3c23ba05afe22253f9cdee6491882c92c", "patch": "@@ -1,6 +1,6 @@\n // -*- C++ -*-\n \n-// Copyright (C) 2007 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the terms\n@@ -53,28 +53,32 @@ namespace __gnu_parallel\n    */\n   // XXX Comparator default template argument\n   template<typename InputIterator, typename Comparator>\n-  bool\n-  is_sorted(InputIterator begin, InputIterator end, Comparator comp = std::less<typename std::iterator_traits<InputIterator>::value_type>())\n-  {\n-    if (begin == end)\n-      return true;\n-\n-    InputIterator current(begin), recent(begin);\n+    bool\n+    is_sorted(InputIterator begin, InputIterator end,\n+\t      Comparator comp\n+\t      = std::less<typename std::iterator_traits<InputIterator>::\n+\t      value_type>())\n+    {\n+      if (begin == end)\n+\treturn true;\n+\n+      InputIterator current(begin), recent(begin);\n+\n+      unsigned long long position = 1;\n+      for (current++; current != end; current++)\n+\t{\n+\t  if (comp(*current, *recent))\n+\t    {\n+\t      printf(\"is_sorted: check failed before position %i.\\n\",\n+\t\t     position);\n+\t      return false;\n+\t    }\n+\t  recent = current;\n+\t  position++;\n+\t}\n \n-    unsigned long long position = 1;\n-    for (current++; current != end; current++)\n-      {\n-\tif (comp(*current, *recent))\n-\t  {\n-\t    printf(\"is_sorted: check failed before position %i.\\n\", position);\n-\t    return false;\n-\t  }\n-\trecent = current;\n-\tposition++;\n-      }\n-\n-    return true;\n-  }\n+      return true;\n+    }\n \n   /**\n    * @brief Check whether @c [begin, @c end) is sorted according to @c comp.\n@@ -87,30 +91,35 @@ namespace __gnu_parallel\n    */\n   // XXX Comparator default template argument\n   template<typename InputIterator, typename Comparator>\n-  bool\n-  is_sorted_failure(InputIterator begin, InputIterator end, InputIterator& first_failure, Comparator comp = std::less<typename std::iterator_traits<InputIterator>::value_type>())\n-  {\n-    if (begin == end)\n+    bool\n+    is_sorted_failure(InputIterator begin, InputIterator end,\n+\t\t      InputIterator& first_failure,\n+\t\t      Comparator comp\n+\t\t      = std::less<typename std::iterator_traits<InputIterator>::\n+\t\t      value_type>())\n+    {\n+      if (begin == end)\n+\treturn true;\n+\n+      InputIterator current(begin), recent(begin);\n+\n+      unsigned long long position = 1;\n+      for (current++; current != end; current++)\n+\t{\n+\t  if (comp(*current, *recent))\n+\t    {\n+\t      first_failure = current;\n+\t      printf(\"is_sorted: check failed before position %lld.\\n\",\n+\t\t     position);\n+\t      return false;\n+\t    }\n+\t  recent = current;\n+\t  position++;\n+\t}\n+\n+      first_failure = end;\n       return true;\n-\n-    InputIterator current(begin), recent(begin);\n-\n-    unsigned long long position = 1;\n-    for (current++; current != end; current++)\n-      {\n-\tif (comp(*current, *recent))\n-\t  {\n-\t    first_failure = current;\n-\t    printf(\"is_sorted: check failed before position %lld.\\n\", position);\n-\t    return false;\n-\t  }\n-\trecent = current;\n-\tposition++;\n-      }\n-\n-    first_failure = end;\n-    return true;\n-  }\n+    }\n \n   /**\n    * @brief Check whether @c [begin, @c end) is sorted according to @c comp.\n@@ -121,28 +130,31 @@ namespace __gnu_parallel\n    * @return @c true if sorted, @c false otherwise.\n    */\n   template<typename InputIterator, typename Comparator>\n-  bool\n-  // XXX Comparator default template argument\n-  is_sorted_print_failures(InputIterator begin, InputIterator end, Comparator comp = std::less<typename std::iterator_traits<InputIterator>::value_type>())\n-  {\n-    if (begin == end)\n-      return true;\n-\n-    InputIterator recent(begin);\n-    bool ok = true;\n-\n-    for (InputIterator pos(begin + 1); pos != end; pos++)\n-      {\n-\tif (comp(*pos, *recent))\n-\t  {\n-\t    printf(\"%ld: %d %d %d %d\\n\", pos - begin, *(pos - 2),\n-\t\t   *(pos- 1), *pos, *(pos + 1));\n-\t    ok = false;\n-\t  }\n-\trecent = pos;\n-      }\n-    return ok;\n-  }\n+    bool\n+    // XXX Comparator default template argument\n+    is_sorted_print_failures(InputIterator begin, InputIterator end,\n+\t\t\t     Comparator comp\n+\t\t\t     = std::less<typename std::iterator_traits\n+\t\t\t     <InputIterator>::value_type>())\n+    {\n+      if (begin == end)\n+\treturn true;\n+\n+      InputIterator recent(begin);\n+      bool ok = true;\n+\n+      for (InputIterator pos(begin + 1); pos != end; pos++)\n+\t{\n+\t  if (comp(*pos, *recent))\n+\t    {\n+\t      printf(\"%ld: %d %d %d %d\\n\", pos - begin, *(pos - 2),\n+\t\t     *(pos- 1), *pos, *(pos + 1));\n+\t      ok = false;\n+\t    }\n+\t  recent = pos;\n+\t}\n+      return ok;\n+    }\n }\n \n #endif"}, {"sha": "3a0db1ffbe155b10a2664bc5f3bc5ee2fa6a08f6", "filename": "libstdc++-v3/include/parallel/find.h", "status": "modified", "additions": 17, "deletions": 21, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/531898c3c23ba05afe22253f9cdee6491882c92c/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/531898c3c23ba05afe22253f9cdee6491882c92c/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffind.h?ref=531898c3c23ba05afe22253f9cdee6491882c92c", "patch": "@@ -1,6 +1,6 @@\n // -*- C++ -*-\n \n-// Copyright (C) 2007 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the terms\n@@ -58,11 +58,10 @@ namespace __gnu_parallel\n  *  @param selector Functionality (e. g. std::find_if (), std::equal(),...)\n  *  @return Place of finding in both sequences.\n  */\n-template<\n-    typename RandomAccessIterator1,\n-    typename RandomAccessIterator2,\n-    typename Pred,\n-    typename Selector>\n+template<typename RandomAccessIterator1,\n+\t typename RandomAccessIterator2,\n+\t typename Pred,\n+\t typename Selector>\n   std::pair<RandomAccessIterator1, RandomAccessIterator2>\n   find_template(RandomAccessIterator1 begin1, RandomAccessIterator1 end1,\n                 RandomAccessIterator2 begin2, Pred pred, Selector selector)\n@@ -96,11 +95,10 @@ template<\n  *  @param selector Functionality (e. g. std::find_if (), std::equal(),...)\n  *  @return Place of finding in both sequences.\n  */\n-template<\n-    typename RandomAccessIterator1,\n-    typename RandomAccessIterator2,\n-    typename Pred,\n-    typename Selector>\n+template<typename RandomAccessIterator1,\n+\t typename RandomAccessIterator2,\n+\t typename Pred,\n+\t typename Selector>\n   std::pair<RandomAccessIterator1, RandomAccessIterator2>\n   find_template(RandomAccessIterator1 begin1,\n                 RandomAccessIterator1 end1,\n@@ -190,11 +188,10 @@ template<\n  *     for CSB, the blocks are allocated in a predetermined manner,\n  *     namely spacial round-robin.\n  */\n-template<\n-    typename RandomAccessIterator1,\n-    typename RandomAccessIterator2,\n-    typename Pred,\n-    typename Selector>\n+template<typename RandomAccessIterator1,\n+\t typename RandomAccessIterator2,\n+\t typename Pred,\n+\t typename Selector>\n   std::pair<RandomAccessIterator1, RandomAccessIterator2>\n   find_template(RandomAccessIterator1 begin1, RandomAccessIterator1 end1,\n                 RandomAccessIterator2 begin2, Pred pred, Selector selector,\n@@ -311,11 +308,10 @@ template<\n  *  blocks are allocated in a predetermined manner, namely spacial\n  *  round-robin.\n  */\n-template<\n-    typename RandomAccessIterator1,\n-    typename RandomAccessIterator2,\n-    typename Pred,\n-    typename Selector>\n+template<typename RandomAccessIterator1,\n+\t typename RandomAccessIterator2,\n+\t typename Pred,\n+\t typename Selector>\n   std::pair<RandomAccessIterator1, RandomAccessIterator2>\n   find_template(RandomAccessIterator1 begin1, RandomAccessIterator1 end1,\n                 RandomAccessIterator2 begin2, Pred pred, Selector selector,"}, {"sha": "3076bd2327e4236aa95d521a0984dce912a90d8a", "filename": "libstdc++-v3/include/parallel/find_selectors.h", "status": "modified", "additions": 67, "deletions": 53, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/531898c3c23ba05afe22253f9cdee6491882c92c/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffind_selectors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/531898c3c23ba05afe22253f9cdee6491882c92c/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffind_selectors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffind_selectors.h?ref=531898c3c23ba05afe22253f9cdee6491882c92c", "patch": "@@ -1,6 +1,6 @@\n // -*- C++ -*-\n \n-// Copyright (C) 2007 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the terms\n@@ -60,23 +60,26 @@ namespace __gnu_parallel\n      * @param i2 Iterator on second sequence (unused).\n      * @param pred Find predicate.\n      */\n-    template<typename RandomAccessIterator1, typename RandomAccessIterator2, typename Pred>\n-    inline bool \n-    operator()(RandomAccessIterator1 i1, RandomAccessIterator2 i2, Pred pred)\n-    { return pred(*i1); }\n+    template<typename RandomAccessIterator1, typename RandomAccessIterator2,\n+\t     typename Pred>\n+      bool \n+      operator()(RandomAccessIterator1 i1, RandomAccessIterator2 i2, Pred pred)\n+      { return pred(*i1); }\n \n     /** @brief Corresponding sequential algorithm on a sequence.\n      *  @param begin1 Begin iterator of first sequence.\n      *  @param end1 End iterator of first sequence.\n      *  @param begin2 Begin iterator of second sequence.\n      *  @param pred Find predicate.\n      */\n-    template<typename RandomAccessIterator1, typename RandomAccessIterator2, typename Pred>\n-    inline std::pair<RandomAccessIterator1, RandomAccessIterator2> \n-    sequential_algorithm(RandomAccessIterator1 begin1, RandomAccessIterator1 end1, RandomAccessIterator2 begin2, Pred pred)\n-    {\n-      return std::make_pair(find_if(begin1, end1, pred, sequential_tag()), begin2);\n-    }\n+    template<typename RandomAccessIterator1, typename RandomAccessIterator2,\n+\t     typename Pred>\n+      std::pair<RandomAccessIterator1, RandomAccessIterator2> \n+      sequential_algorithm(RandomAccessIterator1 begin1,\n+\t\t\t   RandomAccessIterator1 end1,\n+\t\t\t   RandomAccessIterator2 begin2, Pred pred)\n+      { return std::make_pair(find_if(begin1, end1, pred,\n+\t\t\t\t      sequential_tag()), begin2); }\n   };\n \n   /** @brief Test predicate on two adjacent elements. */\n@@ -87,30 +90,35 @@ namespace __gnu_parallel\n      *  @param i2 Iterator on second sequence (unused).\n      *  @param pred Find predicate.\n      */\n-    template<typename RandomAccessIterator1, typename RandomAccessIterator2, typename Pred>\n-    inline bool \n-    operator()(RandomAccessIterator1 i1, RandomAccessIterator2 i2, Pred pred)\n-    {\n-      // Passed end iterator is one short.\n-      return pred(*i1, *(i1 + 1));\n-    }\n+    template<typename RandomAccessIterator1, typename RandomAccessIterator2,\n+\t     typename Pred>\n+      bool \n+      operator()(RandomAccessIterator1 i1, RandomAccessIterator2 i2, Pred pred)\n+      {\n+\t// Passed end iterator is one short.\n+\treturn pred(*i1, *(i1 + 1));\n+      }\n \n     /** @brief Corresponding sequential algorithm on a sequence.\n      *  @param begin1 Begin iterator of first sequence.\n      *  @param end1 End iterator of first sequence.\n      *  @param begin2 Begin iterator of second sequence.\n      *  @param pred Find predicate.\n      */\n-    template<typename RandomAccessIterator1, typename RandomAccessIterator2, typename Pred>\n-    inline std::pair<RandomAccessIterator1, RandomAccessIterator2>\n-    sequential_algorithm(RandomAccessIterator1 begin1, RandomAccessIterator1 end1, RandomAccessIterator2 begin2, Pred pred)\n-    {\n-      // Passed end iterator is one short.\n-      RandomAccessIterator1 spot = adjacent_find(begin1, end1 + 1, pred, sequential_tag());\n-      if (spot == (end1 + 1))\n-\tspot = end1;\n-      return std::make_pair(spot, begin2);\n-    }\n+    template<typename RandomAccessIterator1, typename RandomAccessIterator2,\n+\t     typename Pred>\n+      std::pair<RandomAccessIterator1, RandomAccessIterator2>\n+      sequential_algorithm(RandomAccessIterator1 begin1,\n+\t\t\t   RandomAccessIterator1 end1,\n+\t\t\t   RandomAccessIterator2 begin2, Pred pred)\n+      {\n+\t// Passed end iterator is one short.\n+\tRandomAccessIterator1 spot = adjacent_find(begin1, end1 + 1,\n+\t\t\t\t\t\t   pred, sequential_tag());\n+\tif (spot == (end1 + 1))\n+\t  spot = end1;\n+\treturn std::make_pair(spot, begin2);\n+      }\n   };\n \n   /** @brief Test inverted predicate on a single element. */\n@@ -122,10 +130,11 @@ namespace __gnu_parallel\n      *  @param i2 Iterator on second sequence (unused).\n      *  @param pred Find predicate. \n      */\n-    template<typename RandomAccessIterator1, typename RandomAccessIterator2, typename Pred>\n-    inline bool \n-    operator()(RandomAccessIterator1 i1, RandomAccessIterator2 i2, Pred pred)\n-    { return !pred(*i1, *i2); }\n+    template<typename RandomAccessIterator1, typename RandomAccessIterator2,\n+\t     typename Pred>\n+      bool \n+      operator()(RandomAccessIterator1 i1, RandomAccessIterator2 i2, Pred pred)\n+      { return !pred(*i1, *i2); }\n \n     /** \n      *  @brief Corresponding sequential algorithm on a sequence.\n@@ -134,12 +143,13 @@ namespace __gnu_parallel\n      *  @param begin2 Begin iterator of second sequence.\n      *  @param pred Find predicate. \n      */\n-    template<typename RandomAccessIterator1, typename RandomAccessIterator2, typename Pred>\n-    inline std::pair<RandomAccessIterator1, RandomAccessIterator2>\n-    sequential_algorithm(RandomAccessIterator1 begin1, RandomAccessIterator1 end1, RandomAccessIterator2 begin2, Pred pred)\n-    { \n-      return mismatch(begin1, end1, begin2, pred, sequential_tag()); \n-    }\n+    template<typename RandomAccessIterator1, typename RandomAccessIterator2,\n+\t     typename Pred>\n+      std::pair<RandomAccessIterator1, RandomAccessIterator2>\n+      sequential_algorithm(RandomAccessIterator1 begin1,\n+\t\t\t   RandomAccessIterator1 end1,\n+\t\t\t   RandomAccessIterator2 begin2, Pred pred)\n+      { return mismatch(begin1, end1, begin2, pred, sequential_tag()); }\n   };\n \n \n@@ -157,27 +167,31 @@ namespace __gnu_parallel\n      *  @param i1 Iterator on first sequence.\n      *  @param i2 Iterator on second sequence (unused).\n      *  @param pred Find predicate. */\n-    template<typename RandomAccessIterator1, typename RandomAccessIterator2, typename Pred>\n-    inline bool \n-    operator()(RandomAccessIterator1 i1, RandomAccessIterator2 i2, Pred pred)\n-    {\n-      for (ForwardIterator pos_in_candidates = begin; pos_in_candidates != end; pos_in_candidates++)\n-\tif (pred(*i1, *pos_in_candidates))\n-\t  return true;\n-      return false;\n-    }\n+    template<typename RandomAccessIterator1, typename RandomAccessIterator2,\n+\t     typename Pred>\n+      bool \n+      operator()(RandomAccessIterator1 i1, RandomAccessIterator2 i2, Pred pred)\n+      {\n+\tfor (ForwardIterator pos_in_candidates = begin;\n+\t     pos_in_candidates != end; ++pos_in_candidates)\n+\t  if (pred(*i1, *pos_in_candidates))\n+\t    return true;\n+\treturn false;\n+      }\n \n     /** @brief Corresponding sequential algorithm on a sequence.\n      *  @param begin1 Begin iterator of first sequence.\n      *  @param end1 End iterator of first sequence.\n      *  @param begin2 Begin iterator of second sequence.\n      *  @param pred Find predicate. */\n-    template<typename RandomAccessIterator1, typename RandomAccessIterator2, typename Pred>\n-    inline std::pair<RandomAccessIterator1, RandomAccessIterator2>\n-    sequential_algorithm(RandomAccessIterator1 begin1, RandomAccessIterator1 end1, RandomAccessIterator2 begin2, Pred pred)\n-    {\n-      return std::make_pair(find_first_of(begin1, end1, begin, end, pred, sequential_tag()), begin2);\n-    }\n+    template<typename RandomAccessIterator1, typename RandomAccessIterator2,\n+\t     typename Pred>\n+      std::pair<RandomAccessIterator1, RandomAccessIterator2>\n+      sequential_algorithm(RandomAccessIterator1 begin1,\n+\t\t\t   RandomAccessIterator1 end1,\n+\t\t\t   RandomAccessIterator2 begin2, Pred pred)\n+      { return std::make_pair(find_first_of(begin1, end1, begin, end, pred,\n+\t\t\t\t\t    sequential_tag()), begin2); }\n   };\n }\n "}, {"sha": "c5b157948236115fb74463dff487257f733bf6be", "filename": "libstdc++-v3/include/parallel/for_each.h", "status": "modified", "additions": 37, "deletions": 17, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/531898c3c23ba05afe22253f9cdee6491882c92c/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffor_each.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/531898c3c23ba05afe22253f9cdee6491882c92c/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffor_each.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffor_each.h?ref=531898c3c23ba05afe22253f9cdee6491882c92c", "patch": "@@ -1,6 +1,6 @@\n // -*- C++ -*-\n \n-// Copyright (C) 2007 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the terms\n@@ -61,22 +61,42 @@ namespace __gnu_parallel\n    *  @param output Output iterator.\n    *  @param bound Maximum number of elements processed.\n    *  @param parallelism_tag Parallelization method */\n-  template<typename InputIterator, typename UserOp, typename Functionality, typename Red, typename Result>\n-  UserOp\n-  for_each_template_random_access(InputIterator begin, InputIterator end,\n-\t\t\t\t  UserOp user_op, Functionality& functionality,\n-\t\t\t\t  Red reduction, Result reduction_start,\n-\t\t\t\t  Result& output,\n-\t\t\t\t  typename std::iterator_traits<InputIterator>::difference_type bound, parallelism parallelism_tag)\n-  {\n-    if (parallelism_tag == parallel_unbalanced)\n-      return for_each_template_random_access_ed(begin, end, user_op, functionality, reduction, reduction_start, output, bound);\n-    else if (parallelism_tag == parallel_omp_loop)\n-      return for_each_template_random_access_omp_loop(begin, end, user_op, functionality, reduction, reduction_start, output, bound);\n-    else if (parallelism_tag == parallel_omp_loop_static)\n-      return for_each_template_random_access_omp_loop(begin, end, user_op, functionality, reduction, reduction_start, output, bound);\n-    else\t//e. g. parallel_balanced\n-      return for_each_template_random_access_workstealing(begin, end, user_op, functionality, reduction, reduction_start, output, bound);\n+  template<typename InputIterator, typename UserOp,\n+\t   typename Functionality, typename Red, typename Result>\n+    UserOp\n+    for_each_template_random_access(InputIterator begin, InputIterator end,\n+\t\t\t\t    UserOp user_op,\n+\t\t\t\t    Functionality& functionality,\n+\t\t\t\t    Red reduction, Result reduction_start,\n+\t\t\t\t    Result& output, typename\n+\t\t\t\t    std::iterator_traits<InputIterator>::\n+\t\t\t\t    difference_type bound,\n+\t\t\t\t    parallelism parallelism_tag)\n+    {\n+      if (parallelism_tag == parallel_unbalanced)\n+\treturn for_each_template_random_access_ed(begin, end, user_op,\n+\t\t\t\t\t\t  functionality, reduction,\n+\t\t\t\t\t\t  reduction_start,\n+\t\t\t\t\t\t  output, bound);\n+      else if (parallelism_tag == parallel_omp_loop)\n+\treturn for_each_template_random_access_omp_loop(begin, end, user_op,\n+\t\t\t\t\t\t\tfunctionality,\n+\t\t\t\t\t\t\treduction,\n+\t\t\t\t\t\t\treduction_start,\n+\t\t\t\t\t\t\toutput, bound);\n+      else if (parallelism_tag == parallel_omp_loop_static)\n+\treturn for_each_template_random_access_omp_loop(begin, end, user_op,\n+\t\t\t\t\t\t\tfunctionality,\n+\t\t\t\t\t\t\treduction,\n+\t\t\t\t\t\t\treduction_start,\n+\t\t\t\t\t\t\toutput, bound);\n+      else\t//e. g. parallel_balanced\n+\treturn for_each_template_random_access_workstealing(begin, end,\n+\t\t\t\t\t\t\t    user_op,\n+\t\t\t\t\t\t\t    functionality,\n+\t\t\t\t\t\t\t    reduction,\n+\t\t\t\t\t\t\t    reduction_start,\n+\t\t\t\t\t\t\t    output, bound);\n   }\n }\n "}, {"sha": "b38aded5cb325296b01b12aecf77c9802189bee6", "filename": "libstdc++-v3/include/parallel/for_each_selectors.h", "status": "modified", "additions": 74, "deletions": 55, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/531898c3c23ba05afe22253f9cdee6491882c92c/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffor_each_selectors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/531898c3c23ba05afe22253f9cdee6491882c92c/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffor_each_selectors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffor_each_selectors.h?ref=531898c3c23ba05afe22253f9cdee6491882c92c", "patch": "@@ -1,6 +1,6 @@\n // -*- C++ -*-\n \n-// Copyright (C) 2007 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the terms\n@@ -63,11 +63,12 @@ namespace __gnu_parallel\n      *  @param o Operator.\n      *  @param i Iterator referencing object. */\n     template<typename Op>\n-    inline bool operator()(Op& o, It i)\n-    {\n-      o(*i);\n-      return true;\n-    }\n+      bool\n+      operator()(Op& o, It i)\n+      {\n+\to(*i);\n+\treturn true;\n+      }\n   };\n \n   /** @brief std::generate() selector. */\n@@ -78,11 +79,12 @@ namespace __gnu_parallel\n      *  @param o Operator.\n      *  @param i Iterator referencing object. */\n     template<typename Op>\n-    inline bool operator()(Op& o, It i)\n-    {\n-      *i = o();\n-      return true;\n-    }\n+      bool\n+      operator()(Op& o, It i)\n+      {\n+\t*i = o();\n+\treturn true;\n+      }\n   };\n \n   /** @brief std::fill() selector. */\n@@ -93,11 +95,12 @@ namespace __gnu_parallel\n      *  @param v Current value.\n      *  @param i Iterator referencing object. */\n     template<typename Val>\n-    inline bool operator()(Val& v, It i)\n-    {\n-      *i = v;\n-      return true;\n-    }\n+      bool\n+      operator()(Val& v, It i)\n+      {\n+\t*i = v;\n+\treturn true;\n+      }\n   };\n \n   /** @brief std::transform() selector, one input sequence variant. */\n@@ -108,11 +111,12 @@ namespace __gnu_parallel\n      *  @param o Operator.\n      *  @param i Iterator referencing object. */\n     template<typename Op>\n-    inline bool operator()(Op& o, It i)\n-    {\n-      *i.second = o(*i.first);\n-      return true;\n-    }\n+      bool\n+      operator()(Op& o, It i)\n+      {\n+\t*i.second = o(*i.first);\n+\treturn true;\n+      }\n   };\n \n   /** @brief std::transform() selector, two input sequences variant. */\n@@ -123,11 +127,12 @@ namespace __gnu_parallel\n      *  @param o Operator.\n      *  @param i Iterator referencing object. */\n     template<typename Op>\n-    inline bool operator()(Op& o, It i)\n-    {\n-      *i.third = o(*i.first, *i.second);\n-      return true;\n-    }\n+      bool\n+      operator()(Op& o, It i)\n+      {\n+\t*i.third = o(*i.first, *i.second);\n+\treturn true;\n+      }\n   };\n \n   /** @brief std::replace() selector. */\n@@ -144,7 +149,8 @@ namespace __gnu_parallel\n     /** @brief Functor execution.\n      *  @param v Current value.\n      *  @param i Iterator referencing object. */\n-    inline bool operator()(T& v, It i)\n+    bool\n+    operator()(T& v, It i)\n     {\n       if (*i == v)\n \t*i = new_val;\n@@ -166,7 +172,8 @@ namespace __gnu_parallel\n     /** @brief Functor execution.\n      *  @param o Operator.\n      *  @param i Iterator referencing object. */\n-    inline bool operator()(Op& o, It i)\n+    bool\n+    operator()(Op& o, It i)\n     {\n       if (o(*i))\n \t*i = new_val;\n@@ -183,8 +190,9 @@ namespace __gnu_parallel\n      *  @param i Iterator referencing object.\n      *  @return 1 if count, 0 if does not count. */\n     template<typename Val>\n-    inline Diff operator()(Val& v, It i)\n-    { return (v == *i) ? 1 : 0; }\n+      Diff\n+      operator()(Val& v, It i)\n+      { return (v == *i) ? 1 : 0; }\n   };\n \n   /** @brief std::count_if () selector. */\n@@ -196,8 +204,9 @@ namespace __gnu_parallel\n      *  @param i Iterator referencing object.\n      *  @return 1 if count, 0 if does not count. */\n     template<typename Op>\n-    inline Diff operator()(Op& o, It i)\n-    { return (o(*i)) ? 1 : 0; }\n+      Diff\n+      operator()(Op& o, It i)\n+      { return (o(*i)) ? 1 : 0; }\n   };\n \n   /** @brief std::accumulate() selector. */\n@@ -209,8 +218,8 @@ namespace __gnu_parallel\n      *  @param i Iterator referencing object.\n      *  @return The current value. */\n     template<typename Op>\n-    inline typename std::iterator_traits<It>::value_type operator()(Op o, It i)\n-    { return *i; }\n+      typename std::iterator_traits<It>::value_type operator()(Op o, It i)\n+      { return *i; }\n   };\n \n   /** @brief std::inner_product() selector. */\n@@ -226,18 +235,21 @@ namespace __gnu_parallel\n     /** @brief Constructor.\n      *  @param b1 Begin iterator of first sequence.\n      *  @param b2 Begin iterator of second sequence. */\n-    explicit inner_product_selector(It b1, It2 b2) : begin1_iterator(b1), begin2_iterator(b2) { }\n+    explicit inner_product_selector(It b1, It2 b2)\n+    : begin1_iterator(b1), begin2_iterator(b2) { }\n \n     /** @brief Functor execution.\n      *  @param mult Multiplication functor.\n      *  @param current Iterator referencing object.\n      *  @return Inner product elemental result. */\n     template<typename Op>\n-    inline T operator()(Op mult, It current)\n-    {\n-      typename std::iterator_traits<It>::difference_type position = current - begin1_iterator;\n-      return mult(*current, *(begin2_iterator + position));\n-    }\n+      T\n+      operator()(Op mult, It current)\n+      {\n+\ttypename std::iterator_traits<It>::difference_type position\n+\t  = current - begin1_iterator;\n+\treturn mult(*current, *(begin2_iterator + position));\n+      }\n   };\n \n   /** @brief Selector that just returns the passed iterator. */\n@@ -249,8 +261,9 @@ namespace __gnu_parallel\n      *  @param i Iterator referencing object.\n      *  @return Passed iterator. */\n     template<typename Op>\n-    inline It operator()(Op o, It i)\n-    { return i; }\n+      It\n+      operator()(Op o, It i)\n+      { return i; }\n   };\n \n   /** @brief Selector that returns the difference between two adjacent\n@@ -260,13 +273,14 @@ namespace __gnu_parallel\n   struct adjacent_difference_selector : public generic_for_each_selector<It>\n   {\n     template<typename Op>\n-    inline bool operator()(Op& o, It i)\n-    {\n-      typename It::first_type go_back_one = i.first;\n-      --go_back_one;\n-      *i.second = o(*i.first, *go_back_one);\n-      return true;\n-    }\n+      bool\n+      operator()(Op& o, It i)\n+      {\n+\ttypename It::first_type go_back_one = i.first;\n+\t--go_back_one;\n+\t*i.second = o(*i.first, *go_back_one);\n+\treturn true;\n+      }\n   };\n \n   // XXX move into type_traits?\n@@ -280,14 +294,15 @@ namespace __gnu_parallel\n     /** @brief Functor execution.\n      *  @param i Iterator referencing object. */\n     template<typename It>\n-    inline void operator()(It i)\n-    { }\n+      void\n+      operator()(It i) { }\n   };\n \n   /** @brief Reduction function doing nothing. */\n   struct dummy_reduct\n   {\n-    inline bool operator()(bool /*x*/, bool /*y*/) const\n+    bool\n+    operator()(bool /*x*/, bool /*y*/) const\n     { return true; }\n   };\n \n@@ -300,7 +315,8 @@ namespace __gnu_parallel\n     explicit min_element_reduct(Comp &c) : comp(c)\n     { }\n \n-    inline It operator()(It x, It y)\n+    It\n+    operator()(It x, It y)\n     {\n       if (comp(*x, *y))\n \treturn x;\n@@ -318,7 +334,8 @@ namespace __gnu_parallel\n     explicit max_element_reduct(Comp& c) : comp(c)\n     { }\n \n-    inline It operator()(It x, It y)\n+    It\n+    operator()(It x, It y)\n     {\n       if (comp(*x, *y))\n \treturn y;\n@@ -336,7 +353,9 @@ namespace __gnu_parallel\n     explicit accumulate_binop_reduct(BinOp& b) : binop(b) {}\n \n     template<typename Result, typename Addend>\n-    Result operator()(const Result& x, const Addend& y) { return binop(x, y); }\n+      Result\n+      operator()(const Result& x, const Addend& y)\n+      { return binop(x, y); }\n   };\n }\n "}, {"sha": "ba20a460d5c9b30ba82212a862e878772415d898", "filename": "libstdc++-v3/include/parallel/iterator.h", "status": "modified", "additions": 145, "deletions": 143, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/531898c3c23ba05afe22253f9cdee6491882c92c/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fiterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/531898c3c23ba05afe22253f9cdee6491882c92c/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fiterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fiterator.h?ref=531898c3c23ba05afe22253f9cdee6491882c92c", "patch": "@@ -1,6 +1,6 @@\n // -*- C++ -*-\n \n-// Copyright (C) 2007 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the terms\n@@ -47,156 +47,158 @@ namespace __gnu_parallel\n    *  applied to both child iterators.\n    */\n   template<typename Iterator1, typename Iterator2, typename IteratorCategory>\n-  class iterator_pair : public std::pair<Iterator1, Iterator2>\n-  {\n-  private:\n-    typedef iterator_pair<Iterator1, Iterator2, IteratorCategory> type;\n-    typedef std::pair<Iterator1, Iterator2> base_type;\n-\n-  public:\n-    typedef IteratorCategory iterator_category;\n-    typedef void value_type;\n-\n-    typedef std::iterator_traits<Iterator1> traits_type;\n-    typedef typename traits_type::difference_type difference_type;\n-    typedef type* pointer;\n-    typedef type& reference;\n-\n-    iterator_pair() { }\n-\n-    iterator_pair(const Iterator1& first, const Iterator2& second) \n-    : base_type(first, second) { }\n-\n-    // Pre-increment operator.\n-    type&\n-    operator++()\n+    class iterator_pair : public std::pair<Iterator1, Iterator2>\n     {\n-      ++base_type::first;\n-      ++base_type::second;\n-      return *this;\n-    }\n-\n-    // Post-increment operator.\n-    const type\n-    operator++(int)\n-    { return type(base_type::first++, base_type::second++); }\n-\n-    // Pre-decrement operator.\n-    type&\n-    operator--()\n-    {\n-      --base_type::first;\n-      --base_type::second;\n-      return *this;\n-    }\n-\n-    // Post-decrement operator.\n-    const type\n-    operator--(int)\n-    { return type(base_type::first--, base_type::second--); }\n-\n-    // Type conversion.\n-    operator Iterator2() const\n-    { return base_type::second; }\n-\n-    type&\n-    operator=(const type& other)\n-    {\n-      base_type::first = other.first;\n-      base_type::second = other.second;\n-      return *this;\n-    }\n-\n-    type\n-    operator+(difference_type delta) const\n-    { return type(base_type::first + delta, base_type::second + delta); }\n-\n-    difference_type\n-    operator-(const type& other) const\n-    { return base_type::first - other.first; }\n+    private:\n+      typedef iterator_pair<Iterator1, Iterator2, IteratorCategory> type;\n+      typedef std::pair<Iterator1, Iterator2> base_type;\n+\n+    public:\n+      typedef IteratorCategory iterator_category;\n+      typedef void value_type;\n+\n+      typedef std::iterator_traits<Iterator1> traits_type;\n+      typedef typename traits_type::difference_type difference_type;\n+      typedef type* pointer;\n+      typedef type& reference;\n+\n+      iterator_pair() { }\n+\n+      iterator_pair(const Iterator1& first, const Iterator2& second) \n+      : base_type(first, second) { }\n+\n+      // Pre-increment operator.\n+      type&\n+      operator++()\n+      {\n+\t++base_type::first;\n+\t++base_type::second;\n+\treturn *this;\n+      }\n+\n+      // Post-increment operator.\n+      const type\n+      operator++(int)\n+      { return type(base_type::first++, base_type::second++); }\n+\n+      // Pre-decrement operator.\n+      type&\n+      operator--()\n+      {\n+\t--base_type::first;\n+\t--base_type::second;\n+\treturn *this;\n+      }\n+\n+      // Post-decrement operator.\n+      const type\n+      operator--(int)\n+      { return type(base_type::first--, base_type::second--); }\n+\n+      // Type conversion.\n+      operator Iterator2() const\n+      { return base_type::second; }\n+\n+      type&\n+      operator=(const type& other)\n+      {\n+\tbase_type::first = other.first;\n+\tbase_type::second = other.second;\n+\treturn *this;\n+      }\n+\n+      type\n+      operator+(difference_type delta) const\n+      { return type(base_type::first + delta, base_type::second + delta); }\n+\n+      difference_type\n+      operator-(const type& other) const\n+      { return base_type::first - other.first; }\n   };\n \n \n   /** @brief A triple of iterators. The usual iterator operations are\n       applied to all three child iterators.\n    */\n-  template<typename Iterator1, typename Iterator2, typename Iterator3, typename IteratorCategory>\n-  class iterator_triple\n-  {\n-  private:\n-    typedef iterator_triple<Iterator1, Iterator2, Iterator3, IteratorCategory> type;\n-\n-  public:\n-    typedef IteratorCategory iterator_category;\n-    typedef void value_type;\n-    typedef typename Iterator1::difference_type difference_type;\n-    typedef type* pointer;\n-    typedef type& reference;\n-\n-    Iterator1 first;\n-    Iterator2 second;\n-    Iterator3 third;\n-\n-    iterator_triple() { }\n-\n-    iterator_triple(const Iterator1& _first, const Iterator2& _second,\n-\t\t    const Iterator3& _third)\n-    {\n-      first = _first;\n-      second = _second;\n-      third = _third;\n-    }\n-\n-    // Pre-increment operator.\n-    type&\n-    operator++()\n-    {\n-      ++first;\n-      ++second;\n-      ++third;\n-      return *this;\n-    }\n-\n-    // Post-increment operator.\n-    const type\n-    operator++(int)\n-    { return type(first++, second++, third++); }\n-\n-    // Pre-decrement operator.\n-    type&\n-    operator--()\n-    {\n-      --first;\n-      --second;\n-      --third;\n-      return *this;\n-    }\n-\n-    // Post-decrement operator.\n-    const type\n-    operator--(int)\n-    { return type(first--, second--, third--); }\n-\n-    // Type conversion.\n-    operator Iterator3() const\n-    { return third; }\n-\n-    type&\n-    operator=(const type& other)\n+  template<typename Iterator1, typename Iterator2, typename Iterator3,\n+\t   typename IteratorCategory>\n+    class iterator_triple\n     {\n-      first = other.first;\n-      second = other.second;\n-      third = other.third;\n-      return *this;\n-    }\n-\n-    type\n-    operator+(difference_type delta) const\n-    { return type(first + delta, second + delta, third + delta); }\n-\n-    difference_type\n-    operator-(const type& other) const\n-    { return first - other.first; }\n+    private:\n+      typedef iterator_triple<Iterator1, Iterator2, Iterator3,\n+\t\t\t      IteratorCategory> type;\n+\n+    public:\n+      typedef IteratorCategory iterator_category;\n+      typedef void value_type;\n+      typedef typename Iterator1::difference_type difference_type;\n+      typedef type* pointer;\n+      typedef type& reference;\n+\n+      Iterator1 first;\n+      Iterator2 second;\n+      Iterator3 third;\n+\n+      iterator_triple() { }\n+\n+      iterator_triple(const Iterator1& _first, const Iterator2& _second,\n+\t\t      const Iterator3& _third)\n+      {\n+\tfirst = _first;\n+\tsecond = _second;\n+\tthird = _third;\n+      }\n+\n+      // Pre-increment operator.\n+      type&\n+      operator++()\n+      {\n+\t++first;\n+\t++second;\n+\t++third;\n+\treturn *this;\n+      }\n+\n+      // Post-increment operator.\n+      const type\n+      operator++(int)\n+      { return type(first++, second++, third++); }\n+\n+      // Pre-decrement operator.\n+      type&\n+      operator--()\n+      {\n+\t--first;\n+\t--second;\n+\t--third;\n+\treturn *this;\n+      }\n+\n+      // Post-decrement operator.\n+      const type\n+      operator--(int)\n+      { return type(first--, second--, third--); }\n+\n+      // Type conversion.\n+      operator Iterator3() const\n+      { return third; }\n+\n+      type&\n+      operator=(const type& other)\n+      {\n+\tfirst = other.first;\n+\tsecond = other.second;\n+\tthird = other.third;\n+\treturn *this;\n+      }\n+\n+      type\n+      operator+(difference_type delta) const\n+      { return type(first + delta, second + delta, third + delta); }\n+\n+      difference_type\n+      operator-(const type& other) const\n+      { return first - other.first; }\n   };\n }\n "}, {"sha": "b3461054e4a6a735b5fa4f1b1b6574e49198968b", "filename": "libstdc++-v3/include/parallel/list_partition.h", "status": "modified", "additions": 90, "deletions": 89, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/531898c3c23ba05afe22253f9cdee6491882c92c/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flist_partition.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/531898c3c23ba05afe22253f9cdee6491882c92c/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flist_partition.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flist_partition.h?ref=531898c3c23ba05afe22253f9cdee6491882c92c", "patch": "@@ -1,6 +1,6 @@\n // -*- C++ -*-\n \n-// Copyright (C) 2007 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the terms\n@@ -52,36 +52,35 @@ namespace __gnu_parallel\n    *  grown or not\n    */\n   template<typename InputIterator>\n-  void\n-  shrink_and_double(std::vector<InputIterator>& os_starts, size_t& count_to_two, size_t& range_length, const bool make_twice)\n-  {\n-    ++count_to_two;\n-    if (not make_twice or count_to_two < 2)\n-      {\n+    void\n+    shrink_and_double(std::vector<InputIterator>& os_starts,\n+\t\t      size_t& count_to_two, size_t& range_length,\n+\t\t      const bool make_twice)\n+    {\n+      ++count_to_two;\n+      if (not make_twice or count_to_two < 2)\n \tshrink(os_starts, count_to_two, range_length);\n-      }\n-    else\n-      {\n-\tos_starts.resize((os_starts.size() - 1) * 2 + 1);\n-\tcount_to_two = 0;\n-      }\n-  }\n+      else\n+\t{\n+\t  os_starts.resize((os_starts.size() - 1) * 2 + 1);\n+\t  count_to_two = 0;\n+\t}\n+    }\n \n   /** @brief Combines two ranges into one and thus halves the number of ranges.\n    *  @param os_starts Start positions worked on (oversampled).\n    *  @param count_to_two Counts up to 2.\n    *  @param range_length Current length of a chunk. */\n   template<typename InputIterator>\n-  void\n-  shrink(std::vector<InputIterator>& os_starts, size_t& count_to_two,\n-\t size_t& range_length)\n-  {\n-    for (typename std::vector<InputIterator>::size_type i = 0; i <= (os_starts.size() / 2); ++i)\n-      {\n+    void\n+    shrink(std::vector<InputIterator>& os_starts, size_t& count_to_two,\n+\t   size_t& range_length)\n+    {\n+      for (typename std::vector<InputIterator>::size_type i = 0;\n+\t   i <= (os_starts.size() / 2); ++i)\n \tos_starts[i] = os_starts[i * 2];\n-      }\n-    range_length *= 2;\n-  }\n+      range_length *= 2;\n+    }\n \n   /** @brief Splits a sequence given by input iterators into parts of\n    * almost equal size\n@@ -103,79 +102,81 @@ namespace __gnu_parallel\n    *  @return Length of the whole sequence.\n    */\n   template<typename InputIterator, typename FunctorType>\n-  size_t\n-  list_partition(const InputIterator begin, const InputIterator end,\n-\t\t InputIterator* starts, size_t* lengths, const int num_parts,\n-\t\t FunctorType& f, int oversampling = 0)\n-  {\n-    bool make_twice = false;\n-\n-    // According to the oversampling factor, the resizing algorithm is chosen.\n-    if (oversampling == 0)\n-      {\n-\tmake_twice = true;\n-\toversampling = 1;\n-      }\n-\n-    std::vector<InputIterator> os_starts(2 * oversampling * num_parts + 1);\n-\n-    os_starts[0]= begin;\n-    InputIterator prev = begin, it = begin;\n-    size_t dist_limit = 0, dist = 0;\n-    size_t cur = 1, next = 1;\n-    size_t range_length = 1;\n-    size_t count_to_two = 0;\n-    while (it != end){\n-      cur = next;\n-      for (; cur < os_starts.size() and it != end; ++cur)\n+    size_t\n+    list_partition(const InputIterator begin, const InputIterator end,\n+\t\t   InputIterator* starts, size_t* lengths, const int num_parts,\n+\t\t   FunctorType& f, int oversampling = 0)\n+    {\n+      bool make_twice = false;\n+\n+      // According to the oversampling factor, the resizing algorithm is chosen.\n+      if (oversampling == 0)\n+\t{\n+\t  make_twice = true;\n+\t  oversampling = 1;\n+\t}\n+\n+      std::vector<InputIterator> os_starts(2 * oversampling * num_parts + 1);\n+\n+      os_starts[0]= begin;\n+      InputIterator prev = begin, it = begin;\n+      size_t dist_limit = 0, dist = 0;\n+      size_t cur = 1, next = 1;\n+      size_t range_length = 1;\n+      size_t count_to_two = 0;\n+      while (it != end)\n \t{\n-\t  for (dist_limit += range_length; dist < dist_limit and it != end; ++dist)\n+\t  cur = next;\n+\t  for (; cur < os_starts.size() and it != end; ++cur)\n \t    {\n-\t      f(it);\n-\t      ++it;\n+\t      for (dist_limit += range_length;\n+\t\t   dist < dist_limit and it != end; ++dist)\n+\t\t{\n+\t\t  f(it);\n+\t\t  ++it;\n+\t\t}\n+\t      os_starts[cur] = it;\n \t    }\n-\t  os_starts[cur] = it;\n+\n+\t  // Must compare for end and not cur < os_starts.size() , because\n+\t  // cur could be == os_starts.size() as well\n+\t  if (it == end)\n+\t    break;\n+\n+\t  shrink_and_double(os_starts, count_to_two, range_length, make_twice);\n+\t  next = os_starts.size() / 2 + 1;\n \t}\n \n-      // Must compare for end and not cur < os_starts.size() , because\n-      // cur could be == os_starts.size() as well\n-      if (it == end)\n-\tbreak;\n+      // Calculation of the parts (one must be extracted from current\n+      // because the partition beginning at end, consists only of\n+      // itself).\n+      size_t size_part = (cur - 1) / num_parts;\n+      int size_greater = static_cast<int>((cur - 1) % num_parts);\n+      starts[0] = os_starts[0];\n \n-      shrink_and_double(os_starts, count_to_two, range_length, make_twice);\n-      next = os_starts.size()/2 + 1;\n-    }\n+      size_t index = 0;\n \n-    // Calculation of the parts (one must be extracted from current\n-    // because the partition beginning at end, consists only of\n-    // itself).\n-    size_t size_part = (cur - 1) / num_parts;\n-    int size_greater = static_cast<int>((cur - 1) % num_parts);\n-    starts[0] = os_starts[0];\n-\n-    size_t index = 0;\n-\n-    // Smallest partitions.\n-    for (int i = 1; i < (num_parts + 1 - size_greater); ++i)\n-      {\n-\tlengths[i-1] =  size_part * range_length;\n-\tindex += size_part;\n-\tstarts[i] = os_starts[index];\n-      }\n-\n-    // Biggest partitions.\n-    for (int i = num_parts + 1 - size_greater; i <= num_parts; ++i)\n-      {\n-\tlengths[i-1] =  (size_part+1) * range_length;\n-\tindex += (size_part+1);\n-\tstarts[i] = os_starts[index];\n-      }\n-\n-    // Correction of the end size (the end iteration has not finished).\n-    lengths[num_parts - 1] -= (dist_limit - dist);\n-\n-    return dist;\n-  }\n+      // Smallest partitions.\n+      for (int i = 1; i < (num_parts + 1 - size_greater); ++i)\n+\t{\n+\t  lengths[i-1] =  size_part * range_length;\n+\t  index += size_part;\n+\t  starts[i] = os_starts[index];\n+\t}\n+\n+      // Biggest partitions.\n+      for (int i = num_parts + 1 - size_greater; i <= num_parts; ++i)\n+\t{\n+\t  lengths[i-1] =  (size_part+1) * range_length;\n+\t  index += (size_part+1);\n+\t  starts[i] = os_starts[index];\n+\t}\n+\n+      // Correction of the end size (the end iteration has not finished).\n+      lengths[num_parts - 1] -= (dist_limit - dist);\n+\n+      return dist;\n+    }\n }\n \n #endif"}, {"sha": "572688062fc096aef36d7d69f65ad1af014053d2", "filename": "libstdc++-v3/include/parallel/losertree.h", "status": "modified", "additions": 55, "deletions": 64, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/531898c3c23ba05afe22253f9cdee6491882c92c/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flosertree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/531898c3c23ba05afe22253f9cdee6491882c92c/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flosertree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flosertree.h?ref=531898c3c23ba05afe22253f9cdee6491882c92c", "patch": "@@ -76,9 +76,8 @@ template<typename T, typename Comparator = std::less<T> >\n     Comparator comp;\n \n   public:\n-    inline\n     LoserTreeExplicit(unsigned int _size, Comparator _comp = std::less<T>())\n-      : comp(_comp)\n+    : comp(_comp)\n     {\n       size = _size;\n       offset = size;\n@@ -92,14 +91,14 @@ template<typename T, typename Comparator = std::less<T> >\n         }\n     }\n \n-    inline ~LoserTreeExplicit()\n+    ~LoserTreeExplicit()\n     { delete[] losers; }\n \n-    inline int\n+    int\n     get_min_source()\n     { return losers[0].source; }\n \n-    inline void\n+    void\n     insert_start(T key, int source, bool sup)\n     {\n       bool inf = false;\n@@ -122,10 +121,10 @@ template<typename T, typename Comparator = std::less<T> >\n       losers[0].source = source;\n     }\n \n-    inline void\n+    void\n     init() { }\n \n-    inline void\n+    void\n     delete_min_insert(T key, bool sup)\n     {\n       bool inf = false;\n@@ -151,7 +150,7 @@ template<typename T, typename Comparator = std::less<T> >\n       losers[0].source = source;\n     }\n \n-    inline void\n+    void\n     insert_start_stable(T key, int source, bool sup)\n     {\n       bool inf = false;\n@@ -176,10 +175,10 @@ template<typename T, typename Comparator = std::less<T> >\n       losers[0].source = source;\n     }\n \n-    inline void\n+    void\n     init_stable() { }\n \n-    inline void\n+    void\n     delete_min_insert_stable(T key, bool sup)\n     {\n       bool inf = false;\n@@ -233,7 +232,7 @@ template<typename T, typename Comparator = std::less<T> >\n     bool first_insert;\n \n   public:\n-    inline LoserTree(unsigned int _k, Comparator _comp = std::less<T>())\n+    LoserTree(unsigned int _k, Comparator _comp = std::less<T>())\n     : comp(_comp)\n     {\n       ik = _k;\n@@ -249,14 +248,14 @@ template<typename T, typename Comparator = std::less<T> >\n       first_insert = true;\n     }\n \n-    inline ~LoserTree()\n+    ~LoserTree()\n     { ::operator delete(losers); }\n \n-    inline int\n+    int\n     get_min_source()\n     { return losers[0].source; }\n \n-    inline void\n+    void\n     insert_start(const T& key, int source, bool sup)\n     {\n       unsigned int pos = k + source;\n@@ -303,12 +302,12 @@ template<typename T, typename Comparator = std::less<T> >\n         }\n     }\n \n-    inline void\n+    void\n     init()\n     { losers[0] = losers[init_winner(1)]; }\n \n     // Do not pass const reference since key will be used as local variable.\n-    inline void\n+    void\n     delete_min_insert(T key, bool sup)\n     {\n       int source = losers[0].source;\n@@ -329,7 +328,7 @@ template<typename T, typename Comparator = std::less<T> >\n       losers[0].key = key;\n     }\n \n-    inline void\n+    void\n     insert_start_stable(const T& key, int source, bool sup)\n     { return insert_start(key, source, sup); }\n \n@@ -361,12 +360,12 @@ template<typename T, typename Comparator = std::less<T> >\n         }\n     }\n \n-    inline void\n+    void\n     init_stable()\n     { losers[0] = losers[init_winner_stable(1)]; }\n \n     // Do not pass const reference since key will be used as local variable.\n-    inline void\n+    void\n     delete_min_insert_stable(T key, bool sup)\n     {\n       int source = losers[0].source;\n@@ -432,9 +431,8 @@ template<typename T, typename Comparator = std::less<T> >\n     Comparator comp;\n \n   public:\n-    inline\n     LoserTreeReference(unsigned int _k, Comparator _comp = std::less<T>())\n-      : comp(_comp)\n+    : comp(_comp)\n     {\n       ik = _k;\n \n@@ -449,19 +447,19 @@ template<typename T, typename Comparator = std::less<T> >\n         losers[i + k].sup = true;\n     }\n \n-    inline ~LoserTreeReference()\n+    ~LoserTreeReference()\n     {\n       delete[] losers;\n #ifndef COPY\n       delete[] keys;\n #endif\n     }\n \n-    inline int\n+    int\n     get_min_source()\n     { return losers[0].source; }\n \n-    inline void\n+    void\n     insert_start(T key, int source, bool sup)\n     {\n       unsigned int pos = k + source;\n@@ -498,13 +496,13 @@ template<typename T, typename Comparator = std::less<T> >\n         }\n     }\n \n-    inline void\n+    void\n     init()\n     {\n       losers[0] = losers[init_winner(1)];\n     }\n \n-    inline void\n+    void\n     delete_min_insert(T key, bool sup)\n     {\n       int source = losers[0].source;\n@@ -529,7 +527,7 @@ template<typename T, typename Comparator = std::less<T> >\n #endif\n     }\n \n-    inline void\n+    void\n     insert_start_stable(T key, int source, bool sup)\n     { return insert_start(key, source, sup); }\n \n@@ -560,11 +558,11 @@ template<typename T, typename Comparator = std::less<T> >\n         }\n     }\n \n-    inline void\n+    void\n     init_stable()\n     { losers[0] = losers[init_winner_stable(1)]; }\n \n-    inline void\n+    void\n     delete_min_insert_stable(T key, bool sup)\n     {\n       int source = losers[0].source;\n@@ -622,7 +620,6 @@ template<typename T, typename Comparator = std::less<T> >\n     Comparator comp;\n \n   public:\n-    inline\n     LoserTreePointer(unsigned int _k, Comparator _comp = std::less<T>())\n       : comp(_comp)\n     {\n@@ -636,14 +633,14 @@ template<typename T, typename Comparator = std::less<T> >\n         losers[i + k].sup = true;\n     }\n \n-    inline ~LoserTreePointer()\n+    ~LoserTreePointer()\n     { delete[] losers; }\n \n-    inline int\n+    int\n     get_min_source()\n     { return losers[0].source; }\n \n-    inline void\n+    void\n     insert_start(const T& key, int source, bool sup)\n     {\n       unsigned int pos = k + source;\n@@ -657,9 +654,7 @@ template<typename T, typename Comparator = std::less<T> >\n     init_winner(unsigned int root)\n     {\n       if (root >= k)\n-        {\n-          return root;\n-        }\n+\treturn root;\n       else\n         {\n           unsigned int left = init_winner (2 * root);\n@@ -681,11 +676,11 @@ template<typename T, typename Comparator = std::less<T> >\n         }\n     }\n \n-    inline void\n+    void\n     init()\n     { losers[0] = losers[init_winner(1)]; }\n \n-    inline void\n+    void\n     delete_min_insert(const T& key, bool sup)\n     {\n       const T* keyp = &key;\n@@ -707,7 +702,7 @@ template<typename T, typename Comparator = std::less<T> >\n       losers[0].keyp = keyp;\n     }\n \n-    inline void\n+    void\n     insert_start_stable(const T& key, int source, bool sup)\n     { return insert_start(key, source, sup); }\n \n@@ -739,11 +734,11 @@ template<typename T, typename Comparator = std::less<T> >\n         }\n     }\n \n-    inline void\n+    void\n     init_stable()\n     { losers[0] = losers[init_winner_stable(1)]; }\n \n-    inline void\n+    void\n     delete_min_insert_stable(const T& key, bool sup)\n     {\n       const T* keyp = &key;\n@@ -810,9 +805,8 @@ template<typename T, typename Comparator = std::less<T> >\n     }\n \n   public:\n-    inline\n     LoserTreeUnguarded(unsigned int _k, Comparator _comp = std::less<T>())\n-      : comp(_comp)\n+    : comp(_comp)\n     {\n       ik = _k;\n       // Next greater or equal power of 2.\n@@ -823,17 +817,17 @@ template<typename T, typename Comparator = std::less<T> >\n       map(1, 0, ik);\n     }\n \n-    inline ~LoserTreeUnguarded()\n+    ~LoserTreeUnguarded()\n     {\n       delete[] losers;\n       delete[] mapping;\n     }\n \n-    inline int\n+    int\n     get_min_source()\n     { return losers[0].source; }\n \n-    inline void\n+    void\n     insert_start(const T& key, int source, bool)\n     {\n       unsigned int pos = mapping[source];\n@@ -868,12 +862,12 @@ template<typename T, typename Comparator = std::less<T> >\n         }\n     }\n \n-    inline void\n+    void\n     init()\n     { losers[0] = losers[init_winner(1, 0, ik)]; }\n \n     // Do not pass const reference since key will be used as local variable.\n-    inline void\n+    void\n     delete_min_insert(const T& key, bool)\n     {\n       losers[0].key = key;\n@@ -891,15 +885,15 @@ template<typename T, typename Comparator = std::less<T> >\n         }\n     }\n \n-    inline void\n+    void\n     insert_start_stable(const T& key, int source, bool)\n     { return insert_start(key, source, false); }\n \n-    inline void\n+    void\n     init_stable()\n     { init(); }\n \n-    inline void\n+    void\n     delete_min_insert_stable(const T& key, bool)\n     {\n       losers[0].key = key;\n@@ -959,10 +953,9 @@ template<typename T, typename Comparator = std::less<T> >\n     }\n \n   public:\n-    inline\n     LoserTreePointerUnguarded(unsigned int _k,\n                               Comparator _comp = std::less<T>())\n-      : comp(_comp)\n+    : comp(_comp)\n     {\n       ik = _k;\n \n@@ -974,17 +967,17 @@ template<typename T, typename Comparator = std::less<T> >\n       map(1, 0, ik);\n     }\n \n-    inline ~LoserTreePointerUnguarded()\n+    ~LoserTreePointerUnguarded()\n     {\n       delete[] losers;\n       delete[] mapping;\n     }\n \n-    inline int\n+    int\n     get_min_source()\n     { return losers[0].source; }\n \n-    inline void\n+    void\n     insert_start(const T& key, int source, bool)\n     {\n       unsigned int pos = mapping[source];\n@@ -1019,13 +1012,11 @@ template<typename T, typename Comparator = std::less<T> >\n         }\n     }\n \n-    inline void\n+    void\n     init()\n-    {\n-      losers[0] = losers[init_winner(1, 0, ik)];\n-    }\n+    { losers[0] = losers[init_winner(1, 0, ik)]; }\n \n-    inline void\n+    void\n     delete_min_insert(const T& key, bool)\n     {\n       const T* keyp = &key;\n@@ -1044,15 +1035,15 @@ template<typename T, typename Comparator = std::less<T> >\n       losers[0].keyp = keyp;\n     }\n \n-    inline void\n+    void\n     insert_start_stable(const T& key, int source, bool)\n     { return insert_start(key, source, false); }\n \n-    inline void\n+    void\n     init_stable()\n     { init(); }\n \n-    inline void\n+    void\n     delete_min_insert_stable(const T& key, bool)\n     {\n       int& source = losers[0].source;"}, {"sha": "667213045b51ce21f950120615bad0078107b2dc", "filename": "libstdc++-v3/include/parallel/merge.h", "status": "modified", "additions": 136, "deletions": 101, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/531898c3c23ba05afe22253f9cdee6491882c92c/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmerge.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/531898c3c23ba05afe22253f9cdee6491882c92c/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmerge.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmerge.h?ref=531898c3c23ba05afe22253f9cdee6491882c92c", "patch": "@@ -1,6 +1,6 @@\n // -*- C++ -*-\n \n-// Copyright (C) 2007 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the terms\n@@ -56,33 +56,39 @@ namespace __gnu_parallel\n    * @param max_length Maximum number of elements to merge.\n    * @param comp Comparator.\n    * @return Output end iterator. */\n-  template<typename RandomAccessIterator1, typename RandomAccessIterator2, typename OutputIterator, typename _DifferenceTp, typename Comparator>\n-  OutputIterator\n-  merge_advance_usual(RandomAccessIterator1& begin1, RandomAccessIterator1 end1, RandomAccessIterator2& begin2, RandomAccessIterator2 end2, OutputIterator target, _DifferenceTp max_length, Comparator comp)\n-  {\n-    typedef _DifferenceTp difference_type;\n-    while (begin1 != end1 && begin2 != end2 && max_length > 0)\n-      {\n-\t// array1[i1] < array0[i0]\n-\tif (comp(*begin2, *begin1))\n-\t  *target++ = *begin2++;\n-\telse\n-\t  *target++ = *begin1++;\n-\tmax_length--;\n-      }\n-\n-    if (begin1 != end1)\n-      {\n-\ttarget = std::copy(begin1, begin1 + max_length, target);\n-\tbegin1 += max_length;\n-      }\n-    else\n-      {\n-\ttarget = std::copy(begin2, begin2 + max_length, target);\n-\tbegin2 += max_length;\n-      }\n-    return target;\n-  }\n+  template<typename RandomAccessIterator1, typename RandomAccessIterator2,\n+\t   typename OutputIterator, typename _DifferenceTp,\n+\t   typename Comparator>\n+    OutputIterator\n+    merge_advance_usual(RandomAccessIterator1& begin1,\n+\t\t\tRandomAccessIterator1 end1,\n+\t\t\tRandomAccessIterator2& begin2,\n+\t\t\tRandomAccessIterator2 end2, OutputIterator target,\n+\t\t\t_DifferenceTp max_length, Comparator comp)\n+    {\n+      typedef _DifferenceTp difference_type;\n+      while (begin1 != end1 && begin2 != end2 && max_length > 0)\n+\t{\n+\t  // array1[i1] < array0[i0]\n+\t  if (comp(*begin2, *begin1))\n+\t    *target++ = *begin2++;\n+\t  else\n+\t    *target++ = *begin1++;\n+\t  max_length--;\n+\t}\n+\n+      if (begin1 != end1)\n+\t{\n+\t  target = std::copy(begin1, begin1 + max_length, target);\n+\t  begin1 += max_length;\n+\t}\n+      else\n+\t{\n+\t  target = std::copy(begin2, begin2 + max_length, target);\n+\t  begin2 += max_length;\n+\t}\n+      return target;\n+    }\n \n   /** @brief Merge routine being able to merge only the @c max_length\n    * smallest elements.\n@@ -99,52 +105,59 @@ namespace __gnu_parallel\n    * @param max_length Maximum number of elements to merge.\n    * @param comp Comparator.\n    * @return Output end iterator. */\n-  template<typename RandomAccessIterator1, typename RandomAccessIterator2, typename OutputIterator, typename _DifferenceTp, typename Comparator>\n-  OutputIterator\n-  merge_advance_movc(RandomAccessIterator1& begin1, RandomAccessIterator1 end1, RandomAccessIterator2& begin2, RandomAccessIterator2 end2, OutputIterator target, _DifferenceTp max_length, Comparator comp)\n-  {\n-    typedef _DifferenceTp difference_type;\n-    typedef typename std::iterator_traits<RandomAccessIterator1>::value_type value_type1;\n-    typedef typename std::iterator_traits<RandomAccessIterator2>::value_type value_type2;\n+  template<typename RandomAccessIterator1, typename RandomAccessIterator2,\n+\t   typename OutputIterator, typename _DifferenceTp,\n+\t   typename Comparator>\n+    OutputIterator\n+    merge_advance_movc(RandomAccessIterator1& begin1,\n+\t\t       RandomAccessIterator1 end1,\n+\t\t       RandomAccessIterator2& begin2,\n+\t\t       RandomAccessIterator2 end2,\n+\t\t       OutputIterator target,\n+\t\t       _DifferenceTp max_length, Comparator comp)\n+    {\n+      typedef _DifferenceTp difference_type;\n+      typedef typename std::iterator_traits<RandomAccessIterator1>::value_type\n+\tvalue_type1;\n+      typedef typename std::iterator_traits<RandomAccessIterator2>::value_type\n+\tvalue_type2;\n \n #if _GLIBCXX_ASSERTIONS\n-    _GLIBCXX_PARALLEL_ASSERT(max_length >= 0);\n+      _GLIBCXX_PARALLEL_ASSERT(max_length >= 0);\n #endif\n \n-    while (begin1 != end1 && begin2 != end2 && max_length > 0)\n-      {\n-\tRandomAccessIterator1 next1 = begin1 + 1;\n-\tRandomAccessIterator2 next2 = begin2 + 1;\n-\tvalue_type1 element1 = *begin1;\n-\tvalue_type2 element2 = *begin2;\n-\n-\tif (comp(element2, element1))\n-\t  {\n-\t    element1 = element2;\n-\t    begin2 = next2;\n-\t  }\n-\telse\n-\t  {\n+      while (begin1 != end1 && begin2 != end2 && max_length > 0)\n+\t{\n+\t  RandomAccessIterator1 next1 = begin1 + 1;\n+\t  RandomAccessIterator2 next2 = begin2 + 1;\n+\t  value_type1 element1 = *begin1;\n+\t  value_type2 element2 = *begin2;\n+\n+\t  if (comp(element2, element1))\n+\t    {\n+\t      element1 = element2;\n+\t      begin2 = next2;\n+\t    }\n+\t  else\n \t    begin1 = next1;\n-\t  }\n-\n-\t*target = element1;\n-\n-\ttarget++;\n-\tmax_length--;\n-      }\n-    if (begin1 != end1)\n-      {\n-\ttarget = std::copy(begin1, begin1 + max_length, target);\n-\tbegin1 += max_length;\n-      }\n-    else\n-      {\n-\ttarget = std::copy(begin2, begin2 + max_length, target);\n-\tbegin2 += max_length;\n-      }\n-    return target;\n-  }\n+\n+\t  *target = element1;\n+\n+\t  target++;\n+\t  max_length--;\n+\t}\n+      if (begin1 != end1)\n+\t{\n+\t  target = std::copy(begin1, begin1 + max_length, target);\n+\t  begin1 += max_length;\n+\t}\n+      else\n+\t{\n+\t  target = std::copy(begin2, begin2 + max_length, target);\n+\t  begin2 += max_length;\n+\t}\n+      return target;\n+    }\n \n   /** @brief Merge routine being able to merge only the @c max_length\n    * smallest elements.\n@@ -160,14 +173,20 @@ namespace __gnu_parallel\n    *  @param max_length Maximum number of elements to merge.\n    *  @param comp Comparator.\n    *  @return Output end iterator. */\n-  template<typename RandomAccessIterator1, typename RandomAccessIterator2, typename OutputIterator, typename _DifferenceTp, typename Comparator>\n-  inline OutputIterator\n-  merge_advance(RandomAccessIterator1& begin1, RandomAccessIterator1 end1, RandomAccessIterator2& begin2, RandomAccessIterator2 end2, OutputIterator target, _DifferenceTp max_length, Comparator comp)\n-  {\n-    _GLIBCXX_CALL(max_length)\n+  template<typename RandomAccessIterator1, typename RandomAccessIterator2,\n+\t   typename OutputIterator, typename _DifferenceTp,\n+\t   typename Comparator>\n+    inline OutputIterator\n+    merge_advance(RandomAccessIterator1& begin1, RandomAccessIterator1 end1,\n+\t\t  RandomAccessIterator2& begin2, RandomAccessIterator2 end2,\n+\t\t  OutputIterator target, _DifferenceTp max_length,\n+\t\t  Comparator comp)\n+    {\n+      _GLIBCXX_CALL(max_length)\n \n-      return merge_advance_movc(begin1, end1, begin2, end2, target, max_length, comp);\n-  }\n+      return merge_advance_movc(begin1, end1, begin2, end2, target,\n+\t\t\t\tmax_length, comp);\n+    }\n \n   /** @brief Merge routine fallback to sequential in case the\n       iterators of the two input sequences are of different type.\n@@ -179,15 +198,20 @@ namespace __gnu_parallel\n       *  @param max_length Maximum number of elements to merge.\n       *  @param comp Comparator.\n       *  @return Output end iterator. */\n-  template<typename RandomAccessIterator1, typename RandomAccessIterator2, typename RandomAccessIterator3, typename Comparator>\n-  inline RandomAccessIterator3\n-  parallel_merge_advance(RandomAccessIterator1& begin1, RandomAccessIterator1 end1,\n-\t\t\t RandomAccessIterator2& begin2, RandomAccessIterator2 end2,\t//different iterators, parallel implementation not available\n-\t\t\t RandomAccessIterator3 target,\n-\t\t\t typename std::iterator_traits<RandomAccessIterator1>::difference_type max_length, Comparator comp)\n-  {\n-    return merge_advance(begin1, end1, begin2, end2, target, max_length, comp);\n-  }\n+  template<typename RandomAccessIterator1, typename RandomAccessIterator2,\n+\t   typename RandomAccessIterator3, typename Comparator>\n+    inline RandomAccessIterator3\n+    parallel_merge_advance(RandomAccessIterator1& begin1,\n+\t\t\t   RandomAccessIterator1 end1,\n+\t\t\t   RandomAccessIterator2& begin2,\n+\t\t\t   // different iterators, parallel implementation\n+\t\t\t   // not available\t\t\t   \n+\t\t\t   RandomAccessIterator2 end2,\n+\t\t\t   RandomAccessIterator3 target, typename\n+\t\t\t   std::iterator_traits<RandomAccessIterator1>::\n+\t\t\t   difference_type max_length, Comparator comp)\n+    { return merge_advance(begin1, end1, begin2, end2, target,\n+\t\t\t   max_length, comp); }\n \n   /** @brief Parallel merge routine being able to merge only the @c\n    * max_length smallest elements.\n@@ -204,22 +228,33 @@ namespace __gnu_parallel\n    *  @param comp Comparator.\n    *  @return Output end iterator.\n    */\n-  template<typename RandomAccessIterator1, typename RandomAccessIterator3, typename Comparator>\n-  inline RandomAccessIterator3\n-  parallel_merge_advance(RandomAccessIterator1& begin1, RandomAccessIterator1 end1, RandomAccessIterator1& begin2, RandomAccessIterator1 end2, RandomAccessIterator3 target, typename std::iterator_traits<RandomAccessIterator1>::difference_type max_length, Comparator comp)\n-  {\n-    typedef typename std::iterator_traits<RandomAccessIterator1>::value_type\n-      value_type;\n-    typedef typename std::iterator_traits<RandomAccessIterator1>::difference_type\n-      difference_type1 /* == difference_type2 */;\n-    typedef typename std::iterator_traits<RandomAccessIterator3>::difference_type\n-      difference_type3;\n-\n-    std::pair<RandomAccessIterator1, RandomAccessIterator1> seqs[2] = { std::make_pair(begin1, end1), std::make_pair(begin2, end2) };\n-    RandomAccessIterator3 target_end = parallel_multiway_merge(seqs, seqs + 2, target, comp, max_length, true, false);\n-\n-    return target_end;\n-  }\n+  template<typename RandomAccessIterator1, typename RandomAccessIterator3,\n+\t   typename Comparator>\n+    inline RandomAccessIterator3\n+    parallel_merge_advance(RandomAccessIterator1& begin1,\n+\t\t\t   RandomAccessIterator1 end1,\n+\t\t\t   RandomAccessIterator1& begin2,\n+\t\t\t   RandomAccessIterator1 end2,\n+\t\t\t   RandomAccessIterator3 target, typename\n+\t\t\t   std::iterator_traits<RandomAccessIterator1>::\n+\t\t\t   difference_type max_length, Comparator comp)\n+    {\n+      typedef typename std::iterator_traits<RandomAccessIterator1>::value_type\n+\tvalue_type;\n+      typedef typename std::iterator_traits<RandomAccessIterator1>::\n+\tdifference_type difference_type1 /* == difference_type2 */;\n+      typedef typename std::iterator_traits<RandomAccessIterator3>::\n+\tdifference_type difference_type3;\n+\n+      std::pair<RandomAccessIterator1, RandomAccessIterator1>\n+\tseqs[2] = { std::make_pair(begin1, end1),\n+\t\t    std::make_pair(begin2, end2) };\n+      RandomAccessIterator3 \n+\ttarget_end = parallel_multiway_merge(seqs, seqs + 2, target,\n+\t\t\t\t\t     comp, max_length, true, false);\n+\n+      return target_end;\n+    }\n }\t//namespace __gnu_parallel\n \n #endif"}, {"sha": "df5bb870a5c601bc249ab33007e4bd261ed99300", "filename": "libstdc++-v3/include/parallel/multiseq_selection.h", "status": "modified", "additions": 494, "deletions": 469, "changes": 963, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/531898c3c23ba05afe22253f9cdee6491882c92c/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiseq_selection.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/531898c3c23ba05afe22253f9cdee6491882c92c/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiseq_selection.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiseq_selection.h?ref=531898c3c23ba05afe22253f9cdee6491882c92c", "patch": "@@ -1,6 +1,6 @@\n // -*- C++ -*-\n \n-// Copyright (C) 2007 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the terms\n@@ -58,52 +58,55 @@ namespace __gnu_parallel\n {\n   /** @brief Compare a pair of types lexicographically, ascending. */\n   template<typename T1, typename T2, typename Comparator>\n-  class lexicographic : public std::binary_function<std::pair<T1, T2>, std::pair<T1, T2>, bool>\n-  {\n-  private:\n-    Comparator& comp;\n+    class lexicographic\n+    : public std::binary_function<std::pair<T1, T2>, std::pair<T1, T2>, bool>\n+    {\n+    private:\n+      Comparator& comp;\n \n-  public:\n-    lexicographic(Comparator& _comp) : comp(_comp) { }\n+    public:\n+      lexicographic(Comparator& _comp) : comp(_comp) { }\n \n-    // XXX const\n-    inline bool\n-    operator()(const std::pair<T1, T2>& p1, const std::pair<T1, T2>& p2) const\n-    {\n-      if (comp(p1.first, p2.first))\n-\treturn true;\n+      // XXX const\n+      bool\n+      operator()(const std::pair<T1, T2>& p1,\n+\t\t const std::pair<T1, T2>& p2) const\n+      {\n+\tif (comp(p1.first, p2.first))\n+\t  return true;\n \n-      if (comp(p2.first, p1.first))\n-\treturn false;\n+\tif (comp(p2.first, p1.first))\n+\t  return false;\n \n-      // Firsts are equal.\n-      return p1.second < p2.second;\n-    }\n-  };\n+\t// Firsts are equal.\n+\treturn p1.second < p2.second;\n+      }\n+    };\n \n   /** @brief Compare a pair of types lexicographically, descending. */\n   template<typename T1, typename T2, typename Comparator>\n-  class lexicographic_reverse : public std::binary_function<T1, T2, bool>\n-  {\n-  private:\n-    Comparator& comp;\n+    class lexicographic_reverse : public std::binary_function<T1, T2, bool>\n+    {\n+    private:\n+      Comparator& comp;\n \n-  public:\n-    lexicographic_reverse(Comparator& _comp) : comp(_comp) { }\n+    public:\n+      lexicographic_reverse(Comparator& _comp) : comp(_comp) { }\n \n-    inline bool\n-    operator()(const std::pair<T1, T2>& p1, const std::pair<T1, T2>& p2) const\n-    {\n-      if (comp(p2.first, p1.first))\n-\treturn true;\n+      bool\n+      operator()(const std::pair<T1, T2>& p1,\n+\t\t const std::pair<T1, T2>& p2) const\n+      {\n+\tif (comp(p2.first, p1.first))\n+\t  return true;\n \n-      if (comp(p1.first, p2.first))\n-\treturn false;\n+\tif (comp(p1.first, p2.first))\n+\t  return false;\n \n-      // Firsts are equal.\n-      return p2.second < p1.second;\n-    }\n-  };\n+\t// Firsts are equal.\n+\treturn p2.second < p1.second;\n+      }\n+    };\n \n   /** \n    *  @brief Splits several sorted sequences at a certain global rank,\n@@ -121,229 +124,243 @@ namespace __gnu_parallel\n    *  the respective sequence.\n    *  @param comp The ordering functor, defaults to std::less<T>. \n    */\n-  template<typename RanSeqs, typename RankType, typename RankIterator, typename Comparator>\n-  void \n-  multiseq_partition(RanSeqs begin_seqs, RanSeqs end_seqs, RankType rank,\n-\t\t     RankIterator begin_offsets,\n-\t\t     Comparator comp = std::less<\n-\t\t     typename std::iterator_traits<typename std::iterator_traits<RanSeqs>::value_type::first_type>::value_type>()) // std::less<T>\n-  {\n-    _GLIBCXX_CALL(end_seqs - begin_seqs)\n-\n-    typedef typename std::iterator_traits<RanSeqs>::value_type::first_type It;\n-    typedef typename std::iterator_traits<It>::difference_type difference_type;\n-    typedef typename std::iterator_traits<It>::value_type value_type;\n-\n-    lexicographic<value_type, int, Comparator> lcomp(comp);\n-    lexicographic_reverse<value_type, int, Comparator> lrcomp(comp);\n-\n-    // Number of sequences, number of elements in total (possibly\n-    // including padding).\n-    difference_type m = std::distance(begin_seqs, end_seqs), N = 0, nmax, n, r;\n-\n-    for (int i = 0; i < m; i++)\n-      N += std::distance(begin_seqs[i].first, begin_seqs[i].second);\n-\n-    if (rank == N)\n-      {\n-\tfor (int i = 0; i < m; i++)\n-\t  begin_offsets[i] = begin_seqs[i].second; // Very end.\n-\t// Return m - 1;\n-      }\n-\n-    _GLIBCXX_PARALLEL_ASSERT(m != 0 && N != 0 && rank >= 0 && rank < N);\n-\n-    difference_type* ns = new difference_type[m];\n-    difference_type* a = new difference_type[m];\n-    difference_type* b = new difference_type[m];\n-    difference_type l;\n-\n-    ns[0] = std::distance(begin_seqs[0].first, begin_seqs[0].second);\n-    nmax = ns[0];\n-    for (int i = 0; i < m; i++)\n-      {\n-\tns[i] = std::distance(begin_seqs[i].first, begin_seqs[i].second);\n-\tnmax = std::max(nmax, ns[i]);\n-      }\n-\n-    r = log2(nmax) + 1;\n-\n-    // Pad all lists to this length, at least as long as any ns[i],\n-    // equality iff nmax = 2^k - 1.\n-    l = (1ULL << r) - 1;\n-\n-    // From now on, including padding.\n-    N = l * m;\n-\n-    for (int i = 0; i < m; i++)\n-      {\n-\ta[i] = 0;\n-\tb[i] = l;\n-      }\n-    n = l / 2;\n-\n-    // Invariants:\n-    // 0 <= a[i] <= ns[i], 0 <= b[i] <= l\n+  template<typename RanSeqs, typename RankType, typename RankIterator,\n+\t   typename Comparator>\n+    void\n+    multiseq_partition(RanSeqs begin_seqs, RanSeqs end_seqs,\n+\t\t       RankType rank,\n+\t\t       RankIterator begin_offsets,\n+\t\t       Comparator comp = std::less<\n+\t\t       typename std::iterator_traits<typename\n+\t\t       std::iterator_traits<RanSeqs>::value_type::\n+\t\t       first_type>::value_type>()) // std::less<T>\n+    {\n+      _GLIBCXX_CALL(end_seqs - begin_seqs)\n+\n+      typedef typename std::iterator_traits<RanSeqs>::value_type::first_type\n+\tIt;\n+      typedef typename std::iterator_traits<It>::difference_type\n+\tdifference_type;\n+      typedef typename std::iterator_traits<It>::value_type value_type;\n+\n+      lexicographic<value_type, int, Comparator> lcomp(comp);\n+      lexicographic_reverse<value_type, int, Comparator> lrcomp(comp);\n+\n+      // Number of sequences, number of elements in total (possibly\n+      // including padding).\n+      difference_type m = std::distance(begin_seqs, end_seqs), N = 0,\n+\tnmax, n, r;\n+\n+      for (int i = 0; i < m; i++)\n+\tN += std::distance(begin_seqs[i].first, begin_seqs[i].second);\n+\n+      if (rank == N)\n+\t{\n+\t  for (int i = 0; i < m; i++)\n+\t    begin_offsets[i] = begin_seqs[i].second; // Very end.\n+\t  // Return m - 1;\n+\t}\n+\n+      _GLIBCXX_PARALLEL_ASSERT(m != 0 && N != 0 && rank >= 0 && rank < N);\n+\n+      difference_type* ns = new difference_type[m];\n+      difference_type* a = new difference_type[m];\n+      difference_type* b = new difference_type[m];\n+      difference_type l;\n+\n+      ns[0] = std::distance(begin_seqs[0].first, begin_seqs[0].second);\n+      nmax = ns[0];\n+      for (int i = 0; i < m; i++)\n+\t{\n+\t  ns[i] = std::distance(begin_seqs[i].first, begin_seqs[i].second);\n+\t  nmax = std::max(nmax, ns[i]);\n+\t}\n+\n+      r = log2(nmax) + 1;\n+\n+      // Pad all lists to this length, at least as long as any ns[i],\n+      // equality iff nmax = 2^k - 1.\n+      l = (1ULL << r) - 1;\n+\n+      // From now on, including padding.\n+      N = l * m;\n+\n+      for (int i = 0; i < m; i++)\n+\t{\n+\t  a[i] = 0;\n+\t  b[i] = l;\n+\t}\n+      n = l / 2;\n+\n+      // Invariants:\n+      // 0 <= a[i] <= ns[i], 0 <= b[i] <= l\n \n #define S(i) (begin_seqs[i].first)\n \n-    // Initial partition.\n-    std::vector<std::pair<value_type, int> > sample;\n-\n-    for (int i = 0; i < m; i++)\n-      if (n < ns[i])\t//sequence long enough\n-\tsample.push_back(std::make_pair(S(i)[n], i));\n-    __gnu_sequential::sort(sample.begin(), sample.end(), lcomp);\n-\n-    for (int i = 0; i < m; i++)\t//conceptual infinity\n-      if (n >= ns[i])\t//sequence too short, conceptual infinity\n-\tsample.push_back(std::make_pair(S(i)[0] /*dummy element*/, i));\n-\n-    difference_type localrank = rank * m / N ;\n-\n-    int j;\n-    for (j = 0; j < localrank && ((n + 1) <= ns[sample[j].second]); j++)\n-      a[sample[j].second] += n + 1;\n-    for (; j < m; j++)\n-      b[sample[j].second] -= n + 1;\n-\n-    // Further refinement.\n-    while (n > 0)\n-      {\n-\tn /= 2;\n-\n-\tint lmax_seq = -1;\t// to avoid warning\n-\tconst value_type* lmax = NULL;\t// impossible to avoid the warning?\n-\tfor (int i = 0; i < m; i++)\n-\t  {\n-\t    if (a[i] > 0)\n-\t      {\n-\t\tif (!lmax)\n-\t\t  {\n-\t\t    lmax = &(S(i)[a[i] - 1]);\n-\t\t    lmax_seq = i;\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    // Max, favor rear sequences.\n-\t\t    if (!comp(S(i)[a[i] - 1], *lmax))\n-\t\t      {\n-\t\t\tlmax = &(S(i)[a[i] - 1]);\n-\t\t\tlmax_seq = i;\n-\t\t      }\n-\t\t  }\n-\t      }\n-\t  }\n-\n-\tint i;\n-\tfor (i = 0; i < m; i++)\n-\t  {\n-\t    difference_type middle = (b[i] + a[i]) / 2;\n-\t    if (lmax && middle < ns[i] &&\n-\t\tlcomp(std::make_pair(S(i)[middle], i), std::make_pair(*lmax, lmax_seq)))\n-\t      a[i] = std::min(a[i] + n + 1, ns[i]);\n-\t    else\n-\t      b[i] -= n + 1;\n-\t  }\n-\n-\tdifference_type leftsize = 0, total = 0;\n-\tfor (int i = 0; i < m; i++)\n-\t  {\n-\t    leftsize += a[i] / (n + 1);\n-\t    total += l / (n + 1);\n-\t  }\n-\n-\tdifference_type skew = static_cast<difference_type>(static_cast<uint64>(total) * rank / N - leftsize);\n-\n-\tif (skew > 0)\n-\t  {\n-\t    // Move to the left, find smallest.\n-\t    std::priority_queue<std::pair<value_type, int>, std::vector<std::pair<value_type, int> >, lexicographic_reverse<value_type, int, Comparator> > pq(lrcomp);\n-\n-\t    for (int i = 0; i < m; i++)\n-\t      if (b[i] < ns[i])\n-\t\tpq.push(std::make_pair(S(i)[b[i]], i));\n-\n-\t    for (; skew != 0 && !pq.empty(); skew--)\n-\t      {\n-\t\tint source = pq.top().second;\n-\t\tpq.pop();\n-\n-\t\ta[source] = std::min(a[source] + n + 1, ns[source]);\n-\t\tb[source] += n + 1;\n-\n-\t\tif (b[source] < ns[source])\n-\t\t  pq.push(std::make_pair(S(source)[b[source]], source));\n-\t      }\n-\t  }\n-\telse if (skew < 0)\n-\t  {\n-\t    // Move to the right, find greatest.\n-\t    std::priority_queue<std::pair<value_type, int>, std::vector<std::pair<value_type, int> >, lexicographic<value_type, int, Comparator> > pq(lcomp);\n-\n-\t    for (int i = 0; i < m; i++)\n+      // Initial partition.\n+      std::vector<std::pair<value_type, int> > sample;\n+\n+      for (int i = 0; i < m; i++)\n+\tif (n < ns[i])\t//sequence long enough\n+\t  sample.push_back(std::make_pair(S(i)[n], i));\n+      __gnu_sequential::sort(sample.begin(), sample.end(), lcomp);\n+\n+      for (int i = 0; i < m; i++)\t//conceptual infinity\n+\tif (n >= ns[i])\t//sequence too short, conceptual infinity\n+\t  sample.push_back(std::make_pair(S(i)[0] /*dummy element*/, i));\n+\n+      difference_type localrank = rank * m / N ;\n+\n+      int j;\n+      for (j = 0; j < localrank && ((n + 1) <= ns[sample[j].second]); j++)\n+\ta[sample[j].second] += n + 1;\n+      for (; j < m; j++)\n+\tb[sample[j].second] -= n + 1;\n+      \n+      // Further refinement.\n+      while (n > 0)\n+\t{\n+\t  n /= 2;\n+\n+\t  int lmax_seq = -1;\t// to avoid warning\n+\t  const value_type* lmax = NULL; // impossible to avoid the warning?\n+\t  for (int i = 0; i < m; i++)\n+\t    {\n \t      if (a[i] > 0)\n-\t\tpq.push(std::make_pair(S(i)[a[i] - 1], i));\n-\n-\t    for (; skew != 0; skew++)\n-\t      {\n-\t\tint source = pq.top().second;\n-\t\tpq.pop();\n-\n-\t\ta[source] -= n + 1;\n-\t\tb[source] -= n + 1;\n-\n-\t\tif (a[source] > 0)\n-\t\t  pq.push(std::make_pair(S(source)[a[source] - 1], source));\n-\t      }\n-\t  }\n-      }\n-\n-    // Postconditions:\n-    // a[i] == b[i] in most cases, except when a[i] has been clamped\n-    // because of having reached the boundary\n-\n-    // Now return the result, calculate the offset.\n-\n-    // Compare the keys on both edges of the border.\n-\n-    // Maximum of left edge, minimum of right edge.\n-    value_type* maxleft = NULL;\n-    value_type* minright = NULL;\n-    for (int i = 0; i < m; i++)\n-      {\n-\tif (a[i] > 0)\n-\t  {\n-\t    if (!maxleft)\n-\t      maxleft = &(S(i)[a[i] - 1]);\n-\t    else\n-\t      {\n-\t\t// Max, favor rear sequences.\n-\t\tif (!comp(S(i)[a[i] - 1], *maxleft))\n-\t\t  maxleft = &(S(i)[a[i] - 1]);\n-\t      }\n-\t  }\n-\tif (b[i] < ns[i])\n-\t  {\n-\t    if (!minright)\n-\t      minright = &(S(i)[b[i]]);\n-\t    else\n-\t      {\n-\t\t// Min, favor fore sequences.\n-\t\tif (comp(S(i)[b[i]], *minright))\n-\t\t  minright = &(S(i)[b[i]]);\n-\t      }\n-\t  }\n-      }\n-\n-    int seq = 0;\n-    for (int i = 0; i < m; i++)\n-      begin_offsets[i] = S(i) + a[i];\n-\n-    delete[] ns;\n-    delete[] a;\n-    delete[] b;\n-  }\n+\t\t{\n+\t\t  if (!lmax)\n+\t\t    {\n+\t\t      lmax = &(S(i)[a[i] - 1]);\n+\t\t      lmax_seq = i;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      // Max, favor rear sequences.\n+\t\t      if (!comp(S(i)[a[i] - 1], *lmax))\n+\t\t\t{\n+\t\t\t  lmax = &(S(i)[a[i] - 1]);\n+\t\t\t  lmax_seq = i;\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\n+\t  int i;\n+\t  for (i = 0; i < m; i++)\n+\t    {\n+\t      difference_type middle = (b[i] + a[i]) / 2;\n+\t      if (lmax && middle < ns[i] &&\n+\t\t  lcomp(std::make_pair(S(i)[middle], i),\n+\t\t\tstd::make_pair(*lmax, lmax_seq)))\n+\t\ta[i] = std::min(a[i] + n + 1, ns[i]);\n+\t      else\n+\t\tb[i] -= n + 1;\n+\t    }\n+\n+\t  difference_type leftsize = 0, total = 0;\n+\t  for (int i = 0; i < m; i++)\n+\t    {\n+\t      leftsize += a[i] / (n + 1);\n+\t      total += l / (n + 1);\n+\t    }\n+\t  \n+\t  difference_type skew = static_cast<difference_type>\n+\t    (static_cast<uint64>(total) * rank / N - leftsize);\n+\n+\t  if (skew > 0)\n+\t    {\n+\t      // Move to the left, find smallest.\n+\t      std::priority_queue<std::pair<value_type, int>,\n+\t\tstd::vector<std::pair<value_type, int> >,\n+\t\tlexicographic_reverse<value_type, int, Comparator> >\n+\t\tpq(lrcomp);\n+\t      \n+\t      for (int i = 0; i < m; i++)\n+\t\tif (b[i] < ns[i])\n+\t\t  pq.push(std::make_pair(S(i)[b[i]], i));\n+\n+\t      for (; skew != 0 && !pq.empty(); skew--)\n+\t\t{\n+\t\t  int source = pq.top().second;\n+\t\t  pq.pop();\n+\n+\t\t  a[source] = std::min(a[source] + n + 1, ns[source]);\n+\t\t  b[source] += n + 1;\n+\n+\t\t  if (b[source] < ns[source])\n+\t\t    pq.push(std::make_pair(S(source)[b[source]], source));\n+\t\t}\n+\t    }\n+\t  else if (skew < 0)\n+\t    {\n+\t      // Move to the right, find greatest.\n+\t      std::priority_queue<std::pair<value_type, int>,\n+\t\tstd::vector<std::pair<value_type, int> >,\n+\t\tlexicographic<value_type, int, Comparator> > pq(lcomp);\n+\n+\t      for (int i = 0; i < m; i++)\n+\t\tif (a[i] > 0)\n+\t\t  pq.push(std::make_pair(S(i)[a[i] - 1], i));\n+\n+\t      for (; skew != 0; skew++)\n+\t\t{\n+\t\t  int source = pq.top().second;\n+\t\t  pq.pop();\n+\n+\t\t  a[source] -= n + 1;\n+\t\t  b[source] -= n + 1;\n+\n+\t\t  if (a[source] > 0)\n+\t\t    pq.push(std::make_pair(S(source)[a[source] - 1], source));\n+\t\t}\n+\t    }\n+\t}\n+\n+      // Postconditions:\n+      // a[i] == b[i] in most cases, except when a[i] has been clamped\n+      // because of having reached the boundary\n+\n+      // Now return the result, calculate the offset.\n+\n+      // Compare the keys on both edges of the border.\n+\n+      // Maximum of left edge, minimum of right edge.\n+      value_type* maxleft = NULL;\n+      value_type* minright = NULL;\n+      for (int i = 0; i < m; i++)\n+\t{\n+\t  if (a[i] > 0)\n+\t    {\n+\t      if (!maxleft)\n+\t\tmaxleft = &(S(i)[a[i] - 1]);\n+\t      else\n+\t\t{\n+\t\t  // Max, favor rear sequences.\n+\t\t  if (!comp(S(i)[a[i] - 1], *maxleft))\n+\t\t    maxleft = &(S(i)[a[i] - 1]);\n+\t\t}\n+\t    }\n+\t  if (b[i] < ns[i])\n+\t    {\n+\t      if (!minright)\n+\t\tminright = &(S(i)[b[i]]);\n+\t      else\n+\t\t{\n+\t\t  // Min, favor fore sequences.\n+\t\t  if (comp(S(i)[b[i]], *minright))\n+\t\t    minright = &(S(i)[b[i]]);\n+\t\t}\n+\t    }\n+\t}\n+\n+      int seq = 0;\n+      for (int i = 0; i < m; i++)\n+\tbegin_offsets[i] = S(i) + a[i];\n+\n+      delete[] ns;\n+      delete[] a;\n+      delete[] b;\n+    }\n \n \n   /** \n@@ -360,246 +377,254 @@ namespace __gnu_parallel\n    *  selected element is unique, this number is 0.\n    *  @param comp The ordering functor, defaults to std::less. \n    */\n-  template<typename T, typename RanSeqs, typename RankType, typename Comparator>\n-  T \n-  multiseq_selection(RanSeqs begin_seqs, RanSeqs end_seqs, RankType rank,\n-\t\t     RankType& offset, Comparator comp = std::less<T>())\n-  {\n-    _GLIBCXX_CALL(end_seqs - begin_seqs)\n+  template<typename T, typename RanSeqs, typename RankType,\n+\t   typename Comparator>\n+    T\n+    multiseq_selection(RanSeqs begin_seqs, RanSeqs end_seqs, RankType rank,\n+\t\t       RankType& offset, Comparator comp = std::less<T>())\n+    {\n+      _GLIBCXX_CALL(end_seqs - begin_seqs)\n \n-    typedef typename std::iterator_traits<RanSeqs>::value_type::first_type It;\n-    typedef typename std::iterator_traits<It>::difference_type difference_type;\n+      typedef typename std::iterator_traits<RanSeqs>::value_type::first_type\n+\tIt;\n+      typedef typename std::iterator_traits<It>::difference_type\n+\tdifference_type;\n \n-    lexicographic<T, int, Comparator> lcomp(comp);\n-    lexicographic_reverse<T, int, Comparator> lrcomp(comp);\n+      lexicographic<T, int, Comparator> lcomp(comp);\n+      lexicographic_reverse<T, int, Comparator> lrcomp(comp);\n \n-    // Number of sequences, number of elements in total (possibly\n-    // including padding).\n-    difference_type m = std::distance(begin_seqs, end_seqs);\n-    difference_type N = 0;\n-    difference_type nmax, n, r;\n+      // Number of sequences, number of elements in total (possibly\n+      // including padding).\n+      difference_type m = std::distance(begin_seqs, end_seqs);\n+      difference_type N = 0;\n+      difference_type nmax, n, r;\n \n-    for (int i = 0; i < m; i++)\n-      N += std::distance(begin_seqs[i].first, begin_seqs[i].second);\n+      for (int i = 0; i < m; i++)\n+\tN += std::distance(begin_seqs[i].first, begin_seqs[i].second);\n \n-    if (m == 0 || N == 0 || rank < 0 || rank >= N)\n-      {\n-\t// Result undefined when there is no data or rank is outside bounds.\n-\tthrow std::exception();\n-      }\n+      if (m == 0 || N == 0 || rank < 0 || rank >= N)\n+\t{\n+\t  // Result undefined when there is no data or rank is outside bounds.\n+\t  throw std::exception();\n+\t}\n \n \n-    difference_type* ns = new difference_type[m];\n-    difference_type* a = new difference_type[m];\n-    difference_type* b = new difference_type[m];\n-    difference_type l;\n+      difference_type* ns = new difference_type[m];\n+      difference_type* a = new difference_type[m];\n+      difference_type* b = new difference_type[m];\n+      difference_type l;\n \n-    ns[0] = std::distance(begin_seqs[0].first, begin_seqs[0].second);\n-    nmax = ns[0];\n-    for (int i = 0; i < m; i++)\n-      {\n-\tns[i] = std::distance(begin_seqs[i].first, begin_seqs[i].second);\n-\tnmax = std::max(nmax, ns[i]);\n-      }\n+      ns[0] = std::distance(begin_seqs[0].first, begin_seqs[0].second);\n+      nmax = ns[0];\n+      for (int i = 0; i < m; i++)\n+\t{\n+\t  ns[i] = std::distance(begin_seqs[i].first, begin_seqs[i].second);\n+\t  nmax = std::max(nmax, ns[i]);\n+\t}\n \n-    r = log2(nmax) + 1;\n+      r = log2(nmax) + 1;\n \n-    // Pad all lists to this length, at least as long as any ns[i],\n-    // equality iff nmax = 2^k - 1\n-    l = pow2(r) - 1;\n+      // Pad all lists to this length, at least as long as any ns[i],\n+      // equality iff nmax = 2^k - 1\n+      l = pow2(r) - 1;\n \n-    // From now on, including padding.\n-    N = l * m;\n+      // From now on, including padding.\n+      N = l * m;\n \n-    for (int i = 0; i < m; i++)\n-      {\n-\ta[i] = 0;\n-\tb[i] = l;\n-      }\n-    n = l / 2;\n+      for (int i = 0; i < m; i++)\n+\t{\n+\t  a[i] = 0;\n+\t  b[i] = l;\n+\t}\n+      n = l / 2;\n \n-    // Invariants:\n-    // 0 <= a[i] <= ns[i], 0 <= b[i] <= l\n+      // Invariants:\n+      // 0 <= a[i] <= ns[i], 0 <= b[i] <= l\n \n #define S(i) (begin_seqs[i].first)\n \n-    // Initial partition.\n-    std::vector<std::pair<T, int> > sample;\n+      // Initial partition.\n+      std::vector<std::pair<T, int> > sample;\n \n-    for (int i = 0; i < m; i++)\n-      if (n < ns[i])\n-\tsample.push_back(std::make_pair(S(i)[n], i));\n-    __gnu_sequential::sort(sample.begin(), sample.end(), lcomp, sequential_tag());\n+      for (int i = 0; i < m; i++)\n+\tif (n < ns[i])\n+\t  sample.push_back(std::make_pair(S(i)[n], i));\n+      __gnu_sequential::sort(sample.begin(), sample.end(),\n+\t\t\t     lcomp, sequential_tag());\n \n-    // Conceptual infinity.\n-    for (int i = 0; i < m; i++)\n-      if (n >= ns[i])\n-\tsample.push_back(std::make_pair(S(i)[0] /*dummy element*/, i));\n+      // Conceptual infinity.\n+      for (int i = 0; i < m; i++)\n+\tif (n >= ns[i])\n+\t  sample.push_back(std::make_pair(S(i)[0] /*dummy element*/, i));\n \n-    difference_type localrank = rank * m / N ;\n+      difference_type localrank = rank * m / N ;\n \n-    int j;\n-    for (j = 0; j < localrank && ((n + 1) <= ns[sample[j].second]); j++)\n-      a[sample[j].second] += n + 1;\n-    for (; j < m; j++)\n-      b[sample[j].second] -= n + 1;\n-\n-    // Further refinement.\n-    while (n > 0)\n-      {\n-\tn /= 2;\n-\n-\tconst T* lmax = NULL;\n-\tfor (int i = 0; i < m; i++)\n-\t  {\n-\t    if (a[i] > 0)\n-\t      {\n-\t\tif (!lmax)\n-\t\t  {\n-\t\t    lmax = &(S(i)[a[i] - 1]);\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    if (comp(*lmax, S(i)[a[i] - 1]))\t//max\n-\t\t      lmax = &(S(i)[a[i] - 1]);\n-\t\t  }\n-\t      }\n-\t  }\n-\n-\tint i;\n-\tfor (i = 0; i < m; i++)\n-\t  {\n-\t    difference_type middle = (b[i] + a[i]) / 2;\n-\t    if (lmax && middle < ns[i] && comp(S(i)[middle], *lmax))\n-\t      a[i] = std::min(a[i] + n + 1, ns[i]);\n-\t    else\n-\t      b[i] -= n + 1;\n-\t  }\n-\n-\tdifference_type leftsize = 0, total = 0;\n-\tfor (int i = 0; i < m; i++)\n-\t  {\n-\t    leftsize += a[i] / (n + 1);\n-\t    total += l / (n + 1);\n-\t  }\n-\n-\tdifference_type skew = (unsigned long long)total * rank / N - leftsize;\n-\n-\tif (skew > 0)\n-\t  {\n-\t    // Move to the left, find smallest.\n-\t    std::priority_queue<std::pair<T, int>, std::vector<std::pair<T, int> >, lexicographic_reverse<T, int, Comparator> > pq(lrcomp);\n-\n-\t    for (int i = 0; i < m; i++)\n-\t      if (b[i] < ns[i])\n-\t\tpq.push(std::make_pair(S(i)[b[i]], i));\n-\n-\t    for (; skew != 0 && !pq.empty(); skew--)\n-\t      {\n-\t\tint source = pq.top().second;\n-\t\tpq.pop();\n-\n-\t\ta[source] = std::min(a[source] + n + 1, ns[source]);\n-\t\tb[source] += n + 1;\n-\n-\t\tif (b[source] < ns[source])\n-\t\t  pq.push(std::make_pair(S(source)[b[source]], source));\n-\t      }\n-\t  }\n-\telse if (skew < 0)\n-\t  {\n-\t    // Move to the right, find greatest.\n-\t    std::priority_queue<std::pair<T, int>, std::vector<std::pair<T, int> >, lexicographic<T, int, Comparator> > pq(lcomp);\n-\n-\t    for (int i = 0; i < m; i++)\n-\t      if (a[i] > 0)\n-\t\tpq.push(std::make_pair(S(i)[a[i] - 1], i));\n+      int j;\n+      for (j = 0; j < localrank && ((n + 1) <= ns[sample[j].second]); j++)\n+\ta[sample[j].second] += n + 1;\n+      for (; j < m; j++)\n+\tb[sample[j].second] -= n + 1;\n \n-\t    for (; skew != 0; skew++)\n-\t      {\n-\t\tint source = pq.top().second;\n-\t\tpq.pop();\n+      // Further refinement.\n+      while (n > 0)\n+\t{\n+\t  n /= 2;\n \n-\t\ta[source] -= n + 1;\n-\t\tb[source] -= n + 1;\n-\n-\t\tif (a[source] > 0)\n-\t\t  pq.push(std::make_pair(S(source)[a[source] - 1], source));\n-\t      }\n-\t  }\n-      }\n-\n-    // Postconditions:\n-    // a[i] == b[i] in most cases, except when a[i] has been clamped\n-    // because of having reached the boundary\n-\n-    // Now return the result, calculate the offset.\n-\n-    // Compare the keys on both edges of the border.\n-\n-    // Maximum of left edge, minimum of right edge.\n-    bool maxleftset = false, minrightset = false;\n-\n-    // Impossible to avoid the warning?\n-    T maxleft, minright;\n-    for (int i = 0; i < m; i++)\n-      {\n-\tif (a[i] > 0)\n-\t  {\n-\t    if (!maxleftset)\n-\t      {\n-\t\tmaxleft = S(i)[a[i] - 1];\n-\t\tmaxleftset = true;\n-\t      }\n-\t    else\n-\t      {\n-\t\t// Max.\n-\t\tif (comp(maxleft, S(i)[a[i] - 1]))\n+\t  const T* lmax = NULL;\n+\t  for (int i = 0; i < m; i++)\n+\t    {\n+\t      if (a[i] > 0)\n+\t\t{\n+\t\t  if (!lmax)\n+\t\t    lmax = &(S(i)[a[i] - 1]);\n+\t\t  else\n+\t\t    {\n+\t\t      if (comp(*lmax, S(i)[a[i] - 1]))\t//max\n+\t\t\tlmax = &(S(i)[a[i] - 1]);\n+\t\t    }\n+\t\t}\n+\t    }\n+\n+\t  int i;\n+\t  for (i = 0; i < m; i++)\n+\t    {\n+\t      difference_type middle = (b[i] + a[i]) / 2;\n+\t      if (lmax && middle < ns[i] && comp(S(i)[middle], *lmax))\n+\t\ta[i] = std::min(a[i] + n + 1, ns[i]);\n+\t      else\n+\t\tb[i] -= n + 1;\n+\t    }\n+\n+\t  difference_type leftsize = 0, total = 0;\n+\t  for (int i = 0; i < m; i++)\n+\t    {\n+\t      leftsize += a[i] / (n + 1);\n+\t      total += l / (n + 1);\n+\t    }\n+\n+\t  difference_type skew = ((unsigned long long)total * rank / N\n+\t\t\t\t  - leftsize);\n+\n+\t  if (skew > 0)\n+\t    {\n+\t      // Move to the left, find smallest.\n+\t      std::priority_queue<std::pair<T, int>,\n+\t\tstd::vector<std::pair<T, int> >,\n+\t\tlexicographic_reverse<T, int, Comparator> > pq(lrcomp);\n+\n+\t      for (int i = 0; i < m; i++)\n+\t\tif (b[i] < ns[i])\n+\t\t  pq.push(std::make_pair(S(i)[b[i]], i));\n+\n+\t      for (; skew != 0 && !pq.empty(); --skew)\n+\t\t{\n+\t\t  int source = pq.top().second;\n+\t\t  pq.pop();\n+\t\t  \n+\t\t  a[source] = std::min(a[source] + n + 1, ns[source]);\n+\t\t  b[source] += n + 1;\n+\t\t  \n+\t\t  if (b[source] < ns[source])\n+\t\t    pq.push(std::make_pair(S(source)[b[source]], source));\n+\t\t}\n+\t    }\n+\t  else if (skew < 0)\n+\t    {\n+\t      // Move to the right, find greatest.\n+\t      std::priority_queue<std::pair<T, int>,\n+\t\tstd::vector<std::pair<T, int> >,\n+\t\tlexicographic<T, int, Comparator> > pq(lcomp);\n+\n+\t      for (int i = 0; i < m; i++)\n+\t\tif (a[i] > 0)\n+\t\t  pq.push(std::make_pair(S(i)[a[i] - 1], i));\n+\n+\t      for (; skew != 0; ++skew)\n+\t\t{\n+\t\t  int source = pq.top().second;\n+\t\t  pq.pop();\n+\n+\t\t  a[source] -= n + 1;\n+\t\t  b[source] -= n + 1;\n+\n+\t\t  if (a[source] > 0)\n+\t\t    pq.push(std::make_pair(S(source)[a[source] - 1], source));\n+\t\t}\n+\t    }\n+\t}\n+\n+      // Postconditions:\n+      // a[i] == b[i] in most cases, except when a[i] has been clamped\n+      // because of having reached the boundary\n+\n+      // Now return the result, calculate the offset.\n+\n+      // Compare the keys on both edges of the border.\n+\n+      // Maximum of left edge, minimum of right edge.\n+      bool maxleftset = false, minrightset = false;\n+\n+      // Impossible to avoid the warning?\n+      T maxleft, minright;\n+      for (int i = 0; i < m; i++)\n+\t{\n+\t  if (a[i] > 0)\n+\t    {\n+\t      if (!maxleftset)\n+\t\t{\n \t\t  maxleft = S(i)[a[i] - 1];\n-\t      }\n-\t  }\n-\tif (b[i] < ns[i])\n-\t  {\n-\t    if (!minrightset)\n-\t      {\n-\t\tminright = S(i)[b[i]];\n-\t\tminrightset = true;\n-\t      }\n-\t    else\n-\t      {\n-\t\t// Min.\n-\t\tif (comp(S(i)[b[i]], minright))\n+\t\t  maxleftset = true;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  // Max.\n+\t\t  if (comp(maxleft, S(i)[a[i] - 1]))\n+\t\t    maxleft = S(i)[a[i] - 1];\n+\t\t}\n+\t    }\n+\t  if (b[i] < ns[i])\n+\t    {\n+\t      if (!minrightset)\n+\t\t{\n \t\t  minright = S(i)[b[i]];\n-\t      }\n-\t  }\n+\t\t  minrightset = true;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  // Min.\n+\t\t  if (comp(S(i)[b[i]], minright))\n+\t\t    minright = S(i)[b[i]];\n+\t\t}\n+\t    }\n       }\n \n-    // Minright is the splitter, in any case.\n-\n-    if (!maxleftset || comp(minright, maxleft))\n-      {\n-\t// Good luck, everything is split unambigiously.\n-\toffset = 0;\n-      }\n-    else\n-      {\n-\t// We have to calculate an offset.\n-\toffset = 0;\n-\n-\tfor (int i = 0; i < m; i++)\n-\t  {\n-\t    difference_type lb = std::lower_bound(S(i), S(i) + ns[i], minright,\n-\t\t\t\t\t\t  comp) - S(i);\n-\t    offset += a[i] - lb;\n-\t  }\n-      }\n-\n-    delete[] ns;\n-    delete[] a;\n-    delete[] b;\n-\n-    return minright;\n-  }\n+      // Minright is the splitter, in any case.\n+\n+      if (!maxleftset || comp(minright, maxleft))\n+\t{\n+\t  // Good luck, everything is split unambigiously.\n+\t  offset = 0;\n+\t}\n+      else\n+\t{\n+\t  // We have to calculate an offset.\n+\t  offset = 0;\n+\n+\t  for (int i = 0; i < m; i++)\n+\t    {\n+\t      difference_type lb = std::lower_bound(S(i), S(i) + ns[i],\n+\t\t\t\t\t\t    minright,\n+\t\t\t\t\t\t    comp) - S(i);\n+\t      offset += a[i] - lb;\n+\t    }\n+\t}\n+\n+      delete[] ns;\n+      delete[] a;\n+      delete[] b;\n+\n+      return minright;\n+    }\n }\n \n #undef S"}]}