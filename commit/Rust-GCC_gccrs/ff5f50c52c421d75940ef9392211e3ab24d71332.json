{"sha": "ff5f50c52c421d75940ef9392211e3ab24d71332", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmY1ZjUwYzUyYzQyMWQ3NTk0MGVmOTM5MjIxMWUzYWIyNGQ3MTMzMg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2011-01-21T18:19:03Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-01-21T18:19:03Z"}, "message": "Remove the types float and complex.\n\nUpdate to current version of Go library.\n\nUpdate testsuite for removed types.\n\n\t* go-lang.c (go_langhook_init): Omit float_type_size when calling\n\tgo_create_gogo.\n\t* go-c.h: Update declaration of go_create_gogo.\n\nFrom-SVN: r169098", "tree": {"sha": "27d8768fb1d25696d3c40b42535eb5e073c278da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/27d8768fb1d25696d3c40b42535eb5e073c278da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff5f50c52c421d75940ef9392211e3ab24d71332", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff5f50c52c421d75940ef9392211e3ab24d71332", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff5f50c52c421d75940ef9392211e3ab24d71332", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff5f50c52c421d75940ef9392211e3ab24d71332/comments", "author": null, "committer": null, "parents": [{"sha": "d6ed1c8903e728f4233122554bab5910853338bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6ed1c8903e728f4233122554bab5910853338bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6ed1c8903e728f4233122554bab5910853338bd"}], "stats": {"total": 39980, "additions": 21979, "deletions": 18001}, "files": [{"sha": "7c1f272a07312df9bcf96239e4a056b26acb71e6", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -1,3 +1,9 @@\n+2011-01-21  Ian Lance Taylor  <iant@google.com>\n+\n+\t* go-lang.c (go_langhook_init): Omit float_type_size when calling\n+\tgo_create_gogo.\n+\t* go-c.h: Update declaration of go_create_gogo.\n+\n 2011-01-13  Ian Lance Taylor  <iant@google.com>\n \n \t* go-backend.c: Include \"rtl.h\" and \"target.h\"."}, {"sha": "1c7a3b1f0c6ccb9aaaf80d7641729b6ef3945bf3", "filename": "gcc/go/go-c.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Fgo%2Fgo-c.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Fgo%2Fgo-c.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-c.h?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -41,8 +41,7 @@ extern void go_set_prefix (const char*);\n \n extern void go_add_search_path (const char*);\n \n-extern void go_create_gogo (int int_type_size, int float_type_size,\n-\t\t\t    int pointer_size);\n+extern void go_create_gogo (int int_type_size, int pointer_size);\n \n extern void go_parse_input_files (const char**, unsigned int,\n \t\t\t\t  bool only_check_syntax,"}, {"sha": "ef019d33c3d9ebbc413b1a4db5b356224cf29105", "filename": "gcc/go/go-lang.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Fgo%2Fgo-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Fgo%2Fgo-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-lang.c?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -1,5 +1,5 @@\n /* go-lang.c -- Go frontend gcc interface.\n-   Copyright (C) 2009, 2010 Free Software Foundation, Inc.\n+   Copyright (C) 2009, 2010, 2011 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -103,7 +103,7 @@ go_langhook_init (void)\n      to, e.g., unsigned_char_type_node) but before calling\n      build_common_builtin_nodes (because it calls, indirectly,\n      go_type_for_size).  */\n-  go_create_gogo (INT_TYPE_SIZE, FLOAT_TYPE_SIZE, POINTER_SIZE);\n+  go_create_gogo (INT_TYPE_SIZE, POINTER_SIZE);\n \n   build_common_builtin_nodes ();\n "}, {"sha": "cbf24b84025cb8583322f45523fea10fde3f9a7e", "filename": "gcc/go/gofrontend/export.cc", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Fgo%2Fgofrontend%2Fexport.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Fgo%2Fgofrontend%2Fexport.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexport.cc?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -345,8 +345,6 @@ Export::register_builtin_types(Gogo* gogo)\n   this->register_builtin_type(gogo, \"int\", BUILTIN_INT);\n   this->register_builtin_type(gogo, \"uint\", BUILTIN_UINT);\n   this->register_builtin_type(gogo, \"uintptr\", BUILTIN_UINTPTR);\n-  this->register_builtin_type(gogo, \"float\", BUILTIN_FLOAT);\n-  this->register_builtin_type(gogo, \"complex\", BUILTIN_COMPLEX);\n   this->register_builtin_type(gogo, \"bool\", BUILTIN_BOOL);\n   this->register_builtin_type(gogo, \"string\", BUILTIN_STRING);\n }"}, {"sha": "4a1fd2b64247f70e32d624f51fceaa66045521e9", "filename": "gcc/go/gofrontend/export.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Fgo%2Fgofrontend%2Fexport.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Fgo%2Fgofrontend%2Fexport.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexport.h?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -33,14 +33,12 @@ enum Builtin_code\n   BUILTIN_INT = -11,\n   BUILTIN_UINT = -12,\n   BUILTIN_UINTPTR = -13,\n-  BUILTIN_FLOAT = -14,\n   BUILTIN_BOOL = -15,\n   BUILTIN_STRING = -16,\n   BUILTIN_COMPLEX64 = -17,\n   BUILTIN_COMPLEX128 = -18,\n-  BUILTIN_COMPLEX = -19,\n \n-  SMALLEST_BUILTIN_CODE = -19\n+  SMALLEST_BUILTIN_CODE = -18\n };\n \n // This class manages exporting Go declarations.  It handles the main"}, {"sha": "8eefaee9c10dea1dce129bbc0df6a342528fd20b", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 22, "deletions": 26, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -1932,7 +1932,7 @@ Float_expression::do_determine_type(const Type_context* context)\n \t       || context->type->complex_type() != NULL))\n     this->type_ = context->type;\n   else if (!context->may_be_abstract)\n-    this->type_ = Type::lookup_float_type(\"float\");\n+    this->type_ = Type::lookup_float_type(\"float64\");\n }\n \n // Return true if the floating point value VAL fits in the range of\n@@ -2185,7 +2185,7 @@ Complex_expression::do_determine_type(const Type_context* context)\n \t   && context->type->complex_type() != NULL)\n     this->type_ = context->type;\n   else if (!context->may_be_abstract)\n-    this->type_ = Type::lookup_complex_type(\"complex\");\n+    this->type_ = Type::lookup_complex_type(\"complex128\");\n }\n \n // Return true if the complex value REAL/IMAG fits in the range of the\n@@ -6473,7 +6473,7 @@ class Builtin_call_expression : public Call_expression\n       BUILTIN_CAP,\n       BUILTIN_CLOSE,\n       BUILTIN_CLOSED,\n-      BUILTIN_CMPLX,\n+      BUILTIN_COMPLEX,\n       BUILTIN_COPY,\n       BUILTIN_IMAG,\n       BUILTIN_LEN,\n@@ -6501,7 +6501,7 @@ class Builtin_call_expression : public Call_expression\n   real_imag_type(Type*);\n \n   static Type*\n-  cmplx_type(Type*);\n+  complex_type(Type*);\n \n   // A pointer back to the general IR structure.  This avoids a global\n   // variable, or passing it around everywhere.\n@@ -6532,8 +6532,8 @@ Builtin_call_expression::Builtin_call_expression(Gogo* gogo,\n     this->code_ = BUILTIN_CLOSE;\n   else if (name == \"closed\")\n     this->code_ = BUILTIN_CLOSED;\n-  else if (name == \"cmplx\")\n-    this->code_ = BUILTIN_CMPLX;\n+  else if (name == \"complex\")\n+    this->code_ = BUILTIN_COMPLEX;\n   else if (name == \"copy\")\n     this->code_ = BUILTIN_COPY;\n   else if (name == \"imag\")\n@@ -6774,21 +6774,19 @@ Builtin_call_expression::real_imag_type(Type* arg_type)\n     return NULL;\n   while (nt->real_type()->named_type() != NULL)\n     nt = nt->real_type()->named_type();\n-  if (nt->name() == \"complex\")\n-    return Type::lookup_float_type(\"float\");\n-  else if (nt->name() == \"complex64\")\n+  if (nt->name() == \"complex64\")\n     return Type::lookup_float_type(\"float32\");\n   else if (nt->name() == \"complex128\")\n     return Type::lookup_float_type(\"float64\");\n   else\n     return NULL;\n }\n \n-// Return the type of the cmplx function, given the type of one of the\n+// Return the type of the complex function, given the type of one of the\n // argments.  Like real_imag_type, we have to map by name.\n \n Type*\n-Builtin_call_expression::cmplx_type(Type* arg_type)\n+Builtin_call_expression::complex_type(Type* arg_type)\n {\n   if (arg_type == NULL || arg_type->is_abstract())\n     return NULL;\n@@ -6797,9 +6795,7 @@ Builtin_call_expression::cmplx_type(Type* arg_type)\n     return NULL;\n   while (nt->real_type()->named_type() != NULL)\n     nt = nt->real_type()->named_type();\n-  if (nt->name() == \"float\")\n-    return Type::lookup_complex_type(\"complex\");\n-  else if (nt->name() == \"float32\")\n+  if (nt->name() == \"float32\")\n     return Type::lookup_complex_type(\"complex64\");\n   else if (nt->name() == \"float64\")\n     return Type::lookup_complex_type(\"complex128\");\n@@ -6868,7 +6864,7 @@ Builtin_call_expression::do_is_constant() const\n \treturn arg->field_reference_expression() != NULL;\n       }\n \n-    case BUILTIN_CMPLX:\n+    case BUILTIN_COMPLEX:\n       {\n \tconst Expression_list* args = this->args();\n \tif (args != NULL && args->size() == 2)\n@@ -7053,7 +7049,7 @@ bool\n Builtin_call_expression::do_complex_constant_value(mpfr_t real, mpfr_t imag,\n \t\t\t\t\t\t   Type** ptype) const\n {\n-  if (this->code_ == BUILTIN_CMPLX)\n+  if (this->code_ == BUILTIN_COMPLEX)\n     {\n       const Expression_list* args = this->args();\n       if (args == NULL || args->size() != 2)\n@@ -7078,7 +7074,7 @@ Builtin_call_expression::do_complex_constant_value(mpfr_t real, mpfr_t imag,\n \t{\n \t  mpfr_set(real, r, GMP_RNDN);\n \t  mpfr_set(imag, i, GMP_RNDN);\n-\t  *ptype = Builtin_call_expression::cmplx_type(rtype);\n+\t  *ptype = Builtin_call_expression::complex_type(rtype);\n \t  ret = true;\n \t}\n \n@@ -7154,7 +7150,7 @@ Builtin_call_expression::do_type()\n \treturn t;\n       }\n \n-    case BUILTIN_CMPLX:\n+    case BUILTIN_COMPLEX:\n       {\n \tconst Expression_list* args = this->args();\n \tif (args == NULL || args->size() != 2)\n@@ -7166,7 +7162,7 @@ Builtin_call_expression::do_type()\n \t    if (t->is_abstract())\n \t      t = t->make_non_abstract_type();\n \t  }\n-\tt = Builtin_call_expression::cmplx_type(t);\n+\tt = Builtin_call_expression::complex_type(t);\n \tif (t == NULL)\n \t  t = Type::make_error_type();\n \treturn t;\n@@ -7195,13 +7191,13 @@ Builtin_call_expression::do_determine_type(const Type_context* context)\n \n     case BUILTIN_REAL:\n     case BUILTIN_IMAG:\n-      arg_type = Builtin_call_expression::cmplx_type(context->type);\n+      arg_type = Builtin_call_expression::complex_type(context->type);\n       is_print = false;\n       break;\n \n-    case BUILTIN_CMPLX:\n+    case BUILTIN_COMPLEX:\n       {\n-\t// For the cmplx function the type of one operand can\n+\t// For the complex function the type of one operand can\n \t// determine the type of the other, as in a binary expression.\n \targ_type = Builtin_call_expression::real_imag_type(context->type);\n \tif (args != NULL && args->size() == 2)\n@@ -7498,7 +7494,7 @@ Builtin_call_expression::do_check_types(Gogo*)\n \t}\n       break;\n \n-    case BUILTIN_CMPLX:\n+    case BUILTIN_COMPLEX:\n       {\n \tconst Expression_list* args = this->args();\n \tif (args == NULL || args->size() < 2)\n@@ -7512,9 +7508,9 @@ Builtin_call_expression::do_check_types(Gogo*)\n \t  this->set_is_error();\n \telse if (!Type::are_identical(args->front()->type(),\n \t\t\t\t      args->back()->type(), true, NULL))\n-\t  this->report_error(_(\"cmplx arguments must have identical types\"));\n+\t  this->report_error(_(\"complex arguments must have identical types\"));\n \telse if (args->front()->type()->float_type() == NULL)\n-\t  this->report_error(_(\"cmplx arguments must have \"\n+\t  this->report_error(_(\"complex arguments must have \"\n \t\t\t       \"floating-point type\"));\n       }\n       break;\n@@ -8077,7 +8073,7 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \t\t\t\t arg_tree);\n       }\n \n-    case BUILTIN_CMPLX:\n+    case BUILTIN_COMPLEX:\n       {\n \tconst Expression_list* args = this->args();\n \tgcc_assert(args != NULL && args->size() == 2);"}, {"sha": "2f30fd804b6be97fc05003d33c9c1fcd90062f17", "filename": "gcc/go/gofrontend/go.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Fgo%2Fgofrontend%2Fgo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Fgo%2Fgofrontend%2Fgo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgo.cc?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -24,10 +24,10 @@ static Gogo* gogo;\n \n GO_EXTERN_C\n void\n-go_create_gogo(int int_type_size, int float_type_size, int pointer_size)\n+go_create_gogo(int int_type_size, int pointer_size)\n {\n   gcc_assert(::gogo == NULL);\n-  ::gogo = new Gogo(int_type_size, float_type_size, pointer_size);\n+  ::gogo = new Gogo(int_type_size, pointer_size);\n   if (!unique_prefix.empty())\n     ::gogo->set_unique_prefix(unique_prefix);\n }"}, {"sha": "794dd74e11f08bb861c31e165d6d81bffd824bca", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -19,7 +19,7 @@\n \n // Class Gogo.\n \n-Gogo::Gogo(int int_type_size, int float_type_size, int pointer_size)\n+Gogo::Gogo(int int_type_size, int pointer_size)\n   : package_(NULL),\n     functions_(),\n     globals_(new Bindings(NULL)),\n@@ -86,12 +86,6 @@ Gogo::Gogo(int int_type_size, int float_type_size, int pointer_size)\n \t\t\t\t\t       pointer_size,\n \t\t\t\t\t       RUNTIME_TYPE_KIND_UINTPTR));\n \n-  this->add_named_type(Type::make_float_type(\"float\", float_type_size,\n-\t\t\t\t\t     RUNTIME_TYPE_KIND_FLOAT));\n-\n-  this->add_named_type(Type::make_complex_type(\"complex\", float_type_size * 2,\n-\t\t\t\t\t       RUNTIME_TYPE_KIND_COMPLEX));\n-\n   this->add_named_type(Type::make_named_bool_type());\n \n   this->add_named_type(Type::make_named_string_type());\n@@ -199,10 +193,10 @@ Gogo::Gogo(int int_type_size, int float_type_size, int pointer_size)\n   append_type->set_is_builtin();\n   this->globals_->add_function_declaration(\"append\", NULL, append_type, loc);\n \n-  Function_type* cmplx_type = Type::make_function_type(NULL, NULL, NULL, loc);\n-  cmplx_type->set_is_varargs();\n-  cmplx_type->set_is_builtin();\n-  this->globals_->add_function_declaration(\"cmplx\", NULL, cmplx_type, loc);\n+  Function_type* complex_type = Type::make_function_type(NULL, NULL, NULL, loc);\n+  complex_type->set_is_varargs();\n+  complex_type->set_is_builtin();\n+  this->globals_->add_function_declaration(\"complex\", NULL, complex_type, loc);\n \n   Function_type* real_type = Type::make_function_type(NULL, NULL, NULL, loc);\n   real_type->set_is_varargs();\n@@ -212,7 +206,7 @@ Gogo::Gogo(int int_type_size, int float_type_size, int pointer_size)\n   Function_type* imag_type = Type::make_function_type(NULL, NULL, NULL, loc);\n   imag_type->set_is_varargs();\n   imag_type->set_is_builtin();\n-  this->globals_->add_function_declaration(\"imag\", NULL, cmplx_type, loc);\n+  this->globals_->add_function_declaration(\"imag\", NULL, imag_type, loc);\n \n   this->define_builtin_function_trees();\n "}, {"sha": "cb3fe67f39e1a713015f781340417cfe46a19886", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -100,9 +100,9 @@ operator<(const Import_init& i1, const Import_init& i2)\n class Gogo\n {\n  public:\n-  // Create the IR, passing in the sizes of the types \"int\", \"float\",\n-  // and \"uintptr\" in bits.\n-  Gogo(int int_type_size, int float_type_size, int pointer_size);\n+  // Create the IR, passing in the sizes of the types \"int\" and\n+  // \"uintptr\" in bits.\n+  Gogo(int int_type_size, int pointer_size);\n \n   // Get the package name.\n   const std::string&"}, {"sha": "d926edf44802cd2e8a888a11dd11b3201ae3dc21", "filename": "gcc/go/gofrontend/import.cc", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Fgo%2Fgofrontend%2Fimport.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Fgo%2Fgofrontend%2Fimport.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fimport.cc?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -704,8 +704,6 @@ Import::register_builtin_types(Gogo* gogo)\n   this->register_builtin_type(gogo, \"int\", BUILTIN_INT);\n   this->register_builtin_type(gogo, \"uint\", BUILTIN_UINT);\n   this->register_builtin_type(gogo, \"uintptr\", BUILTIN_UINTPTR);\n-  this->register_builtin_type(gogo, \"float\", BUILTIN_FLOAT);\n-  this->register_builtin_type(gogo, \"complex\", BUILTIN_COMPLEX);\n   this->register_builtin_type(gogo, \"bool\", BUILTIN_BOOL);\n   this->register_builtin_type(gogo, \"string\", BUILTIN_STRING);\n }"}, {"sha": "a70f5e9a3d0c2f434f2814903db32149f368eb33", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -194,9 +194,9 @@ Type::make_non_abstract_type()\n     case TYPE_INTEGER:\n       return Type::lookup_integer_type(\"int\");\n     case TYPE_FLOAT:\n-      return Type::lookup_float_type(\"float\");\n+      return Type::lookup_float_type(\"float64\");\n     case TYPE_COMPLEX:\n-      return Type::lookup_complex_type(\"complex\");\n+      return Type::lookup_complex_type(\"complex128\");\n     case TYPE_STRING:\n       return Type::lookup_string_type();\n     case TYPE_BOOLEAN:\n@@ -1872,8 +1872,7 @@ Float_type::create_abstract_float_type()\n {\n   static Float_type* abstract_type;\n   if (abstract_type == NULL)\n-    abstract_type = new Float_type(true, FLOAT_TYPE_SIZE,\n-\t\t\t\t   RUNTIME_TYPE_KIND_FLOAT);\n+    abstract_type = new Float_type(true, 64, RUNTIME_TYPE_KIND_FLOAT64);\n   return abstract_type;\n }\n \n@@ -2029,8 +2028,7 @@ Complex_type::create_abstract_complex_type()\n {\n   static Complex_type* abstract_type;\n   if (abstract_type == NULL)\n-    abstract_type = new Complex_type(true, FLOAT_TYPE_SIZE * 2,\n-\t\t\t\t     RUNTIME_TYPE_KIND_FLOAT);\n+    abstract_type = new Complex_type(true, 128, RUNTIME_TYPE_KIND_COMPLEX128);\n   return abstract_type;\n }\n "}, {"sha": "b9e8caf6c13fb29a9a30ef287127d119e7647c84", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -60,22 +60,20 @@ static const int RUNTIME_TYPE_KIND_UINT16 = 9;\n static const int RUNTIME_TYPE_KIND_UINT32 = 10;\n static const int RUNTIME_TYPE_KIND_UINT64 = 11;\n static const int RUNTIME_TYPE_KIND_UINTPTR = 12;\n-static const int RUNTIME_TYPE_KIND_FLOAT = 13;\n-static const int RUNTIME_TYPE_KIND_FLOAT32 = 14;\n-static const int RUNTIME_TYPE_KIND_FLOAT64 = 15;\n-static const int RUNTIME_TYPE_KIND_COMPLEX = 16;\n-static const int RUNTIME_TYPE_KIND_COMPLEX64 = 17;\n-static const int RUNTIME_TYPE_KIND_COMPLEX128 = 18;\n-static const int RUNTIME_TYPE_KIND_ARRAY = 19;\n-static const int RUNTIME_TYPE_KIND_CHAN = 20;\n-static const int RUNTIME_TYPE_KIND_FUNC = 21;\n-static const int RUNTIME_TYPE_KIND_INTERFACE = 22;\n-static const int RUNTIME_TYPE_KIND_MAP = 23;\n-static const int RUNTIME_TYPE_KIND_PTR = 24;\n-static const int RUNTIME_TYPE_KIND_SLICE = 25;\n-static const int RUNTIME_TYPE_KIND_STRING = 26;\n-static const int RUNTIME_TYPE_KIND_STRUCT = 27;\n-static const int RUNTIME_TYPE_KIND_UNSAFE_POINTER = 28;\n+static const int RUNTIME_TYPE_KIND_FLOAT32 = 13;\n+static const int RUNTIME_TYPE_KIND_FLOAT64 = 14;\n+static const int RUNTIME_TYPE_KIND_COMPLEX64 = 15;\n+static const int RUNTIME_TYPE_KIND_COMPLEX128 = 16;\n+static const int RUNTIME_TYPE_KIND_ARRAY = 17;\n+static const int RUNTIME_TYPE_KIND_CHAN = 18;\n+static const int RUNTIME_TYPE_KIND_FUNC = 19;\n+static const int RUNTIME_TYPE_KIND_INTERFACE = 20;\n+static const int RUNTIME_TYPE_KIND_MAP = 21;\n+static const int RUNTIME_TYPE_KIND_PTR = 22;\n+static const int RUNTIME_TYPE_KIND_SLICE = 23;\n+static const int RUNTIME_TYPE_KIND_STRING = 24;\n+static const int RUNTIME_TYPE_KIND_STRUCT = 25;\n+static const int RUNTIME_TYPE_KIND_UNSAFE_POINTER = 26;\n \n // To build the complete list of methods for a named type we need to\n // gather all methods from anonymous fields.  Those methods may"}, {"sha": "681a5e77cb47fc74fb6798b040c006e5bf1bcc6a", "filename": "gcc/testsuite/go.test/test/blank.go", "status": "modified", "additions": 37, "deletions": 16, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fblank.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fblank.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fblank.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -28,23 +28,23 @@ const (\n \tc4\n )\n \n-var ints = []string {\n+var ints = []string{\n \t\"1\",\n \t\"2\",\n \t\"3\",\n }\n \n func f() (int, int) {\n \tcall += \"f\"\n-\treturn 1,2\n+\treturn 1, 2\n }\n \n-func g() (float, float) {\n+func g() (float64, float64) {\n \tcall += \"g\"\n-\treturn 3,4\n+\treturn 3, 4\n }\n \n-func h(_ int, _ float) {\n+func h(_ int, _ float64) {\n }\n \n func i() int {\n@@ -55,43 +55,64 @@ func i() int {\n var _ = i()\n \n func main() {\n-\tif call != \"i\" {panic(\"init did not run\")}\n+\tif call != \"i\" {\n+\t\tpanic(\"init did not run\")\n+\t}\n \tcall = \"\"\n \t_, _ = f()\n \ta, _ := f()\n-\tif a != 1 {panic(a)}\n+\tif a != 1 {\n+\t\tpanic(a)\n+\t}\n \tb, _ := g()\n-\tif b != 3 {panic(b)}\n+\tif b != 3 {\n+\t\tpanic(b)\n+\t}\n \t_, a = f()\n-\tif a != 2 {panic(a)}\n+\tif a != 2 {\n+\t\tpanic(a)\n+\t}\n \t_, b = g()\n-\tif b != 4 {panic(b)}\n+\tif b != 4 {\n+\t\tpanic(b)\n+\t}\n \t_ = i()\n-\tif call != \"ffgfgi\" {panic(call)}\n-\tif c4 != 4 {panic(c4)}\n+\tif call != \"ffgfgi\" {\n+\t\tpanic(call)\n+\t}\n+\tif c4 != 4 {\n+\t\tpanic(c4)\n+\t}\n \n \tout := \"\"\n \tfor _, s := range ints {\n \t\tout += s\n \t}\n-\tif out != \"123\" {panic(out)}\n+\tif out != \"123\" {\n+\t\tpanic(out)\n+\t}\n \n \tsum := 0\n-\tfor s, _ := range ints {\n+\tfor s := range ints {\n \t\tsum += s\n \t}\n-\tif sum != 3 {panic(sum)}\n+\tif sum != 3 {\n+\t\tpanic(sum)\n+\t}\n \n-\th(a,b)\n+\th(a, b)\n }\n \n // useless but legal\n var _ int = 1\n var _ = 2\n var _, _ = 3, 4\n+\n const _ = 3\n const _, _ = 4, 5\n+\n type _ int\n+\n func _() {\n \tpanic(\"oops\")\n }"}, {"sha": "d5a77d684a7d08b6d2057e05bb17a1ac7cca3d6f", "filename": "gcc/testsuite/go.test/test/cmplx.go", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcmplx.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcmplx.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcmplx.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -7,25 +7,19 @@\n package main\n \n var (\n-\tf float\n \tf32 float32\n \tf64 float64\n \n-\tc complex\n-\tc64 complex64\n+\tc64  complex64\n \tc128 complex128\n )\n-\t\n+\n func main() {\n \t// ok\n-\tc = cmplx(f, f)\n-\tc64 = cmplx(f32, f32)\n-\tc128 = cmplx(f64, f64)\n+\tc64 = complex(f32, f32)\n+\tc128 = complex(f64, f64)\n \n-\t_ = cmplx(f, f32)\t// ERROR \"cmplx\"\n-\t_ = cmplx(f, f64)\t// ERROR \"cmplx\"\n-\t_ = cmplx(f32, f)\t// ERROR \"cmplx\"\n-\t_ = cmplx(f32, f64)\t// ERROR \"cmplx\"\n-\t_ = cmplx(f64, f)\t// ERROR \"cmplx\"\n-\t_ = cmplx(f64, f32)\t// ERROR \"cmplx\"\n+\t_ = complex128(0)     // ok\n+\t_ = complex(f32, f64) // ERROR \"complex\"\n+\t_ = complex(f64, f32) // ERROR \"complex\"\n }"}, {"sha": "6a1dee9fe784cda31c5417e092932c7f7d60d3de", "filename": "gcc/testsuite/go.test/test/cmplxdivide1.go", "status": "modified", "additions": 2401, "deletions": 2402, "changes": 4803, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcmplxdivide1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcmplxdivide1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcmplxdivide1.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "f5f7aca9d90f912ed42dbb21b1a2477718810a58", "filename": "gcc/testsuite/go.test/test/complit.go", "status": "modified", "additions": 51, "deletions": 19, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcomplit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcomplit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcomplit.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -6,9 +6,16 @@\n \n package main\n \n-type T struct { i int; f float; s string; next *T }\n+type T struct {\n+\ti    int\n+\tf    float64\n+\ts    string\n+\tnext *T\n+}\n \n-type R struct { num int }\n+type R struct {\n+\tnum int\n+}\n \n func itor(a int) *R {\n \tr := new(R)\n@@ -18,11 +25,16 @@ func itor(a int) *R {\n \n func eq(a []*R) {\n \tfor i := 0; i < len(a); i++ {\n-\t\tif a[i].num != i { panic(\"bad\") }\n+\t\tif a[i].num != i {\n+\t\t\tpanic(\"bad\")\n+\t\t}\n \t}\n }\n \n-type P struct { a, b int }\n+type P struct {\n+\ta, b int\n+}\n+\n func NewP(a, b int) *P {\n \treturn &P{a, b}\n }\n@@ -34,37 +46,57 @@ func main() {\n \tvar tp *T\n \ttp = &T{0, 7.2, \"hi\", &t}\n \n-\ta1 := []int{1,2,3}\n-\tif len(a1) != 3 { panic(\"a1\") }\n-\ta2 := [10]int{1,2,3}\n-\tif len(a2) != 10 || cap(a2) != 10 { panic(\"a2\") }\n+\ta1 := []int{1, 2, 3}\n+\tif len(a1) != 3 {\n+\t\tpanic(\"a1\")\n+\t}\n+\ta2 := [10]int{1, 2, 3}\n+\tif len(a2) != 10 || cap(a2) != 10 {\n+\t\tpanic(\"a2\")\n+\t}\n \n-\ta3 := [10]int{1,2,3,}\n-\tif len(a3) != 10 || a2[3] != 0 { panic(\"a3\") }\n+\ta3 := [10]int{1, 2, 3}\n+\tif len(a3) != 10 || a2[3] != 0 {\n+\t\tpanic(\"a3\")\n+\t}\n \n \tvar oai []int\n-\toai = []int{1,2,3}\n-\tif len(oai) != 3 { panic(\"oai\") }\n+\toai = []int{1, 2, 3}\n+\tif len(oai) != 3 {\n+\t\tpanic(\"oai\")\n+\t}\n \n \tat := [...]*T{&t, tp, &t}\n-\tif len(at) != 3 { panic(\"at\") }\n+\tif len(at) != 3 {\n+\t\tpanic(\"at\")\n+\t}\n \n \tc := make(chan int)\n \tac := []chan int{c, c, c}\n-\tif len(ac) != 3 { panic(\"ac\") }\n+\tif len(ac) != 3 {\n+\t\tpanic(\"ac\")\n+\t}\n \n \taat := [][len(at)]*T{at, at}\n-\tif len(aat) != 2 || len(aat[1]) != 3 { panic(\"aat\") }\n+\tif len(aat) != 2 || len(aat[1]) != 3 {\n+\t\tpanic(\"aat\")\n+\t}\n \n \ts := string([]byte{'h', 'e', 'l', 'l', 'o'})\n-\tif s != \"hello\" { panic(\"s\") }\n+\tif s != \"hello\" {\n+\t\tpanic(\"s\")\n+\t}\n \n-\tm := map[string]float{\"one\":1.0, \"two\":2.0, \"pi\":22./7.}\n-\tif len(m) != 3 { panic(\"m\") }\n+\tm := map[string]float64{\"one\": 1.0, \"two\": 2.0, \"pi\": 22. / 7.}\n+\tif len(m) != 3 {\n+\t\tpanic(\"m\")\n+\t}\n \n \teq([]*R{itor(0), itor(1), itor(2), itor(3), itor(4), itor(5)})\n \n \tp1 := NewP(1, 2)\n \tp2 := NewP(1, 2)\n-\tif p1 == p2 { panic(\"NewP\") }\n+\tif p1 == p2 {\n+\t\tpanic(\"NewP\")\n+\t}\n }"}, {"sha": "6cfcb460b5098b8f37871333fe46bb04e599184a", "filename": "gcc/testsuite/go.test/test/const1.go", "status": "modified", "additions": 55, "deletions": 54, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fconst1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fconst1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fconst1.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -6,74 +6,75 @@\n \n package main\n \n-type I interface {}\n+type I interface{}\n+\n const (\n \t// assume all types behave similarly to int8/uint8\n-\tInt8 int8 = 101\n-\tMinus1 int8 = -1\n-\tUint8 uint8 = 102\n-\tConst = 103\n+\tInt8   int8  = 101\n+\tMinus1 int8  = -1\n+\tUint8  uint8 = 102\n+\tConst  = 103\n \n-\tFloat32 float32 = 104.5\n-\tFloat float = 105.5\n+\tFloat32    float32 = 104.5\n+\tFloat64    float64 = 105.5\n \tConstFloat = 106.5\n-\tBig float64 = 1e300\n+\tBig        float64 = 1e300\n \n \tString = \"abc\"\n-\tBool = true\n+\tBool   = true\n )\n \n var (\n-\ta1 = Int8 * 100\t// ERROR \"overflow\"\n-\ta2 = Int8 * -1\t// OK\n-\ta3 = Int8 * 1000\t// ERROR \"overflow\"\n-\ta4 = Int8 * int8(1000)\t// ERROR \"overflow\"\n-\ta5 = int8(Int8 * 1000)\t// ERROR \"overflow\"\n-\ta6 = int8(Int8 * int8(1000))\t// ERROR \"overflow\"\n-\ta7 = Int8 - 2*Int8 - 2*Int8\t// ERROR \"overflow\"\n-\ta8 = Int8 * Const / 100\t// ERROR \"overflow\"\n-\ta9 = Int8 * (Const / 100)\t// OK\n+\ta1 = Int8 * 100              // ERROR \"overflow\"\n+\ta2 = Int8 * -1               // OK\n+\ta3 = Int8 * 1000             // ERROR \"overflow\"\n+\ta4 = Int8 * int8(1000)       // ERROR \"overflow\"\n+\ta5 = int8(Int8 * 1000)       // ERROR \"overflow\"\n+\ta6 = int8(Int8 * int8(1000)) // ERROR \"overflow\"\n+\ta7 = Int8 - 2*Int8 - 2*Int8  // ERROR \"overflow\"\n+\ta8 = Int8 * Const / 100      // ERROR \"overflow\"\n+\ta9 = Int8 * (Const / 100)    // OK\n \n-\tb1 = Uint8 * Uint8\t// ERROR \"overflow\"\n-\tb2 = Uint8 * -1\t// ERROR \"overflow\"\n-\tb3 = Uint8 - Uint8\t// OK\n-\tb4 = Uint8 - Uint8 - Uint8\t// ERROR \"overflow\"\n-\tb5 = uint8(^0)\t// ERROR \"overflow\"\n-\tb6 = ^uint8(0)\t// OK\n-\tb7 = uint8(Minus1)\t// ERROR \"overflow\"\n-\tb8 = uint8(int8(-1))\t// ERROR \"overflow\"\n-\tb8a = uint8(-1)\t// ERROR \"overflow\"\n-\tb9 byte = (1<<10) >> 8\t// OK\n-\tb10 byte = (1<<10)\t// ERROR \"overflow\"\n-\tb11 byte = (byte(1)<<10) >> 8\t// ERROR \"overflow\"\n-\tb12 byte = 1000\t// ERROR \"overflow\"\n-\tb13 byte = byte(1000)\t// ERROR \"overflow\"\n-\tb14 byte = byte(100) * byte(100)\t// ERROR \"overflow\"\n-\tb15 byte = byte(100) * 100\t// ERROR \"overflow\"\n-\tb16 byte = byte(0) * 1000\t// ERROR \"overflow\"\n-\tb16a byte = 0 * 1000\t// OK\n-\tb17 byte = byte(0) * byte(1000)\t// ERROR \"overflow\"\n-\tb18 byte = Uint8/0\t// ERROR \"division by zero\"\n+\tb1   = Uint8 * Uint8                                 // ERROR \"overflow\"\n+\tb2   = Uint8 * -1                                    // ERROR \"overflow\"\n+\tb3   = Uint8 - Uint8                                 // OK\n+\tb4   = Uint8 - Uint8 - Uint8                         // ERROR \"overflow\"\n+\tb5   = uint8(^0)                                     // ERROR \"overflow\"\n+\tb6   = ^uint8(0)                                     // OK\n+\tb7   = uint8(Minus1)                                 // ERROR \"overflow\"\n+\tb8   = uint8(int8(-1))                               // ERROR \"overflow\"\n+\tb8a  = uint8(-1)                                     // ERROR \"overflow\"\n+\tb9   byte                    = (1 << 10) >> 8        // OK\n+\tb10  byte                    = (1 << 10)             // ERROR \"overflow\"\n+\tb11  byte                    = (byte(1) << 10) >> 8  // ERROR \"overflow\"\n+\tb12  byte                    = 1000                  // ERROR \"overflow\"\n+\tb13  byte                    = byte(1000)            // ERROR \"overflow\"\n+\tb14  byte                    = byte(100) * byte(100) // ERROR \"overflow\"\n+\tb15  byte                    = byte(100) * 100       // ERROR \"overflow\"\n+\tb16  byte                    = byte(0) * 1000        // ERROR \"overflow\"\n+\tb16a byte                    = 0 * 1000              // OK\n+\tb17  byte                    = byte(0) * byte(1000)  // ERROR \"overflow\"\n+\tb18  byte                    = Uint8 / 0             // ERROR \"division by zero\"\n \n-\tc1 float64 = Big\n-\tc2 float64 = Big*Big\t// ERROR \"overflow\"\n-\tc3 float64 = float64(Big)*Big\t// ERROR \"overflow\"\n-\tc4 = Big*Big\t// ERROR \"overflow\"\n-\tc5 = Big/0\t// ERROR \"division by zero\"\n+\tc1 float64     = Big\n+\tc2 float64     = Big * Big          // ERROR \"overflow\"\n+\tc3 float64     = float64(Big) * Big // ERROR \"overflow\"\n+\tc4 = Big * Big                      // ERROR \"overflow\"\n+\tc5 = Big / 0                        // ERROR \"division by zero\"\n )\n \n func f(int)\n \n func main() {\n-\tf(Int8)\t// ERROR \"convert|wrong type|cannot\"\n-\tf(Minus1)\t// ERROR \"convert|wrong type|cannot\"\n-\tf(Uint8)\t// ERROR \"convert|wrong type|cannot\"\n-\tf(Const)\t// OK\n-\tf(Float32)\t// ERROR \"convert|wrong type|cannot\"\n-\tf(Float)\t// ERROR \"convert|wrong type|cannot\"\n-\tf(ConstFloat)\t// ERROR \"truncate\"\n-\tf(ConstFloat - 0.5)\t// OK\n-\tf(Big)\t// ERROR \"convert|wrong type|cannot\"\n-\tf(String)\t// ERROR \"convert|wrong type|cannot|incompatible\"\n-\tf(Bool)\t// ERROR \"convert|wrong type|cannot|incompatible\"\n+\tf(Int8)             // ERROR \"convert|wrong type|cannot\"\n+\tf(Minus1)           // ERROR \"convert|wrong type|cannot\"\n+\tf(Uint8)            // ERROR \"convert|wrong type|cannot\"\n+\tf(Const)            // OK\n+\tf(Float32)          // ERROR \"convert|wrong type|cannot\"\n+\tf(Float64)          // ERROR \"convert|wrong type|cannot\"\n+\tf(ConstFloat)       // ERROR \"truncate\"\n+\tf(ConstFloat - 0.5) // OK\n+\tf(Big)              // ERROR \"convert|wrong type|cannot\"\n+\tf(String)           // ERROR \"convert|wrong type|cannot|incompatible\"\n+\tf(Bool)             // ERROR \"convert|wrong type|cannot|incompatible\"\n }"}, {"sha": "90ac5490c84d2531fd8c97b78f2fe59f72f99128", "filename": "gcc/testsuite/go.test/test/convlit.go", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fconvlit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fconvlit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fconvlit.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -11,54 +11,56 @@ package main\n // the language spec says for now.\n var x1 = string(1)\n var x2 string = string(1)\n-var x3 = int(1.5)\t// ERROR \"convert|truncate\"\n-var x4 int = int(1.5)\t// ERROR \"convert|truncate\"\n+var x3 = int(1.5)     // ERROR \"convert|truncate\"\n+var x4 int = int(1.5) // ERROR \"convert|truncate\"\n var x5 = \"a\" + string(1)\n-var x6 = int(1e100)\t// ERROR \"overflow\"\n-var x7 = float(1e1000)\t// ERROR \"overflow\"\n+var x6 = int(1e100)      // ERROR \"overflow\"\n+var x7 = float32(1e1000) // ERROR \"overflow\"\n \n // implicit conversions merit scrutiny\n var s string\n-var bad1 string = 1\t// ERROR \"conver|incompatible|invalid|cannot\"\n-var bad2 = s + 1\t\t// ERROR \"conver|incompatible|invalid\"\n-var bad3 = s + 'a'\t// ERROR \"conver|incompatible|invalid\"\n-var bad4 = \"a\" + 1\t// ERROR \"literals|incompatible|convert|invalid\"\n-var bad5 = \"a\" + 'a'\t// ERROR \"literals|incompatible|convert|invalid\"\n+var bad1 string = 1  // ERROR \"conver|incompatible|invalid|cannot\"\n+var bad2 = s + 1     // ERROR \"conver|incompatible|invalid\"\n+var bad3 = s + 'a'   // ERROR \"conver|incompatible|invalid\"\n+var bad4 = \"a\" + 1   // ERROR \"literals|incompatible|convert|invalid\"\n+var bad5 = \"a\" + 'a' // ERROR \"literals|incompatible|convert|invalid\"\n \n-var bad6 int = 1.5\t// ERROR \"convert|truncate\"\n-var bad7 int = 1e100\t// ERROR \"overflow\"\n-var bad8 float32 = 1e200\t// ERROR \"overflow\"\n+var bad6 int = 1.5       // ERROR \"convert|truncate\"\n+var bad7 int = 1e100     // ERROR \"overflow\"\n+var bad8 float32 = 1e200 // ERROR \"overflow\"\n \n // but these implicit conversions are okay\n var good1 string = \"a\"\n var good2 int = 1.0\n var good3 int = 1e9\n-var good4 float = 1e20\n+var good4 float64 = 1e20\n \n // explicit conversion of string is okay\n var _ = []int(\"abc\")\n var _ = []byte(\"abc\")\n \n // implicit is not\n-var _ []int = \"abc\"\t// ERROR \"cannot use|incompatible|invalid\"\n-var _ []byte = \"abc\"\t// ERROR \"cannot use|incompatible|invalid\"\n+var _ []int = \"abc\"  // ERROR \"cannot use|incompatible|invalid\"\n+var _ []byte = \"abc\" // ERROR \"cannot use|incompatible|invalid\"\n \n // named string is okay\n type Tstring string\n+\n var ss Tstring = \"abc\"\n var _ = []int(ss)\n var _ = []byte(ss)\n \n // implicit is still not\n-var _ []int = ss\t// ERROR \"cannot use|incompatible|invalid\"\n-var _ []byte = ss\t// ERROR \"cannot use|incompatible|invalid\"\n+var _ []int = ss  // ERROR \"cannot use|incompatible|invalid\"\n+var _ []byte = ss // ERROR \"cannot use|incompatible|invalid\"\n \n // named slice is not\n type Tint []int\n type Tbyte []byte\n-var _ = Tint(\"abc\")\t// ERROR \"convert|incompatible|invalid\"\n-var _ = Tbyte(\"abc\")\t// ERROR \"convert|incompatible|invalid\"\n+\n+var _ = Tint(\"abc\")  // ERROR \"convert|incompatible|invalid\"\n+var _ = Tbyte(\"abc\") // ERROR \"convert|incompatible|invalid\"\n \n // implicit is still not\n-var _ Tint = \"abc\"\t// ERROR \"cannot use|incompatible|invalid\"\n-var _ Tbyte = \"abc\"\t// ERROR \"cannot use|incompatible|invalid\"\n+var _ Tint = \"abc\"  // ERROR \"cannot use|incompatible|invalid\"\n+var _ Tbyte = \"abc\" // ERROR \"cannot use|incompatible|invalid\""}, {"sha": "95b6346c3edfa9188d0889b0c091279793c55ce9", "filename": "gcc/testsuite/go.test/test/decl.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fdecl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fdecl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fdecl.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -8,26 +8,26 @@\n \n package main\n \n-func f1() int { return 1 }\n-func f2() (float, int) { return 1, 2 }\n-func f3() (float, int, string) { return 1, 2, \"3\" }\n+func f1() int                    { return 1 }\n+func f2() (float32, int)         { return 1, 2 }\n+func f3() (float32, int, string) { return 1, 2, \"3\" }\n \n func x() (s string) {\n \ta, b, s := f3()\n \t_, _ = a, b\n-\treturn\t// tests that result var is in scope for redeclaration\n+\treturn // tests that result var is in scope for redeclaration\n }\n \n func main() {\n \ti, f, s := f3()\n-\tj, f := f2()\t// redeclare f\n+\tj, f := f2() // redeclare f\n \tk := f1()\n \tm, g, s := f3()\n \tm, h, s := f3()\n \t{\n \t\t// new block should be ok.\n \t\ti, f, s := f3()\n-\t\tj, f := f2()\t// redeclare f\n+\t\tj, f := f2() // redeclare f\n \t\tk := f1()\n \t\tm, g, s := f3()\n \t\tm, h, s := f3()"}, {"sha": "5e5e145011040dc7f974012b20e4db67a378c133", "filename": "gcc/testsuite/go.test/test/declbad.go", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fdeclbad.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fdeclbad.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fdeclbad.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -8,51 +8,51 @@\n \n package main\n \n-func f1() int { return 1 }\n-func f2() (float, int) { return 1, 2 }\n-func f3() (float, int, string) { return 1, 2, \"3\" }\n+func f1() int                    { return 1 }\n+func f2() (float32, int)         { return 1, 2 }\n+func f3() (float32, int, string) { return 1, 2, \"3\" }\n \n func main() {\n \t{\n \t\t// simple redeclaration\n \t\ti := f1()\n-\t\ti := f1()\t// ERROR \"redeclared|no new\"\n+\t\ti := f1() // ERROR \"redeclared|no new\"\n \t\t_ = i\n \t}\n \t{\n \t\t// change of type for f\n \t\ti, f, s := f3()\n-\t\tf, g, t := f3()\t// ERROR \"redeclared|cannot assign|incompatible\"\n+\t\tf, g, t := f3() // ERROR \"redeclared|cannot assign|incompatible\"\n \t\t_, _, _, _, _ = i, f, s, g, t\n \t}\n \t{\n \t\t// change of type for i\n \t\ti, f, s := f3()\n-\t\tj, i, t := f3()\t// ERROR \"redeclared|cannot assign|incompatible\"\n+\t\tj, i, t := f3() // ERROR \"redeclared|cannot assign|incompatible\"\n \t\t_, _, _, _, _ = i, f, s, j, t\n \t}\n \t{\n \t\t// no new variables\n \t\ti, f, s := f3()\n-\t\ti, f := f2()\t// ERROR \"redeclared|no new\"\n+\t\ti, f := f2() // ERROR \"redeclared|no new\"\n \t\t_, _, _ = i, f, s\n \t}\n \t{\n \t\t// single redeclaration\n \t\ti, f, s := f3()\n-\t\ti := f1()\t\t// ERROR \"redeclared|no new|incompatible\"\n+\t\ti := f1() // ERROR \"redeclared|no new|incompatible\"\n \t\t_, _, _ = i, f, s\n \t}\n-\t\t// double redeclaration\n+\t// double redeclaration\n \t{\n \t\ti, f, s := f3()\n-\t\ti, f := f2()\t// ERROR \"redeclared|no new\"\n+\t\ti, f := f2() // ERROR \"redeclared|no new\"\n \t\t_, _, _ = i, f, s\n \t}\n \t{\n \t\t// triple redeclaration\n \t\ti, f, s := f3()\n-\t\ti, f, s := f3()\t// ERROR \"redeclared|no new\"\n+\t\ti, f, s := f3() // ERROR \"redeclared|no new\"\n \t\t_, _, _ = i, f, s\n \t}\n }"}, {"sha": "43b5dfb129492c26d93b5db526cfac4fc08dea0c", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug006.go", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug006.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug006.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug006.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -9,11 +9,16 @@ package main\n import \"os\"\n \n const (\n-\tx float = iota;\n-\tg float = 4.5 * iota;\n-);\n+\tx float64 = iota\n+\tg float64 = 4.5 * iota\n+)\n \n func main() {\n-\tif g == 0.0 { print(\"zero\\n\");}\n-\tif g != 4.5 { print(\" fail\\n\"); os.Exit(1); }\n+\tif g == 0.0 {\n+\t\tprint(\"zero\\n\")\n+\t}\n+\tif g != 4.5 {\n+\t\tprint(\" fail\\n\")\n+\t\tos.Exit(1)\n+\t}\n }"}, {"sha": "d65f6da4503b00e4ef966f7e960f5606cf183a05", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug007.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug007.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug007.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug007.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -7,7 +7,9 @@\n package main\n \n type (\n-\tPoint struct { x, y float };\n+\tPoint struct {\n+\t\tx, y float64\n+\t}\n \tPolar Point\n )\n "}, {"sha": "7d96988d43bd183cf2e7099ce17fb14c7378cbc9", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug010.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug010.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug010.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug010.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -7,14 +7,14 @@\n package main\n \n \n-func f(i int, f float) {\n-\ti = 8;\n-\tf = 8.0;\n-\treturn;\n+func f(i int, f float64) {\n+\ti = 8\n+\tf = 8.0\n+\treturn\n }\n \n func main() {\n-\tf(3, float(5))\n+\tf(3, float64(5))\n }\n \n /*"}, {"sha": "ce627472c473a3d4b7fef12006e9901b3e384655", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug011.go", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug011.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug011.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug011.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -8,19 +8,19 @@ package main\n \n \n type T struct {\n-\tx, y int;\n+\tx, y int\n }\n \n-func (t *T) m(a int, b float) int {\n-\treturn (t.x+a) * (t.y+int(b));\n+func (t *T) m(a int, b float64) int {\n+\treturn (t.x + a) * (t.y + int(b))\n }\n \n func main() {\n-\tvar t *T = new(T);\n-\tt.x = 1;\n-\tt.y = 2;\n-\tr10 := t.m(1, 3.0);\n-\t_ = r10;\n+\tvar t *T = new(T)\n+\tt.x = 1\n+\tt.y = 2\n+\tr10 := t.m(1, 3.0)\n+\t_ = r10\n }\n /*\n bug11.go:16: fatal error: walktype: switch 1 unknown op CALLMETH l(16) <int32>INT32"}, {"sha": "bd2a633f298eb6ee31c23f954b71d93b87b87adc", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug035.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug035.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug035.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug035.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -6,8 +6,8 @@\n \n package main\n \n-func f9(a int) (i int, f float) {\n-\ti := 9;  // ERROR \"redecl|no new\"\n-\tf := float(9);  // ERROR \"redecl|no new\"\n-\treturn i, f;\n+func f9(a int) (i int, f float64) {\n+\ti := 9          // ERROR \"redecl|no new\"\n+\tf := float64(9) // ERROR \"redecl|no new\"\n+\treturn i, f\n }"}, {"sha": "5a776abce8d591cc9a2f794dcf0de75d99822f63", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug047.go", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug047.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug047.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug047.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -9,15 +9,15 @@ package main\n func main() {\n \n \ttype T struct {\n-\t\ts string;\n-\t\tf float;\n-\t};\n-\tvar s string = \"hello\";\n-\tvar f float = 0.2;\n-\tt := T{s, f};\n+\t\ts string\n+\t\tf float64\n+\t}\n+\tvar s string = \"hello\"\n+\tvar f float64 = 0.2\n+\tt := T{s, f}\n \n-\ttype M map[int] int;\n-\tm0 := M{7:8};\n+\ttype M map[int]int\n+\tm0 := M{7: 8}\n \n-\t_, _ = t, m0;\n+\t_, _ = t, m0\n }"}, {"sha": "bae16cdb2e90cae4c7b3296ddba2b69c916b85a5", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug080.go", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug080.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug080.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug080.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -4,18 +4,18 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package main\t\n- \t\n-func f1() (x int, y float) {\n-\treturn;\n+package main\n+\n+func f1() (x int, y float64) {\n+\treturn\n }\n \n-func f2   (x int, y float) {\n-\treturn;\n+func f2(x int, y float64) {\n+\treturn\n }\n \n func main() {\n-\tf2(f1());  // this should be a legal call\n+\tf2(f1()) // this should be a legal call\n }\n \n /*"}, {"sha": "7666577230fc66589f73f31cdee8ade5557d0324", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug109.go", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug109.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug109.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug109.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -5,10 +5,11 @@\n // license that can be found in the LICENSE file.\n \n package main\n-func f(a float) float {\n-\te := 1.0;\n-\te = e * a;\n-\treturn e;\n+\n+func f(a float64) float64 {\n+\te := 1.0\n+\te = e * a\n+\treturn e\n }\n \n /*"}, {"sha": "33eb3cb1a955c0d35115bc107afe2cae88b4fdca", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug167.go", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug167.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug167.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug167.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -7,20 +7,24 @@\n package main\n \n func f1() {\n-\ttype T struct { x int }\n+\ttype T struct {\n+\t\tx int\n+\t}\n }\n \n func f2() {\n-\ttype T struct { x float }\n+\ttype T struct {\n+\t\tx float64\n+\t}\n }\n \n func main() {\n-\tf1();\n-\tf2();\n+\tf1()\n+\tf2()\n }\n \n /*\n 1606416576: conflicting definitions for main.T\u00b7bug167\n bug167.6:\ttype main.T\u00b7bug167 struct { x int }\n-bug167.6:\ttype main.T\u00b7bug167 struct { x float }\n+bug167.6:\ttype main.T\u00b7bug167 struct { x float64 }\n */"}, {"sha": "5ef02b1c1d77598adfbd42782dd0fbb8ed0ec4fc", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug193.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug193.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug193.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug193.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -7,10 +7,10 @@\n package main\n \n func main() {\n-\ts := uint(10);\n-\tss := 1<<s;\n-\ty1 := float(ss);\n-\ty2 := float(1<<s);  // ERROR \"shift\"\n-\ty3 := string(1<<s);  // ERROR \"shift\"\n-\t_, _, _, _, _ = s, ss, y1, y2, y3;\n+\ts := uint(10)\n+\tss := 1 << s\n+\ty1 := float64(ss)\n+\ty2 := float64(1 << s) // ERROR \"shift\"\n+\ty3 := string(1 << s)  // ERROR \"shift\"\n+\t_, _, _, _, _ = s, ss, y1, y2, y3\n }"}, {"sha": "7efc0b14afb7969b6b3e9936f580cab78bd5c11c", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug206.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug206.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug206.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug206.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -10,14 +10,14 @@ import \"go/ast\";\n \n func g(list []ast.Expr) {\n \tn := len(list)-1;\n-\tprintln(list[n].Pos().Line);\n+\tprintln(list[n].Pos());\n }\n \n \n // f is the same as g except that the expression assigned to n is inlined.\n func f(list []ast.Expr) {\n \t// n := len(list)-1;\n-\tprintln(list[len(list)-1 /* n */].Pos().Line);\n+\tprintln(list[len(list)-1 /* n */].Pos());\n }\n \n "}, {"sha": "ff027ddc22963a2b2fac556f0ecc0e7818b6074f", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug220.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug220.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug220.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug220.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -7,8 +7,8 @@\n package main\n \n func main() {\n-\tm := make(map[int]map[uint]float);\n-\t\n-\tm[0] = make(map[uint]float), false;\t// 6g used to reject this\n-\tm[1] = nil;\n+\tm := make(map[int]map[uint]float64)\n+\n+\tm[0] = make(map[uint]float64), false // 6g used to reject this\n+\tm[1] = nil\n }"}, {"sha": "c7ad1a3660c7b57bf8e8ef8a01a314c2f3e1142b", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug230.go", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug230.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug230.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug230.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -8,14 +8,17 @@ package main\n \n type S string\n type I int\n-type F float\n+type F float64\n \n func (S) m() {}\n func (I) m() {}\n func (F) m() {}\n \n func main() {\n-\tc := make(chan interface { m() }, 10)\n+\tc := make(chan interface {\n+\t\tm()\n+\t},\n+\t\t10)\n \tc <- I(0)\n \tc <- F(1)\n \tc <- S(\"hi\")"}, {"sha": "7e8660d37e4b15c75da4a54b68ddcadd1cda2ddc", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug238.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug238.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug238.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug238.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -17,6 +17,6 @@ const f struct{} = 6    // ERROR \"convert|wrong|invalid\"\n const g interface{} = 7 // ERROR \"constant|wrong|invalid\"\n const h bool = false\n const i int = 2\n-const j float = 5\n+const j float64 = 5\n \n func main() { println(a, b, c, d, e, f, g) }"}, {"sha": "4ea187a4b127da99a3c5a913407de92c313c041b", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug248.dir/bug2.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug248.dir%2Fbug2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug248.dir%2Fbug2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug248.dir%2Fbug2.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -23,7 +23,7 @@ type t0 int\n \n func (t0) M(p0.T) {}\n \n-type t1 float\n+type t1 float64\n \n func (t1) M(p1.T) {}\n "}, {"sha": "e5a24495577300b9f1170004af929feb9ab681e1", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug248.dir/bug3.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug248.dir%2Fbug3.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug248.dir%2Fbug3.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug248.dir%2Fbug3.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -26,7 +26,7 @@ type t0 int\n func (t0) M(p0.T) {}\n \n // t1 satisfies I1 and p1.I\n-type t1 float\n+type t1 float64\n \n func (t1) M(p1.T) {}\n "}, {"sha": "1c7adb5f5b80327b6c6bf40372cabc5090d8633c", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug299.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug299.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug299.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug299.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -11,9 +11,9 @@ type T struct {\n \tx int\n \ty (int)\n \tint\n-\t*float\n+\t*float64\n \t// not legal according to spec\n-\t(complex)  // ERROR \"non-declaration|expected|parenthesize\"\n+\t(complex128)  // ERROR \"non-declaration|expected|parenthesize\"\n \t(*string)  // ERROR \"non-declaration|expected|parenthesize\"\n \t*(bool)    // ERROR \"non-declaration|expected|parenthesize\"\n }"}, {"sha": "e8ed928bcd3773d528219357be629480283a5233", "filename": "gcc/testsuite/go.test/test/func.go", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffunc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffunc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffunc.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -21,10 +21,10 @@ func f2(a int) {\n }\n \n func f3(a, b int) int {\n-\treturn a+b\n+\treturn a + b\n }\n \n-func f4(a, b int, c float) int {\n+func f4(a, b int, c float32) int {\n \treturn (a+b)/2 + int(c)\n }\n \n@@ -36,25 +36,25 @@ func f6(a int) (r int) {\n \treturn 6\n }\n \n-func f7(a int) (x int, y float) {\n+func f7(a int) (x int, y float32) {\n \treturn 7, 7.0\n }\n \n \n-func f8(a int) (x int, y float) {\n+func f8(a int) (x int, y float32) {\n \treturn 8, 8.0\n }\n \n type T struct {\n \tx, y int\n }\n \n-func (t *T) m10(a int, b float) int {\n-\treturn (t.x+a) * (t.y+int(b))\n+func (t *T) m10(a int, b float32) int {\n+\treturn (t.x + a) * (t.y + int(b))\n }\n \n \n-func f9(a int) (i int, f float) {\n+func f9(a int) (i int, f float32) {\n \ti = 9\n \tf = 9.0\n \treturn"}, {"sha": "056ff9877d39e83624a514ee3ae1cb24b0554426", "filename": "gcc/testsuite/go.test/test/func1.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffunc1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffunc1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffunc1.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -8,11 +8,11 @@\n \n package main\n \n-func f1(a int) (int, float) {  // BUG (not caught by compiler): multiple return values must have names\n+func f1(a int) (int, float32) { // BUG (not caught by compiler): multiple return values must have names\n \treturn 7, 7.0\n }\n \n \n-func f2(a int) (a int, b float) {  // ERROR \"redeclared|definition\"\n+func f2(a int) (a int, b float32) { // ERROR \"redeclared|definition\"\n \treturn 8, 8.0\n }"}, {"sha": "b6a582fffba8700287add0f3f9bf01f3c868ced2", "filename": "gcc/testsuite/go.test/test/interface/explicit.go", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Finterface%2Fexplicit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Finterface%2Fexplicit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Finterface%2Fexplicit.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -51,21 +51,25 @@ func main() {\n \tt = T(e) // ERROR \"need explicit|need type assertion|incompatible\"\n }\n \n-type M interface { M() }\n+type M interface {\n+\tM()\n+}\n+\n var m M\n \n-var _ = m.(int)\t// ERROR \"impossible type assertion\"\n+var _ = m.(int) // ERROR \"impossible type assertion\"\n \n type Int int\n-func (Int) M(float) {}\n \n-var _ = m.(Int)\t// ERROR \"impossible type assertion\"\n+func (Int) M(float64) {}\n+\n+var _ = m.(Int) // ERROR \"impossible type assertion\"\n \n var ii int\n var jj Int\n \n-var m1 M = ii\t// ERROR \"incompatible|missing\"\n-var m2 M = jj\t// ERROR \"incompatible|wrong type for M method\"\n+var m1 M = ii // ERROR \"incompatible|missing\"\n+var m2 M = jj // ERROR \"incompatible|wrong type for M method\"\n \n-var m3 = M(ii)\t// ERROR \"invalid|missing\"\n-var m4 = M(jj)\t// ERROR \"invalid|wrong type for M method\"\n+var m3 = M(ii) // ERROR \"invalid|missing\"\n+var m4 = M(jj) // ERROR \"invalid|wrong type for M method\""}, {"sha": "c40ca1f382464f943ebd7af7476d8a0edd5d34de", "filename": "gcc/testsuite/go.test/test/iota.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fiota.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fiota.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fiota.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -17,8 +17,8 @@ const (\n \tx int = iota\n \ty = iota\n \tz = 1 << iota\n-\tf float = 2 * iota\n-\tg float = 4.5 * float(iota)\n+\tf float32 = 2 * iota\n+\tg float32 = 4.5 * float32(iota)\n )\n \n const (\n@@ -57,7 +57,7 @@ const (\n )\n \n const (\n-\tp = float(iota)\n+\tp = float32(iota)\n \tq\n \tr\n )\n@@ -68,9 +68,9 @@ const (\n )\n \n const (\n-\tabit, amask = 1 << iota, 1 << iota - 1\n-\tbbit, bmask = 1 << iota, 1 << iota - 1\n-\tcbit, cmask = 1 << iota, 1 << iota - 1\n+\tabit, amask = 1 << iota, 1<<iota - 1\n+\tbbit, bmask = 1 << iota, 1<<iota - 1\n+\tcbit, cmask = 1 << iota, 1<<iota - 1\n )\n \n func main() {"}, {"sha": "ba1fa196fd6874b23e27fb162d4afd8032954af6", "filename": "gcc/testsuite/go.test/test/ken/cplx0.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fken%2Fcplx0.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fken%2Fcplx0.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fken%2Fcplx0.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -13,7 +13,7 @@ const (\n \tC1 = R + I // ADD(5,6)\n )\n \n-func doprint(c complex) { println(c) }\n+func doprint(c complex128) { println(c) }\n \n func main() {\n "}, {"sha": "8ec7d40f5e58104b6260a1066cb8e18b0359a315", "filename": "gcc/testsuite/go.test/test/ken/cplx1.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fken%2Fcplx1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fken%2Fcplx1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fken%2Fcplx1.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -48,7 +48,7 @@ func main() {\n \tbooltest(6+9i, false)\n }\n \n-func booltest(a complex, r bool) {\n+func booltest(a complex64, r bool) {\n \tvar b bool\n \n \tb = a == C1"}, {"sha": "83acc15ff7c12e529dfc2a2437658c9891be96f2", "filename": "gcc/testsuite/go.test/test/ken/cplx3.go", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fken%2Fcplx3.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fken%2Fcplx3.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fken%2Fcplx3.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -16,24 +16,18 @@ const (\n \tC1 = R + I // ADD(5,6)\n )\n \n-var complexBits = reflect.Typeof(complex(0i)).Size() * 8\n-\n func main() {\n \tc0 := C1\n \tc0 = (c0 + c0 + c0) / (c0 + c0 + 3i)\n \tprintln(c0)\n \n-\tc := *(*complex)(unsafe.Pointer(&c0))\n+\tc := *(*complex128)(unsafe.Pointer(&c0))\n \tprintln(c)\n \n-\tprintln(complexBits)\n-\n \tvar a interface{}\n \tswitch c := reflect.NewValue(a).(type) {\n \tcase *reflect.ComplexValue:\n-\t\tif complexBits == 64 {\n-\t\t\tv := c.Get()\n-\t\t\t_, _ = complex64(v), true\n-\t\t}\n+\t\tv := c.Get()\n+\t\t_, _ = complex128(v), true\n \t}\n }"}, {"sha": "8524e47aec3b303a95b5e0fae2b3e9b32c1ac8df", "filename": "gcc/testsuite/go.test/test/ken/cplx4.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fken%2Fcplx4.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fken%2Fcplx4.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fken%2Fcplx4.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -15,7 +15,7 @@ const (\n \tC1 = R + I // ADD(5,6)\n )\n \n-func doprint(c complex) { fmt.Printf(\"c = %f\\n\", c) }\n+func doprint(c complex128) { fmt.Printf(\"c = %f\\n\", c) }\n \n func main() {\n \n@@ -32,12 +32,12 @@ func main() {\n \tc2 := complex128(C1)\n \tfmt.Printf(\"c = %G\\n\", c2)\n \n-\t// real, imag, cmplx\n-\tc3 := cmplx(real(c2)+3, imag(c2)-5) + c2\n+\t// real, imag, complex\n+\tc3 := complex(real(c2)+3, imag(c2)-5) + c2\n \tfmt.Printf(\"c = %G\\n\", c3)\n \n \t// compiler used to crash on nested divide\n-\tc4 := cmplx(real(c3/2), imag(c3/2))\n+\tc4 := complex(real(c3/2), imag(c3/2))\n \tif c4 != c3/2 {\n \t\tfmt.Printf(\"BUG: c3 = %G != c4 = %G\\n\", c3, c4)\n \t}"}, {"sha": "d425a7c4c04da9b29ec34ac4213b0056a6f1be94", "filename": "gcc/testsuite/go.test/test/ken/cplx5.go", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fken%2Fcplx5.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fken%2Fcplx5.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fken%2Fcplx5.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -6,49 +6,49 @@\n \n package main\n \n-var a [12]complex\n-var s []complex\n-var c chan complex\n+var a [12]complex128\n+var s []complex128\n+var c chan complex128\n var f struct {\n-\tc complex\n+\tc complex128\n }\n-var m map[complex]complex\n+var m map[complex128]complex128\n \n func main() {\n-\t// array of complex\n+\t// array of complex128\n \tfor i := 0; i < len(a); i++ {\n-\t\ta[i] = cmplx(float(i), float(-i))\n+\t\ta[i] = complex(float64(i), float64(-i))\n \t}\n \tprintln(a[5])\n \n-\t// slice of complex\n-\ts = make([]complex, len(a))\n+\t// slice of complex128\n+\ts = make([]complex128, len(a))\n \tfor i := 0; i < len(s); i++ {\n \t\ts[i] = a[i]\n \t}\n \tprintln(s[5])\n \n \t// chan\n-\tc = make(chan complex)\n+\tc = make(chan complex128)\n \tgo chantest(c)\n \tprintln(<-c)\n \n-\t// pointer of complex\n+\t// pointer of complex128\n \tv := a[5]\n \tpv := &v\n \tprintln(*pv)\n \n-\t// field of complex\n+\t// field of complex128\n \tf.c = a[5]\n \tprintln(f.c)\n \n-\t// map of complex\n-\tm = make(map[complex]complex)\n+\t// map of complex128\n+\tm = make(map[complex128]complex128)\n \tfor i := 0; i < len(s); i++ {\n \t\tm[-a[i]] = a[i]\n \t}\n \tprintln(m[5i-5])\n-\tprintln(m[cmplx(-5, 5)])\n+\tprintln(m[complex(-5, 5)])\n }\n \n-func chantest(c chan complex) { c <- a[5] }\n+func chantest(c chan complex128) { c <- a[5] }"}, {"sha": "6b3d4b2e46086c82b33354f0dbbb7bcb9d09b5dd", "filename": "gcc/testsuite/go.test/test/ken/robfunc.go", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fken%2Frobfunc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fken%2Frobfunc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fken%2Frobfunc.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -8,8 +8,8 @@ package main\n \n func assertequal(is, shouldbe int, msg string) {\n \tif is != shouldbe {\n-\t\tprint(\"assertion fail\" + msg + \"\\n\");\n-\t\tpanic(1);\n+\t\tprint(\"assertion fail\" + msg + \"\\n\")\n+\t\tpanic(1)\n \t}\n }\n \n@@ -20,75 +20,75 @@ func f2(a int) {\n }\n \n func f3(a, b int) int {\n-\treturn a+b;\n+\treturn a + b\n }\n \n-func f4(a, b int, c float) int {\n-\treturn (a+b)/2 + int(c);\n+func f4(a, b int, c float64) int {\n+\treturn (a+b)/2 + int(c)\n }\n \n func f5(a int) int {\n-\treturn 5;\n+\treturn 5\n }\n \n func f6(a int) (r int) {\n-\treturn 6;\n+\treturn 6\n }\n \n-func f7(a int) (x int, y float) {\n-\treturn 7, 7.0;\n+func f7(a int) (x int, y float64) {\n+\treturn 7, 7.0\n }\n \n \n-func f8(a int) (x int, y float) {\n-\treturn 8, 8.0;\n+func f8(a int) (x int, y float64) {\n+\treturn 8, 8.0\n }\n \n type T struct {\n-\tx, y int;\n+\tx, y int\n }\n \n-func (t *T) m10(a int, b float) int {\n-\treturn (t.x+a) * (t.y+int(b));\n+func (t *T) m10(a int, b float64) int {\n+\treturn (t.x + a) * (t.y + int(b))\n }\n \n \n-func f9(a int) (in int, fl float) {\n-\ti := 9;\n-\tf := float(9);\n-\treturn i, f;\n+func f9(a int) (in int, fl float64) {\n+\ti := 9\n+\tf := float64(9)\n+\treturn i, f\n }\n \n \n func main() {\n-\tf1();\n-\tf2(1);\n-\tr3 := f3(1, 2);\n-\tassertequal(r3, 3, \"3\");\n-\tr4 := f4(0, 2, 3.0);\n-\tassertequal(r4, 4, \"4\");\n-\tr5 := f5(1);\n-\tassertequal(r5, 5, \"5\");\n-\tr6 := f6(1);\n-\tassertequal(r6, 6, \"6\");\n-\tvar r7 int;\n-\tvar s7 float;\n-\tr7, s7 = f7(1);\n-\tassertequal(r7, 7, \"r7\");\n-\tassertequal(int(s7), 7, \"s7\");\n-\tvar r8 int;\n-\tvar s8 float;\n-\tr8, s8 = f8(1);\n-\tassertequal(r8, 8, \"r8\");\n-\tassertequal(int(s8), 8, \"s8\");\n-\tvar r9 int;\n-\tvar s9 float;\n-\tr9, s9 = f9(1);\n-\tassertequal(r9, 9, \"r9\");\n-\tassertequal(int(s9), 9, \"s9\");\n-\tvar t *T = new(T);\n-\tt.x = 1;\n-\tt.y = 2;\n-\tr10 := t.m10(1, 3.0);\n-\tassertequal(r10, 10, \"10\");\n+\tf1()\n+\tf2(1)\n+\tr3 := f3(1, 2)\n+\tassertequal(r3, 3, \"3\")\n+\tr4 := f4(0, 2, 3.0)\n+\tassertequal(r4, 4, \"4\")\n+\tr5 := f5(1)\n+\tassertequal(r5, 5, \"5\")\n+\tr6 := f6(1)\n+\tassertequal(r6, 6, \"6\")\n+\tvar r7 int\n+\tvar s7 float64\n+\tr7, s7 = f7(1)\n+\tassertequal(r7, 7, \"r7\")\n+\tassertequal(int(s7), 7, \"s7\")\n+\tvar r8 int\n+\tvar s8 float64\n+\tr8, s8 = f8(1)\n+\tassertequal(r8, 8, \"r8\")\n+\tassertequal(int(s8), 8, \"s8\")\n+\tvar r9 int\n+\tvar s9 float64\n+\tr9, s9 = f9(1)\n+\tassertequal(r9, 9, \"r9\")\n+\tassertequal(int(s9), 9, \"s9\")\n+\tvar t *T = new(T)\n+\tt.x = 1\n+\tt.y = 2\n+\tr10 := t.m10(1, 3.0)\n+\tassertequal(r10, 10, \"10\")\n }"}, {"sha": "feb85d29997da3bbf1c5feb4495a0371dffcf13b", "filename": "gcc/testsuite/go.test/test/ken/simpconv.go", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fken%2Fsimpconv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fken%2Fsimpconv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fken%2Fsimpconv.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -6,20 +6,23 @@\n \n package main\n \n-type vlong int64;\n-type short int16;\n+type vlong int64\n+type short int16\n \n-func\n-main() {\n-\ts1 := vlong(0);\n-\tfor i:=short(0); i<10; i=i+1 {\n-\t\ts1 = s1 + vlong(i);\n+func main() {\n+\ts1 := vlong(0)\n+\tfor i := short(0); i < 10; i = i + 1 {\n+\t\ts1 = s1 + vlong(i)\n+\t}\n+\tif s1 != 45 {\n+\t\tpanic(s1)\n \t}\n-\tif s1 != 45 { panic(s1); }\n \n-\ts2 := float(0);\n-\tfor i:=0; i<10; i=i+1 {\n-\t\ts2 = s2 + float(i);\n+\ts2 := float64(0)\n+\tfor i := 0; i < 10; i = i + 1 {\n+\t\ts2 = s2 + float64(i)\n+\t}\n+\tif s2 != 45 {\n+\t\tpanic(s2)\n \t}\n-\tif s2 != 45 { panic(s2); }\n }"}, {"sha": "5c31270fcd3dca00032b250c9848043581b00fe4", "filename": "gcc/testsuite/go.test/test/ken/slicearray.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fken%2Fslicearray.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fken%2Fslicearray.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fken%2Fslicearray.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -8,8 +8,8 @@ package main\n \n var bx [10]byte\n var by []byte\n-var fx [10]float\n-var fy []float\n+var fx [10]float64\n+var fy []float64\n var lb, hb int\n var t int\n \n@@ -87,7 +87,7 @@ func main() {\n \tby = bx[2:8]\n \ttstb()\n \n-\t// width 4 (float)\n+\t// width 4 (float64)\n \tlb = 0\n \thb = 10\n \tfy = fx[lb:hb]\n@@ -204,7 +204,7 @@ func init() {\n \tby = nil\n \n \tfor i := 0; i < len(fx); i++ {\n-\t\tfx[i] = float(i + 20)\n+\t\tfx[i] = float64(i + 20)\n \t}\n \tfy = nil\n }"}, {"sha": "639042128774d1888e4c2e70adf26224dc1789f1", "filename": "gcc/testsuite/go.test/test/ken/sliceslice.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fken%2Fsliceslice.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fken%2Fsliceslice.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fken%2Fsliceslice.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -8,8 +8,8 @@ package main\n \n var bx []byte\n var by []byte\n-var fx []float\n-var fy []float\n+var fx []float64\n+var fy []float64\n var lb, hb int\n var t int\n \n@@ -78,7 +78,7 @@ func main() {\n \tby = bx[2:8]\n \ttstb()\n \n-\t// width 4 (float)\n+\t// width 4 (float64)\n \tlb = 0\n \thb = 10\n \tfy = fx[lb:hb]\n@@ -195,9 +195,9 @@ func init() {\n \t}\n \tby = nil\n \n-\tfx = make([]float, 10)\n+\tfx = make([]float64, 10)\n \tfor i := 0; i < len(fx); i++ {\n-\t\tfx[i] = float(i + 20)\n+\t\tfx[i] = float64(i + 20)\n \t}\n \tfy = nil\n }"}, {"sha": "bf05388127ceba120de38ef024f1ed72fbbe27da", "filename": "gcc/testsuite/go.test/test/literal.go", "status": "modified", "additions": 29, "deletions": 40, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fliteral.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fliteral.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fliteral.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -6,8 +6,6 @@\n \n package main\n \n-import \"os\"\n-\n var nbad int\n \n func assert(cond bool, msg string) {\n@@ -20,16 +18,8 @@ func assert(cond bool, msg string) {\n \t}\n }\n \n-func equal(a, b float) bool {\n-\tif os.Getenv(\"GOARCH\") != \"arm\" {\n-\t\treturn a == b\n-\t}\n-\td := a-b\n-\tif a > b {\n-\t\treturn d < a * 1.0e-7\n-\t}\n-\td = -d\n-\treturn d < b * 1.0e-7\n+func equal(a, b float32) bool {\n+\treturn a == b\n }\n \n \n@@ -47,7 +37,7 @@ func main() {\n \tvar i04 int8 = -127\n \tvar i05 int8 = -128\n \tvar i06 int8 = +127\n-\tassert(i01 == i00 + 1, \"i01\")\n+\tassert(i01 == i00+1, \"i01\")\n \tassert(i02 == -i01, \"i02\")\n \tassert(i03 == -i04, \"i03\")\n \tassert(-(i05+1) == i06, \"i05\")\n@@ -60,7 +50,7 @@ func main() {\n \tvar i14 int16 = -32767\n \tvar i15 int16 = -32768\n \tvar i16 int16 = +32767\n-\tassert(i11 == i10 + 1, \"i11\")\n+\tassert(i11 == i10+1, \"i11\")\n \tassert(i12 == -i11, \"i12\")\n \tassert(i13 == -i14, \"i13\")\n \tassert(-(i15+1) == i16, \"i15\")\n@@ -73,11 +63,11 @@ func main() {\n \tvar i24 int32 = -2147483647\n \tvar i25 int32 = -2147483648\n \tvar i26 int32 = +2147483647\n-\tassert(i21 == i20 + 1, \"i21\")\n+\tassert(i21 == i20+1, \"i21\")\n \tassert(i22 == -i21, \"i22\")\n \tassert(i23 == -i24, \"i23\")\n \tassert(-(i25+1) == i26, \"i25\")\n-\tassert(i23 == (1 << 31) - 1, \"i23 size\")\n+\tassert(i23 == (1<<31)-1, \"i23 size\")\n \n \t// int64\n \tvar i30 int64 = 0\n@@ -87,35 +77,35 @@ func main() {\n \tvar i34 int64 = -9223372036854775807\n \tvar i35 int64 = -9223372036854775808\n \tvar i36 int64 = +9223372036854775807\n-\tassert(i31 == i30 + 1, \"i31\")\n+\tassert(i31 == i30+1, \"i31\")\n \tassert(i32 == -i31, \"i32\")\n \tassert(i33 == -i34, \"i33\")\n \tassert(-(i35+1) == i36, \"i35\")\n-\tassert(i33 == (1<<63) - 1, \"i33 size\")\n+\tassert(i33 == (1<<63)-1, \"i33 size\")\n \n \t// uint8\n \tvar u00 uint8 = 0\n \tvar u01 uint8 = 1\n \tvar u02 uint8 = 255\n \tvar u03 uint8 = +255\n-\tassert(u01 == u00 + 1, \"u01\")\n+\tassert(u01 == u00+1, \"u01\")\n \tassert(u02 == u03, \"u02\")\n-\tassert(u03 == (1<<8) - 1, \"u03 size\")\n+\tassert(u03 == (1<<8)-1, \"u03 size\")\n \n \t// uint16\n \tvar u10 uint16 = 0\n \tvar u11 uint16 = 1\n \tvar u12 uint16 = 65535\n \tvar u13 uint16 = +65535\n-\tassert(u11 == u10 + 1, \"u11\")\n+\tassert(u11 == u10+1, \"u11\")\n \tassert(u12 == u13, \"u12\")\n \n \t// uint32\n \tvar u20 uint32 = 0\n \tvar u21 uint32 = 1\n \tvar u22 uint32 = 4294967295\n \tvar u23 uint32 = +4294967295\n-\tassert(u21 == u20 + 1, \"u21\")\n+\tassert(u21 == u20+1, \"u21\")\n \tassert(u22 == u23, \"u22\")\n \n \t// uint64\n@@ -126,23 +116,23 @@ func main() {\n \t_, _, _, _ = u30, u31, u32, u33\n \n \t// float\n-\tvar f00 float = 3.14159\n-\tvar f01 float = -3.14159\n-\tvar f02 float = +3.14159\n-\tvar f03 float = 0.0\n-\tvar f04 float = .0\n-\tvar f05 float = 0.\n-\tvar f06 float = -0.0\n-\tvar f07 float = 1e10\n-\tvar f08 float = -1e10\n-\tvar f09 float = 1e-10\n-\tvar f10 float = 1e+10\n-\tvar f11 float = 1.e-10\n-\tvar f12 float = 1.e+10\n-\tvar f13 float = .1e-10\n-\tvar f14 float = .1e+10\n-\tvar f15 float = 1.1e-10\n-\tvar f16 float = 1.1e+10\n+\tvar f00 float32 = 3.14159\n+\tvar f01 float32 = -3.14159\n+\tvar f02 float32 = +3.14159\n+\tvar f03 float32 = 0.0\n+\tvar f04 float32 = .0\n+\tvar f05 float32 = 0.\n+\tvar f06 float32 = -0.0\n+\tvar f07 float32 = 1e10\n+\tvar f08 float32 = -1e10\n+\tvar f09 float32 = 1e-10\n+\tvar f10 float32 = 1e+10\n+\tvar f11 float32 = 1.e-10\n+\tvar f12 float32 = 1.e+10\n+\tvar f13 float32 = .1e-10\n+\tvar f14 float32 = .1e+10\n+\tvar f15 float32 = 1.1e-10\n+\tvar f16 float32 = 1.1e+10\n \tassert(f01 == -f00, \"f01\")\n \tassert(f02 == -f01, \"f02\")\n \tassert(f03 == f04, \"f03\")\n@@ -179,7 +169,6 @@ func main() {\n \tassert(c8 == 0x0b, \"c8\")\n \tassert(c9 == 0x672c, \"c9\")\n \n-\n \tvar c00 uint8 = '\\000'\n \tvar c01 uint8 = '\\007'\n \tvar c02 uint8 = '\\177'"}, {"sha": "c3963499bcef1fec02933893a8ba142b32a18825", "filename": "gcc/testsuite/go.test/test/map.go", "status": "modified", "additions": 83, "deletions": 84, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fmap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fmap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fmap.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -21,73 +21,73 @@ func P(a []string) string {\n \t\t}\n \t\ts += `\"` + a[i] + `\"`\n \t}\n-\ts +=\"}\"\n+\ts += \"}\"\n \treturn s\n }\n \n func main() {\n \t// Test a map literal.\n-\tmlit := map[string] int { \"0\":0, \"1\":1, \"2\":2, \"3\":3, \"4\":4 }\n+\tmlit := map[string]int{\"0\": 0, \"1\": 1, \"2\": 2, \"3\": 3, \"4\": 4}\n \tfor i := 0; i < len(mlit); i++ {\n-\t\ts := string([]byte{byte(i)+'0'})\n+\t\ts := string([]byte{byte(i) + '0'})\n \t\tif mlit[s] != i {\n \t\t\tfmt.Printf(\"mlit[%s] = %d\\n\", s, mlit[s])\n \t\t}\n \t}\n \n-\tmib := make(map[int] bool)\n-\tmii := make(map[int] int)\n-\tmfi := make(map[float] int)\n-\tmif := make(map[int] float)\n-\tmsi := make(map[string] int)\n-\tmis := make(map[int] string)\n-\tmss := make(map[string] string)\n-\tmspa := make(map[string] []string)\n+\tmib := make(map[int]bool)\n+\tmii := make(map[int]int)\n+\tmfi := make(map[float32]int)\n+\tmif := make(map[int]float32)\n+\tmsi := make(map[string]int)\n+\tmis := make(map[int]string)\n+\tmss := make(map[string]string)\n+\tmspa := make(map[string][]string)\n \t// BUG need an interface map both ways too\n \n \ttype T struct {\n-\t\ti int64\t// can't use string here; struct values are only compared at the top level\n-\t\tf float\n+\t\ti int64 // can't use string here; struct values are only compared at the top level\n+\t\tf float32\n \t}\n-\tmipT := make(map[int] *T)\n-\tmpTi := make(map[*T] int)\n-\tmit := make(map[int] T)\n-//\tmti := make(map[T] int)\n+\tmipT := make(map[int]*T)\n+\tmpTi := make(map[*T]int)\n+\tmit := make(map[int]T)\n+\t//\tmti := make(map[T] int)\n \n-\ttype M map[int] int\n-\tmipM := make(map[int] M)\n+\ttype M map[int]int\n+\tmipM := make(map[int]M)\n \n-\tvar apT [2*count]*T\n+\tvar apT [2 * count]*T\n \n \tfor i := 0; i < count; i++ {\n \t\ts := strconv.Itoa(i)\n-\t\ts10 := strconv.Itoa(i*10)\n-\t\tf := float(i)\n-\t\tt := T{int64(i),f}\n+\t\ts10 := strconv.Itoa(i * 10)\n+\t\tf := float32(i)\n+\t\tt := T{int64(i), f}\n \t\tapT[i] = new(T)\n \t\tapT[i].i = int64(i)\n \t\tapT[i].f = f\n-\t\tapT[2*i] = new(T)\t// need twice as many entries as we use, for the nonexistence check\n+\t\tapT[2*i] = new(T) // need twice as many entries as we use, for the nonexistence check\n \t\tapT[2*i].i = int64(i)\n \t\tapT[2*i].f = f\n-\t\tm := M{i: i+1}\n+\t\tm := M{i: i + 1}\n \t\tmib[i] = (i != 0)\n-\t\tmii[i] = 10*i\n-\t\tmfi[float(i)] = 10*i\n-\t\tmif[i] = 10.0*f\n+\t\tmii[i] = 10 * i\n+\t\tmfi[float32(i)] = 10 * i\n+\t\tmif[i] = 10.0 * f\n \t\tmis[i] = s\n \t\tmsi[s] = i\n \t\tmss[s] = s10\n \t\tmss[s] = s10\n \t\tas := make([]string, 2)\n-\t\t\tas[0] = s10\n-\t\t\tas[1] = s10\n+\t\tas[0] = s10\n+\t\tas[1] = s10\n \t\tmspa[s] = as\n \t\tmipT[i] = apT[i]\n \t\tmpTi[apT[i]] = i\n \t\tmipM[i] = m\n \t\tmit[i] = t\n-\t//\tmti[t] = i\n+\t\t//\tmti[t] = i\n \t}\n \n \t// test len\n@@ -121,41 +121,41 @@ func main() {\n \tif len(mpTi) != count {\n \t\tfmt.Printf(\"len(mpTi) = %d\\n\", len(mpTi))\n \t}\n-//\tif len(mti) != count {\n-//\t\tfmt.Printf(\"len(mti) = %d\\n\", len(mti))\n-//\t}\n+\t//\tif len(mti) != count {\n+\t//\t\tfmt.Printf(\"len(mti) = %d\\n\", len(mti))\n+\t//\t}\n \tif len(mipM) != count {\n \t\tfmt.Printf(\"len(mipM) = %d\\n\", len(mipM))\n \t}\n-//\tif len(mti) != count {\n-//\t\tfmt.Printf(\"len(mti) = %d\\n\", len(mti))\n-//\t}\n+\t//\tif len(mti) != count {\n+\t//\t\tfmt.Printf(\"len(mti) = %d\\n\", len(mti))\n+\t//\t}\n \tif len(mit) != count {\n \t\tfmt.Printf(\"len(mit) = %d\\n\", len(mit))\n \t}\n \n \t// test construction directly\n \tfor i := 0; i < count; i++ {\n \t\ts := strconv.Itoa(i)\n-\t\ts10 := strconv.Itoa(i*10)\n-\t\tf := float(i)\n+\t\ts10 := strconv.Itoa(i * 10)\n+\t\tf := float32(i)\n \t\t// BUG m := M(i, i+1)\n \t\tif mib[i] != (i != 0) {\n \t\t\tfmt.Printf(\"mib[%d] = %t\\n\", i, mib[i])\n \t\t}\n-\t\tif(mii[i] != 10*i) {\n+\t\tif mii[i] != 10*i {\n \t\t\tfmt.Printf(\"mii[%d] = %d\\n\", i, mii[i])\n \t\t}\n-\t\tif(mfi[f] != 10*i) {\n+\t\tif mfi[f] != 10*i {\n \t\t\tfmt.Printf(\"mfi[%d] = %d\\n\", i, mfi[f])\n \t\t}\n-\t\tif(mif[i] != 10.0*f) {\n+\t\tif mif[i] != 10.0*f {\n \t\t\tfmt.Printf(\"mif[%d] = %g\\n\", i, mif[i])\n \t\t}\n-\t\tif(mis[i] != s) {\n+\t\tif mis[i] != s {\n \t\t\tfmt.Printf(\"mis[%d] = %s\\n\", i, mis[i])\n \t\t}\n-\t\tif(msi[s] != i) {\n+\t\tif msi[s] != i {\n \t\t\tfmt.Printf(\"msi[%s] = %d\\n\", s, msi[s])\n \t\t}\n \t\tif mss[s] != s10 {\n@@ -166,22 +166,22 @@ func main() {\n \t\t\t\tfmt.Printf(\"mspa[%s][%d] = %s\\n\", s, j, mspa[s][j])\n \t\t\t}\n \t\t}\n-\t\tif(mipT[i].i != int64(i) || mipT[i].f != f) {\n+\t\tif mipT[i].i != int64(i) || mipT[i].f != f {\n \t\t\tfmt.Printf(\"mipT[%d] = %v\\n\", i, mipT[i])\n \t\t}\n-\t\tif(mpTi[apT[i]] != i) {\n+\t\tif mpTi[apT[i]] != i {\n \t\t\tfmt.Printf(\"mpTi[apT[%d]] = %d\\n\", i, mpTi[apT[i]])\n \t\t}\n-\t//\tif(mti[t] != i) {\n-\t//\t\tfmt.Printf(\"mti[%s] = %s\\n\", s, mti[t])\n-\t//\t}\n-\t\tif (mipM[i][i] != i + 1) {\n+\t\t//\tif(mti[t] != i) {\n+\t\t//\t\tfmt.Printf(\"mti[%s] = %s\\n\", s, mti[t])\n+\t\t//\t}\n+\t\tif mipM[i][i] != i+1 {\n \t\t\tfmt.Printf(\"mipM[%d][%d] = %d\\n\", i, i, mipM[i][i])\n \t\t}\n-\t//\tif(mti[t] != i) {\n-\t//\t\tfmt.Printf(\"mti[%v] = %d\\n\", t, mti[t])\n-\t//\t}\n-\t\tif(mit[i].i != int64(i) || mit[i].f != f) {\n+\t\t//\tif(mti[t] != i) {\n+\t\t//\t\tfmt.Printf(\"mti[%v] = %d\\n\", t, mti[t])\n+\t\t//\t}\n+\t\tif mit[i].i != int64(i) || mit[i].f != f {\n \t\t\tfmt.Printf(\"mit[%d] = {%d %g}\\n\", i, mit[i].i, mit[i].f)\n \t\t}\n \t}\n@@ -190,7 +190,7 @@ func main() {\n \t// failed lookups yield a false value for the boolean.\n \tfor i := 0; i < count; i++ {\n \t\ts := strconv.Itoa(i)\n-\t\tf := float(i)\n+\t\tf := float32(i)\n \t\t{\n \t\t\t_, b := mib[i]\n \t\t\tif !b {\n@@ -311,23 +311,23 @@ func main() {\n \t\t\t\tfmt.Printf(\"tuple existence assign: mit[%d]\\n\", i)\n \t\t\t}\n \t\t}\n-//\t\t{\n-//\t\t\t_, b := mti[t]\n-//\t\t\tif !b {\n-//\t\t\t\tfmt.Printf(\"tuple existence decl: mti[%d]\\n\", i)\n-//\t\t\t}\n-//\t\t\t_, b = mti[t]\n-//\t\t\tif !b {\n-//\t\t\t\tfmt.Printf(\"tuple existence assign: mti[%d]\\n\", i)\n-//\t\t\t}\n-//\t\t}\n+\t\t//\t\t{\n+\t\t//\t\t\t_, b := mti[t]\n+\t\t//\t\t\tif !b {\n+\t\t//\t\t\t\tfmt.Printf(\"tuple existence decl: mti[%d]\\n\", i)\n+\t\t//\t\t\t}\n+\t\t//\t\t\t_, b = mti[t]\n+\t\t//\t\t\tif !b {\n+\t\t//\t\t\t\tfmt.Printf(\"tuple existence assign: mti[%d]\\n\", i)\n+\t\t//\t\t\t}\n+\t\t//\t\t}\n \t}\n \n \t// test nonexistence with tuple check\n \t// failed lookups yield a false value for the boolean.\n \tfor i := count; i < 2*count; i++ {\n \t\ts := strconv.Itoa(i)\n-\t\tf := float(i)\n+\t\tf := float32(i)\n \t\t{\n \t\t\t_, b := mib[i]\n \t\t\tif b {\n@@ -438,16 +438,16 @@ func main() {\n \t\t\t\tfmt.Printf(\"tuple nonexistence assign: mipM[%d]\", i)\n \t\t\t}\n \t\t}\n-//\t\t{\n-//\t\t\t_, b := mti[t]\n-//\t\t\tif b {\n-//\t\t\t\tfmt.Printf(\"tuple nonexistence decl: mti[%d]\", i)\n-//\t\t\t}\n-//\t\t\t_, b = mti[t]\n-//\t\t\tif b {\n-//\t\t\t\tfmt.Printf(\"tuple nonexistence assign: mti[%d]\", i)\n-//\t\t\t}\n-//\t\t}\n+\t\t//\t\t{\n+\t\t//\t\t\t_, b := mti[t]\n+\t\t//\t\t\tif b {\n+\t\t//\t\t\t\tfmt.Printf(\"tuple nonexistence decl: mti[%d]\", i)\n+\t\t//\t\t\t}\n+\t\t//\t\t\t_, b = mti[t]\n+\t\t//\t\t\tif b {\n+\t\t//\t\t\t\tfmt.Printf(\"tuple nonexistence assign: mti[%d]\", i)\n+\t\t//\t\t\t}\n+\t\t//\t\t}\n \t\t{\n \t\t\t_, b := mit[i]\n \t\t\tif b {\n@@ -460,32 +460,31 @@ func main() {\n \t\t}\n \t}\n \n-\n \t// tests for structured map element updates\n \tfor i := 0; i < count; i++ {\n \t\ts := strconv.Itoa(i)\n-\t\tmspa[s][i % 2] = \"deleted\"\n-\t\tif mspa[s][i % 2] != \"deleted\" {\n-\t\t\tfmt.Printf(\"update mspa[%s][%d] = %s\\n\", s, i %2, mspa[s][i % 2])\n+\t\tmspa[s][i%2] = \"deleted\"\n+\t\tif mspa[s][i%2] != \"deleted\" {\n+\t\t\tfmt.Printf(\"update mspa[%s][%d] = %s\\n\", s, i%2, mspa[s][i%2])\n \t\t}\n \n \t\tmipT[i].i += 1\n \t\tif mipT[i].i != int64(i)+1 {\n \t\t\tfmt.Printf(\"update mipT[%d].i = %d\\n\", i, mipT[i].i)\n \t\t}\n-\t\tmipT[i].f = float(i + 1)\n-\t\tif (mipT[i].f != float(i + 1)) {\n+\t\tmipT[i].f = float32(i + 1)\n+\t\tif mipT[i].f != float32(i+1) {\n \t\t\tfmt.Printf(\"update mipT[%d].f = %g\\n\", i, mipT[i].f)\n \t\t}\n \n \t\tmipM[i][i]++\n-\t\tif mipM[i][i] != (i + 1) + 1 {\n+\t\tif mipM[i][i] != (i+1)+1 {\n \t\t\tfmt.Printf(\"update mipM[%d][%d] = %i\\n\", i, i, mipM[i][i])\n \t\t}\n \t}\n \n \t// test range on nil map\n-\tvar mnil map[string] int\n+\tvar mnil map[string]int\n \tfor _, _ = range mnil {\n \t\tpanic(\"range mnil\")\n \t}"}, {"sha": "ec14ef9e4f4549602c138a14da48f3ec0b1d2c0f", "filename": "gcc/testsuite/go.test/test/method1.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fmethod1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fmethod1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fmethod1.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -8,10 +8,10 @@ package main\n \n type T struct { }\n func (t *T) M(int, string)\t// GCCGO_ERROR \"previous\"\n-func (t *T) M(int, float) { }   // ERROR \"redeclared|redefinition\"\n+func (t *T) M(int, float64) { }   // ERROR \"redeclared|redefinition\"\n \n func f(int, string)\t// GCCGO_ERROR \"previous\"\n-func f(int, float) { }  // ERROR \"redeclared|redefinition\"\n+func f(int, float64) { }  // ERROR \"redeclared|redefinition\"\n \n func g(a int, b string)  // GCCGO_ERROR \"previous\"\n func g(a int, c string)  // ERROR \"redeclared|redefinition\""}, {"sha": "5b6bb81fe342c1905f8e53c768ce90215273ad9b", "filename": "gcc/testsuite/go.test/test/named.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fnamed.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fnamed.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fnamed.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -12,7 +12,7 @@ package main\n type Array [10]byte\n type Bool bool\n type Chan chan int\n-type Float float\n+type Float float32\n type Int int\n type Map map[int]byte\n type Slice []byte"}, {"sha": "4f4c75527606d5ad0d7c34d1127cdc8a41aa5e0c", "filename": "gcc/testsuite/go.test/test/nil.go", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fnil.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fnil.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fnil.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -10,14 +10,13 @@ type T struct {\n \ti int\n }\n \n-type IN interface {\n-}\n+type IN interface{}\n \n func main() {\n \tvar i *int\n-\tvar f *float\n+\tvar f *float32\n \tvar s *string\n-\tvar m map[float] *int\n+\tvar m map[float32]*int\n \tvar c chan int\n \tvar t *T\n \tvar in IN"}, {"sha": "9affe25d47acf8b129af03aad933ef2bae2bbfa7", "filename": "gcc/testsuite/go.test/test/recover2.go", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Frecover2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Frecover2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Frecover2.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -7,15 +7,13 @@\n // Test of recover for run-time errors.\n \n // TODO(rsc):\n-//\tinteger divide by zero?\n //\tnull pointer accesses\n \n package main\n \n import (\n \t\"os\"\n \t\"strings\"\n-\t\"syscall\"\n )\n \n var x = make([]byte, 10)\n@@ -60,7 +58,7 @@ func test3() {\n func test4() {\n \tdefer mustRecover(\"interface\")\n \tvar x interface{} = 1\n-\tprintln(x.(float))\n+\tprintln(x.(float32))\n }\n \n type T struct {\n@@ -83,10 +81,6 @@ func test6() {\n }\n \n func test7() {\n-\tif syscall.ARCH == \"arm\" || syscall.OS == \"nacl\" {\n-\t\t// ARM doesn't have integer divide trap yet\n-\t\treturn\n-\t}\n \tdefer mustRecover(\"divide by zero\")\n \tvar x, y int\n \tprintln(x / y)"}, {"sha": "d8d86c427937955afc6009b09105592038f7a83d", "filename": "gcc/testsuite/go.test/test/test0.go", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ftest0.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ftest0.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ftest0.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -6,20 +6,19 @@\n \n package main\n \n-const\n-\ta_const = 0\n+const a_const = 0\n \n const (\n-\tpi = /* the usual */ 3.14159265358979323\n-\te = 2.718281828\n+\tpi    = /* the usual */ 3.14159265358979323\n+\te     = 2.718281828\n \tmask1 int = 1 << iota\n \tmask2 = 1 << iota\n \tmask3 = 1 << iota\n \tmask4 = 1 << iota\n )\n \n type (\n-\tEmpty interface {}\n+\tEmpty interface{}\n \tPoint struct {\n \t\tx, y int\n \t}\n@@ -32,19 +31,21 @@ func (p *Point) Initialize(x, y int) *Point {\n }\n \n func (p *Point) Distance() int {\n-\treturn p.x * p.x + p.y * p.y\n+\treturn p.x*p.x + p.y*p.y\n }\n \n var (\n-\tx1 int\n-\tx2 int\n-\tu, v, w float\n+\tx1      int\n+\tx2      int\n+\tu, v, w float32\n )\n \n func foo() {}\n \n func min(x, y int) int {\n-\tif x < y { return x; }\n+\tif x < y {\n+\t\treturn x\n+\t}\n \treturn y\n }\n \n@@ -57,24 +58,29 @@ func swap(x, y int) (u, v int) {\n func control_structs() {\n \tvar p *Point = new(Point).Initialize(2, 3)\n \ti := p.Distance()\n-\tvar f float = 0.3\n+\tvar f float32 = 0.3\n \t_ = f\n-\tfor {}\n-\tfor {}\n+\tfor {\n+\t}\n+\tfor {\n+\t}\n \tfor j := 0; j < i; j++ {\n \t\tif i == 0 {\n-\t\t} else i = 0\n-\t\tvar x float\n+\t\t} else {\n+\t\t\ti = 0\n+\t\t}\n+\t\tvar x float32\n \t\t_ = x\n \t}\n-\tfoo:\t// a label\n+foo: // a label\n \tvar j int\n \tswitch y := 0; true {\n \tcase i < y:\n \t\tfallthrough\n \tcase i < j:\n \tcase i == 0, i == 1, i == j:\n-\t\ti++; i++\n+\t\ti++\n+\t\ti++\n \t\tgoto foo\n \tdefault:\n \t\ti = -+-+i"}, {"sha": "83fb0985a91e1a9eaf00b21c9df9c149ee9540de", "filename": "gcc/testsuite/go.test/test/typeswitch.go", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ftypeswitch.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ftypeswitch.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ftypeswitch.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -21,12 +21,15 @@ const (\n \tLast\n )\n \n-type S struct { a int }\n+type S struct {\n+\ta int\n+}\n+\n var s S = S{1234}\n \n var c = make(chan int)\n \n-var a\t= []int{0,1,2,3}\n+var a = []int{0, 1, 2, 3}\n \n var m = make(map[string]int)\n \n@@ -68,10 +71,10 @@ func main() {\n \t\t\tassert(x == true && i == Bool, \"bool\")\n \t\tcase int:\n \t\t\tassert(x == 7 && i == Int, \"int\")\n-\t\tcase float:\n-\t\t\tassert(x == 7.4 && i == Float, \"float\")\n+\t\tcase float64:\n+\t\t\tassert(x == 7.4 && i == Float, \"float64\")\n \t\tcase string:\n-\t\t\tassert(x == \"hello\"&& i == String, \"string\")\n+\t\t\tassert(x == \"hello\" && i == String, \"string\")\n \t\tcase S:\n \t\t\tassert(x.a == 1234 && i == Struct, \"struct\")\n \t\tcase chan int:"}, {"sha": "1948528d2450a36278ab128095ca13f4d407de48", "filename": "gcc/testsuite/go.test/test/zerodivide.go", "status": "modified", "additions": 120, "deletions": 87, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fzerodivide.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fzerodivide.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fzerodivide.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -10,64 +10,97 @@ import (\n \t\"fmt\"\n \t\"math\"\n \t\"strings\"\n-\t\"syscall\"\n )\n \n type Error interface {\n \tString() string\n }\n \n type ErrorTest struct {\n-\tname\tstring\n-\tfn\tfunc()\n-\terr\tstring\n+\tname string\n+\tfn   func()\n+\terr  string\n }\n \n var (\n-\ti, j, k int = 0, 0, 1\n-\ti8, j8, k8 int8 = 0, 0, 1\n+\ti, j, k       int   = 0, 0, 1\n+\ti8, j8, k8    int8  = 0, 0, 1\n \ti16, j16, k16 int16 = 0, 0, 1\n \ti32, j32, k32 int32 = 0, 0, 1\n \ti64, j64, k64 int64 = 0, 0, 1\n \n-\tu, v, w uint = 0, 0, 1\n-\tu8, v8, w8 uint8 = 0, 0, 1\n-\tu16, v16, w16 uint16 = 0, 0, 1\n-\tu32, v32, w32 uint32 = 0, 0, 1\n-\tu64, v64, w64 uint64 = 0, 0, 1\n-\tup, vp, wp uintptr = 0, 0, 1\n+\tu, v, w       uint    = 0, 0, 1\n+\tu8, v8, w8    uint8   = 0, 0, 1\n+\tu16, v16, w16 uint16  = 0, 0, 1\n+\tu32, v32, w32 uint32  = 0, 0, 1\n+\tu64, v64, w64 uint64  = 0, 0, 1\n+\tup, vp, wp    uintptr = 0, 0, 1\n \n-\tf, g, h float = 0, 0, 1\n-\tf32, g32, h32 float32 = 0, 0, 1\n+\tf, g, h                         float64 = 0, 0, 1\n+\tf32, g32, h32                   float32 = 0, 0, 1\n \tf64, g64, h64, inf, negInf, nan float64 = 0, 0, 1, math.Inf(1), math.Inf(-1), math.NaN()\n \n-\tc, d, e complex = 0+0i, 0+0i, 1+1i\n-\tc64, d64, e64 complex64 = 0+0i, 0+0i, 1+1i\n-\tc128, d128, e128 complex128 = 0+0i, 0+0i, 1+1i\n+\tc, d, e          complex128 = 0 + 0i, 0 + 0i, 1 + 1i\n+\tc64, d64, e64    complex64  = 0 + 0i, 0 + 0i, 1 + 1i\n+\tc128, d128, e128 complex128 = 0 + 0i, 0 + 0i, 1 + 1i\n )\n \n // Fool gccgo into thinking that these variables can change.\n func NotCalled() {\n-\ti++; j++; k++\n-\ti8++; j8++; k8++\n-\ti16++; j16++; k16++\n-\ti32++; j32++; k32++\n-\ti64++; j64++; k64++\n-\n-\tu++; v++; w++\n-\tu8++; v8++; w8++\n-\tu16++; v16++; w16++\n-\tu32++; v32++; w32++\n-\tu64++; v64++; w64++\n-\tup++; vp++; wp++\n-\n-\tf += 1; g += 1; h += 1\n-\tf32 += 1; g32 += 1; h32 += 1\n-\tf64 += 1; g64 += 1; h64 += 1\n-\n-\tc += 1+1i; d += 1+1i; e += 1+1i\n-\tc64 += 1+1i; d64 += 1+1i; e64 += 1+1i\n-\tc128 += 1+1i; d128 += 1+1i; e128 += 1+1i\n+\ti++\n+\tj++\n+\tk++\n+\ti8++\n+\tj8++\n+\tk8++\n+\ti16++\n+\tj16++\n+\tk16++\n+\ti32++\n+\tj32++\n+\tk32++\n+\ti64++\n+\tj64++\n+\tk64++\n+\n+\tu++\n+\tv++\n+\tw++\n+\tu8++\n+\tv8++\n+\tw8++\n+\tu16++\n+\tv16++\n+\tw16++\n+\tu32++\n+\tv32++\n+\tw32++\n+\tu64++\n+\tv64++\n+\tw64++\n+\tup++\n+\tvp++\n+\twp++\n+\n+\tf += 1\n+\tg += 1\n+\th += 1\n+\tf32 += 1\n+\tg32 += 1\n+\th32 += 1\n+\tf64 += 1\n+\tg64 += 1\n+\th64 += 1\n+\n+\tc += 1 + 1i\n+\td += 1 + 1i\n+\te += 1 + 1i\n+\tc64 += 1 + 1i\n+\td64 += 1 + 1i\n+\te64 += 1 + 1i\n+\tc128 += 1 + 1i\n+\td128 += 1 + 1i\n+\te128 += 1 + 1i\n }\n \n var tmp interface{}\n@@ -80,52 +113,52 @@ func use(v interface{}) {\n // Verify error/no error for all types.\n var errorTests = []ErrorTest{\n \t// All integer divide by zero should error.\n-\tErrorTest{ \"int 0/0\", func() { use(i/j) }, \"divide\", },\n-\tErrorTest{ \"int8 0/0\", func() { use(i8/j8) }, \"divide\", },\n-\tErrorTest{ \"int16 0/0\", func() { use(i16/j16) }, \"divide\", },\n-\tErrorTest{ \"int32 0/0\", func() { use(i32/j32) }, \"divide\", },\n-\tErrorTest{ \"int64 0/0\", func() { use(i64/j64) }, \"divide\", },\n-\n-\tErrorTest{ \"int 1/0\", func() { use(k/j) }, \"divide\", },\n-\tErrorTest{ \"int8 1/0\", func() { use(k8/j8) }, \"divide\", },\n-\tErrorTest{ \"int16 1/0\", func() { use(k16/j16) }, \"divide\", },\n-\tErrorTest{ \"int32 1/0\", func() { use(k32/j32) }, \"divide\", },\n-\tErrorTest{ \"int64 1/0\", func() { use(k64/j64) }, \"divide\", },\n-\n-\tErrorTest{ \"uint 0/0\", func() { use(u/v) }, \"divide\", },\n-\tErrorTest{ \"uint8 0/0\", func() { use(u8/v8) }, \"divide\", },\n-\tErrorTest{ \"uint16 0/0\", func() { use(u16/v16) }, \"divide\", },\n-\tErrorTest{ \"uint32 0/0\", func() { use(u32/v32) }, \"divide\", },\n-\tErrorTest{ \"uint64 0/0\", func() { use(u64/v64) }, \"divide\", },\n-\tErrorTest{ \"uintptr 0/0\", func() { use(up/vp) }, \"divide\", },\n-\n-\tErrorTest{ \"uint 1/0\", func() { use(w/v) }, \"divide\", },\n-\tErrorTest{ \"uint8 1/0\", func() { use(w8/v8) }, \"divide\", },\n-\tErrorTest{ \"uint16 1/0\", func() { use(w16/v16) }, \"divide\", },\n-\tErrorTest{ \"uint32 1/0\", func() { use(w32/v32) }, \"divide\", },\n-\tErrorTest{ \"uint64 1/0\", func() { use(w64/v64) }, \"divide\", },\n-\tErrorTest{ \"uintptr 1/0\", func() { use(wp/vp) }, \"divide\", },\n-\n-\t// All floating divide by zero should not error.\n-\tErrorTest{ \"float 0/0\", func() { use(f/g) }, \"\", },\n-\tErrorTest{ \"float32 0/0\", func() { use(f32/g32) }, \"\", },\n-\tErrorTest{ \"float64 0/0\", func() { use(f64/g64) }, \"\", },\n-\n-\tErrorTest{ \"float 1/0\", func() { use(h/g) }, \"\", },\n-\tErrorTest{ \"float32 1/0\", func() { use(h32/g32) }, \"\", },\n-\tErrorTest{ \"float64 1/0\", func() { use(h64/g64) }, \"\", },\n-\tErrorTest{ \"float64 inf/0\", func() { use(inf/g64) }, \"\", },\n-\tErrorTest{ \"float64 -inf/0\", func() { use(negInf/g64) }, \"\", },\n-\tErrorTest{ \"float64 nan/0\", func() { use(nan/g64) }, \"\", },\n+\tErrorTest{\"int 0/0\", func() { use(i / j) }, \"divide\"},\n+\tErrorTest{\"int8 0/0\", func() { use(i8 / j8) }, \"divide\"},\n+\tErrorTest{\"int16 0/0\", func() { use(i16 / j16) }, \"divide\"},\n+\tErrorTest{\"int32 0/0\", func() { use(i32 / j32) }, \"divide\"},\n+\tErrorTest{\"int64 0/0\", func() { use(i64 / j64) }, \"divide\"},\n+\n+\tErrorTest{\"int 1/0\", func() { use(k / j) }, \"divide\"},\n+\tErrorTest{\"int8 1/0\", func() { use(k8 / j8) }, \"divide\"},\n+\tErrorTest{\"int16 1/0\", func() { use(k16 / j16) }, \"divide\"},\n+\tErrorTest{\"int32 1/0\", func() { use(k32 / j32) }, \"divide\"},\n+\tErrorTest{\"int64 1/0\", func() { use(k64 / j64) }, \"divide\"},\n+\n+\tErrorTest{\"uint 0/0\", func() { use(u / v) }, \"divide\"},\n+\tErrorTest{\"uint8 0/0\", func() { use(u8 / v8) }, \"divide\"},\n+\tErrorTest{\"uint16 0/0\", func() { use(u16 / v16) }, \"divide\"},\n+\tErrorTest{\"uint32 0/0\", func() { use(u32 / v32) }, \"divide\"},\n+\tErrorTest{\"uint64 0/0\", func() { use(u64 / v64) }, \"divide\"},\n+\tErrorTest{\"uintptr 0/0\", func() { use(up / vp) }, \"divide\"},\n+\n+\tErrorTest{\"uint 1/0\", func() { use(w / v) }, \"divide\"},\n+\tErrorTest{\"uint8 1/0\", func() { use(w8 / v8) }, \"divide\"},\n+\tErrorTest{\"uint16 1/0\", func() { use(w16 / v16) }, \"divide\"},\n+\tErrorTest{\"uint32 1/0\", func() { use(w32 / v32) }, \"divide\"},\n+\tErrorTest{\"uint64 1/0\", func() { use(w64 / v64) }, \"divide\"},\n+\tErrorTest{\"uintptr 1/0\", func() { use(wp / vp) }, \"divide\"},\n+\n+\t// All float64ing divide by zero should not error.\n+\tErrorTest{\"float64 0/0\", func() { use(f / g) }, \"\"},\n+\tErrorTest{\"float32 0/0\", func() { use(f32 / g32) }, \"\"},\n+\tErrorTest{\"float64 0/0\", func() { use(f64 / g64) }, \"\"},\n+\n+\tErrorTest{\"float64 1/0\", func() { use(h / g) }, \"\"},\n+\tErrorTest{\"float32 1/0\", func() { use(h32 / g32) }, \"\"},\n+\tErrorTest{\"float64 1/0\", func() { use(h64 / g64) }, \"\"},\n+\tErrorTest{\"float64 inf/0\", func() { use(inf / g64) }, \"\"},\n+\tErrorTest{\"float64 -inf/0\", func() { use(negInf / g64) }, \"\"},\n+\tErrorTest{\"float64 nan/0\", func() { use(nan / g64) }, \"\"},\n \n \t// All complex divide by zero should not error.\n-\tErrorTest{ \"complex 0/0\", func() { use(c/d) }, \"\", },\n-\tErrorTest{ \"complex64 0/0\", func() { use(c64/d64) }, \"\", },\n-\tErrorTest{ \"complex128 0/0\", func() { use(c128/d128) }, \"\", },\n+\tErrorTest{\"complex 0/0\", func() { use(c / d) }, \"\"},\n+\tErrorTest{\"complex64 0/0\", func() { use(c64 / d64) }, \"\"},\n+\tErrorTest{\"complex128 0/0\", func() { use(c128 / d128) }, \"\"},\n \n-\tErrorTest{ \"complex 1/0\", func() { use(e/d) }, \"\", },\n-\tErrorTest{ \"complex64 1/0\", func() { use(e64/d64) }, \"\", },\n-\tErrorTest{ \"complex128 1/0\", func() { use(e128/d128) }, \"\", },\n+\tErrorTest{\"complex 1/0\", func() { use(e / d) }, \"\"},\n+\tErrorTest{\"complex64 1/0\", func() { use(e64 / d64) }, \"\"},\n+\tErrorTest{\"complex128 1/0\", func() { use(e128 / d128) }, \"\"},\n }\n \n func error(fn func()) (error string) {\n@@ -138,12 +171,12 @@ func error(fn func()) (error string) {\n \treturn \"\"\n }\n \n-type FloatTest struct{\n-\tf, g\tfloat64\n-\tout\tfloat64\n+type FloatTest struct {\n+\tf, g float64\n+\tout  float64\n }\n \n-var floatTests = []FloatTest{\n+var float64Tests = []FloatTest{\n \tFloatTest{0, 0, nan},\n \tFloatTest{nan, 0, nan},\n \tFloatTest{inf, 0, inf},\n@@ -163,7 +196,7 @@ func alike(a, b float64) bool {\n func main() {\n \tbad := false\n \tfor _, t := range errorTests {\n-\t\tif t.err != \"\" && syscall.OS == \"nacl\" {\n+\t\tif t.err != \"\" {\n \t\t\tcontinue\n \t\t}\n \t\terr := error(t.fn)\n@@ -195,8 +228,8 @@ func main() {\n \t}\n \n \t// At this point we know we don't error on the values we're testing\n-\tfor _, t := range floatTests {\n-\t\tx := t.f/t.g\n+\tfor _, t := range float64Tests {\n+\t\tx := t.f / t.g\n \t\tif !alike(x, t.out) {\n \t\t\tif !bad {\n \t\t\t\tbad = true"}, {"sha": "97e6655a625f9e3a3220bcf85846c56cc7ee005b", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -1,4 +1,4 @@\n-b547c5b04a18\n+559f12e8fcd5\n \n The first line of this file holds the Mercurial revision number of the\n last merge done from the master library sources."}, {"sha": "254a8058d27fdb126f23e509841c393165069905", "filename": "libgo/Makefile.am", "status": "modified", "additions": 222, "deletions": 19, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -177,6 +177,8 @@ toolexeclibgocrypto_DATA = \\\n \tcrypto/block.gox \\\n \tcrypto/blowfish.gox \\\n \tcrypto/cast5.gox \\\n+\tcrypto/cipher.gox \\\n+\tcrypto/elliptic.gox \\\n \tcrypto/hmac.gox \\\n \tcrypto/md4.gox \\\n \tcrypto/md5.gox \\\n@@ -190,9 +192,17 @@ toolexeclibgocrypto_DATA = \\\n \tcrypto/sha512.gox \\\n \tcrypto/subtle.gox \\\n \tcrypto/tls.gox \\\n+\tcrypto/twofish.gox \\\n \tcrypto/x509.gox \\\n \tcrypto/xtea.gox\n \n+toolexeclibgocryptoopenpgpdir = $(toolexeclibgocryptodir)/openpgp\n+\n+toolexeclibgocryptoopenpgp_DATA = \\\n+\tcrypto/openpgp/armor.gox \\\n+\tcrypto/openpgp/error.gox \\\n+\tcrypto/openpgp/s2k.gox\n+\n toolexeclibgodebugdir = $(toolexeclibgodir)/debug\n \n toolexeclibgodebug_DATA = \\\n@@ -207,8 +217,10 @@ toolexeclibgoencodingdir = $(toolexeclibgodir)/encoding\n \n toolexeclibgoencoding_DATA = \\\n \tencoding/ascii85.gox \\\n+\tencoding/base32.gox \\\n \tencoding/base64.gox \\\n \tencoding/binary.gox \\\n+\tencoding/line.gox \\\n \tencoding/git85.gox \\\n \tencoding/hex.gox \\\n \tencoding/pem.gox\n@@ -272,7 +284,15 @@ toolexeclibgonet_DATA = \\\n \n toolexeclibgoosdir = $(toolexeclibgodir)/os\n \n+if LIBGO_IS_LINUX\n+# os_inotify_gox = os/inotify.gox\n+os_inotify_gox =\n+else\n+os_inotify_gox =\n+endif\n+\n toolexeclibgoos_DATA = \\\n+\t$(os_inotify_gox) \\\n \tos/signal.gox\n \n toolexeclibgorpcdir = $(toolexeclibgodir)/rpc\n@@ -283,6 +303,7 @@ toolexeclibgorpc_DATA = \\\n toolexeclibgoruntimedir = $(toolexeclibgodir)/runtime\n \n toolexeclibgoruntime_DATA = \\\n+\truntime/debug.gox \\\n \truntime/pprof.gox\n \n toolexeclibgotestingdir = $(toolexeclibgodir)/testing\n@@ -503,6 +524,7 @@ go_html_files = \\\n \tgo/html/doc.go \\\n \tgo/html/entity.go \\\n \tgo/html/escape.go \\\n+\tgo/html/parse.go \\\n \tgo/html/token.go\n \n go_http_files = \\\n@@ -554,6 +576,7 @@ go_math_files = \\\n \tgo/math/copysign.go \\\n \tgo/math/erf.go \\\n \tgo/math/exp.go \\\n+\tgo/math/exp_port.go \\\n \tgo/math/exp2.go \\\n \tgo/math/expm1.go \\\n \tgo/math/fabs.go \\\n@@ -658,7 +681,8 @@ go_patch_files = \\\n \n go_path_files = \\\n \tgo/path/match.go \\\n-\tgo/path/path.go\n+\tgo/path/path.go \\\n+\tgo/path/path_unix.go\n \n go_rand_files = \\\n \tgo/rand/exp.go \\\n@@ -684,6 +708,8 @@ go_runtime_files = \\\n \tgo/runtime/debug.go \\\n \tgo/runtime/error.go \\\n \tgo/runtime/extern.go \\\n+\tgo/runtime/malloc_defs.go \\\n+\tgo/runtime/runtime_defs.go \\\n \tgo/runtime/sig.go \\\n \tgo/runtime/softfloat64.go \\\n \tgo/runtime/type.go \\\n@@ -708,6 +734,7 @@ go_smtp_files = \\\n \tgo/smtp/smtp.go\n \n go_sort_files = \\\n+\tgo/sort/search.go \\\n \tgo/sort/sort.go\n \n go_strconv_files = \\\n@@ -837,6 +864,16 @@ go_crypto_blowfish_files = \\\n \tgo/crypto/blowfish/cipher.go\n go_crypto_cast5_files = \\\n \tgo/crypto/cast5/cast5.go\n+go_crypto_cipher_files = \\\n+\tgo/crypto/cipher/cbc.go \\\n+\tgo/crypto/cipher/cfb.go \\\n+\tgo/crypto/cipher/cipher.go \\\n+\tgo/crypto/cipher/ctr.go \\\n+\tgo/crypto/cipher/io.go \\\n+\tgo/crypto/cipher/ocfb.go \\\n+\tgo/crypto/cipher/ofb.go\n+go_crypto_elliptic_files = \\\n+\tgo/crypto/elliptic/elliptic.go\n go_crypto_hmac_files = \\\n \tgo/crypto/hmac/hmac.go\n go_crypto_md4_files = \\\n@@ -872,19 +909,31 @@ go_crypto_subtle_files = \\\n go_crypto_tls_files = \\\n \tgo/crypto/tls/alert.go \\\n \tgo/crypto/tls/ca_set.go \\\n+\tgo/crypto/tls/cipher_suites.go \\\n \tgo/crypto/tls/common.go \\\n \tgo/crypto/tls/conn.go \\\n \tgo/crypto/tls/handshake_client.go \\\n \tgo/crypto/tls/handshake_messages.go \\\n \tgo/crypto/tls/handshake_server.go \\\n+\tgo/crypto/tls/key_agreement.go \\\n \tgo/crypto/tls/prf.go \\\n \tgo/crypto/tls/tls.go\n+go_crypto_twofish_files = \\\n+\tgo/crypto/twofish/twofish.go\n go_crypto_x509_files = \\\n \tgo/crypto/x509/x509.go\n go_crypto_xtea_files = \\\n \tgo/crypto/xtea/block.go \\\n \tgo/crypto/xtea/cipher.go\n \n+go_crypto_openpgp_armor_files = \\\n+\tgo/crypto/openpgp/armor/armor.go \\\n+\tgo/crypto/openpgp/armor/encode.go\n+go_crypto_openpgp_error_files = \\\n+\tgo/crypto/openpgp/error/error.go\n+go_crypto_openpgp_s2k_files = \\\n+\tgo/crypto/openpgp/s2k/s2k.go\n+\n go_debug_dwarf_files = \\\n \tgo/debug/dwarf/buf.go \\\n \tgo/debug/dwarf/const.go \\\n@@ -912,6 +961,8 @@ go_debug_proc_files = \\\n \n go_encoding_ascii85_files = \\\n \tgo/encoding/ascii85/ascii85.go\n+go_encoding_base32_files = \\\n+\tgo/encoding/base32/base32.go\n go_encoding_base64_files = \\\n \tgo/encoding/base64/base64.go\n go_encoding_binary_files = \\\n@@ -920,6 +971,8 @@ go_encoding_git85_files = \\\n \tgo/encoding/git85/git.go\n go_encoding_hex_files = \\\n \tgo/encoding/hex/hex.go\n+go_encoding_line_files = \\\n+\tgo/encoding/line/line.go\n go_encoding_pem_files = \\\n \tgo/encoding/pem/pem.go\n \n@@ -962,6 +1015,7 @@ go_go_scanner_files = \\\n \tgo/go/scanner/errors.go \\\n \tgo/go/scanner/scanner.go\n go_go_token_files = \\\n+\tgo/go/token/position.go \\\n \tgo/go/token/token.go\n go_go_typechecker_files = \\\n \tgo/go/typechecker/scope.go \\\n@@ -988,6 +1042,7 @@ go_image_png_files = \\\n \tgo/image/png/writer.go\n \n go_index_suffixarray_files = \\\n+\tgo/index/suffixarray/qsufsort.go \\\n \tgo/index/suffixarray/suffixarray.go\n \n go_io_ioutil_files = \\\n@@ -1006,6 +1061,9 @@ go_net_textproto_files = \\\n \tgo/net/textproto/textproto.go \\\n \tgo/net/textproto/writer.go\n \n+go_os_inotify_files = \\\n+\tgo/os/inotify/inotify_linux.go\n+\n go_os_signal_files = \\\n \tgo/os/signal/signal.go \\\n \tunix.go\n@@ -1014,6 +1072,8 @@ go_rpc_jsonrpc_files = \\\n \tgo/rpc/jsonrpc/client.go \\\n \tgo/rpc/jsonrpc/server.go\n \n+go_runtime_debug_files = \\\n+\tgo/runtime/debug/stack.go\n go_runtime_pprof_files = \\\n \tgo/runtime/pprof/pprof.go\n \n@@ -1136,6 +1196,13 @@ go_syscall_files = \\\n go_syscall_c_files = \\\n \tsyscalls/errno.c\n \n+if LIBGO_IS_LINUX\n+# os_lib_inotify_la = os/libinotify.la\n+os_lib_inotify_la =\n+else\n+os_lib_inotify_la =\n+endif\n+\n libgo_go_objs = \\\n \tasn1/libasn1.la \\\n \tbig/libbig.la \\\n@@ -1196,6 +1263,8 @@ libgo_go_objs = \\\n \tcrypto/libblock.la \\\n \tcrypto/libblowfish.la \\\n \tcrypto/libcast5.la \\\n+\tcrypto/libcipher.la \\\n+\tcrypto/libelliptic.la \\\n \tcrypto/libhmac.la \\\n \tcrypto/libmd4.la \\\n \tcrypto/libmd5.la \\\n@@ -1209,19 +1278,25 @@ libgo_go_objs = \\\n \tcrypto/libsha512.la \\\n \tcrypto/libsubtle.la \\\n \tcrypto/libtls.la \\\n+\tcrypto/libtwofish.la \\\n \tcrypto/libx509.la \\\n \tcrypto/libxtea.la \\\n+\tcrypto/openpgp/libarmor.la \\\n+\tcrypto/openpgp/liberror.la \\\n+\tcrypto/openpgp/libs2k.la \\\n \tdebug/libdwarf.la \\\n \tdebug/libelf.la \\\n \tdebug/libgosym.la \\\n \tdebug/libmacho.la \\\n \tdebug/libpe.la \\\n \tdebug/libproc.la \\\n \tencoding/libascii85.la \\\n+\tencoding/libbase32.la \\\n \tencoding/libbase64.la \\\n \tencoding/libbinary.la \\\n \tencoding/libgit85.la \\\n \tencoding/libhex.la \\\n+\tencoding/libline.la \\\n \tencoding/libpem.la \\\n \texp/libdatafmt.la \\\n \texp/libdraw.la \\\n@@ -1244,8 +1319,10 @@ libgo_go_objs = \\\n \tmime/libmultipart.la \\\n \tnet/libdict.la \\\n \tnet/libtextproto.la \\\n+\t$(os_lib_inotify_la) \\\n \tos/libsignal.la \\\n \trpc/libjsonrpc.la \\\n+\truntime/libdebug.la \\\n \truntime/libpprof.la \\\n \tsyscalls/libsyscall.la \\\n \ttesting/libtesting.la \\\n@@ -1418,7 +1495,8 @@ fmt/check: $(CHECK_DEPS)\n .PHONY: fmt/check\n \n gob/libgob.a: $(go_gob_files) bytes.gox fmt.gox io.gox math.gox os.gox \\\n-\t\treflect.gox runtime.gox strings.gox sync.gox unicode.gox\n+\t\treflect.gox runtime.gox strings.gox sync.gox unicode.gox \\\n+\t\tutf8.gox\n \t$(BUILDARCHIVE)\n gob/libgob.la: gob/libgob.a\n gob/check: $(CHECK_DEPS)\n@@ -1475,7 +1553,7 @@ json/check: $(CHECK_DEPS)\n .PHONY: json/check\n \n log/liblog.a: $(go_log_files) bytes.gox fmt.gox io.gox runtime.gox os.gox \\\n-\t\ttime.gox\n+\t\tsync.gox time.gox\n \t$(BUILDARCHIVE)\n log/liblog.la: log/liblog.a\n log/check: $(CHECK_DEPS)\n@@ -1497,16 +1575,16 @@ mime/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: mime/check\n \n-net/libnet.a: $(go_net_files) fmt.gox io.gox os.gox reflect.gox strconv.gox \\\n-\t\tstrings.gox sync.gox syscall.gox\n+net/libnet.a: $(go_net_files) bytes.gox fmt.gox io.gox os.gox reflect.gox \\\n+\t\tstrconv.gox strings.gox sync.gox syscall.gox\n \t$(BUILDARCHIVE)\n net/libnet.la: net/libnet.a\n net/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: net/check\n \n netchan/libnetchan.a: $(go_netchan_files) gob.gox log.gox net.gox os.gox \\\n-\t\treflect.gox sync.gox time.gox\n+\t\treflect.gox strconv.gox sync.gox time.gox\n \t$(BUILDARCHIVE)\n netchan/libnetchan.la: netchan/libnetchan.a\n netchan/check: $(CHECK_DEPS)\n@@ -1657,8 +1735,8 @@ testing/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: testing/check\n \n-time/libtime.a: $(go_time_files) bytes.gox io/ioutil.gox os.gox strconv.gox \\\n-\t\tsync.gox syscall.gox\n+time/libtime.a: $(go_time_files) bytes.gox container/heap.gox io/ioutil.gox \\\n+\t\tos.gox strconv.gox sync.gox syscall.gox\n \t$(BUILDARCHIVE)\n time/libtime.la: time/libtime.a\n time/check: $(CHECK_DEPS)\n@@ -1703,8 +1781,8 @@ websocket/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: websocket/check\n \n-xml/libxml.a: $(go_xml_files) bufio.gox bytes.gox io.gox os.gox reflect.gox \\\n-\t\tstrconv.gox strings.gox unicode.gox utf8.gox\n+xml/libxml.a: $(go_xml_files) bufio.gox bytes.gox fmt.gox io.gox os.gox \\\n+\t\treflect.gox strconv.gox strings.gox unicode.gox utf8.gox\n \t$(BUILDARCHIVE)\n xml/libxml.la: xml/libxml.a\n xml/check: $(CHECK_DEPS)\n@@ -1821,8 +1899,25 @@ crypt/cast5/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: crypto/cast5/check\n \n+crypto/libcipher.a: $(go_crypto_cipher_files) io.gox os.gox\n+\t$(BUILDARCHIVE)\n+crypto/libcipher.la: crypto/libcipher.a\n+crypto/cipher/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) crypto/cipher\n+\t$(CHECK)\n+.PHONY: crypto/cipher/check\n+\n+crypto/libelliptic.a: $(go_crypto_elliptic_files) big.gox io.gox os.gox \\\n+\t\tsync.gox\n+\t$(BUILDARCHIVE)\n+crypto/libelliptic.la: crypto/libelliptic.a\n+crypto/elliptic/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) crypto/elliptic\n+\t$(CHECK)\n+.PHONY: crypto/elliptic/check\n+\n crypto/libhmac.a: $(go_crypto_hmac_files) crypto/md5.gox crypto/sha1.gox \\\n-\t\thash.gox os.gox\n+\t\tcrypto/sha256.gox hash.gox os.gox\n \t$(BUILDARCHIVE)\n crypto/libhmac.la: crypto/libhmac.a\n crypto/hmac/check: $(CHECK_DEPS)\n@@ -1921,19 +2016,28 @@ crypto/subtle/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: crypto/subtle/check\n \n-crypto/libtls.a: $(go_crypto_tls_files) bufio.gox bytes.gox container/list.gox \\\n-\t\tcrypto/hmac.gox crypto/md5.gox crypto/rc4.gox crypto/rand.gox \\\n-\t\tcrypto/rsa.gox crypto/sha1.gox crypto/subtle.gox \\\n-\t\tcrypto/rsa.gox crypto/x509.gox encoding/pem.gox fmt.gox \\\n-\t\thash.gox io.gox io/ioutil.gox net.gox os.gox strings.gox \\\n-\t\tsync.gox time.gox\n+crypto/libtls.a: $(go_crypto_tls_files) big.gox bufio.gox bytes.gox \\\n+\t\tcontainer/list.gox crypto/aes.gox crypto/cipher.gox \\\n+\t\tcrypto/elliptic.gox crypto/hmac.gox crypto/md5.gox \\\n+\t\tcrypto/rc4.gox crypto/rand.gox crypto/rsa.gox crypto/sha1.gox \\\n+\t\tcrypto/subtle.gox crypto/rsa.gox crypto/sha1.gox \\\n+\t\tcrypto/x509.gox encoding/pem.gox fmt.gox hash.gox io.gox \\\n+\t\tio/ioutil.gox net.gox os.gox strings.gox sync.gox time.gox\n \t$(BUILDARCHIVE)\n crypto/libtls.la: crypto/libtls.a\n crypto/tls/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/tls\n \t$(CHECK)\n .PHONY: crypto/tls/check\n \n+crypto/libtwofish.a: $(go_crypto_twofish_files) os.gox strconv.gox\n+\t$(BUILDARCHIVE)\n+crypto/libtwofish.la: crypto/libtwofish.a\n+crypto/twofish/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) crypto/twofish\n+\t$(CHECK)\n+.PHONY: crypto/twofish/check\n+\n crypto/libx509.a: $(go_crypto_x509_files) asn1.gox big.gox \\\n \t\tcontainer/vector.gox crypto/rsa.gox crypto/sha1.gox hash.gox \\\n \t\tos.gox strings.gox time.gox\n@@ -1952,6 +2056,34 @@ crypto/xtea/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: crypto/xtea/check\n \n+crypto/openpgp/libarmor.a: $(go_crypto_openpgp_armor_files) bytes.gox \\\n+\t\tcrypto/openpgp/error.gox encoding/base64.gox \\\n+\t\tencoding/line.gox io.gox os.gox\n+\t$(BUILDARCHIVE)\n+crypto/openpgp/libarmor.la: crypto/openpgp/libarmor.a\n+crypto/openpgp/armor/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) crypto/openpgp/armor\n+\t$(CHECK)\n+.PHONY: crypto/openpgp/armor/check\n+\n+crypto/openpgp/liberror.a: $(go_crypto_openpgp_error_files)\n+\t$(BUILDARCHIVE)\n+crypto/openpgp/liberror.la: crypto/openpgp/liberror.a\n+crypto/openpgp/error/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) crypto/openpgp/error\n+\t$(CHECK)\n+.PHONY: crypto/openpgp/error/check\n+\n+crypto/openpgp/libs2k.a: $(go_crypto_openpgp_s2k_files) crypto/md5.gox \\\n+\t\tcrypto/openpgp/error.gox crypto/ripemd160.gox crypto/sha1.gox \\\n+\t\tcrypto/sha256.gox crypto/sha512.gox hash.gox io.gox os.gox\n+\t$(BUILDARCHIVE)\n+crypto/openpgp/libs2k.la: crypto/openpgp/libs2k.a\n+crypto/openpgp/s2k/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) crypto/openpgp/s2k\n+\t$(CHECK)\n+.PHONY: crypto/openpgp/s2k/check\n+\n debug/libdwarf.a: $(go_debug_dwarf_files) encoding/binary.gox os.gox \\\n \t\tstrconv.gox\n \t$(BUILDARCHIVE)\n@@ -2015,6 +2147,14 @@ encoding/ascii85/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: encoding/ascii85/check\n \n+encoding/libbase32.a: $(go_encoding_base32_files) io.gox os.gox strconv.gox\n+\t$(BUILDARCHIVE)\n+encoding/libbase32.la: encoding/libbase32.a\n+encoding/base32/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) encoding/base32\n+\t$(CHECK)\n+.PHONY: encoding/base32/check\n+\n encoding/libbase64.a: $(go_encoding_base64_files) io.gox os.gox strconv.gox\n \t$(BUILDARCHIVE)\n encoding/libbase64.la: encoding/libbase64.a\n@@ -2049,6 +2189,14 @@ encoding/hex/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: encoding/hex/check\n \n+encoding/libline.a: $(go_encoding_line_files) io.gox os.gox\n+\t$(BUILDARCHIVE)\n+encoding/libline.la: encoding/libline.a\n+encoding/line/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) encoding/line\n+\t$(CHECK)\n+.PHONY: encoding/line/check\n+\n encoding/libpem.a: $(go_encoding_pem_files) bytes.gox encoding/base64.gox\n \t$(BUILDARCHIVE)\n encoding/libpem.la: encoding/libpem.a\n@@ -2200,8 +2348,8 @@ image/png/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: image/png/check\n \n-index/libsuffixarray.a: $(go_index_suffixarray_files) bytes.gox \\\n-\t\tcontainer/vector.gox sort.gox\n+index/libsuffixarray.a: $(go_index_suffixarray_files) bytes.gox regexp.gox \\\n+\t\tsort.gox\n \t$(BUILDARCHIVE)\n index/libsuffixarray.la: index/libsuffixarray.a\n index/suffixarray/check: $(CHECK_DEPS)\n@@ -2242,6 +2390,15 @@ net/textproto/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: net/textproto/check\n \n+os/libinotify.a: $(go_os_inotify_files) fmt.gox os.gox strings.gox \\\n+\t\tsyscall.gox\n+\t$(BUILDARCHIVE)\n+os/libinotify.la: os/libinotify.a\n+os/inotify/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) os/inotify\n+\t$(CHECK)\n+.PHONY: os/inotify/check\n+\n os/libsignal.a: $(go_os_signal_files) runtime.gox strconv.gox\n \t$(BUILDARCHIVE)\n os/libsignal.la: os/libsignal.a\n@@ -2263,6 +2420,15 @@ rpc/jsonrpc/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: rpc/jsonrpc/check\n \n+runtime/libdebug.a: $(go_runtime_debug_files) bytes.gox fmt.gox io/ioutil.gox \\\n+\t\tos.gox runtime.gox\n+\t$(BUILDARCHIVE)\n+runtime/libdebug.la: runtime/libdebug.a\n+runtime/debug/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) runtime/debug\n+\t$(CHECK)\n+.PHONY: runtime/debug/check\n+\n runtime/libpprof.a: $(go_runtime_pprof_files) bufio.gox fmt.gox io.gox os.gox \\\n \t\truntime.gox\n \t$(BUILDARCHIVE)\n@@ -2445,6 +2611,10 @@ crypto/blowfish.gox: crypto/libblowfish.a\n \t$(BUILDGOX)\n crypto/cast5.gox: crypto/libcast5.a\n \t$(BUILDGOX)\n+crypto/cipher.gox: crypto/libcipher.a\n+\t$(BUILDGOX)\n+crypto/elliptic.gox: crypto/libelliptic.a\n+\t$(BUILDGOX)\n crypto/hmac.gox: crypto/libhmac.a\n \t$(BUILDGOX)\n crypto/md4.gox: crypto/libmd4.a\n@@ -2471,11 +2641,20 @@ crypto/subtle.gox: crypto/libsubtle.a\n \t$(BUILDGOX)\n crypto/tls.gox: crypto/libtls.a\n \t$(BUILDGOX)\n+crypto/twofish.gox: crypto/libtwofish.a\n+\t$(BUILDGOX)\n crypto/x509.gox: crypto/libx509.a\n \t$(BUILDGOX)\n crypto/xtea.gox: crypto/libxtea.a\n \t$(BUILDGOX)\n \n+crypto/openpgp/armor.gox: crypto/openpgp/libarmor.a\n+\t$(BUILDGOX)\n+crypto/openpgp/error.gox: crypto/openpgp/liberror.a\n+\t$(BUILDGOX)\n+crypto/openpgp/s2k.gox: crypto/openpgp/libs2k.a\n+\t$(BUILDGOX)\n+\n debug/dwarf.gox: debug/libdwarf.a\n \t$(BUILDGOX)\n debug/elf.gox: debug/libelf.a\n@@ -2491,6 +2670,8 @@ debug/proc.gox: debug/libproc.a\n \n encoding/ascii85.gox: encoding/libascii85.a\n \t$(BUILDGOX)\n+encoding/base32.gox: encoding/libbase32.a\n+\t$(BUILDGOX)\n encoding/base64.gox: encoding/libbase64.a\n \t$(BUILDGOX)\n encoding/binary.gox: encoding/libbinary.a\n@@ -2499,6 +2680,8 @@ encoding/git85.gox: encoding/libgit85.a\n \t$(BUILDGOX)\n encoding/hex.gox: encoding/libhex.a\n \t$(BUILDGOX)\n+encoding/line.gox: encoding/libline.a\n+\t$(BUILDGOX)\n encoding/pem.gox: encoding/libpem.a\n \t$(BUILDGOX)\n \n@@ -2553,12 +2736,16 @@ net/dict.gox: net/libdict.a\n net/textproto.gox: net/libtextproto.a\n \t$(BUILDGOX)\n \n+os/inotify.gox: os/libinotify.a\n+\t$(BUILDGOX)\n os/signal.gox: os/libsignal.a\n \t$(BUILDGOX)\n \n rpc/jsonrpc.gox: rpc/libjsonrpc.a\n \t$(BUILDGOX)\n \n+runtime/debug.gox: runtime/libdebug.a\n+\t$(BUILDGOX)\n runtime/pprof.gox: runtime/libpprof.a\n \t$(BUILDGOX)\n \n@@ -2569,6 +2756,13 @@ testing/quick.gox: testing/libquick.a\n testing/script.gox: testing/libscript.a\n \t$(BUILDGOX)\n \n+if LIBGO_IS_LINUX\n+# os_inotify_check = os/inotify/check\n+os_inotify_check =\n+else\n+os_inotify_check =\n+endif\n+\n TEST_PACKAGES = \\\n \tasn1/check \\\n \tbig/check \\\n@@ -2627,6 +2821,8 @@ TEST_PACKAGES = \\\n \tcrypto/block/check \\\n \tcrypto/blowfish/check \\\n \tcrypto/cast5/check \\\n+\tcrypto/cipher/check \\\n+\tcrypto/elliptic/check \\\n \tcrypto/hmac/check \\\n \tcrypto/md4/check \\\n \tcrypto/md5/check \\\n@@ -2640,24 +2836,30 @@ TEST_PACKAGES = \\\n \tcrypto/sha512/check \\\n \tcrypto/subtle/check \\\n \tcrypto/tls/check \\\n+\tcrypto/twofish/check \\\n \tcrypto/x509/check \\\n \tcrypto/xtea/check \\\n+\tcrypto/openpgp/armor/check \\\n+\tcrypto/openpgp/s2k/check \\\n \tdebug/dwarf/check \\\n \tdebug/elf/check \\\n \tdebug/macho/check \\\n \tdebug/pe/check \\\n \tencoding/ascii85/check \\\n+\tencoding/base32/check \\\n \tencoding/base64/check \\\n \tencoding/binary/check \\\n \tencoding/git85/check \\\n \tencoding/hex/check \\\n+\tencoding/line/check \\\n \tencoding/pem/check \\\n \texp/datafmt/check \\\n \texp/draw/check \\\n \texp/eval/check \\\n \tgo/parser/check \\\n \tgo/printer/check \\\n \tgo/scanner/check \\\n+\tgo/token/check \\\n \tgo/typechecker/check \\\n \thash/adler32/check \\\n \thash/crc32/check \\\n@@ -2667,6 +2869,7 @@ TEST_PACKAGES = \\\n \tio/ioutil/check \\\n \tmime/multipart/check \\\n \tnet/textproto/check \\\n+\t$(os_inotify_check) \\\n \tos/signal/check \\\n \trpc/jsonrpc/check \\\n \ttesting/quick/check \\"}, {"sha": "83cdf666dc73b4672ca211f3b9391319d2c5e0b3", "filename": "libgo/Makefile.in", "status": "modified", "additions": 302, "deletions": 31, "changes": 333, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -97,6 +97,7 @@ am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgocompressdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgocontainerdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgocryptodir)\" \\\n+\t\"$(DESTDIR)$(toolexeclibgocryptoopenpgpdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgodebugdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgoencodingdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgoexpdir)\" \\\n@@ -120,7 +121,49 @@ am_libgobegin_a_OBJECTS = go-main.$(OBJEXT)\n libgobegin_a_OBJECTS = $(am_libgobegin_a_OBJECTS)\n LTLIBRARIES = $(toolexeclib_LTLIBRARIES)\n am__DEPENDENCIES_1 =\n-libgo_la_DEPENDENCIES = $(libgo_go_objs) $(am__DEPENDENCIES_1) \\\n+am__DEPENDENCIES_2 = asn1/libasn1.la big/libbig.la bufio/libbufio.la \\\n+\tbytes/libbytes.la cmath/libcmath.la ebnf/libebnf.la \\\n+\texec/libexec.la expvar/libexpvar.la flag/libflag.la \\\n+\tfmt/libfmt.la gob/libgob.la hash/libhash.la html/libhtml.la \\\n+\thttp/libhttp.la image/libimage.la io/libio.la json/libjson.la \\\n+\tlog/liblog.la math/libmath.la mime/libmime.la net/libnet.la \\\n+\tnetchan/libnetchan.la os/libos.la patch/libpatch.la \\\n+\tpath/libpath.la rand/librand.la reflect/libreflect.la \\\n+\tregexp/libregexp.la rpc/librpc.la runtime/libruntime.la \\\n+\tscanner/libscanner.la smtp/libsmtp.la sort/libsort.la \\\n+\tstrconv/libstrconv.la strings/libstrings.la sync/libsync.la \\\n+\tsyslog/libsyslog.la tabwriter/libtabwriter.la \\\n+\ttemplate/libtemplate.la time/libtime.la try/libtry.la \\\n+\tunicode/libunicode.la utf16/libutf16.la utf8/libutf8.la \\\n+\twebsocket/libwebsocket.la xml/libxml.la archive/libtar.la \\\n+\tarchive/libzip.la compress/libflate.la compress/libgzip.la \\\n+\tcompress/libzlib.la container/libheap.la container/liblist.la \\\n+\tcontainer/libring.la container/libvector.la crypto/libaes.la \\\n+\tcrypto/libblock.la crypto/libblowfish.la crypto/libcast5.la \\\n+\tcrypto/libcipher.la crypto/libelliptic.la crypto/libhmac.la \\\n+\tcrypto/libmd4.la crypto/libmd5.la crypto/libocsp.la \\\n+\tcrypto/librand.la crypto/librc4.la crypto/libripemd160.la \\\n+\tcrypto/librsa.la crypto/libsha1.la crypto/libsha256.la \\\n+\tcrypto/libsha512.la crypto/libsubtle.la crypto/libtls.la \\\n+\tcrypto/libtwofish.la crypto/libx509.la crypto/libxtea.la \\\n+\tcrypto/openpgp/libarmor.la crypto/openpgp/liberror.la \\\n+\tcrypto/openpgp/libs2k.la debug/libdwarf.la debug/libelf.la \\\n+\tdebug/libgosym.la debug/libmacho.la debug/libpe.la \\\n+\tdebug/libproc.la encoding/libascii85.la encoding/libbase32.la \\\n+\tencoding/libbase64.la encoding/libbinary.la \\\n+\tencoding/libgit85.la encoding/libhex.la encoding/libline.la \\\n+\tencoding/libpem.la exp/libdatafmt.la exp/libdraw.la \\\n+\texp/libeval.la go/libast.la go/libdoc.la go/libparser.la \\\n+\tgo/libprinter.la go/libscanner.la go/libtoken.la \\\n+\tgo/libtypechecker.la hash/libadler32.la hash/libcrc32.la \\\n+\thash/libcrc64.la http/libpprof.la image/libjpeg.la \\\n+\timage/libpng.la index/libsuffixarray.la io/libioutil.la \\\n+\tmime/libmultipart.la net/libdict.la net/libtextproto.la \\\n+\t$(am__DEPENDENCIES_1) os/libsignal.la rpc/libjsonrpc.la \\\n+\truntime/libdebug.la runtime/libpprof.la syscalls/libsyscall.la \\\n+\ttesting/libtesting.la testing/libiotest.la testing/libquick.la \\\n+\ttesting/libscript.la\n+libgo_la_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1) \\\n \t$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \\\n \t$(am__DEPENDENCIES_1)\n am__libgo_la_SOURCES_DIST = runtime/go-append.c runtime/go-assert.c \\\n@@ -231,14 +274,15 @@ RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \\\n \tps-recursive uninstall-recursive\n DATA = $(toolexeclibgo_DATA) $(toolexeclibgoarchive_DATA) \\\n \t$(toolexeclibgocompress_DATA) $(toolexeclibgocontainer_DATA) \\\n-\t$(toolexeclibgocrypto_DATA) $(toolexeclibgodebug_DATA) \\\n-\t$(toolexeclibgoencoding_DATA) $(toolexeclibgoexp_DATA) \\\n-\t$(toolexeclibgogo_DATA) $(toolexeclibgohash_DATA) \\\n-\t$(toolexeclibgohttp_DATA) $(toolexeclibgoimage_DATA) \\\n-\t$(toolexeclibgoindex_DATA) $(toolexeclibgoio_DATA) \\\n-\t$(toolexeclibgomime_DATA) $(toolexeclibgonet_DATA) \\\n-\t$(toolexeclibgoos_DATA) $(toolexeclibgorpc_DATA) \\\n-\t$(toolexeclibgoruntime_DATA) $(toolexeclibgotesting_DATA)\n+\t$(toolexeclibgocrypto_DATA) $(toolexeclibgocryptoopenpgp_DATA) \\\n+\t$(toolexeclibgodebug_DATA) $(toolexeclibgoencoding_DATA) \\\n+\t$(toolexeclibgoexp_DATA) $(toolexeclibgogo_DATA) \\\n+\t$(toolexeclibgohash_DATA) $(toolexeclibgohttp_DATA) \\\n+\t$(toolexeclibgoimage_DATA) $(toolexeclibgoindex_DATA) \\\n+\t$(toolexeclibgoio_DATA) $(toolexeclibgomime_DATA) \\\n+\t$(toolexeclibgonet_DATA) $(toolexeclibgoos_DATA) \\\n+\t$(toolexeclibgorpc_DATA) $(toolexeclibgoruntime_DATA) \\\n+\t$(toolexeclibgotesting_DATA)\n RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive\t\\\n   distclean-recursive maintainer-clean-recursive\n AM_RECURSIVE_TARGETS = $(RECURSIVE_TARGETS:-recursive=) \\\n@@ -570,6 +614,8 @@ toolexeclibgocrypto_DATA = \\\n \tcrypto/block.gox \\\n \tcrypto/blowfish.gox \\\n \tcrypto/cast5.gox \\\n+\tcrypto/cipher.gox \\\n+\tcrypto/elliptic.gox \\\n \tcrypto/hmac.gox \\\n \tcrypto/md4.gox \\\n \tcrypto/md5.gox \\\n@@ -583,9 +629,16 @@ toolexeclibgocrypto_DATA = \\\n \tcrypto/sha512.gox \\\n \tcrypto/subtle.gox \\\n \tcrypto/tls.gox \\\n+\tcrypto/twofish.gox \\\n \tcrypto/x509.gox \\\n \tcrypto/xtea.gox\n \n+toolexeclibgocryptoopenpgpdir = $(toolexeclibgocryptodir)/openpgp\n+toolexeclibgocryptoopenpgp_DATA = \\\n+\tcrypto/openpgp/armor.gox \\\n+\tcrypto/openpgp/error.gox \\\n+\tcrypto/openpgp/s2k.gox\n+\n toolexeclibgodebugdir = $(toolexeclibgodir)/debug\n toolexeclibgodebug_DATA = \\\n \tdebug/dwarf.gox \\\n@@ -598,8 +651,10 @@ toolexeclibgodebug_DATA = \\\n toolexeclibgoencodingdir = $(toolexeclibgodir)/encoding\n toolexeclibgoencoding_DATA = \\\n \tencoding/ascii85.gox \\\n+\tencoding/base32.gox \\\n \tencoding/base64.gox \\\n \tencoding/binary.gox \\\n+\tencoding/line.gox \\\n \tencoding/git85.gox \\\n \tencoding/hex.gox \\\n \tencoding/pem.gox\n@@ -653,7 +708,12 @@ toolexeclibgonet_DATA = \\\n \tnet/textproto.gox\n \n toolexeclibgoosdir = $(toolexeclibgodir)/os\n+@LIBGO_IS_LINUX_FALSE@os_inotify_gox = \n+\n+# os_inotify_gox = os/inotify.gox\n+@LIBGO_IS_LINUX_TRUE@os_inotify_gox = \n toolexeclibgoos_DATA = \\\n+\t$(os_inotify_gox) \\\n \tos/signal.gox\n \n toolexeclibgorpcdir = $(toolexeclibgodir)/rpc\n@@ -662,6 +722,7 @@ toolexeclibgorpc_DATA = \\\n \n toolexeclibgoruntimedir = $(toolexeclibgodir)/runtime\n toolexeclibgoruntime_DATA = \\\n+\truntime/debug.gox \\\n \truntime/pprof.gox\n \n toolexeclibgotestingdir = $(toolexeclibgodir)/testing\n@@ -848,6 +909,7 @@ go_html_files = \\\n \tgo/html/doc.go \\\n \tgo/html/entity.go \\\n \tgo/html/escape.go \\\n+\tgo/html/parse.go \\\n \tgo/html/token.go\n \n go_http_files = \\\n@@ -899,6 +961,7 @@ go_math_files = \\\n \tgo/math/copysign.go \\\n \tgo/math/erf.go \\\n \tgo/math/exp.go \\\n+\tgo/math/exp_port.go \\\n \tgo/math/exp2.go \\\n \tgo/math/expm1.go \\\n \tgo/math/fabs.go \\\n@@ -996,7 +1059,8 @@ go_patch_files = \\\n \n go_path_files = \\\n \tgo/path/match.go \\\n-\tgo/path/path.go\n+\tgo/path/path.go \\\n+\tgo/path/path_unix.go\n \n go_rand_files = \\\n \tgo/rand/exp.go \\\n@@ -1022,6 +1086,8 @@ go_runtime_files = \\\n \tgo/runtime/debug.go \\\n \tgo/runtime/error.go \\\n \tgo/runtime/extern.go \\\n+\tgo/runtime/malloc_defs.go \\\n+\tgo/runtime/runtime_defs.go \\\n \tgo/runtime/sig.go \\\n \tgo/runtime/softfloat64.go \\\n \tgo/runtime/type.go \\\n@@ -1035,6 +1101,7 @@ go_smtp_files = \\\n \tgo/smtp/smtp.go\n \n go_sort_files = \\\n+\tgo/sort/search.go \\\n \tgo/sort/sort.go\n \n go_strconv_files = \\\n@@ -1169,6 +1236,18 @@ go_crypto_blowfish_files = \\\n go_crypto_cast5_files = \\\n \tgo/crypto/cast5/cast5.go\n \n+go_crypto_cipher_files = \\\n+\tgo/crypto/cipher/cbc.go \\\n+\tgo/crypto/cipher/cfb.go \\\n+\tgo/crypto/cipher/cipher.go \\\n+\tgo/crypto/cipher/ctr.go \\\n+\tgo/crypto/cipher/io.go \\\n+\tgo/crypto/cipher/ocfb.go \\\n+\tgo/crypto/cipher/ofb.go\n+\n+go_crypto_elliptic_files = \\\n+\tgo/crypto/elliptic/elliptic.go\n+\n go_crypto_hmac_files = \\\n \tgo/crypto/hmac/hmac.go\n \n@@ -1216,21 +1295,36 @@ go_crypto_subtle_files = \\\n go_crypto_tls_files = \\\n \tgo/crypto/tls/alert.go \\\n \tgo/crypto/tls/ca_set.go \\\n+\tgo/crypto/tls/cipher_suites.go \\\n \tgo/crypto/tls/common.go \\\n \tgo/crypto/tls/conn.go \\\n \tgo/crypto/tls/handshake_client.go \\\n \tgo/crypto/tls/handshake_messages.go \\\n \tgo/crypto/tls/handshake_server.go \\\n+\tgo/crypto/tls/key_agreement.go \\\n \tgo/crypto/tls/prf.go \\\n \tgo/crypto/tls/tls.go\n \n+go_crypto_twofish_files = \\\n+\tgo/crypto/twofish/twofish.go\n+\n go_crypto_x509_files = \\\n \tgo/crypto/x509/x509.go\n \n go_crypto_xtea_files = \\\n \tgo/crypto/xtea/block.go \\\n \tgo/crypto/xtea/cipher.go\n \n+go_crypto_openpgp_armor_files = \\\n+\tgo/crypto/openpgp/armor/armor.go \\\n+\tgo/crypto/openpgp/armor/encode.go\n+\n+go_crypto_openpgp_error_files = \\\n+\tgo/crypto/openpgp/error/error.go\n+\n+go_crypto_openpgp_s2k_files = \\\n+\tgo/crypto/openpgp/s2k/s2k.go\n+\n go_debug_dwarf_files = \\\n \tgo/debug/dwarf/buf.go \\\n \tgo/debug/dwarf/const.go \\\n@@ -1263,6 +1357,9 @@ go_debug_proc_files = \\\n go_encoding_ascii85_files = \\\n \tgo/encoding/ascii85/ascii85.go\n \n+go_encoding_base32_files = \\\n+\tgo/encoding/base32/base32.go\n+\n go_encoding_base64_files = \\\n \tgo/encoding/base64/base64.go\n \n@@ -1275,6 +1372,9 @@ go_encoding_git85_files = \\\n go_encoding_hex_files = \\\n \tgo/encoding/hex/hex.go\n \n+go_encoding_line_files = \\\n+\tgo/encoding/line/line.go\n+\n go_encoding_pem_files = \\\n \tgo/encoding/pem/pem.go\n \n@@ -1324,6 +1424,7 @@ go_go_scanner_files = \\\n \tgo/go/scanner/scanner.go\n \n go_go_token_files = \\\n+\tgo/go/token/position.go \\\n \tgo/go/token/token.go\n \n go_go_typechecker_files = \\\n@@ -1353,6 +1454,7 @@ go_image_png_files = \\\n \tgo/image/png/writer.go\n \n go_index_suffixarray_files = \\\n+\tgo/index/suffixarray/qsufsort.go \\\n \tgo/index/suffixarray/suffixarray.go\n \n go_io_ioutil_files = \\\n@@ -1371,6 +1473,9 @@ go_net_textproto_files = \\\n \tgo/net/textproto/textproto.go \\\n \tgo/net/textproto/writer.go\n \n+go_os_inotify_files = \\\n+\tgo/os/inotify/inotify_linux.go\n+\n go_os_signal_files = \\\n \tgo/os/signal/signal.go \\\n \tunix.go\n@@ -1379,6 +1484,9 @@ go_rpc_jsonrpc_files = \\\n \tgo/rpc/jsonrpc/client.go \\\n \tgo/rpc/jsonrpc/server.go\n \n+go_runtime_debug_files = \\\n+\tgo/runtime/debug/stack.go\n+\n go_runtime_pprof_files = \\\n \tgo/runtime/pprof/pprof.go\n \n@@ -1458,6 +1566,10 @@ go_syscall_files = \\\n go_syscall_c_files = \\\n \tsyscalls/errno.c\n \n+@LIBGO_IS_LINUX_FALSE@os_lib_inotify_la = \n+\n+# os_lib_inotify_la = os/libinotify.la\n+@LIBGO_IS_LINUX_TRUE@os_lib_inotify_la = \n libgo_go_objs = \\\n \tasn1/libasn1.la \\\n \tbig/libbig.la \\\n@@ -1518,6 +1630,8 @@ libgo_go_objs = \\\n \tcrypto/libblock.la \\\n \tcrypto/libblowfish.la \\\n \tcrypto/libcast5.la \\\n+\tcrypto/libcipher.la \\\n+\tcrypto/libelliptic.la \\\n \tcrypto/libhmac.la \\\n \tcrypto/libmd4.la \\\n \tcrypto/libmd5.la \\\n@@ -1531,19 +1645,25 @@ libgo_go_objs = \\\n \tcrypto/libsha512.la \\\n \tcrypto/libsubtle.la \\\n \tcrypto/libtls.la \\\n+\tcrypto/libtwofish.la \\\n \tcrypto/libx509.la \\\n \tcrypto/libxtea.la \\\n+\tcrypto/openpgp/libarmor.la \\\n+\tcrypto/openpgp/liberror.la \\\n+\tcrypto/openpgp/libs2k.la \\\n \tdebug/libdwarf.la \\\n \tdebug/libelf.la \\\n \tdebug/libgosym.la \\\n \tdebug/libmacho.la \\\n \tdebug/libpe.la \\\n \tdebug/libproc.la \\\n \tencoding/libascii85.la \\\n+\tencoding/libbase32.la \\\n \tencoding/libbase64.la \\\n \tencoding/libbinary.la \\\n \tencoding/libgit85.la \\\n \tencoding/libhex.la \\\n+\tencoding/libline.la \\\n \tencoding/libpem.la \\\n \texp/libdatafmt.la \\\n \texp/libdraw.la \\\n@@ -1566,8 +1686,10 @@ libgo_go_objs = \\\n \tmime/libmultipart.la \\\n \tnet/libdict.la \\\n \tnet/libtextproto.la \\\n+\t$(os_lib_inotify_la) \\\n \tos/libsignal.la \\\n \trpc/libjsonrpc.la \\\n+\truntime/libdebug.la \\\n \truntime/libpprof.la \\\n \tsyscalls/libsyscall.la \\\n \ttesting/libtesting.la \\\n@@ -1659,6 +1781,10 @@ BUILDGOX = \\\n \tmv -f $@.tmp $@; \\\n \trm -f $@.$(OBJEXT)\n \n+@LIBGO_IS_LINUX_FALSE@os_inotify_check = \n+\n+# os_inotify_check = os/inotify/check\n+@LIBGO_IS_LINUX_TRUE@os_inotify_check = \n TEST_PACKAGES = \\\n \tasn1/check \\\n \tbig/check \\\n@@ -1717,6 +1843,8 @@ TEST_PACKAGES = \\\n \tcrypto/block/check \\\n \tcrypto/blowfish/check \\\n \tcrypto/cast5/check \\\n+\tcrypto/cipher/check \\\n+\tcrypto/elliptic/check \\\n \tcrypto/hmac/check \\\n \tcrypto/md4/check \\\n \tcrypto/md5/check \\\n@@ -1730,24 +1858,30 @@ TEST_PACKAGES = \\\n \tcrypto/sha512/check \\\n \tcrypto/subtle/check \\\n \tcrypto/tls/check \\\n+\tcrypto/twofish/check \\\n \tcrypto/x509/check \\\n \tcrypto/xtea/check \\\n+\tcrypto/openpgp/armor/check \\\n+\tcrypto/openpgp/s2k/check \\\n \tdebug/dwarf/check \\\n \tdebug/elf/check \\\n \tdebug/macho/check \\\n \tdebug/pe/check \\\n \tencoding/ascii85/check \\\n+\tencoding/base32/check \\\n \tencoding/base64/check \\\n \tencoding/binary/check \\\n \tencoding/git85/check \\\n \tencoding/hex/check \\\n+\tencoding/line/check \\\n \tencoding/pem/check \\\n \texp/datafmt/check \\\n \texp/draw/check \\\n \texp/eval/check \\\n \tgo/parser/check \\\n \tgo/printer/check \\\n \tgo/scanner/check \\\n+\tgo/token/check \\\n \tgo/typechecker/check \\\n \thash/adler32/check \\\n \thash/crc32/check \\\n@@ -1757,6 +1891,7 @@ TEST_PACKAGES = \\\n \tio/ioutil/check \\\n \tmime/multipart/check \\\n \tnet/textproto/check \\\n+\t$(os_inotify_check) \\\n \tos/signal/check \\\n \trpc/jsonrpc/check \\\n \ttesting/quick/check \\\n@@ -2793,6 +2928,26 @@ uninstall-toolexeclibgocryptoDATA:\n \ttest -n \"$$files\" || exit 0; \\\n \techo \" ( cd '$(DESTDIR)$(toolexeclibgocryptodir)' && rm -f\" $$files \")\"; \\\n \tcd \"$(DESTDIR)$(toolexeclibgocryptodir)\" && rm -f $$files\n+install-toolexeclibgocryptoopenpgpDATA: $(toolexeclibgocryptoopenpgp_DATA)\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(toolexeclibgocryptoopenpgpdir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibgocryptoopenpgpdir)\"\n+\t@list='$(toolexeclibgocryptoopenpgp_DATA)'; test -n \"$(toolexeclibgocryptoopenpgpdir)\" || list=; \\\n+\tfor p in $$list; do \\\n+\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n+\t  echo \"$$d$$p\"; \\\n+\tdone | $(am__base_list) | \\\n+\twhile read files; do \\\n+\t  echo \" $(INSTALL_DATA) $$files '$(DESTDIR)$(toolexeclibgocryptoopenpgpdir)'\"; \\\n+\t  $(INSTALL_DATA) $$files \"$(DESTDIR)$(toolexeclibgocryptoopenpgpdir)\" || exit $$?; \\\n+\tdone\n+\n+uninstall-toolexeclibgocryptoopenpgpDATA:\n+\t@$(NORMAL_UNINSTALL)\n+\t@list='$(toolexeclibgocryptoopenpgp_DATA)'; test -n \"$(toolexeclibgocryptoopenpgpdir)\" || list=; \\\n+\tfiles=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \\\n+\ttest -n \"$$files\" || exit 0; \\\n+\techo \" ( cd '$(DESTDIR)$(toolexeclibgocryptoopenpgpdir)' && rm -f\" $$files \")\"; \\\n+\tcd \"$(DESTDIR)$(toolexeclibgocryptoopenpgpdir)\" && rm -f $$files\n install-toolexeclibgodebugDATA: $(toolexeclibgodebug_DATA)\n \t@$(NORMAL_INSTALL)\n \ttest -z \"$(toolexeclibgodebugdir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibgodebugdir)\"\n@@ -3410,7 +3565,7 @@ all-am: Makefile $(LIBRARIES) $(LTLIBRARIES) all-multi $(DATA) \\\n \t\tconfig.h\n installdirs: installdirs-recursive\n installdirs-am:\n-\tfor dir in \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibgodir)\" \"$(DESTDIR)$(toolexeclibgoarchivedir)\" \"$(DESTDIR)$(toolexeclibgocompressdir)\" \"$(DESTDIR)$(toolexeclibgocontainerdir)\" \"$(DESTDIR)$(toolexeclibgocryptodir)\" \"$(DESTDIR)$(toolexeclibgodebugdir)\" \"$(DESTDIR)$(toolexeclibgoencodingdir)\" \"$(DESTDIR)$(toolexeclibgoexpdir)\" \"$(DESTDIR)$(toolexeclibgogodir)\" \"$(DESTDIR)$(toolexeclibgohashdir)\" \"$(DESTDIR)$(toolexeclibgohttpdir)\" \"$(DESTDIR)$(toolexeclibgoimagedir)\" \"$(DESTDIR)$(toolexeclibgoindexdir)\" \"$(DESTDIR)$(toolexeclibgoiodir)\" \"$(DESTDIR)$(toolexeclibgomimedir)\" \"$(DESTDIR)$(toolexeclibgonetdir)\" \"$(DESTDIR)$(toolexeclibgoosdir)\" \"$(DESTDIR)$(toolexeclibgorpcdir)\" \"$(DESTDIR)$(toolexeclibgoruntimedir)\" \"$(DESTDIR)$(toolexeclibgotestingdir)\"; do \\\n+\tfor dir in \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibgodir)\" \"$(DESTDIR)$(toolexeclibgoarchivedir)\" \"$(DESTDIR)$(toolexeclibgocompressdir)\" \"$(DESTDIR)$(toolexeclibgocontainerdir)\" \"$(DESTDIR)$(toolexeclibgocryptodir)\" \"$(DESTDIR)$(toolexeclibgocryptoopenpgpdir)\" \"$(DESTDIR)$(toolexeclibgodebugdir)\" \"$(DESTDIR)$(toolexeclibgoencodingdir)\" \"$(DESTDIR)$(toolexeclibgoexpdir)\" \"$(DESTDIR)$(toolexeclibgogodir)\" \"$(DESTDIR)$(toolexeclibgohashdir)\" \"$(DESTDIR)$(toolexeclibgohttpdir)\" \"$(DESTDIR)$(toolexeclibgoimagedir)\" \"$(DESTDIR)$(toolexeclibgoindexdir)\" \"$(DESTDIR)$(toolexeclibgoiodir)\" \"$(DESTDIR)$(toolexeclibgomimedir)\" \"$(DESTDIR)$(toolexeclibgonetdir)\" \"$(DESTDIR)$(toolexeclibgoosdir)\" \"$(DESTDIR)$(toolexeclibgorpcdir)\" \"$(DESTDIR)$(toolexeclibgoruntimedir)\" \"$(DESTDIR)$(toolexeclibgotestingdir)\"; do \\\n \t  test -z \"$$dir\" || $(MKDIR_P) \"$$dir\"; \\\n \tdone\n install: install-recursive\n@@ -3475,7 +3630,9 @@ install-exec-am: install-multi install-toolexeclibLIBRARIES \\\n \tinstall-toolexeclibgoarchiveDATA \\\n \tinstall-toolexeclibgocompressDATA \\\n \tinstall-toolexeclibgocontainerDATA \\\n-\tinstall-toolexeclibgocryptoDATA install-toolexeclibgodebugDATA \\\n+\tinstall-toolexeclibgocryptoDATA \\\n+\tinstall-toolexeclibgocryptoopenpgpDATA \\\n+\tinstall-toolexeclibgodebugDATA \\\n \tinstall-toolexeclibgoencodingDATA install-toolexeclibgoexpDATA \\\n \tinstall-toolexeclibgogoDATA install-toolexeclibgohashDATA \\\n \tinstall-toolexeclibgohttpDATA install-toolexeclibgoimageDATA \\\n@@ -3531,6 +3688,7 @@ uninstall-am: uninstall-toolexeclibLIBRARIES \\\n \tuninstall-toolexeclibgocompressDATA \\\n \tuninstall-toolexeclibgocontainerDATA \\\n \tuninstall-toolexeclibgocryptoDATA \\\n+\tuninstall-toolexeclibgocryptoopenpgpDATA \\\n \tuninstall-toolexeclibgodebugDATA \\\n \tuninstall-toolexeclibgoencodingDATA \\\n \tuninstall-toolexeclibgoexpDATA uninstall-toolexeclibgogoDATA \\\n@@ -3566,7 +3724,9 @@ uninstall-am: uninstall-toolexeclibLIBRARIES \\\n \tinstall-toolexeclibgoDATA install-toolexeclibgoarchiveDATA \\\n \tinstall-toolexeclibgocompressDATA \\\n \tinstall-toolexeclibgocontainerDATA \\\n-\tinstall-toolexeclibgocryptoDATA install-toolexeclibgodebugDATA \\\n+\tinstall-toolexeclibgocryptoDATA \\\n+\tinstall-toolexeclibgocryptoopenpgpDATA \\\n+\tinstall-toolexeclibgodebugDATA \\\n \tinstall-toolexeclibgoencodingDATA install-toolexeclibgoexpDATA \\\n \tinstall-toolexeclibgogoDATA install-toolexeclibgohashDATA \\\n \tinstall-toolexeclibgohttpDATA install-toolexeclibgoimageDATA \\\n@@ -3586,6 +3746,7 @@ uninstall-am: uninstall-toolexeclibLIBRARIES \\\n \tuninstall-toolexeclibgocompressDATA \\\n \tuninstall-toolexeclibgocontainerDATA \\\n \tuninstall-toolexeclibgocryptoDATA \\\n+\tuninstall-toolexeclibgocryptoopenpgpDATA \\\n \tuninstall-toolexeclibgodebugDATA \\\n \tuninstall-toolexeclibgoencodingDATA \\\n \tuninstall-toolexeclibgoexpDATA uninstall-toolexeclibgogoDATA \\\n@@ -3731,7 +3892,8 @@ fmt/check: $(CHECK_DEPS)\n .PHONY: fmt/check\n \n gob/libgob.a: $(go_gob_files) bytes.gox fmt.gox io.gox math.gox os.gox \\\n-\t\treflect.gox runtime.gox strings.gox sync.gox unicode.gox\n+\t\treflect.gox runtime.gox strings.gox sync.gox unicode.gox \\\n+\t\tutf8.gox\n \t$(BUILDARCHIVE)\n gob/libgob.la: gob/libgob.a\n gob/check: $(CHECK_DEPS)\n@@ -3788,7 +3950,7 @@ json/check: $(CHECK_DEPS)\n .PHONY: json/check\n \n log/liblog.a: $(go_log_files) bytes.gox fmt.gox io.gox runtime.gox os.gox \\\n-\t\ttime.gox\n+\t\tsync.gox time.gox\n \t$(BUILDARCHIVE)\n log/liblog.la: log/liblog.a\n log/check: $(CHECK_DEPS)\n@@ -3810,16 +3972,16 @@ mime/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: mime/check\n \n-net/libnet.a: $(go_net_files) fmt.gox io.gox os.gox reflect.gox strconv.gox \\\n-\t\tstrings.gox sync.gox syscall.gox\n+net/libnet.a: $(go_net_files) bytes.gox fmt.gox io.gox os.gox reflect.gox \\\n+\t\tstrconv.gox strings.gox sync.gox syscall.gox\n \t$(BUILDARCHIVE)\n net/libnet.la: net/libnet.a\n net/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: net/check\n \n netchan/libnetchan.a: $(go_netchan_files) gob.gox log.gox net.gox os.gox \\\n-\t\treflect.gox sync.gox time.gox\n+\t\treflect.gox strconv.gox sync.gox time.gox\n \t$(BUILDARCHIVE)\n netchan/libnetchan.la: netchan/libnetchan.a\n netchan/check: $(CHECK_DEPS)\n@@ -3970,8 +4132,8 @@ testing/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: testing/check\n \n-time/libtime.a: $(go_time_files) bytes.gox io/ioutil.gox os.gox strconv.gox \\\n-\t\tsync.gox syscall.gox\n+time/libtime.a: $(go_time_files) bytes.gox container/heap.gox io/ioutil.gox \\\n+\t\tos.gox strconv.gox sync.gox syscall.gox\n \t$(BUILDARCHIVE)\n time/libtime.la: time/libtime.a\n time/check: $(CHECK_DEPS)\n@@ -4016,8 +4178,8 @@ websocket/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: websocket/check\n \n-xml/libxml.a: $(go_xml_files) bufio.gox bytes.gox io.gox os.gox reflect.gox \\\n-\t\tstrconv.gox strings.gox unicode.gox utf8.gox\n+xml/libxml.a: $(go_xml_files) bufio.gox bytes.gox fmt.gox io.gox os.gox \\\n+\t\treflect.gox strconv.gox strings.gox unicode.gox utf8.gox\n \t$(BUILDARCHIVE)\n xml/libxml.la: xml/libxml.a\n xml/check: $(CHECK_DEPS)\n@@ -4134,8 +4296,25 @@ crypt/cast5/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: crypto/cast5/check\n \n+crypto/libcipher.a: $(go_crypto_cipher_files) io.gox os.gox\n+\t$(BUILDARCHIVE)\n+crypto/libcipher.la: crypto/libcipher.a\n+crypto/cipher/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) crypto/cipher\n+\t$(CHECK)\n+.PHONY: crypto/cipher/check\n+\n+crypto/libelliptic.a: $(go_crypto_elliptic_files) big.gox io.gox os.gox \\\n+\t\tsync.gox\n+\t$(BUILDARCHIVE)\n+crypto/libelliptic.la: crypto/libelliptic.a\n+crypto/elliptic/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) crypto/elliptic\n+\t$(CHECK)\n+.PHONY: crypto/elliptic/check\n+\n crypto/libhmac.a: $(go_crypto_hmac_files) crypto/md5.gox crypto/sha1.gox \\\n-\t\thash.gox os.gox\n+\t\tcrypto/sha256.gox hash.gox os.gox\n \t$(BUILDARCHIVE)\n crypto/libhmac.la: crypto/libhmac.a\n crypto/hmac/check: $(CHECK_DEPS)\n@@ -4234,19 +4413,28 @@ crypto/subtle/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: crypto/subtle/check\n \n-crypto/libtls.a: $(go_crypto_tls_files) bufio.gox bytes.gox container/list.gox \\\n-\t\tcrypto/hmac.gox crypto/md5.gox crypto/rc4.gox crypto/rand.gox \\\n-\t\tcrypto/rsa.gox crypto/sha1.gox crypto/subtle.gox \\\n-\t\tcrypto/rsa.gox crypto/x509.gox encoding/pem.gox fmt.gox \\\n-\t\thash.gox io.gox io/ioutil.gox net.gox os.gox strings.gox \\\n-\t\tsync.gox time.gox\n+crypto/libtls.a: $(go_crypto_tls_files) big.gox bufio.gox bytes.gox \\\n+\t\tcontainer/list.gox crypto/aes.gox crypto/cipher.gox \\\n+\t\tcrypto/elliptic.gox crypto/hmac.gox crypto/md5.gox \\\n+\t\tcrypto/rc4.gox crypto/rand.gox crypto/rsa.gox crypto/sha1.gox \\\n+\t\tcrypto/subtle.gox crypto/rsa.gox crypto/sha1.gox \\\n+\t\tcrypto/x509.gox encoding/pem.gox fmt.gox hash.gox io.gox \\\n+\t\tio/ioutil.gox net.gox os.gox strings.gox sync.gox time.gox\n \t$(BUILDARCHIVE)\n crypto/libtls.la: crypto/libtls.a\n crypto/tls/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/tls\n \t$(CHECK)\n .PHONY: crypto/tls/check\n \n+crypto/libtwofish.a: $(go_crypto_twofish_files) os.gox strconv.gox\n+\t$(BUILDARCHIVE)\n+crypto/libtwofish.la: crypto/libtwofish.a\n+crypto/twofish/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) crypto/twofish\n+\t$(CHECK)\n+.PHONY: crypto/twofish/check\n+\n crypto/libx509.a: $(go_crypto_x509_files) asn1.gox big.gox \\\n \t\tcontainer/vector.gox crypto/rsa.gox crypto/sha1.gox hash.gox \\\n \t\tos.gox strings.gox time.gox\n@@ -4265,6 +4453,34 @@ crypto/xtea/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: crypto/xtea/check\n \n+crypto/openpgp/libarmor.a: $(go_crypto_openpgp_armor_files) bytes.gox \\\n+\t\tcrypto/openpgp/error.gox encoding/base64.gox \\\n+\t\tencoding/line.gox io.gox os.gox\n+\t$(BUILDARCHIVE)\n+crypto/openpgp/libarmor.la: crypto/openpgp/libarmor.a\n+crypto/openpgp/armor/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) crypto/openpgp/armor\n+\t$(CHECK)\n+.PHONY: crypto/openpgp/armor/check\n+\n+crypto/openpgp/liberror.a: $(go_crypto_openpgp_error_files)\n+\t$(BUILDARCHIVE)\n+crypto/openpgp/liberror.la: crypto/openpgp/liberror.a\n+crypto/openpgp/error/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) crypto/openpgp/error\n+\t$(CHECK)\n+.PHONY: crypto/openpgp/error/check\n+\n+crypto/openpgp/libs2k.a: $(go_crypto_openpgp_s2k_files) crypto/md5.gox \\\n+\t\tcrypto/openpgp/error.gox crypto/ripemd160.gox crypto/sha1.gox \\\n+\t\tcrypto/sha256.gox crypto/sha512.gox hash.gox io.gox os.gox\n+\t$(BUILDARCHIVE)\n+crypto/openpgp/libs2k.la: crypto/openpgp/libs2k.a\n+crypto/openpgp/s2k/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) crypto/openpgp/s2k\n+\t$(CHECK)\n+.PHONY: crypto/openpgp/s2k/check\n+\n debug/libdwarf.a: $(go_debug_dwarf_files) encoding/binary.gox os.gox \\\n \t\tstrconv.gox\n \t$(BUILDARCHIVE)\n@@ -4328,6 +4544,14 @@ encoding/ascii85/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: encoding/ascii85/check\n \n+encoding/libbase32.a: $(go_encoding_base32_files) io.gox os.gox strconv.gox\n+\t$(BUILDARCHIVE)\n+encoding/libbase32.la: encoding/libbase32.a\n+encoding/base32/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) encoding/base32\n+\t$(CHECK)\n+.PHONY: encoding/base32/check\n+\n encoding/libbase64.a: $(go_encoding_base64_files) io.gox os.gox strconv.gox\n \t$(BUILDARCHIVE)\n encoding/libbase64.la: encoding/libbase64.a\n@@ -4362,6 +4586,14 @@ encoding/hex/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: encoding/hex/check\n \n+encoding/libline.a: $(go_encoding_line_files) io.gox os.gox\n+\t$(BUILDARCHIVE)\n+encoding/libline.la: encoding/libline.a\n+encoding/line/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) encoding/line\n+\t$(CHECK)\n+.PHONY: encoding/line/check\n+\n encoding/libpem.a: $(go_encoding_pem_files) bytes.gox encoding/base64.gox\n \t$(BUILDARCHIVE)\n encoding/libpem.la: encoding/libpem.a\n@@ -4513,8 +4745,8 @@ image/png/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: image/png/check\n \n-index/libsuffixarray.a: $(go_index_suffixarray_files) bytes.gox \\\n-\t\tcontainer/vector.gox sort.gox\n+index/libsuffixarray.a: $(go_index_suffixarray_files) bytes.gox regexp.gox \\\n+\t\tsort.gox\n \t$(BUILDARCHIVE)\n index/libsuffixarray.la: index/libsuffixarray.a\n index/suffixarray/check: $(CHECK_DEPS)\n@@ -4555,6 +4787,15 @@ net/textproto/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: net/textproto/check\n \n+os/libinotify.a: $(go_os_inotify_files) fmt.gox os.gox strings.gox \\\n+\t\tsyscall.gox\n+\t$(BUILDARCHIVE)\n+os/libinotify.la: os/libinotify.a\n+os/inotify/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) os/inotify\n+\t$(CHECK)\n+.PHONY: os/inotify/check\n+\n os/libsignal.a: $(go_os_signal_files) runtime.gox strconv.gox\n \t$(BUILDARCHIVE)\n os/libsignal.la: os/libsignal.a\n@@ -4576,6 +4817,15 @@ rpc/jsonrpc/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: rpc/jsonrpc/check\n \n+runtime/libdebug.a: $(go_runtime_debug_files) bytes.gox fmt.gox io/ioutil.gox \\\n+\t\tos.gox runtime.gox\n+\t$(BUILDARCHIVE)\n+runtime/libdebug.la: runtime/libdebug.a\n+runtime/debug/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) runtime/debug\n+\t$(CHECK)\n+.PHONY: runtime/debug/check\n+\n runtime/libpprof.a: $(go_runtime_pprof_files) bufio.gox fmt.gox io.gox os.gox \\\n \t\truntime.gox\n \t$(BUILDARCHIVE)\n@@ -4749,6 +4999,10 @@ crypto/blowfish.gox: crypto/libblowfish.a\n \t$(BUILDGOX)\n crypto/cast5.gox: crypto/libcast5.a\n \t$(BUILDGOX)\n+crypto/cipher.gox: crypto/libcipher.a\n+\t$(BUILDGOX)\n+crypto/elliptic.gox: crypto/libelliptic.a\n+\t$(BUILDGOX)\n crypto/hmac.gox: crypto/libhmac.a\n \t$(BUILDGOX)\n crypto/md4.gox: crypto/libmd4.a\n@@ -4775,11 +5029,20 @@ crypto/subtle.gox: crypto/libsubtle.a\n \t$(BUILDGOX)\n crypto/tls.gox: crypto/libtls.a\n \t$(BUILDGOX)\n+crypto/twofish.gox: crypto/libtwofish.a\n+\t$(BUILDGOX)\n crypto/x509.gox: crypto/libx509.a\n \t$(BUILDGOX)\n crypto/xtea.gox: crypto/libxtea.a\n \t$(BUILDGOX)\n \n+crypto/openpgp/armor.gox: crypto/openpgp/libarmor.a\n+\t$(BUILDGOX)\n+crypto/openpgp/error.gox: crypto/openpgp/liberror.a\n+\t$(BUILDGOX)\n+crypto/openpgp/s2k.gox: crypto/openpgp/libs2k.a\n+\t$(BUILDGOX)\n+\n debug/dwarf.gox: debug/libdwarf.a\n \t$(BUILDGOX)\n debug/elf.gox: debug/libelf.a\n@@ -4795,6 +5058,8 @@ debug/proc.gox: debug/libproc.a\n \n encoding/ascii85.gox: encoding/libascii85.a\n \t$(BUILDGOX)\n+encoding/base32.gox: encoding/libbase32.a\n+\t$(BUILDGOX)\n encoding/base64.gox: encoding/libbase64.a\n \t$(BUILDGOX)\n encoding/binary.gox: encoding/libbinary.a\n@@ -4803,6 +5068,8 @@ encoding/git85.gox: encoding/libgit85.a\n \t$(BUILDGOX)\n encoding/hex.gox: encoding/libhex.a\n \t$(BUILDGOX)\n+encoding/line.gox: encoding/libline.a\n+\t$(BUILDGOX)\n encoding/pem.gox: encoding/libpem.a\n \t$(BUILDGOX)\n \n@@ -4857,12 +5124,16 @@ net/dict.gox: net/libdict.a\n net/textproto.gox: net/libtextproto.a\n \t$(BUILDGOX)\n \n+os/inotify.gox: os/libinotify.a\n+\t$(BUILDGOX)\n os/signal.gox: os/libsignal.a\n \t$(BUILDGOX)\n \n rpc/jsonrpc.gox: rpc/libjsonrpc.a\n \t$(BUILDGOX)\n \n+runtime/debug.gox: runtime/libdebug.a\n+\t$(BUILDGOX)\n runtime/pprof.gox: runtime/libpprof.a\n \t$(BUILDGOX)\n "}, {"sha": "aa4c797fb6a6535f36dff7de7b912417feea7148", "filename": "libgo/go/archive/tar/reader_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Farchive%2Ftar%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Farchive%2Ftar%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Freader_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -136,7 +136,7 @@ testLoop:\n \t\t\tbreak\n \t\t}\n \t\tif hdr != nil || err != nil {\n-\t\t\tt.Errorf(\"test %d: Unexpected entry or error: hdr=%v err=%v\", i, err)\n+\t\t\tt.Errorf(\"test %d: Unexpected entry or error: hdr=%v err=%v\", i, hdr, err)\n \t\t}\n \t\tf.Close()\n \t}"}, {"sha": "48b8911400514dec86b93578cfb2fd42e82586a3", "filename": "libgo/go/archive/tar/writer_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Farchive%2Ftar%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Farchive%2Ftar%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fwriter_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -141,7 +141,7 @@ testLoop:\n \t\t\t}\n \t\t}\n \t\tif err := tw.Close(); err != nil {\n-\t\t\tt.Errorf(\"test %d: Failed closing archive: %v\", err)\n+\t\t\tt.Errorf(\"test %d: Failed closing archive: %v\", i, err)\n \t\t\tcontinue testLoop\n \t\t}\n "}, {"sha": "3c24f1467cf8e71b5775a9c40a54954d958ba8d3", "filename": "libgo/go/archive/zip/reader_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -111,7 +111,7 @@ func readTestZip(t *testing.T, zt ZipTest) {\n \tvar b bytes.Buffer\n \t_, err = io.Copy(&b, r)\n \tif err != ChecksumError {\n-\t\tt.Errorf(\"%s: copy error=%v, want %v\", err, ChecksumError)\n+\t\tt.Errorf(\"%s: copy error=%v, want %v\", z.File[0].Name, err, ChecksumError)\n \t}\n }\n \n@@ -144,7 +144,7 @@ func readTestFile(t *testing.T, ft ZipTestFile, f *File) {\n \t}\n \tfor i, b := range b.Bytes() {\n \t\tif b != c[i] {\n-\t\t\tt.Errorf(\"%s: content[%d]=%q want %q\", i, b, c[i])\n+\t\t\tt.Errorf(\"%s: content[%d]=%q want %q\", f.Name, i, b, c[i])\n \t\t\treturn\n \t\t}\n \t}"}, {"sha": "d06b1d4d776efb8d242015260f256abcdf5fb0c0", "filename": "libgo/go/asn1/asn1.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fasn1%2Fasn1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fasn1%2Fasn1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fasn1%2Fasn1.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -591,7 +591,7 @@ func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParam\n \t\tsliceValue := v.(*reflect.SliceValue)\n \t\tsliceValue.Set(reflect.MakeSlice(sliceValue.Type().(*reflect.SliceType), len(newSlice), len(newSlice)))\n \t\tif err1 == nil {\n-\t\t\treflect.ArrayCopy(sliceValue, reflect.NewValue(newSlice).(reflect.ArrayOrSliceValue))\n+\t\t\treflect.Copy(sliceValue, reflect.NewValue(newSlice).(reflect.ArrayOrSliceValue))\n \t\t}\n \t\terr = err1\n \t\treturn\n@@ -683,7 +683,7 @@ func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParam\n \t\tsliceType := fieldType.(*reflect.SliceType)\n \t\tif sliceType.Elem().Kind() == reflect.Uint8 {\n \t\t\tval.Set(reflect.MakeSlice(sliceType, len(innerBytes), len(innerBytes)))\n-\t\t\treflect.ArrayCopy(val, reflect.NewValue(innerBytes).(reflect.ArrayOrSliceValue))\n+\t\t\treflect.Copy(val, reflect.NewValue(innerBytes).(reflect.ArrayOrSliceValue))\n \t\t\treturn\n \t\t}\n \t\tnewSlice, err1 := parseSequenceOf(innerBytes, sliceType, sliceType.Elem())"}, {"sha": "fc981e1da46c4fab2ff04e0d61a3e3082f8539a4", "filename": "libgo/go/big/int_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fbig%2Fint_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fbig%2Fint_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbig%2Fint_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -94,7 +94,7 @@ func testFunZZ(t *testing.T, msg string, f funZZ, a argZZ) {\n \tvar z Int\n \tf(&z, a.x, a.y)\n \tif !isNormalized(&z) {\n-\t\tt.Errorf(\"msg: %v is not normalized\", z, msg)\n+\t\tt.Errorf(\"%s%v is not normalized\", z, msg)\n \t}\n \tif (&z).Cmp(a.z) != 0 {\n \t\tt.Errorf(\"%s%+v\\n\\tgot z = %v; want %v\", msg, a, &z, a.z)"}, {"sha": "e70673a1cbacd10381f247b6419adcbd28f7bf39", "filename": "libgo/go/big/rat.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fbig%2Frat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fbig%2Frat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbig%2Frat.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -35,9 +35,8 @@ func (z *Rat) SetFrac(a, b *Int) *Rat {\n func (z *Rat) SetFrac64(a, b int64) *Rat {\n \tz.a.SetInt64(a)\n \tif b < 0 {\n-\t\tz.b.setUint64(uint64(-b))\n+\t\tb = -b\n \t\tz.a.neg = !z.a.neg\n-\t\treturn z.norm()\n \t}\n \tz.b = z.b.setUint64(uint64(b))\n \treturn z.norm()"}, {"sha": "8f42949b087e3ebd6b5dc61886500cd60f0ead06", "filename": "libgo/go/big/rat_test.go", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fbig%2Frat_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fbig%2Frat_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbig%2Frat_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -257,3 +257,26 @@ func TestIssue820(t *testing.T) {\n \t\tt.Errorf(\"got %s want %s\", z, q)\n \t}\n }\n+\n+\n+var setFrac64Tests = []struct {\n+\ta, b int64\n+\tout  string\n+}{\n+\t{0, 1, \"0\"},\n+\t{0, -1, \"0\"},\n+\t{1, 1, \"1\"},\n+\t{-1, 1, \"-1\"},\n+\t{1, -1, \"-1\"},\n+\t{-1, -1, \"1\"},\n+\t{-9223372036854775808, -9223372036854775808, \"1\"},\n+}\n+\n+func TestRatSetFrac64Rat(t *testing.T) {\n+\tfor i, test := range setFrac64Tests {\n+\t\tx := new(Rat).SetFrac64(test.a, test.b)\n+\t\tif x.RatString() != test.out {\n+\t\t\tt.Errorf(\"#%d got %s want %s\", i, x.RatString(), test.out)\n+\t\t}\n+\t}\n+}"}, {"sha": "c13456a6326b78ec9c3200d932cba7808d551578", "filename": "libgo/go/bufio/bufio.go", "status": "modified", "additions": 33, "deletions": 34, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fbufio%2Fbufio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fbufio%2Fbufio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -128,43 +128,42 @@ func (b *Reader) Peek(n int) ([]byte, os.Error) {\n \n // Read reads data into p.\n // It returns the number of bytes read into p.\n-// If nn < len(p), also returns an error explaining\n-// why the read is short.  At EOF, the count will be\n-// zero and err will be os.EOF.\n-func (b *Reader) Read(p []byte) (nn int, err os.Error) {\n-\tnn = 0\n-\tfor len(p) > 0 {\n-\t\tn := len(p)\n-\t\tif b.w == b.r {\n-\t\t\tif b.err != nil {\n-\t\t\t\treturn nn, b.err\n-\t\t\t}\n-\t\t\tif len(p) >= len(b.buf) {\n-\t\t\t\t// Large read, empty buffer.\n-\t\t\t\t// Read directly into p to avoid copy.\n-\t\t\t\tn, b.err = b.rd.Read(p)\n-\t\t\t\tif n > 0 {\n-\t\t\t\t\tb.lastByte = int(p[n-1])\n-\t\t\t\t\tb.lastRuneSize = -1\n-\t\t\t\t}\n-\t\t\t\tp = p[n:]\n-\t\t\t\tnn += n\n-\t\t\t\tcontinue\n+// It calls Read at most once on the underlying Reader,\n+// hence n may be less than len(p).\n+// At EOF, the count will be zero and err will be os.EOF.\n+func (b *Reader) Read(p []byte) (n int, err os.Error) {\n+\tn = len(p)\n+\tif n == 0 {\n+\t\treturn 0, b.err\n+\t}\n+\tif b.w == b.r {\n+\t\tif b.err != nil {\n+\t\t\treturn 0, b.err\n+\t\t}\n+\t\tif len(p) >= len(b.buf) {\n+\t\t\t// Large read, empty buffer.\n+\t\t\t// Read directly into p to avoid copy.\n+\t\t\tn, b.err = b.rd.Read(p)\n+\t\t\tif n > 0 {\n+\t\t\t\tb.lastByte = int(p[n-1])\n+\t\t\t\tb.lastRuneSize = -1\n \t\t\t}\n-\t\t\tb.fill()\n-\t\t\tcontinue\n+\t\t\treturn n, b.err\n \t\t}\n-\t\tif n > b.w-b.r {\n-\t\t\tn = b.w - b.r\n+\t\tb.fill()\n+\t\tif b.w == b.r {\n+\t\t\treturn 0, b.err\n \t\t}\n-\t\tcopy(p[0:n], b.buf[b.r:])\n-\t\tp = p[n:]\n-\t\tb.r += n\n-\t\tb.lastByte = int(b.buf[b.r-1])\n-\t\tb.lastRuneSize = -1\n-\t\tnn += n\n \t}\n-\treturn nn, nil\n+\n+\tif n > b.w-b.r {\n+\t\tn = b.w - b.r\n+\t}\n+\tcopy(p[0:n], b.buf[b.r:])\n+\tb.r += n\n+\tb.lastByte = int(b.buf[b.r-1])\n+\tb.lastRuneSize = -1\n+\treturn n, nil\n }\n \n // ReadByte reads and returns a single byte.\n@@ -482,7 +481,7 @@ func (b *Writer) WriteRune(rune int) (size int, err os.Error) {\n \t\t\treturn b.WriteString(string(rune))\n \t\t}\n \t}\n-\tsize = utf8.EncodeRune(rune, b.buf[b.n:])\n+\tsize = utf8.EncodeRune(b.buf[b.n:], rune)\n \tb.n += size\n \treturn size, nil\n }"}, {"sha": "059ca6dd223d91ea2a6d42bd989ccb9e1db580e3", "filename": "libgo/go/bufio/bufio_test.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -337,7 +337,7 @@ func TestReadWriteRune(t *testing.T) {\n \t// Write the runes out using WriteRune\n \tbuf := make([]byte, utf8.UTFMax)\n \tfor rune := 0; rune < NRune; rune++ {\n-\t\tsize := utf8.EncodeRune(rune, buf)\n+\t\tsize := utf8.EncodeRune(buf, rune)\n \t\tnbytes, err := w.WriteRune(rune)\n \t\tif err != nil {\n \t\t\tt.Fatalf(\"WriteRune(0x%x) error: %s\", rune, err)\n@@ -351,7 +351,7 @@ func TestReadWriteRune(t *testing.T) {\n \tr := NewReader(byteBuf)\n \t// Read them back with ReadRune\n \tfor rune := 0; rune < NRune; rune++ {\n-\t\tsize := utf8.EncodeRune(rune, buf)\n+\t\tsize := utf8.EncodeRune(buf, rune)\n \t\tnr, nbytes, err := r.ReadRune()\n \t\tif nr != rune || nbytes != size || err != nil {\n \t\t\tt.Fatalf(\"ReadRune(0x%x) got 0x%x,%d not 0x%x,%d (err=%s)\", r, nr, nbytes, r, size, err)\n@@ -397,9 +397,9 @@ func TestWriter(t *testing.T) {\n \t\t\t}\n \t\t\tfor l := 0; l < len(written); l++ {\n \t\t\t\tif written[i] != data[i] {\n-\t\t\t\t\tt.Errorf(\"%s: wrong bytes written\")\n-\t\t\t\t\tt.Errorf(\"want=%s\", data[0:len(written)])\n-\t\t\t\t\tt.Errorf(\"have=%s\", written)\n+\t\t\t\t\tt.Errorf(\"wrong bytes written\")\n+\t\t\t\t\tt.Errorf(\"want=%q\", data[0:len(written)])\n+\t\t\t\t\tt.Errorf(\"have=%q\", written)\n \t\t\t\t}\n \t\t\t}\n \t\t}"}, {"sha": "62cf82810e79204add4496491615bc28d8c1e898", "filename": "libgo/go/bytes/buffer.go", "status": "modified", "additions": 63, "deletions": 2, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fbytes%2Fbuffer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fbytes%2Fbuffer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbuffer.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -19,8 +19,20 @@ type Buffer struct {\n \toff       int               // read at &buf[off], write at &buf[len(buf)]\n \truneBytes [utf8.UTFMax]byte // avoid allocation of slice on each WriteByte or Rune\n \tbootstrap [64]byte          // memory to hold first slice; helps small buffers (Printf) avoid allocation.\n+\tlastRead  readOp            // last read operation, so that Unread* can work correctly.\n }\n \n+// The readOp constants describe the last action performed on\n+// the buffer, so that UnreadRune and UnreadByte can\n+// check for invalid usage.\n+type readOp int\n+\n+const (\n+\topInvalid  readOp = iota // Non-read operation.\n+\topReadRune               // Read rune.\n+\topRead                   // Any other read operation.\n+)\n+\n // Bytes returns a slice of the contents of the unread portion of the buffer;\n // len(b.Bytes()) == b.Len().  If the caller changes the contents of the\n // returned slice, the contents of the buffer will change provided there\n@@ -44,6 +56,7 @@ func (b *Buffer) Len() int { return len(b.buf) - b.off }\n // Truncate discards all but the first n unread bytes from the buffer.\n // It is an error to call b.Truncate(n) with n > b.Len().\n func (b *Buffer) Truncate(n int) {\n+\tb.lastRead = opInvalid\n \tif n == 0 {\n \t\t// Reuse buffer space.\n \t\tb.off = 0\n@@ -82,6 +95,7 @@ func (b *Buffer) grow(n int) int {\n // Write appends the contents of p to the buffer.  The return\n // value n is the length of p; err is always nil.\n func (b *Buffer) Write(p []byte) (n int, err os.Error) {\n+\tb.lastRead = opInvalid\n \tm := b.grow(len(p))\n \tcopy(b.buf[m:], p)\n \treturn len(p), nil\n@@ -90,6 +104,7 @@ func (b *Buffer) Write(p []byte) (n int, err os.Error) {\n // WriteString appends the contents of s to the buffer.  The return\n // value n is the length of s; err is always nil.\n func (b *Buffer) WriteString(s string) (n int, err os.Error) {\n+\tb.lastRead = opInvalid\n \tm := b.grow(len(s))\n \treturn copy(b.buf[m:], s), nil\n }\n@@ -105,6 +120,7 @@ const MinRead = 512\n // Any error except os.EOF encountered during the read\n // is also returned.\n func (b *Buffer) ReadFrom(r io.Reader) (n int64, err os.Error) {\n+\tb.lastRead = opInvalid\n \t// If buffer is empty, reset to recover space.\n \tif b.off >= len(b.buf) {\n \t\tb.Truncate(0)\n@@ -141,6 +157,7 @@ func (b *Buffer) ReadFrom(r io.Reader) (n int64, err os.Error) {\n // occurs. The return value n is the number of bytes written.\n // Any error encountered during the write is also returned.\n func (b *Buffer) WriteTo(w io.Writer) (n int64, err os.Error) {\n+\tb.lastRead = opInvalid\n \tfor b.off < len(b.buf) {\n \t\tm, e := w.Write(b.buf[b.off:])\n \t\tn += int64(m)\n@@ -158,6 +175,7 @@ func (b *Buffer) WriteTo(w io.Writer) (n int64, err os.Error) {\n // The returned error is always nil, but is included\n // to match bufio.Writer's WriteByte.\n func (b *Buffer) WriteByte(c byte) os.Error {\n+\tb.lastRead = opInvalid\n \tm := b.grow(1)\n \tb.buf[m] = c\n \treturn nil\n@@ -172,7 +190,7 @@ func (b *Buffer) WriteRune(r int) (n int, err os.Error) {\n \t\tb.WriteByte(byte(r))\n \t\treturn 1, nil\n \t}\n-\tn = utf8.EncodeRune(r, b.runeBytes[0:])\n+\tn = utf8.EncodeRune(b.runeBytes[0:], r)\n \tb.Write(b.runeBytes[0:n])\n \treturn n, nil\n }\n@@ -182,13 +200,17 @@ func (b *Buffer) WriteRune(r int) (n int, err os.Error) {\n // buffer has no data to return, err is os.EOF even if len(p) is zero;\n // otherwise it is nil.\n func (b *Buffer) Read(p []byte) (n int, err os.Error) {\n+\tb.lastRead = opInvalid\n \tif b.off >= len(b.buf) {\n \t\t// Buffer is empty, reset to recover space.\n \t\tb.Truncate(0)\n \t\treturn 0, os.EOF\n \t}\n \tn = copy(p, b.buf[b.off:])\n \tb.off += n\n+\tif n > 0 {\n+\t\tb.lastRead = opRead\n+\t}\n \treturn\n }\n \n@@ -197,25 +219,31 @@ func (b *Buffer) Read(p []byte) (n int, err os.Error) {\n // If there are fewer than n bytes in the buffer, Next returns the entire buffer.\n // The slice is only valid until the next call to a read or write method.\n func (b *Buffer) Next(n int) []byte {\n+\tb.lastRead = opInvalid\n \tm := b.Len()\n \tif n > m {\n \t\tn = m\n \t}\n \tdata := b.buf[b.off : b.off+n]\n \tb.off += n\n+\tif n > 0 {\n+\t\tb.lastRead = opRead\n+\t}\n \treturn data\n }\n \n // ReadByte reads and returns the next byte from the buffer.\n // If no byte is available, it returns error os.EOF.\n func (b *Buffer) ReadByte() (c byte, err os.Error) {\n+\tb.lastRead = opInvalid\n \tif b.off >= len(b.buf) {\n \t\t// Buffer is empty, reset to recover space.\n \t\tb.Truncate(0)\n \t\treturn 0, os.EOF\n \t}\n \tc = b.buf[b.off]\n \tb.off++\n+\tb.lastRead = opRead\n \treturn c, nil\n }\n \n@@ -225,11 +253,13 @@ func (b *Buffer) ReadByte() (c byte, err os.Error) {\n // If the bytes are an erroneous UTF-8 encoding, it\n // consumes one byte and returns U+FFFD, 1.\n func (b *Buffer) ReadRune() (r int, size int, err os.Error) {\n+\tb.lastRead = opInvalid\n \tif b.off >= len(b.buf) {\n \t\t// Buffer is empty, reset to recover space.\n \t\tb.Truncate(0)\n \t\treturn 0, 0, os.EOF\n \t}\n+\tb.lastRead = opReadRune\n \tc := b.buf[b.off]\n \tif c < utf8.RuneSelf {\n \t\tb.off++\n@@ -240,9 +270,40 @@ func (b *Buffer) ReadRune() (r int, size int, err os.Error) {\n \treturn r, n, nil\n }\n \n+// UnreadRune unreads the last rune returned by ReadRune.\n+// If the most recent read or write operation on the buffer was\n+// not a ReadRune, UnreadRune returns an error.  (In this regard\n+// it is stricter than UnreadByte, which will unread the last byte\n+// from any read operation.)\n+func (b *Buffer) UnreadRune() os.Error {\n+\tif b.lastRead != opReadRune {\n+\t\treturn os.ErrorString(\"bytes.Buffer: UnreadRune: previous operation was not ReadRune\")\n+\t}\n+\tb.lastRead = opInvalid\n+\tif b.off > 0 {\n+\t\t_, n := utf8.DecodeLastRune(b.buf[0:b.off])\n+\t\tb.off -= n\n+\t}\n+\treturn nil\n+}\n+\n+// UnreadByte unreads the last byte returned by the most recent\n+// read operation.  If write has happened since the last read, UnreadByte\n+// returns an error.\n+func (b *Buffer) UnreadByte() os.Error {\n+\tif b.lastRead != opReadRune && b.lastRead != opRead {\n+\t\treturn os.ErrorString(\"bytes.Buffer: UnreadByte: previous operation was not a read\")\n+\t}\n+\tb.lastRead = opInvalid\n+\tif b.off > 0 {\n+\t\tb.off--\n+\t}\n+\treturn nil\n+}\n+\n // NewBuffer creates and initializes a new Buffer using buf as its initial\n // contents.  It is intended to prepare a Buffer to read existing data.  It\n-// can also be used to to size the internal buffer for writing.  To do that,\n+// can also be used to size the internal buffer for writing.  To do that,\n // buf should have the desired capacity but a length of zero.\n func NewBuffer(buf []byte) *Buffer { return &Buffer{buf: buf} }\n "}, {"sha": "509793d24a8293331ffcc297d6493a42d8c0ca85", "filename": "libgo/go/bytes/buffer_test.go", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fbytes%2Fbuffer_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fbytes%2Fbuffer_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbuffer_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -165,7 +165,7 @@ func TestBasicOperations(t *testing.T) {\n \t\t\tt.Error(\"ReadByte unexpected eof\")\n \t\t}\n \t\tif c != data[1] {\n-\t\t\tt.Error(\"ReadByte wrong value c=%v\", c)\n+\t\t\tt.Errorf(\"ReadByte wrong value c=%v\", c)\n \t\t}\n \t\tc, err = buf.ReadByte()\n \t\tif err == nil {\n@@ -272,13 +272,13 @@ func TestRuneIO(t *testing.T) {\n \tvar buf Buffer\n \tn := 0\n \tfor r := 0; r < NRune; r++ {\n-\t\tsize := utf8.EncodeRune(r, b[n:])\n+\t\tsize := utf8.EncodeRune(b[n:], r)\n \t\tnbytes, err := buf.WriteRune(r)\n \t\tif err != nil {\n-\t\t\tt.Fatalf(\"WriteRune(0x%x) error: %s\", r, err)\n+\t\t\tt.Fatalf(\"WriteRune(%U) error: %s\", r, err)\n \t\t}\n \t\tif nbytes != size {\n-\t\t\tt.Fatalf(\"WriteRune(0x%x) expected %d, got %d\", r, size, nbytes)\n+\t\t\tt.Fatalf(\"WriteRune(%U) expected %d, got %d\", r, size, nbytes)\n \t\t}\n \t\tn += size\n \t}\n@@ -289,12 +289,27 @@ func TestRuneIO(t *testing.T) {\n \t\tt.Fatalf(\"incorrect result from WriteRune: %q not %q\", buf.Bytes(), b)\n \t}\n \n+\tp := make([]byte, utf8.UTFMax)\n \t// Read it back with ReadRune\n \tfor r := 0; r < NRune; r++ {\n-\t\tsize := utf8.EncodeRune(r, b)\n+\t\tsize := utf8.EncodeRune(p, r)\n \t\tnr, nbytes, err := buf.ReadRune()\n \t\tif nr != r || nbytes != size || err != nil {\n-\t\t\tt.Fatalf(\"ReadRune(0x%x) got 0x%x,%d not 0x%x,%d (err=%s)\", r, nr, nbytes, r, size, err)\n+\t\t\tt.Fatalf(\"ReadRune(%U) got %U,%d not %U,%d (err=%s)\", r, nr, nbytes, r, size, err)\n+\t\t}\n+\t}\n+\n+\t// Check that UnreadRune works\n+\tbuf.Reset()\n+\tbuf.Write(b)\n+\tfor r := 0; r < NRune; r++ {\n+\t\tr1, size, _ := buf.ReadRune()\n+\t\tif err := buf.UnreadRune(); err != nil {\n+\t\t\tt.Fatalf(\"UnreadRune(%U) got error %q\", r, err)\n+\t\t}\n+\t\tr2, nbytes, err := buf.ReadRune()\n+\t\tif r1 != r2 || r1 != r || nbytes != size || err != nil {\n+\t\t\tt.Fatalf(\"ReadRune(%U) after UnreadRune got %U,%d not %U,%d (err=%s)\", r, r2, nbytes, r, size, err)\n \t\t}\n \t}\n }"}, {"sha": "bfe2ef39db500adb860c90f1ba2c4d607cd7bce7", "filename": "libgo/go/bytes/bytes.go", "status": "modified", "additions": 21, "deletions": 44, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fbytes%2Fbytes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fbytes%2Fbytes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -165,6 +165,25 @@ func IndexAny(s []byte, chars string) int {\n \treturn -1\n }\n \n+// LastIndexAny interprets s as a sequence of UTF-8-encoded Unicode code\n+// points.  It returns the byte index of the last occurrence in s of any of\n+// the Unicode code points in chars.  It returns -1 if chars is empty or if\n+// there is no code point in common.\n+func LastIndexAny(s []byte, chars string) int {\n+\tif len(chars) > 0 {\n+\t\tfor i := len(s); i > 0; {\n+\t\t\trune, size := utf8.DecodeLastRune(s[0:i])\n+\t\t\ti -= size\n+\t\t\tfor _, m := range chars {\n+\t\t\t\tif rune == m {\n+\t\t\t\t\treturn i\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn -1\n+}\n+\n // Generic split: splits after each instance of sep,\n // including sepSave bytes of sep in the subarrays.\n func genSplit(s, sep []byte, sepSave, n int) [][]byte {\n@@ -328,7 +347,7 @@ func Map(mapping func(rune int) int, s []byte) []byte {\n \t\t\t\tcopy(nb, b[0:nbytes])\n \t\t\t\tb = nb\n \t\t\t}\n-\t\t\tnbytes += utf8.EncodeRune(rune, b[nbytes:maxbytes])\n+\t\t\tnbytes += utf8.EncodeRune(b[nbytes:maxbytes], rune)\n \t\t}\n \t\ti += wid\n \t}\n@@ -528,53 +547,11 @@ func TrimRight(s []byte, cutset string) []byte {\n }\n \n // TrimSpace returns a subslice of s by slicing off all leading and\n-// trailing white space, as as defined by Unicode.\n+// trailing white space, as defined by Unicode.\n func TrimSpace(s []byte) []byte {\n \treturn TrimFunc(s, unicode.IsSpace)\n }\n \n-// How big to make a byte array when growing.\n-// Heuristic: Scale by 50% to give n log n time.\n-func resize(n int) int {\n-\tif n < 16 {\n-\t\tn = 16\n-\t}\n-\treturn n + n/2\n-}\n-\n-// Add appends the contents of t to the end of s and returns the result.\n-// If s has enough capacity, it is extended in place; otherwise a\n-// new array is allocated and returned.\n-func Add(s, t []byte) []byte { // TODO\n-\tlens := len(s)\n-\tlent := len(t)\n-\tif lens+lent <= cap(s) {\n-\t\ts = s[0 : lens+lent]\n-\t} else {\n-\t\tnews := make([]byte, lens+lent, resize(lens+lent))\n-\t\tcopy(news, s)\n-\t\ts = news\n-\t}\n-\tcopy(s[lens:lens+lent], t)\n-\treturn s\n-}\n-\n-// AddByte appends byte t to the end of s and returns the result.\n-// If s has enough capacity, it is extended in place; otherwise a\n-// new array is allocated and returned.\n-func AddByte(s []byte, t byte) []byte { // TODO\n-\tlens := len(s)\n-\tif lens+1 <= cap(s) {\n-\t\ts = s[0 : lens+1]\n-\t} else {\n-\t\tnews := make([]byte, lens+1, resize(lens+1))\n-\t\tcopy(news, s)\n-\t\ts = news\n-\t}\n-\ts[lens] = t\n-\treturn s\n-}\n-\n // Runes returns a slice of runes (Unicode code points) equivalent to s.\n func Runes(s []byte) []int {\n \tt := make([]int, utf8.RuneCount(s))"}, {"sha": "063686ec5d6e7d01cc28c44b4053bf1da8ef7f8e", "filename": "libgo/go/bytes/bytes_test.go", "status": "modified", "additions": 25, "deletions": 45, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fbytes%2Fbytes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fbytes%2Fbytes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -128,6 +128,20 @@ var indexAnyTests = []BinOpTest{\n \t{dots + dots + dots, \" \", -1},\n }\n \n+var lastIndexAnyTests = []BinOpTest{\n+\t{\"\", \"\", -1},\n+\t{\"\", \"a\", -1},\n+\t{\"\", \"abc\", -1},\n+\t{\"a\", \"\", -1},\n+\t{\"a\", \"a\", 0},\n+\t{\"aaa\", \"a\", 2},\n+\t{\"abc\", \"xyz\", -1},\n+\t{\"abc\", \"ab\", 1},\n+\t{\"a\u263ab\u263bc\u2639d\", \"uvw\u263bxyz\", 2 + len(\"\u263a\")},\n+\t{\"a.RegExp*\", \".(|)*+?^$[]\", 8},\n+\t{dots + dots + dots, \" \", -1},\n+}\n+\n var indexRuneTests = []BinOpTest{\n \t{\"\", \"a\", -1},\n \t{\"\", \"\u263a\", -1},\n@@ -150,18 +164,23 @@ func runIndexTests(t *testing.T, f func(s, sep []byte) int, funcName string, tes\n \t}\n }\n \n-func TestIndex(t *testing.T)     { runIndexTests(t, Index, \"Index\", indexTests) }\n-func TestLastIndex(t *testing.T) { runIndexTests(t, LastIndex, \"LastIndex\", lastIndexTests) }\n-func TestIndexAny(t *testing.T) {\n-\tfor _, test := range indexAnyTests {\n+func runIndexAnyTests(t *testing.T, f func(s []byte, chars string) int, funcName string, testCases []BinOpTest) {\n+\tfor _, test := range testCases {\n \t\ta := []byte(test.a)\n-\t\tactual := IndexAny(a, test.b)\n+\t\tactual := f(a, test.b)\n \t\tif actual != test.i {\n-\t\t\tt.Errorf(\"IndexAny(%q,%q) = %v; want %v\", a, test.b, actual, test.i)\n+\t\t\tt.Errorf(\"%s(%q,%q) = %v; want %v\", funcName, a, test.b, actual, test.i)\n \t\t}\n \t}\n }\n \n+func TestIndex(t *testing.T)     { runIndexTests(t, Index, \"Index\", indexTests) }\n+func TestLastIndex(t *testing.T) { runIndexTests(t, LastIndex, \"LastIndex\", lastIndexTests) }\n+func TestIndexAny(t *testing.T)  { runIndexAnyTests(t, IndexAny, \"IndexAny\", indexAnyTests) }\n+func TestLastIndexAny(t *testing.T) {\n+\trunIndexAnyTests(t, LastIndexAny, \"LastIndexAny\", lastIndexAnyTests)\n+}\n+\n func TestIndexByte(t *testing.T) {\n \tfor _, tt := range indexTests {\n \t\tif len(tt.b) != 1 {\n@@ -554,45 +573,6 @@ func TestToLower(t *testing.T) { runStringTests(t, ToLower, \"ToLower\", lowerTest\n \n func TestTrimSpace(t *testing.T) { runStringTests(t, TrimSpace, \"TrimSpace\", trimSpaceTests) }\n \n-type AddTest struct {\n-\ts, t string\n-\tcap  int\n-}\n-\n-var addtests = []AddTest{\n-\t{\"\", \"\", 0},\n-\t{\"a\", \"\", 1},\n-\t{\"a\", \"b\", 1},\n-\t{\"abc\", \"def\", 100},\n-}\n-\n-func TestAdd(t *testing.T) {\n-\tfor _, test := range addtests {\n-\t\tb := make([]byte, len(test.s), test.cap)\n-\t\tcopy(b, test.s)\n-\t\tb = Add(b, []byte(test.t))\n-\t\tif string(b) != test.s+test.t {\n-\t\t\tt.Errorf(\"Add(%q,%q) = %q\", test.s, test.t, string(b))\n-\t\t}\n-\t}\n-}\n-\n-func TestAddByte(t *testing.T) {\n-\tconst N = 2e5\n-\tb := make([]byte, 0)\n-\tfor i := 0; i < N; i++ {\n-\t\tb = AddByte(b, byte(i))\n-\t}\n-\tif len(b) != N {\n-\t\tt.Errorf(\"AddByte: too small; expected %d got %d\", N, len(b))\n-\t}\n-\tfor i, c := range b {\n-\t\tif c != byte(i) {\n-\t\t\tt.Fatalf(\"AddByte: b[%d] should be %d is %d\", i, c, byte(i))\n-\t\t}\n-\t}\n-}\n-\n type RepeatTest struct {\n \tin, out string\n \tcount   int"}, {"sha": "d6a3ca48026b46cc7028faaca133e3b72af828c2", "filename": "libgo/go/cmath/asin.go", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcmath%2Fasin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcmath%2Fasin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmath%2Fasin.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -51,30 +51,30 @@ import \"math\"\n func Asin(x complex128) complex128 {\n \tif imag(x) == 0 {\n \t\tif math.Fabs(real(x)) > 1 {\n-\t\t\treturn cmplx(math.Pi/2, 0) // DOMAIN error\n+\t\t\treturn complex(math.Pi/2, 0) // DOMAIN error\n \t\t}\n-\t\treturn cmplx(math.Asin(real(x)), 0)\n+\t\treturn complex(math.Asin(real(x)), 0)\n \t}\n-\tct := cmplx(-imag(x), real(x)) // i * x\n+\tct := complex(-imag(x), real(x)) // i * x\n \txx := x * x\n-\tx1 := cmplx(1-real(xx), -imag(xx)) // 1 - x*x\n-\tx2 := Sqrt(x1)                     // x2 = sqrt(1 - x*x)\n+\tx1 := complex(1-real(xx), -imag(xx)) // 1 - x*x\n+\tx2 := Sqrt(x1)                       // x2 = sqrt(1 - x*x)\n \tw := Log(ct + x2)\n-\treturn cmplx(imag(w), -real(w)) // -i * w\n+\treturn complex(imag(w), -real(w)) // -i * w\n }\n \n // Asinh returns the inverse hyperbolic sine of x.\n func Asinh(x complex128) complex128 {\n \t// TODO check range\n \tif imag(x) == 0 {\n \t\tif math.Fabs(real(x)) > 1 {\n-\t\t\treturn cmplx(math.Pi/2, 0) // DOMAIN error\n+\t\t\treturn complex(math.Pi/2, 0) // DOMAIN error\n \t\t}\n-\t\treturn cmplx(math.Asinh(real(x)), 0)\n+\t\treturn complex(math.Asinh(real(x)), 0)\n \t}\n \txx := x * x\n-\tx1 := cmplx(1+real(xx), imag(xx)) // 1 + x*x\n-\treturn Log(x + Sqrt(x1))          // log(x + sqrt(1 + x*x))\n+\tx1 := complex(1+real(xx), imag(xx)) // 1 + x*x\n+\treturn Log(x + Sqrt(x1))            // log(x + sqrt(1 + x*x))\n }\n \n // Complex circular arc cosine\n@@ -93,16 +93,16 @@ func Asinh(x complex128) complex128 {\n // Acos returns the inverse cosine of x.\n func Acos(x complex128) complex128 {\n \tw := Asin(x)\n-\treturn cmplx(math.Pi/2-real(w), -imag(w))\n+\treturn complex(math.Pi/2-real(w), -imag(w))\n }\n \n // Acosh returns the inverse hyperbolic cosine of x.\n func Acosh(x complex128) complex128 {\n \tw := Acos(x)\n \tif imag(w) <= 0 {\n-\t\treturn cmplx(-imag(w), real(w)) // i * w\n+\t\treturn complex(-imag(w), real(w)) // i * w\n \t}\n-\treturn cmplx(imag(w), -real(w)) // -i * w\n+\treturn complex(imag(w), -real(w)) // -i * w\n }\n \n // Complex circular arc tangent\n@@ -159,12 +159,12 @@ func Atan(x complex128) complex128 {\n \t}\n \tt = imag(x) + 1\n \tc := (x2 + t*t) / b\n-\treturn cmplx(w, 0.25*math.Log(c))\n+\treturn complex(w, 0.25*math.Log(c))\n }\n \n // Atanh returns the inverse hyperbolic tangent of x.\n func Atanh(x complex128) complex128 {\n-\tz := cmplx(-imag(x), real(x)) // z = i * x\n+\tz := complex(-imag(x), real(x)) // z = i * x\n \tz = Atan(z)\n-\treturn cmplx(imag(z), -real(z)) // z = -i * z\n+\treturn complex(imag(z), -real(z)) // z = -i * z\n }"}, {"sha": "6a595b0a60953f1a35a41f000d4dc343025d6646", "filename": "libgo/go/cmath/cmath_test.go", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcmath%2Fcmath_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcmath%2Fcmath_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmath%2Fcmath_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -355,15 +355,15 @@ var expSC = []complex128{\n \tNaN(),\n }\n var vcIsNaNSC = []complex128{\n-\tcmplx(math.Inf(-1), math.Inf(-1)),\n-\tcmplx(math.Inf(-1), math.NaN()),\n-\tcmplx(math.NaN(), math.Inf(-1)),\n-\tcmplx(0, math.NaN()),\n-\tcmplx(math.NaN(), 0),\n-\tcmplx(math.Inf(1), math.Inf(1)),\n-\tcmplx(math.Inf(1), math.NaN()),\n-\tcmplx(math.NaN(), math.Inf(1)),\n-\tcmplx(math.NaN(), math.NaN()),\n+\tcomplex(math.Inf(-1), math.Inf(-1)),\n+\tcomplex(math.Inf(-1), math.NaN()),\n+\tcomplex(math.NaN(), math.Inf(-1)),\n+\tcomplex(0, math.NaN()),\n+\tcomplex(math.NaN(), 0),\n+\tcomplex(math.Inf(1), math.Inf(1)),\n+\tcomplex(math.Inf(1), math.NaN()),\n+\tcomplex(math.NaN(), math.Inf(1)),\n+\tcomplex(math.NaN(), math.NaN()),\n }\n var isNaNSC = []bool{\n \tfalse,\n@@ -615,7 +615,7 @@ func TestExp(t *testing.T) {\n func TestIsNaN(t *testing.T) {\n \tfor i := 0; i < len(vcIsNaNSC); i++ {\n \t\tif f := IsNaN(vcIsNaNSC[i]); isNaNSC[i] != f {\n-\t\t\tt.Errorf(\"IsNaN(%g) = %g, want %g\", vcIsNaNSC[i], f, isNaNSC[i])\n+\t\t\tt.Errorf(\"IsNaN(%v) = %v, want %v\", vcIsNaNSC[i], f, isNaNSC[i])\n \t\t}\n \t}\n }\n@@ -656,7 +656,7 @@ func TestPolar(t *testing.T) {\n \t}\n }\n func TestPow(t *testing.T) {\n-\tvar a = cmplx(float64(3), float64(3))\n+\tvar a = complex(3.0, 3.0)\n \tfor i := 0; i < len(vc); i++ {\n \t\tif f := Pow(a, vc[i]); !cSoclose(pow[i], f, 4e-15) {\n \t\t\tt.Errorf(\"Pow(%g, %g) = %g, want %g\", a, vc[i], f, pow[i])\n@@ -743,82 +743,82 @@ func TestTanh(t *testing.T) {\n \n func BenchmarkAbs(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n-\t\tAbs(cmplx(2.5, 3.5))\n+\t\tAbs(complex(2.5, 3.5))\n \t}\n }\n func BenchmarkAcos(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n-\t\tAcos(cmplx(2.5, 3.5))\n+\t\tAcos(complex(2.5, 3.5))\n \t}\n }\n func BenchmarkAcosh(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n-\t\tAcosh(cmplx(2.5, 3.5))\n+\t\tAcosh(complex(2.5, 3.5))\n \t}\n }\n func BenchmarkAsin(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n-\t\tAsin(cmplx(2.5, 3.5))\n+\t\tAsin(complex(2.5, 3.5))\n \t}\n }\n func BenchmarkAsinh(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n-\t\tAsinh(cmplx(2.5, 3.5))\n+\t\tAsinh(complex(2.5, 3.5))\n \t}\n }\n func BenchmarkAtan(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n-\t\tAtan(cmplx(2.5, 3.5))\n+\t\tAtan(complex(2.5, 3.5))\n \t}\n }\n func BenchmarkAtanh(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n-\t\tAtanh(cmplx(2.5, 3.5))\n+\t\tAtanh(complex(2.5, 3.5))\n \t}\n }\n func BenchmarkConj(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n-\t\tConj(cmplx(2.5, 3.5))\n+\t\tConj(complex(2.5, 3.5))\n \t}\n }\n func BenchmarkCos(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n-\t\tCos(cmplx(2.5, 3.5))\n+\t\tCos(complex(2.5, 3.5))\n \t}\n }\n func BenchmarkCosh(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n-\t\tCosh(cmplx(2.5, 3.5))\n+\t\tCosh(complex(2.5, 3.5))\n \t}\n }\n func BenchmarkExp(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n-\t\tExp(cmplx(2.5, 3.5))\n+\t\tExp(complex(2.5, 3.5))\n \t}\n }\n func BenchmarkLog(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n-\t\tLog(cmplx(2.5, 3.5))\n+\t\tLog(complex(2.5, 3.5))\n \t}\n }\n func BenchmarkLog10(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n-\t\tLog10(cmplx(2.5, 3.5))\n+\t\tLog10(complex(2.5, 3.5))\n \t}\n }\n func BenchmarkPhase(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n-\t\tPhase(cmplx(2.5, 3.5))\n+\t\tPhase(complex(2.5, 3.5))\n \t}\n }\n func BenchmarkPolar(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n-\t\tPolar(cmplx(2.5, 3.5))\n+\t\tPolar(complex(2.5, 3.5))\n \t}\n }\n func BenchmarkPow(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n-\t\tPow(cmplx(2.5, 3.5), cmplx(2.5, 3.5))\n+\t\tPow(complex(2.5, 3.5), complex(2.5, 3.5))\n \t}\n }\n func BenchmarkRect(b *testing.B) {\n@@ -828,26 +828,26 @@ func BenchmarkRect(b *testing.B) {\n }\n func BenchmarkSin(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n-\t\tSin(cmplx(2.5, 3.5))\n+\t\tSin(complex(2.5, 3.5))\n \t}\n }\n func BenchmarkSinh(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n-\t\tSinh(cmplx(2.5, 3.5))\n+\t\tSinh(complex(2.5, 3.5))\n \t}\n }\n func BenchmarkSqrt(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n-\t\tSqrt(cmplx(2.5, 3.5))\n+\t\tSqrt(complex(2.5, 3.5))\n \t}\n }\n func BenchmarkTan(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n-\t\tTan(cmplx(2.5, 3.5))\n+\t\tTan(complex(2.5, 3.5))\n \t}\n }\n func BenchmarkTanh(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n-\t\tTanh(cmplx(2.5, 3.5))\n+\t\tTanh(complex(2.5, 3.5))\n \t}\n }"}, {"sha": "776b57da7b7a5aaacf33f347ae91175149fe6525", "filename": "libgo/go/cmath/conj.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcmath%2Fconj.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcmath%2Fconj.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmath%2Fconj.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -5,4 +5,4 @@\n package cmath\n \n // Conj returns the complex conjugate of x.\n-func Conj(x complex128) complex128 { return cmplx(real(x), -imag(x)) }\n+func Conj(x complex128) complex128 { return complex(real(x), -imag(x)) }"}, {"sha": "64c1ef409399001d611b85761b8d33bae6a1ec03", "filename": "libgo/go/cmath/exp.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcmath%2Fexp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcmath%2Fexp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmath%2Fexp.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -51,5 +51,5 @@ import \"math\"\n func Exp(x complex128) complex128 {\n \tr := math.Exp(real(x))\n \ts, c := math.Sincos(imag(x))\n-\treturn cmplx(r*c, r*s)\n+\treturn complex(r*c, r*s)\n }"}, {"sha": "f23d2dea7874a030c659b76c40020370a63267f6", "filename": "libgo/go/cmath/isinf.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcmath%2Fisinf.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcmath%2Fisinf.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmath%2Fisinf.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -14,8 +14,8 @@ func IsInf(x complex128) bool {\n \treturn false\n }\n \n-// Inf returns a complex infinity, cmplx(+Inf, +Inf).\n+// Inf returns a complex infinity, complex(+Inf, +Inf).\n func Inf() complex128 {\n \tinf := math.Inf(1)\n-\treturn cmplx(inf, inf)\n+\treturn complex(inf, inf)\n }"}, {"sha": "2063bb8356619c854918c2ed1c80275268048960", "filename": "libgo/go/cmath/isnan.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcmath%2Fisnan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcmath%2Fisnan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmath%2Fisnan.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -21,5 +21,5 @@ func IsNaN(x complex128) bool {\n // NaN returns a complex ``not-a-number'' value.\n func NaN() complex128 {\n \tnan := math.NaN()\n-\treturn cmplx(nan, nan)\n+\treturn complex(nan, nan)\n }"}, {"sha": "8e6964fee89c010b01984977d86f508f83639101", "filename": "libgo/go/cmath/log.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcmath%2Flog.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcmath%2Flog.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmath%2Flog.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -55,7 +55,7 @@ import \"math\"\n \n // Log returns the natural logarithm of x.\n func Log(x complex128) complex128 {\n-\treturn cmplx(math.Log(Abs(x)), Phase(x))\n+\treturn complex(math.Log(Abs(x)), Phase(x))\n }\n \n // Log10 returns the decimal logarithm of x."}, {"sha": "68e1207c674719223eb1811d3dc329cb13402b45", "filename": "libgo/go/cmath/pow.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcmath%2Fpow.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcmath%2Fpow.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmath%2Fpow.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -46,7 +46,7 @@ import \"math\"\n func Pow(x, y complex128) complex128 {\n \tmodulus := Abs(x)\n \tif modulus == 0 {\n-\t\treturn cmplx(0, 0)\n+\t\treturn complex(0, 0)\n \t}\n \tr := math.Pow(modulus, real(y))\n \targ := Phase(x)\n@@ -56,5 +56,5 @@ func Pow(x, y complex128) complex128 {\n \t\ttheta += imag(y) * math.Log(modulus)\n \t}\n \ts, c := math.Sincos(theta)\n-\treturn cmplx(r*c, r*s)\n+\treturn complex(r*c, r*s)\n }"}, {"sha": "b955f0bf7d575c6e063dfb58688f3153b48f107e", "filename": "libgo/go/cmath/rect.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcmath%2Frect.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcmath%2Frect.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmath%2Frect.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -9,5 +9,5 @@ import \"math\"\n // Rect returns the complex number x with polar coordinates r, \u03b8.\n func Rect(r, \u03b8 float64) complex128 {\n \ts, c := math.Sincos(\u03b8)\n-\treturn cmplx(r*c, r*s)\n+\treturn complex(r*c, r*s)\n }"}, {"sha": "8900ecddea3079b02336ea756dc08ae2fd0fb986", "filename": "libgo/go/cmath/sin.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcmath%2Fsin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcmath%2Fsin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmath%2Fsin.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -53,7 +53,7 @@ import \"math\"\n func Sin(x complex128) complex128 {\n \ts, c := math.Sincos(real(x))\n \tsh, ch := sinhcosh(imag(x))\n-\treturn cmplx(s*ch, c*sh)\n+\treturn complex(s*ch, c*sh)\n }\n \n // Complex hyperbolic sine\n@@ -73,7 +73,7 @@ func Sin(x complex128) complex128 {\n func Sinh(x complex128) complex128 {\n \ts, c := math.Sincos(imag(x))\n \tsh, ch := sinhcosh(real(x))\n-\treturn cmplx(c*sh, s*ch)\n+\treturn complex(c*sh, s*ch)\n }\n \n // Complex circular cosine\n@@ -98,7 +98,7 @@ func Sinh(x complex128) complex128 {\n func Cos(x complex128) complex128 {\n \ts, c := math.Sincos(real(x))\n \tsh, ch := sinhcosh(imag(x))\n-\treturn cmplx(c*ch, -s*sh)\n+\treturn complex(c*ch, -s*sh)\n }\n \n // Complex hyperbolic cosine\n@@ -117,7 +117,7 @@ func Cos(x complex128) complex128 {\n func Cosh(x complex128) complex128 {\n \ts, c := math.Sincos(imag(x))\n \tsh, ch := sinhcosh(real(x))\n-\treturn cmplx(c*ch, s*sh)\n+\treturn complex(c*ch, s*sh)\n }\n \n // calculate sinh and cosh"}, {"sha": "e77a9b9df216caa48bd6f97d25710d5d690673a4", "filename": "libgo/go/cmath/sqrt.go", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcmath%2Fsqrt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcmath%2Fsqrt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmath%2Fsqrt.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -57,20 +57,20 @@ import \"math\"\n func Sqrt(x complex128) complex128 {\n \tif imag(x) == 0 {\n \t\tif real(x) == 0 {\n-\t\t\treturn cmplx(0, 0)\n+\t\t\treturn complex(0, 0)\n \t\t}\n \t\tif real(x) < 0 {\n-\t\t\treturn cmplx(0, math.Sqrt(-real(x)))\n+\t\t\treturn complex(0, math.Sqrt(-real(x)))\n \t\t}\n-\t\treturn cmplx(math.Sqrt(real(x)), 0)\n+\t\treturn complex(math.Sqrt(real(x)), 0)\n \t}\n \tif real(x) == 0 {\n \t\tif imag(x) < 0 {\n \t\t\tr := math.Sqrt(-0.5 * imag(x))\n-\t\t\treturn cmplx(r, -r)\n+\t\t\treturn complex(r, -r)\n \t\t}\n \t\tr := math.Sqrt(0.5 * imag(x))\n-\t\treturn cmplx(r, r)\n+\t\treturn complex(r, r)\n \t}\n \ta := real(x)\n \tb := imag(x)\n@@ -97,7 +97,7 @@ func Sqrt(x complex128) complex128 {\n \t\tr *= scale\n \t}\n \tif b < 0 {\n-\t\treturn cmplx(t, -r)\n+\t\treturn complex(t, -r)\n \t}\n-\treturn cmplx(t, r)\n+\treturn complex(t, r)\n }"}, {"sha": "94b517521ec8dff9efe35a1a3a2c5ac2aba735b1", "filename": "libgo/go/cmath/tan.go", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcmath%2Ftan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcmath%2Ftan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmath%2Ftan.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -64,7 +64,7 @@ func Tan(x complex128) complex128 {\n \tif d == 0 {\n \t\treturn Inf()\n \t}\n-\treturn cmplx(math.Sin(2*real(x))/d, math.Sinh(2*imag(x))/d)\n+\treturn complex(math.Sin(2*real(x))/d, math.Sinh(2*imag(x))/d)\n }\n \n // Complex hyperbolic tangent\n@@ -85,7 +85,7 @@ func Tanh(x complex128) complex128 {\n \tif d == 0 {\n \t\treturn Inf()\n \t}\n-\treturn cmplx(math.Sinh(2*real(x))/d, math.Sin(2*imag(x))/d)\n+\treturn complex(math.Sinh(2*real(x))/d, math.Sin(2*imag(x))/d)\n }\n \n // Program to subtract nearest integer multiple of PI\n@@ -114,11 +114,11 @@ func tanSeries(z complex128) float64 {\n \tx = reducePi(x)\n \tx = x * x\n \ty = y * y\n-\tx2 := float64(1)\n-\ty2 := float64(1)\n-\tf := float64(1)\n-\trn := float64(0)\n-\td := float64(0)\n+\tx2 := 1.0\n+\ty2 := 1.0\n+\tf := 1.0\n+\trn := 0.0\n+\td := 0.0\n \tfor {\n \t\trn += 1\n \t\tf *= rn\n@@ -180,5 +180,5 @@ func Cot(x complex128) complex128 {\n \tif d == 0 {\n \t\treturn Inf()\n \t}\n-\treturn cmplx(math.Sin(2*real(x))/d, -math.Sinh(2*imag(x))/d)\n+\treturn complex(math.Sin(2*real(x))/d, -math.Sinh(2*imag(x))/d)\n }"}, {"sha": "591b35c4463e44421d547a7e1fdb2859e4c88790", "filename": "libgo/go/compress/flate/deflate.go", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -89,6 +89,10 @@ type compressor struct {\n \t// (1 << logWindowSize) - 1.\n \twindowMask int\n \n+\teof      bool // has eof been reached on input?\n+\tsync     bool // writer wants to flush\n+\tsyncChan chan os.Error\n+\n \t// hashHead[hashValue] contains the largest inputIndex with the specified hash value\n \thashHead []int\n \n@@ -124,6 +128,9 @@ func (d *compressor) flush() os.Error {\n }\n \n func (d *compressor) fillWindow(index int) (int, os.Error) {\n+\tif d.sync {\n+\t\treturn index, nil\n+\t}\n \twSize := d.windowMask + 1\n \tif index >= wSize+wSize-(minMatchLength+maxMatchLength) {\n \t\t// shift the window by wSize\n@@ -142,12 +149,14 @@ func (d *compressor) fillWindow(index int) (int, os.Error) {\n \t\t\td.hashPrev[i] = max(h-wSize, -1)\n \t\t}\n \t}\n-\tvar count int\n-\tvar err os.Error\n-\tcount, err = io.ReadAtLeast(d.r, d.window[d.windowEnd:], 1)\n+\tcount, err := d.r.Read(d.window[d.windowEnd:])\n \td.windowEnd += count\n+\tif count == 0 && err == nil {\n+\t\td.sync = true\n+\t}\n \tif err == os.EOF {\n-\t\treturn index, nil\n+\t\td.eof = true\n+\t\terr = nil\n \t}\n \treturn index, err\n }\n@@ -227,10 +236,17 @@ func (d *compressor) storedDeflate() os.Error {\n \tbuf := make([]byte, maxStoreBlockSize)\n \tfor {\n \t\tn, err := d.r.Read(buf)\n-\t\tif n > 0 {\n+\t\tif n == 0 && err == nil {\n+\t\t\td.sync = true\n+\t\t}\n+\t\tif n > 0 || d.sync {\n \t\t\tif err := d.writeStoredBlock(buf[0:n]); err != nil {\n \t\t\t\treturn err\n \t\t\t}\n+\t\t\tif d.sync {\n+\t\t\t\td.syncChan <- nil\n+\t\t\t\td.sync = false\n+\t\t\t}\n \t\t}\n \t\tif err != nil {\n \t\t\tif err == os.EOF {\n@@ -275,6 +291,7 @@ func (d *compressor) doDeflate() (err os.Error) {\n \t\thash = int(d.window[index])<<hashShift + int(d.window[index+1])\n \t}\n \tchainHead := -1\n+Loop:\n \tfor {\n \t\tif index > windowEnd {\n \t\t\tpanic(\"index > windowEnd\")\n@@ -291,7 +308,31 @@ func (d *compressor) doDeflate() (err os.Error) {\n \t\t\tmaxInsertIndex = windowEnd - (minMatchLength - 1)\n \t\t\tlookahead = windowEnd - index\n \t\t\tif lookahead == 0 {\n-\t\t\t\tbreak\n+\t\t\t\t// Flush current output block if any.\n+\t\t\t\tif byteAvailable {\n+\t\t\t\t\t// There is still one pending token that needs to be flushed\n+\t\t\t\t\ttokens[ti] = literalToken(uint32(d.window[index-1]) & 0xFF)\n+\t\t\t\t\tti++\n+\t\t\t\t\tbyteAvailable = false\n+\t\t\t\t}\n+\t\t\t\tif ti > 0 {\n+\t\t\t\t\tif err = d.writeBlock(tokens[0:ti], index, false); err != nil {\n+\t\t\t\t\t\treturn\n+\t\t\t\t\t}\n+\t\t\t\t\tti = 0\n+\t\t\t\t}\n+\t\t\t\tif d.sync {\n+\t\t\t\t\td.w.writeStoredHeader(0, false)\n+\t\t\t\t\td.w.flush()\n+\t\t\t\t\td.syncChan <- d.w.err\n+\t\t\t\t\td.sync = false\n+\t\t\t\t}\n+\n+\t\t\t\t// If this was only a sync (not at EOF) keep going.\n+\t\t\t\tif !d.eof {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tbreak Loop\n \t\t\t}\n \t\t}\n \t\tif index < maxInsertIndex {\n@@ -383,23 +424,11 @@ func (d *compressor) doDeflate() (err os.Error) {\n \t\t\t\tbyteAvailable = true\n \t\t\t}\n \t\t}\n-\n-\t}\n-\tif byteAvailable {\n-\t\t// There is still one pending token that needs to be flushed\n-\t\ttokens[ti] = literalToken(uint32(d.window[index-1]) & 0xFF)\n-\t\tti++\n-\t}\n-\n-\tif ti > 0 {\n-\t\tif err = d.writeBlock(tokens[0:ti], index, false); err != nil {\n-\t\t\treturn\n-\t\t}\n \t}\n \treturn\n }\n \n-func (d *compressor) compressor(r io.Reader, w io.Writer, level int, logWindowSize uint) (err os.Error) {\n+func (d *compressor) compress(r io.Reader, w io.Writer, level int, logWindowSize uint) (err os.Error) {\n \td.r = r\n \td.w = newHuffmanBitWriter(w)\n \td.level = level\n@@ -417,6 +446,10 @@ func (d *compressor) compressor(r io.Reader, w io.Writer, level int, logWindowSi\n \t\treturn WrongValueError{\"level\", 0, 9, int32(level)}\n \t}\n \n+\tif d.sync {\n+\t\td.syncChan <- err\n+\t\td.sync = false\n+\t}\n \tif err != nil {\n \t\treturn err\n \t}\n@@ -426,16 +459,63 @@ func (d *compressor) compressor(r io.Reader, w io.Writer, level int, logWindowSi\n \treturn d.flush()\n }\n \n-func newCompressor(w io.Writer, level int, logWindowSize uint) io.WriteCloser {\n+// NewWriter returns a new Writer compressing\n+// data at the given level.  Following zlib, levels\n+// range from 1 (BestSpeed) to 9 (BestCompression);\n+// higher levels typically run slower but compress more.\n+// Level 0 (NoCompression) does not attempt any\n+// compression; it only adds the necessary DEFLATE framing.\n+func NewWriter(w io.Writer, level int) *Writer {\n+\tconst logWindowSize = logMaxOffsetSize\n \tvar d compressor\n+\td.syncChan = make(chan os.Error, 1)\n \tpr, pw := syncPipe()\n \tgo func() {\n-\t\terr := d.compressor(pr, w, level, logWindowSize)\n+\t\terr := d.compress(pr, w, level, logWindowSize)\n \t\tpr.CloseWithError(err)\n \t}()\n-\treturn pw\n+\treturn &Writer{pw, &d}\n+}\n+\n+// A Writer takes data written to it and writes the compressed\n+// form of that data to an underlying writer (see NewWriter).\n+type Writer struct {\n+\tw *syncPipeWriter\n+\td *compressor\n+}\n+\n+// Write writes data to w, which will eventually write the\n+// compressed form of data to its underlying writer.\n+func (w *Writer) Write(data []byte) (n int, err os.Error) {\n+\tif len(data) == 0 {\n+\t\t// no point, and nil interferes with sync\n+\t\treturn\n+\t}\n+\treturn w.w.Write(data)\n+}\n+\n+// Flush flushes any pending compressed data to the underlying writer.\n+// It is useful mainly in compressed network protocols, to ensure that\n+// a remote reader has enough data to reconstruct a packet.\n+// Flush does not return until the data has been written.\n+// If the underlying writer returns an error, Flush returns that error.\n+//\n+// In the terminology of the zlib library, Flush is equivalent to Z_SYNC_FLUSH.\n+func (w *Writer) Flush() os.Error {\n+\t// For more about flushing:\n+\t// http://www.bolet.org/~pornin/deflate-flush.html\n+\tif w.d.sync {\n+\t\tpanic(\"compress/flate: double Flush\")\n+\t}\n+\t_, err := w.w.Write(nil)\n+\terr1 := <-w.d.syncChan\n+\tif err == nil {\n+\t\terr = err1\n+\t}\n+\treturn err\n }\n \n-func NewWriter(w io.Writer, level int) io.WriteCloser {\n-\treturn newCompressor(w, level, logMaxOffsetSize)\n+// Close flushes and closes the writer.\n+func (w *Writer) Close() os.Error {\n+\treturn w.w.Close()\n }"}, {"sha": "3db955609d7eb85c1b9ea2904b74ba0a92f5407e", "filename": "libgo/go/compress/flate/deflate_test.go", "status": "modified", "additions": 132, "deletions": 7, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -7,8 +7,10 @@ package flate\n import (\n \t\"bytes\"\n \t\"fmt\"\n+\t\"io\"\n \t\"io/ioutil\"\n \t\"os\"\n+\t\"sync\"\n \t\"testing\"\n )\n \n@@ -79,7 +81,7 @@ func getLargeDataChunk() []byte {\n \n func TestDeflate(t *testing.T) {\n \tfor _, h := range deflateTests {\n-\t\tbuffer := bytes.NewBuffer([]byte{})\n+\t\tbuffer := bytes.NewBuffer(nil)\n \t\tw := NewWriter(buffer, h.level)\n \t\tw.Write(h.in)\n \t\tw.Close()\n@@ -90,21 +92,144 @@ func TestDeflate(t *testing.T) {\n \t}\n }\n \n+type syncBuffer struct {\n+\tbuf    bytes.Buffer\n+\tmu     sync.RWMutex\n+\tclosed bool\n+\tready  chan bool\n+}\n+\n+func newSyncBuffer() *syncBuffer {\n+\treturn &syncBuffer{ready: make(chan bool, 1)}\n+}\n+\n+func (b *syncBuffer) Read(p []byte) (n int, err os.Error) {\n+\tfor {\n+\t\tb.mu.RLock()\n+\t\tn, err = b.buf.Read(p)\n+\t\tb.mu.RUnlock()\n+\t\tif n > 0 || b.closed {\n+\t\t\treturn\n+\t\t}\n+\t\t<-b.ready\n+\t}\n+\tpanic(\"unreachable\")\n+}\n+\n+func (b *syncBuffer) Write(p []byte) (n int, err os.Error) {\n+\tn, err = b.buf.Write(p)\n+\t_ = b.ready <- true\n+\treturn\n+}\n+\n+func (b *syncBuffer) WriteMode() {\n+\tb.mu.Lock()\n+}\n+\n+func (b *syncBuffer) ReadMode() {\n+\tb.mu.Unlock()\n+\t_ = b.ready <- true\n+}\n+\n+func (b *syncBuffer) Close() os.Error {\n+\tb.closed = true\n+\t_ = b.ready <- true\n+\treturn nil\n+}\n+\n+func testSync(t *testing.T, level int, input []byte, name string) {\n+\tif len(input) == 0 {\n+\t\treturn\n+\t}\n+\n+\tt.Logf(\"--testSync %d, %d, %s\", level, len(input), name)\n+\tbuf := newSyncBuffer()\n+\tbuf1 := new(bytes.Buffer)\n+\tbuf.WriteMode()\n+\tw := NewWriter(io.MultiWriter(buf, buf1), level)\n+\tr := NewReader(buf)\n+\n+\t// Write half the input and read back.\n+\tfor i := 0; i < 2; i++ {\n+\t\tvar lo, hi int\n+\t\tif i == 0 {\n+\t\t\tlo, hi = 0, (len(input)+1)/2\n+\t\t} else {\n+\t\t\tlo, hi = (len(input)+1)/2, len(input)\n+\t\t}\n+\t\tt.Logf(\"#%d: write %d-%d\", i, lo, hi)\n+\t\tif _, err := w.Write(input[lo:hi]); err != nil {\n+\t\t\tt.Errorf(\"testSync: write: %v\", err)\n+\t\t\treturn\n+\t\t}\n+\t\tif i == 0 {\n+\t\t\tif err := w.Flush(); err != nil {\n+\t\t\t\tt.Errorf(\"testSync: flush: %v\", err)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t} else {\n+\t\t\tif err := w.Close(); err != nil {\n+\t\t\t\tt.Errorf(\"testSync: close: %v\", err)\n+\t\t\t}\n+\t\t}\n+\t\tbuf.ReadMode()\n+\t\tout := make([]byte, hi-lo+1)\n+\t\tm, err := io.ReadAtLeast(r, out, hi-lo)\n+\t\tt.Logf(\"#%d: read %d\", i, m)\n+\t\tif m != hi-lo || err != nil {\n+\t\t\tt.Errorf(\"testSync/%d (%d, %d, %s): read %d: %d, %v (%d left)\", i, level, len(input), name, hi-lo, m, err, buf.buf.Len())\n+\t\t\treturn\n+\t\t}\n+\t\tif !bytes.Equal(input[lo:hi], out[:hi-lo]) {\n+\t\t\tt.Errorf(\"testSync/%d: read wrong bytes: %x vs %x\", i, input[lo:hi], out[:hi-lo])\n+\t\t\treturn\n+\t\t}\n+\t\tif i == 0 && buf.buf.Len() != 0 {\n+\t\t\tt.Errorf(\"testSync/%d (%d, %d, %s): extra data after %d\", i, level, len(input), name, hi-lo)\n+\t\t}\n+\t\tbuf.WriteMode()\n+\t}\n+\tbuf.ReadMode()\n+\tout := make([]byte, 10)\n+\tif n, err := r.Read(out); n > 0 || err != os.EOF {\n+\t\tt.Errorf(\"testSync (%d, %d, %s): final Read: %d, %v (hex: %x)\", level, len(input), name, n, err, out[0:n])\n+\t}\n+\tif buf.buf.Len() != 0 {\n+\t\tt.Errorf(\"testSync (%d, %d, %s): extra data at end\", level, len(input), name)\n+\t}\n+\tr.Close()\n+\n+\t// stream should work for ordinary reader too\n+\tr = NewReader(buf1)\n+\tout, err := ioutil.ReadAll(r)\n+\tif err != nil {\n+\t\tt.Errorf(\"testSync: read: %s\", err)\n+\t\treturn\n+\t}\n+\tr.Close()\n+\tif !bytes.Equal(input, out) {\n+\t\tt.Errorf(\"testSync: decompress(compress(data)) != data: level=%d input=%s\", level, name)\n+\t}\n+}\n+\n+\n func testToFromWithLevel(t *testing.T, level int, input []byte, name string) os.Error {\n-\tbuffer := bytes.NewBuffer([]byte{})\n+\tbuffer := bytes.NewBuffer(nil)\n \tw := NewWriter(buffer, level)\n \tw.Write(input)\n \tw.Close()\n-\tdecompressor := NewReader(buffer)\n-\tdecompressed, err := ioutil.ReadAll(decompressor)\n+\tr := NewReader(buffer)\n+\tout, err := ioutil.ReadAll(r)\n \tif err != nil {\n-\t\tt.Errorf(\"reading decompressor: %s\", err)\n+\t\tt.Errorf(\"read: %s\", err)\n \t\treturn err\n \t}\n-\tdecompressor.Close()\n-\tif bytes.Compare(input, decompressed) != 0 {\n+\tr.Close()\n+\tif !bytes.Equal(input, out) {\n \t\tt.Errorf(\"decompress(compress(data)) != data: level=%d input=%s\", level, name)\n \t}\n+\n+\ttestSync(t, level, input, name)\n \treturn nil\n }\n "}, {"sha": "7dc8cf93bd9f9dc9310c78cfde6d809d87fc660f", "filename": "libgo/go/compress/flate/inflate.go", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcompress%2Fflate%2Finflate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcompress%2Fflate%2Finflate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Finflate.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -47,7 +47,7 @@ func (e *ReadError) String() string {\n // A WriteError reports an error encountered while writing output.\n type WriteError struct {\n \tOffset int64    // byte offset where error occurred\n-\tError  os.Error // error returned by underlying Read\n+\tError  os.Error // error returned by underlying Write\n }\n \n func (e *WriteError) String() string {\n@@ -217,6 +217,7 @@ type decompressor struct {\n \t// Output history, buffer.\n \thist  [maxHist]byte\n \thp    int  // current output position in buffer\n+\thw    int  // have written hist[0:hw] already\n \thfull bool // buffer has filled at least once\n \n \t// Temporary buffer (avoids repeated allocation).\n@@ -497,6 +498,11 @@ func (f *decompressor) dataBlock() os.Error {\n \t\treturn CorruptInputError(f.roffset)\n \t}\n \n+\tif n == 0 {\n+\t\t// 0-length block means sync\n+\t\treturn f.flush()\n+\t}\n+\n \t// Read len bytes into history,\n \t// writing as history fills.\n \tfor n > 0 {\n@@ -560,19 +566,23 @@ func (f *decompressor) huffSym(h *huffmanDecoder) (int, os.Error) {\n \n // Flush any buffered output to the underlying writer.\n func (f *decompressor) flush() os.Error {\n-\tif f.hp == 0 {\n+\tif f.hw == f.hp {\n \t\treturn nil\n \t}\n-\tn, err := f.w.Write(f.hist[0:f.hp])\n-\tif n != f.hp && err == nil {\n+\tn, err := f.w.Write(f.hist[f.hw:f.hp])\n+\tif n != f.hp-f.hw && err == nil {\n \t\terr = io.ErrShortWrite\n \t}\n \tif err != nil {\n \t\treturn &WriteError{f.woffset, err}\n \t}\n-\tf.woffset += int64(f.hp)\n-\tf.hp = 0\n-\tf.hfull = true\n+\tf.woffset += int64(f.hp - f.hw)\n+\tf.hw = f.hp\n+\tif f.hp == len(f.hist) {\n+\t\tf.hp = 0\n+\t\tf.hw = 0\n+\t\tf.hfull = true\n+\t}\n \treturn nil\n }\n \n@@ -583,9 +593,9 @@ func makeReader(r io.Reader) Reader {\n \treturn bufio.NewReader(r)\n }\n \n-// Inflate reads DEFLATE-compressed data from r and writes\n+// decompress reads DEFLATE-compressed data from r and writes\n // the uncompressed data to w.\n-func (f *decompressor) decompressor(r io.Reader, w io.Writer) os.Error {\n+func (f *decompressor) decompress(r io.Reader, w io.Writer) os.Error {\n \tf.r = makeReader(r)\n \tf.w = w\n \tf.woffset = 0\n@@ -605,6 +615,6 @@ func (f *decompressor) decompressor(r io.Reader, w io.Writer) os.Error {\n func NewReader(r io.Reader) io.ReadCloser {\n \tvar f decompressor\n \tpr, pw := io.Pipe()\n-\tgo func() { pw.CloseWithError(f.decompressor(r, pw)) }()\n+\tgo func() { pw.CloseWithError(f.decompress(r, pw)) }()\n \treturn pr\n }"}, {"sha": "1e38a1982f6620b285ec0b4ebd041fea78ef73a3", "filename": "libgo/go/container/vector/intvector_test.go", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcontainer%2Fvector%2Fintvector_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcontainer%2Fvector%2Fintvector_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Fvector%2Fintvector_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -127,59 +127,59 @@ func TestIntInsertDeleteClear(t *testing.T) {\n \n \tfor i := 0; i < n; i++ {\n \t\tif a.Len() != i {\n-\t\t\tt.Errorf(\"T%: A) wrong Len() %d (expected %d)\", a, a.Len(), i)\n+\t\t\tt.Errorf(\"%T: A) wrong Len() %d (expected %d)\", a, a.Len(), i)\n \t\t}\n \t\tif len(a) != i {\n-\t\t\tt.Errorf(\"T%: A) wrong len() %d (expected %d)\", a, len(a), i)\n+\t\t\tt.Errorf(\"%T: A) wrong len() %d (expected %d)\", a, len(a), i)\n \t\t}\n \t\ta.Insert(0, int2IntValue(val(i)))\n \t\tif elem2IntValue(a.Last()) != int2IntValue(val(0)) {\n-\t\t\tt.Error(\"T%: B\", a)\n+\t\t\tt.Errorf(\"%T: B\", a)\n \t\t}\n \t}\n \tfor i := n - 1; i >= 0; i-- {\n \t\tif elem2IntValue(a.Last()) != int2IntValue(val(0)) {\n-\t\t\tt.Error(\"T%: C\", a)\n+\t\t\tt.Errorf(\"%T: C\", a)\n \t\t}\n \t\tif elem2IntValue(a.At(0)) != int2IntValue(val(i)) {\n-\t\t\tt.Error(\"T%: D\", a)\n+\t\t\tt.Errorf(\"%T: D\", a)\n \t\t}\n \t\tif elem2IntValue(a[0]) != int2IntValue(val(i)) {\n-\t\t\tt.Error(\"T%: D2\", a)\n+\t\t\tt.Errorf(\"%T: D2\", a)\n \t\t}\n \t\ta.Delete(0)\n \t\tif a.Len() != i {\n-\t\t\tt.Errorf(\"T%: E) wrong Len() %d (expected %d)\", a, a.Len(), i)\n+\t\t\tt.Errorf(\"%T: E) wrong Len() %d (expected %d)\", a, a.Len(), i)\n \t\t}\n \t\tif len(a) != i {\n-\t\t\tt.Errorf(\"T%: E) wrong len() %d (expected %d)\", a, len(a), i)\n+\t\t\tt.Errorf(\"%T: E) wrong len() %d (expected %d)\", a, len(a), i)\n \t\t}\n \t}\n \n \tif a.Len() != 0 {\n-\t\tt.Errorf(\"T%: F) wrong Len() %d (expected 0)\", a, a.Len())\n+\t\tt.Errorf(\"%T: F) wrong Len() %d (expected 0)\", a, a.Len())\n \t}\n \tif len(a) != 0 {\n-\t\tt.Errorf(\"T%: F) wrong len() %d (expected 0)\", a, len(a))\n+\t\tt.Errorf(\"%T: F) wrong len() %d (expected 0)\", a, len(a))\n \t}\n \tfor i := 0; i < n; i++ {\n \t\ta.Push(int2IntValue(val(i)))\n \t\tif a.Len() != i+1 {\n-\t\t\tt.Errorf(\"T%: G) wrong Len() %d (expected %d)\", a, a.Len(), i+1)\n+\t\t\tt.Errorf(\"%T: G) wrong Len() %d (expected %d)\", a, a.Len(), i+1)\n \t\t}\n \t\tif len(a) != i+1 {\n-\t\t\tt.Errorf(\"T%: G) wrong len() %d (expected %d)\", a, len(a), i+1)\n+\t\t\tt.Errorf(\"%T: G) wrong len() %d (expected %d)\", a, len(a), i+1)\n \t\t}\n \t\tif elem2IntValue(a.Last()) != int2IntValue(val(i)) {\n-\t\t\tt.Error(\"T%: H\", a)\n+\t\t\tt.Errorf(\"%T: H\", a)\n \t\t}\n \t}\n \ta.Resize(0, 0)\n \tif a.Len() != 0 {\n-\t\tt.Errorf(\"T%: I wrong Len() %d (expected 0)\", a, a.Len())\n+\t\tt.Errorf(\"%T: I wrong Len() %d (expected 0)\", a, a.Len())\n \t}\n \tif len(a) != 0 {\n-\t\tt.Errorf(\"T%: I wrong len() %d (expected 0)\", a, len(a))\n+\t\tt.Errorf(\"%T: I wrong len() %d (expected 0)\", a, len(a))\n \t}\n \n \tconst m = 5\n@@ -189,36 +189,36 @@ func TestIntInsertDeleteClear(t *testing.T) {\n \t\t\tx := val(i)\n \t\t\ta.Push(int2IntValue(x))\n \t\t\tif elem2IntValue(a.Pop()) != int2IntValue(x) {\n-\t\t\t\tt.Error(\"T%: J\", a)\n+\t\t\t\tt.Errorf(\"%T: J\", a)\n \t\t\t}\n \t\t\tif a.Len() != j+1 {\n-\t\t\t\tt.Errorf(\"T%: K) wrong Len() %d (expected %d)\", a, a.Len(), j+1)\n+\t\t\t\tt.Errorf(\"%T: K) wrong Len() %d (expected %d)\", a, a.Len(), j+1)\n \t\t\t}\n \t\t\tif len(a) != j+1 {\n-\t\t\t\tt.Errorf(\"T%: K) wrong len() %d (expected %d)\", a, len(a), j+1)\n+\t\t\t\tt.Errorf(\"%T: K) wrong len() %d (expected %d)\", a, len(a), j+1)\n \t\t\t}\n \t\t}\n \t}\n \tif a.Len() != m {\n-\t\tt.Errorf(\"T%: L) wrong Len() %d (expected %d)\", a, a.Len(), m)\n+\t\tt.Errorf(\"%T: L) wrong Len() %d (expected %d)\", a, a.Len(), m)\n \t}\n \tif len(a) != m {\n-\t\tt.Errorf(\"T%: L) wrong len() %d (expected %d)\", a, len(a), m)\n+\t\tt.Errorf(\"%T: L) wrong len() %d (expected %d)\", a, len(a), m)\n \t}\n }\n \n \n func verify_sliceInt(t *testing.T, x *IntVector, elt, i, j int) {\n \tfor k := i; k < j; k++ {\n \t\tif elem2IntValue(x.At(k)) != int2IntValue(elt) {\n-\t\t\tt.Errorf(\"T%: M) wrong [%d] element %v (expected %v)\", x, k, elem2IntValue(x.At(k)), int2IntValue(elt))\n+\t\t\tt.Errorf(\"%T: M) wrong [%d] element %v (expected %v)\", x, k, elem2IntValue(x.At(k)), int2IntValue(elt))\n \t\t}\n \t}\n \n \ts := x.Slice(i, j)\n \tfor k, n := 0, j-i; k < n; k++ {\n \t\tif elem2IntValue(s.At(k)) != int2IntValue(elt) {\n-\t\t\tt.Errorf(\"T%: N) wrong [%d] element %v (expected %v)\", x, k, elem2IntValue(x.At(k)), int2IntValue(elt))\n+\t\t\tt.Errorf(\"%T: N) wrong [%d] element %v (expected %v)\", x, k, elem2IntValue(x.At(k)), int2IntValue(elt))\n \t\t}\n \t}\n }\n@@ -227,10 +227,10 @@ func verify_sliceInt(t *testing.T, x *IntVector, elt, i, j int) {\n func verify_patternInt(t *testing.T, x *IntVector, a, b, c int) {\n \tn := a + b + c\n \tif x.Len() != n {\n-\t\tt.Errorf(\"T%: O) wrong Len() %d (expected %d)\", x, x.Len(), n)\n+\t\tt.Errorf(\"%T: O) wrong Len() %d (expected %d)\", x, x.Len(), n)\n \t}\n \tif len(*x) != n {\n-\t\tt.Errorf(\"T%: O) wrong len() %d (expected %d)\", x, len(*x), n)\n+\t\tt.Errorf(\"%T: O) wrong len() %d (expected %d)\", x, len(*x), n)\n \t}\n \tverify_sliceInt(t, x, 0, 0, a)\n \tverify_sliceInt(t, x, 1, a, a+b)"}, {"sha": "d540ace0502140450c98bcb4c0a44182cf3ff5cd", "filename": "libgo/go/container/vector/numbers_test.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcontainer%2Fvector%2Fnumbers_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcontainer%2Fvector%2Fnumbers_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Fvector%2Fnumbers_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -20,7 +20,7 @@ func s(n uint64) string {\n \tlens := len(str)\n \ta := make([]string, (lens+2)/3)\n \tstart := lens\n-\tfor i, _ := range a {\n+\tfor i := range a {\n \t\tstart -= 3\n \t\tif start < 0 {\n \t\t\tstart = 0\n@@ -46,7 +46,7 @@ func TestVectorNums(t *testing.T) {\n \tv.Resize(0, 0)\n \truntime.GC()\n \tn := m.Alloc - m0.Alloc\n-\tt.Logf(\"%T.Push(%#v), n = %s: Alloc/n = %.2f\\n\", v, c, s(memTestN), float(n)/memTestN)\n+\tt.Logf(\"%T.Push(%#v), n = %s: Alloc/n = %.2f\\n\", v, c, s(memTestN), float64(n)/memTestN)\n }\n \n \n@@ -64,7 +64,7 @@ func TestIntVectorNums(t *testing.T) {\n \tv.Resize(0, 0)\n \truntime.GC()\n \tn := m.Alloc - m0.Alloc\n-\tt.Logf(\"%T.Push(%#v), n = %s: Alloc/n = %.2f\\n\", v, c, s(memTestN), float(n)/memTestN)\n+\tt.Logf(\"%T.Push(%#v), n = %s: Alloc/n = %.2f\\n\", v, c, s(memTestN), float64(n)/memTestN)\n }\n \n \n@@ -82,7 +82,7 @@ func TestStringVectorNums(t *testing.T) {\n \tv.Resize(0, 0)\n \truntime.GC()\n \tn := m.Alloc - m0.Alloc\n-\tt.Logf(\"%T.Push(%#v), n = %s: Alloc/n = %.2f\\n\", v, c, s(memTestN), float(n)/memTestN)\n+\tt.Logf(\"%T.Push(%#v), n = %s: Alloc/n = %.2f\\n\", v, c, s(memTestN), float64(n)/memTestN)\n }\n \n "}, {"sha": "776ae26dea13ac8fa6a240520a2551dbfda384e8", "filename": "libgo/go/container/vector/stringvector_test.go", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcontainer%2Fvector%2Fstringvector_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcontainer%2Fvector%2Fstringvector_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Fvector%2Fstringvector_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -127,59 +127,59 @@ func TestStrInsertDeleteClear(t *testing.T) {\n \n \tfor i := 0; i < n; i++ {\n \t\tif a.Len() != i {\n-\t\t\tt.Errorf(\"T%: A) wrong Len() %d (expected %d)\", a, a.Len(), i)\n+\t\t\tt.Errorf(\"%T: A) wrong Len() %d (expected %d)\", a, a.Len(), i)\n \t\t}\n \t\tif len(a) != i {\n-\t\t\tt.Errorf(\"T%: A) wrong len() %d (expected %d)\", a, len(a), i)\n+\t\t\tt.Errorf(\"%T: A) wrong len() %d (expected %d)\", a, len(a), i)\n \t\t}\n \t\ta.Insert(0, int2StrValue(val(i)))\n \t\tif elem2StrValue(a.Last()) != int2StrValue(val(0)) {\n-\t\t\tt.Error(\"T%: B\", a)\n+\t\t\tt.Errorf(\"%T: B\", a)\n \t\t}\n \t}\n \tfor i := n - 1; i >= 0; i-- {\n \t\tif elem2StrValue(a.Last()) != int2StrValue(val(0)) {\n-\t\t\tt.Error(\"T%: C\", a)\n+\t\t\tt.Errorf(\"%T: C\", a)\n \t\t}\n \t\tif elem2StrValue(a.At(0)) != int2StrValue(val(i)) {\n-\t\t\tt.Error(\"T%: D\", a)\n+\t\t\tt.Errorf(\"%T: D\", a)\n \t\t}\n \t\tif elem2StrValue(a[0]) != int2StrValue(val(i)) {\n-\t\t\tt.Error(\"T%: D2\", a)\n+\t\t\tt.Errorf(\"%T: D2\", a)\n \t\t}\n \t\ta.Delete(0)\n \t\tif a.Len() != i {\n-\t\t\tt.Errorf(\"T%: E) wrong Len() %d (expected %d)\", a, a.Len(), i)\n+\t\t\tt.Errorf(\"%T: E) wrong Len() %d (expected %d)\", a, a.Len(), i)\n \t\t}\n \t\tif len(a) != i {\n-\t\t\tt.Errorf(\"T%: E) wrong len() %d (expected %d)\", a, len(a), i)\n+\t\t\tt.Errorf(\"%T: E) wrong len() %d (expected %d)\", a, len(a), i)\n \t\t}\n \t}\n \n \tif a.Len() != 0 {\n-\t\tt.Errorf(\"T%: F) wrong Len() %d (expected 0)\", a, a.Len())\n+\t\tt.Errorf(\"%T: F) wrong Len() %d (expected 0)\", a, a.Len())\n \t}\n \tif len(a) != 0 {\n-\t\tt.Errorf(\"T%: F) wrong len() %d (expected 0)\", a, len(a))\n+\t\tt.Errorf(\"%T: F) wrong len() %d (expected 0)\", a, len(a))\n \t}\n \tfor i := 0; i < n; i++ {\n \t\ta.Push(int2StrValue(val(i)))\n \t\tif a.Len() != i+1 {\n-\t\t\tt.Errorf(\"T%: G) wrong Len() %d (expected %d)\", a, a.Len(), i+1)\n+\t\t\tt.Errorf(\"%T: G) wrong Len() %d (expected %d)\", a, a.Len(), i+1)\n \t\t}\n \t\tif len(a) != i+1 {\n-\t\t\tt.Errorf(\"T%: G) wrong len() %d (expected %d)\", a, len(a), i+1)\n+\t\t\tt.Errorf(\"%T: G) wrong len() %d (expected %d)\", a, len(a), i+1)\n \t\t}\n \t\tif elem2StrValue(a.Last()) != int2StrValue(val(i)) {\n-\t\t\tt.Error(\"T%: H\", a)\n+\t\t\tt.Errorf(\"%T: H\", a)\n \t\t}\n \t}\n \ta.Resize(0, 0)\n \tif a.Len() != 0 {\n-\t\tt.Errorf(\"T%: I wrong Len() %d (expected 0)\", a, a.Len())\n+\t\tt.Errorf(\"%T: I wrong Len() %d (expected 0)\", a, a.Len())\n \t}\n \tif len(a) != 0 {\n-\t\tt.Errorf(\"T%: I wrong len() %d (expected 0)\", a, len(a))\n+\t\tt.Errorf(\"%T: I wrong len() %d (expected 0)\", a, len(a))\n \t}\n \n \tconst m = 5\n@@ -189,36 +189,36 @@ func TestStrInsertDeleteClear(t *testing.T) {\n \t\t\tx := val(i)\n \t\t\ta.Push(int2StrValue(x))\n \t\t\tif elem2StrValue(a.Pop()) != int2StrValue(x) {\n-\t\t\t\tt.Error(\"T%: J\", a)\n+\t\t\t\tt.Errorf(\"%T: J\", a)\n \t\t\t}\n \t\t\tif a.Len() != j+1 {\n-\t\t\t\tt.Errorf(\"T%: K) wrong Len() %d (expected %d)\", a, a.Len(), j+1)\n+\t\t\t\tt.Errorf(\"%T: K) wrong Len() %d (expected %d)\", a, a.Len(), j+1)\n \t\t\t}\n \t\t\tif len(a) != j+1 {\n-\t\t\t\tt.Errorf(\"T%: K) wrong len() %d (expected %d)\", a, len(a), j+1)\n+\t\t\t\tt.Errorf(\"%T: K) wrong len() %d (expected %d)\", a, len(a), j+1)\n \t\t\t}\n \t\t}\n \t}\n \tif a.Len() != m {\n-\t\tt.Errorf(\"T%: L) wrong Len() %d (expected %d)\", a, a.Len(), m)\n+\t\tt.Errorf(\"%T: L) wrong Len() %d (expected %d)\", a, a.Len(), m)\n \t}\n \tif len(a) != m {\n-\t\tt.Errorf(\"T%: L) wrong len() %d (expected %d)\", a, len(a), m)\n+\t\tt.Errorf(\"%T: L) wrong len() %d (expected %d)\", a, len(a), m)\n \t}\n }\n \n \n func verify_sliceStr(t *testing.T, x *StringVector, elt, i, j int) {\n \tfor k := i; k < j; k++ {\n \t\tif elem2StrValue(x.At(k)) != int2StrValue(elt) {\n-\t\t\tt.Errorf(\"T%: M) wrong [%d] element %v (expected %v)\", x, k, elem2StrValue(x.At(k)), int2StrValue(elt))\n+\t\t\tt.Errorf(\"%T: M) wrong [%d] element %v (expected %v)\", x, k, elem2StrValue(x.At(k)), int2StrValue(elt))\n \t\t}\n \t}\n \n \ts := x.Slice(i, j)\n \tfor k, n := 0, j-i; k < n; k++ {\n \t\tif elem2StrValue(s.At(k)) != int2StrValue(elt) {\n-\t\t\tt.Errorf(\"T%: N) wrong [%d] element %v (expected %v)\", x, k, elem2StrValue(x.At(k)), int2StrValue(elt))\n+\t\t\tt.Errorf(\"%T: N) wrong [%d] element %v (expected %v)\", x, k, elem2StrValue(x.At(k)), int2StrValue(elt))\n \t\t}\n \t}\n }\n@@ -227,10 +227,10 @@ func verify_sliceStr(t *testing.T, x *StringVector, elt, i, j int) {\n func verify_patternStr(t *testing.T, x *StringVector, a, b, c int) {\n \tn := a + b + c\n \tif x.Len() != n {\n-\t\tt.Errorf(\"T%: O) wrong Len() %d (expected %d)\", x, x.Len(), n)\n+\t\tt.Errorf(\"%T: O) wrong Len() %d (expected %d)\", x, x.Len(), n)\n \t}\n \tif len(*x) != n {\n-\t\tt.Errorf(\"T%: O) wrong len() %d (expected %d)\", x, len(*x), n)\n+\t\tt.Errorf(\"%T: O) wrong len() %d (expected %d)\", x, len(*x), n)\n \t}\n \tverify_sliceStr(t, x, 0, 0, a)\n \tverify_sliceStr(t, x, 1, a, a+b)"}, {"sha": "a9c4ceb55acebcf7b74dd5be7fb71bcadc7c5539", "filename": "libgo/go/container/vector/vector_test.go", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcontainer%2Fvector%2Fvector_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcontainer%2Fvector%2Fvector_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Fvector%2Fvector_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -127,59 +127,59 @@ func TestInsertDeleteClear(t *testing.T) {\n \n \tfor i := 0; i < n; i++ {\n \t\tif a.Len() != i {\n-\t\t\tt.Errorf(\"T%: A) wrong Len() %d (expected %d)\", a, a.Len(), i)\n+\t\t\tt.Errorf(\"%T: A) wrong Len() %d (expected %d)\", a, a.Len(), i)\n \t\t}\n \t\tif len(a) != i {\n-\t\t\tt.Errorf(\"T%: A) wrong len() %d (expected %d)\", a, len(a), i)\n+\t\t\tt.Errorf(\"%T: A) wrong len() %d (expected %d)\", a, len(a), i)\n \t\t}\n \t\ta.Insert(0, int2Value(val(i)))\n \t\tif elem2Value(a.Last()) != int2Value(val(0)) {\n-\t\t\tt.Error(\"T%: B\", a)\n+\t\t\tt.Errorf(\"%T: B\", a)\n \t\t}\n \t}\n \tfor i := n - 1; i >= 0; i-- {\n \t\tif elem2Value(a.Last()) != int2Value(val(0)) {\n-\t\t\tt.Error(\"T%: C\", a)\n+\t\t\tt.Errorf(\"%T: C\", a)\n \t\t}\n \t\tif elem2Value(a.At(0)) != int2Value(val(i)) {\n-\t\t\tt.Error(\"T%: D\", a)\n+\t\t\tt.Errorf(\"%T: D\", a)\n \t\t}\n \t\tif elem2Value(a[0]) != int2Value(val(i)) {\n-\t\t\tt.Error(\"T%: D2\", a)\n+\t\t\tt.Errorf(\"%T: D2\", a)\n \t\t}\n \t\ta.Delete(0)\n \t\tif a.Len() != i {\n-\t\t\tt.Errorf(\"T%: E) wrong Len() %d (expected %d)\", a, a.Len(), i)\n+\t\t\tt.Errorf(\"%T: E) wrong Len() %d (expected %d)\", a, a.Len(), i)\n \t\t}\n \t\tif len(a) != i {\n-\t\t\tt.Errorf(\"T%: E) wrong len() %d (expected %d)\", a, len(a), i)\n+\t\t\tt.Errorf(\"%T: E) wrong len() %d (expected %d)\", a, len(a), i)\n \t\t}\n \t}\n \n \tif a.Len() != 0 {\n-\t\tt.Errorf(\"T%: F) wrong Len() %d (expected 0)\", a, a.Len())\n+\t\tt.Errorf(\"%T: F) wrong Len() %d (expected 0)\", a, a.Len())\n \t}\n \tif len(a) != 0 {\n-\t\tt.Errorf(\"T%: F) wrong len() %d (expected 0)\", a, len(a))\n+\t\tt.Errorf(\"%T: F) wrong len() %d (expected 0)\", a, len(a))\n \t}\n \tfor i := 0; i < n; i++ {\n \t\ta.Push(int2Value(val(i)))\n \t\tif a.Len() != i+1 {\n-\t\t\tt.Errorf(\"T%: G) wrong Len() %d (expected %d)\", a, a.Len(), i+1)\n+\t\t\tt.Errorf(\"%T: G) wrong Len() %d (expected %d)\", a, a.Len(), i+1)\n \t\t}\n \t\tif len(a) != i+1 {\n-\t\t\tt.Errorf(\"T%: G) wrong len() %d (expected %d)\", a, len(a), i+1)\n+\t\t\tt.Errorf(\"%T: G) wrong len() %d (expected %d)\", a, len(a), i+1)\n \t\t}\n \t\tif elem2Value(a.Last()) != int2Value(val(i)) {\n-\t\t\tt.Error(\"T%: H\", a)\n+\t\t\tt.Errorf(\"%T: H\", a)\n \t\t}\n \t}\n \ta.Resize(0, 0)\n \tif a.Len() != 0 {\n-\t\tt.Errorf(\"T%: I wrong Len() %d (expected 0)\", a, a.Len())\n+\t\tt.Errorf(\"%T: I wrong Len() %d (expected 0)\", a, a.Len())\n \t}\n \tif len(a) != 0 {\n-\t\tt.Errorf(\"T%: I wrong len() %d (expected 0)\", a, len(a))\n+\t\tt.Errorf(\"%T: I wrong len() %d (expected 0)\", a, len(a))\n \t}\n \n \tconst m = 5\n@@ -189,36 +189,36 @@ func TestInsertDeleteClear(t *testing.T) {\n \t\t\tx := val(i)\n \t\t\ta.Push(int2Value(x))\n \t\t\tif elem2Value(a.Pop()) != int2Value(x) {\n-\t\t\t\tt.Error(\"T%: J\", a)\n+\t\t\t\tt.Errorf(\"%T: J\", a)\n \t\t\t}\n \t\t\tif a.Len() != j+1 {\n-\t\t\t\tt.Errorf(\"T%: K) wrong Len() %d (expected %d)\", a, a.Len(), j+1)\n+\t\t\t\tt.Errorf(\"%T: K) wrong Len() %d (expected %d)\", a, a.Len(), j+1)\n \t\t\t}\n \t\t\tif len(a) != j+1 {\n-\t\t\t\tt.Errorf(\"T%: K) wrong len() %d (expected %d)\", a, len(a), j+1)\n+\t\t\t\tt.Errorf(\"%T: K) wrong len() %d (expected %d)\", a, len(a), j+1)\n \t\t\t}\n \t\t}\n \t}\n \tif a.Len() != m {\n-\t\tt.Errorf(\"T%: L) wrong Len() %d (expected %d)\", a, a.Len(), m)\n+\t\tt.Errorf(\"%T: L) wrong Len() %d (expected %d)\", a, a.Len(), m)\n \t}\n \tif len(a) != m {\n-\t\tt.Errorf(\"T%: L) wrong len() %d (expected %d)\", a, len(a), m)\n+\t\tt.Errorf(\"%T: L) wrong len() %d (expected %d)\", a, len(a), m)\n \t}\n }\n \n \n func verify_slice(t *testing.T, x *Vector, elt, i, j int) {\n \tfor k := i; k < j; k++ {\n \t\tif elem2Value(x.At(k)) != int2Value(elt) {\n-\t\t\tt.Errorf(\"T%: M) wrong [%d] element %v (expected %v)\", x, k, elem2Value(x.At(k)), int2Value(elt))\n+\t\t\tt.Errorf(\"%T: M) wrong [%d] element %v (expected %v)\", x, k, elem2Value(x.At(k)), int2Value(elt))\n \t\t}\n \t}\n \n \ts := x.Slice(i, j)\n \tfor k, n := 0, j-i; k < n; k++ {\n \t\tif elem2Value(s.At(k)) != int2Value(elt) {\n-\t\t\tt.Errorf(\"T%: N) wrong [%d] element %v (expected %v)\", x, k, elem2Value(x.At(k)), int2Value(elt))\n+\t\t\tt.Errorf(\"%T: N) wrong [%d] element %v (expected %v)\", x, k, elem2Value(x.At(k)), int2Value(elt))\n \t\t}\n \t}\n }\n@@ -227,10 +227,10 @@ func verify_slice(t *testing.T, x *Vector, elt, i, j int) {\n func verify_pattern(t *testing.T, x *Vector, a, b, c int) {\n \tn := a + b + c\n \tif x.Len() != n {\n-\t\tt.Errorf(\"T%: O) wrong Len() %d (expected %d)\", x, x.Len(), n)\n+\t\tt.Errorf(\"%T: O) wrong Len() %d (expected %d)\", x, x.Len(), n)\n \t}\n \tif len(*x) != n {\n-\t\tt.Errorf(\"T%: O) wrong len() %d (expected %d)\", x, len(*x), n)\n+\t\tt.Errorf(\"%T: O) wrong len() %d (expected %d)\", x, len(*x), n)\n \t}\n \tverify_slice(t, x, 0, 0, a)\n \tverify_slice(t, x, 1, a, a+b)"}, {"sha": "e1099e9a104d1e048280719eb1168a581b6a5416", "filename": "libgo/go/crypto/block/cipher.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Fblock%2Fcipher.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Fblock%2Fcipher.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fblock%2Fcipher.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -2,6 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// The block package is deprecated, use cipher instead.\n // The block package implements standard block cipher modes\n // that can be wrapped around low-level block cipher implementations.\n // See http://csrc.nist.gov/groups/ST/toolkit/BCM/current_modes.html"}, {"sha": "4632f882a4c12be0cdaa7cd2eb1d79c57d45eb2d", "filename": "libgo/go/crypto/cipher/cbc.go", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcbc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcbc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcbc.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -0,0 +1,78 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Cipher block chaining (CBC) mode.\n+\n+// CBC provides confidentiality by xoring (chaining) each plaintext block\n+// with the previous ciphertext block before applying the block cipher.\n+\n+// See NIST SP 800-38A, pp 10-11\n+\n+package cipher\n+\n+type cbc struct {\n+\tb         Block\n+\tblockSize int\n+\tiv        []byte\n+\ttmp       []byte\n+}\n+\n+func newCBC(b Block, iv []byte) *cbc {\n+\treturn &cbc{\n+\t\tb:         b,\n+\t\tblockSize: b.BlockSize(),\n+\t\tiv:        dup(iv),\n+\t\ttmp:       make([]byte, b.BlockSize()),\n+\t}\n+}\n+\n+type cbcEncrypter cbc\n+\n+// NewCBCEncrypter returns a BlockMode which encrypts in cipher block chaining\n+// mode, using the given Block. The length of iv must be the same as the\n+// Block's block size.\n+func NewCBCEncrypter(b Block, iv []byte) BlockMode {\n+\treturn (*cbcEncrypter)(newCBC(b, iv))\n+}\n+\n+func (x *cbcEncrypter) BlockSize() int { return x.blockSize }\n+\n+func (x *cbcEncrypter) CryptBlocks(dst, src []byte) {\n+\tfor len(src) > 0 {\n+\t\tfor i := 0; i < x.blockSize; i++ {\n+\t\t\tx.iv[i] ^= src[i]\n+\t\t}\n+\t\tx.b.Encrypt(x.iv, x.iv)\n+\t\tfor i := 0; i < x.blockSize; i++ {\n+\t\t\tdst[i] = x.iv[i]\n+\t\t}\n+\t\tsrc = src[x.blockSize:]\n+\t\tdst = dst[x.blockSize:]\n+\t}\n+}\n+\n+type cbcDecrypter cbc\n+\n+// NewCBCDecrypter returns a BlockMode which decrypts in cipher block chaining\n+// mode, using the given Block. The length of iv must be the same as the\n+// Block's block size as must match the iv used to encrypt the data.\n+func NewCBCDecrypter(b Block, iv []byte) BlockMode {\n+\treturn (*cbcDecrypter)(newCBC(b, iv))\n+}\n+\n+func (x *cbcDecrypter) BlockSize() int { return x.blockSize }\n+\n+func (x *cbcDecrypter) CryptBlocks(dst, src []byte) {\n+\tfor len(src) > 0 {\n+\t\tx.b.Decrypt(x.tmp, src[:x.blockSize])\n+\t\tfor i := 0; i < x.blockSize; i++ {\n+\t\t\tx.tmp[i] ^= x.iv[i]\n+\t\t\tx.iv[i] = src[i]\n+\t\t\tdst[i] = x.tmp[i]\n+\t\t}\n+\n+\t\tsrc = src[x.blockSize:]\n+\t\tdst = dst[x.blockSize:]\n+\t}\n+}"}, {"sha": "944ca1ba8510b66b11e215056e4d7c6853589b41", "filename": "libgo/go/crypto/cipher/cbc_aes_test.go", "status": "renamed", "additions": 11, "deletions": 24, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcbc_aes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcbc_aes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcbc_aes_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -8,24 +8,21 @@\n // Special Publication 800-38A, ``Recommendation for Block Cipher\n // Modes of Operation,'' 2001 Edition, pp. 24-29.\n \n-package block\n+package cipher\n \n import (\n \t\"bytes\"\n \t\"crypto/aes\"\n-\t\"io\"\n \t\"testing\"\n )\n \n-type cbcTest struct {\n+var cbcAESTests = []struct {\n \tname string\n \tkey  []byte\n \tiv   []byte\n \tin   []byte\n \tout  []byte\n-}\n-\n-var cbcAESTests = []cbcTest{\n+}{\n \t// NIST SP 800-38A pp 27-29\n \t{\n \t\t\"CBC-AES128\",\n@@ -75,28 +72,18 @@ func TestCBC_AES(t *testing.T) {\n \t\t\tcontinue\n \t\t}\n \n-\t\tvar crypt bytes.Buffer\n-\t\tw := NewCBCEncrypter(c, tt.iv, &crypt)\n-\t\tvar r io.Reader = bytes.NewBuffer(tt.in)\n-\t\tn, err := io.Copy(w, r)\n-\t\tif n != int64(len(tt.in)) || err != nil {\n-\t\t\tt.Errorf(\"%s: CBCEncrypter io.Copy = %d, %v want %d, nil\", test, n, err, len(tt.in))\n-\t\t} else if d := crypt.Bytes(); !same(tt.out, d) {\n+\t\tencrypter := NewCBCEncrypter(c, tt.iv)\n+\t\td := make([]byte, len(tt.in))\n+\t\tencrypter.CryptBlocks(d, tt.in)\n+\t\tif !bytes.Equal(tt.out, d) {\n \t\t\tt.Errorf(\"%s: CBCEncrypter\\nhave %x\\nwant %x\", test, d, tt.out)\n \t\t}\n \n-\t\tvar plain bytes.Buffer\n-\t\tr = NewCBCDecrypter(c, tt.iv, bytes.NewBuffer(tt.out))\n-\t\tw = &plain\n-\t\tn, err = io.Copy(w, r)\n-\t\tif n != int64(len(tt.out)) || err != nil {\n-\t\t\tt.Errorf(\"%s: CBCDecrypter io.Copy = %d, %v want %d, nil\", test, n, err, len(tt.out))\n-\t\t} else if d := plain.Bytes(); !same(tt.in, d) {\n+\t\tdecrypter := NewCBCDecrypter(c, tt.iv)\n+\t\tp := make([]byte, len(d))\n+\t\tdecrypter.CryptBlocks(p, d)\n+\t\tif !bytes.Equal(tt.in, p) {\n \t\t\tt.Errorf(\"%s: CBCDecrypter\\nhave %x\\nwant %x\", test, d, tt.in)\n \t\t}\n-\n-\t\tif t.Failed() {\n-\t\t\tbreak\n-\t\t}\n \t}\n }", "previous_filename": "libgo/go/crypto/block/cbc_aes_test.go"}, {"sha": "d14165a865661a0fee40bb5f727856cb869140d4", "filename": "libgo/go/crypto/cipher/cfb.go", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcfb.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcfb.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcfb.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -0,0 +1,64 @@\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// CFB (Cipher Feedback) Mode.\n+\n+package cipher\n+\n+type cfb struct {\n+\tb       Block\n+\tout     []byte\n+\toutUsed int\n+\tdecrypt bool\n+}\n+\n+// NewCFBEncrypter returns a Stream which encrypts with cipher feedback mode,\n+// using the given Block. The iv must be the same length as the Block's block\n+// size.\n+func NewCFBEncrypter(block Block, iv []byte) Stream {\n+\treturn newCFB(block, iv, false)\n+}\n+\n+// NewCFBDecrypter returns a Stream which decrypts with cipher feedback mode,\n+// using the given Block. The iv must be the same length as the Block's block\n+// size.\n+func NewCFBDecrypter(block Block, iv []byte) Stream {\n+\treturn newCFB(block, iv, true)\n+}\n+\n+func newCFB(block Block, iv []byte, decrypt bool) Stream {\n+\tblockSize := block.BlockSize()\n+\tif len(iv) != blockSize {\n+\t\treturn nil\n+\t}\n+\n+\tx := &cfb{\n+\t\tb:       block,\n+\t\tout:     make([]byte, blockSize),\n+\t\toutUsed: 0,\n+\t\tdecrypt: decrypt,\n+\t}\n+\tblock.Encrypt(x.out, iv)\n+\n+\treturn x\n+}\n+\n+func (x *cfb) XORKeyStream(dst, src []byte) {\n+\tfor i := 0; i < len(src); i++ {\n+\t\tif x.outUsed == len(x.out) {\n+\t\t\tx.b.Encrypt(x.out, x.out)\n+\t\t\tx.outUsed = 0\n+\t\t}\n+\n+\t\tif x.decrypt {\n+\t\t\tt := src[i]\n+\t\t\tdst[i] = src[i] ^ x.out[x.outUsed]\n+\t\t\tx.out[x.outUsed] = t\n+\t\t} else {\n+\t\t\tx.out[x.outUsed] ^= src[i]\n+\t\t\tdst[i] = x.out[x.outUsed]\n+\t\t}\n+\t\tx.outUsed++\n+\t}\n+}"}, {"sha": "9547bfceb7b28980319a3dccf1c6927697c68ccc", "filename": "libgo/go/crypto/cipher/cfb_test.go", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcfb_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcfb_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcfb_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cipher\n+\n+import (\n+\t\"bytes\"\n+\t\"crypto/aes\"\n+\t\"crypto/rand\"\n+\t\"testing\"\n+)\n+\n+func TestCFB(t *testing.T) {\n+\tblock, err := aes.NewCipher(commonKey128)\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t\treturn\n+\t}\n+\n+\tplaintext := []byte(\"this is the plaintext\")\n+\tiv := make([]byte, block.BlockSize())\n+\trand.Reader.Read(iv)\n+\tcfb := NewCFBEncrypter(block, iv)\n+\tciphertext := make([]byte, len(plaintext))\n+\tcfb.XORKeyStream(ciphertext, plaintext)\n+\n+\tcfbdec := NewCFBDecrypter(block, iv)\n+\tplaintextCopy := make([]byte, len(plaintext))\n+\tcfbdec.XORKeyStream(plaintextCopy, ciphertext)\n+\n+\tif !bytes.Equal(plaintextCopy, plaintext) {\n+\t\tt.Errorf(\"got: %x, want: %x\", plaintextCopy, plaintext)\n+\t}\n+}"}, {"sha": "50516b23a13cfe27701aa9476cf6d48b07f0b011", "filename": "libgo/go/crypto/cipher/cipher.go", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcipher.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcipher.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcipher.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -0,0 +1,63 @@\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// The cipher package implements standard block cipher modes\n+// that can be wrapped around low-level block cipher implementations.\n+// See http://csrc.nist.gov/groups/ST/toolkit/BCM/current_modes.html\n+// and NIST Special Publication 800-38A.\n+package cipher\n+\n+// A Block represents an implementation of block cipher\n+// using a given key.  It provides the capability to encrypt\n+// or decrypt individual blocks.  The mode implementations\n+// extend that capability to streams of blocks.\n+type Block interface {\n+\t// BlockSize returns the cipher's block size.\n+\tBlockSize() int\n+\n+\t// Encrypt encrypts the first block in src into dst.\n+\t// Dst and src may point at the same memory.\n+\tEncrypt(dst, src []byte)\n+\n+\t// Decrypt decrypts the first block in src into dst.\n+\t// Dst and src may point at the same memory.\n+\tDecrypt(dst, src []byte)\n+}\n+\n+// A Stream represents a stream cipher.\n+type Stream interface {\n+\t// XORKeyStream XORs each byte in the given slice with a byte from the\n+\t// cipher's key stream. Dst and src may point to the same memory.\n+\tXORKeyStream(dst, src []byte)\n+}\n+\n+// A BlockMode represents a block cipher running in a block-based mode (CBC,\n+// ECB etc).\n+type BlockMode interface {\n+\t// BlockSize returns the mode's block size.\n+\tBlockSize() int\n+\n+\t// CryptBlocks encrypts or decrypts a number of blocks. The length of\n+\t// src must be a multiple of the block size. Dst and src may point to\n+\t// the same memory.\n+\tCryptBlocks(dst, src []byte)\n+}\n+\n+// Utility routines\n+\n+func shift1(dst, src []byte) byte {\n+\tvar b byte\n+\tfor i := len(src) - 1; i >= 0; i-- {\n+\t\tbb := src[i] >> 7\n+\t\tdst[i] = src[i]<<1 | b\n+\t\tb = bb\n+\t}\n+\treturn b\n+}\n+\n+func dup(p []byte) []byte {\n+\tq := make([]byte, len(p))\n+\tcopy(q, p)\n+\treturn q\n+}"}, {"sha": "fb755757c25401ed12100803b6ea14c2c2953e47", "filename": "libgo/go/crypto/cipher/common_test.go", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcommon_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcommon_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcommon_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cipher\n+\n+// Common values for tests.\n+\n+var commonInput = []byte{\n+\t0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,\n+\t0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c, 0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,\n+\t0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11, 0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,\n+\t0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17, 0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10,\n+}\n+\n+var commonKey128 = []byte{0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c}\n+\n+var commonKey192 = []byte{\n+\t0x8e, 0x73, 0xb0, 0xf7, 0xda, 0x0e, 0x64, 0x52, 0xc8, 0x10, 0xf3, 0x2b, 0x80, 0x90, 0x79, 0xe5,\n+\t0x62, 0xf8, 0xea, 0xd2, 0x52, 0x2c, 0x6b, 0x7b,\n+}\n+\n+var commonKey256 = []byte{\n+\t0x60, 0x3d, 0xeb, 0x10, 0x15, 0xca, 0x71, 0xbe, 0x2b, 0x73, 0xae, 0xf0, 0x85, 0x7d, 0x77, 0x81,\n+\t0x1f, 0x35, 0x2c, 0x07, 0x3b, 0x61, 0x08, 0xd7, 0x2d, 0x98, 0x10, 0xa3, 0x09, 0x14, 0xdf, 0xf4,\n+}\n+\n+var commonIV = []byte{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f}"}, {"sha": "04436ec23b0115d6a819c5443f1390cc44420f32", "filename": "libgo/go/crypto/cipher/ctr.go", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Fcipher%2Fctr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Fcipher%2Fctr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fctr.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Counter (CTR) mode.\n+\n+// CTR converts a block cipher into a stream cipher by\n+// repeatedly encrypting an incrementing counter and\n+// xoring the resulting stream of data with the input.\n+\n+// See NIST SP 800-38A, pp 13-15\n+\n+package cipher\n+\n+type ctr struct {\n+\tb       Block\n+\tctr     []byte\n+\tout     []byte\n+\toutUsed int\n+}\n+\n+// NewCTR returns a Stream which encrypts/decrypts using the given Block in\n+// counter mode. The length of iv must be the same as the Block's block size.\n+func NewCTR(block Block, iv []byte) Stream {\n+\treturn &ctr{\n+\t\tb:       block,\n+\t\tctr:     dup(iv),\n+\t\tout:     make([]byte, len(iv)),\n+\t\toutUsed: len(iv),\n+\t}\n+}\n+\n+func (x *ctr) XORKeyStream(dst, src []byte) {\n+\tfor i := 0; i < len(src); i++ {\n+\t\tif x.outUsed == len(x.ctr) {\n+\t\t\tx.b.Encrypt(x.out, x.ctr)\n+\t\t\tx.outUsed = 0\n+\n+\t\t\t// Increment counter\n+\t\t\tfor i := len(x.ctr) - 1; i >= 0; i-- {\n+\t\t\t\tx.ctr[i]++\n+\t\t\t\tif x.ctr[i] != 0 {\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tdst[i] = src[i] ^ x.out[x.outUsed]\n+\t\tx.outUsed++\n+\t}\n+}"}, {"sha": "8dca9968c44835fa22f104b77975ba0f4f3d7aee", "filename": "libgo/go/crypto/cipher/ctr_aes_test.go", "status": "renamed", "additions": 16, "deletions": 25, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Fcipher%2Fctr_aes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Fcipher%2Fctr_aes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fctr_aes_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -8,26 +8,23 @@\n // Special Publication 800-38A, ``Recommendation for Block Cipher\n // Modes of Operation,'' 2001 Edition, pp. 55-58.\n \n-package block\n+package cipher\n \n import (\n \t\"bytes\"\n \t\"crypto/aes\"\n-\t\"io\"\n \t\"testing\"\n )\n \n-type ctrTest struct {\n+var commonCounter = []byte{0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff}\n+\n+var ctrAESTests = []struct {\n \tname string\n \tkey  []byte\n \tiv   []byte\n \tin   []byte\n \tout  []byte\n-}\n-\n-var commonCounter = []byte{0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff}\n-\n-var ctrAESTests = []ctrTest{\n+}{\n \t// NIST SP 800-38A pp 55-58\n \t{\n \t\t\"CTR-AES128\",\n@@ -78,28 +75,22 @@ func TestCTR_AES(t *testing.T) {\n \t\t}\n \n \t\tfor j := 0; j <= 5; j += 5 {\n-\t\t\tvar crypt bytes.Buffer\n \t\t\tin := tt.in[0 : len(tt.in)-j]\n-\t\t\tw := NewCTRWriter(c, tt.iv, &crypt)\n-\t\t\tvar r io.Reader = bytes.NewBuffer(in)\n-\t\t\tn, err := io.Copy(w, r)\n-\t\t\tif n != int64(len(in)) || err != nil {\n-\t\t\t\tt.Errorf(\"%s/%d: CTRWriter io.Copy = %d, %v want %d, nil\", test, len(in), n, err, len(in))\n-\t\t\t} else if d, out := crypt.Bytes(), tt.out[0:len(in)]; !same(out, d) {\n-\t\t\t\tt.Errorf(\"%s/%d: CTRWriter\\ninpt %x\\nhave %x\\nwant %x\", test, len(in), in, d, out)\n+\t\t\tctr := NewCTR(c, tt.iv)\n+\t\t\tencrypted := make([]byte, len(in))\n+\t\t\tctr.XORKeyStream(encrypted, in)\n+\t\t\tif out := tt.out[0:len(in)]; !bytes.Equal(out, encrypted) {\n+\t\t\t\tt.Errorf(\"%s/%d: CTR\\ninpt %x\\nhave %x\\nwant %x\", test, len(in), in, encrypted, out)\n \t\t\t}\n \t\t}\n \n \t\tfor j := 0; j <= 7; j += 7 {\n-\t\t\tvar plain bytes.Buffer\n-\t\t\tout := tt.out[0 : len(tt.out)-j]\n-\t\t\tr := NewCTRReader(c, tt.iv, bytes.NewBuffer(out))\n-\t\t\tw := &plain\n-\t\t\tn, err := io.Copy(w, r)\n-\t\t\tif n != int64(len(out)) || err != nil {\n-\t\t\t\tt.Errorf(\"%s/%d: CTRReader io.Copy = %d, %v want %d, nil\", test, len(out), n, err, len(out))\n-\t\t\t} else if d, in := plain.Bytes(), tt.in[0:len(out)]; !same(in, d) {\n-\t\t\t\tt.Errorf(\"%s/%d: CTRReader\\nhave %x\\nwant %x\", test, len(out), d, in)\n+\t\t\tin := tt.out[0 : len(tt.out)-j]\n+\t\t\tctr := NewCTR(c, tt.iv)\n+\t\t\tplain := make([]byte, len(in))\n+\t\t\tctr.XORKeyStream(plain, in)\n+\t\t\tif out := tt.in[0:len(in)]; !bytes.Equal(out, plain) {\n+\t\t\t\tt.Errorf(\"%s/%d: CTRReader\\nhave %x\\nwant %x\", test, len(out), plain, out)\n \t\t\t}\n \t\t}\n ", "previous_filename": "libgo/go/crypto/block/ctr_aes_test.go"}, {"sha": "97f40b8e78dbef219268bdcace52a483023e5bc8", "filename": "libgo/go/crypto/cipher/io.go", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Fcipher%2Fio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Fcipher%2Fio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fio.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -0,0 +1,57 @@\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cipher\n+\n+import (\n+\t\"os\"\n+\t\"io\"\n+)\n+\n+// The Stream* objects are so simple that all their members are public. Users\n+// can create them themselves.\n+\n+// StreamReader wraps a Stream into an io.Reader. It simply calls XORKeyStream\n+// to process each slice of data which passes through.\n+type StreamReader struct {\n+\tS Stream\n+\tR io.Reader\n+}\n+\n+func (r StreamReader) Read(dst []byte) (n int, err os.Error) {\n+\tn, err = r.R.Read(dst)\n+\tr.S.XORKeyStream(dst[:n], dst[:n])\n+\treturn\n+}\n+\n+// StreamWriter wraps a Stream into an io.Writer. It simply calls XORKeyStream\n+// to process each slice of data which passes through. If any Write call\n+// returns short then the StreamWriter is out of sync and must be discarded.\n+type StreamWriter struct {\n+\tS   Stream\n+\tW   io.Writer\n+\tErr os.Error\n+}\n+\n+func (w StreamWriter) Write(src []byte) (n int, err os.Error) {\n+\tif w.Err != nil {\n+\t\treturn 0, w.Err\n+\t}\n+\tc := make([]byte, len(src))\n+\tw.S.XORKeyStream(c, src)\n+\tn, err = w.W.Write(c)\n+\tif n != len(src) {\n+\t\tif err == nil { // should never happen\n+\t\t\terr = io.ErrShortWrite\n+\t\t}\n+\t\tw.Err = err\n+\t}\n+\treturn\n+}\n+\n+func (w StreamWriter) Close() os.Error {\n+\t// This saves us from either requiring a WriteCloser or having a\n+\t// StreamWriterCloser.\n+\treturn w.W.(io.Closer).Close()\n+}"}, {"sha": "43cb5a53108334277eb63ccddabf31efb109a02b", "filename": "libgo/go/crypto/cipher/ocfb.go", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Fcipher%2Focfb.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Fcipher%2Focfb.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Focfb.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -0,0 +1,112 @@\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// OpenPGP CFB Mode. http://tools.ietf.org/html/rfc4880#section-13.9\n+\n+package cipher\n+\n+type ocfbEncrypter struct {\n+\tb       Block\n+\tfre     []byte\n+\toutUsed int\n+}\n+\n+// NewOCFBEncrypter returns a Stream which encrypts data with OpenPGP's cipher\n+// feedback mode using the given Block, and an initial amount of ciphertext.\n+// randData must be random bytes and be the same length as the Block's block\n+// size.\n+func NewOCFBEncrypter(block Block, randData []byte) (Stream, []byte) {\n+\tblockSize := block.BlockSize()\n+\tif len(randData) != blockSize {\n+\t\treturn nil, nil\n+\t}\n+\n+\tx := &ocfbEncrypter{\n+\t\tb:       block,\n+\t\tfre:     make([]byte, blockSize),\n+\t\toutUsed: 0,\n+\t}\n+\tprefix := make([]byte, blockSize+2)\n+\n+\tblock.Encrypt(x.fre, x.fre)\n+\tfor i := 0; i < blockSize; i++ {\n+\t\tprefix[i] = randData[i] ^ x.fre[i]\n+\t}\n+\n+\tblock.Encrypt(x.fre, prefix[:blockSize])\n+\tprefix[blockSize] = x.fre[0] ^ randData[blockSize-2]\n+\tprefix[blockSize+1] = x.fre[1] ^ randData[blockSize-1]\n+\n+\tblock.Encrypt(x.fre, prefix[2:])\n+\treturn x, prefix\n+}\n+\n+func (x *ocfbEncrypter) XORKeyStream(dst, src []byte) {\n+\tfor i := 0; i < len(src); i++ {\n+\t\tif x.outUsed == len(x.fre) {\n+\t\t\tx.b.Encrypt(x.fre, x.fre)\n+\t\t\tx.outUsed = 0\n+\t\t}\n+\n+\t\tx.fre[x.outUsed] ^= src[i]\n+\t\tdst[i] = x.fre[x.outUsed]\n+\t\tx.outUsed++\n+\t}\n+}\n+\n+type ocfbDecrypter struct {\n+\tb       Block\n+\tfre     []byte\n+\toutUsed int\n+}\n+\n+// NewOCFBDecrypter returns a Stream which decrypts data with OpenPGP's cipher\n+// feedback mode using the given Block. Prefix must be the first blockSize + 2\n+// bytes of the ciphertext, where blockSize is the Block's block size. If an\n+// incorrect key is detected then nil is returned.\n+func NewOCFBDecrypter(block Block, prefix []byte) Stream {\n+\tblockSize := block.BlockSize()\n+\tif len(prefix) != blockSize+2 {\n+\t\treturn nil\n+\t}\n+\n+\tx := &ocfbDecrypter{\n+\t\tb:       block,\n+\t\tfre:     make([]byte, blockSize),\n+\t\toutUsed: 0,\n+\t}\n+\tprefixCopy := make([]byte, len(prefix))\n+\tcopy(prefixCopy, prefix)\n+\n+\tblock.Encrypt(x.fre, x.fre)\n+\tfor i := 0; i < blockSize; i++ {\n+\t\tprefixCopy[i] ^= x.fre[i]\n+\t}\n+\n+\tblock.Encrypt(x.fre, prefix[:blockSize])\n+\tprefixCopy[blockSize] ^= x.fre[0]\n+\tprefixCopy[blockSize+1] ^= x.fre[1]\n+\n+\tif prefixCopy[blockSize-2] != prefixCopy[blockSize] ||\n+\t\tprefixCopy[blockSize-1] != prefixCopy[blockSize+1] {\n+\t\treturn nil\n+\t}\n+\n+\tblock.Encrypt(x.fre, prefix[2:])\n+\treturn x\n+}\n+\n+func (x *ocfbDecrypter) XORKeyStream(dst, src []byte) {\n+\tfor i := 0; i < len(src); i++ {\n+\t\tif x.outUsed == len(x.fre) {\n+\t\t\tx.b.Encrypt(x.fre, x.fre)\n+\t\t\tx.outUsed = 0\n+\t\t}\n+\n+\t\tc := src[i]\n+\t\tdst[i] = x.fre[x.outUsed] ^ src[i]\n+\t\tx.fre[x.outUsed] = c\n+\t\tx.outUsed++\n+\t}\n+}"}, {"sha": "289bb7c91e540f38cd827b60a580d1941578e036", "filename": "libgo/go/crypto/cipher/ocfb_test.go", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Fcipher%2Focfb_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Fcipher%2Focfb_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Focfb_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cipher\n+\n+import (\n+\t\"bytes\"\n+\t\"crypto/aes\"\n+\t\"crypto/rand\"\n+\t\"testing\"\n+)\n+\n+func TestOCFB(t *testing.T) {\n+\tblock, err := aes.NewCipher(commonKey128)\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t\treturn\n+\t}\n+\n+\tplaintext := []byte(\"this is the plaintext\")\n+\trandData := make([]byte, block.BlockSize())\n+\trand.Reader.Read(randData)\n+\tocfb, prefix := NewOCFBEncrypter(block, randData)\n+\tciphertext := make([]byte, len(plaintext))\n+\tocfb.XORKeyStream(ciphertext, plaintext)\n+\n+\tocfbdec := NewOCFBDecrypter(block, prefix)\n+\tif ocfbdec == nil {\n+\t\tt.Error(\"NewOCFBDecrypter failed\")\n+\t\treturn\n+\t}\n+\tplaintextCopy := make([]byte, len(plaintext))\n+\tocfbdec.XORKeyStream(plaintextCopy, ciphertext)\n+\n+\tif !bytes.Equal(plaintextCopy, plaintext) {\n+\t\tt.Errorf(\"got: %x, want: %x\", plaintextCopy, plaintext)\n+\t}\n+}"}, {"sha": "85e5f02b0a64e4c7eca2db7351c9f48ae4dfaa71", "filename": "libgo/go/crypto/cipher/ofb.go", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Fcipher%2Fofb.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Fcipher%2Fofb.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fofb.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// OFB (Output Feedback) Mode.\n+\n+package cipher\n+\n+type ofb struct {\n+\tb       Block\n+\tout     []byte\n+\toutUsed int\n+}\n+\n+// NewOFB returns a Stream that encrypts or decrypts using the block cipher b\n+// in output feedback mode. The initialization vector iv's length must be equal\n+// to b's block size.\n+func NewOFB(b Block, iv []byte) Stream {\n+\tblockSize := b.BlockSize()\n+\tif len(iv) != blockSize {\n+\t\treturn nil\n+\t}\n+\n+\tx := &ofb{\n+\t\tb:       b,\n+\t\tout:     make([]byte, blockSize),\n+\t\toutUsed: 0,\n+\t}\n+\tb.Encrypt(x.out, iv)\n+\n+\treturn x\n+}\n+\n+func (x *ofb) XORKeyStream(dst, src []byte) {\n+\tfor i, s := range src {\n+\t\tif x.outUsed == len(x.out) {\n+\t\t\tx.b.Encrypt(x.out, x.out)\n+\t\t\tx.outUsed = 0\n+\t\t}\n+\n+\t\tdst[i] = s ^ x.out[x.outUsed]\n+\t\tx.outUsed++\n+\t}\n+}"}, {"sha": "9b4495c88305ed7f567c0532fd37635aa92b113f", "filename": "libgo/go/crypto/cipher/ofb_test.go", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Fcipher%2Fofb_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Fcipher%2Fofb_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fofb_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -0,0 +1,101 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// OFB AES test vectors.\n+\n+// See U.S. National Institute of Standards and Technology (NIST)\n+// Special Publication 800-38A, ``Recommendation for Block Cipher\n+// Modes of Operation,'' 2001 Edition, pp. 52-55.\n+\n+package cipher\n+\n+import (\n+\t\"bytes\"\n+\t\"crypto/aes\"\n+\t\"testing\"\n+)\n+\n+type ofbTest struct {\n+\tname string\n+\tkey  []byte\n+\tiv   []byte\n+\tin   []byte\n+\tout  []byte\n+}\n+\n+var ofbTests = []ofbTest{\n+\t// NIST SP 800-38A pp 52-55\n+\t{\n+\t\t\"OFB-AES128\",\n+\t\tcommonKey128,\n+\t\tcommonIV,\n+\t\tcommonInput,\n+\t\t[]byte{\n+\t\t\t0x3b, 0x3f, 0xd9, 0x2e, 0xb7, 0x2d, 0xad, 0x20, 0x33, 0x34, 0x49, 0xf8, 0xe8, 0x3c, 0xfb, 0x4a,\n+\t\t\t0x77, 0x89, 0x50, 0x8d, 0x16, 0x91, 0x8f, 0x03, 0xf5, 0x3c, 0x52, 0xda, 0xc5, 0x4e, 0xd8, 0x25,\n+\t\t\t0x97, 0x40, 0x05, 0x1e, 0x9c, 0x5f, 0xec, 0xf6, 0x43, 0x44, 0xf7, 0xa8, 0x22, 0x60, 0xed, 0xcc,\n+\t\t\t0x30, 0x4c, 0x65, 0x28, 0xf6, 0x59, 0xc7, 0x78, 0x66, 0xa5, 0x10, 0xd9, 0xc1, 0xd6, 0xae, 0x5e,\n+\t\t},\n+\t},\n+\t{\n+\t\t\"OFB-AES192\",\n+\t\tcommonKey192,\n+\t\tcommonIV,\n+\t\tcommonInput,\n+\t\t[]byte{\n+\t\t\t0xcd, 0xc8, 0x0d, 0x6f, 0xdd, 0xf1, 0x8c, 0xab, 0x34, 0xc2, 0x59, 0x09, 0xc9, 0x9a, 0x41, 0x74,\n+\t\t\t0xfc, 0xc2, 0x8b, 0x8d, 0x4c, 0x63, 0x83, 0x7c, 0x09, 0xe8, 0x17, 0x00, 0xc1, 0x10, 0x04, 0x01,\n+\t\t\t0x8d, 0x9a, 0x9a, 0xea, 0xc0, 0xf6, 0x59, 0x6f, 0x55, 0x9c, 0x6d, 0x4d, 0xaf, 0x59, 0xa5, 0xf2,\n+\t\t\t0x6d, 0x9f, 0x20, 0x08, 0x57, 0xca, 0x6c, 0x3e, 0x9c, 0xac, 0x52, 0x4b, 0xd9, 0xac, 0xc9, 0x2a,\n+\t\t},\n+\t},\n+\t{\n+\t\t\"OFB-AES256\",\n+\t\tcommonKey256,\n+\t\tcommonIV,\n+\t\tcommonInput,\n+\t\t[]byte{\n+\t\t\t0xdc, 0x7e, 0x84, 0xbf, 0xda, 0x79, 0x16, 0x4b, 0x7e, 0xcd, 0x84, 0x86, 0x98, 0x5d, 0x38, 0x60,\n+\t\t\t0x4f, 0xeb, 0xdc, 0x67, 0x40, 0xd2, 0x0b, 0x3a, 0xc8, 0x8f, 0x6a, 0xd8, 0x2a, 0x4f, 0xb0, 0x8d,\n+\t\t\t0x71, 0xab, 0x47, 0xa0, 0x86, 0xe8, 0x6e, 0xed, 0xf3, 0x9d, 0x1c, 0x5b, 0xba, 0x97, 0xc4, 0x08,\n+\t\t\t0x01, 0x26, 0x14, 0x1d, 0x67, 0xf3, 0x7b, 0xe8, 0x53, 0x8f, 0x5a, 0x8b, 0xe7, 0x40, 0xe4, 0x84,\n+\t\t},\n+\t},\n+}\n+\n+func TestOFB(t *testing.T) {\n+\tfor _, tt := range ofbTests {\n+\t\ttest := tt.name\n+\n+\t\tc, err := aes.NewCipher(tt.key)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"%s: NewCipher(%d bytes) = %s\", test, len(tt.key), err)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tfor j := 0; j <= 5; j += 5 {\n+\t\t\tplaintext := tt.in[0 : len(tt.in)-j]\n+\t\t\tofb := NewOFB(c, tt.iv)\n+\t\t\tciphertext := make([]byte, len(plaintext))\n+\t\t\tofb.XORKeyStream(ciphertext, plaintext)\n+\t\t\tif !bytes.Equal(ciphertext, tt.out[:len(plaintext)]) {\n+\t\t\t\tt.Errorf(\"%s/%d: encrypting\\ninput % x\\nhave % x\\nwant % x\", test, len(plaintext), plaintext, ciphertext, tt.out)\n+\t\t\t}\n+\t\t}\n+\n+\t\tfor j := 0; j <= 5; j += 5 {\n+\t\t\tciphertext := tt.out[0 : len(tt.in)-j]\n+\t\t\tofb := NewOFB(c, tt.iv)\n+\t\t\tplaintext := make([]byte, len(ciphertext))\n+\t\t\tofb.XORKeyStream(plaintext, ciphertext)\n+\t\t\tif !bytes.Equal(plaintext, tt.in[:len(ciphertext)]) {\n+\t\t\t\tt.Errorf(\"%s/%d: decrypting\\nhave % x\\nwant % x\", test, len(ciphertext), plaintext, tt.in)\n+\t\t\t}\n+\t\t}\n+\n+\t\tif t.Failed() {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+}"}, {"sha": "beac45ca074489e641423491eac1f4fb8a2abbb8", "filename": "libgo/go/crypto/elliptic/elliptic.go", "status": "added", "additions": 376, "deletions": 0, "changes": 376, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -0,0 +1,376 @@\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// The elliptic package implements several standard elliptic curves over prime\n+// fields\n+package elliptic\n+\n+// This package operates, internally, on Jacobian coordinates. For a given\n+// (x, y) position on the curve, the Jacobian coordinates are (x1, y1, z1)\n+// where x = x1/z1\u00b2 and y = y1/z1\u00b3. The greatest speedups come when the whole\n+// calculation can be performed within the transform (as in ScalarMult and\n+// ScalarBaseMult). But even for Add and Double, it's faster to apply and\n+// reverse the transform than to operate in affine coordinates.\n+\n+import (\n+\t\"big\"\n+\t\"io\"\n+\t\"os\"\n+\t\"sync\"\n+)\n+\n+// A Curve represents a short-form Weierstrass curve with a=-3.\n+// See http://www.hyperelliptic.org/EFD/g1p/auto-shortw.html\n+type Curve struct {\n+\tP       *big.Int // the order of the underlying field\n+\tB       *big.Int // the constant of the curve equation\n+\tGx, Gy  *big.Int // (x,y) of the base point\n+\tBitSize int      // the size of the underlying field\n+}\n+\n+// IsOnCurve returns true if the given (x,y) lies on the curve.\n+func (curve *Curve) IsOnCurve(x, y *big.Int) bool {\n+\t// y\u00b2 = x\u00b3 - 3x + b\n+\ty2 := new(big.Int).Mul(y, y)\n+\ty2.Mod(y2, curve.P)\n+\n+\tx3 := new(big.Int).Mul(x, x)\n+\tx3.Mul(x3, x)\n+\n+\tthreeX := new(big.Int).Lsh(x, 1)\n+\tthreeX.Add(threeX, x)\n+\n+\tx3.Sub(x3, threeX)\n+\tx3.Add(x3, curve.B)\n+\tx3.Mod(x3, curve.P)\n+\n+\treturn x3.Cmp(y2) == 0\n+}\n+\n+// affineFromJacobian reverses the Jacobian transform. See the comment at the\n+// top of the file.\n+func (curve *Curve) affineFromJacobian(x, y, z *big.Int) (xOut, yOut *big.Int) {\n+\tzinv := new(big.Int).ModInverse(z, curve.P)\n+\tzinvsq := new(big.Int).Mul(zinv, zinv)\n+\n+\txOut = new(big.Int).Mul(x, zinvsq)\n+\txOut.Mod(xOut, curve.P)\n+\tzinvsq.Mul(zinvsq, zinv)\n+\tyOut = new(big.Int).Mul(y, zinvsq)\n+\tyOut.Mod(yOut, curve.P)\n+\treturn\n+}\n+\n+// Add returns the sum of (x1,y1) and (x2,y2)\n+func (curve *Curve) Add(x1, y1, x2, y2 *big.Int) (*big.Int, *big.Int) {\n+\tz := new(big.Int).SetInt64(1)\n+\treturn curve.affineFromJacobian(curve.addJacobian(x1, y1, z, x2, y2, z))\n+}\n+\n+// addJacobian takes two points in Jacobian coordinates, (x1, y1, z1) and\n+// (x2, y2, z2) and returns their sum, also in Jacobian form.\n+func (curve *Curve) addJacobian(x1, y1, z1, x2, y2, z2 *big.Int) (*big.Int, *big.Int, *big.Int) {\n+\t// See http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#addition-add-2007-bl\n+\tz1z1 := new(big.Int).Mul(z1, z1)\n+\tz1z1.Mod(z1z1, curve.P)\n+\tz2z2 := new(big.Int).Mul(z2, z2)\n+\tz2z2.Mod(z2z2, curve.P)\n+\n+\tu1 := new(big.Int).Mul(x1, z2z2)\n+\tu1.Mod(u1, curve.P)\n+\tu2 := new(big.Int).Mul(x2, z1z1)\n+\tu2.Mod(u2, curve.P)\n+\th := new(big.Int).Sub(u2, u1)\n+\tif h.Sign() == -1 {\n+\t\th.Add(h, curve.P)\n+\t}\n+\ti := new(big.Int).Lsh(h, 1)\n+\ti.Mul(i, i)\n+\tj := new(big.Int).Mul(h, i)\n+\n+\ts1 := new(big.Int).Mul(y1, z2)\n+\ts1.Mul(s1, z2z2)\n+\ts1.Mod(s1, curve.P)\n+\ts2 := new(big.Int).Mul(y2, z1)\n+\ts2.Mul(s2, z1z1)\n+\ts2.Mod(s2, curve.P)\n+\tr := new(big.Int).Sub(s2, s1)\n+\tif r.Sign() == -1 {\n+\t\tr.Add(r, curve.P)\n+\t}\n+\tr.Lsh(r, 1)\n+\tv := new(big.Int).Mul(u1, i)\n+\n+\tx3 := new(big.Int).Set(r)\n+\tx3.Mul(x3, x3)\n+\tx3.Sub(x3, j)\n+\tx3.Sub(x3, v)\n+\tx3.Sub(x3, v)\n+\tx3.Mod(x3, curve.P)\n+\n+\ty3 := new(big.Int).Set(r)\n+\tv.Sub(v, x3)\n+\ty3.Mul(y3, v)\n+\ts1.Mul(s1, j)\n+\ts1.Lsh(s1, 1)\n+\ty3.Sub(y3, s1)\n+\ty3.Mod(y3, curve.P)\n+\n+\tz3 := new(big.Int).Add(z1, z2)\n+\tz3.Mul(z3, z3)\n+\tz3.Sub(z3, z1z1)\n+\tif z3.Sign() == -1 {\n+\t\tz3.Add(z3, curve.P)\n+\t}\n+\tz3.Sub(z3, z2z2)\n+\tif z3.Sign() == -1 {\n+\t\tz3.Add(z3, curve.P)\n+\t}\n+\tz3.Mul(z3, h)\n+\tz3.Mod(z3, curve.P)\n+\n+\treturn x3, y3, z3\n+}\n+\n+// Double returns 2*(x,y)\n+func (curve *Curve) Double(x1, y1 *big.Int) (*big.Int, *big.Int) {\n+\tz1 := new(big.Int).SetInt64(1)\n+\treturn curve.affineFromJacobian(curve.doubleJacobian(x1, y1, z1))\n+}\n+\n+// doubleJacobian takes a point in Jacobian coordinates, (x, y, z), and\n+// returns its double, also in Jacobian form.\n+func (curve *Curve) doubleJacobian(x, y, z *big.Int) (*big.Int, *big.Int, *big.Int) {\n+\t// See http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b\n+\tdelta := new(big.Int).Mul(z, z)\n+\tdelta.Mod(delta, curve.P)\n+\tgamma := new(big.Int).Mul(y, y)\n+\tgamma.Mod(gamma, curve.P)\n+\talpha := new(big.Int).Sub(x, delta)\n+\tif alpha.Sign() == -1 {\n+\t\talpha.Add(alpha, curve.P)\n+\t}\n+\talpha2 := new(big.Int).Add(x, delta)\n+\talpha.Mul(alpha, alpha2)\n+\talpha2.Set(alpha)\n+\talpha.Lsh(alpha, 1)\n+\talpha.Add(alpha, alpha2)\n+\n+\tbeta := alpha2.Mul(x, gamma)\n+\n+\tx3 := new(big.Int).Mul(alpha, alpha)\n+\tbeta8 := new(big.Int).Lsh(beta, 3)\n+\tx3.Sub(x3, beta8)\n+\tfor x3.Sign() == -1 {\n+\t\tx3.Add(x3, curve.P)\n+\t}\n+\tx3.Mod(x3, curve.P)\n+\n+\tz3 := new(big.Int).Add(y, z)\n+\tz3.Mul(z3, z3)\n+\tz3.Sub(z3, gamma)\n+\tif z3.Sign() == -1 {\n+\t\tz3.Add(z3, curve.P)\n+\t}\n+\tz3.Sub(z3, delta)\n+\tif z3.Sign() == -1 {\n+\t\tz3.Add(z3, curve.P)\n+\t}\n+\tz3.Mod(z3, curve.P)\n+\n+\tbeta.Lsh(beta, 2)\n+\tbeta.Sub(beta, x3)\n+\tif beta.Sign() == -1 {\n+\t\tbeta.Add(beta, curve.P)\n+\t}\n+\ty3 := alpha.Mul(alpha, beta)\n+\n+\tgamma.Mul(gamma, gamma)\n+\tgamma.Lsh(gamma, 3)\n+\tgamma.Mod(gamma, curve.P)\n+\n+\ty3.Sub(y3, gamma)\n+\tif y3.Sign() == -1 {\n+\t\ty3.Add(y3, curve.P)\n+\t}\n+\ty3.Mod(y3, curve.P)\n+\n+\treturn x3, y3, z3\n+}\n+\n+// ScalarMult returns k*(Bx,By) where k is a number in big-endian form.\n+func (curve *Curve) ScalarMult(Bx, By *big.Int, k []byte) (*big.Int, *big.Int) {\n+\t// We have a slight problem in that the identity of the group (the\n+\t// point at infinity) cannot be represented in (x, y) form on a finite\n+\t// machine. Thus the standard add/double algorithm has to be tweaked\n+\t// slightly: our initial state is not the identity, but x, and we\n+\t// ignore the first true bit in |k|.  If we don't find any true bits in\n+\t// |k|, then we return nil, nil, because we cannot return the identity\n+\t// element.\n+\n+\tBz := new(big.Int).SetInt64(1)\n+\tx := Bx\n+\ty := By\n+\tz := Bz\n+\n+\tseenFirstTrue := false\n+\tfor _, byte := range k {\n+\t\tfor bitNum := 0; bitNum < 8; bitNum++ {\n+\t\t\tif seenFirstTrue {\n+\t\t\t\tx, y, z = curve.doubleJacobian(x, y, z)\n+\t\t\t}\n+\t\t\tif byte&0x80 == 0x80 {\n+\t\t\t\tif !seenFirstTrue {\n+\t\t\t\t\tseenFirstTrue = true\n+\t\t\t\t} else {\n+\t\t\t\t\tx, y, z = curve.addJacobian(Bx, By, Bz, x, y, z)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tbyte <<= 1\n+\t\t}\n+\t}\n+\n+\tif !seenFirstTrue {\n+\t\treturn nil, nil\n+\t}\n+\n+\treturn curve.affineFromJacobian(x, y, z)\n+}\n+\n+// ScalarBaseMult returns k*G, where G is the base point of the group and k is\n+// an integer in big-endian form.\n+func (curve *Curve) ScalarBaseMult(k []byte) (*big.Int, *big.Int) {\n+\treturn curve.ScalarMult(curve.Gx, curve.Gy, k)\n+}\n+\n+var mask = []byte{0xff, 0x1, 0x3, 0x7, 0xf, 0x1f, 0x3f, 0x7f}\n+\n+// GenerateKey returns a public/private key pair. The private key is generated\n+// using the given reader, which must return random data.\n+func (curve *Curve) GenerateKey(rand io.Reader) (priv []byte, x, y *big.Int, err os.Error) {\n+\tbyteLen := (curve.BitSize + 7) >> 3\n+\tpriv = make([]byte, byteLen)\n+\n+\tfor x == nil {\n+\t\t_, err = io.ReadFull(rand, priv)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\t// We have to mask off any excess bits in the case that the size of the\n+\t\t// underlying field is not a whole number of bytes.\n+\t\tpriv[0] &= mask[curve.BitSize%8]\n+\t\t// This is because, in tests, rand will return all zeros and we don't\n+\t\t// want to get the point at infinity and loop forever.\n+\t\tpriv[1] ^= 0x42\n+\t\tx, y = curve.ScalarBaseMult(priv)\n+\t}\n+\treturn\n+}\n+\n+// Marshal converts a point into the form specified in section 4.3.6 of ANSI\n+// X9.62.\n+func (curve *Curve) Marshal(x, y *big.Int) []byte {\n+\tbyteLen := (curve.BitSize + 7) >> 3\n+\n+\tret := make([]byte, 1+2*byteLen)\n+\tret[0] = 4 // uncompressed point\n+\n+\txBytes := x.Bytes()\n+\tcopy(ret[1+byteLen-len(xBytes):], xBytes)\n+\tyBytes := y.Bytes()\n+\tcopy(ret[1+2*byteLen-len(yBytes):], yBytes)\n+\treturn ret\n+}\n+\n+// Unmarshal converts a point, serialised by Marshal, into an x, y pair. On\n+// error, x = nil.\n+func (curve *Curve) Unmarshal(data []byte) (x, y *big.Int) {\n+\tbyteLen := (curve.BitSize + 7) >> 3\n+\tif len(data) != 1+2*byteLen {\n+\t\treturn\n+\t}\n+\tif data[0] != 4 { // uncompressed form\n+\t\treturn\n+\t}\n+\tx = new(big.Int).SetBytes(data[1 : 1+byteLen])\n+\ty = new(big.Int).SetBytes(data[1+byteLen:])\n+\treturn\n+}\n+\n+var initonce sync.Once\n+var p224 *Curve\n+var p256 *Curve\n+var p384 *Curve\n+var p521 *Curve\n+\n+func initAll() {\n+\tinitP224()\n+\tinitP256()\n+\tinitP384()\n+\tinitP521()\n+}\n+\n+func initP224() {\n+\t// See FIPS 186-3, section D.2.2\n+\tp224 = new(Curve)\n+\tp224.P, _ = new(big.Int).SetString(\"26959946667150639794667015087019630673557916260026308143510066298881\", 10)\n+\tp224.B, _ = new(big.Int).SetString(\"b4050a850c04b3abf54132565044b0b7d7bfd8ba270b39432355ffb4\", 16)\n+\tp224.Gx, _ = new(big.Int).SetString(\"b70e0cbd6bb4bf7f321390b94a03c1d356c21122343280d6115c1d21\", 16)\n+\tp224.Gy, _ = new(big.Int).SetString(\"bd376388b5f723fb4c22dfe6cd4375a05a07476444d5819985007e34\", 16)\n+\tp224.BitSize = 224\n+}\n+\n+func initP256() {\n+\t// See FIPS 186-3, section D.2.3\n+\tp256 = new(Curve)\n+\tp256.P, _ = new(big.Int).SetString(\"115792089210356248762697446949407573530086143415290314195533631308867097853951\", 10)\n+\tp256.B, _ = new(big.Int).SetString(\"5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b\", 16)\n+\tp256.Gx, _ = new(big.Int).SetString(\"6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296\", 16)\n+\tp256.Gy, _ = new(big.Int).SetString(\"4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5\", 16)\n+\tp256.BitSize = 256\n+}\n+\n+func initP384() {\n+\t// See FIPS 186-3, section D.2.4\n+\tp384 = new(Curve)\n+\tp384.P, _ = new(big.Int).SetString(\"39402006196394479212279040100143613805079739270465446667948293404245721771496870329047266088258938001861606973112319\", 10)\n+\tp384.B, _ = new(big.Int).SetString(\"b3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef\", 16)\n+\tp384.Gx, _ = new(big.Int).SetString(\"aa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7\", 16)\n+\tp384.Gy, _ = new(big.Int).SetString(\"3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f\", 16)\n+\tp384.BitSize = 384\n+}\n+\n+func initP521() {\n+\t// See FIPS 186-3, section D.2.5\n+\tp521 = new(Curve)\n+\tp521.P, _ = new(big.Int).SetString(\"6864797660130609714981900799081393217269435300143305409394463459185543183397656052122559640661454554977296311391480858037121987999716643812574028291115057151\", 10)\n+\tp521.B, _ = new(big.Int).SetString(\"051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00\", 16)\n+\tp521.Gx, _ = new(big.Int).SetString(\"c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66\", 16)\n+\tp521.Gy, _ = new(big.Int).SetString(\"11839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650\", 16)\n+\tp521.BitSize = 521\n+}\n+\n+// P224 returns a Curve which implements P-224 (see FIPS 186-3, section D.2.2)\n+func P224() *Curve {\n+\tinitonce.Do(initAll)\n+\treturn p224\n+}\n+\n+// P256 returns a Curve which implements P-256 (see FIPS 186-3, section D.2.3)\n+func P256() *Curve {\n+\tinitonce.Do(initAll)\n+\treturn p256\n+}\n+\n+// P384 returns a Curve which implements P-384 (see FIPS 186-3, section D.2.4)\n+func P384() *Curve {\n+\tinitonce.Do(initAll)\n+\treturn p384\n+}\n+\n+// P256 returns a Curve which implements P-521 (see FIPS 186-3, section D.2.5)\n+func P521() *Curve {\n+\tinitonce.Do(initAll)\n+\treturn p521\n+}"}, {"sha": "6ae6fb96d3ba6f259a2857a5fa72b5687058e2ba", "filename": "libgo/go/crypto/elliptic/elliptic_test.go", "status": "added", "additions": 331, "deletions": 0, "changes": 331, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -0,0 +1,331 @@\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package elliptic\n+\n+import (\n+\t\"big\"\n+\t\"crypto/rand\"\n+\t\"fmt\"\n+\t\"testing\"\n+)\n+\n+func TestOnCurve(t *testing.T) {\n+\tp224 := P224()\n+\tif !p224.IsOnCurve(p224.Gx, p224.Gy) {\n+\t\tt.Errorf(\"FAIL\")\n+\t}\n+}\n+\n+type baseMultTest struct {\n+\tk    string\n+\tx, y string\n+}\n+\n+var p224BaseMultTests = []baseMultTest{\n+\t{\n+\t\t\"1\",\n+\t\t\"b70e0cbd6bb4bf7f321390b94a03c1d356c21122343280d6115c1d21\",\n+\t\t\"bd376388b5f723fb4c22dfe6cd4375a05a07476444d5819985007e34\",\n+\t},\n+\t{\n+\t\t\"2\",\n+\t\t\"706a46dc76dcb76798e60e6d89474788d16dc18032d268fd1a704fa6\",\n+\t\t\"1c2b76a7bc25e7702a704fa986892849fca629487acf3709d2e4e8bb\",\n+\t},\n+\t{\n+\t\t\"3\",\n+\t\t\"df1b1d66a551d0d31eff822558b9d2cc75c2180279fe0d08fd896d04\",\n+\t\t\"a3f7f03cadd0be444c0aa56830130ddf77d317344e1af3591981a925\",\n+\t},\n+\t{\n+\t\t\"4\",\n+\t\t\"ae99feebb5d26945b54892092a8aee02912930fa41cd114e40447301\",\n+\t\t\"482580a0ec5bc47e88bc8c378632cd196cb3fa058a7114eb03054c9\",\n+\t},\n+\t{\n+\t\t\"5\",\n+\t\t\"31c49ae75bce7807cdff22055d94ee9021fedbb5ab51c57526f011aa\",\n+\t\t\"27e8bff1745635ec5ba0c9f1c2ede15414c6507d29ffe37e790a079b\",\n+\t},\n+\t{\n+\t\t\"6\",\n+\t\t\"1f2483f82572251fca975fea40db821df8ad82a3c002ee6c57112408\",\n+\t\t\"89faf0ccb750d99b553c574fad7ecfb0438586eb3952af5b4b153c7e\",\n+\t},\n+\t{\n+\t\t\"7\",\n+\t\t\"db2f6be630e246a5cf7d99b85194b123d487e2d466b94b24a03c3e28\",\n+\t\t\"f3a30085497f2f611ee2517b163ef8c53b715d18bb4e4808d02b963\",\n+\t},\n+\t{\n+\t\t\"8\",\n+\t\t\"858e6f9cc6c12c31f5df124aa77767b05c8bc021bd683d2b55571550\",\n+\t\t\"46dcd3ea5c43898c5c5fc4fdac7db39c2f02ebee4e3541d1e78047a\",\n+\t},\n+\t{\n+\t\t\"9\",\n+\t\t\"2fdcccfee720a77ef6cb3bfbb447f9383117e3daa4a07e36ed15f78d\",\n+\t\t\"371732e4f41bf4f7883035e6a79fcedc0e196eb07b48171697517463\",\n+\t},\n+\t{\n+\t\t\"10\",\n+\t\t\"aea9e17a306517eb89152aa7096d2c381ec813c51aa880e7bee2c0fd\",\n+\t\t\"39bb30eab337e0a521b6cba1abe4b2b3a3e524c14a3fe3eb116b655f\",\n+\t},\n+\t{\n+\t\t\"11\",\n+\t\t\"ef53b6294aca431f0f3c22dc82eb9050324f1d88d377e716448e507c\",\n+\t\t\"20b510004092e96636cfb7e32efded8265c266dfb754fa6d6491a6da\",\n+\t},\n+\t{\n+\t\t\"12\",\n+\t\t\"6e31ee1dc137f81b056752e4deab1443a481033e9b4c93a3044f4f7a\",\n+\t\t\"207dddf0385bfdeab6e9acda8da06b3bbef224a93ab1e9e036109d13\",\n+\t},\n+\t{\n+\t\t\"13\",\n+\t\t\"34e8e17a430e43289793c383fac9774247b40e9ebd3366981fcfaeca\",\n+\t\t\"252819f71c7fb7fbcb159be337d37d3336d7feb963724fdfb0ecb767\",\n+\t},\n+\t{\n+\t\t\"14\",\n+\t\t\"a53640c83dc208603ded83e4ecf758f24c357d7cf48088b2ce01e9fa\",\n+\t\t\"d5814cd724199c4a5b974a43685fbf5b8bac69459c9469bc8f23ccaf\",\n+\t},\n+\t{\n+\t\t\"15\",\n+\t\t\"baa4d8635511a7d288aebeedd12ce529ff102c91f97f867e21916bf9\",\n+\t\t\"979a5f4759f80f4fb4ec2e34f5566d595680a11735e7b61046127989\",\n+\t},\n+\t{\n+\t\t\"16\",\n+\t\t\"b6ec4fe1777382404ef679997ba8d1cc5cd8e85349259f590c4c66d\",\n+\t\t\"3399d464345906b11b00e363ef429221f2ec720d2f665d7dead5b482\",\n+\t},\n+\t{\n+\t\t\"17\",\n+\t\t\"b8357c3a6ceef288310e17b8bfeff9200846ca8c1942497c484403bc\",\n+\t\t\"ff149efa6606a6bd20ef7d1b06bd92f6904639dce5174db6cc554a26\",\n+\t},\n+\t{\n+\t\t\"18\",\n+\t\t\"c9ff61b040874c0568479216824a15eab1a838a797d189746226e4cc\",\n+\t\t\"ea98d60e5ffc9b8fcf999fab1df7e7ef7084f20ddb61bb045a6ce002\",\n+\t},\n+\t{\n+\t\t\"19\",\n+\t\t\"a1e81c04f30ce201c7c9ace785ed44cc33b455a022f2acdbc6cae83c\",\n+\t\t\"dcf1f6c3db09c70acc25391d492fe25b4a180babd6cea356c04719cd\",\n+\t},\n+\t{\n+\t\t\"20\",\n+\t\t\"fcc7f2b45df1cd5a3c0c0731ca47a8af75cfb0347e8354eefe782455\",\n+\t\t\"d5d7110274cba7cdee90e1a8b0d394c376a5573db6be0bf2747f530\",\n+\t},\n+\t{\n+\t\t\"112233445566778899\",\n+\t\t\"61f077c6f62ed802dad7c2f38f5c67f2cc453601e61bd076bb46179e\",\n+\t\t\"2272f9e9f5933e70388ee652513443b5e289dd135dcc0d0299b225e4\",\n+\t},\n+\t{\n+\t\t\"112233445566778899112233445566778899\",\n+\t\t\"29895f0af496bfc62b6ef8d8a65c88c613949b03668aab4f0429e35\",\n+\t\t\"3ea6e53f9a841f2019ec24bde1a75677aa9b5902e61081c01064de93\",\n+\t},\n+\t{\n+\t\t\"6950511619965839450988900688150712778015737983940691968051900319680\",\n+\t\t\"ab689930bcae4a4aa5f5cb085e823e8ae30fd365eb1da4aba9cf0379\",\n+\t\t\"3345a121bbd233548af0d210654eb40bab788a03666419be6fbd34e7\",\n+\t},\n+\t{\n+\t\t\"13479972933410060327035789020509431695094902435494295338570602119423\",\n+\t\t\"bdb6a8817c1f89da1c2f3dd8e97feb4494f2ed302a4ce2bc7f5f4025\",\n+\t\t\"4c7020d57c00411889462d77a5438bb4e97d177700bf7243a07f1680\",\n+\t},\n+\t{\n+\t\t\"13479971751745682581351455311314208093898607229429740618390390702079\",\n+\t\t\"d58b61aa41c32dd5eba462647dba75c5d67c83606c0af2bd928446a9\",\n+\t\t\"d24ba6a837be0460dd107ae77725696d211446c5609b4595976b16bd\",\n+\t},\n+\t{\n+\t\t\"13479972931865328106486971546324465392952975980343228160962702868479\",\n+\t\t\"dc9fa77978a005510980e929a1485f63716df695d7a0c18bb518df03\",\n+\t\t\"ede2b016f2ddffc2a8c015b134928275ce09e5661b7ab14ce0d1d403\",\n+\t},\n+\t{\n+\t\t\"11795773708834916026404142434151065506931607341523388140225443265536\",\n+\t\t\"499d8b2829cfb879c901f7d85d357045edab55028824d0f05ba279ba\",\n+\t\t\"bf929537b06e4015919639d94f57838fa33fc3d952598dcdbb44d638\",\n+\t},\n+\t{\n+\t\t\"784254593043826236572847595991346435467177662189391577090\",\n+\t\t\"8246c999137186632c5f9eddf3b1b0e1764c5e8bd0e0d8a554b9cb77\",\n+\t\t\"e80ed8660bc1cb17ac7d845be40a7a022d3306f116ae9f81fea65947\",\n+\t},\n+\t{\n+\t\t\"13479767645505654746623887797783387853576174193480695826442858012671\",\n+\t\t\"6670c20afcceaea672c97f75e2e9dd5c8460e54bb38538ebb4bd30eb\",\n+\t\t\"f280d8008d07a4caf54271f993527d46ff3ff46fd1190a3f1faa4f74\",\n+\t},\n+\t{\n+\t\t\"205688069665150753842126177372015544874550518966168735589597183\",\n+\t\t\"eca934247425cfd949b795cb5ce1eff401550386e28d1a4c5a8eb\",\n+\t\t\"d4c01040dba19628931bc8855370317c722cbd9ca6156985f1c2e9ce\",\n+\t},\n+\t{\n+\t\t\"13479966930919337728895168462090683249159702977113823384618282123295\",\n+\t\t\"ef353bf5c73cd551b96d596fbc9a67f16d61dd9fe56af19de1fba9cd\",\n+\t\t\"21771b9cdce3e8430c09b3838be70b48c21e15bc09ee1f2d7945b91f\",\n+\t},\n+\t{\n+\t\t\"50210731791415612487756441341851895584393717453129007497216\",\n+\t\t\"4036052a3091eb481046ad3289c95d3ac905ca0023de2c03ecd451cf\",\n+\t\t\"d768165a38a2b96f812586a9d59d4136035d9c853a5bf2e1c86a4993\",\n+\t},\n+\t{\n+\t\t\"26959946667150639794667015087019625940457807714424391721682722368041\",\n+\t\t\"fcc7f2b45df1cd5a3c0c0731ca47a8af75cfb0347e8354eefe782455\",\n+\t\t\"f2a28eefd8b345832116f1e574f2c6b2c895aa8c24941f40d8b80ad1\",\n+\t},\n+\t{\n+\t\t\"26959946667150639794667015087019625940457807714424391721682722368042\",\n+\t\t\"a1e81c04f30ce201c7c9ace785ed44cc33b455a022f2acdbc6cae83c\",\n+\t\t\"230e093c24f638f533dac6e2b6d01da3b5e7f45429315ca93fb8e634\",\n+\t},\n+\t{\n+\t\t\"26959946667150639794667015087019625940457807714424391721682722368043\",\n+\t\t\"c9ff61b040874c0568479216824a15eab1a838a797d189746226e4cc\",\n+\t\t\"156729f1a003647030666054e208180f8f7b0df2249e44fba5931fff\",\n+\t},\n+\t{\n+\t\t\"26959946667150639794667015087019625940457807714424391721682722368044\",\n+\t\t\"b8357c3a6ceef288310e17b8bfeff9200846ca8c1942497c484403bc\",\n+\t\t\"eb610599f95942df1082e4f9426d086fb9c6231ae8b24933aab5db\",\n+\t},\n+\t{\n+\t\t\"26959946667150639794667015087019625940457807714424391721682722368045\",\n+\t\t\"b6ec4fe1777382404ef679997ba8d1cc5cd8e85349259f590c4c66d\",\n+\t\t\"cc662b9bcba6f94ee4ff1c9c10bd6ddd0d138df2d099a282152a4b7f\",\n+\t},\n+\t{\n+\t\t\"26959946667150639794667015087019625940457807714424391721682722368046\",\n+\t\t\"baa4d8635511a7d288aebeedd12ce529ff102c91f97f867e21916bf9\",\n+\t\t\"6865a0b8a607f0b04b13d1cb0aa992a5a97f5ee8ca1849efb9ed8678\",\n+\t},\n+\t{\n+\t\t\"26959946667150639794667015087019625940457807714424391721682722368047\",\n+\t\t\"a53640c83dc208603ded83e4ecf758f24c357d7cf48088b2ce01e9fa\",\n+\t\t\"2a7eb328dbe663b5a468b5bc97a040a3745396ba636b964370dc3352\",\n+\t},\n+\t{\n+\t\t\"26959946667150639794667015087019625940457807714424391721682722368048\",\n+\t\t\"34e8e17a430e43289793c383fac9774247b40e9ebd3366981fcfaeca\",\n+\t\t\"dad7e608e380480434ea641cc82c82cbc92801469c8db0204f13489a\",\n+\t},\n+\t{\n+\t\t\"26959946667150639794667015087019625940457807714424391721682722368049\",\n+\t\t\"6e31ee1dc137f81b056752e4deab1443a481033e9b4c93a3044f4f7a\",\n+\t\t\"df82220fc7a4021549165325725f94c3410ddb56c54e161fc9ef62ee\",\n+\t},\n+\t{\n+\t\t\"26959946667150639794667015087019625940457807714424391721682722368050\",\n+\t\t\"ef53b6294aca431f0f3c22dc82eb9050324f1d88d377e716448e507c\",\n+\t\t\"df4aefffbf6d1699c930481cd102127c9a3d992048ab05929b6e5927\",\n+\t},\n+\t{\n+\t\t\"26959946667150639794667015087019625940457807714424391721682722368051\",\n+\t\t\"aea9e17a306517eb89152aa7096d2c381ec813c51aa880e7bee2c0fd\",\n+\t\t\"c644cf154cc81f5ade49345e541b4d4b5c1adb3eb5c01c14ee949aa2\",\n+\t},\n+\t{\n+\t\t\"26959946667150639794667015087019625940457807714424391721682722368052\",\n+\t\t\"2fdcccfee720a77ef6cb3bfbb447f9383117e3daa4a07e36ed15f78d\",\n+\t\t\"c8e8cd1b0be40b0877cfca1958603122f1e6914f84b7e8e968ae8b9e\",\n+\t},\n+\t{\n+\t\t\"26959946667150639794667015087019625940457807714424391721682722368053\",\n+\t\t\"858e6f9cc6c12c31f5df124aa77767b05c8bc021bd683d2b55571550\",\n+\t\t\"fb9232c15a3bc7673a3a03b0253824c53d0fd1411b1cabe2e187fb87\",\n+\t},\n+\t{\n+\t\t\"26959946667150639794667015087019625940457807714424391721682722368054\",\n+\t\t\"db2f6be630e246a5cf7d99b85194b123d487e2d466b94b24a03c3e28\",\n+\t\t\"f0c5cff7ab680d09ee11dae84e9c1072ac48ea2e744b1b7f72fd469e\",\n+\t},\n+\t{\n+\t\t\"26959946667150639794667015087019625940457807714424391721682722368055\",\n+\t\t\"1f2483f82572251fca975fea40db821df8ad82a3c002ee6c57112408\",\n+\t\t\"76050f3348af2664aac3a8b05281304ebc7a7914c6ad50a4b4eac383\",\n+\t},\n+\t{\n+\t\t\"26959946667150639794667015087019625940457807714424391721682722368056\",\n+\t\t\"31c49ae75bce7807cdff22055d94ee9021fedbb5ab51c57526f011aa\",\n+\t\t\"d817400e8ba9ca13a45f360e3d121eaaeb39af82d6001c8186f5f866\",\n+\t},\n+\t{\n+\t\t\"26959946667150639794667015087019625940457807714424391721682722368057\",\n+\t\t\"ae99feebb5d26945b54892092a8aee02912930fa41cd114e40447301\",\n+\t\t\"fb7da7f5f13a43b81774373c879cd32d6934c05fa758eeb14fcfab38\",\n+\t},\n+\t{\n+\t\t\"26959946667150639794667015087019625940457807714424391721682722368058\",\n+\t\t\"df1b1d66a551d0d31eff822558b9d2cc75c2180279fe0d08fd896d04\",\n+\t\t\"5c080fc3522f41bbb3f55a97cfecf21f882ce8cbb1e50ca6e67e56dc\",\n+\t},\n+\t{\n+\t\t\"26959946667150639794667015087019625940457807714424391721682722368059\",\n+\t\t\"706a46dc76dcb76798e60e6d89474788d16dc18032d268fd1a704fa6\",\n+\t\t\"e3d4895843da188fd58fb0567976d7b50359d6b78530c8f62d1b1746\",\n+\t},\n+\t{\n+\t\t\"26959946667150639794667015087019625940457807714424391721682722368060\",\n+\t\t\"b70e0cbd6bb4bf7f321390b94a03c1d356c21122343280d6115c1d21\",\n+\t\t\"42c89c774a08dc04b3dd201932bc8a5ea5f8b89bbb2a7e667aff81cd\",\n+\t},\n+}\n+\n+func TestBaseMult(t *testing.T) {\n+\tp224 := P224()\n+\tfor i, e := range p224BaseMultTests {\n+\t\tk, ok := new(big.Int).SetString(e.k, 10)\n+\t\tif !ok {\n+\t\t\tt.Errorf(\"%d: bad value for k: %s\", i, e.k)\n+\t\t}\n+\t\tx, y := p224.ScalarBaseMult(k.Bytes())\n+\t\tif fmt.Sprintf(\"%x\", x) != e.x || fmt.Sprintf(\"%x\", y) != e.y {\n+\t\t\tt.Errorf(\"%d: bad output for k=%s: got (%x, %s), want (%s, %s)\", i, e.k, x, y, e.x, e.y)\n+\t\t}\n+\t}\n+}\n+\n+func BenchmarkBaseMult(b *testing.B) {\n+\tb.ResetTimer()\n+\tp224 := P224()\n+\te := p224BaseMultTests[25]\n+\tk, _ := new(big.Int).SetString(e.k, 10)\n+\tb.StartTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tp224.ScalarBaseMult(k.Bytes())\n+\t}\n+}\n+\n+func TestMarshal(t *testing.T) {\n+\tp224 := P224()\n+\t_, x, y, err := p224.GenerateKey(rand.Reader)\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t\treturn\n+\t}\n+\tserialised := p224.Marshal(x, y)\n+\txx, yy := p224.Unmarshal(serialised)\n+\tif xx == nil {\n+\t\tt.Error(\"failed to unmarshal\")\n+\t\treturn\n+\t}\n+\tif xx.Cmp(x) != 0 || yy.Cmp(y) != 0 {\n+\t\tt.Error(\"unmarshal returned different values\")\n+\t\treturn\n+\t}\n+}"}, {"sha": "298fb2c06943f3b502bedcd7f3c4fa3ed890a052", "filename": "libgo/go/crypto/hmac/hmac.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -11,6 +11,7 @@ package hmac\n import (\n \t\"crypto/md5\"\n \t\"crypto/sha1\"\n+\t\"crypto/sha256\"\n \t\"hash\"\n \t\"os\"\n )\n@@ -94,3 +95,6 @@ func NewMD5(key []byte) hash.Hash { return New(md5.New, key) }\n \n // NewSHA1 returns a new HMAC-SHA1 hash using the given key.\n func NewSHA1(key []byte) hash.Hash { return New(sha1.New, key) }\n+\n+// NewSHA256 returns a new HMAC-SHA256 hash using the given key.\n+func NewSHA256(key []byte) hash.Hash { return New(sha256.New, key) }"}, {"sha": "40adbad0408f56e165287afb53987e5edb1d691e", "filename": "libgo/go/crypto/hmac/hmac_test.go", "status": "modified", "additions": 107, "deletions": 2, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -17,9 +17,9 @@ type hmacTest struct {\n \tout  string\n }\n \n-// Tests from US FIPS 198\n-// http://csrc.nist.gov/publications/fips/fips198/fips-198a.pdf\n var hmacTests = []hmacTest{\n+\t// Tests from US FIPS 198\n+\t// http://csrc.nist.gov/publications/fips/fips198/fips-198a.pdf\n \t{\n \t\tNewSHA1,\n \t\t[]byte{\n@@ -73,6 +73,111 @@ var hmacTests = []hmacTest{\n \t\t[]byte(\"what do ya want for nothing?\"),\n \t\t\"750c783e6ab0b503eaa86e310a5db738\",\n \t},\n+\n+\t// Tests from RFC 4231\n+\t{\n+\t\tNewSHA256,\n+\t\t[]byte{\n+\t\t\t0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,\n+\t\t\t0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,\n+\t\t\t0x0b, 0x0b, 0x0b, 0x0b,\n+\t\t},\n+\t\t[]byte(\"Hi There\"),\n+\t\t\"b0344c61d8db38535ca8afceaf0bf12b881dc200c9833da726e9376c2e32cff7\",\n+\t},\n+\t{\n+\t\tNewSHA256,\n+\t\t[]byte(\"Jefe\"),\n+\t\t[]byte(\"what do ya want for nothing?\"),\n+\t\t\"5bdcc146bf60754e6a042426089575c75a003f089d2739839dec58b964ec3843\",\n+\t},\n+\t{\n+\t\tNewSHA256,\n+\t\t[]byte{\n+\t\t\t0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,\n+\t\t\t0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,\n+\t\t\t0xaa, 0xaa, 0xaa, 0xaa,\n+\t\t},\n+\t\t[]byte{\n+\t\t\t0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,\n+\t\t\t0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,\n+\t\t\t0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,\n+\t\t\t0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,\n+\t\t\t0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,\n+\t\t\t0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,\n+\t\t\t0xdd, 0xdd,\n+\t\t},\n+\t\t\"773ea91e36800e46854db8ebd09181a72959098b3ef8c122d9635514ced565fe\",\n+\t},\n+\t{\n+\t\tNewSHA256,\n+\t\t[]byte{\n+\t\t\t0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,\n+\t\t\t0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,\n+\t\t\t0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,\n+\t\t\t0x19,\n+\t\t},\n+\t\t[]byte{\n+\t\t\t0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd,\n+\t\t\t0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd,\n+\t\t\t0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd,\n+\t\t\t0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd,\n+\t\t\t0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd,\n+\t\t\t0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd,\n+\t\t\t0xcd, 0xcd,\n+\t\t},\n+\t\t\"82558a389a443c0ea4cc819899f2083a85f0faa3e578f8077a2e3ff46729665b\",\n+\t},\n+\t{\n+\t\tNewSHA256,\n+\t\t[]byte{\n+\t\t\t0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,\n+\t\t\t0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,\n+\t\t\t0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,\n+\t\t\t0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,\n+\t\t\t0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,\n+\t\t\t0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,\n+\t\t\t0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,\n+\t\t\t0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,\n+\t\t\t0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,\n+\t\t\t0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,\n+\t\t\t0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,\n+\t\t\t0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,\n+\t\t\t0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,\n+\t\t\t0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,\n+\t\t\t0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,\n+\t\t\t0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,\n+\t\t\t0xaa, 0xaa, 0xaa,\n+\t\t},\n+\t\t[]byte(\"Test Using Larger Than Block-Size Key - Hash Key First\"),\n+\t\t\"60e431591ee0b67f0d8a26aacbf5b77f8e0bc6213728c5140546040f0ee37f54\",\n+\t},\n+\t{\n+\t\tNewSHA256,\n+\t\t[]byte{\n+\t\t\t0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,\n+\t\t\t0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,\n+\t\t\t0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,\n+\t\t\t0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,\n+\t\t\t0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,\n+\t\t\t0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,\n+\t\t\t0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,\n+\t\t\t0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,\n+\t\t\t0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,\n+\t\t\t0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,\n+\t\t\t0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,\n+\t\t\t0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,\n+\t\t\t0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,\n+\t\t\t0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,\n+\t\t\t0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,\n+\t\t\t0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,\n+\t\t\t0xaa, 0xaa, 0xaa,\n+\t\t},\n+\t\t[]byte(\"This is a test using a larger than block-size key \" +\n+\t\t\t\"and a larger than block-size data. The key needs to \" +\n+\t\t\t\"be hashed before being used by the HMAC algorithm.\"),\n+\t\t\"9b09ffa71b942fcb27635fbcd5b0e944bfdc63644f0713938a7f51535c3a35e2\",\n+\t},\n }\n \n func TestHMAC(t *testing.T) {"}, {"sha": "97080f6c6d1bec94ba036188a781815f503b7af0", "filename": "libgo/go/crypto/openpgp/armor/armor.go", "status": "added", "additions": 220, "deletions": 0, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Farmor%2Farmor.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Farmor%2Farmor.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Farmor%2Farmor.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -0,0 +1,220 @@\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// This package implements OpenPGP ASCII Armor, see RFC 4880. OpenPGP Armor is\n+// very similar to PEM except that it has an additional CRC checksum.\n+package armor\n+\n+import (\n+\t\"bytes\"\n+\t\"crypto/openpgp/error\"\n+\t\"encoding/base64\"\n+\t\"encoding/line\"\n+\t\"io\"\n+\t\"os\"\n+)\n+\n+// A Block represents an OpenPGP armored structure.\n+//\n+// The encoded form is:\n+//    -----BEGIN Type-----\n+//    Headers\n+//\n+//    base64-encoded Bytes\n+//    '=' base64 encoded checksum\n+//    -----END Type-----\n+// where Headers is a possibly empty sequence of Key: Value lines.\n+//\n+// Since the armored data can be very large, this package presents a streaming\n+// interface.\n+type Block struct {\n+\tType    string            // The type, taken from the preamble (i.e. \"PGP SIGNATURE\").\n+\tHeader  map[string]string // Optional headers.\n+\tBody    io.Reader         // A Reader from which the contents can be read\n+\tlReader lineReader\n+\toReader openpgpReader\n+}\n+\n+var ArmorCorrupt os.Error = error.StructuralError(\"armor invalid\")\n+\n+const crc24Init = 0xb704ce\n+const crc24Poly = 0x1864cfb\n+const crc24Mask = 0xffffff\n+\n+// crc24 calculates the OpenPGP checksum as specified in RFC 4880, section 6.1\n+func crc24(crc uint32, d []byte) uint32 {\n+\tfor _, b := range d {\n+\t\tcrc ^= uint32(b) << 16\n+\t\tfor i := 0; i < 8; i++ {\n+\t\t\tcrc <<= 1\n+\t\t\tif crc&0x1000000 != 0 {\n+\t\t\t\tcrc ^= crc24Poly\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn crc\n+}\n+\n+var armorStart = []byte(\"-----BEGIN \")\n+var armorEnd = []byte(\"-----END \")\n+var armorEndOfLine = []byte(\"-----\")\n+\n+// lineReader wraps a line based reader. It watches for the end of an armor\n+// block and records the expected CRC value.\n+type lineReader struct {\n+\tin  *line.Reader\n+\tbuf []byte\n+\teof bool\n+\tcrc uint32\n+}\n+\n+func (l *lineReader) Read(p []byte) (n int, err os.Error) {\n+\tif l.eof {\n+\t\treturn 0, os.EOF\n+\t}\n+\n+\tif len(l.buf) > 0 {\n+\t\tn = copy(p, l.buf)\n+\t\tl.buf = l.buf[n:]\n+\t\treturn\n+\t}\n+\n+\tline, isPrefix, err := l.in.ReadLine()\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tif isPrefix {\n+\t\treturn 0, ArmorCorrupt\n+\t}\n+\n+\tif len(line) == 5 && line[0] == '=' {\n+\t\t// This is the checksum line\n+\t\tvar expectedBytes [3]byte\n+\t\tvar m int\n+\t\tm, err = base64.StdEncoding.Decode(expectedBytes[0:], line[1:])\n+\t\tif m != 3 || err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tl.crc = uint32(expectedBytes[0])<<16 |\n+\t\t\tuint32(expectedBytes[1])<<8 |\n+\t\t\tuint32(expectedBytes[2])\n+\n+\t\tline, _, err = l.in.ReadLine()\n+\t\tif err != nil && err != os.EOF {\n+\t\t\treturn\n+\t\t}\n+\t\tif !bytes.HasPrefix(line, armorEnd) {\n+\t\t\treturn 0, ArmorCorrupt\n+\t\t}\n+\n+\t\tl.eof = true\n+\t\treturn 0, os.EOF\n+\t}\n+\n+\tif len(line) != 64 {\n+\t\treturn 0, ArmorCorrupt\n+\t}\n+\n+\tn = copy(p, line)\n+\tbytesToSave := len(line) - n\n+\tif bytesToSave > 0 {\n+\t\tif cap(l.buf) < bytesToSave {\n+\t\t\tl.buf = make([]byte, 0, bytesToSave)\n+\t\t}\n+\t\tl.buf = l.buf[0:bytesToSave]\n+\t\tcopy(l.buf, line[n:])\n+\t}\n+\n+\treturn\n+}\n+\n+// openpgpReader passes Read calls to the underlying base64 decoder, but keeps\n+// a running CRC of the resulting data and checks the CRC against the value\n+// found by the lineReader at EOF.\n+type openpgpReader struct {\n+\tlReader    *lineReader\n+\tb64Reader  io.Reader\n+\tcurrentCRC uint32\n+}\n+\n+func (r *openpgpReader) Read(p []byte) (n int, err os.Error) {\n+\tn, err = r.b64Reader.Read(p)\n+\tr.currentCRC = crc24(r.currentCRC, p[:n])\n+\n+\tif err == os.EOF {\n+\t\tif r.lReader.crc != uint32(r.currentCRC&crc24Mask) {\n+\t\t\treturn 0, ArmorCorrupt\n+\t\t}\n+\t}\n+\n+\treturn\n+}\n+\n+// Decode reads a PGP armored block from the given Reader. It will ignore\n+// leading garbage. If it doesn't find a block, it will return nil, os.EOF. The\n+// given Reader is not usable after calling this function: an arbitary amount\n+// of data may have been read past the end of the block.\n+func Decode(in io.Reader) (p *Block, err os.Error) {\n+\tr := line.NewReader(in, 100)\n+\tvar line []byte\n+\tignoreNext := false\n+\n+TryNextBlock:\n+\tp = nil\n+\n+\t// Skip leading garbage\n+\tfor {\n+\t\tignoreThis := ignoreNext\n+\t\tline, ignoreNext, err = r.ReadLine()\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif ignoreNext || ignoreThis {\n+\t\t\tcontinue\n+\t\t}\n+\t\tline = bytes.TrimSpace(line)\n+\t\tif len(line) > len(armorStart)+len(armorEndOfLine) && bytes.HasPrefix(line, armorStart) {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\n+\tp = new(Block)\n+\tp.Type = string(line[len(armorStart) : len(line)-len(armorEndOfLine)])\n+\tp.Header = make(map[string]string)\n+\tnextIsContinuation := false\n+\tvar lastKey string\n+\n+\t// Read headers\n+\tfor {\n+\t\tisContinuation := nextIsContinuation\n+\t\tline, nextIsContinuation, err = r.ReadLine()\n+\t\tif err != nil {\n+\t\t\tp = nil\n+\t\t\treturn\n+\t\t}\n+\t\tif isContinuation {\n+\t\t\tp.Header[lastKey] += string(line)\n+\t\t\tcontinue\n+\t\t}\n+\t\tline = bytes.TrimSpace(line)\n+\t\tif len(line) == 0 {\n+\t\t\tbreak\n+\t\t}\n+\n+\t\ti := bytes.Index(line, []byte(\": \"))\n+\t\tif i == -1 {\n+\t\t\tgoto TryNextBlock\n+\t\t}\n+\t\tlastKey = string(line[:i])\n+\t\tp.Header[lastKey] = string(line[i+2:])\n+\t}\n+\n+\tp.lReader.in = r\n+\tp.oReader.currentCRC = crc24Init\n+\tp.oReader.lReader = &p.lReader\n+\tp.oReader.b64Reader = base64.NewDecoder(base64.StdEncoding, &p.lReader)\n+\tp.Body = &p.oReader\n+\n+\treturn\n+}"}, {"sha": "e4ffd414b6a6467366fa86c7581360f62f13e04c", "filename": "libgo/go/crypto/openpgp/armor/armor_test.go", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Farmor%2Farmor_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Farmor%2Farmor_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Farmor%2Farmor_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -0,0 +1,97 @@\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package armor\n+\n+import (\n+\t\"bytes\"\n+\t\"hash/adler32\"\n+\t\"io/ioutil\"\n+\t\"testing\"\n+)\n+\n+func TestDecodeEncode(t *testing.T) {\n+\tbuf := bytes.NewBuffer([]byte(armorExample1))\n+\tresult, err := Decode(buf)\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t}\n+\texpectedType := \"PGP SIGNATURE\"\n+\tif result.Type != expectedType {\n+\t\tt.Errorf(\"result.Type: got:%s want:%s\", result.Type, expectedType)\n+\t}\n+\tif len(result.Header) != 1 {\n+\t\tt.Errorf(\"len(result.Header): got:%d want:1\", len(result.Header))\n+\t}\n+\tv, ok := result.Header[\"Version\"]\n+\tif !ok || v != \"GnuPG v1.4.10 (GNU/Linux)\" {\n+\t\tt.Errorf(\"result.Header: got:%#v\", result.Header)\n+\t}\n+\n+\tcontents, err := ioutil.ReadAll(result.Body)\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t}\n+\n+\tif adler32.Checksum(contents) != 0x789d7f00 {\n+\t\tt.Errorf(\"contents: got: %x\", contents)\n+\t}\n+\n+\tbuf = bytes.NewBuffer(nil)\n+\tw, err := Encode(buf, result.Type, result.Header)\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t}\n+\t_, err = w.Write(contents)\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t}\n+\tw.Close()\n+\n+\tif !bytes.Equal(buf.Bytes(), []byte(armorExample1)) {\n+\t\tt.Errorf(\"got: %s\\nwant: %s\", string(buf.Bytes()), armorExample1)\n+\t}\n+}\n+\n+func TestLongHeader(t *testing.T) {\n+\tbuf := bytes.NewBuffer([]byte(armorLongLine))\n+\tresult, err := Decode(buf)\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t\treturn\n+\t}\n+\tvalue, ok := result.Header[\"Version\"]\n+\tif !ok {\n+\t\tt.Errorf(\"missing Version header\")\n+\t}\n+\tif value != longValueExpected {\n+\t\tt.Errorf(\"got: %s want: %s\", value, longValueExpected)\n+\t}\n+}\n+\n+const armorExample1 = `-----BEGIN PGP SIGNATURE-----\n+Version: GnuPG v1.4.10 (GNU/Linux)\n+\n+iQEcBAABAgAGBQJMtFESAAoJEKsQXJGvOPsVj40H/1WW6jaMXv4BW+1ueDSMDwM8\n+kx1fLOXbVM5/Kn5LStZNt1jWWnpxdz7eq3uiqeCQjmqUoRde3YbB2EMnnwRbAhpp\n+cacnAvy9ZQ78OTxUdNW1mhX5bS6q1MTEJnl+DcyigD70HG/yNNQD7sOPMdYQw0TA\n+byQBwmLwmTsuZsrYqB68QyLHI+DUugn+kX6Hd2WDB62DKa2suoIUIHQQCd/ofwB3\n+WfCYInXQKKOSxu2YOg2Eb4kLNhSMc1i9uKUWAH+sdgJh7NBgdoE4MaNtBFkHXRvv\n+okWuf3+xA9ksp1npSY/mDvgHijmjvtpRDe6iUeqfCn8N9u9CBg8geANgaG8+QA4=\n+=wfQG\n+-----END PGP SIGNATURE-----`\n+\n+const armorLongLine = `-----BEGIN PGP SIGNATURE-----\n+Version: 0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz\n+\n+iQEcBAABAgAGBQJMtFESAAoJEKsQXJGvOPsVj40H/1WW6jaMXv4BW+1ueDSMDwM8\n+kx1fLOXbVM5/Kn5LStZNt1jWWnpxdz7eq3uiqeCQjmqUoRde3YbB2EMnnwRbAhpp\n+cacnAvy9ZQ78OTxUdNW1mhX5bS6q1MTEJnl+DcyigD70HG/yNNQD7sOPMdYQw0TA\n+byQBwmLwmTsuZsrYqB68QyLHI+DUugn+kX6Hd2WDB62DKa2suoIUIHQQCd/ofwB3\n+WfCYInXQKKOSxu2YOg2Eb4kLNhSMc1i9uKUWAH+sdgJh7NBgdoE4MaNtBFkHXRvv\n+okWuf3+xA9ksp1npSY/mDvgHijmjvtpRDe6iUeqfCn8N9u9CBg8geANgaG8+QA4=\n+=wfQG\n+-----END PGP SIGNATURE-----`\n+\n+const longValueExpected = \"0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz\""}, {"sha": "410e734602fa0862105712b79e787b67f6009265", "filename": "libgo/go/crypto/openpgp/armor/encode.go", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Farmor%2Fencode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Farmor%2Fencode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Farmor%2Fencode.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -0,0 +1,162 @@\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package armor\n+\n+import (\n+\t\"encoding/base64\"\n+\t\"io\"\n+\t\"os\"\n+)\n+\n+var armorHeaderSep = []byte(\": \")\n+var blockEnd = []byte(\"\\n=\")\n+var newline = []byte(\"\\n\")\n+var armorEndOfLineOut = []byte(\"-----\\n\")\n+\n+// writeSlices writes its arguments to the given Writer.\n+func writeSlices(out io.Writer, slices ...[]byte) (err os.Error) {\n+\tfor _, s := range slices {\n+\t\t_, err := out.Write(s)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\treturn\n+}\n+\n+// lineBreaker breaks data across several lines, all of the same byte length\n+// (except possibly the last). Lines are broken with a single '\\n'.\n+type lineBreaker struct {\n+\tlineLength  int\n+\tline        []byte\n+\tused        int\n+\tout         io.Writer\n+\thaveWritten bool\n+}\n+\n+func newLineBreaker(out io.Writer, lineLength int) *lineBreaker {\n+\treturn &lineBreaker{\n+\t\tlineLength: lineLength,\n+\t\tline:       make([]byte, lineLength),\n+\t\tused:       0,\n+\t\tout:        out,\n+\t}\n+}\n+\n+func (l *lineBreaker) Write(b []byte) (n int, err os.Error) {\n+\tn = len(b)\n+\n+\tif n == 0 {\n+\t\treturn\n+\t}\n+\n+\tif l.used == 0 && l.haveWritten {\n+\t\t_, err = l.out.Write([]byte{'\\n'})\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\n+\tif l.used+len(b) < l.lineLength {\n+\t\tl.used += copy(l.line[l.used:], b)\n+\t\treturn\n+\t}\n+\n+\tl.haveWritten = true\n+\t_, err = l.out.Write(l.line[0:l.used])\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\texcess := l.lineLength - l.used\n+\tl.used = 0\n+\n+\t_, err = l.out.Write(b[0:excess])\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\t_, err = l.Write(b[excess:])\n+\treturn\n+}\n+\n+func (l *lineBreaker) Close() (err os.Error) {\n+\tif l.used > 0 {\n+\t\t_, err = l.out.Write(l.line[0:l.used])\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\n+\treturn\n+}\n+\n+// encoding keeps track of a running CRC24 over the data which has been written\n+// to it and outputs a OpenPGP checksum when closed, followed by an armor\n+// trailer.\n+//\n+// It's built into a stack of io.Writers:\n+//    encoding -> base64 encoder -> lineBreaker -> out\n+type encoding struct {\n+\tout       io.Writer\n+\tbreaker   *lineBreaker\n+\tb64       io.WriteCloser\n+\tcrc       uint32\n+\tblockType []byte\n+}\n+\n+func (e *encoding) Write(data []byte) (n int, err os.Error) {\n+\te.crc = crc24(e.crc, data)\n+\treturn e.b64.Write(data)\n+}\n+\n+func (e *encoding) Close() (err os.Error) {\n+\terr = e.b64.Close()\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\tvar checksumBytes [3]byte\n+\tchecksumBytes[0] = byte(e.crc >> 16)\n+\tchecksumBytes[1] = byte(e.crc >> 8)\n+\tchecksumBytes[2] = byte(e.crc)\n+\n+\tvar b64ChecksumBytes [4]byte\n+\tbase64.StdEncoding.Encode(b64ChecksumBytes[:], checksumBytes[:])\n+\n+\treturn writeSlices(e.out, blockEnd, b64ChecksumBytes[:], newline, armorEnd, e.blockType, armorEndOfLine)\n+}\n+\n+// Encode returns a WriteCloser which will encode the data written to it in\n+// OpenPGP armor.\n+func Encode(out io.Writer, blockType string, headers map[string]string) (w io.WriteCloser, err os.Error) {\n+\tbType := []byte(blockType)\n+\terr = writeSlices(out, armorStart, bType, armorEndOfLineOut)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\tfor k, v := range headers {\n+\t\terr = writeSlices(out, []byte(k), armorHeaderSep, []byte(v), newline)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\n+\tif len(headers) > 0 {\n+\t\t_, err := out.Write(newline)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\n+\te := &encoding{\n+\t\tout:       out,\n+\t\tbreaker:   newLineBreaker(out, 64),\n+\t\tcrc:       crc24Init,\n+\t\tblockType: bType,\n+\t}\n+\te.b64 = base64.NewEncoder(base64.StdEncoding, e.breaker)\n+\treturn e, nil\n+}"}, {"sha": "2d80ce3734ee6f71c26615ebc12ce525ff8f6827", "filename": "libgo/go/crypto/openpgp/error/error.go", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Ferror%2Ferror.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Ferror%2Ferror.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Ferror%2Ferror.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// This package contains common error types for the OpenPGP packages.\n+package error\n+\n+// A StructuralError is returned when OpenPGP data is found to be syntactically\n+// invalid.\n+type StructuralError string\n+\n+func (s StructuralError) String() string {\n+\treturn \"OpenPGP data invalid: \" + string(s)\n+}\n+\n+// UnsupportedError indicates that, although the OpenPGP data is valid, it\n+// makes use of currently unimplemented features.\n+type UnsupportedError string\n+\n+func (s UnsupportedError) String() string {\n+\treturn \"OpenPGP feature unsupported: \" + string(s)\n+}\n+\n+// InvalidArgumentError indicates that the caller is in error and passed an\n+// incorrect value.\n+type InvalidArgumentError string\n+\n+func (i InvalidArgumentError) String() string {\n+\treturn \"OpenPGP argument invalid: \" + string(i)\n+}\n+\n+// SignatureError indicates that a syntactically valid signature failed to\n+// validate.\n+type SignatureError string\n+\n+func (b SignatureError) String() string {\n+\treturn \"OpenPGP signature invalid: \" + string(b)\n+}\n+\n+type keyIncorrect int\n+\n+func (ki keyIncorrect) String() string {\n+\treturn \"the given key was incorrect\"\n+}\n+\n+var KeyIncorrectError = keyIncorrect(0)"}, {"sha": "f369d7ed4fc7d71cfc2a3ab134aed35ed5b70261", "filename": "libgo/go/crypto/openpgp/s2k/s2k.go", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fs2k%2Fs2k.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fs2k%2Fs2k.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fs2k%2Fs2k.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -0,0 +1,146 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// This package implements the various OpenPGP string-to-key transforms as\n+// specified in RFC 4800 section 3.7.1.\n+package s2k\n+\n+import (\n+\t\"crypto/md5\"\n+\t\"crypto/openpgp/error\"\n+\t\"crypto/ripemd160\"\n+\t\"crypto/sha1\"\n+\t\"crypto/sha256\"\n+\t\"crypto/sha512\"\n+\t\"hash\"\n+\t\"io\"\n+\t\"os\"\n+)\n+\n+// Simple writes to out the result of computing the Simple S2K function (RFC\n+// 4880, section 3.7.1.1) using the given hash and input passphrase.\n+func Simple(out []byte, h hash.Hash, in []byte) {\n+\tSalted(out, h, in, nil)\n+}\n+\n+var zero [1]byte\n+\n+// Salted writes to out the result of computing the Salted S2K function (RFC\n+// 4880, section 3.7.1.2) using the given hash, input passphrase and salt.\n+func Salted(out []byte, h hash.Hash, in []byte, salt []byte) {\n+\tdone := 0\n+\n+\tfor i := 0; done < len(out); i++ {\n+\t\th.Reset()\n+\t\tfor j := 0; j < i; j++ {\n+\t\t\th.Write(zero[:])\n+\t\t}\n+\t\th.Write(salt)\n+\t\th.Write(in)\n+\t\tn := copy(out[done:], h.Sum())\n+\t\tdone += n\n+\t}\n+}\n+\n+// Iterated writes to out the result of computing the Iterated and Salted S2K\n+// function (RFC 4880, section 3.7.1.3) using the given hash, input passphrase,\n+// salt and iteration count.\n+func Iterated(out []byte, h hash.Hash, in []byte, salt []byte, count int) {\n+\tcombined := make([]byte, len(in)+len(salt))\n+\tcopy(combined, salt)\n+\tcopy(combined[len(salt):], in)\n+\n+\tif count < len(combined) {\n+\t\tcount = len(combined)\n+\t}\n+\n+\tdone := 0\n+\tfor i := 0; done < len(out); i++ {\n+\t\th.Reset()\n+\t\tfor j := 0; j < i; j++ {\n+\t\t\th.Write(zero[:])\n+\t\t}\n+\t\twritten := 0\n+\t\tfor written < count {\n+\t\t\tif written+len(combined) > count {\n+\t\t\t\ttodo := count - written\n+\t\t\t\th.Write(combined[:todo])\n+\t\t\t\twritten = count\n+\t\t\t} else {\n+\t\t\t\th.Write(combined)\n+\t\t\t\twritten += len(combined)\n+\t\t\t}\n+\t\t}\n+\t\tn := copy(out[done:], h.Sum())\n+\t\tdone += n\n+\t}\n+}\n+\n+// Parse reads a binary specification for a string-to-key transformation from r\n+// and returns a function which performs that transform.\n+func Parse(r io.Reader) (f func(out, in []byte), err os.Error) {\n+\tvar buf [9]byte\n+\n+\t_, err = io.ReadFull(r, buf[:2])\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\th := hashFuncFromType(buf[1])\n+\tif h == nil {\n+\t\treturn nil, error.UnsupportedError(\"hash for S2K function\")\n+\t}\n+\n+\tswitch buf[0] {\n+\tcase 1:\n+\t\tf := func(out, in []byte) {\n+\t\t\tSimple(out, h, in)\n+\t\t}\n+\t\treturn f, nil\n+\tcase 2:\n+\t\t_, err := io.ReadFull(r, buf[:8])\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tf := func(out, in []byte) {\n+\t\t\tSalted(out, h, in, buf[:8])\n+\t\t}\n+\t\treturn f, nil\n+\tcase 3:\n+\t\t_, err := io.ReadFull(r, buf[:9])\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tcount := (16 + int(buf[8]&15)) << (uint32(buf[8]>>4) + 6)\n+\t\tf := func(out, in []byte) {\n+\t\t\tIterated(out, h, in, buf[:8], count)\n+\t\t}\n+\t\treturn f, nil\n+\t}\n+\n+\treturn nil, error.UnsupportedError(\"S2K function\")\n+}\n+\n+// hashFuncFromType returns a hash.Hash which corresponds to the given hash\n+// type byte. See RFC 4880, section 9.4.\n+func hashFuncFromType(hashType byte) hash.Hash {\n+\tswitch hashType {\n+\tcase 1:\n+\t\treturn md5.New()\n+\tcase 2:\n+\t\treturn sha1.New()\n+\tcase 3:\n+\t\treturn ripemd160.New()\n+\tcase 8:\n+\t\treturn sha256.New()\n+\tcase 9:\n+\t\treturn sha512.New384()\n+\tcase 10:\n+\t\treturn sha512.New()\n+\tcase 11:\n+\t\treturn sha256.New224()\n+\t}\n+\n+\treturn nil\n+}"}, {"sha": "814b78627f4ddfdaf1c059164df70c5212fe46f6", "filename": "libgo/go/crypto/openpgp/s2k/s2k_test.go", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fs2k%2Fs2k_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fs2k%2Fs2k_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fs2k%2Fs2k_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -0,0 +1,94 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package s2k\n+\n+import (\n+\t\"bytes\"\n+\t\"crypto/sha1\"\n+\t\"encoding/hex\"\n+\t\"testing\"\n+)\n+\n+var saltedTests = []struct {\n+\tin, out string\n+}{\n+\t{\"hello\", \"10295ac1\"},\n+\t{\"world\", \"ac587a5e\"},\n+\t{\"foo\", \"4dda8077\"},\n+\t{\"bar\", \"bd8aac6b9ea9cae04eae6a91c6133b58b5d9a61c14f355516ed9370456\"},\n+\t{\"x\", \"f1d3f289\"},\n+\t{\"xxxxxxxxxxxxxxxxxxxxxxx\", \"e00d7b45\"},\n+}\n+\n+func TestSalted(t *testing.T) {\n+\th := sha1.New()\n+\tsalt := [4]byte{1, 2, 3, 4}\n+\n+\tfor i, test := range saltedTests {\n+\t\texpected, _ := hex.DecodeString(test.out)\n+\t\tout := make([]byte, len(expected))\n+\t\tSalted(out, h, []byte(test.in), salt[:])\n+\t\tif !bytes.Equal(expected, out) {\n+\t\t\tt.Errorf(\"#%d, got: %x want: %x\", i, out, expected)\n+\t\t}\n+\t}\n+}\n+\n+\n+var iteratedTests = []struct {\n+\tin, out string\n+}{\n+\t{\"hello\", \"83126105\"},\n+\t{\"world\", \"6fa317f9\"},\n+\t{\"foo\", \"8fbc35b9\"},\n+\t{\"bar\", \"2af5a99b54f093789fd657f19bd245af7604d0f6ae06f66602a46a08ae\"},\n+\t{\"x\", \"5a684dfe\"},\n+\t{\"xxxxxxxxxxxxxxxxxxxxxxx\", \"18955174\"},\n+}\n+\n+func TestIterated(t *testing.T) {\n+\th := sha1.New()\n+\tsalt := [4]byte{4, 3, 2, 1}\n+\n+\tfor i, test := range iteratedTests {\n+\t\texpected, _ := hex.DecodeString(test.out)\n+\t\tout := make([]byte, len(expected))\n+\t\tIterated(out, h, []byte(test.in), salt[:], 31)\n+\t\tif !bytes.Equal(expected, out) {\n+\t\t\tt.Errorf(\"#%d, got: %x want: %x\", i, out, expected)\n+\t\t}\n+\t}\n+}\n+\n+\n+var parseTests = []struct {\n+\tspec, in, out string\n+}{\n+\t/* Simple with SHA1 */\n+\t{\"0102\", \"hello\", \"aaf4c61d\"},\n+\t/* Salted with SHA1 */\n+\t{\"02020102030405060708\", \"hello\", \"f4f7d67e\"},\n+\t/* Iterated with SHA1 */\n+\t{\"03020102030405060708f1\", \"hello\", \"f2a57b7c\"},\n+}\n+\n+func TestParse(t *testing.T) {\n+\tfor i, test := range parseTests {\n+\t\tspec, _ := hex.DecodeString(test.spec)\n+\t\tbuf := bytes.NewBuffer(spec)\n+\t\tf, err := Parse(buf)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"%d: Parse returned error: %s\", i, err)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\texpected, _ := hex.DecodeString(test.out)\n+\t\tout := make([]byte, len(expected))\n+\t\tf(out, []byte(test.in))\n+\t\tif !bytes.Equal(out, expected) {\n+\t\t\tt.Errorf(\"%d: output got: %x want: %x\", i, out, expected)\n+\t\t}\n+\t}\n+}"}, {"sha": "65fd195f3de47c826eb7aa39dd5eef7783b2cb4f", "filename": "libgo/go/crypto/rc4/rc4.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Frc4%2Frc4.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Frc4%2Frc4.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frc4%2Frc4.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -45,14 +45,14 @@ func NewCipher(key []byte) (*Cipher, os.Error) {\n \treturn &c, nil\n }\n \n-// XORKeyStream will XOR each byte of the given buffer with a byte of the\n-// generated keystream.\n-func (c *Cipher) XORKeyStream(buf []byte) {\n-\tfor i := range buf {\n+// XORKeyStream sets dst to the result of XORing src with the key stream.\n+// Dst and src may be the same slice but otherwise should not overlap.\n+func (c *Cipher) XORKeyStream(dst, src []byte) {\n+\tfor i := range src {\n \t\tc.i += 1\n \t\tc.j += c.s[c.i]\n \t\tc.s[c.i], c.s[c.j] = c.s[c.j], c.s[c.i]\n-\t\tbuf[i] ^= c.s[c.s[c.i]+c.s[c.j]]\n+\t\tdst[i] = src[i] ^ c.s[c.s[c.i]+c.s[c.j]]\n \t}\n }\n "}, {"sha": "6265d9408f40bd1daf5a63b3539f1652f301901b", "filename": "libgo/go/crypto/rc4/rc4_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Frc4%2Frc4_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Frc4%2Frc4_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frc4%2Frc4_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -48,7 +48,7 @@ func TestGolden(t *testing.T) {\n \t\t\treturn\n \t\t}\n \t\tkeystream := make([]byte, len(g.keystream))\n-\t\tc.XORKeyStream(keystream)\n+\t\tc.XORKeyStream(keystream, keystream)\n \t\tfor j, v := range keystream {\n \t\t\tif g.keystream[j] != v {\n \t\t\t\tt.Errorf(\"Failed at golden index %d\", i)"}, {"sha": "7140462509cd8f61b3fd067f517375d143bb1556", "filename": "libgo/go/crypto/rsa/pkcs1v15.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -130,6 +130,9 @@ func nonZeroRandomBytes(s []byte, rand io.Reader) (err os.Error) {\n \t\t\tif err != nil {\n \t\t\t\treturn\n \t\t\t}\n+\t\t\t// In tests, the PRNG may return all zeros so we do\n+\t\t\t// this to break the loop.\n+\t\t\ts[i] ^= 0x42\n \t\t}\n \t}\n "}, {"sha": "ae00ac5586831549343fe18bff967a9767a9f7b5", "filename": "libgo/go/crypto/tls/ca_set.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Ftls%2Fca_set.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Ftls%2Fca_set.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fca_set.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -16,6 +16,7 @@ type CASet struct {\n \tbyName         map[string][]*x509.Certificate\n }\n \n+// NewCASet returns a new, empty CASet.\n func NewCASet() *CASet {\n \treturn &CASet{\n \t\tmake(map[string][]*x509.Certificate),"}, {"sha": "bc7b0d32f95c980bbf6af1d2540060e27ba769e5", "filename": "libgo/go/crypto/tls/cipher_suites.go", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Ftls%2Fcipher_suites.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Ftls%2Fcipher_suites.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fcipher_suites.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -0,0 +1,102 @@\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package tls\n+\n+import (\n+\t\"crypto/aes\"\n+\t\"crypto/cipher\"\n+\t\"crypto/hmac\"\n+\t\"crypto/rc4\"\n+\t\"crypto/x509\"\n+\t\"hash\"\n+\t\"os\"\n+)\n+\n+// a keyAgreement implements the client and server side of a TLS key agreement\n+// protocol by generating and processing key exchange messages.\n+type keyAgreement interface {\n+\t// On the server side, the first two methods are called in order.\n+\n+\t// In the case that the key agreement protocol doesn't use a\n+\t// ServerKeyExchange message, generateServerKeyExchange can return nil,\n+\t// nil.\n+\tgenerateServerKeyExchange(*Config, *clientHelloMsg, *serverHelloMsg) (*serverKeyExchangeMsg, os.Error)\n+\tprocessClientKeyExchange(*Config, *clientKeyExchangeMsg) ([]byte, os.Error)\n+\n+\t// On the client side, the next two methods are called in order.\n+\n+\t// This method may not be called if the server doesn't send a\n+\t// ServerKeyExchange message.\n+\tprocessServerKeyExchange(*Config, *clientHelloMsg, *serverHelloMsg, *x509.Certificate, *serverKeyExchangeMsg) os.Error\n+\tgenerateClientKeyExchange(*Config, *clientHelloMsg, *x509.Certificate) ([]byte, *clientKeyExchangeMsg, os.Error)\n+}\n+\n+// A cipherSuite is a specific combination of key agreement, cipher and MAC\n+// function. All cipher suites currently assume RSA key agreement.\n+type cipherSuite struct {\n+\t// the lengths, in bytes, of the key material needed for each component.\n+\tkeyLen int\n+\tmacLen int\n+\tivLen  int\n+\tka     func() keyAgreement\n+\t// If elliptic is set, a server will only consider this ciphersuite if\n+\t// the ClientHello indicated that the client supports an elliptic curve\n+\t// and point format that we can handle.\n+\telliptic bool\n+\tcipher   func(key, iv []byte, isRead bool) interface{}\n+\tmac      func(macKey []byte) hash.Hash\n+}\n+\n+var cipherSuites = map[uint16]*cipherSuite{\n+\tTLS_RSA_WITH_RC4_128_SHA:           &cipherSuite{16, 20, 0, rsaKA, false, cipherRC4, hmacSHA1},\n+\tTLS_RSA_WITH_AES_128_CBC_SHA:       &cipherSuite{16, 20, 16, rsaKA, false, cipherAES, hmacSHA1},\n+\tTLS_ECDHE_RSA_WITH_RC4_128_SHA:     &cipherSuite{16, 20, 0, ecdheRSAKA, true, cipherRC4, hmacSHA1},\n+\tTLS_ECDHE_RSA_WITH_AES_128_CBC_SHA: &cipherSuite{16, 20, 16, ecdheRSAKA, true, cipherAES, hmacSHA1},\n+}\n+\n+func cipherRC4(key, iv []byte, isRead bool) interface{} {\n+\tcipher, _ := rc4.NewCipher(key)\n+\treturn cipher\n+}\n+\n+func cipherAES(key, iv []byte, isRead bool) interface{} {\n+\tblock, _ := aes.NewCipher(key)\n+\tif isRead {\n+\t\treturn cipher.NewCBCDecrypter(block, iv)\n+\t}\n+\treturn cipher.NewCBCEncrypter(block, iv)\n+}\n+\n+func hmacSHA1(key []byte) hash.Hash {\n+\treturn hmac.NewSHA1(key)\n+}\n+\n+func rsaKA() keyAgreement {\n+\treturn rsaKeyAgreement{}\n+}\n+\n+func ecdheRSAKA() keyAgreement {\n+\treturn new(ecdheRSAKeyAgreement)\n+}\n+\n+// mutualCipherSuite returns a cipherSuite and its id given a list of supported\n+// ciphersuites and the id requested by the peer.\n+func mutualCipherSuite(have []uint16, want uint16) (suite *cipherSuite, id uint16) {\n+\tfor _, id := range have {\n+\t\tif id == want {\n+\t\t\treturn cipherSuites[id], id\n+\t\t}\n+\t}\n+\treturn\n+}\n+\n+// A list of the possible cipher suite ids. Taken from\n+// http://www.iana.org/assignments/tls-parameters/tls-parameters.xml\n+const (\n+\tTLS_RSA_WITH_RC4_128_SHA           uint16 = 0x0005\n+\tTLS_RSA_WITH_AES_128_CBC_SHA       uint16 = 0x002f\n+\tTLS_ECDHE_RSA_WITH_RC4_128_SHA     uint16 = 0xc011\n+\tTLS_ECDHE_RSA_WITH_AES_128_CBC_SHA uint16 = 0xc013\n+)"}, {"sha": "7135f3d0f716853fe89c9364ac5695eb0d956f06", "filename": "libgo/go/crypto/tls/common.go", "status": "modified", "additions": 110, "deletions": 32, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -20,7 +20,7 @@ const (\n \tmaxHandshake    = 65536        // maximum handshake we support (protocol max is 16 MB)\n \n \tminVersion = 0x0301 // minimum supported version - TLS 1.0\n-\tmaxVersion = 0x0302 // maximum supported version - TLS 1.1\n+\tmaxVersion = 0x0301 // maximum supported version - TLS 1.0\n )\n \n // TLS record types.\n@@ -38,6 +38,7 @@ const (\n \ttypeClientHello        uint8 = 1\n \ttypeServerHello        uint8 = 2\n \ttypeCertificate        uint8 = 11\n+\ttypeServerKeyExchange  uint8 = 12\n \ttypeCertificateRequest uint8 = 13\n \ttypeServerHelloDone    uint8 = 14\n \ttypeCertificateVerify  uint8 = 15\n@@ -47,21 +48,32 @@ const (\n \ttypeNextProtocol       uint8 = 67 // Not IANA assigned\n )\n \n-// TLS cipher suites.\n-const (\n-\tTLS_RSA_WITH_RC4_128_SHA uint16 = 5\n-)\n-\n // TLS compression types.\n const (\n \tcompressionNone uint8 = 0\n )\n \n // TLS extension numbers\n var (\n-\textensionServerName    uint16 = 0\n-\textensionStatusRequest uint16 = 5\n-\textensionNextProtoNeg  uint16 = 13172 // not IANA assigned\n+\textensionServerName      uint16 = 0\n+\textensionStatusRequest   uint16 = 5\n+\textensionSupportedCurves uint16 = 10\n+\textensionSupportedPoints uint16 = 11\n+\textensionNextProtoNeg    uint16 = 13172 // not IANA assigned\n+)\n+\n+// TLS Elliptic Curves\n+// http://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-8\n+var (\n+\tcurveP256 uint16 = 23\n+\tcurveP384 uint16 = 24\n+\tcurveP521 uint16 = 25\n+)\n+\n+// TLS Elliptic Curve Point Formats\n+// http://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-9\n+var (\n+\tpointFormatUncompressed uint8 = 0\n )\n \n // TLS CertificateStatusType (RFC 3546)\n@@ -78,6 +90,7 @@ const (\n \t// Rest of these are reserved by the TLS spec\n )\n \n+// ConnectionState records basic TLS details about the connection.\n type ConnectionState struct {\n \tHandshakeComplete  bool\n \tCipherSuite        uint16\n@@ -88,28 +101,77 @@ type ConnectionState struct {\n // has been passed to a TLS function it must not be modified.\n type Config struct {\n \t// Rand provides the source of entropy for nonces and RSA blinding.\n+\t// If Rand is nil, TLS uses the cryptographic random reader in package\n+\t// crypto/rand.\n \tRand io.Reader\n+\n \t// Time returns the current time as the number of seconds since the epoch.\n+\t// If Time is nil, TLS uses the system time.Seconds.\n \tTime func() int64\n-\t// Certificates contains one or more certificate chains.\n+\n+\t// Certificates contains one or more certificate chains\n+\t// to present to the other side of the connection.\n+\t// Server configurations must include at least one certificate.\n \tCertificates []Certificate\n-\tRootCAs      *CASet\n+\n+\t// RootCAs defines the set of root certificate authorities\n+\t// that clients use when verifying server certificates.\n+\t// If RootCAs is nil, TLS uses the host's root CA set.\n+\tRootCAs *CASet\n+\n \t// NextProtos is a list of supported, application level protocols.\n \t// Currently only server-side handling is supported.\n \tNextProtos []string\n+\n \t// ServerName is included in the client's handshake to support virtual\n \t// hosting.\n \tServerName string\n-\t// AuthenticateClient determines if a server will request a certificate\n+\n+\t// AuthenticateClient controls whether a server will request a certificate\n \t// from the client. It does not require that the client send a\n-\t// certificate nor, if it does, that the certificate is anything more\n-\t// than self-signed.\n+\t// certificate nor does it require that the certificate sent be\n+\t// anything more than self-signed.\n \tAuthenticateClient bool\n+\n+\t// CipherSuites is a list of supported cipher suites. If CipherSuites\n+\t// is nil, TLS uses a list of suites supported by the implementation.\n+\tCipherSuites []uint16\n+}\n+\n+func (c *Config) rand() io.Reader {\n+\tr := c.Rand\n+\tif r == nil {\n+\t\treturn rand.Reader\n+\t}\n+\treturn r\n+}\n+\n+func (c *Config) time() int64 {\n+\tt := c.Time\n+\tif t == nil {\n+\t\tt = time.Seconds\n+\t}\n+\treturn t()\n }\n \n+func (c *Config) rootCAs() *CASet {\n+\ts := c.RootCAs\n+\tif s == nil {\n+\t\ts = defaultRoots()\n+\t}\n+\treturn s\n+}\n+\n+func (c *Config) cipherSuites() []uint16 {\n+\ts := c.CipherSuites\n+\tif s == nil {\n+\t\ts = defaultCipherSuites()\n+\t}\n+\treturn s\n+}\n+\n+// A Certificate is a chain of one or more certificates, leaf first.\n type Certificate struct {\n-\t// Certificate contains a chain of one or more certificates. Leaf\n-\t// certificate first.\n \tCertificate [][]byte\n \tPrivateKey  *rsa.PrivateKey\n }\n@@ -126,11 +188,6 @@ type handshakeMessage interface {\n \tunmarshal([]byte) bool\n }\n \n-type encryptor interface {\n-\t// XORKeyStream xors the contents of the slice with bytes from the key stream.\n-\tXORKeyStream(buf []byte)\n-}\n-\n // mutualVersion returns the protocol version to use given the advertised\n // version of the peer.\n func mutualVersion(vers uint16) (uint16, bool) {\n@@ -143,14 +200,10 @@ func mutualVersion(vers uint16) (uint16, bool) {\n \treturn vers, true\n }\n \n-// The defaultConfig is used in place of a nil *Config in the TLS server and client.\n-var varDefaultConfig *Config\n-\n-var once sync.Once\n+var emptyConfig Config\n \n func defaultConfig() *Config {\n-\tonce.Do(initDefaultConfig)\n-\treturn varDefaultConfig\n+\treturn &emptyConfig\n }\n \n // Possible certificate files; stop after finding one.\n@@ -162,7 +215,26 @@ var certFiles = []string{\n \t\"/usr/share/curl/curl-ca-bundle.crt\", // OS X\n }\n \n-func initDefaultConfig() {\n+var once sync.Once\n+\n+func defaultRoots() *CASet {\n+\tonce.Do(initDefaults)\n+\treturn varDefaultRoots\n+}\n+\n+func defaultCipherSuites() []uint16 {\n+\tonce.Do(initDefaults)\n+\treturn varDefaultCipherSuites\n+}\n+\n+func initDefaults() {\n+\tinitDefaultRoots()\n+\tinitDefaultCipherSuites()\n+}\n+\n+var varDefaultRoots *CASet\n+\n+func initDefaultRoots() {\n \troots := NewCASet()\n \tfor _, file := range certFiles {\n \t\tdata, err := ioutil.ReadFile(file)\n@@ -171,10 +243,16 @@ func initDefaultConfig() {\n \t\t\tbreak\n \t\t}\n \t}\n+\tvarDefaultRoots = roots\n+}\n+\n+var varDefaultCipherSuites []uint16\n \n-\tvarDefaultConfig = &Config{\n-\t\tRand:    rand.Reader,\n-\t\tTime:    time.Seconds,\n-\t\tRootCAs: roots,\n+func initDefaultCipherSuites() {\n+\tvarDefaultCipherSuites = make([]uint16, len(cipherSuites))\n+\ti := 0\n+\tfor id, _ := range cipherSuites {\n+\t\tvarDefaultCipherSuites[i] = id\n+\t\ti++\n \t}\n }"}, {"sha": "d203e8d5169afa1055937886d55da3c46c19f82b", "filename": "libgo/go/crypto/tls/conn.go", "status": "modified", "additions": 136, "deletions": 25, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -1,9 +1,14 @@\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n // TLS low level connection and record layer\n \n package tls\n \n import (\n \t\"bytes\"\n+\t\"crypto/cipher\"\n \t\"crypto/subtle\"\n \t\"crypto/x509\"\n \t\"hash\"\n@@ -99,31 +104,31 @@ func (c *Conn) SetWriteTimeout(nsec int64) os.Error {\n // connection, either sending or receiving.\n type halfConn struct {\n \tsync.Mutex\n-\tcrypt encryptor // encryption state\n-\tmac   hash.Hash // MAC algorithm\n-\tseq   [8]byte   // 64-bit sequence number\n-\tbfree *block    // list of free blocks\n+\tcipher interface{} // cipher algorithm\n+\tmac    hash.Hash   // MAC algorithm\n+\tseq    [8]byte     // 64-bit sequence number\n+\tbfree  *block      // list of free blocks\n \n-\tnextCrypt encryptor // next encryption state\n-\tnextMac   hash.Hash // next MAC algorithm\n+\tnextCipher interface{} // next encryption state\n+\tnextMac    hash.Hash   // next MAC algorithm\n }\n \n // prepareCipherSpec sets the encryption and MAC states\n // that a subsequent changeCipherSpec will use.\n-func (hc *halfConn) prepareCipherSpec(crypt encryptor, mac hash.Hash) {\n-\thc.nextCrypt = crypt\n+func (hc *halfConn) prepareCipherSpec(cipher interface{}, mac hash.Hash) {\n+\thc.nextCipher = cipher\n \thc.nextMac = mac\n }\n \n // changeCipherSpec changes the encryption and MAC states\n // to the ones previously passed to prepareCipherSpec.\n func (hc *halfConn) changeCipherSpec() os.Error {\n-\tif hc.nextCrypt == nil {\n+\tif hc.nextCipher == nil {\n \t\treturn alertInternalError\n \t}\n-\thc.crypt = hc.nextCrypt\n+\thc.cipher = hc.nextCipher\n \thc.mac = hc.nextMac\n-\thc.nextCrypt = nil\n+\thc.nextCipher = nil\n \thc.nextMac = nil\n \treturn nil\n }\n@@ -150,42 +155,134 @@ func (hc *halfConn) resetSeq() {\n \t}\n }\n \n+// removePadding returns an unpadded slice, in constant time, which is a prefix\n+// of the input. It also returns a byte which is equal to 255 if the padding\n+// was valid and 0 otherwise. See RFC 2246, section 6.2.3.2\n+func removePadding(payload []byte) ([]byte, byte) {\n+\tif len(payload) < 1 {\n+\t\treturn payload, 0\n+\t}\n+\n+\tpaddingLen := payload[len(payload)-1]\n+\tt := uint(len(payload)-1) - uint(paddingLen)\n+\t// if len(payload) >= (paddingLen - 1) then the MSB of t is zero\n+\tgood := byte(int32(^t) >> 31)\n+\n+\ttoCheck := 255 // the maximum possible padding length\n+\t// The length of the padded data is public, so we can use an if here\n+\tif toCheck+1 > len(payload) {\n+\t\ttoCheck = len(payload) - 1\n+\t}\n+\n+\tfor i := 0; i < toCheck; i++ {\n+\t\tt := uint(paddingLen) - uint(i)\n+\t\t// if i <= paddingLen then the MSB of t is zero\n+\t\tmask := byte(int32(^t) >> 31)\n+\t\tb := payload[len(payload)-1-i]\n+\t\tgood &^= mask&paddingLen ^ mask&b\n+\t}\n+\n+\t// We AND together the bits of good and replicate the result across\n+\t// all the bits.\n+\tgood &= good << 4\n+\tgood &= good << 2\n+\tgood &= good << 1\n+\tgood = uint8(int8(good) >> 7)\n+\n+\ttoRemove := good&paddingLen + 1\n+\treturn payload[:len(payload)-int(toRemove)], good\n+}\n+\n+func roundUp(a, b int) int {\n+\treturn a + (b-a%b)%b\n+}\n+\n // decrypt checks and strips the mac and decrypts the data in b.\n func (hc *halfConn) decrypt(b *block) (bool, alert) {\n \t// pull out payload\n \tpayload := b.data[recordHeaderLen:]\n \n+\tmacSize := 0\n+\tif hc.mac != nil {\n+\t\tmacSize = hc.mac.Size()\n+\t}\n+\n+\tpaddingGood := byte(255)\n+\n \t// decrypt\n-\tif hc.crypt != nil {\n-\t\thc.crypt.XORKeyStream(payload)\n+\tif hc.cipher != nil {\n+\t\tswitch c := hc.cipher.(type) {\n+\t\tcase cipher.Stream:\n+\t\t\tc.XORKeyStream(payload, payload)\n+\t\tcase cipher.BlockMode:\n+\t\t\tblockSize := c.BlockSize()\n+\n+\t\t\tif len(payload)%blockSize != 0 || len(payload) < roundUp(macSize+1, blockSize) {\n+\t\t\t\treturn false, alertBadRecordMAC\n+\t\t\t}\n+\n+\t\t\tc.CryptBlocks(payload, payload)\n+\t\t\tpayload, paddingGood = removePadding(payload)\n+\t\t\tb.resize(recordHeaderLen + len(payload))\n+\n+\t\t\t// note that we still have a timing side-channel in the\n+\t\t\t// MAC check, below. An attacker can align the record\n+\t\t\t// so that a correct padding will cause one less hash\n+\t\t\t// block to be calculated. Then they can iteratively\n+\t\t\t// decrypt a record by breaking each byte. See\n+\t\t\t// \"Password Interception in a SSL/TLS Channel\", Brice\n+\t\t\t// Canvel et al.\n+\t\t\t//\n+\t\t\t// However, our behaviour matches OpenSSL, so we leak\n+\t\t\t// only as much as they do.\n+\t\tdefault:\n+\t\t\tpanic(\"unknown cipher type\")\n+\t\t}\n \t}\n \n \t// check, strip mac\n \tif hc.mac != nil {\n-\t\tif len(payload) < hc.mac.Size() {\n+\t\tif len(payload) < macSize {\n \t\t\treturn false, alertBadRecordMAC\n \t\t}\n \n \t\t// strip mac off payload, b.data\n-\t\tn := len(payload) - hc.mac.Size()\n+\t\tn := len(payload) - macSize\n \t\tb.data[3] = byte(n >> 8)\n \t\tb.data[4] = byte(n)\n-\t\tb.data = b.data[0 : recordHeaderLen+n]\n+\t\tb.resize(recordHeaderLen + n)\n \t\tremoteMAC := payload[n:]\n \n \t\thc.mac.Reset()\n \t\thc.mac.Write(hc.seq[0:])\n \t\thc.incSeq()\n \t\thc.mac.Write(b.data)\n \n-\t\tif subtle.ConstantTimeCompare(hc.mac.Sum(), remoteMAC) != 1 {\n+\t\tif subtle.ConstantTimeCompare(hc.mac.Sum(), remoteMAC) != 1 || paddingGood != 255 {\n \t\t\treturn false, alertBadRecordMAC\n \t\t}\n \t}\n \n \treturn true, 0\n }\n \n+// padToBlockSize calculates the needed padding block, if any, for a payload.\n+// On exit, prefix aliases payload and extends to the end of the last full\n+// block of payload. finalBlock is a fresh slice which contains the contents of\n+// any suffix of payload as well as the needed padding to make finalBlock a\n+// full block.\n+func padToBlockSize(payload []byte, blockSize int) (prefix, finalBlock []byte) {\n+\toverrun := len(payload) % blockSize\n+\tpaddingLen := blockSize - overrun\n+\tprefix = payload[:len(payload)-overrun]\n+\tfinalBlock = make([]byte, blockSize)\n+\tcopy(finalBlock, payload[len(payload)-overrun:])\n+\tfor i := overrun; i < blockSize; i++ {\n+\t\tfinalBlock[i] = byte(paddingLen - 1)\n+\t}\n+\treturn\n+}\n+\n // encrypt encrypts and macs the data in b.\n func (hc *halfConn) encrypt(b *block) (bool, alert) {\n \t// mac\n@@ -198,18 +295,30 @@ func (hc *halfConn) encrypt(b *block) (bool, alert) {\n \t\tn := len(b.data)\n \t\tb.resize(n + len(mac))\n \t\tcopy(b.data[n:], mac)\n-\n-\t\t// update length to include mac\n-\t\tn = len(b.data) - recordHeaderLen\n-\t\tb.data[3] = byte(n >> 8)\n-\t\tb.data[4] = byte(n)\n \t}\n \n+\tpayload := b.data[recordHeaderLen:]\n+\n \t// encrypt\n-\tif hc.crypt != nil {\n-\t\thc.crypt.XORKeyStream(b.data[recordHeaderLen:])\n+\tif hc.cipher != nil {\n+\t\tswitch c := hc.cipher.(type) {\n+\t\tcase cipher.Stream:\n+\t\t\tc.XORKeyStream(payload, payload)\n+\t\tcase cipher.BlockMode:\n+\t\t\tprefix, finalBlock := padToBlockSize(payload, c.BlockSize())\n+\t\t\tb.resize(recordHeaderLen + len(prefix) + len(finalBlock))\n+\t\t\tc.CryptBlocks(b.data[recordHeaderLen:], prefix)\n+\t\t\tc.CryptBlocks(b.data[recordHeaderLen+len(prefix):], finalBlock)\n+\t\tdefault:\n+\t\t\tpanic(\"unknown cipher type\")\n+\t\t}\n \t}\n \n+\t// update length to include MAC and any block padding needed.\n+\tn := len(b.data) - recordHeaderLen\n+\tb.data[3] = byte(n >> 8)\n+\tb.data[4] = byte(n)\n+\n \treturn true, 0\n }\n \n@@ -542,6 +651,8 @@ func (c *Conn) readHandshake() (interface{}, os.Error) {\n \t\tm = new(certificateRequestMsg)\n \tcase typeCertificateStatus:\n \t\tm = new(certificateStatusMsg)\n+\tcase typeServerKeyExchange:\n+\t\tm = new(serverKeyExchangeMsg)\n \tcase typeServerHelloDone:\n \t\tm = new(serverHelloDoneMsg)\n \tcase typeClientKeyExchange:\n@@ -560,7 +671,7 @@ func (c *Conn) readHandshake() (interface{}, os.Error) {\n \t// The handshake message unmarshallers\n \t// expect to be able to keep references to data,\n \t// so pass in a fresh copy that won't be overwritten.\n-\tdata = bytes.Add(nil, data)\n+\tdata = append([]byte(nil), data...)\n \n \tif !m.unmarshal(data) {\n \t\tc.sendAlert(alertUnexpectedMessage)"}, {"sha": "f44a50bedde5586109706f498e434323da21918d", "filename": "libgo/go/crypto/tls/conn_test.go", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package tls\n+\n+import (\n+\t\"testing\"\n+)\n+\n+func TestRoundUp(t *testing.T) {\n+\tif roundUp(0, 16) != 0 ||\n+\t\troundUp(1, 16) != 16 ||\n+\t\troundUp(15, 16) != 16 ||\n+\t\troundUp(16, 16) != 16 ||\n+\t\troundUp(17, 16) != 32 {\n+\t\tt.Error(\"roundUp broken\")\n+\t}\n+}\n+\n+var paddingTests = []struct {\n+\tin          []byte\n+\tgood        bool\n+\texpectedLen int\n+}{\n+\t{[]byte{1, 2, 3, 4, 0}, true, 4},\n+\t{[]byte{1, 2, 3, 4, 0, 1}, false, 0},\n+\t{[]byte{1, 2, 3, 4, 99, 99}, false, 0},\n+\t{[]byte{1, 2, 3, 4, 1, 1}, true, 4},\n+\t{[]byte{1, 2, 3, 2, 2, 2}, true, 3},\n+\t{[]byte{1, 2, 3, 3, 3, 3}, true, 2},\n+\t{[]byte{1, 2, 3, 4, 3, 3}, false, 0},\n+\t{[]byte{1, 4, 4, 4, 4, 4}, true, 1},\n+\t{[]byte{5, 5, 5, 5, 5, 5}, true, 0},\n+\t{[]byte{6, 6, 6, 6, 6, 6}, false, 0},\n+}\n+\n+func TestRemovePadding(t *testing.T) {\n+\tfor i, test := range paddingTests {\n+\t\tpayload, good := removePadding(test.in)\n+\t\texpectedGood := byte(255)\n+\t\tif !test.good {\n+\t\t\texpectedGood = 0\n+\t\t}\n+\t\tif good != expectedGood {\n+\t\t\tt.Errorf(\"#%d: wrong validity, want:%d got:%d\", i, expectedGood, good)\n+\t\t}\n+\t\tif good == 255 && len(payload) != test.expectedLen {\n+\t\t\tt.Errorf(\"#%d: got %d, want %d\", i, len(payload), test.expectedLen)\n+\t\t}\n+\t}\n+}"}, {"sha": "3e0c6393893c0518fe86c35181093ec39aaec8f4", "filename": "libgo/go/crypto/tls/generate_cert.go", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Ftls%2Fgenerate_cert.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Ftls%2Fgenerate_cert.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fgenerate_cert.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -9,6 +9,7 @@ package main\n \n import (\n \t\"crypto/rsa\"\n+\t\"crypto/rand\"\n \t\"crypto/x509\"\n \t\"encoding/pem\"\n \t\"flag\"\n@@ -22,13 +23,7 @@ var hostName *string = flag.String(\"host\", \"127.0.0.1\", \"Hostname to generate a\n func main() {\n \tflag.Parse()\n \n-\turandom, err := os.Open(\"/dev/urandom\", os.O_RDONLY, 0)\n-\tif err != nil {\n-\t\tlog.Exitf(\"failed to open /dev/urandom: %s\", err)\n-\t\treturn\n-\t}\n-\n-\tpriv, err := rsa.GenerateKey(urandom, 1024)\n+\tpriv, err := rsa.GenerateKey(rand.Reader, 1024)\n \tif err != nil {\n \t\tlog.Exitf(\"failed to generate private key: %s\", err)\n \t\treturn\n@@ -40,7 +35,7 @@ func main() {\n \t\tSerialNumber: []byte{0},\n \t\tSubject: x509.Name{\n \t\t\tCommonName:   *hostName,\n-\t\t\tOrganization: \"Acme Co\",\n+\t\t\tOrganization: []string{\"Acme Co\"},\n \t\t},\n \t\tNotBefore: time.SecondsToUTC(now - 300),\n \t\tNotAfter:  time.SecondsToUTC(now + 60*60*24*365), // valid for 1 year.\n@@ -49,7 +44,7 @@ func main() {\n \t\tKeyUsage:     x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,\n \t}\n \n-\tderBytes, err := x509.CreateCertificate(urandom, &template, &template, &priv.PublicKey, priv)\n+\tderBytes, err := x509.CreateCertificate(rand.Reader, &template, &template, &priv.PublicKey, priv)\n \tif err != nil {\n \t\tlog.Exitf(\"Failed to create certificate: %s\", err)\n \t\treturn"}, {"sha": "1ca33f59dd080cdfccc2c5351e922dd6523b3511", "filename": "libgo/go/crypto/tls/handshake_client.go", "status": "modified", "additions": 45, "deletions": 32, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -5,8 +5,6 @@\n package tls\n \n import (\n-\t\"crypto/hmac\"\n-\t\"crypto/rc4\"\n \t\"crypto/rsa\"\n \t\"crypto/subtle\"\n \t\"crypto/x509\"\n@@ -23,19 +21,21 @@ func (c *Conn) clientHandshake() os.Error {\n \n \thello := &clientHelloMsg{\n \t\tvers:               maxVersion,\n-\t\tcipherSuites:       []uint16{TLS_RSA_WITH_RC4_128_SHA},\n+\t\tcipherSuites:       c.config.cipherSuites(),\n \t\tcompressionMethods: []uint8{compressionNone},\n \t\trandom:             make([]byte, 32),\n \t\tocspStapling:       true,\n \t\tserverName:         c.config.ServerName,\n+\t\tsupportedCurves:    []uint16{curveP256, curveP384, curveP521},\n+\t\tsupportedPoints:    []uint8{pointFormatUncompressed},\n \t}\n \n-\tt := uint32(c.config.Time())\n+\tt := uint32(c.config.time())\n \thello.random[0] = byte(t >> 24)\n \thello.random[1] = byte(t >> 16)\n \thello.random[2] = byte(t >> 8)\n \thello.random[3] = byte(t)\n-\t_, err := io.ReadFull(c.config.Rand, hello.random[4:])\n+\t_, err := io.ReadFull(c.config.rand(), hello.random[4:])\n \tif err != nil {\n \t\tc.sendAlert(alertInternalError)\n \t\treturn os.ErrorString(\"short read from Rand\")\n@@ -61,11 +61,15 @@ func (c *Conn) clientHandshake() os.Error {\n \tc.vers = vers\n \tc.haveVers = true\n \n-\tif serverHello.cipherSuite != TLS_RSA_WITH_RC4_128_SHA ||\n-\t\tserverHello.compressionMethod != compressionNone {\n+\tif serverHello.compressionMethod != compressionNone {\n \t\treturn c.sendAlert(alertUnexpectedMessage)\n \t}\n \n+\tsuite, suiteId := mutualCipherSuite(c.config.cipherSuites(), serverHello.cipherSuite)\n+\tif suite == nil {\n+\t\treturn c.sendAlert(alertHandshakeFailure)\n+\t}\n+\n \tmsg, err = c.readHandshake()\n \tif err != nil {\n \t\treturn err\n@@ -128,8 +132,7 @@ func (c *Conn) clientHandshake() os.Error {\n \t\tcur = parent\n \t}\n \n-\tpub, ok := certs[0].PublicKey.(*rsa.PublicKey)\n-\tif !ok {\n+\tif _, ok := certs[0].PublicKey.(*rsa.PublicKey); !ok {\n \t\treturn c.sendAlert(alertUnsupportedCertificate)\n \t}\n \n@@ -156,6 +159,23 @@ func (c *Conn) clientHandshake() os.Error {\n \t\treturn err\n \t}\n \n+\tkeyAgreement := suite.ka()\n+\n+\tskx, ok := msg.(*serverKeyExchangeMsg)\n+\tif ok {\n+\t\tfinishedHash.Write(skx.marshal())\n+\t\terr = keyAgreement.processServerKeyExchange(c.config, hello, serverHello, certs[0], skx)\n+\t\tif err != nil {\n+\t\t\tc.sendAlert(alertUnexpectedMessage)\n+\t\t\treturn err\n+\t\t}\n+\n+\t\tmsg, err = c.readHandshake()\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\n \ttransmitCert := false\n \tcertReq, ok := msg.(*certificateRequestMsg)\n \tif ok {\n@@ -213,29 +233,22 @@ func (c *Conn) clientHandshake() os.Error {\n \t\tc.writeRecord(recordTypeHandshake, certMsg.marshal())\n \t}\n \n-\tckx := new(clientKeyExchangeMsg)\n-\tpreMasterSecret := make([]byte, 48)\n-\tpreMasterSecret[0] = byte(hello.vers >> 8)\n-\tpreMasterSecret[1] = byte(hello.vers)\n-\t_, err = io.ReadFull(c.config.Rand, preMasterSecret[2:])\n+\tpreMasterSecret, ckx, err := keyAgreement.generateClientKeyExchange(c.config, hello, certs[0])\n \tif err != nil {\n-\t\treturn c.sendAlert(alertInternalError)\n+\t\tc.sendAlert(alertInternalError)\n+\t\treturn err\n \t}\n-\n-\tckx.ciphertext, err = rsa.EncryptPKCS1v15(c.config.Rand, pub, preMasterSecret)\n-\tif err != nil {\n-\t\treturn c.sendAlert(alertInternalError)\n+\tif ckx != nil {\n+\t\tfinishedHash.Write(ckx.marshal())\n+\t\tc.writeRecord(recordTypeHandshake, ckx.marshal())\n \t}\n \n-\tfinishedHash.Write(ckx.marshal())\n-\tc.writeRecord(recordTypeHandshake, ckx.marshal())\n-\n \tif cert != nil {\n \t\tcertVerify := new(certificateVerifyMsg)\n \t\tvar digest [36]byte\n \t\tcopy(digest[0:16], finishedHash.serverMD5.Sum())\n \t\tcopy(digest[16:36], finishedHash.serverSHA1.Sum())\n-\t\tsigned, err := rsa.SignPKCS1v15(c.config.Rand, c.config.Certificates[0].PrivateKey, rsa.HashMD5SHA1, digest[0:])\n+\t\tsigned, err := rsa.SignPKCS1v15(c.config.rand(), c.config.Certificates[0].PrivateKey, rsa.HashMD5SHA1, digest[0:])\n \t\tif err != nil {\n \t\t\treturn c.sendAlert(alertInternalError)\n \t\t}\n@@ -245,22 +258,22 @@ func (c *Conn) clientHandshake() os.Error {\n \t\tc.writeRecord(recordTypeHandshake, certVerify.marshal())\n \t}\n \n-\tsuite := cipherSuites[0]\n-\tmasterSecret, clientMAC, serverMAC, clientKey, serverKey :=\n-\t\tkeysFromPreMasterSecret11(preMasterSecret, hello.random, serverHello.random, suite.hashLength, suite.cipherKeyLength)\n-\n-\tcipher, _ := rc4.NewCipher(clientKey)\n+\tmasterSecret, clientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV :=\n+\t\tkeysFromPreMasterSecret10(preMasterSecret, hello.random, serverHello.random, suite.macLen, suite.keyLen, suite.ivLen)\n \n-\tc.out.prepareCipherSpec(cipher, hmac.NewSHA1(clientMAC))\n+\tclientCipher := suite.cipher(clientKey, clientIV, false /* not for reading */ )\n+\tclientHash := suite.mac(clientMAC)\n+\tc.out.prepareCipherSpec(clientCipher, clientHash)\n \tc.writeRecord(recordTypeChangeCipherSpec, []byte{1})\n \n \tfinished := new(finishedMsg)\n \tfinished.verifyData = finishedHash.clientSum(masterSecret)\n \tfinishedHash.Write(finished.marshal())\n \tc.writeRecord(recordTypeHandshake, finished.marshal())\n \n-\tcipher2, _ := rc4.NewCipher(serverKey)\n-\tc.in.prepareCipherSpec(cipher2, hmac.NewSHA1(serverMAC))\n+\tserverCipher := suite.cipher(serverKey, serverIV, true /* for reading */ )\n+\tserverHash := suite.mac(serverMAC)\n+\tc.in.prepareCipherSpec(serverCipher, serverHash)\n \tc.readRecord(recordTypeChangeCipherSpec)\n \tif c.err != nil {\n \t\treturn c.err\n@@ -282,6 +295,6 @@ func (c *Conn) clientHandshake() os.Error {\n \t}\n \n \tc.handshakeComplete = true\n-\tc.cipherSuite = TLS_RSA_WITH_RC4_128_SHA\n+\tc.cipherSuite = suiteId\n \treturn nil\n }"}, {"sha": "e5c9684b9775ee57a6b9e5c7753166d1b793ebff", "filename": "libgo/go/crypto/tls/handshake_client_test.go", "status": "added", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -0,0 +1,211 @@\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package tls\n+\n+import (\n+\t\"bytes\"\n+\t\"flag\"\n+\t\"io\"\n+\t\"net\"\n+\t\"testing\"\n+)\n+\n+func testClientScript(t *testing.T, name string, clientScript [][]byte, config *Config) {\n+\tc, s := net.Pipe()\n+\tcli := Client(c, config)\n+\tgo func() {\n+\t\tcli.Write([]byte(\"hello\\n\"))\n+\t\tcli.Close()\n+\t}()\n+\n+\tdefer c.Close()\n+\tfor i, b := range clientScript {\n+\t\tif i%2 == 1 {\n+\t\t\ts.Write(b)\n+\t\t\tcontinue\n+\t\t}\n+\t\tbb := make([]byte, len(b))\n+\t\t_, err := io.ReadFull(s, bb)\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"%s #%d: %s\", name, i, err)\n+\t\t}\n+\t\tif !bytes.Equal(b, bb) {\n+\t\t\tt.Fatalf(\"%s #%d: mismatch on read: got:%x want:%x\", name, i, bb, b)\n+\t\t}\n+\t}\n+}\n+\n+func TestHandshakeClientRC4(t *testing.T) {\n+\ttestClientScript(t, \"RC4\", rc4ClientScript, testConfig)\n+}\n+\n+var connect = flag.Bool(\"connect\", false, \"connect to a TLS server on :10443\")\n+\n+func TestRunClient(t *testing.T) {\n+\tif !*connect {\n+\t\treturn\n+\t}\n+\n+\ttestConfig.CipherSuites = []uint16{TLS_ECDHE_RSA_WITH_RC4_128_SHA}\n+\n+\tconn, err := Dial(\"tcp\", \"\", \"127.0.0.1:10443\", testConfig)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tconn.Write([]byte(\"hello\\n\"))\n+\tconn.Close()\n+}\n+\n+// Script of interaction with gnutls implementation.\n+// The values for this test are obtained by building and running in client mode:\n+//   % gotest -match \"TestRunClient\" -connect\n+// and then:\n+//   % gnutls-serv -p 10443 --debug 100 --x509keyfile key.pem --x509certfile cert.pem -a > /tmp/log 2>&1\n+//   % python parse-gnutls-cli-debug-log.py < /tmp/log\n+//\n+// Where key.pem is:\n+// -----BEGIN RSA PRIVATE KEY-----\n+// MIIBPAIBAAJBAJ+zw4Qnlf8SMVIPFe9GEcStgOY2Ww/dgNdhjeD8ckUJNP5VZkVD\n+// TGiXav6ooKXfX3j/7tdkuD8Ey2//Kv7+ue0CAwEAAQJAN6W31vDEP2DjdqhzCDDu\n+// OA4NACqoiFqyblo7yc2tM4h4xMbC3Yx5UKMN9ZkCtX0gzrz6DyF47bdKcWBzNWCj\n+// gQIhANEoojVt7hq+SQ6MCN6FTAysGgQf56Q3TYoJMoWvdiXVAiEAw3e3rc+VJpOz\n+// rHuDo6bgpjUAAXM+v3fcpsfZSNO6V7kCIQCtbVjanpUwvZkMI9by02oUk9taki3b\n+// PzPfAfNPYAbCJQIhAJXNQDWyqwn/lGmR11cqY2y9nZ1+5w3yHGatLrcDnQHxAiEA\n+// vnlEGo8K85u+KwIOimM48ZG8oTk7iFdkqLJR1utT3aU=\n+// -----END RSA PRIVATE KEY-----\n+//\n+// and cert.pem is:\n+// -----BEGIN CERTIFICATE-----\n+// MIIBoDCCAUoCAQAwDQYJKoZIhvcNAQEEBQAwYzELMAkGA1UEBhMCQVUxEzARBgNV\n+// BAgTClF1ZWVuc2xhbmQxGjAYBgNVBAoTEUNyeXB0U29mdCBQdHkgTHRkMSMwIQYD\n+// VQQDExpTZXJ2ZXIgdGVzdCBjZXJ0ICg1MTIgYml0KTAeFw05NzA5MDkwMzQxMjZa\n+// Fw05NzEwMDkwMzQxMjZaMF4xCzAJBgNVBAYTAkFVMRMwEQYDVQQIEwpTb21lLVN0\n+// YXRlMSEwHwYDVQQKExhJbnRlcm5ldCBXaWRnaXRzIFB0eSBMdGQxFzAVBgNVBAMT\n+// DkVyaWMgdGhlIFlvdW5nMFEwCQYFKw4DAgwFAANEAAJBALVEqPODnpI4rShlY8S7\n+// tB713JNvabvn6Gned7zylwLLiXQAo/PAT6mfdWPTyCX9RlId/Aroh1ou893BA32Q\n+// sggwDQYJKoZIhvcNAQEEBQADQQCU5SSgapJSdRXJoX+CpCvFy+JVh9HpSjCpSNKO\n+// 19raHv98hKAUJuP9HyM+SUsffO6mAIgitUaqW8/wDMePhEC3\n+// -----END CERTIFICATE-----\n+var rc4ClientScript = [][]byte{\n+\t{\n+\t\t0x16, 0x03, 0x01, 0x00, 0x4a, 0x01, 0x00, 0x00,\n+\t\t0x46, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x05,\n+\t\t0x01, 0x00, 0x00, 0x1b, 0x00, 0x05, 0x00, 0x05,\n+\t\t0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00,\n+\t\t0x08, 0x00, 0x06, 0x00, 0x17, 0x00, 0x18, 0x00,\n+\t\t0x19, 0x00, 0x0b, 0x00, 0x02, 0x01, 0x00,\n+\t},\n+\n+\t{\n+\t\t0x16, 0x03, 0x01, 0x00, 0x4a, 0x02, 0x00, 0x00,\n+\t\t0x46, 0x03, 0x01, 0x4d, 0x0a, 0x56, 0x16, 0xb5,\n+\t\t0x91, 0xd1, 0xcb, 0x80, 0x4d, 0xc7, 0x46, 0xf3,\n+\t\t0x37, 0x0c, 0xef, 0xea, 0x64, 0x11, 0x14, 0x56,\n+\t\t0x97, 0x9b, 0xc5, 0x67, 0x08, 0xb7, 0x13, 0xea,\n+\t\t0xf8, 0xc9, 0xb3, 0x20, 0xe2, 0xfc, 0x41, 0xf6,\n+\t\t0x96, 0x90, 0x9d, 0x43, 0x9b, 0xe9, 0x6e, 0xf8,\n+\t\t0x41, 0x16, 0xcc, 0xf3, 0xc7, 0xde, 0xda, 0x5a,\n+\t\t0xa1, 0x33, 0x69, 0xe2, 0xde, 0x5b, 0xaf, 0x2a,\n+\t\t0x92, 0xe7, 0xd4, 0xa0, 0x00, 0x05, 0x00, 0x16,\n+\t\t0x03, 0x01, 0x01, 0xf7, 0x0b, 0x00, 0x01, 0xf3,\n+\t\t0x00, 0x01, 0xf0, 0x00, 0x01, 0xed, 0x30, 0x82,\n+\t\t0x01, 0xe9, 0x30, 0x82, 0x01, 0x52, 0x02, 0x01,\n+\t\t0x06, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48,\n+\t\t0x86, 0xf7, 0x0d, 0x01, 0x01, 0x04, 0x05, 0x00,\n+\t\t0x30, 0x5b, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03,\n+\t\t0x55, 0x04, 0x06, 0x13, 0x02, 0x41, 0x55, 0x31,\n+\t\t0x13, 0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x08,\n+\t\t0x13, 0x0a, 0x51, 0x75, 0x65, 0x65, 0x6e, 0x73,\n+\t\t0x6c, 0x61, 0x6e, 0x64, 0x31, 0x1a, 0x30, 0x18,\n+\t\t0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x11, 0x43,\n+\t\t0x72, 0x79, 0x70, 0x74, 0x53, 0x6f, 0x66, 0x74,\n+\t\t0x20, 0x50, 0x74, 0x79, 0x20, 0x4c, 0x74, 0x64,\n+\t\t0x31, 0x1b, 0x30, 0x19, 0x06, 0x03, 0x55, 0x04,\n+\t\t0x03, 0x13, 0x12, 0x54, 0x65, 0x73, 0x74, 0x20,\n+\t\t0x43, 0x41, 0x20, 0x28, 0x31, 0x30, 0x32, 0x34,\n+\t\t0x20, 0x62, 0x69, 0x74, 0x29, 0x30, 0x1e, 0x17,\n+\t\t0x0d, 0x30, 0x30, 0x31, 0x30, 0x31, 0x36, 0x32,\n+\t\t0x32, 0x33, 0x31, 0x30, 0x33, 0x5a, 0x17, 0x0d,\n+\t\t0x30, 0x33, 0x30, 0x31, 0x31, 0x34, 0x32, 0x32,\n+\t\t0x33, 0x31, 0x30, 0x33, 0x5a, 0x30, 0x63, 0x31,\n+\t\t0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06,\n+\t\t0x13, 0x02, 0x41, 0x55, 0x31, 0x13, 0x30, 0x11,\n+\t\t0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x0a, 0x51,\n+\t\t0x75, 0x65, 0x65, 0x6e, 0x73, 0x6c, 0x61, 0x6e,\n+\t\t0x64, 0x31, 0x1a, 0x30, 0x18, 0x06, 0x03, 0x55,\n+\t\t0x04, 0x0a, 0x13, 0x11, 0x43, 0x72, 0x79, 0x70,\n+\t\t0x74, 0x53, 0x6f, 0x66, 0x74, 0x20, 0x50, 0x74,\n+\t\t0x79, 0x20, 0x4c, 0x74, 0x64, 0x31, 0x23, 0x30,\n+\t\t0x21, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x1a,\n+\t\t0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x74,\n+\t\t0x65, 0x73, 0x74, 0x20, 0x63, 0x65, 0x72, 0x74,\n+\t\t0x20, 0x28, 0x35, 0x31, 0x32, 0x20, 0x62, 0x69,\n+\t\t0x74, 0x29, 0x30, 0x5c, 0x30, 0x0d, 0x06, 0x09,\n+\t\t0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01,\n+\t\t0x01, 0x05, 0x00, 0x03, 0x4b, 0x00, 0x30, 0x48,\n+\t\t0x02, 0x41, 0x00, 0x9f, 0xb3, 0xc3, 0x84, 0x27,\n+\t\t0x95, 0xff, 0x12, 0x31, 0x52, 0x0f, 0x15, 0xef,\n+\t\t0x46, 0x11, 0xc4, 0xad, 0x80, 0xe6, 0x36, 0x5b,\n+\t\t0x0f, 0xdd, 0x80, 0xd7, 0x61, 0x8d, 0xe0, 0xfc,\n+\t\t0x72, 0x45, 0x09, 0x34, 0xfe, 0x55, 0x66, 0x45,\n+\t\t0x43, 0x4c, 0x68, 0x97, 0x6a, 0xfe, 0xa8, 0xa0,\n+\t\t0xa5, 0xdf, 0x5f, 0x78, 0xff, 0xee, 0xd7, 0x64,\n+\t\t0xb8, 0x3f, 0x04, 0xcb, 0x6f, 0xff, 0x2a, 0xfe,\n+\t\t0xfe, 0xb9, 0xed, 0x02, 0x03, 0x01, 0x00, 0x01,\n+\t\t0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86,\n+\t\t0xf7, 0x0d, 0x01, 0x01, 0x04, 0x05, 0x00, 0x03,\n+\t\t0x81, 0x81, 0x00, 0x93, 0xd2, 0x0a, 0xc5, 0x41,\n+\t\t0xe6, 0x5a, 0xa9, 0x86, 0xf9, 0x11, 0x87, 0xe4,\n+\t\t0xdb, 0x45, 0xe2, 0xc5, 0x95, 0x78, 0x1a, 0x6c,\n+\t\t0x80, 0x6d, 0x73, 0x1f, 0xb4, 0x6d, 0x44, 0xa3,\n+\t\t0xba, 0x86, 0x88, 0xc8, 0x58, 0xcd, 0x1c, 0x06,\n+\t\t0x35, 0x6c, 0x44, 0x62, 0x88, 0xdf, 0xe4, 0xf6,\n+\t\t0x64, 0x61, 0x95, 0xef, 0x4a, 0xa6, 0x7f, 0x65,\n+\t\t0x71, 0xd7, 0x6b, 0x88, 0x39, 0xf6, 0x32, 0xbf,\n+\t\t0xac, 0x93, 0x67, 0x69, 0x51, 0x8c, 0x93, 0xec,\n+\t\t0x48, 0x5f, 0xc9, 0xb1, 0x42, 0xf9, 0x55, 0xd2,\n+\t\t0x7e, 0x4e, 0xf4, 0xf2, 0x21, 0x6b, 0x90, 0x57,\n+\t\t0xe6, 0xd7, 0x99, 0x9e, 0x41, 0xca, 0x80, 0xbf,\n+\t\t0x1a, 0x28, 0xa2, 0xca, 0x5b, 0x50, 0x4a, 0xed,\n+\t\t0x84, 0xe7, 0x82, 0xc7, 0xd2, 0xcf, 0x36, 0x9e,\n+\t\t0x6a, 0x67, 0xb9, 0x88, 0xa7, 0xf3, 0x8a, 0xd0,\n+\t\t0x04, 0xf8, 0xe8, 0xc6, 0x17, 0xe3, 0xc5, 0x29,\n+\t\t0xbc, 0x17, 0xf1, 0x16, 0x03, 0x01, 0x00, 0x04,\n+\t\t0x0e, 0x00, 0x00, 0x00,\n+\t},\n+\n+\t{\n+\t\t0x16, 0x03, 0x01, 0x00, 0x46, 0x10, 0x00, 0x00,\n+\t\t0x42, 0x00, 0x40, 0x87, 0xa1, 0x1f, 0x14, 0xe1,\n+\t\t0xfb, 0x91, 0xac, 0x58, 0x2e, 0xf3, 0x71, 0xce,\n+\t\t0x01, 0x85, 0x2c, 0xc7, 0xfe, 0x84, 0x87, 0x82,\n+\t\t0xb7, 0x57, 0xdb, 0x37, 0x4d, 0x46, 0x83, 0x67,\n+\t\t0x52, 0x82, 0x51, 0x01, 0x95, 0x23, 0x68, 0x69,\n+\t\t0x6b, 0xd0, 0xa7, 0xa7, 0xe5, 0x88, 0xd0, 0x47,\n+\t\t0x71, 0xb8, 0xd2, 0x03, 0x05, 0x25, 0x56, 0x5c,\n+\t\t0x10, 0x08, 0xc6, 0x9b, 0xd4, 0x67, 0xcd, 0x28,\n+\t\t0xbe, 0x9c, 0x48, 0x14, 0x03, 0x01, 0x00, 0x01,\n+\t\t0x01, 0x16, 0x03, 0x01, 0x00, 0x24, 0xc1, 0xb8,\n+\t\t0xd3, 0x7f, 0xc5, 0xc2, 0x5a, 0x1d, 0x6d, 0x5b,\n+\t\t0x2d, 0x5c, 0x82, 0x87, 0xc2, 0x6f, 0x0d, 0x63,\n+\t\t0x7b, 0x72, 0x2b, 0xda, 0x69, 0xc4, 0xfe, 0x3c,\n+\t\t0x84, 0xa1, 0x5a, 0x62, 0x38, 0x37, 0xc6, 0x54,\n+\t\t0x25, 0x2a,\n+\t},\n+\n+\t{\n+\t\t0x14, 0x03, 0x01, 0x00, 0x01, 0x01, 0x16, 0x03,\n+\t\t0x01, 0x00, 0x24, 0xea, 0x88, 0x9c, 0x00, 0xf6,\n+\t\t0x35, 0xb8, 0x42, 0x7f, 0x15, 0x17, 0x76, 0x5e,\n+\t\t0x4b, 0x24, 0xcb, 0x7e, 0xa0, 0x7b, 0xc3, 0x70,\n+\t\t0x52, 0x0a, 0x88, 0x2a, 0x7a, 0x45, 0x59, 0x90,\n+\t\t0x59, 0xac, 0xc6, 0xb5, 0x56, 0x55, 0x96,\n+\t},\n+}"}, {"sha": "e5e8562713df54485c857a481718f4acd84795b3", "filename": "libgo/go/crypto/tls/handshake_messages.go", "status": "modified", "additions": 105, "deletions": 8, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -14,6 +14,8 @@ type clientHelloMsg struct {\n \tnextProtoNeg       bool\n \tserverName         string\n \tocspStapling       bool\n+\tsupportedCurves    []uint16\n+\tsupportedPoints    []uint8\n }\n \n func (m *clientHelloMsg) marshal() []byte {\n@@ -35,6 +37,14 @@ func (m *clientHelloMsg) marshal() []byte {\n \t\textensionsLength += 5 + len(m.serverName)\n \t\tnumExtensions++\n \t}\n+\tif len(m.supportedCurves) > 0 {\n+\t\textensionsLength += 2 + 2*len(m.supportedCurves)\n+\t\tnumExtensions++\n+\t}\n+\tif len(m.supportedPoints) > 0 {\n+\t\textensionsLength += 1 + len(m.supportedPoints)\n+\t\tnumExtensions++\n+\t}\n \tif numExtensions > 0 {\n \t\textensionsLength += 4 * numExtensions\n \t\tlength += 2 + extensionsLength\n@@ -117,6 +127,38 @@ func (m *clientHelloMsg) marshal() []byte {\n \t\t// Two zero valued uint16s for the two lengths.\n \t\tz = z[9:]\n \t}\n+\tif len(m.supportedCurves) > 0 {\n+\t\t// http://tools.ietf.org/html/rfc4492#section-5.5.1\n+\t\tz[0] = byte(extensionSupportedCurves >> 8)\n+\t\tz[1] = byte(extensionSupportedCurves)\n+\t\tl := 2 + 2*len(m.supportedCurves)\n+\t\tz[2] = byte(l >> 8)\n+\t\tz[3] = byte(l)\n+\t\tl -= 2\n+\t\tz[4] = byte(l >> 8)\n+\t\tz[5] = byte(l)\n+\t\tz = z[6:]\n+\t\tfor _, curve := range m.supportedCurves {\n+\t\t\tz[0] = byte(curve >> 8)\n+\t\t\tz[1] = byte(curve)\n+\t\t\tz = z[2:]\n+\t\t}\n+\t}\n+\tif len(m.supportedPoints) > 0 {\n+\t\t// http://tools.ietf.org/html/rfc4492#section-5.5.2\n+\t\tz[0] = byte(extensionSupportedPoints >> 8)\n+\t\tz[1] = byte(extensionSupportedPoints)\n+\t\tl := 1 + len(m.supportedPoints)\n+\t\tz[2] = byte(l >> 8)\n+\t\tz[3] = byte(l)\n+\t\tl--\n+\t\tz[4] = byte(l)\n+\t\tz = z[5:]\n+\t\tfor _, pointFormat := range m.supportedPoints {\n+\t\t\tz[0] = byte(pointFormat)\n+\t\t\tz = z[1:]\n+\t\t}\n+\t}\n \n \tm.raw = x\n \n@@ -221,6 +263,33 @@ func (m *clientHelloMsg) unmarshal(data []byte) bool {\n \t\t\tm.nextProtoNeg = true\n \t\tcase extensionStatusRequest:\n \t\t\tm.ocspStapling = length > 0 && data[0] == statusTypeOCSP\n+\t\tcase extensionSupportedCurves:\n+\t\t\t// http://tools.ietf.org/html/rfc4492#section-5.5.1\n+\t\t\tif length < 2 {\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t\tl := int(data[0])<<8 | int(data[1])\n+\t\t\tif l%2 == 1 || length != l+2 {\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t\tnumCurves := l / 2\n+\t\t\tm.supportedCurves = make([]uint16, numCurves)\n+\t\t\td := data[2:]\n+\t\t\tfor i := 0; i < numCurves; i++ {\n+\t\t\t\tm.supportedCurves[i] = uint16(d[0])<<8 | uint16(d[1])\n+\t\t\t\td = d[2:]\n+\t\t\t}\n+\t\tcase extensionSupportedPoints:\n+\t\t\t// http://tools.ietf.org/html/rfc4492#section-5.5.2\n+\t\t\tif length < 1 {\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t\tl := int(data[0])\n+\t\t\tif length != l+1 {\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t\tm.supportedPoints = make([]uint8, l)\n+\t\t\tcopy(m.supportedPoints, data[1:])\n \t\t}\n \t\tdata = data[length:]\n \t}\n@@ -466,6 +535,36 @@ func (m *certificateMsg) unmarshal(data []byte) bool {\n \treturn true\n }\n \n+type serverKeyExchangeMsg struct {\n+\traw []byte\n+\tkey []byte\n+}\n+\n+func (m *serverKeyExchangeMsg) marshal() []byte {\n+\tif m.raw != nil {\n+\t\treturn m.raw\n+\t}\n+\tlength := len(m.key)\n+\tx := make([]byte, length+4)\n+\tx[0] = typeServerKeyExchange\n+\tx[1] = uint8(length >> 16)\n+\tx[2] = uint8(length >> 8)\n+\tx[3] = uint8(length)\n+\tcopy(x[4:], m.key)\n+\n+\tm.raw = x\n+\treturn x\n+}\n+\n+func (m *serverKeyExchangeMsg) unmarshal(data []byte) bool {\n+\tm.raw = data\n+\tif len(data) < 4 {\n+\t\treturn false\n+\t}\n+\tm.key = data[4:]\n+\treturn true\n+}\n+\n type certificateStatusMsg struct {\n \traw        []byte\n \tstatusType uint8\n@@ -542,30 +641,28 @@ func (m *clientKeyExchangeMsg) marshal() []byte {\n \tif m.raw != nil {\n \t\treturn m.raw\n \t}\n-\tlength := len(m.ciphertext) + 2\n+\tlength := len(m.ciphertext)\n \tx := make([]byte, length+4)\n \tx[0] = typeClientKeyExchange\n \tx[1] = uint8(length >> 16)\n \tx[2] = uint8(length >> 8)\n \tx[3] = uint8(length)\n-\tx[4] = uint8(len(m.ciphertext) >> 8)\n-\tx[5] = uint8(len(m.ciphertext))\n-\tcopy(x[6:], m.ciphertext)\n+\tcopy(x[4:], m.ciphertext)\n \n \tm.raw = x\n \treturn x\n }\n \n func (m *clientKeyExchangeMsg) unmarshal(data []byte) bool {\n \tm.raw = data\n-\tif len(data) < 7 {\n+\tif len(data) < 4 {\n \t\treturn false\n \t}\n-\tcipherTextLen := int(data[4])<<8 | int(data[5])\n-\tif len(data) != 6+cipherTextLen {\n+\tl := int(data[1])<<16 | int(data[2])<<8 | int(data[3])\n+\tif l != len(data)-4 {\n \t\treturn false\n \t}\n-\tm.ciphertext = data[6:]\n+\tm.ciphertext = data[4:]\n \treturn true\n }\n "}, {"sha": "21577dd0b0176587b2e133da72dedcc715446053", "filename": "libgo/go/crypto/tls/handshake_messages_test.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -115,6 +115,11 @@ func (*clientHelloMsg) Generate(rand *rand.Rand, size int) reflect.Value {\n \t\tm.serverName = randomString(rand.Intn(255), rand)\n \t}\n \tm.ocspStapling = rand.Intn(10) > 5\n+\tm.supportedPoints = randomBytes(rand.Intn(5)+1, rand)\n+\tm.supportedCurves = make([]uint16, rand.Intn(5)+1)\n+\tfor i, _ := range m.supportedCurves {\n+\t\tm.supportedCurves[i] = uint16(rand.Intn(30000))\n+\t}\n \n \treturn reflect.NewValue(m)\n }"}, {"sha": "955811ada35d3b3aceb89d6133135b99bd0ef60a", "filename": "libgo/go/crypto/tls/handshake_server.go", "status": "modified", "additions": 58, "deletions": 53, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -4,34 +4,14 @@\n \n package tls\n \n-// The handshake goroutine reads handshake messages from the record processor\n-// and outputs messages to be written on another channel. It updates the record\n-// processor with the state of the connection via the control channel. In the\n-// case of handshake messages that need synchronous processing (because they\n-// affect the handling of the next record) the record processor knows about\n-// them and either waits for a control message (Finished) or includes a reply\n-// channel in the message (ChangeCipherSpec).\n-\n import (\n-\t\"crypto/hmac\"\n-\t\"crypto/rc4\"\n \t\"crypto/rsa\"\n \t\"crypto/subtle\"\n \t\"crypto/x509\"\n \t\"io\"\n \t\"os\"\n )\n \n-type cipherSuite struct {\n-\tid                          uint16 // The number of this suite on the wire.\n-\thashLength, cipherKeyLength int\n-\t// TODO(agl): need a method to create the cipher and hash interfaces.\n-}\n-\n-var cipherSuites = []cipherSuite{\n-\t{TLS_RSA_WITH_RC4_128_SHA, 20, 16},\n-}\n-\n func (c *Conn) serverHandshake() os.Error {\n \tconfig := c.config\n \tmsg, err := c.readHandshake()\n@@ -54,16 +34,38 @@ func (c *Conn) serverHandshake() os.Error {\n \n \thello := new(serverHelloMsg)\n \n-\t// We only support a single ciphersuite so we look for it in the list\n-\t// of client supported suites.\n-\t//\n-\t// TODO(agl): Add additional cipher suites.\n-\tvar suite *cipherSuite\n+\tsupportedCurve := false\n+Curves:\n+\tfor _, curve := range clientHello.supportedCurves {\n+\t\tswitch curve {\n+\t\tcase curveP256, curveP384, curveP521:\n+\t\t\tsupportedCurve = true\n+\t\t\tbreak Curves\n+\t\t}\n+\t}\n+\n+\tsupportedPointFormat := false\n+\tfor _, pointFormat := range clientHello.supportedPoints {\n+\t\tif pointFormat == pointFormatUncompressed {\n+\t\t\tsupportedPointFormat = true\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\n+\tellipticOk := supportedCurve && supportedPointFormat\n \n+\tvar suite *cipherSuite\n+\tvar suiteId uint16\n \tfor _, id := range clientHello.cipherSuites {\n-\t\tfor _, supported := range cipherSuites {\n-\t\t\tif supported.id == id {\n-\t\t\t\tsuite = &supported\n+\t\tfor _, supported := range config.cipherSuites() {\n+\t\t\tif id == supported {\n+\t\t\t\tsuite = cipherSuites[id]\n+\t\t\t\t// Don't select a ciphersuite which we can't\n+\t\t\t\t// support for this client.\n+\t\t\t\tif suite.elliptic && !ellipticOk {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tsuiteId = id\n \t\t\t\tbreak\n \t\t\t}\n \t\t}\n@@ -83,14 +85,14 @@ func (c *Conn) serverHandshake() os.Error {\n \t}\n \n \thello.vers = vers\n-\thello.cipherSuite = suite.id\n-\tt := uint32(config.Time())\n+\thello.cipherSuite = suiteId\n+\tt := uint32(config.time())\n \thello.random = make([]byte, 32)\n \thello.random[0] = byte(t >> 24)\n \thello.random[1] = byte(t >> 16)\n \thello.random[2] = byte(t >> 8)\n \thello.random[3] = byte(t)\n-\t_, err = io.ReadFull(config.Rand, hello.random[4:])\n+\t_, err = io.ReadFull(config.rand(), hello.random[4:])\n \tif err != nil {\n \t\treturn c.sendAlert(alertInternalError)\n \t}\n@@ -112,6 +114,18 @@ func (c *Conn) serverHandshake() os.Error {\n \tfinishedHash.Write(certMsg.marshal())\n \tc.writeRecord(recordTypeHandshake, certMsg.marshal())\n \n+\tkeyAgreement := suite.ka()\n+\n+\tskx, err := keyAgreement.generateServerKeyExchange(config, clientHello, hello)\n+\tif err != nil {\n+\t\tc.sendAlert(alertHandshakeFailure)\n+\t\treturn err\n+\t}\n+\tif skx != nil {\n+\t\tfinishedHash.Write(skx.marshal())\n+\t\tc.writeRecord(recordTypeHandshake, skx.marshal())\n+\t}\n+\n \tif config.AuthenticateClient {\n \t\t// Request a client certificate\n \t\tcertReq := new(certificateRequestMsg)\n@@ -208,28 +222,18 @@ func (c *Conn) serverHandshake() os.Error {\n \t\tfinishedHash.Write(certVerify.marshal())\n \t}\n \n-\tpreMasterSecret := make([]byte, 48)\n-\t_, err = io.ReadFull(config.Rand, preMasterSecret[2:])\n+\tpreMasterSecret, err := keyAgreement.processClientKeyExchange(config, ckx)\n \tif err != nil {\n-\t\treturn c.sendAlert(alertInternalError)\n+\t\tc.sendAlert(alertHandshakeFailure)\n+\t\treturn err\n \t}\n \n-\terr = rsa.DecryptPKCS1v15SessionKey(config.Rand, config.Certificates[0].PrivateKey, ckx.ciphertext, preMasterSecret)\n-\tif err != nil {\n-\t\treturn c.sendAlert(alertHandshakeFailure)\n-\t}\n-\t// We don't check the version number in the premaster secret. For one,\n-\t// by checking it, we would leak information about the validity of the\n-\t// encrypted pre-master secret. Secondly, it provides only a small\n-\t// benefit against a downgrade attack and some implementations send the\n-\t// wrong version anyway. See the discussion at the end of section\n-\t// 7.4.7.1 of RFC 4346.\n-\n-\tmasterSecret, clientMAC, serverMAC, clientKey, serverKey :=\n-\t\tkeysFromPreMasterSecret11(preMasterSecret, clientHello.random, hello.random, suite.hashLength, suite.cipherKeyLength)\n-\n-\tcipher, _ := rc4.NewCipher(clientKey)\n-\tc.in.prepareCipherSpec(cipher, hmac.NewSHA1(clientMAC))\n+\tmasterSecret, clientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV :=\n+\t\tkeysFromPreMasterSecret10(preMasterSecret, clientHello.random, hello.random, suite.macLen, suite.keyLen, suite.ivLen)\n+\n+\tclientCipher := suite.cipher(clientKey, clientIV, true /* for reading */ )\n+\tclientHash := suite.mac(clientMAC)\n+\tc.in.prepareCipherSpec(clientCipher, clientHash)\n \tc.readRecord(recordTypeChangeCipherSpec)\n \tif err := c.error(); err != nil {\n \t\treturn err\n@@ -265,16 +269,17 @@ func (c *Conn) serverHandshake() os.Error {\n \n \tfinishedHash.Write(clientFinished.marshal())\n \n-\tcipher2, _ := rc4.NewCipher(serverKey)\n-\tc.out.prepareCipherSpec(cipher2, hmac.NewSHA1(serverMAC))\n+\tserverCipher := suite.cipher(serverKey, serverIV, false /* not for reading */ )\n+\tserverHash := suite.mac(serverMAC)\n+\tc.out.prepareCipherSpec(serverCipher, serverHash)\n \tc.writeRecord(recordTypeChangeCipherSpec, []byte{1})\n \n \tfinished := new(finishedMsg)\n \tfinished.verifyData = finishedHash.serverSum(masterSecret)\n \tc.writeRecord(recordTypeHandshake, finished.marshal())\n \n \tc.handshakeComplete = true\n-\tc.cipherSuite = TLS_RSA_WITH_RC4_128_SHA\n+\tc.cipherSuite = suiteId\n \n \treturn nil\n }"}, {"sha": "5cf3ae0499d677e12a850027803bcaee7ba3be26", "filename": "libgo/go/crypto/tls/handshake_server_test.go", "status": "modified", "additions": 329, "deletions": 106, "changes": 435, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -5,16 +5,15 @@\n package tls\n \n import (\n-\t//\t\"bytes\"\n \t\"big\"\n+\t\"bytes\"\n \t\"crypto/rsa\"\n \t\"encoding/hex\"\n \t\"flag\"\n \t\"io\"\n \t\"net\"\n \t\"os\"\n \t\"testing\"\n-\t//\t\"testing/script\"\n )\n \n type zeroSource struct{}\n@@ -36,6 +35,7 @@ func init() {\n \ttestConfig.Certificates = make([]Certificate, 1)\n \ttestConfig.Certificates[0].Certificate = [][]byte{testCertificate}\n \ttestConfig.Certificates[0].PrivateKey = testPrivateKey\n+\ttestConfig.CipherSuites = []uint16{TLS_RSA_WITH_RC4_128_SHA}\n }\n \n func testClientHelloFailure(t *testing.T, m handshakeMessage, expected os.Error) {\n@@ -71,13 +71,13 @@ func TestRejectBadProtocolVersion(t *testing.T) {\n }\n \n func TestNoSuiteOverlap(t *testing.T) {\n-\tclientHello := &clientHelloMsg{nil, 0x0301, nil, nil, []uint16{0xff00}, []uint8{0}, false, \"\", false}\n+\tclientHello := &clientHelloMsg{nil, 0x0301, nil, nil, []uint16{0xff00}, []uint8{0}, false, \"\", false, nil, nil}\n \ttestClientHelloFailure(t, clientHello, alertHandshakeFailure)\n \n }\n \n func TestNoCompressionOverlap(t *testing.T) {\n-\tclientHello := &clientHelloMsg{nil, 0x0301, nil, nil, []uint16{TLS_RSA_WITH_RC4_128_SHA}, []uint8{0xff}, false, \"\", false}\n+\tclientHello := &clientHelloMsg{nil, 0x0301, nil, nil, []uint16{TLS_RSA_WITH_RC4_128_SHA}, []uint8{0xff}, false, \"\", false, nil, nil}\n \ttestClientHelloFailure(t, clientHello, alertHandshakeFailure)\n }\n \n@@ -107,9 +107,9 @@ func TestClose(t *testing.T) {\n }\n \n \n-func TestHandshakeServer(t *testing.T) {\n+func testServerScript(t *testing.T, name string, serverScript [][]byte, config *Config) {\n \tc, s := net.Pipe()\n-\tsrv := Server(s, testConfig)\n+\tsrv := Server(s, config)\n \tgo func() {\n \t\tsrv.Write([]byte(\"hello, world\\n\"))\n \t\tsrv.Close()\n@@ -124,15 +124,23 @@ func TestHandshakeServer(t *testing.T) {\n \t\tbb := make([]byte, len(b))\n \t\t_, err := io.ReadFull(c, bb)\n \t\tif err != nil {\n-\t\t\tt.Fatalf(\"#%d: %s\", i, err)\n+\t\t\tt.Fatalf(\"%s #%d: %s\", name, i, err)\n+\t\t}\n+\t\tif !bytes.Equal(b, bb) {\n+\t\t\tt.Fatalf(\"%s #%d: mismatch on read: got:%x want:%x\", name, i, bb, b)\n \t\t}\n \t}\n+}\n \n-\tif !srv.haveVers || srv.vers != 0x0302 {\n-\t\tt.Errorf(\"server version incorrect: %v %v\", srv.haveVers, srv.vers)\n-\t}\n+func TestHandshakeServerRC4(t *testing.T) {\n+\ttestServerScript(t, \"RC4\", rc4ServerScript, testConfig)\n+}\n \n-\t// TODO: check protocol\n+func TestHandshakeServerAES(t *testing.T) {\n+\taesConfig := new(Config)\n+\t*aesConfig = *testConfig\n+\taesConfig.CipherSuites = []uint16{TLS_RSA_WITH_AES_128_CBC_SHA}\n+\ttestServerScript(t, \"AES\", aesServerScript, aesConfig)\n }\n \n var serve = flag.Bool(\"serve\", false, \"run a TLS server on :10443\")\n@@ -152,7 +160,11 @@ func TestRunServer(t *testing.T) {\n \t\tif err != nil {\n \t\t\tbreak\n \t\t}\n-\t\tc.Write([]byte(\"hello, world\\n\"))\n+\t\t_, err = c.Write([]byte(\"hello, world\\n\"))\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"error from TLS: %s\", err)\n+\t\t\tbreak\n+\t\t}\n \t\tc.Close()\n \t}\n }\n@@ -181,113 +193,324 @@ var testPrivateKey = &rsa.PrivateKey{\n }\n \n // Script of interaction with gnutls implementation.\n-// The values for this test are obtained by building a test binary (gotest)\n-// and then running 6.out -serve to start a server and then\n-// gnutls-cli --insecure --debug 100 -p 10443 localhost\n-// to dump a session.\n-var serverScript = [][]byte{\n-\t// Alternate write and read.\n+// The values for this test are obtained by building and running in server mode:\n+//   % gotest -match \"TestRunServer\" -serve\n+// and then:\n+//   % gnutls-cli --insecure --debug 100 -p 10443 localhost > /tmp/log 2>&1\n+//   % python parse-gnutls-cli-debug-log.py < /tmp/log\n+var rc4ServerScript = [][]byte{\n \t{\n-\t\t0x16, 0x03, 0x02, 0x00, 0x71, 0x01, 0x00, 0x00, 0x6d, 0x03, 0x02, 0x4b, 0xd4, 0xee, 0x6e, 0xab,\n-\t\t0x0b, 0xc3, 0x01, 0xd6, 0x8d, 0xe0, 0x72, 0x7e, 0x6c, 0x04, 0xbe, 0x9a, 0x3c, 0xa3, 0xd8, 0x95,\n-\t\t0x28, 0x00, 0xb2, 0xe8, 0x1f, 0xdd, 0xb0, 0xec, 0xca, 0x46, 0x1f, 0x00, 0x00, 0x28, 0x00, 0x33,\n-\t\t0x00, 0x39, 0x00, 0x16, 0x00, 0x32, 0x00, 0x38, 0x00, 0x13, 0x00, 0x66, 0x00, 0x90, 0x00, 0x91,\n-\t\t0x00, 0x8f, 0x00, 0x8e, 0x00, 0x2f, 0x00, 0x35, 0x00, 0x0a, 0x00, 0x05, 0x00, 0x04, 0x00, 0x8c,\n-\t\t0x00, 0x8d, 0x00, 0x8b, 0x00, 0x8a, 0x01, 0x00, 0x00, 0x1c, 0x00, 0x09, 0x00, 0x03, 0x02, 0x00,\n-\t\t0x01, 0x00, 0x00, 0x00, 0x11, 0x00, 0x0f, 0x00, 0x00, 0x0c, 0x31, 0x39, 0x32, 0x2e, 0x31, 0x36,\n-\t\t0x38, 0x2e, 0x30, 0x2e, 0x31, 0x30,\n+\t\t0x16, 0x03, 0x02, 0x00, 0x7f, 0x01, 0x00, 0x00,\n+\t\t0x7b, 0x03, 0x02, 0x4d, 0x08, 0x1f, 0x5a, 0x7a,\n+\t\t0x0a, 0x92, 0x2f, 0xf0, 0x73, 0x16, 0x3a, 0x88,\n+\t\t0x14, 0x85, 0x4c, 0x98, 0x15, 0x7b, 0x65, 0xe0,\n+\t\t0x78, 0xd0, 0xed, 0xd0, 0xf3, 0x65, 0x20, 0xeb,\n+\t\t0x80, 0xd1, 0x0b, 0x00, 0x00, 0x34, 0x00, 0x33,\n+\t\t0x00, 0x45, 0x00, 0x39, 0x00, 0x88, 0x00, 0x16,\n+\t\t0x00, 0x32, 0x00, 0x44, 0x00, 0x38, 0x00, 0x87,\n+\t\t0x00, 0x13, 0x00, 0x66, 0x00, 0x90, 0x00, 0x91,\n+\t\t0x00, 0x8f, 0x00, 0x8e, 0x00, 0x2f, 0x00, 0x41,\n+\t\t0x00, 0x35, 0x00, 0x84, 0x00, 0x0a, 0x00, 0x05,\n+\t\t0x00, 0x04, 0x00, 0x8c, 0x00, 0x8d, 0x00, 0x8b,\n+\t\t0x00, 0x8a, 0x01, 0x00, 0x00, 0x1e, 0x00, 0x09,\n+\t\t0x00, 0x03, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00,\n+\t\t0x0e, 0x00, 0x0c, 0x00, 0x00, 0x09, 0x6c, 0x6f,\n+\t\t0x63, 0x61, 0x6c, 0x68, 0x6f, 0x73, 0x74, 0xff,\n+\t\t0x01, 0x00, 0x01, 0x00,\n \t},\n \n \t{\n-\t\t0x16, 0x03, 0x02, 0x00, 0x2a,\n-\t\t0x02, 0x00, 0x00, 0x26, 0x03, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n-\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n-\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00,\n-\n-\t\t0x16, 0x03, 0x02, 0x02, 0xbe,\n-\t\t0x0b, 0x00, 0x02, 0xba, 0x00, 0x02, 0xb7, 0x00, 0x02, 0xb4, 0x30, 0x82, 0x02, 0xb0, 0x30, 0x82,\n-\t\t0x02, 0x19, 0xa0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x09, 0x00, 0x85, 0xb0, 0xbb, 0xa4, 0x8a, 0x7f,\n-\t\t0xb8, 0xca, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x05, 0x05,\n-\t\t0x00, 0x30, 0x45, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x41, 0x55,\n-\t\t0x31, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x0a, 0x53, 0x6f, 0x6d, 0x65, 0x2d,\n-\t\t0x53, 0x74, 0x61, 0x74, 0x65, 0x31, 0x21, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x18,\n-\t\t0x49, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x20, 0x57, 0x69, 0x64, 0x67, 0x69, 0x74, 0x73,\n-\t\t0x20, 0x50, 0x74, 0x79, 0x20, 0x4c, 0x74, 0x64, 0x30, 0x1e, 0x17, 0x0d, 0x31, 0x30, 0x30, 0x34,\n-\t\t0x32, 0x34, 0x30, 0x39, 0x30, 0x39, 0x33, 0x38, 0x5a, 0x17, 0x0d, 0x31, 0x31, 0x30, 0x34, 0x32,\n-\t\t0x34, 0x30, 0x39, 0x30, 0x39, 0x33, 0x38, 0x5a, 0x30, 0x45, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03,\n-\t\t0x55, 0x04, 0x06, 0x13, 0x02, 0x41, 0x55, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x08,\n-\t\t0x13, 0x0a, 0x53, 0x6f, 0x6d, 0x65, 0x2d, 0x53, 0x74, 0x61, 0x74, 0x65, 0x31, 0x21, 0x30, 0x1f,\n-\t\t0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x18, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x20,\n-\t\t0x57, 0x69, 0x64, 0x67, 0x69, 0x74, 0x73, 0x20, 0x50, 0x74, 0x79, 0x20, 0x4c, 0x74, 0x64, 0x30,\n-\t\t0x81, 0x9f, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05,\n-\t\t0x00, 0x03, 0x81, 0x8d, 0x00, 0x30, 0x81, 0x89, 0x02, 0x81, 0x81, 0x00, 0xbb, 0x79, 0xd6, 0xf5,\n-\t\t0x17, 0xb5, 0xe5, 0xbf, 0x46, 0x10, 0xd0, 0xdc, 0x69, 0xbe, 0xe6, 0x2b, 0x07, 0x43, 0x5a, 0xd0,\n-\t\t0x03, 0x2d, 0x8a, 0x7a, 0x43, 0x85, 0xb7, 0x14, 0x52, 0xe7, 0xa5, 0x65, 0x4c, 0x2c, 0x78, 0xb8,\n-\t\t0x23, 0x8c, 0xb5, 0xb4, 0x82, 0xe5, 0xde, 0x1f, 0x95, 0x3b, 0x7e, 0x62, 0xa5, 0x2c, 0xa5, 0x33,\n-\t\t0xd6, 0xfe, 0x12, 0x5c, 0x7a, 0x56, 0xfc, 0xf5, 0x06, 0xbf, 0xfa, 0x58, 0x7b, 0x26, 0x3f, 0xb5,\n-\t\t0xcd, 0x04, 0xd3, 0xd0, 0xc9, 0x21, 0x96, 0x4a, 0xc7, 0xf4, 0x54, 0x9f, 0x5a, 0xbf, 0xef, 0x42,\n-\t\t0x71, 0x00, 0xfe, 0x18, 0x99, 0x07, 0x7f, 0x7e, 0x88, 0x7d, 0x7d, 0xf1, 0x04, 0x39, 0xc4, 0xa2,\n-\t\t0x2e, 0xdb, 0x51, 0xc9, 0x7c, 0xe3, 0xc0, 0x4c, 0x3b, 0x32, 0x66, 0x01, 0xcf, 0xaf, 0xb1, 0x1d,\n-\t\t0xb8, 0x71, 0x9a, 0x1d, 0xdb, 0xdb, 0x89, 0x6b, 0xae, 0xda, 0x2d, 0x79, 0x02, 0x03, 0x01, 0x00,\n-\t\t0x01, 0xa3, 0x81, 0xa7, 0x30, 0x81, 0xa4, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d, 0x0e, 0x04, 0x16,\n-\t\t0x04, 0x14, 0xb1, 0xad, 0xe2, 0x85, 0x5a, 0xcf, 0xcb, 0x28, 0xdb, 0x69, 0xce, 0x23, 0x69, 0xde,\n-\t\t0xd3, 0x26, 0x8e, 0x18, 0x88, 0x39, 0x30, 0x75, 0x06, 0x03, 0x55, 0x1d, 0x23, 0x04, 0x6e, 0x30,\n-\t\t0x6c, 0x80, 0x14, 0xb1, 0xad, 0xe2, 0x85, 0x5a, 0xcf, 0xcb, 0x28, 0xdb, 0x69, 0xce, 0x23, 0x69,\n-\t\t0xde, 0xd3, 0x26, 0x8e, 0x18, 0x88, 0x39, 0xa1, 0x49, 0xa4, 0x47, 0x30, 0x45, 0x31, 0x0b, 0x30,\n-\t\t0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x41, 0x55, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03,\n-\t\t0x55, 0x04, 0x08, 0x13, 0x0a, 0x53, 0x6f, 0x6d, 0x65, 0x2d, 0x53, 0x74, 0x61, 0x74, 0x65, 0x31,\n-\t\t0x21, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x18, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x6e,\n-\t\t0x65, 0x74, 0x20, 0x57, 0x69, 0x64, 0x67, 0x69, 0x74, 0x73, 0x20, 0x50, 0x74, 0x79, 0x20, 0x4c,\n-\t\t0x74, 0x64, 0x82, 0x09, 0x00, 0x85, 0xb0, 0xbb, 0xa4, 0x8a, 0x7f, 0xb8, 0xca, 0x30, 0x0c, 0x06,\n-\t\t0x03, 0x55, 0x1d, 0x13, 0x04, 0x05, 0x30, 0x03, 0x01, 0x01, 0xff, 0x30, 0x0d, 0x06, 0x09, 0x2a,\n-\t\t0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x81, 0x81, 0x00, 0x08, 0x6c,\n-\t\t0x45, 0x24, 0xc7, 0x6b, 0xb1, 0x59, 0xab, 0x0c, 0x52, 0xcc, 0xf2, 0xb0, 0x14, 0xd7, 0x87, 0x9d,\n-\t\t0x7a, 0x64, 0x75, 0xb5, 0x5a, 0x95, 0x66, 0xe4, 0xc5, 0x2b, 0x8e, 0xae, 0x12, 0x66, 0x1f, 0xeb,\n-\t\t0x4f, 0x38, 0xb3, 0x6e, 0x60, 0xd3, 0x92, 0xfd, 0xf7, 0x41, 0x08, 0xb5, 0x25, 0x13, 0xb1, 0x18,\n-\t\t0x7a, 0x24, 0xfb, 0x30, 0x1d, 0xba, 0xed, 0x98, 0xb9, 0x17, 0xec, 0xe7, 0xd7, 0x31, 0x59, 0xdb,\n-\t\t0x95, 0xd3, 0x1d, 0x78, 0xea, 0x50, 0x56, 0x5c, 0xd5, 0x82, 0x5a, 0x2d, 0x5a, 0x5f, 0x33, 0xc4,\n-\t\t0xb6, 0xd8, 0xc9, 0x75, 0x90, 0x96, 0x8c, 0x0f, 0x52, 0x98, 0xb5, 0xcd, 0x98, 0x1f, 0x89, 0x20,\n-\t\t0x5f, 0xf2, 0xa0, 0x1c, 0xa3, 0x1b, 0x96, 0x94, 0xdd, 0xa9, 0xfd, 0x57, 0xe9, 0x70, 0xe8, 0x26,\n-\t\t0x6d, 0x71, 0x99, 0x9b, 0x26, 0x6e, 0x38, 0x50, 0x29, 0x6c, 0x90, 0xa7, 0xbd, 0xd9,\n-\t\t0x16, 0x03, 0x02, 0x00, 0x04,\n-\t\t0x0e, 0x00, 0x00, 0x00,\n+\t\t0x16, 0x03, 0x01, 0x00, 0x2a, 0x02, 0x00, 0x00,\n+\t\t0x26, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x16,\n+\t\t0x03, 0x01, 0x02, 0xbe, 0x0b, 0x00, 0x02, 0xba,\n+\t\t0x00, 0x02, 0xb7, 0x00, 0x02, 0xb4, 0x30, 0x82,\n+\t\t0x02, 0xb0, 0x30, 0x82, 0x02, 0x19, 0xa0, 0x03,\n+\t\t0x02, 0x01, 0x02, 0x02, 0x09, 0x00, 0x85, 0xb0,\n+\t\t0xbb, 0xa4, 0x8a, 0x7f, 0xb8, 0xca, 0x30, 0x0d,\n+\t\t0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d,\n+\t\t0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x45, 0x31,\n+\t\t0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06,\n+\t\t0x13, 0x02, 0x41, 0x55, 0x31, 0x13, 0x30, 0x11,\n+\t\t0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x0a, 0x53,\n+\t\t0x6f, 0x6d, 0x65, 0x2d, 0x53, 0x74, 0x61, 0x74,\n+\t\t0x65, 0x31, 0x21, 0x30, 0x1f, 0x06, 0x03, 0x55,\n+\t\t0x04, 0x0a, 0x13, 0x18, 0x49, 0x6e, 0x74, 0x65,\n+\t\t0x72, 0x6e, 0x65, 0x74, 0x20, 0x57, 0x69, 0x64,\n+\t\t0x67, 0x69, 0x74, 0x73, 0x20, 0x50, 0x74, 0x79,\n+\t\t0x20, 0x4c, 0x74, 0x64, 0x30, 0x1e, 0x17, 0x0d,\n+\t\t0x31, 0x30, 0x30, 0x34, 0x32, 0x34, 0x30, 0x39,\n+\t\t0x30, 0x39, 0x33, 0x38, 0x5a, 0x17, 0x0d, 0x31,\n+\t\t0x31, 0x30, 0x34, 0x32, 0x34, 0x30, 0x39, 0x30,\n+\t\t0x39, 0x33, 0x38, 0x5a, 0x30, 0x45, 0x31, 0x0b,\n+\t\t0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13,\n+\t\t0x02, 0x41, 0x55, 0x31, 0x13, 0x30, 0x11, 0x06,\n+\t\t0x03, 0x55, 0x04, 0x08, 0x13, 0x0a, 0x53, 0x6f,\n+\t\t0x6d, 0x65, 0x2d, 0x53, 0x74, 0x61, 0x74, 0x65,\n+\t\t0x31, 0x21, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x04,\n+\t\t0x0a, 0x13, 0x18, 0x49, 0x6e, 0x74, 0x65, 0x72,\n+\t\t0x6e, 0x65, 0x74, 0x20, 0x57, 0x69, 0x64, 0x67,\n+\t\t0x69, 0x74, 0x73, 0x20, 0x50, 0x74, 0x79, 0x20,\n+\t\t0x4c, 0x74, 0x64, 0x30, 0x81, 0x9f, 0x30, 0x0d,\n+\t\t0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d,\n+\t\t0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x81, 0x8d,\n+\t\t0x00, 0x30, 0x81, 0x89, 0x02, 0x81, 0x81, 0x00,\n+\t\t0xbb, 0x79, 0xd6, 0xf5, 0x17, 0xb5, 0xe5, 0xbf,\n+\t\t0x46, 0x10, 0xd0, 0xdc, 0x69, 0xbe, 0xe6, 0x2b,\n+\t\t0x07, 0x43, 0x5a, 0xd0, 0x03, 0x2d, 0x8a, 0x7a,\n+\t\t0x43, 0x85, 0xb7, 0x14, 0x52, 0xe7, 0xa5, 0x65,\n+\t\t0x4c, 0x2c, 0x78, 0xb8, 0x23, 0x8c, 0xb5, 0xb4,\n+\t\t0x82, 0xe5, 0xde, 0x1f, 0x95, 0x3b, 0x7e, 0x62,\n+\t\t0xa5, 0x2c, 0xa5, 0x33, 0xd6, 0xfe, 0x12, 0x5c,\n+\t\t0x7a, 0x56, 0xfc, 0xf5, 0x06, 0xbf, 0xfa, 0x58,\n+\t\t0x7b, 0x26, 0x3f, 0xb5, 0xcd, 0x04, 0xd3, 0xd0,\n+\t\t0xc9, 0x21, 0x96, 0x4a, 0xc7, 0xf4, 0x54, 0x9f,\n+\t\t0x5a, 0xbf, 0xef, 0x42, 0x71, 0x00, 0xfe, 0x18,\n+\t\t0x99, 0x07, 0x7f, 0x7e, 0x88, 0x7d, 0x7d, 0xf1,\n+\t\t0x04, 0x39, 0xc4, 0xa2, 0x2e, 0xdb, 0x51, 0xc9,\n+\t\t0x7c, 0xe3, 0xc0, 0x4c, 0x3b, 0x32, 0x66, 0x01,\n+\t\t0xcf, 0xaf, 0xb1, 0x1d, 0xb8, 0x71, 0x9a, 0x1d,\n+\t\t0xdb, 0xdb, 0x89, 0x6b, 0xae, 0xda, 0x2d, 0x79,\n+\t\t0x02, 0x03, 0x01, 0x00, 0x01, 0xa3, 0x81, 0xa7,\n+\t\t0x30, 0x81, 0xa4, 0x30, 0x1d, 0x06, 0x03, 0x55,\n+\t\t0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14, 0xb1, 0xad,\n+\t\t0xe2, 0x85, 0x5a, 0xcf, 0xcb, 0x28, 0xdb, 0x69,\n+\t\t0xce, 0x23, 0x69, 0xde, 0xd3, 0x26, 0x8e, 0x18,\n+\t\t0x88, 0x39, 0x30, 0x75, 0x06, 0x03, 0x55, 0x1d,\n+\t\t0x23, 0x04, 0x6e, 0x30, 0x6c, 0x80, 0x14, 0xb1,\n+\t\t0xad, 0xe2, 0x85, 0x5a, 0xcf, 0xcb, 0x28, 0xdb,\n+\t\t0x69, 0xce, 0x23, 0x69, 0xde, 0xd3, 0x26, 0x8e,\n+\t\t0x18, 0x88, 0x39, 0xa1, 0x49, 0xa4, 0x47, 0x30,\n+\t\t0x45, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55,\n+\t\t0x04, 0x06, 0x13, 0x02, 0x41, 0x55, 0x31, 0x13,\n+\t\t0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13,\n+\t\t0x0a, 0x53, 0x6f, 0x6d, 0x65, 0x2d, 0x53, 0x74,\n+\t\t0x61, 0x74, 0x65, 0x31, 0x21, 0x30, 0x1f, 0x06,\n+\t\t0x03, 0x55, 0x04, 0x0a, 0x13, 0x18, 0x49, 0x6e,\n+\t\t0x74, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x20, 0x57,\n+\t\t0x69, 0x64, 0x67, 0x69, 0x74, 0x73, 0x20, 0x50,\n+\t\t0x74, 0x79, 0x20, 0x4c, 0x74, 0x64, 0x82, 0x09,\n+\t\t0x00, 0x85, 0xb0, 0xbb, 0xa4, 0x8a, 0x7f, 0xb8,\n+\t\t0xca, 0x30, 0x0c, 0x06, 0x03, 0x55, 0x1d, 0x13,\n+\t\t0x04, 0x05, 0x30, 0x03, 0x01, 0x01, 0xff, 0x30,\n+\t\t0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,\n+\t\t0x0d, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x81,\n+\t\t0x81, 0x00, 0x08, 0x6c, 0x45, 0x24, 0xc7, 0x6b,\n+\t\t0xb1, 0x59, 0xab, 0x0c, 0x52, 0xcc, 0xf2, 0xb0,\n+\t\t0x14, 0xd7, 0x87, 0x9d, 0x7a, 0x64, 0x75, 0xb5,\n+\t\t0x5a, 0x95, 0x66, 0xe4, 0xc5, 0x2b, 0x8e, 0xae,\n+\t\t0x12, 0x66, 0x1f, 0xeb, 0x4f, 0x38, 0xb3, 0x6e,\n+\t\t0x60, 0xd3, 0x92, 0xfd, 0xf7, 0x41, 0x08, 0xb5,\n+\t\t0x25, 0x13, 0xb1, 0x18, 0x7a, 0x24, 0xfb, 0x30,\n+\t\t0x1d, 0xba, 0xed, 0x98, 0xb9, 0x17, 0xec, 0xe7,\n+\t\t0xd7, 0x31, 0x59, 0xdb, 0x95, 0xd3, 0x1d, 0x78,\n+\t\t0xea, 0x50, 0x56, 0x5c, 0xd5, 0x82, 0x5a, 0x2d,\n+\t\t0x5a, 0x5f, 0x33, 0xc4, 0xb6, 0xd8, 0xc9, 0x75,\n+\t\t0x90, 0x96, 0x8c, 0x0f, 0x52, 0x98, 0xb5, 0xcd,\n+\t\t0x98, 0x1f, 0x89, 0x20, 0x5f, 0xf2, 0xa0, 0x1c,\n+\t\t0xa3, 0x1b, 0x96, 0x94, 0xdd, 0xa9, 0xfd, 0x57,\n+\t\t0xe9, 0x70, 0xe8, 0x26, 0x6d, 0x71, 0x99, 0x9b,\n+\t\t0x26, 0x6e, 0x38, 0x50, 0x29, 0x6c, 0x90, 0xa7,\n+\t\t0xbd, 0xd9, 0x16, 0x03, 0x01, 0x00, 0x04, 0x0e,\n+\t\t0x00, 0x00, 0x00,\n \t},\n \n \t{\n-\t\t0x16, 0x03, 0x02, 0x00, 0x86, 0x10, 0x00, 0x00, 0x82, 0x00, 0x80, 0x3b, 0x7a, 0x9b, 0x05, 0xfd,\n-\t\t0x1b, 0x0d, 0x81, 0xf0, 0xac, 0x59, 0x57, 0x4e, 0xb6, 0xf5, 0x81, 0xed, 0x52, 0x78, 0xc5, 0xff,\n-\t\t0x36, 0x33, 0x9c, 0x94, 0x31, 0xc3, 0x14, 0x98, 0x5d, 0xa0, 0x49, 0x23, 0x11, 0x67, 0xdf, 0x73,\n-\t\t0x1b, 0x81, 0x0b, 0xdd, 0x10, 0xda, 0xee, 0xb5, 0x68, 0x61, 0xa9, 0xb6, 0x15, 0xae, 0x1a, 0x11,\n-\t\t0x31, 0x42, 0x2e, 0xde, 0x01, 0x4b, 0x81, 0x70, 0x03, 0xc8, 0x5b, 0xca, 0x21, 0x88, 0x25, 0xef,\n-\t\t0x89, 0xf0, 0xb7, 0xff, 0x24, 0x32, 0xd3, 0x14, 0x76, 0xe2, 0x50, 0x5c, 0x2e, 0x75, 0x9d, 0x5c,\n-\t\t0xa9, 0x80, 0x3d, 0x6f, 0xd5, 0x46, 0xd3, 0xdb, 0x42, 0x6e, 0x55, 0x81, 0x88, 0x42, 0x0e, 0x45,\n-\t\t0xfe, 0x9e, 0xe4, 0x41, 0x79, 0xcf, 0x71, 0x0e, 0xed, 0x27, 0xa8, 0x20, 0x05, 0xe9, 0x7a, 0x42,\n-\t\t0x4f, 0x05, 0x10, 0x2e, 0x52, 0x5d, 0x8c, 0x3c, 0x40, 0x49, 0x4c,\n-\n-\t\t0x14, 0x03, 0x02, 0x00, 0x01, 0x01,\n-\n-\t\t0x16, 0x03, 0x02, 0x00, 0x24, 0x8b, 0x12, 0x24, 0x06, 0xaa, 0x92, 0x74, 0xa1, 0x46, 0x6f, 0xc1,\n-\t\t0x4e, 0x4a, 0xf7, 0x16, 0xdd, 0xd6, 0xe1, 0x2d, 0x37, 0x0b, 0x44, 0xba, 0xeb, 0xc4, 0x6c, 0xc7,\n-\t\t0xa0, 0xb7, 0x8c, 0x9d, 0x24, 0xbd, 0x99, 0x33, 0x1e,\n+\t\t0x16, 0x03, 0x01, 0x00, 0x86, 0x10, 0x00, 0x00,\n+\t\t0x82, 0x00, 0x80, 0x3c, 0x13, 0xd7, 0x12, 0xc1,\n+\t\t0x6a, 0xf0, 0x3f, 0x8c, 0xa1, 0x35, 0x5d, 0xc5,\n+\t\t0x89, 0x1e, 0x9e, 0xcd, 0x32, 0xc7, 0x9e, 0xe6,\n+\t\t0xae, 0xd5, 0xf1, 0xbf, 0x70, 0xd7, 0xa9, 0xef,\n+\t\t0x2c, 0x4c, 0xf4, 0x22, 0xbc, 0x17, 0x17, 0xaa,\n+\t\t0x05, 0xf3, 0x9f, 0x80, 0xf2, 0xe9, 0x82, 0x2f,\n+\t\t0x2a, 0x15, 0x54, 0x0d, 0x16, 0x0e, 0x77, 0x4c,\n+\t\t0x28, 0x3c, 0x03, 0x2d, 0x2d, 0xd7, 0xc8, 0x64,\n+\t\t0xd9, 0x59, 0x4b, 0x1c, 0xf4, 0xde, 0xff, 0x2f,\n+\t\t0xbc, 0x94, 0xaf, 0x18, 0x26, 0x37, 0xce, 0x4f,\n+\t\t0x84, 0x74, 0x2e, 0x45, 0x66, 0x7c, 0x0c, 0x54,\n+\t\t0x46, 0x36, 0x5f, 0x65, 0x21, 0x7b, 0x83, 0x8c,\n+\t\t0x6d, 0x76, 0xcd, 0x0d, 0x9f, 0xda, 0x1c, 0xa4,\n+\t\t0x6e, 0xfe, 0xb1, 0xf7, 0x09, 0x0d, 0xfb, 0x74,\n+\t\t0x66, 0x34, 0x99, 0x89, 0x7f, 0x5f, 0x77, 0x87,\n+\t\t0x4a, 0x66, 0x4b, 0xa9, 0x59, 0x57, 0xe3, 0x56,\n+\t\t0x0d, 0xdd, 0xd8, 0x14, 0x03, 0x01, 0x00, 0x01,\n+\t\t0x01, 0x16, 0x03, 0x01, 0x00, 0x24, 0xc0, 0x4e,\n+\t\t0xd3, 0x0f, 0xb5, 0xc0, 0x57, 0xa6, 0x18, 0x80,\n+\t\t0x80, 0x6b, 0x49, 0xfe, 0xbd, 0x3a, 0x7a, 0x2c,\n+\t\t0xef, 0x70, 0xb5, 0x1c, 0xd2, 0xdf, 0x5f, 0x78,\n+\t\t0x5a, 0xd8, 0x4f, 0xa0, 0x95, 0xb4, 0xb3, 0xb5,\n+\t\t0xaa, 0x3b,\n \t},\n \n \t{\n-\t\t0x14, 0x03, 0x02, 0x00, 0x01,\n-\t\t0x01,\n+\t\t0x14, 0x03, 0x01, 0x00, 0x01, 0x01, 0x16, 0x03,\n+\t\t0x01, 0x00, 0x24, 0x9d, 0xc9, 0xda, 0xdf, 0xeb,\n+\t\t0xc8, 0xdb, 0xf8, 0x94, 0xa5, 0xef, 0xd5, 0xfc,\n+\t\t0x89, 0x01, 0x64, 0x30, 0x77, 0x5a, 0x18, 0x4b,\n+\t\t0x16, 0x79, 0x9c, 0xf6, 0xf5, 0x09, 0x22, 0x12,\n+\t\t0x4c, 0x3e, 0xa8, 0x8e, 0x91, 0xa5, 0x24,\n+\t},\n+}\n \n-\t\t0x16, 0x03, 0x02, 0x00, 0x24,\n-\t\t0x6e, 0xd1, 0x3e, 0x49, 0x68, 0xc1, 0xa0, 0xa5, 0xb7, 0xaf, 0xb0, 0x7c, 0x52, 0x1f, 0xf7, 0x2d,\n-\t\t0x51, 0xf3, 0xa5, 0xb6, 0xf6, 0xd4, 0x18, 0x4b, 0x7a, 0xd5, 0x24, 0x1d, 0x09, 0xb6, 0x41, 0x1c,\n-\t\t0x1c, 0x98, 0xf6, 0x90,\n+var aesServerScript = [][]byte{\n+\t{\n+\t\t0x16, 0x03, 0x02, 0x00, 0x7f, 0x01, 0x00, 0x00,\n+\t\t0x7b, 0x03, 0x02, 0x4d, 0x08, 0x2d, 0x0b, 0xb3,\n+\t\t0x57, 0x85, 0x71, 0x4b, 0xfb, 0x34, 0xab, 0x16,\n+\t\t0xd4, 0x92, 0x50, 0x81, 0x16, 0x95, 0x11, 0x28,\n+\t\t0x1a, 0xcb, 0xff, 0x09, 0x4d, 0x23, 0xa6, 0xfe,\n+\t\t0x2e, 0xbb, 0x78, 0x00, 0x00, 0x34, 0x00, 0x33,\n+\t\t0x00, 0x45, 0x00, 0x39, 0x00, 0x88, 0x00, 0x16,\n+\t\t0x00, 0x32, 0x00, 0x44, 0x00, 0x38, 0x00, 0x87,\n+\t\t0x00, 0x13, 0x00, 0x66, 0x00, 0x90, 0x00, 0x91,\n+\t\t0x00, 0x8f, 0x00, 0x8e, 0x00, 0x2f, 0x00, 0x41,\n+\t\t0x00, 0x35, 0x00, 0x84, 0x00, 0x0a, 0x00, 0x05,\n+\t\t0x00, 0x04, 0x00, 0x8c, 0x00, 0x8d, 0x00, 0x8b,\n+\t\t0x00, 0x8a, 0x01, 0x00, 0x00, 0x1e, 0x00, 0x09,\n+\t\t0x00, 0x03, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00,\n+\t\t0x0e, 0x00, 0x0c, 0x00, 0x00, 0x09, 0x6c, 0x6f,\n+\t\t0x63, 0x61, 0x6c, 0x68, 0x6f, 0x73, 0x74, 0xff,\n+\t\t0x01, 0x00, 0x01, 0x00,\n+\t},\n \n-\t\t0x17, 0x03, 0x02, 0x00, 0x21,\n-\t\t0x50, 0xb7, 0x92, 0x4f, 0xd8, 0x78, 0x29, 0xa2, 0xe7, 0xa5, 0xa6, 0xbd, 0x1a, 0x0c, 0xf1, 0x5a,\n-\t\t0x6e, 0x6c, 0xeb, 0x38, 0x99, 0x9b, 0x3c, 0xfd, 0xee, 0x53, 0xe8, 0x4d, 0x7b, 0xa5, 0x5b, 0x00,\n+\t{\n+\t\t0x16, 0x03, 0x01, 0x00, 0x2a, 0x02, 0x00, 0x00,\n+\t\t0x26, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x2f, 0x00, 0x16,\n+\t\t0x03, 0x01, 0x02, 0xbe, 0x0b, 0x00, 0x02, 0xba,\n+\t\t0x00, 0x02, 0xb7, 0x00, 0x02, 0xb4, 0x30, 0x82,\n+\t\t0x02, 0xb0, 0x30, 0x82, 0x02, 0x19, 0xa0, 0x03,\n+\t\t0x02, 0x01, 0x02, 0x02, 0x09, 0x00, 0x85, 0xb0,\n+\t\t0xbb, 0xa4, 0x8a, 0x7f, 0xb8, 0xca, 0x30, 0x0d,\n+\t\t0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d,\n+\t\t0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x45, 0x31,\n+\t\t0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06,\n+\t\t0x13, 0x02, 0x41, 0x55, 0x31, 0x13, 0x30, 0x11,\n+\t\t0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x0a, 0x53,\n+\t\t0x6f, 0x6d, 0x65, 0x2d, 0x53, 0x74, 0x61, 0x74,\n+\t\t0x65, 0x31, 0x21, 0x30, 0x1f, 0x06, 0x03, 0x55,\n+\t\t0x04, 0x0a, 0x13, 0x18, 0x49, 0x6e, 0x74, 0x65,\n+\t\t0x72, 0x6e, 0x65, 0x74, 0x20, 0x57, 0x69, 0x64,\n+\t\t0x67, 0x69, 0x74, 0x73, 0x20, 0x50, 0x74, 0x79,\n+\t\t0x20, 0x4c, 0x74, 0x64, 0x30, 0x1e, 0x17, 0x0d,\n+\t\t0x31, 0x30, 0x30, 0x34, 0x32, 0x34, 0x30, 0x39,\n+\t\t0x30, 0x39, 0x33, 0x38, 0x5a, 0x17, 0x0d, 0x31,\n+\t\t0x31, 0x30, 0x34, 0x32, 0x34, 0x30, 0x39, 0x30,\n+\t\t0x39, 0x33, 0x38, 0x5a, 0x30, 0x45, 0x31, 0x0b,\n+\t\t0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13,\n+\t\t0x02, 0x41, 0x55, 0x31, 0x13, 0x30, 0x11, 0x06,\n+\t\t0x03, 0x55, 0x04, 0x08, 0x13, 0x0a, 0x53, 0x6f,\n+\t\t0x6d, 0x65, 0x2d, 0x53, 0x74, 0x61, 0x74, 0x65,\n+\t\t0x31, 0x21, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x04,\n+\t\t0x0a, 0x13, 0x18, 0x49, 0x6e, 0x74, 0x65, 0x72,\n+\t\t0x6e, 0x65, 0x74, 0x20, 0x57, 0x69, 0x64, 0x67,\n+\t\t0x69, 0x74, 0x73, 0x20, 0x50, 0x74, 0x79, 0x20,\n+\t\t0x4c, 0x74, 0x64, 0x30, 0x81, 0x9f, 0x30, 0x0d,\n+\t\t0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d,\n+\t\t0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x81, 0x8d,\n+\t\t0x00, 0x30, 0x81, 0x89, 0x02, 0x81, 0x81, 0x00,\n+\t\t0xbb, 0x79, 0xd6, 0xf5, 0x17, 0xb5, 0xe5, 0xbf,\n+\t\t0x46, 0x10, 0xd0, 0xdc, 0x69, 0xbe, 0xe6, 0x2b,\n+\t\t0x07, 0x43, 0x5a, 0xd0, 0x03, 0x2d, 0x8a, 0x7a,\n+\t\t0x43, 0x85, 0xb7, 0x14, 0x52, 0xe7, 0xa5, 0x65,\n+\t\t0x4c, 0x2c, 0x78, 0xb8, 0x23, 0x8c, 0xb5, 0xb4,\n+\t\t0x82, 0xe5, 0xde, 0x1f, 0x95, 0x3b, 0x7e, 0x62,\n+\t\t0xa5, 0x2c, 0xa5, 0x33, 0xd6, 0xfe, 0x12, 0x5c,\n+\t\t0x7a, 0x56, 0xfc, 0xf5, 0x06, 0xbf, 0xfa, 0x58,\n+\t\t0x7b, 0x26, 0x3f, 0xb5, 0xcd, 0x04, 0xd3, 0xd0,\n+\t\t0xc9, 0x21, 0x96, 0x4a, 0xc7, 0xf4, 0x54, 0x9f,\n+\t\t0x5a, 0xbf, 0xef, 0x42, 0x71, 0x00, 0xfe, 0x18,\n+\t\t0x99, 0x07, 0x7f, 0x7e, 0x88, 0x7d, 0x7d, 0xf1,\n+\t\t0x04, 0x39, 0xc4, 0xa2, 0x2e, 0xdb, 0x51, 0xc9,\n+\t\t0x7c, 0xe3, 0xc0, 0x4c, 0x3b, 0x32, 0x66, 0x01,\n+\t\t0xcf, 0xaf, 0xb1, 0x1d, 0xb8, 0x71, 0x9a, 0x1d,\n+\t\t0xdb, 0xdb, 0x89, 0x6b, 0xae, 0xda, 0x2d, 0x79,\n+\t\t0x02, 0x03, 0x01, 0x00, 0x01, 0xa3, 0x81, 0xa7,\n+\t\t0x30, 0x81, 0xa4, 0x30, 0x1d, 0x06, 0x03, 0x55,\n+\t\t0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14, 0xb1, 0xad,\n+\t\t0xe2, 0x85, 0x5a, 0xcf, 0xcb, 0x28, 0xdb, 0x69,\n+\t\t0xce, 0x23, 0x69, 0xde, 0xd3, 0x26, 0x8e, 0x18,\n+\t\t0x88, 0x39, 0x30, 0x75, 0x06, 0x03, 0x55, 0x1d,\n+\t\t0x23, 0x04, 0x6e, 0x30, 0x6c, 0x80, 0x14, 0xb1,\n+\t\t0xad, 0xe2, 0x85, 0x5a, 0xcf, 0xcb, 0x28, 0xdb,\n+\t\t0x69, 0xce, 0x23, 0x69, 0xde, 0xd3, 0x26, 0x8e,\n+\t\t0x18, 0x88, 0x39, 0xa1, 0x49, 0xa4, 0x47, 0x30,\n+\t\t0x45, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55,\n+\t\t0x04, 0x06, 0x13, 0x02, 0x41, 0x55, 0x31, 0x13,\n+\t\t0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13,\n+\t\t0x0a, 0x53, 0x6f, 0x6d, 0x65, 0x2d, 0x53, 0x74,\n+\t\t0x61, 0x74, 0x65, 0x31, 0x21, 0x30, 0x1f, 0x06,\n+\t\t0x03, 0x55, 0x04, 0x0a, 0x13, 0x18, 0x49, 0x6e,\n+\t\t0x74, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x20, 0x57,\n+\t\t0x69, 0x64, 0x67, 0x69, 0x74, 0x73, 0x20, 0x50,\n+\t\t0x74, 0x79, 0x20, 0x4c, 0x74, 0x64, 0x82, 0x09,\n+\t\t0x00, 0x85, 0xb0, 0xbb, 0xa4, 0x8a, 0x7f, 0xb8,\n+\t\t0xca, 0x30, 0x0c, 0x06, 0x03, 0x55, 0x1d, 0x13,\n+\t\t0x04, 0x05, 0x30, 0x03, 0x01, 0x01, 0xff, 0x30,\n+\t\t0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,\n+\t\t0x0d, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x81,\n+\t\t0x81, 0x00, 0x08, 0x6c, 0x45, 0x24, 0xc7, 0x6b,\n+\t\t0xb1, 0x59, 0xab, 0x0c, 0x52, 0xcc, 0xf2, 0xb0,\n+\t\t0x14, 0xd7, 0x87, 0x9d, 0x7a, 0x64, 0x75, 0xb5,\n+\t\t0x5a, 0x95, 0x66, 0xe4, 0xc5, 0x2b, 0x8e, 0xae,\n+\t\t0x12, 0x66, 0x1f, 0xeb, 0x4f, 0x38, 0xb3, 0x6e,\n+\t\t0x60, 0xd3, 0x92, 0xfd, 0xf7, 0x41, 0x08, 0xb5,\n+\t\t0x25, 0x13, 0xb1, 0x18, 0x7a, 0x24, 0xfb, 0x30,\n+\t\t0x1d, 0xba, 0xed, 0x98, 0xb9, 0x17, 0xec, 0xe7,\n+\t\t0xd7, 0x31, 0x59, 0xdb, 0x95, 0xd3, 0x1d, 0x78,\n+\t\t0xea, 0x50, 0x56, 0x5c, 0xd5, 0x82, 0x5a, 0x2d,\n+\t\t0x5a, 0x5f, 0x33, 0xc4, 0xb6, 0xd8, 0xc9, 0x75,\n+\t\t0x90, 0x96, 0x8c, 0x0f, 0x52, 0x98, 0xb5, 0xcd,\n+\t\t0x98, 0x1f, 0x89, 0x20, 0x5f, 0xf2, 0xa0, 0x1c,\n+\t\t0xa3, 0x1b, 0x96, 0x94, 0xdd, 0xa9, 0xfd, 0x57,\n+\t\t0xe9, 0x70, 0xe8, 0x26, 0x6d, 0x71, 0x99, 0x9b,\n+\t\t0x26, 0x6e, 0x38, 0x50, 0x29, 0x6c, 0x90, 0xa7,\n+\t\t0xbd, 0xd9, 0x16, 0x03, 0x01, 0x00, 0x04, 0x0e,\n+\t\t0x00, 0x00, 0x00,\n+\t},\n \n-\t\t0xb9,\n+\t{\n+\t\t0x16, 0x03, 0x01, 0x00, 0x86, 0x10, 0x00, 0x00,\n+\t\t0x82, 0x00, 0x80, 0x71, 0x9c, 0xe7, 0x23, 0xfc,\n+\t\t0xb9, 0x19, 0x29, 0x82, 0xbf, 0xef, 0x08, 0xf7,\n+\t\t0x99, 0x36, 0xc3, 0x4c, 0x6f, 0x05, 0xd2, 0x8b,\n+\t\t0x62, 0x2b, 0x19, 0x9b, 0x7f, 0xc0, 0xcc, 0x48,\n+\t\t0x30, 0x5f, 0xcd, 0xc3, 0x70, 0x55, 0x53, 0x73,\n+\t\t0xfa, 0x79, 0x74, 0xf3, 0xa3, 0x76, 0x9f, 0xa1,\n+\t\t0x7f, 0x98, 0xc2, 0xc0, 0xe3, 0xc5, 0xa0, 0x31,\n+\t\t0x2f, 0xa6, 0xe8, 0x1e, 0x61, 0x46, 0xb3, 0x9b,\n+\t\t0x4b, 0x16, 0xf1, 0x2d, 0xc7, 0x63, 0x7f, 0x79,\n+\t\t0x22, 0x30, 0xd1, 0xf2, 0xfc, 0x77, 0x98, 0x0a,\n+\t\t0x16, 0x11, 0x63, 0x71, 0x7f, 0x70, 0xef, 0x16,\n+\t\t0xbb, 0x39, 0x87, 0x34, 0xac, 0x49, 0xbd, 0x07,\n+\t\t0x67, 0xcb, 0x9c, 0xcc, 0xde, 0xef, 0xb1, 0xe0,\n+\t\t0xdb, 0x01, 0xb5, 0x35, 0xa9, 0xb3, 0x10, 0x0c,\n+\t\t0x4b, 0xee, 0xb3, 0x4e, 0xfd, 0xbe, 0x15, 0x27,\n+\t\t0xf0, 0x46, 0xb2, 0x38, 0xba, 0x5f, 0xcc, 0x89,\n+\t\t0xec, 0x29, 0x82, 0x14, 0x03, 0x01, 0x00, 0x01,\n+\t\t0x01, 0x16, 0x03, 0x01, 0x00, 0x30, 0x3c, 0xfb,\n+\t\t0xa4, 0x12, 0xcb, 0x00, 0xf9, 0x57, 0x7e, 0x9b,\n+\t\t0xc9, 0xdc, 0x0c, 0xba, 0x9a, 0x81, 0x62, 0xfb,\n+\t\t0x26, 0x13, 0x53, 0xfe, 0xaa, 0xcc, 0x82, 0xbb,\n+\t\t0xb6, 0x67, 0x7f, 0x39, 0xbe, 0x4d, 0xbb, 0xc0,\n+\t\t0x6c, 0x24, 0x31, 0x83, 0xa5, 0x50, 0x3a, 0x75,\n+\t\t0x32, 0x64, 0xb5, 0xdb, 0xbe, 0x0a,\n+\t},\n \n-\t\t0x15, 0x03, 0x02, 0x00, 0x16,\n-\t\t0xc7, 0xc9, 0x5a, 0x72, 0xfb, 0x02, 0xa5, 0x93, 0xdd, 0x69, 0xeb, 0x30, 0x68, 0x5e, 0xbc, 0xe0,\n-\t\t0x44, 0xb9, 0x59, 0x33, 0x68, 0xa9,\n+\t{\n+\t\t0x14, 0x03, 0x01, 0x00, 0x01, 0x01, 0x16, 0x03,\n+\t\t0x01, 0x00, 0x30, 0x43, 0x24, 0x42, 0x55, 0x08,\n+\t\t0xe4, 0xc2, 0x15, 0xc9, 0xdb, 0x71, 0x69, 0xee,\n+\t\t0x09, 0xc5, 0x1c, 0xfd, 0x46, 0x10, 0xa0, 0x68,\n+\t\t0x21, 0xf2, 0x48, 0xac, 0x6c, 0xc0, 0x2b, 0x62,\n+\t\t0x07, 0x8f, 0x48, 0x33, 0x0a, 0x6b, 0x62, 0x28,\n+\t\t0x2e, 0x2c, 0xad, 0xcb, 0x34, 0x85, 0xca, 0x2e,\n+\t\t0xcd, 0x84, 0xf0,\n \t},\n }"}, {"sha": "861c64f04bb36635074c9cce3f46e2ccc81797e5", "filename": "libgo/go/crypto/tls/key_agreement.go", "status": "added", "additions": 246, "deletions": 0, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Ftls%2Fkey_agreement.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Ftls%2Fkey_agreement.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fkey_agreement.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -0,0 +1,246 @@\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package tls\n+\n+import (\n+\t\"big\"\n+\t\"crypto/elliptic\"\n+\t\"crypto/md5\"\n+\t\"crypto/rsa\"\n+\t\"crypto/sha1\"\n+\t\"crypto/x509\"\n+\t\"io\"\n+\t\"os\"\n+)\n+\n+// rsaKeyAgreement implements the standard TLS key agreement where the client\n+// encrypts the pre-master secret to the server's public key.\n+type rsaKeyAgreement struct{}\n+\n+func (ka rsaKeyAgreement) generateServerKeyExchange(config *Config, clientHello *clientHelloMsg, hello *serverHelloMsg) (*serverKeyExchangeMsg, os.Error) {\n+\treturn nil, nil\n+}\n+\n+func (ka rsaKeyAgreement) processClientKeyExchange(config *Config, ckx *clientKeyExchangeMsg) ([]byte, os.Error) {\n+\tpreMasterSecret := make([]byte, 48)\n+\t_, err := io.ReadFull(config.rand(), preMasterSecret[2:])\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tif len(ckx.ciphertext) < 2 {\n+\t\treturn nil, os.ErrorString(\"bad ClientKeyExchange\")\n+\t}\n+\tciphertextLen := int(ckx.ciphertext[0])<<8 | int(ckx.ciphertext[1])\n+\tif ciphertextLen != len(ckx.ciphertext)-2 {\n+\t\treturn nil, os.ErrorString(\"bad ClientKeyExchange\")\n+\t}\n+\tciphertext := ckx.ciphertext[2:]\n+\n+\terr = rsa.DecryptPKCS1v15SessionKey(config.rand(), config.Certificates[0].PrivateKey, ciphertext, preMasterSecret)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\t// We don't check the version number in the premaster secret.  For one,\n+\t// by checking it, we would leak information about the validity of the\n+\t// encrypted pre-master secret. Secondly, it provides only a small\n+\t// benefit against a downgrade attack and some implementations send the\n+\t// wrong version anyway. See the discussion at the end of section\n+\t// 7.4.7.1 of RFC 4346.\n+\treturn preMasterSecret, nil\n+}\n+\n+func (ka rsaKeyAgreement) processServerKeyExchange(config *Config, clientHello *clientHelloMsg, serverHello *serverHelloMsg, cert *x509.Certificate, skx *serverKeyExchangeMsg) os.Error {\n+\treturn os.ErrorString(\"unexpected ServerKeyExchange\")\n+}\n+\n+func (ka rsaKeyAgreement) generateClientKeyExchange(config *Config, clientHello *clientHelloMsg, cert *x509.Certificate) ([]byte, *clientKeyExchangeMsg, os.Error) {\n+\tpreMasterSecret := make([]byte, 48)\n+\tpreMasterSecret[0] = byte(clientHello.vers >> 8)\n+\tpreMasterSecret[1] = byte(clientHello.vers)\n+\t_, err := io.ReadFull(config.rand(), preMasterSecret[2:])\n+\tif err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\n+\tencrypted, err := rsa.EncryptPKCS1v15(config.rand(), cert.PublicKey.(*rsa.PublicKey), preMasterSecret)\n+\tif err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\tckx := new(clientKeyExchangeMsg)\n+\tckx.ciphertext = make([]byte, len(encrypted)+2)\n+\tckx.ciphertext[0] = byte(len(encrypted) >> 8)\n+\tckx.ciphertext[1] = byte(len(encrypted))\n+\tcopy(ckx.ciphertext[2:], encrypted)\n+\treturn preMasterSecret, ckx, nil\n+}\n+\n+\n+// md5SHA1Hash implements TLS 1.0's hybrid hash function which consists of the\n+// concatenation of an MD5 and SHA1 hash.\n+func md5SHA1Hash(slices ...[]byte) []byte {\n+\tmd5sha1 := make([]byte, md5.Size+sha1.Size)\n+\thmd5 := md5.New()\n+\tfor _, slice := range slices {\n+\t\thmd5.Write(slice)\n+\t}\n+\tcopy(md5sha1, hmd5.Sum())\n+\n+\thsha1 := sha1.New()\n+\tfor _, slice := range slices {\n+\t\thsha1.Write(slice)\n+\t}\n+\tcopy(md5sha1[md5.Size:], hsha1.Sum())\n+\treturn md5sha1\n+}\n+\n+// ecdheRSAKeyAgreement implements a TLS key agreement where the server\n+// generates a ephemeral EC public/private key pair and signs it. The\n+// pre-master secret is then calculated using ECDH.\n+type ecdheRSAKeyAgreement struct {\n+\tprivateKey []byte\n+\tcurve      *elliptic.Curve\n+\tx, y       *big.Int\n+}\n+\n+func (ka *ecdheRSAKeyAgreement) generateServerKeyExchange(config *Config, clientHello *clientHelloMsg, hello *serverHelloMsg) (*serverKeyExchangeMsg, os.Error) {\n+\tvar curveid uint16\n+\n+Curve:\n+\tfor _, c := range clientHello.supportedCurves {\n+\t\tswitch c {\n+\t\tcase curveP256:\n+\t\t\tka.curve = elliptic.P256()\n+\t\t\tcurveid = c\n+\t\t\tbreak Curve\n+\t\tcase curveP384:\n+\t\t\tka.curve = elliptic.P384()\n+\t\t\tcurveid = c\n+\t\t\tbreak Curve\n+\t\tcase curveP521:\n+\t\t\tka.curve = elliptic.P521()\n+\t\t\tcurveid = c\n+\t\t\tbreak Curve\n+\t\t}\n+\t}\n+\n+\tvar x, y *big.Int\n+\tvar err os.Error\n+\tka.privateKey, x, y, err = ka.curve.GenerateKey(config.rand())\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tecdhePublic := ka.curve.Marshal(x, y)\n+\n+\t// http://tools.ietf.org/html/rfc4492#section-5.4\n+\tserverECDHParams := make([]byte, 1+2+1+len(ecdhePublic))\n+\tserverECDHParams[0] = 3 // named curve\n+\tserverECDHParams[1] = byte(curveid >> 8)\n+\tserverECDHParams[2] = byte(curveid)\n+\tserverECDHParams[3] = byte(len(ecdhePublic))\n+\tcopy(serverECDHParams[4:], ecdhePublic)\n+\n+\tmd5sha1 := md5SHA1Hash(clientHello.random, hello.random, serverECDHParams)\n+\tsig, err := rsa.SignPKCS1v15(config.rand(), config.Certificates[0].PrivateKey, rsa.HashMD5SHA1, md5sha1)\n+\tif err != nil {\n+\t\treturn nil, os.ErrorString(\"failed to sign ECDHE parameters: \" + err.String())\n+\t}\n+\n+\tskx := new(serverKeyExchangeMsg)\n+\tskx.key = make([]byte, len(serverECDHParams)+2+len(sig))\n+\tcopy(skx.key, serverECDHParams)\n+\tk := skx.key[len(serverECDHParams):]\n+\tk[0] = byte(len(sig) >> 8)\n+\tk[1] = byte(len(sig))\n+\tcopy(k[2:], sig)\n+\n+\treturn skx, nil\n+}\n+\n+func (ka *ecdheRSAKeyAgreement) processClientKeyExchange(config *Config, ckx *clientKeyExchangeMsg) ([]byte, os.Error) {\n+\tif len(ckx.ciphertext) == 0 || int(ckx.ciphertext[0]) != len(ckx.ciphertext)-1 {\n+\t\treturn nil, os.ErrorString(\"bad ClientKeyExchange\")\n+\t}\n+\tx, y := ka.curve.Unmarshal(ckx.ciphertext[1:])\n+\tif x == nil {\n+\t\treturn nil, os.ErrorString(\"bad ClientKeyExchange\")\n+\t}\n+\tx, _ = ka.curve.ScalarMult(x, y, ka.privateKey)\n+\tpreMasterSecret := make([]byte, (ka.curve.BitSize+7)>>3)\n+\txBytes := x.Bytes()\n+\tcopy(preMasterSecret[len(preMasterSecret)-len(xBytes):], xBytes)\n+\n+\treturn preMasterSecret, nil\n+}\n+\n+func (ka *ecdheRSAKeyAgreement) processServerKeyExchange(config *Config, clientHello *clientHelloMsg, serverHello *serverHelloMsg, cert *x509.Certificate, skx *serverKeyExchangeMsg) os.Error {\n+\tif len(skx.key) < 4 {\n+\t\tgoto Error\n+\t}\n+\tif skx.key[0] != 3 { // named curve\n+\t\treturn os.ErrorString(\"server selected unsupported curve\")\n+\t}\n+\tcurveid := uint16(skx.key[1])<<8 | uint16(skx.key[2])\n+\n+\tswitch curveid {\n+\tcase curveP256:\n+\t\tka.curve = elliptic.P256()\n+\tcase curveP384:\n+\t\tka.curve = elliptic.P384()\n+\tcase curveP521:\n+\t\tka.curve = elliptic.P521()\n+\tdefault:\n+\t\treturn os.ErrorString(\"server selected unsupported curve\")\n+\t}\n+\n+\tpublicLen := int(skx.key[3])\n+\tif publicLen+4 > len(skx.key) {\n+\t\tgoto Error\n+\t}\n+\tka.x, ka.y = ka.curve.Unmarshal(skx.key[4 : 4+publicLen])\n+\tif ka.x == nil {\n+\t\tgoto Error\n+\t}\n+\tserverECDHParams := skx.key[:4+publicLen]\n+\n+\tsig := skx.key[4+publicLen:]\n+\tif len(sig) < 2 {\n+\t\tgoto Error\n+\t}\n+\tsigLen := int(sig[0])<<8 | int(sig[1])\n+\tif sigLen+2 != len(sig) {\n+\t\tgoto Error\n+\t}\n+\tsig = sig[2:]\n+\n+\tmd5sha1 := md5SHA1Hash(clientHello.random, serverHello.random, serverECDHParams)\n+\treturn rsa.VerifyPKCS1v15(cert.PublicKey.(*rsa.PublicKey), rsa.HashMD5SHA1, md5sha1, sig)\n+\n+Error:\n+\treturn os.ErrorString(\"invalid ServerKeyExchange\")\n+}\n+\n+func (ka *ecdheRSAKeyAgreement) generateClientKeyExchange(config *Config, clientHello *clientHelloMsg, cert *x509.Certificate) ([]byte, *clientKeyExchangeMsg, os.Error) {\n+\tif ka.curve == nil {\n+\t\treturn nil, nil, os.ErrorString(\"missing ServerKeyExchange message\")\n+\t}\n+\tpriv, mx, my, err := ka.curve.GenerateKey(config.rand())\n+\tif err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\tx, _ := ka.curve.ScalarMult(ka.x, ka.y, priv)\n+\tpreMasterSecret := make([]byte, (ka.curve.BitSize+7)>>3)\n+\txBytes := x.Bytes()\n+\tcopy(preMasterSecret[len(preMasterSecret)-len(xBytes):], xBytes)\n+\n+\tserialised := ka.curve.Marshal(mx, my)\n+\n+\tckx := new(clientKeyExchangeMsg)\n+\tckx.ciphertext = make([]byte, 1+len(serialised))\n+\tckx.ciphertext[0] = byte(len(serialised))\n+\tcopy(ckx.ciphertext[1:], serialised)\n+\n+\treturn preMasterSecret, ckx, nil\n+}"}, {"sha": "478cf65f91c41f4795ae6f88febe89b7079d8cf8", "filename": "libgo/go/crypto/tls/prf.go", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Ftls%2Fprf.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Ftls%2Fprf.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fprf.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -44,8 +44,8 @@ func pHash(result, secret, seed []byte, hash func() hash.Hash) {\n \t}\n }\n \n-// pRF11 implements the TLS 1.1 pseudo-random function, as defined in RFC 4346, section 5.\n-func pRF11(result, secret, label, seed []byte) {\n+// pRF10 implements the TLS 1.0 pseudo-random function, as defined in RFC 2246, section 5.\n+func pRF10(result, secret, label, seed []byte) {\n \thashSHA1 := sha1.New\n \thashMD5 := md5.New\n \n@@ -75,25 +75,32 @@ var clientFinishedLabel = []byte(\"client finished\")\n var serverFinishedLabel = []byte(\"server finished\")\n \n // keysFromPreMasterSecret generates the connection keys from the pre master\n-// secret, given the lengths of the MAC and cipher keys, as defined in RFC\n-// 4346, section 6.3.\n-func keysFromPreMasterSecret11(preMasterSecret, clientRandom, serverRandom []byte, macLen, keyLen int) (masterSecret, clientMAC, serverMAC, clientKey, serverKey []byte) {\n+// secret, given the lengths of the MAC key, cipher key and IV, as defined in\n+// RFC 2246, section 6.3.\n+func keysFromPreMasterSecret10(preMasterSecret, clientRandom, serverRandom []byte, macLen, keyLen, ivLen int) (masterSecret, clientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV []byte) {\n \tvar seed [tlsRandomLength * 2]byte\n \tcopy(seed[0:len(clientRandom)], clientRandom)\n \tcopy(seed[len(clientRandom):], serverRandom)\n \tmasterSecret = make([]byte, masterSecretLength)\n-\tpRF11(masterSecret, preMasterSecret, masterSecretLabel, seed[0:])\n+\tpRF10(masterSecret, preMasterSecret, masterSecretLabel, seed[0:])\n \n \tcopy(seed[0:len(clientRandom)], serverRandom)\n \tcopy(seed[len(serverRandom):], clientRandom)\n \n-\tn := 2*macLen + 2*keyLen\n+\tn := 2*macLen + 2*keyLen + 2*ivLen\n \tkeyMaterial := make([]byte, n)\n-\tpRF11(keyMaterial, masterSecret, keyExpansionLabel, seed[0:])\n-\tclientMAC = keyMaterial[0:macLen]\n-\tserverMAC = keyMaterial[macLen : macLen*2]\n-\tclientKey = keyMaterial[macLen*2 : macLen*2+keyLen]\n-\tserverKey = keyMaterial[macLen*2+keyLen:]\n+\tpRF10(keyMaterial, masterSecret, keyExpansionLabel, seed[0:])\n+\tclientMAC = keyMaterial[:macLen]\n+\tkeyMaterial = keyMaterial[macLen:]\n+\tserverMAC = keyMaterial[:macLen]\n+\tkeyMaterial = keyMaterial[macLen:]\n+\tclientKey = keyMaterial[:keyLen]\n+\tkeyMaterial = keyMaterial[keyLen:]\n+\tserverKey = keyMaterial[:keyLen]\n+\tkeyMaterial = keyMaterial[keyLen:]\n+\tclientIV = keyMaterial[:ivLen]\n+\tkeyMaterial = keyMaterial[ivLen:]\n+\tserverIV = keyMaterial[:ivLen]\n \treturn\n }\n \n@@ -125,7 +132,7 @@ func finishedSum(md5, sha1, label, masterSecret []byte) []byte {\n \tcopy(seed, md5)\n \tcopy(seed[len(md5):], sha1)\n \tout := make([]byte, finishedVerifyLength)\n-\tpRF11(out, masterSecret, label, seed)\n+\tpRF10(out, masterSecret, label, seed)\n \treturn out\n }\n "}, {"sha": "f8c4acb9d28b309ea2596bd14f87aa35f098c799", "filename": "libgo/go/crypto/tls/prf_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Ftls%2Fprf_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Ftls%2Fprf_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fprf_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -47,7 +47,7 @@ func TestKeysFromPreMasterSecret(t *testing.T) {\n \t\tin, _ := hex.DecodeString(test.preMasterSecret)\n \t\tclientRandom, _ := hex.DecodeString(test.clientRandom)\n \t\tserverRandom, _ := hex.DecodeString(test.serverRandom)\n-\t\tmaster, clientMAC, serverMAC, clientKey, serverKey := keysFromPreMasterSecret11(in, clientRandom, serverRandom, test.macLen, test.keyLen)\n+\t\tmaster, clientMAC, serverMAC, clientKey, serverKey, _, _ := keysFromPreMasterSecret10(in, clientRandom, serverRandom, test.macLen, test.keyLen, 0)\n \t\tmasterString := hex.EncodeToString(master)\n \t\tclientMACString := hex.EncodeToString(clientMAC)\n \t\tserverMACString := hex.EncodeToString(serverMAC)"}, {"sha": "b11d3225daa6eb7add50aa6deee219d36a8b6614", "filename": "libgo/go/crypto/tls/tls.go", "status": "modified", "additions": 39, "deletions": 9, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -15,19 +15,31 @@ import (\n \t\"strings\"\n )\n \n+// Server returns a new TLS server side connection\n+// using conn as the underlying transport.\n+// The configuration config must be non-nil and must have\n+// at least one certificate.\n func Server(conn net.Conn, config *Config) *Conn {\n \treturn &Conn{conn: conn, config: config}\n }\n \n+// Client returns a new TLS client side connection\n+// using conn as the underlying transport.\n+// Client interprets a nil configuration as equivalent to\n+// the zero configuration; see the documentation of Config\n+// for the defaults.\n func Client(conn net.Conn, config *Config) *Conn {\n \treturn &Conn{conn: conn, config: config, isClient: true}\n }\n \n+// A Listener implements a network listener (net.Listener) for TLS connections.\n type Listener struct {\n \tlistener net.Listener\n \tconfig   *Config\n }\n \n+// Accept waits for and returns the next incoming TLS connection.\n+// The returned connection c is a *tls.Conn.\n func (l *Listener) Accept() (c net.Conn, err os.Error) {\n \tc, err = l.listener.Accept()\n \tif err != nil {\n@@ -37,8 +49,10 @@ func (l *Listener) Accept() (c net.Conn, err os.Error) {\n \treturn\n }\n \n+// Close closes the listener.\n func (l *Listener) Close() os.Error { return l.listener.Close() }\n \n+// Addr returns the listener's network address.\n func (l *Listener) Addr() net.Addr { return l.listener.Addr() }\n \n // NewListener creates a Listener which accepts connections from an inner\n@@ -52,7 +66,11 @@ func NewListener(listener net.Listener, config *Config) (l *Listener) {\n \treturn\n }\n \n-func Listen(network, laddr string, config *Config) (net.Listener, os.Error) {\n+// Listen creates a TLS listener accepting connections on the\n+// given network address using net.Listen.\n+// The configuration config must be non-nil and must have\n+// at least one certificate.\n+func Listen(network, laddr string, config *Config) (*Listener, os.Error) {\n \tif config == nil || len(config.Certificates) == 0 {\n \t\treturn nil, os.NewError(\"tls.Listen: no certificates in configuration\")\n \t}\n@@ -63,7 +81,13 @@ func Listen(network, laddr string, config *Config) (net.Listener, os.Error) {\n \treturn NewListener(l, config), nil\n }\n \n-func Dial(network, laddr, raddr string) (net.Conn, os.Error) {\n+// Dial connects to the given network address using net.Dial\n+// and then initiates a TLS handshake, returning the resulting\n+// TLS connection.\n+// Dial interprets a nil configuration as equivalent to\n+// the zero configuration; see the documentation of Config\n+// for the defaults.\n+func Dial(network, laddr, raddr string, config *Config) (*Conn, os.Error) {\n \tc, err := net.Dial(network, laddr, raddr)\n \tif err != nil {\n \t\treturn nil, err\n@@ -75,15 +99,21 @@ func Dial(network, laddr, raddr string) (net.Conn, os.Error) {\n \t}\n \thostname := raddr[:colonPos]\n \n-\tconfig := defaultConfig()\n-\tconfig.ServerName = hostname\n+\tif config == nil {\n+\t\tconfig = defaultConfig()\n+\t}\n+\tif config.ServerName != \"\" {\n+\t\t// Make a copy to avoid polluting argument or default.\n+\t\tc := *config\n+\t\tc.ServerName = hostname\n+\t\tconfig = &c\n+\t}\n \tconn := Client(c, config)\n-\terr = conn.Handshake()\n-\tif err == nil {\n-\t\treturn conn, nil\n+\tif err = conn.Handshake(); err != nil {\n+\t\tc.Close()\n+\t\treturn nil, err\n \t}\n-\tc.Close()\n-\treturn nil, err\n+\treturn conn, nil\n }\n \n // LoadX509KeyPair reads and parses a public/private key pair from a pair of"}, {"sha": "62253e79788132fdfe40dfbb6ebcad974cb6d8a7", "filename": "libgo/go/crypto/twofish/twofish.go", "status": "added", "additions": 358, "deletions": 0, "changes": 358, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Ftwofish%2Ftwofish.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Ftwofish%2Ftwofish.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftwofish%2Ftwofish.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -0,0 +1,358 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// This package implements Bruce Schneier's Twofish encryption algorithm.\n+package twofish\n+\n+// Twofish is defined in http://www.schneier.com/paper-twofish-paper.pdf [TWOFISH]\n+\n+// This code is a port of the LibTom C implementation.\n+// See http://libtom.org/?page=features&newsitems=5&whatfile=crypt.\n+// LibTomCrypt is free for all purposes under the public domain.\n+// It was heavily inspired by the go blowfish package.\n+\n+import (\n+\t\"os\"\n+\t\"strconv\"\n+)\n+\n+// BlockSize is the constant block size of Twofish.\n+const BlockSize = 16\n+\n+const mdsPolynomial = 0x169 // x^8 + x^6 + x^5 + x^3 + 1, see [TWOFISH] 4.2\n+const rsPolynomial = 0x14d  // x^8 + x^6 + x^3 + x^2 + 1, see [TWOFISH] 4.3\n+\n+// A Cipher is an instance of Twofish encryption using a particular key.\n+type Cipher struct {\n+\ts [4][256]uint32\n+\tk [40]uint32\n+}\n+\n+type KeySizeError int\n+\n+func (k KeySizeError) String() string {\n+\treturn \"crypto/twofish: invalid key size \" + strconv.Itoa(int(k))\n+}\n+\n+// NewCipher creates and returns a Cipher.\n+// The key argument should be the Twofish key, 16, 24 or 32 bytes.\n+func NewCipher(key []byte) (*Cipher, os.Error) {\n+\tkeylen := len(key)\n+\n+\tif keylen != 16 && keylen != 24 && keylen != 32 {\n+\t\treturn nil, KeySizeError(keylen)\n+\t}\n+\n+\t// k is the number of 64 bit words in key\n+\tk := keylen / 8\n+\n+\t// Create the S[..] words\n+\tvar S [4 * 4]byte\n+\tfor i := 0; i < k; i++ {\n+\t\t// Computes [y0 y1 y2 y3] = rs . [x0 x1 x2 x3 x4 x5 x6 x7]\n+\t\tfor j, rsRow := range rs {\n+\t\t\tfor k, rsVal := range rsRow {\n+\t\t\t\tS[4*i+j] ^= gfMult(key[8*i+k], rsVal, rsPolynomial)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// Calculate subkeys\n+\tc := new(Cipher)\n+\tvar tmp [4]byte\n+\tfor i := byte(0); i < 20; i++ {\n+\t\t// A = h(p * 2x, Me)\n+\t\tfor j := range tmp {\n+\t\t\ttmp[j] = 2 * i\n+\t\t}\n+\t\tA := h(tmp[:], key, 0)\n+\n+\t\t// B = rolc(h(p * (2x + 1), Mo), 8)\n+\t\tfor j := range tmp {\n+\t\t\ttmp[j] = 2*i + 1\n+\t\t}\n+\t\tB := h(tmp[:], key, 1)\n+\t\tB = rol(B, 8)\n+\n+\t\tc.k[2*i] = A + B\n+\n+\t\t// K[2i+1] = (A + 2B) <<< 9\n+\t\tc.k[2*i+1] = rol(2*B+A, 9)\n+\t}\n+\n+\t// Calculate sboxes\n+\tswitch k {\n+\tcase 2:\n+\t\tfor i := range c.s[0] {\n+\t\t\tc.s[0][i] = mdsColumnMult(sbox[1][sbox[0][sbox[0][byte(i)]^S[0]]^S[4]], 0)\n+\t\t\tc.s[1][i] = mdsColumnMult(sbox[0][sbox[0][sbox[1][byte(i)]^S[1]]^S[5]], 1)\n+\t\t\tc.s[2][i] = mdsColumnMult(sbox[1][sbox[1][sbox[0][byte(i)]^S[2]]^S[6]], 2)\n+\t\t\tc.s[3][i] = mdsColumnMult(sbox[0][sbox[1][sbox[1][byte(i)]^S[3]]^S[7]], 3)\n+\t\t}\n+\tcase 3:\n+\t\tfor i := range c.s[0] {\n+\t\t\tc.s[0][i] = mdsColumnMult(sbox[1][sbox[0][sbox[0][sbox[1][byte(i)]^S[0]]^S[4]]^S[8]], 0)\n+\t\t\tc.s[1][i] = mdsColumnMult(sbox[0][sbox[0][sbox[1][sbox[1][byte(i)]^S[1]]^S[5]]^S[9]], 1)\n+\t\t\tc.s[2][i] = mdsColumnMult(sbox[1][sbox[1][sbox[0][sbox[0][byte(i)]^S[2]]^S[6]]^S[10]], 2)\n+\t\t\tc.s[3][i] = mdsColumnMult(sbox[0][sbox[1][sbox[1][sbox[0][byte(i)]^S[3]]^S[7]]^S[11]], 3)\n+\t\t}\n+\tdefault:\n+\t\tfor i := range c.s[0] {\n+\t\t\tc.s[0][i] = mdsColumnMult(sbox[1][sbox[0][sbox[0][sbox[1][sbox[1][byte(i)]^S[0]]^S[4]]^S[8]]^S[12]], 0)\n+\t\t\tc.s[1][i] = mdsColumnMult(sbox[0][sbox[0][sbox[1][sbox[1][sbox[0][byte(i)]^S[1]]^S[5]]^S[9]]^S[13]], 1)\n+\t\t\tc.s[2][i] = mdsColumnMult(sbox[1][sbox[1][sbox[0][sbox[0][sbox[0][byte(i)]^S[2]]^S[6]]^S[10]]^S[14]], 2)\n+\t\t\tc.s[3][i] = mdsColumnMult(sbox[0][sbox[1][sbox[1][sbox[0][sbox[1][byte(i)]^S[3]]^S[7]]^S[11]]^S[15]], 3)\n+\t\t}\n+\t}\n+\n+\treturn c, nil\n+}\n+\n+// Reset zeros the key data, so that it will no longer appear in the process's\n+// memory.\n+func (c *Cipher) Reset() {\n+\tfor i := range c.k {\n+\t\tc.k[i] = 0\n+\t}\n+\tfor i := range c.s {\n+\t\tfor j := 0; j < 265; j++ {\n+\t\t\tc.s[i][j] = 0\n+\t\t}\n+\t}\n+}\n+\n+// BlockSize returns the Twofish block size, 16 bytes.\n+func (c *Cipher) BlockSize() int { return BlockSize }\n+\n+// store32l stores src in dst in little-endian form.\n+func store32l(dst []byte, src uint32) {\n+\tdst[0] = byte(src)\n+\tdst[1] = byte(src >> 8)\n+\tdst[2] = byte(src >> 16)\n+\tdst[3] = byte(src >> 24)\n+\treturn\n+}\n+\n+// load32l reads a little-endian uint32 from src.\n+func load32l(src []byte) uint32 {\n+\treturn uint32(src[0]) | uint32(src[1])<<8 | uint32(src[2])<<16 | uint32(src[3])<<24\n+}\n+\n+// rol returns x after a left circular rotation of y bits.\n+func rol(x, y uint32) uint32 {\n+\treturn (x << (y & 31)) | (x >> (32 - (y & 31)))\n+}\n+\n+// ror returns x after a right circular rotation of y bits.\n+func ror(x, y uint32) uint32 {\n+\treturn (x >> (y & 31)) | (x << (32 - (y & 31)))\n+}\n+\n+// The RS matrix. See [TWOFISH] 4.3\n+var rs = [4][8]byte{\n+\t{0x01, 0xA4, 0x55, 0x87, 0x5A, 0x58, 0xDB, 0x9E},\n+\t{0xA4, 0x56, 0x82, 0xF3, 0x1E, 0xC6, 0x68, 0xE5},\n+\t{0x02, 0xA1, 0xFC, 0xC1, 0x47, 0xAE, 0x3D, 0x19},\n+\t{0xA4, 0x55, 0x87, 0x5A, 0x58, 0xDB, 0x9E, 0x03},\n+}\n+\n+// sbox tables\n+var sbox = [2][256]byte{\n+\t{\n+\t\t0xa9, 0x67, 0xb3, 0xe8, 0x04, 0xfd, 0xa3, 0x76, 0x9a, 0x92, 0x80, 0x78, 0xe4, 0xdd, 0xd1, 0x38,\n+\t\t0x0d, 0xc6, 0x35, 0x98, 0x18, 0xf7, 0xec, 0x6c, 0x43, 0x75, 0x37, 0x26, 0xfa, 0x13, 0x94, 0x48,\n+\t\t0xf2, 0xd0, 0x8b, 0x30, 0x84, 0x54, 0xdf, 0x23, 0x19, 0x5b, 0x3d, 0x59, 0xf3, 0xae, 0xa2, 0x82,\n+\t\t0x63, 0x01, 0x83, 0x2e, 0xd9, 0x51, 0x9b, 0x7c, 0xa6, 0xeb, 0xa5, 0xbe, 0x16, 0x0c, 0xe3, 0x61,\n+\t\t0xc0, 0x8c, 0x3a, 0xf5, 0x73, 0x2c, 0x25, 0x0b, 0xbb, 0x4e, 0x89, 0x6b, 0x53, 0x6a, 0xb4, 0xf1,\n+\t\t0xe1, 0xe6, 0xbd, 0x45, 0xe2, 0xf4, 0xb6, 0x66, 0xcc, 0x95, 0x03, 0x56, 0xd4, 0x1c, 0x1e, 0xd7,\n+\t\t0xfb, 0xc3, 0x8e, 0xb5, 0xe9, 0xcf, 0xbf, 0xba, 0xea, 0x77, 0x39, 0xaf, 0x33, 0xc9, 0x62, 0x71,\n+\t\t0x81, 0x79, 0x09, 0xad, 0x24, 0xcd, 0xf9, 0xd8, 0xe5, 0xc5, 0xb9, 0x4d, 0x44, 0x08, 0x86, 0xe7,\n+\t\t0xa1, 0x1d, 0xaa, 0xed, 0x06, 0x70, 0xb2, 0xd2, 0x41, 0x7b, 0xa0, 0x11, 0x31, 0xc2, 0x27, 0x90,\n+\t\t0x20, 0xf6, 0x60, 0xff, 0x96, 0x5c, 0xb1, 0xab, 0x9e, 0x9c, 0x52, 0x1b, 0x5f, 0x93, 0x0a, 0xef,\n+\t\t0x91, 0x85, 0x49, 0xee, 0x2d, 0x4f, 0x8f, 0x3b, 0x47, 0x87, 0x6d, 0x46, 0xd6, 0x3e, 0x69, 0x64,\n+\t\t0x2a, 0xce, 0xcb, 0x2f, 0xfc, 0x97, 0x05, 0x7a, 0xac, 0x7f, 0xd5, 0x1a, 0x4b, 0x0e, 0xa7, 0x5a,\n+\t\t0x28, 0x14, 0x3f, 0x29, 0x88, 0x3c, 0x4c, 0x02, 0xb8, 0xda, 0xb0, 0x17, 0x55, 0x1f, 0x8a, 0x7d,\n+\t\t0x57, 0xc7, 0x8d, 0x74, 0xb7, 0xc4, 0x9f, 0x72, 0x7e, 0x15, 0x22, 0x12, 0x58, 0x07, 0x99, 0x34,\n+\t\t0x6e, 0x50, 0xde, 0x68, 0x65, 0xbc, 0xdb, 0xf8, 0xc8, 0xa8, 0x2b, 0x40, 0xdc, 0xfe, 0x32, 0xa4,\n+\t\t0xca, 0x10, 0x21, 0xf0, 0xd3, 0x5d, 0x0f, 0x00, 0x6f, 0x9d, 0x36, 0x42, 0x4a, 0x5e, 0xc1, 0xe0,\n+\t},\n+\t{\n+\t\t0x75, 0xf3, 0xc6, 0xf4, 0xdb, 0x7b, 0xfb, 0xc8, 0x4a, 0xd3, 0xe6, 0x6b, 0x45, 0x7d, 0xe8, 0x4b,\n+\t\t0xd6, 0x32, 0xd8, 0xfd, 0x37, 0x71, 0xf1, 0xe1, 0x30, 0x0f, 0xf8, 0x1b, 0x87, 0xfa, 0x06, 0x3f,\n+\t\t0x5e, 0xba, 0xae, 0x5b, 0x8a, 0x00, 0xbc, 0x9d, 0x6d, 0xc1, 0xb1, 0x0e, 0x80, 0x5d, 0xd2, 0xd5,\n+\t\t0xa0, 0x84, 0x07, 0x14, 0xb5, 0x90, 0x2c, 0xa3, 0xb2, 0x73, 0x4c, 0x54, 0x92, 0x74, 0x36, 0x51,\n+\t\t0x38, 0xb0, 0xbd, 0x5a, 0xfc, 0x60, 0x62, 0x96, 0x6c, 0x42, 0xf7, 0x10, 0x7c, 0x28, 0x27, 0x8c,\n+\t\t0x13, 0x95, 0x9c, 0xc7, 0x24, 0x46, 0x3b, 0x70, 0xca, 0xe3, 0x85, 0xcb, 0x11, 0xd0, 0x93, 0xb8,\n+\t\t0xa6, 0x83, 0x20, 0xff, 0x9f, 0x77, 0xc3, 0xcc, 0x03, 0x6f, 0x08, 0xbf, 0x40, 0xe7, 0x2b, 0xe2,\n+\t\t0x79, 0x0c, 0xaa, 0x82, 0x41, 0x3a, 0xea, 0xb9, 0xe4, 0x9a, 0xa4, 0x97, 0x7e, 0xda, 0x7a, 0x17,\n+\t\t0x66, 0x94, 0xa1, 0x1d, 0x3d, 0xf0, 0xde, 0xb3, 0x0b, 0x72, 0xa7, 0x1c, 0xef, 0xd1, 0x53, 0x3e,\n+\t\t0x8f, 0x33, 0x26, 0x5f, 0xec, 0x76, 0x2a, 0x49, 0x81, 0x88, 0xee, 0x21, 0xc4, 0x1a, 0xeb, 0xd9,\n+\t\t0xc5, 0x39, 0x99, 0xcd, 0xad, 0x31, 0x8b, 0x01, 0x18, 0x23, 0xdd, 0x1f, 0x4e, 0x2d, 0xf9, 0x48,\n+\t\t0x4f, 0xf2, 0x65, 0x8e, 0x78, 0x5c, 0x58, 0x19, 0x8d, 0xe5, 0x98, 0x57, 0x67, 0x7f, 0x05, 0x64,\n+\t\t0xaf, 0x63, 0xb6, 0xfe, 0xf5, 0xb7, 0x3c, 0xa5, 0xce, 0xe9, 0x68, 0x44, 0xe0, 0x4d, 0x43, 0x69,\n+\t\t0x29, 0x2e, 0xac, 0x15, 0x59, 0xa8, 0x0a, 0x9e, 0x6e, 0x47, 0xdf, 0x34, 0x35, 0x6a, 0xcf, 0xdc,\n+\t\t0x22, 0xc9, 0xc0, 0x9b, 0x89, 0xd4, 0xed, 0xab, 0x12, 0xa2, 0x0d, 0x52, 0xbb, 0x02, 0x2f, 0xa9,\n+\t\t0xd7, 0x61, 0x1e, 0xb4, 0x50, 0x04, 0xf6, 0xc2, 0x16, 0x25, 0x86, 0x56, 0x55, 0x09, 0xbe, 0x91,\n+\t},\n+}\n+\n+// gfMult returns a\u00b7b in GF(2^8)/p\n+func gfMult(a, b byte, p uint32) byte {\n+\tB := [2]uint32{0, uint32(b)}\n+\tP := [2]uint32{0, p}\n+\tvar result uint32\n+\n+\t// branchless GF multiplier\n+\tfor i := 0; i < 7; i++ {\n+\t\tresult ^= B[a&1]\n+\t\ta >>= 1\n+\t\tB[1] = P[B[1]>>7] ^ (B[1] << 1)\n+\t}\n+\tresult ^= B[a&1]\n+\treturn byte(result)\n+}\n+\n+// mdsColumnMult calculates y{col} where [y0 y1 y2 y3] = MDS \u00b7 [x0]\n+func mdsColumnMult(in byte, col int) uint32 {\n+\tmul01 := in\n+\tmul5B := gfMult(in, 0x5B, mdsPolynomial)\n+\tmulEF := gfMult(in, 0xEF, mdsPolynomial)\n+\n+\tswitch col {\n+\tcase 0:\n+\t\treturn uint32(mul01) | uint32(mul5B)<<8 | uint32(mulEF)<<16 | uint32(mulEF)<<24\n+\tcase 1:\n+\t\treturn uint32(mulEF) | uint32(mulEF)<<8 | uint32(mul5B)<<16 | uint32(mul01)<<24\n+\tcase 2:\n+\t\treturn uint32(mul5B) | uint32(mulEF)<<8 | uint32(mul01)<<16 | uint32(mulEF)<<24\n+\tcase 3:\n+\t\treturn uint32(mul5B) | uint32(mul01)<<8 | uint32(mulEF)<<16 | uint32(mul5B)<<24\n+\t}\n+\n+\tpanic(\"unreachable\")\n+}\n+\n+// h implements the S-box generation function. See [TWOFISH] 4.3.5\n+func h(in, key []byte, offset int) uint32 {\n+\tvar y [4]byte\n+\tfor x := range y {\n+\t\ty[x] = in[x]\n+\t}\n+\tswitch len(key) / 8 {\n+\tcase 4:\n+\t\ty[0] = sbox[1][y[0]] ^ key[4*(6+offset)+0]\n+\t\ty[1] = sbox[0][y[1]] ^ key[4*(6+offset)+1]\n+\t\ty[2] = sbox[0][y[2]] ^ key[4*(6+offset)+2]\n+\t\ty[3] = sbox[1][y[3]] ^ key[4*(6+offset)+3]\n+\t\tfallthrough\n+\tcase 3:\n+\t\ty[0] = sbox[1][y[0]] ^ key[4*(4+offset)+0]\n+\t\ty[1] = sbox[1][y[1]] ^ key[4*(4+offset)+1]\n+\t\ty[2] = sbox[0][y[2]] ^ key[4*(4+offset)+2]\n+\t\ty[3] = sbox[0][y[3]] ^ key[4*(4+offset)+3]\n+\t\tfallthrough\n+\tcase 2:\n+\t\ty[0] = sbox[1][sbox[0][sbox[0][y[0]]^key[4*(2+offset)+0]]^key[4*(0+offset)+0]]\n+\t\ty[1] = sbox[0][sbox[0][sbox[1][y[1]]^key[4*(2+offset)+1]]^key[4*(0+offset)+1]]\n+\t\ty[2] = sbox[1][sbox[1][sbox[0][y[2]]^key[4*(2+offset)+2]]^key[4*(0+offset)+2]]\n+\t\ty[3] = sbox[0][sbox[1][sbox[1][y[3]]^key[4*(2+offset)+3]]^key[4*(0+offset)+3]]\n+\t}\n+\t// [y0 y1 y2 y3] = MDS . [x0 x1 x2 x3]\n+\tvar mdsMult uint32\n+\tfor i := range y {\n+\t\tmdsMult ^= mdsColumnMult(y[i], i)\n+\t}\n+\treturn mdsMult\n+}\n+\n+// Encrypt encrypts a 16-byte block from src to dst, which may overlap.\n+// Note that for amounts of data larger than a block,\n+// it is not safe to just call Encrypt on successive blocks;\n+// instead, use an encryption mode like CBC (see crypto/block/cbc.go).\n+func (c *Cipher) Encrypt(dst, src []byte) {\n+\tS1 := c.s[0]\n+\tS2 := c.s[1]\n+\tS3 := c.s[2]\n+\tS4 := c.s[3]\n+\n+\t// Load input\n+\tia := load32l(src[0:4])\n+\tib := load32l(src[4:8])\n+\tic := load32l(src[8:12])\n+\tid := load32l(src[12:16])\n+\n+\t// Pre-whitening\n+\tia ^= c.k[0]\n+\tib ^= c.k[1]\n+\tic ^= c.k[2]\n+\tid ^= c.k[3]\n+\n+\tfor i := 0; i < 8; i++ {\n+\t\tk := c.k[8+i*4 : 12+i*4]\n+\t\tt2 := S2[byte(ib)] ^ S3[byte(ib>>8)] ^ S4[byte(ib>>16)] ^ S1[byte(ib>>24)]\n+\t\tt1 := S1[byte(ia)] ^ S2[byte(ia>>8)] ^ S3[byte(ia>>16)] ^ S4[byte(ia>>24)] + t2\n+\t\tic = ror(ic^(t1+k[0]), 1)\n+\t\tid = rol(id, 1) ^ (t2 + t1 + k[1])\n+\n+\t\tt2 = S2[byte(id)] ^ S3[byte(id>>8)] ^ S4[byte(id>>16)] ^ S1[byte(id>>24)]\n+\t\tt1 = S1[byte(ic)] ^ S2[byte(ic>>8)] ^ S3[byte(ic>>16)] ^ S4[byte(ic>>24)] + t2\n+\t\tia = ror(ia^(t1+k[2]), 1)\n+\t\tib = rol(ib, 1) ^ (t2 + t1 + k[3])\n+\t}\n+\n+\t// Output with \"undo last swap\"\n+\tta := ic ^ c.k[4]\n+\ttb := id ^ c.k[5]\n+\ttc := ia ^ c.k[6]\n+\ttd := ib ^ c.k[7]\n+\n+\tstore32l(dst[0:4], ta)\n+\tstore32l(dst[4:8], tb)\n+\tstore32l(dst[8:12], tc)\n+\tstore32l(dst[12:16], td)\n+}\n+\n+// Decrypt decrypts a 16-byte block from src to dst, which may overlap.\n+func (c *Cipher) Decrypt(dst, src []byte) {\n+\tS1 := c.s[0]\n+\tS2 := c.s[1]\n+\tS3 := c.s[2]\n+\tS4 := c.s[3]\n+\n+\t// Load input\n+\tta := load32l(src[0:4])\n+\ttb := load32l(src[4:8])\n+\ttc := load32l(src[8:12])\n+\ttd := load32l(src[12:16])\n+\n+\t// Undo undo final swap\n+\tia := tc ^ c.k[6]\n+\tib := td ^ c.k[7]\n+\tic := ta ^ c.k[4]\n+\tid := tb ^ c.k[5]\n+\n+\tfor i := 8; i > 0; i-- {\n+\t\tk := c.k[4+i*4 : 8+i*4]\n+\t\tt2 := S2[byte(id)] ^ S3[byte(id>>8)] ^ S4[byte(id>>16)] ^ S1[byte(id>>24)]\n+\t\tt1 := S1[byte(ic)] ^ S2[byte(ic>>8)] ^ S3[byte(ic>>16)] ^ S4[byte(ic>>24)] + t2\n+\t\tia = rol(ia, 1) ^ (t1 + k[2])\n+\t\tib = ror(ib^(t2+t1+k[3]), 1)\n+\n+\t\tt2 = S2[byte(ib)] ^ S3[byte(ib>>8)] ^ S4[byte(ib>>16)] ^ S1[byte(ib>>24)]\n+\t\tt1 = S1[byte(ia)] ^ S2[byte(ia>>8)] ^ S3[byte(ia>>16)] ^ S4[byte(ia>>24)] + t2\n+\t\tic = rol(ic, 1) ^ (t1 + k[0])\n+\t\tid = ror(id^(t2+t1+k[1]), 1)\n+\t}\n+\n+\t// Undo pre-whitening\n+\tia ^= c.k[0]\n+\tib ^= c.k[1]\n+\tic ^= c.k[2]\n+\tid ^= c.k[3]\n+\n+\tstore32l(dst[0:4], ia)\n+\tstore32l(dst[4:8], ib)\n+\tstore32l(dst[8:12], ic)\n+\tstore32l(dst[12:16], id)\n+}"}, {"sha": "303081f3f28a3a1549da91979479f5c186448a8f", "filename": "libgo/go/crypto/twofish/twofish_test.go", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Ftwofish%2Ftwofish_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Ftwofish%2Ftwofish_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftwofish%2Ftwofish_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -0,0 +1,129 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package twofish\n+\n+import (\n+\t\"bytes\"\n+\t\"testing\"\n+)\n+\n+var qbox = [2][4][16]byte{\n+\t{\n+\t\t{0x8, 0x1, 0x7, 0xD, 0x6, 0xF, 0x3, 0x2, 0x0, 0xB, 0x5, 0x9, 0xE, 0xC, 0xA, 0x4},\n+\t\t{0xE, 0xC, 0xB, 0x8, 0x1, 0x2, 0x3, 0x5, 0xF, 0x4, 0xA, 0x6, 0x7, 0x0, 0x9, 0xD},\n+\t\t{0xB, 0xA, 0x5, 0xE, 0x6, 0xD, 0x9, 0x0, 0xC, 0x8, 0xF, 0x3, 0x2, 0x4, 0x7, 0x1},\n+\t\t{0xD, 0x7, 0xF, 0x4, 0x1, 0x2, 0x6, 0xE, 0x9, 0xB, 0x3, 0x0, 0x8, 0x5, 0xC, 0xA},\n+\t},\n+\t{\n+\t\t{0x2, 0x8, 0xB, 0xD, 0xF, 0x7, 0x6, 0xE, 0x3, 0x1, 0x9, 0x4, 0x0, 0xA, 0xC, 0x5},\n+\t\t{0x1, 0xE, 0x2, 0xB, 0x4, 0xC, 0x3, 0x7, 0x6, 0xD, 0xA, 0x5, 0xF, 0x9, 0x0, 0x8},\n+\t\t{0x4, 0xC, 0x7, 0x5, 0x1, 0x6, 0x9, 0xA, 0x0, 0xE, 0xD, 0x8, 0x2, 0xB, 0x3, 0xF},\n+\t\t{0xB, 0x9, 0x5, 0x1, 0xC, 0x3, 0xD, 0xE, 0x6, 0x4, 0x7, 0xF, 0x2, 0x0, 0x8, 0xA},\n+\t},\n+}\n+\n+// genSbox generates the variable sbox\n+func genSbox(qi int, x byte) byte {\n+\ta0, b0 := x/16, x%16\n+\tfor i := 0; i < 2; i++ {\n+\t\ta1 := a0 ^ b0\n+\t\tb1 := (a0 ^ ((b0 << 3) | (b0 >> 1)) ^ (a0 << 3)) & 15\n+\t\ta0 = qbox[qi][2*i][a1]\n+\t\tb0 = qbox[qi][2*i+1][b1]\n+\t}\n+\treturn (b0 << 4) + a0\n+}\n+\n+func TestSbox(t *testing.T) {\n+\tfor n := range sbox {\n+\t\tfor m := range sbox[n] {\n+\t\t\tif genSbox(n, byte(m)) != sbox[n][m] {\n+\t\t\t\tt.Errorf(\"#%d|%d: sbox value = %d want %d\", n, m, sbox[n][m], genSbox(n, byte(m)))\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+var testVectors = []struct {\n+\tkey []byte\n+\tdec []byte\n+\tenc []byte\n+}{\n+\t// These tests are extracted from LibTom\n+\t{\n+\t\t[]byte{0x9F, 0x58, 0x9F, 0x5C, 0xF6, 0x12, 0x2C, 0x32, 0xB6, 0xBF, 0xEC, 0x2F, 0x2A, 0xE8, 0xC3, 0x5A},\n+\t\t[]byte{0xD4, 0x91, 0xDB, 0x16, 0xE7, 0xB1, 0xC3, 0x9E, 0x86, 0xCB, 0x08, 0x6B, 0x78, 0x9F, 0x54, 0x19},\n+\t\t[]byte{0x01, 0x9F, 0x98, 0x09, 0xDE, 0x17, 0x11, 0x85, 0x8F, 0xAA, 0xC3, 0xA3, 0xBA, 0x20, 0xFB, 0xC3},\n+\t},\n+\t{\n+\t\t[]byte{0x88, 0xB2, 0xB2, 0x70, 0x6B, 0x10, 0x5E, 0x36, 0xB4, 0x46, 0xBB, 0x6D, 0x73, 0x1A, 0x1E, 0x88,\n+\t\t\t0xEF, 0xA7, 0x1F, 0x78, 0x89, 0x65, 0xBD, 0x44},\n+\t\t[]byte{0x39, 0xDA, 0x69, 0xD6, 0xBA, 0x49, 0x97, 0xD5, 0x85, 0xB6, 0xDC, 0x07, 0x3C, 0xA3, 0x41, 0xB2},\n+\t\t[]byte{0x18, 0x2B, 0x02, 0xD8, 0x14, 0x97, 0xEA, 0x45, 0xF9, 0xDA, 0xAC, 0xDC, 0x29, 0x19, 0x3A, 0x65},\n+\t},\n+\t{\n+\t\t[]byte{0xD4, 0x3B, 0xB7, 0x55, 0x6E, 0xA3, 0x2E, 0x46, 0xF2, 0xA2, 0x82, 0xB7, 0xD4, 0x5B, 0x4E, 0x0D,\n+\t\t\t0x57, 0xFF, 0x73, 0x9D, 0x4D, 0xC9, 0x2C, 0x1B, 0xD7, 0xFC, 0x01, 0x70, 0x0C, 0xC8, 0x21, 0x6F},\n+\t\t[]byte{0x90, 0xAF, 0xE9, 0x1B, 0xB2, 0x88, 0x54, 0x4F, 0x2C, 0x32, 0xDC, 0x23, 0x9B, 0x26, 0x35, 0xE6},\n+\t\t[]byte{0x6C, 0xB4, 0x56, 0x1C, 0x40, 0xBF, 0x0A, 0x97, 0x05, 0x93, 0x1C, 0xB6, 0xD4, 0x08, 0xE7, 0xFA},\n+\t},\n+\t// These test are derived from http://www.schneier.com/code/ecb_ival.txt\n+\t{\n+\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n+\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n+\t\t[]byte{0x9F, 0x58, 0x9F, 0x5C, 0xF6, 0x12, 0x2C, 0x32, 0xB6, 0xBF, 0xEC, 0x2F, 0x2A, 0xE8, 0xC3, 0x5A},\n+\t},\n+\t{\n+\t\t[]byte{0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,\n+\t\t\t0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,\n+\t\t},\n+\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n+\t\t[]byte{0xCF, 0xD1, 0xD2, 0xE5, 0xA9, 0xBE, 0x9C, 0xDF, 0x50, 0x1F, 0x13, 0xB8, 0x92, 0xBD, 0x22, 0x48},\n+\t},\n+\t{\n+\t\t[]byte{0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,\n+\t\t\t0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF,\n+\t\t},\n+\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n+\t\t[]byte{0x37, 0x52, 0x7B, 0xE0, 0x05, 0x23, 0x34, 0xB8, 0x9F, 0x0C, 0xFC, 0xCA, 0xE8, 0x7C, 0xFA, 0x20},\n+\t},\n+}\n+\n+func TestCipher(t *testing.T) {\n+\tfor n, tt := range testVectors {\n+\t\t// Test if the plaintext (dec) is encrypts to the given\n+\t\t// ciphertext (enc) using the given key. Test also if enc can\n+\t\t// be decrypted again into dec.\n+\t\tc, err := NewCipher(tt.key)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"#%d: NewCipher: %v\", n, err)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tbuf := make([]byte, 16)\n+\t\tc.Encrypt(buf, tt.dec)\n+\t\tif !bytes.Equal(buf, tt.enc) {\n+\t\t\tt.Errorf(\"#%d: encrypt = %x want %x\", n, buf, tt.enc)\n+\t\t}\n+\t\tc.Decrypt(buf, tt.enc)\n+\t\tif !bytes.Equal(buf, tt.dec) {\n+\t\t\tt.Errorf(\"#%d: decrypt = %x want %x\", n, buf, tt.dec)\n+\t\t}\n+\n+\t\t// Test that 16 zero bytes, encrypted 1000 times then decrypted\n+\t\t// 1000 times results in zero bytes again.\n+\t\tzero := make([]byte, 16)\n+\t\tbuf = make([]byte, 16)\n+\t\tfor i := 0; i < 1000; i++ {\n+\t\t\tc.Encrypt(buf, buf)\n+\t\t}\n+\t\tfor i := 0; i < 1000; i++ {\n+\t\t\tc.Decrypt(buf, buf)\n+\t\t}\n+\t\tif !bytes.Equal(buf, zero) {\n+\t\t\tt.Errorf(\"#%d: encrypt/decrypt 1000: have %x want %x\", n, buf, zero)\n+\t\t}\n+\t}\n+}"}, {"sha": "6199e8db9f539df86d7c0bc43aa05182e330fe1a", "filename": "libgo/go/crypto/x509/x509.go", "status": "modified", "additions": 68, "deletions": 45, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -217,50 +217,40 @@ var (\n \toidPostalCode         = []int{2, 5, 4, 17}\n )\n \n-func (n Name) toRDNSequence() (ret rdnSequence) {\n-\tret = make([]relativeDistinguishedNameSET, 9 /* maximum number of elements */ )\n-\ti := 0\n-\tif len(n.Country) > 0 {\n-\t\tret[i] = []attributeTypeAndValue{{oidCountry, n.Country}}\n-\t\ti++\n-\t}\n-\tif len(n.Organization) > 0 {\n-\t\tret[i] = []attributeTypeAndValue{{oidOrganization, n.Organization}}\n-\t\ti++\n+// appendRDNs appends a relativeDistinguishedNameSET to the given rdnSequence\n+// and returns the new value. The relativeDistinguishedNameSET contains an\n+// attributeTypeAndValue for each of the given values. See RFC 5280, A.1, and\n+// search for AttributeTypeAndValue.\n+func appendRDNs(in rdnSequence, values []string, oid asn1.ObjectIdentifier) rdnSequence {\n+\tif len(values) == 0 {\n+\t\treturn in\n \t}\n-\tif len(n.OrganizationalUnit) > 0 {\n-\t\tret[i] = []attributeTypeAndValue{{oidOrganizationalUnit, n.OrganizationalUnit}}\n-\t\ti++\n+\n+\ts := make([]attributeTypeAndValue, len(values))\n+\tfor i, value := range values {\n+\t\ts[i].Type = oid\n+\t\ts[i].Value = value\n \t}\n+\n+\treturn append(in, s)\n+}\n+\n+func (n Name) toRDNSequence() (ret rdnSequence) {\n+\tret = appendRDNs(ret, n.Country, oidCountry)\n+\tret = appendRDNs(ret, n.Organization, oidOrganization)\n+\tret = appendRDNs(ret, n.OrganizationalUnit, oidOrganizationalUnit)\n+\tret = appendRDNs(ret, n.Locality, oidLocatity)\n+\tret = appendRDNs(ret, n.Province, oidProvince)\n+\tret = appendRDNs(ret, n.StreetAddress, oidStreetAddress)\n+\tret = appendRDNs(ret, n.PostalCode, oidPostalCode)\n \tif len(n.CommonName) > 0 {\n-\t\tret[i] = []attributeTypeAndValue{{oidCommonName, n.CommonName}}\n-\t\ti++\n+\t\tret = appendRDNs(ret, []string{n.CommonName}, oidCommonName)\n \t}\n \tif len(n.SerialNumber) > 0 {\n-\t\tret[i] = []attributeTypeAndValue{{oidSerialNumber, n.SerialNumber}}\n-\t\ti++\n+\t\tret = appendRDNs(ret, []string{n.SerialNumber}, oidSerialNumber)\n \t}\n-\tif len(n.Locality) > 0 {\n-\t\tret[i] = []attributeTypeAndValue{{oidLocatity, n.Locality}}\n-\t\ti++\n-\t}\n-\tif len(n.Province) > 0 {\n-\t\tret[i] = []attributeTypeAndValue{{oidProvince, n.Province}}\n-\t\ti++\n-\t}\n-\tif len(n.StreetAddress) > 0 {\n-\t\tret[i] = []attributeTypeAndValue{{oidStreetAddress, n.StreetAddress}}\n-\t\ti++\n-\t}\n-\tif len(n.PostalCode) > 0 {\n-\t\tret[i] = []attributeTypeAndValue{{oidPostalCode, n.PostalCode}}\n-\t\ti++\n-\t}\n-\n-\t// Adding another RDN here? Remember to update the maximum number of\n-\t// elements in the make() at the top of the function.\n \n-\treturn ret[0:i]\n+\treturn ret\n }\n \n func getSignatureAlgorithmFromOID(oid []int) SignatureAlgorithm {\n@@ -339,6 +329,8 @@ type Certificate struct {\n \t// Subject Alternate Name values\n \tDNSNames       []string\n \tEmailAddresses []string\n+\n+\tPolicyIdentifiers []asn1.ObjectIdentifier\n }\n \n // UnsupportedAlgorithmError results from attempting to perform an operation\n@@ -476,6 +468,12 @@ type rsaPublicKey struct {\n \tE int\n }\n \n+// RFC 5280 4.2.1.4\n+type policyInformation struct {\n+\tPolicy asn1.ObjectIdentifier\n+\t// policyQualifiers omitted\n+}\n+\n func parsePublicKey(algo PublicKeyAlgorithm, asn1Data []byte) (interface{}, os.Error) {\n \tswitch algo {\n \tcase RSA:\n@@ -517,7 +515,7 @@ func parseCertificate(in *certificate) (*Certificate, os.Error) {\n \t\treturn nil, err\n \t}\n \n-\tout.Version = in.TBSCertificate.Version\n+\tout.Version = in.TBSCertificate.Version + 1\n \tout.SerialNumber = in.TBSCertificate.SerialNumber.Bytes\n \tout.Issuer.fillFromRDNSequence(&in.TBSCertificate.Issuer)\n \tout.Subject.fillFromRDNSequence(&in.TBSCertificate.Subject)\n@@ -623,6 +621,17 @@ func parseCertificate(in *certificate) (*Certificate, os.Error) {\n \t\t\t\t}\n \t\t\t\tout.SubjectKeyId = keyid\n \t\t\t\tcontinue\n+\n+\t\t\tcase 32:\n+\t\t\t\t// RFC 5280 4.2.1.4: Certificate Policies\n+\t\t\t\tvar policies []policyInformation\n+\t\t\t\tif _, err = asn1.Unmarshal(e.Value, &policies); err != nil {\n+\t\t\t\t\treturn nil, err\n+\t\t\t\t}\n+\t\t\t\tout.PolicyIdentifiers = make([]asn1.ObjectIdentifier, len(policies))\n+\t\t\t\tfor i, policy := range policies {\n+\t\t\t\t\tout.PolicyIdentifiers[i] = policy.Policy\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \n@@ -683,15 +692,16 @@ func reverseBitsInAByte(in byte) byte {\n }\n \n var (\n-\toidExtensionSubjectKeyId     = []int{2, 5, 29, 14}\n-\toidExtensionKeyUsage         = []int{2, 5, 29, 15}\n-\toidExtensionAuthorityKeyId   = []int{2, 5, 29, 35}\n-\toidExtensionBasicConstraints = []int{2, 5, 29, 19}\n-\toidExtensionSubjectAltName   = []int{2, 5, 29, 17}\n+\toidExtensionSubjectKeyId        = []int{2, 5, 29, 14}\n+\toidExtensionKeyUsage            = []int{2, 5, 29, 15}\n+\toidExtensionAuthorityKeyId      = []int{2, 5, 29, 35}\n+\toidExtensionBasicConstraints    = []int{2, 5, 29, 19}\n+\toidExtensionSubjectAltName      = []int{2, 5, 29, 17}\n+\toidExtensionCertificatePolicies = []int{2, 5, 29, 32}\n )\n \n func buildExtensions(template *Certificate) (ret []extension, err os.Error) {\n-\tret = make([]extension, 5 /* maximum number of elements. */ )\n+\tret = make([]extension, 6 /* maximum number of elements. */ )\n \tn := 0\n \n \tif template.KeyUsage != 0 {\n@@ -755,6 +765,19 @@ func buildExtensions(template *Certificate) (ret []extension, err os.Error) {\n \t\tn++\n \t}\n \n+\tif len(template.PolicyIdentifiers) > 0 {\n+\t\tret[n].Id = oidExtensionCertificatePolicies\n+\t\tpolicies := make([]policyInformation, len(template.PolicyIdentifiers))\n+\t\tfor i, policy := range template.PolicyIdentifiers {\n+\t\t\tpolicies[i].Policy = policy\n+\t\t}\n+\t\tret[n].Value, err = asn1.Marshal(policies)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tn++\n+\t}\n+\n \t// Adding another extension here? Remember to update the maximum number\n \t// of elements in the make() at the top of the function.\n \n@@ -796,7 +819,7 @@ func CreateCertificate(rand io.Reader, template, parent *Certificate, pub *rsa.P\n \n \tencodedPublicKey := asn1.BitString{BitLength: len(asn1PublicKey) * 8, Bytes: asn1PublicKey}\n \tc := tbsCertificate{\n-\t\tVersion:            3,\n+\t\tVersion:            2,\n \t\tSerialNumber:       asn1.RawValue{Bytes: template.SerialNumber, Tag: 2},\n \t\tSignatureAlgorithm: algorithmIdentifier{oidSHA1WithRSA},\n \t\tIssuer:             parent.Subject.toRDNSequence(),"}, {"sha": "2fe47fdbe595ab50cea22d13164119c9f14d185c", "filename": "libgo/go/crypto/x509/x509_test.go", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -5,6 +5,7 @@\n package x509\n \n import (\n+\t\"asn1\"\n \t\"big\"\n \t\"crypto/rand\"\n \t\"crypto/rsa\"\n@@ -169,6 +170,8 @@ func TestCreateSelfSignedCertificate(t *testing.T) {\n \t\tBasicConstraintsValid: true,\n \t\tIsCA:                  true,\n \t\tDNSNames:              []string{\"test.example.com\"},\n+\n+\t\tPolicyIdentifiers: []asn1.ObjectIdentifier{[]int{1, 2, 3}},\n \t}\n \n \tderBytes, err := CreateCertificate(random, &template, &template, &priv.PublicKey, priv)\n@@ -182,6 +185,11 @@ func TestCreateSelfSignedCertificate(t *testing.T) {\n \t\tt.Errorf(\"Failed to parse certificate: %s\", err)\n \t\treturn\n \t}\n+\n+\tif len(cert.PolicyIdentifiers) != 1 || !cert.PolicyIdentifiers[0].Equal(template.PolicyIdentifiers[0]) {\n+\t\tt.Errorf(\"Failed to parse policy identifiers: got:%#v want:%#v\", cert.PolicyIdentifiers, template.PolicyIdentifiers)\n+\t}\n+\n \terr = cert.CheckSignatureFrom(cert)\n \tif err != nil {\n \t\tt.Errorf(\"Signature verification failed: %s\", err)"}, {"sha": "664d021ced5e6b884a2b5e7cbda08cfe7f5afcf0", "filename": "libgo/go/debug/dwarf/testdata/typedef.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftestdata%2Ftypedef.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftestdata%2Ftypedef.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftestdata%2Ftypedef.c?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -9,13 +9,17 @@ gcc -gdwarf-2 -m64 -c typedef.c && gcc -gdwarf-2 -m64 -o typedef.elf typedef.o\n OS X Mach-O:\n gcc -gdwarf-2 -m64 -c typedef.c -o typedef.macho\n */\n+#include <complex.h>\n \n typedef volatile int* t_ptr_volatile_int;\n typedef const char *t_ptr_const_char;\n typedef long t_long;\n typedef unsigned short t_ushort;\n typedef int t_func_int_of_float_double(float, double);\n typedef int (*t_ptr_func_int_of_float_double)(float, double);\n+typedef int (*t_ptr_func_int_of_float_complex)(float complex);\n+typedef int (*t_ptr_func_int_of_double_complex)(double complex);\n+typedef int (*t_ptr_func_int_of_long_double_complex)(long double complex);\n typedef int *t_func_ptr_int_of_char_schar_uchar(char, signed char, unsigned char);\n typedef void t_func_void_of_char(char);\n typedef void t_func_void_of_void(void);\n@@ -65,6 +69,9 @@ t_my_union *a12a;\n t_my_enum *a13;\n t_my_list *a14;\n t_my_tree *a15;\n+t_ptr_func_int_of_float_complex *a16;\n+t_ptr_func_int_of_double_complex *a17;\n+t_ptr_func_int_of_long_double_complex *a18;\n \n int main()\n {"}, {"sha": "44df8da9bc7c4683d557a34bee8715ab754e2d34", "filename": "libgo/go/debug/dwarf/testdata/typedef.elf", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftestdata%2Ftypedef.elf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftestdata%2Ftypedef.elf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftestdata%2Ftypedef.elf?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "41019c1e1461536738788a750b49abb0a4fd626b", "filename": "libgo/go/debug/dwarf/testdata/typedef.macho", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftestdata%2Ftypedef.macho", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftestdata%2Ftypedef.macho", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftestdata%2Ftypedef.macho?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "e01f7353a4d6c83b1900d9dbcbd245dbec5b3684", "filename": "libgo/go/debug/dwarf/type_test.go", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftype_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftype_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftype_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -12,21 +12,24 @@ import (\n )\n \n var typedefTests = map[string]string{\n-\t\"t_ptr_volatile_int\":                 \"*volatile int\",\n-\t\"t_ptr_const_char\":                   \"*const char\",\n-\t\"t_long\":                             \"long int\",\n-\t\"t_ushort\":                           \"short unsigned int\",\n-\t\"t_func_int_of_float_double\":         \"func(float, double) int\",\n-\t\"t_ptr_func_int_of_float_double\":     \"*func(float, double) int\",\n-\t\"t_func_ptr_int_of_char_schar_uchar\": \"func(char, signed char, unsigned char) *int\",\n-\t\"t_func_void_of_char\":                \"func(char) void\",\n-\t\"t_func_void_of_void\":                \"func() void\",\n-\t\"t_func_void_of_ptr_char_dots\":       \"func(*char, ...) void\",\n-\t\"t_my_struct\":                        \"struct my_struct {vi volatile int@0; x char@4 : 1@7; y int@4 : 4@27; array [40]long long int@8}\",\n-\t\"t_my_union\":                         \"union my_union {vi volatile int@0; x char@0 : 1@7; y int@0 : 4@28; array [40]long long int@0}\",\n-\t\"t_my_enum\":                          \"enum my_enum {e1=1; e2=2; e3=-5; e4=1000000000000000}\",\n-\t\"t_my_list\":                          \"struct list {val short int@0; next *t_my_list@8}\",\n-\t\"t_my_tree\":                          \"struct tree {left *struct tree@0; right *struct tree@8; val long long unsigned int@16}\",\n+\t\"t_ptr_volatile_int\":                    \"*volatile int\",\n+\t\"t_ptr_const_char\":                      \"*const char\",\n+\t\"t_long\":                                \"long int\",\n+\t\"t_ushort\":                              \"short unsigned int\",\n+\t\"t_func_int_of_float_double\":            \"func(float, double) int\",\n+\t\"t_ptr_func_int_of_float_double\":        \"*func(float, double) int\",\n+\t\"t_ptr_func_int_of_float_complex\":       \"*func(complex float) int\",\n+\t\"t_ptr_func_int_of_double_complex\":      \"*func(complex double) int\",\n+\t\"t_ptr_func_int_of_long_double_complex\": \"*func(complex long double) int\",\n+\t\"t_func_ptr_int_of_char_schar_uchar\":    \"func(char, signed char, unsigned char) *int\",\n+\t\"t_func_void_of_char\":                   \"func(char) void\",\n+\t\"t_func_void_of_void\":                   \"func() void\",\n+\t\"t_func_void_of_ptr_char_dots\":          \"func(*char, ...) void\",\n+\t\"t_my_struct\":                           \"struct my_struct {vi volatile int@0; x char@4 : 1@7; y int@4 : 4@27; array [40]long long int@8}\",\n+\t\"t_my_union\":                            \"union my_union {vi volatile int@0; x char@0 : 1@7; y int@0 : 4@28; array [40]long long int@0}\",\n+\t\"t_my_enum\":                             \"enum my_enum {e1=1; e2=2; e3=-5; e4=1000000000000000}\",\n+\t\"t_my_list\":                             \"struct list {val short int@0; next *t_my_list@8}\",\n+\t\"t_my_tree\":                             \"struct tree {left *struct tree@0; right *struct tree@8; val long long unsigned int@16}\",\n }\n \n func elfData(t *testing.T, name string) *Data {"}, {"sha": "74e9799863983b91dd6109187e36ee9177e1ab2a", "filename": "libgo/go/debug/elf/elf.go", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fdebug%2Felf%2Felf.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fdebug%2Felf%2Felf.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Felf%2Felf.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -1356,9 +1356,12 @@ type Sym32 struct {\n \n const Sym32Size = 16\n \n-func ST_BIND(info uint8) SymBind              { return SymBind(info >> 4) }\n-func ST_TYPE(bind SymBind, typ SymType) uint8 { return uint8(bind)<<4 | uint8(typ)&0xf }\n-func ST_VISIBILITY(other uint8) SymVis        { return SymVis(other & 3) }\n+func ST_BIND(info uint8) SymBind { return SymBind(info >> 4) }\n+func ST_TYPE(info uint8) SymType { return SymType(info & 0xF) }\n+func ST_INFO(bind SymBind, typ SymType) uint8 {\n+\treturn uint8(bind)<<4 | uint8(typ)&0xf\n+}\n+func ST_VISIBILITY(other uint8) SymVis { return SymVis(other & 3) }\n \n /*\n  * ELF64"}, {"sha": "e69317a75faf62dfb37b7c9cfb97aaee01a442f0", "filename": "libgo/go/debug/elf/file.go", "status": "modified", "additions": 143, "deletions": 18, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fdebug%2Felf%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fdebug%2Felf%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Felf%2Ffile.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -75,6 +75,15 @@ func (s *Section) Data() ([]byte, os.Error) {\n \treturn dat[0:n], err\n }\n \n+// stringTable reads and returns the string table given by the\n+// specified link value.\n+func (f *File) stringTable(link uint32) ([]byte, os.Error) {\n+\tif link <= 0 || link >= uint32(len(f.Sections)) {\n+\t\treturn nil, os.ErrorString(\"section has invalid string table link\")\n+\t}\n+\treturn f.Sections[link].Data()\n+}\n+\n // Open returns a new ReadSeeker reading the ELF section.\n func (s *Section) Open() io.ReadSeeker { return io.NewSectionReader(s.sr, 0, 1<<63-1) }\n \n@@ -108,9 +117,9 @@ func (p *Prog) Open() io.ReadSeeker { return io.NewSectionReader(p.sr, 0, 1<<63-\n \n // A Symbol represents an entry in an ELF symbol table section.\n type Symbol struct {\n-\tName        uint32\n+\tName        string\n \tInfo, Other byte\n-\tSection     uint32\n+\tSection     SectionIndex\n \tValue, Size uint64\n }\n \n@@ -160,6 +169,17 @@ func (f *File) Close() os.Error {\n \treturn err\n }\n \n+// SectionByType returns the first section in f with the\n+// given type, or nil if there is no such section.\n+func (f *File) SectionByType(typ SectionType) *Section {\n+\tfor _, s := range f.Sections {\n+\t\tif s.Type == typ {\n+\t\t\treturn s\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n // NewFile creates a new File for accessing an ELF binary in an underlying reader.\n // The ELF binary is expected to start at position 0 in the ReaderAt.\n func NewFile(r io.ReaderAt) (*File, os.Error) {\n@@ -293,9 +313,8 @@ func NewFile(r io.ReaderAt) (*File, os.Error) {\n \t}\n \n \t// Load section header string table.\n-\ts := f.Sections[shstrndx]\n-\tshstrtab := make([]byte, s.Size)\n-\tif _, err := r.ReadAt(shstrtab, int64(s.Offset)); err != nil {\n+\tshstrtab, err := f.Sections[shstrndx].Data()\n+\tif err != nil {\n \t\treturn nil, err\n \t}\n \tfor i, s := range f.Sections {\n@@ -309,25 +328,65 @@ func NewFile(r io.ReaderAt) (*File, os.Error) {\n \treturn f, nil\n }\n \n-func (f *File) getSymbols() ([]Symbol, os.Error) {\n+// getSymbols returns a slice of Symbols from parsing the symbol table\n+// with the given type.\n+func (f *File) getSymbols(typ SectionType) ([]Symbol, os.Error) {\n \tswitch f.Class {\n \tcase ELFCLASS64:\n-\t\treturn f.getSymbols64()\n+\t\treturn f.getSymbols64(typ)\n+\n+\tcase ELFCLASS32:\n+\t\treturn f.getSymbols32(typ)\n \t}\n \n \treturn nil, os.ErrorString(\"not implemented\")\n }\n \n-// GetSymbols returns a slice of Symbols from parsing the symbol table.\n-func (f *File) getSymbols64() ([]Symbol, os.Error) {\n-\tvar symtabSection *Section\n-\tfor _, section := range f.Sections {\n-\t\tif section.Type == SHT_SYMTAB {\n-\t\t\tsymtabSection = section\n-\t\t\tbreak\n-\t\t}\n+func (f *File) getSymbols32(typ SectionType) ([]Symbol, os.Error) {\n+\tsymtabSection := f.SectionByType(typ)\n+\tif symtabSection == nil {\n+\t\treturn nil, os.ErrorString(\"no symbol section\")\n+\t}\n+\n+\tdata, err := symtabSection.Data()\n+\tif err != nil {\n+\t\treturn nil, os.ErrorString(\"cannot load symbol section\")\n+\t}\n+\tsymtab := bytes.NewBuffer(data)\n+\tif symtab.Len()%Sym32Size != 0 {\n+\t\treturn nil, os.ErrorString(\"length of symbol section is not a multiple of SymSize\")\n+\t}\n+\n+\tstrdata, err := f.stringTable(symtabSection.Link)\n+\tif err != nil {\n+\t\treturn nil, os.ErrorString(\"cannot load string table section\")\n+\t}\n+\n+\t// The first entry is all zeros.\n+\tvar skip [Sym32Size]byte\n+\tsymtab.Read(skip[0:])\n+\n+\tsymbols := make([]Symbol, symtab.Len()/Sym32Size)\n+\n+\ti := 0\n+\tvar sym Sym32\n+\tfor symtab.Len() > 0 {\n+\t\tbinary.Read(symtab, f.ByteOrder, &sym)\n+\t\tstr, _ := getString(strdata, int(sym.Name))\n+\t\tsymbols[i].Name = str\n+\t\tsymbols[i].Info = sym.Info\n+\t\tsymbols[i].Other = sym.Other\n+\t\tsymbols[i].Section = SectionIndex(sym.Shndx)\n+\t\tsymbols[i].Value = uint64(sym.Value)\n+\t\tsymbols[i].Size = uint64(sym.Size)\n+\t\ti++\n \t}\n \n+\treturn symbols, nil\n+}\n+\n+func (f *File) getSymbols64(typ SectionType) ([]Symbol, os.Error) {\n+\tsymtabSection := f.SectionByType(typ)\n \tif symtabSection == nil {\n \t\treturn nil, os.ErrorString(\"no symbol section\")\n \t}\n@@ -341,6 +400,11 @@ func (f *File) getSymbols64() ([]Symbol, os.Error) {\n \t\treturn nil, os.ErrorString(\"length of symbol section is not a multiple of Sym64Size\")\n \t}\n \n+\tstrdata, err := f.stringTable(symtabSection.Link)\n+\tif err != nil {\n+\t\treturn nil, os.ErrorString(\"cannot load string table section\")\n+\t}\n+\n \t// The first entry is all zeros.\n \tvar skip [Sym64Size]byte\n \tsymtab.Read(skip[0:])\n@@ -351,10 +415,11 @@ func (f *File) getSymbols64() ([]Symbol, os.Error) {\n \tvar sym Sym64\n \tfor symtab.Len() > 0 {\n \t\tbinary.Read(symtab, f.ByteOrder, &sym)\n-\t\tsymbols[i].Name = sym.Name\n+\t\tstr, _ := getString(strdata, int(sym.Name))\n+\t\tsymbols[i].Name = str\n \t\tsymbols[i].Info = sym.Info\n \t\tsymbols[i].Other = sym.Other\n-\t\tsymbols[i].Section = uint32(sym.Shndx)\n+\t\tsymbols[i].Section = SectionIndex(sym.Shndx)\n \t\tsymbols[i].Value = sym.Value\n \t\tsymbols[i].Size = sym.Size\n \t\ti++\n@@ -403,7 +468,7 @@ func (f *File) applyRelocationsAMD64(dst []byte, rels []byte) os.Error {\n \t\treturn os.ErrorString(\"length of relocation section is not a multiple of Sym64Size\")\n \t}\n \n-\tsymbols, err := f.getSymbols()\n+\tsymbols, err := f.getSymbols(SHT_SYMTAB)\n \tif err != nil {\n \t\treturn err\n \t}\n@@ -478,3 +543,63 @@ func (f *File) DWARF() (*dwarf.Data, os.Error) {\n \tabbrev, info, str := dat[0], dat[1], dat[2]\n \treturn dwarf.New(abbrev, nil, nil, info, nil, nil, nil, str)\n }\n+\n+// ImportedSymbols returns the names of all symbols\n+// referred to by the binary f that are expected to be\n+// satisfied by other libraries at dynamic load time.\n+// It does not return weak symbols.\n+func (f *File) ImportedSymbols() ([]string, os.Error) {\n+\tsym, err := f.getSymbols(SHT_DYNSYM)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tvar all []string\n+\tfor _, s := range sym {\n+\t\tif ST_BIND(s.Info) == STB_GLOBAL && s.Section == SHN_UNDEF {\n+\t\t\tall = append(all, s.Name)\n+\t\t}\n+\t}\n+\treturn all, nil\n+}\n+\n+// ImportedLibraries returns the names of all libraries\n+// referred to by the binary f that are expected to be\n+// linked with the binary at dynamic link time.\n+func (f *File) ImportedLibraries() ([]string, os.Error) {\n+\tds := f.SectionByType(SHT_DYNAMIC)\n+\tif ds == nil {\n+\t\t// not dynamic, so no libraries\n+\t\treturn nil, nil\n+\t}\n+\td, err := ds.Data()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tstr, err := f.stringTable(ds.Link)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tvar all []string\n+\tfor len(d) > 0 {\n+\t\tvar tag DynTag\n+\t\tvar value uint64\n+\t\tswitch f.Class {\n+\t\tcase ELFCLASS32:\n+\t\t\ttag = DynTag(f.ByteOrder.Uint32(d[0:4]))\n+\t\t\tvalue = uint64(f.ByteOrder.Uint32(d[4:8]))\n+\t\t\td = d[8:]\n+\t\tcase ELFCLASS64:\n+\t\t\ttag = DynTag(f.ByteOrder.Uint64(d[0:8]))\n+\t\t\tvalue = f.ByteOrder.Uint64(d[8:16])\n+\t\t\td = d[16:]\n+\t\t}\n+\t\tif tag == DT_NEEDED {\n+\t\t\ts, ok := getString(str, int(value))\n+\t\t\tif ok {\n+\t\t\t\tall = append(all, s)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn all, nil\n+}"}, {"sha": "fd8da9449ad0bd1765c06eebcc33bf10228a9d40", "filename": "libgo/go/debug/macho/file.go", "status": "modified", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fdebug%2Fmacho%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fdebug%2Fmacho%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fmacho%2Ffile.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -24,6 +24,9 @@ type File struct {\n \tLoads     []Load\n \tSections  []*Section\n \n+\tSymtab   *Symtab\n+\tDysymtab *Dysymtab\n+\n \tcloser io.Closer\n }\n \n@@ -112,6 +115,28 @@ func (s *Section) Data() ([]byte, os.Error) {\n // Open returns a new ReadSeeker reading the Mach-O section.\n func (s *Section) Open() io.ReadSeeker { return io.NewSectionReader(s.sr, 0, 1<<63-1) }\n \n+// A Dylib represents a Mach-O load dynamic library command.\n+type Dylib struct {\n+\tLoadBytes\n+\tName           string\n+\tTime           uint32\n+\tCurrentVersion uint32\n+\tCompatVersion  uint32\n+}\n+\n+// A Symtab represents a Mach-O symbol table command.\n+type Symtab struct {\n+\tLoadBytes\n+\tSymtabCmd\n+\tSyms []Symbol\n+}\n+\n+// A Dysymtab represents a Mach-O dynamic symbol table command.\n+type Dysymtab struct {\n+\tLoadBytes\n+\tDysymtabCmd\n+\tIndirectSyms []uint32 // indices into Symtab.Syms\n+}\n \n /*\n  * Mach-O reader\n@@ -217,6 +242,71 @@ func NewFile(r io.ReaderAt) (*File, os.Error) {\n \t\tdefault:\n \t\t\tf.Loads[i] = LoadBytes(cmddat)\n \n+\t\tcase LoadCmdDylib:\n+\t\t\tvar hdr DylibCmd\n+\t\t\tb := bytes.NewBuffer(cmddat)\n+\t\t\tif err := binary.Read(b, bo, &hdr); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tl := new(Dylib)\n+\t\t\tif hdr.Name >= uint32(len(cmddat)) {\n+\t\t\t\treturn nil, &FormatError{offset, \"invalid name in dynamic library command\", hdr.Name}\n+\t\t\t}\n+\t\t\tl.Name = cstring(cmddat[hdr.Name:])\n+\t\t\tl.Time = hdr.Time\n+\t\t\tl.CurrentVersion = hdr.CurrentVersion\n+\t\t\tl.CompatVersion = hdr.CompatVersion\n+\t\t\tl.LoadBytes = LoadBytes(cmddat)\n+\t\t\tf.Loads[i] = l\n+\n+\t\tcase LoadCmdSymtab:\n+\t\t\tvar hdr SymtabCmd\n+\t\t\tb := bytes.NewBuffer(cmddat)\n+\t\t\tif err := binary.Read(b, bo, &hdr); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tstrtab := make([]byte, hdr.Strsize)\n+\t\t\tif _, err := r.ReadAt(strtab, int64(hdr.Stroff)); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tvar symsz int\n+\t\t\tif f.Magic == Magic64 {\n+\t\t\t\tsymsz = 16\n+\t\t\t} else {\n+\t\t\t\tsymsz = 12\n+\t\t\t}\n+\t\t\tsymdat := make([]byte, int(hdr.Nsyms)*symsz)\n+\t\t\tif _, err := r.ReadAt(symdat, int64(hdr.Symoff)); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tst, err := f.parseSymtab(symdat, strtab, cmddat, &hdr, offset)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tf.Loads[i] = st\n+\t\t\tf.Symtab = st\n+\n+\t\tcase LoadCmdDysymtab:\n+\t\t\tvar hdr DysymtabCmd\n+\t\t\tb := bytes.NewBuffer(cmddat)\n+\t\t\tif err := binary.Read(b, bo, &hdr); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tdat := make([]byte, hdr.Nindirectsyms*4)\n+\t\t\tif _, err := r.ReadAt(dat, int64(hdr.Indirectsymoff)); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tx := make([]uint32, hdr.Nindirectsyms)\n+\t\t\tif err := binary.Read(bytes.NewBuffer(dat), bo, x); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tst := new(Dysymtab)\n+\t\t\tst.LoadBytes = LoadBytes(cmddat)\n+\t\t\tst.DysymtabCmd = hdr\n+\t\t\tst.IndirectSyms = x\n+\t\t\tf.Loads[i] = st\n+\t\t\tf.Dysymtab = st\n+\n \t\tcase LoadCmdSegment:\n \t\t\tvar seg32 Segment32\n \t\t\tb := bytes.NewBuffer(cmddat)\n@@ -301,6 +391,43 @@ func NewFile(r io.ReaderAt) (*File, os.Error) {\n \treturn f, nil\n }\n \n+func (f *File) parseSymtab(symdat, strtab, cmddat []byte, hdr *SymtabCmd, offset int64) (*Symtab, os.Error) {\n+\tbo := f.ByteOrder\n+\tsymtab := make([]Symbol, hdr.Nsyms)\n+\tb := bytes.NewBuffer(symdat)\n+\tfor i := range symtab {\n+\t\tvar n Nlist64\n+\t\tif f.Magic == Magic64 {\n+\t\t\tif err := binary.Read(b, bo, &n); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t} else {\n+\t\t\tvar n32 Nlist32\n+\t\t\tif err := binary.Read(b, bo, &n32); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tn.Name = n32.Name\n+\t\t\tn.Type = n32.Type\n+\t\t\tn.Sect = n32.Sect\n+\t\t\tn.Desc = n32.Desc\n+\t\t\tn.Value = uint64(n32.Value)\n+\t\t}\n+\t\tsym := &symtab[i]\n+\t\tif n.Name >= uint32(len(strtab)) {\n+\t\t\treturn nil, &FormatError{offset, \"invalid name in symbol table\", n.Name}\n+\t\t}\n+\t\tsym.Name = cstring(strtab[n.Name:])\n+\t\tsym.Type = n.Type\n+\t\tsym.Sect = n.Sect\n+\t\tsym.Desc = n.Desc\n+\t\tsym.Value = n.Value\n+\t}\n+\tst := new(Symtab)\n+\tst.LoadBytes = LoadBytes(cmddat)\n+\tst.Syms = symtab\n+\treturn st, nil\n+}\n+\n func (f *File) pushSection(sh *Section, r io.ReaderAt) {\n \tf.Sections = append(f.Sections, sh)\n \tsh.sr = io.NewSectionReader(r, int64(sh.Offset), int64(sh.Size))\n@@ -358,3 +485,33 @@ func (f *File) DWARF() (*dwarf.Data, os.Error) {\n \tabbrev, info, str := dat[0], dat[1], dat[2]\n \treturn dwarf.New(abbrev, nil, nil, info, nil, nil, nil, str)\n }\n+\n+// ImportedSymbols returns the names of all symbols\n+// referred to by the binary f that are expected to be\n+// satisfied by other libraries at dynamic load time.\n+func (f *File) ImportedSymbols() ([]string, os.Error) {\n+\tif f.Dysymtab == nil || f.Symtab == nil {\n+\t\treturn nil, &FormatError{0, \"missing symbol table\", nil}\n+\t}\n+\n+\tst := f.Symtab\n+\tdt := f.Dysymtab\n+\tvar all []string\n+\tfor _, s := range st.Syms[dt.Iundefsym : dt.Iundefsym+dt.Nundefsym] {\n+\t\tall = append(all, s.Name)\n+\t}\n+\treturn all, nil\n+}\n+\n+// ImportedLibraries returns the paths of all libraries\n+// referred to by the binary f that are expected to be\n+// linked with the binary at dynamic link time.\n+func (f *File) ImportedLibraries() ([]string, os.Error) {\n+\tvar all []string\n+\tfor _, l := range f.Loads {\n+\t\tif lib, ok := l.(*Dylib); ok {\n+\t\t\tall = append(all, lib.Name)\n+\t\t}\n+\t}\n+\treturn all, nil\n+}"}, {"sha": "1386f5acf571fe48fab83365df04a25a1140a284", "filename": "libgo/go/debug/macho/macho.go", "status": "modified", "additions": 78, "deletions": 2, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fdebug%2Fmacho%2Fmacho.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fdebug%2Fmacho%2Fmacho.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fmacho%2Fmacho.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -59,16 +59,21 @@ type LoadCmd uint32\n \n const (\n \tLoadCmdSegment    LoadCmd = 1\n-\tLoadCmdSegment64  LoadCmd = 25\n+\tLoadCmdSymtab     LoadCmd = 2\n \tLoadCmdThread     LoadCmd = 4\n \tLoadCmdUnixThread LoadCmd = 5 // thread+stack\n+\tLoadCmdDysymtab   LoadCmd = 11\n+\tLoadCmdDylib      LoadCmd = 12\n+\tLoadCmdDylinker   LoadCmd = 15\n+\tLoadCmdSegment64  LoadCmd = 25\n )\n \n var cmdStrings = []intName{\n \t{uint32(LoadCmdSegment), \"LoadCmdSegment\"},\n-\t{uint32(LoadCmdSegment64), \"LoadCmdSegment64\"},\n \t{uint32(LoadCmdThread), \"LoadCmdThread\"},\n \t{uint32(LoadCmdUnixThread), \"LoadCmdUnixThread\"},\n+\t{uint32(LoadCmdDylib), \"LoadCmdDylib\"},\n+\t{uint32(LoadCmdSegment64), \"LoadCmdSegment64\"},\n }\n \n func (i LoadCmd) String() string   { return stringName(uint32(i), cmdStrings, false) }\n@@ -104,6 +109,16 @@ type Segment32 struct {\n \tFlag    uint32\n }\n \n+// A DylibCmd is a Mach-O load dynamic library command.\n+type DylibCmd struct {\n+\tCmd            LoadCmd\n+\tLen            uint32\n+\tName           uint32\n+\tTime           uint32\n+\tCurrentVersion uint32\n+\tCompatVersion  uint32\n+}\n+\n // A Section32 is a 32-bit Mach-O section header.\n type Section32 struct {\n \tName     [16]byte\n@@ -135,6 +150,67 @@ type Section64 struct {\n \tReserve3 uint32\n }\n \n+// A SymtabCmd is a Mach-O symbol table command.\n+type SymtabCmd struct {\n+\tCmd     LoadCmd\n+\tLen     uint32\n+\tSymoff  uint32\n+\tNsyms   uint32\n+\tStroff  uint32\n+\tStrsize uint32\n+}\n+\n+// A DysymtabCmd is a Mach-O dynamic symbol table command.\n+type DysymtabCmd struct {\n+\tCmd            LoadCmd\n+\tLen            uint32\n+\tIlocalsym      uint32\n+\tNlocalsym      uint32\n+\tIextdefsym     uint32\n+\tNextdefsym     uint32\n+\tIundefsym      uint32\n+\tNundefsym      uint32\n+\tTocoffset      uint32\n+\tNtoc           uint32\n+\tModtaboff      uint32\n+\tNmodtab        uint32\n+\tExtrefsymoff   uint32\n+\tNextrefsyms    uint32\n+\tIndirectsymoff uint32\n+\tNindirectsyms  uint32\n+\tExtreloff      uint32\n+\tNextrel        uint32\n+\tLocreloff      uint32\n+\tNlocrel        uint32\n+}\n+\n+// An Nlist32 is a Mach-O 32-bit symbol table entry.\n+type Nlist32 struct {\n+\tName  uint32\n+\tType  uint8\n+\tSect  uint8\n+\tDesc  uint16\n+\tValue uint32\n+}\n+\n+// An Nlist64 is a Mach-O 64-bit symbol table entry.\n+type Nlist64 struct {\n+\tName  uint32\n+\tType  uint8\n+\tSect  uint8\n+\tDesc  uint16\n+\tValue uint64\n+}\n+\n+// A Symbol is a Mach-O 32-bit or 64-bit symbol table entry.\n+type Symbol struct {\n+\tName  string\n+\tType  uint8\n+\tSect  uint8\n+\tDesc  uint16\n+\tValue uint64\n+}\n+\n // A Thread is a Mach-O thread state command.\n type Thread struct {\n \tCmd  LoadCmd"}, {"sha": "82c02407bbe3a2587ad3010e5521aee193fb3e04", "filename": "libgo/go/debug/pe/file.go", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fdebug%2Fpe%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fdebug%2Fpe%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fpe%2Ffile.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -49,6 +49,17 @@ type Section struct {\n \tsr *io.SectionReader\n }\n \n+type ImportDirectory struct {\n+\tOriginalFirstThunk uint32\n+\tTimeDateStamp      uint32\n+\tForwarderChain     uint32\n+\tName               uint32\n+\tFirstThunk         uint32\n+\n+\tdll string\n+\trva []uint32\n+}\n+\n // Data reads and returns the contents of the PE section.\n func (s *Section) Data() ([]byte, os.Error) {\n \tdat := make([]byte, s.sr.Size())\n@@ -229,3 +240,70 @@ func (f *File) DWARF() (*dwarf.Data, os.Error) {\n \tabbrev, info, str := dat[0], dat[1], dat[2]\n \treturn dwarf.New(abbrev, nil, nil, info, nil, nil, nil, str)\n }\n+\n+// ImportedSymbols returns the names of all symbols\n+// referred to by the binary f that are expected to be\n+// satisfied by other libraries at dynamic load time.\n+// It does not return weak symbols.\n+func (f *File) ImportedSymbols() ([]string, os.Error) {\n+\tds := f.Section(\".idata\")\n+\tif ds == nil {\n+\t\t// not dynamic, so no libraries\n+\t\treturn nil, nil\n+\t}\n+\td, err := ds.Data()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tvar ida []ImportDirectory\n+\tfor len(d) > 0 {\n+\t\tvar dt ImportDirectory\n+\t\tdt.OriginalFirstThunk = binary.LittleEndian.Uint32(d[0:4])\n+\t\tdt.Name = binary.LittleEndian.Uint32(d[12:16])\n+\t\tdt.FirstThunk = binary.LittleEndian.Uint32(d[16:20])\n+\t\td = d[20:]\n+\t\tif dt.OriginalFirstThunk == 0 {\n+\t\t\tbreak\n+\t\t}\n+\t\tida = append(ida, dt)\n+\t}\n+\tfor i, _ := range ida {\n+\t\tfor len(d) > 0 {\n+\t\t\tva := binary.LittleEndian.Uint32(d[0:4])\n+\t\t\td = d[4:]\n+\t\t\tif va == 0 {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tida[i].rva = append(ida[i].rva, va)\n+\t\t}\n+\t}\n+\tfor _, _ = range ida {\n+\t\tfor len(d) > 0 {\n+\t\t\tva := binary.LittleEndian.Uint32(d[0:4])\n+\t\t\td = d[4:]\n+\t\t\tif va == 0 {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t}\n+\tnames, _ := ds.Data()\n+\tvar all []string\n+\tfor _, dt := range ida {\n+\t\tdt.dll, _ = getString(names, int(dt.Name-ds.VirtualAddress))\n+\t\tfor _, va := range dt.rva {\n+\t\t\tfn, _ := getString(names, int(va-ds.VirtualAddress+2))\n+\t\t\tall = append(all, fn+\":\"+dt.dll)\n+\t\t}\n+\t}\n+\n+\treturn all, nil\n+}\n+\n+// ImportedLibraries returns the names of all libraries\n+// referred to by the binary f that are expected to be\n+// linked with the binary at dynamic link time.\n+func (f *File) ImportedLibraries() ([]string, os.Error) {\n+\t// TODO\n+\t// cgo -dynimport don't use this for windows PE, so just return.\n+\treturn nil, nil\n+}"}, {"sha": "2c5c25b8c4114dc96e3e43e446253f998cabb65f", "filename": "libgo/go/debug/pe/file_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fdebug%2Fpe%2Ffile_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fdebug%2Fpe%2Ffile_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fpe%2Ffile_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -16,7 +16,7 @@ type fileTest struct {\n }\n \n var fileTests = []fileTest{\n-\tfileTest{\n+\t{\n \t\t\"testdata/gcc-386-mingw-obj\",\n \t\tFileHeader{0x014c, 0x000c, 0x0, 0x64a, 0x1e, 0x0, 0x104},\n \t\t[]*SectionHeader{\n@@ -34,7 +34,7 @@ var fileTests = []fileTest{\n \t\t\t&SectionHeader{\".debug_aranges\", 0, 0, 32, 1408, 1590, 0, 2, 0, 1108344832},\n \t\t},\n \t},\n-\tfileTest{\n+\t{\n \t\t\"testdata/gcc-386-mingw-exec\",\n \t\tFileHeader{0x014c, 0x000f, 0x4c6a1b60, 0x3c00, 0x282, 0xe0, 0x107},\n \t\t[]*SectionHeader{"}, {"sha": "be26bbf18b25b80587cb4f20bb64b35df80ee491", "filename": "libgo/go/debug/proc/proc_nacl.go", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6ed1c8903e728f4233122554bab5910853338bd/libgo%2Fgo%2Fdebug%2Fproc%2Fproc_nacl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6ed1c8903e728f4233122554bab5910853338bd/libgo%2Fgo%2Fdebug%2Fproc%2Fproc_nacl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fproc%2Fproc_nacl.go?ref=d6ed1c8903e728f4233122554bab5910853338bd", "patch": "@@ -1,20 +0,0 @@\n-// Copyright 2009 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package proc\n-\n-import (\n-\t\"os\"\n-\t\"syscall\"\n-)\n-\n-// Process tracing is not supported on Native Client.\n-\n-func Attach(pid int) (Process, os.Error) {\n-\treturn nil, os.NewSyscallError(\"ptrace\", syscall.ENACL)\n-}\n-\n-func ForkExec(argv0 string, argv []string, envv []string, dir string, fd []*os.File) (Process, os.Error) {\n-\treturn nil, os.NewSyscallError(\"fork/exec\", syscall.ENACL)\n-}"}, {"sha": "60c9ac719e90a13f9b53cedc41905ea8ba26836c", "filename": "libgo/go/debug/proc/regs_nacl_386.go", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6ed1c8903e728f4233122554bab5910853338bd/libgo%2Fgo%2Fdebug%2Fproc%2Fregs_nacl_386.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6ed1c8903e728f4233122554bab5910853338bd/libgo%2Fgo%2Fdebug%2Fproc%2Fregs_nacl_386.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fproc%2Fregs_nacl_386.go?ref=d6ed1c8903e728f4233122554bab5910853338bd", "patch": "@@ -1,5 +0,0 @@\n-// Copyright 2009 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package proc"}, {"sha": "e5aabd582b3c1d2046f91398e555e81031b7ce12", "filename": "libgo/go/ebnf/ebnf.go", "status": "modified", "additions": 40, "deletions": 35, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Febnf%2Febnf.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Febnf%2Febnf.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Febnf%2Febnf.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -38,7 +38,7 @@ type (\n \t// An Expression node represents a production expression.\n \tExpression interface {\n \t\t// Pos is the position of the first character of the syntactic construct\n-\t\tPos() token.Position\n+\t\tPos() token.Pos\n \t}\n \n \t// An Alternative node represents a non-empty list of alternative expressions.\n@@ -49,14 +49,14 @@ type (\n \n \t// A Name node represents a production name.\n \tName struct {\n-\t\ttoken.Position\n-\t\tString string\n+\t\tStringPos token.Pos\n+\t\tString    string\n \t}\n \n \t// A Token node represents a literal.\n \tToken struct {\n-\t\ttoken.Position\n-\t\tString string\n+\t\tStringPos token.Pos\n+\t\tString    string\n \t}\n \n \t// A List node represents a range of characters.\n@@ -66,20 +66,20 @@ type (\n \n \t// A Group node represents a grouped expression.\n \tGroup struct {\n-\t\ttoken.Position\n-\t\tBody Expression // (body)\n+\t\tLparen token.Pos\n+\t\tBody   Expression // (body)\n \t}\n \n \t// An Option node represents an optional expression.\n \tOption struct {\n-\t\ttoken.Position\n-\t\tBody Expression // [body]\n+\t\tLbrack token.Pos\n+\t\tBody   Expression // [body]\n \t}\n \n \t// A Repetition node represents a repeated expression.\n \tRepetition struct {\n-\t\ttoken.Position\n-\t\tBody Expression // {body}\n+\t\tLbrace token.Pos\n+\t\tBody   Expression // {body}\n \t}\n \n \t// A Production node represents an EBNF production.\n@@ -95,20 +95,15 @@ type (\n )\n \n \n-func (x Alternative) Pos() token.Position {\n-\treturn x[0].Pos() // the parser always generates non-empty Alternative\n-}\n-\n-\n-func (x Sequence) Pos() token.Position {\n-\treturn x[0].Pos() // the parser always generates non-empty Sequences\n-}\n-\n-\n-func (x Range) Pos() token.Position { return x.Begin.Pos() }\n-\n-\n-func (p *Production) Pos() token.Position { return p.Name.Pos() }\n+func (x Alternative) Pos() token.Pos { return x[0].Pos() } // the parser always generates non-empty Alternative\n+func (x Sequence) Pos() token.Pos    { return x[0].Pos() } // the parser always generates non-empty Sequences\n+func (x *Name) Pos() token.Pos       { return x.StringPos }\n+func (x *Token) Pos() token.Pos      { return x.StringPos }\n+func (x *Range) Pos() token.Pos      { return x.Begin.Pos() }\n+func (x *Group) Pos() token.Pos      { return x.Lparen }\n+func (x *Option) Pos() token.Pos     { return x.Lbrack }\n+func (x *Repetition) Pos() token.Pos { return x.Lbrace }\n+func (x *Production) Pos() token.Pos { return x.Name.Pos() }\n \n \n // ----------------------------------------------------------------------------\n@@ -121,13 +116,19 @@ func isLexical(name string) bool {\n \n \n type verifier struct {\n+\tfset *token.FileSet\n \tscanner.ErrorVector\n \tworklist []*Production\n \treached  Grammar // set of productions reached from (and including) the root production\n \tgrammar  Grammar\n }\n \n \n+func (v *verifier) error(pos token.Pos, msg string) {\n+\tv.Error(v.fset.Position(pos), msg)\n+}\n+\n+\n func (v *verifier) push(prod *Production) {\n \tname := prod.Name.String\n \tif _, found := v.reached[name]; !found {\n@@ -140,7 +141,7 @@ func (v *verifier) push(prod *Production) {\n func (v *verifier) verifyChar(x *Token) int {\n \ts := x.String\n \tif utf8.RuneCountInString(s) != 1 {\n-\t\tv.Error(x.Pos(), \"single char expected, found \"+s)\n+\t\tv.error(x.Pos(), \"single char expected, found \"+s)\n \t\treturn 0\n \t}\n \tch, _ := utf8.DecodeRuneInString(s)\n@@ -166,20 +167,20 @@ func (v *verifier) verifyExpr(expr Expression, lexical bool) {\n \t\tif prod, found := v.grammar[x.String]; found {\n \t\t\tv.push(prod)\n \t\t} else {\n-\t\t\tv.Error(x.Pos(), \"missing production \"+x.String)\n+\t\t\tv.error(x.Pos(), \"missing production \"+x.String)\n \t\t}\n \t\t// within a lexical production references\n \t\t// to non-lexical productions are invalid\n \t\tif lexical && !isLexical(x.String) {\n-\t\t\tv.Error(x.Pos(), \"reference to non-lexical production \"+x.String)\n+\t\t\tv.error(x.Pos(), \"reference to non-lexical production \"+x.String)\n \t\t}\n \tcase *Token:\n \t\t// nothing to do for now\n \tcase *Range:\n \t\ti := v.verifyChar(x.Begin)\n \t\tj := v.verifyChar(x.End)\n \t\tif i >= j {\n-\t\t\tv.Error(x.Pos(), \"decreasing character range\")\n+\t\t\tv.error(x.Pos(), \"decreasing character range\")\n \t\t}\n \tcase *Group:\n \t\tv.verifyExpr(x.Body, lexical)\n@@ -193,16 +194,18 @@ func (v *verifier) verifyExpr(expr Expression, lexical bool) {\n }\n \n \n-func (v *verifier) verify(grammar Grammar, start string) {\n+func (v *verifier) verify(fset *token.FileSet, grammar Grammar, start string) {\n \t// find root production\n \troot, found := grammar[start]\n \tif !found {\n-\t\tvar noPos token.Position\n-\t\tv.Error(noPos, \"no start production \"+start)\n+\t\t// token.NoPos doesn't require a file set;\n+\t\t// ok to set v.fset only afterwards\n+\t\tv.error(token.NoPos, \"no start production \"+start)\n \t\treturn\n \t}\n \n \t// initialize verifier\n+\tv.fset = fset\n \tv.ErrorVector.Reset()\n \tv.worklist = v.worklist[0:0]\n \tv.reached = make(Grammar)\n@@ -224,7 +227,7 @@ func (v *verifier) verify(grammar Grammar, start string) {\n \tif len(v.reached) < len(v.grammar) {\n \t\tfor name, prod := range v.grammar {\n \t\t\tif _, found := v.reached[name]; !found {\n-\t\t\t\tv.Error(prod.Pos(), name+\" is unreachable\")\n+\t\t\t\tv.error(prod.Pos(), name+\" is unreachable\")\n \t\t\t}\n \t\t}\n \t}\n@@ -236,8 +239,10 @@ func (v *verifier) verify(grammar Grammar, start string) {\n //\t- all productions defined are used when beginning at start\n //\t- lexical productions refer only to other lexical productions\n //\n-func Verify(grammar Grammar, start string) os.Error {\n+// Position information is interpreted relative to the file set fset.\n+//\n+func Verify(fset *token.FileSet, grammar Grammar, start string) os.Error {\n \tvar v verifier\n-\tv.verify(grammar, start)\n+\tv.verify(fset, grammar, start)\n \treturn v.GetError(scanner.Sorted)\n }"}, {"sha": "bbe530c278f4e2e6c536a31ab058d7c6a0879219", "filename": "libgo/go/ebnf/ebnf_test.go", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Febnf%2Febnf_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Febnf%2Febnf_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Febnf%2Febnf_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -5,11 +5,15 @@\n package ebnf\n \n import (\n+\t\"go/token\"\n \t\"io/ioutil\"\n \t\"testing\"\n )\n \n \n+var fset = token.NewFileSet()\n+\n+\n var grammars = []string{\n \t`Program = .\n \t`,\n@@ -40,11 +44,11 @@ var grammars = []string{\n \n \n func check(t *testing.T, filename string, src []byte) {\n-\tgrammar, err := Parse(filename, src)\n+\tgrammar, err := Parse(fset, filename, src)\n \tif err != nil {\n \t\tt.Errorf(\"Parse(%s) failed: %v\", src, err)\n \t}\n-\tif err = Verify(grammar, \"Program\"); err != nil {\n+\tif err = Verify(fset, grammar, \"Program\"); err != nil {\n \t\tt.Errorf(\"Verify(%s) failed: %v\", src, err)\n \t}\n }"}, {"sha": "c38530177aca7d35b7645c61066624e6aa4a12af", "filename": "libgo/go/ebnf/parser.go", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Febnf%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Febnf%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Febnf%2Fparser.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -13,11 +13,12 @@ import (\n \n \n type parser struct {\n+\tfset *token.FileSet\n \tscanner.ErrorVector\n \tscanner scanner.Scanner\n-\tpos     token.Position // token position\n-\ttok     token.Token    // one token look-ahead\n-\tlit     []byte         // token literal\n+\tpos     token.Pos   // token position\n+\ttok     token.Token // one token look-ahead\n+\tlit     []byte      // token literal\n }\n \n \n@@ -31,21 +32,26 @@ func (p *parser) next() {\n }\n \n \n-func (p *parser) errorExpected(pos token.Position, msg string) {\n+func (p *parser) error(pos token.Pos, msg string) {\n+\tp.Error(p.fset.Position(pos), msg)\n+}\n+\n+\n+func (p *parser) errorExpected(pos token.Pos, msg string) {\n \tmsg = \"expected \" + msg\n-\tif pos.Offset == p.pos.Offset {\n+\tif pos == p.pos {\n \t\t// the error happened at the current position;\n \t\t// make the error message more specific\n \t\tmsg += \", found '\" + p.tok.String() + \"'\"\n \t\tif p.tok.IsLiteral() {\n \t\t\tmsg += \" \" + string(p.lit)\n \t\t}\n \t}\n-\tp.Error(pos, msg)\n+\tp.error(pos, msg)\n }\n \n \n-func (p *parser) expect(tok token.Token) token.Position {\n+func (p *parser) expect(tok token.Token) token.Pos {\n \tpos := p.pos\n \tif p.tok != tok {\n \t\tp.errorExpected(pos, \"'\"+tok.String()+\"'\")\n@@ -167,10 +173,11 @@ func (p *parser) parseProduction() *Production {\n }\n \n \n-func (p *parser) parse(filename string, src []byte) Grammar {\n+func (p *parser) parse(fset *token.FileSet, filename string, src []byte) Grammar {\n \t// initialize parser\n+\tp.fset = fset\n \tp.ErrorVector.Reset()\n-\tp.scanner.Init(filename, src, p, 0)\n+\tp.scanner.Init(fset.AddFile(filename, fset.Base(), len(src)), src, p, 0)\n \tp.next() // initializes pos, tok, lit\n \n \tgrammar := make(Grammar)\n@@ -180,7 +187,7 @@ func (p *parser) parse(filename string, src []byte) Grammar {\n \t\tif _, found := grammar[name]; !found {\n \t\t\tgrammar[name] = prod\n \t\t} else {\n-\t\t\tp.Error(prod.Pos(), name+\" declared already\")\n+\t\t\tp.error(prod.Pos(), name+\" declared already\")\n \t\t}\n \t}\n \n@@ -191,10 +198,11 @@ func (p *parser) parse(filename string, src []byte) Grammar {\n // Parse parses a set of EBNF productions from source src.\n // It returns a set of productions. Errors are reported\n // for incorrect syntax and if a production is declared\n-// more than once.\n+// more than once. Position information is recorded relative\n+// to the file set fset.\n //\n-func Parse(filename string, src []byte) (Grammar, os.Error) {\n+func Parse(fset *token.FileSet, filename string, src []byte) (Grammar, os.Error) {\n \tvar p parser\n-\tgrammar := p.parse(filename, src)\n+\tgrammar := p.parse(fset, filename, src)\n \treturn grammar, p.GetError(scanner.Sorted)\n }"}, {"sha": "acace30d6ac9294983761278613c7f6be6d3f538", "filename": "libgo/go/encoding/base32/base32.go", "status": "added", "additions": 368, "deletions": 0, "changes": 368, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fencoding%2Fbase32%2Fbase32.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fencoding%2Fbase32%2Fbase32.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbase32%2Fbase32.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -0,0 +1,368 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package base32 implements base32 encoding as specified by RFC 4648.\n+package base32\n+\n+import (\n+\t\"io\"\n+\t\"os\"\n+\t\"strconv\"\n+)\n+\n+/*\n+ * Encodings\n+ */\n+\n+// An Encoding is a radix 32 encoding/decoding scheme, defined by a\n+// 32-character alphabet.  The most common is the \"base32\" encoding\n+// introduced for SASL GSSAPI and standardized in RFC 4648.\n+// The alternate \"base32hex\" encoding is used in DNSSEC.\n+type Encoding struct {\n+\tencode    string\n+\tdecodeMap [256]byte\n+}\n+\n+const encodeStd = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\"\n+const encodeHex = \"0123456789ABCDEFGHIJKLMNOPQRSTUV\"\n+\n+// NewEncoding returns a new Encoding defined by the given alphabet,\n+// which must be a 32-byte string.\n+func NewEncoding(encoder string) *Encoding {\n+\te := new(Encoding)\n+\te.encode = encoder\n+\tfor i := 0; i < len(e.decodeMap); i++ {\n+\t\te.decodeMap[i] = 0xFF\n+\t}\n+\tfor i := 0; i < len(encoder); i++ {\n+\t\te.decodeMap[encoder[i]] = byte(i)\n+\t}\n+\treturn e\n+}\n+\n+// StdEncoding is the standard base32 encoding, as defined in\n+// RFC 4648.\n+var StdEncoding = NewEncoding(encodeStd)\n+\n+// HexEncoding is the ``Extended Hex Alphabet'' defined in RFC 4648.\n+// It is typically used in DNS.\n+var HexEncoding = NewEncoding(encodeHex)\n+\n+/*\n+ * Encoder\n+ */\n+\n+// Encode encodes src using the encoding enc, writing\n+// EncodedLen(len(src)) bytes to dst.\n+//\n+// The encoding pads the output to a multiple of 8 bytes,\n+// so Encode is not appropriate for use on individual blocks\n+// of a large data stream.  Use NewEncoder() instead.\n+func (enc *Encoding) Encode(dst, src []byte) {\n+\tif len(src) == 0 {\n+\t\treturn\n+\t}\n+\n+\tfor len(src) > 0 {\n+\t\tdst[0] = 0\n+\t\tdst[1] = 0\n+\t\tdst[2] = 0\n+\t\tdst[3] = 0\n+\t\tdst[4] = 0\n+\t\tdst[5] = 0\n+\t\tdst[6] = 0\n+\t\tdst[7] = 0\n+\n+\t\t// Unpack 8x 5-bit source blocks into a 5 byte\n+\t\t// destination quantum\n+\t\tswitch len(src) {\n+\t\tdefault:\n+\t\t\tdst[7] |= src[4] & 0x1F\n+\t\t\tdst[6] |= src[4] >> 5\n+\t\t\tfallthrough\n+\t\tcase 4:\n+\t\t\tdst[6] |= (src[3] << 3) & 0x1F\n+\t\t\tdst[5] |= (src[3] >> 2) & 0x1F\n+\t\t\tdst[4] |= src[3] >> 7\n+\t\t\tfallthrough\n+\t\tcase 3:\n+\t\t\tdst[4] |= (src[2] << 1) & 0x1F\n+\t\t\tdst[3] |= (src[2] >> 4) & 0x1F\n+\t\t\tfallthrough\n+\t\tcase 2:\n+\t\t\tdst[3] |= (src[1] << 4) & 0x1F\n+\t\t\tdst[2] |= (src[1] >> 1) & 0x1F\n+\t\t\tdst[1] |= (src[1] >> 6) & 0x1F\n+\t\t\tfallthrough\n+\t\tcase 1:\n+\t\t\tdst[1] |= (src[0] << 2) & 0x1F\n+\t\t\tdst[0] |= src[0] >> 3\n+\t\t}\n+\n+\t\t// Encode 5-bit blocks using the base32 alphabet\n+\t\tfor j := 0; j < 8; j++ {\n+\t\t\tdst[j] = enc.encode[dst[j]]\n+\t\t}\n+\n+\t\t// Pad the final quantum\n+\t\tif len(src) < 5 {\n+\t\t\tdst[7] = '='\n+\t\t\tif len(src) < 4 {\n+\t\t\t\tdst[6] = '='\n+\t\t\t\tdst[5] = '='\n+\t\t\t\tif len(src) < 3 {\n+\t\t\t\t\tdst[4] = '='\n+\t\t\t\t\tif len(src) < 2 {\n+\t\t\t\t\t\tdst[3] = '='\n+\t\t\t\t\t\tdst[2] = '='\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tbreak\n+\t\t}\n+\t\tsrc = src[5:]\n+\t\tdst = dst[8:]\n+\t}\n+}\n+\n+type encoder struct {\n+\terr  os.Error\n+\tenc  *Encoding\n+\tw    io.Writer\n+\tbuf  [5]byte    // buffered data waiting to be encoded\n+\tnbuf int        // number of bytes in buf\n+\tout  [1024]byte // output buffer\n+}\n+\n+func (e *encoder) Write(p []byte) (n int, err os.Error) {\n+\tif e.err != nil {\n+\t\treturn 0, e.err\n+\t}\n+\n+\t// Leading fringe.\n+\tif e.nbuf > 0 {\n+\t\tvar i int\n+\t\tfor i = 0; i < len(p) && e.nbuf < 5; i++ {\n+\t\t\te.buf[e.nbuf] = p[i]\n+\t\t\te.nbuf++\n+\t\t}\n+\t\tn += i\n+\t\tp = p[i:]\n+\t\tif e.nbuf < 5 {\n+\t\t\treturn\n+\t\t}\n+\t\te.enc.Encode(e.out[0:], e.buf[0:])\n+\t\tif _, e.err = e.w.Write(e.out[0:8]); e.err != nil {\n+\t\t\treturn n, e.err\n+\t\t}\n+\t\te.nbuf = 0\n+\t}\n+\n+\t// Large interior chunks.\n+\tfor len(p) >= 5 {\n+\t\tnn := len(e.out) / 8 * 5\n+\t\tif nn > len(p) {\n+\t\t\tnn = len(p)\n+\t\t}\n+\t\tnn -= nn % 5\n+\t\tif nn > 0 {\n+\t\t\te.enc.Encode(e.out[0:], p[0:nn])\n+\t\t\tif _, e.err = e.w.Write(e.out[0 : nn/5*8]); e.err != nil {\n+\t\t\t\treturn n, e.err\n+\t\t\t}\n+\t\t}\n+\t\tn += nn\n+\t\tp = p[nn:]\n+\t}\n+\n+\t// Trailing fringe.\n+\tfor i := 0; i < len(p); i++ {\n+\t\te.buf[i] = p[i]\n+\t}\n+\te.nbuf = len(p)\n+\tn += len(p)\n+\treturn\n+}\n+\n+// Close flushes any pending output from the encoder.\n+// It is an error to call Write after calling Close.\n+func (e *encoder) Close() os.Error {\n+\t// If there's anything left in the buffer, flush it out\n+\tif e.err == nil && e.nbuf > 0 {\n+\t\te.enc.Encode(e.out[0:], e.buf[0:e.nbuf])\n+\t\te.nbuf = 0\n+\t\t_, e.err = e.w.Write(e.out[0:8])\n+\t}\n+\treturn e.err\n+}\n+\n+// NewEncoder returns a new base32 stream encoder.  Data written to\n+// the returned writer will be encoded using enc and then written to w.\n+// Base32 encodings operate in 5-byte blocks; when finished\n+// writing, the caller must Close the returned encoder to flush any\n+// partially written blocks.\n+func NewEncoder(enc *Encoding, w io.Writer) io.WriteCloser {\n+\treturn &encoder{enc: enc, w: w}\n+}\n+\n+// EncodedLen returns the length in bytes of the base32 encoding\n+// of an input buffer of length n.\n+func (enc *Encoding) EncodedLen(n int) int { return (n + 4) / 5 * 8 }\n+\n+/*\n+ * Decoder\n+ */\n+\n+type CorruptInputError int64\n+\n+func (e CorruptInputError) String() string {\n+\treturn \"illegal base32 data at input byte \" + strconv.Itoa64(int64(e))\n+}\n+\n+// decode is like Decode but returns an additional 'end' value, which\n+// indicates if end-of-message padding was encountered and thus any\n+// additional data is an error.  decode also assumes len(src)%8==0,\n+// since it is meant for internal use.\n+func (enc *Encoding) decode(dst, src []byte) (n int, end bool, err os.Error) {\n+\tfor i := 0; i < len(src)/8 && !end; i++ {\n+\t\t// Decode quantum using the base32 alphabet\n+\t\tvar dbuf [8]byte\n+\t\tdlen := 8\n+\n+\t\t// do the top bytes contain any data?\n+\tdbufloop:\n+\t\tfor j := 0; j < 8; j++ {\n+\t\t\tin := src[i*8+j]\n+\t\t\tif in == '=' && j >= 2 && i == len(src)/8-1 {\n+\t\t\t\t// We've reached the end and there's\n+\t\t\t\t// padding, the rest should be padded\n+\t\t\t\tfor k := j; k < 8; k++ {\n+\t\t\t\t\tif src[i*8+k] != '=' {\n+\t\t\t\t\t\treturn n, false, CorruptInputError(i*8 + j)\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tdlen = j\n+\t\t\t\tend = true\n+\t\t\t\tbreak dbufloop\n+\t\t\t}\n+\t\t\tdbuf[j] = enc.decodeMap[in]\n+\t\t\tif dbuf[j] == 0xFF {\n+\t\t\t\treturn n, false, CorruptInputError(i*8 + j)\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Pack 8x 5-bit source blocks into 5 byte destination\n+\t\t// quantum\n+\t\tswitch dlen {\n+\t\tcase 7, 8:\n+\t\t\tdst[i*5+4] = dbuf[6]<<5 | dbuf[7]\n+\t\t\tfallthrough\n+\t\tcase 6, 5:\n+\t\t\tdst[i*5+3] = dbuf[4]<<7 | dbuf[5]<<2 | dbuf[6]>>3\n+\t\t\tfallthrough\n+\t\tcase 4:\n+\t\t\tdst[i*5+2] = dbuf[3]<<4 | dbuf[4]>>1\n+\t\t\tfallthrough\n+\t\tcase 3:\n+\t\t\tdst[i*5+1] = dbuf[1]<<6 | dbuf[2]<<1 | dbuf[3]>>4\n+\t\t\tfallthrough\n+\t\tcase 2:\n+\t\t\tdst[i*5+0] = dbuf[0]<<3 | dbuf[1]>>2\n+\t\t}\n+\t\tswitch dlen {\n+\t\tcase 2:\n+\t\t\tn += 1\n+\t\tcase 3, 4:\n+\t\t\tn += 2\n+\t\tcase 5:\n+\t\t\tn += 3\n+\t\tcase 6, 7:\n+\t\t\tn += 4\n+\t\tcase 8:\n+\t\t\tn += 5\n+\t\t}\n+\t}\n+\treturn n, end, nil\n+}\n+\n+// Decode decodes src using the encoding enc.  It writes at most\n+// DecodedLen(len(src)) bytes to dst and returns the number of bytes\n+// written.  If src contains invalid base32 data, it will return the\n+// number of bytes successfully written and CorruptInputError.\n+func (enc *Encoding) Decode(dst, src []byte) (n int, err os.Error) {\n+\tif len(src)%8 != 0 {\n+\t\treturn 0, CorruptInputError(len(src) / 8 * 8)\n+\t}\n+\n+\tn, _, err = enc.decode(dst, src)\n+\treturn\n+}\n+\n+type decoder struct {\n+\terr    os.Error\n+\tenc    *Encoding\n+\tr      io.Reader\n+\tend    bool       // saw end of message\n+\tbuf    [1024]byte // leftover input\n+\tnbuf   int\n+\tout    []byte // leftover decoded output\n+\toutbuf [1024 / 8 * 5]byte\n+}\n+\n+func (d *decoder) Read(p []byte) (n int, err os.Error) {\n+\tif d.err != nil {\n+\t\treturn 0, d.err\n+\t}\n+\n+\t// Use leftover decoded output from last read.\n+\tif len(d.out) > 0 {\n+\t\tn = copy(p, d.out)\n+\t\td.out = d.out[n:]\n+\t\treturn n, nil\n+\t}\n+\n+\t// Read a chunk.\n+\tnn := len(p) / 5 * 8\n+\tif nn < 8 {\n+\t\tnn = 8\n+\t}\n+\tif nn > len(d.buf) {\n+\t\tnn = len(d.buf)\n+\t}\n+\tnn, d.err = io.ReadAtLeast(d.r, d.buf[d.nbuf:nn], 8-d.nbuf)\n+\td.nbuf += nn\n+\tif d.nbuf < 8 {\n+\t\treturn 0, d.err\n+\t}\n+\n+\t// Decode chunk into p, or d.out and then p if p is too small.\n+\tnr := d.nbuf / 8 * 8\n+\tnw := d.nbuf / 8 * 5\n+\tif nw > len(p) {\n+\t\tnw, d.end, d.err = d.enc.decode(d.outbuf[0:], d.buf[0:nr])\n+\t\td.out = d.outbuf[0:nw]\n+\t\tn = copy(p, d.out)\n+\t\td.out = d.out[n:]\n+\t} else {\n+\t\tn, d.end, d.err = d.enc.decode(p, d.buf[0:nr])\n+\t}\n+\td.nbuf -= nr\n+\tfor i := 0; i < d.nbuf; i++ {\n+\t\td.buf[i] = d.buf[i+nr]\n+\t}\n+\n+\tif d.err == nil {\n+\t\td.err = err\n+\t}\n+\treturn n, d.err\n+}\n+\n+// NewDecoder constructs a new base32 stream decoder.\n+func NewDecoder(enc *Encoding, r io.Reader) io.Reader {\n+\treturn &decoder{enc: enc, r: r}\n+}\n+\n+// DecodedLen returns the maximum length in bytes of the decoded data\n+// corresponding to n bytes of base32-encoded data.\n+func (enc *Encoding) DecodedLen(n int) int { return n / 8 * 5 }"}, {"sha": "792e4dc635d3ad9cd34602f49330ba00d4a9daeb", "filename": "libgo/go/encoding/base32/base32_test.go", "status": "added", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fencoding%2Fbase32%2Fbase32_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fencoding%2Fbase32%2Fbase32_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbase32%2Fbase32_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -0,0 +1,194 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package base32\n+\n+import (\n+\t\"bytes\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"testing\"\n+)\n+\n+type testpair struct {\n+\tdecoded, encoded string\n+}\n+\n+var pairs = []testpair{\n+\t// RFC 4648 examples\n+\t{\"\", \"\"},\n+\t{\"f\", \"MY======\"},\n+\t{\"fo\", \"MZXQ====\"},\n+\t{\"foo\", \"MZXW6===\"},\n+\t{\"foob\", \"MZXW6YQ=\"},\n+\t{\"fooba\", \"MZXW6YTB\"},\n+\t{\"foobar\", \"MZXW6YTBOI======\"},\n+\n+\n+\t// Wikipedia examples, converted to base32\n+\t{\"sure.\", \"ON2XEZJO\"},\n+\t{\"sure\", \"ON2XEZI=\"},\n+\t{\"sur\", \"ON2XE===\"},\n+\t{\"su\", \"ON2Q====\"},\n+\t{\"leasure.\", \"NRSWC43VOJSS4===\"},\n+\t{\"easure.\", \"MVQXG5LSMUXA====\"},\n+\t{\"asure.\", \"MFZXK4TFFY======\"},\n+\t{\"sure.\", \"ON2XEZJO\"},\n+}\n+\n+var bigtest = testpair{\n+\t\"Twas brillig, and the slithy toves\",\n+\t\"KR3WC4ZAMJZGS3DMNFTSYIDBNZSCA5DIMUQHG3DJORUHSIDUN53GK4Y=\",\n+}\n+\n+func testEqual(t *testing.T, msg string, args ...interface{}) bool {\n+\tif args[len(args)-2] != args[len(args)-1] {\n+\t\tt.Errorf(msg, args...)\n+\t\treturn false\n+\t}\n+\treturn true\n+}\n+\n+func TestEncode(t *testing.T) {\n+\tfor _, p := range pairs {\n+\t\tbuf := make([]byte, StdEncoding.EncodedLen(len(p.decoded)))\n+\t\tStdEncoding.Encode(buf, []byte(p.decoded))\n+\t\ttestEqual(t, \"Encode(%q) = %q, want %q\", p.decoded, string(buf), p.encoded)\n+\t}\n+}\n+\n+func TestEncoder(t *testing.T) {\n+\tfor _, p := range pairs {\n+\t\tbb := &bytes.Buffer{}\n+\t\tencoder := NewEncoder(StdEncoding, bb)\n+\t\tencoder.Write([]byte(p.decoded))\n+\t\tencoder.Close()\n+\t\ttestEqual(t, \"Encode(%q) = %q, want %q\", p.decoded, bb.String(), p.encoded)\n+\t}\n+}\n+\n+func TestEncoderBuffering(t *testing.T) {\n+\tinput := []byte(bigtest.decoded)\n+\tfor bs := 1; bs <= 12; bs++ {\n+\t\tbb := &bytes.Buffer{}\n+\t\tencoder := NewEncoder(StdEncoding, bb)\n+\t\tfor pos := 0; pos < len(input); pos += bs {\n+\t\t\tend := pos + bs\n+\t\t\tif end > len(input) {\n+\t\t\t\tend = len(input)\n+\t\t\t}\n+\t\t\tn, err := encoder.Write(input[pos:end])\n+\t\t\ttestEqual(t, \"Write(%q) gave error %v, want %v\", input[pos:end], err, os.Error(nil))\n+\t\t\ttestEqual(t, \"Write(%q) gave length %v, want %v\", input[pos:end], n, end-pos)\n+\t\t}\n+\t\terr := encoder.Close()\n+\t\ttestEqual(t, \"Close gave error %v, want %v\", err, os.Error(nil))\n+\t\ttestEqual(t, \"Encoding/%d of %q = %q, want %q\", bs, bigtest.decoded, bb.String(), bigtest.encoded)\n+\t}\n+}\n+\n+func TestDecode(t *testing.T) {\n+\tfor _, p := range pairs {\n+\t\tdbuf := make([]byte, StdEncoding.DecodedLen(len(p.encoded)))\n+\t\tcount, end, err := StdEncoding.decode(dbuf, []byte(p.encoded))\n+\t\ttestEqual(t, \"Decode(%q) = error %v, want %v\", p.encoded, err, os.Error(nil))\n+\t\ttestEqual(t, \"Decode(%q) = length %v, want %v\", p.encoded, count, len(p.decoded))\n+\t\tif len(p.encoded) > 0 {\n+\t\t\ttestEqual(t, \"Decode(%q) = end %v, want %v\", p.encoded, end, (p.encoded[len(p.encoded)-1] == '='))\n+\t\t}\n+\t\ttestEqual(t, \"Decode(%q) = %q, want %q\", p.encoded,\n+\t\t\tstring(dbuf[0:count]),\n+\t\t\tp.decoded)\n+\t}\n+}\n+\n+func TestDecoder(t *testing.T) {\n+\tfor _, p := range pairs {\n+\t\tdecoder := NewDecoder(StdEncoding, bytes.NewBufferString(p.encoded))\n+\t\tdbuf := make([]byte, StdEncoding.DecodedLen(len(p.encoded)))\n+\t\tcount, err := decoder.Read(dbuf)\n+\t\tif err != nil && err != os.EOF {\n+\t\t\tt.Fatal(\"Read failed\", err)\n+\t\t}\n+\t\ttestEqual(t, \"Read from %q = length %v, want %v\", p.encoded, count, len(p.decoded))\n+\t\ttestEqual(t, \"Decoding of %q = %q, want %q\", p.encoded, string(dbuf[0:count]), p.decoded)\n+\t\tif err != os.EOF {\n+\t\t\tcount, err = decoder.Read(dbuf)\n+\t\t}\n+\t\ttestEqual(t, \"Read from %q = %v, want %v\", p.encoded, err, os.EOF)\n+\t}\n+}\n+\n+func TestDecoderBuffering(t *testing.T) {\n+\tfor bs := 1; bs <= 12; bs++ {\n+\t\tdecoder := NewDecoder(StdEncoding, bytes.NewBufferString(bigtest.encoded))\n+\t\tbuf := make([]byte, len(bigtest.decoded)+12)\n+\t\tvar total int\n+\t\tfor total = 0; total < len(bigtest.decoded); {\n+\t\t\tn, err := decoder.Read(buf[total : total+bs])\n+\t\t\ttestEqual(t, \"Read from %q at pos %d = %d, %v, want _, %v\", bigtest.encoded, total, n, err, os.Error(nil))\n+\t\t\ttotal += n\n+\t\t}\n+\t\ttestEqual(t, \"Decoding/%d of %q = %q, want %q\", bs, bigtest.encoded, string(buf[0:total]), bigtest.decoded)\n+\t}\n+}\n+\n+func TestDecodeCorrupt(t *testing.T) {\n+\ttype corrupt struct {\n+\t\te string\n+\t\tp int\n+\t}\n+\texamples := []corrupt{\n+\t\t{\"!!!!\", 0},\n+\t\t{\"x===\", 0},\n+\t\t{\"AA=A====\", 2},\n+\t\t{\"AAA=AAAA\", 3},\n+\t\t{\"MMMMMMMMM\", 8},\n+\t\t{\"MMMMMM\", 0},\n+\t}\n+\n+\tfor _, e := range examples {\n+\t\tdbuf := make([]byte, StdEncoding.DecodedLen(len(e.e)))\n+\t\t_, err := StdEncoding.Decode(dbuf, []byte(e.e))\n+\t\tswitch err := err.(type) {\n+\t\tcase CorruptInputError:\n+\t\t\ttestEqual(t, \"Corruption in %q at offset %v, want %v\", e.e, int(err), e.p)\n+\t\tdefault:\n+\t\t\tt.Error(\"Decoder failed to detect corruption in\", e)\n+\t\t}\n+\t}\n+}\n+\n+func TestBig(t *testing.T) {\n+\tn := 3*1000 + 1\n+\traw := make([]byte, n)\n+\tconst alpha = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n+\tfor i := 0; i < n; i++ {\n+\t\traw[i] = alpha[i%len(alpha)]\n+\t}\n+\tencoded := new(bytes.Buffer)\n+\tw := NewEncoder(StdEncoding, encoded)\n+\tnn, err := w.Write(raw)\n+\tif nn != n || err != nil {\n+\t\tt.Fatalf(\"Encoder.Write(raw) = %d, %v want %d, nil\", nn, err, n)\n+\t}\n+\terr = w.Close()\n+\tif err != nil {\n+\t\tt.Fatalf(\"Encoder.Close() = %v want nil\", err)\n+\t}\n+\tdecoded, err := ioutil.ReadAll(NewDecoder(StdEncoding, encoded))\n+\tif err != nil {\n+\t\tt.Fatalf(\"ioutil.ReadAll(NewDecoder(...)): %v\", err)\n+\t}\n+\n+\tif !bytes.Equal(raw, decoded) {\n+\t\tvar i int\n+\t\tfor i = 0; i < len(decoded) && i < len(raw); i++ {\n+\t\t\tif decoded[i] != raw[i] {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t\tt.Errorf(\"Decode(Encode(%d-byte string)) failed at offset %d\", n, i)\n+\t}\n+}"}, {"sha": "77ff3a9f3ef4671c7f61742f222470316fdaa923", "filename": "libgo/go/encoding/binary/binary.go", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -198,6 +198,10 @@ func sizeof(v reflect.Type) int {\n \t\treturn sum\n \n \tcase *reflect.UintType, *reflect.IntType, *reflect.FloatType, *reflect.ComplexType:\n+\t\tswitch t := t.Kind(); t {\n+\t\tcase reflect.Int, reflect.Uint, reflect.Uintptr:\n+\t\t\treturn -1\n+\t\t}\n \t\treturn int(v.Size())\n \t}\n \treturn -1\n@@ -327,12 +331,12 @@ func (d *decoder) value(v reflect.Value) {\n \tcase *reflect.ComplexValue:\n \t\tswitch v.Type().Kind() {\n \t\tcase reflect.Complex64:\n-\t\t\tv.Set(cmplx(\n+\t\t\tv.Set(complex(\n \t\t\t\tfloat64(math.Float32frombits(d.uint32())),\n \t\t\t\tfloat64(math.Float32frombits(d.uint32())),\n \t\t\t))\n \t\tcase reflect.Complex128:\n-\t\t\tv.Set(cmplx(\n+\t\t\tv.Set(complex(\n \t\t\t\tmath.Float64frombits(d.uint64()),\n \t\t\t\tmath.Float64frombits(d.uint64()),\n \t\t\t))"}, {"sha": "e09ec489fd4cdd5fcea324a733d3fe73ab5057c7", "filename": "libgo/go/encoding/binary/binary_test.go", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -28,6 +28,13 @@ type Struct struct {\n \tArray      [4]uint8\n }\n \n+type T struct {\n+\tInt     int\n+\tUint    uint\n+\tUintptr uintptr\n+\tArray   [4]int\n+}\n+\n var s = Struct{\n \t0x01,\n \t0x0203,\n@@ -40,11 +47,11 @@ var s = Struct{\n \n \tmath.Float32frombits(0x1f202122),\n \tmath.Float64frombits(0x232425262728292a),\n-\tcmplx(\n+\tcomplex(\n \t\tmath.Float32frombits(0x2b2c2d2e),\n \t\tmath.Float32frombits(0x2f303132),\n \t),\n-\tcmplx(\n+\tcomplex(\n \t\tmath.Float64frombits(0x333435363738393a),\n \t\tmath.Float64frombits(0x3b3c3d3e3f404142),\n \t),\n@@ -136,3 +143,20 @@ func TestWriteSlice(t *testing.T) {\n \terr := Write(buf, BigEndian, res)\n \tcheckResult(t, \"WriteSlice\", BigEndian, err, buf.Bytes(), src)\n }\n+\n+func TestWriteT(t *testing.T) {\n+\tbuf := new(bytes.Buffer)\n+\tts := T{}\n+\terr := Write(buf, BigEndian, ts)\n+\tif err == nil {\n+\t\tt.Errorf(\"WriteT: have nil, want non-nil\")\n+\t}\n+\n+\ttv := reflect.Indirect(reflect.NewValue(ts)).(*reflect.StructValue)\n+\tfor i, n := 0, tv.NumField(); i < n; i++ {\n+\t\terr = Write(buf, BigEndian, tv.Field(i).Interface())\n+\t\tif err == nil {\n+\t\t\tt.Errorf(\"WriteT.%v: have nil, want non-nil\", tv.Field(i).Type())\n+\t\t}\n+\t}\n+}"}, {"sha": "92dddcb996d9011fa9ae477bfedc80b9338eef48", "filename": "libgo/go/encoding/line/line.go", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fencoding%2Fline%2Fline.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fencoding%2Fline%2Fline.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fline%2Fline.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -0,0 +1,95 @@\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// This package implements a Reader which handles reading \\r and \\r\\n\n+// deliminated lines.\n+package line\n+\n+import (\n+\t\"io\"\n+\t\"os\"\n+)\n+\n+// Reader reads lines from an io.Reader (which may use either '\\n' or\n+// '\\r\\n').\n+type Reader struct {\n+\tbuf      []byte\n+\tconsumed int\n+\tin       io.Reader\n+\terr      os.Error\n+}\n+\n+func NewReader(in io.Reader, maxLineLength int) *Reader {\n+\treturn &Reader{\n+\t\tbuf:      make([]byte, 0, maxLineLength),\n+\t\tconsumed: 0,\n+\t\tin:       in,\n+\t}\n+}\n+\n+// ReadLine tries to return a single line, not including the end-of-line bytes.\n+// If the line was found to be longer than the maximum length then isPrefix is\n+// set and the beginning of the line is returned. The rest of the line will be\n+// returned from future calls. isPrefix will be false when returning the last\n+// fragment of the line.  The returned buffer points into the internal state of\n+// the Reader and is only valid until the next call to ReadLine. ReadLine\n+// either returns a non-nil line or it returns an error, never both.\n+func (l *Reader) ReadLine() (line []byte, isPrefix bool, err os.Error) {\n+\tif l.consumed > 0 {\n+\t\tn := copy(l.buf, l.buf[l.consumed:])\n+\t\tl.buf = l.buf[:n]\n+\t\tl.consumed = 0\n+\t}\n+\n+\tif len(l.buf) == 0 && l.err != nil {\n+\t\terr = l.err\n+\t\treturn\n+\t}\n+\n+\tscannedTo := 0\n+\n+\tfor {\n+\t\ti := scannedTo\n+\t\tfor ; i < len(l.buf); i++ {\n+\t\t\tif l.buf[i] == '\\r' && len(l.buf) > i+1 && l.buf[i+1] == '\\n' {\n+\t\t\t\tline = l.buf[:i]\n+\t\t\t\tl.consumed = i + 2\n+\t\t\t\treturn\n+\t\t\t} else if l.buf[i] == '\\n' {\n+\t\t\t\tline = l.buf[:i]\n+\t\t\t\tl.consumed = i + 1\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\n+\t\tif i == cap(l.buf) {\n+\t\t\tline = l.buf[:i]\n+\t\t\tl.consumed = i\n+\t\t\tisPrefix = true\n+\t\t\treturn\n+\t\t}\n+\n+\t\tif l.err != nil {\n+\t\t\tline = l.buf\n+\t\t\tl.consumed = i\n+\t\t\treturn\n+\t\t}\n+\n+\t\t// We don't want to rescan the input that we just scanned.\n+\t\t// However, we need to back up one byte because the last byte\n+\t\t// could have been a '\\r' and we do need to rescan that.\n+\t\tscannedTo = i\n+\t\tif scannedTo > 0 {\n+\t\t\tscannedTo--\n+\t\t}\n+\t\toldLen := len(l.buf)\n+\t\tl.buf = l.buf[:cap(l.buf)]\n+\t\tn, readErr := l.in.Read(l.buf[oldLen:])\n+\t\tl.buf = l.buf[:oldLen+n]\n+\t\tif readErr != nil {\n+\t\t\tl.err = readErr\n+\t\t}\n+\t}\n+\tpanic(\"unreachable\")\n+}"}, {"sha": "68d13b58616a5dfc38901257da790b6bff8cbc96", "filename": "libgo/go/encoding/line/line_test.go", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fencoding%2Fline%2Fline_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fencoding%2Fline%2Fline_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fline%2Fline_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -0,0 +1,89 @@\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package line\n+\n+import (\n+\t\"bytes\"\n+\t\"os\"\n+\t\"testing\"\n+)\n+\n+var testOutput = []byte(\"0123456789abcdefghijklmnopqrstuvwxy\")\n+var testInput = []byte(\"012\\n345\\n678\\n9ab\\ncde\\nfgh\\nijk\\nlmn\\nopq\\nrst\\nuvw\\nxy\")\n+var testInputrn = []byte(\"012\\r\\n345\\r\\n678\\r\\n9ab\\r\\ncde\\r\\nfgh\\r\\nijk\\r\\nlmn\\r\\nopq\\r\\nrst\\r\\nuvw\\r\\nxy\\r\\n\\n\\r\\n\")\n+\n+// TestReader wraps a []byte and returns reads of a specific length.\n+type testReader struct {\n+\tdata   []byte\n+\tstride int\n+}\n+\n+func (t *testReader) Read(buf []byte) (n int, err os.Error) {\n+\tn = t.stride\n+\tif n > len(t.data) {\n+\t\tn = len(t.data)\n+\t}\n+\tif n > len(buf) {\n+\t\tn = len(buf)\n+\t}\n+\tcopy(buf, t.data)\n+\tt.data = t.data[n:]\n+\tif len(t.data) == 0 {\n+\t\terr = os.EOF\n+\t}\n+\treturn\n+}\n+\n+func testLineReader(t *testing.T, input []byte) {\n+\tfor stride := 1; stride < len(input); stride++ {\n+\t\tdone := 0\n+\t\treader := testReader{input, stride}\n+\t\tl := NewReader(&reader, len(input)+1)\n+\t\tfor {\n+\t\t\tline, isPrefix, err := l.ReadLine()\n+\t\t\tif len(line) > 0 && err != nil {\n+\t\t\t\tt.Errorf(\"ReadLine returned both data and error: %s\", err)\n+\t\t\t}\n+\t\t\tif isPrefix {\n+\t\t\t\tt.Errorf(\"ReadLine returned prefix\")\n+\t\t\t}\n+\t\t\tif err != nil {\n+\t\t\t\tif err != os.EOF {\n+\t\t\t\t\tt.Fatalf(\"Got unknown error: %s\", err)\n+\t\t\t\t}\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tif want := testOutput[done : done+len(line)]; !bytes.Equal(want, line) {\n+\t\t\t\tt.Errorf(\"Bad line at stride %d: want: %x got: %x\", stride, want, line)\n+\t\t\t}\n+\t\t\tdone += len(line)\n+\t\t}\n+\t\tif done != len(testOutput) {\n+\t\t\tt.Error(\"ReadLine didn't return everything\")\n+\t\t}\n+\t}\n+}\n+\n+func TestReader(t *testing.T) {\n+\ttestLineReader(t, testInput)\n+\ttestLineReader(t, testInputrn)\n+}\n+\n+func TestLineTooLong(t *testing.T) {\n+\tbuf := bytes.NewBuffer([]byte(\"aaabbbcc\\n\"))\n+\tl := NewReader(buf, 3)\n+\tline, isPrefix, err := l.ReadLine()\n+\tif !isPrefix || !bytes.Equal(line, []byte(\"aaa\")) || err != nil {\n+\t\tt.Errorf(\"bad result for first line: %x %s\", line, err)\n+\t}\n+\tline, isPrefix, err = l.ReadLine()\n+\tif !isPrefix || !bytes.Equal(line, []byte(\"bbb\")) || err != nil {\n+\t\tt.Errorf(\"bad result for second line: %x\", line)\n+\t}\n+\tline, isPrefix, err = l.ReadLine()\n+\tif isPrefix || !bytes.Equal(line, []byte(\"cc\")) || err != nil {\n+\t\tt.Errorf(\"bad result for third line: %x\", line)\n+\t}\n+}"}, {"sha": "3a3d3b1a53ed05c706eba2926e6dd7c76ce12df7", "filename": "libgo/go/exec/exec_test.go", "status": "modified", "additions": 17, "deletions": 25, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fexec%2Fexec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fexec%2Fexec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexec%2Fexec_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -9,15 +9,23 @@ import (\n \t\"io/ioutil\"\n \t\"testing\"\n \t\"os\"\n+\t\"runtime\"\n )\n \n-func TestRunCat(t *testing.T) {\n-\tcat, err := LookPath(\"cat\")\n+func run(argv []string, stdin, stdout, stderr int) (p *Cmd, err os.Error) {\n+\tif runtime.GOOS == \"windows\" {\n+\t\targv = append([]string{\"cmd\", \"/c\"}, argv...)\n+\t}\n+\texe, err := LookPath(argv[0])\n \tif err != nil {\n-\t\tt.Fatal(\"cat: \", err)\n+\t\treturn nil, err\n \t}\n-\tcmd, err := Run(cat, []string{\"cat\"}, nil, \"\",\n-\t\tPipe, Pipe, DevNull)\n+\tp, err = Run(exe, argv, nil, \"\", stdin, stdout, stderr)\n+\treturn p, err\n+}\n+\n+func TestRunCat(t *testing.T) {\n+\tcmd, err := run([]string{\"cat\"}, Pipe, Pipe, DevNull)\n \tif err != nil {\n \t\tt.Fatal(\"run:\", err)\n \t}\n@@ -36,11 +44,7 @@ func TestRunCat(t *testing.T) {\n }\n \n func TestRunEcho(t *testing.T) {\n-\techo, err := LookPath(\"echo\")\n-\tif err != nil {\n-\t\tt.Fatal(\"echo: \", err)\n-\t}\n-\tcmd, err := Run(echo, []string{\"echo\", \"hello\", \"world\"}, nil, \"\",\n+\tcmd, err := run([]string{\"sh\", \"-c\", \"echo hello world\"},\n \t\tDevNull, Pipe, DevNull)\n \tif err != nil {\n \t\tt.Fatal(\"run:\", err)\n@@ -58,11 +62,7 @@ func TestRunEcho(t *testing.T) {\n }\n \n func TestStderr(t *testing.T) {\n-\tsh, err := LookPath(\"sh\")\n-\tif err != nil {\n-\t\tt.Fatal(\"sh: \", err)\n-\t}\n-\tcmd, err := Run(sh, []string{\"sh\", \"-c\", \"echo hello world 1>&2\"}, nil, \"\",\n+\tcmd, err := run([]string{\"sh\", \"-c\", \"echo hello world 1>&2\"},\n \t\tDevNull, DevNull, Pipe)\n \tif err != nil {\n \t\tt.Fatal(\"run:\", err)\n@@ -80,11 +80,7 @@ func TestStderr(t *testing.T) {\n }\n \n func TestMergeWithStdout(t *testing.T) {\n-\tsh, err := LookPath(\"sh\")\n-\tif err != nil {\n-\t\tt.Fatal(\"sh: \", err)\n-\t}\n-\tcmd, err := Run(sh, []string{\"sh\", \"-c\", \"echo hello world 1>&2\"}, nil, \"\",\n+\tcmd, err := run([]string{\"sh\", \"-c\", \"echo hello world 1>&2\"},\n \t\tDevNull, Pipe, MergeWithStdout)\n \tif err != nil {\n \t\tt.Fatal(\"run:\", err)\n@@ -106,11 +102,7 @@ func TestAddEnvVar(t *testing.T) {\n \tif err != nil {\n \t\tt.Fatal(\"setenv:\", err)\n \t}\n-\tsh, err := LookPath(\"sh\")\n-\tif err != nil {\n-\t\tt.Fatal(\"sh: \", err)\n-\t}\n-\tcmd, err := Run(sh, []string{\"sh\", \"-c\", \"echo $NEWVAR\"}, nil, \"\",\n+\tcmd, err := run([]string{\"sh\", \"-c\", \"echo $NEWVAR\"},\n \t\tDevNull, Pipe, DevNull)\n \tif err != nil {\n \t\tt.Fatal(\"run:\", err)"}, {"sha": "292e24fccddd20b3efeb843392de59506c39a210", "filename": "libgo/go/exec/lp_unix.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fexec%2Flp_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fexec%2Flp_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexec%2Flp_unix.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -29,7 +29,7 @@ func LookPath(file string) (string, os.Error) {\n \t\tif canExec(file) {\n \t\t\treturn file, nil\n \t\t}\n-\t\treturn \"\", os.ENOENT\n+\t\treturn \"\", &os.PathError{\"lookpath\", file, os.ENOENT}\n \t}\n \tpathenv := os.Getenv(\"PATH\")\n \tfor _, dir := range strings.Split(pathenv, \":\", -1) {\n@@ -41,5 +41,5 @@ func LookPath(file string) (string, os.Error) {\n \t\t\treturn dir + \"/\" + file, nil\n \t\t}\n \t}\n-\treturn \"\", os.ENOENT\n+\treturn \"\", &os.PathError{\"lookpath\", file, os.ENOENT}\n }"}, {"sha": "7b56afa85664fc40ad76e38ae09fd7258db9843e", "filename": "libgo/go/exec/lp_windows.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fexec%2Flp_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fexec%2Flp_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexec%2Flp_windows.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -49,7 +49,7 @@ func LookPath(file string) (string, os.Error) {\n \t\tif f, ok := canExec(file, exts); ok {\n \t\t\treturn f, nil\n \t\t}\n-\t\treturn ``, os.ENOENT\n+\t\treturn ``, &os.PathError{\"lookpath\", file, os.ENOENT}\n \t}\n \tif pathenv := os.Getenv(`PATH`); pathenv == `` {\n \t\tif f, ok := canExec(`.\\`+file, exts); ok {\n@@ -62,5 +62,5 @@ func LookPath(file string) (string, os.Error) {\n \t\t\t}\n \t\t}\n \t}\n-\treturn ``, os.ENOENT\n+\treturn ``, &os.PathError{\"lookpath\", file, os.ENOENT}\n }"}, {"sha": "ccc0d0051fd5b990c11713aa4aa581821826234c", "filename": "libgo/go/exp/4s/4s.go", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6ed1c8903e728f4233122554bab5910853338bd/libgo%2Fgo%2Fexp%2F4s%2F4s.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6ed1c8903e728f4233122554bab5910853338bd/libgo%2Fgo%2Fexp%2F4s%2F4s.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2F4s%2F4s.go?ref=d6ed1c8903e728f4233122554bab5910853338bd", "patch": "@@ -1,77 +0,0 @@\n-// Copyright 2009 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// This is a simple demo of Go running under Native Client.\n-// It is a tetris clone built on top of the exp/nacl/av and exp/draw\n-// packages.\n-//\n-// See ../nacl/README for how to run it.\n-package main\n-\n-import (\n-\t\"exp/nacl/av\"\n-\t\"exp/nacl/srpc\"\n-\t\"log\"\n-\t\"runtime\"\n-\t\"os\"\n-)\n-\n-var sndc chan []uint16\n-\n-func main() {\n-\t// Native Client requires that some calls are issued\n-\t// consistently by the same OS thread.\n-\truntime.LockOSThread()\n-\n-\tif srpc.Enabled() {\n-\t\tgo srpc.ServeRuntime()\n-\t}\n-\n-\targs := os.Args\n-\tp := pieces4\n-\tif len(args) > 1 && args[1] == \"-5\" {\n-\t\tp = pieces5\n-\t}\n-\tdx, dy := 500, 500\n-\tw, err := av.Init(av.SubsystemVideo|av.SubsystemAudio, dx, dy)\n-\tif err != nil {\n-\t\tlog.Exit(err)\n-\t}\n-\n-\tsndc = make(chan []uint16, 10)\n-\tgo audioServer()\n-\tPlay(p, w)\n-}\n-\n-func audioServer() {\n-\t// Native Client requires that all audio calls\n-\t// original from a single OS thread.\n-\truntime.LockOSThread()\n-\n-\tn, err := av.AudioStream(nil)\n-\tif err != nil {\n-\t\tlog.Exit(err)\n-\t}\n-\tfor {\n-\t\tb := <-sndc\n-\t\tfor len(b)*2 >= n {\n-\t\t\tvar a []uint16\n-\t\t\ta, b = b[0:n/2], b[n/2:]\n-\t\t\tn, err = av.AudioStream(a)\n-\t\t\tif err != nil {\n-\t\t\t\tlog.Exit(err)\n-\t\t\t}\n-\t\t\tprintln(n, len(b)*2)\n-\t\t}\n-\t\ta := make([]uint16, n/2)\n-\t\tcopy(a, b)\n-\t\tn, err = av.AudioStream(a)\n-\t}\n-}\n-\n-func PlaySound(b []uint16) { sndc <- b }\n-\n-var whoosh = []uint16{\n-// Insert your favorite sound samples here.\n-}"}, {"sha": "efeb6f1163dbc0113c8b78f5555bb998a61bbace", "filename": "libgo/go/exp/4s/5s.go", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6ed1c8903e728f4233122554bab5910853338bd/libgo%2Fgo%2Fexp%2F4s%2F5s.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6ed1c8903e728f4233122554bab5910853338bd/libgo%2Fgo%2Fexp%2F4s%2F5s.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2F4s%2F5s.go?ref=d6ed1c8903e728f4233122554bab5910853338bd", "patch": "@@ -1,9 +0,0 @@\n-// Copyright 2009 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Hack to produce a binary that defaults to 5s.\n-\n-package main\n-\n-func init() { pieces4 = pieces5 }"}, {"sha": "9e2a045fe75bd8f8dde12116f95b8cd2927817e3", "filename": "libgo/go/exp/4s/data.go", "status": "removed", "additions": 0, "deletions": 142, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6ed1c8903e728f4233122554bab5910853338bd/libgo%2Fgo%2Fexp%2F4s%2Fdata.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6ed1c8903e728f4233122554bab5910853338bd/libgo%2Fgo%2Fexp%2F4s%2Fdata.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2F4s%2Fdata.go?ref=d6ed1c8903e728f4233122554bab5910853338bd", "patch": "@@ -1,142 +0,0 @@\n-// games/4s - a tetris clone\n-//\n-// Derived from Plan 9's /sys/src/games/xs.c\n-// http://plan9.bell-labs.com/sources/plan9/sys/src/games/xs.c\n-//\n-// Copyright (C) 2003, Lucent Technologies Inc. and others. All Rights Reserved.\n-// Portions Copyright 2009 The Go Authors.  All Rights Reserved.\n-// Distributed under the terms of the Lucent Public License Version 1.02\n-// See http://plan9.bell-labs.com/plan9/license.html\n-\n-package main\n-\n-import . \"image\"\n-\n-var pieces4 = []Piece{\n-\t{0, 0, Point{4, 1}, []Point{{0, 0}, {1, 0}, {1, 0}, {1, 0}}, nil, nil},\n-\t{1, 0, Point{1, 4}, []Point{{0, 0}, {0, 1}, {0, 1}, {0, 1}}, nil, nil},\n-\t{2, 0, Point{4, 1}, []Point{{0, 0}, {1, 0}, {1, 0}, {1, 0}}, nil, nil},\n-\t{3, 0, Point{1, 4}, []Point{{0, 0}, {0, 1}, {0, 1}, {0, 1}}, nil, nil},\n-\n-\t{0, 3, Point{2, 2}, []Point{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}, nil, nil},\n-\t{1, 3, Point{2, 2}, []Point{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}, nil, nil},\n-\t{2, 3, Point{2, 2}, []Point{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}, nil, nil},\n-\t{3, 3, Point{2, 2}, []Point{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}, nil, nil},\n-\n-\t{0, 1, Point{3, 2}, []Point{{0, 0}, {1, 0}, {1, 0}, {0, 1}}, nil, nil},\n-\t{1, 1, Point{2, 3}, []Point{{1, 0}, {0, 1}, {0, 1}, {-1, 0}}, nil, nil},\n-\t{2, 1, Point{3, 2}, []Point{{0, 0}, {0, 1}, {1, 0}, {1, 0}}, nil, nil},\n-\t{3, 1, Point{2, 3}, []Point{{0, 0}, {1, 0}, {-1, 1}, {0, 1}}, nil, nil},\n-\n-\t{0, 2, Point{3, 2}, []Point{{0, 1}, {1, 0}, {1, 0}, {0, -1}}, nil, nil},\n-\t{1, 2, Point{2, 3}, []Point{{0, 0}, {0, 1}, {0, 1}, {1, 0}}, nil, nil},\n-\t{2, 2, Point{3, 2}, []Point{{0, 0}, {1, 0}, {1, 0}, {-2, 1}}, nil, nil},\n-\t{3, 2, Point{2, 3}, []Point{{0, 0}, {1, 0}, {0, 1}, {0, 1}}, nil, nil},\n-\n-\t{0, 4, Point{3, 2}, []Point{{0, 0}, {1, 0}, {1, 0}, {-1, 1}}, nil, nil},\n-\t{1, 4, Point{2, 3}, []Point{{1, 0}, {-1, 1}, {1, 0}, {0, 1}}, nil, nil},\n-\t{2, 4, Point{3, 2}, []Point{{1, 0}, {-1, 1}, {1, 0}, {1, 0}}, nil, nil},\n-\t{3, 4, Point{2, 3}, []Point{{0, 0}, {0, 1}, {0, 1}, {1, -1}}, nil, nil},\n-\n-\t{0, 5, Point{3, 2}, []Point{{0, 0}, {1, 0}, {0, 1}, {1, 0}}, nil, nil},\n-\t{1, 5, Point{2, 3}, []Point{{1, 0}, {0, 1}, {-1, 0}, {0, 1}}, nil, nil},\n-\t{2, 5, Point{3, 2}, []Point{{0, 0}, {1, 0}, {0, 1}, {1, 0}}, nil, nil},\n-\t{3, 5, Point{2, 3}, []Point{{1, 0}, {0, 1}, {-1, 0}, {0, 1}}, nil, nil},\n-\n-\t{0, 6, Point{3, 2}, []Point{{0, 1}, {1, 0}, {0, -1}, {1, 0}}, nil, nil},\n-\t{1, 6, Point{2, 3}, []Point{{0, 0}, {0, 1}, {1, 0}, {0, 1}}, nil, nil},\n-\t{2, 6, Point{3, 2}, []Point{{0, 1}, {1, 0}, {0, -1}, {1, 0}}, nil, nil},\n-\t{3, 6, Point{2, 3}, []Point{{0, 0}, {0, 1}, {1, 0}, {0, 1}}, nil, nil},\n-}\n-\n-var pieces5 = []Piece{\n-\t{0, 1, Point{5, 1}, []Point{{0, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}}, nil, nil},\n-\t{1, 1, Point{1, 5}, []Point{{0, 0}, {0, 1}, {0, 1}, {0, 1}, {0, 1}}, nil, nil},\n-\t{2, 1, Point{5, 1}, []Point{{0, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}}, nil, nil},\n-\t{3, 1, Point{1, 5}, []Point{{0, 0}, {0, 1}, {0, 1}, {0, 1}, {0, 1}}, nil, nil},\n-\n-\t{0, 0, Point{4, 2}, []Point{{0, 0}, {1, 0}, {1, 0}, {1, 0}, {0, 1}}, nil, nil},\n-\t{1, 0, Point{2, 4}, []Point{{1, 0}, {0, 1}, {0, 1}, {0, 1}, {-1, 0}}, nil, nil},\n-\t{2, 0, Point{4, 2}, []Point{{0, 0}, {0, 1}, {1, 0}, {1, 0}, {1, 0}}, nil, nil},\n-\t{3, 0, Point{2, 4}, []Point{{0, 0}, {1, 0}, {-1, 1}, {0, 1}, {0, 1}}, nil, nil},\n-\n-\t{0, 2, Point{4, 2}, []Point{{0, 0}, {0, 1}, {1, -1}, {1, 0}, {1, 0}}, nil, nil},\n-\t{1, 2, Point{2, 4}, []Point{{0, 0}, {1, 0}, {0, 1}, {0, 1}, {0, 1}}, nil, nil},\n-\t{2, 2, Point{4, 2}, []Point{{0, 1}, {1, 0}, {1, 0}, {1, 0}, {0, -1}}, nil, nil},\n-\t{3, 2, Point{2, 4}, []Point{{0, 0}, {0, 1}, {0, 1}, {0, 1}, {1, 0}}, nil, nil},\n-\n-\t{0, 7, Point{3, 3}, []Point{{0, 0}, {1, 0}, {1, 0}, {0, 1}, {0, 1}}, nil, nil},\n-\t{1, 7, Point{3, 3}, []Point{{0, 2}, {1, 0}, {1, 0}, {0, -1}, {0, -1}}, nil, nil},\n-\t{2, 7, Point{3, 3}, []Point{{0, 0}, {0, 1}, {0, 1}, {1, 0}, {1, 0}}, nil, nil},\n-\t{3, 7, Point{3, 3}, []Point{{0, 2}, {0, -1}, {0, -1}, {1, 0}, {1, 0}}, nil, nil},\n-\n-\t{0, 3, Point{3, 2}, []Point{{0, 0}, {1, 0}, {1, 0}, {-2, 1}, {1, 0}}, nil, nil},\n-\t{1, 3, Point{2, 3}, []Point{{0, 0}, {1, 0}, {-1, 1}, {1, 0}, {0, 1}}, nil, nil},\n-\t{2, 3, Point{3, 2}, []Point{{1, 0}, {1, 0}, {-2, 1}, {1, 0}, {1, 0}}, nil, nil},\n-\t{3, 3, Point{2, 3}, []Point{{0, 0}, {0, 1}, {1, 0}, {-1, 1}, {1, 0}}, nil, nil},\n-\n-\t{0, 4, Point{3, 2}, []Point{{0, 0}, {1, 0}, {1, 0}, {-1, 1}, {1, 0}}, nil, nil},\n-\t{1, 4, Point{2, 3}, []Point{{1, 0}, {-1, 1}, {1, 0}, {-1, 1}, {1, 0}}, nil, nil},\n-\t{2, 4, Point{3, 2}, []Point{{0, 0}, {1, 0}, {-1, 1}, {1, 0}, {1, 0}}, nil, nil},\n-\t{3, 4, Point{2, 3}, []Point{{0, 0}, {1, 0}, {-1, 1}, {1, 0}, {-1, 1}}, nil, nil},\n-\n-\t{0, 7, Point{3, 2}, []Point{{0, 0}, {2, 0}, {-2, 1}, {1, 0}, {1, 0}}, nil, nil},\n-\t{1, 7, Point{2, 3}, []Point{{0, 0}, {1, 0}, {-1, 1}, {0, 1}, {1, 0}}, nil, nil},\n-\t{2, 7, Point{3, 2}, []Point{{0, 0}, {1, 0}, {1, 0}, {-2, 1}, {2, 0}}, nil, nil},\n-\t{3, 7, Point{2, 3}, []Point{{0, 0}, {1, 0}, {0, 1}, {-1, 1}, {1, 0}}, nil, nil},\n-\n-\t{0, 5, Point{3, 3}, []Point{{0, 0}, {1, 0}, {0, 1}, {1, 0}, {-1, 1}}, nil, nil},\n-\t{1, 5, Point{3, 3}, []Point{{2, 0}, {-2, 1}, {1, 0}, {1, 0}, {-1, 1}}, nil, nil},\n-\t{2, 5, Point{3, 3}, []Point{{1, 0}, {-1, 1}, {1, 0}, {0, 1}, {1, 0}}, nil, nil},\n-\t{3, 5, Point{3, 3}, []Point{{1, 0}, {-1, 1}, {1, 0}, {1, 0}, {-2, 1}}, nil, nil},\n-\n-\t{0, 6, Point{3, 3}, []Point{{1, 0}, {1, 0}, {-2, 1}, {1, 0}, {0, 1}}, nil, nil},\n-\t{1, 6, Point{3, 3}, []Point{{1, 0}, {-1, 1}, {1, 0}, {1, 0}, {0, 1}}, nil, nil},\n-\t{2, 6, Point{3, 3}, []Point{{1, 0}, {0, 1}, {1, 0}, {-2, 1}, {1, 0}}, nil, nil},\n-\t{3, 6, Point{3, 3}, []Point{{0, 0}, {0, 1}, {1, 0}, {1, 0}, {-1, 1}}, nil, nil},\n-\n-\t{0, 0, Point{4, 2}, []Point{{0, 0}, {1, 0}, {1, 0}, {1, 0}, {-2, 1}}, nil, nil},\n-\t{1, 0, Point{2, 4}, []Point{{1, 0}, {-1, 1}, {1, 0}, {0, 1}, {0, 1}}, nil, nil},\n-\t{2, 0, Point{4, 2}, []Point{{2, 0}, {-2, 1}, {1, 0}, {1, 0}, {1, 0}}, nil, nil},\n-\t{3, 0, Point{2, 4}, []Point{{0, 0}, {0, 1}, {0, 1}, {1, 0}, {-1, 1}}, nil, nil},\n-\n-\t{0, 2, Point{4, 2}, []Point{{0, 0}, {1, 0}, {1, 0}, {1, 0}, {-1, 1}}, nil, nil},\n-\t{1, 2, Point{2, 4}, []Point{{1, 0}, {0, 1}, {-1, 1}, {1, 0}, {0, 1}}, nil, nil},\n-\t{2, 2, Point{4, 2}, []Point{{1, 0}, {-1, 1}, {1, 0}, {1, 0}, {1, 0}}, nil, nil},\n-\t{3, 2, Point{2, 4}, []Point{{0, 0}, {0, 1}, {1, 0}, {-1, 1}, {0, 1}}, nil, nil},\n-\n-\t{0, 1, Point{3, 3}, []Point{{0, 0}, {1, 0}, {0, 1}, {1, 0}, {0, 1}}, nil, nil},\n-\t{1, 1, Point{3, 3}, []Point{{2, 0}, {-1, 1}, {1, 0}, {-2, 1}, {1, 0}}, nil, nil},\n-\t{2, 1, Point{3, 3}, []Point{{0, 0}, {0, 1}, {1, 0}, {0, 1}, {1, 0}}, nil, nil},\n-\t{3, 1, Point{3, 3}, []Point{{1, 0}, {1, 0}, {-2, 1}, {1, 0}, {-1, 1}}, nil, nil},\n-\n-\t{0, 3, Point{3, 3}, []Point{{0, 0}, {1, 0}, {1, 0}, {-1, 1}, {0, 1}}, nil, nil},\n-\t{1, 3, Point{3, 3}, []Point{{2, 0}, {-2, 1}, {1, 0}, {1, 0}, {0, 1}}, nil, nil},\n-\t{2, 3, Point{3, 3}, []Point{{1, 0}, {0, 1}, {-1, 1}, {1, 0}, {1, 0}}, nil, nil},\n-\t{3, 3, Point{3, 3}, []Point{{0, 0}, {0, 1}, {1, 0}, {1, 0}, {-2, 1}}, nil, nil},\n-\n-\t{0, 4, Point{3, 3}, []Point{{1, 0}, {-1, 1}, {1, 0}, {1, 0}, {-1, 1}}, nil, nil},\n-\t{1, 4, Point{3, 3}, []Point{{1, 0}, {-1, 1}, {1, 0}, {1, 0}, {-1, 1}}, nil, nil},\n-\t{2, 4, Point{3, 3}, []Point{{1, 0}, {-1, 1}, {1, 0}, {1, 0}, {-1, 1}}, nil, nil},\n-\t{3, 4, Point{3, 3}, []Point{{1, 0}, {-1, 1}, {1, 0}, {1, 0}, {-1, 1}}, nil, nil},\n-\n-\t{0, 8, Point{4, 2}, []Point{{0, 0}, {1, 0}, {0, 1}, {1, 0}, {1, 0}}, nil, nil},\n-\t{1, 8, Point{2, 4}, []Point{{1, 0}, {-1, 1}, {1, 0}, {-1, 1}, {0, 1}}, nil, nil},\n-\t{2, 8, Point{4, 2}, []Point{{0, 0}, {1, 0}, {1, 0}, {0, 1}, {1, 0}}, nil, nil},\n-\t{3, 8, Point{2, 4}, []Point{{1, 0}, {0, 1}, {-1, 1}, {1, 0}, {-1, 1}}, nil, nil},\n-\n-\t{0, 9, Point{4, 2}, []Point{{2, 0}, {1, 0}, {-3, 1}, {1, 0}, {1, 0}}, nil, nil},\n-\t{1, 9, Point{2, 4}, []Point{{0, 0}, {0, 1}, {0, 1}, {1, 0}, {0, 1}}, nil, nil},\n-\t{2, 9, Point{4, 2}, []Point{{1, 0}, {1, 0}, {1, 0}, {-3, 1}, {1, 0}}, nil, nil},\n-\t{3, 9, Point{2, 4}, []Point{{0, 0}, {0, 1}, {1, 0}, {0, 1}, {0, 1}}, nil, nil},\n-\n-\t{0, 5, Point{3, 3}, []Point{{0, 0}, {0, 1}, {1, 0}, {1, 0}, {0, 1}}, nil, nil},\n-\t{1, 5, Point{3, 3}, []Point{{1, 0}, {1, 0}, {-1, 1}, {-1, 1}, {1, 0}}, nil, nil},\n-\t{2, 5, Point{3, 3}, []Point{{0, 0}, {0, 1}, {1, 0}, {1, 0}, {0, 1}}, nil, nil},\n-\t{3, 5, Point{3, 3}, []Point{{1, 0}, {1, 0}, {-1, 1}, {-1, 1}, {1, 0}}, nil, nil},\n-\n-\t{0, 6, Point{3, 3}, []Point{{2, 0}, {-2, 1}, {1, 0}, {1, 0}, {-2, 1}}, nil, nil},\n-\t{1, 6, Point{3, 3}, []Point{{0, 0}, {1, 0}, {0, 1}, {0, 1}, {1, 0}}, nil, nil},\n-\t{2, 6, Point{3, 3}, []Point{{2, 0}, {-2, 1}, {1, 0}, {1, 0}, {-2, 1}}, nil, nil},\n-\t{3, 6, Point{3, 3}, []Point{{0, 0}, {1, 0}, {0, 1}, {0, 1}, {1, 0}}, nil, nil},\n-}"}, {"sha": "c6806c02d25157342d17b49df28f0e0d89529e2f", "filename": "libgo/go/exp/4s/xs.go", "status": "removed", "additions": 0, "deletions": 750, "changes": 750, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6ed1c8903e728f4233122554bab5910853338bd/libgo%2Fgo%2Fexp%2F4s%2Fxs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6ed1c8903e728f4233122554bab5910853338bd/libgo%2Fgo%2Fexp%2F4s%2Fxs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2F4s%2Fxs.go?ref=d6ed1c8903e728f4233122554bab5910853338bd", "patch": "@@ -1,750 +0,0 @@\n-// games/4s - a tetris clone\n-//\n-// Derived from Plan 9's /sys/src/games/xs.c\n-// http://plan9.bell-labs.com/sources/plan9/sys/src/games/xs.c\n-//\n-// Copyright (C) 2003, Lucent Technologies Inc. and others. All Rights Reserved.\n-// Portions Copyright 2009 The Go Authors.  All Rights Reserved.\n-// Distributed under the terms of the Lucent Public License Version 1.02\n-// See http://plan9.bell-labs.com/plan9/license.html\n-\n-/*\n- * engine for 4s, 5s, etc\n- */\n-\n-package main\n-\n-import (\n-\t\"exp/draw\"\n-\t\"image\"\n-\t\"log\"\n-\t\"os\"\n-\t\"rand\"\n-\t\"time\"\n-)\n-\n-/*\n-Cursor whitearrow = {\n-\t{0, 0},\n-\t{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFC,\n-\t 0xFF, 0xF0, 0xFF, 0xF0, 0xFF, 0xF8, 0xFF, 0xFC,\n-\t 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFC,\n-\t 0xF3, 0xF8, 0xF1, 0xF0, 0xE0, 0xE0, 0xC0, 0x40, },\n-\t{0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x06, 0xC0, 0x1C,\n-\t 0xC0, 0x30, 0xC0, 0x30, 0xC0, 0x38, 0xC0, 0x1C,\n-\t 0xC0, 0x0E, 0xC0, 0x07, 0xCE, 0x0E, 0xDF, 0x1C,\n-\t 0xD3, 0xB8, 0xF1, 0xF0, 0xE0, 0xE0, 0xC0, 0x40, }\n-};\n-*/\n-\n-const (\n-\tCNone   = 0\n-\tCBounds = 1\n-\tCPiece  = 2\n-\tNX      = 10\n-\tNY      = 20\n-\n-\tNCOL = 10\n-\n-\tMAXN = 5\n-)\n-\n-var (\n-\tN                        int\n-\tdisplay                  draw.Window\n-\tscreen                   draw.Image\n-\tscreenr                  image.Rectangle\n-\tboard                    [NY][NX]byte\n-\trboard                   image.Rectangle\n-\tpscore                   image.Point\n-\tscoresz                  image.Point\n-\tpcsz                     = 32\n-\tpos                      image.Point\n-\tbbr, bb2r                image.Rectangle\n-\tbb, bbmask, bb2, bb2mask *image.RGBA\n-\twhitemask                image.Image\n-\tbr, br2                  image.Rectangle\n-\tpoints                   int\n-\tdt                       int\n-\tDY                       int\n-\tDMOUSE                   int\n-\tlastmx                   int\n-\tmouse                    draw.MouseEvent\n-\tnewscreen                bool\n-\ttimerc                   <-chan int64\n-\tsuspc                    chan bool\n-\tmousec                   chan draw.MouseEvent\n-\tresizec                  chan bool\n-\tkbdc                     chan int\n-\tsuspended                bool\n-\ttsleep                   int\n-\tpiece                    *Piece\n-\tpieces                   []Piece\n-)\n-\n-type Piece struct {\n-\trot   int\n-\ttx    int\n-\tsz    image.Point\n-\td     []image.Point\n-\tleft  *Piece\n-\tright *Piece\n-}\n-\n-var txbits = [NCOL][32]byte{\n-\t{0xDD, 0xDD, 0xFF, 0xFF, 0x77, 0x77, 0xFF, 0xFF,\n-\t\t0xDD, 0xDD, 0xFF, 0xFF, 0x77, 0x77, 0xFF, 0xFF,\n-\t\t0xDD, 0xDD, 0xFF, 0xFF, 0x77, 0x77, 0xFF, 0xFF,\n-\t\t0xDD, 0xDD, 0xFF, 0xFF, 0x77, 0x77, 0xFF, 0xFF,\n-\t},\n-\t{0xDD, 0xDD, 0x77, 0x77, 0xDD, 0xDD, 0x77, 0x77,\n-\t\t0xDD, 0xDD, 0x77, 0x77, 0xDD, 0xDD, 0x77, 0x77,\n-\t\t0xDD, 0xDD, 0x77, 0x77, 0xDD, 0xDD, 0x77, 0x77,\n-\t\t0xDD, 0xDD, 0x77, 0x77, 0xDD, 0xDD, 0x77, 0x77,\n-\t},\n-\t{0xAA, 0xAA, 0x55, 0x55, 0xAA, 0xAA, 0x55, 0x55,\n-\t\t0xAA, 0xAA, 0x55, 0x55, 0xAA, 0xAA, 0x55, 0x55,\n-\t\t0xAA, 0xAA, 0x55, 0x55, 0xAA, 0xAA, 0x55, 0x55,\n-\t\t0xAA, 0xAA, 0x55, 0x55, 0xAA, 0xAA, 0x55, 0x55,\n-\t},\n-\t{0xAA, 0xAA, 0x55, 0x55, 0xAA, 0xAA, 0x55, 0x55,\n-\t\t0xAA, 0xAA, 0x55, 0x55, 0xAA, 0xAA, 0x55, 0x55,\n-\t\t0xAA, 0xAA, 0x55, 0x55, 0xAA, 0xAA, 0x55, 0x55,\n-\t\t0xAA, 0xAA, 0x55, 0x55, 0xAA, 0xAA, 0x55, 0x55,\n-\t},\n-\t{0x22, 0x22, 0x88, 0x88, 0x22, 0x22, 0x88, 0x88,\n-\t\t0x22, 0x22, 0x88, 0x88, 0x22, 0x22, 0x88, 0x88,\n-\t\t0x22, 0x22, 0x88, 0x88, 0x22, 0x22, 0x88, 0x88,\n-\t\t0x22, 0x22, 0x88, 0x88, 0x22, 0x22, 0x88, 0x88,\n-\t},\n-\t{0x22, 0x22, 0x00, 0x00, 0x88, 0x88, 0x00, 0x00,\n-\t\t0x22, 0x22, 0x00, 0x00, 0x88, 0x88, 0x00, 0x00,\n-\t\t0x22, 0x22, 0x00, 0x00, 0x88, 0x88, 0x00, 0x00,\n-\t\t0x22, 0x22, 0x00, 0x00, 0x88, 0x88, 0x00, 0x00,\n-\t},\n-\t{0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,\n-\t\t0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,\n-\t\t0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,\n-\t\t0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,\n-\t},\n-\t{0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,\n-\t\t0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,\n-\t\t0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,\n-\t\t0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,\n-\t},\n-\t{0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,\n-\t\t0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,\n-\t\t0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,\n-\t\t0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,\n-\t},\n-\t{0xCC, 0xCC, 0xCC, 0xCC, 0x33, 0x33, 0x33, 0x33,\n-\t\t0xCC, 0xCC, 0xCC, 0xCC, 0x33, 0x33, 0x33, 0x33,\n-\t\t0xCC, 0xCC, 0xCC, 0xCC, 0x33, 0x33, 0x33, 0x33,\n-\t\t0xCC, 0xCC, 0xCC, 0xCC, 0x33, 0x33, 0x33, 0x33,\n-\t},\n-}\n-\n-var txpix = [NCOL]image.Image{\n-\timage.NewColorImage(image.RGBAColor{0xFF, 0xFF, 0x00, 0xFF}), /* yellow */\n-\timage.NewColorImage(image.RGBAColor{0x00, 0xFF, 0xFF, 0xFF}), /* cyan */\n-\timage.NewColorImage(image.RGBAColor{0x00, 0xFF, 0x00, 0xFF}), /* lime green */\n-\timage.NewColorImage(image.RGBAColor{0x00, 0x5D, 0xBB, 0xFF}), /* slate */\n-\timage.NewColorImage(image.RGBAColor{0xFF, 0x00, 0x00, 0xFF}), /* red */\n-\timage.NewColorImage(image.RGBAColor{0x55, 0xAA, 0xAA, 0xFF}), /* olive green */\n-\timage.NewColorImage(image.RGBAColor{0x00, 0x00, 0xFF, 0xFF}), /* blue */\n-\timage.NewColorImage(image.RGBAColor{0xFF, 0x55, 0xAA, 0xFF}), /* pink */\n-\timage.NewColorImage(image.RGBAColor{0xFF, 0xAA, 0xFF, 0xFF}), /* lavender */\n-\timage.NewColorImage(image.RGBAColor{0xBB, 0x00, 0x5D, 0xFF}), /* maroon */\n-}\n-\n-func movemouse() int {\n-\t//mouse.image.Point = image.Pt(rboard.Min.X + rboard.Dx()/2, rboard.Min.Y + rboard.Dy()/2);\n-\t//moveto(mousectl, mouse.Xy);\n-\treturn mouse.Loc.X\n-}\n-\n-func warp(p image.Point, x int) int {\n-\tif !suspended && piece != nil {\n-\t\tx = pos.X + piece.sz.X*pcsz/2\n-\t\tif p.Y < rboard.Min.Y {\n-\t\t\tp.Y = rboard.Min.Y\n-\t\t}\n-\t\tif p.Y >= rboard.Max.Y {\n-\t\t\tp.Y = rboard.Max.Y - 1\n-\t\t}\n-\t\t//moveto(mousectl, image.Pt(x, p.Y));\n-\t}\n-\treturn x\n-}\n-\n-func initPieces() {\n-\tfor i := range pieces {\n-\t\tp := &pieces[i]\n-\t\tif p.rot == 3 {\n-\t\t\tp.right = &pieces[i-3]\n-\t\t} else {\n-\t\t\tp.right = &pieces[i+1]\n-\t\t}\n-\t\tif p.rot == 0 {\n-\t\t\tp.left = &pieces[i+3]\n-\t\t} else {\n-\t\t\tp.left = &pieces[i-1]\n-\t\t}\n-\t}\n-}\n-\n-func collide(pt image.Point, p *Piece) bool {\n-\tpt.X = (pt.X - rboard.Min.X) / pcsz\n-\tpt.Y = (pt.Y - rboard.Min.Y) / pcsz\n-\tfor _, q := range p.d {\n-\t\tpt.X += q.X\n-\t\tpt.Y += q.Y\n-\t\tif pt.X < 0 || pt.X >= NX || pt.Y < 0 || pt.Y >= NY {\n-\t\t\treturn true\n-\t\t\tcontinue\n-\t\t}\n-\t\tif board[pt.Y][pt.X] != 0 {\n-\t\t\treturn true\n-\t\t}\n-\t}\n-\treturn false\n-}\n-\n-func collider(pt, pmax image.Point) bool {\n-\tpi := (pt.X - rboard.Min.X) / pcsz\n-\tpj := (pt.Y - rboard.Min.Y) / pcsz\n-\tn := pmax.X / pcsz\n-\tm := pmax.Y/pcsz + 1\n-\tfor i := pi; i < pi+n && i < NX; i++ {\n-\t\tfor j := pj; j < pj+m && j < NY; j++ {\n-\t\t\tif board[j][i] != 0 {\n-\t\t\t\treturn true\n-\t\t\t}\n-\t\t}\n-\t}\n-\treturn false\n-}\n-\n-func setpiece(p *Piece) {\n-\tdraw.Draw(bb, bbr, image.White, image.ZP)\n-\tdraw.Draw(bbmask, bbr, image.Transparent, image.ZP)\n-\tbr = image.Rect(0, 0, 0, 0)\n-\tbr2 = br\n-\tpiece = p\n-\tif p == nil {\n-\t\treturn\n-\t}\n-\tvar op image.Point\n-\tvar r image.Rectangle\n-\tr.Min = bbr.Min\n-\tfor i, pt := range p.d {\n-\t\tr.Min.X += pt.X * pcsz\n-\t\tr.Min.Y += pt.Y * pcsz\n-\t\tr.Max.X = r.Min.X + pcsz\n-\t\tr.Max.Y = r.Min.Y + pcsz\n-\t\tif i == 0 {\n-\t\t\tdraw.Draw(bb, r, image.Black, image.ZP)\n-\t\t\tdraw.Draw(bb, r.Inset(1), txpix[piece.tx], image.ZP)\n-\t\t\tdraw.Draw(bbmask, r, image.Opaque, image.ZP)\n-\t\t\top = r.Min\n-\t\t} else {\n-\t\t\tdraw.Draw(bb, r, bb, op)\n-\t\t\tdraw.Draw(bbmask, r, bbmask, op)\n-\t\t}\n-\t\tif br.Max.X < r.Max.X {\n-\t\t\tbr.Max.X = r.Max.X\n-\t\t}\n-\t\tif br.Max.Y < r.Max.Y {\n-\t\t\tbr.Max.Y = r.Max.Y\n-\t\t}\n-\t}\n-\tbr.Max = br.Max.Sub(bbr.Min)\n-\tdelta := image.Pt(0, DY)\n-\tbr2.Max = br.Max.Add(delta)\n-\tr = br.Add(bb2r.Min)\n-\tr2 := br2.Add(bb2r.Min)\n-\tdraw.Draw(bb2, r2, image.White, image.ZP)\n-\tdraw.Draw(bb2, r.Add(delta), bb, bbr.Min)\n-\tdraw.Draw(bb2mask, r2, image.Transparent, image.ZP)\n-\tdraw.DrawMask(bb2mask, r, image.Opaque, bbr.Min, bbmask, image.ZP, draw.Over)\n-\tdraw.DrawMask(bb2mask, r.Add(delta), image.Opaque, bbr.Min, bbmask, image.ZP, draw.Over)\n-}\n-\n-func drawpiece() {\n-\tdraw.DrawMask(screen, br.Add(pos), bb, bbr.Min, bbmask, image.ZP, draw.Over)\n-\tif suspended {\n-\t\tdraw.DrawMask(screen, br.Add(pos), image.White, image.ZP, whitemask, image.ZP, draw.Over)\n-\t}\n-}\n-\n-func undrawpiece() {\n-\tvar mask image.Image\n-\tif collider(pos, br.Max) {\n-\t\tmask = bbmask\n-\t}\n-\tdraw.DrawMask(screen, br.Add(pos), image.White, bbr.Min, mask, bbr.Min, draw.Over)\n-}\n-\n-func rest() {\n-\tpt := pos.Sub(rboard.Min)\n-\tpt.X /= pcsz\n-\tpt.Y /= pcsz\n-\tfor _, p := range piece.d {\n-\t\tpt.X += p.X\n-\t\tpt.Y += p.Y\n-\t\tboard[pt.Y][pt.X] = byte(piece.tx + 16)\n-\t}\n-}\n-\n-func canfit(p *Piece) bool {\n-\tvar dx = [...]int{0, -1, 1, -2, 2, -3, 3, 4, -4}\n-\tj := N + 1\n-\tif j >= 4 {\n-\t\tj = p.sz.X\n-\t\tif j < p.sz.Y {\n-\t\t\tj = p.sz.Y\n-\t\t}\n-\t\tj = 2*j - 1\n-\t}\n-\tfor i := 0; i < j; i++ {\n-\t\tvar z image.Point\n-\t\tz.X = pos.X + dx[i]*pcsz\n-\t\tz.Y = pos.Y\n-\t\tif !collide(z, p) {\n-\t\t\tz.Y = pos.Y + pcsz - 1\n-\t\t\tif !collide(z, p) {\n-\t\t\t\tundrawpiece()\n-\t\t\t\tpos.X = z.X\n-\t\t\t\treturn true\n-\t\t\t}\n-\t\t}\n-\t}\n-\treturn false\n-}\n-\n-func score(p int) {\n-\tpoints += p\n-\t//\tsnprint(buf, sizeof(buf), \"%.6ld\", points);\n-\t//\tdraw.Draw(screen, draw.Rpt(pscore, pscore.Add(scoresz)), image.White, image.ZP);\n-\t//\tstring(screen, pscore, image.Black, image.ZP, font, buf);\n-}\n-\n-func drawsq(b draw.Image, p image.Point, ptx int) {\n-\tvar r image.Rectangle\n-\tr.Min = p\n-\tr.Max.X = r.Min.X + pcsz\n-\tr.Max.Y = r.Min.Y + pcsz\n-\tdraw.Draw(b, r, image.Black, image.ZP)\n-\tdraw.Draw(b, r.Inset(1), txpix[ptx], image.ZP)\n-}\n-\n-func drawboard() {\n-\tdraw.Border(screen, rboard.Inset(-2), 2, image.Black, image.ZP)\n-\tdraw.Draw(screen, image.Rect(rboard.Min.X, rboard.Min.Y-2, rboard.Max.X, rboard.Min.Y),\n-\t\timage.White, image.ZP)\n-\tfor i := 0; i < NY; i++ {\n-\t\tfor j := 0; j < NX; j++ {\n-\t\t\tif board[i][j] != 0 {\n-\t\t\t\tdrawsq(screen, image.Pt(rboard.Min.X+j*pcsz, rboard.Min.Y+i*pcsz), int(board[i][j]-16))\n-\t\t\t}\n-\t\t}\n-\t}\n-\tscore(0)\n-\tif suspended {\n-\t\tdraw.DrawMask(screen, screenr, image.White, image.ZP, whitemask, image.ZP, draw.Over)\n-\t}\n-}\n-\n-func choosepiece() {\n-\tfor {\n-\t\ti := rand.Intn(len(pieces))\n-\t\tsetpiece(&pieces[i])\n-\t\tpos = rboard.Min\n-\t\tpos.X += rand.Intn(NX) * pcsz\n-\t\tif !collide(image.Pt(pos.X, pos.Y+pcsz-DY), piece) {\n-\t\t\tbreak\n-\t\t}\n-\t}\n-\tdrawpiece()\n-\tdisplay.FlushImage()\n-}\n-\n-func movepiece() bool {\n-\tvar mask image.Image\n-\tif collide(image.Pt(pos.X, pos.Y+pcsz), piece) {\n-\t\treturn false\n-\t}\n-\tif collider(pos, br2.Max) {\n-\t\tmask = bb2mask\n-\t}\n-\tdraw.DrawMask(screen, br2.Add(pos), bb2, bb2r.Min, mask, bb2r.Min, draw.Over)\n-\tpos.Y += DY\n-\tdisplay.FlushImage()\n-\treturn true\n-}\n-\n-func suspend(s bool) {\n-\tsuspended = s\n-\t/*\n-\t\tif suspended {\n-\t\t\tsetcursor(mousectl, &whitearrow);\n-\t\t} else {\n-\t\t\tsetcursor(mousectl, nil);\n-\t\t}\n-\t*/\n-\tif !suspended {\n-\t\tdrawpiece()\n-\t}\n-\tdrawboard()\n-\tdisplay.FlushImage()\n-}\n-\n-func pause(t int) {\n-\tdisplay.FlushImage()\n-\tfor {\n-\t\tselect {\n-\t\tcase s := <-suspc:\n-\t\t\tif !suspended && s {\n-\t\t\t\tsuspend(true)\n-\t\t\t} else if suspended && !s {\n-\t\t\t\tsuspend(false)\n-\t\t\t\tlastmx = warp(mouse.Loc, lastmx)\n-\t\t\t}\n-\t\tcase <-timerc:\n-\t\t\tif suspended {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tt -= tsleep\n-\t\t\tif t < 0 {\n-\t\t\t\treturn\n-\t\t\t}\n-\t\tcase <-resizec:\n-\t\t\t//redraw(true);\n-\t\tcase mouse = <-mousec:\n-\t\tcase <-kbdc:\n-\t\t}\n-\t}\n-}\n-\n-func horiz() bool {\n-\tvar lev [MAXN]int\n-\th := 0\n-\tfor i := 0; i < NY; i++ {\n-\t\tfor j := 0; board[i][j] != 0; j++ {\n-\t\t\tif j == NX-1 {\n-\t\t\t\tlev[h] = i\n-\t\t\t\th++\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t}\n-\t}\n-\tif h == 0 {\n-\t\treturn false\n-\t}\n-\tr := rboard\n-\tnewscreen = false\n-\tfor j := 0; j < h; j++ {\n-\t\tr.Min.Y = rboard.Min.Y + lev[j]*pcsz\n-\t\tr.Max.Y = r.Min.Y + pcsz\n-\t\tdraw.DrawMask(screen, r, image.White, image.ZP, whitemask, image.ZP, draw.Over)\n-\t\tdisplay.FlushImage()\n-\t}\n-\tPlaySound(whoosh)\n-\tfor i := 0; i < 3; i++ {\n-\t\tpause(250)\n-\t\tif newscreen {\n-\t\t\tdrawboard()\n-\t\t\tbreak\n-\t\t}\n-\t\tfor j := 0; j < h; j++ {\n-\t\t\tr.Min.Y = rboard.Min.Y + lev[j]*pcsz\n-\t\t\tr.Max.Y = r.Min.Y + pcsz\n-\t\t\tdraw.DrawMask(screen, r, image.White, image.ZP, whitemask, image.ZP, draw.Over)\n-\t\t}\n-\t\tdisplay.FlushImage()\n-\t}\n-\tr = rboard\n-\tfor j := 0; j < h; j++ {\n-\t\ti := NY - lev[j] - 1\n-\t\tscore(250 + 10*i*i)\n-\t\tr.Min.Y = rboard.Min.Y\n-\t\tr.Max.Y = rboard.Min.Y + lev[j]*pcsz\n-\t\tdraw.Draw(screen, r.Add(image.Pt(0, pcsz)), screen, r.Min)\n-\t\tr.Max.Y = rboard.Min.Y + pcsz\n-\t\tdraw.Draw(screen, r, image.White, image.ZP)\n-\t\tfor k := lev[j] - 1; k >= 0; k-- {\n-\t\t\tboard[k+1] = board[k]\n-\t\t}\n-\t\tboard[0] = [NX]byte{}\n-\t}\n-\tdisplay.FlushImage()\n-\treturn true\n-}\n-\n-func mright() {\n-\tif !collide(image.Pt(pos.X+pcsz, pos.Y), piece) &&\n-\t\t!collide(image.Pt(pos.X+pcsz, pos.Y+pcsz-DY), piece) {\n-\t\tundrawpiece()\n-\t\tpos.X += pcsz\n-\t\tdrawpiece()\n-\t\tdisplay.FlushImage()\n-\t}\n-}\n-\n-func mleft() {\n-\tif !collide(image.Pt(pos.X-pcsz, pos.Y), piece) &&\n-\t\t!collide(image.Pt(pos.X-pcsz, pos.Y+pcsz-DY), piece) {\n-\t\tundrawpiece()\n-\t\tpos.X -= pcsz\n-\t\tdrawpiece()\n-\t\tdisplay.FlushImage()\n-\t}\n-}\n-\n-func rright() {\n-\tif canfit(piece.right) {\n-\t\tsetpiece(piece.right)\n-\t\tdrawpiece()\n-\t\tdisplay.FlushImage()\n-\t}\n-}\n-\n-func rleft() {\n-\tif canfit(piece.left) {\n-\t\tsetpiece(piece.left)\n-\t\tdrawpiece()\n-\t\tdisplay.FlushImage()\n-\t}\n-}\n-\n-var fusst = 0\n-\n-func drop(f bool) bool {\n-\tif f {\n-\t\tscore(5 * (rboard.Max.Y - pos.Y) / pcsz)\n-\t\tfor movepiece() {\n-\t\t}\n-\t}\n-\tfusst = 0\n-\trest()\n-\tif pos.Y == rboard.Min.Y && !horiz() {\n-\t\treturn true\n-\t}\n-\thoriz()\n-\tsetpiece(nil)\n-\tpause(1500)\n-\tchoosepiece()\n-\tlastmx = warp(mouse.Loc, lastmx)\n-\treturn false\n-}\n-\n-func play() {\n-\tvar om draw.MouseEvent\n-\tdt = 64\n-\tlastmx = -1\n-\tlastmx = movemouse()\n-\tchoosepiece()\n-\tlastmx = warp(mouse.Loc, lastmx)\n-\tfor {\n-\t\tselect {\n-\t\tcase mouse = <-mousec:\n-\t\t\tif suspended {\n-\t\t\t\tom = mouse\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tif lastmx < 0 {\n-\t\t\t\tlastmx = mouse.Loc.X\n-\t\t\t}\n-\t\t\tif mouse.Loc.X > lastmx+DMOUSE {\n-\t\t\t\tmright()\n-\t\t\t\tlastmx = mouse.Loc.X\n-\t\t\t}\n-\t\t\tif mouse.Loc.X < lastmx-DMOUSE {\n-\t\t\t\tmleft()\n-\t\t\t\tlastmx = mouse.Loc.X\n-\t\t\t}\n-\t\t\tif mouse.Buttons&^om.Buttons&1 == 1 {\n-\t\t\t\trleft()\n-\t\t\t}\n-\t\t\tif mouse.Buttons&^om.Buttons&2 == 2 {\n-\t\t\t\tif drop(true) {\n-\t\t\t\t\treturn\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif mouse.Buttons&^om.Buttons&4 == 4 {\n-\t\t\t\trright()\n-\t\t\t}\n-\t\t\tom = mouse\n-\n-\t\tcase s := <-suspc:\n-\t\t\tif !suspended && s {\n-\t\t\t\tsuspend(true)\n-\t\t\t} else if suspended && !s {\n-\t\t\t\tsuspend(false)\n-\t\t\t\tlastmx = warp(mouse.Loc, lastmx)\n-\t\t\t}\n-\n-\t\tcase <-resizec:\n-\t\t\t//redraw(true);\n-\n-\t\tcase r := <-kbdc:\n-\t\t\tif suspended {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tswitch r {\n-\t\t\tcase 'f', ';':\n-\t\t\t\tmright()\n-\t\t\tcase 'a', 'j':\n-\t\t\t\tmleft()\n-\t\t\tcase 'd', 'l':\n-\t\t\t\trright()\n-\t\t\tcase 's', 'k':\n-\t\t\t\trleft()\n-\t\t\tcase ' ':\n-\t\t\t\tif drop(true) {\n-\t\t\t\t\treturn\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\tcase <-timerc:\n-\t\t\tif suspended {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tdt -= tsleep\n-\t\t\tif dt < 0 {\n-\t\t\t\ti := 1\n-\t\t\t\tdt = 16 * (points + rand.Intn(10000) - 5000) / 10000\n-\t\t\t\tif dt >= 32 {\n-\t\t\t\t\ti += (dt - 32) / 16\n-\t\t\t\t\tdt = 32\n-\t\t\t\t}\n-\t\t\t\tdt = 52 - dt\n-\t\t\t\tfor ; i > 0; i-- {\n-\t\t\t\t\tif movepiece() {\n-\t\t\t\t\t\tcontinue\n-\t\t\t\t\t}\n-\t\t\t\t\tfusst++\n-\t\t\t\t\tif fusst == 40 {\n-\t\t\t\t\t\tif drop(false) {\n-\t\t\t\t\t\t\treturn\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tbreak\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-func suspproc() {\n-\ts := false\n-\tfor {\n-\t\tselect {\n-\t\tcase mouse = <-mousec:\n-\t\t\tmousec <- mouse\n-\t\tcase r := <-kbdc:\n-\t\t\tswitch r {\n-\t\t\tcase 'q', 'Q', 0x04, 0x7F:\n-\t\t\t\tos.Exit(0)\n-\t\t\tdefault:\n-\t\t\t\tif s {\n-\t\t\t\t\ts = false\n-\t\t\t\t\tsuspc <- s\n-\t\t\t\t\tbreak\n-\t\t\t\t}\n-\t\t\t\tswitch r {\n-\t\t\t\tcase 'z', 'Z', 'p', 'P', 0x1B:\n-\t\t\t\t\ts = true\n-\t\t\t\t\tsuspc <- s\n-\t\t\t\tdefault:\n-\t\t\t\t\tkbdc <- r\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-func redraw(new bool) {\n-\t//\tif new && getwindow(display, Refmesg) < 0 {\n-\t//\t\tsysfatal(\"can't reattach to window\");\n-\t//\t}\n-\tr := screen.Bounds()\n-\tpos.X = (pos.X - rboard.Min.X) / pcsz\n-\tpos.Y = (pos.Y - rboard.Min.Y) / pcsz\n-\tdx := r.Max.X - r.Min.X\n-\tdy := r.Max.Y - r.Min.Y - 2*32\n-\tDY = dx / NX\n-\tif DY > dy/NY {\n-\t\tDY = dy / NY\n-\t}\n-\tDY /= 8\n-\tif DY > 4 {\n-\t\tDY = 4\n-\t}\n-\tpcsz = DY * 8\n-\tDMOUSE = pcsz / 3\n-\tif pcsz < 8 {\n-\t\tlog.Exitf(\"screen too small: %d\", pcsz)\n-\t}\n-\trboard = screenr\n-\trboard.Min.X += (dx - pcsz*NX) / 2\n-\trboard.Min.Y += (dy-pcsz*NY)/2 + 32\n-\trboard.Max.X = rboard.Min.X + NX*pcsz\n-\trboard.Max.Y = rboard.Min.Y + NY*pcsz\n-\tpscore.X = rboard.Min.X + 8\n-\tpscore.Y = rboard.Min.Y - 32\n-\t//\tscoresz = stringsize(font, \"000000\");\n-\tpos.X = pos.X*pcsz + rboard.Min.X\n-\tpos.Y = pos.Y*pcsz + rboard.Min.Y\n-\tbbr = image.Rect(0, 0, N*pcsz, N*pcsz)\n-\tbb = image.NewRGBA(bbr.Max.X, bbr.Max.Y)\n-\tbbmask = image.NewRGBA(bbr.Max.X, bbr.Max.Y) // actually just a bitmap\n-\tbb2r = image.Rect(0, 0, N*pcsz, N*pcsz+DY)\n-\tbb2 = image.NewRGBA(bb2r.Dx(), bb2r.Dy())\n-\tbb2mask = image.NewRGBA(bb2r.Dx(), bb2r.Dy()) // actually just a bitmap\n-\tdraw.Draw(screen, screenr, image.White, image.ZP)\n-\tdrawboard()\n-\tsetpiece(piece)\n-\tif piece != nil {\n-\t\tdrawpiece()\n-\t}\n-\tlastmx = movemouse()\n-\tnewscreen = true\n-\tdisplay.FlushImage()\n-}\n-\n-func demuxEvents(w draw.Window) {\n-\tfor event := range w.EventChan() {\n-\t\tswitch e := event.(type) {\n-\t\tcase draw.MouseEvent:\n-\t\t\tmousec <- e\n-\t\tcase draw.ConfigEvent:\n-\t\t\tresizec <- true\n-\t\tcase draw.KeyEvent:\n-\t\t\tkbdc <- e.Key\n-\t\t}\n-\t}\n-\tos.Exit(0)\n-}\n-\n-func Play(pp []Piece, ctxt draw.Window) {\n-\tdisplay = ctxt\n-\tscreen = ctxt.Screen()\n-\tscreenr = screen.Bounds()\n-\tpieces = pp\n-\tN = len(pieces[0].d)\n-\tinitPieces()\n-\trand.Seed(int64(time.Nanoseconds() % (1e9 - 1)))\n-\twhitemask = image.NewColorImage(image.AlphaColor{0x7F})\n-\ttsleep = 50\n-\ttimerc = time.Tick(int64(tsleep/2) * 1e6)\n-\tsuspc = make(chan bool)\n-\tmousec = make(chan draw.MouseEvent)\n-\tresizec = make(chan bool)\n-\tkbdc = make(chan int)\n-\tgo demuxEvents(ctxt)\n-\tgo suspproc()\n-\tpoints = 0\n-\tredraw(false)\n-\tplay()\n-}"}, {"sha": "46c412342add9d79df00b42fde84d77a211f64b7", "filename": "libgo/go/exp/datafmt/datafmt.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fexp%2Fdatafmt%2Fdatafmt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fexp%2Fdatafmt%2Fdatafmt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fdatafmt%2Fdatafmt.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -656,7 +656,7 @@ func (s *State) eval(fexpr expr, value reflect.Value, index int) bool {\n \n // Eval formats each argument according to the format\n // f and returns the resulting []byte and os.Error. If\n-// an error occured, the []byte contains the partially\n+// an error occurred, the []byte contains the partially\n // formatted result. An environment env may be passed\n // in which is available in custom formatters through\n // the state parameter."}, {"sha": "d7c70b21decf2299582ae7130d135e7532d8c31e", "filename": "libgo/go/exp/datafmt/datafmt_test.go", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fexp%2Fdatafmt%2Fdatafmt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fexp%2Fdatafmt%2Fdatafmt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fdatafmt%2Fdatafmt_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -7,11 +7,15 @@ package datafmt\n import (\n \t\"fmt\"\n \t\"testing\"\n+\t\"go/token\"\n )\n \n \n+var fset = token.NewFileSet()\n+\n+\n func parse(t *testing.T, form string, fmap FormatterMap) Format {\n-\tf, err := Parse(\"\", []byte(form), fmap)\n+\tf, err := Parse(fset, \"\", []byte(form), fmap)\n \tif err != nil {\n \t\tt.Errorf(\"Parse(%s): %v\", form, err)\n \t\treturn nil\n@@ -76,10 +80,10 @@ func TestCustomFormatters(t *testing.T) {\n \tf = parse(t, ``, fmap1)\n \tverify(t, f, `even odd even odd `, 0, 1, 2, 3)\n \n-\tf = parse(t, `/ =@:blank; float=\"#\"`, fmap1)\n+\tf = parse(t, `/ =@:blank; float64=\"#\"`, fmap1)\n \tverify(t, f, `# # #`, 0.0, 1.0, 2.0)\n \n-\tf = parse(t, `float=@:nil`, fmap1)\n+\tf = parse(t, `float64=@:nil`, fmap1)\n \tverify(t, f, ``, 0.0, 1.0, 2.0)\n \n \tf = parse(t, `testing \"testing\"; ptr=*`, fmap2)\n@@ -135,7 +139,7 @@ func TestBasicTypes(t *testing.T) {\n \n \tconst f = 3.141592\n \tconst fs = `3.141592`\n-\tcheck(t, `float  =\"%g\"`, fs, f)\n+\tcheck(t, `float64=\"%g\"`, fs, f)\n \tcheck(t, `float32=\"%g\"`, fs, float32(f))\n \tcheck(t, `float64=\"%g\"`, fs, float64(f))\n }"}, {"sha": "c6d1402644c13bc00108b6a891e91eb75ce50552", "filename": "libgo/go/exp/datafmt/parser.go", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fexp%2Fdatafmt%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fexp%2Fdatafmt%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fdatafmt%2Fparser.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -19,9 +19,10 @@ import (\n type parser struct {\n \tscanner.ErrorVector\n \tscanner scanner.Scanner\n-\tpos     token.Position // token position\n-\ttok     token.Token    // one token look-ahead\n-\tlit     []byte         // token literal\n+\tfile    *token.File\n+\tpos     token.Pos   // token position\n+\ttok     token.Token // one token look-ahead\n+\tlit     []byte      // token literal\n \n \tpacks map[string]string // PackageName -> ImportPath\n \trules map[string]expr   // RuleName -> Expression\n@@ -39,30 +40,36 @@ func (p *parser) next() {\n }\n \n \n-func (p *parser) init(filename string, src []byte) {\n+func (p *parser) init(fset *token.FileSet, filename string, src []byte) {\n \tp.ErrorVector.Reset()\n-\tp.scanner.Init(filename, src, p, scanner.AllowIllegalChars) // return '@' as token.ILLEGAL w/o error message\n-\tp.next()                                                    // initializes pos, tok, lit\n+\tp.file = fset.AddFile(filename, fset.Base(), len(src))\n+\tp.scanner.Init(p.file, src, p, scanner.AllowIllegalChars) // return '@' as token.ILLEGAL w/o error message\n+\tp.next()                                                  // initializes pos, tok, lit\n \tp.packs = make(map[string]string)\n \tp.rules = make(map[string]expr)\n }\n \n \n-func (p *parser) errorExpected(pos token.Position, msg string) {\n+func (p *parser) error(pos token.Pos, msg string) {\n+\tp.Error(p.file.Position(pos), msg)\n+}\n+\n+\n+func (p *parser) errorExpected(pos token.Pos, msg string) {\n \tmsg = \"expected \" + msg\n-\tif pos.Offset == p.pos.Offset {\n+\tif pos == p.pos {\n \t\t// the error happened at the current position;\n \t\t// make the error message more specific\n \t\tmsg += \", found '\" + p.tok.String() + \"'\"\n \t\tif p.tok.IsLiteral() {\n \t\t\tmsg += \" \" + string(p.lit)\n \t\t}\n \t}\n-\tp.Error(pos, msg)\n+\tp.error(pos, msg)\n }\n \n \n-func (p *parser) expect(tok token.Token) token.Position {\n+func (p *parser) expect(tok token.Token) token.Pos {\n \tpos := p.pos\n \tif p.tok != tok {\n \t\tp.errorExpected(pos, \"'\"+tok.String()+\"'\")\n@@ -87,7 +94,7 @@ func (p *parser) parseTypeName() (string, bool) {\n \t\tif importPath, found := p.packs[name]; found {\n \t\t\tname = importPath\n \t\t} else {\n-\t\t\tp.Error(pos, \"package not declared: \"+name)\n+\t\t\tp.error(pos, \"package not declared: \"+name)\n \t\t}\n \t\tp.next()\n \t\tname, isIdent = name+\".\"+p.parseIdentifier(), false\n@@ -303,11 +310,11 @@ func (p *parser) parseFormat() {\n \n \t\t\t// add package declaration\n \t\t\tif !isIdent {\n-\t\t\t\tp.Error(pos, \"illegal package name: \"+name)\n+\t\t\t\tp.error(pos, \"illegal package name: \"+name)\n \t\t\t} else if _, found := p.packs[name]; !found {\n \t\t\t\tp.packs[name] = importPath\n \t\t\t} else {\n-\t\t\t\tp.Error(pos, \"package already declared: \"+name)\n+\t\t\t\tp.error(pos, \"package already declared: \"+name)\n \t\t\t}\n \n \t\tcase token.ASSIGN:\n@@ -319,7 +326,7 @@ func (p *parser) parseFormat() {\n \t\t\tif _, found := p.rules[name]; !found {\n \t\t\t\tp.rules[name] = x\n \t\t\t} else {\n-\t\t\t\tp.Error(pos, \"format rule already declared: \"+name)\n+\t\t\t\tp.error(pos, \"format rule already declared: \"+name)\n \t\t\t}\n \n \t\tdefault:\n@@ -358,10 +365,10 @@ func remap(p *parser, name string) string {\n // there are no errors, the result is a Format and the error is nil.\n // Otherwise the format is nil and a non-empty ErrorList is returned.\n //\n-func Parse(filename string, src []byte, fmap FormatterMap) (Format, os.Error) {\n+func Parse(fset *token.FileSet, filename string, src []byte, fmap FormatterMap) (Format, os.Error) {\n \t// parse source\n \tvar p parser\n-\tp.init(filename, src)\n+\tp.init(fset, filename, src)\n \tp.parseFormat()\n \n \t// add custom formatters, if any"}, {"sha": "1d0729d922c89f2a426d3353e23112eb664053d4", "filename": "libgo/go/exp/draw/draw.go", "status": "modified", "additions": 1, "deletions": 24, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fexp%2Fdraw%2Fdraw.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fexp%2Fdraw%2Fdraw.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fdraw%2Fdraw.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -268,7 +268,7 @@ func drawFillSrc(dst *image.RGBA, r image.Rectangle, src *image.ColorImage) {\n \tdbase := dy0 * dst.Stride\n \ti0, i1 := dbase+dx0, dbase+dx1\n \tfirstRow := dst.Pix[i0:i1]\n-\tfor i, _ := range firstRow {\n+\tfor i := range firstRow {\n \t\tfirstRow[i] = color\n \t}\n \tfor y := dy0 + 1; y < dy1; y++ {\n@@ -361,26 +361,3 @@ func drawRGBA(dst *image.RGBA, r image.Rectangle, src image.Image, sp image.Poin\n \t\t}\n \t}\n }\n-\n-// Border aligns r.Min in dst with sp in src and then replaces pixels\n-// in a w-pixel border around r in dst with the result of the Porter-Duff compositing\n-// operation ``src over dst.''  If w is positive, the border extends w pixels inside r.\n-// If w is negative, the border extends w pixels outside r.\n-func Border(dst Image, r image.Rectangle, w int, src image.Image, sp image.Point) {\n-\ti := w\n-\tif i > 0 {\n-\t\t// inside r\n-\t\tDraw(dst, image.Rect(r.Min.X, r.Min.Y, r.Max.X, r.Min.Y+i), src, sp)                                // top\n-\t\tDraw(dst, image.Rect(r.Min.X, r.Min.Y+i, r.Min.X+i, r.Max.Y-i), src, sp.Add(image.Pt(0, i)))        // left\n-\t\tDraw(dst, image.Rect(r.Max.X-i, r.Min.Y+i, r.Max.X, r.Max.Y-i), src, sp.Add(image.Pt(r.Dx()-i, i))) // right\n-\t\tDraw(dst, image.Rect(r.Min.X, r.Max.Y-i, r.Max.X, r.Max.Y), src, sp.Add(image.Pt(0, r.Dy()-i)))     // bottom\n-\t\treturn\n-\t}\n-\n-\t// outside r;\n-\ti = -i\n-\tDraw(dst, image.Rect(r.Min.X-i, r.Min.Y-i, r.Max.X+i, r.Min.Y), src, sp.Add(image.Pt(-i, -i))) // top\n-\tDraw(dst, image.Rect(r.Min.X-i, r.Min.Y, r.Min.X, r.Max.Y), src, sp.Add(image.Pt(-i, 0)))      // left\n-\tDraw(dst, image.Rect(r.Max.X, r.Min.Y, r.Max.X+i, r.Max.Y), src, sp.Add(image.Pt(r.Dx(), 0)))  // right\n-\tDraw(dst, image.Rect(r.Min.X-i, r.Max.Y, r.Max.X+i, r.Max.Y+i), src, sp.Add(image.Pt(-i, 0)))  // bottom\n-}"}, {"sha": "12835c4c0288db443db865a9335c9a57e2604f80", "filename": "libgo/go/exp/eval/bridge.go", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fexp%2Feval%2Fbridge.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fexp%2Feval%2Fbridge.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Feval%2Fbridge.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -29,7 +29,7 @@ func TypeFromNative(t reflect.Type) Type {\n \tvar nt *NamedType\n \tif t.Name() != \"\" {\n \t\tname := t.PkgPath() + \"\u00b7\" + t.Name()\n-\t\tnt = &NamedType{token.Position{}, name, nil, true, make(map[string]Method)}\n+\t\tnt = &NamedType{token.NoPos, name, nil, true, make(map[string]Method)}\n \t\tevalTypes[t] = nt\n \t}\n \n@@ -43,8 +43,6 @@ func TypeFromNative(t reflect.Type) Type {\n \t\t\tet = Float32Type\n \t\tcase reflect.Float64:\n \t\t\tet = Float64Type\n-\t\tcase reflect.Float:\n-\t\t\tet = FloatType\n \t\t}\n \tcase *reflect.IntType:\n \t\tswitch t.Kind() {"}, {"sha": "9d2923bfca4674eb0f0f7c0a8e7ad606c58b80e6", "filename": "libgo/go/exp/eval/compiler.go", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fexp%2Feval%2Fcompiler.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fexp%2Feval%2Fcompiler.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Feval%2Fcompiler.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -11,24 +11,20 @@ import (\n )\n \n \n-type positioned interface {\n-\tPos() token.Position\n-}\n-\n-\n // A compiler captures information used throughout an entire\n // compilation.  Currently it includes only the error handler.\n //\n // TODO(austin) This might actually represent package level, in which\n // case it should be package compiler.\n type compiler struct {\n+\tfset         *token.FileSet\n \terrors       scanner.ErrorHandler\n \tnumErrors    int\n \tsilentErrors int\n }\n \n-func (a *compiler) diagAt(pos positioned, format string, args ...interface{}) {\n-\ta.errors.Error(pos.Pos(), fmt.Sprintf(format, args...))\n+func (a *compiler) diagAt(pos token.Pos, format string, args ...interface{}) {\n+\ta.errors.Error(a.fset.Position(pos), fmt.Sprintf(format, args...))\n \ta.numErrors++\n }\n \n@@ -64,9 +60,9 @@ type label struct {\n \tcontinuePC *uint\n \t// The position where this label was resolved.  If it has not\n \t// been resolved yet, an invalid position.\n-\tresolved token.Position\n+\tresolved token.Pos\n \t// The position where this label was first jumped to.\n-\tused token.Position\n+\tused token.Pos\n }\n \n // A funcCompiler captures information used throughout the compilation"}, {"sha": "ff28cf1a9084a3ccfe3c9f4b1a12d8dc6d9b0e29", "filename": "libgo/go/exp/eval/eval_test.go", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fexp%2Feval%2Feval_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fexp%2Feval%2Feval_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Feval%2Feval_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -8,13 +8,17 @@ import (\n \t\"big\"\n \t\"flag\"\n \t\"fmt\"\n+\t\"go/token\"\n \t\"log\"\n \t\"os\"\n \t\"reflect\"\n \t\"regexp\"\n \t\"testing\"\n )\n \n+// All tests are done using the same file set.\n+var fset = token.NewFileSet()\n+\n // Print each statement or expression before parsing it\n var noisy = false\n \n@@ -49,7 +53,7 @@ func (a test) run(t *testing.T, name string) {\n \t\t\tprintln(\"code:\", src)\n \t\t}\n \n-\t\tcode, err := w.Compile(src)\n+\t\tcode, err := w.Compile(fset, src)\n \t\tif err != nil {\n \t\t\tif j.cerr == \"\" {\n \t\t\t\tt.Errorf(\"%s: Compile %s: %v\", name, src, err)\n@@ -169,8 +173,8 @@ func toValue(val interface{}) Value {\n \t\treturn &r\n \tcase *big.Int:\n \t\treturn &idealIntV{val}\n-\tcase float:\n-\t\tr := floatV(val)\n+\tcase float64:\n+\t\tr := float64V(val)\n \t\treturn &r\n \tcase *big.Rat:\n \t\treturn &idealFloatV{val}\n@@ -240,7 +244,7 @@ func newTestWorld() *World {\n \tdef(\"i\", IntType, 1)\n \tdef(\"i2\", IntType, 2)\n \tdef(\"u\", UintType, uint(1))\n-\tdef(\"f\", FloatType, 1.0)\n+\tdef(\"f\", Float64Type, 1.0)\n \tdef(\"s\", StringType, \"abc\")\n \tdef(\"t\", NewStructType([]StructField{{\"a\", IntType, false}}), vstruct{1})\n \tdef(\"ai\", NewArrayType(2, IntType), varray{1, 2})"}, {"sha": "e65f47617bdcd7b2964cc0088bdd2349be5e82e7", "filename": "libgo/go/exp/eval/expr.go", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fexp%2Feval%2Fexpr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fexp%2Feval%2Fexpr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Feval%2Fexpr.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -57,15 +57,15 @@ type expr struct {\n // compiled from it.\n type exprInfo struct {\n \t*compiler\n-\tpos token.Position\n+\tpos token.Pos\n }\n \n func (a *exprInfo) newExpr(t Type, desc string) *expr {\n \treturn &expr{exprInfo: a, t: t, desc: desc}\n }\n \n func (a *exprInfo) diag(format string, args ...interface{}) {\n-\ta.diagAt(&a.pos, format, args...)\n+\ta.diagAt(a.pos, format, args...)\n }\n \n func (a *exprInfo) diagOpType(op token.Token, vt Type) {\n@@ -229,7 +229,7 @@ func (a *expr) derefArray() *expr {\n //    multi-valued type.\n type assignCompiler struct {\n \t*compiler\n-\tpos token.Position\n+\tpos token.Pos\n \t// The RHS expressions.  This may include nil's for\n \t// expressions that failed to compile.\n \trs []*expr\n@@ -254,7 +254,7 @@ type assignCompiler struct {\n // assignCompiler with rmt set, but if type checking fails, slots in\n // the MultiType may be nil.  If rs contains nil's, type checking will\n // fail and these expressions given a nil type.\n-func (a *compiler) checkAssign(pos token.Position, rs []*expr, errOp, errPosName string) (*assignCompiler, bool) {\n+func (a *compiler) checkAssign(pos token.Pos, rs []*expr, errOp, errPosName string) (*assignCompiler, bool) {\n \tc := &assignCompiler{\n \t\tcompiler:   a,\n \t\tpos:        pos,\n@@ -331,7 +331,7 @@ func (a *assignCompiler) compile(b *block, lt Type) func(Value, *Thread) {\n \t\t\t\tpos = a.rs[lcount-1].pos\n \t\t\t}\n \t\t}\n-\t\ta.diagAt(&pos, \"%s %ss for %s\\n\\t%s\\n\\t%s\", msg, a.errPosName, a.errOp, lt, rmt)\n+\t\ta.diagAt(pos, \"%s %ss for %s\\n\\t%s\\n\\t%s\", msg, a.errPosName, a.errOp, lt, rmt)\n \t\treturn nil\n \t}\n \n@@ -453,7 +453,7 @@ func (a *assignCompiler) compile(b *block, lt Type) func(Value, *Thread) {\n // compileAssign compiles an assignment operation without the full\n // generality of an assignCompiler.  See assignCompiler for a\n // description of the arguments.\n-func (a *compiler) compileAssign(pos token.Position, b *block, lt Type, rs []*expr, errOp, errPosName string) func(Value, *Thread) {\n+func (a *compiler) compileAssign(pos token.Pos, b *block, lt Type, rs []*expr, errOp, errPosName string) func(Value, *Thread) {\n \tac, ok := a.checkAssign(pos, rs, errOp, errPosName)\n \tif !ok {\n \t\treturn nil\n@@ -514,7 +514,7 @@ func (a *exprCompiler) compile(x ast.Expr, callCtx bool) *expr {\n \t\t\treturn nil\n \t\t}\n \t\tif a.constant {\n-\t\t\ta.diagAt(x, \"function literal used in constant expression\")\n+\t\t\ta.diagAt(x.Pos(), \"function literal used in constant expression\")\n \t\t\treturn nil\n \t\t}\n \t\treturn ei.compileFuncLit(decl, fn)\n@@ -571,12 +571,12 @@ func (a *exprCompiler) compile(x ast.Expr, callCtx bool) *expr {\n \t\t\treturn nil\n \t\t}\n \t\tif a.constant {\n-\t\t\ta.diagAt(x, \"function call in constant context\")\n+\t\t\ta.diagAt(x.Pos(), \"function call in constant context\")\n \t\t\treturn nil\n \t\t}\n \n \t\tif l.valType != nil {\n-\t\t\ta.diagAt(x, \"type conversions not implemented\")\n+\t\t\ta.diagAt(x.Pos(), \"type conversions not implemented\")\n \t\t\treturn nil\n \t\t} else if ft, ok := l.t.(*FuncType); ok && ft.builtin != \"\" {\n \t\t\treturn ei.compileBuiltinCallExpr(a.block, ft, args)\n@@ -595,15 +595,21 @@ func (a *exprCompiler) compile(x ast.Expr, callCtx bool) *expr {\n \t\treturn ei.compileIndexExpr(l, r)\n \n \tcase *ast.SliceExpr:\n-\t\tvar hi *expr\n+\t\tvar lo, hi *expr\n \t\tarr := a.compile(x.X, false)\n-\t\tlo := a.compile(x.Index, false)\n-\t\tif x.End == nil {\n+\t\tif x.Low == nil {\n+\t\t\t// beginning was omitted, so we need to provide it\n+\t\t\tei := &exprInfo{a.compiler, x.Pos()}\n+\t\t\tlo = ei.compileIntLit(\"0\")\n+\t\t} else {\n+\t\t\tlo = a.compile(x.Low, false)\n+\t\t}\n+\t\tif x.High == nil {\n \t\t\t// End was omitted, so we need to compute len(x.X)\n \t\t\tei := &exprInfo{a.compiler, x.Pos()}\n \t\t\thi = ei.compileBuiltinCallExpr(a.block, lenType, []*expr{arr})\n \t\t} else {\n-\t\t\thi = a.compile(x.End, false)\n+\t\t\thi = a.compile(x.High, false)\n \t\t}\n \t\tif arr == nil || lo == nil || hi == nil {\n \t\t\treturn nil\n@@ -654,13 +660,13 @@ func (a *exprCompiler) compile(x ast.Expr, callCtx bool) *expr {\n \n typeexpr:\n \tif !callCtx {\n-\t\ta.diagAt(x, \"type used as expression\")\n+\t\ta.diagAt(x.Pos(), \"type used as expression\")\n \t\treturn nil\n \t}\n \treturn ei.exprFromType(a.compileType(a.block, x))\n \n notimpl:\n-\ta.diagAt(x, \"%T expression node not implemented\", x)\n+\ta.diagAt(x.Pos(), \"%T expression node not implemented\", x)\n \treturn nil\n }\n \n@@ -1920,7 +1926,7 @@ func (a *compiler) compileArrayLen(b *block, expr ast.Expr) (int64, bool) {\n \t}\n \n \tif !lenExpr.t.isInteger() {\n-\t\ta.diagAt(expr, \"array size must be an integer\")\n+\t\ta.diagAt(expr.Pos(), \"array size must be an integer\")\n \t\treturn 0, false\n \t}\n \n@@ -1975,7 +1981,7 @@ func (a *expr) extractEffect(b *block, errOp string) (func(*Thread), *expr) {\n \t\tcase tempType.isInteger():\n \t\t\ttempType = IntType\n \t\tcase tempType.isFloat():\n-\t\t\ttempType = FloatType\n+\t\t\ttempType = Float64Type\n \t\tdefault:\n \t\t\tlog.Panicf(\"unexpected ideal type %v\", tempType)\n \t\t}"}, {"sha": "5d0e50000325d675898e29638170ac710e7db73b", "filename": "libgo/go/exp/eval/expr1.go", "status": "modified", "additions": 3, "deletions": 34, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fexp%2Feval%2Fexpr1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fexp%2Feval%2Fexpr1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Feval%2Fexpr1.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -9,8 +9,8 @@ import (\n )\n \n /*\n-* \"As\" functions.  These retrieve evaluator functions from an\n-* expr, panicking if the requested evaluator has the wrong type.\n+ * \"As\" functions.  These retrieve evaluator functions from an\n+ * expr, panicking if the requested evaluator has the wrong type.\n  */\n func (a *expr) asBool() func(*Thread) bool {\n \treturn a.eval.(func(*Thread) bool)\n@@ -90,7 +90,7 @@ func (a *expr) asInterface() func(*Thread) interface{} {\n }\n \n /*\n-* Operator generators.\n+ * Operator generators.\n  */\n \n func (a *expr) genConstant(v Value) {\n@@ -392,13 +392,6 @@ func (a *expr) genBinOpAdd(l, r *expr) {\n \t\t\t\tret = l + r\n \t\t\t\treturn float64(float64(ret))\n \t\t\t}\n-\t\tcase 0:\n-\t\t\ta.eval = func(t *Thread) float64 {\n-\t\t\t\tl, r := lf(t), rf(t)\n-\t\t\t\tvar ret float64\n-\t\t\t\tret = l + r\n-\t\t\t\treturn float64(float(ret))\n-\t\t\t}\n \t\tdefault:\n \t\t\tlog.Panicf(\"unexpected size %d in type %v at %v\", t.Bits, t, a.pos)\n \t\t}\n@@ -528,13 +521,6 @@ func (a *expr) genBinOpSub(l, r *expr) {\n \t\t\t\tret = l - r\n \t\t\t\treturn float64(float64(ret))\n \t\t\t}\n-\t\tcase 0:\n-\t\t\ta.eval = func(t *Thread) float64 {\n-\t\t\t\tl, r := lf(t), rf(t)\n-\t\t\t\tvar ret float64\n-\t\t\t\tret = l - r\n-\t\t\t\treturn float64(float(ret))\n-\t\t\t}\n \t\tdefault:\n \t\t\tlog.Panicf(\"unexpected size %d in type %v at %v\", t.Bits, t, a.pos)\n \t\t}\n@@ -657,13 +643,6 @@ func (a *expr) genBinOpMul(l, r *expr) {\n \t\t\t\tret = l * r\n \t\t\t\treturn float64(float64(ret))\n \t\t\t}\n-\t\tcase 0:\n-\t\t\ta.eval = func(t *Thread) float64 {\n-\t\t\t\tl, r := lf(t), rf(t)\n-\t\t\t\tvar ret float64\n-\t\t\t\tret = l * r\n-\t\t\t\treturn float64(float(ret))\n-\t\t\t}\n \t\tdefault:\n \t\t\tlog.Panicf(\"unexpected size %d in type %v at %v\", t.Bits, t, a.pos)\n \t\t}\n@@ -822,16 +801,6 @@ func (a *expr) genBinOpQuo(l, r *expr) {\n \t\t\t\tret = l / r\n \t\t\t\treturn float64(float64(ret))\n \t\t\t}\n-\t\tcase 0:\n-\t\t\ta.eval = func(t *Thread) float64 {\n-\t\t\t\tl, r := lf(t), rf(t)\n-\t\t\t\tvar ret float64\n-\t\t\t\tif r == 0 {\n-\t\t\t\t\tt.Abort(DivByZeroError{})\n-\t\t\t\t}\n-\t\t\t\tret = l / r\n-\t\t\t\treturn float64(float(ret))\n-\t\t\t}\n \t\tdefault:\n \t\t\tlog.Panicf(\"unexpected size %d in type %v at %v\", t.Bits, t, a.pos)\n \t\t}"}, {"sha": "66305de25f034edb94b87a0944d2173b28c58596", "filename": "libgo/go/exp/eval/scope.go", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fexp%2Feval%2Fscope.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fexp%2Feval%2Fscope.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Feval%2Fscope.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -15,11 +15,11 @@ import (\n \n // A definition can be a *Variable, *Constant, or Type.\n type Def interface {\n-\tPos() token.Position\n+\tPos() token.Pos\n }\n \n type Variable struct {\n-\ttoken.Position\n+\tVarPos token.Pos\n \t// Index of this variable in the Frame structure\n \tIndex int\n \t// Static type of this variable\n@@ -30,10 +30,18 @@ type Variable struct {\n \tInit Value\n }\n \n+func (v *Variable) Pos() token.Pos {\n+\treturn v.VarPos\n+}\n+\n type Constant struct {\n-\ttoken.Position\n-\tType  Type\n-\tValue Value\n+\tConstPos token.Pos\n+\tType     Type\n+\tValue    Value\n+}\n+\n+func (c *Constant) Pos() token.Pos {\n+\treturn c.ConstPos\n }\n \n // A block represents a definition block in which a name may not be\n@@ -111,12 +119,12 @@ func (b *block) ChildScope() *Scope {\n \treturn sub.scope\n }\n \n-func (b *block) DefineVar(name string, pos token.Position, t Type) (*Variable, Def) {\n+func (b *block) DefineVar(name string, pos token.Pos, t Type) (*Variable, Def) {\n \tif prev, ok := b.defs[name]; ok {\n \t\treturn nil, prev\n \t}\n \tv := b.defineSlot(t, false)\n-\tv.Position = pos\n+\tv.VarPos = pos\n \tb.defs[name] = v\n \treturn v, nil\n }\n@@ -135,11 +143,11 @@ func (b *block) defineSlot(t Type, temp bool) *Variable {\n \t\t\tb.scope.maxVars = index + 1\n \t\t}\n \t}\n-\tv := &Variable{token.Position{}, index, t, nil}\n+\tv := &Variable{token.NoPos, index, t, nil}\n \treturn v\n }\n \n-func (b *block) DefineConst(name string, pos token.Position, t Type, v Value) (*Constant, Def) {\n+func (b *block) DefineConst(name string, pos token.Pos, t Type, v Value) (*Constant, Def) {\n \tif prev, ok := b.defs[name]; ok {\n \t\treturn nil, prev\n \t}\n@@ -148,7 +156,7 @@ func (b *block) DefineConst(name string, pos token.Position, t Type, v Value) (*\n \treturn c, nil\n }\n \n-func (b *block) DefineType(name string, pos token.Position, t Type) Type {\n+func (b *block) DefineType(name string, pos token.Pos, t Type) Type {\n \tif _, ok := b.defs[name]; ok {\n \t\treturn nil\n \t}"}, {"sha": "77ff066d09cdbcd50112a9b6c47ced532e185580", "filename": "libgo/go/exp/eval/stmt.go", "status": "modified", "additions": 20, "deletions": 23, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fexp%2Feval%2Fstmt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fexp%2Feval%2Fstmt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Feval%2Fstmt.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -22,13 +22,13 @@ const (\n \n type stmtCompiler struct {\n \t*blockCompiler\n-\tpos token.Position\n+\tpos token.Pos\n \t// This statement's label, or nil if it is not labeled.\n \tstmtLabel *label\n }\n \n func (a *stmtCompiler) diag(format string, args ...interface{}) {\n-\ta.diagAt(&a.pos, format, args...)\n+\ta.diagAt(a.pos, format, args...)\n }\n \n /*\n@@ -65,7 +65,7 @@ type flowBuf struct {\n \tents map[uint]*flowEnt\n \t// gotos is a map from goto positions to information on the\n \t// block at the point of the goto.\n-\tgotos map[*token.Position]*flowBlock\n+\tgotos map[token.Pos]*flowBlock\n \t// labels is a map from label name to information on the block\n \t// at the point of the label.  labels are tracked by name,\n \t// since mutliple labels at the same PC can have different\n@@ -74,7 +74,7 @@ type flowBuf struct {\n }\n \n func newFlowBuf(cb *codeBuf) *flowBuf {\n-\treturn &flowBuf{cb, make(map[uint]*flowEnt), make(map[*token.Position]*flowBlock), make(map[string]*flowBlock)}\n+\treturn &flowBuf{cb, make(map[uint]*flowEnt), make(map[token.Pos]*flowBlock), make(map[string]*flowBlock)}\n }\n \n // put creates a flow control point for the next PC in the code buffer.\n@@ -123,8 +123,8 @@ func newFlowBlock(target string, b *block) *flowBlock {\n \n // putGoto captures the block at a goto statement.  This should be\n // called in addition to putting a flow control point.\n-func (f *flowBuf) putGoto(pos token.Position, target string, b *block) {\n-\tf.gotos[&pos] = newFlowBlock(target, b)\n+func (f *flowBuf) putGoto(pos token.Pos, target string, b *block) {\n+\tf.gotos[pos] = newFlowBlock(target, b)\n }\n \n // putLabel captures the block at a label.\n@@ -212,13 +212,10 @@ func (f *flowBuf) gotosObeyScopes(a *compiler) {\n func (a *stmtCompiler) defineVar(ident *ast.Ident, t Type) *Variable {\n \tv, prev := a.block.DefineVar(ident.Name, ident.Pos(), t)\n \tif prev != nil {\n-\t\t// TODO(austin) It's silly that we have to capture\n-\t\t// Pos() in a variable.\n-\t\tpos := prev.Pos()\n-\t\tif pos.IsValid() {\n-\t\t\ta.diagAt(ident, \"variable %s redeclared in this block\\n\\tprevious declaration at %s\", ident.Name, &pos)\n+\t\tif prev.Pos().IsValid() {\n+\t\t\ta.diagAt(ident.Pos(), \"variable %s redeclared in this block\\n\\tprevious declaration at %s\", ident.Name, a.fset.Position(prev.Pos()))\n \t\t} else {\n-\t\t\ta.diagAt(ident, \"variable %s redeclared in this block\", ident.Name)\n+\t\t\ta.diagAt(ident.Pos(), \"variable %s redeclared in this block\", ident.Name)\n \t\t}\n \t\treturn nil\n \t}\n@@ -385,9 +382,9 @@ func (a *stmtCompiler) compileDecl(decl ast.Decl) {\n \t\tif prev != nil {\n \t\t\tpos := prev.Pos()\n \t\t\tif pos.IsValid() {\n-\t\t\t\ta.diagAt(d.Name, \"identifier %s redeclared in this block\\n\\tprevious declaration at %s\", d.Name.Name, &pos)\n+\t\t\t\ta.diagAt(d.Name.Pos(), \"identifier %s redeclared in this block\\n\\tprevious declaration at %s\", d.Name.Name, a.fset.Position(pos))\n \t\t\t} else {\n-\t\t\t\ta.diagAt(d.Name, \"identifier %s redeclared in this block\", d.Name.Name)\n+\t\t\t\ta.diagAt(d.Name.Pos(), \"identifier %s redeclared in this block\", d.Name.Name)\n \t\t\t}\n \t\t}\n \t\tfn := a.compileFunc(a.block, decl, d.Body)\n@@ -419,7 +416,7 @@ func (a *stmtCompiler) compileLabeledStmt(s *ast.LabeledStmt) {\n \tl, ok := a.labels[s.Label.Name]\n \tif ok {\n \t\tif l.resolved.IsValid() {\n-\t\t\ta.diag(\"label %s redeclared in this block\\n\\tprevious declaration at %s\", s.Label.Name, &l.resolved)\n+\t\t\ta.diag(\"label %s redeclared in this block\\n\\tprevious declaration at %s\", s.Label.Name, a.fset.Position(l.resolved))\n \t\t}\n \t} else {\n \t\tpc := badPC\n@@ -555,7 +552,7 @@ func (a *stmtCompiler) doAssign(lhs []ast.Expr, rhs []ast.Expr, tok token.Token,\n \t\t\t// Check that it's an identifier\n \t\t\tident, ok = le.(*ast.Ident)\n \t\t\tif !ok {\n-\t\t\t\ta.diagAt(le, \"left side of := must be a name\")\n+\t\t\t\ta.diagAt(le.Pos(), \"left side of := must be a name\")\n \t\t\t\t// Suppress new defitions errors\n \t\t\t\tnDefs++\n \t\t\t\tcontinue\n@@ -605,7 +602,7 @@ func (a *stmtCompiler) doAssign(lhs []ast.Expr, rhs []ast.Expr, tok token.Token,\n \t\t\t\tcase ac.rmt.Elems[i].isInteger():\n \t\t\t\t\tlt = IntType\n \t\t\t\tcase ac.rmt.Elems[i].isFloat():\n-\t\t\t\t\tlt = FloatType\n+\t\t\t\t\tlt = Float64Type\n \t\t\t\tdefault:\n \t\t\t\t\tlog.Panicf(\"unexpected ideal type %v\", rs[i].t)\n \t\t\t\t}\n@@ -1012,12 +1009,12 @@ func (a *stmtCompiler) compileSwitchStmt(s *ast.SwitchStmt) {\n \tfor _, c := range s.Body.List {\n \t\tclause, ok := c.(*ast.CaseClause)\n \t\tif !ok {\n-\t\t\ta.diagAt(clause, \"switch statement must contain case clauses\")\n+\t\t\ta.diagAt(clause.Pos(), \"switch statement must contain case clauses\")\n \t\t\tcontinue\n \t\t}\n \t\tif clause.Values == nil {\n \t\t\tif hasDefault {\n-\t\t\t\ta.diagAt(clause, \"switch statement contains more than one default case\")\n+\t\t\t\ta.diagAt(clause.Pos(), \"switch statement contains more than one default case\")\n \t\t\t}\n \t\t\thasDefault = true\n \t\t} else {\n@@ -1039,7 +1036,7 @@ func (a *stmtCompiler) compileSwitchStmt(s *ast.SwitchStmt) {\n \t\t\tcase e == nil:\n \t\t\t\t// Error reported by compileExpr\n \t\t\tcase cond == nil && !e.t.isBoolean():\n-\t\t\t\ta.diagAt(v, \"'case' condition must be boolean\")\n+\t\t\t\ta.diagAt(v.Pos(), \"'case' condition must be boolean\")\n \t\t\tcase cond == nil:\n \t\t\t\tcases[i] = e.asBool()\n \t\t\tcase cond != nil:\n@@ -1104,7 +1101,7 @@ func (a *stmtCompiler) compileSwitchStmt(s *ast.SwitchStmt) {\n \t\t\t\t\t// empty blocks to be empty\n \t\t\t\t\t// statements.\n \t\t\t\t\tif _, ok := s2.(*ast.EmptyStmt); !ok {\n-\t\t\t\t\t\ta.diagAt(s, \"fallthrough statement must be final statement in case\")\n+\t\t\t\t\t\ta.diagAt(s.Pos(), \"fallthrough statement must be final statement in case\")\n \t\t\t\t\t\tbreak\n \t\t\t\t\t}\n \t\t\t\t}\n@@ -1275,7 +1272,7 @@ func (a *compiler) compileFunc(b *block, decl *FuncDecl, body *ast.BlockStmt) fu\n \t// this if there were no errors compiling the body.\n \tif len(decl.Type.Out) > 0 && fc.flow.reachesEnd(0) {\n \t\t// XXX(Spec) Not specified.\n-\t\ta.diagAt(&body.Rbrace, \"function ends without a return statement\")\n+\t\ta.diagAt(body.Rbrace, \"function ends without a return statement\")\n \t\treturn nil\n \t}\n \n@@ -1290,7 +1287,7 @@ func (a *funcCompiler) checkLabels() {\n \tnerr := a.numError()\n \tfor _, l := range a.labels {\n \t\tif !l.resolved.IsValid() {\n-\t\t\ta.diagAt(&l.used, \"label %s not defined\", l.name)\n+\t\t\ta.diagAt(l.used, \"label %s not defined\", l.name)\n \t\t}\n \t}\n \tif nerr != a.numError() {"}, {"sha": "3f272ce4b6c21739ee5a06f1aac9763b3bc2f972", "filename": "libgo/go/exp/eval/type.go", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fexp%2Feval%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fexp%2Feval%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Feval%2Ftype.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -54,7 +54,7 @@ type Type interface {\n \t// String returns the string representation of this type.\n \tString() string\n \t// The position where this type was defined, if any.\n-\tPos() token.Position\n+\tPos() token.Pos\n }\n \n type BoundedType interface {\n@@ -65,7 +65,7 @@ type BoundedType interface {\n \tmaxVal() *big.Rat\n }\n \n-var universePos = token.Position{\"<universe>\", 0, 0, 0}\n+var universePos = token.NoPos\n \n /*\n  * Type array maps.  These are used to memoize composite types.\n@@ -140,7 +140,7 @@ func (commonType) isFloat() bool { return false }\n \n func (commonType) isIdeal() bool { return false }\n \n-func (commonType) Pos() token.Position { return token.Position{} }\n+func (commonType) Pos() token.Pos { return token.NoPos }\n \n /*\n  * Bool\n@@ -372,7 +372,6 @@ type floatType struct {\n var (\n \tFloat32Type = universe.DefineType(\"float32\", universePos, &floatType{commonType{}, 32, \"float32\"})\n \tFloat64Type = universe.DefineType(\"float64\", universePos, &floatType{commonType{}, 64, \"float64\"})\n-\tFloatType   = universe.DefineType(\"float\", universePos, &floatType{commonType{}, 0, \"float\"})\n )\n \n func (t *floatType) compat(o Type, conv bool) bool {\n@@ -394,9 +393,6 @@ func (t *floatType) Zero() Value {\n \tcase 64:\n \t\tres := float64V(0)\n \t\treturn &res\n-\tcase 0:\n-\t\tres := floatV(0)\n-\t\treturn &res\n \t}\n \tpanic(\"unexpected float bit count\")\n }\n@@ -408,9 +404,6 @@ var minFloat64Val *big.Rat\n \n func (t *floatType) minVal() *big.Rat {\n \tbits := t.Bits\n-\tif bits == 0 {\n-\t\tbits = uint(8 * unsafe.Sizeof(float(0)))\n-\t}\n \tswitch bits {\n \tcase 32:\n \t\treturn minFloat32Val\n@@ -423,9 +416,6 @@ func (t *floatType) minVal() *big.Rat {\n \n func (t *floatType) maxVal() *big.Rat {\n \tbits := t.Bits\n-\tif bits == 0 {\n-\t\tbits = uint(8 * unsafe.Sizeof(float(0)))\n-\t}\n \tswitch bits {\n \tcase 32:\n \t\treturn maxFloat32Val\n@@ -1100,8 +1090,8 @@ type Method struct {\n }\n \n type NamedType struct {\n-\ttoken.Position\n-\tName string\n+\tNamePos token.Pos\n+\tName    string\n \t// Underlying type.  If incomplete is true, this will be nil.\n \t// If incomplete is false and this is still nil, then this is\n \t// a placeholder type representing an error.\n@@ -1114,7 +1104,11 @@ type NamedType struct {\n // TODO(austin) This is temporarily needed by the debugger's remote\n // type parser.  This should only be possible with block.DefineType.\n func NewNamedType(name string) *NamedType {\n-\treturn &NamedType{token.Position{}, name, nil, true, make(map[string]Method)}\n+\treturn &NamedType{token.NoPos, name, nil, true, make(map[string]Method)}\n+}\n+\n+func (t *NamedType) Pos() token.Pos {\n+\treturn t.NamePos\n }\n \n func (t *NamedType) Complete(def Type) {"}, {"sha": "de90cf66496761e2d8310a34d3d0455da17702df", "filename": "libgo/go/exp/eval/typec.go", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fexp%2Feval%2Ftypec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fexp%2Feval%2Ftypec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Feval%2Ftypec.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -28,19 +28,19 @@ type typeCompiler struct {\n func (a *typeCompiler) compileIdent(x *ast.Ident, allowRec bool) Type {\n \t_, _, def := a.block.Lookup(x.Name)\n \tif def == nil {\n-\t\ta.diagAt(x, \"%s: undefined\", x.Name)\n+\t\ta.diagAt(x.Pos(), \"%s: undefined\", x.Name)\n \t\treturn nil\n \t}\n \tswitch def := def.(type) {\n \tcase *Constant:\n-\t\ta.diagAt(x, \"constant %v used as type\", x.Name)\n+\t\ta.diagAt(x.Pos(), \"constant %v used as type\", x.Name)\n \t\treturn nil\n \tcase *Variable:\n-\t\ta.diagAt(x, \"variable %v used as type\", x.Name)\n+\t\ta.diagAt(x.Pos(), \"variable %v used as type\", x.Name)\n \t\treturn nil\n \tcase *NamedType:\n \t\tif !allowRec && def.incomplete {\n-\t\t\ta.diagAt(x, \"illegal recursive type\")\n+\t\t\ta.diagAt(x.Pos(), \"illegal recursive type\")\n \t\t\treturn nil\n \t\t}\n \t\tif !def.incomplete && def.Def == nil {\n@@ -68,15 +68,15 @@ func (a *typeCompiler) compileArrayType(x *ast.ArrayType, allowRec bool) Type {\n \t}\n \n \tif _, ok := x.Len.(*ast.Ellipsis); ok {\n-\t\ta.diagAt(x.Len, \"... array initailizers not implemented\")\n+\t\ta.diagAt(x.Len.Pos(), \"... array initailizers not implemented\")\n \t\treturn nil\n \t}\n \tl, ok := a.compileArrayLen(a.block, x.Len)\n \tif !ok {\n \t\treturn nil\n \t}\n \tif l < 0 {\n-\t\ta.diagAt(x.Len, \"array length must be non-negative\")\n+\t\ta.diagAt(x.Len.Pos(), \"array length must be non-negative\")\n \t\treturn nil\n \t}\n \tif elem == nil {\n@@ -86,11 +86,11 @@ func (a *typeCompiler) compileArrayType(x *ast.ArrayType, allowRec bool) Type {\n \treturn NewArrayType(l, elem)\n }\n \n-func (a *typeCompiler) compileFields(fields *ast.FieldList, allowRec bool) ([]Type, []*ast.Ident, []token.Position, bool) {\n+func (a *typeCompiler) compileFields(fields *ast.FieldList, allowRec bool) ([]Type, []*ast.Ident, []token.Pos, bool) {\n \tn := fields.NumFields()\n \tts := make([]Type, n)\n \tns := make([]*ast.Ident, n)\n-\tps := make([]token.Position, n)\n+\tps := make([]token.Pos, n)\n \tbad := false\n \n \tif fields != nil {\n@@ -132,7 +132,7 @@ func (a *typeCompiler) compileStructType(x *ast.StructType, allowRec bool) Type\n \t// uniqueness of field names inherited from anonymous fields\n \t// at use time.\n \tfields := make([]StructField, len(ts))\n-\tnameSet := make(map[string]token.Position, len(ts))\n+\tnameSet := make(map[string]token.Pos, len(ts))\n \tfor i := range fields {\n \t\t// Compute field name and check anonymous fields\n \t\tvar name string\n@@ -162,7 +162,7 @@ func (a *typeCompiler) compileStructType(x *ast.StructType, allowRec bool) Type\n \t\t\t// *T, and T itself, may not be a pointer or\n \t\t\t// interface type.\n \t\t\tif nt == nil {\n-\t\t\t\ta.diagAt(&poss[i], \"embedded type must T or *T, where T is a named type\")\n+\t\t\t\ta.diagAt(poss[i], \"embedded type must T or *T, where T is a named type\")\n \t\t\t\tbad = true\n \t\t\t\tcontinue\n \t\t\t}\n@@ -172,7 +172,7 @@ func (a *typeCompiler) compileStructType(x *ast.StructType, allowRec bool) Type\n \t\t\tlateCheck := a.lateCheck\n \t\t\ta.lateCheck = func() bool {\n \t\t\t\tif _, ok := nt.lit().(*PtrType); ok {\n-\t\t\t\t\ta.diagAt(&poss[i], \"embedded type %v is a pointer type\", nt)\n+\t\t\t\t\ta.diagAt(poss[i], \"embedded type %v is a pointer type\", nt)\n \t\t\t\t\treturn false\n \t\t\t\t}\n \t\t\t\treturn lateCheck()\n@@ -181,7 +181,7 @@ func (a *typeCompiler) compileStructType(x *ast.StructType, allowRec bool) Type\n \n \t\t// Check name uniqueness\n \t\tif prev, ok := nameSet[name]; ok {\n-\t\t\ta.diagAt(&poss[i], \"field %s redeclared\\n\\tprevious declaration at %s\", name, &prev)\n+\t\t\ta.diagAt(poss[i], \"field %s redeclared\\n\\tprevious declaration at %s\", name, a.fset.Position(prev))\n \t\t\tbad = true\n \t\t\tcontinue\n \t\t}\n@@ -227,7 +227,7 @@ func (a *typeCompiler) compileInterfaceType(x *ast.InterfaceType, allowRec bool)\n \tts, names, poss, bad := a.compileFields(x.Methods, allowRec)\n \n \tmethods := make([]IMethod, len(ts))\n-\tnameSet := make(map[string]token.Position, len(ts))\n+\tnameSet := make(map[string]token.Pos, len(ts))\n \tembeds := make([]*InterfaceType, len(ts))\n \n \tvar nm, ne int\n@@ -242,7 +242,7 @@ func (a *typeCompiler) compileInterfaceType(x *ast.InterfaceType, allowRec bool)\n \t\t\tmethods[nm].Type = ts[i].(*FuncType)\n \t\t\tnm++\n \t\t\tif prev, ok := nameSet[name]; ok {\n-\t\t\t\ta.diagAt(&poss[i], \"method %s redeclared\\n\\tprevious declaration at %s\", name, &prev)\n+\t\t\t\ta.diagAt(poss[i], \"method %s redeclared\\n\\tprevious declaration at %s\", name, a.fset.Position(prev))\n \t\t\t\tbad = true\n \t\t\t\tcontinue\n \t\t\t}\n@@ -251,15 +251,15 @@ func (a *typeCompiler) compileInterfaceType(x *ast.InterfaceType, allowRec bool)\n \t\t\t// Embedded interface\n \t\t\tit, ok := ts[i].lit().(*InterfaceType)\n \t\t\tif !ok {\n-\t\t\t\ta.diagAt(&poss[i], \"embedded type must be an interface\")\n+\t\t\t\ta.diagAt(poss[i], \"embedded type must be an interface\")\n \t\t\t\tbad = true\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\tembeds[ne] = it\n \t\t\tne++\n \t\t\tfor _, m := range it.methods {\n \t\t\t\tif prev, ok := nameSet[m.Name]; ok {\n-\t\t\t\t\ta.diagAt(&poss[i], \"method %s redeclared\\n\\tprevious declaration at %s\", m.Name, &prev)\n+\t\t\t\t\ta.diagAt(poss[i], \"method %s redeclared\\n\\tprevious declaration at %s\", m.Name, a.fset.Position(prev))\n \t\t\t\t\tbad = true\n \t\t\t\t\tcontinue\n \t\t\t\t}\n@@ -288,13 +288,13 @@ func (a *typeCompiler) compileMapType(x *ast.MapType) Type {\n \t// that can be map keys except for function types.\n \tswitch key.lit().(type) {\n \tcase *StructType:\n-\t\ta.diagAt(x, \"map key cannot be a struct type\")\n+\t\ta.diagAt(x.Pos(), \"map key cannot be a struct type\")\n \t\treturn nil\n \tcase *ArrayType:\n-\t\ta.diagAt(x, \"map key cannot be an array type\")\n+\t\ta.diagAt(x.Pos(), \"map key cannot be an array type\")\n \t\treturn nil\n \tcase *SliceType:\n-\t\ta.diagAt(x, \"map key cannot be a slice type\")\n+\t\ta.diagAt(x.Pos(), \"map key cannot be a slice type\")\n \t\treturn nil\n \t}\n \treturn NewMapType(key, val)\n@@ -339,14 +339,14 @@ func (a *typeCompiler) compileType(x ast.Expr, allowRec bool) Type {\n \t\treturn a.compileType(x.X, allowRec)\n \n \tcase *ast.Ellipsis:\n-\t\ta.diagAt(x, \"illegal use of ellipsis\")\n+\t\ta.diagAt(x.Pos(), \"illegal use of ellipsis\")\n \t\treturn nil\n \t}\n-\ta.diagAt(x, \"expression used as type\")\n+\ta.diagAt(x.Pos(), \"expression used as type\")\n \treturn nil\n \n notimpl:\n-\ta.diagAt(x, \"compileType: %T not implemented\", x)\n+\ta.diagAt(x.Pos(), \"compileType: %T not implemented\", x)\n \treturn nil\n }\n "}, {"sha": "daa69189792bcea1419b71f71ef5e33a338ad972", "filename": "libgo/go/exp/eval/value.go", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fexp%2Feval%2Fvalue.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fexp%2Feval%2Fvalue.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Feval%2Fvalue.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -307,16 +307,6 @@ func (v *float64V) Get(*Thread) float64 { return float64(*v) }\n \n func (v *float64V) Set(t *Thread, x float64) { *v = float64V(x) }\n \n-type floatV float\n-\n-func (v *floatV) String() string { return fmt.Sprint(*v) }\n-\n-func (v *floatV) Assign(t *Thread, o Value) { *v = floatV(o.(FloatValue).Get(t)) }\n-\n-func (v *floatV) Get(*Thread) float64 { return float64(*v) }\n-\n-func (v *floatV) Set(t *Thread, x float64) { *v = floatV(x) }\n-\n /*\n  * Ideal float\n  */"}, {"sha": "02d18bd7935cf1d55e10ea6a177d546a2fb80dc5", "filename": "libgo/go/exp/eval/world.go", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fexp%2Feval%2Fworld.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fexp%2Feval%2Fworld.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Feval%2Fworld.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -41,14 +41,14 @@ type stmtCode struct {\n \tcode code\n }\n \n-func (w *World) CompileStmtList(stmts []ast.Stmt) (Code, os.Error) {\n+func (w *World) CompileStmtList(fset *token.FileSet, stmts []ast.Stmt) (Code, os.Error) {\n \tif len(stmts) == 1 {\n \t\tif s, ok := stmts[0].(*ast.ExprStmt); ok {\n-\t\t\treturn w.CompileExpr(s.X)\n+\t\t\treturn w.CompileExpr(fset, s.X)\n \t\t}\n \t}\n \terrors := new(scanner.ErrorVector)\n-\tcc := &compiler{errors, 0, 0}\n+\tcc := &compiler{fset, errors, 0, 0}\n \tcb := newCodeBuf()\n \tfc := &funcCompiler{\n \t\tcompiler:     cc,\n@@ -73,12 +73,12 @@ func (w *World) CompileStmtList(stmts []ast.Stmt) (Code, os.Error) {\n \treturn &stmtCode{w, fc.get()}, nil\n }\n \n-func (w *World) CompileDeclList(decls []ast.Decl) (Code, os.Error) {\n+func (w *World) CompileDeclList(fset *token.FileSet, decls []ast.Decl) (Code, os.Error) {\n \tstmts := make([]ast.Stmt, len(decls))\n \tfor i, d := range decls {\n \t\tstmts[i] = &ast.DeclStmt{d}\n \t}\n-\treturn w.CompileStmtList(stmts)\n+\treturn w.CompileStmtList(fset, stmts)\n }\n \n func (s *stmtCode) Type() Type { return nil }\n@@ -95,9 +95,9 @@ type exprCode struct {\n \teval func(Value, *Thread)\n }\n \n-func (w *World) CompileExpr(e ast.Expr) (Code, os.Error) {\n+func (w *World) CompileExpr(fset *token.FileSet, e ast.Expr) (Code, os.Error) {\n \terrors := new(scanner.ErrorVector)\n-\tcc := &compiler{errors, 0, 0}\n+\tcc := &compiler{fset, errors, 0, 0}\n \n \tec := cc.compileExpr(w.scope.block, false, e)\n \tif ec == nil {\n@@ -135,16 +135,16 @@ func (e *exprCode) Run() (Value, os.Error) {\n \treturn v, err\n }\n \n-func (w *World) Compile(text string) (Code, os.Error) {\n-\tstmts, err := parser.ParseStmtList(\"input\", text)\n+func (w *World) Compile(fset *token.FileSet, text string) (Code, os.Error) {\n+\tstmts, err := parser.ParseStmtList(fset, \"input\", text)\n \tif err == nil {\n-\t\treturn w.CompileStmtList(stmts)\n+\t\treturn w.CompileStmtList(fset, stmts)\n \t}\n \n \t// Otherwise try as DeclList.\n-\tdecls, err1 := parser.ParseDeclList(\"input\", text)\n+\tdecls, err1 := parser.ParseDeclList(fset, \"input\", text)\n \tif err1 == nil {\n-\t\treturn w.CompileDeclList(decls)\n+\t\treturn w.CompileDeclList(fset, decls)\n \t}\n \n \t// Have to pick an error.\n@@ -162,21 +162,24 @@ func (e *RedefinitionError) String() string {\n \tres := \"identifier \" + e.Name + \" redeclared\"\n \tpos := e.Prev.Pos()\n \tif pos.IsValid() {\n-\t\tres += \"; previous declaration at \" + pos.String()\n+\t\t// TODO: fix this - currently this code is not reached by the tests\n+\t\t//       need to get a file set (fset) from somewhere\n+\t\t//res += \"; previous declaration at \" + fset.Position(pos).String()\n+\t\tpanic(0)\n \t}\n \treturn res\n }\n \n func (w *World) DefineConst(name string, t Type, val Value) os.Error {\n-\t_, prev := w.scope.DefineConst(name, token.Position{}, t, val)\n+\t_, prev := w.scope.DefineConst(name, token.NoPos, t, val)\n \tif prev != nil {\n \t\treturn &RedefinitionError{name, prev}\n \t}\n \treturn nil\n }\n \n func (w *World) DefineVar(name string, t Type, val Value) os.Error {\n-\tv, prev := w.scope.DefineVar(name, token.Position{}, t)\n+\tv, prev := w.scope.DefineVar(name, token.NoPos, t)\n \tif prev != nil {\n \t\treturn &RedefinitionError{name, prev}\n \t}"}, {"sha": "2b980f59687cc9a602421b8e7a789fd7789caf0d", "filename": "libgo/go/exp/nacl/av/av.go", "status": "removed", "additions": 0, "deletions": 289, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6ed1c8903e728f4233122554bab5910853338bd/libgo%2Fgo%2Fexp%2Fnacl%2Fav%2Fav.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6ed1c8903e728f4233122554bab5910853338bd/libgo%2Fgo%2Fexp%2Fnacl%2Fav%2Fav.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnacl%2Fav%2Fav.go?ref=d6ed1c8903e728f4233122554bab5910853338bd", "patch": "@@ -1,289 +0,0 @@\n-// Copyright 2009 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Native Client audio/video\n-\n-// Package av implements audio and video access for Native Client\n-// binaries running standalone or embedded in a web browser window.\n-//\n-// The C version of the API is documented at\n-// http://nativeclient.googlecode.com/svn/data/docs_tarball/nacl/googleclient/native_client/scons-out/doc/html/group__audio__video.html\n-package av\n-\n-import (\n-\t\"exp/draw\"\n-\t\"exp/nacl/srpc\"\n-\t\"log\"\n-\t\"os\"\n-\t\"syscall\"\n-\t\"unsafe\"\n-)\n-\n-var srpcEnabled = srpc.Enabled()\n-\n-// native_client/src/trusted/service_runtime/include/sys/audio_video.h\n-\n-// Subsystem values for Init.\n-const (\n-\tSubsystemVideo = 1 << iota\n-\tSubsystemAudio\n-\tSubsystemEmbed\n-)\n-//\tSubsystemRawEvents;\n-\n-// Audio formats.\n-const (\n-\tAudioFormatStereo44K = iota\n-\tAudioFormatStereo48K\n-)\n-\n-// A Window represents a connection to the Native Client window.\n-// It implements draw.Context.\n-type Window struct {\n-\tEmbedded bool // running as part of a web page?\n-\t*Image        // screen image\n-\teventc   chan interface{}\n-}\n-\n-// *Window implements draw.Window.\n-var _ draw.Window = (*Window)(nil)\n-\n-func (w *Window) EventChan() <-chan interface{} { return w.eventc }\n-\n-func (w *Window) Close() os.Error {\n-\t// TODO(nigeltao): implement.\n-\treturn nil\n-}\n-\n-func (w *Window) Screen() draw.Image { return w.Image }\n-\n-// Init initializes the Native Client subsystems specified by subsys.\n-// Init must be called before using any of the other functions\n-// in this package, and it must be called only once.\n-//\n-// If the SubsystemVideo flag is set, Init requests a window of size dx\u00d7dy.\n-// When embedded in a web page, the web page's window specification\n-// overrides the parameters to Init, so the returned Window may have\n-// a different size than requested.\n-//\n-// If the SubsystemAudio flag is set, Init requests a connection to the\n-// audio device carrying 44 kHz 16-bit stereo PCM audio samples.\n-func Init(subsys int, dx, dy int) (*Window, os.Error) {\n-\txsubsys := subsys\n-\tif srpcEnabled {\n-\t\twaitBridge()\n-\t\txsubsys &^= SubsystemVideo | SubsystemEmbed\n-\t}\n-\n-\tif xsubsys&SubsystemEmbed != 0 {\n-\t\treturn nil, os.NewError(\"not embedded\")\n-\t}\n-\n-\tw := new(Window)\n-\terr := multimediaInit(xsubsys)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\tif subsys&SubsystemVideo != 0 {\n-\t\tif dx, dy, err = videoInit(dx, dy); err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t\tw.Image = newImage(dx, dy, bridge.pixel)\n-\t\tw.eventc = make(chan interface{}, 64)\n-\t}\n-\n-\tif subsys&SubsystemAudio != 0 {\n-\t\tvar n int\n-\t\tif n, err = audioInit(AudioFormatStereo44K, 2048); err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t\tprintln(\"audio\", n)\n-\t}\n-\n-\tif subsys&SubsystemVideo != 0 {\n-\t\tgo w.readEvents()\n-\t}\n-\n-\treturn w, nil\n-}\n-\n-func (w *Window) FlushImage() {\n-\tif w.Image == nil {\n-\t\treturn\n-\t}\n-\tvideoUpdate(w.Image.Linear)\n-}\n-\n-func multimediaInit(subsys int) (err os.Error) {\n-\treturn os.NewSyscallError(\"multimedia_init\", syscall.MultimediaInit(subsys))\n-}\n-\n-func videoInit(dx, dy int) (ndx, ndy int, err os.Error) {\n-\tif srpcEnabled {\n-\t\tbridge.share.ready = 1\n-\t\treturn int(bridge.share.width), int(bridge.share.height), nil\n-\t}\n-\tif e := syscall.VideoInit(dx, dy); e != 0 {\n-\t\treturn 0, 0, os.NewSyscallError(\"video_init\", int(e))\n-\t}\n-\treturn dx, dy, nil\n-}\n-\n-func videoUpdate(data []Color) (err os.Error) {\n-\tif srpcEnabled {\n-\t\tbridge.flushRPC.Call(\"upcall\", nil)\n-\t\treturn\n-\t}\n-\treturn os.NewSyscallError(\"video_update\", syscall.VideoUpdate((*uint32)(&data[0])))\n-}\n-\n-var noEvents = os.NewError(\"no events\")\n-\n-func videoPollEvent(ev []byte) (err os.Error) {\n-\tif srpcEnabled {\n-\t\tr := bridge.share.eq.ri\n-\t\tif r == bridge.share.eq.wi {\n-\t\t\treturn noEvents\n-\t\t}\n-\t\tcopy(ev, bridge.share.eq.event[r][0:])\n-\t\tbridge.share.eq.ri = (r + 1) % eqsize\n-\t\treturn nil\n-\t}\n-\treturn os.NewSyscallError(\"video_poll_event\", syscall.VideoPollEvent(&ev[0]))\n-}\n-\n-func audioInit(fmt int, want int) (got int, err os.Error) {\n-\tvar x int\n-\te := syscall.AudioInit(fmt, want, &x)\n-\tif e == 0 {\n-\t\treturn x, nil\n-\t}\n-\treturn 0, os.NewSyscallError(\"audio_init\", e)\n-}\n-\n-var audioSize uintptr\n-\n-// AudioStream provides access to the audio device.\n-// Each call to AudioStream writes the given data,\n-// which should be a slice of 16-bit stereo PCM audio samples,\n-// and returns the number of samples required by the next\n-// call to AudioStream.\n-//\n-// To find out the initial number of samples to write, call AudioStream(nil).\n-//\n-func AudioStream(data []uint16) (nextSize int, err os.Error) {\n-\tif audioSize == 0 {\n-\t\te := os.NewSyscallError(\"audio_stream\", syscall.AudioStream(nil, &audioSize))\n-\t\treturn int(audioSize), e\n-\t}\n-\tif data == nil {\n-\t\treturn int(audioSize), nil\n-\t}\n-\tif uintptr(len(data))*2 != audioSize {\n-\t\tlog.Printf(\"invalid audio size want %d got %d\", audioSize, len(data))\n-\t}\n-\te := os.NewSyscallError(\"audio_stream\", syscall.AudioStream(&data[0], &audioSize))\n-\treturn int(audioSize), e\n-}\n-\n-// Synchronization structure to wait for bridge to become ready.\n-var bridge struct {\n-\tc         chan bool\n-\tdisplayFd int\n-\trpcFd     int\n-\tshare     *videoShare\n-\tpixel     []Color\n-\tclient    *srpc.Client\n-\tflushRPC  *srpc.RPC\n-}\n-\n-// Wait for bridge to become ready.\n-// When chan is first created, there is nothing in it,\n-// so this blocks.  Once the bridge is ready, multimediaBridge.Run\n-// will drop a value into the channel.  Then any calls\n-// to waitBridge will finish, taking the value out and immediately putting it back.\n-func waitBridge() { bridge.c <- <-bridge.c }\n-\n-const eqsize = 64\n-\n-// Data structure shared with host via mmap.\n-type videoShare struct {\n-\trevision int32 // definition below is rev 100 unless noted\n-\tmapSize  int32\n-\n-\t// event queue\n-\teq struct {\n-\t\tri    uint32 // read index [0,eqsize)\n-\t\twi    uint32 // write index [0,eqsize)\n-\t\teof   int32\n-\t\tevent [eqsize][64]byte\n-\t}\n-\n-\t// now unused\n-\t_, _, _, _ int32\n-\n-\t// video backing store information\n-\twidth, height, _, size int32\n-\tready                  int32 // rev 0x101\n-}\n-\n-// The frame buffer data is videoShareSize bytes after\n-// the videoShare begins.\n-const videoShareSize = 16 * 1024\n-\n-type multimediaBridge struct{}\n-\n-// If using SRPC, the runtime will call this method to pass in two file descriptors,\n-// one to mmap to get the display memory, and another to use for SRPCs back\n-// to the main process.\n-func (multimediaBridge) Run(arg, ret []interface{}, size []int) srpc.Errno {\n-\tbridge.displayFd = arg[0].(int)\n-\tbridge.rpcFd = arg[1].(int)\n-\n-\tvar st syscall.Stat_t\n-\tif errno := syscall.Fstat(bridge.displayFd, &st); errno != 0 {\n-\t\tlog.Exitf(\"mmbridge stat display: %s\", os.Errno(errno))\n-\t}\n-\n-\taddr, _, errno := syscall.Syscall6(syscall.SYS_MMAP,\n-\t\t0,\n-\t\tuintptr(st.Size),\n-\t\tsyscall.PROT_READ|syscall.PROT_WRITE,\n-\t\tsyscall.MAP_SHARED,\n-\t\tuintptr(bridge.displayFd),\n-\t\t0)\n-\tif errno != 0 {\n-\t\tlog.Exitf(\"mmap display: %s\", os.Errno(errno))\n-\t}\n-\n-\tbridge.share = (*videoShare)(unsafe.Pointer(addr))\n-\n-\t// Overestimate frame buffer size\n-\t// (must use a compile-time constant)\n-\t// and then reslice.  256 megapixels (1 GB) should be enough.\n-\tfb := (*[256 * 1024 * 1024]Color)(unsafe.Pointer(addr + videoShareSize))\n-\tbridge.pixel = fb[0 : (st.Size-videoShareSize)/4]\n-\n-\t// Configure RPC connection back to client.\n-\tvar err os.Error\n-\tbridge.client, err = srpc.NewClient(bridge.rpcFd)\n-\tif err != nil {\n-\t\tlog.Exitf(\"NewClient: %s\", err)\n-\t}\n-\tbridge.flushRPC = bridge.client.NewRPC(nil)\n-\n-\t// Notify waiters that the bridge is ready.\n-\tprintln(\"bridged\", bridge.share.revision)\n-\tbridge.c <- true\n-\n-\treturn srpc.OK\n-}\n-\n-func init() {\n-\tbridge.c = make(chan bool, 1)\n-\tif srpcEnabled {\n-\t\tsrpc.Add(\"nacl_multimedia_bridge\", \"hh:\", multimediaBridge{})\n-\t}\n-}"}, {"sha": "f8fe329b8a8f1308f0dcf7afa38cdf1add6e6400", "filename": "libgo/go/exp/nacl/av/event.go", "status": "removed", "additions": 0, "deletions": 473, "changes": 473, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6ed1c8903e728f4233122554bab5910853338bd/libgo%2Fgo%2Fexp%2Fnacl%2Fav%2Fevent.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6ed1c8903e728f4233122554bab5910853338bd/libgo%2Fgo%2Fexp%2Fnacl%2Fav%2Fevent.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnacl%2Fav%2Fevent.go?ref=d6ed1c8903e728f4233122554bab5910853338bd", "patch": "@@ -1,473 +0,0 @@\n-// Copyright 2009 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// NaCl GUI events.\n-// Clients do not have raw access to the event stream\n-// (only filtered through the lens of package draw)\n-// but perhaps they will.\n-\n-package av\n-\n-import (\n-\t\"encoding/binary\"\n-\t\"exp/draw\"\n-\t\"image\"\n-\t\"log\"\n-\t\"os\"\n-\t\"time\"\n-)\n-\n-// An eventType identifies the type of a Native Client Event.\n-type eventType uint8\n-\n-const (\n-\teventActive = 1 + iota\n-\teventExpose\n-\teventKeyDown\n-\teventKeyUp\n-\teventMouseMotion\n-\teventMouseButtonDown\n-\teventMouseButtonUp\n-\teventQuit\n-\teventUnsupported\n-)\n-\n-// A key represents a key on a keyboard.\n-type key uint16\n-\n-const (\n-\tkeyUnknown      = 0\n-\tkeyFirst        = 0\n-\tkeyBackspace    = 8\n-\tkeyTab          = 9\n-\tkeyClear        = 12\n-\tkeyReturn       = 13\n-\tkeyPause        = 19\n-\tkeyEscape       = 27\n-\tkeySpace        = 32\n-\tkeyExclaim      = 33\n-\tkeyQuotedbl     = 34\n-\tkeyHash         = 35\n-\tkeyDollar       = 36\n-\tkeyAmpersand    = 38\n-\tkeyQuote        = 39\n-\tkeyLeftparen    = 40\n-\tkeyRightparen   = 41\n-\tkeyAsterisk     = 42\n-\tkeyPlus         = 43\n-\tkeyComma        = 44\n-\tkeyMinus        = 45\n-\tkeyPeriod       = 46\n-\tkeySlash        = 47\n-\tkey0            = 48\n-\tkey1            = 49\n-\tkey2            = 50\n-\tkey3            = 51\n-\tkey4            = 52\n-\tkey5            = 53\n-\tkey6            = 54\n-\tkey7            = 55\n-\tkey8            = 56\n-\tkey9            = 57\n-\tkeyColon        = 58\n-\tkeySemicolon    = 59\n-\tkeyLess         = 60\n-\tkeyEquals       = 61\n-\tkeyGreater      = 62\n-\tkeyQuestion     = 63\n-\tkeyAt           = 64\n-\tkeyLeftbracket  = 91\n-\tkeyBackslash    = 92\n-\tkeyRightbracket = 93\n-\tkeyCaret        = 94\n-\tkeyUnderscore   = 95\n-\tkeyBackquote    = 96\n-\tkeyA            = 97\n-\tkeyB            = 98\n-\tkeyC            = 99\n-\tkeyD            = 100\n-\tkeyE            = 101\n-\tkeyF            = 102\n-\tkeyG            = 103\n-\tkeyH            = 104\n-\tkeyI            = 105\n-\tkeyJ            = 106\n-\tkeyK            = 107\n-\tkeyL            = 108\n-\tkeyM            = 109\n-\tkeyN            = 110\n-\tkeyO            = 111\n-\tkeyP            = 112\n-\tkeyQ            = 113\n-\tkeyR            = 114\n-\tkeyS            = 115\n-\tkeyT            = 116\n-\tkeyU            = 117\n-\tkeyV            = 118\n-\tkeyW            = 119\n-\tkeyX            = 120\n-\tkeyY            = 121\n-\tkeyZ            = 122\n-\tkeyDelete       = 127\n-\tkeyWorld0       = 160\n-\tkeyWorld1       = 161\n-\tkeyWorld2       = 162\n-\tkeyWorld3       = 163\n-\tkeyWorld4       = 164\n-\tkeyWorld5       = 165\n-\tkeyWorld6       = 166\n-\tkeyWorld7       = 167\n-\tkeyWorld8       = 168\n-\tkeyWorld9       = 169\n-\tkeyWorld10      = 170\n-\tkeyWorld11      = 171\n-\tkeyWorld12      = 172\n-\tkeyWorld13      = 173\n-\tkeyWorld14      = 174\n-\tkeyWorld15      = 175\n-\tkeyWorld16      = 176\n-\tkeyWorld17      = 177\n-\tkeyWorld18      = 178\n-\tkeyWorld19      = 179\n-\tkeyWorld20      = 180\n-\tkeyWorld21      = 181\n-\tkeyWorld22      = 182\n-\tkeyWorld23      = 183\n-\tkeyWorld24      = 184\n-\tkeyWorld25      = 185\n-\tkeyWorld26      = 186\n-\tkeyWorld27      = 187\n-\tkeyWorld28      = 188\n-\tkeyWorld29      = 189\n-\tkeyWorld30      = 190\n-\tkeyWorld31      = 191\n-\tkeyWorld32      = 192\n-\tkeyWorld33      = 193\n-\tkeyWorld34      = 194\n-\tkeyWorld35      = 195\n-\tkeyWorld36      = 196\n-\tkeyWorld37      = 197\n-\tkeyWorld38      = 198\n-\tkeyWorld39      = 199\n-\tkeyWorld40      = 200\n-\tkeyWorld41      = 201\n-\tkeyWorld42      = 202\n-\tkeyWorld43      = 203\n-\tkeyWorld44      = 204\n-\tkeyWorld45      = 205\n-\tkeyWorld46      = 206\n-\tkeyWorld47      = 207\n-\tkeyWorld48      = 208\n-\tkeyWorld49      = 209\n-\tkeyWorld50      = 210\n-\tkeyWorld51      = 211\n-\tkeyWorld52      = 212\n-\tkeyWorld53      = 213\n-\tkeyWorld54      = 214\n-\tkeyWorld55      = 215\n-\tkeyWorld56      = 216\n-\tkeyWorld57      = 217\n-\tkeyWorld58      = 218\n-\tkeyWorld59      = 219\n-\tkeyWorld60      = 220\n-\tkeyWorld61      = 221\n-\tkeyWorld62      = 222\n-\tkeyWorld63      = 223\n-\tkeyWorld64      = 224\n-\tkeyWorld65      = 225\n-\tkeyWorld66      = 226\n-\tkeyWorld67      = 227\n-\tkeyWorld68      = 228\n-\tkeyWorld69      = 229\n-\tkeyWorld70      = 230\n-\tkeyWorld71      = 231\n-\tkeyWorld72      = 232\n-\tkeyWorld73      = 233\n-\tkeyWorld74      = 234\n-\tkeyWorld75      = 235\n-\tkeyWorld76      = 236\n-\tkeyWorld77      = 237\n-\tkeyWorld78      = 238\n-\tkeyWorld79      = 239\n-\tkeyWorld80      = 240\n-\tkeyWorld81      = 241\n-\tkeyWorld82      = 242\n-\tkeyWorld83      = 243\n-\tkeyWorld84      = 244\n-\tkeyWorld85      = 245\n-\tkeyWorld86      = 246\n-\tkeyWorld87      = 247\n-\tkeyWorld88      = 248\n-\tkeyWorld89      = 249\n-\tkeyWorld90      = 250\n-\tkeyWorld91      = 251\n-\tkeyWorld92      = 252\n-\tkeyWorld93      = 253\n-\tkeyWorld94      = 254\n-\tkeyWorld95      = 255\n-\n-\t// Numeric keypad\n-\tkeyKp0        = 256\n-\tkeyKp1        = 257\n-\tkeyKp2        = 258\n-\tkeyKp3        = 259\n-\tkeyKp4        = 260\n-\tkeyKp5        = 261\n-\tkeyKp6        = 262\n-\tkeyKp7        = 263\n-\tkeyKp8        = 264\n-\tkeyKp9        = 265\n-\tkeyKpPeriod   = 266\n-\tkeyKpDivide   = 267\n-\tkeyKpMultiply = 268\n-\tkeyKpMinus    = 269\n-\tkeyKpPlus     = 270\n-\tkeyKpEnter    = 271\n-\tkeyKpEquals   = 272\n-\n-\t// Arrow & insert/delete pad\n-\tkeyUp       = 273\n-\tkeyDown     = 274\n-\tkeyRight    = 275\n-\tkeyLeft     = 276\n-\tkeyInsert   = 277\n-\tkeyHome     = 278\n-\tkeyEnd      = 279\n-\tkeyPageup   = 280\n-\tkeyPagedown = 281\n-\n-\t// Function keys\n-\tkeyF1  = 282\n-\tkeyF2  = 283\n-\tkeyF3  = 284\n-\tkeyF4  = 285\n-\tkeyF5  = 286\n-\tkeyF6  = 287\n-\tkeyF7  = 288\n-\tkeyF8  = 289\n-\tkeyF9  = 290\n-\tkeyF10 = 291\n-\tkeyF11 = 292\n-\tkeyF12 = 293\n-\tkeyF13 = 294\n-\tkeyF14 = 295\n-\tkeyF15 = 296\n-\n-\t// Modifier keys\n-\tkeyNumlock   = 300\n-\tkeyCapslock  = 301\n-\tkeyScrollock = 302\n-\tkeyRshift    = 303\n-\tkeyLshift    = 304\n-\tkeyRctrl     = 305\n-\tkeyLctrl     = 306\n-\tkeyRalt      = 307\n-\tkeyLalt      = 308\n-\tkeyRmeta     = 309\n-\tkeyLmeta     = 310\n-\tkeyLsuper    = 311\n-\tkeyRsuper    = 312\n-\tkeyMode      = 313\n-\tkeyCompose   = 314\n-\n-\t// Misc keys\n-\tkeyHelp   = 315\n-\tkeyPrint  = 316\n-\tkeySysreq = 317\n-\tkeyBreak  = 318\n-\tkeyMenu   = 319\n-\tkeyPower  = 320\n-\tkeyEuro   = 321\n-\tkeyUndo   = 322\n-\n-\t// Add any other keys here\n-\tkeyLast\n-)\n-\n-// A keymod is a set of bit flags\n-type keymod uint16\n-\n-const (\n-\tkeymodNone     = 0x0000\n-\tkeymodLshift   = 0x0001\n-\tkeymodRshift   = 0x0002\n-\tkeymodLctrl    = 0x0040\n-\tkeymodRctrl    = 0x0080\n-\tkeymodLalt     = 0x0100\n-\tkeymodRalt     = 0x0200\n-\tkeymodLmeta    = 0x0400\n-\tkeymodRmeta    = 0x0800\n-\tkeymodNum      = 0x1000\n-\tkeymodCaps     = 0x2000\n-\tkeymodMode     = 0x4000\n-\tkeymodReserved = 0x8000\n-)\n-\n-const (\n-\tmouseButtonLeft   = 1\n-\tmouseButtonMiddle = 2\n-\tmouseButtonRight  = 3\n-\tmouseScrollUp     = 4\n-\tmouseScrollDown   = 5\n-)\n-\n-const (\n-\tmouseStateLeftButtonPressed   = 1\n-\tmouseStateMiddleButtonPressed = 2\n-\tmouseStateRightButtonPressed  = 4\n-)\n-\n-const (\n-\tactiveMouse       = 1 //  mouse leaving/entering\n-\tactiveInputFocus  = 2 // input focus lost/restored\n-\tactiveApplication = 4 // application minimized/restored\n-)\n-\n-const maxEventBytes = 64\n-\n-type activeEvent struct {\n-\tEventType eventType\n-\tGain      uint8\n-\tState     uint8\n-}\n-\n-type exposeEvent struct {\n-\tEventType eventType\n-}\n-\n-type keyboardEvent struct {\n-\tEventType eventType\n-\tDevice    uint8\n-\tState     uint8\n-\tPad       uint8\n-\tScanCode  uint8\n-\tPad1      uint8\n-\tKey       key\n-\tMod       keymod\n-\tUnicode   uint16\n-}\n-\n-type mouseMotionEvent struct {\n-\tEventType eventType\n-\tDevice    uint8\n-\tButtons   uint8\n-\tPad       uint8\n-\tX         uint16\n-\tY         uint16\n-\tXrel      int16\n-\tYrel      int16\n-}\n-\n-type mouseButtonEvent struct {\n-\tEventType eventType\n-\tDevice    uint8\n-\tButton    uint8\n-\tState     uint8\n-\tX         uint16\n-\tY         uint16\n-}\n-\n-type quitEvent struct {\n-\tEventType eventType\n-}\n-\n-type syncEvent struct{}\n-\n-type event interface{}\n-\n-type reader []byte\n-\n-func (r *reader) Read(p []byte) (n int, err os.Error) {\n-\tb := *r\n-\tif len(b) == 0 && len(p) > 0 {\n-\t\treturn 0, os.EOF\n-\t}\n-\tn = copy(p, b)\n-\t*r = b[n:]\n-\treturn\n-}\n-\n-func (w *Window) readEvents() {\n-\tbuf := make([]byte, maxEventBytes)\n-\tclean := false\n-\tvar (\n-\t\tea  *activeEvent\n-\t\tee  *exposeEvent\n-\t\tke  *keyboardEvent\n-\t\tmme *mouseMotionEvent\n-\t\tmbe *mouseButtonEvent\n-\t\tqe  *quitEvent\n-\t)\n-\tvar m draw.MouseEvent\n-\tfor {\n-\t\tif err := videoPollEvent(buf); err != nil {\n-\t\t\tif !clean {\n-\t\t\t\tclean = w.eventc <- draw.ConfigEvent{image.Config{ColorModel, w.Image.Bounds().Dx(), w.Image.Bounds().Dy()}}\n-\t\t\t}\n-\t\t\ttime.Sleep(10e6) // 10ms\n-\t\t\tcontinue\n-\t\t}\n-\t\tclean = false\n-\t\tvar e event\n-\t\tswitch buf[0] {\n-\t\tdefault:\n-\t\t\tlog.Print(\"unsupported event type\", buf[0])\n-\t\t\tcontinue\n-\t\tcase eventActive:\n-\t\t\tea = new(activeEvent)\n-\t\t\te = ea\n-\t\tcase eventExpose:\n-\t\t\tee = new(exposeEvent)\n-\t\t\te = ee\n-\t\tcase eventKeyDown, eventKeyUp:\n-\t\t\tke = new(keyboardEvent)\n-\t\t\te = ke\n-\t\tcase eventMouseMotion:\n-\t\t\tmme = new(mouseMotionEvent)\n-\t\t\te = mme\n-\t\tcase eventMouseButtonDown, eventMouseButtonUp:\n-\t\t\tmbe = new(mouseButtonEvent)\n-\t\t\te = mbe\n-\t\tcase eventQuit:\n-\t\t\tqe = new(quitEvent)\n-\t\t\te = qe\n-\t\t}\n-\t\tr := reader(buf)\n-\t\tif err := binary.Read(&r, binary.LittleEndian, e); err != nil {\n-\t\t\tlog.Print(\"unpacking %T event: %s\", e, err)\n-\t\t\tcontinue\n-\t\t}\n-\t\t// log.Printf(\"%#v\\n\", e);\n-\t\tswitch buf[0] {\n-\t\tcase eventExpose:\n-\t\t\tw.eventc <- draw.ConfigEvent{image.Config{ColorModel, w.Image.Bounds().Dx(), w.Image.Bounds().Dy()}}\n-\t\tcase eventKeyDown:\n-\t\t\tw.eventc <- draw.KeyEvent{int(ke.Key)}\n-\t\tcase eventKeyUp:\n-\t\t\tw.eventc <- draw.KeyEvent{-int(ke.Key)}\n-\t\tcase eventMouseMotion:\n-\t\t\tm.Loc.X = int(mme.X)\n-\t\t\tm.Loc.Y = int(mme.Y)\n-\t\t\tm.Buttons = int(mme.Buttons)\n-\t\t\tm.Nsec = time.Nanoseconds()\n-\t\t\t_ = w.eventc <- m\n-\t\tcase eventMouseButtonDown:\n-\t\t\tm.Loc.X = int(mbe.X)\n-\t\t\tm.Loc.Y = int(mbe.Y)\n-\t\t\t// TODO(rsc): Remove uint cast once 8g bug is fixed.\n-\t\t\tm.Buttons |= 1 << uint(mbe.Button-1)\n-\t\t\tm.Nsec = time.Nanoseconds()\n-\t\t\t_ = w.eventc <- m\n-\t\tcase eventMouseButtonUp:\n-\t\t\tm.Loc.X = int(mbe.X)\n-\t\t\tm.Loc.Y = int(mbe.Y)\n-\t\t\t// TODO(rsc): Remove uint cast once 8g bug is fixed.\n-\t\t\tm.Buttons &^= 1 << uint(mbe.Button-1)\n-\t\t\tm.Nsec = time.Nanoseconds()\n-\t\t\t_ = w.eventc <- m\n-\t\tcase eventQuit:\n-\t\t\tclose(w.eventc)\n-\t\t}\n-\t}\n-}"}, {"sha": "2ff4bb69c144a43357d4b0015ceddc2d5fc35b59", "filename": "libgo/go/exp/nacl/av/image.go", "status": "removed", "additions": 0, "deletions": 84, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6ed1c8903e728f4233122554bab5910853338bd/libgo%2Fgo%2Fexp%2Fnacl%2Fav%2Fimage.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6ed1c8903e728f4233122554bab5910853338bd/libgo%2Fgo%2Fexp%2Fnacl%2Fav%2Fimage.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnacl%2Fav%2Fimage.go?ref=d6ed1c8903e728f4233122554bab5910853338bd", "patch": "@@ -1,84 +0,0 @@\n-// Copyright 2009 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package av\n-\n-import (\n-\t\"image\"\n-)\n-\n-// Native Client image format:\n-// a single linear array of 32-bit ARGB as packed uint32s.\n-\n-// An Image represents a Native Client frame buffer.\n-// The pixels in the image can be accessed as a single\n-// linear slice or as a two-dimensional slice of slices.\n-// Image implements image.Image.\n-type Image struct {\n-\tLinear []Color\n-\tPixel  [][]Color\n-}\n-\n-var _ image.Image = (*Image)(nil)\n-\n-func (m *Image) ColorModel() image.ColorModel { return ColorModel }\n-\n-func (m *Image) Bounds() image.Rectangle {\n-\tif len(m.Pixel) == 0 {\n-\t\treturn image.ZR\n-\t}\n-\treturn image.Rectangle{image.ZP, image.Point{len(m.Pixel[0]), len(m.Pixel)}}\n-}\n-\n-func (m *Image) At(x, y int) image.Color { return m.Pixel[y][x] }\n-\n-func (m *Image) Set(x, y int, color image.Color) {\n-\tif c, ok := color.(Color); ok {\n-\t\tm.Pixel[y][x] = c\n-\t\treturn\n-\t}\n-\tm.Pixel[y][x] = makeColor(color.RGBA())\n-}\n-\n-func newImage(dx, dy int, linear []Color) *Image {\n-\tif linear == nil {\n-\t\tlinear = make([]Color, dx*dy)\n-\t}\n-\tpix := make([][]Color, dy)\n-\tfor i := range pix {\n-\t\tpix[i] = linear[dx*i : dx*(i+1)]\n-\t}\n-\treturn &Image{linear, pix}\n-}\n-\n-// A Color represents a Native Client color value,\n-// a 32-bit R, G, B, A value packed as 0xAARRGGBB.\n-type Color uint32\n-\n-func (p Color) RGBA() (r, g, b, a uint32) {\n-\tx := uint32(p)\n-\ta = x >> 24\n-\ta |= a << 8\n-\tr = (x >> 16) & 0xFF\n-\tr |= r << 8\n-\tg = (x >> 8) & 0xFF\n-\tg |= g << 8\n-\tb = x & 0xFF\n-\tb |= b << 8\n-\treturn\n-}\n-\n-func makeColor(r, g, b, a uint32) Color {\n-\treturn Color(a>>8<<24 | r>>8<<16 | g>>8<<8 | b>>8)\n-}\n-\n-func toColor(color image.Color) image.Color {\n-\tif c, ok := color.(Color); ok {\n-\t\treturn c\n-\t}\n-\treturn makeColor(color.RGBA())\n-}\n-\n-// ColorModel is the color model corresponding to the Native Client Color.\n-var ColorModel = image.ColorModelFunc(toColor)"}, {"sha": "3e421e4c015125465023bb4f743fe897cd0d001d", "filename": "libgo/go/exp/nacl/srpc/client.go", "status": "removed", "additions": 0, "deletions": 210, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6ed1c8903e728f4233122554bab5910853338bd/libgo%2Fgo%2Fexp%2Fnacl%2Fsrpc%2Fclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6ed1c8903e728f4233122554bab5910853338bd/libgo%2Fgo%2Fexp%2Fnacl%2Fsrpc%2Fclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnacl%2Fsrpc%2Fclient.go?ref=d6ed1c8903e728f4233122554bab5910853338bd", "patch": "@@ -1,210 +0,0 @@\n-// Copyright 2009 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// This package implements Native Client's simple RPC (SRPC).\n-package srpc\n-\n-import (\n-\t\"bytes\"\n-\t\"log\"\n-\t\"os\"\n-\t\"sync\"\n-)\n-\n-// A Client represents the client side of an SRPC connection.\n-type Client struct {\n-\tfd      int // fd to server\n-\tr       msgReceiver\n-\ts       msgSender\n-\tservice map[string]srv // services by name\n-\tout     chan *msg      // send to out to write to connection\n-\n-\tmu      sync.Mutex // protects pending, idGen\n-\tpending map[uint64]*RPC\n-\tidGen   uint64 // generator for request IDs\n-}\n-\n-// A srv is a single method that the server offers.\n-type srv struct {\n-\tnum uint32 // method number\n-\tfmt string // argument format\n-}\n-\n-// An RPC represents a single RPC issued by a client.\n-type RPC struct {\n-\tRet   []interface{} // Return values\n-\tDone  chan *RPC     // Channel where notification of done arrives\n-\tErrno Errno         // Status code\n-\tc     *Client\n-\tid    uint64 // request id\n-}\n-\n-// NewClient allocates a new client using the file descriptor fd.\n-func NewClient(fd int) (c *Client, err os.Error) {\n-\tc = new(Client)\n-\tc.fd = fd\n-\tc.r.fd = fd\n-\tc.s.fd = fd\n-\tc.service = make(map[string]srv)\n-\tc.pending = make(map[uint64]*RPC)\n-\n-\t// service discovery request\n-\tm := &msg{\n-\t\tprotocol: protocol,\n-\t\tisReq:    true,\n-\t\tRet:      []interface{}{[]byte(nil)},\n-\t\tSize:     []int{4000},\n-\t}\n-\tm.packRequest()\n-\tc.s.send(m)\n-\tm, err = c.r.recv()\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\tm.unpackResponse()\n-\tif m.status != OK {\n-\t\tlog.Printf(\"NewClient service_discovery: %s\", m.status)\n-\t\treturn nil, m.status\n-\t}\n-\tfor n, line := range bytes.Split(m.Ret[0].([]byte), []byte{'\\n'}, -1) {\n-\t\ti := bytes.Index(line, []byte{':'})\n-\t\tif i < 0 {\n-\t\t\tcontinue\n-\t\t}\n-\t\tc.service[string(line[0:i])] = srv{uint32(n), string(line[i+1:])}\n-\t}\n-\n-\tc.out = make(chan *msg)\n-\tgo c.input()\n-\tgo c.output()\n-\treturn c, nil\n-}\n-\n-func (c *Client) input() {\n-\tfor {\n-\t\tm, err := c.r.recv()\n-\t\tif err != nil {\n-\t\t\tlog.Exitf(\"client recv: %s\", err)\n-\t\t}\n-\t\tif m.unpackResponse(); m.status != OK {\n-\t\t\tlog.Printf(\"invalid message: %s\", m.status)\n-\t\t\tcontinue\n-\t\t}\n-\t\tc.mu.Lock()\n-\t\trpc, ok := c.pending[m.requestId]\n-\t\tif ok {\n-\t\t\tc.pending[m.requestId] = nil, false\n-\t\t}\n-\t\tc.mu.Unlock()\n-\t\tif !ok {\n-\t\t\tlog.Print(\"unexpected response\")\n-\t\t\tcontinue\n-\t\t}\n-\t\trpc.Ret = m.Ret\n-\t\trpc.Done <- rpc\n-\t}\n-}\n-\n-func (c *Client) output() {\n-\tfor m := range c.out {\n-\t\tc.s.send(m)\n-\t}\n-}\n-\n-// NewRPC creates a new RPC on the client connection.\n-func (c *Client) NewRPC(done chan *RPC) *RPC {\n-\tif done == nil {\n-\t\tdone = make(chan *RPC)\n-\t}\n-\tc.mu.Lock()\n-\tid := c.idGen\n-\tc.idGen++\n-\tc.mu.Unlock()\n-\treturn &RPC{nil, done, OK, c, id}\n-}\n-\n-// Start issues an RPC request for method name with the given arguments.\n-// The RPC r must not be in use for another pending request.\n-// To wait for the RPC to finish, receive from r.Done and then\n-// inspect r.Ret and r.Errno.\n-func (r *RPC) Start(name string, arg []interface{}) {\n-\tvar m msg\n-\n-\tr.Errno = OK\n-\tr.c.mu.Lock()\n-\tsrv, ok := r.c.service[name]\n-\tif !ok {\n-\t\tr.c.mu.Unlock()\n-\t\tr.Errno = ErrBadRPCNumber\n-\t\tr.Done <- r\n-\t\treturn\n-\t}\n-\tr.c.pending[r.id] = r\n-\tr.c.mu.Unlock()\n-\n-\tm.protocol = protocol\n-\tm.requestId = r.id\n-\tm.isReq = true\n-\tm.rpcNumber = srv.num\n-\tm.Arg = arg\n-\n-\t// Fill in the return values and sizes to generate\n-\t// the right type chars.  We'll take most any size.\n-\n-\t// Skip over input arguments.\n-\t// We could check them against arg, but the server\n-\t// will do that anyway.\n-\ti := 0\n-\tfor srv.fmt[i] != ':' {\n-\t\ti++\n-\t}\n-\tfmt := srv.fmt[i+1:]\n-\n-\t// Now the return prototypes.\n-\tm.Ret = make([]interface{}, len(fmt)-i)\n-\tm.Size = make([]int, len(fmt)-i)\n-\tfor i := 0; i < len(fmt); i++ {\n-\t\tswitch fmt[i] {\n-\t\tdefault:\n-\t\t\tlog.Exitf(\"unexpected service type %c\", fmt[i])\n-\t\tcase 'b':\n-\t\t\tm.Ret[i] = false\n-\t\tcase 'C':\n-\t\t\tm.Ret[i] = []byte(nil)\n-\t\t\tm.Size[i] = 1 << 30\n-\t\tcase 'd':\n-\t\t\tm.Ret[i] = float64(0)\n-\t\tcase 'D':\n-\t\t\tm.Ret[i] = []float64(nil)\n-\t\t\tm.Size[i] = 1 << 30\n-\t\tcase 'h':\n-\t\t\tm.Ret[i] = int(-1)\n-\t\tcase 'i':\n-\t\t\tm.Ret[i] = int32(0)\n-\t\tcase 'I':\n-\t\t\tm.Ret[i] = []int32(nil)\n-\t\t\tm.Size[i] = 1 << 30\n-\t\tcase 's':\n-\t\t\tm.Ret[i] = \"\"\n-\t\t\tm.Size[i] = 1 << 30\n-\t\t}\n-\t}\n-\n-\tm.packRequest()\n-\tr.c.out <- &m\n-}\n-\n-// Call is a convenient wrapper that starts the RPC request,\n-// waits for it to finish, and then returns the results.\n-// Its implementation is:\n-//\n-//\tr.Start(name, arg)\n-//\t<-r.Done\n-//\treturn r.Ret, r.Errno\n-//\n-func (r *RPC) Call(name string, arg []interface{}) (ret []interface{}, err Errno) {\n-\tr.Start(name, arg)\n-\t<-r.Done\n-\treturn r.Ret, r.Errno\n-}"}, {"sha": "92601ed373075e9e5521aa2136ed4260a73bda46", "filename": "libgo/go/exp/nacl/srpc/msg.go", "status": "removed", "additions": 0, "deletions": 522, "changes": 522, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6ed1c8903e728f4233122554bab5910853338bd/libgo%2Fgo%2Fexp%2Fnacl%2Fsrpc%2Fmsg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6ed1c8903e728f4233122554bab5910853338bd/libgo%2Fgo%2Fexp%2Fnacl%2Fsrpc%2Fmsg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnacl%2Fsrpc%2Fmsg.go?ref=d6ed1c8903e728f4233122554bab5910853338bd", "patch": "@@ -1,522 +0,0 @@\n-// Copyright 2009 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// SRPC constants, data structures, and parsing.\n-\n-package srpc\n-\n-import (\n-\t\"math\"\n-\t\"os\"\n-\t\"strconv\"\n-\t\"syscall\"\n-\t\"unsafe\"\n-)\n-\n-// An Errno is an SRPC status code.\n-type Errno uint32\n-\n-const (\n-\tOK Errno = 256 + iota\n-\tErrBreak\n-\tErrMessageTruncated\n-\tErrNoMemory\n-\tErrProtocolMismatch\n-\tErrBadRPCNumber\n-\tErrBadArgType\n-\tErrTooFewArgs\n-\tErrTooManyArgs\n-\tErrInArgTypeMismatch\n-\tErrOutArgTypeMismatch\n-\tErrInternalError\n-\tErrAppError\n-)\n-\n-var errstr = [...]string{\n-\tOK - OK:                    \"ok\",\n-\tErrBreak - OK:              \"break\",\n-\tErrMessageTruncated - OK:   \"message truncated\",\n-\tErrNoMemory - OK:           \"out of memory\",\n-\tErrProtocolMismatch - OK:   \"protocol mismatch\",\n-\tErrBadRPCNumber - OK:       \"invalid RPC method number\",\n-\tErrBadArgType - OK:         \"unexpected argument type\",\n-\tErrTooFewArgs - OK:         \"too few arguments\",\n-\tErrTooManyArgs - OK:        \"too many arguments\",\n-\tErrInArgTypeMismatch - OK:  \"input argument type mismatch\",\n-\tErrOutArgTypeMismatch - OK: \"output argument type mismatch\",\n-\tErrInternalError - OK:      \"internal error\",\n-\tErrAppError - OK:           \"application error\",\n-}\n-\n-func (e Errno) String() string {\n-\tif e < OK || int(e-OK) >= len(errstr) {\n-\t\treturn \"Errno(\" + strconv.Itoa64(int64(e)) + \")\"\n-\t}\n-\treturn errstr[e-OK]\n-}\n-\n-// A *msgHdr is the data argument to the imc_recvmsg\n-// and imc_sendmsg system calls.  Because it contains unchecked\n-// counts trusted by the system calls, the data structure is unsafe\n-// to expose to package clients.\n-type msgHdr struct {\n-\tiov   *iov\n-\tniov  int32\n-\tdesc  *int32\n-\tndesc int32\n-\tflags uint32\n-}\n-\n-// A single region for I/O.  Just as unsafe as msgHdr.\n-type iov struct {\n-\tbase *byte\n-\tlen  int32\n-}\n-\n-// A msg is the Go representation of a message.\n-type msg struct {\n-\trdata []byte  // data being consumed during message parsing\n-\trdesc []int32 // file descriptors being consumed during message parsing\n-\twdata []byte  // data being generated when replying\n-\n-\t// parsed version of message\n-\tprotocol  uint32\n-\trequestId uint64\n-\tisReq     bool\n-\trpcNumber uint32\n-\tgotHeader bool\n-\tstatus    Errno         // error code sent in response\n-\tArg       []interface{} // method arguments\n-\tRet       []interface{} // method results\n-\tSize      []int         // max sizes for arrays in method results\n-\tfmt       string        // accumulated format string of arg+\":\"+ret\n-}\n-\n-// A msgReceiver receives messages from a file descriptor.\n-type msgReceiver struct {\n-\tfd   int\n-\tdata [128 * 1024]byte\n-\tdesc [8]int32\n-\thdr  msgHdr\n-\tiov  iov\n-}\n-\n-func (r *msgReceiver) recv() (*msg, os.Error) {\n-\t// Init pointers to buffers where syscall recvmsg can write.\n-\tr.iov.base = &r.data[0]\n-\tr.iov.len = int32(len(r.data))\n-\tr.hdr.iov = &r.iov\n-\tr.hdr.niov = 1\n-\tr.hdr.desc = &r.desc[0]\n-\tr.hdr.ndesc = int32(len(r.desc))\n-\tn, _, e := syscall.Syscall(syscall.SYS_IMC_RECVMSG, uintptr(r.fd), uintptr(unsafe.Pointer(&r.hdr)), 0)\n-\tif e != 0 {\n-\t\treturn nil, os.NewSyscallError(\"imc_recvmsg\", int(e))\n-\t}\n-\n-\t// Make a copy of the data so that the next recvmsg doesn't\n-\t// smash it.  The system call did not update r.iov.len.  Instead it\n-\t// returned the total byte count as n.\n-\tm := new(msg)\n-\tm.rdata = make([]byte, n)\n-\tcopy(m.rdata, r.data[0:])\n-\n-\t// Make a copy of the desc too.\n-\t// The system call *did* update r.hdr.ndesc.\n-\tif r.hdr.ndesc > 0 {\n-\t\tm.rdesc = make([]int32, r.hdr.ndesc)\n-\t\tcopy(m.rdesc, r.desc)\n-\t}\n-\n-\treturn m, nil\n-}\n-\n-// A msgSender sends messages on a file descriptor.\n-type msgSender struct {\n-\tfd  int\n-\thdr msgHdr\n-\tiov iov\n-}\n-\n-func (s *msgSender) send(m *msg) os.Error {\n-\tif len(m.wdata) > 0 {\n-\t\ts.iov.base = &m.wdata[0]\n-\t}\n-\ts.iov.len = int32(len(m.wdata))\n-\ts.hdr.iov = &s.iov\n-\ts.hdr.niov = 1\n-\ts.hdr.desc = nil\n-\ts.hdr.ndesc = 0\n-\t_, _, e := syscall.Syscall(syscall.SYS_IMC_SENDMSG, uintptr(s.fd), uintptr(unsafe.Pointer(&s.hdr)), 0)\n-\tif e != 0 {\n-\t\treturn os.NewSyscallError(\"imc_sendmsg\", int(e))\n-\t}\n-\treturn nil\n-}\n-\n-// Reading from msg.rdata.\n-func (m *msg) uint8() uint8 {\n-\tif m.status != OK {\n-\t\treturn 0\n-\t}\n-\tif len(m.rdata) < 1 {\n-\t\tm.status = ErrMessageTruncated\n-\t\treturn 0\n-\t}\n-\tx := m.rdata[0]\n-\tm.rdata = m.rdata[1:]\n-\treturn x\n-}\n-\n-func (m *msg) uint32() uint32 {\n-\tif m.status != OK {\n-\t\treturn 0\n-\t}\n-\tif len(m.rdata) < 4 {\n-\t\tm.status = ErrMessageTruncated\n-\t\treturn 0\n-\t}\n-\tb := m.rdata[0:4]\n-\tx := uint32(b[0]) | uint32(b[1])<<8 | uint32(b[2])<<16 | uint32(b[3])<<24\n-\tm.rdata = m.rdata[4:]\n-\treturn x\n-}\n-\n-func (m *msg) uint64() uint64 {\n-\tif m.status != OK {\n-\t\treturn 0\n-\t}\n-\tif len(m.rdata) < 8 {\n-\t\tm.status = ErrMessageTruncated\n-\t\treturn 0\n-\t}\n-\tb := m.rdata[0:8]\n-\tx := uint64(uint32(b[0]) | uint32(b[1])<<8 | uint32(b[2])<<16 | uint32(b[3])<<24)\n-\tx |= uint64(uint32(b[4])|uint32(b[5])<<8|uint32(b[6])<<16|uint32(b[7])<<24) << 32\n-\tm.rdata = m.rdata[8:]\n-\treturn x\n-}\n-\n-func (m *msg) bytes(n int) []byte {\n-\tif m.status != OK {\n-\t\treturn nil\n-\t}\n-\tif len(m.rdata) < n {\n-\t\tm.status = ErrMessageTruncated\n-\t\treturn nil\n-\t}\n-\tx := m.rdata[0:n]\n-\tm.rdata = m.rdata[n:]\n-\treturn x\n-}\n-\n-// Writing to msg.wdata.\n-func (m *msg) grow(n int) []byte {\n-\ti := len(m.wdata)\n-\tif i+n > cap(m.wdata) {\n-\t\ta := make([]byte, i, (i+n)*2)\n-\t\tcopy(a, m.wdata)\n-\t\tm.wdata = a\n-\t}\n-\tm.wdata = m.wdata[0 : i+n]\n-\treturn m.wdata[i : i+n]\n-}\n-\n-func (m *msg) wuint8(x uint8) { m.grow(1)[0] = x }\n-\n-func (m *msg) wuint32(x uint32) {\n-\tb := m.grow(4)\n-\tb[0] = byte(x)\n-\tb[1] = byte(x >> 8)\n-\tb[2] = byte(x >> 16)\n-\tb[3] = byte(x >> 24)\n-}\n-\n-func (m *msg) wuint64(x uint64) {\n-\tb := m.grow(8)\n-\tlo := uint32(x)\n-\tb[0] = byte(lo)\n-\tb[1] = byte(lo >> 8)\n-\tb[2] = byte(lo >> 16)\n-\tb[3] = byte(lo >> 24)\n-\thi := uint32(x >> 32)\n-\tb[4] = byte(hi)\n-\tb[5] = byte(hi >> 8)\n-\tb[6] = byte(hi >> 16)\n-\tb[7] = byte(hi >> 24)\n-}\n-\n-func (m *msg) wbytes(p []byte) { copy(m.grow(len(p)), p) }\n-\n-func (m *msg) wstring(s string) {\n-\tb := m.grow(len(s))\n-\tcopy(b, s)\n-}\n-\n-// Parsing of RPC header and arguments.\n-//\n-// The header format is:\n-//\tprotocol uint32;\n-//\trequestId uint64;\n-//\tisReq bool;\n-//\trpcNumber uint32;\n-//\tstatus uint32;  // only for response\n-//\n-// Then a sequence of values follow, preceded by the length:\n-//\tnvalue uint32;\n-//\n-// Each value begins with a one-byte type followed by\n-// type-specific data.\n-//\n-//\ttype uint8;\n-//\t'b':\tx bool;\n-//\t'C':\tlen uint32; x [len]byte;\n-//\t'd':\tx float64;\n-//\t'D':\tlen uint32; x [len]float64;\n-//\t'h':\tx int;\t// handle aka file descriptor\n-//\t'i':\tx int32;\n-//\t'I':\tlen uint32; x [len]int32;\n-//\t's':\tlen uint32; x [len]byte;\n-//\n-// If this is a request, a sequence of pseudo-values follows,\n-// preceded by its length (nvalue uint32).\n-//\n-// Each pseudo-value is a one-byte type as above,\n-// followed by a maximum length (len uint32)\n-// for the 'C', 'D', 'I', and 's' types.\n-//\n-// In the Go msg, we represent each argument by\n-// an empty interface containing the type of x in the\n-// corresponding case.\n-\n-// The current protocol number.\n-const protocol = 0xc0da0002\n-\n-func (m *msg) unpackHeader() {\n-\tm.protocol = m.uint32()\n-\tm.requestId = m.uint64()\n-\tm.isReq = m.uint8() != 0\n-\tm.rpcNumber = m.uint32()\n-\tm.gotHeader = m.status == OK // signal that header parsed successfully\n-\tif m.gotHeader && !m.isReq {\n-\t\tstatus := Errno(m.uint32())\n-\t\tm.gotHeader = m.status == OK // still ok?\n-\t\tif m.gotHeader {\n-\t\t\tm.status = status\n-\t\t}\n-\t}\n-}\n-\n-func (m *msg) packHeader() {\n-\tm.wuint32(m.protocol)\n-\tm.wuint64(m.requestId)\n-\tif m.isReq {\n-\t\tm.wuint8(1)\n-\t} else {\n-\t\tm.wuint8(0)\n-\t}\n-\tm.wuint32(m.rpcNumber)\n-\tif !m.isReq {\n-\t\tm.wuint32(uint32(m.status))\n-\t}\n-}\n-\n-func (m *msg) unpackValues(v []interface{}) {\n-\tfor i := range v {\n-\t\tt := m.uint8()\n-\t\tm.fmt += string(t)\n-\t\tswitch t {\n-\t\tdefault:\n-\t\t\tif m.status == OK {\n-\t\t\t\tm.status = ErrBadArgType\n-\t\t\t}\n-\t\t\treturn\n-\t\tcase 'b': // bool[1]\n-\t\t\tv[i] = m.uint8() > 0\n-\t\tcase 'C': // char array\n-\t\t\tv[i] = m.bytes(int(m.uint32()))\n-\t\tcase 'd': // double\n-\t\t\tv[i] = math.Float64frombits(m.uint64())\n-\t\tcase 'D': // double array\n-\t\t\ta := make([]float64, int(m.uint32()))\n-\t\t\tfor j := range a {\n-\t\t\t\ta[j] = math.Float64frombits(m.uint64())\n-\t\t\t}\n-\t\t\tv[i] = a\n-\t\tcase 'h': // file descriptor (handle)\n-\t\t\tif len(m.rdesc) == 0 {\n-\t\t\t\tif m.status == OK {\n-\t\t\t\t\tm.status = ErrBadArgType\n-\t\t\t\t}\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t\tv[i] = int(m.rdesc[0])\n-\t\t\tm.rdesc = m.rdesc[1:]\n-\t\tcase 'i': // int\n-\t\t\tv[i] = int32(m.uint32())\n-\t\tcase 'I': // int array\n-\t\t\ta := make([]int32, int(m.uint32()))\n-\t\t\tfor j := range a {\n-\t\t\t\ta[j] = int32(m.uint32())\n-\t\t\t}\n-\t\t\tv[i] = a\n-\t\tcase 's': // string\n-\t\t\tv[i] = string(m.bytes(int(m.uint32())))\n-\t\t}\n-\t}\n-}\n-\n-func (m *msg) packValues(v []interface{}) {\n-\tfor i := range v {\n-\t\tswitch x := v[i].(type) {\n-\t\tdefault:\n-\t\t\tif m.status == OK {\n-\t\t\t\tm.status = ErrInternalError\n-\t\t\t}\n-\t\t\treturn\n-\t\tcase bool:\n-\t\t\tm.wuint8('b')\n-\t\t\tif x {\n-\t\t\t\tm.wuint8(1)\n-\t\t\t} else {\n-\t\t\t\tm.wuint8(0)\n-\t\t\t}\n-\t\tcase []byte:\n-\t\t\tm.wuint8('C')\n-\t\t\tm.wuint32(uint32(len(x)))\n-\t\t\tm.wbytes(x)\n-\t\tcase float64:\n-\t\t\tm.wuint8('d')\n-\t\t\tm.wuint64(math.Float64bits(x))\n-\t\tcase []float64:\n-\t\t\tm.wuint8('D')\n-\t\t\tm.wuint32(uint32(len(x)))\n-\t\t\tfor _, f := range x {\n-\t\t\t\tm.wuint64(math.Float64bits(f))\n-\t\t\t}\n-\t\tcase int32:\n-\t\t\tm.wuint8('i')\n-\t\t\tm.wuint32(uint32(x))\n-\t\tcase []int32:\n-\t\t\tm.wuint8('I')\n-\t\t\tm.wuint32(uint32(len(x)))\n-\t\t\tfor _, i := range x {\n-\t\t\t\tm.wuint32(uint32(i))\n-\t\t\t}\n-\t\tcase string:\n-\t\t\tm.wuint8('s')\n-\t\t\tm.wuint32(uint32(len(x)))\n-\t\t\tm.wstring(x)\n-\t\t}\n-\t}\n-}\n-\n-func (m *msg) unpackRequest() {\n-\tm.status = OK\n-\tif m.unpackHeader(); m.status != OK {\n-\t\treturn\n-\t}\n-\tif m.protocol != protocol || !m.isReq {\n-\t\tm.status = ErrProtocolMismatch\n-\t\treturn\n-\t}\n-\n-\t// type-tagged argument values\n-\tm.Arg = make([]interface{}, m.uint32())\n-\tm.unpackValues(m.Arg)\n-\tif m.status != OK {\n-\t\treturn\n-\t}\n-\n-\t// type-tagged expected return sizes.\n-\t// fill in zero values for each return value\n-\t// and save sizes.\n-\tm.fmt += \":\"\n-\tm.Ret = make([]interface{}, m.uint32())\n-\tm.Size = make([]int, len(m.Ret))\n-\tfor i := range m.Ret {\n-\t\tt := m.uint8()\n-\t\tm.fmt += string(t)\n-\t\tswitch t {\n-\t\tdefault:\n-\t\t\tif m.status == OK {\n-\t\t\t\tm.status = ErrBadArgType\n-\t\t\t}\n-\t\t\treturn\n-\t\tcase 'b': // bool[1]\n-\t\t\tm.Ret[i] = false\n-\t\tcase 'C': // char array\n-\t\t\tm.Size[i] = int(m.uint32())\n-\t\t\tm.Ret[i] = []byte(nil)\n-\t\tcase 'd': // double\n-\t\t\tm.Ret[i] = float64(0)\n-\t\tcase 'D': // double array\n-\t\t\tm.Size[i] = int(m.uint32())\n-\t\t\tm.Ret[i] = []float64(nil)\n-\t\tcase 'h': // file descriptor (handle)\n-\t\t\tm.Ret[i] = int(-1)\n-\t\tcase 'i': // int\n-\t\t\tm.Ret[i] = int32(0)\n-\t\tcase 'I': // int array\n-\t\t\tm.Size[i] = int(m.uint32())\n-\t\t\tm.Ret[i] = []int32(nil)\n-\t\tcase 's': // string\n-\t\t\tm.Size[i] = int(m.uint32())\n-\t\t\tm.Ret[i] = \"\"\n-\t\t}\n-\t}\n-}\n-\n-func (m *msg) packRequest() {\n-\tm.packHeader()\n-\tm.wuint32(uint32(len(m.Arg)))\n-\tm.packValues(m.Arg)\n-\tm.wuint32(uint32(len(m.Ret)))\n-\tfor i, v := range m.Ret {\n-\t\tswitch x := v.(type) {\n-\t\tcase bool:\n-\t\t\tm.wuint8('b')\n-\t\tcase []byte:\n-\t\t\tm.wuint8('C')\n-\t\t\tm.wuint32(uint32(m.Size[i]))\n-\t\tcase float64:\n-\t\t\tm.wuint8('d')\n-\t\tcase []float64:\n-\t\t\tm.wuint8('D')\n-\t\t\tm.wuint32(uint32(m.Size[i]))\n-\t\tcase int:\n-\t\t\tm.wuint8('h')\n-\t\tcase int32:\n-\t\t\tm.wuint8('i')\n-\t\tcase []int32:\n-\t\t\tm.wuint8('I')\n-\t\t\tm.wuint32(uint32(m.Size[i]))\n-\t\tcase string:\n-\t\t\tm.wuint8('s')\n-\t\t\tm.wuint32(uint32(m.Size[i]))\n-\t\t}\n-\t}\n-}\n-\n-func (m *msg) unpackResponse() {\n-\tm.status = OK\n-\tif m.unpackHeader(); m.status != OK {\n-\t\treturn\n-\t}\n-\tif m.protocol != protocol || m.isReq {\n-\t\tm.status = ErrProtocolMismatch\n-\t\treturn\n-\t}\n-\n-\t// type-tagged return values\n-\tm.fmt = \"\"\n-\tm.Ret = make([]interface{}, m.uint32())\n-\tm.unpackValues(m.Ret)\n-}\n-\n-func (m *msg) packResponse() {\n-\tm.packHeader()\n-\tm.wuint32(uint32(len(m.Ret)))\n-\tm.packValues(m.Ret)\n-}"}, {"sha": "5d65ca1fabbfa9927231772cd4e263c5342eb974", "filename": "libgo/go/exp/nacl/srpc/server.go", "status": "removed", "additions": 0, "deletions": 192, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6ed1c8903e728f4233122554bab5910853338bd/libgo%2Fgo%2Fexp%2Fnacl%2Fsrpc%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6ed1c8903e728f4233122554bab5910853338bd/libgo%2Fgo%2Fexp%2Fnacl%2Fsrpc%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnacl%2Fsrpc%2Fserver.go?ref=d6ed1c8903e728f4233122554bab5910853338bd", "patch": "@@ -1,192 +0,0 @@\n-// Copyright 2009 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// SRPC server\n-\n-package srpc\n-\n-import (\n-\t\"bytes\"\n-\t\"log\"\n-\t\"os\"\n-\t\"syscall\"\n-)\n-\n-// TODO(rsc): I'd prefer to make this\n-//\ttype Handler func(m *msg) Errno\n-// but NaCl can't use closures.\n-// The explicit interface is a way to attach state.\n-\n-// A Handler is a handler for an SRPC method.\n-// It reads arguments from arg, checks size for array limits,\n-// writes return values to ret, and returns an Errno status code.\n-type Handler interface {\n-\tRun(arg, ret []interface{}, size []int) Errno\n-}\n-\n-type method struct {\n-\tname    string\n-\tfmt     string\n-\thandler Handler\n-}\n-\n-var rpcMethod []method\n-\n-// BUG(rsc): Add's format string should be replaced by analyzing the\n-// type of an arbitrary func passed in an interface{} using reflection.\n-\n-// Add registers a handler for the named method.\n-// Fmt is a Native Client format string, a sequence of\n-// alphabetic characters representing the types of the parameter values,\n-// a colon, and then a sequence of alphabetic characters\n-// representing the types of the returned values.\n-// The format characters and corresponding dynamic types are:\n-//\n-//\tb\tbool\n-//\tC\t[]byte\n-//\td\tfloat64\n-//\tD\t[]float64\n-//\th\tint\t// a file descriptor (aka handle)\n-//\ti\tint32\n-//\tI\t[]int32\n-//\ts\tstring\n-//\n-func Add(name, fmt string, handler Handler) {\n-\trpcMethod = append(rpcMethod, method{name, fmt, handler})\n-}\n-\n-// Serve accepts new SRPC connections from the file descriptor fd\n-// and answers RPCs issued on those connections.\n-// It closes fd and returns an error if the imc_accept system call fails.\n-func Serve(fd int) os.Error {\n-\tdefer syscall.Close(fd)\n-\n-\tfor {\n-\t\tcfd, _, e := syscall.Syscall(syscall.SYS_IMC_ACCEPT, uintptr(fd), 0, 0)\n-\t\tif e != 0 {\n-\t\t\treturn os.NewSyscallError(\"imc_accept\", int(e))\n-\t\t}\n-\t\tgo serveLoop(int(cfd))\n-\t}\n-\tpanic(\"unreachable\")\n-}\n-\n-func serveLoop(fd int) {\n-\tc := make(chan *msg)\n-\tgo sendLoop(fd, c)\n-\n-\tvar r msgReceiver\n-\tr.fd = fd\n-\tfor {\n-\t\tm, err := r.recv()\n-\t\tif err != nil {\n-\t\t\tbreak\n-\t\t}\n-\t\tm.unpackRequest()\n-\t\tif !m.gotHeader {\n-\t\t\tlog.Printf(\"cannot unpack header: %s\", m.status)\n-\t\t\tcontinue\n-\t\t}\n-\t\t// log.Printf(\"<- %#v\", m);\n-\t\tm.isReq = false // set up for response\n-\t\tgo serveMsg(m, c)\n-\t}\n-\tclose(c)\n-}\n-\n-func sendLoop(fd int, c <-chan *msg) {\n-\tvar s msgSender\n-\ts.fd = fd\n-\tfor m := range c {\n-\t\t// log.Printf(\"-> %#v\", m);\n-\t\tm.packResponse()\n-\t\ts.send(m)\n-\t}\n-\tsyscall.Close(fd)\n-}\n-\n-func serveMsg(m *msg, c chan<- *msg) {\n-\tif m.status != OK {\n-\t\tc <- m\n-\t\treturn\n-\t}\n-\tif m.rpcNumber >= uint32(len(rpcMethod)) {\n-\t\tm.status = ErrBadRPCNumber\n-\t\tc <- m\n-\t\treturn\n-\t}\n-\n-\tmeth := &rpcMethod[m.rpcNumber]\n-\tif meth.fmt != m.fmt {\n-\t\tswitch {\n-\t\tcase len(m.fmt) < len(meth.fmt):\n-\t\t\tm.status = ErrTooFewArgs\n-\t\tcase len(m.fmt) > len(meth.fmt):\n-\t\t\tm.status = ErrTooManyArgs\n-\t\tdefault:\n-\t\t\t// There's a type mismatch.\n-\t\t\t// It's an in-arg mismatch if the mismatch happens\n-\t\t\t// before the colon; otherwise it's an out-arg mismatch.\n-\t\t\tm.status = ErrInArgTypeMismatch\n-\t\t\tfor i := 0; i < len(m.fmt) && m.fmt[i] == meth.fmt[i]; i++ {\n-\t\t\t\tif m.fmt[i] == ':' {\n-\t\t\t\t\tm.status = ErrOutArgTypeMismatch\n-\t\t\t\t\tbreak\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\tc <- m\n-\t\treturn\n-\t}\n-\n-\tm.status = meth.handler.Run(m.Arg, m.Ret, m.Size)\n-\tc <- m\n-}\n-\n-// ServeRuntime serves RPCs issued by the Native Client embedded runtime.\n-// This should be called by main once all methods have been registered using Add.\n-func ServeRuntime() os.Error {\n-\t// Call getFd to check that we are running embedded.\n-\tif _, err := getFd(); err != nil {\n-\t\treturn err\n-\t}\n-\n-\t// We are running embedded.\n-\t// The fd returned by getFd is a red herring.\n-\t// Accept connections on magic fd 3.\n-\treturn Serve(3)\n-}\n-\n-// getFd runs the srpc_get_fd system call.\n-func getFd() (fd int, err os.Error) {\n-\tr1, _, e := syscall.Syscall(syscall.SYS_SRPC_GET_FD, 0, 0, 0)\n-\treturn int(r1), os.NewSyscallError(\"srpc_get_fd\", int(e))\n-}\n-\n-// Enabled returns true if SRPC is enabled in the Native Client runtime.\n-func Enabled() bool {\n-\t_, err := getFd()\n-\treturn err == nil\n-}\n-\n-// Service #0, service_discovery, returns a list of the other services\n-// and their argument formats.\n-type serviceDiscovery struct{}\n-\n-func (serviceDiscovery) Run(arg, ret []interface{}, size []int) Errno {\n-\tvar b bytes.Buffer\n-\tfor _, m := range rpcMethod {\n-\t\tb.WriteString(m.name)\n-\t\tb.WriteByte(':')\n-\t\tb.WriteString(m.fmt)\n-\t\tb.WriteByte('\\n')\n-\t}\n-\tif b.Len() > size[0] {\n-\t\treturn ErrNoMemory\n-\t}\n-\tret[0] = b.Bytes()\n-\treturn OK\n-}\n-\n-func init() { Add(\"service_discovery\", \":C\", serviceDiscovery{}) }"}, {"sha": "4f67032d0c3085a029149d06037c4e33543f1f36", "filename": "libgo/go/exp/ogle/cmd.go", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fexp%2Fogle%2Fcmd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fexp%2Fogle%2Fcmd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fogle%2Fcmd.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -18,6 +18,7 @@ import (\n \t\"strings\"\n )\n \n+var fset = token.NewFileSet()\n var world *eval.World\n var curProc *Process\n \n@@ -43,7 +44,7 @@ func Main() {\n \t\t}\n \n \t\t// Try line as code\n-\t\tcode, err := world.Compile(string(line))\n+\t\tcode, err := world.Compile(fset, string(line))\n \t\tif err != nil {\n \t\t\tscanner.PrintError(os.Stderr, err)\n \t\t\tcontinue\n@@ -63,8 +64,8 @@ func Main() {\n func newScanner(input []byte) (*scanner.Scanner, *scanner.ErrorVector) {\n \tsc := new(scanner.Scanner)\n \tev := new(scanner.ErrorVector)\n-\tsc.Init(\"input\", input, ev, 0)\n-\n+\tfile := fset.AddFile(\"input\", fset.Base(), len(input))\n+\tsc.Init(file, input, ev, 0)\n \treturn sc, ev\n }\n \n@@ -101,7 +102,7 @@ func getCmd(line []byte) (*cmd, []byte) {\n \tslit := string(lit)\n \tfor i := range cmds {\n \t\tif cmds[i].cmd == slit {\n-\t\t\treturn &cmds[i], line[pos.Offset+len(lit):]\n+\t\t\treturn &cmds[i], line[fset.Position(pos).Offset+len(lit):]\n \t\t}\n \t}\n \treturn nil, nil"}, {"sha": "b3c35575af4c96e88f6439066127705222b192d3", "filename": "libgo/go/exp/ogle/rtype.go", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fexp%2Fogle%2Frtype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fexp%2Fogle%2Frtype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fogle%2Frtype.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332", "patch": "@@ -209,9 +209,6 @@ func parseRemoteType(a aborter, rs remoteStruct) *remoteType {\n \tcase p.runtime.PFloat64Type:\n \t\tt = eval.Float64Type\n \t\tmk = mkFloat64\n-\tcase p.runtime.PFloatType:\n-\t\tt = eval.FloatType\n-\t\tmk = mkFloat\n \tcase p.runtime.PStringType:\n \t\tt = eval.StringType\n \t\tmk = mkString"}, {"sha": "6391b500a8249e9d1d65173ec5144239d131b434", "filename": "libgo/go/exp/spacewar/code.go", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6ed1c8903e728f4233122554bab5910853338bd/libgo%2Fgo%2Fexp%2Fspacewar%2Fcode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6ed1c8903e728f4233122554bab5910853338bd/libgo%2Fgo%2Fexp%2Fspacewar%2Fcode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fspacewar%2Fcode.go?ref=d6ed1c8903e728f4233122554bab5910853338bd"}, {"sha": "e3abd6807fde07c73a9762017b18051ef067827e", "filename": "libgo/go/exp/spacewar/pdp1.go", "status": "removed", "additions": 0, "deletions": 389, "changes": 389, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6ed1c8903e728f4233122554bab5910853338bd/libgo%2Fgo%2Fexp%2Fspacewar%2Fpdp1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6ed1c8903e728f4233122554bab5910853338bd/libgo%2Fgo%2Fexp%2Fspacewar%2Fpdp1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fspacewar%2Fpdp1.go?ref=d6ed1c8903e728f4233122554bab5910853338bd"}, {"sha": "4eb6249d38b6abae2580381c8b39947f5b1960e9", "filename": "libgo/go/exp/spacewar/spacewar.go", "status": "removed", "additions": 0, "deletions": 202, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6ed1c8903e728f4233122554bab5910853338bd/libgo%2Fgo%2Fexp%2Fspacewar%2Fspacewar.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6ed1c8903e728f4233122554bab5910853338bd/libgo%2Fgo%2Fexp%2Fspacewar%2Fspacewar.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fspacewar%2Fspacewar.go?ref=d6ed1c8903e728f4233122554bab5910853338bd"}, {"sha": "b1f0f6c1b81edd332acc24ae2dad371fe8fe610d", "filename": "libgo/go/expvar/expvar.go", "status": "modified", "additions": 53, "deletions": 3, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fexpvar%2Fexpvar.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fexpvar%2Fexpvar.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexpvar%2Fexpvar.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "a8b1a96a93cceed49379d900d99f0ce382e57b3d", "filename": "libgo/go/expvar/expvar_test.go", "status": "modified", "additions": 57, "deletions": 2, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fexpvar%2Fexpvar_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fexpvar%2Fexpvar_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexpvar%2Fexpvar_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "b5e3243b310e6f7aa7e0f8430bdc042ebe4509f5", "filename": "libgo/go/flag/export_test.go", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fflag%2Fexport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fflag%2Fexport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fflag%2Fexport_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "143a106115021d7f5d313110a3f19b3c4311d3b7", "filename": "libgo/go/flag/flag.go", "status": "modified", "additions": 46, "deletions": 98, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fflag%2Fflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fflag%2Fflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fflag%2Fflag.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "b91a8b567956e7f762f9c1c140a2468ebc268054", "filename": "libgo/go/flag/flag_test.go", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fflag%2Fflag_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fflag%2Fflag_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fflag%2Fflag_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "191bf68b13ba1ee17004ca5e43eff93b74a12987", "filename": "libgo/go/fmt/doc.go", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Ffmt%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Ffmt%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fdoc.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "3f085b72245d118ae54b7a142f22ee228c48ca57", "filename": "libgo/go/fmt/fmt_test.go", "status": "modified", "additions": 65, "deletions": 67, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Ffmt_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "86057bf693cda2d49cd8ce44fd41407ac357045a", "filename": "libgo/go/fmt/format.go", "status": "modified", "additions": 11, "deletions": 33, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Ffmt%2Fformat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Ffmt%2Fformat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fformat.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "96029a8789f12c8a405030e47748e46abc4bc3ce", "filename": "libgo/go/fmt/print.go", "status": "modified", "additions": 43, "deletions": 35, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Ffmt%2Fprint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Ffmt%2Fprint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fprint.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "ebbb17155e4a9de0f323373a08f53ba5f7e6a838", "filename": "libgo/go/fmt/scan.go", "status": "modified", "additions": 37, "deletions": 17, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Ffmt%2Fscan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Ffmt%2Fscan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fscan.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "78b9fbb4ab06275fa26ecc6ac4d26ef678a645bf", "filename": "libgo/go/fmt/scan_test.go", "status": "modified", "additions": 70, "deletions": 16, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Ffmt%2Fscan_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Ffmt%2Fscan_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fscan_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "0ca3f522d622aa7d6b2af6a97f253fa3eca869b5", "filename": "libgo/go/fmt/stringer_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Ffmt%2Fstringer_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Ffmt%2Fstringer_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fstringer_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "cf2ce36df88e64a5820f7d9c7d568dab9db9eaac", "filename": "libgo/go/go/ast/ast.go", "status": "modified", "additions": 353, "deletions": 176, "changes": 529, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgo%2Fast%2Fast.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgo%2Fast%2Fast.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fast.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "0c3cef4b27b15c976c8642c409d7a694f7d53c68", "filename": "libgo/go/go/ast/filter.go", "status": "modified", "additions": 6, "deletions": 27, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgo%2Fast%2Ffilter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgo%2Fast%2Ffilter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Ffilter.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "875a92f3f49b49cf2307baccfffaaa14fc298a49", "filename": "libgo/go/go/ast/walk.go", "status": "modified", "additions": 177, "deletions": 123, "changes": 300, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgo%2Fast%2Fwalk.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgo%2Fast%2Fwalk.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fwalk.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "e46857cb8a16103be0c939bd5eac77af5e8047e1", "filename": "libgo/go/go/doc/doc.go", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "84d699a67935910de4159c7f0b0ffc2be92ecade", "filename": "libgo/go/go/parser/interface.go", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgo%2Fparser%2Finterface.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgo%2Fparser%2Finterface.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Finterface.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "f1746e04055060dad812c2cc839e433b5791178e", "filename": "libgo/go/go/parser/parser.go", "status": "modified", "additions": 85, "deletions": 70, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "56bd80ef1fc635bd1a1696f37057e9b6a26f2c8c", "filename": "libgo/go/go/parser/parser_test.go", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgo%2Fparser%2Fparser_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgo%2Fparser%2Fparser_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fparser_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "8207996dcdc9680c2a8fd7f3fa9028ab6adbd5ca", "filename": "libgo/go/go/printer/nodes.go", "status": "modified", "additions": 66, "deletions": 54, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "34b0c4e2dc4c764e723d66f083aa09b322d9979f", "filename": "libgo/go/go/printer/printer.go", "status": "modified", "additions": 48, "deletions": 25, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "c66471b926a6f83f522319a64aa4e411c7e1c512", "filename": "libgo/go/go/printer/printer_test.go", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "a86d6617432b1a2b41bf3bcbaf78b2860030ceff", "filename": "libgo/go/go/printer/testdata/comments.golden", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments.golden?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "14cd4cf7a12e01eb20ccc4c656ff28fefcb0ae33", "filename": "libgo/go/go/printer/testdata/comments.input", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments.input?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "1c091b9295e368baa5e1cdd0b0be44d247749f3c", "filename": "libgo/go/go/printer/testdata/declarations.golden", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.golden?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "c826462f9dce05b88351552993868f8913d822c8", "filename": "libgo/go/go/printer/testdata/declarations.input", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.input?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "8c3205230e84afdf0f6a135250310a1f98ec4a3d", "filename": "libgo/go/go/scanner/scanner.go", "status": "modified", "additions": 80, "deletions": 85, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "1c3b6728c275e620a23945b8a12234f6cfcf63ef", "filename": "libgo/go/go/scanner/scanner_test.go", "status": "modified", "additions": 92, "deletions": 67, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "0044a0ed77d53541f97e35686dbf07802698a364", "filename": "libgo/go/go/token/position.go", "status": "added", "additions": 409, "deletions": 0, "changes": 409, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgo%2Ftoken%2Fposition.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgo%2Ftoken%2Fposition.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftoken%2Fposition.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "1cffcc3c27857f1928534c45d424967fa72710ab", "filename": "libgo/go/go/token/position_test.go", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgo%2Ftoken%2Fposition_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgo%2Ftoken%2Fposition_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftoken%2Fposition_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "1bd81c1b14336938d393f911a45f0aafd30f252b", "filename": "libgo/go/go/token/token.go", "status": "modified", "additions": 1, "deletions": 40, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgo%2Ftoken%2Ftoken.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgo%2Ftoken%2Ftoken.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftoken%2Ftoken.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "114c93ea86ef65ff2e981c4f4dfae2ee2566e8fa", "filename": "libgo/go/go/typechecker/scope.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgo%2Ftypechecker%2Fscope.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgo%2Ftypechecker%2Fscope.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypechecker%2Fscope.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "e9aefa2402b0cc062268cf7c1eb4737706a30fc9", "filename": "libgo/go/go/typechecker/typechecker.go", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftypechecker.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftypechecker.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftypechecker.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "33f4a6223ff41a62dc8d8618fb042590bc2ece94", "filename": "libgo/go/go/typechecker/typechecker_test.go", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftypechecker_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftypechecker_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftypechecker_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "af941c629cd9f4da31fb4d659df6229124900c1c", "filename": "libgo/go/gob/codec_test.go", "status": "modified", "additions": 271, "deletions": 279, "changes": 550, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgob%2Fcodec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgob%2Fcodec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Fcodec_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "2db75215c197881d8d6a9b3044b4dc708139e63a", "filename": "libgo/go/gob/decode.go", "status": "modified", "additions": 88, "deletions": 81, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgob%2Fdecode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgob%2Fdecode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Fdecode.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "664001a4b21e0bf7ba4ada7e9390a955e1d26b2d", "filename": "libgo/go/gob/decoder.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgob%2Fdecoder.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgob%2Fdecoder.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Fdecoder.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "31253f16d096d4fedbedd79b0b9ec8fa12cc8880", "filename": "libgo/go/gob/doc.go", "status": "modified", "additions": 33, "deletions": 25, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgob%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgob%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Fdoc.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "d286a7e00b879b9666881cf0cab0f54e9cb9424d", "filename": "libgo/go/gob/encode.go", "status": "modified", "additions": 39, "deletions": 55, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgob%2Fencode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgob%2Fencode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Fencode.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "8869b262982d835569defb09b8a4cb47d2c83dfa", "filename": "libgo/go/gob/encoder.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgob%2Fencoder.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgob%2Fencoder.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Fencoder.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "c2309352a09d0f7a43f84a24878143e102e8eeac", "filename": "libgo/go/gob/encoder_test.go", "status": "modified", "additions": 64, "deletions": 35, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgob%2Fencoder_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgob%2Fencoder_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Fencoder_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "22502a6e6b9094cadf11144c460a2ed095086ffd", "filename": "libgo/go/gob/type.go", "status": "modified", "additions": 70, "deletions": 59, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgob%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgob%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Ftype.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "5aecde103a5c23c963530470a37f7a739a184987", "filename": "libgo/go/gob/type_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgob%2Ftype_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fgob%2Ftype_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Ftype_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "8443865645e8b705e08b65c980489ad09e061c53", "filename": "libgo/go/hash/crc64/crc64.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fhash%2Fcrc64%2Fcrc64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fhash%2Fcrc64%2Fcrc64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhash%2Fcrc64%2Fcrc64.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "c5338d0781dbf76cdc32948f50f9df0b9a7a276a", "filename": "libgo/go/html/doc.go", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fhtml%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fhtml%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Fdoc.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "1530290cb38b1a0c98541d8de1c5172a90f59711", "filename": "libgo/go/html/entity.go", "status": "modified", "additions": 2234, "deletions": 22, "changes": 2256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fhtml%2Fentity.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fhtml%2Fentity.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Fentity.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "a1eb4d4f01326004fb18e60d34b032053908a0a1", "filename": "libgo/go/html/entity_test.go", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fhtml%2Fentity_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fhtml%2Fentity_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Fentity_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "2799f69087678b7f87f82cbb12a3976800109b8a", "filename": "libgo/go/html/escape.go", "status": "modified", "additions": 114, "deletions": 7, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fhtml%2Fescape.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fhtml%2Fescape.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Fescape.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "2ef90a873216cfe6f4e1e11c91d70937bb7ef242", "filename": "libgo/go/html/parse.go", "status": "added", "additions": 666, "deletions": 0, "changes": 666, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fhtml%2Fparse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fhtml%2Fparse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Fparse.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "d153533b588b45c7882ead30bc38da7876d982b1", "filename": "libgo/go/html/parse_test.go", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fhtml%2Fparse_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fhtml%2Fparse_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Fparse_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "d6388385051b3df9a0cfc5e16aaf64ee22425a21", "filename": "libgo/go/html/token.go", "status": "modified", "additions": 44, "deletions": 43, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fhtml%2Ftoken.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fhtml%2Ftoken.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftoken.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "e07999ca5addd5df5d6264722053a8e6ce8889ef", "filename": "libgo/go/html/token_test.go", "status": "modified", "additions": 74, "deletions": 5, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fhtml%2Ftoken_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fhtml%2Ftoken_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftoken_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "022f4f124a86ed9e3ff4013631590e5909735e2c", "filename": "libgo/go/http/client.go", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fhttp%2Fclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fhttp%2Fclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fclient.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "bbfa58d264d77c10ec132a7633a1af649b7980fe", "filename": "libgo/go/http/fs.go", "status": "modified", "additions": 94, "deletions": 5, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fhttp%2Ffs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fhttp%2Ffs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Ffs.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "0a5636b88d1ac4d8205bb04805b3bd338835613e", "filename": "libgo/go/http/fs_test.go", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fhttp%2Ffs_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fhttp%2Ffs_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Ffs_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "5e1cbcbcbdcb6b4a6f39608ecac37531a93adb97", "filename": "libgo/go/http/readrequest_test.go", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fhttp%2Freadrequest_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fhttp%2Freadrequest_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Freadrequest_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "04bebaaf55bc0df244776de2d793b286ccd9cb62", "filename": "libgo/go/http/request.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fhttp%2Frequest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fhttp%2Frequest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Frequest.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "a24726110c8e8508fb4a82b7138bc45fce391243", "filename": "libgo/go/http/response.go", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fhttp%2Fresponse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fhttp%2Fresponse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fresponse.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "89a8c3b44d2481886b3fd42d8b526e57d6bb4320", "filename": "libgo/go/http/response_test.go", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fhttp%2Fresponse_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fhttp%2Fresponse_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fresponse_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "053d6dca448ec9697400938d56901d643b7bfef5", "filename": "libgo/go/http/serve_test.go", "status": "added", "additions": 220, "deletions": 0, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fhttp%2Fserve_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fhttp%2Fserve_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fserve_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "644724f58e6cc2d3388c4db86c704ea2725d2c8a", "filename": "libgo/go/http/server.go", "status": "modified", "additions": 59, "deletions": 47, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fhttp%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fhttp%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fserver.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "11f11f9be3babdba706660bfc54cb4e8990c3a16", "filename": "libgo/go/http/testdata/file", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fhttp%2Ftestdata%2Ffile", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fhttp%2Ftestdata%2Ffile", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Ftestdata%2Ffile?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "e62885d62fd5a94e05633e631d30d29908c01a62", "filename": "libgo/go/http/transfer.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fhttp%2Ftransfer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fhttp%2Ftransfer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Ftransfer.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "efd90d81eb187f101062000f38fe02f0c54b85af", "filename": "libgo/go/http/url.go", "status": "modified", "additions": 136, "deletions": 58, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fhttp%2Furl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fhttp%2Furl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Furl.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "0801f7ff3e82ab55d593c1cfb8e05f9a8f32e1cf", "filename": "libgo/go/http/url_test.go", "status": "modified", "additions": 210, "deletions": 44, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fhttp%2Furl_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fhttp%2Furl_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Furl_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "0e6894a8b5733c09dcb1ec5401c4eb4e05e08df4", "filename": "libgo/go/index/suffixarray/qsufsort.go", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Findex%2Fsuffixarray%2Fqsufsort.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Findex%2Fsuffixarray%2Fqsufsort.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Findex%2Fsuffixarray%2Fqsufsort.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "628e000e1d35a5a3601f09ad0db7c2ae4b71b0e0", "filename": "libgo/go/index/suffixarray/suffixarray.go", "status": "modified", "additions": 119, "deletions": 48, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Findex%2Fsuffixarray%2Fsuffixarray.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Findex%2Fsuffixarray%2Fsuffixarray.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Findex%2Fsuffixarray%2Fsuffixarray.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "b3486a96d08a9fabf3722ab770610159c697c498", "filename": "libgo/go/index/suffixarray/suffixarray_test.go", "status": "modified", "additions": 112, "deletions": 39, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Findex%2Fsuffixarray%2Fsuffixarray_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Findex%2Fsuffixarray%2Fsuffixarray_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Findex%2Fsuffixarray%2Fsuffixarray_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "1a6eca95a0d9ab9536a842c67aa5c1ca9220d130", "filename": "libgo/go/io/io.go", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fio%2Fio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fio%2Fio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fio.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "4fcd85e693e9f4fe8514c8398494c7dc1bf0e5ae", "filename": "libgo/go/io/io_test.go", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fio%2Fio_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fio%2Fio_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fio_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "ff91dd83c3360cb2f4acdb699c4965a713eae1bb", "filename": "libgo/go/json/decode.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fjson%2Fdecode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fjson%2Fdecode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fjson%2Fdecode.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "9cb27af412af2ab59ecdc50510ad3a76e1c43101", "filename": "libgo/go/json/decode_test.go", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fjson%2Fdecode_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fjson%2Fdecode_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fjson%2Fdecode_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "759b49dbeb4e02e033b41de1ef47f339f1f6c25a", "filename": "libgo/go/json/encode.go", "status": "modified", "additions": 47, "deletions": 13, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fjson%2Fencode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fjson%2Fencode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fjson%2Fencode.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "2dc8ff87fb42a522d631f346163403b18797df69", "filename": "libgo/go/json/scanner_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fjson%2Fscanner_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fjson%2Fscanner_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fjson%2Fscanner_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "cb9b16559ed2bb8d2760cf5250a03829fa291fa5", "filename": "libgo/go/json/stream.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fjson%2Fstream.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fjson%2Fstream.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fjson%2Fstream.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "6ddaed9fe8f2bf11de018acda8739a6d63cd0bec", "filename": "libgo/go/json/stream_test.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fjson%2Fstream_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fjson%2Fstream_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fjson%2Fstream_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "d34af9e5e4548406a32b5eb3f6f14df95535253f", "filename": "libgo/go/log/log.go", "status": "modified", "additions": 51, "deletions": 5, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Flog%2Flog.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Flog%2Flog.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Flog%2Flog.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "d2a7d411ec010d8bc511715a481fc7de5756f544", "filename": "libgo/go/math/all_test.go", "status": "modified", "additions": 152, "deletions": 7, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fmath%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fmath%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fall_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "a1dca3ed695a10689f462c76b3ce56c0d7d04903", "filename": "libgo/go/math/bits.go", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fmath%2Fbits.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fmath%2Fbits.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbits.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "b53527a4f397c90374c1d5982f6acb5af9cb90b6", "filename": "libgo/go/math/const.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fmath%2Fconst.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fmath%2Fconst.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fconst.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "c519c2cb6b6bf55bbc15a55411586ba29dfa5fe3", "filename": "libgo/go/math/exp.go", "status": "modified", "additions": 1, "deletions": 128, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fmath%2Fexp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fmath%2Fexp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fexp.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "1cface9d360ad93730e5c7e825eea15534ffd356", "filename": "libgo/go/math/exp2.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fmath%2Fexp2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fmath%2Fexp2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fexp2.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "071420c24c57052ca0b72c3aba3548585f026ae1", "filename": "libgo/go/math/exp_port.go", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fmath%2Fexp_port.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fmath%2Fexp_port.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fexp_port.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "7381fd5ad34a265291566c02cac32dcd843bd0cc", "filename": "libgo/go/math/exp_test.go", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fmath%2Fexp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fmath%2Fexp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fexp_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "867b78f36489436dd77dd9beabf96f2cdb8bce52", "filename": "libgo/go/math/frexp.go", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fmath%2Ffrexp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fmath%2Ffrexp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Ffrexp.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "73ca0e53addc44fc1b0445c08c41b3e678c5f5e6", "filename": "libgo/go/math/gamma.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fmath%2Fgamma.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fmath%2Fgamma.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fgamma.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "9024af3c223e59f910962dc4c34b8fd4012df9ca", "filename": "libgo/go/math/jn.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fmath%2Fjn.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fmath%2Fjn.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fjn.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "96c95cad4ae11fc2ff3c573aa9730bc9992a276b", "filename": "libgo/go/math/ldexp.go", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fmath%2Fldexp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fmath%2Fldexp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fldexp.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "dc30f468f4bb928ff0e478f42086f93e1a6b79d9", "filename": "libgo/go/math/lgamma.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fmath%2Flgamma.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fmath%2Flgamma.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Flgamma.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "072281ddf9f852de98fbe8793575e4cefd759524", "filename": "libgo/go/math/logb.go", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fmath%2Flogb.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fmath%2Flogb.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Flogb.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "315174b70144ab31494dbf6c8e585835b11722b9", "filename": "libgo/go/math/modf.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fmath%2Fmodf.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fmath%2Fmodf.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fmodf.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "06b107401b99c56075a56e2be58647092907c06d", "filename": "libgo/go/math/pow.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fmath%2Fpow.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fmath%2Fpow.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fpow.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "6f35a383d11f98db3e42073236cd48359e29fe6a", "filename": "libgo/go/math/sqrt_port.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fmath%2Fsqrt_port.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fmath%2Fsqrt_port.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fsqrt_port.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "03b9d87be33d58e36096949978e21dc47355571a", "filename": "libgo/go/net/dial.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fnet%2Fdial.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fnet%2Fdial.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdial.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "87d76261f8e99e78c86b3e76ff5a8932c12f4698", "filename": "libgo/go/net/dnsclient.go", "status": "modified", "additions": 53, "deletions": 1, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fnet%2Fdnsclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fnet%2Fdnsclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdnsclient.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "f4089c5db8a1c57a1741746d150dd08430440023", "filename": "libgo/go/net/dnsname_test.go", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fnet%2Fdnsname_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fnet%2Fdnsname_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdnsname_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "896178f18efeff4a7b02be082b1f55d64cf5fe55", "filename": "libgo/go/net/fd.go", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fnet%2Ffd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fnet%2Ffd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "9b91eb398cbb5735a6e28d96db17e1e60842566c", "filename": "libgo/go/net/fd_windows.go", "status": "modified", "additions": 222, "deletions": 47, "changes": 269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fnet%2Ffd_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fnet%2Ffd_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd_windows.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "8525f578d74457af6e80752eeb3194b9907fe05d", "filename": "libgo/go/net/hosts.go", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fnet%2Fhosts.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fnet%2Fhosts.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhosts.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "4ba6a55b96f70cae0d09065620deaac9f027eeab", "filename": "libgo/go/net/ipsock.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fnet%2Fipsock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fnet%2Fipsock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fipsock.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "275b31c0e31538fafee6762e47933ff63a5c501f", "filename": "libgo/go/net/net_test.go", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fnet%2Fnet_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fnet%2Fnet_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fnet_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "7d25058b29cd7e6572be7573156ab8d62eb6b198", "filename": "libgo/go/net/port.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fnet%2Fport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fnet%2Fport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fport.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "f3d854ff253ba00a0a234819270e5d77af01e316", "filename": "libgo/go/net/resolv_windows.go", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fnet%2Fresolv_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fnet%2Fresolv_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fresolv_windows.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "3f2442a462ddf435dd968af0a6e6e01a781f499c", "filename": "libgo/go/net/server_test.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fnet%2Fserver_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fnet%2Fserver_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fserver_test.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}, {"sha": "8ad3548add41cd34757ac0aec0a99cf595623d53", "filename": "libgo/go/net/sock.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fnet%2Fsock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f50c52c421d75940ef9392211e3ab24d71332/libgo%2Fgo%2Fnet%2Fsock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsock.go?ref=ff5f50c52c421d75940ef9392211e3ab24d71332"}]}