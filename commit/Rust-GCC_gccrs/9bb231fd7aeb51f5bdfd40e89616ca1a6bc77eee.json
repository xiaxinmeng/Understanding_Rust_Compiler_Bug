{"sha": "9bb231fd7aeb51f5bdfd40e89616ca1a6bc77eee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWJiMjMxZmQ3YWViNTFmNWJkZmQ0MGU4OTYxNmNhMWE2YmM3N2VlZQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2003-01-25T17:30:29Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-01-25T17:30:29Z"}, "message": "stmt.c (emit_case_bit_tests): New routine to implement suitable switch statements using the equivalent of \"if...\n\n\n\t* stmt.c (emit_case_bit_tests): New routine to implement suitable\n\tswitch statements using the equivalent of \"if ((1<<x) & cst) ... \".\n\t(case_bit_test_cmp): New comparison function for \"qsort\" to order\n\tcase_bit_tests by decreasing number of destination nodes.\n\t(lshift_cheap_p): New function to determine if \"1 << x\" is cheap.\n\t(expand_end_case_type): Use emit_case_bit_tests to implement\n\tsuitable switch statments.\n\t(CASE_USE_BIT_TESTS): New target macro to disable the above.\n\t* Makefile.in (stmt.o): Add dependency on optab.h.\n\t* doc/tm.texi (CASE_USE_BIT_TESTS): Document new target macro.\n\n\t* gcc.c-torture/execute/switch-1.c: New test case.\n\nFrom-SVN: r61784", "tree": {"sha": "9c8023e7b287c57e4f064213bda30e0016c032ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c8023e7b287c57e4f064213bda30e0016c032ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9bb231fd7aeb51f5bdfd40e89616ca1a6bc77eee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bb231fd7aeb51f5bdfd40e89616ca1a6bc77eee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bb231fd7aeb51f5bdfd40e89616ca1a6bc77eee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bb231fd7aeb51f5bdfd40e89616ca1a6bc77eee/comments", "author": null, "committer": null, "parents": [{"sha": "a073323c198e956e1645dbe302cb986b78c8a081", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a073323c198e956e1645dbe302cb986b78c8a081", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a073323c198e956e1645dbe302cb986b78c8a081"}], "stats": {"total": 281, "additions": 277, "deletions": 4}, "files": [{"sha": "b4fe9b433dc4f1d345179b760442631369278efd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bb231fd7aeb51f5bdfd40e89616ca1a6bc77eee/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bb231fd7aeb51f5bdfd40e89616ca1a6bc77eee/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9bb231fd7aeb51f5bdfd40e89616ca1a6bc77eee", "patch": "@@ -1,3 +1,16 @@\n+2003-01-25  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* stmt.c (emit_case_bit_tests): New routine to implement suitable\n+\tswitch statements using the equivalent of \"if ((1<<x) & cst) ... \".\n+\t(case_bit_test_cmp): New comparison function for \"qsort\" to order\n+\tcase_bit_tests by decreasing number of destination nodes.\n+\t(lshift_cheap_p): New function to determine if \"1 << x\" is cheap.\n+\t(expand_end_case_type): Use emit_case_bit_tests to implement\n+\tsuitable switch statments.\n+\t(CASE_USE_BIT_TESTS): New target macro to disable the above.\n+\t* Makefile.in (stmt.o): Add dependency on optab.h.\n+\t* doc/tm.texi (CASE_USE_BIT_TESTS): Document new target macro.\n+\n 2003-01-23  Andreas Schwab  <schwab@suse.de>\n \n \t* config/ia64/crtend.asm [HAVE_INITFINI_ARRAY]: Make"}, {"sha": "7e2f77952ce6210006070838f749ea1ee33de387", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bb231fd7aeb51f5bdfd40e89616ca1a6bc77eee/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bb231fd7aeb51f5bdfd40e89616ca1a6bc77eee/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=9bb231fd7aeb51f5bdfd40e89616ca1a6bc77eee", "patch": "@@ -1461,7 +1461,7 @@ function.o : function.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(T\n stmt.o : stmt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) flags.h \\\n    function.h insn-config.h hard-reg-set.h $(EXPR_H) libfuncs.h except.h \\\n    $(LOOP_H) $(RECOG_H) toplev.h output.h varray.h $(GGC_H) $(TM_P_H) \\\n-   langhooks.h $(PREDICT_H) gt-stmt.h\n+   langhooks.h $(PREDICT_H) gt-stmt.h $(OPTABS_H)\n except.o : except.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n    flags.h except.h function.h $(EXPR_H) libfuncs.h integrate.h langhooks.h \\\n    insn-config.h hard-reg-set.h $(BASIC_BLOCK_H) output.h \\"}, {"sha": "7ba2f7e13eb3b45a72fe4d1505bcde70f7e073fd", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bb231fd7aeb51f5bdfd40e89616ca1a6bc77eee/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bb231fd7aeb51f5bdfd40e89616ca1a6bc77eee/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=9bb231fd7aeb51f5bdfd40e89616ca1a6bc77eee", "patch": "@@ -8627,6 +8627,16 @@ is best to use a jump-table instead of a tree of conditional branches.\n The default is four for machines with a @code{casesi} instruction and\n five otherwise.  This is best for most machines.\n \n+@findex CASE_USE_BIT_TESTS\n+@item CASE_USE_BIT_TESTS\n+Define this macro to be a C expression to indicate whether C switch\n+statements may be implemented by a sequence of bit tests.  This is\n+advantageous on processors that can efficiently implement left shift\n+of 1 by the number of bits held in a register, but inappropriate on\n+targets that would require a loop.  By default, this macro returns\n+@code{true} if the target defines an @code{ashlsi3} pattern, and\n+@code{false} otherwise.\n+\n @findex WORD_REGISTER_OPERATIONS\n @item WORD_REGISTER_OPERATIONS\n Define this macro if operations between registers with integral mode"}, {"sha": "f968012696927e278c479d0e0d7e3ffa4b7f3913", "filename": "gcc/stmt.c", "status": "modified", "additions": 192, "deletions": 3, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bb231fd7aeb51f5bdfd40e89616ca1a6bc77eee/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bb231fd7aeb51f5bdfd40e89616ca1a6bc77eee/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=9bb231fd7aeb51f5bdfd40e89616ca1a6bc77eee", "patch": "@@ -56,6 +56,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"ggc.h\"\n #include \"langhooks.h\"\n #include \"predict.h\"\n+#include \"optabs.h\"\n \n /* Assume that case vectors are not pc-relative.  */\n #ifndef CASE_VECTOR_PC_RELATIVE\n@@ -420,6 +421,10 @@ static void do_jump_if_equal\t\tPARAMS ((rtx, rtx, rtx, int));\n static int estimate_case_costs\t\tPARAMS ((case_node_ptr));\n static bool same_case_target_p\t\tPARAMS ((rtx, rtx));\n static void strip_default_case_nodes\tPARAMS ((case_node_ptr *, rtx));\n+static bool lshift_cheap_p\t\tPARAMS ((void));\n+static int case_bit_test_cmp\t\tPARAMS ((const void *, const void *));\n+static void emit_case_bit_tests\t\tPARAMS ((tree, tree, tree, tree,\n+\t\t\t\t\t\t case_node_ptr, rtx));\n static void group_case_nodes\t\tPARAMS ((case_node_ptr));\n static void balance_case_nodes\t\tPARAMS ((case_node_ptr *,\n \t\t\t\t\t       case_node_ptr));\n@@ -5172,6 +5177,154 @@ check_for_full_enumeration_handling (type)\n }\n \n \f\n+/* Maximum number of case bit tests.  */\n+#define MAX_CASE_BIT_TESTS  3\n+\n+/* By default, enable case bit tests on targets with ashlsi3.  */\n+#ifndef CASE_USE_BIT_TESTS\n+#define CASE_USE_BIT_TESTS  (ashl_optab->handlers[word_mode].insn_code \\\n+\t\t\t     != CODE_FOR_nothing)\n+#endif\n+\n+\n+/* A case_bit_test represents a set of case nodes that may be\n+   selected from using a bit-wise comparison.  HI and LO hold\n+   the integer to be tested against, LABEL contains the label\n+   to jump to upon success and BITS counts the number of case\n+   nodes handled by this test, typically the number of bits\n+   set in HI:LO.  */\n+\n+struct case_bit_test\n+{\n+  HOST_WIDE_INT hi;\n+  HOST_WIDE_INT lo;\n+  rtx label;\n+  int bits;\n+};\n+\n+/* Determine whether \"1 << x\" is relatively cheap in word_mode.  */\n+\n+static bool lshift_cheap_p ()\n+{\n+  static bool init = false;\n+  static bool cheap = true;\n+\n+  if (!init)\n+    {\n+      rtx reg = gen_rtx_REG (word_mode, 10000);\n+      int cost = rtx_cost (gen_rtx_ASHIFT (word_mode, const1_rtx, reg), SET);\n+      cheap = cost < COSTS_N_INSNS (3);\n+      init = true;\n+    }\n+\n+  return cheap;\n+}\n+\n+/* Comparison function for qsort to order bit tests by decreasing\n+   number of case nodes, i.e. the node with the most cases gets\n+   tested first.  */\n+\n+static int case_bit_test_cmp (p1, p2)\n+     const void *p1;\n+     const void *p2;\n+{\n+  const struct case_bit_test *d1 = p1;\n+  const struct case_bit_test *d2 = p2;\n+\n+  return d2->bits - d1->bits;\n+}\n+\n+/*  Expand a switch statement by a short sequence of bit-wise\n+    comparisons.  \"switch(x)\" is effectively converted into\n+    \"if ((1 << (x-MINVAL)) & CST)\" where CST and MINVAL are\n+    integer constants.\n+\n+    INDEX_EXPR is the value being switched on, which is of\n+    type INDEX_TYPE.  MINVAL is the lowest case value of in\n+    the case nodes, of INDEX_TYPE type, and RANGE is highest\n+    value minus MINVAL, also of type INDEX_TYPE.  NODES is\n+    the set of case nodes, and DEFAULT_LABEL is the label to\n+    branch to should none of the cases match.\n+\n+    There *MUST* be MAX_CASE_BIT_TESTS or less unique case\n+    node targets.  */\n+\n+static void\n+emit_case_bit_tests (index_type, index_expr, minval, range,\n+\t\t     nodes, default_label)\n+     tree index_type, index_expr, minval, range;\n+     case_node_ptr nodes;\n+     rtx default_label;\n+{\n+  struct case_bit_test test[MAX_CASE_BIT_TESTS];\n+  enum machine_mode mode;\n+  rtx expr, index, label;\n+  unsigned int i,j,lo,hi;\n+  struct case_node *n;\n+  unsigned int count;\n+\n+  count = 0;\n+  for (n = nodes; n; n = n->right)\n+    {\n+      label = label_rtx (n->code_label);\n+      for (i = 0; i < count; i++)\n+\tif (same_case_target_p (label, test[i].label))\n+\t  break;\n+\n+      if (i == count)\n+\t{\n+\t  if (count >= MAX_CASE_BIT_TESTS)\n+\t    abort ();\n+          test[i].hi = 0;\n+          test[i].lo = 0;\n+\t  test[i].label = label;\n+\t  test[i].bits = 1;\n+\t  count++;\n+\t}\n+      else\n+        test[i].bits++;\n+\n+      lo = tree_low_cst (fold (build (MINUS_EXPR, index_type,\n+\t\t\t\t      n->low, minval)), 1);\n+      hi = tree_low_cst (fold (build (MINUS_EXPR, index_type,\n+\t\t\t\t      n->high, minval)), 1);\n+      for (j = lo; j <= hi; j++)\n+        if (j >= HOST_BITS_PER_WIDE_INT)\n+\t  test[i].hi |= (HOST_WIDE_INT) 1 << (j - HOST_BITS_PER_INT);\n+\telse\n+\t  test[i].lo |= (HOST_WIDE_INT) 1 << j;\n+    }\n+\n+  qsort (test, count, sizeof(*test), case_bit_test_cmp);\n+\n+  index_expr = fold (build (MINUS_EXPR, index_type,\n+\t\t\t    convert (index_type, index_expr),\n+\t\t\t    convert (index_type, minval)));\n+  index = expand_expr (index_expr, NULL_RTX, VOIDmode, 0);\n+  emit_queue ();\n+  index = protect_from_queue (index, 0);\n+  do_pending_stack_adjust ();\n+\n+  mode = TYPE_MODE (index_type);\n+  expr = expand_expr (range, NULL_RTX, VOIDmode, 0);\n+  emit_cmp_and_jump_insns (index, expr, GTU, NULL_RTX, mode, 1,\n+\t\t\t   default_label);\n+\n+  index = convert_to_mode (word_mode, index, 0);\n+  index = expand_binop (word_mode, ashl_optab, const1_rtx,\n+\t\t\tindex, NULL_RTX, 1, OPTAB_WIDEN);\n+\n+  for (i = 0; i < count; i++)\n+    {\n+      expr = immed_double_const (test[i].lo, test[i].hi, word_mode);\n+      expr = expand_binop (word_mode, and_optab, index, expr,\n+\t\t\t   NULL_RTX, 1, OPTAB_WIDEN);\n+      emit_cmp_and_jump_insns (expr, const0_rtx, NE, NULL_RTX,\n+\t\t\t       word_mode, 1, test[i].label);\n+    }\n+\n+  emit_jump (default_label);\n+}\n \n /* Terminate a case (Pascal) or switch (C) statement\n    in which ORIG_INDEX is the expression to be tested.\n@@ -5185,14 +5338,14 @@ expand_end_case_type (orig_index, orig_type)\n {\n   tree minval = NULL_TREE, maxval = NULL_TREE, range = NULL_TREE;\n   rtx default_label = 0;\n-  struct case_node *n;\n-  unsigned int count;\n+  struct case_node *n, *m;\n+  unsigned int count, uniq;\n   rtx index;\n   rtx table_label;\n   int ncases;\n   rtx *labelvec;\n   int i;\n-  rtx before_case, end;\n+  rtx before_case, end, lab;\n   struct nesting *thiscase = case_stack;\n   tree index_expr, index_type;\n   bool exit_done = false;\n@@ -5267,6 +5420,7 @@ expand_end_case_type (orig_index, orig_type)\n       /* Get upper and lower bounds of case values.\n \t Also convert all the case values to the index expr's data type.  */\n \n+      uniq = 0;\n       count = 0;\n       for (n = thiscase->data.case_stmt.case_list; n; n = n->right)\n \t{\n@@ -5296,6 +5450,16 @@ expand_end_case_type (orig_index, orig_type)\n \t  /* A range counts double, since it requires two compares.  */\n \t  if (! tree_int_cst_equal (n->low, n->high))\n \t    count++;\n+\n+\t  /* Count the number of unique case node targets.  */\n+          uniq++;\n+\t  lab = label_rtx (n->code_label);\n+          for (m = thiscase->data.case_stmt.case_list; m != n; m = m->right)\n+            if (same_case_target_p (label_rtx (m->code_label), lab))\n+              {\n+                uniq--;\n+                break;\n+              }\n \t}\n \n       /* Compute span of values.  */\n@@ -5311,6 +5475,31 @@ expand_end_case_type (orig_index, orig_type)\n \t  emit_jump (default_label);\n \t}\n \n+      /* Try implementing this switch statement by a short sequence of\n+\t bit-wise comparisons.  However, we let the binary-tree case\n+\t below handle constant index expressions.  */\n+      else if (CASE_USE_BIT_TESTS\n+\t       && ! TREE_CONSTANT (index_expr)\n+\t       && compare_tree_int (range, GET_MODE_BITSIZE (word_mode)) < 0\n+\t       && lshift_cheap_p ()\n+\t       && ((uniq == 1 && count >= 3)\n+\t\t   || (uniq == 2 && count >= 5)\n+\t\t   || (uniq == 3 && count >= 6)))\n+\t{\n+\t  /* Optimize the case where all the case values fit in a\n+\t     word without having to subtract MINVAL.  In this case,\n+\t     we can optimize away the subtraction.  */\n+\t  if (compare_tree_int (minval, 0) > 0\n+\t      && compare_tree_int (maxval, GET_MODE_BITSIZE (word_mode)) < 0)\n+\t    {\n+\t      minval = integer_zero_node;\n+\t      range = maxval;\n+\t    }\n+\t  emit_case_bit_tests (index_type, index_expr, minval, range,\n+\t\t\t       thiscase->data.case_stmt.case_list,\n+\t\t\t       default_label);\n+\t}\n+\n       /* If range of values is much bigger than number of values,\n \t make a sequence of conditional branches instead of a dispatch.\n \t If the switch-index is a constant, do it this way"}, {"sha": "f6a8dff0a9ffba9aba5540a4242c6184e7e0166f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bb231fd7aeb51f5bdfd40e89616ca1a6bc77eee/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bb231fd7aeb51f5bdfd40e89616ca1a6bc77eee/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9bb231fd7aeb51f5bdfd40e89616ca1a6bc77eee", "patch": "@@ -1,3 +1,7 @@\n+2003-01-25  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* gcc.c-torture/execute/switch-1.c: New test case.\n+\n Sat Jan 25 12:32:55 CET 2003  Jan HUbicka  <jh@suse.cz>\n \n \t* gcc.c-torture/execute/20030125-1.[cx]: New test."}, {"sha": "30cffed7b857865e3fa23827aaac7915b461d37e", "filename": "gcc/testsuite/gcc.c-torture/execute/switch-1.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bb231fd7aeb51f5bdfd40e89616ca1a6bc77eee/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fswitch-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bb231fd7aeb51f5bdfd40e89616ca1a6bc77eee/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fswitch-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fswitch-1.c?ref=9bb231fd7aeb51f5bdfd40e89616ca1a6bc77eee", "patch": "@@ -0,0 +1,57 @@\n+/* Copyright (C) 2003  Free Software Foundation.\n+\n+   Test that switch statements suitable using case bit tests are\n+   implemented correctly.\n+\n+   Written by Roger Sayle, 01/25/2001.  */\n+\n+extern void abort (void);\n+\n+int\n+foo (int x)\n+{\n+  switch (x)\n+    {\n+    case 4:\n+    case 6:\n+    case 9:\n+    case 11:\n+      return 30;\n+    }\n+  return 31;\n+}\n+\n+int\n+main (int argc)\n+{\n+  int i, r;\n+\n+  for (i=-1; i<66; i++)\n+    {\n+      r = foo (i);\n+      if (i == 4)\n+\t{\n+\t  if (r != 30)\n+\t    abort ();\n+\t}\n+      else if (i == 6)\n+\t{\n+\t  if (r != 30)\n+\t    abort ();\n+\t}\n+      else if (i == 9)\n+\t{\n+\t  if (r != 30)\n+\t    abort ();\n+\t}\n+      else if (i == 11)\n+\t{\n+\t  if (r != 30)\n+\t    abort ();\n+\t}\n+      else if (r != 31)\n+\tabort ();\n+    }\n+  return 0;\n+}\n+"}]}