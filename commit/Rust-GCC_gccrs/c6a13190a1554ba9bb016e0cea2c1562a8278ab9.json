{"sha": "c6a13190a1554ba9bb016e0cea2c1562a8278ab9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzZhMTMxOTBhMTU1NGJhOWJiMDE2ZTBjZWEyYzE1NjJhODI3OGFiOQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2010-11-15T21:38:40Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2010-11-15T21:38:40Z"}, "message": "godump.c: New file.\n\ngcc/:\n\t* godump.c: New file.\n\t* common.opt (fdump-go-spec=): New option.\n\t* tree.h: Add comments for TYPE_SYMTAB_ADDRESS and friends.\n\t(TYPE_SYMTAB_IS_ADDRESS, TYPE_SYMTAB_IS_POINTER): Define.\n\t(TYPE_SYMTAB_IS_DIE): Define.\n\t(struct tree_type): Change GTY for symtab field to use\n\tTYPE_SYMTAB_IS_ADDRESS and friends and to use a debug_hooks field\n\tto pick the union field.\n\t* debug.h (struct gcc_debug_hooks): Add tree_type_symtab_field.\n\t(dump_go_spec_init): Declare.\n\t* toplev.c (process_options): Handle flag_dump_go_spec.\n\t* debug.c: Include \"tree.h\".\n\t(do_nothing_debug_hooks): Set tree_type_symtab_field.\n\t* dwarf2out.c (dwarf2_debug_hooks): Likewise.\n\t* dbxout.c (dbx_debug_hooks): Likewise.\n\t(xcoff_debug_hooks): Likewise.\n\t* vmsdbgout.c (vmsdbg_debug_hooks): Likewise.\n\t* sdbout.c (sdb_debug_hooks): Likewise.  Do not define if\n\tSDB_DEBUGGING_INFO is not defined.\n\t* doc/invoke.texi (Option Summary): Mention -fdump-go-spec.\n\t(Overall Options): Document -fdump-go-spec.\n\t* Makefile.in (OBJS-common): Add godump.o.\n\t(debug.o): Add dependency on $(TREE_H).\n\t(godump.o): New target.\n\t(GTFILES): Add $(srcdir)/godump.c.\ngcc/c-family/:\n\t* c-lex.c (init_c_lex): Set macro debug callbacks if\n\tflag_dump_go_spec is set.\n\nFrom-SVN: r166770", "tree": {"sha": "3c5132e72169c26eb5dcd1aa3737556a21ce16c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c5132e72169c26eb5dcd1aa3737556a21ce16c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c6a13190a1554ba9bb016e0cea2c1562a8278ab9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6a13190a1554ba9bb016e0cea2c1562a8278ab9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6a13190a1554ba9bb016e0cea2c1562a8278ab9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6a13190a1554ba9bb016e0cea2c1562a8278ab9/comments", "author": null, "committer": null, "parents": [{"sha": "11746b92d8023be7a074b788ab2e42fa6ad2f492", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11746b92d8023be7a074b788ab2e42fa6ad2f492", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11746b92d8023be7a074b788ab2e42fa6ad2f492"}], "stats": {"total": 1048, "additions": 988, "deletions": 60}, "files": [{"sha": "5fe196602dd2377d74ee73d93f61ca4d1f7ad196", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6a13190a1554ba9bb016e0cea2c1562a8278ab9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6a13190a1554ba9bb016e0cea2c1562a8278ab9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c6a13190a1554ba9bb016e0cea2c1562a8278ab9", "patch": "@@ -1,3 +1,31 @@\n+2010-11-15  Ian Lance Taylor  <iant@google.com>\n+\n+\t* godump.c: New file.\n+\t* common.opt (fdump-go-spec=): New option.\n+\t* tree.h: Add comments for TYPE_SYMTAB_ADDRESS and friends.\n+\t(TYPE_SYMTAB_IS_ADDRESS, TYPE_SYMTAB_IS_POINTER): Define.\n+\t(TYPE_SYMTAB_IS_DIE): Define.\n+\t(struct tree_type): Change GTY for symtab field to use\n+\tTYPE_SYMTAB_IS_ADDRESS and friends and to use a debug_hooks field\n+\tto pick the union field.\n+\t* debug.h (struct gcc_debug_hooks): Add tree_type_symtab_field.\n+\t(dump_go_spec_init): Declare.\n+\t* toplev.c (process_options): Handle flag_dump_go_spec.\n+\t* debug.c: Include \"tree.h\".\n+\t(do_nothing_debug_hooks): Set tree_type_symtab_field.\n+\t* dwarf2out.c (dwarf2_debug_hooks): Likewise.\n+\t* dbxout.c (dbx_debug_hooks): Likewise.\n+\t(xcoff_debug_hooks): Likewise.\n+\t* vmsdbgout.c (vmsdbg_debug_hooks): Likewise.\n+\t* sdbout.c (sdb_debug_hooks): Likewise.  Do not define if\n+\tSDB_DEBUGGING_INFO is not defined.\n+\t* doc/invoke.texi (Option Summary): Mention -fdump-go-spec.\n+\t(Overall Options): Document -fdump-go-spec.\n+\t* Makefile.in (OBJS-common): Add godump.o.\n+\t(debug.o): Add dependency on $(TREE_H).\n+\t(godump.o): New target.\n+\t(GTFILES): Add $(srcdir)/godump.c.\n+\n 2010-11-15  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR debug/46095"}, {"sha": "6bf5a5148e896ed30509e906f255e28d3717f7c3", "filename": "gcc/Makefile.in", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6a13190a1554ba9bb016e0cea2c1562a8278ab9/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6a13190a1554ba9bb016e0cea2c1562a8278ab9/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=c6a13190a1554ba9bb016e0cea2c1562a8278ab9", "patch": "@@ -1234,6 +1234,7 @@ OBJS-common = \\\n \tgimple-low.o \\\n \tgimple-pretty-print.o \\\n \tgimplify.o \\\n+\tgodump.o \\\n \tgraph.o \\\n \tgraphds.o \\\n \tgraphite.o \\\n@@ -2945,7 +2946,7 @@ dbxout.o : dbxout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(RTL_H) $(FLAGS_H) $(REGS_H) debug.h $(TM_P_H) $(TARGET_H) $(FUNCTION_H) \\\n    langhooks.h insn-config.h reload.h $(GSTAB_H) xcoffout.h output.h dbxout.h \\\n    $(TOPLEV_H) $(DIAGNOSTIC_CORE_H) $(GGC_H) $(OBSTACK_H) $(EXPR_H) gt-dbxout.h\n-debug.o : debug.c debug.h $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H)\n+debug.o : debug.c debug.h $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H)\n sdbout.o : sdbout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) debug.h \\\n    $(TREE_H) $(GGC_H) $(RTL_H) $(REGS_H) $(FLAGS_H) insn-config.h \\\n    output.h $(TOPLEV_H) $(DIAGNOSTIC_CORE_H) $(TM_P_H) gsyms.h langhooks.h $(TARGET_H) sdbout.h \\\n@@ -2965,6 +2966,8 @@ vmsdbgout.o : vmsdbgout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H)\n xcoffout.o : xcoffout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) $(RTL_H) xcoffout.h $(FLAGS_H) $(TOPLEV_H) $(DIAGNOSTIC_CORE_H) output.h dbxout.h \\\n    $(GGC_H) $(TARGET_H) debug.h $(GSTAB_H) xcoff.h\n+godump.o : godump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(DIAGNOSTIC_CORE_H) \\\n+   $(TREE_H) $(GGC_H) pointer-set.h $(OBSTACK_H) debug.h\n emit-rtl.o : emit-rtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(FLAGS_H) $(FUNCTION_H) $(REGS_H) insn-config.h $(RECOG_H) \\\n    $(GGC_H) $(EXPR_H) hard-reg-set.h $(BITMAP_H) $(TOPLEV_H) $(DIAGNOSTIC_CORE_H) $(BASIC_BLOCK_H) \\\n@@ -3739,7 +3742,8 @@ GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/emit-rtl.c $(srcdir)/except.h $(srcdir)/explow.c $(srcdir)/expr.c \\\n   $(srcdir)/expr.h \\\n   $(srcdir)/function.c $(srcdir)/except.c \\\n-  $(srcdir)/gcse.c $(srcdir)/integrate.c $(srcdir)/lists.c $(srcdir)/optabs.c \\\n+  $(srcdir)/gcse.c $(srcdir)/godump.c \\\n+  $(srcdir)/integrate.c $(srcdir)/lists.c $(srcdir)/optabs.c \\\n   $(srcdir)/profile.c $(srcdir)/mcf.c \\\n   $(srcdir)/reg-stack.c $(srcdir)/cfglayout.c $(srcdir)/cfglayout.h \\\n   $(srcdir)/sdbout.c $(srcdir)/stor-layout.c \\"}, {"sha": "3af8ebeb5d6e02acd842620e3fd112591fef75a5", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6a13190a1554ba9bb016e0cea2c1562a8278ab9/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6a13190a1554ba9bb016e0cea2c1562a8278ab9/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=c6a13190a1554ba9bb016e0cea2c1562a8278ab9", "patch": "@@ -1,3 +1,8 @@\n+2010-11-15  Ian Lance Taylor  <iant@google.com>\n+\n+\t* c-lex.c (init_c_lex): Set macro debug callbacks if\n+\tflag_dump_go_spec is set.\n+\n 2010-11-15  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* c-common.h (objc_build_incr_expr_for_property_ref): New."}, {"sha": "68a0fe04a5cd89e6b29d5682077fb595a2d5b9ae", "filename": "gcc/c-family/c-lex.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6a13190a1554ba9bb016e0cea2c1562a8278ab9/gcc%2Fc-family%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6a13190a1554ba9bb016e0cea2c1562a8278ab9/gcc%2Fc-family%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-lex.c?ref=c6a13190a1554ba9bb016e0cea2c1562a8278ab9", "patch": "@@ -87,9 +87,10 @@ init_c_lex (void)\n   cb->read_pch = c_common_read_pch;\n \n   /* Set the debug callbacks if we can use them.  */\n-  if (debug_info_level == DINFO_LEVEL_VERBOSE\n-      && (write_symbols == DWARF2_DEBUG\n-\t  || write_symbols == VMS_AND_DWARF2_DEBUG))\n+  if ((debug_info_level == DINFO_LEVEL_VERBOSE\n+       && (write_symbols == DWARF2_DEBUG\n+\t   || write_symbols == VMS_AND_DWARF2_DEBUG))\n+      || flag_dump_go_spec != NULL)\n     {\n       cb->define = cb_define;\n       cb->undef = cb_undef;"}, {"sha": "0a6e38c4bbd7abddad908c2ec0cd17a667ed18e6", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6a13190a1554ba9bb016e0cea2c1562a8278ab9/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6a13190a1554ba9bb016e0cea2c1562a8278ab9/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=c6a13190a1554ba9bb016e0cea2c1562a8278ab9", "patch": "@@ -825,6 +825,10 @@ fdump-final-insns=\n Common RejectNegative Joined Var(flag_dump_final_insns)\n -fdump-final-insns=filename\tDump to filename the insns at the end of translation\n \n+fdump-go-spec=\n+Common RejectNegative Joined Var(flag_dump_go_spec)\n+-fdump-go-spec=filename\tWrite all declarations to file as Go code\n+\n fdump-noaddr\n Common Report Var(flag_dump_noaddr)\n Suppress output of addresses in debugging dumps"}, {"sha": "89ea0f360900a8819c72b6748ac35c8ffa7f6e2f", "filename": "gcc/dbxout.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6a13190a1554ba9bb016e0cea2c1562a8278ab9/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6a13190a1554ba9bb016e0cea2c1562a8278ab9/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=c6a13190a1554ba9bb016e0cea2c1562a8278ab9", "patch": "@@ -384,7 +384,8 @@ const struct gcc_debug_hooks dbx_debug_hooks =\n   debug_nothing_rtx_rtx,\t         /* copy_call_info */\n   debug_nothing_uid,\t\t         /* virtual_call */\n   debug_nothing_tree_tree,\t\t /* set_name */\n-  0                                      /* start_end_main_source_file */\n+  0,                                     /* start_end_main_source_file */\n+  TYPE_SYMTAB_IS_ADDRESS                 /* tree_type_symtab_field */\n };\n #endif /* DBX_DEBUGGING_INFO  */\n \n@@ -423,7 +424,8 @@ const struct gcc_debug_hooks xcoff_debug_hooks =\n   debug_nothing_rtx_rtx,\t         /* copy_call_info */\n   debug_nothing_uid,\t\t         /* virtual_call */\n   debug_nothing_tree_tree,\t         /* set_name */\n-  0                                      /* start_end_main_source_file */\n+  0,                                     /* start_end_main_source_file */\n+  TYPE_SYMTAB_IS_ADDRESS                 /* tree_type_symtab_field */\n };\n #endif /* XCOFF_DEBUGGING_INFO  */\n \f"}, {"sha": "47d5a13e22cdc11f30eb25aef7b086708802ba41", "filename": "gcc/debug.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6a13190a1554ba9bb016e0cea2c1562a8278ab9/gcc%2Fdebug.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6a13190a1554ba9bb016e0cea2c1562a8278ab9/gcc%2Fdebug.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdebug.c?ref=c6a13190a1554ba9bb016e0cea2c1562a8278ab9", "patch": "@@ -20,6 +20,7 @@\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tm.h\"\n+#include \"tree.h\"\n #include \"debug.h\"\n \n /* The do-nothing debug hooks.  */\n@@ -57,7 +58,8 @@ const struct gcc_debug_hooks do_nothing_debug_hooks =\n   debug_nothing_rtx_rtx,\t         /* copy_call_info */\n   debug_nothing_uid,\t\t         /* virtual_call */\n   debug_nothing_tree_tree,\t\t /* set_name */\n-  0                                      /* start_end_main_source_file */\n+  0,                                     /* start_end_main_source_file */\n+  TYPE_SYMTAB_IS_ADDRESS                 /* tree_type_symtab_field */\n };\n \n /* This file contains implementations of each debug hook that do"}, {"sha": "cdaf457cb4c47bb31afee272353bed0e3d554622", "filename": "gcc/debug.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6a13190a1554ba9bb016e0cea2c1562a8278ab9/gcc%2Fdebug.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6a13190a1554ba9bb016e0cea2c1562a8278ab9/gcc%2Fdebug.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdebug.h?ref=c6a13190a1554ba9bb016e0cea2c1562a8278ab9", "patch": "@@ -165,6 +165,10 @@ struct gcc_debug_hooks\n   /* This is 1 if the debug writer wants to see start and end commands for the\n      main source files, and 0 otherwise.  */\n   int start_end_main_source_file;\n+\n+  /* The type of symtab field used by these debug hooks.  This is one\n+     of the TYPE_SYMTAB_IS_xxx values defined in tree.h.  */\n+  int tree_type_symtab_field;\n };\n \n extern const struct gcc_debug_hooks *debug_hooks;\n@@ -217,4 +221,9 @@ extern int symbol_queue_index;\n const char *remap_debug_filename (const char *);\n void add_debug_prefix_map (const char *);\n \n+/* For -fdump-go-spec.  */\n+\n+extern const struct gcc_debug_hooks *\n+dump_go_spec_init (const char *, const struct gcc_debug_hooks *);\n+\n #endif /* !GCC_DEBUG_H  */"}, {"sha": "9509b835c9c830472705f8216402945ea21462cf", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6a13190a1554ba9bb016e0cea2c1562a8278ab9/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6a13190a1554ba9bb016e0cea2c1562a8278ab9/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=c6a13190a1554ba9bb016e0cea2c1562a8278ab9", "patch": "@@ -165,7 +165,7 @@ in the following sections.\n -pipe  -pass-exit-codes  @gol\n -x @var{language}  -v  -###  --help@r{[}=@var{class}@r{[},@dots{}@r{]]}  --target-help  @gol\n --version -wrapper @@@var{file} -fplugin=@var{file} -fplugin-arg-@var{name}=@var{arg}  @gol\n--fdump-ada-spec@r{[}-slim@r{]}}\n+-fdump-ada-spec@r{[}-slim@r{]}} -fdump-go-spec=@var{file}\n \n @item C Language Options\n @xref{C Dialect Options,,Options Controlling C Dialect}.\n@@ -1385,6 +1385,13 @@ For C and C++ source and include files, generate corresponding Ada\n specs. @xref{Generating Ada Bindings for C and C++ headers,,, gnat_ugn,\n GNAT User's Guide}, which provides detailed documentation on this feature.\n \n+@item -fdump-go-spec=@var{file}\n+For input files in any language, generate corresponding Go\n+declarations in @var{file}.  This generates Go @code{const},\n+@code{type}, @code{var}, and @code{func} declarations which may be a\n+useful way to start writing a Go interface to code written in some\n+other language.\n+\n @include @value{srcdir}/../libiberty/at-file.texi\n @end table\n "}, {"sha": "4eade28815a49e009ab322aeef7271da4c2a89ad", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6a13190a1554ba9bb016e0cea2c1562a8278ab9/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6a13190a1554ba9bb016e0cea2c1562a8278ab9/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=c6a13190a1554ba9bb016e0cea2c1562a8278ab9", "patch": "@@ -5648,7 +5648,8 @@ const struct gcc_debug_hooks dwarf2_debug_hooks =\n   dwarf2out_copy_call_info,\n   dwarf2out_virtual_call,\n   dwarf2out_set_name,\n-  1                             /* start_end_main_source_file */\n+  1,                            /* start_end_main_source_file */\n+  TYPE_SYMTAB_IS_DIE            /* tree_type_symtab_field */\n };\n \f\n /* NOTE: In the comments in this file, many references are made to"}, {"sha": "662aa92284a62ff2117c50b63bb72a861adae793", "filename": "gcc/godump.c", "status": "added", "additions": 874, "deletions": 0, "changes": 874, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6a13190a1554ba9bb016e0cea2c1562a8278ab9/gcc%2Fgodump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6a13190a1554ba9bb016e0cea2c1562a8278ab9/gcc%2Fgodump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgodump.c?ref=c6a13190a1554ba9bb016e0cea2c1562a8278ab9", "patch": "@@ -0,0 +1,874 @@\n+/* Output Go language descriptions of types.\n+   Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor <iant@google.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* This file is used during the build process to emit Go language\n+   descriptions of declarations from C header files.  It uses the\n+   debug info hooks to emit the descriptions.  The Go language\n+   descriptions then become part of the Go runtime support\n+   library.\n+\n+   All global names are output with a leading underscore, so that they\n+   are all hidden in Go.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"diagnostic-core.h\"\n+#include \"tree.h\"\n+#include \"ggc.h\"\n+#include \"pointer-set.h\"\n+#include \"obstack.h\"\n+#include \"debug.h\"\n+\n+/* We dump this information from the debug hooks.  This gives us a\n+   stable and maintainable API to hook into.  In order to work\n+   correctly when -g is used, we build our own hooks structure which\n+   wraps the hooks we need to change.  */\n+\n+/* Our debug hooks.  This is initialized by dump_go_spec_init.  */\n+\n+static struct gcc_debug_hooks go_debug_hooks;\n+\n+/* The real debug hooks.  */\n+\n+static const struct gcc_debug_hooks *real_debug_hooks;\n+\n+/* The file where we should write information.  */\n+\n+static FILE *go_dump_file;\n+\n+/* A queue of decls to output.  */\n+\n+static GTY(()) VEC(tree,gc) *queue;\n+\n+/* A hash table of macros we have seen.  */\n+\n+static htab_t macro_hash;\n+\n+/* For the hash tables.  */\n+\n+static int\n+string_hash_eq (const void *y1, const void *y2)\n+{\n+  return strcmp ((const char *) y1, (const char *) y2) == 0;\n+}\n+\n+/* A macro definition.  */\n+\n+static void\n+go_define (unsigned int lineno, const char *buffer)\n+{\n+  const char *p;\n+  const char *name_end;\n+  char *out_buffer;\n+  char *q;\n+  char *copy;\n+  hashval_t hashval;\n+  void **slot;\n+\n+  real_debug_hooks->define (lineno, buffer);\n+\n+  /* Skip macro functions.  */\n+  for (p = buffer; *p != '\\0' && *p != ' '; ++p)\n+    if (*p == '(')\n+      return;\n+\n+  if (*p == '\\0')\n+    return;\n+\n+  name_end = p;\n+\n+  ++p;\n+  if (*p == '\\0')\n+    return;\n+\n+  copy = XNEWVEC (char, name_end - buffer + 1);\n+  memcpy (copy, buffer, name_end - buffer);\n+  copy[name_end - buffer] = '\\0';\n+\n+  hashval = htab_hash_string (copy);\n+  slot = htab_find_slot_with_hash (macro_hash, copy, hashval, NO_INSERT);\n+  if (slot != NULL)\n+    {\n+      XDELETEVEC (copy);\n+      return;\n+    }\n+\n+  /* For simplicity, we force all names to be hidden by adding an\n+     initial underscore, and let the user undo this as needed.  */\n+  out_buffer = XNEWVEC (char, strlen (p) * 2 + 1);\n+  q = out_buffer;\n+  while (*p != '\\0')\n+    {\n+      if (ISALPHA (*p) || *p == '_')\n+\t{\n+\t  const char *start;\n+\t  char *n;\n+\n+\t  start = p;\n+\t  while (ISALNUM (*p) || *p == '_')\n+\t    ++p;\n+\t  n = XALLOCAVEC (char, p - start + 1);\n+\t  memcpy (n, start, p - start);\n+\t  n[p - start] = '\\0';\n+\t  slot = htab_find_slot (macro_hash, n, NO_INSERT);\n+\t  if (slot == NULL || *slot == NULL)\n+\t    {\n+\t      /* This is a reference to a name which was not defined\n+\t\t as a macro.  */\n+\t      fprintf (go_dump_file, \"// unknowndefine %s\\n\", buffer);\n+\t      return;\n+\t    }\n+\n+\t  *q++ = '_';\n+\t  memcpy (q, start, p - start);\n+\t  q += p - start;\n+\t}\n+      else if (ISDIGIT (*p)\n+\t       || (*p == '.' && ISDIGIT (p[1])))\n+\t{\n+\t  const char *start;\n+\t  bool is_hex;\n+\n+\t  start = p;\n+\t  is_hex = false;\n+\t  if (*p == '0' && (p[1] == 'x' || p[1] == 'X'))\n+\t    {\n+\t      p += 2;\n+\t      is_hex = true;\n+\t    }\n+\t  while (ISDIGIT (*p) || *p == '.' || *p == 'e' || *p == 'E'\n+\t\t || (is_hex\n+\t\t     && ((*p >= 'a' && *p <= 'f')\n+\t\t\t || (*p >= 'A' && *p <= 'F'))))\n+\t    ++p;\n+\t  memcpy (q, start, p - start);\n+\t  q += p - start;\n+\t  while (*p == 'u' || *p == 'U' || *p == 'l' || *p == 'L'\n+\t\t || *p == 'f' || *p == 'F'\n+\t\t || *p == 'd' || *p == 'D')\n+\t    {\n+\t      /* Go doesn't use any of these trailing type\n+\t\t modifiers.  */\n+\t      ++p;\n+\t    }\n+\t}\n+      else if (ISSPACE (*p)\n+\t       || *p == '+' || *p == '-'\n+\t       || *p == '*' || *p == '/' || *p == '%'\n+\t       || *p == '|' || *p == '&'\n+\t       || *p == '>' || *p == '<'\n+\t       || *p == '!'\n+\t       || *p == '(' || *p == ')'\n+\t       || *p == '\"' || *p == '\\'')\n+\t*q++ = *p++;\n+      else\n+\t{\n+\t  /* Something we don't recognize.  */\n+\t  fprintf (go_dump_file, \"// unknowndefine %s\\n\", buffer);\n+\t  return;\n+\t}\n+    }\n+  *q = '\\0';\n+\n+  slot = htab_find_slot_with_hash (macro_hash, copy, hashval, INSERT);\n+  *slot = copy;\n+\n+  fprintf (go_dump_file, \"const _%s = %s\\n\", copy, out_buffer);\n+\n+  XDELETEVEC (out_buffer);\n+}\n+\n+/* A macro undef.  */\n+\n+static void\n+go_undef (unsigned int lineno, const char *buffer)\n+{\n+  void **slot;\n+\n+  real_debug_hooks->undef (lineno, buffer);\n+\n+  slot = htab_find_slot (macro_hash, buffer, NO_INSERT);\n+  if (slot == NULL)\n+    return;\n+  fprintf (go_dump_file, \"// undef _%s\\n\", buffer);\n+  /* We don't delete the slot from the hash table because that will\n+     cause a duplicate const definition.  */\n+}\n+\n+/* A function or variable decl.  */\n+\n+static void\n+go_decl (tree decl)\n+{\n+  if (!TREE_PUBLIC (decl)\n+      || DECL_IS_BUILTIN (decl)\n+      || DECL_NAME (decl) == NULL_TREE)\n+    return;\n+  VEC_safe_push (tree, gc, queue, decl);\n+}\n+\n+/* A function decl.  */\n+\n+static void\n+go_function_decl (tree decl)\n+{\n+  real_debug_hooks->function_decl (decl);\n+  go_decl (decl);\n+}\n+\n+/* A global variable decl.  */\n+\n+static void\n+go_global_decl (tree decl)\n+{\n+  real_debug_hooks->global_decl (decl);\n+  go_decl (decl);\n+}\n+\n+/* A type declaration.  */\n+\n+static void\n+go_type_decl (tree decl, int local)\n+{\n+  real_debug_hooks->type_decl (decl, local);\n+\n+  if (local || DECL_IS_BUILTIN (decl))\n+    return;\n+  if (DECL_NAME (decl) == NULL_TREE\n+      && (TYPE_NAME (TREE_TYPE (decl)) == NULL_TREE\n+\t  || TREE_CODE (TYPE_NAME (TREE_TYPE (decl))) != IDENTIFIER_NODE)\n+      && TREE_CODE (TREE_TYPE (decl)) != ENUMERAL_TYPE)\n+    return;\n+  VEC_safe_push (tree, gc, queue, decl);\n+}\n+\n+/* A container for the data we pass around when generating information\n+   at the end of the compilation.  */\n+\n+struct godump_container\n+{\n+  /* DECLs that we have already seen.  */\n+  struct pointer_set_t *decls_seen;\n+\n+  /* Types which may potentially have to be defined as dummy\n+     types.  */\n+  struct pointer_set_t *pot_dummy_types;\n+\n+  /* Go keywords.  */\n+  htab_t keyword_hash;\n+\n+  /* Global type definitions.  */\n+  htab_t type_hash;\n+\n+  /* Obstack used to write out a type definition.  */\n+  struct obstack type_obstack;\n+};\n+\n+/* Append an IDENTIFIER_NODE to OB.  */\n+\n+static void\n+go_append_string (struct obstack *ob, tree id)\n+{\n+  obstack_grow (ob, IDENTIFIER_POINTER (id), IDENTIFIER_LENGTH (id));\n+}\n+\n+/* Write the Go version of TYPE to CONTAINER->TYPE_OBSTACK.\n+   USE_TYPE_NAME is true if we can simply use a type name here without\n+   needing to define it.  IS_FUNC_OK is true if we can output a func\n+   type here; the \"func\" keyword will already have been added.  Return\n+   true if the type can be represented in Go, false otherwise.  */\n+\n+static bool\n+go_format_type (struct godump_container *container, tree type,\n+\t\tbool use_type_name, bool is_func_ok)\n+{\n+  bool ret;\n+  struct obstack *ob;\n+\n+  ret = true;\n+  ob = &container->type_obstack;\n+\n+  if (TYPE_NAME (type) != NULL_TREE\n+      && (pointer_set_contains (container->decls_seen, type)\n+\t  || pointer_set_contains (container->decls_seen, TYPE_NAME (type)))\n+      && (AGGREGATE_TYPE_P (type)\n+\t  || POINTER_TYPE_P (type)\n+\t  || TREE_CODE (type) == FUNCTION_TYPE))\n+    {\n+      tree name;\n+\n+      name = TYPE_NAME (type);\n+      if (TREE_CODE (name) == IDENTIFIER_NODE)\n+\t{\n+\t  obstack_1grow (ob, '_');\n+\t  go_append_string (ob, name);\n+\t  return ret;\n+\t}\n+      else if (TREE_CODE (name) == TYPE_DECL)\n+\t{\n+\t  obstack_1grow (ob, '_');\n+\t  go_append_string (ob, DECL_NAME (name));\n+\t  return ret;\n+\t}\n+    }\n+\n+  pointer_set_insert (container->decls_seen, type);\n+\n+  switch (TREE_CODE (type))\n+    {\n+    case ENUMERAL_TYPE:\n+      obstack_grow (ob, \"int\", 3);\n+      break;\n+\n+    case TYPE_DECL:\n+      obstack_1grow (ob, '_');\n+      go_append_string (ob, DECL_NAME (type));\n+      break;\n+\n+    case INTEGER_TYPE:\n+      {\n+\tconst char *s;\n+\tchar buf[100];\n+\n+\tswitch (TYPE_PRECISION (type))\n+\t  {\n+\t  case 8:\n+\t    s = TYPE_UNSIGNED (type) ? \"uint8\" : \"int8\";\n+\t    break;\n+\t  case 16:\n+\t    s = TYPE_UNSIGNED (type) ? \"uint16\" : \"int16\";\n+\t    break;\n+\t  case 32:\n+\t    s = TYPE_UNSIGNED (type) ? \"uint32\" : \"int32\";\n+\t    break;\n+\t  case 64:\n+\t    s = TYPE_UNSIGNED (type) ? \"uint64\" : \"int64\";\n+\t    break;\n+\t  default:\n+\t    snprintf (buf, sizeof buf, \"INVALID-int-%u%s\",\n+\t\t      TYPE_PRECISION (type),\n+\t\t      TYPE_UNSIGNED (type) ? \"u\" : \"\");\n+\t    s = buf;\n+\t    ret = false;\n+\t    break;\n+\t  }\n+\tobstack_grow (ob, s, strlen (s));\n+      }\n+      break;\n+\n+    case REAL_TYPE:\n+      {\n+\tconst char *s;\n+\tchar buf[100];\n+\n+\tswitch (TYPE_PRECISION (type))\n+\t  {\n+\t  case 32:\n+\t    s = \"float32\";\n+\t    break;\n+\t  case 64:\n+\t    s = \"float64\";\n+\t    break;\n+\t  case 80:\n+\t    s = \"float80\";\n+\t    break;\n+\t  default:\n+\t    snprintf (buf, sizeof buf, \"INVALID-float-%u\",\n+\t\t      TYPE_PRECISION (type));\n+\t    s = buf;\n+\t    ret = false;\n+\t    break;\n+\t  }\n+\tobstack_grow (ob, s, strlen (s));\n+      }\n+      break;\n+\n+    case BOOLEAN_TYPE:\n+      obstack_grow (ob, \"bool\", 4);\n+      break;\n+\n+    case POINTER_TYPE:\n+      if (use_type_name\n+          && TYPE_NAME (TREE_TYPE (type)) != NULL_TREE\n+          && (RECORD_OR_UNION_TYPE_P (TREE_TYPE (type))\n+\t      || (POINTER_TYPE_P (TREE_TYPE (type))\n+                  && (TREE_CODE (TREE_TYPE (TREE_TYPE (type)))\n+\t\t      == FUNCTION_TYPE))))\n+        {\n+\t  tree name;\n+\n+\t  name = TYPE_NAME (TREE_TYPE (type));\n+\t  if (TREE_CODE (name) == IDENTIFIER_NODE)\n+\t    {\n+\t      obstack_grow (ob, \"*_\", 2);\n+\t      go_append_string (ob, name);\n+\n+\t      /* The pointer here can be used without the struct or\n+\t\t union definition.  So this struct or union is a a\n+\t\t potential dummy type.  */\n+\t      if (RECORD_OR_UNION_TYPE_P (TREE_TYPE (type)))\n+\t\tpointer_set_insert (container->pot_dummy_types,\n+\t\t\t\t    IDENTIFIER_POINTER (name));\n+\n+\t      return ret;\n+\t    }\n+\t  else if (TREE_CODE (name) == TYPE_DECL)\n+\t    {\n+\t      obstack_grow (ob, \"*_\", 2);\n+\t      go_append_string (ob, DECL_NAME (name));\n+\t      if (RECORD_OR_UNION_TYPE_P (TREE_TYPE (type)))\n+\t\tpointer_set_insert (container->pot_dummy_types,\n+\t\t\t\t    IDENTIFIER_POINTER (DECL_NAME (name)));\n+\t      return ret;\n+\t    }\n+        }\n+      if (TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE)\n+\tobstack_grow (ob, \"func\", 4);\n+      else\n+\tobstack_1grow (ob, '*');\n+      if (VOID_TYPE_P (TREE_TYPE (type)))\n+\tobstack_grow (ob, \"byte\", 4);\n+      else\n+\t{\n+\t  if (!go_format_type (container, TREE_TYPE (type), use_type_name,\n+\t\t\t       true))\n+\t    ret = false;\n+\t}\n+      break;\n+\n+    case ARRAY_TYPE:\n+      obstack_1grow (ob, '[');\n+      if (TYPE_DOMAIN (type) != NULL_TREE\n+\t  && TREE_CODE (TYPE_DOMAIN (type)) == INTEGER_TYPE\n+\t  && TYPE_MIN_VALUE (TYPE_DOMAIN (type)) != NULL_TREE\n+\t  && TREE_CODE (TYPE_MIN_VALUE (TYPE_DOMAIN (type))) == INTEGER_CST\n+\t  && tree_int_cst_sgn (TYPE_MIN_VALUE (TYPE_DOMAIN (type))) == 0\n+\t  && TYPE_MAX_VALUE (TYPE_DOMAIN (type)) != NULL_TREE\n+\t  && TREE_CODE (TYPE_MAX_VALUE (TYPE_DOMAIN (type))) == INTEGER_CST\n+\t  && host_integerp (TYPE_MAX_VALUE (TYPE_DOMAIN (type)), 0))\n+\t{\n+\t  char buf[100];\n+\n+\t  snprintf (buf, sizeof buf, HOST_WIDE_INT_PRINT_DEC \"+1\",\n+\t\t    tree_low_cst (TYPE_MAX_VALUE (TYPE_DOMAIN (type)), 0));\n+\t  obstack_grow (ob, buf, strlen (buf));\n+\t}\n+      obstack_1grow (ob, ']');\n+      if (!go_format_type (container, TREE_TYPE (type), use_type_name, false))\n+\tret = false;\n+      break;\n+\n+    case UNION_TYPE:\n+    case RECORD_TYPE:\n+      {\n+\ttree field;\n+\tint i;\n+\n+\tobstack_grow (ob, \"struct { \", 9);\n+\ti = 0;\n+\tfor (field = TYPE_FIELDS (type);\n+\t     field != NULL_TREE;\n+\t     field = TREE_CHAIN (field))\n+\t  {\n+\t    if (DECL_NAME (field) == NULL)\n+\t      {\n+\t\tchar buf[100];\n+\n+\t\tobstack_grow (ob, \"_f\", 2);\n+\t\tsnprintf (buf, sizeof buf, \"%d\", i);\n+\t\tobstack_grow (ob, buf, strlen (buf));\n+\t\ti++;\n+\t      }\n+\t    else\n+              {\n+\t\tconst char *var_name;\n+\t\tvoid **slot;\n+\n+\t\t/* Start variable name with an underscore if a keyword.  */\n+\t\tvar_name = IDENTIFIER_POINTER (DECL_NAME (field));\n+\t\tslot = htab_find_slot (container->keyword_hash, var_name,\n+\t\t\t\t       NO_INSERT);\n+\t\tif (slot != NULL)\n+\t\t  obstack_1grow (ob, '_');\n+\t\tgo_append_string (ob, DECL_NAME (field));\n+\t      }\n+\t    obstack_1grow (ob, ' ');\n+\t    if (DECL_BIT_FIELD (field))\n+\t      {\n+\t\tobstack_grow (ob, \"INVALID-bit-field\", 17);\n+\t\tret = false;\n+\t      }\n+\t    else\n+              {\n+\t\t/* Do not expand type if a record or union type or a\n+\t\t   function pointer.  */\n+\t\tif (TYPE_NAME (TREE_TYPE (field)) != NULL_TREE\n+\t\t    && (RECORD_OR_UNION_TYPE_P (TREE_TYPE (field))\n+\t\t\t|| (POINTER_TYPE_P (TREE_TYPE (field))\n+\t\t\t    && (TREE_CODE (TREE_TYPE (TREE_TYPE (field)))\n+                                == FUNCTION_TYPE))))\n+\t\t  {\n+\t\t    tree name = TYPE_NAME (TREE_TYPE (field));\n+\t\t    if (TREE_CODE (name) == IDENTIFIER_NODE)\n+\t\t      {\n+\t\t\tobstack_1grow (ob, '_');\n+\t\t\tgo_append_string (ob, name);\n+\t\t      }\n+\t\t    else if (TREE_CODE (name) == TYPE_DECL)\n+\t\t      {\n+\t\t\tobstack_1grow (ob, '_');\n+\t\t\tgo_append_string (ob, DECL_NAME (name));\n+\t\t      }\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    if (!go_format_type (container, TREE_TYPE (field), true,\n+\t\t\t\t\t false))\n+\t\t      ret = false;\n+\t\t  }\n+              }\n+\t    obstack_grow (ob, \"; \", 2);\n+\n+\t    /* Only output the first field of a union, and hope for\n+\t       the best.  */\n+\t    if (TREE_CODE (type) == UNION_TYPE)\n+\t      break;\n+\t  }\n+\tobstack_1grow (ob, '}');\n+      }\n+      break;\n+\n+    case FUNCTION_TYPE:\n+      {\n+\ttree args;\n+\tbool is_varargs;\n+\ttree result;\n+\n+\t/* Go has no way to write a type which is a function but not a\n+\t   pointer to a function.  */\n+\tif (!is_func_ok)\n+\t  {\n+\t    obstack_grow (ob, \"func*\", 5);\n+\t    ret = false;\n+\t  }\n+\n+\tobstack_1grow (ob, '(');\n+\tis_varargs = true;\n+\tfor (args = TYPE_ARG_TYPES (type);\n+\t     args != NULL_TREE;\n+\t     args = TREE_CHAIN (args))\n+\t  {\n+\t    if (VOID_TYPE_P (TREE_VALUE (args)))\n+\t      {\n+\t\tgcc_assert (TREE_CHAIN (args) == NULL);\n+\t\tis_varargs = false;\n+\t\tbreak;\n+\t      }\n+\t    if (args != TYPE_ARG_TYPES (type))\n+\t      obstack_grow (ob, \", \", 2);\n+\t    if (!go_format_type (container, TREE_VALUE (args), true, false))\n+\t      ret = false;\n+\t  }\n+\tif (is_varargs)\n+\t  {\n+\t    if (TYPE_ARG_TYPES (type) != NULL_TREE)\n+\t      obstack_grow (ob, \", \", 2);\n+\t    obstack_grow (ob, \"...interface{}\", 14);\n+\t  }\n+\tobstack_1grow (ob, ')');\n+\n+\tresult = TREE_TYPE (type);\n+\tif (!VOID_TYPE_P (result))\n+\t  {\n+\t    obstack_1grow (ob, ' ');\n+\t    if (!go_format_type (container, result, use_type_name, false))\n+\t      ret = false;\n+\t  }\n+      }\n+      break;\n+\n+    default:\n+      obstack_grow (ob, \"INVALID-type\", 12);\n+      ret = false;\n+      break;\n+    }\n+\n+  return ret;\n+}\n+\n+/* Output the type which was built on the type obstack, and then free\n+   it.  */\n+\n+static void\n+go_output_type (struct godump_container *container)\n+{\n+  struct obstack *ob;\n+\n+  ob = &container->type_obstack;\n+  obstack_1grow (ob, '\\0');\n+  fputs (obstack_base (ob), go_dump_file);\n+  obstack_free (ob, obstack_base (ob));\n+}\n+\n+/* Output a function declaration.  */\n+\n+static void\n+go_output_fndecl (struct godump_container *container, tree decl)\n+{\n+  if (!go_format_type (container, TREE_TYPE (decl), false, true))\n+    fprintf (go_dump_file, \"// \");\n+  fprintf (go_dump_file, \"func _%s \",\n+\t   IDENTIFIER_POINTER (DECL_NAME (decl)));\n+  go_output_type (container);\n+  fprintf (go_dump_file, \" __asm__(\\\"%s\\\")\\n\",\n+\t   IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)));\n+}\n+\n+/* Output a typedef or something like a struct definition.  */\n+\n+static void\n+go_output_typedef (struct godump_container *container, tree decl)\n+{\n+  /* If we have an enum type, output the enum constants\n+     separately.  */\n+  if (TREE_CODE (TREE_TYPE (decl)) == ENUMERAL_TYPE\n+      && TYPE_SIZE (TREE_TYPE (decl)) != 0\n+      && !pointer_set_contains (container->decls_seen, TREE_TYPE (decl))\n+      && (TYPE_CANONICAL (TREE_TYPE (decl)) == NULL_TREE\n+\t  || !pointer_set_contains (container->decls_seen,\n+\t\t\t\t    TYPE_CANONICAL (TREE_TYPE (decl)))))\n+    {\n+      tree element;\n+\n+      for (element = TYPE_VALUES (TREE_TYPE (decl));\n+\t   element != NULL_TREE;\n+\t   element = TREE_CHAIN (element))\n+\tfprintf (go_dump_file, \"const _%s = \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n+\t\t IDENTIFIER_POINTER (TREE_PURPOSE (element)),\n+\t\t tree_low_cst (TREE_VALUE (element), 0));\n+      pointer_set_insert (container->decls_seen, TREE_TYPE (decl));\n+      if (TYPE_CANONICAL (TREE_TYPE (decl)) != NULL_TREE)\n+\tpointer_set_insert (container->decls_seen,\n+\t\t\t    TYPE_CANONICAL (TREE_TYPE (decl)));\n+    }\n+\n+  if (DECL_NAME (decl) != NULL_TREE)\n+    {\n+      void **slot;\n+      const char *type;\n+\n+      type = IDENTIFIER_POINTER (DECL_NAME (decl));\n+      /* If type defined already, skip.  */\n+      slot = htab_find_slot (container->type_hash, type, INSERT);\n+      if (*slot != NULL)\n+\treturn;\n+      *slot = CONST_CAST (void *, (const void *) type);\n+\n+      if (!go_format_type (container, TREE_TYPE (decl), false, false))\n+\tfprintf (go_dump_file, \"// \");\n+      fprintf (go_dump_file, \"type _%s \",\n+\t       IDENTIFIER_POINTER (DECL_NAME (decl)));\n+      go_output_type (container);\n+      pointer_set_insert (container->decls_seen, decl);\n+    }\n+  else if (RECORD_OR_UNION_TYPE_P (TREE_TYPE (decl)))\n+    {\n+       void **slot;\n+       const char *type;\n+\n+       type = IDENTIFIER_POINTER (TYPE_NAME (TREE_TYPE ((decl))));\n+       /* If type defined already, skip.  */\n+       slot = htab_find_slot (container->type_hash, type, INSERT);\n+       if (*slot != NULL)\n+         return;\n+       *slot = CONST_CAST (void *, (const void *) type);\n+\n+       if (!go_format_type (container, TREE_TYPE (decl), false, false))\n+\t fprintf (go_dump_file, \"// \");\n+       fprintf (go_dump_file, \"type _%s \",\n+\t       IDENTIFIER_POINTER (TYPE_NAME (TREE_TYPE (decl))));\n+       go_output_type (container);\n+    }\n+  else\n+    return;\n+\n+  fprintf (go_dump_file, \"\\n\");\n+}\n+\n+/* Output a variable.  */\n+\n+static void\n+go_output_var (struct godump_container *container, tree decl)\n+{\n+  if (pointer_set_contains (container->decls_seen, decl)\n+      || pointer_set_contains (container->decls_seen, DECL_NAME (decl)))\n+    return;\n+  pointer_set_insert (container->decls_seen, decl);\n+  pointer_set_insert (container->decls_seen, DECL_NAME (decl));\n+  if (!go_format_type (container, TREE_TYPE (decl), true, false))\n+    fprintf (go_dump_file, \"// \");\n+  fprintf (go_dump_file, \"var _%s \",\n+\t   IDENTIFIER_POINTER (DECL_NAME (decl)));\n+  go_output_type (container);\n+  fprintf (go_dump_file, \"\\n\");\n+\n+  /* Sometimes an extern variable is declared with an unknown struct\n+     type.  */\n+  if (TYPE_NAME (TREE_TYPE (decl)) != NULL_TREE\n+      && RECORD_OR_UNION_TYPE_P (TREE_TYPE (decl)))\n+    {\n+      tree type_name = TYPE_NAME (TREE_TYPE (decl));\n+      if (TREE_CODE (type_name) == IDENTIFIER_NODE)\n+\tpointer_set_insert (container->pot_dummy_types,\n+\t\t\t    IDENTIFIER_POINTER (type_name));\n+      else if (TREE_CODE (type_name) == TYPE_DECL)\n+\tpointer_set_insert (container->pot_dummy_types,\n+\t\t\t    IDENTIFIER_POINTER (DECL_NAME (type_name)));\n+    }\n+}\n+\n+/* Build a hash table with the Go keywords.  */\n+\n+static const char * const keywords[] = {\n+  \"__asm__\", \"break\", \"case\", \"chan\", \"const\", \"continue\", \"default\",\n+  \"defer\", \"else\", \"fallthrough\", \"for\", \"func\", \"go\", \"goto\", \"if\",\n+  \"import\", \"interface\", \"map\", \"package\", \"range\", \"return\", \"select\",\n+  \"struct\", \"switch\", \"type\", \"var\"\n+};\n+\n+static void\n+keyword_hash_init (struct godump_container *container)\n+{\n+  size_t i;\n+  size_t count = sizeof (keywords) / sizeof (keywords[0]);\n+  void **slot;\n+\n+  for (i = 0; i < count; i++)\n+    {\n+      slot = htab_find_slot (container->keyword_hash, keywords[i], INSERT);\n+      *slot = CONST_CAST (void *, (const void *) keywords[i]);\n+    }\n+}\n+\n+/* Traversing the pot_dummy_types and seeing which types are present\n+   in the global types hash table and creating dummy definitions if\n+   not found.  This function is invoked by pointer_set_traverse.  */\n+\n+static bool\n+find_dummy_types (const void *ptr, void *adata)\n+{\n+  struct godump_container *data = (struct godump_container *) adata;\n+  const char *type = (const char *) ptr;\n+  void **slot;\n+\n+  slot = htab_find_slot (data->type_hash, type, NO_INSERT);\n+  if (slot == NULL)\n+    fprintf (go_dump_file, \"type _%s struct {}\\n\", type);\n+  return true;\n+}\n+\n+/* Output symbols.  */\n+\n+static void\n+go_finish (const char *filename)\n+{\n+  struct godump_container container;\n+  unsigned int ix;\n+  tree decl;\n+\n+  real_debug_hooks->finish (filename);\n+\n+  container.decls_seen = pointer_set_create ();\n+  container.pot_dummy_types = pointer_set_create ();\n+  container.type_hash = htab_create (100, htab_hash_string,\n+                                     string_hash_eq, NULL);\n+  container.keyword_hash = htab_create (50, htab_hash_string,\n+                                        string_hash_eq, NULL);\n+  obstack_init (&container.type_obstack);\n+\n+  keyword_hash_init (&container);\n+\n+  FOR_EACH_VEC_ELT (tree, queue, ix, decl)\n+    {\n+      switch (TREE_CODE (decl))\n+\t{\n+\tcase FUNCTION_DECL:\n+\t  go_output_fndecl (&container, decl);\n+\t  break;\n+\n+\tcase TYPE_DECL:\n+\t  go_output_typedef (&container, decl);\n+\t  break;\n+\n+\tcase VAR_DECL:\n+\t  go_output_var (&container, decl);\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable();\n+\t}\n+    }\n+\n+  /* To emit dummy definitions.  */\n+  pointer_set_traverse (container.pot_dummy_types, find_dummy_types,\n+                        (void *) &container);\n+\n+  pointer_set_destroy (container.decls_seen);\n+  pointer_set_destroy (container.pot_dummy_types);\n+  htab_delete (container.type_hash);\n+  htab_delete (container.keyword_hash);\n+  obstack_free (&container.type_obstack, NULL);\n+\n+  queue = NULL;\n+\n+  if (fclose (go_dump_file) != 0)\n+    error (\"could not close Go dump file: %m\");\n+  go_dump_file = NULL;\n+}\n+\n+/* Set up our hooks.  */\n+\n+const struct gcc_debug_hooks *\n+dump_go_spec_init (const char *filename, const struct gcc_debug_hooks *hooks)\n+{\n+  go_dump_file = fopen (filename, \"w\");\n+  if (go_dump_file == NULL)\n+    {\n+      error (\"could not open Go dump file %qs: %m\", filename);\n+      return hooks;\n+    }\n+\n+  go_debug_hooks = *hooks;\n+  real_debug_hooks = hooks;\n+\n+  go_debug_hooks.finish = go_finish;\n+  go_debug_hooks.define = go_define;\n+  go_debug_hooks.undef = go_undef;\n+  go_debug_hooks.function_decl = go_function_decl;\n+  go_debug_hooks.global_decl = go_global_decl;\n+  go_debug_hooks.type_decl = go_type_decl;\n+\n+  macro_hash = htab_create (100, htab_hash_string, string_hash_eq, NULL);\n+\n+  return &go_debug_hooks;\n+}\n+\n+#include \"gt-godump.h\""}, {"sha": "95d7120dd49b984e3e41560ad325c52ca2cb27f4", "filename": "gcc/sdbout.c", "status": "modified", "additions": 2, "deletions": 42, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6a13190a1554ba9bb016e0cea2c1562a8278ab9/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6a13190a1554ba9bb016e0cea2c1562a8278ab9/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=c6a13190a1554ba9bb016e0cea2c1562a8278ab9", "patch": "@@ -345,7 +345,8 @@ const struct gcc_debug_hooks sdb_debug_hooks =\n   debug_nothing_rtx_rtx,\t         /* copy_call_info */\n   debug_nothing_uid,\t\t         /* virtual_call */\n   debug_nothing_tree_tree,\t\t /* set_name */\n-  0                                      /* start_end_main_source_file */\n+  0,                                     /* start_end_main_source_file */\n+  TYPE_SYMTAB_IS_POINTER                 /* tree_type_symtab_field */\n };\n \n /* Return a unique string to name an anonymous type.  */\n@@ -1704,47 +1705,6 @@ sdbout_init (const char *input_file_name ATTRIBUTE_UNUSED)\n   preinit_symbols = 0;\n }\n \n-#else  /* SDB_DEBUGGING_INFO */\n-\n-/* This should never be used, but its address is needed for comparisons.  */\n-const struct gcc_debug_hooks sdb_debug_hooks =\n-{\n-  0,\t\t/* init */\n-  0,\t\t/* finish */\n-  0,\t\t/* assembly_start */\n-  0,\t\t/* define */\n-  0,\t\t/* undef */\n-  0,\t\t/* start_source_file */\n-  0,\t\t/* end_source_file */\n-  0,\t\t/* begin_block */\n-  0,\t\t/* end_block */\n-  0,\t\t/* ignore_block */\n-  0,\t\t/* source_line */\n-  0,\t\t/* begin_prologue */\n-  0,\t\t/* end_prologue */\n-  0,\t\t/* begin_epilogue */\n-  0,\t\t/* end_epilogue */\n-  0,\t\t/* begin_function */\n-  0,\t\t/* end_function */\n-  0,\t\t/* function_decl */\n-  0,\t\t/* global_decl */\n-  0,\t\t/* type_decl */\n-  0,\t\t/* imported_module_or_decl */\n-  0,\t\t/* deferred_inline_function */\n-  0,\t\t/* outlining_inline_function */\n-  0,\t\t/* label */\n-  0,\t\t/* handle_pch */\n-  0,\t\t/* var_location */\n-  0,\t\t/* switch_text_section */\n-  0,\t\t/* direct_call */\n-  0,\t\t/* virtual_call_token */\n-  0,\t        /* copy_call_info */\n-  0,\t\t/* virtual_call */\n-  0,\t\t/* set_name */\n-  0\t\t/* start_end_main_source_file */\n-};\n-\n-\n #endif /* SDB_DEBUGGING_INFO */\n \n #include \"gt-sdbout.h\""}, {"sha": "3f158a4426df0cd3ec6719cecb57b85b6fed45e3", "filename": "gcc/toplev.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6a13190a1554ba9bb016e0cea2c1562a8278ab9/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6a13190a1554ba9bb016e0cea2c1562a8278ab9/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=c6a13190a1554ba9bb016e0cea2c1562a8278ab9", "patch": "@@ -1916,6 +1916,12 @@ process_options (void)\n       flag_var_tracking_uninit = 0;\n     }\n \n+  /* The debug hooks are used to implement -fdump-go-spec because it\n+     gives a simple and stable API for all the information we need to\n+     dump.  */\n+  if (flag_dump_go_spec != NULL)\n+    debug_hooks = dump_go_spec_init (flag_dump_go_spec, debug_hooks);\n+\n   /* If the user specifically requested variable tracking with tagging\n      uninitialized variables, we need to turn on variable tracking.\n      (We already determined above that variable tracking is feasible.)  */"}, {"sha": "6ae90f4128a0181c1f4365346ee2ec100c3cbb7a", "filename": "gcc/tree.h", "status": "modified", "additions": 31, "deletions": 7, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6a13190a1554ba9bb016e0cea2c1562a8278ab9/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6a13190a1554ba9bb016e0cea2c1562a8278ab9/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=c6a13190a1554ba9bb016e0cea2c1562a8278ab9", "patch": "@@ -2076,9 +2076,6 @@ struct GTY(()) tree_block {\n #define TYPE_MIN_VALUE(NODE) (NUMERICAL_TYPE_CHECK (NODE)->type.minval)\n #define TYPE_MAX_VALUE(NODE) (NUMERICAL_TYPE_CHECK (NODE)->type.maxval)\n #define TYPE_PRECISION(NODE) (TYPE_CHECK (NODE)->type.precision)\n-#define TYPE_SYMTAB_ADDRESS(NODE) (TYPE_CHECK (NODE)->type.symtab.address)\n-#define TYPE_SYMTAB_POINTER(NODE) (TYPE_CHECK (NODE)->type.symtab.pointer)\n-#define TYPE_SYMTAB_DIE(NODE) (TYPE_CHECK (NODE)->type.symtab.die)\n #define TYPE_NAME(NODE) (TYPE_CHECK (NODE)->type.name)\n #define TYPE_NEXT_VARIANT(NODE) (TYPE_CHECK (NODE)->type.next_variant)\n #define TYPE_MAIN_VARIANT(NODE) (TYPE_CHECK (NODE)->type.main_variant)\n@@ -2300,6 +2297,33 @@ extern enum machine_mode vector_type_mode (const_tree);\n #define TYPE_CONTAINS_PLACEHOLDER_INTERNAL(NODE) \\\n   (TYPE_CHECK (NODE)->type.contains_placeholder_bits)\n \n+/* The debug output functions use the symtab union field to store\n+   information specific to the debugging format.  The different debug\n+   output hooks store different types in the union field.  These three\n+   macros are used to access different fields in the union.  The debug\n+   hooks are responsible for consistently using only a specific\n+   macro.  */\n+\n+/* Symtab field as an integer.  Used by stabs generator in dbxout.c to\n+   hold the type's number in the generated stabs.  */\n+#define TYPE_SYMTAB_ADDRESS(NODE) (TYPE_CHECK (NODE)->type.symtab.address)\n+\n+/* Symtab field as a string.  Used by COFF generator in sdbout.c to\n+   hold struct/union type tag names.  */\n+#define TYPE_SYMTAB_POINTER(NODE) (TYPE_CHECK (NODE)->type.symtab.pointer)\n+\n+/* Symtab field as a pointer to a DWARF DIE.  Used by DWARF generator\n+   in dwarf2out.c to point to the DIE generated for the type.  */\n+#define TYPE_SYMTAB_DIE(NODE) (TYPE_CHECK (NODE)->type.symtab.die)\n+\n+/* The garbage collector needs to know the interpretation of the\n+   symtab field.  These constants represent the different types in the\n+   union.  */\n+\n+#define TYPE_SYMTAB_IS_ADDRESS (0)\n+#define TYPE_SYMTAB_IS_POINTER (1)\n+#define TYPE_SYMTAB_IS_DIE (2)\n+\n struct die_struct;\n \n struct GTY(()) tree_type {\n@@ -2333,10 +2357,10 @@ struct GTY(()) tree_type {\n   tree pointer_to;\n   tree reference_to;\n   union tree_type_symtab {\n-    int GTY ((tag (\"0\"))) address;\n-    const char * GTY ((tag (\"1\"))) pointer;\n-    struct die_struct * GTY ((tag (\"2\"))) die;\n-  } GTY ((desc (\"debug_hooks == &sdb_debug_hooks ? 1 : debug_hooks == &dwarf2_debug_hooks ? 2 : 0\"))) symtab;\n+    int GTY ((tag (\"TYPE_SYMTAB_IS_ADDRESS\"))) address;\n+    const char * GTY ((tag (\"TYPE_SYMTAB_IS_POINTER\"))) pointer;\n+    struct die_struct * GTY ((tag (\"TYPE_SYMTAB_IS_DIE\"))) die;\n+  } GTY ((desc (\"debug_hooks->tree_type_symtab_field\"))) symtab;\n   tree name;\n   tree minval;\n   tree maxval;"}, {"sha": "45da441972250f1d0f99aa54578413e6ebce9af0", "filename": "gcc/vmsdbgout.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6a13190a1554ba9bb016e0cea2c1562a8278ab9/gcc%2Fvmsdbgout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6a13190a1554ba9bb016e0cea2c1562a8278ab9/gcc%2Fvmsdbgout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvmsdbgout.c?ref=c6a13190a1554ba9bb016e0cea2c1562a8278ab9", "patch": "@@ -210,7 +210,8 @@ const struct gcc_debug_hooks vmsdbg_debug_hooks\n    debug_nothing_rtx_rtx,\t  /* copy_call_info */\n    debug_nothing_uid,\t\t  /* virtual_call */\n    debug_nothing_tree_tree,\t  /* set_name */\n-   0                              /* start_end_main_source_file */\n+   0,                             /* start_end_main_source_file */\n+   TYPE_SYMTAB_IS_ADDRESS         /* tree_type_symtab_field */\n };\n \n /* Definitions of defaults for assembler-dependent names of various"}]}