{"sha": "7ba9e72de95e7eece69bfff744df14b866280f9d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2JhOWU3MmRlOTVlN2VlY2U2OWJmZmY3NDRkZjE0Yjg2NjI4MGY5ZA==", "commit": {"author": {"name": "Trevor Saunders", "email": "tbsaunde+gcc@tbsaunde.org", "date": "2016-07-26T10:44:08Z"}, "committer": {"name": "Trevor Saunders", "email": "tbsaunde@gcc.gnu.org", "date": "2016-07-26T10:44:08Z"}, "message": "use auto_sbitmap in various places\n\ngcc/ChangeLog:\n\n2016-07-26  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n\n\t* bt-load.c (compute_out): Use auto_sbitmap class.\n\t(link_btr_uses): Likewise.\n\t* cfganal.c (mark_dfs_back_edges): Likewise.\n\t(post_order_compute): Likewise.\n\t(inverted_post_order_compute): Likewise.\n\t(pre_and_rev_post_order_compute_fn): Likewise.\n\t(single_pred_before_succ_order): Likewise.\n\t* cfgexpand.c (pass_expand::execute): Likewise.\n\t* cfgloop.c (verify_loop_structure): Likewise.\n\t* cfgloopmanip.c (fix_bb_placements): Likewise.\n\t(remove_path): Likewise.\n\t(update_dominators_in_loop): Likewise.\n\t* cfgrtl.c (break_superblocks): Likewise.\n\t* ddg.c (check_sccs): Likewise.\n\t(create_ddg_all_sccs): Likewise.\n\t* df-core.c (df_worklist_dataflow): Likewise.\n\t* dse.c (dse_step3): Likewise.\n\t* except.c (eh_region_outermost): Likewise.\n\t* function.c (thread_prologue_and_epilogue_insns): Likewise.\n\t* gcse.c (prune_expressions): Likewise.\n\t(prune_insertions_deletions): Likewise.\n\t* gimple-ssa-backprop.c (backprop::~backprop): Likewise.\n\t* graph.c (draw_cfg_nodes_no_loops): Likewise.\n\t* ira-lives.c (remove_some_program_points_and_update_live_ranges): Likewise.\n\t* lcm.c (compute_earliest): Likewise.\n\t(compute_farthest): Likewise.\n\t* loop-unroll.c (unroll_loop_constant_iterations): Likewise.\n\t(unroll_loop_runtime_iterations): Likewise.\n\t(unroll_loop_stupid): Likewise.\n\t* lower-subreg.c (decompose_multiword_subregs): Likewise.\n\t* lra-lives.c: Likewise.\n\t* lra.c (lra): Likewise.\n\t* modulo-sched.c (schedule_reg_moves): Likewise.\n\t(optimize_sc): Likewise.\n\t(get_sched_window): Likewise.\n\t(sms_schedule_by_order): Likewise.\n\t(check_nodes_order): Likewise.\n\t(order_nodes_of_sccs): Likewise.\n\t(order_nodes_in_scc): Likewise.\n\t* recog.c (split_all_insns): Likewise.\n\t* regcprop.c (pass_cprop_hardreg::execute): Likewise.\n\t* reload1.c (reload): Likewise.\n\t* sched-rgn.c (haifa_find_rgns): Likewise.\n\t(split_edges): Likewise.\n\t(compute_trg_info): Likewise.\n\t* sel-sched.c (init_seqno): Likewise.\n\t* store-motion.c (remove_reachable_equiv_notes): Likewise.\n\t* tree-into-ssa.c (update_ssa): Likewise.\n\t* tree-ssa-live.c (live_worklist): Likewise.\n\t* tree-ssa-loop-im.c (fill_always_executed_in): Likewise.\n\t* tree-ssa-loop-ivcanon.c (try_unroll_loop_completely):\n\t* Likewise.\n\t(try_peel_loop): Likewise.\n\t* tree-ssa-loop-manip.c (tree_transform_and_unroll_loop):\n\t* Likewise.\n\t* tree-ssa-pre.c (compute_antic): Likewise.\n\t* tree-ssa-reassoc.c (undistribute_ops_list): Likewise.\n\t* tree-stdarg.c (reachable_at_most_once): Likewise.\n\t* tree-vect-slp.c (vect_attempt_slp_rearrange_stmts): Likewise.\n\t* var-tracking.c (vt_find_locations): Likewise.\n\nFrom-SVN: r238748", "tree": {"sha": "ff74117885135e87c9fc9ad721f0180a6471bafc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff74117885135e87c9fc9ad721f0180a6471bafc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ba9e72de95e7eece69bfff744df14b866280f9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ba9e72de95e7eece69bfff744df14b866280f9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ba9e72de95e7eece69bfff744df14b866280f9d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ba9e72de95e7eece69bfff744df14b866280f9d/comments", "author": null, "committer": null, "parents": [{"sha": "62e2078514e307bc1b9fecff29977a5476fc7c45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62e2078514e307bc1b9fecff29977a5476fc7c45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62e2078514e307bc1b9fecff29977a5476fc7c45"}], "stats": {"total": 431, "additions": 162, "deletions": 269}, "files": [{"sha": "489d9d7e83e977ad6ea67dd97ae6f6ab78f3785a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7ba9e72de95e7eece69bfff744df14b866280f9d", "patch": "@@ -1,3 +1,66 @@\n+2016-07-26  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n+\n+\t* bt-load.c (compute_out): Use auto_sbitmap class.\n+\t(link_btr_uses): Likewise.\n+\t* cfganal.c (mark_dfs_back_edges): Likewise.\n+\t(post_order_compute): Likewise.\n+\t(inverted_post_order_compute): Likewise.\n+\t(pre_and_rev_post_order_compute_fn): Likewise.\n+\t(single_pred_before_succ_order): Likewise.\n+\t* cfgexpand.c (pass_expand::execute): Likewise.\n+\t* cfgloop.c (verify_loop_structure): Likewise.\n+\t* cfgloopmanip.c (fix_bb_placements): Likewise.\n+\t(remove_path): Likewise.\n+\t(update_dominators_in_loop): Likewise.\n+\t* cfgrtl.c (break_superblocks): Likewise.\n+\t* ddg.c (check_sccs): Likewise.\n+\t(create_ddg_all_sccs): Likewise.\n+\t* df-core.c (df_worklist_dataflow): Likewise.\n+\t* dse.c (dse_step3): Likewise.\n+\t* except.c (eh_region_outermost): Likewise.\n+\t* function.c (thread_prologue_and_epilogue_insns): Likewise.\n+\t* gcse.c (prune_expressions): Likewise.\n+\t(prune_insertions_deletions): Likewise.\n+\t* gimple-ssa-backprop.c (backprop::~backprop): Likewise.\n+\t* graph.c (draw_cfg_nodes_no_loops): Likewise.\n+\t* ira-lives.c (remove_some_program_points_and_update_live_ranges): Likewise.\n+\t* lcm.c (compute_earliest): Likewise.\n+\t(compute_farthest): Likewise.\n+\t* loop-unroll.c (unroll_loop_constant_iterations): Likewise.\n+\t(unroll_loop_runtime_iterations): Likewise.\n+\t(unroll_loop_stupid): Likewise.\n+\t* lower-subreg.c (decompose_multiword_subregs): Likewise.\n+\t* lra-lives.c: Likewise.\n+\t* lra.c (lra): Likewise.\n+\t* modulo-sched.c (schedule_reg_moves): Likewise.\n+\t(optimize_sc): Likewise.\n+\t(get_sched_window): Likewise.\n+\t(sms_schedule_by_order): Likewise.\n+\t(check_nodes_order): Likewise.\n+\t(order_nodes_of_sccs): Likewise.\n+\t(order_nodes_in_scc): Likewise.\n+\t* recog.c (split_all_insns): Likewise.\n+\t* regcprop.c (pass_cprop_hardreg::execute): Likewise.\n+\t* reload1.c (reload): Likewise.\n+\t* sched-rgn.c (haifa_find_rgns): Likewise.\n+\t(split_edges): Likewise.\n+\t(compute_trg_info): Likewise.\n+\t* sel-sched.c (init_seqno): Likewise.\n+\t* store-motion.c (remove_reachable_equiv_notes): Likewise.\n+\t* tree-into-ssa.c (update_ssa): Likewise.\n+\t* tree-ssa-live.c (live_worklist): Likewise.\n+\t* tree-ssa-loop-im.c (fill_always_executed_in): Likewise.\n+\t* tree-ssa-loop-ivcanon.c (try_unroll_loop_completely):\n+\t* Likewise.\n+\t(try_peel_loop): Likewise.\n+\t* tree-ssa-loop-manip.c (tree_transform_and_unroll_loop):\n+\t* Likewise.\n+\t* tree-ssa-pre.c (compute_antic): Likewise.\n+\t* tree-ssa-reassoc.c (undistribute_ops_list): Likewise.\n+\t* tree-stdarg.c (reachable_at_most_once): Likewise.\n+\t* tree-vect-slp.c (vect_attempt_slp_rearrange_stmts): Likewise.\n+\t* var-tracking.c (vt_find_locations): Likewise.\n+\n 2016-07-26  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n \n \t* sbitmap.h (auto_sbitmap): New class."}, {"sha": "5b1bcecd5c3cfe232fc6c8f342fd2cf70a3e5402", "filename": "gcc/bt-load.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=7ba9e72de95e7eece69bfff744df14b866280f9d", "patch": "@@ -626,7 +626,7 @@ compute_out (sbitmap *bb_out, sbitmap *bb_gen, sbitmap *bb_kill, int max_uid)\n      Iterate until the bb_out sets stop growing.  */\n   int i;\n   int changed;\n-  sbitmap bb_in = sbitmap_alloc (max_uid);\n+  auto_sbitmap bb_in (max_uid);\n \n   for (i = NUM_FIXED_BLOCKS; i < last_basic_block_for_fn (cfun); i++)\n     bitmap_copy (bb_out[i], bb_gen[i]);\n@@ -642,15 +642,14 @@ compute_out (sbitmap *bb_out, sbitmap *bb_gen, sbitmap *bb_kill, int max_uid)\n \t\t\t\t\t       bb_in, bb_kill[i]);\n \t}\n     }\n-  sbitmap_free (bb_in);\n }\n \n static void\n link_btr_uses (btr_def **def_array, btr_user **use_array, sbitmap *bb_out,\n \t       sbitmap *btr_defset, int max_uid)\n {\n   int i;\n-  sbitmap reaching_defs = sbitmap_alloc (max_uid);\n+  auto_sbitmap reaching_defs (max_uid);\n \n   /* Link uses to the uses lists of all of their reaching defs.\n      Count up the number of reaching defs of each use.  */\n@@ -683,7 +682,7 @@ link_btr_uses (btr_def **def_array, btr_user **use_array, sbitmap *bb_out,\n \t      if (user != NULL)\n \t\t{\n \t\t  /* Find all the reaching defs for this use.  */\n-\t\t  sbitmap reaching_defs_of_reg = sbitmap_alloc (max_uid);\n+\t\t  auto_sbitmap reaching_defs_of_reg (max_uid);\n \t\t  unsigned int uid = 0;\n \t\t  sbitmap_iterator sbi;\n \n@@ -738,7 +737,6 @@ link_btr_uses (btr_def **def_array, btr_user **use_array, sbitmap *bb_out,\n \t\t      user->next = def->uses;\n \t\t      def->uses = user;\n \t\t    }\n-\t\t  sbitmap_free (reaching_defs_of_reg);\n \t\t}\n \n \t      if (CALL_P (insn))\n@@ -754,7 +752,6 @@ link_btr_uses (btr_def **def_array, btr_user **use_array, sbitmap *bb_out,\n \t    }\n \t}\n     }\n-  sbitmap_free (reaching_defs);\n }\n \n static void"}, {"sha": "931e814e8cf799acd2005d0537430486dbf971e6", "filename": "gcc/cfganal.c", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=7ba9e72de95e7eece69bfff744df14b866280f9d", "patch": "@@ -67,7 +67,6 @@ mark_dfs_back_edges (void)\n   int sp;\n   int prenum = 1;\n   int postnum = 1;\n-  sbitmap visited;\n   bool found = false;\n \n   /* Allocate the preorder and postorder number arrays.  */\n@@ -79,7 +78,7 @@ mark_dfs_back_edges (void)\n   sp = 0;\n \n   /* Allocate bitmap to track nodes that have been visited.  */\n-  visited = sbitmap_alloc (last_basic_block_for_fn (cfun));\n+  auto_sbitmap visited (last_basic_block_for_fn (cfun));\n \n   /* None of the nodes in the CFG have been visited yet.  */\n   bitmap_clear (visited);\n@@ -138,7 +137,6 @@ mark_dfs_back_edges (void)\n   free (pre);\n   free (post);\n   free (stack);\n-  sbitmap_free (visited);\n \n   return found;\n }\n@@ -642,7 +640,6 @@ post_order_compute (int *post_order, bool include_entry_exit,\n   edge_iterator *stack;\n   int sp;\n   int post_order_num = 0;\n-  sbitmap visited;\n   int count;\n \n   if (include_entry_exit)\n@@ -653,7 +650,7 @@ post_order_compute (int *post_order, bool include_entry_exit,\n   sp = 0;\n \n   /* Allocate bitmap to track nodes that have been visited.  */\n-  visited = sbitmap_alloc (last_basic_block_for_fn (cfun));\n+  auto_sbitmap visited (last_basic_block_for_fn (cfun));\n \n   /* None of the nodes in the CFG have been visited yet.  */\n   bitmap_clear (visited);\n@@ -726,7 +723,6 @@ post_order_compute (int *post_order, bool include_entry_exit,\n     }\n \n   free (stack);\n-  sbitmap_free (visited);\n   return post_order_num;\n }\n \n@@ -820,7 +816,6 @@ inverted_post_order_compute (int *post_order,\n   edge_iterator *stack;\n   int sp;\n   int post_order_num = 0;\n-  sbitmap visited;\n \n   if (flag_checking)\n     verify_no_unreachable_blocks ();\n@@ -830,7 +825,7 @@ inverted_post_order_compute (int *post_order,\n   sp = 0;\n \n   /* Allocate bitmap to track nodes that have been visited.  */\n-  visited = sbitmap_alloc (last_basic_block_for_fn (cfun));\n+  auto_sbitmap visited (last_basic_block_for_fn (cfun));\n \n   /* None of the nodes in the CFG have been visited yet.  */\n   bitmap_clear (visited);\n@@ -956,7 +951,6 @@ inverted_post_order_compute (int *post_order,\n   post_order[post_order_num++] = EXIT_BLOCK;\n \n   free (stack);\n-  sbitmap_free (visited);\n   return post_order_num;\n }\n \n@@ -981,7 +975,6 @@ pre_and_rev_post_order_compute_fn (struct function *fn,\n   int sp;\n   int pre_order_num = 0;\n   int rev_post_order_num = n_basic_blocks_for_fn (cfun) - 1;\n-  sbitmap visited;\n \n   /* Allocate stack for back-tracking up CFG.  */\n   stack = XNEWVEC (edge_iterator, n_basic_blocks_for_fn (cfun) + 1);\n@@ -999,7 +992,7 @@ pre_and_rev_post_order_compute_fn (struct function *fn,\n     rev_post_order_num -= NUM_FIXED_BLOCKS;\n \n   /* Allocate bitmap to track nodes that have been visited.  */\n-  visited = sbitmap_alloc (last_basic_block_for_fn (cfun));\n+  auto_sbitmap visited (last_basic_block_for_fn (cfun));\n \n   /* None of the nodes in the CFG have been visited yet.  */\n   bitmap_clear (visited);\n@@ -1056,7 +1049,6 @@ pre_and_rev_post_order_compute_fn (struct function *fn,\n     }\n \n   free (stack);\n-  sbitmap_free (visited);\n \n   if (include_entry_exit)\n     {\n@@ -1569,7 +1561,7 @@ single_pred_before_succ_order (void)\n   basic_block *order = XNEWVEC (basic_block, n_basic_blocks_for_fn (cfun));\n   unsigned n = n_basic_blocks_for_fn (cfun) - NUM_FIXED_BLOCKS;\n   unsigned np, i;\n-  sbitmap visited = sbitmap_alloc (last_basic_block_for_fn (cfun));\n+  auto_sbitmap visited (last_basic_block_for_fn (cfun));\n \n #define MARK_VISITED(BB) (bitmap_set_bit (visited, (BB)->index))\n #define VISITED_P(BB) (bitmap_bit_p (visited, (BB)->index))\n@@ -1603,7 +1595,6 @@ single_pred_before_succ_order (void)\n       n -= np;\n     }\n \n-  sbitmap_free (visited);\n   gcc_assert (n == 0);\n   return order;\n "}, {"sha": "417f0dc16e3774de30d9e98f98cc6f164b7b8e04", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=7ba9e72de95e7eece69bfff744df14b866280f9d", "patch": "@@ -6159,7 +6159,6 @@ unsigned int\n pass_expand::execute (function *fun)\n {\n   basic_block bb, init_block;\n-  sbitmap blocks;\n   edge_iterator ei;\n   edge e;\n   rtx_insn *var_seq, *var_ret_seq;\n@@ -6472,10 +6471,9 @@ pass_expand::execute (function *fun)\n \t}\n     }\n \n-  blocks = sbitmap_alloc (last_basic_block_for_fn (fun));\n+  auto_sbitmap blocks (last_basic_block_for_fn (fun));\n   bitmap_ones (blocks);\n   find_many_sub_basic_blocks (blocks);\n-  sbitmap_free (blocks);\n   purge_all_dead_edges ();\n \n   expand_stack_alignment ();"}, {"sha": "8f531b0c516ad5d6a5a59260446278f6a104ae97", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=7ba9e72de95e7eece69bfff744df14b866280f9d", "patch": "@@ -1312,15 +1312,13 @@ DEBUG_FUNCTION void\n verify_loop_structure (void)\n {\n   unsigned *sizes, i, j;\n-  sbitmap irreds;\n   basic_block bb, *bbs;\n   struct loop *loop;\n   int err = 0;\n   edge e;\n   unsigned num = number_of_loops (cfun);\n   struct loop_exit *exit, *mexit;\n   bool dom_available = dom_info_available_p (CDI_DOMINATORS);\n-  sbitmap visited;\n \n   if (loops_state_satisfies_p (LOOPS_NEED_FIXUP))\n     {\n@@ -1366,7 +1364,7 @@ verify_loop_structure (void)\n       }\n \n   /* Check the recorded loop father and sizes of loops.  */\n-  visited = sbitmap_alloc (last_basic_block_for_fn (cfun));\n+  auto_sbitmap visited (last_basic_block_for_fn (cfun));\n   bitmap_clear (visited);\n   bbs = XNEWVEC (basic_block, n_basic_blocks_for_fn (cfun));\n   FOR_EACH_LOOP (loop, LI_FROM_INNERMOST)\n@@ -1413,7 +1411,6 @@ verify_loop_structure (void)\n \t}\n     }\n   free (bbs);\n-  sbitmap_free (visited);\n \n   /* Check headers and latches.  */\n   FOR_EACH_LOOP (loop, 0)\n@@ -1480,7 +1477,7 @@ verify_loop_structure (void)\n   if (loops_state_satisfies_p (LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS))\n     {\n       /* Record old info.  */\n-      irreds = sbitmap_alloc (last_basic_block_for_fn (cfun));\n+      auto_sbitmap irreds (last_basic_block_for_fn (cfun));\n       FOR_EACH_BB_FN (bb, cfun)\n \t{\n \t  edge_iterator ei;\n@@ -1532,7 +1529,6 @@ verify_loop_structure (void)\n \t      e->flags &= ~(EDGE_ALL_FLAGS + 1);\n \t    }\n \t}\n-      free (irreds);\n     }\n \n   /* Check the recorded loop exits.  */"}, {"sha": "6bd2d8570c15302644a0d66dd5a348bca006f3cd", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=7ba9e72de95e7eece69bfff744df14b866280f9d", "patch": "@@ -181,7 +181,6 @@ fix_bb_placements (basic_block from,\n \t\t   bool *irred_invalidated,\n \t\t   bitmap loop_closed_ssa_invalidated)\n {\n-  sbitmap in_queue;\n   basic_block *queue, *qtop, *qbeg, *qend;\n   struct loop *base_loop, *target_loop;\n   edge e;\n@@ -201,7 +200,7 @@ fix_bb_placements (basic_block from,\n       || from == base_loop->header)\n     return;\n \n-  in_queue = sbitmap_alloc (last_basic_block_for_fn (cfun));\n+  auto_sbitmap in_queue (last_basic_block_for_fn (cfun));\n   bitmap_clear (in_queue);\n   bitmap_set_bit (in_queue, from->index);\n   /* Prevent us from going out of the base_loop.  */\n@@ -292,7 +291,6 @@ fix_bb_placements (basic_block from,\n \t  bitmap_set_bit (in_queue, pred->index);\n \t}\n     }\n-  free (in_queue);\n   free (queue);\n }\n \n@@ -306,7 +304,6 @@ remove_path (edge e)\n   basic_block *rem_bbs, *bord_bbs, from, bb;\n   vec<basic_block> dom_bbs;\n   int i, nrem, n_bord_bbs;\n-  sbitmap seen;\n   bool irred_invalidated = false;\n   edge_iterator ei;\n   struct loop *l, *f;\n@@ -345,7 +342,7 @@ remove_path (edge e)\n \n   n_bord_bbs = 0;\n   bord_bbs = XNEWVEC (basic_block, n_basic_blocks_for_fn (cfun));\n-  seen = sbitmap_alloc (last_basic_block_for_fn (cfun));\n+  auto_sbitmap seen (last_basic_block_for_fn (cfun));\n   bitmap_clear (seen);\n \n   /* Find \"border\" hexes -- i.e. those with predecessor in removed path.  */\n@@ -407,8 +404,6 @@ remove_path (edge e)\n \t  dom_bbs.safe_push (ldom);\n     }\n \n-  free (seen);\n-\n   /* Recount dominators.  */\n   iterate_fix_dominators (CDI_DOMINATORS, dom_bbs, true);\n   dom_bbs.release ();\n@@ -616,11 +611,10 @@ static void\n update_dominators_in_loop (struct loop *loop)\n {\n   vec<basic_block> dom_bbs = vNULL;\n-  sbitmap seen;\n   basic_block *body;\n   unsigned i;\n \n-  seen = sbitmap_alloc (last_basic_block_for_fn (cfun));\n+  auto_sbitmap seen (last_basic_block_for_fn (cfun));\n   bitmap_clear (seen);\n   body = get_loop_body (loop);\n \n@@ -643,7 +637,6 @@ update_dominators_in_loop (struct loop *loop)\n \n   iterate_fix_dominators (CDI_DOMINATORS, dom_bbs, false);\n   free (body);\n-  free (seen);\n   dom_bbs.release ();\n }\n "}, {"sha": "0d335fc6e1661e7314bed032de3ddf9b1981d1e3", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=7ba9e72de95e7eece69bfff744df14b866280f9d", "patch": "@@ -4272,11 +4272,10 @@ cfg_layout_initialize (unsigned int flags)\n void\n break_superblocks (void)\n {\n-  sbitmap superblocks;\n   bool need = false;\n   basic_block bb;\n \n-  superblocks = sbitmap_alloc (last_basic_block_for_fn (cfun));\n+  auto_sbitmap superblocks (last_basic_block_for_fn (cfun));\n   bitmap_clear (superblocks);\n \n   FOR_EACH_BB_FN (bb, cfun)\n@@ -4292,8 +4291,6 @@ break_superblocks (void)\n       rebuild_jump_labels (get_insns ());\n       find_many_sub_basic_blocks (superblocks);\n     }\n-\n-  free (superblocks);\n }\n \n /* Finalize the changes: reorder insn list according to the sequence specified"}, {"sha": "72cf1cf22d996208081f3d5a6d8842b55ee65e0a", "filename": "gcc/ddg.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Fddg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Fddg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.c?ref=7ba9e72de95e7eece69bfff744df14b866280f9d", "patch": "@@ -997,7 +997,7 @@ static void\n check_sccs (ddg_all_sccs_ptr sccs, int num_nodes)\n {\n   int i = 0;\n-  sbitmap tmp = sbitmap_alloc (num_nodes);\n+  auto_sbitmap tmp (num_nodes);\n \n   bitmap_clear (tmp);\n   for (i = 0; i < sccs->num_sccs; i++)\n@@ -1008,7 +1008,6 @@ check_sccs (ddg_all_sccs_ptr sccs, int num_nodes)\n       gcc_assert (!bitmap_intersect_p (tmp, sccs->sccs[i]->nodes));\n       bitmap_ior (tmp, tmp, sccs->sccs[i]->nodes);\n     }\n-  sbitmap_free (tmp);\n }\n \n /* Perform the Strongly Connected Components decomposing algorithm on the\n@@ -1018,9 +1017,9 @@ create_ddg_all_sccs (ddg_ptr g)\n {\n   int i;\n   int num_nodes = g->num_nodes;\n-  sbitmap from = sbitmap_alloc (num_nodes);\n-  sbitmap to = sbitmap_alloc (num_nodes);\n-  sbitmap scc_nodes = sbitmap_alloc (num_nodes);\n+  auto_sbitmap from (num_nodes);\n+  auto_sbitmap to (num_nodes);\n+  auto_sbitmap scc_nodes (num_nodes);\n   ddg_all_sccs_ptr sccs = (ddg_all_sccs_ptr)\n \t\t\t  xmalloc (sizeof (struct ddg_all_sccs));\n \n@@ -1052,9 +1051,6 @@ create_ddg_all_sccs (ddg_ptr g)\n \t}\n     }\n   order_sccs (sccs);\n-  sbitmap_free (from);\n-  sbitmap_free (to);\n-  sbitmap_free (scc_nodes);\n \n   if (flag_checking)\n     check_sccs (sccs, num_nodes);"}, {"sha": "cc18a137996edfdeaad1c6db5e9a1c0cd39c5602", "filename": "gcc/df-core.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=7ba9e72de95e7eece69bfff744df14b866280f9d", "patch": "@@ -1083,7 +1083,6 @@ df_worklist_dataflow (struct dataflow *dataflow,\n                       int n_blocks)\n {\n   bitmap pending = BITMAP_ALLOC (&df_bitmap_obstack);\n-  sbitmap considered = sbitmap_alloc (last_basic_block_for_fn (cfun));\n   bitmap_iterator bi;\n   unsigned int *bbindex_to_postorder;\n   int i;\n@@ -1101,6 +1100,7 @@ df_worklist_dataflow (struct dataflow *dataflow,\n     bbindex_to_postorder[i] = last_basic_block_for_fn (cfun);\n \n   /* Initialize the considered map.  */\n+  auto_sbitmap considered (last_basic_block_for_fn (cfun));\n   bitmap_clear (considered);\n   EXECUTE_IF_SET_IN_BITMAP (blocks_to_consider, 0, index, bi)\n     {\n@@ -1124,7 +1124,6 @@ df_worklist_dataflow (struct dataflow *dataflow,\n \t\t\t\t    blocks_in_postorder,\n \t\t\t\t    bbindex_to_postorder,\n \t\t\t\t    n_blocks);\n-  sbitmap_free (considered);\n   free (bbindex_to_postorder);\n }\n "}, {"sha": "17312c5a5872198705fe7ffb545c1901f565978a", "filename": "gcc/dse.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=7ba9e72de95e7eece69bfff744df14b866280f9d", "patch": "@@ -2999,11 +2999,11 @@ static void\n dse_step3 ()\n {\n   basic_block bb;\n-  sbitmap unreachable_blocks = sbitmap_alloc (last_basic_block_for_fn (cfun));\n   sbitmap_iterator sbi;\n   bitmap all_ones = NULL;\n   unsigned int i;\n \n+  auto_sbitmap unreachable_blocks (last_basic_block_for_fn (cfun));\n   bitmap_ones (unreachable_blocks);\n \n   FOR_ALL_BB_FN (bb, cfun)\n@@ -3058,7 +3058,6 @@ dse_step3 ()\n \n   if (all_ones)\n     BITMAP_FREE (all_ones);\n-  sbitmap_free (unreachable_blocks);\n }\n \n "}, {"sha": "8aeb4e826fcedbabb321f82944411691ef4cc034", "filename": "gcc/except.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=7ba9e72de95e7eece69bfff744df14b866280f9d", "patch": "@@ -634,12 +634,10 @@ eh_region\n eh_region_outermost (struct function *ifun, eh_region region_a,\n \t\t     eh_region region_b)\n {\n-  sbitmap b_outer;\n-\n   gcc_assert (ifun->eh->region_array);\n   gcc_assert (ifun->eh->region_tree);\n \n-  b_outer = sbitmap_alloc (ifun->eh->region_array->length ());\n+  auto_sbitmap b_outer (ifun->eh->region_array->length ());\n   bitmap_clear (b_outer);\n \n   do\n@@ -657,7 +655,6 @@ eh_region_outermost (struct function *ifun, eh_region region_a,\n     }\n   while (region_a);\n \n-  sbitmap_free (b_outer);\n   return region_a;\n }\n \f"}, {"sha": "bba07057a8cf7a2b396650e10579e7b81746c82f", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=7ba9e72de95e7eece69bfff744df14b866280f9d", "patch": "@@ -6018,12 +6018,11 @@ thread_prologue_and_epilogue_insns (void)\n       commit_edge_insertions ();\n \n       /* Look for basic blocks within the prologue insns.  */\n-      sbitmap blocks = sbitmap_alloc (last_basic_block_for_fn (cfun));\n+      auto_sbitmap blocks (last_basic_block_for_fn (cfun));\n       bitmap_clear (blocks);\n       bitmap_set_bit (blocks, entry_edge->dest->index);\n       bitmap_set_bit (blocks, orig_entry_edge->dest->index);\n       find_many_sub_basic_blocks (blocks);\n-      sbitmap_free (blocks);\n     }\n \n   default_rtl_profile ();"}, {"sha": "c2c0e8ec690db96d93c91ecc8e7e69b79498b19a", "filename": "gcc/gcse.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=7ba9e72de95e7eece69bfff744df14b866280f9d", "patch": "@@ -1691,12 +1691,11 @@ free_pre_mem (void)\n static void\n prune_expressions (bool pre_p)\n {\n-  sbitmap prune_exprs;\n   struct gcse_expr *expr;\n   unsigned int ui;\n   basic_block bb;\n \n-  prune_exprs = sbitmap_alloc (expr_hash_table.n_elems);\n+  auto_sbitmap prune_exprs (expr_hash_table.n_elems);\n   bitmap_clear (prune_exprs);\n   for (ui = 0; ui < expr_hash_table.size; ui++)\n     {\n@@ -1767,8 +1766,6 @@ prune_expressions (bool pre_p)\n \t    break;\n \t  }\n     }\n-\n-  sbitmap_free (prune_exprs);\n }\n \n /* It may be necessary to insert a large number of insns on edges to\n@@ -1783,7 +1780,6 @@ static void\n prune_insertions_deletions (int n_elems)\n {\n   sbitmap_iterator sbi;\n-  sbitmap prune_exprs;\n \n   /* We always use I to iterate over blocks/edges and J to iterate over\n      expressions.  */\n@@ -1797,7 +1793,7 @@ prune_insertions_deletions (int n_elems)\n   /* Set of expressions which require too many insertions relative to\n      the number of deletions achieved.  We will prune these out of the\n      insertion/deletion sets.  */\n-  prune_exprs = sbitmap_alloc (n_elems);\n+  auto_sbitmap prune_exprs (n_elems);\n   bitmap_clear (prune_exprs);\n \n   /* Iterate over the edges counting the number of times each expression\n@@ -1835,7 +1831,6 @@ prune_insertions_deletions (int n_elems)\n \tbitmap_clear_bit (pre_delete_map[i], j);\n     }\n \n-  sbitmap_free (prune_exprs);\n   free (insertions);\n   free (deletions);\n }"}, {"sha": "53349e89658ef1af85a4afe332fc4ca7ed295cc4", "filename": "gcc/gimple-ssa-backprop.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Fgimple-ssa-backprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Fgimple-ssa-backprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-backprop.c?ref=7ba9e72de95e7eece69bfff744df14b866280f9d", "patch": "@@ -258,7 +258,7 @@ class backprop\n \n   /* A bitmap of blocks that we have finished processing in the initial\n      post-order walk.  */\n-  sbitmap m_visited_blocks;\n+  auto_sbitmap m_visited_blocks;\n \n   /* A worklist of SSA names whose definitions need to be reconsidered.  */\n   auto_vec <tree, 64> m_worklist;\n@@ -272,7 +272,7 @@ class backprop\n backprop::backprop (function *fn)\n   : m_fn (fn),\n     m_info_pool (\"usage_info\"),\n-    m_visited_blocks (sbitmap_alloc (last_basic_block_for_fn (m_fn))),\n+    m_visited_blocks (last_basic_block_for_fn (m_fn)),\n     m_worklist_names (BITMAP_ALLOC (NULL))\n {\n   bitmap_clear (m_visited_blocks);\n@@ -281,7 +281,6 @@ backprop::backprop (function *fn)\n backprop::~backprop ()\n {\n   BITMAP_FREE (m_worklist_names);\n-  sbitmap_free (m_visited_blocks);\n   m_info_pool.release ();\n }\n "}, {"sha": "d3e2d2ea0a6e3ce51cda98c4b85ca3c856be067e", "filename": "gcc/graph.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Fgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Fgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraph.c?ref=7ba9e72de95e7eece69bfff744df14b866280f9d", "patch": "@@ -156,9 +156,8 @@ draw_cfg_nodes_no_loops (pretty_printer *pp, struct function *fun)\n {\n   int *rpo = XNEWVEC (int, n_basic_blocks_for_fn (fun));\n   int i, n;\n-  sbitmap visited;\n \n-  visited = sbitmap_alloc (last_basic_block_for_fn (cfun));\n+  auto_sbitmap visited (last_basic_block_for_fn (cfun));\n   bitmap_clear (visited);\n \n   n = pre_and_rev_post_order_compute_fn (fun, NULL, rpo, true);\n@@ -179,8 +178,6 @@ draw_cfg_nodes_no_loops (pretty_printer *pp, struct function *fun)\n \tif (! bitmap_bit_p (visited, bb->index))\n \t  draw_cfg_node (pp, fun->funcdef_no, bb);\n     }\n-\n-  sbitmap_free (visited);\n }\n \n /* Draw all the basic blocks in LOOP.  Print the blocks in breath-first"}, {"sha": "ff6d1006802b74529c61b1f1eb7cd77c63709442", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=7ba9e72de95e7eece69bfff744df14b866280f9d", "patch": "@@ -1409,12 +1409,11 @@ remove_some_program_points_and_update_live_ranges (void)\n   ira_object_t obj;\n   ira_object_iterator oi;\n   live_range_t r, prev_r, next_r;\n-  sbitmap born_or_dead, born, dead;\n   sbitmap_iterator sbi;\n   bool born_p, dead_p, prev_born_p, prev_dead_p;\n   \n-  born = sbitmap_alloc (ira_max_point);\n-  dead = sbitmap_alloc (ira_max_point);\n+  auto_sbitmap born (ira_max_point);\n+  auto_sbitmap dead (ira_max_point);\n   bitmap_clear (born);\n   bitmap_clear (dead);\n   FOR_EACH_OBJECT (obj, oi)\n@@ -1425,7 +1424,7 @@ remove_some_program_points_and_update_live_ranges (void)\n \tbitmap_set_bit (dead, r->finish);\n       }\n \n-  born_or_dead = sbitmap_alloc (ira_max_point);\n+  auto_sbitmap born_or_dead (ira_max_point);\n   bitmap_ior (born_or_dead, born, dead);\n   map = (int *) ira_allocate (sizeof (int) * ira_max_point);\n   n = -1;\n@@ -1442,9 +1441,7 @@ remove_some_program_points_and_update_live_ranges (void)\n       prev_born_p = born_p;\n       prev_dead_p = dead_p;\n     }\n-  sbitmap_free (born_or_dead);\n-  sbitmap_free (born);\n-  sbitmap_free (dead);\n+\n   n++;\n   if (internal_flag_ira_verbose > 1 && ira_dump_file != NULL)\n     fprintf (ira_dump_file, \"Compressing live ranges: from %d to %d - %d%%\\n\","}, {"sha": "4754338fea8b2afef605147e4078ea1616025173", "filename": "gcc/lcm.c", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=7ba9e72de95e7eece69bfff744df14b866280f9d", "patch": "@@ -170,15 +170,12 @@ compute_earliest (struct edge_list *edge_list, int n_exprs, sbitmap *antin,\n \t\t  sbitmap *antout, sbitmap *avout, sbitmap *kill,\n \t\t  sbitmap *earliest)\n {\n-  sbitmap difference, temp_bitmap;\n   int x, num_edges;\n   basic_block pred, succ;\n \n   num_edges = NUM_EDGES (edge_list);\n \n-  difference = sbitmap_alloc (n_exprs);\n-  temp_bitmap = sbitmap_alloc (n_exprs);\n-\n+  auto_sbitmap difference (n_exprs), temp_bitmap (n_exprs);\n   for (x = 0; x < num_edges; x++)\n     {\n       pred = INDEX_EDGE_PRED_BB (edge_list, x);\n@@ -199,9 +196,6 @@ compute_earliest (struct edge_list *edge_list, int n_exprs, sbitmap *antin,\n \t    }\n \t}\n     }\n-\n-  sbitmap_free (temp_bitmap);\n-  sbitmap_free (difference);\n }\n \n /* later(p,s) is dependent on the calculation of laterin(p).\n@@ -594,15 +588,12 @@ compute_farthest (struct edge_list *edge_list, int n_exprs,\n \t\t  sbitmap *st_avout, sbitmap *st_avin, sbitmap *st_antin,\n \t\t  sbitmap *kill, sbitmap *farthest)\n {\n-  sbitmap difference, temp_bitmap;\n   int x, num_edges;\n   basic_block pred, succ;\n \n   num_edges = NUM_EDGES (edge_list);\n \n-  difference = sbitmap_alloc (n_exprs);\n-  temp_bitmap = sbitmap_alloc (n_exprs);\n-\n+  auto_sbitmap difference (n_exprs), temp_bitmap (n_exprs);\n   for (x = 0; x < num_edges; x++)\n     {\n       pred = INDEX_EDGE_PRED_BB (edge_list, x);\n@@ -623,9 +614,6 @@ compute_farthest (struct edge_list *edge_list, int n_exprs,\n \t    }\n \t}\n     }\n-\n-  sbitmap_free (temp_bitmap);\n-  sbitmap_free (difference);\n }\n \n /* Compute nearer and nearerout vectors for edge based lcm."}, {"sha": "b568ea56d84a3f43fc03cdbaf1d9dd93fad7480a", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=7ba9e72de95e7eece69bfff744df14b866280f9d", "patch": "@@ -461,7 +461,6 @@ unroll_loop_constant_iterations (struct loop *loop)\n {\n   unsigned HOST_WIDE_INT niter;\n   unsigned exit_mod;\n-  sbitmap wont_exit;\n   unsigned i;\n   edge e;\n   unsigned max_unroll = loop->lpt_decision.times;\n@@ -477,7 +476,7 @@ unroll_loop_constant_iterations (struct loop *loop)\n \n   exit_mod = niter % (max_unroll + 1);\n \n-  wont_exit = sbitmap_alloc (max_unroll + 1);\n+  auto_sbitmap wont_exit (max_unroll + 1);\n   bitmap_ones (wont_exit);\n \n   auto_vec<edge> remove_edges;\n@@ -604,8 +603,6 @@ unroll_loop_constant_iterations (struct loop *loop)\n       free_opt_info (opt_info);\n     }\n \n-  free (wont_exit);\n-\n   if (exit_at_end)\n     {\n       basic_block exit_block = get_bb_copy (desc->in_edge->src);\n@@ -861,7 +858,6 @@ unroll_loop_runtime_iterations (struct loop *loop)\n   rtx_insn *init_code, *branch_code;\n   unsigned i, j, p;\n   basic_block preheader, *body, swtch, ezc_swtch;\n-  sbitmap wont_exit;\n   int may_exit_copy;\n   unsigned n_peel;\n   edge e;\n@@ -936,7 +932,7 @@ unroll_loop_runtime_iterations (struct loop *loop)\n \n   auto_vec<edge> remove_edges;\n \n-  wont_exit = sbitmap_alloc (max_unroll + 2);\n+  auto_sbitmap wont_exit (max_unroll + 2);\n \n   /* Peel the first copy of loop body (almost always we must leave exit test\n      here; the only exception is when we have extra zero check and the number\n@@ -1035,8 +1031,6 @@ unroll_loop_runtime_iterations (struct loop *loop)\n       free_opt_info (opt_info);\n     }\n \n-  free (wont_exit);\n-\n   if (exit_at_end)\n     {\n       basic_block exit_block = get_bb_copy (desc->in_edge->src);\n@@ -1201,7 +1195,6 @@ decide_unroll_stupid (struct loop *loop, int flags)\n static void\n unroll_loop_stupid (struct loop *loop)\n {\n-  sbitmap wont_exit;\n   unsigned nunroll = loop->lpt_decision.times;\n   struct niter_desc *desc = get_simple_loop_desc (loop);\n   struct opt_info *opt_info = NULL;\n@@ -1211,8 +1204,7 @@ unroll_loop_stupid (struct loop *loop)\n       || flag_variable_expansion_in_unroller)\n     opt_info = analyze_insns_in_loop (loop);\n \n-\n-  wont_exit = sbitmap_alloc (nunroll + 1);\n+  auto_sbitmap wont_exit (nunroll + 1);\n   bitmap_clear (wont_exit);\n   opt_info_start_duplication (opt_info);\n \n@@ -1231,8 +1223,6 @@ unroll_loop_stupid (struct loop *loop)\n       free_opt_info (opt_info);\n     }\n \n-  free (wont_exit);\n-\n   if (desc->simple_p)\n     {\n       /* We indeed may get here provided that there are nontrivial assumptions"}, {"sha": "4ea763b1e278c026fd97afc456223bf9fb451277", "filename": "gcc/lower-subreg.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Flower-subreg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Flower-subreg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flower-subreg.c?ref=7ba9e72de95e7eece69bfff744df14b866280f9d", "patch": "@@ -1507,15 +1507,14 @@ decompose_multiword_subregs (bool decompose_copies)\n   bitmap_and_compl_into (decomposable_context, non_decomposable_context);\n   if (!bitmap_empty_p (decomposable_context))\n     {\n-      sbitmap sub_blocks;\n       unsigned int i;\n       sbitmap_iterator sbi;\n       bitmap_iterator iter;\n       unsigned int regno;\n \n       propagate_pseudo_copies ();\n \n-      sub_blocks = sbitmap_alloc (last_basic_block_for_fn (cfun));\n+      auto_sbitmap sub_blocks (last_basic_block_for_fn (cfun));\n       bitmap_clear (sub_blocks);\n \n       EXECUTE_IF_SET_IN_BITMAP (decomposable_context, 0, regno, iter)\n@@ -1643,8 +1642,6 @@ decompose_multiword_subregs (bool decompose_copies)\n \t        insn = NEXT_INSN (insn);\n \t    }\n \t}\n-\n-      sbitmap_free (sub_blocks);\n     }\n \n   {"}, {"sha": "f761da53e459ab8281ea9b2b0a171de018426aaa", "filename": "gcc/lra-lives.c", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Flra-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Flra-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-lives.c?ref=7ba9e72de95e7eece69bfff744df14b866280f9d", "patch": "@@ -1015,12 +1015,11 @@ remove_some_program_points_and_update_live_ranges (void)\n   int n, max_regno;\n   int *map;\n   lra_live_range_t r, prev_r, next_r;\n-  sbitmap born_or_dead, born, dead;\n   sbitmap_iterator sbi;\n   bool born_p, dead_p, prev_born_p, prev_dead_p;\n \n-  born = sbitmap_alloc (lra_live_max_point);\n-  dead = sbitmap_alloc (lra_live_max_point);\n+  auto_sbitmap born (lra_live_max_point);\n+  auto_sbitmap dead (lra_live_max_point);\n   bitmap_clear (born);\n   bitmap_clear (dead);\n   max_regno = max_reg_num ();\n@@ -1033,7 +1032,7 @@ remove_some_program_points_and_update_live_ranges (void)\n \t  bitmap_set_bit (dead, r->finish);\n \t}\n     }\n-  born_or_dead = sbitmap_alloc (lra_live_max_point);\n+  auto_sbitmap born_or_dead (lra_live_max_point);\n   bitmap_ior (born_or_dead, born, dead);\n   map = XCNEWVEC (int, lra_live_max_point);\n   n = -1;\n@@ -1056,9 +1055,6 @@ remove_some_program_points_and_update_live_ranges (void)\n       prev_born_p = born_p;\n       prev_dead_p = dead_p;\n     }\n-  sbitmap_free (born_or_dead);\n-  sbitmap_free (born);\n-  sbitmap_free (dead);\n   n++;\n   if (lra_dump_file != NULL)\n     fprintf (lra_dump_file, \"Compressing live ranges: from %d to %d - %d%%\\n\","}, {"sha": "a63e3933ed13eb813dbb3465b51a6f6b81b2ca4e", "filename": "gcc/lra.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=7ba9e72de95e7eece69bfff744df14b866280f9d", "patch": "@@ -2413,11 +2413,9 @@ lra (FILE *f)\n   /* We've possibly turned single trapping insn into multiple ones.  */\n   if (cfun->can_throw_non_call_exceptions)\n     {\n-      sbitmap blocks;\n-      blocks = sbitmap_alloc (last_basic_block_for_fn (cfun));\n+      auto_sbitmap blocks (last_basic_block_for_fn (cfun));\n       bitmap_ones (blocks);\n       find_many_sub_basic_blocks (blocks);\n-      sbitmap_free (blocks);\n     }\n \n   if (inserted_p)"}, {"sha": "6e87a6f260711cbb59ad05dcae2bb04bb4e6f411", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 24, "deletions": 54, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=7ba9e72de95e7eece69bfff744df14b866280f9d", "patch": "@@ -682,7 +682,6 @@ schedule_reg_moves (partial_schedule_ptr ps)\n       rtx prev_reg, old_reg;\n       int first_move;\n       int distances[2];\n-      sbitmap must_follow;\n       sbitmap distance1_uses;\n       rtx set = single_set (u->insn);\n       \n@@ -792,12 +791,11 @@ schedule_reg_moves (partial_schedule_ptr ps)\n \t      }\n \t  }\n \n-      must_follow = sbitmap_alloc (first_move + nreg_moves);\n+      auto_sbitmap must_follow (first_move + nreg_moves);\n       for (i_reg_move = 0; i_reg_move < nreg_moves; i_reg_move++)\n \tif (!schedule_reg_move (ps, first_move + i_reg_move,\n \t\t\t\tdistance1_uses, must_follow))\n \t  break;\n-      sbitmap_free (must_follow);\n       if (distance1_uses)\n \tsbitmap_free (distance1_uses);\n       if (i_reg_move < nreg_moves)\n@@ -927,7 +925,6 @@ static bool\n optimize_sc (partial_schedule_ptr ps, ddg_ptr g)\n {\n   int amount = PS_MIN_CYCLE (ps);\n-  sbitmap sched_nodes = sbitmap_alloc (g->num_nodes);\n   int start, end, step;\n   int ii = ps->ii;\n   bool ok = false;\n@@ -944,8 +941,7 @@ optimize_sc (partial_schedule_ptr ps, ddg_ptr g)\n       if (dump_file)\n \tfprintf (dump_file, \"SMS SC already optimized.\\n\");\n \n-      ok = false;\n-      goto clear;\n+      return false;\n     }\n \n   if (dump_file)\n@@ -967,11 +963,9 @@ optimize_sc (partial_schedule_ptr ps, ddg_ptr g)\n     }\n \n   if (SMODULO (SCHED_TIME (g->closing_branch->cuid), ii) == ii - 1)\n-    {\n-      ok = true;\n-      goto clear;\n-    }\n+    return true;\n \n+  auto_sbitmap sched_nodes (g->num_nodes);\n   bitmap_ones (sched_nodes);\n \n   /* Calculate the new placement of the branch.  It should be in row\n@@ -984,7 +978,7 @@ optimize_sc (partial_schedule_ptr ps, ddg_ptr g)\n       int branch_cycle = SCHED_TIME (g->closing_branch->cuid);\n       int row = SMODULO (branch_cycle, ps->ii);\n       int num_splits = 0;\n-      sbitmap must_precede, must_follow, tmp_precede, tmp_follow;\n+      sbitmap tmp_precede, tmp_follow;\n       int min_cycle, c;\n \n       if (dump_file)\n@@ -1000,11 +994,10 @@ optimize_sc (partial_schedule_ptr ps, ddg_ptr g)\n \t  gcc_assert (c >= start);\n \t  if (c >= end)\n \t    {\n-\t      ok = false;\n \t      if (dump_file)\n \t\tfprintf (dump_file,\n \t\t\t \"SMS failed to schedule branch at cycle: %d\\n\", c);\n-\t      goto clear;\n+\t      return false;\n \t    }\n \t}\n       else\n@@ -1017,13 +1010,12 @@ optimize_sc (partial_schedule_ptr ps, ddg_ptr g)\n \t      if (dump_file)\n \t\tfprintf (dump_file,\n \t\t\t \"SMS failed to schedule branch at cycle: %d\\n\", c);\n-\t      ok = false;\n-\t      goto clear;\n+\t      return false;\n \t    }\n \t}\n \n-      must_precede = sbitmap_alloc (g->num_nodes);\n-      must_follow = sbitmap_alloc (g->num_nodes);\n+      auto_sbitmap must_precede (g->num_nodes);\n+      auto_sbitmap must_follow (g->num_nodes);\n \n       /* Try to schedule the branch is it's new cycle.  */\n       calculate_must_precede_follow (g->closing_branch, start, end,\n@@ -1083,13 +1075,8 @@ optimize_sc (partial_schedule_ptr ps, ddg_ptr g)\n       /* This might have been added to a new first stage.  */\n       if (PS_MIN_CYCLE (ps) < min_cycle)\n \treset_sched_times (ps, 0);\n-\n-      free (must_precede);\n-      free (must_follow);\n     }\n \n-clear:\n-  free (sched_nodes);\n   return ok;\n }\n \n@@ -1866,8 +1853,8 @@ get_sched_window (partial_schedule_ptr ps, ddg_node_ptr u_node,\n   int start, step, end;\n   int early_start, late_start;\n   ddg_edge_ptr e;\n-  sbitmap psp = sbitmap_alloc (ps->g->num_nodes);\n-  sbitmap pss = sbitmap_alloc (ps->g->num_nodes);\n+  auto_sbitmap psp (ps->g->num_nodes);\n+  auto_sbitmap pss (ps->g->num_nodes);\n   sbitmap u_node_preds = NODE_PREDECESSORS (u_node);\n   sbitmap u_node_succs = NODE_SUCCESSORS (u_node);\n   int psp_not_empty;\n@@ -1996,8 +1983,6 @@ get_sched_window (partial_schedule_ptr ps, ddg_node_ptr u_node,\n   *start_p = start;\n   *step_p = step;\n   *end_p = end;\n-  sbitmap_free (psp);\n-  sbitmap_free (pss);\n \n   if ((start >= end && step == 1) || (start <= end && step == -1))\n     {\n@@ -2146,10 +2131,10 @@ sms_schedule_by_order (ddg_ptr g, int mii, int maxii, int *nodes_order)\n   int flush_and_start_over = true;\n   int num_nodes = g->num_nodes;\n   int start, end, step; /* Place together into one struct?  */\n-  sbitmap sched_nodes = sbitmap_alloc (num_nodes);\n-  sbitmap must_precede = sbitmap_alloc (num_nodes);\n-  sbitmap must_follow = sbitmap_alloc (num_nodes);\n-  sbitmap tobe_scheduled = sbitmap_alloc (num_nodes);\n+  auto_sbitmap sched_nodes (num_nodes);\n+  auto_sbitmap must_precede (num_nodes);\n+  auto_sbitmap must_follow (num_nodes);\n+  auto_sbitmap tobe_scheduled (num_nodes);\n \n   partial_schedule_ptr ps = create_partial_schedule (ii, g, DFA_HISTORY);\n \n@@ -2260,11 +2245,6 @@ sms_schedule_by_order (ddg_ptr g, int mii, int maxii, int *nodes_order)\n   else\n     gcc_assert (bitmap_equal_p (tobe_scheduled, sched_nodes));\n \n-  sbitmap_free (sched_nodes);\n-  sbitmap_free (must_precede);\n-  sbitmap_free (must_follow);\n-  sbitmap_free (tobe_scheduled);\n-\n   return ps;\n }\n \n@@ -2474,7 +2454,7 @@ static void\n check_nodes_order (int *node_order, int num_nodes)\n {\n   int i;\n-  sbitmap tmp = sbitmap_alloc (num_nodes);\n+  auto_sbitmap tmp (num_nodes);\n \n   bitmap_clear (tmp);\n \n@@ -2494,8 +2474,6 @@ check_nodes_order (int *node_order, int num_nodes)\n \n   if (dump_file)\n     fprintf (dump_file, \"\\n\");\n-\n-  sbitmap_free (tmp);\n }\n \n /* Order the nodes of G for scheduling and pass the result in\n@@ -2539,10 +2517,10 @@ order_nodes_of_sccs (ddg_all_sccs_ptr all_sccs, int * node_order)\n   int i, pos = 0;\n   ddg_ptr g = all_sccs->ddg;\n   int num_nodes = g->num_nodes;\n-  sbitmap prev_sccs = sbitmap_alloc (num_nodes);\n-  sbitmap on_path = sbitmap_alloc (num_nodes);\n-  sbitmap tmp = sbitmap_alloc (num_nodes);\n-  sbitmap ones = sbitmap_alloc (num_nodes);\n+  auto_sbitmap prev_sccs (num_nodes);\n+  auto_sbitmap on_path (num_nodes);\n+  auto_sbitmap tmp (num_nodes);\n+  auto_sbitmap ones (num_nodes);\n \n   bitmap_clear (prev_sccs);\n   bitmap_ones (ones);\n@@ -2575,10 +2553,6 @@ order_nodes_of_sccs (ddg_all_sccs_ptr all_sccs, int * node_order)\n       bitmap_and_compl (tmp, ones, prev_sccs);\n       pos = order_nodes_in_scc (g, prev_sccs, tmp, node_order, pos);\n     }\n-  sbitmap_free (prev_sccs);\n-  sbitmap_free (on_path);\n-  sbitmap_free (tmp);\n-  sbitmap_free (ones);\n }\n \n /* MII is needed if we consider backarcs (that do not close recursive cycles).  */\n@@ -2739,11 +2713,11 @@ order_nodes_in_scc (ddg_ptr g, sbitmap nodes_ordered, sbitmap scc,\n {\n   enum sms_direction dir;\n   int num_nodes = g->num_nodes;\n-  sbitmap workset = sbitmap_alloc (num_nodes);\n-  sbitmap tmp = sbitmap_alloc (num_nodes);\n+  auto_sbitmap workset (num_nodes);\n+  auto_sbitmap tmp (num_nodes);\n   sbitmap zero_bitmap = sbitmap_alloc (num_nodes);\n-  sbitmap predecessors = sbitmap_alloc (num_nodes);\n-  sbitmap successors = sbitmap_alloc (num_nodes);\n+  auto_sbitmap predecessors (num_nodes);\n+  auto_sbitmap successors (num_nodes);\n \n   bitmap_clear (predecessors);\n   find_predecessors (predecessors, g, nodes_ordered);\n@@ -2823,11 +2797,7 @@ order_nodes_in_scc (ddg_ptr g, sbitmap nodes_ordered, sbitmap scc,\n \t  bitmap_and (workset, successors, scc);\n \t}\n     }\n-  sbitmap_free (tmp);\n-  sbitmap_free (workset);\n   sbitmap_free (zero_bitmap);\n-  sbitmap_free (predecessors);\n-  sbitmap_free (successors);\n   return pos;\n }\n "}, {"sha": "f425e47f498f9407e92fde4ca50803575299bc4e", "filename": "gcc/recog.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=7ba9e72de95e7eece69bfff744df14b866280f9d", "patch": "@@ -2935,11 +2935,10 @@ split_insn (rtx_insn *insn)\n void\n split_all_insns (void)\n {\n-  sbitmap blocks;\n   bool changed;\n   basic_block bb;\n \n-  blocks = sbitmap_alloc (last_basic_block_for_fn (cfun));\n+  auto_sbitmap blocks (last_basic_block_for_fn (cfun));\n   bitmap_clear (blocks);\n   changed = false;\n \n@@ -2989,8 +2988,6 @@ split_all_insns (void)\n     find_many_sub_basic_blocks (blocks);\n \n   checking_verify_flow_info ();\n-\n-  sbitmap_free (blocks);\n }\n \n /* Same as split_all_insns, but do not expect CFG to be available."}, {"sha": "14983001c5d05a89b42f50ed2dccf0eb192cde34", "filename": "gcc/regcprop.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Fregcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Fregcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregcprop.c?ref=7ba9e72de95e7eece69bfff744df14b866280f9d", "patch": "@@ -1238,12 +1238,11 @@ pass_cprop_hardreg::execute (function *fun)\n {\n   struct value_data *all_vd;\n   basic_block bb;\n-  sbitmap visited;\n   bool analyze_called = false;\n \n   all_vd = XNEWVEC (struct value_data, last_basic_block_for_fn (fun));\n \n-  visited = sbitmap_alloc (last_basic_block_for_fn (fun));\n+  auto_sbitmap visited (last_basic_block_for_fn (fun));\n   bitmap_clear (visited);\n \n   FOR_EACH_BB_FN (bb, fun)\n@@ -1308,7 +1307,6 @@ pass_cprop_hardreg::execute (function *fun)\n       queued_debug_insn_change_pool.release ();\n     }\n \n-  sbitmap_free (visited);\n   free (all_vd);\n   return 0;\n }"}, {"sha": "ce042bf69c51864cfe1938829b78070517cc3069", "filename": "gcc/reload1.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=7ba9e72de95e7eece69bfff744df14b866280f9d", "patch": "@@ -1280,11 +1280,9 @@ reload (rtx_insn *first, int global)\n   /* We've possibly turned single trapping insn into multiple ones.  */\n   if (cfun->can_throw_non_call_exceptions)\n     {\n-      sbitmap blocks;\n-      blocks = sbitmap_alloc (last_basic_block_for_fn (cfun));\n+      auto_sbitmap blocks (last_basic_block_for_fn (cfun));\n       bitmap_ones (blocks);\n       find_many_sub_basic_blocks (blocks);\n-      sbitmap_free (blocks);\n     }\n \n   if (inserted)"}, {"sha": "bfb8d8f97eded2750716f386d5aa305b8cdc3f3b", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 10, "deletions": 26, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=7ba9e72de95e7eece69bfff744df14b866280f9d", "patch": "@@ -623,18 +623,6 @@ haifa_find_rgns (void)\n   int too_large_failure;\n   basic_block bb;\n \n-  /* Note if a block is a natural loop header.  */\n-  sbitmap header;\n-\n-  /* Note if a block is a natural inner loop header.  */\n-  sbitmap inner;\n-\n-  /* Note if a block is in the block queue.  */\n-  sbitmap in_queue;\n-\n-  /* Note if a block is in the block queue.  */\n-  sbitmap in_stack;\n-\n   /* Perform a DFS traversal of the cfg.  Identify loop headers, inner loops\n      and a mapping from block to its loop header (if the block is contained\n      in a loop, else -1).\n@@ -649,16 +637,20 @@ haifa_find_rgns (void)\n   dfs_nr = XCNEWVEC (int, last_basic_block_for_fn (cfun));\n   stack = XNEWVEC (edge_iterator, n_edges_for_fn (cfun));\n \n-  inner = sbitmap_alloc (last_basic_block_for_fn (cfun));\n+  /* Note if a block is a natural inner loop header.  */\n+  auto_sbitmap inner (last_basic_block_for_fn (cfun));\n   bitmap_ones (inner);\n \n-  header = sbitmap_alloc (last_basic_block_for_fn (cfun));\n+  /* Note if a block is a natural loop header.  */\n+  auto_sbitmap header (last_basic_block_for_fn (cfun));\n   bitmap_clear (header);\n \n-  in_queue = sbitmap_alloc (last_basic_block_for_fn (cfun));\n+  /* Note if a block is in the block queue.  */\n+  auto_sbitmap in_queue (last_basic_block_for_fn (cfun));\n   bitmap_clear (in_queue);\n \n-  in_stack = sbitmap_alloc (last_basic_block_for_fn (cfun));\n+  /* Note if a block is in the block queue.  */\n+  auto_sbitmap in_stack (last_basic_block_for_fn (cfun));\n   bitmap_clear (in_stack);\n \n   for (i = 0; i < last_basic_block_for_fn (cfun); i++)\n@@ -1070,10 +1062,6 @@ haifa_find_rgns (void)\n   free (max_hdr);\n   free (degree);\n   free (stack);\n-  sbitmap_free (header);\n-  sbitmap_free (inner);\n-  sbitmap_free (in_queue);\n-  sbitmap_free (in_stack);\n }\n \n \n@@ -1477,12 +1465,11 @@ compute_dom_prob_ps (int bb)\n static void\n split_edges (int bb_src, int bb_trg, edgelst *bl)\n {\n-  sbitmap src = sbitmap_alloc (SBITMAP_SIZE (pot_split[bb_src]));\n+  auto_sbitmap src (SBITMAP_SIZE (pot_split[bb_src]));\n   bitmap_copy (src, pot_split[bb_src]);\n \n   bitmap_and_compl (src, src, pot_split[bb_trg]);\n   extract_edgelst (src, bl);\n-  sbitmap_free (src);\n }\n \n /* Find the valid candidate-source-blocks for the target block TRG, compute\n@@ -1496,7 +1483,6 @@ compute_trg_info (int trg)\n   edgelst el = { NULL, 0 };\n   int i, j, k, update_idx;\n   basic_block block;\n-  sbitmap visited;\n   edge_iterator ei;\n   edge e;\n \n@@ -1519,7 +1505,7 @@ compute_trg_info (int trg)\n   sp->is_speculative = 0;\n   sp->src_prob = REG_BR_PROB_BASE;\n \n-  visited = sbitmap_alloc (last_basic_block_for_fn (cfun));\n+  auto_sbitmap visited (last_basic_block_for_fn (cfun));\n \n   for (i = trg + 1; i < current_nr_blocks; i++)\n     {\n@@ -1595,8 +1581,6 @@ compute_trg_info (int trg)\n \t  sp->src_prob = 0;\n \t}\n     }\n-\n-  sbitmap_free (visited);\n }\n \n /* Free the computed target info.  */"}, {"sha": "25a100ee34f6ceaceda2814ae281cadf8b29e688", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=7ba9e72de95e7eece69bfff744df14b866280f9d", "patch": "@@ -6764,11 +6764,10 @@ init_seqno_1 (basic_block bb, sbitmap visited_bbs, bitmap blocks_to_reschedule)\n static int\n init_seqno (bitmap blocks_to_reschedule, basic_block from)\n {\n-  sbitmap visited_bbs;\n   bitmap_iterator bi;\n   unsigned bbi;\n \n-  visited_bbs = sbitmap_alloc (current_nr_blocks);\n+  auto_sbitmap visited_bbs (current_nr_blocks);\n \n   if (blocks_to_reschedule)\n     {\n@@ -6793,7 +6792,6 @@ init_seqno (bitmap blocks_to_reschedule, basic_block from)\n      removed by the call to purge_empty_blocks in sel_sched_region_1).  */\n   gcc_assert (cur_seqno >= 0);\n \n-  sbitmap_free (visited_bbs);\n   return sched_max_luid - 1;\n }\n "}, {"sha": "1d504e794e4cb94d3eef32e819772be62b501650", "filename": "gcc/store-motion.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Fstore-motion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Fstore-motion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstore-motion.c?ref=7ba9e72de95e7eece69bfff744df14b866280f9d", "patch": "@@ -825,7 +825,7 @@ remove_reachable_equiv_notes (basic_block bb, struct st_expr *smexpr)\n   edge_iterator *stack, ei;\n   int sp;\n   edge act;\n-  sbitmap visited = sbitmap_alloc (last_basic_block_for_fn (cfun));\n+  auto_sbitmap visited (last_basic_block_for_fn (cfun));\n   rtx note;\n   rtx_insn *insn;\n   rtx mem = smexpr->pattern;\n@@ -844,7 +844,6 @@ remove_reachable_equiv_notes (basic_block bb, struct st_expr *smexpr)\n \t  if (!sp)\n \t    {\n \t      free (stack);\n-\t      sbitmap_free (visited);\n \t      return;\n \t    }\n \t  act = ei_edge (stack[--sp]);"}, {"sha": "ec522f1ef0633f9b96abefbd3726d35f5b323d80", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=7ba9e72de95e7eece69bfff744df14b866280f9d", "patch": "@@ -3322,12 +3322,11 @@ update_ssa (unsigned update_flags)\n \t     will grow while we are traversing it (but it will not\n \t     gain any new members).  Copy OLD_SSA_NAMES to a temporary\n \t     for traversal.  */\n-\t  sbitmap tmp = sbitmap_alloc (SBITMAP_SIZE (old_ssa_names));\n+\t  auto_sbitmap tmp (SBITMAP_SIZE (old_ssa_names));\n \t  bitmap_copy (tmp, old_ssa_names);\n \t  EXECUTE_IF_SET_IN_BITMAP (tmp, 0, i, sbi)\n \t    insert_updated_phi_nodes_for (ssa_name (i), dfs, blocks_to_update,\n \t                                  update_flags);\n-\t  sbitmap_free (tmp);\n \t}\n \n       symbols_to_rename.qsort (insert_updated_phi_nodes_compare_uids);"}, {"sha": "72ee4e3cef1a884abc7a812fdff16da7824ffbc7", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=7ba9e72de95e7eece69bfff744df14b866280f9d", "patch": "@@ -975,7 +975,7 @@ live_worklist (tree_live_info_p live)\n {\n   unsigned b;\n   basic_block bb;\n-  sbitmap visited = sbitmap_alloc (last_basic_block_for_fn (cfun) + 1);\n+  auto_sbitmap visited (last_basic_block_for_fn (cfun) + 1);\n \n   bitmap_clear (visited);\n \n@@ -990,8 +990,6 @@ live_worklist (tree_live_info_p live)\n       b = *--(live->stack_top);\n       loe_visit_block (live, BASIC_BLOCK_FOR_FN (cfun, b), visited);\n     }\n-\n-  sbitmap_free (visited);\n }\n \n "}, {"sha": "c5aaef325052a5ad9f414803fb67853ec7ac4887", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=7ba9e72de95e7eece69bfff744df14b866280f9d", "patch": "@@ -2409,10 +2409,10 @@ fill_always_executed_in_1 (struct loop *loop, sbitmap contains_call)\n static void\n fill_always_executed_in (void)\n {\n-  sbitmap contains_call = sbitmap_alloc (last_basic_block_for_fn (cfun));\n   basic_block bb;\n   struct loop *loop;\n \n+  auto_sbitmap contains_call (last_basic_block_for_fn (cfun));\n   bitmap_clear (contains_call);\n   FOR_EACH_BB_FN (bb, cfun)\n     {\n@@ -2429,8 +2429,6 @@ fill_always_executed_in (void)\n \n   for (loop = current_loops->tree_root->inner; loop; loop = loop->next)\n     fill_always_executed_in_1 (loop, contains_call);\n-\n-  sbitmap_free (contains_call);\n }\n \n "}, {"sha": "beb65b04e29eb39df32cf6c0c51d4ad15bfb0692", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=7ba9e72de95e7eece69bfff744df14b866280f9d", "patch": "@@ -743,7 +743,6 @@ try_unroll_loop_completely (struct loop *loop,\n \n   if (n_unroll)\n     {\n-      sbitmap wont_exit;\n       bool large;\n       if (ul == UL_SINGLE_ITER)\n \treturn false;\n@@ -860,7 +859,7 @@ try_unroll_loop_completely (struct loop *loop,\n                        \"loop turned into non-loop; it never loops.\\n\");\n \n       initialize_original_copy_tables ();\n-      wont_exit = sbitmap_alloc (n_unroll + 1);\n+      auto_sbitmap wont_exit (n_unroll + 1);\n       if (exit && niter\n \t  && TREE_CODE (niter) == INTEGER_CST\n \t  && wi::leu_p (n_unroll, wi::to_widest (niter)))\n@@ -883,13 +882,11 @@ try_unroll_loop_completely (struct loop *loop,\n \t\t\t\t\t\t | DLTHE_FLAG_COMPLETTE_PEEL))\n \t{\n           free_original_copy_tables ();\n-\t  free (wont_exit);\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file, \"Failed to duplicate the loop\\n\");\n \t  return false;\n \t}\n \n-      free (wont_exit);\n       free_original_copy_tables ();\n     }\n \n@@ -967,7 +964,6 @@ try_peel_loop (struct loop *loop,\n   HOST_WIDE_INT npeel;\n   struct loop_size size;\n   int peeled_size;\n-  sbitmap wont_exit;\n \n   if (!flag_peel_loops || PARAM_VALUE (PARAM_MAX_PEEL_TIMES) <= 0\n       || !peeled_loops)\n@@ -1042,7 +1038,7 @@ try_peel_loop (struct loop *loop,\n \n   /* Duplicate possibly eliminating the exits.  */\n   initialize_original_copy_tables ();\n-  wont_exit = sbitmap_alloc (npeel + 1);\n+  auto_sbitmap wont_exit (npeel + 1);\n   if (exit && niter\n       && TREE_CODE (niter) == INTEGER_CST\n       && wi::leu_p (npeel, wi::to_widest (niter)))\n@@ -1061,10 +1057,8 @@ try_peel_loop (struct loop *loop,\n \t\t\t\t\t     DLTHE_FLAG_UPDATE_FREQ))\n     {\n       free_original_copy_tables ();\n-      free (wont_exit);\n       return false;\n     }\n-  free (wont_exit);\n   free_original_copy_tables ();\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {"}, {"sha": "f2d3492caf1e0331c76cf36263949ccc7bd7ca8d", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=7ba9e72de95e7eece69bfff744df14b866280f9d", "patch": "@@ -1173,7 +1173,6 @@ tree_transform_and_unroll_loop (struct loop *loop, unsigned factor,\n   unsigned est_niter, prob_entry, scale_unrolled, scale_rest, freq_e, freq_h;\n   unsigned new_est_niter, i, prob;\n   unsigned irr = loop_preheader_edge (loop)->flags & EDGE_IRREDUCIBLE_LOOP;\n-  sbitmap wont_exit;\n   auto_vec<edge> to_remove;\n \n   est_niter = expected_loop_iterations (loop);\n@@ -1307,14 +1306,13 @@ tree_transform_and_unroll_loop (struct loop *loop, unsigned factor,\n \n   /* Unroll the loop and remove the exits in all iterations except for the\n      last one.  */\n-  wont_exit = sbitmap_alloc (factor);\n+  auto_sbitmap wont_exit (factor);\n   bitmap_ones (wont_exit);\n   bitmap_clear_bit (wont_exit, factor - 1);\n \n   ok = gimple_duplicate_loop_to_header_edge\n \t  (loop, loop_latch_edge (loop), factor - 1,\n \t   wont_exit, new_exit, &to_remove, DLTHE_FLAG_UPDATE_FREQ);\n-  free (wont_exit);\n   gcc_assert (ok);\n \n   FOR_EACH_VEC_ELT (to_remove, i, e)"}, {"sha": "c2c7495d02d912c2f664bdcb4cc4e5ef545e021b", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=7ba9e72de95e7eece69bfff744df14b866280f9d", "patch": "@@ -2359,7 +2359,7 @@ compute_antic (void)\n   int *postorder = XNEWVEC (int, n_basic_blocks_for_fn (cfun));\n   int postorder_num = inverted_post_order_compute (postorder);\n \n-  sbitmap worklist = sbitmap_alloc (last_basic_block_for_fn (cfun) + 1);\n+  auto_sbitmap worklist (last_basic_block_for_fn (cfun) + 1);\n   bitmap_ones (worklist);\n   while (changed)\n     {\n@@ -2409,7 +2409,6 @@ compute_antic (void)\n     }\n \n   sbitmap_free (has_abnormal_preds);\n-  sbitmap_free (worklist);\n   free (postorder);\n }\n "}, {"sha": "7c7136e710f77efa148c823f3ff2a0f7916157b7", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=7ba9e72de95e7eece69bfff744df14b866280f9d", "patch": "@@ -1458,7 +1458,6 @@ undistribute_ops_list (enum tree_code opcode,\n   unsigned int length = ops->length ();\n   operand_entry *oe1;\n   unsigned i, j;\n-  sbitmap candidates, candidates2;\n   unsigned nr_candidates, nr_candidates2;\n   sbitmap_iterator sbi0;\n   vec<operand_entry *> *subops;\n@@ -1470,7 +1469,7 @@ undistribute_ops_list (enum tree_code opcode,\n     return false;\n \n   /* Build a list of candidates to process.  */\n-  candidates = sbitmap_alloc (length);\n+  auto_sbitmap candidates (length);\n   bitmap_clear (candidates);\n   nr_candidates = 0;\n   FOR_EACH_VEC_ELT (*ops, i, oe1)\n@@ -1494,10 +1493,7 @@ undistribute_ops_list (enum tree_code opcode,\n     }\n \n   if (nr_candidates < 2)\n-    {\n-      sbitmap_free (candidates);\n-      return false;\n-    }\n+    return false;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -1569,7 +1565,7 @@ undistribute_ops_list (enum tree_code opcode,\n     }\n \n   /* Process the (operand, code) pairs in order of most occurrence.  */\n-  candidates2 = sbitmap_alloc (length);\n+  auto_sbitmap candidates2 (length);\n   while (!cvec.is_empty ())\n     {\n       oecount *c = &cvec.last ();\n@@ -1665,8 +1661,6 @@ undistribute_ops_list (enum tree_code opcode,\n     subops[i].release ();\n   free (subops);\n   cvec.release ();\n-  sbitmap_free (candidates);\n-  sbitmap_free (candidates2);\n \n   return changed;\n }"}, {"sha": "f72a60b9362ce74122d7f601277661a42da8290e", "filename": "gcc/tree-stdarg.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Ftree-stdarg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Ftree-stdarg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-stdarg.c?ref=7ba9e72de95e7eece69bfff744df14b866280f9d", "patch": "@@ -56,7 +56,6 @@ reachable_at_most_once (basic_block va_arg_bb, basic_block va_start_bb)\n   auto_vec<edge, 10> stack;\n   edge e;\n   edge_iterator ei;\n-  sbitmap visited;\n   bool ret;\n \n   if (va_arg_bb == va_start_bb)\n@@ -65,7 +64,7 @@ reachable_at_most_once (basic_block va_arg_bb, basic_block va_start_bb)\n   if (! dominated_by_p (CDI_DOMINATORS, va_arg_bb, va_start_bb))\n     return false;\n \n-  visited = sbitmap_alloc (last_basic_block_for_fn (cfun));\n+  auto_sbitmap visited (last_basic_block_for_fn (cfun));\n   bitmap_clear (visited);\n   ret = true;\n \n@@ -105,7 +104,6 @@ reachable_at_most_once (basic_block va_arg_bb, basic_block va_start_bb)\n \t}\n     }\n \n-  sbitmap_free (visited);\n   return ret;\n }\n "}, {"sha": "fb325d54f1084461d44cd54a98e5b7f99541a188", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=7ba9e72de95e7eece69bfff744df14b866280f9d", "patch": "@@ -1274,7 +1274,6 @@ vect_attempt_slp_rearrange_stmts (slp_instance slp_instn)\n {\n   unsigned int group_size = SLP_INSTANCE_GROUP_SIZE (slp_instn);\n   unsigned int i, j;\n-  sbitmap load_index;\n   unsigned int lidx;\n   slp_tree node, load;\n \n@@ -1294,29 +1293,20 @@ vect_attempt_slp_rearrange_stmts (slp_instance slp_instn)\n \n   /* Check that the loads in the first sequence are different and there\n      are no gaps between them.  */\n-  load_index = sbitmap_alloc (group_size);\n+  auto_sbitmap load_index (group_size);\n   bitmap_clear (load_index);\n   FOR_EACH_VEC_ELT (node->load_permutation, i, lidx)\n     {\n       if (lidx >= group_size)\n-\t{\n-\t  sbitmap_free (load_index);\n-\t  return false;\n-\t}\n+\treturn false;\n       if (bitmap_bit_p (load_index, lidx))\n-\t{\n-\t  sbitmap_free (load_index);\n-\t  return false;\n-\t}\n+\treturn false;\n+\n       bitmap_set_bit (load_index, lidx);\n     }\n   for (i = 0; i < group_size; i++)\n     if (!bitmap_bit_p (load_index, i))\n-      {\n-\tsbitmap_free (load_index);\n-\treturn false;\n-      }\n-  sbitmap_free (load_index);\n+      return false;\n \n   /* This permutation is valid for reduction.  Since the order of the\n      statements in the nodes is not important unless they are memory"}, {"sha": "90889786011217bcc2bd6c4af0c5c9e039f2a6e6", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ba9e72de95e7eece69bfff744df14b866280f9d/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=7ba9e72de95e7eece69bfff744df14b866280f9d", "patch": "@@ -6996,7 +6996,7 @@ vt_find_locations (void)\n {\n   bb_heap_t *worklist = new bb_heap_t (LONG_MIN);\n   bb_heap_t *pending = new bb_heap_t (LONG_MIN);\n-  sbitmap visited, in_worklist, in_pending;\n+  sbitmap in_worklist, in_pending;\n   basic_block bb;\n   edge e;\n   int *bb_order;\n@@ -7016,7 +7016,7 @@ vt_find_locations (void)\n     bb_order[rc_order[i]] = i;\n   free (rc_order);\n \n-  visited = sbitmap_alloc (last_basic_block_for_fn (cfun));\n+  auto_sbitmap visited (last_basic_block_for_fn (cfun));\n   in_worklist = sbitmap_alloc (last_basic_block_for_fn (cfun));\n   in_pending = sbitmap_alloc (last_basic_block_for_fn (cfun));\n   bitmap_clear (in_worklist);\n@@ -7185,7 +7185,6 @@ vt_find_locations (void)\n   free (bb_order);\n   delete worklist;\n   delete pending;\n-  sbitmap_free (visited);\n   sbitmap_free (in_worklist);\n   sbitmap_free (in_pending);\n "}]}