{"sha": "8d8ed5c8b52171b663975cd46233de9f9fd80323", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQ4ZWQ1YzhiNTIxNzFiNjYzOTc1Y2Q0NjIzM2RlOWY5ZmQ4MDMyMw==", "commit": {"author": {"name": "Kewen Lin", "email": "linkw@linux.ibm.com", "date": "2021-06-24T08:45:29Z"}, "committer": {"name": "Kewen Lin", "email": "linkw@linux.ibm.com", "date": "2021-06-24T08:45:29Z"}, "message": "predcom: Refactor more by encapsulating global states\n\nThis patch is to encapsulate global states into a class and\nmaking their accessors as member functions, remove some\nconsequent useless clean up code, and do some clean up with\nRAII.\n\nBootstrapped/regtested on powerpc64le-linux-gnu P9,\nx86_64-redhat-linux and aarch64-linux-gnu, also\nbootstrapped on ppc64le P9 with bootstrap-O3 config.\n\ngcc/ChangeLog:\n\n\t* tree-predcom.c (class pcom_worker): New class.\n\t(release_chain): Renamed to...\n\t(pcom_worker::release_chain): ...this.\n\t(release_chains): Renamed to...\n\t(pcom_worker::release_chains): ...this.\n\t(aff_combination_dr_offset): Renamed to...\n\t(pcom_worker::aff_combination_dr_offset): ...this.\n\t(determine_offset): Renamed to...\n\t(pcom_worker::determine_offset): ...this.\n\t(class comp_ptrs): New class.\n\t(split_data_refs_to_components): Renamed to...\n\t(pcom_worker::split_data_refs_to_components): ...this,\n\tand update with class comp_ptrs.\n\t(suitable_component_p): Renamed to...\n\t(pcom_worker::suitable_component_p): ...this.\n\t(filter_suitable_components): Renamed to...\n\t(pcom_worker::filter_suitable_components): ...this.\n\t(valid_initializer_p): Renamed to...\n\t(pcom_worker::valid_initializer_p): ...this.\n\t(find_looparound_phi): Renamed to...\n\t(pcom_worker::find_looparound_phi): ...this.\n\t(add_looparound_copies): Renamed to...\n\t(pcom_worker::add_looparound_copies): ...this.\n\t(determine_roots_comp): Renamed to...\n\t(pcom_worker::determine_roots_comp): ...this.\n\t(determine_roots): Renamed to...\n\t(pcom_worker::determine_roots): ...this.\n\t(single_nonlooparound_use): Renamed to...\n\t(pcom_worker::single_nonlooparound_use): ...this.\n\t(remove_stmt): Renamed to...\n\t(pcom_worker::remove_stmt): ...this.\n\t(execute_pred_commoning_chain): Renamed to...\n\t(pcom_worker::execute_pred_commoning_chain): ...this.\n\t(execute_pred_commoning): Renamed to...\n\t(pcom_worker::execute_pred_commoning): ...this.\n\t(struct epcc_data): New member worker.\n\t(execute_pred_commoning_cbck): Call execute_pred_commoning\n\twith pcom_worker pointer.\n\t(find_use_stmt): Renamed to...\n\t(pcom_worker::find_use_stmt): ...this.\n\t(find_associative_operation_root): Renamed to...\n\t(pcom_worker::find_associative_operation_root): ...this.\n\t(find_common_use_stmt): Renamed to...\n\t(pcom_worker::find_common_use_stmt): ...this.\n\t(combinable_refs_p): Renamed to...\n\t(pcom_worker::combinable_refs_p): ...this.\n\t(reassociate_to_the_same_stmt): Renamed to...\n\t(pcom_worker::reassociate_to_the_same_stmt): ...this.\n\t(stmt_combining_refs): Renamed to...\n\t(pcom_worker::stmt_combining_refs): ...this.\n\t(combine_chains): Renamed to...\n\t(pcom_worker::combine_chains): ...this.\n\t(try_combine_chains): Renamed to...\n\t(pcom_worker::try_combine_chains): ...this.\n\t(prepare_initializers_chain): Renamed to...\n\t(pcom_worker::prepare_initializers_chain): ...this.\n\t(prepare_initializers): Renamed to...\n\t(pcom_worker::prepare_initializers): ...this.\n\t(prepare_finalizers_chain): Renamed to...\n\t(pcom_worker::prepare_finalizers_chain): ...this.\n\t(prepare_finalizers): Renamed to...\n\t(pcom_worker::prepare_finalizers): ...this.\n\t(tree_predictive_commoning_loop): Renamed to...\n\t(pcom_worker::tree_predictive_commoning_loop): ...this, adjust\n\tsome calls and remove some cleanup code.\n\t(tree_predictive_commoning): Adjusted to use pcom_worker instance.\n\t(static variable looparound_phis): Remove.\n\t(static variable name_expansions): Remove.", "tree": {"sha": "1b4996ed26a8505617ff847678c5668a543e165b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b4996ed26a8505617ff847678c5668a543e165b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d8ed5c8b52171b663975cd46233de9f9fd80323", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d8ed5c8b52171b663975cd46233de9f9fd80323", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d8ed5c8b52171b663975cd46233de9f9fd80323", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d8ed5c8b52171b663975cd46233de9f9fd80323/comments", "author": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7dcf139a2b8e1c53096ee2593cfdd706d5d358a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7dcf139a2b8e1c53096ee2593cfdd706d5d358a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7dcf139a2b8e1c53096ee2593cfdd706d5d358a8"}], "stats": {"total": 483, "additions": 309, "deletions": 174}, "files": [{"sha": "a4ebf2261b0d9f8741e483b60279e2568537d295", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 309, "deletions": 174, "changes": 483, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d8ed5c8b52171b663975cd46233de9f9fd80323/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d8ed5c8b52171b663975cd46233de9f9fd80323/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=8d8ed5c8b52171b663975cd46233de9f9fd80323", "patch": "@@ -375,13 +375,156 @@ struct component\n   struct component *next;\n };\n \n-/* Bitmap of ssa names defined by looparound phi nodes covered by chains.  */\n+/* A class to encapsulate the global states used for predictive\n+   commoning work on top of one given LOOP.  */\n \n-static bitmap looparound_phis;\n+class pcom_worker\n+{\n+public:\n+  pcom_worker (loop_p l) : loop (l), chains (vNULL), cache (NULL)\n+  {\n+    dependences.create (10);\n+    datarefs.create (10);\n+  }\n+\n+  ~pcom_worker ()\n+  {\n+    free_data_refs (datarefs);\n+    free_dependence_relations (dependences);\n+    free_affine_expand_cache (&cache);\n+    release_chains ();\n+  }\n+\n+  pcom_worker (const pcom_worker &) = delete;\n+  pcom_worker &operator= (const pcom_worker &) = delete;\n+\n+  /* Performs predictive commoning.  */\n+  unsigned tree_predictive_commoning_loop (bool allow_unroll_p);\n+\n+  /* Perform the predictive commoning optimization for chains, make this\n+     public for being called in callback execute_pred_commoning_cbck.  */\n+  void execute_pred_commoning (bitmap tmp_vars);\n+\n+private:\n+  /* The pointer to the given loop.  */\n+  loop_p loop;\n+\n+  /* All data references.  */\n+  vec<data_reference_p> datarefs;\n+\n+  /* All data dependences.  */\n+  vec<ddr_p> dependences;\n+\n+  /* All chains.  */\n+  vec<chain_p> chains;\n+\n+  /* Bitmap of ssa names defined by looparound phi nodes covered by chains.  */\n+  auto_bitmap looparound_phis;\n+\n+  typedef hash_map<tree, name_expansion *> tree_expand_map_t;\n+  /* Cache used by tree_to_aff_combination_expand.  */\n+  tree_expand_map_t *cache;\n+  /* Splits dependence graph to components.  */\n+  struct component *split_data_refs_to_components ();\n+\n+  /* Check the conditions on references inside each of components COMPS,\n+     and remove the unsuitable components from the list.  */\n+  struct component *filter_suitable_components (struct component *comps);\n+\n+  /* Find roots of the values and determine distances in components COMPS,\n+     and separates the references to chains.  */\n+  void determine_roots (struct component *comps);\n+\n+  /* Prepare initializers for chains, and free chains that cannot\n+     be used because the initializers might trap.  */\n+  void prepare_initializers ();\n+\n+  /* Generates finalizer memory reference for chains.  Returns true if\n+     finalizer code generation for chains breaks loop closed ssa form.  */\n+  bool prepare_finalizers ();\n+\n+  /* Try to combine the chains.  */\n+  void try_combine_chains ();\n+\n+  /* Frees CHAINS.  */\n+  void release_chains ();\n+\n+  /* Frees a chain CHAIN.  */\n+  void release_chain (chain_p chain);\n \n-/* Cache used by tree_to_aff_combination_expand.  */\n+  /* Prepare initializers for CHAIN.  Returns false if this is impossible\n+     because one of these initializers may trap, true otherwise.  */\n+  bool prepare_initializers_chain (chain_p chain);\n \n-static hash_map<tree, name_expansion *> *name_expansions;\n+  /* Generates finalizer memory references for CHAIN.  Returns true\n+     if finalizer code for CHAIN can be generated, otherwise false.  */\n+  bool prepare_finalizers_chain (chain_p chain);\n+\n+  /* Stores DR_OFFSET (DR) + DR_INIT (DR) to OFFSET.  */\n+  void aff_combination_dr_offset (struct data_reference *dr, aff_tree *offset);\n+\n+  /* Determines number of iterations of the innermost enclosing loop before\n+     B refers to exactly the same location as A and stores it to OFF.  */\n+  bool determine_offset (struct data_reference *a, struct data_reference *b,\n+\t\t\t poly_widest_int *off);\n+\n+  /* Returns true if the component COMP satisfies the conditions\n+     described in 2) at the beginning of this file.  */\n+  bool suitable_component_p (struct component *comp);\n+\n+  /* Returns true if REF is a valid initializer for ROOT with given\n+     DISTANCE (in iterations of the innermost enclosing loop).  */\n+  bool valid_initializer_p (struct data_reference *ref, unsigned distance,\n+\t\t\t    struct data_reference *root);\n+\n+  /* Finds looparound phi node of loop that copies the value of REF.  */\n+  gphi *find_looparound_phi (dref ref, dref root);\n+\n+  /* Find roots of the values and determine distances in the component\n+     COMP.  The references are redistributed into chains.  */\n+  void determine_roots_comp (struct component *comp);\n+\n+  /* For references in CHAIN that are copied around the loop, add the\n+     results of such copies to the chain.  */\n+  void add_looparound_copies (chain_p chain);\n+\n+  /* Returns the single statement in that NAME is used, excepting\n+     the looparound phi nodes contained in one of the chains.  */\n+  gimple *single_nonlooparound_use (tree name);\n+\n+  /* Remove statement STMT, as well as the chain of assignments in that\n+     it is used.  */\n+  void remove_stmt (gimple *stmt);\n+\n+  /* Perform the predictive commoning optimization for a chain CHAIN.  */\n+  void execute_pred_commoning_chain (chain_p chain, bitmap tmp_vars);\n+\n+  /* Returns the modify statement that uses NAME.  */\n+  gimple *find_use_stmt (tree *name);\n+\n+  /* If the operation used in STMT is associative and commutative, go\n+     through the tree of the same operations and returns its root.  */\n+  gimple *find_associative_operation_root (gimple *stmt, unsigned *distance);\n+\n+  /* Returns the common statement in that NAME1 and NAME2 have a use.  */\n+  gimple *find_common_use_stmt (tree *name1, tree *name2);\n+\n+  /* Checks whether R1 and R2 are combined together using CODE, with the\n+     result in RSLT_TYPE, in order R1 CODE R2 if SWAP is false and in order\n+     R2 CODE R1 if it is true.  */\n+  bool combinable_refs_p (dref r1, dref r2, enum tree_code *code, bool *swap,\n+\t\t\t  tree *rslt_type);\n+\n+  /* Reassociates the expression in that NAME1 and NAME2 are used so that\n+     they are combined in a single statement, and returns this statement.  */\n+  gimple *reassociate_to_the_same_stmt (tree name1, tree name2);\n+\n+  /* Returns the statement that combines references R1 and R2.  */\n+  gimple *stmt_combining_refs (dref r1, dref r2);\n+\n+  /* Tries to combine chains CH1 and CH2 together.  */\n+  chain_p combine_chains (chain_p ch1, chain_p ch2);\n+};\n \n /* Dumps data reference REF to FILE.  */\n \n@@ -540,8 +683,8 @@ dump_components (FILE *file, struct component *comps)\n \n /* Frees a chain CHAIN.  */\n \n-static void\n-release_chain (chain_p chain)\n+void\n+pcom_worker::release_chain (chain_p chain)\n {\n   dref ref;\n   unsigned i;\n@@ -567,8 +710,8 @@ release_chain (chain_p chain)\n \n /* Frees CHAINS.  */\n \n-static void\n-release_chains (vec<chain_p> chains)\n+void\n+pcom_worker::release_chains ()\n {\n   unsigned i;\n   chain_p chain;\n@@ -672,14 +815,14 @@ suitable_reference_p (struct data_reference *a, enum ref_step_type *ref_step)\n \n /* Stores DR_OFFSET (DR) + DR_INIT (DR) to OFFSET.  */\n \n-static void\n-aff_combination_dr_offset (struct data_reference *dr, aff_tree *offset)\n+void\n+pcom_worker::aff_combination_dr_offset (struct data_reference *dr,\n+\t\t\t\t\taff_tree *offset)\n {\n   tree type = TREE_TYPE (DR_OFFSET (dr));\n   aff_tree delta;\n \n-  tree_to_aff_combination_expand (DR_OFFSET (dr), type, offset,\n-\t\t\t\t  &name_expansions);\n+  tree_to_aff_combination_expand (DR_OFFSET (dr), type, offset, &cache);\n   aff_combination_const (&delta, type, wi::to_poly_widest (DR_INIT (dr)));\n   aff_combination_add (offset, &delta);\n }\n@@ -690,9 +833,9 @@ aff_combination_dr_offset (struct data_reference *dr, aff_tree *offset)\n    returns false, otherwise returns true.  Both A and B are assumed to\n    satisfy suitable_reference_p.  */\n \n-static bool\n-determine_offset (struct data_reference *a, struct data_reference *b,\n-\t\t  poly_widest_int *off)\n+bool\n+pcom_worker::determine_offset (struct data_reference *a,\n+\t\t\t       struct data_reference *b, poly_widest_int *off)\n {\n   aff_tree diff, baseb, step;\n   tree typea, typeb;\n@@ -726,7 +869,7 @@ determine_offset (struct data_reference *a, struct data_reference *b,\n   aff_combination_add (&diff, &baseb);\n \n   tree_to_aff_combination_expand (DR_STEP (a), TREE_TYPE (DR_STEP (a)),\n-\t\t\t\t  &step, &name_expansions);\n+\t\t\t\t  &step, &cache);\n   return aff_combination_constant_multiple_p (&diff, &step, off);\n }\n \n@@ -747,17 +890,39 @@ last_always_executed_block (class loop *loop)\n   return last;\n }\n \n-/* Splits dependence graph on DATAREFS described by DEPENDS to components.  */\n+/* RAII class for comp_father and comp_size usage.  */\n+\n+class comp_ptrs\n+{\n+public:\n+  unsigned *comp_father;\n+  unsigned *comp_size;\n+\n+  comp_ptrs (unsigned n)\n+  {\n+    comp_father = XNEWVEC (unsigned, n + 1);\n+    comp_size = XNEWVEC (unsigned, n + 1);\n+  }\n+\n+  ~comp_ptrs ()\n+  {\n+    free (comp_father);\n+    free (comp_size);\n+  }\n+\n+  comp_ptrs (const comp_ptrs &) = delete;\n+  comp_ptrs &operator= (const comp_ptrs &) = delete;\n+};\n+\n+/* Splits dependence graph on DATAREFS described by DEPENDENCES to\n+   components.  */\n \n-static struct component *\n-split_data_refs_to_components (class loop *loop,\n-\t\t\t       vec<data_reference_p> datarefs,\n-\t\t\t       vec<ddr_p> depends)\n+struct component *\n+pcom_worker::split_data_refs_to_components ()\n {\n   unsigned i, n = datarefs.length ();\n   unsigned ca, ia, ib, bad;\n-  unsigned *comp_father = XNEWVEC (unsigned, n + 1);\n-  unsigned *comp_size = XNEWVEC (unsigned, n + 1);\n+  comp_ptrs ptrs (n);\n   struct component **comps;\n   struct data_reference *dr, *dra, *drb;\n   struct data_dependence_relation *ddr;\n@@ -771,22 +936,20 @@ split_data_refs_to_components (class loop *loop,\n   FOR_EACH_VEC_ELT (datarefs, i, dr)\n     {\n       if (!DR_REF (dr))\n-\t{\n \t  /* A fake reference for call or asm_expr that may clobber memory;\n \t     just fail.  */\n-\t  goto end;\n-\t}\n+\t  return NULL;\n       /* predcom pass isn't prepared to handle calls with data references.  */\n       if (is_gimple_call (DR_STMT (dr)))\n-\tgoto end;\n+\treturn NULL;\n       dr->aux = (void *) (size_t) i;\n-      comp_father[i] = i;\n-      comp_size[i] = 1;\n+      ptrs.comp_father[i] = i;\n+      ptrs.comp_size[i] = 1;\n     }\n \n   /* A component reserved for the \"bad\" data references.  */\n-  comp_father[n] = n;\n-  comp_size[n] = 1;\n+  ptrs.comp_father[n] = n;\n+  ptrs.comp_size[n] = 1;\n \n   FOR_EACH_VEC_ELT (datarefs, i, dr)\n     {\n@@ -795,11 +958,11 @@ split_data_refs_to_components (class loop *loop,\n       if (!suitable_reference_p (dr, &dummy))\n \t{\n \t  ia = (unsigned) (size_t) dr->aux;\n-\t  merge_comps (comp_father, comp_size, n, ia);\n+\t  merge_comps (ptrs.comp_father, ptrs.comp_size, n, ia);\n \t}\n     }\n \n-  FOR_EACH_VEC_ELT (depends, i, ddr)\n+  FOR_EACH_VEC_ELT (dependences, i, ddr)\n     {\n       poly_widest_int dummy_off;\n \n@@ -816,12 +979,12 @@ split_data_refs_to_components (class loop *loop,\n \t      || DDR_NUM_DIST_VECTS (ddr) == 0))\n \teliminate_store_p = false;\n \n-      ia = component_of (comp_father, (unsigned) (size_t) dra->aux);\n-      ib = component_of (comp_father, (unsigned) (size_t) drb->aux);\n+      ia = component_of (ptrs.comp_father, (unsigned) (size_t) dra->aux);\n+      ib = component_of (ptrs.comp_father, (unsigned) (size_t) drb->aux);\n       if (ia == ib)\n \tcontinue;\n \n-      bad = component_of (comp_father, n);\n+      bad = component_of (ptrs.comp_father, n);\n \n       /* If both A and B are reads, we may ignore unsuitable dependences.  */\n       if (DR_IS_READ (dra) && DR_IS_READ (drb))\n@@ -845,7 +1008,7 @@ split_data_refs_to_components (class loop *loop,\n \t  else if (!determine_offset (dra, drb, &dummy_off))\n \t    {\n \t      bitmap_set_bit (no_store_store_comps, ib);\n-\t      merge_comps (comp_father, comp_size, bad, ia);\n+\t      merge_comps (ptrs.comp_father, ptrs.comp_size, bad, ia);\n \t      continue;\n \t    }\n \t}\n@@ -859,20 +1022,20 @@ split_data_refs_to_components (class loop *loop,\n \t  else if (!determine_offset (dra, drb, &dummy_off))\n \t    {\n \t      bitmap_set_bit (no_store_store_comps, ia);\n-\t      merge_comps (comp_father, comp_size, bad, ib);\n+\t      merge_comps (ptrs.comp_father, ptrs.comp_size, bad, ib);\n \t      continue;\n \t    }\n \t}\n       else if (DR_IS_WRITE (dra) && DR_IS_WRITE (drb)\n \t       && ia != bad && ib != bad\n \t       && !determine_offset (dra, drb, &dummy_off))\n \t{\n-\t  merge_comps (comp_father, comp_size, bad, ia);\n-\t  merge_comps (comp_father, comp_size, bad, ib);\n+\t  merge_comps (ptrs.comp_father, ptrs.comp_size, bad, ia);\n+\t  merge_comps (ptrs.comp_father, ptrs.comp_size, bad, ib);\n \t  continue;\n \t}\n \n-      merge_comps (comp_father, comp_size, ia, ib);\n+      merge_comps (ptrs.comp_father, ptrs.comp_size, ia, ib);\n     }\n \n   if (eliminate_store_p)\n@@ -886,19 +1049,19 @@ split_data_refs_to_components (class loop *loop,\n     }\n \n   comps = XCNEWVEC (struct component *, n);\n-  bad = component_of (comp_father, n);\n+  bad = component_of (ptrs.comp_father, n);\n   FOR_EACH_VEC_ELT (datarefs, i, dr)\n     {\n       ia = (unsigned) (size_t) dr->aux;\n-      ca = component_of (comp_father, ia);\n+      ca = component_of (ptrs.comp_father, ia);\n       if (ca == bad)\n \tcontinue;\n \n       comp = comps[ca];\n       if (!comp)\n \t{\n \t  comp = XCNEW (struct component);\n-\t  comp->refs.create (comp_size[ca]);\n+\t  comp->refs.create (ptrs.comp_size[ca]);\n \t  comp->eliminate_store_p = eliminate_store_p;\n \t  comps[ca] = comp;\n \t}\n@@ -921,7 +1084,7 @@ split_data_refs_to_components (class loop *loop,\n       bitmap_iterator bi;\n       EXECUTE_IF_SET_IN_BITMAP (no_store_store_comps, 0, ia, bi)\n \t{\n-\t  ca = component_of (comp_father, ia);\n+\t  ca = component_of (ptrs.comp_father, ia);\n \t  if (ca != bad)\n \t    comps[ca]->eliminate_store_p = false;\n \t}\n@@ -937,19 +1100,14 @@ split_data_refs_to_components (class loop *loop,\n \t}\n     }\n   free (comps);\n-\n-end:\n-  free (comp_father);\n-  free (comp_size);\n   return comp_list;\n }\n \n /* Returns true if the component COMP satisfies the conditions\n-   described in 2) at the beginning of this file.  LOOP is the current\n-   loop.  */\n+   described in 2) at the beginning of this file.  */\n \n-static bool\n-suitable_component_p (class loop *loop, struct component *comp)\n+bool\n+pcom_worker::suitable_component_p (struct component *comp)\n {\n   unsigned i;\n   dref a, first;\n@@ -1002,17 +1160,17 @@ suitable_component_p (class loop *loop, struct component *comp)\n /* Check the conditions on references inside each of components COMPS,\n    and remove the unsuitable components from the list.  The new list\n    of components is returned.  The conditions are described in 2) at\n-   the beginning of this file.  LOOP is the current loop.  */\n+   the beginning of this file.  */\n \n-static struct component *\n-filter_suitable_components (class loop *loop, struct component *comps)\n+struct component *\n+pcom_worker::filter_suitable_components (struct component *comps)\n {\n   struct component **comp, *act;\n \n   for (comp = &comps; *comp; )\n     {\n       act = *comp;\n-      if (suitable_component_p (loop, act))\n+      if (suitable_component_p (act))\n \tcomp = &act->next;\n       else\n \t{\n@@ -1205,9 +1363,9 @@ name_for_ref (dref ref)\n /* Returns true if REF is a valid initializer for ROOT with given DISTANCE (in\n    iterations of the innermost enclosing loop).  */\n \n-static bool\n-valid_initializer_p (struct data_reference *ref,\n-\t\t     unsigned distance, struct data_reference *root)\n+bool\n+pcom_worker::valid_initializer_p (struct data_reference *ref, unsigned distance,\n+\t\t\t\t  struct data_reference *root)\n {\n   aff_tree diff, base, step;\n   poly_widest_int off;\n@@ -1234,7 +1392,7 @@ valid_initializer_p (struct data_reference *ref,\n   aff_combination_add (&diff, &base);\n \n   tree_to_aff_combination_expand (DR_STEP (root), TREE_TYPE (DR_STEP (root)),\n-\t\t\t\t  &step, &name_expansions);\n+\t\t\t\t  &step, &cache);\n   if (!aff_combination_constant_multiple_p (&diff, &step, &off))\n     return false;\n \n@@ -1244,13 +1402,13 @@ valid_initializer_p (struct data_reference *ref,\n   return true;\n }\n \n-/* Finds looparound phi node of LOOP that copies the value of REF, and if its\n+/* Finds looparound phi node of loop that copies the value of REF, and if its\n    initial value is correct (equal to initial value of REF shifted by one\n    iteration), returns the phi node.  Otherwise, NULL_TREE is returned.  ROOT\n    is the root of the current chain.  */\n \n-static gphi *\n-find_looparound_phi (class loop *loop, dref ref, dref root)\n+gphi *\n+pcom_worker::find_looparound_phi (dref ref, dref root)\n {\n   tree name, init, init_ref;\n   gphi *phi = NULL;\n@@ -1333,13 +1491,13 @@ insert_looparound_copy (chain_p chain, dref ref, gphi *phi)\n     }\n }\n \n-/* For references in CHAIN that are copied around the LOOP (created previously\n+/* For references in CHAIN that are copied around the loop (created previously\n    by PRE, or by user), add the results of such copies to the chain.  This\n    enables us to remove the copies by unrolling, and may need less registers\n    (also, it may allow us to combine chains together).  */\n \n-static void\n-add_looparound_copies (class loop *loop, chain_p chain)\n+void\n+pcom_worker::add_looparound_copies (chain_p chain)\n {\n   unsigned i;\n   dref ref, root = get_chain_root (chain);\n@@ -1350,7 +1508,7 @@ add_looparound_copies (class loop *loop, chain_p chain)\n \n   FOR_EACH_VEC_ELT (chain->refs, i, ref)\n     {\n-      phi = find_looparound_phi (loop, ref, root);\n+      phi = find_looparound_phi (ref, root);\n       if (!phi)\n \tcontinue;\n \n@@ -1360,13 +1518,10 @@ add_looparound_copies (class loop *loop, chain_p chain)\n }\n \n /* Find roots of the values and determine distances in the component COMP.\n-   The references are redistributed into CHAINS.  LOOP is the current\n-   loop.  */\n+   The references are redistributed into chains.  */\n \n-static void\n-determine_roots_comp (class loop *loop,\n-\t\t      struct component *comp,\n-\t\t      vec<chain_p> *chains)\n+void\n+pcom_worker::determine_roots_comp (struct component *comp)\n {\n   unsigned i;\n   dref a;\n@@ -1378,7 +1533,7 @@ determine_roots_comp (class loop *loop,\n   if (comp->comp_step == RS_INVARIANT)\n     {\n       chain = make_invariant_chain (comp);\n-      chains->safe_push (chain);\n+      chains.safe_push (chain);\n       return;\n     }\n \n@@ -1422,8 +1577,8 @@ determine_roots_comp (class loop *loop,\n \t{\n \t  if (nontrivial_chain_p (chain))\n \t    {\n-\t      add_looparound_copies (loop, chain);\n-\t      chains->safe_push (chain);\n+\t      add_looparound_copies (chain);\n+\t      chains.safe_push (chain);\n \t    }\n \t  else\n \t    release_chain (chain);\n@@ -1443,24 +1598,23 @@ determine_roots_comp (class loop *loop,\n \n   if (nontrivial_chain_p (chain))\n     {\n-      add_looparound_copies (loop, chain);\n-      chains->safe_push (chain);\n+      add_looparound_copies (chain);\n+      chains.safe_push (chain);\n     }\n   else\n     release_chain (chain);\n }\n \n /* Find roots of the values and determine distances in components COMPS, and\n-   separates the references to CHAINS.  LOOP is the current loop.  */\n+   separates the references to chains.  */\n \n-static void\n-determine_roots (class loop *loop,\n-\t\t struct component *comps, vec<chain_p> *chains)\n+void\n+pcom_worker::determine_roots (struct component *comps)\n {\n   struct component *comp;\n \n   for (comp = comps; comp; comp = comp->next)\n-    determine_roots_comp (loop, comp, chains);\n+    determine_roots_comp (comp);\n }\n \n /* Replace the reference in statement STMT with temporary variable\n@@ -2027,8 +2181,8 @@ execute_load_motion (class loop *loop, chain_p chain, bitmap tmp_vars)\n    the looparound phi nodes contained in one of the chains.  If there is no\n    such statement, or more statements, NULL is returned.  */\n \n-static gimple *\n-single_nonlooparound_use (tree name)\n+gimple *\n+pcom_worker::single_nonlooparound_use (tree name)\n {\n   use_operand_p use;\n   imm_use_iterator it;\n@@ -2062,8 +2216,8 @@ single_nonlooparound_use (tree name)\n /* Remove statement STMT, as well as the chain of assignments in that it is\n    used.  */\n \n-static void\n-remove_stmt (gimple *stmt)\n+void\n+pcom_worker::remove_stmt (gimple *stmt)\n {\n   tree name;\n   gimple *next;\n@@ -2120,8 +2274,8 @@ remove_stmt (gimple *stmt)\n /* Perform the predictive commoning optimization for a chain CHAIN.\n    Uids of the newly created temporary variables are marked in TMP_VARS.*/\n \n-static void\n-execute_pred_commoning_chain (class loop *loop, chain_p chain,\n+void\n+pcom_worker::execute_pred_commoning_chain (chain_p chain,\n \t\t\t      bitmap tmp_vars)\n {\n   unsigned i;\n@@ -2248,12 +2402,11 @@ determine_unroll_factor (vec<chain_p> chains)\n   return factor;\n }\n \n-/* Perform the predictive commoning optimization for CHAINS.\n+/* Perform the predictive commoning optimization for chains.\n    Uids of the newly created temporary variables are marked in TMP_VARS.  */\n \n-static void\n-execute_pred_commoning (class loop *loop, vec<chain_p> chains,\n-\t\t\tbitmap tmp_vars)\n+void\n+pcom_worker::execute_pred_commoning (bitmap tmp_vars)\n {\n   chain_p chain;\n   unsigned i;\n@@ -2263,7 +2416,7 @@ execute_pred_commoning (class loop *loop, vec<chain_p> chains,\n       if (chain->type == CT_INVARIANT)\n \texecute_load_motion (loop, chain, tmp_vars);\n       else\n-\texecute_pred_commoning_chain (loop, chain, tmp_vars);\n+\texecute_pred_commoning_chain (chain, tmp_vars);\n     }\n \n   FOR_EACH_VEC_ELT (chains, i, chain)\n@@ -2330,18 +2483,20 @@ struct epcc_data\n {\n   vec<chain_p> chains;\n   bitmap tmp_vars;\n+  pcom_worker *worker;\n };\n \n static void\n-execute_pred_commoning_cbck (class loop *loop, void *data)\n+execute_pred_commoning_cbck (class loop *loop ATTRIBUTE_UNUSED, void *data)\n {\n   struct epcc_data *const dta = (struct epcc_data *) data;\n+  pcom_worker *worker = dta->worker;\n \n   /* Restore phi nodes that were replaced by ssa names before\n      tree_transform_and_unroll_loop (see detailed description in\n      tree_predictive_commoning_loop).  */\n   replace_names_by_phis (dta->chains);\n-  execute_pred_commoning (loop, dta->chains, dta->tmp_vars);\n+  worker->execute_pred_commoning (dta->tmp_vars);\n }\n \n /* Base NAME and all the names in the chain of phi nodes that use it\n@@ -2433,8 +2588,8 @@ chain_can_be_combined_p (chain_p chain)\n    statements, NAME is replaced with the actual name used in the returned\n    statement.  */\n \n-static gimple *\n-find_use_stmt (tree *name)\n+gimple *\n+pcom_worker::find_use_stmt (tree *name)\n {\n   gimple *stmt;\n   tree rhs, lhs;\n@@ -2486,8 +2641,8 @@ may_reassociate_p (tree type, enum tree_code code)\n    tree of the same operations and returns its root.  Distance to the root\n    is stored in DISTANCE.  */\n \n-static gimple *\n-find_associative_operation_root (gimple *stmt, unsigned *distance)\n+gimple *\n+pcom_worker::find_associative_operation_root (gimple *stmt, unsigned *distance)\n {\n   tree lhs;\n   gimple *next;\n@@ -2523,8 +2678,8 @@ find_associative_operation_root (gimple *stmt, unsigned *distance)\n    tree formed by this operation instead of the statement that uses NAME1 or\n    NAME2.  */\n \n-static gimple *\n-find_common_use_stmt (tree *name1, tree *name2)\n+gimple *\n+pcom_worker::find_common_use_stmt (tree *name1, tree *name2)\n {\n   gimple *stmt1, *stmt2;\n \n@@ -2553,8 +2708,8 @@ find_common_use_stmt (tree *name1, tree *name2)\n    in RSLT_TYPE, in order R1 CODE R2 if SWAP is false and in order R2 CODE R1\n    if it is true.  If CODE is ERROR_MARK, set these values instead.  */\n \n-static bool\n-combinable_refs_p (dref r1, dref r2,\n+bool\n+pcom_worker::combinable_refs_p (dref r1, dref r2,\n \t\t   enum tree_code *code, bool *swap, tree *rslt_type)\n {\n   enum tree_code acode;\n@@ -2622,8 +2777,8 @@ remove_name_from_operation (gimple *stmt, tree op)\n /* Reassociates the expression in that NAME1 and NAME2 are used so that they\n    are combined in a single statement, and returns this statement.  */\n \n-static gimple *\n-reassociate_to_the_same_stmt (tree name1, tree name2)\n+gimple *\n+pcom_worker::reassociate_to_the_same_stmt (tree name1, tree name2)\n {\n   gimple *stmt1, *stmt2, *root1, *root2, *s1, *s2;\n   gassign *new_stmt, *tmp_stmt;\n@@ -2707,8 +2862,8 @@ reassociate_to_the_same_stmt (tree name1, tree name2)\n    associative and commutative operation in the same expression, reassociate\n    the expression so that they are used in the same statement.  */\n \n-static gimple *\n-stmt_combining_refs (dref r1, dref r2)\n+gimple *\n+pcom_worker::stmt_combining_refs (dref r1, dref r2)\n {\n   gimple *stmt1, *stmt2;\n   tree name1 = name_for_ref (r1);\n@@ -2725,8 +2880,8 @@ stmt_combining_refs (dref r1, dref r2)\n /* Tries to combine chains CH1 and CH2 together.  If this succeeds, the\n    description of the new chain is returned, otherwise we return NULL.  */\n \n-static chain_p\n-combine_chains (chain_p ch1, chain_p ch2)\n+chain_p\n+pcom_worker::combine_chains (chain_p ch1, chain_p ch2)\n {\n   dref r1, r2, nw;\n   enum tree_code op = ERROR_MARK;\n@@ -2814,17 +2969,17 @@ pcom_stmt_dominates_stmt_p (gimple *s1, gimple *s2)\n   return dominated_by_p (CDI_DOMINATORS, bb2, bb1);\n }\n \n-/* Try to combine the CHAINS in LOOP.  */\n+/* Try to combine the chains.  */\n \n-static void\n-try_combine_chains (class loop *loop, vec<chain_p> *chains)\n+void\n+pcom_worker::try_combine_chains ()\n {\n   unsigned i, j;\n   chain_p ch1, ch2, cch;\n   auto_vec<chain_p> worklist;\n   bool combined_p = false;\n \n-  FOR_EACH_VEC_ELT (*chains, i, ch1)\n+  FOR_EACH_VEC_ELT (chains, i, ch1)\n     if (chain_can_be_combined_p (ch1))\n       worklist.safe_push (ch1);\n \n@@ -2834,7 +2989,7 @@ try_combine_chains (class loop *loop, vec<chain_p> *chains)\n       if (!chain_can_be_combined_p (ch1))\n \tcontinue;\n \n-      FOR_EACH_VEC_ELT (*chains, j, ch2)\n+      FOR_EACH_VEC_ELT (chains, j, ch2)\n \t{\n \t  if (!chain_can_be_combined_p (ch2))\n \t    continue;\n@@ -2843,7 +2998,7 @@ try_combine_chains (class loop *loop, vec<chain_p> *chains)\n \t  if (cch)\n \t    {\n \t      worklist.safe_push (cch);\n-\t      chains->safe_push (cch);\n+\t      chains.safe_push (cch);\n \t      combined_p = true;\n \t      break;\n \t    }\n@@ -2867,7 +3022,7 @@ try_combine_chains (class loop *loop, vec<chain_p> *chains)\n \n      We first update position information for all combined chains.  */\n   dref ref;\n-  for (i = 0; chains->iterate (i, &ch1); ++i)\n+  for (i = 0; chains.iterate (i, &ch1); ++i)\n     {\n       if (ch1->type != CT_COMBINATION || ch1->combined)\n \tcontinue;\n@@ -2878,7 +3033,7 @@ try_combine_chains (class loop *loop, vec<chain_p> *chains)\n       update_pos_for_combined_chains (ch1);\n     }\n   /* Then sort references according to newly updated position information.  */\n-  for (i = 0; chains->iterate (i, &ch1); ++i)\n+  for (i = 0; chains.iterate (i, &ch1); ++i)\n     {\n       if (ch1->type != CT_COMBINATION && !ch1->combined)\n \tcontinue;\n@@ -2990,11 +3145,11 @@ prepare_initializers_chain_store_elim (class loop *loop, chain_p chain)\n   return true;\n }\n \n-/* Prepare initializers for CHAIN in LOOP.  Returns false if this is\n-   impossible because one of these initializers may trap, true otherwise.  */\n+/* Prepare initializers for CHAIN.  Returns false if this is impossible\n+   because one of these initializers may trap, true otherwise.  */\n \n-static bool\n-prepare_initializers_chain (class loop *loop, chain_p chain)\n+bool\n+pcom_worker::prepare_initializers_chain (chain_p chain)\n {\n   unsigned i, n = (chain->type == CT_INVARIANT) ? 1 : chain->length;\n   struct data_reference *dr = get_chain_root (chain)->ref;\n@@ -3046,19 +3201,19 @@ prepare_initializers_chain (class loop *loop, chain_p chain)\n   return true;\n }\n \n-/* Prepare initializers for CHAINS in LOOP, and free chains that cannot\n+/* Prepare initializers for chains, and free chains that cannot\n    be used because the initializers might trap.  */\n \n-static void\n-prepare_initializers (class loop *loop, vec<chain_p> chains)\n+void\n+pcom_worker::prepare_initializers ()\n {\n   chain_p chain;\n   unsigned i;\n \n   for (i = 0; i < chains.length (); )\n     {\n       chain = chains[i];\n-      if (prepare_initializers_chain (loop, chain))\n+      if (prepare_initializers_chain (chain))\n \ti++;\n       else\n \t{\n@@ -3068,11 +3223,11 @@ prepare_initializers (class loop *loop, vec<chain_p> chains)\n     }\n }\n \n-/* Generates finalizer memory references for CHAIN in LOOP.  Returns true\n+/* Generates finalizer memory references for CHAIN.  Returns true\n    if finalizer code for CHAIN can be generated, otherwise false.  */\n \n-static bool\n-prepare_finalizers_chain (class loop *loop, chain_p chain)\n+bool\n+pcom_worker::prepare_finalizers_chain (chain_p chain)\n {\n   unsigned i, n = chain->length;\n   struct data_reference *dr = get_chain_root (chain)->ref;\n@@ -3116,11 +3271,11 @@ prepare_finalizers_chain (class loop *loop, chain_p chain)\n   return true;\n }\n \n-/* Generates finalizer memory reference for CHAINS in LOOP.  Returns true\n-   if finalizer code generation for CHAINS breaks loop closed ssa form.  */\n+/* Generates finalizer memory reference for chains.  Returns true if\n+   finalizer code generation for chains breaks loop closed ssa form.  */\n \n-static bool\n-prepare_finalizers (class loop *loop, vec<chain_p> chains)\n+bool\n+pcom_worker::prepare_finalizers ()\n {\n   chain_p chain;\n   unsigned i;\n@@ -3138,7 +3293,7 @@ prepare_finalizers (class loop *loop, vec<chain_p> chains)\n \t  continue;\n \t}\n \n-      if (prepare_finalizers_chain (loop, chain))\n+      if (prepare_finalizers_chain (chain))\n \t{\n \t  i++;\n \t  /* Be conservative, assume loop closed ssa form is corrupted\n@@ -3156,7 +3311,7 @@ prepare_finalizers (class loop *loop, vec<chain_p> chains)\n   return loop_closed_ssa;\n }\n \n-/* Insert all initializing gimple stmts into loop's entry edge.  */\n+/* Insert all initializing gimple stmts into LOOP's entry edge.  */\n \n static void\n insert_init_seqs (class loop *loop, vec<chain_p> chains)\n@@ -3177,19 +3332,16 @@ insert_init_seqs (class loop *loop, vec<chain_p> chains)\n    form was corrupted.  Non-zero return value indicates some changes were\n    applied to this loop.  */\n \n-static unsigned\n-tree_predictive_commoning_loop (class loop *loop, bool allow_unroll_p)\n+unsigned\n+pcom_worker::tree_predictive_commoning_loop (bool allow_unroll_p)\n {\n-  vec<data_reference_p> datarefs;\n-  vec<ddr_p> dependences;\n   struct component *components;\n-  vec<chain_p> chains = vNULL;\n   unsigned unroll_factor = 0;\n   class tree_niter_desc desc;\n   bool unroll = false, loop_closed_ssa = false;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"Processing loop %d\\n\",  loop->num);\n+    fprintf (dump_file, \"Processing loop %d\\n\", loop->num);\n \n   /* Nothing for predicitive commoning if loop only iterates 1 time.  */\n   if (get_max_loop_iterations_int (loop) == 0)\n@@ -3203,30 +3355,22 @@ tree_predictive_commoning_loop (class loop *loop, bool allow_unroll_p)\n   /* Find the data references and split them into components according to their\n      dependence relations.  */\n   auto_vec<loop_p, 3> loop_nest;\n-  dependences.create (10);\n-  datarefs.create (10);\n-  if (! compute_data_dependences_for_loop (loop, true, &loop_nest, &datarefs,\n-\t\t\t\t\t   &dependences))\n+  if (!compute_data_dependences_for_loop (loop, true, &loop_nest, &datarefs,\n+\t\t\t\t\t  &dependences))\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"Cannot analyze data dependencies\\n\");\n-      free_data_refs (datarefs);\n-      free_dependence_relations (dependences);\n       return 0;\n     }\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     dump_data_dependence_relations (dump_file, dependences);\n \n-  components = split_data_refs_to_components (loop, datarefs, dependences);\n+  components = split_data_refs_to_components ();\n+\n   loop_nest.release ();\n-  free_dependence_relations (dependences);\n   if (!components)\n-    {\n-      free_data_refs (datarefs);\n-      free_affine_expand_cache (&name_expansions);\n-      return 0;\n-    }\n+    return 0;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -3235,34 +3379,25 @@ tree_predictive_commoning_loop (class loop *loop, bool allow_unroll_p)\n     }\n \n   /* Find the suitable components and split them into chains.  */\n-  components = filter_suitable_components (loop, components);\n+  components = filter_suitable_components (components);\n \n   auto_bitmap tmp_vars;\n-  looparound_phis = BITMAP_ALLOC (NULL);\n-  determine_roots (loop, components, &chains);\n+  determine_roots (components);\n   release_components (components);\n \n-  auto cleanup = [&]() {\n-    release_chains (chains);\n-    free_data_refs (datarefs);\n-    BITMAP_FREE (looparound_phis);\n-    free_affine_expand_cache (&name_expansions);\n-  };\n-\n   if (!chains.exists ())\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file,\n \t\t \"Predictive commoning failed: no suitable chains\\n\");\n-      cleanup ();\n       return 0;\n     }\n \n-  prepare_initializers (loop, chains);\n-  loop_closed_ssa = prepare_finalizers (loop, chains);\n+  prepare_initializers ();\n+  loop_closed_ssa = prepare_finalizers ();\n \n   /* Try to combine the chains that are always worked with together.  */\n-  try_combine_chains (loop, &chains);\n+  try_combine_chains ();\n \n   insert_init_seqs (loop, chains);\n \n@@ -3289,8 +3424,9 @@ tree_predictive_commoning_loop (class loop *loop, bool allow_unroll_p)\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"Unrolling %u times.\\n\", unroll_factor);\n \n-      dta.chains = chains;\n       dta.tmp_vars = tmp_vars;\n+      dta.chains = chains;\n+      dta.worker = this;\n \n       /* Cfg manipulations performed in tree_transform_and_unroll_loop before\n \t execute_pred_commoning_cbck is called may cause phi nodes to be\n@@ -3310,11 +3446,9 @@ tree_predictive_commoning_loop (class loop *loop, bool allow_unroll_p)\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file,\n \t\t \"Executing predictive commoning without unrolling.\\n\");\n-      execute_pred_commoning (loop, chains, tmp_vars);\n+      execute_pred_commoning (tmp_vars);\n     }\n \n-  cleanup ();\n-\n   return (unroll ? 2 : 1) | (loop_closed_ssa ? 4 : 1);\n }\n \n@@ -3330,7 +3464,8 @@ tree_predictive_commoning (bool allow_unroll_p)\n   FOR_EACH_LOOP (loop, LI_ONLY_INNERMOST)\n     if (optimize_loop_for_speed_p (loop))\n       {\n-\tchanged |= tree_predictive_commoning_loop (loop, allow_unroll_p);\n+\tpcom_worker w(loop);\n+\tchanged |= w.tree_predictive_commoning_loop (allow_unroll_p);\n       }\n   free_original_copy_tables ();\n "}]}