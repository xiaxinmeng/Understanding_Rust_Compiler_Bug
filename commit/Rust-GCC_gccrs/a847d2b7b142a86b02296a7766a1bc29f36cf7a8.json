{"sha": "a847d2b7b142a86b02296a7766a1bc29f36cf7a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTg0N2QyYjdiMTQyYTg2YjAyMjk2YTc3NjZhMWJjMjlmMzZjZjdhOA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-10-23T02:46:41Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-10-23T02:46:41Z"}, "message": "compiler: export indexed type data, read unexported types lazily\n    \n    Introduce a new \"types\" command to the export data to record the\n    number of types and the size of their export data. It is immediately\n    followed by new \"type\" commands that can be indexed. Parse all the\n    exported types immediately so that we register them, but parse other\n    type data only as needed.\n    \n    Reviewed-on: https://go-review.googlesource.com/c/143022\n\nFrom-SVN: r265409", "tree": {"sha": "3a518e1527a037ab081f889246b330e2eb42669a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a518e1527a037ab081f889246b330e2eb42669a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a847d2b7b142a86b02296a7766a1bc29f36cf7a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a847d2b7b142a86b02296a7766a1bc29f36cf7a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a847d2b7b142a86b02296a7766a1bc29f36cf7a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a847d2b7b142a86b02296a7766a1bc29f36cf7a8/comments", "author": null, "committer": null, "parents": [{"sha": "91f4d9e994869ad099bf02012e4d1371f00ade4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91f4d9e994869ad099bf02012e4d1371f00ade4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91f4d9e994869ad099bf02012e4d1371f00ade4d"}], "stats": {"total": 788, "additions": 633, "deletions": 155}, "files": [{"sha": "a6b016ad710c530fbaa41009d5c05258cfe7c121", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a847d2b7b142a86b02296a7766a1bc29f36cf7a8/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a847d2b7b142a86b02296a7766a1bc29f36cf7a8/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=a847d2b7b142a86b02296a7766a1bc29f36cf7a8", "patch": "@@ -1,4 +1,4 @@\n-e1dc92a6037a3f81ea1b8ea8fb6207af33505f0c\n+6db7e35d3bcd75ab3cb15296a5ddc5178038c9c1\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "a64c7fd80a603577cb94f0fa48b863aaeb493af3", "filename": "gcc/go/gofrontend/export.cc", "status": "modified", "additions": 229, "deletions": 104, "changes": 333, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a847d2b7b142a86b02296a7766a1bc29f36cf7a8/gcc%2Fgo%2Fgofrontend%2Fexport.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a847d2b7b142a86b02296a7766a1bc29f36cf7a8/gcc%2Fgo%2Fgofrontend%2Fexport.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexport.cc?ref=a847d2b7b142a86b02296a7766a1bc29f36cf7a8", "patch": "@@ -44,11 +44,49 @@ const int Export::checksum_len;\n // Constructor.\n \n Export::Export(Stream* stream)\n-  : stream_(stream), type_refs_(), type_index_(1), packages_()\n+  : stream_(stream), type_index_(1), packages_()\n {\n   go_assert(Export::checksum_len == Go_sha1_helper::checksum_len);\n }\n \n+// Type hash table operations, treating aliases as distinct.\n+\n+class Type_hash_alias_identical\n+{\n+ public:\n+  unsigned int\n+  operator()(const Type* type) const\n+  {\n+    return type->hash_for_method(NULL,\n+\t\t\t\t (Type::COMPARE_ERRORS\n+\t\t\t\t  | Type::COMPARE_TAGS\n+\t\t\t\t  | Type::COMPARE_ALIASES));\n+  }\n+};\n+\n+class Type_alias_identical\n+{\n+ public:\n+  bool\n+  operator()(const Type* t1, const Type* t2) const\n+  {\n+    return Type::are_identical(t1, t2,\n+\t\t\t       (Type::COMPARE_ERRORS\n+\t\t\t\t| Type::COMPARE_TAGS\n+\t\t\t\t| Type::COMPARE_ALIASES),\n+\t\t\t       NULL);\n+  }\n+};\n+\n+// Mapping from Type objects to a constant index.  This would be nicer\n+// as a field in Export, but then export.h would have to #include\n+// types.h.\n+\n+typedef Unordered_map_hash(const Type*, int, Type_hash_alias_identical,\n+\t\t\t   Type_alias_identical) Type_refs;\n+\n+static Type_refs type_refs;\n+\n // A functor to sort Named_object pointers by name.\n \n struct Sort_bindings\n@@ -139,9 +177,10 @@ Export::export_globals(const std::string& package_name,\n \n   std::sort(exports.begin(), exports.end(), Sort_bindings());\n \n-  // Find all packages not explicitly imported but mentioned by types.\n+  // Assign indexes to all exported types and types referenced by\n+  // exported types, and collect all packages mentioned.\n   Unordered_set(const Package*) type_imports;\n-  this->prepare_types(&exports, &type_imports);\n+  int unexported_type_index = this->prepare_types(&exports, &type_imports);\n \n   // Although the export data is readable, at least this version is,\n   // it is conceptually a binary format.  Start with a four byte\n@@ -178,10 +217,17 @@ Export::export_globals(const std::string& package_name,\n   // and ABI being used, although ideally any problems in that area\n   // would be caught by the linker.\n \n+  // Write out all the types, both exported and not.\n+  this->write_types(unexported_type_index);\n+\n+  // Write out the non-type export data.\n   for (std::vector<Named_object*>::const_iterator p = exports.begin();\n        p != exports.end();\n        ++p)\n-    (*p)->export_named_object(this);\n+    {\n+      if (!(*p)->is_type())\n+\t(*p)->export_named_object(this);\n+    }\n \n   std::string checksum = this->stream_->checksum();\n   std::string s = \"checksum \";\n@@ -204,9 +250,10 @@ Export::export_globals(const std::string& package_name,\n class Find_types_to_prepare : public Traverse\n {\n  public:\n-  Find_types_to_prepare(Unordered_set(const Package*)* imports)\n+  Find_types_to_prepare(Export* exp,\n+\t\t\tUnordered_set(const Package*)* imports)\n     : Traverse(traverse_types),\n-      imports_(imports)\n+      exp_(exp), imports_(imports)\n   { }\n \n   int\n@@ -221,19 +268,34 @@ class Find_types_to_prepare : public Traverse\n   traverse_named_type(Named_type*);\n \n  private:\n+  // Exporters.\n+  Export* exp_;\n   // List of packages we are building.\n   Unordered_set(const Package*)* imports_;\n };\n \n-// Traverse a type.\n+// Set type index of referenced type, record package imports, and make\n+// sure we traverse methods of named types.\n \n int\n Find_types_to_prepare::type(Type* type)\n {\n-  // Skip forwarders.\n+  // Skip forwarders; don't try to give them a type index.\n   if (type->forward_declaration_type() != NULL)\n     return TRAVERSE_CONTINUE;\n \n+  // Skip the void type, which we'll see when exporting\n+  // unsafe.Pointer.  The void type is not itself exported, because\n+  // Pointer_type::do_export checks for it.\n+  if (type->is_void_type())\n+    return TRAVERSE_SKIP_COMPONENTS;\n+\n+  if (!this->exp_->set_type_index(type))\n+    {\n+      // We've already seen this type.\n+      return TRAVERSE_SKIP_COMPONENTS;\n+    }\n+\n   // At this stage of compilation traversing interface types traverses\n   // the final list of methods, but we export the locally defined\n   // methods.  If there is an embedded interface type we need to make\n@@ -267,7 +329,7 @@ Find_types_to_prepare::type(Type* type)\n }\n \n // Traverse the types in a function type.  We don't need the function\n-// type tself, just the receiver, parameter, and result types.\n+// type itself, just the receiver, parameter, and result types.\n \n void\n Find_types_to_prepare::traverse_function(Function_type* type)\n@@ -319,20 +381,34 @@ Find_types_to_prepare::traverse_named_type(Named_type* nt)\n     }\n }\n \n-// Collect all the pacakges we see in types, so that if we refer to\n-// any types from indirectly importe packages we can tell the importer\n-// about the package.\n+// Prepare to export types by assigning a type index to every exported\n+// type and every type referenced by an exported type.  Also collect\n+// all the packages we see in types, so that if we refer to any types\n+// from indirectly imported packages we can tell the importer about\n+// the package.  This returns the number of exported types.\n \n-void\n+int\n Export::prepare_types(const std::vector<Named_object*>* exports,\n \t\t      Unordered_set(const Package*)* imports)\n {\n-  // Use a single index of the traversal class because traversal\n+  // Assign indexes to all the exported types.\n+  for (std::vector<Named_object*>::const_iterator p = exports->begin();\n+       p != exports->end();\n+       ++p)\n+    {\n+      if (!(*p)->is_type())\n+\tcontinue;\n+      this->set_type_index((*p)->type_value());\n+    }\n+\n+  int ret = this->type_index_;\n+\n+  // Use a single instance of the traversal class because traversal\n   // classes keep track of which types they've already seen.  That\n   // lets us avoid type reference loops.\n-  Find_types_to_prepare find(imports);\n+  Find_types_to_prepare find(this, imports);\n \n-  // Traverse all the exported objects.\n+  // Traverse all the exported objects and assign indexes to all types.\n   for (std::vector<Named_object*>::const_iterator p = exports->begin();\n        p != exports->end();\n        ++p)\n@@ -349,7 +425,8 @@ Export::prepare_types(const std::vector<Named_object*>* exports,\n \t  break;\n \n \tcase Named_object::NAMED_OBJECT_TYPE:\n-\t  Type::traverse(no->type_value(), &find);\n+\t  Type::traverse(no->type_value()->real_type(), &find);\n+\t  find.traverse_named_type(no->type_value());\n \t  break;\n \n \tcase Named_object::NAMED_OBJECT_VAR:\n@@ -370,6 +447,31 @@ Export::prepare_types(const std::vector<Named_object*>* exports,\n \t  break;\n \t}\n     }\n+\n+  return ret;\n+}\n+\n+// Give a type an index if it doesn't already have one.  Return true\n+// if we set the type index, false if it was already known.\n+\n+bool\n+Export::set_type_index(Type* type)\n+{\n+  type = type->forwarded();\n+\n+  std::pair<Type_refs::iterator, bool> ins =\n+    type_refs.insert(std::make_pair(type, 0));\n+  if (!ins.second)\n+    {\n+      // We've already seen this type.\n+      return false;\n+    }\n+\n+  int index = this->type_index_;\n+  ++this->type_index_;\n+  ins.first->second = index;\n+\n+  return true;\n }\n \n // Sort packages.\n@@ -705,6 +807,104 @@ Export::write_imported_init_fns(const std::string& package_name,\n   this->write_c_string(\"\\n\");\n }\n \n+// Write the types to the export stream.\n+\n+void\n+Export::write_types(int unexported_type_index)\n+{\n+  // Map from type index to type.\n+  std::vector<const Type*> types(static_cast<size_t>(this->type_index_));\n+  for (Type_refs::const_iterator p = type_refs.begin();\n+       p != type_refs.end();\n+       ++p)\n+    {\n+      if (p->second >= 0)\n+\ttypes.at(p->second) = p->first;\n+    }\n+\n+  // Write the type information to a buffer.\n+  Stream_to_string type_data;\n+  Export::Stream* orig_stream = this->stream_;\n+  this->stream_ = &type_data;\n+\n+  std::vector<size_t> type_sizes(static_cast<size_t>(this->type_index_));\n+  type_sizes[0] = 0;\n+\n+  // Start at 1 because type index 0 is not used.\n+  size_t start_size = 0;\n+  for (int i = 1; i < this->type_index_; ++i)\n+    {\n+      this->write_type_definition(types[i], i);\n+\n+      size_t cur_size = type_data.string().size();\n+      type_sizes[i] = cur_size - start_size;\n+      start_size = cur_size;\n+    }\n+\n+  // Back to original stream.\n+  this->stream_ = orig_stream;\n+\n+  // The line \"types MAXP1 EXPORTEDP1 SIZES...\" appears before the\n+  // types.  MAXP1 is one more than the maximum type index used; that\n+  // is, it is the size of the array we need to allocate to hold all\n+  // the values.  Indexes 1 up to but not including EXPORTEDP1 are the\n+  // exported types.  The other types are not exported.  SIZES... is a\n+  // list of MAXP1-1 entries listing the size of the type definition\n+  // for each type, starting at index 1.\n+  char buf[100];\n+  snprintf(buf, sizeof buf, \"types %d %d\", this->type_index_,\n+\t   unexported_type_index);\n+  this->write_c_string(buf);\n+\n+  // Start at 1 because type index 0 is not used.\n+  for (int i = 1; i < this->type_index_; ++i)\n+    {\n+      snprintf(buf, sizeof buf, \" %lu\",\n+\t       static_cast<unsigned long>(type_sizes[i]));\n+      this->write_c_string(buf);\n+    }\n+  this->write_c_string(\"\\n\");\n+  this->write_string(type_data.string());\n+}\n+\n+// Write a single type to the export stream.\n+\n+void\n+Export::write_type_definition(const Type* type, int index)\n+{\n+  this->write_c_string(\"type \");\n+\n+  char buf[30];\n+  snprintf(buf, sizeof buf, \"%d \", index);\n+  this->write_c_string(buf);\n+\n+  const Named_type* nt = type->named_type();\n+  if (nt != NULL)\n+    {\n+      const Named_object* no = nt->named_object();\n+      const Package* package = no->package();\n+\n+      this->write_c_string(\"\\\"\");\n+      if (package != NULL && !Gogo::is_hidden_name(no->name()))\n+\t{\n+\t  this->write_string(package->pkgpath());\n+\t  this->write_c_string(\".\");\n+\t}\n+      this->write_string(nt->named_object()->name());\n+      this->write_c_string(\"\\\" \");\n+\n+      if (nt->is_alias())\n+\tthis->write_c_string(\"= \");\n+    }\n+\n+  type->export_type(this);\n+\n+  // Type::export_type will print a newline for a named type, but not\n+  // otherwise.\n+  if (nt == NULL)\n+    this->write_c_string(\"\\n\");\n+}\n+\n // Write a name to the export stream.\n \n void\n@@ -736,91 +936,19 @@ Export::write_unsigned(unsigned value)\n   this->write_c_string(buf);\n }\n \n-// Export a type.  We have to ensure that on import we create a single\n-// Named_type node for each named type.  We do this by keeping a hash\n-// table mapping named types to reference numbers.  The first time we\n-// see a named type we assign it a reference number by making an entry\n-// in the hash table.  If we see it again, we just refer to the\n-// reference number.\n-\n-// Named types are, of course, associated with packages.  Note that we\n-// may see a named type when importing one package, and then later see\n-// the same named type when importing a different package.  The home\n-// package may or may not be imported during this compilation.  The\n-// reference number scheme has to get this all right.  Basic approach\n-// taken from \"On the Linearization of Graphs and Writing Symbol\n-// Files\" by Robert Griesemer.\n+// Export a type.\n \n void\n Export::write_type(const Type* type)\n {\n-  // We don't want to assign a reference number to a forward\n-  // declaration to a type which was defined later.\n   type = type->forwarded();\n-\n-  Type_refs::const_iterator p = this->type_refs_.find(type);\n-  if (p != this->type_refs_.end())\n-    {\n-      // This type was already in the table.\n-      int index = p->second;\n-      go_assert(index != 0);\n-      char buf[30];\n-      snprintf(buf, sizeof buf, \"<type %d>\", index);\n-      this->write_c_string(buf);\n-      return;\n-    }\n-\n-  const Named_type* named_type = type->named_type();\n-  const Forward_declaration_type* forward = type->forward_declaration_type();\n-\n-  int index = this->type_index_;\n-  ++this->type_index_;\n-\n+  Type_refs::const_iterator p = type_refs.find(type);\n+  go_assert(p != type_refs.end());\n+  int index = p->second;\n+  go_assert(index != 0);\n   char buf[30];\n-  snprintf(buf, sizeof buf, \"<type %d \", index);\n+  snprintf(buf, sizeof buf, \"<type %d>\", index);\n   this->write_c_string(buf);\n-\n-  if (named_type != NULL || forward != NULL)\n-    {\n-      const Named_object* named_object;\n-      if (named_type != NULL)\n-\t{\n-\t  // The builtin types should have been predefined.\n-\t  go_assert(!Linemap::is_predeclared_location(named_type->location())\n-\t\t     || (named_type->named_object()->package()->package_name()\n-\t\t\t == \"unsafe\"));\n-\t  named_object = named_type->named_object();\n-\t}\n-      else\n-\tnamed_object = forward->named_object();\n-\n-      const Package* package = named_object->package();\n-\n-      std::string s = \"\\\"\";\n-      if (package != NULL && !Gogo::is_hidden_name(named_object->name()))\n-\t{\n-\t  s += package->pkgpath();\n-\t  s += '.';\n-\t}\n-      s += named_object->name();\n-      s += \"\\\" \";\n-      this->write_string(s);\n-\n-      // We must add a named type to the table now, since the\n-      // definition of the type may refer to the named type via a\n-      // pointer.\n-      this->type_refs_[type] = index;\n-\n-      if (named_type != NULL && named_type->is_alias())\n-\tthis->write_c_string(\"= \");\n-    }\n-\n-  type->export_type(this);\n-\n-  this->write_c_string(\">\");\n-\n-  if (named_type == NULL)\n-    this->type_refs_[type] = index;\n }\n \n // Export escape note.\n@@ -873,18 +1001,15 @@ Export::register_builtin_type(Gogo* gogo, const char* name, Builtin_code code)\n   Named_object* named_object = gogo->lookup_global(name);\n   go_assert(named_object != NULL && named_object->is_type());\n   std::pair<Type_refs::iterator, bool> ins =\n-    this->type_refs_.insert(std::make_pair(named_object->type_value(), code));\n+    type_refs.insert(std::make_pair(named_object->type_value(), code));\n   go_assert(ins.second);\n \n   // We also insert the underlying type.  We can see the underlying\n-  // type at least for string and bool.  We skip the type aliases byte\n-  // and rune here.\n-  if (code != BUILTIN_BYTE && code != BUILTIN_RUNE)\n-    {\n-      Type* real_type = named_object->type_value()->real_type();\n-      ins = this->type_refs_.insert(std::make_pair(real_type, code));\n-      go_assert(ins.second);\n-    }\n+  // type at least for string and bool.  It's OK if this insert\n+  // fails--we expect duplications here, and it doesn't matter when\n+  // they occur.\n+  Type* real_type = named_object->type_value()->real_type();\n+  type_refs.insert(std::make_pair(real_type, code));\n }\n \n // Class Export::Stream."}, {"sha": "84077a22c23b254832fcfe6fb510831c77f208a1", "filename": "gcc/go/gofrontend/export.h", "status": "modified", "additions": 37, "deletions": 7, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a847d2b7b142a86b02296a7766a1bc29f36cf7a8/gcc%2Fgo%2Fgofrontend%2Fexport.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a847d2b7b142a86b02296a7766a1bc29f36cf7a8/gcc%2Fgo%2Fgofrontend%2Fexport.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexport.h?ref=a847d2b7b142a86b02296a7766a1bc29f36cf7a8", "patch": "@@ -11,6 +11,7 @@\n \n class Go_sha1_helper;\n class Gogo;\n+class Named_object;\n class Import_init;\n class Named_object;\n class Bindings;\n@@ -154,6 +155,10 @@ class Export : public String_dump\n \t\t const Import_init_set& imported_init_fns,\n \t\t const Bindings* bindings);\n \n+  // Set the index of a type.\n+  bool\n+  set_type_index(Type*);\n+\n   // Write a string to the export stream.\n   void\n   write_string(const std::string& s)\n@@ -196,7 +201,7 @@ class Export : public String_dump\n   Export& operator=(const Export&);\n \n   // Prepare types for exporting.\n-  void\n+  int\n   prepare_types(const std::vector<Named_object*>* exports,\n \t\tUnordered_set(const Package*)* imports);\n \n@@ -224,24 +229,27 @@ class Export : public String_dump\n   write_imported_init_fns(const std::string& package_name,\n \t\t\t  const std::string&, const Import_init_set&);\n \n+  // Write out all types.\n+  void\n+  write_types(int unexported_type_index);\n+\n+  // Write out one type definition.\n+  void\n+  write_type_definition(const Type* type, int index);\n+\n   // Register one builtin type.\n   void\n   register_builtin_type(Gogo*, const char* name, Builtin_code);\n \n-  // Mapping from Type objects to a constant index.\n-  typedef Unordered_map(const Type*, int) Type_refs;\n-\n   // The stream to which we are writing data.\n   Stream* stream_;\n-  // Type mappings.\n-  Type_refs type_refs_;\n   // Index number of next type.\n   int type_index_;\n   // Packages we have written out.\n   Unordered_set(const Package*) packages_;\n };\n \n-// An export streamer which puts the export stream in a named section.\n+// An export streamer that puts the export stream in a named section.\n \n class Stream_to_section : public Export::Stream\n {\n@@ -256,4 +264,26 @@ class Stream_to_section : public Export::Stream\n   Backend* backend_;\n };\n \n+// An export streamer that puts the export stream in a string.\n+\n+class Stream_to_string : public Export::Stream\n+{\n+ public:\n+  Stream_to_string()\n+    : string_()\n+  {}\n+\n+  const std::string&\n+  string() const\n+  { return this->string_; }\n+\n+ protected:\n+  void\n+  do_write(const char* s, size_t len)\n+  { this->string_.append(s, len); }\n+\n+ private:\n+  std::string string_;\n+};\n+\n #endif // !defined(GO_EXPORT_H)"}, {"sha": "2472245ebe95d35f96ada08e3ef9282a657b428d", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a847d2b7b142a86b02296a7766a1bc29f36cf7a8/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a847d2b7b142a86b02296a7766a1bc29f36cf7a8/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=a847d2b7b142a86b02296a7766a1bc29f36cf7a8", "patch": "@@ -7511,8 +7511,8 @@ Named_object::export_named_object(Export* exp) const\n       break;\n \n     case NAMED_OBJECT_TYPE:\n-      this->type_value()->export_named_type(exp, this->name_);\n-      break;\n+      // Types are handled by export::write_types.\n+      go_unreachable();\n \n     case NAMED_OBJECT_TYPE_DECLARATION:\n       go_error_at(this->type_declaration_value()->location(),"}, {"sha": "9c469ca32b5ece8a5a74fb20c8536c509a362096", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a847d2b7b142a86b02296a7766a1bc29f36cf7a8/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a847d2b7b142a86b02296a7766a1bc29f36cf7a8/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=a847d2b7b142a86b02296a7766a1bc29f36cf7a8", "patch": "@@ -12,9 +12,7 @@\n class Traverse;\n class Statement_inserter;\n class Type;\n-class Type_hash_identical;\n class Type_equal;\n-class Type_identical;\n class Typed_identifier;\n class Typed_identifier_list;\n class Function_type;"}, {"sha": "d30068f3b97e99fd495c70ad6464b470ab0bc71a", "filename": "gcc/go/gofrontend/import.cc", "status": "modified", "additions": 220, "deletions": 17, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a847d2b7b142a86b02296a7766a1bc29f36cf7a8/gcc%2Fgo%2Fgofrontend%2Fimport.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a847d2b7b142a86b02296a7766a1bc29f36cf7a8/gcc%2Fgo%2Fgofrontend%2Fimport.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fimport.cc?ref=a847d2b7b142a86b02296a7766a1bc29f36cf7a8", "patch": "@@ -236,7 +236,7 @@ Import::find_export_data(const std::string& filename, int fd, Location location)\n     }\n \n   char buf[len];\n-  ssize_t c = read(fd, buf, len);\n+  ssize_t c = ::read(fd, buf, len);\n   if (c < len)\n     return NULL;\n \n@@ -288,7 +288,7 @@ Import::find_object_export_data(const std::string& filename,\n \n Import::Import(Stream* stream, Location location)\n   : gogo_(NULL), stream_(stream), location_(location), package_(NULL),\n-    add_to_globals_(false),\n+    add_to_globals_(false), type_data_(), type_pos_(0), type_offsets_(),\n     builtin_types_((- SMALLEST_BUILTIN_CODE) + 1),\n     types_(), version_(EXPORT_FORMAT_UNKNOWN)\n {\n@@ -403,6 +403,12 @@ Import::import(Gogo* gogo, const std::string& local_name,\n       if (stream->match_c_string(\"init\"))\n \tthis->read_import_init_fns(gogo);\n \n+      if (stream->match_c_string(\"types \"))\n+\t{\n+\t  if (!this->read_types())\n+\t    return NULL;\n+\t}\n+\n       // Loop over all the input data for this package.\n       while (!stream->saw_error())\n \t{\n@@ -585,6 +591,86 @@ Import::read_import_init_fns(Gogo* gogo)\n     }\n }\n \n+// Import the types.  Starting in export format version 3 all the\n+// types are listed first.\n+\n+bool\n+Import::read_types()\n+{\n+  this->require_c_string(\"types \");\n+  std::string str = this->read_identifier();\n+  int maxp1;\n+  if (!this->string_to_int(str, false, &maxp1))\n+    return false;\n+\n+  this->require_c_string(\" \");\n+  str = this->read_identifier();\n+  int exportedp1;\n+  if (!this->string_to_int(str, false, &exportedp1))\n+    return false;\n+\n+  this->type_offsets_.resize(maxp1, std::make_pair<size_t, size_t>(0, 0));\n+  size_t total_type_size = 0;\n+  // Start at 1 because type index 0 not used.\n+  for (int i = 1; i < maxp1; i++)\n+    {\n+      this->require_c_string(\" \");\n+      str = this->read_identifier();\n+      int v;\n+      if (!this->string_to_int(str, false, &v))\n+\treturn false;\n+      size_t vs = static_cast<size_t>(v);\n+      this->type_offsets_[i] = std::make_pair(total_type_size, vs);\n+      total_type_size += vs;\n+    }\n+\n+  this->require_c_string(\"\\n\");\n+\n+  // Types can refer to each other in an unpredictable order.  Read\n+  // all the type data into type_data_.  The type_offsets_ vector we\n+  // just initialized provides indexes into type_data_.\n+\n+  this->type_pos_ = this->stream_->pos();\n+  const char* type_data;\n+  if (!this->stream_->peek(total_type_size, &type_data))\n+    return false;\n+  this->type_data_ = std::string(type_data, total_type_size);\n+  this->advance(total_type_size);\n+\n+  this->types_.resize(maxp1, NULL);\n+\n+  // Parse all the exported types now, so that the names are properly\n+  // bound and visible to the parser.  Parse unexported types lazily.\n+\n+  // Start at 1 because there is no type 0.\n+  for (int i = 1; i < exportedp1; i++)\n+    {\n+      // We may have already parsed this type when we parsed an\n+      // earlier type.\n+      Type* type = this->types_[i];\n+      if (type == NULL)\n+\t{\n+\t  if (!this->parse_type(i))\n+\t    return false;\n+\t  type = this->types_[i];\n+\t  go_assert(type != NULL);\n+\t}\n+      Named_type* nt = type->named_type();\n+      if (nt == NULL)\n+\t{\n+\t  go_error_at(this->location_,\n+\t\t      \"error in import data: exported unnamed type %d\",\n+\t\t      i);\n+\t  return false;\n+\t}\n+      nt->set_is_visible();\n+      if (this->add_to_globals_)\n+\tthis->gogo_->add_named_type(nt);\n+    }\n+\n+  return true;\n+}\n+\n // Import a constant.\n \n void\n@@ -605,6 +691,18 @@ Import::import_const()\n void\n Import::import_type()\n {\n+  if (this->version_ >= EXPORT_FORMAT_V3)\n+    {\n+      if (!this->stream_->saw_error())\n+\t{\n+\t  go_error_at(this->location_,\n+\t\t    \"error in import data at %d: old type syntax\",\n+\t\t    this->stream_->pos());\n+\t  this->stream_->set_saw_error();\n+\t}\n+      return;\n+    }\n+\n   Named_type* type;\n   Named_type::import_named_type(this, &type);\n \n@@ -694,9 +792,73 @@ Import::import_func(Package* package)\n   return no;\n }\n \n+// Read a type definition and initialize the entry in this->types_.\n+// This parses the type definition saved by read_types earlier.  This\n+// returns true on success, false on failure.\n+\n+bool\n+Import::parse_type(int i)\n+{\n+  go_assert(i >= 0 && static_cast<size_t>(i) < this->types_.size());\n+  go_assert(this->types_[i] == NULL);\n+  size_t offset = this->type_offsets_[i].first;\n+  size_t len = this->type_offsets_[i].second;\n+\n+  Stream* orig_stream = this->stream_;\n+\n+  Stream_from_string_ref stream(this->type_data_, offset, len);\n+  stream.set_pos(this->type_pos_ + offset);\n+  this->stream_ = &stream;\n+\n+  this->require_c_string(\"type \");\n+  std::string str = this->read_identifier();\n+  int id;\n+  if (!this->string_to_int(str, false, &id))\n+    {\n+      this->stream_ = orig_stream;\n+      return false;\n+    }\n+  if (i != id)\n+    {\n+      go_error_at(this->location_,\n+\t\t  (\"error in import data at %d: \"\n+\t\t   \"type ID mismatch: got %d, want %d\"),\n+\t\t  stream.pos(), id, i);\n+      this->stream_ = orig_stream;\n+      return false;\n+    }\n+\n+  this->require_c_string(\" \");\n+  if (stream.peek_char() == '\"')\n+    {\n+      stream.advance(1);\n+      Type* type = this->read_named_type(i);\n+      if (type->is_error_type())\n+\t{\n+\t  this->stream_ = orig_stream;\n+\t  return false;\n+\t}\n+    }\n+  else\n+    {\n+      Type* type = Type::import_type(this);\n+      if (type->is_error_type())\n+\t{\n+\t  this->stream_ = orig_stream;\n+\t  return false;\n+\t}\n+      this->types_[i] = type;\n+\n+      this->require_c_string(\"\\n\");\n+    }\n+\n+  this->stream_ = orig_stream;\n+  return true;\n+}\n+\n // Read a type in the import stream.  This records the type by the\n-// type index.  If the type is named, it registers the name, but marks\n-// it as invisible.\n+// type index.  If the type is named (which can only happen with older\n+// export formats), it registers the name, but marks it as invisible.\n \n Type*\n Import::read_type()\n@@ -720,7 +882,28 @@ Import::read_type()\n \n   if (c == '>')\n     {\n-      // This type was already defined.\n+      // A reference to a type defined earlier.\n+\n+      if (index >= 0 && !this->type_data_.empty())\n+\t{\n+\t  if (static_cast<size_t>(index) >= this->type_offsets_.size())\n+\t    {\n+\t      go_error_at(this->location_,\n+\t\t\t  (\"error in import data at %d: \"\n+\t\t\t   \"bad type index %d >= %d\"),\n+\t\t\t  stream->pos(), index,\n+\t\t\t  static_cast<int>(this->type_offsets_.size()));\n+\t      stream->set_saw_error();\n+\t      return Type::make_error_type();\n+\t    }\n+\n+\t  if (this->types_[index] == NULL)\n+\t    {\n+\t      if (!this->parse_type(index))\n+\t\treturn Type::make_error_type();\n+\t    }\n+\t}\n+\n       if (index < 0\n \t  ? (static_cast<size_t>(- index) >= this->builtin_types_.size()\n \t     || this->builtin_types_[- index] == NULL)\n@@ -737,11 +920,21 @@ Import::read_type()\n       return index < 0 ? this->builtin_types_[- index] : this->types_[index];\n     }\n \n+  if (this->version_ >= EXPORT_FORMAT_V3)\n+    {\n+      if (!stream->saw_error())\n+\tgo_error_at(this->location_,\n+\t\t    \"error in import data at %d: expected %<>%>\",\n+\t\t    stream->pos());\n+      stream->set_saw_error();\n+      return Type::make_error_type();\n+    }\n+\n   if (c != ' ')\n     {\n       if (!stream->saw_error())\n \tgo_error_at(this->location_,\n-\t\t    \"error in import data at %d: expect %< %> or %<>%>'\",\n+\t\t    \"error in import data at %d: expected %< %> or %<>%>'\",\n \t\t    stream->pos());\n       stream->set_saw_error();\n       stream->advance(1);\n@@ -774,10 +967,25 @@ Import::read_type()\n       return type;\n     }\n \n-  // This type has a name.\n-\n   stream->advance(1);\n+\n+  Type* type = this->read_named_type(index);\n+\n+  this->require_c_string(\">\");\n+\n+  return type;\n+}\n+\n+// Read a named type from the import stream and store it in\n+// this->types_[index].  The stream should be positioned immediately\n+// after the '\"' that starts the name.\n+\n+Type*\n+Import::read_named_type(int index)\n+{\n+  Stream* stream = this->stream_;\n   std::string type_name;\n+  int c;\n   while ((c = stream->get_char()) != '\"')\n     type_name += c;\n \n@@ -863,7 +1071,7 @@ Import::read_type()\n   // If there is no type definition, then this is just a forward\n   // declaration of a type defined in some other file.\n   Type* type;\n-  if (this->match_c_string(\">\"))\n+  if (this->match_c_string(\">\") || this->match_c_string(\"\\n\"))\n     type = this->types_[index];\n   else\n     {\n@@ -912,8 +1120,6 @@ Import::read_type()\n \t}\n     }\n \n-  this->require_c_string(\">\");\n-\n   return type;\n }\n \n@@ -1125,10 +1331,9 @@ Stream_from_file::do_peek(size_t length, const char** bytes)\n       *bytes = this->data_.data();\n       return true;\n     }\n-  // Don't bother to handle the general case, since we don't need it.\n-  go_assert(length < 64);\n-  char buf[64];\n-  ssize_t got = read(this->fd_, buf, length);\n+\n+  this->data_.resize(length);\n+  ssize_t got = ::read(this->fd_, &this->data_[0], length);\n \n   if (got < 0)\n     {\n@@ -1149,8 +1354,6 @@ Stream_from_file::do_peek(size_t length, const char** bytes)\n   if (static_cast<size_t>(got) < length)\n     return false;\n \n-  this->data_.assign(buf, got);\n-\n   *bytes = this->data_.data();\n   return true;\n }"}, {"sha": "cc7703bcc943871f7ec98586f999dc73309042f1", "filename": "gcc/go/gofrontend/import.h", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a847d2b7b142a86b02296a7766a1bc29f36cf7a8/gcc%2Fgo%2Fgofrontend%2Fimport.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a847d2b7b142a86b02296a7766a1bc29f36cf7a8/gcc%2Fgo%2Fgofrontend%2Fimport.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fimport.h?ref=a847d2b7b142a86b02296a7766a1bc29f36cf7a8", "patch": "@@ -30,6 +30,11 @@ class Import\n     Stream();\n     virtual ~Stream();\n \n+    // Set the position, for error messages.\n+    void\n+    set_pos(int pos)\n+    { this->pos_ = pos; }\n+\n     // Return whether we have seen an error.\n     bool\n     saw_error() const\n@@ -249,6 +254,10 @@ class Import\n   void\n   read_import_init_fns(Gogo*);\n \n+  // Read the types.\n+  bool\n+  read_types();\n+\n   // Import a constant.\n   void\n   import_const();\n@@ -265,6 +274,14 @@ class Import\n   Named_object*\n   import_func(Package*);\n \n+  // Parse a type definition.\n+  bool\n+  parse_type(int index);\n+\n+  // Read a named type and store it at this->type_[index].\n+  Type*\n+  read_named_type(int index);\n+\n   // Register a single builtin type.\n   void\n   register_builtin_type(Gogo*, const char* name, Builtin_code);\n@@ -299,6 +316,12 @@ class Import\n   // Whether to add new objects to the global scope, rather than to a\n   // package scope.\n   bool add_to_globals_;\n+  // All type data.\n+  std::string type_data_;\n+  // Position of type data in the stream.\n+  int type_pos_;\n+  // Mapping from type code to offset/length in type_data_.\n+  std::vector<std::pair<size_t, size_t> > type_offsets_;\n   // Mapping from negated builtin type codes to Type structures.\n   std::vector<Named_type*> builtin_types_;\n   // Mapping from exported type codes to Type structures.\n@@ -399,4 +422,41 @@ class Stream_from_file : public Import::Stream\n   std::string data_;\n };\n \n+// Read import data from an offset into a std::string.  This uses a\n+// reference to the string, to avoid copying, so the string must be\n+// kept alive through some other mechanism.\n+\n+class Stream_from_string_ref : public Import::Stream\n+{\n+ public:\n+  Stream_from_string_ref(const std::string& str, size_t offset, size_t length)\n+    : str_(str), pos_(offset), end_(offset + length)\n+  { }\n+\n+  ~Stream_from_string_ref()\n+  {}\n+\n+ protected:\n+  bool\n+  do_peek(size_t length, const char** bytes)\n+  {\n+    if (this->pos_ + length > this->end_)\n+      return false;\n+    *bytes = &this->str_[this->pos_];\n+    return true;\n+  }\n+\n+  void\n+  do_advance(size_t length)\n+  { this->pos_ += length; }\n+\n+ private:\n+  // A reference to the string we are reading from.\n+  const std::string& str_;\n+  // The current offset into the string.\n+  size_t pos_;\n+  // The index after the last byte we can read.\n+  size_t end_;\n+};\n+\n #endif // !defined(GO_IMPORT_H)"}, {"sha": "2d348ba2c6f1539fdfa0dbdcf78ad6b350f7d5c3", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a847d2b7b142a86b02296a7766a1bc29f36cf7a8/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a847d2b7b142a86b02296a7766a1bc29f36cf7a8/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=a847d2b7b142a86b02296a7766a1bc29f36cf7a8", "patch": "@@ -10865,19 +10865,8 @@ Named_type::append_reflection_type_name(Gogo* gogo, bool use_alias,\n   ret->append(Gogo::unpack_hidden_name(this->named_object_->name()));\n }\n \n-// Export the type.  This is called to export a global type.\n-\n-void\n-Named_type::export_named_type(Export* exp, const std::string&) const\n-{\n-  // We don't need to write the name of the type here, because it will\n-  // be written by Export::write_type anyhow.\n-  exp->write_c_string(\"type \");\n-  exp->write_type(this);\n-  exp->write_c_string(\"\\n\");\n-}\n-\n-// Import a named type.\n+// Import a named type.  This is only used for export format versions\n+// before version 3.\n \n void\n Named_type::import_named_type(Import* imp, Named_type** ptype)\n@@ -10891,20 +10880,22 @@ Named_type::import_named_type(Import* imp, Named_type** ptype)\n }\n \n // Export the type when it is referenced by another type.  In this\n-// case Export::export_type will already have issued the name.\n+// case Export::export_type will already have issued the name.  The\n+// output always ends with a newline, since that is convenient if\n+// there are methods.\n \n void\n Named_type::do_export(Export* exp) const\n {\n   exp->write_type(this->type_);\n+  exp->write_c_string(\"\\n\");\n \n   // To save space, we only export the methods directly attached to\n   // this type.\n   Bindings* methods = this->local_methods_;\n   if (methods == NULL)\n     return;\n \n-  exp->write_c_string(\"\\n\");\n   for (Bindings::const_definitions_iterator p = methods->begin_definitions();\n        p != methods->end_definitions();\n        ++p)"}, {"sha": "4898e67d7b809d533b4323e23998d42ef5398270", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a847d2b7b142a86b02296a7766a1bc29f36cf7a8/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a847d2b7b142a86b02296a7766a1bc29f36cf7a8/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=a847d2b7b142a86b02296a7766a1bc29f36cf7a8", "patch": "@@ -3445,10 +3445,6 @@ class Named_type : public Type\n   void\n   append_mangled_type_name(Gogo*, bool use_alias, std::string*) const;\n \n-  // Export the type.\n-  void\n-  export_named_type(Export*, const std::string& name) const;\n-\n   // Import a named type.\n   static void\n   import_named_type(Import*, Named_type**);"}, {"sha": "dc61e4cadc9e8349d6918603442fda7c3b99809a", "filename": "libgo/go/go/internal/gccgoimporter/parser.go", "status": "modified", "additions": 78, "deletions": 3, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a847d2b7b142a86b02296a7766a1bc29f36cf7a8/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a847d2b7b142a86b02296a7766a1bc29f36cf7a8/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Fparser.go?ref=a847d2b7b142a86b02296a7766a1bc29f36cf7a8", "patch": "@@ -18,7 +18,7 @@ import (\n )\n \n type parser struct {\n-\tscanner  scanner.Scanner\n+\tscanner  *scanner.Scanner\n \tversion  string                    // format version\n \ttok      rune                      // current token\n \tlit      string                    // literal string; only valid for Ident, Int, String tokens\n@@ -27,18 +27,24 @@ type parser struct {\n \tpkg      *types.Package            // reference to imported package\n \timports  map[string]*types.Package // package path -> package object\n \ttypeMap  map[int]types.Type        // type number -> type\n+\ttypeData []string                  // unparsed type data\n \tinitdata InitData                  // package init priority data\n }\n \n func (p *parser) init(filename string, src io.Reader, imports map[string]*types.Package) {\n+\tp.scanner = new(scanner.Scanner)\n+\tp.initScanner(filename, src)\n+\tp.imports = imports\n+\tp.typeMap = make(map[int]types.Type)\n+}\n+\n+func (p *parser) initScanner(filename string, src io.Reader) {\n \tp.scanner.Init(src)\n \tp.scanner.Error = func(_ *scanner.Scanner, msg string) { p.error(msg) }\n \tp.scanner.Mode = scanner.ScanIdents | scanner.ScanInts | scanner.ScanFloats | scanner.ScanStrings | scanner.ScanComments | scanner.SkipComments\n \tp.scanner.Whitespace = 1<<'\\t' | 1<<' '\n \tp.scanner.Filename = filename // for good error messages\n \tp.next()\n-\tp.imports = imports\n-\tp.typeMap = make(map[int]types.Type)\n }\n \n type importError struct {\n@@ -720,6 +726,9 @@ func (p *parser) parseType(pkg *types.Package) (t types.Type) {\n \t\tn := p.parseInt()\n \n \t\tif p.tok == '>' {\n+\t\t\tif len(p.typeData) > 0 && p.typeMap[int(n)] == nil {\n+\t\t\t\tp.parseSavedType(pkg, int(n))\n+\t\t\t}\n \t\t\tt = p.typeMap[int(n)]\n \t\t} else {\n \t\t\tt = p.parseTypeDefinition(pkg, int(n))\n@@ -739,6 +748,67 @@ func (p *parser) parseType(pkg *types.Package) (t types.Type) {\n \treturn\n }\n \n+// Types = \"types\" maxp1 exportedp1 (offset length)* .\n+func (p *parser) parseTypes(pkg *types.Package) {\n+\tmaxp1 := p.parseInt()\n+\texportedp1 := p.parseInt()\n+\n+\ttype typeOffset struct {\n+\t\toffset int\n+\t\tlength int\n+\t}\n+\tvar typeOffsets []typeOffset\n+\n+\ttotal := 0\n+\tfor i := 1; i < int(maxp1); i++ {\n+\t\tlen := int(p.parseInt())\n+\t\ttypeOffsets = append(typeOffsets, typeOffset{total, len})\n+\t\ttotal += len\n+\t}\n+\n+\t// We should now have p.tok pointing to the final newline.\n+\t// The next runes from the scanner should be the type data.\n+\n+\tvar sb strings.Builder\n+\tfor sb.Len() < total {\n+\t\tr := p.scanner.Next()\n+\t\tif r == scanner.EOF {\n+\t\t\tp.error(\"unexpected EOF\")\n+\t\t}\n+\t\tsb.WriteRune(r)\n+\t}\n+\tallTypeData := sb.String()\n+\n+\tp.typeData = []string{\"\"} // type 0, unused\n+\tfor _, to := range typeOffsets {\n+\t\tp.typeData = append(p.typeData, allTypeData[to.offset:to.offset+to.length])\n+\t}\n+\n+\tfor i := 1; i < int(exportedp1); i++ {\n+\t\tp.parseSavedType(pkg, i)\n+\t}\n+}\n+\n+// parseSavedType parses one saved type definition.\n+func (p *parser) parseSavedType(pkg *types.Package, i int) {\n+\tdefer func(s *scanner.Scanner, tok rune, lit string) {\n+\t\tp.scanner = s\n+\t\tp.tok = tok\n+\t\tp.lit = lit\n+\t}(p.scanner, p.tok, p.lit)\n+\n+\tp.scanner = new(scanner.Scanner)\n+\tp.initScanner(p.scanner.Filename, strings.NewReader(p.typeData[i]))\n+\tp.expectKeyword(\"type\")\n+\tid := int(p.parseInt())\n+\tif id != i {\n+\t\tp.errorf(\"type ID mismatch: got %d, want %d\", id, i)\n+\t}\n+\tif p.typeMap[i] == nil {\n+\t\tp.typeMap[i] = p.parseTypeDefinition(pkg, i)\n+\t}\n+}\n+\n // PackageInit = unquotedString unquotedString int .\n func (p *parser) parsePackageInit() PackageInit {\n \tname := p.parseUnquotedString()\n@@ -883,6 +953,11 @@ func (p *parser) parseDirective() {\n \t\tp.getPkg(pkgpath, pkgname)\n \t\tp.expectEOL()\n \n+\tcase \"types\":\n+\t\tp.next()\n+\t\tp.parseTypes(p.pkg)\n+\t\tp.expectEOL()\n+\n \tcase \"func\":\n \t\tp.next()\n \t\tfun := p.parseFunc(p.pkg)"}]}