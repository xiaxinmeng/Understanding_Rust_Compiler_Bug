{"sha": "e70bd3dc1961543d10142c8884755cdaf4fd86e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTcwYmQzZGMxOTYxNTQzZDEwMTQyYzg4ODQ3NTVjZGFmNGZkODZlNw==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-04-12T17:04:57Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-04-12T17:04:57Z"}, "message": "Initial revision\n\nFrom-SVN: r19141", "tree": {"sha": "85692f1dc62b282168e52f089edb883b94bd7a88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/85692f1dc62b282168e52f089edb883b94bd7a88"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e70bd3dc1961543d10142c8884755cdaf4fd86e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e70bd3dc1961543d10142c8884755cdaf4fd86e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e70bd3dc1961543d10142c8884755cdaf4fd86e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e70bd3dc1961543d10142c8884755cdaf4fd86e7/comments", "author": null, "committer": null, "parents": [{"sha": "7d771bfbb2cdd41b3cd495641be0e7decad3d4d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d771bfbb2cdd41b3cd495641be0e7decad3d4d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d771bfbb2cdd41b3cd495641be0e7decad3d4d8"}], "stats": {"total": 293, "additions": 293, "deletions": 0}, "files": [{"sha": "da61e8b5674aeb57e14a9bfbc9d3c78bd809848d", "filename": "gcc/config/i386/osf1elf.h", "status": "added", "additions": 260, "deletions": 0, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70bd3dc1961543d10142c8884755cdaf4fd86e7/gcc%2Fconfig%2Fi386%2Fosf1elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70bd3dc1961543d10142c8884755cdaf4fd86e7/gcc%2Fconfig%2Fi386%2Fosf1elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fosf1elf.h?ref=e70bd3dc1961543d10142c8884755cdaf4fd86e7", "patch": "@@ -0,0 +1,260 @@\n+/* OSF/1 1.3 now is compitable with SVR4, so include sysv4.h, and\n+   put difference here.  */\n+\n+#include <stdio.h>\n+#include \"i386/sysv4.h\"\t/* Base i386 target machine definitions */\n+#define _sys_siglist sys_siglist\n+extern char *sys_siglist[];\n+\n+#undef TARGET_VERSION\n+#define TARGET_VERSION fprintf (stderr, \" (i386 OSF/1)\");\n+\n+/* WORD_SWITCH_TAKES_ARG defined in svr4 is not correct. We also\n+ need an extra -soname */\n+#undef WORD_SWITCH_TAKES_ARG\n+#define WORD_SWITCH_TAKES_ARG(STR)                    \\\n+ (DEFAULT_WORD_SWITCH_TAKES_ARG (STR)                 \\\n+  || !strcmp (STR, \"Tdata\") || !strcmp (STR, \"Ttext\") \\\n+  || !strcmp (STR, \"Tbss\") || !strcmp (STR, \"soname\"))\n+\n+/* Note, -fpic and -fPIC are equivalent */\n+#undef  CPP_SPEC\n+#define CPP_SPEC \"\\\n+%{fpic: -D__SHARED__} %{fPIC: %{!fpic: -D__SHARED__}} \\\n+%{.S:\t%{!ansi:%{!traditional:%{!traditional-cpp:%{!ftraditional: -traditional}}}}} \\\n+%{.S:\t-D__LANGUAGE_ASSEMBLY %{!ansi:-DLANGUAGE_ASSEMBLY}} \\\n+%{.cc:\t-D__LANGUAGE_C_PLUS_PLUS} \\\n+%{.cxx:\t-D__LANGUAGE_C_PLUS_PLUS} \\\n+%{.C:\t-D__LANGUAGE_C_PLUS_PLUS} \\\n+%{.m:\t-D__LANGUAGE_OBJECTIVE_C} \\\n+%{!.S:\t-D__LANGUAGE_C %{!ansi:-DLANGUAGE_C}}\"\n+\n+/* -mmcount or -mno-mcount should be used with -pg or -p */\n+#undef  CC1_SPEC\n+#define CC1_SPEC \"%{p: %{!mmcount: %{!mno-mcount: -mno-mcount }}} \\\n+%{!p: %{pg: %{!mmcount: %{!mno-mcount: -mno-mcount }}}}\"\n+\n+/* Note, -D__NO_UNDERSCORES__ -D__ELF__ are provided in the older version of\n+   OSF/1 gcc. We keep them here, so that old /usr/include/i386/asm.h works.\n+   */\n+#undef CPP_PREDEFINES\n+#define CPP_PREDEFINES \\\n+  \"-D__NO_UNDERSCORES__ -D__ELF__ -DOSF -DOSF1 -Di386 -Dunix -Asystem(xpg4) -Asystem(osf1) -Acpu(i386) -Amachine(i386)\"\n+\n+/* current OSF/1 doesn't provide separate crti.o and gcrti.o (and also, crtn.o\n+   and gcrtn.o) for profile.  */\n+\n+#undef  STARTFILE_SPEC\n+#define STARTFILE_SPEC \"%{!shared: \\\n+                         %{!symbolic: \\\n+                          %{pg:gcrt0.o%s}%{!pg:%{p:mcrt0.o%s}%{!p:crt0.o%s}}}}\\\n+\t\t\tcrti.o%s \\\n+\t\t\tcrtbegin.o%s\"\n+\n+#undef  ENDFILE_SPEC\n+#define ENDFILE_SPEC \"crtend.o%s crtn.o%s\"\n+\n+#undef\tASM_SPEC\n+#define ASM_SPEC       \"%{v*: -v}\"\n+\n+#undef  LINK_SPEC\n+#define LINK_SPEC      \"%{v*: -v} \\\n+\t\t%{h*} %{z*} \\\n+\t\t%{dy:-call_shared} %{dn:-static} \\\n+\t\t%{static:-static} \\\n+\t\t%{shared:-shared} \\\n+\t\t%{call_shared:-call_shared} \\\n+\t\t%{symbolic:-Bsymbolic -shared -call_shared} \\\n+\t\t%{!dy: %{!dn: %{!static: %{!shared: %{!symbolic: \\\n+\t\t\t%{noshrlib: -static } \\\n+\t\t\t%{!noshrlib: -call_shared}}}}}}\"\n+\n+#undef MD_EXEC_PREFIX\n+#define MD_EXEC_PREFIX\t\"/usr/ccs/gcc/\"\n+\n+#undef  MD_STARTFILE_PREFIX\n+#define MD_STARTFILE_PREFIX\t\"/usr/ccs/lib/\"\n+\n+/* Define this macro meaning that gcc should find the library 'libgcc.a'\n+   by hand, rather than passing the argument '-lgcc' to tell the linker\n+   to do the search */\n+#define LINK_LIBGCC_SPECIAL\n+\n+/* This goes with LINK_LIBGCC_SPECIAL, we need tell libgcc.a differently */\n+#undef  LIBGCC_SPEC\n+#define LIBGCC_SPEC \"%{!shared:%{!symbolic:libgcc.a%s}}\"\n+\n+/* A C statement to output assembler commands which will identify the object\n+  file as having been compile with GNU CC. We don't need or want this for\n+  OSF1. */\n+#undef ASM_IDENTIFY_GCC\n+#define ASM_IDENTIFY_GCC(FILE)\n+\n+/* Identify the front-end which produced this file.  To keep symbol\n+   space down, and not confuse kdb, only do this if the language is\n+   not C.  */\n+#define ASM_IDENTIFY_LANGUAGE(STREAM)                                   \\\n+{                                                                       \\\n+  if (strcmp (lang_identify (), \"c\") != 0)                              \\\n+    output_lang_identify (STREAM);                                      \\\n+}\n+\n+/* Specify size_t, ptrdiff_t, and wchar_t types.  */\n+#undef  SIZE_TYPE\n+#undef  PTRDIFF_TYPE\n+#undef  WCHAR_TYPE\n+#undef  WCHAR_TYPE_SIZE\n+\n+#define SIZE_TYPE       \"long unsigned int\"\n+#define PTRDIFF_TYPE    \"int\"\n+#define WCHAR_TYPE      \"unsigned int\"\n+#define WCHAR_TYPE_SIZE BITS_PER_WORD\n+\n+/* Turn off long double being 96 bits.  */\n+#undef LONG_DOUBLE_TYPE_SIZE\n+#define LONG_DOUBLE_TYPE_SIZE 64\n+\n+/* Work with OSF/1 profile */\n+#define MASK_NO_MCOUNT\t\t000200000000\t/* profiling uses mcount_ptr */\n+\n+#define TARGET_MCOUNT\t\t((target_flags & MASK_NO_MCOUNT) == 0)\n+\n+#undef\tSUBTARGET_SWITCHES\n+#define SUBTARGET_SWITCHES\t\t\t\t\t\t\\\n+     { \"mcount\",\t\t-MASK_NO_MCOUNT},\t\t\t\\\n+     { \"no-mcount\",\t\t MASK_NO_MCOUNT},\n+\n+/* This macro generates the assembly code for function entry.\n+   FILE is a stdio stream to output the code to.\n+   SIZE is an int: how many units of temporary storage to allocate.\n+   Refer to the array `regs_ever_live' to determine which registers\n+   to save; `regs_ever_live[I]' is nonzero if register number I\n+   is ever used in the function.  This macro is responsible for\n+   knowing which registers should not be saved even if used.\n+\n+   We override it here to allow for the new profiling code to go before\n+   the prologue and the old mcount code to go after the prologue (and\n+   after %ebx has been set up for ELF shared library support).  */\n+#if 0\n+#define OSF_PROFILE_BEFORE_PROLOGUE\t\t\t\t\t\\\n+  (!TARGET_MCOUNT\t\t\t\t\t\t\t\\\n+   && !current_function_needs_context\t\t\t\t\t\\\n+   && (!flag_pic\t\t\t\t\t\t\t\\\n+       || !frame_pointer_needed\t\t\t\t\t\t\\\n+       || (!current_function_uses_pic_offset_table\t\t\t\\\n+\t   && !current_function_uses_const_pool)))\n+#else\n+#define OSF_PROFILE_BEFORE_PROLOGUE 0\n+#endif\n+#undef\tFUNCTION_PROLOGUE\n+#define FUNCTION_PROLOGUE(FILE, SIZE)\t\t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    char *prefix = \"\";\t\t\t\\\n+    char *lprefix = LPREFIX;\t\t\t\t\t\t\\\n+    int labelno = profile_label_no;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    if (profile_flag && OSF_PROFILE_BEFORE_PROLOGUE)\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tif (!flag_pic)\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    fprintf (FILE, \"\\tmovl $%sP%d,%%edx\\n\", lprefix, labelno);\t\\\n+\t    fprintf (FILE, \"\\tcall *%s_mcount_ptr\\n\", prefix);\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\telse\t\t\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    static int call_no = 0;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t    fprintf (FILE, \"\\tcall %sPc%d\\n\", lprefix, call_no);\t\\\n+\t    fprintf (FILE, \"%sPc%d:\\tpopl %%eax\\n\", lprefix, call_no);\t\\\n+\t    fprintf (FILE, \"\\taddl $_GLOBAL_OFFSET_TABLE_+[.-%sPc%d],%%eax\\n\", \\\n+\t\t     lprefix, call_no++);\t\t\t\t\\\n+\t    fprintf (FILE, \"\\tleal %sP%d@GOTOFF(%%eax),%%edx\\n\",\t\\\n+\t\t     lprefix, labelno);\t\t\t\t\t\\\n+\t    fprintf (FILE, \"\\tmovl %s_mcount_ptr@GOT(%%eax),%%eax\\n\",\t\\\n+\t\t     prefix);\t\t\t\t\t\t\\\n+\t    fprintf (FILE, \"\\tcall *(%%eax)\\n\");\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    function_prologue (FILE, SIZE);\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+\n+/* A C statement or compound statement to output to FILE some assembler code to\n+   call the profiling subroutine `mcount'.  Before calling, the assembler code\n+   must load the address of a counter variable into a register where `mcount'\n+   expects to find the address.  The name of this variable is `LP' followed by\n+   the number LABELNO, so you would generate the name using `LP%d' in a\n+   `fprintf'.\n+\n+   The details of how the address should be passed to `mcount' are determined\n+   by your operating system environment, not by GNU CC.  To figure them out,\n+   compile a small program for profiling using the system's installed C\n+   compiler and look at the assembler code that results. */\n+\n+#undef  FUNCTION_PROFILER\n+#define FUNCTION_PROFILER(FILE, LABELNO)\t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    if (!OSF_PROFILE_BEFORE_PROLOGUE)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tchar *prefix = \"\";\t\t\t\\\n+\tchar *lprefix = LPREFIX;\t\t\t\t\t\\\n+\tint labelno = LABELNO;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t/* Note that OSF/rose blew it in terms of calling mcount,\t\\\n+\t   since OSF/rose prepends a leading underscore, but mcount's\t\\\n+\t   doesn't.  At present, we keep this kludge for ELF as well\t\\\n+\t   to allow old kernels to build profiling.  */\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tif (flag_pic\t\t\t\t\t\t\t\\\n+\t    && !current_function_uses_pic_offset_table\t\t\t\\\n+\t    && !current_function_uses_const_pool)\t\t\t\\\n+\t  abort ();\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tif (TARGET_MCOUNT && flag_pic)\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    fprintf (FILE, \"\\tleal %sP%d@GOTOFF(%%ebx),%%edx\\n\",\t\\\n+\t\t     lprefix, labelno);\t\t\t\t\t\\\n+\t    fprintf (FILE, \"\\tcall *%smcount@GOT(%%ebx)\\n\", prefix);\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\telse if (TARGET_MCOUNT)\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    fprintf (FILE, \"\\tmovl $%sP%d,%%edx\\n\", lprefix, labelno);\t\\\n+\t    fprintf (FILE, \"\\tcall %smcount\\n\", prefix);\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\telse if (flag_pic && frame_pointer_needed)\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    fprintf (FILE, \"\\tmovl 4(%%ebp),%%ecx\\n\");\t\t\t\\\n+\t    fprintf (FILE, \"\\tpushl %%ecx\\n\");\t\t\t\t\\\n+\t    fprintf (FILE, \"\\tleal %sP%d@GOTOFF(%%ebx),%%edx\\n\",\t\\\n+\t\t     lprefix, labelno);\t\t\t\t\t\\\n+\t    fprintf (FILE, \"\\tmovl _mcount_ptr@GOT(%%ebx),%%eax\\n\");\t\\\n+\t    fprintf (FILE, \"\\tcall *(%%eax)\\n\");\t\t\t\\\n+\t    fprintf (FILE, \"\\tpopl %%eax\\n\");\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\telse if (frame_pointer_needed)\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    fprintf (FILE, \"\\tmovl 4(%%ebp),%%ecx\\n\");\t\t\t\\\n+\t    fprintf (FILE, \"\\tpushl %%ecx\\n\");\t\t\t\t\\\n+\t    fprintf (FILE, \"\\tmovl $%sP%d,%%edx\\n\", lprefix, labelno);\t\\\n+\t    fprintf (FILE, \"\\tcall *_mcount_ptr\\n\");\t\t\t\\\n+\t    fprintf (FILE, \"\\tpopl %%eax\\n\");\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\telse\t\t\t\t\t\t\t\t\\\n+\t  abort ();\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+\n+#if defined (CROSS_COMPILE) && defined (HOST_BITS_PER_INT) && defined (HOST_BITS_PER_LONG) && defined (HOST_BITS_PER_LONGLONG)\n+#if (HOST_BITS_PER_INT==32) && (HOST_BITS_PER_LONG==64) && (HOST_BITS_PER_LONGLONG==64)\n+#define REAL_ARITHMETIC\n+#endif\n+#endif"}, {"sha": "af6efa2d0def09db02b7f728500d344490199cd8", "filename": "gcc/config/i386/osf1elfgdb.h", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70bd3dc1961543d10142c8884755cdaf4fd86e7/gcc%2Fconfig%2Fi386%2Fosf1elfgdb.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70bd3dc1961543d10142c8884755cdaf4fd86e7/gcc%2Fconfig%2Fi386%2Fosf1elfgdb.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fosf1elfgdb.h?ref=e70bd3dc1961543d10142c8884755cdaf4fd86e7", "patch": "@@ -0,0 +1,7 @@\n+/* Target definitions for GNU compiler for Intel 80386 running OSF/1 1.3+\n+   with gas and gdb.  */\n+\n+/* Use stabs instead of DWARF debug format.  */\n+#define PREFERRED_DEBUGGING_TYPE DBX_DEBUG\n+\n+#include \"i386/osf1elf.h\""}, {"sha": "77c7df1a6dfd197007082166ecdbdffa3371c206", "filename": "gcc/config/i386/t-osf1elf", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70bd3dc1961543d10142c8884755cdaf4fd86e7/gcc%2Fconfig%2Fi386%2Ft-osf1elf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70bd3dc1961543d10142c8884755cdaf4fd86e7/gcc%2Fconfig%2Fi386%2Ft-osf1elf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Ft-osf1elf?ref=e70bd3dc1961543d10142c8884755cdaf4fd86e7", "patch": "@@ -0,0 +1,18 @@\n+# Assemble startup files.\n+crti.o: $(srcdir)/config/i386/osf1-ci.asm $(GCC_PASSES)\n+\tsed -e '/^!/d' <$(srcdir)/config/i386/osf1-ci.asm >crti.s\n+\t$(GCC_FOR_TARGET) -c -o crti.o crti.s\n+crtn.o: $(srcdir)/config/i386/osf1-cn.asm $(GCC_PASSES)\n+\tsed -e '/^!/d' <$(srcdir)/config/i386/osf1-cn.asm >crtn.s\n+\t$(GCC_FOR_TARGET) -c -o crtn.o crtn.s\n+\n+# The pushl in CTOR initialization interferes with frame pointer elimination.\n+\n+# We need to use -fPIC when we are using gcc to compile the routines in\n+# crtstuff.c.  This is only really needed when we are going to use gcc/g++\n+# to produce a shared library, but since we don't know ahead of time when\n+# we will be doing that, we just always use -fPIC when compiling the\n+# routines in crtstuff.c.\n+\n+CRTSTUFF_T_CFLAGS = -fPIC -fno-omit-frame-pointer\n+TARGET_LIBGCC2_CFLAGS = -fPIC"}, {"sha": "146738107f6e85dd48b20a5f648a6f10c56805af", "filename": "gcc/config/i386/x-osf1elf", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70bd3dc1961543d10142c8884755cdaf4fd86e7/gcc%2Fconfig%2Fi386%2Fx-osf1elf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70bd3dc1961543d10142c8884755cdaf4fd86e7/gcc%2Fconfig%2Fi386%2Fx-osf1elf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fx-osf1elf?ref=e70bd3dc1961543d10142c8884755cdaf4fd86e7", "patch": "@@ -0,0 +1,8 @@\n+# Defaults for OSF/1 1.3+\n+CC\t\t= $(OLDCC)\n+CLIB\t\t= -lld\n+INSTALL\t\t= installbsd -c\n+OLDCC\t\t= /usr/ccs/gcc/gcc\n+X_CFLAGS\t= -static\n+\n+# FIXPROTO_DEFINES = -D_XOPEN_SOURCE"}]}