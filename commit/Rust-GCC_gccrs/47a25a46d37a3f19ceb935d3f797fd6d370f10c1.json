{"sha": "47a25a46d37a3f19ceb935d3f797fd6d370f10c1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDdhMjVhNDZkMzdhM2YxOWNlYjkzNWQzZjc5N2ZkNmQzNzBmMTBjMQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2005-12-02T17:06:50Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2005-12-02T17:06:50Z"}, "message": "alpha.c (alpha_va_start, [...]): Use buildN and fold_buildN where applicable.\n\n2005-12-02  Richard Guenther  <rguenther@suse.de>\n\n\t* config/alpha/alpha.c (alpha_va_start, alpha_gimplify_va_arg_1i,\n\talpha_gimplify_va_arg): Use buildN and fold_buildN where applicable.\n\t* config/frv/frv.c (frv_expand_builtin_va_start): Likewise.\n\t* config/s390/s390.c (s390_va_start, s390_gimplify_va_arg): Likewise.\n\t* config/ia64/ia64.c (ia64_gimplify_va_arg): Likewise.\n\t* config/i386/i386.c (ix86_va_start, ix86_gimplify_va_arg): Likewise.\n\t* config/rs6000/rs6000.c (rs6000_va_start, rs6000_gimplify_va_arg):\n\tLikewise.\n\t* config/sh/sh.c (sh_va_start, sh_gimplify_va_arg_expr,\n\tsh_adjust_unroll_max): Likewise.\n\t* config/c4x/c4x.c (c4x_gimplify_va_arg_expr): Likewise.\n\t* config/pa/pa.c (hppa_gimplify_va_arg_expr): Likewise.\n\t* config/xtensa/xtensa.c (xtensa_va_start, xtensa_gimplify_va_arg_expr):\n\tLikewise.\n\t* config/stormy16/stormy16.c (xstormy16_expand_builtin_va_start):\n\tLikewise.\n\t* config/mips/mips.c (mips_va_start, mips_gimplify_va_arg_expr):\n\tLikewise.\n\nFrom-SVN: r107906", "tree": {"sha": "90f1caf200cda3d26483d4ff07ddcad996ff4c51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/90f1caf200cda3d26483d4ff07ddcad996ff4c51"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47a25a46d37a3f19ceb935d3f797fd6d370f10c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47a25a46d37a3f19ceb935d3f797fd6d370f10c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47a25a46d37a3f19ceb935d3f797fd6d370f10c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47a25a46d37a3f19ceb935d3f797fd6d370f10c1/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a380cd0a3812c6e2fd3d905f01d6e3a0415a00ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a380cd0a3812c6e2fd3d905f01d6e3a0415a00ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a380cd0a3812c6e2fd3d905f01d6e3a0415a00ab"}], "stats": {"total": 563, "additions": 292, "deletions": 271}, "files": [{"sha": "0185109a9ce15e3daa98519566518a6453462f76", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47a25a46d37a3f19ceb935d3f797fd6d370f10c1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47a25a46d37a3f19ceb935d3f797fd6d370f10c1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=47a25a46d37a3f19ceb935d3f797fd6d370f10c1", "patch": "@@ -1,3 +1,24 @@\n+2005-12-02  Richard Guenther  <rguenther@suse.de>\n+\n+\t* config/alpha/alpha.c (alpha_va_start, alpha_gimplify_va_arg_1i,\n+\talpha_gimplify_va_arg): Use buildN and fold_buildN where applicable.\n+\t* config/frv/frv.c (frv_expand_builtin_va_start): Likewise.\n+\t* config/s390/s390.c (s390_va_start, s390_gimplify_va_arg): Likewise.\n+\t* config/ia64/ia64.c (ia64_gimplify_va_arg): Likewise.\n+\t* config/i386/i386.c (ix86_va_start, ix86_gimplify_va_arg): Likewise.\n+\t* config/rs6000/rs6000.c (rs6000_va_start, rs6000_gimplify_va_arg):\n+\tLikewise.\n+\t* config/sh/sh.c (sh_va_start, sh_gimplify_va_arg_expr,\n+\tsh_adjust_unroll_max): Likewise.\n+\t* config/c4x/c4x.c (c4x_gimplify_va_arg_expr): Likewise.\n+\t* config/pa/pa.c (hppa_gimplify_va_arg_expr): Likewise.\n+\t* config/xtensa/xtensa.c (xtensa_va_start, xtensa_gimplify_va_arg_expr):\n+\tLikewise.\n+\t* config/stormy16/stormy16.c (xstormy16_expand_builtin_va_start):\n+\tLikewise.\n+\t* config/mips/mips.c (mips_va_start, mips_gimplify_va_arg_expr):\n+\tLikewise.\n+\n 2005-12-02  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-vrp.c (build_assert_expr_for, process_assert_insertions_for,"}, {"sha": "6824d077570c6c99b5f014fa33f099c5277640b9", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47a25a46d37a3f19ceb935d3f797fd6d370f10c1/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47a25a46d37a3f19ceb935d3f797fd6d370f10c1/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=47a25a46d37a3f19ceb935d3f797fd6d370f10c1", "patch": "@@ -6148,8 +6148,8 @@ alpha_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n     {\n       nextarg = plus_constant (nextarg, offset);\n       nextarg = plus_constant (nextarg, NUM_ARGS * UNITS_PER_WORD);\n-      t = build (MODIFY_EXPR, TREE_TYPE (valist), valist,\n-\t\t make_tree (ptr_type_node, nextarg));\n+      t = build2 (MODIFY_EXPR, TREE_TYPE (valist), valist,\n+\t\t  make_tree (ptr_type_node, nextarg));\n       TREE_SIDE_EFFECTS (t) = 1;\n \n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n@@ -6159,20 +6159,20 @@ alpha_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n       base_field = TYPE_FIELDS (TREE_TYPE (valist));\n       offset_field = TREE_CHAIN (base_field);\n \n-      base_field = build (COMPONENT_REF, TREE_TYPE (base_field),\n-\t\t\t  valist, base_field, NULL_TREE);\n-      offset_field = build (COMPONENT_REF, TREE_TYPE (offset_field),\n-\t\t\t    valist, offset_field, NULL_TREE);\n+      base_field = build3 (COMPONENT_REF, TREE_TYPE (base_field),\n+\t\t\t   valist, base_field, NULL_TREE);\n+      offset_field = build3 (COMPONENT_REF, TREE_TYPE (offset_field),\n+\t\t\t     valist, offset_field, NULL_TREE);\n \n       t = make_tree (ptr_type_node, virtual_incoming_args_rtx);\n-      t = build (PLUS_EXPR, ptr_type_node, t,\n-\t\t build_int_cst (NULL_TREE, offset));\n-      t = build (MODIFY_EXPR, TREE_TYPE (base_field), base_field, t);\n+      t = build2 (PLUS_EXPR, ptr_type_node, t,\n+\t\t  build_int_cst (NULL_TREE, offset));\n+      t = build2 (MODIFY_EXPR, TREE_TYPE (base_field), base_field, t);\n       TREE_SIDE_EFFECTS (t) = 1;\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n       t = build_int_cst (NULL_TREE, NUM_ARGS * UNITS_PER_WORD);\n-      t = build (MODIFY_EXPR, TREE_TYPE (offset_field), offset_field, t);\n+      t = build2 (MODIFY_EXPR, TREE_TYPE (offset_field), offset_field, t);\n       TREE_SIDE_EFFECTS (t) = 1;\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n     }\n@@ -6188,8 +6188,8 @@ alpha_gimplify_va_arg_1 (tree type, tree base, tree offset, tree *pre_p)\n   if (targetm.calls.must_pass_in_stack (TYPE_MODE (type), type))\n     {\n       t = build_int_cst (TREE_TYPE (offset), 6*8);\n-      t = build (MODIFY_EXPR, TREE_TYPE (offset), offset,\n-\t\t build (MAX_EXPR, TREE_TYPE (offset), offset, t));\n+      t = build2 (MODIFY_EXPR, TREE_TYPE (offset), offset,\n+\t\t  build2 (MAX_EXPR, TREE_TYPE (offset), offset, t));\n       gimplify_and_add (t, pre_p);\n     }\n \n@@ -6210,23 +6210,23 @@ alpha_gimplify_va_arg_1 (tree type, tree base, tree offset, tree *pre_p)\n       imag_part = alpha_gimplify_va_arg_1 (TREE_TYPE (type), base,\n \t\t\t\t\t   offset, pre_p);\n \n-      return build (COMPLEX_EXPR, type, real_temp, imag_part);\n+      return build2 (COMPLEX_EXPR, type, real_temp, imag_part);\n     }\n   else if (TREE_CODE (type) == REAL_TYPE)\n     {\n       tree fpaddend, cond, fourtyeight;\n \n       fourtyeight = build_int_cst (TREE_TYPE (addend), 6*8);\n-      fpaddend = fold (build (MINUS_EXPR, TREE_TYPE (addend),\n-\t\t\t      addend, fourtyeight));\n-      cond = fold (build (LT_EXPR, boolean_type_node, addend, fourtyeight));\n-      addend = fold (build (COND_EXPR, TREE_TYPE (addend), cond,\n-\t\t\t    fpaddend, addend));\n+      fpaddend = fold_build2 (MINUS_EXPR, TREE_TYPE (addend),\n+\t\t\t      addend, fourtyeight);\n+      cond = fold_build2 (LT_EXPR, boolean_type_node, addend, fourtyeight);\n+      addend = fold_build3 (COND_EXPR, TREE_TYPE (addend), cond,\n+\t\t\t    fpaddend, addend);\n     }\n \n   /* Build the final address and force that value into a temporary.  */\n-  addr = build (PLUS_EXPR, ptr_type, fold_convert (ptr_type, base),\n-\t        fold_convert (ptr_type, addend));\n+  addr = build2 (PLUS_EXPR, ptr_type, fold_convert (ptr_type, base),\n+\t         fold_convert (ptr_type, addend));\n   internal_post = NULL;\n   gimplify_expr (&addr, pre_p, &internal_post, is_gimple_val, fb_rvalue);\n   append_to_statement_list (internal_post, pre_p);\n@@ -6242,8 +6242,8 @@ alpha_gimplify_va_arg_1 (tree type, tree base, tree offset, tree *pre_p)\n       t = size_binop (MULT_EXPR, t, size_int (8));\n     }\n   t = fold_convert (TREE_TYPE (offset), t);\n-  t = build (MODIFY_EXPR, void_type_node, offset,\n-\t     build (PLUS_EXPR, TREE_TYPE (offset), offset, t));\n+  t = build2 (MODIFY_EXPR, void_type_node, offset,\n+\t      build2 (PLUS_EXPR, TREE_TYPE (offset), offset, t));\n   gimplify_and_add (t, pre_p);\n \n   return build_va_arg_indirect_ref (addr);\n@@ -6260,10 +6260,10 @@ alpha_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n \n   base_field = TYPE_FIELDS (va_list_type_node);\n   offset_field = TREE_CHAIN (base_field);\n-  base_field = build (COMPONENT_REF, TREE_TYPE (base_field),\n-\t\t      valist, base_field, NULL_TREE);\n-  offset_field = build (COMPONENT_REF, TREE_TYPE (offset_field),\n-\t\t\tvalist, offset_field, NULL_TREE);\n+  base_field = build3 (COMPONENT_REF, TREE_TYPE (base_field),\n+\t\t       valist, base_field, NULL_TREE);\n+  offset_field = build3 (COMPONENT_REF, TREE_TYPE (offset_field),\n+\t\t\t valist, offset_field, NULL_TREE);\n \n   /* Pull the fields of the structure out into temporaries.  Since we never\n      modify the base field, we can use a formal temporary.  Sign-extend the\n@@ -6282,8 +6282,8 @@ alpha_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n   r = alpha_gimplify_va_arg_1 (type, base, offset, pre_p);\n \n   /* Stuff the offset temporary back into its field.  */\n-  t = build (MODIFY_EXPR, void_type_node, offset_field,\n-\t     fold_convert (TREE_TYPE (offset_field), offset));\n+  t = build2 (MODIFY_EXPR, void_type_node, offset_field,\n+\t      fold_convert (TREE_TYPE (offset_field), offset));\n   gimplify_and_add (t, pre_p);\n \n   if (indirect)"}, {"sha": "3757523a6208d756c63be65d79cd20131d30442f", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47a25a46d37a3f19ceb935d3f797fd6d370f10c1/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47a25a46d37a3f19ceb935d3f797fd6d370f10c1/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=47a25a46d37a3f19ceb935d3f797fd6d370f10c1", "patch": "@@ -722,8 +722,8 @@ c4x_gimplify_va_arg_expr (tree valist, tree type,\n   if (indirect)\n     type = build_pointer_type (type);\n \n-  t = build (PREDECREMENT_EXPR, TREE_TYPE (valist), valist,\n-\t     build_int_cst (NULL_TREE, int_size_in_bytes (type)));\n+  t = build2 (PREDECREMENT_EXPR, TREE_TYPE (valist), valist,\n+\t      build_int_cst (NULL_TREE, int_size_in_bytes (type)));\n   t = fold_convert (build_pointer_type (type), t);\n   t = build_va_arg_indirect_ref (t);\n "}, {"sha": "4df467a3da44916cae653fc99f07c0895056237c", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47a25a46d37a3f19ceb935d3f797fd6d370f10c1/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47a25a46d37a3f19ceb935d3f797fd6d370f10c1/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=47a25a46d37a3f19ceb935d3f797fd6d370f10c1", "patch": "@@ -2203,8 +2203,8 @@ frv_expand_builtin_va_start (tree valist, rtx nextarg)\n       debug_rtx (nextarg);\n     }\n \n-  t = build (MODIFY_EXPR, TREE_TYPE (valist), valist,\n-\t     make_tree (ptr_type_node, nextarg));\n+  t = build2 (MODIFY_EXPR, TREE_TYPE (valist), valist,\n+\t      make_tree (ptr_type_node, nextarg));\n   TREE_SIDE_EFFECTS (t) = 1;\n \n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);"}, {"sha": "5a394ed4bd957b944d464ccf638cb9d04134c615", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47a25a46d37a3f19ceb935d3f797fd6d370f10c1/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47a25a46d37a3f19ceb935d3f797fd6d370f10c1/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=47a25a46d37a3f19ceb935d3f797fd6d370f10c1", "patch": "@@ -3804,10 +3804,10 @@ ix86_va_start (tree valist, rtx nextarg)\n   f_sav = TREE_CHAIN (f_ovf);\n \n   valist = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (valist)), valist);\n-  gpr = build (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr, NULL_TREE);\n-  fpr = build (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr, NULL_TREE);\n-  ovf = build (COMPONENT_REF, TREE_TYPE (f_ovf), valist, f_ovf, NULL_TREE);\n-  sav = build (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav, NULL_TREE);\n+  gpr = build3 (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr, NULL_TREE);\n+  fpr = build3 (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr, NULL_TREE);\n+  ovf = build3 (COMPONENT_REF, TREE_TYPE (f_ovf), valist, f_ovf, NULL_TREE);\n+  sav = build3 (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav, NULL_TREE);\n \n   /* Count number of gp and fp argument registers used.  */\n   words = current_function_args_info.words;\n@@ -3820,26 +3820,26 @@ ix86_va_start (tree valist, rtx nextarg)\n \n   if (cfun->va_list_gpr_size)\n     {\n-      t = build (MODIFY_EXPR, TREE_TYPE (gpr), gpr,\n-\t\t build_int_cst (NULL_TREE, n_gpr * 8));\n+      t = build2 (MODIFY_EXPR, TREE_TYPE (gpr), gpr,\n+\t\t  build_int_cst (NULL_TREE, n_gpr * 8));\n       TREE_SIDE_EFFECTS (t) = 1;\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n     }\n \n   if (cfun->va_list_fpr_size)\n     {\n-      t = build (MODIFY_EXPR, TREE_TYPE (fpr), fpr,\n-\t\t build_int_cst (NULL_TREE, n_fpr * 16 + 8*REGPARM_MAX));\n+      t = build2 (MODIFY_EXPR, TREE_TYPE (fpr), fpr,\n+\t\t  build_int_cst (NULL_TREE, n_fpr * 16 + 8*REGPARM_MAX));\n       TREE_SIDE_EFFECTS (t) = 1;\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n     }\n \n   /* Find the overflow area.  */\n   t = make_tree (TREE_TYPE (ovf), virtual_incoming_args_rtx);\n   if (words != 0)\n-    t = build (PLUS_EXPR, TREE_TYPE (ovf), t,\n-\t       build_int_cst (NULL_TREE, words * UNITS_PER_WORD));\n-  t = build (MODIFY_EXPR, TREE_TYPE (ovf), ovf, t);\n+    t = build2 (PLUS_EXPR, TREE_TYPE (ovf), t,\n+\t        build_int_cst (NULL_TREE, words * UNITS_PER_WORD));\n+  t = build2 (MODIFY_EXPR, TREE_TYPE (ovf), ovf, t);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n@@ -3848,7 +3848,7 @@ ix86_va_start (tree valist, rtx nextarg)\n       /* Find the register save area.\n \t Prologue of the function save it right above stack frame.  */\n       t = make_tree (TREE_TYPE (sav), frame_pointer_rtx);\n-      t = build (MODIFY_EXPR, TREE_TYPE (sav), sav, t);\n+      t = build2 (MODIFY_EXPR, TREE_TYPE (sav), sav, t);\n       TREE_SIDE_EFFECTS (t) = 1;\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n     }\n@@ -3880,10 +3880,10 @@ ix86_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n   f_sav = TREE_CHAIN (f_ovf);\n \n   valist = build_va_arg_indirect_ref (valist);\n-  gpr = build (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr, NULL_TREE);\n-  fpr = build (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr, NULL_TREE);\n-  ovf = build (COMPONENT_REF, TREE_TYPE (f_ovf), valist, f_ovf, NULL_TREE);\n-  sav = build (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav, NULL_TREE);\n+  gpr = build3 (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr, NULL_TREE);\n+  fpr = build3 (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr, NULL_TREE);\n+  ovf = build3 (COMPONENT_REF, TREE_TYPE (f_ovf), valist, f_ovf, NULL_TREE);\n+  sav = build3 (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav, NULL_TREE);\n \n   indirect_p = pass_by_reference (NULL, TYPE_MODE (type), type, false);\n   if (indirect_p)\n@@ -3965,7 +3965,7 @@ ix86_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n \t\t\t     (REGPARM_MAX - needed_intregs + 1) * 8);\n \t  t = build2 (GE_EXPR, boolean_type_node, gpr, t);\n \t  t2 = build1 (GOTO_EXPR, void_type_node, lab_false);\n-\t  t = build (COND_EXPR, void_type_node, t, t2, NULL_TREE);\n+\t  t = build3 (COND_EXPR, void_type_node, t, t2, NULL_TREE);\n \t  gimplify_and_add (t, pre_p);\n \t}\n       if (needed_sseregs)\n@@ -3975,7 +3975,7 @@ ix86_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n \t\t\t     + REGPARM_MAX * 8);\n \t  t = build2 (GE_EXPR, boolean_type_node, fpr, t);\n \t  t2 = build1 (GOTO_EXPR, void_type_node, lab_false);\n-\t  t = build (COND_EXPR, void_type_node, t, t2, NULL_TREE);\n+\t  t = build3 (COND_EXPR, void_type_node, t, t2, NULL_TREE);\n \t  gimplify_and_add (t, pre_p);\n \t}\n \n@@ -4072,10 +4072,10 @@ ix86_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n   else\n     {\n       HOST_WIDE_INT align = FUNCTION_ARG_BOUNDARY (VOIDmode, type) / 8;\n-      t = build (PLUS_EXPR, TREE_TYPE (ovf), ovf,\n-\t\t build_int_cst (TREE_TYPE (ovf), align - 1));\n-      t = build (BIT_AND_EXPR, TREE_TYPE (t), t,\n-\t\t build_int_cst (TREE_TYPE (t), -align));\n+      t = build2 (PLUS_EXPR, TREE_TYPE (ovf), ovf,\n+\t\t  build_int_cst (TREE_TYPE (ovf), align - 1));\n+      t = build2 (BIT_AND_EXPR, TREE_TYPE (t), t,\n+\t\t  build_int_cst (TREE_TYPE (t), -align));\n     }\n   gimplify_expr (&t, pre_p, NULL, is_gimple_val, fb_rvalue);\n "}, {"sha": "7b9389bbf578b41f1b4551ff468bd9d589fbb8d5", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47a25a46d37a3f19ceb935d3f797fd6d370f10c1/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47a25a46d37a3f19ceb935d3f797fd6d370f10c1/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=47a25a46d37a3f19ceb935d3f797fd6d370f10c1", "patch": "@@ -4260,11 +4260,11 @@ ia64_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n   if ((TREE_CODE (type) == REAL_TYPE || TREE_CODE (type) == INTEGER_TYPE)\n       ? int_size_in_bytes (type) > 8 : TYPE_ALIGN (type) > 8 * BITS_PER_UNIT)\n     {\n-      tree t = build (PLUS_EXPR, TREE_TYPE (valist), valist,\n-\t\t      build_int_cst (NULL_TREE, 2 * UNITS_PER_WORD - 1));\n-      t = build (BIT_AND_EXPR, TREE_TYPE (t), t,\n-\t\t build_int_cst (NULL_TREE, -2 * UNITS_PER_WORD));\n-      t = build (MODIFY_EXPR, TREE_TYPE (valist), valist, t);\n+      tree t = build2 (PLUS_EXPR, TREE_TYPE (valist), valist,\n+\t\t       build_int_cst (NULL_TREE, 2 * UNITS_PER_WORD - 1));\n+      t = build2 (BIT_AND_EXPR, TREE_TYPE (t), t,\n+\t\t  build_int_cst (NULL_TREE, -2 * UNITS_PER_WORD));\n+      t = build2 (MODIFY_EXPR, TREE_TYPE (valist), valist, t);\n       gimplify_and_add (t, pre_p);\n     }\n "}, {"sha": "733b9c6b7bec75de046b11b82036c349f14a225e", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47a25a46d37a3f19ceb935d3f797fd6d370f10c1/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47a25a46d37a3f19ceb935d3f797fd6d370f10c1/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=47a25a46d37a3f19ceb935d3f797fd6d370f10c1", "patch": "@@ -4092,31 +4092,31 @@ mips_va_start (tree valist, rtx nextarg)\n       f_goff = TREE_CHAIN (f_ftop);\n       f_foff = TREE_CHAIN (f_goff);\n \n-      ovfl = build (COMPONENT_REF, TREE_TYPE (f_ovfl), valist, f_ovfl,\n-\t\t    NULL_TREE);\n-      gtop = build (COMPONENT_REF, TREE_TYPE (f_gtop), valist, f_gtop,\n-\t\t    NULL_TREE);\n-      ftop = build (COMPONENT_REF, TREE_TYPE (f_ftop), valist, f_ftop,\n-\t\t    NULL_TREE);\n-      goff = build (COMPONENT_REF, TREE_TYPE (f_goff), valist, f_goff,\n-\t\t    NULL_TREE);\n-      foff = build (COMPONENT_REF, TREE_TYPE (f_foff), valist, f_foff,\n-\t\t    NULL_TREE);\n+      ovfl = build3 (COMPONENT_REF, TREE_TYPE (f_ovfl), valist, f_ovfl,\n+\t\t     NULL_TREE);\n+      gtop = build3 (COMPONENT_REF, TREE_TYPE (f_gtop), valist, f_gtop,\n+\t\t     NULL_TREE);\n+      ftop = build3 (COMPONENT_REF, TREE_TYPE (f_ftop), valist, f_ftop,\n+\t\t     NULL_TREE);\n+      goff = build3 (COMPONENT_REF, TREE_TYPE (f_goff), valist, f_goff,\n+\t\t     NULL_TREE);\n+      foff = build3 (COMPONENT_REF, TREE_TYPE (f_foff), valist, f_foff,\n+\t\t     NULL_TREE);\n \n       /* Emit code to initialize OVFL, which points to the next varargs\n \t stack argument.  CUM->STACK_WORDS gives the number of stack\n \t words used by named arguments.  */\n       t = make_tree (TREE_TYPE (ovfl), virtual_incoming_args_rtx);\n       if (cum->stack_words > 0)\n-\tt = build (PLUS_EXPR, TREE_TYPE (ovfl), t,\n-\t\t   build_int_cst (NULL_TREE,\n-\t\t\t\t  cum->stack_words * UNITS_PER_WORD));\n-      t = build (MODIFY_EXPR, TREE_TYPE (ovfl), ovfl, t);\n+\tt = build2 (PLUS_EXPR, TREE_TYPE (ovfl), t,\n+\t\t    build_int_cst (NULL_TREE,\n+\t\t\t\t   cum->stack_words * UNITS_PER_WORD));\n+      t = build2 (MODIFY_EXPR, TREE_TYPE (ovfl), ovfl, t);\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n       /* Emit code to initialize GTOP, the top of the GPR save area.  */\n       t = make_tree (TREE_TYPE (gtop), virtual_incoming_args_rtx);\n-      t = build (MODIFY_EXPR, TREE_TYPE (gtop), gtop, t);\n+      t = build2 (MODIFY_EXPR, TREE_TYPE (gtop), gtop, t);\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n       /* Emit code to initialize FTOP, the top of the FPR save area.\n@@ -4126,21 +4126,21 @@ mips_va_start (tree valist, rtx nextarg)\n       fpr_offset = gpr_save_area_size + UNITS_PER_FPVALUE - 1;\n       fpr_offset &= ~(UNITS_PER_FPVALUE - 1);\n       if (fpr_offset)\n-\tt = build (PLUS_EXPR, TREE_TYPE (ftop), t,\n-\t\t   build_int_cst (NULL_TREE, -fpr_offset));\n-      t = build (MODIFY_EXPR, TREE_TYPE (ftop), ftop, t);\n+\tt = build2 (PLUS_EXPR, TREE_TYPE (ftop), t,\n+\t\t    build_int_cst (NULL_TREE, -fpr_offset));\n+      t = build2 (MODIFY_EXPR, TREE_TYPE (ftop), ftop, t);\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n       /* Emit code to initialize GOFF, the offset from GTOP of the\n \t next GPR argument.  */\n-      t = build (MODIFY_EXPR, TREE_TYPE (goff), goff,\n-\t\t build_int_cst (NULL_TREE, gpr_save_area_size));\n+      t = build2 (MODIFY_EXPR, TREE_TYPE (goff), goff,\n+\t\t  build_int_cst (NULL_TREE, gpr_save_area_size));\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n       /* Likewise emit code to initialize FOFF, the offset from FTOP\n \t of the next FPR argument.  */\n-      t = build (MODIFY_EXPR, TREE_TYPE (foff), foff,\n-\t\t build_int_cst (NULL_TREE, fpr_save_area_size));\n+      t = build2 (MODIFY_EXPR, TREE_TYPE (foff), foff,\n+\t\t  build_int_cst (NULL_TREE, fpr_save_area_size));\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n     }\n   else\n@@ -4214,16 +4214,16 @@ mips_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p, tree *post_p)\n \n \t [1] and [9] can sometimes be optimized away.  */\n \n-      ovfl = build (COMPONENT_REF, TREE_TYPE (f_ovfl), valist, f_ovfl,\n-\t\t    NULL_TREE);\n+      ovfl = build3 (COMPONENT_REF, TREE_TYPE (f_ovfl), valist, f_ovfl,\n+\t\t     NULL_TREE);\n \n       if (GET_MODE_CLASS (TYPE_MODE (type)) == MODE_FLOAT\n \t  && GET_MODE_SIZE (TYPE_MODE (type)) <= UNITS_PER_FPVALUE)\n \t{\n-\t  top = build (COMPONENT_REF, TREE_TYPE (f_ftop), valist, f_ftop,\n-\t\t       NULL_TREE);\n-\t  off = build (COMPONENT_REF, TREE_TYPE (f_foff), valist, f_foff,\n-\t\t       NULL_TREE);\n+\t  top = build3 (COMPONENT_REF, TREE_TYPE (f_ftop), valist, f_ftop,\n+\t\t        NULL_TREE);\n+\t  off = build3 (COMPONENT_REF, TREE_TYPE (f_foff), valist, f_foff,\n+\t\t        NULL_TREE);\n \n \t  /* When floating-point registers are saved to the stack,\n \t     each one will take up UNITS_PER_HWFPVALUE bytes, regardless\n@@ -4251,42 +4251,42 @@ mips_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p, tree *post_p)\n \t}\n       else\n \t{\n-\t  top = build (COMPONENT_REF, TREE_TYPE (f_gtop), valist, f_gtop,\n-\t\t       NULL_TREE);\n-\t  off = build (COMPONENT_REF, TREE_TYPE (f_goff), valist, f_goff,\n-\t\t       NULL_TREE);\n+\t  top = build3 (COMPONENT_REF, TREE_TYPE (f_gtop), valist, f_gtop,\n+\t\t        NULL_TREE);\n+\t  off = build3 (COMPONENT_REF, TREE_TYPE (f_goff), valist, f_goff,\n+\t\t        NULL_TREE);\n \t  if (rsize > UNITS_PER_WORD)\n \t    {\n \t      /* [1] Emit code for: off &= -rsize.\t*/\n-\t      t = build (BIT_AND_EXPR, TREE_TYPE (off), off,\n-\t\t\t build_int_cst (NULL_TREE, -rsize));\n-\t      t = build (MODIFY_EXPR, TREE_TYPE (off), off, t);\n+\t      t = build2 (BIT_AND_EXPR, TREE_TYPE (off), off,\n+\t\t\t  build_int_cst (NULL_TREE, -rsize));\n+\t      t = build2 (MODIFY_EXPR, TREE_TYPE (off), off, t);\n \t      gimplify_and_add (t, pre_p);\n \t    }\n \t  osize = rsize;\n \t}\n \n       /* [2] Emit code to branch if off == 0.  */\n-      t = build (NE_EXPR, boolean_type_node, off,\n-\t\t build_int_cst (TREE_TYPE (off), 0));\n-      addr = build (COND_EXPR, ptr_type_node, t, NULL, NULL);\n+      t = build2 (NE_EXPR, boolean_type_node, off,\n+\t\t  build_int_cst (TREE_TYPE (off), 0));\n+      addr = build3 (COND_EXPR, ptr_type_node, t, NULL_TREE, NULL_TREE);\n \n       /* [5] Emit code for: off -= rsize.  We do this as a form of\n \t post-increment not available to C.  Also widen for the\n \t coming pointer arithmetic.  */\n       t = fold_convert (TREE_TYPE (off), build_int_cst (NULL_TREE, rsize));\n-      t = build (POSTDECREMENT_EXPR, TREE_TYPE (off), off, t);\n+      t = build2 (POSTDECREMENT_EXPR, TREE_TYPE (off), off, t);\n       t = fold_convert (sizetype, t);\n       t = fold_convert (TREE_TYPE (top), t);\n \n       /* [4] Emit code for: addr_rtx = top - off.  On big endian machines,\n \t the argument has RSIZE - SIZE bytes of leading padding.  */\n-      t = build (MINUS_EXPR, TREE_TYPE (top), top, t);\n+      t = build2 (MINUS_EXPR, TREE_TYPE (top), top, t);\n       if (BYTES_BIG_ENDIAN && rsize > size)\n \t{\n \t  u = fold_convert (TREE_TYPE (t), build_int_cst (NULL_TREE,\n \t\t\t\t\t\t\t  rsize - size));\n-\t  t = build (PLUS_EXPR, TREE_TYPE (t), t, u);\n+\t  t = build2 (PLUS_EXPR, TREE_TYPE (t), t, u);\n \t}\n       COND_EXPR_THEN (addr) = t;\n \n@@ -4295,11 +4295,11 @@ mips_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p, tree *post_p)\n \t  /* [9] Emit: ovfl += ((intptr_t) ovfl + osize - 1) & -osize.  */\n \t  u = fold_convert (TREE_TYPE (ovfl),\n \t\t\t    build_int_cst (NULL_TREE, osize - 1));\n-\t  t = build (PLUS_EXPR, TREE_TYPE (ovfl), ovfl, u);\n+\t  t = build2 (PLUS_EXPR, TREE_TYPE (ovfl), ovfl, u);\n \t  u = fold_convert (TREE_TYPE (ovfl),\n \t\t\t    build_int_cst (NULL_TREE, -osize));\n-\t  t = build (BIT_AND_EXPR, TREE_TYPE (ovfl), t, u);\n-\t  align = build (MODIFY_EXPR, TREE_TYPE (ovfl), ovfl, t);\n+\t  t = build2 (BIT_AND_EXPR, TREE_TYPE (ovfl), t, u);\n+\t  align = build2 (MODIFY_EXPR, TREE_TYPE (ovfl), ovfl, t);\n \t}\n       else\n \talign = NULL;\n@@ -4309,17 +4309,17 @@ mips_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p, tree *post_p)\n \t the argument has OSIZE - SIZE bytes of leading padding.  */\n       u = fold_convert (TREE_TYPE (ovfl),\n \t\t\tbuild_int_cst (NULL_TREE, osize));\n-      t = build (POSTINCREMENT_EXPR, TREE_TYPE (ovfl), ovfl, u);\n+      t = build2 (POSTINCREMENT_EXPR, TREE_TYPE (ovfl), ovfl, u);\n       if (BYTES_BIG_ENDIAN && osize > size)\n \t{\n \t  u = fold_convert (TREE_TYPE (t),\n \t\t\t    build_int_cst (NULL_TREE, osize - size));\n-\t  t = build (PLUS_EXPR, TREE_TYPE (t), t, u);\n+\t  t = build2 (PLUS_EXPR, TREE_TYPE (t), t, u);\n \t}\n \n       /* String [9] and [10,11] together.  */\n       if (align)\n-\tt = build (COMPOUND_EXPR, TREE_TYPE (t), align, t);\n+\tt = build2 (COMPOUND_EXPR, TREE_TYPE (t), align, t);\n       COND_EXPR_ELSE (addr) = t;\n \n       addr = fold_convert (build_pointer_type (type), addr);"}, {"sha": "fee8d1c73afa5a4381d5d1eb0f62220724a6b633", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47a25a46d37a3f19ceb935d3f797fd6d370f10c1/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47a25a46d37a3f19ceb935d3f797fd6d370f10c1/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=47a25a46d37a3f19ceb935d3f797fd6d370f10c1", "patch": "@@ -5853,20 +5853,20 @@ hppa_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p, tree *post_p)\n       /* Args grow down.  Not handled by generic routines.  */\n \n       u = fold_convert (valist_type, size_in_bytes (type));\n-      t = build (MINUS_EXPR, valist_type, valist, u);\n+      t = build2 (MINUS_EXPR, valist_type, valist, u);\n \n       /* Copied from va-pa.h, but we probably don't need to align to\n \t word size, since we generate and preserve that invariant.  */\n       u = build_int_cst (valist_type, (size > 4 ? -8 : -4));\n-      t = build (BIT_AND_EXPR, valist_type, t, u);\n+      t = build2 (BIT_AND_EXPR, valist_type, t, u);\n \n-      t = build (MODIFY_EXPR, valist_type, valist, t);\n+      t = build2 (MODIFY_EXPR, valist_type, valist, t);\n \n       ofs = (8 - size) % 4;\n       if (ofs != 0)\n \t{\n \t  u = fold_convert (valist_type, size_int (ofs));\n-\t  t = build (PLUS_EXPR, valist_type, t, u);\n+\t  t = build2 (PLUS_EXPR, valist_type, t, u);\n \t}\n \n       t = fold_convert (ptr, t);"}, {"sha": "c3fa81aea2e29cb41ad88b450259d1fd3d67c3c8", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47a25a46d37a3f19ceb935d3f797fd6d370f10c1/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47a25a46d37a3f19ceb935d3f797fd6d370f10c1/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=47a25a46d37a3f19ceb935d3f797fd6d370f10c1", "patch": "@@ -5658,10 +5658,10 @@ rs6000_va_start (tree valist, rtx nextarg)\n   f_sav = TREE_CHAIN (f_ovf);\n \n   valist = build_va_arg_indirect_ref (valist);\n-  gpr = build (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr, NULL_TREE);\n-  fpr = build (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr, NULL_TREE);\n-  ovf = build (COMPONENT_REF, TREE_TYPE (f_ovf), valist, f_ovf, NULL_TREE);\n-  sav = build (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav, NULL_TREE);\n+  gpr = build3 (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr, NULL_TREE);\n+  fpr = build3 (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr, NULL_TREE);\n+  ovf = build3 (COMPONENT_REF, TREE_TYPE (f_ovf), valist, f_ovf, NULL_TREE);\n+  sav = build3 (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav, NULL_TREE);\n \n   /* Count number of gp and fp argument registers used.  */\n   words = current_function_args_info.words;\n@@ -5677,26 +5677,26 @@ rs6000_va_start (tree valist, rtx nextarg)\n \n   if (cfun->va_list_gpr_size)\n     {\n-      t = build (MODIFY_EXPR, TREE_TYPE (gpr), gpr,\n-\t\t build_int_cst (NULL_TREE, n_gpr));\n+      t = build2 (MODIFY_EXPR, TREE_TYPE (gpr), gpr,\n+\t\t  build_int_cst (NULL_TREE, n_gpr));\n       TREE_SIDE_EFFECTS (t) = 1;\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n     }\n \n   if (cfun->va_list_fpr_size)\n     {\n-      t = build (MODIFY_EXPR, TREE_TYPE (fpr), fpr,\n-\t\t build_int_cst (NULL_TREE, n_fpr));\n+      t = build2 (MODIFY_EXPR, TREE_TYPE (fpr), fpr,\n+\t\t  build_int_cst (NULL_TREE, n_fpr));\n       TREE_SIDE_EFFECTS (t) = 1;\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n     }\n \n   /* Find the overflow area.  */\n   t = make_tree (TREE_TYPE (ovf), virtual_incoming_args_rtx);\n   if (words != 0)\n-    t = build (PLUS_EXPR, TREE_TYPE (ovf), t,\n-\t       build_int_cst (NULL_TREE, words * UNITS_PER_WORD));\n-  t = build (MODIFY_EXPR, TREE_TYPE (ovf), ovf, t);\n+    t = build2 (PLUS_EXPR, TREE_TYPE (ovf), t,\n+\t        build_int_cst (NULL_TREE, words * UNITS_PER_WORD));\n+  t = build2 (MODIFY_EXPR, TREE_TYPE (ovf), ovf, t);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n@@ -5711,9 +5711,9 @@ rs6000_va_start (tree valist, rtx nextarg)\n   /* Find the register save area.  */\n   t = make_tree (TREE_TYPE (sav), virtual_stack_vars_rtx);\n   if (cfun->machine->varargs_save_offset)\n-    t = build (PLUS_EXPR, TREE_TYPE (sav), t,\n-\t       build_int_cst (NULL_TREE, cfun->machine->varargs_save_offset));\n-  t = build (MODIFY_EXPR, TREE_TYPE (sav), sav, t);\n+    t = build2 (PLUS_EXPR, TREE_TYPE (sav), t,\n+\t        build_int_cst (NULL_TREE, cfun->machine->varargs_save_offset));\n+  t = build2 (MODIFY_EXPR, TREE_TYPE (sav), sav, t);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n }\n@@ -5759,7 +5759,7 @@ rs6000_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n \t      imag_part = rs6000_gimplify_va_arg (valist, elem_type, pre_p,\n \t\t\t\t\t\t  post_p);\n \n-\t      return build (COMPLEX_EXPR, type, real_part, imag_part);\n+\t      return build2 (COMPLEX_EXPR, type, real_part, imag_part);\n \t    }\n \t}\n \n@@ -5773,10 +5773,10 @@ rs6000_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n   f_sav = TREE_CHAIN (f_ovf);\n \n   valist = build_va_arg_indirect_ref (valist);\n-  gpr = build (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr, NULL_TREE);\n-  fpr = build (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr, NULL_TREE);\n-  ovf = build (COMPONENT_REF, TREE_TYPE (f_ovf), valist, f_ovf, NULL_TREE);\n-  sav = build (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav, NULL_TREE);\n+  gpr = build3 (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr, NULL_TREE);\n+  fpr = build3 (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr, NULL_TREE);\n+  ovf = build3 (COMPONENT_REF, TREE_TYPE (f_ovf), valist, f_ovf, NULL_TREE);\n+  sav = build3 (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav, NULL_TREE);\n \n   size = int_size_in_bytes (type);\n   rsize = (size + 3) / 4;\n@@ -5857,7 +5857,7 @@ rs6000_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n \t{\n \t  /* Ensure that we don't find any more args in regs.\n \t     Alignment has taken care of the n_reg == 2 case.  */\n-\t  t = build (MODIFY_EXPR, TREE_TYPE (reg), reg, size_int (8));\n+\t  t = build2 (MODIFY_EXPR, TREE_TYPE (reg), reg, size_int (8));\n \t  gimplify_and_add (t, pre_p);\n \t}\n     }"}, {"sha": "d9dc288e062a5b530345df4ac24e1e41f0ad17e7", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47a25a46d37a3f19ceb935d3f797fd6d370f10c1/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47a25a46d37a3f19ceb935d3f797fd6d370f10c1/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=47a25a46d37a3f19ceb935d3f797fd6d370f10c1", "patch": "@@ -7493,10 +7493,10 @@ s390_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n   f_sav = TREE_CHAIN (f_ovf);\n \n   valist = build_va_arg_indirect_ref (valist);\n-  gpr = build (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr, NULL_TREE);\n-  fpr = build (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr, NULL_TREE);\n-  ovf = build (COMPONENT_REF, TREE_TYPE (f_ovf), valist, f_ovf, NULL_TREE);\n-  sav = build (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav, NULL_TREE);\n+  gpr = build3 (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr, NULL_TREE);\n+  fpr = build3 (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr, NULL_TREE);\n+  ovf = build3 (COMPONENT_REF, TREE_TYPE (f_ovf), valist, f_ovf, NULL_TREE);\n+  sav = build3 (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav, NULL_TREE);\n \n   /* Count number of gp and fp argument registers used.  */\n \n@@ -7505,16 +7505,16 @@ s390_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n \n   if (cfun->va_list_gpr_size)\n     {\n-      t = build (MODIFY_EXPR, TREE_TYPE (gpr), gpr,\n-\t         build_int_cst (NULL_TREE, n_gpr));\n+      t = build2 (MODIFY_EXPR, TREE_TYPE (gpr), gpr,\n+\t          build_int_cst (NULL_TREE, n_gpr));\n       TREE_SIDE_EFFECTS (t) = 1;\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n     }\n \n   if (cfun->va_list_fpr_size)\n     {\n-      t = build (MODIFY_EXPR, TREE_TYPE (fpr), fpr,\n-\t         build_int_cst (NULL_TREE, n_fpr));\n+      t = build2 (MODIFY_EXPR, TREE_TYPE (fpr), fpr,\n+\t          build_int_cst (NULL_TREE, n_fpr));\n       TREE_SIDE_EFFECTS (t) = 1;\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n     }\n@@ -7531,9 +7531,9 @@ s390_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n \tfprintf (stderr, \"va_start: n_gpr = %d, n_fpr = %d off %d\\n\",\n \t\t (int)n_gpr, (int)n_fpr, off);\n \n-      t = build (PLUS_EXPR, TREE_TYPE (ovf), t, build_int_cst (NULL_TREE, off));\n+      t = build2 (PLUS_EXPR, TREE_TYPE (ovf), t, build_int_cst (NULL_TREE, off));\n \n-      t = build (MODIFY_EXPR, TREE_TYPE (ovf), ovf, t);\n+      t = build2 (MODIFY_EXPR, TREE_TYPE (ovf), ovf, t);\n       TREE_SIDE_EFFECTS (t) = 1;\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n     }\n@@ -7543,10 +7543,10 @@ s390_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n       || (cfun->va_list_fpr_size && n_fpr < FP_ARG_NUM_REG))\n     {\n       t = make_tree (TREE_TYPE (sav), return_address_pointer_rtx);\n-      t = build (PLUS_EXPR, TREE_TYPE (sav), t,\n-\t         build_int_cst (NULL_TREE, -RETURN_REGNUM * UNITS_PER_WORD));\n+      t = build2 (PLUS_EXPR, TREE_TYPE (sav), t,\n+\t          build_int_cst (NULL_TREE, -RETURN_REGNUM * UNITS_PER_WORD));\n   \n-      t = build (MODIFY_EXPR, TREE_TYPE (sav), sav, t);\n+      t = build2 (MODIFY_EXPR, TREE_TYPE (sav), sav, t);\n       TREE_SIDE_EFFECTS (t) = 1;\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n     }\n@@ -7591,10 +7591,10 @@ s390_gimplify_va_arg (tree valist, tree type, tree *pre_p,\n   f_sav = TREE_CHAIN (f_ovf);\n \n   valist = build_va_arg_indirect_ref (valist);\n-  gpr = build (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr, NULL_TREE);\n-  fpr = build (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr, NULL_TREE);\n-  ovf = build (COMPONENT_REF, TREE_TYPE (f_ovf), valist, f_ovf, NULL_TREE);\n-  sav = build (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav, NULL_TREE);\n+  gpr = build3 (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr, NULL_TREE);\n+  fpr = build3 (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr, NULL_TREE);\n+  ovf = build3 (COMPONENT_REF, TREE_TYPE (f_ovf), valist, f_ovf, NULL_TREE);\n+  sav = build3 (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav, NULL_TREE);\n \n   size = int_size_in_bytes (type);\n "}, {"sha": "1cbdd99796b0391c1a69119859ca520d106a8666", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 54, "deletions": 54, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47a25a46d37a3f19ceb935d3f797fd6d370f10c1/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47a25a46d37a3f19ceb935d3f797fd6d370f10c1/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=47a25a46d37a3f19ceb935d3f797fd6d370f10c1", "patch": "@@ -6658,20 +6658,20 @@ sh_va_start (tree valist, rtx nextarg)\n   f_next_fp_limit = TREE_CHAIN (f_next_fp);\n   f_next_stack = TREE_CHAIN (f_next_fp_limit);\n \n-  next_o = build (COMPONENT_REF, TREE_TYPE (f_next_o), valist, f_next_o,\n-\t\t  NULL_TREE);\n-  next_o_limit = build (COMPONENT_REF, TREE_TYPE (f_next_o_limit),\n-\t\t\tvalist, f_next_o_limit, NULL_TREE);\n-  next_fp = build (COMPONENT_REF, TREE_TYPE (f_next_fp), valist, f_next_fp,\n+  next_o = build3 (COMPONENT_REF, TREE_TYPE (f_next_o), valist, f_next_o,\n \t\t   NULL_TREE);\n-  next_fp_limit = build (COMPONENT_REF, TREE_TYPE (f_next_fp_limit),\n-\t\t\t valist, f_next_fp_limit, NULL_TREE);\n-  next_stack = build (COMPONENT_REF, TREE_TYPE (f_next_stack),\n-\t\t      valist, f_next_stack, NULL_TREE);\n+  next_o_limit = build3 (COMPONENT_REF, TREE_TYPE (f_next_o_limit),\n+\t\t\t valist, f_next_o_limit, NULL_TREE);\n+  next_fp = build3 (COMPONENT_REF, TREE_TYPE (f_next_fp), valist, f_next_fp,\n+\t\t    NULL_TREE);\n+  next_fp_limit = build3 (COMPONENT_REF, TREE_TYPE (f_next_fp_limit),\n+\t\t\t  valist, f_next_fp_limit, NULL_TREE);\n+  next_stack = build3 (COMPONENT_REF, TREE_TYPE (f_next_stack),\n+\t\t       valist, f_next_stack, NULL_TREE);\n \n   /* Call __builtin_saveregs.  */\n   u = make_tree (ptr_type_node, expand_builtin_saveregs ());\n-  t = build (MODIFY_EXPR, ptr_type_node, next_fp, u);\n+  t = build2 (MODIFY_EXPR, ptr_type_node, next_fp, u);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n@@ -6680,13 +6680,13 @@ sh_va_start (tree valist, rtx nextarg)\n     nfp = 8 - nfp;\n   else\n     nfp = 0;\n-  u = fold (build (PLUS_EXPR, ptr_type_node, u,\n-\t\t   build_int_cst (NULL_TREE, UNITS_PER_WORD * nfp)));\n-  t = build (MODIFY_EXPR, ptr_type_node, next_fp_limit, u);\n+  u = fold_build2 (PLUS_EXPR, ptr_type_node, u,\n+\t\t   build_int_cst (NULL_TREE, UNITS_PER_WORD * nfp));\n+  t = build2 (MODIFY_EXPR, ptr_type_node, next_fp_limit, u);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n-  t = build (MODIFY_EXPR, ptr_type_node, next_o, u);\n+  t = build2 (MODIFY_EXPR, ptr_type_node, next_o, u);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n@@ -6695,14 +6695,14 @@ sh_va_start (tree valist, rtx nextarg)\n     nint = 4 - nint;\n   else\n     nint = 0;\n-  u = fold (build (PLUS_EXPR, ptr_type_node, u,\n-\t\t   build_int_cst (NULL_TREE, UNITS_PER_WORD * nint)));\n-  t = build (MODIFY_EXPR, ptr_type_node, next_o_limit, u);\n+  u = fold_build2 (PLUS_EXPR, ptr_type_node, u,\n+\t\t   build_int_cst (NULL_TREE, UNITS_PER_WORD * nint));\n+  t = build2 (MODIFY_EXPR, ptr_type_node, next_o_limit, u);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n   u = make_tree (ptr_type_node, nextarg);\n-  t = build (MODIFY_EXPR, ptr_type_node, next_stack, u);\n+  t = build2 (MODIFY_EXPR, ptr_type_node, next_stack, u);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n }\n@@ -6761,16 +6761,16 @@ sh_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p,\n       f_next_fp_limit = TREE_CHAIN (f_next_fp);\n       f_next_stack = TREE_CHAIN (f_next_fp_limit);\n \n-      next_o = build (COMPONENT_REF, TREE_TYPE (f_next_o), valist, f_next_o,\n-\t\t      NULL_TREE);\n-      next_o_limit = build (COMPONENT_REF, TREE_TYPE (f_next_o_limit),\n-\t\t\t    valist, f_next_o_limit, NULL_TREE);\n-      next_fp = build (COMPONENT_REF, TREE_TYPE (f_next_fp),\n-\t\t       valist, f_next_fp, NULL_TREE);\n-      next_fp_limit = build (COMPONENT_REF, TREE_TYPE (f_next_fp_limit),\n-\t\t\t     valist, f_next_fp_limit, NULL_TREE);\n-      next_stack = build (COMPONENT_REF, TREE_TYPE (f_next_stack),\n-\t\t\t  valist, f_next_stack, NULL_TREE);\n+      next_o = build3 (COMPONENT_REF, TREE_TYPE (f_next_o), valist, f_next_o,\n+\t\t       NULL_TREE);\n+      next_o_limit = build3 (COMPONENT_REF, TREE_TYPE (f_next_o_limit),\n+\t\t\t     valist, f_next_o_limit, NULL_TREE);\n+      next_fp = build3 (COMPONENT_REF, TREE_TYPE (f_next_fp),\n+\t\t        valist, f_next_fp, NULL_TREE);\n+      next_fp_limit = build3 (COMPONENT_REF, TREE_TYPE (f_next_fp_limit),\n+\t\t\t      valist, f_next_fp_limit, NULL_TREE);\n+      next_stack = build3 (COMPONENT_REF, TREE_TYPE (f_next_stack),\n+\t\t\t   valist, f_next_stack, NULL_TREE);\n \n       /* Structures with a single member with a distinct mode are passed\n \t like their member.  This is relevant if the latter has a REAL_TYPE\n@@ -6829,19 +6829,19 @@ sh_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p,\n \t  if (size > 4 && !is_double)\n \t    tmp = build2 (PLUS_EXPR, TREE_TYPE (tmp), tmp,\n \t\t\t  fold_convert (TREE_TYPE (tmp), size_int (4 - size)));\n-\t  tmp = build (GE_EXPR, boolean_type_node, next_fp_tmp, tmp);\n-\t  cmp = build (COND_EXPR, void_type_node, tmp,\n-\t\t       build (GOTO_EXPR, void_type_node, lab_false),\n-\t\t       NULL);\n+\t  tmp = build2 (GE_EXPR, boolean_type_node, next_fp_tmp, tmp);\n+\t  cmp = build3 (COND_EXPR, void_type_node, tmp,\n+\t\t        build1 (GOTO_EXPR, void_type_node, lab_false),\n+\t\t        NULL_TREE);\n \t  if (!is_double)\n \t    gimplify_and_add (cmp, pre_p);\n \n \t  if (TYPE_ALIGN (type) > BITS_PER_WORD || (is_double || size == 16))\n \t    {\n \t      tmp = fold_convert (ptr_type_node, size_int (UNITS_PER_WORD));\n-\t      tmp = build (BIT_AND_EXPR, ptr_type_node, next_fp_tmp, tmp);\n-\t      tmp = build (PLUS_EXPR, ptr_type_node, next_fp_tmp, tmp);\n-\t      tmp = build (MODIFY_EXPR, ptr_type_node, next_fp_tmp, tmp);\n+\t      tmp = build2 (BIT_AND_EXPR, ptr_type_node, next_fp_tmp, tmp);\n+\t      tmp = build2 (PLUS_EXPR, ptr_type_node, next_fp_tmp, tmp);\n+\t      tmp = build2 (MODIFY_EXPR, ptr_type_node, next_fp_tmp, tmp);\n \t      gimplify_and_add (tmp, pre_p);\n \t    }\n \t  if (is_double)\n@@ -6861,19 +6861,19 @@ sh_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p,\n \t\t= std_gimplify_va_arg_expr (next_fp_tmp, subtype, pre_p, NULL);\n \t      real = get_initialized_tmp_var (real, pre_p, NULL);\n \n-\t      result = build (COMPLEX_EXPR, type, real, imag);\n+\t      result = build2 (COMPLEX_EXPR, type, real, imag);\n \t      result = get_initialized_tmp_var (result, pre_p, NULL);\n \t    }\n #endif /* FUNCTION_ARG_SCmode_WART */\n \n-\t  tmp = build (GOTO_EXPR, void_type_node, lab_over);\n+\t  tmp = build1 (GOTO_EXPR, void_type_node, lab_over);\n \t  gimplify_and_add (tmp, pre_p);\n \n-\t  tmp = build (LABEL_EXPR, void_type_node, lab_false);\n+\t  tmp = build1 (LABEL_EXPR, void_type_node, lab_false);\n \t  gimplify_and_add (tmp, pre_p);\n \n \t  tmp = build1 (ADDR_EXPR, pptr_type_node, next_stack);\n-\t  tmp = build (MODIFY_EXPR, void_type_node, addr, tmp);\n+\t  tmp = build2 (MODIFY_EXPR, void_type_node, addr, tmp);\n \t  gimplify_and_add (tmp, pre_p);\n \t  tmp = build2 (MODIFY_EXPR, ptr_type_node, next_fp_tmp, valist);\n \t  gimplify_and_add (tmp, pre_p);\n@@ -6885,37 +6885,37 @@ sh_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p,\n       else\n \t{\n \t  tmp = fold_convert (ptr_type_node, size_int (rsize));\n-\t  tmp = build (PLUS_EXPR, ptr_type_node, next_o, tmp);\n-\t  tmp = build (GT_EXPR, boolean_type_node, tmp, next_o_limit);\n-\t  tmp = build (COND_EXPR, void_type_node, tmp,\n-\t\t       build (GOTO_EXPR, void_type_node, lab_false),\n-\t\t       NULL);\n+\t  tmp = build2 (PLUS_EXPR, ptr_type_node, next_o, tmp);\n+\t  tmp = build2 (GT_EXPR, boolean_type_node, tmp, next_o_limit);\n+\t  tmp = build3 (COND_EXPR, void_type_node, tmp,\n+\t\t        build1 (GOTO_EXPR, void_type_node, lab_false),\n+\t\t        NULL_TREE);\n \t  gimplify_and_add (tmp, pre_p);\n \n \t  tmp = build1 (ADDR_EXPR, pptr_type_node, next_o);\n-\t  tmp = build (MODIFY_EXPR, void_type_node, addr, tmp);\n+\t  tmp = build2 (MODIFY_EXPR, void_type_node, addr, tmp);\n \t  gimplify_and_add (tmp, pre_p);\n \n-\t  tmp = build (GOTO_EXPR, void_type_node, lab_over);\n+\t  tmp = build1 (GOTO_EXPR, void_type_node, lab_over);\n \t  gimplify_and_add (tmp, pre_p);\n \n-\t  tmp = build (LABEL_EXPR, void_type_node, lab_false);\n+\t  tmp = build1 (LABEL_EXPR, void_type_node, lab_false);\n \t  gimplify_and_add (tmp, pre_p);\n \n \t  if (size > 4 && ! TARGET_SH4)\n \t    {\n-\t      tmp = build (MODIFY_EXPR, ptr_type_node, next_o, next_o_limit);\n+\t      tmp = build2 (MODIFY_EXPR, ptr_type_node, next_o, next_o_limit);\n \t      gimplify_and_add (tmp, pre_p);\n \t    }\n \n \t  tmp = build1 (ADDR_EXPR, pptr_type_node, next_stack);\n-\t  tmp = build (MODIFY_EXPR, void_type_node, addr, tmp);\n+\t  tmp = build2 (MODIFY_EXPR, void_type_node, addr, tmp);\n \t  gimplify_and_add (tmp, pre_p);\n \t}\n \n       if (!result)\n \t{\n-\t  tmp = build (LABEL_EXPR, void_type_node, lab_over);\n+\t  tmp = build1 (LABEL_EXPR, void_type_node, lab_over);\n \t  gimplify_and_add (tmp, pre_p);\n \t}\n     }\n@@ -6926,10 +6926,10 @@ sh_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p,\n   tmp = std_gimplify_va_arg_expr (valist, type, pre_p, NULL);\n   if (result)\n     {\n-      tmp = build (MODIFY_EXPR, void_type_node, result, tmp);\n+      tmp = build2 (MODIFY_EXPR, void_type_node, result, tmp);\n       gimplify_and_add (tmp, pre_p);\n \n-      tmp = build (LABEL_EXPR, void_type_node, lab_over);\n+      tmp = build1 (LABEL_EXPR, void_type_node, lab_over);\n       gimplify_and_add (tmp, pre_p);\n     }\n   else\n@@ -10279,10 +10279,10 @@ sh_adjust_unroll_max (struct loop * loop, int insn_count,\n \t\t\t  if (TREE_CODE (type) != ARRAY_TYPE\n \t\t\t      || ! TYPE_SIZE (type) || ! TYPE_SIZE_UNIT (type))\n \t\t\t    break;\n-\t\t\t  size_tree = fold (build (TRUNC_DIV_EXPR,\n+\t\t\t  size_tree = fold_build2 (TRUNC_DIV_EXPR,\n \t\t\t\t\t\t   bitsizetype,\n \t\t\t\t\t\t   TYPE_SIZE (type),\n-\t\t\t\t\t\t   TYPE_SIZE_UNIT (type)));\n+\t\t\t\t\t\t   TYPE_SIZE_UNIT (type));\n \t\t\t  if (TREE_CODE (size_tree) == INTEGER_CST\n \t\t\t      && ! TREE_INT_CST_HIGH (size_tree)\n \t\t\t      && TREE_INT_CST_LOW  (size_tree) < max_iterations)"}, {"sha": "3e779248d1aeca64710410d6dbac838d5ba03367", "filename": "gcc/config/stormy16/stormy16.c", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47a25a46d37a3f19ceb935d3f797fd6d370f10c1/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47a25a46d37a3f19ceb935d3f797fd6d370f10c1/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.c?ref=47a25a46d37a3f19ceb935d3f797fd6d370f10c1", "patch": "@@ -1365,20 +1365,20 @@ xstormy16_expand_builtin_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n   f_base = TYPE_FIELDS (va_list_type_node);\n   f_count = TREE_CHAIN (f_base);\n   \n-  base = build (COMPONENT_REF, TREE_TYPE (f_base), valist, f_base, NULL_TREE);\n-  count = build (COMPONENT_REF, TREE_TYPE (f_count), valist, f_count,\n-\t\t NULL_TREE);\n+  base = build3 (COMPONENT_REF, TREE_TYPE (f_base), valist, f_base, NULL_TREE);\n+  count = build3 (COMPONENT_REF, TREE_TYPE (f_count), valist, f_count,\n+\t\t  NULL_TREE);\n \n   t = make_tree (TREE_TYPE (base), virtual_incoming_args_rtx);\n-  t = build (PLUS_EXPR, TREE_TYPE (base), t, \n-\t     build_int_cst (NULL_TREE, INCOMING_FRAME_SP_OFFSET));\n-  t = build (MODIFY_EXPR, TREE_TYPE (base), base, t);\n+  t = build2 (PLUS_EXPR, TREE_TYPE (base), t, \n+\t      build_int_cst (NULL_TREE, INCOMING_FRAME_SP_OFFSET));\n+  t = build2 (MODIFY_EXPR, TREE_TYPE (base), base, t);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n-  t = build (MODIFY_EXPR, TREE_TYPE (count), count, \n-\t     build_int_cst (NULL_TREE,\n-\t\t\t    current_function_args_info * UNITS_PER_WORD));\n+  t = build2 (MODIFY_EXPR, TREE_TYPE (count), count, \n+\t      build_int_cst (NULL_TREE,\n+\t\t\t     current_function_args_info * UNITS_PER_WORD));\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n }\n@@ -1401,9 +1401,9 @@ xstormy16_expand_builtin_va_arg (tree valist, tree type, tree *pre_p,\n   f_base = TYPE_FIELDS (va_list_type_node);\n   f_count = TREE_CHAIN (f_base);\n   \n-  base = build (COMPONENT_REF, TREE_TYPE (f_base), valist, f_base, NULL_TREE);\n-  count = build (COMPONENT_REF, TREE_TYPE (f_count), valist, f_count,\n-\t\t NULL_TREE);\n+  base = build3 (COMPONENT_REF, TREE_TYPE (f_base), valist, f_base, NULL_TREE);\n+  count = build3 (COMPONENT_REF, TREE_TYPE (f_count), valist, f_count,\n+\t\t  NULL_TREE);\n \n   must_stack = targetm.calls.must_pass_in_stack (TYPE_MODE (type), type);\n   size_tree = round_up (size_in_bytes (type), UNITS_PER_WORD);\n@@ -1421,23 +1421,23 @@ xstormy16_expand_builtin_va_arg (tree valist, tree type, tree *pre_p,\n       tree r;\n \n       t = fold_convert (TREE_TYPE (count), size_tree);\n-      t = build (PLUS_EXPR, TREE_TYPE (count), count_tmp, t);\n+      t = build2 (PLUS_EXPR, TREE_TYPE (count), count_tmp, t);\n       r = fold_convert (TREE_TYPE (count), size_int (size_of_reg_args));\n-      t = build (GT_EXPR, boolean_type_node, t, r);\n-      t = build (COND_EXPR, void_type_node, t,\n-\t\t build (GOTO_EXPR, void_type_node, lab_fromstack),\n-\t\t NULL);\n+      t = build2 (GT_EXPR, boolean_type_node, t, r);\n+      t = build3 (COND_EXPR, void_type_node, t,\n+\t\t  build1 (GOTO_EXPR, void_type_node, lab_fromstack),\n+\t\t  NULL_TREE);\n       gimplify_and_add (t, pre_p);\n   \n       t = fold_convert (ptr_type_node, count_tmp);\n-      t = build (PLUS_EXPR, ptr_type_node, base, t);\n-      t = build (MODIFY_EXPR, void_type_node, addr, t);\n+      t = build2 (PLUS_EXPR, ptr_type_node, base, t);\n+      t = build2 (MODIFY_EXPR, void_type_node, addr, t);\n       gimplify_and_add (t, pre_p);\n \n-      t = build (GOTO_EXPR, void_type_node, lab_gotaddr);\n+      t = build1 (GOTO_EXPR, void_type_node, lab_gotaddr);\n       gimplify_and_add (t, pre_p);\n \n-      t = build (LABEL_EXPR, void_type_node, lab_fromstack);\n+      t = build1 (LABEL_EXPR, void_type_node, lab_fromstack);\n       gimplify_and_add (t, pre_p);\n     }\n   \n@@ -1450,31 +1450,31 @@ xstormy16_expand_builtin_va_arg (tree valist, tree type, tree *pre_p,\n       tree r, u;\n \n       r = size_int (NUM_ARGUMENT_REGISTERS * UNITS_PER_WORD);\n-      u = build (MODIFY_EXPR, void_type_node, count_tmp, r);\n+      u = build2 (MODIFY_EXPR, void_type_node, count_tmp, r);\n \n       t = fold_convert (TREE_TYPE (count), r);\n-      t = build (GE_EXPR, boolean_type_node, count_tmp, t);\n-      t = build (COND_EXPR, void_type_node, t, NULL, u);\n+      t = build2 (GE_EXPR, boolean_type_node, count_tmp, t);\n+      t = build3 (COND_EXPR, void_type_node, t, NULL_TREE, u);\n       gimplify_and_add (t, pre_p);\n     }\n \n   t = size_int (NUM_ARGUMENT_REGISTERS * UNITS_PER_WORD\n \t\t- INCOMING_FRAME_SP_OFFSET);\n   t = fold_convert (TREE_TYPE (count), t);\n-  t = build (MINUS_EXPR, TREE_TYPE (count), count_tmp, t);\n-  t = build (PLUS_EXPR, TREE_TYPE (count), t,\n-\t     fold_convert (TREE_TYPE (count), size_tree));\n+  t = build2 (MINUS_EXPR, TREE_TYPE (count), count_tmp, t);\n+  t = build2 (PLUS_EXPR, TREE_TYPE (count), t,\n+\t      fold_convert (TREE_TYPE (count), size_tree));\n   t = fold_convert (TREE_TYPE (base), fold (t));\n-  t = build (MINUS_EXPR, TREE_TYPE (base), base, t);\n-  t = build (MODIFY_EXPR, void_type_node, addr, t);\n+  t = build2 (MINUS_EXPR, TREE_TYPE (base), base, t);\n+  t = build2 (MODIFY_EXPR, void_type_node, addr, t);\n   gimplify_and_add (t, pre_p);\n \n-  t = build (LABEL_EXPR, void_type_node, lab_gotaddr);\n+  t = build1 (LABEL_EXPR, void_type_node, lab_gotaddr);\n   gimplify_and_add (t, pre_p);\n \n   t = fold_convert (TREE_TYPE (count), size_tree);\n-  t = build (PLUS_EXPR, TREE_TYPE (count), count_tmp, t);\n-  t = build (MODIFY_EXPR, TREE_TYPE (count), count, t);\n+  t = build2 (PLUS_EXPR, TREE_TYPE (count), count_tmp, t);\n+  t = build2 (MODIFY_EXPR, TREE_TYPE (count), count, t);\n   gimplify_and_add (t, pre_p);\n   \n   addr = fold_convert (build_pointer_type (type), addr);"}, {"sha": "9dfa3027d9d475c1196c102a0872a62d48349dd1", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47a25a46d37a3f19ceb935d3f797fd6d370f10c1/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47a25a46d37a3f19ceb935d3f797fd6d370f10c1/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=47a25a46d37a3f19ceb935d3f797fd6d370f10c1", "patch": "@@ -2098,21 +2098,21 @@ xtensa_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n   f_reg = TREE_CHAIN (f_stk);\n   f_ndx = TREE_CHAIN (f_reg);\n \n-  stk = build (COMPONENT_REF, TREE_TYPE (f_stk), valist, f_stk, NULL_TREE);\n-  reg = build (COMPONENT_REF, TREE_TYPE (f_reg), valist, f_reg, NULL_TREE);\n-  ndx = build (COMPONENT_REF, TREE_TYPE (f_ndx), valist, f_ndx, NULL_TREE);\n+  stk = build3 (COMPONENT_REF, TREE_TYPE (f_stk), valist, f_stk, NULL_TREE);\n+  reg = build3 (COMPONENT_REF, TREE_TYPE (f_reg), valist, f_reg, NULL_TREE);\n+  ndx = build3 (COMPONENT_REF, TREE_TYPE (f_ndx), valist, f_ndx, NULL_TREE);\n \n   /* Call __builtin_saveregs; save the result in __va_reg */\n   u = make_tree (ptr_type_node, expand_builtin_saveregs ());\n-  t = build (MODIFY_EXPR, ptr_type_node, reg, u);\n+  t = build2 (MODIFY_EXPR, ptr_type_node, reg, u);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n   /* Set the __va_stk member to ($arg_ptr - 32).  */\n   u = make_tree (ptr_type_node, virtual_incoming_args_rtx);\n-  u = fold (build (PLUS_EXPR, ptr_type_node, u,\n-\t\t   build_int_cst (NULL_TREE, -32)));\n-  t = build (MODIFY_EXPR, ptr_type_node, stk, u);\n+  u = fold_build2 (PLUS_EXPR, ptr_type_node, u,\n+\t\t   build_int_cst (NULL_TREE, -32));\n+  t = build2 (MODIFY_EXPR, ptr_type_node, stk, u);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n@@ -2122,7 +2122,7 @@ xtensa_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n   if (arg_words >= MAX_ARGS_IN_REGISTERS)\n     arg_words += 2;\n   u = build_int_cst (NULL_TREE, arg_words * UNITS_PER_WORD);\n-  t = build (MODIFY_EXPR, integer_type_node, ndx, u);\n+  t = build2 (MODIFY_EXPR, integer_type_node, ndx, u);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n }\n@@ -2158,16 +2158,16 @@ xtensa_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p,\n \t\t\t\t\t       pre_p, NULL);\n       imag_part = get_initialized_tmp_var (imag_part, pre_p, NULL);\n \n-      return build (COMPLEX_EXPR, type, real_part, imag_part);\n+      return build2 (COMPLEX_EXPR, type, real_part, imag_part);\n     }\n \n   f_stk = TYPE_FIELDS (va_list_type_node);\n   f_reg = TREE_CHAIN (f_stk);\n   f_ndx = TREE_CHAIN (f_reg);\n \n-  stk = build (COMPONENT_REF, TREE_TYPE (f_stk), valist, f_stk, NULL_TREE);\n-  reg = build (COMPONENT_REF, TREE_TYPE (f_reg), valist, f_reg, NULL_TREE);\n-  ndx = build (COMPONENT_REF, TREE_TYPE (f_ndx), valist, f_ndx, NULL_TREE);\n+  stk = build3 (COMPONENT_REF, TREE_TYPE (f_stk), valist, f_stk, NULL_TREE);\n+  reg = build3 (COMPONENT_REF, TREE_TYPE (f_reg), valist, f_reg, NULL_TREE);\n+  ndx = build3 (COMPONENT_REF, TREE_TYPE (f_ndx), valist, f_ndx, NULL_TREE);\n \n   type_size = size_in_bytes (type);\n   va_size = round_up (type_size, UNITS_PER_WORD);\n@@ -2187,11 +2187,11 @@ xtensa_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p,\n     {\n       int align = TYPE_ALIGN (type) / BITS_PER_UNIT;\n \n-      t = build (PLUS_EXPR, integer_type_node, orig_ndx,\n-\t\t build_int_cst (NULL_TREE, align - 1));\n-      t = build (BIT_AND_EXPR, integer_type_node, t,\n-\t\t build_int_cst (NULL_TREE, -align));\n-      t = build (MODIFY_EXPR, integer_type_node, orig_ndx, t);\n+      t = build2 (PLUS_EXPR, integer_type_node, orig_ndx,\n+\t\t  build_int_cst (NULL_TREE, align - 1));\n+      t = build2 (BIT_AND_EXPR, integer_type_node, t,\n+\t\t  build_int_cst (NULL_TREE, -align));\n+      t = build2 (MODIFY_EXPR, integer_type_node, orig_ndx, t);\n       gimplify_and_add (t, pre_p);\n     }\n \n@@ -2201,8 +2201,8 @@ xtensa_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p,\n      (AP).__va_ndx = orig_ndx + __va_size (TYPE); */\n \n   t = fold_convert (integer_type_node, va_size);\n-  t = build (PLUS_EXPR, integer_type_node, orig_ndx, t);\n-  t = build (MODIFY_EXPR, integer_type_node, ndx, t);\n+  t = build2 (PLUS_EXPR, integer_type_node, orig_ndx, t);\n+  t = build2 (MODIFY_EXPR, integer_type_node, ndx, t);\n   gimplify_and_add (t, pre_p);\n \n \n@@ -2221,19 +2221,19 @@ xtensa_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p,\n       lab_over = create_artificial_label ();\n \n       t = build_int_cst (NULL_TREE, MAX_ARGS_IN_REGISTERS * UNITS_PER_WORD);\n-      t = build (GT_EXPR, boolean_type_node, ndx, t);\n-      t = build (COND_EXPR, void_type_node, t,\n-\t\t build (GOTO_EXPR, void_type_node, lab_false),\n-\t\t NULL);\n+      t = build2 (GT_EXPR, boolean_type_node, ndx, t);\n+      t = build3 (COND_EXPR, void_type_node, t,\n+\t\t  build1 (GOTO_EXPR, void_type_node, lab_false),\n+\t\t  NULL_TREE);\n       gimplify_and_add (t, pre_p);\n \n-      t = build (MODIFY_EXPR, void_type_node, array, reg);\n+      t = build2 (MODIFY_EXPR, void_type_node, array, reg);\n       gimplify_and_add (t, pre_p);\n \n-      t = build (GOTO_EXPR, void_type_node, lab_over);\n+      t = build1 (GOTO_EXPR, void_type_node, lab_over);\n       gimplify_and_add (t, pre_p);\n \n-      t = build (LABEL_EXPR, void_type_node, lab_false);\n+      t = build1 (LABEL_EXPR, void_type_node, lab_false);\n       gimplify_and_add (t, pre_p);\n     }\n \n@@ -2251,26 +2251,26 @@ xtensa_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p,\n   lab_false2 = create_artificial_label ();\n \n   t = build_int_cst (NULL_TREE, MAX_ARGS_IN_REGISTERS * UNITS_PER_WORD);\n-  t = build (GT_EXPR, boolean_type_node, orig_ndx, t);\n-  t = build (COND_EXPR, void_type_node, t,\n-\t     build (GOTO_EXPR, void_type_node, lab_false2),\n-\t     NULL);\n+  t = build2 (GT_EXPR, boolean_type_node, orig_ndx, t);\n+  t = build3 (COND_EXPR, void_type_node, t,\n+\t      build1 (GOTO_EXPR, void_type_node, lab_false2),\n+\t      NULL_TREE);\n   gimplify_and_add (t, pre_p);\n \n   t = size_binop (PLUS_EXPR, va_size, size_int (32));\n   t = fold_convert (integer_type_node, t);\n-  t = build (MODIFY_EXPR, integer_type_node, ndx, t);\n+  t = build2 (MODIFY_EXPR, integer_type_node, ndx, t);\n   gimplify_and_add (t, pre_p);\n \n-  t = build (LABEL_EXPR, void_type_node, lab_false2);\n+  t = build1 (LABEL_EXPR, void_type_node, lab_false2);\n   gimplify_and_add (t, pre_p);\n \n-  t = build (MODIFY_EXPR, void_type_node, array, stk);\n+  t = build2 (MODIFY_EXPR, void_type_node, array, stk);\n   gimplify_and_add (t, pre_p);\n \n   if (lab_over)\n     {\n-      t = build (LABEL_EXPR, void_type_node, lab_over);\n+      t = build1 (LABEL_EXPR, void_type_node, lab_over);\n       gimplify_and_add (t, pre_p);\n     }\n \n@@ -2289,17 +2289,17 @@ xtensa_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p,\n   if (BYTES_BIG_ENDIAN && TREE_CODE (type_size) == INTEGER_CST)\n     {\n       t = size_int (PARM_BOUNDARY / BITS_PER_UNIT);\n-      t = fold (build (GE_EXPR, boolean_type_node, type_size, t));\n-      t = fold (build (COND_EXPR, sizetype, t, va_size, type_size));\n+      t = fold_build2 (GE_EXPR, boolean_type_node, type_size, t);\n+      t = fold_build3 (COND_EXPR, sizetype, t, va_size, type_size);\n       size = t;\n     }\n   else\n     size = va_size;\n \n   t = fold_convert (ptr_type_node, ndx);\n-  addr = build (PLUS_EXPR, ptr_type_node, array, t);\n+  addr = build2 (PLUS_EXPR, ptr_type_node, array, t);\n   t = fold_convert (ptr_type_node, size);\n-  addr = build (MINUS_EXPR, ptr_type_node, addr, t);\n+  addr = build2 (MINUS_EXPR, ptr_type_node, addr, t);\n \n   addr = fold_convert (build_pointer_type (type), addr);\n   if (indirect)"}]}