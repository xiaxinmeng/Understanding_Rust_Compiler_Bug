{"sha": "2608d8414085d05d05fae8cba70ac22c8fe2c8d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjYwOGQ4NDE0MDg1ZDA1ZDA1ZmFlOGNiYTcwYWMyMmM4ZmUyYzhkMA==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2012-01-19T20:46:31Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2012-01-19T20:46:31Z"}, "message": "re PR rtl-optimization/40761 (IRA memory hog for insanely nested loops)\n\n2012-01-19  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR rtl-optimization/40761\n\t* ira-int.h (struct ira_loop_tree_node): Add comment for member\n\tloop.  Add new member loop_num.\n\t(IRA_LOOP_NODE_BY_INDEX): Modify the check.\n\t(ira_build): Remove the parameter.\n\n\t* ira.c (ira_print_disposition): Use loop_num instead of\n\tloop->num.\n\t(ira.c): Do not build CFG loops for one region allocation.  Remove\n\targument from ira_build call.\n\n\t* ira-build.c (init_loop_tree_node): New function.\n\t(create_loop_tree_nodes): Use it.  Separate the case when CFG\n\tloops are not built.\n\t(more_one_region_p): Check current_loops.\n\t(finish_loop_tree_nodes): Separate the case when CFG loops are not\n\tbuilt.\n\t(add_loop_to_tree): Process loop equal to NULL too.\n\t(form_loop_tree): Separate the case when CFG loops are not built.\n\tUse explicitly number for the root.\n\t(rebuild_regno_allocno_maps, create_loop_tree_node_allocnos): Add\n\tan assertion.\n\t(ira_print_expanded_allocno, loop_compare_func): Use loop_num\n\tinstead of loop->num.\n\t(mark_loops_for_removal): Ditto.  Use loop_num instead of\n\tloop->num.\n\t(mark_all_loops_for_removal): Ditto.\n\t(remove_unnecessary_regions): Separate the case when CFG loops\n\tare not built.\n\t(ira_build): Remove the parameter.  Use explicit number of regions\n\twhen CFG loops are not built.\n\n\t* ira-color.c (print_loop_title): Separate the case for the root\n\tnode.  Use loop_num instead of loop->num.\n\t(move_spill_restore): Use loop_num instead of loop->num.\n\n\t* ira-emit.c (setup_entered_from_non_parent_p): Add an assertion.\n\t(change_loop): Ditto.\n\t(change_loop): Use loop_num instead of loop->num.\n\n\t* ira-lives.c (process_bb_node_lives): Ditto.\n\n\t* ira-costs.c (print_allocno_costs, find_costs_and_classes):\n\tDitto.\n\n\t* ira-conflicts.c (print_allocno_conflicts): Ditto.\n\nFrom-SVN: r183312", "tree": {"sha": "0d29df176c3620279d71202389bdc2b5691fc410", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0d29df176c3620279d71202389bdc2b5691fc410"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2608d8414085d05d05fae8cba70ac22c8fe2c8d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2608d8414085d05d05fae8cba70ac22c8fe2c8d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2608d8414085d05d05fae8cba70ac22c8fe2c8d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2608d8414085d05d05fae8cba70ac22c8fe2c8d0/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8e19c582b18e18030c172cca406b5607114f80cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e19c582b18e18030c172cca406b5607114f80cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e19c582b18e18030c172cca406b5607114f80cc"}], "stats": {"total": 292, "additions": 193, "deletions": 99}, "files": [{"sha": "1266cd52df299c94abfaec08760e6081dd807adc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2608d8414085d05d05fae8cba70ac22c8fe2c8d0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2608d8414085d05d05fae8cba70ac22c8fe2c8d0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2608d8414085d05d05fae8cba70ac22c8fe2c8d0", "patch": "@@ -1,3 +1,52 @@\n+2012-01-19  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR rtl-optimization/40761\n+\t* ira-int.h (struct ira_loop_tree_node): Add comment for member\n+\tloop.  Add new member loop_num.\n+\t(IRA_LOOP_NODE_BY_INDEX): Modify the check.\n+\t(ira_build): Remove the parameter.\n+\n+\t* ira.c (ira_print_disposition): Use loop_num instead of\n+\tloop->num.\n+\t(ira.c): Do not build CFG loops for one region allocation.  Remove\n+\targument from ira_build call.\n+\n+\t* ira-build.c (init_loop_tree_node): New function.\n+\t(create_loop_tree_nodes): Use it.  Separate the case when CFG\n+\tloops are not built.\n+\t(more_one_region_p): Check current_loops.\n+\t(finish_loop_tree_nodes): Separate the case when CFG loops are not\n+\tbuilt.\n+\t(add_loop_to_tree): Process loop equal to NULL too.\n+\t(form_loop_tree): Separate the case when CFG loops are not built.\n+\tUse explicitly number for the root.\n+\t(rebuild_regno_allocno_maps, create_loop_tree_node_allocnos): Add\n+\tan assertion.\n+\t(ira_print_expanded_allocno, loop_compare_func): Use loop_num\n+\tinstead of loop->num.\n+\t(mark_loops_for_removal): Ditto.  Use loop_num instead of\n+\tloop->num.\n+\t(mark_all_loops_for_removal): Ditto.\n+\t(remove_unnecessary_regions): Separate the case when CFG loops\n+\tare not built.\n+\t(ira_build): Remove the parameter.  Use explicit number of regions\n+\twhen CFG loops are not built.\n+\n+\t* ira-color.c (print_loop_title): Separate the case for the root\n+\tnode.  Use loop_num instead of loop->num.\n+\t(move_spill_restore): Use loop_num instead of loop->num.\n+\n+\t* ira-emit.c (setup_entered_from_non_parent_p): Add an assertion.\n+\t(change_loop): Ditto.\n+\t(change_loop): Use loop_num instead of loop->num.\n+\n+\t* ira-lives.c (process_bb_node_lives): Ditto.\n+\n+\t* ira-costs.c (print_allocno_costs, find_costs_and_classes):\n+\tDitto.\n+\n+\t* ira-conflicts.c (print_allocno_conflicts): Ditto.\n+\n 2012-01-19  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR libmudflap/40778"}, {"sha": "78d0b36acda431e8082ffda67a27939193804fa8", "filename": "gcc/ira-build.c", "status": "modified", "additions": 95, "deletions": 67, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2608d8414085d05d05fae8cba70ac22c8fe2c8d0/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2608d8414085d05d05fae8cba70ac22c8fe2c8d0/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=2608d8414085d05d05fae8cba70ac22c8fe2c8d0", "patch": "@@ -93,15 +93,35 @@ int ira_copies_num;\n    basic block.  */\n static int last_basic_block_before_change;\n \n-/* The following function allocates the loop tree nodes.  If LOOPS_P\n-   is FALSE, the nodes corresponding to the loops (except the root\n-   which corresponds the all function) will be not allocated but nodes\n-   will still be allocated for basic blocks.  */\n+/* Initialize some members in loop tree node NODE.  Use LOOP_NUM for\n+   the member loop_num.  */\n static void\n-create_loop_tree_nodes (bool loops_p)\n+init_loop_tree_node (struct ira_loop_tree_node *node, int loop_num)\n+{\n+  int max_regno = max_reg_num ();\n+\n+  node->regno_allocno_map\n+    = (ira_allocno_t *) ira_allocate (sizeof (ira_allocno_t) * max_regno);\n+  memset (node->regno_allocno_map, 0, sizeof (ira_allocno_t) * max_regno);\n+  memset (node->reg_pressure, 0, sizeof (node->reg_pressure));\n+  node->all_allocnos = ira_allocate_bitmap ();\n+  node->modified_regnos = ira_allocate_bitmap ();\n+  node->border_allocnos = ira_allocate_bitmap ();\n+  node->local_copies = ira_allocate_bitmap ();\n+  node->loop_num = loop_num;\n+  node->children = NULL;\n+  node->subloops = NULL;\n+}\n+\n+\n+/* The following function allocates the loop tree nodes.  If\n+   CURRENT_LOOPS is NULL, the nodes corresponding to the loops (except\n+   the root which corresponds the all function) will be not allocated\n+   but nodes will still be allocated for basic blocks.  */\n+static void\n+create_loop_tree_nodes (void)\n {\n   unsigned int i, j;\n-  int max_regno;\n   bool skip_p;\n   edge_iterator ei;\n   edge e;\n@@ -122,17 +142,21 @@ create_loop_tree_nodes (bool loops_p)\n       ira_bb_nodes[i].border_allocnos = NULL;\n       ira_bb_nodes[i].local_copies = NULL;\n     }\n+  if (current_loops == NULL)\n+    {\n+      ira_loop_nodes = ((struct ira_loop_tree_node *)\n+\t\t\tira_allocate (sizeof (struct ira_loop_tree_node)));\n+      init_loop_tree_node (ira_loop_nodes, 0);\n+      return;\n+    }\n   ira_loop_nodes = ((struct ira_loop_tree_node *)\n \t\t    ira_allocate (sizeof (struct ira_loop_tree_node)\n \t\t\t\t  * VEC_length (loop_p, ira_loops.larray)));\n-  max_regno = max_reg_num ();\n   FOR_EACH_VEC_ELT (loop_p, ira_loops.larray, i, loop)\n     {\n       if (loop != ira_loops.tree_root)\n \t{\n \t  ira_loop_nodes[i].regno_allocno_map = NULL;\n-\t  if (! loops_p)\n-\t    continue;\n \t  skip_p = false;\n \t  FOR_EACH_EDGE (e, ei, loop->header->preds)\n \t    if (e->src != loop->latch\n@@ -154,16 +178,7 @@ create_loop_tree_nodes (bool loops_p)\n \t  if (skip_p)\n \t    continue;\n \t}\n-      ira_loop_nodes[i].regno_allocno_map\n-\t= (ira_allocno_t *) ira_allocate (sizeof (ira_allocno_t) * max_regno);\n-      memset (ira_loop_nodes[i].regno_allocno_map, 0,\n-\t      sizeof (ira_allocno_t) * max_regno);\n-      memset (ira_loop_nodes[i].reg_pressure, 0,\n-\t      sizeof (ira_loop_nodes[i].reg_pressure));\n-      ira_loop_nodes[i].all_allocnos = ira_allocate_bitmap ();\n-      ira_loop_nodes[i].modified_regnos = ira_allocate_bitmap ();\n-      ira_loop_nodes[i].border_allocnos = ira_allocate_bitmap ();\n-      ira_loop_nodes[i].local_copies = ira_allocate_bitmap ();\n+      init_loop_tree_node (&ira_loop_nodes[i], loop->num);\n     }\n }\n \n@@ -175,10 +190,11 @@ more_one_region_p (void)\n   unsigned int i;\n   loop_p loop;\n \n-  FOR_EACH_VEC_ELT (loop_p, ira_loops.larray, i, loop)\n-    if (ira_loop_nodes[i].regno_allocno_map != NULL\n-\t&& ira_loop_tree_root != &ira_loop_nodes[i])\n-      return true;\n+  if (current_loops != NULL)\n+    FOR_EACH_VEC_ELT (loop_p, ira_loops.larray, i, loop)\n+      if (ira_loop_nodes[i].regno_allocno_map != NULL\n+\t  && ira_loop_tree_root != &ira_loop_nodes[i])\n+\treturn true;\n   return false;\n }\n \n@@ -205,8 +221,11 @@ finish_loop_tree_nodes (void)\n   unsigned int i;\n   loop_p loop;\n \n-  FOR_EACH_VEC_ELT (loop_p, ira_loops.larray, i, loop)\n-    finish_loop_tree_node (&ira_loop_nodes[i]);\n+  if (current_loops == NULL)\n+    finish_loop_tree_node (&ira_loop_nodes[0]);\n+  else\n+    FOR_EACH_VEC_ELT (loop_p, ira_loops.larray, i, loop)\n+      finish_loop_tree_node (&ira_loop_nodes[i]);\n   ira_free (ira_loop_nodes);\n   for (i = 0; i < (unsigned int) last_basic_block_before_change; i++)\n     {\n@@ -227,30 +246,39 @@ finish_loop_tree_nodes (void)\n \f\n \n /* The following recursive function adds LOOP to the loop tree\n-   hierarchy.  LOOP is added only once.  */\n+   hierarchy.  LOOP is added only once.  If LOOP is NULL we adding\n+   loop designating the whole function when CFG loops are not\n+   built.  */\n static void\n add_loop_to_tree (struct loop *loop)\n {\n+  int loop_num;\n   struct loop *parent;\n   ira_loop_tree_node_t loop_node, parent_node;\n \n   /* We can not use loop node access macros here because of potential\n      checking and because the nodes are not initialized enough\n      yet.  */\n-  if (loop_outer (loop) != NULL)\n+  if (loop != NULL && loop_outer (loop) != NULL)\n     add_loop_to_tree (loop_outer (loop));\n-  if (ira_loop_nodes[loop->num].regno_allocno_map != NULL\n-      && ira_loop_nodes[loop->num].children == NULL)\n+  loop_num = loop != NULL ? loop->num : 0;\n+  if (ira_loop_nodes[loop_num].regno_allocno_map != NULL\n+      && ira_loop_nodes[loop_num].children == NULL)\n     {\n       /* We have not added loop node to the tree yet.  */\n-      loop_node = &ira_loop_nodes[loop->num];\n+      loop_node = &ira_loop_nodes[loop_num];\n       loop_node->loop = loop;\n       loop_node->bb = NULL;\n-      for (parent = loop_outer (loop);\n-\t   parent != NULL;\n-\t   parent = loop_outer (parent))\n-\tif (ira_loop_nodes[parent->num].regno_allocno_map != NULL)\n-\t  break;\n+      if (loop == NULL)\n+\tparent = NULL;\n+      else\n+\t{\n+\t  for (parent = loop_outer (loop);\n+\t       parent != NULL;\n+\t       parent = loop_outer (parent))\n+\t    if (ira_loop_nodes[parent->num].regno_allocno_map != NULL)\n+\t      break;\n+\t}\n       if (parent == NULL)\n \t{\n \t  loop_node->next = NULL;\n@@ -299,21 +327,13 @@ setup_loop_tree_level (ira_loop_tree_node_t loop_node, int level)\n static void\n form_loop_tree (void)\n {\n-  unsigned int i;\n   basic_block bb;\n   struct loop *parent;\n   ira_loop_tree_node_t bb_node, loop_node;\n-  loop_p loop;\n \n   /* We can not use loop/bb node access macros because of potential\n      checking and because the nodes are not initialized enough\n      yet.  */\n-  FOR_EACH_VEC_ELT (loop_p, ira_loops.larray, i, loop)\n-     if (ira_loop_nodes[i].regno_allocno_map != NULL)\n-       {\n-\t ira_loop_nodes[i].children = NULL;\n-\t ira_loop_nodes[i].subloops = NULL;\n-       }\n   FOR_EACH_BB (bb)\n     {\n       bb_node = &ira_bb_nodes[bb->index];\n@@ -323,18 +343,23 @@ form_loop_tree (void)\n       bb_node->children = NULL;\n       bb_node->subloop_next = NULL;\n       bb_node->next = NULL;\n-      for (parent = bb->loop_father;\n-\t   parent != NULL;\n-\t   parent = loop_outer (parent))\n-\tif (ira_loop_nodes[parent->num].regno_allocno_map != NULL)\n-\t  break;\n+      if (current_loops == NULL)\n+\tparent = NULL;\n+      else\n+\t{\n+\t  for (parent = bb->loop_father;\n+\t       parent != NULL;\n+\t       parent = loop_outer (parent))\n+\t    if (ira_loop_nodes[parent->num].regno_allocno_map != NULL)\n+\t      break;\n+\t}\n       add_loop_to_tree (parent);\n-      loop_node = &ira_loop_nodes[parent->num];\n+      loop_node = &ira_loop_nodes[parent == NULL ? 0 : parent->num];\n       bb_node->next = loop_node->children;\n       bb_node->parent = loop_node;\n       loop_node->children = bb_node;\n     }\n-  ira_loop_tree_root = IRA_LOOP_NODE_BY_INDEX (ira_loops.tree_root->num);\n+  ira_loop_tree_root = IRA_LOOP_NODE_BY_INDEX (0);\n   ira_loop_tree_height = setup_loop_tree_level (ira_loop_tree_root, 0);\n   ira_assert (ira_loop_tree_root->regno_allocno_map != NULL);\n }\n@@ -353,6 +378,7 @@ rebuild_regno_allocno_maps (void)\n   loop_p loop;\n   ira_allocno_iterator ai;\n \n+  ira_assert (current_loops != NULL);\n   max_regno = max_reg_num ();\n   FOR_EACH_VEC_ELT (loop_p, ira_loops.larray, l, loop)\n     if (ira_loop_nodes[l].regno_allocno_map != NULL)\n@@ -837,7 +863,7 @@ ira_print_expanded_allocno (ira_allocno_t a)\n   if ((bb = ALLOCNO_LOOP_TREE_NODE (a)->bb) != NULL)\n     fprintf (ira_dump_file, \",b%d\", bb->index);\n   else\n-    fprintf (ira_dump_file, \",l%d\", ALLOCNO_LOOP_TREE_NODE (a)->loop->num);\n+    fprintf (ira_dump_file, \",l%d\", ALLOCNO_LOOP_TREE_NODE (a)->loop_num);\n   if (ALLOCNO_CAP_MEMBER (a) != NULL)\n     {\n       fprintf (ira_dump_file, \":\");\n@@ -1621,6 +1647,7 @@ create_loop_tree_node_allocnos (ira_loop_tree_node_t loop_node)\n       edge e;\n       VEC (edge, heap) *edges;\n \n+      ira_assert (current_loops != NULL);\n       FOR_EACH_EDGE (e, ei, loop_node->loop->header->preds)\n \tif (e->src != loop_node->loop->latch)\n \t  create_loop_allocnos (e);\n@@ -1848,7 +1875,7 @@ loop_compare_func (const void *v1p, const void *v2p)\n   if ((diff = (int) loop_depth (l1->loop) - (int) loop_depth (l2->loop)) != 0)\n     return diff;\n   /* Make sorting stable.  */\n-  return l1->loop->num - l2->loop->num;\n+  return l1->loop_num - l2->loop_num;\n }\n \n /* Mark loops which should be removed from regional allocation.  We\n@@ -1870,6 +1897,7 @@ mark_loops_for_removal (void)\n   ira_loop_tree_node_t *sorted_loops;\n   loop_p loop;\n \n+  ira_assert (current_loops != NULL);\n   sorted_loops\n     = (ira_loop_tree_node_t *) ira_allocate (sizeof (ira_loop_tree_node_t)\n \t\t\t\t\t     * VEC_length (loop_p,\n@@ -1900,7 +1928,7 @@ mark_loops_for_removal (void)\n \tfprintf\n \t  (ira_dump_file,\n \t   \"  Mark loop %d (header %d, freq %d, depth %d) for removal (%s)\\n\",\n-\t   sorted_loops[i]->loop->num, sorted_loops[i]->loop->header->index,\n+\t   sorted_loops[i]->loop_num, sorted_loops[i]->loop->header->index,\n \t   sorted_loops[i]->loop->header->frequency,\n \t   loop_depth (sorted_loops[i]->loop),\n \t   low_pressure_loop_node_p (sorted_loops[i]->parent)\n@@ -1917,6 +1945,7 @@ mark_all_loops_for_removal (void)\n   int i;\n   loop_p loop;\n \n+  ira_assert (current_loops != NULL);\n   FOR_EACH_VEC_ELT (loop_p, ira_loops.larray, i, loop)\n     if (ira_loop_nodes[i].regno_allocno_map != NULL)\n       {\n@@ -1931,7 +1960,7 @@ mark_all_loops_for_removal (void)\n \t  fprintf\n \t    (ira_dump_file,\n \t     \"  Mark loop %d (header %d, freq %d, depth %d) for removal\\n\",\n-\t     ira_loop_nodes[i].loop->num,\n+\t     ira_loop_nodes[i].loop_num,\n \t     ira_loop_nodes[i].loop->header->index,\n \t     ira_loop_nodes[i].loop->header->frequency,\n \t     loop_depth (ira_loop_nodes[i].loop));\n@@ -2221,6 +2250,8 @@ remove_low_level_allocnos (void)\n static void\n remove_unnecessary_regions (bool all_p)\n {\n+  if (current_loops == NULL)\n+    return;\n   if (all_p)\n     mark_all_loops_for_removal ();\n   else\n@@ -3026,23 +3057,20 @@ update_conflict_hard_reg_costs (void)\n }\n \n /* Create a internal representation (IR) for IRA (allocnos, copies,\n-   loop tree nodes).  If LOOPS_P is FALSE the nodes corresponding to\n-   the loops (except the root which corresponds the all function) and\n-   correspondingly allocnos for the loops will be not created.  Such\n-   parameter value is used for Chaitin-Briggs coloring.  The function\n-   returns TRUE if we generate loop structure (besides nodes\n-   representing all function and the basic blocks) for regional\n-   allocation.  A true return means that we really need to flatten IR\n-   before the reload.  */\n+   loop tree nodes).  The function returns TRUE if we generate loop\n+   structure (besides nodes representing all function and the basic\n+   blocks) for regional allocation.  A true return means that we\n+   really need to flatten IR before the reload.  */\n bool\n-ira_build (bool loops_p)\n+ira_build (void)\n {\n-  df_analyze ();\n+  bool loops_p;\n \n+  df_analyze ();\n   initiate_cost_vectors ();\n   initiate_allocnos ();\n   initiate_copies ();\n-  create_loop_tree_nodes (loops_p);\n+  create_loop_tree_nodes ();\n   form_loop_tree ();\n   create_allocnos ();\n   ira_costs ();\n@@ -3111,8 +3139,8 @@ ira_build (bool loops_p)\n \t    }\n \t}\n       fprintf (ira_dump_file, \"  regions=%d, blocks=%d, points=%d\\n\",\n-\t       VEC_length (loop_p, ira_loops.larray), n_basic_blocks,\n-\t       ira_max_point);\n+\t       current_loops == NULL ? 1 : VEC_length (loop_p, ira_loops.larray),\n+\t       n_basic_blocks, ira_max_point);\n       fprintf (ira_dump_file,\n \t       \"    allocnos=%d (big %d), copies=%d, conflicts=%d, ranges=%d\\n\",\n \t       ira_allocnos_num, nr_big, ira_copies_num, n, nr);"}, {"sha": "c638e58f333d5ec164225a3c48d7e7f3f9448086", "filename": "gcc/ira-color.c", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2608d8414085d05d05fae8cba70ac22c8fe2c8d0/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2608d8414085d05d05fae8cba70ac22c8fe2c8d0/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=2608d8414085d05d05fae8cba70ac22c8fe2c8d0", "patch": "@@ -1670,7 +1670,6 @@ assign_hard_reg (ira_allocno_t a, bool retry_p)\n       update_conflict_hard_regno_costs (full_costs, aclass, false);\n     }\n   min_cost = min_full_cost = INT_MAX;\n-\n   /* We don't care about giving callee saved registers to allocnos no\n      living through calls because call clobbered registers are\n      allocated first (it is usual practice to put them first in\n@@ -2011,7 +2010,7 @@ ira_loop_edge_freq (ira_loop_tree_node_t loop_node, int regno, bool exit_p)\n   edge e;\n   VEC (edge, heap) *edges;\n \n-  ira_assert (loop_node->loop != NULL\n+  ira_assert (current_loops != NULL && loop_node->loop != NULL\n \t      && (regno < 0 || regno >= FIRST_PSEUDO_REGISTER));\n   freq = 0;\n   if (! exit_p)\n@@ -2662,14 +2661,19 @@ print_loop_title (ira_loop_tree_node_t loop_tree_node)\n   edge e;\n   edge_iterator ei;\n \n-  ira_assert (loop_tree_node->loop != NULL);\n-  fprintf (ira_dump_file,\n-\t   \"\\n  Loop %d (parent %d, header bb%d, depth %d)\\n    bbs:\",\n-\t   loop_tree_node->loop->num,\n-\t   (loop_tree_node->parent == NULL\n-\t    ? -1 : loop_tree_node->parent->loop->num),\n-\t   loop_tree_node->loop->header->index,\n-\t   loop_depth (loop_tree_node->loop));\n+  if (loop_tree_node->parent == NULL)\n+    fprintf (ira_dump_file,\n+\t     \"\\n  Loop 0 (parent -1, header bb%d, depth 0)\\n    bbs:\",\n+\t     NUM_FIXED_BLOCKS);\n+  else\n+    {\n+      ira_assert (current_loops != NULL && loop_tree_node->loop != NULL);\n+      fprintf (ira_dump_file,\n+\t       \"\\n  Loop %d (parent %d, header bb%d, depth %d)\\n    bbs:\",\n+\t       loop_tree_node->loop_num, loop_tree_node->parent->loop_num,\n+\t       loop_tree_node->loop->header->index,\n+\t       loop_depth (loop_tree_node->loop));\n+    }\n   for (subloop_node = loop_tree_node->children;\n        subloop_node != NULL;\n        subloop_node = subloop_node->next)\n@@ -2681,7 +2685,7 @@ print_loop_title (ira_loop_tree_node_t loop_tree_node)\n \t      && ((dest_loop_node = IRA_BB_NODE (e->dest)->parent)\n \t\t  != loop_tree_node))\n \t    fprintf (ira_dump_file, \"(->%d:l%d)\",\n-\t\t     e->dest->index, dest_loop_node->loop->num);\n+\t\t     e->dest->index, dest_loop_node->loop_num);\n       }\n   fprintf (ira_dump_file, \"\\n    all:\");\n   EXECUTE_IF_SET_IN_BITMAP (loop_tree_node->all_allocnos, 0, j, bi)\n@@ -3011,7 +3015,7 @@ move_spill_restore (void)\n \t\t  fprintf\n \t\t    (ira_dump_file,\n \t\t     \"      Moving spill/restore for a%dr%d up from loop %d\",\n-\t\t     ALLOCNO_NUM (a), regno, loop_node->loop->num);\n+\t\t     ALLOCNO_NUM (a), regno, loop_node->loop_num);\n \t\t  fprintf (ira_dump_file, \" - profit %d\\n\", -cost);\n \t\t}\n \t      changed_p = true;"}, {"sha": "a0d36094ed568405c471e7ffae3385b932087253", "filename": "gcc/ira-conflicts.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2608d8414085d05d05fae8cba70ac22c8fe2c8d0/gcc%2Fira-conflicts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2608d8414085d05d05fae8cba70ac22c8fe2c8d0/gcc%2Fira-conflicts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-conflicts.c?ref=2608d8414085d05d05fae8cba70ac22c8fe2c8d0", "patch": "@@ -419,6 +419,7 @@ process_regs_for_copy (rtx reg1, rtx reg2, bool constraint_p,\n     {\n       ira_allocno_t a1 = ira_curr_regno_allocno_map[REGNO (reg1)];\n       ira_allocno_t a2 = ira_curr_regno_allocno_map[REGNO (reg2)];\n+\n       if (!allocnos_conflict_for_copy_p (a1, a2) && offset1 == offset2)\n \t{\n \t  cp = ira_add_allocno_copy (a1, a2, freq, constraint_p, insn,\n@@ -765,7 +766,7 @@ print_allocno_conflicts (FILE * file, bool reg_p, ira_allocno_t a)\n       if ((bb = ALLOCNO_LOOP_TREE_NODE (a)->bb) != NULL)\n         fprintf (file, \"b%d\", bb->index);\n       else\n-        fprintf (file, \"l%d\", ALLOCNO_LOOP_TREE_NODE (a)->loop->num);\n+        fprintf (file, \"l%d\", ALLOCNO_LOOP_TREE_NODE (a)->loop_num);\n       putc (')', file);\n     }\n \n@@ -796,7 +797,7 @@ print_allocno_conflicts (FILE * file, bool reg_p, ira_allocno_t a)\n \t\tfprintf (file, \",b%d\", bb->index);\n \t      else\n \t\tfprintf (file, \",l%d\",\n-\t\t\t ALLOCNO_LOOP_TREE_NODE (conflict_a)->loop->num);\n+\t\t\t ALLOCNO_LOOP_TREE_NODE (conflict_a)->loop_num);\n \t      putc (')', file);\n \t    }\n \t}"}, {"sha": "8e1e846643751b1781fdec86db8e4f9273276e96", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2608d8414085d05d05fae8cba70ac22c8fe2c8d0/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2608d8414085d05d05fae8cba70ac22c8fe2c8d0/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=2608d8414085d05d05fae8cba70ac22c8fe2c8d0", "patch": "@@ -1391,7 +1391,7 @@ print_allocno_costs (FILE *f)\n       if ((bb = ALLOCNO_LOOP_TREE_NODE (a)->bb) != NULL)\n \tfprintf (f, \"b%d\", bb->index);\n       else\n-\tfprintf (f, \"l%d\", ALLOCNO_LOOP_TREE_NODE (a)->loop->num);\n+\tfprintf (f, \"l%d\", ALLOCNO_LOOP_TREE_NODE (a)->loop_num);\n       fprintf (f, \") costs:\");\n       for (k = 0; k < cost_classes_ptr->num; k++)\n \t{\n@@ -1789,7 +1789,7 @@ find_costs_and_classes (FILE *dump_file)\n \t\t    fprintf (dump_file, \"b%d\", bb->index);\n \t\t  else\n \t\t    fprintf (dump_file, \"l%d\",\n-\t\t\t     ALLOCNO_LOOP_TREE_NODE (a)->loop->num);\n+\t\t\t     ALLOCNO_LOOP_TREE_NODE (a)->loop_num);\n \t\t  fprintf (dump_file, \") best %s, allocno %s\\n\",\n \t\t\t   reg_class_names[best],\n \t\t\t   reg_class_names[regno_aclass[i]]);"}, {"sha": "3dcd3241cfc067214be55d0a54859ceb4716c6eb", "filename": "gcc/ira-emit.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2608d8414085d05d05fae8cba70ac22c8fe2c8d0/gcc%2Fira-emit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2608d8414085d05d05fae8cba70ac22c8fe2c8d0/gcc%2Fira-emit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-emit.c?ref=2608d8414085d05d05fae8cba70ac22c8fe2c8d0", "patch": "@@ -438,6 +438,7 @@ setup_entered_from_non_parent_p (void)\n   unsigned int i;\n   loop_p loop;\n \n+  ira_assert (current_loops != NULL);\n   FOR_EACH_VEC_ELT (loop_p, ira_loops.larray, i, loop)\n     if (ira_loop_nodes[i].regno_allocno_map != NULL)\n       ira_loop_nodes[i].entered_from_non_parent_p\n@@ -565,7 +566,8 @@ change_loop (ira_loop_tree_node_t node)\n \n   if (node != ira_loop_tree_root)\n     {\n-\n+      ira_assert (current_loops != NULL);\n+      \n       if (node->bb != NULL)\n \t{\n \t  FOR_BB_INSNS (node->bb, insn)\n@@ -580,7 +582,7 @@ change_loop (ira_loop_tree_node_t node)\n       if (internal_flag_ira_verbose > 3 && ira_dump_file != NULL)\n \tfprintf (ira_dump_file,\n \t\t \"      Changing RTL for loop %d (header bb%d)\\n\",\n-\t\t node->loop->num, node->loop->header->index);\n+\t\t node->loop_num, node->loop->header->index);\n \n       parent = ira_curr_loop_tree_node->parent;\n       map = parent->regno_allocno_map;"}, {"sha": "9faabb5d7036bb6b351795dc295988bd336030d6", "filename": "gcc/ira-int.h", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2608d8414085d05d05fae8cba70ac22c8fe2c8d0/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2608d8414085d05d05fae8cba70ac22c8fe2c8d0/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=2608d8414085d05d05fae8cba70ac22c8fe2c8d0", "patch": "@@ -87,7 +87,8 @@ struct ira_loop_tree_node\n {\n   /* The node represents basic block if children == NULL.  */\n   basic_block bb;    /* NULL for loop.  */\n-  struct loop *loop; /* NULL for BB.  */\n+  /* NULL for BB or for loop tree root if we did not build CFG loop tree.  */\n+  struct loop *loop;\n   /* NEXT/SUBLOOP_NEXT is the next node/loop-node of the same parent.\n      SUBLOOP_NEXT is always NULL for BBs.  */\n   ira_loop_tree_node_t subloop_next, next;\n@@ -103,6 +104,9 @@ struct ira_loop_tree_node\n   /* All the following members are defined only for nodes representing\n      loops.  */\n \n+  /* The loop number from CFG loop tree.  The root number is 0.  */\n+  int loop_num;\n+\n   /* True if the loop was marked for removal from the register\n      allocation.  */\n   bool to_remove_p;\n@@ -154,7 +158,7 @@ extern ira_loop_tree_node_t ira_bb_nodes;\n /* Two access macros to the nodes representing basic blocks.  */\n #if defined ENABLE_IRA_CHECKING && (GCC_VERSION >= 2007)\n #define IRA_BB_NODE_BY_INDEX(index) __extension__\t\t\t\\\n-(({ ira_loop_tree_node_t _node = (&ira_bb_nodes[index]);\t\\\n+(({ ira_loop_tree_node_t _node = (&ira_bb_nodes[index]);\t\t\\\n      if (_node->children != NULL || _node->loop != NULL || _node->bb == NULL)\\\n        {\t\t\t\t\t\t\t\t\\\n          fprintf (stderr,\t\t\t\t\t\t\\\n@@ -176,8 +180,9 @@ extern ira_loop_tree_node_t ira_loop_nodes;\n /* Two access macros to the nodes representing loops.  */\n #if defined ENABLE_IRA_CHECKING && (GCC_VERSION >= 2007)\n #define IRA_LOOP_NODE_BY_INDEX(index) __extension__\t\t\t\\\n-(({ ira_loop_tree_node_t const _node = (&ira_loop_nodes[index]);\\\n-     if (_node->children == NULL || _node->bb != NULL || _node->loop == NULL)\\\n+(({ ira_loop_tree_node_t const _node = (&ira_loop_nodes[index]);\t\\\n+     if (_node->children == NULL || _node->bb != NULL\t\t\t\\\n+         || (_node->loop == NULL && current_loops != NULL))\t\t\\\n        {\t\t\t\t\t\t\t\t\\\n          fprintf (stderr,\t\t\t\t\t\t\\\n                   \"\\n%s: %d: error in %s: it is not a loop node\\n\",\t\\\n@@ -989,7 +994,7 @@ extern int *ira_allocate_cost_vector (reg_class_t);\n extern void ira_free_cost_vector (int *, reg_class_t);\n \n extern void ira_flattening (int, int);\n-extern bool ira_build (bool);\n+extern bool ira_build (void);\n extern void ira_destroy (void);\n \n /* ira-costs.c */"}, {"sha": "f639e12449bdc1365f16bc4410707ff4310a4d32", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2608d8414085d05d05fae8cba70ac22c8fe2c8d0/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2608d8414085d05d05fae8cba70ac22c8fe2c8d0/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=2608d8414085d05d05fae8cba70ac22c8fe2c8d0", "patch": "@@ -1123,7 +1123,7 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \n \t  if (internal_flag_ira_verbose > 2 && ira_dump_file != NULL)\n \t    fprintf (ira_dump_file, \"   Insn %u(l%d): point = %d\\n\",\n-\t\t     INSN_UID (insn), loop_tree_node->parent->loop->num,\n+\t\t     INSN_UID (insn), loop_tree_node->parent->loop_num,\n \t\t     curr_point);\n \n \t  /* Mark each defined value as live.  We need to do this for"}, {"sha": "a632284de88a4d7cca823ad47f47cb390069b3ad", "filename": "gcc/ira.c", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2608d8414085d05d05fae8cba70ac22c8fe2c8d0/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2608d8414085d05d05fae8cba70ac22c8fe2c8d0/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=2608d8414085d05d05fae8cba70ac22c8fe2c8d0", "patch": "@@ -718,7 +718,7 @@ ira_print_disposition (FILE *f)\n \tif ((bb = ALLOCNO_LOOP_TREE_NODE (a)->bb) != NULL)\n \t  fprintf (f, \"b%-3d\", bb->index);\n \telse\n-\t  fprintf (f, \"l%-3d\", ALLOCNO_LOOP_TREE_NODE (a)->loop->num);\n+\t  fprintf (f, \"l%-3d\", ALLOCNO_LOOP_TREE_NODE (a)->loop_num);\n \tif (ALLOCNO_HARD_REGNO (a) >= 0)\n \t  fprintf (f, \" %3d\", ALLOCNO_HARD_REGNO (a));\n \telse\n@@ -3614,14 +3614,16 @@ ira (FILE *f)\n   ira_move_loops_num = ira_additional_jumps_num = 0;\n \n   ira_assert (current_loops == NULL);\n-  flow_loops_find (&ira_loops);\n-  record_loop_exits ();\n-  current_loops = &ira_loops;\n+  if (flag_ira_region == IRA_REGION_ALL || flag_ira_region == IRA_REGION_MIXED)\n+    {\n+      flow_loops_find (&ira_loops);\n+      record_loop_exits ();\n+      current_loops = &ira_loops;\n+    }\n \n   if (internal_flag_ira_verbose > 0 && ira_dump_file != NULL)\n     fprintf (ira_dump_file, \"Building IRA IR\\n\");\n-  loops_p = ira_build (flag_ira_region == IRA_REGION_ALL\n-\t\t       || flag_ira_region == IRA_REGION_MIXED);\n+  loops_p = ira_build ();\n \n   ira_assert (ira_conflicts_p || !loops_p);\n \n@@ -3745,8 +3747,11 @@ do_reload (void)\n \n   flag_ira_share_spill_slots = saved_flag_ira_share_spill_slots;\n \n-  flow_loops_free (&ira_loops);\n-  free_dominance_info (CDI_DOMINATORS);\n+  if (current_loops != NULL)\n+    {\n+      flow_loops_free (&ira_loops);\n+      free_dominance_info (CDI_DOMINATORS);\n+    }\n   FOR_ALL_BB (bb)\n     bb->loop_father = NULL;\n   current_loops = NULL;"}]}