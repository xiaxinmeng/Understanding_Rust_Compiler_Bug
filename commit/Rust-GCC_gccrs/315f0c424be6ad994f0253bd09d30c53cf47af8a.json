{"sha": "315f0c424be6ad994f0253bd09d30c53cf47af8a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzE1ZjBjNDI0YmU2YWQ5OTRmMDI1M2JkMDlkMzBjNTNjZjQ3YWY4YQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-06T12:16:32Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-06T12:16:32Z"}, "message": "[multiple changes]\n\n2017-09-06  Bob Duff  <duff@adacore.com>\n\n\t* exp_util.adb (Is_Displace_Call): Make sure it works for indirect\n\tcalls and the like.\n\n2017-09-06  Yannick Moy  <moy@adacore.com>\n\n\t* sem_prag.adb (Analyze_Depends_Global): Reinforce test on object\n\tdeclarations to only consider valid uses of Global/Depends those on\n\tsingle concurrent objects.\n\n2017-09-06  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* sem_ch13.adb (Check_Record_Representation_Clause): Give an\n\terror as soon as one of the specified components overlaps the\n\tparent field.\n\n2017-09-06  Arnaud Charlet  <charlet@adacore.com>\n\n\t* sem_prag.ads: minor fix typo in comment.\n\n2017-09-06  Justin Squirek  <squirek@adacore.com>\n\n\t* sem_ch5.adb (Analyze_Block_Statement): Verify a block comes\n\tfrom source before checking source references.\n\t* sem_warn.adb (Check_References): Add check for internal block\n\tbefore recursing.\n\n2017-09-06  Vincent Celier  <celier@adacore.com>\n\n\t* make.adb, makeusg.adb, switch-m.adb, switch-m.ads, make_util.adb,\n\tmake_util.ads, sinput.adb, sinput.ads, clean.adb, gnatls.adb,\n\tgnatname.adb: Remove the Project Manager from the GNAT tools.\n\n2017-09-06  Bob Duff  <duff@adacore.com>\n\n\t* sem_util.ads: Minor comment fix.\n\n2017-09-06  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch12.adb (Analyze_Associations, case of Formal_Package):\n\tGenerate a freeze node for the actual of a formal package, if\n\tthe actual is declared in the same unit and has a corresponding\n\tbody, to prevent the current instance from being frozen before\n\tthe actual is.\n\nFrom-SVN: r251786", "tree": {"sha": "2269c6989b4176b686f4275fc8b058484766a119", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2269c6989b4176b686f4275fc8b058484766a119"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/315f0c424be6ad994f0253bd09d30c53cf47af8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/315f0c424be6ad994f0253bd09d30c53cf47af8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/315f0c424be6ad994f0253bd09d30c53cf47af8a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/315f0c424be6ad994f0253bd09d30c53cf47af8a/comments", "author": null, "committer": null, "parents": [{"sha": "5efb89d0e1a8aa19fafd64e7c7bebde46cccdd14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5efb89d0e1a8aa19fafd64e7c7bebde46cccdd14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5efb89d0e1a8aa19fafd64e7c7bebde46cccdd14"}], "stats": {"total": 7677, "additions": 2791, "deletions": 4886}, "files": [{"sha": "8939a8cbad153f3badbc24c18bb1962a95e7e741", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 46, "deletions": 11, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315f0c424be6ad994f0253bd09d30c53cf47af8a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315f0c424be6ad994f0253bd09d30c53cf47af8a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=315f0c424be6ad994f0253bd09d30c53cf47af8a", "patch": "@@ -1,3 +1,49 @@\n+2017-09-06  Bob Duff  <duff@adacore.com>\n+\n+\t* exp_util.adb (Is_Displace_Call): Make sure it works for indirect\n+\tcalls and the like.\n+\n+2017-09-06  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Depends_Global): Reinforce test on object\n+\tdeclarations to only consider valid uses of Global/Depends those on\n+\tsingle concurrent objects.\n+\n+2017-09-06  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* sem_ch13.adb (Check_Record_Representation_Clause): Give an\n+\terror as soon as one of the specified components overlaps the\n+\tparent field.\n+\n+2017-09-06  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* sem_prag.ads: minor fix typo in comment.\n+\n+2017-09-06  Justin Squirek  <squirek@adacore.com>\n+\n+\t* sem_ch5.adb (Analyze_Block_Statement): Verify a block comes\n+\tfrom source before checking source references.\n+\t* sem_warn.adb (Check_References): Add check for internal block\n+\tbefore recursing.\n+\n+2017-09-06  Vincent Celier  <celier@adacore.com>\n+\n+\t* make.adb, makeusg.adb, switch-m.adb, switch-m.ads, make_util.adb,\n+\tmake_util.ads, sinput.adb, sinput.ads, clean.adb, gnatls.adb,\n+\tgnatname.adb: Remove the Project Manager from the GNAT tools.\n+\n+2017-09-06  Bob Duff  <duff@adacore.com>\n+\n+\t* sem_util.ads: Minor comment fix.\n+\n+2017-09-06  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch12.adb (Analyze_Associations, case of Formal_Package):\n+\tGenerate a freeze node for the actual of a formal package, if\n+\tthe actual is declared in the same unit and has a corresponding\n+\tbody, to prevent the current instance from being frozen before\n+\tthe actual is.\n+\n 2017-09-06  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* sem_ch7.adb (Entity_Table_Size): Change to nearest prime number.\n@@ -15,17 +61,6 @@\n \tfreezing a subprogram, to complete the generation of the\n \tcorresponding checking code.\n \n-2017-09-06  Eric Botcazou  <ebotcazou@adacore.com>\n-\n-\t* inline.adb (Analyze_Inlined_Bodies): Remove restriction on\n-\tloading of parent body with a with clause for the main unit.\n-\t* gcc-interface/decl.c (defer_limited_with_list): Document\n-\tnew usage.\n-\t(gnat_to_gnu_entity) <E_Access_Type>: Handle\n-\tcompleted Taft Amendment types declared in external units like\n-\ttypes from limited with clauses.  Adjust final processing of\n-\tdefer_limited_with_list accordingly.\n-\n 2017-09-06  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* exp_util.adb (Is_Controlled_Indexing): New routine."}, {"sha": "51793b07596eabcd9ee121b4a67ecd114ba249a0", "filename": "gcc/ada/clean.adb", "status": "modified", "additions": 72, "deletions": 1090, "changes": 1162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315f0c424be6ad994f0253bd09d30c53cf47af8a/gcc%2Fada%2Fclean.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315f0c424be6ad994f0253bd09d30c53cf47af8a/gcc%2Fada%2Fclean.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fclean.adb?ref=315f0c424be6ad994f0253bd09d30c53cf47af8a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2003-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2003-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -23,21 +23,14 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with ALI;      use ALI;\n+with ALI;       use ALI;\n with Csets;\n-with Makeutl;  use Makeutl;\n-with MLib.Tgt; use MLib.Tgt;\n-with Namet;    use Namet;\n-with Opt;      use Opt;\n-with Osint;    use Osint;\n-with Osint.M;  use Osint.M;\n-with Prj;      use Prj;\n-with Prj.Env;\n-with Prj.Ext;\n-with Prj.Pars;\n-with Prj.Tree; use Prj.Tree;\n-with Prj.Util; use Prj.Util;\n-with Sdefault;\n+with Make_Util; use Make_Util;\n+with Namet;     use Namet;\n+with Opt;       use Opt;\n+with Osint;     use Osint;\n+with Osint.M;   use Osint.M;\n+--  with Sdefault;\n with Snames;\n with Stringt;\n with Switch;   use Switch;\n@@ -61,7 +54,6 @@ package body Clean is\n    --  Suffixes of various files\n \n    Assembly_Suffix : constant String := \".s\";\n-   ALI_Suffix      : constant String := \".ali\";\n    Tree_Suffix     : constant String := \".adt\";\n    Object_Suffix   : constant String := Get_Target_Object_Suffix.all;\n    Debug_Suffix    : constant String := \".dg\";\n@@ -71,10 +63,6 @@ package body Clean is\n    B_Start : constant String := \"b~\";\n    --  Prefix of binder generated file, and number of actual characters used\n \n-   Project_Tree : constant Project_Tree_Ref :=\n-     new Project_Tree_Data (Is_Root_Tree => True);\n-   --  The project tree\n-\n    Object_Directory_Path : String_Access := null;\n    --  The path name of the object directory, set with switch -D\n \n@@ -95,40 +83,6 @@ package body Clean is\n \n    Project_File_Name : String_Access := null;\n \n-   Project_Node_Tree : Project_Node_Tree_Ref;\n-\n-   Main_Project : Prj.Project_Id := Prj.No_Project;\n-\n-   All_Projects : Boolean := False;\n-\n-   --  Packages of project files where unknown attributes are errors\n-\n-   Naming_String   : aliased String := \"naming\";\n-   Builder_String  : aliased String := \"builder\";\n-   Compiler_String : aliased String := \"compiler\";\n-   Binder_String   : aliased String := \"binder\";\n-   Linker_String   : aliased String := \"linker\";\n-\n-   Gnatmake_Packages : aliased String_List :=\n-     (Naming_String   'Access,\n-      Builder_String  'Access,\n-      Compiler_String 'Access,\n-      Binder_String   'Access,\n-      Linker_String   'Access);\n-\n-   Packages_To_Check_By_Gnatmake : constant String_List_Access :=\n-     Gnatmake_Packages'Access;\n-\n-   package Processed_Projects is new Table.Table\n-     (Table_Component_Type => Project_Id,\n-      Table_Index_Type     => Natural,\n-      Table_Low_Bound      => 0,\n-      Table_Initial        => 10,\n-      Table_Increment      => 100,\n-      Table_Name           => \"Clean.Processed_Projects\");\n-   --  Table to keep track of what project files have been processed, when\n-   --  switch -r is specified.\n-\n    package Sources is new Table.Table\n      (Table_Component_Type => File_Name_Type,\n       Table_Index_Type     => Natural,\n@@ -143,44 +97,12 @@ package body Clean is\n    -- Other local subprograms --\n    -----------------------------\n \n-   procedure Add_Source_Dir (N : String);\n-   --  Call Add_Src_Search_Dir and output one line when in verbose mode\n-\n-   procedure Add_Source_Directories is\n-     new Prj.Env.For_All_Source_Dirs (Action => Add_Source_Dir);\n-\n-   procedure Add_Object_Dir (N : String);\n-   --  Call Add_Lib_Search_Dir and output one line when in verbose mode\n-\n-   procedure Add_Object_Directories is\n-     new Prj.Env.For_All_Object_Dirs (Action => Add_Object_Dir);\n-\n-   function ALI_File_Name (Source : File_Name_Type) return String;\n-   --  Returns the name of the ALI file corresponding to Source\n-\n    function Assembly_File_Name (Source : File_Name_Type) return String;\n    --  Returns the assembly file name corresponding to Source\n \n-   procedure Clean_Archive (Project : Project_Id; Global : Boolean);\n-   --  Delete a global archive or library project archive and the dependency\n-   --  file, if they exist.\n-\n    procedure Clean_Executables;\n    --  Do the cleaning work when no project file is specified\n \n-   procedure Clean_Interface_Copy_Directory (Project : Project_Id);\n-   --  Delete files in an interface copy directory: any file that is a copy of\n-   --  a source of the project.\n-\n-   procedure Clean_Library_Directory (Project : Project_Id);\n-   --  Delete the library file in a library directory and any ALI file of a\n-   --  source of the project in a library ALI directory.\n-\n-   procedure Clean_Project (Project : Project_Id);\n-   --  Do the cleaning work when a project file is specified. This procedure\n-   --  calls itself recursively when there are several project files in the\n-   --  tree rooted at the main project file and switch -r has been specified.\n-\n    function Debug_File_Name (Source : File_Name_Type) return String;\n    --  Name of the expanded source file corresponding to Source\n \n@@ -213,71 +135,10 @@ package body Clean is\n    function Tree_File_Name (Source : File_Name_Type) return String;\n    --  Returns the tree file name corresponding to Source\n \n-   function In_Extension_Chain\n-     (Of_Project : Project_Id;\n-      Prj        : Project_Id) return Boolean;\n-   --  Returns True iff Prj is an extension of Of_Project or if Of_Project is\n-   --  an extension of Prj.\n-\n    procedure Usage;\n    --  Display the usage. If called several times, the usage is displayed only\n    --  the first time.\n \n-   --------------------\n-   -- Add_Object_Dir --\n-   --------------------\n-\n-   procedure Add_Object_Dir (N : String) is\n-   begin\n-      Add_Lib_Search_Dir (N);\n-\n-      if Opt.Verbose_Mode then\n-         Put (\"Adding object directory \"\"\");\n-         Put (N);\n-         Put (\"\"\".\");\n-         New_Line;\n-      end if;\n-   end Add_Object_Dir;\n-\n-   --------------------\n-   -- Add_Source_Dir --\n-   --------------------\n-\n-   procedure Add_Source_Dir (N : String) is\n-   begin\n-      Add_Src_Search_Dir (N);\n-\n-      if Opt.Verbose_Mode then\n-         Put (\"Adding source directory \"\"\");\n-         Put (N);\n-         Put (\"\"\".\");\n-         New_Line;\n-      end if;\n-   end Add_Source_Dir;\n-\n-   -------------------\n-   -- ALI_File_Name --\n-   -------------------\n-\n-   function ALI_File_Name (Source : File_Name_Type) return String is\n-      Src : constant String := Get_Name_String (Source);\n-\n-   begin\n-      --  If the source name has an extension, then replace it with\n-      --  the ALI suffix.\n-\n-      for Index in reverse Src'First + 1 .. Src'Last loop\n-         if Src (Index) = '.' then\n-            return Src (Src'First .. Index - 1) & ALI_Suffix;\n-         end if;\n-      end loop;\n-\n-      --  If there is no dot, or if it is the first character, just add the\n-      --  ALI suffix.\n-\n-      return Src & ALI_Suffix;\n-   end ALI_File_Name;\n-\n    ------------------------\n    -- Assembly_File_Name --\n    ------------------------\n@@ -301,54 +162,6 @@ package body Clean is\n       return Src & Assembly_Suffix;\n    end Assembly_File_Name;\n \n-   -------------------\n-   -- Clean_Archive --\n-   -------------------\n-\n-   procedure Clean_Archive (Project : Project_Id; Global : Boolean) is\n-      Current_Dir : constant Dir_Name_Str := Get_Current_Dir;\n-\n-      Lib_Prefix : String_Access;\n-      Archive_Name : String_Access;\n-      --  The name of the archive file for this project\n-\n-      Archive_Dep_Name : String_Access;\n-      --  The name of the archive dependency file for this project\n-\n-      Obj_Dir : constant String :=\n-        Get_Name_String (Project.Object_Directory.Display_Name);\n-\n-   begin\n-      Change_Dir (Obj_Dir);\n-\n-      --  First, get the lib prefix, the archive file name and the archive\n-      --  dependency file name.\n-\n-      if Global then\n-         Lib_Prefix :=\n-           new String'(\"lib\" & Get_Name_String (Project.Display_Name));\n-      else\n-         Lib_Prefix :=\n-           new String'(\"lib\" & Get_Name_String (Project.Library_Name));\n-      end if;\n-\n-      Archive_Name := new String'(Lib_Prefix.all & '.' & Archive_Ext);\n-      Archive_Dep_Name := new String'(Lib_Prefix.all & \".deps\");\n-\n-      --  Delete the archive file and the archive dependency file, if they\n-      --  exist.\n-\n-      if Is_Regular_File (Archive_Name.all) then\n-         Delete (Obj_Dir, Archive_Name.all);\n-      end if;\n-\n-      if Is_Regular_File (Archive_Dep_Name.all) then\n-         Delete (Obj_Dir, Archive_Dep_Name.all);\n-      end if;\n-\n-      Change_Dir (Current_Dir);\n-   end Clean_Archive;\n-\n    -----------------------\n    -- Clean_Executables --\n    -----------------------\n@@ -372,7 +185,7 @@ package body Clean is\n       Source  : Queue.Source_Info;\n \n    begin\n-      Queue.Initialize (Queue_Per_Obj_Dir => False);\n+      Queue.Initialize;\n \n       --  It does not really matter if there is or not an object file\n       --  corresponding to an ALI file: if there is one, it will be deleted.\n@@ -390,12 +203,9 @@ package body Clean is\n \n          if Main_Lib_File /= No_File then\n             Queue.Insert\n-              ((Format  => Format_Gnatmake,\n-                File    => Main_Lib_File,\n+              ((File    => Main_Lib_File,\n                 Unit    => No_Unit_Name,\n-                Index   => 0,\n-                Project => No_Project,\n-                Sid     => No_Source));\n+                Index   => 0));\n          end if;\n \n          while not Queue.Is_Empty loop\n@@ -434,12 +244,9 @@ package body Clean is\n                         loop\n                            if Withs.Table (K).Afile /= No_File then\n                               Queue.Insert\n-                                ((Format  => Format_Gnatmake,\n-                                  File    => Withs.Table (K).Afile,\n+                                ((File    => Withs.Table (K).Afile,\n                                   Unit    => No_Unit_Name,\n-                                  Index   => 0,\n-                                  Project => No_Project,\n-                                  Sid     => No_Source));\n+                                  Index   => 0));\n                            end if;\n                         end loop;\n                      end loop;\n@@ -526,695 +333,6 @@ package body Clean is\n       end loop;\n    end Clean_Executables;\n \n-   ------------------------------------\n-   -- Clean_Interface_Copy_Directory --\n-   ------------------------------------\n-\n-   procedure Clean_Interface_Copy_Directory (Project : Project_Id) is\n-      Current : constant String := Get_Current_Dir;\n-\n-      Direc : Dir_Type;\n-\n-      Name : String (1 .. 200);\n-      Last : Natural;\n-\n-      Delete_File : Boolean;\n-      Unit        : Unit_Index;\n-\n-   begin\n-      if Project.Library\n-        and then Project.Library_Src_Dir /= No_Path_Information\n-      then\n-         declare\n-            Directory : constant String :=\n-              Get_Name_String (Project.Library_Src_Dir.Display_Name);\n-\n-         begin\n-            Change_Dir (Directory);\n-            Open (Direc, \".\");\n-\n-            --  For each regular file in the directory, if switch -n has not\n-            --  been specified, make it writable and delete the file if it is\n-            --  a copy of a source of the project.\n-\n-            loop\n-               Read (Direc, Name, Last);\n-               exit when Last = 0;\n-\n-               declare\n-                  Filename : constant String := Name (1 .. Last);\n-\n-               begin\n-                  if Is_Regular_File (Filename) then\n-                     Canonical_Case_File_Name (Name (1 .. Last));\n-                     Delete_File := False;\n-\n-                     Unit := Units_Htable.Get_First (Project_Tree.Units_HT);\n-\n-                     --  Compare with source file names of the project\n-\n-                     while Unit /= No_Unit_Index loop\n-                        if Unit.File_Names (Impl) /= null\n-                          and then Ultimate_Extending_Project_Of\n-                                     (Unit.File_Names (Impl).Project) = Project\n-                          and then\n-                            Get_Name_String (Unit.File_Names (Impl).File) =\n-                                                              Name (1 .. Last)\n-                        then\n-                           Delete_File := True;\n-                           exit;\n-                        end if;\n-\n-                        if Unit.File_Names (Spec) /= null\n-                          and then Ultimate_Extending_Project_Of\n-                                     (Unit.File_Names (Spec).Project) = Project\n-                          and then\n-                            Get_Name_String\n-                              (Unit.File_Names (Spec).File) = Name (1 .. Last)\n-                        then\n-                           Delete_File := True;\n-                           exit;\n-                        end if;\n-\n-                        Unit := Units_Htable.Get_Next (Project_Tree.Units_HT);\n-                     end loop;\n-\n-                     if Delete_File then\n-                        if not Do_Nothing then\n-                           Set_Writable (Filename);\n-                        end if;\n-\n-                        Delete (Directory, Filename);\n-                     end if;\n-                  end if;\n-               end;\n-            end loop;\n-\n-            Close (Direc);\n-\n-            --  Restore the initial working directory\n-\n-            Change_Dir (Current);\n-         end;\n-      end if;\n-   end Clean_Interface_Copy_Directory;\n-\n-   -----------------------------\n-   -- Clean_Library_Directory --\n-   -----------------------------\n-\n-   Empty_String : aliased String := \"\";\n-\n-   procedure Clean_Library_Directory (Project : Project_Id) is\n-      Current : constant String := Get_Current_Dir;\n-\n-      Lib_Filename : constant String := Get_Name_String (Project.Library_Name);\n-      DLL_Name     : String :=\n-        DLL_Prefix & Lib_Filename & \".\" & DLL_Ext;\n-      Archive_Name : String :=\n-        \"lib\" & Lib_Filename & \".\" & Archive_Ext;\n-      Direc        : Dir_Type;\n-\n-      Name : String (1 .. 200);\n-      Last : Natural;\n-\n-      Delete_File : Boolean;\n-\n-      Minor : String_Access := Empty_String'Access;\n-      Major : String_Access := Empty_String'Access;\n-\n-   begin\n-      if Project.Library then\n-         if Project.Library_Kind /= Static\n-           and then MLib.Tgt.Library_Major_Minor_Id_Supported\n-           and then Project.Lib_Internal_Name /= No_Name\n-         then\n-            Minor := new String'(Get_Name_String (Project.Lib_Internal_Name));\n-            Major := new String'(MLib.Major_Id_Name (DLL_Name, Minor.all));\n-         end if;\n-\n-         declare\n-            Lib_Directory     : constant String :=\n-              Get_Name_String (Project.Library_Dir.Display_Name);\n-            Lib_ALI_Directory : constant String :=\n-              Get_Name_String (Project.Library_ALI_Dir.Display_Name);\n-\n-         begin\n-            Canonical_Case_File_Name (Archive_Name);\n-            Canonical_Case_File_Name (DLL_Name);\n-\n-            if Is_Directory (Lib_Directory) then\n-               Change_Dir (Lib_Directory);\n-               Open (Direc, \".\");\n-\n-               --  For each regular file in the directory, if switch -n has not\n-               --  not been specified, make it writable and delete the file if\n-               --  it is the library file.\n-\n-               loop\n-                  Read (Direc, Name, Last);\n-                  exit when Last = 0;\n-\n-                  declare\n-                     Filename : constant String := Name (1 .. Last);\n-\n-                  begin\n-                     if Is_Regular_File (Filename)\n-                       or else Is_Symbolic_Link (Filename)\n-                     then\n-                        Canonical_Case_File_Name (Name (1 .. Last));\n-                        Delete_File := False;\n-\n-                        if (Project.Library_Kind = Static\n-                             and then Name (1 .. Last) = Archive_Name)\n-                          or else\n-                            ((Project.Library_Kind = Dynamic\n-                                or else\n-                              Project.Library_Kind = Relocatable)\n-                             and then\n-                               (Name (1 .. Last) = DLL_Name\n-                                  or else\n-                                Name (1 .. Last) = Minor.all\n-                                  or else\n-                                Name (1 .. Last) = Major.all))\n-                        then\n-                           if not Do_Nothing then\n-                              Set_Writable (Filename);\n-                           end if;\n-\n-                           Delete (Lib_Directory, Filename);\n-                        end if;\n-                     end if;\n-                  end;\n-               end loop;\n-\n-               Close (Direc);\n-            end if;\n-\n-            if not Is_Directory (Lib_ALI_Directory) then\n-               --  Nothing more to do, return now\n-               return;\n-            end if;\n-\n-            Change_Dir (Lib_ALI_Directory);\n-            Open (Direc, \".\");\n-\n-            --  For each regular file in the directory, if switch -n has not\n-            --  been specified, make it writable and delete the file if it is\n-            --  any ALI file of a source of the project.\n-\n-            loop\n-               Read (Direc, Name, Last);\n-               exit when Last = 0;\n-\n-               declare\n-                  Filename : constant String := Name (1 .. Last);\n-               begin\n-                  if Is_Regular_File (Filename) then\n-                     Canonical_Case_File_Name (Name (1 .. Last));\n-                     Delete_File := False;\n-\n-                     if Last > 4 and then Name (Last - 3 .. Last) = \".ali\" then\n-                        declare\n-                           Unit : Unit_Index;\n-\n-                        begin\n-                           --  Compare with ALI file names of the project\n-\n-                           Unit :=\n-                             Units_Htable.Get_First (Project_Tree.Units_HT);\n-                           while Unit /= No_Unit_Index loop\n-                              if Unit.File_Names (Impl) /= null\n-                                and then Unit.File_Names (Impl).Project /=\n-                                                                   No_Project\n-                              then\n-                                 if Ultimate_Extending_Project_Of\n-                                      (Unit.File_Names (Impl).Project) =\n-                                                                   Project\n-                                 then\n-                                    Get_Name_String\n-                                      (Unit.File_Names (Impl).File);\n-                                    Name_Len :=\n-                                      Name_Len -\n-                                        File_Extension\n-                                          (Name (1 .. Name_Len))'Length;\n-                                    if Name_Buffer (1 .. Name_Len) =\n-                                         Name (1 .. Last - 4)\n-                                    then\n-                                       Delete_File := True;\n-                                       exit;\n-                                    end if;\n-                                 end if;\n-\n-                              elsif Unit.File_Names (Spec) /= null\n-                                and then Ultimate_Extending_Project_Of\n-                                           (Unit.File_Names (Spec).Project) =\n-                                                                    Project\n-                              then\n-                                 Get_Name_String (Unit.File_Names (Spec).File);\n-                                 Name_Len :=\n-                                   Name_Len -\n-                                     File_Extension\n-                                       (Name (1 .. Name_Len))'Length;\n-\n-                                 if Name_Buffer (1 .. Name_Len) =\n-                                      Name (1 .. Last - 4)\n-                                 then\n-                                    Delete_File := True;\n-                                    exit;\n-                                 end if;\n-                              end if;\n-\n-                              Unit :=\n-                                Units_Htable.Get_Next (Project_Tree.Units_HT);\n-                           end loop;\n-                        end;\n-                     end if;\n-\n-                     if Delete_File then\n-                        if not Do_Nothing then\n-                           Set_Writable (Filename);\n-                        end if;\n-\n-                        Delete (Lib_ALI_Directory, Filename);\n-                     end if;\n-                  end if;\n-               end;\n-            end loop;\n-\n-            Close (Direc);\n-\n-            --  Restore the initial working directory\n-\n-            Change_Dir (Current);\n-         end;\n-      end if;\n-   end Clean_Library_Directory;\n-\n-   -------------------\n-   -- Clean_Project --\n-   -------------------\n-\n-   procedure Clean_Project (Project : Project_Id) is\n-      Main_Source_File : File_Name_Type;\n-      --  Name of executable on the command line without directory info\n-\n-      Executable : File_Name_Type;\n-      --  Name of the executable file\n-\n-      Current_Dir : constant Dir_Name_Str := Get_Current_Dir;\n-      Unit        : Unit_Index;\n-      File_Name1  : File_Name_Type;\n-      Index1      : Int;\n-      File_Name2  : File_Name_Type;\n-      Index2      : Int;\n-      Lib_File    : File_Name_Type;\n-\n-      Global_Archive : Boolean := False;\n-\n-   begin\n-      --  Check that we don't specify executable on the command line for\n-      --  a main library project.\n-\n-      if Project = Main_Project\n-        and then Osint.Number_Of_Files /= 0\n-        and then Project.Library\n-      then\n-         Osint.Fail\n-           (\"Cannot specify executable(s) for a Library Project File\");\n-      end if;\n-\n-      --  Nothing to clean in an externally built project\n-\n-      if Project.Externally_Built then\n-         if Verbose_Mode then\n-            Put (\"Nothing to do to clean externally built project \"\"\");\n-            Put (Get_Name_String (Project.Name));\n-            Put_Line (\"\"\"\");\n-         end if;\n-\n-      else\n-         if Verbose_Mode then\n-            Put (\"Cleaning project \"\"\");\n-            Put (Get_Name_String (Project.Name));\n-            Put_Line (\"\"\"\");\n-         end if;\n-\n-         --  Add project to the list of processed projects\n-\n-         Processed_Projects.Increment_Last;\n-         Processed_Projects.Table (Processed_Projects.Last) := Project;\n-\n-         if Project.Object_Directory /= No_Path_Information\n-           and then Is_Directory\n-                      (Get_Name_String (Project.Object_Directory.Display_Name))\n-         then\n-            declare\n-               Obj_Dir : constant String :=\n-                 Get_Name_String (Project.Object_Directory.Display_Name);\n-\n-            begin\n-               Change_Dir (Obj_Dir);\n-\n-               --  First, deal with Ada\n-\n-               --  Look through the units to find those that are either\n-               --  immediate sources or inherited sources of the project.\n-               --  Extending projects may have no language specified, if\n-               --  Source_Dirs or Source_Files is specified as an empty list,\n-               --  so always look for Ada units in extending projects.\n-\n-               if Has_Ada_Sources (Project)\n-                 or else Project.Extends /= No_Project\n-               then\n-                  Unit := Units_Htable.Get_First (Project_Tree.Units_HT);\n-                  while Unit /= No_Unit_Index loop\n-                     File_Name1 := No_File;\n-                     File_Name2 := No_File;\n-\n-                     --  If either the spec or the body is a source of the\n-                     --  project, check for the corresponding ALI file in the\n-                     --  object directory.\n-\n-                     if (Unit.File_Names (Impl) /= null\n-                          and then\n-                            In_Extension_Chain\n-                              (Unit.File_Names (Impl).Project, Project))\n-                       or else\n-                         (Unit.File_Names (Spec) /= null\n-                           and then\n-                             In_Extension_Chain\n-                               (Unit.File_Names (Spec).Project, Project))\n-                     then\n-                        if Unit.File_Names (Impl) /= null then\n-                           File_Name1 := Unit.File_Names (Impl).File;\n-                           Index1     := Unit.File_Names (Impl).Index;\n-                        else\n-                           File_Name1 := No_File;\n-                           Index1     := 0;\n-                        end if;\n-\n-                        if Unit.File_Names (Spec) /= null then\n-                           File_Name2 := Unit.File_Names (Spec).File;\n-                           Index2     := Unit.File_Names (Spec).Index;\n-                        else\n-                           File_Name2 := No_File;\n-                           Index2     := 0;\n-                        end if;\n-\n-                        --  If there is no body file name, then there may be\n-                        --  only a spec.\n-\n-                        if File_Name1 = No_File then\n-                           File_Name1 := File_Name2;\n-                           Index1     := Index2;\n-                           File_Name2 := No_File;\n-                           Index2     := 0;\n-                        end if;\n-                     end if;\n-\n-                     --  If there is either a spec or a body, look for files\n-                     --  in the object directory.\n-\n-                     if File_Name1 /= No_File then\n-                        Lib_File := Osint.Lib_File_Name (File_Name1, Index1);\n-\n-                        declare\n-                           Asm : constant String :=\n-                                   Assembly_File_Name (Lib_File);\n-                           ALI : constant String :=\n-                                   ALI_File_Name      (Lib_File);\n-                           Obj : constant String :=\n-                                   Object_File_Name   (Lib_File);\n-                           Adt : constant String :=\n-                                   Tree_File_Name     (Lib_File);\n-                           Deb : constant String :=\n-                                   Debug_File_Name    (File_Name1);\n-                           Rep : constant String :=\n-                                   Repinfo_File_Name  (File_Name1);\n-                           Del : Boolean := True;\n-\n-                        begin\n-                           --  If the ALI file exists and is read-only, no file\n-                           --  is deleted.\n-\n-                           if Is_Regular_File (ALI) then\n-                              if Is_Writable_File (ALI) then\n-                                 Delete (Obj_Dir, ALI);\n-\n-                              else\n-                                 Del := False;\n-\n-                                 if Verbose_Mode then\n-                                    Put ('\"');\n-                                    Put (Obj_Dir);\n-\n-                                    if Obj_Dir (Obj_Dir'Last) /=\n-                                      Dir_Separator\n-                                    then\n-                                       Put (Dir_Separator);\n-                                    end if;\n-\n-                                    Put (ALI);\n-                                    Put_Line (\"\"\" is read-only\");\n-                                 end if;\n-                              end if;\n-                           end if;\n-\n-                           if Del then\n-\n-                              --  Object file\n-\n-                              if Is_Regular_File (Obj) then\n-                                 Delete (Obj_Dir, Obj);\n-                              end if;\n-\n-                              --  Assembly file\n-\n-                              if Is_Regular_File (Asm) then\n-                                 Delete (Obj_Dir, Asm);\n-                              end if;\n-\n-                              --  Tree file\n-\n-                              if Is_Regular_File (Adt) then\n-                                 Delete (Obj_Dir, Adt);\n-                              end if;\n-\n-                              --  First expanded source file\n-\n-                              if Is_Regular_File (Deb) then\n-                                 Delete (Obj_Dir, Deb);\n-                              end if;\n-\n-                              --  Repinfo file\n-\n-                              if Is_Regular_File (Rep) then\n-                                 Delete (Obj_Dir, Rep);\n-                              end if;\n-\n-                              --  Second expanded source file\n-\n-                              if File_Name2 /= No_File then\n-                                 declare\n-                                    Deb : constant String :=\n-                                      Debug_File_Name (File_Name2);\n-                                    Rep : constant String :=\n-                                      Repinfo_File_Name (File_Name2);\n-\n-                                 begin\n-                                    if Is_Regular_File (Deb) then\n-                                       Delete (Obj_Dir, Deb);\n-                                    end if;\n-\n-                                    if Is_Regular_File (Rep) then\n-                                       Delete (Obj_Dir, Rep);\n-                                    end if;\n-                                 end;\n-                              end if;\n-                           end if;\n-                        end;\n-                     end if;\n-\n-                     Unit := Units_Htable.Get_Next (Project_Tree.Units_HT);\n-                  end loop;\n-               end if;\n-\n-               --  Check if a global archive and it dependency file could have\n-               --  been created and, if they exist, delete them.\n-\n-               if Project = Main_Project and then not Project.Library then\n-                  Global_Archive := False;\n-\n-                  declare\n-                     Proj : Project_List;\n-\n-                  begin\n-                     Proj := Project_Tree.Projects;\n-                     while Proj /= null loop\n-\n-                        --  For gnatmake, when the project specifies more than\n-                        --  just Ada as a language (even if course we could not\n-                        --  find any source file for the other languages), we\n-                        --  will take all the object files found in the object\n-                        --  directories. Since we know the project supports at\n-                        --  least Ada, we just have to test whether it has at\n-                        --  least two languages, and we do not care about the\n-                        --  sources.\n-\n-                        if Proj.Project.Languages /= null\n-                          and then Proj.Project.Languages.Next /= null\n-                        then\n-                           Global_Archive := True;\n-                           exit;\n-                        end if;\n-\n-                        Proj := Proj.Next;\n-                     end loop;\n-                  end;\n-\n-                  if Global_Archive then\n-                     Clean_Archive (Project, Global => True);\n-                  end if;\n-               end if;\n-\n-            end;\n-         end if;\n-\n-         --  If this is a library project, clean the library directory, the\n-         --  interface copy dir and, for a Stand-Alone Library, the binder\n-         --  generated files of the library.\n-\n-         --  The directories are cleaned only if switch -c is not specified\n-\n-         if Project.Library then\n-            if not Compile_Only then\n-               Clean_Library_Directory (Project);\n-\n-               if Project.Library_Src_Dir /= No_Path_Information then\n-                  Clean_Interface_Copy_Directory (Project);\n-               end if;\n-            end if;\n-\n-            if Project.Standalone_Library /= No\n-              and then Project.Object_Directory /= No_Path_Information\n-            then\n-               Delete_Binder_Generated_Files\n-                 (Get_Name_String (Project.Object_Directory.Display_Name),\n-                  File_Name_Type (Project.Library_Name));\n-            end if;\n-         end if;\n-\n-         if Verbose_Mode then\n-            New_Line;\n-         end if;\n-      end if;\n-\n-      --  If switch -r is specified, call Clean_Project recursively for the\n-      --  imported projects and the project being extended.\n-\n-      if All_Projects then\n-         declare\n-            Imported : Project_List;\n-            Process  : Boolean;\n-\n-         begin\n-            --  For each imported project, call Clean_Project if the project\n-            --  has not been processed already.\n-\n-            Imported := Project.Imported_Projects;\n-            while Imported /= null loop\n-               Process := True;\n-\n-               for\n-                 J in Processed_Projects.First .. Processed_Projects.Last\n-               loop\n-                  if Imported.Project = Processed_Projects.Table (J) then\n-                     Process := False;\n-                     exit;\n-                  end if;\n-               end loop;\n-\n-               if Process then\n-                  Clean_Project (Imported.Project);\n-               end if;\n-\n-               Imported := Imported.Next;\n-            end loop;\n-\n-            --  If this project extends another project, call Clean_Project for\n-            --  the project being extended. It is guaranteed that it has not\n-            --  called before, because no other project may import or extend\n-            --  this project.\n-\n-            if Project.Extends /= No_Project then\n-               Clean_Project (Project.Extends);\n-            end if;\n-         end;\n-      end if;\n-\n-         --  For the main project, delete the executables and the binder\n-         --  generated files.\n-\n-         --  The executables are deleted only if switch -c is not specified\n-\n-      if Project = Main_Project\n-        and then Project.Exec_Directory /= No_Path_Information\n-      then\n-         declare\n-            Exec_Dir : constant String :=\n-              Get_Name_String (Project.Exec_Directory.Display_Name);\n-\n-         begin\n-            Change_Dir (Exec_Dir);\n-\n-            for N_File in 1 .. Osint.Number_Of_Files loop\n-               Main_Source_File := Next_Main_Source;\n-\n-               if not Compile_Only then\n-                  Executable :=\n-                    Executable_Of\n-                      (Main_Project,\n-                       Project_Tree.Shared,\n-                       Main_Source_File,\n-                       Current_File_Index);\n-\n-                  declare\n-                     Exec_File_Name : constant String :=\n-                       Get_Name_String (Executable);\n-\n-                  begin\n-                     if Is_Absolute_Path (Name => Exec_File_Name) then\n-                        if Is_Regular_File (Exec_File_Name) then\n-                           Delete (\"\", Exec_File_Name);\n-                        end if;\n-\n-                     else\n-                        if Is_Regular_File (Exec_File_Name) then\n-                           Delete (Exec_Dir, Exec_File_Name);\n-                        end if;\n-                     end if;\n-                  end;\n-               end if;\n-\n-               if Project.Object_Directory /= No_Path_Information\n-                 and then\n-                   Is_Directory\n-                     (Get_Name_String (Project.Object_Directory.Display_Name))\n-               then\n-                  Delete_Binder_Generated_Files\n-                    (Get_Name_String (Project.Object_Directory.Display_Name),\n-                     Strip_Suffix (Main_Source_File));\n-               end if;\n-            end loop;\n-         end;\n-      end if;\n-\n-      --  Change back to previous directory\n-\n-      Change_Dir (Current_Dir);\n-   end Clean_Project;\n-\n    ---------------------\n    -- Debug_File_Name --\n    ---------------------\n@@ -1370,102 +488,13 @@ package body Clean is\n \n       Parse_Cmd_Line;\n \n-      --  Add the default project search directories now, after the directories\n-      --  that have been specified by switches -aP<dir>.\n-\n-      Prj.Env.Initialize_Default_Project_Path\n-        (Root_Environment.Project_Path,\n-         Target_Name => Sdefault.Target_Name.all);\n-\n       if Verbose_Mode then\n          Display_Copyright;\n       end if;\n \n-      if Project_File_Name /= null then\n-\n-         --  Warn about 'gnatclean -P'\n-\n-         if Project_File_Name /= null then\n-            Put_Line\n-              (\"warning: gnatclean -P is obsolete and will not be available\" &\n-               \" in the next release; use gprclean instead.\");\n-         end if;\n-\n-         --  A project file was specified by a -P switch\n-\n-         if Opt.Verbose_Mode then\n-            New_Line;\n-            Put (\"Parsing Project File \"\"\");\n-            Put (Project_File_Name.all);\n-            Put_Line (\"\"\".\");\n-            New_Line;\n-         end if;\n-\n-         --  Set the project parsing verbosity to whatever was specified\n-         --  by a possible -vP switch.\n-\n-         Prj.Pars.Set_Verbosity (To => Current_Verbosity);\n-\n-         --  Parse the project file. If there is an error, Main_Project\n-         --  will still be No_Project.\n-\n-         Prj.Pars.Parse\n-           (Project           => Main_Project,\n-            In_Tree           => Project_Tree,\n-            In_Node_Tree      => Project_Node_Tree,\n-            Project_File_Name => Project_File_Name.all,\n-            Env               => Root_Environment,\n-            Packages_To_Check => Packages_To_Check_By_Gnatmake);\n-\n-         if Main_Project = No_Project then\n-            Fail (\"\"\"\" & Project_File_Name.all & \"\"\" processing failed\");\n-\n-         elsif Main_Project.Qualifier = Aggregate then\n-            Fail (\"aggregate projects are not supported\");\n-\n-         elsif Aggregate_Libraries_In (Project_Tree) then\n-            Fail (\"aggregate library projects are not supported\");\n-         end if;\n-\n-         if Opt.Verbose_Mode then\n-            New_Line;\n-            Put (\"Parsing of Project File \"\"\");\n-            Put (Project_File_Name.all);\n-            Put (\"\"\" is finished.\");\n-            New_Line;\n-         end if;\n-\n-         --  Add source directories and object directories to the search paths\n-\n-         Add_Source_Directories (Main_Project, Project_Tree);\n-         Add_Object_Directories (Main_Project, Project_Tree);\n-      end if;\n-\n       Osint.Add_Default_Search_Dirs;\n \n-      --  If a project file was specified, but no executable name, put all\n-      --  the mains of the project file (if any) as if there were on the\n-      --  command line.\n-\n-      if Main_Project /= No_Project and then Osint.Number_Of_Files = 0 then\n-         declare\n-            Main  : String_Element;\n-            Value : String_List_Id := Main_Project.Mains;\n-         begin\n-            while Value /= Prj.Nil_String loop\n-               Main := Project_Tree.Shared.String_Elements.Table (Value);\n-               Osint.Add_File\n-                 (File_Name => Get_Name_String (Main.Value),\n-                  Index     => Main.Index);\n-               Value := Main.Next;\n-            end loop;\n-         end;\n-      end if;\n-\n-      --  If neither a project file nor an executable were specified, exit\n-      --  displaying the usage if there were no arguments on the command line.\n-\n-      if Main_Project = No_Project and then Osint.Number_Of_Files = 0 then\n+      if Osint.Number_Of_Files = 0 then\n          if Argument_Count = 0 then\n             Usage;\n          else\n@@ -1479,22 +508,56 @@ package body Clean is\n          New_Line;\n       end if;\n \n-      if Main_Project /= No_Project then\n+      if Project_File_Name /= null then\n+         declare\n+            Gprclean_Path : constant String_Access :=\n+              Locate_Exec_On_Path (\"gprclean\");\n+            Arg_Len : Natural       := Argument_Count;\n+            Pos     : Natural       := 0;\n+            Target  : String_Access := null;\n+            Success : Boolean       := False;\n+         begin\n+            if Gprclean_Path = null then\n+               Fail_Program\n+                 (\"project files are no longer supported by gnatclean;\" &\n+                    \" use gprclean instead\");\n+            end if;\n \n-         --  If a project file has been specified, call Clean_Project with the\n-         --  project id of this project file, after resetting the list of\n-         --  processed projects.\n+            Find_Program_Name;\n \n-         Processed_Projects.Init;\n-         Clean_Project (Main_Project);\n+            if Name_Len > 10\n+              and then Name_Buffer (Name_Len - 7 .. Name_Len) = \"gnatclean\"\n+            then\n+               Target  := new String'(Name_Buffer (1 .. Name_Len - 9));\n+               Arg_Len := Arg_Len + 1;\n+            end if;\n \n-      else\n-         --  If no project file has been specified, the work is done in\n-         --  Clean_Executables.\n+            declare\n+               Args : Argument_List (1 .. Arg_Len);\n+            begin\n+               if Target /= null then\n+                  Args (1) := new String'(\"--target=\" & Target.all);\n+                  Pos := 1;\n+               end if;\n+\n+               for J in 1 .. Argument_Count loop\n+                  Pos := Pos + 1;\n+                  Args (Pos) := new String'(Argument (J));\n+               end loop;\n+\n+               Spawn (Gprclean_Path.all, Args, Success);\n \n-         Clean_Executables;\n+               if Success then\n+                  Exit_Program (E_Success);\n+               else\n+                  Exit_Program (E_Errors);\n+               end if;\n+            end;\n+         end;\n       end if;\n \n+      Clean_Executables;\n+\n       --  In verbose mode, if Delete has not been called, indicate that no file\n       --  needs to be deleted.\n \n@@ -1509,46 +572,6 @@ package body Clean is\n       end if;\n    end Gnatclean;\n \n-   ------------------------\n-   -- In_Extension_Chain --\n-   ------------------------\n-\n-   function In_Extension_Chain\n-     (Of_Project : Project_Id;\n-      Prj        : Project_Id) return Boolean\n-   is\n-      Proj : Project_Id;\n-\n-   begin\n-      if Prj = No_Project or else Of_Project = No_Project then\n-         return False;\n-      end if;\n-\n-      if Of_Project = Prj then\n-         return True;\n-      end if;\n-\n-      Proj := Of_Project;\n-      while Proj.Extends /= No_Project loop\n-         if Proj.Extends = Prj then\n-            return True;\n-         end if;\n-\n-         Proj := Proj.Extends;\n-      end loop;\n-\n-      Proj := Prj;\n-      while Proj.Extends /= No_Project loop\n-         if Proj.Extends = Of_Project then\n-            return True;\n-         end if;\n-\n-         Proj := Proj.Extends;\n-      end loop;\n-\n-      return False;\n-   end In_Extension_Chain;\n-\n    ----------------\n    -- Initialize --\n    ----------------\n@@ -1569,12 +592,6 @@ package body Clean is\n          Snames.Initialize;\n          Stringt.Initialize;\n \n-         Prj.Tree.Initialize (Root_Environment, Gnatmake_Flags);\n-\n-         Project_Node_Tree := new Project_Node_Tree_Data;\n-         Prj.Tree.Initialize (Project_Node_Tree);\n-\n-         Prj.Initialize (Project_Tree);\n          Targparm.Get_Target_Parameters;\n       end if;\n \n@@ -1585,9 +602,6 @@ package body Clean is\n       File_Deleted := False;\n       Copyright_Displayed := False;\n       Usage_Displayed := False;\n-      Free (Project_File_Name);\n-      Main_Project := Prj.No_Project;\n-      All_Projects := False;\n    end Initialize;\n \n    ----------------------\n@@ -1725,11 +739,10 @@ package body Clean is\n                           and then\n                             Arg (1 .. Subdirs_Option'Length) = Subdirs_Option\n                         then\n-                           Subdirs :=\n-                             new String'\n-                               (Arg (Subdirs_Option'Length + 1 .. Arg'Last));\n+                           null;\n+                           --  Subdirs are only used in gprclean\n \n-                        elsif Arg = Makeutl.Unchecked_Shared_Lib_Imports then\n+                        elsif Arg = Make_Util.Unchecked_Shared_Lib_Imports then\n                            Opt.Unchecked_Shared_Lib_Imports := True;\n \n                         else\n@@ -1745,9 +758,8 @@ package body Clean is\n                            Add_Lib_Search_Dir (Arg (4 .. Arg'Last));\n \n                         elsif Arg (3) = 'P' then\n-                           Prj.Env.Add_Directories\n-                             (Root_Environment.Project_Path,\n-                              Arg (4 .. Arg'Last));\n+                           null;\n+                           --  This is only for gprclean\n \n                         else\n                            Bad_Argument;\n@@ -1881,20 +893,19 @@ package body Clean is\n                         Quiet_Output := True;\n \n                      when 'r' =>\n-                        All_Projects := True;\n+                        null;\n+                        --  This is only for gprclean\n \n                      when 'v' =>\n                         if Arg = \"-v\" then\n                            Verbose_Mode := True;\n \n-                        elsif Arg = \"-vP0\" then\n-                           Current_Verbosity := Prj.Default;\n-\n-                        elsif Arg = \"-vP1\" then\n-                           Current_Verbosity := Prj.Medium;\n-\n-                        elsif Arg = \"-vP2\" then\n-                           Current_Verbosity := Prj.High;\n+                        elsif Arg = \"-vP0\"\n+                          or else Arg = \"-vP1\"\n+                          or else Arg = \"-vP2\"\n+                        then\n+                           null;\n+                           --  This is only for gprclean\n \n                         else\n                            Bad_Argument;\n@@ -1905,35 +916,6 @@ package body Clean is\n                            Bad_Argument;\n                         end if;\n \n-                        declare\n-                           Ext_Asgn  : constant String := Arg (3 .. Arg'Last);\n-                           Start     : Positive := Ext_Asgn'First;\n-                           Stop      : Natural  := Ext_Asgn'Last;\n-                           OK        : Boolean  := True;\n-\n-                        begin\n-                           if Ext_Asgn (Start) = '\"' then\n-                              if Ext_Asgn (Stop) = '\"' then\n-                                 Start := Start + 1;\n-                                 Stop  := Stop - 1;\n-\n-                              else\n-                                 OK := False;\n-                              end if;\n-                           end if;\n-\n-                           if not OK\n-                             or else not\n-                               Prj.Ext.Check (Root_Environment.External,\n-                                              Ext_Asgn (Start .. Stop))\n-                           then\n-                              Fail\n-                                (\"illegal external assignment '\"\n-                                 & Ext_Asgn\n-                                 & \"'\");\n-                           end if;\n-                        end;\n-\n                      when others =>\n                         Bad_Argument;\n                   end case;\n@@ -1999,7 +981,7 @@ package body Clean is\n          New_Line;\n \n          Put_Line (\"  --subdirs=dir real obj/lib/exec dirs are subdirs\");\n-         Put_Line (\"  \" & Makeutl.Unchecked_Shared_Lib_Imports);\n+         Put_Line (\"  \" & Make_Util.Unchecked_Shared_Lib_Imports);\n          Put_Line (\"       Allow shared libraries to import static libraries\");\n          New_Line;\n "}, {"sha": "cf6a56183c2e29c393fd891ad203aa0f55cedeb6", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315f0c424be6ad994f0253bd09d30c53cf47af8a/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315f0c424be6ad994f0253bd09d30c53cf47af8a/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=315f0c424be6ad994f0253bd09d30c53cf47af8a", "patch": "@@ -7675,6 +7675,7 @@ package body Exp_Util is\n          return\n            Present (Call)\n              and then Nkind (Call) = N_Function_Call\n+             and then Nkind (Name (Call)) in N_Has_Entity\n              and then Is_RTE (Entity (Name (Call)), RE_Displace);\n       end Is_Displace_Call;\n "}, {"sha": "a120ee46acd4d6a8ee46299ac874ddbc7680bbe6", "filename": "gcc/ada/gnatls.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315f0c424be6ad994f0253bd09d30c53cf47af8a/gcc%2Fada%2Fgnatls.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315f0c424be6ad994f0253bd09d30c53cf47af8a/gcc%2Fada%2Fgnatls.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatls.adb?ref=315f0c424be6ad994f0253bd09d30c53cf47af8a", "patch": "@@ -32,7 +32,7 @@ with Butil;       use Butil;\n with Csets;       use Csets;\n with Fname;       use Fname;\n with Gnatvsn;     use Gnatvsn;\n-with Makeutl;     use Makeutl;\n+with Make_Util;   use Make_Util;\n with Namet;       use Namet;\n with Opt;         use Opt;\n with Osint;       use Osint;"}, {"sha": "7540a1e557b85a1e251263cda8b5e6dccf87f4b2", "filename": "gcc/ada/gnatname.adb", "status": "modified", "additions": 732, "deletions": 98, "changes": 830, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315f0c424be6ad994f0253bd09d30c53cf47af8a/gcc%2Fada%2Fgnatname.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315f0c424be6ad994f0253bd09d30c53cf47af8a/gcc%2Fada%2Fgnatname.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatname.adb?ref=315f0c424be6ad994f0253bd09d30c53cf47af8a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -23,25 +23,36 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Ada.Command_Line;  use Ada.Command_Line;\n-with Ada.Text_IO;       use Ada.Text_IO;\n+with Ada.Characters.Handling;   use Ada.Characters.Handling;\n+with Ada.Command_Line;          use Ada.Command_Line;\n+with Ada.Text_IO;               use Ada.Text_IO;\n \n-with GNAT.Command_Line; use GNAT.Command_Line;\n+with GNAT.Command_Line;         use GNAT.Command_Line;\n+with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n with GNAT.Dynamic_Tables;\n-with GNAT.OS_Lib;       use GNAT.OS_Lib;\n+with GNAT.OS_Lib;               use GNAT.OS_Lib;\n \n+with Make_Util; use Make_Util;\n+with Namet;     use Namet;\n with Opt;\n-with Osint;    use Osint;\n-with Output;   use Output;\n-with Prj;      use Prj;\n-with Prj.Makr;\n-with Switch;   use Switch;\n+with Osint;     use Osint;\n+with Output;    use Output;\n+with Switch;    use Switch;\n with Table;\n+with Tempdir;\n+with Types;     use Types;\n \n-with System.Regexp; use System.Regexp;\n+with System.CRTL;\n+with System.Regexp;    use System.Regexp;\n \n procedure Gnatname is\n \n+   pragma Warnings (Off);\n+   type Matched_Type is (True, False, Excluded);\n+   pragma Warnings (On);\n+\n+   Create_Project : Boolean := False;\n+\n    Subdirs_Switch : constant String := \"--subdirs=\";\n \n    Usage_Output : Boolean := False;\n@@ -56,16 +67,30 @@ procedure Gnatname is\n    Very_Verbose : Boolean := False;\n    --  Set to True with -v -v\n \n-   Create_Project : Boolean := False;\n-   --  Set to True with a -P switch\n-\n    File_Path : String_Access := new String'(\"gnat.adc\");\n    --  Path name of the file specified by -c or -P switch\n \n    File_Set : Boolean := False;\n    --  Set to True by -c or -P switch.\n    --  Used to detect multiple -c/-P switches.\n \n+   Args : Argument_List_Access;\n+   --  The list of arguments for calls to the compiler to get the unit names\n+   --  and kinds (spec or body) in the Ada sources.\n+\n+   Path_Name : String_Access;\n+\n+   Path_Last : Natural;\n+\n+   Directory_Last    : Natural := 0;\n+\n+   function Dup (Fd : File_Descriptor) return File_Descriptor;\n+\n+   procedure Dup2 (Old_Fd, New_Fd : File_Descriptor);\n+\n+   Gcc      : constant String := \"gcc\";\n+   Gcc_Path : String_Access := null;\n+\n    package Patterns is new GNAT.Dynamic_Tables\n      (Table_Component_Type => String_Access,\n       Table_Index_Type     => Natural,\n@@ -100,6 +125,33 @@ procedure Gnatname is\n    --  Table to store the preprocessor switches to be used in the call\n    --  to the compiler.\n \n+   type Source is record\n+      File_Name : Name_Id;\n+      Unit_Name : Name_Id;\n+      Index     : Int := 0;\n+      Spec      : Boolean;\n+   end record;\n+\n+   package Processed_Directories is new Table.Table\n+     (Table_Component_Type => String_Access,\n+      Table_Index_Type     => Natural,\n+      Table_Low_Bound      => 0,\n+      Table_Initial        => 10,\n+      Table_Increment      => 100,\n+      Table_Name           => \"Prj.Makr.Processed_Directories\");\n+   --  The list of already processed directories for each section, to avoid\n+   --  processing several times the same directory in the same section.\n+\n+   package Sources is new Table.Table\n+     (Table_Component_Type => Source,\n+      Table_Index_Type     => Natural,\n+      Table_Low_Bound      => 0,\n+      Table_Initial        => 10,\n+      Table_Increment      => 100,\n+      Table_Name           => \"Gnatname.Sources\");\n+   --  The list of Ada sources found, with their unit name and kind, to be put\n+   --  in the pragmas Source_File_Name in the configuration pragmas file.\n+\n    procedure Output_Version;\n    --  Print name and version\n \n@@ -115,6 +167,49 @@ procedure Gnatname is\n    procedure Get_Directories (From_File : String);\n    --  Read a source directory text file\n \n+   procedure Write_Eol;\n+   --  Output an empty line\n+\n+   procedure Write_A_String (S : String);\n+   --  Write a String to Output_FD\n+\n+   procedure Initialize\n+     (File_Path         : String;\n+      Preproc_Switches  : Argument_List);\n+   --  Start the creation of a configuration pragmas file\n+   --\n+   --  File_Path is the name of the configuration pragmas file to create\n+   --\n+   --  Preproc_Switches is a list of switches to be used when invoking the\n+   --  compiler to get the name and kind of unit of a source file.\n+\n+   type Regexp_List is array (Positive range <>) of Regexp;\n+\n+   procedure Process\n+     (Directories       : Argument_List;\n+      Name_Patterns     : Regexp_List;\n+      Excluded_Patterns : Regexp_List;\n+      Foreign_Patterns  : Regexp_List);\n+   --  Look for source files in the specified directories, with the specified\n+   --  patterns.\n+   --\n+   --  Directories is the list of source directories where to look for sources.\n+   --\n+   --  Name_Patterns is a potentially empty list of file name patterns to check\n+   --  for Ada Sources.\n+   --\n+   --  Excluded_Patterns is a potentially empty list of file name patterns that\n+   --  should not be checked for Ada or non Ada sources.\n+   --\n+   --  Foreign_Patterns is a potentially empty list of file name patterns to\n+   --  check for non Ada sources.\n+   --\n+   --  At least one of Name_Patterns and Foreign_Patterns is not empty\n+\n+   procedure Finalize;\n+   --  Write the configuration pragmas file indicated in a call to procedure\n+   --  Initialize, after one or several calls to procedure Process.\n+\n    --------------------------\n    -- Add_Source_Directory --\n    --------------------------\n@@ -125,6 +220,26 @@ procedure Gnatname is\n         (Arguments.Table (Arguments.Last).Directories, new String'(S));\n    end Add_Source_Directory;\n \n+   ---------\n+   -- Dup --\n+   ---------\n+\n+   function Dup  (Fd : File_Descriptor) return File_Descriptor is\n+   begin\n+      return File_Descriptor (System.CRTL.dup (Integer (Fd)));\n+   end Dup;\n+\n+   ----------\n+   -- Dup2 --\n+   ----------\n+\n+   procedure Dup2 (Old_Fd, New_Fd : File_Descriptor) is\n+      Fd : Integer;\n+      pragma Warnings (Off, Fd);\n+   begin\n+      Fd := System.CRTL.dup2 (Integer (Old_Fd), Integer (New_Fd));\n+   end Dup2;\n+\n    ---------------------\n    -- Get_Directories --\n    ---------------------\n@@ -152,6 +267,504 @@ procedure Gnatname is\n          Fail (\"cannot open source directory file \"\"\" & From_File & '\"');\n    end Get_Directories;\n \n+   --------------\n+   -- Finalize --\n+   --------------\n+\n+   procedure Finalize is\n+      Discard : Boolean;\n+      pragma Warnings (Off, Discard);\n+\n+   begin\n+      --  Delete the file if it already exists\n+\n+      Delete_File\n+        (Path_Name (Directory_Last + 1 .. Path_Last),\n+         Success => Discard);\n+\n+      --  Create a new one\n+\n+      if Opt.Verbose_Mode then\n+         Output.Write_Str (\"Creating new file \"\"\");\n+         Output.Write_Str (Path_Name (Directory_Last + 1 .. Path_Last));\n+         Output.Write_Line (\"\"\"\");\n+      end if;\n+\n+      Output_FD := Create_New_File\n+        (Path_Name (Directory_Last + 1 .. Path_Last),\n+         Fmode => Text);\n+\n+      --  Fails if file cannot be created\n+\n+      if Output_FD = Invalid_FD then\n+         Fail_Program\n+           (\"cannot create new \"\"\" & Path_Name (1 .. Path_Last) & \"\"\"\");\n+      end if;\n+\n+      --  For each Ada source, write a pragma Source_File_Name to the\n+      --  configuration pragmas file.\n+\n+      for Index in 1 .. Sources.Last loop\n+         if Sources.Table (Index).Unit_Name /= No_Name then\n+            Write_A_String (\"pragma Source_File_Name\");\n+            Write_Eol;\n+            Write_A_String (\"  (\");\n+            Write_A_String\n+              (Get_Name_String (Sources.Table (Index).Unit_Name));\n+            Write_A_String (\",\");\n+            Write_Eol;\n+\n+            if Sources.Table (Index).Spec then\n+               Write_A_String (\"   Spec_File_Name => \"\"\");\n+\n+            else\n+               Write_A_String (\"   Body_File_Name => \"\"\");\n+            end if;\n+\n+            Write_A_String\n+              (Get_Name_String (Sources.Table (Index).File_Name));\n+\n+            Write_A_String (\"\"\"\");\n+\n+            if Sources.Table (Index).Index /= 0 then\n+               Write_A_String (\", Index =>\");\n+               Write_A_String (Sources.Table (Index).Index'Img);\n+            end if;\n+\n+            Write_A_String (\");\");\n+            Write_Eol;\n+         end if;\n+      end loop;\n+\n+      Close (Output_FD);\n+   end Finalize;\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize\n+     (File_Path         : String;\n+      Preproc_Switches  : Argument_List)\n+   is\n+   begin\n+      Sources.Set_Last (0);\n+\n+      --  Initialize the compiler switches\n+\n+      Args := new Argument_List (1 .. Preproc_Switches'Length + 6);\n+      Args (1) := new String'(\"-c\");\n+      Args (2) := new String'(\"-gnats\");\n+      Args (3) := new String'(\"-gnatu\");\n+      Args (4 .. 3 + Preproc_Switches'Length) := Preproc_Switches;\n+      Args (4 + Preproc_Switches'Length) := new String'(\"-x\");\n+      Args (5 + Preproc_Switches'Length) := new String'(\"ada\");\n+\n+      --  Get the path and file names\n+\n+      Path_Name := new\n+        String (1 .. File_Path'Length);\n+      Path_Last := File_Path'Length;\n+\n+      if File_Names_Case_Sensitive then\n+         Path_Name (1 .. Path_Last) := File_Path;\n+      else\n+         Path_Name (1 .. Path_Last) := To_Lower (File_Path);\n+      end if;\n+\n+      --  Get the end of directory information, if any\n+\n+      for Index in reverse 1 .. Path_Last loop\n+         if Path_Name (Index) = Directory_Separator then\n+            Directory_Last := Index;\n+            exit;\n+         end if;\n+      end loop;\n+\n+      --  Change the current directory to the directory of the project file,\n+      --  if any directory information is specified.\n+\n+      if Directory_Last /= 0 then\n+         begin\n+            Change_Dir (Path_Name (1 .. Directory_Last));\n+         exception\n+            when Directory_Error =>\n+               Fail_Program\n+                 (\"unknown directory \"\"\"\n+                  & Path_Name (1 .. Directory_Last)\n+                  & \"\"\"\");\n+         end;\n+      end if;\n+   end Initialize;\n+\n+   -------------\n+   -- Process --\n+   -------------\n+\n+   procedure Process\n+     (Directories       : Argument_List;\n+      Name_Patterns     : Regexp_List;\n+      Excluded_Patterns : Regexp_List;\n+      Foreign_Patterns  : Regexp_List)\n+  is\n+      procedure Process_Directory (Dir_Name : String);\n+      --  Look for Ada and foreign sources in a directory, according to the\n+      --  patterns.\n+\n+      -----------------------\n+      -- Process_Directory --\n+      -----------------------\n+\n+      procedure Process_Directory (Dir_Name : String) is\n+         Matched : Matched_Type := False;\n+         Str     : String (1 .. 2_000);\n+         Canon   : String (1 .. 2_000);\n+         Last    : Natural;\n+         Dir     : Dir_Type;\n+         Do_Process : Boolean := True;\n+\n+         Temp_File_Name         : String_Access := null;\n+         Save_Last_Source_Index : Natural := 0;\n+         File_Name_Id           : Name_Id := No_Name;\n+\n+         Current_Source : Source;\n+\n+      begin\n+         --  Avoid processing the same directory more than once\n+\n+         for Index in 1 .. Processed_Directories.Last loop\n+            if Processed_Directories.Table (Index).all = Dir_Name then\n+               Do_Process := False;\n+               exit;\n+            end if;\n+         end loop;\n+\n+         if Do_Process then\n+            if Opt.Verbose_Mode then\n+               Output.Write_Str (\"Processing directory \"\"\");\n+               Output.Write_Str (Dir_Name);\n+               Output.Write_Line (\"\"\"\");\n+            end if;\n+\n+            Processed_Directories. Increment_Last;\n+            Processed_Directories.Table (Processed_Directories.Last) :=\n+              new String'(Dir_Name);\n+\n+            --  Get the source file names from the directory. Fails if the\n+            --  directory does not exist.\n+\n+            begin\n+               Open (Dir, Dir_Name);\n+            exception\n+               when Directory_Error =>\n+                  Fail_Program (\"cannot open directory \"\"\" & Dir_Name & \"\"\"\");\n+            end;\n+\n+            --  Process each regular file in the directory\n+\n+            File_Loop : loop\n+               Read (Dir, Str, Last);\n+               exit File_Loop when Last = 0;\n+\n+               --  Copy the file name and put it in canonical case to match\n+               --  against the patterns that have themselves already been put\n+               --  in canonical case.\n+\n+               Canon (1 .. Last) := Str (1 .. Last);\n+               Canonical_Case_File_Name (Canon (1 .. Last));\n+\n+               if Is_Regular_File\n+                    (Dir_Name & Directory_Separator & Str (1 .. Last))\n+               then\n+                  Matched := True;\n+\n+                  Name_Len := Last;\n+                  Name_Buffer (1 .. Name_Len) := Str (1 .. Last);\n+                  File_Name_Id := Name_Find;\n+\n+                  --  First, check if the file name matches at least one of\n+                  --  the excluded expressions;\n+\n+                  for Index in Excluded_Patterns'Range loop\n+                     if\n+                       Match (Canon (1 .. Last), Excluded_Patterns (Index))\n+                     then\n+                        Matched := Excluded;\n+                        exit;\n+                     end if;\n+                  end loop;\n+\n+                  --  If it does not match any of the excluded expressions,\n+                  --  check if the file name matches at least one of the\n+                  --  regular expressions.\n+\n+                  if Matched = True then\n+                     Matched := False;\n+\n+                     for Index in Name_Patterns'Range loop\n+                        if\n+                          Match\n+                            (Canon (1 .. Last), Name_Patterns (Index))\n+                        then\n+                           Matched := True;\n+                           exit;\n+                        end if;\n+                     end loop;\n+                  end if;\n+\n+                  if Very_Verbose\n+                    or else (Matched = True and then Opt.Verbose_Mode)\n+                  then\n+                     Output.Write_Str (\"   Checking \"\"\");\n+                     Output.Write_Str (Str (1 .. Last));\n+                     Output.Write_Line (\"\"\": \");\n+                  end if;\n+\n+                  --  If the file name matches one of the regular expressions,\n+                  --  parse it to get its unit name.\n+\n+                  if Matched = True then\n+                     declare\n+                        FD : File_Descriptor;\n+                        Success : Boolean;\n+                        Saved_Output : File_Descriptor;\n+                        Saved_Error  : File_Descriptor;\n+                        Tmp_File     : Path_Name_Type;\n+\n+                     begin\n+                        --  If we don't have the path of the compiler yet,\n+                        --  get it now. The compiler name may have a prefix,\n+                        --  so we get the potentially prefixed name.\n+\n+                        if Gcc_Path = null then\n+                           declare\n+                              Prefix_Gcc : String_Access :=\n+                                             Program_Name (Gcc, \"gnatname\");\n+                           begin\n+                              Gcc_Path :=\n+                                Locate_Exec_On_Path (Prefix_Gcc.all);\n+                              Free (Prefix_Gcc);\n+                           end;\n+\n+                           if Gcc_Path = null then\n+                              Fail_Program (\"could not locate \" & Gcc);\n+                           end if;\n+                        end if;\n+\n+                        --  Create the temporary file\n+\n+                        Tempdir.Create_Temp_File (FD, Tmp_File);\n+\n+                        if FD = Invalid_FD then\n+                           Fail_Program\n+                             (\"could not create temporary file\");\n+\n+                        else\n+                           Temp_File_Name :=\n+                             new String'(Get_Name_String (Tmp_File));\n+                        end if;\n+\n+                        Args (Args'Last) :=\n+                          new String'\n+                            (Dir_Name & Directory_Separator & Str (1 .. Last));\n+\n+                        --  Save the standard output and error\n+\n+                        Saved_Output := Dup (Standout);\n+                        Saved_Error  := Dup (Standerr);\n+\n+                        --  Set standard output and error to the temporary file\n+\n+                        Dup2 (FD, Standout);\n+                        Dup2 (FD, Standerr);\n+\n+                        --  And spawn the compiler\n+\n+                        Spawn (Gcc_Path.all, Args.all, Success);\n+\n+                        --  Restore the standard output and error\n+\n+                        Dup2 (Saved_Output, Standout);\n+                        Dup2 (Saved_Error, Standerr);\n+\n+                        --  Close the temporary file\n+\n+                        Close (FD);\n+\n+                        --  And close the saved standard output and error to\n+                        --  avoid too many file descriptors.\n+\n+                        Close (Saved_Output);\n+                        Close (Saved_Error);\n+\n+                        --  Now that standard output is restored, check if\n+                        --  the compiler ran correctly.\n+\n+                        --  Read the lines of the temporary file:\n+                        --  they should contain the kind and name of the unit.\n+\n+                        declare\n+                           File      : Ada.Text_IO.File_Type;\n+                           Text_Line : String (1 .. 1_000);\n+                           Text_Last : Natural;\n+\n+                        begin\n+                           begin\n+                              Open (File, In_File, Temp_File_Name.all);\n+\n+                           exception\n+                              when others =>\n+                                 Fail_Program\n+                                   (\"could not read temporary file \" &\n+                                      Temp_File_Name.all);\n+                           end;\n+\n+                           Save_Last_Source_Index := Sources.Last;\n+\n+                           if End_Of_File (File) then\n+                              if Opt.Verbose_Mode then\n+                                 if not Success then\n+                                    Output.Write_Str (\"      (process died) \");\n+                                 end if;\n+                              end if;\n+\n+                           else\n+                              Line_Loop : while not End_Of_File (File) loop\n+                                 Get_Line (File, Text_Line, Text_Last);\n+\n+                                 --  Find the first closing parenthesis\n+\n+                                 Char_Loop : for J in 1 .. Text_Last loop\n+                                    if Text_Line (J) = ')' then\n+                                       if J >= 13 and then\n+                                         Text_Line (1 .. 4) = \"Unit\"\n+                                       then\n+                                          --  Add entry to Sources table\n+\n+                                          Name_Len := J - 12;\n+                                          Name_Buffer (1 .. Name_Len) :=\n+                                            Text_Line (6 .. J - 7);\n+                                          Current_Source :=\n+                                            (Unit_Name  => Name_Find,\n+                                             File_Name  => File_Name_Id,\n+                                             Index => 0,\n+                                             Spec  => Text_Line (J - 5 .. J) =\n+                                                        \"(spec)\");\n+\n+                                          Sources.Append (Current_Source);\n+                                       end if;\n+\n+                                       exit Char_Loop;\n+                                    end if;\n+                                 end loop Char_Loop;\n+                              end loop Line_Loop;\n+                           end if;\n+\n+                           if Save_Last_Source_Index = Sources.Last then\n+                              if Opt.Verbose_Mode then\n+                                 Output.Write_Line (\"      not a unit\");\n+                              end if;\n+\n+                           else\n+                              if Sources.Last >\n+                                   Save_Last_Source_Index + 1\n+                              then\n+                                 for Index in Save_Last_Source_Index + 1 ..\n+                                                Sources.Last\n+                                 loop\n+                                    Sources.Table (Index).Index :=\n+                                      Int (Index - Save_Last_Source_Index);\n+                                 end loop;\n+                              end if;\n+\n+                              for Index in Save_Last_Source_Index + 1 ..\n+                                             Sources.Last\n+                              loop\n+                                 Current_Source := Sources.Table (Index);\n+\n+                                 if Opt.Verbose_Mode then\n+                                    if Current_Source.Spec then\n+                                       Output.Write_Str (\"      spec of \");\n+\n+                                    else\n+                                       Output.Write_Str (\"      body of \");\n+                                    end if;\n+\n+                                    Output.Write_Line\n+                                      (Get_Name_String\n+                                         (Current_Source.Unit_Name));\n+                                 end if;\n+                              end loop;\n+                           end if;\n+\n+                           Close (File);\n+\n+                           Delete_File (Temp_File_Name.all, Success);\n+                        end;\n+                     end;\n+\n+                  --  File name matches none of the regular expressions\n+\n+                  else\n+                     --  If file is not excluded, see if this is foreign source\n+\n+                     if Matched /= Excluded then\n+                        for Index in Foreign_Patterns'Range loop\n+                           if Match (Canon (1 .. Last),\n+                                     Foreign_Patterns (Index))\n+                           then\n+                              Matched := True;\n+                              exit;\n+                           end if;\n+                        end loop;\n+                     end if;\n+\n+                     if Very_Verbose then\n+                        case Matched is\n+                           when False =>\n+                              Output.Write_Line (\"no match\");\n+\n+                           when Excluded =>\n+                              Output.Write_Line (\"excluded\");\n+\n+                           when True =>\n+                              Output.Write_Line (\"foreign source\");\n+                        end case;\n+                     end if;\n+\n+                     if Matched = True then\n+\n+                        --  Add source file name without unit name\n+\n+                        Name_Len := 0;\n+                        Add_Str_To_Name_Buffer (Canon (1 .. Last));\n+                        Sources.Append\n+                          ((File_Name => Name_Find,\n+                            Unit_Name => No_Name,\n+                            Index     => 0,\n+                            Spec      => False));\n+                     end if;\n+                  end if;\n+               end if;\n+            end loop File_Loop;\n+\n+            Close (Dir);\n+         end if;\n+\n+      end Process_Directory;\n+\n+   --  Start of processing for Process\n+\n+   begin\n+      Processed_Directories.Set_Last (0);\n+\n+      --  Process each directory\n+\n+      for Index in Directories'Range  loop\n+         Process_Directory (Directories (Index).all);\n+      end loop;\n+   end Process;\n+\n    --------------------\n    -- Output_Version --\n    --------------------\n@@ -243,7 +856,6 @@ procedure Gnatname is\n                elsif Pragmas_File_Expected then\n                   File_Set := True;\n                   File_Path := new String'(Arg);\n-                  Create_Project := False;\n                   Pragmas_File_Expected := False;\n \n                --  -d xxx\n@@ -343,8 +955,8 @@ procedure Gnatname is\n                elsif Arg'Length > Subdirs_Switch'Length\n                  and then Arg (1 .. Subdirs_Switch'Length) = Subdirs_Switch\n                then\n-                  Subdirs :=\n-                    new String'(Arg (Subdirs_Switch'Length + 1 .. Arg'Last));\n+                  null;\n+                  --  Subdirs are only used in gprname\n \n                --  --no-backup\n \n@@ -368,7 +980,6 @@ procedure Gnatname is\n                   else\n                      File_Set := True;\n                      File_Path := new String'(Arg (3 .. Arg'Last));\n-                     Create_Project := False;\n                   end if;\n \n                --  -d\n@@ -510,39 +1121,72 @@ procedure Gnatname is\n       if not Usage_Output then\n          Usage_Needed := False;\n          Usage_Output := True;\n-         Write_Str (\"Usage: \");\n+         Output.Write_Str (\"Usage: \");\n          Osint.Write_Program_Name;\n-         Write_Line (\" [switches] naming-pattern [naming-patterns]\");\n-         Write_Line (\"   {--and [switches] naming-pattern [naming-patterns]}\");\n-         Write_Eol;\n-         Write_Line (\"switches:\");\n+         Output.Write_Line (\" [switches] naming-pattern [naming-patterns]\");\n+         Output.Write_Line\n+           (\"   {--and [switches] naming-pattern [naming-patterns]}\");\n+         Output.Write_Eol;\n+         Output.Write_Line (\"switches:\");\n \n          Display_Usage_Version_And_Help;\n \n-         Write_Line (\"  --subdirs=dir real obj/lib/exec dirs are subdirs\");\n-         Write_Line (\"  --no-backup   do not create backup of project file\");\n-         Write_Eol;\n-\n-         Write_Line (\"  --and        use different patterns\");\n-         Write_Eol;\n-\n-         Write_Line (\"  -cfile       create configuration pragmas file\");\n-         Write_Line (\"  -ddir        use dir as one of the source \" &\n-                     \"directories\");\n-         Write_Line (\"  -Dfile       get source directories from file\");\n-         Write_Line (\"  -eL          follow symbolic links when processing \" &\n-                     \"project files\");\n-         Write_Line (\"  -fpat        foreign pattern\");\n-         Write_Line (\"  -gnateDsym=v preprocess with symbol definition\");\n-         Write_Line (\"  -gnatep=data preprocess files with data file\");\n-         Write_Line (\"  -h           output this help message\");\n-         Write_Line (\"  -Pproj       update or create project file proj\");\n-         Write_Line (\"  -v           verbose output\");\n-         Write_Line (\"  -v -v        very verbose output\");\n-         Write_Line (\"  -xpat        exclude pattern pat\");\n+         Output.Write_Line\n+           (\"  --subdirs=dir real obj/lib/exec dirs are subdirs\");\n+         Output.Write_Line\n+           (\"  --no-backup   do not create backup of project file\");\n+         Output.Write_Eol;\n+\n+         Output.Write_Line (\"  --and        use different patterns\");\n+         Output.Write_Eol;\n+\n+         Output.Write_Line\n+           (\"  -cfile       create configuration pragmas file\");\n+         Output.Write_Line (\"  -ddir        use dir as one of the source \" &\n+                            \"directories\");\n+         Output.Write_Line (\"  -Dfile       get source directories from file\");\n+         Output.Write_Line\n+           (\"  -eL          follow symbolic links when processing \" &\n+            \"project files\");\n+         Output.Write_Line (\"  -fpat        foreign pattern\");\n+         Output.Write_Line\n+           (\"  -gnateDsym=v preprocess with symbol definition\");\n+         Output.Write_Line (\"  -gnatep=data preprocess files with data file\");\n+         Output.Write_Line (\"  -h           output this help message\");\n+         Output.Write_Line\n+           (\"  -Pproj       update or create project file proj\");\n+         Output.Write_Line (\"  -v           verbose output\");\n+         Output.Write_Line (\"  -v -v        very verbose output\");\n+         Output.Write_Line (\"  -xpat        exclude pattern pat\");\n       end if;\n    end Usage;\n \n+   ---------------\n+   -- Write_Eol --\n+   ---------------\n+\n+   procedure Write_Eol is\n+   begin\n+      Write_A_String ((1 => ASCII.LF));\n+   end Write_Eol;\n+\n+   --------------------\n+   -- Write_A_String --\n+   --------------------\n+\n+   procedure Write_A_String (S : String) is\n+      Str : String (1 .. S'Length);\n+\n+   begin\n+      if S'Length > 0 then\n+         Str := S;\n+\n+         if Write (Output_FD, Str (1)'Address, Str'Length) /= Str'Length then\n+            Fail_Program (\"disk full\");\n+         end if;\n+      end if;\n+   end Write_A_String;\n+\n --  Start of processing for Gnatname\n \n begin\n@@ -601,67 +1245,60 @@ begin\n \n    Scan_Args;\n \n-   if Opt.Verbose_Mode then\n-      Output_Version;\n-   end if;\n-\n-   if Usage_Needed then\n-      Usage;\n-   end if;\n-\n    if Create_Project then\n       declare\n-         Gnatname : constant String_Access :=\n-                      Program_Name (\"gnatname\", \"gnatname\");\n-         Arg_Len  : Positive      := Argument_Count;\n-         Target   : String_Access := null;\n-\n+         Gprname_Path : constant String_Access :=\n+           Locate_Exec_On_Path (\"gprname\");\n+         Arg_Len : Natural       := Argument_Count;\n+         Pos     : Natural       := 0;\n+         Target  : String_Access := null;\n+         Success : Boolean       := False;\n       begin\n-         --  Find the target, if any\n+         if Gprname_Path = null then\n+            Fail_Program\n+              (\"project files are no longer supported by gnatname;\" &\n+               \" use gprname instead\");\n+         end if;\n \n-         if Gnatname.all /= \"gnatname\" then\n-            Target :=\n-              new String'(Gnatname (Gnatname'First .. Gnatname'Last - 9));\n+         Find_Program_Name;\n+\n+         if Name_Len > 9\n+            and then Name_Buffer (Name_Len - 7 .. Name_Len) = \"gnatname\"\n+         then\n+            Target  := new String'(Name_Buffer (1 .. Name_Len - 9));\n             Arg_Len := Arg_Len + 1;\n          end if;\n \n          declare\n-            Args    : Argument_List (1 .. Arg_Len);\n-            Gprname : String_Access :=\n-                        Locate_Exec_On_Path (Exec_Name => \"gprname\");\n-            Success : Boolean;\n-\n+            Args : Argument_List (1 .. Arg_Len);\n          begin\n-            if Gprname /= null then\n-               for J in 1 .. Argument_Count loop\n-                  Args (J) := new String'(Argument (J));\n-               end loop;\n-\n-               --  Add the target if there is one\n-\n-               if Target /= null then\n-                  Args (Args'Last) := new String'(\"--target=\" & Target.all);\n-               end if;\n+            if Target /= null then\n+               Args (1) := new String'(\"--target=\" & Target.all);\n+               Pos := 1;\n+            end if;\n \n-               Spawn (Gprname.all, Args, Success);\n+            for J in 1 .. Argument_Count loop\n+               Pos := Pos + 1;\n+               Args (Pos) := new String'(Argument (J));\n+            end loop;\n \n-               Free (Gprname);\n+            Spawn (Gprname_Path.all, Args, Success);\n \n-               if Success then\n-                  Exit_Program (E_Success);\n-               end if;\n+            if Success then\n+               Exit_Program (E_Success);\n+            else\n+               Exit_Program (E_Errors);\n             end if;\n          end;\n       end;\n    end if;\n \n-   --  This only happens if gprname is not found or if the invocation of\n-   --  gprname did not succeed.\n+   if Opt.Verbose_Mode then\n+      Output_Version;\n+   end if;\n \n-   if Create_Project then\n-      Write_Line\n-        (\"warning: gnatname -P is obsolete and will not be available in the\" &\n-         \" next release; use gprname instead\");\n+   if Usage_Needed then\n+      Usage;\n    end if;\n \n    --  If no Ada or foreign pattern was specified, print the usage and return\n@@ -700,12 +1337,9 @@ begin\n          Prep_Switches (Index) := Preprocessor_Switches.Table (Index);\n       end loop;\n \n-      Prj.Makr.Initialize\n+      Initialize\n         (File_Path         => File_Path.all,\n-         Project_File      => Create_Project,\n-         Preproc_Switches  => Prep_Switches,\n-         Very_Verbose      => Very_Verbose,\n-         Flags             => Gnatmake_Flags);\n+         Preproc_Switches  => Prep_Switches);\n    end;\n \n    --  Process each section successively\n@@ -715,13 +1349,13 @@ begin\n          Directories   : Argument_List\n            (1 .. Integer\n                    (Patterns.Last (Arguments.Table (J).Directories)));\n-         Name_Patterns : Prj.Makr.Regexp_List\n+         Name_Patterns : Regexp_List\n            (1 .. Integer\n                    (Patterns.Last (Arguments.Table (J).Name_Patterns)));\n-         Excl_Patterns : Prj.Makr.Regexp_List\n+         Excl_Patterns : Regexp_List\n            (1 .. Integer\n                    (Patterns.Last (Arguments.Table (J).Excluded_Patterns)));\n-         Frgn_Patterns : Prj.Makr.Regexp_List\n+         Frgn_Patterns : Regexp_List\n            (1 .. Integer\n                    (Patterns.Last (Arguments.Table (J).Foreign_Patterns)));\n \n@@ -756,7 +1390,7 @@ begin\n \n          --  Call Prj.Makr.Process where the real work is done\n \n-         Prj.Makr.Process\n+         Process\n            (Directories       => Directories,\n             Name_Patterns     => Name_Patterns,\n             Excluded_Patterns => Excl_Patterns,\n@@ -766,9 +1400,9 @@ begin\n \n    --  Finalize\n \n-   Prj.Makr.Finalize;\n+   Finalize;\n \n    if Opt.Verbose_Mode then\n-      Write_Eol;\n+      Output.Write_Eol;\n    end if;\n end Gnatname;"}, {"sha": "ae17868f57e671e4c170b1cc4cc3bd49006a3c55", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 498, "deletions": 3599, "changes": 4097, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315f0c424be6ad994f0253bd09d30c53cf47af8a/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315f0c424be6ad994f0253bd09d30c53cf47af8a/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=315f0c424be6ad994f0253bd09d30c53cf47af8a"}, {"sha": "27f1319a8ff32c4ef8114d6dfbc4ff783d876d1b", "filename": "gcc/ada/make_util.adb", "status": "added", "additions": 964, "deletions": 0, "changes": 964, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315f0c424be6ad994f0253bd09d30c53cf47af8a/gcc%2Fada%2Fmake_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315f0c424be6ad994f0253bd09d30c53cf47af8a/gcc%2Fada%2Fmake_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake_util.adb?ref=315f0c424be6ad994f0253bd09d30c53cf47af8a", "patch": "@@ -0,0 +1,964 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                            M A K E _ U T I L                             --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2004-2017, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Atree;    use Atree;\n+with Debug;\n+with Errutil;\n+with Osint;    use Osint;\n+with Output;   use Output;\n+with Opt;      use Opt;\n+with Table;\n+\n+with Ada.Command_Line;           use Ada.Command_Line;\n+\n+with GNAT.Case_Util;             use GNAT.Case_Util;\n+with GNAT.Directory_Operations;  use GNAT.Directory_Operations;\n+with GNAT.HTable;\n+\n+package body Make_Util is\n+\n+   ---------\n+   -- Add --\n+   ---------\n+\n+   procedure Add\n+     (Option : String_Access;\n+      To     : in out String_List_Access;\n+      Last   : in out Natural)\n+   is\n+   begin\n+      if Last = To'Last then\n+         declare\n+            New_Options : constant String_List_Access :=\n+                            new String_List (1 .. To'Last * 2);\n+\n+         begin\n+            New_Options (To'Range) := To.all;\n+\n+            --  Set all elements of the original options to null to avoid\n+            --  deallocation of copies.\n+\n+            To.all := (others => null);\n+\n+            Free (To);\n+            To := New_Options;\n+         end;\n+      end if;\n+\n+      Last := Last + 1;\n+      To (Last) := Option;\n+   end Add;\n+\n+   procedure Add\n+     (Option : String;\n+      To     : in out String_List_Access;\n+      Last   : in out Natural)\n+   is\n+   begin\n+      Add (Option => new String'(Option), To => To, Last => Last);\n+   end Add;\n+\n+   -------------------------\n+   -- Base_Name_Index_For --\n+   -------------------------\n+\n+   function Base_Name_Index_For\n+     (Main            : String;\n+      Main_Index      : Int;\n+      Index_Separator : Character) return File_Name_Type\n+   is\n+      Result : File_Name_Type;\n+\n+   begin\n+      Name_Len := 0;\n+      Add_Str_To_Name_Buffer (Base_Name (Main));\n+\n+      --  Remove the extension, if any, that is the last part of the base name\n+      --  starting with a dot and following some characters.\n+\n+      for J in reverse 2 .. Name_Len loop\n+         if Name_Buffer (J) = '.' then\n+            Name_Len := J - 1;\n+            exit;\n+         end if;\n+      end loop;\n+\n+      --  Add the index info, if index is different from 0\n+\n+      if Main_Index > 0 then\n+         Add_Char_To_Name_Buffer (Index_Separator);\n+\n+         declare\n+            Img : constant String := Main_Index'Img;\n+         begin\n+            Add_Str_To_Name_Buffer (Img (2 .. Img'Last));\n+         end;\n+      end if;\n+\n+      Result := Name_Find;\n+      return Result;\n+   end Base_Name_Index_For;\n+\n+   -----------------\n+   -- Create_Name --\n+   -----------------\n+\n+   function Create_Name (Name : String) return File_Name_Type is\n+   begin\n+      Name_Len := 0;\n+      Add_Str_To_Name_Buffer (Name);\n+      return Name_Find;\n+   end Create_Name;\n+\n+   function Create_Name (Name : String) return Name_Id is\n+   begin\n+      Name_Len := 0;\n+      Add_Str_To_Name_Buffer (Name);\n+      return Name_Find;\n+   end Create_Name;\n+\n+   function Create_Name (Name : String) return Path_Name_Type is\n+   begin\n+      Name_Len := 0;\n+      Add_Str_To_Name_Buffer (Name);\n+      return Name_Find;\n+   end Create_Name;\n+\n+   ---------------------------\n+   -- Ensure_Absolute_Path --\n+   ---------------------------\n+\n+   procedure Ensure_Absolute_Path\n+     (Switch               : in out String_Access;\n+      Parent               : String;\n+      Do_Fail              : Fail_Proc;\n+      For_Gnatbind         : Boolean := False;\n+      Including_Non_Switch : Boolean := True;\n+      Including_RTS        : Boolean := False)\n+   is\n+   begin\n+      if Switch /= null then\n+         declare\n+            Sw    : String (1 .. Switch'Length);\n+            Start : Positive;\n+\n+         begin\n+            Sw := Switch.all;\n+\n+            if Sw (1) = '-' then\n+               if Sw'Length >= 3\n+                 and then (Sw (2) = 'I'\n+                            or else (not For_Gnatbind\n+                                      and then (Sw (2) = 'L'\n+                                                 or else\n+                                                Sw (2) = 'A')))\n+               then\n+                  Start := 3;\n+\n+                  if Sw = \"-I-\" then\n+                     return;\n+                  end if;\n+\n+               elsif Sw'Length >= 4\n+                 and then\n+                   (Sw (2 .. 3) = \"aL\" or else\n+                    Sw (2 .. 3) = \"aO\" or else\n+                    Sw (2 .. 3) = \"aI\"\n+                      or else (For_Gnatbind and then Sw (2 .. 3) = \"A=\"))\n+               then\n+                  Start := 4;\n+\n+               elsif Including_RTS\n+                 and then Sw'Length >= 7\n+                 and then Sw (2 .. 6) = \"-RTS=\"\n+               then\n+                  Start := 7;\n+\n+               else\n+                  return;\n+               end if;\n+\n+               --  Because relative path arguments to --RTS= may be relative to\n+               --  the search directory prefix, those relative path arguments\n+               --  are converted only when they include directory information.\n+\n+               if not Is_Absolute_Path (Sw (Start .. Sw'Last)) then\n+                  if Parent'Length = 0 then\n+                     Do_Fail\n+                       (\"relative search path switches (\"\"\"\n+                        & Sw\n+                        & \"\"\") are not allowed\");\n+\n+                  elsif Including_RTS then\n+                     for J in Start .. Sw'Last loop\n+                        if Sw (J) = Directory_Separator then\n+                           Switch :=\n+                             new String'\n+                               (Sw (1 .. Start - 1)\n+                                & Parent\n+                                & Directory_Separator\n+                                & Sw (Start .. Sw'Last));\n+                           return;\n+                        end if;\n+                     end loop;\n+\n+                  else\n+                     Switch :=\n+                       new String'\n+                         (Sw (1 .. Start - 1)\n+                          & Parent\n+                          & Directory_Separator\n+                          & Sw (Start .. Sw'Last));\n+                  end if;\n+               end if;\n+\n+            elsif Including_Non_Switch then\n+               if not Is_Absolute_Path (Sw) then\n+                  if Parent'Length = 0 then\n+                     Do_Fail\n+                       (\"relative paths (\"\"\" & Sw & \"\"\") are not allowed\");\n+                  else\n+                     Switch := new String'(Parent & Directory_Separator & Sw);\n+                  end if;\n+               end if;\n+            end if;\n+         end;\n+      end if;\n+   end Ensure_Absolute_Path;\n+\n+   ----------------------------\n+   -- Executable_Prefix_Path --\n+   ----------------------------\n+\n+   function Executable_Prefix_Path return String is\n+      Exec_Name : constant String := Command_Name;\n+\n+      function Get_Install_Dir (S : String) return String;\n+      --  S is the executable name preceded by the absolute or relative path,\n+      --  e.g. \"c:\\usr\\bin\\gcc.exe\". Returns the absolute directory where \"bin\"\n+      --  lies (in the example \"C:\\usr\"). If the executable is not in a \"bin\"\n+      --  directory, return \"\".\n+\n+      ---------------------\n+      -- Get_Install_Dir --\n+      ---------------------\n+\n+      function Get_Install_Dir (S : String) return String is\n+         Exec      : String  := S;\n+         Path_Last : Integer := 0;\n+\n+      begin\n+         for J in reverse Exec'Range loop\n+            if Exec (J) = Directory_Separator then\n+               Path_Last := J - 1;\n+               exit;\n+            end if;\n+         end loop;\n+\n+         if Path_Last >= Exec'First + 2 then\n+            To_Lower (Exec (Path_Last - 2 .. Path_Last));\n+         end if;\n+\n+         if Path_Last < Exec'First + 2\n+           or else Exec (Path_Last - 2 .. Path_Last) /= \"bin\"\n+           or else (Path_Last - 3 >= Exec'First\n+                     and then Exec (Path_Last - 3) /= Directory_Separator)\n+         then\n+            return \"\";\n+         end if;\n+\n+         return Normalize_Pathname\n+                  (Exec (Exec'First .. Path_Last - 4),\n+                   Resolve_Links => Opt.Follow_Links_For_Dirs)\n+           & Directory_Separator;\n+      end Get_Install_Dir;\n+\n+   --  Beginning of Executable_Prefix_Path\n+\n+   begin\n+      --  First determine if a path prefix was placed in front of the\n+      --  executable name.\n+\n+      for J in reverse Exec_Name'Range loop\n+         if Exec_Name (J) = Directory_Separator then\n+            return Get_Install_Dir (Exec_Name);\n+         end if;\n+      end loop;\n+\n+      --  If we get here, the user has typed the executable name with no\n+      --  directory prefix.\n+\n+      declare\n+         Path : String_Access := Locate_Exec_On_Path (Exec_Name);\n+      begin\n+         if Path = null then\n+            return \"\";\n+         else\n+            declare\n+               Dir : constant String := Get_Install_Dir (Path.all);\n+            begin\n+               Free (Path);\n+               return Dir;\n+            end;\n+         end if;\n+      end;\n+   end Executable_Prefix_Path;\n+\n+   ------------------\n+   -- Fail_Program --\n+   ------------------\n+\n+   procedure Fail_Program\n+     (S              : String;\n+      Flush_Messages : Boolean := True)\n+   is\n+   begin\n+      if Flush_Messages and not No_Exit_Message then\n+         if Total_Errors_Detected /= 0 or else Warnings_Detected /= 0 then\n+            Errutil.Finalize;\n+         end if;\n+      end if;\n+\n+      Finish_Program (E_Fatal, S => S);\n+   end Fail_Program;\n+\n+   --------------------\n+   -- Finish_Program --\n+   --------------------\n+\n+   procedure Finish_Program\n+     (Exit_Code    : Osint.Exit_Code_Type := Osint.E_Success;\n+      S            : String := \"\")\n+   is\n+   begin\n+      if S'Length > 0 then\n+         if Exit_Code /= E_Success then\n+            if No_Exit_Message then\n+               Osint.Exit_Program (E_Fatal);\n+            else\n+               Osint.Fail (S);\n+            end if;\n+\n+         elsif not No_Exit_Message then\n+            Write_Str (S);\n+         end if;\n+      end if;\n+\n+      --  Output Namet statistics\n+\n+      Namet.Finalize;\n+\n+      Exit_Program (Exit_Code);\n+   end Finish_Program;\n+\n+   ----------\n+   -- Hash --\n+   ----------\n+\n+   function Hash is new GNAT.HTable.Hash (Header_Num => Header_Num);\n+   --  Used in implementation of other functions Hash below\n+\n+   ----------\n+   -- Hash --\n+   ----------\n+\n+   function Hash (Name : File_Name_Type) return Header_Num is\n+   begin\n+      return Hash (Get_Name_String (Name));\n+   end Hash;\n+\n+   function Hash (Name : Name_Id) return Header_Num is\n+   begin\n+      return Hash (Get_Name_String (Name));\n+   end Hash;\n+\n+   function Hash (Name : Path_Name_Type) return Header_Num is\n+   begin\n+      return Hash (Get_Name_String (Name));\n+   end Hash;\n+\n+   ------------\n+   -- Inform --\n+   ------------\n+\n+   procedure Inform (N : File_Name_Type; Msg : String) is\n+   begin\n+      Inform (Name_Id (N), Msg);\n+   end Inform;\n+\n+   procedure Inform (N : Name_Id := No_Name; Msg : String) is\n+   begin\n+      Osint.Write_Program_Name;\n+\n+      Write_Str (\": \");\n+\n+      if N /= No_Name then\n+         Write_Str (\"\"\"\");\n+\n+         declare\n+            Name : constant String := Get_Name_String (N);\n+         begin\n+            if Debug.Debug_Flag_F and then Is_Absolute_Path (Name) then\n+               Write_Str (File_Name (Name));\n+            else\n+               Write_Str (Name);\n+            end if;\n+         end;\n+\n+         Write_Str (\"\"\" \");\n+      end if;\n+\n+      Write_Str (Msg);\n+      Write_Eol;\n+   end Inform;\n+\n+   -----------\n+   -- Mains --\n+   -----------\n+\n+   package body Mains is\n+\n+      package Names is new Table.Table\n+        (Table_Component_Type => Main_Info,\n+         Table_Index_Type     => Integer,\n+         Table_Low_Bound      => 1,\n+         Table_Initial        => 10,\n+         Table_Increment      => 100,\n+         Table_Name           => \"Makeutl.Mains.Names\");\n+      --  The table that stores the mains\n+\n+      Current : Natural := 0;\n+      --  The index of the last main retrieved from the table\n+\n+      Count_Of_Mains_With_No_Tree : Natural := 0;\n+      --  Number of main units for which we do not know the project tree\n+\n+      --------------\n+      -- Add_Main --\n+      --------------\n+\n+      procedure Add_Main (Name : String; Index : Int := 0) is\n+      begin\n+         Name_Len := 0;\n+         Add_Str_To_Name_Buffer (Name);\n+         Canonical_Case_File_Name (Name_Buffer (1 .. Name_Len));\n+\n+         Names.Increment_Last;\n+         Names.Table (Names.Last) := (Name_Find, Index);\n+\n+         Mains.Count_Of_Mains_With_No_Tree :=\n+           Mains.Count_Of_Mains_With_No_Tree + 1;\n+      end Add_Main;\n+\n+      ------------\n+      -- Delete --\n+      ------------\n+\n+      procedure Delete is\n+      begin\n+         Names.Set_Last (0);\n+         Mains.Reset;\n+      end Delete;\n+\n+      ---------------\n+      -- Next_Main --\n+      ---------------\n+\n+      function Next_Main return String is\n+         Info : constant Main_Info := Next_Main;\n+      begin\n+         if Info = No_Main_Info then\n+            return \"\";\n+         else\n+            return Get_Name_String (Info.File);\n+         end if;\n+      end Next_Main;\n+\n+      function Next_Main return Main_Info is\n+      begin\n+         if Current >= Names.Last then\n+            return No_Main_Info;\n+         else\n+            Current := Current + 1;\n+\n+            declare\n+               Orig_Main : constant File_Name_Type :=\n+                 Names.Table (Current).File;\n+               Current_Main : File_Name_Type;\n+\n+            begin\n+               if Strip_Suffix (Orig_Main) = Orig_Main then\n+                  Get_Name_String (Orig_Main);\n+                  Add_Str_To_Name_Buffer (\".adb\");\n+                  Current_Main := Name_Find;\n+\n+                  if Full_Source_Name (Current_Main) = No_File then\n+                     Get_Name_String (Orig_Main);\n+                     Add_Str_To_Name_Buffer (\".ads\");\n+                     Current_Main := Name_Find;\n+\n+                     if Full_Source_Name (Current_Main) /= No_File then\n+                        Names.Table (Current).File := Current_Main;\n+                     end if;\n+\n+                  else\n+                     Names.Table (Current).File := Current_Main;\n+                  end if;\n+               end if;\n+            end;\n+\n+            return Names.Table (Current);\n+         end if;\n+      end Next_Main;\n+\n+      ---------------------\n+      -- Number_Of_Mains --\n+      ---------------------\n+\n+      function Number_Of_Mains return Natural is\n+      begin\n+         return Names.Last;\n+      end Number_Of_Mains;\n+\n+      -----------\n+      -- Reset --\n+      -----------\n+\n+      procedure Reset is\n+      begin\n+         Current := 0;\n+      end Reset;\n+\n+      --------------------------\n+      -- Set_Multi_Unit_Index --\n+      --------------------------\n+\n+      procedure Set_Multi_Unit_Index\n+        (Index        : Int := 0)\n+      is\n+      begin\n+         if Index /= 0 then\n+            if Names.Last = 0 then\n+               Fail_Program\n+                 (\"cannot specify a multi-unit index but no main \"\n+                  & \"on the command line\");\n+\n+            elsif Names.Last > 1 then\n+               Fail_Program\n+                 (\"cannot specify several mains with a multi-unit index\");\n+\n+            else\n+               Names.Table (Names.Last).Index := Index;\n+            end if;\n+         end if;\n+      end Set_Multi_Unit_Index;\n+\n+   end Mains;\n+\n+   -----------------------\n+   -- Path_Or_File_Name --\n+   -----------------------\n+\n+   function Path_Or_File_Name (Path : Path_Name_Type) return String is\n+      Path_Name : constant String := Get_Name_String (Path);\n+   begin\n+      if Debug.Debug_Flag_F then\n+         return File_Name (Path_Name);\n+      else\n+         return Path_Name;\n+      end if;\n+   end Path_Or_File_Name;\n+\n+   -------------------\n+   -- Unit_Index_Of --\n+   -------------------\n+\n+   function Unit_Index_Of (ALI_File : File_Name_Type) return Int is\n+      Start  : Natural;\n+      Finish : Natural;\n+      Result : Int := 0;\n+\n+   begin\n+      Get_Name_String (ALI_File);\n+\n+      --  First, find the last dot\n+\n+      Finish := Name_Len;\n+\n+      while Finish >= 1 and then Name_Buffer (Finish) /= '.' loop\n+         Finish := Finish - 1;\n+      end loop;\n+\n+      if Finish = 1 then\n+         return 0;\n+      end if;\n+\n+      --  Now check that the dot is preceded by digits\n+\n+      Start := Finish;\n+      Finish := Finish - 1;\n+      while Start >= 1 and then Name_Buffer (Start - 1) in '0' .. '9' loop\n+         Start := Start - 1;\n+      end loop;\n+\n+      --  If there are no digits, or if the digits are not preceded by the\n+      --  character that precedes a unit index, this is not the ALI file of\n+      --  a unit in a multi-unit source.\n+\n+      if Start > Finish\n+        or else Start = 1\n+        or else Name_Buffer (Start - 1) /= Multi_Unit_Index_Character\n+      then\n+         return 0;\n+      end if;\n+\n+      --  Build the index from the digit(s)\n+\n+      while Start <= Finish loop\n+         Result := Result * 10 +\n+                     Character'Pos (Name_Buffer (Start)) - Character'Pos ('0');\n+         Start := Start + 1;\n+      end loop;\n+\n+      return Result;\n+   end Unit_Index_Of;\n+\n+   -----------------\n+   -- Verbose_Msg --\n+   -----------------\n+\n+   procedure Verbose_Msg\n+     (N1                : Name_Id;\n+      S1                : String;\n+      N2                : Name_Id := No_Name;\n+      S2                : String  := \"\";\n+      Prefix            : String := \"  -> \";\n+      Minimum_Verbosity : Opt.Verbosity_Level_Type := Opt.Low)\n+   is\n+   begin\n+      if not Opt.Verbose_Mode\n+        or else Minimum_Verbosity > Opt.Verbosity_Level\n+      then\n+         return;\n+      end if;\n+\n+      Write_Str (Prefix);\n+      Write_Str (\"\"\"\");\n+      Write_Name (N1);\n+      Write_Str (\"\"\" \");\n+      Write_Str (S1);\n+\n+      if N2 /= No_Name then\n+         Write_Str (\" \"\"\");\n+         Write_Name (N2);\n+         Write_Str (\"\"\" \");\n+      end if;\n+\n+      Write_Str (S2);\n+      Write_Eol;\n+   end Verbose_Msg;\n+\n+   procedure Verbose_Msg\n+     (N1                : File_Name_Type;\n+      S1                : String;\n+      N2                : File_Name_Type := No_File;\n+      S2                : String  := \"\";\n+      Prefix            : String := \"  -> \";\n+      Minimum_Verbosity : Opt.Verbosity_Level_Type := Opt.Low)\n+   is\n+   begin\n+      Verbose_Msg\n+        (Name_Id (N1), S1, Name_Id (N2), S2, Prefix, Minimum_Verbosity);\n+   end Verbose_Msg;\n+\n+   -----------\n+   -- Queue --\n+   -----------\n+\n+   package body Queue is\n+\n+      type Q_Record is record\n+         Info      : Source_Info;\n+         Processed : Boolean;\n+      end record;\n+\n+      package Q is new Table.Table\n+        (Table_Component_Type => Q_Record,\n+         Table_Index_Type     => Natural,\n+         Table_Low_Bound      => 1,\n+         Table_Initial        => 1000,\n+         Table_Increment      => 100,\n+         Table_Name           => \"Makeutl.Queue.Q\");\n+      --  This is the actual Queue\n+\n+      type Mark_Key is record\n+         File  : File_Name_Type;\n+         Index : Int;\n+      end record;\n+      --  Identify either a mono-unit source (when Index = 0) or a specific\n+      --  unit (index = 1's origin index of unit) in a multi-unit source.\n+\n+      Max_Mask_Num : constant := 2048;\n+      subtype Mark_Num is Union_Id range 0 .. Max_Mask_Num - 1;\n+\n+      function Hash (Key : Mark_Key) return Mark_Num;\n+\n+      package Marks is new GNAT.HTable.Simple_HTable\n+        (Header_Num => Mark_Num,\n+         Element    => Boolean,\n+         No_Element => False,\n+         Key        => Mark_Key,\n+         Hash       => Hash,\n+         Equal      => \"=\");\n+      --  A hash table to keep tracks of the marked units.\n+      --  These are the units that have already been processed, when using the\n+      --  gnatmake format. When using the gprbuild format, we can directly\n+      --  store in the source_id whether the file has already been processed.\n+\n+      procedure Mark (Source_File : File_Name_Type; Index : Int := 0);\n+      --  Mark a unit, identified by its source file and, when Index is not 0,\n+      --  the index of the unit in the source file. Marking is used to signal\n+      --  that the unit has already been inserted in the Q.\n+\n+      function Is_Marked\n+        (Source_File : File_Name_Type;\n+         Index       : Int := 0) return Boolean;\n+      --  Returns True if the unit was previously marked\n+\n+      Q_Processed   : Natural := 0;\n+      Q_Initialized : Boolean := False;\n+\n+      Q_First : Natural := 1;\n+      --  Points to the first valid element in the queue\n+\n+      procedure Debug_Display (S : Source_Info);\n+      --  A debug display for S\n+\n+      function Was_Processed (S : Source_Info) return Boolean;\n+      --  Whether S has already been processed. This marks the source as\n+      --  processed, if it hasn't already been processed.\n+\n+      -------------------\n+      -- Was_Processed --\n+      -------------------\n+\n+      function Was_Processed (S : Source_Info) return Boolean is\n+      begin\n+         if Is_Marked (S.File, S.Index) then\n+            return True;\n+         end if;\n+\n+         Mark (S.File, Index => S.Index);\n+\n+         return False;\n+      end Was_Processed;\n+\n+      -------------------\n+      -- Debug_Display --\n+      -------------------\n+\n+      procedure Debug_Display (S : Source_Info) is\n+      begin\n+         Write_Name (S.File);\n+\n+         if S.Index /= 0 then\n+            Write_Str (\", \");\n+            Write_Int (S.Index);\n+         end if;\n+      end Debug_Display;\n+\n+      ----------\n+      -- Hash --\n+      ----------\n+\n+      function Hash (Key : Mark_Key) return Mark_Num is\n+      begin\n+         return Union_Id (Key.File) mod Max_Mask_Num;\n+      end Hash;\n+\n+      ---------------\n+      -- Is_Marked --\n+      ---------------\n+\n+      function Is_Marked\n+        (Source_File : File_Name_Type;\n+         Index       : Int := 0) return Boolean\n+      is\n+      begin\n+         return Marks.Get (K => (File => Source_File, Index => Index));\n+      end Is_Marked;\n+\n+      ----------\n+      -- Mark --\n+      ----------\n+\n+      procedure Mark (Source_File : File_Name_Type; Index : Int := 0) is\n+      begin\n+         Marks.Set (K => (File => Source_File, Index => Index), E => True);\n+      end Mark;\n+\n+      -------------\n+      -- Extract --\n+      -------------\n+\n+      procedure Extract\n+        (Found  : out Boolean;\n+         Source : out Source_Info)\n+      is\n+      begin\n+         Found := False;\n+\n+         if Q_First <= Q.Last then\n+            Source := Q.Table (Q_First).Info;\n+            Q.Table (Q_First).Processed := True;\n+            Q_First := Q_First + 1;\n+            Found := True;\n+         end if;\n+\n+         if Found then\n+            Q_Processed := Q_Processed + 1;\n+         end if;\n+\n+         if Found and then Debug.Debug_Flag_Q then\n+            Write_Str (\"   Q := Q - [ \");\n+            Debug_Display (Source);\n+            Write_Str (\" ]\");\n+            Write_Eol;\n+\n+            Write_Str (\"   Q_First =\");\n+            Write_Int (Int (Q_First));\n+            Write_Eol;\n+\n+            Write_Str (\"   Q.Last =\");\n+            Write_Int (Int (Q.Last));\n+            Write_Eol;\n+         end if;\n+      end Extract;\n+\n+      ---------------\n+      -- Processed --\n+      ---------------\n+\n+      function Processed return Natural is\n+      begin\n+         return Q_Processed;\n+      end Processed;\n+\n+      ----------------\n+      -- Initialize --\n+      ----------------\n+\n+      procedure Initialize (Force : Boolean := False) is\n+      begin\n+         if Force or else not Q_Initialized then\n+            Q_Initialized := True;\n+            Q.Init;\n+            Q_Processed := 0;\n+            Q_First     := 1;\n+         end if;\n+      end Initialize;\n+\n+      ------------\n+      -- Insert --\n+      ------------\n+\n+      function Insert (Source  : Source_Info) return Boolean is\n+      begin\n+         --  Only insert in the Q if it is not already done, to avoid\n+         --  simultaneous compilations if -jnnn is used.\n+\n+         if Was_Processed (Source) then\n+            return False;\n+         end if;\n+\n+         Q.Append (New_Val => (Info => Source, Processed => False));\n+\n+         if Debug.Debug_Flag_Q then\n+            Write_Str (\"   Q := Q + [ \");\n+            Debug_Display (Source);\n+            Write_Str (\" ] \");\n+            Write_Eol;\n+\n+            Write_Str (\"   Q_First =\");\n+            Write_Int (Int (Q_First));\n+            Write_Eol;\n+\n+            Write_Str (\"   Q.Last =\");\n+            Write_Int (Int (Q.Last));\n+            Write_Eol;\n+         end if;\n+\n+         return True;\n+      end Insert;\n+\n+      procedure Insert (Source : Source_Info) is\n+         Discard : Boolean;\n+      begin\n+         Discard := Insert (Source);\n+      end Insert;\n+\n+      --------------\n+      -- Is_Empty --\n+      --------------\n+\n+      function Is_Empty return Boolean is\n+      begin\n+         return Q_Processed >= Q.Last;\n+      end Is_Empty;\n+\n+      ----------\n+      -- Size --\n+      ----------\n+\n+      function Size return Natural is\n+      begin\n+         return Q.Last;\n+      end Size;\n+\n+      -------------\n+      -- Element --\n+      -------------\n+\n+      function Element (Rank : Positive) return File_Name_Type is\n+      begin\n+         if Rank <= Q.Last then\n+            return Q.Table (Rank).Info.File;\n+         else\n+            return No_File;\n+         end if;\n+      end Element;\n+\n+      ------------------\n+      -- Remove_Marks --\n+      ------------------\n+\n+      procedure Remove_Marks is\n+      begin\n+         Marks.Reset;\n+      end Remove_Marks;\n+\n+   end Queue;\n+\n+end Make_Util;"}, {"sha": "1aa496690a634a3d4c12ec4d448a4d59bbfd989e", "filename": "gcc/ada/make_util.ads", "status": "added", "additions": 299, "deletions": 0, "changes": 299, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315f0c424be6ad994f0253bd09d30c53cf47af8a/gcc%2Fada%2Fmake_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315f0c424be6ad994f0253bd09d30c53cf47af8a/gcc%2Fada%2Fmake_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake_util.ads?ref=315f0c424be6ad994f0253bd09d30c53cf47af8a", "patch": "@@ -0,0 +1,299 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                            M A K E _ U T I L                             --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2004-2017, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains various subprograms used by the builders, in\n+--  particular those subprograms related to build queue management.\n+\n+with Namet; use Namet;\n+with Opt;\n+with Osint;\n+with Types; use Types;\n+\n+with GNAT.OS_Lib; use GNAT.OS_Lib;\n+\n+package Make_Util is\n+\n+   type Fail_Proc is access procedure (S : String);\n+   --  Pointer to procedure which outputs a failure message\n+\n+   --  Root_Environment : Prj.Tree.Environment;\n+   --  The environment coming from environment variables and command line\n+   --  switches. When we do not have an aggregate project, this is used for\n+   --  parsing the project tree. When we have an aggregate project, this is\n+   --  used to parse the aggregate project; the latter then generates another\n+   --  environment (with additional external values and project path) to parse\n+   --  the aggregated projects.\n+\n+   --  Default_Config_Name : constant String := \"default.cgpr\";\n+   --  Name of the configuration file used by gprbuild and generated by\n+   --  gprconfig by default.\n+\n+   On_Windows : constant Boolean := Directory_Separator = '\\';\n+   --  True when on Windows\n+\n+   Source_Info_Option : constant String := \"--source-info=\";\n+   --  Switch to indicate the source info file\n+\n+   Subdirs_Option : constant String := \"--subdirs=\";\n+   --  Switch used to indicate that the real directories (object, exec,\n+   --  library, ...) are subdirectories of those in the project file.\n+\n+   Relocate_Build_Tree_Option : constant String := \"--relocate-build-tree\";\n+   --  Switch to build out-of-tree. In this context the object, exec and\n+   --  library directories are relocated to the current working directory\n+   --  or the directory specified as parameter to this option.\n+\n+   Unchecked_Shared_Lib_Imports : constant String :=\n+                                    \"--unchecked-shared-lib-imports\";\n+   --  Command line switch to allow shared library projects to import projects\n+   --  that are not shared library projects.\n+\n+   Single_Compile_Per_Obj_Dir_Switch : constant String :=\n+                                         \"--single-compile-per-obj-dir\";\n+   --  Switch to forbid simultaneous compilations for the same object directory\n+   --  when project files are used.\n+\n+   Create_Map_File_Switch : constant String := \"--create-map-file\";\n+   --  Switch to create a map file when an executable is linked\n+\n+   No_Exit_Message_Option : constant String := \"--no-exit-message\";\n+   --  Switch to suppress exit error message when there are compilation\n+   --  failures. This is useful when a tool, such as gnatprove, silently calls\n+   --  the builder and does not want to pollute its output with error messages\n+   --  coming from the builder. This is an internal switch.\n+\n+   Keep_Temp_Files_Option : constant String := \"--keep-temp-files\";\n+   --  Switch to suppress deletion of temp files created by the builder.\n+   --  Note that debug switch -gnatdn also has this effect.\n+\n+   procedure Add\n+     (Option : String_Access;\n+      To     : in out String_List_Access;\n+      Last   : in out Natural);\n+   procedure Add\n+     (Option : String;\n+      To     : in out String_List_Access;\n+      Last   : in out Natural);\n+   --  Add a string to a list of strings\n+\n+   function Create_Name (Name : String) return File_Name_Type;\n+   function Create_Name (Name : String) return Name_Id;\n+   function Create_Name (Name : String) return Path_Name_Type;\n+   --  Get an id for a name\n+\n+   function Base_Name_Index_For\n+     (Main            : String;\n+      Main_Index      : Int;\n+      Index_Separator : Character) return File_Name_Type;\n+   --  Returns the base name of Main, without the extension, followed by the\n+   --  Index_Separator followed by the Main_Index if it is non-zero.\n+\n+   function Executable_Prefix_Path return String;\n+   --  Return the absolute path parent directory of the directory where the\n+   --  current executable resides, if its directory is named \"bin\", otherwise\n+   --  return an empty string. When a directory is returned, it is guaranteed\n+   --  to end with a directory separator.\n+\n+   procedure Inform (N : Name_Id := No_Name; Msg : String);\n+   procedure Inform (N : File_Name_Type; Msg : String);\n+   --  Prints out the program name followed by a colon, N and S\n+\n+   procedure Ensure_Absolute_Path\n+     (Switch               : in out String_Access;\n+      Parent               : String;\n+      Do_Fail              : Fail_Proc;\n+      For_Gnatbind         : Boolean := False;\n+      Including_Non_Switch : Boolean := True;\n+      Including_RTS        : Boolean := False);\n+   --  Do nothing if Switch is an absolute path switch. If relative, fail if\n+   --  Parent is the empty string, otherwise prepend the path with Parent. This\n+   --  subprogram is only used when using project files. If For_Gnatbind is\n+   --  True, consider gnatbind specific syntax for -L (not a path, left\n+   --  unchanged) and -A (path is optional, preceded with \"=\" if present).\n+   --  If Including_RTS is True, process also switches --RTS=. Do_Fail is\n+   --  called in case of error. Using Osint.Fail might be appropriate.\n+\n+   type Name_Ids is array (Positive range <>) of Name_Id;\n+   No_Names : constant Name_Ids := (1 .. 0 => No_Name);\n+   --  Name_Ids is used for list of language names in procedure Get_Directories\n+   --  below.\n+\n+   function Path_Or_File_Name (Path : Path_Name_Type) return String;\n+   --  Returns a file name if -df is used, otherwise return a path name\n+\n+   function Unit_Index_Of (ALI_File : File_Name_Type) return Int;\n+   --  Find the index of a unit in a source file. Return zero if the file is\n+   --  not a multi-unit source file.\n+\n+   procedure Verbose_Msg\n+     (N1                : Name_Id;\n+      S1                : String;\n+      N2                : Name_Id := No_Name;\n+      S2                : String  := \"\";\n+      Prefix            : String  := \"  -> \";\n+      Minimum_Verbosity : Opt.Verbosity_Level_Type := Opt.Low);\n+   procedure Verbose_Msg\n+     (N1                : File_Name_Type;\n+      S1                : String;\n+      N2                : File_Name_Type := No_File;\n+      S2                : String  := \"\";\n+      Prefix            : String  := \"  -> \";\n+      Minimum_Verbosity : Opt.Verbosity_Level_Type := Opt.Low);\n+   --  If the verbose flag (Verbose_Mode) is set and the verbosity level is at\n+   --  least equal to Minimum_Verbosity, then print Prefix to standard output\n+   --  followed by N1 and S1. If N2 /= No_Name then N2 is printed after S1. S2\n+   --  is printed last. Both N1 and N2 are printed in quotation marks. The two\n+   --  forms differ only in taking Name_Id or File_Name_Type arguments.\n+\n+   Max_Header_Num : constant := 6150;\n+   type Header_Num is range 0 .. Max_Header_Num;\n+   --  Size for hash table below. The upper bound is an arbitrary value, the\n+   --  value here was chosen after testing to determine a good compromise\n+   --  between speed of access and memory usage.\n+\n+   function Hash (Name : Name_Id)        return Header_Num;\n+   function Hash (Name : File_Name_Type) return Header_Num;\n+   function Hash (Name : Path_Name_Type) return Header_Num;\n+\n+   -------------------------\n+   -- Program termination --\n+   -------------------------\n+\n+   procedure Fail_Program\n+     (S              : String;\n+      Flush_Messages : Boolean := True);\n+   --  Terminate program with a message and a fatal status code\n+\n+   procedure Finish_Program\n+     (Exit_Code    : Osint.Exit_Code_Type := Osint.E_Success;\n+      S            : String := \"\");\n+   --  Terminate program, with or without a message, setting the status code\n+   --  according to Fatal. This properly removes all temporary files.\n+\n+   -----------\n+   -- Mains --\n+   -----------\n+\n+   --  Package Mains is used to store the mains specified on the command line\n+   --  and to retrieve them when a project file is used, to verify that the\n+   --  files exist and that they belong to a project file.\n+\n+   --  Mains are stored in a table. An index is used to retrieve the mains\n+   --  from the table.\n+\n+   type Main_Info is record\n+      File      : File_Name_Type;  --  Always canonical casing\n+      Index     : Int := 0;\n+   end record;\n+\n+   No_Main_Info : constant Main_Info := (No_File, 0);\n+\n+   package Mains is\n+      procedure Add_Main (Name : String; Index : Int := 0);\n+      --  Add one main to the table. This is in general used to add the main\n+      --  files specified on the command line. Index is used for multi-unit\n+      --  source files, and indicates which unit in the source is concerned.\n+\n+      procedure Delete;\n+      --  Empty the table\n+\n+      procedure Reset;\n+      --  Reset the cursor to the beginning of the table\n+\n+      procedure Set_Multi_Unit_Index\n+        (Index        : Int := 0);\n+      --  If a single main file was defined, this subprogram indicates which\n+      --  unit inside it is the main (case of a multi-unit source files).\n+      --  Errors are raised if zero or more than one main file was defined,\n+      --  and Index is non-zaero. This subprogram is used for the handling\n+      --  of the command line switch.\n+\n+      function Next_Main return String;\n+      function Next_Main return Main_Info;\n+      --  Moves the cursor forward and returns the new current entry. Returns\n+      --  No_Main_Info there are no more mains in the table.\n+\n+      function Number_Of_Mains return Natural;\n+      --  Returns the number of main.\n+\n+   end Mains;\n+\n+   -----------\n+   -- Queue --\n+   -----------\n+\n+   package Queue is\n+\n+      --  The queue of sources to be checked for compilation. There can be a\n+      --  single such queue per application.\n+\n+      type Source_Info is\n+         record\n+            File    : File_Name_Type := No_File;\n+            Unit    : Unit_Name_Type := No_Unit_Name;\n+            Index   : Int            := 0;\n+         end record;\n+      --  Information about files stored in the queue.\n+\n+      No_Source_Info : constant Source_Info := (No_File, No_Unit_Name, 0);\n+\n+      procedure Initialize (Force : Boolean := False);\n+      --  Initialize the queue\n+\n+      procedure Remove_Marks;\n+      --  Remove all marks set for the files. This means that the files will be\n+      --  handed to the compiler if they are added to the queue, and is mostly\n+      --  useful when recompiling several executables as the switches may be\n+      --  different and -s may be in use.\n+\n+      function Is_Empty return Boolean;\n+      --  Returns True if the queue is empty\n+\n+      procedure Insert (Source : Source_Info);\n+      function Insert (Source  : Source_Info) return Boolean;\n+      --  Insert source in the queue. The second version returns False if the\n+      --  Source was already marked in the queue.\n+\n+      procedure Extract\n+        (Found  : out Boolean;\n+         Source : out Source_Info);\n+      --  Get the first source that can be compiled from the queue. If no\n+      --  source may be compiled, sets Found to False. In this case, the value\n+      --  for Source is undefined.\n+\n+      function Size return Natural;\n+      --  Return the total size of the queue, including the sources already\n+      --  extracted.\n+\n+      function Processed return Natural;\n+      --  Return the number of source in the queue that have aready been\n+      --  processed.\n+\n+      function Element (Rank : Positive) return File_Name_Type;\n+      --  Get the file name for element of index Rank in the queue\n+\n+   end Queue;\n+\n+end Make_Util;"}, {"sha": "73361de9658597d92a54d446146b85b716e2556b", "filename": "gcc/ada/makeusg.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315f0c424be6ad994f0253bd09d30c53cf47af8a/gcc%2Fada%2Fmakeusg.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315f0c424be6ad994f0253bd09d30c53cf47af8a/gcc%2Fada%2Fmakeusg.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeusg.adb?ref=315f0c424be6ad994f0253bd09d30c53cf47af8a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -23,7 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Makeutl;\n+with Make_Util;\n with Osint;   use Osint;\n with Output;  use Output;\n with Switch;  use Switch;\n@@ -350,14 +350,14 @@ begin\n    --  Line for --source-info=\n \n    Write_Str (\"  \");\n-   Write_Str (Makeutl.Source_Info_Option);\n+   Write_Str (Make_Util.Source_Info_Option);\n    Write_Str (\"file specify a source info file\");\n    Write_Eol;\n \n    --  Line for --unchecked-shared-lib-imports\n \n    Write_Str (\"  \");\n-   Write_Str (Makeutl.Unchecked_Shared_Lib_Imports);\n+   Write_Str (Make_Util.Unchecked_Shared_Lib_Imports);\n    Write_Eol;\n    Write_Str (\"            Allow shared libraries to import static libraries\");\n    Write_Eol;"}, {"sha": "f0f102e419be8c232ad77d40e00871d3a1a53215", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315f0c424be6ad994f0253bd09d30c53cf47af8a/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315f0c424be6ad994f0253bd09d30c53cf47af8a/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=315f0c424be6ad994f0253bd09d30c53cf47af8a", "patch": "@@ -1894,6 +1894,53 @@ package body Sem_Ch12 is\n                        (Instantiate_Formal_Package\n                          (Formal, Match, Analyzed_Formal),\n                         Assoc_List);\n+\n+                     --  Determine whether the actual package needs an\n+                     --  explicit freeze node. This is only the case if\n+                     --  the actual is declared in the same unit and has\n+                     --  a body. Normally packages do not have explicit\n+                     --  freeze nodes, and gigi only uses them to elaborate\n+                     --  entities in a package body.\n+\n+                     declare\n+                        Actual : constant Entity_Id := Entity (Match);\n+                        Needs_Freezing : Boolean;\n+                        S : Entity_Id;\n+\n+                     begin\n+                        if not Expander_Active\n+                          or else not Has_Completion (Actual)\n+                          or else not In_Same_Source_Unit (I_Node, Actual)\n+                          or else (Present (Renamed_Entity (Actual))\n+                           and then not In_Same_Source_Unit (I_Node,\n+                             (Renamed_Entity (Actual))))\n+                        then\n+                           null;\n+\n+                        else\n+                           --  Finally we want to exclude such freeze nodes\n+                           --  from statement sequences, which freeze\n+                           --  everything before them.\n+                           --  Is this strictly necesssary ???\n+\n+                           Needs_Freezing := True;\n+                           S := Current_Scope;\n+                           while Present (S) loop\n+                              if Ekind_In\n+                                (S, E_Loop, E_Block, E_Procedure, E_Function)\n+                              then\n+                                 Needs_Freezing := False;\n+                                 exit;\n+                              end if;\n+                              S := Scope (S);\n+                           end loop;\n+\n+                           if Needs_Freezing then\n+                              Set_Has_Delayed_Freeze (Actual);\n+                              Append_Elmt (Actual, Actuals_To_Freeze);\n+                           end if;\n+                        end if;\n+                     end;\n                   end if;\n \n                --  For use type and use package appearing in the generic part,"}, {"sha": "7ef2834be2c44c913ac98a5cc4cfaceb21c7de1e", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 22, "deletions": 25, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315f0c424be6ad994f0253bd09d30c53cf47af8a/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315f0c424be6ad994f0253bd09d30c53cf47af8a/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=315f0c424be6ad994f0253bd09d30c53cf47af8a", "patch": "@@ -9806,12 +9806,12 @@ package body Sem_Ch13 is\n       --  checking for overlap, since no overlap is possible.\n \n       Tagged_Parent : Entity_Id := Empty;\n-      --  This is set in the case of a derived tagged type for which we have\n-      --  Is_Fully_Repped_Tagged_Type True (indicating that all components are\n-      --  positioned by record representation clauses). In this case we must\n-      --  check for overlap between components of this tagged type, and the\n-      --  components of its parent. Tagged_Parent will point to this parent\n-      --  type. For all other cases Tagged_Parent is left set to Empty.\n+      --  This is set in the case of an extension for which we have either a\n+      --  size clause or Is_Fully_Repped_Tagged_Type True (indicating that all\n+      --  components are positioned by record representation clauses) on the\n+      --  parent type. In this case we check for overlap between components of\n+      --  this tagged type and the parent component. Tagged_Parent will point\n+      --  to this parent type. For all other cases, Tagged_Parent is Empty.\n \n       Parent_Last_Bit : Uint;\n       --  Relevant only if Tagged_Parent is set, Parent_Last_Bit indicates the\n@@ -9959,17 +9959,21 @@ package body Sem_Ch13 is\n \n       if Rectype = Any_Type then\n          return;\n-      else\n-         Rectype := Underlying_Type (Rectype);\n       end if;\n \n+      Rectype := Underlying_Type (Rectype);\n+\n       --  See if we have a fully repped derived tagged type\n \n       declare\n          PS : constant Entity_Id := Parent_Subtype (Rectype);\n \n       begin\n-         if Present (PS) and then Is_Fully_Repped_Tagged_Type (PS) then\n+         if Present (PS) and then Known_Static_RM_Size (PS) then\n+            Tagged_Parent := PS;\n+            Parent_Last_Bit := RM_Size (PS) - 1;\n+\n+         elsif Present (PS) and then Is_Fully_Repped_Tagged_Type (PS) then\n             Tagged_Parent := PS;\n \n             --  Find maximum bit of any component of the parent type\n@@ -10063,7 +10067,7 @@ package body Sem_Ch13 is\n                  (\"bit number out of range of specified size\",\n                   Last_Bit (CC));\n \n-               --  Check for overlap with tag component\n+               --  Check for overlap with tag or parent component\n \n             else\n                if Is_Tagged_Type (Rectype)\n@@ -10073,27 +10077,20 @@ package body Sem_Ch13 is\n                     (\"component overlaps tag field of&\",\n                      Component_Name (CC), Rectype);\n                   Overlap_Detected := True;\n+\n+               elsif Present (Tagged_Parent)\n+                 and then Fbit <= Parent_Last_Bit\n+               then\n+                  Error_Msg_NE\n+                    (\"component overlaps parent field of&\",\n+                     Component_Name (CC), Rectype);\n+                  Overlap_Detected := True;\n                end if;\n \n                if Hbit < Lbit then\n                   Hbit := Lbit;\n                end if;\n             end if;\n-\n-            --  Check parent overlap if component might overlap parent field\n-\n-            if Present (Tagged_Parent) and then Fbit <= Parent_Last_Bit then\n-               Pcomp := First_Component_Or_Discriminant (Tagged_Parent);\n-               while Present (Pcomp) loop\n-                  if not Is_Tag (Pcomp)\n-                    and then Chars (Pcomp) /= Name_uParent\n-                  then\n-                     Check_Component_Overlap (Comp, Pcomp);\n-                  end if;\n-\n-                  Next_Component_Or_Discriminant (Pcomp);\n-               end loop;\n-            end if;\n          end if;\n \n          Next (CC);"}, {"sha": "35f5e7c9fe0a0dc649832cee3aa31715b6caae7e", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315f0c424be6ad994f0253bd09d30c53cf47af8a/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315f0c424be6ad994f0253bd09d30c53cf47af8a/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=315f0c424be6ad994f0253bd09d30c53cf47af8a", "patch": "@@ -1111,7 +1111,10 @@ package body Sem_Ch5 is\n             end loop;\n          end if;\n \n-         Check_References (Ent);\n+         if Comes_From_Source (Ent) then\n+            Check_References (Ent);\n+         end if;\n+\n          End_Scope;\n \n          if Unblocked_Exit_Count = 0 then"}, {"sha": "f696655d65167aba54311ae77d7aed168f0f9026", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315f0c424be6ad994f0253bd09d30c53cf47af8a/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315f0c424be6ad994f0253bd09d30c53cf47af8a/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=315f0c424be6ad994f0253bd09d30c53cf47af8a", "patch": "@@ -4080,7 +4080,10 @@ package body Sem_Prag is\n \n          --  Object declaration of a single concurrent type\n \n-         elsif Nkind (Subp_Decl) = N_Object_Declaration then\n+         elsif Nkind (Subp_Decl) = N_Object_Declaration\n+           and then Is_Single_Concurrent_Object\n+                      (Unique_Defining_Entity (Subp_Decl))\n+         then\n             null;\n \n          --  Single task type"}, {"sha": "4c387121aebc8b1593ec10382ed72b0f7fde2f56", "filename": "gcc/ada/sem_prag.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315f0c424be6ad994f0253bd09d30c53cf47af8a/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315f0c424be6ad994f0253bd09d30c53cf47af8a/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=315f0c424be6ad994f0253bd09d30c53cf47af8a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -202,7 +202,7 @@ package Sem_Prag is\n \n    procedure Analyze_Global_In_Decl_Part (N : Node_Id);\n    --  Perform full analysis of delayed pragma Global. This routine is also\n-   --  capable of performing basic analysis of pragma Refind_Global.\n+   --  capable of performing basic analysis of pragma Refined_Global.\n \n    procedure Analyze_Initial_Condition_In_Decl_Part (N : Node_Id);\n    --  Perform full analysis of delayed pragma Initial_Condition"}, {"sha": "2c29dde18b04494290626c111be005d324075346", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315f0c424be6ad994f0253bd09d30c53cf47af8a/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315f0c424be6ad994f0253bd09d30c53cf47af8a/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=315f0c424be6ad994f0253bd09d30c53cf47af8a", "patch": "@@ -465,8 +465,9 @@ package Sem_Util is\n    --  we are operating in Ada 83 mode, or the Warn parameter is set to True.\n \n    procedure Conditional_Delay (New_Ent, Old_Ent : Entity_Id);\n-   --  Sets the Has_Delayed_Freeze flag of New if the Delayed_Freeze flag of\n-   --  Old is set and Old has no yet been Frozen (i.e. Is_Frozen is false).\n+   --  Sets the Has_Delayed_Freeze flag of New_Ent if the Delayed_Freeze flag\n+   --  of Old_Ent is set and Old_Ent has not yet been Frozen (i.e. Is_Frozen is\n+   --  False).\n \n    function Contains_Refined_State (Prag : Node_Id) return Boolean;\n    --  Determine whether pragma Prag contains a reference to the entity of an"}, {"sha": "cfc3f1312c94a179867602e4b65f2cb43242f410", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315f0c424be6ad994f0253bd09d30c53cf47af8a/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315f0c424be6ad994f0253bd09d30c53cf47af8a/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=315f0c424be6ad994f0253bd09d30c53cf47af8a", "patch": "@@ -1670,17 +1670,17 @@ package body Sem_Warn is\n             end if;\n          end if;\n \n-         --  Recurse into nested package or block. Do not recurse into a formal\n-         --  package, because the corresponding body is not analyzed.\n+         --  Recurse into a nested package or non-internal block, but do not\n+         --  recurse into a formal package because the corresponding body is\n+         --  not analyzed.\n \n          <<Continue>>\n             if (Is_Package_Or_Generic_Package (E1)\n                  and then Nkind (Parent (E1)) = N_Package_Specification\n                  and then\n                    Nkind (Original_Node (Unit_Declaration_Node (E1))) /=\n-                                                N_Formal_Package_Declaration)\n-\n-              or else Ekind (E1) = E_Block\n+                                          N_Formal_Package_Declaration)\n+              or else (Ekind (E1) = E_Block and then not Is_Internal (E1))\n             then\n                Check_References (E1);\n             end if;"}, {"sha": "b13da9dc0006f1d9e68a694ff0ff48cf0074e3e2", "filename": "gcc/ada/sinput.adb", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315f0c424be6ad994f0253bd09d30c53cf47af8a/gcc%2Fada%2Fsinput.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315f0c424be6ad994f0253bd09d30c53cf47af8a/gcc%2Fada%2Fsinput.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput.adb?ref=315f0c424be6ad994f0253bd09d30c53cf47af8a", "patch": "@@ -320,6 +320,38 @@ package body Sinput is\n       end case;\n    end Check_For_BOM;\n \n+   -----------------------------\n+   -- Clear_Source_File_Table --\n+   -----------------------------\n+\n+   procedure Free is new Unchecked_Deallocation\n+     (Lines_Table_Type, Lines_Table_Ptr);\n+\n+   procedure Free is new Unchecked_Deallocation\n+     (Logical_Lines_Table_Type, Logical_Lines_Table_Ptr);\n+\n+   procedure Clear_Source_File_Table is\n+   begin\n+      for X in 1 .. Source_File.Last loop\n+         declare\n+            S  : Source_File_Record renames Source_File.Table (X);\n+         begin\n+            if S.Instance = No_Instance_Id then\n+               Free_Source_Buffer (S.Source_Text);\n+            else\n+               Free_Dope (S.Source_Text'Address);\n+               S.Source_Text := null;\n+            end if;\n+\n+            Free (S.Lines_Table);\n+            Free (S.Logical_Lines_Table);\n+         end;\n+      end loop;\n+\n+      Source_File.Free;\n+      Sinput.Initialize;\n+   end Clear_Source_File_Table;\n+\n    ---------------------------------\n    -- Comes_From_Inherited_Pragma --\n    ---------------------------------"}, {"sha": "bde59b131ddd1e9e183fafe5c8ce8b072fd67fcd", "filename": "gcc/ada/sinput.ads", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315f0c424be6ad994f0253bd09d30c53cf47af8a/gcc%2Fada%2Fsinput.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315f0c424be6ad994f0253bd09d30c53cf47af8a/gcc%2Fada%2Fsinput.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput.ads?ref=315f0c424be6ad994f0253bd09d30c53cf47af8a", "patch": "@@ -715,6 +715,13 @@ package Sinput is\n    --  Writes out internal tables to current tree file using the relevant\n    --  Table.Tree_Write routines.\n \n+   procedure Clear_Source_File_Table;\n+   --  This procedure frees memory allocated in the Source_File table (in the\n+   --  private). It should only be used when it is guaranteed that all source\n+   --  files that have been loaded so far will not be accessed before being\n+   --  reloaded. It is intended for tools that parse several times sources,\n+   --  to avoid memory leaks.\n+\n private\n    pragma Inline (File_Name);\n    pragma Inline (Full_File_Name);"}, {"sha": "d6845a85af7d9af4f27f0af326ce4ada6ead366c", "filename": "gcc/ada/switch-m.adb", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315f0c424be6ad994f0253bd09d30c53cf47af8a/gcc%2Fada%2Fswitch-m.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315f0c424be6ad994f0253bd09d30c53cf47af8a/gcc%2Fada%2Fswitch-m.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-m.adb?ref=315f0c424be6ad994f0253bd09d30c53cf47af8a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -24,11 +24,8 @@\n ------------------------------------------------------------------------------\n \n with Debug;    use Debug;\n-with Makeutl;  use Makeutl;\n with Osint;    use Osint;\n with Opt;      use Opt;\n-with Prj;      use Prj;\n-with Prj.Env;  use Prj.Env;\n with Table;\n \n with System.Multiprocessors; use System.Multiprocessors;\n@@ -51,6 +48,8 @@ package body Switch.M is\n    Global_Switches : Argument_List_Access := null;\n    --  Used by function Normalize_Compiler_Switches\n \n+   Subdirs_Option : constant String := \"--subdirs=\";\n+\n    ---------------------------------\n    -- Normalize_Compiler_Switches --\n    ---------------------------------\n@@ -710,8 +709,7 @@ package body Switch.M is\n    ------------------------\n \n    procedure Scan_Make_Switches\n-     (Env               : in out Prj.Tree.Environment;\n-      Switch_Chars      : String;\n+     (Switch_Chars      : String;\n       Success           : out Boolean)\n    is\n       Ptr : Integer          := Switch_Chars'First;\n@@ -745,6 +743,10 @@ package body Switch.M is\n \n       --  Multiple character switches\n \n+      --  To preserve building gnat_util, it is not possible to use the\n+      --  constant Strings declare in Make_Util, as Make_Util is not in\n+      --  gnat_util.\n+\n       if Switch_Chars'Length > 2 then\n          if Switch_Chars = \"--create-missing-dirs\" then\n             Setup_Projects := True;\n@@ -757,21 +759,20 @@ package body Switch.M is\n                                                             Subdirs_Option\n          then\n             Subdirs :=\n-              new String'\n-                (Switch_Chars\n-                  (Switch_Chars'First + Subdirs_Option'Length ..\n-                   Switch_Chars'Last));\n+              new String'(Switch_Chars\n+                           (Switch_Chars'First + Subdirs_Option'Length ..\n+                            Switch_Chars'Last));\n \n-         elsif Switch_Chars = Makeutl.Unchecked_Shared_Lib_Imports then\n+         elsif Switch_Chars = \"--unchecked-shared-lib-imports\" then\n             Opt.Unchecked_Shared_Lib_Imports := True;\n \n-         elsif Switch_Chars = Makeutl.Single_Compile_Per_Obj_Dir_Switch then\n+         elsif Switch_Chars = \"--single-compile-per-obj-dir\" then\n             Opt.One_Compilation_Per_Obj_Dir := True;\n \n-         elsif Switch_Chars = Makeutl.No_Exit_Message_Option then\n+         elsif Switch_Chars = \"--no-exit-message\" then\n             Opt.No_Exit_Message := True;\n \n-         elsif Switch_Chars = Makeutl.Keep_Temp_Files_Option then\n+         elsif Switch_Chars = \"--keep-temp-files\" then\n             Opt.Keep_Temporary_Files := True;\n \n          elsif Switch_Chars (Ptr) = '-' then\n@@ -780,19 +781,18 @@ package body Switch.M is\n          elsif Switch_Chars'Length > 3\n            and then Switch_Chars (Ptr .. Ptr + 1) = \"aP\"\n          then\n-            Add_Directories\n-              (Env.Project_Path,\n-               Switch_Chars (Ptr + 2 .. Switch_Chars'Last));\n+            null;\n+            --  This is only used by gprbuild\n \n          elsif C = 'v' and then Switch_Chars'Length = 3 then\n             Ptr := Ptr + 1;\n             Verbose_Mode := True;\n \n             case Switch_Chars (Ptr) is\n-               when 'l'    => Verbosity_Level := Opt.Low;\n-               when 'm'    => Verbosity_Level := Opt.Medium;\n-               when 'h'    => Verbosity_Level := Opt.High;\n-               when others => Success := False;\n+            when 'l'    => Verbosity_Level := Opt.Low;\n+            when 'm'    => Verbosity_Level := Opt.Medium;\n+            when 'h'    => Verbosity_Level := Opt.High;\n+            when others => Success := False;\n             end case;\n \n          elsif C = 'd' then\n@@ -823,37 +823,37 @@ package body Switch.M is\n \n                --  Processing for eI switch\n \n-               when 'I' =>\n-                  Ptr := Ptr + 1;\n-                  Scan_Pos (Switch_Chars, Max, Ptr, Main_Index, C);\n+            when 'I' =>\n+               Ptr := Ptr + 1;\n+               Scan_Pos (Switch_Chars, Max, Ptr, Main_Index, C);\n \n-                  if Ptr <= Max then\n-                     Bad_Switch (Switch_Chars);\n-                  end if;\n+               if Ptr <= Max then\n+                  Bad_Switch (Switch_Chars);\n+               end if;\n \n                --  Processing for eL switch\n \n-               when 'L' =>\n-                  if Ptr /= Max then\n-                     Bad_Switch (Switch_Chars);\n+            when 'L' =>\n+               if Ptr /= Max then\n+                  Bad_Switch (Switch_Chars);\n \n-                  else\n-                     Follow_Links_For_Files := True;\n-                     Follow_Links_For_Dirs  := True;\n-                  end if;\n+               else\n+                  Follow_Links_For_Files := True;\n+                  Follow_Links_For_Dirs  := True;\n+               end if;\n \n                --  Processing for eS switch\n \n-               when 'S' =>\n-                  if Ptr /= Max then\n-                     Bad_Switch (Switch_Chars);\n+            when 'S' =>\n+               if Ptr /= Max then\n+                  Bad_Switch (Switch_Chars);\n \n-                  else\n-                     Commands_To_Stdout := True;\n-                  end if;\n+               else\n+                  Commands_To_Stdout := True;\n+               end if;\n \n-               when others =>\n-                  Bad_Switch (Switch_Chars);\n+            when others =>\n+               Bad_Switch (Switch_Chars);\n             end case;\n \n          elsif C = 'j' then"}, {"sha": "d7e35ce363078244b736887e942c7b01149e0d9c", "filename": "gcc/ada/switch-m.ads", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315f0c424be6ad994f0253bd09d30c53cf47af8a/gcc%2Fada%2Fswitch-m.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315f0c424be6ad994f0253bd09d30c53cf47af8a/gcc%2Fada%2Fswitch-m.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-m.ads?ref=315f0c424be6ad994f0253bd09d30c53cf47af8a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2001-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -34,13 +34,14 @@ pragma Warnings (Off);\n with System.OS_Lib; use System.OS_Lib;\n pragma Warnings (On);\n \n-with Prj.Tree;\n-\n package Switch.M is\n \n+   Subdirs : String_Ptr := null;\n+   --  The value after the equal sign in switch --subdirs=...\n+   --  Contains the relative subdirectory.\n+\n    procedure Scan_Make_Switches\n-     (Env               : in out Prj.Tree.Environment;\n-      Switch_Chars      : String;\n+     (Switch_Chars      : String;\n       Success           : out Boolean);\n    --  Scan a gnatmake switch and act accordingly. For switches that are\n    --  recognized, Success is set to True. A switch that is not recognized and"}]}