{"sha": "ccef9ef51073dac630247180cba0591af5382d6b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2NlZjllZjUxMDczZGFjNjMwMjQ3MTgwY2JhMDU5MWFmNTM4MmQ2Yg==", "commit": {"author": {"name": "Daniel Berlin", "email": "dan@cgsoftware.com", "date": "2001-07-16T20:02:08Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2001-07-16T20:02:08Z"}, "message": "gcse.c: Update comment at top.\n\n        * gcse.c: Update comment at top.\n        Update comment on mem handling.\n        mem_last_set, mem_first_set, mem_set_in_block: gone.\n        Declaration of reg_set_info: gone.\n        (oprs_unchanged_p): Don't use mem_*set_* anymore. They are\n        pointless with load_killed_in_block_p (they are *more*\n        conservative then it, not less, and less accurate).\n        (oprs_not_set_p): Ditto.\n        (alloc_gcse_mem): Don't allocate mem_set_in_block\n        (free_gcse_mem): Don't free it, either.\n        (record_last_mem_set_info): Update comment in front, remove\n        mem_*set_* stuff. Note the reason we don't handle stores directly\n        here.\n        (compute_hash_table): Update comments to reflect reality. Remove\n        mem_*set_* references.\n        (reset_opr_set_tables): Remove mem_*set_* references.\n        (mark_call): Ditto.\n        (mark_set): Ditto.  Also remove double sets of bitmaps for REG's.\n        (mark_clobber): Ditto (on both parts, we double set here too).\n        (expr_killed_p): Remove mem_set_in_block test.\n        (compute_transp): Remove mem_set_in_block test.\n\nFrom-SVN: r44055", "tree": {"sha": "ec47b72fbc272a73ba11bf503beb1a7a566ee61d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec47b72fbc272a73ba11bf503beb1a7a566ee61d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ccef9ef51073dac630247180cba0591af5382d6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccef9ef51073dac630247180cba0591af5382d6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ccef9ef51073dac630247180cba0591af5382d6b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccef9ef51073dac630247180cba0591af5382d6b/comments", "author": null, "committer": null, "parents": [{"sha": "b85946fc65582c45de99552679502bc289e7393f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b85946fc65582c45de99552679502bc289e7393f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b85946fc65582c45de99552679502bc289e7393f"}], "stats": {"total": 92, "additions": 25, "deletions": 67}, "files": [{"sha": "ef999bf7f7d35fee07339ba6562c72ecc9b7b435", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccef9ef51073dac630247180cba0591af5382d6b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccef9ef51073dac630247180cba0591af5382d6b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ccef9ef51073dac630247180cba0591af5382d6b", "patch": "@@ -28,6 +28,28 @@ Mon Jul 16 18:07:07 2001  J\"orn Rennecke <amylaar@redhat.com>\n \n 2001-07-16  Daniel Berlin  <dan@cgsoftware.com>\n \n+\t* gcse.c: Update comment at top. \n+\tUpdate comment on mem handling.\n+\tmem_last_set, mem_first_set, mem_set_in_block: gone.\n+\tDeclaration of reg_set_info: gone.\n+\t(oprs_unchanged_p): Don't use mem_*set_* anymore. They are\n+\tpointless with load_killed_in_block_p (they are *more*\n+\tconservative then it, not less, and less accurate).\n+\t(oprs_not_set_p): Ditto.\t\n+\t(alloc_gcse_mem): Don't allocate mem_set_in_block\n+\t(free_gcse_mem): Don't free it, either.\n+\t(record_last_mem_set_info): Update comment in front, remove\n+\tmem_*set_* stuff. Note the reason we don't handle stores directly\n+\there.\n+\t(compute_hash_table): Update comments to reflect reality. Remove\n+\tmem_*set_* references.\n+\t(reset_opr_set_tables): Remove mem_*set_* references.\n+\t(mark_call): Ditto.\n+\t(mark_set): Ditto.  Also remove double sets of bitmaps for REG's.\t\n+\t(mark_clobber): Ditto (on both parts, we double set here too).\n+\t(expr_killed_p): Remove mem_set_in_block test.\n+\t(compute_transp): Remove mem_set_in_block test.\n+\n \t* ssa-ccp.c: (optimize_unexecutable_edges): Add note about removal\n \tof edge, and removal of phi alternative to dump file. \n \t(ssa_ccp_substitute_constants): Add note about register now being"}, {"sha": "c4fe5bb97dc793eafee9fe4d6670cbd2b4d33fd1", "filename": "gcc/gcse.c", "status": "modified", "additions": 3, "deletions": 67, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccef9ef51073dac630247180cba0591af5382d6b/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccef9ef51073dac630247180cba0591af5382d6b/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=ccef9ef51073dac630247180cba0591af5382d6b", "patch": "@@ -24,7 +24,6 @@ Boston, MA 02111-1307, USA.  */\n    - do rough calc of how many regs are needed in each block, and a rough\n      calc of how many regs are available in each class and use that to\n      throttle back the code in cases where RTX_COST is minimal.\n-   - dead store elimination\n    - a store to the same address as a load does not kill the load if the\n      source of the store is also the destination of the load.  Handling this\n      allows more load motion, particularly out of loops.\n@@ -497,16 +496,6 @@ static rtx * modify_mem_list;\n \n /* This array parallels modify_mem_list, but is kept canonicalized.  */\n static rtx * canon_modify_mem_list;\n-\n-/* For each block, non-zero if memory is set in that block.\n-   This is computed during hash table computation and is used by\n-   expr_killed_p and compute_transp.\n-   ??? Handling of memory is very simple, we don't make any attempt\n-   to optimize things (later).\n-   ??? This can be computed by compute_sets since the information\n-   doesn't change.  */\n-static char *mem_set_in_block;\n-\n /* Various variables for statistics gathering.  */\n \n /* Memory used in a pass.\n@@ -1032,7 +1021,6 @@ alloc_gcse_mem (f)\n   /* Allocate vars to track sets of regs, memory per block.  */\n   reg_set_in_block = (sbitmap *) sbitmap_vector_alloc (n_basic_blocks,\n \t\t\t\t\t\t       max_gcse_regno);\n-  mem_set_in_block = (char *) gmalloc (n_basic_blocks);\n   /* Allocate array to keep a list of insns which modify memory in each\n      basic block.  */\n   modify_mem_list = (rtx *) gmalloc (n_basic_blocks * sizeof (rtx *));\n@@ -1052,7 +1040,6 @@ free_gcse_mem ()\n   free (reg_set_bitmap);\n \n   sbitmap_vector_free (reg_set_in_block);\n-  free (mem_set_in_block);\n   /* re-Cache any INSN_LIST nodes we have allocated.  */\n   {\n     int i;\n@@ -1317,15 +1304,6 @@ compute_sets (f)\n static int *reg_first_set;\n static int *reg_last_set;\n \n-/* While computing \"first/last set\" info, this is the CUID of first/last insn\n-   to set memory or -1 if not set.  `mem_last_set' is also used when\n-   performing GCSE to record whether memory has been set since the beginning\n-   of the block.\n-\n-   Note that handling of memory is very simple, we don't make any attempt\n-   to optimize things (later).  */\n-static int mem_first_set;\n-static int mem_last_set;\n \n /* See whether X, the source of a set, is something we want to consider for\n    GCSE.  */\n@@ -1409,12 +1387,6 @@ oprs_unchanged_p (x, insn, avail_p)\n       if (load_killed_in_block_p (BLOCK_FOR_INSN (insn), INSN_CUID (insn),\n \t\t\t\t  x, avail_p))\n \treturn 0;\n-      if (avail_p && mem_last_set != NEVER_SET\n-\t  && mem_last_set >= INSN_CUID (insn))\n-\treturn 0;\n-      else if (! avail_p && mem_first_set != NEVER_SET\n-\t       && mem_first_set < INSN_CUID (insn))\n-\treturn 0;\n       else\n \treturn oprs_unchanged_p (XEXP (x, 0), insn, avail_p);\n \n@@ -2410,7 +2382,6 @@ canon_list_insert (dest, unused1, v_insn)\n     alloc_INSN_LIST (dest, canon_modify_mem_list[BLOCK_NUM (insn)]);\n }\n \n-/* Record memory first/last/block set information for INSN.  */\n /* Record memory modification information for INSN.  We do not actually care\n    about the memory location(s) that are set, or even how they are set (consider\n    a CALL_INSN).  We merely need to record which insns modify memory.  */\n@@ -2419,11 +2390,8 @@ static void\n record_last_mem_set_info (insn)\n      rtx insn;\n {\n-  if (mem_first_set == NEVER_SET)\n-    mem_first_set = INSN_CUID (insn);\n-\n-  mem_last_set = INSN_CUID (insn);\n-  mem_set_in_block[BLOCK_NUM (insn)] = 1;\n+  /* load_killed_in_block_p will handle the case of calls clobbering\n+     everything. */\n   modify_mem_list[BLOCK_NUM (insn)] = \n     alloc_INSN_LIST (insn, modify_mem_list[BLOCK_NUM (insn)]);\n \n@@ -2486,12 +2454,9 @@ compute_hash_table (set_p)\n \n   /* While we compute the hash table we also compute a bit array of which\n      registers are set in which blocks.\n-     We also compute which blocks set memory, in the absence of aliasing\n-     support [which is TODO].\n      ??? This isn't needed during const/copy propagation, but it's cheap to\n      compute.  Later.  */\n   sbitmap_vector_zero (reg_set_in_block, n_basic_blocks);\n-  memset ((char *) mem_set_in_block, 0, n_basic_blocks);\n \n   /* re-Cache any INSN_LIST nodes we have allocated.  */\n   {\n@@ -2519,14 +2484,12 @@ compute_hash_table (set_p)\n \n       /* First pass over the instructions records information used to\n \t determine when registers and memory are first and last set.\n-\t ??? The mem_set_in_block and hard-reg reg_set_in_block computation\n+\t ??? hard-reg reg_set_in_block computation\n \t could be moved to compute_sets since they currently don't change.  */\n \n       for (i = 0; i < max_gcse_regno; i++)\n \treg_first_set[i] = reg_last_set[i] = NEVER_SET;\n \n-      mem_first_set = NEVER_SET;\n-      mem_last_set = NEVER_SET;\n \n       for (insn = BLOCK_HEAD (bb);\n \t   insn && insn != NEXT_INSN (BLOCK_END (bb));\n@@ -2747,7 +2710,6 @@ reset_opr_set_tables ()\n   /* Also keep a record of the last instruction to modify memory.\n      For now this is very trivial, we only record whether any memory\n      location has been modified.  */\n-  mem_last_set = 0;\n   {\n     int i;\n \n@@ -2794,8 +2756,6 @@ oprs_not_set_p (x, insn)\n       if (load_killed_in_block_p (BLOCK_FOR_INSN (insn), \n \t\t\t\t  INSN_CUID (insn), x, 0))\n \treturn 0;\n-      if (mem_last_set != 0)\n-\treturn 0;\n       else\n \treturn oprs_not_set_p (XEXP (x, 0), insn);\n \n@@ -2834,7 +2794,6 @@ static void\n mark_call (insn)\n      rtx insn;\n {\n-  mem_last_set = INSN_CUID (insn);\n   if (! CONST_CALL_P (insn))\n     record_last_mem_set_info (insn);\n }\n@@ -2858,11 +2817,6 @@ mark_set (pat, insn)\n   else if (GET_CODE (dest) == MEM)\n     record_last_mem_set_info (insn);\n \n-  if (GET_CODE (dest) == REG)\n-    SET_BIT (reg_set_bitmap, REGNO (dest));\n-  else if (GET_CODE (dest) == MEM)\n-    mem_last_set = INSN_CUID (insn);\n-\n   if (GET_CODE (SET_SRC (pat)) == CALL)\n     mark_call (insn);\n }\n@@ -2878,10 +2832,6 @@ mark_clobber (pat, insn)\n   while (GET_CODE (clob) == SUBREG || GET_CODE (clob) == STRICT_LOW_PART)\n     clob = XEXP (clob, 0);\n \n-  if (GET_CODE (clob) == REG)\n-    SET_BIT (reg_set_bitmap, REGNO (clob));\n-  else\n-    mem_last_set = INSN_CUID (insn);\n   if (GET_CODE (clob) == REG)\n     SET_BIT (reg_set_bitmap, REGNO (clob));\n   else\n@@ -3121,8 +3071,6 @@ expr_killed_p (x, bb)\n     case MEM:\n       if (load_killed_in_block_p (bb, get_max_uid () + 1, x, 0))\n \treturn 1;\n-      if (mem_set_in_block[bb->index])\n-\treturn 1;\n       else\n \treturn expr_killed_p (XEXP (x, 0), bb);\n \n@@ -3825,18 +3773,6 @@ compute_transp (x, indx, bmap, set_p)\n \t      list_entry = XEXP (list_entry, 1);\n \t    }\n \t}\n-      if (set_p)\n-\t{\n-\t  for (bb = 0; bb < n_basic_blocks; bb++)\n-\t    if (mem_set_in_block[bb])\n-\t      SET_BIT (bmap[bb], indx);\n-\t}\n-      else\n-\t{\n-\t  for (bb = 0; bb < n_basic_blocks; bb++)\n-\t    if (mem_set_in_block[bb])\n-\t      RESET_BIT (bmap[bb], indx);\n-\t}\n \n       x = XEXP (x, 0);\n       goto repeat;"}]}