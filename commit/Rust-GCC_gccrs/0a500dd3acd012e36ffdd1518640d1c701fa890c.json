{"sha": "0a500dd3acd012e36ffdd1518640d1c701fa890c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGE1MDBkZDNhY2QwMTJlMzZmZmRkMTUxODY0MGQxYzcwMWZhODkwYw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2011-10-24T12:31:01Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-10-24T12:31:01Z"}, "message": "re PR tree-optimization/50838 (ice in refs_may_alias_p_1 with -O3)\n\n2011-10-24  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/50838\n\t* tree-data-ref.c (dr_analyze_indices): Properly canonicalize\n\ta MEM_REF base if we change it.\n\n\t* gcc.dg/torture/pr50838.c: New testcase.\n\nFrom-SVN: r180381", "tree": {"sha": "58fa5569a0a61b2ddf609acd913fff4129d1cc27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/58fa5569a0a61b2ddf609acd913fff4129d1cc27"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0a500dd3acd012e36ffdd1518640d1c701fa890c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a500dd3acd012e36ffdd1518640d1c701fa890c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a500dd3acd012e36ffdd1518640d1c701fa890c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a500dd3acd012e36ffdd1518640d1c701fa890c/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "30e1709cc9c5281ffbe47cc7c27864bd9785e6a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30e1709cc9c5281ffbe47cc7c27864bd9785e6a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30e1709cc9c5281ffbe47cc7c27864bd9785e6a4"}], "stats": {"total": 80, "additions": 63, "deletions": 17}, "files": [{"sha": "69450bb37fd0cd698e49c2d4a4274376c549ecbf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a500dd3acd012e36ffdd1518640d1c701fa890c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a500dd3acd012e36ffdd1518640d1c701fa890c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0a500dd3acd012e36ffdd1518640d1c701fa890c", "patch": "@@ -1,3 +1,9 @@\n+2011-10-24  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/50838\n+\t* tree-data-ref.c (dr_analyze_indices): Properly canonicalize\n+\ta MEM_REF base if we change it.\n+\n 2011-10-24  Bernd Schmidt  <bernds@codesourcery.com>\n \n \tPR bootstrap/50836"}, {"sha": "bd252aa1d3535317b8097cda0161f8b9aae8a5b8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a500dd3acd012e36ffdd1518640d1c701fa890c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a500dd3acd012e36ffdd1518640d1c701fa890c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0a500dd3acd012e36ffdd1518640d1c701fa890c", "patch": "@@ -1,3 +1,8 @@\n+2011-10-24  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/50838\n+\t* gcc.dg/torture/pr50838.c: New testcase.\n+\n 2011-10-24  Ira Rosen  <ira.rosen@linaro.org>\n \n \tPR tree-optimization/50730"}, {"sha": "a3911c9752a1fab937813c013934402f811945b8", "filename": "gcc/testsuite/gcc.dg/torture/pr50838.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a500dd3acd012e36ffdd1518640d1c701fa890c/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr50838.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a500dd3acd012e36ffdd1518640d1c701fa890c/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr50838.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr50838.c?ref=0a500dd3acd012e36ffdd1518640d1c701fa890c", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+\n+typedef void * gcv_object_t;\n+typedef gcv_object_t object;\n+typedef const void * Pseudofun;\n+extern struct pseudocode_tab_ {\n+    Pseudofun pseudo_eql;\n+    Pseudofun pseudo_iconv_wcslen;\n+    Pseudofun pseudo_iconv_wcstombs;\n+    Pseudofun pseudo_iconv_range;\n+}\n+pseudocode_tab;\n+extern struct symbol_tab_ {\n+    object pointer[1024];\n+} pseudofun_tab;\n+int\n+init_memory (void)\n+{\n+  object* ptr2 = &pseudofun_tab.pointer[0];\n+  const Pseudofun* ptr1 = (const Pseudofun*)&pseudocode_tab;\n+  unsigned int count = (sizeof(pseudocode_tab)/sizeof(Pseudofun));\n+  while (count--)\n+    {\n+      *ptr2++ = (gcv_object_t)(((unsigned char *)((*ptr1))));\n+      ptr1++;\n+    }\n+}"}, {"sha": "4e0de052c15e086133b9bd23ed5157233f3d6414", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 25, "deletions": 17, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a500dd3acd012e36ffdd1518640d1c701fa890c/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a500dd3acd012e36ffdd1518640d1c701fa890c/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=0a500dd3acd012e36ffdd1518640d1c701fa890c", "patch": "@@ -855,7 +855,7 @@ static void\n dr_analyze_indices (struct data_reference *dr, loop_p nest, loop_p loop)\n {\n   VEC (tree, heap) *access_fns = NULL;\n-  tree ref, aref, op;\n+  tree ref, *aref, op;\n   tree base, off, access_fn;\n   basic_block before_loop;\n \n@@ -886,50 +886,58 @@ dr_analyze_indices (struct data_reference *dr, loop_p nest, loop_p loop)\n     }\n \n   /* Analyze access functions of dimensions we know to be independent.  */\n-  aref = ref;\n-  while (handled_component_p (aref))\n+  aref = &ref;\n+  while (handled_component_p (*aref))\n     {\n-      if (TREE_CODE (aref) == ARRAY_REF)\n+      if (TREE_CODE (*aref) == ARRAY_REF)\n \t{\n-\t  op = TREE_OPERAND (aref, 1);\n+\t  op = TREE_OPERAND (*aref, 1);\n \t  access_fn = analyze_scalar_evolution (loop, op);\n \t  access_fn = instantiate_scev (before_loop, loop, access_fn);\n \t  VEC_safe_push (tree, heap, access_fns, access_fn);\n \t  /* For ARRAY_REFs the base is the reference with the index replaced\n \t     by zero if we can not strip it as the outermost component.  */\n-\t  if (aref == ref)\n-\t    ref = TREE_OPERAND (ref, 0);\n+\t  if (*aref == ref)\n+\t    {\n+\t      *aref = TREE_OPERAND (*aref, 0);\n+\t      continue;\n+\t    }\n \t  else\n-\t    TREE_OPERAND (aref, 1) = build_int_cst (TREE_TYPE (op), 0);\n+\t    TREE_OPERAND (*aref, 1) = build_int_cst (TREE_TYPE (op), 0);\n \t}\n \n-      aref = TREE_OPERAND (aref, 0);\n+      aref = &TREE_OPERAND (*aref, 0);\n     }\n \n   /* If the address operand of a MEM_REF base has an evolution in the\n      analyzed nest, add it as an additional independent access-function.  */\n-  if (TREE_CODE (aref) == MEM_REF)\n+  if (TREE_CODE (*aref) == MEM_REF)\n     {\n-      op = TREE_OPERAND (aref, 0);\n+      op = TREE_OPERAND (*aref, 0);\n       access_fn = analyze_scalar_evolution (loop, op);\n       access_fn = instantiate_scev (before_loop, loop, access_fn);\n       if (TREE_CODE (access_fn) == POLYNOMIAL_CHREC)\n \t{\n+\t  tree orig_type;\n \t  base = initial_condition (access_fn);\n+\t  orig_type = TREE_TYPE (base);\n+\t  STRIP_USELESS_TYPE_CONVERSION (base);\n \t  split_constant_offset (base, &base, &off);\n \t  /* Fold the MEM_REF offset into the evolutions initial\n \t     value to make more bases comparable.  */\n-\t  if (!integer_zerop (TREE_OPERAND (aref, 1)))\n+\t  if (!integer_zerop (TREE_OPERAND (*aref, 1)))\n \t    {\n \t      off = size_binop (PLUS_EXPR, off,\n \t\t\t\tfold_convert (ssizetype,\n-\t\t\t\t\t      TREE_OPERAND (aref, 1)));\n-\t      TREE_OPERAND (aref, 1)\n-\t\t= build_int_cst (TREE_TYPE (TREE_OPERAND (aref, 1)), 0);\n+\t\t\t\t\t      TREE_OPERAND (*aref, 1)));\n+\t      TREE_OPERAND (*aref, 1)\n+\t\t= build_int_cst (TREE_TYPE (TREE_OPERAND (*aref, 1)), 0);\n \t    }\n \t  access_fn = chrec_replace_initial_condition\n-\t      (access_fn, fold_convert (TREE_TYPE (base), off));\n-\t  TREE_OPERAND (aref, 0) = base;\n+\t      (access_fn, fold_convert (orig_type, off));\n+\t  *aref = fold_build2_loc (EXPR_LOCATION (*aref),\n+\t\t\t\t   MEM_REF, TREE_TYPE (*aref),\n+\t\t\t\t   base, TREE_OPERAND (*aref, 1));\n \t  VEC_safe_push (tree, heap, access_fns, access_fn);\n \t}\n     }"}]}