{"sha": "0d7d98ee650c56e48f4a12e48c4abe040497abb7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQ3ZDk4ZWU2NTBjNTZlNDhmNGExMmU0OGM0YWJlMDQwNDk3YWJiNw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-03-21T19:35:48Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-03-21T19:35:48Z"}, "message": "i386.c (override_options): Default ix86_regparm to REGPARM_MAX.\n\n\n\t* i386.c (override_options): Default ix86_regparm to REGPARM_MAX.\n\t(override_options): Use properlimits for preferred_stack_boundary.\n\t(ix86_valid_type_attribute_p): Disable stdcall and cdecl attributes\n\ton x86_64.\n\t(ext_register_operand): Accept DImode.\n\t(load_pic_register): Abort on 64bit.\n\t(gen_push): Use Pmode instead of SImode.\n\t(ix86_save_reg): Pic reg is never used on 64bit.\n\t(ix86_expand_prologue): Likewise.\n\t(ix86_emit_save_regs): Use Pmode instead of SImode.\n\t(legitimate_address_p): Check displacement for 64bit.\n\t(print_operand): Avoid outputting of (%rip) on 64bit.\n\t(print_operand_address): Output (%rip) where possible.\n\t(split_di): Abort on 64bit registers.\n\t(ix86_expand_branch): DImode comparison is simple for x86_64.\n\t(memory_address_length): Recognize memory addresses formed using PRE/POST modify.\n\t(ix86_data_alignment, ix86_local_alignment): Align arrays to 16 bytes for x86_64.\n\t* i386.h (TARGET_USE_SAHF): Disable for 64bit.\n\nFrom-SVN: r40708", "tree": {"sha": "25ff9172890c141022594d99d0bc53320da72a50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/25ff9172890c141022594d99d0bc53320da72a50"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d7d98ee650c56e48f4a12e48c4abe040497abb7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d7d98ee650c56e48f4a12e48c4abe040497abb7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d7d98ee650c56e48f4a12e48c4abe040497abb7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d7d98ee650c56e48f4a12e48c4abe040497abb7/comments", "author": null, "committer": null, "parents": [{"sha": "191de4070914f7d669d4e81446ef0fc644ee7978", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/191de4070914f7d669d4e81446ef0fc644ee7978", "html_url": "https://github.com/Rust-GCC/gccrs/commit/191de4070914f7d669d4e81446ef0fc644ee7978"}], "stats": {"total": 124, "additions": 106, "deletions": 18}, "files": [{"sha": "979aa2334fb15af1db2ac80ffeb096eb9b124a6b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d7d98ee650c56e48f4a12e48c4abe040497abb7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d7d98ee650c56e48f4a12e48c4abe040497abb7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0d7d98ee650c56e48f4a12e48c4abe040497abb7", "patch": "@@ -1,3 +1,24 @@\n+Wed Mar 21 20:33:26 CET 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.c (override_options): Default ix86_regparm to REGPARM_MAX.\n+\t(override_options): Use properlimits for preferred_stack_boundary.\n+\t(ix86_valid_type_attribute_p): Disable stdcall and cdecl attributes\n+\ton x86_64.\n+\t(ext_register_operand): Accept DImode.\n+\t(load_pic_register): Abort on 64bit.\n+\t(gen_push): Use Pmode instead of SImode.\n+\t(ix86_save_reg): Pic reg is never used on 64bit.\n+\t(ix86_expand_prologue): Likewise.\n+\t(ix86_emit_save_regs): Use Pmode instead of SImode.\n+\t(legitimate_address_p): Check displacement for 64bit.\n+\t(print_operand): Avoid outputting of (%rip) on 64bit.\n+\t(print_operand_address): Output (%rip) where possible.\n+\t(split_di): Abort on 64bit registers.\n+\t(ix86_expand_branch): DImode comparison is simple for x86_64.\n+\t(memory_address_length): Recognize memory addresses formed using PRE/POST modify.\n+\t(ix86_data_alignment, ix86_local_alignment): Align arrays to 16 bytes for x86_64.\n+\t* i386.h (TARGET_USE_SAHF): Disable for 64bit.\n+\n Wed Mar 21 18:51:19 CET 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* recog.c (push_operand): Recognize new format of push instructions."}, {"sha": "d5a1da118d9364702548479db095b55a4ace2735", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 84, "deletions": 17, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d7d98ee650c56e48f4a12e48c4abe040497abb7/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d7d98ee650c56e48f4a12e48c4abe040497abb7/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=0d7d98ee650c56e48f4a12e48c4abe040497abb7", "patch": "@@ -738,6 +738,9 @@ override_options ()\n       else\n \tix86_regparm = i;\n     }\n+  else\n+   if (TARGET_64BIT)\n+     ix86_regparm = REGPARM_MAX;\n \n   /* Validate -malign-loops= value, or provide default.  */\n   ix86_align_loops = processor_target_table[ix86_cpu].align_loop;\n@@ -779,8 +782,9 @@ override_options ()\n   if (ix86_preferred_stack_boundary_string)\n     {\n       i = atoi (ix86_preferred_stack_boundary_string);\n-      if (i < 2 || i > 31)\n-\terror (\"-mpreferred-stack-boundary=%d is not between 2 and 31\", i);\n+      if (i < (TARGET_64BIT ? 3 : 2) || i > 31)\n+\terror (\"-mpreferred-stack-boundary=%d is not between %d and 31\", i,\n+\t       TARGET_64BIT ? 3 : 2);\n       else\n \tix86_preferred_stack_boundary = (1 << i) * BITS_PER_UNIT;\n     }\n@@ -857,11 +861,13 @@ ix86_valid_type_attribute_p (type, attributes, identifier, args)\n \n   /* Stdcall attribute says callee is responsible for popping arguments\n      if they are not variable.  */\n-  if (is_attribute_p (\"stdcall\", identifier))\n+  if (is_attribute_p (\"stdcall\", identifier)\n+      && !TARGET_64BIT)\n     return (args == NULL_TREE);\n \n   /* Cdecl attribute says the callee is a normal C declaration.  */\n-  if (is_attribute_p (\"cdecl\", identifier))\n+  if (is_attribute_p (\"cdecl\", identifier)\n+      && !TARGET_64BIT)\n     return (args == NULL_TREE);\n \n   /* Regparm attribute specifies how many integer arguments are to be\n@@ -950,7 +956,8 @@ ix86_return_pops_args (fundecl, funtype, size)\n   }\n \n   /* Lose any fake structure return argument.  */\n-  if (aggregate_value_p (TREE_TYPE (funtype)))\n+  if (aggregate_value_p (TREE_TYPE (funtype))\n+      && !TARGET_64BIT)\n     return GET_MODE_SIZE (Pmode);\n \n     return 0;\n@@ -1654,7 +1661,8 @@ ext_register_operand (op, mode)\n      register rtx op;\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n-  if (GET_MODE (op) != SImode && GET_MODE (op) != HImode)\n+  if ((!TARGET_64BIT || GET_MODE (op) != DImode)\n+      && GET_MODE (op) != SImode && GET_MODE (op) != HImode)\n     return 0;\n   return register_operand (op, VOIDmode);\n }\n@@ -2179,6 +2187,9 @@ load_pic_register ()\n {\n   rtx gotsym, pclab;\n \n+  if (TARGET_64BIT)\n+    abort();\n+\n   gotsym = gen_rtx_SYMBOL_REF (Pmode, \"_GLOBAL_OFFSET_TABLE_\");\n \n   if (TARGET_DEEP_BRANCH_PREDICTION)\n@@ -2200,15 +2211,15 @@ load_pic_register ()\n   emit_insn (gen_prologue_set_got (pic_offset_table_rtx, gotsym, pclab));\n }\n \n-/* Generate an SImode \"push\" pattern for input ARG.  */\n+/* Generate an \"push\" pattern for input ARG.  */\n \n static rtx\n gen_push (arg)\n      rtx arg;\n {\n   return gen_rtx_SET (VOIDmode,\n-\t\t      gen_rtx_MEM (SImode,\n-\t\t\t\t   gen_rtx_PRE_DEC (SImode,\n+\t\t      gen_rtx_MEM (Pmode,\n+\t\t\t\t   gen_rtx_PRE_DEC (Pmode,\n \t\t\t\t\t\t    stack_pointer_rtx)),\n \t\t      arg);\n }\n@@ -2219,7 +2230,8 @@ ix86_save_reg (regno)\n \tint regno;\n {\n   int pic_reg_used = flag_pic && (current_function_uses_pic_offset_table\n-\t\t\t\t  || current_function_uses_const_pool);\n+\t\t\t\t  || current_function_uses_const_pool)\n+\t\t     && !TARGET_64BIT;\n   return ((regs_ever_live[regno] && !call_used_regs[regno]\n \t   && !fixed_regs[regno]\n \t   && (regno != HARD_FRAME_POINTER_REGNUM || !frame_pointer_needed))\n@@ -2368,7 +2380,7 @@ ix86_emit_save_regs ()\n   for (regno = FIRST_PSEUDO_REGISTER - 1; regno >= 0; regno--)\n     if (ix86_save_reg (regno))\n       {\n-\tinsn = emit_insn (gen_push (gen_rtx_REG (SImode, regno)));\n+\tinsn = emit_insn (gen_push (gen_rtx_REG (Pmode, regno)));\n \tRTX_FRAME_RELATED_P (insn) = 1;\n       }\n }\n@@ -2379,8 +2391,9 @@ void\n ix86_expand_prologue ()\n {\n   rtx insn;\n-  int pic_reg_used = flag_pic && (current_function_uses_pic_offset_table\n-\t\t\t\t  || current_function_uses_const_pool);\n+  int pic_reg_used = (flag_pic && (current_function_uses_pic_offset_table\n+\t\t\t\t  || current_function_uses_const_pool)\n+\t\t      && !TARGET_64BIT);\n   struct ix86_frame frame;\n \n   ix86_compute_frame_layout (&frame);\n@@ -2976,14 +2989,30 @@ legitimate_address_p (mode, addr, strict)\n \t  goto report_error;\n \t}\n \n-      if (GET_CODE (disp) == CONST_DOUBLE)\n+      if (TARGET_64BIT)\n \t{\n-\t  reason = \"displacement is a const_double\";\n-\t  goto report_error;\n+\t  if (!x86_64_sign_extended_value (disp))\n+\t    {\n+\t      reason = \"displacement is out of range\";\n+\t      goto report_error;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if (GET_CODE (disp) == CONST_DOUBLE)\n+\t    {\n+\t      reason = \"displacement is a const_double\";\n+\t      goto report_error;\n+\t    }\n \t}\n \n       if (flag_pic && SYMBOLIC_CONST (disp))\n \t{\n+\t  if (TARGET_64BIT && (index || base))\n+\t    {\n+\t      reason = \"non-constant pic memory reference\";\n+\t      goto report_error;\n+\t    }\n \t  if (! legitimate_pic_address_disp_p (disp))\n \t    {\n \t      reason = \"displacement is an invalid pic construct\";\n@@ -3958,6 +3987,10 @@ print_operand (file, x, code)\n       x = XEXP (x, 0);\n       if (flag_pic && CONSTANT_ADDRESS_P (x))\n \toutput_pic_addr_const (file, x, code);\n+      /* Avoid (%rip) for call operands.  */\n+      else if (CONSTANT_ADDRESS_P (x) && code =='P'\n+\t       && GET_CODE (x) != CONST_INT)\n+\toutput_addr_const (file, x);\n       else\n \toutput_address (x);\n     }\n@@ -4060,6 +4093,10 @@ print_operand_address (file, addr)\n \toutput_pic_addr_const (file, addr, 0);\n       else\n \toutput_addr_const (file, addr);\n+\n+      /* Use one byte shorter RIP relative addressing for 64bit mode.  */\n+      if (GET_CODE (disp) != CONST_INT && TARGET_64BIT)\n+\tfputs (\"(%rip)\", file);\n     }\n   else\n     {\n@@ -4165,6 +4202,8 @@ split_di (operands, num, lo_half, hi_half)\n \t}\n       else if (GET_CODE (op) == REG)\n \t{\n+\t  if (TARGET_64BIT)\n+\t    abort();\n \t  lo_half[num] = gen_rtx_REG (SImode, REGNO (op));\n \t  hi_half[num] = gen_rtx_REG (SImode, REGNO (op) + 1);\n \t}\n@@ -5726,6 +5765,7 @@ ix86_expand_branch (code, label)\n     case QImode:\n     case HImode:\n     case SImode:\n+      simple:\n       tmp = ix86_expand_compare (code, NULL, NULL);\n       tmp = gen_rtx_IF_THEN_ELSE (VOIDmode, tmp,\n \t\t\t\t  gen_rtx_LABEL_REF (VOIDmode, label),\n@@ -5769,6 +5809,8 @@ ix86_expand_branch (code, label)\n       }\n \n     case DImode:\n+      if (TARGET_64BIT)\n+\tgoto simple;\n       /* Expand DImode branch into multiple compare+branch.  */\n       {\n \trtx lo[2], hi[2], label2;\n@@ -7178,7 +7220,9 @@ memory_address_length (addr)\n   int len;\n \n   if (GET_CODE (addr) == PRE_DEC\n-      || GET_CODE (addr) == POST_INC)\n+      || GET_CODE (addr) == POST_INC\n+      || GET_CODE (addr) == PRE_MODIFY\n+      || GET_CODE (addr) == POST_MODIFY)\n     return 0;\n \n   if (! ix86_decompose_address (addr, &parts))\n@@ -7985,6 +8029,18 @@ ix86_data_alignment (type, align)\n \t   || TREE_INT_CST_HIGH (TYPE_SIZE (type))) && align < 256)\n     return 256;\n \n+  /* x86-64 ABI requires arrays greater than 16 bytes to be aligned\n+     to 16byte boundary.  */\n+  if (TARGET_64BIT)\n+    {\n+      if (AGGREGATE_TYPE_P (type)\n+\t   && TYPE_SIZE (type)\n+\t   && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST\n+\t   && (TREE_INT_CST_LOW (TYPE_SIZE (type)) >= 128\n+\t       || TREE_INT_CST_HIGH (TYPE_SIZE (type))) && align < 128)\n+\treturn 128;\n+    }\n+\n   if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n       if (TYPE_MODE (TREE_TYPE (type)) == DFmode && align < 64)\n@@ -8032,6 +8088,17 @@ ix86_local_alignment (type, align)\n      tree type;\n      int align;\n {\n+  /* x86-64 ABI requires arrays greater than 16 bytes to be aligned\n+     to 16byte boundary.  */\n+  if (TARGET_64BIT)\n+    {\n+      if (AGGREGATE_TYPE_P (type)\n+\t   && TYPE_SIZE (type)\n+\t   && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST\n+\t   && (TREE_INT_CST_LOW (TYPE_SIZE (type)) >= 16\n+\t       || TREE_INT_CST_HIGH (TYPE_SIZE (type))) && align < 128)\n+\treturn 128;\n+    }\n   if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n       if (TYPE_MODE (TREE_TYPE (type)) == DFmode && align < 64)"}, {"sha": "efc1e65136819f813c6d604a6ab1044c708a18a4", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d7d98ee650c56e48f4a12e48c4abe040497abb7/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d7d98ee650c56e48f4a12e48c4abe040497abb7/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=0d7d98ee650c56e48f4a12e48c4abe040497abb7", "patch": "@@ -214,7 +214,7 @@ extern const int x86_partial_reg_dependency, x86_memory_mismatch_stall;\n #define TARGET_CMOVE ((x86_cmove & (1 << ix86_arch)) || TARGET_SSE)\n #define TARGET_DEEP_BRANCH_PREDICTION (x86_deep_branch & CPUMASK)\n #define TARGET_DOUBLE_WITH_ADD (x86_double_with_add & CPUMASK)\n-#define TARGET_USE_SAHF (x86_use_sahf & CPUMASK)\n+#define TARGET_USE_SAHF ((x86_use_sahf & CPUMASK) && !TARGET_64BIT)\n #define TARGET_MOVX (x86_movx & CPUMASK)\n #define TARGET_PARTIAL_REG_STALL (x86_partial_reg_stall & CPUMASK)\n #define TARGET_USE_LOOP (x86_use_loop & CPUMASK)"}]}