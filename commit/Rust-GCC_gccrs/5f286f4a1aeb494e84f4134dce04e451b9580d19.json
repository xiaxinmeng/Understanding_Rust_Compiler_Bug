{"sha": "5f286f4a1aeb494e84f4134dce04e451b9580d19", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWYyODZmNGExYWViNDk0ZTg0ZjQxMzRkY2UwNGU0NTFiOTU4MGQxOQ==", "commit": {"author": {"name": "Yao Qi", "email": "yao@codesourcery.com", "date": "2010-12-07T12:28:46Z"}, "committer": {"name": "Yao Qi", "email": "qiyao@gcc.gnu.org", "date": "2010-12-07T12:28:46Z"}, "message": "Makefile.in: Add $(TARGET_H) to the regrename.o rule.\n\n        * Makefile.in: Add $(TARGET_H) to the regrename.o rule.\n        * regrename.c (struct du_head): Add new element length.\n        (sort_du_head, get_element, merge, merge_sort_comparison):\n        New functions of merge sort implementation to du_head list.\n        (regrename_optimize): Sort du_head linked list by length.\n        Iterate registers in a preferred-register-first order.\n        Move some code to ...\n        (check_new_reg_p): here.  New function.\n        (create_new_chain):  Initialize length.\n        (scan_rtx_reg): Increase length for non-debug insns.\n        * target.def: New hook preferred_rename_class.\n        * targhook.c (default_preferred_rename_class): New.\n        * targhook.h: Declare it.\n        * doc/tm.texi.in: New hook TARGET_PREFERRED_RENAME_CLASS.\n        * doc/tm.texi: Regenerate.\n\nFrom-SVN: r167534", "tree": {"sha": "950a823eefdfe7224b81c1148fa0eb418429dda3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/950a823eefdfe7224b81c1148fa0eb418429dda3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f286f4a1aeb494e84f4134dce04e451b9580d19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f286f4a1aeb494e84f4134dce04e451b9580d19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f286f4a1aeb494e84f4134dce04e451b9580d19", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f286f4a1aeb494e84f4134dce04e451b9580d19/comments", "author": null, "committer": null, "parents": [{"sha": "9ff706526b9553bbb540188f932189ce1719c837", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ff706526b9553bbb540188f932189ce1719c837", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ff706526b9553bbb540188f932189ce1719c837"}], "stats": {"total": 353, "additions": 305, "deletions": 48}, "files": [{"sha": "fb4a27b3ce5b99cdb3b017bcc37cc3a6b4fc0c0d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f286f4a1aeb494e84f4134dce04e451b9580d19/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f286f4a1aeb494e84f4134dce04e451b9580d19/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5f286f4a1aeb494e84f4134dce04e451b9580d19", "patch": "@@ -1,3 +1,21 @@\n+2010-12-07  Yao Qi  <yao@codesourcery.com>\n+\n+\t* Makefile.in: Add $(TARGET_H) to the regrename.o rule.\n+\t* regrename.c (struct du_head): Add new element length.\n+\t(sort_du_head, get_element, merge, merge_sort_comparison):\n+\tNew functions of merge sort implementation to du_head list.\n+\t(regrename_optimize): Sort du_head linked list by length.\n+\tIterate registers in a preferred-register-first order.\n+\tMove some code to ...\n+\t(check_new_reg_p): here.  New function.\n+\t(create_new_chain):  Initialize length.\n+\t(scan_rtx_reg): Increase length for non-debug insns.\n+\t* target.def: New hook preferred_rename_class.\n+\t* targhook.c (default_preferred_rename_class): New.\n+\t* targhook.h: Declare it.\n+\t* doc/tm.texi.in: New hook TARGET_PREFERRED_RENAME_CLASS.\n+\t* doc/tm.texi: Regenerate.\n+\t\n 2010-12-07  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR debug/46799"}, {"sha": "ae195e3356d126c395bae87bf75bab5fa16c6a0c", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f286f4a1aeb494e84f4134dce04e451b9580d19/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f286f4a1aeb494e84f4134dce04e451b9580d19/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=5f286f4a1aeb494e84f4134dce04e451b9580d19", "patch": "@@ -3493,7 +3493,7 @@ regcprop.o : regcprop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n regrename.o : regrename.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_ERROR_H) insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h \\\n    output.h $(RECOG_H) $(FUNCTION_H) $(OBSTACK_H) $(FLAGS_H) $(TM_P_H) \\\n-   addresses.h reload.h $(TIMEVAR_H) $(TREE_PASS_H) $(DF_H)\n+   addresses.h reload.h $(TIMEVAR_H) $(TREE_PASS_H) $(DF_H) $(TARGET_H)\n ifcvt.o : ifcvt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(REGS_H) $(DIAGNOSTIC_CORE_H) $(FLAGS_H) insn-config.h $(FUNCTION_H) $(RECOG_H) \\\n    $(TARGET_H) $(BASIC_BLOCK_H) $(EXPR_H) output.h $(EXCEPT_H) $(TM_P_H) \\"}, {"sha": "8870d76e7bee6e33755627d25bb394fe9648e8fa", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f286f4a1aeb494e84f4134dce04e451b9580d19/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f286f4a1aeb494e84f4134dce04e451b9580d19/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=5f286f4a1aeb494e84f4134dce04e451b9580d19", "patch": "@@ -2504,6 +2504,10 @@ looking for one that is valid, and will reload one or both registers\n only if neither labeling works.\n @end defmac\n \n+@deftypefn {Target Hook} reg_class_t TARGET_PREFERRED_RENAME_CLASS (reg_class_t @var{rclass})\n+A target hook that places additional preference on the register class to use when it is necessary to rename a register in class @var{class} to another class, or perhaps @var{NO_REGS}, if no prefered register class is found or hook @code{preferred_rename_class} is not implemented. Sometimes returning a more restrictive class makes better code.  For example, on ARM, thumb-2 instructions using @code{LO_REGS} may be smaller than instructions using @code{GENERIC_REGS}.  By returning @code{LO_REGS} from @code{preferred_rename_class}, code size can be reduced.\n+@end deftypefn\n+\n @deftypefn {Target Hook} reg_class_t TARGET_PREFERRED_RELOAD_CLASS (rtx @var{x}, reg_class_t @var{rclass})\n A target hook that places additional restrictions on the register class\n to use when it is necessary to copy value @var{x} into a register in class"}, {"sha": "c85dfa28fd4f50e48ec2a1c835ca7497dd85bff8", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f286f4a1aeb494e84f4134dce04e451b9580d19/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f286f4a1aeb494e84f4134dce04e451b9580d19/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=5f286f4a1aeb494e84f4134dce04e451b9580d19", "patch": "@@ -2494,6 +2494,8 @@ looking for one that is valid, and will reload one or both registers\n only if neither labeling works.\n @end defmac\n \n+@hook TARGET_PREFERRED_RENAME_CLASS\n+\n @hook TARGET_PREFERRED_RELOAD_CLASS\n A target hook that places additional restrictions on the register class\n to use when it is necessary to copy value @var{x} into a register in class"}, {"sha": "48013f385d8383bebf0f18b044e7e53da2710274", "filename": "gcc/regrename.c", "status": "modified", "additions": 257, "deletions": 47, "changes": 304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f286f4a1aeb494e84f4134dce04e451b9580d19/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f286f4a1aeb494e84f4134dce04e451b9580d19/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=5f286f4a1aeb494e84f4134dce04e451b9580d19", "patch": "@@ -38,6 +38,7 @@\n #include \"timevar.h\"\n #include \"tree-pass.h\"\n #include \"df.h\"\n+#include \"target.h\"\n \n #if HOST_BITS_PER_WIDE_INT <= MAX_RECOG_OPERANDS\n #error \"Use a different bitmap implementation for untracked_operands.\"\n@@ -51,6 +52,11 @@ struct du_head\n   struct du_head *next_chain;\n   /* The first and last elements of this chain.  */\n   struct du_chain *first, *last;\n+  /* The number of elements of this chain, excluding those corresponding\n+     to references of the register in debug insns.  The du_head linked\n+     list can be sorted by this, and register-rename can prefer\n+     register classes according to this order.  */\n+  int length;\n   /* Describes the register being tracked.  */\n   unsigned regno, nregs;\n \n@@ -154,6 +160,197 @@ merge_overlapping_regs (HARD_REG_SET *pset, struct du_head *head)\n     }\n }\n \n+/* Return the Nth element in LIST.  If LIST contains less than N\n+   elements, return the last one.  */\n+static struct du_head *\n+get_element (struct du_head *list, int n)\n+{\n+  while (n-- && list->next_chain != NULL)\n+    list = list->next_chain;\n+\n+  return list;\n+}\n+\n+/* Comparison function of merge sort.  Return true if A is less than\n+   B, otherwise return false.  */\n+static inline int\n+merge_sort_comparison(const struct du_head *a,\n+\t\t    const struct du_head *b)\n+{\n+  return a->length < b->length;\n+}\n+\n+/* Merge the first 2 sub-lists of LENGTH nodes contained in the\n+   linked list pointed to by START_NODE.  Update START_NODE to point\n+   to the merged nodes, and return a pointer to the last merged\n+   node.  Return NULL if START_NODE doesn't contain enough\n+   elements, or this pass of merge is done.  */\n+\n+static struct du_head *\n+merge(struct du_head **start_node, int length)\n+{\n+  int i, left_count, right_count;\n+  struct du_head *left, *right;\n+  /* Current node of sort result.  */\n+  struct du_head *current_sorted_node;\n+  /* Tail node of sort, used to connect with next piece of list.  */\n+  struct du_head *current_tail_node;\n+\n+  if (*start_node == NULL)\n+    return NULL;\n+\n+  left = right = *start_node;\n+  right_count = left_count = 0;\n+\n+  /* Step RIGHT along the list by LENGTH places.  */\n+  for (i = 0; i < length; i++)\n+    {\n+      right = right->next_chain;\n+      if (right == NULL)\n+\t{\n+\t  return NULL;\n+\t}\n+    }\n+\n+  /* Initialize current_sorted_node.  */\n+  if (merge_sort_comparison (left, right))\n+    {\n+      ++right_count;\n+      current_sorted_node = right;\n+      *start_node = right;\n+      right = right->next_chain;\n+    }\n+  else\n+    {\n+      ++left_count;\n+      current_sorted_node = left;\n+      left = left->next_chain;\n+    }\n+\n+  while (1)\n+    {\n+      /* Choose LEFT or RIGHT to take the next element from.  If\n+\t either is empty, choose from the other one.  */\n+      if (left_count == length || left == NULL)\n+\t{\n+\t  current_sorted_node->next_chain = right;\n+\t  current_tail_node = get_element (current_sorted_node,\n+\t\t\t\t\t   length - right_count);\n+\n+\t  break;\n+\t}\n+      else if (right_count == length || right == NULL)\n+\t{\n+\t  /* Save the head node of next piece of linked list.  */\n+\t  struct du_head *tmp = current_sorted_node->next_chain;\n+\n+\t  current_sorted_node->next_chain = left;\n+\t  current_tail_node\n+\t    = get_element (current_sorted_node,\n+\t\t\t   length - left_count);\n+\t  /* Connect sorted list to next piece of list.  */\n+\t  current_tail_node->next_chain = tmp;\n+\t  break;\n+\t}\n+      else\n+\t{\n+\t  /* Normal merge operations.  If both LEFT and RIGHT are\n+\t     non-empty, compare the first element of each and choose\n+\t     the lower one.  */\n+\t  if (merge_sort_comparison (left, right))\n+\t    {\n+\t      right_count++;\n+\t      current_sorted_node->next_chain = right;\n+\t      right = right->next_chain;\n+\t    }\n+\t  else\n+\t    {\n+\t      left_count++;\n+\t      current_sorted_node->next_chain = left;\n+\t      left = left->next_chain;\n+\t    }\n+\t  current_sorted_node = current_sorted_node->next_chain;\n+\t}\n+    }\n+  /* Return NULL if this pass of merge is done.  */\n+  return (current_tail_node->next_chain ? current_tail_node : NULL);\n+}\n+\n+/* Sort the linked list pointed to by HEAD.  The algorithm is a\n+   non-recursive merge sort to linked list.  */\n+\n+static void\n+sort_du_head (struct du_head **head)\n+{\n+  int current_length = 1;\n+  struct du_head *last_tail;\n+\n+  /* In each pass, lists of size current_length is merged to\n+     lists of size 2xcurrent_length (Initially current_length\n+     is 1).  */\n+  while (1)\n+    {\n+      last_tail = merge(head, current_length);\n+      if (last_tail != NULL)\n+\t{\n+\t  do\n+\t    last_tail = merge (&last_tail->next_chain, current_length);\n+\t  while (last_tail != NULL);\n+\n+\t  current_length *= 2;\n+\t}\n+      else\n+\tbreak;\n+    }\n+}\n+\n+/* Check if NEW_REG can be the candidate register to rename for\n+   REG in THIS_HEAD chain.  THIS_UNAVAILABLE is a set of unavailable hard\n+   registers.  */\n+\n+static bool\n+check_new_reg_p (int reg, int new_reg,  struct du_head *this_head,\n+\t\t HARD_REG_SET this_unavailable)\n+{\n+  enum machine_mode mode = GET_MODE (*this_head->first->loc);\n+  int nregs = hard_regno_nregs[new_reg][mode];\n+  int i;\n+  struct du_chain *tmp;\n+\n+  for (i = nregs - 1; i >= 0; --i)\n+    if (TEST_HARD_REG_BIT (this_unavailable, new_reg + i)\n+\t|| fixed_regs[new_reg + i]\n+\t|| global_regs[new_reg + i]\n+\t/* Can't use regs which aren't saved by the prologue.  */\n+\t|| (! df_regs_ever_live_p (new_reg + i)\n+\t    && ! call_used_regs[new_reg + i])\n+#ifdef LEAF_REGISTERS\n+\t/* We can't use a non-leaf register if we're in a\n+\t   leaf function.  */\n+\t|| (current_function_is_leaf\n+\t    && !LEAF_REGISTERS[new_reg + i])\n+#endif\n+#ifdef HARD_REGNO_RENAME_OK\n+\t|| ! HARD_REGNO_RENAME_OK (reg + i, new_reg + i)\n+#endif\n+\t)\n+      return false;\n+\n+  /* See whether it accepts all modes that occur in\n+     definition and uses.  */\n+  for (tmp = this_head->first; tmp; tmp = tmp->next_use)\n+    if ((! HARD_REGNO_MODE_OK (new_reg, GET_MODE (*tmp->loc))\n+\t && ! DEBUG_INSN_P (tmp->insn))\n+\t|| (this_head->need_caller_save_reg\n+\t    && ! (HARD_REGNO_CALL_PART_CLOBBERED\n+\t\t  (reg, GET_MODE (*tmp->loc)))\n+\t    && (HARD_REGNO_CALL_PART_CLOBBERED\n+\t\t(new_reg, GET_MODE (*tmp->loc)))))\n+      return false;\n+\n+  return true;\n+}\n+\n /* Perform register renaming on the current function.  */\n \n static unsigned int\n@@ -195,6 +392,8 @@ regrename_optimize (void)\n       if (dump_file)\n \tdump_def_use_chain (all_chains);\n \n+      sort_du_head (&all_chains);\n+\n       CLEAR_HARD_REG_SET (unavailable);\n       /* Don't clobber traceback for noreturn functions.  */\n       if (frame_pointer_needed)\n@@ -213,7 +412,9 @@ regrename_optimize (void)\n \t  struct du_chain *tmp;\n \t  HARD_REG_SET this_unavailable;\n \t  int reg = this_head->regno;\n-\t  int i;\n+\t  int pass;\n+\t  enum reg_class superunion_class = NO_REGS;\n+\t  enum reg_class preferred_class;\n \n \t  all_chains = this_head->next_chain;\n \n@@ -243,16 +444,23 @@ regrename_optimize (void)\n \n \t  COPY_HARD_REG_SET (this_unavailable, unavailable);\n \n-\t  /* Count number of uses, and narrow the set of registers we can\n-\t     use for renaming.  */\n+\t  /* Iterate elements in chain in order to:\n+\t     1. Count number of uses, and narrow the set of registers we can\n+\t     use for renaming.\n+\t     2. Compute the superunion of register classes in this chain.  */\n \t  n_uses = 0;\n+\t  superunion_class = NO_REGS;\n \t  for (tmp = this_head->first; tmp; tmp = tmp->next_use)\n \t    {\n \t      if (DEBUG_INSN_P (tmp->insn))\n \t\tcontinue;\n \t      n_uses++;\n+\n \t      IOR_COMPL_HARD_REG_SET (this_unavailable,\n \t\t\t\t      reg_class_contents[tmp->cl]);\n+\n+\t      superunion_class\n+\t\t= reg_class_superunion[(int) superunion_class][(int) tmp->cl];\n \t    }\n \n \t  if (n_uses < 2)\n@@ -262,56 +470,53 @@ regrename_optimize (void)\n \t    IOR_HARD_REG_SET (this_unavailable, call_used_reg_set);\n \n \t  merge_overlapping_regs (&this_unavailable, this_head);\n-\n-\t  /* Now potential_regs is a reasonable approximation, let's\n-\t     have a closer look at each register still in there.  */\n-\t  for (new_reg = 0; new_reg < FIRST_PSEUDO_REGISTER; new_reg++)\n+\t  /* Compute preferred rename class of super union of all the classes\n+\t     on the chain.  */\n+\t  preferred_class\n+\t    = (enum reg_class) targetm.preferred_rename_class(superunion_class);\n+\n+\t  /* The register iteration order here is \"preferred-register-first\".\n+\t     Firstly(pass == 0), we iterate registers belong to PREFERRED_CLASS,\n+\t     if we find a new register, we stop immeidately.\n+\t     Otherwise, we iterate over registers that don't belong to\n+\t     PREFERRED_CLASS.\n+\t     If PREFERRED_CLASS is NO_REGS, we iterate over all registers in\n+\t     ascending order without any preference.  */\n+\t  for (pass = (preferred_class == NO_REGS ? 1 : 0); pass < 2; pass++)\n \t    {\n-\t      enum machine_mode mode = GET_MODE (*this_head->first->loc);\n-\t      int nregs = hard_regno_nregs[new_reg][mode];\n-\n-\t      for (i = nregs - 1; i >= 0; --i)\n-\t        if (TEST_HARD_REG_BIT (this_unavailable, new_reg + i)\n-\t\t    || fixed_regs[new_reg + i]\n-\t\t    || global_regs[new_reg + i]\n-\t\t    /* Can't use regs which aren't saved by the prologue.  */\n-\t\t    || (! df_regs_ever_live_p (new_reg + i)\n-\t\t\t&& ! call_used_regs[new_reg + i])\n-#ifdef LEAF_REGISTERS\n-\t\t    /* We can't use a non-leaf register if we're in a\n-\t\t       leaf function.  */\n-\t\t    || (current_function_is_leaf\n-\t\t\t&& !LEAF_REGISTERS[new_reg + i])\n-#endif\n-#ifdef HARD_REGNO_RENAME_OK\n-\t\t    || ! HARD_REGNO_RENAME_OK (reg + i, new_reg + i)\n-#endif\n-\t\t    )\n-\t\t  break;\n-\t      if (i >= 0)\n-\t\tcontinue;\n-\n-\t      /* See whether it accepts all modes that occur in\n-\t\t definition and uses.  */\n-\t      for (tmp = this_head->first; tmp; tmp = tmp->next_use)\n-\t\tif ((! HARD_REGNO_MODE_OK (new_reg, GET_MODE (*tmp->loc))\n-\t\t     && ! DEBUG_INSN_P (tmp->insn))\n-\t\t    || (this_head->need_caller_save_reg\n-\t\t\t&& ! (HARD_REGNO_CALL_PART_CLOBBERED\n-\t\t\t      (reg, GET_MODE (*tmp->loc)))\n-\t\t\t&& (HARD_REGNO_CALL_PART_CLOBBERED\n-\t\t\t    (new_reg, GET_MODE (*tmp->loc)))))\n-\t\t  break;\n-\t      if (! tmp)\n+\t      bool found = false;\n+\t      /* Now potential_regs is a reasonable approximation, let's\n+\t\t have a closer look at each register still in there.  */\n+\t      for (new_reg = 0; new_reg < FIRST_PSEUDO_REGISTER; new_reg++)\n \t\t{\n-\t\t  if (tick[best_new_reg] > tick[new_reg])\n+\t\t  /* Iterate registers first in prefered class.  */\n+\t\t  if (pass == 0\n+\t\t      && !TEST_HARD_REG_BIT (reg_class_contents[preferred_class],\n+\t\t\t\t\t     new_reg))\n+\t\t    continue;\n+\n+\t\t  if (check_new_reg_p (reg, new_reg, this_head,\n+\t\t\t\t       this_unavailable))\n \t\t    {\n-\t\t      best_new_reg = new_reg;\n-\t\t      best_nregs = nregs;\n+\t\t      if (tick[best_new_reg] > tick[new_reg])\n+\t\t\t{\n+\t\t\t  enum machine_mode mode\n+\t\t\t    = GET_MODE (*this_head->first->loc);\n+\t\t\t  best_new_reg = new_reg;\n+\t\t\t  best_nregs = hard_regno_nregs[new_reg][mode];\n+\t\t\t  /* If we find a new reg in our preferred class,\n+\t\t\t     stop immediately.  */\n+\t\t\t  if (best_new_reg != reg && pass == 0)\n+\t\t\t    {\n+\t\t\t      found = true;\n+\t\t\t      break;\n+\t\t\t    }\n+\t\t\t}\n \t\t    }\n \t\t}\n+\t      if (found)\n+\t\tbreak;\n \t    }\n-\n \t  if (dump_file)\n \t    {\n \t      fprintf (dump_file, \"Register %s in insn %d\",\n@@ -527,6 +732,7 @@ create_new_chain (unsigned this_regno, unsigned this_nregs, rtx *loc,\n   head->need_caller_save_reg = 0;\n   head->cannot_rename = 0;\n   head->terminated = 0;\n+  head->length = 0;\n \n   VEC_safe_push (du_head_p, heap, id_to_chain, head);\n   head->id = current_id++;\n@@ -572,6 +778,8 @@ create_new_chain (unsigned this_regno, unsigned this_nregs, rtx *loc,\n   this_du->loc = loc;\n   this_du->insn = insn;\n   this_du->cl = cl;\n+\n+  head->length = 1;\n }\n \n static void\n@@ -661,6 +869,8 @@ scan_rtx_reg (rtx insn, rtx *loc, enum reg_class cl, enum scan_actions action,\n \t\thead->last->next_use = this_du;\n \t      head->last = this_du;\n \n+\t      if (!DEBUG_INSN_P (insn))\n+\t\thead->length++;\n \t    }\n \t  /* Avoid adding the same location in a DEBUG_INSN multiple times,\n \t     which could happen with non-exact overlap.  */"}, {"sha": "7e4fe123a027d81fc4be42152fe0be1fbdea341a", "filename": "gcc/target.def", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f286f4a1aeb494e84f4134dce04e451b9580d19/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f286f4a1aeb494e84f4134dce04e451b9580d19/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=5f286f4a1aeb494e84f4134dce04e451b9580d19", "patch": "@@ -2224,6 +2224,21 @@ DEFHOOK\n  bool, (reg_class_t rclass),\n  default_class_likely_spilled_p)\n \n+DEFHOOK\n+(preferred_rename_class,\n+ \"A target hook that places additional preference on the register\\\n+ class to use when it is necessary to rename a register in class\\\n+ @var{class} to another class, or perhaps @var{NO_REGS}, if no\\\n+ prefered register class is found or hook @code{preferred_rename_class}\\\n+ is not implemented.\\\n+ Sometimes returning a more restrictive class makes better code.  For\\\n+ example, on ARM, thumb-2 instructions using @code{LO_REGS} may be\\\n+ smaller than instructions using @code{GENERIC_REGS}.  By returning\\\n+ @code{LO_REGS} from @code{preferred_rename_class}, code size can\\\n+ be reduced.\",\n+ reg_class_t, (reg_class_t rclass),\n+ default_preferred_rename_class)\n+\n /* This target hook allows the backend to perform additional\n    processing while initializing for variable expansion.  */\n DEFHOOK"}, {"sha": "0eee5288b6c6d29cdb56d16ee94c653834765259", "filename": "gcc/targhooks.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f286f4a1aeb494e84f4134dce04e451b9580d19/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f286f4a1aeb494e84f4134dce04e451b9580d19/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=5f286f4a1aeb494e84f4134dce04e451b9580d19", "patch": "@@ -1278,6 +1278,13 @@ default_preferred_output_reload_class (rtx x ATTRIBUTE_UNUSED,\n #endif\n }\n \n+/* The default implementation of TARGET_PREFERRED_RENAME_CLASS.  */\n+reg_class_t\n+default_preferred_rename_class (reg_class_t rclass ATTRIBUTE_UNUSED)\n+{\n+  return NO_REGS;\n+}\n+\n /* The default implementation of TARGET_CLASS_LIKELY_SPILLED_P.  */\n \n bool"}, {"sha": "db6f7146b00fcd8cae068e93042068f879797480", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f286f4a1aeb494e84f4134dce04e451b9580d19/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f286f4a1aeb494e84f4134dce04e451b9580d19/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=5f286f4a1aeb494e84f4134dce04e451b9580d19", "patch": "@@ -160,6 +160,7 @@ extern int default_register_move_cost (enum machine_mode, reg_class_t,\n extern bool default_profile_before_prologue (void);\n extern reg_class_t default_preferred_reload_class (rtx, reg_class_t);\n extern reg_class_t default_preferred_output_reload_class (rtx, reg_class_t);\n+extern reg_class_t default_preferred_rename_class (reg_class_t rclass);\n extern bool default_class_likely_spilled_p (reg_class_t);\n \n extern enum unwind_info_type default_debug_unwind_info (void);"}]}