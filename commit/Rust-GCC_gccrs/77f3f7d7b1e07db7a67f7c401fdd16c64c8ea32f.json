{"sha": "77f3f7d7b1e07db7a67f7c401fdd16c64c8ea32f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzdmM2Y3ZDdiMWUwN2RiN2E2N2Y3YzQwMWZkZDE2YzY0YzhlYTMyZg==", "commit": {"author": {"name": "Mark Klein", "email": "mklein@dis.com", "date": "1999-09-07T10:23:53Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-09-07T10:23:53Z"}, "message": "* pa/quadlib.asm: New file for long double support.\n\nFrom-SVN: r29165", "tree": {"sha": "498816ae8c691e2261057fe60f517f42225c754f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/498816ae8c691e2261057fe60f517f42225c754f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/77f3f7d7b1e07db7a67f7c401fdd16c64c8ea32f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77f3f7d7b1e07db7a67f7c401fdd16c64c8ea32f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77f3f7d7b1e07db7a67f7c401fdd16c64c8ea32f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77f3f7d7b1e07db7a67f7c401fdd16c64c8ea32f/comments", "author": {"login": "jazzklein", "id": 6667293, "node_id": "MDQ6VXNlcjY2NjcyOTM=", "avatar_url": "https://avatars.githubusercontent.com/u/6667293?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jazzklein", "html_url": "https://github.com/jazzklein", "followers_url": "https://api.github.com/users/jazzklein/followers", "following_url": "https://api.github.com/users/jazzklein/following{/other_user}", "gists_url": "https://api.github.com/users/jazzklein/gists{/gist_id}", "starred_url": "https://api.github.com/users/jazzklein/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jazzklein/subscriptions", "organizations_url": "https://api.github.com/users/jazzklein/orgs", "repos_url": "https://api.github.com/users/jazzklein/repos", "events_url": "https://api.github.com/users/jazzklein/events{/privacy}", "received_events_url": "https://api.github.com/users/jazzklein/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "afe3d09019946edd8476fa7e7fa965368e8b3904", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afe3d09019946edd8476fa7e7fa965368e8b3904", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afe3d09019946edd8476fa7e7fa965368e8b3904"}], "stats": {"total": 361, "additions": 361, "deletions": 0}, "files": [{"sha": "b65595a3423d0352b5220c42bad381d1a4af0db4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77f3f7d7b1e07db7a67f7c401fdd16c64c8ea32f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77f3f7d7b1e07db7a67f7c401fdd16c64c8ea32f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=77f3f7d7b1e07db7a67f7c401fdd16c64c8ea32f", "patch": "@@ -1,5 +1,7 @@\n Tue Sep  7 03:42:45 1999  Mark Klein (mklein@dis.com)\n \n+\t* pa/quadlib.asm: New file for long double support.\n+\n \t* configure.in: Add hppa1.0-*-mpeix for MPE port.\n \t* configure: Rebuilt.\n "}, {"sha": "11c0b10f30e5d90675c61bdea761a8cbc4d5ddf4", "filename": "gcc/config/pa/quadlib.asm", "status": "added", "additions": 359, "deletions": 0, "changes": 359, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77f3f7d7b1e07db7a67f7c401fdd16c64c8ea32f/gcc%2Fconfig%2Fpa%2Fquadlib.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77f3f7d7b1e07db7a67f7c401fdd16c64c8ea32f/gcc%2Fconfig%2Fpa%2Fquadlib.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fquadlib.asm?ref=77f3f7d7b1e07db7a67f7c401fdd16c64c8ea32f", "patch": "@@ -0,0 +1,359 @@\n+;  Subroutines for long double support on the HPPA\n+;  Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+;  This file is part of GNU CC.\n+\n+;  GNU CC is free software; you can redistribute it and/or modify\n+;  it under the terms of the GNU General Public License as published by\n+;  the Free Software Foundation; either version 2, or (at your option)\n+;  any later version.\n+\n+;  GNU CC is distributed in the hope that it will be useful,\n+;  but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;  GNU General Public License for more details.\n+\n+; In addition to the permissions in the GNU General Public License, the\n+; Free Software Foundation gives you unlimited permission to link the\n+; compiled version of this file with other programs, and to distribute\n+; those programs without any restriction coming from the use of this\n+; file.  (The General Public License restrictions do apply in other\n+; respects; for example, they cover modification of the file, and\n+; distribution when not linked into another program.)\n+\n+;  You should have received a copy of the GNU General Public License\n+;  along with GNU CC; see the file COPYING.  If not, write to\n+;  the Free Software Foundation, 59 Temple Place - Suite 330,\n+;  Boston, MA 02111-1307, USA.\n+\n+\t.SPACE $TEXT$\n+\t.SUBSPA $CODE$,QUAD=0,ALIGN=8,ACCESS=44,CODE_ONLY\n+\t.compiler \"quadlib.asm GNU_PA-RISC_Assembler 2.9.4\"\n+\t.IMPORT _U_Qfcmp,CODE\n+\t.IMPORT _U_Qfsub,CODE\n+\n+\t.align 4\n+\t.NSUBSPA $CODE$,QUAD=0,ALIGN=8,ACCESS=44,CODE_ONLY\n+\t;\n+\t; Check two long doubles for equality\n+\t;\n+\t.EXPORT _U_Qfeq,ENTRY,PRIV_LEV=3,ARGW0=GR,ARGW1=GR,RTNVAL=GR\n+_U_Qfeq\n+\t.PROC\n+\t.CALLINFO FRAME=64,CALLS,SAVE_RP\n+\t.ENTRY\n+\t;\n+\t; Build the frame\n+\t;\n+\tstw %r2,-20(0,%r30)\n+\tldo 64(%r30),%r30\n+\n+\t;\n+\t; Load the additional argument and call the comparison routine.\n+\t;\n+\tbl _U_Qfcmp,%r2\n+\t  ldi 4,%r24\n+\n+\t;\n+\t; The return from _U_Qfcmp is the masked C bit from the FP\n+\t; status register. Convert that to a 0 or 1.\n+\t;\n+\tcomiclr,= 0,%r28,%r28\n+\t  ldi 1,%r28\n+\n+\t;\n+\t; Return\n+\t;\n+\tldw -84(0,%r30),%r2\n+\tbv 0(%r2)\n+\t  ldo -64(%r30), %r30\n+\n+\t.EXIT\n+\t.PROCEND\n+\n+\t;\n+\t; Check two long doubles for inequality\n+\t;\n+\t.EXPORT _U_Qfne,ENTRY,PRIV_LEV=3,ARGW0=GR,ARGW1=GR,RTNVAL=GR\n+_U_Qfne\n+\t.PROC\n+\t.CALLINFO FRAME=64,CALLS,SAVE_RP\n+\t.ENTRY\n+\t;\n+\t; Build the frame\n+\t;\n+\tstw %r2,-20(0,%r30)\n+\tldo 64(%r30),%r30\n+\n+\t;\n+\t; Load the additional argument and call the comparison routine.\n+\t;\n+\tbl _U_Qfcmp,%r2\n+\tldi 4,%r24\n+\t\n+\t;\n+\t; The return from _U_Qfcmp is the masked C bit from the FP\n+\t; status register. Convert that to a 0 or 1.\n+\t;\n+\tcomiclr,<> 0,%r28,%r28\n+\t  ldi 1,%r28\n+\n+\t;\n+\t; Return\n+\t;\n+\tldw -84(0,%r30),%r2\n+\tbv 0(%r2)\n+\t  ldo -64(%r30),%r30\n+\t.EXIT\n+\t.PROCEND\n+\n+\t;\n+\t; Check if opnd1 > opnd0                \n+\t;\n+\t.EXPORT _U_Qfgt,ENTRY,PRIV_LEV=3,ARGW0=GR,ARGW1=GR,RTNVAL=GR\n+_U_Qfgt\n+\t.PROC\n+\t.CALLINFO FRAME=64,CALLS,SAVE_RP\n+\t.ENTRY\n+\t;\n+\t; Build the frame\n+\t;\n+\tstw %r2,-20(0,%r30)\n+\tldo 64(%r30),%r30\n+\n+\t;\n+\t; Load the additional argument and call the comparison routine.\n+\t;\n+\tbl _U_Qfcmp,%r2\n+\tldi 23,%r24\n+\n+\t;\n+\t; The return from _U_Qfcmp is the masked C bit from the FP\n+\t; status register. Convert that to a 0 or 1.\n+\t;\n+\tcomiclr,= 0,%r28,%r28\n+\t  ldi 1,%r28\n+\n+\t;\n+\t; Return\n+\t;\n+\tldw -84(0,%r30),%r2\n+\tbv 0(%r2)\n+\t  ldo -64(%r30), %r30\n+\n+\t.EXIT\n+\t.PROCEND\n+\n+\t;\n+\t; Check if opnd1 >= opnd0                \n+\t;\n+\t.EXPORT _U_Qfge,ENTRY,PRIV_LEV=3,ARGW0=GR,ARGW1=GR,RTNVAL=GR\n+_U_Qfge\n+\t.PROC\n+\t.CALLINFO FRAME=64,CALLS,SAVE_RP\n+\t.ENTRY\n+\t;\n+\t; Build the frame\n+\t;\n+\tstw %r2,-20(0,%r30)\n+\tldo 64(%r30),%r30\n+\n+\t;\n+\t; Load the additional argument and call the comparison routine.\n+\t;\n+\tbl _U_Qfcmp,%r2\n+\tldi 23,%r24\n+\n+\t;\n+\t; The return from _U_Qfcmp is the masked C bit from the FP\n+\t; status register. Convert that to a 0 or 1.\n+\t;\n+\tcomiclr,= 0,%r28,%r28\n+\t  ldi 1,%r28\n+\n+\t;\n+\t; Return\n+\t;\n+\tldw -84(0,%r30),%r2\n+\tbv 0(%r2)\n+\t  ldo -64(%r30), %r30\n+\n+\t.EXIT\n+\t.PROCEND\n+\n+\t;\n+\t; Check if opnd1 < opnd0                \n+\t;\n+\t.EXPORT _U_Qflt,ENTRY,PRIV_LEV=3,ARGW0=GR,ARGW1=GR,RTNVAL=GR\n+_U_Qflt\n+\t.PROC\n+\t.CALLINFO FRAME=64,CALLS,SAVE_RP\n+\t.ENTRY\n+\t;\n+\t; Build the frame\n+\t;\n+\tstw %r2,-20(0,%r30)\n+\tldo 64(%r30),%r30\n+\n+\t;\n+\t; Load the additional argument and call the comparison routine.\n+\t;\n+\tbl _U_Qfcmp,%r2\n+\tldi 9,%r24\n+\n+\t;\n+\t; The return from _U_Qfcmp is the masked C bit from the FP\n+\t; status register. Convert that to a 0 or 1.\n+\t;\n+\tcomiclr,= 0,%r28,%r28\n+\t  ldi 1,%r28\n+\n+\t;\n+\t; Return\n+\t;\n+\tldw -84(0,%r30),%r2\n+\tbv 0(%r2)\n+\t  ldo -64(%r30), %r30\n+\n+\t.EXIT\n+\t.PROCEND\n+\n+\t;\n+\t; Check if opnd1 <= opnd0                \n+\t;\n+\t.EXPORT _U_Qfle,ENTRY,PRIV_LEV=3,ARGW0=GR,ARGW1=GR,RTNVAL=GR\n+_U_Qfle\n+\t.PROC\n+\t.CALLINFO FRAME=64,CALLS,SAVE_RP\n+\t.ENTRY\n+\t;\n+\t; Build the frame\n+\t;\n+\tstw %r2,-20(0,%r30)\n+\tldo 64(%r30),%r30\n+\n+\t;\n+\t; Load the additional argument and call the comparison routine.\n+\t;\n+\tbl _U_Qfcmp,%r2\n+\tldi 13,%r24\n+\n+\t;\n+\t; The return from _U_Qfcmp is the masked C bit from the FP\n+\t; status register. Convert that to a 0 or 1.\n+\t;\n+\tcomiclr,= 0,%r28,%r28\n+\t  ldi 1,%r28\n+\n+\t;\n+\t; Return\n+\t;\n+\tldw -84(0,%r30),%r2\n+\tbv 0(%r2)\n+\t  ldo -64(%r30), %r30\n+\n+\t.EXIT\n+\t.PROCEND\n+\n+\t;\n+\t; Negate opnd0 and store in ret0                 \n+\t;\n+\t.EXPORT _U_Qfneg,ENTRY,PRIV_LEV=3,ARGW0=GR,RTNVAL=GR\n+_U_Qfneg\n+\t.PROC\n+\t.CALLINFO FRAME=128,CALLS,SAVE_RP\n+\t.ENTRY\n+\t;\n+\t; Build the frame\n+\t;\n+\tstw %r2,-20(0,%r30)\n+\tldo 128(%r30),%r30\n+\n+\t;\n+\t; copy the value to be negated to the frame.\n+\t;\n+\tldw 0(0,%r26), %r25\n+\tldw 4(0,%r26), %r24\n+\tldw 8(0,%r26), %r23\n+\tldw 12(0,%r26),%r1\n+\tstw %r25, -100(0,%r30)\n+\tstw %r24,  -96(0,%r30)\n+\tstw %r23,  -92(0,%r30)\n+\tstw %r1,   -88(0,%r30)\n+\tldo -100(%r30), %r25\n+\n+\t;\n+\t; ret0 contains a pointer to the location for the return\n+\t; value. Initialize it to zero and pass it as arg0 to\n+\t; _U_Qfsub.\n+\t;\n+\tcopy %r28,%r26\n+\tstw %r0,0(0,%r26)\n+\tstw %r0,4(0,%r26)\n+\tstw %r0,8(0,%r26)\n+\tbl _U_Qfsub,%r2\n+\t  stw %r0,12(0,%r26)\n+\n+\t;\n+\t; Return\n+\t;\n+\tldw -148(0,%r30),%r2\n+\tbv 0(%r2)\n+\t  ldo -128(%r30), %r30\n+\n+\t.EXIT\n+\t.PROCEND\n+\n+\t;\n+\t; Compare opnd0 and opnd1. If opnd0 == opnd1, return 0.\n+\t; If opnd0 is greater than opnd1, return 1.\n+\t; Otherwise, return -1.\n+\t;\n+\t.EXPORT _U_Qfcomp,ENTRY,PRIV_LEV=3,ARGW0=GR,ARGW1=GR,RTNVAL=GR\n+_U_Qfcomp\n+\t.PROC\n+\t.CALLINFO FRAME=64,CALLS,SAVE_RP\n+\t.ENTRY\n+\t;\n+\t; Build the frame\n+\t;\n+\tstw %r2,-20(0,%r30)\n+\tldo 64(%r30),%r30\n+\n+\t;\n+\t; Save arg0 and arg1.\n+\t;\n+\tstw %r26, -60(0,%r30)\n+\tstw %r25, -56(0,%r30)\n+\t;\n+\t; Check for equality\n+\t;\n+\tbl _U_Qfcmp,%r2\n+\t  ldi 4, %r24\n+\n+\tcomib,<> 0,%r28,done\n+\t  copy %r0, %r1\n+\n+\t;\n+\t; Reset the parms and test for opnd0 > opnd1.\n+\t;\n+\tldw -60(0,%r30),%r26\n+\tldw -56(0,%r30),%r25\n+\tbl _U_Qfcmp,%r2\n+\t  ldi 22,%r24\n+\n+\tldi 1,%r1\n+\tcomiclr,<> 0,%r28,0\n+\t  ldi -1,%r1\n+\n+done\n+\tcopy %r1,%r28\n+\t;\n+\t; Return\n+\t;\n+\tldw -84(0,%r30),%r2\n+\tbv 0(%r2)\n+\t  ldo -64(%r30), %r30\n+\n+\t.EXIT\n+\t.PROCEND"}]}