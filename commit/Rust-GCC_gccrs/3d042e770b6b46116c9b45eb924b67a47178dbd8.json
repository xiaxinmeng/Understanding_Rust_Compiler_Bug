{"sha": "3d042e770b6b46116c9b45eb924b67a47178dbd8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2QwNDJlNzcwYjZiNDYxMTZjOWI0NWViOTI0YjY3YTQ3MTc4ZGJkOA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2003-01-17T03:28:11Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2003-01-17T03:28:11Z"}, "message": "ifcvt.c: Fix comment typos.\n\n\t* ifcvt.c: Fix comment typos.\n\t* lcm.c: Likewise.\n\t* libgcc2.c: Likewise.\n\t* local-alloc.c: Likewise.\n\t* loop.c: Likewise.\n\t* predict.c: Likewise.\n\t* ra-build.c: Likewise.\n\t* ra.c: Likewise.\n\t* ra-colorize.c: Likewise.\n\t* ra.h: Likewise.\n\t* ra-rewrite.c: Likewise.\n\t* regmove.c: Likewise.\n\t* reload.h: Likewise.\n\t* rtlanal.c: Likewise.\n\t* toplev.c: Likewise.\n\t* tree.h: Likewise.\n\t* unwind-dw2-fde-glibc.c: Likewise.\n\t* vmsdbgout.c: Likewise.\n\nFrom-SVN: r61421", "tree": {"sha": "6c402772c72ac7d22890da53e8d0a4884be43356", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c402772c72ac7d22890da53e8d0a4884be43356"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d042e770b6b46116c9b45eb924b67a47178dbd8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d042e770b6b46116c9b45eb924b67a47178dbd8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d042e770b6b46116c9b45eb924b67a47178dbd8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d042e770b6b46116c9b45eb924b67a47178dbd8/comments", "author": null, "committer": null, "parents": [{"sha": "fd2190ca49b7db1f14cfddd3232cd378e995eebb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd2190ca49b7db1f14cfddd3232cd378e995eebb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd2190ca49b7db1f14cfddd3232cd378e995eebb"}], "stats": {"total": 93, "additions": 57, "deletions": 36}, "files": [{"sha": "cff6712fe0b6dd45c3e657a1b7e6fcfca3ce3ded", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d042e770b6b46116c9b45eb924b67a47178dbd8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d042e770b6b46116c9b45eb924b67a47178dbd8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3d042e770b6b46116c9b45eb924b67a47178dbd8", "patch": "@@ -1,3 +1,24 @@\n+2003-01-16  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* ifcvt.c: Fix comment typos.\n+\t* lcm.c: Likewise.\n+\t* libgcc2.c: Likewise.\n+\t* local-alloc.c: Likewise.\n+\t* loop.c: Likewise.\n+\t* predict.c: Likewise.\n+\t* ra-build.c: Likewise.\n+\t* ra.c: Likewise.\n+\t* ra-colorize.c: Likewise.\n+\t* ra.h: Likewise.\n+\t* ra-rewrite.c: Likewise.\n+\t* regmove.c: Likewise.\n+\t* reload.h: Likewise.\n+\t* rtlanal.c: Likewise.\n+\t* toplev.c: Likewise.\n+\t* tree.h: Likewise.\n+\t* unwind-dw2-fde-glibc.c: Likewise.\n+\t* vmsdbgout.c: Likewise.\n+\n 2003-01-16  Richard Henderson  <rth@redhat.com>\n \n \t* dwarf2out.c (struct file_table): Remove."}, {"sha": "72dc2e12f6584d2f1500b5e46bb20c48c156246e", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d042e770b6b46116c9b45eb924b67a47178dbd8/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d042e770b6b46116c9b45eb924b67a47178dbd8/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=3d042e770b6b46116c9b45eb924b67a47178dbd8", "patch": "@@ -2282,7 +2282,7 @@ find_if_block (ce_info)\n       int max_insns = MAX_CONDITIONAL_EXECUTE;\n       int n_insns;\n \n-      /* Determine if the preceeding block is an && or || block.  */\n+      /* Determine if the preceding block is an && or || block.  */\n       if ((n_insns = block_jumps_and_fallthru_p (bb, else_bb)) >= 0)\n \t{\n \t  ce_info->and_and_p = TRUE;\n@@ -2877,7 +2877,7 @@ dead_or_predicable (test_bb, merge_bb, other_bb, new_dest, reversep)\n   if (HAVE_conditional_execution)\n     {\n       /* In the conditional execution case, we have things easy.  We know\n-\t the condition is reversable.  We don't have to check life info,\n+\t the condition is reversible.  We don't have to check life info,\n \t becase we're going to conditionally execute the code anyway.\n \t All that's left is making sure the insns involved can actually\n \t be predicated.  */"}, {"sha": "8bbe893c82386eaa6c1e849d7dc2a6d207e24ea4", "filename": "gcc/lcm.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d042e770b6b46116c9b45eb924b67a47178dbd8/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d042e770b6b46116c9b45eb924b67a47178dbd8/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=3d042e770b6b46116c9b45eb924b67a47178dbd8", "patch": "@@ -307,7 +307,7 @@ compute_laterin (edge_list, earliest, antloc, later, laterin)\n   qin = worklist;\n   /* Note that we do not use the last allocated element for our queue,\n      as EXIT_BLOCK is never inserted into it. In fact the above allocation\n-     of n_basic_blocks + 1 elements is not encessary.  */\n+     of n_basic_blocks + 1 elements is not necessary.  */\n   qend = &worklist[n_basic_blocks];\n   qlen = n_basic_blocks;\n \n@@ -849,9 +849,9 @@ pre_edge_rev_lcm (file, n_exprs, transp, st_avloc, st_antloc, kill,\n \n    The LCM algorithm is then run over the flow graph to determine where to\n    place the sets to the highest-priority value in respect of first the first\n-   insn in any one block.  Any adjustments required to the transparancy\n+   insn in any one block.  Any adjustments required to the transparency\n    vectors are made, then the next iteration starts for the next-lower\n-   priority mode, till for each entity all modes are exhasted.\n+   priority mode, till for each entity all modes are exhausted.\n \n    More details are located in the code for optimize_mode_switching().  */\n "}, {"sha": "6867c0d1430e17a3a6ab8ccc41fc3b6e830bfb1d", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d042e770b6b46116c9b45eb924b67a47178dbd8/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d042e770b6b46116c9b45eb924b67a47178dbd8/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=3d042e770b6b46116c9b45eb924b67a47178dbd8", "patch": "@@ -234,7 +234,7 @@ __mulvdi3 (DWtype u, DWtype v)\n #endif\n \f\n \n-/* Unless shift functions are defined whith full ANSI prototypes,\n+/* Unless shift functions are defined with full ANSI prototypes,\n    parameter b will be promoted to int if word_type is smaller than an int.  */\n #ifdef L_lshrdi3\n DWtype\n@@ -1347,7 +1347,7 @@ gcov_exit (void)\n \n #if defined (TARGET_HAS_F_SETLKW)\n       /* After a fork, another process might try to read and/or write\n-         the same file simultanously.  So if we can, lock the file to\n+         the same file simultaneously.  So if we can, lock the file to\n          avoid race conditions.  */\n       while (fcntl (fileno (da_file), F_SETLKW, &s_flock)\n \t     && errno == EINTR)"}, {"sha": "2e91ae1b8d0d4385c447177e8f05db98eb43e01d", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d042e770b6b46116c9b45eb924b67a47178dbd8/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d042e770b6b46116c9b45eb924b67a47178dbd8/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=3d042e770b6b46116c9b45eb924b67a47178dbd8", "patch": "@@ -1179,7 +1179,7 @@ update_equiv_regs ()\n }\n \n /* Mark REG as having no known equivalence.\n-   Some instructions might have been proceessed before and furnished\n+   Some instructions might have been processed before and furnished\n    with REG_EQUIV notes for this register; these notes will have to be\n    removed.\n    STORE is the piece of RTL that does the non-constant / conflicting\n@@ -1327,7 +1327,7 @@ block_alloc (b)\n \t\t     must match operand zero.  In that case, skip any\n \t\t     operand that doesn't list operand 0 since we know that\n \t\t     the operand always conflicts with operand 0.  We\n-\t\t     ignore commutatity in this case to keep things simple.  */\n+\t\t     ignore commutativity in this case to keep things simple.  */\n \t\t  if (n_matching_alts == recog_data.n_alternatives\n \t\t      && 0 == requires_inout (recog_data.constraints[i]))\n \t\t    continue;"}, {"sha": "55c2c42b78b8bf0444affb0b13dfa14928813d65", "filename": "gcc/loop.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d042e770b6b46116c9b45eb924b67a47178dbd8/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d042e770b6b46116c9b45eb924b67a47178dbd8/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=3d042e770b6b46116c9b45eb924b67a47178dbd8", "patch": "@@ -82,7 +82,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define PREFETCH_BLOCKS_BEFORE_LOOP_MIN  2\n \n /* Parameterize some prefetch heuristics so they can be turned on and off\n-   easily for performance testing on new architecures.  These can be\n+   easily for performance testing on new architectures.  These can be\n    defined in target-dependent files.  */\n \n /* Prefetch is worthwhile only when loads/stores are dense.  */\n@@ -793,7 +793,7 @@ scan_loop (loop, flags)\n \t\t    }\n \t\t}\n \n-\t      /* For parallels, add any possible uses to the depencies, as\n+\t      /* For parallels, add any possible uses to the dependencies, as\n \t\t we can't move the insn without resolving them first.  */\n \t      if (GET_CODE (PATTERN (p)) == PARALLEL)\n \t\t{\n@@ -3620,7 +3620,7 @@ check_store (x, pat, data)\n \f\n /* Like rtx_equal_p, but attempts to swap commutative operands.  This is\n    important to get some addresses combined.  Later more sophisticated\n-   transformations can be added when necesary.\n+   transformations can be added when necessary.\n \n    ??? Same trick with swapping operand is done at several other places.\n    It can be nice to develop some common way to handle this.  */\n@@ -5537,7 +5537,7 @@ valid_initial_value_p (x, insn, call_seen, loop_start)\n    as a possible giv.  INSN is the insn whose pattern X comes from.\n    NOT_EVERY_ITERATION is 1 if the insn might not be executed during\n    every loop iteration.  MAYBE_MULTIPLE is 1 if the insn might be executed\n-   more thanonce in each loop iteration.  */\n+   more than once in each loop iteration.  */\n \n static void\n find_mem_givs (loop, x, insn, not_every_iteration, maybe_multiple)\n@@ -5742,7 +5742,7 @@ record_giv (loop, v, insn, src_reg, dest_reg, mult_val, add_val, ext_val,\n   rtx set = single_set (insn);\n   rtx temp;\n \n-  /* Attempt to prove constantness of the values.  Don't let simplity_rtx\n+  /* Attempt to prove constantness of the values.  Don't let simplify_rtx\n      undo the MULT canonicalization that we performed earlier.  */\n   temp = simplify_rtx (add_val);\n   if (temp\n@@ -6686,7 +6686,7 @@ simplify_giv_expr (loop, x, ext_val, benefit)\n \t\t\t\t\t\t\t\t    arg1)),\n \t\t\t\t\text_val, benefit);\n \t    }\n-\t  /* Porpagate the MULT expressions to the intermost nodes.  */\n+\t  /* Propagate the MULT expressions to the intermost nodes.  */\n \t  else if (GET_CODE (arg0) == PLUS)\n \t    {\n \t      /* (invar_0 + invar_1) * invar_2.  Distribute.  */\n@@ -7372,7 +7372,7 @@ check_ext_dependent_givs (bl, loop_info)\n      constants in order to be certain of no overflow.  */\n   /* ??? An unknown iteration count with an increment of +-1\n      combined with friendly exit tests of against an invariant\n-     value is also ameanable to optimization.  Not implemented.  */\n+     value is also amenable to optimization.  Not implemented.  */\n   if (loop_info->n_iterations > 0\n       && bl->initial_value\n       && GET_CODE (bl->initial_value) == CONST_INT\n@@ -7394,7 +7394,7 @@ check_ext_dependent_givs (bl, loop_info)\n \tneg_incr = 1, abs_incr = -abs_incr;\n       total_incr = abs_incr * loop_info->n_iterations;\n \n-      /* Check for host arithmatic overflow.  */\n+      /* Check for host arithmetic overflow.  */\n       if (total_incr / loop_info->n_iterations == abs_incr)\n \t{\n \t  unsigned HOST_WIDE_INT u_max;\n@@ -7407,7 +7407,7 @@ check_ext_dependent_givs (bl, loop_info)\n \n \t  /* Check zero extension of biv ok.  */\n \t  if (start_val >= 0\n-\t      /* Check for host arithmatic overflow.  */\n+\t      /* Check for host arithmetic overflow.  */\n \t      && (neg_incr\n \t\t  ? u_end_val < u_start_val\n \t\t  : u_end_val > u_start_val)\n@@ -7425,7 +7425,7 @@ check_ext_dependent_givs (bl, loop_info)\n \t     keep this fact in mind -- myself included on occasion.\n \t     So leave alone with the signed overflow optimizations.  */\n \t  if (start_val >= -s_max - 1\n-\t      /* Check for host arithmatic overflow.  */\n+\t      /* Check for host arithmetic overflow.  */\n \t      && (neg_incr\n \t\t  ? s_end_val < start_val\n \t\t  : s_end_val > start_val)\n@@ -10541,7 +10541,7 @@ loop_insn_sink (loop, pattern)\n }\n \n /* bl->final_value can be eighter general_operand or PLUS of general_operand\n-   and constant.  Emit sequence of intructions to load it into REG  */\n+   and constant.  Emit sequence of instructions to load it into REG.  */\n static rtx\n gen_load_of_final_value (reg, final_value)\n      rtx reg, final_value;"}, {"sha": "71009faafdbfb5929a85a564964b457b163b49a3", "filename": "gcc/predict.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d042e770b6b46116c9b45eb924b67a47178dbd8/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d042e770b6b46116c9b45eb924b67a47178dbd8/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=3d042e770b6b46116c9b45eb924b67a47178dbd8", "patch": "@@ -570,7 +570,7 @@ estimate_probability (loops_info)\n \t    if (FLOAT_MODE_P (GET_MODE (XEXP (cond, 0))))\n \t      ;\n \t    /* Comparisons with 0 are often used for booleans and there is\n-\t       nothing usefull to predict about them.  */\n+\t       nothing useful to predict about them.  */\n \t    else if (XEXP (cond, 1) == const0_rtx\n \t\t     || XEXP (cond, 0) == const0_rtx)\n \t      ;\n@@ -586,7 +586,7 @@ estimate_probability (loops_info)\n \t    if (FLOAT_MODE_P (GET_MODE (XEXP (cond, 0))))\n \t      ;\n \t    /* Comparisons with 0 are often used for booleans and there is\n-\t       nothing usefull to predict about them.  */\n+\t       nothing useful to predict about them.  */\n \t    else if (XEXP (cond, 1) == const0_rtx\n \t\t     || XEXP (cond, 0) == const0_rtx)\n \t      ;"}, {"sha": "d5d923eba027c148a7ef61565297c3ce303d40e6", "filename": "gcc/ra-build.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d042e770b6b46116c9b45eb924b67a47178dbd8/gcc%2Fra-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d042e770b6b46116c9b45eb924b67a47178dbd8/gcc%2Fra-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-build.c?ref=3d042e770b6b46116c9b45eb924b67a47178dbd8", "patch": "@@ -2653,7 +2653,7 @@ detect_remat_webs ()\n \t\t  oldwebs can't have their references changed.  The\n \t\t  incremental machinery barfs on that.  */\n \t       || (!rtx_unstable_p (src) && !contains_pseudo (src))\n-\t       /* Additionally also memrefs to stack-slots are usefull, when\n+\t       /* Additionally also memrefs to stack-slots are useful, when\n \t\t  we created them ourself.  They might not have set their\n \t\t  unchanging flag set, but nevertheless they are stable across\n \t\t  the livetime in question.  */"}, {"sha": "074f7356dac95b4e2b9a54c931a3b6ccedaa1fd9", "filename": "gcc/ra-colorize.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d042e770b6b46116c9b45eb924b67a47178dbd8/gcc%2Fra-colorize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d042e770b6b46116c9b45eb924b67a47178dbd8/gcc%2Fra-colorize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-colorize.c?ref=3d042e770b6b46116c9b45eb924b67a47178dbd8", "patch": "@@ -1511,7 +1511,7 @@ colorize_one_web (web, hard)\n \t      struct web *aw = alias (w);\n \t      /* If we are a spill-temp, we also look at webs coalesced\n \t\t to precolored ones.  Otherwise we only look at webs which\n-\t\t themself were colored, or coalesced to one.  */\n+\t\t themselves were colored, or coalesced to one.  */\n \t      if (aw->type == PRECOLORED && w != aw && web->spill_temp\n \t\t  && flag_ra_optimistic_coalescing)\n \t\t{"}, {"sha": "22381967d7198f8a1a299c935518e8452b560071", "filename": "gcc/ra-rewrite.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d042e770b6b46116c9b45eb924b67a47178dbd8/gcc%2Fra-rewrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d042e770b6b46116c9b45eb924b67a47178dbd8/gcc%2Fra-rewrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-rewrite.c?ref=3d042e770b6b46116c9b45eb924b67a47178dbd8", "patch": "@@ -1489,7 +1489,7 @@ detect_web_parts_to_rebuild ()\n   sbitmap_zero (already_webs);\n   /* We need to recheck all uses of all webs involved in spilling (and the\n      uses added by spill insns, but those are not analyzed yet).\n-     Those are the spilled webs themself, webs coalesced to spilled ones,\n+     Those are the spilled webs themselves, webs coalesced to spilled ones,\n      and webs conflicting with any of them.  */\n   for (pass = 0; pass < 2; pass++)\n     for (d = (pass == 0) ? WEBS(SPILLED) : WEBS(COALESCED); d; d = d->next)"}, {"sha": "dfd4ef5b519cee3e9f040f377a0a2ea3bc0c108f", "filename": "gcc/ra.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d042e770b6b46116c9b45eb924b67a47178dbd8/gcc%2Fra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d042e770b6b46116c9b45eb924b67a47178dbd8/gcc%2Fra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra.c?ref=3d042e770b6b46116c9b45eb924b67a47178dbd8", "patch": "@@ -681,7 +681,7 @@ reg_alloc ()\n   /* Setup debugging levels.  */\n   switch (0)\n     {\n-      /* Some usefull presets of the debug level, I often use.  */\n+      /* Some useful presets of the debug level, I often use.  */\n       case 0: debug_new_regalloc = DUMP_EVER; break;\n       case 1: debug_new_regalloc = DUMP_COSTS; break;\n       case 2: debug_new_regalloc = DUMP_IGRAPH_M; break;\n@@ -807,7 +807,7 @@ reg_alloc ()\n \t  /* Those new pseudos need to have their REFS count set.  */\n \t  reg_scan_update (get_insns (), NULL, max_regno);\n \t  max_regno = max_reg_num ();\n-\t  /* And they need usefull classes too.  */\n+\t  /* And they need useful classes too.  */\n \t  regclass (get_insns (), max_reg_num (), rtl_dump_file);\n \t  rtl_dump_file = ra_dump_file;\n "}, {"sha": "522b77a758647f3718e2ba1430302aa1f296548e", "filename": "gcc/ra.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d042e770b6b46116c9b45eb924b67a47178dbd8/gcc%2Fra.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d042e770b6b46116c9b45eb924b67a47178dbd8/gcc%2Fra.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra.h?ref=3d042e770b6b46116c9b45eb924b67a47178dbd8", "patch": "@@ -258,7 +258,7 @@ struct web\n   /* Number of usable colors in usable_regs.  */\n   int num_freedom;\n \n-  /* After successfull coloring the graph each web gets a new reg rtx,\n+  /* After successful coloring the graph each web gets a new reg rtx,\n      with which the original uses and defs are replaced.  This is it.  */\n   rtx reg_rtx;\n "}, {"sha": "3553a40bc3a418cb7c302742b2c0441162fd42c7", "filename": "gcc/regmove.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d042e770b6b46116c9b45eb924b67a47178dbd8/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d042e770b6b46116c9b45eb924b67a47178dbd8/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=3d042e770b6b46116c9b45eb924b67a47178dbd8", "patch": "@@ -647,7 +647,7 @@ optimize_reg_copy_2 (insn, dest, src)\n }\n /* INSN is a ZERO_EXTEND or SIGN_EXTEND of SRC to DEST.\n    Look if SRC dies there, and if it is only set once, by loading\n-   it from memory.  If so, try to encorporate the zero/sign extension\n+   it from memory.  If so, try to incorporate the zero/sign extension\n    into the memory read, change SRC to the mode of DEST, and alter\n    the remaining accesses to use the appropriate SUBREG.  This allows\n    SRC and DEST to be tied later.  */"}, {"sha": "adc2984c0b36850766c3ac0fee70fe3932b173b5", "filename": "gcc/reload.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d042e770b6b46116c9b45eb924b67a47178dbd8/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d042e770b6b46116c9b45eb924b67a47178dbd8/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=3d042e770b6b46116c9b45eb924b67a47178dbd8", "patch": "@@ -269,8 +269,8 @@ extern void transfer_replacements PARAMS ((int, int));\n \n /* IN_RTX is the value loaded by a reload that we now decided to inherit,\n    or a subpart of it.  If we have any replacements registered for IN_RTX,\n-   chancel the reloads that were supposed to load them.\n-   Return nonzero if we chanceled any reloads.  */\n+   cancel the reloads that were supposed to load them.\n+   Return nonzero if we canceled any reloads.  */\n extern int remove_address_replacements PARAMS ((rtx in_rtx));\n \n /* Like rtx_equal_p except that it allows a REG and a SUBREG to match"}, {"sha": "5e0677066a8756c1fb96e878410141418855efdb", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d042e770b6b46116c9b45eb924b67a47178dbd8/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d042e770b6b46116c9b45eb924b67a47178dbd8/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=3d042e770b6b46116c9b45eb924b67a47178dbd8", "patch": "@@ -3420,7 +3420,7 @@ hoist_test_store (x, val, live)\n   /* Pseudo registers can be allways replaced by another pseudo to avoid\n      the side effect, for hard register we must ensure that they are dead.\n      Eventually we may want to add code to try turn pseudos to hards, but it\n-     is unlikely usefull.  */\n+     is unlikely useful.  */\n \n   if (REGNO (x) < FIRST_PSEUDO_REGISTER)\n     {"}, {"sha": "80ddd8eb42c6ada113854199d57655eceecd5d00", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d042e770b6b46116c9b45eb924b67a47178dbd8/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d042e770b6b46116c9b45eb924b67a47178dbd8/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=3d042e770b6b46116c9b45eb924b67a47178dbd8", "patch": "@@ -3150,7 +3150,7 @@ rest_of_compilation (decl)\n \t= combine_instructions (insns, max_reg_num ());\n \n       /* Combining insns may have turned an indirect jump into a\n-\t direct jump.  Rebuid the JUMP_LABEL fields of jumping\n+\t direct jump.  Rebuild the JUMP_LABEL fields of jumping\n \t instructions.  */\n       if (rebuild_jump_labels_after_combine)\n \t{"}, {"sha": "212cfa427c704055058abcf96bf207ce589cf1c3", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d042e770b6b46116c9b45eb924b67a47178dbd8/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d042e770b6b46116c9b45eb924b67a47178dbd8/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=3d042e770b6b46116c9b45eb924b67a47178dbd8", "patch": "@@ -682,7 +682,7 @@ extern void tree_vec_elt_check_failed PARAMS ((int, int, const char *,\n    bounded pointer.  It is insufficient to determine the boundedness\n    of an expression EXP with BOUNDED_POINTER_TYPE_P (TREE_TYPE (EXP)),\n    since we allow pointer to be temporarily cast to integer for\n-   rounding up to an alignment boudary in a way that preserves the\n+   rounding up to an alignment boundary in a way that preserves the\n    pointer's bounds.\n \n    In an IDENTIFIER_NODE, nonzero means that the name is prefixed with"}, {"sha": "d4b62349fca9507abbb82588ca9732268e639b96", "filename": "gcc/unwind-dw2-fde-glibc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d042e770b6b46116c9b45eb924b67a47178dbd8/gcc%2Funwind-dw2-fde-glibc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d042e770b6b46116c9b45eb924b67a47178dbd8/gcc%2Funwind-dw2-fde-glibc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-dw2-fde-glibc.c?ref=3d042e770b6b46116c9b45eb924b67a47178dbd8", "patch": "@@ -155,7 +155,7 @@ _Unwind_IteratePhdrCallback (struct dl_phdr_info *info, size_t size, void *ptr)\n   data->dbase = NULL;\n   if (p_dynamic)\n     {\n-      /* For dynamicly linked executables and shared libraries,\n+      /* For dynamically linked executables and shared libraries,\n \t DT_PLTGOT is the gp value for that object.  */\n       ElfW(Dyn) *dyn = (ElfW(Dyn) *) (p_dynamic->p_vaddr + load_base);\n       for (; dyn->d_tag != DT_NULL ; dyn++)"}, {"sha": "a5cb8a2524d3a58a39434e1bbffd54c64491763f", "filename": "gcc/vmsdbgout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d042e770b6b46116c9b45eb924b67a47178dbd8/gcc%2Fvmsdbgout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d042e770b6b46116c9b45eb924b67a47178dbd8/gcc%2Fvmsdbgout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvmsdbgout.c?ref=3d042e770b6b46116c9b45eb924b67a47178dbd8", "patch": "@@ -352,7 +352,7 @@ static char text_end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n #endif\n \n /* This is similar to the default ASM_OUTPUT_ASCII, except that no trailing\n-   newline is produced.  When flag_verbose_asm is asserted, we add commnetary\n+   newline is produced.  When flag_verbose_asm is asserted, we add commentary\n    at the end of the line, so we must avoid output of a newline here.  */\n #ifndef ASM_OUTPUT_DEBUG_STRING\n #define ASM_OUTPUT_DEBUG_STRING(FILE,P)\t\t\\"}]}