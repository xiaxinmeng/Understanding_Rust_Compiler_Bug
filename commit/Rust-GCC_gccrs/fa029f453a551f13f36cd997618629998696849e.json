{"sha": "fa029f453a551f13f36cd997618629998696849e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmEwMjlmNDUzYTU1MWYxM2YzNmNkOTk3NjE4NjI5OTk4Njk2ODQ5ZQ==", "commit": {"author": {"name": "Per Bothner", "email": "per@bothner.com", "date": "2001-03-24T01:13:30Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "2001-03-24T01:13:30Z"}, "message": "re PR java/1208 (Gcj can't compile a class file it generates.)\n\ne\n\t* verify.c (verify_jvm_instructions):  Replace 3 pop_type by POP_TYPE\n\tmacro for better error pin-pointing.\n\t* java-tree.h:  Fix typo in comment.\n\n\t* jcf-write.c (generate_bytecode_insns):  Changes to TRY_FINALLY_EXPR.\n\tDon't include jsr/goto in exception range.\n\tCheck if start and end of exception range are the same (also TRY_EXPR).\n\tDon't emit jsr after try_block if CAN_COMPLETE_NORMALLY is false.\n\tHowever, do emit the following goto even if try_block is empty.\n\tDefer freeing exception_decl until after the finalizer, to make\n\tsure the local isn't reused in the finalizer.  Fixes PR java/1208.\n\n\t* parse.y (java_complete_lhs):  If the try-clause is empty, just\n\treturn the finally-clause and vice versa.\n\nFrom-SVN: r40801", "tree": {"sha": "b1eef7b31ca3d14d2d241bc45c3318313375f660", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b1eef7b31ca3d14d2d241bc45c3318313375f660"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa029f453a551f13f36cd997618629998696849e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa029f453a551f13f36cd997618629998696849e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa029f453a551f13f36cd997618629998696849e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa029f453a551f13f36cd997618629998696849e/comments", "author": {"login": "PerBothner", "id": 10293361, "node_id": "MDQ6VXNlcjEwMjkzMzYx", "avatar_url": "https://avatars.githubusercontent.com/u/10293361?v=4", "gravatar_id": "", "url": "https://api.github.com/users/PerBothner", "html_url": "https://github.com/PerBothner", "followers_url": "https://api.github.com/users/PerBothner/followers", "following_url": "https://api.github.com/users/PerBothner/following{/other_user}", "gists_url": "https://api.github.com/users/PerBothner/gists{/gist_id}", "starred_url": "https://api.github.com/users/PerBothner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/PerBothner/subscriptions", "organizations_url": "https://api.github.com/users/PerBothner/orgs", "repos_url": "https://api.github.com/users/PerBothner/repos", "events_url": "https://api.github.com/users/PerBothner/events{/privacy}", "received_events_url": "https://api.github.com/users/PerBothner/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3c45ffa5146a7132ea4867981f0d2a737d656e54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c45ffa5146a7132ea4867981f0d2a737d656e54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c45ffa5146a7132ea4867981f0d2a737d656e54"}], "stats": {"total": 107, "additions": 61, "deletions": 46}, "files": [{"sha": "8104fe8429535b83ade2af37b00747defbdc11ec", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa029f453a551f13f36cd997618629998696849e/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa029f453a551f13f36cd997618629998696849e/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=fa029f453a551f13f36cd997618629998696849e", "patch": "@@ -1,3 +1,20 @@\n+2001-03-23  Per Bothner  <per@bothner.com>\n+\n+\t* verify.c (verify_jvm_instructions):  Replace 3 pop_type by POP_TYPE\n+\tmacro for better error pin-pointing.\n+\t* java-tree.h:  Fix typo in comment.\n+\n+\t* jcf-write.c (generate_bytecode_insns):  Changes to TRY_FINALLY_EXPR.\n+\tDon't include jsr/goto in exception range.\n+\tCheck if start and end of exception range are the same (also TRY_EXPR).\n+\tDon't emit jsr after try_block if CAN_COMPLETE_NORMALLY is false.\n+\tHowever, do emit the following goto even if try_block is empty.\n+\tDefer freeing exception_decl until after the finalizer, to make\n+\tsure the local isn't reused in the finalizer.  Fixes PR java/1208.\n+\n+\t* parse.y (java_complete_lhs):  If the try-clause is empty, just\n+\treturn the finally-clause and vice versa.\n+\n 2001-03-23  Alexandre Petit-Bianco  <apbianco@redhat.com>\n \n \t* gcj.texi (Input Options): documented the check for attribute"}, {"sha": "33f8a5b4c18dfd942bd0933fcac99c3d1b21a521", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa029f453a551f13f36cd997618629998696849e/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa029f453a551f13f36cd997618629998696849e/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=fa029f453a551f13f36cd997618629998696849e", "patch": "@@ -743,7 +743,7 @@ struct lang_identifier\n #define LABEL_RETURN_TYPE_STATE(NODE) LABEL_TYPE_STATE (LABEL_RETURN_LABEL (NODE))\n \n /* In a TREE_VEC for a LABEL_RETURN_TYPE_STATE, notes that\n-   TREE_VEC_LENGTH has been adjust to the correct stack size. */\n+   TREE_VEC_LENGTH has been adjusted to the correct stack size. */\n #define RETURN_MAP_ADJUSTED(NODE) TREE_LANG_FLAG_2(NODE)\n \n /* In the label of a sub-routine, a chain of the return location labels. */"}, {"sha": "4593e8a64b5f5a4c1b59b98d731769201ac9055b", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 36, "deletions": 42, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa029f453a551f13f36cd997618629998696849e/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa029f453a551f13f36cd997618629998696849e/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=fa029f453a551f13f36cd997618629998696849e", "patch": "@@ -111,7 +111,7 @@ struct chunk\n struct jcf_block\n {\n   /* For blocks that that are defined, the next block (in pc order).\n-     For blocks that are the not-yet-defined end label of a LABELED_BLOCK_EXPR\n+     For blocks that are not-yet-defined the end label of a LABELED_BLOCK_EXPR\n      or a cleanup expression (from a WITH_CLEANUP_EXPR),\n      this is the next (outer) such end label, in a stack headed by\n      labeled_blocks in jcf_partial. */\n@@ -131,8 +131,8 @@ struct jcf_block\n \n   int linenumber;\n \n-  /* After finish_jcf_block is called, The actual instructions\n-     contained in this block.  Before than NULL, and the instructions\n+  /* After finish_jcf_block is called, the actual instructions\n+     contained in this block.  Before that NULL, and the instructions\n      are in state->bytecode. */\n   union {\n     struct chunk *chunk;\n@@ -2311,6 +2311,8 @@ generate_bytecode_insns (exp, target, state)\n \t  abort ();\n \tgenerate_bytecode_insns (try_clause, IGNORE_TARGET, state);\n \tend_label = get_jcf_label_here (state);\n+\tif (end_label == start_label)\n+\t  break;\n \tif (CAN_COMPLETE_NORMALLY (try_clause))\n \t  emit_goto (finished_label, state);\n \twhile (clause != NULL_TREE)\n@@ -2332,61 +2334,53 @@ generate_bytecode_insns (exp, target, state)\n       break;\n     case TRY_FINALLY_EXPR:\n       {\n-\tstruct jcf_block *finished_label, *finally_label, *start_label;\n+\tstruct jcf_block *finished_label,\n+\t  *finally_label, *start_label, *end_label;\n \tstruct jcf_handler *handler;\n-\tint worthwhile_finally = 1;\n \ttree try_block = TREE_OPERAND (exp, 0);\n \ttree finally = TREE_OPERAND (exp, 1);\n-\ttree return_link, exception_decl;\n+\ttree return_link = NULL_TREE, exception_decl = NULL_TREE;\n \n-\tfinally_label = start_label = NULL;\n-\treturn_link = exception_decl = NULL_TREE;\n-\tfinished_label = gen_jcf_label (state);\n+\ttree exception_type;\n \n-\t/* If the finally clause happens to be empty, set a flag so we\n-           remember to just skip it. */\n-\tif (BLOCK_EXPR_BODY (finally) == empty_stmt_node)\n-\t  worthwhile_finally = 0;\n+\tfinally_label = gen_jcf_label (state);\n+\tstart_label = get_jcf_label_here (state);\n+\tfinally_label->pc = PENDING_CLEANUP_PC;\n+\tfinally_label->next = state->labeled_blocks;\n+\tstate->labeled_blocks = finally_label;\n+\tstate->num_finalizers++;\n+\n+\tgenerate_bytecode_insns (try_block, target, state);\n+\tif (state->labeled_blocks != finally_label)\n+\t  abort();\n+\tstate->labeled_blocks = finally_label->next;\n+\tend_label = get_jcf_label_here (state);\n \n-\tif (worthwhile_finally)\n+\tif (end_label == start_label)\n \t  {\n-\t    tree exception_type;\n-\t    return_link = build_decl (VAR_DECL, NULL_TREE,\n-\t\t\t\t      return_address_type_node);\n-\t    exception_type = build_pointer_type (throwable_type_node);\n-\t    exception_decl = build_decl (VAR_DECL, NULL_TREE, exception_type);\n-\n-\t    finally_label = gen_jcf_label (state);\n-\t    start_label = get_jcf_label_here (state);\n-\t    finally_label->pc = PENDING_CLEANUP_PC;\n-\t    finally_label->next = state->labeled_blocks;\n-\t    state->labeled_blocks = finally_label;\n-\t    state->num_finalizers++;\n+\t    state->num_finalizers--;\n+\t    define_jcf_label (finally_label, state);\n+\t    generate_bytecode_insns (finally, IGNORE_TARGET, state);\n+\t    break;\n \t  }\n \n-\tgenerate_bytecode_insns (try_block, target, state);\n+\treturn_link = build_decl (VAR_DECL, NULL_TREE,\n+\t\t\t\t  return_address_type_node);\n+\tfinished_label = gen_jcf_label (state);\n \n-\tif (worthwhile_finally)\n+\n+\tif (CAN_COMPLETE_NORMALLY (try_block))\n \t  {\n-\t    if (state->labeled_blocks != finally_label)\n-\t      abort();\n-\t    state->labeled_blocks = finally_label->next;\n \t    emit_jsr (finally_label, state);\n+\t    emit_goto (finished_label, state);\n \t  }\n \n-\tif (CAN_COMPLETE_NORMALLY (try_block)\n-\t    && TREE_CODE (try_block) == BLOCK\n-\t    && BLOCK_EXPR_BODY (try_block) != empty_stmt_node)\n-\t  emit_goto (finished_label, state);\n-\n \t/* Handle exceptions. */\n \n-\tif (!worthwhile_finally)\n-\t  break;\n-\n+\texception_type = build_pointer_type (throwable_type_node);\n+\texception_decl = build_decl (VAR_DECL, NULL_TREE, exception_type);\n \tlocalvar_alloc (return_link, state);\n-\thandler = alloc_handler (start_label, NULL_PTR, state);\n-\thandler->end_label = handler->handler_label;\n+\thandler = alloc_handler (start_label, end_label, state);\n \thandler->type = NULL_TREE;\n \tlocalvar_alloc (exception_decl, state);\n \tNOTE_PUSH (1);\n@@ -2396,7 +2390,6 @@ generate_bytecode_insns (exp, target, state)\n \tRESERVE (1);\n \tOP1 (OPCODE_athrow);\n \tNOTE_POP (1);\n-\tlocalvar_free (exception_decl, state);\n \n \t/* The finally block.  First save return PC into return_link. */\n \tdefine_jcf_label (finally_label, state);\n@@ -2405,6 +2398,7 @@ generate_bytecode_insns (exp, target, state)\n \n \tgenerate_bytecode_insns (finally, IGNORE_TARGET, state);\n \tmaybe_wide (OPCODE_ret, DECL_LOCAL_INDEX (return_link), state);\n+\tlocalvar_free (exception_decl, state);\n \tlocalvar_free (return_link, state);\n \tdefine_jcf_label (finished_label, state);\n       }"}, {"sha": "461e6c4e197cbc4c75900efef9b579bff9328bc4", "filename": "gcc/java/parse.y", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa029f453a551f13f36cd997618629998696849e/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa029f453a551f13f36cd997618629998696849e/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=fa029f453a551f13f36cd997618629998696849e", "patch": "@@ -11185,6 +11185,10 @@ java_complete_lhs (node)\n     case TRY_FINALLY_EXPR:\n       COMPLETE_CHECK_OP_0 (node);\n       COMPLETE_CHECK_OP_1 (node);\n+      if (TREE_OPERAND (node, 0) == empty_stmt_node)\n+\treturn TREE_OPERAND (node, 1);\n+      if (TREE_OPERAND (node, 1) == empty_stmt_node)\n+\treturn TREE_OPERAND (node, 0);\n       CAN_COMPLETE_NORMALLY (node)\n \t= (CAN_COMPLETE_NORMALLY (TREE_OPERAND (node, 0))\n \t   && CAN_COMPLETE_NORMALLY (TREE_OPERAND (node, 1)));"}, {"sha": "9b83363cf55944b528460786b5df68cef42ccc6e", "filename": "gcc/java/verify.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa029f453a551f13f36cd997618629998696849e/gcc%2Fjava%2Fverify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa029f453a551f13f36cd997618629998696849e/gcc%2Fjava%2Fverify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fverify.c?ref=fa029f453a551f13f36cd997618629998696849e", "patch": "@@ -1137,7 +1137,7 @@ verify_jvm_instructions (jcf, byte_ops, length)\n \n \tcase OPCODE_athrow:\n \t  /* FIXME: athrow also empties the stack. */\n-\t  pop_type (throwable_type_node);\n+\t  POP_TYPE (throwable_type_node, \"missing throwable at athrow\" );\n \t  INVALIDATE_PC;\n \t  break;\n \n@@ -1156,7 +1156,7 @@ verify_jvm_instructions (jcf, byte_ops, length)\n \t  {\n \t    jint low, high;\n \n-\t    pop_type (int_type_node);\n+\t    POP_TYPE (int_type_node, \"missing int for tableswitch\");\n \t    while (PC%4)\n \t      {\n \t        if (byte_ops[PC++])\n@@ -1179,7 +1179,7 @@ verify_jvm_instructions (jcf, byte_ops, length)\n \t  {\n \t    jint npairs, last = 0, not_registered = 1;\n \n-\t    pop_type (int_type_node);\n+\t    POP_TYPE (int_type_node, \"missing int for lookupswitch\");\n \t    while (PC%4)\n \t      {\n \t        if (byte_ops[PC++])"}]}