{"sha": "d6df6ae236c4810dc264357801e0f94e02690369", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDZkZjZhZTIzNmM0ODEwZGMyNjQzNTc4MDFlMGY5NGUwMjY5MDM2OQ==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2004-09-03T14:45:23Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2004-09-03T14:45:23Z"}, "message": "re PR target/15832 (ICE in move_for_stack_reg, at reg-stack.c:1120)\n\n2004-09-03  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR target/15832\n\t* global.c (modify_reg_pav): New function.\n\t(make_accurate_live_analysis): Call the new function.  Move pavin\n\tmodification by earlyclobber set into the new function.\n\nFrom-SVN: r87035", "tree": {"sha": "9b56daa8c2ef74d813a86921a85b192ff8d1bcb4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b56daa8c2ef74d813a86921a85b192ff8d1bcb4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d6df6ae236c4810dc264357801e0f94e02690369", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6df6ae236c4810dc264357801e0f94e02690369", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6df6ae236c4810dc264357801e0f94e02690369", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6df6ae236c4810dc264357801e0f94e02690369/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "eea22dfbd726f71dca6da2d809000e99a3a11284", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eea22dfbd726f71dca6da2d809000e99a3a11284", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eea22dfbd726f71dca6da2d809000e99a3a11284"}], "stats": {"total": 70, "additions": 64, "deletions": 6}, "files": [{"sha": "98cd6041e7a385ad21ee7e367a4ef3c439003cde", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6df6ae236c4810dc264357801e0f94e02690369/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6df6ae236c4810dc264357801e0f94e02690369/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d6df6ae236c4810dc264357801e0f94e02690369", "patch": "@@ -1,3 +1,10 @@\n+2004-09-03  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR target/15832\n+\t* global.c (modify_reg_pav): New function.\n+\t(make_accurate_live_analysis): Call the new function.  Move pavin\n+\tmodification by earlyclobber set into the new function.\n+\n 2004-09-03  Andreas Schwab  <schwab@suse.de>\n \n \t* config/m68k/m68k.c (output_andsi3): Use -1 instead of"}, {"sha": "9964d728d71bdd49d02d49c1610160c80cbab4c6", "filename": "gcc/global.c", "status": "modified", "additions": 57, "deletions": 6, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6df6ae236c4810dc264357801e0f94e02690369/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6df6ae236c4810dc264357801e0f94e02690369/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=d6df6ae236c4810dc264357801e0f94e02690369", "patch": "@@ -319,6 +319,7 @@ static void set_up_bb_rts_numbers (void);\n static int rpost_cmp (const void *, const void *);\n static bool modify_bb_reg_pav (basic_block, basic_block, bool);\n static void calculate_reg_pav (void);\n+static void modify_reg_pav (void);\n static void make_accurate_live_analysis (void);\n \n \f\n@@ -2360,6 +2361,61 @@ calculate_reg_pav (void)\n   sbitmap_free (wset);\n }\n \n+/* The function modifies partial availability information for two\n+   special cases to prevent incorrect work of the subsequent passes\n+   with the accurate live information based on the partial\n+   availability.  */\n+\n+static void\n+modify_reg_pav (void)\n+{\n+  basic_block bb;\n+  struct bb_info *bb_info;\n+#ifdef STACK_REGS\n+  int i;\n+  HARD_REG_SET zero, stack_hard_regs, used;\n+  bitmap stack_regs;\n+\n+  CLEAR_HARD_REG_SET (zero);\n+  CLEAR_HARD_REG_SET (stack_hard_regs);\n+  for (i = FIRST_STACK_REG; i <= LAST_STACK_REG; i++)\n+    SET_HARD_REG_BIT(stack_hard_regs, i);\n+  stack_regs = BITMAP_XMALLOC ();\n+  for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n+    {\n+      COPY_HARD_REG_SET (used, reg_class_contents[reg_preferred_class (i)]);\n+      IOR_HARD_REG_SET (used, reg_class_contents[reg_alternate_class (i)]);\n+      AND_HARD_REG_SET (used, stack_hard_regs);\n+      GO_IF_HARD_REG_EQUAL(used, zero, skip);\n+      bitmap_set_bit (stack_regs, i);\n+    skip:\n+      ;\n+    }\n+#endif\n+  FOR_EACH_BB (bb)\n+    {\n+      bb_info = BB_INFO (bb);\n+      \n+      /* Reload can assign the same hard register to uninitialized\n+\t pseudo-register and early clobbered pseudo-register in an\n+\t insn if the pseudo-register is used first time in given BB\n+\t and not lived at the BB start.  To prevent this we don't\n+\t change life information for such pseudo-registers.  */\n+      bitmap_a_or_b (bb_info->pavin, bb_info->pavin, bb_info->earlyclobber);\n+#ifdef STACK_REGS\n+      /* We can not use the same stack register for uninitialized\n+\t pseudo-register and another living pseudo-register because if the\n+\t uninitialized pseudo-register dies, subsequent pass reg-stack\n+\t will be confused (it will believe that the other register\n+\t dies).  */\n+      bitmap_a_or_b (bb_info->pavin, bb_info->pavin, stack_regs);\n+#endif\n+    }\n+#ifdef STACK_REGS\n+  BITMAP_XFREE (stack_regs);\n+#endif\n+}\n+\n /* The following function makes live information more accurate by\n    modifying global_live_at_start and global_live_at_end of basic\n    blocks.  After the function call a register lives at a program\n@@ -2379,16 +2435,11 @@ make_accurate_live_analysis (void)\n   calculate_local_reg_bb_info ();\n   set_up_bb_rts_numbers ();\n   calculate_reg_pav ();\n+  modify_reg_pav ();\n   FOR_EACH_BB (bb)\n     {\n       bb_info = BB_INFO (bb);\n       \n-      /* Reload can assign the same hard register to uninitialized\n-\t pseudo-register and early clobbered pseudo-register in an\n-\t insn if the pseudo-register is used first time in given BB\n-\t and not lived at the BB start.  To prevent this we don't\n-\t change life information for such pseudo-registers.  */\n-      bitmap_a_or_b (bb_info->pavin, bb_info->pavin, bb_info->earlyclobber);\n       bitmap_a_and_b (bb->global_live_at_start, bb->global_live_at_start,\n \t\t      bb_info->pavin);\n       bitmap_a_and_b (bb->global_live_at_end, bb->global_live_at_end,"}]}