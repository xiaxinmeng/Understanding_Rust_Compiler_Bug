{"sha": "297363774e6a5dca2f46a85ab086f1d9e59431ac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjk3MzYzNzc0ZTZhNWRjYTJmNDZhODVhYjA4NmYxZDllNTk0MzFhYw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2021-03-28T15:48:27Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2021-03-28T18:39:50Z"}, "message": "Fortran: Fix problem with runtime pointer check [PR99602].\n\n2021-03-28  Paul Thomas  <pault@gcc.gnu.org>\n\ngcc/fortran/ChangeLog\n\n\tPR fortran/99602\n\t* trans-expr.c (gfc_conv_procedure_call): Use the _data attrs\n\tfor class expressions and detect proc pointer evaluations by\n\tthe non-null actual argument list.\n\ngcc/testsuite/ChangeLog\n\n\tPR fortran/99602\n\t* gfortran.dg/pr99602.f90: New test.\n\t* gfortran.dg/pr99602a.f90: New test.\n\t* gfortran.dg/pr99602b.f90: New test.\n\t* gfortran.dg/pr99602c.f90: New test.\n\t* gfortran.dg/pr99602d.f90: New test.", "tree": {"sha": "396b7b7ff01733f9a5d5a51d9218d6ff67d433b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/396b7b7ff01733f9a5d5a51d9218d6ff67d433b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/297363774e6a5dca2f46a85ab086f1d9e59431ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/297363774e6a5dca2f46a85ab086f1d9e59431ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/297363774e6a5dca2f46a85ab086f1d9e59431ac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/297363774e6a5dca2f46a85ab086f1d9e59431ac/comments", "author": null, "committer": null, "parents": [{"sha": "5a5d23010ab8ecbefd443054d9a3ec227aceb976", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a5d23010ab8ecbefd443054d9a3ec227aceb976", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a5d23010ab8ecbefd443054d9a3ec227aceb976"}], "stats": {"total": 329, "additions": 321, "deletions": 8}, "files": [{"sha": "2fa17b36c03a9fdba709c276068ad6b14f6918a8", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/297363774e6a5dca2f46a85ab086f1d9e59431ac/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/297363774e6a5dca2f46a85ab086f1d9e59431ac/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=297363774e6a5dca2f46a85ab086f1d9e59431ac", "patch": "@@ -6663,6 +6663,18 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t  char *msg;\n \t  tree cond;\n \t  tree tmp;\n+\t  symbol_attribute fsym_attr;\n+\n+\t  if (fsym)\n+\t    {\n+\t      if (fsym->ts.type == BT_CLASS)\n+\t\t{\n+\t\t  fsym_attr = CLASS_DATA (fsym)->attr;\n+\t\t  fsym_attr.pointer = fsym_attr.class_pointer;\n+\t\t}\n+\t      else\n+\t\tfsym_attr = fsym->attr;\n+\t    }\n \n \t  if (e->expr_type == EXPR_VARIABLE || e->expr_type == EXPR_FUNCTION)\n \t    attr = gfc_expr_attr (e);\n@@ -6685,17 +6697,17 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t      tree present, null_ptr, type;\n \n \t      if (attr.allocatable\n-\t\t  && (fsym == NULL || !fsym->attr.allocatable))\n+\t\t  && (fsym == NULL || !fsym_attr.allocatable))\n \t\tmsg = xasprintf (\"Allocatable actual argument '%s' is not \"\n \t\t\t\t \"allocated or not present\",\n \t\t\t\t e->symtree->n.sym->name);\n \t      else if (attr.pointer\n-\t\t       && (fsym == NULL || !fsym->attr.pointer))\n+\t\t       && (fsym == NULL || !fsym_attr.pointer))\n \t\tmsg = xasprintf (\"Pointer actual argument '%s' is not \"\n \t\t\t\t \"associated or not present\",\n \t\t\t\t e->symtree->n.sym->name);\n-\t      else if (attr.proc_pointer\n-\t\t       && (fsym == NULL || !fsym->attr.proc_pointer))\n+\t      else if (attr.proc_pointer && !e->value.function.actual\n+\t\t       && (fsym == NULL || !fsym_attr.proc_pointer))\n \t\tmsg = xasprintf (\"Proc-pointer actual argument '%s' is not \"\n \t\t\t\t \"associated or not present\",\n \t\t\t\t e->symtree->n.sym->name);\n@@ -6719,15 +6731,15 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n           else\n \t    {\n \t      if (attr.allocatable\n-\t\t  && (fsym == NULL || !fsym->attr.allocatable))\n+\t\t  && (fsym == NULL || !fsym_attr.allocatable))\n \t\tmsg = xasprintf (\"Allocatable actual argument '%s' is not \"\n \t\t\t\t \"allocated\", e->symtree->n.sym->name);\n \t      else if (attr.pointer\n-\t\t       && (fsym == NULL || !fsym->attr.pointer))\n+\t\t       && (fsym == NULL || !fsym_attr.pointer))\n \t\tmsg = xasprintf (\"Pointer actual argument '%s' is not \"\n \t\t\t\t \"associated\", e->symtree->n.sym->name);\n-\t      else if (attr.proc_pointer\n-\t\t       && (fsym == NULL || !fsym->attr.proc_pointer))\n+\t      else if (attr.proc_pointer && !e->value.function.actual\n+\t\t       && (fsym == NULL || !fsym_attr.proc_pointer))\n \t\tmsg = xasprintf (\"Proc-pointer actual argument '%s' is not \"\n \t\t\t\t \"associated\", e->symtree->n.sym->name);\n \t      else"}, {"sha": "6c8455bcdb919756be28f7cac8e2dbdbf2da35ac", "filename": "gcc/testsuite/gfortran.dg/pr99602.f90", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/297363774e6a5dca2f46a85ab086f1d9e59431ac/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr99602.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/297363774e6a5dca2f46a85ab086f1d9e59431ac/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr99602.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr99602.f90?ref=297363774e6a5dca2f46a85ab086f1d9e59431ac", "patch": "@@ -0,0 +1,94 @@\n+! { dg-do compile }\n+! { dg-options \"-fcheck=pointer -fdump-tree-original\" }\n+!\n+! Test fix of PR99602, where a spurious runtime error was introduced\n+! by PR99112. This is the testcase in comment #6 of the PR.\n+! PR99602a.f90 turns on the runtime errors by eliminating the pointer\n+! attribute from the formal arguments in the abstract interface and\n+! prepare_whizard_m2.\n+!\n+! Contributed by Jeurgen Reuter  <juergen.reuter@desy.de>\n+!\n+module m\n+  implicit none\n+  private\n+  public :: m_t\n+  type :: m_t\n+     private\n+  end type m_t\n+end module m\n+\n+module m2_testbed\n+  use m\n+  implicit none\n+  private\n+  public :: prepare_m2\n+  procedure (prepare_m2_proc), pointer :: prepare_m2 => null ()\n+\n+  abstract interface\n+     subroutine prepare_m2_proc (m2)\n+       import\n+       class(m_t), intent(inout), pointer :: m2\n+     end subroutine prepare_m2_proc\n+  end interface\n+\n+end module m2_testbed\n+\n+module a\n+  use m\n+  use m2_testbed, only: prepare_m2\n+  implicit none\n+  private\n+  public :: a_1\n+\n+contains\n+\n+  subroutine a_1 ()\n+    class(m_t), pointer :: mm\n+    mm => null ()\n+    call prepare_m2 (mm) ! Runtime error triggered here\n+  end subroutine a_1\n+\n+end module a\n+\n+\n+module m2\n+  use m\n+  implicit none\n+  private\n+  public :: m2_t\n+\n+  type, extends (m_t) :: m2_t\n+     private\n+   contains\n+     procedure :: read => m2_read\n+  end type m2_t\n+contains\n+\n+  subroutine m2_read (mm)\n+    class(m2_t), intent(out), target :: mm\n+  end subroutine m2_read\n+end module m2\n+\n+program main\n+  use m2_testbed\n+  use a, only: a_1\n+  implicit none\n+  prepare_m2 => prepare_whizard_m2\n+  call a_1 ()\n+\n+contains\n+\n+  subroutine prepare_whizard_m2 (mm)\n+    use m\n+    use m2\n+    class(m_t), intent(inout), pointer :: mm\n+    if (.not. associated (mm))  allocate (m2_t :: mm)\n+    select type (mm)\n+    type is (m2_t)\n+!       call mm%read ()  ! Since mm is passed to non-pointer, this generates the error code.\n+    end select\n+  end subroutine prepare_whizard_m2\n+end program main\n+! { dg-final { scan-tree-dump-times \"_gfortran_runtime_error_at\" 0 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"Pointer actual argument\" 0 \"original\" } }"}, {"sha": "45063e4f2c584f81d972fe9597e6d8b957dfa08f", "filename": "gcc/testsuite/gfortran.dg/pr99602a.f90", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/297363774e6a5dca2f46a85ab086f1d9e59431ac/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr99602a.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/297363774e6a5dca2f46a85ab086f1d9e59431ac/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr99602a.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr99602a.f90?ref=297363774e6a5dca2f46a85ab086f1d9e59431ac", "patch": "@@ -0,0 +1,93 @@\n+! { dg-do compile }\n+! { dg-options \"-fcheck=pointer -fdump-tree-original\" }\n+!\n+! Test fix of PR99602, where a spurious runtime error was introduced\n+! by PR99112. This is the testcase in comment #6 of the PR.\n+! This version of PR99602.f90 turns on the runtime errors by eliminating\n+! the pointer attribute from the formal arguments in the abstract interface\n+! and prepare_whizard_m2.\n+!\n+! Contributed by Jeurgen Reuter  <juergen.reuter@desy.de>\n+!\n+module m\n+  implicit none\n+  private\n+  public :: m_t\n+  type :: m_t\n+     private\n+  end type m_t\n+end module m\n+\n+module m2_testbed\n+  use m\n+  implicit none\n+  private\n+  public :: prepare_m2\n+  procedure (prepare_m2_proc), pointer :: prepare_m2 => null ()\n+\n+  abstract interface\n+     subroutine prepare_m2_proc (m2)\n+       import\n+       class(m_t), intent(inout) :: m2\n+     end subroutine prepare_m2_proc\n+  end interface\n+\n+end module m2_testbed\n+\n+module a\n+  use m\n+  use m2_testbed, only: prepare_m2\n+  implicit none\n+  private\n+  public :: a_1\n+\n+contains\n+\n+  subroutine a_1 ()\n+    class(m_t), pointer :: mm\n+    mm => null ()\n+    call prepare_m2 (mm) ! Runtime error triggered here\n+  end subroutine a_1\n+\n+end module a\n+\n+\n+module m2\n+  use m\n+  implicit none\n+  private\n+  public :: m2_t\n+\n+  type, extends (m_t) :: m2_t\n+     private\n+   contains\n+     procedure :: read => m2_read\n+  end type m2_t\n+contains\n+\n+  subroutine m2_read (mm)\n+    class(m2_t), intent(out), target :: mm\n+  end subroutine m2_read\n+end module m2\n+\n+program main\n+  use m2_testbed\n+  use a, only: a_1\n+  implicit none\n+  prepare_m2 => prepare_whizard_m2\n+  call a_1 ()\n+\n+contains\n+\n+  subroutine prepare_whizard_m2 (mm)\n+    use m\n+    use m2\n+    class(m_t), intent(inout) :: mm\n+    select type (mm)\n+    type is (m2_t)\n+       call mm%read ()\n+    end select\n+  end subroutine prepare_whizard_m2\n+end program main\n+! { dg-final { scan-tree-dump-times \"_gfortran_runtime_error_at\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"Pointer actual argument\" 1 \"original\" } }"}, {"sha": "ba6d5b6ab06eda217db63b95495c0be7b213d78c", "filename": "gcc/testsuite/gfortran.dg/pr99602b.f90", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/297363774e6a5dca2f46a85ab086f1d9e59431ac/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr99602b.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/297363774e6a5dca2f46a85ab086f1d9e59431ac/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr99602b.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr99602b.f90?ref=297363774e6a5dca2f46a85ab086f1d9e59431ac", "patch": "@@ -0,0 +1,64 @@\n+! { dg-do run }\n+! { dg-options \"-fcheck=pointer\" }\n+!\n+! Test the fix for PR99602 in which the runtime error,\n+! \"Proc-pointer actual argument 'model' is not associated\" was triggered\n+! by the NULL result from model%get_par_data_ptr (\"tea \")\n+!\n+! Contributed by Juergen Reuter  <juergen.reuter@desy.de>\n+!\n+module model_data\n+  type :: model_data_t\n+     type(modelpar_real_t), dimension(:), pointer :: par_real => null ()\n+   contains\n+     procedure :: get_par_data_ptr => model_data_get_par_data_ptr_name\n+     procedure :: set => field_data_set\n+  end type model_data_t\n+\n+  type :: modelpar_real_t\n+     character (4) :: name\n+     real(4) :: value\n+  end type modelpar_real_t\n+\n+  type(modelpar_real_t), target :: names(2) = [modelpar_real_t(\"foo \", 1.0), &\n+                                               modelpar_real_t(\"bar \", 2.0)]\n+  integer :: return_value = 0\n+\n+contains\n+\n+  function model_data_get_par_data_ptr_name (model, name) result (ptr)\n+    class(model_data_t), intent(in) :: model\n+    character (*), intent(in) :: name\n+    class(modelpar_real_t), pointer :: ptr\n+    integer :: i\n+    ptr => null ()\n+    do i = 1, size (model%par_real)\n+       if (model%par_real(i)%name == name) ptr => model%par_real(i)\n+    end do\n+  end function model_data_get_par_data_ptr_name\n+\n+  subroutine field_data_set (this, ptr)\n+    class(model_data_t), intent(inout) :: this\n+    class(modelpar_real_t), intent(in), pointer :: ptr\n+    if (associated (ptr)) then\n+      return_value = int (ptr%value)\n+    else\n+      return_value = -1\n+    end if\n+  end subroutine\n+\n+end module model_data\n+\n+  use model_data\n+  class(model_data_t), allocatable :: model\n+  class(modelpar_real_t), pointer :: name_ptr\n+\n+  allocate (model_data_t :: model)\n+  model%par_real => names\n+\n+  call model%set (model%get_par_data_ptr (\"bar \"))\n+  if (return_value .ne. 2) stop 1\n+  call model%set (model%get_par_data_ptr (\"tea \")) ! Triggered runtime error\n+  if (return_value .ne. -1) stop 2\n+end\n+"}, {"sha": "d16c9ffb79afa0e4c53f92d8f3f9ea54577acc17", "filename": "gcc/testsuite/gfortran.dg/pr99602c.f90", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/297363774e6a5dca2f46a85ab086f1d9e59431ac/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr99602c.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/297363774e6a5dca2f46a85ab086f1d9e59431ac/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr99602c.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr99602c.f90?ref=297363774e6a5dca2f46a85ab086f1d9e59431ac", "patch": "@@ -0,0 +1,25 @@\n+! { dg-do compile }\r\n+! { dg-options \"-fcheck=pointer -fdump-tree-original\" }\r\n+!\r\n+! PR fortran/99602\r\n+!\r\n+\r\n+module m\r\n+  implicit none\r\n+contains\r\n+  subroutine wr(y)\r\n+    class(*), pointer :: y\r\n+    if (associated (y)) stop 1\r\n+  end\r\n+end module m\r\n+\r\n+use m\r\n+implicit none\r\n+class(*), pointer :: cptr\r\n+\r\n+nullify (cptr)\r\n+call wr(cptr)\r\n+end\r\n+\r\n+! { dg-final { scan-tree-dump-not \"_gfortran_runtime_error_at\" \"original\" } }\r\n+! { dg-final { scan-tree-dump-not \"Pointer actual argument\" \"original\" } }\r"}, {"sha": "d16c9ffb79afa0e4c53f92d8f3f9ea54577acc17", "filename": "gcc/testsuite/gfortran.dg/pr99602d.f90", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/297363774e6a5dca2f46a85ab086f1d9e59431ac/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr99602d.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/297363774e6a5dca2f46a85ab086f1d9e59431ac/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr99602d.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr99602d.f90?ref=297363774e6a5dca2f46a85ab086f1d9e59431ac", "patch": "@@ -0,0 +1,25 @@\n+! { dg-do compile }\r\n+! { dg-options \"-fcheck=pointer -fdump-tree-original\" }\r\n+!\r\n+! PR fortran/99602\r\n+!\r\n+\r\n+module m\r\n+  implicit none\r\n+contains\r\n+  subroutine wr(y)\r\n+    class(*), pointer :: y\r\n+    if (associated (y)) stop 1\r\n+  end\r\n+end module m\r\n+\r\n+use m\r\n+implicit none\r\n+class(*), pointer :: cptr\r\n+\r\n+nullify (cptr)\r\n+call wr(cptr)\r\n+end\r\n+\r\n+! { dg-final { scan-tree-dump-not \"_gfortran_runtime_error_at\" \"original\" } }\r\n+! { dg-final { scan-tree-dump-not \"Pointer actual argument\" \"original\" } }\r"}]}