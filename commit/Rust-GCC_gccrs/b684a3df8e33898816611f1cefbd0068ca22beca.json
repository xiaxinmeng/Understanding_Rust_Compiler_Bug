{"sha": "b684a3df8e33898816611f1cefbd0068ca22beca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjY4NGEzZGY4ZTMzODk4ODE2NjExZjFjZWZiZDAwNjhjYTIyYmVjYQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2004-01-01T13:59:02Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2004-01-01T13:59:02Z"}, "message": "re PR rtl-optimization/13473 (cc1 segfault w/-march=pentium4)\n\n\n\tPR opt/13473\n\t* recog.c (validate_replace_rtx_1):  Take care for RTL sharing inside\n\tASM input operands\n\n\tPR opt/12617\n\t* toplev.c (dump_file_index): Reorder ce3 and bbro.\n\t(dump_file): Likewise.\n\t(rest_of_compilation): Likewise.\n\n\tPR debug/13367\n\t* cgraph.c (cgraph_function_possibly_inlined):  Even with\n\tflag_really_no_inline we inline always_inline functions.\n\t* cgraphunit.c (cgraph_analyze_function): Clear inlinable flag\n\tfor non-always_inline functions when there is flag_really_no_inline.\n\t(cgraph_decide_inlining): Limit work done when not inlining.\n\t(cgraph_decide_inlining_incrementally): Likewise.\n\t(cgraph_optimize_function): Check whether something got inlined.\n\t* c-objc-common.c (c_disregard_inline_limits): Do not always inline\n\textern inline functions when not inlining.\n\n\t* opts.c (decode_options):  Disable crossjumping at -O1\n\t* invoke.texi (-O1): Document change.\n\n\t* gcc.dg/debug/20031231-1.c: New.\n\t* gcc.c-torture/compile/20040101-1.c: New.\n\t* gcc.dg/dwarf-die-[1-7].c: New.\n\nFrom-SVN: r75303", "tree": {"sha": "fe1b65729ca0a43eccd94abb9e3c03c5e01a6e20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fe1b65729ca0a43eccd94abb9e3c03c5e01a6e20"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b684a3df8e33898816611f1cefbd0068ca22beca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b684a3df8e33898816611f1cefbd0068ca22beca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b684a3df8e33898816611f1cefbd0068ca22beca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b684a3df8e33898816611f1cefbd0068ca22beca/comments", "author": null, "committer": null, "parents": [{"sha": "74aa338ad540b76f8d8566c996642b02810f5c14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74aa338ad540b76f8d8566c996642b02810f5c14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74aa338ad540b76f8d8566c996642b02810f5c14"}], "stats": {"total": 427, "additions": 307, "deletions": 120}, "files": [{"sha": "9db27a7b5cef377967e8a80c3ff43b51c635428b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b684a3df8e33898816611f1cefbd0068ca22beca/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b684a3df8e33898816611f1cefbd0068ca22beca/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b684a3df8e33898816611f1cefbd0068ca22beca", "patch": "@@ -1,2 +1,26 @@\n+2003-12-31  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR opt/13473\n+\t* recog.c (validate_replace_rtx_1):  Take care for RTL sharing inside\n+\tASM input operands\n+\n+\tPR opt/12617\n+\t* toplev.c (dump_file_index): Reorder ce3 and bbro.\n+\t(dump_file): Likewise.\n+\t(rest_of_compilation): Likewise.\n+\n+\tPR debug/13367\n+\t* cgraph.c (cgraph_function_possibly_inlined):  Even with\n+\tflag_really_no_inline we inline always_inline functions.\n+\t* cgraphunit.c (cgraph_analyze_function): Clear inlinable flag\n+\tfor non-always_inline functions when there is flag_really_no_inline.\n+\t(cgraph_decide_inlining): Limit work done when not inlining.\n+\t(cgraph_decide_inlining_incrementally): Likewise.\n+\t(cgraph_optimize_function): Check whether something got inlined.\n+\t* c-objc-common.c (c_disregard_inline_limits): Do not always inline\n+\textern inline functions when not inlining.\n+\n+\t* opts.c (decode_options):  Disable crossjumping at -O1\n+\t* invoke.texi (-O1): Document change.\n \n See ChangeLog.10 for earlier changes."}, {"sha": "ee2db9e1fc42ac94378bedd667725d5b08dea629", "filename": "gcc/c-decl.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b684a3df8e33898816611f1cefbd0068ca22beca/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b684a3df8e33898816611f1cefbd0068ca22beca/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=b684a3df8e33898816611f1cefbd0068ca22beca", "patch": "@@ -1426,7 +1426,8 @@ duplicate_decls (tree newdecl, tree olddecl, int different_binding_level,\n \t  if (TREE_USED (olddecl)\n \t      /* In unit-at-a-time mode we never inline re-defined extern\n \t         inline functions.  */\n-\t      && !flag_unit_at_a_time)\n+\t      && !flag_unit_at_a_time\n+\t      && cgraph_function_possibly_inlined_p (olddecl))\n \t    (*debug_hooks->outlining_inline_function) (olddecl);\n \n \t  /* The new defn must not be inline.  */"}, {"sha": "5a57aa46065b4fc04604c71680db1abc240dcf1c", "filename": "gcc/c-objc-common.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b684a3df8e33898816611f1cefbd0068ca22beca/gcc%2Fc-objc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b684a3df8e33898816611f1cefbd0068ca22beca/gcc%2Fc-objc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-objc-common.c?ref=b684a3df8e33898816611f1cefbd0068ca22beca", "patch": "@@ -1,5 +1,5 @@\n /* Some code common to C and ObjC front ends.\n-   Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n+   Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -61,7 +61,8 @@ c_disregard_inline_limits (tree fn)\n   if (lookup_attribute (\"always_inline\", DECL_ATTRIBUTES (fn)) != NULL)\n     return 1;\n \n-  return DECL_DECLARED_INLINE_P (fn) && DECL_EXTERNAL (fn);\n+  return (!flag_really_no_inline && DECL_DECLARED_INLINE_P (fn)\n+\t  && DECL_EXTERNAL (fn));\n }\n \n int"}, {"sha": "26cbd27100c36046afb3ba8d04f9f1211d726ba2", "filename": "gcc/cgraph.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b684a3df8e33898816611f1cefbd0068ca22beca/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b684a3df8e33898816611f1cefbd0068ca22beca/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=b684a3df8e33898816611f1cefbd0068ca22beca", "patch": "@@ -1,5 +1,5 @@\n /* Callgraph handling code.\n-   Copyright (C) 2003 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n    Contributed by Jan Hubicka\n \n This file is part of GCC.\n@@ -613,7 +613,9 @@ bool\n cgraph_function_possibly_inlined_p (tree decl)\n {\n   if (!cgraph_global_info_ready)\n-    return (DECL_INLINE (decl) && !flag_really_no_inline);\n+    return (DECL_INLINE (decl)\n+\t    && (!flag_really_no_inline\n+\t\t|| (*lang_hooks.tree_inlining.disregard_inline_limits) (decl)));\n   return cgraph_node (decl)->global.inlined;\n }\n "}, {"sha": "dfe4c7173dca9d4174f6c855568de2f30b152c73", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 95, "deletions": 78, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b684a3df8e33898816611f1cefbd0068ca22beca/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b684a3df8e33898816611f1cefbd0068ca22beca/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=b684a3df8e33898816611f1cefbd0068ca22beca", "patch": "@@ -1,5 +1,5 @@\n /* Callgraph based intraprocedural optimizations.\n-   Copyright (C) 2003 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n    Contributed by Jan Hubicka\n \n This file is part of GCC.\n@@ -325,7 +325,8 @@ cgraph_analyze_function (struct cgraph_node *node)\n   if (node->local.inlinable)\n     node->local.disregard_inline_limits\n       = (*lang_hooks.tree_inlining.disregard_inline_limits) (decl);\n-\n+  if (flag_really_no_inline && !node->local.disregard_inline_limits)\n+    node->local.inlinable = 0;\n   /* Inlining characteristics are maintained by the cgraph_mark_inline.  */\n   node->global.insns = node->local.self_insns;\n   if (!DECL_EXTERNAL (decl))\n@@ -471,7 +472,15 @@ cgraph_optimize_function (struct cgraph_node *node)\n   /* optimize_inline_calls avoids inlining of current_function_decl.  */\n   current_function_decl = decl;\n   if (flag_inline_trees)\n-    optimize_inline_calls (decl);\n+    {\n+      struct cgraph_edge *e;\n+\n+      for (e = node->callees; e; e = e->next_callee)\n+\tif (e->inline_call)\n+\t  break;\n+      if (e)\n+        optimize_inline_calls (decl);\n+    }\n   if (node->nested)\n     {\n       for (node = node->nested; node; node = node->next_nested)\n@@ -1137,80 +1146,84 @@ cgraph_decide_inlining (void)\n \tinlined[y]->output = 0, node->aux = 0;\n     }\n \n-  cgraph_decide_inlining_of_small_functions (inlined, inlined_callees);\n-\n-  if (cgraph_dump_file)\n-    fprintf (cgraph_dump_file, \"\\nDeciding on functions called once:\\n\");\n+  if (!flag_really_no_inline)\n+    {\n+      cgraph_decide_inlining_of_small_functions (inlined, inlined_callees);\n \n-  /* And finally decide what functions are called once.  */\n+      if (cgraph_dump_file)\n+\tfprintf (cgraph_dump_file, \"\\nDeciding on functions called once:\\n\");\n \n-  for (i = nnodes - 1; i >= 0; i--)\n-    {\n-      node = order[i];\n+      /* And finally decide what functions are called once.  */\n \n-      if (node->callers && !node->callers->next_caller && !node->needed\n-\t  && node->local.inlinable && !node->callers->inline_call\n-\t  && !DECL_EXTERNAL (node->decl) && !DECL_COMDAT (node->decl))\n+      for (i = nnodes - 1; i >= 0; i--)\n \t{\n-\t  bool ok = true;\n-\t  struct cgraph_node *node1;\n-\n-\t  /* Verify that we won't duplicate the caller.  */\n-\t  for (node1 = node->callers->caller;\n-\t       node1->callers && node1->callers->inline_call\n-\t       && ok; node1 = node1->callers->caller)\n-\t    if (node1->callers->next_caller || node1->needed)\n-\t      ok = false;\n-\t  if (ok)\n+\t  node = order[i];\n+\n+\t  if (node->callers && !node->callers->next_caller && !node->needed\n+\t      && node->local.inlinable && !node->callers->inline_call\n+\t      && !DECL_EXTERNAL (node->decl) && !DECL_COMDAT (node->decl))\n \t    {\n-\t      if (cgraph_dump_file)\n-\t\tfprintf (cgraph_dump_file,\n-\t\t\t \"\\nConsidering %s %i insns.\\n\"\n-\t\t\t \" Called once from %s %i insns.\\n\",\n-\t\t\t cgraph_node_name (node), node->global.insns,\n-\t\t\t cgraph_node_name (node->callers->caller),\n-\t\t\t node->callers->caller->global.insns);\n-\t      ninlined = cgraph_inlined_into (node->callers->caller, inlined);\n-\t      old_insns = overall_insns;\n-\t      if (cgraph_check_inline_limits\n-\t\t  (node->callers->caller, node, inlined, ninlined))\n+\t      bool ok = true;\n+\t      struct cgraph_node *node1;\n+\n+\t      /* Verify that we won't duplicate the caller.  */\n+\t      for (node1 = node->callers->caller;\n+\t\t   node1->callers && node1->callers->inline_call\n+\t\t   && ok; node1 = node1->callers->caller)\n+\t\tif (node1->callers->next_caller || node1->needed)\n+\t\t  ok = false;\n+\t      if (ok)\n \t\t{\n-\t\t  ninlined_callees =\n-\t\t    cgraph_inlined_callees (node, inlined_callees);\n-\t\t  cgraph_mark_inline (node->callers->caller, node, inlined,\n-\t\t\t\t      ninlined, inlined_callees,\n-\t\t\t\t      ninlined_callees);\n-\t\t  for (y = 0; y < ninlined_callees; y++)\n-\t\t    inlined_callees[y]->output = 0, node->aux = 0;\n \t\t  if (cgraph_dump_file)\n \t\t    fprintf (cgraph_dump_file,\n-\t\t\t     \" Inlined into %s which now has %i insns\"\n-\t\t\t     \" for a net change of %+i insns.\\n\",\n+\t\t\t     \"\\nConsidering %s %i insns.\\n\"\n+\t\t\t     \" Called once from %s %i insns.\\n\",\n+\t\t\t     cgraph_node_name (node), node->global.insns,\n \t\t\t     cgraph_node_name (node->callers->caller),\n-\t\t\t     node->callers->caller->global.insns,\n-\t\t\t     overall_insns - old_insns);\n+\t\t\t     node->callers->caller->global.insns);\n+\t\t  ninlined = cgraph_inlined_into (node->callers->caller,\n+\t\t      \t\t\t\t  inlined);\n+\t\t  old_insns = overall_insns;\n+\t\t  if (cgraph_check_inline_limits\n+\t\t      (node->callers->caller, node, inlined, ninlined))\n+\t\t    {\n+\t\t      ninlined_callees =\n+\t\t\tcgraph_inlined_callees (node, inlined_callees);\n+\t\t      cgraph_mark_inline (node->callers->caller, node, inlined,\n+\t\t\t\t\t  ninlined, inlined_callees,\n+\t\t\t\t\t  ninlined_callees);\n+\t\t      for (y = 0; y < ninlined_callees; y++)\n+\t\t\tinlined_callees[y]->output = 0, node->aux = 0;\n+\t\t      if (cgraph_dump_file)\n+\t\t\tfprintf (cgraph_dump_file,\n+\t\t\t\t \" Inlined into %s which now has %i insns\"\n+\t\t\t\t \" for a net change of %+i insns.\\n\",\n+\t\t\t\t cgraph_node_name (node->callers->caller),\n+\t\t\t\t node->callers->caller->global.insns,\n+\t\t\t\t overall_insns - old_insns);\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      if (cgraph_dump_file)\n+\t\t\tfprintf (cgraph_dump_file,\n+\t\t\t\t \" Inline limit reached, not inlined.\\n\");\n+\t\t    }\n+\t\t  for (y = 0; y < ninlined; y++)\n+\t\t    inlined[y]->output = 0, node->aux = 0;\n \t\t}\n-\t      else\n-                {\n-\t\t  if (cgraph_dump_file)\n-\t\t    fprintf (cgraph_dump_file,\n-\t                     \" Inline limit reached, not inlined.\\n\");\n-\t        }\n-\t      for (y = 0; y < ninlined; y++)\n-\t\tinlined[y]->output = 0, node->aux = 0;\n \t    }\n \t}\n-    }\n \n-  if (cgraph_dump_file)\n-    fprintf (cgraph_dump_file,\n-\t     \"\\nInlined %i calls, eliminated %i functions, \"\n-\t     \"%i insns turned to %i insns.\\n\\n\",\n-\t     ncalls_inlined, nfunctions_inlined, initial_insns,\n-\t     overall_insns);\n-  free (order);\n-  free (inlined);\n-  free (inlined_callees);\n+      if (cgraph_dump_file)\n+\tfprintf (cgraph_dump_file,\n+\t\t \"\\nInlined %i calls, eliminated %i functions, \"\n+\t\t \"%i insns turned to %i insns.\\n\\n\",\n+\t\t ncalls_inlined, nfunctions_inlined, initial_insns,\n+\t\t overall_insns);\n+      free (order);\n+      free (inlined);\n+      free (inlined_callees);\n+    }\n }\n \n /* Decide on the inlining.  We do so in the topological order to avoid\n@@ -1242,20 +1255,24 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node)\n \t  inlined_callees[y]->output = 0, node->aux = 0;\n       }\n \n-  /* Now do the automatic inlining.  */\n-  for (e = node->callees; e; e = e->next_callee)\n-    if (e->callee->local.inlinable && !e->callee->output\n-\t&& e->callee != node && !e->inline_call\n-        && cgraph_default_inline_p (e->callee)\n-\t&& cgraph_check_inline_limits (node, e->callee, inlined,\n-\t\t\t\t       ninlined))\n-      {\n-\tninlined_callees = cgraph_inlined_callees (e->callee, inlined_callees);\n-\tcgraph_mark_inline (node, e->callee, inlined, ninlined,\n-\t\t\t    inlined_callees, ninlined_callees);\n-\tfor (y = 0; y < ninlined_callees; y++)\n-\t  inlined_callees[y]->output = 0, node->aux = 0;\n-      }\n+  if (!flag_really_no_inline)\n+    {\n+      /* Now do the automatic inlining.  */\n+      for (e = node->callees; e; e = e->next_callee)\n+\tif (e->callee->local.inlinable && !e->callee->output\n+\t    && e->callee != node && !e->inline_call\n+\t    && cgraph_default_inline_p (e->callee)\n+\t    && cgraph_check_inline_limits (node, e->callee, inlined,\n+\t\t\t\t\t   ninlined))\n+\t  {\n+\t    ninlined_callees = cgraph_inlined_callees (e->callee,\n+\t\t\t\t\t\t       inlined_callees);\n+\t    cgraph_mark_inline (node, e->callee, inlined, ninlined,\n+\t\t\t\tinlined_callees, ninlined_callees);\n+\t    for (y = 0; y < ninlined_callees; y++)\n+\t      inlined_callees[y]->output = 0, node->aux = 0;\n+\t  }\n+    }\n \n   /* Clear the flags set by cgraph_inlined_into.  */\n   for (y = 0; y < ninlined; y++)"}, {"sha": "874e83c6aca98074ac9e8aca94a341b940c1e99b", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b684a3df8e33898816611f1cefbd0068ca22beca/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b684a3df8e33898816611f1cefbd0068ca22beca/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=b684a3df8e33898816611f1cefbd0068ca22beca", "patch": "@@ -1,5 +1,5 @@\n @c Copyright (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n-@c 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n+@c 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n @c This is part of the GCC manual.\n @c For copying conditions, see the file gcc.texi.\n \n@@ -3626,7 +3626,6 @@ compilation time.\n -fmerge-constants @gol\n -fthread-jumps @gol\n -floop-optimize @gol\n--fcrossjumping @gol\n -fif-conversion @gol\n -fif-conversion2 @gol\n -fdelayed-branch @gol\n@@ -3663,7 +3662,8 @@ also turns on the following optimization flags:\n -fstrict-aliasing @gol\n -funit-at-a-time @gol\n -falign-functions  -falign-jumps @gol\n--falign-loops  -falign-labels}\n+-falign-loops  -falign-labels @gol\n+-fcrossjumping}\n \n Please note the warning under @option{-fgcse} about\n invoking @option{-O2} on programs that use computed gotos."}, {"sha": "e87accea947eaee1bca816e962ca7b34f63c6eb3", "filename": "gcc/opts.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b684a3df8e33898816611f1cefbd0068ca22beca/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b684a3df8e33898816611f1cefbd0068ca22beca/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=b684a3df8e33898816611f1cefbd0068ca22beca", "patch": "@@ -1,5 +1,5 @@\n /* Command line option handling.\n-   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.\n    Contributed by Neil Booth.\n \n This file is part of GCC.\n@@ -536,13 +536,13 @@ decode_options (unsigned int argc, const char **argv)\n       flag_guess_branch_prob = 1;\n       flag_cprop_registers = 1;\n       flag_loop_optimize = 1;\n-      flag_crossjumping = 1;\n       flag_if_conversion = 1;\n       flag_if_conversion2 = 1;\n     }\n \n   if (optimize >= 2)\n     {\n+      flag_crossjumping = 1;\n       flag_optimize_sibling_calls = 1;\n       flag_cse_follow_jumps = 1;\n       flag_cse_skip_blocks = 1;"}, {"sha": "f366e39c9a60171e00c3ef2b5382ceaed4f09b22", "filename": "gcc/recog.c", "status": "modified", "additions": 30, "deletions": 8, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b684a3df8e33898816611f1cefbd0068ca22beca/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b684a3df8e33898816611f1cefbd0068ca22beca/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=b684a3df8e33898816611f1cefbd0068ca22beca", "patch": "@@ -1,6 +1,6 @@\n /* Subroutines used by or related to instruction recognition.\n    Copyright (C) 1987, 1988, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998\n-   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -476,16 +476,38 @@ validate_replace_rtx_1 (rtx *loc, rtx from, rtx to, rtx object)\n       return;\n     }\n \n-  /* Call ourself recursively to perform the replacements.  */\n+  /* Call ourself recursively to perform the replacements.\n+     We must not replace inside already replaced expression, otherwise we\n+     get infinite recursion for replacements like (reg X)->(subreg (reg X))\n+     done by regmove, so we must special case shared ASM_OPERANDS.  */\n \n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+  if (GET_CODE (x) == PARALLEL)\n     {\n-      if (fmt[i] == 'e')\n-\tvalidate_replace_rtx_1 (&XEXP (x, i), from, to, object);\n-      else if (fmt[i] == 'E')\n-\tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t  validate_replace_rtx_1 (&XVECEXP (x, i, j), from, to, object);\n+      for (j = XVECLEN (x, 0) - 1; j >= 0; j--)\n+\t{\n+\t  if (j && GET_CODE (XVECEXP (x, 0, j)) == SET\n+\t      && GET_CODE (SET_SRC (XVECEXP (x, 0, j))) == ASM_OPERANDS)\n+\t    {\n+\t      /* Verify that operands are really shared.  */\n+\t      if (ASM_OPERANDS_INPUT_VEC (SET_SRC (XVECEXP (x, 0, 0))) !=\n+\t\t  ASM_OPERANDS_INPUT_VEC (SET_SRC (XVECEXP (x, 0, j))))\n+\t\tabort ();\n+\t      validate_replace_rtx_1 (&SET_DEST (XVECEXP (x, 0, j)),\n+\t\t\t\t      from, to, object);\n+\t    }\n+\t  else\n+\t    validate_replace_rtx_1 (&XVECEXP (x, 0, j), from, to, object);\n+\t}\n     }\n+  else\n+    for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+      {\n+\tif (fmt[i] == 'e')\n+\t  validate_replace_rtx_1 (&XEXP (x, i), from, to, object);\n+\telse if (fmt[i] == 'E')\n+\t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t    validate_replace_rtx_1 (&XVECEXP (x, i, j), from, to, object);\n+      }\n \n   /* If we didn't substitute, there is nothing more to do.  */\n   if (num_changes == prev_changes)"}, {"sha": "9a5e72658f6d562257e07bc8ec1051b4c92e3d47", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b684a3df8e33898816611f1cefbd0068ca22beca/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b684a3df8e33898816611f1cefbd0068ca22beca/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b684a3df8e33898816611f1cefbd0068ca22beca", "patch": "@@ -1,3 +1,9 @@\n+2004-01-01  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.dg/debug/20031231-1.c: New.\n+\t* gcc.c-torture/compile/20040101-1.c: New.\n+\t* gcc.dg/dwarf-die-[1-7].c: New.\n+\n 2004-01-01  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR optimization/13521"}, {"sha": "7ddef7d00ee40703cf6cb8929f47d3889ae3aa62", "filename": "gcc/testsuite/gcc.c-torture/compile/20040101-1.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b684a3df8e33898816611f1cefbd0068ca22beca/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20040101-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b684a3df8e33898816611f1cefbd0068ca22beca/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20040101-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20040101-1.c?ref=b684a3df8e33898816611f1cefbd0068ca22beca", "patch": "@@ -0,0 +1,28 @@\n+typedef unsigned short uint16_t;\n+typedef unsigned int uint32_t;\n+\n+#define CF (1<<0)\n+#define PF (1<<2)\n+#define AF (1<<4)\n+#define ZF (1<<6)\n+#define SF (1<<7)\n+#define OF (1<<11)\n+\n+#define EFLAGS_BITS (CF|PF|AF|ZF|SF|OF)\n+\n+void test16(uint16_t x, uint32_t eflags)\n+{\n+        uint16_t bsr_result;\n+        uint32_t bsr_eflags;\n+        uint16_t bsf_result;\n+        uint32_t bsf_eflags;\n+\n+        __asm volatile(\"\"\n+                : \"=&r\" (bsr_result), \"=&r\" (bsr_eflags)\n+                : \"r\" (x), \"i\" (~EFLAGS_BITS), \"r\" (eflags));\n+        __asm volatile(\"\"\n+                : \"=&r\" (bsf_result), \"=&r\" (bsf_eflags)\n+                : \"r\" (x), \"i\" (~EFLAGS_BITS), \"r\" (eflags));\n+        printf(\"%08x %04x bsrw %02x %08x bsfw %02x %08x\\n\",\n+                x, eflags, bsr_result, bsr_eflags, bsf_result, bsf_eflags);\n+}"}, {"sha": "08e7ac49d7fe4f8cd08c692a7bf877de05c00537", "filename": "gcc/testsuite/gcc.dg/debug/20031231-1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b684a3df8e33898816611f1cefbd0068ca22beca/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2F20031231-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b684a3df8e33898816611f1cefbd0068ca22beca/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2F20031231-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2F20031231-1.c?ref=b684a3df8e33898816611f1cefbd0068ca22beca", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+\n+/* We used to fail because GCC didn't expect always inline to be inlined at\n+   -O0.  */\n+typedef union tree_node *tree;\n+typedef struct c_pretty_print_info c_pretty_printer;\n+\n+\n+void pp_c_string_literal (c_pretty_printer *, tree);\n+\n+\n+static __inline__  __attribute__((always_inline)) void\n+pp_c_shift_expression (c_pretty_printer *pp, tree e)\n+{\n+        pp_c_shift_expression (pp,e);\n+}\n+\n+static void\n+pp_c_relational_expression (c_pretty_printer *pp, tree e)\n+{\n+        pp_c_shift_expression (pp, e);\n+}"}, {"sha": "39f0bf2792a17df0e5f1c135ae91fcc3f0303cdf", "filename": "gcc/testsuite/gcc.dg/dwarf-die1.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b684a3df8e33898816611f1cefbd0068ca22beca/gcc%2Ftestsuite%2Fgcc.dg%2Fdwarf-die1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b684a3df8e33898816611f1cefbd0068ca22beca/gcc%2Ftestsuite%2Fgcc.dg%2Fdwarf-die1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdwarf-die1.c?ref=b684a3df8e33898816611f1cefbd0068ca22beca", "patch": "@@ -0,0 +1,8 @@\n+/* Verify that inline function never actually inlined has no abstract DIE.  */\n+/* { dg-do compile */\n+/* { dg-options \"-O2 -gdwarf-2 -dA\" } */\n+/* { dg-final { scan-assembler-not \"DW_AT_inline\" } } */\n+inline int t()\n+{\n+}\n+int (*q)()=t;"}, {"sha": "48bce243d41f7e5f4033e1777b50cc93cea81bfa", "filename": "gcc/testsuite/gcc.dg/dwarf-die2.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b684a3df8e33898816611f1cefbd0068ca22beca/gcc%2Ftestsuite%2Fgcc.dg%2Fdwarf-die2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b684a3df8e33898816611f1cefbd0068ca22beca/gcc%2Ftestsuite%2Fgcc.dg%2Fdwarf-die2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdwarf-die2.c?ref=b684a3df8e33898816611f1cefbd0068ca22beca", "patch": "@@ -0,0 +1,7 @@\n+/* Verify that inline function never actually emit has no DIE.  */\n+/* { dg-do compile */\n+/* { dg-options \"-O0 -gdwarf-2 -dA\" } */\n+/* { dg-final { scan-assembler-not \"CIE Version\" } } */\n+static inline int t()\n+{\n+}"}, {"sha": "34fddfaffc08f9c832379729a2d18574c5c8209a", "filename": "gcc/testsuite/gcc.dg/dwarf-die3.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b684a3df8e33898816611f1cefbd0068ca22beca/gcc%2Ftestsuite%2Fgcc.dg%2Fdwarf-die3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b684a3df8e33898816611f1cefbd0068ca22beca/gcc%2Ftestsuite%2Fgcc.dg%2Fdwarf-die3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdwarf-die3.c?ref=b684a3df8e33898816611f1cefbd0068ca22beca", "patch": "@@ -0,0 +1,11 @@\n+/* Verify that extern inline function never actually inlined has no abstract DIE.  */\n+/* { dg-do compile */\n+/* { dg-options \"-O0 -gdwarf-2 -dA\" } */\n+/* { dg-final { scan-assembler-not \"DW_AT_inline\" } } */\n+extern inline int t()\n+{\n+}\n+int (*q)()=t;\n+int t()\n+{\n+}"}, {"sha": "b3a245d2b1102fd1a9c4b3f0537b34e01bf9a98b", "filename": "gcc/testsuite/gcc.dg/dwarf-die5.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b684a3df8e33898816611f1cefbd0068ca22beca/gcc%2Ftestsuite%2Fgcc.dg%2Fdwarf-die5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b684a3df8e33898816611f1cefbd0068ca22beca/gcc%2Ftestsuite%2Fgcc.dg%2Fdwarf-die5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdwarf-die5.c?ref=b684a3df8e33898816611f1cefbd0068ca22beca", "patch": "@@ -0,0 +1,12 @@\n+/* Inlined inline function must have abstract DIE  */\n+/* { dg-do compile */\n+/* { dg-options \"-O2 -gdwarf-2 -dA -fpreprocessed\" } */\n+/* { dg-final { scan-assembler \"3.*DW_AT_inline\" } } */\n+#1 \"test.h\"\n+inline int t()\n+{\n+}\n+int q()\n+{\n+  t();\n+}"}, {"sha": "40cdc8dee37ea0191ae3f58c22acf8159163825e", "filename": "gcc/testsuite/gcc.dg/dwarf-die6.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b684a3df8e33898816611f1cefbd0068ca22beca/gcc%2Ftestsuite%2Fgcc.dg%2Fdwarf-die6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b684a3df8e33898816611f1cefbd0068ca22beca/gcc%2Ftestsuite%2Fgcc.dg%2Fdwarf-die6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdwarf-die6.c?ref=b684a3df8e33898816611f1cefbd0068ca22beca", "patch": "@@ -0,0 +1,12 @@\n+/* not inline inline function must not have abstract DIE  */\n+/* { dg-do compile */\n+/* { dg-options \"-O2 -fno-inline -gdwarf-2 -dA -fpreprocessed\" } */\n+/* { dg-final { scan-assembler-not \"DW_AT_inline\" } } */\n+#1 \"test.h\"\n+inline int t()\n+{\n+}\n+int q()\n+{\n+  t();\n+}"}, {"sha": "d8d013af38c22c124562cdbcf4004d69434c2391", "filename": "gcc/testsuite/gcc.dg/dwarf-die7.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b684a3df8e33898816611f1cefbd0068ca22beca/gcc%2Ftestsuite%2Fgcc.dg%2Fdwarf-die7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b684a3df8e33898816611f1cefbd0068ca22beca/gcc%2Ftestsuite%2Fgcc.dg%2Fdwarf-die7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdwarf-die7.c?ref=b684a3df8e33898816611f1cefbd0068ca22beca", "patch": "@@ -0,0 +1,14 @@\n+/* Inlined non-inline function must have abstract DIE  */\n+/* { dg-do compile */\n+/* { dg-options \"-O2 -gdwarf-2 -dA -fpreprocessed\" } */\n+/* { dg-final { scan-assembler \"1.*DW_AT_inline\" } } */\n+#1 \"test.h\"\n+void f(void);\n+static int t()\n+{\n+\tf();\n+}\n+int q()\n+{\n+  t();\n+}"}, {"sha": "2219fe8a543375b5e36fdf1d148f2cf7d6a56afc", "filename": "gcc/toplev.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b684a3df8e33898816611f1cefbd0068ca22beca/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b684a3df8e33898816611f1cefbd0068ca22beca/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=b684a3df8e33898816611f1cefbd0068ca22beca", "patch": "@@ -1,6 +1,6 @@\n /* Top level of GCC compilers (cc1, cc1plus, etc.)\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -277,8 +277,8 @@ enum dump_file_index\n   DFI_flow2,\n   DFI_peephole2,\n   DFI_rnreg,\n-  DFI_bbro,\n   DFI_ce3,\n+  DFI_bbro,\n   DFI_branch_target_load,\n   DFI_sched2,\n   DFI_stack,\n@@ -328,8 +328,8 @@ static struct dump_file_info dump_file[DFI_MAX] =\n   { \"flow2\",\t'w', 1, 0, 0 },\n   { \"peephole2\", 'z', 1, 0, 0 },\n   { \"rnreg\",\t'n', 1, 0, 0 },\n-  { \"bbro\",\t'B', 1, 0, 0 },\n   { \"ce3\",\t'E', 1, 0, 0 },\n+  { \"bbro\",\t'B', 1, 0, 0 },\n   { \"btl\",\t'd', 1, 0, 0 }, /* Yes, duplicate enable switch.  */\n   { \"sched2\",\t'R', 1, 0, 0 },\n   { \"stack\",\t'k', 1, 0, 0 },\n@@ -3463,14 +3463,6 @@ rest_of_compilation (tree decl)\n     }\n #endif\n \n-  if (optimize > 0)\n-    {\n-      if (flag_rename_registers || flag_cprop_registers)\n-\trest_of_handle_regrename (decl, insns);\n-\n-      rest_of_handle_reorder_blocks (decl, insns);\n-    }\n-\n   if (flag_if_conversion2)\n     {\n       timevar_push (TV_IFCVT2);\n@@ -3482,23 +3474,31 @@ rest_of_compilation (tree decl)\n       timevar_pop (TV_IFCVT2);\n     }\n \n-    if (flag_branch_target_load_optimize2)\n-      {\n-\t/* Leave this a warning for now so that it is possible to experiment\n-\t   with running this pass twice.  In 3.6, we should either make this\n-\t   an error, or use separate dump files.  */\n-\tif (flag_branch_target_load_optimize)\n-\t  warning (\"branch target register load optimization is not intended \"\n-\t\t   \"to be run twice\");\n+  if (optimize > 0)\n+    {\n+      if (flag_rename_registers || flag_cprop_registers)\n+\trest_of_handle_regrename (decl, insns);\n \n-\topen_dump_file (DFI_branch_target_load, decl);\n+      rest_of_handle_reorder_blocks (decl, insns);\n+    }\n+\n+  if (flag_branch_target_load_optimize2)\n+    {\n+      /* Leave this a warning for now so that it is possible to experiment\n+\t with running this pass twice.  In 3.6, we should either make this\n+\t an error, or use separate dump files.  */\n+      if (flag_branch_target_load_optimize)\n+\twarning (\"branch target register load optimization is not intended \"\n+\t\t \"to be run twice\");\n \n-\tbranch_target_load_optimize (insns, true);\n+      open_dump_file (DFI_branch_target_load, decl);\n \n-\tclose_dump_file (DFI_branch_target_load, print_rtl_with_bb, insns);\n+      branch_target_load_optimize (insns, true);\n \n-\tggc_collect ();\n-      }\n+      close_dump_file (DFI_branch_target_load, print_rtl_with_bb, insns);\n+\n+      ggc_collect ();\n+    }\n \n #ifdef INSN_SCHEDULING\n   if (optimize > 0 && flag_schedule_insns_after_reload)"}]}