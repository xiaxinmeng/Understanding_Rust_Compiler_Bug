{"sha": "b86ba9c89d0446621f23af72bc7e4e88f3ed01c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjg2YmE5Yzg5ZDA0NDY2MjFmMjNhZjcyYmM3ZTRlODhmM2VkMDFjMw==", "commit": {"author": {"name": "Geoff Keating", "email": "geoffk@ozemail.com.au", "date": "1998-09-15T23:32:22Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-09-15T23:32:22Z"}, "message": "gcse.c: New definition NEVER_SET for reg_first_set...\n\n        * gcse.c: New definition NEVER_SET for reg_first_set, reg_last_set,\n        mem_first_set, mem_last_set; because 0 can be a CUID.\n        (oprs_unchanged_p): Use new definition.\n        (record_last_reg_set_info): Likewise.\n        (record_last_mem_set_info): Likewise.\n        (compute_hash_table): Likewise.\n\nFrom-SVN: r22441", "tree": {"sha": "a494e24c2826b77cc1c16bc6c0b4f510486c71b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a494e24c2826b77cc1c16bc6c0b4f510486c71b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b86ba9c89d0446621f23af72bc7e4e88f3ed01c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b86ba9c89d0446621f23af72bc7e4e88f3ed01c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b86ba9c89d0446621f23af72bc7e4e88f3ed01c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b86ba9c89d0446621f23af72bc7e4e88f3ed01c3/comments", "author": null, "committer": null, "parents": [{"sha": "fa88e837bfe83bfced127267f20c28ddec97b22d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa88e837bfe83bfced127267f20c28ddec97b22d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa88e837bfe83bfced127267f20c28ddec97b22d"}], "stats": {"total": 32, "additions": 22, "deletions": 10}, "files": [{"sha": "20bc7c6d928bc8a8db1be3a1474e19499688f809", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b86ba9c89d0446621f23af72bc7e4e88f3ed01c3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b86ba9c89d0446621f23af72bc7e4e88f3ed01c3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b86ba9c89d0446621f23af72bc7e4e88f3ed01c3", "patch": "@@ -1,3 +1,12 @@\n+Wed Sep 16 00:30:56 1998  Geoff Keating  <geoffk@ozemail.com.au>\n+\n+\t* gcse.c: New definition NEVER_SET for reg_first_set, reg_last_set,\n+\tmem_first_set, mem_last_set; because 0 can be a CUID.\n+\t(oprs_unchanged_p): Use new definition.\n+\t(record_last_reg_set_info): Likewise.\n+\t(record_last_mem_set_info): Likewise.\n+\t(compute_hash_table): Likewise.\n+\n Tue Sep 15 22:59:52 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* mn10200.h (ASM_OUTPUT_DWARF2_ADDR_CONST): Define."}, {"sha": "f0efdb7a4aca73e4e8d082cfb01b01a4c1e64818", "filename": "gcc/gcse.c", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b86ba9c89d0446621f23af72bc7e4e88f3ed01c3/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b86ba9c89d0446621f23af72bc7e4e88f3ed01c3/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=b86ba9c89d0446621f23af72bc7e4e88f3ed01c3", "patch": "@@ -1055,6 +1055,8 @@ compute_sets (f)\n \f\n /* Hash table support.  */\n \n+#define NEVER_SET -1\n+\n /* For each register, the cuid of the first/last insn in the block to set it,\n    or zero if not set.  */\n static int *reg_first_set;\n@@ -1130,22 +1132,22 @@ oprs_unchanged_p (x, insn, avail_p)\n     {\n     case REG:\n       if (avail_p)\n-\treturn (reg_last_set[REGNO (x)] == 0\n+\treturn (reg_last_set[REGNO (x)] == NEVER_SET\n \t\t|| reg_last_set[REGNO (x)] < INSN_CUID (insn));\n       else\n-\treturn (reg_first_set[REGNO (x)] == 0\n+\treturn (reg_first_set[REGNO (x)] == NEVER_SET\n \t\t|| reg_first_set[REGNO (x)] >= INSN_CUID (insn));\n \n     case MEM:\n       if (avail_p)\n \t{\n-\t  if (mem_last_set != 0\n+\t  if (mem_last_set != NEVER_SET\n \t      && mem_last_set >= INSN_CUID (insn))\n \t    return 0;\n \t}\n       else\n \t{\n-\t  if (mem_first_set != 0\n+\t  if (mem_first_set != NEVER_SET\n \t      && mem_first_set < INSN_CUID (insn))\n \t    return 0;\n \t}\n@@ -1959,7 +1961,7 @@ record_last_reg_set_info (insn, regno)\n      rtx insn;\n      int regno;\n {\n-  if (reg_first_set[regno] == 0)\n+  if (reg_first_set[regno] == NEVER_SET)\n     reg_first_set[regno] = INSN_CUID (insn);\n   reg_last_set[regno] = INSN_CUID (insn);\n   SET_BIT (reg_set_in_block[BLOCK_NUM (insn)], regno);\n@@ -1971,7 +1973,7 @@ static void\n record_last_mem_set_info (insn)\n      rtx insn;\n {\n-  if (mem_first_set == 0)\n+  if (mem_first_set == NEVER_SET)\n     mem_first_set = INSN_CUID (insn);\n   mem_last_set = INSN_CUID (insn);\n   mem_set_in_block[BLOCK_NUM (insn)] = 1;\n@@ -2041,16 +2043,17 @@ compute_hash_table (f, set_p)\n       rtx insn;\n       int regno;\n       int in_libcall_block;\n+      int i;\n \n       /* First pass over the instructions records information used to\n \t determine when registers and memory are first and last set.\n \t ??? The mem_set_in_block and hard-reg reg_set_in_block computation\n \t could be moved to compute_sets since they currently don't change.  */\n \n-      bzero ((char *) reg_first_set, max_gcse_regno * sizeof (int));\n-      bzero ((char *) reg_last_set, max_gcse_regno * sizeof (int));\n-      mem_first_set = 0;\n-      mem_last_set = 0;\n+      for (i = 0; i < max_gcse_regno; i++)\n+\treg_first_set[i] = reg_last_set[i] = NEVER_SET;\n+      mem_first_set = NEVER_SET;\n+      mem_last_set = NEVER_SET;\n \n       for (insn = basic_block_head[bb];\n \t   insn && insn != NEXT_INSN (basic_block_end[bb]);"}]}