{"sha": "03378143aca4cb4276e6fb1d2f790ea58bdcaa86", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDMzNzgxNDNhY2E0Y2I0Mjc2ZTZmYjFkMmY3OTBlYTU4YmRjYWE4Ng==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2001-01-03T14:39:10Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2001-01-03T14:39:10Z"}, "message": "Implement exceptions specifiers for implicit member functions.\n\ncp:\n\tImplement exceptions specifiers for implicit member functions.\n\t* cp-tree.h (merge_exceptions_specifiers): Declare new function.\n\t* method.c (synthesize_exception_spec): New function.\n\t(locate_dtor, locate_ctor, locate_copy): New functions.\n\t(implicitly_declare_fn): Generate the exception spec too.\n\t* search.c (check_final_overrider): Check artificial functions\n\ttoo.\n\t* typeck2.c (merge_exception_specifiers): New function.\ntestsuite:\n\t* g++.old-deja/g++.eh/spec6.C: Remove remaining XFAIL.\n\nFrom-SVN: r38659", "tree": {"sha": "acdad70455870f766fb7e96793203aa55d4c5eb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/acdad70455870f766fb7e96793203aa55d4c5eb1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03378143aca4cb4276e6fb1d2f790ea58bdcaa86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03378143aca4cb4276e6fb1d2f790ea58bdcaa86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03378143aca4cb4276e6fb1d2f790ea58bdcaa86", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03378143aca4cb4276e6fb1d2f790ea58bdcaa86/comments", "author": null, "committer": null, "parents": [{"sha": "fc5769d98c11b8e31c6e800cc90d751dd1ab9fc8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc5769d98c11b8e31c6e800cc90d751dd1ab9fc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc5769d98c11b8e31c6e800cc90d751dd1ab9fc8"}], "stats": {"total": 246, "additions": 234, "deletions": 12}, "files": [{"sha": "bee60d6bbc1060abcbbef3c540ab5d4bfaf2cf02", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03378143aca4cb4276e6fb1d2f790ea58bdcaa86/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03378143aca4cb4276e6fb1d2f790ea58bdcaa86/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=03378143aca4cb4276e6fb1d2f790ea58bdcaa86", "patch": "@@ -1,3 +1,14 @@\n+2001-01-03  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tImplement exceptions specifiers for implicit member functions.\n+\t* cp-tree.h (merge_exceptions_specifiers): Declare new function.\n+\t* method.c (synthesize_exception_spec): New function.\n+\t(locate_dtor, locate_ctor, locate_copy): New functions.\n+\t(implicitly_declare_fn): Generate the exception spec too.\n+\t* search.c (check_final_overrider): Check artificial functions\n+\ttoo.\n+\t* typeck2.c (merge_exception_specifiers): New function.\t\n+\n 2001-01-03  Jason Merrill  <jason@redhat.com>\n \n \t* init.c (build_default_init): New fn."}, {"sha": "05318657a50c7023866774728237f02019c9235f", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03378143aca4cb4276e6fb1d2f790ea58bdcaa86/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03378143aca4cb4276e6fb1d2f790ea58bdcaa86/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=03378143aca4cb4276e6fb1d2f790ea58bdcaa86", "patch": "@@ -4532,6 +4532,7 @@ extern tree build_m_component_ref\t\tPARAMS ((tree, tree));\n extern tree build_functional_cast\t\tPARAMS ((tree, tree));\n extern void check_for_new_type\t\t\tPARAMS ((const char *, flagged_type_tree));\n extern tree add_exception_specifier             PARAMS ((tree, tree, int));\n+extern tree merge_exception_specifiers          PARAMS ((tree, tree));\n \n /* in xref.c */\n extern void GNU_xref_begin\t\t\tPARAMS ((const char *));"}, {"sha": "574d6ecf47111f2eb74c9a3a94e841fc0e294915", "filename": "gcc/cp/method.c", "status": "modified", "additions": 180, "deletions": 4, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03378143aca4cb4276e6fb1d2f790ea58bdcaa86/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03378143aca4cb4276e6fb1d2f790ea58bdcaa86/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=03378143aca4cb4276e6fb1d2f790ea58bdcaa86", "patch": "@@ -98,6 +98,10 @@ static int is_back_referenceable_type PARAMS ((tree));\n static int check_btype PARAMS ((tree));\n static void build_mangled_name_for_type PARAMS ((tree));\n static void build_mangled_name_for_type_with_Gcode PARAMS ((tree, int));\n+static tree synthesize_exception_spec PARAMS ((tree, tree (*) (tree, void *), void *));\n+static tree locate_dtor PARAMS ((tree, void *));\n+static tree locate_ctor PARAMS ((tree, void *));\n+static tree locate_copy PARAMS ((tree, void *));\n \n # define OB_INIT() (scratch_firstobj ? (obstack_free (&scratch_obstack, scratch_firstobj), 0) : 0)\n # define OB_PUTC(C) (obstack_1grow (&scratch_obstack, (C)))\n@@ -2585,6 +2589,163 @@ synthesize_method (fndecl)\n     pop_function_context_from (context);\n }\n \n+/* Use EXTRACTOR to locate the relevant function called for each base &\n+   class field of TYPE. CLIENT allows additional information to be passed\n+   to EXTRACTOR.  Generates the union of all exceptions generated by\n+   those functions.  */\n+\n+static tree\n+synthesize_exception_spec (type, extractor, client)\n+     tree type;\n+     tree (*extractor) (tree, void *);\n+     void *client;\n+{\n+  tree raises = empty_except_spec;\n+  tree fields = TYPE_FIELDS (type);\n+  int i, n_bases = CLASSTYPE_N_BASECLASSES (type);\n+  tree binfos = TYPE_BINFO_BASETYPES (type);\n+  \n+  for (i = 0; i != n_bases; i++)\n+    {\n+      tree base = BINFO_TYPE (TREE_VEC_ELT (binfos, i));\n+      tree fn = (*extractor) (base, client);\n+      if (fn)\n+        {\n+          tree fn_raises = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (fn));\n+          \n+          raises = merge_exception_specifiers (raises, fn_raises);\n+        }\n+    }\n+  for (; fields; fields = TREE_CHAIN (fields))\n+    {\n+      tree type = TREE_TYPE (fields);\n+      tree fn;\n+      \n+      if (TREE_CODE (fields) != FIELD_DECL)\n+        continue;\n+      while (TREE_CODE (type) == ARRAY_TYPE)\n+  \ttype = TREE_TYPE (type);\n+      if (TREE_CODE (type) != RECORD_TYPE)\n+        continue;\n+      \n+      fn = (*extractor) (type, client);\n+      if (fn)\n+        {\n+          tree fn_raises = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (fn));\n+          \n+          raises = merge_exception_specifiers (raises, fn_raises);\n+        }\n+    }\n+  return raises;\n+}\n+\n+/* Locate the dtor of TYPE.  */\n+\n+static tree\n+locate_dtor (type, client)\n+     tree type;\n+     void *client ATTRIBUTE_UNUSED;\n+{\n+  tree fns;\n+  \n+  if (!TYPE_HAS_DESTRUCTOR (type))\n+    return NULL_TREE;\n+  fns = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type),\n+                      CLASSTYPE_DESTRUCTOR_SLOT);\n+  return fns;\n+}\n+\n+/* Locate the default ctor of TYPE.  */\n+\n+static tree\n+locate_ctor (type, client)\n+     tree type;\n+     void *client ATTRIBUTE_UNUSED;\n+{\n+  tree fns;\n+  \n+  if (!TYPE_HAS_DEFAULT_CONSTRUCTOR (type))\n+    return NULL_TREE;\n+  \n+  fns = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type),\n+                      CLASSTYPE_CONSTRUCTOR_SLOT);\n+  for (; fns; fns = OVL_NEXT (fns))\n+    {\n+      tree fn = OVL_CURRENT (fns);\n+      tree parms = TYPE_ARG_TYPES (TREE_TYPE (fn));\n+      \n+      if (sufficient_parms_p (TREE_CHAIN (parms)))\n+        return fn;\n+    }\n+  return NULL_TREE;\n+}\n+\n+struct copy_data\n+{\n+  tree name;\n+  int quals;\n+};\n+\n+/* Locate the copy ctor or copy assignment of TYPE. CLIENT_\n+   points to a COPY_DATA holding the name (NULL for the ctor)\n+   and desired qualifiers of the source operand.  */\n+\n+static tree\n+locate_copy (type, client_)\n+     tree type;\n+     void *client_;\n+{\n+  struct copy_data *client = (struct copy_data *)client_;\n+  tree fns;\n+  int ix = -1;\n+  tree best = NULL_TREE;\n+  int excess_p = 0;\n+  \n+  if (client->name)\n+    {\n+      if (TYPE_HAS_ASSIGN_REF (type))\n+        ix = lookup_fnfields_1 (type, client->name);\n+    }\n+  else if (TYPE_HAS_INIT_REF (type))\n+    ix = CLASSTYPE_CONSTRUCTOR_SLOT;\n+  if (ix < 0)\n+    return NULL_TREE;\n+  fns = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type), ix);\n+  \n+  for (; fns; fns = OVL_NEXT (fns))\n+    {\n+      tree fn = OVL_CURRENT (fns);\n+      tree parms = TYPE_ARG_TYPES (TREE_TYPE (fn));\n+      tree src_type;\n+      int excess;\n+      int quals;\n+      \n+      parms = TREE_CHAIN (parms);\n+      if (!parms)\n+        continue;\n+      src_type = TREE_VALUE (parms);\n+      if (TREE_CODE (src_type) == REFERENCE_TYPE)\n+        src_type = TREE_TYPE (src_type);\n+      if (!same_type_ignoring_top_level_qualifiers_p (src_type, type))\n+        continue;\n+      if (!sufficient_parms_p (TREE_CHAIN (parms)))\n+        continue;\n+      quals = CP_TYPE_QUALS (src_type);\n+      if (client->quals & ~quals)\n+        continue;\n+      excess = quals & ~client->quals;\n+      if (!best || (excess_p && !excess))\n+        {\n+          best = fn;\n+          excess_p = excess;\n+        }\n+      else\n+        /* Ambiguous */\n+        return NULL_TREE;\n+    }\n+  return best;\n+}\n+\n /* Implicitly declare the special function indicated by KIND, as a\n    member of TYPE.  For copy constructors and assignment operators,\n    CONST_P indicates whether these functions should take a const\n@@ -2598,34 +2759,46 @@ implicitly_declare_fn (kind, type, const_p)\n {\n   tree declspecs = NULL_TREE;\n   tree fn, args = NULL_TREE;\n+  tree raises = empty_except_spec;\n   tree argtype;\n   int retref = 0;\n   tree name = constructor_name (TYPE_IDENTIFIER (type));\n \n   switch (kind)\n     {\n-      /* Destructors.  */\n     case sfk_destructor:\n+      /* Destructor.  */\n       name = build_parse_node (BIT_NOT_EXPR, name);\n       args = void_list_node;\n+      raises = synthesize_exception_spec (type, &locate_dtor, 0);\n       break;\n \n     case sfk_constructor:\n       /* Default constructor.  */\n       args = void_list_node;\n+      raises = synthesize_exception_spec (type, &locate_ctor, 0);\n       break;\n \n     case sfk_copy_constructor:\n+    {\n+      struct copy_data data;\n+      \n       if (const_p)\n \ttype = build_qualified_type (type, TYPE_QUAL_CONST);\n       argtype = build_reference_type (type);\n       args = tree_cons (NULL_TREE,\n \t\t\tbuild_tree_list (hash_tree_chain (argtype, NULL_TREE),\n \t\t\t\t\t get_identifier (\"_ctor_arg\")),\n \t\t\tvoid_list_node);\n+      data.name = NULL;\n+      data.quals = const_p ? TYPE_QUAL_CONST : 0;\n+      raises = synthesize_exception_spec (type, &locate_copy, &data);\n       break;\n-\n+    }\n     case sfk_assignment_operator:\n+    {\n+      struct copy_data data;\n+      \n       retref = 1;\n       declspecs = build_tree_list (NULL_TREE, type);\n \n@@ -2639,16 +2812,19 @@ implicitly_declare_fn (kind, type, const_p)\n \t\t\tbuild_tree_list (hash_tree_chain (argtype, NULL_TREE),\n \t\t\t\t\t get_identifier (\"_ctor_arg\")),\n \t\t\tvoid_list_node);\n+      data.name = name;\n+      data.quals = const_p ? TYPE_QUAL_CONST : 0;\n+      raises = synthesize_exception_spec (type, &locate_copy, &data);\n       break;\n-\n+    }\n     default:\n       my_friendly_abort (59);\n     }\n \n   TREE_PARMLIST (args) = 1;\n \n   {\n-    tree declarator = make_call_declarator (name, args, NULL_TREE, NULL_TREE);\n+    tree declarator = make_call_declarator (name, args, NULL_TREE, raises);\n     if (retref)\n       declarator = build_parse_node (ADDR_EXPR, declarator);\n "}, {"sha": "e2fab522fa959809fc41c46cb183e9a8cc2c5f74", "filename": "gcc/cp/search.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03378143aca4cb4276e6fb1d2f790ea58bdcaa86/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03378143aca4cb4276e6fb1d2f790ea58bdcaa86/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=03378143aca4cb4276e6fb1d2f790ea58bdcaa86", "patch": "@@ -1964,10 +1964,7 @@ check_final_overrider (overrider, basefn)\n     }\n   \n   /* Check throw specifier is subset.  */\n-  /* XXX At the moment, punt with artificial functions. We\n-     don't generate their exception specifiers, so can't check properly.  */\n-  if (! DECL_ARTIFICIAL (overrider)\n-      && !comp_except_specs (base_throw, over_throw, 0))\n+  if (!comp_except_specs (base_throw, over_throw, 0))\n     {\n       cp_error_at (\"looser throw specifier for `%#F'\", overrider);\n       cp_error_at (\"  overriding `%#F'\", basefn);"}, {"sha": "5cccddcfe34a1111029aa677a73133f3d2b16ead", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03378143aca4cb4276e6fb1d2f790ea58bdcaa86/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03378143aca4cb4276e6fb1d2f790ea58bdcaa86/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=03378143aca4cb4276e6fb1d2f790ea58bdcaa86", "patch": "@@ -1296,3 +1296,39 @@ add_exception_specifier (list, spec, complain)\n     incomplete_type_error (NULL_TREE, core);\n   return list;\n }\n+\n+/* Combine the two exceptions specifier lists LIST and ADD, and return\n+   their union. */\n+\n+tree\n+merge_exception_specifiers (list, add)\n+     tree list, add;\n+{\n+  if (!list || !add)\n+    return NULL_TREE;\n+  else if (!TREE_VALUE (list))\n+    return add;\n+  else if (!TREE_VALUE (add))\n+    return list;\n+  else\n+    {\n+      tree orig_list = list;\n+      \n+      for (; add; add = TREE_CHAIN (add))\n+        {\n+          tree spec = TREE_VALUE (add);\n+          tree probe;\n+          \n+          for (probe = orig_list; probe; probe = TREE_CHAIN (probe))\n+            if (same_type_p (TREE_VALUE (probe), spec))\n+              break;\n+          if (!probe)\n+            {\n+              spec = build_tree_list (NULL_TREE, spec);\n+              TREE_CHAIN (spec) = list;\n+              list = spec;\n+            }\n+        }\n+    }\n+  return list;\n+}"}, {"sha": "c45ae5cbef852a9ed428827c13d76f514be7085b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03378143aca4cb4276e6fb1d2f790ea58bdcaa86/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03378143aca4cb4276e6fb1d2f790ea58bdcaa86/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=03378143aca4cb4276e6fb1d2f790ea58bdcaa86", "patch": "@@ -1,3 +1,7 @@\n+2001-01-03  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* g++.old-deja/g++.eh/spec6.C: Remove remaining XFAIL.\n+\n 2001-01-02  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* gcc.c-torture/compile/20010102-1.c: New test."}, {"sha": "6ecaec0b116773117d1b49aed0fde5821ea0d4ec", "filename": "gcc/testsuite/g++.old-deja/g++.eh/spec6.C", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03378143aca4cb4276e6fb1d2f790ea58bdcaa86/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fspec6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03378143aca4cb4276e6fb1d2f790ea58bdcaa86/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fspec6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fspec6.C?ref=03378143aca4cb4276e6fb1d2f790ea58bdcaa86", "patch": "@@ -126,10 +126,7 @@ struct C : A, A1\n {\n   virtual void foo() throw(int);    // ERROR - looser throw - A::foo\n   virtual void bar() throw(int);    // ERROR - looser throw - A1::bar\n-   // The xfail is because we don't build exception specifiers for implicit\n-   // members. So we don't check them either.\n-   // C::~C() throw(int), is the correct specification of the destructor.\n-}; // ERROR - looser throw - A::~A() - XFAIL\n+}; // ERROR - looser throw - A::~A()\n \n struct D : A, A1\n {"}]}