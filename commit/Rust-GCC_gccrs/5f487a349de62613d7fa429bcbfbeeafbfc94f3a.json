{"sha": "5f487a349de62613d7fa429bcbfbeeafbfc94f3a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWY0ODdhMzQ5ZGU2MjYxM2Q3ZmE0MjliY2JmYmVlYWZiZmM5NGYzYQ==", "commit": {"author": {"name": "Li Jia He", "email": "helijia@linux.ibm.com", "date": "2019-09-16T14:21:20Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2019-09-16T14:21:20Z"}, "message": "Auto-generate maybe_fold_and/or_comparisons from match.pd\n\n2019-09-16  Li Jia He  <helijia@linux.ibm.com>\n\t    Martin Liska  <mliska@suse.cz>\n\n\t* gimple-fold.c (and_comparisons_1): Add type as first\n\targument.\n\t(and_var_with_comparison): Likewise.\n\t(and_var_with_comparison_1): Likewise.\n\t(or_comparisons_1): Likewise.\n\t(or_var_with_comparison): Likewise.\n\t(or_var_with_comparison_1): Likewise.\n\t(maybe_fold_and_comparisons): Call maybe_fold_comparisons_from_match_pd.\n\t(maybe_fold_or_comparisons): Likewise.\n\t(maybe_fold_comparisons_from_match_pd): New.\n\t* gimple-fold.h (maybe_fold_and_comparisons): Add type argument.\n\t(maybe_fold_or_comparisons): Likewise.\n\t* gimple.c (gimple_size): Make it public and add num_ops argument.\n\t(gimple_init): New function.\n\t(gimple_alloc): Call gimple_init.\n\t* gimple.h (gimple_size): New.\n\t(gimple_init): Likewise.\n\t* tree-if-conv.c (fold_or_predicates): Pass type.\n\t* tree-ssa-ifcombine.c (ifcombine_ifandif): Likewise.\n\t* tree-ssa-reassoc.c (eliminate_redundant_comparison): Likewise.\n\t(optimize_vec_cond_expr): Likewise.\n\t(ovce_extract_ops): Return type of conditional expression.\n\t* tree-ssanames.c (init_ssa_name_imm_use): New.\n\t(make_ssa_name_fn): Use init_ssa_name_imm_use.\n\t* tree-ssanames.h (init_ssa_name_imm_use): New.\n\nCo-Authored-By: Martin Liska <mliska@suse.cz>\n\nFrom-SVN: r275748", "tree": {"sha": "d63d3e1bb2210eb3e25095d2dc0deab2b5ccf72a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d63d3e1bb2210eb3e25095d2dc0deab2b5ccf72a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f487a349de62613d7fa429bcbfbeeafbfc94f3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f487a349de62613d7fa429bcbfbeeafbfc94f3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f487a349de62613d7fa429bcbfbeeafbfc94f3a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f487a349de62613d7fa429bcbfbeeafbfc94f3a/comments", "author": {"login": "HLJ2009", "id": 18440836, "node_id": "MDQ6VXNlcjE4NDQwODM2", "avatar_url": "https://avatars.githubusercontent.com/u/18440836?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HLJ2009", "html_url": "https://github.com/HLJ2009", "followers_url": "https://api.github.com/users/HLJ2009/followers", "following_url": "https://api.github.com/users/HLJ2009/following{/other_user}", "gists_url": "https://api.github.com/users/HLJ2009/gists{/gist_id}", "starred_url": "https://api.github.com/users/HLJ2009/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HLJ2009/subscriptions", "organizations_url": "https://api.github.com/users/HLJ2009/orgs", "repos_url": "https://api.github.com/users/HLJ2009/repos", "events_url": "https://api.github.com/users/HLJ2009/events{/privacy}", "received_events_url": "https://api.github.com/users/HLJ2009/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "10f30ac9cda947d117e50f0cbd4cf94ee70a944f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10f30ac9cda947d117e50f0cbd4cf94ee70a944f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10f30ac9cda947d117e50f0cbd4cf94ee70a944f"}], "stats": {"total": 293, "additions": 218, "deletions": 75}, "files": [{"sha": "864da5a3034809bf9f29d7dfabe7fc700f7e5a08", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f487a349de62613d7fa429bcbfbeeafbfc94f3a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f487a349de62613d7fa429bcbfbeeafbfc94f3a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5f487a349de62613d7fa429bcbfbeeafbfc94f3a", "patch": "@@ -1,3 +1,32 @@\n+2019-09-16  Li Jia He  <helijia@linux.ibm.com>\n+\t    Martin Liska  <mliska@suse.cz>\n+\n+\t* gimple-fold.c (and_comparisons_1): Add type as first\n+\targument.\n+\t(and_var_with_comparison): Likewise.\n+\t(and_var_with_comparison_1): Likewise.\n+\t(or_comparisons_1): Likewise.\n+\t(or_var_with_comparison): Likewise.\n+\t(or_var_with_comparison_1): Likewise.\n+\t(maybe_fold_and_comparisons): Call maybe_fold_comparisons_from_match_pd.\n+\t(maybe_fold_or_comparisons): Likewise.\n+\t(maybe_fold_comparisons_from_match_pd): New.\n+\t* gimple-fold.h (maybe_fold_and_comparisons): Add type argument.\n+\t(maybe_fold_or_comparisons): Likewise.\n+\t* gimple.c (gimple_size): Make it public and add num_ops argument.\n+\t(gimple_init): New function.\n+\t(gimple_alloc): Call gimple_init.\n+\t* gimple.h (gimple_size): New.\n+\t(gimple_init): Likewise.\n+\t* tree-if-conv.c (fold_or_predicates): Pass type.\n+\t* tree-ssa-ifcombine.c (ifcombine_ifandif): Likewise.\n+\t* tree-ssa-reassoc.c (eliminate_redundant_comparison): Likewise.\n+\t(optimize_vec_cond_expr): Likewise.\n+\t(ovce_extract_ops): Return type of conditional expression.\n+\t* tree-ssanames.c (init_ssa_name_imm_use): New.\n+\t(make_ssa_name_fn): Use init_ssa_name_imm_use.\n+\t* tree-ssanames.h (init_ssa_name_imm_use): New.\n+\n 2019-09-16  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/91756"}, {"sha": "6d9ba36783906ffa7f9b337ce7ce307e3976fcd9", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 129, "deletions": 41, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f487a349de62613d7fa429bcbfbeeafbfc94f3a/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f487a349de62613d7fa429bcbfbeeafbfc94f3a/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=5f487a349de62613d7fa429bcbfbeeafbfc94f3a", "patch": "@@ -5371,22 +5371,22 @@ same_bool_result_p (const_tree op1, const_tree op2)\n /* Forward declarations for some mutually recursive functions.  */\n \n static tree\n-and_comparisons_1 (enum tree_code code1, tree op1a, tree op1b,\n+and_comparisons_1 (tree type, enum tree_code code1, tree op1a, tree op1b,\n \t\t   enum tree_code code2, tree op2a, tree op2b);\n static tree\n-and_var_with_comparison (tree var, bool invert,\n+and_var_with_comparison (tree type, tree var, bool invert,\n \t\t\t enum tree_code code2, tree op2a, tree op2b);\n static tree\n-and_var_with_comparison_1 (gimple *stmt,\n+and_var_with_comparison_1 (tree type, gimple *stmt,\n \t\t\t   enum tree_code code2, tree op2a, tree op2b);\n static tree\n-or_comparisons_1 (enum tree_code code1, tree op1a, tree op1b,\n+or_comparisons_1 (tree, enum tree_code code1, tree op1a, tree op1b,\n \t\t  enum tree_code code2, tree op2a, tree op2b);\n static tree\n-or_var_with_comparison (tree var, bool invert,\n+or_var_with_comparison (tree, tree var, bool invert,\n \t\t\tenum tree_code code2, tree op2a, tree op2b);\n static tree\n-or_var_with_comparison_1 (gimple *stmt,\n+or_var_with_comparison_1 (tree, gimple *stmt,\n \t\t\t  enum tree_code code2, tree op2a, tree op2b);\n \n /* Helper function for and_comparisons_1:  try to simplify the AND of the\n@@ -5395,7 +5395,7 @@ or_var_with_comparison_1 (gimple *stmt,\n    Return NULL_EXPR if we can't simplify this to a single expression.  */\n \n static tree\n-and_var_with_comparison (tree var, bool invert,\n+and_var_with_comparison (tree type, tree var, bool invert,\n \t\t\t enum tree_code code2, tree op2a, tree op2b)\n {\n   tree t;\n@@ -5409,11 +5409,11 @@ and_var_with_comparison (tree var, bool invert,\n      !var AND (op2a code2 op2b) => !(var OR !(op2a code2 op2b))\n      Then we only have to consider the simpler non-inverted cases.  */\n   if (invert)\n-    t = or_var_with_comparison_1 (stmt, \n+    t = or_var_with_comparison_1 (type, stmt,\n \t\t\t\t  invert_tree_comparison (code2, false),\n \t\t\t\t  op2a, op2b);\n   else\n-    t = and_var_with_comparison_1 (stmt, code2, op2a, op2b);\n+    t = and_var_with_comparison_1 (type, stmt, code2, op2a, op2b);\n   return canonicalize_bool (t, invert);\n }\n \n@@ -5422,7 +5422,7 @@ and_var_with_comparison (tree var, bool invert,\n    Return NULL_EXPR if we can't simplify this to a single expression.  */\n \n static tree\n-and_var_with_comparison_1 (gimple *stmt,\n+and_var_with_comparison_1 (tree type, gimple *stmt,\n \t\t\t   enum tree_code code2, tree op2a, tree op2b)\n {\n   tree var = gimple_assign_lhs (stmt);\n@@ -5453,7 +5453,7 @@ and_var_with_comparison_1 (gimple *stmt,\n   /* If the definition is a comparison, recurse on it.  */\n   if (TREE_CODE_CLASS (innercode) == tcc_comparison)\n     {\n-      tree t = and_comparisons_1 (innercode,\n+      tree t = and_comparisons_1 (type, innercode,\n \t\t\t\t  gimple_assign_rhs1 (stmt),\n \t\t\t\t  gimple_assign_rhs2 (stmt),\n \t\t\t\t  code2,\n@@ -5489,18 +5489,20 @@ and_var_with_comparison_1 (gimple *stmt,\n       else if (inner1 == false_test_var)\n \treturn (is_and\n \t\t? boolean_false_node\n-\t\t: and_var_with_comparison (inner2, false, code2, op2a, op2b));\n+\t\t: and_var_with_comparison (type, inner2, false, code2, op2a,\n+\t\t\t\t\t   op2b));\n       else if (inner2 == false_test_var)\n \treturn (is_and\n \t\t? boolean_false_node\n-\t\t: and_var_with_comparison (inner1, false, code2, op2a, op2b));\n+\t\t: and_var_with_comparison (type, inner1, false, code2, op2a,\n+\t\t\t\t\t   op2b));\n \n       /* Next, redistribute/reassociate the AND across the inner tests.\n \t Compute the first partial result, (inner1 AND (op2a code op2b))  */\n       if (TREE_CODE (inner1) == SSA_NAME\n \t  && is_gimple_assign (s = SSA_NAME_DEF_STMT (inner1))\n \t  && TREE_CODE_CLASS (gimple_assign_rhs_code (s)) == tcc_comparison\n-\t  && (t = maybe_fold_and_comparisons (gimple_assign_rhs_code (s),\n+\t  && (t = maybe_fold_and_comparisons (type, gimple_assign_rhs_code (s),\n \t\t\t\t\t      gimple_assign_rhs1 (s),\n \t\t\t\t\t      gimple_assign_rhs2 (s),\n \t\t\t\t\t      code2, op2a, op2b)))\n@@ -5532,7 +5534,7 @@ and_var_with_comparison_1 (gimple *stmt,\n       if (TREE_CODE (inner2) == SSA_NAME\n \t  && is_gimple_assign (s = SSA_NAME_DEF_STMT (inner2))\n \t  && TREE_CODE_CLASS (gimple_assign_rhs_code (s)) == tcc_comparison\n-\t  && (t = maybe_fold_and_comparisons (gimple_assign_rhs_code (s),\n+\t  && (t = maybe_fold_and_comparisons (type, gimple_assign_rhs_code (s),\n \t\t\t\t\t      gimple_assign_rhs1 (s),\n \t\t\t\t\t      gimple_assign_rhs2 (s),\n \t\t\t\t\t      code2, op2a, op2b)))\n@@ -5588,7 +5590,7 @@ and_var_with_comparison_1 (gimple *stmt,\n    in the first comparison but not the second.  */\n \n static tree\n-and_comparisons_1 (enum tree_code code1, tree op1a, tree op1b,\n+and_comparisons_1 (tree type, enum tree_code code1, tree op1a, tree op1b,\n \t\t   enum tree_code code2, tree op2a, tree op2b)\n {\n   tree truth_type = truth_type_for (TREE_TYPE (op1a));\n@@ -5762,7 +5764,8 @@ and_comparisons_1 (enum tree_code code1, tree op1a, tree op1b,\n \t{\n \tcase GIMPLE_ASSIGN:\n \t  /* Try to simplify by copy-propagating the definition.  */\n-\t  return and_var_with_comparison (op1a, invert, code2, op2a, op2b);\n+\t  return and_var_with_comparison (type, op1a, invert, code2, op2a,\n+\t\t\t\t\t  op2b);\n \n \tcase GIMPLE_PHI:\n \t  /* If every argument to the PHI produces the same result when\n@@ -5812,7 +5815,7 @@ and_comparisons_1 (enum tree_code code1, tree op1a, tree op1b,\n \t\t\t\t\t     gimple_bb (def_stmt),\n \t\t\t\t\t     gimple_bb (stmt)))\n \t\t\treturn NULL_TREE;\n-\t\t      temp = and_var_with_comparison (arg, invert, code2,\n+\t\t      temp = and_var_with_comparison (type, arg, invert, code2,\n \t\t\t\t\t\t      op2a, op2b);\n \t\t      if (!temp)\n \t\t\treturn NULL_TREE;\n@@ -5834,6 +5837,73 @@ and_comparisons_1 (enum tree_code code1, tree op1a, tree op1b,\n   return NULL_TREE;\n }\n \n+/* Helper function for maybe_fold_and_comparisons and maybe_fold_or_comparisons\n+   : try to simplify the AND/OR of the ssa variable VAR with the comparison\n+   specified by (OP2A CODE2 OP2B) from match.pd.  Return NULL_EXPR if we can't\n+   simplify this to a single expression.  As we are going to lower the cost\n+   of building SSA names / gimple stmts significantly, we need to allocate\n+   them ont the stack.  This will cause the code to be a bit ugly.  */\n+\n+static tree\n+maybe_fold_comparisons_from_match_pd (tree type, enum tree_code code,\n+\t\t\t\t      enum tree_code code1,\n+\t\t\t\t      tree op1a, tree op1b,\n+\t\t\t\t      enum tree_code code2, tree op2a,\n+\t\t\t\t      tree op2b)\n+{\n+  /* Allocate gimple stmt1 on the stack.  */\n+  gassign *stmt1\n+    = (gassign *) XALLOCAVEC (char, gimple_size (GIMPLE_ASSIGN, 3));\n+  gimple_init (stmt1, GIMPLE_ASSIGN, 3);\n+  gimple_assign_set_rhs_code (stmt1, code1);\n+  gimple_assign_set_rhs1 (stmt1, op1a);\n+  gimple_assign_set_rhs2 (stmt1, op1b);\n+\n+  /* Allocate gimple stmt2 on the stack.  */\n+  gassign *stmt2\n+    = (gassign *) XALLOCAVEC (char, gimple_size (GIMPLE_ASSIGN, 3));\n+  gimple_init (stmt2, GIMPLE_ASSIGN, 3);\n+  gimple_assign_set_rhs_code (stmt2, code2);\n+  gimple_assign_set_rhs1 (stmt2, op2a);\n+  gimple_assign_set_rhs2 (stmt2, op2b);\n+\n+  /* Allocate SSA names(lhs1) on the stack.  */\n+  tree lhs1 = (tree)XALLOCA (tree_ssa_name);\n+  memset (lhs1, 0, sizeof (tree_ssa_name));\n+  TREE_SET_CODE (lhs1, SSA_NAME);\n+  TREE_TYPE (lhs1) = type;\n+  init_ssa_name_imm_use (lhs1);\n+\n+  /* Allocate SSA names(lhs2) on the stack.  */\n+  tree lhs2 = (tree)XALLOCA (tree_ssa_name);\n+  memset (lhs2, 0, sizeof (tree_ssa_name));\n+  TREE_SET_CODE (lhs2, SSA_NAME);\n+  TREE_TYPE (lhs2) = type;\n+  init_ssa_name_imm_use (lhs2);\n+\n+  gimple_assign_set_lhs (stmt1, lhs1);\n+  gimple_assign_set_lhs (stmt2, lhs2);\n+\n+  gimple_match_op op (gimple_match_cond::UNCOND, code,\n+\t\t      type, gimple_assign_lhs (stmt1),\n+\t\t      gimple_assign_lhs (stmt2));\n+  if (op.resimplify (NULL, follow_all_ssa_edges))\n+    {\n+      if (gimple_simplified_result_is_gimple_val (&op))\n+\t{\n+\t  tree res = op.ops[0];\n+\t  if (res == lhs1)\n+\t    return build2 (code1, type, op1a, op1b);\n+\t  else if (res == lhs2)\n+\t    return build2 (code2, type, op2a, op2b);\n+\t  else\n+\t    return res;\n+\t}\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n /* Try to simplify the AND of two comparisons, specified by\n    (OP1A CODE1 OP1B) and (OP2B CODE2 OP2B), respectively.\n    If this can be simplified to a single expression (without requiring\n@@ -5842,14 +5912,22 @@ and_comparisons_1 (enum tree_code code1, tree op1a, tree op1b,\n    If the result expression is non-null, it has boolean type.  */\n \n tree\n-maybe_fold_and_comparisons (enum tree_code code1, tree op1a, tree op1b,\n+maybe_fold_and_comparisons (tree type,\n+\t\t\t    enum tree_code code1, tree op1a, tree op1b,\n \t\t\t    enum tree_code code2, tree op2a, tree op2b)\n {\n-  tree t = and_comparisons_1 (code1, op1a, op1b, code2, op2a, op2b);\n-  if (t)\n+  if (tree t = and_comparisons_1 (type, code1, op1a, op1b, code2, op2a, op2b))\n     return t;\n-  else\n-    return and_comparisons_1 (code2, op2a, op2b, code1, op1a, op1b);\n+\n+  if (tree t = and_comparisons_1 (type, code2, op2a, op2b, code1, op1a, op1b))\n+    return t;\n+\n+  if (tree t = maybe_fold_comparisons_from_match_pd (type, BIT_AND_EXPR, code1,\n+\t\t\t\t\t\t     op1a, op1b, code2, op2a,\n+\t\t\t\t\t\t     op2b))\n+    return t;\n+\n+  return NULL_TREE;\n }\n \n /* Helper function for or_comparisons_1:  try to simplify the OR of the\n@@ -5858,7 +5936,7 @@ maybe_fold_and_comparisons (enum tree_code code1, tree op1a, tree op1b,\n    Return NULL_EXPR if we can't simplify this to a single expression.  */\n \n static tree\n-or_var_with_comparison (tree var, bool invert,\n+or_var_with_comparison (tree type, tree var, bool invert,\n \t\t\tenum tree_code code2, tree op2a, tree op2b)\n {\n   tree t;\n@@ -5872,11 +5950,11 @@ or_var_with_comparison (tree var, bool invert,\n      !var OR (op2a code2 op2b) => !(var AND !(op2a code2 op2b))\n      Then we only have to consider the simpler non-inverted cases.  */\n   if (invert)\n-    t = and_var_with_comparison_1 (stmt, \n+    t = and_var_with_comparison_1 (type, stmt,\n \t\t\t\t   invert_tree_comparison (code2, false),\n \t\t\t\t   op2a, op2b);\n   else\n-    t = or_var_with_comparison_1 (stmt, code2, op2a, op2b);\n+    t = or_var_with_comparison_1 (type, stmt, code2, op2a, op2b);\n   return canonicalize_bool (t, invert);\n }\n \n@@ -5885,7 +5963,7 @@ or_var_with_comparison (tree var, bool invert,\n    Return NULL_EXPR if we can't simplify this to a single expression.  */\n \n static tree\n-or_var_with_comparison_1 (gimple *stmt,\n+or_var_with_comparison_1 (tree type, gimple *stmt,\n \t\t\t  enum tree_code code2, tree op2a, tree op2b)\n {\n   tree var = gimple_assign_lhs (stmt);\n@@ -5916,7 +5994,7 @@ or_var_with_comparison_1 (gimple *stmt,\n   /* If the definition is a comparison, recurse on it.  */\n   if (TREE_CODE_CLASS (innercode) == tcc_comparison)\n     {\n-      tree t = or_comparisons_1 (innercode,\n+      tree t = or_comparisons_1 (type, innercode,\n \t\t\t\t gimple_assign_rhs1 (stmt),\n \t\t\t\t gimple_assign_rhs2 (stmt),\n \t\t\t\t code2,\n@@ -5952,18 +6030,20 @@ or_var_with_comparison_1 (gimple *stmt,\n       else if (inner1 == false_test_var)\n \treturn (is_or\n \t\t? boolean_true_node\n-\t\t: or_var_with_comparison (inner2, false, code2, op2a, op2b));\n+\t\t: or_var_with_comparison (type, inner2, false, code2, op2a,\n+\t\t\t\t\t  op2b));\n       else if (inner2 == false_test_var)\n \treturn (is_or\n \t\t? boolean_true_node\n-\t\t: or_var_with_comparison (inner1, false, code2, op2a, op2b));\n+\t\t: or_var_with_comparison (type, inner1, false, code2, op2a,\n+\t\t\t\t\t  op2b));\n       \n       /* Next, redistribute/reassociate the OR across the inner tests.\n \t Compute the first partial result, (inner1 OR (op2a code op2b))  */\n       if (TREE_CODE (inner1) == SSA_NAME\n \t  && is_gimple_assign (s = SSA_NAME_DEF_STMT (inner1))\n \t  && TREE_CODE_CLASS (gimple_assign_rhs_code (s)) == tcc_comparison\n-\t  && (t = maybe_fold_or_comparisons (gimple_assign_rhs_code (s),\n+\t  && (t = maybe_fold_or_comparisons (type, gimple_assign_rhs_code (s),\n \t\t\t\t\t     gimple_assign_rhs1 (s),\n \t\t\t\t\t     gimple_assign_rhs2 (s),\n \t\t\t\t\t     code2, op2a, op2b)))\n@@ -5995,7 +6075,7 @@ or_var_with_comparison_1 (gimple *stmt,\n       if (TREE_CODE (inner2) == SSA_NAME\n \t  && is_gimple_assign (s = SSA_NAME_DEF_STMT (inner2))\n \t  && TREE_CODE_CLASS (gimple_assign_rhs_code (s)) == tcc_comparison\n-\t  && (t = maybe_fold_or_comparisons (gimple_assign_rhs_code (s),\n+\t  && (t = maybe_fold_or_comparisons (type, gimple_assign_rhs_code (s),\n \t\t\t\t\t     gimple_assign_rhs1 (s),\n \t\t\t\t\t     gimple_assign_rhs2 (s),\n \t\t\t\t\t     code2, op2a, op2b)))\n@@ -6052,7 +6132,7 @@ or_var_with_comparison_1 (gimple *stmt,\n    in the first comparison but not the second.  */\n \n static tree\n-or_comparisons_1 (enum tree_code code1, tree op1a, tree op1b,\n+or_comparisons_1 (tree type, enum tree_code code1, tree op1a, tree op1b,\n \t\t  enum tree_code code2, tree op2a, tree op2b)\n {\n   tree truth_type = truth_type_for (TREE_TYPE (op1a));\n@@ -6226,7 +6306,8 @@ or_comparisons_1 (enum tree_code code1, tree op1a, tree op1b,\n \t{\n \tcase GIMPLE_ASSIGN:\n \t  /* Try to simplify by copy-propagating the definition.  */\n-\t  return or_var_with_comparison (op1a, invert, code2, op2a, op2b);\n+\t  return or_var_with_comparison (type, op1a, invert, code2, op2a,\n+\t\t\t\t\t op2b);\n \n \tcase GIMPLE_PHI:\n \t  /* If every argument to the PHI produces the same result when\n@@ -6276,7 +6357,7 @@ or_comparisons_1 (enum tree_code code1, tree op1a, tree op1b,\n \t\t\t\t\t     gimple_bb (def_stmt),\n \t\t\t\t\t     gimple_bb (stmt)))\n \t\t\treturn NULL_TREE;\n-\t\t      temp = or_var_with_comparison (arg, invert, code2,\n+\t\t      temp = or_var_with_comparison (type, arg, invert, code2,\n \t\t\t\t\t\t     op2a, op2b);\n \t\t      if (!temp)\n \t\t\treturn NULL_TREE;\n@@ -6306,16 +6387,23 @@ or_comparisons_1 (enum tree_code code1, tree op1a, tree op1b,\n    If the result expression is non-null, it has boolean type.  */\n \n tree\n-maybe_fold_or_comparisons (enum tree_code code1, tree op1a, tree op1b,\n+maybe_fold_or_comparisons (tree type,\n+\t\t\t   enum tree_code code1, tree op1a, tree op1b,\n \t\t\t   enum tree_code code2, tree op2a, tree op2b)\n {\n-  tree t = or_comparisons_1 (code1, op1a, op1b, code2, op2a, op2b);\n-  if (t)\n+  if (tree t = or_comparisons_1 (type, code1, op1a, op1b, code2, op2a, op2b))\n     return t;\n-  else\n-    return or_comparisons_1 (code2, op2a, op2b, code1, op1a, op1b);\n-}\n \n+  if (tree t = or_comparisons_1 (type, code2, op2a, op2b, code1, op1a, op1b))\n+    return t;\n+\n+  if (tree t = maybe_fold_comparisons_from_match_pd (type, BIT_IOR_EXPR, code1,\n+\t\t\t\t\t\t     op1a, op1b, code2, op2a,\n+\t\t\t\t\t\t     op2b))\n+    return t;\n+\n+  return NULL_TREE;\n+}\n \n /* Fold STMT to a constant using VALUEIZE to valueize SSA names.\n "}, {"sha": "f9d1d54daf46c98ef8acebeb105c15e6f9bfb6fe", "filename": "gcc/gimple-fold.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f487a349de62613d7fa429bcbfbeeafbfc94f3a/gcc%2Fgimple-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f487a349de62613d7fa429bcbfbeeafbfc94f3a/gcc%2Fgimple-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.h?ref=5f487a349de62613d7fa429bcbfbeeafbfc94f3a", "patch": "@@ -31,9 +31,9 @@ extern void gimplify_and_update_call_from_tree (gimple_stmt_iterator *, tree);\n extern bool fold_stmt (gimple_stmt_iterator *);\n extern bool fold_stmt (gimple_stmt_iterator *, tree (*) (tree));\n extern bool fold_stmt_inplace (gimple_stmt_iterator *);\n-extern tree maybe_fold_and_comparisons (enum tree_code, tree, tree, \n+extern tree maybe_fold_and_comparisons (tree, enum tree_code, tree, tree,\n \t\t\t\t\tenum tree_code, tree, tree);\n-extern tree maybe_fold_or_comparisons (enum tree_code, tree, tree,\n+extern tree maybe_fold_or_comparisons (tree, enum tree_code, tree, tree,\n \t\t\t\t       enum tree_code, tree, tree);\n extern bool optimize_atomic_compare_exchange_p (gimple *);\n extern void fold_builtin_atomic_compare_exchange (gimple_stmt_iterator *);"}, {"sha": "88250cad16b5fd5462818120af8b4f9180604102", "filename": "gcc/gimple.c", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f487a349de62613d7fa429bcbfbeeafbfc94f3a/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f487a349de62613d7fa429bcbfbeeafbfc94f3a/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=5f487a349de62613d7fa429bcbfbeeafbfc94f3a", "patch": "@@ -110,10 +110,27 @@ gimple_set_code (gimple *g, enum gimple_code code)\n /* Return the number of bytes needed to hold a GIMPLE statement with\n    code CODE.  */\n \n-static inline size_t\n-gimple_size (enum gimple_code code)\n+size_t\n+gimple_size (enum gimple_code code, unsigned num_ops)\n {\n-  return gsstruct_code_size[gss_for_code (code)];\n+  size_t size = gsstruct_code_size[gss_for_code (code)];\n+  if (num_ops > 0)\n+    size += (sizeof (tree) * (num_ops - 1));\n+  return size;\n+}\n+\n+/* Initialize GIMPLE statement G with CODE and NUM_OPS.  */\n+\n+void\n+gimple_init (gimple *g, enum gimple_code code, unsigned num_ops)\n+{\n+  gimple_set_code (g, code);\n+  gimple_set_num_ops (g, num_ops);\n+\n+  /* Do not call gimple_set_modified here as it has other side\n+     effects and this tuple is still not completely built.  */\n+  g->modified = 1;\n+  gimple_init_singleton (g);\n }\n \n /* Allocate memory for a GIMPLE statement with code CODE and NUM_OPS\n@@ -125,10 +142,7 @@ gimple_alloc (enum gimple_code code, unsigned num_ops MEM_STAT_DECL)\n   size_t size;\n   gimple *stmt;\n \n-  size = gimple_size (code);\n-  if (num_ops > 0)\n-    size += sizeof (tree) * (num_ops - 1);\n-\n+  size = gimple_size (code, num_ops);\n   if (GATHER_STATISTICS)\n     {\n       enum gimple_alloc_kind kind = gimple_alloc_kind (code);\n@@ -137,14 +151,7 @@ gimple_alloc (enum gimple_code code, unsigned num_ops MEM_STAT_DECL)\n     }\n \n   stmt = ggc_alloc_cleared_gimple_statement_stat (size PASS_MEM_STAT);\n-  gimple_set_code (stmt, code);\n-  gimple_set_num_ops (stmt, num_ops);\n-\n-  /* Do not call gimple_set_modified here as it has other side\n-     effects and this tuple is still not completely built.  */\n-  stmt->modified = 1;\n-  gimple_init_singleton (stmt);\n-\n+  gimple_init (stmt, code, num_ops);\n   return stmt;\n }\n "}, {"sha": "cf1f8da5ae2444b5f37a3c5e448ec1d0967c0fee", "filename": "gcc/gimple.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f487a349de62613d7fa429bcbfbeeafbfc94f3a/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f487a349de62613d7fa429bcbfbeeafbfc94f3a/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=5f487a349de62613d7fa429bcbfbeeafbfc94f3a", "patch": "@@ -1445,6 +1445,8 @@ extern enum gimple_statement_structure_enum const gss_for_code_[];\n    of comminucating the profile info to the builtin expanders.  */\n extern gimple *currently_expanding_gimple_stmt;\n \n+size_t gimple_size (enum gimple_code code, unsigned num_ops = 0);\n+void gimple_init (gimple *g, enum gimple_code code, unsigned num_ops);\n gimple *gimple_alloc (enum gimple_code, unsigned CXX_MEM_STAT_INFO);\n greturn *gimple_build_return (tree);\n void gimple_call_reset_alias_info (gcall *);"}, {"sha": "40ad4c5947aa838241407161d13ac9464348fd53", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f487a349de62613d7fa429bcbfbeeafbfc94f3a/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f487a349de62613d7fa429bcbfbeeafbfc94f3a/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=5f487a349de62613d7fa429bcbfbeeafbfc94f3a", "patch": "@@ -436,7 +436,7 @@ fold_or_predicates (location_t loc, tree c1, tree c2)\n \n   if (code1 != ERROR_MARK && code2 != ERROR_MARK)\n     {\n-      tree t = maybe_fold_or_comparisons (code1, op1a, op1b,\n+      tree t = maybe_fold_or_comparisons (boolean_type_node, code1, op1a, op1b,\n \t\t\t\t\t  code2, op2a, op2b);\n       if (t)\n \treturn t;"}, {"sha": "90d8bb5e9e76ad88eddb9645258d7e5630c8132b", "filename": "gcc/tree-ssa-ifcombine.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f487a349de62613d7fa429bcbfbeeafbfc94f3a/gcc%2Ftree-ssa-ifcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f487a349de62613d7fa429bcbfbeeafbfc94f3a/gcc%2Ftree-ssa-ifcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ifcombine.c?ref=5f487a349de62613d7fa429bcbfbeeafbfc94f3a", "patch": "@@ -555,7 +555,7 @@ ifcombine_ifandif (basic_block inner_cond_bb, bool inner_inv,\n \treturn false;\n       /* Don't return false so fast, try maybe_fold_or_comparisons?  */\n \n-      if (!(t = maybe_fold_and_comparisons (inner_cond_code,\n+      if (!(t = maybe_fold_and_comparisons (boolean_type_node, inner_cond_code,\n \t\t\t\t\t    gimple_cond_lhs (inner_cond),\n \t\t\t\t\t    gimple_cond_rhs (inner_cond),\n \t\t\t\t\t    outer_cond_code,"}, {"sha": "510dfd1e188f6d08483e05a67f5ac57924d8ea36", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f487a349de62613d7fa429bcbfbeeafbfc94f3a/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f487a349de62613d7fa429bcbfbeeafbfc94f3a/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=5f487a349de62613d7fa429bcbfbeeafbfc94f3a", "patch": "@@ -2088,12 +2088,15 @@ eliminate_redundant_comparison (enum tree_code opcode,\n \n       /* If we got here, we have a match.  See if we can combine the\n \t two comparisons.  */\n+      tree type = TREE_TYPE (gimple_assign_lhs (def1));\n       if (opcode == BIT_IOR_EXPR)\n-\tt = maybe_fold_or_comparisons (lcode, op1, op2,\n+\tt = maybe_fold_or_comparisons (type,\n+\t\t\t\t       lcode, op1, op2,\n \t\t\t\t       rcode, gimple_assign_rhs1 (def2),\n \t\t\t\t       gimple_assign_rhs2 (def2));\n       else\n-\tt = maybe_fold_and_comparisons (lcode, op1, op2,\n+\tt = maybe_fold_and_comparisons (type,\n+\t\t\t\t\tlcode, op1, op2,\n \t\t\t\t\trcode, gimple_assign_rhs1 (def2),\n \t\t\t\t\tgimple_assign_rhs2 (def2));\n       if (!t)\n@@ -3745,10 +3748,11 @@ optimize_range_tests (enum tree_code opcode,\n \n /* A subroutine of optimize_vec_cond_expr to extract and canonicalize\n    the operands of the VEC_COND_EXPR.  Returns ERROR_MARK on failure,\n-   otherwise the comparison code.  */\n+   otherwise the comparison code.  TYPE is a return value that is set\n+   to type of comparison.  */\n \n static tree_code\n-ovce_extract_ops (tree var, gassign **rets, bool *reti)\n+ovce_extract_ops (tree var, gassign **rets, bool *reti, tree *type)\n {\n   if (TREE_CODE (var) != SSA_NAME)\n     return ERROR_MARK;\n@@ -3790,6 +3794,8 @@ ovce_extract_ops (tree var, gassign **rets, bool *reti)\n     *rets = stmt;\n   if (reti)\n     *reti = inv;\n+  if (type)\n+    *type = TREE_TYPE (cond);\n   return cmp;\n }\n \n@@ -3811,7 +3817,8 @@ optimize_vec_cond_expr (tree_code opcode, vec<operand_entry *> *ops)\n \n       gassign *stmt0;\n       bool invert;\n-      tree_code cmp0 = ovce_extract_ops (elt0, &stmt0, &invert);\n+      tree type;\n+      tree_code cmp0 = ovce_extract_ops (elt0, &stmt0, &invert, &type);\n       if (cmp0 == ERROR_MARK)\n \tcontinue;\n \n@@ -3820,7 +3827,7 @@ optimize_vec_cond_expr (tree_code opcode, vec<operand_entry *> *ops)\n \t  tree &elt1 = (*ops)[j]->op;\n \n \t  gassign *stmt1;\n-\t  tree_code cmp1 = ovce_extract_ops (elt1, &stmt1, NULL);\n+\t  tree_code cmp1 = ovce_extract_ops (elt1, &stmt1, NULL, NULL);\n \t  if (cmp1 == ERROR_MARK)\n \t    continue;\n \n@@ -3834,9 +3841,11 @@ optimize_vec_cond_expr (tree_code opcode, vec<operand_entry *> *ops)\n \n \t  tree comb;\n \t  if (opcode == BIT_AND_EXPR)\n-\t    comb = maybe_fold_and_comparisons (cmp0, x0, y0, cmp1, x1, y1);\n+\t    comb = maybe_fold_and_comparisons (type, cmp0, x0, y0, cmp1, x1,\n+\t\t\t\t\t       y1);\n \t  else if (opcode == BIT_IOR_EXPR)\n-\t    comb = maybe_fold_or_comparisons (cmp0, x0, y0, cmp1, x1, y1);\n+\t    comb = maybe_fold_or_comparisons (type, cmp0, x0, y0, cmp1, x1,\n+\t\t\t\t\t      y1);\n \t  else\n \t    gcc_unreachable ();\n \t  if (comb == NULL)"}, {"sha": "f7b638dba113cc1f411ceeac809b0af435e9845b", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f487a349de62613d7fa429bcbfbeeafbfc94f3a/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f487a349de62613d7fa429bcbfbeeafbfc94f3a/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=5f487a349de62613d7fa429bcbfbeeafbfc94f3a", "patch": "@@ -252,6 +252,19 @@ flush_ssaname_freelist (void)\n   vec_safe_truncate (FREE_SSANAMES_QUEUE (cfun), 0);\n }\n \n+/* Initialize SSA_NAME_IMM_USE_NODE of a SSA NAME.  */\n+\n+void\n+init_ssa_name_imm_use (tree name)\n+{\n+  use_operand_p imm;\n+  imm = &(SSA_NAME_IMM_USE_NODE (name));\n+  imm->use = NULL;\n+  imm->prev = imm;\n+  imm->next = imm;\n+  imm->loc.ssa_name = name;\n+}\n+\n /* Return an SSA_NAME node for variable VAR defined in statement STMT\n    in function FN.  STMT may be an empty statement for artificial\n    references (e.g., default definitions created when a variable is\n@@ -263,8 +276,6 @@ make_ssa_name_fn (struct function *fn, tree var, gimple *stmt,\n \t\t  unsigned int version)\n {\n   tree t;\n-  use_operand_p imm;\n-\n   gcc_assert (VAR_P (var)\n \t      || TREE_CODE (var) == PARM_DECL\n \t      || TREE_CODE (var) == RESULT_DECL\n@@ -318,11 +329,7 @@ make_ssa_name_fn (struct function *fn, tree var, gimple *stmt,\n \n   SSA_NAME_IN_FREE_LIST (t) = 0;\n   SSA_NAME_IS_DEFAULT_DEF (t) = 0;\n-  imm = &(SSA_NAME_IMM_USE_NODE (t));\n-  imm->use = NULL;\n-  imm->prev = imm;\n-  imm->next = imm;\n-  imm->loc.ssa_name = t;\n+  init_ssa_name_imm_use (t);\n \n   return t;\n }"}, {"sha": "1a7d0bccdf8ae366aef7c98368bfbcd69e46e1af", "filename": "gcc/tree-ssanames.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f487a349de62613d7fa429bcbfbeeafbfc94f3a/gcc%2Ftree-ssanames.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f487a349de62613d7fa429bcbfbeeafbfc94f3a/gcc%2Ftree-ssanames.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.h?ref=5f487a349de62613d7fa429bcbfbeeafbfc94f3a", "patch": "@@ -82,6 +82,7 @@ extern void fini_ssanames (struct function *);\n extern void ssanames_print_statistics (void);\n extern tree make_ssa_name_fn (struct function *, tree, gimple *,\n \t\t\t      unsigned int version = 0);\n+extern void init_ssa_name_imm_use (tree);\n extern void release_ssa_name_fn (struct function *, tree);\n extern bool get_ptr_info_alignment (struct ptr_info_def *, unsigned int *,\n \t\t\t\t    unsigned int *);"}]}