{"sha": "17e7cb855000baa6598005571d7dd49cfac5282a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTdlN2NiODU1MDAwYmFhNjU5ODAwNTU3MWQ3ZGQ0OWNmYWM1MjgyYQ==", "commit": {"author": {"name": "Kai Tietz", "email": "kai.tietz@onevision.com", "date": "2009-11-11T18:37:19Z"}, "committer": {"name": "Kai Tietz", "email": "ktietz@gcc.gnu.org", "date": "2009-11-11T18:37:19Z"}, "message": "ChangeLog for libcpp\n\n2009-11-11  Kai Tietz  <kai.tietz@onevision.com>\n\n\t* directives.c (do_pragma_push_macro): New pragma handler.\n\t(do_pragma_pop_macro): Likewise.\n\t(_cpp_init_internal_pragmas): Add push_macro and\n\tpop_macro handler to internal pragmas.\n\t(lex_macro_node_from_str): Removed.\n\t(cpp_push_definition): Replace lex_macro_node_from_str\n\tby _cpp_lex_identifier.\n\t(cpp_pop_definition): Likewise.\n\t* internal.h (_cpp_lex_identifier): New prototype.\n\t(def_pragma_macro): New structure.\n\t(cpp_reader): New member pushed_macros.\n\t* lex.c (_cpp_lex_identifier): New function.\n\t(lex_identifier_intern): New function.\n\t* init.c (cpp_create_reader): Initialize pushed_macros\n\tmember.\n\t(cpp_destroy): Free elements in pushed_macros member.\n\t* pch.c (_cpp_save_pushed_macros): New function.\n\t(_cpp_restore_pushed_macros): Likewise.\n\t(_cpp_restore_pushed_macros): Use _cpp_save_pushed_macros.\n\t(cpp_read_state): Use _cpp_restore_pushed_macros.\n\nChangeLog for gcc\n\n2009-11-11  Kai Tietz  <kai.tietz@onevision.com>\n\n\t* config/i386/cygming.h (HANDLE_PRAGMA_PUSH_POP_MACRO):\n\tRemoved.\n\t* c-pragma.c (def_pragma_macro_value): Likewise.\n\t(def_pragma_macro): Likewise.\n\t(pushed_macro_table): Likewise.\n\t(HANDLE_PRAGMA_PUSH_POP_MACRO): Remove guarded\n\tcode.\n\t* doc/tm.texi (HANDLE_PRAGMA_PUSH_POP_MACRO):\n\tRemoved.\n\nChangeLog for gcc/testsuite\n\n2009-11-11  Kai Tietz  <kai.tietz@onevision.com>\n\n\t* g++.dg/torture/pushpop_macro.C: New testcase.\n\t* gcc.c-torture/execute/pushpop_macro.c: New testcase.\n\t* gcc.dg/cpp/pragma-pop_macro-1.c: Allow test for all\n\ttargets.\n\nFrom-SVN: r154098", "tree": {"sha": "e54ead3691775dbb1e9d31588966d79cac024672", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e54ead3691775dbb1e9d31588966d79cac024672"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/17e7cb855000baa6598005571d7dd49cfac5282a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17e7cb855000baa6598005571d7dd49cfac5282a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17e7cb855000baa6598005571d7dd49cfac5282a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17e7cb855000baa6598005571d7dd49cfac5282a/comments", "author": null, "committer": null, "parents": [{"sha": "110532c838d2302c88de13ad88f81ec975ed4b1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/110532c838d2302c88de13ad88f81ec975ed4b1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/110532c838d2302c88de13ad88f81ec975ed4b1e"}], "stats": {"total": 588, "additions": 411, "deletions": 177}, "files": [{"sha": "87e6fb41091e27fc57ea427e55d22d3ca02d088c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17e7cb855000baa6598005571d7dd49cfac5282a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17e7cb855000baa6598005571d7dd49cfac5282a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=17e7cb855000baa6598005571d7dd49cfac5282a", "patch": "@@ -1,3 +1,15 @@\n+2009-11-11  Kai Tietz  <kai.tietz@onevision.com>\n+\n+\t* config/i386/cygming.h (HANDLE_PRAGMA_PUSH_POP_MACRO):\n+\tRemoved.\n+\t* c-pragma.c (def_pragma_macro_value): Likewise.\n+\t(def_pragma_macro): Likewise.\n+\t(pushed_macro_table): Likewise.\n+\t(HANDLE_PRAGMA_PUSH_POP_MACRO): Remove guarded\n+\tcode.\n+\t* doc/tm.texi (HANDLE_PRAGMA_PUSH_POP_MACRO):\n+\tRemoved.\n+\n 2009-11-11  Basile Starynkevitch  <basile@starynkevitch.net>\n \t* doc/plugins.texi (Registering custom attributes): section\n \trenamed as (Registering custom attributes or pragmas)."}, {"sha": "79b3d132fd72aa6232b40e5b7dc45b8a85418160", "filename": "gcc/c-pragma.c", "status": "modified", "additions": 0, "deletions": 142, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17e7cb855000baa6598005571d7dd49cfac5282a/gcc%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17e7cb855000baa6598005571d7dd49cfac5282a/gcc%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.c?ref=17e7cb855000baa6598005571d7dd49cfac5282a", "patch": "@@ -244,144 +244,6 @@ handle_pragma_pack (cpp_reader * ARG_UNUSED (dummy))\n }\n #endif  /* HANDLE_PRAGMA_PACK */\n \n-struct GTY(()) def_pragma_macro_value {\n-  struct def_pragma_macro_value *prev;\n-  cpp_macro *value;\n-};\n-\n-struct GTY(()) def_pragma_macro {\n-  hashval_t hash;\n-  const char *name;\n-  struct def_pragma_macro_value value;\n-};\n-\n-static GTY((param_is (struct def_pragma_macro))) htab_t pushed_macro_table;\n-\n-#ifdef HANDLE_PRAGMA_PUSH_POP_MACRO\n-/* Hash table control functions for pushed_macro_table.  */\n-static hashval_t\n-dpm_hash (const void *p)\n-{\n-  return ((const struct def_pragma_macro *)p)->hash;\n-}\n-\n-static int\n-dpm_eq (const void *pa, const void *pb)\n-{\n-  const struct def_pragma_macro *const a = (const struct def_pragma_macro *) pa,\n-    *const b = (const struct def_pragma_macro *) pb;\n-  return a->hash == b->hash && strcmp (a->name, b->name) == 0;\n-}\n-\n-/* #pragma push_macro(\"MACRO_NAME\")\n-   #pragma pop_macro(\"MACRO_NAME\") */\n-\n-static void\n-handle_pragma_push_macro (cpp_reader *reader)\n-{\n-  tree x, id = 0;\n-  enum cpp_ttype token;\n-  struct def_pragma_macro dummy, *c;\n-  const char *macroname;\n-  void **slot;\n-\n-  if (pragma_lex (&x) != CPP_OPEN_PAREN)\n-    GCC_BAD (\"missing %<(%> after %<#pragma push_macro%> - ignored\");\n-\n-  token = pragma_lex (&id);\n-\n-  /* Silently ignore */\n-  if (token == CPP_CLOSE_PAREN)\n-    return;\n-  if (token != CPP_STRING)\n-    GCC_BAD (\"invalid constant in %<#pragma push_macro%> - ignored\");\n-\n-  if (pragma_lex (&x) != CPP_CLOSE_PAREN)\n-    GCC_BAD (\"missing %<)%> after %<#pragma push_macro%> - ignored\");\n-\n-  if (pragma_lex (&x) != CPP_EOF)\n-    warning (OPT_Wpragmas, \"junk at end of %<#pragma push_macro%>\");\n-\n-  /* Check for empty string, and silently ignore.  */\n-  if (TREE_STRING_LENGTH (id) < 1)\n-    return;\n-  macroname = TREE_STRING_POINTER (id);\n-\n-  if (pushed_macro_table == NULL)\n-    pushed_macro_table = htab_create_ggc (15, dpm_hash, dpm_eq, 0);\n-\n-  dummy.hash = htab_hash_string (macroname);\n-  dummy.name = macroname;\n-  slot = htab_find_slot_with_hash (pushed_macro_table, &dummy,\n-\t\t\t\t   dummy.hash, INSERT);\n-  c = (struct def_pragma_macro *) *slot;\n-  if (c == NULL)\n-    {\n-      *slot = c = GGC_NEW (struct def_pragma_macro);\n-      c->hash = dummy.hash;\n-      c->name = ggc_alloc_string (macroname, TREE_STRING_LENGTH (id) - 1);\n-      c->value.prev = NULL;\n-    }\n-  else\n-    {\n-      struct def_pragma_macro_value *v;\n-      v = GGC_NEW (struct def_pragma_macro_value);\n-      *v = c->value;\n-      c->value.prev = v;\n-    }\n-\n-  c->value.value = cpp_push_definition (reader, macroname);\n-}\n-\n-static void\n-handle_pragma_pop_macro (cpp_reader *reader)\n-{\n-  tree x, id = 0;\n-  enum cpp_ttype token;\n-  struct def_pragma_macro dummy, *c;\n-  const char *macroname;\n-  void **slot = NULL;\n-\n-  if (pragma_lex (&x) != CPP_OPEN_PAREN)\n-    GCC_BAD (\"missing %<(%> after %<#pragma pop_macro%> - ignored\");\n-\n-  token = pragma_lex (&id);\n-\n-  /* Silently ignore */\n-  if (token == CPP_CLOSE_PAREN)\n-    return;\n-  if (token != CPP_STRING)\n-    GCC_BAD (\"invalid constant in %<#pragma pop_macro%> - ignored\");\n-\n-  if (pragma_lex (&x) != CPP_CLOSE_PAREN)\n-    GCC_BAD (\"missing %<)%> after %<#pragma pop_macro%> - ignored\");\n-\n-  if (pragma_lex (&x) != CPP_EOF)\n-    warning (OPT_Wpragmas, \"junk at end of %<#pragma pop_macro%>\");\n-\n-  /* Check for empty string, and silently ignore.  */\n-  if (TREE_STRING_LENGTH (id) < 1)\n-    return;\n-  macroname = TREE_STRING_POINTER (id);\n-\n-  dummy.hash = htab_hash_string (macroname);\n-  dummy.name = macroname;\n-  if (pushed_macro_table)\n-    slot = htab_find_slot_with_hash (pushed_macro_table, &dummy,\n-\t\t\t\t     dummy.hash, NO_INSERT);\n-  if (slot == NULL)\n-    return;\n-  c = (struct def_pragma_macro *) *slot;\n-\n-  cpp_pop_definition (reader, c->name, c->value.value);\n-\n-  if (c->value.prev)\n-    c->value = *c->value.prev;\n-  else\n-    htab_clear_slot (pushed_macro_table, slot);\n-}\n-#endif /* HANDLE_PRAGMA_PUSH_POP_MACRO */\n-\n static GTY(()) tree pending_weaks;\n \n #ifdef HANDLE_PRAGMA_WEAK\n@@ -1422,10 +1284,6 @@ init_pragma (void)\n   c_register_pragma (0, \"pack\", handle_pragma_pack);\n #endif\n #endif\n-#ifdef HANDLE_PRAGMA_PUSH_POP_MACRO\n-  c_register_pragma (0 ,\"push_macro\", handle_pragma_push_macro);\n-  c_register_pragma (0 ,\"pop_macro\", handle_pragma_pop_macro);\n-#endif\n #ifdef HANDLE_PRAGMA_WEAK\n   c_register_pragma (0, \"weak\", handle_pragma_weak);\n #endif"}, {"sha": "ddec95a36fcd40a21bc017f8d7ecff0823235754", "filename": "gcc/config/i386/cygming.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17e7cb855000baa6598005571d7dd49cfac5282a/gcc%2Fconfig%2Fi386%2Fcygming.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17e7cb855000baa6598005571d7dd49cfac5282a/gcc%2Fconfig%2Fi386%2Fcygming.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcygming.h?ref=17e7cb855000baa6598005571d7dd49cfac5282a", "patch": "@@ -127,8 +127,6 @@ along with GCC; see the file COPYING3.  If not see\n \f\n /* Enable parsing of #pragma pack(push,<n>) and #pragma pack(pop).  */\n #define HANDLE_PRAGMA_PACK_PUSH_POP 1\n-/* Enable push_macro & pop_macro */\n-#define HANDLE_PRAGMA_PUSH_POP_MACRO 1\n \n union tree_node;\n #define TREE union tree_node *"}, {"sha": "3950967b7a371d2bd2e385702537e3ebc332232b", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17e7cb855000baa6598005571d7dd49cfac5282a/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17e7cb855000baa6598005571d7dd49cfac5282a/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=17e7cb855000baa6598005571d7dd49cfac5282a", "patch": "@@ -10476,18 +10476,6 @@ This must be a value that would also be valid to use with\n @samp{#pragma pack()} (that is, a small power of two).\n @end defmac\n \n-@findex #pragma\n-@findex pragma\n-@defmac HANDLE_PRAGMA_PUSH_POP_MACRO\n-Define this macro if you want to support the Win32 style pragmas\n-@samp{#pragma push_macro(macro-name-as-string)} and @samp{#pragma\n-pop_macro(macro-name-as-string)}.  The @samp{#pragma push_macro(\n-macro-name-as-string)} pragma saves the named macro and via\n-@samp{#pragma pop_macro(macro-name-as-string)} it will return to the\n-previous value.\n-@end defmac\n-\n-\n @defmac DOLLARS_IN_IDENTIFIERS\n Define this macro to control use of the character @samp{$} in\n identifier names for the C family of languages.  0 means @samp{$} is"}, {"sha": "16340e589a770660d1e19deb60622700aeadb6e7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17e7cb855000baa6598005571d7dd49cfac5282a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17e7cb855000baa6598005571d7dd49cfac5282a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=17e7cb855000baa6598005571d7dd49cfac5282a", "patch": "@@ -1,4 +1,10 @@\n-gcc/testsuite/\n+2009-11-11  Kai Tietz  <kai.tietz@onevision.com>\n+\n+\t* g++.dg/torture/pushpop_macro.C: New testcase.\n+\t* gcc.c-torture/execute/pushpop_macro.c: New testcase.\n+\t* gcc.dg/cpp/pragma-pop_macro-1.c: Allow test for all\n+\ttargets.\n+\n 2009-11-11  Jon Beniston <jon@beniston.com>\n \n         * lib/target-supports.exp (check_profiling_available): lm32 target "}, {"sha": "98065e6ee79e0dc84398516a16fb73a4d96acaac", "filename": "gcc/testsuite/g++.dg/torture/pushpop_macro.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17e7cb855000baa6598005571d7dd49cfac5282a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpushpop_macro.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17e7cb855000baa6598005571d7dd49cfac5282a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpushpop_macro.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpushpop_macro.C?ref=17e7cb855000baa6598005571d7dd49cfac5282a", "patch": "@@ -0,0 +1,19 @@\n+/* Do the preprocessor push_macro/pop_macro test.  */\n+\n+/* { dg-do run } */\n+\n+extern \"C\" void abort ();\n+\n+#define _ 2\n+#pragma push_macro(\"_\")\n+#undef _\n+#define _ 1\n+#pragma pop_macro(\"_\")\n+\n+int main ()\n+{\n+  if (_ != 2)\n+    abort ();\n+  return 0;\n+}\n+"}, {"sha": "08a82204313e899fbd5643ca8e3d79a27a46e642", "filename": "gcc/testsuite/gcc.c-torture/execute/pushpop_macro.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17e7cb855000baa6598005571d7dd49cfac5282a/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpushpop_macro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17e7cb855000baa6598005571d7dd49cfac5282a/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpushpop_macro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpushpop_macro.c?ref=17e7cb855000baa6598005571d7dd49cfac5282a", "patch": "@@ -0,0 +1,15 @@\n+extern void abort ();\n+\n+#define _ 2\n+#pragma push_macro(\"_\")\n+#undef _\n+#define _ 1\n+#pragma pop_macro(\"_\")\n+\n+int main ()\n+{\n+  if (_ != 2)\n+    abort ();\n+  return 0;\n+}\n+"}, {"sha": "c9a9048646ccaf6c54c977f7656fbb2673d798a1", "filename": "gcc/testsuite/gcc.dg/cpp/pragma-pop_macro-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17e7cb855000baa6598005571d7dd49cfac5282a/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpragma-pop_macro-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17e7cb855000baa6598005571d7dd49cfac5282a/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpragma-pop_macro-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpragma-pop_macro-1.c?ref=17e7cb855000baa6598005571d7dd49cfac5282a", "patch": "@@ -1,7 +1,7 @@\n /* PR preprocessor/35061 */\n /* Do nothing if there is nothing on the macro stack to pop.  */\n \n-/* { dg-do preprocess { target *-*-mingw* *-*-cygwin* } } */\n+/* { dg-do preprocess } */\n \n #define X  1\n /* # pragma push_macro(\"X\") */"}, {"sha": "c093e575a0e09a4365fe39f254d3a0b218484fdd", "filename": "gcc/testsuite/gcc.dg/pch/pushpop-1.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17e7cb855000baa6598005571d7dd49cfac5282a/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fpushpop-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17e7cb855000baa6598005571d7dd49cfac5282a/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fpushpop-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fpushpop-1.c?ref=17e7cb855000baa6598005571d7dd49cfac5282a", "patch": "@@ -0,0 +1,11 @@\n+#include \"pushpop-1.hs\"\n+\n+#if FOO != 2\n+#error FOO != 2\n+#endif\n+#pragma pop_macro(\"FOO\")\n+\n+#if FOO != 1\n+#error FOR != 1\n+#endif\n+"}, {"sha": "e97a4f33a91aba7bc4a43236d05a9126c92f732c", "filename": "gcc/testsuite/gcc.dg/pch/pushpop-1.hs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17e7cb855000baa6598005571d7dd49cfac5282a/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fpushpop-1.hs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17e7cb855000baa6598005571d7dd49cfac5282a/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fpushpop-1.hs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fpushpop-1.hs?ref=17e7cb855000baa6598005571d7dd49cfac5282a", "patch": "@@ -0,0 +1,5 @@\n+#define FOO 1\n+#pragma push_macro (\"FOO\")\n+#undef FOO\n+#define FOO 2\n+"}, {"sha": "c842e80c91deea9f78ec5ea5a4f9ba9863647363", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17e7cb855000baa6598005571d7dd49cfac5282a/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17e7cb855000baa6598005571d7dd49cfac5282a/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=17e7cb855000baa6598005571d7dd49cfac5282a", "patch": "@@ -1,3 +1,26 @@\n+2009-11-11  Kai Tietz  <kai.tietz@onevision.com>\n+\n+\t* directives.c (do_pragma_push_macro): New pragma handler.\n+\t(do_pragma_pop_macro): Likewise.\n+\t(_cpp_init_internal_pragmas): Add push_macro and\n+\tpop_macro handler to internal pragmas.\n+\t(lex_macro_node_from_str): Removed.\n+\t(cpp_push_definition): Replace lex_macro_node_from_str\n+\tby _cpp_lex_identifier.\n+\t(cpp_pop_definition): Likewise.\n+\t* internal.h (_cpp_lex_identifier): New prototype.\n+\t(def_pragma_macro): New structure.\n+\t(cpp_reader): New member pushed_macros.\n+\t* lex.c (_cpp_lex_identifier): New function.\n+\t(lex_identifier_intern): New function.\n+\t* init.c (cpp_create_reader): Initialize pushed_macros\n+\tmember.\n+\t(cpp_destroy): Free elements in pushed_macros member.\n+\t* pch.c (_cpp_save_pushed_macros): New function.\n+\t(_cpp_restore_pushed_macros): Likewise.\n+\t(_cpp_restore_pushed_macros): Use _cpp_save_pushed_macros.\n+\t(cpp_read_state): Use _cpp_restore_pushed_macros.\n+\n 2009-10-19  Jakub Jelinek  <jakub@redhat.com>\n \n \t* charset.c (cpp_init_iconv): Initialize utf8_cset_desc."}, {"sha": "aed940e56e1d8890d0ce8fce930fd58970da400c", "filename": "libcpp/directives.c", "status": "modified", "additions": 96, "deletions": 19, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17e7cb855000baa6598005571d7dd49cfac5282a/libcpp%2Fdirectives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17e7cb855000baa6598005571d7dd49cfac5282a/libcpp%2Fdirectives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fdirectives.c?ref=17e7cb855000baa6598005571d7dd49cfac5282a", "patch": "@@ -126,6 +126,8 @@ static int parse_answer (cpp_reader *, struct answer **, int, source_location);\n static cpp_hashnode *parse_assertion (cpp_reader *, struct answer **, int);\n static struct answer ** find_answer (cpp_hashnode *, const struct answer *);\n static void handle_assertion (cpp_reader *, const char *, int);\n+static void do_pragma_push_macro (cpp_reader *);\n+static void do_pragma_pop_macro (cpp_reader *);\n \n /* This is the table of directive handlers.  It is ordered by\n    frequency of occurrence; the numbers at the end are directive\n@@ -1244,6 +1246,8 @@ _cpp_init_internal_pragmas (cpp_reader *pfile)\n {\n   /* Pragmas in the global namespace.  */\n   register_pragma_internal (pfile, 0, \"once\", do_pragma_once);\n+  register_pragma_internal (pfile, 0, \"push_macro\", do_pragma_push_macro);\n+  register_pragma_internal (pfile, 0, \"pop_macro\", do_pragma_pop_macro);\n \n   /* New GCC-specific pragmas should be put in the GCC namespace.  */\n   register_pragma_internal (pfile, \"GCC\", \"poison\", do_pragma_poison);\n@@ -1423,6 +1427,96 @@ do_pragma_once (cpp_reader *pfile)\n   _cpp_mark_file_once_only (pfile, pfile->buffer->file);\n }\n \n+/* Handle #pragma push_macro(STRING).  */\n+static void\n+do_pragma_push_macro (cpp_reader *pfile)\n+{\n+  char *macroname, *dest;\n+  const char *limit, *src;\n+  const cpp_token *txt;\n+  struct def_pragma_macro *c;\n+\n+  txt = get__Pragma_string (pfile);\n+  if (!txt)\n+    {\n+      source_location src_loc = pfile->cur_token[-1].src_loc;\n+      cpp_error_with_line (pfile, CPP_DL_ERROR, src_loc, 0,\n+\t\t \"invalid #pragma push_macro directive\");\n+      check_eol (pfile, false);\n+      skip_rest_of_line (pfile);\n+      return;\n+    }\n+  dest = macroname = (char *) alloca (txt->val.str.len + 2);\n+  src = (const char *) (txt->val.str.text + 1 + (txt->val.str.text[0] == 'L'));\n+  limit = (const char *) (txt->val.str.text + txt->val.str.len - 1);\n+  while (src < limit)\n+    {\n+      /* We know there is a character following the backslash.  */\n+      if (*src == '\\\\' && (src[1] == '\\\\' || src[1] == '\"'))\n+\tsrc++;\n+      *dest++ = *src++;\n+    }\n+  *dest = 0;\n+  check_eol (pfile, false);\n+  skip_rest_of_line (pfile);\n+  c = XNEW (struct def_pragma_macro);\n+  c->name = XNEWVAR (char, strlen (macroname) + 1);\n+  strcpy (c->name, macroname);\n+  c->next = pfile->pushed_macros;\n+  c->value = cpp_push_definition (pfile, c->name);\n+  pfile->pushed_macros = c;\n+}\n+\n+/* Handle #pragma pop_macro(STRING).  */\n+static void\n+do_pragma_pop_macro (cpp_reader *pfile)\n+{\n+  char *macroname, *dest;\n+  const char *limit, *src;\n+  const cpp_token *txt;\n+  struct def_pragma_macro *l = NULL, *c = pfile->pushed_macros;\n+  txt = get__Pragma_string (pfile);\n+  if (!txt)\n+    {\n+      source_location src_loc = pfile->cur_token[-1].src_loc;\n+      cpp_error_with_line (pfile, CPP_DL_ERROR, src_loc, 0,\n+\t\t \"invalid #pragma pop_macro directive\");\n+      check_eol (pfile, false);\n+      skip_rest_of_line (pfile);\n+      return;\n+    }\n+  dest = macroname = (char *) alloca (txt->val.str.len + 2);\n+  src = (const char *) (txt->val.str.text + 1 + (txt->val.str.text[0] == 'L'));\n+  limit = (const char *) (txt->val.str.text + txt->val.str.len - 1);\n+  while (src < limit)\n+    {\n+      /* We know there is a character following the backslash.  */\n+      if (*src == '\\\\' && (src[1] == '\\\\' || src[1] == '\"'))\n+\tsrc++;\n+      *dest++ = *src++;\n+    }\n+  *dest = 0;\n+  check_eol (pfile, false);\n+  skip_rest_of_line (pfile);\n+\n+  while (c != NULL)\n+    {\n+      if (!strcmp (c->name, macroname))\n+\t{\n+\t  if (!l)\n+\t    pfile->pushed_macros = c->next;\n+\t  else\n+\t    l->next = c->next;\n+\t  cpp_pop_definition (pfile, c->name, c->value);\n+\t  free (c->name);\n+\t  free (c);\n+\t  break;\n+\t}\n+      l = c;\n+      c = c->next;\n+    }\n+}\n+\n /* Handle #pragma GCC poison, to poison one or more identifiers so\n    that the lexer produces a hard error for each subsequent usage.  */\n static void\n@@ -2225,28 +2319,11 @@ cpp_undef (cpp_reader *pfile, const char *macro)\n   run_directive (pfile, T_UNDEF, buf, len);\n }\n \n-/* Like lex_macro_node, but read the input from STR.  */\n-static cpp_hashnode *\n-lex_macro_node_from_str (cpp_reader *pfile, const char *str)\n-{\n-  size_t len = strlen (str);\n-  uchar *buf = (uchar *) alloca (len + 1);\n-  cpp_hashnode *node;\n-\n-  memcpy (buf, str, len);\n-  buf[len] = '\\n';\n-  cpp_push_buffer (pfile, buf, len, true);\n-  node = lex_macro_node (pfile, true);\n-  _cpp_pop_buffer (pfile);\n-\n-  return node;\n-}\n-\n /* If STR is a defined macro, return its definition node, else return NULL.  */\n cpp_macro *\n cpp_push_definition (cpp_reader *pfile, const char *str)\n {\n-  cpp_hashnode *node = lex_macro_node_from_str (pfile, str);\n+  cpp_hashnode *node = _cpp_lex_identifier (pfile, str);\n   if (node && node->type == NT_MACRO)\n     return node->value.macro;\n   else\n@@ -2258,7 +2335,7 @@ cpp_push_definition (cpp_reader *pfile, const char *str)\n void\n cpp_pop_definition (cpp_reader *pfile, const char *str, cpp_macro *dfn)\n {\n-  cpp_hashnode *node = lex_macro_node_from_str (pfile, str);\n+  cpp_hashnode *node = _cpp_lex_identifier (pfile, str);\n   if (node == NULL)\n     return;\n "}, {"sha": "522ddbbb6381b17de0383943cf12bd905c60e1cd", "filename": "libcpp/init.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17e7cb855000baa6598005571d7dd49cfac5282a/libcpp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17e7cb855000baa6598005571d7dd49cfac5282a/libcpp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finit.c?ref=17e7cb855000baa6598005571d7dd49cfac5282a", "patch": "@@ -216,6 +216,9 @@ cpp_create_reader (enum c_lang lang, hash_table *table,\n   pfile->a_buff = _cpp_get_buff (pfile, 0);\n   pfile->u_buff = _cpp_get_buff (pfile, 0);\n \n+  /* Initialize table for push_macro/pop_macro.  */\n+  pfile->pushed_macros = 0;\n+\n   /* The expression parser stack.  */\n   _cpp_expand_op_stack (pfile);\n \n@@ -245,6 +248,7 @@ void\n cpp_destroy (cpp_reader *pfile)\n {\n   cpp_context *context, *contextn;\n+  struct def_pragma_macro *pmacro;\n   tokenrun *run, *runn;\n   int i;\n \n@@ -296,6 +300,17 @@ cpp_destroy (cpp_reader *pfile)\n \n       free (pfile->comments.entries);\n     }\n+  if (pfile->pushed_macros)\n+    {\n+      do\n+\t{\n+\t  pmacro = pfile->pushed_macros;\n+\t  pfile->pushed_macros = pmacro->next;\n+\t  free (pmacro->name);\n+\t  free (pmacro);\n+\t}\n+      while (pfile->pushed_macros);\n+    }\n \n   free (pfile);\n }"}, {"sha": "555874c1d47bce6455e031ac9fae41dd3a3e8aaa", "filename": "libcpp/internal.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17e7cb855000baa6598005571d7dd49cfac5282a/libcpp%2Finternal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17e7cb855000baa6598005571d7dd49cfac5282a/libcpp%2Finternal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finternal.h?ref=17e7cb855000baa6598005571d7dd49cfac5282a", "patch": "@@ -305,6 +305,16 @@ struct cpp_buffer\n   struct cset_converter input_cset_desc;\n };\n \n+/* The list of saved macros by push_macro pragma.  */\n+struct def_pragma_macro {\n+  /* Chain element to previous saved macro.  */\n+  struct def_pragma_macro *next;\n+  /* Name of the macro.  */\n+  char *name;\n+  /* The stored macro content.  */\n+  cpp_macro *value;\n+};\n+\n /* A cpp_reader encapsulates the \"state\" of a pre-processor run.\n    Applying cpp_get_token repeatedly yields a stream of pre-processor\n    tokens.  Usually, there is only one cpp_reader object active.  */\n@@ -475,6 +485,9 @@ struct cpp_reader\n \n   /* Table of comments, when state.save_comments is true.  */\n   cpp_comment_table comments;\n+\n+  /* List of saved macros by push_macro.  */\n+  struct def_pragma_macro *pushed_macros;\n };\n \n /* Character classes.  Based on the more primitive macros in safe-ctype.h.\n@@ -575,6 +588,7 @@ extern const cpp_token *_cpp_lex_token (cpp_reader *);\n extern cpp_token *_cpp_lex_direct (cpp_reader *);\n extern int _cpp_equiv_tokens (const cpp_token *, const cpp_token *);\n extern void _cpp_init_tokenrun (tokenrun *, unsigned int);\n+extern cpp_hashnode *_cpp_lex_identifier (cpp_reader *, const char *);\n \n /* In init.c.  */\n extern void _cpp_maybe_push_include_file (cpp_reader *);"}, {"sha": "ac28f92e64093a7dfeb82bd9d40b831630b6c948", "filename": "libcpp/lex.c", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17e7cb855000baa6598005571d7dd49cfac5282a/libcpp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17e7cb855000baa6598005571d7dd49cfac5282a/libcpp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Flex.c?ref=17e7cb855000baa6598005571d7dd49cfac5282a", "patch": "@@ -504,6 +504,63 @@ forms_identifier_p (cpp_reader *pfile, int first,\n   return false;\n }\n \n+/* Helper function to get the cpp_hashnode of the identifier BASE.  */\n+static cpp_hashnode *\n+lex_identifier_intern (cpp_reader *pfile, const uchar *base)\n+{\n+  cpp_hashnode *result;\n+  const uchar *cur;\n+  unsigned int len;\n+  unsigned int hash = HT_HASHSTEP (0, *base);\n+\n+  cur = base + 1;\n+  while (ISIDNUM (*cur))\n+    {\n+      hash = HT_HASHSTEP (hash, *cur);\n+      cur++;\n+    }\n+  len = cur - base;\n+  hash = HT_HASHFINISH (hash, len);\n+  result = CPP_HASHNODE (ht_lookup_with_hash (pfile->hash_table,\n+\t\t\t\t\t      base, len, hash, HT_ALLOC));\n+\n+  /* Rarely, identifiers require diagnostics when lexed.  */\n+  if (__builtin_expect ((result->flags & NODE_DIAGNOSTIC)\n+\t\t\t&& !pfile->state.skipping, 0))\n+    {\n+      /* It is allowed to poison the same identifier twice.  */\n+      if ((result->flags & NODE_POISONED) && !pfile->state.poisoned_ok)\n+\tcpp_error (pfile, CPP_DL_ERROR, \"attempt to use poisoned \\\"%s\\\"\",\n+\t\t   NODE_NAME (result));\n+\n+      /* Constraint 6.10.3.5: __VA_ARGS__ should only appear in the\n+\t replacement list of a variadic macro.  */\n+      if (result == pfile->spec_nodes.n__VA_ARGS__\n+\t  && !pfile->state.va_args_ok)\n+\tcpp_error (pfile, CPP_DL_PEDWARN,\n+\t\t   \"__VA_ARGS__ can only appear in the expansion\"\n+\t\t   \" of a C99 variadic macro\");\n+\n+      /* For -Wc++-compat, warn about use of C++ named operators.  */\n+      if (result->flags & NODE_WARN_OPERATOR)\n+\tcpp_error (pfile, CPP_DL_WARNING,\n+\t\t   \"identifier \\\"%s\\\" is a special operator name in C++\",\n+\t\t   NODE_NAME (result));\n+    }\n+\n+  return result;\n+}\n+\n+/* Get the cpp_hashnode of an identifier specified by NAME in\n+   the current cpp_reader object.  If none is found, NULL is returned.  */\n+cpp_hashnode *\n+_cpp_lex_identifier (cpp_reader *pfile, const char *name)\n+{\n+  cpp_hashnode *result;\n+  result = lex_identifier_intern (pfile, (uchar *) name);\n+  return result;\n+}\n+\n /* Lex an identifier starting at BUFFER->CUR - 1.  */\n static cpp_hashnode *\n lex_identifier (cpp_reader *pfile, const uchar *base, bool starts_ucn,"}, {"sha": "c70759a996d9a857ca53f5c9a32b4a361937c475", "filename": "libcpp/pch.c", "status": "modified", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17e7cb855000baa6598005571d7dd49cfac5282a/libcpp%2Fpch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17e7cb855000baa6598005571d7dd49cfac5282a/libcpp%2Fpch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fpch.c?ref=17e7cb855000baa6598005571d7dd49cfac5282a", "patch": "@@ -33,6 +33,8 @@ static int comp_hashnodes (const void *, const void *);\n static int collect_ht_nodes (cpp_reader *, cpp_hashnode *, void *);\n static int write_defs (cpp_reader *, cpp_hashnode *, void *);\n static int save_macros (cpp_reader *, cpp_hashnode *, void *);\n+static int _cpp_save_pushed_macros (cpp_reader *, FILE *);\n+static int _cpp_restore_pushed_macros (cpp_reader *, FILE *);\n \n /* This structure represents a macro definition on disk.  */\n struct macrodef_struct\n@@ -378,9 +380,140 @@ cpp_write_pch_state (cpp_reader *r, FILE *f)\n       return -1;\n     }\n \n+  /* Write saved macros.  */\n+  if (! _cpp_save_pushed_macros (r, f))\n+    {\n+      cpp_errno (r, CPP_DL_ERROR, \"while writing precompiled header\");\n+      return -1;\n+    }\n+\n   return 0;\n }\n \n+static int\n+_cpp_restore_pushed_macros (cpp_reader *r, FILE *f)\n+{\n+  size_t count_saved = 0;\n+  size_t i;\n+  struct def_pragma_macro *p;\n+  size_t nlen;\n+  cpp_hashnode *h = NULL;\n+  cpp_macro *m;\n+  uchar *defn;\n+  size_t defnlen;\n+\n+  if (fread (&count_saved, sizeof (count_saved), 1, f) != 1)\n+    return 0;\n+  if (! count_saved)\n+    return 1;\n+  for (i = 0; i < count_saved; i++)\n+    {\n+      if (fread (&nlen, sizeof (nlen), 1, f) != 1)\n+\treturn 0;\n+      p = XNEW (struct def_pragma_macro);\n+      p->name = XNEWVAR (char, nlen + 1);\n+      p->name[nlen] = 0;\n+      if (fread (p->name, nlen, 1, f) != 1)\n+\treturn 0;\n+      /* Save old state.  */\n+      m = cpp_push_definition (r, p->name);\n+      if (fread (&defnlen, sizeof (defnlen), 1, f) != 1)\n+\treturn 0;\n+      defn = XNEWVAR (uchar, defnlen + 2);\n+      defn[defnlen] = '\\n';\n+      defn[defnlen + 1] = 0;\n+\n+      if (fread (defn, defnlen, 1, f) != 1)\n+\treturn 0;\n+      cpp_pop_definition (r, p->name, NULL);\n+      {\n+\tsize_t namelen;\n+\tuchar *dn;\n+\n+\tnamelen = ustrcspn (defn, \"( \\n\");\n+\th = cpp_lookup (r, defn, namelen);\n+\tdn = defn + namelen;\n+\n+\th->type = NT_VOID;\n+\th->flags &= ~(NODE_POISONED|NODE_BUILTIN|NODE_DISABLED|NODE_USED);\n+\tif (cpp_push_buffer (r, dn, ustrchr (dn, '\\n') - dn, true)\n+\t    != NULL)\n+\t  {\n+\t    _cpp_clean_line (r);\n+\t    if (!_cpp_create_definition (r, h))\n+\t      abort ();\n+\t    _cpp_pop_buffer (r);\n+\t  }\n+\telse\n+\t  abort ();\n+      }\n+      p->value = cpp_push_definition (r, p->name);\n+\n+      free (defn);\n+      p->next = r->pushed_macros;\n+      r->pushed_macros = p;\n+      /* Restore current state.  */\n+      cpp_pop_definition (r, p->name, m);\n+    }\n+  return 1;\n+}\n+\n+static int\n+_cpp_save_pushed_macros (cpp_reader *r, FILE *f)\n+{\n+  size_t count_saved = 0;\n+  size_t i;\n+  struct def_pragma_macro *p,**pp;\n+  cpp_hashnode *node;\n+  cpp_macro *m;\n+  size_t defnlen;\n+  const uchar *defn;\n+\n+  /* Get count. */\n+  p = r->pushed_macros;\n+  while (p != NULL)\n+    {\n+      count_saved++;\n+      p = p->next;\n+    }\n+  if (fwrite (&count_saved, sizeof (count_saved), 1, f) != 1)\n+    return 0;\n+  if (!count_saved)\n+    return 1;\n+\n+  pp = (struct def_pragma_macro **) alloca (sizeof (struct def_pragma_macro *)\n+\t\t\t\t\t    * count_saved);\n+  /* Store them in reverse order.  */\n+  p = r->pushed_macros;\n+  i = count_saved;\n+  while (p != NULL)\n+    {\n+      --i;\n+      pp[i] = p;\n+      p = p->next;\n+    }\n+  for (i = 0; i < count_saved; i++)\n+    {\n+      /* Save old state.  */\n+      m = cpp_push_definition (r, pp[i]->name);\n+      /* Set temporary macro name to saved state.  */\n+      cpp_pop_definition (r, pp[i]->name, pp[i]->value);\n+      node = _cpp_lex_identifier (r, pp[i]->name);\n+      defnlen = strlen (pp[i]->name);\n+      if (fwrite (&defnlen, sizeof (size_t), 1, f) != 1\n+\t  || fwrite (pp[i]->name, defnlen, 1, f) != 1)\n+\treturn 0;\n+      defn = cpp_macro_definition (r, node);\n+      defnlen = ustrlen (defn);\n+      if (fwrite (&defnlen, sizeof (size_t), 1, f) != 1\n+\t  || fwrite (defn, defnlen, 1, f) != 1)\n+\treturn 0;\n+      /* Restore current state.  */\n+      cpp_pop_definition (r, pp[i]->name, m);\n+    }\n+  return 1;\n+}\n+\n \n /* Data structure to transform hash table nodes into a sorted list */\n \n@@ -752,6 +885,9 @@ cpp_read_state (cpp_reader *r, const char *name, FILE *f,\n   if (!r->counter)\n     r->counter = counter;\n \n+  /* Read pushed macros. */\n+  if (! _cpp_restore_pushed_macros (r, f))\n+    goto error;\n   return 0;\n \n  error:"}]}