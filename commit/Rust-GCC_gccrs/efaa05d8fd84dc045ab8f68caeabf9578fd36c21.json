{"sha": "efaa05d8fd84dc045ab8f68caeabf9578fd36c21", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWZhYTA1ZDhmZDg0ZGMwNDVhYjhmNjhjYWVhYmY5NTc4ZmQzNmMyMQ==", "commit": {"author": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2019-08-04T15:52:55Z"}, "committer": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2019-08-04T15:52:55Z"}, "message": "re PR fortran/88227 (ICE in gfc_convert_boz, at fortran/target-memory.c:788)\n\n2019-08-04  Steven G. Kargl  <kargl@gcc.gnu.org>\n\n\tPR fortran/88227\n\t* check.c (oct2bin):  New function.  Convert octal string to binary.\n\t(hex2bin): New function.  Convert hexidecimal string to binary.\n\t(bin2real): New function.  Convert binary string to REAL.  Use\n\toct2bin and hex2bin.\n\t(gfc_boz2real):  Use fallback conversion bin2real.\n\nFrom-SVN: r274096", "tree": {"sha": "ef1b5cce499cf63a0dd2a49845296036d4afa1be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef1b5cce499cf63a0dd2a49845296036d4afa1be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/efaa05d8fd84dc045ab8f68caeabf9578fd36c21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efaa05d8fd84dc045ab8f68caeabf9578fd36c21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efaa05d8fd84dc045ab8f68caeabf9578fd36c21", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efaa05d8fd84dc045ab8f68caeabf9578fd36c21/comments", "author": null, "committer": null, "parents": [{"sha": "011fc8c66f8195eaf5ae65951b3e2172383bf16d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/011fc8c66f8195eaf5ae65951b3e2172383bf16d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/011fc8c66f8195eaf5ae65951b3e2172383bf16d"}], "stats": {"total": 197, "additions": 189, "deletions": 8}, "files": [{"sha": "534ae3575d0f99b3fe3c2760378b1abf852a4590", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efaa05d8fd84dc045ab8f68caeabf9578fd36c21/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efaa05d8fd84dc045ab8f68caeabf9578fd36c21/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=efaa05d8fd84dc045ab8f68caeabf9578fd36c21", "patch": "@@ -1,3 +1,12 @@\n+2019-08-04  Steven G. Kargl  <kargl@gcc.gnu.org>\n+\n+\tPR fortran/88227\n+\t* check.c (oct2bin):  New function.  Convert octal string to binary.\n+\t(hex2bin): New function.  Convert hexidecimal string to binary.\n+\t(bin2real): New function.  Convert binary string to REAL.  Use\n+\toct2bin and hex2bin.\n+\t(gfc_boz2real):  Use fallback conversion bin2real.\n+\n 2019-08-02  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/90985"}, {"sha": "0204961a4d7b5c9e9ea8166cab36ccaf45e44c7c", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 180, "deletions": 8, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efaa05d8fd84dc045ab8f68caeabf9578fd36c21/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efaa05d8fd84dc045ab8f68caeabf9578fd36c21/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=efaa05d8fd84dc045ab8f68caeabf9578fd36c21", "patch": "@@ -55,6 +55,7 @@ gfc_invalid_boz (const char *msg, locus *loc)\n \n \n /* Issue an error for an illegal BOZ argument.  */\n+\n static bool\n illegal_boz_arg (gfc_expr *x)\n {\n@@ -101,6 +102,167 @@ is_boz_constant (gfc_expr *a)\n }\n \n \n+/* Convert a octal string into a binary string.  This is used in the\n+   fallback conversion of an octal string to a REAL.  */\n+\n+static char *\n+oct2bin(int nbits, char *oct)\n+{\n+  const char bits[8][5] = {\n+    \"000\", \"001\", \"010\", \"011\", \"100\", \"101\", \"110\", \"111\"};\n+\n+  char *buf, *bufp;\n+  int i, j, n;\n+\n+  j = nbits + 1;\n+  if (nbits == 64) j++;\n+\n+  bufp = buf = XCNEWVEC (char, j + 1);\n+  memset (bufp, 0, j + 1);\n+\n+  n = strlen (oct);\n+  for (i = 0; i < n; i++, oct++)\n+    {\n+      j = *oct - 48;\n+      strcpy (bufp, &bits[j][0]);\n+      bufp += 3;\n+    }\n+\n+  bufp = XCNEWVEC (char, nbits + 1);\n+  if (nbits == 64)\n+    strcpy (bufp, buf + 2);\n+  else\n+    strcpy (bufp, buf + 1);\n+\n+  free (buf);\n+\n+  return bufp;\n+}\n+\n+\n+/* Convert a hexidecimal string into a binary string.  This is used in the\n+   fallback conversion of a hexidecimal string to a REAL.  */\n+\n+static char *\n+hex2bin(int nbits, char *hex)\n+{\n+  const char bits[16][5] = {\n+    \"0000\", \"0001\", \"0010\", \"0011\", \"0100\", \"0101\", \"0110\", \"0111\",\n+    \"1000\", \"1001\", \"1010\", \"1011\", \"1100\", \"1101\", \"1110\", \"1111\"};\n+\n+  char *buf, *bufp;\n+  int i, j, n;\n+\n+  bufp = buf = XCNEWVEC (char, nbits + 1);\n+  memset (bufp, 0, nbits + 1);\n+\n+  n = strlen (hex);\n+  for (i = 0; i < n; i++, hex++)\n+    {\n+      j = *hex;\n+      if (j > 47 && j < 58)\n+         j -= 48;\n+      else if (j > 64 && j < 71)\n+         j -= 55;\n+      else if (j > 96 && j < 103)\n+         j -= 87;\n+      else\n+         gcc_unreachable ();\n+\n+      strcpy (bufp, &bits[j][0]);\n+      bufp += 4;\n+   }\n+\n+   return buf;\n+}\n+\n+\n+/* Fallback conversion of a BOZ string to REAL.  */\n+\n+static void\n+bin2real (gfc_expr *x, int kind)\n+{\n+  char buf[114], *sp;\n+  int b, i, ie, t, w;\n+  bool sgn;\n+  mpz_t em;\n+\n+  i = gfc_validate_kind (BT_REAL, kind, false);\n+  t = gfc_real_kinds[i].digits - 1;\n+\n+  /* Number of bits in the exponent.  */\n+  if (gfc_real_kinds[i].max_exponent == 16384)\n+    w = 15;\n+  else if (gfc_real_kinds[i].max_exponent == 1024)\n+    w = 11;\n+  else\n+    w = 8;\n+\n+  if (x->boz.rdx == 16)\n+    sp = hex2bin (gfc_real_kinds[i].mode_precision, x->boz.str);\n+  else if (x->boz.rdx == 8)\n+    sp = oct2bin (gfc_real_kinds[i].mode_precision, x->boz.str);\n+  else\n+    sp = x->boz.str;\n+\n+  /* Extract sign bit. */\n+  sgn = *sp != '0';\n+\n+  /* Extract biased exponent. */\n+  memset (buf, 0, 114);\n+  strncpy (buf, ++sp, w);\n+  mpz_init (em);\n+  mpz_set_str (em, buf, 2);\n+  ie = mpz_get_si (em);\n+\n+  mpfr_init2 (x->value.real, t + 1);\n+  x->ts.type = BT_REAL;\n+  x->ts.kind = kind;\n+\n+  sp += w;\t\t/* Set to first digit in significand. */\n+  b = (1 << w) - 1;\n+  if ((i == 0 && ie == b) || (i == 1 && ie == b)\n+      || ((i == 2 || i == 3) && ie == b))\n+    {\n+      bool zeros = true;\n+      if (i == 2) sp++;\n+      for (; *sp; sp++)\n+\t{\n+\t  if (*sp != '0')\n+\t    {\n+\t      zeros = false;\n+\t      break;\n+\t    }\n+\t}\n+\n+      if (zeros)\n+\tmpfr_set_inf (x->value.real, 1);\n+      else\n+\tmpfr_set_nan (x->value.real);\n+    }\n+  else\n+    {\n+      if (i == 2)\n+\tstrncpy (buf, sp, t + 1);\n+      else\n+\t{\n+\t  /* Significand with hidden bit. */\n+ \t  buf[0] = '1';\n+\t  strncpy (&buf[1], sp, t);\n+\t}\n+\n+      /* Convert to significand to integer. */\n+      mpz_set_str (em, buf, 2);\n+      ie -= ((1 << (w - 1)) - 1);\t/* Unbiased exponent. */\n+      mpfr_set_z_2exp (x->value.real, em, ie - t, GFC_RND_MODE);\n+    }\n+\n+   if (sgn) mpfr_neg (x->value.real, x->value.real, GFC_RND_MODE);\n+\n+   mpz_clear (em);\n+}\n+\n+\n /* Fortran 2018 treats a BOZ as simply a string of bits.  gfc_boz2real () \n    converts the string into a REAL of the appropriate kind.  The treatment\n    of the sign bit is processor dependent.  */\n@@ -158,21 +320,31 @@ gfc_boz2real (gfc_expr *x, int kind)\n \t    buf[0] = '1';\n \t}\n     }\n- \n+\n   /* Reset BOZ string to the truncated or padded version.  */\n   free (x->boz.str);\n   x->boz.len = len;\n   x->boz.str = XCNEWVEC (char, len + 1);\n   strncpy (x->boz.str, buf, len);\n \n-  /* Convert to widest possible integer.  */\n-  gfc_boz2int (x, gfc_max_integer_kind);\n-  ts.type = BT_REAL;\n-  ts.kind = kind;\n-  if (!gfc_convert_boz (x, &ts))\n+  /* For some targets, the largest INTEGER in terms of bits is smaller than\n+     the bits needed to hold the REAL.  Fortunately, the kind type parameter\n+     indicates the number of bytes required to an INTEGER and a REAL.  */\n+  if (gfc_max_integer_kind < kind)\n     {\n-      gfc_error (\"Failure in conversion of BOZ to REAL at %L\", &x->where);\n-      return false;\n+      bin2real (x, kind);\n+    }\n+  else\n+    {\n+      /* Convert to widest possible integer.  */\n+      gfc_boz2int (x, gfc_max_integer_kind);\n+      ts.type = BT_REAL;\n+      ts.kind = kind;\n+      if (!gfc_convert_boz (x, &ts))\n+\t{\n+\t  gfc_error (\"Failure in conversion of BOZ to REAL at %L\", &x->where);\n+\t  return false;\n+\t}\n     }\n \n   return true;"}]}