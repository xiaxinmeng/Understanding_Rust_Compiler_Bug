{"sha": "f38b36471d70e816a50ccca27628fe812ee8c3af", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjM4YjM2NDcxZDcwZTgxNmE1MGNjY2EyNzYyOGZlODEyZWU4YzNhZg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2017-11-11T12:58:13Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2017-11-11T12:58:13Z"}, "message": "tree-ssa-tail-merge.c (replace_block_by): Fix and re-enable profile merging.\n\n\n\t* tree-ssa-tail-merge.c (replace_block_by): Fix and re-enable profile\n\tmerging.\n\nFrom-SVN: r254650", "tree": {"sha": "541d8bdacd2ae32bac2845761d875874961eca45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/541d8bdacd2ae32bac2845761d875874961eca45"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f38b36471d70e816a50ccca27628fe812ee8c3af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f38b36471d70e816a50ccca27628fe812ee8c3af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f38b36471d70e816a50ccca27628fe812ee8c3af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f38b36471d70e816a50ccca27628fe812ee8c3af/comments", "author": null, "committer": null, "parents": [{"sha": "e8c91a4c5e45209c7cab7c71c36e346bf870547e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8c91a4c5e45209c7cab7c71c36e346bf870547e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8c91a4c5e45209c7cab7c71c36e346bf870547e"}], "stats": {"total": 70, "additions": 28, "deletions": 42}, "files": [{"sha": "bcf42d9188dbaecd154e1c205ec48ba25439cc41", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f38b36471d70e816a50ccca27628fe812ee8c3af/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f38b36471d70e816a50ccca27628fe812ee8c3af/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f38b36471d70e816a50ccca27628fe812ee8c3af", "patch": "@@ -1,3 +1,8 @@\n+2017-11-10  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* tree-ssa-tail-merge.c (replace_block_by): Fix and re-enable profile\n+\tmerging.\n+\n 2017-11-10  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \t* config/rs6000/rs6000.md (bswaphi2_reg): On ISA 3.0 systems,"}, {"sha": "e90283b9cc8bd7a00edd44918fa2b99dc51c2a9a", "filename": "gcc/tree-ssa-tail-merge.c", "status": "modified", "additions": 23, "deletions": 42, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f38b36471d70e816a50ccca27628fe812ee8c3af/gcc%2Ftree-ssa-tail-merge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f38b36471d70e816a50ccca27628fe812ee8c3af/gcc%2Ftree-ssa-tail-merge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-tail-merge.c?ref=f38b36471d70e816a50ccca27628fe812ee8c3af", "patch": "@@ -1556,52 +1556,33 @@ replace_block_by (basic_block bb1, basic_block bb2)\n \t\t   pred_edge, UNKNOWN_LOCATION);\n     }\n \n-  bb2->count += bb1->count;\n \n-  /* FIXME: Fix merging of probabilities.  They need to be redistributed\n-     according to the relative counts of merged BBs.  */\n-#if 0\n   /* Merge the outgoing edge counts from bb1 onto bb2.  */\n-  profile_count out_sum = profile_count::zero ();\n-  int out_freq_sum = 0;\n   edge e1, e2;\n+  edge_iterator ei;\n \n-  /* Recompute the edge probabilities from the new merged edge count.\n-     Use the sum of the new merged edge counts computed above instead\n-     of bb2's merged count, in case there are profile count insanities\n-     making the bb count inconsistent with the edge weights.  */\n-  FOR_EACH_EDGE (e1, ei, bb1->succs)\n-    {\n-      if (e1->count ().initialized_p ())\n-\tout_sum += e1->count ();\n-      out_freq_sum += EDGE_FREQUENCY (e1);\n-    }\n-  FOR_EACH_EDGE (e1, ei, bb2->succs)\n-    {\n-      if (e1->count ().initialized_p ())\n-\tout_sum += e1->count ();\n-      out_freq_sum += EDGE_FREQUENCY (e1);\n-    }\n-  FOR_EACH_EDGE (e1, ei, bb1->succs)\n-    {\n-      e2 = find_edge (bb2, e1->dest);\n-      gcc_assert (e2);\n-      if (out_sum > 0 && e2->count ().initialized_p ())\n-\t{\n-\t  e2->probability = e2->count ().probability_in (bb2->count);\n-\t}\n-      else if (bb1->count.to_frequency (cfun) && bb2->count.to_frequency (cfun))\n-\te2->probability = e1->probability;\n-      else if (bb2->count.to_frequency (cfun) && !bb1->count.to_frequency (cfun))\n-\t;\n-      else if (out_freq_sum)\n-\te2->probability = profile_probability::from_reg_br_prob_base\n-\t\t(GCOV_COMPUTE_SCALE (EDGE_FREQUENCY (e1)\n-\t\t\t\t     + EDGE_FREQUENCY (e2),\n-\t\t\t\t     out_freq_sum));\n-      out_sum += e2->count ();\n-    }\n-#endif\n+  if (bb2->count.initialized_p ())\n+    FOR_EACH_EDGE (e1, ei, bb1->succs)\n+      {\n+        e2 = find_edge (bb2, e1->dest);\n+        gcc_assert (e2);\n+\n+\t/* If probabilities are same, we are done.\n+\t   If counts are nonzero we can distribute accordingly. In remaining\n+\t   cases just avreage the values and hope for the best.  */\n+\tif (e1->probability == e2->probability)\n+\t  ;\n+\telse if (bb1->count.nonzero_p () || bb2->count.nonzero_p ())\n+\t  e2->probability\n+\t     = e2->probability\n+\t\t * bb2->count.probability_in (bb1->count + bb2->count)\n+\t       + e1->probability\n+\t\t * bb1->count.probability_in (bb1->count + bb2->count);\n+\telse\n+\t  e2->probability = e2->probability * profile_probability::even ()\n+\t\t\t    + e1->probability * profile_probability::even ();\n+      }\n+  bb2->count += bb1->count;\n \n   /* Move over any user labels from bb1 after the bb2 labels.  */\n   gimple_stmt_iterator gsi1 = gsi_start_bb (bb1);"}]}