{"sha": "c63bb4f3aaa18b5e4c8722c655187d592faecde3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzYzYmI0ZjNhYWExOGI1ZTRjODcyMmM2NTUxODdkNTkyZmFlY2RlMw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-12-21T07:37:34Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-05-04T09:17:29Z"}, "message": "[Ada] Preliminary cleanup in floating-point output implementation\n\ngcc/ada/\n\n\t* exp_intr.adb: Remove with/use clauses for Urealp.\n\t(Expand_Is_Negative): Delete.\n\t(Expand_Intrinsic_Call): Do not call it.\n\t* rtsfind.ads (RE_Id): Remove RE_Float_Unsigned.\n\t(RE_Unit_Table): Remove entry for RE_Float_Unsigned.\n\t* snames.ads-tmpl (Name_Is_Negative): Delete.\n\t* libgnat/s-imgrea.ads (Set_Image_Real): Fix mode of S parameter.\n\t* libgnat/s-imgrea.adb: Add with/use clauses for System.Img_Util.\n\t(LLU): New subtype.\n\t(Maxdigs): Use it.\n\t(Is_Negative): Reimplement.\n\t(Image_Floating_Point): Simplify.\n\t(Set_Image_Real): Fix mode of S parameter.  Remove the low-level\n\tprocessing on characters.  Flip the sign of the Scale variable.\n\tCompute the maximum number of digits for the straight notation.\n\tCall Set_Decimal_Digits at the end to do the final formatting.\n\t* libgnat/s-imguti.ads (Floating_Invalid_Value): New type.\n\t(Set_Floating_Invalid_Value): New procedure.\n\t* libgnat/s-imguti.adb (Set_Floating_Invalid_Value): Implement it\n\tbased on existing code from Set_Image_Real.\n\t* libgnat/s-unstyp.ads (Float_Unsigned): Delete.", "tree": {"sha": "bef7b61185e6aa11bbde035d063122c6bfb8f598", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bef7b61185e6aa11bbde035d063122c6bfb8f598"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c63bb4f3aaa18b5e4c8722c655187d592faecde3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c63bb4f3aaa18b5e4c8722c655187d592faecde3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c63bb4f3aaa18b5e4c8722c655187d592faecde3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c63bb4f3aaa18b5e4c8722c655187d592faecde3/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4b0a294694a145aa33a25d1f923f4085b8f7d99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4b0a294694a145aa33a25d1f923f4085b8f7d99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4b0a294694a145aa33a25d1f923f4085b8f7d99"}], "stats": {"total": 632, "additions": 196, "deletions": 436}, "files": [{"sha": "e2c3e34327840bd48db0f5788933a890f667c07e", "filename": "gcc/ada/exp_intr.adb", "status": "modified", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c63bb4f3aaa18b5e4c8722c655187d592faecde3/gcc%2Fada%2Fexp_intr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c63bb4f3aaa18b5e4c8722c655187d592faecde3/gcc%2Fada%2Fexp_intr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_intr.adb?ref=c63bb4f3aaa18b5e4c8722c655187d592faecde3", "patch": "@@ -54,7 +54,6 @@ with Snames;   use Snames;\n with Stand;    use Stand;\n with Tbuild;   use Tbuild;\n with Uintp;    use Uintp;\n-with Urealp;   use Urealp;\n \n package body Exp_Intr is\n \n@@ -66,9 +65,6 @@ package body Exp_Intr is\n    --  Expand a call to an intrinsic arithmetic operator when the operand\n    --  types or sizes are not identical.\n \n-   procedure Expand_Is_Negative (N : Node_Id);\n-   --  Expand a call to the intrinsic Is_Negative function\n-\n    procedure Expand_Dispatching_Constructor_Call (N : Node_Id);\n    --  Expand a call to an instantiation of Generic_Dispatching_Constructor\n    --  into a dispatching call to the actual subprogram associated with the\n@@ -636,9 +632,6 @@ package body Exp_Intr is\n       then\n          Expand_Import_Call (N);\n \n-      elsif Nam = Name_Is_Negative then\n-         Expand_Is_Negative (N);\n-\n       elsif Nam = Name_Rotate_Left then\n          Expand_Shift (N, E, N_Op_Rotate_Left);\n \n@@ -696,58 +689,6 @@ package body Exp_Intr is\n       end if;\n    end Expand_Intrinsic_Call;\n \n-   ------------------------\n-   -- Expand_Is_Negative --\n-   ------------------------\n-\n-   procedure Expand_Is_Negative (N : Node_Id) is\n-      Loc   : constant Source_Ptr := Sloc (N);\n-      Opnd  : constant Node_Id    := Relocate_Node (First_Actual (N));\n-\n-   begin\n-\n-      --  We replace the function call by the following expression\n-\n-      --    if Opnd < 0.0 then\n-      --       True\n-      --    else\n-      --       if Opnd > 0.0 then\n-      --          False;\n-      --       else\n-      --          Float_Unsigned!(Float (Opnd)) /= 0\n-      --       end if;\n-      --    end if;\n-\n-      Rewrite (N,\n-        Make_If_Expression (Loc,\n-          Expressions => New_List (\n-            Make_Op_Lt (Loc,\n-              Left_Opnd  => Duplicate_Subexpr (Opnd),\n-              Right_Opnd => Make_Real_Literal (Loc, Ureal_0)),\n-\n-            New_Occurrence_Of (Standard_True, Loc),\n-\n-            Make_If_Expression (Loc,\n-             Expressions => New_List (\n-               Make_Op_Gt (Loc,\n-                 Left_Opnd  => Duplicate_Subexpr_No_Checks (Opnd),\n-                 Right_Opnd => Make_Real_Literal (Loc, Ureal_0)),\n-\n-               New_Occurrence_Of (Standard_False, Loc),\n-\n-                Make_Op_Ne (Loc,\n-                  Left_Opnd =>\n-                    Unchecked_Convert_To\n-                      (RTE (RE_Float_Unsigned),\n-                       Convert_To\n-                         (Standard_Float,\n-                          Duplicate_Subexpr_No_Checks (Opnd))),\n-                  Right_Opnd =>\n-                    Make_Integer_Literal (Loc, 0)))))));\n-\n-      Analyze_And_Resolve (N, Standard_Boolean);\n-   end Expand_Is_Negative;\n-\n    ------------------\n    -- Expand_Shift --\n    ------------------"}, {"sha": "3ec41561b12bceb9e2136bd29f16833e7da3e352", "filename": "gcc/ada/libgnat/s-imgrea.adb", "status": "modified", "additions": 99, "deletions": 370, "changes": 469, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c63bb4f3aaa18b5e4c8722c655187d592faecde3/gcc%2Fada%2Flibgnat%2Fs-imgrea.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c63bb4f3aaa18b5e4c8722c655187d592faecde3/gcc%2Fada%2Flibgnat%2Fs-imgrea.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imgrea.adb?ref=c63bb4f3aaa18b5e4c8722c655187d592faecde3", "patch": "@@ -31,11 +31,15 @@\n \n with System.Img_LLU;    use System.Img_LLU;\n with System.Img_Uns;    use System.Img_Uns;\n+with System.Img_Util;   use System.Img_Util;\n with System.Powten_LLF; use System.Powten_LLF;\n+\n with System.Float_Control;\n \n package body System.Img_Real is\n \n+   subtype LLU is Long_Long_Unsigned;\n+\n    --  The following defines the maximum number of digits that we can convert\n    --  accurately. This is limited by the precision of Long_Long_Float, and\n    --  also by the number of digits we can hold in Long_Long_Unsigned, which\n@@ -46,18 +50,13 @@ package body System.Img_Real is\n    --  implementations, and at worst, the only loss is for some precision\n    --  in very high precision floating-point output.\n \n-   --  Note that in the following, the \"-2\" accounts for the sign and one\n+   --  Note that in the following, the \"-2\" accounts for the space and one\n    --  extra digit, since we need the maximum number of 9's that can be\n    --  represented, e.g. for the 64-bit case, Long_Long_Unsigned'Width is\n    --  21, since the maximum value (approx 1.8E+19) has 20 digits, but the\n    --  maximum number of 9's that can be represented is only 19.\n \n-   Maxdigs : constant :=\n-               Natural'Min\n-                 (Long_Long_Unsigned'Width - 2, Long_Long_Float'Digits);\n-\n-   Unsdigs : constant := Unsigned'Width - 2;\n-   --  Number of digits that can be converted using type Unsigned\n+   Maxdigs : constant := Natural'Min (LLU'Width - 2, Long_Long_Float'Digits);\n \n    Maxscaling : constant := 5000;\n    --  Max decimal scaling required during conversion of floating-point\n@@ -69,7 +68,8 @@ package body System.Img_Real is\n    --  enough room for scaling such values\n \n    function Is_Negative (V : Long_Long_Float) return Boolean;\n-   pragma Import (Intrinsic, Is_Negative);\n+   --  Return True if V is negative for the purpose of the output, i.e. return\n+   --  True for negative zeros only if Signed_Zeros is True.\n \n    --------------------------\n    -- Image_Floating_Point --\n@@ -86,14 +86,12 @@ package body System.Img_Real is\n    begin\n       --  Decide whether a blank should be prepended before the call to\n       --  Set_Image_Real. We generate a blank for positive values, and\n-      --  also for positive zeroes. For negative zeroes, we generate a\n+      --  also for positive zeros. For negative zeros, we generate a\n       --  blank only if Signed_Zeros is False (the RM only permits the\n       --  output of -0.0 when Signed_Zeros is True). We do not generate\n       --  a blank for positive infinity, since we output an explicit +.\n \n-      if (not Is_Negative (V) and then V <= Long_Long_Float'Last)\n-        or else (not Long_Long_Float'Signed_Zeros and then V = -0.0)\n-      then\n+      if not Is_Negative (V) and then V <= Long_Long_Float'Last then\n          pragma Annotate (CodePeer, False_Positive, \"condition predetermined\",\n                           \"CodePeer analysis ignores NaN and Inf values\");\n          pragma Assert (S'Last > 1);\n@@ -133,68 +131,59 @@ package body System.Img_Real is\n       Set_Image_Real (V, S, P, 1, Aft, 0);\n    end Image_Ordinary_Fixed_Point;\n \n+   -----------------\n+   -- Is_Negative --\n+   -----------------\n+\n+   function Is_Negative (V : Long_Long_Float) return Boolean is\n+   begin\n+      if V < 0.0 then\n+         return True;\n+\n+      elsif V > 0.0 then\n+         return False;\n+\n+      elsif not Long_Long_Float'Signed_Zeros then\n+         return False;\n+\n+      else\n+         return Long_Long_Float'Copy_Sign (1.0, V) < 0.0;\n+      end if;\n+   end Is_Negative;\n+\n    --------------------\n    -- Set_Image_Real --\n    --------------------\n \n    procedure Set_Image_Real\n      (V    : Long_Long_Float;\n-      S    : out String;\n+      S    : in out String;\n       P    : in out Natural;\n       Fore : Natural;\n       Aft  : Natural;\n       Exp  : Natural)\n    is\n       NFrac : constant Natural := Natural'Max (Aft, 1);\n-      Minus : Boolean;\n-      X     : Long_Long_Float;\n-      Scale : Integer;\n-      Expon : Integer;\n+      --  Number of digits after the decimal point\n \n-      Digs : String (1 .. Max_Real_Image_Length);\n-      --  Array used to hold digits of converted integer value. This is a large\n-      --  enough buffer to accommodate ludicrous Fore/Aft/Exp combinations.\n+      Digs : String (1 .. 3 + Maxdigs);\n+      --  Array used to hold digits of converted integer value\n \n       Ndigs : Natural;\n       --  Number of digits stored in Digs (and also subscript of last digit)\n \n+      Scale : Integer := 0;\n+      --  Exponent such that the result is Digs (1 .. NDigs) * 10**(-Scale)\n+\n+      X : Long_Long_Float;\n+      --  Current absolute value of the input after scaling\n+\n       procedure Adjust_Scale (S : Natural);\n       --  Adjusts the value in X by multiplying or dividing by a power of\n-      --  ten so that it is in the range 10**(S-1) <= X < 10**S. Includes\n-      --  adding 0.5 to round the result, readjusting if the rounding causes\n-      --  the result to wander out of the range. Scale is adjusted to reflect\n-      --  the power of ten used to divide the result (i.e. one is added to\n-      --  the scale value for each division by 10.0, or one is subtracted\n-      --  for each multiplication by 10.0).\n-\n-      procedure Convert_Integer;\n-      --  Takes the value in X, outputs integer digits into Digs. On return,\n-      --  Ndigs is set to the number of digits stored. The digits are stored\n-      --  in Digs (1 .. Ndigs),\n-\n-      procedure Set (C : Character);\n-      --  Sets character C in output buffer\n-\n-      procedure Set_Blanks_And_Sign (N : Integer);\n-      --  Sets leading blanks and minus sign if needed. N is the number of\n-      --  positions to be filled (a minus sign is output even if N is zero\n-      --  or negative, but for a positive value, if N is non-positive, then\n-      --  the call has no effect).\n-\n-      procedure Set_Digs (S, E : Natural);\n-      --  Set digits S through E from Digs buffer. No effect if S > E\n-\n-      procedure Set_Special_Fill (N : Natural);\n-      --  After outputting +Inf, -Inf or NaN, this routine fills out the\n-      --  rest of the field with * characters. The argument is the number\n-      --  of characters output so far (either 3 or 4)\n-\n-      procedure Set_Zeros (N : Integer);\n-      --  Set N zeros, no effect if N is negative\n-\n-      pragma Inline (Set);\n-      pragma Inline (Set_Digs);\n-      pragma Inline (Set_Zeros);\n+      --  ten so that it is in the range 10**(S-1) <= X < 10**S. Scale is\n+      --  adjusted to reflect the power of ten used to divide the result,\n+      --  i.e. one is added to the scale value for each multiplication by\n+      --  10.0 and one is subtracted for each division by 10.0.\n \n       ------------------\n       -- Adjust_Scale --\n@@ -216,9 +205,9 @@ package body System.Img_Real is\n \n             loop\n                XP := X * Powten (Maxpow);\n-               exit when XP >= Powten (S - 1) or else Scale < -Maxscaling;\n+               exit when XP >= Powten (S - 1) or else Scale > Maxscaling;\n                X := XP;\n-               Scale := Scale - Maxpow;\n+               Scale := Scale + Maxpow;\n             end loop;\n \n             --  The following exception is only raised in case of erroneous\n@@ -227,7 +216,7 @@ package body System.Img_Real is\n             --  when a system which is supposed to be IEEE-compliant, but\n             --  has been reconfigured to flush denormals to zero.\n \n-            if Scale < -Maxscaling then\n+            if Scale > Maxscaling then\n                raise Constraint_Error;\n             end if;\n \n@@ -275,7 +264,7 @@ package body System.Img_Real is\n             end loop;\n \n             X := XP;\n-            Scale := Scale - Mid;\n+            Scale := Scale + Mid;\n \n          --  Cases where scaling down is required\n \n@@ -288,9 +277,9 @@ package body System.Img_Real is\n \n             loop\n                XP := X / Powten (Maxpow);\n-               exit when XP < Powten (S) or else Scale > Maxscaling;\n+               exit when XP < Powten (S) or else Scale < -Maxscaling;\n                X := XP;\n-               Scale := Scale + Maxpow;\n+               Scale := Scale - Maxpow;\n             end loop;\n \n             --  The following exception is only raised in case of erroneous\n@@ -299,7 +288,7 @@ package body System.Img_Real is\n             --  when a system which is supposed to be IEEE-compliant, but\n             --  has been reconfigured to flush denormals to zero.\n \n-            if Scale > Maxscaling then\n+            if Scale < -Maxscaling then\n                raise Constraint_Error;\n             end if;\n \n@@ -341,141 +330,15 @@ package body System.Img_Real is\n             end loop;\n \n             X := XP;\n-            Scale := Scale + Mid;\n+            Scale := Scale - Mid;\n \n          --  Here we are already scaled right\n \n          else\n             null;\n          end if;\n-\n-         --  Round, readjusting scale if needed. Note that if a readjustment\n-         --  occurs, then it is never necessary to round again, because there\n-         --  is no possibility of such a second rounding causing a change.\n-\n-         X := X + 0.5;\n-\n-         if X >= Powten (S) then\n-            X := X / 10.0;\n-            Scale := Scale + 1;\n-         end if;\n-\n       end Adjust_Scale;\n \n-      ---------------------\n-      -- Convert_Integer --\n-      ---------------------\n-\n-      procedure Convert_Integer is\n-      begin\n-         --  Use Unsigned routine if possible, since on many machines it will\n-         --  be significantly more efficient than the Long_Long_Unsigned one.\n-\n-         if X < Powten (Unsdigs) then\n-            pragma Assert (X in 0.0 .. Long_Long_Float (Unsigned'Last));\n-            Ndigs := 0;\n-            Set_Image_Unsigned\n-              (Unsigned (Long_Long_Float'Truncation (X)),\n-               Digs, Ndigs);\n-\n-         --  But if we want more digits than fit in Unsigned, we have to use\n-         --  the Long_Long_Unsigned routine after all.\n-\n-         else\n-            pragma Assert (X < Powten (Maxdigs));\n-            pragma Assert\n-              (X in 0.0 .. Long_Long_Float (Long_Long_Unsigned'Last));\n-\n-            Ndigs := 0;\n-            Set_Image_Long_Long_Unsigned\n-              (Long_Long_Unsigned (Long_Long_Float'Truncation (X)),\n-               Digs, Ndigs);\n-         end if;\n-      end Convert_Integer;\n-\n-      ---------\n-      -- Set --\n-      ---------\n-\n-      procedure Set (C : Character) is\n-      begin\n-         pragma Assert (P in S'First - 1 .. S'Last - 1);\n-         --  No check is done as documented in the header: updating P to point\n-         --  to the last character stored, the caller promises that the buffer\n-         --  is large enough and no check is made for this. Constraint_Error\n-         --  will not necessarily be raised if this requirement is violated,\n-         --  since it is perfectly valid to compile this unit with checks off.\n-         P := P + 1;\n-         S (P) := C;\n-      end Set;\n-\n-      -------------------------\n-      -- Set_Blanks_And_Sign --\n-      -------------------------\n-\n-      procedure Set_Blanks_And_Sign (N : Integer) is\n-      begin\n-         if Minus then\n-            for J in 1 .. N - 1 loop\n-               Set (' ');\n-            end loop;\n-\n-            Set ('-');\n-\n-         else\n-            for J in 1 .. N loop\n-               Set (' ');\n-            end loop;\n-         end if;\n-      end Set_Blanks_And_Sign;\n-\n-      --------------\n-      -- Set_Digs --\n-      --------------\n-\n-      procedure Set_Digs (S, E : Natural) is\n-      begin\n-         pragma Assert (S >= Digs'First and E <= Digs'Last);\n-         --  S and E should be in the Digs array range\n-         for J in S .. E loop\n-            Set (Digs (J));\n-         end loop;\n-      end Set_Digs;\n-\n-      ----------------------\n-      -- Set_Special_Fill --\n-      ----------------------\n-\n-      procedure Set_Special_Fill (N : Natural) is\n-         F : Natural;\n-\n-      begin\n-         pragma Assert ((Fore + Aft - N + 1) in Natural);\n-         --  Fore + Aft - N + 1 should be in the Natural range\n-         F := Fore + 1 + Aft - N;\n-\n-         if Exp /= 0 then\n-            pragma Assert (F + Exp + 1 <= Natural'Last);\n-            --  F + Exp + 1 should be in the Natural range\n-            F := F + Exp + 1;\n-         end if;\n-\n-         for J in 1 .. F loop\n-            Set ('*');\n-         end loop;\n-      end Set_Special_Fill;\n-\n-      ---------------\n-      -- Set_Zeros --\n-      ---------------\n-\n-      procedure Set_Zeros (N : Integer) is\n-      begin\n-         for J in 1 .. N loop\n-            Set ('0');\n-         end loop;\n-      end Set_Zeros;\n-\n    --  Start of processing for Set_Image_Real\n \n    begin\n@@ -486,9 +349,7 @@ package body System.Img_Real is\n \n       System.Float_Control.Reset;\n \n-      Scale := 0;\n-\n-      --  Deal with invalid values first,\n+      --  Deal with invalid values first\n \n       if not V'Valid then\n \n@@ -500,218 +361,86 @@ package body System.Img_Real is\n          --  converting to infinity or some other value, or causing an\n          --  exception to be raised is fine.\n \n-         --  If the following test succeeds, then we definitely have\n-         --  an infinite value, so we print Inf.\n+         --  If the following two tests succeed, then we definitely have\n+         --  an infinite value, so we print +Inf or -Inf.\n \n          if V > Long_Long_Float'Last then\n             pragma Annotate (CodePeer, False_Positive, \"dead code\",\n                              \"CodePeer analysis ignores NaN and Inf values\");\n             pragma Annotate (CodePeer, False_Positive, \"test always true\",\n                              \"CodePeer analysis ignores NaN and Inf values\");\n-            Set ('+');\n-            Set ('I');\n-            Set ('n');\n-            Set ('f');\n-            Set_Special_Fill (4);\n-         --  In all other cases we print NaN\n \n-         elsif V < Long_Long_Float'First then\n-            Set ('-');\n-            Set ('I');\n-            Set ('n');\n-            Set ('f');\n-            Set_Special_Fill (4);\n-         else\n-            Set ('N');\n-            Set ('a');\n-            Set ('N');\n-            Set_Special_Fill (3);\n-         end if;\n+            Set_Floating_Invalid_Value (Infinity, S, P, Fore, Aft, Exp);\n \n-         return;\n-      end if;\n-\n-      --  Positive values\n-\n-      if V > 0.0 then\n-         X := V;\n-         Minus := False;\n-\n-      --  Negative values\n-\n-      elsif V < 0.0 then\n-         X := -V;\n-         Minus := True;\n+         elsif V < Long_Long_Float'First then\n+            Set_Floating_Invalid_Value (Minus_Infinity, S, P, Fore, Aft, Exp);\n \n-      --  Zero values\n+         --  In all other cases we print NaN\n \n-      elsif V = 0.0 then\n-         if Long_Long_Float'Signed_Zeros and then Is_Negative (V) then\n-            Minus := True;\n          else\n-            Minus := False;\n-         end if;\n-\n-         Set_Blanks_And_Sign (Fore - 1);\n-         Set ('0');\n-         Set ('.');\n-         Set_Zeros (NFrac);\n-\n-         if Exp /= 0 then\n-            Set ('E');\n-            Set ('+');\n-            Set_Zeros (Natural'Max (1, Exp - 1));\n+            Set_Floating_Invalid_Value (Not_A_Number, S, P, Fore, Aft, Exp);\n          end if;\n \n          return;\n-\n-      else\n-         --  It should not be possible for a NaN to end up here.\n-         --  Either the 'Valid test has failed, or we have some form\n-         --  of erroneous execution. Raise Constraint_Error instead of\n-         --  attempting to go ahead printing the value.\n-\n-         raise Constraint_Error;\n       end if;\n \n-      --  X and Minus are set here, and X is known to be a valid,\n-      --  non-zero floating-point number.\n-\n-      --  Case of non-zero value with Exp = 0\n-\n-      if Exp = 0 then\n-\n-         --  First step is to multiply by 10 ** Nfrac to get an integer\n-         --  value to be output, an then add 0.5 to round the result.\n-\n-         declare\n-            NF : Natural := NFrac;\n-\n-         begin\n-            loop\n-               --  If we are larger than Powten (Maxdigs) now, then\n-               --  we have too many significant digits, and we have\n-               --  not even finished multiplying by NFrac (NF shows\n-               --  the number of unaccounted-for digits).\n-\n-               if X >= Powten (Maxdigs) then\n+      --  Set the first character like Image\n \n-                  --  In this situation, we only to generate a reasonable\n-                  --  number of significant digits, and then zeroes after.\n-                  --  So first we rescale to get:\n+      Digs (1) := (if Is_Negative (V) then '-' else ' ');\n+      Ndigs := 1;\n \n-                  --    10 ** (Maxdigs - 1) <= X < 10 ** Maxdigs\n+      X := abs (V);\n \n-                  --  and then convert the resulting integer\n+      --  If X is zero, we are done\n \n-                  Adjust_Scale (Maxdigs);\n-                  Convert_Integer;\n+      if X = 0.0 then\n+         Digs (2) := '0';\n+         Ndigs := 2;\n \n-                  --  If that caused rescaling, then add zeros to the end\n-                  --  of the number to account for this scaling. Also add\n-                  --  zeroes to account for the undone multiplications\n-\n-                  for J in 1 .. Scale + NF loop\n-                     Ndigs := Ndigs + 1;\n-                     pragma Assert (Ndigs <= Digs'Last);\n-                     Digs (Ndigs) := '0';\n-                  end loop;\n-\n-                  exit;\n-\n-               --  If multiplication is complete, then convert the resulting\n-               --  integer after rounding (note that X is non-negative)\n-\n-               elsif NF = 0 then\n-                  X := X + 0.5;\n-                  Convert_Integer;\n-                  exit;\n-\n-               --  Otherwise we can go ahead with the multiplication. If it\n-               --  can be done in one step, then do it in one step.\n-\n-               elsif NF < Maxpow then\n-                  X := X * Powten (NF);\n-                  NF := 0;\n-\n-               --  If it cannot be done in one step, then do partial scaling\n-\n-               else\n-                  X := X * Powten (Maxpow);\n-                  NF := NF - Maxpow;\n-               end if;\n-            end loop;\n-         end;\n-\n-         --  If number of available digits is less or equal to NFrac,\n-         --  then we need an extra zero before the decimal point.\n-\n-         if Ndigs <= NFrac then\n-            Set_Blanks_And_Sign (Fore - 1);\n-            Set ('0');\n-            Set ('.');\n-            Set_Zeros (NFrac - Ndigs);\n-            Set_Digs (1, Ndigs);\n-\n-         --  Normal case with some digits before the decimal point\n-\n-         else\n-            Set_Blanks_And_Sign (Fore - (Ndigs - NFrac));\n-            Set_Digs (1, Ndigs - NFrac);\n-            Set ('.');\n-            Set_Digs (Ndigs - NFrac + 1, Ndigs);\n-         end if;\n-\n-      --  Case of non-zero value with non-zero Exp value\n+      --  Otherwise, scale X and convert it to an integer\n \n       else\n-         --  If NFrac is less than Maxdigs, then all the fraction digits are\n-         --  significant, so we can scale the resulting integer accordingly.\n+         --  In exponent notation, we need exactly NFrac + 1 digits and always\n+         --  round the last one.\n \n-         if NFrac < Maxdigs then\n-            Adjust_Scale (NFrac + 1);\n-            Convert_Integer;\n+         if Exp > 0 then\n+            Adjust_Scale (Natural'Min (NFrac + 1, Maxdigs));\n+            X := X + 0.5;\n \n-         --  Otherwise, we get the maximum number of digits available\n+         --  In straight notation, we compute the maximum number of digits and\n+         --  compare how many of them will be put after the decimal point with\n+         --  Nfrac, in order to find out whether we need to round the last one\n+         --  here or whether the rounding is performed by Set_Decimal_Digits.\n \n          else\n             Adjust_Scale (Maxdigs);\n-            Convert_Integer;\n-\n-            for J in 1 .. NFrac - Maxdigs + 1 loop\n-               Ndigs := Ndigs + 1;\n-               pragma Assert (Ndigs <= Digs'Last);\n-               Digs (Ndigs) := '0';\n-               Scale := Scale - 1;\n-            end loop;\n+            if Scale <= NFrac then\n+               X := X + 0.5;\n+            end if;\n          end if;\n \n-         Set_Blanks_And_Sign (Fore - 1);\n-         Set (Digs (1));\n-         Set ('.');\n-         Set_Digs (2, Ndigs);\n-\n-         --  The exponent is the scaling factor adjusted for the digits\n-         --  that we output after the decimal point, since these were\n-         --  included in the scaled digits that we output.\n-\n-         Expon := Scale + NFrac;\n-\n-         Set ('E');\n-         Ndigs := 0;\n+         --  Use Unsigned routine if possible, since on 32-bit machines it will\n+         --  be significantly more efficient than the Long_Long_Unsigned one.\n \n-         if Expon >= 0 then\n-            Set ('+');\n-            Set_Image_Unsigned (Unsigned (Expon), Digs, Ndigs);\n-         else\n-            Set ('-');\n-            Set_Image_Unsigned (Unsigned (-Expon), Digs, Ndigs);\n+         if X <= Long_Long_Float (Unsigned'Last) then\n+            declare\n+               I : constant Unsigned :=\n+                     Unsigned (Long_Long_Float'Truncation (X));\n+            begin\n+               Set_Image_Unsigned (I, Digs, Ndigs);\n+            end;\n+\n+         else pragma Assert (X <= Long_Long_Float (LLU'Last));\n+            declare\n+               I : constant LLU :=\n+                     LLU (Long_Long_Float'Truncation (X));\n+            begin\n+               Set_Image_Long_Long_Unsigned (I, Digs, Ndigs);\n+            end;\n          end if;\n-\n-         Set_Zeros (Exp - Ndigs - 1);\n-         Set_Digs (1, Ndigs);\n       end if;\n \n+      Set_Decimal_Digits (Digs, Ndigs, S, P, Scale, Fore, Aft, Exp);\n    end Set_Image_Real;\n \n end System.Img_Real;"}, {"sha": "2da869bdbeec58a01c2ff95f866e946130af08cb", "filename": "gcc/ada/libgnat/s-imgrea.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c63bb4f3aaa18b5e4c8722c655187d592faecde3/gcc%2Fada%2Flibgnat%2Fs-imgrea.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c63bb4f3aaa18b5e4c8722c655187d592faecde3/gcc%2Fada%2Flibgnat%2Fs-imgrea.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imgrea.ads?ref=c63bb4f3aaa18b5e4c8722c655187d592faecde3", "patch": "@@ -63,7 +63,7 @@ package System.Img_Real is\n \n    procedure Set_Image_Real\n      (V    : Long_Long_Float;\n-      S    : out String;\n+      S    : in out String;\n       P    : in out Natural;\n       Fore : Natural;\n       Aft  : Natural;"}, {"sha": "e86be4923fd34717e021c8f0752f7cfa0e517c4d", "filename": "gcc/ada/libgnat/s-imguti.adb", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c63bb4f3aaa18b5e4c8722c655187d592faecde3/gcc%2Fada%2Flibgnat%2Fs-imguti.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c63bb4f3aaa18b5e4c8722c655187d592faecde3/gcc%2Fada%2Flibgnat%2Fs-imguti.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imguti.adb?ref=c63bb4f3aaa18b5e4c8722c655187d592faecde3", "patch": "@@ -400,4 +400,85 @@ package body System.Img_Util is\n       end if;\n    end Set_Decimal_Digits;\n \n+   --------------------------------\n+   -- Set_Floating_Invalid_Value --\n+   --------------------------------\n+\n+   procedure Set_Floating_Invalid_Value\n+     (V    : Floating_Invalid_Value;\n+      S    : out String;\n+      P    : in out Natural;\n+      Fore : Natural;\n+      Aft  : Natural;\n+      Exp  : Natural)\n+   is\n+      procedure Set (C : Character);\n+      --  Sets character C in output buffer\n+\n+      procedure Set_Special_Fill (N : Natural);\n+      --  After outputting +Inf, -Inf or NaN, this routine fills out the\n+      --  rest of the field with * characters. The argument is the number\n+      --  of characters output so far (either 3 or 4)\n+\n+      ---------\n+      -- Set --\n+      ---------\n+\n+      procedure Set (C : Character) is\n+      begin\n+         pragma Assert (P in S'First - 1 .. S'Last - 1);\n+         --  No check is done as documented in the header: updating P to point\n+         --  to the last character stored, the caller promises that the buffer\n+         --  is large enough and no check is made for this. Constraint_Error\n+         --  will not necessarily be raised if this requirement is violated,\n+         --  since it is perfectly valid to compile this unit with checks off.\n+\n+         P := P + 1;\n+         S (P) := C;\n+      end Set;\n+\n+      ----------------------\n+      -- Set_Special_Fill --\n+      ----------------------\n+\n+      procedure Set_Special_Fill (N : Natural) is\n+      begin\n+         if Exp /= 0 then\n+            for J in N + 1 .. Fore + 1 + Aft + 1 + Exp loop\n+               Set ('*');\n+            end loop;\n+\n+         else\n+            for J in N + 1 .. Fore + 1 + Aft loop\n+               Set ('*');\n+            end loop;\n+         end if;\n+      end Set_Special_Fill;\n+\n+   --  Start of processing for Set_Floating_Invalid_Value\n+\n+   begin\n+      case V is\n+         when Minus_Infinity =>\n+            Set ('-');\n+            Set ('I');\n+            Set ('n');\n+            Set ('f');\n+            Set_Special_Fill (4);\n+\n+         when Infinity =>\n+            Set ('+');\n+            Set ('I');\n+            Set ('n');\n+            Set ('f');\n+            Set_Special_Fill (4);\n+\n+         when Not_A_Number =>\n+            Set ('N');\n+            Set ('a');\n+            Set ('N');\n+            Set_Special_Fill (3);\n+      end case;\n+   end Set_Floating_Invalid_Value;\n+\n end System.Img_Util;"}, {"sha": "680c0bb8eafd13d97983f615f74c433920afea31", "filename": "gcc/ada/libgnat/s-imguti.ads", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c63bb4f3aaa18b5e4c8722c655187d592faecde3/gcc%2Fada%2Flibgnat%2Fs-imguti.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c63bb4f3aaa18b5e4c8722c655187d592faecde3/gcc%2Fada%2Flibgnat%2Fs-imguti.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imguti.ads?ref=c63bb4f3aaa18b5e4c8722c655187d592faecde3", "patch": "@@ -58,4 +58,19 @@ package System.Img_Util is\n    --  may destroy the value in Digs, which is why Digs is in-out (this happens\n    --  if rounding is required).\n \n+   type Floating_Invalid_Value is (Minus_Infinity, Infinity, Not_A_Number);\n+\n+   procedure Set_Floating_Invalid_Value\n+     (V    : Floating_Invalid_Value;\n+      S    : out String;\n+      P    : in out Natural;\n+      Fore : Natural;\n+      Aft  : Natural;\n+      Exp  : Natural);\n+   --  Sets the image of a floating-point invalid value, starting at S (P + 1),\n+   --  updating P to point to the last character stored. The caller promises\n+   --  that the buffer is large enough and therefore no check is made for it.\n+   --  Constraint_Error will not necessarily be raised if the requirement is\n+   --  violated since it is valid to compile this unit with checks off.\n+\n end System.Img_Util;"}, {"sha": "197fd24cfa1ba7a652e3f0b8ea911eec9086a19f", "filename": "gcc/ada/libgnat/s-unstyp.ads", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c63bb4f3aaa18b5e4c8722c655187d592faecde3/gcc%2Fada%2Flibgnat%2Fs-unstyp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c63bb4f3aaa18b5e4c8722c655187d592faecde3/gcc%2Fada%2Flibgnat%2Fs-unstyp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-unstyp.ads?ref=c63bb4f3aaa18b5e4c8722c655187d592faecde3", "patch": "@@ -48,9 +48,6 @@ package System.Unsigned_Types is\n    type Long_Long_Unsigned      is mod 2 ** Long_Long_Integer'Size;\n    type Long_Long_Long_Unsigned is mod Max_Binary_Modulus;\n \n-   type Float_Unsigned          is mod 2 ** Float'Size;\n-   --  Used in the implementation of Is_Negative intrinsic (see Exp_Intr)\n-\n    type Packed_Byte is mod 2 ** 8;\n    for Packed_Byte'Size use 8;\n    pragma Universal_Aliasing (Packed_Byte);"}, {"sha": "3bc36a148a9e8bb164c8a4ad67959c1b7861ab68", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c63bb4f3aaa18b5e4c8722c655187d592faecde3/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c63bb4f3aaa18b5e4c8722c655187d592faecde3/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=c63bb4f3aaa18b5e4c8722c655187d592faecde3", "patch": "@@ -2004,7 +2004,6 @@ package Rtsfind is\n      RE_Bits_1,                          -- System.Unsigned_Types\n      RE_Bits_2,                          -- System.Unsigned_Types\n      RE_Bits_4,                          -- System.Unsigned_Types\n-     RE_Float_Unsigned,                  -- System.Unsigned_Types\n      RE_Long_Long_Unsigned,              -- System.Unsigned_Types\n      RE_Long_Long_Long_Unsigned,         -- System.Unsigned_Types\n      RE_Packed_Byte,                     -- System.Unsigned_Types\n@@ -3684,7 +3683,6 @@ package Rtsfind is\n      RE_Bits_1                           => System_Unsigned_Types,\n      RE_Bits_2                           => System_Unsigned_Types,\n      RE_Bits_4                           => System_Unsigned_Types,\n-     RE_Float_Unsigned                   => System_Unsigned_Types,\n      RE_Long_Long_Unsigned               => System_Unsigned_Types,\n      RE_Long_Long_Long_Unsigned          => System_Unsigned_Types,\n      RE_Packed_Byte                      => System_Unsigned_Types,"}, {"sha": "206e915d39579ed1c7582df6cc14c126742620f8", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c63bb4f3aaa18b5e4c8722c655187d592faecde3/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c63bb4f3aaa18b5e4c8722c655187d592faecde3/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=c63bb4f3aaa18b5e4c8722c655187d592faecde3", "patch": "@@ -1333,7 +1333,6 @@ package Snames is\n    Name_Import_Address                   : constant Name_Id := N + $;\n    Name_Import_Largest_Value             : constant Name_Id := N + $;\n    Name_Import_Value                     : constant Name_Id := N + $;\n-   Name_Is_Negative                      : constant Name_Id := N + $;\n    Name_Line                             : constant Name_Id := N + $;\n    Name_Rotate_Left                      : constant Name_Id := N + $;\n    Name_Rotate_Right                     : constant Name_Id := N + $;"}]}