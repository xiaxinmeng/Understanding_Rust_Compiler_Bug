{"sha": "2f4d95024276fc29c16422589c62cd6df14a3cd3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmY0ZDk1MDI0Mjc2ZmMyOWMxNjQyMjU4OWM2MmNkNmRmMTRhM2NkMw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2004-11-11T08:49:17Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-11-11T08:49:17Z"}, "message": "re PR rtl-optimization/16796 (PowerPC - Unnecessary Floating Point Register Copy)\n\n.:\tPR target/16796\n\t* config/rs6000/rs6000.md: Add DF & SF reg move peepholes.\ntestsuite:\n\tPR target/16796\n\t* gcc.dg/ppc-mov-1.c: New.\n\nFrom-SVN: r90476", "tree": {"sha": "b7aeb61add815399b18aef70a3f499e685fabcc0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b7aeb61add815399b18aef70a3f499e685fabcc0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f4d95024276fc29c16422589c62cd6df14a3cd3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f4d95024276fc29c16422589c62cd6df14a3cd3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f4d95024276fc29c16422589c62cd6df14a3cd3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f4d95024276fc29c16422589c62cd6df14a3cd3/comments", "author": null, "committer": null, "parents": [{"sha": "60934f9cf4eec9feef395961c9dda139fa325845", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60934f9cf4eec9feef395961c9dda139fa325845", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60934f9cf4eec9feef395961c9dda139fa325845"}], "stats": {"total": 81, "additions": 81, "deletions": 0}, "files": [{"sha": "3f4b7a361ea2fb96645f973623aaf73923d504ae", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f4d95024276fc29c16422589c62cd6df14a3cd3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f4d95024276fc29c16422589c62cd6df14a3cd3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2f4d95024276fc29c16422589c62cd6df14a3cd3", "patch": "@@ -1,5 +1,8 @@\n 2004-11-11  Nathan Sidwell  <nathan@codesourcery.com>\n \n+\tPR target/16796\n+\t* config/rs6000/rs6000.md: Add DF & SF reg move peepholes.\n+\n \tPR target/16458\n \t* config/rs6000/rs6000.c (rs6000_generate_compare): Generate an\n \tunsigned equality compare when we know the operands are unsigned."}, {"sha": "6b1c0b656ccf7b91b13093fdb3aa6f84c96ef6ed", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f4d95024276fc29c16422589c62cd6df14a3cd3/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f4d95024276fc29c16422589c62cd6df14a3cd3/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=2f4d95024276fc29c16422589c62cd6df14a3cd3", "patch": "@@ -9716,6 +9716,29 @@\n \t(match_dup 1))]\n   \"operands[0] = widen_memory_access (operands[0], TFmode, 0);\n    operands[1] = gen_rtx_REG (TFmode, REGNO (operands[1]));\")\n+\n+;; after inserting conditional returns we can sometimes have\n+;; unnecessary register moves.  Unfortunately we cannot have a\n+;; modeless peephole here, because some single SImode sets have early\n+;; clobber outputs.  Although those sets expand to multi-ppc-insn\n+;; sequences, using get_attr_length here will smash the operands\n+;; array.  Neither is there an early_cobbler_p predicate.\n+(define_peephole2\n+  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n+\t(match_operand:DF 1 \"any_operand\" \"\"))\n+   (set (match_operand:DF 2 \"gpc_reg_operand\" \"\")\n+\t(match_dup 0))]\n+  \"peep2_reg_dead_p (2, operands[0])\"\n+  [(set (match_dup 2) (match_dup 1))])\n+\n+(define_peephole2\n+  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n+\t(match_operand:SF 1 \"any_operand\" \"\"))\n+   (set (match_operand:SF 2 \"gpc_reg_operand\" \"\")\n+\t(match_dup 0))]\n+  \"peep2_reg_dead_p (2, operands[0])\"\n+  [(set (match_dup 2) (match_dup 1))])\n+\n \f\n ;; TLS support.\n "}, {"sha": "64da733025fb6ad5bed2888c50bdd72314eec342", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f4d95024276fc29c16422589c62cd6df14a3cd3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f4d95024276fc29c16422589c62cd6df14a3cd3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2f4d95024276fc29c16422589c62cd6df14a3cd3", "patch": "@@ -1,5 +1,8 @@\n 2004-11-11  Nathan Sidwell  <nathan@codesourcery.com>\n \n+\tPR target/16796\n+\t* gcc.dg/ppc-mov-1.c: New.\n+\n \tPR target/16458\n \t* gcc.dg/ppc-compare-1.c: New.\n "}, {"sha": "4256b60ca0ebce09b354d00508d45d8d453a7197", "filename": "gcc/testsuite/gcc.dg/ppc-mov-1.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f4d95024276fc29c16422589c62cd6df14a3cd3/gcc%2Ftestsuite%2Fgcc.dg%2Fppc-mov-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f4d95024276fc29c16422589c62cd6df14a3cd3/gcc%2Ftestsuite%2Fgcc.dg%2Fppc-mov-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fppc-mov-1.c?ref=2f4d95024276fc29c16422589c62cd6df14a3cd3", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-do compile { target powerpc64-*-* } } */\n+/* { dg-options \"-m64 -O2\" } */\n+\n+/* { dg-final { scan-assembler-not \"fmr \\[0-9\\]+,\\[0-9\\]+\" } }\n+\n+/* Origin:Pete Steinmetz <steinmtz@us.ibm.com> */\n+\n+/* PR 16796: Extraneous move.  */\n+\n+static const double huge = 1.0e300;\n+typedef int int64_t __attribute__ ((__mode__ (__DI__)));\n+typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));\n+\n+double __floor(double x)\n+{\n+  union {\n+    double dbl_val;\n+    long int long_val;\n+  } temp;\n+\n+  int64_t i0,j0;\n+  u_int64_t i;\n+  temp.dbl_val = x;\n+  i0 = temp.long_val;\n+\n+  j0 = ((i0>>52)&0x7ff)-0x3ff;\n+  if(j0<52) {\n+    if(j0<0) {\n+      if(huge+x>0.0) {\n+        if(i0>=0) {i0=0;}\n+        else if((i0&0x7fffffffffffffff)!=0)\n+        { i0=0xbff0000000000000;}\n+      }\n+    } else {\n+      i = (0x000fffffffffffff)>>j0;\n+      if((i0&i)==0) return x;\n+      if(huge+x>0.0) {\n+        if(i0<0) i0 += (0x0010000000000000)>>j0;\n+        i0 &= (~i);\n+      }\n+    }\n+  } else {\n+    if (j0==0x400)\n+      return x+x;\n+    else\n+      return x;\n+  }\n+  temp.long_val = i0;\n+  x = temp.dbl_val;\n+  return x;\n+}\n+"}]}