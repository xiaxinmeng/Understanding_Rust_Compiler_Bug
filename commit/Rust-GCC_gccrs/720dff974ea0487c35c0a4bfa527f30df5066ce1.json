{"sha": "720dff974ea0487c35c0a4bfa527f30df5066ce1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzIwZGZmOTc0ZWEwNDg3YzM1YzBhNGJmYTUyN2YzMGRmNTA2NmNlMQ==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel@linux.ibm.com", "date": "2021-04-27T08:09:06Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@linux.ibm.com", "date": "2021-05-18T06:45:09Z"}, "message": "PR100281 C++: Fix SImode pointer handling\n\nThe problem appears to be triggered by two locations in the front-end\nwhere non-POINTER_SIZE pointers aren't handled right now.\n\n1. An assertion in strip_typedefs is triggered because the alignment\nof the types don't match. This in turn is caused by creating the new\ntype with build_pointer_type instead of taking the type of the\noriginal pointer into account.\n\n2. An assertion in cp_convert_to_pointer is triggered which expects\nthe target type to always have POINTER_SIZE.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/100281\n\t* cvt.c (cp_convert_to_pointer): Use the size of the target\n\tpointer type.\n\t* tree.c (cp_build_reference_type): Call\n\tcp_build_reference_type_for_mode with VOIDmode.\n\t(cp_build_reference_type_for_mode): Rename from\n\tcp_build_reference_type.  Add MODE argument and invoke\n\tbuild_reference_type_for_mode.\n\t(strip_typedefs): Use build_pointer_type_for_mode and\n\tcp_build_reference_type_for_mode for pointers and references.\n\ngcc/ChangeLog:\n\n\tPR c++/100281\n\t* tree.c (build_reference_type_for_mode)\n\t(build_pointer_type_for_mode): Pick pointer mode if MODE argument\n\tis VOIDmode.\n\t(build_reference_type, build_pointer_type): Invoke\n\tbuild_*_type_for_mode with VOIDmode.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/100281\n\t* g++.target/s390/pr100281-1.C: New test.\n\t* g++.target/s390/pr100281-2.C: New test.", "tree": {"sha": "6e1d3a36cc316a3e0b24f651fa8903f570da7bde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e1d3a36cc316a3e0b24f651fa8903f570da7bde"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/720dff974ea0487c35c0a4bfa527f30df5066ce1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/720dff974ea0487c35c0a4bfa527f30df5066ce1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/720dff974ea0487c35c0a4bfa527f30df5066ce1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/720dff974ea0487c35c0a4bfa527f30df5066ce1/comments", "author": {"login": "Andreas-Krebbel", "id": 38103320, "node_id": "MDQ6VXNlcjM4MTAzMzIw", "avatar_url": "https://avatars.githubusercontent.com/u/38103320?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Andreas-Krebbel", "html_url": "https://github.com/Andreas-Krebbel", "followers_url": "https://api.github.com/users/Andreas-Krebbel/followers", "following_url": "https://api.github.com/users/Andreas-Krebbel/following{/other_user}", "gists_url": "https://api.github.com/users/Andreas-Krebbel/gists{/gist_id}", "starred_url": "https://api.github.com/users/Andreas-Krebbel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Andreas-Krebbel/subscriptions", "organizations_url": "https://api.github.com/users/Andreas-Krebbel/orgs", "repos_url": "https://api.github.com/users/Andreas-Krebbel/repos", "events_url": "https://api.github.com/users/Andreas-Krebbel/events{/privacy}", "received_events_url": "https://api.github.com/users/Andreas-Krebbel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Andreas-Krebbel", "id": 38103320, "node_id": "MDQ6VXNlcjM4MTAzMzIw", "avatar_url": "https://avatars.githubusercontent.com/u/38103320?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Andreas-Krebbel", "html_url": "https://github.com/Andreas-Krebbel", "followers_url": "https://api.github.com/users/Andreas-Krebbel/followers", "following_url": "https://api.github.com/users/Andreas-Krebbel/following{/other_user}", "gists_url": "https://api.github.com/users/Andreas-Krebbel/gists{/gist_id}", "starred_url": "https://api.github.com/users/Andreas-Krebbel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Andreas-Krebbel/subscriptions", "organizations_url": "https://api.github.com/users/Andreas-Krebbel/orgs", "repos_url": "https://api.github.com/users/Andreas-Krebbel/repos", "events_url": "https://api.github.com/users/Andreas-Krebbel/events{/privacy}", "received_events_url": "https://api.github.com/users/Andreas-Krebbel/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe993b469c528230d9a01e1ae2208610f960dd9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe993b469c528230d9a01e1ae2208610f960dd9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe993b469c528230d9a01e1ae2208610f960dd9f"}], "stats": {"total": 75, "additions": 57, "deletions": 18}, "files": [{"sha": "7fa6e8df52b55590539731cbc5415a3776b058e9", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/720dff974ea0487c35c0a4bfa527f30df5066ce1/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/720dff974ea0487c35c0a4bfa527f30df5066ce1/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=720dff974ea0487c35c0a4bfa527f30df5066ce1", "patch": "@@ -232,7 +232,7 @@ cp_convert_to_pointer (tree type, tree expr, bool dofold,\n     {\n       if (TYPE_PRECISION (intype) == POINTER_SIZE)\n \treturn build1 (CONVERT_EXPR, type, expr);\n-      expr = cp_convert (c_common_type_for_size (POINTER_SIZE, 0), expr,\n+      expr = cp_convert (c_common_type_for_size (TYPE_PRECISION (type), 0), expr,\n \t\t\t complain);\n       /* Modes may be different but sizes should be the same.  There\n \t is supposed to be some integral type that is the same width"}, {"sha": "35faeff065ae9aae802f0cef2175ad8652988495", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/720dff974ea0487c35c0a4bfa527f30df5066ce1/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/720dff974ea0487c35c0a4bfa527f30df5066ce1/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=720dff974ea0487c35c0a4bfa527f30df5066ce1", "patch": "@@ -1206,12 +1206,14 @@ vla_type_p (tree t)\n   return false;\n }\n \n-/* Return a reference type node referring to TO_TYPE.  If RVAL is\n+\n+/* Return a reference type node of MODE referring to TO_TYPE.  If MODE\n+   is VOIDmode the standard pointer mode will be picked.  If RVAL is\n    true, return an rvalue reference type, otherwise return an lvalue\n    reference type.  If a type node exists, reuse it, otherwise create\n    a new one.  */\n tree\n-cp_build_reference_type (tree to_type, bool rval)\n+cp_build_reference_type_for_mode (tree to_type, machine_mode mode, bool rval)\n {\n   tree lvalue_ref, t;\n \n@@ -1224,7 +1226,8 @@ cp_build_reference_type (tree to_type, bool rval)\n       to_type = TREE_TYPE (to_type);\n     }\n \n-  lvalue_ref = build_reference_type (to_type);\n+  lvalue_ref = build_reference_type_for_mode (to_type, mode, false);\n+\n   if (!rval)\n     return lvalue_ref;\n \n@@ -1250,7 +1253,7 @@ cp_build_reference_type (tree to_type, bool rval)\n     SET_TYPE_STRUCTURAL_EQUALITY (t);\n   else if (TYPE_CANONICAL (to_type) != to_type)\n     TYPE_CANONICAL (t) \n-      = cp_build_reference_type (TYPE_CANONICAL (to_type), rval);\n+      = cp_build_reference_type_for_mode (TYPE_CANONICAL (to_type), mode, rval);\n   else\n     TYPE_CANONICAL (t) = t;\n \n@@ -1260,6 +1263,16 @@ cp_build_reference_type (tree to_type, bool rval)\n \n }\n \n+/* Return a reference type node referring to TO_TYPE.  If RVAL is\n+   true, return an rvalue reference type, otherwise return an lvalue\n+   reference type.  If a type node exists, reuse it, otherwise create\n+   a new one.  */\n+tree\n+cp_build_reference_type (tree to_type, bool rval)\n+{\n+  return cp_build_reference_type_for_mode (to_type, VOIDmode, rval);\n+}\n+\n /* Returns EXPR cast to rvalue reference type, like std::move.  */\n \n tree\n@@ -1561,11 +1574,11 @@ strip_typedefs (tree t, bool *remove_attributes, unsigned int flags)\n     {\n     case POINTER_TYPE:\n       type = strip_typedefs (TREE_TYPE (t), remove_attributes, flags);\n-      result = build_pointer_type (type);\n+      result = build_pointer_type_for_mode (type, TYPE_MODE (t), false);\n       break;\n     case REFERENCE_TYPE:\n       type = strip_typedefs (TREE_TYPE (t), remove_attributes, flags);\n-      result = cp_build_reference_type (type, TYPE_REF_IS_RVALUE (t));\n+      result = cp_build_reference_type_for_mode (type, TYPE_MODE (t), TYPE_REF_IS_RVALUE (t));\n       break;\n     case OFFSET_TYPE:\n       t0 = strip_typedefs (TYPE_OFFSET_BASETYPE (t), remove_attributes, flags);"}, {"sha": "b82e27b64e93f80b00887ba3f9380263f818c8eb", "filename": "gcc/testsuite/g++.target/s390/pr100281-1.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/720dff974ea0487c35c0a4bfa527f30df5066ce1/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fs390%2Fpr100281-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/720dff974ea0487c35c0a4bfa527f30df5066ce1/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fs390%2Fpr100281-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fs390%2Fpr100281-1.C?ref=720dff974ea0487c35c0a4bfa527f30df5066ce1", "patch": "@@ -0,0 +1,10 @@\n+// PR C++/100281\n+// { dg-do compile }\n+\n+typedef void * __attribute__((mode (SI))) __ptr32_t;\n+\n+void foo () {\n+  unsigned int b = 100;\n+  __ptr32_t a;\n+  a = b; /* { dg-error \"invalid conversion from 'unsigned int' to '__ptr32_t'.*\" } */\n+}"}, {"sha": "58552becd7ceb14ee3b43c5d05110af376e5633c", "filename": "gcc/testsuite/g++.target/s390/pr100281-2.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/720dff974ea0487c35c0a4bfa527f30df5066ce1/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fs390%2Fpr100281-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/720dff974ea0487c35c0a4bfa527f30df5066ce1/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fs390%2Fpr100281-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fs390%2Fpr100281-2.C?ref=720dff974ea0487c35c0a4bfa527f30df5066ce1", "patch": "@@ -0,0 +1,9 @@\n+// PR C++/100281\n+// { dg-do compile }\n+\n+typedef int & __attribute__((mode (SI))) __ref32_t;\n+\n+void foo () {\n+  unsigned int b = 100;\n+  __ref32_t a = b; /* { dg-error \"cannot bind non-const lvalue reference of type '__ref32_t'.*\" } */\n+}"}, {"sha": "31ac4245c9c8256fa9096d54eae7ea9b22ded176", "filename": "gcc/tree.c", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/720dff974ea0487c35c0a4bfa527f30df5066ce1/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/720dff974ea0487c35c0a4bfa527f30df5066ce1/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=720dff974ea0487c35c0a4bfa527f30df5066ce1", "patch": "@@ -6792,9 +6792,10 @@ operation_no_trapping_overflow (tree type, enum tree_code code)\n    constructed by language-dependent code, not here.)  */\n \n /* Construct, lay out and return the type of pointers to TO_TYPE with\n-   mode MODE.  If CAN_ALIAS_ALL is TRUE, indicate this type can\n-   reference all of memory. If such a type has already been\n-   constructed, reuse it.  */\n+   mode MODE.  If MODE is VOIDmode, a pointer mode for the address\n+   space of TO_TYPE will be picked.  If CAN_ALIAS_ALL is TRUE,\n+   indicate this type can reference all of memory. If such a type has\n+   already been constructed, reuse it.  */\n \n tree\n build_pointer_type_for_mode (tree to_type, machine_mode mode,\n@@ -6806,6 +6807,12 @@ build_pointer_type_for_mode (tree to_type, machine_mode mode,\n   if (to_type == error_mark_node)\n     return error_mark_node;\n \n+  if (mode == VOIDmode)\n+    {\n+      addr_space_t as = TYPE_ADDR_SPACE (to_type);\n+      mode = targetm.addr_space.pointer_mode (as);\n+    }\n+\n   /* If the pointed-to type has the may_alias attribute set, force\n      a TYPE_REF_CAN_ALIAS_ALL pointer to be generated.  */\n   if (lookup_attribute (\"may_alias\", TYPE_ATTRIBUTES (to_type)))\n@@ -6857,10 +6864,7 @@ build_pointer_type_for_mode (tree to_type, machine_mode mode,\n tree\n build_pointer_type (tree to_type)\n {\n-  addr_space_t as = to_type == error_mark_node? ADDR_SPACE_GENERIC\n-\t\t\t\t\t      : TYPE_ADDR_SPACE (to_type);\n-  machine_mode pointer_mode = targetm.addr_space.pointer_mode (as);\n-  return build_pointer_type_for_mode (to_type, pointer_mode, false);\n+  return build_pointer_type_for_mode (to_type, VOIDmode, false);\n }\n \n /* Same as build_pointer_type_for_mode, but for REFERENCE_TYPE.  */\n@@ -6875,6 +6879,12 @@ build_reference_type_for_mode (tree to_type, machine_mode mode,\n   if (to_type == error_mark_node)\n     return error_mark_node;\n \n+  if (mode == VOIDmode)\n+    {\n+      addr_space_t as = TYPE_ADDR_SPACE (to_type);\n+      mode = targetm.addr_space.pointer_mode (as);\n+    }\n+\n   /* If the pointed-to type has the may_alias attribute set, force\n      a TYPE_REF_CAN_ALIAS_ALL pointer to be generated.  */\n   if (lookup_attribute (\"may_alias\", TYPE_ATTRIBUTES (to_type)))\n@@ -6926,10 +6936,7 @@ build_reference_type_for_mode (tree to_type, machine_mode mode,\n tree\n build_reference_type (tree to_type)\n {\n-  addr_space_t as = to_type == error_mark_node? ADDR_SPACE_GENERIC\n-\t\t\t\t\t      : TYPE_ADDR_SPACE (to_type);\n-  machine_mode pointer_mode = targetm.addr_space.pointer_mode (as);\n-  return build_reference_type_for_mode (to_type, pointer_mode, false);\n+  return build_reference_type_for_mode (to_type, VOIDmode, false);\n }\n \n #define MAX_INT_CACHED_PREC \\"}]}