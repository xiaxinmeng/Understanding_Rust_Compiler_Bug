{"sha": "3cc1cccc6da7a590bc469bdba47c5f7ec45def4d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2NjMWNjY2M2ZGE3YTU5MGJjNDY5YmRiYTQ3YzVmN2VjNDVkZWY0ZA==", "commit": {"author": {"name": "Razya Ladelsky", "email": "razya@gcc.gnu.org", "date": "2007-01-28T13:01:53Z"}, "committer": {"name": "Razya Ladelsky", "email": "razya@gcc.gnu.org", "date": "2007-01-28T13:01:53Z"}, "message": "ipa-cp.c (ipcp_insert_stage, [...]): Support for SSA.\n\n2007-01-25  Razya Ladelsky  <razya@il.ibm.com>\n\n        * ipa-cp.c (ipcp_insert_stage, ipcp_driver): Support for SSA.\n        (ipcp_driver): Change to static definition.\n        Add dumping of the ifunctions.\n        (constant_val_insert): Remove unused parameter. Support for SSA.\n        (ipcp_propagate_const): Support for SSA.\n        (ipcp_profile_bb_print): Print only analyzed nodes.\n        (ipcp_replace_map_create): Remove support for Fortran constant\n        for now.\n        * ipa-prop.c (ipa_method_modify_stmt,\n        ipa_callsite_compute_param): Support for SSA.\n        * ipa-prop.h (ipcp_driver): Remove declaration.\n        (IS_VALID_TREE_MAP_INDEX): Add define.\n\nFrom-SVN: r121256", "tree": {"sha": "c73db10bbc05de607bbac8c68ffe25e8add6c151", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c73db10bbc05de607bbac8c68ffe25e8add6c151"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3cc1cccc6da7a590bc469bdba47c5f7ec45def4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cc1cccc6da7a590bc469bdba47c5f7ec45def4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cc1cccc6da7a590bc469bdba47c5f7ec45def4d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cc1cccc6da7a590bc469bdba47c5f7ec45def4d/comments", "author": null, "committer": null, "parents": [{"sha": "34462c28dffca29f115fb3bef4364eaff5a3ec43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34462c28dffca29f115fb3bef4364eaff5a3ec43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34462c28dffca29f115fb3bef4364eaff5a3ec43"}], "stats": {"total": 171, "additions": 102, "deletions": 69}, "files": [{"sha": "1bde78373faa73c407b37da58d56f7fb89b3df10", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cc1cccc6da7a590bc469bdba47c5f7ec45def4d/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cc1cccc6da7a590bc469bdba47c5f7ec45def4d/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=3cc1cccc6da7a590bc469bdba47c5f7ec45def4d", "patch": "@@ -2434,7 +2434,7 @@ ipa-prop.o : ipa-prop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h  \\\n    langhooks.h $(GGC_H) $(TARGET_H) $(CGRAPH_H) ipa-prop.h \\\n    $(TREE_FLOW_H) $(TM_H) tree-pass.h $(FLAGS_H) $(TREE_H)\n ipa-cp.o : ipa-cp.c $(CONFIG_H) $(SYSTEM_H) coretypes.h  \\\n-   langhooks.h $(TARGET_H) $(CGRAPH_H) ipa-prop.h  \\\n+   langhooks.h $(TARGET_H) $(CGRAPH_H) ipa-prop.h tree-inline.h tree-dump.h \\\n    $(TREE_FLOW_H) $(TM_H) tree-pass.h $(FLAGS_H) $(TREE_H) $(DIAGNOSTIC_H)\n ipa-inline.o : ipa-inline.c gt-ipa-inline.h $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) langhooks.h $(TREE_INLINE_H) $(FLAGS_H) $(CGRAPH_H) intl.h \\"}, {"sha": "f2e97732320762271ba7634dd9243d0a80b18684", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 66, "deletions": 58, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cc1cccc6da7a590bc469bdba47c5f7ec45def4d/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cc1cccc6da7a590bc469bdba47c5f7ec45def4d/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=3cc1cccc6da7a590bc469bdba47c5f7ec45def4d", "patch": "@@ -143,6 +143,8 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"flags.h\"\n #include \"timevar.h\"\n #include \"diagnostic.h\"\n+#include \"tree-dump.h\"\n+#include \"tree-inline.h\"\n \n /* Get orig node field of ipa_node associated with method MT.  */\n static inline struct cgraph_node *\n@@ -219,7 +221,7 @@ ipcp_cval_set_cvalue (struct ipcp_formal *cval, union parameter_info *value,\n \t\t      enum cvalue_type type)\n {\n   if (type == CONST_VALUE || type == CONST_VALUE_REF)\n-    cval->cvalue.value =  value->value;\n+    cval->cvalue.value = value->value;\n }\n \n /* Return whether TYPE is a constant type.  */\n@@ -336,7 +338,7 @@ ipcp_cval_changed (struct ipcp_formal *cval1, struct ipcp_formal *cval2)\n   if (ipcp_cval_get_cvalue_type (cval1) == ipcp_cval_get_cvalue_type (cval2))\n     {\n       if (ipcp_cval_get_cvalue_type (cval1) != CONST_VALUE &&\n-\t  ipcp_cval_get_cvalue_type (cval1) != CONST_VALUE_REF)\t \n+\t  ipcp_cval_get_cvalue_type (cval1) != CONST_VALUE_REF)\n \treturn false;\n       if (ipcp_cval_equal_cvalues (ipcp_cval_get_cvalue (cval1),\n \t\t\t\t   ipcp_cval_get_cvalue (cval2),\n@@ -379,7 +381,7 @@ ipcp_method_cval_print (FILE * f)\n   struct cgraph_node *node;\n   int i, count;\n   tree cvalue;\n- \n+\n   fprintf (f, \"\\nCVAL PRINT\\n\");\n   for (node = cgraph_nodes; node; node = node->next)\n     {\n@@ -395,10 +397,9 @@ ipcp_method_cval_print (FILE * f)\n \t      fprintf (f, \" param [%d]: \", i);\n \t      fprintf (f, \"type is CONST \");\n \t      cvalue =\n-\t\tipcp_cval_get_cvalue (ipcp_method_cval (node, i))->\n-\t\t  value;\n-              print_generic_expr (f, cvalue, 0);\n-              fprintf (f, \"\\n\");\n+\t\tipcp_cval_get_cvalue (ipcp_method_cval (node, i))->value;\n+\t      print_generic_expr (f, cvalue, 0);\n+\t      fprintf (f, \"\\n\");\n \t    }\n \t  else if (ipcp_method_cval (node, i)->cval_type == TOP)\n \t    fprintf (f, \"param [%d]: type is TOP  \\n\", i);\n@@ -424,8 +425,8 @@ ipcp_method_cval_init (struct cgraph_node *mt)\n   for (i = 0; i < ipa_method_formal_count (mt); i++)\n     {\n       parm_tree = ipa_method_get_tree (mt, i);\n-      if (INTEGRAL_TYPE_P (TREE_TYPE (parm_tree)) \n-\t  || SCALAR_FLOAT_TYPE_P (TREE_TYPE (parm_tree)) \n+      if (INTEGRAL_TYPE_P (TREE_TYPE (parm_tree))\n+\t  || SCALAR_FLOAT_TYPE_P (TREE_TYPE (parm_tree))\n \t  || POINTER_TYPE_P (TREE_TYPE (parm_tree)))\n \tipcp_method_cval_set_cvalue_type (mt, i, TOP);\n       else\n@@ -439,22 +440,18 @@ ipcp_method_cval_init (struct cgraph_node *mt)\n    PARM1 is the lhs of the assignment and\n    VAL is the rhs. */\n static void\n-constant_val_insert (tree fn, tree parm1, tree val)\n+constant_val_insert (tree parm1, tree val)\n {\n-  struct function *func;\n-  tree init_stmt;\n+  tree init_stmt = NULL;\n   edge e_step;\n-  edge_iterator ei;\n \n   init_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, parm1, val);\n-  func = DECL_STRUCT_FUNCTION (fn);\n-  cfun = func;\n-  current_function_decl = fn;\n-  if (ENTRY_BLOCK_PTR_FOR_FUNCTION (func)->succs)\n-    FOR_EACH_EDGE (e_step, ei, ENTRY_BLOCK_PTR_FOR_FUNCTION (func)->succs)\n+\n+  if (init_stmt)\n+    {\n+      e_step = single_succ_edge (ENTRY_BLOCK_PTR_FOR_FUNCTION (cfun));\n       bsi_insert_on_edge_immediate (e_step, init_stmt);\n-  current_function_decl = NULL;\n-  cfun = NULL;\n+    }\n }\n \n /* build INTEGER_CST tree with type TREE_TYPE and \n@@ -474,18 +471,16 @@ build_const_val (union parameter_info *cvalue, enum cvalue_type type,\n    constant_val_insert().  */\n static void\n ipcp_propagate_const (struct cgraph_node *mt, int param,\n-\t\t      union parameter_info *cvalue ,enum cvalue_type type)\n+\t\t      union parameter_info *cvalue, enum cvalue_type type)\n {\n-  tree fndecl;\n   tree const_val;\n   tree parm_tree;\n \n   if (dump_file)\n     fprintf (dump_file, \"propagating const to %s\\n\", cgraph_node_name (mt));\n-  fndecl = mt->decl;\n   parm_tree = ipa_method_get_tree (mt, param);\n   const_val = build_const_val (cvalue, type, TREE_TYPE (parm_tree));\n-  constant_val_insert (fndecl, parm_tree, const_val);\n+  constant_val_insert (parm_tree, const_val);\n }\n \n /* Compute the proper scale for NODE.  It is the ratio between \n@@ -644,7 +639,7 @@ ipcp_callsite_param_print (FILE * f)\n   struct ipa_jump_func *jump_func;\n   enum jump_func_type type;\n   tree info_type;\n- \n+\n   fprintf (f, \"\\nCALLSITE PARAM PRINT\\n\");\n   for (node = cgraph_nodes; node; node = node->next)\n     {\n@@ -663,11 +658,10 @@ ipcp_callsite_param_print (FILE * f)\n \t\tfprintf (f, \"UNKNOWN\\n\");\n \t      else if (type == CONST_IPATYPE || type == CONST_IPATYPE_REF)\n \t\t{\n-\t\t  info_type =\n-\t\t    ipa_jf_get_info_type (jump_func)->value;\n-                  fprintf (f, \"CONST : \");\n-                  print_generic_expr (f, info_type, 0);\n-                  fprintf (f, \"\\n\");\n+\t\t  info_type = ipa_jf_get_info_type (jump_func)->value;\n+\t\t  fprintf (f, \"CONST : \");\n+\t\t  print_generic_expr (f, info_type, 0);\n+\t\t  fprintf (f, \"\\n\");\n \t\t}\n \t      else if (type == FORMAL_IPATYPE)\n \t\t{\n@@ -792,7 +786,7 @@ ipcp_profile_bb_print (FILE * f)\n   for (node = cgraph_nodes; node; node = node->next)\n     {\n       fprintf (f, \"method %s: \\n\", cgraph_node_name (node));\n-      if (DECL_SAVED_TREE (node->decl))\n+      if (node->analyzed)\n \t{\n \t  bb =\n \t    ENTRY_BLOCK_PTR_FOR_FUNCTION (DECL_STRUCT_FUNCTION (node->decl));\n@@ -849,27 +843,22 @@ ipcp_profile_print (FILE * f)\n    operates according to the flags sent.  PARM_TREE is the \n    formal's tree found to be constant.  CVALUE represents the constant.  */\n static struct ipa_replace_map *\n-ipcp_replace_map_create (enum cvalue_type type, tree parm_tree,\n-\t\t\t union parameter_info *cvalue)\n+ipcp_replace_map_create (struct function *func, enum cvalue_type type,\n+\t\t\t tree parm_tree, union parameter_info *cvalue)\n {\n   struct ipa_replace_map *replace_map;\n   tree const_val;\n \n   replace_map = XCNEW (struct ipa_replace_map);\n   gcc_assert (ipcp_type_is_const (type));\n-  if (type == CONST_VALUE_REF )\n-    {\n-      const_val =\n-\tbuild_const_val (cvalue, type, TREE_TYPE (TREE_TYPE (parm_tree)));\n-      replace_map->old_tree = parm_tree;\n-      replace_map->new_tree = const_val;\n-      replace_map->replace_p = true;\n-      replace_map->ref_p = true;\n-    }\n-  else if (TREE_READONLY (parm_tree) && !TREE_ADDRESSABLE (parm_tree))\n+  if (type != CONST_VALUE_REF\n+      && is_gimple_reg (parm_tree) && gimple_default_def (func, parm_tree)\n+\t&& !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (gimple_default_def (func, parm_tree)))\n     {\n+      if (dump_file)\n+\tfprintf (dump_file, \"replacing param with const\\n\");\n       const_val = build_const_val (cvalue, type, TREE_TYPE (parm_tree));\n-      replace_map->old_tree = parm_tree;\n+      replace_map->old_tree =gimple_default_def (func, parm_tree);\n       replace_map->new_tree = const_val;\n       replace_map->replace_p = true;\n       replace_map->ref_p = false;\n@@ -908,8 +897,7 @@ ipcp_redirect (struct cgraph_edge *cs)\n \t{\n \t  jump_func = ipa_callsite_param (cs, i);\n \t  type = get_type (jump_func);\n-\t  if (type != CONST_IPATYPE \n-\t      && type != CONST_IPATYPE_REF)\n+\t  if (type != CONST_IPATYPE && type != CONST_IPATYPE_REF)\n \t    return true;\n \t}\n     }\n@@ -1007,7 +995,7 @@ ipcp_insert_stage (void)\n   struct cgraph_node *node, *node1 = NULL;\n   int i, const_param;\n   union parameter_info *cvalue;\n-  VEC(cgraph_edge_p,heap) *redirect_callers;\n+  VEC (cgraph_edge_p, heap) * redirect_callers;\n   varray_type replace_trees;\n   struct cgraph_edge *cs;\n   int node_callers, count;\n@@ -1019,7 +1007,7 @@ ipcp_insert_stage (void)\n     {\n       /* Propagation of the constant is forbidden in \n          certain conditions.  */\n-      if (ipcp_method_dont_insert_const (node))\n+      if (!node->analyzed || ipcp_method_dont_insert_const (node))\n \tcontinue;\n       const_param = 0;\n       count = ipa_method_formal_count (node);\n@@ -1040,7 +1028,8 @@ ipcp_insert_stage (void)\n \t      cvalue = ipcp_cval_get_cvalue (ipcp_method_cval (node, i));\n \t      parm_tree = ipa_method_get_tree (node, i);\n \t      replace_param =\n-\t\tipcp_replace_map_create (type, parm_tree, cvalue);\n+\t\tipcp_replace_map_create (DECL_STRUCT_FUNCTION (node->decl),\n+\t\t\t\t\t type, parm_tree, cvalue);\n \t      VARRAY_PUSH_GENERIC_PTR (replace_trees, replace_param);\n \t    }\n \t}\n@@ -1063,25 +1052,44 @@ ipcp_insert_stage (void)\n \tfprintf (dump_file, \"versioned function %s\\n\",\n \t\t cgraph_node_name (node));\n       ipcp_cloned_create (node, node1);\n-      for (i = 0; i < count; i++)\n+      if (const_param > 0)\n \t{\n-\t  type = ipcp_cval_get_cvalue_type (ipcp_method_cval (node, i));\n-\t  if (ipcp_type_is_const (type))\n+\t  push_cfun (DECL_STRUCT_FUNCTION (node1->decl));\n+\t  tree_register_cfg_hooks ();\n+\t  current_function_decl = node1->decl;\n+\n+\t  for (i = 0; i < count; i++)\n \t    {\n-\t      cvalue = ipcp_cval_get_cvalue (ipcp_method_cval (node, i));\n-\t      parm_tree = ipa_method_get_tree (node, i);\n-\t      if (type != CONST_VALUE_REF \n-\t\t  && !TREE_READONLY (parm_tree))\n-\t\tipcp_propagate_const (node1, i, cvalue, type);\n+\t      type = ipcp_cval_get_cvalue_type (ipcp_method_cval (node, i));\n+\t      if (ipcp_type_is_const (type))\n+\t\t{\n+\t\t  cvalue = ipcp_cval_get_cvalue (ipcp_method_cval (node, i));\n+\t\t  parm_tree = ipa_method_get_tree (node, i);\n+\t\t  if (type != CONST_VALUE_REF && !is_gimple_reg (parm_tree))\n+\t\t    ipcp_propagate_const (node1, i, cvalue, type);\n+\t\t}\n \t    }\n+\t  if (gimple_in_ssa_p (cfun))\n+\t    {\n+\t      update_ssa (TODO_update_ssa);\n+#ifdef   ENABLE_CHECKING\n+\t      verify_ssa (true);\n+#endif\n+\t    }\n+\t  free_dominance_info (CDI_DOMINATORS);\n+\t  free_dominance_info (CDI_POST_DOMINATORS);\n+\t  pop_cfun ();\n+\t  current_function_decl = NULL;\n \t}\n+      if (dump_file)\n+\tdump_function_to_file (node1->decl, dump_file, dump_flags);\n     }\n   ipcp_update_callgraph ();\n   ipcp_update_profiling ();\n }\n \n /* The IPCP driver.  */\n-unsigned int\n+static unsigned int\n ipcp_driver (void)\n {\n   if (dump_file)"}, {"sha": "55ff37c269156768a855bd72d5ab2fdd3022ced3", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cc1cccc6da7a590bc469bdba47c5f7ec45def4d/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cc1cccc6da7a590bc469bdba47c5f7ec45def4d/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=3cc1cccc6da7a590bc469bdba47c5f7ec45def4d", "patch": "@@ -244,15 +244,17 @@ static void\n ipa_method_modify_stmt (struct cgraph_node *mt, tree stmt)\n {\n   int i, j;\n+  tree parm_decl;\n \n   switch (TREE_CODE (stmt))\n     {\n     case GIMPLE_MODIFY_STMT:\n-      if (TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 0)) == PARM_DECL)\n+\t  if (TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 0)) == PARM_DECL)\n \t{\n-\t  i = ipa_method_tree_map (mt, GIMPLE_STMT_OPERAND (stmt, 0));\n+\t  parm_decl = GIMPLE_STMT_OPERAND (stmt, 0);\n+\t  i = ipa_method_tree_map (mt, parm_decl);\n \t  if (i >= 0)\n-            ipa_method_modify_set (mt, i, true);\n+\t    ipa_method_modify_set (mt, i, true);\n \t}\n       break;\n     case ASM_EXPR:\n@@ -292,11 +294,15 @@ ipa_method_compute_modify (struct cgraph_node *mt)\n   block_stmt_iterator bsi;\n   tree stmt, parm_tree;\n \n+  if (ipa_method_formal_count (mt) == 0)\n+    return;\n+\n   ipa_method_modify_init (mt);\n   decl = mt->decl;\n   count = ipa_method_formal_count (mt);\n   /* ??? Handle pending sizes case. Set all parameters \n      of the method to be modified.  */\n+\n   if (DECL_UNINLINABLE (decl))\n     {\n       for (j = 0; j < count; j++)\n@@ -307,7 +313,8 @@ ipa_method_compute_modify (struct cgraph_node *mt)\n   for (j = 0; j < count; j++)\n     {\n       parm_tree = ipa_method_get_tree (mt, j);\n-      if (TREE_ADDRESSABLE (parm_tree))\n+      if (!is_gimple_reg (parm_tree) \n+\t  && TREE_ADDRESSABLE (parm_tree))\n \tipa_method_modify_set (mt, j, true);\n     }\n   body = DECL_SAVED_TREE (decl);\n@@ -378,7 +385,8 @@ ipa_callsite_param_set_info_type_formal (struct cgraph_edge *cs, int i,\n /* Set int-valued INFO_TYPE1 as 'info_type' field of \n    jump function (ipa_jump_func struct) of argument I of callsite CS.  */\n static inline void\n-ipa_callsite_param_set_info_type (struct cgraph_edge *cs, int i, tree info_type1)\n+ipa_callsite_param_set_info_type (struct cgraph_edge *cs, int i,\n+\t\t\t\t  tree info_type1)\n {\n   ipa_callsite_param (cs, i)->info_type.value = info_type1;\n }\n@@ -435,6 +443,8 @@ ipa_callsite_compute_param (struct cgraph_edge *cs)\n   int arg_num;\n   int i;\n   struct cgraph_node *mt;\n+  tree parm_decl;\n+  struct function *curr_cfun;\n \n   if (ipa_callsite_param_count (cs) == 0)\n     return;\n@@ -449,11 +459,25 @@ ipa_callsite_compute_param (struct cgraph_edge *cs)\n       /* If the formal parameter was passed as argument, we store \n          FORMAL_IPATYPE and its index in the caller as the jump function \n          of this argument.  */\n-      if (TREE_CODE (TREE_VALUE (arg)) == PARM_DECL)\n+      if ((TREE_CODE (TREE_VALUE (arg)) == SSA_NAME\n+\t   && TREE_CODE (SSA_NAME_VAR (TREE_VALUE (arg))) == PARM_DECL)\n+\t  || TREE_CODE (TREE_VALUE (arg)) == PARM_DECL)\n \t{\n \t  mt = ipa_callsite_caller (cs);\n-\t  i = ipa_method_tree_map (mt, TREE_VALUE (arg));\n-\t  if (i < 0 || ipa_method_is_modified (mt, i))\n+\t  parm_decl =\n+\t    TREE_CODE (TREE_VALUE (arg)) ==\n+\t    PARM_DECL ? TREE_VALUE (arg) : SSA_NAME_VAR (TREE_VALUE (arg));\n+          \n+\t  i = ipa_method_tree_map (mt, parm_decl);\n+\t  if (TREE_CODE (TREE_VALUE (arg)) == SSA_NAME \n+\t      && IS_VALID_TREE_MAP_INDEX (i)) \n+\t    {\n+              curr_cfun = DECL_STRUCT_FUNCTION (mt->decl);\n+\t      if (!gimple_default_def (curr_cfun, parm_decl) \n+\t          || gimple_default_def (curr_cfun, parm_decl) != TREE_VALUE (arg))\n+\t\t    ipa_method_modify_set (mt, i, true); \n+            }\n+\t  if (!IS_VALID_TREE_MAP_INDEX (i) || ipa_method_is_modified (mt, i))\n \t    ipa_callsite_param_set_type (cs, arg_num, UNKNOWN_IPATYPE);\n \t  else\n \t    {"}, {"sha": "8450ce4d8ad438a9549355241336ef60edb427de", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cc1cccc6da7a590bc469bdba47c5f7ec45def4d/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cc1cccc6da7a590bc469bdba47c5f7ec45def4d/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=3cc1cccc6da7a590bc469bdba47c5f7ec45def4d", "patch": "@@ -106,6 +106,9 @@ struct ipa_replace_map\n    to ipa_node/ipa_edge struct.  */\n #define IPA_NODE_REF(MT) ((struct ipa_node *)(MT)->aux)\n #define IPA_EDGE_REF(EDGE) ((struct ipa_edge *)(EDGE)->aux)\n+/* This macro checks validity of index returned by\n+   ipa_method_tree_map function.  */\n+#define IS_VALID_TREE_MAP_INDEX(I) ((I) != -1)\n \n /* ipa_node stores information related to a method and\n    its formal parameters. It is pointed to by a field in the\n@@ -199,6 +202,4 @@ void ipa_nodes_free (void);\n void ipa_method_tree_print (FILE *);\n void ipa_method_modify_print (FILE *);\n \n-unsigned int ipcp_driver (void);\n-\n #endif /* IPA_PROP_H */"}]}