{"sha": "bb20cc46aed1c5abe454e1d0472cf307c6a982ed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmIyMGNjNDZhZWQxYzVhYmU0NTRlMWQwNDcyY2YzMDdjNmE5ODJlZA==", "commit": {"author": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2000-09-21T03:43:14Z"}, "committer": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2000-09-21T03:43:14Z"}, "message": "errfn.c: Move declaration of cp_printer and cp_printers to ...\n\n        * errfn.c: Move declaration of cp_printer and cp_printers to ...\n        * cp-tree.h: ... here.\n\n        * error.c: Remove declaration of cp_printer.\n\nFrom-SVN: r36557", "tree": {"sha": "568721c9fe85a0db443612f5ad1c39eb052bdd5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/568721c9fe85a0db443612f5ad1c39eb052bdd5d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb20cc46aed1c5abe454e1d0472cf307c6a982ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb20cc46aed1c5abe454e1d0472cf307c6a982ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb20cc46aed1c5abe454e1d0472cf307c6a982ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb20cc46aed1c5abe454e1d0472cf307c6a982ed/comments", "author": null, "committer": null, "parents": [{"sha": "07328167818043c60e665d3c5bb750a9b54da09b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07328167818043c60e665d3c5bb750a9b54da09b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07328167818043c60e665d3c5bb750a9b54da09b"}], "stats": {"total": 379, "additions": 191, "deletions": 188}, "files": [{"sha": "222b0158f8d0dc78f72d02ccee851e4671e4a0cc", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb20cc46aed1c5abe454e1d0472cf307c6a982ed/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb20cc46aed1c5abe454e1d0472cf307c6a982ed/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=bb20cc46aed1c5abe454e1d0472cf307c6a982ed", "patch": "@@ -1,3 +1,10 @@\n+2000-09-21  Andreas Jaeger  <aj@suse.de>\n+\n+\t* errfn.c: Move declaration of cp_printer and cp_printers to ...\n+\t* cp-tree.h: ... here.\n+\n+\t* error.c: Remove declaration of cp_printer.\n+\n 2000-09-20  Mark Mitchell  <mark@codesourcery.com>\n \n \t* tree.c (mark_local_for_remap_r): Handle CASE_LABELs.\n@@ -14,7 +21,7 @@\n 2000-09-18  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* cp-tree.h (check_function_format): Accept a `status' parameter.\n-\t\n+\n \t* call.c, typeck.c: Updates calls to `check_function_format'.\n \n 2000-09-17  Geoffrey Keating  <geoffk@cygnus.com>\n@@ -72,7 +79,7 @@\n \t* tree.c (cp_statement_code_p): Don't include SCOPE_STMT.\n \t* typeck.c: Change order of includes.\n \t(convert_sequence): Remove.\n-\t\n+\n 2000-09-14  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* lex.c (reswords): Add _Complex.\n@@ -214,7 +221,7 @@ Thu Sep 14 12:10:45 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t(finish_case_label): Remove.\n \t* typeck.c (c_expand_return): Remove.\n \t(c_expand_start_case): Likewise.\n-\t\n+\n 2000-09-07  Gabriel Dos Reis  <gdr@codesourcery.com>\n \n \t* ir.texi: Document type nodes.\n@@ -316,7 +323,7 @@ Thu Sep 14 12:10:45 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t(cp_statement_code_p): New function.\n \t(walk_stmt_tree): Remove.\n \t(init_tree): Set lang_statement_code_p.\n-\t\n+\n 2000-09-06  Zack Weinberg  <zack@wolery.cumb.org>\n \n \tIntegrated preprocessor.\n@@ -2983,11 +2990,11 @@ Mon May 15 11:46:29 2000  Donald Lindsay  <dlindsay@cygnus.com>\n Wed May 17 17:27:44 2000  Andrew Cagney  <cagney@b1.cygnus.com>\n \n \t* decl.c (pop_label): Replace warn_unused with warn_unused_label.\n-  \t* typeck.c (build_x_compound_expr): Replace warn_unused with\n- \twarn_unused_value.\n+\t* typeck.c (build_x_compound_expr): Replace warn_unused with\n+\twarn_unused_value.\n \n \t* decl2.c (lang_decode_option): Update -Wall unused flags by\n- \tcalling set_Wunused.\n+\tcalling set_Wunused.\n \n 2000-05-16  Mark Mitchell  <mark@codesourcery.com>\n \n@@ -6327,4 +6334,3 @@ Wed Jan 26 22:19:14 2000  J\"orn Rennecke <amylaar@cygnus.co.uk>\n 2000-01-01  Martin v. L\ufffdwis  <loewis@informatik.hu-berlin.de>\n \n \t* call.c (build_new_method_call): Also check destructors.\n-"}, {"sha": "2516e89532a0ed074db883465d7dd06f5d83c9ef", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 89, "deletions": 82, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb20cc46aed1c5abe454e1d0472cf307c6a982ed/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb20cc46aed1c5abe454e1d0472cf307c6a982ed/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=bb20cc46aed1c5abe454e1d0472cf307c6a982ed", "patch": "@@ -114,7 +114,7 @@ Boston, MA 02111-1307, USA.  */\n    TYPE_BINFO\n      For an ENUMERAL_TYPE, this is ENUM_TEMPLATE_INFO.\n      For a TYPENAME_TYPE, this is TYPENAME_TYPE_FULLNAME.\n-     For a TEMPLATE_TEMPLATE_PARM or BOUND_TEMPLATE_TEMPLATE_PARM, \n+     For a TEMPLATE_TEMPLATE_PARM or BOUND_TEMPLATE_TEMPLATE_PARM,\n      this is TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO.\n \n   BINFO_VIRTUALS\n@@ -145,7 +145,7 @@ Boston, MA 02111-1307, USA.  */\n      in both ABIs.\n \n    DECL_ARGUMENTS\n-     For a VAR_DECL this is DECL_ANON_UNION_ELEMS.  \n+     For a VAR_DECL this is DECL_ANON_UNION_ELEMS.\n \n    DECL_VINDEX\n      This field is NULL for a non-virtual function.  For a virtual\n@@ -154,7 +154,7 @@ Boston, MA 02111-1307, USA.  */\n      a virtual function is declared, but before it is known what\n      function is overriden, this field is the error_mark_node.\n \n-     Temporarily, it may be set to a TREE_LIST whose TREE_VALUE is \n+     Temporarily, it may be set to a TREE_LIST whose TREE_VALUE is\n      the virtual function this one overrides, and whose TREE_CHAIN is\n      the old DECL_VINDEX.  */\n \n@@ -173,8 +173,8 @@ Boston, MA 02111-1307, USA.  */\n #define VAR_FUNCTION_OR_PARM_DECL_CHECK(NODE)\t\t\t\\\n ({  const tree __t = NODE;\t\t\t\t\t\\\n     enum tree_code __c = TREE_CODE(__t);\t\t\t\\\n-    if (__c != VAR_DECL \t\t\t\t\t\\\n-\t&& __c != FUNCTION_DECL \t\t\t\t\\\n+    if (__c != VAR_DECL\t\t\t\t\t\\\n+\t&& __c != FUNCTION_DECL\t\t\t\t\\\n         && __c != PARM_DECL)\t\t\t\t\t\\\n       tree_check_failed (__t, VAR_DECL, __FILE__, __LINE__,\t\\\n \t\t\t __FUNCTION__);\t\t\t\t\\\n@@ -183,7 +183,7 @@ Boston, MA 02111-1307, USA.  */\n #define VAR_TEMPL_TYPE_OR_FUNCTION_DECL_CHECK(NODE)\t\t\\\n ({  const tree __t = NODE;\t\t\t\t\t\\\n     enum tree_code __c = TREE_CODE(__t);\t\t\t\\\n-    if (__c != VAR_DECL \t\t\t\t\t\\\n+    if (__c != VAR_DECL\t\t\t\t\t\\\n \t&& __c != FUNCTION_DECL\t\t\t\t\t\\\n \t&& __c != TYPE_DECL\t\t\t\t\t\\\n \t&& __c != TEMPLATE_DECL)\t\t\t\t\\\n@@ -307,14 +307,14 @@ struct lang_id2\n   tree error_locus;\n };\n \n-typedef struct \n+typedef struct\n {\n   tree t;\n   int new_type_flag;\n   tree lookups;\n } flagged_type_tree;\n \n-typedef struct \n+typedef struct\n {\n   struct tree_common common;\n   HOST_WIDE_INT index;\n@@ -326,7 +326,7 @@ typedef struct\n typedef struct ptrmem_cst\n {\n   struct tree_common common;\n-  /* This isn't used, but the middle-end expects all constants to have \n+  /* This isn't used, but the middle-end expects all constants to have\n      this field.  */\n   struct rtx_def *rtl;\n   tree member;\n@@ -470,7 +470,7 @@ struct tree_srcloc\n /* The IDENTIFIER_VALUE is the value of the IDENTIFIER_BINDING, or\n    NULL_TREE if there is no binding.  */\n #define IDENTIFIER_VALUE(NODE)\t\t\t\\\n-  (IDENTIFIER_BINDING (NODE) \t\t\t\\\n+  (IDENTIFIER_BINDING (NODE)\t\t\t\\\n    ? BINDING_VALUE (IDENTIFIER_BINDING (NODE))\t\\\n    : NULL_TREE)\n \n@@ -493,7 +493,7 @@ struct tree_srcloc\n \n #define LANG_ID_FIELD(NAME,NODE)\t\t\t\\\n   (LANG_IDENTIFIER_CAST (NODE)->x\t\t\t\\\n-   ? LANG_IDENTIFIER_CAST (NODE)->x->NAME : 0)\t \n+   ? LANG_IDENTIFIER_CAST (NODE)->x->NAME : 0)\n \n #define SET_LANG_ID(NODE,VALUE,NAME)\t\t\t\t\t  \\\n   (LANG_IDENTIFIER_CAST (NODE)->x == 0\t\t\t\t  \\\n@@ -577,7 +577,7 @@ enum cp_tree_index\n     CPTI_VMI_CLASS_DESC_TYPE,\n     CPTI_PTM_DESC_TYPE,\n     CPTI_BASE_DESC_TYPE,\n-    \n+\n     CPTI_CLASS_TYPE,\n     CPTI_RECORD_TYPE,\n     CPTI_UNION_TYPE,\n@@ -1144,8 +1144,8 @@ extern int name_mangling_version;\n    would normally be, for use with WINE.  */\n extern int flag_short_wchar;\n \n-/* Nonzero if squashed mangling is to be performed. \n-   This uses the B and K codes to reference previously seen class types \n+/* Nonzero if squashed mangling is to be performed.\n+   This uses the B and K codes to reference previously seen class types\n    and class qualifiers.       */\n extern int flag_do_squangling;\n \n@@ -1220,8 +1220,8 @@ enum languages { lang_c, lang_cplusplus, lang_java };\n    || TREE_CODE (t) == BOUND_TEMPLATE_TEMPLATE_PARM\t\\\n    || TYPE_LANG_FLAG_5 (t))\n \n-/* Set IS_AGGR_TYPE for T to VAL.  T must be a class, struct, or \n-   union type.  */ \n+/* Set IS_AGGR_TYPE for T to VAL.  T must be a class, struct, or\n+   union type.  */\n #define SET_IS_AGGR_TYPE(T, VAL) \\\n   (TYPE_LANG_FLAG_5 (T) = (VAL))\n \n@@ -1246,7 +1246,7 @@ enum languages { lang_c, lang_cplusplus, lang_java };\n /* The type qualifiers for this type, including the qualifiers on the\n    elements for an array type.  */\n #define CP_TYPE_QUALS(NODE)\t\t\t\\\n-  ((TREE_CODE (NODE) != ARRAY_TYPE) \t\t\\\n+  ((TREE_CODE (NODE) != ARRAY_TYPE)\t\t\\\n    ? TYPE_QUALS (NODE) : cp_type_quals (NODE))\n \n /* Nonzero if this type is const-qualified.  */\n@@ -1364,7 +1364,7 @@ struct lang_type\n      of this by updating the size of this bitfield whenever you add or\n      remove a flag.  */\n   unsigned dummy : 8;\n-      \n+\n   int vsize;\n \n   tree primary_base;\n@@ -1409,7 +1409,7 @@ struct lang_type\n    has a two-argument array operator delete.  */\n #define TYPE_VEC_NEW_USES_COOKIE(NODE)\t\t\\\n   (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (NODE)\t\\\n-   || (TYPE_LANG_SPECIFIC (NODE) \t\t\\\n+   || (TYPE_LANG_SPECIFIC (NODE)\t\t\\\n        && TYPE_VEC_DELETE_TAKES_SIZE (NODE)))\n \n /* Nonzero means that this _CLASSTYPE node defines ways of converting\n@@ -1523,7 +1523,7 @@ struct lang_type\n #define SET_CLASSTYPE_MARKED2(NODE)   SET_CLASSTYPE_MARKED_N(NODE, 1)\n #define CLEAR_CLASSTYPE_MARKED2(NODE) CLEAR_CLASSTYPE_MARKED_N(NODE, 1)\n #define SET_CLASSTYPE_MARKED3(NODE)   SET_CLASSTYPE_MARKED_N(NODE, 2)\n-#define CLEAR_CLASSTYPE_MARKED3(NODE) CLEAR_CLASSTYPE_MARKED_N(NODE, 2)\t\n+#define CLEAR_CLASSTYPE_MARKED3(NODE) CLEAR_CLASSTYPE_MARKED_N(NODE, 2)\n #define SET_CLASSTYPE_MARKED4(NODE)   SET_CLASSTYPE_MARKED_N(NODE, 3)\n #define CLEAR_CLASSTYPE_MARKED4(NODE) CLEAR_CLASSTYPE_MARKED_N(NODE, 3)\n #define SET_CLASSTYPE_MARKED5(NODE)   SET_CLASSTYPE_MARKED_N(NODE, 4)\n@@ -1566,8 +1566,8 @@ struct lang_type\n    binfo_for_vbase.  C is the most derived class for the hierarchy\n    containing BINFO.  */\n #define CANONICAL_BINFO(BINFO, C)\t\t\\\n-  (TREE_VIA_VIRTUAL (BINFO) \t\t\t\\\n-   ? binfo_for_vbase (BINFO_TYPE (BINFO), C) \t\\\n+  (TREE_VIA_VIRTUAL (BINFO)\t\t\t\\\n+   ? binfo_for_vbase (BINFO_TYPE (BINFO), C)\t\\\n    : BINFO)\n \n /* Number of direct baseclasses of NODE.  */\n@@ -1692,7 +1692,7 @@ struct lang_type\n /* Any subobject that needs a new vtable must have a vptr and must not\n    be a primary base (since it would then use the vtable from a\n    derived class.)  */\n-#define SET_BINFO_NEW_VTABLE_MARKED(B, C)\t\t       \t\t \\\n+#define SET_BINFO_NEW_VTABLE_MARKED(B, C)\t\t\t\t \\\n   (BINFO_NEW_VTABLE_MARKED (B, C) = 1,\t\t\t\t\t \\\n    my_friendly_assert (!BINFO_PRIMARY_MARKED_P (B), 20000517),\t\t \\\n    my_friendly_assert (CLASSTYPE_VFIELDS (BINFO_TYPE (B)) != NULL_TREE,  \\\n@@ -1806,7 +1806,7 @@ struct lang_type\n #define CAN_HAVE_FULL_LANG_DECL_P(NODE)\t\t\\\n   (!(TREE_CODE ((NODE)) == VAR_DECL\t\t\\\n      || TREE_CODE ((NODE)) == CONST_DECL\t\\\n-     || TREE_CODE ((NODE)) == FIELD_DECL \t\\\n+     || TREE_CODE ((NODE)) == FIELD_DECL\t\\\n      || TREE_CODE ((NODE)) == USING_DECL))\n \n struct lang_decl_flags\n@@ -1932,7 +1932,7 @@ struct lang_decl\n /* Nonzero if NODE (a FUNCTION_DECL) is a constructor for a complete\n    object.  */\n #define DECL_COMPLETE_CONSTRUCTOR_P(NODE)\t\t\\\n-  (DECL_CONSTRUCTOR_P (NODE) \t\t\t\t\\\n+  (DECL_CONSTRUCTOR_P (NODE)\t\t\t\t\\\n    && DECL_NAME (NODE) == complete_ctor_identifier)\n \n /* Nonzero if NODE (a FUNCTION_DECL) is a constructor for a base\n@@ -1964,7 +1964,7 @@ struct lang_decl\n /* Nonzero if NODE (a FUNCTION_DECL) is a destructor for a complete\n    object.  */\n #define DECL_COMPLETE_DESTRUCTOR_P(NODE)\t\t\\\n-  (DECL_DESTRUCTOR_P (NODE) \t\t\t\t\\\n+  (DECL_DESTRUCTOR_P (NODE)\t\t\t\t\\\n    && DECL_NAME (NODE) == complete_dtor_identifier)\n \n /* Nonzero if NODE (a FUNCTION_DECL) is a destructor for a base\n@@ -1976,13 +1976,13 @@ struct lang_decl\n /* Nonzero if NODE (a FUNCTION_DECL) is a destructor for a complete\n    object that deletes the object after it has been destroyed.  */\n #define DECL_DELETING_DESTRUCTOR_P(NODE)\t\t\\\n-  (DECL_DESTRUCTOR_P (NODE) \t\t\t\t\\\n+  (DECL_DESTRUCTOR_P (NODE)\t\t\t\t\\\n    && DECL_NAME (NODE) == deleting_dtor_identifier)\n \n /* Nonzero if NODE (a FUNCTION_DECL) is a cloned constructor or\n    destructor.  */\n #define DECL_CLONED_FUNCTION_P(NODE)\t\t\\\n-  (DECL_LANG_SPECIFIC (NODE) \t\t\t\\\n+  (DECL_LANG_SPECIFIC (NODE)\t\t\t\\\n    && DECL_CLONED_FUNCTION (NODE) != NULL_TREE)\n \n /* If DECL_CLONED_FUNCTION_P holds, this is the function that was\n@@ -2024,7 +2024,7 @@ struct lang_decl\n    overloaded operator, ERROR_MARK is returned.  Since the numerical\n    value of ERROR_MARK is zero, this macro can be used as a predicate\n    to test whether or not NODE is an overloaded operator.  */\n-#define DECL_OVERLOADED_OPERATOR_P(NODE)       \t\t\\\n+#define DECL_OVERLOADED_OPERATOR_P(NODE)\t\t\\\n   (IDENTIFIER_OPNAME_P (DECL_NAME ((NODE)))\t\t\\\n    ? DECL_LANG_SPECIFIC (NODE)->u2.operator_code : ERROR_MARK)\n \n@@ -2040,7 +2040,7 @@ struct lang_decl\n \n /* Non-zero for a FUNCTION_DECL that declares a type-info function.\n    This only happens in the old abi.  */\n-#define DECL_TINFO_FN_P(NODE) \t\t\t\t\t\\\n+#define DECL_TINFO_FN_P(NODE)\t\t\t\t\t\\\n   (TREE_CODE (NODE) == FUNCTION_DECL\t\t\t\t\\\n    && DECL_ARTIFICIAL (NODE)\t\t\t\t\t\\\n    && DECL_LANG_SPECIFIC(NODE)->decl_flags.tinfo_fn_p)\n@@ -2083,7 +2083,7 @@ struct lang_decl\n #define SHARED_MEMBER_P(NODE) \\\n   (TREE_CODE (NODE) == VAR_DECL || TREE_CODE (NODE) == TYPE_DECL \\\n    || TREE_CODE (NODE) == CONST_DECL)\n-\t\t\t\t\n+\n /* Nonzero for FUNCTION_DECL means that this decl is a non-static\n    member function.  */\n #define DECL_NONSTATIC_MEMBER_FUNCTION_P(NODE) \\\n@@ -2098,7 +2098,7 @@ struct lang_decl\n    has `this' as const X *const.  */\n #define DECL_CONST_MEMFUNC_P(NODE)\t\t\t\t\t \\\n   (DECL_NONSTATIC_MEMBER_FUNCTION_P (NODE)\t\t\t\t \\\n-   && CP_TYPE_CONST_P (TREE_TYPE (TREE_VALUE \t\t\t\t \\\n+   && CP_TYPE_CONST_P (TREE_TYPE (TREE_VALUE\t\t\t\t \\\n \t\t\t\t  (TYPE_ARG_TYPES (TREE_TYPE (NODE))))))\n \n /* Nonzero for FUNCTION_DECL means that this member function\n@@ -2109,8 +2109,8 @@ struct lang_decl\n \t\t\t\t  (TYPE_ARG_TYPES (TREE_TYPE (NODE))))))\n \n /* Nonzero for a DECL means that this member is a non-static member.  */\n-#define DECL_NONSTATIC_MEMBER_P(NODE) \t\t\\\n-  ((TREE_CODE (NODE) == FUNCTION_DECL \t\t\\\n+#define DECL_NONSTATIC_MEMBER_P(NODE)\t\t\\\n+  ((TREE_CODE (NODE) == FUNCTION_DECL\t\t\\\n     && DECL_NONSTATIC_MEMBER_FUNCTION_P (NODE))\t\\\n    || TREE_CODE (NODE) == FIELD_DECL)\n \n@@ -2163,7 +2163,7 @@ struct lang_decl\n \n /* For a non-member friend function, the class (if any) in which this\n    friend was defined.  For example, given:\n-   \n+\n      struct S { friend void f (); };\n \n    the DECL_FRIEND_CONTEXT for `f' will be `S'.  */\n@@ -2244,7 +2244,7 @@ struct lang_decl\n    but have not yet processed it.  */\n #define DECL_PENDING_INLINE_P(NODE) \\\n   (DECL_LANG_SPECIFIC (NODE)->decl_flags.pending_inline_p)\n-   \n+\n /* If DECL_PENDING_INLINE_P holds, this is the saved text of the\n    function.  */\n #define DECL_PENDING_INLINE_INFO(NODE) \\\n@@ -2289,9 +2289,9 @@ struct lang_decl\n \n /* Set the template information for an ENUMERAL_, RECORD_, or\n    UNION_TYPE to VAL.  */\n-#define SET_TYPE_TEMPLATE_INFO(NODE, VAL) \t\\\n-  (TREE_CODE (NODE) == ENUMERAL_TYPE \t\t\\\n-   ? (ENUM_TEMPLATE_INFO (NODE) = VAL) \t\t\\\n+#define SET_TYPE_TEMPLATE_INFO(NODE, VAL)\t\\\n+  (TREE_CODE (NODE) == ENUMERAL_TYPE\t\t\\\n+   ? (ENUM_TEMPLATE_INFO (NODE) = VAL)\t\t\\\n    : (CLASSTYPE_TEMPLATE_INFO (NODE) = VAL))\n \n #define TI_TEMPLATE(NODE) (TREE_PURPOSE (NODE))\n@@ -2304,7 +2304,7 @@ struct lang_decl\n    arguments, then each entry in the TREE_VEC is itself a TREE_VEC,\n    containing the template arguments for a single level.  The first\n    entry in the outer TREE_VEC is the outermost level of template\n-   parameters; the last is the innermost.  \n+   parameters; the last is the innermost.\n \n    It is incorrect to ever form a template argument vector containing\n    only one level of arguments, but which is a TREE_VEC containing as\n@@ -2330,7 +2330,7 @@ struct lang_decl\n /* The LEVELth level of the template ARGS.  The outermost level of of\n    args is level 1, not level 0.  */\n #define TMPL_ARGS_LEVEL(ARGS, LEVEL)\t\t\\\n-  (TMPL_ARGS_HAVE_MULTIPLE_LEVELS (ARGS) \t\\\n+  (TMPL_ARGS_HAVE_MULTIPLE_LEVELS (ARGS)\t\\\n    ? TREE_VEC_ELT ((ARGS), (LEVEL) - 1) : ARGS)\n \n /* Set the LEVELth level of the template ARGS to VAL.  This macro does\n@@ -2349,9 +2349,9 @@ struct lang_decl\n \n /* Given a single level of template arguments in NODE, return the\n    number of arguments.  */\n-#define NUM_TMPL_ARGS(NODE) \t\t\t\t\\\n-  ((NODE) == NULL_TREE ? 0 \t\t\t\t\\\n-   : (TREE_CODE (NODE) == TREE_VEC \t\t\t\\\n+#define NUM_TMPL_ARGS(NODE)\t\t\t\t\\\n+  ((NODE) == NULL_TREE ? 0\t\t\t\t\\\n+   : (TREE_CODE (NODE) == TREE_VEC\t\t\t\\\n       ? TREE_VEC_LENGTH (NODE) : list_length (NODE)))\n \n /* Returns the innermost level of template arguments in ARGS.  */\n@@ -2369,7 +2369,7 @@ struct lang_decl\n       template <class T> struct S { template <class U> void f(U); }\n \n    the FUNCTION_DECL for S<int>::f<double> will have, as its\n-   DECL_TI_TEMPLATE, `template <class U> S<int>::f<U>'. \n+   DECL_TI_TEMPLATE, `template <class U> S<int>::f<U>'.\n \n    As a special case, for a member friend template of a template\n    class, this value will not be a TEMPLATE_DECL, but rather a\n@@ -2379,7 +2379,7 @@ struct lang_decl\n      template <class T> struct S { friend void f<int>(int, double); }\n \n    the DECL_TI_TEMPLATE will be a LOOKUP_EXPR for `f' and the\n-   DECL_TI_ARGS will be {int}.  */ \n+   DECL_TI_ARGS will be {int}.  */\n #define DECL_TI_TEMPLATE(NODE)      TI_TEMPLATE (DECL_TEMPLATE_INFO (NODE))\n \n /* The template arguments used to obtain this decl from the most\n@@ -2390,7 +2390,7 @@ struct lang_decl\n #define DECL_TI_ARGS(NODE)          TI_ARGS (DECL_TEMPLATE_INFO (NODE))\n #define CLASSTYPE_TI_TEMPLATE(NODE) TI_TEMPLATE (CLASSTYPE_TEMPLATE_INFO (NODE))\n #define CLASSTYPE_TI_ARGS(NODE)     TI_ARGS (CLASSTYPE_TEMPLATE_INFO (NODE))\n-#define ENUM_TI_TEMPLATE(NODE) \t\t\t\\\n+#define ENUM_TI_TEMPLATE(NODE)\t\t\t\\\n   TI_TEMPLATE (ENUM_TEMPLATE_INFO (NODE))\n #define ENUM_TI_ARGS(NODE)\t\t\t\\\n   TI_ARGS (ENUM_TEMPLATE_INFO (NODE))\n@@ -2445,7 +2445,7 @@ struct lang_decl\n \n /* Nonzero if NODE is a TYPE_DECL that should not be visible because\n    it is from a dependent base class.  */\n-#define IMPLICIT_TYPENAME_TYPE_DECL_P(NODE) \t\\\n+#define IMPLICIT_TYPENAME_TYPE_DECL_P(NODE)\t\\\n   (TREE_CODE (NODE) == TYPE_DECL\t\t\\\n    && DECL_ARTIFICIAL (NODE)\t\t\t\\\n    && IMPLICIT_TYPENAME_P (TREE_TYPE (NODE)))\n@@ -2466,9 +2466,9 @@ struct lang_decl\n #define TYPE_POLYMORPHIC_P(NODE) (TREE_LANG_FLAG_2 (NODE))\n \n /* Nonzero if this class has a virtual function table pointer.  */\n-#define TYPE_CONTAINS_VPTR_P(NODE) \t\t\\\n-  (TYPE_POLYMORPHIC_P (NODE) \t\t\t\\\n-   || (vbase_offsets_in_vtable_p () \t\t\\\n+#define TYPE_CONTAINS_VPTR_P(NODE)\t\t\\\n+  (TYPE_POLYMORPHIC_P (NODE)\t\t\t\\\n+   || (vbase_offsets_in_vtable_p ()\t\t\\\n        && TYPE_USES_VIRTUAL_BASECLASSES (NODE)))\n \n extern int flag_new_for_scope;\n@@ -2512,12 +2512,12 @@ extern int flag_new_for_scope;\n /* [basic.fundamental]\n \n    Types  bool, char, wchar_t, and the signed and unsigned integer types\n-   are collectively called integral types.  \n+   are collectively called integral types.\n \n    Note that INTEGRAL_TYPE_P, as defined in tree.h, allows enumeration\n    types as well, which is incorrect in C++.  */\n-#define CP_INTEGRAL_TYPE_P(TYPE) \t\t\\\n-  (TREE_CODE ((TYPE)) == BOOLEAN_TYPE \t\t\\\n+#define CP_INTEGRAL_TYPE_P(TYPE)\t\t\\\n+  (TREE_CODE ((TYPE)) == BOOLEAN_TYPE\t\t\\\n    || TREE_CODE ((TYPE)) == INTEGER_TYPE)\n \n /* [basic.fundamental]\n@@ -2568,15 +2568,15 @@ extern int flag_new_for_scope;\n #define TYPE_HAS_COMPLEX_INIT_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->has_complex_init_ref)\n \n /* Nonzero if TYPE has a trivial destructor.  From [class.dtor]:\n-   \n+\n      A destructor is trivial if it is an implicitly declared\n      destructor and if:\n \n        - all of the direct base classes of its class have trivial\n-         destructors, \n+         destructors,\n \n        - for all of the non-static data members of its class that are\n-         of class type (or array thereof), each such class has a \n+         of class type (or array thereof), each such class has a\n \t trivial destructor.  */\n #define TYPE_HAS_TRIVIAL_DESTRUCTOR(NODE) \\\n   (!TYPE_HAS_NONTRIVIAL_DESTRUCTOR (NODE))\n@@ -2677,7 +2677,7 @@ extern int flag_new_for_scope;\n    function.\n \n    (Of course, the exact values may differ depending on the mangling\n-   scheme, sizes of types, and such.).  \n+   scheme, sizes of types, and such.).\n \n    Under the new ABI, we do:\n \n@@ -2690,7 +2690,7 @@ extern int flag_new_for_scope;\n    in the object.)  If the function is virtual, then PFN is one plus\n    twice the index into the vtable; otherwise, it is just a pointer to\n    the function.  */\n-     \n+\n /* Get the POINTER_TYPE to the METHOD_TYPE associated with this\n    pointer to member function.  TYPE_PTRMEMFUNC_P _must_ be true,\n    before using this macro.  */\n@@ -2728,7 +2728,7 @@ extern int flag_new_for_scope;\n #define PTRMEM_CST_CLASS(NODE) \\\n   TYPE_PTRMEM_CLASS_TYPE (TREE_TYPE (PTRMEM_CST_CHECK (NODE)))\n \n-/* For a pointer-to-member constant `X::Y' this is the _DECL for \n+/* For a pointer-to-member constant `X::Y' this is the _DECL for\n    `Y'.  */\n #define PTRMEM_CST_MEMBER(NODE) (((ptrmem_cst_t)PTRMEM_CST_CHECK (NODE))->member)\n \n@@ -2857,7 +2857,7 @@ extern int flag_new_for_scope;\n \n       template <class T> struct S {\n         template <class U> void f(U);\n-\ttemplate <> void f(T); \n+\ttemplate <> void f(T);\n       };\n \n    the `S<int>::f<int>(int)' function will appear on the\n@@ -2881,7 +2881,7 @@ extern int flag_new_for_scope;\n #define DECL_TEMPLATE_SPECIALIZATIONS(NODE)     DECL_SIZE(NODE)\n \n /* Nonzero for a DECL which is actually a template parameter.  */\n-#define DECL_TEMPLATE_PARM_P(NODE) \t\t\\\n+#define DECL_TEMPLATE_PARM_P(NODE)\t\t\\\n   (DECL_LANG_FLAG_0 (NODE)\t\t\t\\\n    && (TREE_CODE (NODE) == CONST_DECL\t\t\\\n        || TREE_CODE (NODE) == TYPE_DECL\t\t\\\n@@ -3396,7 +3396,7 @@ extern varray_type local_classes;\n #define VTABLE_PFN_NAME\t\t\"__pfn\"\n #define VTABLE_DELTA2_NAME\t\"__delta2\"\n \n-#define EXCEPTION_CLEANUP_NAME \t\"exception cleanup\"\n+#define EXCEPTION_CLEANUP_NAME\t\"exception cleanup\"\n \n /* The name used as a prefix for VTTs.  When the new ABI mangling\n    scheme is implemented, this should be removed.  */\n@@ -3414,7 +3414,7 @@ extern varray_type local_classes;\n #define VPTR_NAME_P(ID_NODE) (IDENTIFIER_POINTER (ID_NODE)[0] == JOINER \\\n \t\t\t      && IDENTIFIER_POINTER (ID_NODE)[1] == 'v')\n #define DESTRUCTOR_NAME_P(ID_NODE) (IDENTIFIER_POINTER (ID_NODE)[1] == JOINER \\\n-                                    && IDENTIFIER_POINTER (ID_NODE)[2] == '_') \n+                                    && IDENTIFIER_POINTER (ID_NODE)[2] == '_')\n \n #define VTABLE_NAME_P(ID_NODE) (IDENTIFIER_POINTER (ID_NODE)[1] == 'v' \\\n   && IDENTIFIER_POINTER (ID_NODE)[2] == 't' \\\n@@ -3438,7 +3438,7 @@ extern varray_type local_classes;\n #endif /* !defined(NO_DOLLAR_IN_LABEL) || !defined(NO_DOT_IN_LABEL) */\n \n /* Store the vbase pointer field name for type TYPE into pointer BUF.  */\n-#define FORMAT_VBASE_NAME(BUF,TYPE) do { \t\t\t\t\\\n+#define FORMAT_VBASE_NAME(BUF,TYPE) do {\t\t\t\t\\\n   char *wbuf = (char *) alloca (TYPE_ASSEMBLER_NAME_LENGTH (TYPE)\t\\\n \t\t\t + sizeof (VBASE_NAME) + 1);\t\t\t\\\n   sprintf (wbuf, VBASE_NAME_FORMAT, TYPE_ASSEMBLER_NAME_STRING (TYPE));\t\\\n@@ -3527,7 +3527,7 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n \n    These are used in global lookup to support elaborated types and\n    qualifiers.\n-   \n+\n    LOOKUP_PREFER_TYPES means not to accept objects, and possibly namespaces.\n    LOOKUP_PREFER_NAMESPACES means not to accept objects, and possibly types.\n    LOOKUP_PREFER_BOTH means class-or-namespace-name.\n@@ -3555,7 +3555,7 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n #define LOOKUP_TYPES_ONLY(f)  \\\n   (!((f) & LOOKUP_PREFER_NAMESPACES) && ((f) & LOOKUP_PREFER_TYPES))\n #define LOOKUP_QUALIFIERS_ONLY(f)     ((f) & LOOKUP_PREFER_BOTH)\n-     \n+\n \n /* These flags are used by the conversion code.\n    CONV_IMPLICIT   :  Perform implicit conversions (standard and user-defined).\n@@ -3564,7 +3564,7 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n    CONV_REINTERPRET:  Perform the explicit conversions for reinterpret_cast.\n    CONV_PRIVATE    :  Perform upcasts to private bases.\n    CONV_FORCE_TEMP :  Require a new temporary when converting to the same\n-   \t\t      aggregate type.  */\n+\t\t      aggregate type.  */\n \n #define CONV_IMPLICIT    1\n #define CONV_STATIC      2\n@@ -3640,7 +3640,7 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n #define TEMPLATE_PARM_ORIG_LEVEL(NODE) (TEMPLATE_PARM_INDEX_CAST (NODE)->orig_level)\n #define TEMPLATE_PARM_DECL(NODE) (TEMPLATE_PARM_INDEX_CAST (NODE)->decl)\n \n-/* These macros are for accessing the fields of TEMPLATE_TYPE_PARM, \n+/* These macros are for accessing the fields of TEMPLATE_TYPE_PARM,\n    TEMPLATE_TEMPLATE_PARM and BOUND_TEMPLATE_TEMPLATE_PARM nodes.  */\n #define TEMPLATE_TYPE_PARM_INDEX(NODE) (TYPE_FIELDS (NODE))\n #define TEMPLATE_TYPE_IDX(NODE) \\\n@@ -3668,19 +3668,19 @@ enum tree_string_flags\n     TS_FUNC_SCOPE     = 1 <<  8, /* show function scope */\n     TS_PEDANTIC_NAME  = 1 <<  9, /* pedantically name things */\n     TS_TEMPLATE_PREFIX= 1 << 10, /* show template <parms> prefix */\n-    \n+\n     /* Internal use flags */\n     TS_TEMPLATE_PARM  = 1 << 11, /* decl is really a non-type template parm */\n     TS_TEMPLATE_PLAIN = 1 << 12, /* don't decorate primary template_name */\n-    \n+\n     TS_NEXT_BIT       = 13       /* next available bit */\n };\n \n /* Returns the TEMPLATE_DECL associated to a TEMPLATE_TEMPLATE_PARM\n    node.  */\n-#define TEMPLATE_TEMPLATE_PARM_TEMPLATE_DECL(NODE) \t\\\n+#define TEMPLATE_TEMPLATE_PARM_TEMPLATE_DECL(NODE)\t\\\n   ((TREE_CODE (NODE) == BOUND_TEMPLATE_TEMPLATE_PARM)\t\\\n-   ? TYPE_TI_TEMPLATE (NODE) \t\t\t\t\\\n+   ? TYPE_TI_TEMPLATE (NODE)\t\t\t\t\\\n    : TYPE_NAME (NODE))\n \n /* in lex.c  */\n@@ -3950,11 +3950,11 @@ extern tree grokbitfield\t\t\tPARAMS ((tree, tree, tree));\n extern tree groktypefield\t\t\tPARAMS ((tree, tree));\n extern tree grokoptypename\t\t\tPARAMS ((tree, tree));\n extern int copy_assignment_arg_p\t\tPARAMS ((tree, int));\n-extern void cplus_decl_attributes\t\tPARAMS ((tree, tree, tree)); \n+extern void cplus_decl_attributes\t\tPARAMS ((tree, tree, tree));\n extern tree constructor_name_full\t\tPARAMS ((tree));\n extern tree constructor_name\t\t\tPARAMS ((tree));\n extern void setup_vtbl_ptr\t\t\tPARAMS ((tree, tree));\n-extern void defer_fn             \t\tPARAMS ((tree));\n+extern void defer_fn\t\tPARAMS ((tree));\n extern tree get_temp_name\t\t\tPARAMS ((tree));\n extern void finish_anon_union\t\t\tPARAMS ((tree));\n extern tree finish_table\t\t\tPARAMS ((tree, tree, tree, int));\n@@ -4019,6 +4019,13 @@ extern const char *cp_file_of\t\t\tPARAMS ((tree));\n extern int cp_line_of\t\t\t\tPARAMS ((tree));\n extern const char *language_to_string           PARAMS ((enum languages, int));\n extern void print_instantiation_context         PARAMS ((void));\n+/* cp_printer is the type of a function which converts an argument into\n+   a string for digestion by printf.  The cp_printer function should deal\n+   with all memory management; the functions in errfn will not free\n+   the char*s returned.  See error.c for an example use of this code.  */\n+typedef const char *cp_printer\t\t\tPARAMS ((tree, int));\n+extern cp_printer *cp_printers[256];\n+\n \n /* in except.c */\n extern void init_exception_processing\t\tPARAMS ((void));\n@@ -4114,7 +4121,7 @@ extern void init_method\t\t\t\tPARAMS ((void));\n extern char *build_overload_name\t\tPARAMS ((tree, int, int));\n extern tree build_static_name\t\t\tPARAMS ((tree, tree));\n extern tree build_decl_overload_real            PARAMS ((tree, tree, tree, tree,\n-\t\t\t\t\t\t       tree, int)); \n+\t\t\t\t\t\t       tree, int));\n extern void set_mangled_name_for_decl           PARAMS ((tree));\n extern tree build_typename_overload\t\tPARAMS ((tree));\n extern tree build_overload_with_type\t\tPARAMS ((tree, tree));\n@@ -4241,11 +4248,11 @@ extern int at_function_scope_p                  PARAMS ((void));\n extern tree lookup_conversions\t\t\tPARAMS ((tree));\n extern tree binfo_for_vtable\t\t\tPARAMS ((tree));\n extern int  binfo_from_vbase\t\t\tPARAMS ((tree));\n-extern tree dfs_walk                            PARAMS ((tree, \n+extern tree dfs_walk                            PARAMS ((tree,\n \t\t\t\t\t\t       tree (*)(tree, void *),\n \t\t\t\t\t\t       tree (*) (tree, void *),\n \t\t\t\t\t\t       void *));\n-extern tree dfs_walk_real                      PARAMS ((tree, \n+extern tree dfs_walk_real                      PARAMS ((tree,\n \t\t\t\t\t\t       tree (*) (tree, void *),\n \t\t\t\t\t\t       tree (*) (tree, void *),\n \t\t\t\t\t\t       tree (*) (tree, void *),\n@@ -4409,7 +4416,7 @@ extern tree array_type_nelts_top\t\tPARAMS ((tree));\n extern tree break_out_target_exprs\t\tPARAMS ((tree));\n extern tree get_type_decl\t\t\tPARAMS ((tree));\n extern tree vec_binfo_member\t\t\tPARAMS ((tree, tree));\n-extern tree decl_namespace_context \t\tPARAMS ((tree));\n+extern tree decl_namespace_context\t\tPARAMS ((tree));\n extern tree lvalue_type\t\t\t\tPARAMS ((tree));\n extern tree error_type\t\t\t\tPARAMS ((tree));\n extern tree build_ptr_wrapper\t\t\tPARAMS ((void *));\n@@ -4427,7 +4434,7 @@ extern tree maybe_dummy_object\t\t\tPARAMS ((tree, tree *));\n extern int is_dummy_object\t\t\tPARAMS ((tree));\n extern tree walk_tree                           PARAMS ((tree *,\n \t\t\t\t\t\t\t walk_tree_fn,\n-\t\t\t\t\t\t\t void *, \n+\t\t\t\t\t\t\t void *,\n \t\t\t\t\t\t\t htab_t));\n extern tree walk_tree_without_duplicates        PARAMS ((tree *,\n \t\t\t\t\t\t\t walk_tree_fn,\n@@ -4445,7 +4452,7 @@ extern int count_trees                          PARAMS ((tree));\n extern int char_type_p                          PARAMS ((tree));\n extern void verify_stmt_tree                    PARAMS ((tree));\n extern tree find_tree                           PARAMS ((tree, tree));\n-  \n+\n /* in typeck.c */\n extern int string_conv_p\t\t\tPARAMS ((tree, tree, int));\n extern tree condition_conversion\t\tPARAMS ((tree));\n@@ -4571,7 +4578,7 @@ extern tree mangle_typeinfo_string_for_type     PARAMS ((tree));\n extern tree mangle_vtbl_for_type                PARAMS ((tree));\n extern tree mangle_vtt_for_type                 PARAMS ((tree));\n extern tree mangle_ctor_vtbl_for_type           PARAMS ((tree, tree));\n-extern tree mangle_thunk                        PARAMS ((tree, tree, tree)); \n+extern tree mangle_thunk                        PARAMS ((tree, tree, tree));\n extern tree mangle_conv_op_name_for_type        PARAMS ((tree));\n extern tree mangle_guard_variable               PARAMS ((tree));\n "}, {"sha": "802f5676ee77e1115a5d34bc06d56a6654322fbe", "filename": "gcc/cp/errfn.c", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb20cc46aed1c5abe454e1d0472cf307c6a982ed/gcc%2Fcp%2Ferrfn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb20cc46aed1c5abe454e1d0472cf307c6a982ed/gcc%2Fcp%2Ferrfn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferrfn.c?ref=bb20cc46aed1c5abe454e1d0472cf307c6a982ed", "patch": "@@ -19,21 +19,13 @@ You should have received a copy of the GNU General Public License\n along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n-   \n+\n #include \"config.h\"\n #include \"system.h\"\n #include \"tree.h\"\n #include \"cp-tree.h\"\n #include \"toplev.h\"\n \n-/* cp_printer is the type of a function which converts an argument into\n-   a string for digestion by printf.  The cp_printer function should deal\n-   with all memory management; the functions in this file will not free\n-   the char*s returned.  See error.c for an example use of this code.  */\n-\n-typedef const char *cp_printer PARAMS ((tree, int));\n-extern cp_printer * cp_printers[256];\n-\n /* Whether or not we should try to be quiet for errors and warnings; this is\n    used to avoid being too talkative about problems with tentative choices\n    when we're computing the conversion costs for a method call.  */\n@@ -76,7 +68,7 @@ cp_thing (errfn, atarg1, format, ap)\n       cp_printer * function;\n       int alternate;\n       int maybe_here;\n-      \n+\n       /* ignore text */\n       if (*f != '%')\n \t{\n@@ -175,7 +167,7 @@ cp_thing (errfn, atarg1, format, ap)\n   buf[offset] = '\\0';\n \n   /* If ATARG1 is set, but we haven't extracted any arguments, then\n-     extract one tree argument for ATARG.  */  \n+     extract one tree argument for ATARG.  */\n   if (nargs == 0 && atarg1)\n     atarg = va_arg (ap, tree);\n "}, {"sha": "a847df490efa46fe8d7941c07fc14a3d777e4320", "filename": "gcc/cp/error.c", "status": "modified", "additions": 85, "deletions": 87, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb20cc46aed1c5abe454e1d0472cf307c6a982ed/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb20cc46aed1c5abe454e1d0472cf307c6a982ed/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=bb20cc46aed1c5abe454e1d0472cf307c6a982ed", "patch": "@@ -36,7 +36,7 @@ enum pad { none, before, after };\n    TFF_CLASS_SCOPE: if possible, include the class-name part of a\n         qualified-id.  This flag may be implied in some circumstances by\n         TFF_NAMESPACE_SCOPE.\n-   TFF_SCOPE: the combinaison of the two above.        \n+   TFF_SCOPE: the combinaison of the two above.\n    TFF_CHASE_TYPDEF: print the original type-id instead of the typedef-name.\n    TFF_DECL_SPECIFIERS: print decl-specifiers.\n    TFF_CLASS_KEY_OR_ENUM: precede a class-type name (resp. enum name) with\n@@ -90,8 +90,6 @@ typedef struct\n      put_whitespace (TFI) = none;            \\\n    } while (0)\n \n-typedef const char *cp_printer ();\n-\n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n \n@@ -116,7 +114,7 @@ static char *scratch_firstobj;\n # define OB_PUTI(CST) do { sprintf (digit_buffer, HOST_WIDE_INT_PRINT_DEC, (HOST_WIDE_INT)(CST)); \\\n \t\t\t   OB_PUTCP (digit_buffer); } while (0)\n \n-# define OB_END_TEMPLATE_ID() \t\t\t\t\t\t    \\\n+# define OB_END_TEMPLATE_ID()\t\t\t\t\t\t    \\\n   (((obstack_next_free (&scratch_obstack) != obstack_base (&scratch_obstack) \\\n     && obstack_next_free (&scratch_obstack)[-1] == '>')\t\t\t    \\\n    ? OB_PUTC (' ') : (void)0), OB_PUTC ('>'))\n@@ -256,7 +254,7 @@ dump_scope (scope, flags)\n {\n   if (scope == NULL_TREE)\n     return;\n-  \n+\n   if (TREE_CODE (scope) == NAMESPACE_DECL)\n     {\n       if (scope != global_namespace)\n@@ -298,7 +296,7 @@ dump_qualifiers (t, p)\n   int ix;\n   int quals = TYPE_QUALS (t);\n   int do_after = p == after;\n-  \n+\n   if (quals)\n     {\n       for (ix = 0; ix != 3; ix++)\n@@ -431,7 +429,7 @@ dump_template_bindings (parms, args)\n \t    dump_template_argument (arg, TS_PLAIN);\n \t  else\n \t    OB_PUTS (\"{missing}\");\n-          \n+\n \t  ++arg_idx;\n \t  need_comma = 1;\n \t}\n@@ -450,7 +448,7 @@ dump_type (t, flags)\n {\n   if (t == NULL_TREE)\n     return;\n-  \n+\n   if (TYPE_PTRMEMFUNC_P (t))\n     goto offset_type;\n \n@@ -487,12 +485,12 @@ dump_type (t, flags)\n           break;\n         }\n       /* else fallthrough */\n-    \n+\n     case TEMPLATE_DECL:\n     case NAMESPACE_DECL:\n       dump_decl (t, flags & ~TS_DECL_TYPE);\n       break;\n-    \n+\n     case COMPLEX_TYPE:\n       OB_PUTS (\"complex \");\n       dump_type (TREE_TYPE (t), flags);\n@@ -593,7 +591,7 @@ dump_typename (t, flags)\n      enum tree_string_flags flags;\n {\n   tree ctx = TYPE_CONTEXT (t);\n-  \n+\n   if (TREE_CODE (ctx) == TYPENAME_TYPE)\n     dump_typename (ctx, flags);\n   else\n@@ -638,7 +636,7 @@ dump_aggr_type (t, flags)\n       OB_PUTCP (variety);\n       OB_PUTC (' ');\n     }\n-  \n+\n   if (flags & TS_CHASE_TYPEDEFS)\n     t = TYPE_MAIN_VARIANT (t);\n \n@@ -659,7 +657,7 @@ dump_aggr_type (t, flags)\n           /* Because the template names are mangled, we have to locate\n              the most general template, and use that name.  */\n           tree tpl = CLASSTYPE_TI_TEMPLATE (t);\n-          \n+\n           while (DECL_TEMPLATE_INFO (tpl))\n             tpl = DECL_TI_TEMPLATE (tpl);\n           name = tpl;\n@@ -694,8 +692,8 @@ dump_aggr_type (t, flags)\n    deal with prefix and suffix.\n \n    Arrays must also do this for DECL nodes, like int a[], and for things like\n-   int *[]&.  \n-   \n+   int *[]&.\n+\n    Return indicates how you should pad an object name after this. I.e. you\n    want to pad non-*, non-& cores, but not pad * or & types.  */\n \n@@ -705,20 +703,20 @@ dump_type_prefix (t, flags)\n      enum tree_string_flags flags;\n {\n   enum pad padding = before;\n-  \n+\n   if (TYPE_PTRMEMFUNC_P (t))\n     {\n       t = TYPE_PTRMEMFUNC_FN_TYPE (t);\n       goto offset_type;\n     }\n-  \n+\n   switch (TREE_CODE (t))\n     {\n     case POINTER_TYPE:\n     case REFERENCE_TYPE:\n       {\n \ttree sub = TREE_TYPE (t);\n-\t\n+\n \tpadding = dump_type_prefix (sub, flags);\n \t/* A tree for a member pointer looks like pointer to offset,\n \t   so let the OFFSET_TYPE case handle it.  */\n@@ -792,7 +790,7 @@ dump_type_prefix (t, flags)\n       dump_type (t, flags);\n       padding = before;\n       break;\n-      \n+\n     default:\n       sorry (\"`%s' not supported by dump_type_prefix\",\n \t     tree_code_name[(int) TREE_CODE (t)]);\n@@ -865,7 +863,7 @@ dump_type_suffix (t, flags)\n       OB_PUTC (']');\n       dump_type_suffix (TREE_TYPE (t), flags);\n       break;\n-      \n+\n     case ENUMERAL_TYPE:\n     case IDENTIFIER_NODE:\n     case INTEGER_TYPE:\n@@ -944,7 +942,7 @@ dump_global_iord (t)\n     OB_PUTS (\"destructors\");\n   else\n     my_friendly_abort (352);\n-  \n+\n   OB_PUTS (\" for \");\n   OB_PUTCP (input_filename);\n   OB_PUTC (')');\n@@ -999,11 +997,11 @@ dump_decl (t, flags)\n       }\n       if (flags & TS_DECORATE)\n \tOB_PUTS (\"typedef \");\n-      dump_simple_decl (t, DECL_ORIGINAL_TYPE (t) \n+      dump_simple_decl (t, DECL_ORIGINAL_TYPE (t)\n \t\t\t? DECL_ORIGINAL_TYPE (t) : TREE_TYPE (t),\n \t                flags);\n       break;\n-      \n+\n     case VAR_DECL:\n       if (DECL_NAME (t) && VTABLE_NAME_P (DECL_NAME (t)))\n \t{\n@@ -1040,7 +1038,7 @@ dump_decl (t, flags)\n       dump_decl (TREE_OPERAND (t, 0), flags & ~TS_DECL_TYPE);\n       OB_PUTS (\"::\");\n       dump_decl (TREE_OPERAND (t, 1), flags);\n-      break;      \n+      break;\n \n     case ARRAY_REF:\n       dump_decl (TREE_OPERAND (t, 0), flags);\n@@ -1172,17 +1170,17 @@ dump_template_decl (t, flags)\n {\n   tree orig_parms = DECL_TEMPLATE_PARMS (t);\n   tree parms;\n-  int i; \n-  \n+  int i;\n+\n   if (flags & TS_TEMPLATE_PREFIX)\n     {\n-      for (parms = orig_parms = nreverse (orig_parms); \n+      for (parms = orig_parms = nreverse (orig_parms);\n            parms;\n            parms = TREE_CHAIN (parms))\n         {\n \t  tree inner_parms = INNERMOST_TEMPLATE_PARMS (parms);\n           int len = TREE_VEC_LENGTH (inner_parms);\n-          \n+\n           OB_PUTS (\"template <\");\n           for (i = 0; i < len; i++)\n             {\n@@ -1270,7 +1268,7 @@ dump_function_decl (t, flags)\n     OB_PUTS (\"static \");\n   else if (TYPE_POLYMORPHIC_P (t))\n     OB_PUTS (\"virtual \");\n-  \n+\n   /* Print the return type?  */\n   if (show_return)\n     show_return = !DECL_CONV_FN_P (t)  && !DECL_CONSTRUCTOR_P (t)\n@@ -1291,26 +1289,26 @@ dump_function_decl (t, flags)\n     dump_scope (CP_DECL_CONTEXT (t), flags);\n \n   dump_function_name (t, flags);\n-  \n+\n   if (!(flags & TS_DECL_TYPE))\n     return;\n   if (TREE_CODE (fntype) == METHOD_TYPE && parmtypes)\n     /* Skip \"this\" parameter.  */\n     parmtypes = TREE_CHAIN (parmtypes);\n-    \n+\n   /* Skip past the \"in_charge\" parameter.  */\n   if (DECL_HAS_IN_CHARGE_PARM_P (t))\n     parmtypes = TREE_CHAIN (parmtypes);\n-  \n+\n   dump_parameters (parmtypes, flags);\n-  \n+\n   if (show_return)\n     dump_type_suffix (TREE_TYPE (fntype), flags);\n \n   if (TREE_CODE (fntype) == METHOD_TYPE)\n     dump_qualifiers (TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (fntype))),\n \t\t     before);\n-  \n+\n   if (flags & TS_FUNC_THROW)\n     dump_exception_spec (TYPE_RAISES_EXCEPTIONS (fntype), flags);\n \n@@ -1347,7 +1345,7 @@ dump_parameters (parmtypes, flags)\n           break;\n         }\n       dump_type (TREE_VALUE (parmtypes), flags);\n-      \n+\n       if ((flags & TS_PARM_DEFAULTS) && TREE_PURPOSE (parmtypes))\n         {\n           OB_PUTS (\" = \");\n@@ -1414,7 +1412,7 @@ dump_function_name (t, flags)\n \n   if (DECL_LANG_SPECIFIC (t) && DECL_TEMPLATE_INFO (t)\n       && !DECL_FRIEND_PSEUDO_TEMPLATE_INSTANTIATION (t)\n-      && (DECL_TEMPLATE_SPECIALIZATION (t) \n+      && (DECL_TEMPLATE_SPECIALIZATION (t)\n \t  || TREE_CODE (DECL_TI_TEMPLATE (t)) != TEMPLATE_DECL\n \t  || DECL_TEMPLATE_SPECIALIZATION (DECL_TI_TEMPLATE (t))\n \t  || PRIMARY_TEMPLATE_P (DECL_TI_TEMPLATE (t))))\n@@ -1434,7 +1432,7 @@ dump_template_parms (info, primary, flags)\n      enum tree_string_flags flags;\n {\n   tree args = info ? TI_ARGS (info) : NULL_TREE;\n-  \n+\n   if (primary && flags & TS_TEMPLATE_PLAIN)\n     return;\n   flags &= ~(TS_AGGR_TAGS | TS_TEMPLATE_PLAIN);\n@@ -1447,13 +1445,13 @@ dump_template_parms (info, primary, flags)\n       int len = 0;\n       int ix = 0;\n       int need_comma = 0;\n-      \n+\n       if (TREE_CODE (args) == TREE_VEC)\n         {\n           if (TREE_VEC_LENGTH (args) > 0\n-    \t      && TREE_CODE (TREE_VEC_ELT (args, 0)) == TREE_VEC)\n-    \t    args = TREE_VEC_ELT (args, TREE_VEC_LENGTH (args) - 1);\n-          \n+\t      && TREE_CODE (TREE_VEC_ELT (args, 0)) == TREE_VEC)\n+\t    args = TREE_VEC_ELT (args, TREE_VEC_LENGTH (args) - 1);\n+\n           len = TREE_VEC_LENGTH (args);\n         }\n       else if (TREE_CODE (args) == TREE_LIST)\n@@ -1473,7 +1471,7 @@ dump_template_parms (info, primary, flags)\n             }\n           if (need_comma)\n             OB_PUTS (\", \");\n-              \n+\n           if (!arg)\n             OB_PUTS (\"{template parameter error}\");\n           else\n@@ -1486,17 +1484,17 @@ dump_template_parms (info, primary, flags)\n       tree tpl = TI_TEMPLATE (info);\n       tree parms = DECL_TEMPLATE_PARMS (tpl);\n       int len, ix;\n-      \n+\n       parms = TREE_CODE (parms) == TREE_LIST ? TREE_VALUE (parms) : NULL_TREE;\n       len = parms ? TREE_VEC_LENGTH (parms) : 0;\n-      \n+\n       for (ix = 0; ix != len; ix++)\n         {\n           tree parm = TREE_VALUE (TREE_VEC_ELT (parms, ix));\n \n           if (ix)\n             OB_PUTS (\", \");\n-          \n+\n           dump_decl (parm, flags & ~TS_DECL_TYPE);\n         }\n     }\n@@ -1595,12 +1593,12 @@ dump_expr (t, flags)\n \tif (TREE_CODE (type) == ENUMERAL_TYPE)\n \t  {\n \t    tree values = TYPE_VALUES (type);\n-\t    \n+\n \t    for (; values;\n \t         values = TREE_CHAIN (values))\n \t      if (tree_int_cst_equal (TREE_VALUE (values), t))\n \t        break;\n-\t    \n+\n \t    if (values)\n \t      OB_PUTID (TREE_PURPOSE (values));\n \t    else\n@@ -1725,7 +1723,7 @@ dump_expr (t, flags)\n     case AGGR_INIT_EXPR:\n       {\n \ttree fn = NULL_TREE;\n-\t\n+\n \tif (TREE_CODE (TREE_OPERAND (t, 0)) == ADDR_EXPR)\n \t  fn = TREE_OPERAND (TREE_OPERAND (t, 0), 0);\n \n@@ -1749,7 +1747,7 @@ dump_expr (t, flags)\n       {\n \ttree fn = TREE_OPERAND (t, 0);\n \ttree args = TREE_OPERAND (t, 1);\n-\t\n+\n \tif (TREE_CODE (fn) == ADDR_EXPR)\n \t  fn = TREE_OPERAND (fn, 0);\n \n@@ -1900,7 +1898,7 @@ dump_expr (t, flags)\n \t  /* An ADDR_EXPR can have reference type.  In that case, we\n \t     shouldn't print the `&' doing so indicates to the user\n \t     that the expression has pointer type.  */\n-\t  || (TREE_TYPE (t) \n+\t  || (TREE_TYPE (t)\n \t      && TREE_CODE (TREE_TYPE (t)) == REFERENCE_TYPE))\n \tdump_expr (TREE_OPERAND (t, 0), flags | TS_EXPR_PARENS);\n       else\n@@ -1954,7 +1952,7 @@ dump_expr (t, flags)\n \n \t  while (TREE_CODE (next) == POINTER_TYPE)\n \t    next = TREE_TYPE (next);\n-\t  \n+\n \t  if (TREE_CODE (next) == FUNCTION_TYPE)\n \t    {\n \t      if (flags & TS_EXPR_PARENS)\n@@ -2006,7 +2004,7 @@ dump_expr (t, flags)\n \t      t = TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (TREE_TYPE (t)));\n \t      t = TYPE_METHOD_BASETYPE (t);\n \t      virtuals = TYPE_BINFO_VIRTUALS (TYPE_MAIN_VARIANT (t));\n-\t      \n+\n \t      n = tree_low_cst (idx, 0) - first_vfun_index (t);\n \n \t      /* Map vtable index back one, to allow for the null pointer to\n@@ -2109,7 +2107,7 @@ dump_expr (t, flags)\n     case ALIGNOF_EXPR:\n       if (TREE_CODE (t) == SIZEOF_EXPR)\n \tOB_PUTS (\"sizeof (\");\n-      else \n+      else\n \t{\n \t  my_friendly_assert (TREE_CODE (t) == ALIGNOF_EXPR, 0);\n \t  OB_PUTS (\"__alignof__ (\");\n@@ -2154,7 +2152,7 @@ dump_expr (t, flags)\n       dump_expr (TREE_OPERAND (t, 1), flags & ~TS_EXPR_PARENS);\n       OB_PUTS (\"} \");\n       break;\n-      \n+\n     case LOOP_EXPR:\n       OB_PUTS (\"while (1) { \");\n       dump_expr (TREE_OPERAND (t, 0), flags & ~TS_EXPR_PARENS);\n@@ -2173,7 +2171,7 @@ dump_expr (t, flags)\n \t  OB_PUTID (DECL_NAME (TREE_VALUE (t)));\n \t  break;\n \t}\n-      /* else fall through */\t\n+      /* else fall through */\n \n       /*  This list is incomplete, but should suffice for now.\n \t  It is very important that `sorry' does not call\n@@ -2272,9 +2270,9 @@ context_as_string (context, flags)\n      enum tree_string_flags flags;\n {\n   OB_INIT ();\n-  \n+\n   dump_scope (context, flags);\n-  \n+\n   OB_FINISH ();\n \n   return (char *)obstack_base (&scratch_obstack);\n@@ -2365,7 +2363,7 @@ decl_to_string (decl, verbose)\n   else if (TREE_CODE (decl) == FUNCTION_DECL)\n     flags |= TS_DECL_TYPE | TS_FUNC_NORETURN;\n   flags |= TS_TEMPLATE_PREFIX;\n-  \n+\n   OB_INIT ();\n \n   dump_decl (decl, flags);\n@@ -2395,14 +2393,14 @@ fndecl_to_string (fndecl, verbose)\n      int verbose;\n {\n   enum tree_string_flags flags;\n-  \n+\n   flags = TS_FUNC_THROW | TS_DECL_TYPE;\n   if (verbose)\n     flags |= TS_PARM_DEFAULTS;\n   OB_INIT ();\n \n   dump_decl (fndecl, flags);\n-  \n+\n   OB_FINISH ();\n \n   return (char *)obstack_base (&scratch_obstack);\n@@ -2470,12 +2468,12 @@ type_to_string (typ, verbose)\n      int verbose;\n {\n   enum tree_string_flags flags;\n-  \n+\n   flags = 0;\n   if (verbose)\n     flags |= TS_AGGR_TAGS;\n   flags |= TS_TEMPLATE_PREFIX;\n-  \n+\n   OB_INIT ();\n \n   dump_type (typ, flags);\n@@ -2504,7 +2502,7 @@ args_to_string (p, verbose)\n   enum tree_string_flags flags = 0;\n   if (verbose)\n     flags |= TS_AGGR_TAGS;\n-  \n+\n   if (p == NULL_TREE)\n     return \"\";\n \n@@ -2590,7 +2588,7 @@ cp_print_error_function (buffer, dc)\n \n       os = output_buffer_state (buffer);\n       output_set_prefix (buffer, prefix);\n-      \n+\n       if (current_function_decl == NULL)\n         output_add_string (buffer, \"At global scope:\");\n       else\n@@ -2649,17 +2647,17 @@ print_instantiation_full_context (buffer)\n \t{\n \t  if (current_function_decl == TINST_DECL (p))\n \t    /* Avoid redundancy with the the \"In function\" line.  */;\n-\t  else \n+\t  else\n \t    output_verbatim (buffer, \"%s: In instantiation of `%s':\\n\", file,\n                              decl_as_string (TINST_DECL (p),\n                                              TS_DECL_TYPE | TS_FUNC_NORETURN));\n-\t  \n+\n \t  line = TINST_LINE (p);\n \t  file = TINST_FILE (p);\n \t  p = TREE_CHAIN (p);\n \t}\n     }\n-  \n+\n   print_instantiation_partial_context (buffer, p, file, line);\n }\n \n@@ -2739,7 +2737,7 @@ cp_tree_printer (buffer)\n           | TFF_FUNCTION_DEFAULT_ARGUMENTS;\n       print_function_argument_list (buffer, &tfi);\n       break;\n-      \n+\n     case 'D':\n       tree_being_formatted (&tfi) =\n         va_arg (output_buffer_format_args (buffer), tree);\n@@ -2750,30 +2748,30 @@ cp_tree_printer (buffer)\n           | TFF_EXCEPTION_SPECIFICATION | TFF_CHASE_NAMESPACE_ALIAS;\n       print_declaration (buffer, &tfi);\n       break;\n-      \n+\n     case 'E':\n       tree_being_formatted (&tfi) =\n         va_arg (output_buffer_format_args (buffer), tree);\n       if (be_verbose)\n         tree_formatting_flags (&tfi) = TFF_SCOPE;\n       print_expression (buffer, &tfi);\n       break;\n-      \n+\n     case 'F':\n       tree_being_formatted (&tfi) =\n         va_arg (output_buffer_format_args (buffer), tree);\n       if (be_verbose)\n         tree_formatting_flags (&tfi) = TFF_SCOPE | TFF_DECL_SPECIFIERS\n           | TFF_RETURN_TYPE | TFF_FUNCTION_DEFAULT_ARGUMENTS\n-          | TFF_EXCEPTION_SPECIFICATION;          \n+          | TFF_EXCEPTION_SPECIFICATION;\n       print_function_declaration (buffer, &tfi);\n       break;\n-      \n+\n     case 'P':\n       print_function_parameter\n         (buffer, va_arg (output_buffer_format_args (buffer), int));\n       break;\n-      \n+\n     case 'T':\n       tree_being_formatted (&tfi) =\n         va_arg (output_buffer_format_args (buffer), tree);\n@@ -2782,17 +2780,17 @@ cp_tree_printer (buffer)\n           | TFF_RETURN_TYPE | TFF_EXCEPTION_SPECIFICATION;\n       print_type_id (buffer, &tfi);\n       break;\n-      \n+\n     case 'V':\n       tree_being_formatted (&tfi) =\n         va_arg (output_buffer_format_args (buffer), tree);\n       print_cv_qualifier_seq (buffer, &tfi);\n       break;\n-      \n+\n     default:\n       return 0;\n     }\n-  \n+\n   return 1;\n }\n \n@@ -2806,7 +2804,7 @@ print_function_argument_list (buffer, tfi)\n }\n \n /* Print a declaration represented by tree_being_formatted (TFI)\n-   onto buffer.  */   \n+   onto buffer.  */\n static void\n print_declaration (buffer, tfi)\n      output_buffer *buffer __attribute__ ((__unused__));\n@@ -2859,7 +2857,7 @@ print_type_id (buffer, tfi)\n   if (flags & TFF_CHASE_TYPEDEF)\n     tree_being_formatted (tfi) =\n       typedef_original_name (tree_being_formatted (tfi));\n-  \n+\n   /* A type-id is of the form:\n      type-id:\n         type-specifier-seq abstract-declarator(opt)  */\n@@ -2880,7 +2878,7 @@ print_type_id (buffer, tfi)\n     case FUNCTION_TYPE:\n     ptr_mem_fun:\n       print_rest_of_abstract_declarator (buffer, tfi);\n-  \n+\n     default:\n       break;\n     }\n@@ -2940,7 +2938,7 @@ print_type_specifier_seq (buffer, tfi)\n       /* Because the abstract-declarator can modify the type-specifier-seq\n          in a highly non linear manner, we pretty-print its prefix here.\n          The suffix part is handled by print_rest_of_abstract_declarator.  */\n-      \n+\n       /* A RECORD_TYPE is also used to represent a pointer to member\n          function.  */\n     case RECORD_TYPE:\n@@ -2951,7 +2949,7 @@ print_type_specifier_seq (buffer, tfi)\n             TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (t));\n           print_type_id (buffer, tfi);\n           print_whitespace (buffer, tfi);\n-          \n+\n           /* Then the beginning of the abstract-declarator part.  */\n           tree_being_formatted (tfi) =\n             TYPE_METHOD_BASETYPE (TYPE_PTRMEMFUNC_FN_TYPE (t));\n@@ -3001,7 +2999,7 @@ print_type_specifier_seq (buffer, tfi)\n       tree_being_formatted (tfi) = TREE_TYPE (t);\n       print_type_id (buffer, tfi);\n       print_whitespace (buffer, tfi);\n-      \n+\n       /* Then, the containing class.  */\n       tree_being_formatted (tfi) = TYPE_OFFSET_BASETYPE (t);\n       print_nested_name_specifier (buffer, tfi);\n@@ -3191,9 +3189,9 @@ print_rest_of_abstract_declarator (buffer, tfi)\n {\n   tree t = tree_being_formatted (tfi);\n   enum tree_code code = TREE_CODE (t);\n-  \n+\n   /* An abstract-declarator has the form:\n-    \n+\n      abstract-declarator:\n           ptr-operator abstract-declarator(opt)\n           direct-abstract-declarator\n@@ -3310,7 +3308,7 @@ print_rest_of_abstract_declarator (buffer, tfi)\n       sorry_for_unsupported_tree (t);\n       /* fall throught.  */\n     case ERROR_MARK:\n-      break;      \n+      break;\n     }\n }\n \n@@ -3338,7 +3336,7 @@ print_cv_qualifier_seq (buffer, tfi)\n             print_identifier (buffer, qualifier[i]);\n             put_whitespace (tfi) = before;\n           }\n-      \n+\n       if (pad_after)\n         {\n           output_add_space (buffer);\n@@ -3406,7 +3404,7 @@ print_nested_name_specifier (buffer, tfi)\n         }\n     }\n \n-  tree_being_formatted (tfi) = t;             \n+  tree_being_formatted (tfi) = t;\n }\n \n static void"}]}