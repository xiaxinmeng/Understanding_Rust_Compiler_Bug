{"sha": "fbc848cc8cfbbaa3fb117114f9d7692794e98748", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmJjODQ4Y2M4Y2ZiYmFhM2ZiMTE3MTE0ZjlkNzY5Mjc5NGU5ODc0OA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2005-03-10T15:36:42Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2005-03-10T15:36:42Z"}, "message": "value-prof.c (rtl_find_values_to_profile): Use gcc_assert and gcc_unreachable.\n\n\t* value-prof.c (rtl_find_values_to_profile): Use gcc_assert and\n\tgcc_unreachable.\n\t(rtl_register_value_prof_hooks,\n\ttree_value_profile_transformations,\n\ttree_register_value_prof_hooks): Likewise.\n\t* var-tracking.c (stack_adjust_offset_pre_post,\n\tvariable_htab_free, variable_union, dataflow_set_different_2,\n\tcount_uses, variable_was_changed, set_frame_base_location,\n\tset_variable_part, emit_note_insn_var_location, vt_emit_notes,\n\tvt_add_function_parameters): Likewise.\n\t* varasm.c (named_section_real, named_section, make_decl_rtl,\n\tasm_emit_uninitialised, assemble_integer, decode_addr_const,\n\tconst_hash_1, compare_constant, copy_constant, force_const_mem,\n\toutput_constant_pool_2, output_constant_pool_1, output_constant,\n\toutput_constructor, make_decl_one_only, decl_tls_model,\n\tdefault_no_named_section, default_elf_select_section_1,\n\tdefault_unique_section_1): Likewise.\n\t* vec.c (vec_gc_o_reserve, vec_heap_o_reserve): Likewise.\n\t* vmsdbgout.c (addr_const_to_string): Likewise.\n\nFrom-SVN: r96241", "tree": {"sha": "59b4463274c20dfe561aa971f50cc7afcdc8559d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/59b4463274c20dfe561aa971f50cc7afcdc8559d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fbc848cc8cfbbaa3fb117114f9d7692794e98748", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbc848cc8cfbbaa3fb117114f9d7692794e98748", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbc848cc8cfbbaa3fb117114f9d7692794e98748", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbc848cc8cfbbaa3fb117114f9d7692794e98748/comments", "author": null, "committer": null, "parents": [{"sha": "4fd24a758201ca5b0eaee8ee00ba30619cf1f99f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fd24a758201ca5b0eaee8ee00ba30619cf1f99f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fd24a758201ca5b0eaee8ee00ba30619cf1f99f"}], "stats": {"total": 344, "additions": 151, "deletions": 193}, "files": [{"sha": "f2a5c62aef8c025899b67ea181cf717ffbac3270", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbc848cc8cfbbaa3fb117114f9d7692794e98748/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbc848cc8cfbbaa3fb117114f9d7692794e98748/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fbc848cc8cfbbaa3fb117114f9d7692794e98748", "patch": "@@ -1,5 +1,25 @@\n 2005-03-10  Nathan Sidwell  <nathan@codesourcery.com>\n \n+\t* value-prof.c (rtl_find_values_to_profile): Use gcc_assert and\n+\tgcc_unreachable.\n+\t(rtl_register_value_prof_hooks,\n+\ttree_value_profile_transformations,\n+\ttree_register_value_prof_hooks): Likewise.\n+\t* var-tracking.c (stack_adjust_offset_pre_post,\n+\tvariable_htab_free, variable_union, dataflow_set_different_2,\n+\tcount_uses, variable_was_changed, set_frame_base_location,\n+\tset_variable_part, emit_note_insn_var_location, vt_emit_notes,\n+\tvt_add_function_parameters): Likewise.\n+\t* varasm.c (named_section_real, named_section, make_decl_rtl,\n+\tasm_emit_uninitialised, assemble_integer, decode_addr_const,\n+\tconst_hash_1, compare_constant, copy_constant, force_const_mem,\n+\toutput_constant_pool_2, output_constant_pool_1, output_constant,\n+\toutput_constructor, make_decl_one_only, decl_tls_model,\n+\tdefault_no_named_section, default_elf_select_section_1,\n+\tdefault_unique_section_1): Likewise.\n+\t* vec.c (vec_gc_o_reserve, vec_heap_o_reserve): Likewise.\n+\t* vmsdbgout.c (addr_const_to_string): Likewise.\n+\n \tPR c++/20375\n \t* function.c (struct assign_parm_data_one): Remove last_named\n \tfield."}, {"sha": "c56323473cb3ef428b2ed67547009d1a403fc496", "filename": "gcc/value-prof.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbc848cc8cfbbaa3fb117114f9d7692794e98748/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbc848cc8cfbbaa3fb117114f9d7692794e98748/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=fbc848cc8cfbbaa3fb117114f9d7692794e98748", "patch": "@@ -360,7 +360,7 @@ rtl_find_values_to_profile (histogram_values *values)\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n   allocate_reg_info (max_reg_num (), FALSE, FALSE);\n@@ -1032,21 +1032,20 @@ void\n rtl_register_value_prof_hooks (void)\n {\n   value_prof_hooks = &rtl_value_prof_hooks;\n-  if (ir_type ())\n-    abort ();\n+  gcc_assert (!ir_type ());\n }\n \f\n /* Tree-based versions are stubs for now.  */\n static void\n tree_find_values_to_profile (histogram_values *values ATTRIBUTE_UNUSED)\n {\n-  abort ();\n+  gcc_unreachable ();\n }\n \n static bool\n tree_value_profile_transformations (void)\n {\n-  abort ();\n+  gcc_unreachable ();\n }\n \n static struct value_prof_hooks tree_value_prof_hooks = {\n@@ -1058,8 +1057,7 @@ void\n tree_register_value_prof_hooks (void)\n {\n   value_prof_hooks = &tree_value_prof_hooks;\n-  if (!ir_type ())\n-    abort ();\n+  gcc_assert (ir_type ());\n }\n \f\n /* IR-independent entry points.  */"}, {"sha": "a6a9c15d79e122b1d66b91fb9154b36529ae9f2d", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 24, "deletions": 70, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbc848cc8cfbbaa3fb117114f9d7692794e98748/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbc848cc8cfbbaa3fb117114f9d7692794e98748/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=fbc848cc8cfbbaa3fb117114f9d7692794e98748", "patch": "@@ -387,9 +387,9 @@ stack_adjust_offset_pre_post (rtx pattern, HOST_WIDE_INT *pre,\n \t    {\n \t      rtx val = XEXP (XEXP (src, 1), 1);\n \t      /* We handle only adjustments by constant amount.  */\n-\t      if (GET_CODE (XEXP (src, 1)) != PLUS ||\n-\t\t  GET_CODE (val) != CONST_INT)\n-\t\tabort ();\n+\t      gcc_assert (GET_CODE (XEXP (src, 1)) == PLUS &&\n+\t\t\t  GET_CODE (val) == CONST_INT);\n+\t      \n \t      if (code == PRE_MODIFY)\n \t\t*pre -= INTVAL (val);\n \t      else\n@@ -639,10 +639,7 @@ variable_htab_free (void *elem)\n   variable var = (variable) elem;\n   location_chain node, next;\n \n-#ifdef ENABLE_CHECKING\n-  if (var->refcount <= 0)\n-    abort ();\n-#endif\n+  gcc_assert (var->refcount > 0);\n \n   var->refcount--;\n   if (var->refcount > 0)\n@@ -1019,22 +1016,14 @@ variable_union (void **slot, void *data)\n \t a copy of the variable.  */\n       for (k = 0; k < src->n_var_parts; k++)\n \t{\n+\t  gcc_assert (!src->var_part[k].loc_chain\n+\t\t      == !src->var_part[k].cur_loc);\n \t  if (src->var_part[k].loc_chain)\n \t    {\n-#ifdef ENABLE_CHECKING\n-\t      if (src->var_part[k].cur_loc == NULL)\n-\t\tabort ();\n-#endif\n+\t      gcc_assert (src->var_part[k].cur_loc);\n \t      if (src->var_part[k].cur_loc != src->var_part[k].loc_chain->loc)\n \t\tbreak;\n \t    }\n-#ifdef ENABLE_CHECKING\n-\t  else\n-\t    {\n-\t      if (src->var_part[k].cur_loc != NULL)\n-\t\tabort ();\n-\t    }\n-#endif\n \t}\n       if (k < src->n_var_parts)\n \tunshare_variable (set, src);\n@@ -1047,10 +1036,7 @@ variable_union (void **slot, void *data)\n   else\n     dst = *dstp;\n \n-#ifdef ENABLE_CHECKING\n-  if (src->n_var_parts == 0)\n-    abort ();\n-#endif\n+  gcc_assert (src->n_var_parts);\n \n   /* Count the number of location parts, result is K.  */\n   for (i = 0, j = 0, k = 0;\n@@ -1068,12 +1054,10 @@ variable_union (void **slot, void *data)\n     }\n   k += src->n_var_parts - i;\n   k += dst->n_var_parts - j;\n-#ifdef ENABLE_CHECKING\n+\n   /* We track only variables whose size is <= MAX_VAR_PARTS bytes\n      thus there are at most MAX_VAR_PARTS different offsets.  */\n-  if (k > MAX_VAR_PARTS)\n-    abort ();\n-#endif\n+  gcc_assert (k <= MAX_VAR_PARTS);\n \n   if (dst->refcount > 1 && dst->n_var_parts != k)\n     dst = unshare_variable (set, dst);\n@@ -1356,12 +1340,9 @@ dataflow_set_different_2 (void **slot, void *data)\n       return 0;\n     }\n \n-#ifdef ENABLE_CHECKING\n   /* If both variables are defined they have been already checked for\n      equivalence.  */\n-  if (variable_different_p (var1, var2, false))\n-    abort ();\n-#endif\n+  gcc_assert (!variable_different_p (var1, var2, false));\n \n   /* Continue traversing the hash table.  */\n   return 1;\n@@ -1517,17 +1498,14 @@ count_uses (rtx *loc, void *insn)\n \n   if (REG_P (*loc))\n     {\n-#ifdef ENABLE_CHECKING\n-\tif (REGNO (*loc) >= FIRST_PSEUDO_REGISTER)\n-\t  abort ();\n-#endif\n-\tVTI (bb)->n_mos++;\n+      gcc_assert (REGNO (*loc) < FIRST_PSEUDO_REGISTER);\n+      VTI (bb)->n_mos++;\n     }\n   else if (MEM_P (*loc)\n \t   && MEM_EXPR (*loc)\n \t   && track_expr_p (MEM_EXPR (*loc)))\n     {\n-\t  VTI (bb)->n_mos++;\n+      VTI (bb)->n_mos++;\n     }\n \n   return 0;\n@@ -1922,10 +1900,7 @@ variable_was_changed (variable var, htab_t htab)\n     }\n   else\n     {\n-#ifdef ENABLE_CHECKING\n-      if (!htab)\n-\tabort ();\n-#endif\n+      gcc_assert (htab);\n       if (var->n_var_parts == 0)\n \t{\n \t  void **slot = htab_find_slot_with_hash (htab, var->decl, hash,\n@@ -1947,16 +1922,10 @@ set_frame_base_location (dataflow_set *set, rtx loc)\n   \n   var = htab_find_with_hash (set->vars, frame_base_decl,\n \t\t\t     VARIABLE_HASH_VAL (frame_base_decl));\n-#ifdef ENABLE_CHECKING\n-  if (!var)\n-    abort ();\n-  if (var->n_var_parts != 1)\n-    abort ();\n-  if (var->var_part[0].offset != 0)\n-    abort ();\n-  if (!var->var_part[0].loc_chain)\n-    abort ();\n-#endif\n+  gcc_assert (var);\n+  gcc_assert (var->n_var_parts == 1);\n+  gcc_assert (!var->var_part[0].offset);\n+  gcc_assert (var->var_part[0].loc_chain);\n \n   /* If frame_base_decl is shared unshare it first.  */\n   if (var->refcount > 1)\n@@ -2040,12 +2009,9 @@ set_variable_part (dataflow_set *set, rtx loc, tree decl, HOST_WIDE_INT offset)\n \t  if (var->refcount > 1)\n \t    var = unshare_variable (set, var);\n \n-#ifdef ENABLE_CHECKING\n \t  /* We track only variables whose size is <= MAX_VAR_PARTS bytes\n \t     thus there are at most MAX_VAR_PARTS different offsets.  */\n-\t  if (var->n_var_parts >= MAX_VAR_PARTS)\n-\t    abort ();\n-#endif\n+\t  gcc_assert (var->n_var_parts < MAX_VAR_PARTS);\n \n \t  /* We have to move the elements of array starting at index low to the\n \t     next position.  */\n@@ -2207,10 +2173,7 @@ emit_note_insn_var_location (void **varp, void *data)\n   HOST_WIDE_INT last_limit;\n   tree type_size_unit;\n \n-#ifdef ENABLE_CHECKING\n-  if (!var->decl)\n-    abort ();\n-#endif\n+  gcc_assert (var->decl);\n \n   complete = true;\n   last_limit = 0;\n@@ -2447,10 +2410,7 @@ vt_emit_notes (void)\n   dataflow_set *last_out;\n   dataflow_set empty;\n \n-#ifdef ENABLE_CHECKING\n-  if (htab_elements (changed_variables))\n-    abort ();\n-#endif\n+  gcc_assert (!htab_elements (changed_variables));\n \n   /* Enable emitting notes by functions (mainly by set_variable_part and\n      delete_variable_part).  */\n@@ -2536,20 +2496,14 @@ vt_add_function_parameters (void)\n       if (!decl)\n \tcontinue;\n \n-#ifdef ENABLE_CHECKING\n-      if (parm != decl)\n-\tabort ();\n-#endif\n+      gcc_assert (parm == decl);\n \n       incoming = eliminate_regs (incoming, 0, NULL_RTX);\n       out = &VTI (ENTRY_BLOCK_PTR)->out;\n \n       if (REG_P (incoming))\n \t{\n-#ifdef ENABLE_CHECKING\n-\t  if (REGNO (incoming) >= FIRST_PSEUDO_REGISTER)\n-\t    abort ();\n-#endif\n+\t  gcc_assert (REGNO (incoming) < FIRST_PSEUDO_REGISTER);\n \t  attrs_list_insert (&out->regs[REGNO (incoming)],\n \t\t\t     parm, offset, incoming);\n \t  set_variable_part (out, incoming, parm, offset);"}, {"sha": "e226a19dfee4f8d160c558ff454bff9a5ab6ba41", "filename": "gcc/varasm.c", "status": "modified", "additions": 99, "deletions": 111, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbc848cc8cfbbaa3fb117114f9d7692794e98748/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbc848cc8cfbbaa3fb117114f9d7692794e98748/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=fbc848cc8cfbbaa3fb117114f9d7692794e98748", "patch": "@@ -423,8 +423,9 @@ named_section_real (const char *name, unsigned int flags, tree decl)\n {\n   if (in_section != in_named || strcmp (name, in_named_name) != 0)\n     {\n-      if (! set_named_section_flags (name, flags))\n-\tabort ();\n+      bool unchanged = set_named_section_flags (name, flags);\n+\n+      gcc_assert (unchanged);\n \n       targetm.asm_out.named_section (name, flags, decl);\n \n@@ -448,8 +449,7 @@ named_section (tree decl, const char *name, int reloc)\n {\n   unsigned int flags;\n \n-  if (decl != NULL_TREE && !DECL_P (decl))\n-    abort ();\n+  gcc_assert (!decl || DECL_P (decl));\n   if (name == NULL)\n     name = TREE_STRING_POINTER (DECL_SECTION_NAME (decl));\n \n@@ -852,19 +852,19 @@ make_decl_rtl (tree decl)\n   rtx x;\n \n   /* Check that we are not being given an automatic variable.  */\n+  gcc_assert (TREE_CODE (decl) != PARM_DECL\n+\t      && TREE_CODE (decl) != RESULT_DECL);\n+\n   /* A weak alias has TREE_PUBLIC set but not the other bits.  */\n-  if (TREE_CODE (decl) == PARM_DECL\n-      || TREE_CODE (decl) == RESULT_DECL\n-      || (TREE_CODE (decl) == VAR_DECL\n-\t  && !TREE_STATIC (decl)\n-\t  && !TREE_PUBLIC (decl)\n-\t  && !DECL_EXTERNAL (decl)\n-\t  && !DECL_REGISTER (decl)))\n-    abort ();\n+  gcc_assert (TREE_CODE (decl) != VAR_DECL\n+\t      || TREE_STATIC (decl)\n+\t      || TREE_PUBLIC (decl)\n+\t      || DECL_EXTERNAL (decl)\n+\t      || DECL_REGISTER (decl));\n+  \n   /* And that we were not given a type or a label.  */\n-  else if (TREE_CODE (decl) == TYPE_DECL\n-\t   || TREE_CODE (decl) == LABEL_DECL)\n-    abort ();\n+  gcc_assert (TREE_CODE (decl) != TYPE_DECL\n+\t      && TREE_CODE (decl) != LABEL_DECL);\n \n   /* For a duplicate declaration, we can be called twice on the\n      same DECL node.  Don't discard the RTL already made.  */\n@@ -1003,8 +1003,7 @@ make_decl_rtl (tree decl)\n void\n make_var_volatile (tree var)\n {\n-  if (!MEM_P (DECL_RTL (var)))\n-    abort ();\n+  gcc_assert (MEM_P (DECL_RTL (var)));\n \n   MEM_VOLATILE_P (DECL_RTL (var)) = 1;\n }\n@@ -1487,7 +1486,7 @@ asm_emit_uninitialised (tree decl, const char *name,\n       ASM_EMIT_LOCAL (decl, name, size, rounded);\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   return true;\n@@ -2122,13 +2121,11 @@ assemble_integer (rtx x, unsigned int size, unsigned int align, int force)\n \n       /* If we've printed some of it, but not all of it, there's no going\n \t back now.  */\n-      if (i > 0)\n-\tabort ();\n+      gcc_assert (!i);\n     }\n \n-  if (force)\n-    abort ();\n-\n+  gcc_assert (!force);\n+  \n   return false;\n }\n \f\n@@ -2231,11 +2228,10 @@ decode_addr_const (tree exp, struct addr_const *value)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n-  if (!MEM_P (x))\n-    abort ();\n+  gcc_assert (MEM_P (x));\n   x = XEXP (x, 0);\n \n   value->base = x;\n@@ -2318,19 +2314,24 @@ const_hash_1 (const tree exp)\n \tstruct addr_const value;\n \n \tdecode_addr_const (exp, &value);\n-\tif (GET_CODE (value.base) == SYMBOL_REF)\n+\tswitch (GET_CODE (value.base))\n \t  {\n+\t  case SYMBOL_REF:\n \t    /* Don't hash the address of the SYMBOL_REF;\n \t       only use the offset and the symbol name.  */\n \t    hi = value.offset;\n \t    p = XSTR (value.base, 0);\n \t    for (i = 0; p[i] != 0; i++)\n \t      hi = ((hi * 613) + (unsigned) (p[i]));\n+\t    break;\n+\n+\t  case LABEL_REF:\n+\t    hi = value.offset + CODE_LABEL_NUMBER (XEXP (value.base, 0)) * 13;\n+\t    break;\n+\n+\t  default:\n+\t    gcc_unreachable ();\n \t  }\n-\telse if (GET_CODE (value.base) == LABEL_REF)\n-\t  hi = value.offset + CODE_LABEL_NUMBER (XEXP (value.base, 0)) * 13;\n-\telse\n-\t  abort ();\n       }\n       return hi;\n \n@@ -2492,8 +2493,7 @@ compare_constant (const tree t1, const tree t2)\n       }\n     }\n \n-  /* Should not get here.  */\n-  abort ();\n+  gcc_unreachable ();\n }\n \f\n /* Make a copy of the whole tree structure for a constant.  This\n@@ -2551,12 +2551,10 @@ copy_constant (tree exp)\n \n     default:\n       {\n-\ttree t;\n-\tt = lang_hooks.expand_constant (exp);\n-\tif (t != exp)\n-\t  return copy_constant (t);\n-\telse\n-\t  abort ();\n+\ttree t = lang_hooks.expand_constant (exp);\n+\t\n+\tgcc_assert (t == exp);\n+\treturn copy_constant (t);\n       }\n     }\n }\n@@ -3018,8 +3016,7 @@ force_const_mem (enum machine_mode mode, rtx x)\n \n   /* Insert the descriptor into the symbol cross-reference table too.  */\n   slot = htab_find_slot (pool->const_rtx_sym_htab, desc, INSERT);\n-  if (*slot)\n-    abort ();\n+  gcc_assert (!*slot);\n   *slot = desc;\n \n   /* Construct the MEM.  */\n@@ -3100,16 +3097,15 @@ output_constant_pool_2 (enum machine_mode mode, rtx x, unsigned int align)\n   switch (GET_MODE_CLASS (mode))\n     {\n     case MODE_FLOAT:\n-      if (GET_CODE (x) != CONST_DOUBLE)\n-\tabort ();\n-      else\n-\t{\n-\t  REAL_VALUE_TYPE r;\n-\t  REAL_VALUE_FROM_CONST_DOUBLE (r, x);\n-\t  assemble_real (r, mode, align);\n-\t}\n-      break;\n-\n+      {\n+\tREAL_VALUE_TYPE r;\n+\t\n+\tgcc_assert (GET_CODE (x) == CONST_DOUBLE);\n+\tREAL_VALUE_FROM_CONST_DOUBLE (r, x);\n+\tassemble_real (r, mode, align);\n+\tbreak;\n+      }\n+      \n     case MODE_INT:\n     case MODE_PARTIAL_INT:\n       assemble_integer (x, GET_MODE_SIZE (mode), align, 1);\n@@ -3122,8 +3118,7 @@ output_constant_pool_2 (enum machine_mode mode, rtx x, unsigned int align)\n         enum machine_mode submode = GET_MODE_INNER (mode);\n \tunsigned int subalign = MIN (align, GET_MODE_BITSIZE (submode));\n \n-\tif (GET_CODE (x) != CONST_VECTOR)\n-\t  abort ();\n+\tgcc_assert (GET_CODE (x) == CONST_VECTOR);\n \tunits = CONST_VECTOR_NUNITS (x);\n \n \tfor (i = 0; i < units; i++)\n@@ -3135,7 +3130,7 @@ output_constant_pool_2 (enum machine_mode mode, rtx x, unsigned int align)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -3171,13 +3166,9 @@ output_constant_pool_1 (struct constant_descriptor_rtx *desc)\n \n     case LABEL_REF:\n       tmp = XEXP (x, 0);\n-      if (INSN_DELETED_P (tmp)\n-\t  || (NOTE_P (tmp)\n-\t      && NOTE_LINE_NUMBER (tmp) == NOTE_INSN_DELETED))\n-\t{\n-\t  abort ();\n-\t  x = const0_rtx;\n-\t}\n+      gcc_assert (!INSN_DELETED_P (tmp));\n+      gcc_assert (!NOTE_P (tmp)\n+\t\t  || NOTE_LINE_NUMBER (tmp) != NOTE_INSN_DELETED);\n       break;\n \n     default:\n@@ -3743,7 +3734,7 @@ output_constant (tree exp, unsigned HOST_WIDE_INT size, unsigned int align)\n       tree decl = TREE_OPERAND (exp, 0);\n       ASM_OUTPUT_FDESC (asm_out_file, decl, part);\n #else\n-      abort ();\n+      gcc_unreachable ();\n #endif\n       return;\n     }\n@@ -3780,51 +3771,51 @@ output_constant (tree exp, unsigned HOST_WIDE_INT size, unsigned int align)\n \n     case ARRAY_TYPE:\n     case VECTOR_TYPE:\n-      if (TREE_CODE (exp) == CONSTRUCTOR)\n+      switch (TREE_CODE (exp))\n \t{\n+\tcase CONSTRUCTOR:\n \t  output_constructor (exp, size, align);\n \t  return;\n-\t}\n-      else if (TREE_CODE (exp) == STRING_CST)\n-\t{\n+\tcase STRING_CST:\n \t  thissize = MIN ((unsigned HOST_WIDE_INT)TREE_STRING_LENGTH (exp),\n \t\t\t  size);\n \t  assemble_string (TREE_STRING_POINTER (exp), thissize);\n-\t}\n-      else if (TREE_CODE (exp) == VECTOR_CST)\n-\t{\n-\t  int elt_size;\n-\t  tree link;\n-\t  unsigned int nalign;\n-\t  enum machine_mode inner;\n-\n-\t  inner = TYPE_MODE (TREE_TYPE (TREE_TYPE (exp)));\n-\t  nalign = MIN (align, GET_MODE_ALIGNMENT (inner));\n-\n-\t  elt_size = GET_MODE_SIZE (inner);\n+\t  break;\n \n-\t  link = TREE_VECTOR_CST_ELTS (exp);\n-\t  output_constant (TREE_VALUE (link), elt_size, align);\n-\t  while ((link = TREE_CHAIN (link)) != NULL)\n-\t    output_constant (TREE_VALUE (link), elt_size, nalign);\n+\tcase VECTOR_CST:\n+\t  {\n+\t    int elt_size;\n+\t    tree link;\n+\t    unsigned int nalign;\n+\t    enum machine_mode inner;\n+\t    \n+\t    inner = TYPE_MODE (TREE_TYPE (TREE_TYPE (exp)));\n+\t    nalign = MIN (align, GET_MODE_ALIGNMENT (inner));\n+\t    \n+\t    elt_size = GET_MODE_SIZE (inner);\n+\t    \n+\t    link = TREE_VECTOR_CST_ELTS (exp);\n+\t    output_constant (TREE_VALUE (link), elt_size, align);\n+\t    while ((link = TREE_CHAIN (link)) != NULL)\n+\t      output_constant (TREE_VALUE (link), elt_size, nalign);\n+\t    break;\n+\t  }\n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n-      else\n-\tabort ();\n       break;\n \n     case RECORD_TYPE:\n     case UNION_TYPE:\n-      if (TREE_CODE (exp) == CONSTRUCTOR)\n-\toutput_constructor (exp, size, align);\n-      else\n-\tabort ();\n+      gcc_assert (TREE_CODE (exp) == CONSTRUCTOR);\n+      output_constructor (exp, size, align);\n       return;\n \n     case ERROR_MARK:\n       return;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   if (size > thissize)\n@@ -3890,8 +3881,7 @@ output_constructor (tree exp, unsigned HOST_WIDE_INT size,\n   int byte_buffer_in_use = 0;\n   int byte = 0;\n \n-  if (HOST_BITS_PER_WIDE_INT < BITS_PER_UNIT)\n-    abort ();\n+  gcc_assert (HOST_BITS_PER_WIDE_INT >= BITS_PER_UNIT);\n \n   if (TREE_CODE (type) == RECORD_TYPE)\n     field = TYPE_FIELDS (type);\n@@ -4012,8 +4002,7 @@ output_constructor (tree exp, unsigned HOST_WIDE_INT size,\n \t\t  fieldsize = array_size_for_constructor (val);\n \t\t  /* Given a non-empty initialization, this field had\n \t\t     better be last.  */\n-\t\t  if (fieldsize != 0 && TREE_CHAIN (field) != NULL_TREE)\n-\t\t    abort ();\n+\t\t  gcc_assert (!fieldsize || !TREE_CHAIN (field));\n \t\t}\n \t      else if (DECL_SIZE_UNIT (field))\n \t\t{\n@@ -4122,13 +4111,12 @@ output_constructor (tree exp, unsigned HOST_WIDE_INT size,\n \t\t  /* Now get the bits from the appropriate constant word.  */\n \t\t  if (shift < HOST_BITS_PER_WIDE_INT)\n \t\t    value = TREE_INT_CST_LOW (val);\n-\t\t  else if (shift < 2 * HOST_BITS_PER_WIDE_INT)\n+\t\t  else\n \t\t    {\n+\t\t      gcc_assert (shift < 2 * HOST_BITS_PER_WIDE_INT);\n \t\t      value = TREE_INT_CST_HIGH (val);\n \t\t      shift -= HOST_BITS_PER_WIDE_INT;\n \t\t    }\n-\t\t  else\n-\t\t    abort ();\n \n \t\t  /* Get the result. This works only when:\n \t\t     1 <= this_time <= HOST_BITS_PER_WIDE_INT.  */\n@@ -4155,13 +4143,12 @@ output_constructor (tree exp, unsigned HOST_WIDE_INT size,\n \t\t  /* Now get the bits from the appropriate constant word.  */\n \t\t  if (shift < HOST_BITS_PER_WIDE_INT)\n \t\t    value = TREE_INT_CST_LOW (val);\n-\t\t  else if (shift < 2 * HOST_BITS_PER_WIDE_INT)\n+\t\t  else\n \t\t    {\n+\t\t      gcc_assert (shift < 2 * HOST_BITS_PER_WIDE_INT);\n \t\t      value = TREE_INT_CST_HIGH (val);\n \t\t      shift -= HOST_BITS_PER_WIDE_INT;\n \t\t    }\n-\t\t  else\n-\t\t    abort ();\n \n \t\t  /* Get the result. This works only when:\n \t\t     1 <= this_time <= HOST_BITS_PER_WIDE_INT.  */\n@@ -4556,8 +4543,8 @@ supports_one_only (void)\n void\n make_decl_one_only (tree decl)\n {\n-  if (TREE_CODE (decl) != VAR_DECL && TREE_CODE (decl) != FUNCTION_DECL)\n-    abort ();\n+  gcc_assert (TREE_CODE (decl) == VAR_DECL\n+\t      || TREE_CODE (decl) == FUNCTION_DECL);\n \n   TREE_PUBLIC (decl) = 1;\n \n@@ -4571,10 +4558,11 @@ make_decl_one_only (tree decl)\n   else if (TREE_CODE (decl) == VAR_DECL\n       && (DECL_INITIAL (decl) == 0 || DECL_INITIAL (decl) == error_mark_node))\n     DECL_COMMON (decl) = 1;\n-  else if (SUPPORTS_WEAK)\n-    DECL_WEAK (decl) = 1;\n   else\n-    abort ();\n+    {\n+      gcc_assert (SUPPORTS_WEAK);\n+      DECL_WEAK (decl) = 1;\n+    }\n }\n \n void\n@@ -4598,8 +4586,8 @@ decl_tls_model (tree decl)\n   if (attr)\n     {\n       attr = TREE_VALUE (TREE_VALUE (attr));\n-      if (TREE_CODE (attr) != STRING_CST)\n-\tabort ();\n+      gcc_assert (TREE_CODE (attr) == STRING_CST);\n+      \n       if (!strcmp (TREE_STRING_POINTER (attr), \"local-exec\"))\n \tkind = TLS_MODEL_LOCAL_EXEC;\n       else if (!strcmp (TREE_STRING_POINTER (attr), \"initial-exec\"))\n@@ -4609,7 +4597,7 @@ decl_tls_model (tree decl)\n       else if (!strcmp (TREE_STRING_POINTER (attr), \"global-dynamic\"))\n \tkind = TLS_MODEL_GLOBAL_DYNAMIC;\n       else\n-\tabort ();\n+\tgcc_unreachable ();\n       return kind;\n     }\n \n@@ -4710,7 +4698,7 @@ default_no_named_section (const char *name ATTRIBUTE_UNUSED,\n {\n   /* Some object formats don't support named sections at all.  The\n      front-end should already have flagged this as an error.  */\n-  abort ();\n+  gcc_unreachable ();\n }\n \n void\n@@ -5011,7 +4999,7 @@ default_elf_select_section_1 (tree decl, int reloc,\n     {\n     case SECCAT_TEXT:\n       /* We're not supposed to be called on FUNCTION_DECLs.  */\n-      abort ();\n+      gcc_unreachable ();\n     case SECCAT_RODATA:\n       readonly_data_section ();\n       return;\n@@ -5063,7 +5051,7 @@ default_elf_select_section_1 (tree decl, int reloc,\n       sname = \".tbss\";\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   if (!DECL_P (decl))\n@@ -5125,7 +5113,7 @@ default_unique_section_1 (tree decl, int reloc, int shlib)\n       prefix = one_only ? \".gnu.linkonce.tb.\" : \".tbss.\";\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n   plen = strlen (prefix);\n "}, {"sha": "65a482e93c97034c829b63ccf6515296d27ca685", "filename": "gcc/vec.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbc848cc8cfbbaa3fb117114f9d7692794e98748/gcc%2Fvec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbc848cc8cfbbaa3fb117114f9d7692794e98748/gcc%2Fvec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.c?ref=fbc848cc8cfbbaa3fb117114f9d7692794e98748", "patch": "@@ -66,8 +66,7 @@ vec_gc_o_reserve (void *vec, int reserve, size_t vec_offset, size_t elt_size\n   else\n     alloc = 4;\n \n-  if (pfx && pfx->alloc >= alloc)\n-    abort ();\n+  gcc_assert (!pfx || pfx->alloc < alloc);\n   \n   vec = ggc_realloc_stat (vec, vec_offset + alloc * elt_size PASS_MEM_STAT);\n   ((struct vec_prefix *)vec)->alloc = alloc;\n@@ -117,8 +116,7 @@ vec_heap_o_reserve (void *vec, int reserve, size_t vec_offset, size_t elt_size\n   else\n     alloc = 4;\n \n-  if (pfx && pfx->alloc >= alloc)\n-    abort ();\n+  gcc_assert (!pfx || pfx->alloc < alloc);\n   \n   vec = xrealloc (vec, vec_offset + alloc * elt_size);\n   ((struct vec_prefix *)vec)->alloc = alloc;"}, {"sha": "ae19b937034f8dd1ad895f04cd1d0926ce8cd544", "filename": "gcc/vmsdbgout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbc848cc8cfbbaa3fb117114f9d7692794e98748/gcc%2Fvmsdbgout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbc848cc8cfbbaa3fb117114f9d7692794e98748/gcc%2Fvmsdbgout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvmsdbgout.c?ref=fbc848cc8cfbbaa3fb117114f9d7692794e98748", "patch": "@@ -427,7 +427,7 @@ addr_const_to_string (char *str, rtx x)\n   char buf1[256];\n   char buf2[256];\n \n-restart:\n+ restart:\n   str[0] = '\\0';\n   switch (GET_CODE (x))\n     {"}]}