{"sha": "74605a11f3c482656558d332058870d15cc718d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQ2MDVhMTFmM2M0ODI2NTY1NThkMzMyMDU4ODcwZDE1Y2M3MThkNQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2011-05-08T19:14:24Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2011-05-08T19:14:24Z"}, "message": "cgraph.c (cgraph_clone_node): Add call_duplication_hook parameter.\n\n\n\t* cgraph.c (cgraph_clone_node): Add call_duplication_hook parameter.\n\t(cgraph_create_virtual_clone): Call hooks once virtual clone is finished.\n\t* cgraph.h (cgraph_clone_node): Update prototype.\n\t* ipa-cp.c (ipcp_estimate_growth): Use estimate_ipcp_clone_size_and_time.\n\t* ipa-inline-transform.c (clone_inlined_nodes): Update.\n\t* lto-cgraph.c (input_node): Update.\n\t* ipa-inline.c (recursive_inlining): Update.\n\t* ipa-inline.h (estimate_ipcp_clone_size_and_time): New function.\n\t(evaluate_conditions_for_known_args): Break out from ...\n\t(evaluate_conditions_for_edge): ... here.\n\t(evaluate_conditions_for_ipcp_clone): New function.\n\t(inline_node_duplication_hook): Update clone summary based\n\ton parameter map.\n\t(estimate_callee_size_and_time): Rename to ...\n\t(estimate_node_size_and_time): take NODE instead of EDGE;\n\ttake POSSIBLE_TRUTHS as argument.\n\t(estimate_callee_size_and_time): Update.\n\t(estimate_ipcp_clone_size_and_time): New function.\n\t(do_estimate_edge_time): Update.\n\nFrom-SVN: r173551", "tree": {"sha": "bacaa437c56da65959eaf4a81ceee12d963848df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bacaa437c56da65959eaf4a81ceee12d963848df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/74605a11f3c482656558d332058870d15cc718d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74605a11f3c482656558d332058870d15cc718d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74605a11f3c482656558d332058870d15cc718d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74605a11f3c482656558d332058870d15cc718d5/comments", "author": null, "committer": null, "parents": [{"sha": "5c04950727f2a7a0e00c07776a417f24aea7da9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c04950727f2a7a0e00c07776a417f24aea7da9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c04950727f2a7a0e00c07776a417f24aea7da9a"}], "stats": {"total": 349, "additions": 303, "deletions": 46}, "files": [{"sha": "fba19cc3a8e7506cf05d885e198c8f21417cccb7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74605a11f3c482656558d332058870d15cc718d5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74605a11f3c482656558d332058870d15cc718d5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=74605a11f3c482656558d332058870d15cc718d5", "patch": "@@ -1,3 +1,25 @@\n+2011-05-08  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c (cgraph_clone_node): Add call_duplication_hook parameter.\n+\t(cgraph_create_virtual_clone): Call hooks once virtual clone is finished.\n+\t* cgraph.h (cgraph_clone_node): Update prototype.\n+\t* ipa-cp.c (ipcp_estimate_growth): Use estimate_ipcp_clone_size_and_time.\n+\t* ipa-inline-transform.c (clone_inlined_nodes): Update.\n+\t* lto-cgraph.c (input_node): Update.\n+\t* ipa-inline.c (recursive_inlining): Update.\n+\t* ipa-inline.h (estimate_ipcp_clone_size_and_time): New function.\n+\t(evaluate_conditions_for_known_args): Break out from ...\n+\t(evaluate_conditions_for_edge): ... here.\n+\t(evaluate_conditions_for_ipcp_clone): New function.\n+\t(inline_node_duplication_hook): Update clone summary based\n+\ton parameter map.\n+\t(estimate_callee_size_and_time): Rename to ...\n+\t(estimate_node_size_and_time): take NODE instead of EDGE;\n+\ttake POSSIBLE_TRUTHS as argument.\n+\t(estimate_callee_size_and_time): Update.\n+\t(estimate_ipcp_clone_size_and_time): New function.\n+\t(do_estimate_edge_time): Update.\n+\n 2011-05-08  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/48908"}, {"sha": "a6d548239507de415daf6fc177e086a1a538cda3", "filename": "gcc/cgraph.c", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74605a11f3c482656558d332058870d15cc718d5/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74605a11f3c482656558d332058870d15cc718d5/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=74605a11f3c482656558d332058870d15cc718d5", "patch": "@@ -2128,18 +2128,23 @@ cgraph_clone_edge (struct cgraph_edge *e, struct cgraph_node *n,\n   return new_edge;\n }\n \n+\n /* Create node representing clone of N executed COUNT times.  Decrease\n    the execution counts from original node too.\n    The new clone will have decl set to DECL that may or may not be the same\n    as decl of N.\n \n    When UPDATE_ORIGINAL is true, the counts are subtracted from the original\n    function's profile to reflect the fact that part of execution is handled\n-   by node.  */\n+   by node.  \n+   When CALL_DUPLICATOIN_HOOK is true, the ipa passes are acknowledged about\n+   the new clone. Otherwise the caller is responsible for doing so later.  */\n+\n struct cgraph_node *\n cgraph_clone_node (struct cgraph_node *n, tree decl, gcov_type count, int freq,\n \t\t   bool update_original,\n-\t\t   VEC(cgraph_edge_p,heap) *redirect_callers)\n+\t\t   VEC(cgraph_edge_p,heap) *redirect_callers,\n+\t\t   bool call_duplication_hook)\n {\n   struct cgraph_node *new_node = cgraph_create_node_1 ();\n   struct cgraph_edge *e;\n@@ -2202,7 +2207,6 @@ cgraph_clone_node (struct cgraph_node *n, tree decl, gcov_type count, int freq,\n   n->clones = new_node;\n   new_node->clone_of = n;\n \n-  cgraph_call_node_duplication_hooks (n, new_node);\n   if (n->decl != decl)\n     {\n       struct cgraph_node **slot;\n@@ -2221,6 +2225,9 @@ cgraph_clone_node (struct cgraph_node *n, tree decl, gcov_type count, int freq,\n \t  *aslot = new_node;\n \t}\n     }\n+\n+  if (call_duplication_hook)\n+    cgraph_call_node_duplication_hooks (n, new_node);\n   return new_node;\n }\n \n@@ -2287,7 +2294,7 @@ cgraph_create_virtual_clone (struct cgraph_node *old_node,\n \n   new_node = cgraph_clone_node (old_node, new_decl, old_node->count,\n \t\t\t\tCGRAPH_FREQ_BASE, false,\n-\t\t\t\tredirect_callers);\n+\t\t\t\tredirect_callers, false);\n   /* Update the properties.\n      Make clone visible only within this translation unit.  Make sure\n      that is not weak also.\n@@ -2358,6 +2365,8 @@ cgraph_create_virtual_clone (struct cgraph_node *old_node,\n   new_node->lowered = true;\n   new_node->reachable = true;\n \n+  cgraph_call_node_duplication_hooks (old_node, new_node);\n+\n \n   return new_node;\n }"}, {"sha": "8be0354c2e2359d0d9a1b663e0d001506192f324", "filename": "gcc/cgraph.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74605a11f3c482656558d332058870d15cc718d5/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74605a11f3c482656558d332058870d15cc718d5/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=74605a11f3c482656558d332058870d15cc718d5", "patch": "@@ -506,7 +506,8 @@ struct cgraph_edge * cgraph_clone_edge (struct cgraph_edge *,\n \t\t\t\t\tstruct cgraph_node *, gimple,\n \t\t\t\t\tunsigned, gcov_type, int, bool);\n struct cgraph_node * cgraph_clone_node (struct cgraph_node *, tree, gcov_type,\n-\t\t\t\t\tint, bool, VEC(cgraph_edge_p,heap) *);\n+\t\t\t\t\tint, bool, VEC(cgraph_edge_p,heap) *,\n+\t\t\t\t\tbool);\n \n void cgraph_redirect_edge_callee (struct cgraph_edge *, struct cgraph_node *);\n void cgraph_make_edge_direct (struct cgraph_edge *, struct cgraph_node *,"}, {"sha": "834acb101e55e773c3facb6e5b1cb5171e90a75a", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74605a11f3c482656558d332058870d15cc718d5/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74605a11f3c482656558d332058870d15cc718d5/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=74605a11f3c482656558d332058870d15cc718d5", "patch": "@@ -430,6 +430,11 @@ verify_edge_count_and_frequency (struct cgraph_edge *e)\n     }\n   if (gimple_has_body_p (e->caller->decl)\n       && !e->caller->global.inlined_to\n+      /* FIXME: Inline-analysis sets frequency to 0 when edge is optimized out.\n+\t Remove this once edges are actualy removed from the function at that time.  */\n+      && (e->frequency\n+\t  || (inline_edge_summary_vec\n+\t      && !inline_edge_summary (e)->predicate))\n       && (e->frequency\n \t  != compute_call_stmt_bb_frequency (e->caller->decl,\n \t\t\t\t\t     gimple_bb (e->call_stmt))))"}, {"sha": "41046d117ca2bec0bd837295ac2105fc322e66bb", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74605a11f3c482656558d332058870d15cc718d5/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74605a11f3c482656558d332058870d15cc718d5/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=74605a11f3c482656558d332058870d15cc718d5", "patch": "@@ -1102,7 +1102,8 @@ ipcp_estimate_growth (struct cgraph_node *node)\n      call site.  Precise cost is difficult to get, as our size metric counts\n      constants and moves as free.  Generally we are looking for cases that\n      small function is called very many times.  */\n-  growth = inline_summary (node)->self_size\n+  estimate_ipcp_clone_size_and_time (node, &growth, NULL);\n+  growth = growth\n   \t   - removable_args * redirectable_node_callers;\n   if (growth < 0)\n     return 0;"}, {"sha": "86f5f12cc931e9f3a2f67f2d605d5bde0e9f10d4", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 255, "deletions": 37, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74605a11f3c482656558d332058870d15cc718d5/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74605a11f3c482656558d332058870d15cc718d5/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=74605a11f3c482656558d332058870d15cc718d5", "patch": "@@ -473,7 +473,7 @@ account_size_time (struct inline_summary *summary, int size, int time, struct pr\n \n   /* We need to create initial empty unconitional clause, but otherwie\n      we don't need to account empty times and sizes.  */\n-  if (!size && !time && summary->conds)\n+  if (!size && !time && summary->entry)\n     return;\n \n   /* Watch overflow that might result from insane profiles.  */\n@@ -539,6 +539,42 @@ edge_set_predicate (struct cgraph_edge *e, struct predicate *predicate)\n }\n \n \n+/* KNOWN_VALS is partial mapping of parameters of NODE to constant values.\n+   Return clause of possible truths. When INLINE_P is true, assume that\n+   we are inlining.  */\n+\n+static clause_t\n+evaluate_conditions_for_known_args (struct cgraph_node *node,\n+\t\t\t\t    bool inline_p,\n+\t\t\t\t    VEC (tree, heap) *known_vals)\n+{\n+  clause_t clause = inline_p ? 0 : 1 << predicate_not_inlined_condition;\n+  struct inline_summary *info = inline_summary (node);\n+  int i;\n+  struct condition *c;\n+\n+  for (i = 0; VEC_iterate (condition, info->conds, i, c); i++)\n+    {\n+      tree val = VEC_index (tree, known_vals, c->operand_num);\n+      tree res;\n+\n+      if (!val)\n+\t{\n+\t  clause |= 1 << (i + predicate_first_dynamic_condition);\n+\t  continue;\n+\t}\n+      if (c->code == IS_NOT_CONSTANT)\n+\tcontinue;\n+      res = fold_binary_to_constant (c->code, boolean_type_node, val, c->val);\n+      if (res\n+\t  && integer_zerop (res))\n+\tcontinue;\n+      clause |= 1 << (i + predicate_first_dynamic_condition);\n+    }\n+  return clause;\n+}\n+\n+\n /* Work out what conditions might be true at invocation of E.  */\n \n static clause_t\n@@ -557,7 +593,6 @@ evaluate_conditions_for_edge (struct cgraph_edge *e, bool inline_p)\n       struct ipa_edge_args *args = IPA_EDGE_REF (e);\n       int i, count = ipa_get_cs_argument_count (args);\n       struct ipcp_lattice lat;\n-      struct condition *c;\n       VEC (tree, heap) *known_vals = NULL;\n \n       if (e->caller->global.inlined_to)\n@@ -572,24 +607,8 @@ evaluate_conditions_for_edge (struct cgraph_edge *e, bool inline_p)\n \t  if (lat.type == IPA_CONST_VALUE)\n \t    VEC_replace (tree, known_vals, i, lat.constant);\n \t}\n-      for (i = 0; VEC_iterate (condition, info->conds, i, c); i++)\n-\t{\n-\t  tree val = VEC_index (tree, known_vals, c->operand_num);\n-\t  tree res;\n-\n-\t  if (!val)\n-\t    {\n-\t      clause |= 1 << (i + predicate_first_dynamic_condition);\n-\t      continue;\n-\t    }\n-\t  if (c->code == IS_NOT_CONSTANT)\n-\t    continue;\n-\t  res = fold_binary_to_constant (c->code, boolean_type_node, val, c->val);\n-\t  if (res\n-\t      && integer_zerop (res))\n-\t    continue;\n-\t  clause |= 1 << (i + predicate_first_dynamic_condition);\n-\t}\n+      clause = evaluate_conditions_for_known_args (e->callee,\n+\t\t\t\t\t\t   inline_p, known_vals);\n       VEC_free (tree, heap, known_vals);\n     }\n   else\n@@ -600,6 +619,31 @@ evaluate_conditions_for_edge (struct cgraph_edge *e, bool inline_p)\n }\n \n \n+/* Work out what conditions might be true at invocation of NODE\n+   that is (future) ipa-cp clone.  */\n+\n+static clause_t\n+evaluate_conditions_for_ipcp_clone (struct cgraph_node *node)\n+{\n+  struct ipa_node_params *parms_info = IPA_NODE_REF (node);\n+  int i, count = ipa_get_param_count (parms_info);\n+  struct ipcp_lattice *lat;\n+  VEC (tree, heap) *known_vals = NULL;\n+  clause_t clause;\n+\n+  VEC_safe_grow_cleared (tree, heap, known_vals, count);\n+  for (i = 0; i < count; i++)\n+    {\n+      lat = ipa_get_lattice (parms_info, i);\n+      if (lat->type == IPA_CONST_VALUE)\n+\tVEC_replace (tree, known_vals, i, lat->constant);\n+    }\n+  clause = evaluate_conditions_for_known_args (node, false, known_vals);\n+  VEC_free (tree, heap, known_vals);\n+  return clause;\n+}\n+\n+\n /* Allocate the inline summary vector or resize it to cover all cgraph nodes. */\n \n static void\n@@ -661,8 +705,165 @@ inline_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n   info = inline_summary (dst);\n   memcpy (info, inline_summary (src),\n \t  sizeof (struct inline_summary));\n+  /* TODO: as an optimization, we may avoid copying conditions\n+     that are known to be false or true.  */\n   info->conds = VEC_copy (condition, gc, info->conds);\n-  info->entry = VEC_copy (size_time_entry, gc, info->entry);\n+\n+  /* When there are any replacements in the function body, see if we can figure\n+     out that something was optimized out.  */\n+  if (ipa_node_params_vector && dst->clone.tree_map)\n+    {\n+      VEC(size_time_entry,gc) *entry = info->entry;\n+      /* Use SRC parm info since it may not be copied yet.  */\n+      struct ipa_node_params *parms_info = IPA_NODE_REF (src);\n+      VEC (tree, heap) *known_vals = NULL;\n+      int count = ipa_get_param_count (parms_info);\n+      int i,j;\n+      clause_t possible_truths;\n+      struct predicate true_pred = true_predicate ();\n+      size_time_entry *e;\n+      int optimized_out_size = 0;\n+      gcov_type optimized_out_time = 0;\n+      bool inlined_to_p = false;\n+      struct cgraph_edge *edge;\n+\n+      info->entry = false;\n+      VEC_safe_grow_cleared (tree, heap, known_vals, count);\n+      for (i = 0; i < count; i++)\n+        {\n+\t  tree t = ipa_get_param (parms_info, i);\n+\t  struct ipa_replace_map *r;\n+\n+\t  for (j = 0;\n+\t       VEC_iterate (ipa_replace_map_p, dst->clone.tree_map, j, r);\n+\t       j++)\n+\t    {\n+\t      if (r->old_tree == t\n+\t\t  && r->replace_p\n+\t\t  && !r->ref_p)\n+\t\t{\n+\t\t  VEC_replace (tree, known_vals, i, r->new_tree);\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      possible_truths = evaluate_conditions_for_known_args (dst,\n+\t\t\t\t\t\t\t    false, known_vals);\n+      VEC_free (tree, heap, known_vals);\n+\n+      account_size_time (info, 0, 0, &true_pred);\n+\n+      /* Remap size_time vectors.\n+\t Simplify the predicate by prunning out alternatives that are known\n+\t to be false.\n+\t TODO: as on optimization, we can also eliminate conditions known to be true.  */\n+      for (i = 0; VEC_iterate (size_time_entry, entry, i, e); i++)\n+\t{\n+\t  struct predicate new_predicate = true_predicate ();\n+\t  for (j = 0; e->predicate.clause[j]; j++)\n+\t    if (!(possible_truths & e->predicate.clause[j]))\n+\t      {\n+\t\tnew_predicate = false_predicate ();\n+\t\tbreak;\n+\t      }\n+\t    else\n+\t      add_clause (&new_predicate,\n+\t\t\t  possible_truths & e->predicate.clause[j]);\n+\t  if (false_predicate_p (&new_predicate))\n+\t    {\n+\t      optimized_out_size += e->size;\n+\t      optimized_out_time += e->time;\n+\t    }\n+\t  else\n+\t    account_size_time (info, e->size, e->time, &new_predicate);\n+\t}\n+\n+      /* Remap edge predicates with the same simplificaiton as above.  */\n+      for (edge = dst->callees; edge; edge = edge->next_callee)\n+\t{\n+\t  struct predicate new_predicate = true_predicate ();\n+\t  struct inline_edge_summary *es = inline_edge_summary (edge);\n+\n+\t  if (!edge->inline_failed)\n+\t    inlined_to_p = true;\n+\t  if (!es->predicate)\n+\t    continue;\n+\t  for (j = 0; es->predicate->clause[j]; j++)\n+\t    if (!(possible_truths & es->predicate->clause[j]))\n+\t      {\n+\t\tnew_predicate = false_predicate ();\n+\t\tbreak;\n+\t      }\n+\t    else\n+\t      add_clause (&new_predicate,\n+\t\t\t  possible_truths & es->predicate->clause[j]);\n+\t  if (false_predicate_p (&new_predicate)\n+\t      && !false_predicate_p (es->predicate))\n+\t    {\n+\t      optimized_out_size += es->call_stmt_size * INLINE_SIZE_SCALE;\n+\t      optimized_out_time += (es->call_stmt_time\n+\t\t\t\t     * (INLINE_TIME_SCALE / CGRAPH_FREQ_BASE)\n+\t\t\t\t     * edge->frequency);\n+\t      edge->frequency = 0;\n+\t    }\n+\t  *es->predicate = new_predicate;\n+\t}\n+\n+      /* Remap indirect edge predicates with the same simplificaiton as above.  */\n+      for (edge = dst->indirect_calls; edge; edge = edge->next_callee)\n+\t{\n+\t  struct predicate new_predicate = true_predicate ();\n+\t  struct inline_edge_summary *es = inline_edge_summary (edge);\n+\n+\t  if (!edge->inline_failed)\n+\t    inlined_to_p = true;\n+\t  if (!es->predicate)\n+\t    continue;\n+\t  for (j = 0; es->predicate->clause[j]; j++)\n+\t    if (!(possible_truths & es->predicate->clause[j]))\n+\t      {\n+\t\tnew_predicate = false_predicate ();\n+\t\tbreak;\n+\t      }\n+\t    else\n+\t      add_clause (&new_predicate,\n+\t\t\t  possible_truths & es->predicate->clause[j]);\n+\t  if (false_predicate_p (&new_predicate)\n+\t      && !false_predicate_p (es->predicate))\n+\t    {\n+\t      optimized_out_size += es->call_stmt_size * INLINE_SIZE_SCALE;\n+\t      optimized_out_time += (es->call_stmt_time\n+\t\t\t\t     * (INLINE_TIME_SCALE / CGRAPH_FREQ_BASE)\n+\t\t\t\t     * edge->frequency);\n+\t      edge->frequency = 0;\n+\t    }\n+\t  *es->predicate = new_predicate;\n+\t}\n+\n+      /* If inliner or someone after inliner will ever start producing\n+\t non-trivial clones, we will get trouble with lack of information\n+\t about updating self sizes, because size vectors already contains\n+\t sizes of the calees.  */\n+      gcc_assert (!inlined_to_p \n+\t\t  || (!optimized_out_size && !optimized_out_time));\n+\n+      info->size -= optimized_out_size / INLINE_SIZE_SCALE;\n+      info->self_size -= optimized_out_size / INLINE_SIZE_SCALE;\n+      gcc_assert (info->size > 0);\n+      gcc_assert (info->self_size > 0);\n+\n+      optimized_out_time /= INLINE_TIME_SCALE;\n+      if (optimized_out_time > MAX_TIME)\n+\toptimized_out_time = MAX_TIME;\n+      info->time -= optimized_out_time;\n+      info->self_time -= optimized_out_time;\n+      if (info->time < 0)\n+\tinfo->time = 0;\n+      if (info->self_time < 0)\n+\tinfo->self_time = 0;\n+    }\n+  else\n+    info->entry = VEC_copy (size_time_entry, gc, info->entry);\n }\n \n \n@@ -1565,17 +1766,15 @@ estimate_calls_size_and_time (struct cgraph_node *node, int *size, int *time,\n }\n \n \n-/* Estimate size and time needed to execute callee of EDGE assuming\n-   that parameters known to be constant at caller of EDGE are\n-   propagated.  If INLINE_P is true, it is assumed that call will\n-   be inlined.  */\n+/* Estimate size and time needed to execute NODE assuming\n+   POSSIBLE_TRUTHS clause. */\n \n static void\n-estimate_callee_size_and_time (struct cgraph_edge *edge, bool inline_p,\n-\t\t       \t       int *ret_size, int *ret_time)\n+estimate_node_size_and_time (struct cgraph_node *node,\n+\t\t\t     clause_t possible_truths,\n+\t\t       \t     int *ret_size, int *ret_time)\n {\n-  struct inline_summary *info = inline_summary (edge->callee);\n-  clause_t clause = evaluate_conditions_for_edge (edge, inline_p);\n+  struct inline_summary *info = inline_summary (node);\n   size_time_entry *e;\n   int size = 0, time = 0;\n   int i;\n@@ -1584,15 +1783,15 @@ estimate_callee_size_and_time (struct cgraph_edge *edge, bool inline_p,\n       && (dump_flags & TDF_DETAILS))\n     {\n       bool found = false;\n-      fprintf (dump_file, \"   Estimating callee body: %s/%i\\n\"\n+      fprintf (dump_file, \"   Estimating body: %s/%i\\n\"\n \t\t\t  \"   Known to be false: \",\n-\t       cgraph_node_name (edge->callee),\n-\t       edge->callee->uid);\n+\t       cgraph_node_name (node),\n+\t       node->uid);\n \n       for (i = predicate_not_inlined_condition;\n \t   i < (predicate_first_dynamic_condition\n \t\t+ (int)VEC_length (condition, info->conds)); i++)\n-\tif (!(clause & (1 << i)))\n+\tif (!(possible_truths & (1 << i)))\n \t  {\n \t    if (found)\n \t      fprintf (dump_file, \", \");\n@@ -1602,13 +1801,13 @@ estimate_callee_size_and_time (struct cgraph_edge *edge, bool inline_p,\n     }\n \n   for (i = 0; VEC_iterate (size_time_entry, info->entry, i, e); i++)\n-    if (evaluate_predicate (&e->predicate, clause))\n+    if (evaluate_predicate (&e->predicate, possible_truths))\n       time += e->time, size += e->size;\n \n   if (time > MAX_TIME * INLINE_TIME_SCALE)\n     time = MAX_TIME * INLINE_TIME_SCALE;\n \n-  estimate_calls_size_and_time (edge->callee, &size, &time, clause);\n+  estimate_calls_size_and_time (node, &size, &time, possible_truths);\n   time = (time + INLINE_TIME_SCALE / 2) / INLINE_TIME_SCALE;\n   size = (size + INLINE_SIZE_SCALE / 2) / INLINE_SIZE_SCALE;\n \n@@ -1624,6 +1823,21 @@ estimate_callee_size_and_time (struct cgraph_edge *edge, bool inline_p,\n }\n \n \n+/* Estimate size and time needed to execute callee of EDGE assuming\n+   that parameters known to be constant at caller of EDGE are\n+   propagated.  If INLINE_P is true, it is assumed that call will\n+   be inlined.  */\n+\n+void\n+estimate_ipcp_clone_size_and_time (struct cgraph_node *node,\n+\t\t                   int *ret_size, int *ret_time)\n+{\n+  estimate_node_size_and_time (node,\n+\t\t\t       evaluate_conditions_for_ipcp_clone (node),\n+\t\t\t       ret_size, ret_time);\n+}\n+\n+\n /* Translate all conditions from callee representation into caller representation and\n    symbolically evaluate predicate P into new predicate.\n \n@@ -1872,7 +2086,9 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n   struct inline_edge_summary *es = inline_edge_summary (edge);\n \n   gcc_checking_assert (edge->inline_failed);\n-  estimate_callee_size_and_time (edge, true, &size, &time);\n+  estimate_node_size_and_time (edge->callee,\n+\t\t\t       evaluate_conditions_for_edge (edge, true),\n+\t\t\t       &size, &time);\n \n   ret = (((gcov_type)time - es->call_stmt_time) * edge->frequency\n \t + CGRAPH_FREQ_BASE / 2) / CGRAPH_FREQ_BASE;\n@@ -1921,7 +2137,9 @@ do_estimate_edge_growth (struct cgraph_edge *edge)\n \n   /* Early inliner runs without caching, go ahead and do the dirty work.  */\n   gcc_checking_assert (edge->inline_failed);\n-  estimate_callee_size_and_time (edge, true, &size, NULL);\n+  estimate_node_size_and_time (edge->callee,\n+\t\t\t       evaluate_conditions_for_edge (edge, true),\n+\t\t\t       &size, NULL);\n   gcc_checking_assert (inline_edge_summary (edge)->call_stmt_size);\n   return size - inline_edge_summary (edge)->call_stmt_size;\n }"}, {"sha": "85a47f8a018d4714f60b15a10f4a3e102d58480f", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74605a11f3c482656558d332058870d15cc718d5/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74605a11f3c482656558d332058870d15cc718d5/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=74605a11f3c482656558d332058870d15cc718d5", "patch": "@@ -133,7 +133,7 @@ clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n \t  struct cgraph_node *n;\n \t  n = cgraph_clone_node (e->callee, e->callee->decl,\n \t\t\t\t e->count, e->frequency,\n-\t\t\t\t update_original, NULL);\n+\t\t\t\t update_original, NULL, true);\n \t  cgraph_redirect_edge_callee (e, n);\n \t}\n     }"}, {"sha": "0718334e84ec8dadd7b3271a471e8fcdf89c37c3", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74605a11f3c482656558d332058870d15cc718d5/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74605a11f3c482656558d332058870d15cc718d5/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=74605a11f3c482656558d332058870d15cc718d5", "patch": "@@ -1174,7 +1174,7 @@ recursive_inlining (struct cgraph_edge *edge,\n \t  /* We need original clone to copy around.  */\n \t  master_clone = cgraph_clone_node (node, node->decl,\n \t\t\t\t\t    node->count, CGRAPH_FREQ_BASE,\n-\t\t\t\t\t    false, NULL);\n+\t\t\t\t\t    false, NULL, true);\n \t  for (e = master_clone->callees; e; e = e->next_callee)\n \t    if (!e->inline_failed)\n \t      clone_inlined_nodes (e, true, false, NULL);"}, {"sha": "c9f881ecea7c4374e366965ca1e29a3f2ae57af2", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74605a11f3c482656558d332058870d15cc718d5/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74605a11f3c482656558d332058870d15cc718d5/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=74605a11f3c482656558d332058870d15cc718d5", "patch": "@@ -149,6 +149,7 @@ void inline_free_summary (void);\n void initialize_inline_failed (struct cgraph_edge *);\n int estimate_time_after_inlining (struct cgraph_node *, struct cgraph_edge *);\n int estimate_size_after_inlining (struct cgraph_node *, struct cgraph_edge *);\n+void estimate_ipcp_clone_size_and_time (struct cgraph_node *, int *, int *);\n int do_estimate_growth (struct cgraph_node *);\n void inline_merge_summary (struct cgraph_edge *edge);\n int do_estimate_edge_growth (struct cgraph_edge *edge);"}, {"sha": "22f44ad978392ad31c34e3f1f70abaad7618be9b", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74605a11f3c482656558d332058870d15cc718d5/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74605a11f3c482656558d332058870d15cc718d5/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=74605a11f3c482656558d332058870d15cc718d5", "patch": "@@ -999,7 +999,7 @@ input_node (struct lto_file_decl_data *file_data,\n   if (clone_ref != LCC_NOT_FOUND)\n     {\n       node = cgraph_clone_node (VEC_index (cgraph_node_ptr, nodes, clone_ref), fn_decl,\n-\t\t\t\t0, CGRAPH_FREQ_BASE, false, NULL);\n+\t\t\t\t0, CGRAPH_FREQ_BASE, false, NULL, false);\n     }\n   else\n     node = cgraph_get_create_node (fn_decl);"}]}