{"sha": "2b8fe4a03fe73c160c642733de68868f1d8c3772", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmI4ZmU0YTAzZmU3M2MxNjBjNjQyNzMzZGU2ODg2OGYxZDhjMzc3Mg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2004-08-25T16:58:23Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2004-08-25T16:58:23Z"}, "message": "cp-tree.h (mangle_type): Remove.\n\n\t* cp-tree.h (mangle_type): Remove.\n\t* mangle.c (globals): GTY it.\n\t(mangle_obstack): New variable.\n\t(name_obstack): Likewise.\n\t(name_base): Likewise.\n\t(write_char): Adjust accordingly.\n\t(write_chars): Likewise.\n\t(write_string): Likewise.\n\t(start_mangling): Initialize G.substitutions only one.  Add\n\tident_p parameter.\n\t(finish_mangling): Use VARRAY_CLEAR to reclaim\n\tstorage in G.substitutions.  Use obstack_finish.\n\t(init_mangle): Adjust for changes to variable names above.\n\tInitialize G.substitutions.\n\t(mangle_decl_string): Adjust call to start_mangling.\n\t(get_identifier_nocopy): New function.\n\t(mangle_decl): Use it.\n\t(mangle_type_string): Adjust call to start_mangling.\n\t(mangle_special_for_type): Likewise.\n\t(mangle_vtt_for_type): Likewise.\n\t(mangle_ctor_vtbl_for_type): Likewise.\n\t(mangle_thunk): Likewise.\n\t(mangle_guard_variable): Likewise.\n\t(mangle_ref_init_variable): Likewise.\n\nFrom-SVN: r86559", "tree": {"sha": "7b28cb1ae482b7054de991a613eeebee597435a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b28cb1ae482b7054de991a613eeebee597435a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b8fe4a03fe73c160c642733de68868f1d8c3772", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b8fe4a03fe73c160c642733de68868f1d8c3772", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b8fe4a03fe73c160c642733de68868f1d8c3772", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b8fe4a03fe73c160c642733de68868f1d8c3772/comments", "author": null, "committer": null, "parents": [{"sha": "40f201864ffd59ee5936db9ba75bc918227a6798", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40f201864ffd59ee5936db9ba75bc918227a6798", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40f201864ffd59ee5936db9ba75bc918227a6798"}], "stats": {"total": 126, "additions": 86, "deletions": 40}, "files": [{"sha": "4c43dce96f1df523b99de8f9a9e7c609b98620e8", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b8fe4a03fe73c160c642733de68868f1d8c3772/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b8fe4a03fe73c160c642733de68868f1d8c3772/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2b8fe4a03fe73c160c642733de68868f1d8c3772", "patch": "@@ -1,3 +1,30 @@\n+2004-08-25  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (mangle_type): Remove.\n+\t* mangle.c (globals): GTY it.\n+\t(mangle_obstack): New variable.\n+\t(name_obstack): Likewise.\n+\t(name_base): Likewise.\n+\t(write_char): Adjust accordingly.\n+\t(write_chars): Likewise.\n+\t(write_string): Likewise.\n+\t(start_mangling): Initialize G.substitutions only one.  Add\n+\tident_p parameter.\n+\t(finish_mangling): Use VARRAY_CLEAR to reclaim\n+\tstorage in G.substitutions.  Use obstack_finish.\n+\t(init_mangle): Adjust for changes to variable names above.\n+\tInitialize G.substitutions.\n+\t(mangle_decl_string): Adjust call to start_mangling.\n+\t(get_identifier_nocopy): New function.\n+\t(mangle_decl): Use it.\n+\t(mangle_type_string): Adjust call to start_mangling.\n+\t(mangle_special_for_type): Likewise.\n+\t(mangle_vtt_for_type): Likewise.\n+\t(mangle_ctor_vtbl_for_type): Likewise.\n+\t(mangle_thunk): Likewise.\n+\t(mangle_guard_variable): Likewise.\n+\t(mangle_ref_init_variable): Likewise.\n+\n 2004-08-25  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n \n \tPR c++/14428"}, {"sha": "d7b44485d734d30e3a5ebc9dc15c17f8a25711c5", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b8fe4a03fe73c160c642733de68868f1d8c3772/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b8fe4a03fe73c160c642733de68868f1d8c3772/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=2b8fe4a03fe73c160c642733de68868f1d8c3772", "patch": "@@ -4358,7 +4358,6 @@ extern tree merge_exception_specifiers          (tree, tree);\n extern void init_mangle                         (void);\n extern void mangle_decl                         (tree);\n extern const char *mangle_type_string           (tree);\n-extern tree mangle_type                         (tree);\n extern tree mangle_typeinfo_for_type            (tree);\n extern tree mangle_typeinfo_string_for_type     (tree);\n extern tree mangle_vtbl_for_type                (tree);"}, {"sha": "b491fccf17efcb9ab768e2f0a6f12c0d1c1a05fd", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 59, "deletions": 39, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b8fe4a03fe73c160c642733de68868f1d8c3772/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b8fe4a03fe73c160c642733de68868f1d8c3772/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=2b8fe4a03fe73c160c642733de68868f1d8c3772", "patch": "@@ -92,22 +92,32 @@\n \t   && (PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (NODE))))))\n \n /* Things we only need one of.  This module is not reentrant.  */\n-static struct globals\n+typedef struct globals GTY(())\n {\n-  /* The name in which we're building the mangled name.  */\n-  struct obstack name_obstack;\n-\n   /* An array of the current substitution candidates, in the order\n      we've seen them.  */\n   varray_type substitutions;\n \n   /* The entity that is being mangled.  */\n-  tree entity;\n+  tree GTY ((skip)) entity;\n \n   /* True if the mangling will be different in a future version of the\n      ABI.  */\n   bool need_abi_warning;\n-} G;\n+} globals;\n+\n+static GTY (()) globals G;\n+\n+/* The obstack on which we build mangled names.  */\n+static struct obstack *mangle_obstack;\n+\n+/* The obstack on which we build mangled names that are not going to\n+   be IDENTIFIER_NODEs.  */\n+static struct obstack name_obstack;\n+\n+  /* The first object on the name_obstack; we use this to free memory\n+     allocated on the name_obstack.  */\n+static void *name_base;\n \n /* Indices into subst_identifiers.  These are identifiers used in\n    special substitution rules.  */\n@@ -206,7 +216,7 @@ static const char *mangle_decl_string (const tree);\n \n /* Control functions.  */\n \n-static inline void start_mangling (const tree);\n+static inline void start_mangling (const tree, bool);\n static inline const char *finish_mangling (const bool);\n static tree mangle_special_for_type (const tree, const char *);\n \n@@ -217,16 +227,16 @@ static void write_java_integer_type_codes (const tree);\n /* Append a single character to the end of the mangled\n    representation.  */\n #define write_char(CHAR)                                              \\\n-  obstack_1grow (&G.name_obstack, (CHAR))\n+  obstack_1grow (mangle_obstack, (CHAR))\n \n /* Append a sized buffer to the end of the mangled representation.  */\n #define write_chars(CHAR, LEN)                                        \\\n-  obstack_grow (&G.name_obstack, (CHAR), (LEN))\n+  obstack_grow (mangle_obstack, (CHAR), (LEN))\n \n /* Append a NUL-terminated string to the end of the mangled\n    representation.  */\n #define write_string(STRING)                                          \\\n-  obstack_grow (&G.name_obstack, (STRING), strlen (STRING))\n+  obstack_grow (mangle_obstack, (STRING), strlen (STRING))\n \n /* Nonzero if NODE1 and NODE2 are both TREE_LIST nodes and have the\n    same purpose (context, which may be a type) and value (template\n@@ -2401,12 +2411,18 @@ write_substitution (const int seq_id)\n /* Start mangling ENTITY.  */\n \n static inline void\n-start_mangling (const tree entity)\n+start_mangling (const tree entity, const bool ident_p)\n {\n   G.entity = entity;\n   G.need_abi_warning = false;\n-  VARRAY_TREE_INIT (G.substitutions, 1, \"mangling substitutions\");\n-  obstack_free (&G.name_obstack, obstack_base (&G.name_obstack));\n+  if (!ident_p) \n+    {\n+      obstack_free (&name_obstack, name_base);\n+      mangle_obstack = &name_obstack;\n+      name_base = obstack_alloc (&name_obstack, 0);\n+    }\n+  else\n+    mangle_obstack = &ident_hash->stack;\n }\n \n /* Done with mangling.  Return the generated mangled name.  If WARN is\n@@ -2422,20 +2438,22 @@ finish_mangling (const bool warn)\n \t     G.entity);\n \n   /* Clear all the substitutions.  */\n-  G.substitutions = 0;\n+  VARRAY_CLEAR (G.substitutions);\n \n   /* Null-terminate the string.  */\n   write_char ('\\0');\n \n-  return (const char *) obstack_base (&G.name_obstack);\n+  return (const char *) obstack_finish (mangle_obstack);\n }\n \n /* Initialize data structures for mangling.  */\n \n void\n init_mangle (void)\n {\n-  gcc_obstack_init (&G.name_obstack);\n+  gcc_obstack_init (&name_obstack);\n+  name_base = obstack_alloc (&name_obstack, 0);\n+  VARRAY_TREE_INIT (G.substitutions, 1, \"mangling substitutions\");\n \n   /* Cache these identifiers for quick comparison when checking for\n      standard substitutions.  */\n@@ -2454,7 +2472,7 @@ mangle_decl_string (const tree decl)\n {\n   const char *result;\n \n-  start_mangling (decl);\n+  start_mangling (decl, /*ident_p=*/true);\n \n   if (TREE_CODE (decl) == TYPE_DECL)\n     write_type (TREE_TYPE (decl));\n@@ -2467,14 +2485,24 @@ mangle_decl_string (const tree decl)\n   return result;\n }\n \n+/* Like get_identifier, except that NAME is assumed to have been\n+   allocated on the obstack used by the identifier hash table.  */\n+\n+static inline tree\n+get_identifier_nocopy (const char *name)\n+{\n+  hashnode ht_node = ht_lookup (ident_hash, name, \n+\t\t\t\tstrlen (name), HT_ALLOCED);\n+  return HT_IDENT_TO_GCC_IDENT (ht_node);\n+}\n+\n /* Create an identifier for the external mangled name of DECL.  */\n \n void\n mangle_decl (const tree decl)\n {\n-  tree id = get_identifier (mangle_decl_string (decl));\n-\n-  SET_DECL_ASSEMBLER_NAME (decl, id);\n+  SET_DECL_ASSEMBLER_NAME (decl, \n+\t\t\t   get_identifier_nocopy (mangle_decl_string (decl)));\n }\n \n /* Generate the mangled representation of TYPE.  */\n@@ -2484,22 +2512,14 @@ mangle_type_string (const tree type)\n {\n   const char *result;\n \n-  start_mangling (type);\n+  start_mangling (type, /*ident_p=*/false);\n   write_type (type);\n   result = finish_mangling (/*warn=*/false);\n   if (DEBUG_MANGLE)\n     fprintf (stderr, \"mangle_type_string = '%s'\\n\\n\", result);\n   return result;\n }\n \n-/* Create an identifier for the mangled representation of TYPE.  */\n-\n-tree\n-mangle_type (const tree type)\n-{\n-  return get_identifier (mangle_type_string (type));\n-}\n-\n /* Create an identifier for the mangled name of a special component\n    for belonging to TYPE.  CODE is the ABI-specified code for this\n    component.  */\n@@ -2511,7 +2531,7 @@ mangle_special_for_type (const tree type, const char *code)\n \n   /* We don't have an actual decl here for the special component, so\n      we can't just process the <encoded-name>.  Instead, fake it.  */\n-  start_mangling (type);\n+  start_mangling (type, /*ident_p=*/true);\n \n   /* Start the mangling.  */\n   write_string (\"_Z\");\n@@ -2524,7 +2544,7 @@ mangle_special_for_type (const tree type, const char *code)\n   if (DEBUG_MANGLE)\n     fprintf (stderr, \"mangle_special_for_type = %s\\n\\n\", result);\n \n-  return get_identifier (result);\n+  return get_identifier_nocopy (result);\n }\n \n /* Create an identifier for the mangled representation of the typeinfo\n@@ -2580,7 +2600,7 @@ mangle_ctor_vtbl_for_type (const tree type, const tree binfo)\n {\n   const char *result;\n \n-  start_mangling (type);\n+  start_mangling (type, /*ident_p=*/true);\n \n   write_string (\"_Z\");\n   write_string (\"TC\");\n@@ -2592,7 +2612,7 @@ mangle_ctor_vtbl_for_type (const tree type, const tree binfo)\n   result = finish_mangling (/*warn=*/false);\n   if (DEBUG_MANGLE)\n     fprintf (stderr, \"mangle_ctor_vtbl_for_type = %s\\n\\n\", result);\n-  return get_identifier (result);\n+  return get_identifier_nocopy (result);\n }\n \n /* Mangle a this pointer or result pointer adjustment.\n@@ -2637,7 +2657,7 @@ mangle_thunk (tree fn_decl, const int this_adjusting, tree fixed_offset,\n {\n   const char *result;\n   \n-  start_mangling (fn_decl);\n+  start_mangling (fn_decl, /*ident_p=*/true);\n \n   write_string (\"_Z\");\n   write_char ('T');\n@@ -2671,7 +2691,7 @@ mangle_thunk (tree fn_decl, const int this_adjusting, tree fixed_offset,\n   result = finish_mangling (/*warn=*/false);\n   if (DEBUG_MANGLE)\n     fprintf (stderr, \"mangle_thunk = %s\\n\\n\", result);\n-  return get_identifier (result);\n+  return get_identifier_nocopy (result);\n }\n \n /* This hash table maps TYPEs to the IDENTIFIER for a conversion\n@@ -2740,15 +2760,15 @@ mangle_conv_op_name_for_type (const tree type)\n tree\n mangle_guard_variable (const tree variable)\n {\n-  start_mangling (variable);\n+  start_mangling (variable, /*ident_p=*/true);\n   write_string (\"_ZGV\");\n   if (strncmp (IDENTIFIER_POINTER (DECL_NAME (variable)), \"_ZGR\", 4) == 0)\n     /* The name of a guard variable for a reference temporary should refer\n        to the reference, not the temporary.  */\n     write_string (IDENTIFIER_POINTER (DECL_NAME (variable)) + 4);\n   else\n     write_name (variable, /*ignore_local_scope=*/0);\n-  return get_identifier (finish_mangling (/*warn=*/false));\n+  return get_identifier_nocopy (finish_mangling (/*warn=*/false));\n }\n \n /* Return an identifier for the name of a temporary variable used to\n@@ -2758,10 +2778,10 @@ mangle_guard_variable (const tree variable)\n tree\n mangle_ref_init_variable (const tree variable)\n {\n-  start_mangling (variable);\n+  start_mangling (variable, /*ident_p=*/true);\n   write_string (\"_ZGR\");\n   write_name (variable, /*ignore_local_scope=*/0);\n-  return get_identifier (finish_mangling (/*warn=*/false));\n+  return get_identifier_nocopy (finish_mangling (/*warn=*/false));\n }\n \f\n "}]}