{"sha": "8069928d5c2a99973ac16a49d6c25bc4dc886e14", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODA2OTkyOGQ1YzJhOTk5NzNhYzE2YTQ5ZDZjMjViYzRkYzg4NmUxNA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-11-12T02:18:59Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-11-12T02:18:59Z"}, "message": "analyzer: precision-of-wording for -Wanalyzer-stale-setjmp-buffer\n\nThis patch adds a custom event to paths emitted by\n-Wanalyzer-stale-setjmp-buffer highlighting the place where the\npertinent stack frame is popped, and updates the final event in\nthe path to reference this.\n\ngcc/analyzer/ChangeLog:\n\t* checker-path.h (checker_event::get_id_ptr): New.\n\t* diagnostic-manager.cc (path_builder::path_builder): Add \"sd\"\n\tparam and use it to initialize new field \"m_sd\".\n\t(path_builder::get_pending_diagnostic): New.\n\t(path_builder::m_sd): New field.\n\t(diagnostic_manager::emit_saved_diagnostic): Pass sd to\n\tpath_builder ctor.\n\t(diagnostic_manager::add_events_for_superedge): Call new\n\tmaybe_add_custom_events_for_superedge vfunc.\n\t* engine.cc (stale_jmp_buf::stale_jmp_buf): Add \"setjmp_point\"\n\tparam and use it to initialize new field \"m_setjmp_point\".\n\tInitialize new field \"m_stack_pop_event\".\n\t(stale_jmp_buf::maybe_add_custom_events_for_superedge): New vfunc\n\timplementation.\n\t(stale_jmp_buf::describe_final_event): New vfunc implementation.\n\t(stale_jmp_buf::m_setjmp_point): New field.\n\t(stale_jmp_buf::m_stack_pop_event): New field.\n\t(exploded_node::on_longjmp): Pass setjmp_point to stale_jmp_buf\n\tctor.\n\t* pending-diagnostic.h\n\t(pending_diagnostic::maybe_add_custom_events_for_superedge): New\n\tvfunc.\n\ngcc/testsuite/ChangeLog:\n\t* gcc.dg/analyzer/setjmp-5.c: Update expected path output to show\n\tan event where the pertinent stack frame is popped.  Update\n\texpected message from final event to reference this event.", "tree": {"sha": "1bab14e9c9b31791da7c742d6fbc166616c03147", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1bab14e9c9b31791da7c742d6fbc166616c03147"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8069928d5c2a99973ac16a49d6c25bc4dc886e14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8069928d5c2a99973ac16a49d6c25bc4dc886e14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8069928d5c2a99973ac16a49d6c25bc4dc886e14", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8069928d5c2a99973ac16a49d6c25bc4dc886e14/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e00ad3ffbfb4df7242c313a0d836f5b538eb2fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e00ad3ffbfb4df7242c313a0d836f5b538eb2fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e00ad3ffbfb4df7242c313a0d836f5b538eb2fb"}], "stats": {"total": 107, "additions": 99, "deletions": 8}, "files": [{"sha": "a00b3cf09eaf0e06e44e815d35a7fc7436eafd31", "filename": "gcc/analyzer/checker-path.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8069928d5c2a99973ac16a49d6c25bc4dc886e14/gcc%2Fanalyzer%2Fchecker-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8069928d5c2a99973ac16a49d6c25bc4dc886e14/gcc%2Fanalyzer%2Fchecker-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fchecker-path.h?ref=8069928d5c2a99973ac16a49d6c25bc4dc886e14", "patch": "@@ -97,6 +97,12 @@ class checker_event : public diagnostic_event\n   virtual bool is_function_entry_p () const  { return false; }\n   virtual bool is_return_p () const  { return false; }\n \n+  /* For use with %@.  */\n+  const diagnostic_event_id_t *get_id_ptr () const\n+  {\n+    return &m_emission_id;\n+  }\n+\n   void dump (pretty_printer *pp) const;\n \n  public:"}, {"sha": "13f6dd2f341e54bb46663e84e8a7307a7d0563b8", "filename": "gcc/analyzer/diagnostic-manager.cc", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8069928d5c2a99973ac16a49d6c25bc4dc886e14/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8069928d5c2a99973ac16a49d6c25bc4dc886e14/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.cc?ref=8069928d5c2a99973ac16a49d6c25bc4dc886e14", "patch": "@@ -161,15 +161,22 @@ class path_builder\n public:\n   path_builder (const exploded_graph &eg,\n \t\tconst exploded_path &epath,\n-\t\tconst feasibility_problem *problem)\n+\t\tconst feasibility_problem *problem,\n+\t\tconst saved_diagnostic &sd)\n   : m_eg (eg),\n     m_diag_enode (epath.get_final_enode ()),\n+    m_sd (sd),\n     m_reachability (eg, m_diag_enode),\n     m_feasibility_problem (problem)\n   {}\n \n   const exploded_node *get_diag_node () const { return m_diag_enode; }\n \n+  pending_diagnostic *get_pending_diagnostic () const\n+  {\n+    return m_sd.m_d;\n+  }\n+\n   bool reachable_from_p (const exploded_node *src_enode) const\n   {\n     return m_reachability.reachable_from_p (src_enode);\n@@ -190,6 +197,8 @@ class path_builder\n   /* The enode where the diagnostic occurs.  */\n   const exploded_node *m_diag_enode;\n \n+  const saved_diagnostic &m_sd;\n+\n   /* Precompute all enodes from which the diagnostic is reachable.  */\n   enode_reachability m_reachability;\n \n@@ -629,7 +638,7 @@ diagnostic_manager::emit_saved_diagnostic (const exploded_graph &eg,\n   pretty_printer *pp = global_dc->printer->clone ();\n \n   /* Precompute all enodes from which the diagnostic is reachable.  */\n-  path_builder pb (eg, epath, sd.get_feasibility_problem ());\n+  path_builder pb (eg, epath, sd.get_feasibility_problem (), sd);\n \n   /* This is the diagnostic_path subclass that will be built for\n      the diagnostic.  */\n@@ -1175,6 +1184,11 @@ diagnostic_manager::add_events_for_superedge (const path_builder &pb,\n {\n   gcc_assert (eedge.m_sedge);\n \n+  /* Give diagnostics an opportunity to override this function.  */\n+  pending_diagnostic *pd = pb.get_pending_diagnostic ();\n+  if (pd->maybe_add_custom_events_for_superedge (eedge, emission_path))\n+    return;\n+\n   /* Don't add events for insignificant edges at verbosity levels below 3.  */\n   if (m_verbosity < 3)\n     if (!significant_edge_p (pb, eedge))"}, {"sha": "0a8e5b87e01a3d97987563b28a51f6ce07c92bb9", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 52, "deletions": 3, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8069928d5c2a99973ac16a49d6c25bc4dc886e14/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8069928d5c2a99973ac16a49d6c25bc4dc886e14/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=8069928d5c2a99973ac16a49d6c25bc4dc886e14", "patch": "@@ -1277,8 +1277,10 @@ valid_longjmp_stack_p (const program_point &longjmp_point,\n class stale_jmp_buf : public pending_diagnostic_subclass<dump_path_diagnostic>\n {\n public:\n-  stale_jmp_buf (const gcall *setjmp_call, const gcall *longjmp_call)\n-  : m_setjmp_call (setjmp_call), m_longjmp_call (longjmp_call)\n+  stale_jmp_buf (const gcall *setjmp_call, const gcall *longjmp_call,\n+\t\t const program_point &setjmp_point)\n+  : m_setjmp_call (setjmp_call), m_longjmp_call (longjmp_call),\n+    m_setjmp_point (setjmp_point), m_stack_pop_event (NULL)\n   {}\n \n   bool emit (rich_location *richloc) FINAL OVERRIDE\n@@ -1299,9 +1301,56 @@ class stale_jmp_buf : public pending_diagnostic_subclass<dump_path_diagnostic>\n \t    && m_longjmp_call == other.m_longjmp_call);\n   }\n \n+  bool\n+  maybe_add_custom_events_for_superedge (const exploded_edge &eedge,\n+\t\t\t\t\t checker_path *emission_path)\n+    FINAL OVERRIDE\n+  {\n+    /* Detect exactly when the stack first becomes invalid,\n+       and issue an event then.  */\n+    if (m_stack_pop_event)\n+      return false;\n+    const exploded_node *src_node = eedge.m_src;\n+    const program_point &src_point = src_node->get_point ();\n+    const exploded_node *dst_node = eedge.m_dest;\n+    const program_point &dst_point = dst_node->get_point ();\n+    if (valid_longjmp_stack_p (src_point, m_setjmp_point)\n+\t&& !valid_longjmp_stack_p (dst_point, m_setjmp_point))\n+      {\n+\t/* Compare with diagnostic_manager::add_events_for_superedge.  */\n+\tconst int src_stack_depth = src_point.get_stack_depth ();\n+\tm_stack_pop_event = new custom_event\n+\t  (src_point.get_location (),\n+\t   src_point.get_fndecl (),\n+\t   src_stack_depth,\n+\t   \"stack frame is popped here, invalidating saved environment\");\n+\temission_path->add_event (m_stack_pop_event);\n+\treturn false;\n+      }\n+    return false;\n+  }\n+\n+  label_text describe_final_event (const evdesc::final_event &ev)\n+  {\n+    if (m_stack_pop_event)\n+      return ev.formatted_print\n+\t(\"%qs called after enclosing function of %qs returned at %@\",\n+\t get_user_facing_name (m_longjmp_call),\n+\t get_user_facing_name (m_setjmp_call),\n+\t m_stack_pop_event->get_id_ptr ());\n+    else\n+      return ev.formatted_print\n+\t(\"%qs called after enclosing function of %qs has returned\",\n+\t get_user_facing_name (m_longjmp_call),\n+\t get_user_facing_name (m_setjmp_call));;\n+  }\n+\n+\n private:\n   const gcall *m_setjmp_call;\n   const gcall *m_longjmp_call;\n+  program_point m_setjmp_point;\n+  custom_event *m_stack_pop_event;\n };\n \n /* Handle LONGJMP_CALL, a call to longjmp or siglongjmp.\n@@ -1344,7 +1393,7 @@ exploded_node::on_longjmp (exploded_graph &eg,\n   /* Verify that the setjmp's call_stack hasn't been popped.  */\n   if (!valid_longjmp_stack_p (longjmp_point, setjmp_point))\n     {\n-      ctxt->warn (new stale_jmp_buf (setjmp_call, longjmp_call));\n+      ctxt->warn (new stale_jmp_buf (setjmp_call, longjmp_call, setjmp_point));\n       return;\n     }\n "}, {"sha": "ce626f678711fe269802ab9dd26d96694756f2c2", "filename": "gcc/analyzer/pending-diagnostic.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8069928d5c2a99973ac16a49d6c25bc4dc886e14/gcc%2Fanalyzer%2Fpending-diagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8069928d5c2a99973ac16a49d6c25bc4dc886e14/gcc%2Fanalyzer%2Fpending-diagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fpending-diagnostic.h?ref=8069928d5c2a99973ac16a49d6c25bc4dc886e14", "patch": "@@ -246,6 +246,21 @@ class pending_diagnostic\n   }\n \n   /* End of precision-of-wording vfuncs.  */\n+\n+  /* Vfunc for extending/overriding creation of the events for an\n+     exploded_edge that corresponds to a superedge, allowing for custom\n+     events to be created that are pertinent to a particular\n+     pending_diagnostic subclass.\n+\n+     For example, the -Wanalyzer-stale-setjmp-buffer diagnostic adds a\n+     custom event showing when the pertinent stack frame is popped\n+     (and thus the point at which the jmp_buf becomes invalid).  */\n+\n+  virtual bool maybe_add_custom_events_for_superedge (const exploded_edge &,\n+\t\t\t\t\t\t      checker_path *)\n+  {\n+    return false;\n+  }\n };\n \n /* A template to make it easier to make subclasses of pending_diagnostic."}, {"sha": "4787fa38032b9196b72f326398a4c562e488734b", "filename": "gcc/testsuite/gcc.dg/analyzer/setjmp-5.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8069928d5c2a99973ac16a49d6c25bc4dc886e14/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8069928d5c2a99973ac16a49d6c25bc4dc886e14/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-5.c?ref=8069928d5c2a99973ac16a49d6c25bc4dc886e14", "patch": "@@ -51,18 +51,25 @@ void outer (void)\n            |      |   |\n            |      |   (4) 'setjmp' called here\n            |\n+         'inner': event 5\n+           |\n+           |   NN | }\n+           |      | ^\n+           |      | |\n+           |      | (5) stack frame is popped here, invalidating saved environment\n+           |\n     <------+\n     |\n-  'outer': events 5-6\n+  'outer': events 6-7\n     |\n     |   NN |   inner ();\n     |      |   ^~~~~~~~\n     |      |   |\n-    |      |   (5) returning to 'outer' from 'inner'\n+    |      |   (6) returning to 'outer' from 'inner'\n     |   NN | \n     |   NN |   longjmp (env, 42);\n     |      |   ~~~~~~~~~~~~~~~~~\n     |      |   |\n-    |      |   (6) here\n+    |      |   (7) 'longjmp' called after enclosing function of 'setjmp' returned at (5)\n     |\n     { dg-end-multiline-output \"\" } */"}]}