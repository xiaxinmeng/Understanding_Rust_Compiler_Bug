{"sha": "5bcd8644167353674cc9f44f321df15154311735", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWJjZDg2NDQxNjczNTM2NzRjYzlmNDRmMzIxZGYxNTE1NDMxMTczNQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-05-18T23:21:17Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-05-18T23:21:17Z"}, "message": "tree-ssa-forwprop.c (cfg_changed): New.\n\n        * tree-ssa-forwprop.c (cfg_changed): New.\n        (tidy_after_forward_propagate_addr): New.\n        (forward_propagate_addr_expr): Use it, and fold_stmt_inplace.\n        (forward_propagate_addr_into_variable_array_index): Likewise.\n        (tree_ssa_forward_propagate_single_use_vars): Cleanup cfg if\n        edges were removed.\n\nFrom-SVN: r99935", "tree": {"sha": "eeaeec0070e056ea3ab58b944e95c09a25fc0871", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eeaeec0070e056ea3ab58b944e95c09a25fc0871"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5bcd8644167353674cc9f44f321df15154311735", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bcd8644167353674cc9f44f321df15154311735", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5bcd8644167353674cc9f44f321df15154311735", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bcd8644167353674cc9f44f321df15154311735/comments", "author": null, "committer": null, "parents": [{"sha": "66143232bcc2a86d69242f0e911f2d8a6f12ffb4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66143232bcc2a86d69242f0e911f2d8a6f12ffb4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66143232bcc2a86d69242f0e911f2d8a6f12ffb4"}], "stats": {"total": 62, "additions": 43, "deletions": 19}, "files": [{"sha": "6d083c07874197e4ed3a193c82da1100f2197eb3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bcd8644167353674cc9f44f321df15154311735/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bcd8644167353674cc9f44f321df15154311735/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5bcd8644167353674cc9f44f321df15154311735", "patch": "@@ -1,3 +1,12 @@\n+2005-05-18  Richard Henderson  <rth@redhat.com>\n+\n+        * tree-ssa-forwprop.c (cfg_changed): New.\n+        (tidy_after_forward_propagate_addr): New.\n+        (forward_propagate_addr_expr): Use it, and fold_stmt_inplace.\n+        (forward_propagate_addr_into_variable_array_index): Likewise.\n+        (tree_ssa_forward_propagate_single_use_vars): Cleanup cfg if\n+        edges were removed.\n+\n 2005-05-18  Geoffrey Keating  <geoffk@apple.com>\n \n \t* dummy-checksum.c: New."}, {"sha": "93f1cf65e3cf3f2d4b795de577a759aa4223dc18", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 34, "deletions": 19, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bcd8644167353674cc9f44f321df15154311735/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bcd8644167353674cc9f44f321df15154311735/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=5bcd8644167353674cc9f44f321df15154311735", "patch": "@@ -146,6 +146,11 @@ Boston, MA 02111-1307, USA.  */\n \n    This will (of course) be extended as other needs arise.  */\n \n+\n+/* Set to true if we delete EH edges during the optimization.  */\n+static bool cfg_changed;\n+\n+\n /* Given an SSA_NAME VAR, return true if and only if VAR is defined by\n    a comparison.  */\n \n@@ -434,6 +439,21 @@ forward_propagate_into_cond (tree cond_expr)\n     }\n }\n \n+/* We've just substituted an ADDR_EXPR into stmt.  Update all the \n+   relevant data structures to match.  */\n+\n+static void\n+tidy_after_forward_propagate_addr (tree stmt)\n+{\n+  mark_new_vars_to_rename (stmt);\n+  update_stmt (stmt);\n+\n+  /* We may have turned a trapping insn into a non-trapping insn.  */\n+  if (maybe_clean_or_replace_eh_stmt (stmt, stmt)\n+      && tree_purge_dead_eh_edges (bb_for_stmt (stmt)))\n+    cfg_changed = true;\n+}\n+\n /* STMT defines LHS which is contains the address of the 0th element\n    in an array.  USE_STMT uses LHS to compute the address of an\n    arbitrary element within the array.  The (variable) byte offset\n@@ -498,9 +518,8 @@ forward_propagate_addr_into_variable_array_index (tree offset, tree lhs,\n \n   /* That should have created gimple, so there is no need to\n      record information to undo the propagation.  */\n-  fold_stmt (bsi_stmt_ptr (bsi_for_stmt (use_stmt)));\n-  mark_new_vars_to_rename (use_stmt);\n-  update_stmt (use_stmt);\n+  fold_stmt_inplace (use_stmt);\n+  tidy_after_forward_propagate_addr (use_stmt);\n   return true;\n }\n \n@@ -537,11 +556,6 @@ forward_propagate_addr_expr (tree stmt)\n   if (bb_for_stmt (use_stmt)->loop_depth > stmt_loop_depth)\n     return false;\n \n-  /* If the two statements belong to different EH regions, then there\n-     is nothing we can or should try to do.  */\n-  if (lookup_stmt_eh_region (use_stmt) != lookup_stmt_eh_region (stmt))\n-    return false;\n-\n   /* Strip away any outer COMPONENT_REF/ARRAY_REF nodes from the LHS.  */\n   lhs = TREE_OPERAND (use_stmt, 0);\n   while (TREE_CODE (lhs) == COMPONENT_REF || TREE_CODE (lhs) == ARRAY_REF)\n@@ -554,9 +568,8 @@ forward_propagate_addr_expr (tree stmt)\n       /* This should always succeed in creating gimple, so there is\n \t no need to save enough state to undo this propagation.  */\n       TREE_OPERAND (lhs, 0) = unshare_expr (TREE_OPERAND (stmt, 1));\n-      fold_stmt (bsi_stmt_ptr (bsi_for_stmt (use_stmt)));\n-      mark_new_vars_to_rename (use_stmt);\n-      update_stmt (use_stmt);\n+      fold_stmt_inplace (use_stmt);\n+      tidy_after_forward_propagate_addr (use_stmt);\n       return true;\n     }\n \n@@ -570,8 +583,7 @@ forward_propagate_addr_expr (tree stmt)\n   if (TREE_CODE (lhs) == SSA_NAME && TREE_OPERAND (use_stmt, 1) == name)\n     {\n       TREE_OPERAND (use_stmt, 1) = unshare_expr (TREE_OPERAND (stmt, 1));\n-      mark_new_vars_to_rename (use_stmt);\n-      update_stmt (use_stmt);\n+      tidy_after_forward_propagate_addr (use_stmt);\n       return true;\n     }\n \n@@ -587,9 +599,8 @@ forward_propagate_addr_expr (tree stmt)\n       /* This should always succeed in creating gimple, so there is\n          no need to save enough state to undo this propagation.  */\n       TREE_OPERAND (rhs, 0) = unshare_expr (TREE_OPERAND (stmt, 1));\n-      fold_stmt (bsi_stmt_ptr (bsi_for_stmt (use_stmt)));\n-      mark_new_vars_to_rename (use_stmt);\n-      update_stmt (use_stmt);\n+      fold_stmt_inplace (use_stmt);\n+      tidy_after_forward_propagate_addr (use_stmt);\n       return true;\n     }\n \n@@ -619,10 +630,9 @@ forward_propagate_addr_expr (tree stmt)\n       /* If folding succeeds, then we have just exposed new variables\n \t in USE_STMT which will need to be renamed.  If folding fails,\n \t then we need to put everything back the way it was.  */\n-      if (fold_stmt (bsi_stmt_ptr (bsi_for_stmt (use_stmt))))\n+      if (fold_stmt_inplace (use_stmt))\n \t{\n-\t  mark_new_vars_to_rename (use_stmt);\n-\t  update_stmt (use_stmt);\n+\t  tidy_after_forward_propagate_addr (use_stmt);\n \t  return true;\n \t}\n       else\n@@ -670,6 +680,8 @@ tree_ssa_forward_propagate_single_use_vars (void)\n {\n   basic_block bb;\n \n+  cfg_changed = false;\n+\n   FOR_EACH_BB (bb)\n     {\n       block_stmt_iterator bsi;\n@@ -699,6 +711,9 @@ tree_ssa_forward_propagate_single_use_vars (void)\n \t    bsi_next (&bsi);\n \t}\n     }\n+\n+  if (cfg_changed)\n+    cleanup_tree_cfg ();\n }\n \n "}]}