{"sha": "9b77478248366c7165ea89c8051677ea35333369", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWI3NzQ3ODI0ODM2NmM3MTY1ZWE4OWM4MDUxNjc3ZWEzNTMzMzM2OQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2010-07-27T19:27:31Z"}, "committer": {"name": "Maxim Kuvyrkov", "email": "mkuvyrkov@gcc.gnu.org", "date": "2010-07-27T19:27:31Z"}, "message": "gcse.c (compute_transpout, transpout): Remove, move logic to prune_expressions.\n\n\t* gcse.c (compute_transpout, transpout): Remove, move logic\n\tto prune_expressions.\n\t(compute_pre_data): Move pruning of trapping expressions ...\n\t(prune_expressions): ... here.  New static function.\n\t(compute_code_hoist_data): Use it.\n\t(alloc_code_hoist_mem, free_code_hoist_mem, hoist_code): Update.\n\nCo-Authored-By: Maxim Kuvyrkov <maxim@codesourcery.com>\n\nFrom-SVN: r162588", "tree": {"sha": "7a1ec683cc343481ac7c52d6c023de5e66a1f722", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a1ec683cc343481ac7c52d6c023de5e66a1f722"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b77478248366c7165ea89c8051677ea35333369", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b77478248366c7165ea89c8051677ea35333369", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b77478248366c7165ea89c8051677ea35333369", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b77478248366c7165ea89c8051677ea35333369/comments", "author": null, "committer": null, "parents": [{"sha": "55791fcdf0185d2cce8ebc1dd623588bfa10612b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55791fcdf0185d2cce8ebc1dd623588bfa10612b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55791fcdf0185d2cce8ebc1dd623588bfa10612b"}], "stats": {"total": 176, "additions": 96, "deletions": 80}, "files": [{"sha": "3f2f76fed9014fe8034c4073130d6f6558b64f91", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b77478248366c7165ea89c8051677ea35333369/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b77478248366c7165ea89c8051677ea35333369/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9b77478248366c7165ea89c8051677ea35333369", "patch": "@@ -1,3 +1,13 @@\n+2010-07-27  Jeff Law  <law@redhat.com>\n+\t    Maxim Kuvyrkov  <maxim@codesourcery.com>\n+\n+\t* gcse.c (compute_transpout, transpout): Remove, move logic\n+\tto prune_expressions.\n+\t(compute_pre_data): Move pruning of trapping expressions ...\n+\t(prune_expressions): ... here.  New static function.\n+\t(compute_code_hoist_data): Use it.\n+\t(alloc_code_hoist_mem, free_code_hoist_mem, hoist_code): Update.\n+\n 2010-07-27  Xinliang David Li  <davidxl@google.com>\n \n \t* tree-ssa-loop-ivopts.c (adjust_iv_update_pos): New function."}, {"sha": "be02e9a8de37fd4a54c3ed83be3bc4714f6a0b86", "filename": "gcc/gcse.c", "status": "modified", "additions": 86, "deletions": 80, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b77478248366c7165ea89c8051677ea35333369/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b77478248366c7165ea89c8051677ea35333369/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=9b77478248366c7165ea89c8051677ea35333369", "patch": "@@ -468,7 +468,6 @@ static void mark_oprs_set (rtx);\n static void alloc_cprop_mem (int, int);\n static void free_cprop_mem (void);\n static void compute_transp (const_rtx, int, sbitmap *, int);\n-static void compute_transpout (void);\n static void compute_local_properties (sbitmap *, sbitmap *, sbitmap *,\n \t\t\t\t      struct hash_table_d *);\n static void compute_cprop_data (void);\n@@ -3172,11 +3171,6 @@ bypass_conditional_jumps (void)\n /* Nonzero for expressions that are transparent in the block.  */\n static sbitmap *transp;\n \n-/* Nonzero for expressions that are transparent at the end of the block.\n-   This is only zero for expressions killed by abnormal critical edge\n-   created by a calls.  */\n-static sbitmap *transpout;\n-\n /* Nonzero for expressions that are computed (available) in the block.  */\n static sbitmap *comp;\n \n@@ -3240,51 +3234,113 @@ free_pre_mem (void)\n   pre_optimal = pre_redundant = pre_insert_map = pre_delete_map = NULL;\n }\n \n-/* Top level routine to do the dataflow analysis needed by PRE.  */\n+/* Remove certain expressions from anticipatable and transparent\n+   sets of basic blocks that have incoming abnormal edge.\n+   For PRE remove potentially trapping expressions to avoid placing\n+   them on abnormal edges.  For hoisting remove memory references that\n+   can be clobbered by calls.  */\n \n static void\n-compute_pre_data (void)\n+prune_expressions (bool pre_p)\n {\n-  sbitmap trapping_expr;\n-  basic_block bb;\n+  sbitmap prune_exprs;\n   unsigned int ui;\n+  basic_block bb;\n \n-  compute_local_properties (transp, comp, antloc, &expr_hash_table);\n-  sbitmap_vector_zero (ae_kill, last_basic_block);\n-\n-  /* Collect expressions which might trap.  */\n-  trapping_expr = sbitmap_alloc (expr_hash_table.n_elems);\n-  sbitmap_zero (trapping_expr);\n+  prune_exprs = sbitmap_alloc (expr_hash_table.n_elems);\n+  sbitmap_zero (prune_exprs);\n   for (ui = 0; ui < expr_hash_table.size; ui++)\n     {\n       struct expr *e;\n       for (e = expr_hash_table.table[ui]; e != NULL; e = e->next_same_hash)\n-\tif (may_trap_p (e->expr))\n-\t  SET_BIT (trapping_expr, e->bitmap_index);\n-    }\n+\t{\n+\t  /* Note potentially trapping expressions.  */\n+\t  if (may_trap_p (e->expr))\n+\t    {\n+\t      SET_BIT (prune_exprs, e->bitmap_index);\n+\t      continue;\n+\t    }\n \n-  /* Compute ae_kill for each basic block using:\n+\t  if (!pre_p && MEM_P (e->expr))\n+\t    /* Note memory references that can be clobbered by a call.\n+\t       We do not split abnormal edges in hoisting, so would\n+\t       a memory reference get hoisted along an abnormal edge,\n+\t       it would be placed /before/ the call.  Therefore, only\n+\t       constant memory references can be hoisted along abnormal\n+\t       edges.  */\n+\t    {\n+\t      if (GET_CODE (XEXP (e->expr, 0)) == SYMBOL_REF\n+\t\t  && CONSTANT_POOL_ADDRESS_P (XEXP (e->expr, 0)))\n+\t\tcontinue;\n \n-     ~(TRANSP | COMP)\n-  */\n+\t      if (MEM_READONLY_P (e->expr)\n+\t\t  && !MEM_VOLATILE_P (e->expr)\n+\t\t  && MEM_NOTRAP_P (e->expr))\n+\t\t/* Constant memory reference, e.g., a PIC address.  */\n+\t\tcontinue;\n+\n+\t      /* ??? Optimally, we would use interprocedural alias\n+\t\t analysis to determine if this mem is actually killed\n+\t\t by this call.  */\n+\n+\t      SET_BIT (prune_exprs, e->bitmap_index);\n+\t    }\n+\t}\n+    }\n \n   FOR_EACH_BB (bb)\n     {\n       edge e;\n       edge_iterator ei;\n \n       /* If the current block is the destination of an abnormal edge, we\n-\t kill all trapping expressions because we won't be able to properly\n-\t place the instruction on the edge.  So make them neither\n-\t anticipatable nor transparent.  This is fairly conservative.  */\n+\t kill all trapping (for PRE) and memory (for hoist) expressions\n+\t because we won't be able to properly place the instruction on\n+\t the edge.  So make them neither anticipatable nor transparent.\n+\t This is fairly conservative.\n+\n+\t ??? For hoisting it may be necessary to check for set-and-jump\n+\t instructions here, not just for abnormal edges.  The general problem\n+\t is that when an expression cannot not be placed right at the end of\n+\t a basic block we should account for any side-effects of a subsequent\n+\t jump instructions that could clobber the expression.  It would\n+\t be best to implement this check along the lines of\n+\t hoist_expr_reaches_here_p where the target block is already known\n+\t and, hence, there's no need to conservatively prune expressions on\n+\t \"intermediate\" set-and-jump instructions.  */\n       FOR_EACH_EDGE (e, ei, bb->preds)\n-\tif (e->flags & EDGE_ABNORMAL)\n+\tif ((e->flags & EDGE_ABNORMAL)\n+\t    && (pre_p || CALL_P (BB_END (e->src))))\n \t  {\n-\t    sbitmap_difference (antloc[bb->index], antloc[bb->index], trapping_expr);\n-\t    sbitmap_difference (transp[bb->index], transp[bb->index], trapping_expr);\n+\t    sbitmap_difference (antloc[bb->index],\n+\t\t\t\tantloc[bb->index], prune_exprs);\n+\t    sbitmap_difference (transp[bb->index],\n+\t\t\t\ttransp[bb->index], prune_exprs);\n \t    break;\n \t  }\n+    }\n+\n+  sbitmap_free (prune_exprs);\n+}\n+\n+/* Top level routine to do the dataflow analysis needed by PRE.  */\n \n+static void\n+compute_pre_data (void)\n+{\n+  basic_block bb;\n+\n+  compute_local_properties (transp, comp, antloc, &expr_hash_table);\n+  prune_expressions (true);\n+  sbitmap_vector_zero (ae_kill, last_basic_block);\n+\n+  /* Compute ae_kill for each basic block using:\n+\n+     ~(TRANSP | COMP)\n+  */\n+\n+  FOR_EACH_BB (bb)\n+    {\n       sbitmap_a_or_b (ae_kill[bb->index], transp[bb->index], comp[bb->index]);\n       sbitmap_not (ae_kill[bb->index], ae_kill[bb->index]);\n     }\n@@ -3295,7 +3351,6 @@ compute_pre_data (void)\n   antloc = NULL;\n   sbitmap_vector_free (ae_kill);\n   ae_kill = NULL;\n-  sbitmap_free (trapping_expr);\n }\n \f\n /* PRE utilities */\n@@ -4050,52 +4105,6 @@ add_label_notes (rtx x, rtx insn)\n     }\n }\n \n-/* Compute transparent outgoing information for each block.\n-\n-   An expression is transparent to an edge unless it is killed by\n-   the edge itself.  This can only happen with abnormal control flow,\n-   when the edge is traversed through a call.  This happens with\n-   non-local labels and exceptions.\n-\n-   This would not be necessary if we split the edge.  While this is\n-   normally impossible for abnormal critical edges, with some effort\n-   it should be possible with exception handling, since we still have\n-   control over which handler should be invoked.  But due to increased\n-   EH table sizes, this may not be worthwhile.  */\n-\n-static void\n-compute_transpout (void)\n-{\n-  basic_block bb;\n-  unsigned int i;\n-  struct expr *expr;\n-\n-  sbitmap_vector_ones (transpout, last_basic_block);\n-\n-  FOR_EACH_BB (bb)\n-    {\n-      /* Note that flow inserted a nop at the end of basic blocks that\n-\t end in call instructions for reasons other than abnormal\n-\t control flow.  */\n-      if (! CALL_P (BB_END (bb)))\n-\tcontinue;\n-\n-      for (i = 0; i < expr_hash_table.size; i++)\n-\tfor (expr = expr_hash_table.table[i]; expr ; expr = expr->next_same_hash)\n-\t  if (MEM_P (expr->expr))\n-\t    {\n-\t      if (GET_CODE (XEXP (expr->expr, 0)) == SYMBOL_REF\n-\t\t  && CONSTANT_POOL_ADDRESS_P (XEXP (expr->expr, 0)))\n-\t\tcontinue;\n-\n-\t      /* ??? Optimally, we would use interprocedural alias\n-\t\t analysis to determine if this mem is actually killed\n-\t\t by this call.  */\n-\t      RESET_BIT (transpout[bb->index], expr->bitmap_index);\n-\t    }\n-    }\n-}\n-\n /* Code Hoisting variables and subroutines.  */\n \n /* Very busy expressions.  */\n@@ -4124,7 +4133,6 @@ alloc_code_hoist_mem (int n_blocks, int n_exprs)\n   hoist_vbein = sbitmap_vector_alloc (n_blocks, n_exprs);\n   hoist_vbeout = sbitmap_vector_alloc (n_blocks, n_exprs);\n   hoist_exprs = sbitmap_vector_alloc (n_blocks, n_exprs);\n-  transpout = sbitmap_vector_alloc (n_blocks, n_exprs);\n }\n \n /* Free vars used for code hoisting analysis.  */\n@@ -4139,7 +4147,6 @@ free_code_hoist_mem (void)\n   sbitmap_vector_free (hoist_vbein);\n   sbitmap_vector_free (hoist_vbeout);\n   sbitmap_vector_free (hoist_exprs);\n-  sbitmap_vector_free (transpout);\n \n   free_dominance_info (CDI_DOMINATORS);\n }\n@@ -4192,7 +4199,7 @@ static void\n compute_code_hoist_data (void)\n {\n   compute_local_properties (transp, comp, antloc, &expr_hash_table);\n-  compute_transpout ();\n+  prune_expressions (false);\n   compute_code_hoist_vbeinout ();\n   calculate_dominance_info (CDI_DOMINATORS);\n   if (dump_file)\n@@ -4294,8 +4301,7 @@ hoist_code (void)\n \t{\n \t  int hoistable = 0;\n \n-\t  if (TEST_BIT (hoist_vbeout[bb->index], i)\n-\t      && TEST_BIT (transpout[bb->index], i))\n+\t  if (TEST_BIT (hoist_vbeout[bb->index], i))\n \t    {\n \t      /* We've found a potentially hoistable expression, now\n \t\t we look at every block BB dominates to see if it"}]}