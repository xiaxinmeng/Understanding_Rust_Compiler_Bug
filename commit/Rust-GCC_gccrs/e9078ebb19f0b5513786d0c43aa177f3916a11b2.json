{"sha": "e9078ebb19f0b5513786d0c43aa177f3916a11b2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTkwNzhlYmIxOWYwYjU1MTM3ODZkMGM0M2FhMTc3ZjM5MTZhMTFiMg==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2012-01-09T13:11:05Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2012-01-09T13:11:05Z"}, "message": "re PR fortran/51578 (Import of same symbol via different modules and renaming)\n\n2012-01-09  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/51578\n        * gfortran.h (gfc_use_list):\n        * match.h (gfc_use_module): Rename to ...\n        (gfc_use_modules): ... this.\n        * module.c (use_locus, specified_nonint, specified_int): Remove\n        global variable.\n        (module_name): Change type to const char*, used with gfc_get_string.\n        (module_list): New global variable.\n        (free_rename): Free argument not global var.\n        (gfc_match_use): Save match to module_list.\n        (load_generic_interfaces, read_module): Don't free symtree.\n        (write_dt_extensions, gfc_dump_module): Fix module-name I/O due to the\n        type change of module_name.\n        (write_symbol0, write_generic): Optimize due to the type change.\n        (import_iso_c_binding_module, use_iso_fortran_env_module): Use\n        locus of rename->where.\n        (gfc_use_module): Take module_list as argument.\n        (gfc_use_modules): New function.\n        (gfc_module_init_2, gfc_module_done_2): Init module_list, rename_list.\n        * parse.c (last_was_use_stmt): New global variable.\n        (use_modules): New function.\n        (decode_specification_statement, decode_statement): Move USE match up\n        and call use_modules.\n        (next_free, next_fixed): Call use_modules.\n        (accept_statement): Don't call gfc_module_use.\n\n2012-01-09  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/51578\n        * gfortran.dg/use_17.f90: New.\n\nFrom-SVN: r183010", "tree": {"sha": "e43530d529621d853c055badf47004cac50a6bf9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e43530d529621d853c055badf47004cac50a6bf9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9078ebb19f0b5513786d0c43aa177f3916a11b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9078ebb19f0b5513786d0c43aa177f3916a11b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9078ebb19f0b5513786d0c43aa177f3916a11b2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9078ebb19f0b5513786d0c43aa177f3916a11b2/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d18a0a84f639bf5c30d0044f2d6941fa2d0e1392", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d18a0a84f639bf5c30d0044f2d6941fa2d0e1392", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d18a0a84f639bf5c30d0044f2d6941fa2d0e1392"}], "stats": {"total": 412, "additions": 309, "deletions": 103}, "files": [{"sha": "a12876c287b640a35e20126b1805db86d7e8be6e", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9078ebb19f0b5513786d0c43aa177f3916a11b2/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9078ebb19f0b5513786d0c43aa177f3916a11b2/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=e9078ebb19f0b5513786d0c43aa177f3916a11b2", "patch": "@@ -1,3 +1,31 @@\n+2012-01-09  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/51578\n+\t* gfortran.h (gfc_use_list):\n+\t* match.h (gfc_use_module): Rename to ...\n+\t(gfc_use_modules): ... this.\n+\t* module.c (use_locus, specified_nonint, specified_int): Remove\n+\tglobal variable.\n+\t(module_name): Change type to const char*, used with gfc_get_string.\n+\t(module_list): New global variable.\n+\t(free_rename): Free argument not global var.\n+\t(gfc_match_use): Save match to module_list.\n+\t(load_generic_interfaces, read_module): Don't free symtree.\n+\t(write_dt_extensions, gfc_dump_module): Fix module-name I/O due to the\n+\ttype change of module_name.\n+\t(write_symbol0, write_generic): Optimize due to the type change.\n+\t(import_iso_c_binding_module, use_iso_fortran_env_module): Use\n+\tlocus of rename->where.\n+\t(gfc_use_module): Take module_list as argument.\n+\t(gfc_use_modules): New function.\n+\t(gfc_module_init_2, gfc_module_done_2): Init module_list, rename_list.\n+\t* parse.c (last_was_use_stmt): New global variable.\n+\t(use_modules): New function.\n+\t(decode_specification_statement, decode_statement): Move USE match up\n+\tand call use_modules.\n+\t(next_free, next_fixed): Call use_modules.\n+\t(accept_statement): Don't call gfc_module_use.\n+\n 2012-01-06  Tobias Burnus <burnus@net-b.de>\n \n \t* trans-openmp.c (gfc_omp_clause_dtor, gfc_trans_omp_array_reduction):"}, {"sha": "f3392712b760d76c3b3013ead86386bae24b6f38", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9078ebb19f0b5513786d0c43aa177f3916a11b2/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9078ebb19f0b5513786d0c43aa177f3916a11b2/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=e9078ebb19f0b5513786d0c43aa177f3916a11b2", "patch": "@@ -1299,7 +1299,9 @@ gfc_use_rename;\n typedef struct gfc_use_list\n {\n   const char *module_name;\n-  int only_flag;\n+  bool intrinsic;\n+  bool non_intrinsic;\n+  bool only_flag;\n   struct gfc_use_rename *rename;\n   locus where;\n   /* Next USE statement.  */"}, {"sha": "c4e7e911d95baf3929e58fb61182a1d96720dde9", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9078ebb19f0b5513786d0c43aa177f3916a11b2/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9078ebb19f0b5513786d0c43aa177f3916a11b2/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=e9078ebb19f0b5513786d0c43aa177f3916a11b2", "patch": "@@ -1,5 +1,5 @@\n /* All matcher functions.\n-   Copyright (C) 2003, 2005, 2007, 2008, 2010\n+   Copyright (C) 2003, 2005, 2007, 2008, 2010, 2012\n    Free Software Foundation, Inc.\n    Contributed by Steven Bosscher\n \n@@ -249,7 +249,7 @@ match gfc_match_expr (gfc_expr **);\n \n /* module.c.  */\n match gfc_match_use (void);\n-void gfc_use_module (void);\n+void gfc_use_modules (void);\n \n #endif  /* GFC_MATCH_H  */\n "}, {"sha": "a68132512e416f966c010e9809fe7848e8722570", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 178, "deletions": 90, "changes": 268, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9078ebb19f0b5513786d0c43aa177f3916a11b2/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9078ebb19f0b5513786d0c43aa177f3916a11b2/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=e9078ebb19f0b5513786d0c43aa177f3916a11b2", "patch": "@@ -1,7 +1,7 @@\n /* Handle modules, which amounts to loading and saving symbols and\n    their attendant structures.\n    Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n-   2009, 2010, 2011\n+   2009, 2010, 2011, 2012\n    Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n@@ -188,10 +188,8 @@ static FILE *module_fp;\n static struct md5_ctx ctx;\n \n /* The name of the module we're reading (USE'ing) or writing.  */\n-static char module_name[GFC_MAX_SYMBOL_LEN + 1];\n-\n-/* The way the module we're reading was specified.  */\n-static bool specified_nonint, specified_int;\n+static const char *module_name;\n+static gfc_use_list *module_list;\n \n static int module_line, module_column, only_flag;\n static int prev_module_line, prev_module_column, prev_character;\n@@ -207,8 +205,6 @@ static int symbol_number;\t/* Counter for assigning symbol numbers */\n /* Tells mio_expr_ref to make symbols for unused equivalence members.  */\n static bool in_load_equiv;\n \n-static locus use_locus;\n-\n \n \n /*****************************************************************/\n@@ -519,14 +515,14 @@ add_fixup (int integer, void *gp)\n /* Free the rename list left behind by a USE statement.  */\n \n static void\n-free_rename (void)\n+free_rename (gfc_use_rename *list)\n {\n   gfc_use_rename *next;\n \n-  for (; gfc_rename_list; gfc_rename_list = next)\n+  for (; list; list = next)\n     {\n-      next = gfc_rename_list->next;\n-      free (gfc_rename_list);\n+      next = list->next;\n+      free (list);\n     }\n }\n \n@@ -541,29 +537,29 @@ gfc_match_use (void)\n   interface_type type, type2;\n   gfc_intrinsic_op op;\n   match m;\n-\n-  specified_int = false;\n-  specified_nonint = false;\n-\n+  gfc_use_list *use_list;\n+ \n+  use_list = gfc_get_use_list ();\n+  \n   if (gfc_match (\" , \") == MATCH_YES)\n     {\n       if ((m = gfc_match (\" %n ::\", module_nature)) == MATCH_YES)\n \t{\n \t  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: module \"\n \t\t\t      \"nature in USE statement at %C\") == FAILURE)\n-\t    return MATCH_ERROR;\n+\t    goto cleanup;\n \n \t  if (strcmp (module_nature, \"intrinsic\") == 0)\n-\t    specified_int = true;\n+\t    use_list->intrinsic = true;\n \t  else\n \t    {\n \t      if (strcmp (module_nature, \"non_intrinsic\") == 0)\n-\t\tspecified_nonint = true;\n+\t\tuse_list->non_intrinsic = true;\n \t      else\n \t\t{\n \t\t  gfc_error (\"Module nature in USE statement at %C shall \"\n \t\t\t     \"be either INTRINSIC or NON_INTRINSIC\");\n-\t\t  return MATCH_ERROR;\n+\t\t  goto cleanup;\n \t\t}\n \t    }\n \t}\n@@ -576,6 +572,7 @@ gfc_match_use (void)\n \t      || strcmp (module_nature, \"non_intrinsic\") == 0)\n \t    gfc_error (\"\\\"::\\\" was expected after module nature at %C \"\n \t\t       \"but was not found\");\n+\t  free (use_list);\n \t  return m;\n \t}\n     }\n@@ -585,35 +582,41 @@ gfc_match_use (void)\n       if (m == MATCH_YES &&\n \t  gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: \"\n \t\t\t  \"\\\"USE :: module\\\" at %C\") == FAILURE)\n-\treturn MATCH_ERROR;\n+\tgoto cleanup;\n \n       if (m != MATCH_YES)\n \t{\n \t  m = gfc_match (\"% \");\n \t  if (m != MATCH_YES)\n-\t    return m;\n+\t    {\n+\t      free (use_list);\n+\t      return m;\n+\t    }\n \t}\n     }\n \n-  use_locus = gfc_current_locus;\n+  use_list->where = gfc_current_locus;\n \n-  m = gfc_match_name (module_name);\n+  m = gfc_match_name (name);\n   if (m != MATCH_YES)\n-    return m;\n+    {\n+      free (use_list);\n+      return m;\n+    }\n \n-  free_rename ();\n-  only_flag = 0;\n+  use_list->module_name = gfc_get_string (name);\n \n   if (gfc_match_eos () == MATCH_YES)\n-    return MATCH_YES;\n+    goto done;\n+\n   if (gfc_match_char (',') != MATCH_YES)\n     goto syntax;\n \n   if (gfc_match (\" only :\") == MATCH_YES)\n-    only_flag = 1;\n+    use_list->only_flag = true;\n \n   if (gfc_match_eos () == MATCH_YES)\n-    return MATCH_YES;\n+    goto done;\n \n   for (;;)\n     {\n@@ -622,8 +625,8 @@ gfc_match_use (void)\n       new_use->where = gfc_current_locus;\n       new_use->found = 0;\n \n-      if (gfc_rename_list == NULL)\n-\tgfc_rename_list = new_use;\n+      if (use_list->rename == NULL)\n+\tuse_list->rename = new_use;\n       else\n \ttail->next = new_use;\n       tail = new_use;\n@@ -653,7 +656,7 @@ gfc_match_use (void)\n \t  if (type == INTERFACE_USER_OP)\n \t    new_use->op = INTRINSIC_USER;\n \n-\t  if (only_flag)\n+\t  if (use_list->only_flag)\n \t    {\n \t      if (m != MATCH_YES)\n \t\tstrcpy (new_use->use_name, name);\n@@ -684,11 +687,11 @@ gfc_match_use (void)\n \t\tgoto cleanup;\n \t    }\n \n-\t  if (strcmp (new_use->use_name, module_name) == 0\n-\t      || strcmp (new_use->local_name, module_name) == 0)\n+\t  if (strcmp (new_use->use_name, use_list->module_name) == 0\n+\t      || strcmp (new_use->local_name, use_list->module_name) == 0)\n \t    {\n \t      gfc_error (\"The name '%s' at %C has already been used as \"\n-\t\t\t \"an external module name.\", module_name);\n+\t\t\t \"an external module name.\", use_list->module_name);\n \t      goto cleanup;\n \t    }\n \t  break;\n@@ -707,15 +710,27 @@ gfc_match_use (void)\n \tgoto syntax;\n     }\n \n+done:\n+  if (module_list)\n+    {\n+      gfc_use_list *last = module_list;\n+      while (last->next)\n+\tlast = last->next;\n+      last->next = use_list;\n+    }\n+  else\n+    module_list = use_list;\n+\n   return MATCH_YES;\n \n syntax:\n   gfc_syntax_error (ST_USE);\n \n cleanup:\n-  free_rename ();\n+  free_rename (use_list->rename);\n+  free (use_list);\n   return MATCH_ERROR;\n- }\n+}\n \n \n /* Given a name and a number, inst, return the inst name\n@@ -4016,20 +4031,7 @@ load_generic_interfaces (void)\n \n \t  if (!sym)\n \t    {\n-\t      /* Make the symbol inaccessible if it has been added by a USE\n-\t\t statement without an ONLY(11.3.2).  */\n-\t      if (st && only_flag\n-\t\t     && !st->n.sym->attr.use_only\n-\t\t     && !st->n.sym->attr.use_rename\n-\t\t     && strcmp (st->n.sym->module, module_name) == 0)\n-\t\t{\n-\t\t  sym = st->n.sym;\n-\t\t  gfc_delete_symtree (&gfc_current_ns->sym_root, name);\n-\t\t  st = gfc_get_unique_symtree (gfc_current_ns);\n-\t\t  st->n.sym = sym;\n-\t\t  sym = NULL;\n-\t\t}\n-\t      else if (st)\n+\t      if (st)\n \t\t{\n \t\t  sym = st->n.sym;\n \t\t  if (strcmp (st->name, p) != 0)\n@@ -4046,7 +4048,7 @@ load_generic_interfaces (void)\n \t\t{\n \t\t  gfc_get_symbol (p, NULL, &sym);\n \t\t  sym->name = gfc_get_string (name);\n-\t\t  sym->module = gfc_get_string (module_name);\n+\t\t  sym->module = module_name;\n \t\t  sym->attr.flavor = FL_PROCEDURE;\n \t\t  sym->attr.generic = 1;\n \t\t  sym->attr.use_assoc = 1;\n@@ -4434,7 +4436,7 @@ check_for_ambiguous (gfc_symbol *st_sym, pointer_info *info)\n      the new symbol is generic there can be no ambiguity.  */\n   if (st_sym->attr.generic\n \t&& st_sym->module\n-\t&& strcmp (st_sym->module, module_name))\n+\t&& st_sym->module != module_name)\n     {\n       /* The new symbol's attributes have not yet been read.  Since\n \t we need attr.generic, read it directly.  */\n@@ -4609,16 +4611,6 @@ read_module (void)\n \t    {\n \t      st = gfc_find_symtree (gfc_current_ns->sym_root, name);\n \n-\t      /* Delete the symtree if the symbol has been added by a USE\n-\t\t statement without an ONLY(11.3.2).  Remember that the rsym\n-\t\t will be the same as the symbol found in the symtree, for\n-\t\t this case.  */\n-\t      if (st && (only_flag || info->u.rsym.renamed)\n-\t\t     && !st->n.sym->attr.use_only\n-\t\t     && !st->n.sym->attr.use_rename\n-\t\t     && info->u.rsym.sym == st->n.sym)\n-\t\tgfc_delete_symtree (&gfc_current_ns->sym_root, name);\n-\n \t      /* Create a symtree node in the current namespace for this\n \t\t symbol.  */\n \t      st = check_unique_name (p)\n@@ -4649,9 +4641,6 @@ read_module (void)\n \t      if (strcmp (name, p) != 0)\n \t\tsym->attr.use_rename = 1;\n \n-\t      /* We need to set the only_flag here so that symbols from the\n-\t\t same USE...ONLY but earlier are not deleted from the tree in\n-\t\t the gfc_delete_symtree above.  */\n \t      sym->attr.use_only = only_flag;\n \n \t      /* Store the symtree pointing to this symbol.  */\n@@ -4976,7 +4965,14 @@ write_dt_extensions (gfc_symtree *st)\n   if (st->n.sym->module != NULL)\n     mio_pool_string (&st->n.sym->module);\n   else\n-    mio_internal_string (module_name);\n+    {\n+      char name[GFC_MAX_SYMBOL_LEN + 1];\n+      if (iomode == IO_OUTPUT)\n+\tstrcpy (name, module_name);\n+      mio_internal_string (name);\n+      if (iomode == IO_INPUT)\n+\tmodule_name = gfc_get_string (name);\n+    }\n   mio_rparen ();\n }\n \n@@ -5051,7 +5047,7 @@ write_symbol0 (gfc_symtree *st)\n \n   sym = st->n.sym;\n   if (sym->module == NULL)\n-    sym->module = gfc_get_string (module_name);\n+    sym->module = module_name;\n \n   if (sym->attr.flavor == FL_PROCEDURE && sym->attr.generic\n       && !sym->attr.subroutine && !sym->attr.function)\n@@ -5142,7 +5138,7 @@ write_generic (gfc_symtree *st)\n     return;\n \n   if (sym->module == NULL)\n-    sym->module = gfc_get_string (module_name);\n+    sym->module = module_name;\n \n   mio_symbol_interface (&st->name, &sym->module, &sym->generic);\n }\n@@ -5378,7 +5374,7 @@ gfc_dump_module (const char *name, int dump_flag)\n \n   /* Write the module itself.  */\n   iomode = IO_OUTPUT;\n-  strcpy (module_name, name);\n+  module_name = gfc_get_string (name);\n \n   init_pi_tree ();\n \n@@ -5537,8 +5533,8 @@ import_iso_c_binding_module (void)\n \n \t    if (not_in_std)\n \t      {\n-\t\tgfc_error (\"The symbol '%s', referenced at %C, is not \"\n-\t\t\t   \"in the selected standard\", name);\n+\t\tgfc_error (\"The symbol '%s', referenced at %L, is not \"\n+\t\t\t   \"in the selected standard\", name, &u->where);\n \t\tcontinue;\n \t      }\n \n@@ -5817,16 +5813,17 @@ use_iso_fortran_env_module (void)\n \t      u->found = 1;\n \n \t      if (gfc_notify_std (symbol[i].standard, \"The symbol '%s', \"\n-\t\t\t\t  \"referenced at %C, is not in the selected \"\n-\t\t\t\t  \"standard\", symbol[i].name) == FAILURE)\n+\t\t\t\t  \"referenced at %L, is not in the selected \"\n+\t\t\t\t  \"standard\", symbol[i].name,\n+\t\t\t\t  &u->where) == FAILURE)\n \t        continue;\n \n \t      if ((gfc_option.flag_default_integer || gfc_option.flag_default_real)\n \t\t  && symbol[i].id == ISOFORTRANENV_NUMERIC_STORAGE_SIZE)\n \t\tgfc_warning_now (\"Use of the NUMERIC_STORAGE_SIZE named \"\n \t\t\t\t \"constant from intrinsic module \"\n-\t\t\t\t \"ISO_FORTRAN_ENV at %C is incompatible with \"\n-\t\t\t\t \"option %s\",\n+\t\t\t\t \"ISO_FORTRAN_ENV at %L is incompatible with \"\n+\t\t\t\t \"option %s\", &u->where,\n \t\t\t\t gfc_option.flag_default_integer\n \t\t\t\t   ? \"-fdefault-integer-8\"\n \t\t\t\t   : \"-fdefault-real-8\");\n@@ -5959,8 +5956,8 @@ use_iso_fortran_env_module (void)\n \n /* Process a USE directive.  */\n \n-void\n-gfc_use_module (void)\n+static void\n+gfc_use_module (gfc_use_list *module)\n {\n   char *filename;\n   gfc_state_data *p;\n@@ -5969,29 +5966,33 @@ gfc_use_module (void)\n   gfc_use_list *use_stmt;\n   locus old_locus = gfc_current_locus;\n \n-  gfc_current_locus = use_locus;\n+  gfc_current_locus = module->where;\n+  module_name = module->module_name;\n+  gfc_rename_list = module->rename;\n+  only_flag = module->only_flag;\n \n-  filename = (char *) alloca (strlen (module_name) + strlen (MODULE_EXTENSION)\n-\t\t\t      + 1);\n+  filename = XALLOCAVEC (char, strlen (module_name) + strlen (MODULE_EXTENSION)\n+\t\t\t       + 1);\n   strcpy (filename, module_name);\n   strcat (filename, MODULE_EXTENSION);\n \n   /* First, try to find an non-intrinsic module, unless the USE statement\n      specified that the module is intrinsic.  */\n   module_fp = NULL;\n-  if (!specified_int)\n+  if (!module->intrinsic)\n     module_fp = gfc_open_included_file (filename, true, true);\n \n   /* Then, see if it's an intrinsic one, unless the USE statement\n      specified that the module is non-intrinsic.  */\n-  if (module_fp == NULL && !specified_nonint)\n+  if (module_fp == NULL && !module->non_intrinsic)\n     {\n       if (strcmp (module_name, \"iso_fortran_env\") == 0\n \t  && gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: ISO_FORTRAN_ENV \"\n \t\t\t     \"intrinsic module at %C\") != FAILURE)\n        {\n \t use_iso_fortran_env_module ();\n \t gfc_current_locus = old_locus;\n+\t module->intrinsic = true;\n \t return;\n        }\n \n@@ -6001,12 +6002,13 @@ gfc_use_module (void)\n \t{\n \t  import_iso_c_binding_module();\n \t  gfc_current_locus = old_locus;\n+\t  module->intrinsic = true;\n \t  return;\n \t}\n \n       module_fp = gfc_open_intrinsic_module (filename);\n \n-      if (module_fp == NULL && specified_int)\n+      if (module_fp == NULL && module->intrinsic)\n \tgfc_fatal_error (\"Can't find an intrinsic module named '%s' at %C\",\n \t\t\t module_name);\n     }\n@@ -6083,18 +6085,101 @@ gfc_use_module (void)\n   fclose (module_fp);\n \n   use_stmt = gfc_get_use_list ();\n-  use_stmt->module_name = gfc_get_string (module_name);\n-  use_stmt->only_flag = only_flag;\n-  use_stmt->rename = gfc_rename_list;\n-  use_stmt->where = use_locus;\n-  gfc_rename_list = NULL;\n+  *use_stmt = *module;\n   use_stmt->next = gfc_current_ns->use_stmts;\n   gfc_current_ns->use_stmts = use_stmt;\n \n   gfc_current_locus = old_locus;\n }\n \n \n+/* Process all USE directives.  */\n+\n+void\n+gfc_use_modules (void)\n+{\n+  gfc_use_list *next, *seek, *last;\n+\n+  for (next = module_list; next; next = next->next)\n+    {\n+      bool non_intrinsic = next->non_intrinsic;\n+      bool intrinsic = next->intrinsic;\n+      bool neither = !non_intrinsic && !intrinsic;\n+\n+      for (seek = next->next; seek; seek = seek->next)\n+\t{\n+\t  if (next->module_name != seek->module_name)\n+\t    continue;\n+\n+\t  if (seek->non_intrinsic)\n+\t    non_intrinsic = true;\n+\t  else if (seek->intrinsic)\n+\t    intrinsic = true;\n+\t  else\n+\t    neither = true;\n+\t}\n+\n+      if (intrinsic && neither && !non_intrinsic)\n+\t{\n+\t  char *filename;\n+          FILE *fp;\n+\n+\t  filename = XALLOCAVEC (char,\n+\t\t\t\t strlen (next->module_name)\n+\t\t\t\t + strlen (MODULE_EXTENSION) + 1);\n+\t  strcpy (filename, next->module_name);\n+\t  strcat (filename, MODULE_EXTENSION);\n+\t  fp = gfc_open_included_file (filename, true, true);\n+\t  if (fp != NULL)\n+\t    {\n+\t      non_intrinsic = true;\n+\t      fclose (fp);\n+\t    }\n+\t}\n+\n+      last = next;\n+      for (seek = next->next; seek; seek = last->next)\n+\t{\n+\t  if (next->module_name != seek->module_name)\n+\t    {\n+\t      last = seek;\n+\t      continue;\n+\t    }\n+\n+\t  if ((!next->intrinsic && !seek->intrinsic)\n+\t      || (next->intrinsic && seek->intrinsic)\n+\t      || !non_intrinsic)\n+\t    {\n+\t      if (!seek->only_flag)\n+\t\tnext->only_flag = false;\n+\t      if (seek->rename)\n+\t\t{\n+\t\t  gfc_use_rename *r = seek->rename;\n+\t\t  while (r->next)\n+\t\t    r = r->next;\n+\t\t  r->next = next->rename;\n+\t\t  next->rename = seek->rename;\n+\t\t}\n+\t      last->next = seek->next; \n+\t      free (seek);\n+\t    }\n+\t  else\n+\t    last = seek;\n+\t}\n+    }\n+\n+  for (; module_list; module_list = next)\n+    {\n+      next = module_list->next;\n+      gfc_use_module (module_list);\n+      if (module_list->intrinsic)\n+\tfree_rename (module_list->rename);\n+      free (module_list);\n+    }\n+  gfc_rename_list = NULL;\n+}\n+\n+\n void\n gfc_free_use_stmts (gfc_use_list *use_stmts)\n {\n@@ -6118,11 +6203,14 @@ void\n gfc_module_init_2 (void)\n {\n   last_atom = ATOM_LPAREN;\n+  gfc_rename_list = NULL;\n+  module_list = NULL;\n }\n \n \n void\n gfc_module_done_2 (void)\n {\n-  free_rename ();\n+  free_rename (gfc_rename_list);\n+  gfc_rename_list = NULL;\n }"}, {"sha": "317fb845479ee7b2deb68c050fbf34f98df56c8c", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 54, "deletions": 10, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9078ebb19f0b5513786d0c43aa177f3916a11b2/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9078ebb19f0b5513786d0c43aa177f3916a11b2/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=e9078ebb19f0b5513786d0c43aa177f3916a11b2", "patch": "@@ -1,6 +1,6 @@\n /* Main parser.\n    Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n-   2009, 2010, 2011\n+   2009, 2010, 2011, 2012\n    Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n@@ -37,6 +37,7 @@ static locus label_locus;\n static jmp_buf eof_buf;\n \n gfc_state_data *gfc_state_stack;\n+static bool last_was_use_stmt = false;\n \n /* TODO: Re-order functions to kill these forward decls.  */\n static void check_statement_label (gfc_statement);\n@@ -74,6 +75,26 @@ match_word (const char *str, match (*subr) (void), locus *old_locus)\n }\n \n \n+/* Load symbols from all USE statements encounted in this scoping unit.  */\n+\n+static void\n+use_modules (void)\n+{\n+  gfc_error_buf old_error;\n+\n+  gfc_push_error (&old_error);\n+  gfc_buffer_error (0);\n+  gfc_use_modules ();\n+  gfc_buffer_error (1);\n+  gfc_pop_error (&old_error);\n+  gfc_commit_symbols ();\n+  gfc_warning_check ();\n+  gfc_current_ns->old_cl_list = gfc_current_ns->cl_list;\n+  gfc_current_ns->old_equiv = gfc_current_ns->equiv;\n+  last_was_use_stmt = false;\n+}\n+\n+\n /* Figure out what the next statement is, (mostly) regardless of\n    proper ordering.  The do...while(0) is there to prevent if/else\n    ambiguity.  */\n@@ -108,8 +129,19 @@ decode_specification_statement (void)\n \n   old_locus = gfc_current_locus;\n \n+  if (match_word (\"use\", gfc_match_use, &old_locus) == MATCH_YES)\n+    {\n+      last_was_use_stmt = true;\n+      return ST_USE;\n+    }\n+  else\n+    {\n+      undo_new_statement ();\n+      if (last_was_use_stmt)\n+\tuse_modules ();\n+    }\n+\n   match (\"import\", gfc_match_import, ST_IMPORT);\n-  match (\"use\", gfc_match_use, ST_USE);\n \n   if (gfc_current_block ()->result->ts.type != BT_DERIVED)\n     goto end_of_block;\n@@ -252,6 +284,22 @@ decode_statement (void)\n \n   old_locus = gfc_current_locus;\n \n+  c = gfc_peek_ascii_char ();\n+\n+  if (c == 'u')\n+    {\n+      if (match_word (\"use\", gfc_match_use, &old_locus) == MATCH_YES)\n+\t{\n+\t  last_was_use_stmt = true;\n+\t  return ST_USE;\n+\t}\n+      else\n+\tundo_new_statement ();\n+    }\n+\n+  if (last_was_use_stmt)\n+    use_modules ();\n+\n   /* Try matching a data declaration or function declaration. The\n       input \"REALFUNCTIONA(N)\" can mean several things in different\n       contexts, so it (and its relatives) get special treatment.  */\n@@ -322,8 +370,6 @@ decode_statement (void)\n      statement, we eliminate most possibilities by peeking at the\n      first character.  */\n \n-  c = gfc_peek_ascii_char ();\n-\n   switch (c)\n     {\n     case 'a':\n@@ -454,7 +500,6 @@ decode_statement (void)\n \n     case 'u':\n       match (\"unlock\", gfc_match_unlock, ST_UNLOCK);\n-      match (\"use\", gfc_match_use, ST_USE);\n       break;\n \n     case 'v':\n@@ -713,6 +758,8 @@ next_free (void)\n \n \t  gcc_assert (c == ' ' || c == '\\t');\n \t  gfc_gobble_whitespace ();\n+\t  if (last_was_use_stmt)\n+\t    use_modules ();\n \t  return decode_omp_directive ();\n \t}\n \n@@ -801,7 +848,8 @@ next_fixed (void)\n \t\t  gfc_error (\"Bad continuation line at %C\");\n \t\t  return ST_NONE;\n \t\t}\n-\n+\t      if (last_was_use_stmt)\n+\t\tuse_modules ();\n \t      return decode_omp_directive ();\n \t    }\n \t  /* FALLTHROUGH */\n@@ -1595,10 +1643,6 @@ accept_statement (gfc_statement st)\n {\n   switch (st)\n     {\n-    case ST_USE:\n-      gfc_use_module ();\n-      break;\n-\n     case ST_IMPLICIT_NONE:\n       gfc_set_implicit_none ();\n       break;"}, {"sha": "bab4f895fb6110ce9e3f85283be4e1f8f613fbd9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9078ebb19f0b5513786d0c43aa177f3916a11b2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9078ebb19f0b5513786d0c43aa177f3916a11b2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e9078ebb19f0b5513786d0c43aa177f3916a11b2", "patch": "@@ -1,3 +1,8 @@\n+2012-01-09  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/51578\n+\t* gfortran.dg/use_17.f90: New.\n+\n 2012-01-09  Gary Funck  <gary@intrepid.com>\n \n \tPR preprocessor/33919"}, {"sha": "b1b002e63161b539e9d3fdf169c908c2ddfec388", "filename": "gcc/testsuite/gfortran.dg/use_17.f90", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9078ebb19f0b5513786d0c43aa177f3916a11b2/gcc%2Ftestsuite%2Fgfortran.dg%2Fuse_17.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9078ebb19f0b5513786d0c43aa177f3916a11b2/gcc%2Ftestsuite%2Fgfortran.dg%2Fuse_17.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fuse_17.f90?ref=e9078ebb19f0b5513786d0c43aa177f3916a11b2", "patch": "@@ -0,0 +1,39 @@\n+! { dg-do compile }\n+!\n+! PR fortran/51578\n+!\n+! Contributed by Billy Backer\n+!\n+! Check that indict importing of the symbol \"axx\" works\n+! even if renaming prevent the direct import.\n+!\n+module mod1\n+integer :: axx=2\n+end module mod1\n+\n+module mod2\n+use mod1\n+end module mod2\n+\n+subroutine sub1\n+use mod1, oxx=>axx\n+use mod2\n+implicit none\n+print*,axx ! Valid - was working before\n+end subroutine sub1\n+\n+subroutine sub2\n+use mod2\n+use mod1, oxx=>axx\n+implicit none\n+print*,axx ! Valid - was failing before\n+end subroutine sub2\n+\n+subroutine test1\n+  use :: iso_c_binding\n+  use, intrinsic :: iso_c_binding, only: c_double_orig => c_double\n+  integer :: c_double\n+  integer, parameter :: p1 = c_int, p2 = c_double_orig\n+end subroutine test1\n+\n+! { dg-final { cleanup-modules \"mod1 mod2\" } }"}]}