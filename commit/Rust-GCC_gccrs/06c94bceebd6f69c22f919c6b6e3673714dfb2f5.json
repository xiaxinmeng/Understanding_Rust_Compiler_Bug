{"sha": "06c94bceebd6f69c22f919c6b6e3673714dfb2f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDZjOTRiY2VlYmQ2ZjY5YzIyZjkxOWM2YjZlMzY3MzcxNGRmYjJmNQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-07-05T03:30:59Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-07-05T03:30:59Z"}, "message": "(store_split_bit_field, extract_split_bit_field):\n\nHandle fields split across more than 2 aligned units.\n\nFrom-SVN: r4840", "tree": {"sha": "2d19aa58ac5fede8a2fb03708c3949d440d8d415", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2d19aa58ac5fede8a2fb03708c3949d440d8d415"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06c94bceebd6f69c22f919c6b6e3673714dfb2f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06c94bceebd6f69c22f919c6b6e3673714dfb2f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06c94bceebd6f69c22f919c6b6e3673714dfb2f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06c94bceebd6f69c22f919c6b6e3673714dfb2f5/comments", "author": null, "committer": null, "parents": [{"sha": "626e18ea3f0de2ff5ed906ceca18a3faf44b1759", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/626e18ea3f0de2ff5ed906ceca18a3faf44b1759", "html_url": "https://github.com/Rust-GCC/gccrs/commit/626e18ea3f0de2ff5ed906ceca18a3faf44b1759"}], "stats": {"total": 243, "additions": 113, "deletions": 130}, "files": [{"sha": "ed07d5ad00faea02e7356c1ebe17b113cca8adea", "filename": "gcc/expmed.c", "status": "modified", "additions": 113, "deletions": 130, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06c94bceebd6f69c22f919c6b6e3673714dfb2f5/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06c94bceebd6f69c22f919c6b6e3673714dfb2f5/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=06c94bceebd6f69c22f919c6b6e3673714dfb2f5", "patch": "@@ -514,10 +514,6 @@ store_fixed_bit_field (op0, offset, bitsize, bitpos, value, struct_align)\n   int all_zero = 0;\n   int all_one = 0;\n \n-  /* Add OFFSET to OP0's address (if it is in memory)\n-     and if a single byte contains the whole bit field\n-     change OP0 to a byte.  */\n-\n   /* There is a case not handled here:\n      a structure with a known alignment of just a halfword\n      and a field split across two aligned halfwords within the structure.\n@@ -532,7 +528,8 @@ store_fixed_bit_field (op0, offset, bitsize, bitpos, value, struct_align)\n       /* Special treatment for a bit field split across two registers.  */\n       if (bitsize + bitpos > BITS_PER_WORD)\n \t{\n-\t  store_split_bit_field (op0, bitsize, bitpos, value, BITS_PER_WORD);\n+\t  store_split_bit_field (op0, bitsize, bitpos,\n+\t\t\t\t value, BITS_PER_WORD);\n \t  return;\n \t}\n     }\n@@ -550,7 +547,8 @@ store_fixed_bit_field (op0, offset, bitsize, bitpos, value, struct_align)\n \t{\n \t  /* The only way this should occur is if the field spans word\n \t     boundaries.  */\n-\t  store_split_bit_field (op0, bitsize, bitpos + offset * BITS_PER_UNIT,\n+\t  store_split_bit_field (op0,\n+\t\t\t\t bitsize, bitpos + offset * BITS_PER_UNIT,\n \t\t\t\t value, struct_align);\n \t  return;\n \t}\n@@ -662,12 +660,16 @@ store_fixed_bit_field (op0, offset, bitsize, bitpos, value, struct_align)\n     emit_move_insn (op0, temp);\n }\n \f\n-/* Store a bit field that is split across two words.\n+/* Store a bit field that is split across multiple accessible memory objects.\n \n-   OP0 is the REG, SUBREG or MEM rtx for the first of the two words.\n+   OP0 is the REG, SUBREG or MEM rtx for the first of the objects.\n    BITSIZE is the field width; BITPOS the position of its first bit\n    (within the word).\n-   VALUE is the value to store.  */\n+   VALUE is the value to store.\n+   ALIGN is the known alignment of OP0, measured in bytes.\n+   This is also the size of the memory objects to be used.\n+\n+   This does not yet handle fields wider than BITS_PER_WORD.  */\n \n static void\n store_split_bit_field (op0, bitsize, bitpos, value, align)\n@@ -676,94 +678,67 @@ store_split_bit_field (op0, bitsize, bitpos, value, align)\n      rtx value;\n      int align;\n {\n-  /* BITSIZE_1 is size of the part in the first word.  */\n-  int bitsize_1 = BITS_PER_WORD - bitpos % BITS_PER_WORD;\n-  /* BITSIZE_2 is size of the rest (in the following word).  */\n-  int bitsize_2 = bitsize - bitsize_1;\n-  rtx part1, part2;\n-  int unit = GET_CODE (op0) == MEM ? BITS_PER_UNIT : BITS_PER_WORD;\n-  int offset = bitpos / unit;\n+  int unit = align * BITS_PER_UNIT;\n   rtx word;\n-\n-  /* The field must span exactly one word boundary.  */\n-  if (bitpos / BITS_PER_WORD != (bitpos + bitsize - 1) / BITS_PER_WORD - 1)\n-    abort ();\n-\n-  if (GET_MODE (value) != VOIDmode)\n-    value = convert_to_mode (word_mode, value, 1);\n+  int bitsdone = 0;\n \n   if (GET_CODE (value) == CONST_DOUBLE\n-      && (part1 = gen_lowpart_common (word_mode, value)) != 0)\n-    value = part1;\n+      && (word = gen_lowpart_common (word_mode, value)) != 0)\n+    value = word;\n \n   if (CONSTANT_P (value) && GET_CODE (value) != CONST_INT)\n     value = copy_to_mode_reg (word_mode, value);\n \n-  /* Split the value into two parts:\n-     PART1 gets that which goes in the first word; PART2 the other.  */\n-#if BYTES_BIG_ENDIAN\n-  /* PART1 gets the more significant part.  */\n-  if (GET_CODE (value) == CONST_INT)\n-    {\n-      part1 = GEN_INT ((unsigned HOST_WIDE_INT) (INTVAL (value)) >> bitsize_2);\n-      part2 = GEN_INT ((unsigned HOST_WIDE_INT) (INTVAL (value))\n-\t\t       & (((HOST_WIDE_INT) 1 << bitsize_2) - 1));\n-    }\n-  else\n+  while (bitsdone < bitsize)\n     {\n-      part1 = extract_fixed_bit_field (word_mode, value, 0, bitsize_1,\n-\t\t\t\t       BITS_PER_WORD - bitsize, NULL_RTX, 1,\n-\t\t\t\t       BITS_PER_WORD);\n-      part2 = extract_fixed_bit_field (word_mode, value, 0, bitsize_2,\n-\t\t\t\t       BITS_PER_WORD - bitsize_2, NULL_RTX, 1,\n-\t\t\t\t       BITS_PER_WORD);\n-    }\n-#else\n-  /* PART1 gets the less significant part.  */\n-  if (GET_CODE (value) == CONST_INT)\n-    {\n-      part1 = GEN_INT ((unsigned HOST_WIDE_INT) (INTVAL (value))\n-\t\t       & (((HOST_WIDE_INT) 1 << bitsize_1) - 1));\n-      part2 = GEN_INT ((unsigned HOST_WIDE_INT) (INTVAL (value)) >> bitsize_1);\n-    }\n-  else\n-    {\n-      part1 = extract_fixed_bit_field (word_mode, value, 0, bitsize_1, 0,\n-\t\t\t\t       NULL_RTX, 1, BITS_PER_WORD);\n-      part2 = extract_fixed_bit_field (word_mode, value, 0, bitsize_2,\n-\t\t\t\t       bitsize_1, NULL_RTX, 1, BITS_PER_WORD);\n-    }\n-#endif\n+      int thissize;\n+      rtx part, word;\n+      int thispos;\n+      int offset;\n \n-  /* Store PART1 into the first word.  If OP0 is a MEM, pass OP0 and the\n-     offset computed above.  Otherwise, get the proper word and pass an\n-     offset of zero.  */\n-  word = (GET_CODE (op0) == MEM ? op0\n-\t  : operand_subword (op0, offset, 1, GET_MODE (op0)));\n-  if (word == 0)\n-    abort ();\n+      offset = (bitpos + bitsdone) / unit;\n+      thispos = (bitpos + bitsdone) % unit;\n \n-  store_fixed_bit_field (word, GET_CODE (op0) == MEM ? offset : 0,\n-\t\t\t bitsize_1, bitpos % unit, part1, align);\n+      thissize = unit - offset * BITS_PER_UNIT % unit;\n \n-  /* Offset op0 by 1 word to get to the following one.  */\n-  if (GET_CODE (op0) == SUBREG)\n-    word = operand_subword (SUBREG_REG (op0), SUBREG_WORD (op0) + offset + 1,\n-\t\t\t    1, VOIDmode);\n-  else if (GET_CODE (op0) == MEM)\n-    word = op0;\n-  else\n-    word = operand_subword (op0, offset + 1, 1, GET_MODE (op0));\n+#if BYTES_BIG_ENDIAN\n+      /* Fetch successively less significant portions.  */\n+      if (GET_CODE (value) == CONST_INT)\n+\tpart = GEN_INT (((unsigned HOST_WIDE_INT) (INTVAL (value))\n+\t\t\t >> (bitsize - bitsdone - thissize))\n+\t\t\t& (((HOST_WIDE_INT) 1 << thissize) - 1));\n+      else\n+\t/* The args are chosen so that the last part\n+\t   includes the lsb.  */\n+\tpart = extract_fixed_bit_field (word_mode, value, 0, thissize,\n+\t\t\t\t\tBITS_PER_WORD - bitsize + bitsdone,\n+\t\t\t\t\tNULL_RTX, 1, align);\n+#else\n+      /* Fetch successively more significant portions.  */\n+      if (GET_CODE (value) == CONST_INT)\n+\tpart = GEN_INT (((unsigned HOST_WIDE_INT) (INTVAL (value)) >> bitsdone)\n+\t\t\t& (((HOST_WIDE_INT) 1 << thissize) - 1));\n+      else\n+\tpart = extract_fixed_bit_field (word_mode, value, 0, thissize,\n+\t\t\t\t\tbitsdone, NULL_RTX, 1, align);\n+#endif\n \n-  if (word == 0)\n-    abort ();\n+      /* If OP0 is a register, then handle OFFSET here.\n+\t In the register case, UNIT must be a whole word.  */\n+      if (GET_CODE (op0) == SUBREG || GET_CODE (op0) == REG)\n+\t{\n+\t  word = operand_subword (op0, offset, 1, GET_MODE (op0));\n+\t  offset = 0;\n+\t}\n+      else\n+\tword = op0;\n \n-  /* Store PART2 into the second word.  */\n-  store_fixed_bit_field (word,\n-\t\t\t (GET_CODE (op0) == MEM\n-\t\t\t  ? CEIL (offset + 1, UNITS_PER_WORD) * UNITS_PER_WORD\n-\t\t\t  : 0),\n-\t\t\t bitsize_2, 0, part2, align);\n+      if (word == 0)\n+\tabort ();\n+\n+      store_fixed_bit_field (word, offset, thissize, thispos, part, align);\n+      bitsdone += thissize;\n+    }\n }\n \f\n /* Generate code to extract a byte-field from STR_RTX\n@@ -1449,65 +1424,73 @@ lshift_value (mode, value, bitpos, bitsize)\n \n    OP0 is the REG, SUBREG or MEM rtx for the first of the two words.\n    BITSIZE is the field width; BITPOS, position of its first bit, in the word.\n-   UNSIGNEDP is 1 if should zero-extend the contents; else sign-extend.  */\n+   UNSIGNEDP is 1 if should zero-extend the contents; else sign-extend.\n+\n+   ALIGN is the known alignment of OP0, measured in bytes.\n+   This is also the size of the memory objects to be used.  */\n \n static rtx\n extract_split_bit_field (op0, bitsize, bitpos, unsignedp, align)\n      rtx op0;\n      int bitsize, bitpos, unsignedp, align;\n {\n-  /* BITSIZE_1 is size of the part in the first word.  */\n-  int bitsize_1 = BITS_PER_WORD - bitpos % BITS_PER_WORD;\n-  /* BITSIZE_2 is size of the rest (in the following word).  */\n-  int bitsize_2 = bitsize - bitsize_1;\n-  rtx part1, part2, result;\n-  int unit = GET_CODE (op0) == MEM ? BITS_PER_UNIT : BITS_PER_WORD;\n-  int offset = bitpos / unit;\n-  rtx word;\n- \n-  /* The field must span exactly one word boundary.  */\n-  if (bitpos / BITS_PER_WORD != (bitpos + bitsize - 1) / BITS_PER_WORD - 1)\n-    abort ();\n+  int unit = align * BITS_PER_UNIT;\n+  int bitsdone = 0;\n+  rtx result;\n+  int first = 1;\n \n-  /* Get the part of the bit field from the first word.  If OP0 is a MEM,\n-     pass OP0 and the offset computed above.  Otherwise, get the proper\n-     word and pass an offset of zero.  */\n-  word = (GET_CODE (op0) == MEM ? op0\n-\t  : operand_subword_force (op0, offset, GET_MODE (op0)));\n-  part1 = extract_fixed_bit_field (word_mode, word,\n-\t\t\t\t   GET_CODE (op0) == MEM ? offset : 0,\n-\t\t\t\t   bitsize_1, bitpos % unit, NULL_RTX,\n-\t\t\t\t   1, align);\n-\n-  /* Offset op0 by 1 word to get to the following one.  */\n-  if (GET_CODE (op0) == SUBREG)\n-    word = operand_subword_force (SUBREG_REG (op0),\n-\t\t\t\t  SUBREG_WORD (op0) + offset + 1, VOIDmode);\n-  else if (GET_CODE (op0) == MEM)\n-    word = op0;\n-  else\n-    word = operand_subword_force (op0, offset + 1, GET_MODE (op0));\n+  while (bitsdone < bitsize)\n+    {\n+      int thissize;\n+      rtx part, word;\n+      int thispos;\n+      int offset;\n+\n+      offset = (bitpos + bitsdone) / unit;\n+      thispos = (bitpos + bitsdone) % unit;\n+\n+      thissize = unit - offset * BITS_PER_UNIT % unit;\n+\n+      /* If OP0 is a register, then handle OFFSET here.\n+\t In the register case, UNIT must be a whole word.  */\n+      if (GET_CODE (op0) == SUBREG || GET_CODE (op0) == REG)\n+\t{\n+\t  word = operand_subword_force (op0, offset, GET_MODE (op0));\n+\t  offset = 0;\n+\t}\n+      else\n+\tword = op0;\n+\n+      if (word == 0)\n+\tabort ();\n \n-  /* Get the part of the bit field from the second word.  */\n-  part2 = extract_fixed_bit_field (word_mode, word,\n-\t\t\t\t   (GET_CODE (op0) == MEM\n-\t\t\t\t    ? CEIL (offset + 1, UNITS_PER_WORD) * UNITS_PER_WORD\n-\t\t\t\t    : 0),\n-\t\t\t\t   bitsize_2, 0, NULL_RTX, 1, align);\n+      /* Extract the parts in bit-counting order,\n+\t whose meaning is determined by BYTES_PER_UNIT.  */\n+      part = extract_fixed_bit_field (word_mode, word, offset,\n+\t\t\t\t      thissize, thispos, 0, 1, align);\n+      bitsdone += thissize;\n \n-  /* Shift the more significant part up to fit above the other part.  */\n+      /* Shift this part into place for the result.  */\n #if BYTES_BIG_ENDIAN\n-  part1 = expand_shift (LSHIFT_EXPR, word_mode, part1,\n-\t\t\tbuild_int_2 (bitsize_2, 0), 0, 1);\n+      if (bitsize != bitsdone)\n+\tpart = expand_shift (LSHIFT_EXPR, word_mode, part,\n+\t\t\t     build_int_2 (bitsize - bitsdone, 0), 0, 1);\n #else\n-  part2 = expand_shift (LSHIFT_EXPR, word_mode, part2,\n-\t\t\tbuild_int_2 (bitsize_1, 0), 0, 1);\n+      if (bitsdone != 0)\n+\tpart = expand_shift (LSHIFT_EXPR, word_mode, part,\n+\t\t\t     build_int_2 (bitsdone, 0), 0, 1);\n #endif\n \n-  /* Combine the two parts with bitwise or.  This works\n-     because we extracted both parts as unsigned bit fields.  */\n-  result = expand_binop (word_mode, ior_optab, part1, part2, NULL_RTX, 1,\n-\t\t\t OPTAB_LIB_WIDEN);\n+      if (first)\n+\tresult = part;\n+      else\n+\t/* Combine the parts with bitwise or.  This works\n+\t   because we extracted each part as an unsigned bit field.  */\n+\tresult = expand_binop (word_mode, ior_optab, part, result, NULL_RTX, 1,\n+\t\t\t       OPTAB_LIB_WIDEN);\n+\n+      first = 0;\n+    }\n \n   /* Unsigned bit field: we are done.  */\n   if (unsignedp)"}]}