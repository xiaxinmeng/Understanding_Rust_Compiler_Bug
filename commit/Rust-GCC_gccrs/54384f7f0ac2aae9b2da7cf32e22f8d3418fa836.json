{"sha": "54384f7f0ac2aae9b2da7cf32e22f8d3418fa836", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQzODRmN2YwYWMyYWFlOWIyZGE3Y2YzMmUyMmY4ZDM0MThmYTgzNg==", "commit": {"author": {"name": "Johannes Singler", "email": "singler@ira.uka.de", "date": "2009-09-16T13:50:17Z"}, "committer": {"name": "Johannes Singler", "email": "singler@gcc.gnu.org", "date": "2009-09-16T13:50:17Z"}, "message": "base.h (_EqualFromLess): Correct uglification of member variables and method arguments.\n\n2009-09-16  Johannes Singler  <singler@ira.uka.de>\n\n        * include/parallel/base.h (_EqualFromLess):\n        Correct uglification of member variables and method arguments.\n        * include/parallel/balanced_quicksort.h (_QSBThreadLocal): Likewise.\n        * include/parallel/find_selectors.h (__find_first_of_selector):\n        Likewise.\n        * include/parallel/iterator.h (_IteratorTriple): Likewise.\n        * include/parallel/multiseq_selection.h\n        (_Lexicographic, _LexicographicReverse): Likewise.\n        * include/parallel/multiway_mergesort.h (_Piece, _PMWMSSortingData):\n        Likewise.\n        * include/parallel/random_number.h (_RandomNumber): Likewise.\n        * include/parallel/random_shuffle.h (_DRandomShufflingGlobalData):\n        Likewise.\n        * include/parallel/set_operations.h (__symmetric_difference_func,\n        __difference_func, __intersection_func, __union_func,\n        parallel_set_union, parallel_set_intersection, parallel_set_difference,\n        parallel_set_symmetric_difference): Likewise.\n        * include/parallel/tags.h (parallel_tag): Likewise.\n        * include/parallel/workstealing.h (_Job): Likewise.\n        * include/parallel/multiway_merge.h\n        (__multiway_merge_k_variant_sentinel_switch:operator())\n        correct uglification of _*LoserTree*.\n        * include/parallel/losertree.h (_*LoserTree*): Likewise; correct\n        uglification of member variables and method arguments.\n        * include/parallel/par_loop.h: Correct uglification of finish_iterator.\n        * include/parallel/for_each_selectors.h: Likewise.\n        * include/parallel/omp_loop.h: Likewise.\n        * include/parallel/algo.h: Likewise; uglify c_rand_number.\n\nFrom-SVN: r151754", "tree": {"sha": "c9d0da1d3abba12bdb115d975ce34cdddd306255", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c9d0da1d3abba12bdb115d975ce34cdddd306255"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/54384f7f0ac2aae9b2da7cf32e22f8d3418fa836", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54384f7f0ac2aae9b2da7cf32e22f8d3418fa836", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54384f7f0ac2aae9b2da7cf32e22f8d3418fa836", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54384f7f0ac2aae9b2da7cf32e22f8d3418fa836/comments", "author": null, "committer": null, "parents": [{"sha": "e038c37bb97c516378e39af6b04625dd6751ec00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e038c37bb97c516378e39af6b04625dd6751ec00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e038c37bb97c516378e39af6b04625dd6751ec00"}], "stats": {"total": 949, "additions": 490, "deletions": 459}, "files": [{"sha": "ce55b2f7ad6061ef6e47f00599e142176cd4a9aa", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54384f7f0ac2aae9b2da7cf32e22f8d3418fa836/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54384f7f0ac2aae9b2da7cf32e22f8d3418fa836/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=54384f7f0ac2aae9b2da7cf32e22f8d3418fa836", "patch": "@@ -1,3 +1,34 @@\n+2009-09-16  Johannes Singler  <singler@ira.uka.de>\n+\n+        * include/parallel/base.h (_EqualFromLess):\n+        Correct uglification of member variables and method arguments.\n+        * include/parallel/balanced_quicksort.h (_QSBThreadLocal): Likewise.\n+        * include/parallel/find_selectors.h (__find_first_of_selector):\n+        Likewise.\n+        * include/parallel/iterator.h (_IteratorTriple): Likewise.\n+        * include/parallel/multiseq_selection.h\n+        (_Lexicographic, _LexicographicReverse): Likewise.\n+        * include/parallel/multiway_mergesort.h (_Piece, _PMWMSSortingData):\n+        Likewise.\n+        * include/parallel/random_number.h (_RandomNumber): Likewise.\n+        * include/parallel/random_shuffle.h (_DRandomShufflingGlobalData):\n+        Likewise.\n+        * include/parallel/set_operations.h (__symmetric_difference_func,\n+        __difference_func, __intersection_func, __union_func,\n+        parallel_set_union, parallel_set_intersection, parallel_set_difference,\n+        parallel_set_symmetric_difference): Likewise.\n+        * include/parallel/tags.h (parallel_tag): Likewise.\n+        * include/parallel/workstealing.h (_Job): Likewise.\n+        * include/parallel/multiway_merge.h\n+        (__multiway_merge_k_variant_sentinel_switch:operator())\n+        correct uglification of _*LoserTree*.\n+        * include/parallel/losertree.h (_*LoserTree*): Likewise; correct\n+        uglification of member variables and method arguments.\n+        * include/parallel/par_loop.h: Correct uglification of finish_iterator.\n+        * include/parallel/for_each_selectors.h: Likewise.\n+        * include/parallel/omp_loop.h: Likewise.\n+        * include/parallel/algo.h: Likewise; uglify c_rand_number.\n+\n 2009-09-16  Johannes Singler  <singler@ira.uka.de>\n \n         * include/parallel/base.h (_PseudoSequenceIterator, _PseudoSequence):"}, {"sha": "a94962d13f50190678099adf656d02cf9891b068", "filename": "libstdc++-v3/include/parallel/algo.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54384f7f0ac2aae9b2da7cf32e22f8d3418fa836/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54384f7f0ac2aae9b2da7cf32e22f8d3418fa836/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgo.h?ref=54384f7f0ac2aae9b2da7cf32e22f8d3418fa836", "patch": "@@ -1229,7 +1229,7 @@ namespace __parallel\n                                             unary_op, __functionality,\n                                             __gnu_parallel::_DummyReduct(),\n                                             __dummy, __dummy, -1, __parallelism_tag);\n-          return __functionality.finish_iterator;\n+          return __functionality._M_finish_iterator;\n         }\n       else\n         return transform(__begin, __end, __result, unary_op, \n@@ -1322,7 +1322,7 @@ namespace __parallel\n                                             __gnu_parallel::_DummyReduct(),\n                                             __dummy, __dummy, -1,\n                                             __parallelism_tag);\n-          return __functionality.finish_iterator;\n+          return __functionality._M_finish_iterator;\n         }\n       else\n         return transform(__begin1, __end1, __begin2, __result, __binary_op, \n@@ -1629,7 +1629,7 @@ namespace __parallel\n \n   /** @brief Functor wrapper for std::rand(). */\n   template<typename _MustBeInt = int>\n-    struct c_rand_number\n+    struct _CRandNumber\n     {\n       int\n       operator()(int __limit)\n@@ -1641,7 +1641,7 @@ namespace __parallel\n     inline void\n     random_shuffle(_RAIter __begin, _RAIter __end)\n     {\n-      c_rand_number<> __r;\n+      _CRandNumber<> __r;\n       // Parallelization still possible.\n       __gnu_parallel::random_shuffle(__begin, __end, __r);\n     }"}, {"sha": "6a6f6a240ec1581ff46f00137e2ef030bf310112", "filename": "libstdc++-v3/include/parallel/balanced_quicksort.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54384f7f0ac2aae9b2da7cf32e22f8d3418fa836/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbalanced_quicksort.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54384f7f0ac2aae9b2da7cf32e22f8d3418fa836/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbalanced_quicksort.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbalanced_quicksort.h?ref=54384f7f0ac2aae9b2da7cf32e22f8d3418fa836", "patch": "@@ -75,7 +75,7 @@ template<typename _RAIter>\n     _RestrictedBoundedConcurrentQueue<_Piece> _M_leftover_parts;\n \n     /** @brief Number of threads involved in this algorithm. */\n-    _ThreadIndex __num_threads;\n+    _ThreadIndex _M_num_threads;\n \n     /** @brief Pointer to a counter of elements left over to sort. */\n     volatile _DifferenceType* _M_elements_leftover;\n@@ -250,7 +250,7 @@ template<typename _RAIter, typename _Compare>\n         _Settings::get().sort_qsb_base_case_maximal_n;\n     if (__base_case_n < 2)\n       __base_case_n = 2;\n-    _ThreadIndex __num_threads = __tl.__num_threads;\n+    _ThreadIndex __num_threads = __tl._M_num_threads;\n \n     // Every thread has its own random number generator.\n     _RandomNumber __rng(__iam + 1);\n@@ -451,7 +451,7 @@ template<typename _RAIter, typename _Compare>\n     for (int __i = 0; __i < __num_threads; ++__i)\n       {\n         __tls[__i]->_M_elements_leftover = &_M_elements_leftover;\n-        __tls[__i]->__num_threads = __num_threads;\n+        __tls[__i]->_M_num_threads = __num_threads;\n         __tls[__i]->_M_global = std::make_pair(__begin, __end);\n \n         // Just in case nothing is left to assign."}, {"sha": "80232bc283ba83f5fd650d93f381a4dd56cb432e", "filename": "libstdc++-v3/include/parallel/base.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54384f7f0ac2aae9b2da7cf32e22f8d3418fa836/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54384f7f0ac2aae9b2da7cf32e22f8d3418fa836/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbase.h?ref=54384f7f0ac2aae9b2da7cf32e22f8d3418fa836", "patch": "@@ -159,14 +159,14 @@ template<typename _Compare, typename _T1, typename _T2>\n   class _EqualFromLess : public std::binary_function<_T1, _T2, bool>\n   {\n   private:\n-    _Compare& __comp;\n+    _Compare& _M_comp;\n \n   public:\n-    _EqualFromLess(_Compare& _comp) : __comp(_comp) { }\n+    _EqualFromLess(_Compare& __comp) : _M_comp(__comp) { }\n \n     bool operator()(const _T1& __a, const _T2& __b)\n     {\n-      return !__comp(__a, __b) && !__comp(__b, __a);\n+      return !_M_comp(__a, __b) && !_M_comp(__b, __a);\n     }\n   };\n "}, {"sha": "8dda9c601610497c534450eabca2537eaa63b2a8", "filename": "libstdc++-v3/include/parallel/find_selectors.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54384f7f0ac2aae9b2da7cf32e22f8d3418fa836/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffind_selectors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54384f7f0ac2aae9b2da7cf32e22f8d3418fa836/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffind_selectors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffind_selectors.h?ref=54384f7f0ac2aae9b2da7cf32e22f8d3418fa836", "patch": "@@ -151,11 +151,11 @@ namespace __gnu_parallel\n   template<typename _ForwardIterator>\n   struct __find_first_of_selector : public __generic_find_selector\n   {\n-    _ForwardIterator __begin;\n-    _ForwardIterator __end;\n+    _ForwardIterator _M_begin;\n+    _ForwardIterator _M_end;\n \n     explicit __find_first_of_selector(_ForwardIterator __begin, _ForwardIterator __end)\n-    : __begin(__begin), __end(__end) { }\n+    : _M_begin(__begin), _M_end(__end) { }\n \n     /** @brief Test on one __position.\n      *  @param __i1 _Iterator on first sequence.\n@@ -166,8 +166,8 @@ namespace __gnu_parallel\n       bool \n       operator()(_RAIter1 __i1, _RAIter2 __i2, _Pred __pred)\n       {\n-\tfor (_ForwardIterator __pos_in_candidates = __begin;\n-\t     __pos_in_candidates != __end; ++__pos_in_candidates)\n+\tfor (_ForwardIterator __pos_in_candidates = _M_begin;\n+\t     __pos_in_candidates != _M_end; ++__pos_in_candidates)\n \t  if (__pred(*__i1, *__pos_in_candidates))\n \t    return true;\n \treturn false;\n@@ -184,7 +184,7 @@ namespace __gnu_parallel\n       _M_sequential_algorithm(_RAIter1 __begin1,\n \t\t\t   _RAIter1 __end1,\n \t\t\t   _RAIter2 __begin2, _Pred __pred)\n-      { return std::make_pair(find_first_of(__begin1, __end1, __begin, __end, __pred,\n+      { return std::make_pair(find_first_of(__begin1, __end1, _M_begin, _M_end, __pred,\n \t\t\t\t\t    sequential_tag()), __begin2); }\n   };\n }"}, {"sha": "ae12c945d3ce37c1b99acb11c43b010a8ca88705", "filename": "libstdc++-v3/include/parallel/for_each_selectors.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54384f7f0ac2aae9b2da7cf32e22f8d3418fa836/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffor_each_selectors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54384f7f0ac2aae9b2da7cf32e22f8d3418fa836/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffor_each_selectors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffor_each_selectors.h?ref=54384f7f0ac2aae9b2da7cf32e22f8d3418fa836", "patch": "@@ -45,7 +45,7 @@ namespace __gnu_parallel\n     /** @brief _Iterator on last element processed; needed for some\n      *  algorithms (e. g. std::transform()).\n      */\n-    _It finish_iterator;\n+    _It _M_finish_iterator;\n   };\n \n \n@@ -124,7 +124,7 @@ namespace __gnu_parallel\n         bool\n         operator()(_Op& __o, _It __i)\n \t{\n-\t  *__i.__third = __o(*__i.__first, *__i.__second);\n+\t  *__i._M_third = __o(*__i._M_first, *__i._M_second);\n \t  return true;\n \t}\n     };"}, {"sha": "c49ade2ca75a37644093e52182b37ba0cb6ac0fa", "filename": "libstdc++-v3/include/parallel/iterator.h", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54384f7f0ac2aae9b2da7cf32e22f8d3418fa836/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fiterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54384f7f0ac2aae9b2da7cf32e22f8d3418fa836/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fiterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fiterator.h?ref=54384f7f0ac2aae9b2da7cf32e22f8d3418fa836", "patch": "@@ -125,70 +125,70 @@ namespace __gnu_parallel\n       typedef _IteratorTriple* pointer;\n       typedef _IteratorTriple& reference;\n \n-      _Iterator1 __first;\n-      _Iterator2 __second;\n-      _Iterator3 __third;\n+      _Iterator1 _M_first;\n+      _Iterator2 _M_second;\n+      _Iterator3 _M_third;\n \n       _IteratorTriple() { }\n \n-      _IteratorTriple(const _Iterator1& _first, const _Iterator2& _second,\n-\t\t      const _Iterator3& _third)\n+      _IteratorTriple(const _Iterator1& __first, const _Iterator2& __second,\n+\t\t      const _Iterator3& __third)\n       {\n-\t__first = _first;\n-\t__second = _second;\n-\t__third = _third;\n+\t_M_first = __first;\n+\t_M_second = __second;\n+\t_M_third = __third;\n       }\n \n       // Pre-increment operator.\n       _IteratorTriple&\n       operator++()\n       {\n-\t++__first;\n-\t++__second;\n-\t++__third;\n+\t++_M_first;\n+\t++_M_second;\n+\t++_M_third;\n \treturn *this;\n       }\n \n       // Post-increment operator.\n       const _IteratorTriple\n       operator++(int)\n-      { return _IteratorTriple(__first++, __second++, __third++); }\n+      { return _IteratorTriple(_M_first++, _M_second++, _M_third++); }\n \n       // Pre-decrement operator.\n       _IteratorTriple&\n       operator--()\n       {\n-\t--__first;\n-\t--__second;\n-\t--__third;\n+\t--_M_first;\n+\t--_M_second;\n+\t--_M_third;\n \treturn *this;\n       }\n \n       // Post-decrement operator.\n       const _IteratorTriple\n       operator--(int)\n-      { return _IteratorTriple(__first--, __second--, __third--); }\n+      { return _IteratorTriple(_M_first--, _M_second--, _M_third--); }\n \n       // Type conversion.\n       operator _Iterator3() const\n-      { return __third; }\n+      { return _M_third; }\n \n       _IteratorTriple&\n       operator=(const _IteratorTriple& __other)\n       {\n-\t__first = __other.__first;\n-\t__second = __other.__second;\n-\t__third = __other.__third;\n+\t_M_first = __other._M_first;\n+\t_M_second = __other._M_second;\n+\t_M_third = __other._M_third;\n \treturn *this;\n       }\n \n       _IteratorTriple\n       operator+(difference_type __delta) const\n-      { return _IteratorTriple(__first + __delta, __second + __delta, __third + __delta); }\n+      { return _IteratorTriple(_M_first + __delta, _M_second + __delta, _M_third + __delta); }\n \n       difference_type\n       operator-(const _IteratorTriple& __other) const\n-      { return __first - __other.__first; }\n+      { return _M_first - __other._M_first; }\n   };\n }\n "}, {"sha": "33a4070e9a8827c96bcbd6522e57f4942a4de5ef", "filename": "libstdc++-v3/include/parallel/losertree.h", "status": "modified", "additions": 284, "deletions": 284, "changes": 568, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54384f7f0ac2aae9b2da7cf32e22f8d3418fa836/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flosertree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54384f7f0ac2aae9b2da7cf32e22f8d3418fa836/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flosertree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flosertree.h?ref=54384f7f0ac2aae9b2da7cf32e22f8d3418fa836", "patch": "@@ -54,70 +54,70 @@ namespace __gnu_parallel\n  * @param _Compare the comparator to use, defaults to std::less<_Tp>\n  */\n template<typename _Tp, typename _Compare>\n-class LoserTreeBase\n+class _LoserTreeBase\n {\n protected:\n-  /** @brief Internal representation of a LoserTree element. */\n+  /** @brief Internal representation of a _LoserTree element. */\n   struct _Loser\n   {\n     /** @brief flag, true iff this is a \"maximum\" __sentinel. */\n     bool _M_sup;\n     /** @brief __index of the _M_source __sequence. */\n     int _M_source;\n-    /** @brief _M_key of the element in the LoserTree. */\n+    /** @brief _M_key of the element in the _LoserTree. */\n     _Tp _M_key;\n   };\n \n-  unsigned int __ik, __k, __offset;\n+  unsigned int _M_ik, _M_k, _M_offset;\n \n-  /** log_2{__k} */\n+  /** log_2{_M_k} */\n   unsigned int _M_log_k;\n \n-  /** @brief LoserTree __elements. */\n-  _Loser* __losers;\n+  /** @brief _LoserTree __elements. */\n+  _Loser* _M_losers;\n \n   /** @brief _Compare to use. */\n-  _Compare __comp;\n+  _Compare _M_comp;\n \n   /**\n-   * @brief State flag that determines whether the LoserTree is empty.\n+   * @brief State flag that determines whether the _LoserTree is empty.\n    *\n-   * Only used for building the LoserTree.\n+   * Only used for building the _LoserTree.\n    */\n-  bool __first_insert;\n+  bool _M_first_insert;\n \n public:\n   /**\n    * @brief The constructor.\n    *\n-   * @param _k The number of sequences to merge.\n-   * @param _comp The comparator to use.\n+   * @param __k The number of sequences to merge.\n+   * @param __comp The comparator to use.\n    */\n-  LoserTreeBase(unsigned int _k, _Compare _comp)\n-  : __comp(_comp)\n+  _LoserTreeBase(unsigned int __k, _Compare __comp)\n+  : _M_comp(__comp)\n   {\n-    __ik = _k;\n+    _M_ik = __k;\n \n-    // Compute log_2{__k} for the _Loser Tree\n-    _M_log_k = __log2(__ik - 1) + 1;\n+    // Compute log_2{_M_k} for the _Loser Tree\n+    _M_log_k = __log2(_M_ik - 1) + 1;\n \n     // Next greater power of 2.\n-    __k = 1 << _M_log_k;\n-    __offset = __k;\n+    _M_k = 1 << _M_log_k;\n+    _M_offset = _M_k;\n \n-    // Avoid default-constructing __losers[]._M_key\n-    __losers = static_cast<_Loser*>(::operator new(2 * __k * sizeof(_Loser)));\n-    for (unsigned int __i = __ik - 1; __i < __k; ++__i)\n-      __losers[__i + __k]._M_sup = true;\n+    // Avoid default-constructing _M_losers[]._M_key\n+    _M_losers = static_cast<_Loser*>(::operator new(2 * _M_k * sizeof(_Loser)));\n+    for (unsigned int __i = _M_ik - 1; __i < _M_k; ++__i)\n+      _M_losers[__i + _M_k]._M_sup = true;\n \n-    __first_insert = true;\n+    _M_first_insert = true;\n   }\n \n   /**\n    * @brief The destructor.\n    */\n-  ~LoserTreeBase()\n-  { ::operator delete(__losers); }\n+  ~_LoserTreeBase()\n+  { ::operator delete(_M_losers); }\n \n   /**\n    * @brief Initializes the sequence \"_M_source\" with the element \"_M_key\".\n@@ -130,80 +130,80 @@ class LoserTreeBase\n   inline void\n   __insert_start(const _Tp& _M_key, int _M_source, bool _M_sup)\n   {\n-    unsigned int __pos = __k + _M_source;\n+    unsigned int __pos = _M_k + _M_source;\n \n-    if(__first_insert)\n+    if(_M_first_insert)\n       {\n         // Construct all keys, so we can easily deconstruct them.\n-        for (unsigned int __i = 0; __i < (2 * __k); ++__i)\n-          new(&(__losers[__i]._M_key)) _Tp(_M_key);\n-        __first_insert = false;\n+        for (unsigned int __i = 0; __i < (2 * _M_k); ++__i)\n+          new(&(_M_losers[__i]._M_key)) _Tp(_M_key);\n+        _M_first_insert = false;\n       }\n     else\n-      new(&(__losers[__pos]._M_key)) _Tp(_M_key);\n+      new(&(_M_losers[__pos]._M_key)) _Tp(_M_key);\n \n-    __losers[__pos]._M_sup = _M_sup;\n-    __losers[__pos]._M_source = _M_source;\n+    _M_losers[__pos]._M_sup = _M_sup;\n+    _M_losers[__pos]._M_source = _M_source;\n   }\n \n   /**\n    * @return the index of the sequence with the smallest element.\n    */\n   int __get_min_source()\n-  { return __losers[0]._M_source; }\n+  { return _M_losers[0]._M_source; }\n };\n \n /**\n- * @brief Stable LoserTree variant.\n+ * @brief Stable _LoserTree variant.\n  *\n  * Provides the stable implementations of insert_start, __init_winner,\n  * __init and __delete_min_insert.\n  *\n  * Unstable variant is done using partial specialisation below.\n  */\n template<bool __stable/* default == true */, typename _Tp, typename _Compare>\n-class LoserTree : public LoserTreeBase<_Tp, _Compare>\n+class _LoserTree : public _LoserTreeBase<_Tp, _Compare>\n {\n-  typedef LoserTreeBase<_Tp, _Compare> Base;\n-  using Base::__k;\n-  using Base::__losers;\n-  using Base::__first_insert;\n+  typedef _LoserTreeBase<_Tp, _Compare> Base;\n+  using Base::_M_k;\n+  using Base::_M_losers;\n+  using Base::_M_first_insert;\n \n public:\n-  LoserTree(unsigned int _k, _Compare _comp)\n-  : Base::LoserTreeBase(_k, _comp)\n+  _LoserTree(unsigned int __k, _Compare __comp)\n+  : Base::_LoserTreeBase(__k, __comp)\n   {}\n \n   unsigned int\n   __init_winner(unsigned int __root)\n   {\n-    if (__root >= __k)\n+    if (__root >= _M_k)\n       {\n         return __root;\n       }\n     else\n       {\n         unsigned int __left = __init_winner (2 * __root);\n         unsigned int __right = __init_winner (2 * __root + 1);\n-        if (__losers[__right]._M_sup\n-            || (!__losers[__left]._M_sup\n-              && !__comp(__losers[__right]._M_key, __losers[__left]._M_key)))\n+        if (_M_losers[__right]._M_sup\n+            || (!_M_losers[__left]._M_sup\n+              && !_M_comp(_M_losers[__right]._M_key, _M_losers[__left]._M_key)))\n           {\n             // Left one is less or equal.\n-            __losers[__root] = __losers[__right];\n+            _M_losers[__root] = _M_losers[__right];\n             return __left;\n           }\n         else\n           {\n             // Right one is less.\n-            __losers[__root] = __losers[__left];\n+            _M_losers[__root] = _M_losers[__left];\n             return __right;\n           }\n       }\n   }\n \n   void __init()\n-  { __losers[0] = __losers[__init_winner(1)]; }\n+  { _M_losers[0] = _M_losers[__init_winner(1)]; }\n \n   /**\n    * @brief Delete the smallest element and insert a new element from\n@@ -216,50 +216,50 @@ class LoserTree : public LoserTreeBase<_Tp, _Compare>\n   {\n #if _GLIBCXX_ASSERTIONS\n     // no dummy sequence can ever be at the top!\n-    _GLIBCXX_PARALLEL_ASSERT(__losers[0]._M_source != -1);\n+    _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n #endif\n \n-    int _M_source = __losers[0]._M_source;\n-    for (unsigned int __pos = (__k + _M_source) / 2; __pos > 0; __pos /= 2)\n+    int _M_source = _M_losers[0]._M_source;\n+    for (unsigned int __pos = (_M_k + _M_source) / 2; __pos > 0; __pos /= 2)\n       {\n         // The smaller one gets promoted, ties are broken by _M_source.\n-        if ((_M_sup && (!__losers[__pos]._M_sup || __losers[__pos]._M_source < _M_source))\n-              || (!_M_sup && !__losers[__pos]._M_sup\n-                && ((__comp(__losers[__pos]._M_key, _M_key))\n-                  || (!__comp(_M_key, __losers[__pos]._M_key)\n-                    && __losers[__pos]._M_source < _M_source))))\n+        if ((_M_sup && (!_M_losers[__pos]._M_sup || _M_losers[__pos]._M_source < _M_source))\n+              || (!_M_sup && !_M_losers[__pos]._M_sup\n+                && ((_M_comp(_M_losers[__pos]._M_key, _M_key))\n+                  || (!_M_comp(_M_key, _M_losers[__pos]._M_key)\n+                    && _M_losers[__pos]._M_source < _M_source))))\n           {\n             // The other one is smaller.\n-            std::swap(__losers[__pos]._M_sup, _M_sup);\n-            std::swap(__losers[__pos]._M_source, _M_source);\n-            std::swap(__losers[__pos]._M_key, _M_key);\n+            std::swap(_M_losers[__pos]._M_sup, _M_sup);\n+            std::swap(_M_losers[__pos]._M_source, _M_source);\n+            std::swap(_M_losers[__pos]._M_key, _M_key);\n           }\n       }\n \n-    __losers[0]._M_sup = _M_sup;\n-    __losers[0]._M_source = _M_source;\n-    __losers[0]._M_key = _M_key;\n+    _M_losers[0]._M_sup = _M_sup;\n+    _M_losers[0]._M_source = _M_source;\n+    _M_losers[0]._M_key = _M_key;\n   }\n };\n \n /**\n- * @brief Unstable LoserTree variant.\n+ * @brief Unstable _LoserTree variant.\n  *\n  * Stability (non-stable here) is selected with partial specialization.\n  */\n template<typename _Tp, typename _Compare>\n-class LoserTree</* __stable == */false, _Tp, _Compare> :\n-    public LoserTreeBase<_Tp, _Compare>\n+class _LoserTree</* __stable == */false, _Tp, _Compare> :\n+    public _LoserTreeBase<_Tp, _Compare>\n {\n-  typedef LoserTreeBase<_Tp, _Compare> Base;\n+  typedef _LoserTreeBase<_Tp, _Compare> Base;\n   using Base::_M_log_k;\n-  using Base::__k;\n-  using Base::__losers;\n-  using Base::__first_insert;\n+  using Base::_M_k;\n+  using Base::_M_losers;\n+  using Base::_M_first_insert;\n \n public:\n-  LoserTree(unsigned int _k, _Compare _comp)\n-  : Base::LoserTreeBase(_k, _comp)\n+  _LoserTree(unsigned int __k, _Compare __comp)\n+  : Base::_LoserTreeBase(__k, __comp)\n   {}\n \n   /**\n@@ -272,34 +272,34 @@ class LoserTree</* __stable == */false, _Tp, _Compare> :\n   unsigned int\n   __init_winner (unsigned int __root)\n   {\n-    if (__root >= __k)\n+    if (__root >= _M_k)\n       {\n         return __root;\n       }\n     else\n       {\n         unsigned int __left = __init_winner (2 * __root);\n         unsigned int __right = __init_winner (2 * __root + 1);\n-        if (__losers[__right]._M_sup ||\n-            (!__losers[__left]._M_sup\n-              && !__comp(__losers[__right]._M_key, __losers[__left]._M_key)))\n+        if (_M_losers[__right]._M_sup ||\n+            (!_M_losers[__left]._M_sup\n+              && !_M_comp(_M_losers[__right]._M_key, _M_losers[__left]._M_key)))\n           {\n             // Left one is less or equal.\n-            __losers[__root] = __losers[__right];\n+            _M_losers[__root] = _M_losers[__right];\n             return __left;\n           }\n         else\n           {\n             // Right one is less.\n-            __losers[__root] = __losers[__left];\n+            _M_losers[__root] = _M_losers[__left];\n             return __right;\n           }\n       }\n   }\n \n   inline void\n   __init()\n-  { __losers[0] = __losers[__init_winner(1)]; }\n+  { _M_losers[0] = _M_losers[__init_winner(1)]; }\n \n   /**\n    * Delete the _M_key smallest element and insert the element _M_key instead.\n@@ -313,25 +313,25 @@ class LoserTree</* __stable == */false, _Tp, _Compare> :\n   {\n #if _GLIBCXX_ASSERTIONS\n     // no dummy sequence can ever be at the top!\n-    _GLIBCXX_PARALLEL_ASSERT(__losers[0]._M_source != -1);\n+    _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n #endif\n \n-    int _M_source = __losers[0]._M_source;\n-    for (unsigned int __pos = (__k + _M_source) / 2; __pos > 0; __pos /= 2)\n+    int _M_source = _M_losers[0]._M_source;\n+    for (unsigned int __pos = (_M_k + _M_source) / 2; __pos > 0; __pos /= 2)\n     {\n         // The smaller one gets promoted.\n-      if (_M_sup || (!__losers[__pos]._M_sup && __comp(__losers[__pos]._M_key, _M_key)))\n+      if (_M_sup || (!_M_losers[__pos]._M_sup && _M_comp(_M_losers[__pos]._M_key, _M_key)))\n       {\n             // The other one is smaller.\n-        std::swap(__losers[__pos]._M_sup, _M_sup);\n-        std::swap(__losers[__pos]._M_source, _M_source);\n-        std::swap(__losers[__pos]._M_key, _M_key);\n+        std::swap(_M_losers[__pos]._M_sup, _M_sup);\n+        std::swap(_M_losers[__pos]._M_source, _M_source);\n+        std::swap(_M_losers[__pos]._M_key, _M_key);\n       }\n     }\n \n-    __losers[0]._M_sup = _M_sup;\n-    __losers[0]._M_source = _M_source;\n-    __losers[0]._M_key = _M_key;\n+    _M_losers[0]._M_sup = _M_sup;\n+    _M_losers[0]._M_source = _M_source;\n+    _M_losers[0]._M_key = _M_key;\n   }\n };\n \n@@ -343,129 +343,129 @@ template<typename _Tp, typename _Compare>\n class _LoserTreePointerBase\n {\n protected:\n-  /** @brief Internal representation of LoserTree __elements. */\n+  /** @brief Internal representation of _LoserTree __elements. */\n   struct _Loser\n   {\n     bool _M_sup;\n     int _M_source;\n     const _Tp* _M_keyp;\n   };\n \n-  unsigned int __ik, __k, __offset;\n-  _Loser* __losers;\n-  _Compare __comp;\n+  unsigned int _M_ik, _M_k, _M_offset;\n+  _Loser* _M_losers;\n+  _Compare _M_comp;\n \n public:\n-  _LoserTreePointerBase(unsigned int _k, _Compare _comp = std::less<_Tp>())\n-    : __comp(_comp)\n+  _LoserTreePointerBase(unsigned int __k, _Compare __comp = std::less<_Tp>())\n+    : _M_comp(__comp)\n   {\n-    __ik = _k;\n+    _M_ik = __k;\n \n     // Next greater power of 2.\n-    __k = 1 << (__log2(__ik - 1) + 1);\n-    __offset = __k;\n-    __losers = new _Loser[__k * 2];\n-    for (unsigned int __i = __ik - 1; __i < __k; __i++)\n-      __losers[__i + __k]._M_sup = true;\n+    _M_k = 1 << (__log2(_M_ik - 1) + 1);\n+    _M_offset = _M_k;\n+    _M_losers = new _Loser[_M_k * 2];\n+    for (unsigned int __i = _M_ik - 1; __i < _M_k; __i++)\n+      _M_losers[__i + _M_k]._M_sup = true;\n   }\n \n   ~_LoserTreePointerBase()\n-  { ::operator delete[](__losers); }\n+  { ::operator delete[](_M_losers); }\n \n   int __get_min_source()\n-  { return __losers[0]._M_source; }\n+  { return _M_losers[0]._M_source; }\n \n   void __insert_start(const _Tp& _M_key, int _M_source, bool _M_sup)\n   {\n-    unsigned int __pos = __k + _M_source;\n+    unsigned int __pos = _M_k + _M_source;\n \n-    __losers[__pos]._M_sup = _M_sup;\n-    __losers[__pos]._M_source = _M_source;\n-    __losers[__pos]._M_keyp = &_M_key;\n+    _M_losers[__pos]._M_sup = _M_sup;\n+    _M_losers[__pos]._M_source = _M_source;\n+    _M_losers[__pos]._M_keyp = &_M_key;\n   }\n };\n \n /**\n- * @brief Stable LoserTree implementation.\n+ * @brief Stable _LoserTree implementation.\n  *\n  * The unstable variant is implemented using partial instantiation below.\n  */\n template<bool __stable/* default == true */, typename _Tp, typename _Compare>\n class _LoserTreePointer : public _LoserTreePointerBase<_Tp, _Compare>\n {\n   typedef _LoserTreePointerBase<_Tp, _Compare> Base;\n-  using Base::__k;\n-  using Base::__losers;\n+  using Base::_M_k;\n+  using Base::_M_losers;\n \n public:\n-  _LoserTreePointer(unsigned int _k, _Compare _comp = std::less<_Tp>())\n-    : Base::_LoserTreePointerBase(_k, _comp)\n+  _LoserTreePointer(unsigned int __k, _Compare __comp = std::less<_Tp>())\n+    : Base::_LoserTreePointerBase(__k, __comp)\n   {}\n \n   unsigned int\n   __init_winner(unsigned int __root)\n   {\n-    if (__root >= __k)\n+    if (__root >= _M_k)\n       {\n         return __root;\n       }\n     else\n       {\n         unsigned int __left = __init_winner (2 * __root);\n         unsigned int __right = __init_winner (2 * __root + 1);\n-        if (__losers[__right]._M_sup\n-            || (!__losers[__left]._M_sup && !__comp(*__losers[__right]._M_keyp,\n-                                          *__losers[__left]._M_keyp)))\n+        if (_M_losers[__right]._M_sup\n+            || (!_M_losers[__left]._M_sup && !_M_comp(*_M_losers[__right]._M_keyp,\n+                                          *_M_losers[__left]._M_keyp)))\n           {\n             // Left one is less or equal.\n-            __losers[__root] = __losers[__right];\n+            _M_losers[__root] = _M_losers[__right];\n             return __left;\n           }\n         else\n           {\n             // Right one is less.\n-            __losers[__root] = __losers[__left];\n+            _M_losers[__root] = _M_losers[__left];\n             return __right;\n           }\n       }\n   }\n \n   void __init()\n-  { __losers[0] = __losers[__init_winner(1)]; }\n+  { _M_losers[0] = _M_losers[__init_winner(1)]; }\n \n   void __delete_min_insert(const _Tp& _M_key, bool _M_sup)\n   {\n #if _GLIBCXX_ASSERTIONS\n     // no dummy sequence can ever be at the top!\n-    _GLIBCXX_PARALLEL_ASSERT(__losers[0]._M_source != -1);\n+    _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n #endif\n \n     const _Tp* _M_keyp = &_M_key;\n-    int _M_source = __losers[0]._M_source;\n-    for (unsigned int __pos = (__k + _M_source) / 2; __pos > 0; __pos /= 2)\n+    int _M_source = _M_losers[0]._M_source;\n+    for (unsigned int __pos = (_M_k + _M_source) / 2; __pos > 0; __pos /= 2)\n       {\n         // The smaller one gets promoted, ties are broken by _M_source.\n-        if ((_M_sup && (!__losers[__pos]._M_sup || __losers[__pos]._M_source < _M_source)) ||\n-              (!_M_sup && !__losers[__pos]._M_sup &&\n-              ((__comp(*__losers[__pos]._M_keyp, *_M_keyp)) ||\n-                (!__comp(*_M_keyp, *__losers[__pos]._M_keyp)\n-                && __losers[__pos]._M_source < _M_source))))\n+        if ((_M_sup && (!_M_losers[__pos]._M_sup || _M_losers[__pos]._M_source < _M_source)) ||\n+              (!_M_sup && !_M_losers[__pos]._M_sup &&\n+              ((_M_comp(*_M_losers[__pos]._M_keyp, *_M_keyp)) ||\n+                (!_M_comp(*_M_keyp, *_M_losers[__pos]._M_keyp)\n+                && _M_losers[__pos]._M_source < _M_source))))\n           {\n             // The other one is smaller.\n-            std::swap(__losers[__pos]._M_sup, _M_sup);\n-            std::swap(__losers[__pos]._M_source, _M_source);\n-            std::swap(__losers[__pos]._M_keyp, _M_keyp);\n+            std::swap(_M_losers[__pos]._M_sup, _M_sup);\n+            std::swap(_M_losers[__pos]._M_source, _M_source);\n+            std::swap(_M_losers[__pos]._M_keyp, _M_keyp);\n           }\n       }\n \n-    __losers[0]._M_sup = _M_sup;\n-    __losers[0]._M_source = _M_source;\n-    __losers[0]._M_keyp = _M_keyp;\n+    _M_losers[0]._M_sup = _M_sup;\n+    _M_losers[0]._M_source = _M_source;\n+    _M_losers[0]._M_keyp = _M_keyp;\n   }\n };\n \n /**\n- * @brief Unstable LoserTree implementation.\n+ * @brief Unstable _LoserTree implementation.\n  *\n  * The stable variant is above.\n  */\n@@ -474,73 +474,73 @@ class _LoserTreePointer</* __stable == */false, _Tp, _Compare> :\n     public _LoserTreePointerBase<_Tp, _Compare>\n {\n   typedef _LoserTreePointerBase<_Tp, _Compare> Base;\n-  using Base::__k;\n-  using Base::__losers;\n+  using Base::_M_k;\n+  using Base::_M_losers;\n \n public:\n-  _LoserTreePointer(unsigned int _k, _Compare _comp = std::less<_Tp>())\n-    : Base::_LoserTreePointerBase(_k, _comp)\n+  _LoserTreePointer(unsigned int __k, _Compare __comp = std::less<_Tp>())\n+    : Base::_LoserTreePointerBase(__k, __comp)\n   {}\n \n   unsigned int\n   __init_winner(unsigned int __root)\n   {\n-    if (__root >= __k)\n+    if (__root >= _M_k)\n       {\n         return __root;\n       }\n     else\n       {\n         unsigned int __left = __init_winner (2 * __root);\n         unsigned int __right = __init_winner (2 * __root + 1);\n-        if (__losers[__right]._M_sup\n-              || (!__losers[__left]._M_sup\n-                && !__comp(*__losers[__right]._M_keyp, *__losers[__left]._M_keyp)))\n+        if (_M_losers[__right]._M_sup\n+              || (!_M_losers[__left]._M_sup\n+                && !_M_comp(*_M_losers[__right]._M_keyp, *_M_losers[__left]._M_keyp)))\n           {\n             // Left one is less or equal.\n-            __losers[__root] = __losers[__right];\n+            _M_losers[__root] = _M_losers[__right];\n             return __left;\n           }\n         else\n           {\n             // Right one is less.\n-            __losers[__root] = __losers[__left];\n+            _M_losers[__root] = _M_losers[__left];\n             return __right;\n           }\n       }\n   }\n \n   void __init()\n-  { __losers[0] = __losers[__init_winner(1)]; }\n+  { _M_losers[0] = _M_losers[__init_winner(1)]; }\n \n   void __delete_min_insert(const _Tp& _M_key, bool _M_sup)\n   {\n #if _GLIBCXX_ASSERTIONS\n     // no dummy sequence can ever be at the top!\n-    _GLIBCXX_PARALLEL_ASSERT(__losers[0]._M_source != -1);\n+    _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n #endif\n \n     const _Tp* _M_keyp = &_M_key;\n-    int _M_source = __losers[0]._M_source;\n-    for (unsigned int __pos = (__k + _M_source) / 2; __pos > 0; __pos /= 2)\n+    int _M_source = _M_losers[0]._M_source;\n+    for (unsigned int __pos = (_M_k + _M_source) / 2; __pos > 0; __pos /= 2)\n       {\n         // The smaller one gets promoted.\n-        if (_M_sup || (!__losers[__pos]._M_sup && __comp(*__losers[__pos]._M_keyp, *_M_keyp)))\n+        if (_M_sup || (!_M_losers[__pos]._M_sup && _M_comp(*_M_losers[__pos]._M_keyp, *_M_keyp)))\n           {\n             // The other one is smaller.\n-            std::swap(__losers[__pos]._M_sup, _M_sup);\n-            std::swap(__losers[__pos]._M_source, _M_source);\n-            std::swap(__losers[__pos]._M_keyp, _M_keyp);\n+            std::swap(_M_losers[__pos]._M_sup, _M_sup);\n+            std::swap(_M_losers[__pos]._M_source, _M_source);\n+            std::swap(_M_losers[__pos]._M_keyp, _M_keyp);\n           }\n       }\n \n-    __losers[0]._M_sup = _M_sup;\n-    __losers[0]._M_source = _M_source;\n-    __losers[0]._M_keyp = _M_keyp;\n+    _M_losers[0]._M_sup = _M_sup;\n+    _M_losers[0]._M_source = _M_source;\n+    _M_losers[0]._M_keyp = _M_keyp;\n   }\n };\n \n-/** @brief Base class for unguarded LoserTree implementation.\n+/** @brief Base class for unguarded _LoserTree implementation.\n  * \n  * The whole element is copied into the tree structure.\n  *\n@@ -560,93 +560,93 @@ class _LoserTreeUnguardedBase\n     _Tp _M_key;\n   };\n \n-  unsigned int __ik, __k, __offset;\n-  _Loser* __losers;\n-  _Compare __comp;\n+  unsigned int _M_ik, _M_k, _M_offset;\n+  _Loser* _M_losers;\n+  _Compare _M_comp;\n \n public:\n   inline\n-  _LoserTreeUnguardedBase(unsigned int _k, const _Tp _sentinel,\n-                         _Compare _comp = std::less<_Tp>())\n-    : __comp(_comp)\n+  _LoserTreeUnguardedBase(unsigned int __k, const _Tp _sentinel,\n+                         _Compare __comp = std::less<_Tp>())\n+    : _M_comp(__comp)\n   {\n-    __ik = _k;\n+    _M_ik = __k;\n \n     // Next greater power of 2.\n-    __k = 1 << (__log2(__ik - 1) + 1);\n-    __offset = __k;\n-    // Avoid default-constructing __losers[]._M_key\n-    __losers = static_cast<_Loser*>(::operator new(2 * __k * sizeof(_Loser)));\n+    _M_k = 1 << (__log2(_M_ik - 1) + 1);\n+    _M_offset = _M_k;\n+    // Avoid default-constructing _M_losers[]._M_key\n+    _M_losers = static_cast<_Loser*>(::operator new(2 * _M_k * sizeof(_Loser)));\n \n-    for (unsigned int __i = __k + __ik - 1; __i < (2 * __k); ++__i)\n+    for (unsigned int __i = _M_k + _M_ik - 1; __i < (2 * _M_k); ++__i)\n       {\n-        __losers[__i]._M_key = _sentinel;\n-        __losers[__i]._M_source = -1;\n+        _M_losers[__i]._M_key = _sentinel;\n+        _M_losers[__i]._M_source = -1;\n       }\n   }\n \n   inline ~_LoserTreeUnguardedBase()\n-  { ::operator delete(__losers); }\n+  { ::operator delete(_M_losers); }\n \n   inline int\n   __get_min_source()\n   {\n #if _GLIBCXX_ASSERTIONS\n     // no dummy sequence can ever be at the top!\n-    _GLIBCXX_PARALLEL_ASSERT(__losers[0]._M_source != -1);\n+    _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n #endif\n-    return __losers[0]._M_source;\n+    return _M_losers[0]._M_source;\n   }\n \n   inline void\n   __insert_start(const _Tp& _M_key, int _M_source, bool)\n   {\n-    unsigned int __pos = __k + _M_source;\n+    unsigned int __pos = _M_k + _M_source;\n \n-    new(&(__losers[__pos]._M_key)) _Tp(_M_key);\n-    __losers[__pos]._M_source = _M_source;\n+    new(&(_M_losers[__pos]._M_key)) _Tp(_M_key);\n+    _M_losers[__pos]._M_source = _M_source;\n   }\n };\n \n /**\n- * @brief Stable implementation of unguarded LoserTree.\n+ * @brief Stable implementation of unguarded _LoserTree.\n  *\n  * Unstable variant is selected below with partial specialization.\n  */\n template<bool __stable/* default == true */, typename _Tp, typename _Compare>\n class _LoserTreeUnguarded : public _LoserTreeUnguardedBase<_Tp, _Compare>\n {\n   typedef _LoserTreeUnguardedBase<_Tp, _Compare> Base;\n-  using Base::__k;\n-  using Base::__losers;\n+  using Base::_M_k;\n+  using Base::_M_losers;\n \n public:\n-  _LoserTreeUnguarded(unsigned int _k, const _Tp _sentinel,\n-                     _Compare _comp = std::less<_Tp>())\n-    : Base::_LoserTreeUnguardedBase(_k, _sentinel, _comp)\n+  _LoserTreeUnguarded(unsigned int __k, const _Tp _sentinel,\n+                     _Compare __comp = std::less<_Tp>())\n+    : Base::_LoserTreeUnguardedBase(__k, _sentinel, __comp)\n   {}\n \n   unsigned int\n   __init_winner(unsigned int __root)\n   {\n-    if (__root >= __k)\n+    if (__root >= _M_k)\n       {\n         return __root;\n       }\n     else\n       {\n         unsigned int __left = __init_winner (2 * __root);\n         unsigned int __right = __init_winner (2 * __root + 1);\n-        if (!__comp(__losers[__right]._M_key, __losers[__left]._M_key))\n+        if (!_M_comp(_M_losers[__right]._M_key, _M_losers[__left]._M_key))\n           {\n             // Left one is less or equal.\n-            __losers[__root] = __losers[__right];\n+            _M_losers[__root] = _M_losers[__right];\n             return __left;\n           }\n         else\n           {\n             // Right one is less.\n-            __losers[__root] = __losers[__left];\n+            _M_losers[__root] = _M_losers[__left];\n             return __right;\n           }\n       }\n@@ -655,11 +655,11 @@ class _LoserTreeUnguarded : public _LoserTreeUnguardedBase<_Tp, _Compare>\n   inline void\n   __init()\n   {\n-    __losers[0] = __losers[__init_winner(1)];\n+    _M_losers[0] = _M_losers[__init_winner(1)];\n \n #if _GLIBCXX_ASSERTIONS\n     // no dummy sequence can ever be at the top at the beginning (0 sequences!)\n-    _GLIBCXX_PARALLEL_ASSERT(__losers[0]._M_source != -1);\n+    _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n #endif\n   }\n \n@@ -669,29 +669,29 @@ class _LoserTreeUnguarded : public _LoserTreeUnguardedBase<_Tp, _Compare>\n   {\n #if _GLIBCXX_ASSERTIONS\n     // no dummy sequence can ever be at the top!\n-    _GLIBCXX_PARALLEL_ASSERT(__losers[0]._M_source != -1);\n+    _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n #endif\n \n-    int _M_source = __losers[0]._M_source;\n-    for (unsigned int __pos = (__k + _M_source) / 2; __pos > 0; __pos /= 2)\n+    int _M_source = _M_losers[0]._M_source;\n+    for (unsigned int __pos = (_M_k + _M_source) / 2; __pos > 0; __pos /= 2)\n       {\n         // The smaller one gets promoted, ties are broken by _M_source.\n-        if (__comp(__losers[__pos]._M_key, _M_key)\n-              || (!__comp(_M_key, __losers[__pos]._M_key) && __losers[__pos]._M_source < _M_source))\n+        if (_M_comp(_M_losers[__pos]._M_key, _M_key)\n+              || (!_M_comp(_M_key, _M_losers[__pos]._M_key) && _M_losers[__pos]._M_source < _M_source))\n           {\n             // The other one is smaller.\n-            std::swap(__losers[__pos]._M_source, _M_source);\n-            std::swap(__losers[__pos]._M_key, _M_key);\n+            std::swap(_M_losers[__pos]._M_source, _M_source);\n+            std::swap(_M_losers[__pos]._M_key, _M_key);\n           }\n       }\n \n-    __losers[0]._M_source = _M_source;\n-    __losers[0]._M_key = _M_key;\n+    _M_losers[0]._M_source = _M_source;\n+    _M_losers[0]._M_key = _M_key;\n   }\n };\n \n /**\n- * @brief Non-Stable implementation of unguarded LoserTree.\n+ * @brief Non-Stable implementation of unguarded _LoserTree.\n  *\n  * Stable implementation is above.\n  */\n@@ -700,19 +700,19 @@ class _LoserTreeUnguarded</* __stable == */false, _Tp, _Compare> :\n     public _LoserTreeUnguardedBase<_Tp, _Compare>\n {\n   typedef _LoserTreeUnguardedBase<_Tp, _Compare> Base;\n-  using Base::__k;\n-  using Base::__losers;\n+  using Base::_M_k;\n+  using Base::_M_losers;\n \n public:\n-  _LoserTreeUnguarded(unsigned int _k, const _Tp _sentinel,\n-                     _Compare _comp = std::less<_Tp>())\n-    : Base::_LoserTreeUnguardedBase(_k, _sentinel, _comp)\n+  _LoserTreeUnguarded(unsigned int __k, const _Tp _sentinel,\n+                     _Compare __comp = std::less<_Tp>())\n+    : Base::_LoserTreeUnguardedBase(__k, _sentinel, __comp)\n   {}\n \n   unsigned int\n   __init_winner (unsigned int __root)\n   {\n-    if (__root >= __k)\n+    if (__root >= _M_k)\n       {\n         return __root;\n       }\n@@ -723,20 +723,20 @@ class _LoserTreeUnguarded</* __stable == */false, _Tp, _Compare> :\n \n #if _GLIBCXX_ASSERTIONS\n         // If __left one is sentinel then __right one must be, too.\n-        if (__losers[__left]._M_source == -1)\n-          _GLIBCXX_PARALLEL_ASSERT(__losers[__right]._M_source == -1);\n+        if (_M_losers[__left]._M_source == -1)\n+          _GLIBCXX_PARALLEL_ASSERT(_M_losers[__right]._M_source == -1);\n #endif\n \n-        if (!__comp(__losers[__right]._M_key, __losers[__left]._M_key))\n+        if (!_M_comp(_M_losers[__right]._M_key, _M_losers[__left]._M_key))\n           {\n             // Left one is less or equal.\n-            __losers[__root] = __losers[__right];\n+            _M_losers[__root] = _M_losers[__right];\n             return __left;\n           }\n         else\n           {\n             // Right one is less.\n-            __losers[__root] = __losers[__left];\n+            _M_losers[__root] = _M_losers[__left];\n             return __right;\n           }\n       }\n@@ -745,11 +745,11 @@ class _LoserTreeUnguarded</* __stable == */false, _Tp, _Compare> :\n   inline void\n   __init()\n   {\n-    __losers[0] = __losers[__init_winner(1)];\n+    _M_losers[0] = _M_losers[__init_winner(1)];\n \n #if _GLIBCXX_ASSERTIONS\n     // no dummy sequence can ever be at the top at the beginning (0 sequences!)\n-    _GLIBCXX_PARALLEL_ASSERT(__losers[0]._M_source != -1);\n+    _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n #endif\n   }\n \n@@ -759,23 +759,23 @@ class _LoserTreeUnguarded</* __stable == */false, _Tp, _Compare> :\n   {\n #if _GLIBCXX_ASSERTIONS\n     // no dummy sequence can ever be at the top!\n-    _GLIBCXX_PARALLEL_ASSERT(__losers[0]._M_source != -1);\n+    _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n #endif\n \n-    int _M_source = __losers[0]._M_source;\n-    for (unsigned int __pos = (__k + _M_source) / 2; __pos > 0; __pos /= 2)\n+    int _M_source = _M_losers[0]._M_source;\n+    for (unsigned int __pos = (_M_k + _M_source) / 2; __pos > 0; __pos /= 2)\n       {\n         // The smaller one gets promoted.\n-        if (__comp(__losers[__pos]._M_key, _M_key))\n+        if (_M_comp(_M_losers[__pos]._M_key, _M_key))\n           {\n             // The other one is smaller.\n-            std::swap(__losers[__pos]._M_source, _M_source);\n-            std::swap(__losers[__pos]._M_key, _M_key);\n+            std::swap(_M_losers[__pos]._M_source, _M_source);\n+            std::swap(_M_losers[__pos]._M_key, _M_key);\n           }\n       }\n \n-    __losers[0]._M_source = _M_source;\n-    __losers[0]._M_key = _M_key;\n+    _M_losers[0]._M_source = _M_source;\n+    _M_losers[0]._M_key = _M_key;\n   }\n };\n \n@@ -795,57 +795,57 @@ class LoserTreePointerUnguardedBase\n     const _Tp* _M_keyp;\n   };\n \n-  unsigned int __ik, __k, __offset;\n-  _Loser* __losers;\n-  _Compare __comp;\n+  unsigned int _M_ik, _M_k, _M_offset;\n+  _Loser* _M_losers;\n+  _Compare _M_comp;\n \n public:\n \n   inline\n-  LoserTreePointerUnguardedBase(unsigned int _k, const _Tp& _sentinel,\n-      _Compare _comp = std::less<_Tp>())\n-    : __comp(_comp)\n+  LoserTreePointerUnguardedBase(unsigned int __k, const _Tp& _sentinel,\n+      _Compare __comp = std::less<_Tp>())\n+    : _M_comp(__comp)\n   {\n-    __ik = _k;\n+    _M_ik = __k;\n \n     // Next greater power of 2.\n-    __k = 1 << (__log2(__ik - 1) + 1);\n-    __offset = __k;\n-    // Avoid default-constructing __losers[]._M_key\n-    __losers = new _Loser[2 * __k];\n+    _M_k = 1 << (__log2(_M_ik - 1) + 1);\n+    _M_offset = _M_k;\n+    // Avoid default-constructing _M_losers[]._M_key\n+    _M_losers = new _Loser[2 * _M_k];\n \n-    for (unsigned int __i = __k + __ik - 1; __i < (2 * __k); ++__i)\n+    for (unsigned int __i = _M_k + _M_ik - 1; __i < (2 * _M_k); ++__i)\n       {\n-        __losers[__i]._M_keyp = &_sentinel;\n-        __losers[__i]._M_source = -1;\n+        _M_losers[__i]._M_keyp = &_sentinel;\n+        _M_losers[__i]._M_source = -1;\n       }\n   }\n \n   inline ~LoserTreePointerUnguardedBase()\n-  { delete[] __losers; }\n+  { delete[] _M_losers; }\n \n   inline int\n   __get_min_source()\n   {\n #if _GLIBCXX_ASSERTIONS\n     // no dummy sequence can ever be at the top!\n-    _GLIBCXX_PARALLEL_ASSERT(__losers[0]._M_source != -1);\n+    _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n #endif\n-    return __losers[0]._M_source;\n+    return _M_losers[0]._M_source;\n   }\n \n   inline void\n   __insert_start(const _Tp& _M_key, int _M_source, bool)\n   {\n-    unsigned int __pos = __k + _M_source;\n+    unsigned int __pos = _M_k + _M_source;\n \n-    __losers[__pos]._M_keyp = &_M_key;\n-    __losers[__pos]._M_source = _M_source;\n+    _M_losers[__pos]._M_keyp = &_M_key;\n+    _M_losers[__pos]._M_source = _M_source;\n   }\n };\n \n /**\n- * @brief Stable unguarded LoserTree variant storing pointers.\n+ * @brief Stable unguarded _LoserTree variant storing pointers.\n  *\n  * Unstable variant is implemented below using partial specialization.\n  */\n@@ -854,36 +854,36 @@ class LoserTreePointerUnguarded :\n     public LoserTreePointerUnguardedBase<_Tp, _Compare>\n {\n   typedef LoserTreePointerUnguardedBase<_Tp, _Compare> Base;\n-  using Base::__k;\n-  using Base::__losers;\n+  using Base::_M_k;\n+  using Base::_M_losers;\n \n public:\n-  LoserTreePointerUnguarded(unsigned int _k, const _Tp& _sentinel,\n-      _Compare _comp = std::less<_Tp>())\n-    : Base::LoserTreePointerUnguardedBase(_k, _sentinel, _comp)\n+  LoserTreePointerUnguarded(unsigned int __k, const _Tp& _sentinel,\n+      _Compare __comp = std::less<_Tp>())\n+    : Base::LoserTreePointerUnguardedBase(__k, _sentinel, __comp)\n   {}\n \n   unsigned int\n   __init_winner(unsigned int __root)\n   {\n-    if (__root >= __k)\n+    if (__root >= _M_k)\n       {\n         return __root;\n       }\n     else\n       {\n         unsigned int __left = __init_winner (2 * __root);\n         unsigned int __right = __init_winner (2 * __root + 1);\n-        if (!__comp(*__losers[__right]._M_keyp, *__losers[__left]._M_keyp))\n+        if (!_M_comp(*_M_losers[__right]._M_keyp, *_M_losers[__left]._M_keyp))\n           {\n             // Left one is less or equal.\n-            __losers[__root] = __losers[__right];\n+            _M_losers[__root] = _M_losers[__right];\n             return __left;\n           }\n         else\n           {\n             // Right one is less.\n-            __losers[__root] = __losers[__left];\n+            _M_losers[__root] = _M_losers[__left];\n             return __right;\n           }\n       }\n@@ -892,11 +892,11 @@ class LoserTreePointerUnguarded :\n   inline void\n   __init()\n   {\n-    __losers[0] = __losers[__init_winner(1)];\n+    _M_losers[0] = _M_losers[__init_winner(1)];\n \n #if _GLIBCXX_ASSERTIONS\n     // no dummy sequence can ever be at the top at the beginning (0 sequences!)\n-    _GLIBCXX_PARALLEL_ASSERT(__losers[0]._M_source != -1);\n+    _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n #endif\n   }\n \n@@ -905,30 +905,30 @@ class LoserTreePointerUnguarded :\n   {\n #if _GLIBCXX_ASSERTIONS\n     // no dummy sequence can ever be at the top!\n-    _GLIBCXX_PARALLEL_ASSERT(__losers[0]._M_source != -1);\n+    _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n #endif\n \n     const _Tp* _M_keyp = &_M_key;\n-    int _M_source = __losers[0]._M_source;\n-    for (unsigned int __pos = (__k + _M_source) / 2; __pos > 0; __pos /= 2)\n+    int _M_source = _M_losers[0]._M_source;\n+    for (unsigned int __pos = (_M_k + _M_source) / 2; __pos > 0; __pos /= 2)\n       {\n         // The smaller one gets promoted, ties are broken by _M_source.\n-        if (__comp(*__losers[__pos]._M_keyp, *_M_keyp)\n-          || (!__comp(*_M_keyp, *__losers[__pos]._M_keyp) && __losers[__pos]._M_source < _M_source))\n+        if (_M_comp(*_M_losers[__pos]._M_keyp, *_M_keyp)\n+          || (!_M_comp(*_M_keyp, *_M_losers[__pos]._M_keyp) && _M_losers[__pos]._M_source < _M_source))\n           {\n             // The other one is smaller.\n-            std::swap(__losers[__pos]._M_source, _M_source);\n-            std::swap(__losers[__pos]._M_keyp, _M_keyp);\n+            std::swap(_M_losers[__pos]._M_source, _M_source);\n+            std::swap(_M_losers[__pos]._M_keyp, _M_keyp);\n           }\n       }\n \n-    __losers[0]._M_source = _M_source;\n-    __losers[0]._M_keyp = _M_keyp;\n+    _M_losers[0]._M_source = _M_source;\n+    _M_losers[0]._M_keyp = _M_keyp;\n   }\n };\n \n /**\n- * @brief Unstable unguarded LoserTree variant storing pointers.\n+ * @brief Unstable unguarded _LoserTree variant storing pointers.\n  *\n  * Stable variant is above.\n  */\n@@ -937,19 +937,19 @@ class LoserTreePointerUnguarded</* __stable == */false, _Tp, _Compare> :\n     public LoserTreePointerUnguardedBase<_Tp, _Compare>\n {\n   typedef LoserTreePointerUnguardedBase<_Tp, _Compare> Base;\n-  using Base::__k;\n-  using Base::__losers;\n+  using Base::_M_k;\n+  using Base::_M_losers;\n \n public:\n-  LoserTreePointerUnguarded(unsigned int _k, const _Tp& _sentinel,\n-      _Compare _comp = std::less<_Tp>())\n-    : Base::LoserTreePointerUnguardedBase(_k, _sentinel, _comp)\n+  LoserTreePointerUnguarded(unsigned int __k, const _Tp& _sentinel,\n+      _Compare __comp = std::less<_Tp>())\n+    : Base::LoserTreePointerUnguardedBase(__k, _sentinel, __comp)\n   {}\n \n   unsigned int\n   __init_winner(unsigned int __root)\n   {\n-    if (__root >= __k)\n+    if (__root >= _M_k)\n       {\n         return __root;\n       }\n@@ -960,20 +960,20 @@ class LoserTreePointerUnguarded</* __stable == */false, _Tp, _Compare> :\n \n #if _GLIBCXX_ASSERTIONS\n         // If __left one is sentinel then __right one must be, too.\n-        if (__losers[__left]._M_source == -1)\n-          _GLIBCXX_PARALLEL_ASSERT(__losers[__right]._M_source == -1);\n+        if (_M_losers[__left]._M_source == -1)\n+          _GLIBCXX_PARALLEL_ASSERT(_M_losers[__right]._M_source == -1);\n #endif\n \n-        if (!__comp(*__losers[__right]._M_keyp, *__losers[__left]._M_keyp))\n+        if (!_M_comp(*_M_losers[__right]._M_keyp, *_M_losers[__left]._M_keyp))\n           {\n             // Left one is less or equal.\n-            __losers[__root] = __losers[__right];\n+            _M_losers[__root] = _M_losers[__right];\n             return __left;\n           }\n         else\n           {\n             // Right one is less.\n-            __losers[__root] = __losers[__left];\n+            _M_losers[__root] = _M_losers[__left];\n             return __right;\n           }\n       }\n@@ -982,11 +982,11 @@ class LoserTreePointerUnguarded</* __stable == */false, _Tp, _Compare> :\n   inline void\n   __init()\n   {\n-    __losers[0] = __losers[__init_winner(1)];\n+    _M_losers[0] = _M_losers[__init_winner(1)];\n \n #if _GLIBCXX_ASSERTIONS\n     // no dummy sequence can ever be at the top at the beginning (0 sequences!)\n-    _GLIBCXX_PARALLEL_ASSERT(__losers[0]._M_source != -1);\n+    _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n #endif\n   }\n \n@@ -995,24 +995,24 @@ class LoserTreePointerUnguarded</* __stable == */false, _Tp, _Compare> :\n   {\n #if _GLIBCXX_ASSERTIONS\n     // no dummy sequence can ever be at the top!\n-    _GLIBCXX_PARALLEL_ASSERT(__losers[0]._M_source != -1);\n+    _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n #endif\n \n     const _Tp* _M_keyp = &_M_key;\n-    int _M_source = __losers[0]._M_source;\n-    for (unsigned int __pos = (__k + _M_source) / 2; __pos > 0; __pos /= 2)\n+    int _M_source = _M_losers[0]._M_source;\n+    for (unsigned int __pos = (_M_k + _M_source) / 2; __pos > 0; __pos /= 2)\n       {\n         // The smaller one gets promoted.\n-        if (__comp(*(__losers[__pos]._M_keyp), *_M_keyp))\n+        if (_M_comp(*(_M_losers[__pos]._M_keyp), *_M_keyp))\n           {\n             // The other one is smaller.\n-            std::swap(__losers[__pos]._M_source, _M_source);\n-            std::swap(__losers[__pos]._M_keyp, _M_keyp);\n+            std::swap(_M_losers[__pos]._M_source, _M_source);\n+            std::swap(_M_losers[__pos]._M_keyp, _M_keyp);\n           }\n       }\n \n-    __losers[0]._M_source = _M_source;\n-    __losers[0]._M_keyp = _M_keyp;\n+    _M_losers[0]._M_source = _M_source;\n+    _M_losers[0]._M_keyp = _M_keyp;\n   }\n };\n "}, {"sha": "148b4ab65e491ce51f2a8d5bd17679bd248d9dda", "filename": "libstdc++-v3/include/parallel/multiseq_selection.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54384f7f0ac2aae9b2da7cf32e22f8d3418fa836/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiseq_selection.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54384f7f0ac2aae9b2da7cf32e22f8d3418fa836/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiseq_selection.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiseq_selection.h?ref=54384f7f0ac2aae9b2da7cf32e22f8d3418fa836", "patch": "@@ -56,19 +56,19 @@ namespace __gnu_parallel\n     : public std::binary_function<std::pair<_T1, _T2>, std::pair<_T1, _T2>, bool>\n     {\n     private:\n-      _Compare& __comp;\n+      _Compare& _M_comp;\n \n     public:\n-      _Lexicographic(_Compare& _comp) : __comp(_comp) { }\n+      _Lexicographic(_Compare& __comp) : _M_comp(__comp) { }\n \n       bool\n       operator()(const std::pair<_T1, _T2>& __p1,\n \t\t const std::pair<_T1, _T2>& __p2) const\n       {\n-\tif (__comp(__p1.first, __p2.first))\n+\tif (_M_comp(__p1.first, __p2.first))\n \t  return true;\n \n-\tif (__comp(__p2.first, __p1.first))\n+\tif (_M_comp(__p2.first, __p1.first))\n \t  return false;\n \n \t// Firsts are equal.\n@@ -81,19 +81,19 @@ namespace __gnu_parallel\n     class _LexicographicReverse : public std::binary_function<_T1, _T2, bool>\n     {\n     private:\n-      _Compare& __comp;\n+      _Compare& _M_comp;\n \n     public:\n-      _LexicographicReverse(_Compare& _comp) : __comp(_comp) { }\n+      _LexicographicReverse(_Compare& __comp) : _M_comp(__comp) { }\n \n       bool\n       operator()(const std::pair<_T1, _T2>& __p1,\n \t\t const std::pair<_T1, _T2>& __p2) const\n       {\n-\tif (__comp(__p2.first, __p1.first))\n+\tif (_M_comp(__p2.first, __p1.first))\n \t  return true;\n \n-\tif (__comp(__p1.first, __p2.first))\n+\tif (_M_comp(__p1.first, __p2.first))\n \t  return false;\n \n \t// Firsts are equal."}, {"sha": "2604d3a0ad9f81fdebd1bc55ada46999d5719071", "filename": "libstdc++-v3/include/parallel/multiway_merge.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54384f7f0ac2aae9b2da7cf32e22f8d3418fa836/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_merge.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54384f7f0ac2aae9b2da7cf32e22f8d3418fa836/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_merge.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_merge.h?ref=54384f7f0ac2aae9b2da7cf32e22f8d3418fa836", "patch": "@@ -950,7 +950,7 @@ struct __multiway_merge_k_variant_sentinel_switch\n         typename __gnu_cxx::__conditional_type<\n             _LoserTreeTraits<_ValueType>::_M_use_pointer\n           , _LoserTreePointer<__stable, _ValueType, _Compare>\n-          , LoserTree<__stable, _ValueType, _Compare>\n+          , _LoserTree<__stable, _ValueType, _Compare>\n         >::__type >(__seqs_begin, __seqs_end, __target, __length, __comp);\n   }\n };"}, {"sha": "3a6c7e9fc8c2b68ea203916b71b797a4fb106208", "filename": "libstdc++-v3/include/parallel/multiway_mergesort.h", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54384f7f0ac2aae9b2da7cf32e22f8d3418fa836/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_mergesort.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54384f7f0ac2aae9b2da7cf32e22f8d3418fa836/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_mergesort.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_mergesort.h?ref=54384f7f0ac2aae9b2da7cf32e22f8d3418fa836", "patch": "@@ -49,10 +49,10 @@ template<typename _DifferenceTp>\n     typedef _DifferenceTp _DifferenceType;\n \n     /** @brief Begin of subsequence. */\n-    _DifferenceType __begin;\n+    _DifferenceType _M_begin;\n \n     /** @brief End of subsequence. */\n-    _DifferenceType __end;\n+    _DifferenceType _M_end;\n   };\n \n /** @brief Data accessed by all threads.\n@@ -66,7 +66,7 @@ template<typename _RAIter>\n     typedef typename _TraitsType::difference_type _DifferenceType;\n \n     /** @brief Number of threads involved. */\n-    _ThreadIndex __num_threads;\n+    _ThreadIndex _M_num_threads;\n \n     /** @brief Input __begin. */\n     _RAIter _M_source;\n@@ -141,40 +141,40 @@ template<typename _RAIter, typename _Compare,\n #   pragma omp barrier\n \n     std::vector<std::pair<_SortingPlacesIterator, _SortingPlacesIterator> >\n-        seqs(__sd->__num_threads);\n-    for (_ThreadIndex __s = 0; __s < __sd->__num_threads; __s++)\n+        seqs(__sd->_M_num_threads);\n+    for (_ThreadIndex __s = 0; __s < __sd->_M_num_threads; __s++)\n       seqs[__s] = std::make_pair(__sd->_M_temporary[__s],\n                                 __sd->_M_temporary[__s]\n                                     + (__sd->_M_starts[__s + 1] - __sd->_M_starts[__s]));\n \n-    std::vector<_SortingPlacesIterator> _M_offsets(__sd->__num_threads);\n+    std::vector<_SortingPlacesIterator> _M_offsets(__sd->_M_num_threads);\n \n     // if not last thread\n-    if (__iam < __sd->__num_threads - 1)\n+    if (__iam < __sd->_M_num_threads - 1)\n       multiseq_partition(seqs.begin(), seqs.end(),\n                           __sd->_M_starts[__iam + 1], _M_offsets.begin(), __comp);\n \n-    for (int __seq = 0; __seq < __sd->__num_threads; __seq++)\n+    for (int __seq = 0; __seq < __sd->_M_num_threads; __seq++)\n       {\n         // for each sequence\n-        if (__iam < (__sd->__num_threads - 1))\n-          __sd->_M_pieces[__iam][__seq].__end = _M_offsets[__seq] - seqs[__seq].first;\n+        if (__iam < (__sd->_M_num_threads - 1))\n+          __sd->_M_pieces[__iam][__seq]._M_end = _M_offsets[__seq] - seqs[__seq].first;\n         else\n           // very end of this sequence\n-          __sd->_M_pieces[__iam][__seq].__end =\n+          __sd->_M_pieces[__iam][__seq]._M_end =\n               __sd->_M_starts[__seq + 1] - __sd->_M_starts[__seq];\n       }\n \n #   pragma omp barrier\n \n-    for (_ThreadIndex __seq = 0; __seq < __sd->__num_threads; __seq++)\n+    for (_ThreadIndex __seq = 0; __seq < __sd->_M_num_threads; __seq++)\n       {\n         // For each sequence.\n         if (__iam > 0)\n-          __sd->_M_pieces[__iam][__seq].__begin = __sd->_M_pieces[__iam - 1][__seq].__end;\n+          __sd->_M_pieces[__iam][__seq]._M_begin = __sd->_M_pieces[__iam - 1][__seq]._M_end;\n         else\n           // Absolute beginning.\n-          __sd->_M_pieces[__iam][__seq].__begin = 0;\n+          __sd->_M_pieces[__iam][__seq]._M_begin = 0;\n       }\n   }   \n   };\n@@ -204,16 +204,16 @@ template<typename _RAIter, typename _Compare,\n \n #     pragma omp single\n       __gnu_sequential::sort(__sd->_M_samples,\n-                             __sd->_M_samples + (__num_samples * __sd->__num_threads),\n+                             __sd->_M_samples + (__num_samples * __sd->_M_num_threads),\n                              __comp);\n \n #     pragma omp barrier\n \n-      for (_ThreadIndex __s = 0; __s < __sd->__num_threads; ++__s)\n+      for (_ThreadIndex __s = 0; __s < __sd->_M_num_threads; ++__s)\n         {\n           // For each sequence.\n           if (__num_samples * __iam > 0)\n-            __sd->_M_pieces[__iam][__s].__begin =\n+            __sd->_M_pieces[__iam][__s]._M_begin =\n                 std::lower_bound(__sd->_M_temporary[__s],\n                     __sd->_M_temporary[__s]\n                         + (__sd->_M_starts[__s + 1] - __sd->_M_starts[__s]),\n@@ -222,10 +222,10 @@ template<typename _RAIter, typename _Compare,\n                 - __sd->_M_temporary[__s];\n           else\n             // Absolute beginning.\n-            __sd->_M_pieces[__iam][__s].__begin = 0;\n+            __sd->_M_pieces[__iam][__s]._M_begin = 0;\n \n-          if ((__num_samples * (__iam + 1)) < (__num_samples * __sd->__num_threads))\n-            __sd->_M_pieces[__iam][__s].__end =\n+          if ((__num_samples * (__iam + 1)) < (__num_samples * __sd->_M_num_threads))\n+            __sd->_M_pieces[__iam][__s]._M_end =\n                 std::lower_bound(__sd->_M_temporary[__s],\n                         __sd->_M_temporary[__s]\n                             + (__sd->_M_starts[__s + 1] - __sd->_M_starts[__s]),\n@@ -234,7 +234,7 @@ template<typename _RAIter, typename _Compare,\n                 - __sd->_M_temporary[__s];\n           else\n             // Absolute __end.\n-            __sd->_M_pieces[__iam][__s].__end = __sd->_M_starts[__s + 1] - __sd->_M_starts[__s];\n+            __sd->_M_pieces[__iam][__s]._M_end = __sd->_M_starts[__s + 1] - __sd->_M_starts[__s];\n         }\n     }\n   };\n@@ -346,29 +346,29 @@ template<bool __stable, bool __exact, typename _RAIter,\n     // No barrier here: Synchronization is done by the splitting routine.\n \n     _DifferenceType __num_samples =\n-        _Settings::get().sort_mwms_oversampling * __sd->__num_threads - 1;\n+        _Settings::get().sort_mwms_oversampling * __sd->_M_num_threads - 1;\n     _SplitConsistently\n       <__exact, _RAIter, _Compare, _SortingPlacesIterator>()\n         (__iam, __sd, __comp, __num_samples);\n \n     // Offset from __target __begin, __length after merging.\n     _DifferenceType __offset = 0, __length_am = 0;\n-    for (_ThreadIndex __s = 0; __s < __sd->__num_threads; __s++)\n+    for (_ThreadIndex __s = 0; __s < __sd->_M_num_threads; __s++)\n       {\n-        __length_am += __sd->_M_pieces[__iam][__s].__end - __sd->_M_pieces[__iam][__s].__begin;\n-        __offset += __sd->_M_pieces[__iam][__s].__begin;\n+        __length_am += __sd->_M_pieces[__iam][__s]._M_end - __sd->_M_pieces[__iam][__s]._M_begin;\n+        __offset += __sd->_M_pieces[__iam][__s]._M_begin;\n       }\n \n     typedef std::vector<\n       std::pair<_SortingPlacesIterator, _SortingPlacesIterator> >\n         seq_vector_type;\n-    seq_vector_type seqs(__sd->__num_threads);\n+    seq_vector_type seqs(__sd->_M_num_threads);\n \n-    for (int __s = 0; __s < __sd->__num_threads; ++__s)\n+    for (int __s = 0; __s < __sd->_M_num_threads; ++__s)\n       {\n         seqs[__s] =\n-          std::make_pair(__sd->_M_temporary[__s] + __sd->_M_pieces[__iam][__s].__begin,\n-        __sd->_M_temporary[__s] + __sd->_M_pieces[__iam][__s].__end);\n+          std::make_pair(__sd->_M_temporary[__s] + __sd->_M_pieces[__iam][__s]._M_begin,\n+        __sd->_M_temporary[__s] + __sd->_M_pieces[__iam][__s]._M_end);\n       }\n \n     __possibly_stable_multiway_merge<\n@@ -424,7 +424,7 @@ template<bool __stable, bool __exact, typename _RAIter,\n \n #       pragma omp single\n           {\n-            __sd.__num_threads = __num_threads;\n+            __sd._M_num_threads = __num_threads;\n             __sd._M_source = __begin;\n \n             __sd._M_temporary = new _ValueType*[__num_threads];"}, {"sha": "5f5df6795246ebd59aed0f383b5bb3cfd8813369", "filename": "libstdc++-v3/include/parallel/omp_loop.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54384f7f0ac2aae9b2da7cf32e22f8d3418fa836/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54384f7f0ac2aae9b2da7cf32e22f8d3418fa836/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop.h?ref=54384f7f0ac2aae9b2da7cf32e22f8d3418fa836", "patch": "@@ -108,7 +108,7 @@ template<typename _RAIter,\n \n     // Points to last element processed (needed as return value for\n     // some algorithms like transform).\n-    __f.finish_iterator = __begin + __length;\n+    __f._M_finish_iterator = __begin + __length;\n \n     return __o;\n   }"}, {"sha": "68dee423eda0e9bd331a28663d8537aa1338d6ef", "filename": "libstdc++-v3/include/parallel/par_loop.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54384f7f0ac2aae9b2da7cf32e22f8d3418fa836/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpar_loop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54384f7f0ac2aae9b2da7cf32e22f8d3418fa836/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpar_loop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpar_loop.h?ref=54384f7f0ac2aae9b2da7cf32e22f8d3418fa836", "patch": "@@ -122,7 +122,7 @@ template<typename _RAIter,\n \n     // Points to last element processed (needed as return value for\n     // some algorithms like transform).\n-    __f.finish_iterator = __begin + __length;\n+    __f._M_finish_iterator = __begin + __length;\n \n     delete[] __thread_results;\n     delete[] __constructed;"}, {"sha": "12f646b2eb2474c940d7e17113cb12a20d9c3d9e", "filename": "libstdc++-v3/include/parallel/random_number.h", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54384f7f0ac2aae9b2da7cf32e22f8d3418fa836/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_number.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54384f7f0ac2aae9b2da7cf32e22f8d3418fa836/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_number.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_number.h?ref=54384f7f0ac2aae9b2da7cf32e22f8d3418fa836", "patch": "@@ -43,9 +43,9 @@ namespace __gnu_parallel\n   private:\n     std::tr1::mt19937 \t_M_mt;\n     uint64 \t\t_M_supremum;\n-    uint64 \t\t_RAND_SUP;\n+    uint64 \t\t_M_rand_sup;\n     double \t\t_M_supremum_reciprocal;\n-    double \t\t_RAND_SUP_REC;\n+    double \t\t_M_rand_sup_reciprocal;\n \n     // Assumed to be twice as long as the usual random number.\n     uint64 \t\t__cache;  \n@@ -72,9 +72,9 @@ namespace __gnu_parallel\n     /** @brief Default constructor. Seed with 0. */\n     _RandomNumber()\n     : _M_mt(0), _M_supremum(0x100000000ULL),\n-      _RAND_SUP(1ULL << (sizeof(uint32) * 8)),\n-      _M_supremum_reciprocal(double(_M_supremum) / double(_RAND_SUP)),\n-      _RAND_SUP_REC(1.0 / double(_RAND_SUP)),\n+      _M_rand_sup(1ULL << (sizeof(uint32) * 8)),\n+      _M_supremum_reciprocal(double(_M_supremum) / double(_M_rand_sup)),\n+      _M_rand_sup_reciprocal(1.0 / double(_M_rand_sup)),\n       __cache(0), __bits_left(0) { }\n \n     /** @brief Constructor.\n@@ -83,9 +83,9 @@ namespace __gnu_parallel\n      *                  interval @__c [0,_M_supremum). */\n     _RandomNumber(uint32 __seed, uint64 _M_supremum = 0x100000000ULL)\n     : _M_mt(__seed), _M_supremum(_M_supremum),\n-      _RAND_SUP(1ULL << (sizeof(uint32) * 8)),\n-      _M_supremum_reciprocal(double(_M_supremum) / double(_RAND_SUP)),\n-      _RAND_SUP_REC(1.0 / double(_RAND_SUP)),\n+      _M_rand_sup(1ULL << (sizeof(uint32) * 8)),\n+      _M_supremum_reciprocal(double(_M_supremum) / double(_M_rand_sup)),\n+      _M_rand_sup_reciprocal(1.0 / double(_M_rand_sup)),\n       __cache(0), __bits_left(0) { }\n \n     /** @brief Generate unsigned random 32-bit integer. */\n@@ -99,17 +99,17 @@ namespace __gnu_parallel\n     operator()(uint64 local_supremum)\n     {\n       return __scale_down(_M_mt(), local_supremum,\n-\t\t\tdouble(local_supremum * _RAND_SUP_REC));\n+\t\t\tdouble(local_supremum * _M_rand_sup_reciprocal));\n     }\n \n     /** @brief Generate a number of random bits, run-time parameter.\n      *  @param bits Number of bits to generate. */\n     unsigned long\n-    __genrand_bits(int bits)\n+    __genrand_bits(int __bits)\n     {\n-      unsigned long __res = __cache & ((1 << bits) - 1);\n-      __cache = __cache >> bits;\n-      __bits_left -= bits;\n+      unsigned long __res = __cache & ((1 << __bits) - 1);\n+      __cache = __cache >> __bits;\n+      __bits_left -= __bits;\n       if (__bits_left < 32)\n \t{\n \t  __cache |= ((uint64(_M_mt())) << __bits_left);"}, {"sha": "5994190fcadaa8c7fa3e062005bd8288a79e4f4c", "filename": "libstdc++-v3/include/parallel/random_shuffle.h", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54384f7f0ac2aae9b2da7cf32e22f8d3418fa836/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_shuffle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54384f7f0ac2aae9b2da7cf32e22f8d3418fa836/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_shuffle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_shuffle.h?ref=54384f7f0ac2aae9b2da7cf32e22f8d3418fa836", "patch": "@@ -63,7 +63,7 @@ template<typename _RAIter>\n \n     /** @brief Two-dimensional array to hold the thread-bin distribution.\n      *\n-     *  Dimensions (__num_threads + 1) __x (_M_num_bins + 1). */\n+     *  Dimensions (_M_num_threads + 1) __x (_M_num_bins + 1). */\n     _DifferenceType** _M_dist;\n \n     /** @brief Start indexes of the threads' __chunks. */\n@@ -91,7 +91,7 @@ template<typename _RAIter, typename RandomNumberGenerator>\n   struct _DRSSorterPU\n   {\n     /** @brief Number of threads participating in total. */\n-    int __num_threads;\n+    int _M_num_threads;\n \n     /** @brief Begin __index for bins taken care of by this thread. */\n     _BinIndex _M_bins_begin;\n@@ -135,7 +135,7 @@ template<typename _RAIter, typename RandomNumberGenerator>\n     _BinIndex* __oracles = new _BinIndex[__length];\n     _DifferenceType* _M_dist = new _DifferenceType[_M_sd->_M_num_bins + 1];\n     _BinIndex* _M_bin_proc = new _BinIndex[_M_sd->_M_num_bins];\n-    _ValueType** _M_temporaries = new _ValueType*[d->__num_threads];\n+    _ValueType** _M_temporaries = new _ValueType*[d->_M_num_threads];\n \n     // Compute oracles and count appearances.\n     for (_BinIndex __b = 0; __b < _M_sd->_M_num_bins + 1; ++__b)\n@@ -161,27 +161,27 @@ template<typename _RAIter, typename RandomNumberGenerator>\n \n #   pragma omp single\n     {\n-      // Sum up bins, _M_sd->_M_dist[__s + 1][d->__num_threads] now contains the\n+      // Sum up bins, _M_sd->_M_dist[__s + 1][d->_M_num_threads] now contains the\n       // total number of items in bin __s\n       for (_BinIndex __s = 0; __s < _M_sd->_M_num_bins; ++__s)\n         __gnu_sequential::partial_sum(_M_sd->_M_dist[__s + 1],\n-                                      _M_sd->_M_dist[__s + 1] + d->__num_threads + 1,\n+                                      _M_sd->_M_dist[__s + 1] + d->_M_num_threads + 1,\n                                       _M_sd->_M_dist[__s + 1]);\n     }\n \n #   pragma omp barrier\n \n     _SequenceIndex __offset = 0, __global_offset = 0;\n     for (_BinIndex __s = 0; __s < d->_M_bins_begin; ++__s)\n-      __global_offset += _M_sd->_M_dist[__s + 1][d->__num_threads];\n+      __global_offset += _M_sd->_M_dist[__s + 1][d->_M_num_threads];\n \n #   pragma omp barrier\n \n     for (_BinIndex __s = d->_M_bins_begin; __s < d->__bins_end; ++__s)\n       {\n-\tfor (int __t = 0; __t < d->__num_threads + 1; ++__t)\n+\tfor (int __t = 0; __t < d->_M_num_threads + 1; ++__t)\n \t  _M_sd->_M_dist[__s + 1][__t] += __offset;\n-\t__offset = _M_sd->_M_dist[__s + 1][d->__num_threads];\n+\t__offset = _M_sd->_M_dist[__s + 1][d->_M_num_threads];\n       }\n \n     _M_sd->_M_temporaries[__iam] = static_cast<_ValueType*>(\n@@ -194,7 +194,7 @@ template<typename _RAIter, typename RandomNumberGenerator>\n       _M_dist[__b] = _M_sd->_M_dist[__b][__iam];\n     for (_BinIndex __b = 0; __b < _M_sd->_M_num_bins; ++__b)\n       _M_bin_proc[__b] = _M_sd->_M_bin_proc[__b];\n-    for (_ThreadIndex __t = 0; __t < d->__num_threads; ++__t)\n+    for (_ThreadIndex __t = 0; __t < d->_M_num_threads; ++__t)\n       _M_temporaries[__t] = _M_sd->_M_temporaries[__t];\n \n     _RAIter _M_source = _M_sd->_M_source;\n@@ -206,7 +206,7 @@ template<typename _RAIter, typename RandomNumberGenerator>\n         _BinIndex target_bin = __oracles[__i];\n         _ThreadIndex target_p = _M_bin_proc[target_bin];\n \n-        // Last column [d->__num_threads] stays unchanged.\n+        // Last column [d->_M_num_threads] stays unchanged.\n         ::new(&(_M_temporaries[target_p][_M_dist[target_bin + 1]++]))\n \t    _ValueType(*(_M_source + __i + __start));\n       }\n@@ -223,12 +223,12 @@ template<typename _RAIter, typename RandomNumberGenerator>\n       {\n         _ValueType* __begin =\n                     _M_sd->_M_temporaries[__iam] +\n-                    ((__b == d->_M_bins_begin) ? 0 : _M_sd->_M_dist[__b][d->__num_threads]),\n+                    ((__b == d->_M_bins_begin) ? 0 : _M_sd->_M_dist[__b][d->_M_num_threads]),\n                   * __end =\n-                    _M_sd->_M_temporaries[__iam] + _M_sd->_M_dist[__b + 1][d->__num_threads];\n+                    _M_sd->_M_temporaries[__iam] + _M_sd->_M_dist[__b + 1][d->_M_num_threads];\n         __sequential_random_shuffle(__begin, __end, __rng);\n         std::copy(__begin, __end, _M_sd->_M_source + __global_offset +\n-            ((__b == d->_M_bins_begin) ? 0 : _M_sd->_M_dist[__b][d->__num_threads]));\n+            ((__b == d->_M_bins_begin) ? 0 : _M_sd->_M_dist[__b][d->_M_num_threads]));\n       }\n \n     ::operator delete(_M_sd->_M_temporaries[__iam]);\n@@ -364,7 +364,7 @@ template<typename _RAIter, typename RandomNumberGenerator>\n                 __pus[__i].__bins_end = bin_cursor;\n                 for (; __j < bin_cursor; ++__j)\n                   _M_sd._M_bin_proc[__j] = __i;\n-                __pus[__i].__num_threads = __num_threads;\n+                __pus[__i]._M_num_threads = __num_threads;\n                 __pus[__i]._M_seed = __rng(std::numeric_limits<uint32>::max());\n                 __pus[__i]._M_sd = &_M_sd;\n               }"}, {"sha": "4bbbf089363b19224f94d114e442949f517c831c", "filename": "libstdc++-v3/include/parallel/set_operations.h", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54384f7f0ac2aae9b2da7cf32e22f8d3418fa836/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fset_operations.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54384f7f0ac2aae9b2da7cf32e22f8d3418fa836/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fset_operations.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fset_operations.h?ref=54384f7f0ac2aae9b2da7cf32e22f8d3418fa836", "patch": "@@ -71,9 +71,9 @@ template<typename _IIter,\n     typedef typename _TraitsType::difference_type _DifferenceType;\n     typedef typename std::pair<_IIter, _IIter> _IteratorPair;\n \n-    symmetric_difference_func(_Compare __c) : __comp(__c) {}\n+    symmetric_difference_func(_Compare __comp) : _M_comp(__comp) {}\n \n-    _Compare __comp;\n+    _Compare _M_comp;\n \n     _OutputIterator\n     _M_invoke(_IIter __a, _IIter __b,\n@@ -82,13 +82,13 @@ template<typename _IIter,\n     {\n       while (__a != __b && __c != d)\n         {\n-          if (__comp(*__a, *__c))\n+          if (_M_comp(*__a, *__c))\n             {\n               *__r = *__a;\n               ++__a;\n               ++__r;\n             }\n-          else if (__comp(*__c, *__a))\n+          else if (_M_comp(*__c, *__a))\n             {\n               *__r = *__c;\n               ++__c;\n@@ -111,12 +111,12 @@ template<typename _IIter,\n \n       while (__a != __b && __c != d)\n         {\n-          if (__comp(*__a, *__c))\n+          if (_M_comp(*__a, *__c))\n             {\n               ++__a;\n               ++__counter;\n             }\n-          else if (__comp(*__c, *__a))\n+          else if (_M_comp(*__c, *__a))\n             {\n               ++__c;\n               ++__counter;\n@@ -150,23 +150,23 @@ template<typename _IIter,\n     typedef typename _TraitsType::difference_type _DifferenceType;\n     typedef typename std::pair<_IIter, _IIter> _IteratorPair;\n \n-    __difference_func(_Compare __c) : __comp(__c) {}\n+    __difference_func(_Compare __comp) : _M_comp(__comp) {}\n \n-    _Compare __comp;\n+    _Compare _M_comp;\n \n     _OutputIterator\n     _M_invoke(_IIter __a, _IIter __b, _IIter __c, _IIter d,\n           _OutputIterator __r) const\n     {\n       while (__a != __b && __c != d)\n         {\n-          if (__comp(*__a, *__c))\n+          if (_M_comp(*__a, *__c))\n             {\n               *__r = *__a;\n               ++__a;\n               ++__r;\n             }\n-          else if (__comp(*__c, *__a))\n+          else if (_M_comp(*__c, *__a))\n             { ++__c; }\n           else\n             {\n@@ -185,12 +185,12 @@ template<typename _IIter,\n \n       while (__a != __b && __c != d)\n         {\n-          if (__comp(*__a, *__c))\n+          if (_M_comp(*__a, *__c))\n             {\n               ++__a;\n               ++__counter;\n             }\n-          else if (__comp(*__c, *__a))\n+          else if (_M_comp(*__c, *__a))\n             { ++__c; }\n           else\n             { ++__a; ++__c; }\n@@ -218,19 +218,19 @@ template<typename _IIter,\n     typedef typename _TraitsType::difference_type _DifferenceType;\n     typedef typename std::pair<_IIter, _IIter> _IteratorPair;\n \n-    __intersection_func(_Compare __c) : __comp(__c) {}\n+    __intersection_func(_Compare __comp) : _M_comp(__comp) {}\n \n-    _Compare __comp;\n+    _Compare _M_comp;\n \n     _OutputIterator\n     _M_invoke(_IIter __a, _IIter __b, _IIter __c, _IIter d,\n           _OutputIterator __r) const\n     {\n       while (__a != __b && __c != d)\n         {\n-          if (__comp(*__a, *__c))\n+          if (_M_comp(*__a, *__c))\n             { ++__a; }\n-          else if (__comp(*__c, *__a))\n+          else if (_M_comp(*__c, *__a))\n             { ++__c; }\n           else\n             {\n@@ -252,9 +252,9 @@ template<typename _IIter,\n \n       while (__a != __b && __c != d)\n         {\n-          if (__comp(*__a, *__c))\n+          if (_M_comp(*__a, *__c))\n             { ++__a; }\n-          else if (__comp(*__c, *__a))\n+          else if (_M_comp(*__c, *__a))\n             { ++__c; }\n           else\n             {\n@@ -282,22 +282,22 @@ template<class _IIter, class _OutputIterator, class _Compare>\n     typedef typename std::iterator_traits<_IIter>::difference_type\n     _DifferenceType;\n \n-    __union_func(_Compare __c) : __comp(__c) {}\n+    __union_func(_Compare __comp) : _M_comp(__comp) {}\n \n-    _Compare __comp;\n+    _Compare _M_comp;\n \n     _OutputIterator\n     _M_invoke(_IIter __a, const _IIter __b, _IIter __c,\n           const _IIter d, _OutputIterator __r) const\n     {\n       while (__a != __b && __c != d)\n         {\n-          if (__comp(*__a, *__c))\n+          if (_M_comp(*__a, *__c))\n             {\n               *__r = *__a;\n               ++__a;\n             }\n-          else if (__comp(*__c, *__a))\n+          else if (_M_comp(*__c, *__a))\n             {\n               *__r = *__c;\n               ++__c;\n@@ -321,9 +321,9 @@ template<class _IIter, class _OutputIterator, class _Compare>\n \n       while (__a != __b && __c != d)\n         {\n-          if (__comp(*__a, *__c))\n+          if (_M_comp(*__a, *__c))\n             { ++__a; }\n-          else if (__comp(*__c, *__a))\n+          else if (_M_comp(*__c, *__a))\n             { ++__c; }\n           else\n             {\n@@ -400,14 +400,14 @@ template<typename _IIter,\n         _IIter __offset[2];\n         const _DifferenceType __rank = __borders[__iam + 1];\n \n-        multiseq_partition(__sequence, __sequence + 2, __rank, __offset, __op.__comp);\n+        multiseq_partition(__sequence, __sequence + 2, __rank, __offset, __op._M_comp);\n \n         // allowed to read?\n         // together\n         // *(__offset[ 0 ] - 1) == *__offset[ 1 ]\n         if (__offset[ 0 ] != __begin1 && __offset[ 1 ] != __end2\n-            && !__op.__comp(*(__offset[ 0 ] - 1), *__offset[ 1 ])\n-            && !__op.__comp(*__offset[ 1 ], *(__offset[ 0 ] - 1)))\n+            && !__op._M_comp(*(__offset[ 0 ] - 1), *__offset[ 1 ])\n+            && !__op._M_comp(*__offset[ 1 ], *(__offset[ 0 ] - 1)))\n           {\n             // Avoid split between globally equal elements: move one to\n             // front in first sequence.\n@@ -476,10 +476,10 @@ template<typename _IIter,\n   inline _OutputIterator\n   __parallel_set_union(_IIter __begin1, _IIter __end1,\n                      _IIter __begin2, _IIter __end2,\n-                     _OutputIterator __result, _Compare __comp)\n+                     _OutputIterator __result, _Compare _M_comp)\n   {\n     return __parallel_set_operation(__begin1, __end1, __begin2, __end2, __result,\n-        __union_func< _IIter, _OutputIterator, _Compare>(__comp));\n+        __union_func< _IIter, _OutputIterator, _Compare>(_M_comp));\n   }\n \n template<typename _IIter,\n@@ -488,10 +488,10 @@ template<typename _IIter,\n   inline _OutputIterator\n   __parallel_set_intersection(_IIter __begin1, _IIter __end1,\n                             _IIter __begin2, _IIter __end2,\n-                            _OutputIterator __result, _Compare __comp)\n+                            _OutputIterator __result, _Compare _M_comp)\n   {\n     return __parallel_set_operation(__begin1, __end1, __begin2, __end2, __result,\n-        __intersection_func<_IIter, _OutputIterator, _Compare>(__comp));\n+        __intersection_func<_IIter, _OutputIterator, _Compare>(_M_comp));\n   }\n \n template<typename _IIter,\n@@ -500,10 +500,10 @@ template<typename _IIter,\n   inline _OutputIterator\n   __parallel_set_difference(_IIter __begin1, _IIter __end1,\n                           _IIter __begin2, _IIter __end2,\n-                          _OutputIterator __result, _Compare __comp)\n+                          _OutputIterator __result, _Compare _M_comp)\n   {\n     return __parallel_set_operation(__begin1, __end1, __begin2, __end2, __result,\n-        __difference_func<_IIter, _OutputIterator, _Compare>(__comp));\n+        __difference_func<_IIter, _OutputIterator, _Compare>(_M_comp));\n   }\n \n template<typename _IIter,\n@@ -512,11 +512,11 @@ template<typename _IIter,\n   inline _OutputIterator\n   __parallel_set_symmetric_difference(_IIter __begin1, _IIter __end1,\n                                     _IIter __begin2, _IIter __end2,\n-                                    _OutputIterator __result, _Compare __comp)\n+                                    _OutputIterator __result, _Compare _M_comp)\n   {\n     return __parallel_set_operation(__begin1, __end1, __begin2, __end2, __result,\n         symmetric_difference_func<_IIter, _OutputIterator, _Compare>\n-            (__comp));\n+            (_M_comp));\n   }\n \n }"}, {"sha": "5dfc7f3a1871fd8190aee837706d2fa2d6169d97", "filename": "libstdc++-v3/include/parallel/tags.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54384f7f0ac2aae9b2da7cf32e22f8d3418fa836/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54384f7f0ac2aae9b2da7cf32e22f8d3418fa836/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftags.h?ref=54384f7f0ac2aae9b2da7cf32e22f8d3418fa836", "patch": "@@ -46,37 +46,37 @@ namespace __gnu_parallel\n   struct parallel_tag\n   {\n     private:\n-      _ThreadIndex __num_threads;\n+      _ThreadIndex _M_num_threads;\n \n     public:\n       /** @brief Default constructor. Use default number of threads. */\n       parallel_tag()\n       {\n-        this->__num_threads = 0;\n+        this->_M_num_threads = 0;\n       }\n \n       /** @brief Default constructor. Recommend number of threads to use.\n        *  @param __num_threads Desired number of threads. */\n       parallel_tag(_ThreadIndex __num_threads)\n       {\n-        this->__num_threads = __num_threads;\n+        this->_M_num_threads = __num_threads;\n       }\n \n       /** @brief Find __out desired number of threads.\n        *  @return Desired number of threads. */\n       inline _ThreadIndex __get_num_threads()\n       {\n-        if(__num_threads == 0)\n+        if(_M_num_threads == 0)\n           return omp_get_max_threads();\n         else\n-          return __num_threads;\n+          return _M_num_threads;\n       }\n \n       /** @brief Set the desired number of threads.\n        *  @param __num_threads Desired number of threads. */\n       inline void set_num_threads(_ThreadIndex __num_threads)\n       {\n-        this->__num_threads = __num_threads;\n+        this->_M_num_threads = __num_threads;\n       }\n   };\n "}, {"sha": "3fb71f5a8d7beb568518d8da7dda9e001630e380", "filename": "libstdc++-v3/include/parallel/workstealing.h", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54384f7f0ac2aae9b2da7cf32e22f8d3418fa836/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fworkstealing.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54384f7f0ac2aae9b2da7cf32e22f8d3418fa836/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fworkstealing.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fworkstealing.h?ref=54384f7f0ac2aae9b2da7cf32e22f8d3418fa836", "patch": "@@ -59,17 +59,17 @@ template<typename _DifferenceTp>\n      *\n      *  Changed by owning and stealing thread. By stealing thread,\n      *  always incremented. */\n-    _GLIBCXX_JOB_VOLATILE _DifferenceType __first;\n+    _GLIBCXX_JOB_VOLATILE _DifferenceType _M_first;\n \n     /** @brief Last element.\n      *\n      *  Changed by owning thread only. */\n-    _GLIBCXX_JOB_VOLATILE _DifferenceType __last;\n+    _GLIBCXX_JOB_VOLATILE _DifferenceType _M_last;\n \n-    /** @brief Number of elements, i.e. @__c __last-__first+1.\n+    /** @brief Number of elements, i.e. @__c _M_last-_M_first+1.\n      *\n      *  Changed by owning thread only. */\n-    _GLIBCXX_JOB_VOLATILE _DifferenceType __load;\n+    _GLIBCXX_JOB_VOLATILE _DifferenceType _M_load;\n   };\n \n /** @brief Work stealing algorithm for random access iterators.\n@@ -177,21 +177,21 @@ template<typename _RAIter,\n         __iam_working = true;\n \n         // How many jobs per thread? last thread gets the rest.\n-        __my_job.__first =\n+        __my_job._M_first =\n             static_cast<_DifferenceType>(__iam * (__length / __num_threads));\n \n-        __my_job.__last = (__iam == (__num_threads - 1)) ?\n+        __my_job._M_last = (__iam == (__num_threads - 1)) ?\n             (__length - 1) : ((__iam + 1) * (__length / __num_threads) - 1);\n-        __my_job.__load = __my_job.__last - __my_job.__first + 1;\n+        __my_job._M_load = __my_job._M_last - __my_job._M_first + 1;\n \n-        // Init __result with __first __value (to have a base value for reduction).\n-        if (__my_job.__first <= __my_job.__last)\n+        // Init __result with _M_first __value (to have a base value for reduction).\n+        if (__my_job._M_first <= __my_job._M_last)\n           {\n             // Cannot use volatile variable directly.\n-            _DifferenceType __my_first = __my_job.__first;\n+            _DifferenceType __my_first = __my_job._M_first;\n             __result = __f(__op, __begin + __my_first);\n-            ++__my_job.__first;\n-            --__my_job.__load;\n+            ++__my_job._M_first;\n+            --__my_job._M_load;\n           }\n \n         _RAIter __current;\n@@ -206,18 +206,18 @@ template<typename _RAIter,\n #           pragma omp flush(__busy)\n \n             // Thread has own work to do\n-            while (__my_job.__first <= __my_job.__last)\n+            while (__my_job._M_first <= __my_job._M_last)\n               {\n                 // fetch-and-add call\n                 // Reserve __current __job block (size __chunk_size) in my queue.\n                 _DifferenceType current_job =\n-                  __fetch_and_add<_DifferenceType>(&(__my_job.__first), __chunk_size);\n+                  __fetch_and_add<_DifferenceType>(&(__my_job._M_first), __chunk_size);\n \n-                // Update __load, to make the three values consistent,\n-                // __first might have been changed in the meantime\n-                __my_job.__load = __my_job.__last - __my_job.__first + 1;\n+                // Update _M_load, to make the three values consistent,\n+                // _M_first might have been changed in the meantime\n+                __my_job._M_load = __my_job._M_last - __my_job._M_first + 1;\n                 for (_DifferenceType job_counter = 0;\n-                     job_counter < __chunk_size && current_job <= __my_job.__last;\n+                     job_counter < __chunk_size && current_job <= __my_job._M_last;\n                      ++job_counter)\n                   {\n                     // Yes: process it!\n@@ -248,9 +248,9 @@ template<typename _RAIter,\n                 __yield();\n #               pragma omp flush(__busy)\n                 __victim = rand_gen();\n-                __supposed_first = __job[__victim * __stride].__first;\n-                __supposed_last = __job[__victim * __stride].__last;\n-                __supposed_load = __job[__victim * __stride].__load;\n+                __supposed_first = __job[__victim * __stride]._M_first;\n+                __supposed_last = __job[__victim * __stride]._M_last;\n+                __supposed_load = __job[__victim * __stride]._M_load;\n               }\n             while (__busy > 0\n               && ((__supposed_load <= 0)\n@@ -268,13 +268,13 @@ template<typename _RAIter,\n                 // Push __victim's __start forward.\n                 _DifferenceType __stolen_first =\n                     __fetch_and_add<_DifferenceType>(\n-                        &(__job[__victim * __stride].__first), __steal);\n+                        &(__job[__victim * __stride]._M_first), __steal);\n                 _DifferenceType stolen_try =\n                     __stolen_first + __steal - _DifferenceType(1);\n \n-                __my_job.__first = __stolen_first;\n-                __my_job.__last = __gnu_parallel::min(stolen_try, __supposed_last);\n-                __my_job.__load = __my_job.__last - __my_job.__first + 1;\n+                __my_job._M_first = __stolen_first;\n+                __my_job._M_last = __gnu_parallel::min(stolen_try, __supposed_last);\n+                __my_job._M_load = __my_job._M_last - __my_job._M_first + 1;\n \n                 // Has potential work again.\n #               pragma omp atomic\n@@ -295,7 +295,7 @@ template<typename _RAIter,\n \n     // Points to last element processed (needed as return value for\n     // some algorithms like transform)\n-    __f.finish_iterator = __begin + __length;\n+    __f._M_finish_iterator = __begin + __length;\n \n     omp_destroy_lock(&__output_lock);\n "}]}