{"sha": "85419ac59724b7ce710ebb4acf03dbd747edeea3", "node_id": "C_kwDOANBUbNoAKDg1NDE5YWM1OTcyNGI3Y2U3MTBlYmI0YWNmMDNkYmQ3NDdlZGVlYTM", "commit": {"author": {"name": "Vladimir N. Makarov", "email": "vmakarov@redhat.com", "date": "2022-01-21T18:34:32Z"}, "committer": {"name": "Vladimir N. Makarov", "email": "vmakarov@redhat.com", "date": "2022-01-21T18:37:11Z"}, "message": "[PR103676] LRA: Calculate and exclude some start hard registers for reload pseudos\n\nLRA and old reload pass uses only one register class for reload pseudos even if\noperand constraints contain more one register class.  Let us consider\nconstraint 'lh' for thumb arm which means low and high thumb registers.\nReload pseudo for such constraint will have general reg class (union of\nlow and high reg classes).  Assigning the last low register to the reload\npseudo is wrong if the pseudo is of DImode as it requires two hard regs.\nBut it is considered OK if we use general reg class.  The following patch\nsolves this problem for LRA.\n\ngcc/ChangeLog:\n\n\tPR target/103676\n\t* ira.h (struct target_ira): Add member\n\tx_ira_exclude_class_mode_regs.\n\t(ira_exclude_class_mode_regs): New macro.\n\t* lra.h (lra_create_new_reg): Add arg exclude_start_hard_regs and\n\tmove from here ...\n\t* lra-int.h: ... to here.\n\t(lra_create_new_reg_with_unique_value): Add arg\n\texclude_start_hard_regs.\n\t(class lra_reg): Add member exclude_start_hard_regs.\n\t* lra-assigns.cc (find_hard_regno_for_1): Setup\n\timpossible_start_hard_regs from exclude_start_hard_regs.\n\t* lra-constraints.cc (get_reload_reg): Add arg exclude_start_hard_regs and pass\n\tit lra_create_new_reg[_with_unique_value].\n\t(match_reload): Ditto.\n\t(check_and_process_move): Pass NULL\n\texclude_start_hard_regs to lra_create_new_reg_with_unique_value.\n\t(goal_alt_exclude_start_hard_regs): New static variable.\n\t(process_addr_reg, simplify_operand_subreg): Pass NULL\n\texclude_start_hard_regs to lra_create_new_reg_with_unique_value\n\tand get_reload_reg.\n\t(process_alt_operands): Setup goal_alt_exclude_start_hard_regs.\n\tUse this_alternative_exclude_start_hard_regs additionally to find\n\twinning operand alternative.\n\t(base_to_reg, base_plus_disp_to_reg, index_part_to_reg): Pass NULL\n\texclude_start_hard_regs to lra_create_new_reg.\n\t(process_address_1, emit_inc): Ditto.\n\t(curr_insn_transform): Pass exclude_start_hard_regs value to\n\tlra_create_new_reg, get_reload_reg, match_reload.\n\t(inherit_reload_reg, split_reg): Pass NULL exclude_start_hard_regs\n\tto lra_create_new_reg.\n\t(process_invariant_for_inheritance): Ditto.\n\t* lra-remat.cc (update_scratch_ops): Ditto.\n\t* lra.cc (lra_create_new_reg_with_unique_value): Add arg\n\texclude_start_hard_regs.  Setup the corresponding member of\n\tlra reg info.\n\t(lra_create_new_reg): Add arg exclude_start_hard_regs and pass it\n\tto lra_create_new_reg_with_unique_value.\n\t(initialize_lra_reg_info_element): Initialize member\n\texclude_start_hard_regs.\n\t(get_scratch_reg): Pass NULL to lra_create_new_reg.\n\t* ira.cc (setup_prohibited_class_mode_regs): Rename to\n\tsetup_prohibited_and_exclude_class_mode_regs and calculate\n\tira_exclude_class_mode_regs.\n\ngcc/testsuite/ChangeLog:\n\n\tPR target/103676\n\t* g++.target/arm/pr103676.C: New.", "tree": {"sha": "fd41d96647548894170bacc8c0a45c8b7514da34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd41d96647548894170bacc8c0a45c8b7514da34"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/85419ac59724b7ce710ebb4acf03dbd747edeea3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85419ac59724b7ce710ebb4acf03dbd747edeea3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85419ac59724b7ce710ebb4acf03dbd747edeea3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85419ac59724b7ce710ebb4acf03dbd747edeea3/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3abcbf243239f9576a60f4ce7f8ee4b3fa14784b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3abcbf243239f9576a60f4ce7f8ee4b3fa14784b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3abcbf243239f9576a60f4ce7f8ee4b3fa14784b"}], "stats": {"total": 233, "additions": 163, "deletions": 70}, "files": [{"sha": "e3b3c549120ea3e913d83347404ace23474e3843", "filename": "gcc/ira.cc", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85419ac59724b7ce710ebb4acf03dbd747edeea3/gcc%2Fira.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85419ac59724b7ce710ebb4acf03dbd747edeea3/gcc%2Fira.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.cc?ref=85419ac59724b7ce710ebb4acf03dbd747edeea3", "patch": "@@ -1465,10 +1465,11 @@ setup_reg_class_nregs (void)\n \n \f\n \n-/* Set up IRA_PROHIBITED_CLASS_MODE_REGS and IRA_CLASS_SINGLETON.\n-   This function is called once IRA_CLASS_HARD_REGS has been initialized.  */\n+/* Set up IRA_PROHIBITED_CLASS_MODE_REGS, IRA_EXCLUDE_CLASS_MODE_REGS, and\n+   IRA_CLASS_SINGLETON.  This function is called once IRA_CLASS_HARD_REGS has\n+   been initialized.  */\n static void\n-setup_prohibited_class_mode_regs (void)\n+setup_prohibited_and_exclude_class_mode_regs (void)\n {\n   int j, k, hard_regno, cl, last_hard_regno, count;\n \n@@ -1480,6 +1481,7 @@ setup_prohibited_class_mode_regs (void)\n \t  count = 0;\n \t  last_hard_regno = -1;\n \t  CLEAR_HARD_REG_SET (ira_prohibited_class_mode_regs[cl][j]);\n+\t  CLEAR_HARD_REG_SET (ira_exclude_class_mode_regs[cl][j]);\n \t  for (k = ira_class_hard_regs_num[cl] - 1; k >= 0; k--)\n \t    {\n \t      hard_regno = ira_class_hard_regs[cl][k];\n@@ -1492,6 +1494,10 @@ setup_prohibited_class_mode_regs (void)\n \t\t  last_hard_regno = hard_regno;\n \t\t  count++;\n \t\t}\n+\t      else\n+\t\t{\n+\t\t  SET_HARD_REG_BIT (ira_exclude_class_mode_regs[cl][j], hard_regno);\n+\t\t}\n \t    }\n \t  ira_class_singleton[cl][j] = (count == 1 ? last_hard_regno : -1);\n \t}\n@@ -1707,7 +1713,7 @@ ira_init (void)\n   setup_alloc_regs (flag_omit_frame_pointer != 0);\n   setup_class_subset_and_memory_move_costs ();\n   setup_reg_class_nregs ();\n-  setup_prohibited_class_mode_regs ();\n+  setup_prohibited_and_exclude_class_mode_regs ();\n   find_reg_classes ();\n   clarify_prohibited_class_mode_regs ();\n   setup_hard_regno_aclass ();"}, {"sha": "d19e8cd1a24dc602914339a87a1bf0022cd79fc4", "filename": "gcc/ira.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85419ac59724b7ce710ebb4acf03dbd747edeea3/gcc%2Fira.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85419ac59724b7ce710ebb4acf03dbd747edeea3/gcc%2Fira.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.h?ref=85419ac59724b7ce710ebb4acf03dbd747edeea3", "patch": "@@ -117,6 +117,11 @@ struct target_ira\n      the allocation of given register class whose targetm.hard_regno_mode_ok\n      values for given mode are false.  */\n   HARD_REG_SET x_ira_prohibited_class_mode_regs[N_REG_CLASSES][NUM_MACHINE_MODES];\n+\n+  /* When an allocatable hard register in given mode can not be placed in given\n+     register class, it is in the set of the following array element.  It can\n+     happen only when given mode requires more one hard register.  */\n+  HARD_REG_SET x_ira_exclude_class_mode_regs[N_REG_CLASSES][NUM_MACHINE_MODES];\n };\n \n extern struct target_ira default_target_ira;\n@@ -164,6 +169,8 @@ extern struct target_ira *this_target_ira;\n   (this_target_ira->x_ira_no_alloc_regs)\n #define ira_prohibited_class_mode_regs \\\n   (this_target_ira->x_ira_prohibited_class_mode_regs)\n+#define ira_exclude_class_mode_regs \\\n+  (this_target_ira->x_ira_exclude_class_mode_regs)\n \n /* Major structure describing equivalence info for a pseudo.  */\n struct ira_reg_equiv_s"}, {"sha": "c1d40ea2a14bd4e47521a142c94218444a07a609", "filename": "gcc/lra-assigns.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85419ac59724b7ce710ebb4acf03dbd747edeea3/gcc%2Flra-assigns.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85419ac59724b7ce710ebb4acf03dbd747edeea3/gcc%2Flra-assigns.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-assigns.cc?ref=85419ac59724b7ce710ebb4acf03dbd747edeea3", "patch": "@@ -550,7 +550,7 @@ find_hard_regno_for_1 (int regno, int *cost, int try_only_hard_regno,\n   sparseset_clear_bit (conflict_reload_and_inheritance_pseudos, regno);\n   val = lra_reg_info[regno].val;\n   offset = lra_reg_info[regno].offset;\n-  CLEAR_HARD_REG_SET (impossible_start_hard_regs);\n+  impossible_start_hard_regs = lra_reg_info[regno].exclude_start_hard_regs;\n   EXECUTE_IF_SET_IN_SPARSESET (live_range_hard_reg_pseudos, conflict_regno)\n     {\n       conflict_hr = live_pseudos_reg_renumber[conflict_regno];"}, {"sha": "9cee17479bacc28f2a28bd3088dae5ba6c0e9282", "filename": "gcc/lra-constraints.cc", "status": "modified", "additions": 92, "deletions": 56, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85419ac59724b7ce710ebb4acf03dbd747edeea3/gcc%2Flra-constraints.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85419ac59724b7ce710ebb4acf03dbd747edeea3/gcc%2Flra-constraints.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.cc?ref=85419ac59724b7ce710ebb4acf03dbd747edeea3", "patch": "@@ -625,16 +625,16 @@ canonicalize_reload_addr (rtx addr)\n   return addr;\n }\n \n-/* Create a new pseudo using MODE, RCLASS, ORIGINAL or reuse an existing\n-   reload pseudo.  Don't reuse an existing reload pseudo if IN_SUBREG_P\n-   is true and the reused pseudo should be wrapped up in a SUBREG.\n-   The result pseudo is returned through RESULT_REG.  Return TRUE if we\n-   created a new pseudo, FALSE if we reused an existing reload pseudo.\n-   Use TITLE to describe new registers for debug purposes.  */\n+/* Create a new pseudo using MODE, RCLASS, EXCLUDE_START_HARD_REGS, ORIGINAL or\n+   reuse an existing reload pseudo.  Don't reuse an existing reload pseudo if\n+   IN_SUBREG_P is true and the reused pseudo should be wrapped up in a SUBREG.\n+   The result pseudo is returned through RESULT_REG.  Return TRUE if we created\n+   a new pseudo, FALSE if we reused an existing reload pseudo.  Use TITLE to\n+   describe new registers for debug purposes.  */\n static bool\n get_reload_reg (enum op_type type, machine_mode mode, rtx original,\n-\t\tenum reg_class rclass, bool in_subreg_p,\n-\t\tconst char *title, rtx *result_reg)\n+\t\tenum reg_class rclass, HARD_REG_SET *exclude_start_hard_regs,\n+\t\tbool in_subreg_p, const char *title, rtx *result_reg)\n {\n   int i, regno;\n   enum reg_class new_class;\n@@ -672,7 +672,8 @@ get_reload_reg (enum op_type type, machine_mode mode, rtx original,\n \t  return false;\n \t}\n       *result_reg\n-\t= lra_create_new_reg_with_unique_value (mode, original, rclass, title);\n+\t= lra_create_new_reg_with_unique_value (mode, original, rclass,\n+\t\t\t\t\t\texclude_start_hard_regs, title);\n       return true;\n     }\n   /* Prevent reuse value of expression with side effects,\n@@ -723,7 +724,8 @@ get_reload_reg (enum op_type type, machine_mode mode, rtx original,\n       }\n   *result_reg = (unique_p\n \t\t ? lra_create_new_reg_with_unique_value\n-\t\t : lra_create_new_reg) (mode, original, rclass, title);\n+\t\t : lra_create_new_reg) (mode, original, rclass,\n+\t\t\t\t\texclude_start_hard_regs, title);\n   lra_assert (curr_insn_input_reloads_num < LRA_MAX_INSN_RELOADS);\n   curr_insn_input_reloads[curr_insn_input_reloads_num].input = original;\n   curr_insn_input_reloads[curr_insn_input_reloads_num].match_p = false;\n@@ -991,17 +993,17 @@ check_conflict_input_operands (int regno, signed char *ins)\n   return true;\n }\n \n-/* Generate reloads for matching OUT and INS (array of input operand\n-   numbers with end marker -1) with reg class GOAL_CLASS, considering\n-   output operands OUTS (similar array to INS) needing to be in different\n-   registers.  Add input and output reloads correspondingly to the lists\n-   *BEFORE and *AFTER.  OUT might be negative.  In this case we generate\n+/* Generate reloads for matching OUT and INS (array of input operand numbers\n+   with end marker -1) with reg class GOAL_CLASS and EXCLUDE_START_HARD_REGS,\n+   considering output operands OUTS (similar array to INS) needing to be in\n+   different registers.  Add input and output reloads correspondingly to the\n+   lists *BEFORE and *AFTER.  OUT might be negative.  In this case we generate\n    input reloads for matched input operands INS.  EARLY_CLOBBER_P is a flag\n    that the output operand is early clobbered for chosen alternative.  */\n static void\n match_reload (signed char out, signed char *ins, signed char *outs,\n-\t      enum reg_class goal_class, rtx_insn **before,\n-\t      rtx_insn **after, bool early_clobber_p)\n+\t      enum reg_class goal_class, HARD_REG_SET *exclude_start_hard_regs,\n+\t      rtx_insn **before, rtx_insn **after, bool early_clobber_p)\n {\n   bool out_conflict;\n   int i, in;\n@@ -1020,8 +1022,9 @@ match_reload (signed char out, signed char *ins, signed char *outs,\n       if (partial_subreg_p (outmode, inmode))\n \t{\n \t  reg = new_in_reg\n-\t    = lra_create_new_reg_with_unique_value (inmode, in_rtx,\n-\t\t\t\t\t\t    goal_class, \"\");\n+\t    = lra_create_new_reg_with_unique_value (inmode, in_rtx, goal_class,\n+\t\t\t\t\t\t    exclude_start_hard_regs,\n+\t\t\t\t\t\t    \"\");\n \t  new_out_reg = gen_lowpart_SUBREG (outmode, reg);\n \t  LRA_SUBREG_P (new_out_reg) = 1;\n \t  /* If the input reg is dying here, we can use the same hard\n@@ -1038,7 +1041,9 @@ match_reload (signed char out, signed char *ins, signed char *outs,\n \t{\n \t  reg = new_out_reg\n \t    = lra_create_new_reg_with_unique_value (outmode, out_rtx,\n-\t\t\t\t\t\t    goal_class, \"\");\n+\t\t\t\t\t\t    goal_class,\n+\t\t\t\t\t\t    exclude_start_hard_regs,\n+\t\t\t\t\t\t    \"\");\n \t  new_in_reg = gen_lowpart_SUBREG (inmode, reg);\n \t  /* NEW_IN_REG is non-paradoxical subreg.  We don't want\n \t     NEW_OUT_REG living above.  We add clobber clause for\n@@ -1121,9 +1126,11 @@ match_reload (signed char out, signed char *ins, signed char *outs,\n \t   && (out < 0\n \t       || regno_val_use_in (REGNO (in_rtx), out_rtx) == NULL_RTX)\n \t   && !out_conflict\n-\t   ? lra_create_new_reg (inmode, in_rtx, goal_class, \"\")\n-\t   : lra_create_new_reg_with_unique_value (outmode, out_rtx,\n-\t\t\t\t\t\t   goal_class, \"\"));\n+\t   ? lra_create_new_reg (inmode, in_rtx, goal_class,\n+\t\t\t\t exclude_start_hard_regs, \"\")\n+\t   : lra_create_new_reg_with_unique_value (outmode, out_rtx, goal_class,\n+\t\t\t\t\t\t   exclude_start_hard_regs,\n+\t\t\t\t\t\t   \"\"));\n     }\n   /* In operand can be got from transformations before processing insn\n      constraints.  One example of such transformations is subreg\n@@ -1360,7 +1367,7 @@ check_and_process_move (bool *change_p, bool *sec_mem_p ATTRIBUTE_UNUSED)\n   new_reg = NULL_RTX;\n   if (secondary_class != NO_REGS)\n     new_reg = lra_create_new_reg_with_unique_value (GET_MODE (src), NULL_RTX,\n-\t\t\t\t\t\t    secondary_class,\n+\t\t\t\t\t\t    secondary_class, NULL,\n \t\t\t\t\t\t    \"secondary\");\n   start_sequence ();\n   if (sri.icode == CODE_FOR_nothing)\n@@ -1373,7 +1380,7 @@ check_and_process_move (bool *change_p, bool *sec_mem_p ATTRIBUTE_UNUSED)\n \t\t       (insn_data[sri.icode].operand[2].constraint));\n       scratch_reg = (lra_create_new_reg_with_unique_value\n \t\t     (insn_data[sri.icode].operand[2].mode, NULL_RTX,\n-\t\t      scratch_class, \"scratch\"));\n+\t\t      scratch_class, NULL, \"scratch\"));\n       emit_insn (GEN_FCN (sri.icode) (new_reg != NULL_RTX ? new_reg : dest,\n \t\t\t\t      src, scratch_reg));\n     }\n@@ -1401,6 +1408,9 @@ check_and_process_move (bool *change_p, bool *sec_mem_p ATTRIBUTE_UNUSED)\n /* The chosen reg classes which should be used for the corresponding\n    operands.  */\n static enum reg_class goal_alt[MAX_RECOG_OPERANDS];\n+/* Hard registers which cannot be a start hard register for the corresponding\n+   operands.  */\n+static HARD_REG_SET goal_alt_exclude_start_hard_regs[MAX_RECOG_OPERANDS];\n /* True if the operand should be the same as another operand and that\n    other operand does not need a reload.  */\n static bool goal_alt_match_win[MAX_RECOG_OPERANDS];\n@@ -1492,7 +1502,8 @@ process_addr_reg (rtx *loc, bool check_only_p, rtx_insn **before, rtx_insn **aft\n \treturn true;\n       /* Always reload memory in an address even if the target supports\n \t such addresses.  */\n-      new_reg = lra_create_new_reg_with_unique_value (mode, reg, cl, \"address\");\n+      new_reg = lra_create_new_reg_with_unique_value (mode, reg, cl, NULL,\n+\t\t\t\t\t\t      \"address\");\n       before_p = true;\n     }\n   else\n@@ -1518,7 +1529,8 @@ process_addr_reg (rtx *loc, bool check_only_p, rtx_insn **before, rtx_insn **aft\n \t    return true;\n \t  reg = *loc;\n \t  if (get_reload_reg (after == NULL ? OP_IN : OP_INOUT,\n-\t\t\t      mode, reg, cl, subreg_p, \"address\", &new_reg))\n+\t\t\t      mode, reg, cl, NULL,\n+\t\t\t      subreg_p, \"address\", &new_reg))\n \t    before_p = true;\n \t}\n       else if (new_class != NO_REGS && rclass != new_class)\n@@ -1673,7 +1685,8 @@ simplify_operand_subreg (int nop, machine_mode reg_mode)\n \t  enum reg_class rclass\n \t    = (enum reg_class) targetm.preferred_reload_class (reg, ALL_REGS);\n \t  if (get_reload_reg (curr_static_id->operand[nop].type, innermode,\n-\t\t\t      reg, rclass, TRUE, \"slow/invalid mem\", &new_reg))\n+\t\t\t      reg, rclass, NULL,\n+\t\t\t      TRUE, \"slow/invalid mem\", &new_reg))\n \t    {\n \t      bool insert_before, insert_after;\n \t      bitmap_set_bit (&lra_subreg_reload_pseudos, REGNO (new_reg));\n@@ -1692,7 +1705,8 @@ simplify_operand_subreg (int nop, machine_mode reg_mode)\n \t  rclass\n \t    = (enum reg_class) targetm.preferred_reload_class (reg, ALL_REGS);\n \t  if (get_reload_reg (curr_static_id->operand[nop].type, mode, reg,\n-\t\t\t      rclass, TRUE, \"slow/invalid mem\", &new_reg))\n+\t\t\t      rclass, NULL,\n+\t\t\t      TRUE, \"slow/invalid mem\", &new_reg))\n \t    {\n \t      bool insert_before, insert_after;\n \t      bitmap_set_bit (&lra_subreg_reload_pseudos, REGNO (new_reg));\n@@ -1776,7 +1790,8 @@ simplify_operand_subreg (int nop, machine_mode reg_mode)\n \t  = (enum reg_class) targetm.preferred_reload_class (reg, ALL_REGS);\n \n       if (get_reload_reg (curr_static_id->operand[nop].type, reg_mode, reg,\n-\t\t\t  rclass, TRUE, \"subreg reg\", &new_reg))\n+\t\t\t  rclass, NULL,\n+\t\t\t  TRUE, \"subreg reg\", &new_reg))\n \t{\n \t  bool insert_before, insert_after;\n \t  bitmap_set_bit (&lra_subreg_reload_pseudos, REGNO (new_reg));\n@@ -1849,7 +1864,8 @@ simplify_operand_subreg (int nop, machine_mode reg_mode)\n \t= (enum reg_class) targetm.preferred_reload_class (reg, ALL_REGS);\n \n       if (get_reload_reg (curr_static_id->operand[nop].type, mode, reg,\n-                          rclass, TRUE, \"paradoxical subreg\", &new_reg))\n+                          rclass, NULL,\n+\t\t\t  TRUE, \"paradoxical subreg\", &new_reg))\n         {\n \t  rtx subreg;\n \t  bool insert_before, insert_after;\n@@ -2032,6 +2048,7 @@ process_alt_operands (int only_alternative)\n   int early_clobbered_nops[MAX_RECOG_OPERANDS];\n   enum reg_class curr_alt[MAX_RECOG_OPERANDS];\n   HARD_REG_SET curr_alt_set[MAX_RECOG_OPERANDS];\n+  HARD_REG_SET curr_alt_exclude_start_hard_regs[MAX_RECOG_OPERANDS];\n   bool curr_alt_match_win[MAX_RECOG_OPERANDS];\n   bool curr_alt_win[MAX_RECOG_OPERANDS];\n   bool curr_alt_offmemok[MAX_RECOG_OPERANDS];\n@@ -2133,6 +2150,7 @@ process_alt_operands (int only_alternative)\n \t  bool constmemok;\n \t  enum reg_class this_alternative, this_costly_alternative;\n \t  HARD_REG_SET this_alternative_set, this_costly_alternative_set;\n+\t  HARD_REG_SET this_alternative_exclude_start_hard_regs;\n \t  bool this_alternative_match_win, this_alternative_win;\n \t  bool this_alternative_offmemok;\n \t  bool scratch_p;\n@@ -2169,6 +2187,7 @@ process_alt_operands (int only_alternative)\n \t     pairs and there is no accurate intermediate class.\t */\n \t  CLEAR_HARD_REG_SET (this_alternative_set);\n \t  CLEAR_HARD_REG_SET (this_costly_alternative_set);\n+\t  CLEAR_HARD_REG_SET (this_alternative_exclude_start_hard_regs);\n \t  this_alternative_win = false;\n \t  this_alternative_match_win = false;\n \t  this_alternative_offmemok = false;\n@@ -2393,6 +2412,8 @@ process_alt_operands (int only_alternative)\n \t\t    badop = false;\n \t\t    this_alternative = curr_alt[m];\n \t\t    this_alternative_set = curr_alt_set[m];\n+\t\t    this_alternative_exclude_start_hard_regs\n+\t\t\t= curr_alt_exclude_start_hard_regs[m];\n \t\t    winreg = this_alternative != NO_REGS;\n \t\t    break;\n \t\t  }\n@@ -2478,6 +2499,8 @@ process_alt_operands (int only_alternative)\n \t\t    break;\n \t\t  this_alternative = reg_class_subunion[this_alternative][cl];\n \t\t  this_alternative_set |= reg_class_contents[cl];\n+\t\t  this_alternative_exclude_start_hard_regs\n+\t\t    |= ira_exclude_class_mode_regs[cl][mode];\n \t\t  if (costly_p)\n \t\t    {\n \t\t      this_costly_alternative\n@@ -2489,7 +2512,10 @@ process_alt_operands (int only_alternative)\n \t\t    {\n \t\t      if (hard_regno[nop] >= 0\n \t\t\t  && in_hard_reg_set_p (this_alternative_set,\n-\t\t\t\t\t\tmode, hard_regno[nop]))\n+\t\t\t\t\t\tmode, hard_regno[nop])\n+\t\t\t  && !TEST_HARD_REG_BIT\n+\t\t\t      (this_alternative_exclude_start_hard_regs,\n+\t\t\t       hard_regno[nop]))\n \t\t\twin = true;\n \t\t      else if (hard_regno[nop] < 0\n \t\t\t       && in_class_p (op, this_alternative, NULL))\n@@ -3001,6 +3027,8 @@ process_alt_operands (int only_alternative)\n \t    }\n \t  curr_alt[nop] = this_alternative;\n \t  curr_alt_set[nop] = this_alternative_set;\n+\t  curr_alt_exclude_start_hard_regs[nop]\n+\t    = this_alternative_exclude_start_hard_regs;\n \t  curr_alt_win[nop] = this_alternative_win;\n \t  curr_alt_match_win[nop] = this_alternative_match_win;\n \t  curr_alt_offmemok[nop] = this_alternative_offmemok;\n@@ -3200,6 +3228,8 @@ process_alt_operands (int only_alternative)\n \t      goal_alt_match_win[nop] = curr_alt_match_win[nop];\n \t      goal_alt_matches[nop] = curr_alt_matches[nop];\n \t      goal_alt[nop] = curr_alt[nop];\n+\t      goal_alt_exclude_start_hard_regs[nop]\n+\t\t= curr_alt_exclude_start_hard_regs[nop];\n \t      goal_alt_offmemok[nop] = curr_alt_offmemok[nop];\n \t    }\n \t  goal_alt_dont_inherit_ops_num = curr_alt_dont_inherit_ops_num;\n@@ -3236,8 +3266,8 @@ base_to_reg (struct address_info *ad)\n   lra_assert (ad->disp == ad->disp_term);\n   cl = base_reg_class (ad->mode, ad->as, ad->base_outer_code,\n                        get_index_code (ad));\n-  new_reg = lra_create_new_reg (GET_MODE (*ad->base), NULL_RTX,\n-                                cl, \"base\");\n+  new_reg = lra_create_new_reg (GET_MODE (*ad->base), NULL_RTX, cl, NULL,\n+\t\t\t\t\"base\");\n   new_inner = simplify_gen_binary (PLUS, GET_MODE (new_reg), new_reg,\n                                    ad->disp_term == NULL\n                                    ? const0_rtx\n@@ -3265,8 +3295,8 @@ base_plus_disp_to_reg (struct address_info *ad, rtx disp)\n   lra_assert (ad->base == ad->base_term);\n   cl = base_reg_class (ad->mode, ad->as, ad->base_outer_code,\n \t\t       get_index_code (ad));\n-  new_reg = lra_create_new_reg (GET_MODE (*ad->base_term), NULL_RTX,\n-\t\t\t\tcl, \"base + disp\");\n+  new_reg = lra_create_new_reg (GET_MODE (*ad->base_term), NULL_RTX, cl, NULL,\n+\t\t\t\t\"base + disp\");\n   lra_emit_add (new_reg, *ad->base_term, disp);\n   return new_reg;\n }\n@@ -3279,7 +3309,7 @@ index_part_to_reg (struct address_info *ad)\n   rtx new_reg;\n \n   new_reg = lra_create_new_reg (GET_MODE (*ad->index), NULL_RTX,\n-\t\t\t\tINDEX_REG_CLASS, \"index term\");\n+\t\t\t\tINDEX_REG_CLASS, NULL, \"index term\");\n   expand_mult (GET_MODE (*ad->index), *ad->index_term,\n \t       GEN_INT (get_index_scale (ad)), new_reg, 1);\n   return new_reg;\n@@ -3576,7 +3606,7 @@ process_address_1 (int nop, bool check_only_p,\n \t\t\t\t\t      SCRATCH, SCRATCH);\n \t  rtx addr = *ad.inner;\n \n-\t  new_reg = lra_create_new_reg (Pmode, NULL_RTX, cl, \"addr\");\n+\t  new_reg = lra_create_new_reg (Pmode, NULL_RTX, cl, NULL, \"addr\");\n \t  if (HAVE_lo_sum)\n \t    {\n \t      /* addr => lo_sum (new_base, addr), case (2) above.  */\n@@ -3639,7 +3669,7 @@ process_address_1 (int nop, bool check_only_p,\n \t\t\t\t\t      GET_CODE (*ad.index));\n \n \t  lra_assert (INDEX_REG_CLASS != NO_REGS);\n-\t  new_reg = lra_create_new_reg (Pmode, NULL_RTX, cl, \"disp\");\n+\t  new_reg = lra_create_new_reg (Pmode, NULL_RTX, cl, NULL, \"disp\");\n \t  lra_emit_move (new_reg, *ad.disp);\n \t  *ad.inner = simplify_gen_binary (PLUS, GET_MODE (new_reg),\n \t\t\t\t\t   new_reg, *ad.index);\n@@ -3744,7 +3774,7 @@ process_address_1 (int nop, bool check_only_p,\n \t\t\t\t\t  SCRATCH, SCRATCH);\n       rtx addr = *ad.inner;\n       \n-      new_reg = lra_create_new_reg (Pmode, NULL_RTX, cl, \"addr\");\n+      new_reg = lra_create_new_reg (Pmode, NULL_RTX, cl, NULL, \"addr\");\n       /* addr => new_base.  */\n       lra_emit_move (new_reg, addr);\n       *ad.inner = new_reg;\n@@ -3820,7 +3850,7 @@ emit_inc (enum reg_class new_rclass, rtx in, rtx value, poly_int64 inc_amount)\n   if (! post && REG_P (incloc))\n     result = incloc;\n   else\n-    result = lra_create_new_reg (GET_MODE (value), value, new_rclass,\n+    result = lra_create_new_reg (GET_MODE (value), value, new_rclass, NULL,\n \t\t\t\t \"INC/DEC result\");\n \n   if (real_in != result)\n@@ -4202,8 +4232,8 @@ curr_insn_transform (bool check_only_p)\n       rld = partial_subreg_p (GET_MODE (src), GET_MODE (dest)) ? src : dest;\n       rld_mode = GET_MODE (rld);\n       sec_mode = targetm.secondary_memory_needed_mode (rld_mode);\n-      new_reg = lra_create_new_reg (sec_mode, NULL_RTX,\n-\t\t\t\t    NO_REGS, \"secondary\");\n+      new_reg = lra_create_new_reg (sec_mode, NULL_RTX, NO_REGS, NULL,\n+\t\t\t\t    \"secondary\");\n       /* If the mode is changed, it should be wider.  */\n       lra_assert (!partial_subreg_p (sec_mode, rld_mode));\n       if (sec_mode != rld_mode)\n@@ -4458,7 +4488,8 @@ curr_insn_transform (bool check_only_p)\n \t\t     input registers.  This is the easiest way to avoid\n \t\t     creation of non-existing register conflicts in\n \t\t     lra-lives.cc.  */\n-\t\t  match_reload (i, goal_alt_matched[i], outputs, goal_alt[i], &before,\n+\t\t  match_reload (i, goal_alt_matched[i], outputs, goal_alt[i],\n+\t\t\t\t&goal_alt_exclude_start_hard_regs[i], &before,\n \t\t\t\t&after, TRUE);\n \t\t}\n \t      continue;\n@@ -4488,7 +4519,8 @@ curr_insn_transform (bool check_only_p)\n \t    new_reg = emit_inc (rclass, *loc, *loc,\n \t\t\t\t/* This value does not matter for MODIFY.  */\n \t\t\t\tGET_MODE_SIZE (GET_MODE (op)));\n-\t  else if (get_reload_reg (OP_IN, Pmode, *loc, rclass, FALSE,\n+\t  else if (get_reload_reg (OP_IN, Pmode, *loc, rclass,\n+\t\t\t\t   NULL, FALSE,\n \t\t\t\t   \"offsetable address\", &new_reg))\n \t    {\n \t      rtx addr = *loc;\n@@ -4562,6 +4594,7 @@ curr_insn_transform (bool check_only_p)\n \t    }\n \t  old = *loc;\n \t  if (get_reload_reg (type, mode, old, goal_alt[i],\n+\t\t\t      &goal_alt_exclude_start_hard_regs[i],\n \t\t\t      loc != curr_id->operand_loc[i], \"\", &new_reg)\n \t      && type != OP_OUT)\n \t    {\n@@ -4603,7 +4636,8 @@ curr_insn_transform (bool check_only_p)\n \t  match_inputs[0] = i;\n \t  match_inputs[1] = -1;\n \t  match_reload (goal_alt_matched[i][0], match_inputs, outputs,\n-\t\t\tgoal_alt[i], &before, &after,\n+\t\t\tgoal_alt[i], &goal_alt_exclude_start_hard_regs[i],\n+\t\t\t&before, &after,\n \t\t\tcurr_static_id->operand_alternative\n \t\t\t[goal_alt_number * n_operands + goal_alt_matched[i][0]]\n \t\t\t.earlyclobber);\n@@ -4617,9 +4651,10 @@ curr_insn_transform (bool check_only_p)\n \t       && (curr_static_id->operand[goal_alt_matched[i][0]].type\n \t\t    == OP_IN))\n \t/* Generate reloads for output and matched inputs.  */\n-\tmatch_reload (i, goal_alt_matched[i], outputs, goal_alt[i], &before,\n-\t\t      &after, curr_static_id->operand_alternative\n-\t\t\t      [goal_alt_number * n_operands + i].earlyclobber);\n+\tmatch_reload (i, goal_alt_matched[i], outputs, goal_alt[i],\n+\t\t      &goal_alt_exclude_start_hard_regs[i], &before, &after,\n+\t\t      curr_static_id->operand_alternative\n+\t\t      [goal_alt_number * n_operands + i].earlyclobber);\n       else if (curr_static_id->operand[i].type == OP_IN\n \t       && (curr_static_id->operand[goal_alt_matched[i][0]].type\n \t\t   == OP_IN))\n@@ -4629,8 +4664,9 @@ curr_insn_transform (bool check_only_p)\n \t  for (j = 0; (k = goal_alt_matched[i][j]) >= 0; j++)\n \t    match_inputs[j + 1] = k;\n \t  match_inputs[j + 1] = -1;\n-\t  match_reload (-1, match_inputs, outputs, goal_alt[i], &before,\n-\t\t\t&after, false);\n+\t  match_reload (-1, match_inputs, outputs, goal_alt[i],\n+\t\t\t&goal_alt_exclude_start_hard_regs[i],\n+\t\t\t&before, &after, false);\n \t}\n       else\n \t/* We must generate code in any case when function\n@@ -5535,7 +5571,7 @@ inherit_reload_reg (bool def_p, int original_regno,\n       return false;\n     }\n   new_reg = lra_create_new_reg (GET_MODE (original_reg), original_reg,\n-\t\t\t\trclass, \"inheritance\");\n+\t\t\t\trclass, NULL, \"inheritance\");\n   start_sequence ();\n   if (def_p)\n     lra_emit_move (original_reg, new_reg);\n@@ -5824,7 +5860,7 @@ split_reg (bool before_p, int original_regno, rtx_insn *insn,\n       mode = HARD_REGNO_CALLER_SAVE_MODE (hard_regno,\n \t\t\t\t\t  hard_regno_nregs (hard_regno, mode),\n \t\t\t\t\t  mode);\n-      new_reg = lra_create_new_reg (mode, NULL_RTX, NO_REGS, \"save\");\n+      new_reg = lra_create_new_reg (mode, NULL_RTX, NO_REGS, NULL, \"save\");\n     }\n   else\n     {\n@@ -5866,7 +5902,7 @@ split_reg (bool before_p, int original_regno, rtx_insn *insn,\n \t    }\n \t  return false;\n \t}\n-      new_reg = lra_create_new_reg (mode, original_reg, rclass, \"split\");\n+      new_reg = lra_create_new_reg (mode, original_reg, rclass, NULL, \"split\");\n       reg_renumber[REGNO (new_reg)] = hard_regno;\n     }\n   int new_regno = REGNO (new_reg);\n@@ -6152,8 +6188,8 @@ process_invariant_for_inheritance (rtx dst_reg, rtx invariant_rtx)\n \t  if (lra_dump_file != NULL)\n \t    fprintf (lra_dump_file,\n \t\t     \"    [[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[\\n\");\n-\t  new_reg = lra_create_new_reg (dst_mode, dst_reg,\n-\t\t\t\t\tcl, \"invariant inheritance\");\n+\t  new_reg = lra_create_new_reg (dst_mode, dst_reg, cl, NULL,\n+\t\t\t\t\t\"invariant inheritance\");\n \t  bitmap_set_bit (&lra_inheritance_pseudos, REGNO (new_reg));\n \t  bitmap_set_bit (&check_only_regs, REGNO (new_reg));\n \t  lra_reg_info[REGNO (new_reg)].restore_rtx = PATTERN (insn);"}, {"sha": "04baefef3483b51d0c5cc5b84e0897775eadadea", "filename": "gcc/lra-int.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85419ac59724b7ce710ebb4acf03dbd747edeea3/gcc%2Flra-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85419ac59724b7ce710ebb4acf03dbd747edeea3/gcc%2Flra-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-int.h?ref=85419ac59724b7ce710ebb4acf03dbd747edeea3", "patch": "@@ -73,6 +73,9 @@ class lra_reg\n   /* The following fields are defined only for pseudos.\t */\n   /* Hard registers with which the pseudo conflicts.  */\n   HARD_REG_SET conflict_hard_regs;\n+  /* Pseudo allocno class hard registers which cannot be a start hard register\n+     of the pseudo.  */\n+  HARD_REG_SET exclude_start_hard_regs;\n   /* We assign hard registers to reload pseudos which can occur in few\n      places.  So two hard register preferences are enough for them.\n      The following fields define the preferred hard registers.\tIf\n@@ -292,8 +295,11 @@ extern void lra_push_insn_and_update_insn_regno_info (rtx_insn *);\n extern rtx_insn *lra_pop_insn (void);\n extern unsigned int lra_insn_stack_length (void);\n \n+extern rtx lra_create_new_reg (machine_mode, rtx, enum reg_class, HARD_REG_SET *,\n+\t\t\t       const char *);\n extern rtx lra_create_new_reg_with_unique_value (machine_mode, rtx,\n-\t\t\t\t\t\t enum reg_class, const char *);\n+\t\t\t\t\t\t enum reg_class, HARD_REG_SET *,\n+\t\t\t\t\t\t const char *);\n extern void lra_set_regno_unique_value (int);\n extern void lra_invalidate_insn_data (rtx_insn *);\n extern void lra_set_insn_deleted (rtx_insn *);"}, {"sha": "5079eb50f28b4f7cfc15d7e1ef67c63d629405da", "filename": "gcc/lra-remat.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85419ac59724b7ce710ebb4acf03dbd747edeea3/gcc%2Flra-remat.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85419ac59724b7ce710ebb4acf03dbd747edeea3/gcc%2Flra-remat.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-remat.cc?ref=85419ac59724b7ce710ebb4acf03dbd747edeea3", "patch": "@@ -1039,7 +1039,7 @@ update_scratch_ops (rtx_insn *remat_insn)\n       if (! ira_former_scratch_p (regno))\n \tcontinue;\n       *loc = lra_create_new_reg (GET_MODE (*loc), *loc,\n-\t\t\t\t lra_get_allocno_class (regno),\n+\t\t\t\t lra_get_allocno_class (regno), NULL,\n \t\t\t\t \"scratch pseudo copy\");\n       ira_register_new_scratch_op (remat_insn, i, id->icode);\n     }"}, {"sha": "5ef077c70290c4241143397a581e0385c113eee7", "filename": "gcc/lra.cc", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85419ac59724b7ce710ebb4acf03dbd747edeea3/gcc%2Flra.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85419ac59724b7ce710ebb4acf03dbd747edeea3/gcc%2Flra.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.cc?ref=85419ac59724b7ce710ebb4acf03dbd747edeea3", "patch": "@@ -179,7 +179,9 @@ expand_reg_data (int old)\n    will have unique held value.  */\n rtx\n lra_create_new_reg_with_unique_value (machine_mode md_mode, rtx original,\n-\t\t\t\t      enum reg_class rclass, const char *title)\n+\t\t\t\t      enum reg_class rclass,\n+\t\t\t\t      HARD_REG_SET *exclude_start_hard_regs,\n+\t\t\t\t      const char *title)\n {\n   machine_mode mode;\n   rtx new_reg;\n@@ -214,19 +216,23 @@ lra_create_new_reg_with_unique_value (machine_mode md_mode, rtx original,\n     }\n   expand_reg_data (max_reg_num ());\n   setup_reg_classes (REGNO (new_reg), rclass, NO_REGS, rclass);\n+  if (exclude_start_hard_regs != NULL)\n+    lra_reg_info[REGNO (new_reg)].exclude_start_hard_regs\n+      = *exclude_start_hard_regs;\n   return new_reg;\n }\n \n /* Analogous to the previous function but also inherits value of\n    ORIGINAL.  */\n rtx\n-lra_create_new_reg (machine_mode md_mode, rtx original,\n-\t\t    enum reg_class rclass, const char *title)\n+lra_create_new_reg (machine_mode md_mode, rtx original, enum reg_class rclass,\n+\t\t    HARD_REG_SET *exclude_start_hard_regs, const char *title)\n {\n   rtx new_reg;\n \n   new_reg\n-    = lra_create_new_reg_with_unique_value (md_mode, original, rclass, title);\n+    = lra_create_new_reg_with_unique_value (md_mode, original, rclass,\n+\t\t\t\t\t    exclude_start_hard_regs, title);\n   if (original != NULL_RTX && REG_P (original))\n     lra_assign_reg_val (REGNO (original), REGNO (new_reg));\n   return new_reg;\n@@ -1319,6 +1325,7 @@ initialize_lra_reg_info_element (int i)\n   lra_reg_info[i].no_stack_p = false;\n #endif\n   CLEAR_HARD_REG_SET (lra_reg_info[i].conflict_hard_regs);\n+  CLEAR_HARD_REG_SET (lra_reg_info[i].exclude_start_hard_regs);\n   lra_reg_info[i].preferred_hard_regno1 = -1;\n   lra_reg_info[i].preferred_hard_regno2 = -1;\n   lra_reg_info[i].preferred_hard_regno_profit1 = 0;\n@@ -2042,7 +2049,8 @@ lra_substitute_pseudo_within_insn (rtx_insn *insn, int old_regno,\n static rtx\n get_scratch_reg (rtx original)\n {\n-  return lra_create_new_reg (GET_MODE (original), original, ALL_REGS, NULL);\n+  return lra_create_new_reg (GET_MODE (original), original, ALL_REGS,\n+\t\t\t     NULL, NULL);\n }\n \n /* Remove all insn scratches in INSN.  */"}, {"sha": "4dd6cac7f4d978fecdbdc60414287dfc5b76d6fb", "filename": "gcc/lra.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85419ac59724b7ce710ebb4acf03dbd747edeea3/gcc%2Flra.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85419ac59724b7ce710ebb4acf03dbd747edeea3/gcc%2Flra.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.h?ref=85419ac59724b7ce710ebb4acf03dbd747edeea3", "patch": "@@ -34,8 +34,6 @@ lra_get_allocno_class (int regno)\n   return reg_allocno_class (regno);\n }\n \n-extern rtx lra_create_new_reg (machine_mode, rtx, enum reg_class,\n-\t\t\t       const char *);\n extern rtx lra_eliminate_regs (rtx, machine_mode, rtx);\n extern void lra (FILE *);\n extern void lra_init_once (void);"}, {"sha": "1607564ff5d1e54607d9aa127616ec10773644e1", "filename": "gcc/testsuite/g++.target/arm/pr103676.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85419ac59724b7ce710ebb4acf03dbd747edeea3/gcc%2Ftestsuite%2Fg%2B%2B.target%2Farm%2Fpr103676.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85419ac59724b7ce710ebb4acf03dbd747edeea3/gcc%2Ftestsuite%2Fg%2B%2B.target%2Farm%2Fpr103676.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Farm%2Fpr103676.C?ref=85419ac59724b7ce710ebb4acf03dbd747edeea3", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_thumb1_ok } */\n+/* { dg-additional-options \"-mcpu=cortex-m7 -mthumb -O2\" }  */\n+\n+typedef unsigned long long uint64_t;\n+struct timer {\n+ int active;\n+ uint64_t expire;\n+ void *arg;\n+};\n+int irq_disable();\n+void irq_restore(int);\n+static inline uint64_t h(const  uint64_t *p64)\n+{\n+ uint64_t tmp;\n+ asm(\n+  \"ldrd %Q[r], %R[r], %[p]\\n\"\n+  : [r]\"=lh\"(tmp)\n+  : [p]\"m\"(*p64)\n+  : \"memory\"\n+ );\n+ return tmp;\n+}\n+uint64_t monotonic;\n+void timer_callout(timer *tmr, uint64_t nsec, void *arg)\n+{\n+ const int s = irq_disable();\n+ if (tmr->active)\n+   tmr->arg = arg;\n+ tmr->expire = h(&monotonic) + 100000 + (nsec == 1 ? 0 : nsec);\n+ irq_restore(s);\n+}"}]}