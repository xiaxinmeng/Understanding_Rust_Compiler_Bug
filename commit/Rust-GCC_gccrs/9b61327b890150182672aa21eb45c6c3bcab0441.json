{"sha": "9b61327b890150182672aa21eb45c6c3bcab0441", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWI2MTMyN2I4OTAxNTAxODI2NzJhYTIxZWI0NWM2YzNiY2FiMDQ0MQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@codesourcery.com", "date": "2006-01-14T15:42:11Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2006-01-14T15:42:11Z"}, "message": "re PR tree-optimization/25485 (VRP misses an \"if\" with TRUTH_AND_EXPR statement that could be optimized away)\n\ngcc/\n\tPR tree-optimization/25485\n\t* tree-vrp.c (extract_range_from_binary_expr): Handle cases\n\twhere one of the operands of TRUTH_AND_EXPR and TRUTH_OR_EXPR\n\tis known to be false and true, respectively.\n\ngcc/testsuite/\n\tPR tree-optimization/25485\n\t* gcc.dg/tree-ssa/pr25485.c: New.\n\nFrom-SVN: r109704", "tree": {"sha": "355ef3795da06c59605a8d8b7e753114173b953d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/355ef3795da06c59605a8d8b7e753114173b953d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b61327b890150182672aa21eb45c6c3bcab0441", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b61327b890150182672aa21eb45c6c3bcab0441", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b61327b890150182672aa21eb45c6c3bcab0441", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b61327b890150182672aa21eb45c6c3bcab0441/comments", "author": null, "committer": null, "parents": [{"sha": "a916f21d3c176a23f54114a17605813a31cd5d2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a916f21d3c176a23f54114a17605813a31cd5d2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a916f21d3c176a23f54114a17605813a31cd5d2e"}], "stats": {"total": 75, "additions": 72, "deletions": 3}, "files": [{"sha": "d7cc76a8e229509ee692514c4fd9de74e7dd9fcd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b61327b890150182672aa21eb45c6c3bcab0441/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b61327b890150182672aa21eb45c6c3bcab0441/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9b61327b890150182672aa21eb45c6c3bcab0441", "patch": "@@ -1,3 +1,10 @@\n+2006-01-14  Kazu Hirata  <kazu@codesourcery.com>\n+\n+\tPR tree-optimization/25485\n+\t* tree-vrp.c (extract_range_from_binary_expr): Handle cases\n+\twhere one of the operands of TRUTH_AND_EXPR and TRUTH_OR_EXPR\n+\tis known to be false and true, respectively.\n+\n 2006-01-14  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/22548"}, {"sha": "5567ae32bbaf6aac7f8e022514cc0147651dad4c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b61327b890150182672aa21eb45c6c3bcab0441/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b61327b890150182672aa21eb45c6c3bcab0441/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9b61327b890150182672aa21eb45c6c3bcab0441", "patch": "@@ -1,3 +1,8 @@\n+2006-01-14  Kazu Hirata  <kazu@codesourcery.com>\n+\n+\tPR tree-optimization/25485\n+\t* gcc.dg/tree-ssa/pr25485.c: New.\n+\n 2006-01-14  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/22548"}, {"sha": "7d76d07a7f6f02544b68d4aba02af46efdbbd78e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr25485.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b61327b890150182672aa21eb45c6c3bcab0441/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr25485.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b61327b890150182672aa21eb45c6c3bcab0441/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr25485.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr25485.c?ref=9b61327b890150182672aa21eb45c6c3bcab0441", "patch": "@@ -0,0 +1,17 @@\n+/* PR tree-optimization/25485\n+   VRP did not fold TRUTH_AND_EXPR.  Make sure it does now.  */\n+\n+/* { dg-options \"-O2 -fdump-tree-vrp\" } */\n+\n+int\n+foo (int a, int b)\n+{\n+  if (a > 50)\n+    return 19;\n+  if (a > 63 && b < 50)\n+    return 17;\n+  return 31;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"if\" 1 \"vrp\"} } */\n+/* { dg-final { cleanup-tree-dump \"vrp\" } } */"}, {"sha": "6bd4725ea1cd6f078aea51375a4af34890f5dffe", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 43, "deletions": 3, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b61327b890150182672aa21eb45c6c3bcab0441/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b61327b890150182672aa21eb45c6c3bcab0441/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=9b61327b890150182672aa21eb45c6c3bcab0441", "patch": "@@ -1230,6 +1230,8 @@ extract_range_from_binary_expr (value_range_t *vr, tree expr)\n      the operands is VR_VARYING or symbolic range.  TODO, we may be\n      able to derive anti-ranges in some cases.  */\n   if (code != BIT_AND_EXPR\n+      && code != TRUTH_AND_EXPR\n+      && code != TRUTH_OR_EXPR\n       && (vr0.type == VR_VARYING\n \t  || vr1.type == VR_VARYING\n \t  || vr0.type != vr1.type\n@@ -1277,9 +1279,47 @@ extract_range_from_binary_expr (value_range_t *vr, tree expr)\n       || code == TRUTH_OR_EXPR\n       || code == TRUTH_XOR_EXPR)\n     {\n-      /* Boolean expressions cannot be folded with int_const_binop.  */\n-      min = fold_binary (code, TREE_TYPE (expr), vr0.min, vr1.min);\n-      max = fold_binary (code, TREE_TYPE (expr), vr0.max, vr1.max);\n+      /* If one of the operands is zero, we know that the whole\n+\t expression evaluates zero.  */\n+      if (code == TRUTH_AND_EXPR\n+\t  && ((vr0.type == VR_RANGE\n+\t       && integer_zerop (vr0.min)\n+\t       && integer_zerop (vr0.max))\n+\t      || (vr1.type == VR_RANGE\n+\t\t  && integer_zerop (vr1.min)\n+\t\t  && integer_zerop (vr1.max))))\n+\t{\n+\t  type = VR_RANGE;\n+\t  min = max = build_int_cst (TREE_TYPE (expr), 0);\n+\t}\n+      /* If one of the operands is one, we know that the whole\n+\t expression evaluates one.  */\n+      else if (code == TRUTH_OR_EXPR\n+\t       && ((vr0.type == VR_RANGE\n+\t\t    && integer_onep (vr0.min)\n+\t\t    && integer_onep (vr0.max))\n+\t\t   || (vr1.type == VR_RANGE\n+\t\t       && integer_onep (vr1.min)\n+\t\t       && integer_onep (vr1.max))))\n+\t{\n+\t  type = VR_RANGE;\n+\t  min = max = build_int_cst (TREE_TYPE (expr), 1);\n+\t}\n+      else if (vr0.type != VR_VARYING\n+\t       && vr1.type != VR_VARYING\n+\t       && vr0.type == vr1.type\n+\t       && !symbolic_range_p (&vr0)\n+\t       && !symbolic_range_p (&vr1))\n+\t{\n+\t  /* Boolean expressions cannot be folded with int_const_binop.  */\n+\t  min = fold_binary (code, TREE_TYPE (expr), vr0.min, vr1.min);\n+\t  max = fold_binary (code, TREE_TYPE (expr), vr0.max, vr1.max);\n+\t}\n+      else\n+\t{\n+\t  set_value_range_to_varying (vr);\n+\t  return;\n+\t}\n     }\n   else if (code == PLUS_EXPR\n \t   || code == MIN_EXPR"}]}