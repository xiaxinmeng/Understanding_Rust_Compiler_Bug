{"sha": "6d7306f76e1ce9f0a45c8206c3c256f6e1fe710e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmQ3MzA2Zjc2ZTFjZTlmMGE0NWM4MjA2YzNjMjU2ZjZlMWZlNzEwZQ==", "commit": {"author": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1996-03-26T00:17:01Z"}, "committer": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1996-03-26T00:17:01Z"}, "message": "(expand_function_start): Don't set up context_display\n        unless current_function_needs_context.\n\nFrom-SVN: r11615", "tree": {"sha": "fbb56f455b5f3b468325acfd747c9ae6e5dbdd2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fbb56f455b5f3b468325acfd747c9ae6e5dbdd2d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d7306f76e1ce9f0a45c8206c3c256f6e1fe710e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d7306f76e1ce9f0a45c8206c3c256f6e1fe710e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d7306f76e1ce9f0a45c8206c3c256f6e1fe710e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d7306f76e1ce9f0a45c8206c3c256f6e1fe710e/comments", "author": null, "committer": null, "parents": [{"sha": "65d8b1ce9fbf4b70cd210d04caf700b1506f617f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65d8b1ce9fbf4b70cd210d04caf700b1506f617f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65d8b1ce9fbf4b70cd210d04caf700b1506f617f"}], "stats": {"total": 72, "additions": 38, "deletions": 34}, "files": [{"sha": "f6ffe09ce7a329d750106f1bff6b9dce2c5a5d21", "filename": "gcc/function.c", "status": "modified", "additions": 38, "deletions": 34, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d7306f76e1ce9f0a45c8206c3c256f6e1fe710e/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d7306f76e1ce9f0a45c8206c3c256f6e1fe710e/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=6d7306f76e1ce9f0a45c8206c3c256f6e1fe710e", "patch": "@@ -5230,48 +5230,52 @@ expand_function_start (subr, parms_have_cleanups)\n \tuse_variable (current_function_internal_arg_pointer);\n     }\n \n-  /* Fetch static chain values for containing functions.  */\n-  tem = decl_function_context (current_function_decl);\n-  /* If not doing stupid register allocation copy the static chain\n-     pointer into a pseudo.  If we have small register classes, copy the\n-     value from memory if static_chain_incoming_rtx is a REG.  If we do\n-     stupid register allocation, we use the stack address generated above.  */\n-  if (tem && ! obey_regdecls)\n+  context_display = 0;\n+  if (current_function_needs_context)\n     {\n+      /* Fetch static chain values for containing functions.  */\n+      tem = decl_function_context (current_function_decl);\n+      /* If not doing stupid register allocation copy the static chain\n+\t pointer into a pseudo.  If we have small register classes, copy\n+\t the value from memory if static_chain_incoming_rtx is a REG.  If\n+\t we do stupid register allocation, we use the stack address\n+\t generated above.  */\n+      if (tem && ! obey_regdecls)\n+\t{\n #ifdef SMALL_REGISTER_CLASSES\n-      /* If the static chain originally came in a register, put it back\n-\t there, then move it out in the next insn.  The reason for\n-\t this peculiar code is to satisfy function integration.  */\n-      if (GET_CODE (static_chain_incoming_rtx) == REG)\n-\temit_move_insn (static_chain_incoming_rtx, last_ptr);\n+\t  /* If the static chain originally came in a register, put it back\n+\t     there, then move it out in the next insn.  The reason for\n+\t     this peculiar code is to satisfy function integration.  */\n+\t  if (GET_CODE (static_chain_incoming_rtx) == REG)\n+\t    emit_move_insn (static_chain_incoming_rtx, last_ptr);\n #endif\n \n-      last_ptr = copy_to_reg (static_chain_incoming_rtx);\n-    }\n+\t  last_ptr = copy_to_reg (static_chain_incoming_rtx);\n+\t}\n \n-  context_display = 0;\n-  while (tem)\n-    {\n-      tree rtlexp = make_node (RTL_EXPR);\n+      while (tem)\n+\t{\n+\t  tree rtlexp = make_node (RTL_EXPR);\n \n-      RTL_EXPR_RTL (rtlexp) = last_ptr;\n-      context_display = tree_cons (tem, rtlexp, context_display);\n-      tem = decl_function_context (tem);\n-      if (tem == 0)\n-\tbreak;\n-      /* Chain thru stack frames, assuming pointer to next lexical frame\n-\t is found at the place we always store it.  */\n+\t  RTL_EXPR_RTL (rtlexp) = last_ptr;\n+\t  context_display = tree_cons (tem, rtlexp, context_display);\n+\t  tem = decl_function_context (tem);\n+\t  if (tem == 0)\n+\t    break;\n+\t  /* Chain thru stack frames, assuming pointer to next lexical frame\n+\t     is found at the place we always store it.  */\n #ifdef FRAME_GROWS_DOWNWARD\n-      last_ptr = plus_constant (last_ptr, - GET_MODE_SIZE (Pmode));\n+\t  last_ptr = plus_constant (last_ptr, - GET_MODE_SIZE (Pmode));\n #endif\n-      last_ptr = copy_to_reg (gen_rtx (MEM, Pmode,\n-\t\t\t\t       memory_address (Pmode, last_ptr)));\n-\n-      /* If we are not optimizing, ensure that we know that this\n-\t piece of context is live over the entire function.  */\n-      if (! optimize)\n-\tsave_expr_regs = gen_rtx (EXPR_LIST, VOIDmode, last_ptr,\n-\t\t\t\t  save_expr_regs);\n+\t  last_ptr = copy_to_reg (gen_rtx (MEM, Pmode,\n+\t\t\t\t\t   memory_address (Pmode, last_ptr)));\n+\n+\t  /* If we are not optimizing, ensure that we know that this\n+\t     piece of context is live over the entire function.  */\n+\t  if (! optimize)\n+\t    save_expr_regs = gen_rtx (EXPR_LIST, VOIDmode, last_ptr,\n+\t\t\t\t      save_expr_regs);\n+\t}\n     }\n \n   /* After the display initializations is where the tail-recursion label"}]}