{"sha": "02ed62dd463d55d9d9810b9c8829691e7814743d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDJlZDYyZGQ0NjNkNTVkOWQ5ODEwYjljODgyOTY5MWU3ODE0NzQzZA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2005-10-16T19:38:57Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2005-10-16T19:38:57Z"}, "message": "re PR c++/22137 (Internal error: Segmentation fault (program cc1plus))\n\n\tPR c++/22137\n\t* cp-tree.h (QUALIFIED_NAME_IS_TEMPLATE): New macro.\n\t(check_template_keyword): New function.\n\t(finish_id_expression): Change prototoype.\n\t(finish_qualified_id_expr): Change prototype.\n\t(build_qualified_name): New function.\n\t(finish_class_member_access_expr): Change prototype.\n\t* init.c (build_offset_ref): Use build_qualified_name.\n\t* mangle.c (write_expression): Likewise.\n\t* parser.c (cp_parser_primary_expression): Remove qualifying_class\n\tparameter.  Add address_p and template_arg_p.  Use\n\tbuild_qualified_name.\n\t(cp_parser_id_expression): Default *template_p to\n\ttemplate_keyword_p.  Check for invalid uses of the template\n\tkeyword.\n\t(cp_parser_postfix_expression): Eliminate special handling for\n\tqualified names.  Adjust call to cp_parser_primary_expression.\n\t(cp_parser_postfix_dot_deref_expression): Adjust call to\n\tcp_parser_id_expression and finish_class_member_access_expr.\n\t(cp_parser_template_argument_list): Add comment.\n\t(cp_parser_template_argument): Adjust use of\n\tcp_parser_primary_expression.  Remove call to\n\tfinish_qualified_id_expr.\n\t(cp_parser_lookup_name): Use build_qualified_name.\n\t* pt.c (tsubst): Use build_qualified_name.\n\t(tsubst_qualified_id): Likewise.  Adjust call to\n\tfinish_qualified_id_expr.\n\t(tsubst_copy): Use build_qualified_name.\n\t(tsubst_copy_and_build): Adjusts call to finish_id_expression and\n\tfinish_class_member_access_expr.\n\t* semantics.c (finish_non_static_data_member): Use\n\tbuild_qualified_name.\n\t(finish_qualified_id_expr): Add template_p and template_arg_p\n\tparameters.\n\t(finish_id_expression): Remove qualifiying_class parameter.  Add\n\ttemplate_p, done, address_p, and template_arg_p.  Use\n\tbuild_qualified_name.  Adjust calls to\n\tfinish_class_member_acess_expr.\n\t* tree.c (build_qualified_name): New function.\n\t* typeck.c (check_template_keyword): New function.\n\t(finish_class_member_access_expr): Add template_p argument.  Check\n\tfor invalid uses of the template keyword.\n\n\tPR c++/22137\n\t* g++.dg/parse/template18.C: New test.\n\t* g++.dg/template/nontype15.C: Likewise.\n\nFrom-SVN: r105463", "tree": {"sha": "76f4797c33c693120da1fa591e01740f0bef605d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/76f4797c33c693120da1fa591e01740f0bef605d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/02ed62dd463d55d9d9810b9c8829691e7814743d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02ed62dd463d55d9d9810b9c8829691e7814743d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02ed62dd463d55d9d9810b9c8829691e7814743d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02ed62dd463d55d9d9810b9c8829691e7814743d/comments", "author": null, "committer": null, "parents": [{"sha": "c2b27658fe406ae890354dd825e4060d65df7e0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2b27658fe406ae890354dd825e4060d65df7e0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2b27658fe406ae890354dd825e4060d65df7e0a"}], "stats": {"total": 545, "additions": 405, "deletions": 140}, "files": [{"sha": "9d3930fe23eb8f896374254b71a41094136b07a8", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02ed62dd463d55d9d9810b9c8829691e7814743d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02ed62dd463d55d9d9810b9c8829691e7814743d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=02ed62dd463d55d9d9810b9c8829691e7814743d", "patch": "@@ -1,3 +1,48 @@\n+2005-10-16  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/22137\n+\t* cp-tree.h (QUALIFIED_NAME_IS_TEMPLATE): New macro.\n+\t(check_template_keyword): New function.\n+\t(finish_id_expression): Change prototoype.\n+\t(finish_qualified_id_expr): Change prototype.\n+\t(build_qualified_name): New function.\n+\t(finish_class_member_access_expr): Change prototype.\n+\t* init.c (build_offset_ref): Use build_qualified_name.\n+\t* mangle.c (write_expression): Likewise.\n+\t* parser.c (cp_parser_primary_expression): Remove qualifying_class\n+\tparameter.  Add address_p and template_arg_p.  Use\n+\tbuild_qualified_name.\n+\t(cp_parser_id_expression): Default *template_p to\n+\ttemplate_keyword_p.  Check for invalid uses of the template\n+\tkeyword.  \n+\t(cp_parser_postfix_expression): Eliminate special handling for\n+\tqualified names.  Adjust call to cp_parser_primary_expression.\n+\t(cp_parser_postfix_dot_deref_expression): Adjust call to\n+\tcp_parser_id_expression and finish_class_member_access_expr.\n+\t(cp_parser_template_argument_list): Add comment.\n+\t(cp_parser_template_argument): Adjust use of\n+\tcp_parser_primary_expression.  Remove call to\n+\tfinish_qualified_id_expr.\n+\t(cp_parser_lookup_name): Use build_qualified_name. \n+\t* pt.c (tsubst): Use build_qualified_name.\n+\t(tsubst_qualified_id): Likewise.  Adjust call to\n+\tfinish_qualified_id_expr.\n+\t(tsubst_copy): Use build_qualified_name.\n+\t(tsubst_copy_and_build): Adjusts call to finish_id_expression and\n+\tfinish_class_member_access_expr. \n+\t* semantics.c (finish_non_static_data_member): Use\n+\tbuild_qualified_name.\n+\t(finish_qualified_id_expr): Add template_p and template_arg_p\n+\tparameters. \n+\t(finish_id_expression): Remove qualifiying_class parameter.  Add\n+\ttemplate_p, done, address_p, and template_arg_p.  Use\n+\tbuild_qualified_name.  Adjust calls to\n+\tfinish_class_member_acess_expr.  \n+\t* tree.c (build_qualified_name): New function.\n+\t* typeck.c (check_template_keyword): New function.\n+\t(finish_class_member_access_expr): Add template_p argument.  Check\n+\tfor invalid uses of the template keyword.\n+\t\n 2005-10-15  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/21347"}, {"sha": "9a2becc3c94172ad678ced013220db6f9208120a", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02ed62dd463d55d9d9810b9c8829691e7814743d/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02ed62dd463d55d9d9810b9c8829691e7814743d/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=02ed62dd463d55d9d9810b9c8829691e7814743d", "patch": "@@ -51,6 +51,7 @@ struct diagnostic_context;\n       BIND_EXPR_TRY_BLOCK (in BIND_EXPR)\n       TYPENAME_IS_ENUM_P (in TYPENAME_TYPE)\n       REFERENCE_REF_P (in INDIRECT_EXPR)\n+      QUALIFIED_NAME_IS_TEMPLATE (in SCOPE_REF)\n    1: IDENTIFIER_VIRTUAL_P (in IDENTIFIER_NODE)\n       TI_PENDING_TEMPLATE_FLAG.\n       TEMPLATE_PARMS_FOR_INLINE.\n@@ -2933,6 +2934,11 @@ extern void decl_shadowed_for_var_insert (tree, tree);\n #define THUNK_TARGET(NODE)\t\t\t\t\\\n   (DECL_LANG_SPECIFIC (NODE)->u.f.befriending_classes)\n \n+/* True for a SCOPE_REF iff the \"template\" keyword was used to\n+   indicate that the qualified name denotes a template.  */\n+#define QUALIFIED_NAME_IS_TEMPLATE(NODE) \\\n+  (TREE_LANG_FLAG_0 (SCOPE_REF_CHECK (NODE)))\n+\n /* These macros provide convenient access to the various _STMT nodes\n    created when parsing template declarations.  */\n #define TRY_STMTS(NODE)\t\tTREE_OPERAND (TRY_BLOCK_CHECK (NODE), 0)\n@@ -4200,9 +4206,11 @@ extern tree finish_template_type\t\t(tree, tree, int);\n extern tree finish_base_specifier\t\t(tree, tree, bool);\n extern void finish_member_declaration\t\t(tree);\n extern void qualified_name_lookup_error\t\t(tree, tree, tree);\n+extern void check_template_keyword              (tree);\n extern tree finish_id_expression\t\t(tree, tree, tree,\n-\t\t\t\t\t\t cp_id_kind *, tree *,\n+\t\t\t\t\t\t cp_id_kind *,\n \t\t\t\t\t\t bool, bool, bool *,\n+\t\t\t\t\t\t bool, bool, bool, bool,\n \t\t\t\t\t\t const char **);\n extern tree finish_typeof\t\t\t(tree);\n extern void finish_decl_cleanup\t\t\t(tree, tree);\n@@ -4212,7 +4220,8 @@ extern void finish_mem_initializers\t\t(tree);\n extern tree check_template_template_default_arg (tree);\n extern void expand_or_defer_fn\t\t\t(tree);\n extern void check_accessibility_of_qualified_id (tree, tree, tree);\n-extern tree finish_qualified_id_expr\t\t(tree, tree, bool, bool);\n+extern tree finish_qualified_id_expr\t\t(tree, tree, bool, bool,\n+\t\t\t\t\t\t bool, bool);\n extern void simplify_aggr_init_expr\t\t(tree *);\n extern void finalize_nrv\t\t\t(tree *, tree, tree);\n extern void note_decl_for_pch\t\t\t(tree);\n@@ -4242,6 +4251,7 @@ extern tree get_target_expr\t\t\t(tree);\n extern tree build_cplus_array_type\t\t(tree, tree);\n extern tree hash_tree_cons\t\t\t(tree, tree, tree);\n extern tree hash_tree_chain\t\t\t(tree, tree);\n+extern tree build_qualified_name                (tree, tree, tree, bool);\n extern int is_overloaded_fn\t\t\t(tree);\n extern tree get_first_fn\t\t\t(tree);\n extern tree ovl_cons\t\t\t\t(tree, tree);\n@@ -4305,7 +4315,7 @@ extern tree inline_conversion\t\t\t(tree);\n extern tree decay_conversion\t\t\t(tree);\n extern tree default_conversion\t\t\t(tree);\n extern tree build_class_member_access_expr      (tree, tree, tree, bool);\n-extern tree finish_class_member_access_expr     (tree, tree);\n+extern tree finish_class_member_access_expr     (tree, tree, bool);\n extern tree build_x_indirect_ref\t\t(tree, const char *);\n extern tree build_indirect_ref\t\t\t(tree, const char *);\n extern tree build_array_ref\t\t\t(tree, tree);"}, {"sha": "809b74fa98ad72db37a190a18786b37b9d24678e", "filename": "gcc/cp/init.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02ed62dd463d55d9d9810b9c8829691e7814743d/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02ed62dd463d55d9d9810b9c8829691e7814743d/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=02ed62dd463d55d9d9810b9c8829691e7814743d", "patch": "@@ -1344,7 +1344,8 @@ build_offset_ref (tree type, tree name, bool address_p)\n     return name;\n \n   if (dependent_type_p (type) || type_dependent_expression_p (name))\n-    return build_min_nt (SCOPE_REF, type, name);\n+    return build_qualified_name (NULL_TREE, type, name, \n+\t\t\t\t /*template_p=*/false);\n \n   if (TREE_CODE (name) == TEMPLATE_ID_EXPR)\n     {"}, {"sha": "b07012252bbafc3a23fd48167cdc08ba14956fea", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02ed62dd463d55d9d9810b9c8829691e7814743d/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02ed62dd463d55d9d9810b9c8829691e7814743d/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=02ed62dd463d55d9d9810b9c8829691e7814743d", "patch": "@@ -2008,9 +2008,10 @@ write_expression (tree expr)\n   if (code == PTRMEM_CST)\n     {\n       expr = build_nt (ADDR_EXPR,\n-\t\t       build_nt (SCOPE_REF,\n-\t\t\t\t PTRMEM_CST_CLASS (expr),\n-\t\t\t\t PTRMEM_CST_MEMBER (expr)));\n+\t\t       build_qualified_name (/*type=*/NULL_TREE,\n+\t\t\t\t\t     PTRMEM_CST_CLASS (expr),\n+\t\t\t\t\t     PTRMEM_CST_MEMBER (expr),\n+\t\t\t\t\t     /*template_p=*/false));\n       code = TREE_CODE (expr);\n     }\n \n@@ -2186,7 +2187,7 @@ write_expression (tree expr)\n \t  for (i = 0; i < TREE_CODE_LENGTH (code); ++i)\n \t    {\n \t      tree operand = TREE_OPERAND (expr, i);\n-\t      /* As a GNU expression, the middle operand of a\n+\t      /* As a GNU extension, the middle operand of a\n \t\t conditional may be omitted.  Since expression\n \t\t manglings are supposed to represent the input token\n \t\t stream, there's no good way to mangle such an"}, {"sha": "7f279437196f657c56f39d0ab34ab5ec8c085cb4", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 92, "deletions": 100, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02ed62dd463d55d9d9810b9c8829691e7814743d/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02ed62dd463d55d9d9810b9c8829691e7814743d/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=02ed62dd463d55d9d9810b9c8829691e7814743d", "patch": "@@ -1381,7 +1381,7 @@ static bool cp_parser_translation_unit\n /* Expressions [gram.expr]  */\n \n static tree cp_parser_primary_expression\n-  (cp_parser *, bool, cp_id_kind *, tree *);\n+  (cp_parser *, bool, bool, bool, cp_id_kind *);\n static tree cp_parser_id_expression\n   (cp_parser *, bool, bool, bool *, bool);\n static tree cp_parser_unqualified_id\n@@ -2716,29 +2716,25 @@ cp_parser_translation_unit (cp_parser* parser)\n    literal:\n      __null\n \n-   CAST_P is true if this primary expression is the target of a cast.\n+   ADDRESS_P is true iff this expression was immediately preceded by\n+   \"&\" and therefore might denote a pointer-to-member.  CAST_P is true\n+   iff this expression is the target of a cast.  TEMPLATE_ARG_P is\n+   true iff this expression is a tempalte argument.\n \n-   Returns a representation of the expression.\n-\n-   *IDK indicates what kind of id-expression (if any) was present.\n-\n-   *QUALIFYING_CLASS is set to a non-NULL value if the id-expression can be\n-   used as the operand of a pointer-to-member.  In that case,\n-   *QUALIFYING_CLASS gives the class that is used as the qualifying\n-   class in the pointer-to-member.  */\n+   Returns a representation of the expression.  Upon return, *IDK\n+   indicates what kind of id-expression (if any) was present.  */\n \n static tree\n cp_parser_primary_expression (cp_parser *parser,\n+\t\t\t      bool address_p,\n \t\t\t      bool cast_p,\n-\t\t\t      cp_id_kind *idk,\n-\t\t\t      tree *qualifying_class)\n+\t\t\t      bool template_arg_p,\n+\t\t\t      cp_id_kind *idk)\n {\n   cp_token *token;\n \n   /* Assume the primary expression is not an id-expression.  */\n   *idk = CP_ID_KIND_NONE;\n-  /* And that it cannot be used as pointer-to-member.  */\n-  *qualifying_class = NULL_TREE;\n \n   /* Peek at the next token.  */\n   token = cp_lexer_peek_token (parser->lexer);\n@@ -2964,22 +2960,31 @@ cp_parser_primary_expression (cp_parser *parser,\n \ttree id_expression;\n \ttree decl;\n \tconst char *error_msg;\n+\tbool template_p;\n+\tbool done;\n \n       id_expression:\n \t/* Parse the id-expression.  */\n \tid_expression\n \t  = cp_parser_id_expression (parser,\n \t\t\t\t     /*template_keyword_p=*/false,\n \t\t\t\t     /*check_dependency_p=*/true,\n-\t\t\t\t     /*template_p=*/NULL,\n+\t\t\t\t     &template_p,\n \t\t\t\t     /*declarator_p=*/false);\n \tif (id_expression == error_mark_node)\n \t  return error_mark_node;\n+\ttoken = cp_lexer_peek_token (parser->lexer);\n+\tdone = (token->type != CPP_OPEN_SQUARE\n+\t\t&& token->type != CPP_OPEN_PAREN\n+\t\t&& token->type != CPP_DOT\n+\t\t&& token->type != CPP_DEREF\n+\t\t&& token->type != CPP_PLUS_PLUS\n+\t\t&& token->type != CPP_MINUS_MINUS);\n \t/* If we have a template-id, then no further lookup is\n \t   required.  If the template-id was for a template-class, we\n \t   will sometimes have a TYPE_DECL at this point.  */\n-\telse if (TREE_CODE (id_expression) == TEMPLATE_ID_EXPR\n-\t    || TREE_CODE (id_expression) == TYPE_DECL)\n+\tif (TREE_CODE (id_expression) == TEMPLATE_ID_EXPR\n+\t\t || TREE_CODE (id_expression) == TYPE_DECL)\n \t  decl = id_expression;\n \t/* Look up the name.  */\n \telse\n@@ -2988,7 +2993,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \n \t    decl = cp_parser_lookup_name (parser, id_expression,\n \t\t\t\t\t  none_type,\n-\t\t\t\t\t  /*is_template=*/false,\n+\t\t\t\t\t  template_p,\n \t\t\t\t\t  /*is_namespace=*/false,\n \t\t\t\t\t  /*check_dependency=*/true,\n \t\t\t\t\t  &ambiguous_p);\n@@ -3002,14 +3007,9 @@ cp_parser_primary_expression (cp_parser *parser,\n \t    decl = objc_lookup_ivar (decl, id_expression);\n \n \t    /* If name lookup gives us a SCOPE_REF, then the\n-\t       qualifying scope was dependent.  Just propagate the\n-\t       name.  */\n+\t       qualifying scope was dependent.  */\n \t    if (TREE_CODE (decl) == SCOPE_REF)\n-\t      {\n-\t\tif (TYPE_P (TREE_OPERAND (decl, 0)))\n-\t\t  *qualifying_class = TREE_OPERAND (decl, 0);\n-\t\treturn decl;\n-\t      }\n+\t      return decl;\n \t    /* Check to see if DECL is a local variable in a context\n \t       where that is forbidden.  */\n \t    if (parser->local_variables_forbidden_p\n@@ -3038,12 +3038,15 @@ cp_parser_primary_expression (cp_parser *parser,\n \t      }\n \t  }\n \n-\tdecl = finish_id_expression (id_expression, decl, parser->scope,\n-\t\t\t\t     idk, qualifying_class,\n-\t\t\t\t     parser->integral_constant_expression_p,\n-\t\t\t\t     parser->allow_non_integral_constant_expression_p,\n-\t\t\t\t     &parser->non_integral_constant_expression_p,\n-\t\t\t\t     &error_msg);\n+\tdecl = (finish_id_expression \n+\t\t(id_expression, decl, parser->scope,\n+\t\t idk,\n+\t\t parser->integral_constant_expression_p,\n+\t\t parser->allow_non_integral_constant_expression_p,\n+\t\t &parser->non_integral_constant_expression_p,\n+\t\t template_p, done, address_p,\n+\t\t template_arg_p,\n+\t\t &error_msg));\n \tif (error_msg)\n \t  cp_parser_error (parser, error_msg);\n \treturn decl;\n@@ -3107,7 +3110,7 @@ cp_parser_id_expression (cp_parser *parser,\n \n   /* Assume the `template' keyword was not used.  */\n   if (template_p)\n-    *template_p = false;\n+    *template_p = template_keyword_p;\n \n   /* Look for the optional `::' operator.  */\n   global_scope_p\n@@ -3627,23 +3630,36 @@ cp_parser_nested_name_specifier_opt (cp_parser *parser,\n \t    }\n \t  break;\n \t}\n-\n       /* We've found one valid nested-name-specifier.  */\n       success = true;\n-      /* Make sure we look in the right scope the next time through\n-\t the loop.  */\n-      parser->scope = (TREE_CODE (new_scope) == TYPE_DECL\n-\t\t       ? TREE_TYPE (new_scope)\n-\t\t       : new_scope);\n+      /* Name lookup always gives us a DECL.  */\n+      if (TREE_CODE (new_scope) == TYPE_DECL)\n+\tnew_scope = TREE_TYPE (new_scope);\n+      /* Uses of \"template\" must be followed by actual templates.  */\n+      if (template_keyword_p\n+\t  && !(CLASS_TYPE_P (new_scope)\n+\t       && ((CLASSTYPE_USE_TEMPLATE (new_scope)\n+\t\t    && PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (new_scope)))\n+\t\t   || CLASSTYPE_IS_TEMPLATE (new_scope)))\n+\t  && !(TREE_CODE (new_scope) == TYPENAME_TYPE\n+\t       && (TREE_CODE (TYPENAME_TYPE_FULLNAME (new_scope))\n+\t\t   == TEMPLATE_ID_EXPR)))\n+\tpedwarn (TYPE_P (new_scope)\n+\t\t ? \"%qT is not a template\"\n+\t\t : \"%qD is not a template\",\n+\t\t new_scope);\n       /* If it is a class scope, try to complete it; we are about to\n \t be looking up names inside the class.  */\n-      if (TYPE_P (parser->scope)\n+      if (TYPE_P (new_scope)\n \t  /* Since checking types for dependency can be expensive,\n \t     avoid doing it if the type is already complete.  */\n-\t  && !COMPLETE_TYPE_P (parser->scope)\n+\t  && !COMPLETE_TYPE_P (new_scope)\n \t  /* Do not try to complete dependent types.  */\n-\t  && !dependent_type_p (parser->scope))\n-\tcomplete_type (parser->scope);\n+\t  && !dependent_type_p (new_scope))\n+\tnew_scope = complete_type (new_scope);\n+      /* Make sure we look in the right scope the next time through\n+\t the loop.  */\n+      parser->scope = new_scope;\n     }\n \n   /* Retrieve any deferred checks.  Do not pop this access checks yet\n@@ -3818,10 +3834,6 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p)\n   enum rid keyword;\n   cp_id_kind idk = CP_ID_KIND_NONE;\n   tree postfix_expression = NULL_TREE;\n-  /* Non-NULL only if the current postfix-expression can be used to\n-     form a pointer-to-member.  In that case, QUALIFYING_CLASS is the\n-     class used to qualify the member.  */\n-  tree qualifying_class = NULL_TREE;\n \n   /* Peek at the next token.  */\n   token = cp_lexer_peek_token (parser->lexer);\n@@ -4073,38 +4085,14 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p)\n \t  }\n \n \t/* It must be a primary-expression.  */\n-\tpostfix_expression = cp_parser_primary_expression (parser,\n-\t\t\t\t\t\t\t   cast_p,\n-\t\t\t\t\t\t\t   &idk,\n-\t\t\t\t\t\t\t   &qualifying_class);\n+\tpostfix_expression \n+\t  = cp_parser_primary_expression (parser, address_p, cast_p, \n+\t\t\t\t\t  /*template_arg_p=*/false,\n+\t\t\t\t\t  &idk);\n       }\n       break;\n     }\n \n-  /* If we were avoiding committing to the processing of a\n-     qualified-id until we knew whether or not we had a\n-     pointer-to-member, we now know.  */\n-  if (qualifying_class)\n-    {\n-      bool done;\n-\n-      /* Peek at the next token.  */\n-      token = cp_lexer_peek_token (parser->lexer);\n-      done = (token->type != CPP_OPEN_SQUARE\n-\t      && token->type != CPP_OPEN_PAREN\n-\t      && token->type != CPP_DOT\n-\t      && token->type != CPP_DEREF\n-\t      && token->type != CPP_PLUS_PLUS\n-\t      && token->type != CPP_MINUS_MINUS);\n-\n-      postfix_expression = finish_qualified_id_expr (qualifying_class,\n-\t\t\t\t\t\t     postfix_expression,\n-\t\t\t\t\t\t     done,\n-\t\t\t\t\t\t     address_p);\n-      if (done)\n-\treturn postfix_expression;\n-    }\n-\n   /* Keep looping until the postfix-expression is complete.  */\n   while (true)\n     {\n@@ -4392,7 +4380,6 @@ cp_parser_postfix_dot_deref_expression (cp_parser *parser,\n {\n   tree name;\n   bool dependent_p;\n-  bool template_p;\n   bool pseudo_destructor_p;\n   tree scope = NULL_TREE;\n \n@@ -4463,12 +4450,14 @@ cp_parser_postfix_dot_deref_expression (cp_parser *parser,\n       /* If the SCOPE is not a scalar type, we are looking at an\n \t ordinary class member access expression, rather than a\n \t pseudo-destructor-name.  */\n-      template_p = cp_parser_optional_template_keyword (parser);\n+      bool template_p;\n       /* Parse the id-expression.  */\n-      name = cp_parser_id_expression (parser, template_p,\n-\t\t\t\t      /*check_dependency_p=*/true,\n-\t\t\t\t      /*template_p=*/NULL,\n-\t\t\t\t      /*declarator_p=*/false);\n+      name = (cp_parser_id_expression \n+\t      (parser, \n+\t       cp_parser_optional_template_keyword (parser),\n+\t       /*check_dependency_p=*/true,\n+\t       &template_p,\n+\t       /*declarator_p=*/false));\n       /* In general, build a SCOPE_REF if the member name is qualified.\n \t However, if the name was not dependent and has already been\n \t resolved; there is no need to build the SCOPE_REF.  For example;\n@@ -4495,7 +4484,10 @@ cp_parser_postfix_dot_deref_expression (cp_parser *parser,\n \t{\n \t  if (name != error_mark_node && !BASELINK_P (name) && parser->scope)\n \t    {\n-\t      name = build_nt (SCOPE_REF, parser->scope, name);\n+\t      name = build_qualified_name (/*type=*/NULL_TREE,\n+\t\t\t\t\t   parser->scope,\n+\t\t\t\t\t   name,\n+\t\t\t\t\t   template_p);\n \t      parser->scope = NULL_TREE;\n \t      parser->qualifying_scope = NULL_TREE;\n \t      parser->object_scope = NULL_TREE;\n@@ -4504,7 +4496,8 @@ cp_parser_postfix_dot_deref_expression (cp_parser *parser,\n \t    adjust_result_of_qualified_name_lookup\n \t      (name, BINFO_TYPE (BASELINK_BINFO (name)), scope);\n \t  postfix_expression\n-\t    = finish_class_member_access_expr (postfix_expression, name);\n+\t    = finish_class_member_access_expr (postfix_expression, name,\n+\t\t\t\t\t       template_p);\n \t}\n     }\n \n@@ -8917,6 +8910,7 @@ cp_parser_template_argument_list (cp_parser* parser)\n   parser->integral_constant_expression_p = false;\n   saved_non_ice_p = parser->non_integral_constant_expression_p;\n   parser->non_integral_constant_expression_p = false;\n+  /* Parse the arguments.  */\n   do\n     {\n       tree argument;\n@@ -8981,7 +8975,6 @@ cp_parser_template_argument (cp_parser* parser)\n   bool maybe_type_id = false;\n   cp_token *token;\n   cp_id_kind idk;\n-  tree qualifying_class;\n \n   /* There's really no way to know what we're looking at, so we just\n      try each alternative in order.\n@@ -9073,9 +9066,10 @@ cp_parser_template_argument (cp_parser* parser)\n     {\n       cp_parser_parse_tentatively (parser);\n       argument = cp_parser_primary_expression (parser,\n+\t\t\t\t\t       /*adress_p=*/false,\n \t\t\t\t\t       /*cast_p=*/false,\n-\t\t\t\t\t       &idk,\n-\t\t\t\t\t       &qualifying_class);\n+\t\t\t\t\t       /*template_arg_p=*/true,\n+\t\t\t\t\t       &idk);\n       if (TREE_CODE (argument) != TEMPLATE_PARM_INDEX\n \t  || !cp_parser_next_token_ends_template_argument_p (parser))\n \tcp_parser_simulate_error (parser);\n@@ -9098,9 +9092,10 @@ cp_parser_template_argument (cp_parser* parser)\n     {\n       cp_parser_parse_tentatively (parser);\n       argument = cp_parser_primary_expression (parser,\n+\t\t\t\t\t       address_p,\n \t\t\t\t\t       /*cast_p=*/false,\n-\t\t\t\t\t       &idk,\n-\t\t\t\t\t       &qualifying_class);\n+\t\t\t\t\t       /*template_arg_p=*/true,\n+\t\t\t\t\t       &idk);\n       if (cp_parser_error_occurred (parser)\n \t  || !cp_parser_next_token_ends_template_argument_p (parser))\n \tcp_parser_abort_tentative_parse (parser);\n@@ -9112,16 +9107,7 @@ cp_parser_template_argument (cp_parser* parser)\n \t      argument = TREE_OPERAND (argument, 0);\n \t    }\n \n-\t  /* If ADDRESS_P, then we use finish_qualified_id_expr so\n-\t     that we get a pointer-to-member, if appropriate.\n-\t     However, if ADDRESS_P is false, we don't want to turn\n-\t     \"T::f\" into \"(*this).T::f\".  */\n-\t  if (qualifying_class && address_p)\n-\t    argument = finish_qualified_id_expr (qualifying_class,\n-\t\t\t\t\t\t argument,\n-\t\t\t\t\t\t /*done=*/true,\n-\t\t\t\t\t\t /*address_p=*/true);\n-\t  else if (TREE_CODE (argument) == BASELINK)\n+\t  if (TREE_CODE (argument) == BASELINK)\n \t    /* We don't need the information about what class was used\n \t       to name the overloaded functions.  */  \n \t    argument = BASELINK_FUNCTIONS (argument);\n@@ -14480,7 +14466,8 @@ cp_parser_label_declaration (cp_parser* parser)\n static tree\n cp_parser_lookup_name (cp_parser *parser, tree name,\n \t\t       enum tag_types tag_type,\n-\t\t       bool is_template, bool is_namespace,\n+\t\t       bool is_template, \n+\t\t       bool is_namespace,\n \t\t       bool check_dependency,\n \t\t       bool *ambiguous_p)\n {\n@@ -14575,12 +14562,17 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n \t\t\t\t\t /*complain=*/1);\n \t      decl = TYPE_NAME (type);\n \t    }\n-\t  else if (is_template)\n+\t  else if (is_template\n+\t\t   && (cp_parser_next_token_ends_template_argument_p (parser)\n+\t\t       || cp_lexer_next_token_is (parser->lexer,\n+\t\t\t\t\t\t  CPP_CLOSE_PAREN)))\n \t    decl = make_unbound_class_template (parser->scope,\n \t\t\t\t\t\tname, NULL_TREE,\n \t\t\t\t\t\t/*complain=*/1);\n \t  else\n-\t    decl = build_nt (SCOPE_REF, parser->scope, name);\n+\t    decl = build_qualified_name (/*type=*/NULL_TREE,\n+\t\t\t\t\t parser->scope, name,\n+\t\t\t\t\t is_template);\n \t}\n       else\n \t{"}, {"sha": "1ef5669a82dbc08f7c028d5ba8b440eac17f0ada", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02ed62dd463d55d9d9810b9c8829691e7814743d/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02ed62dd463d55d9d9810b9c8829691e7814743d/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=02ed62dd463d55d9d9810b9c8829691e7814743d", "patch": "@@ -7544,7 +7544,8 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \tif (e1 == error_mark_node || e2 == error_mark_node)\n \t  return error_mark_node;\n \n-\treturn build_nt (TREE_CODE (t), e1, e2);\n+\treturn build_qualified_name (/*type=*/NULL_TREE,\n+\t\t\t\t     e1, e2, QUALIFIED_NAME_IS_TEMPLATE (t));\n       }\n \n     case TYPEOF_TYPE:\n@@ -7675,7 +7676,9 @@ tsubst_qualified_id (tree qualified_id, tree args,\n     expr = name;\n \n   if (dependent_type_p (scope))\n-    return build_nt (SCOPE_REF, scope, expr);\n+    return build_qualified_name (/*type=*/NULL_TREE, \n+\t\t\t\t scope, expr, \n+\t\t\t\t QUALIFIED_NAME_IS_TEMPLATE (qualified_id));\n \n   if (!BASELINK_P (name) && !DECL_P (expr))\n     {\n@@ -7725,7 +7728,10 @@ tsubst_qualified_id (tree qualified_id, tree args,\n     {\n       expr = (adjust_result_of_qualified_name_lookup\n \t      (expr, scope, current_class_type));\n-      expr = finish_qualified_id_expr (scope, expr, done, address_p);\n+      expr = (finish_qualified_id_expr \n+\t      (scope, expr, done, address_p,\n+\t       QUALIFIED_NAME_IS_TEMPLATE (qualified_id),\n+\t       /*template_arg_p=*/false));\n     }\n \n   if (TREE_CODE (expr) != SCOPE_REF)\n@@ -7912,7 +7918,9 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t    name = tsubst_copy (TREE_OPERAND (name, 0), args,\n \t\t\t\tcomplain, in_decl);\n \t    name = build1 (BIT_NOT_EXPR, NULL_TREE, name);\n-\t    name = build_nt (SCOPE_REF, base, name);\n+\t    name = build_qualified_name (/*type=*/NULL_TREE,\n+\t\t\t\t\t base, name, \n+\t\t\t\t\t /*template_p=*/false);\n \t  }\n \telse if (TREE_CODE (name) == BASELINK)\n \t  name = tsubst_baselink (name,\n@@ -7954,7 +7962,6 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n     case LT_EXPR:\n     case GT_EXPR:\n     case COMPOUND_EXPR:\n-    case SCOPE_REF:\n     case DOTSTAR_EXPR:\n     case MEMBER_REF:\n     case PREDECREMENT_EXPR:\n@@ -7965,6 +7972,14 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t(code, tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl),\n \t tsubst_copy (TREE_OPERAND (t, 1), args, complain, in_decl));\n \n+    case SCOPE_REF:\n+      return build_qualified_name (/*type=*/NULL_TREE,\n+\t\t\t\t   tsubst_copy (TREE_OPERAND (t, 0),\n+\t\t\t\t\t\targs, complain, in_decl),\n+\t\t\t\t   tsubst_copy (TREE_OPERAND (t, 1),\n+\t\t\t\t\t\targs, complain, in_decl),\n+\t\t\t\t   QUALIFIED_NAME_IS_TEMPLATE (t));\n+\n     case ARRAY_REF:\n       return build_nt\n \t(ARRAY_REF,\n@@ -8438,7 +8453,6 @@ tsubst_copy_and_build (tree t,\n       {\n \ttree decl;\n \tcp_id_kind idk;\n-\ttree qualifying_class;\n \tbool non_integral_constant_expression_p;\n \tconst char *error_msg;\n \n@@ -8458,10 +8472,13 @@ tsubst_copy_and_build (tree t,\n \n \tdecl = finish_id_expression (t, decl, NULL_TREE,\n \t\t\t\t     &idk,\n-\t\t\t\t     &qualifying_class,\n \t\t\t\t     /*integral_constant_expression_p=*/false,\n \t\t\t\t     /*allow_non_integral_constant_expression_p=*/false,\n \t\t\t\t     &non_integral_constant_expression_p,\n+\t\t\t\t     /*template_p=*/false,\n+\t\t\t\t     /*done=*/true,\n+\t\t\t\t     /*address_p=*/false,\n+\t\t\t\t     /*template_arg_p=*/false,\n \t\t\t\t     &error_msg);\n \tif (error_msg)\n \t  error (error_msg);\n@@ -8872,7 +8889,8 @@ tsubst_copy_and_build (tree t,\n \telse if (TREE_CODE (member) == FIELD_DECL)\n \t  return finish_non_static_data_member (member, object, NULL_TREE);\n \n-\treturn finish_class_member_access_expr (object, member);\n+\treturn finish_class_member_access_expr (object, member,\n+\t\t\t\t\t\t/*template_p=*/false);\n       }\n \n     case THROW_EXPR:"}, {"sha": "5ccc7c757096742a80a577a27fba0909fdd965c3", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 69, "deletions": 22, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02ed62dd463d55d9d9810b9c8829691e7814743d/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02ed62dd463d55d9d9810b9c8829691e7814743d/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=02ed62dd463d55d9d9810b9c8829691e7814743d", "patch": "@@ -1407,8 +1407,10 @@ finish_non_static_data_member (tree decl, tree object, tree qualifying_scope)\n \t QUALIFYING_SCOPE is also non-null.  Wrap this in a SCOPE_REF\n \t for now.  */\n       if (processing_template_decl)\n-\treturn build_min (SCOPE_REF, TREE_TYPE (decl),\n-\t\t\t  qualifying_scope, DECL_NAME (decl));\n+\treturn build_qualified_name (TREE_TYPE (decl),\n+\t\t\t\t     qualifying_scope,\n+\t\t\t\t     DECL_NAME (decl),\n+\t\t\t\t     /*template_p=*/false);\n \n       perform_or_defer_access_check (TYPE_BINFO (access_type), decl);\n \n@@ -1494,15 +1496,24 @@ check_accessibility_of_qualified_id (tree decl,\n    class named to the left of the \"::\" operator.  DONE is true if this\n    expression is a complete postfix-expression; it is false if this\n    expression is followed by '->', '[', '(', etc.  ADDRESS_P is true\n-   iff this expression is the operand of '&'.  */\n+   iff this expression is the operand of '&'.  TEMPLATE_P is true iff\n+   the qualified-id was of the form \"A::template B\".  TEMPLATE_ARG_P\n+   is true iff this qualified name appears as a template argument.  */\n \n tree\n-finish_qualified_id_expr (tree qualifying_class, tree expr, bool done,\n-\t\t\t  bool address_p)\n+finish_qualified_id_expr (tree qualifying_class, \n+\t\t\t  tree expr, \n+\t\t\t  bool done,\n+\t\t\t  bool address_p, \n+\t\t\t  bool template_p,\n+\t\t\t  bool template_arg_p)\n {\n   if (error_operand_p (expr))\n     return error_mark_node;\n \n+  if (template_p)\n+    check_template_keyword (expr);\n+\n   /* If EXPR occurs as the operand of '&', use special handling that\n      permits a pointer-to-member.  */\n   if (address_p && done)\n@@ -1514,7 +1525,13 @@ finish_qualified_id_expr (tree qualifying_class, tree expr, bool done,\n       return expr;\n     }\n \n-  if (TREE_CODE (expr) == FIELD_DECL)\n+  /* Within the scope of a class, turn references to non-static\n+     members into expression of the form \"this->...\".  */\n+  if (template_arg_p)\n+    /* But, within a template argument, we do not want make the\n+       transformation, as there is no \"this\" pointer.  */\n+    ;\n+  else if (TREE_CODE (expr) == FIELD_DECL)\n     expr = finish_non_static_data_member (expr, current_class_ref,\n \t\t\t\t\t  qualifying_class);\n   else if (BASELINK_P (expr) && !processing_template_decl)\n@@ -2383,6 +2400,13 @@ qualified_name_lookup_error (tree scope, tree name, tree decl)\n    constant-expression, but a non-constant expression is also\n    permissible.\n \n+   DONE is true if this expression is a complete postfix-expression;\n+   it is false if this expression is followed by '->', '[', '(', etc.\n+   ADDRESS_P is true iff this expression is the operand of '&'.\n+   TEMPLATE_P is true iff the qualified-id was of the form\n+   \"A::template B\".  TEMPLATE_ARG_P is true iff this qualified name\n+   appears as a template argument.\n+\n    If an error occurs, and it is the kind of error that might cause\n    the parser to abort a tentative parse, *ERROR_MSG is filled in.  It\n    is the caller's responsibility to issue the message.  *ERROR_MSG\n@@ -2401,10 +2425,13 @@ finish_id_expression (tree id_expression,\n \t\t      tree decl,\n \t\t      tree scope,\n \t\t      cp_id_kind *idk,\n-\t\t      tree *qualifying_class,\n \t\t      bool integral_constant_expression_p,\n \t\t      bool allow_non_integral_constant_expression_p,\n \t\t      bool *non_integral_constant_expression_p,\n+\t\t      bool template_p,\n+\t\t      bool done,\n+\t\t      bool address_p,\n+\t\t      bool template_arg_p,\n \t\t      const char **error_msg)\n {\n   /* Initialize the output parameters.  */\n@@ -2610,20 +2637,32 @@ finish_id_expression (tree id_expression,\n \t     dependent.  */\n \t  if (scope)\n \t    {\n-\t      if (TYPE_P (scope))\n-\t\t*qualifying_class = scope;\n \t      /* Since this name was dependent, the expression isn't\n \t\t constant -- yet.  No error is issued because it might\n \t\t be constant when things are instantiated.  */\n \t      if (integral_constant_expression_p)\n \t\t*non_integral_constant_expression_p = true;\n-\t      if (TYPE_P (scope) && dependent_type_p (scope))\n-\t\treturn build_nt (SCOPE_REF, scope, id_expression);\n-\t      else if (TYPE_P (scope) && DECL_P (decl))\n-\t\treturn convert_from_reference\n-\t\t  (build2 (SCOPE_REF, TREE_TYPE (decl), scope, id_expression));\n-\t      else\n-\t\treturn convert_from_reference (decl);\n+\t      if (TYPE_P (scope))\n+\t\t{\n+\t\t  if (address_p && done)\n+\t\t    decl = finish_qualified_id_expr (scope, decl,\n+\t\t\t\t\t\t     done, address_p,\n+\t\t\t\t\t\t     template_p,\n+\t\t\t\t\t\t     template_arg_p);\n+\t\t  else if (dependent_type_p (scope))\n+\t\t    decl = build_qualified_name (/*type=*/NULL_TREE,\n+\t\t\t\t\t\t scope,\n+\t\t\t\t\t\t id_expression,\n+\t\t\t\t\t\t template_p);\n+\t\t  else if (DECL_P (decl))\n+\t\t    decl = build_qualified_name (TREE_TYPE (decl),\n+\t\t\t\t\t\t scope,\n+\t\t\t\t\t\t id_expression,\n+\t\t\t\t\t\t template_p);\n+\t\t}\n+\t      if (TREE_TYPE (decl))\n+\t\tdecl = convert_from_reference (decl);\n+\t      return decl;\n \t    }\n \t  /* A TEMPLATE_ID already contains all the information we\n \t     need.  */\n@@ -2703,14 +2742,20 @@ finish_id_expression (tree id_expression,\n \t    mark_used (decl);\n \n \t  if (TREE_CODE (decl) == FIELD_DECL || BASELINK_P (decl))\n-\t    *qualifying_class = scope;\n+\t    decl = finish_qualified_id_expr (scope,\n+\t\t\t\t\t     decl,\n+\t\t\t\t\t     done,\n+\t\t\t\t\t     address_p,\n+\t\t\t\t\t     template_p,\n+\t\t\t\t\t     template_arg_p);\n \t  else\n \t    {\n \t      tree r = convert_from_reference (decl);\n \n-\t      if (processing_template_decl\n-\t\t  && TYPE_P (scope))\n-\t\tr = build2 (SCOPE_REF, TREE_TYPE (r), scope, decl);\n+\t      if (processing_template_decl && TYPE_P (scope))\n+\t\tr = build_qualified_name (TREE_TYPE (r),\n+\t\t\t\t\t  scope, decl,\n+\t\t\t\t\t  template_p);\n \t      decl = r;\n \t    }\n \t}\n@@ -2734,13 +2779,15 @@ finish_id_expression (tree id_expression,\n \t  if (!really_overloaded_fn (decl))\n \t    mark_used (first_fn);\n \n-\t  if (TREE_CODE (first_fn) == FUNCTION_DECL\n+\t  if (!template_arg_p\n+\t      && TREE_CODE (first_fn) == FUNCTION_DECL\n \t      && DECL_FUNCTION_MEMBER_P (first_fn)\n \t      && !shared_member_p (decl))\n \t    {\n \t      /* A set of member functions.  */\n \t      decl = maybe_dummy_object (DECL_CONTEXT (first_fn), 0);\n-\t      return finish_class_member_access_expr (decl, id_expression);\n+\t      return finish_class_member_access_expr (decl, id_expression,\n+\t\t\t\t\t\t      /*template_p=*/false);\n \t    }\n \t}\n       else"}, {"sha": "15ee56c7c870da81be2e95de7d0b4bd44c6eb30a", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02ed62dd463d55d9d9810b9c8829691e7814743d/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02ed62dd463d55d9d9810b9c8829691e7814743d/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=02ed62dd463d55d9d9810b9c8829691e7814743d", "patch": "@@ -805,6 +805,23 @@ debug_binfo (tree elem)\n     }\n }\n \n+/* Build a representation for the qualified name SCOPE::NAME.  TYPE is\n+   the type of the result expression, if known, or NULL_TREE if the\n+   resulting expression is type-dependent.  If TEMPLATE_P is true,\n+   NAME is known to be a template because the user explicitly used the\n+   \"template\" keyword after the \"::\".   \n+\n+   All SCOPE_REFs should be built by use of this function.  */\n+\n+tree\n+build_qualified_name (tree type, tree scope, tree name, bool template_p)\n+{\n+  tree t;\n+  t = build2 (SCOPE_REF, type, scope, name);\n+  QUALIFIED_NAME_IS_TEMPLATE (t) = template_p;\n+  return t;\n+}\n+\n int\n is_overloaded_fn (tree x)\n {"}, {"sha": "bc34a40380688146fb6730af72961eaeda890c8f", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 58, "deletions": 2, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02ed62dd463d55d9d9810b9c8829691e7814743d/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02ed62dd463d55d9d9810b9c8829691e7814743d/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=02ed62dd463d55d9d9810b9c8829691e7814743d", "patch": "@@ -1841,16 +1841,69 @@ lookup_destructor (tree object, tree scope, tree dtor_name)\n   return expr;\n }\n \n+/* An expression of the form \"A::template B\" has been resolved to\n+   DECL.  Issue a diagnostic if B is not a template or template\n+   specialization.  */\n+\n+void\n+check_template_keyword (tree decl)\n+{\n+  /* The standard says:\n+\n+      [temp.names]\n+\n+      If a name prefixed by the keyword template is not a member\n+      template, the program is ill-formed.\n+\n+     DR 228 removed the restriction that the template be a member\n+     template.  \n+     \n+     DR 96, if accepted would add the further restriction that explcit\n+     template arguments must be provided if the template keyword is\n+     used, but, as of 2005-10-16, that DR is still in \"drafting\".  If\n+     this DR is accepted, then the semantic checks here can be\n+     simplified, as the entity named must in fact be a template\n+     specialization, rather than, as at present, a set of overloaded\n+     functions containing at least one template function.  */\n+  if (TREE_CODE (decl) != TEMPLATE_DECL\n+      && TREE_CODE (decl) != TEMPLATE_ID_EXPR)\n+    {\n+      if (!is_overloaded_fn (decl))\n+\tpedwarn (\"%qD is not a template\", decl);\n+      else\n+\t{\n+\t  tree fns;\n+\t  if (BASELINK_P (decl))\n+\t    fns = BASELINK_FUNCTIONS (decl);\n+\t  while (fns)\n+\t    {\n+\t      tree fn = OVL_CURRENT (fns);\n+\t      if (TREE_CODE (fn) == TEMPLATE_DECL\n+\t\t  || TREE_CODE (fn) == TEMPLATE_ID_EXPR)\n+\t\tbreak;\n+\t      if (TREE_CODE (fn) == FUNCTION_DECL\n+\t\t  && DECL_USE_TEMPLATE (fn)\n+\t\t  && PRIMARY_TEMPLATE_P (DECL_TI_TEMPLATE (fn)))\n+\t\tbreak;\n+\t      fns = OVL_NEXT (fns);\n+\t    }\n+\t  if (!fns)\n+\t    pedwarn (\"%qD is not a template\", decl);\n+\t}\n+    }\n+}\n+\n /* This function is called by the parser to process a class member\n    access expression of the form OBJECT.NAME.  NAME is a node used by\n    the parser to represent a name; it is not yet a DECL.  It may,\n    however, be a BASELINK where the BASELINK_FUNCTIONS is a\n    TEMPLATE_ID_EXPR.  Templates must be looked up by the parser, and\n    there is no reason to do the lookup twice, so the parser keeps the\n-   BASELINK.  */\n+   BASELINK.  TEMPLATE_P is true iff NAME was explicitly declared to\n+   be a template via the use of the \"A::template B\" syntax.  */\n \n tree\n-finish_class_member_access_expr (tree object, tree name)\n+finish_class_member_access_expr (tree object, tree name, bool template_p)\n {\n   tree expr;\n   tree object_type;\n@@ -1995,6 +2048,9 @@ finish_class_member_access_expr (tree object, tree name)\n   if (TREE_DEPRECATED (member))\n     warn_deprecated_use (member);\n \n+  if (template_p)\n+    check_template_keyword (member);\n+\n   expr = build_class_member_access_expr (object, member, access_path,\n \t\t\t\t\t /*preserve_reference=*/false);\n   if (processing_template_decl && expr != error_mark_node)"}, {"sha": "bcfad3f8b99517924d251093b59617ef9f69bb01", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02ed62dd463d55d9d9810b9c8829691e7814743d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02ed62dd463d55d9d9810b9c8829691e7814743d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=02ed62dd463d55d9d9810b9c8829691e7814743d", "patch": "@@ -1,3 +1,9 @@\n+2005-10-16  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/22137\n+\t* g++.dg/parse/template18.C: New test.\n+\t* g++.dg/template/nontype15.C: Likewise.\n+\n 2005-10-16  Erik Edelmann  <erik.edelmann@iki.fi>\n \n \tPR fortran/22273"}, {"sha": "82336abd2ad25fe81181ccc400b45ddcac7f8c85", "filename": "gcc/testsuite/g++.dg/parse/template18.C", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02ed62dd463d55d9d9810b9c8829691e7814743d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftemplate18.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02ed62dd463d55d9d9810b9c8829691e7814743d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftemplate18.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftemplate18.C?ref=02ed62dd463d55d9d9810b9c8829691e7814743d", "patch": "@@ -0,0 +1,52 @@\n+// PR c++/22137\n+\n+struct A\n+{\n+  static void a1();\n+  template <typename T>\n+  static void b1(T);\n+  template <int I>\n+  struct B {\n+    static void b1();\n+    template <typename T>\n+    static void b2(T);\n+  };\n+  struct C {\n+    static void c1();\n+  };\n+};\n+\n+template<int I> void f1()\n+{\n+  A* p;\n+  A::template a1(); // { dg-error \"template\" }\n+  A::template b1(0);\n+  p->template a1(); // { dg-error \"template\" }\n+  p->template b1('a');\n+\n+  A::template B<0>::b1();\n+  A::template B<0>::template b1(); // { dg-error \"template\" }\n+  A::template B<0>::template b2(0);\n+  A::template B<0>::template b2<double>(0);\n+\n+  // Because B<I> is dependent, none of these are errors, as this\n+  // function is not instantiated. \n+  A::template B<I>::b1();\n+  A::template B<I>::template b1();\n+  A::template B<I>::template b2(0);\n+  A::template B<I>::template b2<double>(0);\n+\n+  A::template C::c1(); // { dg-error \"template\" }\n+}\n+\n+template<int I> void f2()\n+{\n+  // These are copies of lines from f1, but this function is\n+  // instantiated, so we should get errors here.\n+  A::template B<I>::b1();\n+  A::template B<I>::template b1(); // { dg-error \"template\" }\n+  A::template B<I>::template b2(0);\n+  A::template B<I>::template b2<double>(0);\n+}\n+\n+template void f2<0>(); // { dg-error \"instantiated\" }"}, {"sha": "dd5f4e78a5f066f6bd893f3083e844f9f708aabb", "filename": "gcc/testsuite/g++.dg/template/nontype15.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02ed62dd463d55d9d9810b9c8829691e7814743d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02ed62dd463d55d9d9810b9c8829691e7814743d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype15.C?ref=02ed62dd463d55d9d9810b9c8829691e7814743d", "patch": "@@ -0,0 +1,20 @@\n+struct foo {\n+    typedef int (*fun)(int);\n+\n+  static int f(int);    // overload between static & non-static\n+  int f();\n+\n+  static int g(int);    // non-overloaded static\n+};\n+\n+template<foo::fun>\n+struct f_obj {\n+  // something ..\n+};\n+\n+int foo::f() {\n+  f_obj<f> f1;\n+  f_obj<g> f2;\n+\n+  return 0; \n+}"}]}