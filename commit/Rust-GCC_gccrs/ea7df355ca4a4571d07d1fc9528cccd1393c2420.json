{"sha": "ea7df355ca4a4571d07d1fc9528cccd1393c2420", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWE3ZGYzNTVjYTRhNDU3MWQwN2QxZmM5NTI4Y2NjZDEzOTNjMjQyMA==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2020-11-02T22:04:23Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2020-11-03T15:17:39Z"}, "message": "More Ranger cache tweaks\n\nThis patch splits the individual value propagation out from fill_block_cache,\nand calls it from set_global_value when the global value is updated.\nThis ensures the \"current\" global value is reflected in the on-entry cache.\n\n\t* gimple-range-cache.cc (ssa_global_cache::get_global_range): Return\n\ttrue if there was a previous range set.\n\t(ranger_cache::ranger_cache): Take a gimple_ranger parameter.\n\t(ranger_cache::set_global_range): Propagate the value if updating.\n\t(ranger_cache::propagate_cache): Renamed from iterative_cache_update.\n\t(ranger_cache::propagate_updated_value): New.  Split from:\n\t(ranger_cache::fill_block_cache): Split out value propagator.\n\t* gimple-range-cache.h (ssa_global_cache): Update prototypes.\n\t(ranger_cache): Update prototypes.", "tree": {"sha": "a6898fdc3b74d003b823e48bf9718981a469738e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a6898fdc3b74d003b823e48bf9718981a469738e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea7df355ca4a4571d07d1fc9528cccd1393c2420", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea7df355ca4a4571d07d1fc9528cccd1393c2420", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea7df355ca4a4571d07d1fc9528cccd1393c2420", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea7df355ca4a4571d07d1fc9528cccd1393c2420/comments", "author": null, "committer": null, "parents": [{"sha": "220929c067717605cab96a9c5fe93e2e01532e51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/220929c067717605cab96a9c5fe93e2e01532e51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/220929c067717605cab96a9c5fe93e2e01532e51"}], "stats": {"total": 124, "additions": 79, "deletions": 45}, "files": [{"sha": "cca9025abbae2aa8c01e2204dc40e1e8f3630939", "filename": "gcc/gimple-range-cache.cc", "status": "modified", "additions": 73, "deletions": 41, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea7df355ca4a4571d07d1fc9528cccd1393c2420/gcc%2Fgimple-range-cache.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea7df355ca4a4571d07d1fc9528cccd1393c2420/gcc%2Fgimple-range-cache.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.cc?ref=ea7df355ca4a4571d07d1fc9528cccd1393c2420", "patch": "@@ -419,8 +419,9 @@ ssa_global_cache::get_global_range (irange &r, tree name) const\n }\n \n // Set the range for NAME to R in the global cache.\n+// Return TRUE if there was already a range set, otherwise false.\n \n-void\n+bool\n ssa_global_cache::set_global_range (tree name, const irange &r)\n {\n   unsigned v = SSA_NAME_VERSION (name);\n@@ -432,6 +433,7 @@ ssa_global_cache::set_global_range (tree name, const irange &r)\n     *m = r;\n   else\n     m_tab[v] = m_irange_allocator->allocate (r);\n+  return m != NULL;\n }\n \n // Set the range for NAME to R in the glonbal cache.\n@@ -476,7 +478,7 @@ ssa_global_cache::dump (FILE *f)\n \n // --------------------------------------------------------------------------\n \n-ranger_cache::ranger_cache (range_query &q) : query (q)\n+ranger_cache::ranger_cache (gimple_ranger &q) : query (q)\n {\n   m_workback.create (0);\n   m_workback.safe_grow_cleared (last_basic_block_for_fn (cfun));\n@@ -532,7 +534,18 @@ ranger_cache::get_global_range (irange &r, tree name) const\n void\n ranger_cache::set_global_range (tree name, const irange &r)\n {\n-  m_globals.set_global_range (name, r);\n+  if (m_globals.set_global_range (name, r))\n+    {\n+      // If there was already a range set, propagate the new value.\n+      basic_block bb = gimple_bb (SSA_NAME_DEF_STMT (name));\n+      if (!bb)\n+\tbb = ENTRY_BLOCK_PTR_FOR_FN (cfun);\n+\n+      if (DEBUG_RANGE_CACHE)\n+\tfprintf (dump_file, \"   GLOBAL :\");\n+\n+      propagate_updated_value (name, bb);\n+    }\n }\n \n // Push a request for a new lookup in block BB of name.  Return true if\n@@ -660,11 +673,11 @@ ranger_cache::add_to_update (basic_block bb)\n     m_update_list.quick_push (bb);\n }\n \n-// If there is anything in the iterative update_list, continue\n+// If there is anything in the propagation update_list, continue\n // processing NAME until the list of blocks is empty.\n \n void\n-ranger_cache::iterative_cache_update (tree name)\n+ranger_cache::propagate_cache (tree name)\n {\n   basic_block bb;\n   edge_iterator ei;\n@@ -755,6 +768,50 @@ ranger_cache::iterative_cache_update (tree name)\n       }\n }\n \n+// Check to see if an update to the value for NAME in BB has any effect\n+// on values already in the on-entry cache for successor blocks.\n+// If it does, update them.  Don't visit any blocks which dont have a cache\n+// entry.\n+\n+void\n+ranger_cache::propagate_updated_value (tree name, basic_block bb)\n+{\n+  edge e;\n+  edge_iterator ei;\n+\n+  // The update work list should be empty at this point.\n+  gcc_checking_assert (m_update_list.length () == 0);\n+  gcc_checking_assert (bb);\n+\n+  if (DEBUG_RANGE_CACHE)\n+    {\n+      fprintf (dump_file, \" UPDATE cache for \");\n+      print_generic_expr (dump_file, name, TDF_SLIM);\n+      fprintf (dump_file, \" in BB %d : successors : \", bb->index);\n+    }\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    {\n+      // Only update active cache entries.\n+      if (m_on_entry.bb_range_p (name, e->dest))\n+\t{\n+\t  add_to_update (e->dest);\n+\t  if (DEBUG_RANGE_CACHE)\n+\t    fprintf (dump_file, \" UPDATE: bb%d\", e->dest->index);\n+\t}\n+    }\n+    if (m_update_list.length () != 0)\n+      {\n+\tif (DEBUG_RANGE_CACHE)\n+\t  fprintf (dump_file, \"\\n\");\n+\tpropagate_cache (name);\n+      }\n+    else\n+      {\n+\tif (DEBUG_RANGE_CACHE)\n+\t  fprintf (dump_file, \"  : No updates!\\n\");\n+      }\n+}\n+\n // Make sure that the range-on-entry cache for NAME is set for block BB.\n // Work back through the CFG to DEF_BB ensuring the range is calculated\n // on the block/edges leading back to that point.\n@@ -864,13 +921,13 @@ ranger_cache::fill_block_cache (tree name, basic_block bb, basic_block def_bb)\n     fprintf (dump_file, \"\\n\");\n \n   // Now fill in the marked blocks with values.\n-  iterative_cache_update (name);\n+  propagate_cache (name);\n   if (DEBUG_RANGE_CACHE)\n-    fprintf (dump_file, \"  iterative update done.\\n\");\n+    fprintf (dump_file, \"  Propagation update done.\\n\");\n \n   // Now that the cache has been updated, check to see if there were any \n   // SSA_NAMES used in filling the cache which were \"poor values\".\n-  // We can evaluate them, and inject any new values into the iteration \n+  // Evaluate them, and inject any new values into the propagation\n   // list, and see if it improves any on-entry values.\n   if (poor_list_start !=  m_poor_value_list.length ())\n     {\n@@ -886,50 +943,25 @@ ranger_cache::fill_block_cache (tree name, basic_block bb, basic_block def_bb)\n \t  basic_block calc_bb = rec.bb;\n \t  int_range_max tmp;\n \n-\t  // The update work list should be empty at this point.\n-\t  gcc_checking_assert (m_update_list.length () == 0);\n-\n \t  if (DEBUG_RANGE_CACHE)\n \t    {\n \t      fprintf (dump_file, \"(%d:%d)Calculating \",\n \t\t       m_poor_value_list.length () + 1, poor_list_start);\n \t      print_generic_expr (dump_file, name, TDF_SLIM);\n-\t      fprintf (dump_file, \" used poor value for \");\n+\t      fprintf (dump_file, \" used POOR VALUE for \");\n \t      print_generic_expr (dump_file, rec.calc, TDF_SLIM);\n \t      fprintf (dump_file, \" in bb%d, trying to improve:\\n\",\n \t\t       calc_bb->index);\n \t    }\n \n-\t  // It must have at least one edge, pick edge 0.  we just want to\n-\t  // calculate a range at the exit from the block so the caches feeding\n-\t  // this block will be filled up. \n-\t  gcc_checking_assert (EDGE_SUCC (calc_bb, 0));\n-\t  query.range_on_edge (tmp, EDGE_SUCC (calc_bb, 0), rec.calc);\n+\t  // Calculate a range at the exit from the block so the caches feeding\n+\t  // this block will be filled, and we'll get a \"better\" value.\n+\t  query.range_on_exit (tmp, calc_bb, rec.calc);\n \t  \n-\t  if (DEBUG_RANGE_CACHE)\n-\t    fprintf (dump_file, \"    Checking successors of bb%d :\",\n-\t\t     calc_bb->index);\n-\n-\t  // Try recalculating any successor blocks with the new value.\n-\t  // Note that even if this value is refined from the initial value,\n-\t  // it may not affect the calculation, but the iterative update\n-\t  // will resolve that efficently.\n-\t  FOR_EACH_EDGE (e, ei, calc_bb->succs)\n-\t    {\n-\t      if (DEBUG_RANGE_CACHE)\n-\t\tfprintf (dump_file, \"bb%d: \", e->dest->index);\n-\t      // Only update active cache entries.\n-\t      if (m_on_entry.bb_range_p (name, e->dest))\n-\t\t{\n-\t\t  if (DEBUG_RANGE_CACHE)\n-\t\t    fprintf (dump_file, \"update \");\n-\t\t  add_to_update (e->dest);\n-\t\t}\n-\t    }\n-\t  if (DEBUG_RANGE_CACHE)\n-\t    fprintf (dump_file, \"\\n\");\n-\t  // Now see if there is a new value.\n-\t  iterative_cache_update (name);\n+\t  // Then ask for NAME to be re-evaluated on outgoing edges and \n+\t  // use any new values.\n+\t  propagate_updated_value (name, calc_bb);\n \t}\n     }\n }\n+"}, {"sha": "0e84ab0c4e60a7d3e3b755f1c7e296874550e08a", "filename": "gcc/gimple-range-cache.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea7df355ca4a4571d07d1fc9528cccd1393c2420/gcc%2Fgimple-range-cache.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea7df355ca4a4571d07d1fc9528cccd1393c2420/gcc%2Fgimple-range-cache.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.h?ref=ea7df355ca4a4571d07d1fc9528cccd1393c2420", "patch": "@@ -74,7 +74,7 @@ class ssa_global_cache\n   ssa_global_cache ();\n   ~ssa_global_cache ();\n   bool get_global_range (irange &r, tree name) const;\n-  void set_global_range (tree name, const irange &r);\n+  bool set_global_range (tree name, const irange &r);\n   void clear_global_range (tree name);\n   void clear ();\n   void dump (FILE *f = stderr);\n@@ -90,7 +90,7 @@ class ssa_global_cache\n class ranger_cache : public gori_compute_cache\n {\n public:\n-  ranger_cache (class range_query &q);\n+  ranger_cache (class gimple_ranger &q);\n   ~ranger_cache ();\n \n   virtual void ssa_range_in_bb (irange &r, tree name, basic_block bb);\n@@ -108,7 +108,9 @@ class ranger_cache : public gori_compute_cache\n   block_range_cache m_on_entry;\n   void add_to_update (basic_block bb);\n   void fill_block_cache (tree name, basic_block bb, basic_block def_bb);\n-  void iterative_cache_update (tree name);\n+  void propagate_cache (tree name);\n+\n+  void propagate_updated_value (tree name, basic_block bb);\n \n   vec<basic_block> m_workback;\n   vec<basic_block> m_update_list;\n@@ -121,7 +123,7 @@ class ranger_cache : public gori_compute_cache\n   };\n   bool push_poor_value (basic_block bb, tree name);\n   vec<update_record> m_poor_value_list;\n-  class range_query &query;\n+  class gimple_ranger &query;\n };\n \n #endif // GCC_SSA_RANGE_CACHE_H"}]}