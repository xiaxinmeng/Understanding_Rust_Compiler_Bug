{"sha": "03b72c86a8dfb7b3ccb2c325b7478aeaca33754f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDNiNzJjODZhOGRmYjdiM2NjYjJjMzI1Yjc0NzhhZWFjYTMzNzU0Zg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-12-24T13:33:15Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-12-24T13:33:15Z"}, "message": "(push_reload...\n\n(push_reload, find_reloads): Reload inside a paradoxical SUBREG of MEM\nexcept don't force a reload unless the inner mode is narrower than\nBIGGEST_ALIGNMENT.\n\nFrom-SVN: r6302", "tree": {"sha": "7be8ddb26633dac8e7022e22bde05387bcc07826", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7be8ddb26633dac8e7022e22bde05387bcc07826"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03b72c86a8dfb7b3ccb2c325b7478aeaca33754f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03b72c86a8dfb7b3ccb2c325b7478aeaca33754f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03b72c86a8dfb7b3ccb2c325b7478aeaca33754f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03b72c86a8dfb7b3ccb2c325b7478aeaca33754f/comments", "author": null, "committer": null, "parents": [{"sha": "3c9d8bafe27323a6edd9c3c996beacaa36c022f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c9d8bafe27323a6edd9c3c996beacaa36c022f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c9d8bafe27323a6edd9c3c996beacaa36c022f8"}], "stats": {"total": 67, "additions": 39, "deletions": 28}, "files": [{"sha": "a13dee140e8b1bccb2f98f238c4ebf0c19979820", "filename": "gcc/reload.c", "status": "modified", "additions": 39, "deletions": 28, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03b72c86a8dfb7b3ccb2c325b7478aeaca33754f/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03b72c86a8dfb7b3ccb2c325b7478aeaca33754f/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=03b72c86a8dfb7b3ccb2c325b7478aeaca33754f", "patch": "@@ -644,16 +644,16 @@ push_reload (in, out, inloc, outloc, class,\n \t  || (((GET_CODE (SUBREG_REG (in)) == REG\n \t\t&& REGNO (SUBREG_REG (in)) >= FIRST_PSEUDO_REGISTER)\n \t       || GET_CODE (SUBREG_REG (in)) == MEM)\n+\t      && ((GET_MODE_SIZE (inmode)\n+\t\t   > GET_MODE_SIZE (GET_MODE (SUBREG_REG (in))))\n #ifdef LOAD_EXTEND_OP\n-\t      && GET_MODE_SIZE (inmode) <= UNITS_PER_WORD\n-\t      && GET_MODE_SIZE (GET_MODE (SUBREG_REG (in))) <= UNITS_PER_WORD\n-\t      && (GET_MODE_SIZE (inmode)\n-\t\t  != GET_MODE_SIZE (GET_MODE (SUBREG_REG (in))))\n-#else\n-\t      && (GET_MODE_SIZE (inmode)\n-\t\t  > GET_MODE_SIZE (GET_MODE (SUBREG_REG (in))))\n+\t\t  || (GET_MODE_SIZE (inmode) <= UNITS_PER_WORD\n+\t\t      && (GET_MODE_SIZE (GET_MODE (SUBREG_REG (in)))\n+\t\t\t  <= UNITS_PER_WORD)\n+\t\t      && (GET_MODE_SIZE (inmode)\n+\t\t\t  != GET_MODE_SIZE (GET_MODE (SUBREG_REG (in)))))\n #endif\n-\t      )\n+\t\t  ))\n \t  || (GET_CODE (SUBREG_REG (in)) == REG\n \t      && REGNO (SUBREG_REG (in)) < FIRST_PSEUDO_REGISTER\n \t      /* The case where out is nonzero\n@@ -727,16 +727,16 @@ push_reload (in, out, inloc, outloc, class,\n \t  || (((GET_CODE (SUBREG_REG (out)) == REG\n \t\t&& REGNO (SUBREG_REG (out)) >= FIRST_PSEUDO_REGISTER)\n \t       || GET_CODE (SUBREG_REG (out)) == MEM)\n+\t      && ((GET_MODE_SIZE (outmode)\n+\t\t   > GET_MODE_SIZE (GET_MODE (SUBREG_REG (out))))\n #ifdef LOAD_EXTEND_OP\n-\t      && GET_MODE_SIZE (outmode) <= UNITS_PER_WORD\n-\t      && GET_MODE_SIZE (GET_MODE (SUBREG_REG (out))) <= UNITS_PER_WORD\n-\t      && (GET_MODE_SIZE (outmode)\n-\t\t  != GET_MODE_SIZE (GET_MODE (SUBREG_REG (out))))\n-#else\n-\t      && (GET_MODE_SIZE (outmode)\n-\t\t  > GET_MODE_SIZE (GET_MODE (SUBREG_REG (out))))\n+\t\t  || (GET_MODE_SIZE (outmode) <= UNITS_PER_WORD\n+\t\t      && (GET_MODE_SIZE (GET_MODE (SUBREG_REG (out)))\n+\t\t\t  <= UNITS_PER_WORD)\n+\t\t      && (GET_MODE_SIZE (outmode)\n+\t\t\t  != GET_MODE_SIZE (GET_MODE (SUBREG_REG (out)))))\n #endif\n-\t      )\n+\t\t  ))\n \t  || (GET_CODE (SUBREG_REG (out)) == REG\n \t      && REGNO (SUBREG_REG (out)) < FIRST_PSEUDO_REGISTER\n \t      && ((GET_MODE_SIZE (outmode) <= UNITS_PER_WORD\n@@ -2609,22 +2609,33 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t be a problem accessing OPERAND in the outer mode.  */\n \t      if (CONSTANT_P (operand)\n \t\t  || GET_CODE (operand) == PLUS\n-#ifdef LOAD_EXTEND_OP\n-\t\t  /* If we have a SUBREG where both the inner and outer\n-\t\t     modes are different size but no wider than a word,\n-\t\t     combine.c has made assumptions about the behavior of\n-\t\t     the machine in such register access.  If the data is,\n-\t\t     in fact, in memory we must always load using the size\n-\t\t     assumed to be in the register and let the insn do the\n-\t\t     different-sized accesses.  */\n+\t\t  /* We must force a reload of paradoxical SUBREGs\n+\t\t     of a MEM because the alignment of the inner value\n+\t\t     may not be enough to do the outer reference.\n+\n+\t\t     On machines that extend byte operations and we have a\n+\t\t     SUBREG where both the inner and outer modes are different\n+\t\t     size but no wider than a word, combine.c has made\n+\t\t     assumptions about the behavior of the machine in such\n+\t\t     register access.  If the data is, in fact, in memory we\n+\t\t     must always load using the size assumed to be in the\n+\t\t     register and let the insn do the different-sized \n+\t\t     accesses.  */\n \t\t  || ((GET_CODE (operand) == MEM\n \t\t       || (GET_CODE (operand)== REG\n \t\t\t   && REGNO (operand) >= FIRST_PSEUDO_REGISTER))\n-\t\t      && GET_MODE_SIZE (operand_mode[i]) <= UNITS_PER_WORD\n-\t\t      && GET_MODE_SIZE (GET_MODE (operand)) <= UNITS_PER_WORD\n-\t\t      && (GET_MODE_SIZE (operand_mode[i])\n-\t\t\t  != GET_MODE_SIZE (GET_MODE (operand))))\n+\t\t      && (((GET_MODE_BITSIZE (GET_MODE (operand))\n+\t\t\t    < BIGGEST_ALIGNMENT)\n+\t\t\t   && (GET_MODE_SIZE (operand_mode[i])\n+\t\t\t       > GET_MODE_SIZE (GET_MODE (operand))))\n+#ifdef LOAD_EXTEND_OP\n+\t\t\t  || (GET_MODE_SIZE (operand_mode[i]) <= UNITS_PER_WORD\n+\t\t\t      && (GET_MODE_SIZE (GET_MODE (operand))\n+\t\t\t\t  <= UNITS_PER_WORD)\n+\t\t\t      && (GET_MODE_SIZE (operand_mode[i])\n+\t\t\t\t  != GET_MODE_SIZE (GET_MODE (operand))))\n #endif\n+\t\t\t  ))\n \t\t  /* Subreg of a hard reg which can't handle the subreg's mode\n \t\t     or which would handle that mode in the wrong number of\n \t\t     registers for subregging to work.  */"}]}