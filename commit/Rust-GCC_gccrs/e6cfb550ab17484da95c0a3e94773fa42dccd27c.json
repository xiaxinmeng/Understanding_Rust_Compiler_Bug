{"sha": "e6cfb550ab17484da95c0a3e94773fa42dccd27c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTZjZmI1NTBhYjE3NDg0ZGE5NWMwYTNlOTQ3NzNmYTQyZGNjZDI3Yw==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@cygnus.com", "date": "1998-12-08T14:04:03Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "1998-12-08T14:04:03Z"}, "message": "See ChangeLog..\n\nTue Dec  8 15:32:56 EST 1998  Andrew MacLeod  <amacleod@cygnus.com>\nSee ChangeLog.. These are the files that were changed:\n\t* eh-common.h (struct eh_context): Add table_index for rethrows.\n\t* rtl.h (enum reg_note): Add REG_EH_REGION and REG_EH_RETHROW reg notes.\n\t* rtl.c (reg_note_name): Add strings for new reg_note enums.\n\t* expr.h (rethrow_libfunc): New library decl.\n\t* optabs.c (rethrow_libfunc): Initialize.\n\t* except.h (struct eh_entry): Add new field 'rethrow_label'.\n\t* except.c (create_rethrow_ref): New function to create a single\n\t* flow.c (make_edges): Add different edges for rethrow calls,\n\t* integrate.c (save_for_inline_eh_labelmap): New callback routine to\n\t* libgcc2.c (find_exception_handler): Generalize to enable it to\n        * cp/except.c\n        * cp/exception.cc\n\nFrom-SVN: r24194", "tree": {"sha": "7f21607b0446aa635cee54fb52e2f750bc2be0d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7f21607b0446aa635cee54fb52e2f750bc2be0d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6cfb550ab17484da95c0a3e94773fa42dccd27c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6cfb550ab17484da95c0a3e94773fa42dccd27c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6cfb550ab17484da95c0a3e94773fa42dccd27c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6cfb550ab17484da95c0a3e94773fa42dccd27c/comments", "author": null, "committer": null, "parents": [{"sha": "2bfdc2d4e73144131b2e2de7ccfc1183f63175ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bfdc2d4e73144131b2e2de7ccfc1183f63175ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bfdc2d4e73144131b2e2de7ccfc1183f63175ac"}], "stats": {"total": 831, "additions": 683, "deletions": 148}, "files": [{"sha": "f75a603edac38e30b3eebf22a40326252ea74715", "filename": "gcc/ChangeLog", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cfb550ab17484da95c0a3e94773fa42dccd27c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cfb550ab17484da95c0a3e94773fa42dccd27c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e6cfb550ab17484da95c0a3e94773fa42dccd27c", "patch": "@@ -1,3 +1,71 @@\n+Tue Dec  8 15:32:56 EST 1998  Andrew MacLeod  <amacleod@cygnus.com>\n+\n+\t* eh-common.h (struct eh_context): Add table_index for rethrows.\n+\n+\t* rtl.h (enum reg_note): Add REG_EH_REGION and REG_EH_RETHROW reg notes.\n+\t(SYMBOL_REF_NEED_ADJUST): New flag indicating symbol needs to be\n+\tprocessed when inlined or unrolled (ie duplicated in some way).\n+\n+\t* rtl.c (reg_note_name): Add strings for new reg_note enums.\n+\n+\t* expr.h (rethrow_libfunc): New library decl.\n+\n+\t* optabs.c (rethrow_libfunc): Initialize.\n+\n+\t* except.h (struct eh_entry): Add new field 'rethrow_label'.\n+\t(new_eh_region_entry): No longer exported from except.c.\n+\t(duplicate_handlers): Renamed to duplicate_eh_handlers and \n+\tdifferent prototype.\n+\t(rethrow_symbol_map, rethrow_used): New exported functions.\n+\t(eh_region_from_symbol): New exported function.\n+\n+\t* except.c (create_rethrow_ref): New function to create a single\n+\tSYMBOL_REF for a rethrow region.  \n+\t(push_eh_entry): Initialize a rethrow ref.\n+\t(func_eh_entry): Add a rethrow_label field.\n+\t(new_eh_region_entry): Make static, and initialize the rethrow entry.\n+\t(duplicate_eh_handlers): Create a new region, and remap labels/symbols.\n+\t(eh_region_from_symbol): Find an EH region based on its rethrow symbol.\n+\t(rethrow_symbol_map): Given a label map, maps a rethrow symbol for \n+\ta region into an appropriate new symbol.\n+\t(rethrow_used): Indicate whether a rethrow symbol has been referenced.\n+\t(expand_eh_region_end): Don't issue jump around code for new-exceptions.\n+\t(end_catch_handler): Emit a barrier for new-exceptions since \n+\tcontrol can never drop through the end of a catch block.\n+\t(expand_end_all_catch): new-exceptions never fall through a catch \n+\tblock.\n+\t(expand_rethrow): use __rethrow routine for new exceptions.\n+\t(output_exception_table_entry): Generate rethrow labels, if needed.\n+\t(output_exception_table): Generate start and end rethrow labels.\n+\t(init_eh): Create rethrow symbols for beginning and end of table.\n+\t(scan_region): Don't eliminate EH regions which are the targets of\n+\trethrows.\n+\n+\t* flow.c (make_edges): Add different edges for rethrow calls, \n+\tidentified by having the REG_EH_RETHROW reg label.\n+\t(delete_unreachable_blocks): Don't delete regions markers which are \n+\tthe target of a rethrow.\n+\n+\t* integrate.c (save_for_inline_eh_labelmap): New callback routine to \n+\tallow save_for_inline_copying to call duplicate_eh_handlers.\n+\t(save_for_inline_copying): Call duplicate_eh_handlers instead of\n+\texposing internal details of exception regions.\n+\t(copy_for_inline): Check if SYMBOL_REFs need adjustment.\n+\t(expand_inline_function_eh_labelmap):  New callback routine to \n+\tallow expand_inline_function to call duplicate_eh_handlers.\n+\t(expand_inline_function): Call duplicate_eh_handlers instead of\n+\texposing internal details of exception regions.\n+\t(copy_rtx_and_substitute): Adjust SYMBOL_REFS if SYMBOL_REF_NEED_ADJUST\n+\tflag is set.\n+\n+\t* libgcc2.c (find_exception_handler): Generalize to enable it to\n+\tpick up processing where it left off last time for a rethrow.\n+\t(__unwinding_cleanup): New function. debug hook which is called before\n+\tunwinding when __throw finds there is nothing but cleanups left.\n+\t(throw_helper): Common parts of __throw extracted out for reuse.\n+\t(__throw): Common parts moved to throw_helper.\n+\t(__rethrow): New function for performing rethrows.\n+\n Tue Dec  8 13:11:04 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* reload1.c (current_function_decl): Tweak declaration."}, {"sha": "40280afc8a25cd2b55455ca21b81e3b892dbf141", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cfb550ab17484da95c0a3e94773fa42dccd27c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cfb550ab17484da95c0a3e94773fa42dccd27c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e6cfb550ab17484da95c0a3e94773fa42dccd27c", "patch": "@@ -1,3 +1,19 @@\n+1998-12-08  Andrew MacLeod  <amacleod@cygnus.com>\n+\n+\t* cp/except.c (call_eh_info): use __start_cp_handler instead of\n+\t__cp_eh_info for getting the eh info pointer. Add table_index to\n+\tfield list.\n+\t(push_eh_cleanup): Don't increment 'handlers' data field.\n+\t(process_start_catch_block): Don't set the 'caught' field.\n+\n+\t* cp/exception.cc (CP_EH_INFO): New macro for getting the \n+\texception info pointer within library routines.\n+\t(__cp_eh_info): Use CP_EH_INFO.\n+\t(__start_cp_handler): Get exception info pointer, set caught field,\n+\tand increment the handlers field. Avoids this being done by handlers.\n+\t(__uncatch_exception, __check_eh_spec): Use CP_EH_INFO macro.\n+\t(uncaught_exception): Use CP_EH_INFO macro.\n+\n Tue Dec  8 10:48:21 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* Make-lang.in (cxxmain.o): Depend on $(DEMANGLE_H), not demangle.h"}, {"sha": "a2c2c51baceaa6308fb69fe2df985c77f0631ca4", "filename": "gcc/cp/except.c", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cfb550ab17484da95c0a3e94773fa42dccd27c/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cfb550ab17484da95c0a3e94773fa42dccd27c/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=e6cfb550ab17484da95c0a3e94773fa42dccd27c", "patch": "@@ -249,14 +249,14 @@ call_eh_info ()\n {\n   tree fn;\n \n-  fn = get_identifier (\"__cp_eh_info\");\n+  fn = get_identifier (\"__start_cp_handler\");\n   if (IDENTIFIER_GLOBAL_VALUE (fn))\n     fn = IDENTIFIER_GLOBAL_VALUE (fn);\n   else\n     {\n       tree t1, t, fields[7];\n \n-      /* Declare cp_eh_info * __cp_eh_info (void),\n+      /* Declare cp_eh_info * __start_cp_handler (void),\n \t as defined in exception.cc. */\n       push_obstacks_nochange ();\n       end_temporary_allocation ();\n@@ -270,9 +270,11 @@ call_eh_info ()\n                     get_identifier (\"dynamic_handler_chain\"), ptr_type_node);\n       fields[2] = build_lang_field_decl (FIELD_DECL, \n                     get_identifier (\"info\"), ptr_type_node);\n+      fields[3] = build_lang_field_decl (FIELD_DECL, \n+                    get_identifier (\"table_index\"), ptr_type_node);\n       /* N.B.: The fourth field LEN is expected to be\n \t the number of fields - 1, not the total number of fields.  */\n-      finish_builtin_type (t1, \"eh_context\", fields, 2, ptr_type_node);\n+      finish_builtin_type (t1, \"eh_context\", fields, 3, ptr_type_node);\n       t1 = build_pointer_type (t1);\n \n       t1= make_lang_type (RECORD_TYPE);\n@@ -547,9 +549,6 @@ push_eh_cleanup ()\n {\n   int yes;\n \n-  expand_expr (build_unary_op (PREINCREMENT_EXPR, get_eh_handlers (), 1),\n-\t       const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\n   yes = suspend_momentary ();\n   /* All cleanups must last longer than normal.  */\n   expand_decl_cleanup (NULL_TREE, do_pop_exception ());\n@@ -701,9 +700,6 @@ process_start_catch_block (declspecs, declarator)\n       /* Fall into the catch all section.  */\n     }\n \n-  init = build_modify_expr (get_eh_caught (), NOP_EXPR, integer_one_node);\n-  expand_expr (init, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\n   emit_line_note (input_filename, lineno);\n }\n "}, {"sha": "8e8f35f50dbecb459ac82d408f1252696ff804b2", "filename": "gcc/cp/exception.cc", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cfb550ab17484da95c0a3e94773fa42dccd27c/gcc%2Fcp%2Fexception.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cfb550ab17484da95c0a3e94773fa42dccd27c/gcc%2Fcp%2Fexception.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexception.cc?ref=e6cfb550ab17484da95c0a3e94773fa42dccd27c", "patch": "@@ -117,13 +117,29 @@ __cp_exception_info (void)\n   return &((*__get_eh_info ())->value);\n }\n \n-/* Compiler hook to return a pointer to the info for the current exception.\n+#define CP_EH_INFO ((cp_eh_info *) *__get_eh_info ())\n+\n+/* Old Compiler hook to return a pointer to the info for the current exception.\n    Used by get_eh_info ().  */\n \n extern \"C\" cp_eh_info *\n __cp_eh_info (void)\n {\n-  return *__get_eh_info ();\n+  cp_eh_info *p = CP_EH_INFO;\n+  return p;\n+}\n+\n+/* Compiler hook to return a pointer to the info for the current exception,\n+   Set the caught bit, and increment the number of handlers that are\n+   looking at this exception. This makes handlers smaller. */\n+\n+extern \"C\" cp_eh_info *\n+__start_cp_handler (void)\n+{\n+  cp_eh_info *p = CP_EH_INFO;\n+  p->caught = 1;\n+  p->handlers++;\n+  return p;\n }\n \n /* Allocate a buffer for a cp_eh_info and an exception object of size SIZE,\n@@ -242,7 +258,7 @@ __cp_pop_exception (cp_eh_info *p)\n extern \"C\" void\n __uncatch_exception (void)\n {\n-  cp_eh_info *p = __cp_eh_info ();\n+  cp_eh_info *p = CP_EH_INFO;\n   if (p == 0)\n     terminate ();\n   p->caught = false;\n@@ -263,7 +279,7 @@ __uncatch_exception (void)\n extern \"C\" void\n __check_eh_spec (int n, const void **spec)\n {\n-  cp_eh_info *p = __cp_eh_info ();\n+  cp_eh_info *p = CP_EH_INFO;\n \n   for (int i = 0; i < n; ++i)\n     {\n@@ -316,7 +332,7 @@ __throw_bad_typeid (void)\n bool\n std::uncaught_exception ()\n {\n-  cp_eh_info *p = __cp_eh_info ();\n+  cp_eh_info *p = CP_EH_INFO;\n   return p && ! p->caught;\n }\n "}, {"sha": "5d9f30c91b3a559ed9de3c0ce99a6b9cbaf23cb6", "filename": "gcc/eh-common.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cfb550ab17484da95c0a3e94773fa42dccd27c/gcc%2Feh-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cfb550ab17484da95c0a3e94773fa42dccd27c/gcc%2Feh-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Feh-common.h?ref=e6cfb550ab17484da95c0a3e94773fa42dccd27c", "patch": "@@ -29,6 +29,8 @@ struct eh_context\n   void **dynamic_handler_chain;\n   /* This is language dependent part of the eh context. */\n   void *info;\n+  /* This is used to remember where we threw for re-throws */\n+  void *table_index;  /* address of exception table entry to rethrow from */\n };\n \n #ifndef EH_TABLE_LOOKUP"}, {"sha": "40aafdd21dce628ddd541e28a9868806a1f04169", "filename": "gcc/except.c", "status": "modified", "additions": 201, "deletions": 27, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cfb550ab17484da95c0a3e94773fa42dccd27c/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cfb550ab17484da95c0a3e94773fa42dccd27c/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=e6cfb550ab17484da95c0a3e94773fa42dccd27c", "patch": "@@ -406,6 +406,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"recog.h\"\n #include \"output.h\"\n #include \"toplev.h\"\n+#include \"obstack.h\"\n \n /* One to use setjmp/longjmp method of generating code for exception\n    handling.  */\n@@ -502,6 +503,15 @@ static rtx eh_return_handler;\n \n rtx eh_return_stub_label;\n \n+/* This is used for targets which can call rethrow with an offset instead\n+   of an address. This is subtracted from the rethrow label we are\n+   interested in. */\n+\n+static rtx first_rethrow_symbol = NULL_RTX;\n+static rtx final_rethrow = NULL_RTX;\n+static rtx last_rethrow_symbol = NULL_RTX;\n+\n+\n /* Prototypes for local functions.  */\n \n static void push_eh_entry\tPROTO((struct eh_stack *));\n@@ -526,6 +536,29 @@ rtx expand_builtin_return_addr\tPROTO((enum built_in_function, int, rtx));\n /* Various support routines to manipulate the various data structures\n    used by the exception handling code.  */\n \n+extern struct obstack permanent_obstack;\n+\n+/* Generate a SYMBOL_REF for rethrow to use */\n+static rtx\n+create_rethrow_ref (region_num)\n+     int region_num;\n+{\n+  rtx def;\n+  char *ptr;\n+  char buf[60];\n+\n+  push_obstacks_nochange ();\n+  end_temporary_allocation ();\n+\n+  ASM_GENERATE_INTERNAL_LABEL (buf, \"LRTH\", region_num);\n+  ptr = (char *) obstack_copy0 (&permanent_obstack, buf, strlen (buf));\n+  def = gen_rtx_SYMBOL_REF (Pmode, ptr);\n+  SYMBOL_REF_NEED_ADJUST (def) = 1;\n+\n+  pop_obstacks ();\n+  return def;\n+}\n+\n /* Push a label entry onto the given STACK.  */\n \n void\n@@ -600,11 +633,16 @@ push_eh_entry (stack)\n   struct eh_node *node = (struct eh_node *) xmalloc (sizeof (struct eh_node));\n   struct eh_entry *entry = (struct eh_entry *) xmalloc (sizeof (struct eh_entry));\n \n-  entry->outer_context = gen_label_rtx ();\n+  rtx rlab = gen_exception_label ();\n   entry->finalization = NULL_TREE;\n   entry->label_used = 0;\n-  entry->exception_handler_label = gen_exception_label ();\n+  entry->exception_handler_label = rlab;\n   entry->false_label = NULL_RTX;\n+  if (! flag_new_exceptions)\n+    entry->outer_context = gen_label_rtx ();\n+  else\n+    entry->outer_context = create_rethrow_ref (CODE_LABEL_NUMBER (rlab));\n+  entry->rethrow_label = entry->outer_context;\n \n   node->entry = entry;\n   node->chain = stack->top;\n@@ -707,6 +745,7 @@ receive_exception_label (handler_label)\n struct func_eh_entry \n {\n   int range_number;   /* EH region number from EH NOTE insn's */\n+  rtx rethrow_label;  /* Label for rethrow */\n   struct handler_info *handlers;\n };\n \n@@ -719,12 +758,14 @@ static int current_func_eh_entry = 0;\n #define SIZE_FUNC_EH(X)   (sizeof (struct func_eh_entry) * X)\n \n /* Add a new eh_entry for this function, and base it off of the information\n-   in the EH_ENTRY parameter. A NULL parameter is invalid. The number\n+   in the EH_ENTRY parameter. A NULL parameter is invalid. \n+   OUTER_CONTEXT is a label which is used for rethrowing. The number\n    returned is an number which uniquely identifies this exception range. */\n \n-int \n-new_eh_region_entry (note_eh_region) \n+static int \n+new_eh_region_entry (note_eh_region, rethrow) \n      int note_eh_region;\n+     rtx rethrow;\n {\n   if (current_func_eh_entry == num_func_eh_entries) \n     {\n@@ -742,6 +783,11 @@ new_eh_region_entry (note_eh_region)\n         }\n     }\n   function_eh_regions[current_func_eh_entry].range_number = note_eh_region;\n+  if (rethrow == NULL_RTX)\n+    function_eh_regions[current_func_eh_entry].rethrow_label = \n+                                          create_rethrow_ref (note_eh_region);\n+  else\n+    function_eh_regions[current_func_eh_entry].rethrow_label = rethrow;\n   function_eh_regions[current_func_eh_entry].handlers = NULL;\n \n   return current_func_eh_entry++;\n@@ -929,34 +975,98 @@ clear_function_eh_region ()\n }\n \n /* Make a duplicate of an exception region by copying all the handlers\n-   for an exception region. Return the new handler index. */\n+   for an exception region. Return the new handler index. The final\n+   parameter is a routine which maps old labels to new ones. */\n \n int \n-duplicate_handlers (old_note_eh_region, new_note_eh_region)\n+duplicate_eh_handlers (old_note_eh_region, new_note_eh_region, map)\n      int old_note_eh_region, new_note_eh_region;\n+     rtx (*map)(rtx);\n {\n   struct handler_info *ptr, *new_ptr;\n   int new_region, region;\n+  rtx tmp;\n \n   region = find_func_region (old_note_eh_region);\n   if (region == -1)\n-    error (\"Cannot duplicate non-existant exception region.\");\n+    fatal (\"Cannot duplicate non-existant exception region.\");\n+\n+  /* duplicate_eh_handlers may have been called during a symbol remap. */\n+  new_region = find_func_region (new_note_eh_region);\n+  if (new_region != -1)\n+    return (new_region);\n \n-  if (find_func_region (new_note_eh_region) != -1)\n-    error (\"Cannot duplicate EH region because new note region already exists\");\n+  new_region = new_eh_region_entry (new_note_eh_region, NULL_RTX);\n \n-  new_region = new_eh_region_entry (new_note_eh_region);\n   ptr = function_eh_regions[region].handlers;\n \n   for ( ; ptr; ptr = ptr->next) \n     {\n-      new_ptr = get_new_handler (ptr->handler_label, ptr->type_info);\n+      new_ptr = get_new_handler (map (ptr->handler_label), ptr->type_info);\n       add_new_handler (new_region, new_ptr);\n     }\n \n   return new_region;\n }\n \n+\n+/* Given a rethrow symbol, find the EH region number this is for. */\n+int \n+eh_region_from_symbol (sym)\n+     rtx sym;\n+{\n+  int x;\n+  if (sym == last_rethrow_symbol)\n+    return 1;\n+  for (x = 0; x < current_func_eh_entry; x++)\n+    if (function_eh_regions[x].rethrow_label == sym)\n+      return function_eh_regions[x].range_number;\n+  return -1;\n+}\n+\n+\n+/* When inlining/unrolling, we have to map the symbols passed to\n+   __rethrow as well. This performs the remap. If a symbol isn't foiund,\n+   the original one is returned. This is not an efficient routine,\n+   so don't call it on everything!! */\n+rtx \n+rethrow_symbol_map (sym, map)\n+     rtx sym;\n+     rtx (*map)(rtx);\n+{\n+  int x, y;\n+  for (x = 0; x < current_func_eh_entry; x++)\n+    if (function_eh_regions[x].rethrow_label == sym)\n+      {\n+        /* We've found the original region, now lets determine which region\n+           this now maps to. */\n+        rtx l1 = function_eh_regions[x].handlers->handler_label;\n+        rtx l2 = map (l1);\n+        y = CODE_LABEL_NUMBER (l2); /* This is the new region number */\n+        x = find_func_region (y);  /* Get the new permanent region */\n+        if (x == -1)  /* Hmm, Doesn't exist yet */\n+          {\n+            x = duplicate_eh_handlers (CODE_LABEL_NUMBER (l1), y, map);\n+            /* Since we're mapping it, it must be used. */\n+            SYMBOL_REF_USED (function_eh_regions[x].rethrow_label) = 1;\n+          }\n+        return function_eh_regions[x].rethrow_label;\n+      }\n+  return sym;\n+}\n+\n+int \n+rethrow_used (region)\n+     int region;\n+{\n+  if (flag_new_exceptions)\n+    {\n+      rtx lab = function_eh_regions[find_func_region (region)].rethrow_label;\n+      return (SYMBOL_REF_USED (lab));\n+    }\n+  return 0;\n+}\n+\n \f\n /* Routine to see if exception handling is turned on.\n    DO_WARN is non-zero if we want to inform the user that exception\n@@ -1410,16 +1520,17 @@ expand_eh_region_end (handler)\n {\n   struct eh_entry *entry;\n   rtx note;\n+  int ret, r;\n \n   if (! doing_eh (0))\n     return;\n \n   entry = pop_eh_entry (&ehstack);\n \n   note = emit_note (NULL_PTR, NOTE_INSN_EH_REGION_END);\n-  NOTE_BLOCK_NUMBER (note)\n+  ret = NOTE_BLOCK_NUMBER (note)\n     = CODE_LABEL_NUMBER (entry->exception_handler_label);\n-  if (exceptions_via_longjmp == 0\n+  if (exceptions_via_longjmp == 0 && ! flag_new_exceptions\n       /* We share outer_context between regions; only emit it once.  */\n       && INSN_UID (entry->outer_context) == 0)\n     {\n@@ -1439,7 +1550,7 @@ expand_eh_region_end (handler)\n   entry->finalization = handler;\n \n   /* create region entry in final exception table */\n-  new_eh_region_entry (NOTE_BLOCK_NUMBER (note));\n+  r = new_eh_region_entry (NOTE_BLOCK_NUMBER (note), entry->rethrow_label);\n \n   enqueue_eh_entry (&ehqueue, entry);\n \n@@ -1673,8 +1784,14 @@ start_catch_handler (rtime)\n void \n end_catch_handler ()\n {\n-  if (! doing_eh (1) || (flag_new_exceptions && ! exceptions_via_longjmp))\n+  if (! doing_eh (1))\n     return;\n+\n+  if (flag_new_exceptions && ! exceptions_via_longjmp) \n+    {\n+      emit_barrier ();\n+      return;\n+    }\n   \n   /* A NULL label implies the catch clause was a catch all or cleanup */\n   if (catchstack.top->entry->false_label == NULL_RTX)\n@@ -1786,7 +1903,7 @@ expand_start_all_catch ()\n void\n expand_end_all_catch ()\n {\n-  rtx new_catch_clause, outer_context = NULL_RTX;\n+  rtx new_catch_clause;\n   struct eh_entry *entry;\n \n   if (! doing_eh (1))\n@@ -1798,11 +1915,17 @@ expand_end_all_catch ()\n \n   if (! exceptions_via_longjmp)\n     {\n-      outer_context = ehstack.top->entry->outer_context;\n+      rtx outer_context = ehstack.top->entry->outer_context;\n \n       /* Finish the rethrow region.  size_zero_node is just a NOP.  */\n       expand_eh_region_end (size_zero_node);\n+      /* New exceptions handling models will never have a fall through\n+         of a catch clause */\n+      if (!flag_new_exceptions)\n+        expand_rethrow (outer_context);\n     }\n+  else \n+    expand_rethrow (NULL_RTX);\n \n   /* Code to throw out to outer context, if we fall off end of catch\n      handlers.  This is rethrow (Lresume, same id, same obj) in the\n@@ -1813,7 +1936,6 @@ expand_end_all_catch ()\n      do a \"throw\" (using the address of Lresume as the point being\n      thrown from) so that the outer EH region can then try to process\n      the exception.  */\n-  expand_rethrow (outer_context);\n \n   /* Now we have the complete catch sequence.  */\n   new_catch_clause = get_insns ();\n@@ -1842,7 +1964,22 @@ expand_rethrow (label)\n   if (exceptions_via_longjmp)\n     emit_throw ();\n   else\n-    emit_jump (label);\n+    if (flag_new_exceptions)\n+      {\n+        rtx insn, val;\n+        if (label == NULL_RTX)\n+          label = last_rethrow_symbol;\n+        emit_library_call (rethrow_libfunc, 0, VOIDmode, 1, label, Pmode);\n+        SYMBOL_REF_USED (label) = 1;\n+        insn = get_last_insn ();\n+        val = GEN_INT (eh_region_from_symbol (label));\n+        /* Mark the label/symbol on the call. */\n+        REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EH_RETHROW, val,\n+                                     REG_NOTES (insn));\n+        emit_barrier ();\n+      }\n+    else\n+      emit_jump (label);\n }\n \n /* End all the pending exception regions on protect_list. The handlers\n@@ -1976,12 +2113,29 @@ output_exception_table_entry (file, n)\n {\n   char buf[256];\n   rtx sym;\n-  struct handler_info *handler;\n+  struct handler_info *handler = get_first_handler (n);\n+  int index = find_func_region (n);\n+  rtx rethrow;\n+  \n+ /* form and emit the rethrow label, if needed  */\n+  rethrow = function_eh_regions[index].rethrow_label;\n+  if (rethrow != NULL_RTX && !flag_new_exceptions)\n+      rethrow = NULL_RTX;\n+  if (rethrow != NULL_RTX && handler == NULL)\n+    if (! SYMBOL_REF_USED (rethrow))\n+      rethrow = NULL_RTX;\n \n-  handler = get_first_handler (n);\n \n-  for ( ; handler != NULL; handler = handler->next)\n+  for ( ; handler != NULL || rethrow != NULL_RTX; handler = handler->next)\n     {\n+      /* rethrow label should indicate the LAST entry for a region */\n+      if (rethrow != NULL_RTX && (handler == NULL || handler->next == NULL))\n+        {\n+          ASM_GENERATE_INTERNAL_LABEL (buf, \"LRTH\", n);\n+          assemble_label(buf);\n+          rethrow = NULL_RTX;\n+        }\n+\n       ASM_GENERATE_INTERNAL_LABEL (buf, \"LEHB\", n);\n       sym = gen_rtx_SYMBOL_REF (Pmode, buf);\n       assemble_integer (sym, POINTER_SIZE / BITS_PER_UNIT, 1);\n@@ -1990,12 +2144,15 @@ output_exception_table_entry (file, n)\n       sym = gen_rtx_SYMBOL_REF (Pmode, buf);\n       assemble_integer (sym, POINTER_SIZE / BITS_PER_UNIT, 1);\n       \n-      assemble_integer (handler->handler_label, \n-                                         POINTER_SIZE / BITS_PER_UNIT, 1);\n+      if (handler == NULL)\n+        assemble_integer (GEN_INT (0), POINTER_SIZE / BITS_PER_UNIT, 1);\n+      else\n+        assemble_integer (handler->handler_label, \n+                          POINTER_SIZE / BITS_PER_UNIT, 1);\n \n       if (flag_new_exceptions)\n         {\n-          if (handler->type_info == NULL)\n+          if (handler == NULL || handler->type_info == NULL)\n             assemble_integer (const0_rtx, POINTER_SIZE / BITS_PER_UNIT, 1);\n           else\n             if (handler->type_info == CATCH_ALL_TYPE)\n@@ -2007,7 +2164,7 @@ output_exception_table_entry (file, n)\n         }\n       putc ('\\n', file);\t\t/* blank line */\n       /* We only output the first label under the old scheme */\n-      if (! flag_new_exceptions)\n+      if (! flag_new_exceptions || handler == NULL)\n         break;\n     }\n }\n@@ -2038,6 +2195,7 @@ void\n output_exception_table ()\n {\n   int i;\n+  char buf[256];\n   extern FILE *asm_out_file;\n \n   if (! doing_eh (0) || ! eh_table)\n@@ -2062,6 +2220,10 @@ output_exception_table ()\n         ;\n       if (i != 0)\n         assemble_integer (const0_rtx, i , 1);\n+\n+      /* Generate the label for offset calculations on rethrows */\n+      ASM_GENERATE_INTERNAL_LABEL (buf, \"LRTH\", 0);\n+      assemble_label(buf);\n     }\n \n   for (i = 0; i < eh_table_size; ++i)\n@@ -2071,6 +2233,9 @@ output_exception_table ()\n   clear_function_eh_region ();\n \n   /* Ending marker for table.  */\n+  /* Generate the label for end of table. */\n+  ASM_GENERATE_INTERNAL_LABEL (buf, \"LRTH\", CODE_LABEL_NUMBER (final_rethrow));\n+  assemble_label(buf);\n   assemble_integer (constm1_rtx, POINTER_SIZE / BITS_PER_UNIT, 1);\n \n   /* for binary compatability, the old __throw checked the second\n@@ -2229,6 +2394,10 @@ check_exception_handler_labels ()\n void\n init_eh ()\n {\n+  \n+  first_rethrow_symbol = create_rethrow_ref (0);\n+  final_rethrow = gen_exception_label ();\n+  last_rethrow_symbol = create_rethrow_ref (CODE_LABEL_NUMBER (final_rethrow));\n }\n \n /* Initialize the per-function EH information.  */\n@@ -2348,6 +2517,11 @@ scan_region (insn, n, delete_outer)\n   /* Assume we can delete the region.  */\n   int delete = 1;\n \n+  int r = find_func_region (n);\n+  /* Can't delete something which is rethrown to. */\n+  if (SYMBOL_REF_USED((function_eh_regions[r].rethrow_label)))\n+    delete = 0;\n+\n   if (insn == NULL_RTX\n       || GET_CODE (insn) != NOTE\n       || NOTE_LINE_NUMBER (insn) != NOTE_INSN_EH_REGION_BEG"}, {"sha": "5b4b3db4ed240d60bd8869436982f766df87cd6f", "filename": "gcc/except.h", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cfb550ab17484da95c0a3e94773fa42dccd27c/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cfb550ab17484da95c0a3e94773fa42dccd27c/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=e6cfb550ab17484da95c0a3e94773fa42dccd27c", "patch": "@@ -65,6 +65,7 @@ struct eh_entry {\n   tree finalization;\n   int label_used;\n   rtx false_label;\n+  rtx rethrow_label;\n };\n \n /* A list of EH_ENTRYs. ENTRY is the entry; CHAIN points to the next\n@@ -177,13 +178,6 @@ typedef struct handler_info\n } handler_info;\n \n \n-/* Add a new eh_entry for this function, The parameter specifies what\n-   exception region number NOTE insns use to delimit this range. \n-   The integer returned is uniquely identifies this exception range\n-   within an internal table. */\n-\n-int new_eh_region_entry                         PROTO((int));\n-\n /* Add new handler information to an exception range. The  first parameter\n    specifies the range number (returned from new_eh_entry()). The second\n    parameter specifies the handler.  By default the handler is inserted at\n@@ -208,8 +202,19 @@ struct handler_info *get_new_handler            PROTO((rtx, void *));\n /* Make a duplicate of an exception region by copying all the handlers\n    for an exception region. Return the new handler index. */\n \n-int duplicate_handlers                          PROTO((int, int));\n+int duplicate_eh_handlers                       PROTO((int, int, rtx (*)(rtx)));\n+\n+/* map symbol refs for rethrow */\n+\n+rtx rethrow_symbol_map                          PROTO((rtx, rtx (*)(rtx)));\n+\n+/* Is the rethrow label for a region used? */\n+\n+int rethrow_used                                PROTO((int));\n+\n+/* Return the region number a this is the rethrow label for. */\n \n+int eh_region_from_symbol                       PROTO((rtx));\n \n /* Get a pointer to the first handler in an exception region's list. */\n "}, {"sha": "134c095bd8c3d402cc8d40c01217fd5f5d2ab748", "filename": "gcc/expr.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cfb550ab17484da95c0a3e94773fa42dccd27c/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cfb550ab17484da95c0a3e94773fa42dccd27c/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=e6cfb550ab17484da95c0a3e94773fa42dccd27c", "patch": "@@ -443,6 +443,7 @@ extern rtx memset_libfunc;\n extern rtx bzero_libfunc;\n \n extern rtx throw_libfunc;\n+extern rtx rethrow_libfunc;\n extern rtx sjthrow_libfunc;\n extern rtx sjpopnthrow_libfunc;\n extern rtx terminate_libfunc;"}, {"sha": "6a4a448e5eefd905bbea75ad04705b7635aa4210", "filename": "gcc/flow.c", "status": "modified", "additions": 56, "deletions": 2, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cfb550ab17484da95c0a3e94773fa42dccd27c/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cfb550ab17484da95c0a3e94773fa42dccd27c/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=e6cfb550ab17484da95c0a3e94773fa42dccd27c", "patch": "@@ -721,6 +721,7 @@ make_edges (i)\n      int i;\n {\n   rtx insn, x;\n+  rtx pending_eh_region = NULL_RTX;\n \n   /* See if control drops into the next block.  */\n   if (i + 1 < n_basic_blocks)\n@@ -801,6 +802,40 @@ make_edges (i)\n \t\t}\n \t    }\n \n+          /* If this is a call with an EH_RETHROW note, then we \n+             know its a rethrow call, and we know exactly where\n+             this call can end up going. */\n+          else if (GET_CODE (insn) == CALL_INSN\n+                    && (note = find_reg_note (insn, REG_EH_RETHROW, NULL_RTX)))\n+            {\n+              int region = XINT (XEXP (note, 0), 0);\n+              /* if nested region is not 0, we know for sure it has been \n+                 processed. If it is zero, we dont know whether its an\n+                 outer region, or hasn't been seen yet, so defer it */\n+              if (nested_eh_region[region] != 0) \n+                {\n+                  /* start with the first region OUTSIDE the one specified \n+                     in the rethrow parameter. (since a rethrow behaves\n+                     as if a handler in the region didn't handle the \n+                     exception, so the handlers for the next outer region\n+                     are going to get a shot at it.*/\n+\t\t  for ( region = nested_eh_region[region]; region; \n+\t\t\tregion = nested_eh_region[region]) \n+\t\t    {\n+\t\t      handler_info *ptr = get_first_handler (region);\n+\t\t      for ( ; ptr ; ptr = ptr->next)\n+                        add_edge_to_label (i, ptr->handler_label);\n+\t\t    }\n+                }\n+              else \n+                {\n+                  /* Push this region onto a list, and after we've done the\n+                     whole procedure, we'll process everything on the list */\n+                  pending_eh_region = gen_rtx_EXPR_LIST (VOIDmode, insn, \n+                                                         pending_eh_region);\n+                }\n+            }\n+\n \t  /* If this is a CALL_INSN, then mark it as reaching the active EH\n \t     handler for this CALL_INSN.  If we're handling asynchronous\n \t     exceptions mark every insn as reaching the active EH handler.\n@@ -837,6 +872,24 @@ make_edges (i)\n \t    }\n \t}\n     }\n+\n+  while (pending_eh_region != NULL_RTX)\n+    {\n+      rtx insn = XEXP (pending_eh_region, 0);\n+      rtx note = find_reg_note (insn, REG_EH_RETHROW, NULL_RTX);\n+      int region = XINT (XEXP (note, 0), 0);\n+      /* start with the first region OUTSIDE the one specified \n+         in the rethrow parameter */\n+      for ( region = nested_eh_region[region]; region; \n+            region = nested_eh_region[region]) \n+        {\n+          handler_info *ptr = get_first_handler (region);\n+          for ( ; ptr ; ptr = ptr->next)\n+            add_edge_to_label (BLOCK_NUM (insn), ptr->handler_label);\n+        }\n+      pending_eh_region = XEXP (pending_eh_region, 1);\n+    }\n+\n   /* We know something about the structure of the function __throw in\n      libgcc2.c.  It is the only function that ever contains eh_stub labels.\n      It modifies its return address so that the last block returns to one of\n@@ -918,8 +971,9 @@ delete_unreachable_blocks ()\n \t      NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_END)\n \t    {\n \t      int num = CODE_LABEL_NUMBER (insn);\n-\t      /* A NULL handler indicates a region is no longer needed */\n-\t      if (get_first_handler (num) == NULL)\n+\t      /* A NULL handler indicates a region is no longer needed,\n+                 unless its the target of a rethrow. */\n+\t      if (get_first_handler (num) == NULL && !rethrow_used (num))\n \t\t{\n \t\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n \t\t  NOTE_SOURCE_FILE (insn) = 0;"}, {"sha": "702e5fa4f513ad63c3e1d1601dcd2cd3044b6f36", "filename": "gcc/integrate.c", "status": "modified", "additions": 42, "deletions": 25, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cfb550ab17484da95c0a3e94773fa42dccd27c/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cfb550ab17484da95c0a3e94773fa42dccd27c/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=e6cfb550ab17484da95c0a3e94773fa42dccd27c", "patch": "@@ -265,6 +265,16 @@ static rtvec copy_asm_constraints_vector;\n /* In save_for_inline, nonzero if past the parm-initialization insns.  */\n static int in_nonparm_insns;\n \f\n+/* subroutines passed to duplicate_eh_handlers to map exception labels */\n+\n+static rtx \n+save_for_inline_eh_labelmap (label)\n+     rtx label;\n+{\n+  int index = CODE_LABEL_NUMBER (label);\n+  return label_map[index];\n+}\n+\n /* Subroutine for `save_for_inline{copying,nocopy}'.  Performs initialization\n    needed to save FNDECL's insns and info for future inline expansion.  */\n    \n@@ -667,19 +677,8 @@ save_for_inline_copying (fndecl)\n \n               /* we have to duplicate the handlers for the original */\n               if (NOTE_LINE_NUMBER (copy) == NOTE_INSN_EH_REGION_BEG) \n-                {\n-                  handler_info *ptr, *temp;\n-                  int nr;\n-                  nr = new_eh_region_entry (new_region);\n-                  ptr = get_first_handler (NOTE_BLOCK_NUMBER (copy));\n-                  for ( ; ptr; ptr = ptr->next)\n-                    {\n-                      temp = get_new_handler (\n-                           label_map[CODE_LABEL_NUMBER (ptr->handler_label)],\n-                                                               ptr->type_info);\n-                      add_new_handler (nr, temp);\n-                    }\n-                }\n+                duplicate_eh_handlers (NOTE_BLOCK_NUMBER (copy), new_region,\n+                                       save_for_inline_eh_labelmap);\n                 \n \t      /* We have to forward these both to match the new exception\n \t\t region.  */\n@@ -1075,11 +1074,15 @@ copy_for_inline (orig)\n     {\n     case QUEUED:\n     case CONST_INT:\n-    case SYMBOL_REF:\n     case PC:\n     case CC0:\n       return x;\n \n+    case SYMBOL_REF:\n+      if (! SYMBOL_REF_NEED_ADJUST (x))\n+        return x;\n+      return rethrow_symbol_map (x, save_for_inline_eh_labelmap);\n+\n     case CONST_DOUBLE:\n       /* We have to make a new CONST_DOUBLE to ensure that we account for\n \t it correctly.  Using the old CONST_DOUBLE_MEM data is wrong.  */\n@@ -1338,6 +1341,18 @@ process_reg_param (map, loc, copy)\n     }\n   map->reg_map[REGNO (loc)] = copy;\n }\n+\n+/* Used by duplicate_eh_handlers to map labels for the exception table */\n+static struct inline_remap *eif_eh_map;\n+\n+static rtx \n+expand_inline_function_eh_labelmap (label)\n+   rtx label;\n+{\n+  int index = CODE_LABEL_NUMBER (label);\n+  return get_label_from_map (eif_eh_map, index);\n+}\n+\n /* Integrate the procedure defined by FNDECL.  Note that this function\n    may wind up calling itself.  Since the static variables are not\n    reentrant, we do not assign them until after the possibility\n@@ -2055,17 +2070,12 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n                   /* we have to duplicate the handlers for the original */\n                   if (NOTE_LINE_NUMBER (copy) == NOTE_INSN_EH_REGION_BEG)\n                     {\n-                      handler_info *ptr, *temp;\n-                      int nr;\n-                      nr = new_eh_region_entry (CODE_LABEL_NUMBER (label));\n-                      ptr = get_first_handler (NOTE_BLOCK_NUMBER (copy));\n-                      for ( ; ptr; ptr = ptr->next)\n-                        {\n-                          temp = get_new_handler ( get_label_from_map (map, \n-                                      CODE_LABEL_NUMBER (ptr->handler_label)),\n-                                                               ptr->type_info);\n-                          add_new_handler (nr, temp);\n-                        }\n+                      /* We need to duplicate the handlers for the EH region\n+                         and we need to indicate where the label map is */\n+                      eif_eh_map = map;\n+                      duplicate_eh_handlers (NOTE_BLOCK_NUMBER (copy), \n+                                             CODE_LABEL_NUMBER (label),\n+                                             expand_inline_function_eh_labelmap);\n                     }\n \n \t\t  /* We have to forward these both to match the new exception\n@@ -2533,6 +2543,13 @@ copy_rtx_and_substitute (orig, map)\n \t\t\t\t\t\t\t\t   map)),\n \t\t\t 0);\n \t}\n+      else\n+        if (SYMBOL_REF_NEED_ADJUST (orig)) \n+          {\n+            eif_eh_map = map;\n+            return rethrow_symbol_map (orig, \n+                                       expand_inline_function_eh_labelmap);\n+          }\n \n       return orig;\n "}, {"sha": "0275525b185aff4a13a9b16fb97618b81dbea8d8", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 240, "deletions": 70, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cfb550ab17484da95c0a3e94773fa42dccd27c/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cfb550ab17484da95c0a3e94773fa42dccd27c/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=e6cfb550ab17484da95c0a3e94773fa42dccd27c", "patch": "@@ -3468,45 +3468,82 @@ old_find_exception_handler (void *pc, old_exception_table *table)\n   return (void *) 0;\n }\n \n+/* find_exception_handler finds the correct handler, if there is one, to\n+   handle an exception.\n+   returns a pointer to the handler which controlled should be transferred\n+   to, or NULL if there is nothing left.\n+   Parameters:\n+   PC - pc where the exception originates. If this is a rethrow, \n+        then this starts out as a pointer to the exception table\n+\tentry we wish to rethrow out of.\n+   TABLE - exception table for the current module.\n+   EH_INFO - eh info pointer for this exception.\n+   RETHROW - 1 if this is a rethrow. (see incoming value of PC).\n+   CLEANUP - returned flag indicating whether this is a cleanup handler.\n+*/\n static void *\n-find_exception_handler (void *pc, exception_descriptor *table, void *eh_info)\n+find_exception_handler (void *pc, exception_descriptor *table, \n+                        __eh_info *eh_info, int rethrow, int *cleanup)\n {\n+\n+  void *retval = NULL;\n+  *cleanup = 1;\n   if (table)\n     {\n+      int pos = 0;\n       /* The new model assumed the table is sorted inner-most out so the\n          first region we find which matches is the correct one */\n \n-      int pos;\n-      void *ret;\n       exception_table *tab = &(table->table[0]);\n \n       /* Subtract 1 from the PC to avoid hitting the next region */\n-      pc--;\n+      if (rethrow) \n+        {\n+          /* pc is actually the region table entry to rethrow out of */\n+          pos = ((exception_table *) pc) - tab;\n+          pc = ((exception_table *) pc)->end_region - 1;\n+\n+          /* The label is always on the LAST handler entry for a region, \n+             so we know the next entry is a different region, even if the\n+             addresses are the same. Make sure its not end of table tho. */\n+          if (tab[pos].start_region != (void *) -1)\n+            pos++;\n+        }\n+      else\n+        pc--;\n       \n       /* We can't do a binary search because the table is in inner-most\n          to outermost address ranges within functions */\n-      for (pos = 0; tab[pos].start_region != (void *) -1; pos++)\n+      for ( ; tab[pos].start_region != (void *) -1; pos++)\n         { \n           if (tab[pos].start_region <= pc && tab[pos].end_region > pc)\n             {\n               if (tab[pos].match_info)\n                 {\n-                  __eh_matcher matcher = ((__eh_info *)eh_info)->match_function;\n+                  __eh_matcher matcher = eh_info->match_function;\n                   /* match info but no matcher is NOT a match */\n                   if (matcher) \n                     {\n-                      ret = (*matcher)(eh_info, tab[pos].match_info, table);\n-                      if (ret)\n-                        return tab[pos].exception_handler;\n+                      void *ret = (*matcher)((void *) eh_info, \n+                                             tab[pos].match_info, table);\n+                      if (ret) \n+                        {\n+                          if (retval == NULL)\n+                            retval = tab[pos].exception_handler;\n+                          *cleanup = 0;\n+                          break;\n+                        }\n                     }\n                 }\n               else\n-                return tab[pos].exception_handler;\n+                {\n+                  if (retval == NULL)\n+                    retval = tab[pos].exception_handler;\n+                }\n             }\n         }\n     }\n-\n-  return (void *) 0;\n+  return retval;\n }\n #endif /* DWARF2_UNWIND_INFO */\n #endif /* EH_TABLE_LOOKUP */\n@@ -3643,54 +3680,47 @@ next_stack_level (void *pc, frame_state *udata, frame_state *caller_udata)\n   return caller_udata;\n }\n \n-/* We first search for an exception handler, and if we don't find\n-   it, we call __terminate on the current stack frame so that we may\n-   use the debugger to walk the stack and understand why no handler\n-   was found.\n-\n-   If we find one, then we unwind the frames down to the one that\n-   has the handler and transfer control into the handler.  */\n-\n-/*extern void __throw(void) __attribute__ ((__noreturn__));*/\n-\n-void\n-__throw ()\n+/* Hook to call before __terminate if only cleanup handlers remain. */\n+void \n+__unwinding_cleanup ()\n {\n-  struct eh_context *eh = (*get_eh_context) ();\n-  void *saved_pc, *pc, *handler;\n-  frame_state ustruct, ustruct2;\n-  frame_state *udata = &ustruct;\n-  frame_state *sub_udata = &ustruct2;\n-  frame_state my_ustruct, *my_udata = &my_ustruct;\n-  long args_size;\n-  int new_exception_model;\n-\n-  /* This is required for C++ semantics.  We must call terminate if we\n-     try and rethrow an exception, when there is no exception currently\n-     active.  */\n-  if (! eh->info)\n-    __terminate ();\n-    \n-  /* Start at our stack frame.  */\n-label:\n-  udata = __frame_state_for (&&label, udata);\n-  if (! udata)\n-    __terminate ();\n-\n-  /* We need to get the value from the CFA register. */\n-  udata->cfa = __builtin_dwarf_cfa ();\n-\n-  memcpy (my_udata, udata, sizeof (*udata));\n+}\n \n-  /* Do any necessary initialization to access arbitrary stack frames.\n-     On the SPARC, this means flushing the register windows.  */\n-  __builtin_unwind_init ();\n+/* throw_helper performs some of the common grunt work for a throw. This\n+   routine is called by throw and rethrows. This is pretty much split \n+   out from the old __throw routine. An addition has been added which allows\n+   for a dummy call to a routine __unwinding_cleanup() when there are nothing\n+   but cleanups remaining. This allows a debugger to examine the state\n+   at which the throw was executed, before any cleanups, rather than\n+   at the terminate point after the stack has been unwound. */\n \n-  /* Now reset pc to the right throw point.  */\n-  pc = __builtin_extract_return_addr (__builtin_return_address (0)) - 1;\n-  saved_pc = pc;\n-\n-  handler = 0;\n+static void *\n+throw_helper (eh, pc, my_udata, udata_p)\n+     struct eh_context *eh;\n+     void *pc;\n+     frame_state *my_udata;\n+     frame_state **udata_p;\n+{\n+  frame_state *udata = *udata_p;\n+  frame_state ustruct;\n+  frame_state *sub_udata = &ustruct;\n+  void *saved_pc = pc;\n+  void *handler;\n+  void *handler_p;\n+  void *pc_p;\n+  frame_state saved_ustruct;\n+  int new_eh_model;\n+  int cleanup = 0;\n+  int only_cleanup = 0;\n+  int rethrow = 0;\n+  int saved_state = 0;\n+  __eh_info *eh_info = (__eh_info *)eh->info;\n+\n+  /* Do we find a handler based on a re-throw PC? */\n+  if (eh->table_index != (void *) 0)\n+    rethrow = 1;\n+\n+  handler = (void *) 0;\n   for (;;)\n     { \n       frame_state *p = udata;\n@@ -3702,32 +3732,64 @@ __throw ()\n \tbreak;\n \n       if (udata->eh_ptr == NULL)\n-        new_exception_model = 0;\n+        new_eh_model = 0;\n       else\n-        new_exception_model = (((exception_descriptor *)(udata->eh_ptr))->\n+        new_eh_model = (((exception_descriptor *)(udata->eh_ptr))->\n                                           runtime_id_field == NEW_EH_RUNTIME);\n \n-      if (new_exception_model)\n-        handler = find_exception_handler (pc, udata->eh_ptr, eh->info);\n+      if (rethrow) \n+        {\n+          rethrow = 0;\n+          handler = find_exception_handler (eh->table_index, udata->eh_ptr, \n+                                          eh_info, 1, &cleanup);\n+          eh->table_index = (void *)0;\n+        }\n       else\n-        handler = old_find_exception_handler (pc, udata->eh_ptr);\n-\n-      /* If we found one, we can stop searching.  */\n+        if (new_eh_model)\n+          handler = find_exception_handler (pc, udata->eh_ptr, eh_info, \n+                                            0, &cleanup);\n+        else\n+          handler = old_find_exception_handler (pc, udata->eh_ptr);\n+\n+      /* If we found one, we can stop searching, if its not a cleanup. \n+         for cleanups, we save the state, and keep looking. This allows\n+         us to call a debug hook if there are nothing but cleanups left. */\n       if (handler)\n-\t{\n-\t  args_size = udata->args_size;\n-\t  break;\n-\t}\n+\tif (cleanup)\n+\t  {\n+\t    if (!saved_state)\n+\t      {\n+\t\tsaved_ustruct = *udata;\n+\t\thandler_p = handler;\n+\t\tpc_p = pc;\n+\t\tsaved_state = 1;\n+\t\tonly_cleanup = 1;\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    only_cleanup = 0;\n+\t    break;\n+\t  }\n \n       /* Otherwise, we continue searching.  We subtract 1 from PC to avoid\n \t hitting the beginning of the next region.  */\n       pc = get_return_addr (udata, sub_udata) - 1;\n     }\n \n+  if (saved_state) \n+    {\n+      udata = &saved_ustruct;\n+      handler = handler_p;\n+      pc = pc_p;\n+      if (only_cleanup)\n+        __unwinding_cleanup ();\n+    }\n+\n   /* If we haven't found a handler by now, this is an unhandled\n      exception.  */\n-  if (! handler)\n-    __terminate ();\n+  if (! handler) \n+    __terminate();\n \n   eh->handler_label = handler;\n \n@@ -3781,6 +3843,114 @@ __throw ()\n \t    copy_reg (i, udata, my_udata);\n \t}\n     }\n+  /* udata now refers to the frame called by the handler frame.  */\n+\n+  *udata_p = udata;\n+  return handler;\n+}\n+\n+\n+/* We first search for an exception handler, and if we don't find\n+   it, we call __terminate on the current stack frame so that we may\n+   use the debugger to walk the stack and understand why no handler\n+   was found.\n+\n+   If we find one, then we unwind the frames down to the one that\n+   has the handler and transfer control into the handler.  */\n+\n+/*extern void __throw(void) __attribute__ ((__noreturn__));*/\n+\n+void\n+__throw ()\n+{\n+  struct eh_context *eh = (*get_eh_context) ();\n+  void *pc, *handler;\n+  frame_state ustruct;\n+  frame_state *udata = &ustruct;\n+  frame_state my_ustruct, *my_udata = &my_ustruct;\n+\n+  /* This is required for C++ semantics.  We must call terminate if we\n+     try and rethrow an exception, when there is no exception currently\n+     active.  */\n+  if (! eh->info)\n+    __terminate ();\n+    \n+  /* Start at our stack frame.  */\n+label:\n+  udata = __frame_state_for (&&label, udata);\n+  if (! udata)\n+    __terminate ();\n+\n+  /* We need to get the value from the CFA register. */\n+  udata->cfa = __builtin_dwarf_cfa ();\n+\n+  memcpy (my_udata, udata, sizeof (*udata));\n+\n+  /* Do any necessary initialization to access arbitrary stack frames.\n+     On the SPARC, this means flushing the register windows.  */\n+  __builtin_unwind_init ();\n+\n+  /* Now reset pc to the right throw point.  */\n+  pc = __builtin_extract_return_addr (__builtin_return_address (0)) - 1;\n+\n+  handler = throw_helper (eh, pc, my_udata, &udata);\n+\n+  /* Now go!  */\n+\n+  __builtin_eh_return ((void *)eh,\n+#ifdef STACK_GROWS_DOWNWARD\n+\t\t       udata->cfa - my_udata->cfa,\n+#else\n+\t\t       my_udata->cfa - udata->cfa,\n+#endif\n+\t\t       handler);\n+\n+  /* Epilogue:  restore the handler frame's register values and return\n+     to the stub.  */\n+}\n+\n+/*extern void __rethrow(void *) __attribute__ ((__noreturn__));*/\n+\n+void\n+__rethrow (index)\n+     void *index;\n+{\n+  struct eh_context *eh = (*get_eh_context) ();\n+  void *pc, *handler;\n+  frame_state ustruct;\n+  frame_state *udata = &ustruct;\n+  frame_state my_ustruct, *my_udata = &my_ustruct;\n+\n+  /* This is required for C++ semantics.  We must call terminate if we\n+     try and rethrow an exception, when there is no exception currently\n+     active.  */\n+  if (! eh->info)\n+    __terminate ();\n+\n+  /* This is the table index we want to rethrow from. The value of\n+     the END_REGION label is used for the PC of the throw, and the\n+     search begins with the next table entry. */\n+  eh->table_index = index;\n+    \n+  /* Start at our stack frame.  */\n+label:\n+  udata = __frame_state_for (&&label, udata);\n+  if (! udata)\n+    __terminate ();\n+\n+  /* We need to get the value from the CFA register. */\n+  udata->cfa = __builtin_dwarf_cfa ();\n+\n+  memcpy (my_udata, udata, sizeof (*udata));\n+\n+  /* Do any necessary initialization to access arbitrary stack frames.\n+     On the SPARC, this means flushing the register windows.  */\n+  __builtin_unwind_init ();\n+\n+  /* Now reset pc to the right throw point.  */\n+  pc = __builtin_extract_return_addr (__builtin_return_address (0)) - 1;\n+\n+  handler = throw_helper (eh, pc, my_udata, &udata);\n \n   /* Now go!  */\n "}, {"sha": "eb5f72a94c4701f344a7edf94bcb6155e8ee77a2", "filename": "gcc/optabs.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cfb550ab17484da95c0a3e94773fa42dccd27c/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cfb550ab17484da95c0a3e94773fa42dccd27c/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=e6cfb550ab17484da95c0a3e94773fa42dccd27c", "patch": "@@ -119,6 +119,7 @@ rtx memset_libfunc;\n rtx bzero_libfunc;\n \n rtx throw_libfunc;\n+rtx rethrow_libfunc;\n rtx sjthrow_libfunc;\n rtx sjpopnthrow_libfunc;\n rtx terminate_libfunc;\n@@ -4294,6 +4295,7 @@ init_optabs ()\n   bzero_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"bzero\");\n \n   throw_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__throw\");\n+  rethrow_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__rethrow\");\n   sjthrow_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__sjthrow\");\n   sjpopnthrow_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__sjpopnthrow\");\n   terminate_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__terminate\");"}, {"sha": "c82696259377ef7e40e245e8048bd595c150b1fe", "filename": "gcc/rtl.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cfb550ab17484da95c0a3e94773fa42dccd27c/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cfb550ab17484da95c0a3e94773fa42dccd27c/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=e6cfb550ab17484da95c0a3e94773fa42dccd27c", "patch": "@@ -193,7 +193,8 @@ char *reg_note_name[] = { \"\", \"REG_DEAD\", \"REG_INC\", \"REG_EQUIV\", \"REG_WAS_0\",\n \t\t\t  \"REG_DEP_ANTI\", \"REG_DEP_OUTPUT\", \"REG_BR_PROB\",\n \t\t\t  \"REG_EXEC_COUNT\", \"REG_NOALIAS\", \"REG_SAVE_AREA\",\n \t\t\t  \"REG_BR_PRED\", \"REG_EH_CONTEXT\",\n-\t\t\t  \"REG_FRAME_RELATED_EXPR\" };\n+\t\t\t  \"REG_FRAME_RELATED_EXPR\", \"REG_EH_REGION\",\n+\t\t\t  \"REG_EH_RETHROW\" };\n \n static void dump_and_abort\tPROTO((int, int, FILE *)) ATTRIBUTE_NORETURN;\n static void read_name\t\tPROTO((char *, FILE *));"}, {"sha": "940de7305e1a63dbb7bd798ff1ab501c6e229fd1", "filename": "gcc/rtl.h", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cfb550ab17484da95c0a3e94773fa42dccd27c/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cfb550ab17484da95c0a3e94773fa42dccd27c/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=e6cfb550ab17484da95c0a3e94773fa42dccd27c", "patch": "@@ -340,6 +340,14 @@ typedef struct rtvec_def{\n      REG_FRAME_RELATED_EXPR is attached to insns that are RTX_FRAME_RELATED_P,\n    but are too complex for DWARF to interpret what they imply.  The attached\n    rtx is used instead of intuition.  */\n+/*   REG_EH_REGION is used to indicate what exception region an INSN\n+   belongs in. This can be used to indicate what region a call may throw\n+   to. a REGION of 0 indicates that a call cannot throw at all.\n+     REG_EH_RETHROW is used to indicate what that a call is actually a\n+   call to rethrow, and specifies which region the rethrow is targetting.\n+   This provides a way to generate the non standard flow edges required \n+   for a rethrow. */\n+   \n \n #define REG_NOTES(INSN)\t((INSN)->fld[6].rtx)\n \n@@ -353,7 +361,8 @@ enum reg_note { REG_DEAD = 1, REG_INC = 2, REG_EQUIV = 3, REG_WAS_0 = 4,\n \t\tREG_DEP_ANTI = 14, REG_DEP_OUTPUT = 15, REG_BR_PROB = 16,\n \t\tREG_EXEC_COUNT = 17, REG_NOALIAS = 18, REG_SAVE_AREA = 19,\n \t\tREG_BR_PRED = 20, REG_EH_CONTEXT = 21,\n-\t\tREG_FRAME_RELATED_EXPR = 22 };\n+\t\tREG_FRAME_RELATED_EXPR = 22, REG_EH_REGION = 23,\n+\t\tREG_EH_RETHROW = 24 };\n /* The base value for branch probability notes.  */\n #define REG_BR_PROB_BASE  10000\n \n@@ -617,6 +626,10 @@ extern char *note_insn_name[];\n /* Flag in a SYMBOL_REF for machine-specific purposes.  */\n #define SYMBOL_REF_FLAG(RTX) ((RTX)->volatil)\n \n+/* 1 in a SYMBOL_REF if it represents a symbol which might have to change\n+   if its inlined or unrolled. */\n+#define SYMBOL_REF_NEED_ADJUST(RTX)  ((RTX)->in_struct)\n+\n /* 1 means a SYMBOL_REF has been the library function in emit_library_call.  */\n #define SYMBOL_REF_USED(RTX) ((RTX)->used)\n "}]}