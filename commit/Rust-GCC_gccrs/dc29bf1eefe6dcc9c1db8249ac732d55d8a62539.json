{"sha": "dc29bf1eefe6dcc9c1db8249ac732d55d8a62539", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGMyOWJmMWVlZmU2ZGNjOWMxZGI4MjQ5YWM3MzJkNTVkOGE2MjUzOQ==", "commit": {"author": {"name": "Dodji Seketeli", "email": "dodji@redhat.com", "date": "2012-11-12T15:52:56Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2012-11-12T15:52:56Z"}, "message": "Make build_check_stmt accept an SSA_NAME for its base\n\nThis patch makes build_check_stmt accept its memory access parameter\nto be an SSA name.  This is useful for a subsequent patch that will\nre-use.\n\nTested by running cc1 -fasan on the program below with and without the\npatch and inspecting the gimple output to see that there is no change.\n\nvoid\nfoo ()\n{\n  char foo[1] = {0};\n\n  foo[0] = 1;\n}\n\ngcc/\n\t* asan.c (build_check_stmt): Accept the memory access to be\n\trepresented by an SSA_NAME.\n\nFrom-SVN: r193438", "tree": {"sha": "180ca989839a55574caee4be09f93e799a6249f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/180ca989839a55574caee4be09f93e799a6249f4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc29bf1eefe6dcc9c1db8249ac732d55d8a62539", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc29bf1eefe6dcc9c1db8249ac732d55d8a62539", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc29bf1eefe6dcc9c1db8249ac732d55d8a62539", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc29bf1eefe6dcc9c1db8249ac732d55d8a62539/comments", "author": null, "committer": null, "parents": [{"sha": "8240018b0c5da12a6e6df5689055983e76768151", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8240018b0c5da12a6e6df5689055983e76768151", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8240018b0c5da12a6e6df5689055983e76768151"}], "stats": {"total": 41, "additions": 28, "deletions": 13}, "files": [{"sha": "7fec865b7176244521e1da84755103ed3baace9d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc29bf1eefe6dcc9c1db8249ac732d55d8a62539/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc29bf1eefe6dcc9c1db8249ac732d55d8a62539/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dc29bf1eefe6dcc9c1db8249ac732d55d8a62539", "patch": "@@ -1,3 +1,8 @@\n+2012-11-12  Dodji Seketeli  <dodji@redhat.com>\n+\n+\t* asan.c (build_check_stmt): Accept the memory access to be\n+\trepresented by an SSA_NAME.\n+\n 2012-11-12  Jakub Jelinek  <jakub@redhat.com>\n \t    Wei Mi <wmi@google.com>\n "}, {"sha": "da5f22bf6fba0d11be7015a95dfbc3271660f7f9", "filename": "gcc/asan.c", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc29bf1eefe6dcc9c1db8249ac732d55d8a62539/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc29bf1eefe6dcc9c1db8249ac732d55d8a62539/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=dc29bf1eefe6dcc9c1db8249ac732d55d8a62539", "patch": "@@ -520,16 +520,18 @@ asan_init_func (void)\n #define PROB_VERY_UNLIKELY\t(REG_BR_PROB_BASE / 2000 - 1)\n #define PROB_ALWAYS\t\t(REG_BR_PROB_BASE)\n \n-/* Instrument the memory access instruction BASE.\n-   Insert new statements before ITER.\n-   LOCATION is source code location.\n-   IS_STORE is either 1 (for a store) or 0 (for a load).\n+/* Instrument the memory access instruction BASE.  Insert new\n+   statements before ITER.\n+\n+   Note that the memory access represented by BASE can be either an\n+   SSA_NAME, or a non-SSA expression.  LOCATION is the source code\n+   location.  IS_STORE is TRUE for a store, FALSE for a load.\n    SIZE_IN_BYTES is one of 1, 2, 4, 8, 16.  */\n \n static void\n-build_check_stmt (tree base,\n-                  gimple_stmt_iterator *iter,\n-                  location_t location, bool is_store, int size_in_bytes)\n+build_check_stmt (tree base, gimple_stmt_iterator *iter,\n+                  location_t location, bool is_store,\n+\t\t  int size_in_bytes)\n {\n   gimple_stmt_iterator gsi;\n   basic_block cond_bb, then_bb, else_bb;\n@@ -540,6 +542,7 @@ build_check_stmt (tree base,\n   tree shadow_type = TREE_TYPE (shadow_ptr_type);\n   tree uintptr_type\n     = build_nonstandard_integer_type (TYPE_PRECISION (TREE_TYPE (base)), 1);\n+  tree base_ssa = base;\n \n   /* We first need to split the current basic block, and start altering\n      the CFG.  This allows us to insert the statements we're about to\n@@ -585,15 +588,22 @@ build_check_stmt (tree base,\n   base = unshare_expr (base);\n \n   gsi = gsi_last_bb (cond_bb);\n-  g = gimple_build_assign_with_ops (TREE_CODE (base),\n-\t\t\t\t    make_ssa_name (TREE_TYPE (base), NULL),\n-\t\t\t\t    base, NULL_TREE);\n-  gimple_set_location (g, location);\n-  gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n+\n+  /* BASE can already be an SSA_NAME; in that case, do not create a\n+     new SSA_NAME for it.  */\n+  if (TREE_CODE (base) != SSA_NAME)\n+    {\n+      g = gimple_build_assign_with_ops (TREE_CODE (base),\n+\t\t\t\t\tmake_ssa_name (TREE_TYPE (base), NULL),\n+\t\t\t\t\tbase, NULL_TREE);\n+      gimple_set_location (g, location);\n+      gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n+      base_ssa = gimple_assign_lhs (g);\n+    }\n \n   g = gimple_build_assign_with_ops (NOP_EXPR,\n \t\t\t\t    make_ssa_name (uintptr_type, NULL),\n-\t\t\t\t    gimple_assign_lhs (g), NULL_TREE);\n+\t\t\t\t    base_ssa, NULL_TREE);\n   gimple_set_location (g, location);\n   gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n   base_addr = gimple_assign_lhs (g);"}]}