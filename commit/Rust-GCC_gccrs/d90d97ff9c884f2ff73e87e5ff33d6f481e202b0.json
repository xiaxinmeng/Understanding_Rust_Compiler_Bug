{"sha": "d90d97ff9c884f2ff73e87e5ff33d6f481e202b0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDkwZDk3ZmY5Yzg4NGYyZmY3M2U4N2U1ZmYzM2Q2ZjQ4MWUyMDJiMA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely.gcc@gmail.com", "date": "2010-01-12T00:53:30Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2010-01-12T00:53:30Z"}, "message": "re PR libstdc++/24803 ([c++0x] reference_wrapper and pointers to member functions)\n\n2010-01-12  Jonathan Wakely  <jwakely.gcc@gmail.com>\n\n\tPR libstdc++/24803\n\tPR libstdc++/35569\n\tPR libstdc++/42593\n\t* include/std/functional (bind): Forward rvalues and detect correct\n\tresult type of bound function object.\n\t* include/std/mutex (call_once): Specify bind result type.\n\t* testsuite/20_util/reference_wrapper/invoke.cc: Remove invalid tests.\n\t* testsuite/20_util/reference_wrapper/24803.cc: Remove invalid tests\n\tand enable FIXME tests.\n\t* testsuite/20_util/bind/35569.cc: New.\n\t* testsuite/20_util/bind/ref2.cc: New.\n\t* testsuite/20_util/bind/38889.cc: New.\n\t* testsuite/20_util/bind/ref_neg.cc: New.\n\t* testsuite/20_util/bind/42593.cc: New.\n\nFrom-SVN: r155826", "tree": {"sha": "1748edcc59520249e1129c28e281158433bd118a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1748edcc59520249e1129c28e281158433bd118a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d90d97ff9c884f2ff73e87e5ff33d6f481e202b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d90d97ff9c884f2ff73e87e5ff33d6f481e202b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d90d97ff9c884f2ff73e87e5ff33d6f481e202b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d90d97ff9c884f2ff73e87e5ff33d6f481e202b0/comments", "author": null, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "31380bc4c511f38b514cf51b954e3bbd766359c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31380bc4c511f38b514cf51b954e3bbd766359c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31380bc4c511f38b514cf51b954e3bbd766359c8"}], "stats": {"total": 523, "additions": 355, "deletions": 168}, "files": [{"sha": "3601ad61af16da35493f72d94e0e99b98d7bbaeb", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d90d97ff9c884f2ff73e87e5ff33d6f481e202b0/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d90d97ff9c884f2ff73e87e5ff33d6f481e202b0/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=d90d97ff9c884f2ff73e87e5ff33d6f481e202b0", "patch": "@@ -1,3 +1,20 @@\n+2010-01-12  Jonathan Wakely  <jwakely.gcc@gmail.com>\n+\n+\tPR libstdc++/24803\n+\tPR libstdc++/35569\n+\tPR libstdc++/42593\n+\t* include/std/functional (bind): Forward rvalues and detect correct\n+\tresult type of bound function object.\n+\t* include/std/mutex (call_once): Specify bind result type.\n+\t* testsuite/20_util/reference_wrapper/invoke.cc: Remove invalid tests.\n+\t* testsuite/20_util/reference_wrapper/24803.cc: Remove invalid tests\n+\tand enable FIXME tests.\n+\t* testsuite/20_util/bind/35569.cc: New.\n+\t* testsuite/20_util/bind/ref2.cc: New.\n+\t* testsuite/20_util/bind/38889.cc: New.\n+\t* testsuite/20_util/bind/ref_neg.cc: New.\n+\t* testsuite/20_util/bind/42593.cc: New.\n+\n 2010-01-11  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* include/parallel/base.h (decode2): Rename to __decode2."}, {"sha": "34b85ab95971a44124f3511cb2c3f7d05c9a66b2", "filename": "libstdc++-v3/include/std/functional", "status": "modified", "additions": 119, "deletions": 134, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d90d97ff9c884f2ff73e87e5ff33d6f481e202b0/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d90d97ff9c884f2ff73e87e5ff33d6f481e202b0/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional?ref=d90d97ff9c884f2ff73e87e5ff33d6f481e202b0", "patch": "@@ -1,6 +1,6 @@\n // <functional> -*- C++ -*-\n \n-// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009\n+// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009, 2010\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -177,61 +177,12 @@ namespace std\n   template<typename _Signature>\n     class result_of;\n \n-  /**\n-   *  Actual implementation of result_of. When _Has_result_type is\n-   *  true, gets its result from _Weak_result_type. Otherwise, uses\n-   *  the function object's member template result to extract the\n-   *  result type.\n-  */\n-  template<bool _Has_result_type, typename _Signature>\n-    struct _Result_of_impl;\n-\n-  // Handle member data pointers using _Mem_fn's logic\n-  template<typename _Res, typename _Class, typename _T1>\n-    struct _Result_of_impl<false, _Res _Class::*(_T1)>\n-    {\n-      typedef typename _Mem_fn<_Res _Class::*>\n-                ::template _Result_type<_T1>::type type;\n-    };\n-\n-  /**\n-   * Determine whether we can determine a result type from @c Functor \n-   * alone.\n-   */ \n-  template<typename _Functor, typename... _ArgTypes>\n-    class result_of<_Functor(_ArgTypes...)>\n-    : public _Result_of_impl<\n-               _Has_result_type<_Weak_result_type<_Functor> >::value,\n-               _Functor(_ArgTypes...)>\n-    {\n-    };\n-\n-  /// We already know the result type for @c Functor; use it.\n   template<typename _Functor, typename... _ArgTypes>\n-    struct _Result_of_impl<true, _Functor(_ArgTypes...)>\n+    struct result_of<_Functor(_ArgTypes...)>\n     {\n-      typedef typename _Weak_result_type<_Functor>::result_type type;\n-    };\n-\n-  /**\n-   * We need to compute the result type for this invocation the hard \n-   * way.\n-   */\n-  template<typename _Functor, typename... _ArgTypes>\n-    struct _Result_of_impl<false, _Functor(_ArgTypes...)>\n-    {\n-      typedef typename _Functor\n-                ::template result<_Functor(_ArgTypes...)>::type type;\n-    };\n-\n-  /**\n-   * It is unsafe to access ::result when there are zero arguments, so we \n-   * return @c void instead.\n-   */\n-  template<typename _Functor>\n-    struct _Result_of_impl<false, _Functor()>\n-    {\n-      typedef void type;\n+      typedef\n+        decltype( std::declval<_Functor>()(std::declval<_ArgTypes>()...) )\n+        type;\n     };\n \n   /// Determines if the type _Tp derives from unary_function.\n@@ -291,22 +242,9 @@ namespace std\n               && !is_function<typename remove_pointer<_Functor>::type>::value),\n              typename result_of<_Functor(_Args...)>::type\n            >::__type\n-    __invoke(_Functor& __f, _Args&... __args)\n-    {\n-      return __f(__args...);\n-    }\n-\n-  template<typename _Functor, typename... _Args>\n-    inline\n-    typename __gnu_cxx::__enable_if<\n-             (is_member_pointer<_Functor>::value\n-              && !is_function<_Functor>::value\n-              && !is_function<typename remove_pointer<_Functor>::type>::value),\n-             typename result_of<_Functor(_Args...)>::type\n-           >::__type\n-    __invoke(_Functor& __f, _Args&... __args)\n+    __invoke(_Functor& __f, _Args&&... __args)\n     {\n-      return mem_fn(__f)(__args...);\n+      return __f(std::forward<_Args>(__args)...);\n     }\n \n   // To pick up function references (that will become function pointers)\n@@ -317,9 +255,9 @@ namespace std\n               && is_function<typename remove_pointer<_Functor>::type>::value),\n              typename result_of<_Functor(_Args...)>::type\n            >::__type\n-    __invoke(_Functor __f, _Args&... __args)\n+    __invoke(_Functor __f, _Args&&... __args)\n     {\n-      return __f(__args...);\n+      return __f(std::forward<_Args>(__args)...);\n     }\n \n   /**\n@@ -464,10 +402,11 @@ namespace std\n     public:\n       typedef _Tp type;\n \n-      explicit\n       reference_wrapper(_Tp& __indata): _M_data(&__indata)\n       { }\n \n+      reference_wrapper(_Tp&&) = delete;\n+\n       reference_wrapper(const reference_wrapper<_Tp>& __inref):\n       _M_data(__inref._M_data)\n       { }\n@@ -488,9 +427,9 @@ namespace std\n \n       template<typename... _Args>\n         typename result_of<_M_func_type(_Args...)>::type\n-        operator()(_Args&... __args) const\n+        operator()(_Args&&... __args) const\n         {\n-\t  return __invoke(get(), __args...);\n+\t  return __invoke(get(), std::forward<_Args>(__args)...);\n \t}\n     };\n \n@@ -1023,7 +962,7 @@ namespace std\n       template<typename _CVArg, typename... _Args>\n         typename result_of<_CVArg(_Args...)>::type\n         operator()(_CVArg& __arg,\n-\t\t   const tuple<_Args...>& __tuple) const volatile\n+\t\t   tuple<_Args...>& __tuple) const volatile\n         {\n \t  // Construct an index tuple and forward to __call\n \t  typedef typename _Build_index_tuple<sizeof...(_Args)>::__type\n@@ -1036,10 +975,10 @@ namespace std\n       // of the arguments in the tuple. \n       template<typename _CVArg, typename... _Args, int... _Indexes>\n         typename result_of<_CVArg(_Args...)>::type\n-        __call(_CVArg& __arg, const tuple<_Args...>& __tuple,\n+        __call(_CVArg& __arg, tuple<_Args...>& __tuple,\n \t       const _Index_tuple<_Indexes...>&) const volatile\n         {\n-\t  return __arg(get<_Indexes>(__tuple)...);\n+\t  return __arg(std::forward<_Args>(get<_Indexes>(__tuple))...);\n \t}\n     };\n \n@@ -1065,14 +1004,15 @@ namespace std\n \t    __base_type;\n \n \tpublic:\n-\t  typedef typename add_lvalue_reference<__base_type>::type type;\n+\t  typedef typename add_rvalue_reference<__base_type>::type type;\n \t};\n \n       template<typename _Tuple>\n         typename result<_Mu(_Arg, _Tuple)>::type\n-        operator()(const volatile _Arg&, const _Tuple& __tuple) const volatile\n+        operator()(const volatile _Arg&, _Tuple& __tuple) const volatile\n         {\n-\t  return ::std::get<(is_placeholder<_Arg>::value - 1)>(__tuple);\n+\t  return std::forward<typename result<_Mu(_Arg, _Tuple)>::type>(\n+              ::std::get<(is_placeholder<_Arg>::value - 1)>(__tuple));\n \t}\n     };\n \n@@ -1095,9 +1035,9 @@ namespace std\n \n       // Pick up the cv-qualifiers of the argument\n       template<typename _CVArg, typename _Tuple>\n-        _CVArg&\n-        operator()(_CVArg& __arg, const _Tuple&) const volatile\n-        { return __arg; }\n+        _CVArg&&\n+        operator()(_CVArg&& __arg, const _Tuple&) const volatile\n+        { return std::forward<_CVArg>(__arg); }\n     };\n \n   /**\n@@ -1156,106 +1096,139 @@ namespace std\n       tuple<_Bound_args...> _M_bound_args;\n \n       // Call unqualified\n-      template<typename... _Args, int... _Indexes>\n+      template<typename... _Args, int... _Indexes, typename _Sfinae\n+        = decltype( std::declval<_Functor>()(\n+              _Mu<_Bound_args>()( std::declval<_Bound_args&>(),\n+                                  std::declval<tuple<_Args...>&>() )... ) )>\n         typename result_of<\n                    _Functor(typename result_of<_Mu<_Bound_args> \n-                            (_Bound_args, tuple<_Args...>)>::type...)\n+                            (_Bound_args&, tuple<_Args...>&)>::type...)\n                  >::type\n-        __call(const tuple<_Args...>& __args, _Index_tuple<_Indexes...>)\n+        __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>)\n         {\n           return _M_f(_Mu<_Bound_args>()\n                       (get<_Indexes>(_M_bound_args), __args)...);\n         }\n \n       // Call as const\n-      template<typename... _Args, int... _Indexes>\n+      template<typename... _Args, int... _Indexes, typename _Sfinae\n+        = decltype( std::declval<const _Functor>()(\n+              _Mu<_Bound_args>()( std::declval<const _Bound_args&>(),\n+                                  std::declval<tuple<_Args...>&>() )... ) )>\n         typename result_of<\n                    const _Functor(typename result_of<_Mu<_Bound_args> \n-                                    (const _Bound_args, tuple<_Args...>)\n+                                    (const _Bound_args&, tuple<_Args...>&)\n                                   >::type...)>::type\n-        __call(const tuple<_Args...>& __args, _Index_tuple<_Indexes...>) const\n+        __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>) const\n         {\n           return _M_f(_Mu<_Bound_args>()\n                       (get<_Indexes>(_M_bound_args), __args)...);\n         }\n \n+#if 0\n       // Call as volatile\n-      template<typename... _Args, int... _Indexes>\n+      template<typename... _Args, int... _Indexes, typename _Sfinae\n+        = decltype( std::declval<volatile _Functor>()(\n+              _Mu<_Bound_args>()( std::declval<volatile _Bound_args&>(),\n+                                  std::declval<tuple<_Args...>&>() )... ) )>\n         typename result_of<\n                    volatile _Functor(typename result_of<_Mu<_Bound_args> \n-                                    (volatile _Bound_args, tuple<_Args...>)\n+                                    (volatile _Bound_args&, tuple<_Args...>&)\n                                   >::type...)>::type\n-        __call(const tuple<_Args...>& __args, \n+        __call(tuple<_Args...>&& __args, \n                _Index_tuple<_Indexes...>) volatile\n         {\n           return _M_f(_Mu<_Bound_args>()\n                       (get<_Indexes>(_M_bound_args), __args)...);\n         }\n \n       // Call as const volatile\n-      template<typename... _Args, int... _Indexes>\n+      template<typename... _Args, int... _Indexes, typename _Sfinae\n+        = decltype( std::declval<const volatile _Functor>()(\n+              _Mu<_Bound_args>()( std::declval<const volatile _Bound_args&>(),\n+                                  std::declval<tuple<_Args...>&>() )... ) )>\n         typename result_of<\n                    const volatile _Functor(typename result_of<_Mu<_Bound_args> \n-                                    (const volatile _Bound_args, \n-                                     tuple<_Args...>)\n+                                    (const volatile _Bound_args&, \n+                                     tuple<_Args...>&)\n                                   >::type...)>::type\n-        __call(const tuple<_Args...>& __args, \n+        __call(tuple<_Args...>&& __args, \n                _Index_tuple<_Indexes...>) const volatile\n         {\n           return _M_f(_Mu<_Bound_args>()\n                       (get<_Indexes>(_M_bound_args), __args)...);\n         }\n+#endif\n \n      public:\n       explicit _Bind(_Functor __f, _Bound_args... __bound_args)\n-        : _M_f(__f), _M_bound_args(__bound_args...) { }\n+      : _M_f(std::forward<_Functor>(__f)),\n+      _M_bound_args(std::forward<_Bound_args>(__bound_args)...)\n+      { }\n \n       // Call unqualified\n-      template<typename... _Args>\n+      template<typename... _Args, typename _Sfinae\n+        = decltype( std::declval<_Functor>()(\n+              _Mu<_Bound_args>()( std::declval<_Bound_args&>(),\n+                                  std::declval<tuple<_Args...>&>() )... ) )>\n         typename result_of<\n                    _Functor(typename result_of<_Mu<_Bound_args> \n-                            (_Bound_args, tuple<_Args...>)>::type...)\n+                            (_Bound_args&, tuple<_Args...>&)>::type...)\n                  >::type\n-        operator()(_Args&... __args)\n+        operator()(_Args&&... __args)\n         {\n-          return this->__call(tie(__args...), _Bound_indexes());\n+          return this->__call(tuple<_Args...>(std::forward<_Args>(__args)...),\n+                              _Bound_indexes());\n         }\n \n       // Call as const\n-      template<typename... _Args>\n+      template<typename... _Args, typename _Sfinae\n+        = decltype( std::declval<const _Functor>()(\n+              _Mu<_Bound_args>()( std::declval<const _Bound_args&>(),\n+                                  std::declval<tuple<_Args...>&>() )... ) )>\n         typename result_of<\n                    const _Functor(typename result_of<_Mu<_Bound_args> \n-                            (const _Bound_args, tuple<_Args...>)>::type...)\n+                            (const _Bound_args&, tuple<_Args...>&)>::type...)\n                  >::type\n-        operator()(_Args&... __args) const\n+        operator()(_Args&&... __args) const\n         {\n-          return this->__call(tie(__args...), _Bound_indexes());\n+          return this->__call(tuple<_Args...>(std::forward<_Args>(__args)...),\n+                              _Bound_indexes());\n         }\n \n-\n+#if 0\n       // Call as volatile\n-      template<typename... _Args>\n+      template<typename... _Args, typename _Sfinae\n+        = decltype( std::declval<volatile _Functor>()(\n+              _Mu<_Bound_args>()( std::declval<volatile _Bound_args&>(),\n+                                  std::declval<tuple<_Args...>&>() )... ) )>\n         typename result_of<\n                    volatile _Functor(typename result_of<_Mu<_Bound_args> \n-                            (volatile _Bound_args, tuple<_Args...>)>::type...)\n+                            (volatile _Bound_args&, tuple<_Args...>&)>::type...)\n                  >::type\n-        operator()(_Args&... __args) volatile\n+        operator()(_Args&&... __args) volatile\n         {\n-          return this->__call(tie(__args...), _Bound_indexes());\n+          return this->__call(tuple<_Args...>(std::forward<_Args>(__args)...),\n+                              _Bound_indexes());\n         }\n \n \n       // Call as const volatile\n-      template<typename... _Args>\n+      template<typename... _Args, typename _Sfinae\n+        = decltype( std::declval<const volatile _Functor>()(\n+              _Mu<_Bound_args>()( std::declval<const volatile _Bound_args&>(),\n+                                  std::declval<tuple<_Args...>&>() )... ) )>\n         typename result_of<\n                    const volatile _Functor(typename result_of<_Mu<_Bound_args> \n-                            (const volatile _Bound_args, \n-                             tuple<_Args...>)>::type...)\n+                            (const volatile _Bound_args&, \n+                             tuple<_Args...>&)>::type...)\n                  >::type\n-        operator()(_Args&... __args) const volatile\n+        operator()(_Args&&... __args) const volatile\n         {\n-          return this->__call(tie(__args...), _Bound_indexes());\n+          return this->__call(tuple<_Args...>(std::forward<_Args>(__args)...),\n+                              _Bound_indexes());\n         }\n+#endif\n     };\n \n   /// Type of the function object returned from bind<R>().\n@@ -1281,7 +1254,7 @@ namespace std\n       // Call unqualified\n       template<typename _Res, typename... _Args, int... _Indexes>\n         _Result\n-        __call(const tuple<_Args...>& __args, _Index_tuple<_Indexes...>,\n+        __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,\n             typename __disable_if_void<_Res>::type = 0)\n         {\n           return _M_f(_Mu<_Bound_args>()\n@@ -1291,7 +1264,7 @@ namespace std\n       // Call unqualified, return void\n       template<typename _Res, typename... _Args, int... _Indexes>\n         void\n-        __call(const tuple<_Args...>& __args, _Index_tuple<_Indexes...>,\n+        __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,\n             typename __enable_if_void<_Res>::type = 0)\n         {\n           _M_f(_Mu<_Bound_args>()\n@@ -1301,7 +1274,7 @@ namespace std\n       // Call as const\n       template<typename _Res, typename... _Args, int... _Indexes>\n         _Result\n-        __call(const tuple<_Args...>& __args, _Index_tuple<_Indexes...>,\n+        __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,\n             typename __disable_if_void<_Res>::type = 0) const\n         {\n           return _M_f(_Mu<_Bound_args>()\n@@ -1311,7 +1284,7 @@ namespace std\n       // Call as const, return void\n       template<typename _Res, typename... _Args, int... _Indexes>\n         void\n-        __call(const tuple<_Args...>& __args, _Index_tuple<_Indexes...>,\n+        __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,\n             typename __enable_if_void<_Res>::type = 0) const\n         {\n           _M_f(_Mu<_Bound_args>()\n@@ -1321,7 +1294,7 @@ namespace std\n       // Call as volatile\n       template<typename _Res, typename... _Args, int... _Indexes>\n         _Result\n-        __call(const tuple<_Args...>& __args, _Index_tuple<_Indexes...>,\n+        __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,\n             typename __disable_if_void<_Res>::type = 0) volatile\n         {\n           return _M_f(_Mu<_Bound_args>()\n@@ -1331,7 +1304,7 @@ namespace std\n       // Call as volatile, return void\n       template<typename _Res, typename... _Args, int... _Indexes>\n         void\n-        __call(const tuple<_Args...>& __args, _Index_tuple<_Indexes...>,\n+        __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,\n             typename __enable_if_void<_Res>::type = 0) volatile\n         {\n           _M_f(_Mu<_Bound_args>()\n@@ -1341,7 +1314,7 @@ namespace std\n       // Call as const volatile\n       template<typename _Res, typename... _Args, int... _Indexes>\n         _Result\n-        __call(const tuple<_Args...>& __args, _Index_tuple<_Indexes...>,\n+        __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,\n             typename __disable_if_void<_Res>::type = 0) const volatile\n         {\n           return _M_f(_Mu<_Bound_args>()\n@@ -1351,7 +1324,7 @@ namespace std\n       // Call as const volatile, return void\n       template<typename _Res, typename... _Args, int... _Indexes>\n         void\n-        __call(const tuple<_Args...>& __args, \n+        __call(tuple<_Args...>&& __args, \n                _Index_tuple<_Indexes...>,\n             typename __enable_if_void<_Res>::type = 0) const volatile\n         {\n@@ -1364,38 +1337,48 @@ namespace std\n \n       explicit\n       _Bind_result(_Functor __f, _Bound_args... __bound_args)\n-      : _M_f(__f), _M_bound_args(__bound_args...) { }\n+      : _M_f(std::forward<_Functor>(__f)),\n+      _M_bound_args(std::forward<_Bound_args>(__bound_args)...)\n+      { }\n \n       // Call unqualified\n       template<typename... _Args>\n         result_type\n-        operator()(_Args&... __args)\n+        operator()(_Args&&... __args)\n         {\n-          return this->__call<_Result>(tie(__args...), _Bound_indexes());\n+          return this->__call<_Result>(\n+              tuple<_Args...>(std::forward<_Args...>(__args)...),\n+              _Bound_indexes());\n         }\n \n       // Call as const\n       template<typename... _Args>\n         result_type\n-        operator()(_Args&... __args) const\n+        operator()(_Args&&... __args) const\n         {\n-          return this->__call<_Result>(tie(__args...), _Bound_indexes());\n+          return this->__call<_Result>(\n+              tuple<_Args...>(std::forward<_Args...>(__args)...),\n+              _Bound_indexes());\n         }\n \n       // Call as volatile\n       template<typename... _Args>\n         result_type\n-        operator()(_Args&... __args) volatile\n+        operator()(_Args&&... __args) volatile\n         {\n-          return this->__call<_Result>(tie(__args...), _Bound_indexes());\n+          return this->__call<_Result>(\n+              tuple<_Args...>(std::forward<_Args...>(__args)...),\n+              _Bound_indexes());\n         }\n \n       // Call as const volatile\n       template<typename... _Args>\n         result_type\n-        operator()(_Args&... __args) const volatile\n+        operator()(_Args&&... __args) const volatile\n         {\n-          return this->__call<_Result>(tie(__args...), _Bound_indexes());\n+          return this->__call<_Result>(\n+              tuple<_Args...>(std::forward<_Args...>(__args)...),\n+              _Bound_indexes());\n         }\n     };\n \n@@ -1424,7 +1407,8 @@ namespace std\n       typedef _Maybe_wrap_member_pointer<_Functor> __maybe_type;\n       typedef typename __maybe_type::type __functor_type;\n       typedef _Bind<__functor_type(_ArgTypes...)> __result_type;\n-      return __result_type(__maybe_type::__do_wrap(__f), __args...);\n+      return __result_type(__maybe_type::__do_wrap(__f),\n+                           std::forward<_ArgTypes>(__args)...);\n     } \n \n   template<typename _Result, typename _Functor, typename... _ArgTypes>\n@@ -1438,7 +1422,8 @@ namespace std\n       typedef typename __maybe_type::type __functor_type;\n       typedef _Bind_result<_Result, __functor_type(_ArgTypes...)>\n \t__result_type;\n-      return __result_type(__maybe_type::__do_wrap(__f), __args...);\n+      return __result_type(__maybe_type::__do_wrap(__f),\n+                           std::forward<_ArgTypes>(__args)...);\n     }\n \n   /**"}, {"sha": "9b009ecb12becb4d3b937f51b46188ec3f4f21e8", "filename": "libstdc++-v3/include/std/mutex", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d90d97ff9c884f2ff73e87e5ff33d6f481e202b0/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d90d97ff9c884f2ff73e87e5ff33d6f481e202b0/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex?ref=d90d97ff9c884f2ff73e87e5ff33d6f481e202b0", "patch": "@@ -1,6 +1,6 @@\n // <mutex> -*- C++ -*-\n \n-// Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009\n+// Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -722,12 +722,12 @@ namespace std\n     call_once(once_flag& __once, _Callable __f, _Args&&... __args)\n     {\n #ifdef _GLIBCXX_HAVE_TLS\n-      auto __bound_functor = std::bind(__f, __args...);\n+      auto __bound_functor = std::bind<void>(__f, __args...);\n       __once_callable = &__bound_functor;\n       __once_call = &__once_call_impl<decltype(__bound_functor)>;\n #else\n       unique_lock<mutex> __functor_lock(__get_once_mutex());\n-      __once_functor = std::bind(__f, __args...);\n+      __once_functor = std::bind<void>(__f, __args...);\n       __set_once_functor_lock_ptr(&__functor_lock);\n #endif\n "}, {"sha": "8d25f1a8a20f7f772f6f345acc4704a2dde58c54", "filename": "libstdc++-v3/testsuite/20_util/bind/35569.cc", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d90d97ff9c884f2ff73e87e5ff33d6f481e202b0/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2F35569.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d90d97ff9c884f2ff73e87e5ff33d6f481e202b0/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2F35569.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2F35569.cc?ref=d90d97ff9c884f2ff73e87e5ff33d6f481e202b0", "patch": "@@ -0,0 +1,32 @@\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 20.7.11 Function template bind\n+\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+#include <functional>\n+\n+using namespace std;\n+using namespace std::placeholders;\n+\n+void test01()\n+{ \n+  bind(multiplies<int>(),4,_1)(5);\n+}\n+"}, {"sha": "b4f47c6c432e3f9c698379d20a5f492652e7cd78", "filename": "libstdc++-v3/testsuite/20_util/bind/38889.cc", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d90d97ff9c884f2ff73e87e5ff33d6f481e202b0/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2F38889.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d90d97ff9c884f2ff73e87e5ff33d6f481e202b0/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2F38889.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2F38889.cc?ref=d90d97ff9c884f2ff73e87e5ff33d6f481e202b0", "patch": "@@ -0,0 +1,31 @@\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 20.7.11 Function template bind\n+\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+#include <functional>\n+\n+void goo(int);\n+void foo() {\n+    std::bind (goo,1)();\n+    std::bind (goo,std::placeholders::_1)(1);\n+}\n+\n+"}, {"sha": "327d1df545eeedb1783f9f688c85ea69fc64f08c", "filename": "libstdc++-v3/testsuite/20_util/bind/42593.cc", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d90d97ff9c884f2ff73e87e5ff33d6f481e202b0/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2F42593.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d90d97ff9c884f2ff73e87e5ff33d6f481e202b0/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2F42593.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2F42593.cc?ref=d90d97ff9c884f2ff73e87e5ff33d6f481e202b0", "patch": "@@ -0,0 +1,31 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 20.7.11 Function template bind\n+\n+#include <functional>\n+\n+void f( int ) {}\n+\n+void test01()\n+{\n+  std::function< void( int ) > pf = std::bind( &f, std::placeholders::_1 );\n+  pf(1);\n+}\n+"}, {"sha": "bf6456c38b51abe7fcfbd868dc50e0a2b39389a0", "filename": "libstdc++-v3/testsuite/20_util/bind/ref2.cc", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d90d97ff9c884f2ff73e87e5ff33d6f481e202b0/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Fref2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d90d97ff9c884f2ff73e87e5ff33d6f481e202b0/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Fref2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Fref2.cc?ref=d90d97ff9c884f2ff73e87e5ff33d6f481e202b0", "patch": "@@ -0,0 +1,59 @@\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 20.7.11 Function template bind\n+\n+// { dg-options \"-std=gnu++0x\" }\n+\n+#include <functional>\n+#include <testsuite_hooks.h>\n+\n+using namespace std::placeholders;\n+\n+int inc(int& i) { return ++i; }\n+\n+void test01()\n+{\n+  int counter = 0;\n+  std::bind(&inc, _1)(counter);\n+  VERIFY(counter == 1 );\n+  std::bind(&inc, std::ref(counter))();\n+  VERIFY(counter == 2 );\n+}\n+\n+struct Inc\n+{\n+  int operator()(int& i) const { return ++i; }\n+  void operator()(int&&) const { }\n+\n+  int f(int& i) const { return ++i; }\n+};\n+\n+void test02()\n+{\n+  int counter = 0;\n+  std::bind(Inc(), _1)(counter);\n+  VERIFY(counter == 1 );\n+  std::bind(&Inc::f, Inc(), std::ref(counter))();\n+  VERIFY(counter == 2 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "060bf8715d823df2594ea050e9937d925210d573", "filename": "libstdc++-v3/testsuite/20_util/bind/ref_neg.cc", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d90d97ff9c884f2ff73e87e5ff33d6f481e202b0/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Fref_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d90d97ff9c884f2ff73e87e5ff33d6f481e202b0/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Fref_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Fref_neg.cc?ref=d90d97ff9c884f2ff73e87e5ff33d6f481e202b0", "patch": "@@ -0,0 +1,59 @@\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 20.7.11 Function template bind\n+\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+#include <functional>\n+\n+using namespace std::placeholders;\n+\n+int inc(int& i) { return ++i; }\n+\n+void test01()\n+{\n+  const int dummy = 0;\n+  std::bind(&inc, _1)(0);               // { dg-error  \"\"}\n+  std::bind(&inc, std::ref(dummy))();  // { dg-error  \"\"}\n+  std::bind(&inc, dummy)();  // { dg-error  \"\"}\n+  std::bind(&inc, 0)();  // { dg-error  \"\"}\n+}\n+\n+struct Inc\n+{\n+  int operator()(int& i) const { return ++i; }\n+  void operator()(int&&) const { }\n+\n+  int f(int&& i) const { return ++i; }\n+};\n+\n+void test02()\n+{\n+  const int dummy = 0;\n+  std::bind(Inc(), _1)(dummy);                  // { dg-error  \"\"}\n+  std::bind(&Inc::f, Inc(), std::ref(dummy))(); // { dg-error  \"\"}\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+}\n+\n+// { dg-excess-errors \"\" }"}, {"sha": "fcffd9dd559889d26419ac8d1a63d71266d3d0ee", "filename": "libstdc++-v3/testsuite/20_util/reference_wrapper/24803.cc", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d90d97ff9c884f2ff73e87e5ff33d6f481e202b0/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_wrapper%2F24803.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d90d97ff9c884f2ff73e87e5ff33d6f481e202b0/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_wrapper%2F24803.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_wrapper%2F24803.cc?ref=d90d97ff9c884f2ff73e87e5ff33d6f481e202b0", "patch": "@@ -1,7 +1,7 @@\n // { dg-options \"-std=gnu++0x\" }\n // { dg-do compile }\n \n-// Copyright (C) 2008, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -54,27 +54,19 @@ void test01()\n    verify_return_type((*pr1)(0), double());\n    std::reference_wrapper<double (*)(int)>* pr2(0);\n    verify_return_type((*pr2)(0), double());\n-   std::reference_wrapper<int (test_type::*)()>* pr3(0);\n-   verify_return_type((*pr3)(null_tt), int());\n-   std::reference_wrapper<int (test_type::*)()const>* pr4(0);\n-   verify_return_type((*pr4)(null_ttc), int());\n    std::reference_wrapper<functor1>* pr5(0);\n \n    // libstdc++/24803\n-   // FIXME: verify_return_type((*pr5)(0), double());\n+   verify_return_type((*pr5)(0), double());\n    verify_return_type((*pr5)(zero), double());\n \n    std::reference_wrapper<double (int, char)>* pr1b(0);\n    verify_return_type((*pr1b)(0,0), double());\n    std::reference_wrapper<double (*)(int, char)>* pr2b(0);\n    verify_return_type((*pr2b)(0,0), double());\n-   std::reference_wrapper<int (test_type::*)(char)>* pr3b(0);\n-   verify_return_type((*pr3b)(null_tt,zero), int());\n-   std::reference_wrapper<int (test_type::*)()const>* pr4b(0);\n-   verify_return_type((*pr4b)(null_ttc), int());\n    std::reference_wrapper<functor2>* pr5b(0);\n \n    // libstdc++/24803\n-   // FIXME: verify_return_type((*pr5b)(0,0), double());\n+   verify_return_type((*pr5b)(0,0), double());\n    verify_return_type((*pr5b)(zero,zero), double());\n }"}, {"sha": "ba72b974a05938e05bac2cd8ab9741904975bf6c", "filename": "libstdc++-v3/testsuite/20_util/reference_wrapper/invoke.cc", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d90d97ff9c884f2ff73e87e5ff33d6f481e202b0/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_wrapper%2Finvoke.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d90d97ff9c884f2ff73e87e5ff33d6f481e202b0/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_wrapper%2Finvoke.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_wrapper%2Finvoke.cc?ref=d90d97ff9c884f2ff73e87e5ff33d6f481e202b0", "patch": "@@ -1,6 +1,6 @@\n // { dg-options \"-std=gnu++0x\" }\n \n-// Copyright (C) 2008, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -70,11 +70,6 @@ void test01()\n   ::get_seventeen get_sev;\n   ::X x;\n   ::X* xp = &x;\n-  int (::X::* p_foo)(float) = &::X::foo;\n-  int (::X::* p_foo_c)(float) const = &::X::foo_c;\n-  int (::X::* p_foo_v)(float) volatile = &::X::foo_v;\n-  int (::X::* p_foo_cv)(float) const volatile = &::X::foo_cv;\n-  int ::X::* p_bar = &::X::bar;\n \n   const float pi = 3.14;\n \n@@ -86,20 +81,6 @@ void test01()\n   VERIFY(cref(&truncate_float)(pi) == 3);\n   VERIFY(cref(&seventeen)() == 17);\n \n-  // Member function pointers\n-  VERIFY(ref(p_foo)(x, pi) == 3);\n-  VERIFY(ref(p_foo)(xp, pi) == 3);\n-  VERIFY(ref(p_foo_c)(x, pi) == 3);\n-  VERIFY(ref(p_foo_c)(xp, pi) == 3);\n-  VERIFY(ref(p_foo_v)(x, pi) == 3);\n-  VERIFY(ref(p_foo_v)(xp, pi) == 3);\n-  VERIFY(ref(p_foo_cv)(x, pi) == 3);\n-  VERIFY(ref(p_foo_cv)(xp, pi) == 3);\n-\n-  // Member data pointers\n-  VERIFY(ref(p_bar)(x) == 17);\n-  VERIFY(ref(p_bar)(xp) == 17);\n-\n   // Function objects\n   VERIFY(ref(get_sev)() == 17);\n   VERIFY(cref(get_sev)() == 17);"}]}