{"sha": "de43a0ac6d4d5816a5b59cde78aabce651d43cc8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGU0M2EwYWM2ZDRkNTgxNmE1YjU5Y2RlNzhhYWJjZTY1MWQ0M2NjOA==", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-09-17T21:35:13Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-09-17T21:35:13Z"}, "message": "Merge #684\n\n684: Initial Dynamic dispatch support r=philberty a=philberty\n\nThis rebases my branch for dynamic dispatch (dyn bound) support it supports\r\nthe HIR::TraitObjectOneBound for now but can be easily extended. The computation\r\nof the addresses of the methods only supports impl items and does not support\r\noptional trait methods yet but the change set was already 10 commits and this seems like\r\na good initial stab at support here.\r\n\r\nPlease see the git commits for more detail information on each change.\r\n\r\nFixes #197 \n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "d50a81ea97725eee5abe8d4b881e265c04fd80c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d50a81ea97725eee5abe8d4b881e265c04fd80c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/de43a0ac6d4d5816a5b59cde78aabce651d43cc8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhRQoRCRBK7hj4Ov3rIwAANokIAKCEaUtz28z3LMIqeGEzkvop\nlt6FFAACpcy+WJRCpUD8Kt3WEIxeb1gXYKHVDyxkDDk3+WEsGbd1r3ETchVE4UCF\nrzP1uzW1OhKigyfvfS57FxlwdQns459zZc/rf2tJIXqTrfKvHMeRX+8nyoPmu4iW\nZgfRWY0zwBSF8dGb5CFlAVK1nkXNwi+akx6h2dHteb7ILceCr8/u/UUgQgfeWGKJ\nwBxzWObqJ34zx/WMgXqU9zs773PEEeHH09FA47LcmBiL/cy0QWAXkMENwP0/HVwD\nZ9dHZiZdueEUm04nb40bbPUwEBn3eypf0iISJ+TFBwhwNlifJgHpR2f7YlCUVDE=\n=6+yr\n-----END PGP SIGNATURE-----\n", "payload": "tree d50a81ea97725eee5abe8d4b881e265c04fd80c0\nparent 384cc64dab40edca1f59f369e162df89aa1e91f8\nparent fabaf7d6caf919ceaa05f2db4260fa897864d517\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1631914513 +0000\ncommitter GitHub <noreply@github.com> 1631914513 +0000\n\nMerge #684\n\n684: Initial Dynamic dispatch support r=philberty a=philberty\n\nThis rebases my branch for dynamic dispatch (dyn bound) support it supports\r\nthe HIR::TraitObjectOneBound for now but can be easily extended. The computation\r\nof the addresses of the methods only supports impl items and does not support\r\noptional trait methods yet but the change set was already 10 commits and this seems like\r\na good initial stab at support here.\r\n\r\nPlease see the git commits for more detail information on each change.\r\n\r\nFixes #197 \n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de43a0ac6d4d5816a5b59cde78aabce651d43cc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de43a0ac6d4d5816a5b59cde78aabce651d43cc8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "384cc64dab40edca1f59f369e162df89aa1e91f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/384cc64dab40edca1f59f369e162df89aa1e91f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/384cc64dab40edca1f59f369e162df89aa1e91f8"}, {"sha": "fabaf7d6caf919ceaa05f2db4260fa897864d517", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fabaf7d6caf919ceaa05f2db4260fa897864d517", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fabaf7d6caf919ceaa05f2db4260fa897864d517"}], "stats": {"total": 1118, "additions": 1032, "deletions": 86}, "files": [{"sha": "4a810616977cbfac5812fa64f6e83d9fc20c5c40", "filename": "gcc/rust/backend/rust-compile-base.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.h?ref=de43a0ac6d4d5816a5b59cde78aabce651d43cc8", "patch": "@@ -200,6 +200,19 @@ class HIRCompileBase : public HIR::HIRVisitor\n \n   bool compile_locals_for_block (Resolver::Rib &rib, Bfunction *fndecl,\n \t\t\t\t std::vector<Bvariable *> &locals);\n+\n+  Bexpression *coercion_site (Bexpression *compiled_ref, TyTy::BaseType *actual,\n+\t\t\t      TyTy::BaseType *expected, Location locus);\n+\n+  Bexpression *coerce_to_dyn_object (Bexpression *compiled_ref,\n+\t\t\t\t     TyTy::BaseType *actual,\n+\t\t\t\t     TyTy::BaseType *expected,\n+\t\t\t\t     TyTy::DynamicObjectType *ty,\n+\t\t\t\t     Location locus);\n+\n+  Bexpression *\n+  compute_address_for_trait_item (const Resolver::TraitItemReference *ref,\n+\t\t\t\t  TyTy::BaseType *receiver);\n };\n \n } // namespace Compile"}, {"sha": "7a4344ec493a1bb1526230fa8a8355e164d62c5e", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 62, "deletions": 8, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=de43a0ac6d4d5816a5b59cde78aabce651d43cc8", "patch": "@@ -343,9 +343,10 @@ class Context\n class TyTyResolveCompile : public TyTy::TyVisitor\n {\n public:\n-  static ::Btype *compile (Context *ctx, TyTy::BaseType *ty)\n+  static ::Btype *compile (Context *ctx, TyTy::BaseType *ty,\n+\t\t\t   bool trait_object_mode = false)\n   {\n-    TyTyResolveCompile compiler (ctx);\n+    TyTyResolveCompile compiler (ctx, trait_object_mode);\n     ty->accept_vis (compiler);\n     return compiler.translated;\n   }\n@@ -378,7 +379,8 @@ class TyTyResolveCompile : public TyTy::TyVisitor\n     if (!type.get_return_type ()->is_unit ())\n       {\n \tauto hir_type = type.get_return_type ();\n-\tauto ret = TyTyResolveCompile::compile (ctx, hir_type);\n+\tauto ret\n+\t  = TyTyResolveCompile::compile (ctx, hir_type, trait_object_mode);\n \tresults.push_back (Backend::Btyped_identifier (\n \t  \"_\", ret,\n \t  ctx->get_mappings ()->lookup_location (hir_type->get_ref ())));\n@@ -388,7 +390,7 @@ class TyTyResolveCompile : public TyTy::TyVisitor\n       {\n \tauto param_tyty = param_pair.second;\n \tauto compiled_param_type\n-\t  = TyTyResolveCompile::compile (ctx, param_tyty);\n+\t  = TyTyResolveCompile::compile (ctx, param_tyty, trait_object_mode);\n \n \tauto compiled_param = Backend::Btyped_identifier (\n \t  param_pair.first->as_string (), compiled_param_type,\n@@ -429,7 +431,6 @@ class TyTyResolveCompile : public TyTy::TyVisitor\n     if (ctx->lookup_compiled_types (type.get_ty_ref (), &translated, &type))\n       return;\n \n-    // create implicit struct\n     std::vector<Backend::Btyped_identifier> fields;\n     for (size_t i = 0; i < type.num_fields (); i++)\n       {\n@@ -570,7 +571,7 @@ class TyTyResolveCompile : public TyTy::TyVisitor\n   void visit (TyTy::ReferenceType &type) override\n   {\n     Btype *base_compiled_type\n-      = TyTyResolveCompile::compile (ctx, type.get_base ());\n+      = TyTyResolveCompile::compile (ctx, type.get_base (), trait_object_mode);\n     if (type.is_mutable ())\n       {\n \ttranslated = ctx->get_backend ()->reference_type (base_compiled_type);\n@@ -585,7 +586,7 @@ class TyTyResolveCompile : public TyTy::TyVisitor\n   void visit (TyTy::PointerType &type) override\n   {\n     Btype *base_compiled_type\n-      = TyTyResolveCompile::compile (ctx, type.get_base ());\n+      = TyTyResolveCompile::compile (ctx, type.get_base (), trait_object_mode);\n     if (type.is_mutable ())\n       {\n \ttranslated = ctx->get_backend ()->pointer_type (base_compiled_type);\n@@ -610,10 +611,63 @@ class TyTyResolveCompile : public TyTy::TyVisitor\n     translated = ctx->get_backend ()->unit_type ();\n   }\n \n+  void visit (TyTy::DynamicObjectType &type) override\n+  {\n+    if (trait_object_mode)\n+      {\n+\ttranslated = ctx->get_backend ()->integer_type (\n+\t  true, ctx->get_backend ()->get_pointer_size ());\n+\treturn;\n+      }\n+\n+    if (ctx->lookup_compiled_types (type.get_ty_ref (), &translated, &type))\n+      return;\n+\n+    // create implicit struct\n+    auto items = type.get_object_items ();\n+    std::vector<Backend::Btyped_identifier> fields;\n+\n+    Btype *uint = ctx->get_backend ()->integer_type (\n+      true, ctx->get_backend ()->get_pointer_size ());\n+    Btype *uintptr_ty = ctx->get_backend ()->pointer_type (uint);\n+\n+    Backend::Btyped_identifier f (\"__receiver_trait_obj_ptr\", uintptr_ty,\n+\t\t\t\t  ctx->get_mappings ()->lookup_location (\n+\t\t\t\t    type.get_ty_ref ()));\n+    fields.push_back (std::move (f));\n+\n+    for (size_t i = 0; i < items.size (); i++)\n+      {\n+\t// mrustc seems to make a vtable consisting of uintptr's\n+\tBtype *uint = ctx->get_backend ()->integer_type (\n+\t  true, ctx->get_backend ()->get_pointer_size ());\n+\tBtype *uintptr_ty = ctx->get_backend ()->pointer_type (uint);\n+\n+\tBackend::Btyped_identifier f (\"__\" + std::to_string (i), uintptr_ty,\n+\t\t\t\t      ctx->get_mappings ()->lookup_location (\n+\t\t\t\t\ttype.get_ty_ref ()));\n+\tfields.push_back (std::move (f));\n+      }\n+\n+    Btype *type_record = ctx->get_backend ()->struct_type (fields);\n+    Btype *named_struct\n+      = ctx->get_backend ()->named_type (type.get_name (), type_record,\n+\t\t\t\t\t ctx->get_mappings ()->lookup_location (\n+\t\t\t\t\t   type.get_ty_ref ()));\n+\n+    ctx->push_type (named_struct);\n+    translated = named_struct;\n+\n+    ctx->insert_compiled_type (type.get_ty_ref (), named_struct, &type);\n+  }\n+\n private:\n-  TyTyResolveCompile (Context *ctx) : ctx (ctx), translated (nullptr) {}\n+  TyTyResolveCompile (Context *ctx, bool trait_object_mode)\n+    : ctx (ctx), trait_object_mode (trait_object_mode), translated (nullptr)\n+  {}\n \n   Context *ctx;\n+  bool trait_object_mode;\n   ::Btype *translated;\n };\n "}, {"sha": "e3fa697cca957865a9545c050c5e10cb8e8af314", "filename": "gcc/rust/backend/rust-compile-stmt.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h?ref=de43a0ac6d4d5816a5b59cde78aabce651d43cc8", "patch": "@@ -58,6 +58,7 @@ class CompileStmt : public HIRCompileBase\n     if (!ctx->get_tyctx ()->lookup_type (stmt.get_mappings ().get_hirid (),\n \t\t\t\t\t &ty))\n       {\n+\t// FIXME this should be an assertion instead\n \trust_fatal_error (stmt.get_locus (),\n \t\t\t  \"failed to lookup variable declaration type\");\n \treturn;\n@@ -66,15 +67,26 @@ class CompileStmt : public HIRCompileBase\n     Bvariable *var = nullptr;\n     if (!ctx->lookup_var_decl (stmt.get_mappings ().get_hirid (), &var))\n       {\n+\t// FIXME this should be an assertion instead and use error mark node\n \trust_fatal_error (stmt.get_locus (),\n \t\t\t  \"failed to lookup compiled variable declaration\");\n \treturn;\n       }\n \n     Bexpression *init = CompileExpr::Compile (stmt.get_init_expr (), ctx);\n+    // FIXME use error_mark_node, check that CompileExpr returns error_mark_node\n+    // on failure and make this an assertion\n     if (init == nullptr)\n       return;\n \n+    TyTy::BaseType *actual = nullptr;\n+    bool ok = ctx->get_tyctx ()->lookup_type (\n+      stmt.get_init_expr ()->get_mappings ().get_hirid (), &actual);\n+    rust_assert (ok);\n+\n+    TyTy::BaseType *expected = ty;\n+    init = coercion_site (init, actual, expected, stmt.get_locus ());\n+\n     auto fnctx = ctx->peek_fn ();\n     if (ty->is_unit ())\n       {"}, {"sha": "40b297c59f994a7cfbbc07ab2a3d715cb2b2c305", "filename": "gcc/rust/backend/rust-compile-tyty.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h?ref=de43a0ac6d4d5816a5b59cde78aabce651d43cc8", "patch": "@@ -237,6 +237,8 @@ class TyTyCompile : public TyTy::TyVisitor\n     translated = backend->unit_type ();\n   }\n \n+  void visit (TyTy::DynamicObjectType &) override { gcc_unreachable (); }\n+\n private:\n   TyTyCompile (::Backend *backend)\n     : backend (backend), translated (nullptr),"}, {"sha": "58c679f74ff207f1cadced4de684df0a45d128d3", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 240, "deletions": 15, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=de43a0ac6d4d5816a5b59cde78aabce651d43cc8", "patch": "@@ -108,6 +108,9 @@ CompileExpr::visit (HIR::CallExpr &expr)\n void\n CompileExpr::visit (HIR::MethodCallExpr &expr)\n {\n+  // method receiver\n+  Bexpression *self = CompileExpr::Compile (expr.get_receiver ().get (), ctx);\n+\n   // lookup the resolved name\n   NodeId resolved_node_id = UNKNOWN_NODEID;\n   if (!ctx->get_resolver ()->lookup_resolved_name (\n@@ -134,6 +137,110 @@ CompileExpr::visit (HIR::MethodCallExpr &expr)\n   rust_assert (lookup_fntype->get_kind () == TyTy::TypeKind::FNDEF);\n   TyTy::FnType *fntype = static_cast<TyTy::FnType *> (lookup_fntype);\n \n+  TyTy::BaseType *receiver = nullptr;\n+  ok = ctx->get_tyctx ()->lookup_receiver (expr.get_mappings ().get_hirid (),\n+\t\t\t\t\t   &receiver);\n+  rust_assert (ok);\n+\n+  bool is_dyn_dispatch\n+    = receiver->get_root ()->get_kind () == TyTy::TypeKind::DYNAMIC;\n+  bool is_generic_receiver = receiver->get_kind () == TyTy::TypeKind::PARAM;\n+  if (is_generic_receiver)\n+    {\n+      TyTy::ParamType *p = static_cast<TyTy::ParamType *> (receiver);\n+      receiver = p->resolve ();\n+    }\n+\n+  if (is_dyn_dispatch)\n+    {\n+      TyTy::DynamicObjectType *dyn\n+\t= static_cast<TyTy::DynamicObjectType *> (receiver->get_root ());\n+\n+      size_t offs = 0;\n+      const Resolver::TraitItemReference *ref = nullptr;\n+      for (auto &item : dyn->get_object_items ())\n+\t{\n+\t  auto t = item->get_tyty ();\n+\t  rust_assert (t->get_kind () == TyTy::TypeKind::FNDEF);\n+\t  auto ft = static_cast<TyTy::FnType *> (t);\n+\n+\t  if (ft->get_id () == fntype->get_id ())\n+\t    {\n+\t      ref = item;\n+\t      break;\n+\t    }\n+\t  offs++;\n+\t}\n+\n+      if (ref == nullptr)\n+\t{\n+\t  translated = ctx->get_backend ()->error_expression ();\n+\t  return;\n+\t}\n+\n+      // get any indirection sorted out\n+      auto receiver_ref = self;\n+      if (receiver->get_kind () == TyTy::TypeKind::REF)\n+\t{\n+\t  TyTy::ReferenceType *r\n+\t    = static_cast<TyTy::ReferenceType *> (receiver);\n+\t  auto indirect_ty = r->get_base ();\n+\t  Btype *indrect_compiled_tyty\n+\t    = TyTyResolveCompile::compile (ctx, indirect_ty);\n+\n+\t  Bexpression *indirect\n+\t    = ctx->get_backend ()->indirect_expression (indrect_compiled_tyty,\n+\t\t\t\t\t\t\treceiver_ref, true,\n+\t\t\t\t\t\t\texpr.get_locus ());\n+\t  receiver_ref = indirect;\n+\t}\n+\n+      // access the offs + 1 for the fnptr and offs=0 for the reciever obj\n+      Bexpression *self_argument\n+\t= ctx->get_backend ()->struct_field_expression (receiver_ref, 0,\n+\t\t\t\t\t\t\texpr.get_locus ());\n+\n+      // access the vtable for the fn\n+      Bexpression *fn_vtable_access\n+\t= ctx->get_backend ()->struct_field_expression (receiver_ref, offs + 1,\n+\t\t\t\t\t\t\texpr.get_locus ());\n+\n+      // cast it to the correct fntype\n+      Btype *expected_fntype = TyTyResolveCompile::compile (ctx, fntype, true);\n+      Bexpression *fn_convert_expr\n+\t= ctx->get_backend ()->convert_expression (expected_fntype,\n+\t\t\t\t\t\t   fn_vtable_access,\n+\t\t\t\t\t\t   expr.get_locus ());\n+\n+      fncontext fnctx = ctx->peek_fn ();\n+      Bblock *enclosing_scope = ctx->peek_enclosing_scope ();\n+      bool is_address_taken = false;\n+      Bstatement *ret_var_stmt = nullptr;\n+\n+      Bvariable *fn_convert_expr_tmp = ctx->get_backend ()->temporary_variable (\n+\tfnctx.fndecl, enclosing_scope, expected_fntype, fn_convert_expr,\n+\tis_address_taken, expr.get_locus (), &ret_var_stmt);\n+      ctx->add_statement (ret_var_stmt);\n+\n+      std::vector<Bexpression *> args;\n+      args.push_back (self_argument);\n+      expr.iterate_params ([&] (HIR::Expr *p) mutable -> bool {\n+\tBexpression *compiled_expr = CompileExpr::Compile (p, ctx);\n+\trust_assert (compiled_expr != nullptr);\n+\targs.push_back (compiled_expr);\n+\treturn true;\n+      });\n+\n+      Bexpression *fn_expr\n+\t= ctx->get_backend ()->var_expression (fn_convert_expr_tmp,\n+\t\t\t\t\t       expr.get_locus ());\n+\n+      translated\n+\t= ctx->get_backend ()->call_expression (fnctx.fndecl, fn_expr, args,\n+\t\t\t\t\t\tnullptr, expr.get_locus ());\n+      return;\n+    }\n+\n   // lookup compiled functions\n   Bfunction *fn = nullptr;\n   if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n@@ -157,17 +264,6 @@ CompileExpr::visit (HIR::MethodCallExpr &expr)\n \t    trait->get_mappings ().get_defid (), &trait_ref);\n \t  rust_assert (ok);\n \n-\t  TyTy::BaseType *receiver = nullptr;\n-\t  ok = ctx->get_tyctx ()->lookup_receiver (\n-\t    expr.get_mappings ().get_hirid (), &receiver);\n-\t  rust_assert (ok);\n-\n-\t  if (receiver->get_kind () == TyTy::TypeKind::PARAM)\n-\t    {\n-\t      TyTy::ParamType *p = static_cast<TyTy::ParamType *> (receiver);\n-\t      receiver = p->resolve ();\n-\t    }\n-\n \t  // the type resolver can only resolve type bounds to their trait\n \t  // item so its up to us to figure out if this path should resolve\n \t  // to an trait-impl-block-item or if it can be defaulted to the\n@@ -290,10 +386,6 @@ CompileExpr::visit (HIR::MethodCallExpr &expr)\n \n   std::vector<Bexpression *> args;\n \n-  // method receiver\n-  Bexpression *self = CompileExpr::Compile (expr.get_receiver ().get (), ctx);\n-  rust_assert (self != nullptr);\n-\n   // lookup the autoderef mappings\n   std::vector<Resolver::Adjustment> *adjustments = nullptr;\n   ok = ctx->get_tyctx ()->lookup_autoderef_mappings (\n@@ -579,5 +671,138 @@ HIRCompileBase::compile_locals_for_block (Resolver::Rib &rib, Bfunction *fndecl,\n \n   return true;\n }\n+\n+Bexpression *\n+HIRCompileBase::coercion_site (Bexpression *compiled_ref,\n+\t\t\t       TyTy::BaseType *actual, TyTy::BaseType *expected,\n+\t\t\t       Location locus)\n+{\n+  auto root_actual_kind = actual->get_root ()->get_kind ();\n+  auto root_expected_kind = expected->get_root ()->get_kind ();\n+\n+  if (root_expected_kind == TyTy::TypeKind::DYNAMIC\n+      && root_actual_kind != TyTy::TypeKind::DYNAMIC)\n+    {\n+      TyTy::DynamicObjectType *dyn\n+\t= static_cast<TyTy::DynamicObjectType *> (expected->get_root ());\n+      return coerce_to_dyn_object (compiled_ref, actual, expected, dyn, locus);\n+    }\n+\n+  return compiled_ref;\n+}\n+\n+Bexpression *\n+HIRCompileBase::coerce_to_dyn_object (Bexpression *compiled_ref,\n+\t\t\t\t      TyTy::BaseType *actual,\n+\t\t\t\t      TyTy::BaseType *expected,\n+\t\t\t\t      TyTy::DynamicObjectType *ty,\n+\t\t\t\t      Location locus)\n+{\n+  Btype *dynamic_object = TyTyResolveCompile::compile (ctx, ty);\n+\n+  //' this assumes ordering and current the structure is\n+  // __trait_object_ptr\n+  // [list of function ptrs]\n+\n+  std::vector<Bexpression *> vals;\n+  vals.push_back (compiled_ref);\n+  for (auto &item : ty->get_object_items ())\n+    {\n+      // compute the address of each method item\n+      auto address = compute_address_for_trait_item (item, actual->get_root ());\n+      vals.push_back (address);\n+    }\n+\n+  Bexpression *constructed_trait_object\n+    = ctx->get_backend ()->constructor_expression (dynamic_object, vals, -1,\n+\n+\t\t\t\t\t\t   locus);\n+\n+  fncontext fnctx = ctx->peek_fn ();\n+  Bblock *enclosing_scope = ctx->peek_enclosing_scope ();\n+  bool is_address_taken = false;\n+  Bstatement *ret_var_stmt = nullptr;\n+\n+  Bvariable *dyn_tmp = ctx->get_backend ()->temporary_variable (\n+    fnctx.fndecl, enclosing_scope, dynamic_object, constructed_trait_object,\n+    is_address_taken, locus, &ret_var_stmt);\n+  ctx->add_statement (ret_var_stmt);\n+\n+  // FIXME this needs to be more generic to apply any covariance\n+\n+  auto e = expected;\n+  std::vector<Resolver::Adjustment> adjustments;\n+  while (e->get_kind () == TyTy::TypeKind::REF)\n+    {\n+      auto r = static_cast<TyTy::ReferenceType *> (e);\n+      e = r->get_base ();\n+\n+      if (r->is_mutable ())\n+\tadjustments.push_back (\n+\t  Resolver::Adjustment (Resolver::Adjustment::AdjustmentType::MUT_REF,\n+\t\t\t\te));\n+      else\n+\tadjustments.push_back (\n+\t  Resolver::Adjustment (Resolver::Adjustment::AdjustmentType::IMM_REF,\n+\t\t\t\te));\n+    }\n+\n+  auto resulting_dyn_object_ref\n+    = ctx->get_backend ()->var_expression (dyn_tmp, locus);\n+  for (auto it = adjustments.rbegin (); it != adjustments.rend (); it++)\n+    {\n+      bool ok\n+\t= it->get_type () == Resolver::Adjustment::AdjustmentType::IMM_REF\n+\t  || it->get_type () == Resolver::Adjustment::AdjustmentType::MUT_REF;\n+      rust_assert (ok);\n+\n+      resulting_dyn_object_ref\n+\t= ctx->get_backend ()->address_expression (resulting_dyn_object_ref,\n+\t\t\t\t\t\t   locus);\n+    }\n+  return resulting_dyn_object_ref;\n+}\n+\n+Bexpression *\n+HIRCompileBase::compute_address_for_trait_item (\n+  const Resolver::TraitItemReference *trait_item_ref, TyTy::BaseType *receiver)\n+{\n+  TyTy::BaseType *item_type = trait_item_ref->get_tyty ();\n+  rust_assert (item_type->get_kind () == TyTy::TypeKind::FNDEF);\n+  TyTy::FnType *fntype = static_cast<TyTy::FnType *> (item_type);\n+\n+  auto root = receiver->get_root ();\n+  HIR::PathIdentSegment segment_name (trait_item_ref->get_identifier ());\n+  std::vector<Resolver::PathProbeCandidate> candidates\n+    = Resolver::PathProbeType::Probe (root, segment_name, true, false, true);\n+\n+  // FIXME for default trait item resolution\n+  //\n+  // if (candidates.size () == 0)\n+  //   {\n+  //     rust_assert (trait_item_ref->is_optional ()); // has definition\n+  //\n+  //     CompileTraitItem::Compile (self_type,\n+  //       \t\t\t trait_item_ref->get_hir_trait_item (), ctx,\n+  //       \t\t\t fntype);\n+  //     if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n+  //       {\n+  //         return ctx->get_backend ()->error_expression ();\n+  //       }\n+  //   }\n+\n+  rust_assert (!candidates.empty ());\n+  rust_assert (candidates.size () == 1);\n+\n+  Resolver::PathProbeCandidate *candidate = &candidates.at (0);\n+  rust_assert (candidate->is_impl_candidate ());\n+\n+  HIR::ImplItem *impl_item = candidate->item.impl.impl_item;\n+\n+  return CompileInherentImplItem::Compile (receiver->get_root (), impl_item,\n+\t\t\t\t\t   ctx, true, fntype, true,\n+\t\t\t\t\t   Location () /* FIXME */);\n+}\n+\n } // namespace Compile\n } // namespace Rust"}, {"sha": "8cd7a01b2e8d386ff23281bd278a4e137786e0ff", "filename": "gcc/rust/hir/tree/rust-hir-item.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h?ref=de43a0ac6d4d5816a5b59cde78aabce651d43cc8", "patch": "@@ -2264,6 +2264,8 @@ class TraitItemFunc : public TraitItem\n \n   TraitFunctionDecl &get_decl () { return decl; }\n \n+  const TraitFunctionDecl &get_decl () const { return decl; }\n+\n   bool has_block_defined () const { return block_expr != nullptr; }\n \n   std::unique_ptr<BlockExpr> &get_block_expr ()"}, {"sha": "14664340d2b57c297ab1b734dd3dcefc80856140", "filename": "gcc/rust/typecheck/rust-hir-const-fold.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.h?ref=de43a0ac6d4d5816a5b59cde78aabce651d43cc8", "patch": "@@ -191,6 +191,8 @@ class ConstFoldType : public TyTy::TyVisitor\n \n   void visit (TyTy::NeverType &) override { gcc_unreachable (); }\n \n+  void visit (TyTy::DynamicObjectType &) override { gcc_unreachable (); }\n+\n private:\n   ConstFoldType (::Backend *backend)\n     : backend (backend), translated (backend->error_type ())"}, {"sha": "0b64a3680192cdfc5f96b4ba49b8b1f11655cf01", "filename": "gcc/rust/typecheck/rust-hir-trait-ref.h", "status": "modified", "additions": 47, "deletions": 3, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h?ref=de43a0ac6d4d5816a5b59cde78aabce651d43cc8", "patch": "@@ -143,6 +143,8 @@ class TraitItemReference\n \n   void associated_type_reset ();\n \n+  bool is_object_safe () const;\n+\n private:\n   TyTy::ErrorType *get_error () const\n   {\n@@ -175,12 +177,15 @@ class TraitItemReference\n };\n \n // this wraps up the HIR::Trait so we can do analysis on it\n+\n class TraitReference\n {\n public:\n   TraitReference (const HIR::Trait *hir_trait_ref,\n-\t\t  std::vector<TraitItemReference> item_refs)\n-    : hir_trait_ref (hir_trait_ref), item_refs (item_refs)\n+\t\t  std::vector<TraitItemReference> item_refs,\n+\t\t  std::vector<const TraitReference *> super_traits)\n+    : hir_trait_ref (hir_trait_ref), item_refs (item_refs),\n+      super_traits (super_traits)\n   {}\n \n   TraitReference (TraitReference const &other)\n@@ -198,7 +203,7 @@ class TraitReference\n   TraitReference (TraitReference &&other) = default;\n   TraitReference &operator= (TraitReference &&other) = default;\n \n-  static TraitReference error () { return TraitReference (nullptr, {}); }\n+  static TraitReference error () { return TraitReference (nullptr, {}, {}); }\n \n   bool is_error () const { return hir_trait_ref == nullptr; }\n \n@@ -323,9 +328,48 @@ class TraitReference\n     return this_id == other_id;\n   }\n \n+  const std::vector<const TraitReference *> get_super_traits () const\n+  {\n+    return super_traits;\n+  }\n+\n+  bool is_object_safe (bool emit_error, Location locus) const\n+  {\n+    // https: // doc.rust-lang.org/reference/items/traits.html#object-safety\n+    std::vector<const TraitReference *> non_object_super_traits;\n+    for (auto &item : super_traits)\n+      {\n+\tif (!item->is_object_safe (false, Location ()))\n+\t  non_object_super_traits.push_back (item);\n+      }\n+\n+    std::vector<const Resolver::TraitItemReference *> non_object_safe_items;\n+    for (auto &item : get_trait_items ())\n+      {\n+\tif (!item.is_object_safe ())\n+\t  non_object_safe_items.push_back (&item);\n+      }\n+\n+    bool is_safe\n+      = non_object_super_traits.empty () && non_object_safe_items.empty ();\n+    if (emit_error && !is_safe)\n+      {\n+\tRichLocation r (locus);\n+\tfor (auto &item : non_object_super_traits)\n+\t  r.add_range (item->get_locus ());\n+\tfor (auto &item : non_object_safe_items)\n+\t  r.add_range (item->get_locus ());\n+\n+\trust_error_at (r, \"trait bound is not object safe\");\n+      }\n+\n+    return is_safe;\n+  }\n+\n private:\n   const HIR::Trait *hir_trait_ref;\n   std::vector<TraitItemReference> item_refs;\n+  std::vector<const TraitReference *> super_traits;\n };\n \n class AssociatedImplTrait"}, {"sha": "cee6999acce2d432ea27c7e33430b64df17e6b46", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.cc", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc?ref=de43a0ac6d4d5816a5b59cde78aabce651d43cc8", "patch": "@@ -193,6 +193,36 @@ TraitItemReference::get_parent_trait_mappings () const\n   return trait->get_mappings ();\n }\n \n+bool\n+TraitItemReference::is_object_safe () const\n+{\n+  // https://doc.rust-lang.org/reference/items/traits.html#object-safety\n+  switch (get_trait_item_type ())\n+    {\n+      case TraitItemReference::TraitItemType::FN: {\n+\t// lets be boring and just check that this is indeed a method will do\n+\t// for now\n+\tconst HIR::TraitItem *item = get_hir_trait_item ();\n+\tconst HIR::TraitItemFunc *fn\n+\t  = static_cast<const HIR::TraitItemFunc *> (item);\n+\treturn fn->get_decl ().is_method ();\n+      }\n+\n+      // constants are not available via dyn dispatch and so is not object safe\n+    case TraitItemReference::TraitItemType::CONST:\n+      return false;\n+\n+      // types are object safe since they are not available via dyn dispatch\n+    case TraitItemReference::TraitItemType::TYPE:\n+      return true;\n+\n+      // this is just an error so lets just fail it\n+    case TraitItemReference::TraitItemType::ERROR:\n+      return false;\n+    }\n+  return false;\n+}\n+\n TyTy::BaseType *\n AssociatedImplTrait::get_projected_type (\n   const TraitItemReference *trait_item_ref, TyTy::BaseType *receiver, HirId ref,"}, {"sha": "a32b4dae7d8268c16607e8f0be613032d2055f39", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h?ref=de43a0ac6d4d5816a5b59cde78aabce651d43cc8", "patch": "@@ -153,6 +153,7 @@ class TraitResolver : public TypeCheckBase\n       TyTy::TypeBoundPredicate (trait_reference->get_mappings ().get_defid (),\n \t\t\t\ttrait_reference->get_locus ()));\n \n+    std::vector<const TraitReference *> super_traits;\n     if (trait_reference->has_type_param_bounds ())\n       {\n \tfor (auto &bound : trait_reference->get_type_param_bounds ())\n@@ -170,6 +171,7 @@ class TraitResolver : public TypeCheckBase\n \t\t  trait->get_mappings ().get_defid (), bound->get_locus ());\n \n \t\tspecified_bounds.push_back (std::move (predicate));\n+\t\tsuper_traits.push_back (predicate.get ());\n \t      }\n \t  }\n       }\n@@ -189,7 +191,8 @@ class TraitResolver : public TypeCheckBase\n \titem_refs.push_back (std::move (trait_item_ref));\n       }\n \n-    TraitReference trait_object (trait_reference, item_refs);\n+    TraitReference trait_object (trait_reference, item_refs,\n+\t\t\t\t std::move (super_traits));\n     context->insert_trait_reference (\n       trait_reference->get_mappings ().get_defid (), std::move (trait_object));\n "}, {"sha": "fe8973a4d819b267d1ac0564aeed072fea9b7db7", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=de43a0ac6d4d5816a5b59cde78aabce651d43cc8", "patch": "@@ -227,10 +227,13 @@ class TypeCheckExpr : public TypeCheckBase\n     // which is simple. There will need to be adjustments to ensure we can turn\n     // the receiver into borrowed references etc\n \n-    bool reciever_is_generic = root->get_kind () == TyTy::TypeKind::PARAM;\n+    bool receiver_is_type_param = root->get_kind () == TyTy::TypeKind::PARAM;\n+    bool receiver_is_dyn = root->get_kind () == TyTy::TypeKind::DYNAMIC;\n+\n+    bool receiver_is_generic = receiver_is_type_param || receiver_is_dyn;\n     bool probe_bounds = true;\n-    bool probe_impls = !reciever_is_generic;\n-    bool ignore_mandatory_trait_items = !reciever_is_generic;\n+    bool probe_impls = !receiver_is_generic;\n+    bool ignore_mandatory_trait_items = !receiver_is_generic;\n \n     auto candidates\n       = PathProbeType::Probe (root, expr.get_method_name ().get_segment (),\n@@ -345,7 +348,7 @@ class TypeCheckExpr : public TypeCheckBase\n \t  }\n       }\n \n-    if (!reciever_is_generic)\n+    if (!receiver_is_type_param)\n       {\n \t// apply any remaining generic arguments\n \tif (expr.get_method_name ().has_generic_args ())"}, {"sha": "daf515a6afd9d335b8966e9782d3216c3eef02df", "filename": "gcc/rust/typecheck/rust-hir-type-check-implitem.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h?ref=de43a0ac6d4d5816a5b59cde78aabce651d43cc8", "patch": "@@ -424,9 +424,6 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n \t  trait_reference.get_name ().c_str ());\n       }\n \n-    rust_debug_loc (type.get_locus (), \"type-alias within impl block\");\n-    lookup->debug ();\n-\n     // its actually a projection, since we need a way to actually bind the\n     // generic substitutions to the type itself\n     TyTy::ProjectionType *projection = new TyTy::ProjectionType ("}, {"sha": "7ad6d033afa91cd332be47da03823f779e48b406", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.cc", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc?ref=de43a0ac6d4d5816a5b59cde78aabce651d43cc8", "patch": "@@ -221,5 +221,24 @@ TypeCheckType::resolve_segments (\n   gcc_unreachable ();\n }\n \n+void\n+TypeCheckType::visit (HIR::TraitObjectTypeOneBound &type)\n+{\n+  std::vector<TyTy::TypeBoundPredicate> specified_bounds;\n+\n+  HIR::TraitBound &trait_bound = type.get_trait_bound ();\n+  TraitReference *trait = resolve_trait_path (trait_bound.get_path ());\n+  TyTy::TypeBoundPredicate predicate (trait->get_mappings ().get_defid (),\n+\t\t\t\t      trait_bound.get_locus ());\n+\n+  if (predicate.is_object_safe (true, type.get_locus ()))\n+    {\n+      specified_bounds.push_back (std::move (predicate));\n+      translated\n+\t= new TyTy::DynamicObjectType (type.get_mappings ().get_hirid (),\n+\t\t\t\t       std::move (specified_bounds));\n+    }\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "eb1c8617bb37c5328267fe7e501af38c7b47cec8", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h?ref=de43a0ac6d4d5816a5b59cde78aabce651d43cc8", "patch": "@@ -66,7 +66,8 @@ class TypeCheckType : public TypeCheckBase\n     type->accept_vis (resolver);\n \n     if (resolver.translated == nullptr)\n-      return new TyTy::ErrorType (type->get_mappings ().get_hirid ());\n+      resolver.translated\n+\t= new TyTy::ErrorType (type->get_mappings ().get_hirid ());\n \n     resolver.context->insert_type (type->get_mappings (), resolver.translated);\n     return resolver.translated;\n@@ -146,6 +147,8 @@ class TypeCheckType : public TypeCheckBase\n \t\t\t\t      TyTy::InferType::InferTypeKind::GENERAL);\n   }\n \n+  void visit (HIR::TraitObjectTypeOneBound &type) override;\n+\n private:\n   TypeCheckType (std::vector<TyTy::SubstitutionParamMapping> *subst_mappings)\n     : TypeCheckBase (), subst_mappings (subst_mappings), translated (nullptr)"}, {"sha": "13496ff22b832249f756959b3df24ab3d5bafa64", "filename": "gcc/rust/typecheck/rust-substitution-mapper.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h?ref=de43a0ac6d4d5816a5b59cde78aabce651d43cc8", "patch": "@@ -137,6 +137,7 @@ class SubstMapper : public TyTy::TyVisitor\n   void visit (TyTy::ParamType &) override { gcc_unreachable (); }\n   void visit (TyTy::StrType &) override { gcc_unreachable (); }\n   void visit (TyTy::NeverType &) override { gcc_unreachable (); }\n+  void visit (TyTy::DynamicObjectType &) override { gcc_unreachable (); }\n \n private:\n   SubstMapper (HirId ref, HIR::GenericArgs *generics, Location locus)\n@@ -230,6 +231,7 @@ class SubstMapperInternal : public TyTy::TyVisitor\n   void visit (TyTy::CharType &) override { gcc_unreachable (); }\n   void visit (TyTy::StrType &) override { gcc_unreachable (); }\n   void visit (TyTy::NeverType &) override { gcc_unreachable (); }\n+  void visit (TyTy::DynamicObjectType &) override { gcc_unreachable (); }\n \n private:\n   SubstMapperInternal (HirId ref, TyTy::SubstitutionArgumentMappings &mappings)\n@@ -288,6 +290,7 @@ class SubstMapperFromExisting : public TyTy::TyVisitor\n   void visit (TyTy::NeverType &) override { gcc_unreachable (); }\n   void visit (TyTy::PlaceholderType &) override { gcc_unreachable (); }\n   void visit (TyTy::ProjectionType &) override { gcc_unreachable (); }\n+  void visit (TyTy::DynamicObjectType &) override { gcc_unreachable (); }\n \n private:\n   SubstMapperFromExisting (TyTy::BaseType *concrete, TyTy::BaseType *receiver)\n@@ -339,6 +342,7 @@ class GetUsedSubstArgs : public TyTy::TyVisitor\n   void visit (TyTy::NeverType &) override {}\n   void visit (TyTy::PlaceholderType &) override {}\n   void visit (TyTy::ProjectionType &) override {}\n+  void visit (TyTy::DynamicObjectType &) override {}\n \n private:\n   GetUsedSubstArgs () : args (TyTy::SubstitutionArgumentMappings::error ()) {}"}, {"sha": "5f69deb52d3a2d0df403e8fc4f6e51bf83e95c6c", "filename": "gcc/rust/typecheck/rust-tyty-bounds.cc", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc?ref=de43a0ac6d4d5816a5b59cde78aabce651d43cc8", "patch": "@@ -88,7 +88,24 @@ TypeBoundPredicate::get () const\n std::string\n TypeBoundPredicate::get_name () const\n {\n-  return get ()->get_name ();\n+  auto mappings = Analysis::Mappings::get ();\n+  auto trait = get ();\n+  auto nodeid = trait->get_mappings ().get_nodeid ();\n+\n+  const Resolver::CanonicalPath *p = nullptr;\n+  if (mappings->lookup_canonical_path (mappings->get_current_crate (), nodeid,\n+\t\t\t\t       &p))\n+    return p->get ();\n+\n+  return trait->get_name ();\n+}\n+\n+bool\n+TypeBoundPredicate::is_object_safe (bool emit_error, Location locus) const\n+{\n+  const Resolver::TraitReference *trait = get ();\n+  rust_assert (trait != nullptr);\n+  return trait->is_object_safe (emit_error, locus);\n }\n \n } // namespace TyTy"}, {"sha": "906110ad89540d48834a5e7a59e3a0e31d9a3a48", "filename": "gcc/rust/typecheck/rust-tyty-call.h", "status": "modified", "additions": 29, "deletions": 27, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h?ref=de43a0ac6d4d5816a5b59cde78aabce651d43cc8", "patch": "@@ -39,24 +39,25 @@ class TypeCheckCallExpr : private TyVisitor\n     return checker.resolved;\n   }\n \n-  void visit (InferType &type) override { gcc_unreachable (); }\n-  void visit (TupleType &type) override { gcc_unreachable (); }\n-  void visit (ArrayType &type) override { gcc_unreachable (); }\n-  void visit (BoolType &type) override { gcc_unreachable (); }\n-  void visit (IntType &type) override { gcc_unreachable (); }\n-  void visit (UintType &type) override { gcc_unreachable (); }\n-  void visit (FloatType &type) override { gcc_unreachable (); }\n-  void visit (USizeType &type) override { gcc_unreachable (); }\n-  void visit (ISizeType &type) override { gcc_unreachable (); }\n-  void visit (ErrorType &type) override { gcc_unreachable (); }\n-  void visit (CharType &type) override { gcc_unreachable (); }\n-  void visit (ReferenceType &type) override { gcc_unreachable (); }\n-  void visit (PointerType &type) override { gcc_unreachable (); }\n+  void visit (InferType &) override { gcc_unreachable (); }\n+  void visit (TupleType &) override { gcc_unreachable (); }\n+  void visit (ArrayType &) override { gcc_unreachable (); }\n+  void visit (BoolType &) override { gcc_unreachable (); }\n+  void visit (IntType &) override { gcc_unreachable (); }\n+  void visit (UintType &) override { gcc_unreachable (); }\n+  void visit (FloatType &) override { gcc_unreachable (); }\n+  void visit (USizeType &) override { gcc_unreachable (); }\n+  void visit (ISizeType &) override { gcc_unreachable (); }\n+  void visit (ErrorType &) override { gcc_unreachable (); }\n+  void visit (CharType &) override { gcc_unreachable (); }\n+  void visit (ReferenceType &) override { gcc_unreachable (); }\n+  void visit (PointerType &) override { gcc_unreachable (); }\n   void visit (ParamType &) override { gcc_unreachable (); }\n   void visit (StrType &) override { gcc_unreachable (); }\n   void visit (NeverType &) override { gcc_unreachable (); }\n   void visit (PlaceholderType &) override { gcc_unreachable (); }\n   void visit (ProjectionType &) override { gcc_unreachable (); }\n+  void visit (DynamicObjectType &) override { gcc_unreachable (); }\n \n   // tuple-structs\n   void visit (ADTType &type) override;\n@@ -89,25 +90,26 @@ class TypeCheckMethodCallExpr : private TyVisitor\n     return checker.resolved;\n   }\n \n-  void visit (InferType &type) override { gcc_unreachable (); }\n-  void visit (TupleType &type) override { gcc_unreachable (); }\n-  void visit (ArrayType &type) override { gcc_unreachable (); }\n-  void visit (BoolType &type) override { gcc_unreachable (); }\n-  void visit (IntType &type) override { gcc_unreachable (); }\n-  void visit (UintType &type) override { gcc_unreachable (); }\n-  void visit (FloatType &type) override { gcc_unreachable (); }\n-  void visit (USizeType &type) override { gcc_unreachable (); }\n-  void visit (ISizeType &type) override { gcc_unreachable (); }\n-  void visit (ErrorType &type) override { gcc_unreachable (); }\n-  void visit (ADTType &type) override { gcc_unreachable (); };\n-  void visit (CharType &type) override { gcc_unreachable (); }\n-  void visit (ReferenceType &type) override { gcc_unreachable (); }\n-  void visit (PointerType &type) override { gcc_unreachable (); }\n+  void visit (InferType &) override { gcc_unreachable (); }\n+  void visit (TupleType &) override { gcc_unreachable (); }\n+  void visit (ArrayType &) override { gcc_unreachable (); }\n+  void visit (BoolType &) override { gcc_unreachable (); }\n+  void visit (IntType &) override { gcc_unreachable (); }\n+  void visit (UintType &) override { gcc_unreachable (); }\n+  void visit (FloatType &) override { gcc_unreachable (); }\n+  void visit (USizeType &) override { gcc_unreachable (); }\n+  void visit (ISizeType &) override { gcc_unreachable (); }\n+  void visit (ErrorType &) override { gcc_unreachable (); }\n+  void visit (ADTType &) override { gcc_unreachable (); };\n+  void visit (CharType &) override { gcc_unreachable (); }\n+  void visit (ReferenceType &) override { gcc_unreachable (); }\n+  void visit (PointerType &) override { gcc_unreachable (); }\n   void visit (ParamType &) override { gcc_unreachable (); }\n   void visit (StrType &) override { gcc_unreachable (); }\n   void visit (NeverType &) override { gcc_unreachable (); }\n   void visit (PlaceholderType &) override { gcc_unreachable (); }\n   void visit (ProjectionType &) override { gcc_unreachable (); }\n+  void visit (DynamicObjectType &) override { gcc_unreachable (); }\n \n   // FIXME\n   void visit (FnPtr &type) override { gcc_unreachable (); }"}, {"sha": "fa50992ab9c7b75c9c807a0987bfc03a26217a7c", "filename": "gcc/rust/typecheck/rust-tyty-cast.h", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Frust%2Ftypecheck%2Frust-tyty-cast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Frust%2Ftypecheck%2Frust-tyty-cast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-cast.h?ref=de43a0ac6d4d5816a5b59cde78aabce651d43cc8", "patch": "@@ -318,6 +318,17 @@ class BaseCastRules : public TyVisitor\n \t\t   type.as_string ().c_str ());\n   }\n \n+  virtual void visit (DynamicObjectType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"invalid cast [%s] to [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n protected:\n   BaseCastRules (BaseType *base)\n     : mappings (Analysis::Mappings::get ()),\n@@ -566,6 +577,19 @@ class InferCastRules : public BaseCastRules\n     BaseCastRules::visit (type);\n   }\n \n+  void visit (DynamicObjectType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseCastRules::visit (type);\n+  }\n+\n private:\n   BaseType *get_base () override { return base; }\n \n@@ -1273,6 +1297,20 @@ class PlaceholderCastRules : public BaseCastRules\n   PlaceholderType *base;\n };\n \n+class DynamicCastRules : public BaseCastRules\n+{\n+  using Rust::TyTy::BaseCastRules::visit;\n+\n+public:\n+  DynamicCastRules (DynamicObjectType *base) : BaseCastRules (base), base (base)\n+  {}\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  DynamicObjectType *base;\n+};\n+\n } // namespace TyTy\n } // namespace Rust\n "}, {"sha": "030f702e05f816ea282a96cd75840ce8f07d8923", "filename": "gcc/rust/typecheck/rust-tyty-cmp.h", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h?ref=de43a0ac6d4d5816a5b59cde78aabce651d43cc8", "patch": "@@ -375,6 +375,22 @@ class BaseCmp : public TyConstVisitor\n     ok = true;\n   }\n \n+  virtual void visit (const DynamicObjectType &type) override\n+  {\n+    ok = false;\n+    if (emit_error_flag)\n+      {\n+\tLocation ref_locus = mappings->lookup_location (type.get_ref ());\n+\tLocation base_locus\n+\t  = mappings->lookup_location (get_base ()->get_ref ());\n+\tRichLocation r (ref_locus);\n+\tr.add_range (base_locus);\n+\trust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t       get_base ()->as_string ().c_str (),\n+\t\t       type.as_string ().c_str ());\n+      }\n+  }\n+\n protected:\n   BaseCmp (const BaseType *base, bool emit_errors)\n     : mappings (Analysis::Mappings::get ()),\n@@ -622,6 +638,19 @@ class InferCmp : public BaseCmp\n     BaseCmp::visit (type);\n   }\n \n+  void visit (const DynamicObjectType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tok = true;\n+\treturn;\n+      }\n+\n+    BaseCmp::visit (type);\n+  }\n+\n private:\n   const BaseType *get_base () const override { return base; }\n   const InferType *base;\n@@ -1231,6 +1260,33 @@ class PlaceholderCmp : public BaseCmp\n   const PlaceholderType *base;\n };\n \n+class DynamicCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  DynamicCmp (const DynamicObjectType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n+  {}\n+\n+  void visit (const DynamicObjectType &type) override\n+  {\n+    if (base->num_specified_bounds () != type.num_specified_bounds ())\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    ok = base->bounds_compatible (type, ref_locus, false);\n+  }\n+\n+private:\n+  const BaseType *get_base () const override { return base; }\n+\n+  const DynamicObjectType *base;\n+};\n+\n } // namespace TyTy\n } // namespace Rust\n "}, {"sha": "976997db2dcf3670ee7d50234533d1317d646c7a", "filename": "gcc/rust/typecheck/rust-tyty-coercion.h", "status": "modified", "additions": 100, "deletions": 1, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Frust%2Ftypecheck%2Frust-tyty-coercion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Frust%2Ftypecheck%2Frust-tyty-coercion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-coercion.h?ref=de43a0ac6d4d5816a5b59cde78aabce651d43cc8", "patch": "@@ -24,6 +24,7 @@\n #include \"rust-tyty-visitor.h\"\n #include \"rust-hir-map.h\"\n #include \"rust-hir-type-check.h\"\n+#include \"rust-hir-type-bounds.h\"\n \n extern ::Backend *\n rust_get_backend ();\n@@ -331,6 +332,17 @@ class BaseCoercionRules : public TyVisitor\n \t\t   type.as_string ().c_str ());\n   }\n \n+  virtual void visit (DynamicObjectType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n protected:\n   BaseCoercionRules (BaseType *base)\n     : mappings (Analysis::Mappings::get ()),\n@@ -580,6 +592,19 @@ class InferCoercionRules : public BaseCoercionRules\n     BaseCoercionRules::visit (type);\n   }\n \n+  void visit (DynamicObjectType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseCoercionRules::visit (type);\n+  }\n+\n private:\n   BaseType *get_base () override { return base; }\n \n@@ -1106,7 +1131,7 @@ class ReferenceCoercionRules : public BaseCoercionRules\n     auto base_type = base->get_base ();\n     auto other_base_type = type.get_base ();\n \n-    TyTy::BaseType *base_resolved = base_type->unify (other_base_type);\n+    TyTy::BaseType *base_resolved = base_type->coerce (other_base_type);\n     if (base_resolved == nullptr\n \t|| base_resolved->get_kind () == TypeKind::ERROR)\n       {\n@@ -1302,12 +1327,86 @@ class PlaceholderCoercionRules : public BaseCoercionRules\n     : BaseCoercionRules (base), base (base)\n   {}\n \n+  BaseType *coerce (BaseType *other) override final\n+  {\n+    if (!base->can_resolve ())\n+      return BaseCoercionRules::coerce (other);\n+\n+    BaseType *lookup = base->resolve ();\n+    return lookup->unify (other);\n+  }\n+\n+  void visit (PlaceholderType &type) override\n+  {\n+    if (base->get_symbol ().compare (type.get_symbol ()) != 0)\n+      {\n+\tBaseCoercionRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = type.clone ();\n+  }\n+\n+  void visit (InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseCoercionRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+  }\n+\n private:\n   BaseType *get_base () override { return base; }\n \n   PlaceholderType *base;\n };\n \n+class DynamicCoercionRules : public BaseCoercionRules\n+{\n+  using Rust::TyTy::BaseCoercionRules::visit;\n+\n+public:\n+  DynamicCoercionRules (DynamicObjectType *base)\n+    : BaseCoercionRules (base), base (base)\n+  {}\n+\n+  void visit (DynamicObjectType &type) override\n+  {\n+    if (base->num_specified_bounds () != type.num_specified_bounds ())\n+      {\n+\tBaseCoercionRules::visit (type);\n+\treturn;\n+      }\n+\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    if (!base->bounds_compatible (type, ref_locus, true))\n+      {\n+\tBaseCoercionRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+  }\n+\n+  void visit (ADTType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    bool ok = base->bounds_compatible (type, ref_locus, true);\n+    if (!ok)\n+      return;\n+\n+    resolved = base->clone ();\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  DynamicObjectType *base;\n+};\n+\n } // namespace TyTy\n } // namespace Rust\n "}, {"sha": "62689cf180106ed7e9992d1cb64f4e5c9b9e9d3c", "filename": "gcc/rust/typecheck/rust-tyty-rules.h", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h?ref=de43a0ac6d4d5816a5b59cde78aabce651d43cc8", "patch": "@@ -353,6 +353,17 @@ class BaseRules : public TyVisitor\n \t\t   type.as_string ().c_str ());\n   }\n \n+  virtual void visit (DynamicObjectType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n protected:\n   BaseRules (BaseType *base)\n     : mappings (Analysis::Mappings::get ()),\n@@ -601,6 +612,19 @@ class InferRules : public BaseRules\n     BaseRules::visit (type);\n   }\n \n+  void visit (DynamicObjectType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseRules::visit (type);\n+  }\n+\n private:\n   BaseType *get_base () override { return base; }\n \n@@ -1314,6 +1338,48 @@ class PlaceholderRules : public BaseRules\n   PlaceholderType *base;\n };\n \n+class DynamicRules : public BaseRules\n+{\n+  using Rust::TyTy::BaseRules::visit;\n+\n+public:\n+  DynamicRules (DynamicObjectType *base) : BaseRules (base), base (base) {}\n+\n+  void visit (InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+  }\n+\n+  void visit (DynamicObjectType &type) override\n+  {\n+    if (base->num_specified_bounds () != type.num_specified_bounds ())\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    if (!base->bounds_compatible (type, ref_locus, true))\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  DynamicObjectType *base;\n+};\n+\n } // namespace TyTy\n } // namespace Rust\n "}, {"sha": "a51edf49cf9486c432058c0bc4ab254c852ddad4", "filename": "gcc/rust/typecheck/rust-tyty-visitor.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Frust%2Ftypecheck%2Frust-tyty-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Frust%2Ftypecheck%2Frust-tyty-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-visitor.h?ref=de43a0ac6d4d5816a5b59cde78aabce651d43cc8", "patch": "@@ -48,6 +48,7 @@ class TyVisitor\n   virtual void visit (NeverType &type) = 0;\n   virtual void visit (PlaceholderType &type) = 0;\n   virtual void visit (ProjectionType &type) = 0;\n+  virtual void visit (DynamicObjectType &type) = 0;\n };\n \n class TyConstVisitor\n@@ -74,6 +75,7 @@ class TyConstVisitor\n   virtual void visit (const NeverType &type) = 0;\n   virtual void visit (const PlaceholderType &type) = 0;\n   virtual void visit (const ProjectionType &type) = 0;\n+  virtual void visit (const DynamicObjectType &type) = 0;\n };\n \n } // namespace TyTy"}, {"sha": "f4ce501c48c393cedfaa336179e824199c14894b", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 118, "deletions": 15, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=de43a0ac6d4d5816a5b59cde78aabce651d43cc8", "patch": "@@ -63,7 +63,8 @@ BaseType::satisfies_bound (const TypeBoundPredicate &predicate) const\n }\n \n bool\n-BaseType::bounds_compatible (const BaseType &other, Location locus) const\n+BaseType::bounds_compatible (const BaseType &other, Location locus,\n+\t\t\t     bool emit_error) const\n {\n   std::vector<std::reference_wrapper<const TypeBoundPredicate>>\n     unsatisfied_bounds;\n@@ -89,8 +90,9 @@ BaseType::bounds_compatible (const BaseType &other, Location locus) const\n \t    missing_preds += \", \";\n \t}\n \n-      rust_error_at (r, \"bounds not satisfied for %s %<%s%> is not satisfied\",\n-\t\t     other.get_name ().c_str (), missing_preds.c_str ());\n+      if (emit_error)\n+\trust_error_at (r, \"bounds not satisfied for %s %<%s%> is not satisfied\",\n+\t\t       other.get_name ().c_str (), missing_preds.c_str ());\n     }\n \n   return unsatisfied_bounds.size () == 0;\n@@ -2257,6 +2259,107 @@ ProjectionType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n   return projection;\n }\n \n+void\n+DynamicObjectType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+DynamicObjectType::accept_vis (TyConstVisitor &vis) const\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+DynamicObjectType::as_string () const\n+{\n+  return \"dyn [\" + raw_bounds_as_string () + \"]\";\n+}\n+\n+BaseType *\n+DynamicObjectType::unify (BaseType *other)\n+{\n+  DynamicRules r (this);\n+  return r.unify (other);\n+}\n+\n+bool\n+DynamicObjectType::can_eq (const BaseType *other, bool emit_errors) const\n+{\n+  DynamicCmp r (this, emit_errors);\n+  return r.can_eq (other);\n+}\n+\n+BaseType *\n+DynamicObjectType::coerce (BaseType *other)\n+{\n+  DynamicCoercionRules r (this);\n+  return r.coerce (other);\n+}\n+\n+BaseType *\n+DynamicObjectType::cast (BaseType *other)\n+{\n+  DynamicCastRules r (this);\n+  return r.cast (other);\n+}\n+\n+BaseType *\n+DynamicObjectType::clone () const\n+{\n+  return new DynamicObjectType (get_ref (), get_ty_ref (), specified_bounds,\n+\t\t\t\tget_combined_refs ());\n+}\n+\n+std::string\n+DynamicObjectType::get_name () const\n+{\n+  std::string bounds = \"[\" + raw_bounds_as_string () + \"]\";\n+  return \"dyn \" + bounds;\n+}\n+\n+bool\n+DynamicObjectType::is_equal (const BaseType &other) const\n+{\n+  if (get_kind () != other.get_kind ())\n+    return false;\n+\n+  if (num_specified_bounds () != other.num_specified_bounds ())\n+    return false;\n+\n+  return bounds_compatible (other, Location (), false);\n+}\n+\n+const std::vector<const Resolver::TraitItemReference *>\n+DynamicObjectType::get_object_items () const\n+{\n+  std::vector<const Resolver::TraitItemReference *> items;\n+  for (auto &bound : get_specified_bounds ())\n+    {\n+      const Resolver::TraitReference *trait = bound.get ();\n+      for (auto &item : trait->get_trait_items ())\n+\t{\n+\t  if (item.get_trait_item_type ()\n+\t\t== Resolver::TraitItemReference::TraitItemType::FN\n+\t      && item.is_object_safe ())\n+\t    items.push_back (&item);\n+\t}\n+\n+      for (auto &super_trait : trait->get_super_traits ())\n+\t{\n+\t  for (auto &item : super_trait->get_trait_items ())\n+\t    {\n+\t      if (item.get_trait_item_type ()\n+\t\t    == Resolver::TraitItemReference::TraitItemType::FN\n+\t\t  && item.is_object_safe ())\n+\t\titems.push_back (&item);\n+\t    }\n+\t}\n+    }\n+  return items;\n+}\n+\n // rust-tyty-call.h\n \n void\n@@ -2285,14 +2388,14 @@ TypeCheckCallExpr::visit (ADTType &type)\n     BaseType *field_tyty = field->get_field_type ();\n \n     BaseType *arg = Resolver::TypeCheckExpr::Resolve (p, false);\n-    if (arg == nullptr)\n+    if (arg->get_kind () == TyTy::TypeKind::ERROR)\n       {\n \trust_error_at (p->get_locus (), \"failed to resolve argument type\");\n \treturn false;\n       }\n \n-    auto res = field_tyty->unify (arg);\n-    if (res == nullptr)\n+    auto res = field_tyty->coerce (arg);\n+    if (res->get_kind () == TyTy::TypeKind::ERROR)\n       {\n \treturn false;\n       }\n@@ -2340,7 +2443,7 @@ TypeCheckCallExpr::visit (FnType &type)\n   size_t i = 0;\n   call.iterate_params ([&] (HIR::Expr *param) mutable -> bool {\n     auto argument_expr_tyty = Resolver::TypeCheckExpr::Resolve (param, false);\n-    if (argument_expr_tyty == nullptr)\n+    if (argument_expr_tyty->get_kind () == TyTy::TypeKind::ERROR)\n       {\n \trust_error_at (param->get_locus (),\n \t\t       \"failed to resolve type for argument expr in CallExpr\");\n@@ -2353,8 +2456,8 @@ TypeCheckCallExpr::visit (FnType &type)\n     if (i < type.num_params ())\n       {\n \tauto fnparam = type.param_at (i);\n-\tresolved_argument_type = fnparam.second->unify (argument_expr_tyty);\n-\tif (resolved_argument_type == nullptr)\n+\tresolved_argument_type = fnparam.second->coerce (argument_expr_tyty);\n+\tif (argument_expr_tyty->get_kind () == TyTy::TypeKind::ERROR)\n \t  {\n \t    rust_error_at (param->get_locus (),\n \t\t\t   \"Type Resolution failure on parameter\");\n@@ -2405,15 +2508,15 @@ TypeCheckCallExpr::visit (FnPtr &type)\n   call.iterate_params ([&] (HIR::Expr *param) mutable -> bool {\n     auto fnparam = type.param_at (i);\n     auto argument_expr_tyty = Resolver::TypeCheckExpr::Resolve (param, false);\n-    if (argument_expr_tyty == nullptr)\n+    if (argument_expr_tyty->get_kind () == TyTy::TypeKind::ERROR)\n       {\n \trust_error_at (param->get_locus (),\n \t\t       \"failed to resolve type for argument expr in CallExpr\");\n \treturn false;\n       }\n \n-    auto resolved_argument_type = fnparam->unify (argument_expr_tyty);\n-    if (resolved_argument_type == nullptr)\n+    auto resolved_argument_type = fnparam->coerce (argument_expr_tyty);\n+    if (argument_expr_tyty->get_kind () == TyTy::TypeKind::ERROR)\n       {\n \trust_error_at (param->get_locus (),\n \t\t       \"Type Resolution failure on parameter\");\n@@ -2456,15 +2559,15 @@ TypeCheckMethodCallExpr::visit (FnType &type)\n   call.iterate_params ([&] (HIR::Expr *param) mutable -> bool {\n     auto fnparam = type.param_at (i);\n     auto argument_expr_tyty = Resolver::TypeCheckExpr::Resolve (param, false);\n-    if (argument_expr_tyty == nullptr)\n+    if (argument_expr_tyty->get_kind () == TyTy::TypeKind::ERROR)\n       {\n \trust_error_at (param->get_locus (),\n \t\t       \"failed to resolve type for argument expr in CallExpr\");\n \treturn false;\n       }\n \n-    auto resolved_argument_type = fnparam.second->unify (argument_expr_tyty);\n-    if (resolved_argument_type == nullptr)\n+    auto resolved_argument_type = fnparam.second->coerce (argument_expr_tyty);\n+    if (argument_expr_tyty->get_kind () == TyTy::TypeKind::ERROR)\n       {\n \trust_error_at (param->get_locus (),\n \t\t       \"Type Resolution failure on parameter\");"}, {"sha": "7ab2b2ce830615edbb4605acf8952981b6edc889", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 62, "deletions": 6, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=de43a0ac6d4d5816a5b59cde78aabce651d43cc8", "patch": "@@ -26,8 +26,10 @@\n #include \"rust-abi.h\"\n \n namespace Rust {\n+\n namespace Resolver {\n class TraitReference;\n+class TraitItemReference;\n class AssociatedImplTrait;\n } // namespace Resolver\n \n@@ -57,6 +59,7 @@ enum TypeKind\n   NEVER,\n   PLACEHOLDER,\n   PROJECTION,\n+  DYNAMIC,\n   // there are more to add...\n   ERROR\n };\n@@ -128,6 +131,9 @@ class TypeKindFormat\n       case TypeKind::PROJECTION:\n \treturn \"Projection\";\n \n+      case TypeKind::DYNAMIC:\n+\treturn \"Dynamic\";\n+\n       case TypeKind::ERROR:\n \treturn \"ERROR\";\n       }\n@@ -150,6 +156,10 @@ class TypeBoundPredicate\n \n   std::string get_name () const;\n \n+  // check that this predicate is object-safe see:\n+  // https://doc.rust-lang.org/reference/items/traits.html#object-safety\n+  bool is_object_safe (bool emit_error, Location locus) const;\n+\n private:\n   DefId reference;\n   Location locus;\n@@ -173,13 +183,23 @@ class TypeBoundsMappings\n     return specified_bounds;\n   }\n \n-  std::string bounds_as_string () const\n+  size_t num_specified_bounds () const { return specified_bounds.size (); }\n+\n+  std::string raw_bounds_as_string () const\n   {\n     std::string buf;\n-    for (auto &b : specified_bounds)\n-      buf += b.as_string () + \", \";\n+    for (size_t i = 0; i < specified_bounds.size (); i++)\n+      {\n+\tconst TypeBoundPredicate &b = specified_bounds.at (i);\n+\tbool has_next = (i + 1) < specified_bounds.size ();\n+\tbuf += b.get_name () + (has_next ? \" + \" : \"\");\n+      }\n+    return buf;\n+  }\n \n-    return \"bounds:[\" + buf + \"]\";\n+  std::string bounds_as_string () const\n+  {\n+    return \"bounds:[\" + raw_bounds_as_string () + \"]\";\n   }\n \n protected:\n@@ -253,7 +273,8 @@ class BaseType : public TypeBoundsMappings\n \n   bool satisfies_bound (const TypeBoundPredicate &predicate) const;\n \n-  bool bounds_compatible (const BaseType &other, Location locus) const;\n+  bool bounds_compatible (const BaseType &other, Location locus,\n+\t\t\t  bool emit_error) const;\n \n   void inherit_bounds (const BaseType &other);\n \n@@ -608,7 +629,7 @@ class SubstitutionParamMapping\n       }\n     else\n       {\n-\tif (!param->bounds_compatible (*type, locus))\n+\tif (!param->bounds_compatible (*type, locus, true))\n \t  return;\n       }\n \n@@ -1813,6 +1834,41 @@ class ProjectionType : public BaseType, public SubstitutionRef\n   DefId item;\n };\n \n+class DynamicObjectType : public BaseType\n+{\n+public:\n+  DynamicObjectType (HirId ref,\n+\t\t     std::vector<TypeBoundPredicate> specified_bounds,\n+\t\t     std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ref, TypeKind::DYNAMIC, specified_bounds, refs)\n+  {}\n+\n+  DynamicObjectType (HirId ref, HirId ty_ref,\n+\t\t     std::vector<TypeBoundPredicate> specified_bounds,\n+\t\t     std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ty_ref, TypeKind::DYNAMIC, specified_bounds, refs)\n+  {}\n+\n+  void accept_vis (TyVisitor &vis) override;\n+  void accept_vis (TyConstVisitor &vis) const override;\n+\n+  std::string as_string () const override;\n+\n+  BaseType *unify (BaseType *other) override;\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+  BaseType *coerce (BaseType *other) override;\n+  BaseType *cast (BaseType *other) override;\n+  bool is_equal (const BaseType &other) const override;\n+\n+  BaseType *clone () const final override;\n+\n+  std::string get_name () const override final;\n+\n+  // this returns a flat list of items including super trait bounds\n+  const std::vector<const Resolver::TraitItemReference *>\n+  get_object_items () const;\n+};\n+\n } // namespace TyTy\n } // namespace Rust\n "}, {"sha": "a4622b240c4027bf74ebb6ca1913304df9fc0c7f", "filename": "gcc/testsuite/rust/compile/traits10.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits10.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits10.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits10.rs?ref=de43a0ac6d4d5816a5b59cde78aabce651d43cc8", "patch": "@@ -0,0 +1,16 @@\n+struct Foo(i32);\n+\n+trait Bar {\n+    const A: i32 = 123;\n+    fn B();\n+    fn C(&self);\n+}\n+\n+pub fn main() {\n+    let a;\n+    a = Foo(123);\n+\n+    let b: &dyn Bar = &a;\n+    // { dg-error \"trait bound is not object safe\" \"\" { target *-*-* } .-1 }\n+    // { dg-error \"expected\" \"\" { target *-*-* } .-2 }\n+}"}, {"sha": "bf69ff0e5a64d9d65e309ac6d810d25773433dcd", "filename": "gcc/testsuite/rust/compile/traits11.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits11.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits11.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits11.rs?ref=de43a0ac6d4d5816a5b59cde78aabce651d43cc8", "patch": "@@ -0,0 +1,20 @@\n+struct Foo(i32);\n+\n+trait A {\n+    const A: i32 = 123;\n+    fn B();\n+    fn C(&self);\n+}\n+\n+trait B: A {\n+    fn test(&self);\n+}\n+\n+pub fn main() {\n+    let a;\n+    a = Foo(123);\n+\n+    let b: &dyn B = &a;\n+    // { dg-error \"trait bound is not object safe\" \"\" { target *-*-* } .-1 }\n+    // { dg-error \"expected\" \"\" { target *-*-* } .-2 }\n+}"}, {"sha": "e1aef5397fc9cb02e379cd7ba9ce7a3a2945e4ed", "filename": "gcc/testsuite/rust/compile/traits9.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits9.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits9.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits9.rs?ref=de43a0ac6d4d5816a5b59cde78aabce651d43cc8", "patch": "@@ -0,0 +1,13 @@\n+struct Foo(i32);\n+trait Bar {\n+    fn baz(&self);\n+}\n+\n+fn main() {\n+    let a;\n+    a = Foo(123);\n+\n+    let b: &dyn Bar = &a;\n+    // { dg-error \"bounds not satisfied for Foo .Bar. is not satisfied\" \"\" { target *-*-* } .-1 }\n+    // { dg-error \"expected\" \"\" { target *-*-* } .-2 }\n+}"}, {"sha": "1af72a28551d04465d9b25aa8585e66996242cce", "filename": "gcc/testsuite/rust/compile/tuple_struct3.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftuple_struct3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftuple_struct3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftuple_struct3.rs?ref=de43a0ac6d4d5816a5b59cde78aabce651d43cc8", "patch": "@@ -1,5 +1,9 @@\n struct Foo(i32, i32, bool);\n \n fn main() {\n-    let c = Foo(1, 2f32, true); // { dg-error \"expected .i32. got .f32.\" }\n+    let c = Foo(1, 2f32, true);\n+    // { dg-error \"expected .i32. got .f32.\" \"\" { target *-*-* } .-1 }\n+    // { dg-error \"unexpected number of arguments 1 expected 3\" \"\" { target *-*-* } .-2 }\n+    // { dg-error \"failed to lookup type to CallExpr\" \"\" { target *-*-* } .-3 }\n+    // { dg-error \"failed to type resolve expression\" \"\" { target *-*-* } .-4 }\n }"}, {"sha": "f25784a1ebb9b2b48befa93523a833388d385e0b", "filename": "gcc/testsuite/rust/execute/torture/trait5.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait5.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de43a0ac6d4d5816a5b59cde78aabce651d43cc8/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait5.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait5.rs?ref=de43a0ac6d4d5816a5b59cde78aabce651d43cc8", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-output \"123\\n123\\n\" } */\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+struct Foo(i32);\n+trait Bar {\n+    fn baz(&self);\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+}\n+\n+impl Bar for Foo {\n+    fn baz(&self) {\n+        // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+        unsafe {\n+            let a = \"%i\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c, self.0);\n+        }\n+    }\n+}\n+\n+fn static_dispatch<T: Bar>(t: &T) {\n+    t.baz();\n+}\n+\n+fn dynamic_dispatch(t: &dyn Bar) {\n+    t.baz();\n+}\n+\n+fn main() -> i32 {\n+    let a = &Foo(123);\n+    static_dispatch(a);\n+\n+    let b: &dyn Bar = a;\n+    dynamic_dispatch(b);\n+\n+    0\n+}"}]}