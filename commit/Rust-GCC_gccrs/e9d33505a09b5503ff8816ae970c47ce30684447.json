{"sha": "e9d33505a09b5503ff8816ae970c47ce30684447", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTlkMzM1MDVhMDliNTUwM2ZmODgxNmFlOTcwYzQ3Y2UzMDY4NDQ0Nw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-10-30T16:48:37Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-10-30T16:48:37Z"}, "message": "compiler: fix slice/array evaluation order bug\n    \n    There was a phase ordering issue in the handling of \"keyed\" array\n    literal expressions: the lowering phase was canonicalizing the\n    indices/vals before the phase that fixed evaluation order, meaning that\n    the evaluation order was incorrect. The fix is to capture the orginal\n    ordering and use that ordering when doing traversals (there is already\n    something similar being done for struct literal expressions).\n    \n    Fixes golang/go#17640\n    \n    Reviewed-on: https://go-review.googlesource.com/32296\n\nFrom-SVN: r241688", "tree": {"sha": "dbe8fdb330eeb1b6785b676fd16430ff6fb88892", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dbe8fdb330eeb1b6785b676fd16430ff6fb88892"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9d33505a09b5503ff8816ae970c47ce30684447", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9d33505a09b5503ff8816ae970c47ce30684447", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9d33505a09b5503ff8816ae970c47ce30684447", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9d33505a09b5503ff8816ae970c47ce30684447/comments", "author": null, "committer": null, "parents": [{"sha": "48e21b40b5549ddcf2a3e20cde612ed5c52ed3c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48e21b40b5549ddcf2a3e20cde612ed5c52ed3c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48e21b40b5549ddcf2a3e20cde612ed5c52ed3c2"}], "stats": {"total": 252, "additions": 147, "deletions": 105}, "files": [{"sha": "a03ed5852671551d5accd3479643a5e457094455", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9d33505a09b5503ff8816ae970c47ce30684447/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9d33505a09b5503ff8816ae970c47ce30684447/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=e9d33505a09b5503ff8816ae970c47ce30684447", "patch": "@@ -1,4 +1,4 @@\n-4ca21c94f00c620bfde2f924e214c78fe2e1ff69\n+c353ffbe18d1538cac7f2a3fcefb846dbf1a6591\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "4f850598ca02a7f7ec6c254b27d7aa5653b8b40c", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 92, "deletions": 72, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9d33505a09b5503ff8816ae970c47ce30684447/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9d33505a09b5503ff8816ae970c47ce30684447/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=e9d33505a09b5503ff8816ae970c47ce30684447", "patch": "@@ -12202,12 +12202,10 @@ Expression::make_allocation(Type* type, Location location)\n   return new Allocation_expression(type, location);\n }\n \n-// Class Struct_construction_expression.\n-\n-// Traversal.\n+// Class Ordered_value_list.\n \n int\n-Struct_construction_expression::do_traverse(Traverse* traverse)\n+Ordered_value_list::traverse_vals(Traverse* traverse)\n {\n   if (this->vals_ != NULL)\n     {\n@@ -12218,8 +12216,8 @@ Struct_construction_expression::do_traverse(Traverse* traverse)\n \t}\n       else\n \t{\n-\t  for (std::vector<int>::const_iterator p =\n-\t\t this->traverse_order_->begin();\n+\t  for (std::vector<unsigned long>::const_iterator p =\n+\t\t   this->traverse_order_->begin();\n \t       p != this->traverse_order_->end();\n \t       ++p)\n \t    {\n@@ -12229,6 +12227,18 @@ Struct_construction_expression::do_traverse(Traverse* traverse)\n \t    }\n \t}\n     }\n+  return TRAVERSE_CONTINUE;\n+}\n+\n+// Class Struct_construction_expression.\n+\n+// Traversal.\n+\n+int\n+Struct_construction_expression::do_traverse(Traverse* traverse)\n+{\n+  if (this->traverse_vals(traverse) == TRAVERSE_EXIT)\n+    return TRAVERSE_EXIT;\n   if (Type::traverse(this->type_, traverse) == TRAVERSE_EXIT)\n     return TRAVERSE_EXIT;\n   return TRAVERSE_CONTINUE;\n@@ -12239,10 +12249,10 @@ Struct_construction_expression::do_traverse(Traverse* traverse)\n bool\n Struct_construction_expression::is_constant_struct() const\n {\n-  if (this->vals_ == NULL)\n+  if (this->vals() == NULL)\n     return true;\n-  for (Expression_list::const_iterator pv = this->vals_->begin();\n-       pv != this->vals_->end();\n+  for (Expression_list::const_iterator pv = this->vals()->begin();\n+       pv != this->vals()->end();\n        ++pv)\n     {\n       if (*pv != NULL\n@@ -12270,10 +12280,10 @@ Struct_construction_expression::is_constant_struct() const\n bool\n Struct_construction_expression::do_is_immutable() const\n {\n-  if (this->vals_ == NULL)\n+  if (this->vals() == NULL)\n     return true;\n-  for (Expression_list::const_iterator pv = this->vals_->begin();\n-       pv != this->vals_->end();\n+  for (Expression_list::const_iterator pv = this->vals()->begin();\n+       pv != this->vals()->end();\n        ++pv)\n     {\n       if (*pv != NULL && !(*pv)->is_immutable())\n@@ -12287,15 +12297,15 @@ Struct_construction_expression::do_is_immutable() const\n void\n Struct_construction_expression::do_determine_type(const Type_context*)\n {\n-  if (this->vals_ == NULL)\n+  if (this->vals() == NULL)\n     return;\n   const Struct_field_list* fields = this->type_->struct_type()->fields();\n-  Expression_list::const_iterator pv = this->vals_->begin();\n+  Expression_list::const_iterator pv = this->vals()->begin();\n   for (Struct_field_list::const_iterator pf = fields->begin();\n        pf != fields->end();\n        ++pf, ++pv)\n     {\n-      if (pv == this->vals_->end())\n+      if (pv == this->vals()->end())\n \treturn;\n       if (*pv != NULL)\n \t{\n@@ -12305,7 +12315,7 @@ Struct_construction_expression::do_determine_type(const Type_context*)\n     }\n   // Extra values are an error we will report elsewhere; we still want\n   // to determine the type to avoid knockon errors.\n-  for (; pv != this->vals_->end(); ++pv)\n+  for (; pv != this->vals()->end(); ++pv)\n     (*pv)->determine_type_no_context();\n }\n \n@@ -12314,24 +12324,24 @@ Struct_construction_expression::do_determine_type(const Type_context*)\n void\n Struct_construction_expression::do_check_types(Gogo*)\n {\n-  if (this->vals_ == NULL)\n+  if (this->vals() == NULL)\n     return;\n \n   Struct_type* st = this->type_->struct_type();\n-  if (this->vals_->size() > st->field_count())\n+  if (this->vals()->size() > st->field_count())\n     {\n       this->report_error(_(\"too many expressions for struct\"));\n       return;\n     }\n \n   const Struct_field_list* fields = st->fields();\n-  Expression_list::const_iterator pv = this->vals_->begin();\n+  Expression_list::const_iterator pv = this->vals()->begin();\n   int i = 0;\n   for (Struct_field_list::const_iterator pf = fields->begin();\n        pf != fields->end();\n        ++pf, ++pv, ++i)\n     {\n-      if (pv == this->vals_->end())\n+      if (pv == this->vals()->end())\n \t{\n \t  this->report_error(_(\"too few expressions for struct\"));\n \t  break;\n@@ -12355,7 +12365,7 @@ Struct_construction_expression::do_check_types(Gogo*)\n \t  this->set_is_error();\n \t}\n     }\n-  go_assert(pv == this->vals_->end());\n+  go_assert(pv == this->vals()->end());\n }\n \n // Flatten a struct construction expression.  Store the values into\n@@ -12365,16 +12375,16 @@ Expression*\n Struct_construction_expression::do_flatten(Gogo*, Named_object*,\n \t\t\t\t\t   Statement_inserter* inserter)\n {\n-  if (this->vals_ == NULL)\n+  if (this->vals() == NULL)\n     return this;\n \n   // If this is a constant struct, we don't need temporaries.\n   if (this->is_constant_struct())\n     return this;\n \n   Location loc = this->location();\n-  for (Expression_list::iterator pv = this->vals_->begin();\n-       pv != this->vals_->end();\n+  for (Expression_list::iterator pv = this->vals()->begin();\n+       pv != this->vals()->end();\n        ++pv)\n     {\n       if (*pv != NULL)\n@@ -12404,18 +12414,18 @@ Struct_construction_expression::do_get_backend(Translate_context* context)\n   Gogo* gogo = context->gogo();\n \n   Btype* btype = this->type_->get_backend(gogo);\n-  if (this->vals_ == NULL)\n+  if (this->vals() == NULL)\n     return gogo->backend()->zero_expression(btype);\n \n   const Struct_field_list* fields = this->type_->struct_type()->fields();\n-  Expression_list::const_iterator pv = this->vals_->begin();\n+  Expression_list::const_iterator pv = this->vals()->begin();\n   std::vector<Bexpression*> init;\n   for (Struct_field_list::const_iterator pf = fields->begin();\n        pf != fields->end();\n        ++pf)\n     {\n       Btype* fbtype = pf->type()->get_backend(gogo);\n-      if (pv == this->vals_->end())\n+      if (pv == this->vals()->end())\n         init.push_back(gogo->backend()->zero_expression(fbtype));\n       else if (*pv == NULL)\n \t{\n@@ -12441,8 +12451,8 @@ Struct_construction_expression::do_export(Export* exp) const\n {\n   exp->write_c_string(\"convert(\");\n   exp->write_type(this->type_);\n-  for (Expression_list::const_iterator pv = this->vals_->begin();\n-       pv != this->vals_->end();\n+  for (Expression_list::const_iterator pv = this->vals()->begin();\n+       pv != this->vals()->end();\n        ++pv)\n     {\n       exp->write_c_string(\", \");\n@@ -12460,7 +12470,7 @@ Struct_construction_expression::do_dump_expression(\n {\n   ast_dump_context->dump_type(this->type_);\n   ast_dump_context->ostream() << \"{\";\n-  ast_dump_context->dump_expression_list(this->vals_);\n+  ast_dump_context->dump_expression_list(this->vals());\n   ast_dump_context->ostream() << \"}\";\n }\n \n@@ -12481,8 +12491,7 @@ Expression::make_struct_composite_literal(Type* type, Expression_list* vals,\n int\n Array_construction_expression::do_traverse(Traverse* traverse)\n {\n-  if (this->vals_ != NULL\n-      && this->vals_->traverse(traverse) == TRAVERSE_EXIT)\n+  if (this->traverse_vals(traverse) == TRAVERSE_EXIT)\n     return TRAVERSE_EXIT;\n   if (Type::traverse(this->type_, traverse) == TRAVERSE_EXIT)\n     return TRAVERSE_EXIT;\n@@ -12494,15 +12503,15 @@ Array_construction_expression::do_traverse(Traverse* traverse)\n bool\n Array_construction_expression::is_constant_array() const\n {\n-  if (this->vals_ == NULL)\n+  if (this->vals() == NULL)\n     return true;\n \n   // There are no constant constructors for interfaces.\n   if (this->type_->array_type()->element_type()->interface_type() != NULL)\n     return false;\n \n-  for (Expression_list::const_iterator pv = this->vals_->begin();\n-       pv != this->vals_->end();\n+  for (Expression_list::const_iterator pv = this->vals()->begin();\n+       pv != this->vals()->end();\n        ++pv)\n     {\n       if (*pv != NULL\n@@ -12519,10 +12528,10 @@ Array_construction_expression::is_constant_array() const\n bool\n Array_construction_expression::do_is_immutable() const\n {\n-  if (this->vals_ == NULL)\n+  if (this->vals() == NULL)\n     return true;\n-  for (Expression_list::const_iterator pv = this->vals_->begin();\n-       pv != this->vals_->end();\n+  for (Expression_list::const_iterator pv = this->vals()->begin();\n+       pv != this->vals()->end();\n        ++pv)\n     {\n       if (*pv != NULL && !(*pv)->is_immutable())\n@@ -12536,11 +12545,11 @@ Array_construction_expression::do_is_immutable() const\n void\n Array_construction_expression::do_determine_type(const Type_context*)\n {\n-  if (this->vals_ == NULL)\n+  if (this->vals() == NULL)\n     return;\n   Type_context subcontext(this->type_->array_type()->element_type(), false);\n-  for (Expression_list::const_iterator pv = this->vals_->begin();\n-       pv != this->vals_->end();\n+  for (Expression_list::const_iterator pv = this->vals()->begin();\n+       pv != this->vals()->end();\n        ++pv)\n     {\n       if (*pv != NULL)\n@@ -12553,14 +12562,14 @@ Array_construction_expression::do_determine_type(const Type_context*)\n void\n Array_construction_expression::do_check_types(Gogo*)\n {\n-  if (this->vals_ == NULL)\n+  if (this->vals() == NULL)\n     return;\n \n   Array_type* at = this->type_->array_type();\n   int i = 0;\n   Type* element_type = at->element_type();\n-  for (Expression_list::const_iterator pv = this->vals_->begin();\n-       pv != this->vals_->end();\n+  for (Expression_list::const_iterator pv = this->vals()->begin();\n+       pv != this->vals()->end();\n        ++pv, ++i)\n     {\n       if (*pv != NULL\n@@ -12581,16 +12590,16 @@ Expression*\n Array_construction_expression::do_flatten(Gogo*, Named_object*,\n \t\t\t\t\t   Statement_inserter* inserter)\n {\n-  if (this->vals_ == NULL)\n+  if (this->vals() == NULL)\n     return this;\n \n   // If this is a constant array, we don't need temporaries.\n   if (this->is_constant_array())\n     return this;\n \n   Location loc = this->location();\n-  for (Expression_list::iterator pv = this->vals_->begin();\n-       pv != this->vals_->end();\n+  for (Expression_list::iterator pv = this->vals()->begin();\n+       pv != this->vals()->end();\n        ++pv)\n     {\n       if (*pv != NULL)\n@@ -12623,14 +12632,14 @@ Array_construction_expression::get_constructor(Translate_context* context,\n   std::vector<unsigned long> indexes;\n   std::vector<Bexpression*> vals;\n   Gogo* gogo = context->gogo();\n-  if (this->vals_ != NULL)\n+  if (this->vals() != NULL)\n     {\n       size_t i = 0;\n       std::vector<unsigned long>::const_iterator pi;\n       if (this->indexes_ != NULL)\n \tpi = this->indexes_->begin();\n-      for (Expression_list::const_iterator pv = this->vals_->begin();\n-\t   pv != this->vals_->end();\n+      for (Expression_list::const_iterator pv = this->vals()->begin();\n+\t   pv != this->vals()->end();\n \t   ++pv, ++i)\n \t{\n \t  if (this->indexes_ != NULL)\n@@ -12670,13 +12679,13 @@ Array_construction_expression::do_export(Export* exp) const\n {\n   exp->write_c_string(\"convert(\");\n   exp->write_type(this->type_);\n-  if (this->vals_ != NULL)\n+  if (this->vals() != NULL)\n     {\n       std::vector<unsigned long>::const_iterator pi;\n       if (this->indexes_ != NULL)\n \tpi = this->indexes_->begin();\n-      for (Expression_list::const_iterator pv = this->vals_->begin();\n-\t   pv != this->vals_->end();\n+      for (Expression_list::const_iterator pv = this->vals()->begin();\n+\t   pv != this->vals()->end();\n \t   ++pv)\n \t{\n \t  exp->write_c_string(\", \");\n@@ -12717,10 +12726,10 @@ Array_construction_expression::do_dump_expression(\n   this->dump_slice_storage_expression(ast_dump_context);\n   ast_dump_context->ostream() << \"{\" ;\n   if (this->indexes_ == NULL)\n-    ast_dump_context->dump_expression_list(this->vals_);\n+    ast_dump_context->dump_expression_list(this->vals());\n   else\n     {\n-      Expression_list::const_iterator pv = this->vals_->begin();\n+      Expression_list::const_iterator pv = this->vals()->begin();\n       for (std::vector<unsigned long>::const_iterator pi =\n \t     this->indexes_->begin();\n \t   pi != this->indexes_->end();\n@@ -13349,7 +13358,7 @@ Composite_literal_expression::lower_struct(Gogo* gogo, Type* type)\n \n   size_t field_count = st->field_count();\n   std::vector<Expression*> vals(field_count);\n-  std::vector<int>* traverse_order = new(std::vector<int>);\n+  std::vector<unsigned long>* traverse_order = new(std::vector<unsigned long>);\n   Expression_list::const_iterator p = this->vals_->begin();\n   Expression* external_expr = NULL;\n   const Named_object* external_no = NULL;\n@@ -13481,7 +13490,7 @@ Composite_literal_expression::lower_struct(Gogo* gogo, Type* type)\n                     type->named_type()->message_name().c_str());\n \n       vals[index] = val;\n-      traverse_order->push_back(index);\n+      traverse_order->push_back(static_cast<unsigned long>(index));\n     }\n \n   if (!this->all_are_names_)\n@@ -13512,15 +13521,16 @@ Composite_literal_expression::lower_struct(Gogo* gogo, Type* type)\n   return ret;\n }\n \n-// Used to sort an index/value array.\n+// Index/value/traversal-order triple.\n \n-class Index_value_compare\n-{\n- public:\n-  bool\n-  operator()(const std::pair<unsigned long, Expression*>& a,\n-\t     const std::pair<unsigned long, Expression*>& b)\n-  { return a.first < b.first; }\n+struct IVT_triple {\n+  unsigned long index;\n+  unsigned long traversal_order;\n+  Expression* expr;\n+  IVT_triple(unsigned long i, unsigned long to, Expression *e)\n+      : index(i), traversal_order(to), expr(e) { }\n+  bool operator<(const IVT_triple& other) const\n+  { return this->index < other.index; }\n };\n \n // Lower an array composite literal.\n@@ -13624,35 +13634,45 @@ Composite_literal_expression::lower_array(Type* type)\n       indexes = NULL;\n     }\n \n+  std::vector<unsigned long>* traverse_order = NULL;\n   if (indexes_out_of_order)\n     {\n-      typedef std::vector<std::pair<unsigned long, Expression*> > V;\n+      typedef std::vector<IVT_triple> V;\n \n       V v;\n       v.reserve(indexes->size());\n       std::vector<unsigned long>::const_iterator pi = indexes->begin();\n+      unsigned long torder = 0;\n       for (Expression_list::const_iterator pe = vals->begin();\n \t   pe != vals->end();\n-\t   ++pe, ++pi)\n-\tv.push_back(std::make_pair(*pi, *pe));\n+\t   ++pe, ++pi, ++torder)\n+\tv.push_back(IVT_triple(*pi, torder, *pe));\n \n-      std::sort(v.begin(), v.end(), Index_value_compare());\n+      std::sort(v.begin(), v.end());\n \n       delete indexes;\n       delete vals;\n+\n       indexes = new std::vector<unsigned long>();\n       indexes->reserve(v.size());\n       vals = new Expression_list();\n       vals->reserve(v.size());\n+      traverse_order = new std::vector<unsigned long>();\n+      traverse_order->reserve(v.size());\n \n       for (V::const_iterator p = v.begin(); p != v.end(); ++p)\n \t{\n-\t  indexes->push_back(p->first);\n-\t  vals->push_back(p->second);\n+\t  indexes->push_back(p->index);\n+\t  vals->push_back(p->expr);\n+\t  traverse_order->push_back(p->traversal_order);\n \t}\n     }\n \n-  return this->make_array(type, indexes, vals);\n+  Expression* ret = this->make_array(type, indexes, vals);\n+  Array_construction_expression* ace = ret->array_literal();\n+  if (ace != NULL && traverse_order != NULL)\n+    ace->set_traverse_order(traverse_order);\n+  return ret;\n }\n \n // Actually build the array composite literal. This handles"}, {"sha": "a02fd19feb34d855979d5767b7ef352c1854367d", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 54, "deletions": 32, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9d33505a09b5503ff8816ae970c47ce30684447/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9d33505a09b5503ff8816ae970c47ce30684447/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=e9d33505a09b5503ff8816ae970c47ce30684447", "patch": "@@ -3232,31 +3232,64 @@ class Composite_literal_expression : public Parser_expression\n   std::vector<bool> key_path_;\n };\n \n-// Construct a struct.\n+// Helper/mixin class for struct and array construction expressions;\n+// encapsulates a list of values plus an optional traversal order\n+// recording the order in which the values should be visited.\n \n-class Struct_construction_expression : public Expression\n+class Ordered_value_list\n {\n  public:\n-  Struct_construction_expression(Type* type, Expression_list* vals,\n-\t\t\t\t Location location)\n-    : Expression(EXPRESSION_STRUCT_CONSTRUCTION, location),\n-      type_(type), vals_(vals), traverse_order_(NULL)\n+  Ordered_value_list(Expression_list* vals)\n+      : vals_(vals), traverse_order_(NULL)\n   { }\n \n+  Expression_list*\n+  vals() const\n+  { return this->vals_; }\n+\n+  int\n+  traverse_vals(Traverse* traverse);\n+\n+  // Get the traversal order (may be NULL)\n+  std::vector<unsigned long>*\n+  traverse_order()\n+  { return traverse_order_; }\n+\n   // Set the traversal order, used to ensure that we implement the\n   // order of evaluation rules.  Takes ownership of the argument.\n   void\n-  set_traverse_order(std::vector<int>* traverse_order)\n+  set_traverse_order(std::vector<unsigned long>* traverse_order)\n   { this->traverse_order_ = traverse_order; }\n \n-  // Return whether this is a constant initializer.\n+ private:\n+  // The list of values, in order of the fields in the struct or in\n+  // order of indices in an array. A NULL value of vals_ means that\n+  // all fields/slots should be zero-initialized; a single NULL entry\n+  // in the list means that the corresponding field or array slot\n+  // should be zero-initialized.\n+  Expression_list* vals_;\n+  // If not NULL, the order in which to traverse vals_.  This is used\n+  // so that we implement the order of evaluation rules correctly.\n+  std::vector<unsigned long>* traverse_order_;\n+};\n+\n+// Construct a struct.\n+\n+class Struct_construction_expression : public Expression,\n+\t\t\t\t       public Ordered_value_list\n+{\n+ public:\n+  Struct_construction_expression(Type* type, Expression_list* vals,\n+\t\t\t\t Location location)\n+      : Expression(EXPRESSION_STRUCT_CONSTRUCTION, location),\n+\tOrdered_value_list(vals),\n+\ttype_(type)\n+  { }\n+\n+ // Return whether this is a constant initializer.\n   bool\n   is_constant_struct() const;\n \n-  Expression_list*\n-  vals() const\n-  { return this->vals_; }\n-\n  protected:\n   int\n   do_traverse(Traverse* traverse);\n@@ -3279,12 +3312,12 @@ class Struct_construction_expression : public Expression\n   {\n     Struct_construction_expression* ret =\n       new Struct_construction_expression(this->type_,\n-\t\t\t\t\t (this->vals_ == NULL\n+\t\t\t\t\t (this->vals() == NULL\n \t\t\t\t\t  ? NULL\n-\t\t\t\t\t  : this->vals_->copy()),\n+\t\t\t\t\t  : this->vals()->copy()),\n \t\t\t\t\t this->location());\n-    if (this->traverse_order_ != NULL)\n-      ret->set_traverse_order(this->traverse_order_);\n+    if (this->traverse_order() != NULL)\n+      ret->set_traverse_order(this->traverse_order());\n     return ret;\n   }\n \n@@ -3303,27 +3336,23 @@ class Struct_construction_expression : public Expression\n  private:\n   // The type of the struct to construct.\n   Type* type_;\n-  // The list of values, in order of the fields in the struct.  A NULL\n-  // entry means that the field should be zero-initialized.\n-  Expression_list* vals_;\n-  // If not NULL, the order in which to traverse vals_.  This is used\n-  // so that we implement the order of evaluation rules correctly.\n-  std::vector<int>* traverse_order_;\n };\n \n // Construct an array.  This class is not used directly; instead we\n // use the child classes, Fixed_array_construction_expression and\n // Slice_construction_expression.\n \n-class Array_construction_expression : public Expression\n+class Array_construction_expression : public Expression,\n+\t\t\t\t      public Ordered_value_list\n {\n  protected:\n   Array_construction_expression(Expression_classification classification,\n \t\t\t\tType* type,\n \t\t\t\tconst std::vector<unsigned long>* indexes,\n \t\t\t\tExpression_list* vals, Location location)\n     : Expression(classification, location),\n-      type_(type), indexes_(indexes), vals_(vals)\n+      Ordered_value_list(vals),\n+      type_(type), indexes_(indexes)\n   { go_assert(indexes == NULL || indexes->size() == vals->size()); }\n \n  public:\n@@ -3334,12 +3363,7 @@ class Array_construction_expression : public Expression\n   // Return the number of elements.\n   size_t\n   element_count() const\n-  { return this->vals_ == NULL ? 0 : this->vals_->size(); }\n-\n-  // The list of values.\n-  Expression_list*\n-  vals() const\n-  { return this->vals_; }\n+  { return this->vals() == NULL ? 0 : this->vals()->size(); }\n \n protected:\n   virtual int\n@@ -3385,8 +3409,6 @@ class Array_construction_expression : public Expression\n   // The list of indexes into the array, one for each value.  This may\n   // be NULL, in which case the indexes start at zero and increment.\n   const std::vector<unsigned long>* indexes_;\n-  // The list of values.  This may be NULL if there are no values.\n-  Expression_list* vals_;\n };\n \n // Construct a fixed array."}]}