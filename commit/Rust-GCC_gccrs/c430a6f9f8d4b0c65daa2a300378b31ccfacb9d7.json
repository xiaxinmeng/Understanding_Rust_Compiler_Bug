{"sha": "c430a6f9f8d4b0c65daa2a300378b31ccfacb9d7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzQzMGE2ZjlmOGQ0YjBjNjVkYWEyYTMwMDM3OGIzMWNjZmFjYjlkNw==", "commit": {"author": {"name": "Daniel Franke", "email": "franke.daniel@gmail.com", "date": "2009-06-07T17:33:34Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2009-06-07T17:33:34Z"}, "message": "re PR fortran/25104 ([F2003] Non-initialization expr. as case-selector)\n\n2009-06-07  Daniel Franke  <franke.daniel@gmail.com>\n\n        PR fortran/25104\n        PR fortran/29962\n        * array.c (gfc_append_constructor): Added NULL-check.\n        * check.c (gfc_check_spread): Check DIM.\n        (gfc_check_unpack): Check that the ARRAY arguments provides\n        enough values for MASK.\n        * intrinsic.h (gfc_simplify_spread): New prototype.\n        (gfc_simplify_unpack): Likewise.\n        * intrinsic.c (add_functions): Added new simplifier callbacks.\n        * simplify.c (gfc_simplify_spread): New.\n        (gfc_simplify_unpack): New.\n        * expr.c (check_transformational): Allow additional\n        * transformational\n        intrinsics in initialization expression.\n\n2009-06-07  Daniel Franke  <franke.daniel@gmail.com>\n\n        PR fortran/25104\n        PR fortran/29962\n        * gfortran.dg/spread_init_expr.f03: New.\n        * gfortran.dg/unpack_init_expr.f03: New.\n        * gfortran.dg/intrinsic_argument_conformance_2.f90: Adjusted\n        error message.\n\nFrom-SVN: r148250", "tree": {"sha": "48c9eeaebfafed289ed9dd624607342231223647", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/48c9eeaebfafed289ed9dd624607342231223647"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c430a6f9f8d4b0c65daa2a300378b31ccfacb9d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c430a6f9f8d4b0c65daa2a300378b31ccfacb9d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c430a6f9f8d4b0c65daa2a300378b31ccfacb9d7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c430a6f9f8d4b0c65daa2a300378b31ccfacb9d7/comments", "author": {"login": "dfranke76", "id": 15729164, "node_id": "MDQ6VXNlcjE1NzI5MTY0", "avatar_url": "https://avatars.githubusercontent.com/u/15729164?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dfranke76", "html_url": "https://github.com/dfranke76", "followers_url": "https://api.github.com/users/dfranke76/followers", "following_url": "https://api.github.com/users/dfranke76/following{/other_user}", "gists_url": "https://api.github.com/users/dfranke76/gists{/gist_id}", "starred_url": "https://api.github.com/users/dfranke76/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dfranke76/subscriptions", "organizations_url": "https://api.github.com/users/dfranke76/orgs", "repos_url": "https://api.github.com/users/dfranke76/repos", "events_url": "https://api.github.com/users/dfranke76/events{/privacy}", "received_events_url": "https://api.github.com/users/dfranke76/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a16d978fca0146aebb9e2ec46236d3cd03554695", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a16d978fca0146aebb9e2ec46236d3cd03554695", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a16d978fca0146aebb9e2ec46236d3cd03554695"}], "stats": {"total": 275, "additions": 264, "deletions": 11}, "files": [{"sha": "0a737bfd1e91994f688d3144ba8c8ff3798ea118", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c430a6f9f8d4b0c65daa2a300378b31ccfacb9d7/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c430a6f9f8d4b0c65daa2a300378b31ccfacb9d7/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=c430a6f9f8d4b0c65daa2a300378b31ccfacb9d7", "patch": "@@ -1,3 +1,19 @@\n+2009-06-07  Daniel Franke  <franke.daniel@gmail.com>\n+\n+\tPR fortran/25104\n+\tPR fortran/29962\n+\t* array.c (gfc_append_constructor): Added NULL-check.\n+\t* check.c (gfc_check_spread): Check DIM.\n+\t(gfc_check_unpack): Check that the ARRAY arguments provides enough\n+\tvalues for MASK.\n+\t* intrinsic.h (gfc_simplify_spread): New prototype.\n+\t(gfc_simplify_unpack): Likewise.\n+\t* intrinsic.c (add_functions): Added new simplifier callbacks.\n+\t* simplify.c (gfc_simplify_spread): New.\n+\t(gfc_simplify_unpack): New.\n+\t* expr.c (check_transformational): Allow additional transformational\n+\tintrinsics in initialization expression.\n+\n 2009-06-07  Daniel Franke  <franke.daniel@gmail.com>\n \n \tPR fortran/25104"}, {"sha": "4d3345f3fd4347206b796db2a6f6fc3ca0e87a28", "filename": "gcc/fortran/array.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c430a6f9f8d4b0c65daa2a300378b31ccfacb9d7/gcc%2Ffortran%2Farray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c430a6f9f8d4b0c65daa2a300378b31ccfacb9d7/gcc%2Ffortran%2Farray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farray.c?ref=c430a6f9f8d4b0c65daa2a300378b31ccfacb9d7", "patch": "@@ -607,7 +607,8 @@ gfc_append_constructor (gfc_expr *base, gfc_expr *new_expr)\n \n   c->expr = new_expr;\n \n-  if (new_expr->ts.type != base->ts.type || new_expr->ts.kind != base->ts.kind)\n+  if (new_expr\n+      && (new_expr->ts.type != base->ts.type || new_expr->ts.kind != base->ts.kind))\n     gfc_internal_error (\"gfc_append_constructor(): New node has wrong kind\");\n }\n "}, {"sha": "103c9417790c30e51ee908492e5d10ddb17a19af", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 56, "deletions": 5, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c430a6f9f8d4b0c65daa2a300378b31ccfacb9d7/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c430a6f9f8d4b0c65daa2a300378b31ccfacb9d7/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=c430a6f9f8d4b0c65daa2a300378b31ccfacb9d7", "patch": "@@ -2816,6 +2816,18 @@ gfc_check_spread (gfc_expr *source, gfc_expr *dim, gfc_expr *ncopies)\n   if (dim_check (dim, 1, false) == FAILURE)\n     return FAILURE;\n \n+  /* dim_rank_check() does not apply here.  */\n+  if (dim \n+      && dim->expr_type == EXPR_CONSTANT\n+      && (mpz_cmp_ui (dim->value.integer, 1) < 0\n+\t  || mpz_cmp_ui (dim->value.integer, source->rank + 1) > 0))\n+    {\n+      gfc_error (\"'%s' argument of '%s' intrinsic at %L is not a valid \"\n+\t\t \"dimension index\", gfc_current_intrinsic_arg[1],\n+\t\t gfc_current_intrinsic, &dim->where);\n+      return FAILURE;\n+    }\n+\n   if (type_check (ncopies, 2, BT_INTEGER) == FAILURE)\n     return FAILURE;\n \n@@ -3120,6 +3132,8 @@ gfc_check_ubound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind)\n gfc_try\n gfc_check_unpack (gfc_expr *vector, gfc_expr *mask, gfc_expr *field)\n {\n+  mpz_t vector_size;\n+\n   if (rank_check (vector, 0, 1) == FAILURE)\n     return FAILURE;\n \n@@ -3132,10 +3146,45 @@ gfc_check_unpack (gfc_expr *vector, gfc_expr *mask, gfc_expr *field)\n   if (same_type_check (vector, 0, field, 2) == FAILURE)\n     return FAILURE;\n \n+  if (mask->expr_type == EXPR_ARRAY\n+      && gfc_array_size (vector, &vector_size) == SUCCESS)\n+    {\n+      int mask_true_count = 0;\n+      gfc_constructor *mask_ctor = mask->value.constructor;\n+      while (mask_ctor)\n+\t{\n+\t  if (mask_ctor->expr->expr_type != EXPR_CONSTANT)\n+\t    {\n+\t      mask_true_count = 0;\n+\t      break;\n+\t    }\n+\n+\t  if (mask_ctor->expr->value.logical)\n+\t    mask_true_count++;\n+\n+\t  mask_ctor = mask_ctor->next;\n+\t}\n+\n+      if (mpz_get_si (vector_size) < mask_true_count)\n+\t{\n+\t  gfc_error (\"'%s' argument of '%s' intrinsic at %L must \"\n+\t\t     \"provide at least as many elements as there \"\n+\t\t     \"are .TRUE. values in '%s' (%ld/%d)\",\n+\t\t     gfc_current_intrinsic_arg[0], gfc_current_intrinsic,\n+\t\t     &vector->where, gfc_current_intrinsic_arg[1],\n+\t\t     mpz_get_si (vector_size), mask_true_count);\n+\t  return FAILURE;\n+\t}\n+\n+      mpz_clear (vector_size);\n+    }\n+\n   if (mask->rank != field->rank && field->rank != 0)\n     {\n-      gfc_error (\"FIELD argument at %L of UNPACK must have the same rank as \"\n-\t\t \"MASK or be a scalar\", &field->where);\n+      gfc_error (\"'%s' argument of '%s' intrinsic at %L must have \"\n+\t\t \"the same rank as '%s' or be a scalar\", \n+\t\t gfc_current_intrinsic_arg[2], gfc_current_intrinsic,\n+\t\t &field->where, gfc_current_intrinsic_arg[1]);\n       return FAILURE;\n     }\n \n@@ -3145,9 +3194,11 @@ gfc_check_unpack (gfc_expr *vector, gfc_expr *mask, gfc_expr *field)\n       for (i = 0; i < field->rank; i++)\n \tif (! identical_dimen_shape (mask, i, field, i))\n \t{\n-\t  gfc_error (\"Different shape in dimension %d for MASK and FIELD \"\n-\t\t     \"arguments of UNPACK at %L\", mask->rank, &field->where);\n-\t  return FAILURE;\n+\t  gfc_error (\"'%s' and '%s' arguments of '%s' intrinsic at %L \"\n+\t\t     \"must have identical shape.\", \n+\t\t     gfc_current_intrinsic_arg[2],\n+\t\t     gfc_current_intrinsic_arg[1], gfc_current_intrinsic,\n+\t\t     &field->where);\n \t}\n     }\n "}, {"sha": "f76c35ea4f155e21da359767b97f5075133c57e8", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c430a6f9f8d4b0c65daa2a300378b31ccfacb9d7/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c430a6f9f8d4b0c65daa2a300378b31ccfacb9d7/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=c430a6f9f8d4b0c65daa2a300378b31ccfacb9d7", "patch": "@@ -2130,7 +2130,8 @@ check_transformational (gfc_expr *e)\n   static const char * const trans_func_f2003[] =  {\n     \"all\", \"any\", \"count\", \"dot_product\", \"matmul\", \"null\", \"pack\",\n     \"product\", \"repeat\", \"reshape\", \"selected_char_kind\", \"selected_int_kind\",\n-    \"selected_real_kind\", \"sum\", \"transfer\", \"transpose\", \"trim\", NULL\n+    \"selected_real_kind\", \"spread\", \"sum\", \"transfer\", \"transpose\",\n+    \"trim\", \"unpack\", NULL\n   };\n \n   int i;"}, {"sha": "014ea11d3e83160c0410b9f0a1415b8c8d1b9025", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c430a6f9f8d4b0c65daa2a300378b31ccfacb9d7/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c430a6f9f8d4b0c65daa2a300378b31ccfacb9d7/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=c430a6f9f8d4b0c65daa2a300378b31ccfacb9d7", "patch": "@@ -2433,7 +2433,7 @@ add_functions (void)\n   make_generic (\"spacing\", GFC_ISYM_SPACING, GFC_STD_F95);\n \n   add_sym_3 (\"spread\", GFC_ISYM_SPREAD, CLASS_TRANSFORMATIONAL, ACTUAL_NO, BT_REAL, dr, GFC_STD_F95,\n-\t     gfc_check_spread, NULL, gfc_resolve_spread,\n+\t     gfc_check_spread, gfc_simplify_spread, gfc_resolve_spread,\n \t     src, BT_REAL, dr, REQUIRED, dm, BT_INTEGER, ii, REQUIRED,\n \t     ncopies, BT_INTEGER, di, REQUIRED);\n \n@@ -2575,7 +2575,7 @@ add_functions (void)\n   make_generic (\"unlink\", GFC_ISYM_UNLINK, GFC_STD_GNU);\n \n   add_sym_3 (\"unpack\", GFC_ISYM_UNPACK, CLASS_TRANSFORMATIONAL, ACTUAL_NO, BT_REAL, dr, GFC_STD_F95,\n-\t     gfc_check_unpack, NULL, gfc_resolve_unpack,\n+\t     gfc_check_unpack, gfc_simplify_unpack, gfc_resolve_unpack,\n \t     v, BT_REAL, dr, REQUIRED, msk, BT_LOGICAL, dl, REQUIRED,\n \t     f, BT_REAL, dr, REQUIRED);\n "}, {"sha": "4ae15783fc179074f13cba2962e189ddf2fccc75", "filename": "gcc/fortran/intrinsic.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c430a6f9f8d4b0c65daa2a300378b31ccfacb9d7/gcc%2Ffortran%2Fintrinsic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c430a6f9f8d4b0c65daa2a300378b31ccfacb9d7/gcc%2Ffortran%2Fintrinsic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.h?ref=c430a6f9f8d4b0c65daa2a300378b31ccfacb9d7", "patch": "@@ -318,6 +318,7 @@ gfc_expr *gfc_simplify_sinh (gfc_expr *);\n gfc_expr *gfc_simplify_size (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_sngl (gfc_expr *);\n gfc_expr *gfc_simplify_spacing (gfc_expr *);\n+gfc_expr *gfc_simplify_spread (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_sqrt (gfc_expr *);\n gfc_expr *gfc_simplify_sum (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_tan (gfc_expr *);\n@@ -328,6 +329,7 @@ gfc_expr *gfc_simplify_transfer (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_transpose (gfc_expr *);\n gfc_expr *gfc_simplify_trim (gfc_expr *);\n gfc_expr *gfc_simplify_ubound (gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_expr *gfc_simplify_unpack (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_verify (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_xor (gfc_expr *, gfc_expr *);\n "}, {"sha": "18ce099ae77fbc655d984de7ab8962315ea838a5", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c430a6f9f8d4b0c65daa2a300378b31ccfacb9d7/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c430a6f9f8d4b0c65daa2a300378b31ccfacb9d7/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=c430a6f9f8d4b0c65daa2a300378b31ccfacb9d7", "patch": "@@ -5037,6 +5037,99 @@ gfc_simplify_spacing (gfc_expr *x)\n }\n \n \n+gfc_expr *\n+gfc_simplify_spread (gfc_expr *source, gfc_expr *dim_expr, gfc_expr *ncopies_expr)\n+{\n+  gfc_expr *result = 0L;\n+  int i, j, dim, ncopies;\n+\n+  if ((!gfc_is_constant_expr (source)\n+       && !is_constant_array_expr (source))\n+      || !gfc_is_constant_expr (dim_expr)\n+      || !gfc_is_constant_expr (ncopies_expr))\n+    return NULL;\n+\n+  gcc_assert (dim_expr->ts.type == BT_INTEGER);\n+  gfc_extract_int (dim_expr, &dim);\n+  dim -= 1;   /* zero-base DIM */\n+\n+  gcc_assert (ncopies_expr->ts.type == BT_INTEGER);\n+  gfc_extract_int (ncopies_expr, &ncopies);\n+  ncopies = MAX (ncopies, 0);\n+\n+  if (source->expr_type == EXPR_CONSTANT)\n+    {\n+      gcc_assert (dim == 0);\n+\n+      result = gfc_start_constructor (source->ts.type,\n+\t\t\t\t      source->ts.kind,\n+\t\t\t\t      &source->where);\n+      result->rank = 1;\n+      result->shape = gfc_get_shape (result->rank);\n+      mpz_init_set_si (result->shape[0], ncopies);\n+\n+      for (i = 0; i < ncopies; ++i)\n+        gfc_append_constructor (result, gfc_copy_expr (source));\n+    }\n+  else if (source->expr_type == EXPR_ARRAY)\n+    {\n+      int result_size, rstride[GFC_MAX_DIMENSIONS], extent[GFC_MAX_DIMENSIONS];\n+      gfc_constructor *ctor, *source_ctor, *result_ctor;\n+\n+      gcc_assert (source->rank < GFC_MAX_DIMENSIONS);\n+      gcc_assert (dim >= 0 && dim <= source->rank);\n+\n+      result = gfc_start_constructor (source->ts.type,\n+\t\t\t\t      source->ts.kind,\n+\t\t\t\t      &source->where);\n+      result->rank = source->rank + 1;\n+      result->shape = gfc_get_shape (result->rank);\n+\n+      result_size = 1;\n+      for (i = 0, j = 0; i < result->rank; ++i)\n+\t{\n+\t  if (i != dim)\n+\t    mpz_init_set (result->shape[i], source->shape[j++]);\n+\t  else\n+\t    mpz_init_set_si (result->shape[i], ncopies);\n+\n+\t  extent[i] = mpz_get_si (result->shape[i]);\n+\t  rstride[i] = (i == 0) ? 1 : rstride[i-1] * extent[i-1];\n+\t  result_size *= extent[i];\n+\t}\n+\n+      for (i = 0; i < result_size; ++i)\n+\tgfc_append_constructor (result, NULL);\n+\n+      source_ctor = source->value.constructor;\n+      result_ctor = result->value.constructor;\n+      while (source_ctor)\n+\t{\n+\t  ctor = result_ctor;\n+\n+\t  for (i = 0; i < ncopies; ++i)\n+\t  {\n+\t    ctor->expr = gfc_copy_expr (source_ctor->expr);\n+\t    ADVANCE (ctor, rstride[dim]);\n+\t  }\n+\n+\t  ADVANCE (result_ctor, (dim == 0 ? ncopies : 1));\n+\t  ADVANCE (source_ctor, 1);\n+\t}\n+    }\n+  else\n+    /* FIXME: Returning here avoids a regression in array_simplify_1.f90.\n+       Replace NULL with gcc_unreachable() after implementing\n+       gfc_simplify_cshift(). */\n+    return NULL;\n+\n+  if (source->ts.type == BT_CHARACTER)\n+    result->ts.cl = source->ts.cl;\n+\n+  return result;\n+}\n+\n+\n gfc_expr *\n gfc_simplify_sqrt (gfc_expr *e)\n {\n@@ -5431,6 +5524,54 @@ gfc_simplify_ubound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind)\n }\n \n \n+gfc_expr *\n+gfc_simplify_unpack (gfc_expr *vector, gfc_expr *mask, gfc_expr *field)\n+{\n+  gfc_expr *result, *e;\n+  gfc_constructor *vector_ctor, *mask_ctor, *field_ctor;\n+\n+  if (!is_constant_array_expr (vector)\n+      || !is_constant_array_expr (mask)\n+      || (!gfc_is_constant_expr (field)\n+\t  && !is_constant_array_expr(field)))\n+    return NULL;\n+\n+  result = gfc_start_constructor (vector->ts.type,\n+\t\t\t\t  vector->ts.kind,\n+\t\t\t\t  &vector->where);\n+  result->rank = mask->rank;\n+  result->shape = gfc_copy_shape (mask->shape, mask->rank);\n+\n+  if (vector->ts.type == BT_CHARACTER)\n+    result->ts.cl = vector->ts.cl;\n+\n+  vector_ctor = vector->value.constructor;\n+  mask_ctor = mask->value.constructor;\n+  field_ctor = field->expr_type == EXPR_ARRAY ? field->value.constructor : NULL;\n+\n+  while (mask_ctor)\n+    {\n+      if (mask_ctor->expr->value.logical)\n+\t{\n+\t  gcc_assert (vector_ctor);\n+\t  e = gfc_copy_expr (vector_ctor->expr);\n+\t  ADVANCE (vector_ctor, 1);\n+\t}\n+      else if (field->expr_type == EXPR_ARRAY)\n+\te = gfc_copy_expr (field_ctor->expr);\n+      else\n+\te = gfc_copy_expr (field);\n+\n+      gfc_append_constructor (result, e);\n+\n+      ADVANCE (mask_ctor, 1);\n+      ADVANCE (field_ctor, 1);\n+    }\n+\n+  return result;\n+}\n+\n+\n gfc_expr *\n gfc_simplify_verify (gfc_expr *s, gfc_expr *set, gfc_expr *b, gfc_expr *kind)\n {"}, {"sha": "10445db8048e2cee2b7786acd3582771de06cfed", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c430a6f9f8d4b0c65daa2a300378b31ccfacb9d7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c430a6f9f8d4b0c65daa2a300378b31ccfacb9d7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c430a6f9f8d4b0c65daa2a300378b31ccfacb9d7", "patch": "@@ -1,3 +1,12 @@\n+2009-06-07  Daniel Franke  <franke.daniel@gmail.com>\n+\n+\tPR fortran/25104\n+\tPR fortran/29962\n+\t* gfortran.dg/spread_init_expr.f03: New.\n+\t* gfortran.dg/unpack_init_expr.f03: New.\n+\t* gfortran.dg/intrinsic_argument_conformance_2.f90: Adjusted\n+\terror message.\n+\n 2009-06-07  Daniel Franke  <franke.daniel@gmail.com>\n \n \tPR fortran/25104"}, {"sha": "daff64f8065f2c585778851bbb06177500f57566", "filename": "gcc/testsuite/gfortran.dg/intrinsic_argument_conformance_2.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c430a6f9f8d4b0c65daa2a300378b31ccfacb9d7/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_argument_conformance_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c430a6f9f8d4b0c65daa2a300378b31ccfacb9d7/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_argument_conformance_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_argument_conformance_2.f90?ref=c430a6f9f8d4b0c65daa2a300378b31ccfacb9d7", "patch": "@@ -39,6 +39,6 @@ program main\n   if (any(eoshift(foo,dim=1,shift=1,boundary=(/42.0,-7.0/))/= 0)) call abort() ! { dg-error \"must be a scalar\" }\n   if (any(eoshift(tempn(2:1),dim=1,shift=1,boundary=(/42.0,-7.0/))/= 0)) call abort() ! { dg-error \"must be a scalar\" }\n \n-  if (any(unpack(tempv,tempv(1:0)/=0,tempv) /= -47)) call abort() ! { dg-error \"Different shape\" }\n-  if (any(unpack(tempv(5:4),tempv(1:0)/=0,tempv) /= -47)) call abort() ! { dg-error \"Different shape\" }\n+  if (any(unpack(tempv,tempv(1:0)/=0,tempv) /= -47)) call abort() ! { dg-error \"must have identical shape\" }\n+  if (any(unpack(tempv(5:4),tempv(1:0)/=0,tempv) /= -47)) call abort() ! { dg-error \"must have identical shape\" }\n end program main"}, {"sha": "a8bdc5e19ee5c4451b09ca5d9620c41b5751e2b6", "filename": "gcc/testsuite/gfortran.dg/spread_init_expr.f03", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c430a6f9f8d4b0c65daa2a300378b31ccfacb9d7/gcc%2Ftestsuite%2Fgfortran.dg%2Fspread_init_expr.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c430a6f9f8d4b0c65daa2a300378b31ccfacb9d7/gcc%2Ftestsuite%2Fgfortran.dg%2Fspread_init_expr.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fspread_init_expr.f03?ref=c430a6f9f8d4b0c65daa2a300378b31ccfacb9d7", "patch": "@@ -0,0 +1,17 @@\n+! { dg-do \"run\" }\n+\n+  INTEGER, PARAMETER :: n = 5\n+  INTEGER, PARAMETER :: a1(n) = SPREAD(1, 1, n)\n+  INTEGER, PARAMETER :: a2(n, 3) = SPREAD([1,2,3], DIM=1, NCOPIES=n)\n+  INTEGER, PARAMETER :: a3(3, n) = SPREAD([1,2,3], DIM=2, NCOPIES=n)\n+\n+  IF (ANY(a1 /= [ 1, 1, 1, 1, 1 ])) CALL abort()\n+\n+  IF (ANY(a2(:, 1) /= 1)) CALL abort()\n+  IF (ANY(a2(:, 2) /= 2)) CALL abort()\n+  IF (ANY(a2(:, 3) /= 3)) CALL abort()\n+\n+  IF (ANY(a3(1, :) /= 1)) CALL abort()\n+  IF (ANY(a3(2, :) /= 2)) CALL abort()\n+  IF (ANY(a3(3, :) /= 3)) CALL abort()\n+END"}, {"sha": "78460d19a633c0610201c6d5063926cad0e52a9b", "filename": "gcc/testsuite/gfortran.dg/unpack_init_expr.f03", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c430a6f9f8d4b0c65daa2a300378b31ccfacb9d7/gcc%2Ftestsuite%2Fgfortran.dg%2Funpack_init_expr.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c430a6f9f8d4b0c65daa2a300378b31ccfacb9d7/gcc%2Ftestsuite%2Fgfortran.dg%2Funpack_init_expr.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Funpack_init_expr.f03?ref=c430a6f9f8d4b0c65daa2a300378b31ccfacb9d7", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do \"run\" }\n+!\n+! Example from F2003, sec 13.7.125\n+!\n+  INTEGER, PARAMETER :: m(3,3) = RESHAPE ([1,0,0,0,1,0,0,0,1], [3,3])\n+  INTEGER, PARAMETER :: v(3)   = [1,2,3]\n+  LOGICAL, PARAMETER :: F = .FALSE., T = .TRUE.\n+  LOGICAL, PARAMETER :: q(3,3) = RESHAPE ([F,T,F,T,F,F,F,F,T], [3,3])\n+\n+  INTEGER, PARAMETER :: r1(3,3) = UNPACK (V, MASK=Q, FIELD=M)\n+  INTEGER, PARAMETER :: r2(3,3) = UNPACK (V, MASK=Q, FIELD=0)\n+\n+  IF (ANY (r1 /= RESHAPE ([1,1,0,2,1,0,0,0,3], [3,3]))) CALL ABORT()\n+  IF (ANY (r2 /= RESHAPE ([0,1,0,2,0,0,0,0,3], [3,3]))) CALL ABORT()\n+END"}]}