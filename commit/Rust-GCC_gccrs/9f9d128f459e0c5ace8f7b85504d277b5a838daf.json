{"sha": "9f9d128f459e0c5ace8f7b85504d277b5a838daf", "node_id": "C_kwDOANBUbNoAKDlmOWQxMjhmNDU5ZTBjNWFjZThmN2I4NTUwNGQyNzdiNWE4MzhkYWY", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2022-11-25T12:48:17Z"}, "committer": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2022-11-25T12:48:17Z"}, "message": "libgomp: Add no-target-region rev offload test + fix plugin-nvptx\n\nOpenMP permits that a 'target device(ancestor:1)' is called without being\nenclosed in a target region - using the current device (i.e. the host) in\nthat case.  This commit adds a testcase for this.\n\nIn case of nvptx, the missing on-device 'GOMP_target_ext' call causes that\nit and also the associated on-device GOMP_REV_OFFLOAD_VAR variable are not\nlinked in from nvptx's libgomp.a. Thus, handle the failing cuModuleGetGlobal\ngracefully by disabling reverse offload and assuming that the failure is fine.\n\nlibgomp/ChangeLog:\n\n\t* plugin/plugin-nvptx.c (GOMP_OFFLOAD_load_image): Use unsigned int\n\tfor 'i' to match 'fn_entries'; regard absent GOMP_REV_OFFLOAD_VAR\n\tas valid and the code having no reverse-offload code.\n\t* testsuite/libgomp.c-c++-common/reverse-offload-2.c: New test.", "tree": {"sha": "c935998f0c1a3490cd5beec437d84a01ea14e0f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c935998f0c1a3490cd5beec437d84a01ea14e0f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9f9d128f459e0c5ace8f7b85504d277b5a838daf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f9d128f459e0c5ace8f7b85504d277b5a838daf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f9d128f459e0c5ace8f7b85504d277b5a838daf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f9d128f459e0c5ace8f7b85504d277b5a838daf/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c16e85d726a7793c05209af031dac0bebf035ab9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c16e85d726a7793c05209af031dac0bebf035ab9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c16e85d726a7793c05209af031dac0bebf035ab9"}], "stats": {"total": 85, "additions": 73, "deletions": 12}, "files": [{"sha": "e803f083591a43ee31c29257c167ad29f028b5ee", "filename": "libgomp/plugin/plugin-nvptx.c", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f9d128f459e0c5ace8f7b85504d277b5a838daf/libgomp%2Fplugin%2Fplugin-nvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f9d128f459e0c5ace8f7b85504d277b5a838daf/libgomp%2Fplugin%2Fplugin-nvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fplugin-nvptx.c?ref=9f9d128f459e0c5ace8f7b85504d277b5a838daf", "patch": "@@ -1390,7 +1390,8 @@ GOMP_OFFLOAD_load_image (int ord, unsigned version, const void *target_data,\n   else if (rev_fn_table)\n     {\n       CUdeviceptr var;\n-      size_t bytes, i;\n+      size_t bytes;\n+      unsigned int i;\n       r = CUDA_CALL_NOCHECK (cuModuleGetGlobal, &var, &bytes, module,\n \t\t\t     \"$offload_func_table\");\n       if (r != CUDA_SUCCESS)\n@@ -1413,24 +1414,35 @@ GOMP_OFFLOAD_load_image (int ord, unsigned version, const void *target_data,\n \n   if (rev_fn_table && *rev_fn_table && dev->rev_data == NULL)\n     {\n-      /* cuMemHostAlloc memory is accessible on the device, if unified-shared\n-\t address is supported; this is assumed - see comment in\n-\t nvptx_open_device for CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING.   */\n-      CUDA_CALL_ASSERT (cuMemHostAlloc, (void **) &dev->rev_data,\n-\t\t\tsizeof (*dev->rev_data), CU_MEMHOSTALLOC_DEVICEMAP);\n-      CUdeviceptr dp = (CUdeviceptr) dev->rev_data;\n+      /* Get the on-device GOMP_REV_OFFLOAD_VAR variable.  It should be\n+\t available but it might be not.  One reason could be: if the user code\n+\t has 'omp target device(ancestor:1)' in pure hostcode, GOMP_target_ext\n+\t is not called on the device and, hence, it and GOMP_REV_OFFLOAD_VAR\n+\t are not linked in.  */\n       CUdeviceptr device_rev_offload_var;\n       size_t device_rev_offload_size;\n       CUresult r = CUDA_CALL_NOCHECK (cuModuleGetGlobal,\n \t\t\t\t      &device_rev_offload_var,\n \t\t\t\t      &device_rev_offload_size, module,\n \t\t\t\t      XSTRING (GOMP_REV_OFFLOAD_VAR));\n       if (r != CUDA_SUCCESS)\n-\tGOMP_PLUGIN_fatal (\"cuModuleGetGlobal error - GOMP_REV_OFFLOAD_VAR: %s\", cuda_error (r));\n-      r = CUDA_CALL_NOCHECK (cuMemcpyHtoD, device_rev_offload_var, &dp,\n-\t\t\t     sizeof (dp));\n-      if (r != CUDA_SUCCESS)\n-\tGOMP_PLUGIN_fatal (\"cuMemcpyHtoD error: %s\", cuda_error (r));\n+\t{\n+\t  free (*rev_fn_table);\n+\t  *rev_fn_table = NULL;\n+\t}\n+      else\n+\t{\n+\t  /* cuMemHostAlloc memory is accessible on the device, if\n+\t     unified-shared address is supported; this is assumed - see comment\n+\t     in nvptx_open_device for CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING. */\n+\t  CUDA_CALL_ASSERT (cuMemHostAlloc, (void **) &dev->rev_data,\n+\t\t\t    sizeof (*dev->rev_data), CU_MEMHOSTALLOC_DEVICEMAP);\n+\t  CUdeviceptr dp = (CUdeviceptr) dev->rev_data;\n+\t  r = CUDA_CALL_NOCHECK (cuMemcpyHtoD, device_rev_offload_var, &dp,\n+\t\t\t\t sizeof (dp));\n+\t  if (r != CUDA_SUCCESS)\n+\t    GOMP_PLUGIN_fatal (\"cuMemcpyHtoD error: %s\", cuda_error (r));\n+\t}\n     }\n \n   nvptx_set_clocktick (module, dev);"}, {"sha": "33bd38481bb26956025aac7c4ceac5c37caa1993", "filename": "libgomp/testsuite/libgomp.c-c++-common/reverse-offload-2.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f9d128f459e0c5ace8f7b85504d277b5a838daf/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Freverse-offload-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f9d128f459e0c5ace8f7b85504d277b5a838daf/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Freverse-offload-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Freverse-offload-2.c?ref=9f9d128f459e0c5ace8f7b85504d277b5a838daf", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-do run }  */\n+/* { dg-additional-options \"-foffload-options=nvptx-none=-misa=sm_35\" { target { offload_target_nvptx } } } */\n+\n+#pragma omp requires reverse_offload\n+\n+int\n+main ()\n+{\n+  int A[10];\n+  int y;\n+\n+  for (int i = 0; i < 10; i++)\n+    A[i] = 2*i;\n+\n+  y = 42;\n+\n+  /* Pointlessly copy to the default device.  */\n+  #pragma omp target data map(to: A)\n+  {\n+    /* Not enclosed in a target region (= i.e. running on the host); the\n+       following is valid - it runs on the current device (= host).  */\n+    #pragma omp target device ( ancestor:1 ) firstprivate(y) map(to: A)\n+    {\n+      if (y != 42)\n+\t__builtin_abort ();\n+      for (int i = 0; i < 10; i++)\n+\tif (A[i] != 2*i)\n+\t  __builtin_abort ();\n+      for (int i = 0; i < 10; i++)\n+\tif (A[i] != 2*i)\n+\t  A[i] = 4*i;\n+      y = 31;\n+    }\n+\n+    if (y != 42)\n+      __builtin_abort ();\n+    for (int i = 0; i < 10; i++)\n+      if (A[i] != 2*i)\n+\t__builtin_abort ();\n+  }\n+\n+  if (y != 42)\n+    __builtin_abort ();\n+  for (int i = 0; i < 10; i++)\n+    if (A[i] != 2*i)\n+      __builtin_abort ();\n+\n+  return 0;\n+}"}]}