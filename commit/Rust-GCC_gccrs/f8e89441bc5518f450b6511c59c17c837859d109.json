{"sha": "f8e89441bc5518f450b6511c59c17c837859d109", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjhlODk0NDFiYzU1MThmNDUwYjY1MTFjNTljMTdjODM3ODU5ZDEwOQ==", "commit": {"author": {"name": "Tom de Vries", "email": "tom@codesourcery.com", "date": "2015-04-17T09:26:59Z"}, "committer": {"name": "Tom de Vries", "email": "vries@gcc.gnu.org", "date": "2015-04-17T09:26:59Z"}, "message": "Postpone expanding va_arg until pass_stdarg\n\n2015-04-17  Tom de Vries  <tom@codesourcery.com>\n\t    Michael Matz  <matz@suse.de>\n\n\t* gimple-iterator.c (update_modified_stmts): Remove static.\n\t* gimple-iterator.h (update_modified_stmts): Declare.\n\t* gimplify.c (gimplify_modify_expr): Handle IFN_VA_ARG.\n\t(gimplify_va_arg_internal): New function.\n\t(gimplify_va_arg_expr): Use IFN_VA_ARG.\n\t* gimplify.h (gimplify_va_arg_internal): Declare.\n\t* internal-fn.c (expand_VA_ARG): New unreachable function.\n\t* internal-fn.def (VA_ARG): New DEF_INTERNAL_FN.\n\t* tree-stdarg.c (gimple_call_ifn_va_arg_p, expand_ifn_va_arg_1)\n\t(expand_ifn_va_arg): New function.\n\t(pass_data_stdarg): Add PROP_gimple_lva to properties_provided field.\n\t(pass_stdarg::execute): Call expand_ifn_va_arg.\n\t(pass_data_lower_vaarg): New pass_data.\n\t(pass_lower_vaarg): New gimple_opt_pass.\n\t(pass_lower_vaarg::gate, pass_lower_vaarg::execute)\n\t(make_pass_lower_vaarg): New function.\n\t* cfgexpand.c (pass_data_expand): Add PROP_gimple_lva to\n\tproperties_required field.\n\t* passes.def (all_passes): Add pass_lower_vaarg.\n\t* tree-pass.h (PROP_gimple_lva): Add define.\n\t(make_pass_lower_vaarg): Declare.\n\n\t* gcc.dg/tree-ssa/stdarg-2.c: Change f15 scan-tree-dump for target\n\tx86_64-*-*.\n\nCo-Authored-By: Michael Matz <matz@suse.de>\n\nFrom-SVN: r222173", "tree": {"sha": "5d4de8b2de7d1bc521bef75e9c0cea144cf87699", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d4de8b2de7d1bc521bef75e9c0cea144cf87699"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8e89441bc5518f450b6511c59c17c837859d109", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8e89441bc5518f450b6511c59c17c837859d109", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8e89441bc5518f450b6511c59c17c837859d109", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8e89441bc5518f450b6511c59c17c837859d109/comments", "author": null, "committer": null, "parents": [{"sha": "1691b2e1ca494eee178a70c73c0f941ff27118f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1691b2e1ca494eee178a70c73c0f941ff27118f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1691b2e1ca494eee178a70c73c0f941ff27118f6"}], "stats": {"total": 351, "additions": 304, "deletions": 47}, "files": [{"sha": "2fb57eae57ca7ff39cf9ec5a1a1187906329a994", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e89441bc5518f450b6511c59c17c837859d109/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e89441bc5518f450b6511c59c17c837859d109/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f8e89441bc5518f450b6511c59c17c837859d109", "patch": "@@ -1,3 +1,28 @@\n+2015-04-17  Tom de Vries  <tom@codesourcery.com>\n+\t    Michael Matz  <matz@suse.de>\n+\n+\t* gimple-iterator.c (update_modified_stmts): Remove static.\n+\t* gimple-iterator.h (update_modified_stmts): Declare.\n+\t* gimplify.c (gimplify_modify_expr): Handle IFN_VA_ARG.\n+\t(gimplify_va_arg_internal): New function.\n+\t(gimplify_va_arg_expr): Use IFN_VA_ARG.\n+\t* gimplify.h (gimplify_va_arg_internal): Declare.\n+\t* internal-fn.c (expand_VA_ARG): New unreachable function.\n+\t* internal-fn.def (VA_ARG): New DEF_INTERNAL_FN.\n+\t* tree-stdarg.c (gimple_call_ifn_va_arg_p, expand_ifn_va_arg_1)\n+\t(expand_ifn_va_arg): New function.\n+\t(pass_data_stdarg): Add PROP_gimple_lva to properties_provided field.\n+\t(pass_stdarg::execute): Call expand_ifn_va_arg.\n+\t(pass_data_lower_vaarg): New pass_data.\n+\t(pass_lower_vaarg): New gimple_opt_pass.\n+\t(pass_lower_vaarg::gate, pass_lower_vaarg::execute)\n+\t(make_pass_lower_vaarg): New function.\n+\t* cfgexpand.c (pass_data_expand): Add PROP_gimple_lva to\n+\tproperties_required field.\n+\t* passes.def (all_passes): Add pass_lower_vaarg.\n+\t* tree-pass.h (PROP_gimple_lva): Add define.\n+\t(make_pass_lower_vaarg): Declare.\n+\n 2015-04-17  Tom de Vries  <tom@codesourcery.com>\n \n \t* fold-const.c (operand_equal_p): Handle INTERNAL_FNs."}, {"sha": "ca491a0d1560e1d9955085b9aa647d9ef8675c1f", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e89441bc5518f450b6511c59c17c837859d109/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e89441bc5518f450b6511c59c17c837859d109/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=f8e89441bc5518f450b6511c59c17c837859d109", "patch": "@@ -5899,7 +5899,8 @@ const pass_data pass_data_expand =\n   TV_EXPAND, /* tv_id */\n   ( PROP_ssa | PROP_gimple_leh | PROP_cfg\n     | PROP_gimple_lcx\n-    | PROP_gimple_lvec ), /* properties_required */\n+    | PROP_gimple_lvec\n+    | PROP_gimple_lva), /* properties_required */\n   PROP_rtl, /* properties_provided */\n   ( PROP_ssa | PROP_trees ), /* properties_destroyed */\n   0, /* todo_flags_start */"}, {"sha": "df29123f538b751414a68a78c0c265591d613b2c", "filename": "gcc/gimple-iterator.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e89441bc5518f450b6511c59c17c837859d109/gcc%2Fgimple-iterator.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e89441bc5518f450b6511c59c17c837859d109/gcc%2Fgimple-iterator.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-iterator.c?ref=f8e89441bc5518f450b6511c59c17c837859d109", "patch": "@@ -72,7 +72,7 @@ update_modified_stmt (gimple stmt)\n \n /* Mark the statements in SEQ as modified, and update them.  */\n \n-static void\n+void\n update_modified_stmts (gimple_seq seq)\n {\n   gimple_stmt_iterator gsi;"}, {"sha": "87e943ae46876be0a2d2fac2c67431e30e21f718", "filename": "gcc/gimple-iterator.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e89441bc5518f450b6511c59c17c837859d109/gcc%2Fgimple-iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e89441bc5518f450b6511c59c17c837859d109/gcc%2Fgimple-iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-iterator.h?ref=f8e89441bc5518f450b6511c59c17c837859d109", "patch": "@@ -90,6 +90,7 @@ extern basic_block gsi_insert_seq_on_edge_immediate (edge, gimple_seq);\n extern void gsi_commit_edge_inserts (void);\n extern void gsi_commit_one_edge_insert (edge, basic_block *);\n extern gphi_iterator gsi_start_phis (basic_block);\n+extern void update_modified_stmts (gimple_seq);\n \n /* Return a new iterator pointing to GIMPLE_SEQ's first statement.  */\n "}, {"sha": "e1ea204916483b353c459a15e4b42b64fd60ebac", "filename": "gcc/gimplify.c", "status": "modified", "additions": 81, "deletions": 30, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e89441bc5518f450b6511c59c17c837859d109/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e89441bc5518f450b6511c59c17c837859d109/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=f8e89441bc5518f450b6511c59c17c837859d109", "patch": "@@ -4564,6 +4564,7 @@ gimplify_modify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n   gimple assign;\n   location_t loc = EXPR_LOCATION (*expr_p);\n   gimple_stmt_iterator gsi;\n+  tree ap = NULL_TREE, ap_copy = NULL_TREE;\n \n   gcc_assert (TREE_CODE (*expr_p) == MODIFY_EXPR\n \t      || TREE_CODE (*expr_p) == INIT_EXPR);\n@@ -4640,6 +4641,27 @@ gimplify_modify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n   if (ret == GS_ERROR)\n     return ret;\n \n+  /* In case of va_arg internal fn wrappped in a WITH_SIZE_EXPR, add the type\n+     size as argument to the the call.  */\n+  if (TREE_CODE (*from_p) == WITH_SIZE_EXPR)\n+    {\n+      tree call = TREE_OPERAND (*from_p, 0);\n+      tree vlasize = TREE_OPERAND (*from_p, 1);\n+\n+      if (TREE_CODE (call) == CALL_EXPR\n+\t  && CALL_EXPR_IFN (call) == IFN_VA_ARG)\n+\t{\n+\t  tree type = TREE_TYPE (call);\n+\t  tree ap = CALL_EXPR_ARG (call, 0);\n+\t  tree tag = CALL_EXPR_ARG (call, 1);\n+\t  tree newcall = build_call_expr_internal_loc (EXPR_LOCATION (call),\n+\t\t\t\t\t\t       IFN_VA_ARG, type, 3, ap,\n+\t\t\t\t\t\t       tag, vlasize);\n+\t  tree *call_p = &(TREE_OPERAND (*from_p, 0));\n+\t  *call_p = newcall;\n+\t}\n+    }\n+\n   /* Now see if the above changed *from_p to something we handle specially.  */\n   ret = gimplify_modify_expr_rhs (expr_p, from_p, to_p, pre_p, post_p,\n \t\t\t\t  want_value);\n@@ -4703,12 +4725,16 @@ gimplify_modify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t  enum internal_fn ifn = CALL_EXPR_IFN (*from_p);\n \t  auto_vec<tree> vargs (nargs);\n \n+\t  if (ifn == IFN_VA_ARG)\n+\t    ap = unshare_expr (CALL_EXPR_ARG (*from_p, 0));\n \t  for (i = 0; i < nargs; i++)\n \t    {\n \t      gimplify_arg (&CALL_EXPR_ARG (*from_p, i), pre_p,\n \t\t\t    EXPR_LOCATION (*from_p));\n \t      vargs.quick_push (CALL_EXPR_ARG (*from_p, i));\n \t    }\n+\t  if (ifn == IFN_VA_ARG)\n+\t    ap_copy = CALL_EXPR_ARG (*from_p, 0);\n \t  call_stmt = gimple_build_call_internal_vec (ifn, vargs);\n \t  gimple_set_location (call_stmt, EXPR_LOCATION (*expr_p));\n \t}\n@@ -4753,6 +4779,17 @@ gimplify_modify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n   gsi = gsi_last (*pre_p);\n   maybe_fold_stmt (&gsi);\n \n+  /* When gimplifying the &ap argument of va_arg, we might end up with\n+       ap.1 = ap\n+       va_arg (&ap.1, 0B)\n+     We need to assign ap.1 back to ap, otherwise va_arg has no effect on\n+     ap.  */\n+  if (ap != NULL_TREE\n+      && TREE_CODE (ap) == ADDR_EXPR\n+      && TREE_CODE (ap_copy) == ADDR_EXPR\n+      && TREE_OPERAND (ap, 0) != TREE_OPERAND (ap_copy, 0))\n+    gimplify_assign (TREE_OPERAND (ap, 0), TREE_OPERAND (ap_copy, 0), pre_p);\n+\n   if (want_value)\n     {\n       *expr_p = TREE_THIS_VOLATILE (*to_p) ? *from_p : unshare_expr (*to_p);\n@@ -9273,16 +9310,53 @@ dummy_object (tree type)\n   return build2 (MEM_REF, type, t, t);\n }\n \n+/* Call the target expander for evaluating a va_arg call of VALIST\n+   and TYPE.  */\n+\n+tree\n+gimplify_va_arg_internal (tree valist, tree type, location_t loc,\n+\t\t\t  gimple_seq *pre_p, gimple_seq *post_p)\n+{\n+  tree have_va_type = TREE_TYPE (valist);\n+  tree cano_type = targetm.canonical_va_list_type (have_va_type);\n+\n+  if (cano_type != NULL_TREE)\n+    have_va_type = cano_type;\n+\n+  /* Make it easier for the backends by protecting the valist argument\n+     from multiple evaluations.  */\n+  if (TREE_CODE (have_va_type) == ARRAY_TYPE)\n+    {\n+      /* For this case, the backends will be expecting a pointer to\n+\t TREE_TYPE (abi), but it's possible we've\n+\t actually been given an array (an actual TARGET_FN_ABI_VA_LIST).\n+\t So fix it.  */\n+      if (TREE_CODE (TREE_TYPE (valist)) == ARRAY_TYPE)\n+\t{\n+\t  tree p1 = build_pointer_type (TREE_TYPE (have_va_type));\n+\t  valist = fold_convert_loc (loc, p1,\n+\t\t\t\t     build_fold_addr_expr_loc (loc, valist));\n+\t}\n+\n+      gimplify_expr (&valist, pre_p, post_p, is_gimple_val, fb_rvalue);\n+    }\n+  else\n+    gimplify_expr (&valist, pre_p, post_p, is_gimple_min_lval, fb_lvalue);\n+\n+  return targetm.gimplify_va_arg_expr (valist, type, pre_p, post_p);\n+}\n+\n /* Gimplify __builtin_va_arg, aka VA_ARG_EXPR, which is not really a\n    builtin function, but a very special sort of operator.  */\n \n enum gimplify_status\n-gimplify_va_arg_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n+gimplify_va_arg_expr (tree *expr_p, gimple_seq *pre_p,\n+\t\t      gimple_seq *post_p ATTRIBUTE_UNUSED)\n {\n   tree promoted_type, have_va_type;\n   tree valist = TREE_OPERAND (*expr_p, 0);\n   tree type = TREE_TYPE (*expr_p);\n-  tree t;\n+  tree t, tag, ap;\n   location_t loc = EXPR_LOCATION (*expr_p);\n \n   /* Verify that valist is of the proper type.  */\n@@ -9334,36 +9408,13 @@ gimplify_va_arg_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n       *expr_p = dummy_object (type);\n       return GS_ALL_DONE;\n     }\n-  else\n-    {\n-      /* Make it easier for the backends by protecting the valist argument\n-\t from multiple evaluations.  */\n-      if (TREE_CODE (have_va_type) == ARRAY_TYPE)\n-\t{\n-\t  /* For this case, the backends will be expecting a pointer to\n-\t     TREE_TYPE (abi), but it's possible we've\n-\t     actually been given an array (an actual TARGET_FN_ABI_VA_LIST).\n-\t     So fix it.  */\n-\t  if (TREE_CODE (TREE_TYPE (valist)) == ARRAY_TYPE)\n-\t    {\n-\t      tree p1 = build_pointer_type (TREE_TYPE (have_va_type));\n-\t      valist = fold_convert_loc (loc, p1,\n-\t\t\t\t\t build_fold_addr_expr_loc (loc, valist));\n-\t    }\n-\n-\t  gimplify_expr (&valist, pre_p, post_p, is_gimple_val, fb_rvalue);\n-\t}\n-      else\n-\tgimplify_expr (&valist, pre_p, post_p, is_gimple_min_lval, fb_lvalue);\n \n-      if (!targetm.gimplify_va_arg_expr)\n-\t/* FIXME: Once most targets are converted we should merely\n-\t   assert this is non-null.  */\n-\treturn GS_ALL_DONE;\n+  /* Transform a VA_ARG_EXPR into an VA_ARG internal function.  */\n+  ap = build_fold_addr_expr_loc (loc, valist);\n+  tag = build_int_cst (build_pointer_type (type), 0);\n+  *expr_p = build_call_expr_internal_loc (loc, IFN_VA_ARG, type, 2, ap, tag);\n \n-      *expr_p = targetm.gimplify_va_arg_expr (valist, type, pre_p, post_p);\n-      return GS_OK;\n-    }\n+  return GS_OK;\n }\n \n /* Build a new GIMPLE_ASSIGN tuple and append it to the end of *SEQ_P."}, {"sha": "bad8e0ffd004b34caf2b27dcb1a438e250df8bc4", "filename": "gcc/gimplify.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e89441bc5518f450b6511c59c17c837859d109/gcc%2Fgimplify.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e89441bc5518f450b6511c59c17c837859d109/gcc%2Fgimplify.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.h?ref=f8e89441bc5518f450b6511c59c17c837859d109", "patch": "@@ -82,6 +82,8 @@ extern void gimplify_function_tree (tree);\n extern enum gimplify_status gimplify_va_arg_expr (tree *, gimple_seq *,\n \t\t\t\t\t\t  gimple_seq *);\n gimple gimplify_assign (tree, tree, gimple_seq *);\n+extern tree gimplify_va_arg_internal (tree, tree, location_t, gimple_seq *,\n+\t\t\t\t      gimple_seq *);\n \n /* Return true if gimplify_one_sizepos doesn't need to gimplify\n    expr (when in TYPE_SIZE{,_UNIT} and similar type/decl size/bitsize"}, {"sha": "0053ed9574910991f21d217b1f2087822b44d64e", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e89441bc5518f450b6511c59c17c837859d109/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e89441bc5518f450b6511c59c17c837859d109/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=f8e89441bc5518f450b6511c59c17c837859d109", "patch": "@@ -1972,6 +1972,15 @@ expand_BUILTIN_EXPECT (gcall *stmt)\n     emit_move_insn (target, val);\n }\n \n+/* IFN_VA_ARG is supposed to be expanded at pass_stdarg.  So this dummy function\n+   should never be called.  */\n+\n+static void\n+expand_VA_ARG (gcall *stmt ATTRIBUTE_UNUSED)\n+{\n+  gcc_unreachable ();\n+}\n+\n /* Routines to expand each internal function, indexed by function number.\n    Each routine has the prototype:\n "}, {"sha": "f557c64247ce1c7e252b0f2097a41101c1d9b973", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e89441bc5518f450b6511c59c17c837859d109/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e89441bc5518f450b6511c59c17c837859d109/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=f8e89441bc5518f450b6511c59c17c837859d109", "patch": "@@ -62,3 +62,4 @@ DEF_INTERNAL_FN (ADD_OVERFLOW, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (SUB_OVERFLOW, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (MUL_OVERFLOW, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (TSAN_FUNC_EXIT, ECF_NOVOPS | ECF_LEAF | ECF_NOTHROW, NULL)\n+DEF_INTERNAL_FN (VA_ARG, 0, NULL)"}, {"sha": "ffa63b5904d7a1380bfdecfcd987900d20590c26", "filename": "gcc/passes.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e89441bc5518f450b6511c59c17c837859d109/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e89441bc5518f450b6511c59c17c837859d109/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=f8e89441bc5518f450b6511c59c17c837859d109", "patch": "@@ -344,6 +344,7 @@ along with GCC; see the file COPYING3.  If not see\n       NEXT_PASS (pass_tm_edges);\n   POP_INSERT_PASSES ()\n   NEXT_PASS (pass_vtable_verify);\n+  NEXT_PASS (pass_lower_vaarg);\n   NEXT_PASS (pass_lower_vector);\n   NEXT_PASS (pass_lower_complex_O0);\n   NEXT_PASS (pass_asan_O0);"}, {"sha": "087f2b9a14a1999be3ca44593d08df41f674a8b4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e89441bc5518f450b6511c59c17c837859d109/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e89441bc5518f450b6511c59c17c837859d109/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f8e89441bc5518f450b6511c59c17c837859d109", "patch": "@@ -1,3 +1,9 @@\n+2015-04-17  Tom de Vries  <tom@codesourcery.com>\n+\t    Michael Matz  <matz@suse.de>\n+\n+\t* gcc.dg/tree-ssa/stdarg-2.c: Change f15 scan-tree-dump for target\n+\tx86_64-*-*.\n+\n 2015-04-17  Yury Gribov  <y.gribov@samsung.com>\n \n \t* c-c++-common/asan/user-section-1.c: New test."}, {"sha": "5a74280f7281814eff9cf221946744c0f6c8e43f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/stdarg-2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e89441bc5518f450b6511c59c17c837859d109/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e89441bc5518f450b6511c59c17c837859d109/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-2.c?ref=f8e89441bc5518f450b6511c59c17c837859d109", "patch": "@@ -288,9 +288,9 @@ f15 (int i, ...)\n   f15_1 (ap);\n   va_end (ap);\n }\n-/* { dg-final { scan-tree-dump \"f15: va_list escapes 0, needs to save \\[148\\] GPR units and \\[1-9\\]\\[0-9\\]* FPR units\" \"stdarg\" { target { { i?86-*-* x86_64-*-* } && { ! { ia32 || llp64 } } } } } } */\n+/* { dg-final { scan-tree-dump \"f15: va_list escapes 0, needs to save \\[148\\] GPR units and \\[1-9\\]\\[0-9\\]* FPR units\" \"stdarg\" { target { { i?86-*-* } && { ! { ia32 || llp64 } } } } } } */\n /* { dg-final { scan-tree-dump \"f15: va_list escapes 0, needs to save \\[148\\] GPR units and \\[1-9\\]\\[0-9\\]* FPR units\" \"stdarg\" { target { powerpc*-*-linux* && { powerpc_fprs && ilp32 } } } } } */\n-/* { dg-final { scan-tree-dump \"f15: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target alpha*-*-linux* } } } */\n+/* { dg-final { scan-tree-dump \"f15: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target { { alpha*-*-linux* } || { { x86_64-*-* } && { ! { ia32 || llp64 } } } } } } } */\n /* { dg-final { scan-tree-dump \"f15: va_list escapes 0, needs to save 1 GPR units and 2 FPR units\" \"stdarg\" { target s390*-*-linux* } } } */\n /* { dg-final { scan-tree-dump-not \"f15: va_list escapes 0, needs to save 0 GPR units\" \"stdarg\" { target { { i?86-*-* x86_64-*-* } && ia32 } } } } */\n /* { dg-final { scan-tree-dump-not \"f15: va_list escapes 0, needs to save 0 GPR units\" \"stdarg\" { target ia64-*-* } } } */"}, {"sha": "172bd8219028a8bdab8a5e8faf8b36e50ca1f90c", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e89441bc5518f450b6511c59c17c837859d109/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e89441bc5518f450b6511c59c17c837859d109/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=f8e89441bc5518f450b6511c59c17c837859d109", "patch": "@@ -221,6 +221,7 @@ class simple_ipa_opt_pass : public opt_pass\n #define PROP_loops\t\t(1 << 11)\t/* preserve loop structures */\n #define PROP_gimple_lvec\t(1 << 12)       /* lowered vector */\n #define PROP_gimple_eomp\t(1 << 13)       /* no OpenMP directives */\n+#define PROP_gimple_lva\t\t(1 << 14)       /* No va_arg internal function.  */\n \n #define PROP_trees \\\n   (PROP_gimple_any | PROP_gimple_lcf | PROP_gimple_leh | PROP_gimple_lomp)\n@@ -589,6 +590,7 @@ extern gimple_opt_pass *make_pass_early_inline (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_inline_parameters (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_update_address_taken (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_convert_switch (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_lower_vaarg (gcc::context *ctxt);\n \n /* Current optimization pass.  */\n extern opt_pass *current_pass;"}, {"sha": "16a9e2cf66f4a1c5ca775fcbbdd288899759c30f", "filename": "gcc/tree-stdarg.c", "status": "modified", "additions": 171, "deletions": 13, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e89441bc5518f450b6511c59c17c837859d109/gcc%2Ftree-stdarg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e89441bc5518f450b6511c59c17c837859d109/gcc%2Ftree-stdarg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-stdarg.c?ref=f8e89441bc5518f450b6511c59c17c837859d109", "patch": "@@ -52,11 +52,14 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-iterator.h\"\n #include \"gimple-walk.h\"\n #include \"gimple-ssa.h\"\n+#include \"gimplify.h\"\n #include \"tree-phinodes.h\"\n #include \"ssa-iterators.h\"\n #include \"stringpool.h\"\n #include \"tree-ssanames.h\"\n+#include \"tree-into-ssa.h\"\n #include \"sbitmap.h\"\n+#include \"tree-cfg.h\"\n #include \"tree-pass.h\"\n #include \"tree-stdarg.h\"\n \n@@ -1016,6 +1019,112 @@ optimize_va_list_gpr_fpr_size (function *fun)\n     }\n }\n \n+/* Return true if STMT is IFN_VA_ARG.  */\n+\n+static bool\n+gimple_call_ifn_va_arg_p (gimple stmt)\n+{\n+  return (is_gimple_call (stmt)\n+\t  && gimple_call_internal_p (stmt)\n+\t  && gimple_call_internal_fn (stmt) == IFN_VA_ARG);\n+}\n+\n+/* Expand IFN_VA_ARGs in FUN.  */\n+\n+static void\n+expand_ifn_va_arg_1 (function *fun)\n+{\n+  bool modified = false;\n+  basic_block bb;\n+  gimple_stmt_iterator i;\n+\n+  FOR_EACH_BB_FN (bb, fun)\n+    for (i = gsi_start_bb (bb); !gsi_end_p (i); gsi_next (&i))\n+      {\n+\tgimple stmt = gsi_stmt (i);\n+\ttree ap, expr, lhs, type;\n+\tgimple_seq pre = NULL, post = NULL;\n+\n+\tif (!gimple_call_ifn_va_arg_p (stmt))\n+\t  continue;\n+\n+\tmodified = true;\n+\n+\ttype = TREE_TYPE (TREE_TYPE (gimple_call_arg (stmt, 1)));\n+\tap = gimple_call_arg (stmt, 0);\n+\tap = build_fold_indirect_ref (ap);\n+\n+\tpush_gimplify_context (false);\n+\n+\texpr = gimplify_va_arg_internal (ap, type, gimple_location (stmt),\n+\t\t\t\t\t &pre, &post);\n+\n+\tlhs = gimple_call_lhs (stmt);\n+\tif (lhs != NULL_TREE)\n+\t  {\n+\t    gcc_assert (useless_type_conversion_p (TREE_TYPE (lhs), type));\n+\n+\t    if (gimple_call_num_args (stmt) == 3)\n+\t      {\n+\t\t/* We've transported the size of with WITH_SIZE_EXPR here as\n+\t\t   the 3rd argument of the internal fn call.  Now reinstate\n+\t\t   it.  */\n+\t\ttree size = gimple_call_arg (stmt, 2);\n+\t\texpr = build2 (WITH_SIZE_EXPR, TREE_TYPE (expr), expr, size);\n+\t      }\n+\n+\t    /* We use gimplify_assign here, rather than gimple_build_assign,\n+\t       because gimple_assign knows how to deal with variable-sized\n+\t       types.  */\n+\t    gimplify_assign (lhs, expr, &pre);\n+\t  }\n+\n+\tpop_gimplify_context (NULL);\n+\n+\tgimple_seq_add_seq (&pre, post);\n+\tupdate_modified_stmts (pre);\n+\n+\t/* Add the sequence after IFN_VA_ARG.  This splits the bb right\n+\t   after IFN_VA_ARG, and adds the sequence in one or more new bbs\n+\t   inbetween.  */\n+\tgimple_find_sub_bbs (pre, &i);\n+\n+\t/* Remove the IFN_VA_ARG gimple_call.  It's the last stmt in the\n+\t   bb.  */\n+\tgsi_remove (&i, true);\n+\tgcc_assert (gsi_end_p (i));\n+\n+\t/* We're walking here into the bbs which contain the expansion of\n+\t   IFN_VA_ARG, and will not contain another IFN_VA_ARG that needs\n+\t   expanding.  We could try to skip walking these bbs, perhaps by\n+\t   walking backwards over gimples and bbs.  */\n+\tbreak;\n+      }\n+\n+  if (!modified)\n+    return;\n+\n+  free_dominance_info (CDI_DOMINATORS);\n+  update_ssa (TODO_update_ssa);\n+}\n+\n+/* Expand IFN_VA_ARGs in FUN, if necessary.  */\n+\n+static void\n+expand_ifn_va_arg (function *fun)\n+{\n+  if ((fun->curr_properties & PROP_gimple_lva) == 0)\n+    expand_ifn_va_arg_1 (fun);\n+\n+#if ENABLE_CHECKING\n+  basic_block bb;\n+  gimple_stmt_iterator i;\n+  FOR_EACH_BB_FN (bb, fun)\n+    for (i = gsi_start_bb (bb); !gsi_end_p (i); gsi_next (&i))\n+      gcc_assert (!gimple_call_ifn_va_arg_p (gsi_stmt (i)));\n+#endif\n+}\n+\n namespace {\n \n const pass_data pass_data_stdarg =\n@@ -1025,7 +1134,7 @@ const pass_data pass_data_stdarg =\n   OPTGROUP_NONE, /* optinfo_flags */\n   TV_NONE, /* tv_id */\n   ( PROP_cfg | PROP_ssa ), /* properties_required */\n-  0, /* properties_provided */\n+  PROP_gimple_lva, /* properties_provided */\n   0, /* properties_destroyed */\n   0, /* todo_flags_start */\n   0, /* todo_flags_finish */\n@@ -1039,18 +1148,13 @@ class pass_stdarg : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  virtual bool gate (function *fun)\n+  virtual bool gate (function *)\n     {\n-      return (flag_stdarg_opt\n-#ifdef ACCEL_COMPILER\n-\t      /* Disable for GCC5 in the offloading compilers, as\n-\t\t va_list and gpr/fpr counter fields are not merged.\n-\t\t In GCC6 when stdarg is lowered late this shouldn't be\n-\t\t an issue.  */\n-\t      && !in_lto_p\n-#endif\n-\t      /* This optimization is only for stdarg functions.  */\n-\t      && fun->stdarg != 0);\n+      /* Always run this pass, in order to expand va_arg internal_fns.  We\n+\t also need to do that if fun->stdarg == 0, because a va_arg may also\n+\t occur in a function without varargs, f.i. if when passing a va_list to\n+\t another function.  */\n+      return true;\n     }\n \n   virtual unsigned int execute (function *);\n@@ -1060,7 +1164,14 @@ class pass_stdarg : public gimple_opt_pass\n unsigned int\n pass_stdarg::execute (function *fun)\n {\n-  optimize_va_list_gpr_fpr_size (fun);\n+  /* TODO: Postpone expand_ifn_va_arg till after\n+     optimize_va_list_gpr_fpr_size.  */\n+  expand_ifn_va_arg (fun);\n+\n+  if (flag_stdarg_opt\n+      /* This optimization is only for stdarg functions.  */\n+      && fun->stdarg != 0)\n+    optimize_va_list_gpr_fpr_size (fun);\n \n   return 0;\n }\n@@ -1072,3 +1183,50 @@ make_pass_stdarg (gcc::context *ctxt)\n {\n   return new pass_stdarg (ctxt);\n }\n+\n+namespace {\n+\n+const pass_data pass_data_lower_vaarg =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"lower_vaarg\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  TV_NONE, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  PROP_gimple_lva, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_lower_vaarg : public gimple_opt_pass\n+{\n+public:\n+  pass_lower_vaarg (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_lower_vaarg, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *)\n+    {\n+      return (cfun->curr_properties & PROP_gimple_lva) == 0;\n+    }\n+\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_lower_vaarg\n+\n+unsigned int\n+pass_lower_vaarg::execute (function *fun)\n+{\n+  expand_ifn_va_arg (fun);\n+  return 0;\n+}\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_lower_vaarg (gcc::context *ctxt)\n+{\n+  return new pass_lower_vaarg (ctxt);\n+}"}]}