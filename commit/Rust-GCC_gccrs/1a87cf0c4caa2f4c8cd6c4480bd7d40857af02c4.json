{"sha": "1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWE4N2NmMGM0Y2FhMmY0YzhjZDZjNDQ4MGJkN2Q0MDg1N2FmMDJjNA==", "commit": {"author": {"name": "Tomas Bily", "email": "tbily@suse.cz", "date": "2008-08-18T16:23:47Z"}, "committer": {"name": "Tomas Bily", "email": "tomby@gcc.gnu.org", "date": "2008-08-18T16:23:47Z"}, "message": "tree.h (IS_CONVERT_EXPR_CODE_P): Renamed to\n\n        * tree.h (IS_CONVERT_EXPR_CODE_P): Renamed to\n        * CONVERT_EXPR_CODE_P.\n        * tree-ssa-threadedge.c (simplify_control_stmt_condition): Use\n        CONVERT_EXPR_P.\n        * tree-data-ref.c (split_constant_offset_1): Likewise.\n        * tree-inline.c (estimate_operator_cost): Use CASE_CONVERT.\n        * tree-sra.c (sra_walk_expr): Likewise.\n        * matrix-reorg.c (ssa_accessed_in_assign_rhs): Likewise.\n        * tree-ssa-loop-niter.c (expand_simple_operations): Likewise.\n        * gimple.h (gimple_assign_cast_p): Use CONVERT_EXPR_CODE_P.\n        * tree-ssa-structalias.c (find_func_aliases, find_func_aliases):\n        * Likewise.\n        * gimple.c (gimple_assign_unary_nop_p): Likewise.\n        * tree-vect-transform.c (vectorizable_type_demotion)\n        (vectorizable_type_promotion): Likewise.\n        * tree-inline.c (expand_call_inline): \n        * tree-ssa-forwprop.c (get_prop_source_stmt, can_propagate_from)\n        (forward_propagate_addr_expr_1, forward_propagate_comparison)\n        (tree_ssa_forward_propagate_single_use_vars): Likewise.\n        * expr.c (expand_expr_real_1): Likewise.\n        * tree-ssa-dom.c (hashable_expr_equal_p,\n        * iterative_hash_hashable_expr)\n        (gimple_assign_unary_useless_conversion_p): Likewise.\n        * tree-stdarg.c (execute_optimize_stdarg): Likewise.\n        * tree-ssa-ccp.c (ccp_fold, fold_gimple_assign): Likewise.\n        * fold-const.c (fold_unary): Likewise.\n        * tree.h (CONVERT_EXPR_P): Likewise.\n        * tree.c (simple_cst_equal, iterative_hash_expr): Likewise.\n        * tree-ssa-loop-im.c (rewrite_bittest): Likewise.\n        * tree-vrp.c: \n        (register_edge_assert_for_2, extract_range_from_unary_expr)\n        (register_edge_assert_for_1): Likewise.\n\n        * cp/tree.c (cp_tree_equal): Likewise.\n\nFrom-SVN: r139204", "tree": {"sha": "7bc02fb458f22cc201c3126fcc40c8e4ad81b090", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7bc02fb458f22cc201c3126fcc40c8e4ad81b090"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4/comments", "author": null, "committer": null, "parents": [{"sha": "3c7c6d39d0edaf25eb66363efc37c1dc0ada736d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c7c6d39d0edaf25eb66363efc37c1dc0ada736d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c7c6d39d0edaf25eb66363efc37c1dc0ada736d"}], "stats": {"total": 139, "additions": 79, "deletions": 60}, "files": [{"sha": "36e15f2e2178847e56074a5600da2e8c6529a584", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4", "patch": "@@ -1,3 +1,36 @@\n+2008-08-18  Tomas Bily  <tbily@suse.cz>\n+\n+\t* tree.h (IS_CONVERT_EXPR_CODE_P): Renamed to CONVERT_EXPR_CODE_P.\n+\t* tree-ssa-threadedge.c (simplify_control_stmt_condition): Use\n+\tCONVERT_EXPR_P.\n+\t* tree-data-ref.c (split_constant_offset_1): Likewise.\n+\t* tree-inline.c (estimate_operator_cost): Use CASE_CONVERT.\n+\t* tree-sra.c (sra_walk_expr): Likewise.\n+\t* matrix-reorg.c (ssa_accessed_in_assign_rhs): Likewise.\n+\t* tree-ssa-loop-niter.c (expand_simple_operations): Likewise.\n+\t* gimple.h (gimple_assign_cast_p): Use CONVERT_EXPR_CODE_P.\n+\t* tree-ssa-structalias.c (find_func_aliases, find_func_aliases):\n+\tLikewise.\n+\t* gimple.c (gimple_assign_unary_nop_p): Likewise.\n+\t* tree-vect-transform.c (vectorizable_type_demotion)\n+\t(vectorizable_type_promotion): Likewise.\n+\t* tree-inline.c (expand_call_inline): \n+\t* tree-ssa-forwprop.c (get_prop_source_stmt, can_propagate_from)\n+\t(forward_propagate_addr_expr_1, forward_propagate_comparison)\n+\t(tree_ssa_forward_propagate_single_use_vars): Likewise.\n+\t* expr.c (expand_expr_real_1): Likewise.\n+\t* tree-ssa-dom.c (hashable_expr_equal_p, iterative_hash_hashable_expr)\n+\t(gimple_assign_unary_useless_conversion_p): Likewise.\n+\t* tree-stdarg.c (execute_optimize_stdarg): Likewise.\n+\t* tree-ssa-ccp.c (ccp_fold, fold_gimple_assign): Likewise.\n+\t* fold-const.c (fold_unary): Likewise.\n+\t* tree.h (CONVERT_EXPR_P): Likewise.\n+\t* tree.c (simple_cst_equal, iterative_hash_expr): Likewise.\n+\t* tree-ssa-loop-im.c (rewrite_bittest): Likewise.\n+\t* tree-vrp.c: \n+\t(register_edge_assert_for_2, extract_range_from_unary_expr)\n+\t(register_edge_assert_for_1): Likewise.\n+\t\n 2008-08-18  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n \n \t* real.h (dconst_e, dconst_third, dconst_sqrt2, dconst_e_ptr,"}, {"sha": "a684338d65426c1abc742a7381d3640ceb3e4570", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4", "patch": "@@ -1,3 +1,7 @@\n+2008-08-18  Tomas Bily  <tbily@suse.cz>\n+\n+\t* tree.c (cp_tree_equal): Use CONVERT_EXPR_CODE_P.\n+\n 2008-08-18  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n \n \t* typeck.c: Update all callers of permerror."}, {"sha": "81682974da01d9dd1fe098a0320eaa757c42fa5f", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4", "patch": "@@ -1739,12 +1739,12 @@ cp_tree_equal (tree t1, tree t2)\n     return false;\n \n   for (code1 = TREE_CODE (t1);\n-       code1 == NOP_EXPR || code1 == CONVERT_EXPR\n+       CONVERT_EXPR_CODE_P (code1)\n \t || code1 == NON_LVALUE_EXPR;\n        code1 = TREE_CODE (t1))\n     t1 = TREE_OPERAND (t1, 0);\n   for (code2 = TREE_CODE (t2);\n-       code2 == NOP_EXPR || code2 == CONVERT_EXPR\n+       CONVERT_EXPR_CODE_P (code2)\n \t || code1 == NON_LVALUE_EXPR;\n        code2 = TREE_CODE (t2))\n     t2 = TREE_OPERAND (t2, 0);"}, {"sha": "908d5641953b2c19acf01117f6158470660958ae", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4", "patch": "@@ -7153,7 +7153,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n   unsignedp = TYPE_UNSIGNED (type);\n \n   ignore = (target == const0_rtx\n-\t    || ((code == NOP_EXPR || code == CONVERT_EXPR \n+\t    || ((CONVERT_EXPR_CODE_P (code)\n \t\t || code == COND_EXPR || code == VIEW_CONVERT_EXPR)\n \t\t&& TREE_CODE (type) == VOID_TYPE));\n "}, {"sha": "cba882675655aa6a5cbe9740aaf853f1378ad20c", "filename": "gcc/fold-const.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4", "patch": "@@ -7625,7 +7625,7 @@ fold_unary (enum tree_code code, tree type, tree op0)\n   arg0 = op0;\n   if (arg0)\n     {\n-      if (code == NOP_EXPR || code == CONVERT_EXPR\n+      if (CONVERT_EXPR_CODE_P (code)\n \t  || code == FLOAT_EXPR || code == ABS_EXPR)\n \t{\n \t  /* Don't use STRIP_NOPS, because signedness of argument type\n@@ -7674,7 +7674,7 @@ fold_unary (enum tree_code code, tree type, tree op0)\n \t     so we don't get into an infinite recursion loop taking the\n \t     conversion out and then back in.  */\n \n-\t  if ((code == NOP_EXPR || code == CONVERT_EXPR\n+\t  if ((CONVERT_EXPR_CODE_P (code)\n \t       || code == NON_LVALUE_EXPR)\n \t      && TREE_CODE (tem) == COND_EXPR\n \t      && TREE_CODE (TREE_OPERAND (tem, 1)) == code"}, {"sha": "9e7d92155b033f700fbf2f2d92d7de3cc87d1fcb", "filename": "gcc/gimple.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4", "patch": "@@ -1899,8 +1899,7 @@ bool\n gimple_assign_unary_nop_p (gimple gs)\n {\n   return (gimple_code (gs) == GIMPLE_ASSIGN\n-          && (gimple_assign_rhs_code (gs) == NOP_EXPR\n-              || gimple_assign_rhs_code (gs) == CONVERT_EXPR\n+          && (CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (gs))\n               || gimple_assign_rhs_code (gs) == NON_LVALUE_EXPR)\n           && gimple_assign_rhs1 (gs) != error_mark_node\n           && (TYPE_MODE (TREE_TYPE (gimple_assign_lhs (gs)))"}, {"sha": "7072edfb1b51fa49bcfa37f4c0b0608ad55d64bb", "filename": "gcc/gimple.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4", "patch": "@@ -1853,8 +1853,7 @@ gimple_assign_cast_p (gimple s)\n   if (is_gimple_assign (s))\n     {\n       enum tree_code sc = gimple_assign_rhs_code (s);\n-      return sc == NOP_EXPR\n-\t     || sc == CONVERT_EXPR\n+      return CONVERT_EXPR_CODE_P (sc)\n \t     || sc == VIEW_CONVERT_EXPR\n \t     || sc == FIX_TRUNC_EXPR;\n     }"}, {"sha": "2299c4ed3f285081be34c46888198afcaf6224f7", "filename": "gcc/matrix-reorg.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4/gcc%2Fmatrix-reorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4/gcc%2Fmatrix-reorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatrix-reorg.c?ref=1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4", "patch": "@@ -658,8 +658,7 @@ ssa_accessed_in_assign_rhs (gimple stmt, struct ssa_acc_in_tree *a)\n \n     case SSA_NAME:\n     case INDIRECT_REF:\n-    case CONVERT_EXPR:\n-    case NOP_EXPR:\n+    CASE_CONVERT:\n     case VIEW_CONVERT_EXPR:\n       ssa_accessed_in_tree (gimple_assign_rhs1 (stmt), a);\n       break;"}, {"sha": "85d0977bce9f9ce474d1e56cf24c93e4db182c76", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4", "patch": "@@ -581,8 +581,7 @@ split_constant_offset_1 (tree type, tree op0, enum tree_code code, tree op1,\n \t   To compute that ARRAY_REF's element size TYPE_SIZE_UNIT, which\n \t   possibly no longer appears in current GIMPLE, might resurface.\n \t   This perhaps could run\n-\t   if (TREE_CODE (var0) == NOP_EXPR\n-\t       || TREE_CODE (var0) == CONVERT_EXPR)\n+\t   if (CONVERT_EXPR_P (var0))\n \t     {\n \t       gimplify_conversion (&var0);\n \t       // Attempt to fill in any within var0 found ARRAY_REF's"}, {"sha": "2f06d22db3f8310f94a7a9339c280ee9e1fcdbd0", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4", "patch": "@@ -2632,10 +2632,9 @@ estimate_operator_cost (enum tree_code code, eni_weights *weights)\n     /* These are \"free\" conversions, or their presumed cost\n        is folded into other operations.  */\n     case RANGE_EXPR:\n-    case CONVERT_EXPR:\n+    CASE_CONVERT:\n     case COMPLEX_EXPR:\n     case PAREN_EXPR:\n-    case NOP_EXPR:\n       return 0;\n \n     /* Assign cost of 1 to usual operations.\n@@ -3346,8 +3345,7 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n   if (is_gimple_assign (stmt))\n     {\n       gcc_assert (gimple_assign_single_p (stmt)\n-\t\t  || gimple_assign_rhs_code (stmt) == NOP_EXPR\n-\t\t  || gimple_assign_rhs_code (stmt) == CONVERT_EXPR);\n+\t\t  || CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (stmt)));\n       TREE_USED (gimple_assign_rhs1 (stmt)) = 1;\n     }\n "}, {"sha": "abe0c9f530d66a1903831a4f44ee888a64474c40", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4", "patch": "@@ -881,8 +881,7 @@ sra_walk_expr (tree *expr_p, gimple_stmt_iterator *gsi, bool is_output,\n \t   outer element, to which walk_tree will bring us next.  */\n \tgoto use_all;\n \n-      case NOP_EXPR:\n-      case CONVERT_EXPR:\n+      CASE_CONVERT:\n \t/* Similarly, a nop explicitly wants to look at an object in a\n \t   type other than the one we've scalarized.  */\n \tgoto use_all;"}, {"sha": "ad6012e8ffc7b13146fb0fa53eb222f05d114001", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4", "patch": "@@ -988,7 +988,7 @@ ccp_fold (gimple stmt)\n \t\t useless_type_conversion_p places for pointer type conversions\n \t\t do not apply here.  Substitution later will only substitute to\n \t\t allowed places.  */\n-\t      if (IS_CONVERT_EXPR_CODE_P (subcode)\n+\t      if (CONVERT_EXPR_CODE_P (subcode)\n \t\t  && POINTER_TYPE_P (TREE_TYPE (lhs))\n \t\t  && POINTER_TYPE_P (TREE_TYPE (op0))\n \t\t  /* Do not allow differences in volatile qualification\n@@ -2781,8 +2781,7 @@ fold_gimple_assign (gimple_stmt_iterator *si)\n           if (valid_gimple_rhs_p (result))\n \t    return result;\n         }\n-      else if ((gimple_assign_rhs_code (stmt) == NOP_EXPR\n-\t\t|| gimple_assign_rhs_code (stmt) == CONVERT_EXPR)\n+      else if (CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (stmt))\n \t       && POINTER_TYPE_P (gimple_expr_type (stmt))\n \t       && POINTER_TYPE_P (TREE_TYPE (gimple_assign_rhs1 (stmt))))\n \t{"}, {"sha": "cd7defa869c262c1cfadb1b3c3ca54c4a1c5169a", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4", "patch": "@@ -381,8 +381,7 @@ hashable_expr_equal_p (const struct hashable_expr *expr0,\n       if (expr0->ops.unary.op != expr1->ops.unary.op)\n         return false;\n \n-      if ((expr0->ops.unary.op == NOP_EXPR\n-           || expr0->ops.unary.op == CONVERT_EXPR\n+      if ((CONVERT_EXPR_CODE_P (expr0->ops.unary.op)\n            || expr0->ops.unary.op == NON_LVALUE_EXPR)\n           && TYPE_UNSIGNED (expr0->type) != TYPE_UNSIGNED (expr1->type))\n         return false;\n@@ -460,8 +459,7 @@ iterative_hash_hashable_expr (const struct hashable_expr *expr, hashval_t val)\n          Don't hash the type, that can lead to having nodes which\n          compare equal according to operand_equal_p, but which\n          have different hash codes.  */\n-      if (expr->ops.unary.op == NOP_EXPR\n-          || expr->ops.unary.op == CONVERT_EXPR\n+      if (CONVERT_EXPR_CODE_P (expr->ops.unary.op)\n           || expr->ops.unary.op == NON_LVALUE_EXPR)\n         val += TYPE_UNSIGNED (expr->type);\n \n@@ -1929,8 +1927,7 @@ static bool\n gimple_assign_unary_useless_conversion_p (gimple gs)\n {\n   if (is_gimple_assign (gs)\n-      && (gimple_assign_rhs_code (gs) == NOP_EXPR\n-          || gimple_assign_rhs_code (gs) == CONVERT_EXPR\n+      && (CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (gs))\n           || gimple_assign_rhs_code (gs) == VIEW_CONVERT_EXPR\n           || gimple_assign_rhs_code (gs) == NON_LVALUE_EXPR))\n     {"}, {"sha": "64eb2d8dcf6f45a4cbce7c13a6f7771fe7dfb034", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4", "patch": "@@ -232,7 +232,7 @@ get_prop_source_stmt (tree name, bool single_use_only, bool *single_use_p)\n \t/* We can look through pointer conversions in the search\n \t   for a useful stmt for the comparison folding.  */\n \trhs = gimple_assign_rhs1 (def_stmt);\n-\tif (IS_CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (def_stmt))\n+\tif (CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (def_stmt))\n \t    && TREE_CODE (rhs) == SSA_NAME\n \t    && POINTER_TYPE_P (TREE_TYPE (gimple_assign_lhs (def_stmt)))\n \t    && POINTER_TYPE_P (TREE_TYPE (rhs)))\n@@ -282,7 +282,7 @@ can_propagate_from (gimple def_stmt)\n      function pointers to be canonicalized and in this case this\n      optimization could eliminate a necessary canonicalization.  */\n   if (is_gimple_assign (def_stmt)\n-      && (IS_CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (def_stmt))))\n+      && (CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (def_stmt))))\n     {\n       tree rhs = gimple_assign_rhs1 (def_stmt);\n       if (POINTER_TYPE_P (TREE_TYPE (rhs))\n@@ -689,7 +689,7 @@ forward_propagate_addr_expr_1 (tree name, tree def_rhs,\n      a conversion to def_rhs type separate, though.  */\n   if (TREE_CODE (lhs) == SSA_NAME\n       && ((rhs_code == SSA_NAME && rhs == name)\n-\t  || IS_CONVERT_EXPR_CODE_P (rhs_code))\n+\t  || CONVERT_EXPR_CODE_P (rhs_code))\n       && useless_type_conversion_p (TREE_TYPE (lhs), TREE_TYPE (def_rhs)))\n     {\n       /* Only recurse if we don't deal with a single use.  */\n@@ -928,7 +928,7 @@ forward_propagate_comparison (gimple stmt)\n \n   /* Conversion of the condition result to another integral type.  */\n   if (is_gimple_assign (use_stmt)\n-      && (IS_CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (use_stmt))\n+      && (CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (use_stmt))\n \t  || TREE_CODE_CLASS (gimple_assign_rhs_code (use_stmt))\n \t     == tcc_comparison\n           || gimple_assign_rhs_code (use_stmt) == TRUTH_NOT_EXPR)\n@@ -937,7 +937,7 @@ forward_propagate_comparison (gimple stmt)\n       tree lhs = gimple_assign_lhs (use_stmt);\n \n       /* We can propagate the condition into a conversion.  */\n-      if (IS_CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (use_stmt)))\n+      if (CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (use_stmt)))\n \t{\n \t  /* Avoid using fold here as that may create a COND_EXPR with\n \t     non-boolean condition as canonical form.  */\n@@ -1138,7 +1138,7 @@ tree_ssa_forward_propagate_single_use_vars (void)\n \t      if (gimple_assign_rhs_code (stmt) == ADDR_EXPR\n \t\t  /* Handle pointer conversions on invariant addresses\n \t\t     as well, as this is valid gimple.  */\n-\t\t  || (IS_CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (stmt))\n+\t\t  || (CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (stmt))\n \t\t      && TREE_CODE (rhs) == ADDR_EXPR\n \t\t      && POINTER_TYPE_P (TREE_TYPE (lhs))))\n \t\t{"}, {"sha": "527b810e3352b078fca7c6e1e7f2f3c257038d44", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4", "patch": "@@ -819,8 +819,7 @@ rewrite_bittest (gimple_stmt_iterator *bsi)\n     return stmt;\n \n   /* There is a conversion in between possibly inserted by fold.  */\n-  if (gimple_assign_rhs_code (stmt1) == NOP_EXPR\n-      || gimple_assign_rhs_code (stmt1) == CONVERT_EXPR)\n+  if (CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (stmt1)))\n     {\n       t = gimple_assign_rhs1 (stmt1);\n       if (TREE_CODE (t) != SSA_NAME"}, {"sha": "33aacae83b59250930ef4c603dd2f9eeda75c49b", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4", "patch": "@@ -1451,8 +1451,7 @@ expand_simple_operations (tree expr)\n \n   switch (code)\n     {\n-    case NOP_EXPR:\n-    case CONVERT_EXPR:\n+    CASE_CONVERT:\n       /* Casts are simple.  */\n       ee = expand_simple_operations (e);\n       return fold_build1 (code, TREE_TYPE (expr), ee);"}, {"sha": "7ed37a59762257340a808cf73621dfb1b8cecda1", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4", "patch": "@@ -3852,7 +3852,7 @@ find_func_aliases (gimple origt)\n \t  if (gimple_assign_rhs_code (t) == POINTER_PLUS_EXPR)\n \t    get_constraint_for_ptr_offset (gimple_assign_rhs1 (t),\n \t\t\t\t\t   gimple_assign_rhs2 (t), &rhsc);\n-\t  else if ((IS_CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (t))\n+\t  else if ((CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (t))\n \t\t    && !(POINTER_TYPE_P (gimple_expr_type (t))\n \t\t\t && !POINTER_TYPE_P (TREE_TYPE (rhsop))))\n \t\t   || gimple_assign_single_p (t))\n@@ -3908,7 +3908,7 @@ find_func_aliases (gimple origt)\n   else if (stmt_escape_type == ESCAPE_BAD_CAST)\n     {\n       gcc_assert (is_gimple_assign (t));\n-      gcc_assert (IS_CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (t))\n+      gcc_assert (CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (t))\n \t\t  || gimple_assign_rhs_code (t) == VIEW_CONVERT_EXPR);\n       make_escape_constraint (gimple_assign_rhs1 (t));\n     }"}, {"sha": "a193d94b01041d45d59dde9fea9fc20a3fee319c", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4", "patch": "@@ -483,8 +483,7 @@ simplify_control_stmt_condition (edge e,\n \n       cached_lhs = fold_binary (cond_code, boolean_type_node, op0, op1);\n       if (cached_lhs)\n-        while (TREE_CODE (cached_lhs) == NOP_EXPR\n-               || TREE_CODE (cached_lhs) == CONVERT_EXPR)\n+\twhile (CONVERT_EXPR_P (cached_lhs))\n           cached_lhs = TREE_OPERAND (cached_lhs, 0);\n \n       fold_undefer_overflow_warnings ((cached_lhs"}, {"sha": "00fce82e7503e1edf1b3f21ad4a39fc8e028dd73", "filename": "gcc/tree-stdarg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4/gcc%2Ftree-stdarg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4/gcc%2Ftree-stdarg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-stdarg.c?ref=1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4", "patch": "@@ -811,7 +811,7 @@ execute_optimize_stdarg (void)\n \n \t\t  if ((gimple_assign_rhs_code (stmt) == POINTER_PLUS_EXPR\n \t\t       && TREE_CODE (gimple_assign_rhs2 (stmt)) == INTEGER_CST)\n-\t\t      || IS_CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (stmt))\n+\t\t      || CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (stmt))\n \t\t      || (get_gimple_rhs_class (gimple_assign_rhs_code (stmt))\n \t\t\t  == GIMPLE_SINGLE_RHS))\n \t\t    check_va_list_escapes (&si, lhs, rhs);"}, {"sha": "29f52b645c21d37acde355be0cddfa678a91d351", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4", "patch": "@@ -4341,7 +4341,7 @@ vectorizable_type_demotion (gimple stmt, gimple_stmt_iterator *gsi,\n     return false;\n \n   code = gimple_assign_rhs_code (stmt);\n-  if (code != NOP_EXPR && code != CONVERT_EXPR)\n+  if (!CONVERT_EXPR_CODE_P (code))\n     return false;\n \n   op0 = gimple_assign_rhs1 (stmt);\n@@ -4366,7 +4366,7 @@ vectorizable_type_demotion (gimple stmt, gimple_stmt_iterator *gsi,\n \t  && INTEGRAL_TYPE_P (TREE_TYPE (op0)))\n \t || (SCALAR_FLOAT_TYPE_P (TREE_TYPE (scalar_dest))\n \t     && SCALAR_FLOAT_TYPE_P (TREE_TYPE (op0))\n-\t     && (code == NOP_EXPR || code == CONVERT_EXPR))))\n+\t     && CONVERT_EXPR_CODE_P (code))))\n     return false;\n \n   /* Check the operands of the operation.  */\n@@ -4534,7 +4534,7 @@ vectorizable_type_promotion (gimple stmt, gimple_stmt_iterator *gsi,\n     return false;\n \n   code = gimple_assign_rhs_code (stmt);\n-  if (code != NOP_EXPR && code != CONVERT_EXPR\n+  if (!CONVERT_EXPR_CODE_P (code)\n       && code != WIDEN_MULT_EXPR)\n     return false;\n \n@@ -4559,7 +4559,7 @@ vectorizable_type_promotion (gimple stmt, gimple_stmt_iterator *gsi,\n \t  && INTEGRAL_TYPE_P (TREE_TYPE (op0)))\n \t || (SCALAR_FLOAT_TYPE_P (TREE_TYPE (scalar_dest))\n \t     && SCALAR_FLOAT_TYPE_P (TREE_TYPE (op0))\n-\t     && (code == CONVERT_EXPR || code == NOP_EXPR))))\n+\t     && CONVERT_EXPR_CODE_P (code))))\n     return false;\n \n   /* Check the operands of the operation.  */"}, {"sha": "383beb1c23ae7c646278ffed545d2ba19586080c", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4", "patch": "@@ -2483,8 +2483,7 @@ extract_range_from_unary_expr (value_range_t *vr, enum tree_code code,\n     }\n \n   /* Handle unary expressions on integer ranges.  */\n-  if ((code == NOP_EXPR\n-       || code == CONVERT_EXPR)\n+  if (CONVERT_EXPR_CODE_P (code)\n       && INTEGRAL_TYPE_P (type)\n       && INTEGRAL_TYPE_P (TREE_TYPE (op0)))\n     {\n@@ -3944,8 +3943,7 @@ register_edge_assert_for_2 (tree name, edge e, gimple_stmt_iterator bsi,\n       /* Extract NAME2 from the (optional) sign-changing cast.  */\n       if (gimple_assign_cast_p (def_stmt))\n \t{\n-\t  if ((gimple_assign_rhs_code (def_stmt) == NOP_EXPR\n-\t       || gimple_assign_rhs_code (def_stmt) == CONVERT_EXPR)\n+\t  if (CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (def_stmt))\n \t      && ! TYPE_UNSIGNED (TREE_TYPE (gimple_assign_rhs1 (def_stmt)))\n \t      && (TYPE_PRECISION (gimple_expr_type (def_stmt))\n \t\t  == TYPE_PRECISION (TREE_TYPE (gimple_assign_rhs1 (def_stmt)))))\n@@ -4098,8 +4096,7 @@ register_edge_assert_for_1 (tree op, enum tree_code code,\n       retval |= register_edge_assert_for_1 (gimple_assign_rhs1 (op_def),\n \t\t\t\t\t    code, e, bsi);\n     }\n-  else if (gimple_assign_rhs_code (op_def) == NOP_EXPR\n-\t   || gimple_assign_rhs_code (op_def) == CONVERT_EXPR)\n+  else if (CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (op_def)))\n     { \n       /* Recurse through the type conversion.  */\n       retval |= register_edge_assert_for_1 (gimple_assign_rhs1 (op_def),"}, {"sha": "4441bc0abe4d7313b49fdf1e6682406cbc5e3a5e", "filename": "gcc/tree.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4", "patch": "@@ -5022,16 +5022,16 @@ simple_cst_equal (const_tree t1, const_tree t2)\n   code1 = TREE_CODE (t1);\n   code2 = TREE_CODE (t2);\n \n-  if (code1 == NOP_EXPR || code1 == CONVERT_EXPR || code1 == NON_LVALUE_EXPR)\n+  if (CONVERT_EXPR_CODE_P (code1) || code1 == NON_LVALUE_EXPR)\n     {\n-      if (code2 == NOP_EXPR || code2 == CONVERT_EXPR\n+      if (CONVERT_EXPR_CODE_P (code2)\n \t  || code2 == NON_LVALUE_EXPR)\n \treturn simple_cst_equal (TREE_OPERAND (t1, 0), TREE_OPERAND (t2, 0));\n       else\n \treturn simple_cst_equal (TREE_OPERAND (t1, 0), t2);\n     }\n \n-  else if (code2 == NOP_EXPR || code2 == CONVERT_EXPR\n+  else if (CONVERT_EXPR_CODE_P (code2)\n \t   || code2 == NON_LVALUE_EXPR)\n     return simple_cst_equal (t1, TREE_OPERAND (t2, 0));\n \n@@ -5338,8 +5338,7 @@ iterative_hash_expr (const_tree t, hashval_t val)\n \t  /* Don't hash the type, that can lead to having nodes which\n \t     compare equal according to operand_equal_p, but which\n \t     have different hash codes.  */\n-\t  if (code == NOP_EXPR\n-\t      || code == CONVERT_EXPR\n+\t  if (CONVERT_EXPR_CODE_P (code)\n \t      || code == NON_LVALUE_EXPR)\n \t    {\n \t      /* Make sure to include signness in the hash computation.  */"}, {"sha": "656fb0a7acfffcb996b22bcd55a88fefc27841a5", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=1a87cf0c4caa2f4c8cd6c4480bd7d40857af02c4", "patch": "@@ -962,11 +962,11 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n #define TREE_HASH(NODE) ((size_t) (NODE) & 0777777)\n \n /* Tests if CODE is a conversion expr (NOP_EXPR or CONVERT_EXPR).  */\n-#define IS_CONVERT_EXPR_CODE_P(CODE)\t\t\t\t\\\n+#define CONVERT_EXPR_CODE_P(CODE)\t\t\t\t\\\n   ((CODE) == NOP_EXPR || (CODE) == CONVERT_EXPR)\n \n /* Similarly, but accept an expressions instead of a tree code.  */\n-#define CONVERT_EXPR_P(EXP)\tIS_CONVERT_EXPR_CODE_P (TREE_CODE (EXP))\n+#define CONVERT_EXPR_P(EXP)\tCONVERT_EXPR_CODE_P (TREE_CODE (EXP))\n \n /* Generate case for NOP_EXPR, CONVERT_EXPR.  */\n "}]}