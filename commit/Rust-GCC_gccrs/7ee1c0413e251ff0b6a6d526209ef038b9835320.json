{"sha": "7ee1c0413e251ff0b6a6d526209ef038b9835320", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2VlMWMwNDEzZTI1MWZmMGI2YTZkNTI2MjA5ZWYwMzhiOTgzNTMyMA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-10-02T18:13:26Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-10-02T18:22:42Z"}, "message": "c++: Hash table iteration for namespace-member spelling suggestions\n\nFor 'no such binding' errors, we iterate over binding levels to find a\nclose match.  At the namespace level we were using DECL_ANTICIPATED to\nskip undeclared builtins.  But (a) there are other unnameable things\nthere and (b) decl-anticipated is about to go away.  This changes the\nnamespace scanning to iterate over the hash table, and look at\nnon-hidden bindings.  This does mean we look at fewer strings\n(hurrarh), but the order we meet them is somewhat 'random'.  Our\ndistance measure is not very fine grained, and a couple of testcases\nchange their suggestion.  I notice for the c/c++ common one, we now\nmatch the output of the C compiler.  For the other one we think 'int'\nand 'int64_t' have the same distance from 'int64', and now meet the\nformer first.  That's a little unfortunate.  If it's too problematic I\nsuppose we could sort the strings via an intermediate array before\nmeasuring distance.\n\n\tgcc/cp/\n\t* name-lookup.c (consider_decl): New, broken out of ...\n\t(consider_binding_level): ... here.  Iterate the hash table for\n\tnamespace bindings.\n\tgcc/testsuite/\n\t* c-c++-common/spellcheck-reserved.c: Adjust diagnostic.\n\t* g++.dg/spellcheck-typenames.C: Adjust diagnostic.", "tree": {"sha": "81c76e02ae7706afc52b305cdfc3fc0cd738b77f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81c76e02ae7706afc52b305cdfc3fc0cd738b77f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ee1c0413e251ff0b6a6d526209ef038b9835320", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ee1c0413e251ff0b6a6d526209ef038b9835320", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ee1c0413e251ff0b6a6d526209ef038b9835320", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ee1c0413e251ff0b6a6d526209ef038b9835320/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9340d1c97b8a7aa47aff677f9b6db4799670f47b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9340d1c97b8a7aa47aff677f9b6db4799670f47b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9340d1c97b8a7aa47aff677f9b6db4799670f47b"}], "stats": {"total": 132, "additions": 87, "deletions": 45}, "files": [{"sha": "4024ceaa74b2d88cecaaeced371e2213f174ec2c", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 84, "deletions": 42, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ee1c0413e251ff0b6a6d526209ef038b9835320/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ee1c0413e251ff0b6a6d526209ef038b9835320/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=7ee1c0413e251ff0b6a6d526209ef038b9835320", "patch": "@@ -6106,6 +6106,39 @@ qualified_namespace_lookup (tree scope, name_lookup *lookup)\n   return found;\n }\n \n+static void\n+consider_decl (tree decl,  best_match <tree, const char *> &bm,\n+\t       bool consider_impl_names)\n+{\n+  /* Skip compiler-generated variables (e.g. __for_begin/__for_end\n+     within range for).  */\n+  if (TREE_CODE (decl) == VAR_DECL && DECL_ARTIFICIAL (decl))\n+    return;\n+\n+  tree suggestion = DECL_NAME (decl);\n+  if (!suggestion)\n+    return;\n+\n+  /* Don't suggest names that are for anonymous aggregate types, as\n+     they are an implementation detail generated by the compiler.  */\n+  if (IDENTIFIER_ANON_P (suggestion))\n+    return;\n+\n+  const char *suggestion_str = IDENTIFIER_POINTER (suggestion);\n+\n+  /* Ignore internal names with spaces in them.  */\n+  if (strchr (suggestion_str, ' '))\n+    return;\n+\n+  /* Don't suggest names that are reserved for use by the\n+     implementation, unless NAME began with an underscore.  */\n+  if (!consider_impl_names\n+      && name_reserved_for_implementation_p (suggestion_str))\n+    return;\n+\n+  bm.consider (suggestion_str);\n+}\n+\n /* Helper function for lookup_name_fuzzy.\n    Traverse binding level LVL, looking for good name matches for NAME\n    (and BM).  */\n@@ -6129,54 +6162,63 @@ consider_binding_level (tree name, best_match <tree, const char *> &bm,\n      with an underscore.  */\n   bool consider_implementation_names = (IDENTIFIER_POINTER (name)[0] == '_');\n \n-  for (tree t = lvl->names; t; t = TREE_CHAIN (t))\n-    {\n-      tree d = t;\n-\n-      /* OVERLOADs or decls from using declaration are wrapped into\n-\t TREE_LIST.  */\n-      if (TREE_CODE (d) == TREE_LIST)\n-\td = OVL_FIRST (TREE_VALUE (d));\n-\n-      /* Don't use bindings from implicitly declared functions,\n-\t as they were likely misspellings themselves.  */\n-      if (TREE_TYPE (d) == error_mark_node)\n-\tcontinue;\n-\n-      /* Skip anticipated decls of builtin functions.  */\n-      if (TREE_CODE (d) == FUNCTION_DECL\n-\t  && fndecl_built_in_p (d)\n-\t  && DECL_ANTICIPATED (d))\n-\tcontinue;\n+  if (lvl->kind != sk_namespace)\n+    for (tree t = lvl->names; t; t = TREE_CHAIN (t))\n+      {\n+\ttree d = t;\n \n-      /* Skip compiler-generated variables (e.g. __for_begin/__for_end\n-\t within range for).  */\n-      if (TREE_CODE (d) == VAR_DECL\n-\t  && DECL_ARTIFICIAL (d))\n-\tcontinue;\n+\t/* OVERLOADs or decls from using declaration are wrapped into\n+\t   TREE_LIST.  */\n+\tif (TREE_CODE (d) == TREE_LIST)\n+\t  d = OVL_FIRST (TREE_VALUE (d));\n \n-      tree suggestion = DECL_NAME (d);\n-      if (!suggestion)\n-\tcontinue;\n-\n-      /* Don't suggest names that are for anonymous aggregate types, as\n-\t they are an implementation detail generated by the compiler.  */\n-      if (IDENTIFIER_ANON_P (suggestion))\n-\tcontinue;\n+\t/* Don't use bindings from implicitly declared functions,\n+\t   as they were likely misspellings themselves.  */\n+\tif (TREE_TYPE (d) == error_mark_node)\n+\t  continue;\n \n-      const char *suggestion_str = IDENTIFIER_POINTER (suggestion);\n+\t/* If we want a typename, ignore non-types.  */\n+\tif (kind == FUZZY_LOOKUP_TYPENAME\n+\t    && TREE_CODE (STRIP_TEMPLATE (d)) != TYPE_DECL)\n+\t  continue;\n \n-      /* Ignore internal names with spaces in them.  */\n-      if (strchr (suggestion_str, ' '))\n-\tcontinue;\n+\tconsider_decl (d, bm, consider_implementation_names);\n+      }\n+  else\n+    {\n+      /* Iterate over the namespace hash table, that'll have fewer\n+\t entries than the decl list.  */\n+      tree ns = lvl->this_entity;\n \n-      /* Don't suggest names that are reserved for use by the\n-\t implementation, unless NAME began with an underscore.  */\n-      if (name_reserved_for_implementation_p (suggestion_str)\n-\t  && !consider_implementation_names)\n-\tcontinue;\n+      hash_table<named_decl_hash>::iterator end\n+\t(DECL_NAMESPACE_BINDINGS (ns)->end ());\n+      for (hash_table<named_decl_hash>::iterator iter\n+\t     (DECL_NAMESPACE_BINDINGS (ns)->begin ()); iter != end; ++iter)\n+\t{\n+\t  tree binding = *iter;\n+\t  tree value = NULL_TREE;\n \n-      bm.consider (suggestion_str);\n+\t  if (STAT_HACK_P (binding))\n+\t    {\n+\t      if (!STAT_TYPE_HIDDEN_P (binding)\n+\t\t  && STAT_TYPE (binding))\n+\t\tconsider_decl (STAT_TYPE (binding), bm,\n+\t\t\t       consider_implementation_names);\n+\t      else if (!STAT_DECL_HIDDEN_P (binding))\n+\t\tvalue = STAT_DECL (binding);\n+\t    }\n+\t  else\n+\t    value = binding;\n+\t  \n+\t  value = ovl_skip_hidden (value);\n+\t  if (value)\n+\t    {\n+\t      value = OVL_FIRST (value);\n+\t      if (!(kind == FUZZY_LOOKUP_TYPENAME\n+\t\t    && TREE_CODE (STRIP_TEMPLATE (value)) != TYPE_DECL))\n+\t\tconsider_decl (value, bm, consider_implementation_names);\n+\t    }\n+\t}\n     }\n }\n "}, {"sha": "175ba4a2e0fedb9b8118cc1555c6767e7e9a6cde", "filename": "gcc/testsuite/c-c++-common/spellcheck-reserved.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ee1c0413e251ff0b6a6d526209ef038b9835320/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fspellcheck-reserved.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ee1c0413e251ff0b6a6d526209ef038b9835320/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fspellcheck-reserved.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fspellcheck-reserved.c?ref=7ee1c0413e251ff0b6a6d526209ef038b9835320", "patch": "@@ -30,7 +30,7 @@ void test (const char *buf, char ch)\n {\n   __builtin_strtchr (buf, ch); /* { dg-line misspelled_reserved } */\n   /* { dg-warning \"did you mean '__builtin_strchr'\" \"\" { target c } misspelled_reserved } */\n-  /* { dg-error \"'__builtin_strtchr' was not declared in this scope; did you mean '__builtin_strrchr'\\\\?\" \"\" { target c++ } misspelled_reserved } */\n+  /* { dg-error \"'__builtin_strtchr' was not declared in this scope; did you mean '__builtin_strchr'\\\\?\" \"\" { target c++ } misspelled_reserved } */\n }\n \n /* Similarly for a name that begins with a single underscore.  */"}, {"sha": "ff53ecc63038cffe1eff9310e7955d303a3e8d0a", "filename": "gcc/testsuite/g++.dg/spellcheck-typenames.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ee1c0413e251ff0b6a6d526209ef038b9835320/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fspellcheck-typenames.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ee1c0413e251ff0b6a6d526209ef038b9835320/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fspellcheck-typenames.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fspellcheck-typenames.C?ref=7ee1c0413e251ff0b6a6d526209ef038b9835320", "patch": "@@ -54,11 +54,11 @@ struct some_thing test_6; // { dg-error \"aggregate 'some_thing test_6' has incom\n    { dg-end-multiline-output \"\" } */\n \n typedef long int64_t;\n-int64 i; // { dg-error \"1: 'int64' does not name a type; did you mean 'int64_t'?\" }\n+int64 i; // { dg-error \"1: 'int64' does not name a type; did you mean 'int'?\" }\n /* { dg-begin-multiline-output \"\" }\n  int64 i;\n  ^~~~~\n- int64_t\n+ int\n    { dg-end-multiline-output \"\" } */\n \n /* Verify that gcc doesn't offer nonsensical suggestions.  */"}]}