{"sha": "02e3025e174e6e93ab2675f49baf4df617e59c68", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDJlMzAyNWUxNzRlNmU5M2FiMjY3NWY0OWJhZjRkZjYxN2U1OWM2OA==", "commit": {"author": {"name": "Aaron Sawdey", "email": "acsawdey@gcc.gnu.org", "date": "2019-07-02T18:51:23Z"}, "committer": {"name": "Aaron Sawdey", "email": "acsawdey@gcc.gnu.org", "date": "2019-07-02T18:51:23Z"}, "message": "optabs.def (movmem_optab): Add movmem back for memmove().\n\n2019-07-02  Aaron Sawdey  <acsawdey@linux.ibm.com>\n\n\t* optabs.def (movmem_optab): Add movmem back for memmove().\n\t* doc/md.texi: Add description of movmem pattern for overlapping move.\n\nFrom-SVN: r272946", "tree": {"sha": "c79681510df7cbcd20b98df7ae78edcb01870382", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c79681510df7cbcd20b98df7ae78edcb01870382"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/02e3025e174e6e93ab2675f49baf4df617e59c68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02e3025e174e6e93ab2675f49baf4df617e59c68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02e3025e174e6e93ab2675f49baf4df617e59c68", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02e3025e174e6e93ab2675f49baf4df617e59c68/comments", "author": null, "committer": null, "parents": [{"sha": "e2790e1eab7bfaae5a733ed742a59a518253a645", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2790e1eab7bfaae5a733ed742a59a518253a645", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2790e1eab7bfaae5a733ed742a59a518253a645"}], "stats": {"total": 37, "additions": 37, "deletions": 0}, "files": [{"sha": "b1fcc38d76bcdd3ddda9c346124671f94ee6bf8e", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e3025e174e6e93ab2675f49baf4df617e59c68/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e3025e174e6e93ab2675f49baf4df617e59c68/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=02e3025e174e6e93ab2675f49baf4df617e59c68", "patch": "@@ -6237,6 +6237,42 @@ to the possibility that the source and destination strings might\n overlap. These patterns are used to do inline expansion of\n @code{__builtin_memcpy}.\n \n+@cindex @code{movmem@var{m}} instruction pattern\n+@item @samp{movmem@var{m}}\n+Block move instruction.  The destination and source blocks of memory\n+are the first two operands, and both are @code{mem:BLK}s with an\n+address in mode @code{Pmode}.\n+\n+The number of bytes to copy is the third operand, in mode @var{m}.\n+Usually, you specify @code{Pmode} for @var{m}.  However, if you can\n+generate better code knowing the range of valid lengths is smaller than\n+those representable in a full Pmode pointer, you should provide\n+a pattern with a\n+mode corresponding to the range of values you can handle efficiently\n+(e.g., @code{QImode} for values in the range 0--127; note we avoid numbers\n+that appear negative) and also a pattern with @code{Pmode}.\n+\n+The fourth operand is the known shared alignment of the source and\n+destination, in the form of a @code{const_int} rtx.  Thus, if the\n+compiler knows that both source and destination are word-aligned,\n+it may provide the value 4 for this operand.\n+\n+Optional operands 5 and 6 specify expected alignment and size of block\n+respectively.  The expected alignment differs from alignment in operand 4\n+in a way that the blocks are not required to be aligned according to it in\n+all cases. This expected alignment is also in bytes, just like operand 4.\n+Expected size, when unknown, is set to @code{(const_int -1)}.\n+\n+Descriptions of multiple @code{movmem@var{m}} patterns can only be\n+beneficial if the patterns for smaller modes have fewer restrictions\n+on their first, second and fourth operands.  Note that the mode @var{m}\n+in @code{movmem@var{m}} does not impose any restriction on the mode of\n+individually copied data units in the block.\n+\n+The @code{movmem@var{m}} patterns must correctly handle the case where\n+the source and destination strings overlap. These patterns are used to\n+do inline expansion of @code{__builtin_memmove}.\n+\n @cindex @code{movstr} instruction pattern\n @item @samp{movstr}\n String copy instruction, with @code{stpcpy} semantics.  Operand 0 is"}, {"sha": "4ffd0f35a40c10e5d77416a8e0709075aa212fac", "filename": "gcc/optabs.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e3025e174e6e93ab2675f49baf4df617e59c68/gcc%2Foptabs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e3025e174e6e93ab2675f49baf4df617e59c68/gcc%2Foptabs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.def?ref=02e3025e174e6e93ab2675f49baf4df617e59c68", "patch": "@@ -257,6 +257,7 @@ OPTAB_D (cmpmem_optab, \"cmpmem$a\")\n OPTAB_D (cmpstr_optab, \"cmpstr$a\")\n OPTAB_D (cmpstrn_optab, \"cmpstrn$a\")\n OPTAB_D (cpymem_optab, \"cpymem$a\")\n+OPTAB_D (movmem_optab, \"movmem$a\")\n OPTAB_D (setmem_optab, \"setmem$a\")\n OPTAB_D (strlen_optab, \"strlen$a\")\n "}]}