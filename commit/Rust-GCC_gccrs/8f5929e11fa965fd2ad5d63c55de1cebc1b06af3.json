{"sha": "8f5929e11fa965fd2ad5d63c55de1cebc1b06af3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGY1OTI5ZTExZmE5NjVmZDJhZDVkNjNjNTVkZTFjZWJjMWIwNmFmMw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2009-03-18T17:04:26Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2009-03-18T17:04:26Z"}, "message": "dse.c (struct group_info): Reorder fields for 64-bit hosts.\n\n\t* dse.c (struct group_info): Reorder fields for 64-bit hosts.\n\t* matrix-reorg.c (struct matrix_info): Likewise.\n\t* tree-ssa-loop-ivopts.c (struct ivopts_data): Likewise.\n\t* rtl.h (struct mem_attrs): Likewise.\n\t* df.h (struct df): Likewise.\n\t* tree-data-ref.h (struct data_dependence_relation): Likewise.\n\t* ira-int.h (struct ira_allocno): Likewise.\n\t* df-scan.c (struct df_collection_rec): Likewise.\n\t* ira.c (struct equivalence): Likewise.\n\t* function.c (struct temp_slot): Likewise.\n\t* cfgloop.h (struct loop): Likewise.\n\n\t* parser.c (struct cp_token): Reorder fields for 64-bit hosts.\n\t(eof_token): Adjust.\n\n\t* include/cpplib.h (struct cpp_dir): Reorder fields for 64-bit hosts.\n\nFrom-SVN: r144938", "tree": {"sha": "9ffa72fee709efb6885ad516b9076279d60c9e24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ffa72fee709efb6885ad516b9076279d60c9e24"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8f5929e11fa965fd2ad5d63c55de1cebc1b06af3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f5929e11fa965fd2ad5d63c55de1cebc1b06af3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f5929e11fa965fd2ad5d63c55de1cebc1b06af3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f5929e11fa965fd2ad5d63c55de1cebc1b06af3/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9968d233b33186f70cbf9b265ec15b8b97153128", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9968d233b33186f70cbf9b265ec15b8b97153128", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9968d233b33186f70cbf9b265ec15b8b97153128"}], "stats": {"total": 209, "additions": 117, "deletions": 92}, "files": [{"sha": "c192bd61a484156b7da2b4beb49a4326e55a98dc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f5929e11fa965fd2ad5d63c55de1cebc1b06af3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f5929e11fa965fd2ad5d63c55de1cebc1b06af3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8f5929e11fa965fd2ad5d63c55de1cebc1b06af3", "patch": "@@ -1,3 +1,17 @@\n+2009-03-18  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* dse.c (struct group_info): Reorder fields for 64-bit hosts.\n+\t* matrix-reorg.c (struct matrix_info): Likewise.\n+\t* tree-ssa-loop-ivopts.c (struct ivopts_data): Likewise.\n+\t* rtl.h (struct mem_attrs): Likewise.\n+\t* df.h (struct df): Likewise.\n+\t* tree-data-ref.h (struct data_dependence_relation): Likewise.\n+\t* ira-int.h (struct ira_allocno): Likewise.\n+\t* df-scan.c (struct df_collection_rec): Likewise.\n+\t* ira.c (struct equivalence): Likewise.\n+\t* function.c (struct temp_slot): Likewise.\n+\t* cfgloop.h (struct loop): Likewise.\n+\n 2009-03-18  Sebastian Pop  <sebastian.pop@amd.com>\n \n \tPR middle-end/39447"}, {"sha": "0af5be02d7656071b670beeba560218bf3db5a28", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f5929e11fa965fd2ad5d63c55de1cebc1b06af3/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f5929e11fa965fd2ad5d63c55de1cebc1b06af3/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=8f5929e11fa965fd2ad5d63c55de1cebc1b06af3", "patch": "@@ -1,6 +1,6 @@\n /* Natural loop functions\n    Copyright (C) 1987, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n-   2005, 2006, 2007, 2008  Free Software Foundation, Inc.\n+   2005, 2006, 2007, 2008, 2009  Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -105,6 +105,9 @@ struct loop GTY ((chain_next (\"%h.next\")))\n   /* Index into loops array.  */\n   int num;\n \n+  /* Number of loop insns.  */\n+  unsigned ninsns;\n+\n   /* Basic block of loop header.  */\n   struct basic_block_def *header;\n \n@@ -114,9 +117,6 @@ struct loop GTY ((chain_next (\"%h.next\")))\n   /* For loop unrolling/peeling decision.  */\n   struct lpt_decision lpt_decision;\n \n-  /* Number of loop insns.  */\n-  unsigned ninsns;\n-\n   /* Average number of executed insns per iteration.  */\n   unsigned av_ninsns;\n \n@@ -142,19 +142,20 @@ struct loop GTY ((chain_next (\"%h.next\")))\n      information in this field.  */\n   tree nb_iterations;\n \n-  /* An integer estimation of the number of iterations.  Estimate_state\n-     describes what is the state of the estimation.  */\n-  enum loop_estimation estimate_state;\n-\n   /* An integer guaranteed to bound the number of iterations of the loop\n      from above.  */\n-  bool any_upper_bound;\n   double_int nb_iterations_upper_bound;\n \n   /* An integer giving the expected number of iterations of the loop.  */\n-  bool any_estimate;\n   double_int nb_iterations_estimate;\n \n+  bool any_upper_bound;\n+  bool any_estimate;\n+\n+  /* An integer estimation of the number of iterations.  Estimate_state\n+     describes what is the state of the estimation.  */\n+  enum loop_estimation estimate_state;\n+\n   /* Upper bound on number of iterations of a loop.  */\n   struct nb_iter_bound *bounds;\n "}, {"sha": "8553a198f928e0ce31ee6a402db6f0c78ee63636", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f5929e11fa965fd2ad5d63c55de1cebc1b06af3/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f5929e11fa965fd2ad5d63c55de1cebc1b06af3/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8f5929e11fa965fd2ad5d63c55de1cebc1b06af3", "patch": "@@ -1,3 +1,8 @@\n+2009-03-18  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* parser.c (struct cp_token): Reorder fields for 64-bit hosts.\n+\t(eof_token): Adjust.\n+\n 2009-03-18  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR c++/39425"}, {"sha": "4e79e1f91262b426918a41a3fc65e92abdd97d48", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f5929e11fa965fd2ad5d63c55de1cebc1b06af3/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f5929e11fa965fd2ad5d63c55de1cebc1b06af3/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=8f5929e11fa965fd2ad5d63c55de1cebc1b06af3", "patch": "@@ -77,15 +77,15 @@ typedef struct cp_token GTY (())\n      KEYWORD is RID_MAX) iff this name was looked up and found to be\n      ambiguous.  An error has already been reported.  */\n   BOOL_BITFIELD ambiguous_p : 1;\n+  /* The location at which this token was found.  */\n+  location_t location;\n   /* The value associated with this token, if any.  */\n   union cp_token_value {\n     /* Used for CPP_NESTED_NAME_SPECIFIER and CPP_TEMPLATE_ID.  */\n     struct tree_check* GTY((tag (\"1\"))) tree_check_value;\n     /* Use for all other tokens.  */\n     tree GTY((tag (\"0\"))) value;\n   } GTY((desc (\"(%1.type == CPP_TEMPLATE_ID) || (%1.type == CPP_NESTED_NAME_SPECIFIER)\"))) u;\n-  /* The location at which this token was found.  */\n-  location_t location;\n } cp_token;\n \n /* We use a stack of token pointer for saving token sets.  */\n@@ -95,8 +95,7 @@ DEF_VEC_ALLOC_P (cp_token_position,heap);\n \n static cp_token eof_token =\n {\n-  CPP_EOF, RID_MAX, 0, PRAGMA_NONE, false, 0, { NULL },\n-  0\n+  CPP_EOF, RID_MAX, 0, PRAGMA_NONE, false, 0, 0, { NULL }\n };\n \n /* The cp_lexer structure represents the C++ lexer.  It is responsible"}, {"sha": "d8ad4a0669826ecb92ecdb3e60515967a63463c7", "filename": "gcc/df-scan.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f5929e11fa965fd2ad5d63c55de1cebc1b06af3/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f5929e11fa965fd2ad5d63c55de1cebc1b06af3/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=8f5929e11fa965fd2ad5d63c55de1cebc1b06af3", "patch": "@@ -1,6 +1,6 @@\n /* Scanning of rtl for dataflow analysis.\n    Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,\n-   2008  Free Software Foundation, Inc.\n+   2008, 2009  Free Software Foundation, Inc.\n    Originally contributed by Michael P. Hayes \n              (m.hayes@elec.canterbury.ac.nz, mhayes@redhat.com)\n    Major rewrite contributed by Danny Berlin (dberlin@dberlin.org)\n@@ -85,12 +85,12 @@ static HARD_REG_SET elim_reg_set;\n struct df_collection_rec\n {\n   df_ref * def_vec;\n-  unsigned int next_def;\n   df_ref * use_vec;\n+  unsigned int next_def;\n   unsigned int next_use;\n   df_ref * eq_use_vec;\n-  unsigned int next_eq_use;\n   struct df_mw_hardreg **mw_vec;\n+  unsigned int next_eq_use;\n   unsigned int next_mw;\n };\n "}, {"sha": "639c52157b42e0512605426eccbf851ade8bcf6b", "filename": "gcc/df.h", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f5929e11fa965fd2ad5d63c55de1cebc1b06af3/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f5929e11fa965fd2ad5d63c55de1cebc1b06af3/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=8f5929e11fa965fd2ad5d63c55de1cebc1b06af3", "patch": "@@ -1,6 +1,6 @@\n /* Form lists of pseudo register references for autoinc optimization\n    for GNU compiler.  This is part of flow optimization.\n-   Copyright (C) 1999, 2000, 2001, 2003, 2004, 2005, 2006, 2007, 2008\n+   Copyright (C) 1999, 2000, 2001, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n    Free Software Foundation, Inc.\n    Originally contributed by Michael P. Hayes \n              (m.hayes@elec.canterbury.ac.nz, mhayes@redhat.com)\n@@ -535,22 +535,13 @@ struct df\n \n   struct dataflow *problems_in_order[DF_LAST_PROBLEM_PLUS1]; \n   struct dataflow *problems_by_index[DF_LAST_PROBLEM_PLUS1]; \n-  int num_problems_defined;\n \n   /* If not NULL, this subset of blocks of the program to be\n      considered for analysis.  At certain times, this will contain all\n      the blocks in the function so it cannot be used as an indicator\n      of if we are analyzing a subset.  See analyze_subset.  */ \n   bitmap blocks_to_analyze;\n \n-  /* If this is true, then only a subset of the blocks of the program\n-     is considered to compute the solutions of dataflow problems.  */\n-  bool analyze_subset;\n-\n-  /* True if someone added or deleted something from regs_ever_live so\n-     that the entry and exit blocks need be reprocessed.  */\n-  bool redo_entry_and_exit;\n-\n   /* The following information is really the problem data for the\n      scanning instance but it is used too often by the other problems\n      to keep getting it from there.  */\n@@ -568,6 +559,9 @@ struct df\n \n   struct df_insn_info **insns;   /* Insn table, indexed by insn UID.  */\n   unsigned int insns_size;       /* Size of insn table.  */\n+\n+  int num_problems_defined;\n+\n   bitmap hardware_regs_used;     /* The set of hardware registers used.  */\n   /* The set of hard regs that are in the artificial uses at the end\n      of a regular basic block.  */\n@@ -609,7 +603,15 @@ struct df\n   unsigned int ref_order;\n \n   /* Problem specific control information.  */\n-  enum df_changeable_flags changeable_flags;\n+  ENUM_BITFIELD (df_changeable_flags) changeable_flags : 8;\n+\n+  /* If this is true, then only a subset of the blocks of the program\n+     is considered to compute the solutions of dataflow problems.  */\n+  bool analyze_subset;\n+\n+  /* True if someone added or deleted something from regs_ever_live so\n+     that the entry and exit blocks need be reprocessed.  */\n+  bool redo_entry_and_exit;\n };\n \n #define DF_SCAN_BB_INFO(BB) (df_scan_get_bb_info((BB)->index))"}, {"sha": "a35f07bb1134e5af9e43060973a43fa61b6eb227", "filename": "gcc/dse.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f5929e11fa965fd2ad5d63c55de1cebc1b06af3/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f5929e11fa965fd2ad5d63c55de1cebc1b06af3/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=8f5929e11fa965fd2ad5d63c55de1cebc1b06af3", "patch": "@@ -1,5 +1,5 @@\n /* RTL dead store elimination.\n-   Copyright (C) 2005, 2006, 2007, 2008 Free Software Foundation, Inc.\n+   Copyright (C) 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.\n \n    Contributed by Richard Sandiford <rsandifor@codesourcery.com>\n    and Kenneth Zadeck <zadeck@naturalbridge.com>\n@@ -464,6 +464,14 @@ struct group_info\n      canonical ordering of these that is not based on addresses.  */\n   int id;\n \n+  /* True if there are any positions that are to be processed\n+     globally.  */\n+  bool process_globally;\n+\n+  /* True if the base of this group is either the frame_pointer or\n+     hard_frame_pointer.  */\n+  bool frame_related;\n+\n   /* A mem wrapped around the base pointer for the group in order to\n      do read dependency.  */\n   rtx base_mem;\n@@ -494,14 +502,6 @@ struct group_info\n      the positions that are occupied by stores for this group.  */\n   bitmap group_kill;\n \n-  /* True if there are any positions that are to be processed\n-     globally.  */\n-  bool process_globally;\n-\n-  /* True if the base of this group is either the frame_pointer or\n-     hard_frame_pointer.  */\n-  bool frame_related;\n-\n   /* The offset_map is used to map the offsets from this base into\n      positions in the global bitmaps.  It is only created after all of\n      the all of stores have been scanned and we know which ones we"}, {"sha": "76d48347d48ccb34623685fd8af25a2292029a23", "filename": "gcc/function.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f5929e11fa965fd2ad5d63c55de1cebc1b06af3/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f5929e11fa965fd2ad5d63c55de1cebc1b06af3/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=8f5929e11fa965fd2ad5d63c55de1cebc1b06af3", "patch": "@@ -458,15 +458,15 @@ struct temp_slot GTY(())\n   struct temp_slot *prev;\n   /* The rtx to used to reference the slot.  */\n   rtx slot;\n-  /* The alignment (in bits) of the slot.  */\n-  unsigned int align;\n   /* The size, in units, of the slot.  */\n   HOST_WIDE_INT size;\n   /* The type of the object in the slot, or zero if it doesn't correspond\n      to a type.  We use this to determine whether a slot can be reused.\n      It can be reused if objects of the type of the new slot will always\n      conflict with objects of the type of the old slot.  */\n   tree type;\n+  /* The alignment (in bits) of the slot.  */\n+  unsigned int align;\n   /* Nonzero if this temporary is currently in use.  */\n   char in_use;\n   /* Nonzero if this temporary has its address taken.  */"}, {"sha": "4cb3928564cd1cd9356c8666dd0f5258e97f5393", "filename": "gcc/ira-int.h", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f5929e11fa965fd2ad5d63c55de1cebc1b06af3/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f5929e11fa965fd2ad5d63c55de1cebc1b06af3/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=8f5929e11fa965fd2ad5d63c55de1cebc1b06af3", "patch": "@@ -240,15 +240,15 @@ struct ira_allocno\n   /* Mode of the allocno which is the mode of the corresponding\n      pseudo-register.  */\n   enum machine_mode mode;\n-  /* Final rtx representation of the allocno.  */\n-  rtx reg;\n   /* Hard register assigned to given allocno.  Negative value means\n      that memory was allocated to the allocno.  During the reload,\n      spilled allocno has value equal to the corresponding stack slot\n      number (0, ...) - 2.  Value -1 is used for allocnos spilled by the\n      reload (at this point pseudo-register has only one allocno) which\n      did not get stack slot yet.  */\n   int hard_regno;\n+  /* Final rtx representation of the allocno.  */\n+  rtx reg;\n   /* Allocnos with the same regno are linked by the following member.\n      Allocnos corresponding to inner loops are first in the list (it\n      corresponds to depth-first traverse of the loops).  */\n@@ -312,33 +312,29 @@ struct ira_allocno\n      correspondingly minimal and maximal conflict ids of allocnos with\n      which given allocno can conflict.  */\n   int min, max;\n-  /* The unique member value represents given allocno in conflict bit\n-     vectors.  */\n-  int conflict_id;\n   /* Vector of accumulated conflicting allocnos with NULL end marker\n      (if CONFLICT_VEC_P is true) or conflict bit vector otherwise.\n      Only allocnos with the same cover class are in the vector or in\n      the bit vector.  */\n   void *conflict_allocno_array;\n+  /* The unique member value represents given allocno in conflict bit\n+     vectors.  */\n+  int conflict_id;\n   /* Allocated size of the previous array.  */\n   unsigned int conflict_allocno_array_size;\n-  /* Number of accumulated conflicts in the vector of conflicting\n-     allocnos.  */\n-  int conflict_allocnos_num;\n   /* Initial and accumulated hard registers conflicting with this\n      allocno and as a consequences can not be assigned to the allocno.\n      All non-allocatable hard regs and hard regs of cover classes\n      different from given allocno one are included in the sets.  */\n   HARD_REG_SET conflict_hard_regs, total_conflict_hard_regs;\n+  /* Number of accumulated conflicts in the vector of conflicting\n+     allocnos.  */\n+  int conflict_allocnos_num;\n   /* Accumulated frequency of calls which given allocno\n      intersects.  */\n   int call_freq;\n   /* Accumulated number of the intersected calls.  */\n   int calls_crossed_num;\n-  /* Non NULL if we remove restoring value from given allocno to\n-     MEM_OPTIMIZED_DEST at loop exit (see ira-emit.c) because the\n-     allocno value is not changed inside the loop.  */\n-  ira_allocno_t mem_optimized_dest;\n   /* TRUE if the allocno assigned to memory was a destination of\n      removed move (see ira-emit.c) at loop exit because the value of\n      the corresponding pseudo-register is not changed inside the\n@@ -383,6 +379,10 @@ struct ira_allocno\n      vector where a bit with given index represents allocno with the\n      same number.  */\n   unsigned int conflict_vec_p : 1;\n+  /* Non NULL if we remove restoring value from given allocno to\n+     MEM_OPTIMIZED_DEST at loop exit (see ira-emit.c) because the\n+     allocno value is not changed inside the loop.  */\n+  ira_allocno_t mem_optimized_dest;\n   /* Array of usage costs (accumulated and the one updated during\n      coloring) for each hard register of the allocno cover class.  The\n      member value can be NULL if all costs are the same and equal to"}, {"sha": "3742f0f35c1c1d79afc7d92dd12aa388c7bbae23", "filename": "gcc/ira.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f5929e11fa965fd2ad5d63c55de1cebc1b06af3/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f5929e11fa965fd2ad5d63c55de1cebc1b06af3/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=8f5929e11fa965fd2ad5d63c55de1cebc1b06af3", "patch": "@@ -1864,21 +1864,21 @@ mark_elimination (int from, int to)\n \n struct equivalence\n {\n-  /* Set when an attempt should be made to replace a register\n-     with the associated src_p entry.  */\n-  char replace;\n   /* Set when a REG_EQUIV note is found or created.  Use to\n      keep track of what memory accesses might be created later,\n      e.g. by reload.  */\n   rtx replacement;\n   rtx *src_p;\n+  /* The list of each instruction which initializes this register.  */\n+  rtx init_insns;\n   /* Loop depth is used to recognize equivalences which appear\n      to be present within the same loop (or in an inner loop).  */\n   int loop_depth;\n-  /* The list of each instruction which initializes this register.  */\n-  rtx init_insns;\n   /* Nonzero if this had a preexisting REG_EQUIV note.  */\n   int is_arg_equivalence;\n+  /* Set when an attempt should be made to replace a register\n+     with the associated src_p entry.  */\n+  char replace;\n };\n \n /* reg_equiv[N] (where N is a pseudo reg number) is the equivalence"}, {"sha": "d916f70266cc419b1673703133b673bf70a35236", "filename": "gcc/matrix-reorg.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f5929e11fa965fd2ad5d63c55de1cebc1b06af3/gcc%2Fmatrix-reorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f5929e11fa965fd2ad5d63c55de1cebc1b06af3/gcc%2Fmatrix-reorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatrix-reorg.c?ref=8f5929e11fa965fd2ad5d63c55de1cebc1b06af3", "patch": "@@ -1,5 +1,5 @@\n /* Matrix layout transformations.\n-   Copyright (C) 2006, 2007, 2008 Free Software Foundation, Inc.\n+   Copyright (C) 2006, 2007, 2008, 2009 Free Software Foundation, Inc.\n    Contributed by Razya Ladelsky <razya@il.ibm.com>\n    Originally written by Revital Eres and Mustafa Hagog.\n    \n@@ -261,9 +261,6 @@ struct matrix_info\n \n   gimple min_indirect_level_escape_stmt;\n \n-  /* Is the matrix transposed.  */\n-  bool is_transposed_p;\n-\n   /* Hold the allocation site for each level (dimension).\n      We can use NUM_DIMS as the upper bound and allocate the array\n      once with this number of elements and no need to use realloc and\n@@ -272,6 +269,9 @@ struct matrix_info\n \n   int max_malloced_level;\n \n+  /* Is the matrix transposed.  */\n+  bool is_transposed_p;\n+\n   /* The location of the allocation sites (they must be in one\n      function).  */\n   tree allocation_function_decl;\n@@ -303,7 +303,7 @@ struct matrix_info\n \n   /* An array of the accesses to be flattened.\n      elements are of type \"struct access_site_info *\".  */\n-    VEC (access_site_info_p, heap) * access_l;\n+  VEC (access_site_info_p, heap) * access_l;\n \n   /* A map of how the dimensions will be organized at the end of \n      the analyses.  */"}, {"sha": "e8d42c8cc6168bce31e4d0e92e8bee7c8354c741", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f5929e11fa965fd2ad5d63c55de1cebc1b06af3/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f5929e11fa965fd2ad5d63c55de1cebc1b06af3/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=8f5929e11fa965fd2ad5d63c55de1cebc1b06af3", "patch": "@@ -141,10 +141,10 @@ typedef struct\n    stricter alignment; OFFSET is the offset of the MEM within that object.  */\n typedef struct mem_attrs GTY(())\n {\n-  alias_set_type alias;\t\t/* Memory alias set.  */\n   tree expr;\t\t\t/* expr corresponding to MEM.  */\n   rtx offset;\t\t\t/* Offset from start of DECL, as CONST_INT.  */\n   rtx size;\t\t\t/* Size in bytes, as a CONST_INT.  */\n+  alias_set_type alias;\t\t/* Memory alias set.  */\n   unsigned int align;\t\t/* Alignment of MEM in bits.  */\n } mem_attrs;\n "}, {"sha": "4a12f3946d809a48564d60fa7bacb21819bbc12f", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f5929e11fa965fd2ad5d63c55de1cebc1b06af3/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f5929e11fa965fd2ad5d63c55de1cebc1b06af3/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=8f5929e11fa965fd2ad5d63c55de1cebc1b06af3", "patch": "@@ -291,14 +291,6 @@ struct data_dependence_relation\n   struct data_reference *a;\n   struct data_reference *b;\n \n-  /* When the dependence relation is affine, it can be represented by\n-     a distance vector.  */\n-  bool affine_p;\n-\n-  /* Set to true when the dependence relation is on the same data\n-     access.  */\n-  bool self_reference_p;\n-\n   /* A \"yes/no/maybe\" field for the dependence relation:\n      \n      - when \"ARE_DEPENDENT == NULL_TREE\", there exist a dependence\n@@ -320,18 +312,26 @@ struct data_dependence_relation\n   /* The analyzed loop nest.  */\n   VEC (loop_p, heap) *loop_nest;\n \n-  /* An index in loop_nest for the innermost loop that varies for\n-     this data dependence relation.  */\n-  unsigned inner_loop;\n-\n   /* The classic direction vector.  */\n   VEC (lambda_vector, heap) *dir_vects;\n \n   /* The classic distance vector.  */\n   VEC (lambda_vector, heap) *dist_vects;\n \n+  /* An index in loop_nest for the innermost loop that varies for\n+     this data dependence relation.  */\n+  unsigned inner_loop;\n+\n   /* Is the dependence reversed with respect to the lexicographic order?  */\n   bool reversed_p;\n+\n+  /* When the dependence relation is affine, it can be represented by\n+     a distance vector.  */\n+  bool affine_p;\n+\n+  /* Set to true when the dependence relation is on the same data\n+     access.  */\n+  bool self_reference_p;\n };\n \n typedef struct data_dependence_relation *ddr_p;"}, {"sha": "fcaf7846458b43841988abc9c0eee1cd16f62fdb", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f5929e11fa965fd2ad5d63c55de1cebc1b06af3/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f5929e11fa965fd2ad5d63c55de1cebc1b06af3/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=8f5929e11fa965fd2ad5d63c55de1cebc1b06af3", "patch": "@@ -1,6 +1,6 @@\n /* Induction variable optimizations.\n-   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008 Free Software\n-   Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009\n+   Free Software Foundation, Inc.\n    \n This file is part of GCC.\n    \n@@ -219,15 +219,12 @@ struct ivopts_data\n   /* The currently optimized loop.  */\n   struct loop *current_loop;\n \n-  /* Are we optimizing for speed?  */\n-  bool speed;\n+  /* Numbers of iterations for all exits of the current loop.  */\n+  struct pointer_map_t *niters;\n \n   /* Number of registers used in it.  */\n   unsigned regs_used;\n \n-  /* Numbers of iterations for all exits of the current loop.  */\n-  struct pointer_map_t *niters;\n-\n   /* The size of version_info array allocated.  */\n   unsigned version_info_size;\n \n@@ -237,9 +234,6 @@ struct ivopts_data\n   /* The bitmap of indices in version_info whose value was changed.  */\n   bitmap relevant;\n \n-  /* The maximum invariant id.  */\n-  unsigned max_inv_id;\n-\n   /* The uses of induction variables.  */\n   VEC(iv_use_p,heap) *iv_uses;\n \n@@ -249,9 +243,15 @@ struct ivopts_data\n   /* A bitmap of important candidates.  */\n   bitmap important_candidates;\n \n+  /* The maximum invariant id.  */\n+  unsigned max_inv_id;\n+\n   /* Whether to consider just related and important candidates when replacing a\n      use.  */\n   bool consider_all_candidates;\n+\n+  /* Are we optimizing for speed?  */\n+  bool speed;\n };\n \n /* An assignment of iv candidates to uses.  */"}, {"sha": "acffe8e39e0d8ceb1525a7ed880f4daf9e1532ac", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f5929e11fa965fd2ad5d63c55de1cebc1b06af3/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f5929e11fa965fd2ad5d63c55de1cebc1b06af3/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=8f5929e11fa965fd2ad5d63c55de1cebc1b06af3", "patch": "@@ -1,3 +1,7 @@\n+2009-03-18  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* include/cpplib.h (struct cpp_dir): Reorder fields for 64-bit hosts.\n+\n 2009-02-21  Joseph Myers  <joseph@codesourcery.com>\n \n \t* lex.c (lex_string): Return a CPP_LESS token for missing '>' in a"}, {"sha": "e2c505c38694aa772510fcd2f5a7df3459acb6f9", "filename": "libcpp/include/cpplib.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f5929e11fa965fd2ad5d63c55de1cebc1b06af3/libcpp%2Finclude%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f5929e11fa965fd2ad5d63c55de1cebc1b06af3/libcpp%2Finclude%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fcpplib.h?ref=8f5929e11fa965fd2ad5d63c55de1cebc1b06af3", "patch": "@@ -1,6 +1,6 @@\n /* Definitions for CPP library.\n    Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,\n-   2004, 2005, 2007, 2008\n+   2004, 2005, 2007, 2008, 2009\n    Free Software Foundation, Inc.\n    Written by Per Bothner, 1994-95.\n \n@@ -516,14 +516,17 @@ struct cpp_dir\n   char *name;\n   unsigned int len;\n \n-  /* The canonicalized NAME as determined by lrealpath.  This field \n-     is only used by hosts that lack reliable inode numbers.  */\n-  char *canonical_name;\n-\n   /* One if a system header, two if a system header that has extern\n      \"C\" guards for C++.  */\n   unsigned char sysp;\n \n+  /* Is this a user-supplied directory? */\n+  bool user_supplied_p;\n+\n+  /* The canonicalized NAME as determined by lrealpath.  This field \n+     is only used by hosts that lack reliable inode numbers.  */\n+  char *canonical_name;\n+\n   /* Mapping of file names for this directory for MS-DOS and related\n      platforms.  A NULL-terminated array of (from, to) pairs.  */\n   const char **name_map;\n@@ -538,9 +541,6 @@ struct cpp_dir\n      directories in the search path.  */\n   ino_t ino;\n   dev_t dev;\n-\n-  /* Is this a user-supplied directory? */\n-  bool user_supplied_p;\n };\n \n /* Name under which this program was invoked.  */"}]}