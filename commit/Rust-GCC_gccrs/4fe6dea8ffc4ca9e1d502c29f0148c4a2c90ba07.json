{"sha": "4fe6dea8ffc4ca9e1d502c29f0148c4a2c90ba07", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGZlNmRlYThmZmM0Y2E5ZTFkNTAyYzI5ZjAxNDhjNGEyYzkwYmEwNw==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel1@de.ibm.com", "date": "2009-07-22T07:47:04Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2009-07-22T07:47:04Z"}, "message": "constraints.md (ZQ, ZR, ZS, ZT): New constraints.\n\n2009-07-22  Andreas Krebbel  <krebbel1@de.ibm.com>\n\n\t* config/s390/constraints.md (ZQ, ZR, ZS, ZT): New constraints.\n\t(U, W): Constraints are now deprecated and will be removed if we\n\trun out of letters.\t\n\t* config/s390/s390.md (U, W): Replaced with ZQZR, ZSZT throughout\n\tthe file.\n\t(\"prefetch\"): Add the stcmh instruction for prefetching.\n\t* config/s390/s390.c (s390_symref_operand_p): Function moved. No\n\tchanges.\n\t(s390_short_displacement): Return always true if compiling for\n\tmachines not providing the long displacement facility.\n\t(s390_mem_constraint): Support the new constraint letter Z.\n\t(s390_check_qrst_address): New function.\n\nFrom-SVN: r149917", "tree": {"sha": "bc375d66fda821d2492c02adfae74c3d9f2913f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc375d66fda821d2492c02adfae74c3d9f2913f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4fe6dea8ffc4ca9e1d502c29f0148c4a2c90ba07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fe6dea8ffc4ca9e1d502c29f0148c4a2c90ba07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fe6dea8ffc4ca9e1d502c29f0148c4a2c90ba07", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fe6dea8ffc4ca9e1d502c29f0148c4a2c90ba07/comments", "author": null, "committer": null, "parents": [{"sha": "40b125d799aa684a563e1332db029f766defdb5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40b125d799aa684a563e1332db029f766defdb5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40b125d799aa684a563e1332db029f766defdb5c"}], "stats": {"total": 324, "additions": 185, "deletions": 139}, "files": [{"sha": "7e939cd45a551fca2fdf93de6a0243fc77da88e2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fe6dea8ffc4ca9e1d502c29f0148c4a2c90ba07/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fe6dea8ffc4ca9e1d502c29f0148c4a2c90ba07/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4fe6dea8ffc4ca9e1d502c29f0148c4a2c90ba07", "patch": "@@ -1,3 +1,18 @@\n+2009-07-22  Andreas Krebbel  <krebbel1@de.ibm.com>\n+\n+\t* config/s390/constraints.md (ZQ, ZR, ZS, ZT): New constraints.\n+\t(U, W): Constraints are now deprecated and will be removed if we\n+\trun out of letters.\t\n+\t* config/s390/s390.md (U, W): Replaced with ZQZR, ZSZT throughout\n+\tthe file.\n+\t(\"prefetch\"): Add the stcmh instruction for prefetching.\n+\t* config/s390/s390.c (s390_symref_operand_p): Function moved. No\n+\tchanges.\n+\t(s390_short_displacement): Return always true if compiling for\n+\tmachines not providing the long displacement facility.\n+\t(s390_mem_constraint): Support the new constraint letter Z.\n+\t(s390_check_qrst_address): New function.\n+\n 2009-07-21  DJ Delorie  <dj@redhat.com>\n \n \t* config/mep/mep.c (mep_legitimize_arg): Leave control registers"}, {"sha": "8564b6619a55a04172bb0fa4957ddda71105d872", "filename": "gcc/config/s390/constraints.md", "status": "modified", "additions": 26, "deletions": 6, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fe6dea8ffc4ca9e1d502c29f0148c4a2c90ba07/gcc%2Fconfig%2Fs390%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fe6dea8ffc4ca9e1d502c29f0148c4a2c90ba07/gcc%2Fconfig%2Fs390%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fconstraints.md?ref=4fe6dea8ffc4ca9e1d502c29f0148c4a2c90ba07", "patch": "@@ -66,9 +66,14 @@\n ;;    B -- Multiple letter constraint followed by Q, R, S, or T:\n ;;         Memory reference of the type specified by second letter that\n ;;         does *not* refer to a literal pool entry.\n-;;    U -- Pointer with short displacement.\n-;;    W -- Pointer with long displacement.\n+;;    U -- Pointer with short displacement. (deprecated - use ZQZR)\n+;;    W -- Pointer with long displacement. (deprecated - use ZSZT)\n ;;    Y -- Shift count operand.\n+;;    ZQ -- Pointer without index register and with short displacement.\n+;;    ZR -- Pointer with index register and short displacement.\n+;;    ZS -- Pointer without index register but with long displacement.\n+;;    ZT -- Pointer with index register and long displacement.\n+;;\n ;;\n \n \n@@ -462,11 +467,26 @@ constraint.\"\n \n \n (define_address_constraint \"U\"\n-  \"Pointer with short displacement\"\n+  \"Pointer with short displacement. (deprecated - use ZQZR)\"\n   (match_test \"s390_mem_constraint (\\\"U\\\", op)\"))\n \n-\n-\n (define_address_constraint \"W\"\n-  \"Pointer with long displacement\"\n+  \"Pointer with long displacement. (deprecated - use ZSZT)\"\n   (match_test \"s390_mem_constraint (\\\"W\\\", op)\"))\n+\n+\n+(define_address_constraint \"ZQ\"\n+  \"Pointer without index register and with short displacement.\"\n+  (match_test \"s390_mem_constraint (\\\"ZQ\\\", op)\"))\n+\n+(define_address_constraint \"ZR\"\n+  \"Pointer with index register and short displacement.\"\n+  (match_test \"s390_mem_constraint (\\\"ZR\\\", op)\"))\n+\n+(define_address_constraint \"ZS\"\n+  \"Pointer without index register but with long displacement.\"\n+  (match_test \"s390_mem_constraint (\\\"ZS\\\", op)\"))\n+\n+(define_address_constraint \"ZT\"\n+  \"Pointer with index register and long displacement.\"\n+  (match_test \"s390_mem_constraint (\\\"ZT\\\", op)\"))"}, {"sha": "1454fde2fd813a2099f2effa51b39608e5c33d16", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 108, "deletions": 102, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fe6dea8ffc4ca9e1d502c29f0148c4a2c90ba07/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fe6dea8ffc4ca9e1d502c29f0148c4a2c90ba07/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=4fe6dea8ffc4ca9e1d502c29f0148c4a2c90ba07", "patch": "@@ -1664,6 +1664,11 @@ s390_short_displacement (rtx disp)\n   if (!disp)\n     return true;\n \n+  /* Without the long displacement facility we don't need to\n+     distingiush between long and short displacement.  */\n+  if (!TARGET_LONG_DISPLACEMENT)\n+    return true;\n+\n   /* Integer displacement in range.  */\n   if (GET_CODE (disp) == CONST_INT)\n     return INTVAL (disp) >= 0 && INTVAL (disp) < 4096;\n@@ -2032,132 +2037,168 @@ s390_legitimate_address_without_index_p (rtx op)\n }\n \n \n-/* Evaluates constraint strings described by the regular expression\n-   ([A|B](Q|R|S|T))|U|W and returns 1 if OP is a valid operand for the\n-   constraint given in STR, or 0 else.  */\n+/* Return true if ADDR is of kind symbol_ref or symbol_ref + const_int\n+   and return these parts in SYMREF and ADDEND.  You can pass NULL in\n+   SYMREF and/or ADDEND if you are not interested in these values.  */\n \n-int\n-s390_mem_constraint (const char *str, rtx op)\n+static bool\n+s390_symref_operand_p (rtx addr, rtx *symref, HOST_WIDE_INT *addend)\n {\n-  struct s390_address addr;\n-  char c = str[0];\n+  HOST_WIDE_INT tmpaddend = 0;\n \n-  /* Check for offsettable variants of memory constraints.  */\n-  if (c == 'A')\n+  if (GET_CODE (addr) == CONST)\n+    addr = XEXP (addr, 0);\n+\n+  if (GET_CODE (addr) == PLUS)\n     {\n-      /* Only accept non-volatile MEMs.  */\n-      if (!MEM_P (op) || MEM_VOLATILE_P (op))\n-\treturn 0;\n+      if (GET_CODE (XEXP (addr, 0)) == SYMBOL_REF\n+\t  && CONST_INT_P (XEXP (addr, 1)))\n+\t{\n+\t  tmpaddend = INTVAL (XEXP (addr, 1));\n+\t  addr = XEXP (addr, 0);\n+\t}\n+      else\n+\treturn false;\n+    }\n+  else\n+    if (GET_CODE (addr) != SYMBOL_REF)\n+\treturn false;\n \n-      if ((reload_completed || reload_in_progress)\n-\t  ? !offsettable_memref_p (op) : !offsettable_nonstrict_memref_p (op))\n-\treturn 0;\n+  if (symref)\n+    *symref = addr;\n+  if (addend)\n+    *addend = tmpaddend;\n \n-      c = str[1];\n-    }\n+  return true;\n+}\n+\n+\n+/* Return true if the address in OP is valid for constraint letter C\n+   if wrapped in a MEM rtx.  Set LIT_POOL_OK to true if it literal\n+   pool MEMs should be accepted.  Only the Q, R, S, T constraint\n+   letters are allowed for C.  */\n \n-  /* Check for non-literal-pool variants of memory constraints.  */\n-  else if (c == 'B')\n+static int\n+s390_check_qrst_address (char c, rtx op, bool lit_pool_ok)\n+{\n+  struct s390_address addr;\n+  bool decomposed = false;\n+\n+  /* This check makes sure that no symbolic address (except literal\n+     pool references) are accepted by the R or T constraints.  */\n+  if (s390_symref_operand_p (op, NULL, NULL))\n     {\n-      if (GET_CODE (op) != MEM)\n+      if (!lit_pool_ok)\n \treturn 0;\n-      if (!s390_decompose_address (XEXP (op, 0), &addr))\n+      if (!s390_decompose_address (op, &addr))\n \treturn 0;\n-      if (addr.literal_pool)\n+      if (!addr.literal_pool)\n \treturn 0;\n-\n-      c = str[1];\n+      decomposed = true;\n     }\n \n   switch (c)\n     {\n-    case 'Q':\n-      if (GET_CODE (op) != MEM)\n-\treturn 0;\n-      if (!s390_decompose_address (XEXP (op, 0), &addr))\n+    case 'Q': /* no index short displacement */\n+      if (!decomposed && !s390_decompose_address (op, &addr))\n \treturn 0;\n       if (addr.indx)\n \treturn 0;\n-\n-      if (TARGET_LONG_DISPLACEMENT)\n-\t{\n-\t  if (!s390_short_displacement (addr.disp))\n-\t    return 0;\n-\t}\n-      break;\n-\n-    case 'R':\n-      if (GET_CODE (op) != MEM)\n+      if (!s390_short_displacement (addr.disp))\n \treturn 0;\n+      break;\n \n+    case 'R': /* with index short displacement */\n       if (TARGET_LONG_DISPLACEMENT)\n \t{\n-\t  if (!s390_decompose_address (XEXP (op, 0), &addr))\n+\t  if (!decomposed && !s390_decompose_address (op, &addr))\n \t    return 0;\n \t  if (!s390_short_displacement (addr.disp))\n \t    return 0;\n \t}\n+      /* Any invalid address here will be fixed up by reload,\n+\t so accept it for the most generic constraint.  */\n       break;\n \n-    case 'S':\n+    case 'S': /* no index long displacement */\n       if (!TARGET_LONG_DISPLACEMENT)\n \treturn 0;\n-      if (GET_CODE (op) != MEM)\n-\treturn 0;\n-      if (!s390_decompose_address (XEXP (op, 0), &addr))\n+      if (!decomposed && !s390_decompose_address (op, &addr))\n \treturn 0;\n       if (addr.indx)\n \treturn 0;\n       if (s390_short_displacement (addr.disp))\n \treturn 0;\n       break;\n \n-    case 'T':\n+    case 'T': /* with index long displacement */\n       if (!TARGET_LONG_DISPLACEMENT)\n \treturn 0;\n-      if (GET_CODE (op) != MEM)\n-\treturn 0;\n-      if (!s390_decompose_address (XEXP (op, 0), &addr))\n-\treturn 0;\n-      if (s390_short_displacement (addr.disp))\n+      /* Any invalid address here will be fixed up by reload,\n+\t so accept it for the most generic constraint.  */\n+      if ((decomposed || s390_decompose_address (op, &addr))\n+\t  && s390_short_displacement (addr.disp))\n \treturn 0;\n       break;\n+    default:\n+      return 0;\n+    }\n+  return 1;\n+}\n \n-    case 'U':\n-      if (TARGET_LONG_DISPLACEMENT)\n-\t{\n-\t  if (!s390_decompose_address (op, &addr))\n-\t    return 0;\n-\t  if (!s390_short_displacement (addr.disp))\n-\t    return 0;\n-\t}\n-      break;\n \n-    case 'W':\n-      if (!TARGET_LONG_DISPLACEMENT)\n+/* Evaluates constraint strings described by the regular expression\n+   ([A|B|Z](Q|R|S|T))|U|W|Y and returns 1 if OP is a valid operand for\n+   the constraint given in STR, or 0 else.  */\n+\n+int\n+s390_mem_constraint (const char *str, rtx op)\n+{\n+  char c = str[0];\n+\n+  switch (c)\n+    {\n+    case 'A':\n+      /* Check for offsettable variants of memory constraints.  */\n+      if (!MEM_P (op) || MEM_VOLATILE_P (op))\n \treturn 0;\n-      if (!s390_decompose_address (op, &addr))\n+      if ((reload_completed || reload_in_progress)\n+\t  ? !offsettable_memref_p (op) : !offsettable_nonstrict_memref_p (op))\n \treturn 0;\n-      if (s390_short_displacement (addr.disp))\n+      return s390_check_qrst_address (str[1], XEXP (op, 0), true);\n+    case 'B':\n+      /* Check for non-literal-pool variants of memory constraints.  */\n+      if (!MEM_P (op))\n \treturn 0;\n-      break;\n-\n+      return s390_check_qrst_address (str[1], XEXP (op, 0), false);\n+    case 'Q':\n+    case 'R':\n+    case 'S':\n+    case 'T':\n+      if (GET_CODE (op) != MEM)\n+\treturn 0;\n+      return s390_check_qrst_address (c, XEXP (op, 0), true);\n+    case 'U':\n+      return (s390_check_qrst_address ('Q', op, true)\n+\t      || s390_check_qrst_address ('R', op, true));\n+    case 'W':\n+      return (s390_check_qrst_address ('S', op, true)\n+\t      || s390_check_qrst_address ('T', op, true));\n     case 'Y':\n       /* Simply check for the basic form of a shift count.  Reload will\n \t take care of making sure we have a proper base register.  */\n       if (!s390_decompose_shift_count (op, NULL, NULL))\n \treturn 0;\n       break;\n-\n+    case 'Z':\n+      return s390_check_qrst_address (str[1], op, true);\n     default:\n       return 0;\n     }\n-\n   return 1;\n }\n \n \n-\n /* Evaluates constraint strings starting with letter O.  Input\n    parameter C is the second letter following the \"O\" in the constraint\n    string. Returns 1 if VALUE meets the respective constraint and 0\n@@ -2775,41 +2816,6 @@ s390_preferred_reload_class (rtx op, enum reg_class rclass)\n   return rclass;\n }\n \n-/* Return true if ADDR is of kind symbol_ref or symbol_ref + const_int\n-   and return these parts in SYMREF and ADDEND.  You can pass NULL in\n-   SYMREF and/or ADDEND if you are not interested in these values.  */\n-\n-static bool\n-s390_symref_operand_p (rtx addr, rtx *symref, HOST_WIDE_INT *addend)\n-{\n-  HOST_WIDE_INT tmpaddend = 0;\n-\n-  if (GET_CODE (addr) == CONST)\n-    addr = XEXP (addr, 0);\n-\n-  if (GET_CODE (addr) == PLUS)\n-    {\n-      if (GET_CODE (XEXP (addr, 0)) == SYMBOL_REF\n-\t  && CONST_INT_P (XEXP (addr, 1)))\n-\t{\n-\t  tmpaddend = INTVAL (XEXP (addr, 1));\n-\t  addr = XEXP (addr, 0);\n-\t}\n-      else\n-\treturn false;\n-    }\n-  else\n-    if (GET_CODE (addr) != SYMBOL_REF)\n-\treturn false;\n-\n-  if (symref)\n-    *symref = addr;\n-  if (addend)\n-    *addend = tmpaddend;\n-\n-  return true;\n-}\n-\n /* Return true if ADDR is SYMBOL_REF + addend with addend being a\n    multiple of ALIGNMENT and the SYMBOL_REF being naturally\n    aligned.  */"}, {"sha": "b6a54469498dc3777ebcc5a82a5c5812c1801e51", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 36, "deletions": 31, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fe6dea8ffc4ca9e1d502c29f0148c4a2c90ba07/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fe6dea8ffc4ca9e1d502c29f0148c4a2c90ba07/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=4fe6dea8ffc4ca9e1d502c29f0148c4a2c90ba07", "patch": "@@ -1440,7 +1440,7 @@\n \n (define_insn \"*la_64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d,d\")\n-        (match_operand:QI 1 \"address_operand\" \"U,W\"))]\n+        (match_operand:QI 1 \"address_operand\" \"ZQZR,ZSZT\"))]\n   \"TARGET_64BIT\"\n   \"@\n    la\\t%0,%a1\n@@ -1623,7 +1623,7 @@\n \n (define_insn \"*la_31\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n-        (match_operand:QI 1 \"address_operand\" \"U,W\"))]\n+        (match_operand:QI 1 \"address_operand\" \"ZQZR,ZSZT\"))]\n   \"!TARGET_64BIT && legitimate_la_operand_p (operands[1])\"\n   \"@\n    la\\t%0,%a1\n@@ -1658,7 +1658,7 @@\n \n (define_insn \"*la_31_and\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n-        (and:SI (match_operand:QI 1 \"address_operand\" \"U,W\")\n+        (and:SI (match_operand:QI 1 \"address_operand\" \"ZQZR,ZSZT\")\n                 (const_int 2147483647)))]\n   \"!TARGET_64BIT\"\n   \"@\n@@ -1684,7 +1684,7 @@\n \n (define_insn \"force_la_31\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n-        (match_operand:QI 1 \"address_operand\" \"U,W\"))\n+        (match_operand:QI 1 \"address_operand\" \"ZQZR,ZSZT\"))\n    (use (const_int 0))]\n   \"!TARGET_64BIT\"\n   \"@\n@@ -7402,7 +7402,7 @@\n   [(set (pc)\n         (if_then_else\n           (match_operator 1 \"s390_comparison\" [(reg CC_REGNUM) (const_int 0)])\n-          (match_operand 0 \"address_operand\" \"U\")\n+          (match_operand 0 \"address_operand\" \"ZQZR\")\n           (pc)))]\n   \"\"\n {\n@@ -7466,7 +7466,7 @@\n         (if_then_else\n           (match_operator 1 \"s390_comparison\" [(reg CC_REGNUM) (const_int 0)])\n           (pc)\n-          (match_operand 0 \"address_operand\" \"U\")))]\n+          (match_operand 0 \"address_operand\" \"ZQZR\")))]\n   \"\"\n {\n   if (get_attr_op_type (insn) == OP_TYPE_RR)\n@@ -7673,7 +7673,7 @@\n         (if_then_else\n           (ne (match_operand:SI 1 \"register_operand\" \"d\")\n               (const_int 1))\n-          (match_operand 0 \"address_operand\" \"U\")\n+          (match_operand 0 \"address_operand\" \"ZQZR\")\n           (pc)))\n    (set (match_operand:SI 2 \"register_operand\" \"=1\")\n         (plus:SI (match_dup 1) (const_int -1)))\n@@ -7784,7 +7784,7 @@\n ;\n \n (define_insn \"indirect_jump\"\n- [(set (pc) (match_operand 0 \"address_operand\" \"U\"))]\n+ [(set (pc) (match_operand 0 \"address_operand\" \"ZQZR\"))]\n   \"\"\n {\n   if (get_attr_op_type (insn) == OP_TYPE_RR)\n@@ -7803,7 +7803,7 @@\n ;\n \n (define_insn \"casesi_jump\"\n- [(set (pc) (match_operand 0 \"address_operand\" \"U\"))\n+ [(set (pc) (match_operand 0 \"address_operand\" \"ZQZR\"))\n    (use (label_ref (match_operand 1 \"\" \"\")))]\n   \"\"\n {\n@@ -8025,7 +8025,7 @@\n    (set_attr \"type\"    \"jsr\")])\n \n (define_insn \"*basr\"\n-  [(call (mem:QI (match_operand 0 \"address_operand\" \"U\"))\n+  [(call (mem:QI (match_operand 0 \"address_operand\" \"ZQZR\"))\n          (match_operand 1 \"const_int_operand\" \"n\"))\n    (clobber (match_operand 2 \"register_operand\" \"=r\"))]\n   \"!SIBLING_CALL_P (insn) && GET_MODE (operands[2]) == Pmode\"\n@@ -8083,7 +8083,7 @@\n \n (define_insn \"*basr_r\"\n   [(set (match_operand 0 \"\" \"\")\n-        (call (mem:QI (match_operand 1 \"address_operand\" \"U\"))\n+        (call (mem:QI (match_operand 1 \"address_operand\" \"ZQZR\"))\n               (match_operand 2 \"const_int_operand\" \"n\")))\n    (clobber (match_operand 3 \"register_operand\" \"=r\"))]\n   \"!SIBLING_CALL_P (insn) && GET_MODE (operands[3]) == Pmode\"\n@@ -8183,7 +8183,7 @@\n \n (define_insn \"*basr_tls\"\n   [(set (match_operand 0 \"\" \"\")\n-        (call (mem:QI (match_operand 1 \"address_operand\" \"U\"))\n+        (call (mem:QI (match_operand 1 \"address_operand\" \"ZQZR\"))\n               (match_operand 2 \"const_int_operand\" \"n\")))\n    (clobber (match_operand 3 \"register_operand\" \"=r\"))\n    (use (match_operand 4 \"\" \"\"))]\n@@ -8709,27 +8709,32 @@\n ;\n \n (define_insn \"prefetch\"\n-  [(prefetch (match_operand 0 \"address_operand\" \"UW,X\")\n-\t     (match_operand:SI 1 \"const_int_operand\" \"n,n\")\n-\t     (match_operand:SI 2 \"const_int_operand\" \"n,n\"))]\n-  \"TARGET_Z10\"\n+  [(prefetch (match_operand 0    \"address_operand\"   \"ZQZS,ZRZT,X\")\n+\t     (match_operand:SI 1 \"const_int_operand\" \"   n,   n,n\")\n+\t     (match_operand:SI 2 \"const_int_operand\" \"   n,   n,n\"))]\n+  \"TARGET_ZARCH && s390_tune == PROCESSOR_2097_Z10\"\n {\n-  if (larl_operand (operands[0], Pmode))\n-    return INTVAL (operands[1]) == 1 ? \"pfdrl\\t2,%a0\" : \"pfdrl\\t1,%a0\";\n-\n-  if (s390_mem_constraint (\"W\", operands[0])\n-      || s390_mem_constraint (\"U\", operands[0]))\n-    return INTVAL (operands[1]) == 1 ? \"pfd\\t2,%a0\" : \"pfd\\t1,%a0\";\n-\n-  /* This point might be reached if op0 is a larl operand with an\n-     uneven addend.  In this case we simply omit issuing a prefetch\n-     instruction.  */\n-\n-  return \"\";\n+  switch (which_alternative)\n+    {\n+      case 0:\n+        return INTVAL (operands[1]) == 1 ? \"stcmh\\t2,0,%a0\" : \"stcmh\\t1,0,%a0\";\n+      case 1:\n+        return INTVAL (operands[1]) == 1 ? \"pfd\\t2,%a0\" : \"pfd\\t1,%a0\";\n+      case 2:\n+        if (larl_operand (operands[0], Pmode))\n+\t  return INTVAL (operands[1]) == 1 ? \"pfdrl\\t2,%a0\" : \"pfdrl\\t1,%a0\";\n+      default:\n+\n+        /* This might be reached for symbolic operands with an odd\n+           addend.  We simply omit the prefetch for such rare cases.  */\n+\n+        return \"\";\n+     }\n }\n-  [(set_attr \"type\" \"load,larl\")\n-   (set_attr \"op_type\" \"RXY,RIL\")\n-   (set_attr \"z10prop\" \"z10_super\")])\n+  [(set_attr \"type\" \"store,load,larl\")\n+   (set_attr \"op_type\" \"RSY,RXY,RIL\")\n+   (set_attr \"z10prop\" \"z10_super\")\n+   (set_attr \"cpu_facility\" \"*,z10,z10\")])\n \n \n ;"}]}