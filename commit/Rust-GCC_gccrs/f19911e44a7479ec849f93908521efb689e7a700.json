{"sha": "f19911e44a7479ec849f93908521efb689e7a700", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjE5OTExZTQ0YTc0NzllYzg0OWY5MzkwODUyMWVmYjY4OWU3YTcwMA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-02-04T11:14:25Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-02-04T11:14:25Z"}, "message": "Update documentation.\n\nFrom-SVN: r13606", "tree": {"sha": "046b6e4172effc043f9561538d0cb3f13177f09b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/046b6e4172effc043f9561538d0cb3f13177f09b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f19911e44a7479ec849f93908521efb689e7a700", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f19911e44a7479ec849f93908521efb689e7a700", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f19911e44a7479ec849f93908521efb689e7a700", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f19911e44a7479ec849f93908521efb689e7a700/comments", "author": null, "committer": null, "parents": [{"sha": "55e777641fb97d3141471ed91237b6a7422f1340", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55e777641fb97d3141471ed91237b6a7422f1340", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55e777641fb97d3141471ed91237b6a7422f1340"}], "stats": {"total": 216, "additions": 176, "deletions": 40}, "files": [{"sha": "5c3a4d1a131e6f4cdc588d68ac60f491db257bfc", "filename": "gcc/objc/THREADS", "status": "modified", "additions": 176, "deletions": 40, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f19911e44a7479ec849f93908521efb689e7a700/gcc%2Fobjc%2FTHREADS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f19911e44a7479ec849f93908521efb689e7a700/gcc%2Fobjc%2FTHREADS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FTHREADS?ref=f19911e44a7479ec849f93908521efb689e7a700", "patch": "@@ -12,7 +12,7 @@ Objective-C runtime you can reach Galen at:\n Any questions, comments, bug reports, etc. should send email either to the\n GCC bug account or to:\n \n-\tScott Christley <scottc@ocbi.com>\n+\tScott Christley <scottc@net-community.com>\n \n * Sarray Threading:\n \n@@ -87,16 +87,38 @@ Notes:\n 2) Initialized value will always be same, guaranteed by lock on selector \n    hash table.\n \n+\n ******************************************************************************\n-* Linking:\n+* Frontend/Backend design:\n+\n+The design of the Objective-C runtime thread and mutex functions utilizes a\n+frontend/backend implementation.\n+\n+The frontend, as characterized by the files thr.h and thr.c, is a set\n+of platform independent structures and functions which represent the\n+user interface.  Objective-C programs should use these structures and\n+functions for their thread and mutex work if they wish to maintain a\n+high degree of portability across platforms.\n \n-On Solaris, you must link with -lthread to include the system\n-thread library.  We use its low level thread and mutex implementations.\n+The backend is composed of a file with the necessary code to map the ObjC\n+thread and mutex to a platform specific implementation.  For example, the\n+file thr-solaris.c contains the implementation for Solaris.  When you \n+configure GCC, it attempts to pick an appropriate backend file for the\n+target platform; however, you can override this choice by assign the\n+OBJC_THREAD_FILE make variable to the basename of the backend file.  This\n+is especially useful on platforms which have multiple thread libraries.\n+For example:\n \n-On OSF/1, you must link with -lpthreads to include the pthreads library.\n+\tmake OBJC_THREAD_FILE=thr-posix\n+\n+would indicate that the generic posix backend file, thr-posix.c, should be\n+compiled with the ObjC runtime library.  If your platform does not support\n+threads then you should specify the OBJC_THREAD_FILE=thr-single backend file\n+to compile the ObjC runtime library without thread or mutex support; note\n+that programs which rely upon the ObjC thread and mutex functions will\n+compile and link correctly but attempting to create a thread or mutex will\n+result in an error.\n \n-On WIN32, thread support is built-in to the WIN32 API; refer to your\n-compiler documentation for the appropriate library.\n \n ******************************************************************************\n * Threads:\n@@ -108,27 +130,25 @@ that the system implementation of malloc and free must be thread safe.\n If a system has multiple processors, the threads are configured for\n full parallel processing.\n \n-__objc_init_thread_system(void), int\n-\tInitialize the thread subsystem.  Call once by __objc_exec_class.\n+*****\n+* Frontend thread functions\n+* User programs should use these thread functions.\n \n-__objc_fini_thread_system(void), int\n-\tCloses the thread subsystem.\n-\n-objc_thread_detach(SEL selector, id object, id argument), int\n+objc_thread_detach(SEL selector, id object, id argument), objc_thread_t\n \tCreates and detaches a new thread.  The new thread starts by\n \tsending the given selector with a single argument to the\n \tgiven object.\n \n objc_thread_set_priority(int priority), int\n-\tSets a threads relative priority within the program.  Valid\n+\tSets a thread's relative priority within the program.  Valid\n \toptions are:\n \t\n \tOBJC_THREAD_INTERACTIVE_PRIORITY\n \tOBJC_THREAD_BACKGROUND_PRIORITY\n \tOBJC_THREAD_LOW_PRIORITY\n \n objc_thread_get_priority(void), int\n-\tQuery a threads priority.\n+\tQuery a thread's priority.\n \n objc_thread_yield(void), void\n \tYields processor to another thread with equal or higher\n@@ -149,52 +169,168 @@ objc_thread_set_data(void *value), int\n objc_thread_get_data(void), void *\n \tReturns the pointer to the thread's local storage.\n \n+*****\n+* Backend thread functions\n+* User programs should *NOT* directly call these functions.\n+\n+__objc_init_thread_system(void), int\n+\tInitialize the thread subsystem.  Called once by __objc_exec_class.\n+\tReturn -1 if error otherwise return 0.\n+\n+__objc_fini_thread_system(void), int\n+\tCloses the thread subsystem, not currently guaranteed to be called.\n+\tReturn -1 if error otherwise return 0.\n+\n+__objc_thread_create(void (*func)(void *arg), void *arg), objc_thread_t\n+\tSpawns a new thread executing func, called by objc_thread_detach.\n+\tReturn NULL if error otherwise return thread id.\n+\n+__objc_thread_set_priority(int priority), int\n+\tSet the thread's priority, called by objc_thread_set_priority.\n+\tReturn -1 if error otherwise return 0.\n+\n+__objc_thread_get_priority(void), int\n+\tQuery a thread's priority, called by objc_thread_get_priority.\n+\tReturn -1 if error otherwise return the priority.\n+\n+__objc_thread_yield(void), void\n+\tYields the processor, called by objc_thread_yield.\n+\n+__objc_thread_exit(void), int\n+\tTerminates the thread, called by objc_thread_exit.\n+\tReturn -1 if error otherwise function does not return.\n+\n+__objc_thread_id(void), objc_thread_t\n+\tReturns the current thread's id, called by objc_thread_id.\n+\tReturn -1 if error otherwise return thread id.\n+\n+__objc_thread_set_data(void *value), int\n+\tSet pointer for thread local storage, called by objc_thread_set_data.\n+\tReturns -1 if error otherwise return 0.\n+\n+__objc_thread_get_data(void), void *\n+\tReturns the pointer to the thread's local storage.\n+\tReturns NULL if error, called by objc_thread_get_data.\n+\n+\n ******************************************************************************\n * Mutexs:\n \n-Mutexs can be locked recursively.  Each mutex locked mutex remembers\n+Mutexs can be locked recursively.  Each locked mutex remembers\n its owner (by thread id) and how many times it has been locked.  The\n last unlock on a mutex removes the system lock and allows other\n threads to access the mutex.\n \n-objc_mutex_allocate(void), Mutex_t\n+*****\n+* Frontend thread functions\n+* User programs should use these thread functions.\n+\n+objc_mutex_allocate(void), objc_mutex_t\n \tAllocates a new mutex.  Mutex is initially unlocked.\n \n-objc_mutex_deallocate(Mutex_t mutex), int\n+objc_mutex_deallocate(objc_mutex_t mutex), int\n \tFree a mutex.  Before freeing the mutex, makes sure that no\n \tone else is using it.\n \n-objc_mutex_lock(Mutex_t mutex), int\n+objc_mutex_lock(objc_mutex_t mutex), int\n \tLocks a mutex.  As mentioned earlier, the same thread may call\n \tthis routine repeatedly.\n \t\n-objc_mutex_trylock(Mutex_t mutex), int\n+objc_mutex_trylock(objc_mutex_t mutex), int\n \tAttempts to lock a mutex.  Returns -1 if failed.  If lock on\n \tmutex can be acquired then function operates exactly as\n \tobjc_mutex_lock.\n \n-objc_mutex_unlock(Mutex_t mutex), int\n+objc_mutex_unlock(objc_mutex_t mutex), int\n \tUnlocks the mutex by one level.  Other threads may not acquire\n \tthe mutex until this thread has released all locks on it.\n \n+*****\n+* Backend thread functions\n+* User programs should *NOT* directly call these functions.\n+\n+__objc_mutex_allocate(void), objc_mutex_t\n+\tAllocates a new mutex, called by objc_mutex_allocate.\n+\tReturn NULL if error otherwise return mutex pointer.\n+\n+__objc_mutex_deallocate(objc_mutex_t mutex), int\n+\tFree a mutex, called by objc_mutex_deallocate.\n+\tReturn -1 if error otherwise return 0.\n+\n+__objc_mutex_lock(objc_mutex_t mutex), int\n+\tLocks a mutex, called by objc_mutex_lock.\n+\tReturn -1 if error otherwise return 0.\n+\t\n+__objc_mutex_trylock(objc_mutex_t mutex), int\n+\tAttempts to lock a mutex, called by objc_mutex_trylock.\n+\tReturn -1 if failed to acquire lock or error otherwise return 0.\n+\n+__objc_mutex_unlock(objc_mutex_t mutex), int\n+\tUnlocks the mutex, called by objc_mutex_unlock.\n+\tReturn -1 if error otherwise return 0.\n+\n ******************************************************************************\n-* Sample run of thread-test/checks/test01.m\n-\n-<< program started >>\t\t\t\t-- Program started\n-__objc_exec_class(Object.m)\t\t\t-- Initialize once \n-__objc_init_mutex_system\n-__objc_init_thread_system\n-__objc_init_selector_tables()  \n-__objc_init_class_tables()  \n-__objc_init_dispatch_tables() \n-__objc_exec_class(Protocol.m)\t\t\t-- Called repeatedly\n-__objc_init_protocols(0x000746d4) \t\t-- Called repeatedly\n-class_add_method_list(0x74718, 0x74208) \t-- Called repeatedly\n-<< main called >>\t\t\t\t-- Main called\n-__objc_init_install_dtable(0x6d980, 0x6d5c0)    -- Called repeatedly\n-<< delegatePool filled, count=10 >>\t\t-- Code in secondary function\n-__objc_init_install_dtable(0x76268, 0x70614)    -- Called repeatedly\n-Array: count=1\t\t\t\t\t-- More secondary code.\n-EltNodeCollector: count=1\n-<< end of program >>\t\t\t\t-- End of program\n+* Condition Mutexs:\n+\n+Mutexs can be locked recursively.  Each locked mutex remembers\n+its owner (by thread id) and how many times it has been locked.  The\n+last unlock on a mutex removes the system lock and allows other\n+threads to access the mutex.\n \n+*****\n+* Frontend thread functions\n+* User programs should use these thread functions.\n+\n+objc_condition_allocate(void), objc_condition_t \n+\tAllocate a condition mutex.\n+\tReturn NULL if error otherwise return condition pointer.\n+\n+objc_condition_deallocate(objc_condition_t condition), int\n+\tDeallocate a condition. Note that this includes an implicit\n+\tcondition_broadcast to insure that waiting threads have the \n+\topportunity to wake.  It is legal to dealloc a condition only\n+\tif no other thread is/will be using it. Does NOT check for\n+\tother threads waiting but just wakes them up.\n+\n+objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex), int\n+\tWait on the condition unlocking the mutex until objc_condition_signal()\n+\tor objc_condition_broadcast() are called for the same condition. The\n+\tgiven mutex *must* have the depth 1 so that it can be unlocked\n+\there, for someone else can lock it and signal/broadcast the condition.\n+\tThe mutex is used to lock access to the shared data that make up the\n+\t\"condition\" predicate.\n+\t\n+objc_condition_broadcast(objc_condition_t condition), int\n+\tWake up all threads waiting on this condition. It is recommended that \n+\tthe called would lock the same mutex as the threads in\n+\tobjc_condition_wait before changing the \"condition predicate\"\n+\tand make this call and unlock it right away after this call.\n+\n+objc_condition_signal(objc_condition_t condition), int\n+\tWake up one thread waiting on this condition.\n+\n+*****\n+* Backend thread functions\n+* User programs should *NOT* directly call these functions.\n+\n+__objc_condition_allocate(void), objc_condition_t \n+\tAllocate a condition mutex, called by objc_condition_allocate.\n+\tReturn NULL if error otherwise return condition pointer.\n+\n+__objc_condition_deallocate(objc_condition_t condition), int\n+\tDeallocate a condition, called by objc_condition_deallocate.\n+\tReturn -1 if error otherwise return 0.\n+\n+__objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex), int\n+\tWait on the condition, called by objc_condition_wait.\n+\tReturn -1 if error otherwise return 0 when condition is met.\n+\t\n+__objc_condition_broadcast(objc_condition_t condition), int\n+\tWake up all threads waiting on this condition.\n+\tCalled by objc_condition_broadcast.\n+\tReturn -1 if error otherwise return 0.\n+\n+__objc_condition_signal(objc_condition_t condition), int\n+\tWake up one thread waiting on this condition.\n+\tCalled by objc_condition_signal.\n+\tReturn -1 if error otherwise return 0."}]}