{"sha": "a64478660ee95930773d356760e39e05fe0147fe", "node_id": "C_kwDOANBUbNoAKGE2NDQ3ODY2MGVlOTU5MzA3NzNkMzU2NzYwZTM5ZTA1ZmUwMTQ3ZmU", "commit": {"author": {"name": "Patrick Bernardi", "email": "bernardi@adacore.com", "date": "2021-12-22T21:32:41Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-01-07T16:24:15Z"}, "message": "[Ada] Read directory in Ada.Directories.Start_Search rather than Get_Next_Entry\n\ngcc/ada/\n\n\t* libgnat/a-direct.adb (Search_Data): Remove type.\n\t(Directory_Vectors): New package instantiation.\n\t(Search_State): New type.\n\t(Fetch_Next_Entry): Remove.\n\t(Close): Remove.\n\t(Finalize): Rewritten.\n\t(Full_Name): Ditto.\n\t(Get_Next_Entry): Return next entry from Search results vector\n\trather than querying the directory directly using readdir.\n\t(Kind): Rewritten.\n\t(Modification_Time): Rewritten.\n\t(More_Entries): Use Search state cursor to determine if more\n\tentries are available for users to read.\n\t(Simple_Name): Rewritten.\n\t(Size): Rewritten.\n\t(Start_Search_Internal): Rewritten to load the contents of the\n\tdirectory that matches the pattern and filter into the search\n\tobject.\n\t* libgnat/a-direct.ads (Search_Type): New type.\n\t(Search_Ptr): Ditto.\n\t(Directory_Entry_Type): Rewritten to support new Start_Search\n\tprocedure.\n\t* libgnat/s-filatt.ads (File_Length_Attr): New function.", "tree": {"sha": "9ac3b7f48f09479a3ad723ac9949166aa3afd7e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ac3b7f48f09479a3ad723ac9949166aa3afd7e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a64478660ee95930773d356760e39e05fe0147fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a64478660ee95930773d356760e39e05fe0147fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a64478660ee95930773d356760e39e05fe0147fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a64478660ee95930773d356760e39e05fe0147fe/comments", "author": {"login": "burratoo", "id": 23646118, "node_id": "MDQ6VXNlcjIzNjQ2MTE4", "avatar_url": "https://avatars.githubusercontent.com/u/23646118?v=4", "gravatar_id": "", "url": "https://api.github.com/users/burratoo", "html_url": "https://github.com/burratoo", "followers_url": "https://api.github.com/users/burratoo/followers", "following_url": "https://api.github.com/users/burratoo/following{/other_user}", "gists_url": "https://api.github.com/users/burratoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/burratoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/burratoo/subscriptions", "organizations_url": "https://api.github.com/users/burratoo/orgs", "repos_url": "https://api.github.com/users/burratoo/repos", "events_url": "https://api.github.com/users/burratoo/events{/privacy}", "received_events_url": "https://api.github.com/users/burratoo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b573d421a457852da09253f966246fcc0e16a27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b573d421a457852da09253f966246fcc0e16a27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b573d421a457852da09253f966246fcc0e16a27"}], "stats": {"total": 638, "additions": 330, "deletions": 308}, "files": [{"sha": "b8db8dcceb8340ccf85c10d0077093dd793fff21", "filename": "gcc/ada/libgnat/a-direct.adb", "status": "modified", "additions": 272, "deletions": 278, "changes": 550, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a64478660ee95930773d356760e39e05fe0147fe/gcc%2Fada%2Flibgnat%2Fa-direct.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a64478660ee95930773d356760e39e05fe0147fe/gcc%2Fada%2Flibgnat%2Fa-direct.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-direct.adb?ref=a64478660ee95930773d356760e39e05fe0147fe", "patch": "@@ -31,12 +31,14 @@\n \n with Ada.Calendar;               use Ada.Calendar;\n with Ada.Characters.Handling;    use Ada.Characters.Handling;\n+with Ada.Containers.Vectors;\n with Ada.Directories.Validity;   use Ada.Directories.Validity;\n with Ada.Directories.Hierarchical_File_Names;\n-use Ada.Directories.Hierarchical_File_Names;\n+use  Ada.Directories.Hierarchical_File_Names;\n with Ada.Strings.Fixed;\n with Ada.Strings.Maps;           use Ada.Strings.Maps;\n with Ada.Strings.Unbounded;      use Ada.Strings.Unbounded;\n+with Ada.Unchecked_Conversion;\n with Ada.Unchecked_Deallocation;\n \n with Interfaces.C;\n@@ -78,40 +80,56 @@ package body Ada.Directories is\n    --  Result returned from C_Modification_Time call when routine unable to get\n    --  file modification time.\n \n-   type Search_Data is record\n-      Is_Valid      : Boolean := False;\n-      Name          : Unbounded_String;\n-      Pattern       : Regexp;\n-      Filter        : Filter_Type;\n-      Dir           : Dir_Type_Value := No_Dir;\n-      Entry_Fetched : Boolean := False;\n-      Dir_Entry     : Directory_Entry_Type;\n-   end record;\n-   --  The current state of a search\n-\n    Empty_String : constant String := \"\";\n    --  Empty string, returned by function Extension when there is no extension\n \n-   procedure Free is new Ada.Unchecked_Deallocation (Search_Data, Search_Ptr);\n+   ----------------------------\n+   -- Directory Search Types --\n+   ----------------------------\n+\n+   package Directory_Vectors is new\n+     Ada.Containers.Vectors\n+       (Index_Type   => Natural,\n+        Element_Type => Directory_Entry_Type);\n+   use Directory_Vectors;\n+   --  Used to store the results of the directory search\n+\n+   type Dir_Contents_Ptr is access Directory_Vectors.Vector;\n+\n+   procedure Free is new Ada.Unchecked_Deallocation\n+     (Directory_Vectors.Vector, Dir_Contents_Ptr);\n+   --  Directory_Vectors.Vector deallocation routine\n+\n+   type Search_State is new Ada.Finalization.Controlled with record\n+      Dir_Contents : Dir_Contents_Ptr;\n+      Next_Entry   : Cursor;\n+   end record;\n+   --  The Search_State consists of a vector of directory items that match the\n+   --  search pattern and filter, and a cursor pointing to the next item of the\n+   --  vector to be returned to the user.\n+\n+   procedure Free is new Ada.Unchecked_Deallocation (Search_State, Search_Ptr);\n+   --  Search_State deallocation routine\n+\n+   Dir_Vector_Initial_Size : constant := 100;\n+   --  Initial size for the Dir_Contents vector, sized to ensure the vector\n+   --  does not need to be reallocated for reasonably sized directory searches.\n \n-   procedure Close (Dir : Dir_Type_Value);\n+   ------------------------\n+   -- Helper Subprograms --\n+   ------------------------\n \n    function File_Exists (Name : String) return Boolean;\n    --  Returns True if the named file exists\n \n-   procedure Fetch_Next_Entry (Search : Search_Type);\n-   --  Get the next entry in a directory, setting Entry_Fetched if successful\n-   --  or resetting Is_Valid if not.\n-\n    procedure Start_Search_Internal\n-     (Search                 : in out Search_Type;\n-      Directory              : String;\n-      Pattern                : String;\n-      Filter                 : Filter_Type := [others => True];\n-      Force_Case_Insensitive : Boolean);\n-   --  Similar to Start_Search except we can force a search to be\n-   --  case-insensitive, which is important for detecting the name-case\n-   --  equivalence for a given directory.\n+     (Search           : in out Search_Type;\n+      Directory        : String;\n+      Pattern          : String;\n+      Filter           : Filter_Type := [others => True];\n+      Case_Insensitive : Boolean);\n+   --  Similar to Start_Search except we can specify a case-insensitive search.\n+   --  This enables detecting the name-case equivalence for a given directory.\n \n    ---------------\n    -- Base_Name --\n@@ -137,21 +155,6 @@ package body Ada.Directories is\n       return Simple;\n    end Base_Name;\n \n-   -----------\n-   -- Close --\n-   -----------\n-\n-   procedure Close (Dir : Dir_Type_Value) is\n-      Discard : Integer;\n-      pragma Warnings (Off, Discard);\n-\n-      function closedir (directory : DIRs) return Integer;\n-      pragma Import (C, closedir, \"__gnat_closedir\");\n-\n-   begin\n-      Discard := closedir (DIRs (Dir));\n-   end Close;\n-\n    -------------\n    -- Compose --\n    -------------\n@@ -378,7 +381,7 @@ package body Ada.Directories is\n      (New_Directory : String;\n       Form          : String := \"\")\n    is\n-      C_Dir_Name : constant String := New_Directory & ASCII.NUL;\n+      Dir_Name_C : constant String := New_Directory & ASCII.NUL;\n \n    begin\n       --  First, the invalid case\n@@ -411,7 +414,7 @@ package body Ada.Directories is\n                raise Use_Error with \"invalid Form\";\n             end if;\n \n-            if CRTL.mkdir (C_Dir_Name, Encoding) /= 0 then\n+            if CRTL.mkdir (Dir_Name_C, Encoding) /= 0 then\n                raise Use_Error with\n                  \"creation of new directory \"\"\" & New_Directory & \"\"\" failed\";\n             end if;\n@@ -553,9 +556,9 @@ package body Ada.Directories is\n \n       else\n          declare\n-            C_Dir_Name : constant String := Directory & ASCII.NUL;\n+            Dir_Name_C : constant String := Directory & ASCII.NUL;\n          begin\n-            if rmdir (C_Dir_Name) /= 0 then\n+            if rmdir (Dir_Name_C) /= 0 then\n                raise Use_Error with\n                  \"deletion of directory \"\"\" & Directory & \"\"\" failed\";\n             end if;\n@@ -640,10 +643,10 @@ package body Ada.Directories is\n          End_Search (Search);\n \n          declare\n-            C_Dir_Name : constant String := Directory & ASCII.NUL;\n+            Dir_Name_C : constant String := Directory & ASCII.NUL;\n \n          begin\n-            if rmdir (C_Dir_Name) /= 0 then\n+            if rmdir (Dir_Name_C) /= 0 then\n                raise Use_Error with\n                  \"directory tree rooted at \"\"\" &\n                    Directory & \"\"\" could not be deleted\";\n@@ -710,141 +713,6 @@ package body Ada.Directories is\n       end if;\n    end Extension;\n \n-   ----------------------\n-   -- Fetch_Next_Entry --\n-   ----------------------\n-\n-   procedure Fetch_Next_Entry (Search : Search_Type) is\n-      Name : String (1 .. NAME_MAX);\n-      Last : Natural;\n-\n-      Kind : File_Kind := Ordinary_File;\n-      --  Initialized to avoid a compilation warning\n-\n-      Filename_Addr : Address;\n-      Filename_Len  : aliased Integer;\n-\n-      Buffer : array (1 .. SIZEOF_struct_dirent_alloc) of Character;\n-\n-      function readdir_gnat\n-        (Directory : Address;\n-         Buffer    : Address;\n-         Last      : not null access Integer) return Address;\n-      pragma Import (C, readdir_gnat, \"__gnat_readdir\");\n-\n-   begin\n-      --  Search.Value.Is_Valid is always True when Fetch_Next_Entry is called\n-\n-      loop\n-         Filename_Addr :=\n-           readdir_gnat\n-             (Address (Search.Value.Dir),\n-              Buffer'Address,\n-              Filename_Len'Access);\n-\n-         --  If no matching entry is found, set Is_Valid to False\n-\n-         if Filename_Addr = Null_Address then\n-            Search.Value.Is_Valid := False;\n-            exit;\n-         end if;\n-\n-         if Filename_Len > Name'Length then\n-            raise Use_Error with \"file name too long\";\n-         end if;\n-\n-         declare\n-            subtype Name_String is String (1 .. Filename_Len);\n-            Dent_Name : Name_String;\n-            for Dent_Name'Address use Filename_Addr;\n-            pragma Import (Ada, Dent_Name);\n-\n-         begin\n-            Last := Filename_Len;\n-            Name (1 .. Last) := Dent_Name;\n-         end;\n-\n-         --  Check if the entry matches the pattern\n-\n-         if Match (Name (1 .. Last), Search.Value.Pattern) then\n-            declare\n-               C_Full_Name : constant String :=\n-                               Compose (To_String (Search.Value.Name),\n-                                        Name (1 .. Last)) & ASCII.NUL;\n-               Full_Name   : String renames\n-                               C_Full_Name\n-                                 (C_Full_Name'First .. C_Full_Name'Last - 1);\n-               Found       : Boolean := False;\n-               Attr        : aliased File_Attributes;\n-               Exists      : Integer;\n-               Error       : Integer;\n-\n-            begin\n-               Reset_Attributes (Attr'Access);\n-               Exists := File_Exists_Attr (C_Full_Name'Address, Attr'Access);\n-               Error  := Error_Attributes (Attr'Access);\n-\n-               if Error /= 0 then\n-                  raise Use_Error\n-                    with Full_Name & \": \" & Errno_Message (Err => Error);\n-               end if;\n-\n-               if Exists = 1 then\n-                  --  Ignore special directories \".\" and \"..\"\n-\n-                  if (Full_Name'Length > 1\n-                       and then\n-                         Full_Name\n-                            (Full_Name'Last - 1 .. Full_Name'Last) = \"\\.\")\n-                    or else\n-                     (Full_Name'Length > 2\n-                        and then\n-                          Full_Name\n-                            (Full_Name'Last - 2 .. Full_Name'Last) = \"\\..\")\n-                  then\n-                     Exists := 0;\n-                  end if;\n-\n-                  --  Now check if the file kind matches the filter\n-\n-                  if Is_Regular_File_Attr\n-                       (C_Full_Name'Address, Attr'Access) = 1\n-                  then\n-                     if Search.Value.Filter (Ordinary_File) then\n-                        Kind := Ordinary_File;\n-                        Found := True;\n-                     end if;\n-\n-                  elsif Is_Directory_Attr\n-                          (C_Full_Name'Address, Attr'Access) = 1\n-                  then\n-                     if Search.Value.Filter (Directory) then\n-                        Kind := Directory;\n-                        Found := True;\n-                     end if;\n-\n-                  elsif Search.Value.Filter (Special_File) then\n-                     Kind := Special_File;\n-                     Found := True;\n-                  end if;\n-\n-                  --  If it does, update Search and return\n-\n-                  if Found then\n-                     Search.Value.Entry_Fetched := True;\n-                     Search.Value.Dir_Entry :=\n-                       (Is_Valid => True,\n-                        Simple   => To_Unbounded_String (Name (1 .. Last)),\n-                        Full     => To_Unbounded_String (Full_Name),\n-                        Kind     => Kind);\n-                     exit;\n-                  end if;\n-               end if;\n-            end;\n-         end if;\n-      end loop;\n-   end Fetch_Next_Entry;\n-\n    -----------------\n    -- File_Exists --\n    -----------------\n@@ -867,15 +735,9 @@ package body Ada.Directories is\n \n    procedure Finalize (Search : in out Search_Type) is\n    begin\n-      if Search.Value /= null then\n-\n-         --  Close the directory, if one is open\n-\n-         if Search.Value.Dir /= No_Dir then\n-            Close (Search.Value.Dir);\n-         end if;\n-\n-         Free (Search.Value);\n+      if Search.State /= null then\n+         Free (Search.State.Dir_Contents);\n+         Free (Search.State);\n       end if;\n    end Finalize;\n \n@@ -910,15 +772,13 @@ package body Ada.Directories is\n \n    function Full_Name (Directory_Entry : Directory_Entry_Type) return String is\n    begin\n-      --  First, the invalid case\n+      --  If the Directory_Entry is valid return the full name contained in the\n+      --  entry record.\n \n-      if not Directory_Entry.Is_Valid then\n+      if not Directory_Entry.Valid then\n          raise Status_Error with \"invalid directory entry\";\n-\n       else\n-         --  The value to return has already been computed\n-\n-         return To_String (Directory_Entry.Full);\n+         return To_String (Directory_Entry.Full_Name);\n       end if;\n    end Full_Name;\n \n@@ -931,28 +791,34 @@ package body Ada.Directories is\n       Directory_Entry : out Directory_Entry_Type)\n    is\n    begin\n-      --  First, the invalid case\n+      --  A Search with no state implies the user has not called Start_Search\n \n-      if Search.Value = null or else not Search.Value.Is_Valid then\n-         raise Status_Error with \"invalid search\";\n+      if Search.State = null then\n+         raise Status_Error with \"search not started\";\n       end if;\n \n-      --  Fetch the next entry, if needed\n+      --  If the next entry is No_Element it means the search is finished and\n+      --  there are no more entries to return.\n \n-      if not Search.Value.Entry_Fetched then\n-         Fetch_Next_Entry (Search);\n+      if Search.State.Next_Entry = No_Element then\n+         raise Status_Error with \"no more entries\";\n       end if;\n \n-      --  It is an error if no valid entry is found\n+      --  Populate Directory_Entry with the next entry and update the search\n+      --  state.\n \n-      if not Search.Value.Is_Valid then\n-         raise Status_Error with \"no next entry\";\n+      Directory_Entry := Element (Search.State.Next_Entry);\n+      Next (Search.State.Next_Entry);\n \n-      else\n-         --  Reset Entry_Fetched and return the entry\n+      --  If Start_Search received a non-zero error code when trying to read\n+      --  the file attributes of this entry, raise an Use_Error so the user\n+      --  is aware that it was not possible to retrieve the attributes of this\n+      --  entry.\n \n-         Search.Value.Entry_Fetched := False;\n-         Directory_Entry := Search.Value.Dir_Entry;\n+      if Directory_Entry.Attr_Error_Code /= 0 then\n+         raise Use_Error\n+           with To_String (Directory_Entry.Full_Name) & \": \" &\n+             Errno_Message (Err => Directory_Entry.Attr_Error_Code);\n       end if;\n    end Get_Next_Entry;\n \n@@ -982,14 +848,9 @@ package body Ada.Directories is\n \n    function Kind (Directory_Entry : Directory_Entry_Type) return File_Kind is\n    begin\n-      --  First, the invalid case\n-\n-      if not Directory_Entry.Is_Valid then\n+      if not Directory_Entry.Valid then\n          raise Status_Error with \"invalid directory entry\";\n-\n       else\n-         --  The value to return has already be computed\n-\n          return Directory_Entry.Kind;\n       end if;\n    end Kind;\n@@ -1025,15 +886,15 @@ package body Ada.Directories is\n      (Directory_Entry : Directory_Entry_Type) return Ada.Calendar.Time\n    is\n    begin\n-      --  First, the invalid case\n+      --  If the Directory_Entry is valid return the modification time\n+      --  contained in the entry record. The modification time is recorded in\n+      --  the entry since its cheap to query all the file the attributes in\n+      --  one read when the directory is searched.\n \n-      if not Directory_Entry.Is_Valid then\n+      if not Directory_Entry.Valid then\n          raise Status_Error with \"invalid directory entry\";\n-\n       else\n-         --  The value to return has already be computed\n-\n-         return Modification_Time (To_String (Directory_Entry.Full));\n+         return Directory_Entry.Modification_Time;\n       end if;\n    end Modification_Time;\n \n@@ -1043,19 +904,17 @@ package body Ada.Directories is\n \n    function More_Entries (Search : Search_Type) return Boolean is\n    begin\n-      if Search.Value = null then\n-         return False;\n-\n-      elsif Search.Value.Is_Valid then\n+      --  If the vector cursor Search.State.Next_Entry points to an element in\n+      --  Search.State.Dir_Contents then there is another entry to return.\n+      --  Otherwise, we return False.\n \n-         --  Fetch the next entry, if needed\n-\n-         if not Search.Value.Entry_Fetched then\n-            Fetch_Next_Entry (Search);\n-         end if;\n+      if Search.State = null then\n+         return False;\n+      elsif Search.State.Next_Entry = No_Element then\n+         return False;\n+      else\n+         return True;\n       end if;\n-\n-      return Search.Value.Is_Valid;\n    end More_Entries;\n \n    ---------------------------\n@@ -1115,7 +974,7 @@ package body Ada.Directories is\n          Directory              => To_String (Dir_Path),\n          Pattern                => Simple_Name (Test_File),\n          Filter                 => [Directory => False, others => True],\n-         Force_Case_Insensitive => True);\n+         Case_Insensitive => True);\n \n       --  We will find at least one match due to the search hitting our test\n       --  file.\n@@ -1237,7 +1096,7 @@ package body Ada.Directories is\n    -------------------\n \n    procedure Set_Directory (Directory : String) is\n-      C_Dir_Name : constant String := Directory & ASCII.NUL;\n+      Dir_Name_C : constant String := Directory & ASCII.NUL;\n    begin\n       if not Is_Valid_Path_Name (Directory) then\n          raise Name_Error with\n@@ -1247,7 +1106,7 @@ package body Ada.Directories is\n          raise Name_Error with\n            \"directory \"\"\" & Directory & \"\"\" does not exist\";\n \n-      elsif chdir (C_Dir_Name) /= 0 then\n+      elsif chdir (Dir_Name_C) /= 0 then\n          raise Name_Error with\n            \"could not set to designated directory \"\"\" & Directory & '\"';\n       end if;\n@@ -1344,15 +1203,13 @@ package body Ada.Directories is\n    function Simple_Name\n      (Directory_Entry : Directory_Entry_Type) return String is\n    begin\n-      --  First, the invalid case\n+      --  If the Directory_Entry is valid return the simple name contained in\n+      --  the entry record.\n \n-      if not Directory_Entry.Is_Valid then\n+      if not Directory_Entry.Valid then\n          raise Status_Error with \"invalid directory entry\";\n-\n       else\n-         --  The value to return has already be computed\n-\n-         return To_String (Directory_Entry.Simple);\n+         return To_String (Directory_Entry.Name);\n       end if;\n    end Simple_Name;\n \n@@ -1381,15 +1238,15 @@ package body Ada.Directories is\n \n    function Size (Directory_Entry : Directory_Entry_Type) return File_Size is\n    begin\n-      --  First, the invalid case\n+      --  If the Directory_Entry is valid return the size contained in the\n+      --  entry record. The size is recorded in the entry since it is cheap to\n+      --  query all the file the attributes in one read when the directory is\n+      --  searched.\n \n-      if not Directory_Entry.Is_Valid then\n+      if not Directory_Entry.Valid then\n          raise Status_Error with \"invalid directory entry\";\n-\n       else\n-         --  The value to return has already be computed\n-\n-         return Size (To_String (Directory_Entry.Full));\n+         return Directory_Entry.Size;\n       end if;\n    end Size;\n \n@@ -1412,69 +1269,206 @@ package body Ada.Directories is\n    ---------------------------\n \n    procedure Start_Search_Internal\n-     (Search                 : in out Search_Type;\n-      Directory              : String;\n-      Pattern                : String;\n-      Filter                 : Filter_Type := [others => True];\n-      Force_Case_Insensitive : Boolean)\n+     (Search           : in out Search_Type;\n+      Directory        : String;\n+      Pattern          : String;\n+      Filter           : Filter_Type := [others => True];\n+      Case_Insensitive : Boolean)\n    is\n-      function opendir (file_name : String) return DIRs;\n-      pragma Import (C, opendir, \"__gnat_opendir\");\n+      function closedir (Directory : DIRs) return Integer\n+        with Import, External_Name => \"__gnat_closedir\", Convention => C;\n+      --  C lib function to close Directory\n+\n+      function opendir (Directory : String) return DIRs\n+        with Import, External_Name => \"__gnat_opendir\", Convention => C;\n+      --  C lib function to open Directory\n+\n+      function readdir_gnat\n+        (Directory : Address;\n+         Buffer    : Address;\n+         Last      : not null access Integer) return Address\n+        with Import, External_Name => \"__gnat_readdir\", Convention => C;\n+      --  Read the next item in Directory\n \n-      C_File_Name : constant String := Directory & ASCII.NUL;\n-      Pat         : Regexp;\n-      Dir         : Dir_Type_Value;\n+      Dir_Name_C       : constant String := Directory & ASCII.NUL;\n+      Dir_Entry_Buffer : array (1 .. SIZEOF_struct_dirent_alloc) of Character;\n+      Dir_Pointer      : Dir_Type_Value;\n+      File_Name_Addr   : Address;\n+      File_Name_Len    : aliased Integer;\n+      Pattern_Regex    : Regexp;\n+\n+      Call_Result      : Integer;\n+      pragma Warnings (Off, Call_Result);\n+      --  Result of calling a C function that returns a status\n \n    begin\n-      --  First, the invalid case Name_Error\n+      --  Check that Directory is a valid directory\n \n       if not Is_Directory (Directory) then\n          raise Name_Error with\n            \"unknown directory \"\"\" & Simple_Name (Directory) & '\"';\n       end if;\n \n-      --  Check the pattern\n+      --  Check and compile the pattern\n \n       declare\n          Case_Sensitive : Boolean := Is_Path_Name_Case_Sensitive;\n       begin\n-         if Force_Case_Insensitive then\n+         if Case_Insensitive then\n             Case_Sensitive := False;\n          end if;\n \n-         Pat :=\n-           Compile\n-             (Pattern,\n-              Glob           => True,\n-              Case_Sensitive => Case_Sensitive);\n+         Pattern_Regex :=\n+           Compile (Pattern, Glob => True, Case_Sensitive => Case_Sensitive);\n       exception\n          when Error_In_Regexp =>\n-            Free (Search.Value);\n             raise Name_Error with \"invalid pattern \"\"\" & Pattern & '\"';\n       end;\n \n-      Dir := Dir_Type_Value (opendir (C_File_Name));\n+      --  Open Directory\n+\n+      Dir_Pointer := Dir_Type_Value (opendir (Dir_Name_C));\n \n-      if Dir = No_Dir then\n+      if Dir_Pointer = No_Dir then\n          raise Use_Error with\n            \"unreadable directory \"\"\" & Simple_Name (Directory) & '\"';\n       end if;\n \n-      --  If needed, finalize Search\n+      --  If needed, finalize Search. Note: we should probably raise an\n+      --  exception here if Search belongs to an existing search rather than\n+      --  quietly end it. However, we first need to check that it won't break\n+      --  existing software.\n \n       Finalize (Search);\n \n-      --  Allocate the default data\n+      --  Allocate and initialize the search state\n+\n+      Search.State := new Search_State'\n+        (Ada.Finalization.Controlled with\n+         Dir_Contents  => new Vector,\n+         Next_Entry    => No_Element);\n+\n+      --  Increase the size of the Dir_Contents vector so it does not need to\n+      --  grow for most reasonable directory searches.\n+\n+      Search.State.Dir_Contents.Reserve_Capacity (Dir_Vector_Initial_Size);\n+\n+      --  Read the contents of Directory into Search.State\n+\n+      loop\n+         --  Get next item in the directory\n+\n+         File_Name_Addr :=\n+           readdir_gnat\n+             (Address (Dir_Pointer),\n+              Dir_Entry_Buffer'Address,\n+              File_Name_Len'Access);\n+\n+         exit when File_Name_Addr = Null_Address;\n+\n+         --  If the file name matches the Pattern and the file type matches\n+         --  the Filter add it to our search vector.\n+\n+         declare\n+            subtype File_Name_String is String (1 .. File_Name_Len);\n+\n+            File_Name : constant File_Name_String\n+              with Import, Address => File_Name_Addr;\n+\n+         begin\n+            if Match (File_Name, Pattern_Regex) then\n+               declare\n+                  Path_C : constant String :=\n+                             Compose (Directory, File_Name) & ASCII.NUL;\n+                  Path   : String renames\n+                             Path_C (Path_C'First .. Path_C'Last - 1);\n+                  Found  : Boolean := False;\n+                  Attr   : aliased File_Attributes;\n+                  Exists : Integer;\n+                  Error  : Integer;\n+                  Kind   : File_Kind;\n+                  Size   : File_Size;\n+\n+               begin\n+                  --  Get the file attributes for the directory item\n+\n+                  Reset_Attributes (Attr'Access);\n+                  Exists := File_Exists_Attr (Path_C'Address, Attr'Access);\n+                  Error  := Error_Attributes (Attr'Access);\n+\n+                  --  If there was an error when trying to read the attributes\n+                  --  of a Directory entry, record the error so it can be\n+                  --  propagated to the user when they interate through the\n+                  --  directory results.\n+\n+                  if Error /= 0 then\n+                     Search.State.Dir_Contents.Append\n+                       (Directory_Entry_Type'\n+                          [Valid           => True,\n+                           Name            => To_Unbounded_String (File_Name),\n+                           Full_Name       => To_Unbounded_String (Path),\n+                           Attr_Error_Code => Error,\n+                           others          => <>]);\n+\n+                  --  Otherwise, if the file exists and matches the file kind\n+                  --  Filter, add the file to the search results. We capture\n+                  --  the size and modification time here as we have already\n+                  --  the entry's attributes above.\n+\n+                  elsif Exists = 1 then\n+                     if Is_Regular_File_Attr (Path_C'Address, Attr'Access) = 1\n+                       and then Filter (Ordinary_File)\n+                     then\n+                        Found := True;\n+                        Kind := Ordinary_File;\n+                        Size :=\n+                          File_Size\n+                            (File_Length_Attr\n+                               (-1, Path_C'Address, Attr'Access));\n+\n+                     elsif Is_Directory_Attr (Path_C'Address, Attr'Access) = 1\n+                       and then Filter (File_Kind'First)\n+                     then\n+                        Found := True;\n+                        Kind := File_Kind'First;\n+                        --  File_Kind'First is used instead of Directory due\n+                        --  to a name overload issue with the procedure\n+                        --  parameter Directory.\n+                        Size := 0;\n+\n+                     elsif Filter (Special_File) then\n+                        Found := True;\n+                        Kind := Special_File;\n+                        Size := 0;\n+                     end if;\n+\n+                     if Found then\n+                        Search.State.Dir_Contents.Append\n+                          (Directory_Entry_Type'\n+                             [Valid             => True,\n+                              Name              =>\n+                                To_Unbounded_String (File_Name),\n+                              Full_Name         => To_Unbounded_String (Path),\n+                              Attr_Error_Code   => 0,\n+                              Kind              => Kind,\n+                              Modification_Time => Modification_Time (Path),\n+                              Size              => Size]);\n+                     end if;\n+                  end if;\n+               end;\n+            end if;\n+         end;\n+      end loop;\n+\n+      --  Set the first entry to be returned to the user to be the first\n+      --  element of the Dir_Contents vector. If no items were found, First\n+      --  will return No_Element, which signals\n+      Search.State.Next_Entry := Search.State.Dir_Contents.First;\n \n-      Search.Value := new Search_Data;\n+      --  Search is finished, close Directory\n \n-      --  Initialize some Search components\n+      Call_Result := closedir (DIRs (Dir_Pointer));\n \n-      Search.Value.Filter   := Filter;\n-      Search.Value.Name     := To_Unbounded_String (Full_Name (Directory));\n-      Search.Value.Pattern  := Pat;\n-      Search.Value.Dir      := Dir;\n-      Search.Value.Is_Valid := True;\n    end Start_Search_Internal;\n \n end Ada.Directories;"}, {"sha": "05106b3aec03927f087fe8a87b0a36274b2baba4", "filename": "gcc/ada/libgnat/a-direct.ads", "status": "modified", "additions": 52, "deletions": 30, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a64478660ee95930773d356760e39e05fe0147fe/gcc%2Fada%2Flibgnat%2Fa-direct.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a64478660ee95930773d356760e39e05fe0147fe/gcc%2Fada%2Flibgnat%2Fa-direct.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-direct.ads?ref=a64478660ee95930773d356760e39e05fe0147fe", "patch": "@@ -372,14 +372,17 @@ package Ada.Directories is\n    --  matching pattern. If Pattern is null, all items in the directory are\n    --  matched; otherwise, the interpretation of Pattern is implementation-\n    --  defined. Only items which match Filter will be returned. After a\n-   --  successful call on Start_Search, the object Search may have entries\n-   --  available, but it may have no entries available if no files or\n-   --  directories match Pattern and Filter. The exception Name_Error is\n-   --  propagated if the string given by Directory does not identify an\n-   --  existing directory, or if Pattern does not allow the identification of\n-   --  any possible external file or directory. The exception Use_Error is\n-   --  propagated if the external environment does not support the searching\n-   --  of the directory with the given name (in the absence of Name_Error).\n+   --  successful call on Start_Search, the object Search will be populated\n+   --  with the items of the directory that match the Pattern and Filter, if\n+   --  any. Any subsequent change to the directory after the call to\n+   --  Start_Search will not be reflected in the Search object.\n+   --\n+   --  The exception Name_Error is propagated if the string given by Directory\n+   --  does not identify an existing directory, or if Pattern does not allow\n+   --  the identification of any possible external file or directory. The\n+   --  exception Use_Error is propagated if the external environment does not\n+   --  support the searching of the directory with the given name (in the\n+   --  absence of Name_Error).\n \n    procedure End_Search (Search : in out Search_Type);\n    --  Ends the search represented by Search. After a successful call on\n@@ -397,12 +400,12 @@ package Ada.Directories is\n       Directory_Entry : out Directory_Entry_Type);\n    --  Returns the next Directory_Entry for the search described by Search that\n    --  matches the pattern and filter. If no further matches are available,\n-   --  Status_Error is raised. It is implementation-defined as to whether the\n-   --  results returned by this routine are altered if the contents of the\n-   --  directory are altered while the Search object is valid (for example, by\n-   --  another program). The exception Use_Error is propagated if the external\n-   --  environment does not support continued searching of the directory\n-   --  represented by Search.\n+   --  Status_Error is raised. The results returned by this routine reflect the\n+   --  contents of the directory at the time of the Start_Search call.\n+   --  Consequently, changes to the contents of the directory, by this or\n+   --  another program, will not be reflected in the Search object. The\n+   --  exception Use_Error is propagated if the external environment does not\n+   --  support continued searching of the directory represented by Search.\n \n    procedure Search\n      (Directory : String;\n@@ -472,30 +475,49 @@ package Ada.Directories is\n    Device_Error : exception renames Ada.IO_Exceptions.Device_Error;\n \n private\n-   type Directory_Entry_Type is record\n-      Is_Valid : Boolean := False;\n-      Simple   : Ada.Strings.Unbounded.Unbounded_String;\n-      Full     : Ada.Strings.Unbounded.Unbounded_String;\n-      Kind     : File_Kind := Ordinary_File;\n+   type Search_State;\n+   type Search_Ptr is access Search_State;\n+   --  To simplify the setup of a new search and its subsequent teardown, the\n+   --  state of Search_Type is implemented in a seperate record type that can\n+   --  be allocated when a new search is started and deallocated when the\n+   --  search is ended. The type is defined in the body as it is not required\n+   --  by child packages.\n+\n+   type Search_Type is new Ada.Finalization.Controlled with record\n+      State : Search_Ptr;\n    end record;\n \n-   --  The type Search_Data is defined in the body, so that the spec does not\n-   --  depend on packages of the GNAT hierarchy.\n+   type Directory_Entry_Type is record\n+      Valid : Boolean := False;\n+      --  Indicates if the record has been populated by the Get_Next_Entry\n+      --  procedure. The default initialization ensures objects created through\n+      --  declarations or allocators are identified as not valid for use with\n+      --  the Directory_Entry_Type routines until Get_Next_Entry is called.\n \n-   type Search_Data;\n-   type Search_Ptr is access Search_Data;\n+      Name : Ada.Strings.Unbounded.Unbounded_String;\n+      --  The name of the item in the directory\n \n-   --  Search_Type need to be a controlled type, because it includes component\n-   --  of type Dir_Type (in GNAT.Directory_Operations) that need to be closed\n-   --  (if opened) during finalization. The component need to be an access\n-   --  value, because Search_Data is not fully defined in the spec.\n+      Full_Name : Ada.Strings.Unbounded.Unbounded_String;\n+      --  The full path to the item\n \n-   type Search_Type is new Ada.Finalization.Controlled with record\n-      Value : Search_Ptr;\n+      Attr_Error_Code : Integer;\n+      --  The error code returned when querying the item's file attributes\n+      --  during Start_Search. Allows Get_Next_Entry to raise an exception when\n+      --  the error code is non-zero.\n+\n+      Kind : File_Kind;\n+      --  The type of item\n+\n+      Modification_Time : Ada.Calendar.Time;\n+      --  The modification time of the item at the time of Start_Search\n+\n+      Size : File_Size;\n+      --  The size of an ordinary file at the time of Start_Search. For special\n+      --  files and directories, Size is always zero.\n    end record;\n \n    procedure Finalize (Search : in out Search_Type);\n-   --  Close the directory, if opened, and deallocate Value\n+   --  Deallocate the data structures used for the search\n \n    procedure End_Search (Search : in out Search_Type) renames Finalize;\n "}, {"sha": "39d4e5535a2c6c160ed4bbe7cb8903b6f07c7346", "filename": "gcc/ada/libgnat/s-filatt.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a64478660ee95930773d356760e39e05fe0147fe/gcc%2Fada%2Flibgnat%2Fs-filatt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a64478660ee95930773d356760e39e05fe0147fe/gcc%2Fada%2Flibgnat%2Fs-filatt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-filatt.ads?ref=a64478660ee95930773d356760e39e05fe0147fe", "patch": "@@ -46,6 +46,11 @@ package System.File_Attributes is\n      (N : System.Address;\n       A : access File_Attributes) return Integer;\n \n+   function File_Length_Attr\n+     (FD : Integer;\n+      N  : System.Address;\n+      A  : access File_Attributes) return Long_Long_Integer;\n+\n    function Is_Regular_File_Attr\n      (N : System.Address;\n       A : access File_Attributes) return Integer;\n@@ -65,6 +70,7 @@ private\n    pragma Import (C, Reset_Attributes,     \"__gnat_reset_attributes\");\n    pragma Import (C, Error_Attributes,     \"__gnat_error_attributes\");\n    pragma Import (C, File_Exists_Attr,     \"__gnat_file_exists_attr\");\n+   pragma Import (C, File_Length_Attr,     \"__gnat_file_length_attr\");\n    pragma Import (C, Is_Regular_File_Attr, \"__gnat_is_regular_file_attr\");\n    pragma Import (C, Is_Directory_Attr,    \"__gnat_is_directory_attr\");\n "}]}