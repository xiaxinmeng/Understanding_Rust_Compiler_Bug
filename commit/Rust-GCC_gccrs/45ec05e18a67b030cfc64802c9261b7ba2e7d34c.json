{"sha": "45ec05e18a67b030cfc64802c9261b7ba2e7d34c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDVlYzA1ZTE4YTY3YjAzMGNmYzY0ODAyYzkyNjFiN2JhMmU3ZDM0Yw==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2014-07-30T15:13:23Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-30T15:13:23Z"}, "message": "gnat_ugn.texi: Minor spelling correction.\n\n2014-07-30  Robert Dewar  <dewar@adacore.com>\n\n\t* gnat_ugn.texi: Minor spelling correction.\n\t* makeutl.adb: Minor code reorganization.\n\t* exp_ch4.adb, exp_aggr.adb, exp_ch3.adb: Minor reformatting.\n\n2014-07-30  Robert Dewar  <dewar@adacore.com>\n\n\t* einfo.ads (Has_Unchecked_Union): Document that this is used\n\tto check for illegal Valid_Scalars attribute references.\n\t* exp_attr.adb (Build_Record_VS_Func): New function\n\t(Expand_N_Attribute_Reference, case Valid_Scalars): Call this\n\tfunction.\n\t* gnat_rm.texi: Document 'Valid_Scalars cannot be applied to\n\tUnchecked_Union Add note on 'Valid_Scalars generating a lot\n\tof code.\n\t* sem_attr.adb (Analyze_Attribute, case Valid_Scalars): Give\n\terror on attempt to apply Valid_Scalars to Unchecked_Union type.\n\nFrom-SVN: r213298", "tree": {"sha": "e9d7f87f40d20e633debaafad695d3cb50b3a33b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e9d7f87f40d20e633debaafad695d3cb50b3a33b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/45ec05e18a67b030cfc64802c9261b7ba2e7d34c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45ec05e18a67b030cfc64802c9261b7ba2e7d34c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45ec05e18a67b030cfc64802c9261b7ba2e7d34c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45ec05e18a67b030cfc64802c9261b7ba2e7d34c/comments", "author": null, "committer": null, "parents": [{"sha": "ad9560ea432c33bdcfdeb5ed16cdb411ced11fbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad9560ea432c33bdcfdeb5ed16cdb411ced11fbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad9560ea432c33bdcfdeb5ed16cdb411ced11fbc"}], "stats": {"total": 471, "additions": 398, "deletions": 73}, "files": [{"sha": "54452ab53b7a541f241dc28b24f95849b89fa5b2", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45ec05e18a67b030cfc64802c9261b7ba2e7d34c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45ec05e18a67b030cfc64802c9261b7ba2e7d34c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=45ec05e18a67b030cfc64802c9261b7ba2e7d34c", "patch": "@@ -1,3 +1,22 @@\n+2014-07-30  Robert Dewar  <dewar@adacore.com>\n+\n+\t* gnat_ugn.texi: Minor spelling correction.\n+\t* makeutl.adb: Minor code reorganization.\n+\t* exp_ch4.adb, exp_aggr.adb, exp_ch3.adb: Minor reformatting.\n+\n+2014-07-30  Robert Dewar  <dewar@adacore.com>\n+\n+\t* einfo.ads (Has_Unchecked_Union): Document that this is used\n+\tto check for illegal Valid_Scalars attribute references.\n+\t* exp_attr.adb (Build_Record_VS_Func): New function\n+\t(Expand_N_Attribute_Reference, case Valid_Scalars): Call this\n+\tfunction.\n+\t* gnat_rm.texi: Document 'Valid_Scalars cannot be applied to\n+\tUnchecked_Union Add note on 'Valid_Scalars generating a lot\n+\tof code.\n+\t* sem_attr.adb (Analyze_Attribute, case Valid_Scalars): Give\n+\terror on attempt to apply Valid_Scalars to Unchecked_Union type.\n+\n 2014-07-30  Steve Baird  <baird@adacore.com>\n \n \t* exp_ch4.adb (Expand_N_Indexed_Component): Disable optimized handling"}, {"sha": "ba96f0414c3abff2de791e478ac09e4964ec02d5", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45ec05e18a67b030cfc64802c9261b7ba2e7d34c/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45ec05e18a67b030cfc64802c9261b7ba2e7d34c/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=45ec05e18a67b030cfc64802c9261b7ba2e7d34c", "patch": "@@ -1955,9 +1955,9 @@ package Einfo is\n --       Defined in all type entities. Set on unchecked unions themselves\n --       and (recursively) on any composite type which has a component for\n --       which Has_Unchecked_Union is set. The meaning is that a comparison\n---       operation for the type is not permitted. Note that the flag is not\n---       set on access types, even if they designate an object that has\n---       the flag Has_Unchecked_Union set.\n+--       operation or 'Valid_Scalars reference for the type is not permitted.\n+--       Note that the flag is not set on access types, even if they designate\n+--       an object that has the flag Has_Unchecked_Union set.\n \n --    Has_Unknown_Discriminants (Flag72)\n --       Defined in all entities. Set for types with unknown discriminants."}, {"sha": "9dd983c1ab3accfcb023f2cf2b233088e02ebf94", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45ec05e18a67b030cfc64802c9261b7ba2e7d34c/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45ec05e18a67b030cfc64802c9261b7ba2e7d34c/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=45ec05e18a67b030cfc64802c9261b7ba2e7d34c", "patch": "@@ -2847,12 +2847,11 @@ package body Exp_Aggr is\n                   then\n                      declare\n                         Assoc : constant Node_Id :=\n-                           First (Component_Associations (Expr_Q));\n+                                  First (Component_Associations (Expr_Q));\n                         Decl  : Node_Id;\n \n                      begin\n-                        if\n-                          Nkind (First (Choices (Assoc))) = N_Others_Choice\n+                        if Nkind (First (Choices (Assoc))) = N_Others_Choice\n                         then\n                            Decl :=\n                              Build_Actual_Subtype_Of_Component"}, {"sha": "9bdf92fef01857293335e658f2e0505f83c6f619", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 308, "deletions": 15, "changes": 323, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45ec05e18a67b030cfc64802c9261b7ba2e7d34c/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45ec05e18a67b030cfc64802c9261b7ba2e7d34c/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=45ec05e18a67b030cfc64802c9261b7ba2e7d34c", "patch": "@@ -84,6 +84,14 @@ package body Exp_Attr is\n    --  value returned is the entity of the constructed function body. We do not\n    --  bother to generate a separate spec for this subprogram.\n \n+   function Build_Record_VS_Func\n+     (R_Type : Entity_Id;\n+      Nod    : Node_Id) return Entity_Id;\n+   --  Build function to test Valid_Scalars for record type A_Type. Nod is the\n+   --  Valid_Scalars attribute node, used to insert the function body, and the\n+   --  value returned is the entity of the constructed function body. We do not\n+   --  bother to generate a separate spec for this subprogram.\n+\n    procedure Compile_Stream_Body_In_Scope\n      (N     : Node_Id;\n       Decl  : Node_Id;\n@@ -202,10 +210,10 @@ package body Exp_Attr is\n       Nod    : Node_Id) return Entity_Id\n    is\n       Loc        : constant Source_Ptr := Sloc (Nod);\n+      Func_Id    : constant Entity_Id  := Make_Temporary (Loc, 'V');\n       Comp_Type  : constant Entity_Id  := Component_Type (A_Type);\n       Body_Stmts : List_Id;\n       Index_List : List_Id;\n-      Func_Id    : Entity_Id;\n       Formals    : List_Id;\n \n       function Test_Component return List_Id;\n@@ -298,8 +306,6 @@ package body Exp_Attr is\n \n    begin\n       Index_List := New_List;\n-      Func_Id := Make_Defining_Identifier (Loc, New_Internal_Name ('V'));\n-\n       Body_Stmts := Test_One_Dimension (1);\n \n       --  Parameter is always (A : A_Typ)\n@@ -333,9 +339,279 @@ package body Exp_Attr is\n          Set_Debug_Info_Off (Func_Id);\n       end if;\n \n+      Set_Is_Pure (Func_Id);\n       return Func_Id;\n    end Build_Array_VS_Func;\n \n+   --------------------------\n+   -- Build_Record_VS_Func --\n+   --------------------------\n+\n+   --  Generates:\n+\n+   --    function _Valid_Scalars (X : T) return Boolean is\n+   --    begin\n+   --       --  Check discriminants\n+\n+   --       if not X.D1'Valid_Scalars or else\n+   --          not X.D2'Valid_Scalars or else\n+   --         ...\n+   --       then\n+   --          return False;\n+   --       end if;\n+\n+   --       --  Check components\n+\n+   --       if not X.C1'Valid_Scalars or else\n+   --          not X.C2'Valid_Scalars or else\n+   --          ...\n+   --       then\n+   --          return False;\n+   --       end if;\n+\n+   --       --  Check variant part\n+\n+   --       case X.D1 is\n+   --          when V1 =>\n+   --             if not X.C2'Valid_Scalars or else\n+   --                not X.C3'Valid_Scalars or else\n+   --               ...\n+   --             then\n+   --                return False;\n+   --             end if;\n+   --          ...\n+   --          when Vn =>\n+   --             if not X.Cn'Valid_Scalars or else\n+   --               ...\n+   --             then\n+   --                return False;\n+   --             end if;\n+   --       end case;\n+\n+   --       return True;\n+   --    end _Valid_Scalars;\n+\n+   function Build_Record_VS_Func\n+     (R_Type : Entity_Id;\n+      Nod    : Node_Id) return Entity_Id\n+   is\n+      Loc     : constant Source_Ptr := Sloc (R_Type);\n+      Func_Id : constant Entity_Id  := Make_Temporary (Loc, 'V');\n+      X       : constant Entity_Id  := Make_Defining_Identifier (Loc, Name_X);\n+\n+      function Make_VS_Case\n+        (E      : Entity_Id;\n+         CL     : Node_Id;\n+         Discrs : Elist_Id := New_Elmt_List) return List_Id;\n+      --  Building block for variant valid scalars. Given a Component_List node\n+      --  CL, it generates an 'if' followed by a 'case' statement that compares\n+      --  all components of local temporaries named X and Y (that are declared\n+      --  as formals at some upper level). E provides the Sloc to be used for\n+      --  the generated code.\n+\n+      function Make_VS_If\n+        (E : Entity_Id;\n+         L : List_Id) return Node_Id;\n+      --  Building block for variant validate scalars. Given the list, L, of\n+      --  components (or discriminants) L, it generates a return statement that\n+      --  compares all components of local temporaries named X and Y (that are\n+      --  declared as formals at some upper level). E provides the Sloc to be\n+      --  used for the generated code.\n+\n+      ------------------\n+      -- Make_VS_Case --\n+      ------------------\n+\n+      --  <Make_VS_If on shared components>\n+\n+      --  case X.D1 is\n+      --     when V1 => <Make_VS_Case> on subcomponents\n+      --     ...\n+      --     when Vn => <Make_VS_Case> on subcomponents\n+      --  end case;\n+\n+      function Make_VS_Case\n+        (E      : Entity_Id;\n+         CL     : Node_Id;\n+         Discrs : Elist_Id := New_Elmt_List) return List_Id\n+      is\n+         Loc      : constant Source_Ptr := Sloc (E);\n+         Result   : constant List_Id    := New_List;\n+         Variant  : Node_Id;\n+         Alt_List : List_Id;\n+\n+      begin\n+         Append_To (Result, Make_VS_If (E, Component_Items (CL)));\n+\n+         if No (Variant_Part (CL)) then\n+            return Result;\n+         end if;\n+\n+         Variant := First_Non_Pragma (Variants (Variant_Part (CL)));\n+\n+         if No (Variant) then\n+            return Result;\n+         end if;\n+\n+         Alt_List := New_List;\n+         while Present (Variant) loop\n+            Append_To (Alt_List,\n+              Make_Case_Statement_Alternative (Loc,\n+                Discrete_Choices => New_Copy_List (Discrete_Choices (Variant)),\n+                Statements =>\n+                  Make_VS_Case (E, Component_List (Variant), Discrs)));\n+            Next_Non_Pragma (Variant);\n+         end loop;\n+\n+         Append_To (Result,\n+           Make_Case_Statement (Loc,\n+             Expression =>\n+               Make_Selected_Component (Loc,\n+                 Prefix        => Make_Identifier (Loc, Name_X),\n+                 Selector_Name => New_Copy (Name (Variant_Part (CL)))),\n+             Alternatives => Alt_List));\n+\n+         return Result;\n+      end Make_VS_Case;\n+\n+      ----------------\n+      -- Make_VS_If --\n+      ----------------\n+\n+      --  Generates:\n+\n+      --    if\n+      --      not X.C1'Valid_Scalars\n+      --        or else\n+      --      not X.C2'Valid_Scalars\n+      --        ...\n+      --    then\n+      --       return False;\n+      --    end if;\n+\n+      --  or a null statement if the list L is empty\n+\n+      function Make_VS_If\n+        (E : Entity_Id;\n+         L : List_Id) return Node_Id\n+      is\n+         Loc        : constant Source_Ptr := Sloc (E);\n+         C          : Node_Id;\n+         Def_Id     : Entity_Id;\n+         Field_Name : Name_Id;\n+         Cond       : Node_Id;\n+\n+      begin\n+         if No (L) then\n+            return Make_Null_Statement (Loc);\n+\n+         else\n+            Cond := Empty;\n+\n+            C := First_Non_Pragma (L);\n+            while Present (C) loop\n+               Def_Id := Defining_Identifier (C);\n+               Field_Name := Chars (Def_Id);\n+\n+               --  The tags need not be checked since they will always be valid\n+\n+               --  Note also that in the following, we use Make_Identifier for\n+               --  the component names. Use of New_Occurrence_Of to identify\n+               --  the components would be incorrect because wrong entities for\n+               --  discriminants could be picked up in the private type case.\n+\n+               --  Don't bother with abstract parent in interface case\n+\n+               if Field_Name = Name_uParent\n+                 and then Is_Interface (Etype (Def_Id))\n+               then\n+                  null;\n+\n+               --  Don't bother with tag, always valid, and not scalar anyway\n+\n+               elsif Field_Name = Name_uTag then\n+                  null;\n+\n+               --  Don't bother with component with no scalar components\n+\n+               elsif not Scalar_Part_Present (Etype (Def_Id)) then\n+                  null;\n+\n+               --  Normal case, generate Valid_Scalars attribute reference\n+\n+               else\n+                  Evolve_Or_Else (Cond,\n+                    Make_Op_Not (Loc,\n+                      Right_Opnd =>\n+                        Make_Attribute_Reference (Loc,\n+                          Prefix =>\n+                            Make_Selected_Component (Loc,\n+                              Prefix        =>\n+                                Make_Identifier (Loc, Name_X),\n+                              Selector_Name =>\n+                                Make_Identifier (Loc, Field_Name)),\n+                          Attribute_Name => Name_Valid_Scalars)));\n+               end if;\n+\n+               Next_Non_Pragma (C);\n+            end loop;\n+\n+            if No (Cond) then\n+               return Make_Null_Statement (Loc);\n+\n+            else\n+               return\n+                 Make_Implicit_If_Statement (E,\n+                   Condition       => Cond,\n+                   Then_Statements => New_List (\n+                     Make_Simple_Return_Statement (Loc,\n+                       Expression =>\n+                         New_Occurrence_Of (Standard_False, Loc))));\n+            end if;\n+         end if;\n+      end Make_VS_If;\n+\n+      --  Local Declarations\n+\n+      Def    : constant Node_Id := Parent (R_Type);\n+      Comps  : constant Node_Id := Component_List (Type_Definition (Def));\n+      Stmts  : constant List_Id := New_List;\n+      Pspecs : constant List_Id := New_List;\n+\n+   begin\n+      Append_To (Pspecs,\n+        Make_Parameter_Specification (Loc,\n+          Defining_Identifier => X,\n+          Parameter_Type      => New_Occurrence_Of (R_Type, Loc)));\n+\n+      Append_To (Stmts,\n+        Make_VS_If (R_Type, Discriminant_Specifications (Def)));\n+      Append_List_To (Stmts, Make_VS_Case (R_Type, Comps));\n+\n+      Append_To (Stmts,\n+        Make_Simple_Return_Statement (Loc,\n+          Expression => New_Occurrence_Of (Standard_True, Loc)));\n+\n+      Insert_Action (Nod,\n+        Make_Subprogram_Body (Loc,\n+          Specification =>\n+            Make_Function_Specification (Loc,\n+              Defining_Unit_Name       => Func_Id,\n+              Parameter_Specifications => Pspecs,\n+              Result_Definition => New_Occurrence_Of (Standard_Boolean, Loc)),\n+          Declarations               => New_List,\n+          Handled_Statement_Sequence =>\n+            Make_Handled_Sequence_Of_Statements (Loc, Statements => Stmts)),\n+        Suppress => Discriminant_Check);\n+\n+      if not Debug_Generated_Code then\n+         Set_Debug_Info_Off (Func_Id);\n+      end if;\n+\n+      Set_Is_Pure (Func_Id);\n+      return Func_Id;\n+   end Build_Record_VS_Func;\n+\n    ----------------------------------\n    -- Compile_Stream_Body_In_Scope --\n    ----------------------------------\n@@ -6377,14 +6653,18 @@ package body Exp_Attr is\n             Ftyp := Ptyp;\n          end if;\n \n+         --  Replace by True if no scalar parts\n+\n+         if not Scalar_Part_Present (Ftyp) then\n+            Rewrite (N, New_Occurrence_Of (Standard_True, Loc));\n+\n          --  For scalar types, Valid_Scalars is the same as Valid\n \n-         if Is_Scalar_Type (Ftyp) then\n+         elsif Is_Scalar_Type (Ftyp) then\n             Rewrite (N,\n               Make_Attribute_Reference (Loc,\n                 Attribute_Name => Name_Valid,\n                 Prefix         => Pref));\n-            Analyze_And_Resolve (N, Standard_Boolean);\n \n          --  For array types, we construct a function that determines if there\n          --  are any non-valid scalar subcomponents, and call the function.\n@@ -6399,14 +6679,25 @@ package body Exp_Attr is\n                   New_Occurrence_Of (Build_Array_VS_Func (Ftyp, N), Loc),\n                 Parameter_Associations => New_List (Pref)));\n \n-            Analyze_And_Resolve (N, Standard_Boolean);\n-\n-         --  For record types, we build a big if expression, applying Valid or\n-         --  Valid_Scalars as appropriate to all relevant components.\n+         --  For record types, we construct a function that determines if there\n+         --  are any non-valid scalar subcomponents, and call the function.\n \n-         elsif (Is_Record_Type (Ptyp) or else Has_Discriminants (Ptyp))\n-           and then Scalar_Part_Present (Ptyp)\n+         elsif Is_Record_Type (Ftyp)\n+            and then Nkind (Type_Definition (Declaration_Node (Ftyp))) =\n+                                                        N_Record_Definition\n          then\n+            Rewrite (N,\n+              Make_Function_Call (Loc,\n+                Name                   =>\n+                  New_Occurrence_Of (Build_Record_VS_Func (Ftyp, N), Loc),\n+              Parameter_Associations => New_List (Pref)));\n+\n+         --  Other record types or types with discriminants\n+\n+         elsif Is_Record_Type (Ftyp) or else Has_Discriminants (Ptyp) then\n+\n+            --  Build expression with list of equality tests\n+\n             declare\n                C : Entity_Id;\n                X : Node_Id;\n@@ -6441,16 +6732,18 @@ package body Exp_Attr is\n                end loop;\n \n                Rewrite (N, X);\n-               Analyze_And_Resolve (N, Standard_Boolean);\n             end;\n \n-         --  For all other types, result is True (but not static)\n+         --  For all other types, result is True\n \n          else\n             Rewrite (N, New_Occurrence_Of (Standard_Boolean, Loc));\n-            Analyze_And_Resolve (N, Standard_Boolean);\n-            Set_Is_Static_Expression (N, False);\n          end if;\n+\n+         --  Result is always boolean, but never static\n+\n+         Analyze_And_Resolve (N, Standard_Boolean);\n+         Set_Is_Static_Expression (N, False);\n       end Valid_Scalars;\n \n       -----------"}, {"sha": "6533db22727249b810b015ac26614ca217f89084", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45ec05e18a67b030cfc64802c9261b7ba2e7d34c/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45ec05e18a67b030cfc64802c9261b7ba2e7d34c/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=45ec05e18a67b030cfc64802c9261b7ba2e7d34c", "patch": "@@ -147,7 +147,7 @@ package body Exp_Ch3 is\n    --  The resulting operation is a TSS subprogram.\n \n    procedure Build_Variant_Record_Equality (Typ  : Entity_Id);\n-   --  Create An Equality function for the non-tagged variant record 'Typ'\n+   --  Create An Equality function for the non-tagged variant record Typ\n    --  and attach it to the TSS list\n \n    procedure Check_Stream_Attributes (Typ : Entity_Id);\n@@ -442,9 +442,7 @@ package body Exp_Ch3 is\n \n          Ctyp := Etype (Comp);\n \n-         if not Is_Array_Type (Ctyp)\n-           or else Number_Dimensions (Ctyp) > 1\n-         then\n+         if not Is_Array_Type (Ctyp) or else Number_Dimensions (Ctyp) > 1 then\n             goto Continue;\n          end if;\n \n@@ -4279,36 +4277,36 @@ package body Exp_Ch3 is\n       end if;\n    end Build_Untagged_Equality;\n \n-   ------------------------------------\n+   -----------------------------------\n    -- Build_Variant_Record_Equality --\n-   ------------------------------------\n+   -----------------------------------\n \n    --  Generates:\n \n    --    function _Equality (X, Y : T) return Boolean is\n    --    begin\n    --       --  Compare discriminants\n \n-   --       if False or else X.D1 /= Y.D1 or else X.D2 /= Y.D2 then\n+   --       if X.D1 /= Y.D1 or else X.D2 /= Y.D2 or else ... then\n    --          return False;\n    --       end if;\n \n    --       --  Compare components\n \n-   --       if False or else X.C1 /= Y.C1 or else X.C2 /= Y.C2 then\n+   --       if X.C1 /= Y.C1 or else X.C2 /= Y.C2 or else ... then\n    --          return False;\n    --       end if;\n \n    --       --  Compare variant part\n \n    --       case X.D1 is\n    --          when V1 =>\n-   --             if False or else X.C2 /= Y.C2 or else X.C3 /= Y.C3 then\n+   --             if X.C2 /= Y.C2 or else X.C3 /= Y.C3 or else ... then\n    --                return False;\n    --             end if;\n    --          ...\n    --          when Vn =>\n-   --             if False or else X.Cn /= Y.Cn then\n+   --             if X.Cn /= Y.Cn or else ... then\n    --                return False;\n    --             end if;\n    --       end case;\n@@ -4323,13 +4321,8 @@ package body Exp_Ch3 is\n             Make_Defining_Identifier (Loc,\n               Chars => Make_TSS_Name (Typ, TSS_Composite_Equality));\n \n-      X : constant Entity_Id :=\n-           Make_Defining_Identifier (Loc,\n-             Chars => Name_X);\n-\n-      Y : constant Entity_Id :=\n-            Make_Defining_Identifier (Loc,\n-              Chars => Name_Y);\n+      X : constant Entity_Id := Make_Defining_Identifier (Loc, Name_X);\n+      Y : constant Entity_Id := Make_Defining_Identifier (Loc, Name_Y);\n \n       Def    : constant Node_Id := Parent (Typ);\n       Comps  : constant Node_Id := Component_List (Type_Definition (Def));\n@@ -4357,7 +4350,6 @@ package body Exp_Ch3 is\n          declare\n             Parent_Eq : constant Entity_Id :=\n                           TSS (Root_Type (Typ), TSS_Composite_Equality);\n-\n          begin\n             if Present (Parent_Eq) then\n                Copy_TSS (Parent_Eq, Typ);\n@@ -8805,6 +8797,7 @@ package body Exp_Ch3 is\n    ------------------\n \n    --  <Make_Eq_If shared components>\n+\n    --  case X.D1 is\n    --     when V1 => <Make_Eq_Case> on subcomponents\n    --     ..."}, {"sha": "1fb35c11b0a65adb9e0b79140af8d18207e6933a", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45ec05e18a67b030cfc64802c9261b7ba2e7d34c/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45ec05e18a67b030cfc64802c9261b7ba2e7d34c/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=45ec05e18a67b030cfc64802c9261b7ba2e7d34c", "patch": "@@ -6164,11 +6164,15 @@ package body Exp_Ch4 is\n       --  messing especially in the packed case, but more importantly bypasses\n       --  some problems in handling this peculiar case, for example, the issue\n       --  of dealing specially with object renamings.\n-      --  This optimization is disabled for CodePeer because it can transform\n-      --  an index-check constraint_error into a range-check constraint_error\n-      --  and CodePeer cares about that distinction.\n \n-      if Nkind (P) = N_Slice and then not CodePeer_Mode then\n+      if Nkind (P) = N_Slice\n+\n+        --  This optimization is disabled for CodePeer because it can transform\n+        --  an index-check constraint_error into a range-check constraint_error\n+        --  and CodePeer cares about that distinction.\n+\n+        and then not CodePeer_Mode\n+      then\n          Rewrite (N,\n            Make_Indexed_Component (Loc,\n              Prefix      => Prefix (P),"}, {"sha": "edbba0f2a7bb5ad7630e82c2eebdb6b412630022", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45ec05e18a67b030cfc64802c9261b7ba2e7d34c/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45ec05e18a67b030cfc64802c9261b7ba2e7d34c/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=45ec05e18a67b030cfc64802c9261b7ba2e7d34c", "patch": "@@ -10163,6 +10163,16 @@ be determined at compile time that the prefix of the attribute has no\n scalar parts (e.g., if the prefix is of an access type, an interface type,\n an undiscriminated task type, or an undiscriminated protected type).\n \n+For scalar types, @code{Valid_Scalars} is equivalent to @code{Valid}. The use\n+of this attribute is not permitted for @code{Unchecked_Union} types for which\n+in general it is not possible to determine the values of the discriminants.\n+\n+Note: @code{Valid_Scalars} can generate a lot of code, especially in the case\n+of a large variant record. If the attribute is called in many places in the\n+same program applied to objects of the same type, it can reduce program size\n+to write a function with a single use of the attribute, and then call that\n+function from multiple places.\n+\n @node Attribute VADS_Size\n @unnumberedsec Attribute VADS_Size\n @cindex @code{Size}, VADS compatibility"}, {"sha": "6ba7002d723082301e815d40ca73db0beea8cece", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45ec05e18a67b030cfc64802c9261b7ba2e7d34c/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45ec05e18a67b030cfc64802c9261b7ba2e7d34c/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=45ec05e18a67b030cfc64802c9261b7ba2e7d34c", "patch": "@@ -19972,7 +19972,7 @@ by hand.\n \n @item --omit-sloc\n @cindex @option{--omit-sloc} (@command{gnattest})\n-Supresses comment line containing file name and line number of corresponding\n+Suppresses comment line containing file name and line number of corresponding\n subprograms in test skeletons.\n \n @end table"}, {"sha": "b192ef858f9d8d69901372be6ffcd0e4ab14fe97", "filename": "gcc/ada/makeutl.adb", "status": "modified", "additions": 21, "deletions": 25, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45ec05e18a67b030cfc64802c9261b7ba2e7d34c/gcc%2Fada%2Fmakeutl.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45ec05e18a67b030cfc64802c9261b7ba2e7d34c/gcc%2Fada%2Fmakeutl.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeutl.adb?ref=45ec05e18a67b030cfc64802c9261b7ba2e7d34c", "patch": "@@ -2912,26 +2912,26 @@ package body Makeutl is\n       is\n \n          procedure Do_Insert\n-           (Project    : Project_Id;\n-            Tree       : Project_Tree_Ref;\n-            Context    : Project_Context);\n+           (Project : Project_Id;\n+            Tree    : Project_Tree_Ref;\n+            Context : Project_Context);\n+         --  Local procedures must be commented ???\n \n          ---------------\n          -- Do_Insert --\n          ---------------\n \n          procedure Do_Insert\n-           (Project    : Project_Id;\n-            Tree       : Project_Tree_Ref;\n-            Context    : Project_Context)\n+           (Project : Project_Id;\n+            Tree    : Project_Tree_Ref;\n+            Context : Project_Context)\n          is\n             Unit_Based : constant Boolean :=\n                            Unique_Compile\n                              or else not Builder_Data (Tree).Closure_Needed;\n-            --  When Unit_Based is True, put in the queue all compilable\n-            --  sources including the unit based (Ada) one. When Unit_Based is\n-            --  False, put the Ada sources only when they are in a library\n-            --  project.\n+            --  When Unit_Based is True, we enqueue all compilable sources\n+            --  including the unit based (Ada) one. When Unit_Based is False,\n+            --  put the Ada sources only when they are in a library project.\n \n             Iter    : Source_Iterator;\n             Source  : Prj.Source_Id;\n@@ -2942,9 +2942,7 @@ package body Makeutl is\n             --  Nothing to do when \"-u\" was specified and some files were\n             --  specified on the command line\n \n-            if Unique_Compile\n-              and then Mains.Number_Of_Mains (Tree) > 0\n-            then\n+            if Unique_Compile and then Mains.Number_Of_Mains (Tree) > 0 then\n                return;\n             end if;\n \n@@ -2955,16 +2953,13 @@ package body Makeutl is\n \n                if Is_Allowed_Language (Source.Language.Name)\n                  and then Is_Compilable (Source)\n-                 and then\n-                   (All_Projects\n-                     or else Is_Extending (Project, Source.Project))\n+                 and then (All_Projects\n+                            or else Is_Extending (Project, Source.Project))\n                  and then not Source.Locally_Removed\n                  and then Source.Replaced_By = No_Source\n-                 and then\n-                   (not Source.Project.Externally_Built\n-                     or else\n-                       (Is_Extending (Project, Source.Project)\n-                         and then not Project.Externally_Built))\n+                 and then (not Source.Project.Externally_Built\n+                            or else (Is_Extending (Project, Source.Project)\n+                                      and then not Project.Externally_Built))\n                  and then Source.Kind /= Sep\n                  and then Source.Path /= No_Path_Information\n                then\n@@ -2988,19 +2983,20 @@ package body Makeutl is\n                         if Source.Unit /= No_Unit_Index\n                           and then\n                             (Source.Project.Library\n-                             or else Project.Qualifier = Aggregate_Library\n-                             or else Context.In_Aggregate_Lib)\n+                              or else Project.Qualifier = Aggregate_Library\n+                              or else Context.In_Aggregate_Lib)\n                           and then Source.Project.Standalone_Library /= No\n                         then\n                            --  Check if the unit is in the interface\n+\n                            OK := False;\n \n                            declare\n-                              List : String_List_Id :=\n-                                Source.Project.Lib_Interface_ALIs;\n+                              List    : String_List_Id;\n                               Element : String_Element;\n \n                            begin\n+                              List := Source.Project.Lib_Interface_ALIs;\n                               while List /= Nil_String loop\n                                  Element :=\n                                    Project_Tree.Shared.String_Elements.Table"}, {"sha": "88c3c5d6e27dc389bb6afef9de5e7e84e8b4bf87", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45ec05e18a67b030cfc64802c9261b7ba2e7d34c/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45ec05e18a67b030cfc64802c9261b7ba2e7d34c/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=45ec05e18a67b030cfc64802c9261b7ba2e7d34c", "patch": "@@ -6589,12 +6589,23 @@ package body Sem_Attr is\n       when Attribute_Valid_Scalars =>\n          Check_E0;\n          Check_Object_Reference (P);\n+         Set_Etype (N, Standard_Boolean);\n \n-         if not Scalar_Part_Present (P_Type) then\n-            Error_Attr_P (\"??attribute % always True, no scalars to check\");\n-         end if;\n+         --  Following checks are only for source types\n \n-         Set_Etype (N, Standard_Boolean);\n+         if Comes_From_Source (N) then\n+            if not Scalar_Part_Present (P_Type) then\n+               Error_Attr_P\n+                 (\"??attribute % always True, no scalars to check\");\n+            end if;\n+\n+            --  Not allowed for unchecked union type\n+\n+            if Has_Unchecked_Union (P_Type) then\n+               Error_Attr_P\n+                 (\"attribute % not allowed for Unchecked_Union type\");\n+            end if;\n+         end if;\n \n       -----------\n       -- Value --"}]}