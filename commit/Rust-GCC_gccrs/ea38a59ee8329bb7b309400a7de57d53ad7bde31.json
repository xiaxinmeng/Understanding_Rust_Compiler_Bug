{"sha": "ea38a59ee8329bb7b309400a7de57d53ad7bde31", "node_id": "C_kwDOANBUbNoAKGVhMzhhNTllZTgzMjliYjdiMzA5NDAwYTdkZTU3ZDUzYWQ3YmRlMzE", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-04-26T19:12:58Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-04-26T20:44:00Z"}, "message": "Fix regression in fix for #1173\n\nA regression was introduced in e476433c45624ec713395c85bcbd410806e90639\nthis was a tricky bug to fix. There are several fixes here but they all\nrely on one another so in order to have a commit which does not introduce\nmore regressions it seems best to keep these fixes together.\n\nIn this patch we remove the check at the end of type resolution to look\nfor any error type nodes within the type context since this will only ever\nproduce false postive/duplicate errors. Since any real error will have been\nemitted at the time of occurance.\n\nWe also fixed a bug in infering the types on a generic type so for example:\n\n  struct Foo<A,B>(A,B);\n  impl<T> Foo<T,T> { ... }\n\nIn this example the Self type on the impl block will be Foo<T,T> so in the\ncode for infering the arguments for the type we simply iterated each of the\ngeneric parameter mappings and if any of them need substitution we generate\nimplict inference variables for them but in this case the ParamType is T\nso generating one for each of these T's will introduce a stay inference\nvariable which we cannot infer so it will not be used. This patch keeps\na mapping inside SubstitutionRef::infer_substitions to ensure we don't\nintroduce any extra inference variables than required.\n\nThe final fix was around how we clone inference variables, there is a\ncomment explaining this but we cannot safely clone a inference variables\nsimply by creating a new object, inference variables are closely tied to\nthe type-conext so that when we infer the type to be a concrete type we\nneed to be able to update the reference in memory but simply cloning an\ninference variable does not guarentee this to occur. This change ensures\nthat we create a new implict inference variable and setup the reference\nand chain apropirately.", "tree": {"sha": "7efe52d94bf719b0a4db1d15d0f90ec65e6e5141", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7efe52d94bf719b0a4db1d15d0f90ec65e6e5141"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea38a59ee8329bb7b309400a7de57d53ad7bde31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea38a59ee8329bb7b309400a7de57d53ad7bde31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea38a59ee8329bb7b309400a7de57d53ad7bde31", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea38a59ee8329bb7b309400a7de57d53ad7bde31/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40f2979b73b56e4ddc5ab5686d75164a8b664320", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40f2979b73b56e4ddc5ab5686d75164a8b664320", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40f2979b73b56e4ddc5ab5686d75164a8b664320"}], "stats": {"total": 178, "additions": 76, "deletions": 102}, "files": [{"sha": "aa3e29a99c02106660b270f2ee149dc45fc7d068", "filename": "gcc/rust/hir/tree/rust-hir-path.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea38a59ee8329bb7b309400a7de57d53ad7bde31/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea38a59ee8329bb7b309400a7de57d53ad7bde31/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h?ref=ea38a59ee8329bb7b309400a7de57d53ad7bde31", "patch": "@@ -262,6 +262,8 @@ class PathPattern : public Pattern\n \n   std::vector<PathExprSegment> &get_segments () { return segments; }\n \n+  const std::vector<PathExprSegment> &get_segments () const { return segments; }\n+\n   PathExprSegment &get_root_seg () { return segments.at (0); }\n \n   PathExprSegment get_final_segment () const { return segments.back (); }"}, {"sha": "5633751c5a033195ad5a64468c92f8895aab5faa", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea38a59ee8329bb7b309400a7de57d53ad7bde31/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea38a59ee8329bb7b309400a7de57d53ad7bde31/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=ea38a59ee8329bb7b309400a7de57d53ad7bde31", "patch": "@@ -221,13 +221,6 @@ class TypeCheckExpr : public TypeCheckBase\n \n     infered\n       = TyTy::TypeCheckCallExpr::go (function_tyty, expr, variant, context);\n-    if (infered == nullptr)\n-      {\n-\trust_error_at (expr.get_locus (), \"failed to lookup type to CallExpr\");\n-\treturn;\n-      }\n-\n-    infered->set_ref (expr.get_mappings ().get_hirid ());\n   }\n \n   void visit (HIR::MethodCallExpr &expr) override\n@@ -1076,7 +1069,6 @@ class TypeCheckExpr : public TypeCheckBase\n     : TypeCheckBase (), infered (nullptr), inside_loop (inside_loop)\n   {}\n \n-  // Beware: currently returns Tyty::ErrorType or nullptr in case of error.\n   TyTy::BaseType *resolve_root_path (HIR::PathInExpression &expr,\n \t\t\t\t     size_t *offset,\n \t\t\t\t     NodeId *root_resolved_node_id);"}, {"sha": "9960e76dccbf0e382a26f08a84c162f20444b94c", "filename": "gcc/rust/typecheck/rust-hir-type-check-path.cc", "status": "modified", "additions": 25, "deletions": 81, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea38a59ee8329bb7b309400a7de57d53ad7bde31/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea38a59ee8329bb7b309400a7de57d53ad7bde31/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc?ref=ea38a59ee8329bb7b309400a7de57d53ad7bde31", "patch": "@@ -138,27 +138,17 @@ void\n TypeCheckExpr::visit (HIR::PathInExpression &expr)\n {\n   NodeId resolved_node_id = UNKNOWN_NODEID;\n-\n   size_t offset = -1;\n   TyTy::BaseType *tyseg = resolve_root_path (expr, &offset, &resolved_node_id);\n-  rust_assert (tyseg != nullptr);\n-\n   if (tyseg->get_kind () == TyTy::TypeKind::ERROR)\n     return;\n \n-  if (expr.get_num_segments () == 1)\n-    {\n-      Location locus = expr.get_segments ().back ().get_locus ();\n-\n-      bool is_big_self\n-\t= expr.get_segments ().front ().get_segment ().as_string ().compare (\n-\t    \"Self\")\n-\t  == 0;\n-      if (!is_big_self && tyseg->needs_generic_substitutions ())\n-\t{\n-\t  tyseg = SubstMapper::InferSubst (tyseg, locus);\n-\t}\n+  if (tyseg->needs_generic_substitutions ())\n+    tyseg = SubstMapper::InferSubst (tyseg, expr.get_locus ());\n \n+  bool fully_resolved = offset == expr.get_segments ().size ();\n+  if (fully_resolved)\n+    {\n       infered = tyseg;\n       return;\n     }\n@@ -171,14 +161,11 @@ TyTy::BaseType *\n TypeCheckExpr::resolve_root_path (HIR::PathInExpression &expr, size_t *offset,\n \t\t\t\t  NodeId *root_resolved_node_id)\n {\n-  TyTy::BaseType *root_tyty = nullptr;\n   *offset = 0;\n   for (size_t i = 0; i < expr.get_num_segments (); i++)\n     {\n       HIR::PathExprSegment &seg = expr.get_segments ().at (i);\n-\n       bool have_more_segments = (expr.get_num_segments () - 1 != i);\n-      bool is_root = *offset == 0 || root_tyty == nullptr;\n       NodeId ast_node_id = seg.get_mappings ().get_nodeid ();\n \n       // then lookup the reference_node_id\n@@ -205,40 +192,30 @@ TypeCheckExpr::resolve_root_path (HIR::PathInExpression &expr, size_t *offset,\n       // ref_node_id is the NodeId that the segments refers to.\n       if (ref_node_id == UNKNOWN_NODEID)\n \t{\n-\t  if (is_root)\n-\t    {\n-\t      rust_error_at (seg.get_locus (),\n-\t\t\t     \"failed to type resolve root segment\");\n-\t      return new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n-\t    }\n-\t  return root_tyty;\n+\t  rust_error_at (seg.get_locus (),\n+\t\t\t \"failed to type resolve root segment\");\n+\t  return new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n \t}\n \n       // node back to HIR\n       HirId ref;\n       if (!mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n \t\t\t\t\t ref_node_id, &ref))\n \t{\n-\t  if (is_root)\n-\t    {\n-\t      rust_error_at (seg.get_locus (), \"456 reverse lookup failure\");\n-\t      rust_debug_loc (\n-\t\tseg.get_locus (),\n-\t\t\"failure with [%s] mappings [%s] ref_node_id [%u]\",\n-\t\tseg.as_string ().c_str (),\n-\t\tseg.get_mappings ().as_string ().c_str (), ref_node_id);\n+\t  rust_error_at (seg.get_locus (), \"456 reverse lookup failure\");\n+\t  rust_debug_loc (seg.get_locus (),\n+\t\t\t  \"failure with [%s] mappings [%s] ref_node_id [%u]\",\n+\t\t\t  seg.as_string ().c_str (),\n+\t\t\t  seg.get_mappings ().as_string ().c_str (),\n+\t\t\t  ref_node_id);\n \n-\t      return new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n-\t    }\n-\n-\t  return root_tyty;\n+\t  return new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n \t}\n \n       auto seg_is_module\n \t= (nullptr\n \t   != mappings->lookup_module (expr.get_mappings ().get_crate_num (),\n \t\t\t\t       ref));\n-\n       if (seg_is_module)\n \t{\n \t  // A::B::C::this_is_a_module::D::E::F\n@@ -261,33 +238,8 @@ TypeCheckExpr::resolve_root_path (HIR::PathInExpression &expr, size_t *offset,\n       TyTy::BaseType *lookup = nullptr;\n       if (!context->lookup_type (ref, &lookup))\n \t{\n-\t  if (is_root)\n-\t    {\n-\t      rust_error_at (seg.get_locus (),\n-\t\t\t     \"failed to resolve root segment\");\n-\t      return new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n-\t    }\n-\t  return root_tyty;\n-\t}\n-\n-      // if we have a previous segment type\n-      if (root_tyty != nullptr)\n-\t{\n-\t  // if this next segment needs substitution we must apply the\n-\t  // previous type arguments\n-\t  //\n-\t  // such as: GenericStruct::<_>::new(123, 456)\n-\t  if (lookup->needs_generic_substitutions ())\n-\t    {\n-\t      if (!root_tyty->needs_generic_substitutions ())\n-\t\t{\n-\t\t  auto used_args_in_prev_segment\n-\t\t    = GetUsedSubstArgs::From (root_tyty);\n-\t\t  lookup\n-\t\t    = SubstMapperInternal::Resolve (lookup,\n-\t\t\t\t\t\t    used_args_in_prev_segment);\n-\t\t}\n-\t    }\n+\t  rust_error_at (seg.get_locus (), \"failed to resolve root segment\");\n+\t  return new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n \t}\n \n       // turbo-fish segment path::<ty>\n@@ -300,16 +252,16 @@ TypeCheckExpr::resolve_root_path (HIR::PathInExpression &expr, size_t *offset,\n \t\t\t     lookup->as_string ().c_str ());\n \t      return new TyTy::ErrorType (lookup->get_ref ());\n \t    }\n-\t  lookup = SubstMapper::Resolve (lookup, expr.get_locus (),\n+\t  lookup = SubstMapper::Resolve (lookup, seg.get_locus (),\n \t\t\t\t\t &seg.get_generic_args ());\n \t}\n \n       *root_resolved_node_id = ref_node_id;\n       *offset = *offset + 1;\n-      root_tyty = lookup;\n+      return lookup;\n     }\n \n-  return root_tyty;\n+  return new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n }\n \n void\n@@ -424,19 +376,11 @@ TypeCheckExpr::resolve_segments (NodeId root_resolved_node_id,\n \t  bool ok = context->lookup_type (impl_ty_id, &impl_block_ty);\n \t  rust_assert (ok);\n \n-\t  if (prev_segment->needs_generic_substitutions ())\n-\t    {\n-\t      if (!impl_block_ty->needs_generic_substitutions ())\n-\t\t{\n-\t\t  prev_segment = impl_block_ty;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  HIR::PathExprSegment &pseg = segments.at (i - 1);\n-\t\t  Location locus = pseg.get_locus ();\n-\t\t  prev_segment = SubstMapper::InferSubst (prev_segment, locus);\n-\t\t}\n-\t    }\n+\t  if (impl_block_ty->needs_generic_substitutions ())\n+\t    impl_block_ty\n+\t      = SubstMapper::InferSubst (impl_block_ty, seg.get_locus ());\n+\n+\t  prev_segment = prev_segment->unify (impl_block_ty);\n \t}\n \n       if (tyseg->needs_generic_substitutions ())"}, {"sha": "ee6663877a5b95e40f801ad98b85d5967bc32f80", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea38a59ee8329bb7b309400a7de57d53ad7bde31/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea38a59ee8329bb7b309400a7de57d53ad7bde31/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=ea38a59ee8329bb7b309400a7de57d53ad7bde31", "patch": "@@ -54,18 +54,11 @@ TypeResolution::Resolve (HIR::Crate &crate)\n \n   // default inference variables if possible\n   context->iterate ([&] (HirId id, TyTy::BaseType *ty) mutable -> bool {\n-    if (ty->get_kind () == TyTy::TypeKind::ERROR)\n-      {\n-\trust_error_at (mappings->lookup_location (id),\n-\t\t       \"failure in type resolution for %u\", id);\n-\treturn false;\n-      }\n-\n     // nothing to do\n     if (ty->get_kind () != TyTy::TypeKind::INFER)\n       return true;\n \n-    TyTy::InferType *infer_var = (TyTy::InferType *) ty;\n+    TyTy::InferType *infer_var = static_cast<TyTy::InferType *> (ty);\n     TyTy::BaseType *default_type;\n     bool ok = infer_var->default_type (&default_type);\n     if (!ok)"}, {"sha": "1dd011229c20dd2b1e3d91422589e0f38669e224", "filename": "gcc/rust/typecheck/rust-tyty-rules.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea38a59ee8329bb7b309400a7de57d53ad7bde31/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea38a59ee8329bb7b309400a7de57d53ad7bde31/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h?ref=ea38a59ee8329bb7b309400a7de57d53ad7bde31", "patch": "@@ -89,6 +89,11 @@ class BaseRules : public TyVisitor\n     for (auto ref : other->get_combined_refs ())\n       resolved->append_reference (ref);\n \n+    other->append_reference (resolved->get_ref ());\n+    other->append_reference (get_base ()->get_ref ());\n+    get_base ()->append_reference (resolved->get_ref ());\n+    get_base ()->append_reference (other->get_ref ());\n+\n     bool result_resolved = resolved->get_kind () != TyTy::TypeKind::INFER;\n     bool result_is_infer_var = resolved->get_kind () == TyTy::TypeKind::INFER;\n     bool results_is_non_general_infer_var"}, {"sha": "847ca88900f178cd07970b41559c16ab18b82b62", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea38a59ee8329bb7b309400a7de57d53ad7bde31/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea38a59ee8329bb7b309400a7de57d53ad7bde31/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=ea38a59ee8329bb7b309400a7de57d53ad7bde31", "patch": "@@ -263,6 +263,7 @@ TyVar::get_implicit_infer_var (Location locus)\n \t\t\tinfer);\n   mappings->insert_location (mappings->get_current_crate (), infer->get_ref (),\n \t\t\t     locus);\n+\n   return TyVar (infer->get_ref ());\n }\n \n@@ -341,8 +342,34 @@ InferType::cast (BaseType *other)\n BaseType *\n InferType::clone () const\n {\n-  return new InferType (get_ref (), get_ty_ref (), get_infer_kind (),\n-\t\t\tget_ident ().locus, get_combined_refs ());\n+  // clones for inference variables are special in that they _must_ exist within\n+  // the type check context and we must ensure we don't loose the chain\n+  // otherwise we will end up in the missing type annotations case\n+  //\n+  // This means we cannot simply take over the same reference we must generate a\n+  // new ref just like the get_implicit_infer_var code then we can setup the\n+  // chain of references accordingly to ensure we don't loose the ability to\n+  // update the inference variables when we solve the type\n+\n+  auto mappings = Analysis::Mappings::get ();\n+  auto context = Resolver::TypeCheckContext::get ();\n+\n+  InferType *clone\n+    = new InferType (mappings->get_next_hir_id (), get_infer_kind (),\n+\t\t     get_ident ().locus, get_combined_refs ());\n+\n+  context->insert_type (Analysis::NodeMapping (mappings->get_current_crate (),\n+\t\t\t\t\t       UNKNOWN_NODEID,\n+\t\t\t\t\t       clone->get_ref (),\n+\t\t\t\t\t       UNKNOWN_LOCAL_DEFID),\n+\t\t\tclone);\n+  mappings->insert_location (mappings->get_current_crate (), clone->get_ref (),\n+\t\t\t     mappings->lookup_location (get_ref ()));\n+\n+  // setup the chain to reference this\n+  clone->append_reference (get_ref ());\n+\n+  return clone;\n }\n \n bool"}, {"sha": "271ce2c386b6cc5947c10fb3b8a48da59a715d9c", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea38a59ee8329bb7b309400a7de57d53ad7bde31/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea38a59ee8329bb7b309400a7de57d53ad7bde31/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=ea38a59ee8329bb7b309400a7de57d53ad7bde31", "patch": "@@ -955,12 +955,23 @@ class SubstitutionRef\n   BaseType *infer_substitions (Location locus)\n   {\n     std::vector<SubstitutionArg> args;\n+    std::map<std::string, BaseType *> argument_mappings;\n     for (auto &p : get_substs ())\n       {\n \tif (p.needs_substitution ())\n \t  {\n-\t    TyVar infer_var = TyVar::get_implicit_infer_var (locus);\n-\t    args.push_back (SubstitutionArg (&p, infer_var.get_tyty ()));\n+\t    const std::string &symbol = p.get_param_ty ()->get_symbol ();\n+\t    auto it = argument_mappings.find (symbol);\n+\t    if (it == argument_mappings.end ())\n+\t      {\n+\t\tTyVar infer_var = TyVar::get_implicit_infer_var (locus);\n+\t\targs.push_back (SubstitutionArg (&p, infer_var.get_tyty ()));\n+\t\targument_mappings[symbol] = infer_var.get_tyty ();\n+\t      }\n+\t    else\n+\t      {\n+\t\targs.push_back (SubstitutionArg (&p, it->second));\n+\t      }\n \t  }\n \telse\n \t  {"}, {"sha": "88a865d66dcfc47d9ed65d5a08a77cc99986c77f", "filename": "gcc/testsuite/rust/compile/torture/issue-893-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea38a59ee8329bb7b309400a7de57d53ad7bde31/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fissue-893-2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea38a59ee8329bb7b309400a7de57d53ad7bde31/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fissue-893-2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fissue-893-2.rs?ref=ea38a59ee8329bb7b309400a7de57d53ad7bde31", "patch": "@@ -24,7 +24,7 @@ impl Baz<i32, f32> {\n \n pub fn main() {\n     let a = Foo::<i32>::new::<f32>(123, 456f32);\n-    // let b = Foo::new::<f32>(123, 456f32);\n+    let b = Foo::new::<f32>(123, 456f32);\n \n     let c = Bar::<i32>(123);\n     let d = Bar::baz(c);"}]}