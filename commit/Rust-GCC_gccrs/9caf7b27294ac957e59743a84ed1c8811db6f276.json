{"sha": "9caf7b27294ac957e59743a84ed1c8811db6f276", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWNhZjdiMjcyOTRhYzk1N2U1OTc0M2E4NGVkMWM4ODExZGI2ZjI3Ng==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2015-05-15T18:37:25Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2015-05-15T18:37:25Z"}, "message": "ops.cc (stat_type): Define alias for struct stat and use throughout the file.\n\n\t* src/filesystem/ops.cc (stat_type): Define alias for struct stat and\n\tuse throughout the file.\n\t(make_file_type): New function.\n\t(file_size(const path&, error_code&)): Report an error for anything\n\tthat isn't a regular file.\n\t(status(const path&), symlink_status(const path&)): Do not throw for\n\tfile_type::not_found.\n\t(temp_directory_path()): Check additional environment variables.\n\t* testsuite/experimental/filesystem/operations/exists.cc: New.\n\t* testsuite/experimental/filesystem/operations/file_size.cc: New.\n\t* testsuite/experimental/filesystem/operations/status.cc: New.\n\t* testsuite/experimental/filesystem/operations/temp_directory_path.cc:\n\tNew.\n\nFrom-SVN: r223224", "tree": {"sha": "1e287b05d467be63a9b10d35fbf5993a76550f0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e287b05d467be63a9b10d35fbf5993a76550f0a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9caf7b27294ac957e59743a84ed1c8811db6f276", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9caf7b27294ac957e59743a84ed1c8811db6f276", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9caf7b27294ac957e59743a84ed1c8811db6f276", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9caf7b27294ac957e59743a84ed1c8811db6f276/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a37fa90703f62301130a3e1ef7ad4fade1bd786", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a37fa90703f62301130a3e1ef7ad4fade1bd786", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a37fa90703f62301130a3e1ef7ad4fade1bd786"}], "stats": {"total": 426, "additions": 384, "deletions": 42}, "files": [{"sha": "0f1089c6d2b8b6bf33a017ac6539361276ef070a", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9caf7b27294ac957e59743a84ed1c8811db6f276/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9caf7b27294ac957e59743a84ed1c8811db6f276/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=9caf7b27294ac957e59743a84ed1c8811db6f276", "patch": "@@ -1,3 +1,19 @@\n+2015-05-15  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* src/filesystem/ops.cc (stat_type): Define alias for struct stat and\n+\tuse throughout the file.\n+\t(make_file_type): New function.\n+\t(file_size(const path&, error_code&)): Report an error for anything\n+\tthat isn't a regular file.\n+\t(status(const path&), symlink_status(const path&)): Do not throw for\n+\tfile_type::not_found.\n+\t(temp_directory_path()): Check additional environment variables.\n+\t* testsuite/experimental/filesystem/operations/exists.cc: New.\n+\t* testsuite/experimental/filesystem/operations/file_size.cc: New.\n+\t* testsuite/experimental/filesystem/operations/status.cc: New.\n+\t* testsuite/experimental/filesystem/operations/temp_directory_path.cc:\n+\tNew.\n+\n 2015-05-14  Nathan Myers  <ncm@cantrip.org>\n \t    Jonathan Wakely  <jwakely@redhat.com>\n "}, {"sha": "661685aa04a46cf6a8fd536f924a123af84ef9c6", "filename": "libstdc++-v3/src/filesystem/ops.cc", "status": "modified", "additions": 71, "deletions": 42, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9caf7b27294ac957e59743a84ed1c8811db6f276/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fops.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9caf7b27294ac957e59743a84ed1c8811db6f276/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fops.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fops.cc?ref=9caf7b27294ac957e59743a84ed1c8811db6f276", "patch": "@@ -150,33 +150,39 @@ namespace\n #ifdef _GLIBCXX_HAVE_SYS_STAT_H\n namespace\n {\n-  fs::file_status\n-  make_file_status(const struct ::stat& st)\n+  typedef struct ::stat stat_type;\n+\n+  inline fs::file_type\n+  make_file_type(const stat_type& st)\n   {\n-    using fs::file_status;\n     using fs::file_type;\n-    using fs::perms;\n-    file_type ft;\n-    perms perm = static_cast<perms>(st.st_mode) & perms::mask;\n #ifdef _GLIBCXX_HAVE_S_ISREG\n     if (S_ISREG(st.st_mode))\n-      ft = file_type::regular;\n+      return file_type::regular;\n     else if (S_ISDIR(st.st_mode))\n-      ft = file_type::directory;\n+      return file_type::directory;\n     else if (S_ISCHR(st.st_mode))\n-      ft = file_type::character;\n+      return file_type::character;\n     else if (S_ISBLK(st.st_mode))\n-      ft = file_type::block;\n+      return file_type::block;\n     else if (S_ISFIFO(st.st_mode))\n-      ft = file_type::fifo;\n+      return file_type::fifo;\n     else if (S_ISLNK(st.st_mode))\n-      ft = file_type::symlink;\n+      return file_type::symlink;\n     else if (S_ISSOCK(st.st_mode))\n-      ft = file_type::socket;\n-    else\n+      return file_type::socket;\n #endif\n-      ft = file_type::unknown;\n-    return file_status{ft, perm};\n+    return file_type::unknown;\n+\n+  }\n+\n+  inline fs::file_status\n+  make_file_status(const stat_type& st)\n+  {\n+    return fs::file_status{\n+\tmake_file_type(st),\n+\tstatic_cast<fs::perms>(st.st_mode) & fs::perms::mask\n+    };\n   }\n \n   inline bool\n@@ -186,7 +192,7 @@ namespace\n   }\n \n   inline fs::file_time_type\n-  file_time(const struct ::stat& st)\n+  file_time(const stat_type& st)\n   {\n     using namespace std::chrono;\n     return fs::file_time_type{\n@@ -201,10 +207,10 @@ namespace\n   bool\n   do_copy_file(const fs::path& from, const fs::path& to,\n \t       fs::copy_options option,\n-\t       struct ::stat* from_st, struct ::stat* to_st,\n+\t       stat_type* from_st, stat_type* to_st,\n \t       std::error_code& ec) noexcept\n   {\n-    struct ::stat st1, st2;\n+    stat_type st1, st2;\n     fs::file_status t, f;\n \n     if (to_st == nullptr)\n@@ -342,7 +348,7 @@ fs::copy(const path& from, const path& to, copy_options options,\n   bool use_lstat = create_symlinks || skip_symlinks;\n \n   file_status f, t;\n-  struct ::stat from_st, to_st;\n+  stat_type from_st, to_st;\n   if (use_lstat\n       ? ::lstat(from.c_str(), &from_st)\n       : ::stat(from.c_str(), &from_st))\n@@ -564,7 +570,7 @@ fs::create_directory(const path& p, const path& attributes,\n \t\t     error_code& ec) noexcept\n {\n #ifdef _GLIBCXX_HAVE_SYS_STAT_H\n-  struct ::stat st;\n+  stat_type st;\n   if (::stat(attributes.c_str(), &st))\n     {\n       ec.assign(errno, std::generic_category());\n@@ -747,7 +753,7 @@ bool\n fs::equivalent(const path& p1, const path& p2, error_code& ec) noexcept\n {\n #ifdef _GLIBCXX_HAVE_SYS_STAT_H\n-  struct ::stat st1, st2;\n+  stat_type st1, st2;\n   if (::stat(p1.c_str(), &st1) == 0 && ::stat(p2.c_str(), &st2) == 0)\n     {\n       file_status s1 = make_file_status(st1);\n@@ -789,7 +795,7 @@ namespace\n     do_stat(const fs::path& p, std::error_code& ec, Accessor f, T deflt)\n     {\n #ifdef _GLIBCXX_HAVE_SYS_STAT_H\n-      struct ::stat st;\n+      stat_type st;\n       if (::stat(p.c_str(), &st))\n \t{\n \t  ec.assign(errno, std::generic_category());\n@@ -807,8 +813,24 @@ namespace\n std::uintmax_t\n fs::file_size(const path& p, error_code& ec) noexcept\n {\n-  return do_stat(p, ec, std::mem_fn(&stat::st_size),\n-\t\t static_cast<uintmax_t>(-1));\n+  struct S\n+  {\n+    S(const stat_type& st) : type(make_file_type(st)), size(st.st_size) { }\n+    S() : type(file_type::not_found) { }\n+    file_type type;\n+    size_t size;\n+  };\n+  auto s = do_stat(p, ec, [](const auto& st) { return S{st}; }, S{});\n+  if (s.type == file_type::regular)\n+    return s.size;\n+  if (!ec)\n+    {\n+      if (s.type == file_type::directory)\n+\tec = std::make_error_code(std::errc::is_a_directory);\n+      else\n+\tec = std::make_error_code(std::errc::not_supported);\n+    }\n+  return -1;\n }\n \n std::uintmax_t\n@@ -938,7 +960,7 @@ fs::read_symlink(const path& p)\n fs::path fs::read_symlink(const path& p, error_code& ec)\n {\n #ifdef _GLIBCXX_HAVE_SYS_STAT_H\n-  struct ::stat st;\n+  stat_type st;\n   if (::lstat(p.c_str(), &st))\n     {\n       ec.assign(errno, std::generic_category());\n@@ -1094,13 +1116,13 @@ fs::file_status\n fs::status(const fs::path& p, std::error_code& ec) noexcept\n {\n   file_status status;\n-  struct ::stat st;\n+  stat_type st;\n   if (::stat(p.c_str(), &st))\n     {\n       int err = errno;\n       ec.assign(err, std::generic_category());\n       if (is_not_found_errno(err))\n-\tstatus = file_status{file_type::not_found};\n+\tstatus.type(file_type::not_found);\n     }\n   else\n     {\n@@ -1114,13 +1136,13 @@ fs::file_status\n fs::symlink_status(const fs::path& p, std::error_code& ec) noexcept\n {\n   file_status status;\n-  struct ::stat st;\n+  stat_type st;\n   if (::lstat(p.c_str(), &st))\n     {\n       int err = errno;\n       ec.assign(err, std::generic_category());\n       if (is_not_found_errno(err))\n-\tstatus = file_status{file_type::not_found};\n+\tstatus.type(file_type::not_found);\n     }\n   else\n     {\n@@ -1135,20 +1157,20 @@ fs::file_status\n fs::status(const fs::path& p)\n {\n   std::error_code ec;\n-  auto s = status(p, ec);\n-  if (ec.value())\n+  auto result = status(p, ec);\n+  if (result.type() == file_type::none)\n     _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"status\", p, ec));\n-  return s;\n+  return result;\n }\n \n fs::file_status\n fs::symlink_status(const fs::path& p)\n {\n   std::error_code ec;\n-  auto s = symlink_status(p, ec);\n-  if (ec.value())\n-    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"symlink_status\", ec));\n-  return s;\n+  auto result = symlink_status(p, ec);\n+  if (result.type() == file_type::none)\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"symlink_status\", p, ec));\n+  return result;\n }\n \n fs::path\n@@ -1194,11 +1216,18 @@ fs::path fs::temp_directory_path(error_code& ec)\n   ec = std::make_error_code(std::errc::not_supported);\n   return {}; // TODO\n #else\n-  const char* tmpdir = ::getenv(\"TMPDIR\");\n-  if (!tmpdir)\n-    tmpdir = \"/tmp\";\n-  ec.clear();\n-  return tmpdir;\n+  const char* tmpdir = nullptr;\n+  const char* env[] = { \"TMPDIR\", \"TMP\", \"TEMP\", \"TEMPDIR\", nullptr };\n+  for (auto e = env; tmpdir == nullptr && *e != nullptr; ++e)\n+    tmpdir = ::getenv(*e);\n+  path p = tmpdir ? tmpdir : \"/tmp\";\n+  if (exists(p) && is_directory(p))\n+    {\n+      ec.clear();\n+      return p;\n+    }\n+  ec = std::make_error_code(std::errc::not_a_directory);\n+  return {};\n #endif\n }\n "}, {"sha": "0f1e5aaf203cfbe8d1817507643b6e9a6737a3a9", "filename": "libstdc++-v3/testsuite/experimental/filesystem/operations/exists.cc", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9caf7b27294ac957e59743a84ed1c8811db6f276/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Foperations%2Fexists.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9caf7b27294ac957e59743a84ed1c8811db6f276/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Foperations%2Fexists.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Foperations%2Fexists.cc?ref=9caf7b27294ac957e59743a84ed1c8811db6f276", "patch": "@@ -0,0 +1,58 @@\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11 -lstdc++fs\" }\n+// { dg-require-filesystem-ts \"\" }\n+\n+#include <experimental/filesystem>\n+#include <testsuite_hooks.h>\n+\n+using std::experimental::filesystem::path;\n+\n+void\n+test01()\n+{\n+  VERIFY( exists(path{\"/\"}) );\n+  VERIFY( exists(path{\"/.\"}) );\n+  VERIFY( exists(path{\".\"}) );\n+}\n+\n+void\n+test02()\n+{\n+  path rel{\"xXxXx\"};\n+  while (exists(rel))\n+    rel /= \"x\";\n+  VERIFY( !exists(rel) );\n+}\n+\n+void\n+test03()\n+{\n+  path abs{\"/xXxXx\"};\n+  while (exists(abs))\n+    abs /= \"x\";\n+  VERIFY( !exists(abs) );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "04fa7bb614dd39fb3091fdb8b780378f584d1a8f", "filename": "libstdc++-v3/testsuite/experimental/filesystem/operations/file_size.cc", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9caf7b27294ac957e59743a84ed1c8811db6f276/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Foperations%2Ffile_size.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9caf7b27294ac957e59743a84ed1c8811db6f276/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Foperations%2Ffile_size.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Foperations%2Ffile_size.cc?ref=9caf7b27294ac957e59743a84ed1c8811db6f276", "patch": "@@ -0,0 +1,70 @@\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11 -lstdc++fs\" }\n+// { dg-require-filesystem-ts \"\" }\n+\n+#include <experimental/filesystem>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+namespace fs = std::experimental::filesystem;\n+\n+void\n+test01()\n+{\n+  std::error_code ec;\n+  size_t size = fs::file_size(\".\", ec);\n+  VERIFY( ec == std::errc::is_a_directory );\n+  VERIFY( size == -1 );\n+\n+  try {\n+    size = fs::file_size(\".\");\n+    ec.clear();\n+  } catch (const fs::filesystem_error& e) {\n+    ec = e.code();\n+  }\n+  VERIFY( ec == std::errc::is_a_directory );\n+  VERIFY( size == -1 );\n+}\n+\n+void\n+test02()\n+{\n+  fs::path p = __gnu_test::nonexistent_path();\n+\n+  std::error_code ec;\n+  size_t size = fs::file_size(p, ec);\n+  VERIFY( ec );\n+  VERIFY( size == -1 );\n+\n+  try {\n+    size = fs::file_size(p);\n+    ec.clear();\n+  } catch (const fs::filesystem_error& e) {\n+    ec = e.code();\n+  }\n+  VERIFY( ec );\n+  VERIFY( size == -1 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "2c54494be29ff38a835bc511523d34902b0ad86e", "filename": "libstdc++-v3/testsuite/experimental/filesystem/operations/status.cc", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9caf7b27294ac957e59743a84ed1c8811db6f276/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Foperations%2Fstatus.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9caf7b27294ac957e59743a84ed1c8811db6f276/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Foperations%2Fstatus.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Foperations%2Fstatus.cc?ref=9caf7b27294ac957e59743a84ed1c8811db6f276", "patch": "@@ -0,0 +1,58 @@\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11 -lstdc++fs\" }\n+// { dg-require-filesystem-ts \"\" }\n+\n+#include <experimental/filesystem>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+namespace fs = std::experimental::filesystem;\n+\n+void\n+test01()\n+{\n+  std::error_code ec;\n+  fs::file_status st1 = fs::status(\".\", ec);\n+  VERIFY( !ec );\n+  VERIFY( st1.type() == fs::file_type::directory );\n+\n+  fs::file_status st2 = fs::status(\".\");\n+  VERIFY( st2.type() == fs::file_type::directory );\n+}\n+\n+void\n+test02()\n+{\n+  fs::path p = __gnu_test::nonexistent_path();\n+\n+  std::error_code ec;\n+  fs::file_status st1 = fs::status(p, ec);\n+  VERIFY( ec );\n+  VERIFY( st1.type() == fs::file_type::not_found );\n+\n+  fs::file_status st2 = fs::status(p);\n+  VERIFY( st2.type() == fs::file_type::not_found );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "2aacd1c38c3f75e2f0ad645dc6c5dddc40ab7ae6", "filename": "libstdc++-v3/testsuite/experimental/filesystem/operations/temp_directory_path.cc", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9caf7b27294ac957e59743a84ed1c8811db6f276/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Foperations%2Ftemp_directory_path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9caf7b27294ac957e59743a84ed1c8811db6f276/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Foperations%2Ftemp_directory_path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Foperations%2Ftemp_directory_path.cc?ref=9caf7b27294ac957e59743a84ed1c8811db6f276", "patch": "@@ -0,0 +1,80 @@\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11 -lstdc++fs\" }\n+// { dg-require-filesystem-ts \"\" }\n+\n+#include <experimental/filesystem>\n+#include <stdlib.h>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+void\n+clean_env()\n+{\n+  ::unsetenv(\"TMPDIR\");\n+  ::unsetenv(\"TMP\");\n+  ::unsetenv(\"TEMPDIR\");\n+  ::unsetenv(\"TEMP\");\n+}\n+\n+namespace fs = std::experimental::filesystem;\n+\n+void\n+test01()\n+{\n+  clean_env();\n+\n+  if (!fs::exists(\"/tmp\"))\n+    return; // just give up\n+\n+  std::error_code ec;\n+  fs::path p1 = fs::temp_directory_path(ec);\n+  VERIFY( exists(p1) );\n+\n+  fs::path p2 = fs::temp_directory_path();\n+  VERIFY( p1 == p2 );\n+}\n+\n+void\n+test02()\n+{\n+  clean_env();\n+\n+  if (::setenv(\"TMPDIR\", __gnu_test::nonexistent_path().string().c_str(), 1))\n+    return; // just give up\n+\n+  std::error_code ec;\n+  fs::path p = fs::temp_directory_path(ec);\n+  VERIFY( ec );\n+\n+  std::error_code ec2;\n+  try {\n+    p = fs::temp_directory_path();\n+  } catch (const fs::filesystem_error& e) {\n+    ec2 = e.code();\n+  }\n+  VERIFY( ec2 == ec );\n+}\n+\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "f404a7a7ff8c963fc7cc399732560b8dbd68b8c6", "filename": "libstdc++-v3/testsuite/util/testsuite_fs.h", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9caf7b27294ac957e59743a84ed1c8811db6f276/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_fs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9caf7b27294ac957e59743a84ed1c8811db6f276/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_fs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_fs.h?ref=9caf7b27294ac957e59743a84ed1c8811db6f276", "patch": "@@ -25,6 +25,11 @@\n #include <experimental/filesystem>\n #include <iostream>\n #include <string>\n+#include <cstdio>\n+#if defined(_GNU_SOURCE) || _XOPEN_SOURCE >= 500 || _POSIX_C_SOURCE >= 200112L\n+# include <stdlib.h>\n+# include <unistd.h>\n+#endif\n \n namespace __gnu_test\n {\n@@ -63,5 +68,31 @@ namespace __gnu_test\n     \"a\", \"a/b\", \"a/b/\", \"a/b/c\", \"a/b/c.d\", \"a/b/..\", \"a/b/c.\", \"a/b/.c\"\n   };\n \n+  // This is NOT supposed to be a secure way to get a unique name!\n+  // We just need a path that doesn't exist for testing purposes.\n+  std::experimental::filesystem::path\n+  nonexistent_path()\n+  {\n+    std::experimental::filesystem::path p;\n+#if defined(_GNU_SOURCE) || _XOPEN_SOURCE >= 500 || _POSIX_C_SOURCE >= 200112L\n+    char tmp[] = \"test.XXXXXX\";\n+    int fd = ::mkstemp(tmp);\n+    if (fd == -1)\n+      throw std::experimental::filesystem::filesystem_error(\"mkstemp failed\",\n+\t  std::error_code(errno, std::generic_category()));\n+    ::unlink(tmp);\n+    ::close(fd);\n+    p = tmp;\n+#else\n+    char* tmp = tempnam(\".\", \"test.\");\n+    if (!tmp)\n+      throw std::experimental::filesystem::filesystem_error(\"tempnam failed\",\n+\t  std::error_code(errno, std::generic_category()));\n+    p = tmp;\n+    ::free(tmp);\n+#endif\n+    return p;\n+  }\n+\n } // namespace __gnu_test\n #endif"}]}