{"sha": "759f1648029eef1fde1c66e342b033438c44e3b5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzU5ZjE2NDgwMjllZWYxZmRlMWM2NmUzNDJiMDMzNDM4YzQ0ZTNiNQ==", "commit": {"author": {"name": "Dmitriy Anisimkov", "email": "anisimko@adacore.com", "date": "2018-12-11T11:12:32Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-12-11T11:12:32Z"}, "message": "[Ada] GNAT.Sockets: add IPv6 support\n\n2018-12-11  Dmitriy Anisimkov  <anisimko@adacore.com>\n\ngcc/ada/\n\n\t* libgnat/g-socket.ads (Family_Type): Add new enumerated value\n\tFamily_Unspec to be able to use it in Get_Address_Info parameter\n\tand find IPv4 together with IPv6 addresses.\n\t(Inet_Addr_Bytes_Length): Zero length for Family_Unspec.  New\n\tIPv6 predefined constant addresses.\n\t(IPv4_To_IPv6_Prefix): IPv4 mapped to IPv6 address prefix.\n\t(Is_IPv4_Address): Rename from Is_IP_Address and published.\n\t(Is_IPv6_Address): New routine.\n\t(Image of Inet_Addr_Type): Fix description about IPv6 address\n\ttext representation.\n\t(Level_Type): New propocol level IP_Protocol_For_IPv6_Level.\n\t(Add_Membership_V4): New socket option equal to Add_Membership.\n\t(Drop_Membership_V4): New socket option equal to\n\tDrop_Membership.\n\t(Multicast_If_V4): New socket option equal to Multicast_If.\n\t(Multicast_Loop_V4, Add_Membership_V6, Drop_Membership_V6,\n\tMulticast_If_V6, Multicast_Loop_V6, Multicast_Hops, IPv6_Only):\n\tNew socket option for IPv6.\n\t(Address_Info): New record to keep address info.\n\t(Address_Info_Array): Array to keep address info records.\n\t(Get_Address_Info): Routine to get address info records by host\n\tand service names.\n\t(Host_Service): Record to keep host and service names.\n\t(Get_Name_Info): New routine to get host and service names by\n\taddress.\n\t(Create_Socket): Add Level parameter, IP_Protocol_For_IP_Level\n\tdefault.\n\t(Name_Array, Inet_Addr_Array): Change array index to Positive.\n\t* libgnat/g-socket.adb (IPV6_Mreq): New record definition for\n\tIPv6.\n\t(Hex_To_Char): Remove.\n\t(Short_To_Network, Network_To_Short): Move to package\n\tGNAT.Sockets.Thin_Common.\n\t(Is_IP_Address): Remove.\n\t(To_In_Addr, To_Inet_Addr): Move to package\n\tGNAT.Sockets.Thin_Common.\n\t(Get_Socket_Option): Get value of Multicast_Loop option as\n\tinteger boolean, process IPv6 options. Don't try to get\n\tAdd_Membership_V4, Add_Membership_V6, Drop_Membership_V4, and\n\tDrop_Membership_V6 as not supported by the socket API.\n\t(Set_Socket_Option): Set value of Multicast_Loop option as\n\tinteger boolean, process IPv6 options.\n\t* gsocket.h\n\t(IPV6_ADD_MEMBERSHIP): Define from IPV6_JOIN_GROUP if necessary\n\tfor VxWorks.\n\t(IPV6_DROP_MEMBERSHIP): Define from IPV6_LEAVE_GROUP if\n\tnecessary for VxWorks\n\t(HAVE_INET_NTOP): New definition.\n\t(HAVE_INET_PTON): Includes VxWorks now.\n\t* socket.c (__gnat_getaddrinfo, __gnat_getnameinfo,\n\t__gnat_freeaddrinfo, __gnat_gai_strerror, __gnat_inet_ntop): New\n\troutines.\n\t* libgnat/g-sothco.ads, libgnat/g-sothco.adb\n\t(socklen_t, In6_Addr, To_In6_Addr): New.\n\t(To_In_Addr, To_Inet_Addr): Move from package body GNAT.Sockets.\n\t(To_Inet_Addr): New overload with In6_Addr type parmeter.\n\t(In_Addr_Access_Array): Remove.\n\t(Sockaddr): Unchecked_Union instead of Sockaddr_In and old\n\tdefined generic Sockaddr.\n\t(Set_Address): Use it to set family, port and address into\n\tSockaddr.\n\t(Get_Address): New routine to get Socket_Addr_Type from\n\tSockaddr.\n\t(Addrinfo): Structure to use with getaddrinfo.\n\t(C_Getaddrinfo, C_Freeaddrinfo, C_Getnameinfo, C_GAI_Strerror,\n\tInet_Ntop): New routine import.\n\t(Short_To_Network, Network_To_Short): Move from package body\n\tGNAT.Sockets.\n\t* libgnat/g-stsifd__sockets.adb: Use Sockaddr instead of\n\tSockaddr_In.\n\t* s-oscons-tmplt.c (AF_UNSPEC, EAI_SYSTEM, SOCK_RAW,\n\tIPPROTO_IPV6, IP_RECVERR, SIZEOF_socklen_t, IF_NAMESIZE): New\n\tconstants.\n\t(AI_xxxx_OFFSET): Constants to consider platform differences in\n\tfield positions and sizes for addrinfo structure.\n\t(AI_xxxxx): Flags for getaddrinfo.\n\t(NI_xxxxx): Flags for getnameinfo.\n\t(IPV6_xxxxx): Socket options for IPv6.\n\t(Inet_Ntop_Linkname): New routine.\n\nFrom-SVN: r267016", "tree": {"sha": "ab1a23e36f228d370e5baa848c6b474263994c34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ab1a23e36f228d370e5baa848c6b474263994c34"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/759f1648029eef1fde1c66e342b033438c44e3b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/759f1648029eef1fde1c66e342b033438c44e3b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/759f1648029eef1fde1c66e342b033438c44e3b5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/759f1648029eef1fde1c66e342b033438c44e3b5/comments", "author": {"login": "anisimkov", "id": 15864134, "node_id": "MDQ6VXNlcjE1ODY0MTM0", "avatar_url": "https://avatars.githubusercontent.com/u/15864134?v=4", "gravatar_id": "", "url": "https://api.github.com/users/anisimkov", "html_url": "https://github.com/anisimkov", "followers_url": "https://api.github.com/users/anisimkov/followers", "following_url": "https://api.github.com/users/anisimkov/following{/other_user}", "gists_url": "https://api.github.com/users/anisimkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/anisimkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/anisimkov/subscriptions", "organizations_url": "https://api.github.com/users/anisimkov/orgs", "repos_url": "https://api.github.com/users/anisimkov/repos", "events_url": "https://api.github.com/users/anisimkov/events{/privacy}", "received_events_url": "https://api.github.com/users/anisimkov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d71b0a9a041430612883f7f891bb25b8e21b6f2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d71b0a9a041430612883f7f891bb25b8e21b6f2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d71b0a9a041430612883f7f891bb25b8e21b6f2c"}], "stats": {"total": 1812, "additions": 1441, "deletions": 371}, "files": [{"sha": "aab6ceb5c259801ec5e95fcaa3537e54d53925e2", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/759f1648029eef1fde1c66e342b033438c44e3b5/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/759f1648029eef1fde1c66e342b033438c44e3b5/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=759f1648029eef1fde1c66e342b033438c44e3b5", "patch": "@@ -1,3 +1,85 @@\n+2018-12-11  Dmitriy Anisimkov  <anisimko@adacore.com>\n+\n+\t* libgnat/g-socket.ads (Family_Type): Add new enumerated value\n+\tFamily_Unspec to be able to use it in Get_Address_Info parameter\n+\tand find IPv4 together with IPv6 addresses.\n+\t(Inet_Addr_Bytes_Length): Zero length for Family_Unspec.  New\n+\tIPv6 predefined constant addresses.\n+\t(IPv4_To_IPv6_Prefix): IPv4 mapped to IPv6 address prefix.\n+\t(Is_IPv4_Address): Rename from Is_IP_Address and published.\n+\t(Is_IPv6_Address): New routine.\n+\t(Image of Inet_Addr_Type): Fix description about IPv6 address\n+\ttext representation.\n+\t(Level_Type): New propocol level IP_Protocol_For_IPv6_Level.\n+\t(Add_Membership_V4): New socket option equal to Add_Membership.\n+\t(Drop_Membership_V4): New socket option equal to\n+\tDrop_Membership.\n+\t(Multicast_If_V4): New socket option equal to Multicast_If.\n+\t(Multicast_Loop_V4, Add_Membership_V6, Drop_Membership_V6,\n+\tMulticast_If_V6, Multicast_Loop_V6, Multicast_Hops, IPv6_Only):\n+\tNew socket option for IPv6.\n+\t(Address_Info): New record to keep address info.\n+\t(Address_Info_Array): Array to keep address info records.\n+\t(Get_Address_Info): Routine to get address info records by host\n+\tand service names.\n+\t(Host_Service): Record to keep host and service names.\n+\t(Get_Name_Info): New routine to get host and service names by\n+\taddress.\n+\t(Create_Socket): Add Level parameter, IP_Protocol_For_IP_Level\n+\tdefault.\n+\t(Name_Array, Inet_Addr_Array): Change array index to Positive.\n+\t* libgnat/g-socket.adb (IPV6_Mreq): New record definition for\n+\tIPv6.\n+\t(Hex_To_Char): Remove.\n+\t(Short_To_Network, Network_To_Short): Move to package\n+\tGNAT.Sockets.Thin_Common.\n+\t(Is_IP_Address): Remove.\n+\t(To_In_Addr, To_Inet_Addr): Move to package\n+\tGNAT.Sockets.Thin_Common.\n+\t(Get_Socket_Option): Get value of Multicast_Loop option as\n+\tinteger boolean, process IPv6 options. Don't try to get\n+\tAdd_Membership_V4, Add_Membership_V6, Drop_Membership_V4, and\n+\tDrop_Membership_V6 as not supported by the socket API.\n+\t(Set_Socket_Option): Set value of Multicast_Loop option as\n+\tinteger boolean, process IPv6 options.\n+\t* gsocket.h\n+\t(IPV6_ADD_MEMBERSHIP): Define from IPV6_JOIN_GROUP if necessary\n+\tfor VxWorks.\n+\t(IPV6_DROP_MEMBERSHIP): Define from IPV6_LEAVE_GROUP if\n+\tnecessary for VxWorks\n+\t(HAVE_INET_NTOP): New definition.\n+\t(HAVE_INET_PTON): Includes VxWorks now.\n+\t* socket.c (__gnat_getaddrinfo, __gnat_getnameinfo,\n+\t__gnat_freeaddrinfo, __gnat_gai_strerror, __gnat_inet_ntop): New\n+\troutines.\n+\t* libgnat/g-sothco.ads, libgnat/g-sothco.adb\n+\t(socklen_t, In6_Addr, To_In6_Addr): New.\n+\t(To_In_Addr, To_Inet_Addr): Move from package body GNAT.Sockets.\n+\t(To_Inet_Addr): New overload with In6_Addr type parmeter.\n+\t(In_Addr_Access_Array): Remove.\n+\t(Sockaddr): Unchecked_Union instead of Sockaddr_In and old\n+\tdefined generic Sockaddr.\n+\t(Set_Address): Use it to set family, port and address into\n+\tSockaddr.\n+\t(Get_Address): New routine to get Socket_Addr_Type from\n+\tSockaddr.\n+\t(Addrinfo): Structure to use with getaddrinfo.\n+\t(C_Getaddrinfo, C_Freeaddrinfo, C_Getnameinfo, C_GAI_Strerror,\n+\tInet_Ntop): New routine import.\n+\t(Short_To_Network, Network_To_Short): Move from package body\n+\tGNAT.Sockets.\n+\t* libgnat/g-stsifd__sockets.adb: Use Sockaddr instead of\n+\tSockaddr_In.\n+\t* s-oscons-tmplt.c (AF_UNSPEC, EAI_SYSTEM, SOCK_RAW,\n+\tIPPROTO_IPV6, IP_RECVERR, SIZEOF_socklen_t, IF_NAMESIZE): New\n+\tconstants.\n+\t(AI_xxxx_OFFSET): Constants to consider platform differences in\n+\tfield positions and sizes for addrinfo structure.\n+\t(AI_xxxxx): Flags for getaddrinfo.\n+\t(NI_xxxxx): Flags for getnameinfo.\n+\t(IPV6_xxxxx): Socket options for IPv6.\n+\t(Inet_Ntop_Linkname): New routine.\n+\n 2018-12-11  Yannick Moy  <moy@adacore.com>\n \n \t* sem_ch6.adb (Analyze_Subprogram_Body_Helper): Deactivate"}, {"sha": "ab441487fe58dde13124a9e15d696302cc8fc208", "filename": "gcc/ada/gsocket.h", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/759f1648029eef1fde1c66e342b033438c44e3b5/gcc%2Fada%2Fgsocket.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/759f1648029eef1fde1c66e342b033438c44e3b5/gcc%2Fada%2Fgsocket.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgsocket.h?ref=759f1648029eef1fde1c66e342b033438c44e3b5", "patch": "@@ -63,10 +63,19 @@\n #include <vxWorks.h>\n #include <ioLib.h>\n #include <hostLib.h>\n+\n #define SHUT_RD\t\t0\n #define SHUT_WR\t\t1\n #define SHUT_RDWR\t2\n \n+#ifndef IPV6_ADD_MEMBERSHIP\n+#define IPV6_ADD_MEMBERSHIP IPV6_JOIN_GROUP\n+#endif\n+\n+#ifndef IPV6_DROP_MEMBERSHIP\n+#define IPV6_DROP_MEMBERSHIP IPV6_LEAVE_GROUP\n+#endif\n+\n #elif defined (WINNT)\n #define FD_SETSIZE 1024\n \n@@ -250,8 +259,9 @@\n # define Has_Sockaddr_Len 0\n #endif\n \n-#if !(defined (__vxworks) || defined (_WIN32) || defined (__hpux__) || defined (VMS))\n+#if !(defined (_WIN32) || defined (__hpux__) || defined (VMS))\n # define HAVE_INET_PTON\n+# define HAVE_INET_NTOP\n #endif\n \n #endif /* defined(VTHREADS) */"}, {"sha": "8a7783aeb196eea60aa4d5c101b6b905697e6d72", "filename": "gcc/ada/libgnat/g-socket.adb", "status": "modified", "additions": 493, "deletions": 268, "changes": 761, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/759f1648029eef1fde1c66e342b033438c44e3b5/gcc%2Fada%2Flibgnat%2Fg-socket.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/759f1648029eef1fde1c66e342b033438c44e3b5/gcc%2Fada%2Flibgnat%2Fg-socket.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-socket.adb?ref=759f1648029eef1fde1c66e342b033438c44e3b5", "patch": "@@ -31,6 +31,7 @@\n \n with Ada.Streams;              use Ada.Streams;\n with Ada.Exceptions;           use Ada.Exceptions;\n+with Ada.Containers.Generic_Array_Sort;\n with Ada.Finalization;\n with Ada.Unchecked_Conversion;\n \n@@ -50,6 +51,12 @@ package body GNAT.Sockets is\n \n    package C renames Interfaces.C;\n \n+   type IPV6_Mreq is record\n+      ipv6mr_multiaddr : In6_Addr;\n+      ipv6mr_interface : C.unsigned;\n+   end record with Convention => C;\n+   --  Record to Add/Drop_Membership for multicast in IPv6\n+\n    ENOERROR : constant := 0;\n \n    Netdb_Buffer_Size : constant := SOSC.Need_Netdb_Buffer * 1024;\n@@ -62,10 +69,11 @@ package body GNAT.Sockets is\n    --  Correspondence tables\n \n    Levels : constant array (Level_Type) of C.int :=\n-              (Socket_Level              => SOSC.SOL_SOCKET,\n-               IP_Protocol_For_IP_Level  => SOSC.IPPROTO_IP,\n-               IP_Protocol_For_UDP_Level => SOSC.IPPROTO_UDP,\n-               IP_Protocol_For_TCP_Level => SOSC.IPPROTO_TCP);\n+              (Socket_Level               => SOSC.SOL_SOCKET,\n+               IP_Protocol_For_IP_Level   => SOSC.IPPROTO_IP,\n+               IP_Protocol_For_IPv6_Level => SOSC.IPPROTO_IPV6,\n+               IP_Protocol_For_UDP_Level  => SOSC.IPPROTO_UDP,\n+               IP_Protocol_For_TCP_Level  => SOSC.IPPROTO_TCP);\n \n    Modes : constant array (Mode_Type) of C.int :=\n              (Socket_Stream   => SOSC.SOCK_STREAM,\n@@ -89,12 +97,18 @@ package body GNAT.Sockets is\n                 Linger              => SOSC.SO_LINGER,\n                 Error               => SOSC.SO_ERROR,\n                 No_Delay            => SOSC.TCP_NODELAY,\n-                Add_Membership      => SOSC.IP_ADD_MEMBERSHIP,\n-                Drop_Membership     => SOSC.IP_DROP_MEMBERSHIP,\n-                Multicast_If        => SOSC.IP_MULTICAST_IF,\n-                Multicast_TTL       => SOSC.IP_MULTICAST_TTL,\n-                Multicast_Loop      => SOSC.IP_MULTICAST_LOOP,\n+                Add_Membership_V4   => SOSC.IP_ADD_MEMBERSHIP,\n+                Drop_Membership_V4  => SOSC.IP_DROP_MEMBERSHIP,\n+                Multicast_If_V4     => SOSC.IP_MULTICAST_IF,\n+                Multicast_Loop_V4   => SOSC.IP_MULTICAST_LOOP,\n                 Receive_Packet_Info => SOSC.IP_PKTINFO,\n+                Multicast_TTL       => SOSC.IP_MULTICAST_TTL,\n+                Add_Membership_V6   => SOSC.IPV6_ADD_MEMBERSHIP,\n+                Drop_Membership_V6  => SOSC.IPV6_DROP_MEMBERSHIP,\n+                Multicast_If_V6     => SOSC.IPV6_MULTICAST_IF,\n+                Multicast_Loop_V6   => SOSC.IPV6_MULTICAST_LOOP,\n+                Multicast_Hops      => SOSC.IPV6_MULTICAST_HOPS,\n+                IPv6_Only           => SOSC.IPV6_V6ONLY,\n                 Send_Timeout        => SOSC.SO_SNDTIMEO,\n                 Receive_Timeout     => SOSC.SO_RCVTIMEO,\n                 Busy_Polling        => SOSC.SO_BUSY_POLL);\n@@ -110,8 +124,16 @@ package body GNAT.Sockets is\n    Socket_Error_Id : constant Exception_Id := Socket_Error'Identity;\n    Host_Error_Id   : constant Exception_Id := Host_Error'Identity;\n \n-   Hex_To_Char : constant String (1 .. 16) := \"0123456789ABCDEF\";\n-   --  Use to print in hexadecimal format\n+   type In_Addr_Union (Family : Family_Type) is record\n+      case Family is\n+         when Family_Inet =>\n+            In4 : In_Addr;\n+         when Family_Inet6 =>\n+            In6 : In6_Addr;\n+         when Family_Unspec =>\n+            null;\n+      end case;\n+   end record with Unchecked_Union;\n \n    -----------------------\n    -- Local subprograms --\n@@ -133,37 +155,13 @@ package body GNAT.Sockets is\n    function Set_Forced_Flags (F : C.int) return C.int;\n    --  Return F with the bits from SOSC.MSG_Forced_Flags forced set\n \n-   function Short_To_Network\n-     (S : C.unsigned_short) return C.unsigned_short;\n-   pragma Inline (Short_To_Network);\n-   --  Convert a port number into a network port number\n-\n-   function Network_To_Short\n-     (S : C.unsigned_short) return C.unsigned_short\n-   renames Short_To_Network;\n-   --  Symmetric operation\n-\n-   function Image\n-     (Val : Inet_Addr_Bytes;\n-      Hex : Boolean := False) return String;\n-   --  Output an array of inet address components in hex or decimal mode\n-\n-   function Is_IP_Address (Name : String) return Boolean;\n-   --  Return true when Name is an IPv4 address in dotted quad notation\n-\n    procedure Netdb_Lock;\n    pragma Inline (Netdb_Lock);\n    procedure Netdb_Unlock;\n    pragma Inline (Netdb_Unlock);\n    --  Lock/unlock operation used to protect netdb access for platforms that\n    --  require such protection.\n \n-   function To_In_Addr (Addr : Inet_Addr_Type) return In_Addr;\n-   procedure To_Inet_Addr\n-     (Addr   : In_Addr;\n-      Result : out Inet_Addr_Type);\n-   --  Conversion functions\n-\n    function To_Host_Entry (E : Hostent_Access) return Host_Entry_Type;\n    --  Conversion function\n \n@@ -180,6 +178,12 @@ package body GNAT.Sockets is\n    --  Reconstruct a Duration value from a Timeval record (seconds and\n    --  microseconds).\n \n+   function Dedot (Value : String) return String\n+   is (if Value /= \"\" and then Value (Value'Last) = '.'\n+       then Value (Value'First .. Value'Last - 1)\n+       else Value);\n+   --  Removes dot at the end of error message\n+\n    procedure Raise_Socket_Error (Error : Integer);\n    --  Raise Socket_Error with an exception message describing the error code\n    --  from errno.\n@@ -189,6 +193,13 @@ package body GNAT.Sockets is\n    --  hstrerror seems to be obsolete) from h_errno. Name is the name\n    --  or address that was being looked up.\n \n+   procedure Raise_GAI_Error (RC : C.int; Name : String);\n+   --  Raise Host_Error with exception message in case of errors in\n+   --  getaddrinfo and getnameinfo.\n+\n+   function Is_Windows return Boolean with Inline;\n+   --  Returns True on Windows platform\n+\n    procedure Narrow (Item : in out Socket_Set_Type);\n    --  Update Last as it may be greater than the real last socket\n \n@@ -328,7 +339,7 @@ package body GNAT.Sockets is\n       Address : out Sock_Addr_Type)\n    is\n       Res : C.int;\n-      Sin : aliased Sockaddr_In;\n+      Sin : aliased Sockaddr;\n       Len : aliased C.int := Sin'Size / 8;\n \n    begin\n@@ -339,9 +350,7 @@ package body GNAT.Sockets is\n       end if;\n \n       Socket := Socket_Type (Res);\n-\n-      To_Inet_Addr (Sin.Sin_Addr, Address.Addr);\n-      Address.Port := Port_Type (Network_To_Short (Sin.Sin_Port));\n+      Address := Get_Address (Sin);\n    end Accept_Socket;\n \n    -------------------\n@@ -451,20 +460,11 @@ package body GNAT.Sockets is\n       Address : Sock_Addr_Type)\n    is\n       Res : C.int;\n-      Sin : aliased Sockaddr_In;\n+      Sin : aliased Sockaddr;\n       Len : constant C.int := Sin'Size / 8;\n-      --  This assumes that Address.Family = Family_Inet???\n \n    begin\n-      if Address.Family = Family_Inet6 then\n-         raise Socket_Error with \"IPv6 not supported\";\n-      end if;\n-\n-      Set_Family  (Sin.Sin_Family, Address.Family);\n-      Set_Address (Sin'Unchecked_Access, To_In_Addr (Address.Addr));\n-      Set_Port\n-        (Sin'Unchecked_Access,\n-         Short_To_Network (C.unsigned_short (Address.Port)));\n+      Set_Address (Sin'Unchecked_Access, Address);\n \n       Res := C_Bind (C.int (Socket), Sin'Address, Len);\n \n@@ -478,14 +478,12 @@ package body GNAT.Sockets is\n    ----------------------\n \n    procedure Check_For_Fd_Set (Fd : Socket_Type) is\n-      use SOSC;\n-\n    begin\n       --  On Windows, fd_set is a FD_SETSIZE array of socket ids:\n       --  no check required. Warnings suppressed because condition\n       --  is known at compile time.\n \n-      if Target_OS = Windows then\n+      if Is_Windows then\n \n          return;\n \n@@ -667,19 +665,11 @@ package body GNAT.Sockets is\n      (Socket : Socket_Type;\n       Server : Sock_Addr_Type) return C.int\n    is\n-      Sin : aliased Sockaddr_In;\n+      Sin : aliased Sockaddr;\n       Len : constant C.int := Sin'Size / 8;\n \n    begin\n-      if Server.Family = Family_Inet6 then\n-         raise Socket_Error with \"IPv6 not supported\";\n-      end if;\n-\n-      Set_Family  (Sin.Sin_Family, Server.Family);\n-      Set_Address (Sin'Unchecked_Access, To_In_Addr (Server.Addr));\n-      Set_Port\n-        (Sin'Unchecked_Access,\n-         Short_To_Network (C.unsigned_short (Server.Port)));\n+      Set_Address (Sin'Unchecked_Access, Server);\n \n       return C_Connect (C.int (Socket), Sin'Address, Len);\n    end Connect_Socket;\n@@ -861,12 +851,13 @@ package body GNAT.Sockets is\n    procedure Create_Socket\n      (Socket : out Socket_Type;\n       Family : Family_Type := Family_Inet;\n-      Mode   : Mode_Type   := Socket_Stream)\n+      Mode   : Mode_Type   := Socket_Stream;\n+      Level  : Level_Type  := IP_Protocol_For_IP_Level)\n    is\n       Res : C.int;\n \n    begin\n-      Res := C_Socket (Families (Family), Modes (Mode), 0);\n+      Res := C_Socket (Families (Family), Modes (Mode), Levels (Level));\n \n       if Res = Failure then\n          Raise_Socket_Error (Socket_Errno);\n@@ -959,6 +950,228 @@ package body GNAT.Sockets is\n       end if;\n    end Get_Address;\n \n+   ---------------------\n+   -- Raise_GAI_Error --\n+   ---------------------\n+\n+   procedure Raise_GAI_Error (RC : C.int; Name : String) is\n+   begin\n+      if RC = SOSC.EAI_SYSTEM then\n+         declare\n+            Errcode : constant Integer := Socket_Errno;\n+         begin\n+            raise Host_Error with Err_Code_Image (Errcode)\n+              & Dedot (Socket_Error_Message (Errcode)) & \": \" & Name;\n+         end;\n+      else\n+         raise Host_Error with Err_Code_Image (Integer (RC))\n+           & Dedot (CS.Value (C_GAI_Strerror (RC))) & \": \" & Name;\n+      end if;\n+   end Raise_GAI_Error;\n+\n+   ----------------------\n+   -- Get_Address_Info --\n+   ----------------------\n+\n+   function Get_Address_Info\n+     (Host         : String;\n+      Service      : String;\n+      Family       : Family_Type := Family_Unspec;\n+      Mode         : Mode_Type   := Socket_Stream;\n+      Level        : Level_Type  := IP_Protocol_For_IP_Level;\n+      Numeric_Host : Boolean     := False;\n+      Passive      : Boolean     := False;\n+      Unknown      : access procedure\n+        (Family, Mode, Level, Length : Integer) := null)\n+      return Address_Info_Array\n+   is\n+      A : aliased Addrinfo_Access;\n+      N : aliased C.char_array := C.To_C (Host);\n+      S : aliased C.char_array := C.To_C (if Service = \"\" then \"0\"\n+                                          else Service);\n+      Hints : aliased constant Addrinfo :=\n+        (ai_family   => Families (Family),\n+         ai_socktype => Modes (Mode),\n+         ai_protocol => Levels (Level),\n+         ai_flags    => (if Numeric_Host then SOSC.AI_NUMERICHOST else 0) +\n+                        (if Passive then SOSC.AI_PASSIVE else 0),\n+         ai_addrlen  => 0,\n+         others      => <>);\n+\n+      R     : C.int;\n+      Iter  : Addrinfo_Access;\n+      Found : Boolean;\n+\n+      function To_Array return Address_Info_Array;\n+      --  Convert taken from OS addrinfo list A into Address_Info_Array\n+\n+      --------------\n+      -- To_Array --\n+      --------------\n+\n+      function To_Array return Address_Info_Array is\n+         Result : Address_Info_Array (1 .. 8);\n+\n+         procedure Unsupported;\n+         --  Calls Unknown callback if defiend\n+\n+         -----------------\n+         -- Unsupported --\n+         -----------------\n+\n+         procedure Unsupported is\n+         begin\n+            if Unknown /= null then\n+               Unknown\n+                 (Integer (Iter.ai_family),\n+                  Integer (Iter.ai_socktype),\n+                  Integer (Iter.ai_protocol),\n+                  Integer (Iter.ai_addrlen));\n+            end if;\n+         end Unsupported;\n+\n+      --  Start of processing for To_Array\n+\n+      begin\n+         for J in Result'Range loop\n+            Look_For_Supported : loop\n+               if Iter = null then\n+                  return Result (1 .. J - 1);\n+               end if;\n+\n+               Result (J).Addr := Get_Address (Iter.ai_addr.all);\n+\n+               if Result (J).Addr.Family = Family_Unspec then\n+                  Unsupported;\n+               else\n+                  for M in Modes'Range loop\n+                     Found := False;\n+                     if Modes (M) = Iter.ai_socktype then\n+                        Result (J).Mode := M;\n+                        Found := True;\n+                        exit;\n+                     end if;\n+                  end loop;\n+\n+                  if Found then\n+                     for L in Levels'Range loop\n+                        if Levels (L) = Iter.ai_protocol then\n+                           Result (J).Level := L;\n+                           exit;\n+                        end if;\n+                     end loop;\n+\n+                     exit Look_For_Supported;\n+                  else\n+                     Unsupported;\n+                  end if;\n+               end if;\n+\n+               Iter := Iter.ai_next;\n+\n+               if Iter = null then\n+                  return Result (1 .. J - 1);\n+               end if;\n+            end loop Look_For_Supported;\n+\n+            Iter := Iter.ai_next;\n+         end loop;\n+\n+         return Result & To_Array;\n+      end To_Array;\n+\n+   --  Start of processing for Get_Address_Info\n+\n+   begin\n+      R := C_Getaddrinfo\n+        (Node    => (if Host = \"\" then null else N'Unchecked_Access),\n+         Service => S'Unchecked_Access,\n+         Hints   => Hints'Unchecked_Access,\n+         Res     => A'Access);\n+\n+      if R /= 0 then\n+         Raise_GAI_Error\n+           (R, Host & (if Service = \"\" then \"\" else ':' & Service));\n+      end if;\n+\n+      Iter := A;\n+\n+      return Result : constant Address_Info_Array := To_Array do\n+         C_Freeaddrinfo (A);\n+      end return;\n+   end Get_Address_Info;\n+\n+   ----------\n+   -- Sort --\n+   ----------\n+\n+   procedure Sort\n+     (Addr_Info : in out Address_Info_Array;\n+      Compare   : access function (Left, Right : Address_Info) return Boolean)\n+   is\n+      function Comp (Left, Right : Address_Info) return Boolean is\n+         (Compare (Left, Right));\n+      procedure Sorter is new Ada.Containers.Generic_Array_Sort\n+        (Positive, Address_Info, Address_Info_Array, Comp);\n+   begin\n+      Sorter (Addr_Info);\n+   end Sort;\n+\n+   ------------------------\n+   -- IPv6_TCP_Preferred --\n+   ------------------------\n+\n+   function IPv6_TCP_Preferred (Left, Right : Address_Info) return Boolean is\n+   begin\n+      pragma Assert (Family_Inet < Family_Inet6);\n+      --  To be sure that Family_Type enumeration has appropriate elements\n+      --  order\n+\n+      if Left.Addr.Family /= Right.Addr.Family then\n+         return Left.Addr.Family > Right.Addr.Family;\n+      end if;\n+\n+      pragma Assert (Socket_Stream < Socket_Datagram);\n+      --  To be sure that Mode_Type enumeration has appropriate elements order\n+\n+      return Left.Mode < Right.Mode;\n+   end IPv6_TCP_Preferred;\n+\n+   -------------------\n+   -- Get_Name_Info --\n+   -------------------\n+\n+   function Get_Name_Info\n+     (Addr         : Sock_Addr_Type;\n+      Numeric_Host : Boolean := False;\n+      Numeric_Serv : Boolean := False) return Host_Service\n+   is\n+      SA : aliased Sockaddr;\n+      H  : aliased C.char_array := (1 .. SOSC.NI_MAXHOST => C.nul);\n+      S  : aliased C.char_array := (1 .. SOSC.NI_MAXSERV => C.nul);\n+      RC : C.int;\n+   begin\n+      Set_Address (SA'Unchecked_Access, Addr);\n+\n+      RC := C_Getnameinfo\n+        (SA'Unchecked_Access, socklen_t (Lengths (Addr.Family)),\n+         H'Unchecked_Access, H'Length,\n+         S'Unchecked_Access, S'Length,\n+         (if Numeric_Host then SOSC.NI_NUMERICHOST else 0) +\n+             (if Numeric_Serv then SOSC.NI_NUMERICSERV else 0));\n+\n+      if RC /= 0 then\n+         Raise_GAI_Error (RC, Image (Addr));\n+      end if;\n+\n+      declare\n+         HR : constant String := C.To_Ada (H);\n+         SR : constant String := C.To_Ada (S);\n+      begin\n+         return (HR'Length, SR'Length, HR, SR);\n+      end;\n+   end Get_Name_Info;\n+\n    -------------------------\n    -- Get_Host_By_Address --\n    -------------------------\n@@ -969,17 +1182,33 @@ package body GNAT.Sockets is\n    is\n       pragma Unreferenced (Family);\n \n-      HA     : aliased In_Addr := To_In_Addr (Address);\n+      HA     : aliased In_Addr_Union (Address.Family);\n       Buflen : constant C.int := Netdb_Buffer_Size;\n       Buf    : aliased C.char_array (1 .. Netdb_Buffer_Size);\n       Res    : aliased Hostent;\n       Err    : aliased C.int;\n \n    begin\n+      case Address.Family is\n+         when Family_Inet =>\n+            HA.In4 := To_In_Addr (Address);\n+         when Family_Inet6 =>\n+            HA.In6 := To_In6_Addr (Address);\n+         when Family_Unspec =>\n+            return (0, 0, (1, \" \"), (1 .. 0 => (1, \" \")),\n+                    (1 .. 0 => No_Inet_Addr));\n+      end case;\n+\n       Netdb_Lock;\n \n-      if C_Gethostbyaddr (HA'Address, HA'Size / 8, SOSC.AF_INET,\n-                             Res'Access, Buf'Address, Buflen, Err'Access) /= 0\n+      if C_Gethostbyaddr\n+        (HA'Address,\n+         (case Address.Family is\n+             when Family_Inet => HA.In4'Size,\n+             when Family_Inet6 => HA.In6'Size,\n+             when Family_Unspec => 0) / 8,\n+         Families (Address.Family),\n+         Res'Access, Buf'Address, Buflen, Err'Access) /= 0\n       then\n          Netdb_Unlock;\n          Raise_Host_Error (Integer (Err), Image (Address));\n@@ -1007,7 +1236,7 @@ package body GNAT.Sockets is\n       --  If the given name actually is the string representation of\n       --  an IP address, use Get_Host_By_Address instead.\n \n-      if Is_IP_Address (Name) then\n+      if Is_IPv4_Address (Name) or else Is_IPv6_Address (Name) then\n          return Get_Host_By_Address (Inet_Addr (Name));\n       end if;\n \n@@ -1041,19 +1270,14 @@ package body GNAT.Sockets is\n    -------------------\n \n    function Get_Peer_Name (Socket : Socket_Type) return Sock_Addr_Type is\n-      Sin : aliased Sockaddr_In;\n+      Sin : aliased Sockaddr;\n       Len : aliased C.int := Sin'Size / 8;\n-      Res : Sock_Addr_Type (Family_Inet);\n-\n    begin\n       if C_Getpeername (C.int (Socket), Sin'Address, Len'Access) = Failure then\n          Raise_Socket_Error (Socket_Errno);\n       end if;\n \n-      To_Inet_Addr (Sin.Sin_Addr, Res.Addr);\n-      Res.Port := Port_Type (Network_To_Short (Sin.Sin_Port));\n-\n-      return Res;\n+      return Get_Address (Sin);\n    end Get_Peer_Name;\n \n    -------------------------\n@@ -1127,20 +1351,17 @@ package body GNAT.Sockets is\n    function Get_Socket_Name\n      (Socket : Socket_Type) return Sock_Addr_Type\n    is\n-      Sin  : aliased Sockaddr_In;\n-      Len  : aliased C.int := Sin'Size / 8;\n-      Res  : C.int;\n-      Addr : Sock_Addr_Type := No_Sock_Addr;\n-\n+      Sin : aliased Sockaddr;\n+      Len : aliased C.int := Sin'Size / 8;\n+      Res : C.int;\n    begin\n       Res := C_Getsockname (C.int (Socket), Sin'Address, Len'Access);\n \n-      if Res /= Failure then\n-         To_Inet_Addr (Sin.Sin_Addr, Addr.Addr);\n-         Addr.Port := Port_Type (Network_To_Short (Sin.Sin_Port));\n+      if Res = Failure then\n+         return No_Sock_Addr;\n       end if;\n \n-      return Addr;\n+      return Get_Address (Sin);\n    end Get_Socket_Name;\n \n    -----------------------\n@@ -1153,7 +1374,6 @@ package body GNAT.Sockets is\n       Name    : Option_Name;\n       Optname : Interfaces.C.int := -1) return Option_Type\n    is\n-      use SOSC;\n       use type C.unsigned;\n       use type C.unsigned_char;\n \n@@ -1180,8 +1400,7 @@ package body GNAT.Sockets is\n       end if;\n \n       case Name is\n-         when Multicast_Loop\n-            | Multicast_TTL\n+         when Multicast_TTL\n             | Receive_Packet_Info\n          =>\n             Len := V1'Size / 8;\n@@ -1192,11 +1411,16 @@ package body GNAT.Sockets is\n             | Error\n             | Generic_Option\n             | Keep_Alive\n-            | Multicast_If\n+            | Multicast_If_V4\n+            | Multicast_If_V6\n+            | Multicast_Loop_V4\n+            | Multicast_Loop_V6\n+            | Multicast_Hops\n             | No_Delay\n             | Receive_Buffer\n             | Reuse_Address\n             | Send_Buffer\n+            | IPv6_Only\n          =>\n             Len := V4'Size / 8;\n             Add := V4'Address;\n@@ -1208,18 +1432,23 @@ package body GNAT.Sockets is\n             --  struct timeval, but on Windows it is a milliseconds count in\n             --  a DWORD.\n \n-            if Target_OS = Windows then\n+            if Is_Windows then\n                Len := U4'Size / 8;\n                Add := U4'Address;\n-\n             else\n                Len := VT'Size / 8;\n                Add := VT'Address;\n             end if;\n \n-         when Add_Membership\n-            | Drop_Membership\n-            | Linger\n+         when Add_Membership_V4\n+            | Add_Membership_V6\n+            | Drop_Membership_V4\n+            | Drop_Membership_V6\n+         =>\n+            raise Socket_Error with\n+              \"Add/Drop membership valid only for Set_Socket_Option\";\n+\n+         when Linger\n          =>\n             Len := V8'Size / 8;\n             Add := V8'Address;\n@@ -1245,6 +1474,9 @@ package body GNAT.Sockets is\n             | Keep_Alive\n             | No_Delay\n             | Reuse_Address\n+            | Multicast_Loop_V4\n+            | Multicast_Loop_V6\n+            | IPv6_Only\n          =>\n             Opt.Enabled := (V4 /= 0);\n \n@@ -1263,27 +1495,35 @@ package body GNAT.Sockets is\n          when Error =>\n             Opt.Error := Resolve_Error (Integer (V4));\n \n-         when Add_Membership\n-            | Drop_Membership\n+         when Add_Membership_V4\n+            | Add_Membership_V6\n+            | Drop_Membership_V4\n+            | Drop_Membership_V6\n          =>\n-            To_Inet_Addr (To_In_Addr (V8 (V8'First)), Opt.Multicast_Address);\n-            To_Inet_Addr (To_In_Addr (V8 (V8'Last)), Opt.Local_Interface);\n+            --  No way to be here. Exception raised in the first case Name\n+            --  expression.\n+            null;\n \n-         when Multicast_If =>\n+         when Multicast_If_V4 =>\n             To_Inet_Addr (To_In_Addr (V4), Opt.Outgoing_If);\n \n+         when Multicast_If_V6 =>\n+            Opt.Outgoing_If_Index := Natural (V4);\n+\n          when Multicast_TTL =>\n             Opt.Time_To_Live := Integer (V1);\n \n-         when Multicast_Loop\n-            | Receive_Packet_Info\n+         when Multicast_Hops =>\n+            Opt.Hop_Limit := Integer (V4);\n+\n+         when Receive_Packet_Info\n          =>\n             Opt.Enabled := (V1 /= 0);\n \n          when Receive_Timeout\n             | Send_Timeout\n          =>\n-            if Target_OS = Windows then\n+            if Is_Windows then\n \n                --  Timeout is in milliseconds, actual value is 500 ms +\n                --  returned value (unless it is 0).\n@@ -1324,78 +1564,34 @@ package body GNAT.Sockets is\n    -- Image --\n    -----------\n \n-   function Image\n-     (Val : Inet_Addr_Bytes;\n-      Hex : Boolean := False) return String\n-   is\n-      --  The largest Inet_Addr_Comp_Type image occurs with IPv4. It\n-      --  has at most a length of 3 plus one '.' character.\n-\n-      Buffer    : String (1 .. 4 * Val'Length);\n-      Length    : Natural := 1;\n-      Separator : Character;\n-\n-      procedure Img10 (V : Inet_Addr_Comp_Type);\n-      --  Append to Buffer image of V in decimal format\n-\n-      procedure Img16 (V : Inet_Addr_Comp_Type);\n-      --  Append to Buffer image of V in hexadecimal format\n-\n-      -----------\n-      -- Img10 --\n-      -----------\n-\n-      procedure Img10 (V : Inet_Addr_Comp_Type) is\n-         Img : constant String := V'Img;\n-         Len : constant Natural := Img'Length - 1;\n-      begin\n-         Buffer (Length .. Length + Len - 1) := Img (2 .. Img'Last);\n-         Length := Length + Len;\n-      end Img10;\n-\n-      -----------\n-      -- Img16 --\n-      -----------\n-\n-      procedure Img16 (V : Inet_Addr_Comp_Type) is\n-      begin\n-         Buffer (Length)     := Hex_To_Char (Natural (V / 16) + 1);\n-         Buffer (Length + 1) := Hex_To_Char (Natural (V mod 16) + 1);\n-         Length := Length + 2;\n-      end Img16;\n-\n-   --  Start of processing for Image\n-\n-   begin\n-      Separator := (if Hex then ':' else '.');\n-\n-      for J in Val'Range loop\n-         if Hex then\n-            Img16 (Val (J));\n-         else\n-            Img10 (Val (J));\n-         end if;\n-\n-         if J /= Val'Last then\n-            Buffer (Length) := Separator;\n-            Length := Length + 1;\n-         end if;\n-      end loop;\n-\n-      return Buffer (1 .. Length - 1);\n-   end Image;\n-\n-   -----------\n-   -- Image --\n-   -----------\n-\n    function Image (Value : Inet_Addr_Type) return String is\n-   begin\n-      if Value.Family = Family_Inet then\n-         return Image (Inet_Addr_Bytes (Value.Sin_V4), Hex => False);\n-      else\n-         return Image (Inet_Addr_Bytes (Value.Sin_V6), Hex => True);\n+      use type CS.char_array_access;\n+      Size : constant socklen_t :=\n+        (case Value.Family is\n+            when Family_Inet   => 4 * Value.Sin_V4'Length,\n+            when Family_Inet6  => 6 * 5 + 4 * 4,\n+            --  1234:1234:1234:1234:1234:1234:123.123.123.123\n+            when Family_Unspec => 0);\n+      Dst : aliased C.char_array := (1 .. C.size_t (Size) => C.nul);\n+      Ia  : aliased In_Addr_Union (Value.Family);\n+   begin\n+      case Value.Family is\n+         when Family_Inet6 =>\n+            Ia.In6 := To_In6_Addr (Value);\n+         when Family_Inet =>\n+            Ia.In4 := To_In_Addr (Value);\n+         when Family_Unspec =>\n+            return \"\";\n+      end case;\n+\n+      if Inet_Ntop\n+        (Families (Value.Family), Ia'Address,\n+         Dst'Unchecked_Access, Size) = null\n+      then\n+         Raise_Socket_Error (Socket_Errno);\n       end if;\n+\n+      return C.To_Ada (Dst);\n    end Image;\n \n    -----------\n@@ -1404,8 +1600,10 @@ package body GNAT.Sockets is\n \n    function Image (Value : Sock_Addr_Type) return String is\n       Port : constant String := Value.Port'Img;\n+      function Ipv6_Brackets (S : String) return String is\n+        (if Value.Family = Family_Inet6 then \"[\" & S & \"]\" else S);\n    begin\n-      return Image (Value.Addr) & ':' & Port (2 .. Port'Last);\n+      return Ipv6_Brackets (Image (Value.Addr)) & ':' & Port (2 .. Port'Last);\n    end Image;\n \n    -----------\n@@ -1456,10 +1654,11 @@ package body GNAT.Sockets is\n       use Interfaces.C;\n \n       Img    : aliased char_array := To_C (Image);\n-      Addr   : aliased C.int;\n       Res    : C.int;\n       Result : Inet_Addr_Type;\n-\n+      IPv6   : constant Boolean := Is_IPv6_Address (Image);\n+      Ia     : aliased In_Addr_Union\n+                 (if IPv6 then Family_Inet6 else Family_Inet);\n    begin\n       --  Special case for an empty Image as on some platforms (e.g. Windows)\n       --  calling Inet_Addr(\"\") will not return an error.\n@@ -1468,7 +1667,9 @@ package body GNAT.Sockets is\n          Raise_Socket_Error (SOSC.EINVAL);\n       end if;\n \n-      Res := Inet_Pton (SOSC.AF_INET, Img'Address, Addr'Address);\n+      Res := Inet_Pton\n+        ((if IPv6 then SOSC.AF_INET6 else SOSC.AF_INET), Img'Address,\n+         Ia'Address);\n \n       if Res < 0 then\n          Raise_Socket_Error (Socket_Errno);\n@@ -1477,7 +1678,12 @@ package body GNAT.Sockets is\n          Raise_Socket_Error (SOSC.EINVAL);\n       end if;\n \n-      To_Inet_Addr (To_In_Addr (Addr), Result);\n+      if IPv6 then\n+         To_Inet_Addr (Ia.In6, Result);\n+      else\n+         To_Inet_Addr (Ia.In4, Result);\n+      end if;\n+\n       return Result;\n    end Inet_Addr;\n \n@@ -1527,6 +1733,16 @@ package body GNAT.Sockets is\n       null;\n    end Initialize;\n \n+   ----------------\n+   -- Is_Windows --\n+   ----------------\n+\n+   function Is_Windows return Boolean is\n+      use SOSC;\n+   begin\n+      return Target_OS = Windows;\n+   end Is_Windows;\n+\n    --------------\n    -- Is_Empty --\n    --------------\n@@ -1536,11 +1752,56 @@ package body GNAT.Sockets is\n       return Item.Last = No_Socket;\n    end Is_Empty;\n \n-   -------------------\n-   -- Is_IP_Address --\n-   -------------------\n+   ---------------------\n+   -- Is_IPv6_Address --\n+   ---------------------\n \n-   function Is_IP_Address (Name : String) return Boolean is\n+   function Is_IPv6_Address (Name : String) return Boolean is\n+      Prev_Colon   : Natural := 0;\n+      Double_Colon : Boolean := False;\n+      Colons       : Natural := 0;\n+   begin\n+      for J in Name'Range loop\n+         if Name (J) = ':' then\n+            Colons := Colons + 1;\n+\n+            if Prev_Colon > 0 and then J = Prev_Colon + 1 then\n+               if Double_Colon then\n+                  --  Only one double colon allowed\n+                  return False;\n+               end if;\n+\n+               Double_Colon := True;\n+\n+            elsif J = Name'Last then\n+               --  Single colon at the end is not allowed\n+               return False;\n+            end if;\n+\n+            Prev_Colon := J;\n+\n+         elsif Prev_Colon = Name'First then\n+            --  Single colon at start is not allowed\n+            return False;\n+\n+         elsif Name (J) = '.' then\n+            return Prev_Colon > 0\n+              and then Is_IPv4_Address (Name (Prev_Colon + 1 .. Name'Last));\n+\n+         elsif Name (J) not in '0' .. '9' | 'A' .. 'F' | 'a' .. 'f' then\n+            return False;\n+\n+         end if;\n+      end loop;\n+\n+      return Colons <= 7;\n+   end Is_IPv6_Address;\n+\n+   ---------------------\n+   -- Is_IPv4_Address --\n+   ---------------------\n+\n+   function Is_IPv4_Address (Name : String) return Boolean is\n       Dots : Natural := 0;\n \n    begin\n@@ -1571,7 +1832,7 @@ package body GNAT.Sockets is\n       end loop;\n \n       return Dots in 1 .. 3;\n-   end Is_IP_Address;\n+   end Is_IPv4_Address;\n \n    -------------\n    -- Is_Open --\n@@ -1760,13 +2021,6 @@ package body GNAT.Sockets is\n    ----------------------\n \n    procedure Raise_Host_Error (H_Error : Integer; Name : String) is\n-      function Dedot (Value : String) return String is\n-        (if Value /= \"\" and then Value (Value'Last) = '.' then\n-            Value (Value'First .. Value'Last - 1)\n-         else\n-            Value);\n-      --  Removes dot at the end of error message\n-\n    begin\n       raise Host_Error with\n         Err_Code_Image (H_Error)\n@@ -1863,7 +2117,7 @@ package body GNAT.Sockets is\n       Flags  : Request_Flag_Type := No_Request_Flag)\n    is\n       Res : C.int;\n-      Sin : aliased Sockaddr_In;\n+      Sin : aliased Sockaddr;\n       Len : aliased C.int := Sin'Size / 8;\n \n    begin\n@@ -1882,8 +2136,7 @@ package body GNAT.Sockets is\n \n       Last := Last_Index (First => Item'First, Count => size_t (Res));\n \n-      To_Inet_Addr (Sin.Sin_Addr, From.Addr);\n-      From.Port := Port_Type (Network_To_Short (Sin.Sin_Port));\n+      From := Get_Address (Sin);\n    end Receive_Socket;\n \n    --------------------\n@@ -2142,17 +2395,13 @@ package body GNAT.Sockets is\n    is\n       Res  : C.int;\n \n-      Sin  : aliased Sockaddr_In;\n+      Sin  : aliased Sockaddr;\n       C_To : System.Address;\n       Len  : C.int;\n \n    begin\n       if To /= null then\n-         Set_Family  (Sin.Sin_Family, To.Family);\n-         Set_Address (Sin'Unchecked_Access, To_In_Addr (To.Addr));\n-         Set_Port\n-           (Sin'Unchecked_Access,\n-            Short_To_Network (C.unsigned_short (To.Port)));\n+         Set_Address (Sin'Unchecked_Access, To.all);\n          C_To := Sin'Address;\n          Len := Sin'Size / 8;\n \n@@ -2294,9 +2543,9 @@ package body GNAT.Sockets is\n       Level  : Level_Type := Socket_Level;\n       Option : Option_Type)\n    is\n-      use SOSC;\n       use type C.unsigned;\n \n+      MR  : aliased IPV6_Mreq;\n       V8  : aliased Two_Ints;\n       V4  : aliased C.int;\n       U4  : aliased C.unsigned;\n@@ -2318,6 +2567,9 @@ package body GNAT.Sockets is\n             | Keep_Alive\n             | No_Delay\n             | Reuse_Address\n+            | Multicast_Loop_V4\n+            | Multicast_Loop_V6\n+            | IPv6_Only\n          =>\n             V4  := C.int (Boolean'Pos (Option.Enabled));\n             Len := V4'Size / 8;\n@@ -2346,26 +2598,42 @@ package body GNAT.Sockets is\n             Len := V4'Size / 8;\n             Add := V4'Address;\n \n-         when Add_Membership\n-            | Drop_Membership\n+         when Add_Membership_V4\n+            | Drop_Membership_V4\n          =>\n             V8 (V8'First) := To_Int (To_In_Addr (Option.Multicast_Address));\n             V8 (V8'Last)  := To_Int (To_In_Addr (Option.Local_Interface));\n             Len := V8'Size / 8;\n             Add := V8'Address;\n \n-         when Multicast_If =>\n+         when Add_Membership_V6\n+            | Drop_Membership_V6 =>\n+            MR.ipv6mr_multiaddr := To_In6_Addr (Option.Multicast_Address);\n+            MR.ipv6mr_interface := C.unsigned (Option.Interface_Index);\n+            Len := MR'Size / 8;\n+            Add := MR'Address;\n+\n+         when Multicast_If_V4 =>\n             V4  := To_Int (To_In_Addr (Option.Outgoing_If));\n             Len := V4'Size / 8;\n             Add := V4'Address;\n \n+         when Multicast_If_V6 =>\n+            V4  := C.int (Option.Outgoing_If_Index);\n+            Len := V4'Size / 8;\n+            Add := V4'Address;\n+\n          when Multicast_TTL =>\n             V1  := C.unsigned_char (Option.Time_To_Live);\n             Len := V1'Size / 8;\n             Add := V1'Address;\n \n-         when Multicast_Loop\n-            | Receive_Packet_Info\n+         when Multicast_Hops =>\n+            V4  := C.int (Option.Hop_Limit);\n+            Len := V4'Size / 8;\n+            Add := V4'Address;\n+\n+         when Receive_Packet_Info\n          =>\n             V1  := C.unsigned_char (Boolean'Pos (Option.Enabled));\n             Len := V1'Size / 8;\n@@ -2374,7 +2642,7 @@ package body GNAT.Sockets is\n          when Receive_Timeout\n             | Send_Timeout\n          =>\n-            if Target_OS = Windows then\n+            if Is_Windows then\n \n                --  On Windows, the timeout is a DWORD in milliseconds, and\n                --  the actual timeout is 500 ms + the given value (unless it\n@@ -2420,28 +2688,6 @@ package body GNAT.Sockets is\n       end if;\n    end Set_Socket_Option;\n \n-   ----------------------\n-   -- Short_To_Network --\n-   ----------------------\n-\n-   function Short_To_Network (S : C.unsigned_short) return C.unsigned_short is\n-      use type C.unsigned_short;\n-\n-   begin\n-      --  Big-endian case. No conversion needed. On these platforms, htons()\n-      --  defaults to a null procedure.\n-\n-      if Default_Bit_Order = High_Order_First then\n-         return S;\n-\n-      --  Little-endian case. We must swap the high and low bytes of this\n-      --  short to make the port number network compliant.\n-\n-      else\n-         return (S / 256) + (S mod 256) * 256;\n-      end if;\n-   end Short_To_Network;\n-\n    ---------------------\n    -- Shutdown_Socket --\n    ---------------------\n@@ -2538,15 +2784,18 @@ package body GNAT.Sockets is\n    -------------------\n \n    function To_Host_Entry (E : Hostent_Access) return Host_Entry_Type is\n-      use type C.size_t;\n-\n       Aliases_Count, Addresses_Count : Natural;\n \n-      --  H_Length is not used because it is currently only ever set to 4, as\n-      --  we only handle the case of H_Addrtype being AF_INET.\n+      Family : constant Family_Type :=\n+                 (case Hostent_H_Addrtype (E) is\n+                     when SOSC.AF_INET  => Family_Inet,\n+                     when SOSC.AF_INET6 => Family_Inet6,\n+                     when others        => Family_Unspec);\n+\n+      Addr_Len : constant C.size_t := C.size_t (Hostent_H_Length (E));\n \n    begin\n-      if Hostent_H_Addrtype (E) /= SOSC.AF_INET then\n+      if Family = Family_Unspec then\n          Raise_Socket_Error (SOSC.EPFNOSUPPORT);\n       end if;\n \n@@ -2574,61 +2823,35 @@ package body GNAT.Sockets is\n \n          for J in Result.Addresses'Range loop\n             declare\n-               Addr : In_Addr;\n+               Ia : In_Addr_Union (Family);\n \n                --  Hostent_H_Addr (E, <index>) may return an address that is\n                --  not correctly aligned for In_Addr, so we need to use\n                --  an intermediate copy operation on a type with an alignment\n                --  of 1 to recover the value.\n \n-               subtype Addr_Buf_T is C.char_array (1 .. Addr'Size / 8);\n+               subtype Addr_Buf_T is C.char_array (1 .. Addr_Len);\n                Unaligned_Addr : Addr_Buf_T;\n                for Unaligned_Addr'Address\n                  use Hostent_H_Addr (E, C.int (J - Result.Addresses'First));\n                pragma Import (Ada, Unaligned_Addr);\n \n                Aligned_Addr : Addr_Buf_T;\n-               for Aligned_Addr'Address use Addr'Address;\n+               for Aligned_Addr'Address use Ia'Address;\n                pragma Import (Ada, Aligned_Addr);\n \n             begin\n                Aligned_Addr := Unaligned_Addr;\n-               To_Inet_Addr (Addr, Result.Addresses (J));\n+               if Family = Family_Inet6 then\n+                  To_Inet_Addr (Ia.In6, Result.Addresses (J));\n+               else\n+                  To_Inet_Addr (Ia.In4, Result.Addresses (J));\n+               end if;\n             end;\n          end loop;\n       end return;\n    end To_Host_Entry;\n \n-   ----------------\n-   -- To_In_Addr --\n-   ----------------\n-\n-   function To_In_Addr (Addr : Inet_Addr_Type) return In_Addr is\n-   begin\n-      if Addr.Family = Family_Inet then\n-         return (S_B1 => C.unsigned_char (Addr.Sin_V4 (1)),\n-                 S_B2 => C.unsigned_char (Addr.Sin_V4 (2)),\n-                 S_B3 => C.unsigned_char (Addr.Sin_V4 (3)),\n-                 S_B4 => C.unsigned_char (Addr.Sin_V4 (4)));\n-      end if;\n-\n-      raise Socket_Error with \"IPv6 not supported\";\n-   end To_In_Addr;\n-\n-   ------------------\n-   -- To_Inet_Addr --\n-   ------------------\n-\n-   procedure To_Inet_Addr\n-     (Addr   : In_Addr;\n-      Result : out Inet_Addr_Type) is\n-   begin\n-      Result.Sin_V4 (1) := Inet_Addr_Comp_Type (Addr.S_B1);\n-      Result.Sin_V4 (2) := Inet_Addr_Comp_Type (Addr.S_B2);\n-      Result.Sin_V4 (3) := Inet_Addr_Comp_Type (Addr.S_B3);\n-      Result.Sin_V4 (4) := Inet_Addr_Comp_Type (Addr.S_B4);\n-   end To_Inet_Addr;\n-\n    ------------\n    -- To_Int --\n    ------------\n@@ -2825,7 +3048,8 @@ package body GNAT.Sockets is\n    is\n      (case Family is\n          when Family_Inet => (Family_Inet, Bytes),\n-         when Family_Inet6 => (Family_Inet6, Bytes));\n+         when Family_Inet6 => (Family_Inet6, Bytes),\n+         when Family_Unspec => (Family => Family_Unspec));\n \n    ---------------\n    -- Get_Bytes --\n@@ -2834,7 +3058,8 @@ package body GNAT.Sockets is\n    function Get_Bytes (Addr : Inet_Addr_Type) return Inet_Addr_Bytes is\n      (case Addr.Family is\n          when Family_Inet => Addr.Sin_V4,\n-         when Family_Inet6 => Addr.Sin_V6);\n+         when Family_Inet6 => Addr.Sin_V6,\n+         when Family_Unspec => (1 .. 0 => 0));\n \n    ----------\n    -- Mask --"}, {"sha": "9ba12878f4ccc8b8199f5f8596377165e965eda8", "filename": "gcc/ada/libgnat/g-socket.ads", "status": "modified", "additions": 181, "deletions": 26, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/759f1648029eef1fde1c66e342b033438c44e3b5/gcc%2Fada%2Flibgnat%2Fg-socket.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/759f1648029eef1fde1c66e342b033438c44e3b5/gcc%2Fada%2Flibgnat%2Fg-socket.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-socket.ads?ref=759f1648029eef1fde1c66e342b033438c44e3b5", "patch": "@@ -469,13 +469,17 @@ package GNAT.Sockets is\n    --  Return a file descriptor to be used by external subprograms. This is\n    --  useful for C functions that are not yet interfaced in this package.\n \n-   type Family_Type is (Family_Inet, Family_Inet6);\n+   type Family_Type is (Family_Inet, Family_Inet6, Family_Unspec);\n    --  Address family (or protocol family) identifies the communication domain\n    --  and groups protocols with similar address formats.\n+   --  The order of the enumeration elements should not be changed unilaterally\n+   --  because the IPv6_TCP_Preferred routine rely on it.\n \n    type Mode_Type is (Socket_Stream, Socket_Datagram);\n    --  Stream sockets provide connection-oriented byte streams. Datagram\n    --  sockets support unreliable connectionless message based communication.\n+   --  The order of the enumeration elements should not be changed unilaterally\n+   --  because the IPv6_TCP_Preferred routine rely on it.\n \n    type Shutmode_Type is (Shut_Read, Shut_Write, Shut_Read_Write);\n    --  When a process closes a socket, the policy is to retain any data queued\n@@ -497,8 +501,8 @@ package GNAT.Sockets is\n    type Inet_Addr_Comp_Type is mod 2 ** 8;\n    --  Octet for Internet address\n \n-   Inet_Addr_Bytes_Length : constant array (Family_Type) of Positive :=\n-     (Family_Inet => 4, Family_Inet6 => 16);\n+   Inet_Addr_Bytes_Length : constant array (Family_Type) of Natural :=\n+     (Family_Inet => 4, Family_Inet6 => 16, Family_Unspec => 0);\n \n    type Inet_Addr_Bytes is array (Natural range <>) of Inet_Addr_Comp_Type;\n \n@@ -517,24 +521,61 @@ package GNAT.Sockets is\n \n          when Family_Inet6 =>\n             Sin_V6 : Inet_Addr_V6_Type := (others => 0);\n+\n+         when Family_Unspec =>\n+            null;\n+\n       end case;\n    end record;\n \n    --  An Internet address depends on an address family (IPv4 contains 4 octets\n-   --  and IPv6 contains 16 octets). Any_Inet_Addr is a special value treated\n-   --  like a wildcard enabling all addresses. No_Inet_Addr provides a special\n-   --  value to denote uninitialized inet addresses.\n+   --  and IPv6 contains 16 octets).\n \n    Any_Inet_Addr       : constant Inet_Addr_Type;\n+   --  Wildcard enabling all addresses to use with bind\n+\n+   Any_Inet6_Addr      : constant Inet_Addr_Type;\n+   --  Idem for IPV6 socket\n+\n    No_Inet_Addr        : constant Inet_Addr_Type;\n+   --  Uninitialized inet address\n+\n+   Unspecified_Addr    : constant Inet_Addr_Type;\n+   --  Unspecified address. Unlike of No_Inet_Addr the constraint is\n+   --  Family_Unspec for this constant.\n+\n    Broadcast_Inet_Addr : constant Inet_Addr_Type;\n+   --  Broadcast destination address in the current network\n+\n    Loopback_Inet_Addr  : constant Inet_Addr_Type;\n+   --  Loopback address to the local host\n+\n+   Loopback_Inet6_Addr : constant Inet_Addr_Type;\n+   --  IPv6 Loopback address to the local host\n+\n+   --  Useful constants for multicast addresses\n+\n+   Unspecified_Group_Inet_Addr  : constant Inet_Addr_Type;\n+   --  IPv4 multicast mask with prefix length 4\n+\n+   Unspecified_Group_Inet6_Addr : constant Inet_Addr_Type;\n+   --  IPv6 multicast mask with prefix length 16\n+\n+   All_Hosts_Group_Inet_Addr    : constant Inet_Addr_Type;\n+   --  Multicast group addresses all hosts on the same network segment\n+\n+   All_Hosts_Group_Inet6_Addr   : constant Inet_Addr_Type;\n+   --  Idem for IPv6 protocol\n \n-   --  Useful constants for IPv4 multicast addresses\n+   All_Routers_Group_Inet_Addr  : constant Inet_Addr_Type;\n+   --  Multicast group addresses all routers on the same network segment\n \n-   Unspecified_Group_Inet_Addr : constant Inet_Addr_Type;\n-   All_Hosts_Group_Inet_Addr   : constant Inet_Addr_Type;\n-   All_Routers_Group_Inet_Addr : constant Inet_Addr_Type;\n+   All_Routers_Group_Inet6_Addr : constant Inet_Addr_Type;\n+   --  Idem for IPv6 protocol\n+\n+   IPv4_To_IPv6_Prefix : constant Inet_Addr_Bytes :=\n+     (1 .. 10 => 0, 11 .. 12 => 255);\n+   --  Prefix for IPv4 mapped to IPv6 addresses\n \n    --  Functions to handle masks and prefixes\n \n@@ -563,18 +604,24 @@ package GNAT.Sockets is\n    --  for uninitialized socket addresses.\n \n    No_Sock_Addr : constant Sock_Addr_Type;\n+   --  Uninitialized socket address\n+\n+   function Is_IPv4_Address (Name : String) return Boolean;\n+   --  Return true when Name is an IPv4 address in dotted quad notation\n+\n+   function Is_IPv6_Address (Name : String) return Boolean;\n+   --  Return true when Name is an IPv6 address in numeric format\n \n    function Image (Value : Inet_Addr_Type) return String;\n    --  Return an image of an Internet address. IPv4 notation consists in 4\n    --  octets in decimal format separated by dots. IPv6 notation consists in\n-   --  16 octets in hexadecimal format separated by colons (and possibly\n-   --  dots).\n+   --  8 hextets in hexadecimal format separated by colons.\n \n    function Image (Value : Sock_Addr_Type) return String;\n    --  Return inet address image and port image separated by a colon\n \n    function Inet_Addr (Image : String) return Inet_Addr_Type;\n-   --  Convert address image from numbers-and-dots notation into an\n+   --  Convert address image from numbers-dots-and-colons notation into an\n    --  inet address.\n \n    --  Host entries provide complete information on a given host: the official\n@@ -723,6 +770,7 @@ package GNAT.Sockets is\n    type Level_Type is\n      (Socket_Level,\n       IP_Protocol_For_IP_Level,\n+      IP_Protocol_For_IPv6_Level,\n       IP_Protocol_For_UDP_Level,\n       IP_Protocol_For_TCP_Level);\n \n@@ -740,18 +788,29 @@ package GNAT.Sockets is\n       Linger,              -- Shutdown wait for msg to be sent or timeout occur\n       Error,               -- Get and clear the pending socket error\n       No_Delay,            -- Do not delay send to coalesce data (TCP_NODELAY)\n-      Add_Membership,      -- Join a multicast group\n-      Drop_Membership,     -- Leave a multicast group\n-      Multicast_If,        -- Set default out interface for multicast packets\n+      Add_Membership_V4,   -- Join a multicast group\n+      Add_Membership_V6,   -- Idem for IPv6 socket\n+      Drop_Membership_V4,  -- Leave a multicast group\n+      Drop_Membership_V6,  -- Idem for IPv6 socket\n+      Multicast_If_V4,     -- Set default out interface for multicast packets\n+      Multicast_If_V6,     -- Idem for IPv6 socket\n+      Multicast_Loop_V4,   -- Sent multicast packets are looped to local socket\n+      Multicast_Loop_V6,   -- Idem for IPv6 socket\n       Multicast_TTL,       -- Set the time-to-live of sent multicast packets\n-      Multicast_Loop,      -- Sent multicast packets are looped to local socket\n+      Multicast_Hops,      -- Set the multicast hop limit for the IPv6 socket\n       Receive_Packet_Info, -- Receive low level packet info as ancillary data\n       Send_Timeout,        -- Set timeout value for output\n       Receive_Timeout,     -- Set timeout value for input\n+      IPv6_Only,           -- Restricted to IPv6 communications only\n       Busy_Polling);       -- Set busy polling mode\n    subtype Specific_Option_Name is\n      Option_Name range Keep_Alive .. Option_Name'Last;\n \n+   Add_Membership  : Option_Name renames Add_Membership_V4;\n+   Drop_Membership : Option_Name renames Drop_Membership_V4;\n+   Multicast_If    : Option_Name renames Multicast_If_V4;\n+   Multicast_Loop  : Option_Name renames Multicast_Loop_V4;\n+\n    type Option_Type (Name : Option_Name := Keep_Alive) is record\n       case Name is\n          when Generic_Option =>\n@@ -764,7 +823,9 @@ package GNAT.Sockets is\n               Linger              |\n               No_Delay            |\n               Receive_Packet_Info |\n-              Multicast_Loop      =>\n+              IPv6_Only           |\n+              Multicast_Loop_V4   |\n+              Multicast_Loop_V6   =>\n             Enabled : Boolean;\n \n             case Name is\n@@ -784,17 +845,31 @@ package GNAT.Sockets is\n          when Error           =>\n             Error : Error_Type;\n \n-         when Add_Membership  |\n-              Drop_Membership =>\n+         when Add_Membership_V4  |\n+              Add_Membership_V6  |\n+              Drop_Membership_V4 |\n+              Drop_Membership_V6 =>\n             Multicast_Address : Inet_Addr_Type;\n-            Local_Interface   : Inet_Addr_Type;\n+            case Name is\n+               when Add_Membership_V4  |\n+                    Drop_Membership_V4 =>\n+                  Local_Interface : Inet_Addr_Type;\n+               when others =>\n+                  Interface_Index : Natural;\n+            end case;\n \n-         when Multicast_If    =>\n+         when Multicast_If_V4 =>\n             Outgoing_If : Inet_Addr_Type;\n \n-         when Multicast_TTL   =>\n+         when Multicast_If_V6 =>\n+            Outgoing_If_Index : Natural;\n+\n+         when Multicast_TTL  =>\n             Time_To_Live : Natural;\n \n+         when Multicast_Hops =>\n+            Hop_Limit : Integer range -1 .. 255;\n+\n          when Send_Timeout |\n               Receive_Timeout =>\n             Timeout : Timeval_Duration;\n@@ -865,10 +940,76 @@ package GNAT.Sockets is\n \n    type Vector_Type is array (Integer range <>) of Vector_Element;\n \n+   type Address_Info is record\n+      Addr  : Sock_Addr_Type;\n+      Mode  : Mode_Type  := Socket_Stream;\n+      Level : Level_Type := IP_Protocol_For_IP_Level;\n+   end record;\n+\n+   type Address_Info_Array is array (Positive range <>) of Address_Info;\n+\n+   function Get_Address_Info\n+     (Host         : String;\n+      Service      : String;\n+      Family       : Family_Type := Family_Unspec;\n+      Mode         : Mode_Type   := Socket_Stream;\n+      Level        : Level_Type  := IP_Protocol_For_IP_Level;\n+      Numeric_Host : Boolean     := False;\n+      Passive      : Boolean     := False;\n+      Unknown      : access procedure\n+        (Family, Mode, Level, Length : Integer) := null)\n+      return Address_Info_Array;\n+   --  Returns available addresses for the Host and Service names.\n+   --  If Family is Family_Unspec, all available protocol families returned.\n+   --  Service is the name of service as defined in /etc/services or port\n+   --  number in string representation.\n+   --  If Unknown procedure access specified it will be called in case of\n+   --  unknown family found.\n+   --  Numeric_Host flag suppresses any potentially lengthy network host\n+   --  address lookups, and Host have to represent numerical network address in\n+   --  this case.\n+   --  If Passive is True and Host is empty then the returned socket addresses\n+   --  will be suitable for binding a socket that will accept connections.\n+   --  The returned socket address will contain  the  \"wildcard  address\".\n+   --  The wildcard address is used by applications (typically servers) that\n+   --  intend to accept connections on any of the hosts's network addresses.\n+   --  If Host is not empty, then the Passive flag is ignored.\n+   --  If Passive is False, then the returned socket addresses will be suitable\n+   --  for use with connect, sendto, or sendmsg.  If Host is empty, then the\n+   --  network address will be set  to  the  loopback  interface  address;\n+   --  this is used by applications that intend to communicate with peers\n+   --  running on the same host.\n+\n+   procedure Sort\n+     (Addr_Info : in out Address_Info_Array;\n+      Compare   : access function (Left, Right : Address_Info) return Boolean);\n+   --  Sort address info array in order defined by compare function\n+\n+   function IPv6_TCP_Preferred (Left, Right : Address_Info) return Boolean;\n+   --  To use with Sort to order where IPv6 and TCP addresses first\n+\n+   type Host_Service (Host_Length, Service_Length : Natural) is record\n+      Host    : String (1 .. Host_Length);\n+      Service : String (1 .. Service_Length);\n+   end record;\n+\n+   function Get_Name_Info\n+     (Addr         : Sock_Addr_Type;\n+      Numeric_Host : Boolean := False;\n+      Numeric_Serv : Boolean := False) return Host_Service;\n+   --  Returns host and service names by the address and port.\n+   --  If Numeric_Host is True, then the numeric form of the hostname is\n+   --  returned. When Numeric_Host is False, this will still happen in case the\n+   --  host name cannot be determined.\n+   --  If Numenric_Serv is True, then the numeric form of the service address\n+   --  (port number) is returned.  When Numenric_Serv is False, this will still\n+   --  happen in case the service's name cannot be determined.\n+\n    procedure Create_Socket\n      (Socket : out Socket_Type;\n       Family : Family_Type := Family_Inet;\n-      Mode   : Mode_Type   := Socket_Stream);\n+      Mode   : Mode_Type   := Socket_Stream;\n+      Level  : Level_Type  := IP_Protocol_For_IP_Level);\n    --  Create an endpoint for communication. Raises Socket_Error on error\n \n    procedure Accept_Socket\n@@ -1265,12 +1406,19 @@ private\n \n    Any_Inet_Addr       : constant Inet_Addr_Type :=\n                            (Family_Inet, (others => 0));\n+   Any_Inet6_Addr      : constant Inet_Addr_Type :=\n+                           (Family_Inet6, (others => 0));\n    No_Inet_Addr        : constant Inet_Addr_Type :=\n                            (Family_Inet, (others => 0));\n+   Unspecified_Addr    : constant Inet_Addr_Type :=\n+                           (Family => Family_Unspec);\n    Broadcast_Inet_Addr : constant Inet_Addr_Type :=\n                            (Family_Inet, (others => 255));\n    Loopback_Inet_Addr  : constant Inet_Addr_Type :=\n                            (Family_Inet, (127, 0, 0, 1));\n+   Loopback_Inet6_Addr : constant Inet_Addr_Type :=\n+                           (Family_Inet6,\n+                            (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1));\n \n    Unspecified_Group_Inet_Addr : constant Inet_Addr_Type :=\n                                    (Family_Inet, (224, 0, 0, 0));\n@@ -1279,6 +1427,13 @@ private\n    All_Routers_Group_Inet_Addr : constant Inet_Addr_Type :=\n                                    (Family_Inet, (224, 0, 0, 2));\n \n+   Unspecified_Group_Inet6_Addr : constant Inet_Addr_Type :=\n+     (Family_Inet6, (255, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0));\n+   All_Hosts_Group_Inet6_Addr   : constant Inet_Addr_Type :=\n+     (Family_Inet6, (255, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1));\n+   All_Routers_Group_Inet6_Addr : constant Inet_Addr_Type :=\n+     (Family_Inet6, (255, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2));\n+\n    No_Sock_Addr : constant Sock_Addr_Type := (Family_Inet, No_Inet_Addr, 0);\n \n    Max_Name_Length : constant := 64;\n@@ -1291,8 +1446,8 @@ private\n    end record;\n    --  We need fixed strings to avoid access types in host entry type\n \n-   type Name_Array is array (Natural range <>) of Name_Type;\n-   type Inet_Addr_Array is array (Natural range <>) of Inet_Addr_Type;\n+   type Name_Array is array (Positive range <>) of Name_Type;\n+   type Inet_Addr_Array is array (Positive range <>) of Inet_Addr_Type;\n \n    type Host_Entry_Type (Aliases_Length, Addresses_Length : Natural) is record\n       Official  : Name_Type;"}, {"sha": "1dced107dee68ec76bdf31f70ab3c846e9269c87", "filename": "gcc/ada/libgnat/g-sothco.adb", "status": "modified", "additions": 122, "deletions": 11, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/759f1648029eef1fde1c66e342b033438c44e3b5/gcc%2Fada%2Flibgnat%2Fg-sothco.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/759f1648029eef1fde1c66e342b033438c44e3b5/gcc%2Fada%2Flibgnat%2Fg-sothco.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-sothco.adb?ref=759f1648029eef1fde1c66e342b033438c44e3b5", "patch": "@@ -36,13 +36,52 @@ package body GNAT.Sockets.Thin_Common is\n    -----------------\n \n    procedure Set_Address\n-     (Sin     : Sockaddr_In_Access;\n-      Address : In_Addr)\n+     (Sin     : Sockaddr_Access;\n+      Address : Sock_Addr_Type)\n    is\n    begin\n-      Sin.Sin_Addr := Address;\n+      Set_Family (Sin.Sin_Family, Address.Family);\n+      Sin.Sin_Port := Short_To_Network (C.unsigned_short (Address.Port));\n+\n+      case Address.Family is\n+         when Family_Inet =>\n+            Sin.Sin_Addr := To_In_Addr (Address.Addr);\n+         when Family_Inet6 =>\n+            Sin.Sin6_Addr := To_In6_Addr (Address.Addr);\n+            Sin.Sin6_Scope_Id := 0;\n+         when Family_Unspec =>\n+            null;\n+      end case;\n    end Set_Address;\n \n+   -----------------\n+   -- Get_Address --\n+   -----------------\n+\n+   function Get_Address (Sin : Sockaddr) return Sock_Addr_Type is\n+      Family : constant C.unsigned_short :=\n+        (if SOSC.Has_Sockaddr_Len = 0 then Sin.Sin_Family.Short_Family\n+         else C.unsigned_short (Sin.Sin_Family.Char_Family));\n+      Result : Sock_Addr_Type\n+        (case Family is\n+            when SOSC.AF_INET6 => Family_Inet6,\n+            when SOSC.AF_INET  => Family_Inet,\n+            when others        => Family_Unspec);\n+   begin\n+      Result.Port := Port_Type (Network_To_Short (Sin.Sin_Port));\n+\n+      case Result.Family is\n+         when Family_Inet =>\n+            To_Inet_Addr (Sin.Sin_Addr, Result.Addr);\n+         when Family_Inet6 =>\n+            To_Inet_Addr (Sin.Sin6_Addr, Result.Addr);\n+         when Family_Unspec =>\n+            Result.Addr := (Family => Family_Unspec);\n+      end case;\n+\n+      return Result;\n+   end Get_Address;\n+\n    ----------------\n    -- Set_Family --\n    ----------------\n@@ -62,16 +101,88 @@ package body GNAT.Sockets.Thin_Common is\n       end if;\n    end Set_Family;\n \n-   --------------\n-   -- Set_Port --\n-   --------------\n+   ----------------\n+   -- To_In_Addr --\n+   ----------------\n+\n+   function To_In_Addr (Addr : Inet_Addr_Type) return In_Addr is\n+   begin\n+      if Addr.Family = Family_Inet then\n+         return (S_B1 => C.unsigned_char (Addr.Sin_V4 (1)),\n+                 S_B2 => C.unsigned_char (Addr.Sin_V4 (2)),\n+                 S_B3 => C.unsigned_char (Addr.Sin_V4 (3)),\n+                 S_B4 => C.unsigned_char (Addr.Sin_V4 (4)));\n+      end if;\n+\n+      raise Socket_Error with \"IPv6 not supported\";\n+   end To_In_Addr;\n+\n+   ------------------\n+   -- To_Inet_Addr --\n+   ------------------\n+\n+   procedure To_Inet_Addr\n+     (Addr   : In_Addr;\n+      Result : out Inet_Addr_Type) is\n+   begin\n+      Result.Sin_V4 (1) := Inet_Addr_Comp_Type (Addr.S_B1);\n+      Result.Sin_V4 (2) := Inet_Addr_Comp_Type (Addr.S_B2);\n+      Result.Sin_V4 (3) := Inet_Addr_Comp_Type (Addr.S_B3);\n+      Result.Sin_V4 (4) := Inet_Addr_Comp_Type (Addr.S_B4);\n+   end To_Inet_Addr;\n+\n+   ------------------\n+   -- To_Inet_Addr --\n+   ------------------\n \n-   procedure Set_Port\n-     (Sin  : Sockaddr_In_Access;\n-      Port : C.unsigned_short)\n+   procedure To_Inet_Addr\n+     (Addr   : In6_Addr;\n+      Result : out Inet_Addr_Type)\n    is\n+      Sin_V6 : Inet_Addr_V6_Type;\n    begin\n-      Sin.Sin_Port := Port;\n-   end Set_Port;\n+      for J in Addr'Range loop\n+         Sin_V6 (J) := Inet_Addr_Comp_Type (Addr (J));\n+      end loop;\n+\n+      Result := (Family => Family_Inet6, Sin_V6 => Sin_V6);\n+   end To_Inet_Addr;\n+\n+   ----------------\n+   -- To_In_Addr --\n+   ----------------\n+\n+   function To_In6_Addr (Addr : Inet_Addr_Type) return In6_Addr is\n+      Result : In6_Addr;\n+   begin\n+      for J in Addr.Sin_V6'Range loop\n+         Result (J) := C.unsigned_char (Addr.Sin_V6 (J));\n+      end loop;\n+\n+      return Result;\n+   end To_In6_Addr;\n+\n+   ----------------------\n+   -- Short_To_Network --\n+   ----------------------\n+\n+   function Short_To_Network (S : C.unsigned_short) return C.unsigned_short is\n+      use Interfaces;\n+      use System;\n+\n+   begin\n+      --  Big-endian case. No conversion needed. On these platforms, htons()\n+      --  defaults to a null procedure.\n+\n+      if Default_Bit_Order = High_Order_First then\n+         return S;\n+\n+      --  Little-endian case. We must swap the high and low bytes of this\n+      --  short to make the port number network compliant.\n+\n+      else\n+         return C.unsigned_short (Rotate_Left (Unsigned_16 (S), 8));\n+      end if;\n+   end Short_To_Network;\n \n end GNAT.Sockets.Thin_Common;"}, {"sha": "03d20b579a73ad6c3ae5426b045e05c8a5f69b49", "filename": "gcc/ada/libgnat/g-sothco.ads", "status": "modified", "additions": 121, "deletions": 57, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/759f1648029eef1fde1c66e342b033438c44e3b5/gcc%2Fada%2Flibgnat%2Fg-sothco.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/759f1648029eef1fde1c66e342b033438c44e3b5/gcc%2Fada%2Flibgnat%2Fg-sothco.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-sothco.ads?ref=759f1648029eef1fde1c66e342b033438c44e3b5", "patch": "@@ -33,13 +33,12 @@\n --  This package should not be directly with'ed by an applications program.\n \n with Ada.Unchecked_Conversion;\n-\n-with Interfaces.C;\n-with Interfaces.C.Pointers;\n+with Interfaces.C.Strings;\n \n package GNAT.Sockets.Thin_Common is\n \n    package C renames Interfaces.C;\n+   package CS renames C.Strings;\n \n    Success : constant C.int :=  0;\n    Failure : constant C.int := -1;\n@@ -65,19 +64,24 @@ package GNAT.Sockets.Thin_Common is\n    type Timeval_Access is access all Timeval;\n    pragma Convention (C, Timeval_Access);\n \n+   type socklen_t is mod 2 ** (8 * SOSC.SIZEOF_socklen_t);\n+   for socklen_t'Size use (8 * SOSC.SIZEOF_socklen_t);\n+\n    Immediat : constant Timeval := (0, 0);\n \n    -------------------------------------------\n    -- Mapping tables to low level constants --\n    -------------------------------------------\n \n    Families : constant array (Family_Type) of C.int :=\n-                (Family_Inet  => SOSC.AF_INET,\n-                 Family_Inet6 => SOSC.AF_INET6);\n+                (Family_Unspec => SOSC.AF_UNSPEC,\n+                 Family_Inet   => SOSC.AF_INET,\n+                 Family_Inet6  => SOSC.AF_INET6);\n \n    Lengths  : constant array (Family_Type) of C.unsigned_char :=\n-                (Family_Inet  => SOSC.SIZEOF_sockaddr_in,\n-                 Family_Inet6 => SOSC.SIZEOF_sockaddr_in6);\n+                (Family_Unspec => 0,\n+                 Family_Inet   => SOSC.SIZEOF_sockaddr_in,\n+                 Family_Inet6  => SOSC.SIZEOF_sockaddr_in6);\n \n    ----------------------------\n    -- Generic socket address --\n@@ -112,22 +116,6 @@ package GNAT.Sockets.Thin_Common is\n    --  Set the family component to the appropriate value for Family, and also\n    --  set Length accordingly if applicable on this platform.\n \n-   type Sockaddr is record\n-      Sa_Family : Sockaddr_Length_And_Family;\n-      --  Address family (and address length on some platforms)\n-\n-      Sa_Data : C.char_array (1 .. 14) := (others => C.nul);\n-      --  Family-specific data\n-      --  Note that some platforms require that all unused (reserved) bytes\n-      --  in addresses be initialized to 0 (e.g. VxWorks).\n-   end record;\n-   pragma Convention (C, Sockaddr);\n-   --  Generic socket address\n-\n-   type Sockaddr_Access is access all Sockaddr;\n-   pragma Convention (C, Sockaddr_Access);\n-   --  Access to socket address\n-\n    ----------------------------\n    -- AF_INET socket address --\n    ----------------------------\n@@ -144,55 +132,64 @@ package GNAT.Sockets.Thin_Common is\n    function To_In_Addr is new Ada.Unchecked_Conversion (C.int, In_Addr);\n    function To_Int     is new Ada.Unchecked_Conversion (In_Addr, C.int);\n \n-   type In_Addr_Access is access all In_Addr;\n-   pragma Convention (C, In_Addr_Access);\n-   --  Access to internet address\n-\n-   Inaddr_Any : aliased constant In_Addr := (others => 0);\n-   --  Any internet address (all the interfaces)\n+   function To_In_Addr (Addr : Inet_Addr_Type) return In_Addr;\n+   procedure To_Inet_Addr\n+     (Addr   : In_Addr;\n+      Result : out Inet_Addr_Type);\n+   --  Conversion functions\n \n-   type In_Addr_Access_Array is array (C.size_t range <>)\n-     of aliased In_Addr_Access;\n-   pragma Convention (C, In_Addr_Access_Array);\n+   type In6_Addr is array (1 .. 16) of C.unsigned_char;\n+   for In6_Addr'Alignment use C.int'Alignment;\n+   pragma Convention (C, In6_Addr);\n \n-   package In_Addr_Access_Pointers is new C.Pointers\n-     (C.size_t, In_Addr_Access, In_Addr_Access_Array, null);\n-   --  Array of internet addresses\n+   function To_In6_Addr (Addr : Inet_Addr_Type) return In6_Addr;\n+   procedure To_Inet_Addr\n+     (Addr   : In6_Addr;\n+      Result : out Inet_Addr_Type);\n+   --  Conversion functions\n \n-   type Sockaddr_In is record\n+   type Sockaddr (Family : Family_Type := Family_Inet) is record\n       Sin_Family : Sockaddr_Length_And_Family;\n       --  Address family (and address length on some platforms)\n \n       Sin_Port : C.unsigned_short;\n       --  Port in network byte order\n \n-      Sin_Addr : In_Addr;\n-      --  IPv4 address\n-\n-      Sin_Zero : C.char_array (1 .. 8) := (others => C.nul);\n-      --  Padding\n-      --\n-      --  Note that some platforms require that all unused (reserved) bytes\n-      --  in addresses be initialized to 0 (e.g. VxWorks).\n+      case Family is\n+      when Family_Inet =>\n+         Sin_Addr : In_Addr := (others => 0);\n+         --  IPv4 address\n+\n+         Sin_Zero : C.char_array (1 .. 8) := (others => C.nul);\n+         --  Padding\n+         --\n+         --  Note that some platforms require that all unused (reserved) bytes\n+         --  in addresses be initialized to 0 (e.g. VxWorks).\n+      when Family_Inet6 =>\n+         Sin6_FlowInfo : Interfaces.Unsigned_32 := 0;\n+         Sin6_Addr     : In6_Addr := (others => 0);\n+         Sin6_Scope_Id : Interfaces.Unsigned_32 := 0;\n+      when Family_Unspec =>\n+         null;\n+      end case;\n    end record;\n-   pragma Convention (C, Sockaddr_In);\n+   pragma Unchecked_Union (Sockaddr);\n+   pragma Convention (C, Sockaddr);\n    --  Internet socket address\n \n-   type Sockaddr_In_Access is access all Sockaddr_In;\n-   pragma Convention (C, Sockaddr_In_Access);\n+   type Sockaddr_Access is access all Sockaddr;\n+   pragma Convention (C, Sockaddr_Access);\n    --  Access to internet socket address\n \n-   procedure Set_Port\n-     (Sin  : Sockaddr_In_Access;\n-      Port : C.unsigned_short);\n-   pragma Inline (Set_Port);\n-   --  Set Sin.Sin_Port to Port\n-\n    procedure Set_Address\n-     (Sin     : Sockaddr_In_Access;\n-      Address : In_Addr);\n-   pragma Inline (Set_Address);\n-   --  Set Sin.Sin_Addr to Address\n+     (Sin     : Sockaddr_Access;\n+      Address : Sock_Addr_Type);\n+   --  Initialise all necessary fields in Sin from Address.\n+   --  Set appropriate Family, Port, and either Sin.Sin_Addr or Sin.Sin6_Addr\n+   --  depend on family.\n+\n+   function Get_Address (Sin : Sockaddr) return Sock_Addr_Type;\n+   --  Get Sock_Addr_Type from Sockaddr\n \n    ------------------\n    -- Host entries --\n@@ -297,6 +294,51 @@ package GNAT.Sockets.Thin_Common is\n       Buf    : System.Address;\n       Buflen : C.int) return C.int;\n \n+   Address_Size : constant := Standard'Address_Size;\n+\n+   type Addrinfo;\n+   type Addrinfo_Access is access all Addrinfo;\n+\n+   type Addrinfo is record\n+      ai_flags     : C.int;\n+      ai_family    : C.int;\n+      ai_socktype  : C.int;\n+      ai_protocol  : C.int;\n+      ai_addrlen   : socklen_t;\n+      ai_addr      : Sockaddr_Access;\n+      ai_canonname : CS.char_array_access;\n+      ai_next      : Addrinfo_Access;\n+   end record with Convention => C;\n+   for Addrinfo use record\n+      ai_flags     at SOSC.AI_FLAGS_OFFSET     range 0 .. C.int'Size - 1;\n+      ai_family    at SOSC.AI_FAMILY_OFFSET    range 0 .. C.int'Size - 1;\n+      ai_socktype  at SOSC.AI_SOCKTYPE_OFFSET  range 0 .. C.int'Size - 1;\n+      ai_protocol  at SOSC.AI_PROTOCOL_OFFSET  range 0 .. C.int'Size - 1;\n+      ai_addrlen   at SOSC.AI_ADDRLEN_OFFSET   range 0 .. socklen_t'Size - 1;\n+      ai_canonname at SOSC.AI_CANONNAME_OFFSET range 0 .. Address_Size - 1;\n+      ai_addr      at SOSC.AI_ADDR_OFFSET      range 0 .. Address_Size - 1;\n+      ai_next      at SOSC.AI_NEXT_OFFSET      range 0 .. Address_Size - 1;\n+   end record;\n+\n+   function C_Getaddrinfo\n+     (Node    : CS.char_array_access;\n+      Service : CS.char_array_access;\n+      Hints   : access constant Addrinfo;\n+      Res     : not null access Addrinfo_Access) return C.int;\n+\n+   procedure C_Freeaddrinfo (res : Addrinfo_Access);\n+\n+   function C_Getnameinfo\n+     (sa      : Sockaddr_Access;\n+      salen   : socklen_t;\n+      host    : CS.char_array_access;\n+      hostlen : C.size_t;\n+      serv    : CS.char_array_access;\n+      servlen : C.size_t;\n+      flags   : C.int) return C.int;\n+\n+   function C_GAI_Strerror (ecode : C.int) return CS.chars_ptr;\n+\n    ------------------------------------\n    -- Scatter/gather vector handling --\n    ------------------------------------\n@@ -375,11 +417,27 @@ package GNAT.Sockets.Thin_Common is\n       Cp  : System.Address;\n       Inp : System.Address) return C.int;\n \n+   function Inet_Ntop\n+     (Af   : C.int;\n+      Src  : System.Address;\n+      Dst  : CS.char_array_access;\n+      Size : socklen_t) return CS.char_array_access;\n+\n    function C_Ioctl\n      (Fd  : C.int;\n       Req : SOSC.IOCTL_Req_T;\n       Arg : access C.int) return C.int;\n \n+   function Short_To_Network\n+     (S : C.unsigned_short) return C.unsigned_short;\n+   pragma Inline (Short_To_Network);\n+   --  Convert a port number into a network port number\n+\n+   function Network_To_Short\n+     (S : C.unsigned_short) return C.unsigned_short\n+   renames Short_To_Network;\n+   --  Symmetric operation\n+\n private\n    pragma Import (C, Get_Socket_From_Set, \"__gnat_get_socket_from_set\");\n    pragma Import (C, Is_Socket_In_Set, \"__gnat_is_socket_in_set\");\n@@ -389,12 +447,18 @@ private\n    pragma Import (C, Reset_Socket_Set, \"__gnat_reset_socket_set\");\n    pragma Import (C, C_Ioctl, \"__gnat_socket_ioctl\");\n    pragma Import (C, Inet_Pton, SOSC.Inet_Pton_Linkname);\n+   pragma Import (C, Inet_Ntop, SOSC.Inet_Ntop_Linkname);\n \n    pragma Import (C, C_Gethostbyname, \"__gnat_gethostbyname\");\n    pragma Import (C, C_Gethostbyaddr, \"__gnat_gethostbyaddr\");\n    pragma Import (C, C_Getservbyname, \"__gnat_getservbyname\");\n    pragma Import (C, C_Getservbyport, \"__gnat_getservbyport\");\n \n+   pragma Import (C, C_Getaddrinfo,   \"__gnat_getaddrinfo\");\n+   pragma Import (C, C_Freeaddrinfo,  \"__gnat_freeaddrinfo\");\n+   pragma Import (C, C_Getnameinfo,   \"__gnat_getnameinfo\");\n+   pragma Import (C, C_GAI_Strerror,  \"__gnat_gai_strerror\");\n+\n    pragma Import (C, Servent_S_Name,  \"__gnat_servent_s_name\");\n    pragma Import (C, Servent_S_Alias, \"__gnat_servent_s_alias\");\n    pragma Import (C, Servent_S_Port,  \"__gnat_servent_s_port\");"}, {"sha": "cd5dce4fa0379b263652ea5ec38fa4140a4775d8", "filename": "gcc/ada/libgnat/g-stsifd__sockets.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/759f1648029eef1fde1c66e342b033438c44e3b5/gcc%2Fada%2Flibgnat%2Fg-stsifd__sockets.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/759f1648029eef1fde1c66e342b033438c44e3b5/gcc%2Fada%2Flibgnat%2Fg-stsifd__sockets.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-stsifd__sockets.adb?ref=759f1648029eef1fde1c66e342b033438c44e3b5", "patch": "@@ -60,7 +60,7 @@ package body Signalling_Fds is\n       L_Sock, R_Sock, W_Sock : C.int := Failure;\n       --  Listening socket, read socket and write socket\n \n-      Sin : aliased Sockaddr_In;\n+      Sin : aliased Sockaddr;\n       Len : aliased C.int;\n       --  Address of listening socket\n "}, {"sha": "448155b2ed395cddeec49db7bdb2bffe32954cbb", "filename": "gcc/ada/s-oscons-tmplt.c", "status": "modified", "additions": 270, "deletions": 0, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/759f1648029eef1fde1c66e342b033438c44e3b5/gcc%2Fada%2Fs-oscons-tmplt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/759f1648029eef1fde1c66e342b033438c44e3b5/gcc%2Fada%2Fs-oscons-tmplt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-oscons-tmplt.c?ref=759f1648029eef1fde1c66e342b033438c44e3b5", "patch": "@@ -1056,6 +1056,138 @@ CND(AF_INET, \"IPv4 address family\")\n #endif\n CND(AF_INET6, \"IPv6 address family\")\n \n+#ifndef AF_UNSPEC\n+# define AF_UNSPEC -1\n+#else\n+# define HAVE_AF_UNSPEC 1\n+#endif\n+CND(AF_UNSPEC, \"Unspecified address family\")\n+\n+/*\n+\n+   -----------------------------\n+   -- addrinfo fields offsets --\n+   -----------------------------\n+\n+*/\n+\n+#ifdef AI_CANONNAME\n+  const struct addrinfo ai;\n+\n+#define AI_FLAGS_OFFSET ((void *)&ai.ai_flags - (void *)&ai)\n+#define AI_FAMILY_OFFSET ((void *)&ai.ai_family - (void *)&ai)\n+#define AI_SOCKTYPE_OFFSET ((void *)&ai.ai_socktype - (void *)&ai)\n+#define AI_PROTOCOL_OFFSET ((void *)&ai.ai_protocol - (void *)&ai)\n+#define AI_ADDRLEN_OFFSET ((void *)&ai.ai_addrlen - (void *)&ai)\n+#define AI_ADDR_OFFSET ((void *)&ai.ai_addr - (void *)&ai)\n+#define AI_CANONNAME_OFFSET ((void *)&ai.ai_canonname - (void *)&ai)\n+#define AI_NEXT_OFFSET ((void *)&ai.ai_next - (void *)&ai)\n+\n+#else\n+\n+#define AI_FLAGS_OFFSET 0\n+#define AI_FAMILY_OFFSET 4\n+#define AI_SOCKTYPE_OFFSET 8\n+#define AI_PROTOCOL_OFFSET 12\n+#define AI_ADDRLEN_OFFSET 16\n+#define AI_CANONNAME_OFFSET 24\n+#define AI_ADDR_OFFSET 32\n+#define AI_NEXT_OFFSET 40\n+\n+#endif\n+\n+CND(AI_FLAGS_OFFSET,     \"Offset of ai_flags in addrinfo\");\n+CND(AI_FAMILY_OFFSET,    \"Offset of ai_family in addrinfo\");\n+CND(AI_SOCKTYPE_OFFSET,  \"Offset of ai_socktype in addrinfo\");\n+CND(AI_PROTOCOL_OFFSET,  \"Offset of ai_protocol in addrinfo\");\n+CND(AI_ADDRLEN_OFFSET,   \"Offset of ai_addrlen in addrinfo\");\n+CND(AI_ADDR_OFFSET,      \"Offset of ai_addr in addrinfo\");\n+CND(AI_CANONNAME_OFFSET, \"Offset of ai_canonname in addrinfo\");\n+CND(AI_NEXT_OFFSET,      \"Offset of ai_next in addrinfo\");\n+\n+/*\n+\n+   ---------------------------------------\n+   -- getaddrinfo getnameinfo constants --\n+   ---------------------------------------\n+\n+*/\n+\n+#ifndef AI_PASSIVE\n+# define AI_PASSIVE -1\n+#endif\n+CND(AI_PASSIVE, \"NULL nodename for accepting\")\n+\n+#ifndef AI_CANONNAME\n+# define AI_CANONNAME -1\n+#endif\n+CND(AI_CANONNAME, \"Get the host official name\")\n+\n+#ifndef AI_NUMERICSERV\n+# define AI_NUMERICSERV -1\n+#endif\n+CND(AI_NUMERICSERV, \"Service is a numeric string\")\n+\n+#ifndef AI_NUMERICHOST\n+# define AI_NUMERICHOST -1\n+#endif\n+CND(AI_NUMERICHOST, \"Node is a numeric IP address\")\n+\n+#ifndef AI_ADDRCONFIG\n+# define AI_ADDRCONFIG -1\n+#endif\n+CND(AI_ADDRCONFIG, \"Returns addresses for only locally configured families\")\n+\n+#ifndef AI_V4MAPPED\n+# define AI_V4MAPPED -1\n+#endif\n+CND(AI_V4MAPPED, \"Returns IPv4 mapped to IPv6\")\n+\n+#ifndef AI_ALL\n+# define AI_ALL -1\n+#endif\n+CND(AI_ALL, \"Change AI_V4MAPPED behavior for unavailavle IPv6 addresses\")\n+\n+#ifndef NI_NAMEREQD\n+# define NI_NAMEREQD -1\n+#endif\n+CND(NI_NAMEREQD, \"Error if the hostname cannot be determined\")\n+\n+#ifndef NI_DGRAM\n+# define NI_DGRAM -1\n+#endif\n+CND(NI_DGRAM, \"Service is datagram\")\n+\n+#ifndef NI_NOFQDN\n+# define NI_NOFQDN -1\n+#endif\n+CND(NI_NOFQDN, \"Return only the hostname part for local hosts\")\n+\n+#ifndef NI_NUMERICSERV\n+# define NI_NUMERICSERV -1\n+#endif\n+CND(NI_NUMERICSERV, \"Numeric form of the service\")\n+\n+#ifndef NI_NUMERICHOST\n+# define NI_NUMERICHOST -1\n+#endif\n+CND(NI_NUMERICHOST, \"Numeric form of the hostname\")\n+\n+#ifndef NI_MAXHOST\n+# define NI_MAXHOST -1\n+#endif\n+CND(NI_MAXHOST, \"Maximum size of hostname\")\n+\n+#ifndef NI_MAXSERV\n+# define NI_MAXSERV -1\n+#endif\n+CND(NI_MAXSERV, \"Maximum size of service name\")\n+\n+#ifndef EAI_SYSTEM\n+# define EAI_SYSTEM -1\n+#endif\n+CND(EAI_SYSTEM, \"Check errno for details\")\n+\n /*\n \n    ------------------\n@@ -1074,6 +1206,11 @@ CND(SOCK_STREAM, \"Stream socket\")\n #endif\n CND(SOCK_DGRAM, \"Datagram socket\")\n \n+#ifndef SOCK_RAW\n+# define SOCK_RAW -1\n+#endif\n+CND(SOCK_RAW, \"Raw socket\")\n+\n /*\n \n    -----------------\n@@ -1143,6 +1280,11 @@ CND(SOL_SOCKET, \"Options for socket level\")\n #endif\n CND(IPPROTO_IP, \"Dummy protocol for IP\")\n \n+#ifndef IPPROTO_IPV6\n+# define IPPROTO_IPV6 -1\n+#endif\n+CND(IPPROTO_IPV6, \"IPv6 socket option level\")\n+\n #ifndef IPPROTO_UDP\n # define IPPROTO_UDP -1\n #endif\n@@ -1300,6 +1442,111 @@ CND(IP_DROP_MEMBERSHIP, \"Leave a multicast group\")\n #endif\n CND(IP_PKTINFO, \"Get datagram info\")\n \n+#ifndef IP_RECVERR\n+# define IP_RECVERR -1\n+#endif\n+CND(IP_RECVERR, \"Extended reliable error message passing\")\n+\n+#ifndef IPV6_ADDRFORM\n+# define IPV6_ADDRFORM -1\n+#endif\n+CND(IPV6_ADDRFORM, \"Turn IPv6 socket into different address family\")\n+\n+#ifndef IPV6_ADD_MEMBERSHIP\n+# define IPV6_ADD_MEMBERSHIP -1\n+#endif\n+CND(IPV6_ADD_MEMBERSHIP, \"Join IPv6 multicast group\")\n+\n+#ifndef IPV6_DROP_MEMBERSHIP\n+# define IPV6_DROP_MEMBERSHIP -1\n+#endif\n+CND(IPV6_DROP_MEMBERSHIP, \"Leave IPv6 multicast group\")\n+\n+#ifndef IPV6_MTU\n+# define IPV6_MTU -1\n+#endif\n+CND(IPV6_MTU, \"Set/get MTU used for the socket\")\n+\n+#ifndef IPV6_MTU_DISCOVER\n+# define IPV6_MTU_DISCOVER -1\n+#endif\n+CND(IPV6_MTU_DISCOVER, \"Control path-MTU discovery on the socket\")\n+\n+#ifndef IPV6_MULTICAST_HOPS\n+# define IPV6_MULTICAST_HOPS -1\n+#endif\n+CND(IPV6_MULTICAST_HOPS, \"Set the multicast hop limit for the socket\")\n+\n+#ifndef IPV6_MULTICAST_IF\n+# define IPV6_MULTICAST_IF -1\n+#endif\n+CND(IPV6_MULTICAST_IF, \"Set/get IPv6 mcast interface\")\n+\n+#ifndef IPV6_MULTICAST_LOOP\n+# define IPV6_MULTICAST_LOOP -1\n+#endif\n+CND(IPV6_MULTICAST_LOOP, \"Set/get mcast loopback\")\n+\n+#ifndef IPV6_RECVPKTINFO\n+# define IPV6_RECVPKTINFO -1\n+#endif\n+CND(IPV6_RECVPKTINFO, \"Set delivery of the IPV6_PKTINFO\")\n+\n+#ifndef IPV6_PKTINFO\n+# define IPV6_PKTINFO -1\n+#endif\n+CND(IPV6_PKTINFO, \"Get IPv6datagram info\")\n+\n+#ifndef IPV6_RTHDR\n+# define IPV6_RTHDR -1\n+#endif\n+CND(IPV6_RTHDR, \"Set the routing header delivery\")\n+\n+#ifndef IPV6_AUTHHDR\n+# define IPV6_AUTHHDR -1\n+#endif\n+CND(IPV6_AUTHHDR, \"Set the authentication header delivery\")\n+\n+#ifndef IPV6_DSTOPTS\n+# define IPV6_DSTOPTS -1\n+#endif\n+CND(IPV6_DSTOPTS, \"Set the destination options delivery\")\n+\n+#ifndef IPV6_HOPOPTS\n+# define IPV6_HOPOPTS -1\n+#endif\n+CND(IPV6_HOPOPTS, \"Set the hop options delivery\")\n+\n+#ifndef IPV6_FLOWINFO\n+# define IPV6_FLOWINFO -1\n+#endif\n+CND(IPV6_FLOWINFO, \"Set the flow ID delivery\")\n+\n+#ifndef IPV6_HOPLIMIT\n+# define IPV6_HOPLIMIT -1\n+#endif\n+CND(IPV6_HOPLIMIT, \"Set the hop count of the packet delivery\")\n+\n+#ifndef IPV6_RECVERR\n+# define IPV6_RECVERR -1\n+#endif\n+CND(IPV6_RECVERR, \"Extended reliable error message passing\")\n+\n+#ifndef IPV6_ROUTER_ALERT\n+# define IPV6_ROUTER_ALERT -1\n+#endif\n+CND(IPV6_ROUTER_ALERT, \"Pass forwarded router alert hop-by-hop option\")\n+\n+#ifndef IPV6_UNICAST_HOPS\n+# define IPV6_UNICAST_HOPS -1\n+#endif\n+CND(IPV6_UNICAST_HOPS, \"Set the unicast hop limit\")\n+\n+#ifndef IPV6_V6ONLY\n+# define IPV6_V6ONLY -1\n+#endif\n+CND(IPV6_V6ONLY, \"Restricted to IPv6 communications only\")\n+\n /*\n \n    ----------------------\n@@ -1367,6 +1614,22 @@ CND(SIZEOF_struct_servent, \"struct servent\")\n CND(SIZEOF_sigset, \"sigset\")\n #endif\n \n+#if defined(_WIN32) || defined(__vxworks)\n+#define SIZEOF_socklen_t sizeof (size_t)\n+#else\n+#define SIZEOF_socklen_t sizeof (socklen_t)\n+#endif\n+CND(SIZEOF_socklen_t, \"Size of socklen_t\");\n+\n+#ifndef IF_NAMESIZE\n+#ifdef IF_MAX_STRING_SIZE\n+#define IF_NAMESIZE IF_MAX_STRING_SIZE\n+#else\n+#define IF_NAMESIZE -1\n+#endif\n+#endif\n+CND(IF_NAMESIZE, \"Max size of interface name with 0 terminator\");\n+\n /*\n \n    --  Fields of struct msghdr\n@@ -1409,6 +1672,13 @@ C(\"Thread_Blocking_IO\", Boolean, \"True\", \"\")\n #endif\n CST(Inet_Pton_Linkname, \"\")\n \n+#ifdef HAVE_INET_NTOP\n+# define Inet_Ntop_Linkname \"inet_ntop\"\n+#else\n+# define Inet_Ntop_Linkname \"__gnat_inet_ntop\"\n+#endif\n+CST(Inet_Ntop_Linkname, \"\")\n+\n #endif /* HAVE_SOCKETS */\n \n /*"}, {"sha": "7f2b5ff84248cc70c6c99370f9c21aa662c1eb3e", "filename": "gcc/ada/socket.c", "status": "modified", "additions": 160, "deletions": 7, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/759f1648029eef1fde1c66e342b033438c44e3b5/gcc%2Fada%2Fsocket.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/759f1648029eef1fde1c66e342b033438c44e3b5/gcc%2Fada%2Fsocket.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsocket.c?ref=759f1648029eef1fde1c66e342b033438c44e3b5", "patch": "@@ -90,10 +90,27 @@ extern int __gnat_hostent_h_addrtype (struct hostent *);\n extern int __gnat_hostent_h_length (struct hostent *);\n extern char * __gnat_hostent_h_addr (struct hostent *, int);\n \n+extern int __gnat_getaddrinfo(\n+  const char *node,\n+  const char *service,\n+  const struct addrinfo *hints,\n+  struct addrinfo **res);\n+int __gnat_getnameinfo(\n+  const struct sockaddr *sa, socklen_t salen,\n+  char *host, size_t hostlen,\n+  char *serv, size_t servlen, int flags);\n+extern void __gnat_freeaddrinfo(struct addrinfo *res);\n+extern const char * __gnat_gai_strerror(int errcode);\n+\n #ifndef HAVE_INET_PTON\n extern int  __gnat_inet_pton (int, const char *, void *);\n #endif\n-\f\n+\n+#ifndef HAVE_INET_NTOP\n+extern const char *\n+__gnat_inet_ntop(int, const void *, char *, socklen_t);\n+#endif\n+\n /* Disable the sending of SIGPIPE for writes on a broken stream */\n \n void\n@@ -112,7 +129,7 @@ __gnat_disable_all_sigpipes (void)\n   (void) signal (SIGPIPE, SIG_IGN);\n #endif\n }\n-\f\n+\n #if defined (_WIN32) || defined (__vxworks)\n /*\n  * Signalling FDs operations are implemented in Ada for these platforms\n@@ -128,7 +145,7 @@ int\n __gnat_create_signalling_fds (int *fds) {\n   return pipe (fds);\n }\n-\f\n+\n /*\n  * Read one byte of data from rsig, the read end of a pair of signalling fds\n  * created by __gnat_create_signalling_fds.\n@@ -138,7 +155,7 @@ __gnat_read_signalling_fd (int rsig) {\n   char c;\n   return read (rsig, &c, 1);\n }\n-\f\n+\n /*\n  * Write one byte of data to wsig, the write end of a pair of signalling fds\n  * created by __gnat_create_signalling_fds.\n@@ -148,7 +165,7 @@ __gnat_write_signalling_fd (int wsig) {\n   char c = 0;\n   return write (wsig, &c, 1);\n }\n-\f\n+\n /*\n  * Close one end of a pair of signalling fds\n  */\n@@ -157,7 +174,7 @@ __gnat_close_signalling_fd (int sig) {\n   (void) close (sig);\n }\n #endif\n-\f\n+\n /*\n  * Handling of gethostbyname, gethostbyaddr, getservbyname and getservbyport\n  * =========================================================================\n@@ -369,7 +386,7 @@ __gnat_getservbyport (int port, const char *proto,\n   return 0;\n }\n #endif\n-\f\n+\n /* Find the largest socket in the socket set SET. This is needed for\n    `select'.  LAST is the maximum value for the largest socket. This hint is\n    used to avoid scanning very large socket sets.  On return, LAST is the\n@@ -572,6 +589,41 @@ __gnat_inet_pton (int af, const char *src, void *dst) {\n }\n #endif\n \n+#ifndef HAVE_INET_NTOP\n+\n+const char *\n+__gnat_inet_ntop(int af, const void *src, char *dst, socklen_t size)\n+{\n+#ifdef _WIN32\n+  struct sockaddr_storage ss;\n+  int sslen = sizeof ss;\n+  memset(&ss, 0, sslen);\n+  ss.ss_family = af;\n+\n+  switch (af) {\n+    case AF_INET6:\n+      ((struct sockaddr_in6 *)&ss)->sin6_addr = *(struct in6_addr *)src;\n+      break;\n+    case AF_INET:\n+      ((struct sockaddr_in *)&ss)->sin_addr = *(struct in_addr *)src;\n+      break;\n+    default:\n+      errno = EAFNOSUPPORT;\n+      return NULL;\n+  }\n+\n+  DWORD sz = size;\n+\n+  if (WSAAddressToStringA((struct sockaddr*)&ss, sslen, 0, dst, &sz) != 0) {\n+     return NULL;\n+  }\n+  return dst;\n+#else\n+  return NULL;\n+#endif\n+}\n+#endif\n+\n /*\n  * Accessor functions for struct hostent.\n  */\n@@ -650,4 +702,105 @@ __gnat_servent_s_proto (struct servent * s)\n   return s->s_proto;\n }\n \n+#if defined(AF_INET6) && !defined(__rtems__)\n+\n+#if defined (__vxworks)\n+#define getaddrinfo ipcom_getaddrinfo\n+#define getnameinfo ipcom_getnameinfo\n+#define freeaddrinfo ipcom_freeaddrinfo\n+#endif\n+\n+int __gnat_getaddrinfo(\n+  const char *node,\n+  const char *service,\n+  const struct addrinfo *hints,\n+  struct addrinfo **res)\n+{\n+  return getaddrinfo(node, service, hints, res);\n+}\n+\n+int __gnat_getnameinfo(\n+  const struct sockaddr *sa, socklen_t salen,\n+  char *host, size_t hostlen,\n+  char *serv, size_t servlen, int flags)\n+{\n+  return getnameinfo(sa, salen, host, hostlen, serv, servlen, flags);\n+}\n+\n+void __gnat_freeaddrinfo(struct addrinfo *res) {\n+   freeaddrinfo(res);\n+}\n+\n+const char * __gnat_gai_strerror(int errcode) {\n+#if defined(_WIN32) ||  defined(__vxworks)\n+  // gai_strerror thread usafe on Windows and is not available on some vxWorks\n+  // versions\n+\n+  switch (errcode) {\n+    case EAI_AGAIN:\n+      return \"Temporary failure in name resolution.\";\n+    case EAI_BADFLAGS:\n+      return \"Invalid value for ai_flags.\";\n+    case EAI_FAIL:\n+      return \"Nonrecoverable failure in name resolution.\";\n+    case EAI_FAMILY:\n+      return \"The ai_family member is not supported.\";\n+    case EAI_MEMORY:\n+      return \"Memory allocation failure.\";\n+#ifdef EAI_NODATA\n+    // Could be not defined under the vxWorks\n+    case EAI_NODATA:\n+      return \"No address associated with nodename.\";\n+#endif\n+#if EAI_NODATA != EAI_NONAME\n+    /* with mingw64 runtime EAI_NODATA and EAI_NONAME have the same value.\n+       This applies to both win32 and win64 */\n+    case EAI_NONAME:\n+      return \"Neither nodename nor servname provided, or not known.\";\n+#endif\n+    case EAI_SERVICE:\n+      return \"The servname parameter is not supported for ai_socktype.\";\n+    case EAI_SOCKTYPE:\n+      return \"The ai_socktype member is not supported.\";\n+#ifdef EAI_SYSTEM\n+    // Could be not defined, at least on Windows\n+    case EAI_SYSTEM:\n+      return \"System error returned in errno\";\n+#endif\n+    default:\n+      return \"Unknown error.\";\n+    }\n+#else\n+   return gai_strerror(errcode);\n+#endif\n+}\n+\n+#else\n+\n+int __gnat_getaddrinfo(\n+  const char *node,\n+  const char *service,\n+  const struct addrinfo *hints,\n+  struct addrinfo **res)\n+{\n+  return -1;\n+}\n+\n+int __gnat_getnameinfo(\n+  const struct sockaddr *sa, socklen_t salen,\n+  char *host, size_t hostlen,\n+  char *serv, size_t servlen, int flags)\n+{\n+  return -1;\n+}\n+\n+void __gnat_freeaddrinfo(struct addrinfo *res) {\n+}\n+\n+const char * __gnat_gai_strerror(int errcode) {\n+   return \"getaddinfo functions family is not supported\";\n+}\n+\n+#endif\n+\n #endif /* defined(HAVE_SOCKETS) */"}]}