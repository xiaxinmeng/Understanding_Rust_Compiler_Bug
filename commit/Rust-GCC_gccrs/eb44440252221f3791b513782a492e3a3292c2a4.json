{"sha": "eb44440252221f3791b513782a492e3a3292c2a4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWI0NDQ0MDI1MjIyMWYzNzkxYjUxMzc4MmE0OTJlM2EzMjkyYzJhNA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-10-29T14:42:50Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-10-29T14:42:50Z"}, "message": "[multiple changes]\n\n2009-10-28  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_type.adb: Minor reformatting\n\n2009-10-28  Arnaud Charlet  <charlet@adacore.com>\n\n\t* exp_ch9.adb (Build_Task_Proc_Specification): Generate a different\n\tsuffix for task type bodies.\n\n2009-10-28  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_aggr.adb (Convert_Aggr_In_Allocator): Do not look for a\n\tfinalization list if the designated type requires no control actions,\n\tto prevent a useless semantic dependence on ada.tags.\n\nFrom-SVN: r153705", "tree": {"sha": "138b582dd4a3704fa0f5e8bbd79ac163f50a5e00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/138b582dd4a3704fa0f5e8bbd79ac163f50a5e00"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eb44440252221f3791b513782a492e3a3292c2a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb44440252221f3791b513782a492e3a3292c2a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb44440252221f3791b513782a492e3a3292c2a4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb44440252221f3791b513782a492e3a3292c2a4/comments", "author": null, "committer": null, "parents": [{"sha": "90e7755315528419c69362a3ab49456c1aff18f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90e7755315528419c69362a3ab49456c1aff18f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90e7755315528419c69362a3ab49456c1aff18f0"}], "stats": {"total": 77, "additions": 62, "deletions": 15}, "files": [{"sha": "0c5382e8fc0466f0324bccd2414c244a8a894f01", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb44440252221f3791b513782a492e3a3292c2a4/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb44440252221f3791b513782a492e3a3292c2a4/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=eb44440252221f3791b513782a492e3a3292c2a4", "patch": "@@ -1,3 +1,18 @@\n+2009-10-28  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_type.adb: Minor reformatting\n+\n+2009-10-28  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* exp_ch9.adb (Build_Task_Proc_Specification): Generate a different\n+\tsuffix for task type bodies.\n+\n+2009-10-28  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_aggr.adb (Convert_Aggr_In_Allocator): Do not look for a\n+\tfinalization list if the designated type requires no control actions,\n+\tto prevent a useless semantic dependence on ada.tags.\n+\n 2009-10-28  Bob Duff  <duff@adacore.com>\n \n \t* s-fileio.adb: Give more information in exception messages."}, {"sha": "aadb22485d2ff2e43876babb30fa0b0159090f7c", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb44440252221f3791b513782a492e3a3292c2a4/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb44440252221f3791b513782a492e3a3292c2a4/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=eb44440252221f3791b513782a492e3a3292c2a4", "patch": "@@ -3298,8 +3298,14 @@ package body Exp_Aggr is\n                                               N_Discriminant_Specification\n       then\n          Flist := Empty;\n-      else\n+\n+      elsif Needs_Finalization (Typ) then\n          Flist := Find_Final_List (Access_Type);\n+\n+         --  Otherwise there are no controlled actions to be performed.\n+\n+      else\n+         Flist := Empty;\n       end if;\n \n       if Is_Array_Type (Typ) then"}, {"sha": "f9cbf7b50d8f0647130d7456db979f4d28aee5c1", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb44440252221f3791b513782a492e3a3292c2a4/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb44440252221f3791b513782a492e3a3292c2a4/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=eb44440252221f3791b513782a492e3a3292c2a4", "patch": "@@ -3983,9 +3983,18 @@ package body Exp_Ch9 is\n       Spec_Id : Entity_Id;\n \n    begin\n-      Spec_Id :=\n-        Make_Defining_Identifier (Loc,\n-          Chars => New_External_Name (Chars (T), 'B'));\n+      if Comes_From_Source (T) then\n+         --  This is an explicit task type\n+         Spec_Id :=\n+           Make_Defining_Identifier (Loc,\n+             Chars => New_External_Name (Chars (T), \"TB\"));\n+      else\n+         --  This is an anonymous task type\n+         Spec_Id :=\n+           Make_Defining_Identifier (Loc,\n+             Chars => New_External_Name (Chars (T), 'B'));\n+      end if;\n+\n       Set_Is_Internal (Spec_Id);\n \n       --  Associate the procedure with the task, if this is the declaration"}, {"sha": "d35326e1a507c2017b6c3bf8404abdf5bf4cb669", "filename": "gcc/ada/sem_type.adb", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb44440252221f3791b513782a492e3a3292c2a4/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb44440252221f3791b513782a492e3a3292c2a4/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=eb44440252221f3791b513782a492e3a3292c2a4", "patch": "@@ -732,7 +732,7 @@ package body Sem_Type is\n    begin\n       --  If either operand missing, then this is an error, but ignore it (and\n       --  pretend we have a cover) if errors already detected, since this may\n-      --  simply mean we have malformed trees.\n+      --  simply mean we have malformed trees or a semantic error upstream.\n \n       if No (T1) or else No (T2) then\n          if Total_Errors_Detected /= 0 then\n@@ -803,7 +803,8 @@ package body Sem_Type is\n       then\n          return True;\n \n-      --  The context may be class wide\n+      --  The context may be class wide, and a class-wide type is\n+      --  compatible with any member of the class.\n \n       elsif Is_Class_Wide_Type (T1)\n         and then Is_Ancestor (Root_Type (T1), T2)\n@@ -816,8 +817,8 @@ package body Sem_Type is\n       then\n          return True;\n \n-      --  Ada 2005 (AI-345): A class-wide abstract interface type T1 covers a\n-      --  task_type or protected_type implementing T1\n+      --  Ada 2005 (AI-345): A class-wide abstract interface type covers a\n+      --  task_type or protected_type that implements the interface.\n \n       elsif Ada_Version >= Ada_05\n         and then Is_Class_Wide_Type (T1)\n@@ -884,7 +885,10 @@ package body Sem_Type is\n       then\n          return True;\n \n-      --  Some contexts require a class of types rather than a specific type\n+      --  Some contexts require a class of types rather than a specific type.\n+      --  For example, conditions require any boolean type, fixed point\n+      --  attributes require some real type, etc. The built-in types Any_XXX\n+      --  represent these classes.\n \n       elsif (T1 = Any_Integer and then Is_Integer_Type (T2))\n         or else (T1 = Any_Boolean and then Is_Boolean_Type (T2))\n@@ -963,13 +967,19 @@ package body Sem_Type is\n       then\n          return Covers (Corresponding_Remote_Type (T1), T2);\n \n+      --  and conversely.\n+\n       elsif Is_Record_Type (T2)\n         and then (Is_Remote_Call_Interface (T2)\n                    or else Is_Remote_Types (T2))\n         and then Present (Corresponding_Remote_Type (T2))\n       then\n          return Covers (Corresponding_Remote_Type (T2), T1);\n \n+      --  Synchronized types are represented at run time by their corresponding\n+      --  record type. During expansion one is replaced with the other, but\n+      --  they are compatible views of the same type.\n+\n       elsif Is_Record_Type (T1)\n         and then Is_Concurrent_Type (T2)\n         and then Present (Corresponding_Record_Type (T2))\n@@ -982,9 +992,14 @@ package body Sem_Type is\n       then\n          return Covers (Corresponding_Record_Type (T1), T2);\n \n+      --  During analysis, an attribute reference 'Access has a special type\n+      --  kind: Access_Attribute_Type, to be replaced eventually with the type\n+      --  imposed by context.\n+\n       elsif Ekind (T2) = E_Access_Attribute_Type\n         and then (Ekind (BT1) = E_General_Access_Type\n-                    or else Ekind (BT1) = E_Access_Type)\n+                    or else\n+                  Ekind (BT1) = E_Access_Type)\n         and then Covers (Designated_Type (T1), Designated_Type (T2))\n       then\n          --  If the target type is a RACW type while the source is an access\n@@ -996,6 +1011,8 @@ package body Sem_Type is\n \n          return True;\n \n+      --  Ditto for allocators, which eventually resolve to the context type\n+\n       elsif Ekind (T2) = E_Allocator_Type\n         and then Is_Access_Type (T1)\n       then\n@@ -1020,7 +1037,7 @@ package body Sem_Type is\n       --  A packed array type covers its corresponding non-packed type. This is\n       --  not legitimate Ada, but allows the omission of a number of otherwise\n       --  useless unchecked conversions, and since this can only arise in\n-      --  (known correct) expanded code, no harm is done\n+      --  (known correct) expanded code, no harm is done.\n \n       elsif Is_Array_Type (T2)\n         and then Is_Packed (T2)\n@@ -1077,7 +1094,7 @@ package body Sem_Type is\n          return True;\n \n       --  Ada 2005 (AI-50217): Additional branches to make the shadow entity\n-      --  compatible with its real entity.\n+      --  obtained through a limited_with compatible with its real entity.\n \n       elsif From_With_Type (T1) then\n \n@@ -1099,7 +1116,7 @@ package body Sem_Type is\n \n          --  If units in the context have Limited_With clauses on each other,\n          --  either type might have a limited view. Checks performed elsewhere\n-         --  verify that the context type is the non-limited view.\n+         --  verify that the context type is the nonlimited view.\n \n          if Is_Incomplete_Type (T2) then\n             return Covers (T1, Get_Full_View (Non_Limited_View (T2)));\n@@ -1123,7 +1140,7 @@ package body Sem_Type is\n \n       --  Ada 2005 (AI-423): Coverage of formal anonymous access types\n       --  and actual anonymous access types in the context of generic\n-      --  instantiation. We have the following situation:\n+      --  instantiations. We have the following situation:\n \n       --     generic\n       --        type Formal is private;\n@@ -1145,7 +1162,7 @@ package body Sem_Type is\n       then\n          return True;\n \n-      --  Otherwise it doesn't cover!\n+      --  Otherwise, types are not compatible!\n \n       else\n          return False;"}]}