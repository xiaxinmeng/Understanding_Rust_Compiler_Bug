{"sha": "573e20aaca836029b309a053c8ef19367f27bdc1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTczZTIwYWFjYTgzNjAyOWIzMDlhMDUzYzhlZjE5MzY3ZjI3YmRjMQ==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-07-15T13:06:36Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-07-27T15:58:14Z"}, "message": "Abstract out (forward) jump threader state handling.\n\nThe *forward* jump threader has multiple places where it pushes and\npops state, and where it sets context up for the jump threading\nsimplifier callback.  Not only are the idioms repetitive, but the only\nreason for passing const_and_copies, avail_exprs_stack, and the evrp\nengine around are so we can set up context.\n\nAs part of my jump threading work, I will divorce the evrp engine from\nthe DOM jump threader, replacing it with a subset of the path solver I\nhave just contributed.  Since this will entail passing even more\ncontext around, I've abstracted out the state handling so it can be\npassed around in one object.  This cleans up the code, and also makes\nit trivial to set up context with another engine in the future.\n\nFWIW, I've used these cleanups and the path solver in a POC to improve\nDOM's threaded edges by an additional 5%, and the overall threading\nopportunities in the compiler by 1%.  This is in addition to the gains\nI have documented in the backwards threader rewrite.\n\nThere are no functional changes with this patch.\n\nTested on x86-64 Linux.\n\ngcc/ChangeLog:\n\n\t* tree-ssa-dom.c (dom_jump_threader_simplifier):\n\tPut avail_exprs_stack in the class, instead of passing it to\n\tjump_threader_simplifier.\n\t(dom_jump_threader_simplifier::simplify): Add state argument.\n\t(dom_opt_dom_walker): Add state.\n\t(pass_dominator::execute): Pass state to threader.\n\t(dom_opt_dom_walker::before_dom_children): Use state.\n\t* tree-ssa-threadedge.c (jump_threader::jump_threader): Replace\n\targuments by state.\n\t(jump_threader::record_temporary_equivalences_from_phis):\n\tRegister equivalences through the state variable.\n\t(jump_threader::record_temporary_equivalences_from_stmts_at_dest):\n\tRecord ranges in a statement through the state variable.\n\t(jump_threader::simplify_control_stmt_condition): Pass state to\n\tsimplify.\n\t(jump_threader::simplify_control_stmt_condition_1): Same.\n\t(jump_threader::thread_around_empty_blocks): Remove obsolete\n\tcomment.\n\t(jump_threader::thread_through_normal_block): Record equivalences\n\ton edge through the state variable.\n\t(jump_threader::thread_across_edge): Abstract state pushing.\n\t(jt_state::jt_state): New.\n\t(jt_state::push): New.\n\t(jt_state::pop): New.\n\t(jt_state::register_equiv): New.\n\t(jt_state::record_ranges_from_stmt): New.\n\t(jt_state::register_equivs_on_edge): New.\n\t(jump_threader_simplifier::jump_threader_simplifier): Move from\n\theader.\n\t(jump_threader_simplifier::simplify): Add state argument.\n\t* tree-ssa-threadedge.h (class jt_state): New.\n\t(class jump_threader): Add state to constructor.\n\t(class jump_threader_simplifier): Add state to simplify.  Remove\n\tavail_exprs_stack from class.\n\t* tree-vrp.c (vrp_jump_threader_simplifier::simplify): Add state\n\targument.\n\t(vrp_jump_threader::vrp_jump_threader): Add state.\n\t(vrp_jump_threader::~vrp_jump_threader): Cleanup state.", "tree": {"sha": "03319e23c9e231bbe65ed6e6eaa43af98c8c2970", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/03319e23c9e231bbe65ed6e6eaa43af98c8c2970"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/573e20aaca836029b309a053c8ef19367f27bdc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/573e20aaca836029b309a053c8ef19367f27bdc1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/573e20aaca836029b309a053c8ef19367f27bdc1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/573e20aaca836029b309a053c8ef19367f27bdc1/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bee2f80b901d73f50275f2b44932067ffcf616ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bee2f80b901d73f50275f2b44932067ffcf616ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bee2f80b901d73f50275f2b44932067ffcf616ca"}], "stats": {"total": 295, "additions": 172, "deletions": 123}, "files": [{"sha": "a0df492df10293329be078e2cb628796bdeb7a87", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/573e20aaca836029b309a053c8ef19367f27bdc1/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/573e20aaca836029b309a053c8ef19367f27bdc1/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=573e20aaca836029b309a053c8ef19367f27bdc1", "patch": "@@ -590,37 +590,41 @@ class dom_jump_threader_simplifier : public jump_threader_simplifier\n public:\n   dom_jump_threader_simplifier (vr_values *v,\n \t\t\t\tavail_exprs_stack *avails)\n-    : jump_threader_simplifier (v, avails) {}\n+    : jump_threader_simplifier (v), m_avail_exprs_stack (avails) { }\n \n private:\n-  tree simplify (gimple *, gimple *, basic_block);\n+  tree simplify (gimple *, gimple *, basic_block, jt_state *) override;\n+  avail_exprs_stack *m_avail_exprs_stack;\n };\n \n tree\n dom_jump_threader_simplifier::simplify (gimple *stmt,\n \t\t\t\t\tgimple *within_stmt,\n-\t\t\t\t\tbasic_block bb)\n+\t\t\t\t\tbasic_block bb,\n+\t\t\t\t\tjt_state *state)\n {\n   /* First see if the conditional is in the hash table.  */\n   tree cached_lhs =  m_avail_exprs_stack->lookup_avail_expr (stmt,\n \t\t\t\t\t\t\t     false, true);\n   if (cached_lhs)\n     return cached_lhs;\n \n-  return jump_threader_simplifier::simplify (stmt, within_stmt, bb);\n+  return jump_threader_simplifier::simplify (stmt, within_stmt, bb, state);\n }\n \n class dom_opt_dom_walker : public dom_walker\n {\n public:\n   dom_opt_dom_walker (cdi_direction direction,\n \t\t      jump_threader *threader,\n+\t\t      jt_state *state,\n \t\t      evrp_range_analyzer *analyzer,\n \t\t      const_and_copies *const_and_copies,\n \t\t      avail_exprs_stack *avail_exprs_stack)\n     : dom_walker (direction, REACHABLE_BLOCKS)\n     {\n       m_evrp_range_analyzer = analyzer;\n+      m_state = state;\n       m_dummy_cond = gimple_build_cond (NE_EXPR, integer_zero_node,\n \t\t\t\t\tinteger_zero_node, NULL, NULL);\n       m_const_and_copies = const_and_copies;\n@@ -651,6 +655,7 @@ class dom_opt_dom_walker : public dom_walker\n \n   jump_threader *m_threader;\n   evrp_range_analyzer *m_evrp_range_analyzer;\n+  jt_state *m_state;\n };\n \n /* Jump threading, redundancy elimination and const/copy propagation.\n@@ -748,10 +753,11 @@ pass_dominator::execute (function *fun)\n   /* Recursively walk the dominator tree optimizing statements.  */\n   evrp_range_analyzer analyzer (true);\n   dom_jump_threader_simplifier simplifier (&analyzer, avail_exprs_stack);\n-  jump_threader threader (const_and_copies, avail_exprs_stack,\n-\t\t\t  &simplifier, &analyzer);\n+  jt_state state (const_and_copies, avail_exprs_stack, &analyzer);\n+  jump_threader threader (&simplifier, &state);\n   dom_opt_dom_walker walker (CDI_DOMINATORS,\n \t\t\t     &threader,\n+\t\t\t     &state,\n \t\t\t     &analyzer,\n \t\t\t     const_and_copies,\n \t\t\t     avail_exprs_stack);\n@@ -1419,8 +1425,7 @@ dom_opt_dom_walker::before_dom_children (basic_block bb)\n \t  continue;\n \t}\n \n-      /* Compute range information and optimize the stmt.  */\n-      m_evrp_range_analyzer->record_ranges_from_stmt (gsi_stmt (gsi), false);\n+      m_state->record_ranges_from_stmt (gsi_stmt (gsi), false);\n       bool removed_p = false;\n       taken_edge = this->optimize_stmt (bb, &gsi, &removed_p);\n       if (!removed_p)"}, {"sha": "24ccf014416ae789576ce941729d5c0726b49aaf", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 124, "deletions": 95, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/573e20aaca836029b309a053c8ef19367f27bdc1/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/573e20aaca836029b309a053c8ef19367f27bdc1/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=573e20aaca836029b309a053c8ef19367f27bdc1", "patch": "@@ -61,10 +61,8 @@ set_ssa_name_value (tree name, tree value)\n   ssa_name_values[SSA_NAME_VERSION (name)] = value;\n }\n \n-jump_threader::jump_threader (const_and_copies *copies,\n-\t\t\t      avail_exprs_stack *avails,\n-\t\t\t      jump_threader_simplifier *simplifier,\n-\t\t\t      evrp_range_analyzer *analyzer)\n+jump_threader::jump_threader (jump_threader_simplifier *simplifier,\n+\t\t\t      jt_state *state)\n {\n   /* Initialize the per SSA_NAME value-handles array.  */\n   gcc_assert (!ssa_name_values.exists ());\n@@ -73,11 +71,9 @@ jump_threader::jump_threader (const_and_copies *copies,\n   dummy_cond = gimple_build_cond (NE_EXPR, integer_zero_node,\n \t\t\t\t  integer_zero_node, NULL, NULL);\n \n-  m_const_and_copies = copies;\n-  m_avail_exprs_stack = avails;\n   m_registry = new jump_thread_path_registry ();\n   m_simplifier = simplifier;\n-  m_evrp_range_analyzer = analyzer;\n+  m_state = state;\n }\n \n jump_threader::~jump_threader (void)\n@@ -168,41 +164,7 @@ jump_threader::record_temporary_equivalences_from_phis (edge e)\n       if (!virtual_operand_p (dst))\n \tstmt_count++;\n \n-      m_const_and_copies->record_const_or_copy (dst, src);\n-\n-      /* Also update the value range associated with DST, using\n-\t the range from SRC.\n-\n-\t Note that even if SRC is a constant we need to set a suitable\n-\t output range so that VR_UNDEFINED ranges do not leak through.  */\n-      if (m_evrp_range_analyzer)\n-\t{\n-\t  /* Get an empty new VR we can pass to update_value_range and save\n-\t     away in the VR stack.  */\n-\t  value_range_equiv *new_vr\n-\t    = m_evrp_range_analyzer->allocate_value_range_equiv ();\n-\t  new (new_vr) value_range_equiv ();\n-\n-\t  /* There are three cases to consider:\n-\n-\t       First if SRC is an SSA_NAME, then we can copy the value\n-\t       range from SRC into NEW_VR.\n-\n-\t       Second if SRC is an INTEGER_CST, then we can just wet\n-\t       NEW_VR to a singleton range.\n-\n-\t       Otherwise set NEW_VR to varying.  This may be overly\n-\t       conservative.  */\n-\t  if (TREE_CODE (src) == SSA_NAME)\n-\t    new_vr->deep_copy (m_evrp_range_analyzer->get_value_range (src));\n-\t  else if (TREE_CODE (src) == INTEGER_CST)\n-\t    new_vr->set (src);\n-\t  else\n-\t    new_vr->set_varying (TREE_TYPE (src));\n-\n-\t  /* This is a temporary range for DST, so push it.  */\n-\t  m_evrp_range_analyzer->push_value_range (dst, new_vr);\n-\t}\n+      m_state->register_equiv (dst, src, /*update_range=*/true);\n     }\n   return true;\n }\n@@ -304,10 +266,7 @@ jump_threader::record_temporary_equivalences_from_stmts_at_dest (edge e)\n \t    return NULL;\n \t}\n \n-      /* These are temporary ranges, do nto reflect them back into\n-\t the global range data.  */\n-      if (m_evrp_range_analyzer)\n-\tm_evrp_range_analyzer->record_ranges_from_stmt (stmt, true);\n+      m_state->record_ranges_from_stmt (stmt, true);\n \n       /* If this is not a statement that sets an SSA_NAME to a new\n \t value, then do not try to simplify this statement as it will\n@@ -408,7 +367,7 @@ jump_threader::record_temporary_equivalences_from_stmts_at_dest (edge e)\n \t\t    SET_USE (use_p, tmp);\n \t\t}\n \n-\t      cached_lhs = m_simplifier->simplify (stmt, stmt, e->src);\n+\t      cached_lhs = m_simplifier->simplify (stmt, stmt, e->src, m_state);\n \n \t      /* Restore the statement's original uses/defs.  */\n \t      i = 0;\n@@ -422,8 +381,7 @@ jump_threader::record_temporary_equivalences_from_stmts_at_dest (edge e)\n       if (cached_lhs\n \t  && (TREE_CODE (cached_lhs) == SSA_NAME\n \t      || is_gimple_min_invariant (cached_lhs)))\n-\tm_const_and_copies->record_const_or_copy (gimple_get_lhs (stmt),\n-\t\t\t\t\t\t  cached_lhs);\n+\tm_state->register_equiv (gimple_get_lhs (stmt), cached_lhs);\n     }\n   return stmt;\n }\n@@ -552,11 +510,12 @@ jump_threader::simplify_control_stmt_condition (edge e, gimple *stmt)\n \t\t the label that is proven to be taken.  */\n \t      gswitch *dummy_switch = as_a<gswitch *> (gimple_copy (stmt));\n \t      gimple_switch_set_index (dummy_switch, cached_lhs);\n-\t      cached_lhs = m_simplifier->simplify (dummy_switch, stmt, e->src);\n+\t      cached_lhs = m_simplifier->simplify (dummy_switch, stmt, e->src,\n+\t\t\t\t\t\t   m_state);\n \t      ggc_free (dummy_switch);\n \t    }\n \t  else\n-\t    cached_lhs = m_simplifier->simplify (stmt, stmt, e->src);\n+\t    cached_lhs = m_simplifier->simplify (stmt, stmt, e->src, m_state);\n \t}\n \n       /* We couldn't find an invariant.  But, callers of this\n@@ -733,7 +692,7 @@ jump_threader::simplify_control_stmt_condition_1\n      then use the pass specific callback to simplify the condition.  */\n   if (!res\n       || !is_gimple_min_invariant (res))\n-    res = m_simplifier->simplify (dummy_cond, stmt, e->src);\n+    res = m_simplifier->simplify (dummy_cond, stmt, e->src, m_state);\n \n   return res;\n }\n@@ -880,9 +839,7 @@ propagate_threaded_block_debug_into (basic_block dest, basic_block src)\n \n    If it is threadable, add it to PATH and VISITED and recurse, ultimately\n    returning TRUE from the toplevel call.   Otherwise do nothing and\n-   return false.\n-\n-   The available expression table is referenced via AVAIL_EXPRS_STACK.  */\n+   return false.  */\n \n bool\n jump_threader::thread_around_empty_blocks (vec<jump_thread_edge *> *path,\n@@ -997,12 +954,6 @@ jump_threader::thread_around_empty_blocks (vec<jump_thread_edge *> *path,\n    limited in that case to avoid short-circuiting the loop\n    incorrectly.\n \n-   STACK is used to undo temporary equivalences created during the walk of\n-   E->dest.\n-\n-   Our caller is responsible for restoring the state of the expression\n-   and const_and_copies stacks.\n-\n    Positive return value is success.  Zero return value is failure, but\n    the block can still be duplicated as a joiner in a jump thread path,\n    negative indicates the block should not be duplicated and thus is not\n@@ -1012,8 +963,7 @@ int\n jump_threader::thread_through_normal_block (vec<jump_thread_edge *> *path,\n \t\t\t\t\t    edge e, bitmap visited)\n {\n-  /* We want to record any equivalences created by traversing E.  */\n-  record_temporary_equivalences (e, m_const_and_copies, m_avail_exprs_stack);\n+  m_state->register_equivs_on_edge (e);\n \n   /* PHIs create temporary equivalences.\n      Note that if we found a PHI that made the block non-threadable, then\n@@ -1186,10 +1136,7 @@ jump_threader::thread_across_edge (edge e)\n {\n   bitmap visited = BITMAP_ALLOC (NULL);\n \n-  m_const_and_copies->push_marker ();\n-  m_avail_exprs_stack->push_marker ();\n-  if (m_evrp_range_analyzer)\n-    m_evrp_range_analyzer->push_marker ();\n+  m_state->push (e);\n \n   stmt_count = 0;\n \n@@ -1208,10 +1155,7 @@ jump_threader::thread_across_edge (edge e)\n     {\n       propagate_threaded_block_debug_into (path->last ()->e->dest,\n \t\t\t\t\t   e->dest);\n-      m_const_and_copies->pop_to_marker ();\n-      m_avail_exprs_stack->pop_to_marker ();\n-      if (m_evrp_range_analyzer)\n-\tm_evrp_range_analyzer->pop_to_marker ();\n+      m_state->pop ();\n       BITMAP_FREE (visited);\n       m_registry->register_jump_thread (path);\n       return;\n@@ -1234,10 +1178,7 @@ jump_threader::thread_across_edge (edge e)\n       if (threaded < 0)\n \t{\n \t  BITMAP_FREE (visited);\n-\t  m_const_and_copies->pop_to_marker ();\n-\t  m_avail_exprs_stack->pop_to_marker ();\n-\t  if (m_evrp_range_analyzer)\n-\t    m_evrp_range_analyzer->pop_to_marker ();\n+\t  m_state->pop ();\n \t  return;\n \t}\n     }\n@@ -1263,10 +1204,7 @@ jump_threader::thread_across_edge (edge e)\n     FOR_EACH_EDGE (taken_edge, ei, e->dest->succs)\n       if (taken_edge->flags & EDGE_COMPLEX)\n \t{\n-\t  m_const_and_copies->pop_to_marker ();\n-\t  m_avail_exprs_stack->pop_to_marker ();\n-\t  if (m_evrp_range_analyzer)\n-\t    m_evrp_range_analyzer->pop_to_marker ();\n+\t  m_state->pop ();\n \t  BITMAP_FREE (visited);\n \t  return;\n \t}\n@@ -1278,12 +1216,7 @@ jump_threader::thread_across_edge (edge e)\n \t    || (taken_edge->flags & EDGE_DFS_BACK) != 0)\n \t  continue;\n \n-\t/* Push a fresh marker so we can unwind the equivalences created\n-\t   for each of E->dest's successors.  */\n-\tm_const_and_copies->push_marker ();\n-\tm_avail_exprs_stack->push_marker ();\n-\tif (m_evrp_range_analyzer)\n-\t  m_evrp_range_analyzer->push_marker ();\n+\tm_state->push (taken_edge);\n \n \t/* Avoid threading to any block we have already visited.  */\n \tbitmap_clear (visited);\n@@ -1320,19 +1253,12 @@ jump_threader::thread_across_edge (edge e)\n \telse\n \t  path->release ();\n \n-\t/* And unwind the equivalence table.  */\n-\tif (m_evrp_range_analyzer)\n-\t  m_evrp_range_analyzer->pop_to_marker ();\n-\tm_avail_exprs_stack->pop_to_marker ();\n-\tm_const_and_copies->pop_to_marker ();\n+\tm_state->pop ();\n       }\n     BITMAP_FREE (visited);\n   }\n \n-  if (m_evrp_range_analyzer)\n-    m_evrp_range_analyzer->pop_to_marker ();\n-  m_const_and_copies->pop_to_marker ();\n-  m_avail_exprs_stack->pop_to_marker ();\n+  m_state->pop ();\n }\n \n /* Examine the outgoing edges from BB and conditionally\n@@ -1375,10 +1301,113 @@ jump_threader::thread_outgoing_edges (basic_block bb)\n     }\n }\n \n+jt_state::jt_state (const_and_copies *copies,\n+\t\t    avail_exprs_stack *exprs,\n+\t\t    evrp_range_analyzer *evrp)\n+{\n+  m_copies = copies;\n+  m_exprs = exprs;\n+  m_evrp = evrp;\n+}\n+\n+// Record that E is being crossed.\n+\n+void\n+jt_state::push (edge)\n+{\n+  m_copies->push_marker ();\n+  m_exprs->push_marker ();\n+  if (m_evrp)\n+    m_evrp->push_marker ();\n+}\n+\n+// Pop to the last pushed state.\n+\n+void\n+jt_state::pop ()\n+{\n+  m_copies->pop_to_marker ();\n+  m_exprs->pop_to_marker ();\n+  if (m_evrp)\n+    m_evrp->pop_to_marker ();\n+}\n+\n+// Record an equivalence from DST to SRC.  If UPDATE_RANGE is TRUE,\n+// update the value range associated with DST.\n+\n+void\n+jt_state::register_equiv (tree dst, tree src, bool update_range)\n+{\n+  m_copies->record_const_or_copy (dst, src);\n+\n+  /* If requested, update the value range associated with DST, using\n+     the range from SRC.  */\n+  if (m_evrp && update_range)\n+    {\n+      /* Get new VR we can pass to push_value_range.  */\n+      value_range_equiv *new_vr = m_evrp->allocate_value_range_equiv ();\n+      new (new_vr) value_range_equiv ();\n+\n+      /* There are three cases to consider:\n+\n+\t First if SRC is an SSA_NAME, then we can copy the value range\n+\t from SRC into NEW_VR.\n+\n+\t Second if SRC is an INTEGER_CST, then we can just set NEW_VR\n+\t to a singleton range.  Note that even if SRC is a constant we\n+\t need to set a suitable output range so that VR_UNDEFINED\n+\t ranges do not leak through.\n+\n+\t Otherwise set NEW_VR to varying.  This may be overly\n+\t conservative.  */\n+      if (TREE_CODE (src) == SSA_NAME)\n+\tnew_vr->deep_copy (m_evrp->get_value_range (src));\n+      else if (TREE_CODE (src) == INTEGER_CST)\n+\tnew_vr->set (src);\n+      else\n+\tnew_vr->set_varying (TREE_TYPE (src));\n+\n+      /* This is a temporary range for DST, so push it.  */\n+      m_evrp->push_value_range (dst, new_vr);\n+    }\n+}\n+\n+// Record any ranges calculated in STMT.  If TEMPORARY is TRUE, then\n+// this is a temporary equivalence and should be recorded into the\n+// unwind table, instead of the global table.\n+\n+void\n+jt_state::record_ranges_from_stmt (gimple *stmt, bool temporary)\n+{\n+  if (m_evrp)\n+    m_evrp->record_ranges_from_stmt (stmt, temporary);\n+}\n+\n+// Record any equivalences created by traversing E.\n+\n+void\n+jt_state::register_equivs_on_edge (edge e)\n+{\n+  record_temporary_equivalences (e, m_copies, m_exprs);\n+}\n+\n+jump_threader_simplifier::jump_threader_simplifier (vr_values *v)\n+{\n+  m_vr_values = v;\n+}\n+\n+// Return the singleton that resolves STMT, if it is possible to\n+// simplify it.\n+//\n+// STMT may be a dummy statement, not necessarily in the CFG, in which\n+// case WITHIN_STMT can be used to determine the position in the CFG\n+// where STMT should be evaluated as being in.\n+\n tree\n jump_threader_simplifier::simplify (gimple *stmt,\n \t\t\t\t    gimple *within_stmt,\n-\t\t\t\t    basic_block)\n+\t\t\t\t    basic_block,\n+\t\t\t\t    jt_state *)\n {\n   if (gcond *cond_stmt = dyn_cast <gcond *> (stmt))\n     {"}, {"sha": "c0d3c921e0f9ee6bb1860fd1a8e29c3785001230", "filename": "gcc/tree-ssa-threadedge.h", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/573e20aaca836029b309a053c8ef19367f27bdc1/gcc%2Ftree-ssa-threadedge.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/573e20aaca836029b309a053c8ef19367f27bdc1/gcc%2Ftree-ssa-threadedge.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.h?ref=573e20aaca836029b309a053c8ef19367f27bdc1", "patch": "@@ -20,6 +20,27 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_TREE_SSA_THREADEDGE_H\n #define GCC_TREE_SSA_THREADEDGE_H\n \n+// Class used to maintain path state in the jump threader and pass it\n+// to the jump threader simplifier.\n+\n+class jt_state\n+{\n+public:\n+  jt_state (class const_and_copies *,\n+\t    class avail_exprs_stack *,\n+\t    class evrp_range_analyzer *);\n+  void push (edge);\n+  void pop ();\n+  void register_equiv (tree dest, tree src, bool update_range = false);\n+  void register_equivs_on_edge (edge e);\n+  void record_ranges_from_stmt (gimple *stmt, bool temporary);\n+\n+private:\n+  const_and_copies *m_copies;\n+  avail_exprs_stack *m_exprs;\n+  evrp_range_analyzer *m_evrp;\n+};\n+\n // This is the high level threader.  The entry point is\n // thread_outgoing_edges(), which calculates and registers paths to be\n // threaded.  When all candidates have been registered,\n@@ -28,10 +49,7 @@ along with GCC; see the file COPYING3.  If not see\n class jump_threader\n {\n public:\n-  jump_threader (class const_and_copies *,\n-\t\t avail_exprs_stack *,\n-\t\t class jump_threader_simplifier *,\n-\t\t class evrp_range_analyzer * = NULL);\n+  jump_threader (class jump_threader_simplifier *, class jt_state *);\n   ~jump_threader ();\n   void thread_outgoing_edges (basic_block);\n   void remove_jump_threads_including (edge_def *);\n@@ -57,29 +75,22 @@ class jump_threader\n   // Dummy condition to avoid creating lots of throw away statements.\n   gcond *dummy_cond;\n \n-  const_and_copies *m_const_and_copies;\n-  avail_exprs_stack *m_avail_exprs_stack;\n   class jump_thread_path_registry *m_registry;\n   jump_threader_simplifier *m_simplifier;\n-  evrp_range_analyzer *m_evrp_range_analyzer;\n+  jt_state *m_state;\n };\n \n // Statement simplifier callback for the jump threader.\n \n class jump_threader_simplifier\n {\n public:\n-  jump_threader_simplifier (class vr_values *v,\n-\t\t\t    avail_exprs_stack *avails)\n-    : m_vr_values (v),\n-      m_avail_exprs_stack (avails)\n-  { }\n+  jump_threader_simplifier (class vr_values *v);\n   virtual ~jump_threader_simplifier () { }\n-  virtual tree simplify (gimple *, gimple *, basic_block);\n+  virtual tree simplify (gimple *, gimple *, basic_block, jt_state *);\n \n protected:\n   vr_values *m_vr_values;\n-  avail_exprs_stack *m_avail_exprs_stack;\n };\n \n extern void propagate_threaded_block_debug_into (basic_block, basic_block);"}, {"sha": "d1b6910fcbba0ef33d4bdeb30a5a477ac9b1b98c", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/573e20aaca836029b309a053c8ef19367f27bdc1/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/573e20aaca836029b309a053c8ef19367f27bdc1/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=573e20aaca836029b309a053c8ef19367f27bdc1", "patch": "@@ -4165,16 +4165,18 @@ class vrp_jump_threader_simplifier : public jump_threader_simplifier\n {\n public:\n   vrp_jump_threader_simplifier (vr_values *v, avail_exprs_stack *avails)\n-    : jump_threader_simplifier (v, avails) {}\n+    : jump_threader_simplifier (v), m_avail_exprs_stack (avails) { }\n \n private:\n-  tree simplify (gimple *, gimple *, basic_block) OVERRIDE;\n+  tree simplify (gimple *, gimple *, basic_block, jt_state *) OVERRIDE;\n+  avail_exprs_stack *m_avail_exprs_stack;\n };\n \n tree\n vrp_jump_threader_simplifier::simplify (gimple *stmt,\n \t\t\t\t\tgimple *within_stmt,\n-\t\t\t\t\tbasic_block bb)\n+\t\t\t\t\tbasic_block bb,\n+\t\t\t\t\tjt_state *state)\n {\n   /* First see if the conditional is in the hash table.  */\n   tree cached_lhs = m_avail_exprs_stack->lookup_avail_expr (stmt, false, true);\n@@ -4206,7 +4208,7 @@ vrp_jump_threader_simplifier::simplify (gimple *stmt,\n       return find_case_label_range (switch_stmt, vr);\n     }\n \n-  return jump_threader_simplifier::simplify (stmt, within_stmt, bb);\n+  return jump_threader_simplifier::simplify (stmt, within_stmt, bb, state);\n }\n \n /* Blocks which have more than one predecessor and more than\n@@ -4257,6 +4259,7 @@ class vrp_jump_threader : public dom_walker\n   hash_table<expr_elt_hasher> *m_avail_exprs;\n   vrp_jump_threader_simplifier *m_simplifier;\n   jump_threader *m_threader;\n+  jt_state *m_state;\n };\n \n vrp_jump_threader::vrp_jump_threader (struct function *fun, vr_values *v)\n@@ -4282,11 +4285,11 @@ vrp_jump_threader::vrp_jump_threader (struct function *fun, vr_values *v)\n   m_vr_values = v;\n   m_avail_exprs = new hash_table<expr_elt_hasher> (1024);\n   m_avail_exprs_stack = new avail_exprs_stack (m_avail_exprs);\n+  m_state = new jt_state (m_const_and_copies, m_avail_exprs_stack, NULL);\n \n   m_simplifier = new vrp_jump_threader_simplifier (m_vr_values,\n \t\t\t\t\t\t   m_avail_exprs_stack);\n-  m_threader = new jump_threader (m_const_and_copies, m_avail_exprs_stack,\n-\t\t\t\t  m_simplifier);\n+  m_threader = new jump_threader (m_simplifier, m_state);\n }\n \n vrp_jump_threader::~vrp_jump_threader ()\n@@ -4299,6 +4302,7 @@ vrp_jump_threader::~vrp_jump_threader ()\n   delete m_avail_exprs_stack;\n   delete m_simplifier;\n   delete m_threader;\n+  delete m_state;\n }\n \n /* Called before processing dominator children of BB.  We want to look"}]}