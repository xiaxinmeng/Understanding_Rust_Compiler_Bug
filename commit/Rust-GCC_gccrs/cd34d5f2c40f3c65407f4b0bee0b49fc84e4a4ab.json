{"sha": "cd34d5f2c40f3c65407f4b0bee0b49fc84e4a4ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2QzNGQ1ZjJjNDBmM2M2NTQwN2Y0YjBiZWUwYjQ5ZmM4NGU0YTRhYg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-12-02T02:59:18Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-12-03T16:21:02Z"}, "message": "compiler: defer to middle-end for complex division\n\nGo used to use slightly different semantics than C99 for complex division,\nso we used runtime routines to handle the different.  The gc compiler\nhas changes its behavior to match C99, so changes ours as well.\n\nFor golang/go#14644\n\nReviewed-on: https://go-review.googlesource.com/c/gofrontend/+/274213", "tree": {"sha": "843df1c1321bbc66e1bee850fa8513c54dd25dc8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/843df1c1321bbc66e1bee850fa8513c54dd25dc8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd34d5f2c40f3c65407f4b0bee0b49fc84e4a4ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd34d5f2c40f3c65407f4b0bee0b49fc84e4a4ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd34d5f2c40f3c65407f4b0bee0b49fc84e4a4ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd34d5f2c40f3c65407f4b0bee0b49fc84e4a4ab/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65af6bc9f87bc6b329fb7a16e3f736dd0a042bf5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65af6bc9f87bc6b329fb7a16e3f736dd0a042bf5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65af6bc9f87bc6b329fb7a16e3f736dd0a042bf5"}], "stats": {"total": 6719, "additions": 4176, "deletions": 2543}, "files": [{"sha": "f55daf7562cf1adf7f86f71cef46ff2aa7abb3de", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd34d5f2c40f3c65407f4b0bee0b49fc84e4a4ab/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd34d5f2c40f3c65407f4b0bee0b49fc84e4a4ab/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=cd34d5f2c40f3c65407f4b0bee0b49fc84e4a4ab", "patch": "@@ -1,4 +1,4 @@\n-6b01f8cdc11d86bd98165c91d6ae101bcf6b9e1a\n+5364d15082de77d2759a01f254208d4cb4f579e3\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "50574c2bc582b7d11d1ad02bb54cc839df3165c3", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd34d5f2c40f3c65407f4b0bee0b49fc84e4a4ab/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd34d5f2c40f3c65407f4b0bee0b49fc84e4a4ab/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=cd34d5f2c40f3c65407f4b0bee0b49fc84e4a4ab", "patch": "@@ -6979,27 +6979,6 @@ Binary_expression::do_get_backend(Translate_context* context)\n   // been converted to a String_concat_expression in do_lower.\n   go_assert(!left_type->is_string_type());\n \n-  // For complex division Go might want slightly different results than the\n-  // backend implementation provides, so we have our own runtime routine.\n-  if (this->op_ == OPERATOR_DIV && this->left_->type()->complex_type() != NULL)\n-    {\n-      Runtime::Function complex_code;\n-      switch (this->left_->type()->complex_type()->bits())\n-\t{\n-\tcase 64:\n-          complex_code = Runtime::COMPLEX64_DIV;\n-\t  break;\n-\tcase 128:\n-          complex_code = Runtime::COMPLEX128_DIV;\n-\t  break;\n-\tdefault:\n-\t  go_unreachable();\n-\t}\n-      Expression* complex_div =\n-          Runtime::make_call(complex_code, loc, 2, this->left_, this->right_);\n-      return complex_div->get_backend(context);\n-    }\n-\n   Bexpression* left = this->left_->get_backend(context);\n   Bexpression* right = this->right_->get_backend(context);\n "}, {"sha": "4b606a6c00c6f6922978013f35c3ffb0068d1f54", "filename": "gcc/go/gofrontend/runtime.def", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd34d5f2c40f3c65407f4b0bee0b49fc84e4a4ab/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd34d5f2c40f3c65407f4b0bee0b49fc84e4a4ab/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.def?ref=cd34d5f2c40f3c65407f4b0bee0b49fc84e4a4ab", "patch": "@@ -62,12 +62,6 @@ DEF_GO_RUNTIME(STRINGTOSLICERUNE, \"runtime.stringtoslicerune\",\n \t       P2(POINTER, STRING), R1(SLICE))\n \n \n-// Complex division.\n-DEF_GO_RUNTIME(COMPLEX64_DIV, \"__go_complex64_div\",\n-\t       P2(COMPLEX64, COMPLEX64), R1(COMPLEX64))\n-DEF_GO_RUNTIME(COMPLEX128_DIV, \"__go_complex128_div\",\n-\t       P2(COMPLEX128, COMPLEX128), R1(COMPLEX128))\n-\n // Make a slice.\n DEF_GO_RUNTIME(MAKESLICE, \"runtime.makeslice\", P3(TYPE, INT, INT),\n \t       R1(POINTER))"}, {"sha": "89a2868b75bdb249b905f4243cd5c1f8485569a8", "filename": "gcc/testsuite/go.test/test/cmplxdivide.c", "status": "modified", "additions": 51, "deletions": 36, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd34d5f2c40f3c65407f4b0bee0b49fc84e4a4ab/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcmplxdivide.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd34d5f2c40f3c65407f4b0bee0b49fc84e4a4ab/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcmplxdivide.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcmplxdivide.c?ref=cd34d5f2c40f3c65407f4b0bee0b49fc84e4a4ab", "patch": "@@ -1,8 +1,19 @@\n-// Copyright 2010 The Go Authors.  All rights reserved.\n+// Copyright 2010 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// gcc '-std=c99' cmplxdivide.c && a.out >cmplxdivide1.go\n+// This C program generates the file cmplxdivide1.go. It uses the\n+// output of the operations by C99 as the reference to check\n+// the implementation of complex numbers in Go.\n+// The generated file, cmplxdivide1.go, is compiled along\n+// with the driver cmplxdivide.go (the names are confusing\n+// and unimaginative) to run the actual test. This is done by\n+// the usual test runner.\n+//\n+// The file cmplxdivide1.go is checked in to the repository, but\n+// if it needs to be regenerated, compile and run this C program\n+// like this:\n+//\tgcc '-std=c99' cmplxdivide.c && a.out >cmplxdivide1.go\n \n #include <complex.h>\n #include <math.h>\n@@ -12,68 +23,72 @@\n #define nelem(x) (sizeof(x)/sizeof((x)[0]))\n \n double f[] = {\n-\t0,\n-\t1,\n-\t-1,\n-\t2,\n+\t0.0,\n+\t-0.0,\n+\t1.0,\n+\t-1.0,\n+\t2.0,\n \tNAN,\n \tINFINITY,\n \t-INFINITY,\n };\n \n-char*\n-fmt(double g)\n-{\n+char* fmt(double g) {\n \tstatic char buf[10][30];\n \tstatic int n;\n \tchar *p;\n-\t\n+\n \tp = buf[n++];\n-\tif(n == 10)\n+\tif(n == 10) {\n \t\tn = 0;\n+\t}\n+\n \tsprintf(p, \"%g\", g);\n-\tif(strcmp(p, \"-0\") == 0)\n-\t\tstrcpy(p, \"negzero\");\n-\treturn p;\n-}\n \n-int\n-iscnan(double complex d)\n-{\n-\treturn !isinf(creal(d)) && !isinf(cimag(d)) && (isnan(creal(d)) || isnan(cimag(d)));\n-}\n+\tif(strcmp(p, \"0\") == 0) {\n+\t\tstrcpy(p, \"zero\");\n+\t\treturn p;\n+\t}\n+\n+\tif(strcmp(p, \"-0\") == 0) {\n+\t\tstrcpy(p, \"-zero\");\n+\t\treturn p;\n+\t}\n \n-double complex zero;\t// attempt to hide zero division from gcc\n+\treturn p;\n+}\n \n-int\n-main(void)\n-{\n+int main(void) {\n \tint i, j, k, l;\n \tdouble complex n, d, q;\n-\t\n+\n \tprintf(\"// skip\\n\");\n \tprintf(\"// # generated by cmplxdivide.c\\n\");\n \tprintf(\"\\n\");\n \tprintf(\"package main\\n\");\n-\tprintf(\"var tests = []Test{\\n\");\n+\tprintf(\"\\n\");\n+\tprintf(\"import \\\"math\\\"\\n\");\n+\tprintf(\"\\n\");\n+\tprintf(\"var (\\n\");\n+\tprintf(\"\\tnan     = math.NaN()\\n\");\n+\tprintf(\"\\tinf     = math.Inf(1)\\n\");\n+\tprintf(\"\\tzero    = 0.0\\n\");\n+\tprintf(\")\\n\");\n+\tprintf(\"\\n\");\n+\tprintf(\"var tests = []struct {\\n\");\n+\tprintf(\"\\tf, g complex128\\n\");\n+\tprintf(\"\\tout  complex128\\n\");\n+\tprintf(\"}{\\n\");\n+\n \tfor(i=0; i<nelem(f); i++)\n \tfor(j=0; j<nelem(f); j++)\n \tfor(k=0; k<nelem(f); k++)\n \tfor(l=0; l<nelem(f); l++) {\n \t\tn = f[i] + f[j]*I;\n \t\td = f[k] + f[l]*I;\n \t\tq = n/d;\n-\t\t\n-\t\t// BUG FIX.\n-\t\t// Gcc gets the wrong answer for NaN/0 unless both sides are NaN.\n-\t\t// That is, it treats (NaN+NaN*I)/0 = NaN+NaN*I (a complex NaN)\n-\t\t// but it then computes (1+NaN*I)/0 = Inf+NaN*I (a complex infinity).\n-\t\t// Since both numerators are complex NaNs, it seems that the\n-\t\t// results should agree in kind.  Override the gcc computation in this case.\n-\t\tif(iscnan(n) && d == 0)\n-\t\t\tq = (NAN+NAN*I) / zero;\n \n-\t\tprintf(\"\\tTest{complex(%s, %s), complex(%s, %s), complex(%s, %s)},\\n\",\n+\t\tprintf(\"\\t{complex(%s, %s), complex(%s, %s), complex(%s, %s)},\\n\",\n \t\t\tfmt(creal(n)), fmt(cimag(n)),\n \t\t\tfmt(creal(d)), fmt(cimag(d)),\n \t\t\tfmt(creal(q)), fmt(cimag(q)));"}, {"sha": "49cd5bf5824755e8696586d2d950956192909192", "filename": "gcc/testsuite/go.test/test/cmplxdivide.go", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd34d5f2c40f3c65407f4b0bee0b49fc84e4a4ab/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcmplxdivide.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd34d5f2c40f3c65407f4b0bee0b49fc84e4a4ab/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcmplxdivide.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcmplxdivide.go?ref=cd34d5f2c40f3c65407f4b0bee0b49fc84e4a4ab", "patch": "@@ -1,36 +1,29 @@\n // run cmplxdivide1.go\n \n-// Copyright 2010 The Go Authors.  All rights reserved.\n+// Copyright 2010 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n // Driver for complex division table defined in cmplxdivide1.go\n+// For details, see the comment at the top of cmplxdivide.c.\n \n package main\n \n import (\n \t\"fmt\"\n \t\"math\"\n-\t\"math/cmplx\"\n )\n \n-type Test struct {\n-\tf, g complex128\n-\tout  complex128\n-}\n-\n-var nan = math.NaN()\n-var inf = math.Inf(1)\n-var negzero = math.Copysign(0, -1)\n-\n func calike(a, b complex128) bool {\n-\tswitch {\n-\tcase cmplx.IsInf(a) && cmplx.IsInf(b):\n-\t\treturn true\n-\tcase cmplx.IsNaN(a) && cmplx.IsNaN(b):\n-\t\treturn true\n+\tif imag(a) != imag(b) && !(math.IsNaN(imag(a)) && math.IsNaN(imag(b))) {\n+\t\treturn false\n \t}\n-\treturn a == b\n+\n+\tif real(a) != real(b) && !(math.IsNaN(real(a)) && math.IsNaN(real(b))) {\n+\t\treturn false\n+\t}\n+\n+\treturn true\n }\n \n func main() {"}, {"sha": "a52fb6fbcf706cc3b995e6f5ed0ba792b047d2c4", "filename": "gcc/testsuite/go.test/test/cmplxdivide1.go", "status": "modified", "additions": 4109, "deletions": 2402, "changes": 6511, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd34d5f2c40f3c65407f4b0bee0b49fc84e4a4ab/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcmplxdivide1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd34d5f2c40f3c65407f4b0bee0b49fc84e4a4ab/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcmplxdivide1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcmplxdivide1.go?ref=cd34d5f2c40f3c65407f4b0bee0b49fc84e4a4ab"}, {"sha": "4d3e54e92257ae01c68448c6c500d63d24cf8862", "filename": "libgo/Makefile.am", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd34d5f2c40f3c65407f4b0bee0b49fc84e4a4ab/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd34d5f2c40f3c65407f4b0bee0b49fc84e4a4ab/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=cd34d5f2c40f3c65407f4b0bee0b49fc84e4a4ab", "patch": "@@ -439,7 +439,6 @@ runtime_files = \\\n \truntime/go-assert.c \\\n \truntime/go-caller.c \\\n \truntime/go-callers.c \\\n-\truntime/go-cdiv.c \\\n \truntime/go-cgo.c \\\n \truntime/go-construct-map.c \\\n \truntime/go-ffi.c \\"}, {"sha": "d6ac066df411b95283b03944976f751bc292a40b", "filename": "libgo/Makefile.in", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd34d5f2c40f3c65407f4b0bee0b49fc84e4a4ab/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd34d5f2c40f3c65407f4b0bee0b49fc84e4a4ab/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=cd34d5f2c40f3c65407f4b0bee0b49fc84e4a4ab", "patch": "@@ -240,12 +240,11 @@ am__objects_2 = $(am__objects_1)\n @LIBGO_IS_RTEMS_TRUE@am__objects_3 =  \\\n @LIBGO_IS_RTEMS_TRUE@\truntime/rtems-task-variable-add.lo\n am__objects_4 = runtime/aeshash.lo runtime/go-assert.lo \\\n-\truntime/go-caller.lo runtime/go-callers.lo runtime/go-cdiv.lo \\\n-\truntime/go-cgo.lo runtime/go-construct-map.lo \\\n-\truntime/go-ffi.lo runtime/go-fieldtrack.lo \\\n-\truntime/go-matherr.lo runtime/go-memclr.lo \\\n-\truntime/go-memequal.lo runtime/go-nanotime.lo \\\n-\truntime/go-now.lo runtime/go-nosys.lo \\\n+\truntime/go-caller.lo runtime/go-callers.lo runtime/go-cgo.lo \\\n+\truntime/go-construct-map.lo runtime/go-ffi.lo \\\n+\truntime/go-fieldtrack.lo runtime/go-matherr.lo \\\n+\truntime/go-memclr.lo runtime/go-memequal.lo \\\n+\truntime/go-nanotime.lo runtime/go-now.lo runtime/go-nosys.lo \\\n \truntime/go-reflect-call.lo runtime/go-setenv.lo \\\n \truntime/go-signal.lo runtime/go-unsafe-pointer.lo \\\n \truntime/go-unsetenv.lo runtime/go-unwind.lo \\\n@@ -892,7 +891,6 @@ runtime_files = \\\n \truntime/go-assert.c \\\n \truntime/go-caller.c \\\n \truntime/go-callers.c \\\n-\truntime/go-cdiv.c \\\n \truntime/go-cgo.c \\\n \truntime/go-construct-map.c \\\n \truntime/go-ffi.c \\\n@@ -1343,8 +1341,6 @@ runtime/go-caller.lo: runtime/$(am__dirstamp) \\\n \truntime/$(DEPDIR)/$(am__dirstamp)\n runtime/go-callers.lo: runtime/$(am__dirstamp) \\\n \truntime/$(DEPDIR)/$(am__dirstamp)\n-runtime/go-cdiv.lo: runtime/$(am__dirstamp) \\\n-\truntime/$(DEPDIR)/$(am__dirstamp)\n runtime/go-cgo.lo: runtime/$(am__dirstamp) \\\n \truntime/$(DEPDIR)/$(am__dirstamp)\n runtime/go-construct-map.lo: runtime/$(am__dirstamp) \\\n@@ -1417,7 +1413,6 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@runtime/$(DEPDIR)/go-assert.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@runtime/$(DEPDIR)/go-caller.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@runtime/$(DEPDIR)/go-callers.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@runtime/$(DEPDIR)/go-cdiv.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@runtime/$(DEPDIR)/go-cgo.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@runtime/$(DEPDIR)/go-construct-map.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@runtime/$(DEPDIR)/go-context.Plo@am__quote@"}, {"sha": "0355e26fc8ed2a955bddc7dcd41e180d33691f66", "filename": "libgo/runtime/go-cdiv.c", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65af6bc9f87bc6b329fb7a16e3f736dd0a042bf5/libgo%2Fruntime%2Fgo-cdiv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65af6bc9f87bc6b329fb7a16e3f736dd0a042bf5/libgo%2Fruntime%2Fgo-cdiv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-cdiv.c?ref=65af6bc9f87bc6b329fb7a16e3f736dd0a042bf5", "patch": "@@ -1,49 +0,0 @@\n-/* go-cdiv.c -- complex division routines\n-\n-   Copyright 2013 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include <complex.h>\n-#include <math.h>\n-\n-/* Calls to these functions are generated by the Go frontend for\n-   division of complex64 or complex128.  We use these because Go's\n-   complex division expects slightly different results from the GCC\n-   default.  When dividing NaN+1.0i / 0+0i, Go expects NaN+NaNi but\n-   GCC generates NaN+Infi.  NaN+Infi seems wrong seems the rules of\n-   C99 Annex G specify that if either side of a complex number is Inf,\n-   the the whole number is Inf, but an operation involving NaN ought\n-   to result in NaN, not Inf.  */\n-\n-complex float\n-__go_complex64_div (complex float a, complex float b)\n-{\n-  if (__builtin_expect (b == 0, 0))\n-    {\n-      if (!isinf (crealf (a))\n-\t  && !isinf (cimagf (a))\n-\t  && (isnan (crealf (a)) || isnan (cimagf (a))))\n-\t{\n-\t  /* Pass \"1\" to nanf to match math/bits.go.  */\n-\t  return nanf(\"1\") + nanf(\"1\")*I;\n-\t}\n-    }\n-  return a / b;\n-}\n-\n-complex double\n-__go_complex128_div (complex double a, complex double b)\n-{\n-  if (__builtin_expect (b == 0, 0))\n-    {\n-      if (!isinf (creal (a))\n-\t  && !isinf (cimag (a))\n-\t  && (isnan (creal (a)) || isnan (cimag (a))))\n-\t{\n-\t  /* Pass \"1\" to nan to match math/bits.go.  */\n-\t  return nan(\"1\") + nan(\"1\")*I;\n-\t}\n-    }\n-  return a / b;\n-}"}]}