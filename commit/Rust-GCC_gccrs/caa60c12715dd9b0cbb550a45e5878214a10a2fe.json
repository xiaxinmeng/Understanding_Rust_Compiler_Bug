{"sha": "caa60c12715dd9b0cbb550a45e5878214a10a2fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2FhNjBjMTI3MTVkZDliMGNiYjU1MGE0NWU1ODc4MjE0YTEwYTJmZQ==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-05-26T06:40:17Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-06-03T15:47:27Z"}, "message": "Implement generic expression evaluator for range_query.\n\nRight now, range_of_expr only works with constants, SSA names, and\npointers.  Anything else gets returned as VARYING.  This patch adds the\ncapability to deal with arbitrary expressions, inasmuch as these\ntree codes are implemented in range-ops.cc.\n\nThis will give us the ability to ask for the range of any tree expression,\nnot just constants and SSA names, with range_of_expr().\n\nThis is a more generic implementation of determine_value_range in VRP.\nA follow-up patch will remove all uses of it in favor of the\nrange_query API.\n\ngcc/ChangeLog:\n\n\t* function-tests.c (test_ranges): Call gimple_range_tests.\n\t* gimple-range-cache.cc (ranger_cache::range_of_expr): Pass stmt\n\tto get_tree_range.\n\t* gimple-range.cc (fur_source::get_operand): Do not call\n\tget_tree_range or gimple_range_global.\n\tget_tree_range.\n\t(get_tree_range): Move to value-query.cc.\n\tCall get_arith_expr_range.\n\t(gimple_ranger::range_of_expr): Add argument to get_tree_range.\n\tInclude gimple-range-tests.cc.\n\t* gimple-range.h (fold_range): Add argument.\n\t(get_tree_range): Remove.\n\t* selftest.h (gimple_range_tests): New.\n\t* value-query.cc (global_range_query::range_of_expr): Add\n\tstmt argument.\n\t(range_query::get_tree_range): Move from gimple-range.cc.\n\t* value-query.h (class range_query): Add get_tree_range and\n\tget_arith_expr_range.  Make fur_source a friend.\n\t* vr-values.c (vr_values::range_of_expr): Pass stmt to\n\tget_tree_range.\n\t* gimple-range-tests.cc: New file.", "tree": {"sha": "54782e0a2bb50af3fc37acb46e787a0de7c9298f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/54782e0a2bb50af3fc37acb46e787a0de7c9298f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/caa60c12715dd9b0cbb550a45e5878214a10a2fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/caa60c12715dd9b0cbb550a45e5878214a10a2fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/caa60c12715dd9b0cbb550a45e5878214a10a2fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/caa60c12715dd9b0cbb550a45e5878214a10a2fe/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be54520ea0422f4b5468cbbcf139be7e3a6cdeea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be54520ea0422f4b5468cbbcf139be7e3a6cdeea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be54520ea0422f4b5468cbbcf139be7e3a6cdeea"}], "stats": {"total": 241, "additions": 172, "deletions": 69}, "files": [{"sha": "0ac1d37f8ffbe0681164986ca3c4bcbf6b93d746", "filename": "gcc/function-tests.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caa60c12715dd9b0cbb550a45e5878214a10a2fe/gcc%2Ffunction-tests.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caa60c12715dd9b0cbb550a45e5878214a10a2fe/gcc%2Ffunction-tests.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction-tests.c?ref=caa60c12715dd9b0cbb550a45e5878214a10a2fe", "patch": "@@ -581,6 +581,11 @@ test_ranges ()\n   push_cfun (fun);\n   range_tests ();\n   range_op_tests ();\n+\n+  build_cfg (fndecl);\n+  convert_to_ssa (fndecl);\n+  gimple_range_tests ();\n+\n   pop_cfun ();\n }\n "}, {"sha": "c58acf48dfb3ea2b6b6731f7c2ccbac0ec915bae", "filename": "gcc/gimple-range-cache.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caa60c12715dd9b0cbb550a45e5878214a10a2fe/gcc%2Fgimple-range-cache.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caa60c12715dd9b0cbb550a45e5878214a10a2fe/gcc%2Fgimple-range-cache.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.cc?ref=caa60c12715dd9b0cbb550a45e5878214a10a2fe", "patch": "@@ -827,7 +827,7 @@ ranger_cache::range_of_expr (irange &r, tree name, gimple *stmt)\n {\n   if (!gimple_range_ssa_p (name))\n     {\n-      get_tree_range (r, name);\n+      get_tree_range (r, name, stmt);\n       return true;\n     }\n \n@@ -860,7 +860,7 @@ ranger_cache::range_of_expr (irange &r, tree name, gimple *stmt)\n \t}\n     }\n   else\n-    get_tree_range (r, expr);\n+    get_tree_range (r, expr, NULL);\n   return false;\n }\n "}, {"sha": "9ee4c5aa6cd4dbc2f947c597f37bfad2e4715276", "filename": "gcc/gimple-range-tests.cc", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caa60c12715dd9b0cbb550a45e5878214a10a2fe/gcc%2Fgimple-range-tests.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caa60c12715dd9b0cbb550a45e5878214a10a2fe/gcc%2Fgimple-range-tests.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-tests.cc?ref=caa60c12715dd9b0cbb550a45e5878214a10a2fe", "patch": "@@ -0,0 +1,72 @@\n+/* Unit tests for GIMPLE range related routines.\n+   Copyright (C) 2021 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#if CHECKING_P\n+\n+#include \"selftest.h\"\n+\n+namespace selftest {\n+\n+// Test ranges of tree expressions.\n+class test_expr_eval : public gimple_ranger\n+{\n+public:\n+  test_expr_eval ()\n+  {\n+    type = integer_type_node;\n+    op0 = make_ssa_name (type);\n+    op1 = make_ssa_name (type);\n+\n+    // [5,10] + [15,20] => [20, 30]\n+    tree expr = fold_build2 (PLUS_EXPR, type, op0, op1);\n+    int_range<2> expect (build_int_cst (type, 20), build_int_cst (type, 30));\n+    int_range_max r;\n+\n+    ASSERT_TRUE (range_of_expr (r, expr));\n+    ASSERT_TRUE (r == expect);\n+  }\n+\n+  virtual bool range_of_expr (irange &r, tree expr, gimple * = NULL) OVERRIDE\n+  {\n+    if (expr == op0)\n+      {\n+\tr.set (build_int_cst (type, 5), build_int_cst (type, 10));\n+\treturn true;\n+      }\n+    if (expr == op1)\n+      {\n+\tr.set (build_int_cst (type, 15), build_int_cst (type, 20));\n+\treturn true;\n+      }\n+    return gimple_ranger::range_of_expr (r, expr);\n+  }\n+\n+private:\n+  tree op0, op1, type;\n+};\n+\n+void\n+gimple_range_tests ()\n+{\n+  test_expr_eval e;\n+}\n+\n+} // namespace selftest\n+\n+#endif // CHECKING_P"}, {"sha": "db8419bc4c6d356b48c80d2f443d1dda52cdfa24", "filename": "gcc/gimple-range.cc", "status": "modified", "additions": 3, "deletions": 61, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caa60c12715dd9b0cbb550a45e5878214a10a2fe/gcc%2Fgimple-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caa60c12715dd9b0cbb550a45e5878214a10a2fe/gcc%2Fgimple-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.cc?ref=caa60c12715dd9b0cbb550a45e5878214a10a2fe", "patch": "@@ -54,16 +54,6 @@ along with GCC; see the file COPYING3.  If not see\n bool\n fur_source::get_operand (irange &r, tree expr)\n {\n-  if (!gimple_range_ssa_p (expr))\n-    return get_tree_range (r, expr);\n-\n-  // If no query engine is present, simply get the global value.\n-  if (!m_query)\n-    {\n-       r = gimple_range_global (expr);\n-       return true;\n-    }\n-\n   // First look for a stmt.\n   if (m_stmt)\n     return m_query->range_of_expr (r, expr, m_stmt);\n@@ -168,56 +158,6 @@ gimple_range_adjustment (irange &res, const gimple *stmt)\n     }\n }\n \n-// Return a range in R for the tree EXPR.  Return true if a range is\n-// representable, and UNDEFINED/false if not.\n-\n-bool\n-get_tree_range (irange &r, tree expr)\n-{\n-  tree type;\n-  if (TYPE_P (expr))\n-    type = expr;\n-  else\n-    type = TREE_TYPE (expr);\n-\n-  // Return false if the type isn't suported.\n-  if (!irange::supports_type_p (type))\n-    {\n-      r.set_undefined ();\n-      return false;\n-    }\n-\n-  switch (TREE_CODE (expr))\n-    {\n-      case INTEGER_CST:\n-\tif (TREE_OVERFLOW_P (expr))\n-\t  expr = drop_tree_overflow (expr);\n-\tr.set (expr, expr);\n-\treturn true;\n-\n-      case SSA_NAME:\n-\tr = gimple_range_global (expr);\n-\treturn true;\n-\n-      case ADDR_EXPR:\n-        {\n-\t  // Handle &var which can show up in phi arguments.\n-\t  bool ov;\n-\t  if (tree_single_nonzero_warnv_p (expr, &ov))\n-\t    {\n-\t      r = range_nonzero (type);\n-\t      return true;\n-\t    }\n-\t  break;\n-\t}\n-\n-      default:\n-        break;\n-    }\n-  r.set_varying (type);\n-  return true;\n-}\n-\n // Return the base of the RHS of an assignment.\n \n static tree\n@@ -961,7 +901,7 @@ bool\n gimple_ranger::range_of_expr (irange &r, tree expr, gimple *stmt)\n {\n   if (!gimple_range_ssa_p (expr))\n-    return get_tree_range (r, expr);\n+    return get_tree_range (r, expr, stmt);\n \n   // If there is no statement, just get the global value.\n   if (!stmt)\n@@ -1466,3 +1406,5 @@ disable_ranger (struct function *fun)\n \n   fun->x_range_query = &global_ranges;\n }\n+\n+#include \"gimple-range-tests.cc\""}, {"sha": "02b891fad6928b03f1a7b160a25b99eeb0c2d8a4", "filename": "gcc/gimple-range.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caa60c12715dd9b0cbb550a45e5878214a10a2fe/gcc%2Fgimple-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caa60c12715dd9b0cbb550a45e5878214a10a2fe/gcc%2Fgimple-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.h?ref=caa60c12715dd9b0cbb550a45e5878214a10a2fe", "patch": "@@ -159,6 +159,8 @@ inline bool\n fold_range (irange &r, gimple *s, range_query *q = NULL)\n {\n   fold_using_range f;\n+  if (q == NULL)\n+    q = get_global_range_query ();\n   fur_source src (q, s);\n   return f.fold_stmt (r, s, src);\n }\n@@ -169,13 +171,12 @@ inline bool\n fold_range (irange &r, gimple *s, edge on_edge, range_query *q = NULL)\n {\n   fold_using_range f;\n+  if (q == NULL)\n+    q = get_global_range_query ();\n   fur_source src (q, on_edge);\n   return f.fold_stmt (r, s, src);\n }\n \n-// Calculate a basic range for a tree node expression.\n-extern bool get_tree_range (irange &r, tree expr);\n-\n // These routines provide a GIMPLE interface to the range-ops code.\n extern tree gimple_range_operand1 (const gimple *s);\n extern tree gimple_range_operand2 (const gimple *s);"}, {"sha": "80459d63a39e7cc52cf14990e2bc130cfecbfb5e", "filename": "gcc/selftest.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caa60c12715dd9b0cbb550a45e5878214a10a2fe/gcc%2Fselftest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caa60c12715dd9b0cbb550a45e5878214a10a2fe/gcc%2Fselftest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest.h?ref=caa60c12715dd9b0cbb550a45e5878214a10a2fe", "patch": "@@ -249,6 +249,7 @@ extern void predict_c_tests ();\n extern void pretty_print_c_tests ();\n extern void range_tests ();\n extern void range_op_tests ();\n+extern void gimple_range_tests ();\n extern void read_rtl_function_c_tests ();\n extern void rtl_tests_c_tests ();\n extern void sbitmap_c_tests ();"}, {"sha": "821f224d4ab88e1b812becab4d6271666c72e45d", "filename": "gcc/value-query.cc", "status": "modified", "additions": 82, "deletions": 2, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caa60c12715dd9b0cbb550a45e5878214a10a2fe/gcc%2Fvalue-query.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caa60c12715dd9b0cbb550a45e5878214a10a2fe/gcc%2Fvalue-query.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-query.cc?ref=caa60c12715dd9b0cbb550a45e5878214a10a2fe", "patch": "@@ -182,6 +182,86 @@ range_query::~range_query ()\n   delete equiv_alloc;\n }\n \n+// Return a range in R for the tree EXPR.  Return true if a range is\n+// representable, and UNDEFINED/false if not.\n+\n+bool\n+range_query::get_tree_range (irange &r, tree expr, gimple *stmt)\n+{\n+  tree type;\n+  if (TYPE_P (expr))\n+    type = expr;\n+  else\n+    type = TREE_TYPE (expr);\n+\n+  if (!irange::supports_type_p (type))\n+    {\n+      r.set_undefined ();\n+      return false;\n+    }\n+  if (expr == type)\n+    {\n+      r.set_varying (type);\n+      return true;\n+    }\n+  switch (TREE_CODE (expr))\n+    {\n+    case INTEGER_CST:\n+      if (TREE_OVERFLOW_P (expr))\n+\texpr = drop_tree_overflow (expr);\n+      r.set (expr, expr);\n+      return true;\n+\n+    case SSA_NAME:\n+      r = gimple_range_global (expr);\n+      return true;\n+\n+    case ADDR_EXPR:\n+      {\n+\t// Handle &var which can show up in phi arguments.\n+\tbool ov;\n+\tif (tree_single_nonzero_warnv_p (expr, &ov))\n+\t  {\n+\t    r = range_nonzero (type);\n+\t    return true;\n+\t  }\n+\tbreak;\n+      }\n+\n+    default:\n+      break;\n+    }\n+  if (BINARY_CLASS_P (expr))\n+    {\n+      range_operator *op = range_op_handler (TREE_CODE (expr), type);\n+      if (op)\n+\t{\n+\t  int_range_max r0, r1;\n+\t  range_of_expr (r0, TREE_OPERAND (expr, 0), stmt);\n+\t  range_of_expr (r1, TREE_OPERAND (expr, 1), stmt);\n+\t  op->fold_range (r, type, r0, r1);\n+\t}\n+      else\n+\tr.set_varying (type);\n+      return true;\n+    }\n+  if (UNARY_CLASS_P (expr))\n+    {\n+      range_operator *op = range_op_handler (TREE_CODE (expr), type);\n+      if (op)\n+\t{\n+\t  int_range_max r0;\n+\t  range_of_expr (r0, TREE_OPERAND (expr, 0), stmt);\n+\t  op->fold_range (r, type, r0, int_range<1> (type));\n+\t}\n+      else\n+\tr.set_varying (type);\n+      return true;\n+    }\n+  r.set_varying (type);\n+  return true;\n+}\n+\n // Return the range for NAME from SSA_NAME_RANGE_INFO.\n \n static inline void\n@@ -355,12 +435,12 @@ get_global_range_query ()\n }\n \n bool\n-global_range_query::range_of_expr (irange &r, tree expr, gimple *)\n+global_range_query::range_of_expr (irange &r, tree expr, gimple *stmt)\n {\n   tree type = TREE_TYPE (expr);\n \n   if (!irange::supports_type_p (type) || !gimple_range_ssa_p (expr))\n-    return get_tree_range (r, expr);\n+    return get_tree_range (r, expr, stmt);\n \n   get_range_global (r, expr);\n "}, {"sha": "77e49e9a9065defdc9fef274a94a58e4b68b1972", "filename": "gcc/value-query.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caa60c12715dd9b0cbb550a45e5878214a10a2fe/gcc%2Fvalue-query.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caa60c12715dd9b0cbb550a45e5878214a10a2fe/gcc%2Fvalue-query.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-query.h?ref=caa60c12715dd9b0cbb550a45e5878214a10a2fe", "patch": "@@ -100,6 +100,8 @@ class range_query : public value_query\n protected:\n   class value_range_equiv *allocate_value_range_equiv ();\n   void free_value_range_equiv (class value_range_equiv *);\n+  bool get_tree_range (irange &r, tree expr, gimple *stmt);\n+  bool get_arith_expr_range (irange &r, tree expr, gimple *stmt);\n \n private:\n   class equiv_allocator *equiv_alloc;"}, {"sha": "509c8b093c50b296166dffa6b02aab72ba40e84b", "filename": "gcc/vr-values.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caa60c12715dd9b0cbb550a45e5878214a10a2fe/gcc%2Fvr-values.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caa60c12715dd9b0cbb550a45e5878214a10a2fe/gcc%2Fvr-values.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.c?ref=caa60c12715dd9b0cbb550a45e5878214a10a2fe", "patch": "@@ -180,7 +180,7 @@ bool\n vr_values::range_of_expr (irange &r, tree expr, gimple *stmt)\n {\n   if (!gimple_range_ssa_p (expr))\n-    return get_tree_range (r, expr);\n+    return get_tree_range (r, expr, stmt);\n \n   if (const value_range *vr = get_value_range (expr, stmt))\n     {"}]}