{"sha": "50612a04e59e7e68cd2ecedf34e9bad1ec2b5827", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTA2MTJhMDRlNTllN2U2OGNkMmVjZWRmMzRlOWJhZDFlYzJiNTgyNw==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@atrey.karlin.mff.cuni.cz", "date": "2003-08-02T10:30:48Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2003-08-02T10:30:48Z"}, "message": "libgcov.c (gcov_exit): Cleanup and fix.\n\n\t* libgcov.c (gcov_exit): Cleanup and fix.\n\t* profile.c (compute_value_histograms): Don't try to read profiles\n\tthat are not present.\n\nFrom-SVN: r70100", "tree": {"sha": "c24ca8a30aa1c180b963e821ab1e55f1685897e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c24ca8a30aa1c180b963e821ab1e55f1685897e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/50612a04e59e7e68cd2ecedf34e9bad1ec2b5827", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50612a04e59e7e68cd2ecedf34e9bad1ec2b5827", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50612a04e59e7e68cd2ecedf34e9bad1ec2b5827", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50612a04e59e7e68cd2ecedf34e9bad1ec2b5827/comments", "author": null, "committer": null, "parents": [{"sha": "7575931c17b4ce70f4b8cdd857225973767e96a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7575931c17b4ce70f4b8cdd857225973767e96a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7575931c17b4ce70f4b8cdd857225973767e96a9"}], "stats": {"total": 195, "additions": 114, "deletions": 81}, "files": [{"sha": "bb16c06cf8faff97125b39071fd5aa82be2d6ad8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50612a04e59e7e68cd2ecedf34e9bad1ec2b5827/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50612a04e59e7e68cd2ecedf34e9bad1ec2b5827/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=50612a04e59e7e68cd2ecedf34e9bad1ec2b5827", "patch": "@@ -1,3 +1,9 @@\n+2003-08-02  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\t* libgcov.c (gcov_exit): Cleanup and fix.\n+\t* profile.c (compute_value_histograms): Don't try to read profiles\n+\tthat are not present.\n+\n 2003-08-02  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* builtins.def: Categorize."}, {"sha": "850680612835dca799aed6e4bd104635eb324a5e", "filename": "gcc/libgcov.c", "status": "modified", "additions": 101, "deletions": 80, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50612a04e59e7e68cd2ecedf34e9bad1ec2b5827/gcc%2Flibgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50612a04e59e7e68cd2ecedf34e9bad1ec2b5827/gcc%2Flibgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcov.c?ref=50612a04e59e7e68cd2ecedf34e9bad1ec2b5827", "patch": "@@ -122,32 +122,32 @@ gcov_exit (void)\n   struct gcov_info *gi_ptr;\n   struct gcov_summary this_program;\n   struct gcov_summary all;\n+  struct gcov_ctr_summary *cs_ptr;\n+  const struct gcov_ctr_info *ci_ptr;\n+  unsigned t_ix;\n+  gcov_unsigned_t c_num;\n \n   memset (&all, 0, sizeof (all));\n   /* Find the totals for this execution.  */\n   memset (&this_program, 0, sizeof (this_program));\n   for (gi_ptr = gcov_list; gi_ptr; gi_ptr = gi_ptr->next)\n     {\n-      const struct gcov_ctr_info *ci_ptr;\n-      struct gcov_ctr_summary *cs_ptr;\n-      unsigned t_ix;\n-      \n-      for (t_ix = 0, ci_ptr = gi_ptr->counts, cs_ptr = this_program.ctrs;\n-\t   t_ix != GCOV_COUNTERS_SUMMABLE; t_ix++, cs_ptr++)\n-\tif ((1 << t_ix) & gi_ptr->ctr_mask)\n-\t  {\n-\t    const gcov_type *c_ptr;\n-\t    gcov_unsigned_t c_num;\n-\n-\t    cs_ptr->num += ci_ptr->num;\n-\t    for (c_num = ci_ptr->num, c_ptr = ci_ptr->values; c_num--; c_ptr++)\n-\t      {\n-\t\tcs_ptr->sum_all += *c_ptr;\n-\t\tif (cs_ptr->run_max < *c_ptr)\n-\t\t  cs_ptr->run_max = *c_ptr;\n-\t      }\n-\t    ci_ptr++;\n-\t  }\n+      ci_ptr = gi_ptr->counts;\n+      for (t_ix = 0; t_ix < GCOV_COUNTERS_SUMMABLE; t_ix++)\n+\t{\n+\t  if (!((1 << t_ix) & gi_ptr->ctr_mask))\n+\t    continue;\n+\n+\t  cs_ptr = &this_program.ctrs[t_ix];\n+\t  cs_ptr->num += ci_ptr->num;\n+\t  for (c_num = 0; c_num < ci_ptr->num; c_num++)\n+\t    {\n+      \t      cs_ptr->sum_all += ci_ptr->values[c_num];\n+\t      if (cs_ptr->run_max < ci_ptr->values[c_num])\n+\t\tcs_ptr->run_max = ci_ptr->values[c_num];\n+\t    }\n+\t  ci_ptr++;\n+\t}\n     }\n \n   /* Now merge each file.  */\n@@ -158,9 +158,7 @@ gcov_exit (void)\n       gcov_type *values[GCOV_COUNTERS];\n       const struct gcov_fn_info *fi_ptr;\n       unsigned fi_stride;\n-      unsigned c_ix, t_ix, f_ix;\n-      const struct gcov_ctr_info *ci_ptr;\n-      struct gcov_ctr_summary *cs_ptr;\n+      unsigned c_ix, f_ix, n_counts;\n       struct gcov_ctr_summary *cs_obj, *cs_tobj, *cs_prg, *cs_tprg, *cs_all;\n       int error = 0;\n       gcov_unsigned_t tag, length;\n@@ -170,24 +168,30 @@ gcov_exit (void)\n       memset (&object, 0, sizeof (object));\n       \n       /* Totals for this object file.  */\n-      for (t_ix = c_ix = 0,\n-\t     ci_ptr = gi_ptr->counts, cs_ptr = this_object.ctrs;\n-\t   t_ix != GCOV_COUNTERS_SUMMABLE; t_ix++, cs_ptr++)\n+      ci_ptr = gi_ptr->counts;\n+      for (t_ix = 0; t_ix < GCOV_COUNTERS_SUMMABLE; t_ix++)\n+\t{\n+\t  if (!((1 << t_ix) & gi_ptr->ctr_mask))\n+\t    continue;\n+\n+\t  cs_ptr = &this_program.ctrs[t_ix];\n+\t  cs_ptr->num += ci_ptr->num;\n+\t  for (c_num = 0; c_num < ci_ptr->num; c_num++)\n+\t    {\n+\t      cs_ptr->sum_all += ci_ptr->values[c_num];\n+\t      if (cs_ptr->run_max < ci_ptr->values[c_num])\n+\t\tcs_ptr->run_max = ci_ptr->values[c_num];\n+\t    }\n+\n+\t  ci_ptr++;\n+\t}\n+\n+      c_ix = 0;\n+      for (t_ix = 0; t_ix < GCOV_COUNTERS; t_ix++)\n \tif ((1 << t_ix) & gi_ptr->ctr_mask)\n \t  {\n-\t    const gcov_type *c_ptr;\n-\t    gcov_unsigned_t c_num;\n-\n-\t    cs_ptr->num += ci_ptr->num;\n-\t    values[c_ix] = ci_ptr->values;\n-\t    for (c_num = ci_ptr->num, c_ptr = ci_ptr->values; c_num--; c_ptr++)\n-\t      {\n-\t\tcs_ptr->sum_all += *c_ptr;\n-\t\tif (cs_ptr->run_max < *c_ptr)\n-\t\t  cs_ptr->run_max = *c_ptr;\n-\t      }\n+\t    values[c_ix] = gi_ptr->counts[c_ix].values;\n \t    c_ix++;\n-\t    ci_ptr++;\n \t  }\n \n       /* Calculate the function_info stride. This depends on the\n@@ -231,11 +235,10 @@ gcov_exit (void)\n \t    }\n \t  \n \t  /* Merge execution counts for each function.  */\n-\t  for (f_ix = gi_ptr->n_functions, fi_ptr = gi_ptr->functions;\n-\t       f_ix--;\n-\t       fi_ptr = (const struct gcov_fn_info *)\n-\t\t ((const char *) fi_ptr + fi_stride))\n+\t  for (f_ix = 0; f_ix < gi_ptr->n_functions; f_ix++)\n \t    {\n+\t      fi_ptr = (const struct gcov_fn_info *)\n+\t\t      ((const char *) gi_ptr->functions + f_ix * fi_stride);\n \t      tag = gcov_read_unsigned ();\n \t      length = gcov_read_unsigned ();\n \n@@ -252,25 +255,31 @@ gcov_exit (void)\n \t\t  goto read_fatal;\n \t\t}\n \n-\t      for (c_ix = t_ix = 0; t_ix != GCOV_COUNTERS; t_ix++)\n-\t\tif ((1 << t_ix) & gi_ptr->ctr_mask)\n-\t\t  {\n-\t\t    unsigned n_counts = fi_ptr->n_ctrs[c_ix];\n-\t\t    gcov_merge_fn merge = gi_ptr->counts[c_ix].merge;\n+\t      c_ix = 0;\n+\t      for (t_ix = 0; t_ix < GCOV_COUNTERS; t_ix++)\n+\t\t{\n+\t\t  gcov_merge_fn merge;\n+\n+\t\t  if (!((1 << t_ix) & gi_ptr->ctr_mask))\n+\t\t    continue;\n+\t\t  \n+\t\t  n_counts = fi_ptr->n_ctrs[c_ix];\n+\t\t  merge = gi_ptr->counts[c_ix].merge;\n \t\t    \n-\t\t    tag = gcov_read_unsigned ();\n-\t\t    length = gcov_read_unsigned ();\n-\t\t    if (tag != GCOV_TAG_FOR_COUNTER (t_ix)\n-\t\t\t|| length != GCOV_TAG_COUNTER_LENGTH (n_counts))\n-\t\t      goto read_mismatch;\n-\t\t    (*merge) (values[c_ix], n_counts);\n-\t\t    values[c_ix] += n_counts;\n-\t\t    c_ix++;\n+\t\t  tag = gcov_read_unsigned ();\n+\t\t  length = gcov_read_unsigned ();\n+\t\t  if (tag != GCOV_TAG_FOR_COUNTER (t_ix)\n+\t\t      || length != GCOV_TAG_COUNTER_LENGTH (n_counts))\n+\t\t    goto read_mismatch;\n+\t\t  (*merge) (values[c_ix], n_counts);\n+\t\t  values[c_ix] += n_counts;\n+\t\t  c_ix++;\n \t\t}\n \t      if ((error = gcov_is_error ()))\n \t\tgoto read_error;\n \t    }\n \n+\t  f_ix = ~0u;\n \t  /* Check program & object summary */\n \t  while (1)\n \t    {\n@@ -310,13 +319,14 @@ gcov_exit (void)\n \n       /* Merge the summaries.  */\n       f_ix = ~0u;\n-      for (t_ix = c_ix = 0,\n-\t     cs_obj = object.ctrs, cs_tobj = this_object.ctrs,\n-\t     cs_prg = program.ctrs, cs_tprg = this_program.ctrs,\n-\t     cs_all = all.ctrs;\n-\t   t_ix != GCOV_COUNTERS_SUMMABLE;\n-\t   t_ix++, cs_obj++, cs_tobj++, cs_prg++, cs_tprg++, cs_all++)\n+      for (t_ix = 0; t_ix < GCOV_COUNTERS_SUMMABLE; t_ix++)\n \t{\n+\t  cs_obj = &object.ctrs[t_ix];\n+\t  cs_tobj = &this_object.ctrs[t_ix];\n+\t  cs_prg = &program.ctrs[t_ix];\n+\t  cs_tprg = &program.ctrs[t_ix];\n+\t  cs_all = &all.ctrs[t_ix];\n+\n \t  if ((1 << t_ix) & gi_ptr->ctr_mask)\n \t    {\n \t      if (!cs_obj->runs++)\n@@ -336,9 +346,6 @@ gcov_exit (void)\n \t      if (cs_prg->run_max < cs_tprg->run_max)\n \t\tcs_prg->run_max = cs_tprg->run_max;\n \t      cs_prg->sum_max += cs_tprg->run_max;\n-\t      \n-\t      values[c_ix] = gi_ptr->counts[c_ix].values;\n-\t      c_ix++;\n \t    }\n \t  else if (cs_obj->num || cs_prg->num)\n \t    goto read_mismatch;\n@@ -356,36 +363,50 @@ gcov_exit (void)\n \t    }\n \t}\n       \n+      c_ix = 0;\n+      for (t_ix = 0; t_ix < GCOV_COUNTERS; t_ix++)\n+\tif ((1 << t_ix) & gi_ptr->ctr_mask)\n+\t  {\n+\t    values[c_ix] = gi_ptr->counts[c_ix].values;\n+\t    c_ix++;\n+\t  }\n+\n       program.checksum = gcov_crc32;\n       \n       /* Write out the data.  */\n       gcov_write_tag_length (GCOV_DATA_MAGIC, GCOV_VERSION);\n       gcov_write_unsigned (gi_ptr->stamp);\n       \n       /* Write execution counts for each function.  */\n-      for (f_ix = gi_ptr->n_functions, fi_ptr = gi_ptr->functions; f_ix--;\n-\t   fi_ptr = (const struct gcov_fn_info *)\n-\t     ((const char *) fi_ptr + fi_stride))\n+      for (f_ix = 0; f_ix < gi_ptr->n_functions; f_ix++)\n \t{\n+\t  fi_ptr = (const struct gcov_fn_info *)\n+\t\t  ((const char *) gi_ptr->functions + f_ix * fi_stride);\n+\n \t  /* Announce function.  */\n \t  gcov_write_tag_length (GCOV_TAG_FUNCTION, GCOV_TAG_FUNCTION_LENGTH);\n \t  gcov_write_unsigned (fi_ptr->ident);\n \t  gcov_write_unsigned (fi_ptr->checksum);\n \n-\t  for (c_ix = t_ix = 0; t_ix != GCOV_COUNTERS; t_ix++)\n-\t    if ((1 << t_ix) & gi_ptr->ctr_mask)\n-\t      {\n-\t\tunsigned n_counts = fi_ptr->n_ctrs[c_ix];\n-\t\tgcov_type *c_ptr;\n+\t  c_ix = 0;\n+\t  for (t_ix = 0; t_ix < GCOV_COUNTERS; t_ix++)\n+\t    {\n+\t      gcov_type *c_ptr;\n+\n+\t      if (!((1 << t_ix) & gi_ptr->ctr_mask))\n+\t\tcontinue;\n+\n+\t      n_counts = fi_ptr->n_ctrs[c_ix];\n \t\t    \n-\t\tgcov_write_tag_length (GCOV_TAG_FOR_COUNTER (t_ix),\n-\t\t\t\t       GCOV_TAG_COUNTER_LENGTH (n_counts));\n-\t\tc_ptr = values[c_ix];\n-\t\twhile (n_counts--)\n-\t\t  gcov_write_counter (*c_ptr++);\n-\t\tvalues[c_ix] = c_ptr;\n-\t\tc_ix++;\n-\t      }\n+\t      gcov_write_tag_length (GCOV_TAG_FOR_COUNTER (t_ix),\n+\t\t\t\t     GCOV_TAG_COUNTER_LENGTH (n_counts));\n+\t      c_ptr = values[c_ix];\n+\t      while (n_counts--)\n+\t\tgcov_write_counter (*c_ptr++);\n+\n+\t      values[c_ix] = c_ptr;\n+\t      c_ix++;\n+\t    }\n \t}\n \n       /* Object file summary.  */"}, {"sha": "09949819064c3fc57c93eb56ee757eaf90465641", "filename": "gcc/profile.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50612a04e59e7e68cd2ecedf34e9bad1ec2b5827/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50612a04e59e7e68cd2ecedf34e9bad1ec2b5827/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=50612a04e59e7e68cd2ecedf34e9bad1ec2b5827", "patch": "@@ -622,9 +622,15 @@ compute_value_histograms (unsigned n_values, struct histogram_value *values)\n   any = 0;\n   for (t = 0; t < GCOV_N_VALUE_COUNTERS; t++)\n     {\n+      if (!n_histogram_counters[t])\n+\t{\n+\t  histogram_counts[t] = NULL;\n+\t  continue;\n+\t}\n+\n       histogram_counts[t] =\n \tget_coverage_counts (COUNTER_FOR_HIST_TYPE (t),\n-\t\t\t     n_histogram_counters[t], &profile_info);\n+\t\t\t     n_histogram_counters[t], NULL);\n       if (histogram_counts[t])\n \tany = 1;\n       act_count[t] = histogram_counts[t];"}]}