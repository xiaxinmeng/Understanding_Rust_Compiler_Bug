{"sha": "d0f4e7fcdbde6134337c5956a23a740a26a4af66", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDBmNGU3ZmNkYmRlNjEzNDMzN2M1OTU2YTIzYTc0MGEyNmE0YWY2Ng==", "commit": {"author": {"name": "Alan Lawrence", "email": "alan.lawrence@arm.com", "date": "2015-09-18T10:55:11Z"}, "committer": {"name": "Alan Lawrence", "email": "alalaw01@gcc.gnu.org", "date": "2015-09-18T10:55:11Z"}, "message": "completely_scalarize arrays as well as records.\n\ngcc/:\n    \n\tPR tree-optimization/67283\n\t* tree-sra.c (type_consists_of_records_p): Rename to...\n\t(scalarizable_type_p): ...this, add case for ARRAY_TYPE.\n\t(completely_scalarize_record): Rename to...\n\t(completely_scalarize): ...this, add ARRAY_TYPE case, move some code to:\n\t(scalarize_elem): New.\n\t(analyze_all_variable_accesses): Follow renamings.\n    \ngcc/testsuite/:\n    \n\t* gcc.dg/tree-ssa/sra-15.c: New.\n\t* gcc.dg/tree-ssa/sra-16.c: New.\n\nFrom-SVN: r227901", "tree": {"sha": "cfec84514002ebf8ec3799c9ebf3002f2aa1bcac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cfec84514002ebf8ec3799c9ebf3002f2aa1bcac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d0f4e7fcdbde6134337c5956a23a740a26a4af66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0f4e7fcdbde6134337c5956a23a740a26a4af66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0f4e7fcdbde6134337c5956a23a740a26a4af66", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0f4e7fcdbde6134337c5956a23a740a26a4af66/comments", "author": null, "committer": null, "parents": [{"sha": "f5916470c42633933457dbebbbed519cd73ed5b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5916470c42633933457dbebbbed519cd73ed5b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5916470c42633933457dbebbbed519cd73ed5b0"}], "stats": {"total": 255, "additions": 207, "deletions": 48}, "files": [{"sha": "dddd0f3e9f3eba6c15d5f50b2352d95c5da3fabb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0f4e7fcdbde6134337c5956a23a740a26a4af66/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0f4e7fcdbde6134337c5956a23a740a26a4af66/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d0f4e7fcdbde6134337c5956a23a740a26a4af66", "patch": "@@ -1,3 +1,13 @@\n+2015-09-18  Alan Lawrence  <alan.lawrence@arm.com>\n+\n+\tPR tree-optimization/67283\n+\t* tree-sra.c (type_consists_of_records_p): Rename to...\n+\t(scalarizable_type_p): ...this, add case for ARRAY_TYPE.\n+\t(completely_scalarize_record): Rename to...\n+\t(completely_scalarize): ...this, add ARRAY_TYPE case, move some code to:\n+\t(scalarize_elem): New.\n+\t(analyze_all_variable_accesses): Follow renamings.\n+\n 2015-09-18  Richard Biener  <rguenther@suse.de>\n \n \t* dwarf2out.c (add_location_or_const_value_attribute): Do nothing"}, {"sha": "08baed1ef3fb1f13a72a68ef69abc6cf8354ba51", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0f4e7fcdbde6134337c5956a23a740a26a4af66/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0f4e7fcdbde6134337c5956a23a740a26a4af66/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d0f4e7fcdbde6134337c5956a23a740a26a4af66", "patch": "@@ -1,3 +1,9 @@\n+2015-09-18  Alan Lawrence  <alan.lawrence@arm.com>\n+\n+\tPR tree-optimization/67283\n+\t* gcc.dg/tree-ssa/sra-15.c: New.\n+\t* gcc.dg/tree-ssa/sra-16.c: New.\n+\n 2015-09-17  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n \n \tPR sanitizer/64078"}, {"sha": "a22062e32d1a94711e20c06676aed7ce4a7513f3", "filename": "gcc/testsuite/gcc.dg/tree-ssa/sra-15.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0f4e7fcdbde6134337c5956a23a740a26a4af66/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsra-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0f4e7fcdbde6134337c5956a23a740a26a4af66/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsra-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsra-15.c?ref=d0f4e7fcdbde6134337c5956a23a740a26a4af66", "patch": "@@ -0,0 +1,37 @@\n+/* Verify that SRA total scalarization works on records containing arrays.  */\n+/* { dg-do run } */\n+/* { dg-options \"-O1 -fdump-tree-release_ssa --param sra-max-scalarization-size-Ospeed=32\" } */\n+\n+extern void abort (void);\n+\n+struct S\n+{\n+  char c;\n+  unsigned short f[2][2];\n+  int i;\n+  unsigned short f3, f4;\n+};\n+\n+\n+int __attribute__ ((noinline))\n+foo (struct S *p)\n+{\n+  struct S l;\n+\n+  l = *p;\n+  l.i++;\n+  l.f[1][0] += 3;\n+  *p = l;\n+}\n+\n+int\n+main (int argc, char **argv)\n+{\n+  struct S a = {0, { {5, 7}, {9, 11} }, 4, 0, 0};\n+  foo (&a);\n+  if (a.i != 5 || a.f[1][0] != 12)\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"l;\" 0 \"release_ssa\" } } */"}, {"sha": "fef34c0d8272c46ade1e99d0ed5ccedd1f24da97", "filename": "gcc/testsuite/gcc.dg/tree-ssa/sra-16.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0f4e7fcdbde6134337c5956a23a740a26a4af66/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsra-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0f4e7fcdbde6134337c5956a23a740a26a4af66/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsra-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsra-16.c?ref=d0f4e7fcdbde6134337c5956a23a740a26a4af66", "patch": "@@ -0,0 +1,37 @@\n+/* Verify that SRA total scalarization works on records containing arrays.  */\n+/* { dg-do run } */\n+/* { dg-options \"-O1 -fdump-tree-release_ssa --param sra-max-scalarization-size-Ospeed=16\" } */\n+\n+extern void abort (void);\n+\n+struct S\n+{\n+  long zilch[0];\n+  char c;\n+  int i;\n+  unsigned short f3, f4;\n+};\n+\n+\n+int __attribute__ ((noinline))\n+foo (struct S *p)\n+{\n+  struct S l;\n+\n+  l = *p;\n+  l.i++;\n+  l.f3++;\n+  *p = l;\n+}\n+\n+int\n+main (int argc, char **argv)\n+{\n+  struct S a = { { }, 0, 4, 0, 0};\n+  foo (&a);\n+  if (a.i != 5 || a.f3 != 1)\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"l;\" 0 \"release_ssa\" } } */"}, {"sha": "ec5edd35f08307a02ef38752dfaad933338a0dea", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 117, "deletions": 48, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0f4e7fcdbde6134337c5956a23a740a26a4af66/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0f4e7fcdbde6134337c5956a23a740a26a4af66/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=d0f4e7fcdbde6134337c5956a23a740a26a4af66", "patch": "@@ -915,73 +915,142 @@ create_access (tree expr, gimple stmt, bool write)\n }\n \n \n-/* Return true iff TYPE is a RECORD_TYPE with fields that are either of gimple\n-   register types or (recursively) records with only these two kinds of fields.\n-   It also returns false if any of these records contains a bit-field.  */\n+/* Return true iff TYPE is scalarizable - i.e. a RECORD_TYPE or fixed-length\n+   ARRAY_TYPE with fields that are either of gimple register types (excluding\n+   bit-fields) or (recursively) scalarizable types.  */\n \n static bool\n-type_consists_of_records_p (tree type)\n+scalarizable_type_p (tree type)\n {\n-  tree fld;\n+  gcc_assert (!is_gimple_reg_type (type));\n \n-  if (TREE_CODE (type) != RECORD_TYPE)\n-    return false;\n+  switch (TREE_CODE (type))\n+  {\n+  case RECORD_TYPE:\n+    for (tree fld = TYPE_FIELDS (type); fld; fld = DECL_CHAIN (fld))\n+      if (TREE_CODE (fld) == FIELD_DECL)\n+\t{\n+\t  tree ft = TREE_TYPE (fld);\n \n-  for (fld = TYPE_FIELDS (type); fld; fld = DECL_CHAIN (fld))\n-    if (TREE_CODE (fld) == FIELD_DECL)\n-      {\n-\ttree ft = TREE_TYPE (fld);\n+\t  if (DECL_BIT_FIELD (fld))\n+\t    return false;\n \n-\tif (DECL_BIT_FIELD (fld))\n-\t  return false;\n+\t  if (!is_gimple_reg_type (ft)\n+\t      && !scalarizable_type_p (ft))\n+\t    return false;\n+\t}\n \n-\tif (!is_gimple_reg_type (ft)\n-\t    && !type_consists_of_records_p (ft))\n-\t  return false;\n-      }\n+    return true;\n \n-  return true;\n+  case ARRAY_TYPE:\n+    {\n+      if (TYPE_DOMAIN (type) == NULL_TREE\n+\t  || !tree_fits_shwi_p (TYPE_SIZE (type))\n+\t  || !tree_fits_shwi_p (TYPE_SIZE (TREE_TYPE (type)))\n+\t  || (tree_to_shwi (TYPE_SIZE (TREE_TYPE (type))) <= 0)\n+\t  || !tree_fits_shwi_p (TYPE_MIN_VALUE (TYPE_DOMAIN (type))))\n+\treturn false;\n+      if (tree_to_shwi (TYPE_SIZE (type)) == 0\n+\t  && TYPE_MAX_VALUE (TYPE_DOMAIN (type)) == NULL_TREE)\n+\t/* Zero-element array, should not prevent scalarization.  */\n+\t;\n+      else if ((tree_to_shwi (TYPE_SIZE (type)) <= 0)\n+\t       || !tree_fits_shwi_p (TYPE_MAX_VALUE (TYPE_DOMAIN (type))))\n+\treturn false;\n+\n+      tree elem = TREE_TYPE (type);\n+      if (!is_gimple_reg_type (elem)\n+\t && !scalarizable_type_p (elem))\n+\treturn false;\n+      return true;\n+    }\n+  default:\n+    return false;\n+  }\n }\n \n-/* Create total_scalarization accesses for all scalar type fields in DECL that\n-   must be of a RECORD_TYPE conforming to type_consists_of_records_p.  BASE\n-   must be the top-most VAR_DECL representing the variable, OFFSET must be the\n-   offset of DECL within BASE.  REF must be the memory reference expression for\n-   the given decl.  */\n+static void scalarize_elem (tree, HOST_WIDE_INT, HOST_WIDE_INT, tree, tree);\n+\n+/* Create total_scalarization accesses for all scalar fields of a member\n+   of type DECL_TYPE conforming to scalarizable_type_p.  BASE\n+   must be the top-most VAR_DECL representing the variable; within that,\n+   OFFSET locates the member and REF must be the memory reference expression for\n+   the member.  */\n \n static void\n-completely_scalarize_record (tree base, tree decl, HOST_WIDE_INT offset,\n-\t\t\t     tree ref)\n+completely_scalarize (tree base, tree decl_type, HOST_WIDE_INT offset, tree ref)\n {\n-  tree fld, decl_type = TREE_TYPE (decl);\n+  switch (TREE_CODE (decl_type))\n+    {\n+    case RECORD_TYPE:\n+      for (tree fld = TYPE_FIELDS (decl_type); fld; fld = DECL_CHAIN (fld))\n+\tif (TREE_CODE (fld) == FIELD_DECL)\n+\t  {\n+\t    HOST_WIDE_INT pos = offset + int_bit_position (fld);\n+\t    tree ft = TREE_TYPE (fld);\n+\t    tree nref = build3 (COMPONENT_REF, ft, ref, fld, NULL_TREE);\n \n-  for (fld = TYPE_FIELDS (decl_type); fld; fld = DECL_CHAIN (fld))\n-    if (TREE_CODE (fld) == FIELD_DECL)\n+\t    scalarize_elem (base, pos, tree_to_uhwi (DECL_SIZE (fld)), nref,\n+\t\t\t    ft);\n+\t  }\n+      break;\n+    case ARRAY_TYPE:\n       {\n-\tHOST_WIDE_INT pos = offset + int_bit_position (fld);\n-\ttree ft = TREE_TYPE (fld);\n-\ttree nref = build3 (COMPONENT_REF, TREE_TYPE (fld), ref, fld,\n-\t\t\t    NULL_TREE);\n-\n-\tif (is_gimple_reg_type (ft))\n+\ttree elemtype = TREE_TYPE (decl_type);\n+\ttree elem_size = TYPE_SIZE (elemtype);\n+\tgcc_assert (elem_size && tree_fits_shwi_p (elem_size));\n+\tHOST_WIDE_INT el_size = tree_to_shwi (elem_size);\n+\tgcc_assert (el_size > 0);\n+\n+\ttree minidx = TYPE_MIN_VALUE (TYPE_DOMAIN (decl_type));\n+\tgcc_assert (TREE_CODE (minidx) == INTEGER_CST);\n+\ttree maxidx = TYPE_MAX_VALUE (TYPE_DOMAIN (decl_type));\n+\tif (maxidx)\n \t  {\n-\t    struct access *access;\n-\t    HOST_WIDE_INT size;\n-\n-\t    size = tree_to_uhwi (DECL_SIZE (fld));\n-\t    access = create_access_1 (base, pos, size);\n-\t    access->expr = nref;\n-\t    access->type = ft;\n-\t    access->grp_total_scalarization = 1;\n-\t    /* Accesses for intraprocedural SRA can have their stmt NULL.  */\n+\t    gcc_assert (TREE_CODE (maxidx) == INTEGER_CST);\n+\t    /* MINIDX and MAXIDX are inclusive.  Try to avoid overflow.  */\n+\t    unsigned HOST_WIDE_INT lenp1 = tree_to_shwi (maxidx)\n+\t\t\t\t\t- tree_to_shwi (minidx);\n+\t    unsigned HOST_WIDE_INT idx = 0;\n+\t    do\n+\t      {\n+\t\ttree nref = build4 (ARRAY_REF, elemtype, ref, size_int (idx),\n+\t\t\t\t    NULL_TREE, NULL_TREE);\n+\t\tint el_off = offset + idx * el_size;\n+\t\tscalarize_elem (base, el_off, el_size, nref, elemtype);\n+\t      }\n+\t    while (++idx <= lenp1);\n \t  }\n-\telse\n-\t  completely_scalarize_record (base, fld, pos, nref);\n       }\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Create total_scalarization accesses for a member of type TYPE, which must\n+   satisfy either is_gimple_reg_type or scalarizable_type_p.  BASE must be the\n+   top-most VAR_DECL representing the variable; within that, POS and SIZE locate\n+   the member and REF must be the reference expression for it.  */\n+\n+static void\n+scalarize_elem (tree base, HOST_WIDE_INT pos, HOST_WIDE_INT size,\n+\t\t tree ref, tree type)\n+{\n+  if (is_gimple_reg_type (type))\n+  {\n+    struct access *access = create_access_1 (base, pos, size);\n+    access->expr = ref;\n+    access->type = type;\n+    access->grp_total_scalarization = 1;\n+    /* Accesses for intraprocedural SRA can have their stmt NULL.  */\n+  }\n+  else\n+    completely_scalarize (base, type, pos, ref);\n }\n \n /* Create a total_scalarization access for VAR as a whole.  VAR must be of a\n-   RECORD_TYPE conforming to type_consists_of_records_p.  */\n+   RECORD_TYPE or ARRAY_TYPE conforming to scalarizable_type_p.  */\n \n static void\n create_total_scalarization_access (tree var)\n@@ -2521,13 +2590,13 @@ analyze_all_variable_accesses (void)\n \ttree var = candidate (i);\n \n \tif (TREE_CODE (var) == VAR_DECL\n-\t    && type_consists_of_records_p (TREE_TYPE (var)))\n+\t    && scalarizable_type_p (TREE_TYPE (var)))\n \t  {\n \t    if (tree_to_uhwi (TYPE_SIZE (TREE_TYPE (var)))\n \t\t<= max_scalarization_size)\n \t      {\n \t\tcreate_total_scalarization_access (var);\n-\t\tcompletely_scalarize_record (var, var, 0, var);\n+\t\tcompletely_scalarize (var, TREE_TYPE (var), 0, var);\n \t\tif (dump_file && (dump_flags & TDF_DETAILS))\n \t\t  {\n \t\t    fprintf (dump_file, \"Will attempt to totally scalarize \");"}]}