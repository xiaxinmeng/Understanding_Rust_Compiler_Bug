{"sha": "2bc529bf7d9fa18d85c06b34063ff5b3a8cfacd9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmJjNTI5YmY3ZDlmYTE4ZDg1YzA2YjM0MDYzZmY1YjNhOGNmYWNkOQ==", "commit": {"author": {"name": "Konrad Trifunovic", "email": "konrad.trifunovic@inria.fr", "date": "2009-11-25T05:29:01Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2009-11-25T05:29:01Z"}, "message": "graphite-interchange.c (build_partial_difference): New.\n\n2009-11-04  Konrad Trifunovic  <konrad.trifunovic@inria.fr>\n\n        * graphite-interchange.c (build_partial_difference): New.\n        (memory_stride_in_loop): Refactored the computation of\n        equality constraints into build_partial_difference function.\n        Added support for debugging stride computations.\n\nFrom-SVN: r154634", "tree": {"sha": "8ffbfde1ea0be66b24e174e5193defb92c5c718e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ffbfde1ea0be66b24e174e5193defb92c5c718e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2bc529bf7d9fa18d85c06b34063ff5b3a8cfacd9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bc529bf7d9fa18d85c06b34063ff5b3a8cfacd9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bc529bf7d9fa18d85c06b34063ff5b3a8cfacd9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bc529bf7d9fa18d85c06b34063ff5b3a8cfacd9/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c54631db7c7cb9be466b5764429d072de8d89d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c54631db7c7cb9be466b5764429d072de8d89d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c54631db7c7cb9be466b5764429d072de8d89d7"}], "stats": {"total": 141, "additions": 103, "deletions": 38}, "files": [{"sha": "468d3f59135a66c29041029f98773ef7d7c65232", "filename": "gcc/ChangeLog.graphite", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bc529bf7d9fa18d85c06b34063ff5b3a8cfacd9/gcc%2FChangeLog.graphite", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bc529bf7d9fa18d85c06b34063ff5b3a8cfacd9/gcc%2FChangeLog.graphite", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.graphite?ref=2bc529bf7d9fa18d85c06b34063ff5b3a8cfacd9", "patch": "@@ -1,3 +1,10 @@\n+2009-11-04  Konrad Trifunovic  <konrad.trifunovic@inria.fr>\n+\n+        * graphite-interchange.c (build_partial_difference): New.\n+        (memory_stride_in_loop): Refactored the computation of\n+        equality constraints into build_partial_difference function.\n+        Added support for debugging stride computations.\n+\n 2009-11-03  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* graphite-clast-to-gimple.c (gloog): Free if_region,"}, {"sha": "42a0b1dac7f27968ea21317fabcbd47b13eb8c55", "filename": "gcc/graphite-interchange.c", "status": "modified", "additions": 96, "deletions": 38, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bc529bf7d9fa18d85c06b34063ff5b3a8cfacd9/gcc%2Fgraphite-interchange.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bc529bf7d9fa18d85c06b34063ff5b3a8cfacd9/gcc%2Fgraphite-interchange.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-interchange.c?ref=2bc529bf7d9fa18d85c06b34063ff5b3a8cfacd9", "patch": "@@ -104,6 +104,94 @@ build_linearized_memory_access (ppl_dimension_type offset, poly_dr_p pdr)\n   return res;\n }\n \n+/* Builds a partial difference equations and inserts them\n+   into pointset powerset polyhedron P.  Polyhedron is assumed\n+   to have the format: T|I|T'|I'|G|S|S'|l1|l2.\n+\n+   TIME_DEPTH is the time dimension w.r.t. which we are\n+   differentiating.\n+   OFFSET represents the number of dimensions between\n+   columns t_{time_depth} and t'_{time_depth}.\n+   DIM_SCTR is the number of scattering dimensions.  It is\n+   essentially the dimensionality of the T vector.\n+\n+   The following equations are inserted into the polyhedron P:\n+    | t_1 = t_1'\n+    | ...\n+    | t_{time_depth-1} = t'_{time_depth-1}\n+    | t_{time_depth} = t'_{time_depth} + 1\n+    | t_{time_depth+1} = t'_{time_depth + 1}\n+    | ...\n+    | t_{dim_sctr} = t'_{dim_sctr}.  */\n+\n+static void\n+build_partial_difference (ppl_Pointset_Powerset_C_Polyhedron_t *p,\n+                          ppl_dimension_type time_depth,\n+                          ppl_dimension_type offset,\n+                          ppl_dimension_type dim_sctr)\n+{\n+  ppl_Constraint_t new_cstr;\n+  ppl_Linear_Expression_t le;\n+  ppl_dimension_type i;\n+  ppl_dimension_type dim;\n+  ppl_Pointset_Powerset_C_Polyhedron_t temp;\n+\n+  /* Add the equality: t_{time_depth} = t'_{time_depth} + 1.\n+     This is the core part of this alogrithm, since this\n+     constraint asks for the memory access stride (difference)\n+     between two consecutive points in time dimensions.  */\n+\n+  ppl_Pointset_Powerset_C_Polyhedron_space_dimension (*p, &dim);\n+  ppl_new_Linear_Expression_with_dimension (&le, dim);\n+  ppl_set_coef (le, time_depth, 1);\n+  ppl_set_coef (le, time_depth + offset, -1);\n+  ppl_set_inhomogeneous (le, 1);\n+  ppl_new_Constraint (&new_cstr, le, PPL_CONSTRAINT_TYPE_EQUAL);\n+  ppl_Pointset_Powerset_C_Polyhedron_add_constraint (*p, new_cstr);\n+  ppl_delete_Linear_Expression (le);\n+  ppl_delete_Constraint (new_cstr);\n+\n+  /* Add equalities:\n+     | t1 = t1'\n+     | ...\n+     | t_{time_depth-1} = t'_{time_depth-1}\n+     | t_{time_depth+1} = t'_{time_depth+1}\n+     | ...\n+     | t_{dim_sctr} = t'_{dim_sctr}\n+\n+     This means that all the time dimensions are equal except for\n+     time_depth, where the constraint is t_{depth} = t'_{depth} + 1\n+     step.  More to this: we should be carefull not to add equalities\n+     to the 'coupled' dimensions, which happens when the one dimension\n+     is stripmined dimension, and the other dimension corresponds\n+     to the point loop inside stripmined dimension.  */\n+\n+  ppl_new_Pointset_Powerset_C_Polyhedron_from_Pointset_Powerset_C_Polyhedron (&temp, *p);\n+\n+  for (i = 0; i < dim_sctr; i++)\n+    if (i != time_depth)\n+      {\n+        ppl_new_Linear_Expression_with_dimension (&le, dim);\n+        ppl_set_coef (le, i, 1);\n+        ppl_set_coef (le, i + offset, -1);\n+        ppl_new_Constraint (&new_cstr, le, PPL_CONSTRAINT_TYPE_EQUAL);\n+        ppl_Pointset_Powerset_C_Polyhedron_add_constraint (temp, new_cstr);\n+\n+        if (ppl_Pointset_Powerset_C_Polyhedron_is_empty (temp))\n+          {\n+            ppl_delete_Pointset_Powerset_C_Polyhedron (temp);\n+            ppl_new_Pointset_Powerset_C_Polyhedron_from_Pointset_Powerset_C_Polyhedron (&temp, *p);\n+          }\n+        else\n+          ppl_Pointset_Powerset_C_Polyhedron_add_constraint (*p, new_cstr);\n+        ppl_delete_Linear_Expression (le);\n+        ppl_delete_Constraint (new_cstr);\n+      }\n+\n+  ppl_delete_Pointset_Powerset_C_Polyhedron (temp);\n+}\n+\n+\n /* Set STRIDE to the stride of PDR in memory by advancing by one in\n    time dimension DEPTH.  */\n \n@@ -215,48 +303,11 @@ memory_stride_in_loop (Value stride, graphite_dim_t depth, poly_dr_p pdr)\n     free (map);\n   }\n \n-  /* Add equalities:\n-     | t1 = t1'\n-     | ...\n-     | t_{depth-1} = t'_{depth-1}\n-     | t_{depth+1} = t'_{depth+1}\n-     | ...\n-     | t_{dim_sctr} = t'_{dim_sctr}\n-\n-     This means that all the time dimensions are equal except for\n-     depth, where we will add t_{depth} = t'_{depth} + 1 in the next\n-     step.  */\n-\n   time_depth = psct_dynamic_dim (pbb, depth);\n-  for (i = 0; i < dim_sctr; i++)\n-    if (i != time_depth)\n-      {\n-        ppl_new_Linear_Expression_with_dimension (&le, new_dim);\n-        ppl_set_coef (le, i, 1);\n-        ppl_set_coef (le, i + offset, -1);\n-        ppl_new_Constraint (&new_cstr, le, PPL_CONSTRAINT_TYPE_EQUAL);\n-        ppl_Pointset_Powerset_C_Polyhedron_add_constraint (p2, new_cstr);\n-        ppl_delete_Linear_Expression (le);\n-        ppl_delete_Constraint (new_cstr);\n-      }\n-\n-  /* Add equality : t_{depth} = t'_{depth} + 1.\n-     This is the core part of this alogrithm, since this\n-     constraint asks for the memory access stride (difference)\n-     between two consecutive points in time dimensions.  */\n-  {\n-    ppl_new_Linear_Expression_with_dimension (&le, new_dim);\n-    ppl_set_coef (le, time_depth, 1);\n-    ppl_set_coef (le, time_depth + offset, -1);\n-    ppl_set_inhomogeneous (le, 1);\n-    ppl_new_Constraint (&new_cstr, le, PPL_CONSTRAINT_TYPE_EQUAL);\n-    ppl_Pointset_Powerset_C_Polyhedron_add_constraint (p2, new_cstr);\n-    ppl_delete_Linear_Expression (le);\n-    ppl_delete_Constraint (new_cstr);\n-  }\n \n   /* P1 = P1 inter P2.  */\n   ppl_Pointset_Powerset_C_Polyhedron_intersection_assign (p1, p2);\n+  build_partial_difference (&p1, time_depth, offset, dim_sctr);\n \n   /* Maximise the expression L2 - L1.  */\n   {\n@@ -266,6 +317,13 @@ memory_stride_in_loop (Value stride, graphite_dim_t depth, poly_dr_p pdr)\n     ppl_max_for_le_pointset (p1, le, stride);\n   }\n \n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"\\nStride in BB_%d, DR_%d, depth %d:\",\n+\t       pbb_index (pbb), PDR_ID (pdr), (int) depth);\n+      value_print (dump_file, \"  %s \", stride);\n+    }\n+\n   ppl_delete_Pointset_Powerset_C_Polyhedron (p1);\n   ppl_delete_Pointset_Powerset_C_Polyhedron (p2);\n   ppl_delete_Linear_Expression (le);"}]}