{"sha": "410538ea80a50d7e16bb169230a05606fbda8315", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDEwNTM4ZWE4MGE1MGQ3ZTE2YmIxNjkyMzBhMDU2MDZmYmRhODMxNQ==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@cygnus.com", "date": "1999-08-16T22:14:51Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "1999-08-16T22:14:51Z"}, "message": "basic-block.h (struct edge_list): Stucture to maintain a vector of edges.\n\n\t* basic-block.h (struct edge_list): Stucture to maintain a vector\n\tof edges.\n\t(EDGE_INDEX_NO_EDGE, EDGE_INDEX, INDEX_EDGE_PRED_BB, INDEX_EDGE_SUCC_BB,\n\t INDEX_EDGE, NUM_EDGES): New Macros for accessing edge list.\n\t(create_edge_list, free_edge-List, print_edge_list, verify_edge_list):\n\tNew function prototypes.\n\t* flow.c (create_edge_list): Function to create an edge list.\n\t(free_edge_list): Discards memory used by an edge list.\n\t(print_edge_list): Debug output showing an edge list.\n\t(verify_edge_list): Internal consistency check for an edge list.\n\nFrom-SVN: r28732", "tree": {"sha": "51264c076578e2c29019399f0d2a2a72f1378908", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/51264c076578e2c29019399f0d2a2a72f1378908"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/410538ea80a50d7e16bb169230a05606fbda8315", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/410538ea80a50d7e16bb169230a05606fbda8315", "html_url": "https://github.com/Rust-GCC/gccrs/commit/410538ea80a50d7e16bb169230a05606fbda8315", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/410538ea80a50d7e16bb169230a05606fbda8315/comments", "author": null, "committer": null, "parents": [{"sha": "b0d065155dcf58badec4abea8652c1b06b66a2e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0d065155dcf58badec4abea8652c1b06b66a2e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0d065155dcf58badec4abea8652c1b06b66a2e1"}], "stats": {"total": 311, "additions": 311, "deletions": 0}, "files": [{"sha": "0758117e34d06a1322b50e077454c231dfa9c60c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/410538ea80a50d7e16bb169230a05606fbda8315/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/410538ea80a50d7e16bb169230a05606fbda8315/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=410538ea80a50d7e16bb169230a05606fbda8315", "patch": "@@ -1,3 +1,17 @@\n+Mon Aug 16 18:08:22 EDT 1999  Andrew MacLeod  <amacleod@cygnus.com>\n+\n+\t* basic-block.h (struct edge_list): Stucture to maintain a vector\n+\tof edges.\n+\t(EDGE_INDEX_NO_EDGE, EDGE_INDEX, INDEX_EDGE_PRED_BB, INDEX_EDGE_SUCC_BB,\n+\t INDEX_EDGE, NUM_EDGES): New Macros for accessing edge list.\n+\t(create_edge_list, free_edge-List, print_edge_list, verify_edge_list):\n+\tNew function prototypes.\n+\t* flow.c (create_edge_list): Function to create an edge list.\n+\t(free_edge_list): Discards memory used by an edge list.\n+\t(print_edge_list): Debug output showing an edge list.\n+\t(verify_edge_list): Internal consistency check for an edge list.\n+\t(find_edge_index): Function to find an edge index for a pred and succ.\n+\n Mon Aug 16 11:56:36 1999  Mark Mitchell  <mark@codesourcery.com>\n \n \t* tree.c (type_hash_add): Use permalloc to allocate nodes in the"}, {"sha": "c6a9065392712587810ec02015a443ffbb3db4f7", "filename": "gcc/basic-block.h", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/410538ea80a50d7e16bb169230a05606fbda8315/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/410538ea80a50d7e16bb169230a05606fbda8315/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=410538ea80a50d7e16bb169230a05606fbda8315", "patch": "@@ -244,6 +244,38 @@ extern basic_block split_edge\t\tPROTO ((edge));\n extern void insert_insn_on_edge\t\tPROTO ((rtx, edge));\n extern void commit_edge_insertions\tPROTO ((void));\n \n+/* This structure maintains an edge list vector.  */\n+struct edge_list \n+{\n+  int num_blocks;\n+  int num_edges;\n+  edge *index_to_edge;\n+};\n+\n+/* This is the value which indicates no edge is present.  */\n+#define EDGE_INDEX_NO_EDGE\t-1\n+\n+/* EDGE_INDEX returns an integer index for an edge, or EDGE_INDEX_NO_EDGE\n+   if there is no edge between the 2 basic blocks.  */\n+#define EDGE_INDEX(el, pred, succ) (find_edge_index ((el), (pred), (succ)))\n+\n+/* INDEX_EDGE_PRED_BB and INDEX_EDGE_SUCC_BB return a pointer to the basic\n+   block which is either the pred or succ end of the indexed edge.  */\n+#define INDEX_EDGE_PRED_BB(el, index)\t((el)->index_to_edge[(index)]->src)\n+#define INDEX_EDGE_SUCC_BB(el, index)\t((el)->index_to_edge[(index)]->dest)\n+\n+/* INDEX_EDGE returns a pointer to the edge.  */\n+#define INDEX_EDGE(el, index)           ((el)->index_to_edge[(index)])\n+\n+/* Number of edges in the compressed edge list.  */\n+#define NUM_EDGES(el)\t\t\t((el)->num_edges)\n+\n+struct edge_list * create_edge_list\tPROTO ((void));\n+void free_edge_list\t\t\tPROTO ((struct edge_list *));\n+void print_edge_list\t\t\tPROTO ((FILE *, struct edge_list *));\n+void verify_edge_list\t\t\tPROTO ((FILE *, struct edge_list *));\n+int find_edge_index\t\t\tPROTO ((struct edge_list *, int, int));\n+\n extern void compute_preds_succs\t\tPROTO ((int_list_ptr *, int_list_ptr *,\n \t\t\t\t\t\tint *, int *));\n extern void compute_dominators\t\tPROTO ((sbitmap *, sbitmap *,"}, {"sha": "e63481dc58bbb9c5750c2b124f7d545c93e02218", "filename": "gcc/flow.c", "status": "modified", "additions": 265, "deletions": 0, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/410538ea80a50d7e16bb169230a05606fbda8315/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/410538ea80a50d7e16bb169230a05606fbda8315/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=410538ea80a50d7e16bb169230a05606fbda8315", "patch": "@@ -5243,3 +5243,268 @@ verify_flow_info ()\n       x = NEXT_INSN (x);\n     }\n }\n+\f\n+/* Functions to access an edge list with a vector representation.\n+   Enough data is kept such that given an index number, the \n+   pred and succ that edge reprsents can be determined, or\n+   given a pred and a succ, it's index number can be returned.\n+   This allows algorithms which comsume a lot of memory to \n+   represent the normally full matrix of edge (pred,succ) with a\n+   single indexed vector,  edge (EDGE_INDEX (pred, succ)), with no\n+   wasted space in the client code due to sparse flow graphs.  */\n+\n+/* This functions initializes the edge list. Basically the entire \n+   flowgraph is processed, and all edges are assigned a number,\n+   and the data structure is filed in.  */\n+struct edge_list *\n+create_edge_list ()\n+{\n+  struct edge_list *elist;\n+  edge e;\n+  int num_edges;\n+  int x,y;\n+  int_list_ptr ptr;\n+  int block_count;\n+\n+  block_count = n_basic_blocks + 2;   /* Include the entry and exit blocks.  */\n+\n+  num_edges = 0;\n+\n+  /* Determine the number of edges in the flow graph by counting successor\n+     edges on each basic block.  */\n+  for (x = 0; x < n_basic_blocks; x++)\n+    {\n+      basic_block bb = BASIC_BLOCK (x);\n+\n+      for (e = bb->succ; e; e = e->succ_next)\n+\tnum_edges++;\n+    }\n+  /* Don't forget successors of the entry block.  */\n+  for (e = ENTRY_BLOCK_PTR->succ; e; e = e->succ_next)\n+    num_edges++;\n+\n+  elist = malloc (sizeof (struct edge_list));\n+  elist->num_blocks = block_count;\n+  elist->num_edges = num_edges;\n+  elist->index_to_edge = malloc (sizeof (edge) * num_edges);\n+\n+  num_edges = 0;\n+\n+  /* Follow successors of the entry block, and register these edges.  */\n+  for (e = ENTRY_BLOCK_PTR->succ; e; e = e->succ_next)\n+    {\n+      elist->index_to_edge[num_edges] = e;\n+      num_edges++;\n+    }\n+  \n+  for (x = 0; x < n_basic_blocks; x++)\n+    {\n+      basic_block bb = BASIC_BLOCK (x);\n+\n+      /* Follow all successors of blocks, and register these edges.  */\n+      for (e = bb->succ; e; e = e->succ_next)\n+\t{\n+\t  elist->index_to_edge[num_edges] = e;\n+\t  num_edges++;\n+\t}\n+    }\n+  return elist;\n+}\n+\n+/* This function free's memory associated with an edge list.  */\n+void\n+free_edge_list (elist)\n+     struct edge_list *elist;\n+{\n+  if (elist)\n+    {\n+      free (elist->index_to_edge);\n+      free (elist);\n+    }\n+}\n+\n+/* This function provides debug output showing an edge list.  */\n+void \n+print_edge_list (f, elist)\n+     FILE *f;\n+     struct edge_list *elist;\n+{\n+  int x;\n+  fprintf(f, \"Compressed edge list, %d BBs + entry & exit, and %d edges\\n\",\n+\t  elist->num_blocks - 2, elist->num_edges);\n+\n+  for (x = 0; x < elist->num_edges; x++)\n+    {\n+      fprintf (f, \" %-4d - edge(\", x);\n+      if (INDEX_EDGE_PRED_BB (elist, x) == ENTRY_BLOCK_PTR)\n+        fprintf (f,\"entry,\");\n+      else\n+        fprintf (f,\"%d,\", INDEX_EDGE_PRED_BB (elist, x)->index);\n+\n+      if (INDEX_EDGE_SUCC_BB (elist, x) == EXIT_BLOCK_PTR)\n+        fprintf (f,\"exit)\\n\");\n+      else\n+        fprintf (f,\"%d)\\n\", INDEX_EDGE_SUCC_BB (elist, x)->index);\n+    }\n+}\n+\n+/* This function provides an internal consistancy check of an edge list,\n+   verifying that all edges are present, and that there are no \n+   extra edges.  */\n+void\n+verify_edge_list (f, elist)\n+     FILE *f;\n+     struct edge_list *elist;\n+{\n+  int x, pred, succ, index;\n+  int_list_ptr ptr;\n+  int flawed = 0;\n+  edge e;\n+\n+  for (x = 0; x < n_basic_blocks; x++)\n+    {\n+      basic_block bb = BASIC_BLOCK (x);\n+\n+      for (e = bb->succ; e; e = e->succ_next)\n+\t{\n+\t  pred = e->src->index;\n+\t  succ = e->dest->index;\n+\t  index = EDGE_INDEX (elist, pred, succ);\n+\t  if (index == EDGE_INDEX_NO_EDGE)\n+\t    {\n+\t      fprintf (f, \"*p* No index for edge from %d to %d\\n\",pred, succ);\n+\t      continue;\n+\t    }\n+\t  if (INDEX_EDGE_PRED_BB (elist, index)->index != pred)\n+\t    fprintf (f, \"*p* Pred for index %d should be %d not %d\\n\",\n+\t\t     index, pred, INDEX_EDGE_PRED_BB (elist, index)->index);\n+\t  if (INDEX_EDGE_SUCC_BB (elist, index)->index != succ)\n+\t    fprintf (f, \"*p* Succ for index %d should be %d not %d\\n\",\n+\t\t     index, succ, INDEX_EDGE_SUCC_BB (elist, index)->index);\n+\t}\n+    }\n+  for (e = ENTRY_BLOCK_PTR->succ; e; e = e->succ_next)\n+    {\n+      pred = e->src->index;\n+      succ = e->dest->index;\n+      index = EDGE_INDEX (elist, pred, succ);\n+      if (index == EDGE_INDEX_NO_EDGE)\n+\t{\n+\t  fprintf (f, \"*p* No index for edge from %d to %d\\n\",pred, succ);\n+\t  continue;\n+\t}\n+      if (INDEX_EDGE_PRED_BB (elist, index)->index != pred)\n+\tfprintf (f, \"*p* Pred for index %d should be %d not %d\\n\",\n+\t\t index, pred, INDEX_EDGE_PRED_BB (elist, index)->index);\n+      if (INDEX_EDGE_SUCC_BB (elist, index)->index != succ)\n+\tfprintf (f, \"*p* Succ for index %d should be %d not %d\\n\",\n+\t\t index, succ, INDEX_EDGE_SUCC_BB (elist, index)->index);\n+    }\n+  /* We've verified that all the edges are in the list, no lets make sure\n+     there are no spurious edges in the list.  */\n+  \n+  for (pred = 0 ; pred < n_basic_blocks; pred++)\n+    for (succ = 0 ; succ < n_basic_blocks; succ++)\n+      {\n+        basic_block p = BASIC_BLOCK (pred);\n+        basic_block s = BASIC_BLOCK (succ);\n+\n+        int found_edge = 0;\n+\n+        for (e = p->succ; e; e = e->succ_next)\n+          if (e->dest == s)\n+\t    {\n+\t      found_edge = 1;\n+\t      break;\n+\t    }\n+        for (e = s->pred; e; e = e->pred_next)\n+          if (e->src == p)\n+\t    {\n+\t      found_edge = 1;\n+\t      break;\n+\t    }\n+        if (EDGE_INDEX (elist, pred, succ) == EDGE_INDEX_NO_EDGE \n+\t    && found_edge != 0)\n+\t  fprintf (f, \"*** Edge (%d, %d) appears to not have an index\\n\",\n+\t  \t   pred, succ);\n+        if (EDGE_INDEX (elist, pred, succ) != EDGE_INDEX_NO_EDGE\n+\t    && found_edge == 0)\n+\t  fprintf (f, \"*** Edge (%d, %d) has index %d, but there is no edge\\n\",\n+\t  \t   pred, succ, EDGE_INDEX (elist, pred, succ));\n+      }\n+    for (succ = 0 ; succ < n_basic_blocks; succ++)\n+      {\n+        basic_block p = ENTRY_BLOCK_PTR;\n+        basic_block s = BASIC_BLOCK (succ);\n+\n+        int found_edge = 0;\n+\n+        for (e = p->succ; e; e = e->succ_next)\n+          if (e->dest == s)\n+\t    {\n+\t      found_edge = 1;\n+\t      break;\n+\t    }\n+        for (e = s->pred; e; e = e->pred_next)\n+          if (e->src == p)\n+\t    {\n+\t      found_edge = 1;\n+\t      break;\n+\t    }\n+        if (EDGE_INDEX (elist, ENTRY_BLOCK, succ) == EDGE_INDEX_NO_EDGE \n+\t    && found_edge != 0)\n+\t  fprintf (f, \"*** Edge (entry, %d) appears to not have an index\\n\",\n+\t  \t   succ);\n+        if (EDGE_INDEX (elist, ENTRY_BLOCK, succ) != EDGE_INDEX_NO_EDGE\n+\t    && found_edge == 0)\n+\t  fprintf (f, \"*** Edge (entry, %d) has index %d, but no edge exists\\n\",\n+\t  \t   succ, EDGE_INDEX (elist, ENTRY_BLOCK, succ));\n+      }\n+    for (pred = 0 ; pred < n_basic_blocks; pred++)\n+      {\n+        basic_block p = BASIC_BLOCK (pred);\n+        basic_block s = EXIT_BLOCK_PTR;\n+\n+        int found_edge = 0;\n+\n+        for (e = p->succ; e; e = e->succ_next)\n+          if (e->dest == s)\n+\t    {\n+\t      found_edge = 1;\n+\t      break;\n+\t    }\n+        for (e = s->pred; e; e = e->pred_next)\n+          if (e->src == p)\n+\t    {\n+\t      found_edge = 1;\n+\t      break;\n+\t    }\n+        if (EDGE_INDEX (elist, pred, EXIT_BLOCK) == EDGE_INDEX_NO_EDGE\n+\t    && found_edge != 0)\n+\t  fprintf (f, \"*** Edge (%d, exit) appears to not have an index\\n\",\n+\t  \t   pred);\n+        if (EDGE_INDEX (elist, pred, EXIT_BLOCK) != EDGE_INDEX_NO_EDGE\n+\t    && found_edge == 0)\n+\t  fprintf (f, \"*** Edge (%d, exit) has index %d, but no edge exists\\n\",\n+\t  \t   pred, EDGE_INDEX (elist, pred, EXIT_BLOCK));\n+      }\n+}\n+\n+/* This routine will determine what, if any, edge there is between\n+   a specified predecessor and successor.  */\n+\n+int\n+find_edge_index (edge_list, pred, succ)\n+     struct edge_list *edge_list;\n+     int pred, succ;\n+{\n+  int x;\n+  for (x = 0; x < NUM_EDGES (edge_list); x++)\n+    {\n+      if (INDEX_EDGE_PRED_BB (edge_list, x)->index == pred\n+\t  && INDEX_EDGE_SUCC_BB (edge_list, x)->index == succ)\n+\treturn x;\n+    }\n+  return (EDGE_INDEX_NO_EDGE);\n+}\n+"}]}