{"sha": "e101152f8636505b18b7bdfd73bd1992702e094f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTEwMTE1MmY4NjM2NTA1YjE4YjdiZGZkNzNiZDE5OTI3MDJlMDk0Zg==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "2001-02-15T01:23:32Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "2001-02-15T01:23:32Z"}, "message": "[multiple changes]\n\n2001-02-14  Tom Tromey  <tromey@redhat.com>\n            Alexandre Petit-Bianco  <apbianco@redhat.com>\n\n        Fix for PR java/1261.\n        * typeck.c (build_java_array_type): Add public `clone' method to\n        arrays.\n        * parse.y (resolve_qualified_expression_name): Use current_class\n\twhen checking for inaccessibility.\n        (patch_method_invocation): Fixed error message when accessibility\n\tdenied.  Added `from_super' argument.\n\n2001-02-14  Alexandre Petit-Bianco  <apbianco@redhat.com>\n\n\t* parse.y (resolve_class): Don't build a fake decl. Use the one\n\talready built.\n\t* typeck.c (build_java_array_type): Build and assign decl to array\n\ttype.\n\n2001-02-14  Alexandre Petit-Bianco  <apbianco@redhat.com>\n\n\t* parse.y (not_accessible_p): Changed leading comment. Added extra\n\t`where' argument. Use it to enforce protected access rules.\n\t(resolve_qualified_expression_name): Added extra argument to\n\tnot_accessible_p.\n\t(patch_method_invocation): Use argument `primary' to provide\n\tnot_accessible_p with an extra argument.\n\t(lookup_method_invoke): Added extra argument to not_accessible_p.\n\t(search_applicable_method_list): Likewise.\n\n(http://gcc.gnu.org/ml/gcc-patches/2001-02/msg00849.html)\n\nFrom-SVN: r39701", "tree": {"sha": "94a9f394e08ff9de11cac1c913d8085fcd9b5e34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/94a9f394e08ff9de11cac1c913d8085fcd9b5e34"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e101152f8636505b18b7bdfd73bd1992702e094f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e101152f8636505b18b7bdfd73bd1992702e094f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e101152f8636505b18b7bdfd73bd1992702e094f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e101152f8636505b18b7bdfd73bd1992702e094f/comments", "author": null, "committer": null, "parents": [{"sha": "2ccc6d5b41b774dee1ad7fd477f27e8016f644d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ccc6d5b41b774dee1ad7fd477f27e8016f644d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ccc6d5b41b774dee1ad7fd477f27e8016f644d2"}], "stats": {"total": 122, "additions": 86, "deletions": 36}, "files": [{"sha": "e0f3ee09a331b7355dab85f40606cea3cc4cccf8", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e101152f8636505b18b7bdfd73bd1992702e094f/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e101152f8636505b18b7bdfd73bd1992702e094f/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=e101152f8636505b18b7bdfd73bd1992702e094f", "patch": "@@ -1,3 +1,32 @@\n+2001-02-14  Tom Tromey  <tromey@redhat.com>\n+            Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+        Fix for PR java/1261.\n+        * typeck.c (build_java_array_type): Add public `clone' method to\n+        arrays.\n+        * parse.y (resolve_qualified_expression_name): Use current_class\n+\twhen checking for inaccessibility.\n+        (patch_method_invocation): Fixed error message when accessibility\n+\tdenied.  Added `from_super' argument.\n+\n+2001-02-14  Alexandre Petit-Bianco  <apbianco@redhat.com>\n+\n+\t* parse.y (resolve_class): Don't build a fake decl. Use the one\n+\talready built.\n+\t* typeck.c (build_java_array_type): Build and assign decl to array\n+\ttype.\n+\n+2001-02-14  Alexandre Petit-Bianco  <apbianco@redhat.com>\n+\n+\t* parse.y (not_accessible_p): Changed leading comment. Added extra\n+\t`where' argument. Use it to enforce protected access rules.\n+\t(resolve_qualified_expression_name): Added extra argument to\n+\tnot_accessible_p.\n+\t(patch_method_invocation): Use argument `primary' to provide\n+\tnot_accessible_p with an extra argument.\n+\t(lookup_method_invoke): Added extra argument to not_accessible_p.\n+\t(search_applicable_method_list): Likewise.\n+\n 2001-02-13  Alexandre Petit-Bianco  <apbianco@redhat.com>\n \n \t* parse.y (resolve_qualified_expression_name): Try to resolve as"}, {"sha": "e70b2eb0cd8256ca5bf1df635baf55f94c27d9aa", "filename": "gcc/java/parse.y", "status": "modified", "additions": 48, "deletions": 35, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e101152f8636505b18b7bdfd73bd1992702e094f/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e101152f8636505b18b7bdfd73bd1992702e094f/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=e101152f8636505b18b7bdfd73bd1992702e094f", "patch": "@@ -124,7 +124,7 @@ static tree resolve_expression_name PARAMS ((tree, tree *));\n static tree maybe_create_class_interface_decl PARAMS ((tree, tree, tree, tree));\n static int check_class_interface_creation PARAMS ((int, int, tree, \n \t\t\t\t\t\t  tree, tree, tree));\n-static tree patch_method_invocation PARAMS ((tree, tree, tree, \n+static tree patch_method_invocation PARAMS ((tree, tree, tree, int,\n \t\t\t\t\t    int *, tree *));\n static int breakdown_qualified PARAMS ((tree *, tree *, tree));\n static tree resolve_and_layout PARAMS ((tree, tree));\n@@ -197,7 +197,7 @@ static tree maybe_access_field PARAMS ((tree, tree, tree));\n static int complete_function_arguments PARAMS ((tree));\n static int check_for_static_method_reference PARAMS ((tree, tree, tree, \n \t\t\t\t\t\t      tree, tree));\n-static int not_accessible_p PARAMS ((tree, tree, int));\n+static int not_accessible_p PARAMS ((tree, tree, tree, int));\n static void check_deprecation PARAMS ((tree, tree));\n static int class_in_current_package PARAMS ((tree));\n static tree build_if_else_statement PARAMS ((int, tree, tree, tree));\n@@ -5480,14 +5480,9 @@ resolve_class (enclosing, class_type, decl, cl)\n \t  CLASS_LOADED_P (resolved_type) = 1;\n \t  name--;\n \t}\n-      /* Build a fake decl for this, since this is what is expected to\n-         be returned.  */\n-      resolved_type_decl =\n-\tbuild_decl (TYPE_DECL, TYPE_NAME (resolved_type), resolved_type);\n-      /* Figure how those two things are important for error report. FIXME */\n-      DECL_SOURCE_LINE (resolved_type_decl) = 0;\n-      DECL_SOURCE_FILE (resolved_type_decl) = input_filename;\n-      TYPE_NAME (class_type) = TYPE_NAME (resolved_type);\n+      /* A TYPE_NAME that is a TYPE_DECL was set in\n+         build_java_array_type, return it. */\n+      resolved_type_decl = TYPE_NAME (resolved_type);\n     }\n   TREE_TYPE (class_type) = resolved_type;\n   return resolved_type_decl;\n@@ -9034,7 +9029,8 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t    CALL_USING_SUPER (qual_wfl) = 1;\n \t  location = (TREE_CODE (qual_wfl) == CALL_EXPR ?\n \t\t      EXPR_WFL_LINECOL (TREE_OPERAND (qual_wfl, 0)) : 0);\n-\t  *where_found = patch_method_invocation (qual_wfl, decl, type, \n+\t  *where_found = patch_method_invocation (qual_wfl, decl, type,\n+\t\t\t\t\t\t  from_super,\n \t\t\t\t\t\t  &is_static, &ret_decl);\n \t  if (*where_found == error_mark_node)\n \t    {\n@@ -9287,7 +9283,7 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t      return 1;\n \t    }\n \n-\t  if (not_accessible_p (TREE_TYPE (decl), decl, 0))\n+\t  if (not_accessible_p (TREE_TYPE (decl), decl, type, 0))\n \t    {\n \t      parse_error_context \n \t\t(qual_wfl, \"Can't access %s field `%s.%s' from `%s'\",\n@@ -9407,7 +9403,8 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t\tCLASS_LOADED_P (field_decl_type) = 1;\n \t      \n \t      /* Check on accessibility here */\n-\t      if (not_accessible_p (type, field_decl, from_super))\n+\t      if (not_accessible_p (current_class, field_decl,\n+\t\t\t\t    TREE_TYPE (decl), from_super))\n \t\t{\n \t\t  parse_error_context \n \t\t    (qual_wfl,\n@@ -9494,12 +9491,16 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n }\n \n /* 6.6 Qualified name and access control. Returns 1 if MEMBER (a decl)\n-   can't be accessed from REFERENCE (a record type). This should be\n-   used when decl is a field or a method.*/\n+   can't be accessed from REFERENCE (a record type). If MEMBER\n+   features a protected access, we then use WHERE which, if non null,\n+   holds the type of MEMBER's access that is checked against\n+   6.6.2.1. This function should be used when decl is a field or a\n+   method.  */\n \n static int\n-not_accessible_p (reference, member, from_super)\n+not_accessible_p (reference, member, where, from_super)\n      tree reference, member;\n+     tree where;\n      int from_super;\n {\n   int access_flag = get_access_flags_from_decl (member);\n@@ -9525,6 +9526,12 @@ not_accessible_p (reference, member, from_super)\n       if (from_super)\n \treturn 0;\n \n+      /* If where is active, access was made through a\n+\t qualifier. Access is granted if the type of the qualifier is\n+\t or is a sublass of the type the access made from (6.6.2.1.)  */\n+      if (where && !inherits_from_p (where, reference))\n+\treturn 1;\n+\n       /* Otherwise, access is granted if occuring from the class where\n \t member is declared or a subclass of it. Find the right\n \t context to perform the check */\n@@ -9663,8 +9670,10 @@ maybe_access_field (decl, where, type)\n    used. IS_STATIC is set to 1 if the invoked function is static. */\n \n static tree\n-patch_method_invocation (patch, primary, where, is_static, ret_decl)\n+patch_method_invocation (patch, primary, where, from_super,\n+                        is_static, ret_decl)\n      tree patch, primary, where;\n+     int from_super;\n      int *is_static;\n      tree *ret_decl;\n {\n@@ -9898,19 +9907,21 @@ patch_method_invocation (patch, primary, where, is_static, ret_decl)\n \n   /* Check accessibility, position the is_static flag, build and\n      return the call */\n-  if (not_accessible_p (DECL_CONTEXT (current_function_decl), list, 0))\n-    {\n-      char *fct_name = xstrdup (lang_printable_name (list, 0));\n-      int ctor_p = DECL_CONSTRUCTOR_P (list);\n-      parse_error_context \n-\t(wfl, \"Can't access %s %s `%s%s.%s' from `%s'\",\n-\t java_accstring_lookup (get_access_flags_from_decl (list)),\n-\t (ctor_p ? \"constructor\" : \"method\"),\n-\t (ctor_p ? \n-\t  \"\" : lang_printable_name_wls (TREE_TYPE (TREE_TYPE (list)), 0)), \n-\t IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (DECL_CONTEXT (list)))), \n-\t fct_name, IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (current_class))));\n-      free (fct_name);\n+  if (not_accessible_p (DECL_CONTEXT (current_function_decl), list,\n+\t\t\t(primary ? TREE_TYPE (TREE_TYPE (primary)) : \n+\t\t\t NULL_TREE), from_super))\n+    {\n+      char *fct_name = (char *) IDENTIFIER_POINTER (DECL_NAME (list));\n+      char *access = java_accstring_lookup (get_access_flags_from_decl (list));\n+      char *klass = (char *) IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (DECL_CONTEXT (list))));\n+      char *refklass = (char *) IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (current_class)));\n+      char *what = (char *) (DECL_CONSTRUCTOR_P (list)\n+\t\t\t     ? \"constructor\" : \"method\");\n+      /* FIXME: WFL yields the wrong message here but I don't know\n+\t what else to use.  */\n+      parse_error_context (wfl,\n+\t\t\t   \"Can't access %s %s `%s.%s' from `%s'\",\n+\t\t\t   access, what, klass, fct_name, refklass);\n       PATCH_METHOD_RETURN_ERROR ();\n     }\n   check_deprecation (wfl, list);\n@@ -10338,7 +10349,7 @@ lookup_method_invoke (lc, cl, class, name, arg_list)\n \t{\n \t  tree cm = TREE_VALUE (current);\n \t  char string [4096];\n-\t  if (!cm || not_accessible_p (class, cm, 0))\n+\t  if (!cm || not_accessible_p (class, cm, NULL_TREE, 0))\n \t    continue;\n \t  sprintf \n \t    (string, \"  `%s' in `%s'%s\",\n@@ -10532,7 +10543,7 @@ search_applicable_methods_list (lc, method, name, arglist, list, all_list)\n \t{\n \t  /* Retain accessible methods only */\n \t  if (!not_accessible_p (DECL_CONTEXT (current_function_decl), \n-\t\t\t\t method, 0))\n+\t\t\t\t method, NULL_TREE, 0))\n \t    *list = tree_cons (NULL_TREE, method, *list);\n \t  else\n \t    /* Also retain all selected method here */\n@@ -11409,9 +11420,11 @@ java_complete_lhs (node)\n \t{\n \t  tree decl, wfl = TREE_OPERAND (node, 0);\n \t  int in_this = CALL_THIS_CONSTRUCTOR_P (node);\n+\t  int from_super = (EXPR_WFL_NODE (TREE_OPERAND (node, 0)) ==\n+                           super_identifier_node);\n \n-\t  node = patch_method_invocation (node, NULL_TREE, \n-\t\t\t\t\t  NULL_TREE, 0, &decl);\n+\t  node = patch_method_invocation (node, NULL_TREE, NULL_TREE,\n+\t\t\t\t\t  from_super, 0, &decl);\n \t  if (node == error_mark_node)\n \t    return error_mark_node;\n \n@@ -11462,7 +11475,7 @@ java_complete_lhs (node)\n              class. TESTME, FIXME */\n \t  tree lvalue = java_stabilize_reference (TREE_OPERAND (node, 0)); \n \n-\t  /* Hand stablize the lhs on both places */\n+\t  /* Hand stabilize the lhs on both places */\n \t  TREE_OPERAND (node, 0) = lvalue;\n \t  TREE_OPERAND (TREE_OPERAND (node, 1), 0) = \n \t    (flag_emit_class_files ? lvalue : save_expr (lvalue));"}, {"sha": "4f3971612db93a2733783ffda45cef69aac05d43", "filename": "gcc/java/typeck.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e101152f8636505b18b7bdfd73bd1992702e094f/gcc%2Fjava%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e101152f8636505b18b7bdfd73bd1992702e094f/gcc%2Fjava%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Ftypeck.c?ref=e101152f8636505b18b7bdfd73bd1992702e094f", "patch": "@@ -406,7 +406,9 @@ build_java_array_type (element_type, length)\n   el_name = TYPE_NAME (el_name);\n   if (TREE_CODE (el_name) == TYPE_DECL)\n     el_name = DECL_NAME (el_name);\n-  TYPE_NAME (t) = identifier_subst (el_name, \"\", '.', '.', \"[]\");\n+  TYPE_NAME (t) = build_decl (TYPE_DECL,\n+                             identifier_subst (el_name, \"\", '.', '.', \"[]\"),\n+                             t);\n \n   set_java_signature (t, sig);\n   set_super_info (0, t, object_type_node, 0);\n@@ -420,6 +422,12 @@ build_java_array_type (element_type, length)\n   DECL_CONTEXT (fld) = t;\n   FIELD_PUBLIC (fld) = 1;\n   FIELD_FINAL (fld) = 1;\n+  TREE_READONLY (fld) = 1;\n+\n+  /* Add clone method.  This is different from Object.clone because it\n+     is public.  */\n+  add_method (t, ACC_PUBLIC | ACC_FINAL, get_identifier (\"clone\"),\n+             get_identifier (\"()Ljava/lang/Object;\"));\n \n   atype = build_prim_array_type (element_type, length);\n   arfld = build_decl (FIELD_DECL, get_identifier (\"data\"), atype);"}]}