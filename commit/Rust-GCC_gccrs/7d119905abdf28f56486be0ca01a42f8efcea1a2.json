{"sha": "7d119905abdf28f56486be0ca01a42f8efcea1a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2QxMTk5MDVhYmRmMjhmNTY0ODZiZTBjYTAxYTQyZjhlZmNlYTFhMg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2018-11-13T04:47:20Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2018-11-13T04:47:20Z"}, "message": "Avoid double substitution with complete explicit template arguments.\n\nPreviously, when we got a function template with explicit arguments for all\nof the template parameters, we still did \"deduction\", which of course\ncouldn't deduce anything, but did other deduction-time checking of\nnon-dependent conversions and such.  This broke down with the unevaluated\nlambdas patch (to follow): substituting into the lambda multiple times, once\nto get the function type for deduction and then again to generate the actual\ndecl, doesn't work, since different substitutions of a lambda produce\ndifferent types.  I believe that skipping the initial substitution when we\nhave all the arguments is still conformant, and produces better diagnostics\nfor some testcases.\n\n\t* pt.c (fn_type_unification): If we have a full set of explicit\n\targuments, go straight to substitution.\n\nFrom-SVN: r266055", "tree": {"sha": "ea8bf50fae9497d15cbee4407a37515b686e65af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea8bf50fae9497d15cbee4407a37515b686e65af"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d119905abdf28f56486be0ca01a42f8efcea1a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d119905abdf28f56486be0ca01a42f8efcea1a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d119905abdf28f56486be0ca01a42f8efcea1a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d119905abdf28f56486be0ca01a42f8efcea1a2/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7c23c87c93f3eafa5c22d1f4f52711d97f3a4329", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c23c87c93f3eafa5c22d1f4f52711d97f3a4329", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c23c87c93f3eafa5c22d1f4f52711d97f3a4329"}], "stats": {"total": 112, "additions": 61, "deletions": 51}, "files": [{"sha": "5cd147114a0e623d5b28709da3b1fd8e783c7af7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d119905abdf28f56486be0ca01a42f8efcea1a2/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d119905abdf28f56486be0ca01a42f8efcea1a2/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7d119905abdf28f56486be0ca01a42f8efcea1a2", "patch": "@@ -1,5 +1,8 @@\n 2018-11-12  Jason Merrill  <jason@redhat.com>\n \n+\t* pt.c (fn_type_unification): If we have a full set of explicit\n+\targuments, go straight to substitution.\n+\n \t* decl2.c (min_vis_expr_r, expr_visibility): New.\n \t(min_vis_r): Call expr_visibility.\n \t(constrain_visibility_for_template): Likewise."}, {"sha": "f948aef37768d1ecd6d9ae1693dfb0cb47459b2d", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 44, "deletions": 31, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d119905abdf28f56486be0ca01a42f8efcea1a2/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d119905abdf28f56486be0ca01a42f8efcea1a2/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=7d119905abdf28f56486be0ca01a42f8efcea1a2", "patch": "@@ -19800,6 +19800,11 @@ fn_type_unification (tree fn,\n   tsubst_flags_t complain = (explain_p ? tf_warning_or_error : tf_none);\n   bool ok;\n   static int deduction_depth;\n+  /* type_unification_real will pass back any access checks from default\n+     template argument substitution.  */\n+  vec<deferred_access_check, va_gc> *checks = NULL;\n+  /* We don't have all the template args yet.  */\n+  bool incomplete = true;\n \n   tree orig_fn = fn;\n   if (flag_new_inheriting_ctors)\n@@ -19857,7 +19862,7 @@ fn_type_unification (tree fn,\n \t template results in an invalid type, type deduction fails.  */\n       int i, len = TREE_VEC_LENGTH (tparms);\n       location_t loc = input_location;\n-      bool incomplete = false;\n+      incomplete = false;\n \n       if (explicit_targs == error_mark_node)\n \tgoto fail;\n@@ -19923,33 +19928,52 @@ fn_type_unification (tree fn,\n             }\n         }\n \n-      if (!push_tinst_level (fn, explicit_targs))\n+      if (incomplete)\n \t{\n-\t  excessive_deduction_depth = true;\n-\t  goto fail;\n-\t}\n-      processing_template_decl += incomplete;\n-      input_location = DECL_SOURCE_LOCATION (fn);\n-      /* Ignore any access checks; we'll see them again in\n-\t instantiate_template and they might have the wrong\n-\t access path at this point.  */\n-      push_deferring_access_checks (dk_deferred);\n-      fntype = tsubst (TREE_TYPE (fn), explicit_targs,\n-\t\t       complain | tf_partial | tf_fndecl_type, NULL_TREE);\n-      pop_deferring_access_checks ();\n-      input_location = loc;\n-      processing_template_decl -= incomplete;\n-      pop_tinst_level ();\n+\t  if (!push_tinst_level (fn, explicit_targs))\n+\t    {\n+\t      excessive_deduction_depth = true;\n+\t      goto fail;\n+\t    }\n+\t  ++processing_template_decl;\n+\t  input_location = DECL_SOURCE_LOCATION (fn);\n+\t  /* Ignore any access checks; we'll see them again in\n+\t     instantiate_template and they might have the wrong\n+\t     access path at this point.  */\n+\t  push_deferring_access_checks (dk_deferred);\n+\t  tsubst_flags_t ecomplain = complain | tf_partial | tf_fndecl_type;\n+\t  fntype = tsubst (TREE_TYPE (fn), explicit_targs, ecomplain, NULL_TREE);\n+\t  pop_deferring_access_checks ();\n+\t  input_location = loc;\n+\t  --processing_template_decl;\n+\t  pop_tinst_level ();\n \n-      if (fntype == error_mark_node)\n-\tgoto fail;\n+\t  if (fntype == error_mark_node)\n+\t    goto fail;\n+\t}\n \n       /* Place the explicitly specified arguments in TARGS.  */\n       explicit_targs = INNERMOST_TEMPLATE_ARGS (explicit_targs);\n       for (i = NUM_TMPL_ARGS (explicit_targs); i--;)\n \tTREE_VEC_ELT (targs, i) = TREE_VEC_ELT (explicit_targs, i);\n+      if (!incomplete && CHECKING_P\n+\t  && !NON_DEFAULT_TEMPLATE_ARGS_COUNT (targs))\n+\tSET_NON_DEFAULT_TEMPLATE_ARGS_COUNT\n+\t  (targs, NUM_TMPL_ARGS (explicit_targs));\n+    }\n+\n+  if (return_type && strict != DEDUCE_CALL)\n+    {\n+      tree *new_args = XALLOCAVEC (tree, nargs + 1);\n+      new_args[0] = return_type;\n+      memcpy (new_args + 1, args, nargs * sizeof (tree));\n+      args = new_args;\n+      ++nargs;\n     }\n \n+  if (!incomplete)\n+    goto deduced;\n+\n   /* Never do unification on the 'this' parameter.  */\n   parms = skip_artificial_parms_for (fn, TYPE_ARG_TYPES (fntype));\n \n@@ -19963,14 +19987,7 @@ fn_type_unification (tree fn,\n     }\n   else if (return_type)\n     {\n-      tree *new_args;\n-\n       parms = tree_cons (NULL_TREE, TREE_TYPE (fntype), parms);\n-      new_args = XALLOCAVEC (tree, nargs + 1);\n-      new_args[0] = return_type;\n-      memcpy (new_args + 1, args, nargs * sizeof (tree));\n-      args = new_args;\n-      ++nargs;\n     }\n \n   /* We allow incomplete unification without an error message here\n@@ -19988,11 +20005,6 @@ fn_type_unification (tree fn,\n       goto fail;\n     }\n \n-  /* type_unification_real will pass back any access checks from default\n-     template argument substitution.  */\n-  vec<deferred_access_check, va_gc> *checks;\n-  checks = NULL;\n-\n   ok = !type_unification_real (DECL_INNERMOST_TEMPLATE_PARMS (fn),\n \t\t\t       full_targs, parms, args, nargs, /*subr=*/0,\n \t\t\t       strict, &checks, explain_p);\n@@ -20035,6 +20047,7 @@ fn_type_unification (tree fn,\n \t\t\t\t       convs, explain_p))\n     goto fail;\n \n+ deduced:\n   /* All is well so far.  Now, check:\n \n      [temp.deduct]"}, {"sha": "7f5005b915cd0faadfd1e8726912d0ef7b96a121", "filename": "gcc/testsuite/g++.dg/cpp0x/decltype48.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d119905abdf28f56486be0ca01a42f8efcea1a2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype48.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d119905abdf28f56486be0ca01a42f8efcea1a2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype48.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype48.C?ref=7d119905abdf28f56486be0ca01a42f8efcea1a2", "patch": "@@ -6,7 +6,7 @@ template<typename T> struct baz { };\n template<typename T> T bar();\n \n template<typename T, typename ... U>\n-baz<decltype(bar<Int>(bar<U>() ...))> // { dg-error \"no match\" }\n+baz<decltype(bar<Int>(bar<U>() ...))> // { dg-error \"\" }\n foo();\n \n int main()"}, {"sha": "1f8c4a4482169cb37dc9cbd82baee554dd9c4be3", "filename": "gcc/testsuite/g++.dg/cpp0x/diag1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d119905abdf28f56486be0ca01a42f8efcea1a2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdiag1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d119905abdf28f56486be0ca01a42f8efcea1a2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdiag1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdiag1.C?ref=7d119905abdf28f56486be0ca01a42f8efcea1a2", "patch": "@@ -23,7 +23,7 @@ struct TypeC\n   //   TypeC::fn()\n   // we don't want to see the template header, return type, or parameter bindings\n   // for TypeB::fn.\n-  template <int N> auto fn() -> decltype(b.fn<N>()); // { dg-bogus \"typename|with\" }\n+  template <int N> auto fn() -> decltype(b.fn<N>()); // { dg-bogus \"typename\" }\n };\n \n int main()"}, {"sha": "1f365b7a10aba1bb3058858067cd304b4be5e01e", "filename": "gcc/testsuite/g++.dg/cpp0x/error4.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d119905abdf28f56486be0ca01a42f8efcea1a2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ferror4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d119905abdf28f56486be0ca01a42f8efcea1a2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ferror4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ferror4.C?ref=7d119905abdf28f56486be0ca01a42f8efcea1a2", "patch": "@@ -12,7 +12,7 @@ struct S {\n   template<typename U>\n     static decltype(*declval<U>()) get(...); // { dg-error \"operator*\" }\n \n-  typedef decltype(get<T>(declval<T>())) type; // { dg-error \"no match\" }\n+  typedef decltype(get<T>(declval<T>())) type; // { dg-error \"\" }\n };\n \n struct X { };"}, {"sha": "8b4ffa66ea608d726a500c9ac8049986fad0ca3e", "filename": "gcc/testsuite/g++.dg/cpp0x/pr77655.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d119905abdf28f56486be0ca01a42f8efcea1a2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr77655.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d119905abdf28f56486be0ca01a42f8efcea1a2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr77655.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr77655.C?ref=7d119905abdf28f56486be0ca01a42f8efcea1a2", "patch": "@@ -3,7 +3,7 @@\n \n template <class F> void g(F);\n template <class... A>\n-auto h(A &&... a) -> decltype(g(0, g<decltype(a)>(a)...)) {  // { dg-error \"no matching\" }\n+auto h(A &&... a) -> decltype(g(0, g<decltype(a)>(a)...)) {  // { dg-error \"\" }\n   h([] {});  // { dg-error \"no matching\" }\n }\n "}, {"sha": "b19655d649614d74797a4bd3360fd6beb5312316", "filename": "gcc/testsuite/g++.dg/diagnostic/param-type-mismatch-2.C", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d119905abdf28f56486be0ca01a42f8efcea1a2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fparam-type-mismatch-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d119905abdf28f56486be0ca01a42f8efcea1a2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fparam-type-mismatch-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fparam-type-mismatch-2.C?ref=7d119905abdf28f56486be0ca01a42f8efcea1a2", "patch": "@@ -134,21 +134,17 @@ int test_7 (int one, T two, float three); // { dg-line test_7_decl }\n int test_7 (int first, const char *second, float third)\n {\n   return test_7 <const char **> (first, second, third); // { dg-line test_7_usage }\n-  // { dg-error \"no matching function\" \"\" { target *-*-* } test_7_usage }\n+  // { dg-message \"cannot convert 'const char\\\\*' to 'const char\\\\*\\\\*'\" \"\" { target *-*-* } test_7_usage }\n   /* { dg-begin-multiline-output \"\" }\n    return test_7 <const char **> (first, second, third);\n-                                                      ^\n+                                         ^~~~~~\n+                                         |\n+                                         const char*\n      { dg-end-multiline-output \"\" } */\n-  // { dg-message \"candidate: 'template<class T> int test_7\\\\(int, T, float\\\\)'\" \"\" { target *-*-* } test_7_decl }\n+  // { dg-message \"initializing argument 2 of 'int test_7\\\\(int, T, float\\\\) .with T = const char\\\\*\\\\*.'\" \"\" { target *-*-* } test_7_decl }\n   /* { dg-begin-multiline-output \"\" }\n  int test_7 (int one, T two, float three);\n-     ^~~~~~\n-     { dg-end-multiline-output \"\" } */\n-  // { dg-message \"template argument deduction/substitution failed:\" \"\" { target *-*-* } test_7_decl }\n-  // { dg-message \"cannot convert 'second' \\\\(type 'const char\\\\*'\\\\) to type 'const char\\\\*\\\\*'\" \"\" { target *-*-* } test_7_usage }\n-  /* { dg-begin-multiline-output \"\" }\n-   return test_7 <const char **> (first, second, third);\n-                                         ^~~~~~\n+                      ~~^~~\n      { dg-end-multiline-output \"\" } */\n }\n "}, {"sha": "cb5c3602a66aaa2d7f29d1c004b6d314db27d201", "filename": "gcc/testsuite/g++.dg/diagnostic/param-type-mismatch.C", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d119905abdf28f56486be0ca01a42f8efcea1a2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fparam-type-mismatch.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d119905abdf28f56486be0ca01a42f8efcea1a2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fparam-type-mismatch.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fparam-type-mismatch.C?ref=7d119905abdf28f56486be0ca01a42f8efcea1a2", "patch": "@@ -130,18 +130,16 @@ int test_7 (int one, T two, float three);\n \n int test_7 (int first, int second, float third)\n {\n-  return test_7 <const char *> (first, second, third); // { dg-error \"no matching function\" }\n-  /* { dg-begin-multiline-output \"\" }\n-   return test_7 <const char *> (first, second, third);\n-                                                     ^\n-     { dg-end-multiline-output \"\" } */\n+  return test_7 <const char *> (first, second, third); // { dg-error \"invalid conversion from 'int' to 'const char\\\\*'\" }\n   /* { dg-begin-multiline-output \"\" }\n    return test_7 <const char *> (first, second, third);\n                                         ^~~~~~\n+                                        |\n+                                        int\n      { dg-end-multiline-output \"\" } */\n   /* { dg-begin-multiline-output \"\" }\n  int test_7 (int one, T two, float three);\n-     ^~~~~~\n+                      ~~^~~\n      { dg-end-multiline-output \"\" } */\n }\n "}]}