{"sha": "36a117a5b33194265633e62df5968d2385baf8be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzZhMTE3YTViMzMxOTQyNjU2MzNlNjJkZjU5NjhkMjM4NWJhZjhiZQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-07-28T01:03:16Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-07-28T01:03:16Z"}, "message": "cp-tree.h (TI_USES_TEMPLATE_PARMS): Remove.\n\n\t* cp-tree.h (TI_USES_TEMPLATE_PARMS): Remove.\n\t(build_template_decl_overload): Remove.\n\t(set_mangled_name_for_decl): New function.\n\t(innermost_args): Remove is_spec parameter.\n\t(most_specialized, most_specialized_class): Remove declarations.\n\t(lookup_template_class): Add entering_scope parameter.\n\t(maybe_process_partial_specialization): New function.\n\t(finish_template_decl): Likewise.\n\t(finish_template_type): Likewise.\n\t* class.c (finish_struct): Clean up processing of member template\n\tspecializations.\n\t* decl.c (pushtag): Fix\tformatting.\n\t(lookup_tag): Improve handling of pseudo-global levels.\n\t(make_typename_type): Adjust call to lookup_template_class.\n\t(shadow_tag): Use maybe_process_partial_specialization.\n\t(xref_tag): Improve handling of member friends.\n\t(start_function): Call push_nested_class before\n\tpush_template_decl.  Don't call push_template_decl for\n\tspecializations.\n\t* decl2.c (grok_x_components): Don't call xref_tag for\n\ttemplate instantiations.  Handle UNION_TYPEs like RECORD_TYPEs.\n\t(grokclassfn): Use set_mangled_name_for_decl.\n\t(arg_assoc_class): Adjust call to innermost_args.\n\t(mark_used): Don't call instantiate_decl for a TEMPLATE_DECL.\n\t* error.c (dump_function_name): Improve printing of template\n\tfunction names.\n\t* friend.c (is_friend): Don't compare types of decls to determine\n\tfriendship, unless flag_guiding_decls.\n\t(make_friend_class): Partial specializations cannot be friends.\n\t(do_friend): Use set_mangled_name_for_decl.  Call\n\tpush_template_decl_real instead of push_template_decl.\n\t* method.c (build_decl_overload_real): Remove prototype.  Give it\n\texternal linkage.\n\t(build_overload_identififer): Adjust call to innermost_args.\n\t(build_template_decl_overload): Remove.\n\t(set_mangled_name_for_decl): New function.\n\t* parse.y (.finish_template_type): New non-terminal.\n\t(template_def): Use finish_template_decl.  Use template_extdef\n\tinstead of extdef.\n\t(template_extdef, template_datadef): New non-terminals, containing\n\tonly those rules for things which can be templates.\n\t(datadef): Tidy.\n\t(template_type, self_template_type): Use .finish_template_type.\n\t(named_class_head): Use maybe_process_partial_specialization.\n\t* pt.c (mangle_class_name_for_template): Remove context parameter.\n\t(get_class_bindings): Remove outer_args parameter.\n\t(complete_template_args): Remove.\n\t(add_outermost_template_args): New function.\n\t(register_specialization): Return the specialization.\n\t(unregister_specialization): New function.\n\t(tsubst_template_parms): Likewise.\n\t(most_specialized, most_specialized_class): Prototype here as\n\tstatic.\n\t(original_template): Rename to most_general_template.\n\t(tsubst_template_parms): New function.\n\t(set_mangled_name_for_template_decl): Likewise.\n\t(TMPL_ARGS_DEPTH): New macro.\n\t(TMPL_ARGS_HAVE_MULTIPLE_LEVELS): Adjust.\n\t(TMPL_ARGS_LEVEL): New macro.\n\t(SET_TMPL_ARGS_LEVEL): Likewise.\n\t(TMPL_ARG): Likewise.\n\t(SET_TMPL_ARG): Likewise.\n\t(TMPL_ARGS_DEPTH): Likewise.\n\t(finish_member_template_decl): Use finish_template_decl.\n\t(maybe_process_partial_specialization): New function, split out\n\tfrom tsubst.\n\t(inline_needs_template_parms): Use TMPL_PARMS_DEPTH.\n\t(maybe_begin_member_template_processing): Use new macros.\n\t(is_member_template): Likewise.\n\t(is_member_template_class): Likewise.\n\t(add_to_template_args): Likewise.  Deal with multiple levels of\n\targs.\n\t(maybe_process_partial_specialization): New function.\n\t(retrieve_specialization): Add consistency check.\n\t(determine_specialization): Return full argument list.\n\t(check_explicit_specialization): Tweak friend handling.  Use full\n\targument lists.  Simplify.\n\t(current_template_args): Use new macros.\n\t(push_template_decl_real): Change ill-named mainargs to specargs.\n\tCheck that a partial specialization actually specializes at least\n\tone parameter.   Improve friend handling.  Modify for full\n\ttemplate arguments.\n\t(classtype_mangled_name): Don't mangle the names of\n\tspecializations.\n\t(lookup_template_class): Add entering_scope parameter.  Use it to\n\tavoid finding a template type when an instantiation is required.\n\tSimplify.  Use full template arguments.\n\t(tsubst_friend_function): Use unregister_specialization.  Use new\n\tmacros.  Use full template arguments.\n\t(tsubst_friend_class): Substitute, using tsubst_template_parms,\n\tinto the template parameters before passing them to\n\tredeclare_class_template.\n\t(instantiate_class_template): Simplify.  Use full template\n\targuments.  Adjust calls to get_class_bindings.  Use\n\tSET_IDENTIFIER_TYPE_VALUE where needed.  Improve friend handling.\n\t(innermost_args): Use new macros.\n\t(tsubst_aggr_type): New function, split out from tsubst.\n\t(tsubst): Use tsubst_aggr_type, tsubst_template_parms, new calling\n\tconventions for lookup_tmeplate_class.  Refine handling of partial\n\tinstantiations.   Remove calls to complete_template_args.\n\tSimplify.  Add consistency checks.  Use set_mangled_name_for_decl\n\tand set_mangled_name_for_template_decl.\n\t(tsubst_copy): Use tsubst_aggr_type.\n\t(instantiate_template): Use full template arguments.\n\t(more_specialized): Improve formatting.\n\t(more_specialized_class): Adjust calls to get_class_bindings.\n\t(get_bindings_real): Don't call complete_template_args.\n\t(most_specialized): Don't overwrite input; create a new list.\n\t(most_specialized_class): Use most_general_template.\n\t(regenerate_decl_from_template): Use unregister_specialization.\n\tUse full template arguments.\n\t(instantiate_decl): Use full template arguments.\n\t(set_mangled_name_for_template_decl): New function.\n\t* semantics.c (begin_class_definition): Use\n\tmaybe_process_partial_specialization.\n\t(finish_member_class_template): New function.\n\t(finish_template_decl): Likewise.\n\t(finish_template_type): Likewise.\n\t(typeck.c): Don't crash after issuing a compiler_error.\n\t* Makefile.in (CONFLICTS): Adjust; we removed a s/r conflict.\n\nFrom-SVN: r21433", "tree": {"sha": "8d2a9c9d4295100bf295320dbf0267643eb1736d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d2a9c9d4295100bf295320dbf0267643eb1736d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/36a117a5b33194265633e62df5968d2385baf8be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36a117a5b33194265633e62df5968d2385baf8be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36a117a5b33194265633e62df5968d2385baf8be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36a117a5b33194265633e62df5968d2385baf8be/comments", "author": null, "committer": null, "parents": [{"sha": "0167ae91ffb59682b168efa319b5ecf7ed3184bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0167ae91ffb59682b168efa319b5ecf7ed3184bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0167ae91ffb59682b168efa319b5ecf7ed3184bf"}], "stats": {"total": 3305, "additions": 2061, "deletions": 1244}, "files": [{"sha": "52df5d573d28aea1ee4d9f17a5e6b12c1f7c25b5", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=36a117a5b33194265633e62df5968d2385baf8be", "patch": "@@ -1,3 +1,126 @@\n+1998-07-27  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* cp-tree.h (TI_USES_TEMPLATE_PARMS): Remove.\n+\t(build_template_decl_overload): Remove.\n+\t(set_mangled_name_for_decl): New function.\n+\t(innermost_args): Remove is_spec parameter.\n+\t(most_specialized, most_specialized_class): Remove declarations.\n+\t(lookup_template_class): Add entering_scope parameter.\n+\t(maybe_process_partial_specialization): New function.\n+\t(finish_template_decl): Likewise.\n+\t(finish_template_type): Likewise.  \n+\t* class.c (finish_struct): Clean up processing of member template\n+\tspecializations.\n+\t* decl.c (pushtag): Fix\tformatting.\n+\t(lookup_tag): Improve handling of pseudo-global levels.\n+\t(make_typename_type): Adjust call to lookup_template_class.\n+\t(shadow_tag): Use maybe_process_partial_specialization.\n+\t(xref_tag): Improve handling of member friends.  \n+\t(start_function): Call push_nested_class before\n+\tpush_template_decl.  Don't call push_template_decl for\n+\tspecializations.\n+\t* decl2.c (grok_x_components): Don't call xref_tag for\n+\ttemplate instantiations.  Handle UNION_TYPEs like RECORD_TYPEs.\n+\t(grokclassfn): Use set_mangled_name_for_decl.\n+\t(arg_assoc_class): Adjust call to innermost_args.\n+\t(mark_used): Don't call instantiate_decl for a TEMPLATE_DECL.\n+\t* error.c (dump_function_name): Improve printing of template\n+\tfunction names.\n+\t* friend.c (is_friend): Don't compare types of decls to determine\n+\tfriendship, unless flag_guiding_decls.\n+\t(make_friend_class): Partial specializations cannot be friends.  \n+\t(do_friend): Use set_mangled_name_for_decl.  Call\n+\tpush_template_decl_real instead of push_template_decl.\n+\t* method.c (build_decl_overload_real): Remove prototype.  Give it\n+\texternal linkage.\n+\t(build_overload_identififer): Adjust call to innermost_args.\n+\t(build_template_decl_overload): Remove.\n+\t(set_mangled_name_for_decl): New function.\n+\t* parse.y (.finish_template_type): New non-terminal.\n+\t(template_def): Use finish_template_decl.  Use template_extdef\n+\tinstead of extdef.\n+\t(template_extdef, template_datadef): New non-terminals, containing\n+\tonly those rules for things which can be templates.\n+\t(datadef): Tidy.\n+\t(template_type, self_template_type): Use .finish_template_type.\n+\t(named_class_head): Use maybe_process_partial_specialization.\n+\t* pt.c (mangle_class_name_for_template): Remove context parameter.\n+\t(get_class_bindings): Remove outer_args parameter.\n+\t(complete_template_args): Remove.\n+\t(add_outermost_template_args): New function.\n+\t(register_specialization): Return the specialization.\n+\t(unregister_specialization): New function.\n+\t(tsubst_template_parms): Likewise.\n+\t(most_specialized, most_specialized_class): Prototype here as\n+\tstatic. \n+\t(original_template): Rename to most_general_template.\n+\t(tsubst_template_parms): New function.\n+\t(set_mangled_name_for_template_decl): Likewise.\n+\t(TMPL_ARGS_DEPTH): New macro.\n+\t(TMPL_ARGS_HAVE_MULTIPLE_LEVELS): Adjust.\n+\t(TMPL_ARGS_LEVEL): New macro.\n+\t(SET_TMPL_ARGS_LEVEL): Likewise.\n+\t(TMPL_ARG): Likewise.\n+\t(SET_TMPL_ARG): Likewise.\n+\t(TMPL_ARGS_DEPTH): Likewise.\n+\t(finish_member_template_decl): Use finish_template_decl.\n+\t(maybe_process_partial_specialization): New function, split out\n+\tfrom tsubst.\n+\t(inline_needs_template_parms): Use TMPL_PARMS_DEPTH.\n+\t(maybe_begin_member_template_processing): Use new macros.\n+\t(is_member_template): Likewise.\n+\t(is_member_template_class): Likewise.\n+\t(add_to_template_args): Likewise.  Deal with multiple levels of\n+\targs. \n+\t(maybe_process_partial_specialization): New function.\n+\t(retrieve_specialization): Add consistency check.\n+\t(determine_specialization): Return full argument list.\n+\t(check_explicit_specialization): Tweak friend handling.  Use full\n+\targument lists.  Simplify.\n+\t(current_template_args): Use new macros.\n+\t(push_template_decl_real): Change ill-named mainargs to specargs.\n+\tCheck that a partial specialization actually specializes at least\n+\tone parameter.   Improve friend handling.  Modify for full\n+\ttemplate arguments.\n+\t(classtype_mangled_name): Don't mangle the names of\n+\tspecializations. \n+\t(lookup_template_class): Add entering_scope parameter.  Use it to\n+\tavoid finding a template type when an instantiation is required.\n+\tSimplify.  Use full template arguments.\n+\t(tsubst_friend_function): Use unregister_specialization.  Use new\n+\tmacros.  Use full template arguments.\n+\t(tsubst_friend_class): Substitute, using tsubst_template_parms,\n+\tinto the template parameters before passing them to\n+\tredeclare_class_template.\n+\t(instantiate_class_template): Simplify.  Use full template\n+\targuments.  Adjust calls to get_class_bindings.  Use\n+\tSET_IDENTIFIER_TYPE_VALUE where needed.  Improve friend handling.\n+\t(innermost_args): Use new macros.\n+\t(tsubst_aggr_type): New function, split out from tsubst.\n+\t(tsubst): Use tsubst_aggr_type, tsubst_template_parms, new calling\n+\tconventions for lookup_tmeplate_class.  Refine handling of partial\n+\tinstantiations.   Remove calls to complete_template_args.\n+\tSimplify.  Add consistency checks.  Use set_mangled_name_for_decl\n+\tand set_mangled_name_for_template_decl.\n+\t(tsubst_copy): Use tsubst_aggr_type.\n+\t(instantiate_template): Use full template arguments.\n+\t(more_specialized): Improve formatting.\n+\t(more_specialized_class): Adjust calls to get_class_bindings.\n+\t(get_bindings_real): Don't call complete_template_args.\n+\t(most_specialized): Don't overwrite input; create a new list.\n+\t(most_specialized_class): Use most_general_template.\n+\t(regenerate_decl_from_template): Use unregister_specialization.\n+\tUse full template arguments.  \n+\t(instantiate_decl): Use full template arguments.\n+\t(set_mangled_name_for_template_decl): New function.\n+\t* semantics.c (begin_class_definition): Use\n+\tmaybe_process_partial_specialization.\n+\t(finish_member_class_template): New function.\n+\t(finish_template_decl): Likewise.\n+\t(finish_template_type): Likewise.  \n+\t(typeck.c): Don't crash after issuing a compiler_error.\n+\t* Makefile.in (CONFLICTS): Adjust; we removed a s/r conflict.\n+\t\n 1998-07-27  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* typeck2.c (build_functional_cast): Handle default-initialization."}, {"sha": "085fe3c5c86f2ca291353e2d10179053d1dd38f5", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=36a117a5b33194265633e62df5968d2385baf8be", "patch": "@@ -215,7 +215,7 @@ parse.o : $(PARSE_C) $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h lex.h \\\n \t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(BIG_SWITCHFLAG) \\\n   `echo $(PARSE_C) | sed 's,^\\./,,'`\n \n-CONFLICTS = expect 26 shift/reduce conflicts and 42 reduce/reduce conflicts.\n+CONFLICTS = expect 25 shift/reduce conflicts and 42 reduce/reduce conflicts.\n $(PARSE_H) : $(PARSE_C)\n $(PARSE_C) : $(srcdir)/parse.y\n \t@echo $(CONFLICTS)"}, {"sha": "098f6c3c71794d6e1d37f8a28aa52790aa936cd6", "filename": "gcc/cp/class.c", "status": "modified", "additions": 8, "deletions": 36, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=36a117a5b33194265633e62df5968d2385baf8be", "patch": "@@ -4458,49 +4458,21 @@ finish_struct (t, list_of_fieldlists, attributes, warn_anon)\n   /* Now, figure out which member templates we're specializing.  */\n   for (x = specializations; x != NULL_TREE; x = TREE_CHAIN (x))\n     {\n-      tree spec_args;\n-      tree fn;\n       int pending_specialization;\n \n-      if (uses_template_parms (t))\n-\t/* If t is a template class, and x is a specialization, then x\n-\t   is itself really a template.  Due to the vagaries of the\n-\t   parser, however, we will have a handle to a function\n-\t   declaration, rather than the template declaration, at this\n-\t   point.  */\n-\t{\n-\t  my_friendly_assert (DECL_TEMPLATE_INFO (x) != NULL_TREE, 0);\n-\t  my_friendly_assert (DECL_TI_TEMPLATE (x) != NULL_TREE, 0);\n-\t  fn = DECL_TI_TEMPLATE (x);\n-\t}\n-      else\n-\tfn = x;\n-\n-      /* We want the specialization arguments, which will be the\n-\t innermost ones.  */\n-      if (DECL_TI_ARGS (fn) && TREE_CODE (DECL_TI_ARGS (fn)) == TREE_VEC)\n-\tspec_args \n-\t  = TREE_VEC_ELT (DECL_TI_ARGS (fn), 0);\n-      else\n-\tspec_args = DECL_TI_ARGS (fn);\n-      \n       pending_specialization \n-\t= TI_PENDING_SPECIALIZATION_FLAG (DECL_TEMPLATE_INFO (fn));\n+\t= TI_PENDING_SPECIALIZATION_FLAG (DECL_TEMPLATE_INFO (x));\n       check_explicit_specialization \n-\t(lookup_template_function (DECL_NAME (fn), spec_args),\n-\t fn, 0, 1 | (8 * pending_specialization));\n-      TI_PENDING_SPECIALIZATION_FLAG (DECL_TEMPLATE_INFO (fn)) = 0;\n+\t(lookup_template_function (DECL_NAME (x), DECL_TI_ARGS (x)),\n+\t x, 0, 1 | (8 * pending_specialization));\n+      TI_PENDING_SPECIALIZATION_FLAG (DECL_TEMPLATE_INFO (x)) = 0;\n \n       /* Now, the assembler name will be correct for fn, so we\n \t make its RTL.  */\n-      DECL_RTL (fn) = 0;\n-      make_decl_rtl (fn, NULL_PTR, 1);\n-\n-      if (x != fn)\n-\t{\n-\t  DECL_RTL (x) = 0;\n-\t  make_decl_rtl (x, NULL_PTR, 1);\n-\t}\n+      DECL_RTL (x) = 0;\n+      make_decl_rtl (x, NULL_PTR, 1);\n+      DECL_RTL (DECL_TI_TEMPLATE (x)) = 0;\n+      make_decl_rtl (DECL_TI_TEMPLATE (x), NULL_PTR, 1);\n     }\n \n   if (current_class_type)"}, {"sha": "be97c1b1ca00c98f6173a4e01e1676894d69efb6", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 97, "deletions": 18, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=36a117a5b33194265633e62df5968d2385baf8be", "patch": "@@ -27,7 +27,6 @@ Boston, MA 02111-1307, USA.  */\n /* Usage of TREE_LANG_FLAG_?:\n    0: TREE_NONLOCAL_FLAG (in TREE_LIST or _TYPE).\n       BINFO_MARKED (BINFO nodes).\n-      TI_USES_TEMPLATE_PARMS.\n       COMPOUND_STMT_NO_SCOPE (in COMPOUND_STMT).\n       NEW_EXPR_USE_GLOBAL (in NEW_EXPR).\n       DELETE_EXPR_USE_GLOBAL (in DELETE_EXPR).\n@@ -1250,13 +1249,35 @@ struct lang_decl\n #define TI_TEMPLATE(NODE) (TREE_PURPOSE (NODE))\n #define TI_ARGS(NODE) (TREE_VALUE (NODE))\n #define TI_SPEC_INFO(NODE) (TREE_CHAIN (NODE))\n-#define TI_USES_TEMPLATE_PARMS(NODE) TREE_LANG_FLAG_0 (NODE)\n #define TI_PENDING_TEMPLATE_FLAG(NODE) TREE_LANG_FLAG_1 (NODE)\n /* TI_PENDING_SPECIALIZATION_FLAG on a template-info node indicates\n    that the template is a specialization of a member template, but\n    that we don't yet know which one.  */\n #define TI_PENDING_SPECIALIZATION_FLAG(NODE) TREE_LANG_FLAG_1 (NODE)\n+/* The TEMPLATE_DECL instantiated or specialized by NODE.  This\n+   TEMPLATE_DECL will be the immediate parent, not the most general\n+   template.  For example, in:\n+\n+      template <class T> struct S { template <class U> void f(U); }\n+\n+   the FUNCTION_DECL for S<int>::f<double> will have, as its\n+   DECL_TI_TEMPLATE, `template <class U> S<int>::f<U>'. \n+\n+   As a special case, for a member friend template of a template\n+   class, this value will not be a TEMPLATE_DECL, but rather a\n+   LOOKUP_EXPR indicating the name of the template and any explicit\n+   template arguments provided.  For example, in:\n+\n+     template <class T> struct S { friend void f<int>(int, double); }\n+\n+   the DECL_TI_TEMPLATE will be a LOOKUP_EXPR for `f' and the\n+   DECL_TI_ARGS will be {int}.  */ \n #define DECL_TI_TEMPLATE(NODE)      TI_TEMPLATE (DECL_TEMPLATE_INFO (NODE))\n+/* The template arguments used to obtain this decl from the most\n+   general form of DECL_TI_TEMPLATE.  For the example given for\n+   DECL_TI_TEMPLATE, the DECL_TI_ARGS will be {int, double}.  These\n+   are always the full set of arguments required to instantiate this\n+   declaration from the most general template specialized here.  */\n #define DECL_TI_ARGS(NODE)          TI_ARGS (DECL_TEMPLATE_INFO (NODE))\n #define CLASSTYPE_TI_TEMPLATE(NODE) TI_TEMPLATE (CLASSTYPE_TEMPLATE_INFO (NODE))\n #define CLASSTYPE_TI_ARGS(NODE)     TI_ARGS (CLASSTYPE_TEMPLATE_INFO (NODE))\n@@ -1528,25 +1549,80 @@ extern int flag_new_for_scope;\n /* Accessor macros for C++ template decl nodes.  */\n \n /* The DECL_TEMPLATE_PARMS are a list.  The TREE_PURPOSE of each node\n-   indicates the level of the template parameters, with 1 being the\n-   outermost set of template parameters.  The TREE_VALUE is a vector,\n-   whose elements are the template parameters at each level.  Each\n-   element in the vector is a TREE_LIST, whose TREE_VALUE is a\n-   PARM_DECL (if the parameter is a non-type parameter), or a\n-   TYPE_DECL (if the parameter is a type parameter).  The TREE_PURPOSE\n-   is the default value, if any.  The TEMPLATE_PARM_INDEX for the\n-   parameter is avilable as the DECL_INITIAL (for a PARM_DECL) or as\n-   the TREE_TYPE (for a TYPE_DECL).  */\n+   is a INT_CST whose TREE_INT_CST_HIGH indicates the level of the\n+   template parameters, with 1 being the outermost set of template\n+   parameters.  The TREE_VALUE is a vector, whose elements are the\n+   template parameters at each level.  Each element in the vector is a\n+   TREE_LIST, whose TREE_VALUE is a PARM_DECL (if the parameter is a\n+   non-type parameter), or a TYPE_DECL (if the parameter is a type\n+   parameter).  The TREE_PURPOSE is the default value, if any.  The\n+   TEMPLATE_PARM_INDEX for the parameter is avilable as the\n+   DECL_INITIAL (for a PARM_DECL) or as the TREE_TYPE (for a\n+   TYPE_DECL).  */\n #define DECL_TEMPLATE_PARMS(NODE)       DECL_ARGUMENTS(NODE)\n #define DECL_INNERMOST_TEMPLATE_PARMS(NODE) \\\n    INNERMOST_TEMPLATE_PARMS (DECL_TEMPLATE_PARMS (NODE))\n #define DECL_NTPARMS(NODE) \\\n    TREE_VEC_LENGTH (DECL_INNERMOST_TEMPLATE_PARMS (NODE))\n-/* For class templates.  */\n-#define DECL_TEMPLATE_SPECIALIZATIONS(NODE)     DECL_SIZE(NODE)\n /* For function, method, class-data templates.  */\n #define DECL_TEMPLATE_RESULT(NODE)      DECL_RESULT(NODE)\n+/* For a static member variable template, the\n+   DECL_TEMPLATE_INSTANTIATIONS list contains the explicitly and\n+   implicitly generated instantiations of the variable.  There are no\n+   partial instantiations of static member variables, so all of these\n+   will be full instantiations.\n+\n+   For a class template the DECL_TEMPLATE_INSTANTIATIONS lists holds\n+   all instantiations and specializations of the class type, including\n+   partial instantiations and partial specializations.\n+\n+   In both cases, the TREE_PURPOSE of each node contains the arguments\n+   used; the TREE_VALUE contains the generated variable.  The template\n+   arguments are always complete.  For example, given:\n+\n+      template <class T> struct S1 {\n+        template <class U> struct S2 {};\n+\ttemplate <class U> struct S2<U*> {};\n+      };\n+\n+   the record for the partial specialization will contain, as its\n+   argument list, { {T}, {U*} }, and will be on the\n+   DECL_TEMPLATE_INSTANTIATIONS list for `template <class T> template\n+   <class U> struct S1<T>::S2'.\n+\n+   This list is not used for function templates.  */\n #define DECL_TEMPLATE_INSTANTIATIONS(NODE) DECL_VINDEX(NODE)\n+/* For a function template, the DECL_TEMPLATE_SPECIALIZATIONS lists\n+   contains all instantiations and specializations of the function,\n+   including partial instantiations.  For a partial instantiation\n+   which is a specialization, this list holds only full\n+   specializations of the template that are instantiations of the\n+   partial instantiation.  For example, given:\n+\n+      template <class T> struct S {\n+        template <class U> void f(U);\n+\ttemplate <> void f(T); \n+      };\n+\n+   the `S<int>::f<int>(int)' function will appear on the\n+   DECL_TEMPLATE_SPECIALIZATIONS list for both `template <class T>\n+   template <class U> void S<T>::f(U)' and `template <class T> void\n+   S<int>::f(T)'.  In the latter case, however, it will have only the\n+   innermost set of arguments (T, in this case).  The DECL_TI_TEMPLATE\n+   for the function declaration will point at the specialization, not\n+   the fully general template.\n+\n+   For a class template, this list contains the partial\n+   specializations of this template.  (Full specializations are not\n+   recorded on this list.)  The TREE_PURPOSE holds the innermost\n+   arguments used in the partial specialization (e.g., for `template\n+   <class T> struct S<T*, int>' this will be `T*'.)  The TREE_VALUE\n+   holds the innermost template parameters for the specialization\n+   (e.g., `T' in the example above.)  The TREE_TYPE is the _TYPE node\n+   for the partial specialization.\n+\n+   This list is not used for static variable templates.  */\n+#define DECL_TEMPLATE_SPECIALIZATIONS(NODE)     DECL_SIZE(NODE)\n #define DECL_TEMPLATE_INJECT(NODE)\tDECL_INITIAL(NODE)\n \n /* Nonzero for TEMPLATE_DECL nodes that represents template template\n@@ -2649,7 +2725,9 @@ extern void do_inline_function_hair\t\tPROTO((tree, tree));\n extern char *build_overload_name\t\tPROTO((tree, int, int));\n extern tree build_static_name\t\t\tPROTO((tree, tree));\n extern tree build_decl_overload\t\t\tPROTO((tree, tree, int));\n-extern tree build_template_decl_overload        PROTO((tree, tree, tree, tree, tree, int));\n+extern tree build_decl_overload_real            PROTO((tree, tree, tree, tree,\n+\t\t\t\t\t\t       tree, int)); \n+extern tree set_mangled_name_for_decl           PROTO((tree));\n extern tree build_typename_overload\t\tPROTO((tree));\n extern tree build_overload_with_type\t\tPROTO((tree, tree));\n extern tree build_destructor_name\t\tPROTO((tree));\n@@ -2661,7 +2739,7 @@ extern void synthesize_method\t\t\tPROTO((tree));\n extern tree get_id_2\t\t\t\tPROTO((char *, tree));\n \n /* in pt.c */\n-extern tree innermost_args\t\t\tPROTO ((tree, int));\n+extern tree innermost_args\t\t\tPROTO ((tree));\n extern tree tsubst\t\t\t\tPROTO ((tree, tree, tree));\n extern tree tsubst_expr\t\t\t\tPROTO ((tree, tree, tree));\n extern tree tsubst_copy\t\t\t\tPROTO ((tree, tree, tree));\n@@ -2684,7 +2762,7 @@ extern tree current_template_args\t\tPROTO((void));\n extern tree push_template_decl\t\t\tPROTO((tree));\n extern tree push_template_decl_real             PROTO((tree, int));\n extern void redeclare_class_template            PROTO((tree, tree));\n-extern tree lookup_template_class\t\tPROTO((tree, tree, tree, tree));\n+extern tree lookup_template_class\t\tPROTO((tree, tree, tree, tree, int));\n extern tree lookup_template_function            PROTO((tree, tree));\n extern int uses_template_parms\t\t\tPROTO((tree));\n extern tree instantiate_class_template\t\tPROTO((tree));\n@@ -2708,15 +2786,14 @@ extern void begin_tree                          PROTO((void));\n extern void end_tree                            PROTO((void));\n extern void add_maybe_template\t\t\tPROTO((tree, tree));\n extern void pop_tinst_level\t\t\tPROTO((void));\n-extern tree most_specialized\t\t\tPROTO((tree, tree, tree));\n-extern tree most_specialized_class\t\tPROTO((tree, tree, tree));\n extern int more_specialized_class\t\tPROTO((tree, tree));\n extern void do_pushlevel\t\t\tPROTO((void));\n extern int is_member_template                   PROTO((tree));\n extern int comp_template_parms                  PROTO((tree, tree));\n extern int template_class_depth                 PROTO((tree));\n extern int is_specialization_of                 PROTO((tree, tree));\n extern int comp_template_args                   PROTO((tree, tree));\n+extern void maybe_process_partial_specialization PROTO((tree));\n \n extern int processing_specialization;\n extern int processing_explicit_instantiation;\n@@ -2839,6 +2916,8 @@ extern tree finish_class_definition             PROTO((tree, tree, tree, int));\n extern void finish_default_args                 PROTO((void));\n extern void begin_inline_definitions            PROTO((void));\n extern tree finish_member_class_template        PROTO((tree, tree));\n+extern void finish_template_decl                PROTO((tree));\n+extern tree finish_template_type                PROTO((tree, tree, int));\n \n /* in sig.c */\n extern tree build_signature_pointer_type\tPROTO((tree, int, int));"}, {"sha": "aa5204ec84461ad2bd1aa70a40b7e617f4c5c5ae", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 121, "deletions": 64, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=36a117a5b33194265633e62df5968d2385baf8be", "patch": "@@ -2339,8 +2339,8 @@ pushtag (name, type, globalize)\n \t\t class scope.  In the friend case, push_template_decl\n \t\t will already have put the friend into global scope,\n \t\t if appropriate.  */ \n-\t      if (!globalize && b->pseudo_global &&\n-\t\t  b->level_chain->parm_flag == 2)\n+\t      if (!globalize && b->pseudo_global\n+\t\t  && b->level_chain->parm_flag == 2)\n \t\t{\n \t\t  pushdecl_with_scope (CLASSTYPE_TI_TEMPLATE (type),\n \t\t\t\t       b->level_chain);\n@@ -4455,6 +4455,9 @@ lookup_tag (form, name, binding_level, thislevel_only)\n      int thislevel_only;\n {\n   register struct binding_level *level;\n+  /* Non-zero if, we should look past a pseudo-global level, even if\n+     THISLEVEL_ONLY.  */\n+  int allow_pseudo_global = 1;\n \n   for (level = binding_level; level; level = level->level_chain)\n     {\n@@ -4472,7 +4475,19 @@ lookup_tag (form, name, binding_level, thislevel_only)\n \t/* XXX: is this a real lookup, considering using-directives etc. ??? */\n \tfor (tail = current_namespace; 1; tail = CP_DECL_CONTEXT (tail))\n \t  {\n-\t    tree old = BINDING_TYPE (binding_for_name (name, tail));\n+\t    tree old = binding_for_name (name, tail);\n+\n+\t    /* If we just skipped past a pseudo global level, even\n+\t       though THISLEVEL_ONLY, and we find a template class\n+\t       declaration, then we use the _TYPE node for the\n+\t       template.  See the example below.  */\n+\t    if (thislevel_only && !allow_pseudo_global\n+\t\t&& old && BINDING_VALUE (old) \n+\t\t&& DECL_CLASS_TEMPLATE_P (BINDING_VALUE (old)))\n+\t      old = TREE_TYPE (BINDING_VALUE (old));\n+\t    else \n+\t      old = BINDING_TYPE (old);\n+\n \t    /* If it has an original type, it is a typedef, and we\n \t       should not return it.  */\n \t    if (old && DECL_ORIGINAL_TYPE (TYPE_NAME (old)))\n@@ -4509,16 +4524,24 @@ lookup_tag (form, name, binding_level, thislevel_only)\n \t  }\n       if (thislevel_only && ! level->tag_transparent)\n \t{\n-\t  if (level->pseudo_global)\n-\t    {\n-\t      tree t = IDENTIFIER_CLASS_VALUE (name);\n-\t      if (t && DECL_CLASS_TEMPLATE_P (t))\n-\t\treturn TREE_TYPE (t);\n-\t      t = IDENTIFIER_NAMESPACE_VALUE (name);\n-\t      if (t && DECL_CLASS_TEMPLATE_P (t))\n-\t\treturn TREE_TYPE (t);\n+\t  if (level->pseudo_global && allow_pseudo_global)\n+\t    {\n+\t      /* We must deal with cases like this:\n+\t\t \n+\t           template <class T> struct S;\n+\t\t   template <class T> struct S {};\n+\t\t   \n+\t\t When looking up `S', for the second declaration, we\n+\t\t would like to find the first declaration.  But, we\n+\t\t are in the pseudo-global level created for the\n+\t\t template parameters, rather than the (surrounding)\n+\t\t namespace level.  Thus, we keep going one more level,\n+\t\t even though THISLEVEL_ONLY is non-zero.  */\n+\t      allow_pseudo_global = 0;\n+\t      continue;\n \t    }\n-\t  return NULL_TREE;\n+\t  else\n+\t    return NULL_TREE;\n \t}\n       if (current_class_type && level->level_chain->namespace_p)\n \t{\n@@ -4730,7 +4753,8 @@ make_typename_type (context, name)\n \t    }\n \n \t  return lookup_template_class (t, TREE_OPERAND (fullname, 1),\n-\t\t\t\t\tNULL_TREE, context);\n+\t\t\t\t\tNULL_TREE, context, \n+\t\t\t\t\t/*entering_scope=*/0);\n \t}\n       else\n \t{\n@@ -6207,18 +6231,7 @@ shadow_tag (declspecs)\n \t{\n \t  my_friendly_assert (TYPE_MAIN_DECL (value) != NULL_TREE, 261);\n \n-\t  if (IS_AGGR_TYPE (value) && CLASSTYPE_USE_TEMPLATE (value))\n-\t    {\n-\t      if (CLASSTYPE_IMPLICIT_INSTANTIATION (value)\n-\t\t  && TYPE_SIZE (value) == NULL_TREE)\n-\t\t{\n-\t\t  SET_CLASSTYPE_TEMPLATE_SPECIALIZATION (value);\n-\t\t  if (processing_template_decl)\n-\t\t    push_template_decl (TYPE_MAIN_DECL (value));\n-\t\t}\n-\t      else if (CLASSTYPE_TEMPLATE_INSTANTIATION (value))\n-\t\tcp_error (\"specialization after instantiation of `%T'\", value);\n-\t    }\n+\t  maybe_process_partial_specialization (value);\n \n \t  t = value;\n \t  ok_code = code;\n@@ -10241,9 +10254,16 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t      {\n \t\ttree t = NULL_TREE;\n \t\tif (decl && DECL_NAME (decl))\n-\t\t  t = do_friend (ctype, declarator, decl,\n-\t\t\t\t last_function_parms, flags, quals,\n-\t\t\t\t funcdef_flag);\n+\t\t  {\n+\t\t    if (template_class_depth (current_class_type) == 0)\n+\t\t      decl \n+\t\t\t= check_explicit_specialization \n+\t\t\t(declarator, decl,\n+\t\t\t template_count, 2 * (funcdef_flag != 0) + 4);\n+\t\t    t = do_friend (ctype, declarator, decl,\n+\t\t\t\t   last_function_parms, flags, quals,\n+\t\t\t\t   funcdef_flag);\n+\t\t  }\n \t\tif (t && funcdef_flag)\n \t\t  return t;\n \t\t\n@@ -11321,37 +11341,66 @@ xref_tag (code_type_node, name, binfo, globalize)\n       if (t && TYPE_CONTEXT (t) && got_type)\n \tref = t;\n       else\n-\t{\n-\t  /* If we know we are defining this tag, only look it up in\n-\t     this scope and don't try to find it as a type.  */\n-\t  ref = lookup_tag (code, name, b, 1);\n-\t}\n+\t/* If we know we are defining this tag, only look it up in\n+\t   this scope and don't try to find it as a type.  */\n+\tref = lookup_tag (code, name, b, 1);\n     }\n   else\n     {\n-      if (t)\n-\tref = t;\n-      else\n-        ref = lookup_tag (code, name, b, 0);\n-\n-      if (! ref)\n-\t{\n-\t  /* Try finding it as a type declaration.  If that wins, use it.  */\n-\t  ref = lookup_name (name, 1);\n+      if (current_class_type \n+\t  && template_class_depth (current_class_type) \n+\t  && (processing_template_decl \n+\t      > template_class_depth (current_class_type)))\n+      /* Since GLOBALIZE is non-zero, we are not looking at a\n+\t definition of this tag.  Since, in addition, we are currently\n+\t processing a (member) template declaration of a template\n+\t class, we don't want to do any lookup at all; consider:\n+\n+\t   template <class X>\n+\t   struct S1\n+\n+\t   template <class U>\n+\t   struct S2\n+\t   { template <class V>\n+\t     friend struct S1; };\n+\t   \n+\t Here, the S2::S1 declaration should not be confused with the\n+\t outer declaration.  In particular, the inner version should\n+\t have a template parameter of level 2, not level 1.  This\n+\t would be particularly important if the member declaration\n+\t were instead:\n+\n+\t   template <class V = U> friend struct S1;\n+\n+\t say, when we should tsubst into `U' when instantiating S2.  */\n+\tref = NULL_TREE;\n+      else \n+\t{\n+\t  if (t)\n+\t    ref = t;\n+\t  else\n+\t    ref = lookup_tag (code, name, b, 0);\n+\t  \n+\t  if (! ref)\n+\t    {\n+\t      /* Try finding it as a type declaration.  If that wins,\n+\t\t use it.  */ \n+\t      ref = lookup_name (name, 1);\n \n-\t  if (ref != NULL_TREE\n-\t      && processing_template_decl\n-\t      && DECL_CLASS_TEMPLATE_P (ref)\n-\t      && template_class_depth (current_class_type) == 0)\n-\t    /* Since GLOBALIZE is true, we're declaring a global\n+\t      if (ref != NULL_TREE\n+\t\t  && processing_template_decl\n+\t\t  && DECL_CLASS_TEMPLATE_P (ref)\n+\t\t  && template_class_depth (current_class_type) == 0)\n+\t\t/* Since GLOBALIZE is true, we're declaring a global\n \t       template, so we want this type.  */\n-\t    ref = DECL_RESULT (ref);\n+\t\tref = DECL_RESULT (ref);\n \n-\t  if (ref && TREE_CODE (ref) == TYPE_DECL\n-\t      && TREE_CODE (TREE_TYPE (ref)) == code)\n-\t    ref = TREE_TYPE (ref);\n-\t  else\n-\t    ref = NULL_TREE;\n+\t      if (ref && TREE_CODE (ref) == TYPE_DECL\n+\t\t  && TREE_CODE (TREE_TYPE (ref)) == code)\n+\t\tref = TREE_TYPE (ref);\n+\t      else\n+\t\tref = NULL_TREE;\n+\t    }\n \t}\n     }\n \n@@ -12121,13 +12170,24 @@ start_function (declspecs, declarator, attrs, pre_parsed_p)\n      (This does not mean `static' in the C sense!)  */\n   TREE_STATIC (decl1) = 1;\n \n+  /* Set up current_class_type, and enter the scope of the class, if\n+     appropriate.  */\n+  if (ctype)\n+    push_nested_class (ctype, 1);\n+  else if (DECL_STATIC_FUNCTION_P (decl1))\n+    push_nested_class (DECL_CONTEXT (decl1), 2);\n+\n+  /* We must call push_template_decl after current_class_type is set\n+     up.  (If we are processing inline definitions after exiting a\n+     class scope, current_class_type will be NULL_TREE until set above\n+     by push_nested_class.)  */\n+  if (processing_template_decl)\n+    decl1 = push_template_decl (decl1);\n+\n   /* Record the decl so that the function name is defined.\n      If we already have a decl for this name, and it is a FUNCTION_DECL,\n      use the old decl.  */\n-\n-  if (processing_template_decl)\n-    decl1 = push_template_decl (decl1);\n-  else if (pre_parsed_p == 0)\n+  if (!processing_template_decl && pre_parsed_p == 0)\n     {\n       /* A specialization is not used to guide overload resolution.  */\n       if ((flag_guiding_decls \n@@ -12207,8 +12267,6 @@ start_function (declspecs, declarator, attrs, pre_parsed_p)\n \n   if (ctype)\n     {\n-      push_nested_class (ctype, 1);\n-\n       /* If we're compiling a friend function, neither of the variables\n \t current_class_ptr nor current_class_type will have values.  */\n       if (! doing_friend)\n@@ -12241,10 +12299,8 @@ start_function (declspecs, declarator, attrs, pre_parsed_p)\n     }\n   else\n     {\n-      if (DECL_STATIC_FUNCTION_P (decl1))\n-\tpush_nested_class (DECL_CONTEXT (decl1), 2);\n-      else\n-\tpush_memoized_context (0, 1);\n+      if (!DECL_STATIC_FUNCTION_P (decl1))\n+\tpush_memoized_context (NULL_TREE, 1);\n       current_class_ptr = current_class_ref = NULL_TREE;\n     }\n \n@@ -13185,7 +13241,8 @@ start_method (declspecs, declarator)\n   if (flag_default_inline)\n     DECL_INLINE (fndecl) = 1;\n \n-  if (processing_template_decl)\n+  /* We process method specializations in finish_struct_1.  */\n+  if (processing_template_decl && !DECL_TEMPLATE_SPECIALIZATION (fndecl))\n     fndecl = push_template_decl (fndecl);\n \n   /* We read in the parameters on the maybepermanent_obstack,"}, {"sha": "3aa5d73593b9a3fd6fa293887b4d3b22525b40d8", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=36a117a5b33194265633e62df5968d2385baf8be", "patch": "@@ -912,34 +912,29 @@ grok_x_components (specs, components)\n \t  break;\n \n \tcase RECORD_TYPE:\n-\t  /* This code may be needed for UNION_TYPEs as\n-\t     well.  */\n-\t  tcode = record_type_node;\n+\tcase UNION_TYPE:\n+\t  if (TREE_CODE (t) == UNION_TYPE)\n+\t    tcode = union_type_node;\n+\t  else\n+\t    tcode = record_type_node;\n \t  if (CLASSTYPE_DECLARED_CLASS (t))\n \t    tcode = class_type_node;\n \t  else if (IS_SIGNATURE (t))\n \t    tcode = signature_type_node;\n-\n-\t  if (CLASSTYPE_IS_TEMPLATE (t))\n-\t    /* In this case, the TYPE_IDENTIFIER will be something\n-\t       like S<T>, rather than S, so to get the correct name we\n-\t       look at the template.  */\n-\t    x = DECL_NAME (CLASSTYPE_TI_TEMPLATE (t));\n-\t  else\n-\t    x = TYPE_IDENTIFIER (t);\n-\n-\t  t = xref_tag (tcode, x, NULL_TREE, 0);\n-\t  return NULL_TREE;\n-\t  break;\n-\n-\tcase UNION_TYPE:\n-\tcase ENUMERAL_TYPE:\n-\t  if (TREE_CODE (t) == UNION_TYPE)\n-\t    tcode = union_type_node;\n+\t  \n+\t  if (TYPE_LANG_SPECIFIC (t) \n+\t      && CLASSTYPE_USE_TEMPLATE (t))\n+\t    /* We have already looked up this type.  */\n+\t    ;\n \t  else\n-\t    tcode = enum_type_node;\n+\t    {\n+\t      if (CLASSTYPE_IS_TEMPLATE (t))\n+\t\tx = DECL_NAME (CLASSTYPE_TI_TEMPLATE (t));\n+\t      else\n+\t\tx = TYPE_IDENTIFIER (t);\n+\t      t = xref_tag (tcode, x, NULL_TREE, 0);\n+\t    }\n \n-\t  t = xref_tag (tcode, TYPE_IDENTIFIER (t), NULL_TREE, 0);\n \t  if (ANON_UNION_TYPE_P (t))\n \t    {\n \t      /* See also shadow_tag.  */\n@@ -972,11 +967,17 @@ grok_x_components (specs, components)\n \t      for (; *p; *p = (*p)->next)\n \t\tif (DECL_CONTEXT ((*p)->fndecl) != t)\n \t\t  break;\n+\n+\t      return x;\n \t    }\n-\t  else if (TREE_CODE (t) == ENUMERAL_TYPE)\n-\t    x = grok_enum_decls (NULL_TREE);\n-\t  else\n-\t    x = NULL_TREE;\n+\n+\t  return NULL_TREE;\n+\t  break;\n+\n+\tcase ENUMERAL_TYPE:\n+\t  tcode = enum_type_node;\n+\t  t = xref_tag (tcode, TYPE_IDENTIFIER (t), NULL_TREE, 0);\n+\t  x = grok_enum_decls (NULL_TREE);\n \t  return x;\n \t  break;\n \n@@ -1132,16 +1133,7 @@ grokclassfn (ctype, cname, function, flags, quals)\n       TYPE_HAS_DESTRUCTOR (ctype) = 1;\n     }\n   else\n-    {\n-      if (TREE_CODE (TREE_TYPE (function)) == FUNCTION_TYPE)\n-\t/* Only true for static member functions.  */\n-\targ_types = hash_tree_chain (build_pointer_type (qualtype),\n-\t\t\t\t     arg_types);\n-\n-      DECL_ASSEMBLER_NAME (function)\n-\t= build_decl_overload (fn_name, arg_types,\n-\t\t\t       1 + DECL_CONSTRUCTOR_P (function));\n-    }\n+    set_mangled_name_for_decl (function);\n }\n \n /* Work on the expr used by alignof (this is only called by the parser).  */\n@@ -4299,7 +4291,7 @@ arg_assoc_class (k, type)\n   /* Process template arguments.  */\n   if (CLASSTYPE_TEMPLATE_INFO (type))\n     {\n-      list = innermost_args (CLASSTYPE_TI_ARGS (type), 0);\n+      list = innermost_args (CLASSTYPE_TI_ARGS (type));\n       for (i = 0; i < TREE_VEC_LENGTH (list); ++i)\n \targ_assoc (k, TREE_VEC_ELT (list, i));\n     }\n@@ -4690,13 +4682,21 @@ mark_used (decl)\n   if (processing_template_decl)\n     return;\n   assemble_external (decl);\n+\n   /* Is it a synthesized method that needs to be synthesized?  */\n   if (TREE_CODE (decl) == FUNCTION_DECL && DECL_CLASS_CONTEXT (decl)\n       && DECL_ARTIFICIAL (decl) && ! DECL_INITIAL (decl)\n       /* Kludge: don't synthesize for default args.  */\n       && current_function_decl)\n     synthesize_method (decl);\n-  if (DECL_LANG_SPECIFIC (decl) && DECL_TEMPLATE_INFO (decl))\n+\n+  /* If this is a function or variable that is an instance of some\n+     template, we now know that we will need to actually do the\n+     instantiation.  A TEMPLATE_DECL may also have DECL_TEMPLATE_INFO,\n+     if it's a partial instantiation, but there's no need to\n+     instantiate such a thing.  */\n+  if (TREE_CODE (decl) != TEMPLATE_DECL\n+      && DECL_LANG_SPECIFIC (decl) && DECL_TEMPLATE_INFO (decl))\n     instantiate_decl (decl);\n }\n "}, {"sha": "bd459c2a6f82d19bebb1f5a0653e44f4d233974a", "filename": "gcc/cp/error.c", "status": "modified", "additions": 54, "deletions": 70, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=36a117a5b33194265633e62df5968d2385baf8be", "patch": "@@ -1042,91 +1042,75 @@ dump_function_name (t)\n   else\n     dump_decl (name, 0);\n \n-  if (DECL_LANG_SPECIFIC (t) && DECL_USE_TEMPLATE (t))\n+  if (DECL_LANG_SPECIFIC (t) && DECL_USE_TEMPLATE (t) \n+      && DECL_TEMPLATE_INFO (t)\n+      && (DECL_TEMPLATE_SPECIALIZATION (t) \n+\t  || TREE_CODE (DECL_TI_TEMPLATE (t)) != TEMPLATE_DECL\n+\t  || DECL_TEMPLATE_SPECIALIZATION (DECL_TI_TEMPLATE (t))\n+\t  || PRIMARY_TEMPLATE_P (DECL_TI_TEMPLATE (t))))\n     {\n       tree args = DECL_TEMPLATE_INFO (t) ? DECL_TI_ARGS (t) : NULL_TREE; \n+      OB_PUTC ('<');\n \n-      if (args != NULL_TREE\n-\t  && DECL_CONTEXT (t) != NULL_TREE\n-\t  && uses_template_parms (DECL_CONTEXT (t))\n-\t  /* This next clause checks that there is only one level of\n-\t     template arguments.  In that case, they are the\n-\t     arguments for the class context.  */\n-\t  && (TREE_CODE (args) == TREE_LIST\n-\t      || (TREE_CODE (args) == TREE_VEC \n-\t\t  && TREE_VEC_ELT (args, 0) != NULL_TREE\n-\t\t  && TREE_CODE (TREE_VEC_ELT (args, 0)) != TREE_VEC)))\n-\t/* We have something like this:\n-\t   \n-\t   template <class T> struct S { void f(); };\n-\t   \n-\t   and we are printing S<int>::f().  This is a template\n-\t   instantiation, but we don't print anything after the f.  */\n-\t;\n-      else\n+      /* Be careful only to print things when we have them, so as not\n+\t to crash producing error messages.  */\n+      if (args)\n \t{\n-\t  OB_PUTC ('<');\n-\n-\t  /* Be careful only to print things when we have them, so as not\n-\t     to crash producing error messages.  */\n-\t  if (args)\n+\t  if (TREE_CODE (args) == TREE_LIST)\n \t    {\n-\t      if (TREE_CODE (args) == TREE_LIST)\n+\t      tree arg;\n+\t      int need_comma = 0;\n+\t      \n+\t      for (arg = args; arg; arg = TREE_CHAIN (arg))\n \t\t{\n-\t\t  tree arg;\n-\t\t  int need_comma = 0;\n-\n-\t\t  for (arg = args; arg; arg = TREE_CHAIN (arg))\n-\t\t    {\n-\t\t      tree a = TREE_VALUE (arg);\n-\n-\t\t      if (need_comma)\n-\t\t\tOB_PUTS (\", \");\n-\n-\t\t      if (a)\n-\t\t\t{\n-\t\t\t  if (TREE_CODE_CLASS (TREE_CODE (a)) == 't'\n-\t\t\t      || TREE_CODE (a) == TEMPLATE_DECL)\n-\t\t\t    dump_type (a, 0);\n-\t\t\t  else\n-\t\t\t    dump_expr (a, 0);\n-\t\t\t}\n+\t\t  tree a = TREE_VALUE (arg);\n+\t\t  \n+\t\t  if (need_comma)\n+\t\t    OB_PUTS (\", \");\n \t\t  \n-\t\t      need_comma = 1;\n+\t\t  if (a)\n+\t\t    {\n+\t\t      if (TREE_CODE_CLASS (TREE_CODE (a)) == 't'\n+\t\t\t  || TREE_CODE (a) == TEMPLATE_DECL)\n+\t\t\tdump_type (a, 0);\n+\t\t      else\n+\t\t\tdump_expr (a, 0);\n \t\t    }\n+\t\t  \n+\t\t  need_comma = 1;\n \t\t}\n-\t      else if (TREE_CODE (args) == TREE_VEC)\n+\t    }\n+\t  else if (TREE_CODE (args) == TREE_VEC)\n+\t    {\n+\t      int i;\n+\t      int need_comma = 0;\n+\t      \n+\t      if (TREE_VEC_LENGTH (args) > 0\n+\t\t  && TREE_CODE (TREE_VEC_ELT (args, 0)) == TREE_VEC)\n+\t\targs = TREE_VEC_ELT (args, \n+\t\t\t\t     TREE_VEC_LENGTH (args) - 1);\n+\t      \n+\t      for (i = 0; i < TREE_VEC_LENGTH (args); i++)\n \t\t{\n-\t\t  int i;\n-\t\t  int need_comma = 0;\n-\n-\t\t  if (TREE_VEC_LENGTH (args) > 0\n-\t\t      && TREE_CODE (TREE_VEC_ELT (args, 0)) == TREE_VEC)\n-\t\t    args = TREE_VEC_ELT (args, \n-\t\t\t\t\t TREE_VEC_LENGTH (args) - 1);\n-\n-\t\t  for (i = 0; i < TREE_VEC_LENGTH (args); i++)\n-\t\t    {\n-\t\t      tree a = TREE_VEC_ELT (args, i);\n-\n-\t\t      if (need_comma)\n-\t\t\tOB_PUTS (\", \");\n-\n-\t\t      if (a)\n-\t\t\t{\n-\t\t\t  if (TREE_CODE_CLASS (TREE_CODE (a)) == 't'\n-\t\t\t      || TREE_CODE (a) == TEMPLATE_DECL)\n-\t\t\t    dump_type (a, 0);\n-\t\t\t  else\n-\t\t\t    dump_expr (a, 0);\n-\t\t\t}\n+\t\t  tree a = TREE_VEC_ELT (args, i);\n+\t\t  \n+\t\t  if (need_comma)\n+\t\t    OB_PUTS (\", \");\n \t\t  \n-\t\t      need_comma = 1;\n+\t\t  if (a)\n+\t\t    {\n+\t\t      if (TREE_CODE_CLASS (TREE_CODE (a)) == 't'\n+\t\t\t  || TREE_CODE (a) == TEMPLATE_DECL)\n+\t\t\tdump_type (a, 0);\n+\t\t      else\n+\t\t\tdump_expr (a, 0);\n \t\t    }\n+\t\t  \n+\t\t  need_comma = 1;\n \t\t}\n \t    }\n-\t  OB_PUTC ('>');\n \t}\n+      OB_PUTC ('>');\n     }\n }\n "}, {"sha": "4bd0b08ecff7e4e0c8d6cf3062d57fb81daf495b", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 42, "deletions": 31, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=36a117a5b33194265633e62df5968d2385baf8be", "patch": "@@ -70,21 +70,22 @@ is_friend (type, supplicant)\n \t\t  if (TREE_VALUE (friends) == NULL_TREE)\n \t\t    continue;\n \n-\t\t  if (TREE_CODE (TREE_VALUE (friends)) == TEMPLATE_DECL)\n-\t\t    {\n-\t\t      if (is_specialization_of (supplicant, \n-\t\t\t\t\t\tTREE_VALUE (friends)))\n-\t\t\treturn 1;\n-\n-\t\t      continue;\n-\t\t    }\n-\n-\t\t  /* FIXME: The use of comptypes here is bogus, since\n-\t\t     two specializations of a template with non-type\n-\t\t     parameters may have the same type, but be\n-\t\t     different.  */\n-\t\t  if (comptypes (TREE_TYPE (supplicant),\n-\t\t\t\t TREE_TYPE (TREE_VALUE (friends)), 1))\n+\t\t  if (supplicant == TREE_VALUE (friends))\n+\t\t    return 1;\n+\n+\t\t  /* With -fguiding-decls we are more lenient about\n+\t\t     friendship.  This is bogus in general since two\n+\t\t     specializations of a template with non-type\n+\t\t     template parameters may have the same type, but\n+\t\t     be different.  */\n+\t\t  if (flag_guiding_decls \n+\t\t      && comptypes (TREE_TYPE (supplicant),\n+\t\t\t\t    TREE_TYPE (TREE_VALUE (friends)), 1))\n+\t\t    return 1;\n+\n+\t\t  if (TREE_CODE (TREE_VALUE (friends)) == TEMPLATE_DECL\n+\t\t      && is_specialization_of (supplicant, \n+\t\t\t\t\t       TREE_VALUE (friends)))\n \t\t    return 1;\n \t\t}\n \t      break;\n@@ -253,6 +254,21 @@ make_friend_class (type, friend_type)\n \t     IDENTIFIER_POINTER (TYPE_IDENTIFIER (friend_type)));\n       return;\n     }\n+\n+  if (CLASSTYPE_TEMPLATE_SPECIALIZATION (friend_type)) \n+    {\n+      /* [temp.friend]\n+\t \n+\t Friend declarations shall not declare partial\n+\t specializations.  \n+\n+         Note that CLASSTYPE_TEMPLATE_SPECIALIZATION is not set for\n+\t full specializations.  */ \n+      cp_error (\"partial specialization `%T' declared `friend'\",\n+\t\tfriend_type);\n+      return;\n+    }\n+\n   if (processing_template_decl > template_class_depth (type))\n     /* If the TYPE is a template then it makes sense for it to be\n        friends with itself; this means that each instantiation is\n@@ -407,30 +423,25 @@ do_friend (ctype, declarator, decl, parmdecls, flags, quals, funcdef_flag)\n \n \t Note that because classes all wind up being top-level\n \t in their scope, their friend wind up in top-level scope as well.  */\n-      DECL_ASSEMBLER_NAME (decl)\n-\t= build_decl_overload (declarator, TYPE_ARG_TYPES (TREE_TYPE (decl)),\n-\t\t\t       TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE);\n+      set_mangled_name_for_decl (decl);\n       DECL_ARGUMENTS (decl) = parmdecls;\n       if (funcdef_flag)\n \tDECL_CLASS_CONTEXT (decl) = current_class_type;\n \n       if (! DECL_USE_TEMPLATE (decl))\n \t{\n \t  /* We can call pushdecl here, because the TREE_CHAIN of this\n-\t     FUNCTION_DECL is not needed for other purposes.  Don't do this\n-\t     for a template instantiation.  */\n-\t  if (!is_friend_template)\n-\t    {  \n-\t      /* However, we don't call pushdecl() for a friend\n-\t\t function of a template class, since in general,\n-\t\t such a declaration depends on template\n-\t\t parameters.  Instead, we call pushdecl when the\n-\t\t class is instantiated.  */\n-\t      if (template_class_depth (current_class_type) == 0)\n-\t\tdecl = pushdecl (decl);\n-\t    }\n+\t     FUNCTION_DECL is not needed for other purposes.  Don't do\n+\t     this for a template instantiation.  However, we don't\n+\t     call pushdecl() for a friend function of a template\n+\t     class, since in general, such a declaration depends on\n+\t     template parameters.  Instead, we call pushdecl when the\n+\t     class is instantiated.  */\n+\t  if (!is_friend_template\n+\t      && template_class_depth (current_class_type) == 0)\n+\t    decl = pushdecl (decl);\n \t  else \n-\t    decl = push_template_decl (decl); \n+\t    decl = push_template_decl_real (decl, /*is_friend=*/1); \n \n \t  if (! funcdef_flag && ! flag_guiding_decls && ! is_friend_template\n \t      && current_template_parms && uses_template_parms (decl))"}, {"sha": "a4c19822897851469f8839ddcefbbd962571e653", "filename": "gcc/cp/method.c", "status": "modified", "additions": 24, "deletions": 29, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=36a117a5b33194265633e62df5968d2385baf8be", "patch": "@@ -71,8 +71,6 @@ static void process_overload_item PROTO((tree,int));\n static void do_build_assign_ref PROTO((tree));\n static void do_build_copy_constructor PROTO((tree));\n static tree largest_union_member PROTO((tree));\n-static tree build_decl_overload_real PROTO((tree, tree, tree, tree,\n-\t\t\t\t\t    tree, int)); \n static void build_template_template_parm_names PROTO((tree));\n static void build_template_parm_names PROTO((tree, tree));\n static void build_underscore_int PROTO((int));\n@@ -922,7 +920,7 @@ build_overload_identifier (name)\n       /* NAME is the TYPE_DECL for a template specialization.  */\n       tree template, parmlist, arglist, tname;\n       template = CLASSTYPE_TEMPLATE_INFO (TREE_TYPE (name));\n-      arglist = innermost_args (TREE_VALUE (template), 0);\n+      arglist = innermost_args (TREE_VALUE (template));\n       template = TREE_PURPOSE (template);\n       tname = DECL_NAME (template);\n       parmlist = DECL_INNERMOST_TEMPLATE_PARMS (template);\n@@ -1499,7 +1497,10 @@ build_static_name (context, name)\n   return get_identifier ((char *)obstack_base (&scratch_obstack));\n }\n \f\n-static tree \n+/* FOR_METHOD should be 1 if the declaration in question is for a member\n+   of a class (including a static member) and 2 if the declaration is\n+   for a constructor.  */\n+tree \n build_decl_overload_real (dname, parms, ret_type, tparms, targs,\n \t\t\t  for_method) \n      tree dname;\n@@ -1660,38 +1661,32 @@ build_decl_overload (dname, parms, for_method)\n \t\t\t\t   NULL_TREE, for_method); \n }\n \n-\n-/* Like build_decl_overload, but for template functions. */\n+/* Set the mangled name (DECL_ASSEMBLER_NAME) for DECL.  */\n \n tree\n-build_template_decl_overload (decl, parms, ret_type, tparms, targs,\n-\t\t\t      for_method) \n+set_mangled_name_for_decl (decl)\n      tree decl;\n-     tree parms;\n-     tree ret_type;\n-     tree tparms;\n-     tree targs;\n-     int for_method;\n {\n-  tree res, saved_ctx;\n+  tree parm_types = TYPE_ARG_TYPES (TREE_TYPE (decl));\n \n-  /* If the template is in a namespace, we need to put that into the\n-     mangled name. Unfortunately, build_decl_overload_real does not\n-     get the decl to mangle, so it relies on the current\n-     namespace. Therefore, we set that here temporarily. */\n-\n-  my_friendly_assert (TREE_CODE_CLASS (TREE_CODE (decl)) == 'd', 980702);\n-  saved_ctx = current_namespace;\n-  current_namespace = CP_DECL_CONTEXT (decl);  \n-\n-  res = build_decl_overload_real (DECL_NAME (decl), parms, ret_type,\n-\t\t\t\t  tparms, targs, for_method); \n-\n-  current_namespace = saved_ctx;\n-  return res;\n+  if (DECL_STATIC_FUNCTION_P (decl))\n+    parm_types = \n+      hash_tree_chain (build_pointer_type (DECL_CLASS_CONTEXT (decl)),\n+\t\t\t\t\t   parm_types);\n+  else\n+    /* The only member functions whose type is a FUNCTION_TYPE, rather\n+       than a METHOD_TYPE, should be static members.  */\n+    my_friendly_assert (!DECL_CONTEXT (decl)\n+\t\t\t|| !IS_AGGR_TYPE_CODE (TREE_CODE (DECL_CONTEXT (decl)))\n+\t\t\t|| TREE_CODE (TREE_TYPE (decl)) != FUNCTION_TYPE,\n+\t\t\t0);\n+\n+  DECL_ASSEMBLER_NAME (decl)\n+    = build_decl_overload (DECL_NAME (decl), parm_types, \n+\t\t\t   DECL_FUNCTION_MEMBER_P (decl)\n+\t\t\t   + DECL_CONSTRUCTOR_P (decl));\n }\n \n-\n /* Build an overload name for the type expression TYPE.  */\n \n tree"}, {"sha": "22d92428291a12fa6f806180bc5ddb3ef8e85708", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 50, "deletions": 47, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=36a117a5b33194265633e62df5968d2385baf8be", "patch": "@@ -267,7 +267,7 @@ empty_parms ()\n %type <ttype> named_class_head_sans_basetype_defn\n %type <ttype> identifier_defn IDENTIFIER_DEFN TYPENAME_DEFN PTYPENAME_DEFN\n \n-%type <ttype> self_template_type\n+%type <ttype> self_template_type .finish_template_type\n \n %token NSNAME\n %type <ttype> NSNAME\n@@ -556,32 +556,46 @@ template_parm:\n \t;\n \n template_def:\n-\t  template_header\n-\t  extdef\n-                { \n-                  if ($1) \n-                    end_template_decl (); \n-\t\t  else\n-\t\t    end_specialization ();\n-\t\t}\n-\t| template_header\n-\t  error  %prec EMPTY\n-\t\t{ \n-                  if ($1) \n-                    end_template_decl ();\n-\t\t  else\n-\t\t    end_specialization (); \n-                }\n+\t  template_header template_extdef\n+                { finish_template_decl ($1); }\n+\t| template_header error  %prec EMPTY\n+                { finish_template_decl ($1); }\n+\t;\n+\n+template_extdef:\n+\t  fndef eat_saved_input\n+\t\t{ if (pending_inlines) do_pending_inlines (); }\n+\t| template_datadef\n+\t\t{ if (pending_inlines) do_pending_inlines (); }\n+\t| template_def\n+\t\t{ if (pending_inlines) do_pending_inlines (); }\n+\t| extern_lang_string .hush_warning fndef .warning_ok eat_saved_input\n+\t\t{ if (pending_inlines) do_pending_inlines ();\n+\t\t  pop_lang_context (); }\n+\t| extern_lang_string .hush_warning template_datadef .warning_ok\n+\t\t{ if (pending_inlines) do_pending_inlines ();\n+\t\t  pop_lang_context (); }\n+\t| extension template_extdef\n+\t\t{ pedantic = $<itype>1; }\n+\t;\n+\n+template_datadef:\n+\t  nomods_initdecls ';'\n+\t| declmods notype_initdecls ';'\n+\t\t{}\n+\t| typed_declspecs initdecls ';'\n+                { note_list_got_semicolon ($1.t); }\n+\t| structsp ';'\n+                { maybe_process_partial_specialization ($1.t);\n+\t\t  note_got_semicolon ($1.t); }\n \t;\n \n datadef:\n \t  nomods_initdecls ';'\n \t| declmods notype_initdecls ';'\n \t\t{}\n \t| typed_declspecs initdecls ';'\n-\t\t{\n-\t\t  note_list_got_semicolon ($1.t);\n-\t\t}\n+                { note_list_got_semicolon ($1.t); }\n         | declmods ';'\n \t\t{ pedwarn (\"empty declaration\"); }\n \t| explicit_instantiation ';'\n@@ -870,29 +884,29 @@ end_explicit_instantiation:\n \n template_type:\n \t  PTYPENAME '<' template_arg_list_opt template_close_bracket\n-\t\t{\n-\t\t  $$ = lookup_template_class ($1, $3, NULL_TREE, NULL_TREE);\n-\t\t  if ($$ != error_mark_node)\n-\t\t    $$ = TYPE_STUB_DECL ($$);\n-\t\t}\n+\t    .finish_template_type\n+                { $$ = $5; }\n \t| TYPENAME  '<' template_arg_list_opt template_close_bracket\n-\t\t{\n-\t\t  $$ = lookup_template_class ($1, $3, NULL_TREE, NULL_TREE);\n-\t\t  if ($$ != error_mark_node)\n-\t\t    $$ = TYPE_STUB_DECL ($$);\n-\t\t}\n+\t    .finish_template_type\n+                { $$ = $5; }\n \t| self_template_type\n \t;\n \n self_template_type:\n \t  SELFNAME  '<' template_arg_list_opt template_close_bracket\n-\t\t{\n-\t\t  $$ = lookup_template_class ($1, $3, NULL_TREE, NULL_TREE);\n-\t\t  if ($$ != error_mark_node)\n-\t\t    $$ = TYPE_STUB_DECL ($$);\n-\t\t}\n+\t    .finish_template_type\n+                { $$ = $5; }\n \t;\n \n+.finish_template_type:\n+                { \n+\t\t  if (yychar == YYEMPTY)\n+\t\t    yychar = YYLEX;\n+\n+\t\t  $$ = finish_template_type ($<ttype>-3, $<ttype>-1, \n+\t\t\t\t\t     yychar == SCOPE);\n+\t\t}\n+\n template_close_bracket:\n \t  '>'\n \t| RSHIFT \n@@ -2193,18 +2207,7 @@ named_class_head:\n \t\t    cp_pedwarn (\"non-`union' tag used in declaring `%#T'\", $$);\n \t\t  if ($2)\n \t\t    {\n-\t\t      if (IS_AGGR_TYPE ($$) && CLASSTYPE_USE_TEMPLATE ($$))\n-\t\t        {\n-\t\t          if (CLASSTYPE_IMPLICIT_INSTANTIATION ($$)\n-\t\t\t      && TYPE_SIZE ($$) == NULL_TREE)\n-\t\t\t    {\n-\t\t\t      SET_CLASSTYPE_TEMPLATE_SPECIALIZATION ($$);\n-\t\t\t      if (processing_template_decl)\n-\t\t\t\tpush_template_decl (TYPE_MAIN_DECL ($$));\n-\t\t\t    }\n-\t\t\t  else if (CLASSTYPE_TEMPLATE_INSTANTIATION ($$))\n-\t\t\t    cp_error (\"specialization after instantiation of `%T'\", $$);\n-\t\t\t}\n+\t\t      maybe_process_partial_specialization ($$);\n \t\t      xref_basetypes (current_aggr, $1, $$, $2); \n \t\t    }\n \t\t}"}, {"sha": "07174a0b4c02e96444416e4fc72d7502938f435e", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1233, "deletions": 888, "changes": 2121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=36a117a5b33194265633e62df5968d2385baf8be"}, {"sha": "a6d03e1a256bcf5d0fda8e815235d82282f25564", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 44, "deletions": 12, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=36a117a5b33194265633e62df5968d2385baf8be", "patch": "@@ -1235,18 +1235,7 @@ begin_class_definition (t)\n     push_template_decl (TYPE_STUB_DECL (t));\n   pushclass (t, 0);\n   TYPE_BEING_DEFINED (t) = 1;\n-  if (IS_AGGR_TYPE (t) && CLASSTYPE_USE_TEMPLATE (t))\n-    {\n-      if (CLASSTYPE_IMPLICIT_INSTANTIATION (t)\n-\t  && TYPE_SIZE (t) == NULL_TREE)\n-\t{\n-\t  SET_CLASSTYPE_TEMPLATE_SPECIALIZATION (t);\n-\t  if (processing_template_decl)\n-\t    push_template_decl (TYPE_MAIN_DECL (t));\n-\t}\n-      else if (CLASSTYPE_TEMPLATE_INSTANTIATION (t))\n-\tcp_error (\"specialization after instantiation of `%T'\", t);\n-    }\n+  maybe_process_partial_specialization (t);\n   /* Reset the interface data, at the earliest possible\n      moment, as it might have been set via a class foo;\n      before.  */\n@@ -1378,6 +1367,15 @@ finish_member_class_template (parms, types)\n      tree parms;\n      tree types;\n {\n+  tree t;\n+\n+  /* If there are declared, but undefined, partial specializations\n+     mixed in with the typespecs they will not yet have passed through\n+     maybe_process_partial_specialization, so we do that here.  */\n+  for (t = types; t != NULL_TREE; t = TREE_CHAIN (t))\n+    if (IS_AGGR_TYPE_CODE (TREE_CODE (TREE_VALUE (t))))\n+      maybe_process_partial_specialization (TREE_VALUE (t));\n+\n   note_list_got_semicolon (types);\n   grok_x_components (types, NULL_TREE); \n   if (TYPE_CONTEXT (TREE_VALUE (types)) != current_class_type)\n@@ -1391,3 +1389,37 @@ finish_member_class_template (parms, types)\n      component_decls.  */\n   return NULL_TREE;\n }\n+\n+/* Finish processsing a complete template declaration.  The PARMS are\n+   the template parameters.  */\n+\n+void\n+finish_template_decl (parms)\n+     tree parms;\n+{\n+  if (parms)\n+    end_template_decl ();\n+  else\n+    end_specialization ();\n+}\n+\n+/* Finish processing a a template-id (which names a type) of the form\n+   NAME < ARGS >.  Return the TYPE_DECL for the type named by the\n+   template-id.  If ENTERING_SCOPE is non-zero we are about to enter\n+   the scope of template-id indicated.  */\n+\n+tree\n+finish_template_type (name, args, entering_scope)\n+     tree name;\n+     tree args;\n+     int entering_scope;\n+{\n+  tree decl;\n+\n+  decl = lookup_template_class (name, args,\n+\t\t\t\tNULL_TREE, NULL_TREE, entering_scope);\n+  if (decl != error_mark_node)\n+    decl = TYPE_STUB_DECL (decl);\n+\n+  return decl;\n+}"}, {"sha": "0ae703b2d325b8c9b766d445adab1429ead509e6", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=36a117a5b33194265633e62df5968d2385baf8be", "patch": "@@ -587,7 +587,10 @@ common_type (t1, t2)\n       else if (binfo_or_else (t2, t1))\n \treturn build_type_attribute_variant (t2, attributes);\n       else\n-\tcompiler_error (\"common_type called with uncommon aggregate types\");\n+\t{\n+\t  compiler_error (\"common_type called with uncommon aggregate types\");\n+\t  return error_mark_node;\n+\t}\n \n     case METHOD_TYPE:\n       if (TREE_CODE (TREE_TYPE (t1)) == TREE_CODE (TREE_TYPE (t2)))"}, {"sha": "b5e997cc6ee62fb7e3c431f0a23ed6fa2a4df48c", "filename": "gcc/testsuite/g++.old-deja/g++.brendan/crash56.C", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash56.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash56.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash56.C?ref=36a117a5b33194265633e62df5968d2385baf8be", "patch": "@@ -1,5 +1,7 @@\n // Build don't link: \n // GROUPS passed old-abort\n+// Special g++ Options:\n+\n const bool FALSE = 0;\n const bool TRUE = 1;\n class ListDProto {\n@@ -41,8 +43,8 @@ public:\n     enum Action { NORMAL, REMOVE_CURRENT };\n     Vix first() const;\n     void first(Vix& x) const;\n-    void next(Vix& x) const;// ERROR - candidate for call\n-    void next(Vix& x, Action a = NORMAL);// ERROR - list of candidates\n+    void next(Vix& x) const;\n+    void next(Vix& x, Action a = NORMAL);\n     Vix last() const;\n     void last(Vix& x) const;\n     void prev(Vix& x) const;"}, {"sha": "8990c4656774d6cbc5f3f04188e1419d8ddec679", "filename": "gcc/testsuite/g++.old-deja/g++.brendan/crash8.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash8.C?ref=36a117a5b33194265633e62df5968d2385baf8be", "patch": "@@ -6,7 +6,7 @@ class Elvis\n } ;\n \n template<int a>\n-class Elvis<0>// ERROR - .*\n-{ // ERROR - \n+class Elvis<0>\n+{ // ERROR - incorrect number of parameters\n    int geta() { return a ; }\n } ;"}, {"sha": "30c72a679f23729b3fe570a92924e1065438400b", "filename": "gcc/testsuite/g++.old-deja/g++.pt/crash11.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash11.C?ref=36a117a5b33194265633e62df5968d2385baf8be", "patch": "@@ -0,0 +1,13 @@\n+// Build don't link:\n+\n+class A\n+{\n+      class A_impl;\n+   public: \n+      A(){}\n+};\n+\n+\n+template <class j> class A::A_impl \n+{ // ERROR - does not declare a template\n+};"}, {"sha": "f3de38e6be1efada78644722d7d5f7e7a1628ef9", "filename": "gcc/testsuite/g++.old-deja/g++.pt/crash13.C", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash13.C?ref=36a117a5b33194265633e62df5968d2385baf8be", "patch": "@@ -0,0 +1,6 @@\n+// Build don't link:\n+\n+template <class T> struct A {};\n+template <class T> struct A<T>;    // ERROR - does not specialize args\n+template <class T> const struct A; // ERROR - parse error\n+template <class T> template A<int>; // ERROR - .*"}, {"sha": "f698316b511fb1cb01349781d4cd36a0b3982200", "filename": "gcc/testsuite/g++.old-deja/g++.pt/crash14.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash14.C?ref=36a117a5b33194265633e62df5968d2385baf8be", "patch": "@@ -0,0 +1,5 @@\n+// Build don't link:\n+\n+template <class T> struct A {};\n+template <class T> struct A<T*>;\n+A<int*> ai; // ERROR - incomplete type"}, {"sha": "2fd687ac8199a9de1e29db377509b69e420e0ba1", "filename": "gcc/testsuite/g++.old-deja/g++.pt/crash8.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash8.C?ref=36a117a5b33194265633e62df5968d2385baf8be", "patch": "@@ -0,0 +1,34 @@\n+// Build don't link:\n+\n+template<class T>\n+class TestClass1 {\n+public:\n+  TestClass1() { } \n+};\n+\n+template<class T>\n+class TestClass2 {\n+public:\n+  TestClass2() { } \n+  T operator()(int) { }\n+};\n+\n+template<class T>\n+void doit(T x) {\n+  TestClass1<T> q1;\n+  q1 = TestClass1<T>();\n+  TestClass2<T> q2;\n+  q2 = TestClass2<T>();\n+\n+  TestClass1<T> p1;\n+  p1 = TestClass1(); // ERROR - template used as expression\n+\n+  TestClass2<T> p2;\n+  p2 = TestClass2(); // ERROR - template used as expression\n+}\n+\n+main() {\n+  double x;\n+  doit(x);\n+}\n+"}, {"sha": "c89fe1dc1d2b7db9bdd1231e0170e936f7fec26e", "filename": "gcc/testsuite/g++.old-deja/g++.pt/friend21.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend21.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend21.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend21.C?ref=36a117a5b33194265633e62df5968d2385baf8be", "patch": "@@ -13,7 +13,7 @@ template <class T> class B\n template <class T> class C\n {\n   template <class U>\n-  friend class A<U>;\n+  friend class A;\n \n   static int i;\n };"}, {"sha": "ed459d71fe2fdaf27f59e3a3678d33d87ead7b09", "filename": "gcc/testsuite/g++.old-deja/g++.pt/friend22.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend22.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend22.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend22.C?ref=36a117a5b33194265633e62df5968d2385baf8be", "patch": "@@ -0,0 +1,10 @@\n+// Build don't link:\n+\n+template <class T = int>\n+struct S\n+{\n+  template <class U>\n+  friend class S;\n+};\n+\n+template struct S<int>;"}, {"sha": "efb24b1d551e0dcdb882897bec5983ae498fc36b", "filename": "gcc/testsuite/g++.old-deja/g++.pt/friend23.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend23.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend23.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend23.C?ref=36a117a5b33194265633e62df5968d2385baf8be", "patch": "@@ -0,0 +1,10 @@\n+// Build don't link:\n+\n+template <class T = int> // ERROR - original definition\n+struct S\n+{\n+  template <class U = int>\n+  friend class S;\n+};\n+\n+template struct S<int>; // ERROR - redefinition of default arg"}, {"sha": "d312b3854ea9f256cbc83bf48be3b39a42ab5619", "filename": "gcc/testsuite/g++.old-deja/g++.pt/friend24.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend24.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend24.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend24.C?ref=36a117a5b33194265633e62df5968d2385baf8be", "patch": "@@ -0,0 +1,18 @@\n+// Build don't link:\n+\n+template <class T>\n+struct S\n+{\n+  template <class U = T>\n+  friend class S;\n+\n+  void f(T);\n+};\n+\n+template struct S<int>;\n+\n+void g()\n+{\n+  S<> s;\n+  s.f(3);\n+}"}, {"sha": "f93e73bc396ff24f29cc8db61fe3670b1d488c01", "filename": "gcc/testsuite/g++.old-deja/g++.pt/friend25.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend25.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend25.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend25.C?ref=36a117a5b33194265633e62df5968d2385baf8be", "patch": "@@ -0,0 +1,15 @@\n+// Build don't link:\n+\n+template <class T> struct A;\n+\n+struct B\n+{\n+  template <class U>\n+  friend class A<U>;  // ERROR - does not specialize any args\n+};\n+\n+struct C\n+{\n+  template <class U>\n+  friend class A<U*>; // ERROR - partial specialization\n+};"}, {"sha": "a426f8b775f09a71b36fec84b50718f5ce0657af", "filename": "gcc/testsuite/g++.old-deja/g++.pt/friend26.C", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend26.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend26.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend26.C?ref=36a117a5b33194265633e62df5968d2385baf8be", "patch": "@@ -0,0 +1,6 @@\n+// Build don't link:\n+\n+struct S\n+{\n+  friend void f<>(int); // ERROR - does not match any template\n+};"}, {"sha": "0f11a49c060c5d0db3230799d5f5f9f72033a1cd", "filename": "gcc/testsuite/g++.old-deja/g++.pt/friend27.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend27.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend27.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend27.C?ref=36a117a5b33194265633e62df5968d2385baf8be", "patch": "@@ -0,0 +1,7 @@\n+// Build don't link:\n+\n+class S\n+{\n+  friend void f<>(int); // ERROR - does not match any template\n+  int i;\n+};"}, {"sha": "7eddc278b256ab3244df2419dd12a9ea664859be", "filename": "gcc/testsuite/g++.old-deja/g++.pt/memclass13.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemclass13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemclass13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemclass13.C?ref=36a117a5b33194265633e62df5968d2385baf8be", "patch": "@@ -0,0 +1,16 @@\n+// Build don't link:\n+\n+template <class X, class Y>\n+struct Inner;\n+\n+template <class T>\n+struct S\n+{\n+  template <class U>\n+  struct Inner\n+  {\n+  };\n+};\n+\n+\n+S<double>::Inner<int> si;"}, {"sha": "ad1b2b4b5ac634a83277056b0464e3c310d119f0", "filename": "gcc/testsuite/g++.old-deja/g++.pt/memclass14.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemclass14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemclass14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemclass14.C?ref=36a117a5b33194265633e62df5968d2385baf8be", "patch": "@@ -0,0 +1,15 @@\n+// Build don't link:\n+\n+template <class X, class Y>\n+struct Inner;\n+\n+struct S\n+{\n+  template <class U>\n+  struct Inner\n+  {\n+  };\n+};\n+\n+\n+S::Inner<int> si;"}, {"sha": "52f92bf52218ccc562f80d0cb4a5c31dac6b5e4a", "filename": "gcc/testsuite/g++.old-deja/g++.pt/memclass15.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemclass15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemclass15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemclass15.C?ref=36a117a5b33194265633e62df5968d2385baf8be", "patch": "@@ -0,0 +1,27 @@\n+// Build don't link:\n+\n+template <class T>\n+struct S1\n+{\n+  template <class U>\n+  struct S2 {};\n+\n+  template <class X, class Y, class Z>\n+  void f(X, Y, Z)\n+    {\n+      S2<Z> s2z;\n+    }\n+\n+  template <class X, class Z>\n+  void g(X, Z)\n+    {\n+      S2<Z> s2z;\n+    }\n+};\n+\n+\n+void h()\n+{\n+  S1<int> si;\n+  si.g(3, 4);\n+}"}, {"sha": "e6f62cfa38d71003ffb90fd27f80a216c2407e63", "filename": "gcc/testsuite/g++.old-deja/g++.pt/memtemp77.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemtemp77.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemtemp77.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemtemp77.C?ref=36a117a5b33194265633e62df5968d2385baf8be", "patch": "@@ -0,0 +1,25 @@\n+extern \"C\" int strcmp(const char*, const char*);\n+\n+template <class T>\n+struct S3\n+{\n+  template <class U>\n+  static char* h(U);\n+};\n+\n+template <class T>\n+template <>\n+char* S3<T>::h(int) { return __PRETTY_FUNCTION__; }\n+\n+template <>\n+template <>\n+char* S3<char>::h(int) { return __PRETTY_FUNCTION__; }\n+\n+int main()\n+{\n+  if (strcmp (S3<double>::h(7), \n+\t      \"static char * S3<double>::h<int>(int)\") == 0)\n+    return 0;\n+  else \n+    return 1;\n+}"}, {"sha": "fb841b96ea760ec3c1c5dfa3ea2441c6cdc3e15c", "filename": "gcc/testsuite/g++.old-deja/g++.pt/ttp52.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fttp52.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fttp52.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fttp52.C?ref=36a117a5b33194265633e62df5968d2385baf8be", "patch": "@@ -12,7 +12,7 @@ class base\n \n // specialization\n template<class Key, class Value>\n-class base<Key, Value, mymap<int, int > >\t// ERROR - mymap<...> is not a template\n-{\t\t\t\t\t\t// ERROR - Bad class name\n+class base<Key, Value, mymap<int, int > >\t\n+{\t\t\t\t\t\t// ERROR - type/value mismatch\n   \n };"}, {"sha": "0b19d54723ea6e23fae2ccac4ce039182960b02e", "filename": "gcc/testsuite/g++.old-deja/g++.pt/typename3.C", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename3.C?ref=36a117a5b33194265633e62df5968d2385baf8be", "patch": "@@ -1,4 +1,5 @@\n // Build don't link:\n+// Special g++ Options:\n \n template <class T>\n struct A"}, {"sha": "6f9362fe8e79a5f620b48e3a1fff4f024d578588", "filename": "gcc/testsuite/g++.old-deja/g++.pt/typename4.C", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename4.C?ref=36a117a5b33194265633e62df5968d2385baf8be", "patch": "@@ -1,4 +1,5 @@\n // Build don't link:\n+// Special g++ Options:\n \n template <class T>\n struct A"}, {"sha": "e967d143f371661faa0e07c680aff513e765e9e4", "filename": "gcc/testsuite/g++.old-deja/g++.pt/typename5.C", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename5.C?ref=36a117a5b33194265633e62df5968d2385baf8be", "patch": "@@ -1,4 +1,5 @@\n // Build don't link:\n+// Special g++ Options:\n \n template <class T>\n struct A"}, {"sha": "0b19d54723ea6e23fae2ccac4ce039182960b02e", "filename": "gcc/testsuite/g++.old-deja/g++.pt/typename6.C", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename6.C?ref=36a117a5b33194265633e62df5968d2385baf8be", "patch": "@@ -1,4 +1,5 @@\n // Build don't link:\n+// Special g++ Options:\n \n template <class T>\n struct A"}, {"sha": "5faa28087c8469049bc3f30574166d83ee086fd2", "filename": "gcc/testsuite/g++.old-deja/g++.robertl/eb125.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb125.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb125.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb125.C?ref=36a117a5b33194265633e62df5968d2385baf8be", "patch": "@@ -7,7 +7,7 @@ void test<class BOX> (test_box *);   // ERROR - illegal code\n \n class test_square\n     {\n-    friend void test<class BOX> (test_box *);\n+      friend void test<class BOX> (test_box *); // ERROR - does not match\n     }\n \n "}, {"sha": "f41ead5313f41c448d122a91ba5e4e5015858a11", "filename": "gcc/testsuite/g++.old-deja/g++.robertl/eb49.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb49.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a117a5b33194265633e62df5968d2385baf8be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb49.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb49.C?ref=36a117a5b33194265633e62df5968d2385baf8be", "patch": "@@ -1,5 +1,5 @@\n // Build don't link:\n-// excess errors test - XFAIL *-*-*\n+// excess errors test\n \n // Here we declare ::S\n typedef struct s1 *S;"}]}