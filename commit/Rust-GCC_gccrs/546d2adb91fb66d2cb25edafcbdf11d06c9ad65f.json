{"sha": "546d2adb91fb66d2cb25edafcbdf11d06c9ad65f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQ2ZDJhZGI5MWZiNjZkMmNiMjVlZGFmY2JkZjExZDA2YzlhZDY1Zg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2003-04-07T19:37:12Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-04-07T19:37:12Z"}, "message": "Change gcov file interface to single file at a time.\n\n\t* gcov-io.h: Replace IN_LIBGCC1 with IN_LIBGCOV. Use IN_GCOV.\n\tConvert to C89 prototypes.\n\t(gcov_file, gcov_length, gcov_position, gcov_buffer, gcov_alloc,\n\tgcov_error, gcov_modified): New static variables.\n\t(gcov_open, gcov_close, gcov_read_bytes, gcov_write_bytes): New\n\tfunctions.\n\t(gcov_write_unsigned, gcov_write_counter, gcov_write_string,\n\tgcov_read_unsigned, gcov_read_counter, gcov_read_string): Adjust.\n\t(gcov_read_summary, gcov_write_summary): Adjust.\n\t(gcov_save_position, gcov_reserve_length, gcov_write_length):\n\tAdjust.\n\t(gcov_resync, gcov_skip, gcov_skip_string): Adjust.\n\t(da_file_open, da_file_close, da_file_eof, da_file_error): Remove.\n\t(da_file_position, da_file_seek, da_file_write, da_file_read):\n\tRemove.\n\t(gcov_error, gcov_eof, gcov_ok, gcov_time): New functions.\n\t* gcov.c (gcov_type): Don't typedef here.\n\t(IN_GCOV): #define\n\t(read_graph_file, read_count_file): Adjust.\n\t* gcov-dump.c (gcov_type): Don't typedef here.\n\t(IN_GCOV): #define.\n\t(tag_function, tag_blocks, tag_arcs, tag_lines, tag_arc_counts):\n\tRemove FILE parameter, adjust.\n\t(struct tag_format): Adjust proc member.\n\t(dump_file): Adjust.\n\t* libgcov.c (IN_LIBGCOV): #define.\n\t(gcov_exit): Adjust.\n\t* loop-init.c: Don't #include gcov-io.h\n\t* profile.c (struct counts_entry): New structure to hold counter\n\tvalues.\n\t(struct section_reference, struct da_index_entry): Remove.\n\t(bbg_file, da_file): Remove.\n\t(htab_counts_index_hash, htab_counts_index_eq,\n\thtab_counts_index_del): Replace with ...\n\t(htab_counts_entry_hash, htab_counts_entry_eq,\n\thtab_counts_entry_del): ... these.\n\t(cleanup_counts_index, index_counts_file): Remove.\n\t(read_counts_file): New function.\n\t(get_exec_counts): Adjust.\n\t(compute_branch_probabilities): Don't free the exec counts here.\n\t(branch_prob): Adjust.\n\t(init_branch_prob): Adjust.\n\t(end_branch_prob): Adjust.\n\nFrom-SVN: r65338", "tree": {"sha": "544c50187f4dba610ef1e5aca2d2179d3211968b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/544c50187f4dba610ef1e5aca2d2179d3211968b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/546d2adb91fb66d2cb25edafcbdf11d06c9ad65f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/546d2adb91fb66d2cb25edafcbdf11d06c9ad65f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/546d2adb91fb66d2cb25edafcbdf11d06c9ad65f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/546d2adb91fb66d2cb25edafcbdf11d06c9ad65f/comments", "author": null, "committer": null, "parents": [{"sha": "5da702b196433484c7163a827e3202c44664734a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5da702b196433484c7163a827e3202c44664734a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5da702b196433484c7163a827e3202c44664734a"}], "stats": {"total": 1700, "additions": 810, "deletions": 890}, "files": [{"sha": "af3813092536c36f044e2e89e98af5c20a434c4c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/546d2adb91fb66d2cb25edafcbdf11d06c9ad65f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/546d2adb91fb66d2cb25edafcbdf11d06c9ad65f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=546d2adb91fb66d2cb25edafcbdf11d06c9ad65f", "patch": "@@ -1,3 +1,50 @@\n+2003-04-07  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tChange gcov file interface to single file at a time.\n+\t* gcov-io.h: Replace IN_LIBGCC1 with IN_LIBGCOV. Use IN_GCOV.\n+\tConvert to C89 prototypes.\n+\t(gcov_file, gcov_length, gcov_position, gcov_buffer, gcov_alloc,\n+\tgcov_error, gcov_modified): New static variables.\n+\t(gcov_open, gcov_close, gcov_read_bytes, gcov_write_bytes): New\n+\tfunctions.\n+\t(gcov_write_unsigned, gcov_write_counter, gcov_write_string,\n+\tgcov_read_unsigned, gcov_read_counter, gcov_read_string): Adjust.\n+\t(gcov_read_summary, gcov_write_summary): Adjust.\n+\t(gcov_save_position, gcov_reserve_length, gcov_write_length):\n+\tAdjust.\n+\t(gcov_resync, gcov_skip, gcov_skip_string): Adjust.\n+\t(da_file_open, da_file_close, da_file_eof, da_file_error): Remove.\n+\t(da_file_position, da_file_seek, da_file_write, da_file_read):\n+\tRemove.\n+\t(gcov_error, gcov_eof, gcov_ok, gcov_time): New functions.\n+\t* gcov.c (gcov_type): Don't typedef here.\n+\t(IN_GCOV): #define\n+\t(read_graph_file, read_count_file): Adjust.\n+\t* gcov-dump.c (gcov_type): Don't typedef here.\n+\t(IN_GCOV): #define.\n+\t(tag_function, tag_blocks, tag_arcs, tag_lines, tag_arc_counts):\n+\tRemove FILE parameter, adjust.\n+\t(struct tag_format): Adjust proc member.\n+\t(dump_file): Adjust.\n+\t* libgcov.c (IN_LIBGCOV): #define.\n+\t(gcov_exit): Adjust.\n+\t* loop-init.c: Don't #include gcov-io.h\n+\t* profile.c (struct counts_entry): New structure to hold counter\n+\tvalues.\n+\t(struct section_reference, struct da_index_entry): Remove.\n+\t(bbg_file, da_file): Remove.\n+\t(htab_counts_index_hash, htab_counts_index_eq,\n+\thtab_counts_index_del): Replace with ...\n+\t(htab_counts_entry_hash, htab_counts_entry_eq,\n+\thtab_counts_entry_del): ... these.\n+\t(cleanup_counts_index, index_counts_file): Remove.\n+\t(read_counts_file): New function.\n+\t(get_exec_counts): Adjust.\n+\t(compute_branch_probabilities): Don't free the exec counts here.\n+\t(branch_prob): Adjust.\n+\t(init_branch_prob): Adjust.\n+\t(end_branch_prob): Adjust.\n+\n 2003-04-07  Aldy Hernandez  <aldyh@redhat.com>\n \n         * doc/invoke.texi (RS/6000 and PowerPC Options): Document"}, {"sha": "5ca64a4f6cf74abcadc693d20e5e3b36259ce53a", "filename": "gcc/gcov-dump.c", "status": "modified", "additions": 51, "deletions": 50, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/546d2adb91fb66d2cb25edafcbdf11d06c9ad65f/gcc%2Fgcov-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/546d2adb91fb66d2cb25edafcbdf11d06c9ad65f/gcc%2Fgcov-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-dump.c?ref=546d2adb91fb66d2cb25edafcbdf11d06c9ad65f", "patch": "@@ -23,26 +23,26 @@ Boston, MA 02111-1307, USA.  */\n #include \"tm.h\"\n #include \"version.h\"\n #include <getopt.h>\n-typedef HOST_WIDEST_INT gcov_type;\n+#define IN_GCOV (-1)\n #include \"gcov-io.h\"\n \n static void dump_file PARAMS ((const char *));\n static void print_prefix PARAMS ((const char *, unsigned));\n static void print_usage PARAMS ((void));\n static void print_version PARAMS ((void));\n-static int tag_function PARAMS ((const char *, FILE *, unsigned, unsigned));\n-static int tag_blocks PARAMS ((const char *, FILE *, unsigned, unsigned));\n-static int tag_arcs PARAMS ((const char *, FILE *, unsigned, unsigned));\n-static int tag_lines PARAMS ((const char *, FILE *, unsigned, unsigned));\n-static int tag_arc_counts PARAMS ((const char *, FILE *, unsigned, unsigned));\n-static int tag_summary PARAMS ((const char *, FILE *, unsigned, unsigned));\n+static int tag_function PARAMS ((const char *, unsigned, unsigned));\n+static int tag_blocks PARAMS ((const char *, unsigned, unsigned));\n+static int tag_arcs PARAMS ((const char *, unsigned, unsigned));\n+static int tag_lines PARAMS ((const char *, unsigned, unsigned));\n+static int tag_arc_counts PARAMS ((const char *, unsigned, unsigned));\n+static int tag_summary PARAMS ((const char *, unsigned, unsigned));\n extern int main PARAMS ((int, char **));\n \n typedef struct tag_format\n {\n   unsigned tag;\n   char const *name;\n-  int (*proc) (const char *, FILE *, unsigned, unsigned);\n+  int (*proc) (const char *, unsigned, unsigned);\n } tag_format_t;\n \n static int flag_dump_contents = 0;\n@@ -138,24 +138,22 @@ static void\n dump_file (filename)\n      const char *filename;\n {\n-  FILE *file = fopen (filename, \"rb\");\n   unsigned tags[4];\n   unsigned depth = 0;\n   unsigned magic, version;\n   unsigned tag, length;\n   \n-  if (!file)\n+  if (!gcov_open (filename, 1))\n     {\n       fprintf (stderr, \"%s:cannot open\\n\", filename);\n       return;\n     }\n   \n-  if (gcov_read_unsigned (file, &magic)\n-      || gcov_read_unsigned (file, &version))\n+  if (gcov_read_unsigned (&magic) || gcov_read_unsigned (&version))\n     {\n     read_error:;\n-      printf (\"%s:read error at %ld\\n\", filename, ftell (file));\n-      fclose (file);\n+      printf (\"%s:read error at %lu\\n\", filename, gcov_save_position ());\n+      gcov_close ();\n       return;\n     }\n \n@@ -174,7 +172,7 @@ dump_file (filename)\n     else\n       {\n \tprintf (\"%s:not a gcov file\\n\", filename);\n-\tfclose (file);\n+\tgcov_close ();\n \treturn;\n       }\n     for (ix = 4; ix--; expected >>= 8, version >>= 8, magic >>= 8)\n@@ -189,14 +187,13 @@ dump_file (filename)\n       printf (\"%s:warning:current version is `%.4s'\\n\", filename, e);\n   }\n \n-  while (!gcov_read_unsigned (file, &tag)\n-\t && !gcov_read_unsigned (file, &length))\n+  while (!gcov_read_unsigned (&tag) && !gcov_read_unsigned (&length))\n     {\n       tag_format_t const *format;\n       unsigned tag_depth;\n       long base, end;\n       \n-      base = gcov_save_position (file);\n+      base = gcov_save_position ();\n       \n       if (!tag)\n \ttag_depth = depth;\n@@ -234,11 +231,11 @@ dump_file (filename)\n       print_prefix (filename, tag_depth);\n       printf (\"%08x:%4u:%s\", tag, length, format->name);\n       if (format->proc)\n-\tif ((*format->proc) (filename, file, tag, length))\n+\tif ((*format->proc) (filename, tag, length))\n \t  goto read_error;\n       printf (\"\\n\");\n-      end = gcov_save_position (file);\n-      gcov_resync (file, base, length);\n+      end = gcov_save_position ();\n+      gcov_resync (base, length);\n       if (format->proc && end != base + (long)length)\n \t{\n \t  if (end > base + (long)length)\n@@ -249,35 +246,44 @@ dump_file (filename)\n \t\t    filename, length - (end - base));\n \t}\n     }\n-  if (!feof (file))\n+  if (!gcov_eof ())\n     goto read_error;\n-  fclose (file);\n+  gcov_close ();\n }\n \n static int\n-tag_function (filename, file, tag, length)\n+tag_function (filename, tag, length)\n      const char *filename ATTRIBUTE_UNUSED;\n-     FILE *file ATTRIBUTE_UNUSED;\n      unsigned tag ATTRIBUTE_UNUSED;\n      unsigned length ATTRIBUTE_UNUSED;\n {\n   char *name = NULL;\n   unsigned checksum;\n+  char *src = NULL;\n+  unsigned lineno = 0;\n+  unsigned long pos = gcov_save_position ();\n+  \n+  if (gcov_read_string (&name)\n+      || gcov_read_unsigned (&checksum))\n+    return 1;\n \n-  if (gcov_read_string (file, &name, NULL)\n-      || gcov_read_unsigned (file, &checksum))\n+  if (gcov_save_position () - pos != length\n+      && (gcov_read_string (&src)\n+\t  || gcov_read_unsigned (&lineno)))\n     return 1;\n \n   printf (\" `%s' checksum=0x%08x\", name, checksum);\n+  if (src)\n+    printf (\" %s:%u\", src, lineno);\n   free (name);\n+  free (src);\n   \n   return 0;\n }\n \n static int\n-tag_blocks (filename, file, tag, length)\n+tag_blocks (filename, tag, length)\n      const char *filename ATTRIBUTE_UNUSED;\n-     FILE *file ATTRIBUTE_UNUSED;\n      unsigned tag ATTRIBUTE_UNUSED;\n      unsigned length ATTRIBUTE_UNUSED;\n {\n@@ -292,7 +298,7 @@ tag_blocks (filename, file, tag, length)\n       for (ix = 0; ix != n_blocks; ix++)\n \t{\n \t  unsigned flags;\n-\t  if (gcov_read_unsigned (file, &flags))\n+\t  if (gcov_read_unsigned (&flags))\n \t    return 1;\n \t  if (!(ix & 7))\n \t    printf (\"\\n%s:\\t\\t%u\", filename, ix);\n@@ -301,15 +307,14 @@ tag_blocks (filename, file, tag, length)\n       \n     }\n   else\n-    gcov_skip (file, n_blocks * 4);\n+    gcov_skip (n_blocks * 4);\n   \n   return 0;\n }\n \n static int\n-tag_arcs (filename, file, tag, length)\n+tag_arcs (filename, tag, length)\n      const char *filename ATTRIBUTE_UNUSED;\n-     FILE *file ATTRIBUTE_UNUSED;\n      unsigned tag ATTRIBUTE_UNUSED;\n      unsigned length ATTRIBUTE_UNUSED;\n {\n@@ -321,31 +326,29 @@ tag_arcs (filename, file, tag, length)\n       unsigned ix;\n       unsigned blockno;\n \n-      if (gcov_read_unsigned (file, &blockno))\n+      if (gcov_read_unsigned (&blockno))\n \treturn 1;\n \n       for (ix = 0; ix != n_arcs; ix++)\n \t{\n \t  unsigned dst, flags;\n \t  \n-\t  if (gcov_read_unsigned (file, &dst)\n-\t      || gcov_read_unsigned (file, &flags))\n+\t  if (gcov_read_unsigned (&dst) || gcov_read_unsigned (&flags))\n \t    return 1;\n \t  if (!(ix & 3))\n \t    printf (\"\\n%s:\\t\\t%u:\", filename, blockno);\n \t  printf (\" %u:%04x\", dst, flags);\n \t}\n     }\n   else\n-    gcov_skip (file, 4 + n_arcs * 8);\n+    gcov_skip (4 + n_arcs * 8);\n   \n   return 0;\n }\n \n static int\n-tag_lines (filename, file, tag, length)\n+tag_lines (filename, tag, length)\n      const char *filename ATTRIBUTE_UNUSED;\n-     FILE *file ATTRIBUTE_UNUSED;\n      unsigned tag ATTRIBUTE_UNUSED;\n      unsigned length ATTRIBUTE_UNUSED;\n {\n@@ -355,21 +358,21 @@ tag_lines (filename, file, tag, length)\n       unsigned blockno;\n       char const *sep = NULL;\n \n-      if (gcov_read_unsigned (file, &blockno))\n+      if (gcov_read_unsigned (&blockno))\n \treturn 1;\n       \n       while (1)\n \t{\n \t  unsigned lineno;\n \t  \n-\t  if (gcov_read_unsigned (file, &lineno))\n+\t  if (gcov_read_unsigned (&lineno))\n \t    {\n \t      free (source);\n \t      return 1;\n \t    }\n \t  if (!lineno)\n \t    {\n-\t      if (gcov_read_string (file, &source, NULL))\n+\t      if (gcov_read_string (&source))\n \t\treturn 1;\n \t      if (!source)\n \t\tbreak;\n@@ -394,15 +397,14 @@ tag_lines (filename, file, tag, length)\n \t}\n     }\n   else\n-    gcov_skip (file, length);\n+    gcov_skip (length);\n   \n   return 0;\n }\n \n static int\n-tag_arc_counts (filename, file, tag, length)\n+tag_arc_counts (filename, tag, length)\n      const char *filename ATTRIBUTE_UNUSED;\n-     FILE *file ATTRIBUTE_UNUSED;\n      unsigned tag ATTRIBUTE_UNUSED;\n      unsigned length ATTRIBUTE_UNUSED;\n {\n@@ -417,7 +419,7 @@ tag_arc_counts (filename, file, tag, length)\n \t{\n \t  gcov_type count;\n \t  \n-\t  if (gcov_read_counter (file, &count))\n+\t  if (gcov_read_counter (&count))\n \t    return 1;\n \t  if (!(ix & 7))\n \t    printf (\"\\n%s:\\t\\t%u\", filename, ix);\n@@ -426,21 +428,20 @@ tag_arc_counts (filename, file, tag, length)\n \t}\n     }\n   else\n-    gcov_skip (file, n_counts * 8);\n+    gcov_skip (n_counts * 8);\n   \n   return 0;\n }\n \n static int\n-tag_summary (filename, file, tag, length)\n+tag_summary (filename, tag, length)\n      const char *filename ATTRIBUTE_UNUSED;\n-     FILE *file ATTRIBUTE_UNUSED;\n      unsigned tag ATTRIBUTE_UNUSED;\n      unsigned length ATTRIBUTE_UNUSED;\n {\n   struct gcov_summary summary;\n \n-  if (gcov_read_summary (file, &summary))\n+  if (gcov_read_summary (&summary))\n     return 1;\n   printf (\" checksum=0x%08x\", summary.checksum);\n   "}, {"sha": "8e10e49141a0defe1a1ea604d00181c591db9121", "filename": "gcc/gcov-io.h", "status": "modified", "additions": 413, "deletions": 417, "changes": 830, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/546d2adb91fb66d2cb25edafcbdf11d06c9ad65f/gcc%2Fgcov-io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/546d2adb91fb66d2cb25edafcbdf11d06c9ad65f/gcc%2Fgcov-io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.h?ref=546d2adb91fb66d2cb25edafcbdf11d06c9ad65f", "patch": "@@ -135,24 +135,30 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    merged.\n \n    This file is included by both the compiler, gcov tools and the\n-   library.  The IN_LIBGCC2 define distinguishes these cases.  When\n-   IN_LIBGCC2 is nonzero, we're building libgcc2 for the target and\n-   know the compiler is (the just built) gcc.  Otherwise we're\n-   generating code for the host, and the compiler may or may not be\n-   gcc.  In this latter case, you must ensure that 'gcov_type' is\n-   typedefed to something suitable (unsigned HOST_WIDEST_INT is\n-   usually what you want).  */\n+   runtime support library libgcov. IN_LIBGCOV and IN_GCOV are used to\n+   distinguish which case is which.  If IN_LIBGCOV is non-zero,\n+   libgcov is being built. If IN_GCOV is non-zero, the gcov tools are\n+   being built. Otherwise the compiler is being built. IN_GCOV may be\n+   positive or negative. If positive, we are compiling a tool that\n+   requires additional functions (see the code for knowledge of what\n+   those functions are).  */\n \n #ifndef GCC_GCOV_IO_H\n #define GCC_GCOV_IO_H\n \n-#if IN_LIBGCC2\n+#if IN_LIBGCOV\n #if LONG_TYPE_SIZE == GCOV_TYPE_SIZE\n typedef long gcov_type;\n #else\n typedef long long gcov_type;\n #endif\n-#endif /* IN_LIBGCC2 */\n+#endif /* IN_LIBGCOV */\n+#if IN_GCOV\n+typedef HOST_WIDEST_INT gcov_type;\n+#if IN_GCOV > 0\n+#include <sys/types.h>\n+#endif\n+#endif\n \n /* File suffixes.  */\n #define GCOV_DATA_SUFFIX \".da\"\n@@ -228,7 +234,7 @@ struct counter_section\n   unsigned n_counters;\t/* Number of counters in the section.  */\n };\n \n-#if IN_LIBGCC2\n+#if IN_LIBGCOV\n /* Information about section of counters for an object file.  */\n struct counter_section_data\n {\n@@ -272,139 +278,369 @@ extern void __gcov_flush (void);\n \n /* Since this file is used in both host and target files, and we don't\n    include ansidecl.h in target files, provide some necessary macros.  */\n-#ifndef PARAMS\n-# define PARAMS(X) X\n-#endif\n #ifndef ATTRIBUTE_UNUSED\n # define ATTRIBUTE_UNUSED __attribute__ ((__unused__))\n #endif\n \n-#endif /* IN_LIBGCC2 */\n+#endif /* IN_LIBGCOV */\n+\n+/* Because small reads and writes, interspersed with seeks cause lots\n+   of disk activity, we buffer the entire count files.  */\n+\n+static FILE *gcov_file;\n+static size_t gcov_position;\n+static size_t gcov_length;\n+static unsigned char *gcov_buffer;\n+static size_t gcov_alloc;\n+static int gcov_modified;\n+static int gcov_errored = 1;\n \n /* Functions for reading and writing gcov files.  */\n-static int gcov_write_unsigned PARAMS((FILE *, unsigned))\n-     ATTRIBUTE_UNUSED;\n-static int gcov_write_counter PARAMS((FILE *, gcov_type))\n-     ATTRIBUTE_UNUSED;\n-static int gcov_write_string PARAMS((FILE *, const char *, unsigned))\n-     ATTRIBUTE_UNUSED;\n-static int gcov_read_unsigned PARAMS((FILE *, unsigned *))\n-     ATTRIBUTE_UNUSED;\n-static int gcov_read_counter PARAMS((FILE *, gcov_type *))\n-     ATTRIBUTE_UNUSED;\n-#if !IN_LIBGCC2\n-static int gcov_read_string PARAMS((FILE *, char **, unsigned *))\n-     ATTRIBUTE_UNUSED;\n+static int gcov_open (const char */*name*/, int /*truncate*/);\n+static int gcov_close (void);\n+#if !IN_GCOV\n+static unsigned char *gcov_write_bytes (unsigned);\n+static int gcov_write_unsigned (unsigned);\n+#if IN_LIBGCOV\n+static int gcov_write_counter (gcov_type);\n+#endif\n+static int gcov_write_string (const char *);\n+static unsigned long gcov_reserve_length (void);\n+static int gcov_write_length (unsigned long /*position*/);\n+#if IN_LIBGCOV\n+static int gcov_write_summary (unsigned, const struct gcov_summary *);\n+#endif\n+#endif /* !IN_GCOV */\n+static const unsigned char *gcov_read_bytes (unsigned);\n+static int gcov_read_unsigned (unsigned *);\n+static int gcov_read_counter (gcov_type *);\n+#if !IN_LIBGCOV\n+static int gcov_read_string (char **);\n+#endif\n+static int gcov_read_summary (struct gcov_summary *);\n+static __inline__ unsigned long gcov_save_position (void);\n+static int gcov_resync (unsigned long /*base*/, unsigned /*length */);\n+static unsigned long gcov_seek_end (void);\n+static int gcov_skip (unsigned /*length*/);\n+static int gcov_skip_string (unsigned /*length*/);\n+static int gcov_ok (void);\n+static int gcov_error (void);\n+static int gcov_eof (void);\n+#if IN_GCOV > 0\n+static time_t gcov_time (void);\n+#endif\n+\n+/* Open a gcov file. NAME is the name of the file to open and MODE\n+   indicates whether a new file should be created, or an existing file\n+   opened for modification. If MODE is >= 0 an existing file will be\n+   opened, if possible, and if MODE is <= 0, a new file will be\n+   created. Use MODE=0 to attempt to reopen an existing file and then\n+   fall back on creating a new one.  Return zero on failure, >0 on\n+   opening an existing file and <0 on creating a new one.  */\n+\n+static int\n+gcov_open (const char *name, int mode)\n+{\n+  int result = 1;\n+  size_t alloc = 1024;\n+#if defined (TARGET_HAS_F_SETLKW) && IN_LIBGCOV\n+  struct flock s_flock;\n+\n+  s_flock.l_type = F_WRLCK;\n+  s_flock.l_whence = SEEK_SET;\n+  s_flock.l_start = 0;\n+  s_flock.l_len = 0; /* Until EOF.  */\n+  s_flock.l_pid = getpid ();\n+#endif\n+  \n+  if (gcov_file)\n+    abort ();\n+  gcov_position = gcov_length = 0;\n+  gcov_errored = gcov_modified = 0;\n+  if (mode >= 0)\n+    gcov_file = fopen (name, \"r+b\");\n+  if (!gcov_file && mode <= 0)\n+    {\n+      result = -1;\n+      gcov_file = fopen (name, \"w+b\");\n+    }\n+  if (!gcov_file)\n+    return 0;\n+\n+#if defined (TARGET_HAS_F_SETLKW) && IN_LIBGCOV\n+  while (fcntl (fileno (gcov_file), F_SETLKW, &s_flock)\n+\t && errno == EINTR)\n+    continue;\n #endif\n-static int gcov_read_summary PARAMS ((FILE *, struct gcov_summary *))\n-     ATTRIBUTE_UNUSED;\n-#if IN_LIBGCC2\n-static int gcov_write_summary PARAMS ((FILE *, unsigned,\n-\t\t\t\t       const struct gcov_summary *))\n-     ATTRIBUTE_UNUSED;\n+\n+  if (result >= 0)\n+    {\n+      if (fseek (gcov_file, 0, SEEK_END))\n+\t{\n+\t  fclose (gcov_file);\n+\t  gcov_file = 0;\n+\t  return 0;\n+\t}\n+      gcov_length = ftell (gcov_file);\n+      fseek (gcov_file, 0, SEEK_SET);\n+      alloc += gcov_length;\n+    }\n+  if (alloc > gcov_alloc)\n+    {\n+      if (gcov_buffer)\n+\tfree (gcov_buffer);\n+      gcov_alloc = alloc;\n+#if IN_LIBGCOV\n+      gcov_buffer = malloc (gcov_alloc);\n+      if (!gcov_buffer)\n+\t{\n+\t  fclose (gcov_file);\n+\t  gcov_file = 0;\n+\t  gcov_length = 0;\n+\t  gcov_alloc = 0;\n+\t  return 0;\n+\t}\n+#else\n+      gcov_buffer = xmalloc (gcov_alloc);\n #endif\n-#define gcov_save_position(STREAM) \\\n- \tda_file_position (STREAM)\n-#define gcov_reserve_length(STREAM) \\\n-\t(gcov_write_unsigned (STREAM, 0) ? 0 : da_file_position (STREAM) - 4)\n-static int gcov_write_length PARAMS((FILE *, long))\n-     ATTRIBUTE_UNUSED;\n-#define gcov_resync(STREAM, BASE, LENGTH) \\\n-\tda_file_seek (STREAM, BASE + (long)LENGTH, SEEK_SET)\n-#define gcov_skip(STREAM, LENGTH) \\\n-\tda_file_seek (STREAM, LENGTH, SEEK_CUR)\n-#define gcov_skip_string(STREAM, LENGTH) \\\n-\tda_file_seek (STREAM, (LENGTH) + 4 - ((LENGTH) & 3), SEEK_CUR)\n-#if IN_LIBGCC2\n-static FILE *da_file_open PARAMS ((const char *, int *));\n-static int da_file_close PARAMS ((void));\n-static int da_file_eof PARAMS ((void));\n-static int da_file_error PARAMS ((void));\n+    }\n+  if (result >= 0 && fread (gcov_buffer, gcov_length, 1, gcov_file) != 1)\n+    {\n+      fclose (gcov_file);\n+      gcov_file = 0;\n+      gcov_length = 0;\n+      return 0;\n+    }\n+  return result;\n+}\n+\n+/* Close the current gcov file. Flushes data to disk. Returns nonzero\n+   on failure or error flag set.  */\n+\n+static int\n+gcov_close ()\n+{\n+  int result = 0;\n+  \n+  if (gcov_file)\n+    {\n+      if (gcov_modified\n+\t  && (fseek (gcov_file, 0, SEEK_SET)\n+\t      || fwrite (gcov_buffer, gcov_length, 1, gcov_file) != 1))\n+\tresult = -1;\n+      fclose (gcov_file);\n+      gcov_file = 0;\n+      gcov_length = 0;\n+    }\n+  return result || gcov_errored;\n+}\n+\n+#if !IN_GCOV\n+/* Allocate space to write BYTES bytes to the gcov file. Return a\n+   pointer to those bytes, or NULL on failure.  */\n+\n+static unsigned char *\n+gcov_write_bytes (unsigned bytes)\n+{\n+  char unsigned *result;\n+\n+  if (gcov_position + bytes > gcov_alloc)\n+    {\n+      size_t new_size = (gcov_alloc + bytes) * 3 / 2;\n+\n+      if (!gcov_buffer)\n+\treturn 0;\n+#if IN_LIBGCOV\n+      result = realloc (gcov_buffer, new_size);\n+      if (!result)\n+\t{\n+\t  free (gcov_buffer);\n+\t  gcov_buffer = 0;\n+\t  gcov_alloc = 0;\n+\t  gcov_position = gcov_length = 0;\n+\t  return 0;\n+\t}\n+#else\n+      result = xrealloc (gcov_buffer, new_size);\n #endif\n-static unsigned long da_file_position PARAMS ((FILE *));\n-static int da_file_seek PARAMS ((FILE *, long, int));\n-static size_t da_file_write PARAMS ((const void *, size_t, size_t, FILE *));\n-static size_t da_file_read PARAMS ((void *, size_t, size_t, FILE *));\n+      gcov_alloc = new_size;\n+      gcov_buffer = result;\n+    }\n+  \n+  result = &gcov_buffer[gcov_position];\n+  gcov_position += bytes;\n+  gcov_modified = 1;\n+  if (gcov_position > gcov_length)\n+    gcov_length = gcov_position;\n+  return result;\n+}\n \n-/* Write VALUE to coverage file FILE.  Return nonzero if failed due to\n+/* Write VALUE to coverage file.  Return nonzero if failed due to\n    file i/o error, or value error.  */\n \n static int\n-gcov_write_unsigned (file, value)\n-     FILE *file;\n-     unsigned value;\n+gcov_write_unsigned (unsigned value)\n {\n-  char buffer[4];\n+  unsigned char *buffer = gcov_write_bytes (4);\n   unsigned ix;\n \n-  for (ix = sizeof (buffer); ix--; )\n+  if (!buffer)\n+    return 1;\n+  \n+  for (ix = 4; ix--; )\n     {\n       buffer[ix] = value;\n       value >>= 8;\n     }\n-  return ((sizeof (value) > sizeof (buffer) && value)\n-\t  || da_file_write (buffer, 1, sizeof (buffer), file) != sizeof (buffer));\n+  return sizeof (value) > 4 && value;\n }\n \n-/* Write VALUE to coverage file FILE.  Return nonzero if failed due to\n+/* Write VALUE to coverage file.  Return nonzero if failed due to\n    file i/o error, or value error.  Negative values are not checked\n    here -- they are checked in gcov_read_counter.  */\n \n+#if IN_LIBGCOV\n static int\n-gcov_write_counter (file, value)\n-     FILE *file;\n-     gcov_type value;\n+gcov_write_counter (gcov_type value)\n {\n-  char buffer[8];\n+  unsigned char *buffer = gcov_write_bytes (8);\n   unsigned ix;\n \n-  for (ix = sizeof (buffer); ix--; )\n+  if (!buffer)\n+    return 1;\n+  \n+  for (ix = 8; ix--; )\n     {\n       buffer[ix] = value;\n       value >>= 8;\n     }\n-  return ((sizeof (value) > sizeof (buffer) && value != 0 && value != -1)\n-\t  || da_file_write (buffer, 1, sizeof (buffer), file) != sizeof (buffer));\n+  return sizeof (value) > 8 && value;\n }\n+#endif /* IN_LIBGCOV */\n \n-/* Write VALUE to coverage file FILE.  Return nonzero if failed due to\n+/* Write VALUE to coverage file.  Return nonzero if failed due to\n    file i/o error, or value error.  */\n \n static int\n-gcov_write_string (file, string, length)\n-     FILE *file;\n-     unsigned length;\n-     const char *string;\n+gcov_write_string (const char *string)\n {\n-  unsigned pad = 0;\n-  unsigned rem = 4 - (length & 3);\n-\n   if (string)\n-    return (gcov_write_unsigned (file, length)\n-\t    || da_file_write (string, 1, length, file) != length\n-\t    || da_file_write (&pad, 1, rem, file) != rem);\n+    {\n+      unsigned length = strlen (string);\n+      unsigned pad = 0;\n+      unsigned rem = 4 - (length & 3);\n+      unsigned char *buffer;\n+\n+      if (gcov_write_unsigned (length))\n+\treturn 1;\n+      buffer = gcov_write_bytes (length + rem);\n+      if (!buffer)\n+\treturn 1;\n+      memcpy (buffer, string, length);\n+      memcpy (buffer + length, &pad, rem);\n+      return 0;\n+    }\n   else\n-    return gcov_write_unsigned (file, 0);\n+    return gcov_write_unsigned (0);\n+}\n+\n+/* Allocate space to write a record tag length.  Return a value to be\n+   used for gcov_write_length.  */\n+\n+static unsigned long\n+gcov_reserve_length (void)\n+{\n+  unsigned long result = gcov_position;\n+  unsigned char *buffer = gcov_write_bytes (4);\n+\n+  if (!buffer)\n+    return 0;\n+  memset (buffer, 0, 4);\n+  return result;\n+}\n+\n+/* Write a record length at PLACE.  The current file position is the\n+   end of the record, and is restored before returning.  Returns\n+   nonzero on failure.  */\n+\n+static int\n+gcov_write_length (unsigned long position)\n+{\n+  unsigned length = gcov_position - position - 4;\n+  unsigned char *buffer = &gcov_buffer[position];\n+  unsigned ix;\n+\n+  if (!position)\n+    return 1;\n+  for (ix = 4; ix--; )\n+    {\n+      buffer[ix] = length;\n+      length >>= 8;\n+    }\n+  return 0;\n+}\n+\n+#if IN_LIBGCOV\n+/* Write a summary structure to the gcov file.  */\n+\n+static int\n+gcov_write_summary (unsigned tag, const struct gcov_summary *summary)\n+{\n+  volatile unsigned long base; /* volatile is necessary to work around\n+\t\t\t\t  a compiler bug. */\n+\n+  if (gcov_write_unsigned (tag))\n+    return 1;\n+  base = gcov_reserve_length ();\n+  if (gcov_write_unsigned (summary->checksum))\n+    return 1;\n+  if (gcov_write_unsigned (summary->runs)\n+      || gcov_write_unsigned (summary->arcs))\n+    return 1;\n+  if (gcov_write_counter (summary->arc_sum)\n+      || gcov_write_counter (summary->arc_max_one)\n+      || gcov_write_counter (summary->arc_max_sum)\n+      || gcov_write_counter (summary->arc_sum_max))\n+    return 1;\n+  if (gcov_write_length (base))\n+    return 1;\n+  return 0;\n+}\n+#endif /* IN_LIBGCOV */\n+\n+#endif /*!IN_GCOV */\n+\n+/* Return a pointer to read BYTES bytes from the gcov file. Returns\n+   NULL on failure (read past EOF). */\n+\n+static const unsigned char *\n+gcov_read_bytes (unsigned bytes)\n+{\n+  const unsigned char *result;\n+  \n+  if (gcov_position + bytes > gcov_length)\n+    return 0;\n+  result = &gcov_buffer[gcov_position];\n+  gcov_position += bytes;\n+  return result;\n }\n \n-/* Read *VALUE_P from coverage file FILE.  Return nonzero if failed\n+/* Read *VALUE_P from coverage file.  Return nonzero if failed\n    due to file i/o error, or range error.  */\n \n static int\n-gcov_read_unsigned (file, value_p)\n-     FILE *file;\n-     unsigned *value_p;\n+gcov_read_unsigned (unsigned *value_p)\n {\n   unsigned value = 0;\n   unsigned ix;\n-  unsigned char buffer[4];\n+  const unsigned char *buffer = gcov_read_bytes (4);\n \n-  if (da_file_read (buffer, 1, sizeof (buffer), file) != sizeof (buffer))\n+  if (!buffer)\n     return 1;\n-  for (ix = sizeof (value); ix < sizeof (buffer); ix++)\n+  for (ix = sizeof (value); ix < 4; ix++)\n     if (buffer[ix])\n       return 1;\n-  for (ix = 0; ix != sizeof (buffer); ix++)\n+  for (ix = 0; ix != 4; ix++)\n     {\n       value <<= 8;\n       value |= buffer[ix];\n@@ -413,24 +649,22 @@ gcov_read_unsigned (file, value_p)\n   return 0;\n }\n \n-/* Read *VALUE_P from coverage file FILE.  Return nonzero if failed\n+/* Read *VALUE_P from coverage file.  Return nonzero if failed\n    due to file i/o error, or range error.  */\n \n static int\n-gcov_read_counter (file, value_p)\n-     FILE *file;\n-     gcov_type *value_p;\n+gcov_read_counter (gcov_type *value_p)\n {\n   gcov_type value = 0;\n   unsigned ix;\n-  unsigned char buffer[8];\n+  const unsigned char *buffer = gcov_read_bytes (8);\n \n-  if (da_file_read (buffer, 1, sizeof (buffer), file) != sizeof (buffer))\n+  if (!buffer)\n     return 1;\n-  for (ix = sizeof (value); ix < sizeof (buffer); ix++)\n+  for (ix = sizeof (value); ix < 8; ix++)\n     if (buffer[ix])\n       return 1;\n-  for (ix = 0; ix != sizeof (buffer); ix++)\n+  for (ix = 0; ix != 8; ix++)\n     {\n       value <<= 8;\n       value |= buffer[ix];\n@@ -440,377 +674,139 @@ gcov_read_counter (file, value_p)\n   return value < 0;\n }\n \n-#if !IN_LIBGCC2\n+#if !IN_LIBGCOV\n \n-/* Read string from coverage file FILE.  Length is stored in *LENGTH_P\n-   (if non-null), a buffer is allocated and returned in *STRING_P.\n-   Return nonzero if failed due to file i/o error, or range\n-   error.  Uses xmalloc to allocate the string buffer.  */\n+/* Read string from coverage file.  A buffer is allocated and returned\n+   in *STRING_P.  Return nonzero if failed due to file i/o error, or\n+   range error.  Uses xmalloc to allocate the string buffer.  */\n \n static int\n-gcov_read_string (file, string_p, length_p)\n-     FILE *file;\n-     char **string_p;\n-     unsigned *length_p;\n+gcov_read_string (char **string_p)\n {\n   unsigned length;\n+  const unsigned char *buffer;\n \n-  if (gcov_read_unsigned (file, &length))\n+  if (gcov_read_unsigned (&length))\n     return 1;\n \n-  if (length_p)\n-    *length_p = length;\n   free (*string_p);\n-\n   *string_p = NULL;\n   if (!length)\n     return 0;\n \n   length += 4 - (length & 3);\n-  *string_p = (char *) xmalloc (length);\n-\n-  return da_file_read (*string_p, 1, length, file) != length;\n+  buffer = gcov_read_bytes (length);\n+  if (!buffer)\n+    return 1;\n+  \n+  *string_p = xmalloc (length);\n+  if (!*string_p)\n+    return 1;\n \n+  memcpy (*string_p, buffer, length);\n+  return 0;\n }\n \n-#endif /* !IN_LIBGCC2 */\n-\n-/* Write a record length at PLACE.  The current file position is the\n-   end of the record, and is restored before returning.  Returns\n-   nonzero on failure.  */\n-\n-static int\n-gcov_write_length (file, place)\n-     FILE *file;\n-     long place;\n-{\n-  long here = da_file_position (file);\n-  int result = (!place || da_file_seek (file, place, SEEK_SET)\n-\t\t|| gcov_write_unsigned (file, here - place - 4));\n-  if (da_file_seek (file, here, SEEK_SET))\n-    result = 1;\n-  return result;\n-}\n+#endif /* !IN_LIBGCOV */\n \n #define GCOV_SUMMARY_LENGTH 44\n static int\n-gcov_read_summary (da_file, summary)\n-     FILE *da_file;\n-     struct gcov_summary *summary;\n+gcov_read_summary (struct gcov_summary *summary)\n {\n-  return (gcov_read_unsigned (da_file, &summary->checksum)\n-\t  || gcov_read_unsigned (da_file, &summary->runs)\n-\t  || gcov_read_unsigned (da_file, &summary->arcs)\n-\t  || gcov_read_counter (da_file, &summary->arc_sum)\n-\t  || gcov_read_counter (da_file, &summary->arc_max_one)\n-\t  || gcov_read_counter (da_file, &summary->arc_max_sum)\n-\t  || gcov_read_counter (da_file, &summary->arc_sum_max));\n+  return (gcov_read_unsigned (&summary->checksum)\n+\t  || gcov_read_unsigned (&summary->runs)\n+\t  || gcov_read_unsigned (&summary->arcs)\n+\t  || gcov_read_counter (&summary->arc_sum)\n+\t  || gcov_read_counter (&summary->arc_max_one)\n+\t  || gcov_read_counter (&summary->arc_max_sum)\n+\t  || gcov_read_counter (&summary->arc_sum_max));\n }\n \n-#if IN_LIBGCC2\n-static int\n-gcov_write_summary (da_file, tag, summary)\n-     FILE *da_file;\n-     unsigned tag;\n-     const struct gcov_summary *summary;\n-{\n-  long base;\n-\n-  return (gcov_write_unsigned (da_file, tag)\n-\t  || !(base = gcov_reserve_length (da_file))\n-\t  || gcov_write_unsigned (da_file, summary->checksum)\n-\t  || gcov_write_unsigned (da_file, summary->runs)\n-\t  || gcov_write_unsigned (da_file, summary->arcs)\n-\t  || gcov_write_counter (da_file, summary->arc_sum)\n-\t  || gcov_write_counter (da_file, summary->arc_max_one)\n-\t  || gcov_write_counter (da_file, summary->arc_max_sum)\n-\t  || gcov_write_counter (da_file, summary->arc_sum_max)\n-\t  || gcov_write_length (da_file, base));\n-}\n-#endif\n+/* Save the current position in the gcov file.  */\n \n-#if IN_LIBGCC2\n-/* The kernel had problems with managing a lot of small reads/writes we use;\n-   the functions below are used to buffer whole file in memory, thus reading and\n-   writing it only once.  This should be feasible, as we have this amount\n-   of memory for counters allocated anyway.  */\n-\n-static FILE *actual_da_file;\n-static unsigned long actual_da_file_position;\n-static unsigned long actual_da_file_length;\n-static char *actual_da_file_buffer;\n-static unsigned long actual_da_file_buffer_size;\n-\n-/* Open the file NAME and return it; in EXISTED return 1 if it existed\n-   already.  */\n-static FILE *\n-da_file_open (name, existed)\n-     const char *name;\n-     int *existed;\n+static inline unsigned long\n+gcov_save_position (void)\n {\n-#if defined (TARGET_HAS_F_SETLKW)\n-  struct flock s_flock;\n-\n-  s_flock.l_type = F_WRLCK;\n-  s_flock.l_whence = SEEK_SET;\n-  s_flock.l_start = 0;\n-  s_flock.l_len = 0; /* Until EOF.  */\n-  s_flock.l_pid = getpid ();\n-#endif\n-\n-  if (actual_da_file)\n-    return 0;\n-  actual_da_file_position = 0;\n-  if (!actual_da_file_buffer)\n-    {\n-      actual_da_file_buffer = malloc (1);\n-      actual_da_file_buffer_size = 1;\n-    }\n-\n-  actual_da_file = fopen (name, \"r+t\");\n-  if (actual_da_file)\n-    *existed = 1;\n-  else\n-    {\n-      actual_da_file = fopen (name, \"w+t\");\n-      if (actual_da_file)\n-\t*existed = 0;\n-      else\n-\treturn 0;\n-    }\n-\n-#if defined (TARGET_HAS_F_SETLKW)\n-  /* After a fork, another process might try to read and/or write\n-     the same file simultaneously.  So if we can, lock the file to\n-     avoid race conditions.  */\n-  while (fcntl (fileno (actual_da_file), F_SETLKW, &s_flock)\n-\t && errno == EINTR)\n-    continue;\n-#endif\n-\n-  if (*existed)\n-    {\n-      if (fseek (actual_da_file, 0, SEEK_END))\n-\t{\n-\t  fclose (actual_da_file);\n-\t  actual_da_file = 0;\n-\t  return 0;\n-\t}\n-      actual_da_file_length = ftell (actual_da_file);\n-      rewind (actual_da_file);\n-    }\n-  else\n-    actual_da_file_length = 0;\n-\n-  if (actual_da_file_length > actual_da_file_buffer_size)\n-    {\n-      actual_da_file_buffer_size = actual_da_file_length;\n-      actual_da_file_buffer = realloc (actual_da_file_buffer,\n-\t\t\t\t       actual_da_file_buffer_size);\n-      if (!actual_da_file_buffer)\n-\t{\n-\t  fclose (actual_da_file);\n-\t  actual_da_file = 0;\n-\t  return 0;\n-\t}\n-    }\n-\n-  if (*existed)\n-    {\n-      if (fread (actual_da_file_buffer, actual_da_file_length,\n-\t\t 1, actual_da_file) != 1)\n-\t{\n-\t  fclose (actual_da_file);\n-\t  actual_da_file = 0;\n-\t  return 0;\n-\t}\n-      rewind (actual_da_file);\n-    }\n-\n-  return actual_da_file;\n+  return gcov_position;\n }\n \n-/* Write changes to the .da file and close it.  */\n-static int da_file_close ()\n-{\n-  if (!actual_da_file)\n-    return -1;\n-  \n-  if (fwrite (actual_da_file_buffer, actual_da_file_length,\n-     \t      1, actual_da_file) != 1)\n-    return da_file_error ();\n-\n-  if (fclose (actual_da_file))\n-    {\n-      actual_da_file = 0;\n-      return -1;\n-    }\n+/* Reset to a known position.  BASE should have been obtained from\n+   gcov_save_position, LENGTH should be a record length, or zero.  */\n \n-  actual_da_file = 0;\n+static inline int\n+gcov_resync (unsigned long base, unsigned length)\n+{\n+  if (gcov_buffer)\n+    gcov_position = base + length;\n   return 0;\n }\n \n-/* Returns current position in .da file.  */\n-static unsigned long\n-da_file_position (file)\n-     FILE *file;\n-{\n-  if (file)\n-    return ftell (file);\n-  return actual_da_file_position;\n-}\n+/* Move to the end of the gcov file.  */\n \n-/* Tests whether we have reached end of .da file.  */\n-static int\n-da_file_eof ()\n+static inline unsigned long\n+gcov_seek_end ()\n {\n-  return actual_da_file_position == actual_da_file_length;\n+  gcov_position = gcov_length;\n+  return gcov_position;\n }\n \n-/* Change position in the .da file.  */\n-static int\n-da_file_seek (file, pos, whence)\n-     FILE *file;\n-     long pos;\n-     int whence;\n-{\n-  if (file)\n-    return fseek (file, pos, whence);\n-\n-  if (!actual_da_file)\n-    return -1;\n+/* Skip LENGTH bytes in the file.  */\n \n-  switch (whence)\n-    {\n-    case SEEK_CUR:\n-      if (pos < 0 && (unsigned long) -pos > actual_da_file_position)\n-\treturn da_file_error ();\n-\n-      actual_da_file_position += pos;\n-      break;\n-    case SEEK_SET:\n-      actual_da_file_position = pos;\n-      break;\n-    case SEEK_END:\n-      if ((unsigned long) -pos > actual_da_file_length)\n-\treturn da_file_error ();\n-      actual_da_file_position = actual_da_file_length + pos;\n-    }\n-  if (actual_da_file_position > actual_da_file_length)\n-    return da_file_error ();\n+static inline int\n+gcov_skip (unsigned length)\n+{\n+  if (gcov_length < gcov_position + length)\n+    return 1;\n+  gcov_position += length;\n   return 0;\n }\n \n-/* Write LEN chars of DATA to actual .da file; ELTS is expected to be 1,\n-   FILE 0.  */\n-static size_t\n-da_file_write (data, elts, len, file)\n-     const void *data;\n-     size_t elts;\n-     size_t len;\n-     FILE *file;\n-{\n-  size_t l = len;\n-  const char *dat = data;\n-\n-  if (file)\n-    return fwrite (data, elts, len, file);\n-\n-  if (elts != 1)\n-    abort ();\n-\n-  if (!actual_da_file)\n-    return -1;\n-  if (actual_da_file_position + len > actual_da_file_buffer_size)\n-    {\n-      actual_da_file_buffer_size = 2 * (actual_da_file_position + len);\n-      actual_da_file_buffer = realloc (actual_da_file_buffer,\n-\t\t\t\t       actual_da_file_buffer_size);\n-      if (!actual_da_file_buffer)\n-\treturn da_file_error ();\n-    }\n-  while (len--)\n-    actual_da_file_buffer[actual_da_file_position++] = *dat++;\n-  if (actual_da_file_position > actual_da_file_length)\n-    actual_da_file_length = actual_da_file_position;\n-\n-  return l;\n-}\n+/* Skip a string of LENGTH bytes.  */\n \n-/* Read LEN chars of DATA from actual .da file; ELTS is expected to be 1,\n-   FILE 0.  */\n-static size_t\n-da_file_read (data, elts, len, file)\n-     void *data;\n-     size_t elts;\n-     size_t len;\n-     FILE *file;\n+static inline int\n+gcov_skip_string (unsigned length)\n {\n-  size_t l;\n-  char *dat = data;\n-\n-  if (file)\n-    return fread (data, elts, len, file);\n-\n-  if (elts != 1)\n-    abort ();\n-\n-  if (!actual_da_file)\n-    return -1;\n-  if (actual_da_file_position + len > actual_da_file_length)\n-    len = actual_da_file_length - actual_da_file_position;\n-  l = len;\n-  \n-  while (len--)\n-    *dat++ = actual_da_file_buffer[actual_da_file_position++];\n-  return l;\n+  return gcov_skip (length + 4 - (length & 3));\n }\n \n-/* Close the current .da file and report error.  */\n-static int\n-da_file_error ()\n-{\n-  if (actual_da_file)\n-    fclose (actual_da_file);\n-  actual_da_file = 0;\n-  return -1;\n-}\n-#else /* !IN_LIBGCC2 */\n-static size_t\n-da_file_write (data, elts, len, file)\n-     const void *data;\n-     size_t elts;\n-     size_t len;\n-     FILE *file;\n+/* Tests whether we have reached end of .da file.  */\n+\n+static inline int\n+gcov_eof ()\n {\n-  return fwrite (data, elts, len, file);\n+  return gcov_position == gcov_length;\n }\n \n-static size_t\n-da_file_read (data, elts, len, file)\n-     void *data;\n-     size_t elts;\n-     size_t len;\n-     FILE *file;\n+/* Return non-zero if the error flag is set.  */\n+\n+static inline int\n+gcov_ok ()\n {\n-  return fread (data, elts, len, file);\n+  return gcov_file != 0 && !gcov_errored;\n }\n \n-static unsigned long\n-da_file_position (file)\n-     FILE *file;\n+/* Set the error flag. */\n+static inline int\n+gcov_error ()\n {\n-  return ftell (file);\n+  int error = gcov_errored;\n+  \n+  gcov_errored = 1;\n+  return error;\n }\n \n-static int\n-da_file_seek (file, pos, whence)\n-     FILE *file;\n-     long pos;\n-     int whence;\n+#if IN_GCOV > 0\n+/* Return the modification time of the current gcov file.  */\n+\n+static time_t\n+gcov_time ()\n {\n-  return fseek (file, pos, whence);\n+  struct stat status;\n+  \n+  if (fstat (fileno (gcov_file), &status))\n+    return 0;\n+  else\n+    return status.st_mtime;\n }\n-#endif\n-\n+#endif /* IN_GCOV */\n #endif /* GCC_GCOV_IO_H */"}, {"sha": "5a2f4291f4ac054c521bec8801a32ef5e58a3c16", "filename": "gcc/gcov.c", "status": "modified", "additions": 42, "deletions": 44, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/546d2adb91fb66d2cb25edafcbdf11d06c9ad65f/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/546d2adb91fb66d2cb25edafcbdf11d06c9ad65f/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=546d2adb91fb66d2cb25edafcbdf11d06c9ad65f", "patch": "@@ -51,7 +51,7 @@ Boston, MA 02111-1307, USA.  */\n \n #include <getopt.h>\n \n-typedef HOST_WIDEST_INT gcov_type;\n+#define IN_GCOV 1\n #include \"gcov-io.h\"\n \n /* The bbg file is generated by -ftest-coverage option. The da file is\n@@ -706,31 +706,27 @@ find_source (file_name)\n static int\n read_graph_file ()\n {\n-  FILE *file;\n-  struct stat status;\n   unsigned magic, version;\n   unsigned current_tag = 0;\n   unsigned tag;\n   struct function_info *fn = NULL;\n   source_t *src = NULL;\n   unsigned ix;\n \n-  file = fopen (bbg_file_name, \"rb\");\n-  if (!file)\n+  if (!gcov_open (bbg_file_name, 1))\n     {\n       fnotice (stderr, \"%s:cannot open graph file\\n\", bbg_file_name);\n       return 1;\n     }\n-  if (!fstat (fileno (file), &status))\n-    bbg_file_time = status.st_mtime;\n-  if (gcov_read_unsigned (file, &magic) || magic != GCOV_GRAPH_MAGIC)\n+  bbg_file_time = gcov_time ();\n+  if (gcov_read_unsigned (&magic) || magic != GCOV_GRAPH_MAGIC)\n     {\n       fnotice (stderr, \"%s:not a gcov graph file\\n\", bbg_file_name);\n-      fclose (file);\n+      gcov_close ();\n       return 1;\n     }\n \n-  if (gcov_read_unsigned (file, &version) || version != GCOV_VERSION)\n+  if (gcov_read_unsigned (&version) || version != GCOV_VERSION)\n     {\n       char v[4], e[4];\n \n@@ -745,15 +741,15 @@ read_graph_file ()\n \t       bbg_file_name, v, e);\n     }\n   \n-  while (!gcov_read_unsigned (file, &tag))\n+  while (!gcov_read_unsigned (&tag))\n     {\n       unsigned length;\n       long base;\n \n-      if (gcov_read_unsigned (file, &length))\n+      if (gcov_read_unsigned (&length))\n \tgoto corrupt;\n \n-      base = gcov_save_position (file);\n+      base = gcov_save_position ();\n \n       if (tag == GCOV_TAG_FUNCTION)\n \t{\n@@ -763,10 +759,10 @@ read_graph_file ()\n \t  source_t *src;\n \t  function_t *probe, *prev;\n \n-\t  if (gcov_read_string (file, &function_name, NULL)\n-\t      || gcov_read_unsigned (file, &checksum)\n-\t      || gcov_read_string (file, &function_file, NULL)\n-\t      || gcov_read_unsigned (file, &lineno))\n+\t  if (gcov_read_string (&function_name)\n+\t      || gcov_read_unsigned (&checksum)\n+\t      || gcov_read_string (&function_file)\n+\t      || gcov_read_unsigned (&lineno))\n \t    goto corrupt;\n \t  src = find_source (function_file);\n \t  fn = (function_t *)xcalloc (1, sizeof (function_t));\n@@ -810,7 +806,7 @@ read_graph_file ()\n \t\t{\n \t\t  unsigned flags;\n \t\t  \n-\t\t  if (gcov_read_unsigned (file, &flags))\n+\t\t  if (gcov_read_unsigned (&flags))\n \t\t    goto corrupt;\n \t\t  fn->blocks[ix].flags = flags;\n \t\t}\n@@ -822,7 +818,7 @@ read_graph_file ()\n \t  unsigned num_dests = (length - 4) / 8;\n \t  unsigned dest, flags;\n \n-\t  if (gcov_read_unsigned (file, &src)\n+\t  if (gcov_read_unsigned (&src)\n \t      || src >= fn->num_blocks\n \t      || fn->blocks[src].succ)\n \t    goto corrupt;\n@@ -831,8 +827,8 @@ read_graph_file ()\n \t    {\n \t      struct arc_info *arc;\n \t      \n-\t      if (gcov_read_unsigned (file, &dest)\n-\t\t  || gcov_read_unsigned (file, &flags)\n+\t      if (gcov_read_unsigned (&dest)\n+\t\t  || gcov_read_unsigned (&flags)\n \t\t  || dest >= fn->num_blocks)\n \t\tgoto corrupt;\n \t      arc = (arc_t *) xcalloc (1, sizeof (arc_t));\n@@ -883,7 +879,7 @@ read_graph_file ()\n \t  unsigned *line_nos\n \t    = (unsigned *)xcalloc ((length - 4) / 4, sizeof (unsigned));\n \n-\t  if (gcov_read_unsigned (file, &blockno)\n+\t  if (gcov_read_unsigned (&blockno)\n \t      || blockno >= fn->num_blocks\n \t      || fn->blocks[blockno].u.line.encoding)\n \t    goto corrupt;\n@@ -892,7 +888,7 @@ read_graph_file ()\n \t    {\n \t      unsigned lineno;\n \t      \n-\t      if (gcov_read_unsigned (file, &lineno))\n+\t      if (gcov_read_unsigned (&lineno))\n \t\tgoto corrupt;\n \t      if (lineno)\n \t\t{\n@@ -909,7 +905,7 @@ read_graph_file ()\n \t\t{\n \t\t  char *file_name = NULL;\n \t\t  \n-\t\t  if (gcov_read_string (file, &file_name, NULL))\n+\t\t  if (gcov_read_string (&file_name))\n \t\t    goto corrupt;\n \t\t  if (!file_name)\n \t\t    break;\n@@ -928,15 +924,15 @@ read_graph_file ()\n \t  fn = NULL;\n \t  current_tag = 0;\n \t}\n-      if (gcov_resync (file, base, length))\n+      if (gcov_resync (base, length))\n \t{\n \tcorrupt:;\n \t  fnotice (stderr, \"%s:corrupted\\n\", bbg_file_name);\n-\t  fclose (file);\n+\t  gcov_close ();\n \t  return 1;\n \t}\n     }\n-  fclose (file);\n+  gcov_close ();\n   \n   /* We built everything backwards, so nreverse them all */\n   \n@@ -997,27 +993,25 @@ read_graph_file ()\n static int\n read_count_file ()\n {\n-  FILE *file;\n   unsigned ix;\n   char *function_name_buffer = NULL;\n   unsigned magic, version;\n   function_t *fn = NULL;\n \n-  file = fopen (da_file_name, \"rb\");\n-  if (!file)\n+  if (!gcov_open (da_file_name, 1))\n     {\n       fnotice (stderr, \"%s:cannot open data file\\n\", da_file_name);\n       return 1;\n     }\n-  if (gcov_read_unsigned (file, &magic) || magic != GCOV_DATA_MAGIC)\n+  if (gcov_read_unsigned (&magic) || magic != GCOV_DATA_MAGIC)\n     {\n       fnotice (stderr, \"%s:not a gcov data file\\n\", da_file_name);\n     cleanup:;\n       free (function_name_buffer);\n-      fclose (file);\n+      gcov_close ();\n       return 1;\n     }\n-  if (gcov_read_unsigned (file, &version) || version != GCOV_VERSION)\n+  if (gcov_read_unsigned (&version) || version != GCOV_VERSION)\n     {\n       char v[4], e[4];\n       \n@@ -1036,32 +1030,35 @@ read_count_file ()\n       unsigned tag, length;\n       long base;\n       \n-      if (gcov_read_unsigned (file, &tag)\n-\t  || gcov_read_unsigned (file, &length))\n+      if (gcov_read_unsigned (&tag)\n+\t  || gcov_read_unsigned (&length))\n \t{\n-\t  if (feof (file))\n+\t  if (gcov_eof ())\n \t    break;\n \t  \n \tcorrupt:;\n \t  fnotice (stderr, \"%s:corrupted\\n\", da_file_name);\n \t  goto cleanup;\n \t}\n-      base = gcov_save_position (file);\n+      base = gcov_save_position ();\n       if (tag == GCOV_TAG_OBJECT_SUMMARY)\n \t{\n-\t  if (gcov_read_summary (file, &object_summary))\n+\t  if (gcov_read_summary (&object_summary))\n \t    goto corrupt;\n \t}\n       else if (tag == GCOV_TAG_PROGRAM_SUMMARY\n \t       || tag == GCOV_TAG_INCORRECT_SUMMARY)\n-\tprogram_count++;\n+\t{\n+\t  program_count++;\n+\t  gcov_resync (base, length);\n+\t}\n       else if (tag == GCOV_TAG_FUNCTION)\n \t{\n \t  unsigned checksum;\n \t  struct function_info *fn_n = functions;\n \t  \n-\t  if (gcov_read_string (file, &function_name_buffer, NULL)\n-\t      || gcov_read_unsigned (file, &checksum))\n+\t  if (gcov_read_string (&function_name_buffer)\n+\t      || gcov_read_unsigned (&checksum))\n \t    goto corrupt;\n \n \t  for (fn = fn ? fn->next : NULL; ; fn = fn->next)\n@@ -1103,15 +1100,16 @@ read_count_file ()\n \t    {\n \t      gcov_type count;\n \t      \n-\t      if (gcov_read_counter (file, &count))\n+\t      if (gcov_read_counter (&count))\n \t\tgoto corrupt;\n \t      fn->counts[ix] += count;\n \t    }\n \t}\n-      gcov_resync (file, base, length);\n+      else\n+\tgcov_resync (base, length);\n     }\n \n-  fclose (file);\n+  gcov_close ();\n   free (function_name_buffer);\n   return 0;\n }"}, {"sha": "37d3e800c1a08f2632cdc7c9c097ac494b55afec", "filename": "gcc/libgcov.c", "status": "modified", "additions": 51, "deletions": 73, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/546d2adb91fb66d2cb25edafcbdf11d06c9ad65f/gcc%2Flibgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/546d2adb91fb66d2cb25edafcbdf11d06c9ad65f/gcc%2Flibgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcov.c?ref=546d2adb91fb66d2cb25edafcbdf11d06c9ad65f", "patch": "@@ -57,6 +57,7 @@ void __gcov_flush (void) { }\n #include <fcntl.h>\n #include <errno.h>\n #endif\n+#define IN_LIBGCOV 1\n #include \"gcov-io.h\"\n \n /* Chain of per-object gcov structures.  */\n@@ -102,24 +103,14 @@ gcov_exit (void)\n   gcov_type program_sum = 0;\n   unsigned program_arcs = 0;\n   \n-#if defined (TARGET_HAS_F_SETLKW)\n-  struct flock s_flock;\n-\n-  s_flock.l_type = F_WRLCK;\n-  s_flock.l_whence = SEEK_SET;\n-  s_flock.l_start = 0;\n-  s_flock.l_len = 0; /* Until EOF.  */\n-  s_flock.l_pid = getpid ();\n-#endif\n-\n   memset (&program, 0, sizeof (program));\n   program.checksum = gcov_crc32;\n   \n   for (ptr = gcov_list; ptr; ptr = ptr->next)\n     {\n       struct gcov_summary object;\n       struct gcov_summary local_prg;\n-      int merging = 0;\n+      int merging;\n       long base;\n       const struct function_info *fn_info;\n       gcov_type **counters;\n@@ -164,27 +155,28 @@ gcov_exit (void)\n       memset (&object, 0, sizeof (object));\n       \n       /* Open for modification */\n-      if (!da_file_open (ptr->filename, &merging))\n+      merging = gcov_open (ptr->filename, 0);\n+      \n+      if (!merging)\n \t{\n \t  fprintf (stderr, \"profiling:%s:Cannot open\\n\", ptr->filename);\n \t  ptr->filename = 0;\n \t  continue;\n \t}\n-\n-      if (merging)\n+      \n+      if (merging > 0)\n \t{\n \t  /* Merge data from file.  */\n-\t      \n-\t  if (gcov_read_unsigned (0, &tag) || tag != GCOV_DATA_MAGIC)\n+\t  if (gcov_read_unsigned (&tag) || tag != GCOV_DATA_MAGIC)\n \t    {\n \t      fprintf (stderr, \"profiling:%s:Not a gcov data file\\n\",\n \t\t       ptr->filename);\n \t    read_fatal:;\n-\t      da_file_close ();\n+\t      gcov_close ();\n \t      ptr->filename = 0;\n \t      continue;\n \t    }\n-\t  if (gcov_read_unsigned (0, &length) || length != GCOV_VERSION)\n+\t  if (gcov_read_unsigned (&length) || length != GCOV_VERSION)\n \t    {\n \t      gcov_version_mismatch (ptr, length);\n \t      goto read_fatal;\n@@ -194,8 +186,7 @@ gcov_exit (void)\n \t  for (ix = ptr->n_functions, fn_info = ptr->functions;\n \t       ix--; fn_info++)\n \t    {\n-\t      if (gcov_read_unsigned (0, &tag)\n-\t\t  || gcov_read_unsigned (0, &length))\n+\t      if (gcov_read_unsigned (&tag) || gcov_read_unsigned (&length))\n \t\t{\n \t\tread_error:;\n \t\t  fprintf (stderr, \"profiling:%s:Error merging\\n\",\n@@ -212,9 +203,9 @@ gcov_exit (void)\n \t\t  goto read_fatal;\n \t\t}\n \n-\t      if (gcov_read_unsigned (0, &flength)\n-\t\t  || gcov_skip_string (0, flength)\n-\t\t  || gcov_read_unsigned (0, &checksum))\n+\t      if (gcov_read_unsigned (&flength)\n+\t\t  || gcov_skip_string (flength)\n+\t\t  || gcov_read_unsigned (&checksum))\n \t\tgoto read_error;\n \t      if (flength != strlen (fn_info->name)\n \t\t  || checksum != fn_info->checksum)\n@@ -227,8 +218,8 @@ gcov_exit (void)\n \t\t{\n \t\t  unsigned n_counters;\n \n-\t\t  if (gcov_read_unsigned (0, &tag)\n-\t\t      || gcov_read_unsigned (0, &length))\n+\t\t  if (gcov_read_unsigned (&tag)\n+\t\t      || gcov_read_unsigned (&length))\n \t\t    goto read_error;\n \t\t  for (sect_index = 0;\n \t\t       sect_index < ptr->n_counter_sections;\n@@ -244,7 +235,7 @@ gcov_exit (void)\n \t\t    goto read_mismatch;\n \t\t \n \t\t  for (jx = 0; jx < n_counters; jx++)\n-\t    \t    if (gcov_read_counter (0, &count))\n+\t    \t    if (gcov_read_counter (&count))\n     \t\t      goto read_error;\n \t\t    else\n \t\t      counters[sect_index][jx] += count;\n@@ -253,31 +244,30 @@ gcov_exit (void)\n \t    }\n \n \t  /* Check object summary */\n-\t  if (gcov_read_unsigned (0, &tag)\n-\t      || gcov_read_unsigned (0, &length))\n+\t  if (gcov_read_unsigned (&tag) || gcov_read_unsigned (&length))\n \t    goto read_error;\n \t  if (tag != GCOV_TAG_OBJECT_SUMMARY)\n \t    goto read_mismatch;\n-\t  if (gcov_read_summary (0, &object))\n+\t  if (gcov_read_summary (&object))\n \t    goto read_error;\n \n \t  /* Check program summary */\n \t  while (1)\n \t    {\n-\t      long base = da_file_position (0);\n+\t      long base = gcov_save_position ();\n \t      \n-\t      if (gcov_read_unsigned (0, &tag)\n-\t\t  || gcov_read_unsigned (0, &length))\n+\t      if (gcov_read_unsigned (&tag)\n+\t\t  || gcov_read_unsigned (&length))\n \t\t{\n-\t\t  if (da_file_eof ())\n+\t\t  if (gcov_eof ())\n \t\t    break;\n \t\t  goto read_error;\n \t\t}\n \t      if (tag != GCOV_TAG_PROGRAM_SUMMARY\n \t\t  && tag != GCOV_TAG_PLACEHOLDER_SUMMARY\n \t\t  && tag != GCOV_TAG_INCORRECT_SUMMARY)\n \t\tgoto read_mismatch;\n-\t      if (gcov_read_summary (0, &local_prg))\n+\t      if (gcov_read_summary (&local_prg))\n \t\tgoto read_error;\n \t      if (local_prg.checksum != program.checksum)\n \t\tcontinue;\n@@ -288,7 +278,7 @@ gcov_exit (void)\n \t\t\t   ptr->filename);\n \t\t  goto read_fatal;\n \t\t}\n-\t      merging = -1;\n+\t      merging = 0;\n \t      if (tag != GCOV_TAG_PROGRAM_SUMMARY)\n \t\tbreak;\n \t      \n@@ -304,7 +294,7 @@ gcov_exit (void)\n \t      ptr->wkspc = base;\n \t      break;\n \t    }\n-\t  da_file_seek (0, 0, SEEK_SET);\n+\t  gcov_resync (0, 0);\n \t}\n \n       object.runs++;\n@@ -316,12 +306,12 @@ gcov_exit (void)\n       \n       /* Write out the data.  */\n       if (/* magic */\n-\t  gcov_write_unsigned (0, GCOV_DATA_MAGIC)\n+\t  gcov_write_unsigned (GCOV_DATA_MAGIC)\n \t  /* version number */\n-\t  || gcov_write_unsigned (0, GCOV_VERSION))\n+\t  || gcov_write_unsigned (GCOV_VERSION))\n \t{\n \twrite_error:;\n-\t  da_file_close ();\n+\t  gcov_close ();\n \t  fprintf (stderr, \"profiling:%s:Error writing\\n\", ptr->filename);\n \t  ptr->filename = 0;\n \t  continue;\n@@ -333,14 +323,13 @@ gcov_exit (void)\n       for (ix = ptr->n_functions, fn_info = ptr->functions; ix--; fn_info++)\n \t{\n \t  /* Announce function.  */\n-\t  if (gcov_write_unsigned (0, GCOV_TAG_FUNCTION)\n-\t      || !(base = gcov_reserve_length (0))\n+\t  if (gcov_write_unsigned (GCOV_TAG_FUNCTION)\n+\t      || !(base = gcov_reserve_length ())\n \t      /* function name */\n-\t      || gcov_write_string (0, fn_info->name,\n-\t\t\t\t    strlen (fn_info->name))\n+\t      || gcov_write_string (fn_info->name)\n \t      /* function checksum */\n-\t      || gcov_write_unsigned (0, fn_info->checksum)\n-\t      || gcov_write_length (0, base))\n+\t      || gcov_write_unsigned (fn_info->checksum)\n+\t      || gcov_write_length (base))\n \t    goto write_error;\n \n \t  /* counters.  */\n@@ -357,8 +346,8 @@ gcov_exit (void)\n \t      if (sect_index == ptr->n_counter_sections)\n \t\tabort ();\n \n-\t      if (gcov_write_unsigned (0, tag)\n-\t\t  || !(base = gcov_reserve_length (0)))\n+\t      if (gcov_write_unsigned (tag)\n+\t\t  || !(base = gcov_reserve_length ()))\n \t\tgoto write_error;\n \t  \n     \t      for (jx = fn_info->counter_sections[f_sect_index].n_counters; jx--;)\n@@ -371,41 +360,39 @@ gcov_exit (void)\n \t\t      if (object.arc_max_sum < count)\n \t\t\tobject.arc_max_sum = count;\n \t\t    }\n-\t\t  if (gcov_write_counter (0, count))\n+\t\t  if (gcov_write_counter (count))\n \t\t    goto write_error; /* RIP Edsger Dijkstra */\n \t\t}\n-\t      if (gcov_write_length (0, base))\n+\t      if (gcov_write_length (base))\n \t\tgoto write_error;\n \t    }\n \t}\n \n       /* Object file summary.  */\n-      if (gcov_write_summary (0, GCOV_TAG_OBJECT_SUMMARY, &object))\n+      if (gcov_write_summary (GCOV_TAG_OBJECT_SUMMARY, &object))\n \tgoto write_error;\n \n-      if (merging >= 0)\n+      if (merging)\n \t{\n-\t  if (da_file_seek (0, 0, SEEK_END))\n-\t    goto write_error;\n-\t  ptr->wkspc = da_file_position (0);\n-\t  if (gcov_write_summary (0, GCOV_TAG_PLACEHOLDER_SUMMARY,\n+\t  ptr->wkspc = gcov_seek_end ();\n+\t  if (gcov_write_summary (GCOV_TAG_PLACEHOLDER_SUMMARY,\n \t\t\t\t  &program))\n \t    goto write_error;\n \t}\n       else if (ptr->wkspc)\n \t{\n \t  /* Zap trailing program summary */\n-\t  if (da_file_seek (0, ptr->wkspc, SEEK_SET))\n+\t  if (gcov_resync (ptr->wkspc, 0))\n \t    goto write_error;\n \t  if (!local_prg.runs)\n \t    ptr->wkspc = 0;\n-\t  if (gcov_write_unsigned (0, local_prg.runs\n-\t\t\t\t\t? GCOV_TAG_PLACEHOLDER_SUMMARY\n-\t\t\t\t\t: GCOV_TAG_INCORRECT_SUMMARY))\n+\t  if (gcov_write_unsigned (local_prg.runs\n+\t\t\t\t   ? GCOV_TAG_PLACEHOLDER_SUMMARY\n+\t\t\t\t   : GCOV_TAG_INCORRECT_SUMMARY))\n \t    goto write_error;\n \t}\n \n-      if (da_file_close ())\n+      if (gcov_close ())\n \t{\n \t  fprintf (stderr, \"profiling:%s:Error closing\\n\", ptr->filename);\n \t  ptr->filename = 0;\n@@ -434,25 +421,16 @@ gcov_exit (void)\n   for (ptr = gcov_list; ptr; ptr = ptr->next)\n     if (ptr->filename && ptr->wkspc)\n       {\n-\tFILE *da_file;\n-\t\n-\tda_file = fopen (ptr->filename, \"r+b\");\n-\tif (!da_file)\n+\tif (!gcov_open (ptr->filename, 1))\n \t  {\n \t    fprintf (stderr, \"profiling:%s:Cannot open\\n\", ptr->filename);\n \t    continue;\n \t  }\n \t\n-#if defined (TARGET_HAS_F_SETLKW)\n-\twhile (fcntl (fileno (da_file), F_SETLKW, &s_flock)\n-\t       && errno == EINTR)\n-\t  continue;\n-#endif\n-\tif (fseek (da_file, ptr->wkspc, SEEK_SET)\n- \t    || gcov_write_summary (da_file, GCOV_TAG_PROGRAM_SUMMARY, &program)\n- \t    || fflush (da_file))\n+\tif (gcov_resync (ptr->wkspc, 0)\n+ \t    || gcov_write_summary (GCOV_TAG_PROGRAM_SUMMARY, &program))\n  \t  fprintf (stderr, \"profiling:%s:Error writing\\n\", ptr->filename);\n-\tif (fclose (da_file))\n+\tif (gcov_close ())\n \t  fprintf (stderr, \"profiling:%s:Error closing\\n\", ptr->filename);\n       }\n }"}, {"sha": "d64d407ad940f95cc36d5af218efd302bfd41ffc", "filename": "gcc/loop-init.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/546d2adb91fb66d2cb25edafcbdf11d06c9ad65f/gcc%2Floop-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/546d2adb91fb66d2cb25edafcbdf11d06c9ad65f/gcc%2Floop-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-init.c?ref=546d2adb91fb66d2cb25edafcbdf11d06c9ad65f", "patch": "@@ -27,7 +27,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"basic-block.h\"\n #include \"cfgloop.h\"\n #include \"cfglayout.h\"\n-#include \"gcov-io.h\"\n #include \"profile.h\"\n \n /* Initialize loop optimizer.  */"}, {"sha": "ec53065d5674000934fd6cf6eae6fc7c511b675c", "filename": "gcc/profile.c", "status": "modified", "additions": 206, "deletions": 305, "changes": 511, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/546d2adb91fb66d2cb25edafcbdf11d06c9ad65f/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/546d2adb91fb66d2cb25edafcbdf11d06c9ad65f/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=546d2adb91fb66d2cb25edafcbdf11d06c9ad65f", "patch": "@@ -101,6 +101,27 @@ struct function_list\n   \t\t\t\t/* the sections */\n };\n \n+\n+/* Counts information for a function.  */\n+typedef struct counts_entry\n+{\n+  /* We hash by  */\n+  char *function_name;\n+  unsigned section;\n+  \n+  /* Store  */\n+  unsigned checksum;\n+  unsigned n_counts;\n+  gcov_type *counts;\n+  unsigned merged;\n+  gcov_type max_counter;\n+  gcov_type max_counter_sum;\n+\n+  /* Workspace */\n+  struct counts_entry *chain;\n+  \n+} counts_entry_t;\n+\n static struct function_list *functions_head = 0;\n static struct function_list **functions_tail = &functions_head;\n \n@@ -119,12 +140,10 @@ struct profile_info profile_info;\n \n /* Name and file pointer of the output file for the basic block graph.  */\n \n-static FILE *bbg_file;\n static char *bbg_file_name;\n \n /* Name and file pointer of the input file for the arc count data.  */\n \n-static FILE *da_file;\n static char *da_file_name;\n \n /* The name of the count table. Used by the edge profiling code.  */\n@@ -149,11 +168,10 @@ static void find_spanning_tree PARAMS ((struct edge_list *));\n static rtx gen_edge_profiler PARAMS ((int));\n static void instrument_edges PARAMS ((struct edge_list *));\n static void compute_branch_probabilities PARAMS ((void));\n-static hashval_t htab_counts_index_hash PARAMS ((const void *));\n-static int htab_counts_index_eq PARAMS ((const void *, const void *));\n-static void htab_counts_index_del PARAMS ((void *));\n-static void cleanup_counts_index PARAMS ((int));\n-static int index_counts_file PARAMS ((void));\n+static hashval_t htab_counts_entry_hash PARAMS ((const void *));\n+static int htab_counts_entry_eq PARAMS ((const void *, const void *));\n+static void htab_counts_entry_del PARAMS ((void *));\n+static void read_counts_file PARAMS ((const char *));\n static gcov_type * get_exec_counts PARAMS ((void));\n static unsigned compute_checksum PARAMS ((void));\n static basic_block find_group PARAMS ((basic_block));\n@@ -218,106 +236,61 @@ instrument_edges (el)\n     fprintf (rtl_dump_file, \"%d edges instrumented\\n\", num_instr_edges);\n }\n \f\n-struct section_reference\n-{\n-  long offset;\n-  int owns_summary;\n-  long *summary;\n-};\n-\n-struct da_index_entry\n-{\n-  /* We hash by  */\n-  char *function_name;\n-  unsigned section;\n-  /* and store  */\n-  unsigned checksum;\n-  unsigned n_offsets;\n-  struct section_reference *offsets;\n-};\n-\n static hashval_t\n-htab_counts_index_hash (of)\n+htab_counts_entry_hash (of)\n      const void *of;\n {\n-  const struct da_index_entry *entry = of;\n+  const counts_entry_t *entry = of;\n \n   return htab_hash_string (entry->function_name) ^ entry->section;\n }\n \n static int\n-htab_counts_index_eq (of1, of2)\n+htab_counts_entry_eq (of1, of2)\n      const void *of1;\n      const void *of2;\n {\n-  const struct da_index_entry *entry1 = of1;\n-  const struct da_index_entry *entry2 = of2;\n+  const counts_entry_t *entry1 = of1;\n+  const counts_entry_t *entry2 = of2;\n \n   return !strcmp (entry1->function_name, entry2->function_name)\n-\t  && entry1->section == entry2->section;\n+    && entry1->section == entry2->section;\n }\n \n static void\n-htab_counts_index_del (what)\n-     void *what;\n+htab_counts_entry_del (of)\n+     void *of;\n {\n-  struct da_index_entry *entry = what;\n-  unsigned i;\n+  counts_entry_t *entry = of;\n \n-  for (i = 0; i < entry->n_offsets; i++)\n-    {\n-      struct section_reference *act = entry->offsets + i;\n-      if (act->owns_summary)\n-\tfree (act->summary);\n-    }\n   free (entry->function_name);\n-  free (entry->offsets);\n+  free (entry->counts);\n   free (entry);\n }\n \n-static char *counts_file_name;\n-static htab_t counts_file_index = NULL;\n+static htab_t counts_hash = NULL;\n \n static void\n-cleanup_counts_index (close_file)\n-     int close_file;\n-{\n-  if (da_file && close_file)\n-    {\n-      fclose (da_file);\n-      da_file = NULL;\n-    }\n-  if (counts_file_name)\n-    free (counts_file_name);\n-  counts_file_name = NULL;\n-  if (counts_file_index)\n-    htab_delete (counts_file_index);\n-  counts_file_index = NULL;\n-}\n-\n-static int\n-index_counts_file ()\n+read_counts_file (const char *name)\n {\n   char *function_name_buffer = NULL;\n   unsigned magic, version, ix, checksum;\n-  long *summary;\n-\n-  /* No .da file, no data.  */\n-  if (!da_file)\n-    return 0;\n-  counts_file_index = htab_create (10, htab_counts_index_hash, htab_counts_index_eq, htab_counts_index_del);\n-\n-  /* Now index all profile sections.  */\n-  rewind (da_file);\n-\n-  summary = NULL;\n-\n-  if (gcov_read_unsigned (da_file, &magic) || magic != GCOV_DATA_MAGIC)\n+  counts_entry_t *summaried = NULL;\n+  unsigned seen_summary = 0;\n+  \n+  if (!gcov_open (name, 1))\n     {\n-      warning (\"`%s' is not a gcov data file\", da_file_name);\n-      goto cleanup;\n+      warning (\"file %s not found, execution counts assumed to be zero\", name);\n+      return;\n     }\n-  if (gcov_read_unsigned (da_file, &version) || version != GCOV_VERSION)\n+  \n+  if (gcov_read_unsigned (&magic) || magic != GCOV_DATA_MAGIC)\n+    {\n+      warning (\"`%s' is not a gcov data file\", name);\n+      gcov_close ();\n+      return;\n+    }\n+  else if (gcov_read_unsigned (&version) || version != GCOV_VERSION)\n     {\n       char v[4], e[4];\n       magic = GCOV_VERSION;\n@@ -327,97 +300,121 @@ index_counts_file ()\n \t  v[ix] = version;\n \t  e[ix] = magic;\n \t}\n-      warning (\"`%s' is version `%.4s', expected version `%.4s'\",\n-\t       da_file_name, v, e);\n-      goto cleanup;\n+      warning (\"`%s' is version `%.4s', expected version `%.4s'\", name, v, e);\n+      gcov_close ();\n+      return;\n     }\n   \n+  counts_hash = htab_create (10,\n+\t\t\t     htab_counts_entry_hash, htab_counts_entry_eq,\n+\t\t\t     htab_counts_entry_del);\n   while (1)\n     {\n       unsigned tag, length;\n       long offset;\n       \n-      offset = gcov_save_position (da_file);\n-      if (gcov_read_unsigned (da_file, &tag)\n-\t  || gcov_read_unsigned (da_file, &length))\n+      offset = gcov_save_position ();\n+      if (gcov_read_unsigned (&tag) || gcov_read_unsigned (&length))\n \t{\n-\t  if (feof (da_file))\n+\t  if (gcov_eof ())\n \t    break;\n \tcorrupt:;\n-\t  warning (\"`%s' is corrupted\", da_file_name);\n-\t  goto cleanup;\n+\t  warning (\"`%s' is corrupted\", name);\n+\tcleanup:\n+\t  htab_delete (counts_hash);\n+\t  break;\n \t}\n       if (tag == GCOV_TAG_FUNCTION)\n \t{\n-\t  if (gcov_read_string (da_file, &function_name_buffer, NULL)\n-\t      || gcov_read_unsigned (da_file, &checksum))\n+\t  if (gcov_read_string (&function_name_buffer)\n+\t      || gcov_read_unsigned (&checksum))\n \t    goto corrupt;\n-\t  continue;\n+\t  if (seen_summary)\n+\t    {\n+\t      /* We have already seen a summary, this means that this\n+\t\t new function begins a new set of program runs. We\n+\t\t must unlink the summaried chain.  */\n+\t      counts_entry_t *entry, *chain;\n+\t      \n+\t      for (entry = summaried; entry; entry = chain)\n+\t\t{\n+\t\t  chain = entry->chain;\n+\t\t  \n+\t\t  entry->max_counter_sum += entry->max_counter;\n+\t\t  entry->chain = NULL;\n+\t\t}\n+\t      summaried = NULL;\n+\t      seen_summary = 0;\n+\t    }\n \t}\n-      if (tag == GCOV_TAG_PROGRAM_SUMMARY)\n+      else if (tag == GCOV_TAG_PROGRAM_SUMMARY)\n \t{\n-\t  if (length != GCOV_SUMMARY_LENGTH)\n+\t  counts_entry_t *entry;\n+\t  struct gcov_summary summary;\n+\t  \n+\t  if (length != GCOV_SUMMARY_LENGTH\n+\t      || gcov_read_summary (&summary))\n \t    goto corrupt;\n \n-\t  if (summary)\n-\t    *summary = offset;\n-\t  summary = NULL;\n+\t  seen_summary = 1;\n+\t  for (entry = summaried; entry; entry = entry->chain)\n+\t    {\n+\t      entry->merged += summary.runs;\n+\t      if (entry->max_counter < summary.arc_sum_max)\n+\t\tentry->max_counter = summary.arc_sum_max;\n+\t    }\n \t}\n-      else\n+      else if (GCOV_TAG_IS_SUBTAG (GCOV_TAG_FUNCTION, tag)\n+\t       && function_name_buffer)\n \t{\n-\t  if (function_name_buffer)\n-\t    {\n-\t      struct da_index_entry **slot, elt;\n-\t      elt.function_name = function_name_buffer;\n-\t      elt.section = tag;\n+\t  counts_entry_t **slot, *entry, elt;\n+\t  unsigned n_counts = length / 8;\n+\t  unsigned ix;\n+\t  gcov_type count;\n \n-\t      slot = (struct da_index_entry **)\n-\t\thtab_find_slot (counts_file_index, &elt, INSERT);\n-\t      if (*slot)\n-\t\t{\n-\t\t  if ((*slot)->checksum != checksum)\n-\t\t    {\n-\t\t      warning (\"profile mismatch for `%s'\", function_name_buffer);\n-\t\t      goto cleanup;\n-\t\t    }\n-\t\t  (*slot)->n_offsets++;\n-\t\t  (*slot)->offsets = xrealloc ((*slot)->offsets,\n-\t\t\t\t\t       sizeof (struct section_reference) * (*slot)->n_offsets);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  *slot = xmalloc (sizeof (struct da_index_entry));\n-\t\t  (*slot)->function_name = xstrdup (function_name_buffer);\n-\t\t  (*slot)->section = tag;\n-\t\t  (*slot)->checksum = checksum;\n-\t\t  (*slot)->n_offsets = 1;\n-\t\t  (*slot)->offsets = xmalloc (sizeof (struct section_reference));\n-\t\t}\n-\t      (*slot)->offsets[(*slot)->n_offsets - 1].offset = offset;\n-\t      if (summary)\n-\t\t(*slot)->offsets[(*slot)->n_offsets - 1].owns_summary = 0;\n-\t      else\n-\t\t{\n-\t\t  summary = xmalloc (sizeof (long));\n-\t\t  *summary = -1;\n-\t\t  (*slot)->offsets[(*slot)->n_offsets - 1].owns_summary = 1;\n-\t\t}\n-\t      (*slot)->offsets[(*slot)->n_offsets - 1].summary = summary;\n+\t  elt.function_name = function_name_buffer;\n+\t  elt.section = tag;\n+\n+\t  slot = (counts_entry_t **) htab_find_slot\n+\t    (counts_hash, &elt, INSERT);\n+\t  entry = *slot;\n+\t  if (!entry)\n+\t    {\n+\t      *slot = entry = xmalloc (sizeof (counts_entry_t));\n+\t      entry->function_name = xstrdup (function_name_buffer);\n+\t      entry->section = tag;\n+\t      entry->checksum = checksum;\n+\t      entry->n_counts = n_counts;\n+\t      entry->counts = xcalloc (n_counts, sizeof (gcov_type));\n+\t    }\n+\t  else if (entry->checksum != checksum || entry->n_counts != n_counts)\n+\t    {\n+\t      warning (\"profile mismatch for `%s'\", function_name_buffer);\n+\t      goto cleanup;\n+\t    }\n+\t  \n+\t  /* This should always be true for a just allocated entry,\n+\t     and always false for an existing one. Check this way, in\n+\t     case the gcov file is corrupt.  */\n+\t  if (!entry->chain || summaried != entry)\n+\t    {\n+\t      entry->chain = summaried;\n+\t      summaried = entry;\n+\t    }\n+\t  for (ix = 0; ix != n_counts; ix++)\n+\t    {\n+\t      if (gcov_read_counter (&count))\n+\t\tgoto corrupt;\n+\t      entry->counts[ix] += count;\n \t    }\n \t}\n-      if (gcov_skip (da_file, length))\n-\tgoto corrupt;\n+      else\n+\tif (gcov_skip (length))\n+\t  goto corrupt;\n     }\n \n   free (function_name_buffer);\n-\n-  return 1;\n-\n-cleanup:\n-  cleanup_counts_index (1);\n-  if (function_name_buffer)\n-    free (function_name_buffer);\n-  return 0;\n+  gcov_close ();\n }\n \n /* Computes hybrid profile for all matching entries in da_file.\n@@ -428,26 +425,17 @@ get_exec_counts ()\n {\n   unsigned num_edges = 0;\n   basic_block bb;\n-  gcov_type *profile;\n-  gcov_type max_count;\n-  unsigned ix, i, tag, length, num;\n   const char *name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (current_function_decl));\n-  struct da_index_entry *entry, what;\n-  struct section_reference *act;\n-  gcov_type count;\n-  struct gcov_summary summ;\n+  counts_entry_t *entry, elt;\n \n   profile_info.max_counter_in_program = 0;\n   profile_info.count_profiles_merged = 0;\n \n-  /* No .da file, no execution counts.  */\n-  if (!da_file)\n+  /* No hash table, no counts. */\n+  if (!counts_hash)\n     return NULL;\n-  if (!counts_file_index)\n-    abort ();\n \n   /* Count the edges to be (possibly) instrumented.  */\n-\n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n     {\n       edge e;\n@@ -456,81 +444,24 @@ get_exec_counts ()\n \t  num_edges++;\n     }\n \n-  /* now read and combine all matching profiles.  */\n-\n-  profile = xmalloc (sizeof (gcov_type) * num_edges);\n-\n-  for (ix = 0; ix < num_edges; ix++)\n-    profile[ix] = 0;\n-\n-  what.function_name = (char *) name;\n-  what.section = GCOV_TAG_ARC_COUNTS;\n-  entry = htab_find (counts_file_index, &what);\n+  elt.function_name = (char *) name;\n+  elt.section = GCOV_TAG_ARC_COUNTS;\n+  entry = htab_find (counts_hash, &elt);\n   if (!entry)\n     {\n       warning (\"No profile for function '%s' found.\", name);\n-      goto cleanup;\n+      return NULL;\n     }\n   \n-  if (entry->checksum != profile_info.current_function_cfg_checksum)\n+  if (entry->checksum != profile_info.current_function_cfg_checksum\n+      || num_edges != entry->n_counts)\n     {\n       warning (\"profile mismatch for `%s'\", current_function_name);\n-      goto cleanup;\n+      return NULL;\n     }\n \n-  for (i = 0; i < entry->n_offsets; i++)\n-    {\n-      act = entry->offsets + i;\n-\n-      /* Read arc counters.  */\n-      max_count = 0;\n-      gcov_resync (da_file, act->offset, 0);\n-\n-      if (gcov_read_unsigned (da_file, &tag)\n-\t  || gcov_read_unsigned (da_file, &length)\n-\t  || tag != GCOV_TAG_ARC_COUNTS)\n-\t{\n-\t  /* We have already passed through file, so any error means\n-\t     something is rotten.  */\n-\t  abort ();\n-\t}\n-      num = length / 8;\n-\n-      if (num != num_edges)\n-\t{\n-\t  warning (\"profile mismatch for `%s'\", current_function_name);\n-\t  goto cleanup;\n-\t}\n-\t  \n-      for (ix = 0; ix != num; ix++)\n-\t{\n-\t  if (gcov_read_counter (da_file, &count))\n-\t    abort ();\n-\t  if (count > max_count)\n-\t    max_count = count;\n-\t  profile[ix] += count;\n-\t}\n-\n-      /* Read program summary.  */\n-      if (*act->summary != -1)\n-\t{\n-\t  gcov_resync (da_file, *act->summary, 0);\n-\t  if (gcov_read_unsigned (da_file, &tag)\n-\t      || gcov_read_unsigned (da_file, &length)\n-\t      || tag != GCOV_TAG_PROGRAM_SUMMARY\n-\t      || gcov_read_summary (da_file, &summ))\n-\t    abort ();\n-\t  profile_info.count_profiles_merged += summ.runs;\n-\t  profile_info.max_counter_in_program += summ.arc_sum_max;\n-\t}\n-      else\n-\tsumm.runs = 0;\n-      if (!summ.runs)\n-\t{\n-\t  profile_info.count_profiles_merged++;\n-\t  profile_info.max_counter_in_program += max_count;\n-\t}\n-    }\n+  profile_info.count_profiles_merged = entry->merged;\n+  profile_info.max_counter_in_program = entry->max_counter_sum;\n \n   if (rtl_dump_file)\n     {\n@@ -539,12 +470,7 @@ get_exec_counts ()\n \t      (int)profile_info.max_counter_in_program);\n     }\n \n-  return profile;\n-\n-cleanup:;\n-  free (profile);\n-  cleanup_counts_index (1);\n-  return NULL;\n+  return entry->counts;\n }\n \f\n \n@@ -858,8 +784,6 @@ compute_branch_probabilities ()\n     }\n \n   free_aux_for_blocks ();\n-  if (exec_counts)\n-    free (exec_counts);\n   find_counters_section (GCOV_TAG_ARC_COUNTS)->present = 1;\n }\n \n@@ -1083,42 +1007,40 @@ branch_prob ()\n      edge output the source and target basic block numbers.\n      NOTE: The format of this file must be compatible with gcov.  */\n \n-  if (flag_test_coverage && bbg_file)\n+  if (gcov_ok ())\n     {\n       long offset;\n       const char *file = DECL_SOURCE_FILE (current_function_decl);\n       unsigned line = DECL_SOURCE_LINE (current_function_decl);\n       \n       /* Announce function */\n-      if (gcov_write_unsigned (bbg_file, GCOV_TAG_FUNCTION)\n-\t  || !(offset = gcov_reserve_length (bbg_file))\n-\t  || gcov_write_string (bbg_file, name,\n-\t\t\t     strlen (name))\n-\t  || gcov_write_unsigned (bbg_file,\n-\t\t\t    profile_info.current_function_cfg_checksum)\n-\t  || gcov_write_string (bbg_file, file, strlen (file))\n-\t  || gcov_write_unsigned (bbg_file, line)\n-\t  || gcov_write_length (bbg_file, offset))\n+      if (gcov_write_unsigned (GCOV_TAG_FUNCTION)\n+\t  || !(offset = gcov_reserve_length ())\n+\t  || gcov_write_string (name)\n+\t  || gcov_write_unsigned (profile_info.current_function_cfg_checksum)\n+\t  || gcov_write_string (file)\n+\t  || gcov_write_unsigned (line)\n+\t  || gcov_write_length (offset))\n \tgoto bbg_error;\n \n       /* Basic block flags */\n-      if (gcov_write_unsigned (bbg_file, GCOV_TAG_BLOCKS)\n-\t  || !(offset = gcov_reserve_length (bbg_file)))\n+      if (gcov_write_unsigned (GCOV_TAG_BLOCKS)\n+\t  || !(offset = gcov_reserve_length ()))\n \tgoto bbg_error;\n       for (i = 0; i != (unsigned) (n_basic_blocks + 2); i++)\n-\tif (gcov_write_unsigned (bbg_file, 0))\n+\tif (gcov_write_unsigned (0))\n \t  goto bbg_error;\n-      if (gcov_write_length (bbg_file, offset))\n+      if (gcov_write_length (offset))\n \tgoto bbg_error;\n       \n       /* Arcs */\n       FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n \t{\n \t  edge e;\n \n-\t  if (gcov_write_unsigned (bbg_file, GCOV_TAG_ARCS)\n-\t      || !(offset = gcov_reserve_length (bbg_file))\n-\t      || gcov_write_unsigned (bbg_file, BB_TO_GCOV_INDEX (bb)))\n+\t  if (gcov_write_unsigned (GCOV_TAG_ARCS)\n+\t      || !(offset = gcov_reserve_length ())\n+\t      || gcov_write_unsigned (BB_TO_GCOV_INDEX (bb)))\n \t    goto bbg_error;\n \n \t  for (e = bb->succ; e; e = e->succ_next)\n@@ -1135,14 +1057,13 @@ branch_prob ()\n \t\t  if (e->flags & EDGE_FALLTHRU)\n \t\t    flag_bits |= GCOV_ARC_FALLTHROUGH;\n \n-\t\t  if (gcov_write_unsigned (bbg_file,\n-\t\t\t\t\t   BB_TO_GCOV_INDEX (e->dest))\n-\t\t      || gcov_write_unsigned (bbg_file, flag_bits))\n+\t\t  if (gcov_write_unsigned (BB_TO_GCOV_INDEX (e->dest))\n+\t\t      || gcov_write_unsigned (flag_bits))\n \t\t    goto bbg_error;\n \t        }\n \t    }\n \n-\t  if (gcov_write_length (bbg_file, offset))\n+\t  if (gcov_write_length (offset))\n \t    goto bbg_error;\n \t}\n \n@@ -1185,10 +1106,10 @@ branch_prob ()\n \t\t      {\n \t\t\tif (offset)\n \t\t\t  /*NOP*/;\n-\t\t\telse if (gcov_write_unsigned (bbg_file, GCOV_TAG_LINES)\n-\t\t\t\t || !(offset = gcov_reserve_length (bbg_file))\n-\t\t\t\t || gcov_write_unsigned (bbg_file,\n-\t\t\t\t\t\t   BB_TO_GCOV_INDEX (bb)))\n+\t\t\telse if (gcov_write_unsigned (GCOV_TAG_LINES)\n+\t\t\t\t || !(offset = gcov_reserve_length ())\n+\t\t\t\t || (gcov_write_unsigned\n+\t\t\t\t     (BB_TO_GCOV_INDEX (bb))))\n \t\t\t  goto bbg_error;\n \t\t\t/* If this is a new source file, then output\n \t\t\t   the file's name to the .bb file.  */\n@@ -1197,12 +1118,11 @@ branch_prob ()\n \t\t\t\t       prev_file_name))\n \t\t\t  {\n \t\t\t    prev_file_name = NOTE_SOURCE_FILE (insn);\n-\t\t\t    if (gcov_write_unsigned (bbg_file, 0)\n-\t\t\t\t|| gcov_write_string (bbg_file, prev_file_name,\n-\t\t\t\t\t\t      strlen (prev_file_name)))\n+\t\t\t    if (gcov_write_unsigned (0)\n+\t\t\t\t|| gcov_write_string (prev_file_name))\n \t\t\t      goto bbg_error;\n \t\t\t  }\n-\t\t\tif (gcov_write_unsigned (bbg_file, NOTE_LINE_NUMBER (insn)))\n+\t\t\tif (gcov_write_unsigned (NOTE_LINE_NUMBER (insn)))\n \t\t\t  goto bbg_error;\n \t\t      }\n \t\t  }\n@@ -1211,14 +1131,13 @@ branch_prob ()\n \n \t    if (offset)\n \t      {\n-\t\tif (gcov_write_unsigned (bbg_file, 0)\n-\t\t    || gcov_write_string (bbg_file, NULL, 0)\n-\t\t    || gcov_write_length (bbg_file, offset))\n+\t\tif (gcov_write_unsigned (0)\n+\t\t    || gcov_write_string (NULL)\n+\t\t    || gcov_write_length (offset))\n \t\t  {\n \t\t  bbg_error:;\n \t\t    warning (\"error writing `%s'\", bbg_file_name);\n-\t\t    fclose (bbg_file);\n-\t\t    bbg_file = NULL;\n+\t\t    gcov_error ();\n \t\t  }\n \t      }\n \t  }\n@@ -1395,38 +1314,27 @@ init_branch_prob (filename)\n   int len = strlen (filename);\n   int i;\n \n+  da_file_name = (char *) xmalloc (len + strlen (GCOV_DATA_SUFFIX) + 1);\n+  strcpy (da_file_name, filename);\n+  strcat (da_file_name, GCOV_DATA_SUFFIX);\n+  \n+  if (flag_branch_probabilities)\n+    read_counts_file (da_file_name);\n+\n   if (flag_test_coverage)\n     {\n       /* Open the bbg output file.  */\n       bbg_file_name = (char *) xmalloc (len + strlen (GCOV_GRAPH_SUFFIX) + 1);\n       strcpy (bbg_file_name, filename);\n       strcat (bbg_file_name, GCOV_GRAPH_SUFFIX);\n-      bbg_file = fopen (bbg_file_name, \"wb\");\n-      if (!bbg_file)\n-\tfatal_io_error (\"cannot open %s\", bbg_file_name);\n-\n-      if (gcov_write_unsigned (bbg_file, GCOV_GRAPH_MAGIC)\n-\t  || gcov_write_unsigned (bbg_file, GCOV_VERSION))\n+      if (!gcov_open (bbg_file_name, -1))\n \t{\n-\t  fclose (bbg_file);\n-\t  fatal_io_error (\"cannot write `%s'\", bbg_file_name);\n+\t  error (\"cannot open %s\", bbg_file_name);\n+\t  gcov_error ();\n \t}\n-    }\n-\n-  da_file_name = (char *) xmalloc (len + strlen (GCOV_DATA_SUFFIX) + 1);\n-  strcpy (da_file_name, filename);\n-  strcat (da_file_name, GCOV_DATA_SUFFIX);\n-  \n-  if (flag_branch_probabilities)\n-    {\n-      da_file = fopen (da_file_name, \"rb\");\n-      if (!da_file)\n-\twarning (\"file %s not found, execution counts assumed to be zero\",\n-\t\t da_file_name);\n-      if (counts_file_index && strcmp (da_file_name, counts_file_name))\n-       \tcleanup_counts_index (0);\n-      if (index_counts_file ())\n-\tcounts_file_name = xstrdup (da_file_name);\n+      else if (gcov_write_unsigned (GCOV_GRAPH_MAGIC)\n+\t       || gcov_write_unsigned (GCOV_VERSION))\n+\tgcov_error ();\n     }\n \n   if (profile_arc_flag)\n@@ -1459,27 +1367,20 @@ end_branch_prob ()\n {\n   if (flag_test_coverage)\n     {\n-      if (bbg_file)\n-\t{\n-#if !SELF_COVERAGE\n-\t  /* If the compiler is instrumented, we should not remove the\n-             counts file, because we might be recompiling\n-             ourselves. The .da files are all removed during copying\n-             the stage1 files.  */\n-\t  unlink (da_file_name);\n+      int error = gcov_close ();\n+      \n+      if (error)\n+\tunlink (bbg_file_name);\n+#if SELF_COVERAGE\n+      /* If the compiler is instrumented, we should not\n+         unconditionally remove the counts file, because we might be\n+         recompiling ourselves. The .da files are all removed during\n+         copying the stage1 files.  */\n+      if (error)\n #endif\n-\t  fclose (bbg_file);\n-\t}\n-      else\n-\t{\n-\t  unlink (bbg_file_name);\n-\t  unlink (da_file_name);\n-\t}\n+\tunlink (da_file_name);\n     }\n \n-  if (da_file)\n-    fclose (da_file);\n-\n   if (rtl_dump_file)\n     {\n       fprintf (rtl_dump_file, \"\\n\");"}]}