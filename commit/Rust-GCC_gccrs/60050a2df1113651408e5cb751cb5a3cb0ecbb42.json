{"sha": "60050a2df1113651408e5cb751cb5a3cb0ecbb42", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjAwNTBhMmRmMTExMzY1MTQwOGU1Y2I3NTFjYjVhM2NiMGVjYmI0Mg==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2005-07-04T13:28:59Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-07-04T13:28:59Z"}, "message": "par-load.adb: Load the context items in two rounds.\n\n2005-07-04  Javier Miranda  <miranda@adacore.com>\n\n\t* par-load.adb: Load the context items in two rounds.\n\nFrom-SVN: r101584", "tree": {"sha": "3717bc8812b8b73903c33eb719731940a8a4d388", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3717bc8812b8b73903c33eb719731940a8a4d388"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/60050a2df1113651408e5cb751cb5a3cb0ecbb42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60050a2df1113651408e5cb751cb5a3cb0ecbb42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60050a2df1113651408e5cb751cb5a3cb0ecbb42", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60050a2df1113651408e5cb751cb5a3cb0ecbb42/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c6bbcfff037aaa575fc55de8963d60b5dd124bda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6bbcfff037aaa575fc55de8963d60b5dd124bda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6bbcfff037aaa575fc55de8963d60b5dd124bda"}], "stats": {"total": 145, "additions": 87, "deletions": 58}, "files": [{"sha": "3d42506a025d49e55602f15d485d66994fea1e2a", "filename": "gcc/ada/par-load.adb", "status": "modified", "additions": 87, "deletions": 58, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60050a2df1113651408e5cb751cb5a3cb0ecbb42/gcc%2Fada%2Fpar-load.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60050a2df1113651408e5cb751cb5a3cb0ecbb42/gcc%2Fada%2Fpar-load.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-load.adb?ref=60050a2df1113651408e5cb751cb5a3cb0ecbb42", "patch": "@@ -87,6 +87,9 @@ procedure Load is\n    Unum : Unit_Number_Type;\n    --  Unit number of loaded unit\n \n+   Limited_With_Found : Boolean := False;\n+   --  Set True if a limited WITH is found, used to ???\n+\n    function Same_File_Name_Except_For_Case\n      (Expected_File_Name : File_Name_Type;\n       Actual_File_Name   : File_Name_Type) return Boolean;\n@@ -350,83 +353,109 @@ begin\n       Reset_Validity_Check_Options;\n    end if;\n \n-   --  Loop through context items\n+   --  Load the context items in two rounds: the first round handles normal\n+   --  withed units and the second round handles Ada 2005 limited-withed units.\n+   --  This is required to allow the low-level circuitry that detects circular\n+   --  dependencies of units the correct notification of the following error:\n \n-   Context_Node := First (Context_Items (Curunit));\n-   while Present (Context_Node) loop\n-      if Nkind (Context_Node) = N_With_Clause then\n-         With_Node := Context_Node;\n-         Spec_Name := Get_Unit_Name (With_Node);\n+   --       limited with D;\n+   --       with D;                  with C;\n+   --       package C is ...         package D is ...\n \n-         Unum :=\n-           Load_Unit\n-             (Load_Name         => Spec_Name,\n-              Required          => False,\n-              Subunit           => False,\n-              Error_Node        => With_Node,\n-              Renamings         => True,\n-              From_Limited_With => From_Limited_With\n-                                     or else\n-                                   Limited_Present (Context_Node));\n-\n-         --  If we find the unit, then set spec pointer in the N_With_Clause\n-         --  to point to the compilation unit for the spec. Remember that\n-         --  the Load routine itself sets our Fatal_Error flag if the loaded\n-         --  unit gets a fatal error, so we don't need to worry about that.\n+   for Round in 1 .. 2 loop\n+      Context_Node := First (Context_Items (Curunit));\n+      while Present (Context_Node) loop\n \n-         if Unum /= No_Unit then\n-            Set_Library_Unit (With_Node, Cunit (Unum));\n+         --  During the first round we check if there is some limited-with\n+         --  context clause; otherwise the second round will be skipped\n+\n+         if Nkind (Context_Node) = N_With_Clause\n+           and then Round = 1\n+           and then Limited_Present (Context_Node)\n+         then\n+            Limited_With_Found := True;\n+         end if;\n \n-         --  If the spec isn't found, then try finding the corresponding\n-         --  body, since it is possible that we have a subprogram body\n-         --  that is acting as a spec (since no spec is present).\n+         if Nkind (Context_Node) = N_With_Clause\n+           and then ((Round = 1 and then not Limited_Present (Context_Node))\n+                        or else\n+                     (Round = 2 and then Limited_Present (Context_Node)))\n+         then\n+            With_Node := Context_Node;\n+            Spec_Name := Get_Unit_Name (With_Node);\n \n-         else\n-            Body_Name := Get_Body_Name (Spec_Name);\n             Unum :=\n               Load_Unit\n-                (Load_Name  => Body_Name,\n-                 Required   => False,\n-                 Subunit    => False,\n-                 Error_Node => With_Node,\n-                 Renamings  => True);\n-\n-            --  If we got a subprogram body, then mark that we are using\n-            --  the body as a spec in the file table, and set the spec\n-            --  pointer in the N_With_Clause to point to the body entity.\n-\n-            if Unum /= No_Unit\n-              and then Nkind (Unit (Cunit (Unum))) = N_Subprogram_Body\n-            then\n-               With_Cunit := Cunit (Unum);\n-               Set_Library_Unit (With_Node, With_Cunit);\n-               Set_Acts_As_Spec (With_Cunit, True);\n-               Set_Library_Unit (With_Cunit, With_Cunit);\n+                (Load_Name         => Spec_Name,\n+                 Required          => False,\n+                 Subunit           => False,\n+                 Error_Node        => With_Node,\n+                 Renamings         => True,\n+                 From_Limited_With => From_Limited_With\n+                                        or else\n+                                      Limited_Present (Context_Node));\n+\n+            --  If we find the unit, then set spec pointer in the N_With_Clause\n+            --  to point to the compilation unit for the spec. Remember that\n+            --  the Load routine itself sets our Fatal_Error flag if the loaded\n+            --  unit gets a fatal error, so we don't need to worry about that.\n+\n+            if Unum /= No_Unit then\n+               Set_Library_Unit (With_Node, Cunit (Unum));\n \n-            --  If we couldn't find the body, or if it wasn't a body spec\n-            --  then we are in trouble. We make one more call to Load to\n-            --  require the spec. We know it will fail of course, the\n-            --  purpose is to generate the required error message (we prefer\n-            --  that this message refer to the missing spec, not the body)\n+            --  If the spec isn't found, then try finding the corresponding\n+            --  body, since it is possible that we have a subprogram body\n+            --  that is acting as a spec (since no spec is present).\n \n             else\n+               Body_Name := Get_Body_Name (Spec_Name);\n                Unum :=\n                  Load_Unit\n-                   (Load_Name  => Spec_Name,\n-                    Required   => True,\n+                   (Load_Name  => Body_Name,\n+                    Required   => False,\n                     Subunit    => False,\n                     Error_Node => With_Node,\n                     Renamings  => True);\n \n-               --  Here we create a dummy package unit for the missing unit\n-\n-               Unum := Create_Dummy_Package_Unit (With_Node, Spec_Name);\n-               Set_Library_Unit (With_Node, Cunit (Unum));\n+               --  If we got a subprogram body, then mark that we are using\n+               --  the body as a spec in the file table, and set the spec\n+               --  pointer in the N_With_Clause to point to the body entity.\n+\n+               if Unum /= No_Unit\n+                 and then Nkind (Unit (Cunit (Unum))) = N_Subprogram_Body\n+               then\n+                  With_Cunit := Cunit (Unum);\n+                  Set_Library_Unit (With_Node, With_Cunit);\n+                  Set_Acts_As_Spec (With_Cunit, True);\n+                  Set_Library_Unit (With_Cunit, With_Cunit);\n+\n+               --  If we couldn't find the body, or if it wasn't a body spec\n+               --  then we are in trouble. We make one more call to Load to\n+               --  require the spec. We know it will fail of course, the\n+               --  purpose is to generate the required error message (we prefer\n+               --  that this message refer to the missing spec, not the body)\n+\n+               else\n+                  Unum :=\n+                    Load_Unit\n+                      (Load_Name  => Spec_Name,\n+                       Required   => True,\n+                       Subunit    => False,\n+                       Error_Node => With_Node,\n+                       Renamings  => True);\n+\n+                  --  Here we create a dummy package unit for the missing unit\n+\n+                  Unum := Create_Dummy_Package_Unit (With_Node, Spec_Name);\n+                  Set_Library_Unit (With_Node, Cunit (Unum));\n+               end if;\n             end if;\n          end if;\n-      end if;\n \n-      Next (Context_Node);\n+         Next (Context_Node);\n+      end loop;\n+\n+      exit when not Limited_With_Found;\n    end loop;\n \n    --  Restore style/validity check mode for main unit"}]}