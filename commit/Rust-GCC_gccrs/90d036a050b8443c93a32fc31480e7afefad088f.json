{"sha": "90d036a050b8443c93a32fc31480e7afefad088f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTBkMDM2YTA1MGI4NDQzYzkzYTMyZmMzMTQ4MGU3YWZlZmFkMDg4Zg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-01-18T13:14:34Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-01-18T13:14:34Z"}, "message": "flow.c (mark_set_1, [...]): Now case; rework to allow entry to be EXPR_LIST.\n\n\t* flow.c (mark_set_1, case PARALLEL): Now case; rework to allow\n\tentry to be EXPR_LIST.\n\t* rtlanal.c (reg_overlap_mentioned_p): Allow PARALLEL in SET to\n\tbe an EXPR_LIST (but not null, which other code doesn't allow).\n\t(note_stores): Properly handle PARALLEL in SET.\n\tRecursively call for top-level PARALLEL.\n\t* sched-deps.c (sched_analyze_1): Handle EXPR_LIST in PARALLEL in SET.\n\t* sched-rgn.c (check_live_1, update_live_1): Likewise.\n\nFrom-SVN: r39118", "tree": {"sha": "a7cc3b76930fd2143f70721950dcf585e13f0528", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a7cc3b76930fd2143f70721950dcf585e13f0528"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90d036a050b8443c93a32fc31480e7afefad088f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90d036a050b8443c93a32fc31480e7afefad088f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90d036a050b8443c93a32fc31480e7afefad088f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90d036a050b8443c93a32fc31480e7afefad088f/comments", "author": null, "committer": null, "parents": [{"sha": "8eeb855e2b6b8cc1aea7df5dcd0e0856897668a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8eeb855e2b6b8cc1aea7df5dcd0e0856897668a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8eeb855e2b6b8cc1aea7df5dcd0e0856897668a2"}], "stats": {"total": 180, "additions": 103, "deletions": 77}, "files": [{"sha": "51cb1866feb988416a2fdb91d39c965a35b18e7c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90d036a050b8443c93a32fc31480e7afefad088f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90d036a050b8443c93a32fc31480e7afefad088f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=90d036a050b8443c93a32fc31480e7afefad088f", "patch": "@@ -1,5 +1,14 @@\n Thu Jan 18 06:43:04 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n+\t* flow.c (mark_set_1, case PARALLEL): Now case; rework to allow\n+\tentry to be EXPR_LIST.\n+\t* rtlanal.c (reg_overlap_mentioned_p): Allow PARALLEL in SET to\n+\tbe an EXPR_LIST (but not null, which other code doesn't allow).\n+\t(note_stores): Properly handle PARALLEL in SET.\n+\tRecursively call for top-level PARALLEL.\n+\t* sched-deps.c (sched_analyze_1): Handle EXPR_LIST in PARALLEL in SET.\n+\t* sched-rgn.c (check_live_1, update_live_1): Likewise.\n+\n \t* config.gcc (rs6000-ibm-aix*, rs6000-bull-bosx): Add rs6000/aix.h.\n \n 2001-01-18  Neil Booth  <neil@daikokuya.demon.co.uk>"}, {"sha": "aa37d05de5601fa479c28f907ccc2114a936fdbe", "filename": "gcc/flow.c", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90d036a050b8443c93a32fc31480e7afefad088f/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90d036a050b8443c93a32fc31480e7afefad088f/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=90d036a050b8443c93a32fc31480e7afefad088f", "patch": "@@ -4651,23 +4651,30 @@ mark_set_1 (pbi, code, reg, cond, insn, flags)\n   int not_dead = 0;\n   int i;\n \n-  /* Some targets place small structures in registers for\n-     return values of functions.  We have to detect this\n-     case specially here to get correct flow information.  */\n-  if (GET_CODE (reg) == PARALLEL\n-      && GET_MODE (reg) == BLKmode)\n-    {\n-      for (i = XVECLEN (reg, 0) - 1; i >= 0; i--)\n-\tmark_set_1 (pbi, code, XVECEXP (reg, 0, i), cond, insn, flags);\n-      return;\n-    }\n-\n   /* Modifying just one hardware register of a multi-reg value or just a\n      byte field of a register does not mean the value from before this insn\n      is now dead.  Of course, if it was dead after it's unused now.  */\n \n   switch (GET_CODE (reg))\n     {\n+    case PARALLEL:\n+      /* Some targets place small structures in registers for return values of\n+\t functions.  We have to detect this case specially here to get correct\n+\t flow information.  Note that each element might be either a REG\n+\t or an EXPR_LIST whose first operand is a REG.  */\n+      if (GET_MODE (reg) != BLKmode)\n+\tabort ();\n+\n+      for (i = XVECLEN (reg, 0) - 1; i >= 0; i--)\n+\t{\n+\t  rtx elmt = XVECEXP (reg, 0, i);\n+\n+\t  mark_set_1 (pbi, code,\n+\t\t      GET_CODE (elmt) == EXPR_LIST ? XEXP (elmt, 0) : elmt,\n+\t\t      cond, insn, flags);\n+\t}\n+      return;\n+\n     case ZERO_EXTRACT:\n     case SIGN_EXTRACT:\n     case STRICT_LOW_PART:\n@@ -5964,8 +5971,8 @@ mark_used_regs (pbi, x, cond, insn)\n \t    testreg = XEXP (testreg, 0);\n \t  }\n \n-\t/* If this is a store into a register, recursively scan the\n-\t   value being stored.  */\n+\t/* If this is a store into a register or group of registers,\n+\t   recursively scan the value being stored.  */\n \n \tif ((GET_CODE (testreg) == PARALLEL\n \t     && GET_MODE (testreg) == BLKmode)"}, {"sha": "eec8b6af5016845366255fecde449899b0a641b9", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 34, "deletions": 50, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90d036a050b8443c93a32fc31480e7afefad088f/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90d036a050b8443c93a32fc31480e7afefad088f/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=90d036a050b8443c93a32fc31480e7afefad088f", "patch": "@@ -1182,20 +1182,21 @@ reg_overlap_mentioned_p (x, in)\n \n     case PARALLEL:\n       {\n-\tint i, n;\n-\n-\t/* Check for a NULL entry, used to indicate that the parameter goes\n-\t   both on the stack and in registers.  */\n-\tif (XEXP (XVECEXP (x, 0, 0), 0))\n-\t  i = 0;\n-\telse\n-\t  i = 1;\n+\tint i;\n \n \t/* If any register in here refers to it we return true.  */\n-\tfor (n = XVECLEN (x, 0); i < n; ++i)\n-\t  if (reg_overlap_mentioned_p (XEXP (XVECEXP (x, 0, i), 0), in))\n-\t    return 1;\n-\treturn 0;\n+\tfor (i = XVECLEN (x, 0); i >= 0; i--)\n+\t  {\n+\t    rtx reg = XVECEXP (x, 0, i);\n+\n+\t    if (GET_CODE (reg) == EXPR_LIST)\n+\t      reg = XEXP (reg, 0);\n+\n+\t    if (reg_overlap_mentioned_p (reg, in))\n+\t      return 1;\n+\t    return 0;\n+\t  \n+\t  }\n       }\n \n     default:\n@@ -1270,11 +1271,15 @@ note_stores (x, fun, data)\n      void (*fun) PARAMS ((rtx, rtx, void *));\n      void *data;\n {\n+  int i;\n+\n   if (GET_CODE (x) == COND_EXEC)\n     x = COND_EXEC_CODE (x);\n+\n   if (GET_CODE (x) == SET || GET_CODE (x) == CLOBBER)\n     {\n       register rtx dest = SET_DEST (x);\n+\n       while ((GET_CODE (dest) == SUBREG\n \t      && (GET_CODE (SUBREG_REG (dest)) != REG\n \t\t  || REGNO (SUBREG_REG (dest)) >= FIRST_PSEUDO_REGISTER))\n@@ -1283,48 +1288,27 @@ note_stores (x, fun, data)\n \t     || GET_CODE (dest) == STRICT_LOW_PART)\n \tdest = XEXP (dest, 0);\n \n-      if (GET_CODE (dest) == PARALLEL\n-\t  && GET_MODE (dest) == BLKmode)\n-\t{\n-\t  register int i;\n-\t  for (i = XVECLEN (dest, 0) - 1; i >= 0; i--)\n-\t    (*fun) (SET_DEST (XVECEXP (dest, 0, i)), x, data);\n-\t}\n+      /* If we have a PARALLEL, SET_DEST is a list of registers or\n+\t EXPR_LIST expressions, each of whose first operand is a register.\n+\t We can't know what precisely is being set in these cases, so\n+\t make up a CLOBBER to pass to the function.  */\n+      if (GET_CODE (dest) == PARALLEL && GET_MODE (dest) == BLKmode)\n+\tfor (i = XVECLEN (dest, 0) - 1; i >= 0; i--)\n+\t  {\n+\t    rtx reg = XVECEXP (dest, 0, i);\n+\n+\t    if (GET_CODE (reg) == EXPR_LIST)\n+\t      reg = XEXP (reg, 0);\n+\n+\t    (*fun) (reg, gen_rtx_CLOBBER (VOIDmode, reg), data);\n+\t  }\n       else\n \t(*fun) (dest, x, data);\n     }\n-  else if (GET_CODE (x) == PARALLEL)\n-    {\n-      register int i;\n-      for (i = XVECLEN (x, 0) - 1; i >= 0; i--)\n-\t{\n-\t  register rtx y = XVECEXP (x, 0, i);\n-\t  if (GET_CODE (y) == COND_EXEC)\n-\t    y = COND_EXEC_CODE (y);\n-\t  if (GET_CODE (y) == SET || GET_CODE (y) == CLOBBER)\n-\t    {\n-\t      register rtx dest = SET_DEST (y);\n-\t      while ((GET_CODE (dest) == SUBREG\n-\t\t      && (GET_CODE (SUBREG_REG (dest)) != REG\n-\t\t\t  || (REGNO (SUBREG_REG (dest))\n-\t\t\t      >= FIRST_PSEUDO_REGISTER)))\n-\t\t     || GET_CODE (dest) == ZERO_EXTRACT\n-\t\t     || GET_CODE (dest) == SIGN_EXTRACT\n-\t\t     || GET_CODE (dest) == STRICT_LOW_PART)\n-\t\tdest = XEXP (dest, 0);\n-\t      if (GET_CODE (dest) == PARALLEL\n-\t\t  && GET_MODE (dest) == BLKmode)\n-\t\t{\n-\t\t  register int i;\n \n-\t\t  for (i = XVECLEN (dest, 0) - 1; i >= 0; i--)\n-\t\t    (*fun) (SET_DEST (XVECEXP (dest, 0, i)), y, data);\n-\t\t}\n-\t      else\n-\t\t(*fun) (dest, y, data);\n-\t    }\n-\t}\n-    }\n+  else if (GET_CODE (x) == PARALLEL)\n+    for (i = XVECLEN (x, 0) - 1; i >= 0; i--)\n+      note_stores (XVECEXP (x, 0, i), fun, data);\n }\n \f\n /* Return nonzero if X's old contents don't survive after INSN."}, {"sha": "9b566a0ec2688f88468c8b58f689f38b1a3db196", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90d036a050b8443c93a32fc31480e7afefad088f/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90d036a050b8443c93a32fc31480e7afefad088f/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=90d036a050b8443c93a32fc31480e7afefad088f", "patch": "@@ -551,12 +551,20 @@ sched_analyze_1 (deps, x, insn)\n   if (dest == 0)\n     return;\n \n-  if (GET_CODE (dest) == PARALLEL\n-      && GET_MODE (dest) == BLKmode)\n+  if (GET_CODE (dest) == PARALLEL && GET_MODE (dest) == BLKmode)\n     {\n       register int i;\n+\n       for (i = XVECLEN (dest, 0) - 1; i >= 0; i--)\n-\tsched_analyze_1 (deps, XVECEXP (dest, 0, i), insn);\n+\t{\n+\t  rtx reg = XVECEXP (dest, 0, i);\n+\n+\t  if (GET_CODE (reg) == EXPR_LIST)\n+\t    reg = XEXP (reg, 0);\n+\n+\t  sched_analyze_1 (deps, reg, insn);\n+\t}\n+\n       if (GET_CODE (x) == SET)\n \tsched_analyze_2 (deps, SET_SRC (x), insn);\n       return;"}, {"sha": "71c4018bb1c2621ad14e2e74cb3333b5ccc51f9b", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 29, "deletions": 11, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90d036a050b8443c93a32fc31480e7afefad088f/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90d036a050b8443c93a32fc31480e7afefad088f/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=90d036a050b8443c93a32fc31480e7afefad088f", "patch": "@@ -1396,13 +1396,21 @@ check_live_1 (src, x)\n \t || GET_CODE (reg) == STRICT_LOW_PART)\n     reg = XEXP (reg, 0);\n \n-  if (GET_CODE (reg) == PARALLEL\n-      && GET_MODE (reg) == BLKmode)\n+  if (GET_CODE (reg) == PARALLEL && GET_MODE (reg) == BLKmode)\n     {\n       register int i;\n+\n       for (i = XVECLEN (reg, 0) - 1; i >= 0; i--)\n-\tif (check_live_1 (src, XVECEXP (reg, 0, i)))\n-\t  return 1;\n+\t{\n+\t  rtx dest = XVECEXP (reg, 0, i);\n+\n+\t  if (GET_CODE (dest) == EXPR_LIST)\n+\t    dest = XEXP (dest, 0);\n+\n+\t  if (check_live_1 (src, dest))\n+\t    return 1;\n+\t}\n+\n       return 0;\n     }\n \n@@ -1474,12 +1482,20 @@ update_live_1 (src, x)\n \t || GET_CODE (reg) == STRICT_LOW_PART)\n     reg = XEXP (reg, 0);\n \n-  if (GET_CODE (reg) == PARALLEL\n-      && GET_MODE (reg) == BLKmode)\n+  if (GET_CODE (reg) == PARALLEL && GET_MODE (reg) == BLKmode)\n     {\n       register int i;\n+\n       for (i = XVECLEN (reg, 0) - 1; i >= 0; i--)\n-\tupdate_live_1 (src, XVECEXP (reg, 0, i));\n+\t{\n+\t  rtx dest = XVECEXP (reg, 0, i);\n+\n+\t  if (GET_CODE (dest) == EXPR_LIST)\n+\t    dest = XEXP (dest, 0);\n+\n+\t  update_live_1 (src, dest);\n+\t}\n+\n       return;\n     }\n \n@@ -1915,15 +1931,17 @@ haifa_classify_insn (insn)\n \t      if (tmp_class == TRAP_RISKY)\n \t\tbreak;\n \t      /* Test if it is a load.  */\n-\t      tmp_class =\n-\t\tWORST_CLASS (tmp_class,\n-\t\t\t     may_trap_exp (SET_SRC (XVECEXP (pat, 0, i)), 0));\n+\t      tmp_class\n+\t\t= WORST_CLASS (tmp_class,\n+\t\t\t       may_trap_exp (SET_SRC (XVECEXP (pat, 0, i)),\n+\t\t\t\t\t     0));\n \t      break;\n \t    case COND_EXEC:\n \t    case TRAP_IF:\n \t      tmp_class = TRAP_RISKY;\n \t      break;\n-\t    default:;\n+\t    default:\n+\t      ;\n \t    }\n \t  insn_class = WORST_CLASS (insn_class, tmp_class);\n \t  if (insn_class == TRAP_RISKY || insn_class == IRISKY)"}]}