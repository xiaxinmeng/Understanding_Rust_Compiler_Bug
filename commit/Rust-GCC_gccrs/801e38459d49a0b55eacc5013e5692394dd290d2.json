{"sha": "801e38459d49a0b55eacc5013e5692394dd290d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODAxZTM4NDU5ZDQ5YTBiNTVlYWNjNTAxM2U1NjkyMzk0ZGQyOTBkMg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-13T17:50:45Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-13T17:50:45Z"}, "message": "[AArch64] Testsuite markup for SVE\n\nThis patch adds new target selectors for SVE and updates existing\nselectors accordingly.  It also XFAILs some tests that don't yet\nwork for some SVE modes; most of these go away with follow-on\nvectorisation enhancements.\n\n2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/testsuite/\n\t* lib/target-supports.exp (check_effective_target_aarch64_sve)\n\t(aarch64_sve_bits, check_effective_target_aarch64_sve_hw)\n\t(aarch64_sve_hw_bits, check_effective_target_aarch64_sve256_hw):\n\tNew procedures.\n\t(check_effective_target_vect_perm): Handle SVE.\n\t(check_effective_target_vect_perm_byte): Likewise.\n\t(check_effective_target_vect_perm_short): Likewise.\n\t(check_effective_target_vect_widen_sum_hi_to_si_pattern): Likewise.\n\t(check_effective_target_vect_widen_mult_qi_to_hi): Likewise.\n\t(check_effective_target_vect_widen_mult_hi_to_si): Likewise.\n\t(check_effective_target_vect_element_align_preferred): Likewise.\n\t(check_effective_target_vect_align_stack_vars): Likewise.\n\t(check_effective_target_vect_load_lanes): Likewise.\n\t(check_effective_target_vect_masked_store): Likewise.\n\t(available_vector_sizes): Use aarch64_sve_bits for SVE.\n\t* gcc.dg/vect/tree-vect.h (VECTOR_BITS): Define appropriately\n\tfor SVE.\n\t* gcc.dg/tree-ssa/ssa-dom-cse-2.c: Add SVE XFAIL.\n\t* gcc.dg/vect/bb-slp-pr69907.c: Likewise.\n\t* gcc.dg/vect/no-vfa-vect-depend-2.c: Likewise.\n\t* gcc.dg/vect/no-vfa-vect-depend-3.c: Likewise.\n\t* gcc.dg/vect/slp-23.c: Likewise.\n\t* gcc.dg/vect/slp-perm-5.c: Likewise.\n\t* gcc.dg/vect/slp-perm-6.c: Likewise.\n\t* gcc.dg/vect/slp-perm-9.c: Likewise.\n\t* gcc.dg/vect/slp-reduc-3.c: Likewise.\n\t* gcc.dg/vect/vect-114.c: Likewise.\n\t* gcc.dg/vect/vect-mult-const-pattern-1.c: Likewise.\n\t* gcc.dg/vect/vect-mult-const-pattern-2.c: Likewise.\n\nReviewed-by: James Greenhalgh <james.greenhalgh@arm.com>\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256613", "tree": {"sha": "7f453a85051e7ebbe900827b47163a71d13b505a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7f453a85051e7ebbe900827b47163a71d13b505a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/801e38459d49a0b55eacc5013e5692394dd290d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/801e38459d49a0b55eacc5013e5692394dd290d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/801e38459d49a0b55eacc5013e5692394dd290d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/801e38459d49a0b55eacc5013e5692394dd290d2/comments", "author": null, "committer": null, "parents": [{"sha": "43cacb12fc859b671464b63668794158974b2a34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43cacb12fc859b671464b63668794158974b2a34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43cacb12fc859b671464b63668794158974b2a34"}], "stats": {"total": 195, "additions": 172, "deletions": 23}, "files": [{"sha": "0ad46ee2e4bc0a1c4cd752a75ed3fc3155e8408d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/801e38459d49a0b55eacc5013e5692394dd290d2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/801e38459d49a0b55eacc5013e5692394dd290d2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=801e38459d49a0b55eacc5013e5692394dd290d2", "patch": "@@ -1,3 +1,37 @@\n+2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* lib/target-supports.exp (check_effective_target_aarch64_sve)\n+\t(aarch64_sve_bits, check_effective_target_aarch64_sve_hw)\n+\t(aarch64_sve_hw_bits, check_effective_target_aarch64_sve256_hw):\n+\tNew procedures.\n+\t(check_effective_target_vect_perm): Handle SVE.\n+\t(check_effective_target_vect_perm_byte): Likewise.\n+\t(check_effective_target_vect_perm_short): Likewise.\n+\t(check_effective_target_vect_widen_sum_hi_to_si_pattern): Likewise.\n+\t(check_effective_target_vect_widen_mult_qi_to_hi): Likewise.\n+\t(check_effective_target_vect_widen_mult_hi_to_si): Likewise.\n+\t(check_effective_target_vect_element_align_preferred): Likewise.\n+\t(check_effective_target_vect_align_stack_vars): Likewise.\n+\t(check_effective_target_vect_load_lanes): Likewise.\n+\t(check_effective_target_vect_masked_store): Likewise.\n+\t(available_vector_sizes): Use aarch64_sve_bits for SVE.\n+\t* gcc.dg/vect/tree-vect.h (VECTOR_BITS): Define appropriately\n+\tfor SVE.\n+\t* gcc.dg/tree-ssa/ssa-dom-cse-2.c: Add SVE XFAIL.\n+\t* gcc.dg/vect/bb-slp-pr69907.c: Likewise.\n+\t* gcc.dg/vect/no-vfa-vect-depend-2.c: Likewise.\n+\t* gcc.dg/vect/no-vfa-vect-depend-3.c: Likewise.\n+\t* gcc.dg/vect/slp-23.c: Likewise.\n+\t* gcc.dg/vect/slp-perm-5.c: Likewise.\n+\t* gcc.dg/vect/slp-perm-6.c: Likewise.\n+\t* gcc.dg/vect/slp-perm-9.c: Likewise.\n+\t* gcc.dg/vect/slp-reduc-3.c: Likewise.\n+\t* gcc.dg/vect/vect-114.c: Likewise.\n+\t* gcc.dg/vect/vect-mult-const-pattern-1.c: Likewise.\n+\t* gcc.dg/vect/vect-mult-const-pattern-2.c: Likewise.\n+\n 2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* gcc.dg/vect/no-scevccp-slp-30.c: XFAIL SLP test for"}, {"sha": "7e77a6a0a226262541674bec1d7bdf081e916215", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-cse-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/801e38459d49a0b55eacc5013e5692394dd290d2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-cse-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/801e38459d49a0b55eacc5013e5692394dd290d2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-cse-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-cse-2.c?ref=801e38459d49a0b55eacc5013e5692394dd290d2", "patch": "@@ -25,4 +25,4 @@ foo ()\n    but the loop reads only one element at a time, and DOM cannot resolve these.\n    The same happens on powerpc depending on the SIMD support available.  */\n \n-/* { dg-final { scan-tree-dump \"return 28;\" \"optimized\" { xfail { { alpha*-*-* hppa*64*-*-* nvptx*-*-* } || { lp64 && { powerpc*-*-* sparc*-*-* riscv*-*-* } } } } } } */\n+/* { dg-final { scan-tree-dump \"return 28;\" \"optimized\" { xfail { { alpha*-*-* hppa*64*-*-* nvptx*-*-* } || { { lp64 && { powerpc*-*-* sparc*-*-* riscv*-*-* } } || aarch64_sve } } } } } */"}, {"sha": "85f9a02582f480fc92d4a2b4dea82a358d6e2bb3", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-pr69907.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/801e38459d49a0b55eacc5013e5692394dd290d2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr69907.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/801e38459d49a0b55eacc5013e5692394dd290d2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr69907.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr69907.c?ref=801e38459d49a0b55eacc5013e5692394dd290d2", "patch": "@@ -17,4 +17,6 @@ void foo(unsigned *p1, unsigned short *p2)\n     p1[n] = p2[n * 2];\n }\n \n-/* { dg-final { scan-tree-dump \"BB vectorization with gaps at the end of a load is not supported\" \"slp1\" } } */\n+/* Disable for SVE because for long or variable-length vectors we don't\n+   get an unrolled epilogue loop.  */\n+/* { dg-final { scan-tree-dump \"BB vectorization with gaps at the end of a load is not supported\" \"slp1\" { target { ! aarch64_sve } } } } */"}, {"sha": "acad8fc033268e5bd2728a617dbc61d9e4ae8c48", "filename": "gcc/testsuite/gcc.dg/vect/no-vfa-vect-depend-2.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/801e38459d49a0b55eacc5013e5692394dd290d2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-depend-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/801e38459d49a0b55eacc5013e5692394dd290d2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-depend-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-depend-2.c?ref=801e38459d49a0b55eacc5013e5692394dd290d2", "patch": "@@ -51,4 +51,7 @@ int main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" {xfail { vect_no_align && { ! vect_hw_misalign } } } } } */\n-/* { dg-final { scan-tree-dump-times \"dependence distance negative\" 1 \"vect\"  } } */\n+/* Requires reverse for variable-length SVE, which is implemented for\n+   by a later patch.  Until then we report it twice, once for SVE and\n+   once for 128-bit Advanced SIMD.  */\n+/* { dg-final { scan-tree-dump-times \"dependence distance negative\" 1 \"vect\" { xfail { aarch64_sve && vect_variable_length } } } } */"}, {"sha": "1ccfc1edaccf0805029cbc35f0fe8dbc6a2583ff", "filename": "gcc/testsuite/gcc.dg/vect/no-vfa-vect-depend-3.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/801e38459d49a0b55eacc5013e5692394dd290d2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-depend-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/801e38459d49a0b55eacc5013e5692394dd290d2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-depend-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-depend-3.c?ref=801e38459d49a0b55eacc5013e5692394dd290d2", "patch": "@@ -183,4 +183,7 @@ int main ()\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 4 \"vect\" {xfail { vect_no_align && { ! vect_hw_misalign } } } } } */\n-/* { dg-final { scan-tree-dump-times \"dependence distance negative\" 4 \"vect\"  } } */\n+/* f4 requires reverse for SVE, which is implemented by a later patch.\n+   Until then we report it twice, once for SVE and once for 128-bit\n+   Advanced SIMD.  */\n+/* { dg-final { scan-tree-dump-times \"dependence distance negative\" 4 \"vect\" { xfail { aarch64_sve && vect_variable_length } } } } */"}, {"sha": "88708e645d6bf949947a57dbc02d7aad0b9c17de", "filename": "gcc/testsuite/gcc.dg/vect/slp-23.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/801e38459d49a0b55eacc5013e5692394dd290d2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-23.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/801e38459d49a0b55eacc5013e5692394dd290d2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-23.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-23.c?ref=801e38459d49a0b55eacc5013e5692394dd290d2", "patch": "@@ -107,6 +107,8 @@ int main (void)\n \n /* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" { target { vect_strided8 && { ! { vect_no_align} } } } } } */\n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { ! { vect_strided8 || vect_no_align } } } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { target { ! vect_perm } } } } */\n+/* We fail to vectorize the second loop with variable-length SVE but\n+   fall back to 128-bit vectors, which does use SLP.  */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { target { ! vect_perm } xfail aarch64_sve } } } */\n /* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\" { target vect_perm } } } */\n   "}, {"sha": "e07600841295d4da72c42a1d7da14821591811d1", "filename": "gcc/testsuite/gcc.dg/vect/slp-perm-5.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/801e38459d49a0b55eacc5013e5692394dd290d2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/801e38459d49a0b55eacc5013e5692394dd290d2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-5.c?ref=801e38459d49a0b55eacc5013e5692394dd290d2", "patch": "@@ -104,7 +104,9 @@ int main (int argc, const char* argv[])\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target vect_perm } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\" { target { vect_perm3_int && {! vect_load_lanes } } } } } */\n+/* Fails for variable-length SVE because we fall back to Advanced SIMD\n+   and use LD3/ST3.  Will be fixed when SVE LOAD_LANES support is added.  */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\" { target { vect_perm3_int && {! vect_load_lanes } } xfail { aarch64_sve && vect_variable_length } } } } */\n /* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 0 \"vect\" { target vect_load_lanes } } } */\n /* { dg-final { scan-tree-dump \"note: Built SLP cancelled: can use load/store-lanes\" \"vect\" { target { vect_perm3_int && vect_load_lanes } } } } */\n /* { dg-final { scan-tree-dump \"LOAD_LANES\" \"vect\" { target vect_load_lanes } } } */"}, {"sha": "3ee2b926b5396161bfb773151299cd0462ea2497", "filename": "gcc/testsuite/gcc.dg/vect/slp-perm-6.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/801e38459d49a0b55eacc5013e5692394dd290d2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/801e38459d49a0b55eacc5013e5692394dd290d2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-6.c?ref=801e38459d49a0b55eacc5013e5692394dd290d2", "patch": "@@ -103,7 +103,9 @@ int main (int argc, const char* argv[])\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target vect_perm } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\" { target { vect_perm3_int && {! vect_load_lanes } } } } } */\n+/* Fails for variable-length SVE because we fall back to Advanced SIMD\n+   and use LD3/ST3.  Will be fixed when SVE LOAD_LANES support is added.  */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\" { target { vect_perm3_int && {! vect_load_lanes } } xfail { aarch64_sve && vect_variable_length } } } } */\n /* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { target vect_load_lanes } } } */\n /* { dg-final { scan-tree-dump \"note: Built SLP cancelled: can use load/store-lanes\" \"vect\" { target { vect_perm3_int && vect_load_lanes } } } } */\n /* { dg-final { scan-tree-dump \"LOAD_LANES\" \"vect\" { target vect_load_lanes } } } */"}, {"sha": "f7010799f6c9af1410876e9d7ec421d8daebda62", "filename": "gcc/testsuite/gcc.dg/vect/slp-perm-9.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/801e38459d49a0b55eacc5013e5692394dd290d2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/801e38459d49a0b55eacc5013e5692394dd290d2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-9.c?ref=801e38459d49a0b55eacc5013e5692394dd290d2", "patch": "@@ -57,10 +57,11 @@ int main (int argc, const char* argv[])\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 2 \"vect\" { target { ! { vect_perm_short || vect_load_lanes } } } } } */\n+/* Fails for variable-length SVE because we fall back to Advanced SIMD\n+   and use LD3/ST3.  Will be fixed when SVE LOAD_LANES support is added.  */\n+/* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 2 \"vect\" { target { ! { vect_perm_short || vect_load_lanes } } xfail { aarch64_sve && vect_variable_length } } } } */\n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { vect_perm_short || vect_load_lanes } } } } */\n /* { dg-final { scan-tree-dump-times \"permutation requires at least three vectors\" 1 \"vect\" { target { vect_perm_short && { ! vect_perm3_short } } } } } */\n /* { dg-final { scan-tree-dump-not \"permutation requires at least three vectors\" \"vect\" { target vect_perm3_short } } } */\n /* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 0 \"vect\" { target { { ! vect_perm3_short } || vect_load_lanes } } } } */\n /* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { target { vect_perm3_short && { ! vect_load_lanes } } } } } */\n-"}, {"sha": "34c8da7eac22b82256548238e0fec116835a8b1d", "filename": "gcc/testsuite/gcc.dg/vect/slp-reduc-3.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/801e38459d49a0b55eacc5013e5692394dd290d2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-reduc-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/801e38459d49a0b55eacc5013e5692394dd290d2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-reduc-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-reduc-3.c?ref=801e38459d49a0b55eacc5013e5692394dd290d2", "patch": "@@ -58,4 +58,7 @@ int main (void)\n /* The initialization loop in main also gets vectorized.  */\n /* { dg-final { scan-tree-dump-times \"vect_recog_dot_prod_pattern: detected\" 1 \"vect\" { xfail *-*-* } } } */\n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { target { vect_short_mult && { vect_widen_sum_hi_to_si  && vect_unpack } } } } } */ \n-/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { xfail { vect_widen_sum_hi_to_si_pattern ||  { ! vect_unpack } } } } } */\n+/* We can't yet create the necessary SLP constant vector for variable-length\n+   SVE and so fall back to Advanced SIMD.  This means that we repeat each\n+   analysis note.  */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { xfail { vect_widen_sum_hi_to_si_pattern || { { ! vect_unpack } || { aarch64_sve && vect_variable_length } } } } } } */"}, {"sha": "69c93ac8092b105164a915865a7538c1956dd4df", "filename": "gcc/testsuite/gcc.dg/vect/tree-vect.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/801e38459d49a0b55eacc5013e5692394dd290d2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ftree-vect.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/801e38459d49a0b55eacc5013e5692394dd290d2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ftree-vect.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ftree-vect.h?ref=801e38459d49a0b55eacc5013e5692394dd290d2", "patch": "@@ -76,4 +76,12 @@ check_vect (void)\n   signal (SIGILL, SIG_DFL);\n }\n \n-#define VECTOR_BITS 128\n+#if defined (__ARM_FEATURE_SVE)\n+#  if __ARM_FEATURE_SVE_BITS == 0\n+#    define VECTOR_BITS 1024\n+#  else\n+#    define VECTOR_BITS __ARM_FEATURE_SVE_BITS\n+#  endif\n+#else\n+#  define VECTOR_BITS 128\n+#endif"}, {"sha": "557b44110a095ae725b58cf1ca2494a103b96dd7", "filename": "gcc/testsuite/gcc.dg/vect/vect-114.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/801e38459d49a0b55eacc5013e5692394dd290d2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-114.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/801e38459d49a0b55eacc5013e5692394dd290d2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-114.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-114.c?ref=801e38459d49a0b55eacc5013e5692394dd290d2", "patch": "@@ -34,6 +34,9 @@ int main (void)\n   return main1 ();\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 1 \"vect\" { target { ! { vect_perm  } } } } } */\n+/* Requires reverse for SVE, which is implemented by a later patch.\n+   Until then we fall back to Advanced SIMD and successfully vectorize\n+   the loop.  */\n+/* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 1 \"vect\" { target { ! vect_perm } xfail { aarch64_sve && vect_variable_length } } } } */\n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_perm } } } */\n "}, {"sha": "ee34eea0c3c92380c0ed90b635a5adefc560e17f", "filename": "gcc/testsuite/gcc.dg/vect/vect-mult-const-pattern-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/801e38459d49a0b55eacc5013e5692394dd290d2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-mult-const-pattern-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/801e38459d49a0b55eacc5013e5692394dd290d2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-mult-const-pattern-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-mult-const-pattern-1.c?ref=801e38459d49a0b55eacc5013e5692394dd290d2", "patch": "@@ -37,5 +37,5 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vect_recog_mult_pattern: detected\" 2 \"vect\"  { target aarch64*-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vect_recog_mult_pattern: detected\" 2 \"vect\" { target aarch64*-*-* xfail aarch64_sve } } } */\n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target aarch64*-*-* } } } */"}, {"sha": "fbd6c9065f31e1acaf3a6fdada3bb63dd6b2260b", "filename": "gcc/testsuite/gcc.dg/vect/vect-mult-const-pattern-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/801e38459d49a0b55eacc5013e5692394dd290d2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-mult-const-pattern-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/801e38459d49a0b55eacc5013e5692394dd290d2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-mult-const-pattern-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-mult-const-pattern-2.c?ref=801e38459d49a0b55eacc5013e5692394dd290d2", "patch": "@@ -36,5 +36,5 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vect_recog_mult_pattern: detected\" 2 \"vect\"  { target aarch64*-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vect_recog_mult_pattern: detected\" 2 \"vect\"  { target aarch64*-*-* xfail aarch64_sve } } } */\n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target aarch64*-*-* } } } */"}, {"sha": "f525426eb40034f4dbea17644293016b4970bb2d", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 95, "deletions": 9, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/801e38459d49a0b55eacc5013e5692394dd290d2/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/801e38459d49a0b55eacc5013e5692394dd290d2/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=801e38459d49a0b55eacc5013e5692394dd290d2", "patch": "@@ -3340,6 +3340,35 @@ proc check_effective_target_aarch64_little_endian { } {\n     }]\n }\n \n+# Return 1 if this is an AArch64 target supporting SVE.\n+proc check_effective_target_aarch64_sve { } {\n+    if { ![istarget aarch64*-*-*] } {\n+\treturn 0\n+    }\n+    return [check_no_compiler_messages aarch64_sve assembly {\n+\t#if !defined (__ARM_FEATURE_SVE)\n+\t#error FOO\n+\t#endif\n+    }]\n+}\n+\n+# Return the size in bits of an SVE vector, or 0 if the size is variable.\n+proc aarch64_sve_bits { } {\n+    return [check_cached_effective_target aarch64_sve_bits {\n+\tglobal tool\n+\n+\tset src dummy[pid].c\n+\tset f [open $src \"w\"]\n+\tputs $f \"int bits = __ARM_FEATURE_SVE_BITS;\"\n+\tclose $f\n+\tset output [${tool}_target_compile $src \"\" preprocess \"\"]\n+\tfile delete $src\n+\n+\tregsub {.*bits = ([^;]*);.*} $output {\\1} bits\n+\texpr { $bits }\n+    }]\n+}\n+\n # Return 1 if this is a compiler supporting ARC atomic operations\n proc check_effective_target_arc_atomic { } {\n     return [check_no_compiler_messages arc_atomic assembly {\n@@ -4278,6 +4307,49 @@ proc check_effective_target_arm_neon_hw { } {\n     } [add_options_for_arm_neon \"\"]]\n }\n \n+# Return true if this is an AArch64 target that can run SVE code.\n+\n+proc check_effective_target_aarch64_sve_hw { } {\n+    if { ![istarget aarch64*-*-*] } {\n+\treturn 0\n+    }\n+    return [check_runtime aarch64_sve_hw_available {\n+\tint\n+\tmain (void)\n+\t{\n+\t  asm volatile (\"ptrue p0.b\");\n+\t  return 0;\n+\t}\n+    }]\n+}\n+\n+# Return true if this is an AArch64 target that can run SVE code and\n+# if its SVE vectors have exactly BITS bits.\n+\n+proc aarch64_sve_hw_bits { bits } {\n+    if { ![check_effective_target_aarch64_sve_hw] } {\n+\treturn 0\n+    }\n+    return [check_runtime aarch64_sve${bits}_hw [subst {\n+\tint\n+\tmain (void)\n+\t{\n+\t  int res;\n+\t  asm volatile (\"cntd %0\" : \"=r\" (res));\n+\t  if (res * 64 != $bits)\n+\t    __builtin_abort ();\n+\t  return 0;\n+\t}\n+    }]]\n+}\n+\n+# Return true if this is an AArch64 target that can run SVE code and\n+# if its SVE vectors have exactly 256 bits.\n+\n+proc check_effective_target_aarch64_sve256_hw { } {\n+    return [aarch64_sve_hw_bits 256]\n+}\n+\n proc check_effective_target_arm_neonv2_hw { } {\n     return [check_runtime arm_neon_hwv2_available {\n \t#include \"arm_neon.h\"\n@@ -5579,7 +5651,8 @@ proc check_effective_target_vect_perm { } {\n     } else {\n \tset et_vect_perm_saved($et_index) 0\n         if { [is-effective-target arm_neon]\n-\t     || [istarget aarch64*-*-*]\n+\t     || ([istarget aarch64*-*-*]\n+\t\t && ![check_effective_target_vect_variable_length])\n \t     || [istarget powerpc*-*-*]\n              || [istarget spu-*-*]\n \t     || [istarget i?86-*-*] || [istarget x86_64-*-*]\n@@ -5684,7 +5757,8 @@ proc check_effective_target_vect_perm_byte { } {\n         if { ([is-effective-target arm_neon]\n \t      && [is-effective-target arm_little_endian])\n \t     || ([istarget aarch64*-*-*]\n-\t\t && [is-effective-target aarch64_little_endian])\n+\t\t && [is-effective-target aarch64_little_endian]\n+\t\t && ![check_effective_target_vect_variable_length])\n \t     || [istarget powerpc*-*-*]\n \t     || [istarget spu-*-*]\n \t     || ([istarget mips-*.*]\n@@ -5723,7 +5797,8 @@ proc check_effective_target_vect_perm_short { } {\n         if { ([is-effective-target arm_neon]\n \t      && [is-effective-target arm_little_endian])\n \t     || ([istarget aarch64*-*-*]\n-\t\t && [is-effective-target aarch64_little_endian])\n+\t\t && [is-effective-target aarch64_little_endian]\n+\t\t && ![check_effective_target_vect_variable_length])\n \t     || [istarget powerpc*-*-*]\n \t     || [istarget spu-*-*]\n \t     || ([istarget mips*-*-*]\n@@ -5783,7 +5858,8 @@ proc check_effective_target_vect_widen_sum_hi_to_si_pattern { } {\n     } else {\n \tset et_vect_widen_sum_hi_to_si_pattern_saved($et_index) 0\n         if { [istarget powerpc*-*-*]\n-             || [istarget aarch64*-*-*]\n+             || ([istarget aarch64*-*-*]\n+\t\t && ![check_effective_target_aarch64_sve])\n \t     || [is-effective-target arm_neon]\n              || [istarget ia64-*-*] } {\n \t    set et_vect_widen_sum_hi_to_si_pattern_saved($et_index) 1\n@@ -5895,7 +5971,8 @@ proc check_effective_target_vect_widen_mult_qi_to_hi { } {\n \t    set et_vect_widen_mult_qi_to_hi_saved($et_index) 0\n \t}\n         if { [istarget powerpc*-*-*]\n-              || [istarget aarch64*-*-*]\n+              || ([istarget aarch64*-*-*]\n+\t\t  && ![check_effective_target_aarch64_sve])\n               || [is-effective-target arm_neon]\n \t      || ([istarget s390*-*-*]\n \t\t  && [check_effective_target_s390_vx]) } {\n@@ -5933,7 +6010,8 @@ proc check_effective_target_vect_widen_mult_hi_to_si { } {\n         if { [istarget powerpc*-*-*]\n \t     || [istarget spu-*-*]\n \t     || [istarget ia64-*-*]\n-\t     || [istarget aarch64*-*-*]\n+\t     || ([istarget aarch64*-*-*]\n+\t\t && ![check_effective_target_aarch64_sve])\n \t     || [istarget i?86-*-*] || [istarget x86_64-*-*]\n \t     || [is-effective-target arm_neon]\n \t     || ([istarget s390*-*-*]\n@@ -6420,12 +6498,16 @@ proc check_effective_target_vect_natural_alignment { } {\n # alignment during vectorization.\n \n proc check_effective_target_vect_element_align_preferred { } {\n-    return [check_effective_target_vect_variable_length]\n+    return [expr { [check_effective_target_aarch64_sve]\n+\t\t   && [check_effective_target_vect_variable_length] }]\n }\n \n # Return 1 if we can align stack data to the preferred vector alignment.\n \n proc check_effective_target_vect_align_stack_vars { } {\n+    if { [check_effective_target_aarch64_sve] } {\n+\treturn [check_effective_target_vect_variable_length]\n+    }\n     return 1\n }\n \n@@ -6497,7 +6579,8 @@ proc check_effective_target_vect_load_lanes { } {\n     } else {\n \tset et_vect_load_lanes 0\n \tif { ([istarget arm*-*-*] && [check_effective_target_arm_neon_ok])\n-\t     || [istarget aarch64*-*-*] } {\n+\t     || ([istarget aarch64*-*-*]\n+\t\t && ![check_effective_target_aarch64_sve]) } {\n \t    set et_vect_load_lanes 1\n \t}\n     }\n@@ -6509,7 +6592,7 @@ proc check_effective_target_vect_load_lanes { } {\n # Return 1 if the target supports vector masked stores.\n \n proc check_effective_target_vect_masked_store { } {\n-    return 0\n+    return [check_effective_target_aarch64_sve]\n }\n \n # Return 1 if the target supports vector conditional operations, 0 otherwise.\n@@ -6777,6 +6860,9 @@ foreach N {2 3 4 8} {\n proc available_vector_sizes { } {\n     set result {}\n     if { [istarget aarch64*-*-*] } {\n+\tif { [check_effective_target_aarch64_sve] } {\n+\t    lappend result [aarch64_sve_bits]\n+\t}\n \tlappend result 128 64\n     } elseif { [istarget arm*-*-*]\n \t\t&& [check_effective_target_arm_neon_ok] } {"}]}