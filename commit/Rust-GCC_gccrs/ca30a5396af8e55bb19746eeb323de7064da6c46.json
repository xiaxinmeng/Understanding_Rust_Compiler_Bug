{"sha": "ca30a5396af8e55bb19746eeb323de7064da6c46", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2EzMGE1Mzk2YWY4ZTU1YmIxOTc0NmVlYjMyM2RlNzA2NGRhNmM0Ng==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2008-08-29T16:41:35Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2008-08-29T16:41:35Z"}, "message": "cgraph.c (cgraph_remove_node): Do not remove nested nodes.\n\n\n\t* cgraph.c (cgraph_remove_node): Do not remove nested nodes.\n\n\t* cgraph.h (cgraph_maybe_hot_edge_p): Declare.\n\t* ipa-cp.c (n_cloning_candidates): New static variable.\n\t(ipcp_print_profile_data, ipcp_function_scale_print): Forward declare.\n\t(ipcp_print_all_lattices): Improve debug output.\n\t(ipcp_cloning_candidate_p): New function.\n\t(ipcp_initialize_node_lattices): Use it.\n\t(ipcp_init_stage): Do only analyzis here; prettier debug output.\n\t(ipcp_propagate_stage): Prettier debug output.\n\t(ipcp_iterate_stage): Initialize latices here; prettier debug output.\n\t(ipcp_print_all_structures): Remove.\n\t(ipcp_need_redirect_p): Test !n_cloning_candidates.\n\t(ipcp_insert_stage): Prettier debug output; call\n\tcgraph_remove_unreachable_nodes before propagating.\n\t(pass_ipa_cp): Schedule function removal pass.\n\t* ipa-inline.c (inline_indirect_intraprocedural_analysis): Better\n\tdebug output.\n\t(cgraph_maybe_hot_edge_p): Move to ...\n\t* predict.c (cgraph_maybe_hot_edge_p) ... here.\n\t* opts.c (flag_ipa_cp_set, flag_ipa_cp_clone_set): New.\n\t(common_handle_option): Set them; enable ipa-cp when profiling.\n\t* ipa-prop.c (ipa_print_node_jump_functions): Prettier output.\n\t(ipa_print_all_jump_functions): Likewise.\n\t(ipa_print_all_tree_maps, ipa_print_node_param_flags): Remove.\n\t(ipa_print_node_params, ipa_print_all_params): New.\n\t* ipa-prop.h (ipa_print_all_tree_maps, ipa_print_node_param_flags,\n\tipa_print_all_param_flags): Remove.\n\t(ipa_print_node_params, ipa_print_all_params): New.\n\nFrom-SVN: r139772", "tree": {"sha": "9296bef7d6851c797bb4189695298388ef9bef1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9296bef7d6851c797bb4189695298388ef9bef1d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca30a5396af8e55bb19746eeb323de7064da6c46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca30a5396af8e55bb19746eeb323de7064da6c46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca30a5396af8e55bb19746eeb323de7064da6c46", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca30a5396af8e55bb19746eeb323de7064da6c46/comments", "author": null, "committer": null, "parents": [{"sha": "a1f626ad3b943f90c164f54abb1d3830c8959782", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1f626ad3b943f90c164f54abb1d3830c8959782", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1f626ad3b943f90c164f54abb1d3830c8959782"}], "stats": {"total": 405, "additions": 279, "deletions": 126}, "files": [{"sha": "a808305db83ec99b7c3dd5d44edc131425f998d7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca30a5396af8e55bb19746eeb323de7064da6c46/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca30a5396af8e55bb19746eeb323de7064da6c46/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ca30a5396af8e55bb19746eeb323de7064da6c46", "patch": "@@ -1,3 +1,35 @@\n+2008-08-29  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c (cgraph_remove_node): Do not remove nested nodes.\n+\n+\t* cgraph.h (cgraph_maybe_hot_edge_p): Declare.\n+\t* ipa-cp.c (n_cloning_candidates): New static variable.\n+\t(ipcp_print_profile_data, ipcp_function_scale_print): Forward declare.\n+\t(ipcp_print_all_lattices): Improve debug output.\n+\t(ipcp_cloning_candidate_p): New function.\n+\t(ipcp_initialize_node_lattices): Use it.\n+\t(ipcp_init_stage): Do only analyzis here; prettier debug output.\n+\t(ipcp_propagate_stage): Prettier debug output.\n+\t(ipcp_iterate_stage): Initialize latices here; prettier debug output.\n+\t(ipcp_print_all_structures): Remove.\n+\t(ipcp_need_redirect_p): Test !n_cloning_candidates.\n+\t(ipcp_insert_stage): Prettier debug output; call\n+\tcgraph_remove_unreachable_nodes before propagating.\n+\t(pass_ipa_cp): Schedule function removal pass.\n+\t* ipa-inline.c (inline_indirect_intraprocedural_analysis): Better\n+\tdebug output.\n+\t(cgraph_maybe_hot_edge_p): Move to ...\n+\t* predict.c (cgraph_maybe_hot_edge_p) ... here.\n+\t* opts.c (flag_ipa_cp_set, flag_ipa_cp_clone_set): New.\n+\t(common_handle_option): Set them; enable ipa-cp when profiling.\n+\t* ipa-prop.c (ipa_print_node_jump_functions): Prettier output.\n+\t(ipa_print_all_jump_functions): Likewise.\n+\t(ipa_print_all_tree_maps, ipa_print_node_param_flags): Remove.\n+\t(ipa_print_node_params, ipa_print_all_params): New.\n+\t* ipa-prop.h (ipa_print_all_tree_maps, ipa_print_node_param_flags,\n+\tipa_print_all_param_flags): Remove.\n+\t(ipa_print_node_params, ipa_print_all_params): New.\n+\n 2008-08-29  Bob Wilson  <bob.wilson@acm.org>\n \n \t* config/xtensa/xtensa.c (xtensa_secondary_reload_class): Revert"}, {"sha": "fdc156dfe33a646f58d088c021bd7b50eb169ac4", "filename": "gcc/cgraph.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca30a5396af8e55bb19746eeb323de7064da6c46/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca30a5396af8e55bb19746eeb323de7064da6c46/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=ca30a5396af8e55bb19746eeb323de7064da6c46", "patch": "@@ -857,6 +857,7 @@ cgraph_remove_node (struct cgraph_node *node)\n {\n   void **slot;\n   bool kill_body = false;\n+  struct cgraph_node *n;\n \n   cgraph_call_node_removal_hooks (node);\n   cgraph_node_remove_callers (node);\n@@ -865,8 +866,9 @@ cgraph_remove_node (struct cgraph_node *node)\n   /* Incremental inlining access removed nodes stored in the postorder list.\n      */\n   node->needed = node->reachable = false;\n-  while (node->nested)\n-    cgraph_remove_node (node->nested);\n+  for (n = node->nested; n; n = n->next_nested)\n+    n->origin = NULL;\n+  node->nested = NULL;\n   if (node->origin)\n     {\n       struct cgraph_node **node2 = &node->origin->nested;"}, {"sha": "eec56a5390306d6ad29b8ad7db8579cd484aa33e", "filename": "gcc/cgraph.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca30a5396af8e55bb19746eeb323de7064da6c46/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca30a5396af8e55bb19746eeb323de7064da6c46/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=ca30a5396af8e55bb19746eeb323de7064da6c46", "patch": "@@ -390,6 +390,8 @@ int compute_call_stmt_bb_frequency (basic_block bb);\n bool cgraph_remove_unreachable_nodes (bool, FILE *);\n int cgraph_postorder (struct cgraph_node **);\n \n+bool cgraph_maybe_hot_edge_p (struct cgraph_edge *e);\n+\n /* In varpool.c  */\n \n extern GTY(()) struct varpool_node *varpool_nodes_queue;"}, {"sha": "6c3572dd51e10908d2677e904eeb1069b837850f", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 173, "deletions": 45, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca30a5396af8e55bb19746eeb323de7064da6c46/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca30a5396af8e55bb19746eeb323de7064da6c46/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=ca30a5396af8e55bb19746eeb323de7064da6c46", "patch": "@@ -135,6 +135,21 @@ along with GCC; see the file COPYING3.  If not see\n #include \"fibheap.h\"\n #include \"params.h\"\n \n+/* Number of functions identified as candidates for cloning. When not cloning\n+   we can simplify iterate stage not forcing it to go through the decision\n+   on what is profitable and what not.  */\n+static int n_cloning_candidates;\n+\n+/* Maximal count found in program.  */\n+static gcov_type max_count;\n+\n+/* Cgraph nodes that has been completely replaced by cloning during iterate\n+ * stage and will be removed after ipcp is finished.  */\n+static bitmap dead_nodes;\n+\n+static void ipcp_print_profile_data (FILE *);\n+static void ipcp_function_scale_print (FILE *);\n+\n /* Get the original node field of ipa_node_params associated with node NODE.  */\n static inline struct cgraph_node *\n ipcp_get_orig_node (struct cgraph_node *node)\n@@ -174,7 +189,7 @@ ipcp_analyze_node (struct cgraph_node *node)\n }\n \n /* Recompute all local information since node might've got new\n-   direct calls after clonning.  */\n+   direct calls after cloning.  */\n static void\n ipcp_update_cloned_node (struct cgraph_node *new_node)\n {\n@@ -337,21 +352,21 @@ ipcp_print_all_lattices (FILE * f)\n   struct cgraph_node *node;\n   int i, count;\n \n-  fprintf (f, \"\\nLATTICE PRINT\\n\");\n+  fprintf (f, \"\\nLattice:\\n\");\n   for (node = cgraph_nodes; node; node = node->next)\n     {\n       struct ipa_node_params *info;\n \n       if (!node->analyzed)\n \tcontinue;\n       info = IPA_NODE_REF (node);\n-      fprintf (f, \"Printing lattices %s:\\n\", cgraph_node_name (node));\n+      fprintf (f, \"  Node: %s:\\n\", cgraph_node_name (node));\n       count = ipa_get_param_count (info);\n       for (i = 0; i < count; i++)\n \t{\n \t  struct ipcp_lattice *lat = ipcp_get_ith_lattice (info, i);\n \n-\t  fprintf (f, \" param [%d]: \", i);\n+\t  fprintf (f, \"    param [%d]: \", i);\n \t  if (lat->type == IPA_CONST_VALUE)\n \t    {\n \t      fprintf (f, \"type is CONST \");\n@@ -366,6 +381,100 @@ ipcp_print_all_lattices (FILE * f)\n     }\n }\n \n+/* Return true if this NODE is viable candidate for cloning.  */\n+static bool\n+ipcp_cloning_candidate_p (struct cgraph_node *node)\n+{\n+  int n_calls = 0;\n+  int n_hot_calls = 0;\n+  gcov_type direct_call_sum = 0;\n+  struct cgraph_edge *e;\n+\n+  /* We never clone functions that are not visible from outside.\n+     FIXME: in future we should clone such functions when they are called with\n+     different constants, but current ipcp implementation is not good on this.\n+     */\n+  if (!node->needed || !node->analyzed)\n+    return false;\n+\n+  if (cgraph_function_body_availability (node) <= AVAIL_OVERWRITABLE)\n+    {\n+      if (dump_file)\n+        fprintf (dump_file, \"Not considering %s for cloning; body is overwrittable.\\n\",\n+ \t         cgraph_node_name (node));\n+      return false;\n+    }\n+  if (!tree_versionable_function_p (node->decl))\n+    {\n+      if (dump_file)\n+        fprintf (dump_file, \"Not considering %s for cloning; body is not versionable.\\n\",\n+ \t         cgraph_node_name (node));\n+      return false;\n+    }\n+  for (e = node->callers; e; e = e->next_caller)\n+    {\n+      direct_call_sum += e->count;\n+      n_calls ++;\n+      if (cgraph_maybe_hot_edge_p (e))\n+\tn_hot_calls ++;\n+    }\n+  \n+  if (!n_calls)\n+    {\n+      if (dump_file)\n+        fprintf (dump_file, \"Not considering %s for cloning; no direct calls.\\n\",\n+ \t         cgraph_node_name (node));\n+      return false;\n+    }\n+  if (node->local.inline_summary.self_insns < n_calls)\n+    {\n+      if (dump_file)\n+        fprintf (dump_file, \"Considering %s for cloning; code would shrink.\\n\",\n+ \t         cgraph_node_name (node));\n+      return true;\n+    }  \n+\n+  if (!flag_ipa_cp_clone)\n+    {\n+      if (dump_file)\n+        fprintf (dump_file, \"Not considering %s for cloning; -fipa-cp-clone disabled.\\n\",\n+ \t         cgraph_node_name (node));\n+      return false;\n+    }\n+\n+  if (!optimize_function_for_speed_p (DECL_STRUCT_FUNCTION (node->decl)))\n+    {\n+      if (dump_file)\n+        fprintf (dump_file, \"Not considering %s for cloning; optimizing it for size.\\n\",\n+ \t         cgraph_node_name (node));\n+      return false;\n+    }\n+\n+  /* When profile is available and function is hot, propagate into it even if\n+     calls seems cold; constant propagation can improve function's speed\n+     significandly.  */\n+  if (max_count)\n+    {\n+      if (direct_call_sum > node->count * 90 / 100)\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Considering %s for cloning; usually called directly.\\n\",\n+\t\t     cgraph_node_name (node));\n+\t  return true;\n+        }\n+    }\n+  if (!n_hot_calls)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"Not considering %s for cloning; no hot calls.\\n\",\n+\t\t cgraph_node_name (node));\n+    }\n+  if (dump_file)\n+    fprintf (dump_file, \"Considering %s for cloning.\\n\",\n+\t     cgraph_node_name (node));\n+  return true;\n+}\n+\n /* Initialize ipcp_lattices array.  The lattices corresponding to supported\n    types (integers, real types and Fortran constants defined as const_decls)\n    are initialized to IPA_TOP, the rest of them to IPA_BOTTOM.  */\n@@ -374,18 +483,24 @@ ipcp_initialize_node_lattices (struct cgraph_node *node)\n {\n   int i;\n   struct ipa_node_params *info = IPA_NODE_REF (node);\n+  enum ipa_lattice_type type;\n \n   info->ipcp_lattices = XCNEWVEC (struct ipcp_lattice,\n \t\t\t\t  ipa_get_param_count (info));\n   \n+  if (ipa_is_called_with_var_arguments (info))\n+    type = IPA_BOTTOM;\n+  else if (!node->needed)\n+    type = IPA_TOP;\n   /* When cloning is allowed, we can assume that externally visible functions\n      are not called.  We will compensate this by cloning later.  */\n-  if (flag_ipa_cp_clone || !node->needed)\n-    for (i = 0; i < ipa_get_param_count (info) ; i++)\n-      ipcp_get_ith_lattice (info, i)->type = IPA_TOP;\n+  else if (ipcp_cloning_candidate_p (node))\n+    type = IPA_TOP, n_cloning_candidates ++;\n   else\n-    for (i = 0; i < ipa_get_param_count (info) ; i++)\n-      ipcp_get_ith_lattice (info, i)->type = IPA_BOTTOM;\n+    type = IPA_BOTTOM;\n+\n+  for (i = 0; i < ipa_get_param_count (info) ; i++)\n+    ipcp_get_ith_lattice (info, i)->type = type;\n }\n \n /* build INTEGER_CST tree with type TREE_TYPE and value according to LAT.\n@@ -438,11 +553,7 @@ ipcp_init_stage (void)\n \n   for (node = cgraph_nodes; node; node = node->next)\n     if (node->analyzed)\n-      {\n-        ipcp_analyze_node (node);\n-        ipcp_initialize_node_lattices (node);\n-        ipcp_compute_node_scale (node);\n-      }\n+      ipcp_analyze_node (node);\n   for (node = cgraph_nodes; node; node = node->next)\n     {\n       if (!node->analyzed)\n@@ -489,6 +600,13 @@ ipcp_change_tops_to_bottom (void)\n \t  if (lat->type == IPA_TOP)\n \t    {\n \t      prop_again = true;\n+\t      if (dump_file)\n+\t\t{\n+\t\t  fprintf (dump_file, \"Forcing param \");\n+\t\t  print_generic_expr (dump_file, ipa_get_ith_param (info, i), 0);\n+\t\t  fprintf (dump_file, \" of node %s to bottom.\\n\",\n+\t\t\t   cgraph_node_name (node));\n+\t\t}\n \t      lat->type = IPA_BOTTOM;\n \t    }\n \t}\n@@ -512,6 +630,7 @@ ipcp_propagate_stage (void)\n \n   ipa_check_create_node_params ();\n   ipa_check_create_edge_args ();\n+\n   /* Initialize worklist to contain all functions.  */\n   wl = ipa_init_func_list ();\n   while (wl)\n@@ -550,11 +669,37 @@ ipcp_propagate_stage (void)\n static void\n ipcp_iterate_stage (void)\n {\n+  struct cgraph_node *node;\n+  n_cloning_candidates = 0;\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"\\nIPA iterate stage:\\n\\n\");\n+  for (node = cgraph_nodes; node; node = node->next)\n+    {\n+      ipcp_initialize_node_lattices (node);\n+      ipcp_compute_node_scale (node);\n+    }\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      ipcp_print_all_lattices (dump_file);\n+      ipcp_function_scale_print (dump_file);\n+    }\n+\n   ipcp_propagate_stage ();\n   if (ipcp_change_tops_to_bottom ())\n     /* Some lattices have changed from IPA_TOP to IPA_BOTTOM.\n        This change should be propagated.  */\n-    ipcp_propagate_stage ();\n+    {\n+      gcc_assert (n_cloning_candidates);\n+      ipcp_propagate_stage ();\n+    }\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"\\nIPA lattices after propagation:\\n\");\n+      ipcp_print_all_lattices (dump_file);\n+      if (dump_flags & TDF_DETAILS)\n+        ipcp_print_profile_data (dump_file);\n+    }\n }\n \n /* Check conditions to forbid constant insertion to function described by\n@@ -708,17 +853,6 @@ ipcp_print_bb_profiles (FILE * f)\n     }\n }\n \n-/* Print all IPCP data structures to F.  */\n-static void\n-ipcp_print_all_structures (FILE * f)\n-{\n-  ipcp_print_all_lattices (f);\n-  ipcp_function_scale_print (f);\n-  ipa_print_all_tree_maps (f);\n-  ipa_print_all_param_flags (f);\n-  ipa_print_all_jump_functions (f);\n-}\n-\n /* Print profile info for all functions.  */\n static void\n ipcp_print_profile_data (FILE * f)\n@@ -771,7 +905,7 @@ ipcp_need_redirect_p (struct cgraph_edge *cs)\n   struct ipa_jump_func *jump_func;\n   struct cgraph_node *node = cs->callee, *orig;\n \n-  if (!flag_ipa_cp_clone)\n+  if (!n_cloning_candidates)\n     return false;\n \n   if ((orig = ipcp_get_orig_node (node)) != NULL)\n@@ -908,10 +1042,6 @@ ipcp_update_profiling (void)\n     }\n }\n \n-/* Maximal count found in program.  */\n-static gcov_type max_count;\n-bitmap dead_nodes;\n-\n /* Return true if original clone needs to be preserved.  */\n static bool\n ipcp_need_original_clone_p (struct cgraph_node *node)\n@@ -1008,6 +1138,8 @@ ipcp_insert_stage (void)\n \n   ipa_check_create_node_params ();\n   ipa_check_create_edge_args ();\n+  if (dump_file)\n+    fprintf (dump_file, \"\\nIPA insert stage:\\n\\n\");\n \n   dead_nodes = BITMAP_ALLOC (NULL);\n \n@@ -1156,18 +1288,19 @@ ipcp_insert_stage (void)\n static unsigned int\n ipcp_driver (void)\n {\n-  /* 2. Do the interprocedural propagation.  */\n-  ipcp_iterate_stage ();\n+  cgraph_remove_unreachable_nodes (true,dump_file);\n   if (dump_file)\n     {\n-      fprintf (dump_file, \"\\nIPA structures after propagation:\\n\");\n-      ipcp_print_all_structures (dump_file);\n-      fprintf (dump_file, \"\\nProfiling info before insert stage:\\n\");\n-      ipcp_print_profile_data (dump_file);\n+      fprintf (dump_file, \"\\nIPA structures before propagation:\\n\");\n+      if (dump_flags & TDF_DETAILS)\n+        ipa_print_all_params (dump_file);\n+      ipa_print_all_jump_functions (dump_file);\n     }\n+  /* 2. Do the interprocedural propagation.  */\n+  ipcp_iterate_stage ();\n   /* 3. Insert the constants found to the functions.  */\n   ipcp_insert_stage ();\n-  if (dump_file)\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"\\nProfiling info after insert stage:\\n\");\n       ipcp_print_profile_data (dump_file);\n@@ -1176,7 +1309,6 @@ ipcp_driver (void)\n   free_all_ipa_structures_after_ipa_cp ();\n   if (dump_file)\n     fprintf (dump_file, \"\\nIPA constant propagation end\\n\");\n-  cgraph_remove_unreachable_nodes (true, NULL);\n   return 0;\n }\n \n@@ -1192,11 +1324,6 @@ ipcp_generate_summary (void)\n   /* 1. Call the init stage to initialize \n      the ipa_node_params and ipa_edge_args structures.  */\n   ipcp_init_stage ();\n-  if (dump_file)\n-    {\n-      fprintf (dump_file, \"\\nIPA structures before propagation:\\n\");\n-      ipcp_print_all_structures (dump_file);\n-    }\n }\n \n /* Gate for IPCP optimization.  */\n@@ -1221,7 +1348,8 @@ struct ipa_opt_pass pass_ipa_cp =\n   PROP_trees,\t\t\t/* properties_provided */\n   0,\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t/* todo_flags_start */\n-  TODO_dump_cgraph | TODO_dump_func\t/* todo_flags_finish */\n+  TODO_dump_cgraph | TODO_dump_func |\n+  TODO_remove_functions /* todo_flags_finish */\n  },\n  ipcp_generate_summary,\t\t\t/* generate_summary */\n  NULL,\t\t\t\t\t/* write_summary */"}, {"sha": "a85a8a3be6b0562fefe566dc473a7d536d38b961", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 4, "deletions": 24, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca30a5396af8e55bb19746eeb323de7064da6c46/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca30a5396af8e55bb19746eeb323de7064da6c46/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=ca30a5396af8e55bb19746eeb323de7064da6c46", "patch": "@@ -468,26 +468,6 @@ cgraph_recursive_inlining_p (struct cgraph_node *to,\n   return recursive;\n }\n \n-/* Return true if the call can be hot.  */\n-static bool\n-cgraph_maybe_hot_edge_p (struct cgraph_edge *edge)\n-{\n-  if (profile_info && flag_branch_probabilities\n-      && (edge->count\n-\t  <= profile_info->sum_max / PARAM_VALUE (HOT_BB_COUNT_FRACTION)))\n-    return false;\n-  if (lookup_attribute (\"cold\", DECL_ATTRIBUTES (edge->callee->decl))\n-      || lookup_attribute (\"cold\", DECL_ATTRIBUTES (edge->caller->decl)))\n-    return false;\n-  if (lookup_attribute (\"hot\", DECL_ATTRIBUTES (edge->caller->decl)))\n-    return true;\n-  if (flag_guess_branch_prob\n-      && edge->frequency < (CGRAPH_FREQ_MAX\n-      \t\t\t    / PARAM_VALUE (HOT_BB_FREQUENCY_FRACTION)))\n-    return false;\n-  return true;\n-}\n-\n /* A cost model driving the inlining heuristics in a way so the edges with\n    smallest badness are inlined first.  After each inlining is performed\n    the costs of all caller edges of nodes affected are recomputed so the\n@@ -1646,9 +1626,6 @@ inline_indirect_intraprocedural_analysis (struct cgraph_node *node)\n     }\n   ipa_analyze_params_uses (node);\n \n-  if (dump_file)\n-    ipa_print_node_param_flags (dump_file, node);\n-\n   if (!flag_ipa_cp)\n     for (cs = node->callees; cs; cs = cs->next_callee)\n       {\n@@ -1657,7 +1634,10 @@ inline_indirect_intraprocedural_analysis (struct cgraph_node *node)\n       }\n \n   if (dump_file)\n-    ipa_print_node_jump_functions (dump_file, node);\n+    {\n+      ipa_print_node_params (dump_file, node);\n+      ipa_print_node_jump_functions (dump_file, node);\n+    }\n }\n \n /* Note function body size.  */"}, {"sha": "ffbf3adb668a7b6fadd308a380db30bd483c17c5", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 14, "deletions": 39, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca30a5396af8e55bb19746eeb323de7064da6c46/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca30a5396af8e55bb19746eeb323de7064da6c46/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=ca30a5396af8e55bb19746eeb323de7064da6c46", "patch": "@@ -255,13 +255,13 @@ ipa_print_node_jump_functions (FILE *f, struct cgraph_node *node)\n   struct ipa_jump_func *jump_func;\n   enum jump_func_type type;\n \n-  fprintf (f, \"JUMP FUNCTIONS OF CALLER  %s:\\n\", cgraph_node_name (node));\n+  fprintf (f, \"  Jump functions of caller  %s:\\n\", cgraph_node_name (node));\n   for (cs = node->callees; cs; cs = cs->next_callee)\n     {\n       if (!ipa_edge_args_info_available_for_edge_p (cs))\n \tcontinue;\n \n-      fprintf (f, \"callsite  %s \", cgraph_node_name (node));\n+      fprintf (f, \"    callsite  %s \", cgraph_node_name (node));\n       fprintf (f, \"-> %s :: \\n\", cgraph_node_name (cs->callee));\n \n       count = ipa_get_cs_argument_count (IPA_EDGE_REF (cs));\n@@ -270,7 +270,7 @@ ipa_print_node_jump_functions (FILE *f, struct cgraph_node *node)\n \t  jump_func = ipa_get_ith_jump_func (IPA_EDGE_REF (cs), i);\n \t  type = jump_func->type;\n \n-\t  fprintf (f, \"  param %d: \", i);\n+\t  fprintf (f, \"       param %d: \", i);\n \t  if (type == IPA_UNKNOWN)\n \t    fprintf (f, \"UNKNOWN\\n\");\n \t  else if (type == IPA_CONST)\n@@ -303,7 +303,7 @@ ipa_print_all_jump_functions (FILE *f)\n {\n   struct cgraph_node *node;\n \n-  fprintf (f, \"\\nCALLSITE PARAM PRINT\\n\");\n+  fprintf (f, \"\\nJump functions:\\n\");\n   for (node = cgraph_nodes; node; node = node->next)\n     {\n       ipa_print_node_jump_functions (f, node);\n@@ -1207,48 +1207,23 @@ free_all_ipa_structures_after_iinln (void)\n /* Print ipa_tree_map data structures of all functions in the\n    callgraph to F.  */\n void\n-ipa_print_all_tree_maps (FILE * f)\n+ipa_print_node_params (FILE * f, struct cgraph_node *node)\n {\n   int i, count;\n   tree temp;\n-  struct cgraph_node *node;\n-\n-  fprintf (f, \"\\nPARAM TREE MAP PRINT\\n\");\n-  for (node = cgraph_nodes; node; node = node->next)\n-    {\n-      struct ipa_node_params *info;\n-\n-      if (!node->analyzed)\n-\tcontinue;\n-      info = IPA_NODE_REF (node);\n-      fprintf (f, \"function  %s Trees :: \\n\", cgraph_node_name (node));\n-      count = ipa_get_param_count (info);\n-      for (i = 0; i < count; i++)\n-\t{\n-\t  temp = ipa_get_ith_param (info, i);\n-\t  if (TREE_CODE (temp) == PARM_DECL)\n-\t    fprintf (f, \"  param [%d] : %s\\n\", i,\n-\t\t     (*lang_hooks.decl_printable_name) (temp, 2));\n-\t}\n-\n-    }\n-}\n-\n-/* Print param_flags data structures of the NODE to F.  */\n-void\n-ipa_print_node_param_flags (FILE * f, struct cgraph_node *node)\n-{\n-  int i, count;\n   struct ipa_node_params *info;\n \n   if (!node->analyzed)\n     return;\n   info = IPA_NODE_REF (node);\n-  fprintf (f, \"PARAM FLAGS of function  %s: \\n\", cgraph_node_name (node));\n+  fprintf (f, \"  function  %s Trees :: \\n\", cgraph_node_name (node));\n   count = ipa_get_param_count (info);\n   for (i = 0; i < count; i++)\n     {\n-      fprintf (f, \"   param %d flags:\", i);\n+      temp = ipa_get_ith_param (info, i);\n+      if (TREE_CODE (temp) == PARM_DECL)\n+\tfprintf (f, \"    param %d : %s\", i,\n+\t\t (*lang_hooks.decl_printable_name) (temp, 2));\n       if (ipa_is_ith_param_modified (info, i))\n \tfprintf (f, \" modified\");\n       if (ipa_is_ith_param_called (info, i))\n@@ -1257,14 +1232,14 @@ ipa_print_node_param_flags (FILE * f, struct cgraph_node *node)\n     }\n }\n \n-/* Print param_flags data structures of all functions in the\n+/* Print ipa_tree_map data structures of all functions in the\n    callgraph to F.  */\n void\n-ipa_print_all_param_flags (FILE * f)\n+ipa_print_all_params (FILE * f)\n {\n   struct cgraph_node *node;\n \n-  fprintf (f, \"\\nIPA PARAM FLAGS DUMP\\n\");\n+  fprintf (f, \"\\nFunction parameters:\\n\");\n   for (node = cgraph_nodes; node; node = node->next)\n-    ipa_print_node_param_flags (f, node);\n+    ipa_print_node_params (f, node);\n }"}, {"sha": "80b591bc2f83a6f07e42788dad21055ca72dfa03", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca30a5396af8e55bb19746eeb323de7064da6c46/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca30a5396af8e55bb19746eeb323de7064da6c46/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=ca30a5396af8e55bb19746eeb323de7064da6c46", "patch": "@@ -381,9 +381,8 @@ void ipa_propagate_indirect_call_infos (struct cgraph_edge *cs,\n \t\t\t\t\tVEC (cgraph_edge_p, heap) *new_edges);\n \n /* Debugging interface.  */\n-void ipa_print_all_tree_maps (FILE *);\n-void ipa_print_node_param_flags (FILE * f, struct cgraph_node *node);\n-void ipa_print_all_param_flags (FILE *);\n+void ipa_print_node_params (FILE *, struct cgraph_node *node);\n+void ipa_print_all_params (FILE *);\n void ipa_print_node_jump_functions (FILE *f, struct cgraph_node *node);\n void ipa_print_all_jump_functions (FILE * f);\n "}, {"sha": "fbe67569c2d8756f8c2db1aaf9e929efb068d09a", "filename": "gcc/opts.c", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca30a5396af8e55bb19746eeb323de7064da6c46/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca30a5396af8e55bb19746eeb323de7064da6c46/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=ca30a5396af8e55bb19746eeb323de7064da6c46", "patch": "@@ -347,7 +347,7 @@ static bool profile_arc_flag_set, flag_profile_values_set;\n static bool flag_unroll_loops_set, flag_tracer_set;\n static bool flag_value_profile_transformations_set;\n static bool flag_peel_loops_set, flag_branch_probabilities_set;\n-static bool flag_inline_functions_set;\n+static bool flag_inline_functions_set, flag_ipa_cp_set, flag_ipa_cp_clone_set;\n \n /* Functions excluded from profiling.  */\n \n@@ -1031,9 +1031,6 @@ decode_options (unsigned int argc, const char **argv)\n \n       /* We want to crossjump as much as possible.  */\n       set_param_value (\"min-crossjump-insns\", 1);\n-\n-      /* Do not perform clonning in ipcp.  */\n-      flag_ipa_cp_clone = 0;\n     }\n   else\n     set_param_value (\"min-crossjump-insns\", initial_min_crossjump_insns);\n@@ -1837,6 +1834,11 @@ common_handle_option (size_t scode, const char *arg, int value,\n         flag_value_profile_transformations = value;\n       if (!flag_inline_functions_set)\n         flag_inline_functions = value;\n+      if (!flag_ipa_cp_set)\n+        flag_ipa_cp = value;\n+      if (!flag_ipa_cp_clone_set\n+\t  && value && flag_ipa_cp)\n+\tflag_ipa_cp_clone = value;\n       break;\n \n     case OPT_fprofile_generate_:\n@@ -1994,6 +1996,14 @@ common_handle_option (size_t scode, const char *arg, int value,\n       flag_tracer_set = true;\n       break;\n \n+    case OPT_fipa_cp:\n+      flag_ipa_cp_set = true;\n+      break;\n+\n+    case OPT_fipa_cp_clone:\n+      flag_ipa_cp_clone_set = true;\n+      break;\n+\n     case OPT_funroll_loops:\n       flag_unroll_loops_set = true;\n       break;"}, {"sha": "4e17b9ac676146f0ae0452fef50604850f96265d", "filename": "gcc/predict.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca30a5396af8e55bb19746eeb323de7064da6c46/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca30a5396af8e55bb19746eeb323de7064da6c46/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=ca30a5396af8e55bb19746eeb323de7064da6c46", "patch": "@@ -138,6 +138,27 @@ maybe_hot_bb_p (const_basic_block bb)\n   return maybe_hot_frequency_p (bb->frequency);\n }\n \n+/* Return true if the call can be hot.  */\n+\n+bool\n+cgraph_maybe_hot_edge_p (struct cgraph_edge *edge)\n+{\n+  if (profile_info && flag_branch_probabilities\n+      && (edge->count\n+\t  <= profile_info->sum_max / PARAM_VALUE (HOT_BB_COUNT_FRACTION)))\n+    return false;\n+  if (lookup_attribute (\"cold\", DECL_ATTRIBUTES (edge->callee->decl))\n+      || lookup_attribute (\"cold\", DECL_ATTRIBUTES (edge->caller->decl)))\n+    return false;\n+  if (lookup_attribute (\"hot\", DECL_ATTRIBUTES (edge->caller->decl)))\n+    return true;\n+  if (flag_guess_branch_prob\n+      && edge->frequency < (CGRAPH_FREQ_MAX\n+      \t\t\t    / PARAM_VALUE (HOT_BB_FREQUENCY_FRACTION)))\n+    return false;\n+  return true;\n+}\n+\n /* Return true in case BB can be CPU intensive and should be optimized\n    for maximal performance.  */\n "}, {"sha": "2aa360a9a09dd1e3d7b45d1dd980f966e4767fce", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca30a5396af8e55bb19746eeb323de7064da6c46/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca30a5396af8e55bb19746eeb323de7064da6c46/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ca30a5396af8e55bb19746eeb323de7064da6c46", "patch": "@@ -1,3 +1,7 @@\n+2008-08-29  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.dg/ipa/modif-1.c: Update template.\n+\n 2008-08-29  Jan Hubicka  <jh@suse.cz>\n \n \t* gcc.dg/ipa/ipa-1.c: Fix template for better debug output."}, {"sha": "bc1706c56506d1a5ce181b1df8849eec727d67d9", "filename": "gcc/testsuite/gcc.dg/ipa/modif-1.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca30a5396af8e55bb19746eeb323de7064da6c46/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fmodif-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca30a5396af8e55bb19746eeb323de7064da6c46/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fmodif-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fmodif-1.c?ref=ca30a5396af8e55bb19746eeb323de7064da6c46", "patch": "@@ -1,6 +1,6 @@\n /* Verify that modification analysis detects modfications.  */\n /* { dg-do compile } */\n-/* { dg-options \"-O3 -c -fdump-ipa-inline -fno-early-inlining\"  } */\n+/* { dg-options \"-O3 -c -fdump-ipa-inline-details -fno-early-inlining\"  } */\n \n struct whatever\n {\n@@ -33,12 +33,12 @@ void the_test (struct whatever u, struct whatever v,\n   func4 (&l);\n }\n \n-/* { dg-final { scan-ipa-dump-not \"param 0 flags:\\[^\\\\n\\]*modified\" \"inline\" } } */\n-/* { dg-final { scan-ipa-dump \"param 1 flags:\\[^\\\\n\\]*modified\" \"inline\" } } */\n-/* { dg-final { scan-ipa-dump \"param 2 flags:\\[^\\\\n\\]*modified\" \"inline\" } } */\n-/* { dg-final { scan-ipa-dump \"param 3 flags:\\[^\\\\n\\]*modified\" \"inline\" } } */\n-/* { dg-final { scan-ipa-dump-not \"param 4 flags:\\[^\\\\n\\]*modified\" \"inline\" } } */\n-/* { dg-final { scan-ipa-dump \"param 5 flags:\\[^\\\\n\\]*modified\" \"inline\" } } */\n-/* { dg-final { scan-ipa-dump \"param 6 flags:\\[^\\\\n\\]*modified\" \"inline\" } } */\n-/* { dg-final { scan-ipa-dump \"param 7 flags:\\[^\\\\n\\]*modified\" \"inline\" } } */\n+/* { dg-final { scan-ipa-dump-not \"param 0\\[^\\\\n\\]*modified\" \"inline\" } } */\n+/* { dg-final { scan-ipa-dump \"param 1\\[^\\\\n\\]*modified\" \"inline\" } } */\n+/* { dg-final { scan-ipa-dump \"param 2\\[^\\\\n\\]*modified\" \"inline\" } } */\n+/* { dg-final { scan-ipa-dump \"param 3\\[^\\\\n\\]*modified\" \"inline\" } } */\n+/* { dg-final { scan-ipa-dump-not \"param 4\\[^\\\\n\\]*modified\" \"inline\" } } */\n+/* { dg-final { scan-ipa-dump \"param 5\\[^\\\\n\\]*modified\" \"inline\" } } */\n+/* { dg-final { scan-ipa-dump \"param 6\\[^\\\\n\\]*modified\" \"inline\" } } */\n+/* { dg-final { scan-ipa-dump \"param 7\\[^\\\\n\\]*modified\" \"inline\" } } */\n /* { dg-final { cleanup-ipa-dump \"inline\" } } */"}]}