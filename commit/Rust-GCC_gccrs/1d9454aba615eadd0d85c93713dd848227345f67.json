{"sha": "1d9454aba615eadd0d85c93713dd848227345f67", "node_id": "C_kwDOANBUbNoAKDFkOTQ1NGFiYTYxNWVhZGQwZDg1YzkzNzEzZGQ4NDgyMjczNDVmNjc", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-10-18T20:20:06Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-11-13T01:10:44Z"}, "message": "libstdc++: Implement C++20 <format> [PR104166]\n\nThis doesn't add the newer C++23 features like formatting ranges\nand escaped string prsentation types.\n\nHowever, C++23 extended floating-point types are supported, as are\n128-bit integers.\n\nIt could do with more tests.\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/104166\n\t* include/Makefile.am (std_headers): Add <format>.\n\t* include/Makefile.in: Regenerate.\n\t* include/precompiled/stdc++.h: Add <format>.\n\t* include/std/format: New file.\n\t* python/libstdcxx/v6/printers.py (StdFormatArgsPrinter): New\n\tprinter for std::format_args.\n\t* testsuite/std/format/arguments/args.cc: New test.\n\t* testsuite/std/format/error.cc: New test.\n\t* testsuite/std/format/formatter.cc: New test.\n\t* testsuite/std/format/functions/format.cc: New test.\n\t* testsuite/std/format/functions/format_to_n.cc: New test.\n\t* testsuite/std/format/functions/size.cc: New test.\n\t* testsuite/std/format/functions/vformat_to.cc: New test.\n\t* testsuite/std/format/parse_ctx.cc: New test.\n\t* testsuite/std/format/string.cc: New test.\n\t* testsuite/std/format/string_neg.cc: New test.", "tree": {"sha": "f2b2f1e038a1fe90ea5b4058dec236d47c26c991", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f2b2f1e038a1fe90ea5b4058dec236d47c26c991"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1d9454aba615eadd0d85c93713dd848227345f67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d9454aba615eadd0d85c93713dd848227345f67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d9454aba615eadd0d85c93713dd848227345f67", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d9454aba615eadd0d85c93713dd848227345f67/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4ba3b369cbe9bce0a1212670825ecfb99762520", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4ba3b369cbe9bce0a1212670825ecfb99762520", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4ba3b369cbe9bce0a1212670825ecfb99762520"}], "stats": {"total": 5191, "additions": 5191, "deletions": 0}, "files": [{"sha": "27dfa2be2f39d4e1e8897e0bbf02c59dc941133f", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d9454aba615eadd0d85c93713dd848227345f67/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d9454aba615eadd0d85c93713dd848227345f67/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=1d9454aba615eadd0d85c93713dd848227345f67", "patch": "@@ -68,6 +68,7 @@ std_headers = \\\n \t${std_srcdir}/deque \\\n \t${std_srcdir}/execution \\\n \t${std_srcdir}/filesystem \\\n+\t${std_srcdir}/format \\\n \t${std_srcdir}/forward_list \\\n \t${std_srcdir}/fstream \\\n \t${std_srcdir}/future \\"}, {"sha": "64621922f779904dd63513ea41b40fd3711cb557", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d9454aba615eadd0d85c93713dd848227345f67/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d9454aba615eadd0d85c93713dd848227345f67/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=1d9454aba615eadd0d85c93713dd848227345f67", "patch": "@@ -424,6 +424,7 @@ std_freestanding = \\\n @GLIBCXX_HOSTED_TRUE@\t${std_srcdir}/deque \\\n @GLIBCXX_HOSTED_TRUE@\t${std_srcdir}/execution \\\n @GLIBCXX_HOSTED_TRUE@\t${std_srcdir}/filesystem \\\n+@GLIBCXX_HOSTED_TRUE@\t${std_srcdir}/format \\\n @GLIBCXX_HOSTED_TRUE@\t${std_srcdir}/forward_list \\\n @GLIBCXX_HOSTED_TRUE@\t${std_srcdir}/fstream \\\n @GLIBCXX_HOSTED_TRUE@\t${std_srcdir}/future \\"}, {"sha": "b447feb844f91bde5c365c4007cb50a32dc1c767", "filename": "libstdc++-v3/include/precompiled/stdc++.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d9454aba615eadd0d85c93713dd848227345f67/libstdc%2B%2B-v3%2Finclude%2Fprecompiled%2Fstdc%2B%2B.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d9454aba615eadd0d85c93713dd848227345f67/libstdc%2B%2B-v3%2Finclude%2Fprecompiled%2Fstdc%2B%2B.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprecompiled%2Fstdc%2B%2B.h?ref=1d9454aba615eadd0d85c93713dd848227345f67", "patch": "@@ -210,6 +210,7 @@\n #include <bit>\n #include <compare>\n #include <concepts>\n+#include <format>\n #include <latch>\n #include <numbers>\n #include <ranges>"}, {"sha": "1796362ceef9e3a9880fda3fd5b2a6cbd10c58c4", "filename": "libstdc++-v3/include/std/format", "status": "added", "additions": 3926, "deletions": 0, "changes": 3926, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d9454aba615eadd0d85c93713dd848227345f67/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fformat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d9454aba615eadd0d85c93713dd848227345f67/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fformat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fformat?ref=1d9454aba615eadd0d85c93713dd848227345f67"}, {"sha": "09dffad3c6f4248f40ec196ca74d864387236bd8", "filename": "libstdc++-v3/python/libstdcxx/v6/printers.py", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d9454aba615eadd0d85c93713dd848227345f67/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fprinters.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d9454aba615eadd0d85c93713dd848227345f67/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fprinters.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fprinters.py?ref=1d9454aba615eadd0d85c93713dd848227345f67", "patch": "@@ -1815,6 +1815,32 @@ def to_string(self):\n             val = self.val['_M_i']\n         return '%s<%s> = { %s }' % (self.typename, str(self.value_type), val)\n \n+class StdFormatArgsPrinter:\n+    \"Print a std::basic_format_args\"\n+    # TODO: add printer for basic_format_arg<C> and print out children\n+    # TODO: add printer for basic_format_args<C>::_Store<Args...>\n+\n+    def __init__(self, typename, val):\n+        self.typename = strip_versioned_namespace(typename)\n+        self.val = val\n+\n+    def to_string(self):\n+        targs = get_template_arg_list(self.val.type)\n+        char_type = get_template_arg_list(targs[0])[1]\n+        if char_type == gdb.lookup_type('char'):\n+            typ = 'std::format_args'\n+        elif char_type == gdb.lookup_type('wchar_t'):\n+            typ = 'std::wformat_args'\n+        else:\n+            typ = 'std::basic_format_args'\n+\n+        size = self.val['_M_packed_size']\n+        if size == 1:\n+            return \"%s with 1 argument\" % (typ)\n+        if size == 0:\n+            size = self.val['_M_unpacked_size']\n+        return \"%s with %d arguments\" % (typ, size)\n+\n # A \"regular expression\" printer which conforms to the\n # \"SubPrettyPrinter\" protocol from gdb.printing.\n class RxPrinter(object):\n@@ -2355,6 +2381,7 @@ def build_libstdcxx_dictionary ():\n     libstdcxx_printer.add_version('std::', 'weak_ordering', StdCmpCatPrinter)\n     libstdcxx_printer.add_version('std::', 'strong_ordering', StdCmpCatPrinter)\n     libstdcxx_printer.add_version('std::', 'span', StdSpanPrinter)\n+    libstdcxx_printer.add_version('std::', 'basic_format_args', StdFormatArgsPrinter)\n \n     # Extensions.\n     libstdcxx_printer.add_version('__gnu_cxx::', 'slist', StdSlistPrinter)"}, {"sha": "ae2eab6d5600762d87a983c95e7e24882b23cb92", "filename": "libstdc++-v3/testsuite/std/format/arguments/args.cc", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d9454aba615eadd0d85c93713dd848227345f67/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fformat%2Farguments%2Fargs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d9454aba615eadd0d85c93713dd848227345f67/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fformat%2Farguments%2Fargs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fformat%2Farguments%2Fargs.cc?ref=1d9454aba615eadd0d85c93713dd848227345f67", "patch": "@@ -0,0 +1,96 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do run { target c++20 } }\n+\n+#include <format>\n+#include <testsuite_hooks.h>\n+\n+template<typename Ctx, typename T>\n+bool equals(std::basic_format_arg<Ctx> fmt_arg, T expected) {\n+  return std::visit_format_arg([=](auto arg_val) {\n+    if constexpr (std::is_same_v<decltype(arg_val), T>)\n+      return arg_val == expected;\n+    else\n+      return false;\n+  }, fmt_arg);\n+}\n+\n+void\n+test_empty()\n+{\n+  std::format_args args = std::make_format_args();\n+  VERIFY(!args.get(0));\n+  VERIFY(!args.get(1));\n+  VERIFY(!args.get((std::size_t)-1));\n+  VERIFY(equals(args.get(0), std::monostate{}));\n+\n+  std::format_args cargs =  std::make_format_args<std::format_context>();\n+  VERIFY(!cargs.get(0));\n+  VERIFY(equals(cargs.get(0), std::monostate{}));\n+\n+  std::wformat_args wargs = std::make_wformat_args();\n+  VERIFY(!wargs.get(0));\n+  VERIFY(equals(wargs.get(0), std::monostate{}));\n+}\n+\n+enum E { ByGum };\n+\n+template<>\n+struct std::formatter<E> : std::formatter<int>\n+{\n+  using std::formatter<int>::parse;\n+\n+  std::format_context::iterator\n+  format(E e, std::format_context& fc) const\n+  { return std::formatter<int>::format((int)e, fc); }\n+};\n+\n+void\n+test_args()\n+{\n+  auto store = std::make_format_args(false, 1, '2', 3.4);\n+  std::format_args args = store;\n+  VERIFY(equals(args.get(0), false));\n+  VERIFY(equals(args.get(1), 1));\n+  VERIFY(equals(args.get(2), '2'));\n+  VERIFY(equals(args.get(3), 3.4));\n+  VERIFY(!args.get(4));\n+\n+  auto cstore = std::make_format_args<std::format_context>(5L, 6ULL, 7.8f);\n+  std::format_args cargs = cstore;\n+  if constexpr (sizeof(long) == sizeof(int))\n+    VERIFY(equals(cargs.get(0), 5));\n+  else\n+    VERIFY(equals(cargs.get(0), 5LL));\n+  VERIFY(equals(cargs.get(1), 6ULL));\n+  VERIFY(equals(cargs.get(2), 7.8f));\n+  VERIFY(!cargs.get(3));\n+\n+  VERIFY(equals(std::format_args(std::make_format_args(std::string(\"tenfour\"))).get(0), std::string_view(\"tenfour\")));\n+\n+  // This needs to be on the stack so that testing pointer equality works.\n+  wchar_t eleven[] = L\"eleven\";\n+  // This needs to be on the stack so that the wstring_view doesn't dangle.\n+  std::wstring tenfour = L\"tenfour\";\n+\n+  auto wstore = std::make_wformat_args('9', L'X', eleven, 12.13L, tenfour);\n+  std::wformat_args wargs = wstore;\n+  VERIFY(equals(wargs.get(0), static_cast<wchar_t>('9')));\n+  VERIFY(equals(wargs.get(1), L'X'));\n+  VERIFY(equals(wargs.get(2), static_cast<const wchar_t*>(eleven)));\n+  VERIFY(equals(wargs.get(3), 12.13L));\n+  VERIFY(equals(wargs.get(4), std::wstring_view(tenfour)));\n+  VERIFY(!wargs.get(5));\n+\n+  auto another_store = std::make_format_args(nullptr, E::ByGum);\n+  args = another_store;\n+  VERIFY(equals(args.get(0), static_cast<const void*>(nullptr)));\n+  using handle = std::basic_format_arg<std::format_context>::handle;\n+  auto is_handle = []<typename T>(T) { return std::is_same_v<T, handle>; };\n+  VERIFY(std::visit_format_arg(is_handle, args.get(1)));\n+}\n+\n+int main()\n+{\n+  test_empty();\n+  test_args();\n+}"}, {"sha": "a6918f5ab2e1395cfaa50a6aa31f654f8dd0eb7a", "filename": "libstdc++-v3/testsuite/std/format/error.cc", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d9454aba615eadd0d85c93713dd848227345f67/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fformat%2Ferror.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d9454aba615eadd0d85c93713dd848227345f67/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fformat%2Ferror.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fformat%2Ferror.cc?ref=1d9454aba615eadd0d85c93713dd848227345f67", "patch": "@@ -0,0 +1,26 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do run { target c++20 } }\n+\n+#include <format>\n+#include <string>\n+#include <testsuite_hooks.h>\n+\n+static_assert( std::is_base_of_v<std::runtime_error, std::format_error> );\n+static_assert( std::is_convertible_v<std::format_error*, std::runtime_error*> );\n+\n+void\n+test_what()\n+{\n+  const char* cstr = \"test string\";\n+  std::format_error e(cstr);\n+  VERIFY( std::string(e.what()).find(cstr) != std::string::npos );\n+\n+  std::string str = \"test std::string\";\n+  std::format_error ee(str);\n+  VERIFY( std::string(ee.what()).find(str) != std::string::npos );\n+}\n+\n+int main()\n+{\n+  test_what();\n+}"}, {"sha": "64ff2dbfbfd2724105bca34759d1a67c00d45af2", "filename": "libstdc++-v3/testsuite/std/format/formatter.cc", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d9454aba615eadd0d85c93713dd848227345f67/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fformat%2Fformatter.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d9454aba615eadd0d85c93713dd848227345f67/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fformat%2Fformatter.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fformat%2Fformatter.cc?ref=1d9454aba615eadd0d85c93713dd848227345f67", "patch": "@@ -0,0 +1,89 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do run { target c++20 } }\n+\n+#include <format>\n+#include <testsuite_hooks.h>\n+\n+struct S { };\n+\n+template<> struct std::formatter<S> : std::formatter<const char*> {\n+  template<class Out>\n+  auto format(S, std::basic_format_context<Out, char>& ctx) const {\n+    return formatter<const char*>::format(\"ess\", ctx);\n+  }\n+};\n+\n+struct T { };\n+\n+template<> struct std::formatter<T> : std::formatter<const char*> {\n+  // This function only accepts std::format_context, not other contexts.\n+  auto format(T, std::format_context& ctx) const {\n+    return formatter<const char*>::format(\"tee\", ctx);\n+  }\n+};\n+\n+struct U { };\n+\n+void\n+test_concept() // [format.formattable]\n+{\n+  static_assert( std::formattable<int, char> );\n+  static_assert( std::formattable<const int, char> );\n+  static_assert( std::formattable<int, wchar_t> );\n+  static_assert( std::formattable<const int, wchar_t> );\n+  static_assert( std::formattable<char, char> );\n+  static_assert( std::formattable<char*, char> );\n+  static_assert( std::formattable<wchar_t, wchar_t> );\n+  static_assert( std::formattable<wchar_t*, wchar_t> );\n+  static_assert( std::formattable<char, wchar_t> );\n+  static_assert( ! std::formattable<char*, wchar_t> );\n+  static_assert( ! std::formattable<wchar_t, char> );\n+  static_assert( ! std::formattable<wchar_t*, char> );\n+  static_assert( std::formattable<S, char> );\n+  static_assert( std::formattable<const S, char> );\n+  static_assert( ! std::formattable<S, wchar_t> ); // only formats as char\n+  static_assert( ! std::formattable<T, char> ); // formatter not generic\n+  static_assert( ! std::formattable<U, char> ); // no formatter\n+}\n+\n+enum color { red, green, blue };\n+const char* color_names[] = { \"red\", \"green\", \"blue\" };\n+\n+template<> struct std::formatter<color> : std::formatter<const char*> {\n+  auto format(color c, format_context& ctx) const {\n+    return formatter<const char*>::format(color_names[c], ctx);\n+  }\n+};\n+\n+struct err {};\n+\n+void\n+test_specializations() // [format.formatter.spec]\n+{\n+  std::string s0 = std::format(\"{}\", 42); // OK, library-provided formatter\n+  VERIFY( s0 == \"42\" );\n+\n+  // std::string s1 = std::format(\"{}\", L\"foo\"); // error: disabled formatter\n+  using Fw = std::format_context::formatter_type<wchar_t>;\n+  static_assert( ! std::is_default_constructible_v<Fw> );\n+  static_assert( ! std::is_copy_constructible_v<Fw> );\n+  static_assert( ! std::is_move_constructible_v<Fw> );\n+  static_assert( ! std::is_copy_assignable_v<Fw> );\n+  static_assert( ! std::is_move_assignable_v<Fw> );\n+\n+  std::string s2 = std::format(\"{}\", red);  // OK, user-provided formatter\n+  VERIFY( s2 == \"red\" );\n+\n+  // std::string s3 = std::format(\"{}\", err{}); // error: disabled formatter\n+  using Ferr = std::format_context::formatter_type<err>;\n+  static_assert( ! std::is_default_constructible_v<Ferr> );\n+  static_assert( ! std::is_copy_constructible_v<Ferr> );\n+  static_assert( ! std::is_move_constructible_v<Ferr> );\n+  static_assert( ! std::is_copy_assignable_v<Ferr> );\n+  static_assert( ! std::is_move_assignable_v<Ferr> );\n+}\n+\n+int main()\n+{\n+  test_specializations();\n+}"}, {"sha": "e9e61694f7d0751e6e0aa21ea7cd34fead6551ef", "filename": "libstdc++-v3/testsuite/std/format/functions/format.cc", "status": "added", "additions": 313, "deletions": 0, "changes": 313, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d9454aba615eadd0d85c93713dd848227345f67/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fformat%2Ffunctions%2Fformat.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d9454aba615eadd0d85c93713dd848227345f67/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fformat%2Ffunctions%2Fformat.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fformat%2Ffunctions%2Fformat.cc?ref=1d9454aba615eadd0d85c93713dd848227345f67", "patch": "@@ -0,0 +1,313 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do run { target c++20 } }\n+\n+#include <format>\n+#include <string>\n+#include <limits>\n+#include <cstdint>\n+#include <testsuite_hooks.h>\n+\n+void\n+test_no_args()\n+{\n+  std::string s;\n+  s = std::format(\"disco\");\n+  VERIFY( s == \"disco\" );\n+\n+  s = std::format(\"}} machine {{ funk }} specialists {{\");\n+  VERIFY( s == \"} machine { funk } specialists {\" );\n+\n+  s = std::format(\"128bpm }}\");\n+  VERIFY( s == \"128bpm }\" );\n+}\n+\n+void\n+test_unescaped()\n+{\n+#ifdef __cpp_exceptions\n+  for (auto f : { \"{\", \"}\", \"{{{\", \"{{}\", \"}{\", \"{{{{{\" })\n+    try {\n+      (void) std::vformat(f, std::make_format_args());\n+      VERIFY( false );\n+    } catch (const std::format_error& e) {\n+      std::string what = e.what();\n+      VERIFY( what.find(\"unmatched\") != what.npos );\n+    }\n+#endif\n+}\n+\n+struct brit_punc : std::numpunct<char>\n+{\n+  std::string do_grouping() const override { return \"\\3\\3\"; }\n+  char do_thousands_sep() const override { return ','; }\n+  std::string do_truename() const override { return \"yes mate\"; }\n+  std::string do_falsename() const override { return \"nah bruv\"; }\n+};\n+\n+void\n+test_std_examples()\n+{\n+  using namespace std;\n+\n+  string s = format(\"{0}-{{\", 8); // value of s is \"8-{\"\n+  VERIFY( s == \"8-{\" );\n+\n+  // align\n+  {\n+    char c = 120;\n+    string s0 = format(\"{:6}\", 42);\n+    VERIFY(s0 == \"    42\");\n+    string s1 = format(\"{:6}\", 'x');\n+    VERIFY(s1 == \"x     \");\n+    string s2 = format(\"{:*<6}\", 'x');\n+    VERIFY(s2 == \"x*****\");\n+    string s3 = format(\"{:*>6}\", 'x');\n+    VERIFY(s3 == \"*****x\");\n+    string s4 = format(\"{:*^6}\", 'x');\n+    VERIFY(s4 == \"**x***\");\n+    string s5 = format(\"{:6d}\", c);\n+    VERIFY(s5 == \"   120\");\n+    string s6 = format(\"{:6}\", true);\n+    VERIFY(s6 == \"true  \");\n+  }\n+\n+  // sign\n+  {\n+    double inf = numeric_limits<double>::infinity();\n+    double nan = numeric_limits<double>::quiet_NaN();\n+    string s0 = format(\"{0:},{0:+},{0:-},{0: }\", 1);\n+    VERIFY(s0 == \"1,+1,1, 1\");\n+    string s1 = format(\"{0:},{0:+},{0:-},{0: }\", -1);\n+    VERIFY(s1 == \"-1,-1,-1,-1\");\n+    string s2 = format(\"{0:},{0:+},{0:-},{0: }\", inf);\n+    VERIFY(s2 == \"inf,+inf,inf, inf\");\n+    string s3 = format(\"{0:},{0:+},{0:-},{0: }\", nan);\n+    VERIFY(s3 == \"nan,+nan,nan, nan\");\n+  }\n+\n+  // alternate form and zero fill\n+  {\n+    char c = 120;\n+    string s1 = format(\"{:+06d}\", c);\n+    VERIFY(s1 == \"+00120\");\n+    string s2 = format(\"{:#06x}\", 0xa);\n+    VERIFY(s2 == \"0x000a\");\n+    string s3 = format(\"{:<06}\", -42);\n+    VERIFY(s3 == \"-42   \"); // 0 is ignored because of < alignment\n+  }\n+\n+  // integer presentation types\n+  {\n+    // Change global locale so \"{:L}\" adds digit separators.\n+    std::locale::global(std::locale({}, new brit_punc));\n+\n+    string s0 = format(\"{}\", 42);\n+    VERIFY(s0 == \"42\");\n+    string s1 = format(\"{0:b} {0:d} {0:o} {0:x}\", 42);\n+    VERIFY(s1 == \"101010 42 52 2a\");\n+    string s2 = format(\"{0:#x} {0:#X}\", 42);\n+    VERIFY(s2 == \"0x2a 0X2A\");\n+    string s3 = format(\"{:L}\", 1234);\n+    VERIFY(s3 == \"1,234\");\n+\n+    // Restore\n+    std::locale::global(std::locale::classic());\n+  }\n+}\n+\n+void\n+test_alternate_forms()\n+{\n+  std::string s;\n+\n+  s = std::format(\"{0:#b} {0:+#B} {0:#o} {0:#x} {0:+#X} {0: #d}\", 42);\n+  VERIFY( s == \"0b101010 +0B101010 052 0x2a +0X2A  42\" );\n+  s = std::format(\"{0:#b} {0:+#B} {0:#o} {0:#x} {0:+#X} {0: #d}\", 0);\n+  VERIFY( s == \"0b0 +0B0 0 0x0 +0X0  0\" );\n+\n+  s = std::format(\"{0:+#012g} {0:+#014g} {0:+#014g}\", 1234.0);\n+  VERIFY( s == \"+00001234.00 +0000001234.00 +0000001234.00\" );\n+  s = std::format(\"{0:+#0{1}g} {0:+#0{2}g} {0:+#0{2}g}\", 1234.5, 12, 14);\n+  VERIFY( s == \"+00001234.50 +0000001234.50 +0000001234.50\" );\n+\n+  s = std::format(\"{:#.2g}\", -0.0);\n+  VERIFY( s == \"-0.0\" );\n+}\n+\n+struct euro_punc : std::numpunct<char>\n+{\n+  std::string do_grouping() const override { return \"\\3\\3\"; }\n+  char do_thousands_sep() const override { return '.'; }\n+  char do_decimal_point() const override { return ','; }\n+};\n+\n+void\n+test_locale()\n+{\n+  // The default C locale.\n+  std::locale cloc = std::locale::classic();\n+  // A custom locale using comma digit separators.\n+  std::locale bloc(cloc, new brit_punc);\n+  // A custom locale using period digit separators.\n+  std::locale eloc(cloc, new euro_punc);\n+\n+  std::string s;\n+\n+  // Change the global locale:\n+  std::locale::global(bloc);\n+  // Format using the global locale:\n+  s = std::format(\"{0:L} {0:Lx} {0:Lb}\", 12345);\n+  VERIFY( s == \"12,345 3,039 11,000,000,111,001\" );\n+  s = std::format(\"{0:L} {0:.7Lg} {0:La}\", 12345.6789);\n+  VERIFY( s == \"12,345.6789 12,345.68 1.81cd6e631f8a1p+13\" );\n+\n+  s = std::format(\"{0:s} {0:L} {1:Ls} {0:Ld}\", true, false);\n+  VERIFY( s == \"true yes mate nah bruv 1\" );\n+\n+  // Format using a specific locale:\n+  s = std::format(eloc, \"{0:L} {0:Lx} {0:Lb}\", 12345);\n+  VERIFY( s == \"12.345 3.039 11.000.000.111.001\" );\n+  s = std::format(eloc, \"{0:L} {0:.7LG} {0:La}\", 12345.6789);\n+  VERIFY( s == \"12.345,6789 12.345,68 1,81cd6e631f8a1p+13\" );\n+\n+  s = std::format(eloc, \"{0:#Lg} {0:+#.3Lg} {0:#08.4Lg}\", -1234.);\n+  VERIFY( s == \"-1.234,00 -1,23e+03 -01.234,\" );\n+\n+  // Restore\n+  std::locale::global(cloc);\n+}\n+\n+void\n+test_width()\n+{\n+  std::string s;\n+\n+  s = std::format(\"{:4}\", \"\");\n+  VERIFY( s == \"    \" );\n+  s = std::format(\"{:{}}\", \"\", 3);\n+  VERIFY( s == \"   \" );\n+  s = std::format(\"{1:{0}}\", 2, \"\");\n+  VERIFY( s == \"  \" );\n+  s = std::format(\"{:03}\", 9);\n+  VERIFY( s == \"009\" );\n+\n+  s = std::format(\"DR {0:{1}}: allow width {1} from arg-id\", 3721, 0);\n+  VERIFY( s == \"DR 3721: allow width 0 from arg-id\" );\n+\n+  try {\n+    s = std::format(\"Negative width is an error: {0:{1}}\", 123, -1);\n+    VERIFY(false);\n+  } catch (const std::format_error&) {\n+  }\n+\n+  try {\n+    auto args = std::make_format_args(false, true);\n+    s = std::vformat(\"DR 3720: restrict type of width arg-id {0:{1}}\", args);\n+    VERIFY(false);\n+  } catch (const std::format_error&) {\n+  }\n+\n+  try {\n+    auto args = std::make_format_args('?', '!');\n+    s = std::vformat(\"DR 3720: restrict type of width arg-id {0:{1}}\", args);\n+    VERIFY(false);\n+  } catch (const std::format_error&) {\n+  }\n+}\n+\n+void\n+test_wchar()\n+{\n+  using namespace std::literals;\n+  std::wstring s;\n+\n+  s = std::format(L\"{} {} {} {} {} {}\", L'0', 1, 2LL, 3.4, L\"five\", L\"six\"s);\n+  VERIFY( s == L\"0 1 2 3.4 five six\" );\n+\n+  std::locale loc;\n+  s = std::format(loc, L\"{:L} {:.3s}{:Lc}\", true, L\"data\"sv, '.');\n+  VERIFY( s == L\"true dat.\" );\n+}\n+\n+void\n+test_minmax()\n+{\n+  auto check = []<typename T>(T) {\n+    const int digits = std::numeric_limits<T>::digits;\n+    const std::string zeros(digits, '0');\n+    const std::string ones(digits, '1');\n+    auto s = std::format(\"{:b}\" , std::numeric_limits<T>::min());\n+    VERIFY( s == \"-1\" + zeros );\n+    s = std::format(\"{:b}\" , std::numeric_limits<T>::max());\n+    VERIFY( s == ones );\n+    using U = std::make_unsigned_t<T>;\n+    s = std::format(\"{:0{}b}\" , std::numeric_limits<U>::min(), digits + 1);\n+    VERIFY( s == '0' + zeros );\n+    s = std::format(\"{:b}\" , std::numeric_limits<U>::max());\n+    VERIFY( s == '1' + ones );\n+  };\n+  check(std::int8_t(0));\n+  check(std::int16_t(0));\n+  check(std::int32_t(0));\n+  check(std::int64_t(0));\n+#ifdef __SIZEOF_INT128__\n+  check(__int128(0));\n+#endif\n+}\n+\n+void\n+test_p1652r1() // printf corner cases in std::format\n+{\n+  std::string s;\n+\n+  // Problem 1: \"#o\" specification should not print 0 as \"00\"\n+  s = std::format(\"{:#o}\", 0);\n+  VERIFY( s == \"0\" );\n+\n+  // Problem 2: 'c' should be able to print 65 as \"A\" (ASCII)\n+  int c = 'A';\n+  s = std::format(\"{:c}\", c);\n+  VERIFY( s == \"A\" );\n+\n+  // Problem 3: \"-000nan\" is not a floating point value\n+  double nan = std::numeric_limits<double>::quiet_NaN();\n+  try {\n+    s = std::vformat(\"{:0=6}\", std::make_format_args(nan));\n+    VERIFY( false );\n+  } catch (const std::format_error&) {\n+  }\n+\n+  s = std::format(\"{:06}\", nan);\n+  VERIFY( s == \"   nan\" );\n+\n+  // Problem 4: bool needs a type format specifier\n+  s = std::format(\"{:s}\", true);\n+  VERIFY( s == \"true\" );\n+\n+  // Problem 5: double does not roundtrip float\n+  s = std::format(\"{}\", 3.31f);\n+  VERIFY( s == \"3.31\" );\n+}\n+\n+void\n+test_float128()\n+{\n+#ifdef __SIZEOF_FLOAT128__\n+  auto s = std::format(\"{:#} != {:<+7.3f}\", (__float128)-0.0, (__float128)0.5);\n+  VERIFY( s == \"-0. != +0.500 \" );\n+#endif\n+}\n+\n+int main()\n+{\n+  test_no_args();\n+  test_unescaped();\n+  test_std_examples();\n+  test_alternate_forms();\n+  test_locale();\n+  test_width();\n+  test_wchar();\n+  test_minmax();\n+  test_p1652r1();\n+  test_float128();\n+}"}, {"sha": "846bda30fdf3ccf96403c4ae0f5c448360ec115f", "filename": "libstdc++-v3/testsuite/std/format/functions/format_to_n.cc", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d9454aba615eadd0d85c93713dd848227345f67/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fformat%2Ffunctions%2Fformat_to_n.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d9454aba615eadd0d85c93713dd848227345f67/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fformat%2Ffunctions%2Fformat_to_n.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fformat%2Ffunctions%2Fformat_to_n.cc?ref=1d9454aba615eadd0d85c93713dd848227345f67", "patch": "@@ -0,0 +1,96 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do run { target c++20 } }\n+\n+#include <format>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+\n+struct punct : std::numpunct<char>\n+{\n+  std::string do_grouping() const override { return \"\\2\"; }\n+  std::string do_truename() const override { return \"troo\"; }\n+  std::string do_falsename() const override { return \"falz\"; }\n+};\n+\n+void\n+test()\n+{\n+  char buf[4] = { };\n+  auto [out, len] = std::format_to_n(buf, 3, \"123 + 456 = {}\", 579);\n+  VERIFY( out == buf+3 );\n+  VERIFY( len == 15 );\n+\n+  std::locale loc({}, new punct);\n+  auto [out2, len2] = std::format_to_n(buf, 4, loc, \"{:Ld}\", 12345);\n+  VERIFY( out2 == buf+4 );\n+  VERIFY( len2 == 7 );\n+  VERIFY( std::string_view(buf, 4) == \"1,23\" );\n+}\n+\n+struct wpunct : std::numpunct<wchar_t>\n+{\n+  std::string do_grouping() const override { return \"\\2\"; }\n+  std::wstring do_truename() const override { return L\"troo\"; }\n+  std::wstring do_falsename() const override { return L\"falz\"; }\n+};\n+\n+void\n+test_wchar()\n+{\n+  wchar_t buf[4] = { };\n+  auto [out, len] = std::format_to_n(buf, 3, L\"123 + 456 = {}\", 579);\n+  VERIFY( out == buf+3 );\n+  VERIFY( len == 15 );\n+\n+  std::locale loc({}, new wpunct);\n+  auto [out2, len2] = std::format_to_n(buf, 4, loc, L\"{:Ld}\", 12345);\n+  VERIFY( out2 == buf+4 );\n+  VERIFY( len2 == 7 );\n+  VERIFY( std::wstring_view(buf, 4) == L\"1,23\" );\n+}\n+\n+template<typename I>\n+struct move_only_iterator\n+{\n+  using iterator = I;\n+  using value_type = iterator::value_type;\n+  using difference_type = iterator::difference_type;\n+  using iterator_category = std::output_iterator_tag;\n+\n+  move_only_iterator(iterator b) : base_(b) { }\n+  move_only_iterator(move_only_iterator&&) = default;\n+  move_only_iterator& operator=(move_only_iterator&&) = default;\n+\n+  move_only_iterator& operator++() { ++base_; return *this; }\n+  move_only_iterator operator++(int) { auto tmp = *this; ++base_; return tmp; }\n+\n+  decltype(auto) operator*() { return *base_; }\n+\n+private:\n+  iterator base_;\n+};\n+\n+void\n+test_move_only()\n+{\n+  std::string str;\n+  move_only_iterator mo(std::back_inserter(str));\n+  auto [res, len] = std::format_to_n(std::move(mo), 4, \"for{:.3} that{:c}\",\n+\t\t\t\t     \"matte\", (int)'!');\n+  VERIFY( str == \"form\" );\n+  VERIFY( len == 12 );\n+\n+  std::vector<wchar_t> vec;\n+  move_only_iterator wmo(std::back_inserter(vec));\n+  auto [wres, wlen] = std::format_to_n(std::move(wmo), 9, L\"for{:.3} hat{:c}\",\n+\t\t\t\t       L\"matte\", (long)L'!');\n+  VERIFY( std::wstring_view(vec.data(), vec.size()) == L\"format ha\" );\n+  VERIFY( wlen == 11 );\n+}\n+\n+int main()\n+{\n+  test();\n+  test_wchar();\n+  test_move_only();\n+}"}, {"sha": "4509a7ccd73f806e717b763366de16ddffec4520", "filename": "libstdc++-v3/testsuite/std/format/functions/size.cc", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d9454aba615eadd0d85c93713dd848227345f67/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fformat%2Ffunctions%2Fsize.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d9454aba615eadd0d85c93713dd848227345f67/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fformat%2Ffunctions%2Fsize.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fformat%2Ffunctions%2Fsize.cc?ref=1d9454aba615eadd0d85c93713dd848227345f67", "patch": "@@ -0,0 +1,52 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do run { target c++20 } }\n+\n+#include <format>\n+#include <string>\n+#include <testsuite_hooks.h>\n+\n+void\n+test()\n+{\n+  auto n = std::formatted_size(\"\");\n+  static_assert( std::is_same_v<std::size_t, decltype(n)> );\n+  VERIFY( n == 0 );\n+\n+  n = std::formatted_size(\"abc\");\n+  VERIFY( n == 3 );\n+\n+  n = std::formatted_size(\"{{abc}}\");\n+  VERIFY( n == 5 );\n+\n+  n = std::formatted_size(\"{{{}}}\", 1);\n+  VERIFY( n == 3 );\n+\n+  n = std::formatted_size(\"{{{}}}\", \"abc\");\n+  VERIFY( n == 5 );\n+}\n+\n+void\n+test_wchar()\n+{\n+  auto n = std::formatted_size(L\"\");\n+  static_assert( std::is_same_v<std::size_t, decltype(n)> );\n+  VERIFY( n == 0 );\n+\n+  n = std::formatted_size(L\"abc\");\n+  VERIFY( n == 3 );\n+\n+  n = std::formatted_size(L\"{{abc}}\");\n+  VERIFY( n == 5 );\n+\n+  n = std::formatted_size(L\"{{{}}}\", 1);\n+  VERIFY( n == 3 );\n+\n+  n = std::formatted_size(L\"{{{}}}\", L\"abc\");\n+  VERIFY( n == 5 );\n+}\n+\n+int main()\n+{\n+  test();\n+  test_wchar();\n+}"}, {"sha": "6fa33b9fbacd533e2969c6667adfc50316ff42ae", "filename": "libstdc++-v3/testsuite/std/format/functions/vformat_to.cc", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d9454aba615eadd0d85c93713dd848227345f67/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fformat%2Ffunctions%2Fvformat_to.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d9454aba615eadd0d85c93713dd848227345f67/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fformat%2Ffunctions%2Fvformat_to.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fformat%2Ffunctions%2Fvformat_to.cc?ref=1d9454aba615eadd0d85c93713dd848227345f67", "patch": "@@ -0,0 +1,51 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do run { target c++20 } }\n+\n+#include <format>\n+#include <string>\n+#include <iterator>\n+#include <testsuite_hooks.h>\n+\n+template<typename C>\n+struct move_only_iterator\n+{\n+  using iterator = std::back_insert_iterator<std::basic_string<C>>;\n+  using value_type = iterator::value_type;\n+  using difference_type = iterator::difference_type;\n+  using iterator_category = std::output_iterator_tag;\n+\n+  move_only_iterator(iterator b) : base_(b) { }\n+  move_only_iterator(move_only_iterator&&) = default;\n+  move_only_iterator& operator=(move_only_iterator&&) = default;\n+\n+  move_only_iterator& operator++() { ++base_; return *this; }\n+  move_only_iterator operator++(int) { auto tmp = *this; ++base_; return tmp; }\n+\n+  decltype(auto) operator*() { return *base_; }\n+\n+private:\n+  iterator base_;\n+};\n+\n+void\n+test_move_only()\n+{\n+  std::string str;\n+  move_only_iterator<char> mo(std::back_inserter(str));\n+  auto res = std::vformat_to(std::move(mo), \"for{:.3} that{:c}\",\n+\t\t\t     std::make_format_args(\"matte\", (int)'!'));\n+  static_assert(std::is_same_v<decltype(res), decltype(mo)>);\n+  VERIFY( str == \"format that!\" );\n+\n+  std::wstring wstr;\n+  move_only_iterator<wchar_t> wmo(std::back_inserter(wstr));\n+  auto wres = std::vformat_to(std::move(wmo), L\"for{:.3} that{:c}\",\n+\t\t\t      std::make_wformat_args(L\"matte\", (long)L'!'));\n+  static_assert(std::is_same_v<decltype(wres), decltype(wmo)>);\n+  VERIFY( wstr == L\"format that!\" );\n+}\n+\n+int main()\n+{\n+  test_move_only();\n+}"}, {"sha": "dd6ca68290bef4f19942dc25141df9b1831ea5e8", "filename": "libstdc++-v3/testsuite/std/format/parse_ctx.cc", "status": "added", "additions": 374, "deletions": 0, "changes": 374, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d9454aba615eadd0d85c93713dd848227345f67/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fformat%2Fparse_ctx.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d9454aba615eadd0d85c93713dd848227345f67/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fformat%2Fparse_ctx.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fformat%2Fparse_ctx.cc?ref=1d9454aba615eadd0d85c93713dd848227345f67", "patch": "@@ -0,0 +1,374 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do run { target c++20 } }\n+\n+#include <format>\n+#include <testsuite_hooks.h>\n+\n+template<typename T, size_t N = 1, bool auto_indexing = true>\n+bool\n+is_std_format_spec_for(std::string_view spec)\n+{\n+  std::format_parse_context pc(spec, N);\n+  if (auto_indexing)\n+    (void) pc.next_arg_id();\n+  else\n+    pc.check_arg_id(0);\n+\n+  std::formatter<T> f;\n+  try {\n+    auto end = f.parse(pc);\n+    VERIFY( end == spec.end() || *end == '}' );\n+    return true;\n+  } catch (const std::format_error&) {\n+    return false;\n+  }\n+}\n+\n+#if __cpp_lib_format_ranges\n+constexpr bool escaped_strings_supported = true;\n+#else\n+constexpr bool escaped_strings_supported = false;\n+#endif\n+\n+void\n+test_char()\n+{\n+  VERIFY( is_std_format_spec_for<char>(\"\") );\n+  VERIFY( is_std_format_spec_for<char>(\"<\") );\n+  VERIFY( is_std_format_spec_for<char>(\">\") );\n+  VERIFY( is_std_format_spec_for<char>(\"^\") );\n+  VERIFY( is_std_format_spec_for<char>(\"0<\") );\n+  VERIFY( is_std_format_spec_for<char>(\"0>\") );\n+  VERIFY( is_std_format_spec_for<char>(\"0^\") );\n+  VERIFY( ! is_std_format_spec_for<char>(\"{^\") );\n+  VERIFY( ! is_std_format_spec_for<char>(\"+\") );\n+  VERIFY( ! is_std_format_spec_for<char>(\"-\") );\n+  VERIFY( ! is_std_format_spec_for<char>(\" \") );\n+  VERIFY( ! is_std_format_spec_for<char>(\"#\") );\n+  VERIFY( is_std_format_spec_for<char>(\"0d\") );\n+  VERIFY( ! is_std_format_spec_for<char>(\"0\") );\n+  VERIFY( ! is_std_format_spec_for<char>(\"00d\") );\n+  VERIFY( is_std_format_spec_for<char>(\"01d\") );\n+  VERIFY( ! is_std_format_spec_for<char>(\"0{}d\") );\n+  VERIFY( ! is_std_format_spec_for<char>(\"0{1}d\") );\n+  VERIFY(( is_std_format_spec_for<char, 2>(\"0{}d\") ));\n+  VERIFY(( ! is_std_format_spec_for<char, 2>(\"0{1}d\") ));\n+  VERIFY(( is_std_format_spec_for<char, 2, false>(\"0{1}d\") ));\n+  VERIFY( is_std_format_spec_for<char>(\"1\") );\n+  VERIFY( ! is_std_format_spec_for<char>(\"-1\") );\n+  VERIFY( is_std_format_spec_for<char>(\"-1d\") ); // sign and width\n+  VERIFY( ! is_std_format_spec_for<char>(\".\") );\n+  VERIFY( ! is_std_format_spec_for<char>(\".1\") );\n+  VERIFY( is_std_format_spec_for<char>(\"c\") );\n+  VERIFY( is_std_format_spec_for<char>(\"b\") );\n+  VERIFY( is_std_format_spec_for<char>(\"B\") );\n+  VERIFY( is_std_format_spec_for<char>(\"d\") );\n+  VERIFY( is_std_format_spec_for<char>(\"o\") );\n+  VERIFY( is_std_format_spec_for<char>(\"x\") );\n+  VERIFY( is_std_format_spec_for<char>(\"X\") );\n+  VERIFY( ! is_std_format_spec_for<char>(\"s\") );\n+  VERIFY( is_std_format_spec_for<char>(\"?\") == escaped_strings_supported );\n+  VERIFY( ! is_std_format_spec_for<char>(\"a\") );\n+  VERIFY( ! is_std_format_spec_for<char>(\"A\") );\n+  VERIFY( ! is_std_format_spec_for<char>(\"f\") );\n+  VERIFY( ! is_std_format_spec_for<char>(\"F\") );\n+  VERIFY( ! is_std_format_spec_for<char>(\"g\") );\n+  VERIFY( ! is_std_format_spec_for<char>(\"G\") );\n+  VERIFY( ! is_std_format_spec_for<char>(\"+c\") );\n+  VERIFY( ! is_std_format_spec_for<char>(\"+?\") );\n+  VERIFY( is_std_format_spec_for<char>(\"+d\") );\n+}\n+\n+void\n+test_int()\n+{\n+  VERIFY( is_std_format_spec_for<int>(\"\") );\n+  VERIFY( is_std_format_spec_for<int>(\"<\") );\n+  VERIFY( is_std_format_spec_for<int>(\">\") );\n+  VERIFY( is_std_format_spec_for<int>(\"^\") );\n+  VERIFY( is_std_format_spec_for<int>(\"0<\") );\n+  VERIFY( is_std_format_spec_for<int>(\"0>\") );\n+  VERIFY( is_std_format_spec_for<int>(\"0^\") );\n+  VERIFY( ! is_std_format_spec_for<int>(\"{^\") );\n+  VERIFY( is_std_format_spec_for<int>(\"+\") );\n+  VERIFY( is_std_format_spec_for<int>(\"-\") );\n+  VERIFY( is_std_format_spec_for<int>(\" \") );\n+  VERIFY( is_std_format_spec_for<int>(\"#\") );\n+  VERIFY( is_std_format_spec_for<int>(\"0d\") );\n+  VERIFY( is_std_format_spec_for<int>(\"0\") );\n+  VERIFY( ! is_std_format_spec_for<int>(\"00d\") );\n+  VERIFY( is_std_format_spec_for<int>(\"01d\") );\n+  VERIFY( ! is_std_format_spec_for<int>(\"0{}d\") );\n+  VERIFY( ! is_std_format_spec_for<int>(\"0{1}d\") );\n+  VERIFY(( is_std_format_spec_for<int, 2>(\"0{}d\") ));\n+  VERIFY(( ! is_std_format_spec_for<int, 2>(\"0{1}d\") ));\n+  VERIFY(( is_std_format_spec_for<int, 2, false>(\"0{1}d\") ));\n+  VERIFY( is_std_format_spec_for<int>(\"1\") );\n+  VERIFY( is_std_format_spec_for<int>(\"-1\") ); // sign and width\n+  VERIFY( ! is_std_format_spec_for<int>(\".\") );\n+  VERIFY( ! is_std_format_spec_for<int>(\".1\") );\n+  VERIFY( is_std_format_spec_for<int>(\"c\") );\n+  VERIFY( is_std_format_spec_for<int>(\"b\") );\n+  VERIFY( is_std_format_spec_for<int>(\"B\") );\n+  VERIFY( is_std_format_spec_for<int>(\"d\") );\n+  VERIFY( is_std_format_spec_for<int>(\"o\") );\n+  VERIFY( is_std_format_spec_for<int>(\"x\") );\n+  VERIFY( is_std_format_spec_for<int>(\"X\") );\n+  VERIFY( ! is_std_format_spec_for<int>(\"s\") );\n+  VERIFY( ! is_std_format_spec_for<int>(\"?\") );\n+  VERIFY( ! is_std_format_spec_for<int>(\"a\") );\n+  VERIFY( ! is_std_format_spec_for<int>(\"A\") );\n+  VERIFY( ! is_std_format_spec_for<int>(\"f\") );\n+  VERIFY( ! is_std_format_spec_for<int>(\"F\") );\n+  VERIFY( ! is_std_format_spec_for<int>(\"g\") );\n+  VERIFY( ! is_std_format_spec_for<int>(\"G\") );\n+  VERIFY( ! is_std_format_spec_for<int>(\"p\") );\n+  VERIFY( ! is_std_format_spec_for<int>(\"P\") );\n+  VERIFY( is_std_format_spec_for<int>(\"+c\") ); // But LWG 3644 would change it.\n+  VERIFY( ! is_std_format_spec_for<int>(\"+?\") );\n+  VERIFY( is_std_format_spec_for<int>(\"+d\") );\n+}\n+\n+void\n+test_bool()\n+{\n+  VERIFY( is_std_format_spec_for<bool>(\"\") );\n+  VERIFY( is_std_format_spec_for<bool>(\"<\") );\n+  VERIFY( is_std_format_spec_for<bool>(\">\") );\n+  VERIFY( is_std_format_spec_for<bool>(\"^\") );\n+  VERIFY( is_std_format_spec_for<bool>(\"0<\") );\n+  VERIFY( is_std_format_spec_for<bool>(\"0>\") );\n+  VERIFY( is_std_format_spec_for<bool>(\"0^\") );\n+  VERIFY( ! is_std_format_spec_for<bool>(\"{^\") );\n+  VERIFY( ! is_std_format_spec_for<bool>(\"+\") );\n+  VERIFY( ! is_std_format_spec_for<bool>(\"-\") );\n+  VERIFY( ! is_std_format_spec_for<bool>(\" \") );\n+  VERIFY( ! is_std_format_spec_for<bool>(\"#\") );\n+  VERIFY( is_std_format_spec_for<bool>(\"0d\") );\n+  VERIFY( ! is_std_format_spec_for<bool>(\"0\") );\n+  VERIFY( ! is_std_format_spec_for<bool>(\"00d\") );\n+  VERIFY( is_std_format_spec_for<bool>(\"01d\") );\n+  VERIFY( is_std_format_spec_for<bool>(\"1\") );\n+  VERIFY( ! is_std_format_spec_for<bool>(\"-1\") );\n+  VERIFY( is_std_format_spec_for<bool>(\"-1d\") ); // sign and width\n+  VERIFY( ! is_std_format_spec_for<bool>(\".\") );\n+  VERIFY( ! is_std_format_spec_for<bool>(\".1\") );\n+  VERIFY( ! is_std_format_spec_for<bool>(\"c\") );\n+  VERIFY( is_std_format_spec_for<bool>(\"b\") );\n+  VERIFY( is_std_format_spec_for<bool>(\"B\") );\n+  VERIFY( is_std_format_spec_for<bool>(\"d\") );\n+  VERIFY( is_std_format_spec_for<bool>(\"o\") );\n+  VERIFY( is_std_format_spec_for<bool>(\"x\") );\n+  VERIFY( is_std_format_spec_for<bool>(\"X\") );\n+  VERIFY( is_std_format_spec_for<bool>(\"s\") );\n+  VERIFY( ! is_std_format_spec_for<bool>(\"?\") );\n+  VERIFY( ! is_std_format_spec_for<bool>(\"a\") );\n+  VERIFY( ! is_std_format_spec_for<bool>(\"A\") );\n+  VERIFY( ! is_std_format_spec_for<bool>(\"f\") );\n+  VERIFY( ! is_std_format_spec_for<bool>(\"F\") );\n+  VERIFY( ! is_std_format_spec_for<bool>(\"g\") );\n+  VERIFY( ! is_std_format_spec_for<bool>(\"G\") );\n+  VERIFY( ! is_std_format_spec_for<bool>(\"p\") );\n+  VERIFY( ! is_std_format_spec_for<bool>(\"P\") );\n+  VERIFY( ! is_std_format_spec_for<bool>(\"+s\") );\n+  VERIFY( is_std_format_spec_for<bool>(\"+d\") );\n+}\n+\n+void\n+test_float()\n+{\n+  VERIFY( is_std_format_spec_for<float>(\"\") );\n+  VERIFY( is_std_format_spec_for<float>(\"<\") );\n+  VERIFY( is_std_format_spec_for<float>(\">\") );\n+  VERIFY( is_std_format_spec_for<float>(\"^\") );\n+  VERIFY( is_std_format_spec_for<float>(\"0<\") );\n+  VERIFY( is_std_format_spec_for<float>(\"0>\") );\n+  VERIFY( is_std_format_spec_for<float>(\"0^\") );\n+  VERIFY( ! is_std_format_spec_for<float>(\"{^\") );\n+  VERIFY( is_std_format_spec_for<float>(\"+\") );\n+  VERIFY( is_std_format_spec_for<float>(\"-\") );\n+  VERIFY( is_std_format_spec_for<float>(\" \") );\n+  VERIFY( is_std_format_spec_for<float>(\"#\") );\n+  VERIFY( is_std_format_spec_for<float>(\"0f\") );\n+  VERIFY( is_std_format_spec_for<float>(\"0\") );\n+  VERIFY( ! is_std_format_spec_for<float>(\"00f\") );\n+  VERIFY( is_std_format_spec_for<float>(\"01f\") );\n+  VERIFY( ! is_std_format_spec_for<float>(\"0{}f\") );\n+  VERIFY( ! is_std_format_spec_for<float>(\"0{1}f\") );\n+  VERIFY(( is_std_format_spec_for<float, 2>(\"0{}f\") ));\n+  VERIFY(( ! is_std_format_spec_for<float, 2>(\"0{1}f\") ));\n+  VERIFY(( is_std_format_spec_for<float, 2, false>(\"0{1}f\") ));\n+  VERIFY( is_std_format_spec_for<float>(\"1\") );\n+  VERIFY( is_std_format_spec_for<float>(\"-1\") ); // sign and width\n+  VERIFY( ! is_std_format_spec_for<float>(\".\") );\n+  VERIFY( is_std_format_spec_for<float>(\".1\") );\n+  VERIFY( ! is_std_format_spec_for<float>(\".{}\") );\n+  VERIFY( ! is_std_format_spec_for<float>(\".{1}\") );\n+  VERIFY(( is_std_format_spec_for<float, 2>(\".{}\") ));\n+  VERIFY(( ! is_std_format_spec_for<float, 2>(\".{1}\") ));\n+  VERIFY(( is_std_format_spec_for<float, 2, false>(\".{1}\") ));\n+  VERIFY(( ! is_std_format_spec_for<float, 2>(\"{}.{}\") ));\n+  VERIFY(( is_std_format_spec_for<float, 3>(\"{}.{}\") ));\n+  VERIFY(( is_std_format_spec_for<float, 2, false>(\"{1}.{1}\") ));\n+  VERIFY(( is_std_format_spec_for<float, 3, false>(\"{2}.{1}\") ));\n+  VERIFY( ! is_std_format_spec_for<float>(\"c\") );\n+  VERIFY( ! is_std_format_spec_for<float>(\"b\") );\n+  VERIFY( ! is_std_format_spec_for<float>(\"B\") );\n+  VERIFY( ! is_std_format_spec_for<float>(\"d\") );\n+  VERIFY( ! is_std_format_spec_for<float>(\"o\") );\n+  VERIFY( ! is_std_format_spec_for<float>(\"x\") );\n+  VERIFY( ! is_std_format_spec_for<float>(\"X\") );\n+  VERIFY( ! is_std_format_spec_for<float>(\"s\") );\n+  VERIFY( ! is_std_format_spec_for<float>(\"?\") );\n+  VERIFY( is_std_format_spec_for<float>(\"a\") );\n+  VERIFY( is_std_format_spec_for<float>(\"A\") );\n+  VERIFY( is_std_format_spec_for<float>(\"f\") );\n+  VERIFY( is_std_format_spec_for<float>(\"F\") );\n+  VERIFY( is_std_format_spec_for<float>(\"g\") );\n+  VERIFY( is_std_format_spec_for<float>(\"G\") );\n+  VERIFY( ! is_std_format_spec_for<float>(\"p\") );\n+  VERIFY( ! is_std_format_spec_for<float>(\"P\") );\n+  VERIFY( is_std_format_spec_for<float>(\"+f\") );\n+\n+  VERIFY( is_std_format_spec_for<float>(\"_<+#09.6Lf\") );\n+  VERIFY( is_std_format_spec_for<float>(\"<+#09.6Lf\") );\n+  VERIFY( is_std_format_spec_for<float>(\"<+#9.6Lf\") );\n+  VERIFY( is_std_format_spec_for<float>(\".0006f\") );\n+}\n+\n+void\n+test_pointer()\n+{\n+  VERIFY( is_std_format_spec_for<void*>(\"\") );\n+  VERIFY( is_std_format_spec_for<void*>(\"<\") );\n+  VERIFY( is_std_format_spec_for<void*>(\">\") );\n+  VERIFY( is_std_format_spec_for<void*>(\"^\") );\n+  VERIFY( is_std_format_spec_for<void*>(\"0<\") );\n+  VERIFY( is_std_format_spec_for<void*>(\"0>\") );\n+  VERIFY( is_std_format_spec_for<void*>(\"0^\") );\n+  VERIFY( ! is_std_format_spec_for<void*>(\"{^\") );\n+  VERIFY( ! is_std_format_spec_for<void*>(\"+\") );\n+  VERIFY( ! is_std_format_spec_for<void*>(\"-\") );\n+  VERIFY( ! is_std_format_spec_for<void*>(\" \") );\n+  VERIFY( ! is_std_format_spec_for<void*>(\"#\") );\n+  VERIFY( is_std_format_spec_for<void*>(\"0p\") ); // P2510\n+  VERIFY( is_std_format_spec_for<void*>(\"0\") );\n+  VERIFY( ! is_std_format_spec_for<void*>(\"00p\") );\n+  VERIFY( is_std_format_spec_for<void*>(\"01p\") );\n+  VERIFY( is_std_format_spec_for<void*>(\"1\") );\n+  VERIFY( ! is_std_format_spec_for<void*>(\"-1\") );\n+  VERIFY( ! is_std_format_spec_for<void*>(\"-1p\") );\n+  VERIFY( ! is_std_format_spec_for<void*>(\".\") );\n+  VERIFY( ! is_std_format_spec_for<void*>(\".1\") );\n+  VERIFY( ! is_std_format_spec_for<void*>(\"c\") );\n+  VERIFY( ! is_std_format_spec_for<void*>(\"b\") );\n+  VERIFY( ! is_std_format_spec_for<void*>(\"B\") );\n+  VERIFY( ! is_std_format_spec_for<void*>(\"d\") );\n+  VERIFY( ! is_std_format_spec_for<void*>(\"o\") );\n+  VERIFY( ! is_std_format_spec_for<void*>(\"x\") );\n+  VERIFY( ! is_std_format_spec_for<void*>(\"X\") );\n+  VERIFY( ! is_std_format_spec_for<void*>(\"s\") );\n+  VERIFY( ! is_std_format_spec_for<void*>(\"?\") );\n+  VERIFY( is_std_format_spec_for<void*>(\"p\") );\n+  VERIFY( is_std_format_spec_for<void*>(\"P\") );\n+  VERIFY( ! is_std_format_spec_for<void*>(\"a\") );\n+  VERIFY( ! is_std_format_spec_for<void*>(\"A\") );\n+  VERIFY( ! is_std_format_spec_for<void*>(\"f\") );\n+  VERIFY( ! is_std_format_spec_for<void*>(\"F\") );\n+  VERIFY( ! is_std_format_spec_for<void*>(\"g\") );\n+  VERIFY( ! is_std_format_spec_for<void*>(\"G\") );\n+  VERIFY( ! is_std_format_spec_for<void*>(\"+p\") );\n+}\n+\n+void\n+test_string()\n+{\n+  VERIFY( is_std_format_spec_for<const char*>(\"\") );\n+  VERIFY( is_std_format_spec_for<const char*>(\"<\") );\n+  VERIFY( is_std_format_spec_for<const char*>(\">\") );\n+  VERIFY( is_std_format_spec_for<const char*>(\"^\") );\n+  VERIFY( is_std_format_spec_for<const char*>(\"0<\") );\n+  VERIFY( is_std_format_spec_for<const char*>(\"0>\") );\n+  VERIFY( is_std_format_spec_for<const char*>(\"0^\") );\n+  VERIFY( ! is_std_format_spec_for<const char*>(\"{^\") );\n+  VERIFY( ! is_std_format_spec_for<const char*>(\"+\") );\n+  VERIFY( ! is_std_format_spec_for<const char*>(\"-\") );\n+  VERIFY( ! is_std_format_spec_for<const char*>(\" \") );\n+  VERIFY( ! is_std_format_spec_for<const char*>(\"#\") );\n+  VERIFY( ! is_std_format_spec_for<const char*>(\"0\") );\n+  VERIFY( ! is_std_format_spec_for<const char*>(\"01s\") );\n+  VERIFY( is_std_format_spec_for<const char*>(\"1\") );\n+  VERIFY( ! is_std_format_spec_for<const char*>(\"-1\") );\n+  VERIFY( ! is_std_format_spec_for<const char*>(\"-1s\") );\n+  VERIFY( ! is_std_format_spec_for<const char*>(\".\") );\n+  VERIFY( is_std_format_spec_for<const char*>(\".1\") );\n+  VERIFY( ! is_std_format_spec_for<const char*>(\".{}\") );\n+  VERIFY(( ! is_std_format_spec_for<const char*, 1, false>(\".{1}\") ));\n+  VERIFY(( is_std_format_spec_for<const char*, 1, false>(\".{0}\") ));\n+  VERIFY(( is_std_format_spec_for<const char*, 2>(\".{}\") ));\n+  VERIFY(( is_std_format_spec_for<const char*, 2, false>(\".{1}\") ));\n+  VERIFY( ! is_std_format_spec_for<const char*>(\"c\") );\n+  VERIFY( ! is_std_format_spec_for<const char*>(\"b\") );\n+  VERIFY( ! is_std_format_spec_for<const char*>(\"B\") );\n+  VERIFY( ! is_std_format_spec_for<const char*>(\"d\") );\n+  VERIFY( ! is_std_format_spec_for<const char*>(\"o\") );\n+  VERIFY( ! is_std_format_spec_for<const char*>(\"x\") );\n+  VERIFY( ! is_std_format_spec_for<const char*>(\"X\") );\n+  VERIFY( is_std_format_spec_for<const char*>(\"s\") );\n+  VERIFY( is_std_format_spec_for<const char*>(\"?\") == escaped_strings_supported );\n+  VERIFY( ! is_std_format_spec_for<const char*>(\"p\") );\n+  VERIFY( ! is_std_format_spec_for<const char*>(\"P\") );\n+  VERIFY( ! is_std_format_spec_for<const char*>(\"a\") );\n+  VERIFY( ! is_std_format_spec_for<const char*>(\"A\") );\n+  VERIFY( ! is_std_format_spec_for<const char*>(\"f\") );\n+  VERIFY( ! is_std_format_spec_for<const char*>(\"F\") );\n+  VERIFY( ! is_std_format_spec_for<const char*>(\"g\") );\n+  VERIFY( ! is_std_format_spec_for<const char*>(\"G\") );\n+\n+  VERIFY( is_std_format_spec_for<const char*>(\"*^6s\") );\n+  VERIFY( is_std_format_spec_for<const char*>(\">6s\") );\n+  VERIFY( is_std_format_spec_for<const char*>(\"_<6.4?\") == escaped_strings_supported );\n+}\n+\n+struct S { };\n+\n+template<>\n+struct std::formatter<S, char>\n+{\n+  constexpr std::format_parse_context::iterator\n+  parse(std::format_parse_context& pc)\n+  {\n+    std::string_view spec(pc.begin(), pc.end());\n+    auto p = spec.find('}');\n+    if (p == std::string_view::npos)\n+      p = spec.size();\n+    if (p == 0)\n+      throw std::format_error(\"empty format-spec\");\n+    if (spec != \"custom\")\n+      throw std::format_error(\"invalid format-spec\");\n+    return pc.begin() + p;\n+  }\n+\n+  std::format_context::iterator\n+  format(const S&, std::format_context&) const;\n+};\n+\n+void\n+test_custom()\n+{\n+  VERIFY( is_std_format_spec_for<S>(\"custom\") );\n+  VERIFY( ! is_std_format_spec_for<S>(\"customer\") );\n+  VERIFY( ! is_std_format_spec_for<S>(\"custard\") );\n+  VERIFY( ! is_std_format_spec_for<S>(\"\") );\n+}\n+\n+int main()\n+{\n+  test_char();\n+  test_int();\n+  test_bool();\n+  test_float();\n+  test_string();\n+  test_pointer();\n+  test_custom();\n+}"}, {"sha": "e421028a873e58d81fc389867c2211ab0dcebff3", "filename": "libstdc++-v3/testsuite/std/format/string.cc", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d9454aba615eadd0d85c93713dd848227345f67/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fformat%2Fstring.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d9454aba615eadd0d85c93713dd848227345f67/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fformat%2Fstring.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fformat%2Fstring.cc?ref=1d9454aba615eadd0d85c93713dd848227345f67", "patch": "@@ -0,0 +1,131 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do run { target c++20 } }\n+\n+#include <format>\n+#include <testsuite_hooks.h>\n+\n+template<typename... Args>\n+bool\n+is_format_string_for(const char* str, Args&&... args)\n+{\n+  try {\n+    (void) std::vformat(str, std::make_format_args(args...));\n+    return true;\n+  } catch (const std::format_error&) {\n+    return false;\n+  }\n+}\n+\n+void\n+test_no_args()\n+{\n+  VERIFY( is_format_string_for(\"\") );\n+  VERIFY( is_format_string_for(\"chars\") );\n+  VERIFY( is_format_string_for(\" The Great Escape {{}} \") );\n+\n+  VERIFY( ! is_format_string_for(\"{\") );\n+  VERIFY( ! is_format_string_for(\"}\") );\n+  VERIFY( ! is_format_string_for(\"}{\") );\n+  VERIFY( ! is_format_string_for(\"{{}\") );\n+  VERIFY( ! is_format_string_for(\"{{{\") );\n+  VERIFY( ! is_format_string_for(\"{{{{{\") );\n+}\n+\n+void\n+test_indexing()\n+{\n+  VERIFY( is_format_string_for(\"{} to {}\", \"a\", \"b\") );   // automatic indexing\n+  VERIFY( is_format_string_for(\"{1} to {0}\", \"a\", \"b\") ); // manual indexing\n+  VERIFY( ! is_format_string_for(\"{0} to {}\", \"a\", \"b\") );  // mixed indexing\n+  VERIFY( ! is_format_string_for(\"{} to {1}\", \"a\", \"b\") );  // mixed indexing\n+\n+  VERIFY( is_format_string_for(\"{} {} {}\", 1, 2, 3) );\n+  VERIFY( is_format_string_for(\"{} {} {}\", 1, 2, 3, 4) );\n+  VERIFY( is_format_string_for(\"{0} {1} {2}\", 1, 2, 3, 4) );\n+  VERIFY( is_format_string_for(\"{1} {2} {3}\", 1, 2, 3, 4) );\n+  VERIFY( is_format_string_for(\"{3} {3} {3}\", 1, 2, 3, 4) );\n+\n+  VERIFY( ! is_format_string_for(\"{2}\", 1, 2) );\n+\n+  VERIFY( ! is_format_string_for(\"{0} {}\", 1) );\n+  VERIFY( ! is_format_string_for(\"{} {0}\", 1) );\n+}\n+\n+#if __cpp_lib_format_ranges\n+constexpr bool escaped_strings_supported = true;\n+#else\n+constexpr bool escaped_strings_supported = false;\n+#endif\n+\n+void\n+test_format_spec()\n+{\n+  VERIFY( is_format_string_for(\"{:}\", 1) );\n+  VERIFY( is_format_string_for(\"{0:}\", 1) );\n+  VERIFY( is_format_string_for(\"{2:}\", 1, 2, 3) );\n+  VERIFY( is_format_string_for(\"{0:s} {0:}\", \"str\") );\n+  VERIFY( is_format_string_for(\"{0:} {0:c}\", 'c') );\n+  VERIFY( is_format_string_for(\"{0:p} {0:}\", nullptr) );\n+  VERIFY( is_format_string_for(\"{:d} {:+d}\", true, true) );\n+  VERIFY( is_format_string_for(\"{:0<-#03Ld}\", 1) );\n+  VERIFY( is_format_string_for(\"{1:0<-#03.4Lf}\", 1, 2.3) );\n+  VERIFY( is_format_string_for(\"{1:3.3f}\", 1, 2.3) );\n+  VERIFY( is_format_string_for(\"{:#d}\", 'c') );\n+  VERIFY( is_format_string_for(\"{:#d}\", true) );\n+  VERIFY( is_format_string_for(\"{0:s} {0:?}\", \"str\") == escaped_strings_supported );\n+  VERIFY( is_format_string_for(\"{0:} {0:?}\", 'c') == escaped_strings_supported );\n+\n+  // Invalid sign options.\n+  VERIFY( ! is_format_string_for(\"{:+}\", \"str\") );\n+  VERIFY( ! is_format_string_for(\"{:+s}\", \"str\") );\n+  VERIFY( ! is_format_string_for(\"{:+}\", 'c') );\n+  VERIFY( ! is_format_string_for(\"{:+c}\", 'c') );\n+  VERIFY( ! is_format_string_for(\"{:+p}\", nullptr) );\n+  VERIFY( ! is_format_string_for(\"{:+}\", true) );\n+  VERIFY( ! is_format_string_for(\"{:+s}\", true) );\n+  VERIFY( ! is_format_string_for(\"{:+?}\", \"str\") );\n+  VERIFY( ! is_format_string_for(\"{:+?}\", 'c') );\n+\n+  // Invalid alternate forms.\n+  VERIFY( ! is_format_string_for(\"{:#}\", \"str\") );\n+  VERIFY( ! is_format_string_for(\"{:#s}\", \"str\") );\n+  VERIFY( ! is_format_string_for(\"{:#}\", 'c') );\n+  VERIFY( ! is_format_string_for(\"{:#c}\", 'c') );\n+  VERIFY( ! is_format_string_for(\"{:#}\", true) );\n+  VERIFY( ! is_format_string_for(\"{:#s}\", true) );\n+  VERIFY( ! is_format_string_for(\"{:#}\", nullptr) );\n+  VERIFY( ! is_format_string_for(\"{:#p}\", nullptr) );\n+  VERIFY( ! is_format_string_for(\"{:#?}\", \"str\") );\n+  VERIFY( ! is_format_string_for(\"{:#?}\", 'c') );\n+\n+  // Precision only valid for string and floating-point types.\n+  VERIFY( ! is_format_string_for(\"{:.3d}\", 1) );\n+  VERIFY( ! is_format_string_for(\"{:3.3d}\", 1) );\n+  VERIFY( is_format_string_for(\"{:3.3s}\", \"str\") );\n+  VERIFY( ! is_format_string_for(\"{:3.3s}\", 'c') );\n+  VERIFY( ! is_format_string_for(\"{:3.3p}\", nullptr) );\n+\n+  // Invalid presentation types for integers.\n+  VERIFY( ! is_format_string_for(\"{:f}\", 1) );\n+  VERIFY( ! is_format_string_for(\"{:s}\", 1) );\n+  VERIFY( ! is_format_string_for(\"{:g}\", 1) );\n+  VERIFY( ! is_format_string_for(\"{:E}\", 1) );\n+  VERIFY( ! is_format_string_for(\"{:D}\", 1) );\n+\n+  // Invalid presentation types for floating-point types.\n+  VERIFY( ! is_format_string_for(\"{:d}\", 1.2) );\n+  VERIFY( ! is_format_string_for(\"{:b}\", 1.2) );\n+  VERIFY( ! is_format_string_for(\"{:x}\", 1.2) );\n+  VERIFY( ! is_format_string_for(\"{:s}\", 1.2) );\n+\n+  // Invalid presentation types for strings.\n+  VERIFY( ! is_format_string_for(\"{:S}\", \"str\") );\n+  VERIFY( ! is_format_string_for(\"{:d}\", \"str\") );\n+}\n+\n+int main()\n+{\n+  test_no_args();\n+  test_indexing();\n+  test_format_spec();\n+}"}, {"sha": "8ec7096ffd3850d46f1c45afd3c1f9fcc914708a", "filename": "libstdc++-v3/testsuite/std/format/string_neg.cc", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d9454aba615eadd0d85c93713dd848227345f67/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fformat%2Fstring_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d9454aba615eadd0d85c93713dd848227345f67/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fformat%2Fstring_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fformat%2Fstring_neg.cc?ref=1d9454aba615eadd0d85c93713dd848227345f67", "patch": "@@ -0,0 +1,7 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do compile { target c++20 } }\n+\n+#include <format>\n+\n+auto s = std::format(\" {9} \");\n+// { dg-error \"invalid.arg.id\" \"\" { target *-*-* } 0 }"}]}