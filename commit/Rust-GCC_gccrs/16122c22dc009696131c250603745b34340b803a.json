{"sha": "16122c22dc009696131c250603745b34340b803a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTYxMjJjMjJkYzAwOTY5NjEzMWMyNTA2MDM3NDViMzQzNDBiODAzYQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2017-06-20T06:26:27Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2017-06-20T06:26:27Z"}, "message": "re PR target/79799 (Improve vec_insert of float on Power9)\n\n[gcc]\n2017-06-20  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/79799\n\t* config/rs6000/rs6000.c (rs6000_expand_vector_init): Add support\n\tfor doing vector set of SFmode on ISA 3.0.\n\t* config/rs6000/vsx.md (vsx_set_v4sf_p9): Likewise.\n\t(vsx_set_v4sf_p9_zero): Special case setting 0.0f to a V4SF\n\telement.\n\t(vsx_insert_extract_v4sf_p9): Add an optimization for inserting a\n\tSFmode value into a V4SF variable that was extracted from another\n\tV4SF variable without converting the element to double precision\n\tand back to single precision vector format.\n\t(vsx_insert_extract_v4sf_p9_2): Likewise.\n\n[gcc/testsuite]\n2017-06-20  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/79799\n\t* gcc.target/powerpc/pr79799-1.c: New test.\n\t* gcc.target/powerpc/pr79799-2.c: Likewise.\n\t* gcc.target/powerpc/pr79799-3.c: Likewise.\n\t* gcc.target/powerpc/pr79799-4.c: Likewise.\n\t* gcc.target/powerpc/pr79799-5.c: Likewise.\n\nFrom-SVN: r249395", "tree": {"sha": "46687cfe25fb0fa32e45b84869a47be42de250b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46687cfe25fb0fa32e45b84869a47be42de250b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16122c22dc009696131c250603745b34340b803a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16122c22dc009696131c250603745b34340b803a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16122c22dc009696131c250603745b34340b803a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16122c22dc009696131c250603745b34340b803a/comments", "author": null, "committer": null, "parents": [{"sha": "62be3709cdf1837a66d789a88199a29f29edb1d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62be3709cdf1837a66d789a88199a29f29edb1d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62be3709cdf1837a66d789a88199a29f29edb1d0"}], "stats": {"total": 381, "additions": 381, "deletions": 0}, "files": [{"sha": "5af9611b8370d5cd354bca2623d212fc64786d3c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16122c22dc009696131c250603745b34340b803a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16122c22dc009696131c250603745b34340b803a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=16122c22dc009696131c250603745b34340b803a", "patch": "@@ -1,3 +1,17 @@\n+2017-06-20  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/79799\n+\t* config/rs6000/rs6000.c (rs6000_expand_vector_init): Add support\n+\tfor doing vector set of SFmode on ISA 3.0.\n+\t* config/rs6000/vsx.md (vsx_set_v4sf_p9): Likewise.\n+\t(vsx_set_v4sf_p9_zero): Special case setting 0.0f to a V4SF\n+\telement.\n+\t(vsx_insert_extract_v4sf_p9): Add an optimization for inserting a\n+\tSFmode value into a V4SF variable that was extracted from another\n+\tV4SF variable without converting the element to double precision\n+\tand back to single precision vector format.\n+\t(vsx_insert_extract_v4sf_p9_2): Likewise.\n+\n 2017-06-19  Jakub Jelinek  <jakub@redhat.com>\n \n \t* tree-ssa-structalias.c (get_constraint_for_ptr_offset): Multiply"}, {"sha": "eee9d0c00f36d7c69b9a731b1e52e4e06e0e1469", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16122c22dc009696131c250603745b34340b803a/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16122c22dc009696131c250603745b34340b803a/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=16122c22dc009696131c250603745b34340b803a", "patch": "@@ -7451,6 +7451,8 @@ rs6000_expand_vector_set (rtx target, rtx val, int elt)\n \t    insn = gen_vsx_set_v8hi_p9 (target, target, val, elt_rtx);\n \t  else if (mode == V16QImode)\n \t    insn = gen_vsx_set_v16qi_p9 (target, target, val, elt_rtx);\n+\t  else if (mode == V4SFmode)\n+\t    insn = gen_vsx_set_v4sf_p9 (target, target, val, elt_rtx);\n \t}\n \n       if (insn)"}, {"sha": "4d73f0abe0a628dda11bbe971deb25b8d750d266", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16122c22dc009696131c250603745b34340b803a/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16122c22dc009696131c250603745b34340b803a/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=16122c22dc009696131c250603745b34340b803a", "patch": "@@ -3173,6 +3173,134 @@\n }\n   [(set_attr \"type\" \"vecperm\")])\n \n+(define_insn_and_split \"vsx_set_v4sf_p9\"\n+  [(set (match_operand:V4SF 0 \"gpc_reg_operand\" \"=wa\")\n+\t(unspec:V4SF\n+\t [(match_operand:V4SF 1 \"gpc_reg_operand\" \"0\")\n+\t  (match_operand:SF 2 \"gpc_reg_operand\" \"ww\")\n+\t  (match_operand:QI 3 \"const_0_to_3_operand\" \"n\")]\n+\t UNSPEC_VSX_SET))\n+   (clobber (match_scratch:SI 4 \"=&wJwK\"))]\n+  \"VECTOR_MEM_VSX_P (V4SFmode) && TARGET_P9_VECTOR && TARGET_VSX_SMALL_INTEGER\n+   && TARGET_UPPER_REGS_DI && TARGET_POWERPC64\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 5)\n+\t(unspec:V4SF [(match_dup 2)]\n+\t\t     UNSPEC_VSX_CVDPSPN))\n+   (parallel [(set (match_dup 4)\n+\t\t   (vec_select:SI (match_dup 6)\n+\t\t\t\t  (parallel [(match_dup 7)])))\n+\t      (clobber (scratch:SI))])\n+   (set (match_dup 8)\n+\t(unspec:V4SI [(match_dup 8)\n+\t\t      (match_dup 4)\n+\t\t      (match_dup 3)]\n+\t\t     UNSPEC_VSX_SET))]\n+{\n+  unsigned int tmp_regno = reg_or_subregno (operands[4]);\n+\n+  operands[5] = gen_rtx_REG (V4SFmode, tmp_regno);\n+  operands[6] = gen_rtx_REG (V4SImode, tmp_regno);\n+  operands[7] = GEN_INT (VECTOR_ELT_ORDER_BIG ? 1 : 2);\n+  operands[8] = gen_rtx_REG (V4SImode, reg_or_subregno (operands[0]));\n+}\n+  [(set_attr \"type\" \"vecperm\")\n+   (set_attr \"length\" \"12\")])\n+\n+;; Special case setting 0.0f to a V4SF element\n+(define_insn_and_split \"*vsx_set_v4sf_p9_zero\"\n+  [(set (match_operand:V4SF 0 \"gpc_reg_operand\" \"=wa\")\n+\t(unspec:V4SF\n+\t [(match_operand:V4SF 1 \"gpc_reg_operand\" \"0\")\n+\t  (match_operand:SF 2 \"zero_fp_constant\" \"j\")\n+\t  (match_operand:QI 3 \"const_0_to_3_operand\" \"n\")]\n+\t UNSPEC_VSX_SET))\n+   (clobber (match_scratch:SI 4 \"=&wJwK\"))]\n+  \"VECTOR_MEM_VSX_P (V4SFmode) && TARGET_P9_VECTOR && TARGET_VSX_SMALL_INTEGER\n+   && TARGET_UPPER_REGS_DI && TARGET_POWERPC64\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 4)\n+\t(const_int 0))\n+   (set (match_dup 5)\n+\t(unspec:V4SI [(match_dup 5)\n+\t\t      (match_dup 4)\n+\t\t      (match_dup 3)]\n+\t\t     UNSPEC_VSX_SET))]\n+{\n+  operands[5] = gen_rtx_REG (V4SImode, reg_or_subregno (operands[0]));\n+}\n+  [(set_attr \"type\" \"vecperm\")\n+   (set_attr \"length\" \"8\")])\n+\n+;; Optimize x = vec_insert (vec_extract (v2, n), v1, m) if n is the element\n+;; that is in the default scalar position (1 for big endian, 2 for little\n+;; endian).  We just need to do an xxinsertw since the element is in the\n+;; correct location.\n+\n+(define_insn \"*vsx_insert_extract_v4sf_p9\"\n+  [(set (match_operand:V4SF 0 \"gpc_reg_operand\" \"=wa\")\n+\t(unspec:V4SF\n+\t [(match_operand:V4SF 1 \"gpc_reg_operand\" \"0\")\n+\t  (vec_select:SF (match_operand:V4SF 2 \"gpc_reg_operand\" \"wa\")\n+\t\t\t (parallel\n+\t\t\t  [(match_operand:QI 3 \"const_0_to_3_operand\" \"n\")]))\n+\t  (match_operand:QI 4 \"const_0_to_3_operand\" \"n\")]\n+\t UNSPEC_VSX_SET))]\n+  \"VECTOR_MEM_VSX_P (V4SFmode) && TARGET_P9_VECTOR && TARGET_VSX_SMALL_INTEGER\n+   && TARGET_UPPER_REGS_DI && TARGET_POWERPC64\n+   && (INTVAL (operands[3]) == (VECTOR_ELT_ORDER_BIG ? 1 : 2))\"\n+{\n+  int ele = INTVAL (operands[4]);\n+\n+  if (!VECTOR_ELT_ORDER_BIG)\n+    ele = GET_MODE_NUNITS (V4SFmode) - 1 - ele;\n+\n+  operands[4] = GEN_INT (GET_MODE_SIZE (SFmode) * ele);\n+  return \"xxinsertw %x0,%x2,%4\";\n+}\n+  [(set_attr \"type\" \"vecperm\")])\n+\n+;; Optimize x = vec_insert (vec_extract (v2, n), v1, m) if n is not the element\n+;; that is in the default scalar position (1 for big endian, 2 for little\n+;; endian).  Convert the insert/extract to int and avoid doing the conversion.\n+\n+(define_insn_and_split \"*vsx_insert_extract_v4sf_p9_2\"\n+  [(set (match_operand:V4SF 0 \"gpc_reg_operand\" \"=wa\")\n+\t(unspec:V4SF\n+\t [(match_operand:V4SF 1 \"gpc_reg_operand\" \"0\")\n+\t  (vec_select:SF (match_operand:V4SF 2 \"gpc_reg_operand\" \"wa\")\n+\t\t\t (parallel\n+\t\t\t  [(match_operand:QI 3 \"const_0_to_3_operand\" \"n\")]))\n+\t  (match_operand:QI 4 \"const_0_to_3_operand\" \"n\")]\n+\t UNSPEC_VSX_SET))\n+   (clobber (match_scratch:SI 5 \"=&wJwK\"))]\n+  \"VECTOR_MEM_VSX_P (V4SFmode) && VECTOR_MEM_VSX_P (V4SImode)\n+   && TARGET_P9_VECTOR && TARGET_VSX_SMALL_INTEGER\n+   && TARGET_UPPER_REGS_DI && TARGET_POWERPC64\n+   && (INTVAL (operands[3]) != (VECTOR_ELT_ORDER_BIG ? 1 : 2))\"\n+  \"#\"\n+  \"&& 1\"\n+  [(parallel [(set (match_dup 5)\n+\t\t   (vec_select:SI (match_dup 6)\n+\t\t\t\t  (parallel [(match_dup 3)])))\n+\t      (clobber (scratch:SI))])\n+   (set (match_dup 7)\n+\t(unspec:V4SI [(match_dup 8)\n+\t\t      (match_dup 5)\n+\t\t      (match_dup 4)]\n+\t\t     UNSPEC_VSX_SET))]\n+{\n+  if (GET_CODE (operands[5]) == SCRATCH)\n+    operands[5] = gen_reg_rtx (SImode);\n+\n+  operands[6] = gen_lowpart (V4SImode, operands[2]);\n+  operands[7] = gen_lowpart (V4SImode, operands[0]);\n+  operands[8] = gen_lowpart (V4SImode, operands[1]);\n+}\n+  [(set_attr \"type\" \"vecperm\")])\n+\n ;; Expanders for builtins\n (define_expand \"vsx_mergel_<mode>\"\n   [(use (match_operand:VSX_D 0 \"vsx_register_operand\" \"\"))"}, {"sha": "0809b2cd70a92b0224140a81932b067c32013fed", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16122c22dc009696131c250603745b34340b803a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16122c22dc009696131c250603745b34340b803a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=16122c22dc009696131c250603745b34340b803a", "patch": "@@ -1,3 +1,12 @@\n+2017-06-20  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/79799\n+\t* gcc.target/powerpc/pr79799-1.c: New test.\n+\t* gcc.target/powerpc/pr79799-2.c: Likewise.\n+\t* gcc.target/powerpc/pr79799-3.c: Likewise.\n+\t* gcc.target/powerpc/pr79799-4.c: Likewise.\n+\t* gcc.target/powerpc/pr79799-5.c: Likewise.\n+\n 2017-06-19  Nathan Sidwell  <nathan@acm.org>\n \n \tPR c++/81124"}, {"sha": "87a9e49b889ed44e3bfd3bd914d98a54abd7cbaa", "filename": "gcc/testsuite/gcc.target/powerpc/pr79799-1.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16122c22dc009696131c250603745b34340b803a/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr79799-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16122c22dc009696131c250603745b34340b803a/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr79799-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr79799-1.c?ref=16122c22dc009696131c250603745b34340b803a", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-do compile { target { powerpc64*-*-* && lp64 } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9 -O2\" } */\n+\n+#include <altivec.h>\n+\n+/* GCC 7.1 did not have a specialized method for inserting 32-bit floating\n+   point on ISA 3.0 (power9) systems.  */\n+\n+vector float\n+insert_arg_0 (vector float vf, float f)\n+{\n+  return vec_insert (f, vf, 0);\n+}\n+\n+vector float\n+insert_arg_1 (vector float vf, float f)\n+{\n+  return vec_insert (f, vf, 1);\n+}\n+\n+vector float\n+insert_arg_2 (vector float vf, float f)\n+{\n+  return vec_insert (f, vf, 2);\n+}\n+\n+vector float\n+insert_arg_3 (vector float vf, float f)\n+{\n+  return vec_insert (f, vf, 3);\n+}\n+\n+/* { dg-final { scan-assembler     {\\mxscvdpspn\\M} } } */\n+/* { dg-final { scan-assembler     {\\mxxinsertw\\M} } } */\n+/* { dg-final { scan-assembler-not {\\mlvewx\\M}     } } */\n+/* { dg-final { scan-assembler-not {\\mlvx\\M}       } } */\n+/* { dg-final { scan-assembler-not {\\mvperm\\M}     } } */\n+/* { dg-final { scan-assembler-not {\\mvpermr\\M}    } } */\n+/* { dg-final { scan-assembler-not {\\mstfs\\M}      } } */\n+/* { dg-final { scan-assembler-not {\\mstxssp\\M}    } } */\n+/* { dg-final { scan-assembler-not {\\mstxsspx\\M}   } } */"}, {"sha": "793e3b9b66c0623ef07ff909082f86430b01c650", "filename": "gcc/testsuite/gcc.target/powerpc/pr79799-2.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16122c22dc009696131c250603745b34340b803a/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr79799-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16122c22dc009696131c250603745b34340b803a/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr79799-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr79799-2.c?ref=16122c22dc009696131c250603745b34340b803a", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile { target { powerpc64*-*-* && lp64 } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9 -O2\" } */\n+\n+#include <altivec.h>\n+\n+/* Optimize x = vec_insert (vec_extract (v2, N), v1, M) for SFmode if N is the default\n+   scalar position.  */\n+\n+#if __ORDER_LITTLE_ENDIAN__\n+#define ELE 2\n+#else\n+#define ELE 1\n+#endif\n+\n+vector float\n+foo (vector float v1, vector float v2)\n+{\n+  return vec_insert (vec_extract (v2, ELE), v1, 0);\n+}\n+\n+/* { dg-final { scan-assembler     {\\mxxinsertw\\M}   } } */\n+/* { dg-final { scan-assembler-not {\\mxxextractuw\\M} } } */\n+/* { dg-final { scan-assembler-not {\\mlvewx\\M}       } } */\n+/* { dg-final { scan-assembler-not {\\mlvx\\M}         } } */\n+/* { dg-final { scan-assembler-not {\\mvperm\\M}       } } */\n+/* { dg-final { scan-assembler-not {\\mvpermr\\M}      } } */\n+/* { dg-final { scan-assembler-not {\\mstfs\\M}        } } */\n+/* { dg-final { scan-assembler-not {\\mstxssp\\M}      } } */\n+/* { dg-final { scan-assembler-not {\\mstxsspx\\M}     } } */"}, {"sha": "72550421859f2fd832635912ce8e531984fd8693", "filename": "gcc/testsuite/gcc.target/powerpc/pr79799-3.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16122c22dc009696131c250603745b34340b803a/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr79799-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16122c22dc009696131c250603745b34340b803a/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr79799-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr79799-3.c?ref=16122c22dc009696131c250603745b34340b803a", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile { target { powerpc64*-*-* && lp64 } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9 -O2\" } */\n+\n+#include <altivec.h>\n+\n+/* Optimize x = vec_insert (vec_extract (v2, N), v1, M) for SFmode.  */\n+\n+vector float\n+foo (vector float v1, vector float v2)\n+{\n+  return vec_insert (vec_extract (v2, 4), v1, 0);\n+}\n+\n+/* { dg-final { scan-assembler     {\\mxxinsertw\\M}   } } */\n+/* { dg-final { scan-assembler     {\\mxxextractuw\\M} } } */\n+/* { dg-final { scan-assembler-not {\\mlvewx\\M}       } } */\n+/* { dg-final { scan-assembler-not {\\mlvx\\M}         } } */\n+/* { dg-final { scan-assembler-not {\\mvperm\\M}       } } */\n+/* { dg-final { scan-assembler-not {\\mvpermr\\M}      } } */\n+/* { dg-final { scan-assembler-not {\\mstfs\\M}        } } */\n+/* { dg-final { scan-assembler-not {\\mstxssp\\M}      } } */\n+/* { dg-final { scan-assembler-not {\\mstxsspx\\M}     } } */"}, {"sha": "056a005be2521625a0fe964b2bfce0f36df17def", "filename": "gcc/testsuite/gcc.target/powerpc/pr79799-4.c", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16122c22dc009696131c250603745b34340b803a/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr79799-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16122c22dc009696131c250603745b34340b803a/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr79799-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr79799-4.c?ref=16122c22dc009696131c250603745b34340b803a", "patch": "@@ -0,0 +1,105 @@\n+/* { dg-do run { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target p9vector_hw } */\n+/* { dg-options \"-mcpu=power9 -O2\" } */\n+\n+#include <altivec.h>\n+#include <stdlib.h>\n+\n+__attribute__ ((__noinline__))\n+vector float\n+insert_0 (vector float v, float f)\n+{\n+  return vec_insert (f, v, 0);\n+}\n+\n+__attribute__ ((__noinline__))\n+vector float\n+insert_1 (vector float v, float f)\n+{\n+  return vec_insert (f, v, 1);\n+}\n+\n+__attribute__ ((__noinline__))\n+vector float\n+insert_2 (vector float v, float f)\n+{\n+  return vec_insert (f, v, 2);\n+}\n+\n+__attribute__ ((__noinline__))\n+vector float\n+insert_3 (vector float v, float f)\n+{\n+  return vec_insert (f, v, 3);\n+}\n+\n+__attribute__ ((__noinline__))\n+void\n+test_insert (void)\n+{\n+  vector float v1 = { 1.0f, 2.0f, 3.0f, 4.0f };\n+  vector float v2 = { 5.0f, 6.0f, 7.0f, 8.0f };\n+\n+  v1 = insert_0 (v1, 5.0f);\n+  v1 = insert_1 (v1, 6.0f);\n+  v1 = insert_2 (v1, 7.0f);\n+  v1 = insert_3 (v1, 8.0f);\n+\n+  if (vec_any_ne (v1, v2))\n+    abort ();\n+}\n+\n+__attribute__ ((__noinline__))\n+vector float\n+insert_extract_0_3 (vector float v1, vector float v2)\n+{\n+  return vec_insert (vec_extract (v2, 3), v1, 0);\n+}\n+\n+__attribute__ ((__noinline__))\n+vector float\n+insert_extract_1_2 (vector float v1, vector float v2)\n+{\n+  return vec_insert (vec_extract (v2, 2), v1, 1);\n+}\n+\n+__attribute__ ((__noinline__))\n+vector float\n+insert_extract_2_1 (vector float v1, vector float v2)\n+{\n+  return vec_insert (vec_extract (v2, 1), v1, 2);\n+}\n+\n+__attribute__ ((__noinline__))\n+vector float\n+insert_extract_3_0 (vector float v1, vector float v2)\n+{\n+  return vec_insert (vec_extract (v2, 0), v1, 3);\n+}\n+\n+__attribute__ ((__noinline__))\n+void\n+test_insert_extract (void)\n+{\n+  vector float v1 = { 1.0f, 2.0f, 3.0f, 4.0f };\n+  vector float v2 = { 5.0f, 6.0f, 7.0f, 8.0f };\n+  vector float v3 = { 8.0f, 7.0f, 6.0f, 5.0f };\n+\n+  v1 = insert_extract_0_3 (v1, v2);\n+  v1 = insert_extract_1_2 (v1, v2);\n+  v1 = insert_extract_2_1 (v1, v2);\n+  v1 = insert_extract_3_0 (v1, v2);\n+\n+  if (vec_any_ne (v1, v3))\n+    abort ();\n+}\n+\n+int\n+main (void)\n+{\n+  test_insert ();\n+  test_insert_extract ();\n+  return 0;\n+}"}, {"sha": "fcd92ffd60a3897f6c094789965fcbe88beaed0a", "filename": "gcc/testsuite/gcc.target/powerpc/pr79799-5.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16122c22dc009696131c250603745b34340b803a/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr79799-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16122c22dc009696131c250603745b34340b803a/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr79799-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr79799-5.c?ref=16122c22dc009696131c250603745b34340b803a", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile { target { powerpc64*-*-* && lp64 } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9 -O2\" } */\n+\n+#include <altivec.h>\n+\n+/* Insure setting 0.0f to a V4SFmode element does not do a FP conversion.  */\n+\n+vector float\n+insert_arg_0 (vector float vf)\n+{\n+  return vec_insert (0.0f, vf, 0);\n+}\n+\n+/* { dg-final { scan-assembler     {\\mxxinsertw\\M}   } } */\n+/* { dg-final { scan-assembler-not {\\mlvewx\\M}       } } */\n+/* { dg-final { scan-assembler-not {\\mlvx\\M}         } } */\n+/* { dg-final { scan-assembler-not {\\mvperm\\M}       } } */\n+/* { dg-final { scan-assembler-not {\\mvpermr\\M}      } } */\n+/* { dg-final { scan-assembler-not {\\mstfs\\M}        } } */\n+/* { dg-final { scan-assembler-not {\\mstxssp\\M}      } } */\n+/* { dg-final { scan-assembler-not {\\mstxsspx\\M}     } } */\n+/* { dg-final { scan-assembler-not {\\mxscvdpspn\\M}   } } */\n+/* { dg-final { scan-assembler-not {\\mxxextractuw\\M} } } */"}]}