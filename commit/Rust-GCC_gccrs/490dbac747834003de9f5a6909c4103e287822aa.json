{"sha": "490dbac747834003de9f5a6909c4103e287822aa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDkwZGJhYzc0NzgzNDAwM2RlOWY1YTY5MDljNDEwM2UyODc4MjJhYQ==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "joern.rennecke@superh.com", "date": "2003-04-08T13:16:03Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2003-04-08T13:16:03Z"}, "message": "sh.c (push_regs, [...]): Return int.\n\n\t* sh.c (push_regs, calc_live_regs): Return int.  Take single\n\tHARD_REG_SET * parameter.  Changed all callers.\n\nFrom-SVN: r65373", "tree": {"sha": "d941577492136af237a3dd4efe4da515ed262f1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d941577492136af237a3dd4efe4da515ed262f1e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/490dbac747834003de9f5a6909c4103e287822aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/490dbac747834003de9f5a6909c4103e287822aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/490dbac747834003de9f5a6909c4103e287822aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/490dbac747834003de9f5a6909c4103e287822aa/comments", "author": null, "committer": null, "parents": [{"sha": "e9fcab6251336fe528de248ad37f640e3f03b450", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9fcab6251336fe528de248ad37f640e3f03b450", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9fcab6251336fe528de248ad37f640e3f03b450"}], "stats": {"total": 77, "additions": 40, "deletions": 37}, "files": [{"sha": "812b70390e6a048427099627fdce7dd3cd00200a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490dbac747834003de9f5a6909c4103e287822aa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490dbac747834003de9f5a6909c4103e287822aa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=490dbac747834003de9f5a6909c4103e287822aa", "patch": "@@ -1,3 +1,8 @@\n+2003-04-08  J\"orn Rennecke <joern.rennecke@superh.com>\n+\n+\t* sh.c (push_regs, calc_live_regs): Return int.  Take single\n+\tHARD_REG_SET * parameter.  Changed all callers.\n+\n Tue Apr  8 11:12:07 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \n \t* i386.c (legitimate_pic_address_disp_p): Do not accept PLUS in the"}, {"sha": "e939cbb5807705f90b8c98e9f3970fca855e9659", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 35, "deletions": 37, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490dbac747834003de9f5a6909c4103e287822aa/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490dbac747834003de9f5a6909c4103e287822aa/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=490dbac747834003de9f5a6909c4103e287822aa", "patch": "@@ -189,8 +189,8 @@ static void output_stack_adjust PARAMS ((int, rtx, int, rtx (*) (rtx)));\n static rtx frame_insn PARAMS ((rtx));\n static rtx push PARAMS ((int));\n static void pop PARAMS ((int));\n-static void push_regs PARAMS ((HOST_WIDE_INT *));\n-static void calc_live_regs PARAMS ((int *, HOST_WIDE_INT *));\n+static void push_regs PARAMS ((HARD_REG_SET *));\n+static int calc_live_regs PARAMS ((HARD_REG_SET *));\n static void mark_use PARAMS ((rtx, rtx *));\n static HOST_WIDE_INT rounded_frame_size PARAMS ((int));\n static rtx mark_constant_pool_use PARAMS ((rtx));\n@@ -4659,31 +4659,30 @@ pop (rn)\n \n static void\n push_regs (mask)\n-     HOST_WIDE_INT *mask;\n+     HARD_REG_SET *mask;\n {\n   int i;\n \n   /* Push PR last; this gives better latencies after the prologue, and\n      candidates for the return delay slot when there are no general\n      registers pushed.  */\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    if (i != PR_REG && mask[i / 32] & (1 << (i % 32)))\n+    if (i != PR_REG && TEST_HARD_REG_BIT (*mask, i))\n       push (i);\n-  if (mask[PR_REG / 32] & (1 << (PR_REG % 32)))\n+  if (TEST_HARD_REG_BIT (*mask, PR_REG))\n     push (PR_REG);\n }\n \n /* Work out the registers which need to be saved, both as a mask and a\n-   count of saved words.\n+   count of saved words.  Return the count.\n \n    If doing a pragma interrupt function, then push all regs used by the\n    function, and if we call another function (we can tell by looking at PR),\n    make sure that all the regs it clobbers are safe too.  */\n \n-static void\n-calc_live_regs (count_ptr, live_regs_mask)\n-     int *count_ptr;\n-     HOST_WIDE_INT *live_regs_mask;\n+static int\n+calc_live_regs (live_regs_mask)\n+     HARD_REG_SET *live_regs_mask;\n {\n   int reg;\n   int count;\n@@ -4693,7 +4692,7 @@ calc_live_regs (count_ptr, live_regs_mask)\n   interrupt_handler = sh_cfun_interrupt_handler_p ();\n \n   for (count = 0; 32 * count < FIRST_PSEUDO_REGISTER; count++)\n-    live_regs_mask[count] = 0;\n+    CLEAR_HARD_REG_SET (*live_regs_mask);\n   /* If we can save a lot of saves by switching to double mode, do that.  */\n   if (TARGET_SH4 && TARGET_FMOVD && TARGET_FPU_SINGLE)\n     for (count = 0, reg = FIRST_FP_REG; reg <= LAST_FP_REG; reg += 2)\n@@ -4752,7 +4751,7 @@ calc_live_regs (count_ptr, live_regs_mask)\n \t\t     || reg == EH_RETURN_DATA_REGNO (2)\n \t\t     || reg == EH_RETURN_DATA_REGNO (3)))))\n \t{\n-\t  live_regs_mask[reg / 32] |= 1 << (reg % 32);\n+\t  SET_HARD_REG_BIT (*live_regs_mask, reg);\n \t  count += GET_MODE_SIZE (REGISTER_NATURAL_MODE (reg));\n \n \t  if ((TARGET_SH4 || TARGET_SH5) && TARGET_FMOVD\n@@ -4762,7 +4761,7 @@ calc_live_regs (count_ptr, live_regs_mask)\n \t\t{\n \t\t  if (! TARGET_FPU_SINGLE && ! regs_ever_live[reg ^ 1])\n \t\t    {\n-\t\t      live_regs_mask[(reg ^ 1) / 32] |= 1 << ((reg ^ 1) % 32);\n+\t\t      SET_HARD_REG_BIT (*live_regs_mask, (reg ^ 1));\n \t\t      count += GET_MODE_SIZE (REGISTER_NATURAL_MODE (reg ^ 1));\n \t\t    }\n \t\t}\n@@ -4775,7 +4774,7 @@ calc_live_regs (count_ptr, live_regs_mask)\n \t}\n     }\n \n-  *count_ptr = count;\n+  return count;\n }\n \n /* Code to generate prologue and epilogue sequences */\n@@ -4817,7 +4816,7 @@ sh_media_register_for_return ()\n void\n sh_expand_prologue ()\n {\n-  HOST_WIDE_INT live_regs_mask[(FIRST_PSEUDO_REGISTER + 31) / 32];\n+  HARD_REG_SET live_regs_mask;\n   int d, i;\n   int d_rounding = 0;\n   int save_flags = target_flags;\n@@ -4909,7 +4908,7 @@ sh_expand_prologue ()\n   if (sp_switch)\n     emit_insn (gen_sp_switch_1 ());\n \n-  calc_live_regs (&d, live_regs_mask);\n+  d = calc_live_regs (&live_regs_mask);\n   /* ??? Maybe we could save some switching if we can move a mode switch\n      that already happens to be at the function start into the prologue.  */\n   if (target_flags != save_flags)\n@@ -4940,15 +4939,15 @@ sh_expand_prologue ()\n \t sh_expand_epilogue, but also sh_set_return_address.  */\n       for (align = 1; align >= 0; align--)\n \tfor (i = FIRST_PSEUDO_REGISTER - 1; i >= 0; i--)\n-\t  if (live_regs_mask[i/32] & (1 << (i % 32)))\n+\t  if (TEST_HARD_REG_BIT (live_regs_mask, i))\n \t    {\n \t      enum machine_mode mode = REGISTER_NATURAL_MODE (i);\n \t      int reg = i;\n \t      rtx reg_rtx, mem_rtx, pre_dec = NULL_RTX;\n \n \t      if (mode == SFmode && (i % 2) == 1\n \t\t  && ! TARGET_FPU_SINGLE && FP_REGISTER_P (i)\n-\t\t  && (live_regs_mask[(i ^ 1) / 32] & (1 << ((i ^ 1) % 32))))\n+\t\t  && (TEST_HARD_REG_BIT (live_regs_mask, (i ^ 1))))\n \t\t{\n \t\t  mode = DFmode;\n \t\t  i--;\n@@ -5069,7 +5068,7 @@ sh_expand_prologue ()\n \tabort ();\n     }\n   else\n-    push_regs (live_regs_mask);\n+    push_regs (&live_regs_mask);\n \n   if (flag_pic && regs_ever_live[PIC_OFFSET_TABLE_REGNUM])\n     {\n@@ -5138,14 +5137,14 @@ sh_expand_prologue ()\n void\n sh_expand_epilogue ()\n {\n-  HOST_WIDE_INT live_regs_mask[(FIRST_PSEUDO_REGISTER + 31) / 32];\n+  HARD_REG_SET live_regs_mask;\n   int d, i;\n   int d_rounding = 0;\n \n   int save_flags = target_flags;\n   int frame_size;\n \n-  calc_live_regs (&d, live_regs_mask);\n+  d = calc_live_regs (&live_regs_mask);\n \n   if (TARGET_SH5 && d % (STACK_BOUNDARY / BITS_PER_UNIT))\n     d_rounding = ((STACK_BOUNDARY / BITS_PER_UNIT)\n@@ -5206,15 +5205,15 @@ sh_expand_epilogue ()\n \t alignment.  */\n       for (align = 0; align <= 1; align++)\n \tfor (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t  if (live_regs_mask[i/32] & (1 << (i % 32)))\n+\t  if (TEST_HARD_REG_BIT (live_regs_mask, i))\n \t    {\n \t      enum machine_mode mode = REGISTER_NATURAL_MODE (i);\n \t      int reg = i;\n \t      rtx reg_rtx, mem_rtx, post_inc = NULL_RTX, insn;\n \n \t      if (mode == SFmode && (i % 2) == 0\n \t\t  && ! TARGET_FPU_SINGLE && FP_REGISTER_P (i)\n-\t\t  && (live_regs_mask[(i ^ 1) / 32] & (1 << ((i ^ 1) % 32))))\n+\t\t  && (TEST_HARD_REG_BIT (live_regs_mask, (i ^ 1))))\n \t\t{\n \t\t  mode = DFmode;\n \t\t  i++;\n@@ -5336,13 +5335,13 @@ sh_expand_epilogue ()\n     }\n   else\n     d = 0;\n-  if (live_regs_mask[PR_REG / 32] & (1 << (PR_REG % 32)))\n+  if (TEST_HARD_REG_BIT (live_regs_mask, PR_REG))\n     pop (PR_REG);\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     {\n       int j = (FIRST_PSEUDO_REGISTER - 1) - i;\n \n-      if (j != PR_REG && live_regs_mask[j / 32] & (1 << (j % 32)))\n+      if (j != PR_REG && TEST_HARD_REG_BIT (live_regs_mask, j))\n \tpop (j);\n     }\n  finish:\n@@ -5367,7 +5366,7 @@ sh_expand_epilogue ()\n   /* PR_REG will never be live in SHmedia mode, and we don't need to\n      USE PR_MEDIA_REG, since it will be explicitly copied to TR0_REG\n      by the return pattern.  */\n-  if (live_regs_mask[PR_REG / 32] & (1 << (PR_REG % 32)))\n+  if (TEST_HARD_REG_BIT (live_regs_mask, PR_REG))\n     emit_insn (gen_rtx_USE (VOIDmode, gen_rtx_REG (SImode, PR_REG)));\n }\n \n@@ -5396,17 +5395,17 @@ void\n sh_set_return_address (ra, tmp)\n      rtx ra, tmp;\n {\n-  HOST_WIDE_INT live_regs_mask[(FIRST_PSEUDO_REGISTER + 31) / 32];\n+  HARD_REG_SET live_regs_mask;\n   int d;\n   int d_rounding = 0;\n   int pr_reg = TARGET_SHMEDIA ? PR_MEDIA_REG : PR_REG;\n   int pr_offset;\n \n-  calc_live_regs (&d, live_regs_mask);\n+  d = calc_live_regs (&live_regs_mask);\n \n   /* If pr_reg isn't life, we can set it (or the register given in\n      sh_media_register_for_return) directly.  */\n-  if ((live_regs_mask[pr_reg / 32] & (1 << (pr_reg % 32))) == 0)\n+  if (! TEST_HARD_REG_BIT (live_regs_mask, pr_reg))\n     {\n       rtx rr;\n \n@@ -5446,13 +5445,13 @@ sh_set_return_address (ra, tmp)\n \t alignment.  */\n       for (align = 0; align <= 1; align++)\n \tfor (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t  if (live_regs_mask[i/32] & (1 << (i % 32)))\n+\t  if (TEST_HARD_REG_BIT (live_regs_mask, i))\n \t    {\n \t      enum machine_mode mode = REGISTER_NATURAL_MODE (i);\n \n \t      if (mode == SFmode && (i % 2) == 0\n \t\t  && ! TARGET_FPU_SINGLE && FP_REGISTER_P (i)\n-\t\t  && (live_regs_mask[(i ^ 1) / 32] & (1 << ((i ^ 1) % 32))))\n+\t\t  && (TEST_HARD_REG_BIT (live_regs_mask, (i ^ 1))))\n \t\t{\n \t\t  mode = DFmode;\n \t\t  i++;\n@@ -5931,8 +5930,8 @@ initial_elimination_offset (from, to)\n   int save_flags = target_flags;\n   int copy_flags;\n \n-  HOST_WIDE_INT live_regs_mask[(FIRST_PSEUDO_REGISTER + 31) / 32];\n-  calc_live_regs (&regs_saved, live_regs_mask);\n+  HARD_REG_SET live_regs_mask;\n+  regs_saved = calc_live_regs (&live_regs_mask);\n   regs_saved += SHMEDIA_REGS_STACK_ADJUST ();\n   if (TARGET_SH5 && regs_saved % (STACK_BOUNDARY / BITS_PER_UNIT))\n     regs_saved_rounding = ((STACK_BOUNDARY / BITS_PER_UNIT)\n@@ -5968,7 +5967,7 @@ initial_elimination_offset (from, to)\n \t  n += total_auto_space;\n \n \t  /* If it wasn't saved, there's not much we can do.  */\n-\t  if ((live_regs_mask[pr_reg / 32] & (1 << (pr_reg % 32))) == 0)\n+\t  if (! TEST_HARD_REG_BIT (live_regs_mask, pr_reg))\n \t    return n;\n \n \t  target_flags = copy_flags;\n@@ -5979,14 +5978,13 @@ initial_elimination_offset (from, to)\n \t     need 8-byte alignment.  */\n \t  for (align = 1; align >= 0; align--)\n \t    for (i = FIRST_PSEUDO_REGISTER - 1; i >= 0; i--)\n-\t      if (live_regs_mask[i/32] & (1 << (i % 32)))\n+\t      if (TEST_HARD_REG_BIT (live_regs_mask, i))\n \t\t{\n \t\t  enum machine_mode mode = REGISTER_NATURAL_MODE (i);\n \n \t\t  if (mode == SFmode && (i % 2) == 1\n \t\t      && ! TARGET_FPU_SINGLE && FP_REGISTER_P (i)\n-\t\t      && (live_regs_mask[(i ^ 1) / 32]\n-\t\t\t  & (1 << ((i ^ 1) % 32))))\n+\t\t      && TEST_HARD_REG_BIT (live_regs_mask, (i ^ 1)))\n \t\t    {\n \t\t      mode = DFmode;\n \t\t      i--;"}]}