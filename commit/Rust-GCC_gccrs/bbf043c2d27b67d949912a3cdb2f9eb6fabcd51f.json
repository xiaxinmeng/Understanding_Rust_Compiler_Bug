{"sha": "bbf043c2d27b67d949912a3cdb2f9eb6fabcd51f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmJmMDQzYzJkMjdiNjdkOTQ5OTEyYTNjZGIyZjllYjZmYWJjZDUxZg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2015-03-25T09:58:18Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2015-03-25T09:58:18Z"}, "message": "re PR lto/65515 (FAIL: gcc.c-torture/compile/limits-fndefn.c   -O2 -flto -flto-partition=none  (ICE) -- SIGSEGV for stack growth failure)\n\n\tPR lto/65515\n\t* lto-streamer-out.c (DFS::worklist): New struct.\n\t(DFS::worklist_vec): New data member.\n\t(DFS::next_dfs_num): Remove.\n\t(DFS::DFS): Rewritten using worklist instead of recursion,\n\tusing most of code from DFS::DFS_write_tree.\n\t(DFS::DFS_write_tree_body): Remove SINGLE_P argument, don't\n\tpass it to DFS_write_tree calls.\n\t(DFS::DFS_write_tree): Remove SINGLE_P argument, after\n\tquick initial checks push it into worklist_vec and return.\n\nFrom-SVN: r221656", "tree": {"sha": "8113424d7db51b59ce435d864dcea6727fee41de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8113424d7db51b59ce435d864dcea6727fee41de"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bbf043c2d27b67d949912a3cdb2f9eb6fabcd51f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbf043c2d27b67d949912a3cdb2f9eb6fabcd51f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbf043c2d27b67d949912a3cdb2f9eb6fabcd51f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbf043c2d27b67d949912a3cdb2f9eb6fabcd51f/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ea348bbe596297d82466a2000dc4c14d2ddc5eac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea348bbe596297d82466a2000dc4c14d2ddc5eac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea348bbe596297d82466a2000dc4c14d2ddc5eac"}], "stats": {"total": 401, "additions": 226, "deletions": 175}, "files": [{"sha": "f450b7d87995f91d1f3d99e8ebb97b3837002fcc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbf043c2d27b67d949912a3cdb2f9eb6fabcd51f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbf043c2d27b67d949912a3cdb2f9eb6fabcd51f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bbf043c2d27b67d949912a3cdb2f9eb6fabcd51f", "patch": "@@ -1,3 +1,16 @@\n+2015-03-25  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR lto/65515\n+\t* lto-streamer-out.c (DFS::worklist): New struct.\n+\t(DFS::worklist_vec): New data member.\n+\t(DFS::next_dfs_num): Remove.\n+\t(DFS::DFS): Rewritten using worklist instead of recursion,\n+\tusing most of code from DFS::DFS_write_tree.\n+\t(DFS::DFS_write_tree_body): Remove SINGLE_P argument, don't\n+\tpass it to DFS_write_tree calls.\n+\t(DFS::DFS_write_tree): Remove SINGLE_P argument, after\n+\tquick initial checks push it into worklist_vec and return.\n+\n 2015-03-25  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/65519"}, {"sha": "d36cfbcc3e5e14f3f02df9559726b0588365fadd", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 213, "deletions": 175, "changes": 388, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbf043c2d27b67d949912a3cdb2f9eb6fabcd51f/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbf043c2d27b67d949912a3cdb2f9eb6fabcd51f/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=bbf043c2d27b67d949912a3cdb2f9eb6fabcd51f", "patch": "@@ -485,31 +485,225 @@ class DFS\n     unsigned int dfsnum;\n     unsigned int low;\n   };\n+  struct worklist\n+  {\n+    tree expr;\n+    sccs *from_state;\n+    sccs *cstate;\n+    bool ref_p;\n+    bool this_ref_p;\n+  };\n \n   static int scc_entry_compare (const void *, const void *);\n \n   void DFS_write_tree_body (struct output_block *ob,\n-\t\t\t    tree expr, sccs *expr_state, bool ref_p,\n-\t\t\t    bool single_p);\n+\t\t\t    tree expr, sccs *expr_state, bool ref_p);\n \n   void DFS_write_tree (struct output_block *ob, sccs *from_state,\n-\t\t       tree expr, bool ref_p, bool this_ref_p,\n-\t\t       bool single_p);\n+\t\t       tree expr, bool ref_p, bool this_ref_p);\n+\n   hashval_t\n   hash_scc (struct output_block *ob, unsigned first, unsigned size);\n \n-  unsigned int next_dfs_num;\n   hash_map<tree, sccs *> sccstate;\n+  vec<worklist> worklist_vec;\n   struct obstack sccstate_obstack;\n };\n \n DFS::DFS (struct output_block *ob, tree expr, bool ref_p, bool this_ref_p,\n \t  bool single_p)\n {\n+  unsigned int next_dfs_num = 1;\n   sccstack.create (0);\n   gcc_obstack_init (&sccstate_obstack);\n-  next_dfs_num = 1;\n-  DFS_write_tree (ob, NULL, expr, ref_p, this_ref_p, single_p);\n+  worklist_vec = vNULL;\n+  DFS_write_tree (ob, NULL, expr, ref_p, this_ref_p);\n+  while (!worklist_vec.is_empty ())\n+    {\n+      worklist &w = worklist_vec.last ();\n+      expr = w.expr;\n+      sccs *from_state = w.from_state;\n+      sccs *cstate = w.cstate;\n+      ref_p = w.ref_p;\n+      this_ref_p = w.this_ref_p;\n+      if (cstate == NULL)\n+\t{\n+\t  sccs **slot = &sccstate.get_or_insert (expr);\n+\t  cstate = *slot;\n+\t  if (cstate)\n+\t    {\n+\t      gcc_checking_assert (from_state);\n+\t      if (cstate->dfsnum < from_state->dfsnum)\n+\t\tfrom_state->low = MIN (cstate->dfsnum, from_state->low);\n+\t      worklist_vec.pop ();\n+\t      continue;\n+\t    }\n+\n+\t  scc_entry e = { expr, 0 };\n+\t  /* Not yet visited.  DFS recurse and push it onto the stack.  */\n+\t  *slot = cstate = XOBNEW (&sccstate_obstack, struct sccs);\n+\t  sccstack.safe_push (e);\n+\t  cstate->dfsnum = next_dfs_num++;\n+\t  cstate->low = cstate->dfsnum;\n+\t  w.cstate = cstate;\n+\n+\t  if (streamer_handle_as_builtin_p (expr))\n+\t    ;\n+\t  else if (TREE_CODE (expr) == INTEGER_CST\n+\t\t   && !TREE_OVERFLOW (expr))\n+\t    DFS_write_tree (ob, cstate, TREE_TYPE (expr), ref_p, ref_p);\n+\t  else\n+\t    {\n+\t      DFS_write_tree_body (ob, expr, cstate, ref_p);\n+\n+\t      /* Walk any LTO-specific edges.  */\n+\t      if (DECL_P (expr)\n+\t\t  && TREE_CODE (expr) != FUNCTION_DECL\n+\t\t  && TREE_CODE (expr) != TRANSLATION_UNIT_DECL)\n+\t\t{\n+\t\t  /* Handle DECL_INITIAL for symbols.  */\n+\t\t  tree initial\n+\t\t    = get_symbol_initial_value (ob->decl_state->symtab_node_encoder,\n+\t\t\t\t\t\texpr);\n+\t\t  DFS_write_tree (ob, cstate, initial, ref_p, ref_p);\n+\t\t}\n+\t    }\n+\t  continue;\n+\t}\n+\n+      /* See if we found an SCC.  */\n+      if (cstate->low == cstate->dfsnum)\n+\t{\n+\t  unsigned first, size;\n+\t  tree x;\n+\n+\t  /* If we are re-walking a single leaf-SCC just pop it,\n+\t     let earlier worklist item access the sccstack.  */\n+\t  if (single_p)\n+\t    {\n+\t      worklist_vec.pop ();\n+\t      continue;\n+\t    }\n+\n+\t  /* Pop the SCC and compute its size.  */\n+\t  first = sccstack.length ();\n+\t  do\n+\t    {\n+\t      x = sccstack[--first].t;\n+\t    }\n+\t  while (x != expr);\n+\t  size = sccstack.length () - first;\n+\n+\t  /* No need to compute hashes for LTRANS units, we don't perform\n+\t     any merging there.  */\n+\t  hashval_t scc_hash = 0;\n+\t  unsigned scc_entry_len = 0;\n+\t  if (!flag_wpa)\n+\t    {\n+\t      scc_hash = hash_scc (ob, first, size);\n+\n+\t      /* Put the entries with the least number of collisions first.  */\n+\t      unsigned entry_start = 0;\n+\t      scc_entry_len = size + 1;\n+\t      for (unsigned i = 0; i < size;)\n+\t\t{\n+\t\t  unsigned from = i;\n+\t\t  for (i = i + 1; i < size\n+\t\t       && (sccstack[first + i].hash\n+\t\t\t   == sccstack[first + from].hash); ++i)\n+\t\t    ;\n+\t\t  if (i - from < scc_entry_len)\n+\t\t    {\n+\t\t      scc_entry_len = i - from;\n+\t\t      entry_start = from;\n+\t\t    }\n+\t\t}\n+\t      for (unsigned i = 0; i < scc_entry_len; ++i)\n+\t\t{\n+\t\t  scc_entry tem = sccstack[first + i];\n+\t\t  sccstack[first + i] = sccstack[first + entry_start + i];\n+\t\t  sccstack[first + entry_start + i] = tem;\n+\t\t}\n+\n+\t      if (scc_entry_len == 1)\n+\t\t; /* We already sorted SCC deterministically in hash_scc.  */\n+\t      else\n+\t\t/* Check that we have only one SCC.\n+\t\t   Naturally we may have conflicts if hash function is not\n+ \t\t   strong enough.  Lets see how far this gets.  */\n+\t\t{\n+#ifdef ENABLE_CHECKING\n+\t\t  gcc_unreachable ();\n+#endif\n+\t\t}\n+\t    }\n+\n+\t  /* Write LTO_tree_scc.  */\n+\t  streamer_write_record_start (ob, LTO_tree_scc);\n+\t  streamer_write_uhwi (ob, size);\n+\t  streamer_write_uhwi (ob, scc_hash);\n+\n+\t  /* Write size-1 SCCs without wrapping them inside SCC bundles.\n+\t     All INTEGER_CSTs need to be handled this way as we need\n+\t     their type to materialize them.  Also builtins are handled\n+\t     this way.\n+\t     ???  We still wrap these in LTO_tree_scc so at the\n+\t     input side we can properly identify the tree we want\n+\t     to ultimatively return.  */\n+\t  if (size == 1)\n+\t    lto_output_tree_1 (ob, expr, scc_hash, ref_p, this_ref_p);\n+\t  else\n+\t    {\n+\t      /* Write the size of the SCC entry candidates.  */\n+\t      streamer_write_uhwi (ob, scc_entry_len);\n+\n+\t      /* Write all headers and populate the streamer cache.  */\n+\t      for (unsigned i = 0; i < size; ++i)\n+\t\t{\n+\t\t  hashval_t hash = sccstack[first+i].hash;\n+\t\t  tree t = sccstack[first+i].t;\n+\t\t  bool exists_p = streamer_tree_cache_insert (ob->writer_cache,\n+\t\t\t\t\t\t\t      t, hash, NULL);\n+\t\t  gcc_assert (!exists_p);\n+\n+\t\t  if (!lto_is_streamable (t))\n+\t\t    internal_error (\"tree code %qs is not supported \"\n+\t\t\t\t    \"in LTO streams\",\n+\t\t\t\t    get_tree_code_name (TREE_CODE (t)));\n+\n+\t\t  gcc_checking_assert (!streamer_handle_as_builtin_p (t));\n+\n+\t\t  /* Write the header, containing everything needed to\n+\t\t     materialize EXPR on the reading side.  */\n+\t\t  streamer_write_tree_header (ob, t);\n+\t\t}\n+\n+\t      /* Write the bitpacks and tree references.  */\n+\t      for (unsigned i = 0; i < size; ++i)\n+\t\t{\n+\t\t  lto_write_tree_1 (ob, sccstack[first+i].t, ref_p);\n+\n+\t\t  /* Mark the end of the tree.  */\n+\t\t  streamer_write_zero (ob);\n+\t\t}\n+\t    }\n+\n+\t  /* Finally truncate the vector.  */\n+\t  sccstack.truncate (first);\n+\n+\t  if (from_state)\n+\t    from_state->low = MIN (from_state->low, cstate->low);\n+\t  worklist_vec.pop ();\n+\t  continue;\n+\t}\n+\n+      gcc_checking_assert (from_state);\n+      from_state->low = MIN (from_state->low, cstate->low);\n+      if (cstate->dfsnum < from_state->dfsnum)\n+\tfrom_state->low = MIN (cstate->dfsnum, from_state->low);\n+      worklist_vec.pop ();\n+    }\n+  worklist_vec.release ();\n }\n \n DFS::~DFS ()\n@@ -523,11 +717,10 @@ DFS::~DFS ()\n \n void\n DFS::DFS_write_tree_body (struct output_block *ob,\n-\t\t\t  tree expr, sccs *expr_state, bool ref_p,\n-\t\t\t  bool single_p)\n+\t\t\t  tree expr, sccs *expr_state, bool ref_p)\n {\n #define DFS_follow_tree_edge(DEST) \\\n-  DFS_write_tree (ob, expr_state, DEST, ref_p, ref_p, single_p)\n+  DFS_write_tree (ob, expr_state, DEST, ref_p, ref_p)\n \n   enum tree_code code;\n \n@@ -680,7 +873,7 @@ DFS::DFS_write_tree_body (struct output_block *ob,\n \t  /* We have to stream externals in the block chain as\n \t     non-references.  See also\n \t     tree-streamer-out.c:streamer_write_chain.  */\n-\t  DFS_write_tree (ob, expr_state, t, ref_p, false, single_p);\n+\t  DFS_write_tree (ob, expr_state, t, ref_p, false);\n \telse\n \t  DFS_follow_tree_edge (t);\n \n@@ -1339,10 +1532,8 @@ DFS::hash_scc (struct output_block *ob,\n \n void\n DFS::DFS_write_tree (struct output_block *ob, sccs *from_state,\n-\t\t     tree expr, bool ref_p, bool this_ref_p, bool single_p)\n+\t\t     tree expr, bool ref_p, bool this_ref_p)\n {\n-  unsigned ix;\n-\n   /* Handle special cases.  */\n   if (expr == NULL_TREE)\n     return;\n@@ -1352,169 +1543,16 @@ DFS::DFS_write_tree (struct output_block *ob, sccs *from_state,\n     return;\n \n   /* Check if we already streamed EXPR.  */\n-  if (streamer_tree_cache_lookup (ob->writer_cache, expr, &ix))\n+  if (streamer_tree_cache_lookup (ob->writer_cache, expr, NULL))\n     return;\n \n-  sccs **slot = &sccstate.get_or_insert (expr);\n-  sccs *cstate = *slot;\n-  if (!cstate)\n-    {\n-      scc_entry e = { expr, 0 };\n-      /* Not yet visited.  DFS recurse and push it onto the stack.  */\n-      *slot = cstate = XOBNEW (&sccstate_obstack, struct sccs);\n-      sccstack.safe_push (e);\n-      cstate->dfsnum = next_dfs_num++;\n-      cstate->low = cstate->dfsnum;\n-\n-      if (streamer_handle_as_builtin_p (expr))\n-\t;\n-      else if (TREE_CODE (expr) == INTEGER_CST\n-\t       && !TREE_OVERFLOW (expr))\n-\tDFS_write_tree (ob, cstate, TREE_TYPE (expr), ref_p, ref_p, single_p);\n-      else\n-\t{\n-\t  DFS_write_tree_body (ob, expr, cstate, ref_p, single_p);\n-\n-\t  /* Walk any LTO-specific edges.  */\n-\t  if (DECL_P (expr)\n-\t      && TREE_CODE (expr) != FUNCTION_DECL\n-\t      && TREE_CODE (expr) != TRANSLATION_UNIT_DECL)\n-\t    {\n-\t      /* Handle DECL_INITIAL for symbols.  */\n-\t      tree initial = get_symbol_initial_value (ob->decl_state->symtab_node_encoder,\n-\t\t\t\t\t\t       expr);\n-\t      DFS_write_tree (ob, cstate, initial, ref_p, ref_p, single_p);\n-\t    }\n-\t}\n-\n-      /* See if we found an SCC.  */\n-      if (cstate->low == cstate->dfsnum)\n-\t{\n-\t  unsigned first, size;\n-\t  tree x;\n-\n-\t  /* If we are re-walking a single leaf-SCC just return and\n-\t     let the caller access the sccstack.  */\n-\t  if (single_p)\n-\t    return;\n-\n-\t  /* Pop the SCC and compute its size.  */\n-\t  first = sccstack.length ();\n-\t  do\n-\t    {\n-\t      x = sccstack[--first].t;\n-\t    }\n-\t  while (x != expr);\n-\t  size = sccstack.length () - first;\n-\n-\t  /* No need to compute hashes for LTRANS units, we don't perform\n-\t     any merging there.  */\n-\t  hashval_t scc_hash = 0;\n-\t  unsigned scc_entry_len = 0;\n-\t  if (!flag_wpa)\n-\t    {\n-\t      scc_hash = hash_scc (ob, first, size);\n-\n-\t      /* Put the entries with the least number of collisions first.  */\n-\t      unsigned entry_start = 0;\n-\t      scc_entry_len = size + 1;\n-\t      for (unsigned i = 0; i < size;)\n-\t\t{\n-\t\t  unsigned from = i;\n-\t\t  for (i = i + 1; i < size\n-\t\t       && (sccstack[first + i].hash\n-\t\t\t   == sccstack[first + from].hash); ++i)\n-\t\t    ;\n-\t\t  if (i - from < scc_entry_len)\n-\t\t    {\n-\t\t      scc_entry_len = i - from;\n-\t\t      entry_start = from;\n-\t\t    }\n-\t\t}\n-\t      for (unsigned i = 0; i < scc_entry_len; ++i)\n-\t\t{\n-\t\t  scc_entry tem = sccstack[first + i];\n-\t\t  sccstack[first + i] = sccstack[first + entry_start + i];\n-\t\t  sccstack[first + entry_start + i] = tem;\n-\t\t}\n-\n-\t      if (scc_entry_len == 1)\n-\t\t; /* We already sorted SCC deterministically in hash_scc.  */\n-\t      else\n-\t\t/* Check that we have only one SCC.\n-\t\t   Naturally we may have conflicts if hash function is not\n- \t\t   strong enough.  Lets see how far this gets.  */\n-\t\t{\n-#ifdef ENABLE_CHECKING\n-\t\t  gcc_unreachable ();\n-#endif\n-\t\t}\n-\t    }\n-\n-\t  /* Write LTO_tree_scc.  */\n-\t  streamer_write_record_start (ob, LTO_tree_scc);\n-\t  streamer_write_uhwi (ob, size);\n-\t  streamer_write_uhwi (ob, scc_hash);\n-\n-\t  /* Write size-1 SCCs without wrapping them inside SCC bundles.\n-\t     All INTEGER_CSTs need to be handled this way as we need\n-\t     their type to materialize them.  Also builtins are handled\n-\t     this way.\n-\t     ???  We still wrap these in LTO_tree_scc so at the\n-\t     input side we can properly identify the tree we want\n-\t     to ultimatively return.  */\n-\t  if (size == 1)\n-\t    lto_output_tree_1 (ob, expr, scc_hash, ref_p, this_ref_p);\n-\t  else\n-\t    {\n-\t      /* Write the size of the SCC entry candidates.  */\n-\t      streamer_write_uhwi (ob, scc_entry_len);\n-\n-\t      /* Write all headers and populate the streamer cache.  */\n-\t      for (unsigned i = 0; i < size; ++i)\n-\t\t{\n-\t\t  hashval_t hash = sccstack[first+i].hash;\n-\t\t  tree t = sccstack[first+i].t;\n-\t\t  bool exists_p = streamer_tree_cache_insert (ob->writer_cache,\n-\t\t\t\t\t\t\t      t, hash, &ix);\n-\t\t  gcc_assert (!exists_p);\n-\n-\t\t  if (!lto_is_streamable (t))\n-\t\t    internal_error (\"tree code %qs is not supported \"\n-\t\t\t\t    \"in LTO streams\",\n-\t\t\t\t    get_tree_code_name (TREE_CODE (t)));\n-\n-\t\t  gcc_checking_assert (!streamer_handle_as_builtin_p (t));\n-\n-\t\t  /* Write the header, containing everything needed to\n-\t\t     materialize EXPR on the reading side.  */\n-\t\t  streamer_write_tree_header (ob, t);\n-\t\t}\n-\n-\t      /* Write the bitpacks and tree references.  */\n-\t      for (unsigned i = 0; i < size; ++i)\n-\t\t{\n-\t\t  lto_write_tree_1 (ob, sccstack[first+i].t, ref_p);\n-\n-\t\t  /* Mark the end of the tree.  */\n-\t\t  streamer_write_zero (ob);\n-\t\t}\n-\t    }\n-\n-\t  /* Finally truncate the vector.  */\n-\t  sccstack.truncate (first);\n-\n-\t  if (from_state)\n-\t    from_state->low = MIN (from_state->low, cstate->low);\n-\t  return;\n-\t}\n-\n-      if (from_state)\n-\tfrom_state->low = MIN (from_state->low, cstate->low);\n-    }\n-  gcc_checking_assert (from_state);\n-  if (cstate->dfsnum < from_state->dfsnum)\n-    from_state->low = MIN (cstate->dfsnum, from_state->low);\n+  worklist w;\n+  w.expr = expr;\n+  w.from_state = from_state;\n+  w.cstate = NULL;\n+  w.ref_p = ref_p;\n+  w.this_ref_p = this_ref_p;\n+  worklist_vec.safe_push (w);\n }\n \n "}]}