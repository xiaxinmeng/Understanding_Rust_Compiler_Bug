{"sha": "0021b564f4ce0b648a8d6ec49b29afe609370788", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDAyMWI1NjRmNGNlMGI2NDhhOGQ2ZWM0OWIyOWFmZTYwOTM3MDc4OA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1997-09-10T18:00:28Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1997-09-10T18:00:28Z"}, "message": "dwarf2 EH support\n\nFrom-SVN: r15255", "tree": {"sha": "0928096722cf7e87c6973bd7bb029f787ab959db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0928096722cf7e87c6973bd7bb029f787ab959db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0021b564f4ce0b648a8d6ec49b29afe609370788", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0021b564f4ce0b648a8d6ec49b29afe609370788", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0021b564f4ce0b648a8d6ec49b29afe609370788", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0021b564f4ce0b648a8d6ec49b29afe609370788/comments", "author": null, "committer": null, "parents": [{"sha": "0680d170431a1a44f958ca97a9ce01ea12b676b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0680d170431a1a44f958ca97a9ce01ea12b676b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0680d170431a1a44f958ca97a9ce01ea12b676b6"}], "stats": {"total": 1374, "additions": 1210, "deletions": 164}, "files": [{"sha": "94dc196a6a17b246dcb9775d3edf54387a281ddf", "filename": "gcc/c-decl.c", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0021b564f4ce0b648a8d6ec49b29afe609370788/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0021b564f4ce0b648a8d6ec49b29afe609370788/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=0021b564f4ce0b648a8d6ec49b29afe609370788", "patch": "@@ -2849,7 +2849,7 @@ init_decl_processing ()\n   tree traditional_ptr_type_node;\n   /* Data types of memcpy and strlen.  */\n   tree memcpy_ftype, memset_ftype, strlen_ftype;\n-  tree void_ftype_any;\n+  tree void_ftype_any, ptr_ftype_void, ptr_ftype_ptr;\n   int wchar_type_size;\n   tree temp;\n   tree array_domain_type;\n@@ -3165,6 +3165,11 @@ init_decl_processing ()\n \t\t\t\t\t\t\t    sizetype,\n \t\t\t\t\t\t\t    endlink))));\n \n+  ptr_ftype_void = build_function_type (ptr_type_node, endlink);\n+  ptr_ftype_ptr\n+    = build_function_type (ptr_type_node,\n+\t\t\t   tree_cons (NULL_TREE, ptr_type_node, endlink));\n+\n   builtin_function (\"__builtin_constant_p\", default_function_type,\n \t\t    BUILT_IN_CONSTANT_P, NULL_PTR);\n \n@@ -3186,6 +3191,36 @@ init_decl_processing ()\n \t\t    build_function_type (ptr_type_node, NULL_TREE),\n \t\t    BUILT_IN_AGGREGATE_INCOMING_ADDRESS, NULL_PTR);\n \n+  /* Hooks for the DWARF 2 __throw routine.  */\n+  builtin_function (\"__builtin_unwind_init\",\n+\t\t    build_function_type (void_type_node, endlink),\n+\t\t    BUILT_IN_UNWIND_INIT, NULL_PTR);\n+  builtin_function (\"__builtin_fp\", ptr_ftype_void, BUILT_IN_FP, NULL_PTR);\n+  builtin_function (\"__builtin_sp\", ptr_ftype_void, BUILT_IN_SP, NULL_PTR);\n+  builtin_function (\"__builtin_dwarf_fp_regnum\",\n+\t\t    build_function_type (unsigned_type_node, endlink),\n+\t\t    BUILT_IN_DWARF_FP_REGNUM, NULL_PTR);\n+  builtin_function (\"__builtin_frob_return_addr\", ptr_ftype_ptr,\n+\t\t    BUILT_IN_FROB_RETURN_ADDR, NULL_PTR);\n+  builtin_function (\"__builtin_extract_return_addr\", ptr_ftype_ptr,\n+\t\t    BUILT_IN_EXTRACT_RETURN_ADDR, NULL_PTR);\n+  builtin_function (\"__builtin_set_return_addr_reg\",\n+\t\t    build_function_type (void_type_node, \n+\t\t\t\t\t tree_cons (NULL_TREE,\n+\t\t\t\t\t\t    ptr_type_node,\n+\t\t\t\t\t\t    endlink)),\n+\t\t    BUILT_IN_SET_RETURN_ADDR_REG, NULL_PTR);\n+  builtin_function (\"__builtin_eh_stub\", ptr_ftype_void,\n+\t\t    BUILT_IN_EH_STUB, NULL_PTR);\n+  builtin_function\n+    (\"__builtin_set_eh_regs\",\n+     build_function_type (void_type_node,\n+\t\t\t  tree_cons (NULL_TREE, ptr_type_node,\n+\t\t\t\t     tree_cons (NULL_TREE,\n+\t\t\t\t\t\ttype_for_mode (ptr_mode, 0),\n+\t\t\t\t\t\tendlink))),\n+     BUILT_IN_SET_EH_REGS, NULL_PTR);\n+\n   builtin_function (\"__builtin_alloca\",\n \t\t    build_function_type (ptr_type_node,\n \t\t\t\t\t tree_cons (NULL_TREE,"}, {"sha": "576bc74669f808627934bc48135bb6e8b2ee9359", "filename": "gcc/collect2.c", "status": "modified", "additions": 71, "deletions": 8, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0021b564f4ce0b648a8d6ec49b29afe609370788/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0021b564f4ce0b648a8d6ec49b29afe609370788/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=0021b564f4ce0b648a8d6ec49b29afe609370788", "patch": "@@ -239,6 +239,7 @@ static char *initname, *fininame;\t/* names of init and fini funcs */\n static struct head constructors;\t/* list of constructors found */\n static struct head destructors;\t\t/* list of destructors found */\n static struct head exports;\t\t/* list of exported symbols */\n+static struct head frame_tables;\t/* list of frame unwind info tables */\n \n struct obstack temporary_obstack;\n struct obstack permanent_obstack;\n@@ -599,13 +600,16 @@ is_ctor_dtor (s)\n #ifdef NO_DOT_IN_LABEL\n     { \"GLOBAL__I_\", sizeof (\"GLOBAL__I_\")-1, 1, 0 },\n     { \"GLOBAL__D_\", sizeof (\"GLOBAL__D_\")-1, 2, 0 },\n+    { \"GLOBAL__F_\", sizeof (\"GLOBAL__F_\")-1, 5, 0 },\n #else\n     { \"GLOBAL_.I.\", sizeof (\"GLOBAL_.I.\")-1, 1, 0 },\n     { \"GLOBAL_.D.\", sizeof (\"GLOBAL_.D.\")-1, 2, 0 },\n+    { \"GLOBAL_.F.\", sizeof (\"GLOBAL_.F.\")-1, 5, 0 },\n #endif\n #else\n     { \"GLOBAL_$I$\", sizeof (\"GLOBAL_$I$\")-1, 1, 0 },\n     { \"GLOBAL_$D$\", sizeof (\"GLOBAL_$D$\")-1, 2, 0 },\n+    { \"GLOBAL_$F$\", sizeof (\"GLOBAL_$F$\")-1, 5, 0 },\n #endif\n     { \"GLOBAL__FI_\", sizeof (\"GLOBAL__FI_\")-1, 3, 0 },\n     { \"GLOBAL__FD_\", sizeof (\"GLOBAL__FD_\")-1, 4, 0 },\n@@ -993,6 +997,7 @@ main (argc, argv)\n \tnum_c_args++;\n     }\n   obstack_free (&temporary_obstack, temporary_firstobj);\n+  ++num_c_args;\n \n   c_ptr = c_argv = (char **) xcalloc (sizeof (char *), num_c_args);\n \n@@ -1288,6 +1293,7 @@ main (argc, argv)\n \tshared_obj = 1;\n     }\n   obstack_free (&temporary_obstack, temporary_firstobj);\n+  *c_ptr++ = \"-fno-exceptions\";\n \n #ifdef COLLECT_EXPORT_LIST\n   /* The AIX linker will discard static constructors in object files if\n@@ -1396,7 +1402,8 @@ main (argc, argv)\n     }\n \n   if (constructors.number == 0 && destructors.number == 0\n-#ifdef LDD_SUFFIX\n+      && frame_tables.number == 0\n+#ifdef SCAN_LIBRARIES\n       /* If we will be running these functions ourselves, we want to emit\n \t stubs into the shared library so that we don't have to relink\n \t dependent programs when we add static objects.  */\n@@ -1690,6 +1697,7 @@ write_c_file_stat (stream, name)\n      char *name;\n {\n   char *prefix, *p, *q;\n+  int frames = (frame_tables.number > 0);\n \n   /* Figure out name of output_file, stripping off .so version.  */\n   p = rindex (output_file, '/');\n@@ -1743,32 +1751,57 @@ write_c_file_stat (stream, name)\n   fprintf (stream, \"static int count;\\n\");\n   fprintf (stream, \"typedef void entry_pt();\\n\");\n   write_list_with_asm (stream, \"extern entry_pt \", constructors.first);\n+\n+  if (frames)\n+    {\n+      write_list_with_asm (stream, \"extern void *\", frame_tables.first);\n+\n+      fprintf (stream, \"\\tstatic void *frame_table[] = {\\n\");\n+      write_list (stream, \"\\t\\t&\", frame_tables.first);\n+      fprintf (stream, \"\\t0\\n};\\n\");\n+\n+      fprintf (stream, \"extern void __register_frame_table (void *);\\n\");\n+      fprintf (stream, \"extern void __deregister_frame (void *);\\n\");\n+\n+      fprintf (stream, \"static void reg_frame () {\\n\");\n+      fprintf (stream, \"\\t__register_frame_table (frame_table);\\n\");\n+      fprintf (stream, \"\\t}\\n\");\n+\n+      fprintf (stream, \"static void dereg_frame () {\\n\");\n+      fprintf (stream, \"\\t__deregister_frame (frame_table);\\n\");\n+      fprintf (stream, \"\\t}\\n\");\n+    }\n+\n   fprintf (stream, \"void %s() {\\n\", initname);\n-  if (constructors.number > 0)\n+  if (constructors.number > 0 || frames)\n     {\n       fprintf (stream, \"\\tstatic entry_pt *ctors[] = {\\n\");\n       write_list (stream, \"\\t\\t\", constructors.first);\n+      if (frames)\n+\tfprintf (stream, \"\\treg_frame,\\n\");\n       fprintf (stream, \"\\t};\\n\");\n       fprintf (stream, \"\\tentry_pt **p;\\n\");\n       fprintf (stream, \"\\tif (count++ != 0) return;\\n\");\n-      fprintf (stream, \"\\tp = ctors + %d;\\n\", constructors.number);\n+      fprintf (stream, \"\\tp = ctors + %d;\\n\", constructors.number + frames);\n       fprintf (stream, \"\\twhile (p > ctors) (*--p)();\\n\");\n     }\n   else\n     fprintf (stream, \"\\t++count;\\n\");\n   fprintf (stream, \"}\\n\");\n   write_list_with_asm (stream, \"extern entry_pt \", destructors.first);\n   fprintf (stream, \"void %s() {\\n\", fininame);\n-  if (destructors.number > 0)\n+  if (destructors.number > 0 || frames)\n     {\n       fprintf (stream, \"\\tstatic entry_pt *dtors[] = {\\n\");\n       write_list (stream, \"\\t\\t\", destructors.first);\n+      if (frames)\n+\tfprintf (stream, \"\\tdereg_frame,\\n\");\n       fprintf (stream, \"\\t};\\n\");\n       fprintf (stream, \"\\tentry_pt **p;\\n\");\n       fprintf (stream, \"\\tif (--count != 0) return;\\n\");\n       fprintf (stream, \"\\tp = dtors;\\n\");\n       fprintf (stream, \"\\twhile (p < dtors + %d) (*p++)();\\n\",\n-\t       destructors.number);\n+\t       destructors.number + frames);\n     }\n   fprintf (stream, \"}\\n\");\n \n@@ -1788,20 +1821,46 @@ write_c_file_glob (stream, name)\n {\n   /* Write the tables as C code  */\n \n+  int frames = (frame_tables.number > 0);\n+\n   fprintf (stream, \"typedef void entry_pt();\\n\\n\");\n     \n   write_list_with_asm (stream, \"extern entry_pt \", constructors.first);\n-    \n+\n+  if (frames)\n+    {\n+      write_list_with_asm (stream, \"extern void *\", frame_tables.first);\n+\n+      fprintf (stream, \"\\tstatic void *frame_table[] = {\\n\");\n+      write_list (stream, \"\\t\\t&\", frame_tables.first);\n+      fprintf (stream, \"\\t0\\n};\\n\");\n+\n+      fprintf (stream, \"extern void __register_frame_table (void *);\\n\");\n+      fprintf (stream, \"extern void __deregister_frame (void *);\\n\");\n+\n+      fprintf (stream, \"static void reg_frame () {\\n\");\n+      fprintf (stream, \"\\t__register_frame_table (frame_table);\\n\");\n+      fprintf (stream, \"\\t}\\n\");\n+\n+      fprintf (stream, \"static void dereg_frame () {\\n\");\n+      fprintf (stream, \"\\t__deregister_frame (frame_table);\\n\");\n+      fprintf (stream, \"\\t}\\n\");\n+    }\n+\n   fprintf (stream, \"\\nentry_pt * __CTOR_LIST__[] = {\\n\");\n-  fprintf (stream, \"\\t(entry_pt *) %d,\\n\", constructors.number);\n+  fprintf (stream, \"\\t(entry_pt *) %d,\\n\", constructors.number + frames);\n   write_list (stream, \"\\t\", constructors.first);\n+  if (frames)\n+    fprintf (stream, \"\\treg_frame,\\n\");\n   fprintf (stream, \"\\t0\\n};\\n\\n\");\n \n   write_list_with_asm (stream, \"extern entry_pt \", destructors.first);\n \n   fprintf (stream, \"\\nentry_pt * __DTOR_LIST__[] = {\\n\");\n-  fprintf (stream, \"\\t(entry_pt *) %d,\\n\", destructors.number);\n+  fprintf (stream, \"\\t(entry_pt *) %d,\\n\", destructors.number + frames);\n   write_list (stream, \"\\t\", destructors.first);\n+  if (frames)\n+    fprintf (stream, \"\\tdereg_frame,\\n\");\n   fprintf (stream, \"\\t0\\n};\\n\\n\");\n \n   fprintf (stream, \"extern entry_pt %s;\\n\", NAME__MAIN);\n@@ -1985,6 +2044,10 @@ scan_prog_file (prog_name, which_pass)\n #endif\n \t  break;\n \n+\tcase 5:\n+\t  if (which_pass != PASS_LIB)\n+\t    add_to_list (&frame_tables, name);\n+\n \tdefault:\t\t/* not a constructor or destructor */\n \t  continue;\n \t}"}, {"sha": "fafdabc91b4ef589a02b89dee26b405c96e958d8", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0021b564f4ce0b648a8d6ec49b29afe609370788/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0021b564f4ce0b648a8d6ec49b29afe609370788/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=0021b564f4ce0b648a8d6ec49b29afe609370788", "patch": "@@ -1866,6 +1866,7 @@ function_prologue (file, size)\n   int pic_reg_used = flag_pic && (current_function_uses_pic_offset_table\n \t\t\t\t  || current_function_uses_const_pool);\n   long tsize = get_frame_size ();\n+  int cfa_offset = INCOMING_FRAME_SP_OFFSET, cfa_store_offset = cfa_offset;\n \n   /* pic references don't explicitly mention pic_offset_table_rtx */\n   if (TARGET_SCHEDULE_PROLOGUE)\n@@ -1881,13 +1882,34 @@ function_prologue (file, size)\n   if (frame_pointer_needed)\n     {\n       output_asm_insn (\"push%L1 %1\", xops); \n+      if (dwarf2out_do_frame ())\n+\t{\n+\t  char *l = (char *) dwarf2out_cfi_label ();\n+\t  cfa_store_offset += 4;\n+\t  cfa_offset = cfa_store_offset;\n+\t  dwarf2out_def_cfa (l, STACK_POINTER_REGNUM, cfa_offset);\n+\t  dwarf2out_reg_save (l, FRAME_POINTER_REGNUM, -cfa_store_offset);\n+\t}\n       output_asm_insn (AS2 (mov%L0,%0,%1), xops); \n+      if (dwarf2out_do_frame ())\n+\tdwarf2out_def_cfa (\"\", FRAME_POINTER_REGNUM, cfa_offset);\n     }\n \n   if (tsize == 0)\n     ;\n   else if (! TARGET_STACK_PROBE || tsize < CHECK_STACK_LIMIT)\n-    output_asm_insn (AS2 (sub%L0,%2,%0), xops);\n+    {\n+      output_asm_insn (AS2 (sub%L0,%2,%0), xops);\n+      if (dwarf2out_do_frame ())\n+\t{\n+\t  cfa_store_offset += tsize;\n+\t  if (! frame_pointer_needed)\n+\t    {\n+\t      cfa_offset = cfa_store_offset;\n+\t      dwarf2out_def_cfa (\"\", STACK_POINTER_REGNUM, cfa_offset);\n+\t    }\n+\t}\n+    }\n   else \n     {\n       xops[3] = gen_rtx (REG, SImode, 0);\n@@ -1913,6 +1935,17 @@ function_prologue (file, size)\n       {\n \txops[0] = gen_rtx (REG, SImode, regno);\n \toutput_asm_insn (\"push%L0 %0\", xops);\n+\tif (dwarf2out_do_frame ())\n+\t  {\n+\t    char *l = (char *) dwarf2out_cfi_label ();\n+\t    cfa_store_offset += 4;\n+\t    if (! frame_pointer_needed)\n+\t      {\n+\t\tcfa_offset = cfa_store_offset;\n+\t\tdwarf2out_def_cfa (l, STACK_POINTER_REGNUM, cfa_offset);\n+\t      }\n+\t    dwarf2out_reg_save (l, regno, -cfa_store_offset);\n+\t  }\n       }\n \n   if (pic_reg_used && TARGET_DEEP_BRANCH_PREDICTION)"}, {"sha": "86746d11e845a57cc1164cca365af7d6119da239", "filename": "gcc/config/mips/iris6.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0021b564f4ce0b648a8d6ec49b29afe609370788/gcc%2Fconfig%2Fmips%2Firis6.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0021b564f4ce0b648a8d6ec49b29afe609370788/gcc%2Fconfig%2Fmips%2Firis6.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Firis6.h?ref=0021b564f4ce0b648a8d6ec49b29afe609370788", "patch": "@@ -249,6 +249,10 @@ Boston, MA 02111-1307, USA.  */\n   (TARGET_LONG64 ? \".section\\t.dtors,1,2,0,8\" : \".section\\t.dtors,1,2,0,4\")\n #endif /* defined (CRT_BEGIN) || defined (CRT_END) */\n \n+/* dwarf2out will handle padding this data properly.  We definitely don't\n+   want it 8-byte aligned on n32.  */\n+#define EH_FRAME_SECTION_ASM_OP \".section\\t.eh_frame,1,2,0,1\"\n+\n /* A default list of other sections which we might be \"in\" at any given\n    time.  For targets that use additional sections (e.g. .tdesc) you\n    should override this definition in the target-specific file which\n@@ -538,5 +542,5 @@ do {\t\t\t\t\t\t\t\t\t \\\n %{!static: \\\n   %{!shared: %{!non_shared: %{!call_shared: -call_shared -no_unresolved}}}} \\\n %{rpath} -init __do_global_ctors -fini __do_global_dtors \\\n-%{shared:-hidden_symbol __do_global_ctors,__do_global_dtors} \\\n+%{shared:-hidden_symbol __do_global_ctors,__do_global_dtors,__EH_FRAME_BEGIN__} \\\n -_SYSTYPE_SVR4 %{mabi=32: -32}%{mabi=n32: -n32}%{mabi=64: -64} %{!mabi*: -n32}\""}, {"sha": "ffbea137862d9863f0e261951e427b95d487f561", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0021b564f4ce0b648a8d6ec49b29afe609370788/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0021b564f4ce0b648a8d6ec49b29afe609370788/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=0021b564f4ce0b648a8d6ec49b29afe609370788", "patch": "@@ -5241,6 +5241,9 @@ function_prologue (file, size)\n \t\t   sp_str, sp_str, tsize);\n \t  fprintf (file, \"\\t.cprestore %d\\n\", current_frame_info.args_size);\n \t}\n+\n+      if (dwarf2out_do_frame ())\n+\tdwarf2out_def_cfa (\"\", STACK_POINTER_REGNUM, tsize);\n     }\n }\n "}, {"sha": "fba9d0a1ce8bed4121706745e46e39a6759118c4", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0021b564f4ce0b648a8d6ec49b29afe609370788/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0021b564f4ce0b648a8d6ec49b29afe609370788/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=0021b564f4ce0b648a8d6ec49b29afe609370788", "patch": "@@ -948,12 +948,11 @@ while (0)\n #define DBX_REGISTER_NUMBER(REGNO) mips_dbx_regno[ (REGNO) ]\n \n /* The mapping from gcc register number to DWARF 2 CFA column number.\n-   This mapping does not allow for tracking DBX register 0, since column 0\n-   is used for the frame address, but since register 0 is fixed this is\n-   not really a problem.  */\n+   This mapping does not allow for tracking register 0, since SGI's broken\n+   dwarf reader thinks column 0 is used for the frame address, but since\n+   register 0 is fixed this is not a problem.  */\n #define DWARF_FRAME_REGNUM(REG)\t\t\t\t\\\n-  (REG == GP_REG_FIRST + 31 ? DWARF_FRAME_RETURN_COLUMN\t\\\n-   : DBX_REGISTER_NUMBER (REG))\n+  (REG == GP_REG_FIRST + 31 ? DWARF_FRAME_RETURN_COLUMN : REG)\n \n /* The DWARF 2 CFA column which tracks the return address.  */\n #define DWARF_FRAME_RETURN_COLUMN (FP_REG_LAST + 1)"}, {"sha": "f040aa7608ec5ddc142b8f238157167ff780481a", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 13, "deletions": 39, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0021b564f4ce0b648a8d6ec49b29afe609370788/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0021b564f4ce0b648a8d6ec49b29afe609370788/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=0021b564f4ce0b648a8d6ec49b29afe609370788", "patch": "@@ -2910,10 +2910,8 @@ save_regs (file, low, high, base, offset, n_regs, real_offset)\n \t    {\n \t      fprintf (file, \"\\tstx %s,[%s+%d]\\n\",\n \t\t       reg_names[i], base, offset + 4 * n_regs);\n-#ifdef DWARF2_DEBUGGING_INFO\n-\t      if (write_symbols == DWARF2_DEBUG)\n+\t      if (dwarf2out_do_frame ())\n \t\tdwarf2out_reg_save (\"\", i, real_offset + 4 * n_regs);\n-#endif\n \t      n_regs += 2;\n \t    }\n \t}\n@@ -2927,34 +2925,28 @@ save_regs (file, low, high, base, offset, n_regs, real_offset)\n \t      {\n \t\tfprintf (file, \"\\tstd %s,[%s+%d]\\n\",\n \t\t\t reg_names[i], base, offset + 4 * n_regs);\n-#ifdef DWARF2_DEBUGGING_INFO\n-\t\tif (write_symbols == DWARF2_DEBUG)\n+\t\tif (dwarf2out_do_frame ())\n \t\t  {\n \t\t    char *l = (char *) dwarf2out_cfi_label ();\n \t\t    dwarf2out_reg_save (l, i, real_offset + 4 * n_regs);\n \t\t    dwarf2out_reg_save (l, i+1, real_offset + 4 * n_regs + 4);\n \t\t  }\n-#endif\n \t\tn_regs += 2;\n \t      }\n \t    else\n \t      {\n \t\tfprintf (file, \"\\tst %s,[%s+%d]\\n\",\n \t\t\t reg_names[i], base, offset + 4 * n_regs);\n-#ifdef DWARF2_DEBUGGING_INFO\n-\t\tif (write_symbols == DWARF2_DEBUG)\n+\t\tif (dwarf2out_do_frame ())\n \t\t  dwarf2out_reg_save (\"\", i, real_offset + 4 * n_regs);\n-#endif\n \t\tn_regs += 2;\n \t      }\n \t  else if (regs_ever_live[i+1] && ! call_used_regs[i+1])\n \t    {\n \t      fprintf (file, \"\\tst %s,[%s+%d]\\n\",\n \t\t       reg_names[i+1], base, offset + 4 * n_regs + 4);\n-#ifdef DWARF2_DEBUGGING_INFO\n-\t      if (write_symbols == DWARF2_DEBUG)\n+\t      if (dwarf2out_do_frame ())\n \t\tdwarf2out_reg_save (\"\", i + 1, real_offset + 4 * n_regs + 4);\n-#endif\n \t      n_regs += 2;\n \t    }\n \t}\n@@ -3196,8 +3188,7 @@ output_function_prologue (file, size, leaf_function)\n \t}\n     }\n \n-#ifdef DWARF2_DEBUGGING_INFO\n-  if (write_symbols == DWARF2_DEBUG && actual_fsize)\n+  if (dwarf2out_do_frame () && actual_fsize)\n     {\n       char *label = (char *) dwarf2out_cfi_label ();\n \n@@ -3217,7 +3208,6 @@ output_function_prologue (file, size, leaf_function)\n \t  dwarf2out_return_reg (label, 31);\n \t}\n     }\n-#endif\n \n   /* If doing anything with PIC, do it now.  */\n   if (! flag_pic)\n@@ -4739,15 +4729,13 @@ sparc_flat_save_restore (file, base_reg, offset, gmask, fmask, word_op, doublewo\n \t\t      fprintf (file, \"\\t%s %s,[%s+%d]\\n\",\n \t\t\t       doubleword_op, reg_names[regno],\n \t\t\t       base_reg, offset);\n-#ifdef DWARF2_DEBUGGING_INFO\n-\t\t      if (write_symbols == DWARF2_DEBUG)\n+\t\t      if (dwarf2out_do_frame ())\n \t\t\t{\n \t\t\t  char *l = (char *) dwarf2out_cfi_label ();\n \t\t\t  dwarf2out_reg_save (l, regno, offset + base_offset);\n \t\t\t  dwarf2out_reg_save\n \t\t\t    (l, regno+1, offset+base_offset + UNITS_PER_WORD);\n \t\t\t}\n-#endif\n \t\t    }\n \t\t  else\n \t\t    fprintf (file, \"\\t%s [%s+%d],%s\\n\",\n@@ -4764,10 +4752,8 @@ sparc_flat_save_restore (file, base_reg, offset, gmask, fmask, word_op, doublewo\n \t\t      fprintf (file, \"\\t%s %s,[%s+%d]\\n\",\n \t\t\t       word_op, reg_names[regno],\n \t\t\t       base_reg, offset);\n-#ifdef DWARF2_DEBUGGING_INFO\n-\t\t      if (write_symbols == DWARF2_DEBUG)\n+\t\t      if (dwarf2out_do_frame ())\n \t\t\tdwarf2out_reg_save (\"\", regno, offset + base_offset);\n-#endif\n \t\t    }\n \t\t  else\n \t\t    fprintf (file, \"\\t%s [%s+%d],%s\\n\",\n@@ -4790,10 +4776,8 @@ sparc_flat_save_restore (file, base_reg, offset, gmask, fmask, word_op, doublewo\n \t\t  fprintf (file, \"\\t%s %s,[%s+%d]\\n\",\n \t\t\t   word_op, reg_names[regno],\n \t\t\t   base_reg, offset);\n-#ifdef DWARF2_DEBUGGING_INFO\n-\t\t  if (write_symbols == DWARF2_DEBUG)\n+\t\t  if (dwarf2out_do_frame ())\n \t\t    dwarf2out_reg_save (\"\", regno, offset + base_offset);\n-#endif\n \t\t}\n \t      else\n \t\tfprintf (file, \"\\t%s [%s+%d],%s\\n\",\n@@ -4891,8 +4875,7 @@ sparc_flat_output_function_prologue (file, size)\n \t\t  reg_offset += 4;\n \t\t}\n \t    }\n-#ifdef DWARF2_DEBUGGING_INFO\n-\t  if (write_symbols == DWARF2_DEBUG)\n+\t  if (dwarf2out_do_frame ())\n \t    {\n \t      char *l = (char *) dwarf2out_cfi_label ();\n \t      if (gmask & FRAME_POINTER_MASK)\n@@ -4904,15 +4887,12 @@ sparc_flat_output_function_prologue (file, size)\n \t      else\n \t\tdwarf2out_def_cfa (l, STACK_POINTER_REGNUM, size);\n \t    }\n-#endif\n \t  if (gmask & RETURN_ADDR_MASK)\n \t    {\n \t      fprintf (file, \"\\tst %s,[%s+%d]\\n\",\n \t\t       reg_names[RETURN_ADDR_REGNUM], sp_str, reg_offset);\n-#ifdef DWARF2_DEBUGGING_INFO\n-\t      if (write_symbols == DWARF2_DEBUG)\n+\t      if (dwarf2out_do_frame ())\n \t\tdwarf2out_return_save (\"\", reg_offset - size);\n-#endif\n \t      reg_offset += 4;\n \t    }\n \t  sparc_flat_save_restore (file, sp_str, reg_offset,\n@@ -4951,8 +4931,7 @@ sparc_flat_output_function_prologue (file, size)\n \t\t  offset += 4;\n \t\t}\n \t    }\n-#ifdef DWARF2_DEBUGGING_INFO\n-\t  if (write_symbols == DWARF2_DEBUG)\n+\t  if (dwarf2out_do_frame ())\n \t    {\n \t      char *l = (char *) dwarf2out_cfi_label ();\n \t      if (gmask & FRAME_POINTER_MASK)\n@@ -4964,17 +4943,14 @@ sparc_flat_output_function_prologue (file, size)\n \t      else\n \t\tdwarf2out_def_cfa (l, STACK_POINTER_REGNUM, size1);\n \t    }\n-#endif\n \t  if (gmask & RETURN_ADDR_MASK)\n \t    {\n \t      fprintf (file, \"\\tst %s,[%s+%d]\\n\",\n \t\t       reg_names[RETURN_ADDR_REGNUM], sp_str, offset);\n-#ifdef DWARF2_DEBUGGING_INFO\n-\t      if (write_symbols == DWARF2_DEBUG)\n+\t      if (dwarf2out_do_frame ())\n \t\t/* offset - size1 == reg_offset - size\n \t\t   if reg_offset were updated above like offset.  */\n \t\tdwarf2out_return_save (\"\", offset - size1);\n-#endif\n \t      offset += 4;\n \t    }\n \t  sparc_flat_save_restore (file, sp_str, offset,\n@@ -4983,11 +4959,9 @@ sparc_flat_output_function_prologue (file, size)\n \t\t\t\t   \"st\", \"std\", -size1);\n \t  fprintf (file, \"\\tset %d,%s\\n\\tsub %s,%s,%s\\n\",\n \t\t   size - size1, t1_str, sp_str, t1_str, sp_str);\n-#ifdef DWARF2_DEBUGGING_INFO\n-\t  if (write_symbols == DWARF2_DEBUG)\n+\t  if (dwarf2out_do_frame ())\n \t    if (! (gmask & FRAME_POINTER_MASK))\n \t      dwarf2out_def_cfa (\"\", STACK_POINTER_REGNUM, size);\n-#endif\n \t}\n     }\n "}, {"sha": "070f41aa3b5e1ff2c757d9ccc7f63e8427b5ba35", "filename": "gcc/config/sparc/sunos4.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0021b564f4ce0b648a8d6ec49b29afe609370788/gcc%2Fconfig%2Fsparc%2Fsunos4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0021b564f4ce0b648a8d6ec49b29afe609370788/gcc%2Fconfig%2Fsparc%2Fsunos4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsunos4.h?ref=0021b564f4ce0b648a8d6ec49b29afe609370788", "patch": "@@ -25,3 +25,6 @@ Boston, MA 02111-1307, USA.  */\n #define DBX_USE_BINCL\n \n #include \"sparc/sparc.h\"\n+\n+/* The Sun as doesn't like unaligned data.  */\n+#define DWARF2_UNWIND_INFO 0"}, {"sha": "cdb7cd6a2bbe6f81ce683ee7a1ccca2440b0e260", "filename": "gcc/config/sparc/sysv4.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0021b564f4ce0b648a8d6ec49b29afe609370788/gcc%2Fconfig%2Fsparc%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0021b564f4ce0b648a8d6ec49b29afe609370788/gcc%2Fconfig%2Fsparc%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsysv4.h?ref=0021b564f4ce0b648a8d6ec49b29afe609370788", "patch": "@@ -91,6 +91,7 @@ Boston, MA 02111-1307, USA.  */\n #define STRING_ASM_OP\t\t\".asciz\"\n #define COMMON_ASM_OP\t\t\".common\"\n #define SKIP_ASM_OP\t\t\".skip\"\n+#define UNALIGNED_DOUBLE_INT_ASM_OP \".uaxword\"\n #define UNALIGNED_INT_ASM_OP\t\".uaword\"\n #define UNALIGNED_SHORT_ASM_OP\t\".uahalf\"\n #define PUSHSECTION_ASM_OP\t\".pushsection\"\n@@ -179,6 +180,8 @@ do { ASM_OUTPUT_ALIGN ((FILE), Pmode == SImode ? 2 : 3);\t\t\\\n #define CTORS_SECTION_ASM_OP    \".section\\t\\\".ctors\\\",#alloc,#write\"\n #undef DTORS_SECTION_ASM_OP\n #define DTORS_SECTION_ASM_OP    \".section\\t\\\".dtors\\\",#alloc,#write\"\n+#undef EH_FRAME_SECTION_ASM_OP\n+#define EH_FRAME_SECTION_ASM_OP \".section\\t\\\".eh_frame\\\",#alloc,#write\"\n \n /* A C statement to output something to the assembler file to switch to section\n    NAME for object DECL which is either a FUNCTION_DECL, a VAR_DECL or"}, {"sha": "0f313f5e7ec8baece6784f93cdc89f27b14de6fb", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0021b564f4ce0b648a8d6ec49b29afe609370788/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0021b564f4ce0b648a8d6ec49b29afe609370788/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=0021b564f4ce0b648a8d6ec49b29afe609370788", "patch": "@@ -2934,7 +2934,7 @@ finish_file ()\n       rest_of_decl_compilation (TREE_VALUE (vars), 0, 1, 1);\n   vars = static_aggregates;\n \n-  if (static_ctors || vars || exception_table_p ())\n+  if (static_ctors || vars || register_exception_table_p ())\n     needs_messing_up = 1;\n   if (static_dtors)\n     needs_cleaning = 1;\n@@ -3033,7 +3033,7 @@ finish_file ()\n       push_momentary ();\n       expand_start_bindings (0);\n \n-      if (exception_table_p ())\n+      if (register_exception_table_p ())\n \tregister_exception_table ();\n \n       while (vars)"}, {"sha": "355485af399ca452ba2fdff5e9df565629d662e6", "filename": "gcc/cp/except.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0021b564f4ce0b648a8d6ec49b29afe609370788/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0021b564f4ce0b648a8d6ec49b29afe609370788/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=0021b564f4ce0b648a8d6ec49b29afe609370788", "patch": "@@ -33,6 +33,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"output.h\"\n #include \"except.h\"\n #include \"function.h\"\n+#include \"defaults.h\"\n \n rtx expand_builtin_return_addr\tPROTO((enum built_in_function, int, rtx));\n \n@@ -609,7 +610,8 @@ do_unwind (inner_throw_label)\n      rtx inner_throw_label;\n {\n #if defined (SPARC_STACK_ALIGN) /* was sparc */\n-  /* This doesn't work for the flat model sparc, I bet.  */\n+  /* This doesn't work for the flat model sparc, nor does it need to\n+     as the default unwinder is only used to unwind non-flat frames.  */\n   tree fcall;\n   tree params;\n   rtx next_pc;\n@@ -704,6 +706,7 @@ do_unwind (inner_throw_label)\n void\n expand_builtin_throw ()\n {\n+#ifndef DWARF2_UNWIND_INFO\n   tree fcall;\n   tree params;\n   rtx handler;\n@@ -897,6 +900,7 @@ expand_builtin_throw ()\n   pop_momentary ();\n \n   finish_function (lineno, 0, 0);\n+#endif /* DWARF2_UNWIND_INFO */\n }\n \n \n@@ -1149,7 +1153,6 @@ expand_throw (exp)\n \t  expand_expr (object, const0_rtx, VOIDmode, 0);\n \t  end_anon_func ();\n \t  mark_addressable (cleanup);\n-\n \t}\n \n       if (cleanup == empty_fndecl)"}, {"sha": "587f0a293ace9dc2182faccca30521978c5ddc0e", "filename": "gcc/cp/gxxint.texi", "status": "modified", "additions": 44, "deletions": 18, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0021b564f4ce0b648a8d6ec49b29afe609370788/gcc%2Fcp%2Fgxxint.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0021b564f4ce0b648a8d6ec49b29afe609370788/gcc%2Fcp%2Fgxxint.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fgxxint.texi?ref=0021b564f4ce0b648a8d6ec49b29afe609370788", "patch": "@@ -1185,29 +1185,28 @@ arrays.  Exception specifications are now handled.  Thrown objects are\n now cleaned up all the time.  We can now tell if we have an active\n exception being thrown or not (__eh_type != 0).  We use this to call\n terminate if someone does a throw; without there being an active\n-exception object.  uncaught_exception () works.\n+exception object.  uncaught_exception () works.  Exception handling\n+should work right if you optimize.  Exception handling should work with\n+-fpic or -fPIC.\n \n The below points out some flaws in g++'s exception handling, as it now\n stands.\n \n Only exact type matching or reference matching of throw types works when\n--fno-rtti is used.  Only works on a SPARC (like Suns), SPARClite, i386,\n-arm, rs6000, PowerPC, Alpha, mips, VAX, m68k and z8k machines.  Partial\n-support is in for all other machines, but a stack unwinder called\n-__unwind_function has to be written, and added to libgcc2 for them.  The\n-new EH code doesn't rely upon the __unwind_function for C++ code,\n-instead it creates per function unwinders right inside the function,\n-unfortunately, on many platforms the definition of RETURN_ADDR_RTX in\n-the tm.h file for the machine port is wrong.  The HPPA has a brain dead\n-abi that prevents exception handling from just working.  See below for\n-details on __unwind_function.  Don't expect exception handling to work\n-right if you optimize, in fact the compiler will probably core dump.\n-RTL_EXPRs for EH cond variables for && and || exprs should probably be\n-wrapped in UNSAVE_EXPRs, and RTL_EXPRs tweaked so that they can be\n-unsaved, and the UNSAVE_EXPR code should be in the backend, or\n-alternatively, UNSAVE_EXPR should be ripped out and exactly one\n-finalization allowed to be expanded by the backend.  I talked with\n-kenner about this, and we have to allow multiple expansions.\n+-fno-rtti is used.  Only works on a SPARC (like Suns) (both -mflat and\n+-mno-flat models work), SPARClite, Hitachi SH, i386, arm, rs6000,\n+PowerPC, Alpha, mips, VAX, m68k and z8k machines.  SPARC v9 may not\n+work.  HPPA is mostly done, but throwing between a shared library and\n+user code doesn't yet work.  Some targets have support for data-driven\n+unwinding.  Partial support is in for all other machines, but a stack\n+unwinder called __unwind_function has to be written, and added to\n+libgcc2 for them.  The new EH code doesn't rely upon the\n+__unwind_function for C++ code, instead it creates per function\n+unwinders right inside the function, unfortunately, on many platforms\n+the definition of RETURN_ADDR_RTX in the tm.h file for the machine port\n+is wrong.  See below for details on __unwind_function.  RTL_EXPRs for EH\n+cond variables for && and || exprs should probably be wrapped in\n+UNSAVE_EXPRs, and RTL_EXPRs tweaked so that they can be unsaved.\n \n We only do pointer conversions on exception matching a la 15.3 p2 case\n 3: `A handler with type T, const T, T&, or const T& is a match for a\n@@ -1397,6 +1396,33 @@ things: first, a way to figure out where the frame pointer was stored,\n and second, a functional @code{__builtin_return_address} implementation\n for except.c to be able to use it.\n \n+Or just support DWARF 2 unwind info.\n+\n+@subsection New Backend Exception Support\n+\n+This subsection discusses various aspects of the design of the\n+data-driven model being implemented for the exception handling backend.\n+\n+The goal is to generate enough data during the compilation of user code,\n+such that we can dynamically unwind through functions at run time with a\n+single routine (@code{__throw}) that lives in libgcc.a, built by the\n+compiler, and dispatch into associated exception handlers.\n+\n+This information is generated by the DWARF 2 debugging backend, and\n+includes all of the information __throw needs to unwind an arbitrary\n+frame.  It specifies where all of the saved registers and the return\n+address can be found at any point in the function.\n+\n+Major disadvantages when enabling exceptions are:\n+\n+@itemize @bullet\n+@item\n+Code that uses caller saved registers, can't, when flow can be\n+transfered into that code from an exception handler.  In high performace\n+code this should not usually be true, so the effects should be minimal.\n+\n+@end itemize\n+\n @subsection Backend Exception Support\n \n The backend must be extended to fully support exceptions.  Right now"}, {"sha": "bcb5cc50bf0b820f78a08c1d05891261c3522a3e", "filename": "gcc/crtstuff.c", "status": "modified", "additions": 64, "deletions": 2, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0021b564f4ce0b648a8d6ec49b29afe609370788/gcc%2Fcrtstuff.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0021b564f4ce0b648a8d6ec49b29afe609370788/gcc%2Fcrtstuff.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcrtstuff.c?ref=0021b564f4ce0b648a8d6ec49b29afe609370788", "patch": "@@ -52,6 +52,7 @@ Boston, MA 02111-1307, USA.  */\n    do not apply.  */\n \n #include \"tm.h\"\n+#include \"defaults.h\"\n \n /* Provide default definitions for the pseudo-ops used to switch to the\n    .ctors and .dtors sections.\n@@ -75,6 +76,9 @@ Boston, MA 02111-1307, USA.  */\n #ifndef DTORS_SECTION_ASM_OP\n #define DTORS_SECTION_ASM_OP\t\".section\\t.dtors,\\\"aw\\\"\"\n #endif\n+#if !defined (EH_FRAME_SECTION_ASM_OP) && defined (DWARF2_UNWIND_INFO) && defined(ASM_OUTPUT_SECTION_NAME)\n+#define EH_FRAME_SECTION_ASM_OP\t\".section\\t.eh_frame,\\\"aw\\\"\"\n+#endif\n \n #ifdef OBJECT_FORMAT_ELF\n \n@@ -118,6 +122,7 @@ typedef void (*func_ptr) (void);\n    the list we left off processing, and we resume at that point,\n    should we be re-invoked.  */\n \n+static char __EH_FRAME_BEGIN__[];\n static func_ptr __DTOR_LIST__[];\n static void\n __do_global_dtors_aux ()\n@@ -128,6 +133,10 @@ __do_global_dtors_aux ()\n       p++;\n       (*(p-1)) ();\n     }\n+\n+#ifdef EH_FRAME_SECTION_ASM_OP\n+  __deregister_frame (__EH_FRAME_BEGIN__);\n+#endif\n }\n \n /* Stick a call to __do_global_dtors_aux into the .fini section.  */\n@@ -143,6 +152,29 @@ fini_dummy ()\n   asm (TEXT_SECTION_ASM_OP);\n }\n \n+#ifdef EH_FRAME_SECTION_ASM_OP\n+/* Stick a call to __register_frame into the .init section.  For some reason\n+   calls with no arguments work more reliably in .init, so stick the call\n+   in another function.  */\n+\n+static void\n+frame_dummy ()\n+{\n+  __register_frame (__EH_FRAME_BEGIN__);\n+}\n+\n+static void\n+init_dummy ()\n+{\n+  asm (INIT_SECTION_ASM_OP);\n+  frame_dummy ();\n+#ifdef FORCE_INIT_SECTION_ALIGN\n+  FORCE_INIT_SECTION_ALIGN;\n+#endif\n+  asm (TEXT_SECTION_ASM_OP);\n+}\n+#endif /* EH_FRAME_SECTION_ASM_OP */\n+\n #else  /* OBJECT_FORMAT_ELF */\n \n /* The function __do_global_ctors_aux is compiled twice (once in crtbegin.o\n@@ -200,14 +232,20 @@ __do_global_ctors_aux ()\t/* prologue goes in .init section */\n #ifdef HAS_INIT_SECTION\n /* This case is used by the Irix 6 port, which supports named sections but\n    not an SVR4-style .fini section.  __do_global_dtors can be non-static\n-   in this case because the -fini switch to ld binds strongly.  */\n+   in this case because we protect it with -hidden_symbol.  */\n+\n+static char __EH_FRAME_BEGIN__[];\n static func_ptr __DTOR_LIST__[];\n void\n __do_global_dtors ()\n {\n   func_ptr *p;\n   for (p = __DTOR_LIST__ + 1; *p; p++)\n     (*p) ();\n+\n+#ifdef EH_FRAME_SECTION_ASM_OP\n+  __deregister_frame (__EH_FRAME_BEGIN__);\n+#endif\n }\n #endif\n \n@@ -244,6 +282,17 @@ asm (DTORS_SECTION_ASM_OP);\t/* cc1 doesn't know that we are switching! */\n STATIC func_ptr __DTOR_LIST__[1] = { (func_ptr) (-1) };\n #endif\n \n+#ifdef EH_FRAME_SECTION_ASM_OP\n+/* Stick a label at the beginning of the frame unwind info so we can register\n+   and deregister it with the exception handling library code.  */\n+\n+asm (EH_FRAME_SECTION_ASM_OP);\n+#ifdef INIT_SECTION_ASM_OP\n+STATIC\n+#endif\n+char __EH_FRAME_BEGIN__[] = { };\n+#endif /* EH_FRAME_SECTION_ASM_OP */\n+\n #endif /* defined(CRT_BEGIN) */\n \n #ifdef CRT_END\n@@ -327,12 +376,16 @@ __do_global_ctors_aux ()\t/* prologue goes in .text section */\n #ifdef HAS_INIT_SECTION\n /* This case is used by the Irix 6 port, which supports named sections but\n    not an SVR4-style .init section.  __do_global_ctors can be non-static\n-   in this case because the -init switch to ld binds strongly.  */\n+   in this case because we protect it with -hidden_symbol.  */\n+extern char __EH_FRAME_BEGIN__[];\n static func_ptr __CTOR_END__[];\n void\n __do_global_ctors ()\n {\n   func_ptr *p;\n+#ifdef EH_FRAME_SECTION_ASM_OP\n+  __register_frame (__EH_FRAME_BEGIN__);\n+#endif\n   for (p = __CTOR_END__ - 1; *p != (func_ptr) -1; p--)\n     (*p) ();\n }\n@@ -363,4 +416,13 @@ asm (DTORS_SECTION_ASM_OP);\t/* cc1 doesn't know that we are switching! */\n STATIC func_ptr __DTOR_END__[1] = { (func_ptr) 0 };\n #endif\n \n+#ifdef EH_FRAME_SECTION_ASM_OP\n+/* Terminate the frame unwind info section with a 4byte 0 as a sentinel;\n+   this would be the 'length' field in a real FDE.  */\n+\n+typedef unsigned int ui32 __attribute__ ((mode (SI)));\n+asm (EH_FRAME_SECTION_ASM_OP);\n+STATIC ui32 __FRAME_END__[] = { 0 };\n+#endif /* EH_FRAME_SECTION */\n+\n #endif /* defined(CRT_END) */"}, {"sha": "434d761afed797644f0dbf59f87f7869f350ded5", "filename": "gcc/defaults.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0021b564f4ce0b648a8d6ec49b29afe609370788/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0021b564f4ce0b648a8d6ec49b29afe609370788/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=0021b564f4ce0b648a8d6ec49b29afe609370788", "patch": "@@ -136,6 +136,6 @@ do { fprintf (FILE, \"\\t%s\\t\", ASM_LONG);\t\t\t\t\\\n \n /* If we have a definition of INCOMING_RETURN_ADDR_RTX, assume that\n    the rest of the DWARF 2 frame unwind support is also provided.  */\n-#ifdef INCOMING_RETURN_ADDR_RTX\n-#define DWARF2_UNWIND_INFO\n+#if !defined (DWARF2_UNWIND_INFO) && defined (INCOMING_RETURN_ADDR_RTX)\n+#define DWARF2_UNWIND_INFO 1\n #endif"}, {"sha": "4340344c868c4a8bb0ea593a709f6ce8235e1674", "filename": "gcc/dwarf2.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0021b564f4ce0b648a8d6ec49b29afe609370788/gcc%2Fdwarf2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0021b564f4ce0b648a8d6ec49b29afe609370788/gcc%2Fdwarf2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2.h?ref=0021b564f4ce0b648a8d6ec49b29afe609370788", "patch": "@@ -496,7 +496,8 @@ enum dwarf_call_frame_info\n     DW_CFA_MIPS_advance_loc8 = 0x1d,\n \n     /* GNU extensions */\n-    DW_CFA_GNU_window_save = 0x2d\n+    DW_CFA_GNU_window_save = 0x2d,\n+    DW_CFA_GNU_args_size = 0x2e\n   };\n \n #define DW_CIE_ID\t  0xffffffff"}, {"sha": "6789f01af84780c71fdfd9bb1fa9839b7c41c22f", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 205, "deletions": 66, "changes": 271, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0021b564f4ce0b648a8d6ec49b29afe609370788/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0021b564f4ce0b648a8d6ec49b29afe609370788/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=0021b564f4ce0b648a8d6ec49b29afe609370788", "patch": "@@ -20,19 +20,15 @@ You should have received a copy of the GNU General Public License\n along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n-#include \"config.h\"\n-#include \"defaults.h\"\n-\n /* The first part of this file deals with the DWARF 2 frame unwind\n    information, which is also used by the GCC efficient exception handling\n    mechanism.  The second part, controlled only by an #ifdef\n    DWARF2_DEBUGGING_INFO, deals with the other DWARF 2 debugging\n    information.  */\n \n-#if defined (DWARF2_DEBUGGING_INFO) || defined (DWARF2_UNWIND_INFO)\n-\n+#include \"config.h\"\n+#include \"defaults.h\"\n #include <stdio.h>\n-#include <setjmp.h>\n #include \"dwarf2.h\"\n #include \"tree.h\"\n #include \"flags.h\"\n@@ -48,6 +44,21 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n /* #define NDEBUG 1 */\n #include \"assert.h\"\n \n+/* Decide whether we want to emit frame unwind information for the current\n+   translation unit.  */\n+\n+int\n+dwarf2out_do_frame ()\n+{\n+  return (write_symbols == DWARF2_DEBUG\n+#ifdef DWARF2_UNWIND_INFO\n+\t  || (flag_exceptions && ! exceptions_via_longjmp)\n+#endif\n+\t  );\n+}\n+\n+#if defined (DWARF2_DEBUGGING_INFO) || defined (DWARF2_UNWIND_INFO)\n+\n #ifndef __GNUC__\n #define inline\n #endif\n@@ -191,6 +202,7 @@ static unsigned reg_number\t\tPROTO((rtx));\n    Theses may be overridden in the tm.h file (if necessary) for a particular\n    assembler.  */\n \n+#ifdef OBJECT_FORMAT_ELF\n #ifndef UNALIGNED_SHORT_ASM_OP\n #define UNALIGNED_SHORT_ASM_OP\t\".2byte\"\n #endif\n@@ -200,20 +212,12 @@ static unsigned reg_number\t\tPROTO((rtx));\n #ifndef UNALIGNED_DOUBLE_INT_ASM_OP\n #define UNALIGNED_DOUBLE_INT_ASM_OP\t\".8byte\"\n #endif\n+#endif /* OBJECT_FORMAT_ELF */\n+\n #ifndef ASM_BYTE_OP\n #define ASM_BYTE_OP\t\t\".byte\"\n #endif\n \n-#ifndef UNALIGNED_OFFSET_ASM_OP\n-#define UNALIGNED_OFFSET_ASM_OP \\\n-  (DWARF_OFFSET_SIZE == 8 ? UNALIGNED_DOUBLE_INT_ASM_OP : UNALIGNED_INT_ASM_OP)\n-#endif\n-\n-#ifndef UNALIGNED_WORD_ASM_OP\n-#define UNALIGNED_WORD_ASM_OP \\\n-  (PTR_SIZE == 8 ? UNALIGNED_DOUBLE_INT_ASM_OP : UNALIGNED_INT_ASM_OP)\n-#endif\n-\n /* Data and reference forms for relocatable data.  */\n #define DW_FORM_data (DWARF_OFFSET_SIZE == 8 ? DW_FORM_data8 : DW_FORM_data4)\n #define DW_FORM_ref (DWARF_OFFSET_SIZE == 8 ? DW_FORM_ref8 : DW_FORM_ref4)\n@@ -238,9 +242,6 @@ static unsigned reg_number\t\tPROTO((rtx));\n #ifndef FRAME_SECTION\n #define FRAME_SECTION\t\t\".debug_frame\"\n #endif\n-#if !defined (EH_FRAME_SECTION) && defined (ASM_OUTPUT_SECTION_NAME)\n-#define EH_FRAME_SECTION\t\".eh_frame\"\n-#endif\n \n #ifndef FUNC_BEGIN_LABEL\n #define FUNC_BEGIN_LABEL\t\"LFB\"\n@@ -262,6 +263,23 @@ static unsigned reg_number\t\tPROTO((rtx));\n   fprintf ((FILE), SECTION_FORMAT, SECTION_ASM_OP, SECTION)\n #endif\n \n+#ifndef ASM_OUTPUT_DWARF_DATA1\n+#define ASM_OUTPUT_DWARF_DATA1(FILE,VALUE) \\\n+  fprintf ((FILE), \"\\t%s\\t0x%x\", ASM_BYTE_OP, VALUE)\n+#endif\n+\n+#ifdef UNALIGNED_INT_ASM_OP\n+\n+#ifndef UNALIGNED_OFFSET_ASM_OP\n+#define UNALIGNED_OFFSET_ASM_OP \\\n+  (DWARF_OFFSET_SIZE == 8 ? UNALIGNED_DOUBLE_INT_ASM_OP : UNALIGNED_INT_ASM_OP)\n+#endif\n+\n+#ifndef UNALIGNED_WORD_ASM_OP\n+#define UNALIGNED_WORD_ASM_OP \\\n+  (PTR_SIZE == 8 ? UNALIGNED_DOUBLE_INT_ASM_OP : UNALIGNED_INT_ASM_OP)\n+#endif\n+\n #ifndef ASM_OUTPUT_DWARF_DELTA2\n #define ASM_OUTPUT_DWARF_DELTA2(FILE,LABEL1,LABEL2)\t\t\t\\\n  do {\tfprintf ((FILE), \"\\t%s\\t\", UNALIGNED_SHORT_ASM_OP);\t\t\\\n@@ -317,11 +335,6 @@ static unsigned reg_number\t\tPROTO((rtx));\n   } while (0)\n #endif\n \n-#ifndef ASM_OUTPUT_DWARF_DATA1\n-#define ASM_OUTPUT_DWARF_DATA1(FILE,VALUE) \\\n-  fprintf ((FILE), \"\\t%s\\t0x%x\", ASM_BYTE_OP, VALUE)\n-#endif\n-\n #ifndef ASM_OUTPUT_DWARF_DATA2\n #define ASM_OUTPUT_DWARF_DATA2(FILE,VALUE) \\\n   fprintf ((FILE), \"\\t%s\\t0x%x\", UNALIGNED_SHORT_ASM_OP, (unsigned) VALUE)\n@@ -360,6 +373,43 @@ static unsigned reg_number\t\tPROTO((rtx));\n   } while (0)\n #endif\n \n+#else /* UNALIGNED_INT_ASM_OP */\n+\n+/* We don't have unaligned support, let's hope the normal output works for\n+   .debug_frame.  */\n+\n+#define ASM_OUTPUT_DWARF_ADDR(FILE,LABEL) \\\n+  assemble_integer (gen_rtx (SYMBOL_REF, Pmode, LABEL), PTR_SIZE, 1)\n+\n+#define ASM_OUTPUT_DWARF_OFFSET(FILE,LABEL) \\\n+  assemble_integer (gen_rtx (SYMBOL_REF, SImode, LABEL), 4, 1)\n+\n+#define ASM_OUTPUT_DWARF_DELTA2(FILE,LABEL1,LABEL2)\t\t\t\\\n+  assemble_integer (gen_rtx (MINUS, HImode,\t\t\t      \t\\\n+\t\t\t     gen_rtx (SYMBOL_REF, Pmode, LABEL1),   \t\\\n+\t\t\t     gen_rtx (SYMBOL_REF, Pmode, LABEL2)),\t\\\n+\t\t    2, 1)\n+  \n+#define ASM_OUTPUT_DWARF_DELTA4(FILE,LABEL1,LABEL2)\t\t\t\\\n+  assemble_integer (gen_rtx (MINUS, SImode,\t\t\t      \t\\\n+\t\t\t     gen_rtx (SYMBOL_REF, Pmode, LABEL1),   \t\\\n+\t\t\t     gen_rtx (SYMBOL_REF, Pmode, LABEL2)),\t\\\n+\t\t    4, 1)\n+\n+#define ASM_OUTPUT_DWARF_ADDR_DELTA(FILE,LABEL1,LABEL2)\t\t\t\\\n+  assemble_integer (gen_rtx (MINUS, Pmode,\t\t\t\t\\\n+\t\t\t     gen_rtx (SYMBOL_REF, Pmode, LABEL1),\t\\\n+\t\t\t     gen_rtx (SYMBOL_REF, Pmode, LABEL2)),\t\\\n+\t\t    PTR_SIZE, 1)\n+\n+#define ASM_OUTPUT_DWARF_DELTA(FILE,LABEL1,LABEL2) \\\n+  ASM_OUTPUT_DWARF_DELTA4 (FILE,LABEL1,LABEL2)\n+\n+#define ASM_OUTPUT_DWARF_DATA4(FILE,VALUE) \\\n+  assemble_integer (GEN_INT (VALUE), 4, 1)\n+\n+#endif /* UNALIGNED_INT_ASM_OP */\n+\n /* This is similar to the default ASM_OUTPUT_ASCII, except that no trailing\n    newline is produced.  When flag_verbose_asm is asserted, we add commnetary\n    at the end of the line, so we must avoid output of a newline here.  */\n@@ -404,6 +454,14 @@ static unsigned reg_number\t\tPROTO((rtx));\n #define DWARF_FRAME_REGNUM(REG) DBX_REGISTER_NUMBER (REG)\n #endif\n \n+/* Hook used by __throw.  */\n+\n+rtx\n+expand_builtin_dwarf_fp_regnum ()\n+{\n+  return GEN_INT (DWARF_FRAME_REGNUM (HARD_FRAME_POINTER_REGNUM));\n+}\n+\n /* The offset from the incoming value of %sp to the top of the stack frame\n    for the current function.  */\n #ifndef INCOMING_FRAME_SP_OFFSET\n@@ -497,6 +555,8 @@ dwarf_cfi_name (cfi_opc)\n     /* GNU extensions */\n     case DW_CFA_GNU_window_save:\n       return \"DW_CFA_GNU_window_save\";\n+    case DW_CFA_GNU_args_size:\n+      return \"DW_CFA_GNU_args_size\";\n \n     default:\n       return \"DW_CFA_<unknown>\";\n@@ -638,6 +698,9 @@ static long cfa_offset;\n static unsigned cfa_store_reg;\n static long cfa_store_offset;\n \n+/* The running total of the size of arguments pushed onto the stack.  */\n+static long args_size;\n+\n /* Entry point to update the canonical frame address (CFA).\n    LABEL is passed to add_fde_cfi.  The value of CFA is now to be\n    calculated from REG+OFFSET.  */\n@@ -743,6 +806,20 @@ dwarf2out_window_save (label)\n   add_fde_cfi (label, cfi);\n }\n \n+/* Add a CFI to update the running total of the size of arguments\n+   pushed onto the stack.  */\n+\n+void\n+dwarf2out_args_size (label, size)\n+     char *label;\n+     long size;\n+{\n+  register dw_cfi_ref cfi = new_cfi ();\n+  cfi->dw_cfi_opc = DW_CFA_GNU_args_size;\n+  cfi->dw_cfi_oprnd1.dw_cfi_offset = size;\n+  add_fde_cfi (label, cfi);\n+}\n+\n /* Entry point for saving a register to the stack.  REG is the GCC register\n    number.  LABEL and OFFSET are passed to reg_save.  */\n \n@@ -828,6 +905,67 @@ initial_return_save (rtl)\n   reg_save (NULL, DWARF_FRAME_RETURN_COLUMN, reg, offset - cfa_offset);\n }\n \n+/* Check INSN to see if it looks like a push or a stack adjustment, and\n+   make a note of it if it does.  EH uses this information to find out how\n+   much extra space it needs to pop off the stack.  */\n+\n+static void\n+dwarf2out_stack_adjust (insn)\n+     rtx insn;\n+{\n+  rtx src, dest;\n+  enum rtx_code code;\n+  long offset;\n+  char *label;\n+\n+  if (GET_CODE (insn) != SET)\n+    return;\n+\n+  src = SET_SRC (insn);\n+  dest = SET_DEST (insn);\n+  if (dest == stack_pointer_rtx)\n+    {\n+      /* (set (reg sp) (plus (reg sp) (const_int))) */\n+      code = GET_CODE (src);\n+      if (! (code == PLUS || code == MINUS)\n+\t  || XEXP (src, 0) != stack_pointer_rtx\n+\t  || GET_CODE (XEXP (src, 1)) != CONST_INT)\n+\treturn;\n+\n+      offset = INTVAL (XEXP (src, 1));\n+    }\n+  else if (GET_CODE (dest) == MEM)\n+    {\n+      /* (set (mem (pre_dec (reg sp))) (foo)) */\n+      src = XEXP (dest, 0);\n+      code = GET_CODE (src);\n+\n+      if (! (code == PRE_DEC || code == PRE_INC)\n+\t  || XEXP (src, 0) != stack_pointer_rtx)\n+\treturn;\n+\n+      offset = GET_MODE_SIZE (GET_MODE (dest));\n+    }\n+  else\n+    return;\n+\n+  if (code == PLUS || code == PRE_INC)\n+    offset = -offset;\n+  if (cfa_reg == STACK_POINTER_REGNUM)\n+    cfa_offset += offset;\n+\n+#ifndef STACK_GROWS_DOWNWARD\n+  offset = -offset;\n+#endif\n+  args_size += offset;\n+  if (args_size < 0)\n+    args_size = 0;\n+\n+  label = dwarf2out_cfi_label ();\n+  dwarf2out_def_cfa (label, cfa_reg, cfa_offset);\n+  dwarf2out_args_size (label, args_size);\n+}\n+\n /* Record call frame debugging information for INSN, which either\n    sets SP or FP (adjusting how we calculate the frame address) or saves a\n    register to the stack.  If INSN is NULL_RTX, initialize our state.  */\n@@ -857,6 +995,12 @@ dwarf2out_frame_debug (insn)\n       return;\n     }\n \n+  if (! RTX_FRAME_RELATED_P (insn))\n+    {\n+      dwarf2out_stack_adjust (PATTERN (insn));\n+      return;\n+    }\n+\n   label = dwarf2out_cfi_label ();\n     \n   insn = PATTERN (insn);\n@@ -903,13 +1047,21 @@ dwarf2out_frame_debug (insn)\n \t\t  abort ();\n \t\t}\n \n+\t      if (XEXP (src, 0) == hard_frame_pointer_rtx)\n+\t\t{\n+\t\t  /* Restoring SP from FP in the epilogue.  */\n+\t\t  assert (cfa_reg == HARD_FRAME_POINTER_REGNUM);\n+\t\t  cfa_reg = STACK_POINTER_REGNUM;\n+\t\t}\n+\t      else\n+\t\tassert (XEXP (src, 0) == stack_pointer_rtx);\n+\n \t      if (GET_CODE (src) == PLUS)\n \t\toffset = -offset;\n \t      if (cfa_reg == STACK_POINTER_REGNUM)\n \t\tcfa_offset += offset;\n \t      if (cfa_store_reg == STACK_POINTER_REGNUM)\n \t\tcfa_store_offset += offset;\n-\t      assert (XEXP (src, 0) == stack_pointer_rtx);\n \t    }\n \t  else\n \t    {\n@@ -953,7 +1105,7 @@ dwarf2out_frame_debug (insn)\n \tcase PRE_INC:\n \tcase PRE_DEC:\n \t  offset = GET_MODE_SIZE (GET_MODE (dest));\n-\t  if (GET_CODE (src) == PRE_INC)\n+\t  if (GET_CODE (XEXP (dest, 0)) == PRE_INC)\n \t    offset = -offset;\n \n \t  assert (REGNO (XEXP (XEXP (dest, 0), 0)) == STACK_POINTER_REGNUM);\n@@ -1196,12 +1348,29 @@ output_cfi (cfi, fde)\n \t  break;\n \tcase DW_CFA_GNU_window_save:\n \t  break;\n+\tcase DW_CFA_GNU_args_size:\n+\t  output_uleb128 (cfi->dw_cfi_oprnd1.dw_cfi_offset);\n+          fputc ('\\n', asm_out_file);\n+\t  break;\n \tdefault:\n \t  break;\n \t}\n      }\n }\n \n+#if !defined (EH_FRAME_SECTION)\n+#if defined (EH_FRAME_SECTION_ASM_OP)\n+#define EH_FRAME_SECTION() eh_frame_section();\n+#else\n+#if defined (ASM_OUTPUT_SECTION_NAME)\n+#define EH_FRAME_SECTION()\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\\\n+      named_section (NULL_TREE, \".eh_frame\", 0);\t\\\n+  } while (0)\n+#endif\n+#endif\n+#endif\n+\n /* Output the call frame information used to used to record information\n    that relates to calculating the frame pointer, and records the\n    location of saved registers.  */\n@@ -1231,9 +1400,13 @@ output_call_frame_info (for_eh)\n   if (for_eh)\n     {\n #ifdef EH_FRAME_SECTION\n-      ASM_OUTPUT_SECTION_NAME (asm_out_file, NULL_TREE, EH_FRAME_SECTION, 0);\n+      EH_FRAME_SECTION ();\n #else\n+      tree label = (tree) get_file_function_name ('F');\n+\n       data_section ();\n+      ASM_GLOBALIZE_LABEL (asm_out_file, IDENTIFIER_POINTER (label));\n+      ASM_OUTPUT_LABEL (asm_out_file, IDENTIFIER_POINTER (label));\n #endif\n       assemble_label (\"__FRAME_BEGIN__\");\n     }\n@@ -1272,9 +1445,9 @@ output_call_frame_info (for_eh)\n   fputc ('\\n', asm_out_file);\n   if (eh_ptr)\n     {\n-      /* The \"z\" augmentation was defined by SGI; the FDE contains a pointer\n+      /* The FDE contains a pointer\n \t to the exception region info for the frame.  */\n-      ASM_OUTPUT_DWARF_STRING (asm_out_file, \"z\");\n+      ASM_OUTPUT_DWARF_STRING (asm_out_file, \"e\");\n       if (flag_verbose_asm)\n \tfprintf (asm_out_file, \"\\t%s CIE Augmentation\", ASM_COMMENT_START);\n     }\n@@ -1302,14 +1475,6 @@ output_call_frame_info (for_eh)\n     fprintf (asm_out_file, \"\\t%s CIE RA Column\", ASM_COMMENT_START);\n \n   fputc ('\\n', asm_out_file);\n-  if (eh_ptr)\n-    {\n-      output_uleb128 (0);\n-      if (flag_verbose_asm)\n-\tfprintf (asm_out_file, \"\\t%s CIE augmentation fields length\",\n-\t\t ASM_COMMENT_START);\n-      fputc ('\\n', asm_out_file);\n-    }\n \n   for (cfi = cie_cfi_head; cfi != NULL; cfi = cfi->dw_cfi_next)\n     output_cfi (cfi, NULL);\n@@ -1355,19 +1520,9 @@ output_call_frame_info (for_eh)\n       fputc ('\\n', asm_out_file);\n       if (eh_ptr)\n \t{\n-\t  output_uleb128 (PTR_SIZE);\n-\t  if (flag_verbose_asm)\n-\t    fprintf (asm_out_file, \"\\t%s FDE augmentation fields length\",\n-\t\t     ASM_COMMENT_START);\n-\t  fputc ('\\n', asm_out_file);\n-\n \t  /* For now, a pointer to the translation unit's info will do.\n \t     ??? Eventually this should point to the function's info.  */\n-\t  if (exception_table_p ())\n-\t    ASM_OUTPUT_DWARF_ADDR (asm_out_file, \"__EXCEPTION_TABLE__\");\n-\t  else\n-\t    ASM_OUTPUT_DWARF_ADDR_DATA (asm_out_file, 0);\n-\n+\t  ASM_OUTPUT_DWARF_ADDR (asm_out_file, \"__EXCEPTION_TABLE__\");\n \t  if (flag_verbose_asm)\n \t    fprintf (asm_out_file, \"\\t%s pointer to exception region info\",\n \t\t     ASM_COMMENT_START);\n@@ -1399,16 +1554,6 @@ output_call_frame_info (for_eh)\n #endif\n }\n \n-/* Decide whether we want to emit frame unwind information for the current\n-   translation unit.  */\n-\n-int\n-dwarf2out_do_frame ()\n-{\n-  return (write_symbols == DWARF2_DEBUG\n-\t  || (flag_exceptions && ! exceptions_via_longjmp));\n-}\n-\n /* Output a marker (i.e. a label) for the beginning of a function, before\n    the prologue.  */\n \n@@ -1443,6 +1588,8 @@ dwarf2out_begin_prologue ()\n   fde->dw_fde_current_label = NULL;\n   fde->dw_fde_end = NULL;\n   fde->dw_fde_cfi = NULL;\n+\n+  args_size = 0;\n }\n \n /* Output a marker (i.e. a label) for the absolute end of the generated code\n@@ -9142,10 +9289,6 @@ dwarf2out_init (asm_out_file, main_input_filename)\n   gen_compile_unit_die (main_input_filename);\n \n   ASM_GENERATE_INTERNAL_LABEL (text_end_label, TEXT_END_LABEL, 0);\n-\n-  /* Initialize the frame unwind information.  Eventually this should be\n-     called from compile_file instead.  */\n-  dwarf2out_frame_init ();\n }\n \n /* Output stuff that dwarf requires at the end of every file,\n@@ -9202,10 +9345,6 @@ dwarf2out_finish ()\n   ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, BSS_END_LABEL, 0);\n #endif\n \n-  /* Output the frame unwind information.  Eventually this should be called\n-     from compile_file instead.  */\n-  dwarf2out_frame_finish ();\n-\n   /* Output the source line correspondence table.  */\n   if (line_info_table_in_use > 1 || separate_line_info_table_in_use)\n     {"}, {"sha": "71c49c25a77178c8c5d4e3b0b732aebaf45cdf25", "filename": "gcc/except.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0021b564f4ce0b648a8d6ec49b29afe609370788/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0021b564f4ce0b648a8d6ec49b29afe609370788/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=0021b564f4ce0b648a8d6ec49b29afe609370788", "patch": "@@ -281,3 +281,15 @@ extern int protect_cleanup_actions_with_terminate;\n #ifdef TREE_CODE\n extern tree protect_with_terminate\t\tPROTO((tree));\n #endif\n+\n+/* Various hooks for the DWARF 2 __throw routine.  */\n+\n+void expand_builtin_unwind_init\t\tPROTO((void));\n+rtx expand_builtin_dwarf_fp_regnum\tPROTO((void));\n+rtx expand_builtin_eh_stub\t\tPROTO((void));\n+#ifdef TREE_CODE\n+rtx expand_builtin_frob_return_addr\tPROTO((tree));\n+rtx expand_builtin_extract_return_addr\tPROTO((tree));\n+void expand_builtin_set_return_addr_reg PROTO((tree));\n+void expand_builtin_set_eh_regs\t\tPROTO((tree, tree));\n+#endif"}, {"sha": "48e1a0878f771de7b0f7b33930ab2d6405618773", "filename": "gcc/final.c", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0021b564f4ce0b648a8d6ec49b29afe609370788/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0021b564f4ce0b648a8d6ec49b29afe609370788/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=0021b564f4ce0b648a8d6ec49b29afe609370788", "patch": "@@ -955,9 +955,9 @@ final_start_function (first, file, optimize)\n     last_linenum = high_block_linenum = high_function_linenum\n       = NOTE_LINE_NUMBER (first);\n \n-#ifdef DWARF2_DEBUGGING_INFO\n+#if defined (DWARF2_UNWIND_INFO)\n   /* Output DWARF definition of the function.  */\n-  if (write_symbols == DWARF2_DEBUG)\n+  if (dwarf2out_do_frame ())\n     dwarf2out_begin_prologue ();\n #endif\n \n@@ -992,6 +992,11 @@ final_start_function (first, file, optimize)\n     profile_function (file);\n #endif /* PROFILE_BEFORE_PROLOGUE */\n \n+#if defined (DWARF2_UNWIND_INFO) && defined (HAVE_prologue)\n+  if (dwarf2out_do_frame ())\n+    dwarf2out_frame_debug (NULL_RTX);\n+#endif\n+\n #ifdef FUNCTION_PROLOGUE\n   /* First output the function prologue: code to set up the stack frame.  */\n   FUNCTION_PROLOGUE (file, get_frame_size ());\n@@ -1142,8 +1147,8 @@ final_end_function (first, file, optimize)\n     dwarfout_end_epilogue ();\n #endif\n \n-#ifdef DWARF2_DEBUGGING_INFO\n-  if (write_symbols == DWARF2_DEBUG)\n+#if defined (DWARF2_UNWIND_INFO)\n+  if (dwarf2out_do_frame ())\n     dwarf2out_end_epilogue ();\n #endif\n \n@@ -1265,11 +1270,6 @@ final (first, file, optimize, prescan)\n   last_ignored_compare = 0;\n   new_block = 1;\n \n-#if defined (DWARF2_DEBUGGING_INFO) && defined (HAVE_prologue)\n-  if (write_symbols == DWARF2_DEBUG)\n-    dwarf2out_frame_debug (NULL_RTX);\n-#endif\n-\n   check_exception_handler_labels ();\n \n   /* Make a map indicating which line numbers appear in this function.\n@@ -2171,12 +2171,21 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \n \toutput_asm_insn (template, recog_operand);\n \n-#if defined (DWARF2_DEBUGGING_INFO) && defined (HAVE_prologue)\n+#if defined (DWARF2_UNWIND_INFO)\n+#if !defined (ACCUMULATE_OUTGOING_ARGS)\n+\t/* If we push arguments, we need to check all insns for stack\n+\t   adjustments.  */\n+\tif (dwarf2out_do_frame ())\n+\t  dwarf2out_frame_debug (insn);\n+#else\n+#if defined (HAVE_prologue)\n \t/* If this insn is part of the prologue, emit DWARF v2\n \t   call frame info.  */\n-\tif (write_symbols == DWARF2_DEBUG && RTX_FRAME_RELATED_P (insn))\n+\tif (RTX_FRAME_RELATED_P (insn) && dwarf2out_do_frame ())\n \t  dwarf2out_frame_debug (insn);\n #endif\n+#endif\n+#endif\n \n #if 0\n \t/* It's not at all clear why we did this and doing so interferes"}, {"sha": "a9e5e231e7d5859845536fd5b0074583b6173204", "filename": "gcc/frame.c", "status": "added", "additions": 607, "deletions": 0, "changes": 607, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0021b564f4ce0b648a8d6ec49b29afe609370788/gcc%2Fframe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0021b564f4ce0b648a8d6ec49b29afe609370788/gcc%2Fframe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fframe.c?ref=0021b564f4ce0b648a8d6ec49b29afe609370788", "patch": "@@ -0,0 +1,607 @@\n+/* Subroutines needed for unwinding stack frames for exception handling.  */\n+/* Compile this one with gcc.  */\n+/* Copyright (C) 1997 Free Software Foundation, Inc.\n+   Contributed by Jason Merrill <jason@cygnus.com>.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with other files,\n+   some of which are compiled with GCC, to produce an executable,\n+   this library does not by itself cause the resulting executable\n+   to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\n+/* It is incorrect to include config.h here, because this file is being\n+   compiled for the target, and hence definitions concerning only the host\n+   do not apply.  */\n+\n+#include \"tconfig.h\"\n+#include \"defaults.h\"\n+\n+#ifdef DWARF2_UNWIND_INFO\n+#include \"dwarf2.h\"\n+#include \"frame.h\"\n+#include <stddef.h>\n+\n+/* Don't use `fancy_abort' here even if config.h says to use it.  */\n+#ifdef abort\n+#undef abort\n+#endif\n+\n+/* Some types used by the DWARF 2 spec.  */\n+\n+typedef unsigned int uword __attribute__ ((mode (SI)));\n+typedef unsigned int uaddr __attribute__ ((mode (pointer)));\n+typedef int saddr __attribute__ ((mode (pointer)));\n+typedef unsigned char ubyte;\n+\n+/* The first few fields of a CIE.  The CIE_id field is 0xffffffff for a CIE,\n+   to distinguish it from a valid FDE.  FDEs are aligned to an addressing\n+   unit boundary, but the fields within are unaligned.  */\n+\n+struct dwarf_cie {\n+  uword length;\n+  uaddr CIE_id;\n+  ubyte version;\n+  char augmentation[0];\n+} __attribute__ ((packed, aligned (__alignof__ (void *))));\n+\n+/* The first few fields of an FDE.  */\n+\n+struct dwarf_fde {\n+  uword length;\n+  struct dwarf_cie* CIE_pointer;\n+  void* pc_begin;\n+  uaddr pc_range;\n+} __attribute__ ((packed, aligned (__alignof__ (void *))));\n+\n+typedef struct dwarf_fde fde;\n+\n+/* The representation for an \"object\" to be searched for frame unwind info.\n+   For targets with named sections, one object is an executable or shared\n+   library; for other targets, one object is one translation unit.  */\n+\n+struct object {\n+  void *pc_begin;\n+  void *pc_end;\n+  fde *fde_begin;\n+  fde ** fde_array;\n+  size_t count;\n+  struct object *next;\n+};\n+\n+static struct object *objects;\n+\n+/* The information we care about from a CIE.  */\n+\n+struct cie_info {\n+  char *augmentation;\n+  int code_align;\n+  int data_align;\n+  unsigned ra_regno;\n+};\n+\n+/* The current unwind state, plus a saved copy for DW_CFA_remember_state.  */\n+\n+struct frame_state_internal\n+{\n+  struct frame_state s;\n+  struct frame_state_internal *saved_state;\n+};\n+\f  \n+/* Decode the unsigned LEB128 constant at BUF into the variable pointed to\n+   by R, and return the new value of BUF.  */\n+\n+static void *\n+decode_uleb128 (unsigned char *buf, unsigned *r)\n+{\n+  unsigned shift = 0;\n+  unsigned result = 0;\n+\n+  while (1)\n+    {\n+      unsigned byte = *buf++;\n+      result |= (byte & 0x7f) << shift;\n+      if ((byte & 0x80) == 0)\n+\tbreak;\n+      shift += 7;\n+    }\n+  *r = result;\n+  return buf;\n+}\n+\n+/* Decode the signed LEB128 constant at BUF into the variable pointed to\n+   by R, and return the new value of BUF.  */\n+\n+static void *\n+decode_sleb128 (unsigned char *buf, int *r)\n+{\n+  unsigned shift = 0;\n+  unsigned result = 0;\n+  unsigned byte;\n+\n+  while (1)\n+    {\n+      byte = *buf++;\n+      result |= (byte & 0x7f) << shift;\n+      shift += 7;\n+      if ((byte & 0x80) == 0)\n+\tbreak;\n+    }\n+  if (shift < (sizeof (*r) * 8) && (byte & 0x40) != 0)\n+    result |= - (1 << shift);\n+\n+  *r = result;\n+  return buf;\n+}\n+\n+/* Read unaligned data from the instruction buffer.  */\n+\n+union unaligned {\n+  void *p;\n+  unsigned b2 __attribute__ ((mode (HI)));\n+  unsigned b4 __attribute__ ((mode (SI)));\n+  unsigned b8 __attribute__ ((mode (DI)));\n+} __attribute__ ((packed));\n+static inline void *\n+read_pointer (void *p)\n+{ union unaligned *up = p; return up->p; }\n+static inline unsigned\n+read_1byte (void *p)\n+{ return *(unsigned char *)p; }\n+static inline unsigned\n+read_2byte (void *p)\n+{ union unaligned *up = p; return up->b2; }\n+static inline unsigned\n+read_4byte (void *p)\n+{ union unaligned *up = p; return up->b4; }\n+static inline unsigned long\n+read_8byte (void *p)\n+{ union unaligned *up = p; return up->b8; }\n+\f\n+/* Ordering function for FDEs.  Functions can't overlap, so we just compare\n+   their starting addresses.  */\n+\n+static inline saddr\n+fde_compare (fde *x, fde *y)\n+{\n+  return (saddr)x->pc_begin - (saddr)y->pc_begin;\n+}\n+\n+/* Return the address of the FDE after P.  */\n+\n+static inline fde *\n+next_fde (fde *p)\n+{\n+  return (fde *)(((char *)p) + p->length + sizeof (p->length));\n+}\n+\n+/* One iteration of an insertion sort, for adding new FDEs to the array.\n+   Usually the new FDE will go in at the end, so we can expect close to\n+   O(n) performance.  If this turns out to be overly optimistic, we can have\n+   the linker sort the FDEs so we don't have to do it at run time.  */\n+\n+static void\n+fde_insert (fde **array, size_t i, fde *this_fde)\n+{\n+  array[i] = this_fde;\n+\n+  for (; i > 0 && fde_compare (array[i], array[i-1]) < 0; --i)\n+    {\n+      this_fde = array[i];\n+      array[i] = array[i-1];\n+      array[i-1] = this_fde;\n+    }\n+}\n+\n+static size_t\n+count_fdes (fde *this_fde)\n+{\n+  size_t count;\n+\n+  for (count = 0; this_fde->length != 0; this_fde = next_fde (this_fde))\n+    {\n+      /* Skip CIEs.  */\n+      if ((uaddr)(this_fde->CIE_pointer) == (uaddr)-1)\n+\tcontinue;\n+\n+      ++count;\n+    }\n+\n+  return count;\n+}\n+\n+static void\n+add_fdes (fde *this_fde, fde **array, size_t *i_ptr,\n+\t  void **beg_ptr, void **end_ptr)\n+{\n+  size_t i = *i_ptr;\n+  void *pc_begin = *beg_ptr;\n+  void *pc_end = *end_ptr;\n+\n+  for (; this_fde->length != 0; this_fde = next_fde (this_fde))\n+    {\n+      /* Skip CIEs.  */\n+      if ((uaddr)(this_fde->CIE_pointer) == (uaddr)-1)\n+\tcontinue;\n+\n+      fde_insert (array, i++, this_fde);\n+\n+      if (this_fde->pc_begin < pc_begin)\n+\tpc_begin = this_fde->pc_begin;\n+      if (this_fde->pc_begin + this_fde->pc_range > pc_end)\n+\tpc_end = this_fde->pc_begin + this_fde->pc_range;\n+    }\n+\n+  *i_ptr = i;\n+  *beg_ptr = pc_begin;\n+  *end_ptr = pc_end;\n+}\n+\n+/* Set up a sorted array of pointers to FDEs for a loaded object.  We\n+   count up the entries before allocating the array because it's likely to\n+   be faster.  */\n+\n+static void\n+frame_init (struct object* ob)\n+{\n+  fde *this_fde;\n+  size_t count;\n+  fde **array;\n+  void *pc_begin, *pc_end;\n+\n+  if (ob->fde_array)\n+    {\n+      fde **p = ob->fde_array;\n+      for (count = 0; *p; ++p)\n+\tcount += count_fdes (*p);\n+    }\n+  else\n+    count = count_fdes (ob->fde_begin);\n+\n+  ob->count = count;\n+  array = (fde **) malloc (sizeof (fde *) * count);\n+\n+  pc_begin = (void*)(uaddr)-1;\n+  pc_end = 0;\n+  count = 0;\n+\n+  if (ob->fde_array)\n+    {\n+      fde **p = ob->fde_array;\n+      for (; *p; ++p)\n+\tadd_fdes (*p, array, &count, &pc_begin, &pc_end);\n+    }\n+  else\n+    add_fdes (ob->fde_begin, array, &count, &pc_begin, &pc_end);\n+\n+  ob->fde_array = array;\n+  ob->pc_begin = pc_begin;\n+  ob->pc_end = pc_end;\n+}\n+\n+/* Return a pointer to the FDE for the function containing PC.  */\n+\n+static fde *\n+find_fde (void *pc)\n+{\n+  struct object *ob;\n+  size_t lo, hi;\n+\n+  for (ob = objects; ob; ob = ob->next)\n+    {\n+      if (ob->pc_begin == 0)\n+\tframe_init (ob);\n+      if (pc >= ob->pc_begin && pc < ob->pc_end)\n+\tbreak;\n+    }\n+\n+  if (ob == 0)\n+    return 0;\n+\n+  /* Standard binary search algorithm.  */\n+  for (lo = 0, hi = ob->count; lo < hi; )\n+    {\n+      size_t i = (lo + hi) / 2;\n+      fde *f = ob->fde_array[i];\n+\n+      if (pc < f->pc_begin)\n+\thi = i;\n+      else if (pc > f->pc_begin + f->pc_range)\n+\tlo = i + 1;\n+      else\n+\treturn f;\n+    }\n+\n+  return 0;\n+}\n+\f\n+/* Extract any interesting information from the CIE for the translation\n+   unit F belongs to.  */\n+\n+static void *\n+extract_cie_info (fde *f, struct cie_info *c)\n+{\n+  void *p;\n+  int i;\n+\n+  c->augmentation = f->CIE_pointer->augmentation;\n+\n+  if (strcmp (c->augmentation, \"\") != 0\n+      && strcmp (c->augmentation, \"e\") != 0\n+      && c->augmentation[0] != 'z')\n+    return 0;\n+\n+  p = c->augmentation + strlen (c->augmentation) + 1;\n+\n+  p = decode_uleb128 (p, &c->code_align);\n+  p = decode_sleb128 (p, &c->data_align);\n+  c->ra_regno = *(unsigned char *)p++;\n+\n+  /* If the augmentation starts with 'z', we now see the length of the\n+     augmentation fields.  */\n+  if (c->augmentation[0] == 'z')\n+    {\n+      p = decode_uleb128 (p, &i);\n+      p += i;\n+    }\n+\n+  return p;\n+}\n+\n+/* Decode one instruction's worth of of DWARF 2 call frame information.\n+   Used by __frame_state_for.  Takes pointers P to the instruction to\n+   decode, STATE to the current register unwind information, INFO to the\n+   current CIE information, and PC to the current PC value.  Returns a\n+   pointer to the next instruction.  */\n+\n+static void *\n+execute_cfa_insn (void *p, struct frame_state_internal *state,\n+\t\t  struct cie_info *info, void **pc)\n+{\n+  unsigned insn = *(unsigned char *)p++;\n+  unsigned reg;\n+  int offset;\n+\n+  if (insn & DW_CFA_advance_loc)\n+    *pc += ((insn & 0x3f) * info->code_align);\n+  else if (insn & DW_CFA_offset)\n+    {\n+      reg = (insn & 0x3f);\n+      p = decode_uleb128 (p, &offset);\n+      offset *= info->data_align;\n+      state->s.saved[reg] = REG_SAVED_OFFSET;\n+      state->s.reg_or_offset[reg] = offset;\n+    }\n+  else if (insn & DW_CFA_restore)\n+    {\n+      reg = (insn & 0x3f);\n+      state->s.saved[reg] = REG_UNSAVED;\n+    }\n+  else switch (insn)\n+    {\n+    case DW_CFA_set_loc:\n+      *pc = read_pointer (p);\n+      p += sizeof (void *);\n+      break;\n+    case DW_CFA_advance_loc1:\n+      *pc += read_1byte (p);\n+      p += 1;\n+      break;\n+    case DW_CFA_advance_loc2:\n+      *pc += read_2byte (p);\n+      p += 2;\n+      break;\n+    case DW_CFA_advance_loc4:\n+      *pc += read_4byte (p);\n+      p += 4;\n+      break;\n+\n+    case DW_CFA_offset_extended:\n+      p = decode_uleb128 (p, &reg);\n+      p = decode_uleb128 (p, &offset);\n+      offset *= info->data_align;\n+      state->s.saved[reg] = REG_SAVED_OFFSET;\n+      state->s.reg_or_offset[reg] = offset;\n+      break;\n+    case DW_CFA_restore_extended:\n+      p = decode_uleb128 (p, &reg);\n+      state->s.saved[reg] = REG_UNSAVED;\n+      break;\n+\n+    case DW_CFA_undefined:\n+    case DW_CFA_same_value:\n+    case DW_CFA_nop:\n+      break;\n+\n+    case DW_CFA_register:\n+      {\n+\tunsigned reg2;\n+\tp = decode_uleb128 (p, &reg);\n+\tp = decode_uleb128 (p, &reg2);\n+\tstate->s.saved[reg] = REG_SAVED_REG;\n+\tstate->s.reg_or_offset[reg] = reg2;\n+      }\n+      break;\n+\n+    case DW_CFA_def_cfa:\n+      p = decode_uleb128 (p, &reg);\n+      p = decode_uleb128 (p, &offset);\n+      state->s.cfa_reg = reg;\n+      state->s.cfa_offset = offset;\n+      break;\n+    case DW_CFA_def_cfa_register:\n+      p = decode_uleb128 (p, &reg);\n+      state->s.cfa_reg = reg;\n+      break;\n+    case DW_CFA_def_cfa_offset:\n+      p = decode_uleb128 (p, &offset);\n+      state->s.cfa_offset = offset;\n+      break;\n+      \n+    case DW_CFA_remember_state:\n+      {\n+\tstruct frame_state_internal *save =\n+\t  (struct frame_state_internal *)\n+\t  malloc (sizeof (struct frame_state_internal));\n+\tmemcpy (save, state, sizeof (struct frame_state_internal));\n+\tstate->saved_state = save;\n+      }\n+      break;\n+    case DW_CFA_restore_state:\n+      {\n+\tstruct frame_state_internal *save = state->saved_state;\n+\tmemcpy (state, save, sizeof (struct frame_state_internal));\n+\tfree (save);\n+      }\n+      break;\n+\n+      /* FIXME: Hardcoded for SPARC register window configuration.  */\n+    case DW_CFA_GNU_window_save:\n+      for (reg = 16; reg < 32; ++reg)\n+\t{\n+\t  state->s.saved[reg] = REG_SAVED_OFFSET;\n+\t  state->s.reg_or_offset[reg] = (reg - 16) * sizeof (void *);\n+\t}\n+      break;\n+\n+    case DW_CFA_GNU_args_size:\n+      p = decode_uleb128 (p, &offset);\n+      state->s.args_size = offset;\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+  return p;\n+}\n+\f\n+/* Called from crtbegin.o to register the unwind info for an object.  */\n+\n+void\n+__register_frame (void *begin)\n+{\n+  struct object *ob = (struct object *) malloc (sizeof (struct object));\n+\n+  ob->fde_begin = begin;\n+\n+  ob->pc_begin = ob->pc_end = 0;\n+  ob->fde_array = 0;\n+  ob->count = 0;\n+\n+  ob->next = objects;\n+  objects = ob;\n+}\n+\n+/* Similar, but BEGIN is actually a pointer to a table of unwind entries\n+   for different translation units.  Called from the file generated by\n+   collect2.  */\n+\n+void\n+__register_frame_table (void *begin)\n+{\n+  struct object *ob = (struct object *) malloc (sizeof (struct object));\n+\n+  ob->fde_begin = begin;\n+  ob->fde_array = begin;\n+\n+  ob->pc_begin = ob->pc_end = 0;\n+  ob->count = 0;\n+\n+  ob->next = objects;\n+  objects = ob;\n+}\n+\n+/* Called from crtend.o to deregister the unwind info for an object.  */\n+\n+void\n+__deregister_frame (void *begin)\n+{\n+  struct object **p = &objects;\n+\n+  while (*p)\n+    {\n+      if ((*p)->fde_begin == begin)\n+\t{\n+\t  struct object *ob = *p;\n+\t  *p = (*p)->next;\n+\n+\t  if (ob->fde_array)\n+\t    free (ob->fde_array);\n+\t  free (ob);\n+\n+\t  return;\n+\t}\n+      p = &((*p)->next);\n+    }\n+  abort ();\n+}\n+\n+/* Called from __throw to find the registers to restore for a given\n+   PC_TARGET.  The caller should allocate a local variable of `struct\n+   frame_state' (declared in frame.h) and pass its address to STATE_IN.  */\n+\n+struct frame_state *\n+__frame_state_for (void *pc_target, struct frame_state *state_in)\n+{\n+  fde *f;\n+  void *insn, *end, *pc;\n+  struct cie_info info;\n+  struct frame_state_internal state;\n+\n+  f = find_fde (pc_target);\n+  if (f == 0)\n+    return 0;\n+\n+  insn = extract_cie_info (f, &info);\n+  if (insn == 0)\n+    return 0;\n+\n+  memset (&state, 0, sizeof (state));\n+  state.s.retaddr_column = info.ra_regno;\n+\n+  /* First decode all the insns in the CIE.  */\n+  end = next_fde ((fde*) f->CIE_pointer);\n+  while (insn < end)\n+    insn = execute_cfa_insn (insn, &state, &info, 0);\n+\n+  insn = ((fde *)f) + 1;\n+\n+  if (info.augmentation[0] == 'z')\n+    {\n+      int i;\n+      insn = decode_uleb128 (insn, &i);\n+      insn += i;\n+    }\n+  else if (strcmp (info.augmentation, \"e\") == 0)\n+    {\n+      state.s.eh_ptr = read_pointer (insn);\n+      insn += sizeof (void *);\n+    }\n+\n+  /* Then the insns in the FDE up to our target PC.  */\n+  end = next_fde (f);\n+  pc = f->pc_begin;\n+  while (insn < end && pc < pc_target)\n+    insn = execute_cfa_insn (insn, &state, &info, &pc);\n+\n+  memcpy (state_in, &state.s, sizeof (state.s));\n+  return state_in;\n+}\n+#endif /* DWARF2_UNWIND_INFO */"}, {"sha": "0b95dbf1850b2ba0963bcd541472ef0b9cbccc6a", "filename": "gcc/tm.texi", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0021b564f4ce0b648a8d6ec49b29afe609370788/gcc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0021b564f4ce0b648a8d6ec49b29afe609370788/gcc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftm.texi?ref=0021b564f4ce0b648a8d6ec49b29afe609370788", "patch": "@@ -5987,6 +5987,26 @@ A C expression to output text to mark the end of an exception region.\n \n This macro need not be defined on most platforms.\n \n+@findex EXCEPTION_SECTION\n+@item EXCEPTION_SECTION ()\n+A C expression to switch to the section in which the main\n+exception table is to be placed (@pxref{Sections}).  The default is a\n+section named @code{.gcc_except_table} on machines that support named\n+sections via @code{ASM_OUTPUT_SECTION_NAME}, otherwise if @samp{-fpic}\n+or @samp{-fPIC} is in effect, the @code{data_section}, otherwise the\n+@code{readonly_data_section}.\n+\n+@findex EH_FRAME_SECTION_ASM_OP\n+@item EH_FRAME_SECTION_ASM_OP\n+If defined, a C string constant for the assembler operation to switch to\n+the section for exception handling frame unwind information.  If not\n+defined, GNU CC will provide a default definition if the target supports\n+named sections.  @file{crtstuff.c} uses this macro to switch to the\n+appropriate section.\n+\n+You should define this symbol if your target supports DWARF 2 frame\n+unwind information and the default definition does not work.\n+\n @findex OMIT_EH_TABLE\n @item OMIT_EH_TABLE ()\n A C expression that is nonzero if the normal exception table output\n@@ -6011,6 +6031,23 @@ for details on when to define this, and how.\n @item MASK_RETURN_ADDR\n An rtx used to mask the return address found via RETURN_ADDR_RTX, so\n that it does not contain any extraneous set bits in it.\n+\n+@findex DWARF2_UNWIND_INFO\n+@item DWARF2_UNWIND_INFO\n+Define this macro to 0 if your target supports DWARF 2 frame unwind\n+information, but it does not yet work with exception handling.\n+Otherwise, if your target supports this information (if it defines\n+@samp{INCOMING_RETURN_ADDR_RTX} and either @samp{UNALIGNED_INT_ASM_OP}\n+or @samp{OBJECT_FORMAT_ELF}), GCC will provide a default definition of\n+1.\n+\n+If this macro is defined to 1, the DWARF 2 unwinder will be the default\n+exception handling mechanism; otherwise, setjmp/longjmp will be used by\n+default.\n+\n+If this macro is defined to anything, the DWARF 2 unwinder will be used\n+instead of inline unwinders and __unwind_function in the non-setjmp case.\n+\n @end table\n \n @node Alignment Output"}, {"sha": "2658e5b5ee9121fd4c817e8ec977f50e22a802de", "filename": "gcc/toplev.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0021b564f4ce0b648a8d6ec49b29afe609370788/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0021b564f4ce0b648a8d6ec49b29afe609370788/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=0021b564f4ce0b648a8d6ec49b29afe609370788", "patch": "@@ -2463,6 +2463,10 @@ compile_file (name)\n   if (write_symbols == DWARF_DEBUG)\n     TIMEVAR (symout_time, dwarfout_init (asm_out_file, main_input_filename));\n #endif\n+#ifdef DWARF2_UNWIND_INFO\n+  if (dwarf2out_do_frame ())\n+    dwarf2out_frame_init ();\n+#endif\n #ifdef DWARF2_DEBUGGING_INFO\n   if (write_symbols == DWARF2_DEBUG)\n     TIMEVAR (symout_time, dwarf2out_init (asm_out_file, main_input_filename));\n@@ -2597,8 +2601,7 @@ compile_file (name)\n     /* Now that all possible functions have been output, we can dump\n        the exception table.  */\n \n-    if (exception_table_p ())\n-      output_exception_table ();\n+    output_exception_table ();\n \n     for (i = 0; i < len; i++)\n       {\n@@ -2713,6 +2716,11 @@ compile_file (name)\n \t     });\n #endif\n \n+#ifdef DWARF2_UNWIND_INFO\n+  if (dwarf2out_do_frame ())\n+    dwarf2out_frame_finish ();\n+#endif\n+\n #ifdef DWARF2_DEBUGGING_INFO\n   if (write_symbols == DWARF2_DEBUG)\n     TIMEVAR (symout_time,"}, {"sha": "d594bd92ccda16cab18bc01e24fe529c92077c98", "filename": "gcc/tree.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0021b564f4ce0b648a8d6ec49b29afe609370788/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0021b564f4ce0b648a8d6ec49b29afe609370788/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=0021b564f4ce0b648a8d6ec49b29afe609370788", "patch": "@@ -101,6 +101,16 @@ enum built_in_function\n   BUILT_IN_SETJMP,\n   BUILT_IN_LONGJMP,\n \n+  /* Various hooks for the DWARF 2 __throw routine.  */\n+  BUILT_IN_FP, BUILT_IN_SP,\n+  BUILT_IN_UNWIND_INIT,\n+  BUILT_IN_DWARF_FP_REGNUM,\n+  BUILT_IN_FROB_RETURN_ADDR,\n+  BUILT_IN_EXTRACT_RETURN_ADDR,\n+  BUILT_IN_SET_RETURN_ADDR_REG,\n+  BUILT_IN_EH_STUB,\n+  BUILT_IN_SET_EH_REGS,\n+\n   /* C++ extensions */\n   BUILT_IN_NEW,\n   BUILT_IN_VEC_NEW,"}, {"sha": "351524dec558415367b883b6f680a7cebc0575a1", "filename": "gcc/varasm.c", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0021b564f4ce0b648a8d6ec49b29afe609370788/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0021b564f4ce0b648a8d6ec49b29afe609370788/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=0021b564f4ce0b648a8d6ec49b29afe609370788", "patch": "@@ -170,6 +170,9 @@ static enum in_section { no_section, in_text, in_data, in_named\n #ifdef BSS_SECTION_ASM_OP\n   , in_bss\n #endif\n+#ifdef EH_FRAME_SECTION_ASM_OP\n+  , in_eh_frame\n+#endif\n #ifdef EXTRA_SECTIONS\n   , EXTRA_SECTIONS\n #endif\n@@ -401,6 +404,18 @@ asm_output_aligned_bss (file, decl, name, size, align)\n \n #endif /* BSS_SECTION_ASM_OP */\n \n+#ifdef EH_FRAME_SECTION_ASM_OP\n+void\n+eh_frame_section ()\n+{\n+  if (in_section != in_eh_frame)\n+    {\n+      fprintf (asm_out_file, \"%s\\n\", EH_FRAME_SECTION_ASM_OP);\n+      in_section = in_eh_frame;\n+    }\n+} \n+#endif\n+\n /* Switch to the section for function DECL.\n \n    If DECL is NULL_TREE, switch to the text section.\n@@ -461,15 +476,15 @@ variable_section (decl, reloc)\n void\n exception_section ()\n {\n+#if defined (EXCEPTION_SECTION)\n+  EXCEPTION_SECTION ();\n+#else\n #ifdef ASM_OUTPUT_SECTION_NAME\n   named_section (NULL_TREE, \".gcc_except_table\", 0);\n #else\n   if (flag_pic)\n     data_section ();\n   else\n-#if defined (EXCEPTION_SECTION)\n-    EXCEPTION_SECTION ();\n-#else\n     readonly_data_section ();\n #endif\n #endif"}]}