{"sha": "6adb6030c126ad8aa75ab0ecfb1276ed6c88cead", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmFkYjYwMzBjMTI2YWQ4YWE3NWFiMGVjZmIxMjc2ZWQ2Yzg4Y2VhZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-01-23T11:23:48Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-01-23T11:23:48Z"}, "message": "[multiple changes]\n\n2017-01-23  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_aggr.adb (Resolve_Array_Aggregate): In ASIS mode do not\n\treport on spurious overlaps between values involving a subtype\n\twith a static predicate, because the expansion of such a subtype\n\tinto individual ranges in inhibited in ASIS mode.\n\n2017-01-23  Justin Squirek  <squirek@adacore.com>\n\n\t* sem_ch3.adb (Analyze_Declarations): Add detection\n\tof an edge case and delay freezing if it is present.\n\nFrom-SVN: r244780", "tree": {"sha": "fae825f947a73d82356e4ba298aa86504136fc12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fae825f947a73d82356e4ba298aa86504136fc12"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6adb6030c126ad8aa75ab0ecfb1276ed6c88cead", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6adb6030c126ad8aa75ab0ecfb1276ed6c88cead", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6adb6030c126ad8aa75ab0ecfb1276ed6c88cead", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6adb6030c126ad8aa75ab0ecfb1276ed6c88cead/comments", "author": null, "committer": null, "parents": [{"sha": "d8ae8d16017202f41b57f6b24aca4e20cd61340b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8ae8d16017202f41b57f6b24aca4e20cd61340b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8ae8d16017202f41b57f6b24aca4e20cd61340b"}], "stats": {"total": 131, "additions": 100, "deletions": 31}, "files": [{"sha": "33299c3789b0438f475026b245ad937baedcc415", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6adb6030c126ad8aa75ab0ecfb1276ed6c88cead/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6adb6030c126ad8aa75ab0ecfb1276ed6c88cead/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6adb6030c126ad8aa75ab0ecfb1276ed6c88cead", "patch": "@@ -1,3 +1,15 @@\n+2017-01-23  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_aggr.adb (Resolve_Array_Aggregate): In ASIS mode do not\n+\treport on spurious overlaps between values involving a subtype\n+\twith a static predicate, because the expansion of such a subtype\n+\tinto individual ranges in inhibited in ASIS mode.\n+\n+2017-01-23  Justin Squirek  <squirek@adacore.com>\n+\n+\t* sem_ch3.adb (Analyze_Declarations): Add detection\n+\tof an edge case and delay freezing if it is present.\n+\n 2017-01-23  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* sem_ch3.adb, exp_spark.adb, exp_attr.adb, sem_ch9.adb, sem_prag.adb,"}, {"sha": "80873180e1e7cd404b6037ebb163893ba2849f49", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6adb6030c126ad8aa75ab0ecfb1276ed6c88cead/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6adb6030c126ad8aa75ab0ecfb1276ed6c88cead/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=6adb6030c126ad8aa75ab0ecfb1276ed6c88cead", "patch": "@@ -2282,7 +2282,22 @@ package body Sem_Aggr is\n                               if Lo_Dup > Hi_Dup then\n                                  null;\n \n-                              --  Otherwise place proper message\n+                              --  Otherwise place proper message. Because\n+                              --  of the missing expansion of subtypes with\n+                              --  predicates in ASIS mode, do not report\n+                              --  spurious overlap errors.\n+\n+                              elsif ASIS_Mode\n+                                and then\n+                                  ((Is_Type (Entity (Table (J).Choice))\n+                                    and then Has_Predicates\n+                                      (Entity (Table (J).Choice)))\n+                                   or else\n+                                     (Is_Type (Entity (Table (K).Choice))\n+                                       and then Has_Predicates\n+                                          (Entity (Table (K).Choice))))\n+                              then\n+                                 null;\n \n                               else\n                                  --  We place message on later choice, with a"}, {"sha": "6a6254d4841a628693b82629181271183ef78d1e", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 72, "deletions": 30, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6adb6030c126ad8aa75ab0ecfb1276ed6c88cead/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6adb6030c126ad8aa75ab0ecfb1276ed6c88cead/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=6adb6030c126ad8aa75ab0ecfb1276ed6c88cead", "patch": "@@ -2490,6 +2490,10 @@ package body Sem_Ch3 is\n       Body_Seen : Boolean := False;\n       --  Flag set when the first body [stub] is encountered\n \n+      Ignore_Freezing : Boolean;\n+      --  Flag set when deciding to freeze an expression function in the\n+      --  current scope.\n+\n    --  Start of processing for Analyze_Declarations\n \n    begin\n@@ -2630,45 +2634,83 @@ package body Sem_Ch3 is\n \n          elsif not Analyzed (Next_Decl) and then Is_Body (Next_Decl) then\n \n-            --  When a controlled type is frozen, the expander generates stream\n-            --  and controlled type support routines. If the freeze is caused\n-            --  by the stand alone body of Initialize, Adjust and Finalize, the\n-            --  expander will end up using the wrong version of these routines\n-            --  as the body has not been processed yet. To remedy this, detect\n-            --  a late controlled primitive and create a proper spec for it.\n-            --  This ensures that the primitive will override its inherited\n-            --  counterpart before the freeze takes place.\n+            --  If there is an array type that uses a private type from an\n+            --  enclosing package which is in the same scope as an expression\n+            --  function that is not a completion then we cannot freeze here.\n+            --  So identify the case here and delay freezing.\n \n-            --  If the declaration we just processed is a body, do not attempt\n-            --  to examine Next_Decl as the late primitive idiom can only apply\n-            --  to the first encountered body.\n+            Ignore_Freezing := False;\n \n-            --  The spec of the late primitive is not generated in ASIS mode to\n-            --  ensure a consistent list of primitives that indicates the true\n-            --  semantic structure of the program (which is not relevant when\n-            --  generating executable code.\n+            if Nkind (Next_Decl) = N_Subprogram_Body\n+              and then Was_Expression_Function (Next_Decl)\n+              and then not Is_Compilation_Unit (Current_Scope)\n+              and then not Is_Generic_Instance (Current_Scope)\n+            then\n \n-            --  ??? a cleaner approach may be possible and/or this solution\n-            --  could be extended to general-purpose late primitives, TBD.\n+               --  Loop through all entities in the current scope to identify\n+               --  an instance of the edge case outlined above.\n \n-            if not ASIS_Mode and then not Body_Seen and then not Is_Body (Decl)\n-            then\n-               Body_Seen := True;\n+               declare\n+                  Curr : Entity_Id := First_Entity (Current_Scope);\n+               begin\n+                  loop\n+                     if Nkind (Curr) in N_Entity\n+                       and then Depends_On_Private (Curr)\n+                     then\n+                        Ignore_Freezing := True;\n+                        exit;\n+                     end if;\n \n-               if Nkind (Next_Decl) = N_Subprogram_Body then\n-                  Handle_Late_Controlled_Primitive (Next_Decl);\n-               end if;\n+                     exit when Last_Entity (Current_Scope) = Curr;\n+                     Curr := Next_Entity (Curr);\n+                  end loop;\n+               end;\n             end if;\n \n-            Adjust_Decl;\n+            if not Ignore_Freezing then\n+\n+               --  When a controlled type is frozen, the expander generates\n+               --  stream and controlled-type support routines. If the freeze\n+               --  is caused by the stand-alone body of Initialize, Adjust, or\n+               --  Finalize, the expander will end up using the wrong version\n+               --  of these routines, as the body has not been processed yet.\n+               --  To remedy this, detect a late controlled primitive and\n+               --  create a proper spec for it. This ensures that the primitive\n+               --  will override its inherited counterpart before the freeze\n+               --  takes place.\n \n-            --  The generated body of an expression function does not freeze,\n-            --  unless it is a completion, in which case only the expression\n-            --  itself freezes. THis is handled when the body itself is\n-            --  analyzed (see Freeze_Expr_Types, sem_ch6.adb).\n+               --  If the declaration we just processed is a body, do not\n+               --  attempt to examine Next_Decl as the late primitive idiom can\n+               --  only apply to the first encountered body.\n \n-            Freeze_All (Freeze_From, Decl);\n-            Freeze_From := Last_Entity (Current_Scope);\n+               --  The spec of the late primitive is not generated in ASIS mode\n+               --  to ensure a consistent list of primitives that indicates the\n+               --  true semantic structure of the program (which is not\n+               --  relevant when generating executable code).\n+\n+               --  ??? A cleaner approach may be possible and/or this solution\n+               --  could be extended to general-purpose late primitives, TBD.\n+\n+               if not ASIS_Mode and then not Body_Seen\n+                 and then not Is_Body (Decl)\n+               then\n+                  Body_Seen := True;\n+\n+                  if Nkind (Next_Decl) = N_Subprogram_Body then\n+                     Handle_Late_Controlled_Primitive (Next_Decl);\n+                  end if;\n+               end if;\n+\n+               Adjust_Decl;\n+\n+               --  The generated body of an expression function does not\n+               --  freeze, unless it is a completion, in which case only the\n+               --  expression itself freezes. This is handled when the body\n+               --  itself is analyzed (see Freeze_Expr_Types, sem_ch6.adb).\n+\n+               Freeze_All (Freeze_From, Decl);\n+               Freeze_From := Last_Entity (Current_Scope);\n+            end if;\n          end if;\n \n          Decl := Next_Decl;"}]}