{"sha": "b4e209fd1ad2bcceed90e8849e1ba903121013b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjRlMjA5ZmQxYWQyYmNjZWVkOTBlODg0OWUxYmE5MDMxMjEwMTNiNA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2012-07-31T13:42:16Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2012-07-31T13:42:16Z"}, "message": "tree-flow.h (struct var_ann_d): Remove need_phi_state and current_def members.\n\n2012-07-31  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-flow.h (struct var_ann_d): Remove need_phi_state\n\tand current_def members.\n\t* tree-into-ssa.c (struct def_blocks_d): Remove var member.\n\t(def_blocks): Remove.\n\t(struct var_info_d): New.\n\t(var_infos): New hashtable.\n\t(struct ssa_name_info): Add def_blocks member.\n\t(get_ssa_name_ann): Adjust.\n\t(get_var_info): New function.\n\t(get_phi_state, set_phi_state, get_current_def,\n\tset_current_def, get_def_blocks_for, find_def_blocks_for): Adjust.\n\t(insert_phi_nodes_compare_def_blocks): Rename to ...\n\t(insert_phi_nodes_compare_var_infos): ... this and adjust.\n\t(insert_phi_nodes): Adjust.\n\t(dump_tree_ssa, dump_tree_ssa_stats): Adjust.\n\t(def_blocks_hash, def_blocks_eq, def_blocks_free): Remove.\n\t(debug_def_blocks_r): Rename to ...\n\t(debug_var_infos_r): ... this and adjust.\n\t(var_info_hash): New function.\n\t(var_info_eq): Likewise.\n\t(rewrite_blocks): Adjust.\n\t(init_ssa_renamer): Likewise.\n\t(fini_ssa_renamer): Likewise.\n\t(delete_update_ssa): Likewise.\n\t(update_ssa): Likewise.\n\t* tree-ssanames.c (release_dead_ssa_names): Do not clear\n\tcurrent defs.\n\nFrom-SVN: r190012", "tree": {"sha": "192672a5cf42f01db3b8769a1d6479c3497473ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/192672a5cf42f01db3b8769a1d6479c3497473ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4e209fd1ad2bcceed90e8849e1ba903121013b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4e209fd1ad2bcceed90e8849e1ba903121013b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4e209fd1ad2bcceed90e8849e1ba903121013b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4e209fd1ad2bcceed90e8849e1ba903121013b4/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8539d639a863e52a59bad6ef6c7fbd7e80a4c042", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8539d639a863e52a59bad6ef6c7fbd7e80a4c042", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8539d639a863e52a59bad6ef6c7fbd7e80a4c042"}], "stats": {"total": 304, "additions": 162, "deletions": 142}, "files": [{"sha": "6b1851ab85de8c9f0dbbb23aa9592644e469ff8b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4e209fd1ad2bcceed90e8849e1ba903121013b4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4e209fd1ad2bcceed90e8849e1ba903121013b4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b4e209fd1ad2bcceed90e8849e1ba903121013b4", "patch": "@@ -1,3 +1,33 @@\n+2012-07-31  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-flow.h (struct var_ann_d): Remove need_phi_state\n+\tand current_def members.\n+\t* tree-into-ssa.c (struct def_blocks_d): Remove var member.\n+\t(def_blocks): Remove.\n+\t(struct var_info_d): New.\n+\t(var_infos): New hashtable.\n+\t(struct ssa_name_info): Add def_blocks member.\n+\t(get_ssa_name_ann): Adjust.\n+\t(get_var_info): New function.\n+\t(get_phi_state, set_phi_state, get_current_def,\n+\tset_current_def, get_def_blocks_for, find_def_blocks_for): Adjust.\n+\t(insert_phi_nodes_compare_def_blocks): Rename to ...\n+\t(insert_phi_nodes_compare_var_infos): ... this and adjust.\n+\t(insert_phi_nodes): Adjust.\n+\t(dump_tree_ssa, dump_tree_ssa_stats): Adjust.\n+\t(def_blocks_hash, def_blocks_eq, def_blocks_free): Remove.\n+\t(debug_def_blocks_r): Rename to ...\n+\t(debug_var_infos_r): ... this and adjust.\n+\t(var_info_hash): New function.\n+\t(var_info_eq): Likewise.\n+\t(rewrite_blocks): Adjust.\n+\t(init_ssa_renamer): Likewise.\n+\t(fini_ssa_renamer): Likewise.\n+\t(delete_update_ssa): Likewise.\n+\t(update_ssa): Likewise.\n+\t* tree-ssanames.c (release_dead_ssa_names): Do not clear\n+\tcurrent defs.\n+\n 2012-07-31  Bill Schmidt  <wschmidt@linux.ibm.com>\n \n \tPR tree-optimization/53773"}, {"sha": "301bd7e9c833dcaa379d92c7309dc26ed1771ef0", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4e209fd1ad2bcceed90e8849e1ba903121013b4/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4e209fd1ad2bcceed90e8849e1ba903121013b4/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=b4e209fd1ad2bcceed90e8849e1ba903121013b4", "patch": "@@ -184,17 +184,8 @@ struct GTY(()) var_ann_d {\n      applied.  We set this when translating out of SSA form.  */\n   unsigned used : 1;\n \n-  /* This field indicates whether or not the variable may need PHI nodes.\n-     See the enum's definition for more detailed information about the\n-     states.  */\n-  ENUM_BITFIELD (need_phi_state) need_phi_state : 2;\n-\n   /* Used by var_map for the base index of ssa base variables.  */\n   unsigned base_index;\n-\n-  /* During into-ssa and the dominator optimizer, this field holds the\n-     current version of this variable (an SSA_NAME).  */\n-  tree current_def;\n };\n \n "}, {"sha": "da747bfc442d9f3db93c3c7c77a02e12b55be9c9", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 132, "deletions": 126, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4e209fd1ad2bcceed90e8849e1ba903121013b4/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4e209fd1ad2bcceed90e8849e1ba903121013b4/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=b4e209fd1ad2bcceed90e8849e1ba903121013b4", "patch": "@@ -52,9 +52,6 @@ along with GCC; see the file COPYING3.  If not see\n    definitions for VAR.  */\n struct def_blocks_d\n {\n-  /* The variable.  */\n-  tree var;\n-\n   /* Blocks that contain definitions of VAR.  Bit I will be set if the\n      Ith block contains a definition of VAR.  */\n   bitmap def_blocks;\n@@ -69,18 +66,6 @@ struct def_blocks_d\n \n typedef struct def_blocks_d *def_blocks_p;\n \n-DEF_VEC_P(def_blocks_p);\n-DEF_VEC_ALLOC_P(def_blocks_p,heap);\n-\n-\n-/* Each entry in DEF_BLOCKS contains an element of type STRUCT\n-   DEF_BLOCKS_D, mapping a variable VAR to a bitmap describing all the\n-   basic blocks where VAR is defined (assigned a new value).  It also\n-   contains a bitmap of all the blocks where VAR is live-on-entry\n-   (i.e., there is a use of VAR in block B without a preceding\n-   definition in B).  The live-on-entry information is used when\n-   computing PHI pruning heuristics.  */\n-static htab_t def_blocks;\n \n /* Stack of trees used to restore the global currdefs to its original\n    state after completing rewriting of a block and its dominator\n@@ -142,6 +127,35 @@ struct mark_def_sites_global_data\n };\n \n \n+/* Information stored for decls.  */\n+struct var_info_d\n+{\n+  /* The variable.  */\n+  tree var;\n+\n+  /* This field indicates whether or not the variable may need PHI nodes.\n+     See the enum's definition for more detailed information about the\n+     states.  */\n+  ENUM_BITFIELD (need_phi_state) need_phi_state : 2;\n+\n+  /* The current reaching definition replacing this SSA name.  */\n+  tree current_def;\n+\n+  /* Definitions for this VAR.  */\n+  struct def_blocks_d def_blocks;\n+};\n+\n+/* The information associated with decls.  */\n+typedef struct var_info_d *var_info_p;\n+\n+DEF_VEC_P(var_info_p);\n+DEF_VEC_ALLOC_P(var_info_p,heap);\n+\n+/* Each entry in VAR_INFOS contains an element of type STRUCT \n+   VAR_INFO_D.  */\n+static htab_t var_infos;\n+\n+\n /* Information stored for SSA names.  */\n struct ssa_name_info\n {\n@@ -160,6 +174,9 @@ struct ssa_name_info\n \n   /* Replacement mappings, allocated from update_ssa_obstack.  */\n   bitmap repl_set;\n+\n+  /* Definitions for this SSA name.  */\n+  struct def_blocks_d def_blocks;\n };\n \n /* The information associated with names.  */\n@@ -203,8 +220,8 @@ extern void dump_update_ssa (FILE *);\n extern void debug_update_ssa (void);\n extern void dump_names_replaced_by (FILE *, tree);\n extern void debug_names_replaced_by (tree);\n-extern void dump_def_blocks (FILE *);\n-extern void debug_def_blocks (void);\n+extern void dump_var_infos (FILE *);\n+extern void debug_var_infos (void);\n extern void dump_defs_stack (FILE *, int);\n extern void debug_defs_stack (int);\n extern void dump_currdefs (FILE *);\n@@ -282,12 +299,34 @@ get_ssa_name_ann (tree name)\n       info->need_phi_state = NEED_PHI_STATE_UNKNOWN;\n       info->current_def = NULL_TREE;\n       info->repl_set = NULL;\n+      info->def_blocks.def_blocks = NULL;\n+      info->def_blocks.phi_blocks = NULL;\n+      info->def_blocks.livein_blocks = NULL;\n       info->age = current_info_for_ssa_name_age;\n     }\n \n   return info;\n }\n \n+/* Return and allocate the auxiliar information for DECL.  */\n+\n+static inline var_info_p\n+get_var_info (tree decl)\n+{\n+  struct var_info_d vi;\n+  void **slot;\n+  vi.var = decl;\n+  slot = htab_find_slot_with_hash (var_infos, &vi, DECL_UID (decl), INSERT);\n+  if (*slot == NULL)\n+    {\n+      var_info_p v = XCNEW (struct var_info_d);\n+      v->var = decl;\n+      *slot = (void *)v;\n+      return v;\n+    }\n+  return (var_info_p) *slot;\n+}\n+\n \n /* Clears info for SSA names.  */\n \n@@ -310,7 +349,7 @@ get_phi_state (tree var)\n   if (TREE_CODE (var) == SSA_NAME)\n     return get_ssa_name_ann (var)->need_phi_state;\n   else\n-    return var_ann (var)->need_phi_state;\n+    return get_var_info (var)->need_phi_state;\n }\n \n \n@@ -322,7 +361,7 @@ set_phi_state (tree var, enum need_phi_state state)\n   if (TREE_CODE (var) == SSA_NAME)\n     get_ssa_name_ann (var)->need_phi_state = state;\n   else\n-    var_ann (var)->need_phi_state = state;\n+    get_var_info (var)->need_phi_state = state;\n }\n \n \n@@ -334,7 +373,7 @@ get_current_def (tree var)\n   if (TREE_CODE (var) == SSA_NAME)\n     return get_ssa_name_ann (var)->current_def;\n   else\n-    return var_ann (var)->current_def;\n+    return get_var_info (var)->current_def;\n }\n \n \n@@ -346,7 +385,7 @@ set_current_def (tree var, tree def)\n   if (TREE_CODE (var) == SSA_NAME)\n     get_ssa_name_ann (var)->current_def = def;\n   else\n-    var_ann (var)->current_def = def;\n+    get_var_info (var)->current_def = def;\n }\n \n \n@@ -448,22 +487,19 @@ mark_block_for_update (basic_block bb)\n static inline struct def_blocks_d *\n get_def_blocks_for (tree var)\n {\n-  struct def_blocks_d db, *db_p;\n-  void **slot;\n+  struct def_blocks_d *db_p;\n \n-  db.var = var;\n-  slot = htab_find_slot (def_blocks, (void *) &db, INSERT);\n-  if (*slot == NULL)\n+  if (TREE_CODE (var) == SSA_NAME)\n+    db_p = &get_ssa_name_ann (var)->def_blocks;\n+  else\n+    db_p = &get_var_info (var)->def_blocks;\n+\n+  if (!db_p->def_blocks)\n     {\n-      db_p = XNEW (struct def_blocks_d);\n-      db_p->var = var;\n-      db_p->def_blocks = BITMAP_ALLOC (NULL);\n-      db_p->phi_blocks = BITMAP_ALLOC (NULL);\n-      db_p->livein_blocks = BITMAP_ALLOC (NULL);\n-      *slot = (void *) db_p;\n+      db_p->def_blocks = BITMAP_ALLOC (&update_ssa_obstack);\n+      db_p->phi_blocks = BITMAP_ALLOC (&update_ssa_obstack);\n+      db_p->livein_blocks = BITMAP_ALLOC (&update_ssa_obstack);\n     }\n-  else\n-    db_p = (struct def_blocks_d *) *slot;\n \n   return db_p;\n }\n@@ -922,9 +958,14 @@ prune_unused_phi_nodes (bitmap phis, bitmap kills, bitmap uses)\n static inline struct def_blocks_d *\n find_def_blocks_for (tree var)\n {\n-  struct def_blocks_d dm;\n-  dm.var = var;\n-  return (struct def_blocks_d *) htab_find (def_blocks, &dm);\n+  def_blocks_p p;\n+  if (TREE_CODE (var) == SSA_NAME)\n+    p = &get_ssa_name_ann (var)->def_blocks;\n+  else\n+    p = &get_var_info (var)->def_blocks;\n+  if (!p->def_blocks)\n+    return NULL;\n+  return p;\n }\n \n \n@@ -1062,13 +1103,13 @@ insert_phi_nodes_for (tree var, bitmap phi_insertion_points, bool update_p)\n     }\n }\n \n-/* Sort def_blocks after DECL_UID of their var.  */\n+/* Sort var_infos after DECL_UID of their var.  */\n \n static int\n-insert_phi_nodes_compare_def_blocks (const void *a, const void *b)\n+insert_phi_nodes_compare_var_infos (const void *a, const void *b)\n {\n-  const struct def_blocks_d *defa = *(struct def_blocks_d * const *)a;\n-  const struct def_blocks_d *defb = *(struct def_blocks_d * const *)b;\n+  const struct var_info_d *defa = *(struct var_info_d * const *)a;\n+  const struct var_info_d *defb = *(struct var_info_d * const *)b;\n   if (DECL_UID (defa->var) < DECL_UID (defb->var))\n     return -1;\n   else\n@@ -1084,28 +1125,28 @@ insert_phi_nodes (bitmap_head *dfs)\n {\n   htab_iterator hi;\n   unsigned i;\n-  struct def_blocks_d *def_map;\n-  VEC(def_blocks_p,heap) *vars;\n+  var_info_p info;\n+  VEC(var_info_p,heap) *vars;\n \n   timevar_push (TV_TREE_INSERT_PHI_NODES);\n \n-  vars = VEC_alloc (def_blocks_p, heap, htab_elements (def_blocks));\n-  FOR_EACH_HTAB_ELEMENT (def_blocks, def_map, struct def_blocks_d *, hi)\n-    if (get_phi_state (def_map->var) != NEED_PHI_STATE_NO)\n-      VEC_quick_push (def_blocks_p, vars, def_map);\n+  vars = VEC_alloc (var_info_p, heap, htab_elements (var_infos));\n+  FOR_EACH_HTAB_ELEMENT (var_infos, info, var_info_p, hi)\n+    if (info->need_phi_state != NEED_PHI_STATE_NO)\n+      VEC_quick_push (var_info_p, vars, info);\n \n   /* Do two stages to avoid code generation differences for UID\n      differences but no UID ordering differences.  */\n-  VEC_qsort (def_blocks_p, vars, insert_phi_nodes_compare_def_blocks);\n+  VEC_qsort (var_info_p, vars, insert_phi_nodes_compare_var_infos);\n \n-  FOR_EACH_VEC_ELT (def_blocks_p, vars, i, def_map)\n+  FOR_EACH_VEC_ELT (var_info_p, vars, i, info)\n     {\n-      bitmap idf = compute_idf (def_map->def_blocks, dfs);\n-      insert_phi_nodes_for (def_map->var, idf, false);\n+      bitmap idf = compute_idf (info->def_blocks.def_blocks, dfs);\n+      insert_phi_nodes_for (info->var, idf, false);\n       BITMAP_FREE (idf);\n     }\n \n-  VEC_free(def_blocks_p, heap, vars);\n+  VEC_free(var_info_p, heap, vars);\n \n   timevar_pop (TV_TREE_INSERT_PHI_NODES);\n }\n@@ -1634,7 +1675,7 @@ dump_tree_ssa (FILE *file)\n \n   fprintf (file, \"SSA renaming information for %s\\n\\n\", funcname);\n \n-  dump_def_blocks (file);\n+  dump_var_infos (file);\n   dump_defs_stack (file, -1);\n   dump_currdefs (file);\n   dump_tree_ssa_stats (file);\n@@ -1667,17 +1708,13 @@ htab_statistics (FILE *file, htab_t htab)\n void\n dump_tree_ssa_stats (FILE *file)\n {\n-  if (def_blocks)\n-    fprintf (file, \"\\nHash table statistics:\\n\");\n-\n-  if (def_blocks)\n+  if (var_infos)\n     {\n-      fprintf (file, \"    def_blocks:   \");\n-      htab_statistics (file, def_blocks);\n+      fprintf (file, \"\\nHash table statistics:\\n\");\n+      fprintf (file, \"    var_infos:   \");\n+      htab_statistics (file, var_infos);\n+      fprintf (file, \"\\n\");\n     }\n-\n-  if (def_blocks)\n-    fprintf (file, \"\\n\");\n }\n \n \n@@ -1690,71 +1727,57 @@ debug_tree_ssa_stats (void)\n }\n \n \n-/* Hashing and equality functions for DEF_BLOCKS.  */\n+/* Hashing and equality functions for VAR_INFOS.  */\n \n static hashval_t\n-def_blocks_hash (const void *p)\n+var_info_hash (const void *p)\n {\n-  return htab_hash_pointer\n-\t((const void *)((const struct def_blocks_d *)p)->var);\n+  return DECL_UID (((const struct var_info_d *)p)->var);\n }\n \n static int\n-def_blocks_eq (const void *p1, const void *p2)\n-{\n-  return ((const struct def_blocks_d *)p1)->var\n-\t == ((const struct def_blocks_d *)p2)->var;\n-}\n-\n-\n-/* Free memory allocated by one entry in DEF_BLOCKS.  */\n-\n-static void\n-def_blocks_free (void *p)\n+var_info_eq (const void *p1, const void *p2)\n {\n-  struct def_blocks_d *entry = (struct def_blocks_d *) p;\n-  BITMAP_FREE (entry->def_blocks);\n-  BITMAP_FREE (entry->phi_blocks);\n-  BITMAP_FREE (entry->livein_blocks);\n-  free (entry);\n+  return ((const struct var_info_d *)p1)->var\n+\t == ((const struct var_info_d *)p2)->var;\n }\n \n \n-/* Callback for htab_traverse to dump the DEF_BLOCKS hash table.  */\n+/* Callback for htab_traverse to dump the VAR_INFOS hash table.  */\n \n static int\n-debug_def_blocks_r (void **slot, void *data)\n+debug_var_infos_r (void **slot, void *data)\n {\n   FILE *file = (FILE *) data;\n-  struct def_blocks_d *db_p = (struct def_blocks_d *) *slot;\n+  struct var_info_d *db_p = (struct var_info_d *) *slot;\n \n   fprintf (file, \"VAR: \");\n   print_generic_expr (file, db_p->var, dump_flags);\n-  bitmap_print (file, db_p->def_blocks, \", DEF_BLOCKS: { \", \"}\");\n-  bitmap_print (file, db_p->livein_blocks, \", LIVEIN_BLOCKS: { \", \"}\");\n-  bitmap_print (file, db_p->phi_blocks, \", PHI_BLOCKS: { \", \"}\\n\");\n+  bitmap_print (file, db_p->def_blocks.def_blocks, \", DEF_BLOCKS: { \", \"}\");\n+  bitmap_print (file, db_p->def_blocks.livein_blocks, \", LIVEIN_BLOCKS: { \", \"}\");\n+  bitmap_print (file, db_p->def_blocks.phi_blocks, \", PHI_BLOCKS: { \", \"}\\n\");\n \n   return 1;\n }\n \n \n-/* Dump the DEF_BLOCKS hash table on FILE.  */\n+/* Dump the VAR_INFOS hash table on FILE.  */\n \n void\n-dump_def_blocks (FILE *file)\n+dump_var_infos (FILE *file)\n {\n   fprintf (file, \"\\n\\nDefinition and live-in blocks:\\n\\n\");\n-  if (def_blocks)\n-    htab_traverse (def_blocks, debug_def_blocks_r, file);\n+  if (var_infos)\n+    htab_traverse (var_infos, debug_var_infos_r, file);\n }\n \n \n-/* Dump the DEF_BLOCKS hash table on stderr.  */\n+/* Dump the VAR_INFOS hash table on stderr.  */\n \n DEBUG_FUNCTION void\n-debug_def_blocks (void)\n+debug_var_infos (void)\n {\n-  dump_def_blocks (stderr);\n+  dump_var_infos (stderr);\n }\n \n \n@@ -2245,7 +2268,7 @@ rewrite_blocks (basic_block entry, enum rewrite_mode what)\n   if (dump_file && (dump_flags & TDF_STATS))\n     {\n       dump_dfa_stats (dump_file);\n-      if (def_blocks)\n+      if (var_infos)\n \tdump_tree_ssa_stats (dump_file);\n     }\n \n@@ -2322,18 +2345,14 @@ mark_def_site_blocks (void)\n static void\n init_ssa_renamer (void)\n {\n-  tree var;\n-  referenced_var_iterator rvi;\n-\n   cfun->gimple_df->in_ssa_p = false;\n \n   /* Allocate memory for the DEF_BLOCKS hash table.  */\n-  gcc_assert (def_blocks == NULL);\n-  def_blocks = htab_create (num_referenced_vars, def_blocks_hash,\n-                            def_blocks_eq, def_blocks_free);\n+  gcc_assert (var_infos == NULL);\n+  var_infos = htab_create (VEC_length (tree, cfun->local_decls),\n+\t\t\t   var_info_hash, var_info_eq, NULL);\n \n-  FOR_EACH_REFERENCED_VAR (cfun, var, rvi)\n-    set_current_def (var, NULL_TREE);\n+  bitmap_obstack_initialize (&update_ssa_obstack);\n }\n \n \n@@ -2342,12 +2361,14 @@ init_ssa_renamer (void)\n static void\n fini_ssa_renamer (void)\n {\n-  if (def_blocks)\n+  if (var_infos)\n     {\n-      htab_delete (def_blocks);\n-      def_blocks = NULL;\n+      htab_delete (var_infos);\n+      var_infos = NULL;\n     }\n \n+  bitmap_obstack_release (&update_ssa_obstack);\n+\n   cfun->gimple_df->in_ssa_p = true;\n }\n \n@@ -2825,8 +2846,6 @@ delete_update_ssa (void)\n   BITMAP_FREE (blocks_with_phis_to_rewrite);\n   BITMAP_FREE (blocks_to_update);\n \n-  bitmap_obstack_release (&update_ssa_obstack);\n-\n   update_ssa_initialized_fn = NULL;\n }\n \n@@ -3146,23 +3165,6 @@ update_ssa (unsigned update_flags)\n \n   insert_phi_p = (update_flags != TODO_update_ssa_no_phi);\n \n-  if (insert_phi_p)\n-    {\n-      /* If the caller requested PHI nodes to be added, initialize\n-\t live-in information data structures (DEF_BLOCKS).  */\n-\n-      /* For each SSA name N, the DEF_BLOCKS table describes where the\n-\t name is defined, which blocks have PHI nodes for N, and which\n-\t blocks have uses of N (i.e., N is live-on-entry in those\n-\t blocks).  */\n-      def_blocks = htab_create (num_ssa_names, def_blocks_hash,\n-\t\t\t\tdef_blocks_eq, def_blocks_free);\n-    }\n-  else\n-    {\n-      def_blocks = NULL;\n-    }\n-\n   /* If there are names defined in the replacement table, prepare\n      definition and use sites for all the names in NEW_SSA_NAMES and\n      OLD_SSA_NAMES.  */\n@@ -3181,6 +3183,10 @@ update_ssa (unsigned update_flags)\n   /* Next, determine the block at which to start the renaming process.  */\n   if (!bitmap_empty_p (SYMS_TO_RENAME (cfun)))\n     {\n+      /* If we rename bare symbols initialize the mapping to\n+         auxiliar info we need to keep track of.  */\n+      var_infos = htab_create (47, var_info_hash, var_info_eq, NULL);\n+\n       /* If we have to rename some symbols from scratch, we need to\n \t start the process at the root of the CFG.  FIXME, it should\n \t be possible to determine the nearest block that had a"}, {"sha": "67c406f4ba1bc9db7eb5ae3ea30d88ea058331e1", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4e209fd1ad2bcceed90e8849e1ba903121013b4/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4e209fd1ad2bcceed90e8849e1ba903121013b4/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=b4e209fd1ad2bcceed90e8849e1ba903121013b4", "patch": "@@ -380,15 +380,8 @@ replace_ssa_name_symbol (tree ssa_name, tree sym)\n static unsigned int\n release_dead_ssa_names (void)\n {\n-  tree t;\n   unsigned i, j;\n   int n = VEC_length (tree, FREE_SSANAMES (cfun));\n-  referenced_var_iterator rvi;\n-\n-  /* Current defs point to various dead SSA names that in turn point to\n-     eventually dead variables so a bunch of memory is held live.  */\n-  FOR_EACH_REFERENCED_VAR (cfun, t, rvi)\n-    set_current_def (t, NULL);\n \n   /* Now release the freelist.  */\n   VEC_free (tree, gc, FREE_SSANAMES (cfun));"}]}