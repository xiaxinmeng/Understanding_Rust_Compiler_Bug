{"sha": "48960b6897e6e7749def5370119aa4888ccf54b1", "node_id": "C_kwDOANBUbNoAKDQ4OTYwYjY4OTdlNmU3NzQ5ZGVmNTM3MDExOWFhNDg4OGNjZjU0YjE", "commit": {"author": {"name": "Andrew Stubbs", "email": "ams@codesourcery.com", "date": "2020-10-02T14:12:50Z"}, "committer": {"name": "Andrew Stubbs", "email": "ams@codesourcery.com", "date": "2022-10-03T14:25:27Z"}, "message": "vect: while_ult for integer masks\n\nAdd a vector length parameter needed by amdgcn without breaking aarch64.\n\nAll amdgcn vector masks are DImode, regardless of vector length, so we can't\ntell what length is implied simply from the operator mode.  (Even if we used\ndifferent integer modes there's no mode small enough to differenciate a 2 or\n4 lane mask).  Without knowing the intended length we end up using a mask with\ntoo many lanes enabled, which leads to undefined behaviour..\n\nThe extra operand is not added for vector mask types so AArch64 does not need\nto be adjusted.\n\ngcc/ChangeLog:\n\n\t* config/gcn/gcn-valu.md (while_ultsidi): Limit mask length using\n\toperand 3.\n\t* doc/md.texi (while_ult): Document new operand 3 usage.\n\t* internal-fn.cc (expand_while_optab_fn): Set operand 3 when lhs_type\n\tmaps to a non-vector mode.", "tree": {"sha": "cec7d9810d92434af43f7f10fda3dfbedf9757e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cec7d9810d92434af43f7f10fda3dfbedf9757e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/48960b6897e6e7749def5370119aa4888ccf54b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48960b6897e6e7749def5370119aa4888ccf54b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48960b6897e6e7749def5370119aa4888ccf54b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48960b6897e6e7749def5370119aa4888ccf54b1/comments", "author": {"login": "ams-cs", "id": 2235130, "node_id": "MDQ6VXNlcjIyMzUxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2235130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ams-cs", "html_url": "https://github.com/ams-cs", "followers_url": "https://api.github.com/users/ams-cs/followers", "following_url": "https://api.github.com/users/ams-cs/following{/other_user}", "gists_url": "https://api.github.com/users/ams-cs/gists{/gist_id}", "starred_url": "https://api.github.com/users/ams-cs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ams-cs/subscriptions", "organizations_url": "https://api.github.com/users/ams-cs/orgs", "repos_url": "https://api.github.com/users/ams-cs/repos", "events_url": "https://api.github.com/users/ams-cs/events{/privacy}", "received_events_url": "https://api.github.com/users/ams-cs/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ams-cs", "id": 2235130, "node_id": "MDQ6VXNlcjIyMzUxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2235130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ams-cs", "html_url": "https://github.com/ams-cs", "followers_url": "https://api.github.com/users/ams-cs/followers", "following_url": "https://api.github.com/users/ams-cs/following{/other_user}", "gists_url": "https://api.github.com/users/ams-cs/gists{/gist_id}", "starred_url": "https://api.github.com/users/ams-cs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ams-cs/subscriptions", "organizations_url": "https://api.github.com/users/ams-cs/orgs", "repos_url": "https://api.github.com/users/ams-cs/repos", "events_url": "https://api.github.com/users/ams-cs/events{/privacy}", "received_events_url": "https://api.github.com/users/ams-cs/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f41d1b39a6443fad38c36af34b1baa384954ca80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f41d1b39a6443fad38c36af34b1baa384954ca80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f41d1b39a6443fad38c36af34b1baa384954ca80"}], "stats": {"total": 41, "additions": 35, "deletions": 6}, "files": [{"sha": "dec81e863f769850c6a5cd060e18846d82673e1c", "filename": "gcc/config/gcn/gcn-valu.md", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48960b6897e6e7749def5370119aa4888ccf54b1/gcc%2Fconfig%2Fgcn%2Fgcn-valu.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48960b6897e6e7749def5370119aa4888ccf54b1/gcc%2Fconfig%2Fgcn%2Fgcn-valu.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn-valu.md?ref=48960b6897e6e7749def5370119aa4888ccf54b1", "patch": "@@ -3052,7 +3052,8 @@\n (define_expand \"while_ultsidi\"\n   [(match_operand:DI 0 \"register_operand\")\n    (match_operand:SI 1 \"\")\n-   (match_operand:SI 2 \"\")]\n+   (match_operand:SI 2 \"\")\n+   (match_operand:SI 3 \"\")]\n   \"\"\n   {\n     if (GET_CODE (operands[1]) != CONST_INT\n@@ -3077,6 +3078,11 @@\n \t\t\t      : ~((unsigned HOST_WIDE_INT)-1 << diff));\n \temit_move_insn (operands[0], gen_rtx_CONST_INT (VOIDmode, mask));\n       }\n+    if (INTVAL (operands[3]) < 64)\n+      emit_insn (gen_anddi3 (operands[0], operands[0],\n+\t\t\t     gen_rtx_CONST_INT (VOIDmode,\n+\t\t\t\t\t\t~((unsigned HOST_WIDE_INT)-1\n+\t\t\t\t\t\t  << INTVAL (operands[3])))));\n     DONE;\n   })\n "}, {"sha": "bb42ee1da36cd0baa53ca558fddce1175c73c1f1", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48960b6897e6e7749def5370119aa4888ccf54b1/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48960b6897e6e7749def5370119aa4888ccf54b1/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=48960b6897e6e7749def5370119aa4888ccf54b1", "patch": "@@ -4950,16 +4950,25 @@ This pattern is not allowed to @code{FAIL}.\n @cindex @code{while_ult@var{m}@var{n}} instruction pattern\n @item @code{while_ult@var{m}@var{n}}\n Set operand 0 to a mask that is true while incrementing operand 1\n-gives a value that is less than operand 2.  Operand 0 has mode @var{n}\n-and operands 1 and 2 are scalar integers of mode @var{m}.\n-The operation is equivalent to:\n+gives a value that is less than operand 2, for a vector length up to operand 3.\n+Operand 0 has mode @var{n} and operands 1 and 2 are scalar integers of mode\n+@var{m}.  Operand 3 should be omitted when @var{n} is a vector mode, and\n+a @code{CONST_INT} otherwise.  The operation for vector modes is equivalent to:\n \n @smallexample\n operand0[0] = operand1 < operand2;\n for (i = 1; i < GET_MODE_NUNITS (@var{n}); i++)\n   operand0[i] = operand0[i - 1] && (operand1 + i < operand2);\n @end smallexample\n \n+And for non-vector modes the operation is equivalent to:\n+\n+@smallexample\n+operand0[0] = operand1 < operand2;\n+for (i = 1; i < operand3; i++)\n+  operand0[i] = operand0[i - 1] && (operand1 + i < operand2);\n+@end smallexample\n+\n @cindex @code{check_raw_ptrs@var{m}} instruction pattern\n @item @samp{check_raw_ptrs@var{m}}\n Check whether, given two pointers @var{a} and @var{b} and a length @var{len},"}, {"sha": "c306240c2acebf59a447a28e271c375e70eb8ae2", "filename": "gcc/internal-fn.cc", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48960b6897e6e7749def5370119aa4888ccf54b1/gcc%2Finternal-fn.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48960b6897e6e7749def5370119aa4888ccf54b1/gcc%2Finternal-fn.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.cc?ref=48960b6897e6e7749def5370119aa4888ccf54b1", "patch": "@@ -3664,7 +3664,7 @@ expand_direct_optab_fn (internal_fn fn, gcall *stmt, direct_optab optab,\n static void\n expand_while_optab_fn (internal_fn, gcall *stmt, convert_optab optab)\n {\n-  expand_operand ops[3];\n+  expand_operand ops[4];\n   tree rhs_type[2];\n \n   tree lhs = gimple_call_lhs (stmt);\n@@ -3680,10 +3680,24 @@ expand_while_optab_fn (internal_fn, gcall *stmt, convert_optab optab)\n       create_input_operand (&ops[i + 1], rhs_rtx, TYPE_MODE (rhs_type[i]));\n     }\n \n+  int opcnt;\n+  if (!VECTOR_MODE_P (TYPE_MODE (lhs_type)))\n+    {\n+      /* When the mask is an integer mode the exact vector length may not\n+\t be clear to the backend, so we pass it in operand[3].\n+         Use the vector in arg2 for the most reliable intended size.  */\n+      tree type = TREE_TYPE (gimple_call_arg (stmt, 2));\n+      create_integer_operand (&ops[3], TYPE_VECTOR_SUBPARTS (type));\n+      opcnt = 4;\n+    }\n+  else\n+    /* The mask has a vector type so the length operand is unnecessary.  */\n+    opcnt = 3;\n+\n   insn_code icode = convert_optab_handler (optab, TYPE_MODE (rhs_type[0]),\n \t\t\t\t\t   TYPE_MODE (lhs_type));\n \n-  expand_insn (icode, 3, ops);\n+  expand_insn (icode, opcnt, ops);\n   if (!rtx_equal_p (lhs_rtx, ops[0].value))\n     emit_move_insn (lhs_rtx, ops[0].value);\n }"}]}