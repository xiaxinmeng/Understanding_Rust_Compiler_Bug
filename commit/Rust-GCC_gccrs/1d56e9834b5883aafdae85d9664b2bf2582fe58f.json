{"sha": "1d56e9834b5883aafdae85d9664b2bf2582fe58f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWQ1NmU5ODM0YjU4ODNhYWZkYWU4NWQ5NjY0YjJiZjI1ODJmZTU4Zg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1991-12-31T23:38:08Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1991-12-31T23:38:08Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r151", "tree": {"sha": "6c0ca919271ec2f80390ea1c2d94c830f8fffdec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c0ca919271ec2f80390ea1c2d94c830f8fffdec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1d56e9834b5883aafdae85d9664b2bf2582fe58f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d56e9834b5883aafdae85d9664b2bf2582fe58f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d56e9834b5883aafdae85d9664b2bf2582fe58f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d56e9834b5883aafdae85d9664b2bf2582fe58f/comments", "author": null, "committer": null, "parents": [{"sha": "01fa70ee7367f753ef72a51ef9e54f7bcc5f4e0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01fa70ee7367f753ef72a51ef9e54f7bcc5f4e0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01fa70ee7367f753ef72a51ef9e54f7bcc5f4e0c"}], "stats": {"total": 126, "additions": 99, "deletions": 27}, "files": [{"sha": "c016d3831718f29c9e1fffa6b8b269999f111614", "filename": "gcc/global.c", "status": "modified", "additions": 99, "deletions": 27, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d56e9834b5883aafdae85d9664b2bf2582fe58f/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d56e9834b5883aafdae85d9664b2bf2582fe58f/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=1d56e9834b5883aafdae85d9664b2bf2582fe58f", "patch": "@@ -173,6 +173,16 @@ static int *allocno_n_refs;\n \n static int *allocno_live_length;\n \n+/* Number of refs (weighted) to each hard reg, as used by local alloc.\n+   It is zero for a reg that contains global pseudos or is explicitly used.  */\n+\n+static int local_reg_n_refs[FIRST_PSEUDO_REGISTER];\n+\n+/* Guess at live length of each hard reg, as used by local alloc.\n+   This is actually the sum of the live lengths of the specific regs.  */\n+\n+static int local_reg_live_length[FIRST_PSEUDO_REGISTER];\n+\n /* Test a bit in TABLE, a vector of HARD_REG_SETs,\n    for vector element I, and hard register number J.  */\n \n@@ -284,17 +294,15 @@ global_alloc (file)\n \n       if (! CAN_ELIMINATE (eliminables[i].from, eliminables[i].to)\n \t  || (eliminables[i].from == FRAME_POINTER_REGNUM\n-\t      && (! flag_omit_frame_pointer || FRAME_POINTER_REQUIRED\n-\t\t  || caller_save_needed)))\n+\t      && (! flag_omit_frame_pointer || FRAME_POINTER_REQUIRED)))\n \tSET_HARD_REG_BIT (no_global_alloc_regs, eliminables[i].from);\n     }\n #else\n   SET_HARD_REG_BIT (eliminable_regset, FRAME_POINTER_REGNUM);\n \n   /* If we know we will definitely not be eliminating the frame pointer,\n      don't allocate it.  */\n-  if (! flag_omit_frame_pointer || FRAME_POINTER_REQUIRED\n-      || caller_save_needed)\n+  if (! flag_omit_frame_pointer || FRAME_POINTER_REQUIRED)\n     SET_HARD_REG_BIT (no_global_alloc_regs, FRAME_POINTER_REGNUM);\n #endif\n \n@@ -378,6 +386,22 @@ global_alloc (file)\n \t  allocno_live_length[allocno] = reg_live_length[i];\n       }\n \n+  /* Calculate amount of usage of each hard reg by pseudos\n+     allocated by local-alloc.  This is to see if we want to\n+     override it.  */\n+  bzero (local_reg_live_length, sizeof local_reg_live_length);\n+  bzero (local_reg_n_refs, sizeof local_reg_n_refs);\n+  for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n+    if (reg_allocno[i] < 0 && reg_renumber[i] >= 0)\n+      {\n+\tlocal_reg_n_refs[reg_renumber[i]] += reg_n_refs[i];\n+\tlocal_reg_live_length[reg_renumber[i]] += reg_live_length[i];\n+      }\n+  /* We can't override local-alloc for a reg used not just by local-alloc.  */\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    if (regs_ever_live[i])\n+      local_reg_n_refs[i] = 0;\n+\n   /* Allocate the space for the conflict and preference tables and\n      initialize them.  */\n \n@@ -422,10 +446,16 @@ global_alloc (file)\n \t the register is not eliminated, the pseudo won't really be able to\n \t live in the eliminable register, so the conflict doesn't matter.\n \t If we do eliminate the register, the conflict will no longer exist.\n-\t So in either case, we can ignore the conflict.  */\n+\t So in either case, we can ignore the conflict.  Likewise for\n+\t preferences.  */\n \n       for (i = 0; i < max_allocno; i++)\n-\tAND_COMPL_HARD_REG_SET (hard_reg_conflicts[i], eliminable_regset);\n+\t{\n+\t  AND_COMPL_HARD_REG_SET (hard_reg_conflicts[i], eliminable_regset);\n+\t  AND_COMPL_HARD_REG_SET (hard_reg_copy_preferences[i],\n+\t\t\t\t  eliminable_regset);\n+\t  AND_COMPL_HARD_REG_SET (hard_reg_preferences[i], eliminable_regset);\n+\t}\n \n       /* Try to expand the preferences by merging them between allocnos.  */\n \n@@ -470,12 +500,12 @@ global_alloc (file)\n \t       for this pseudo-reg.  If that fails, try any reg.  */\n \t    if (N_REG_CLASSES > 1)\n \t      {\n-\t\tfind_reg (allocno_order[i], HARD_CONST (0), 0, 0);\n+\t\tfind_reg (allocno_order[i], HARD_CONST (0), 0, 0, 0);\n \t\tif (reg_renumber[allocno_reg[allocno_order[i]]] >= 0)\n \t\t  continue;\n \t      }\n \t    if (!reg_preferred_or_nothing (allocno_reg[allocno_order[i]]))\n-\t      find_reg (allocno_order[i], HARD_CONST (0), 1, 0);\n+\t      find_reg (allocno_order[i], HARD_CONST (0), 1, 0, 0);\n \t  }\n     }\n \n@@ -775,21 +805,24 @@ prune_preferences ()\n    If ACCEPT_CALL_CLOBBERED is nonzero, accept a call-clobbered hard reg that\n    will have to be saved and restored at calls.\n \n+   RETRYING is nonzero if this is called from retry_global_alloc.\n+\n    If we find one, record it in reg_renumber.\n    If not, do nothing.  */\n \n static void\n-find_reg (allocno, losers, all_regs_p, accept_call_clobbered)\n+find_reg (allocno, losers, all_regs_p, accept_call_clobbered, retrying)\n      int allocno;\n      HARD_REG_SET losers;\n      int all_regs_p;\n      int accept_call_clobbered;\n+     int retrying;\n {\n   register int i, best_reg, pass;\n #ifdef HARD_REG_SET\n   register\t\t/* Declare it register if it's a scalar.  */\n #endif\n-    HARD_REG_SET used, used1;\n+    HARD_REG_SET used, used1, used2;\n \n   enum reg_class class \n     = all_regs_p ? ALL_REGS : reg_preferred_class (allocno_reg[allocno]);\n@@ -808,6 +841,8 @@ find_reg (allocno, losers, all_regs_p, accept_call_clobbered)\n     IOR_HARD_REG_SET (used1, losers);\n \n   IOR_COMPL_HARD_REG_SET (used1, reg_class_contents[(int) class]);\n+  COPY_HARD_REG_SET (used2, used1);\n+\n   IOR_HARD_REG_SET (used1, hard_reg_conflicts[allocno]);\n \n   /* Try each hard reg to see if it fits.  Do this in two passes.\n@@ -938,6 +973,56 @@ find_reg (allocno, losers, all_regs_p, accept_call_clobbered)\n     }\n  no_prefs:\n \n+  /* If we haven't succeeded yet, try with caller-saves.  */\n+  if (flag_caller_saves && best_reg < 0)\n+    {\n+      /* Did not find a register.  If it would be profitable to\n+\t allocate a call-clobbered register and save and restore it\n+\t around calls, do that.  */\n+      if (! accept_call_clobbered\n+\t  && allocno_calls_crossed[allocno] != 0\n+\t  && CALLER_SAVE_PROFITABLE (allocno_n_refs[allocno],\n+\t\t\t\t     allocno_calls_crossed[allocno]))\n+\t{\n+\t  find_reg (allocno, losers, all_regs_p, 1, retrying);\n+\t  if (reg_renumber[allocno_reg[allocno]] >= 0)\n+\t    {\n+\t      caller_save_needed = 1;\n+\t      return;\n+\t    }\n+\t}\n+    }\n+\n+  /* If we haven't succeeded yet,\n+     see if some hard reg that conflicts with us\n+     was utilized poorly by local-alloc.\n+     If so, kick out the regs that were put there by local-alloc\n+     so we can use it instead.  */\n+  if (best_reg < 0 && !retrying\n+      /* Let's not bother with multi-reg allocnos.  */\n+      && allocno_size[allocno] == 1)\n+    {\n+      /* Count from the end, to find the least-used ones first.  */\n+      for (i = FIRST_PSEUDO_REGISTER - 1; i >= 0; i--)\n+\tif (local_reg_n_refs[i] != 0\n+\t    /* Don't use a reg no good for this pseudo.  */\n+\t    && ! TEST_HARD_REG_BIT (used2, i)\n+\t    && HARD_REGNO_MODE_OK (i, mode)\n+\t    && ((double) local_reg_n_refs[i] / local_reg_live_length[i]\n+\t\t< ((double) allocno_n_refs[allocno]\n+\t\t   / allocno_live_length[allocno])))\n+\t  {\n+\t    /* Hard reg I was used less in total by local regs\n+\t       than it would be used by this one allocno!  */\n+\t    int k;\n+\t    for (k = 0; k < max_regno; k++)\n+\t      if (reg_renumber[k] == i)\n+\t\treg_renumber[k] = -1;\n+\t    best_reg = i;\n+\t    break;\n+\t  }\n+    }\n+\n   /* Did we find a register?  */\n \n   if (best_reg >= 0)\n@@ -960,6 +1045,8 @@ find_reg (allocno, losers, all_regs_p, accept_call_clobbered)\n \t{\n \t  SET_HARD_REG_BIT (this_reg, j);\n \t  SET_HARD_REG_BIT (regs_used_so_far, j);\n+\t  /* This is no longer a reg used just by local regs.  */\n+\t  local_reg_n_refs[j] = 0;\n \t}\n       /* For each other pseudo-reg conflicting with this one,\n \t mark it as conflicting with the hard regs this one occupies.  */\n@@ -970,21 +1057,6 @@ find_reg (allocno, losers, all_regs_p, accept_call_clobbered)\n \t    IOR_HARD_REG_SET (hard_reg_conflicts[j], this_reg);\n \t  }\n     }\n-  else if (flag_caller_saves)\n-    {\n-      /* Did not find a register.  If it would be profitable to\n-\t allocate a call-clobbered register and save and restore it\n-\t around calls, do that.  */\n-      if (! accept_call_clobbered\n-\t  && allocno_calls_crossed[allocno] != 0\n-\t  && CALLER_SAVE_PROFITABLE (allocno_n_refs[allocno],\n-\t\t\t\t     allocno_calls_crossed[allocno]))\n-\t{\n-\t  find_reg (allocno, losers, all_regs_p, 1);\n-\t  if (reg_renumber[allocno_reg[allocno]] >= 0)\n-\t    caller_save_needed = 1;\n-\t}\n-    }\n }\n \f\n /* Called from `reload' to look for a hard reg to put pseudo reg REGNO in.\n@@ -1006,10 +1078,10 @@ retry_global_alloc (regno, forbidden_regs)\n \t first try allocating in the class that is cheapest\n \t for this pseudo-reg.  If that fails, try any reg.  */\n       if (N_REG_CLASSES > 1)\n-\tfind_reg (allocno, forbidden_regs, 0, 0);\n+\tfind_reg (allocno, forbidden_regs, 0, 0, 1);\n       if (reg_renumber[regno] < 0\n \t  && !reg_preferred_or_nothing (regno))\n-\tfind_reg (allocno, forbidden_regs, 1, 0);\n+\tfind_reg (allocno, forbidden_regs, 1, 0, 1);\n \n       /* If we found a register, modify the RTL for the register to\n \t show the hard register, and mark that register live.  */"}]}