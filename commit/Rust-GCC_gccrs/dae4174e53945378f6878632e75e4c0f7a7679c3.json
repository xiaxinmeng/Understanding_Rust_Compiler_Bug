{"sha": "dae4174e53945378f6878632e75e4c0f7a7679c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGFlNDE3NGU1Mzk0NTM3OGY2ODc4NjMyZTc1ZTRjMGY3YTc2NzljMw==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2008-05-21T15:00:59Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2008-05-21T15:00:59Z"}, "message": "symtab.h (HT_ALLOCED): Remove.\n\nlibcpp\n\t* include/symtab.h (HT_ALLOCED): Remove.\n\t(ht_purge): Declare.\n\t* symtab.c (DELETED): New define.\n\t(ht_lookup): Update comment.\n\t(ht_lookup_with_hash): Handle deleted entries.  Remove HT_ALLOCED\n\tcode.  Use subobject allocator for strings, if it exists.\n\t(ht_expand): Handle deleted entries.\n\t(ht_forall): Likewise.\n\t(ht_purge): New function.\n\t(ht_dump_statistics): Print deletion statistics.\ngcc\n\t* ggc-zone.c (lookup_page_table_if_allocated): New function.\n\t(zone_find_object_offset): Likewise.\n\t(gt_ggc_m_S): Likewise.\n\t(highest_bit): Likewise.\n\t* ggc-page.c (gt_ggc_m_S): New function.\n\t* stringpool.c (string_stack): Remove.\n\t(init_stringpool): Update.\n\t(ggc_alloc_string): Use ggc_alloc.\n\t(maybe_delete_ident): New function.\n\t(ggc_purge_stringpool): Likewise.\n\t(gt_ggc_m_S): Remove.\n\t* ggc-common.c (ggc_protect_identifiers): New global.\n\t(ggc_mark_roots): Call ggc_purge_stringpool.  Use\n\tggc_protect_identifiers.\n\t* ggc.h (ggc_protect_identifiers): Declare.\n\t(gt_ggc_m_S): Update.\n\t(ggc_purge_stringpool): Declare.\n\t* toplev.c (compile_file): Set and reset ggc_protect_identifiers.\n\t* gengtype.c (write_types_process_field) <TYPE_STRING>: Remove\n\tspecial case.\n\t(write_root): Cast gt_ggc_m_S to gt_pointer_walker.\ngcc/cp\n\t* mangle.c (save_partially_mangled_name): Remove.\n\t(restore_partially_mangled_name): Likewise.\n\t(write_encoding): Update.\n\t(write_unqualified_name): Likewise.\n\t(start_mangling): Always use name_obstack.  Remove 'ident_p'\n\targument.\n\t(get_identifier_nocopy): Remove.\n\t(finish_mangling_internal): Rename from finish_mangling.\n\t(finish_mangling): New function.\n\t(finish_mangling_get_identifier): Likewise.\n\t(partially_mangled_name, partially_mangled_name_len): Remove.\n\t(mangle_decl_string): Change return type.  Update.\n\t(mangle_decl, mangle_type_string, mangle_special_for_type,\n\tmangle_ctor_vtbl_for_type, mangle_thunk, mangle_guard_variable,\n\tmangle_ref_init_variable): Update.\n\nFrom-SVN: r135720", "tree": {"sha": "06f6431108f6797065ea5bc80a375513068f17a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06f6431108f6797065ea5bc80a375513068f17a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dae4174e53945378f6878632e75e4c0f7a7679c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dae4174e53945378f6878632e75e4c0f7a7679c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dae4174e53945378f6878632e75e4c0f7a7679c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dae4174e53945378f6878632e75e4c0f7a7679c3/comments", "author": null, "committer": null, "parents": [{"sha": "ccbdd3bc4e25f642b37694b277af2fccf49496c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccbdd3bc4e25f642b37694b277af2fccf49496c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ccbdd3bc4e25f642b37694b277af2fccf49496c6"}], "stats": {"total": 590, "additions": 431, "deletions": 159}, "files": [{"sha": "822d9c1e96ea7c09303a31a2233732a7d2ce05dc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae4174e53945378f6878632e75e4c0f7a7679c3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae4174e53945378f6878632e75e4c0f7a7679c3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dae4174e53945378f6878632e75e4c0f7a7679c3", "patch": "@@ -1,3 +1,27 @@\n+2008-05-21  Tom Tromey  <tromey@redhat.com>\n+\n+\t* ggc-zone.c (lookup_page_table_if_allocated): New function.\n+\t(zone_find_object_offset): Likewise.\n+\t(gt_ggc_m_S): Likewise.\n+\t(highest_bit): Likewise.\n+\t* ggc-page.c (gt_ggc_m_S): New function.\n+\t* stringpool.c (string_stack): Remove.\n+\t(init_stringpool): Update.\n+\t(ggc_alloc_string): Use ggc_alloc.\n+\t(maybe_delete_ident): New function.\n+\t(ggc_purge_stringpool): Likewise.\n+\t(gt_ggc_m_S): Remove.\n+\t* ggc-common.c (ggc_protect_identifiers): New global.\n+\t(ggc_mark_roots): Call ggc_purge_stringpool.  Use\n+\tggc_protect_identifiers.\n+\t* ggc.h (ggc_protect_identifiers): Declare.\n+\t(gt_ggc_m_S): Update.\n+\t(ggc_purge_stringpool): Declare.\n+\t* toplev.c (compile_file): Set and reset ggc_protect_identifiers.\n+\t* gengtype.c (write_types_process_field) <TYPE_STRING>: Remove\n+\tspecial case.\n+\t(write_root): Cast gt_ggc_m_S to gt_pointer_walker.\n+\n 2008-05-21  David S. Miller  <davem@davemloft.net>\n \n \t* config.gcc (sparc-*-linux*): Always include sparc/t-linux in"}, {"sha": "d6787157f0e84b1cdb31ee4f7103b9454a1925aa", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae4174e53945378f6878632e75e4c0f7a7679c3/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae4174e53945378f6878632e75e4c0f7a7679c3/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=dae4174e53945378f6878632e75e4c0f7a7679c3", "patch": "@@ -1,3 +1,21 @@\n+2008-05-21  Tom Tromey  <tromey@redhat.com>\n+\n+\t* mangle.c (save_partially_mangled_name): Remove.\n+\t(restore_partially_mangled_name): Likewise.\n+\t(write_encoding): Update.\n+\t(write_unqualified_name): Likewise.\n+\t(start_mangling): Always use name_obstack.  Remove 'ident_p'\n+\targument.\n+\t(get_identifier_nocopy): Remove.\n+\t(finish_mangling_internal): Rename from finish_mangling.\n+\t(finish_mangling): New function.\n+\t(finish_mangling_get_identifier): Likewise.\n+\t(partially_mangled_name, partially_mangled_name_len): Remove.\n+\t(mangle_decl_string): Change return type.  Update.\n+\t(mangle_decl, mangle_type_string, mangle_special_for_type,\n+\tmangle_ctor_vtbl_for_type, mangle_thunk, mangle_guard_variable,\n+\tmangle_ref_init_variable): Update.\n+\n 2008-05-12  Paolo Carlini  <paolo.carlini@oracle.com>\n \n         PR c++/35331"}, {"sha": "b23e781e99dbafbfecfa281de90a686bc383c8b4", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 60, "deletions": 101, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae4174e53945378f6878632e75e4c0f7a7679c3/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae4174e53945378f6878632e75e4c0f7a7679c3/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=dae4174e53945378f6878632e75e4c0f7a7679c3", "patch": "@@ -1,5 +1,5 @@\n /* Name mangling for the 3.0 C++ ABI.\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2007\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008\n    Free Software Foundation, Inc.\n    Written by Alex Samuel <samuel@codesourcery.com>\n \n@@ -117,13 +117,6 @@ static struct obstack name_obstack;\n    allocated on the name_obstack.  */\n static void *name_base;\n \n-/* An incomplete mangled name.  There will be no NUL terminator.  If\n-   there is no incomplete mangled name, this variable is NULL.  */\n-static char *partially_mangled_name;\n-\n-/* The number of characters in the PARTIALLY_MANGLED_NAME.  */\n-static size_t partially_mangled_name_len;\n-\n /* Indices into subst_identifiers.  These are identifiers used in\n    special substitution rules.  */\n typedef enum\n@@ -217,11 +210,11 @@ static int discriminator_for_string_literal (tree, tree);\n static void write_discriminator (const int);\n static void write_local_name (const tree, const tree, const tree);\n static void dump_substitution_candidates (void);\n-static const char *mangle_decl_string (const tree);\n+static tree mangle_decl_string (const tree);\n \n /* Control functions.  */\n \n-static inline void start_mangling (const tree, bool);\n+static inline void start_mangling (const tree);\n static inline const char *finish_mangling (const bool);\n static tree mangle_special_for_type (const tree, const char *);\n \n@@ -259,42 +252,6 @@ static void write_java_integer_type_codes (const tree);\n #define write_unsigned_number(NUMBER)\t\t\t\t\t\\\n   write_number ((NUMBER), /*unsigned_p=*/1, 10)\n \n-/* Save the current (incomplete) mangled name and release the obstack\n-   storage holding it.  This function should be used during mangling\n-   when making a call that could result in a call to get_identifier,\n-   as such a call will clobber the same obstack being used for\n-   mangling.  This function may not be called twice without an\n-   intervening call to restore_partially_mangled_name.  */\n-\n-static void\n-save_partially_mangled_name (void)\n-{\n-  if (mangle_obstack == &ident_hash->stack)\n-    {\n-      gcc_assert (!partially_mangled_name);\n-      partially_mangled_name_len = obstack_object_size (mangle_obstack);\n-      partially_mangled_name = XNEWVEC (char, partially_mangled_name_len);\n-      memcpy (partially_mangled_name, obstack_base (mangle_obstack),\n-\t      partially_mangled_name_len);\n-      obstack_free (mangle_obstack, obstack_finish (mangle_obstack));\n-    }\n-}\n-\n-/* Restore the incomplete mangled name saved with\n-   save_partially_mangled_name.  */\n-\n-static void\n-restore_partially_mangled_name (void)\n-{\n-  if (partially_mangled_name)\n-    {\n-      obstack_grow (mangle_obstack, partially_mangled_name,\n-\t\t    partially_mangled_name_len);\n-      free (partially_mangled_name);\n-      partially_mangled_name = NULL;\n-    }\n-}\n-\n /* If DECL is a template instance, return nonzero and, if\n    TEMPLATE_INFO is non-NULL, set *TEMPLATE_INFO to its template info.\n    Otherwise return zero.  */\n@@ -743,9 +700,7 @@ write_encoding (const tree decl)\n \n       if (decl_is_template_id (decl, NULL))\n \t{\n-\t  save_partially_mangled_name ();\n \t  fn_type = get_mostly_instantiated_function_type (decl);\n-\t  restore_partially_mangled_name ();\n \t  /* FN_TYPE will not have parameter types for in-charge or\n \t     VTT parameters.  Therefore, we pass NULL_TREE to\n \t     write_bare_function_type -- otherwise, it will get\n@@ -1110,9 +1065,7 @@ write_unqualified_name (const tree decl)\n       if (decl_is_template_id (decl, NULL))\n \t{\n \t  tree fn_type;\n-\t  save_partially_mangled_name ();\n \t  fn_type = get_mostly_instantiated_function_type (decl);\n-\t  restore_partially_mangled_name ();\n \t  type = TREE_TYPE (fn_type);\n \t}\n       else\n@@ -2566,26 +2519,21 @@ write_substitution (const int seq_id)\n /* Start mangling ENTITY.  */\n \n static inline void\n-start_mangling (const tree entity, const bool ident_p)\n+start_mangling (const tree entity)\n {\n   G.entity = entity;\n   G.need_abi_warning = false;\n-  if (!ident_p)\n-    {\n-      obstack_free (&name_obstack, name_base);\n-      mangle_obstack = &name_obstack;\n-      name_base = obstack_alloc (&name_obstack, 0);\n-    }\n-  else\n-    mangle_obstack = &ident_hash->stack;\n+  obstack_free (&name_obstack, name_base);\n+  mangle_obstack = &name_obstack;\n+  name_base = obstack_alloc (&name_obstack, 0);\n }\n \n-/* Done with mangling.  Return the generated mangled name.  If WARN is\n-   true, and the name of G.entity will be mangled differently in a\n-   future version of the ABI, issue a warning.  */\n+/* Done with mangling. If WARN is true, and the name of G.entity will\n+   be mangled differently in a future version of the ABI, issue a\n+   warning.  */\n \n-static inline const char *\n-finish_mangling (const bool warn)\n+static void\n+finish_mangling_internal (const bool warn)\n {\n   if (warn_abi && warn && G.need_abi_warning)\n     warning (OPT_Wabi, \"the mangled name of %qD will change in a future \"\n@@ -2597,10 +2545,29 @@ finish_mangling (const bool warn)\n \n   /* Null-terminate the string.  */\n   write_char ('\\0');\n+}\n+\n \n+/* Like finish_mangling_internal, but return the mangled string.  */\n+\n+static inline const char *\n+finish_mangling (const bool warn)\n+{\n+  finish_mangling_internal (warn);\n   return (const char *) obstack_finish (mangle_obstack);\n }\n \n+/* Like finish_mangling_internal, but return an identifier.  */\n+\n+static tree\n+finish_mangling_get_identifier (const bool warn)\n+{\n+  finish_mangling_internal (warn);\n+  /* Don't obstack_finish here, and the next start_mangling will\n+     remove the identifier.  */\n+  return get_identifier ((const char *) name_base);\n+}\n+\n /* Initialize data structures for mangling.  */\n \n void\n@@ -2622,41 +2589,31 @@ init_mangle (void)\n \n /* Generate the mangled name of DECL.  */\n \n-static const char *\n+static tree\n mangle_decl_string (const tree decl)\n {\n-  const char *result;\n+  tree result;\n \n-  start_mangling (decl, /*ident_p=*/true);\n+  start_mangling (decl);\n \n   if (TREE_CODE (decl) == TYPE_DECL)\n     write_type (TREE_TYPE (decl));\n   else\n     write_mangled_name (decl, true);\n \n-  result = finish_mangling (/*warn=*/true);\n+  result = finish_mangling_get_identifier (/*warn=*/true);\n   if (DEBUG_MANGLE)\n-    fprintf (stderr, \"mangle_decl_string = '%s'\\n\\n\", result);\n+    fprintf (stderr, \"mangle_decl_string = '%s'\\n\\n\",\n+\t     IDENTIFIER_POINTER (result));\n   return result;\n }\n \n-/* Like get_identifier, except that NAME is assumed to have been\n-   allocated on the obstack used by the identifier hash table.  */\n-\n-static inline tree\n-get_identifier_nocopy (const char *name)\n-{\n-  hashnode ht_node = ht_lookup (ident_hash, (const unsigned char *) name,\n-\t\t\t\tstrlen (name), HT_ALLOCED);\n-  return HT_IDENT_TO_GCC_IDENT (ht_node);\n-}\n-\n /* Create an identifier for the external mangled name of DECL.  */\n \n void\n mangle_decl (const tree decl)\n {\n-  tree id = get_identifier_nocopy (mangle_decl_string (decl));\n+  tree id = mangle_decl_string (decl);\n   id = targetm.mangle_decl_assembler_name (decl, id);\n   SET_DECL_ASSEMBLER_NAME (decl, id);\n }\n@@ -2668,7 +2625,7 @@ mangle_type_string (const tree type)\n {\n   const char *result;\n \n-  start_mangling (type, /*ident_p=*/false);\n+  start_mangling (type);\n   write_type (type);\n   result = finish_mangling (/*warn=*/false);\n   if (DEBUG_MANGLE)\n@@ -2683,24 +2640,25 @@ mangle_type_string (const tree type)\n static tree\n mangle_special_for_type (const tree type, const char *code)\n {\n-  const char *result;\n+  tree result;\n \n   /* We don't have an actual decl here for the special component, so\n      we can't just process the <encoded-name>.  Instead, fake it.  */\n-  start_mangling (type, /*ident_p=*/true);\n+  start_mangling (type);\n \n   /* Start the mangling.  */\n   write_string (\"_Z\");\n   write_string (code);\n \n   /* Add the type.  */\n   write_type (type);\n-  result = finish_mangling (/*warn=*/false);\n+  result = finish_mangling_get_identifier (/*warn=*/false);\n \n   if (DEBUG_MANGLE)\n-    fprintf (stderr, \"mangle_special_for_type = %s\\n\\n\", result);\n+    fprintf (stderr, \"mangle_special_for_type = %s\\n\\n\",\n+\t     IDENTIFIER_POINTER (result));\n \n-  return get_identifier_nocopy (result);\n+  return result;\n }\n \n /* Create an identifier for the mangled representation of the typeinfo\n@@ -2754,9 +2712,9 @@ mangle_vtt_for_type (const tree type)\n tree\n mangle_ctor_vtbl_for_type (const tree type, const tree binfo)\n {\n-  const char *result;\n+  tree result;\n \n-  start_mangling (type, /*ident_p=*/true);\n+  start_mangling (type);\n \n   write_string (\"_Z\");\n   write_string (\"TC\");\n@@ -2765,10 +2723,11 @@ mangle_ctor_vtbl_for_type (const tree type, const tree binfo)\n   write_char ('_');\n   write_type (BINFO_TYPE (binfo));\n \n-  result = finish_mangling (/*warn=*/false);\n+  result = finish_mangling_get_identifier (/*warn=*/false);\n   if (DEBUG_MANGLE)\n-    fprintf (stderr, \"mangle_ctor_vtbl_for_type = %s\\n\\n\", result);\n-  return get_identifier_nocopy (result);\n+    fprintf (stderr, \"mangle_ctor_vtbl_for_type = %s\\n\\n\",\n+\t     IDENTIFIER_POINTER (result));\n+  return result;\n }\n \n /* Mangle a this pointer or result pointer adjustment.\n@@ -2810,9 +2769,9 @@ tree\n mangle_thunk (tree fn_decl, const int this_adjusting, tree fixed_offset,\n \t      tree virtual_offset)\n {\n-  const char *result;\n+  tree result;\n \n-  start_mangling (fn_decl, /*ident_p=*/true);\n+  start_mangling (fn_decl);\n \n   write_string (\"_Z\");\n   write_char ('T');\n@@ -2843,10 +2802,10 @@ mangle_thunk (tree fn_decl, const int this_adjusting, tree fixed_offset,\n   /* Scoped name.  */\n   write_encoding (fn_decl);\n \n-  result = finish_mangling (/*warn=*/false);\n+  result = finish_mangling_get_identifier (/*warn=*/false);\n   if (DEBUG_MANGLE)\n-    fprintf (stderr, \"mangle_thunk = %s\\n\\n\", result);\n-  return get_identifier_nocopy (result);\n+    fprintf (stderr, \"mangle_thunk = %s\\n\\n\", IDENTIFIER_POINTER (result));\n+  return result;\n }\n \n /* This hash table maps TYPEs to the IDENTIFIER for a conversion\n@@ -2918,15 +2877,15 @@ mangle_conv_op_name_for_type (const tree type)\n tree\n mangle_guard_variable (const tree variable)\n {\n-  start_mangling (variable, /*ident_p=*/true);\n+  start_mangling (variable);\n   write_string (\"_ZGV\");\n   if (strncmp (IDENTIFIER_POINTER (DECL_NAME (variable)), \"_ZGR\", 4) == 0)\n     /* The name of a guard variable for a reference temporary should refer\n        to the reference, not the temporary.  */\n     write_string (IDENTIFIER_POINTER (DECL_NAME (variable)) + 4);\n   else\n     write_name (variable, /*ignore_local_scope=*/0);\n-  return get_identifier_nocopy (finish_mangling (/*warn=*/false));\n+  return finish_mangling_get_identifier (/*warn=*/false);\n }\n \n /* Return an identifier for the name of a temporary variable used to\n@@ -2936,10 +2895,10 @@ mangle_guard_variable (const tree variable)\n tree\n mangle_ref_init_variable (const tree variable)\n {\n-  start_mangling (variable, /*ident_p=*/true);\n+  start_mangling (variable);\n   write_string (\"_ZGR\");\n   write_name (variable, /*ignore_local_scope=*/0);\n-  return get_identifier_nocopy (finish_mangling (/*warn=*/false));\n+  return finish_mangling_get_identifier (/*warn=*/false);\n }\n \f\n "}, {"sha": "62cac24001154b8d3a8262ce8a6d2bded292e567", "filename": "gcc/gengtype.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae4174e53945378f6878632e75e4c0f7a7679c3/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae4174e53945378f6878632e75e4c0f7a7679c3/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=dae4174e53945378f6878632e75e4c0f7a7679c3", "patch": "@@ -2357,9 +2357,6 @@ write_types_process_field (type_p f, const struct walk_type_data *d)\n       break;\n \n     case TYPE_STRING:\n-      if (wtd->param_prefix == NULL)\n-\tbreak;\n-\n     case TYPE_STRUCT:\n     case TYPE_UNION:\n     case TYPE_LANG_STRUCT:\n@@ -3134,7 +3131,7 @@ write_root (outf_p f, pair_p v, type_p type, const char *name, int has_length,\n \toprintf (f, \"    &%s,\\n\", name);\n \toprintf (f, \"    1, \\n\");\n \toprintf (f, \"    sizeof (%s),\\n\", v->name);\n-\toprintf (f, \"    &gt_ggc_m_S,\\n\");\n+\toprintf (f, \"    (gt_pointer_walker) &gt_ggc_m_S,\\n\");\n \toprintf (f, \"    (gt_pointer_walker) &gt_pch_n_S\\n\");\n \toprintf (f, \"  },\\n\");\n       }"}, {"sha": "17c1f50b608fc82d81f3a9e0eb028da3283b1a61", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae4174e53945378f6878632e75e4c0f7a7679c3/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae4174e53945378f6878632e75e4c0f7a7679c3/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=dae4174e53945378f6878632e75e4c0f7a7679c3", "patch": "@@ -1,5 +1,5 @@\n /* Simple garbage collection for the GNU compiler.\n-   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n+   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -50,6 +50,9 @@ along with GCC; see the file COPYING3.  If not see\n /* When set, ggc_collect will do collection.  */\n bool ggc_force_collect;\n \n+/* When true, protect the contents of the identifier hash table.  */\n+bool ggc_protect_identifiers = true;\n+\n /* Statistics about the allocation.  */\n static ggc_statistics *ggc_stats;\n \n@@ -103,7 +106,8 @@ ggc_mark_roots (void)\n       for (i = 0; i < rti->nelt; i++)\n \t(*rti->cb)(*(void **)((char *)rti->base + rti->stride * i));\n \n-  ggc_mark_stringpool ();\n+  if (ggc_protect_identifiers)\n+    ggc_mark_stringpool ();\n \n   /* Now scan all hash tables that have objects which are to be deleted if\n      they are not already marked.  */\n@@ -115,6 +119,9 @@ ggc_mark_roots (void)\n \t  htab_traverse_noresize (*cti->base, ggc_htab_delete, (void *) cti);\n \t  ggc_set_mark ((*cti->base)->entries);\n \t}\n+\n+  if (! ggc_protect_identifiers)\n+    ggc_purge_stringpool ();\n }\n \n /* Allocate a block of memory, then clear it.  */"}, {"sha": "f22ddf6e826e8275d55d5cca9b04788c28efedce", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 52, "deletions": 1, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae4174e53945378f6878632e75e4c0f7a7679c3/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae4174e53945378f6878632e75e4c0f7a7679c3/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=dae4174e53945378f6878632e75e4c0f7a7679c3", "patch": "@@ -1,5 +1,5 @@\n /* \"Bag-of-pages\" garbage collector for the GNU compiler.\n-   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007\n+   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -1256,6 +1256,57 @@ ggc_alloc_stat (size_t size MEM_STAT_DECL)\n   return result;\n }\n \n+/* Mark function for strings.  */\n+\n+void\n+gt_ggc_m_S (const void *p)\n+{\n+  page_entry *entry;\n+  unsigned bit, word;\n+  unsigned long mask;\n+  unsigned long offset;\n+\n+  if (!p || !ggc_allocated_p (p))\n+    return;\n+\n+  /* Look up the page on which the object is alloced.  .  */\n+  entry = lookup_page_table_entry (p);\n+  gcc_assert (entry);\n+\n+  /* Calculate the index of the object on the page; this is its bit\n+     position in the in_use_p bitmap.  Note that because a char* might\n+     point to the middle of an object, we need special code here to\n+     make sure P points to the start of an object.  */\n+  offset = ((const char *) p - entry->page) % object_size_table[entry->order];\n+  if (offset)\n+    {\n+      /* Here we've seen a char* which does not point to the beginning\n+\t of an allocated object.  We assume it points to the middle of\n+\t a STRING_CST.  */\n+      gcc_assert (offset == offsetof (struct tree_string, str));\n+      p = ((const char *) p) - offset;\n+      gt_ggc_mx_lang_tree_node ((void *) p);\n+      return;\n+    }\n+\n+  bit = OFFSET_TO_BIT (((const char *) p) - entry->page, entry->order);\n+  word = bit / HOST_BITS_PER_LONG;\n+  mask = (unsigned long) 1 << (bit % HOST_BITS_PER_LONG);\n+\n+  /* If the bit was previously set, skip it.  */\n+  if (entry->in_use_p[word] & mask)\n+    return;\n+\n+  /* Otherwise set it, and decrement the free object count.  */\n+  entry->in_use_p[word] |= mask;\n+  entry->num_free_objects -= 1;\n+\n+  if (GGC_DEBUG_LEVEL >= 4)\n+    fprintf (G.debug_file, \"Marking %p\\n\", p);\n+\n+  return;\n+}\n+\n /* If P is not marked, marks it and return false.  Otherwise return true.\n    P must have been allocated by the GC allocator; it mustn't point to\n    static objects, stack variables, or memory allocated with malloc.  */"}, {"sha": "af211ad90dc5f3e65e5891a309bbab3e2e83400f", "filename": "gcc/ggc-zone.c", "status": "modified", "additions": 150, "deletions": 1, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae4174e53945378f6878632e75e4c0f7a7679c3/gcc%2Fggc-zone.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae4174e53945378f6878632e75e4c0f7a7679c3/gcc%2Fggc-zone.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-zone.c?ref=dae4174e53945378f6878632e75e4c0f7a7679c3", "patch": "@@ -1,5 +1,5 @@\n /* \"Bag-of-pages\" zone garbage collector for the GNU compiler.\n-   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007\n+   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008\n    Free Software Foundation, Inc.\n \n    Contributed by Richard Henderson (rth@redhat.com) and Daniel Berlin\n@@ -506,6 +506,47 @@ lookup_page_table_entry (const void *p)\n   return base[L1][L2];\n }\n \n+/* Traverse the page table and find the entry for a page.\n+   Return NULL if the object wasn't allocated via the GC.  */\n+\n+static inline page_entry *\n+lookup_page_table_if_allocated (const void *p)\n+{\n+  page_entry ***base;\n+  size_t L1, L2;\n+\n+#if HOST_BITS_PER_PTR <= 32\n+  base = &G.lookup[0];\n+#else\n+  page_table table = G.lookup;\n+  size_t high_bits = (size_t) p & ~ (size_t) 0xffffffff;\n+  while (1)\n+    {\n+      if (table == NULL)\n+\treturn NULL;\n+      if (table->high_bits == high_bits)\n+\tbreak;\n+      table = table->next;\n+    }\n+  base = &table->table[0];\n+#endif\n+\n+  /* Extract the level 1 and 2 indices.  */\n+  L1 = LOOKUP_L1 (p);\n+  if (! base[L1])\n+    return NULL;\n+\n+  L2 = LOOKUP_L2 (p);\n+  if (L2 >= PAGE_L2_SIZE)\n+    return NULL;\n+  /* We might have a page entry which does not correspond exactly to a\n+     system page.  */\n+  if (base[L1][L2] && (char *) p < base[L1][L2]->page)\n+    return NULL;\n+\n+  return base[L1][L2];\n+}\n+\n /* Set the page table entry for the page that starts at P.  If ENTRY\n    is NULL, clear the entry.  */\n \n@@ -680,6 +721,55 @@ zone_find_object_size (struct small_page_entry *page,\n \t\t\t     max_size);\n }\n \n+/* highest_bit assumes that alloc_type is 32 bits.  */\n+extern char check_alloc_type_size[(sizeof (alloc_type) == 4) ? 1 : -1];\n+\n+/* Find the highest set bit in VALUE.  Returns the bit number of that\n+   bit, using the same values as ffs.  */\n+static inline alloc_type\n+highest_bit (alloc_type value)\n+{\n+  /* This also assumes that alloc_type is unsigned.  */\n+  value |= value >> 1;\n+  value |= value >> 2;\n+  value |= value >> 4;\n+  value |= value >> 8;\n+  value |= value >> 16;\n+  value = value ^ (value >> 1);\n+  return alloc_ffs (value);\n+}\n+\n+/* Find the offset from the start of an object to P, which may point\n+   into the interior of the object.  */\n+\n+static unsigned long\n+zone_find_object_offset (alloc_type *alloc_bits, size_t start_word,\n+\t\t\t size_t start_bit)\n+{\n+  unsigned int offset_in_bits;\n+  alloc_type alloc_word = alloc_bits[start_word];\n+\n+  /* Mask off any bits after the initial bit, but make sure to include\n+     the initial bit in the result.  Note that START_BIT is\n+     0-based.  */\n+  if (start_bit < 8 * sizeof (alloc_type) - 1)\n+    alloc_word &= (1 << (start_bit + 1)) - 1;\n+  offset_in_bits = start_bit;\n+\n+  /* Search for the start of the object.  */\n+  while (alloc_word == 0 && start_word > 0)\n+    {\n+      alloc_word = alloc_bits[--start_word];\n+      offset_in_bits += 8 * sizeof (alloc_type);\n+    }\n+  /* We must always find a set bit.  */\n+  gcc_assert (alloc_word != 0);\n+  /* Note that the result of highest_bit is 1-based.  */\n+  offset_in_bits -= highest_bit (alloc_word) - 1;\n+\n+  return BYTES_PER_ALLOC_BIT * offset_in_bits;\n+}\n+\n /* Allocate the mark bits for every zone, and set the pointers on each\n    page.  */\n static void\n@@ -1353,6 +1443,65 @@ ggc_free (void *p)\n     }\n }\n \n+/* Mark function for strings.  */\n+\n+void\n+gt_ggc_m_S (const void *p)\n+{\n+  page_entry *entry;\n+  unsigned long offset;\n+\n+  if (!p)\n+    return;\n+\n+  /* Look up the page on which the object is alloced.  .  */\n+  entry = lookup_page_table_if_allocated (p);\n+  if (! entry)\n+    return;\n+\n+  if (entry->pch_p)\n+    {\n+      size_t alloc_word, alloc_bit, t;\n+      t = ((const char *) p - pch_zone.page) / BYTES_PER_ALLOC_BIT;\n+      alloc_word = t / (8 * sizeof (alloc_type));\n+      alloc_bit = t % (8 * sizeof (alloc_type));\n+      offset = zone_find_object_offset (pch_zone.alloc_bits, alloc_word,\n+\t\t\t\t\talloc_bit);\n+    }\n+  else if (entry->large_p)\n+    {\n+      struct large_page_entry *le = (struct large_page_entry *) entry;\n+      offset = ((const char *) p) - entry->page;\n+      gcc_assert (offset < le->bytes);\n+    }\n+  else\n+    {\n+      struct small_page_entry *se = (struct small_page_entry *) entry;\n+      unsigned int start_word = zone_get_object_alloc_word (p);\n+      unsigned int start_bit = zone_get_object_alloc_bit (p);\n+      offset = zone_find_object_offset (se->alloc_bits, start_word, start_bit);\n+\n+      /* On some platforms a char* will not necessarily line up on an\n+\t allocation boundary, so we have to update the offset to\n+\t account for the leftover bytes.  */\n+      offset += (size_t) p % BYTES_PER_ALLOC_BIT;\n+    }\n+\n+  if (offset)\n+    {\n+      /* Here we've seen a char* which does not point to the beginning\n+\t of an allocated object.  We assume it points to the middle of\n+\t a STRING_CST.  */\n+      gcc_assert (offset == offsetof (struct tree_string, str));\n+      p = ((const char *) p) - offset;\n+      gt_ggc_mx_lang_tree_node ((void *) p);\n+      return;\n+    }\n+\n+  /* Inefficient, but also unlikely to matter.  */\n+  ggc_set_mark (p);\n+}\n+\n /* If P is not marked, mark it and return false.  Otherwise return true.\n    P must have been allocated by the GC allocator; it mustn't point to\n    static objects, stack variables, or memory allocated with malloc.  */"}, {"sha": "03f534faaa53973aca1ba55c7c2918ea26877292", "filename": "gcc/ggc.h", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae4174e53945378f6878632e75e4c0f7a7679c3/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae4174e53945378f6878632e75e4c0f7a7679c3/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=dae4174e53945378f6878632e75e4c0f7a7679c3", "patch": "@@ -1,5 +1,5 @@\n /* Garbage collection for the GNU compiler.\n-   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -120,6 +120,9 @@ extern int ggc_marked_p\t(const void *);\n /* Mark the entries in the string pool.  */\n extern void ggc_mark_stringpool\t(void);\n \n+/* Purge the entries in the string pool.  */\n+extern void ggc_purge_stringpool (void);\n+\n /* Call ggc_set_mark on all the roots.  */\n \n extern void ggc_mark_roots (void);\n@@ -134,7 +137,7 @@ extern void gt_pch_restore_stringpool (void);\n \n extern void gt_pch_p_S (void *, void *, gt_pointer_operator, void *);\n extern void gt_pch_n_S (const void *);\n-extern void gt_ggc_m_S (void *);\n+extern void gt_ggc_m_S (const void *);\n \n /* Initialize the string pool.  */\n extern void init_stringpool (void);\n@@ -200,6 +203,12 @@ extern void ggc_pch_read (FILE *, void *);\n /* When set, ggc_collect will do collection.  */\n extern bool ggc_force_collect;\n \n+/* When true, identifier nodes are considered as GC roots.  When\n+   false, identifier nodes are treated like any other GC-allocated\n+   object, and the identifier hash table is treated as a weak\n+   hash.  */\n+extern bool ggc_protect_identifiers;\n+\n /* The internal primitive.  */\n extern void *ggc_alloc_stat (size_t MEM_STAT_DECL);\n #define ggc_alloc(s) ggc_alloc_stat (s MEM_STAT_INFO)"}, {"sha": "cc2dd35368db81cba8b9e68d434bdeb0a8405b84", "filename": "gcc/stringpool.c", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae4174e53945378f6878632e75e4c0f7a7679c3/gcc%2Fstringpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae4174e53945378f6878632e75e4c0f7a7679c3/gcc%2Fstringpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstringpool.c?ref=dae4174e53945378f6878632e75e4c0f7a7679c3", "patch": "@@ -1,5 +1,5 @@\n /* String pool for GCC.\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2007\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -47,7 +47,6 @@ const char digit_vector[] = {\n };\n \n struct ht *ident_hash;\n-static struct obstack string_stack;\n \n static hashnode alloc_node (hash_table *);\n static int mark_ident (struct cpp_reader *, hashnode, const void *);\n@@ -66,7 +65,6 @@ init_stringpool (void)\n   ident_hash = ht_create (14);\n   ident_hash->alloc_node = alloc_node;\n   ident_hash->alloc_subobject = stringpool_ggc_alloc;\n-  gcc_obstack_init (&string_stack);\n }\n \n /* Allocate a hash node.  */\n@@ -85,6 +83,8 @@ alloc_node (hash_table *table ATTRIBUTE_UNUSED)\n const char *\n ggc_alloc_string (const char *contents, int length)\n {\n+  char *result;\n+\n   if (length == -1)\n     length = strlen (contents);\n \n@@ -93,8 +93,9 @@ ggc_alloc_string (const char *contents, int length)\n   if (length == 1 && ISDIGIT (contents[0]))\n     return digit_string (contents[0] - '0');\n \n-  obstack_grow0 (&string_stack, contents, length);\n-  return XOBFINISH (&string_stack, const char *);\n+  result = ggc_alloc (length + 1);\n+  memcpy (result, contents, length + 1);\n+  return (const char *) result;\n }\n \n /* Return an IDENTIFIER_NODE whose name is TEXT (a null-terminated string).\n@@ -163,23 +164,32 @@ mark_ident (struct cpp_reader *pfile ATTRIBUTE_UNUSED, hashnode h,\n   return 1;\n }\n \n+/* Return true if an identifier should be removed from the table.  */\n+\n+static int\n+maybe_delete_ident (struct cpp_reader *pfile ATTRIBUTE_UNUSED, hashnode h,\n+\t\t    const void *v ATTRIBUTE_UNUSED)\n+{\n+  return !ggc_marked_p (HT_IDENT_TO_GCC_IDENT (h));\n+}\n+\n /* Mark the trees hanging off the identifier node for GGC.  These are\n-   handled specially (not using gengtype) because of the special\n-   treatment for strings.  */\n+   handled specially (not using gengtype) because identifiers are only\n+   roots during one part of compilation.  */\n \n void\n ggc_mark_stringpool (void)\n {\n   ht_forall (ident_hash, mark_ident, NULL);\n }\n \n-/* Strings are _not_ GCed, but this routine exists so that a separate\n-   roots table isn't needed for the few global variables that refer\n-   to strings.  */\n+/* Purge the identifier hash of identifiers which are no longer\n+   referenced.  */\n \n void\n-gt_ggc_m_S (void *x ATTRIBUTE_UNUSED)\n+ggc_purge_stringpool (void)\n {\n+  ht_purge (ident_hash, maybe_delete_ident, NULL);\n }\n \n /* Pointer-walking routine for strings (not very interesting, since"}, {"sha": "a35c105160eb2497fa6ec1ecbf7c123bd6768787", "filename": "gcc/toplev.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae4174e53945378f6878632e75e4c0f7a7679c3/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae4174e53945378f6878632e75e4c0f7a7679c3/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=dae4174e53945378f6878632e75e4c0f7a7679c3", "patch": "@@ -951,6 +951,8 @@ compile_file (void)\n {\n   /* Initialize yet another pass.  */\n \n+  ggc_protect_identifiers = true;\n+\n   init_cgraph ();\n   init_final (main_input_filename);\n   coverage_init (aux_base_name);\n@@ -969,6 +971,8 @@ compile_file (void)\n   if (flag_syntax_only)\n     return;\n \n+  ggc_protect_identifiers = false;\n+\n   lang_hooks.decls.final_write_globals ();\n \n   if (errorcount || sorrycount)"}, {"sha": "58632e3f54820bc450f89418fd2c393a9989f99d", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae4174e53945378f6878632e75e4c0f7a7679c3/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae4174e53945378f6878632e75e4c0f7a7679c3/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=dae4174e53945378f6878632e75e4c0f7a7679c3", "patch": "@@ -1,3 +1,16 @@\n+2008-05-21  Tom Tromey  <tromey@redhat.com>\n+\n+\t* include/symtab.h (HT_ALLOCED): Remove.\n+\t(ht_purge): Declare.\n+\t* symtab.c (DELETED): New define.\n+\t(ht_lookup): Update comment.\n+\t(ht_lookup_with_hash): Handle deleted entries.  Remove HT_ALLOCED\n+\tcode.  Use subobject allocator for strings, if it exists.\n+\t(ht_expand): Handle deleted entries.\n+\t(ht_forall): Likewise.\n+\t(ht_purge): New function.\n+\t(ht_dump_statistics): Print deletion statistics.\n+\n 2008-05-13  Tom Tromey  <tromey@redhat.com>\n \n \tPR preprocessor/22168:"}, {"sha": "c016be3755b9b9ebfdf7e37f1763a08caa412e67", "filename": "libcpp/include/symtab.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae4174e53945378f6878632e75e4c0f7a7679c3/libcpp%2Finclude%2Fsymtab.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae4174e53945378f6878632e75e4c0f7a7679c3/libcpp%2Finclude%2Fsymtab.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fsymtab.h?ref=dae4174e53945378f6878632e75e4c0f7a7679c3", "patch": "@@ -1,5 +1,5 @@\n /* Hash tables.\n-   Copyright (C) 2000, 2001, 2003, 2004, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2003, 2004, 2007, 2008 Free Software Foundation, Inc.\n \n This program is free software; you can redistribute it and/or modify it\n under the terms of the GNU General Public License as published by the\n@@ -39,7 +39,7 @@ struct ht_identifier GTY(())\n typedef struct ht hash_table;\n typedef struct ht_identifier *hashnode;\n \n-enum ht_lookup_option {HT_NO_INSERT = 0, HT_ALLOC, HT_ALLOCED};\n+enum ht_lookup_option {HT_NO_INSERT = 0, HT_ALLOC};\n \n /* An identifier hash table for cpplib and the front ends.  */\n struct ht\n@@ -88,6 +88,10 @@ extern hashnode ht_lookup_with_hash (hash_table *, const unsigned char *,\n typedef int (*ht_cb) (struct cpp_reader *, hashnode, const void *);\n extern void ht_forall (hash_table *, ht_cb, const void *);\n \n+/* For all nodes in TABLE, call the callback.  If the callback returns\n+   a nonzero value, the node is removed from the table.  */\n+extern void ht_purge (hash_table *, ht_cb, const void *);\n+\n /* Restore the hash table.  */\n extern void ht_load (hash_table *ht, hashnode *entries,\n \t\t     unsigned int nslots, unsigned int nelements, bool own);"}, {"sha": "5414ff05fc9dc3a5143b2818830a57b6565b6981", "filename": "libcpp/symtab.c", "status": "modified", "additions": 62, "deletions": 35, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae4174e53945378f6878632e75e4c0f7a7679c3/libcpp%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae4174e53945378f6878632e75e4c0f7a7679c3/libcpp%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fsymtab.c?ref=dae4174e53945378f6878632e75e4c0f7a7679c3", "patch": "@@ -1,5 +1,5 @@\n /* Hash tables.\n-   Copyright (C) 2000, 2001, 2003, 2004 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2003, 2004, 2008 Free Software Foundation, Inc.\n \n This program is free software; you can redistribute it and/or modify it\n under the terms of the GNU General Public License as published by the\n@@ -27,13 +27,15 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n    hash tables (see libiberty/hashtab.c).  The abstraction penalty was\n    too high to continue using the generic form.  This code knows\n    intrinsically how to calculate a hash value, and how to compare an\n-   existing entry with a potential new one.  Also, the ability to\n-   delete members from the table has been removed.  */\n+   existing entry with a potential new one.  */\n \n static unsigned int calc_hash (const unsigned char *, size_t);\n static void ht_expand (hash_table *);\n static double approx_sqrt (double);\n \n+/* A deleted entry.  */\n+#define DELETED ((hashnode) -1)\n+\n /* Calculate the hash of the string STR of length LEN.  */\n \n static unsigned int\n@@ -83,13 +85,10 @@ ht_destroy (hash_table *table)\n }\n \n /* Returns the hash entry for the a STR of length LEN.  If that string\n-   already exists in the table, returns the existing entry, and, if\n-   INSERT is CPP_ALLOCED, frees the last obstack object.  If the\n+   already exists in the table, returns the existing entry.  If the\n    identifier hasn't been seen before, and INSERT is CPP_NO_INSERT,\n    returns NULL.  Otherwise insert and returns a new entry.  A new\n-   string is alloced if INSERT is CPP_ALLOC, otherwise INSERT is\n-   CPP_ALLOCED and the item is assumed to be at the top of the\n-   obstack.  */\n+   string is allocated.  */\n hashnode\n ht_lookup (hash_table *table, const unsigned char *str, size_t len,\n \t   enum ht_lookup_option insert)\n@@ -105,6 +104,7 @@ ht_lookup_with_hash (hash_table *table, const unsigned char *str,\n {\n   unsigned int hash2;\n   unsigned int index;\n+  unsigned int deleted_index = table->nslots;\n   size_t sizemask;\n   hashnode node;\n \n@@ -113,19 +113,15 @@ ht_lookup_with_hash (hash_table *table, const unsigned char *str,\n   table->searches++;\n \n   node = table->entries[index];\n- \n+\n   if (node != NULL)\n     {\n-      if (node->hash_value == hash\n-\t  && HT_LEN (node) == (unsigned int) len\n-\t  && !memcmp (HT_STR (node), str, len))\n-\t{\n-\t  if (insert == HT_ALLOCED)\n-\t    /* The string we search for was placed at the end of the\n-\t       obstack.  Release it.  */\n-\t    obstack_free (&table->stack, (void *) str);\n-\t  return node;\n-\t}\n+      if (node == DELETED)\n+\tdeleted_index = index;\n+      else if (node->hash_value == hash\n+\t       && HT_LEN (node) == (unsigned int) len\n+\t       && !memcmp (HT_STR (node), str, len))\n+\treturn node;\n \n       /* hash2 must be odd, so we're guaranteed to visit every possible\n \t location in the table during rehashing.  */\n@@ -139,32 +135,41 @@ ht_lookup_with_hash (hash_table *table, const unsigned char *str,\n \t  if (node == NULL)\n \t    break;\n \n-\t  if (node->hash_value == hash\n-\t      && HT_LEN (node) == (unsigned int) len\n-\t      && !memcmp (HT_STR (node), str, len))\n+\t  if (node == DELETED)\n \t    {\n-\t      if (insert == HT_ALLOCED)\n-\t      /* The string we search for was placed at the end of the\n-\t\t obstack.  Release it.  */\n-\t\tobstack_free (&table->stack, (void *) str);\n-\t      return node;\n+\t      if (deleted_index != table->nslots)\n+\t\tdeleted_index = index;\n \t    }\n+\t  else if (node->hash_value == hash\n+\t\t   && HT_LEN (node) == (unsigned int) len\n+\t\t   && !memcmp (HT_STR (node), str, len))\n+\t    return node;\n \t}\n     }\n \n   if (insert == HT_NO_INSERT)\n     return NULL;\n \n+  /* We prefer to overwrite the first deleted slot we saw.  */\n+  if (deleted_index != table->nslots)\n+    index = deleted_index;\n+\n   node = (*table->alloc_node) (table);\n   table->entries[index] = node;\n \n   HT_LEN (node) = (unsigned int) len;\n   node->hash_value = hash;\n-  if (insert == HT_ALLOC)\n-    HT_STR (node) = (const unsigned char *) obstack_copy0 (&table->stack,\n-                                                           str, len);\n+\n+  if (table->alloc_subobject)\n+    {\n+      char *chars = table->alloc_subobject (len + 1);\n+      memcpy (chars, str, len);\n+      chars[len] = '\\0';\n+      HT_STR (node) = (const unsigned char *) chars;\n+    }\n   else\n-    HT_STR (node) = str;\n+    HT_STR (node) = (const unsigned char *) obstack_copy0 (&table->stack,\n+\t\t\t\t\t\t\t   str, len);\n \n   if (++table->nelements * 4 >= table->nslots * 3)\n     /* Must expand the string table.  */\n@@ -188,7 +193,7 @@ ht_expand (hash_table *table)\n   p = table->entries;\n   limit = p + table->nslots;\n   do\n-    if (*p)\n+    if (*p && *p != DELETED)\n       {\n \tunsigned int index, hash, hash2;\n \n@@ -225,14 +230,32 @@ ht_forall (hash_table *table, ht_cb cb, const void *v)\n   p = table->entries;\n   limit = p + table->nslots;\n   do\n-    if (*p)\n+    if (*p && *p != DELETED)\n       {\n \tif ((*cb) (table->pfile, *p, v) == 0)\n \t  break;\n       }\n   while (++p < limit);\n }\n \n+/* Like ht_forall, but a nonzero return from the callback means that\n+   the entry should be removed from the table.  */\n+void\n+ht_purge (hash_table *table, ht_cb cb, const void *v)\n+{\n+  hashnode *p, *limit;\n+\n+  p = table->entries;\n+  limit = p + table->nslots;\n+  do\n+    if (*p && *p != DELETED)\n+      {\n+\tif ((*cb) (table->pfile, *p, v))\n+\t  *p = DELETED;\n+      }\n+  while (++p < limit);\n+}\n+\n /* Restore the hash table.  */\n void\n ht_load (hash_table *ht, hashnode *entries,\n@@ -253,7 +276,7 @@ void\n ht_dump_statistics (hash_table *table)\n {\n   size_t nelts, nids, overhead, headers;\n-  size_t total_bytes, longest;\n+  size_t total_bytes, longest, deleted = 0;\n   double sum_of_squares, exp_len, exp_len2, exp2_len;\n   hashnode *p, *limit;\n \n@@ -268,7 +291,9 @@ ht_dump_statistics (hash_table *table)\n   p = table->entries;\n   limit = p + table->nslots;\n   do\n-    if (*p)\n+    if (*p == DELETED)\n+      ++deleted;\n+    else if (*p)\n       {\n \tsize_t n = HT_LEN (*p);\n \n@@ -290,6 +315,8 @@ ht_dump_statistics (hash_table *table)\n \t   (unsigned long) nids, nids * 100.0 / nelts);\n   fprintf (stderr, \"slots\\t\\t%lu\\n\",\n \t   (unsigned long) table->nslots);\n+  fprintf (stderr, \"deleted\\t\\t%lu\\n\",\n+\t   (unsigned long) deleted);\n   fprintf (stderr, \"bytes\\t\\t%lu%c (%lu%c overhead)\\n\",\n \t   SCALE (total_bytes), LABEL (total_bytes),\n \t   SCALE (overhead), LABEL (overhead));"}]}