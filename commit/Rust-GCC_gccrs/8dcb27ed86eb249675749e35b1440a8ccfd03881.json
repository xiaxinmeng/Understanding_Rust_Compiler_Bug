{"sha": "8dcb27ed86eb249675749e35b1440a8ccfd03881", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGRjYjI3ZWQ4NmViMjQ5Njc1NzQ5ZTM1YjE0NDBhOGNjZmQwMzg4MQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2002-06-15T16:55:24Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2002-06-15T16:55:24Z"}, "message": "fold-const.c (comparison_to_compcode): New function to convert an comparison TREE CODE into a bit-based representation.\n\n\n\t* fold-const.c (comparison_to_compcode): New function to convert\n\tan comparison TREE CODE into a bit-based representation.\n\t(compcode_to_comparison): New function to convert from this bit\n\tbased representation back to a comparison TREE CODE.\n\t(fold_truthop): Simplify (x<y) && (x==y) and related composite\n\tcomparisons.\n\n\t* gcc.c-tortuture/execute/compare-1.c: New test case.\n\t* gcc.c-tortuture/execute/compare-2.c: New test case.\n\t* gcc.c-tortuture/execute/compare-3.c: New test case.\n\nFrom-SVN: r54647", "tree": {"sha": "c9fc91c5bbced804e712ce47aaa7397c5a3ed98d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c9fc91c5bbced804e712ce47aaa7397c5a3ed98d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8dcb27ed86eb249675749e35b1440a8ccfd03881", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dcb27ed86eb249675749e35b1440a8ccfd03881", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8dcb27ed86eb249675749e35b1440a8ccfd03881", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dcb27ed86eb249675749e35b1440a8ccfd03881/comments", "author": null, "committer": null, "parents": [{"sha": "f7d3c5f00586f93c1a5a46ebbffa14dce150aae7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7d3c5f00586f93c1a5a46ebbffa14dce150aae7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7d3c5f00586f93c1a5a46ebbffa14dce150aae7"}], "stats": {"total": 355, "additions": 355, "deletions": 0}, "files": [{"sha": "b190a54807eb4adffa544c24e5d66f134ddc6116", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dcb27ed86eb249675749e35b1440a8ccfd03881/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dcb27ed86eb249675749e35b1440a8ccfd03881/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8dcb27ed86eb249675749e35b1440a8ccfd03881", "patch": "@@ -1,3 +1,12 @@\n+2002-06-15  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* fold-const.c (comparison_to_compcode): New function to convert\n+\tan comparison TREE CODE into a bit-based representation.\n+\t(compcode_to_comparison): New function to convert from this bit\n+\tbased representation back to a comparison TREE CODE.\n+\t(fold_truthop): Simplify (x<y) && (x==y) and related composite\n+\tcomparisons.\n+\n 2002-06-15  Aldy Hernandez  <aldyh@redhat.com>\n \n         * tm.texi (MEMBER_TYPE_FORCES_BLK): Document MODE argument."}, {"sha": "f9f3a64943363adb4121d8672a0f20fb2ce53745", "filename": "gcc/fold-const.c", "status": "modified", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dcb27ed86eb249675749e35b1440a8ccfd03881/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dcb27ed86eb249675749e35b1440a8ccfd03881/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=8dcb27ed86eb249675749e35b1440a8ccfd03881", "patch": "@@ -72,6 +72,8 @@ static int size_htab_eq\t\tPARAMS ((const void *, const void *));\n static tree fold_convert\tPARAMS ((tree, tree));\n static enum tree_code invert_tree_comparison PARAMS ((enum tree_code));\n static enum tree_code swap_tree_comparison PARAMS ((enum tree_code));\n+static int comparison_to_compcode PARAMS ((enum tree_code));\n+static enum tree_code compcode_to_comparison PARAMS ((int));\n static int truth_value_p\tPARAMS ((enum tree_code));\n static int operand_equal_for_comparison_p PARAMS ((tree, tree, tree));\n static int twoval_comparison_p\tPARAMS ((tree, tree *, tree *, int *));\n@@ -115,6 +117,18 @@ static bool fold_real_zero_addition_p\tPARAMS ((tree, tree, int));\n #define CHARMASK 0x7f\n #endif\n \n+/* The following constants represent a bit based encoding of GCC's\n+   comparison operators.  This encoding simplifies transformations\n+   on relational comparison operators, such as AND and OR.  */\n+#define COMPCODE_FALSE   0\n+#define COMPCODE_LT      1\n+#define COMPCODE_EQ      2\n+#define COMPCODE_LE      3\n+#define COMPCODE_GT      4\n+#define COMPCODE_NE      5\n+#define COMPCODE_GE      6\n+#define COMPCODE_TRUE    7\n+\n /* We know that A1 + B1 = SUM1, using 2's complement arithmetic and ignoring\n    overflow.  Suppose A, B and SUM have the same respective signs as A1, B1,\n    and SUM1.  Then this yields nonzero if overflow occurred during the\n@@ -1709,6 +1723,61 @@ swap_tree_comparison (code)\n     }\n }\n \n+\n+/* Convert a comparison tree code from an enum tree_code representation\n+   into a compcode bit-based encoding.  This function is the inverse of\n+   compcode_to_comparison.  */\n+\n+static int\n+comparison_to_compcode (code)\n+     enum tree_code code;\n+{\n+  switch (code)\n+    {\n+    case LT_EXPR:\n+      return COMPCODE_LT;\n+    case EQ_EXPR:\n+      return COMPCODE_EQ;\n+    case LE_EXPR:\n+      return COMPCODE_LE;\n+    case GT_EXPR:\n+      return COMPCODE_GT;\n+    case NE_EXPR:\n+      return COMPCODE_NE;\n+    case GE_EXPR:\n+      return COMPCODE_GE;\n+    default:\n+      abort ();\n+    }\n+}\n+\n+/* Convert a compcode bit-based encoding of a comparison operator back\n+   to GCC's enum tree_code representation.  This function is the\n+   inverse of comparison_to_compcode.  */\n+\n+static enum tree_code\n+compcode_to_comparison (code)\n+     int code;\n+{\n+  switch (code)\n+    {\n+    case COMPCODE_LT:\n+      return LT_EXPR;\n+    case COMPCODE_EQ:\n+      return EQ_EXPR;\n+    case COMPCODE_LE:\n+      return LE_EXPR;\n+    case COMPCODE_GT:\n+      return GT_EXPR;\n+    case COMPCODE_NE:\n+      return NE_EXPR;\n+    case COMPCODE_GE:\n+      return GE_EXPR;\n+    default:\n+      abort ();\n+    }\n+}\n+\n /* Return nonzero if CODE is a tree code that represents a truth value.  */\n \n static int\n@@ -3498,6 +3567,48 @@ fold_truthop (code, truth_type, lhs, rhs)\n   rl_arg = TREE_OPERAND (rhs, 0);\n   rr_arg = TREE_OPERAND (rhs, 1);\n \n+  /* Simplify (x<y) && (x==y) into (x<=y) and related optimizations.  */\n+  if (simple_operand_p (ll_arg)\n+      && simple_operand_p (lr_arg)\n+      && !FLOAT_TYPE_P (TREE_TYPE (ll_arg)))\n+    {\n+      int compcode;\n+\n+      if (operand_equal_p (ll_arg, rl_arg, 0)\n+          && operand_equal_p (lr_arg, rr_arg, 0))\n+        {\n+          int lcompcode, rcompcode;\n+\n+          lcompcode = comparison_to_compcode (lcode);\n+          rcompcode = comparison_to_compcode (rcode);\n+          compcode = (code == TRUTH_AND_EXPR)\n+                     ? lcompcode & rcompcode\n+                     : lcompcode | rcompcode;\n+        }\n+      else if (operand_equal_p (ll_arg, rr_arg, 0)\n+               && operand_equal_p (lr_arg, rl_arg, 0))\n+        {\n+          int lcompcode, rcompcode;\n+\n+          rcode = swap_tree_comparison (rcode);\n+          lcompcode = comparison_to_compcode (lcode);\n+          rcompcode = comparison_to_compcode (rcode);\n+          compcode = (code == TRUTH_AND_EXPR)\n+                     ? lcompcode & rcompcode\n+                     : lcompcode | rcompcode;\n+        }\n+      else\n+\tcompcode = -1;\n+\n+      if (compcode == COMPCODE_TRUE)\n+\treturn convert (truth_type, integer_one_node);\n+      else if (compcode == COMPCODE_FALSE)\n+\treturn convert (truth_type, integer_zero_node);\n+      else if (compcode != -1)\n+\treturn build (compcode_to_comparison (compcode),\n+\t\t      truth_type, ll_arg, lr_arg);\n+    }\n+\n   /* If the RHS can be evaluated unconditionally and its operands are\n      simple, it wins to evaluate the RHS unconditionally on machines\n      with expensive branches.  In this case, this isn't a comparison"}, {"sha": "68a9cc1aededfe73c49afad86b728b441c57fa0b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dcb27ed86eb249675749e35b1440a8ccfd03881/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dcb27ed86eb249675749e35b1440a8ccfd03881/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8dcb27ed86eb249675749e35b1440a8ccfd03881", "patch": "@@ -1,3 +1,9 @@\n+2002-06-15  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* gcc.c-tortuture/execute/compare-1.c: New test case.\n+\t* gcc.c-tortuture/execute/compare-2.c: New test case.\n+\t* gcc.c-tortuture/execute/compare-3.c: New test case.\n+\n 2002-06-13  Richard Henderson  <rth@redhat.com>\n \n \t* g++.old-deja/g++.abi/vtable2.C (INC_VDATA): New.  Define for"}, {"sha": "78b465024ea622641312008146031b39530e1b6a", "filename": "gcc/testsuite/gcc.c-torture/execute/compare-1.c", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dcb27ed86eb249675749e35b1440a8ccfd03881/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fcompare-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dcb27ed86eb249675749e35b1440a8ccfd03881/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fcompare-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fcompare-1.c?ref=8dcb27ed86eb249675749e35b1440a8ccfd03881", "patch": "@@ -0,0 +1,119 @@\n+/* Copyright (C) 2002 Free Software Foundation.\n+\n+   Test for correctness of composite comparisons.\n+\n+   Written by Roger Sayle, 3rd June 2002.  */\n+\n+extern void abort (void);\n+\n+int ieq (int x, int y, int ok)\n+{\n+  if ((x<=y) && (x>=y))\n+    {\n+      if (!ok) abort ();\n+    }\n+  else\n+    if (ok) abort ();\n+\n+  if ((x<=y) && (x==y))\n+    {\n+      if (!ok) abort ();\n+    }\n+  else\n+    if (ok) abort ();\n+\n+  if ((x<=y) && (y<=x))\n+    {\n+      if (!ok) abort ();\n+    }\n+  else\n+    if (ok) abort ();\n+\n+  if ((y==x) && (x<=y))\n+    {\n+      if (!ok) abort ();\n+    }\n+  else\n+    if (ok) abort ();\n+}\n+\n+int ine (int x, int y, int ok)\n+{\n+  if ((x<y) || (x>y))\n+    {\n+      if (!ok) abort ();\n+    }\n+  else\n+    if (ok) abort ();\n+}\n+\n+int ilt (int x, int y, int ok)\n+{\n+  if ((x<y) && (x!=y))\n+    {\n+      if (!ok) abort ();\n+    }\n+  else\n+    if (ok) abort ();\n+}\n+\n+int ile (int x, int y, int ok)\n+{\n+  if ((x<y) || (x==y))\n+    {\n+      if (!ok) abort ();\n+    }\n+  else\n+    if (ok) abort ();\n+}\n+\n+int igt (int x, int y, int ok)\n+{\n+  if ((x>y) && (x!=y))\n+    {\n+      if (!ok) abort ();\n+    }\n+  else\n+    if (ok) abort ();\n+}\n+\n+int ige (int x, int y, int ok)\n+{\n+  if ((x>y) || (x==y))\n+    {\n+      if (!ok) abort ();\n+    }\n+  else\n+    if (ok) abort ();\n+}\n+\n+int\n+main ()\n+{\n+  ieq (1, 4, 0);\n+  ieq (3, 3, 1);\n+  ieq (5, 2, 0);\n+\n+  ine (1, 4, 1);\n+  ine (3, 3, 0);\n+  ine (5, 2, 1);\n+\n+  ilt (1, 4, 1);\n+  ilt (3, 3, 0);\n+  ilt (5, 2, 0);\n+\n+  ile (1, 4, 1);\n+  ile (3, 3, 1);\n+  ile (5, 2, 0);\n+\n+  igt (1, 4, 0);\n+  igt (3, 3, 0);\n+  igt (5, 2, 1);\n+\n+  ige (1, 4, 0);\n+  ige (3, 3, 1);\n+  ige (5, 2, 1);\n+\n+  return 0;\n+}\n+"}, {"sha": "858df294ecaf9a264e451bb25fef98071cbbe210", "filename": "gcc/testsuite/gcc.c-torture/execute/compare-2.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dcb27ed86eb249675749e35b1440a8ccfd03881/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fcompare-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dcb27ed86eb249675749e35b1440a8ccfd03881/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fcompare-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fcompare-2.c?ref=8dcb27ed86eb249675749e35b1440a8ccfd03881", "patch": "@@ -0,0 +1,24 @@\n+/* Copyright (C) 2002 Free Software Foundation.\n+\n+   Ensure that the composite comparison optimization doesn't misfire\n+   and attempt to combine a signed comparison with an unsigned one.\n+\n+   Written by Roger Sayle, 3rd June 2002.  */\n+\n+extern void abort (void);\n+\n+int\n+foo (int x, int y)\n+{\n+  /* If miscompiled the following may become \"x == y\".  */\n+  return (x<=y) && ((unsigned int)x >= (unsigned int)y);\n+}\n+\n+int\n+main ()\n+{\n+  if (! foo (-1,0))\n+    abort ();\n+  return 0;\n+}\n+"}, {"sha": "6549c904b52e1e3beeac2c7c44ef1df65039f227", "filename": "gcc/testsuite/gcc.c-torture/execute/compare-3.c", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dcb27ed86eb249675749e35b1440a8ccfd03881/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fcompare-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dcb27ed86eb249675749e35b1440a8ccfd03881/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fcompare-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fcompare-3.c?ref=8dcb27ed86eb249675749e35b1440a8ccfd03881", "patch": "@@ -0,0 +1,86 @@\n+/* Copyright (C) 2002 Free Software Foundation.\n+\n+   Test for composite comparison always true/false optimization.\n+\n+   Written by Roger Sayle, 7th June 2002.  */\n+\n+extern void link_error0 ();\n+extern void link_error1 ();\n+\n+void\n+test1 (int x, int y)\n+{\n+  if ((x==y) && (x!=y))\n+    link_error0();\n+}\n+\n+void\n+test2 (int x, int y)\n+{\n+  if ((x<y) && (x>y))\n+    link_error0();\n+}\n+\n+void\n+test3 (int x, int y)\n+{\n+  if ((x<y) && (y<x))\n+    link_error0();\n+}\n+\n+void \n+test4 (int x, int y)\n+{\n+  if ((x==y) || (x!=y))\n+    {\n+    }\n+  else\n+    link_error1 ();\n+}\n+\n+void\n+test5 (int x, int y)\n+{\n+  if ((x>=y) || (x<y))\n+    {\n+    }\n+  else\n+    link_error1 ();\n+}\n+\n+void\n+test6 (int x, int y)\n+{\n+  if ((x<=y) || (y<x))\n+    {\n+    }\n+  else\n+    link_error1 ();\n+}\n+\n+void\n+all_tests (int x, int y)\n+{\n+  test1 (x, y);\n+  test2 (x, y);\n+  test3 (x, y);\n+  test4 (x, y);\n+  test5 (x, y);\n+  test6 (x, y);\n+}\n+\n+int\n+main ()\n+{\n+  all_tests (0, 0);\n+  all_tests (1, 2);\n+  all_tests (4, 3);\n+\n+  return 0;\n+}\n+\n+#ifndef __OPTIMIZE__\n+void link_error0() {}\n+void link_error1() {}\n+#endif /* ! __OPTIMIZE__ */\n+"}]}