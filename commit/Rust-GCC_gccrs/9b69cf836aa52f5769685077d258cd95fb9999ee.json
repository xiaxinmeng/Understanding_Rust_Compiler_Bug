{"sha": "9b69cf836aa52f5769685077d258cd95fb9999ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWI2OWNmODM2YWE1MmY1NzY5Njg1MDc3ZDI1OGNkOTVmYjk5OTllZQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2011-04-04T16:53:51Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2011-04-04T16:53:51Z"}, "message": "re PR bootstrap/48403 (bootstrap comparison failure)\n\nFix PR bootstrap/48403.\n\n2011-04-04  Bernd Schmidt  <bernds@codesourcery.com>\n\n\tPR bootstrap/48403\n\t* haifa-sched.c (nonscheduled_insns_begin): New static variable.\n\t(rank_for_schedule): Use scheduled_insns vector instead of\n\tlast_scheduled_insn.\n\t(ok_for_early_queue_removal): Likewise.\n\t(queue_to_ready): Search forward in nonscheduled_insns_begin if\n\twe have a dbg_cnt.\n\t(choose_ready): Likewise.\n\t(commit_schedule): Use VEC_iterate.\n\t(schedule_block): Initialize nonscheduled_insns_begin.  If we have\n\ta dbg_cnt, use it and ensure the first insn is in the ready list.\n\t(haifa_sched_init): Allocate scheduled_insns.\n\t(sched_extend_ready_list): Don't allocate it; reserve space.\n\t(haifa_sched_finish): Free it.\n\nFrom-SVN: r171942", "tree": {"sha": "ff67bf01de5159e212ece6ece7e302bfc2b86f01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff67bf01de5159e212ece6ece7e302bfc2b86f01"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b69cf836aa52f5769685077d258cd95fb9999ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b69cf836aa52f5769685077d258cd95fb9999ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b69cf836aa52f5769685077d258cd95fb9999ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b69cf836aa52f5769685077d258cd95fb9999ee/comments", "author": null, "committer": null, "parents": [{"sha": "d355ede7fdd18fc5783df1b90204080aef4b3dc8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d355ede7fdd18fc5783df1b90204080aef4b3dc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d355ede7fdd18fc5783df1b90204080aef4b3dc8"}], "stats": {"total": 107, "additions": 70, "deletions": 37}, "files": [{"sha": "ecb6692fe678163b85cadd692c1ea60805747d71", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b69cf836aa52f5769685077d258cd95fb9999ee/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b69cf836aa52f5769685077d258cd95fb9999ee/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9b69cf836aa52f5769685077d258cd95fb9999ee", "patch": "@@ -1,3 +1,20 @@\n+2011-04-04  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\tPR bootstrap/48403\n+\t* haifa-sched.c (nonscheduled_insns_begin): New static variable.\n+\t(rank_for_schedule): Use scheduled_insns vector instead of\n+\tlast_scheduled_insn.\n+\t(ok_for_early_queue_removal): Likewise.\n+\t(queue_to_ready): Search forward in nonscheduled_insns_begin if\n+\twe have a dbg_cnt.\n+\t(choose_ready): Likewise.\n+\t(commit_schedule): Use VEC_iterate.\n+\t(schedule_block): Initialize nonscheduled_insns_begin.  If we have\n+\ta dbg_cnt, use it and ensure the first insn is in the ready list.\n+\t(haifa_sched_init): Allocate scheduled_insns.\n+\t(sched_extend_ready_list): Don't allocate it; reserve space.\n+\t(haifa_sched_finish): Free it.\n+\n 2011-04-04  Joseph Myers  <joseph@codesourcery.com>\n \n \t* optc-gen.awk: Always remove type from Variable entry before"}, {"sha": "8f2e4ada33c38285dce342b4d5eee7ee6bb87e6a", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 53, "deletions": 37, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b69cf836aa52f5769685077d258cd95fb9999ee/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b69cf836aa52f5769685077d258cd95fb9999ee/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=9b69cf836aa52f5769685077d258cd95fb9999ee", "patch": "@@ -780,12 +780,14 @@ print_curr_reg_pressure (void)\n   fprintf (sched_dump, \"\\n\");\n }\n \n-/* Pointer to the last instruction scheduled.  Used by rank_for_schedule,\n-   so that insns independent of the last scheduled insn will be preferred\n-   over dependent instructions.  */\n-\n+/* Pointer to the last instruction scheduled.  */\n static rtx last_scheduled_insn;\n \n+/* Pointer that iterates through the list of unscheduled insns if we\n+   have a dbg_cnt enabled.  It always points at an insn prior to the\n+   first unscheduled one.  */\n+static rtx nonscheduled_insns_begin;\n+\n /* Cached cost of the instruction.  Use below function to get cost of the\n    insn.  -1 here means that the field is not initialized.  */\n #define INSN_COST(INSN)\t(HID (INSN)->cost)\n@@ -1239,18 +1241,19 @@ rank_for_schedule (const void *x, const void *y)\n \n   if (flag_sched_last_insn_heuristic)\n     {\n-      last = last_scheduled_insn;\n-\n-      if (DEBUG_INSN_P (last) && last != current_sched_info->prev_head)\n-\tdo\n-\t  last = PREV_INSN (last);\n-\twhile (!NONDEBUG_INSN_P (last)\n-\t       && last != current_sched_info->prev_head);\n+      int i = VEC_length (rtx, scheduled_insns);\n+      last = NULL_RTX;\n+      while (i-- > 0)\n+\t{\n+\t  last = VEC_index (rtx, scheduled_insns, i);\n+\t  if (NONDEBUG_INSN_P (last))\n+\t    break;\n+\t}\n     }\n \n   /* Compare insns based on their relation to the last scheduled\n      non-debug insn.  */\n-  if (flag_sched_last_insn_heuristic && NONDEBUG_INSN_P (last))\n+  if (flag_sched_last_insn_heuristic && last && NONDEBUG_INSN_P (last))\n     {\n       dep_t dep1;\n       dep_t dep2;\n@@ -2044,9 +2047,16 @@ queue_to_ready (struct ready_list *ready)\n   q_ptr = NEXT_Q (q_ptr);\n \n   if (dbg_cnt (sched_insn) == false)\n-    /* If debug counter is activated do not requeue insn next after\n-       last_scheduled_insn.  */\n-    skip_insn = next_nonnote_nondebug_insn (last_scheduled_insn);\n+    {\n+      /* If debug counter is activated do not requeue the first\n+\t nonscheduled insn.  */\n+      skip_insn = nonscheduled_insns_begin;\n+      do\n+\t{\n+\t  skip_insn = next_nonnote_nondebug_insn (skip_insn);\n+\t}\n+      while (QUEUE_INDEX (skip_insn) == QUEUE_SCHEDULED);\n+    }\n   else\n     skip_insn = NULL_RTX;\n \n@@ -2129,22 +2139,18 @@ queue_to_ready (struct ready_list *ready)\n static bool\n ok_for_early_queue_removal (rtx insn)\n {\n-  int n_cycles;\n-  rtx prev_insn = last_scheduled_insn;\n-\n   if (targetm.sched.is_costly_dependence)\n     {\n+      rtx prev_insn;\n+      int n_cycles;\n+      int i = VEC_length (rtx, scheduled_insns);\n       for (n_cycles = flag_sched_stalled_insns_dep; n_cycles; n_cycles--)\n \t{\n-\t  for ( ; prev_insn; prev_insn = PREV_INSN (prev_insn))\n+\t  while (i-- > 0)\n \t    {\n \t      int cost;\n \n-\t      if (prev_insn == current_sched_info->prev_head)\n-\t\t{\n-\t\t  prev_insn = NULL;\n-\t\t  break;\n-\t\t}\n+\t      prev_insn = VEC_index (rtx, scheduled_insns, i);\n \n \t      if (!NOTE_P (prev_insn))\n \t\t{\n@@ -2166,9 +2172,8 @@ ok_for_early_queue_removal (rtx insn)\n \t\tbreak;\n \t    }\n \n-\t  if (!prev_insn)\n+\t  if (i == 0)\n \t    break;\n-\t  prev_insn = PREV_INSN (prev_insn);\n \t}\n     }\n \n@@ -2673,13 +2678,17 @@ choose_ready (struct ready_list *ready, bool first_cycle_insn_p,\n \n   if (dbg_cnt (sched_insn) == false)\n     {\n-      rtx insn;\n-\n-      insn = next_nonnote_insn (last_scheduled_insn);\n+      rtx insn = nonscheduled_insns_begin;\n+      do\n+\t{\n+\t  insn = next_nonnote_insn (insn);\n+\t}\n+      while (QUEUE_INDEX (insn) == QUEUE_SCHEDULED);\n \n       if (QUEUE_INDEX (insn) == QUEUE_READY)\n \t/* INSN is in the ready_list.  */\n \t{\n+\t  nonscheduled_insns_begin = insn;\n \t  ready_remove_insn (insn);\n \t  *insn_ptr = insn;\n \t  return 0;\n@@ -2826,13 +2835,14 @@ choose_ready (struct ready_list *ready, bool first_cycle_insn_p,\n static void\n commit_schedule (rtx prev_head, rtx tail, basic_block *target_bb)\n {\n-  int i;\n+  unsigned int i;\n+  rtx insn;\n \n   last_scheduled_insn = prev_head;\n-  for (i = 0; i < (int)VEC_length (rtx, scheduled_insns); i++)\n+  for (i = 0;\n+       VEC_iterate (rtx, scheduled_insns, i, insn);\n+       i++)\n     {\n-      rtx insn = VEC_index (rtx, scheduled_insns, i);\n-\n       if (control_flow_insn_p (last_scheduled_insn)\n \t  || current_sched_info->advance_target_bb (*target_bb, insn))\n \t{\n@@ -2956,7 +2966,7 @@ schedule_block (basic_block *target_bb)\n     targetm.sched.init (sched_dump, sched_verbose, ready.veclen);\n \n   /* We start inserting insns after PREV_HEAD.  */\n-  last_scheduled_insn = prev_head;\n+  last_scheduled_insn = nonscheduled_insns_begin = prev_head;\n \n   gcc_assert ((NOTE_P (last_scheduled_insn)\n \t       || DEBUG_INSN_P (last_scheduled_insn))\n@@ -3001,12 +3011,12 @@ schedule_block (basic_block *target_bb)\n \n       /* Delay all insns past it for 1 cycle.  If debug counter is\n \t activated make an exception for the insn right after\n-\t last_scheduled_insn.  */\n+\t nonscheduled_insns_begin.  */\n       {\n \trtx skip_insn;\n \n \tif (dbg_cnt (sched_insn) == false)\n-\t  skip_insn = next_nonnote_insn (last_scheduled_insn);\n+\t  skip_insn = next_nonnote_insn (nonscheduled_insns_begin);\n \telse\n \t  skip_insn = NULL_RTX;\n \n@@ -3019,6 +3029,8 @@ schedule_block (basic_block *target_bb)\n \t    if (insn != skip_insn)\n \t      queue_insn (insn, 1, \"list truncated\");\n \t  }\n+\tif (skip_insn)\n+\t  ready_add (&ready, skip_insn, true);\n       }\n     }\n \n@@ -3540,6 +3552,8 @@ haifa_sched_init (void)\n   setup_sched_dump ();\n   sched_init ();\n \n+  scheduled_insns = VEC_alloc (rtx, heap, 0);\n+\n   if (spec_info != NULL)\n     {\n       sched_deps_info->use_deps_list = 1;\n@@ -3610,6 +3624,8 @@ haifa_sched_finish (void)\n                c, nr_be_in_control);\n     }\n \n+  VEC_free (rtx, heap, scheduled_insns);\n+\n   /* Finalize h_i_d, dependency caches, and luids for the whole\n      function.  Target will be finalized in md_global_finish ().  */\n   sched_deps_finish ();\n@@ -4008,7 +4024,7 @@ sched_extend_ready_list (int new_sched_ready_n_insns)\n     {\n       i = 0;\n       sched_ready_n_insns = 0;\n-      scheduled_insns = VEC_alloc (rtx, heap, new_sched_ready_n_insns);\n+      VEC_reserve (rtx, heap, scheduled_insns, new_sched_ready_n_insns);\n     }\n   else\n     i = sched_ready_n_insns + 1;"}]}