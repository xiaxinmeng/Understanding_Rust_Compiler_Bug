{"sha": "279b84660bf493976de41fe1320690dcae3ec279", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjc5Yjg0NjYwYmY0OTM5NzZkZTQxZmUxMzIwNjkwZGNhZTNlYzI3OQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2003-07-09T23:06:39Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2003-07-09T23:06:39Z"}, "message": "parser.c (cp_parser_primary_expression): Preserve the form of qualified expressions in templates...\n\n\t* parser.c (cp_parser_primary_expression): Preserve the form of\n\tqualified expressions in templates, even if they are not\n\tdependent.\n\t* pt.c (convert_nontype_argument): Handle non-dependent SCOPE_REFs.\n\t(tsubst_qualified_id): Likewise.\n\t* search.c (accessible_p): Treat everything in the body of a\n\nFrom-SVN: r69160", "tree": {"sha": "01da5236669d609ce81b5e86fefc7f54e6b12b70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01da5236669d609ce81b5e86fefc7f54e6b12b70"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/279b84660bf493976de41fe1320690dcae3ec279", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/279b84660bf493976de41fe1320690dcae3ec279", "html_url": "https://github.com/Rust-GCC/gccrs/commit/279b84660bf493976de41fe1320690dcae3ec279", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/279b84660bf493976de41fe1320690dcae3ec279/comments", "author": null, "committer": null, "parents": [{"sha": "bb498ea3a5c35c73f3ca3a89642637eec1c2c4a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb498ea3a5c35c73f3ca3a89642637eec1c2c4a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb498ea3a5c35c73f3ca3a89642637eec1c2c4a8"}], "stats": {"total": 47, "additions": 38, "deletions": 9}, "files": [{"sha": "4544e1b4f11e62203ce8e11c6363e7941a957362", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/279b84660bf493976de41fe1320690dcae3ec279/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/279b84660bf493976de41fe1320690dcae3ec279/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=279b84660bf493976de41fe1320690dcae3ec279", "patch": "@@ -1,3 +1,13 @@\n+2003-07-09  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* parser.c (cp_parser_primary_expression): Preserve the form of\n+\tqualified expressions in templates, even if they are not\n+\tdependent.\n+\t* pt.c (convert_nontype_argument): Handle non-dependent SCOPE_REFs.\n+\t(tsubst_qualified_id): Likewise.\n+\t* search.c (accessible_p): Treat everything in the body of a\n+\ttemplate as accessible.\n+\n 2003-07-08  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.def (NON_DEPENDENT_EXPR): New node."}, {"sha": "60ec06947557f72341782e07734ce9062e584000", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/279b84660bf493976de41fe1320690dcae3ec279/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/279b84660bf493976de41fe1320690dcae3ec279/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=279b84660bf493976de41fe1320690dcae3ec279", "patch": "@@ -2648,6 +2648,12 @@ cp_parser_primary_expression (cp_parser *parser,\n \t\t      return build_nt (SCOPE_REF, \n \t\t\t\t       parser->scope, \n \t\t\t\t       id_expression);\n+\t\t    else if (TYPE_P (parser->scope)\n+\t\t\t     && DECL_P (decl))\n+\t\t      return build (SCOPE_REF,\n+\t\t\t\t    TREE_TYPE (decl),\n+\t\t\t\t    parser->scope,\n+\t\t\t\t    id_expression);\n \t\t    else\n \t\t      return decl;\n \t\t  }\n@@ -2705,6 +2711,11 @@ cp_parser_primary_expression (cp_parser *parser,\n \t\t  *qualifying_class = parser->scope;\n \t\telse if (!processing_template_decl)\n \t\t  decl = convert_from_reference (decl);\n+\t\telse if (TYPE_P (parser->scope))\n+\t\t  decl = build (SCOPE_REF,\n+\t\t\t\tTREE_TYPE (decl),\n+\t\t\t\tparser->scope,\n+\t\t\t\tdecl);\n \t      }\n \t    else\n \t      /* Transform references to non-static data members into"}, {"sha": "b4c9cedfad8292b2282c6fe7303a1a5e93b727ed", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/279b84660bf493976de41fe1320690dcae3ec279/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/279b84660bf493976de41fe1320690dcae3ec279/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=279b84660bf493976de41fe1320690dcae3ec279", "patch": "@@ -3054,7 +3054,6 @@ convert_nontype_argument (tree type, tree expr)\n \tgoto bad_argument;\n     }\n   else if (TYPE_PTR_P (expr_type)\n-\t   || TYPE_PTRMEM_P (expr_type)\n \t   || TREE_CODE (expr_type) == ARRAY_TYPE\n \t   || TREE_CODE (type) == REFERENCE_TYPE\n \t   /* If expr is the address of an overloaded function, we\n@@ -3100,6 +3099,9 @@ convert_nontype_argument (tree type, tree expr)\n \t  return NULL_TREE;\n \t}\n \n+      if (TREE_CODE (referent) == SCOPE_REF)\n+\treferent = TREE_OPERAND (referent, 1);\n+\n       if (is_overloaded_fn (referent))\n \t/* We'll check that it has external linkage later.  */\n \t;\n@@ -7160,14 +7162,13 @@ tsubst_qualified_id (tree qualified_id, tree args,\n     }\n \n   expr = tsubst_copy (name, args, complain, in_decl);\n-  if (!BASELINK_P (name))\n-    {\n-      expr = lookup_qualified_name (scope, expr, /*is_type_p=*/0);\n-      if (DECL_P (expr))\n-\tcheck_accessibility_of_qualified_id (expr, \n-\t\t\t\t\t     /*object_type=*/NULL_TREE,\n-\t\t\t\t\t     scope);\n-    }\n+  if (!BASELINK_P (name)\n+      && !DECL_P (expr))\n+    expr = lookup_qualified_name (scope, expr, /*is_type_p=*/0);\n+  if (DECL_P (expr))\n+    check_accessibility_of_qualified_id (expr, \n+\t\t\t\t\t /*object_type=*/NULL_TREE,\n+\t\t\t\t\t scope);\n \n   /* Remember that there was a reference to this entity.  */\n   if (DECL_P (expr))"}, {"sha": "c2c158a691c3aac5fa7711ecf13fc2a02e4694a3", "filename": "gcc/cp/search.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/279b84660bf493976de41fe1320690dcae3ec279/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/279b84660bf493976de41fe1320690dcae3ec279/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=279b84660bf493976de41fe1320690dcae3ec279", "patch": "@@ -903,6 +903,13 @@ accessible_p (tree type, tree decl)\n   if (!TYPE_P (context_for_name_lookup (decl)))\n     return 1;\n \n+  /* In a template declaration, we cannot be sure whether the\n+     particular specialization that is instantiated will be a friend\n+     or not.  Therefore, all access checks are deferred until\n+     instantiation.  */\n+  if (processing_template_decl)\n+    return 1;\n+\n   if (!TYPE_P (type))\n     {\n       binfo = type;"}]}