{"sha": "ea250f561291c184423c4372041c067f5233fa5c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWEyNTBmNTYxMjkxYzE4NDQyM2M0MzcyMDQxYzA2N2Y1MjMzZmE1Yw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-04-17T22:10:58Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-04-17T22:10:58Z"}, "message": "libgo: update to Go 1.8.1 release\n    \n    Reviewed-on: https://go-review.googlesource.com/40775\n\nFrom-SVN: r246957", "tree": {"sha": "a190311458c423b71ed9f800fd5bd43faa7dccc3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a190311458c423b71ed9f800fd5bd43faa7dccc3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea250f561291c184423c4372041c067f5233fa5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea250f561291c184423c4372041c067f5233fa5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea250f561291c184423c4372041c067f5233fa5c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea250f561291c184423c4372041c067f5233fa5c/comments", "author": null, "committer": null, "parents": [{"sha": "1adb82e11762ce349eeaee1051ea3c379a453b2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1adb82e11762ce349eeaee1051ea3c379a453b2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1adb82e11762ce349eeaee1051ea3c379a453b2e"}], "stats": {"total": 400, "additions": 359, "deletions": 41}, "files": [{"sha": "a5808db54ff4c4fcb01fae79c808159cd73385c6", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea250f561291c184423c4372041c067f5233fa5c/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea250f561291c184423c4372041c067f5233fa5c/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=ea250f561291c184423c4372041c067f5233fa5c", "patch": "@@ -1,4 +1,4 @@\n-cd6b6202dd1559b3ac63179b45f1833fcfbe7eca\n+a4c18f063b6659079ca2848ca217a0587dabc001\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "dce1d463ba144a2d58ae0d9a336b2796938d8f15", "filename": "libgo/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea250f561291c184423c4372041c067f5233fa5c/libgo%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea250f561291c184423c4372041c067f5233fa5c/libgo%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FVERSION?ref=ea250f561291c184423c4372041c067f5233fa5c", "patch": "@@ -1 +1 @@\n-go1.8\n+go1.8.1"}, {"sha": "fa78578d1215142efbe3a31ee451e12888340c57", "filename": "libgo/go/cmd/go/go_test.go", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea250f561291c184423c4372041c067f5233fa5c/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea250f561291c184423c4372041c067f5233fa5c/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go?ref=ea250f561291c184423c4372041c067f5233fa5c", "patch": "@@ -2227,6 +2227,24 @@ func TestTestEmpty(t *testing.T) {\n \t}\n }\n \n+func TestTestRaceInstall(t *testing.T) {\n+\tif !canRace {\n+\t\tt.Skip(\"no race detector\")\n+\t}\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\n+\ttg.tempDir(\"pkg\")\n+\tpkgdir := tg.path(\"pkg\")\n+\ttg.run(\"install\", \"-race\", \"-pkgdir=\"+pkgdir, \"std\")\n+\ttg.run(\"test\", \"-race\", \"-pkgdir=\"+pkgdir, \"-i\", \"-v\", \"empty/pkg\")\n+\tif tg.getStderr() != \"\" {\n+\t\tt.Error(\"go test -i -race: rebuilds cached packages\")\n+\t}\n+}\n+\n func TestBuildDryRunWithCgo(t *testing.T) {\n \tif !canCgo {\n \t\tt.Skip(\"skipping because cgo not enabled\")"}, {"sha": "f0dc95670f99289821a32cc124db1cff0ef05376", "filename": "libgo/go/cmd/go/pkg.go", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea250f561291c184423c4372041c067f5233fa5c/libgo%2Fgo%2Fcmd%2Fgo%2Fpkg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea250f561291c184423c4372041c067f5233fa5c/libgo%2Fgo%2Fcmd%2Fgo%2Fpkg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fpkg.go?ref=ea250f561291c184423c4372041c067f5233fa5c", "patch": "@@ -970,10 +970,6 @@ func (p *Package) load(stk *importStack, bp *build.Package, err error) *Package\n \t\tif p.Name == \"main\" && goarch == \"arm\" {\n \t\t\timportPaths = append(importPaths, \"math\")\n \t\t}\n-\t\t// In coverage atomic mode everything depends on sync/atomic.\n-\t\tif testCoverMode == \"atomic\" && (!p.Standard || (p.ImportPath != \"runtime/cgo\" && p.ImportPath != \"runtime/race\" && p.ImportPath != \"sync/atomic\")) {\n-\t\t\timportPaths = append(importPaths, \"sync/atomic\")\n-\t\t}\n \t}\n \n \t// Runtime and its internal packages depend on runtime/internal/sys,"}, {"sha": "12990feb43c97e5a6d0e391ec79db79f9c703df8", "filename": "libgo/go/cmd/go/test.go", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea250f561291c184423c4372041c067f5233fa5c/libgo%2Fgo%2Fcmd%2Fgo%2Ftest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea250f561291c184423c4372041c067f5233fa5c/libgo%2Fgo%2Fcmd%2Fgo%2Ftest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftest.go?ref=ea250f561291c184423c4372041c067f5233fa5c", "patch": "@@ -548,6 +548,10 @@ func runTest(cmd *Command, args []string) {\n \n \t// Prepare build + run + print actions for all packages being tested.\n \tfor _, p := range pkgs {\n+\t\t// sync/atomic import is inserted by the cover tool. See #18486\n+\t\tif testCover && testCoverMode == \"atomic\" {\n+\t\t\tensureImport(p, \"sync/atomic\")\n+\t\t}\n \t\tbuildTest, runTest, printTest, err := b.test(p)\n \t\tif err != nil {\n \t\t\tstr := err.Error()\n@@ -639,6 +643,23 @@ func runTest(cmd *Command, args []string) {\n \tb.do(root)\n }\n \n+// ensures that package p imports the named package.\n+func ensureImport(p *Package, pkg string) {\n+\tfor _, d := range p.deps {\n+\t\tif d.Name == pkg {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\n+\ta := loadPackage(pkg, &importStack{})\n+\tif a.Error != nil {\n+\t\tfatalf(\"load %s: %v\", pkg, a.Error)\n+\t}\n+\tcomputeStale(a)\n+\n+\tp.imports = append(p.imports, a)\n+}\n+\n func contains(x []string, s string) bool {\n \tfor _, t := range x {\n \t\tif t == s {"}, {"sha": "de833a905637259351433976f1c06b36d713a5f9", "filename": "libgo/go/crypto/tls/common.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea250f561291c184423c4372041c067f5233fa5c/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea250f561291c184423c4372041c067f5233fa5c/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go?ref=ea250f561291c184423c4372041c067f5233fa5c", "patch": "@@ -563,6 +563,7 @@ func (c *Config) Clone() *Config {\n \t\tCertificates:                c.Certificates,\n \t\tNameToCertificate:           c.NameToCertificate,\n \t\tGetCertificate:              c.GetCertificate,\n+\t\tGetClientCertificate:        c.GetClientCertificate,\n \t\tGetConfigForClient:          c.GetConfigForClient,\n \t\tVerifyPeerCertificate:       c.VerifyPeerCertificate,\n \t\tRootCAs:                     c.RootCAs,"}, {"sha": "86812f0c974cf36076d133e46106596f668f9654", "filename": "libgo/go/crypto/tls/tls_test.go", "status": "modified", "additions": 68, "deletions": 22, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea250f561291c184423c4372041c067f5233fa5c/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea250f561291c184423c4372041c067f5233fa5c/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls_test.go?ref=ea250f561291c184423c4372041c067f5233fa5c", "patch": "@@ -13,13 +13,11 @@ import (\n \t\"io\"\n \t\"io/ioutil\"\n \t\"math\"\n-\t\"math/rand\"\n \t\"net\"\n \t\"os\"\n \t\"reflect\"\n \t\"strings\"\n \t\"testing\"\n-\t\"testing/quick\"\n \t\"time\"\n )\n \n@@ -568,11 +566,50 @@ func TestConnCloseWrite(t *testing.T) {\n \t}\n }\n \n-func TestClone(t *testing.T) {\n+func TestCloneFuncFields(t *testing.T) {\n+\tconst expectedCount = 5\n+\tcalled := 0\n+\n+\tc1 := Config{\n+\t\tTime: func() time.Time {\n+\t\t\tcalled |= 1 << 0\n+\t\t\treturn time.Time{}\n+\t\t},\n+\t\tGetCertificate: func(*ClientHelloInfo) (*Certificate, error) {\n+\t\t\tcalled |= 1 << 1\n+\t\t\treturn nil, nil\n+\t\t},\n+\t\tGetClientCertificate: func(*CertificateRequestInfo) (*Certificate, error) {\n+\t\t\tcalled |= 1 << 2\n+\t\t\treturn nil, nil\n+\t\t},\n+\t\tGetConfigForClient: func(*ClientHelloInfo) (*Config, error) {\n+\t\t\tcalled |= 1 << 3\n+\t\t\treturn nil, nil\n+\t\t},\n+\t\tVerifyPeerCertificate: func(rawCerts [][]byte, verifiedChains [][]*x509.Certificate) error {\n+\t\t\tcalled |= 1 << 4\n+\t\t\treturn nil\n+\t\t},\n+\t}\n+\n+\tc2 := c1.Clone()\n+\n+\tc2.Time()\n+\tc2.GetCertificate(nil)\n+\tc2.GetClientCertificate(nil)\n+\tc2.GetConfigForClient(nil)\n+\tc2.VerifyPeerCertificate(nil, nil)\n+\n+\tif called != (1<<expectedCount)-1 {\n+\t\tt.Fatalf(\"expected %d calls but saw calls %b\", expectedCount, called)\n+\t}\n+}\n+\n+func TestCloneNonFuncFields(t *testing.T) {\n \tvar c1 Config\n \tv := reflect.ValueOf(&c1).Elem()\n \n-\trnd := rand.New(rand.NewSource(time.Now().Unix()))\n \ttyp := v.Type()\n \tfor i := 0; i < typ.NumField(); i++ {\n \t\tf := v.Field(i)\n@@ -581,40 +618,49 @@ func TestClone(t *testing.T) {\n \t\t\tcontinue\n \t\t}\n \n-\t\t// testing/quick can't handle functions or interfaces.\n-\t\tfn := typ.Field(i).Name\n-\t\tswitch fn {\n+\t\t// testing/quick can't handle functions or interfaces and so\n+\t\t// isn't used here.\n+\t\tswitch fn := typ.Field(i).Name; fn {\n \t\tcase \"Rand\":\n \t\t\tf.Set(reflect.ValueOf(io.Reader(os.Stdin)))\n-\t\t\tcontinue\n \t\tcase \"Time\", \"GetCertificate\", \"GetConfigForClient\", \"VerifyPeerCertificate\", \"GetClientCertificate\":\n-\t\t\t// DeepEqual can't compare functions.\n-\t\t\tcontinue\n+\t\t\t// DeepEqual can't compare functions. If you add a\n+\t\t\t// function field to this list, you must also change\n+\t\t\t// TestCloneFuncFields to ensure that the func field is\n+\t\t\t// cloned.\n \t\tcase \"Certificates\":\n \t\t\tf.Set(reflect.ValueOf([]Certificate{\n \t\t\t\t{Certificate: [][]byte{{'b'}}},\n \t\t\t}))\n-\t\t\tcontinue\n \t\tcase \"NameToCertificate\":\n \t\t\tf.Set(reflect.ValueOf(map[string]*Certificate{\"a\": nil}))\n-\t\t\tcontinue\n \t\tcase \"RootCAs\", \"ClientCAs\":\n \t\t\tf.Set(reflect.ValueOf(x509.NewCertPool()))\n-\t\t\tcontinue\n \t\tcase \"ClientSessionCache\":\n \t\t\tf.Set(reflect.ValueOf(NewLRUClientSessionCache(10)))\n-\t\t\tcontinue\n \t\tcase \"KeyLogWriter\":\n \t\t\tf.Set(reflect.ValueOf(io.Writer(os.Stdout)))\n-\t\t\tcontinue\n-\n-\t\t}\n-\n-\t\tq, ok := quick.Value(f.Type(), rnd)\n-\t\tif !ok {\n-\t\t\tt.Fatalf(\"quick.Value failed on field %s\", fn)\n+\t\tcase \"NextProtos\":\n+\t\t\tf.Set(reflect.ValueOf([]string{\"a\", \"b\"}))\n+\t\tcase \"ServerName\":\n+\t\t\tf.Set(reflect.ValueOf(\"b\"))\n+\t\tcase \"ClientAuth\":\n+\t\t\tf.Set(reflect.ValueOf(VerifyClientCertIfGiven))\n+\t\tcase \"InsecureSkipVerify\", \"SessionTicketsDisabled\", \"DynamicRecordSizingDisabled\", \"PreferServerCipherSuites\":\n+\t\t\tf.Set(reflect.ValueOf(true))\n+\t\tcase \"MinVersion\", \"MaxVersion\":\n+\t\t\tf.Set(reflect.ValueOf(uint16(VersionTLS12)))\n+\t\tcase \"SessionTicketKey\":\n+\t\t\tf.Set(reflect.ValueOf([32]byte{}))\n+\t\tcase \"CipherSuites\":\n+\t\t\tf.Set(reflect.ValueOf([]uint16{1, 2}))\n+\t\tcase \"CurvePreferences\":\n+\t\t\tf.Set(reflect.ValueOf([]CurveID{CurveP256}))\n+\t\tcase \"Renegotiation\":\n+\t\t\tf.Set(reflect.ValueOf(RenegotiateOnceAsClient))\n+\t\tdefault:\n+\t\t\tt.Errorf(\"all fields must be accounted for, but saw unknown field %q\", fn)\n \t\t}\n-\t\tf.Set(q)\n \t}\n \n \tc2 := c1.Clone()"}, {"sha": "0126146d332e0e098450074325228a84401e1e40", "filename": "libgo/go/encoding/xml/marshal_test.go", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea250f561291c184423c4372041c067f5233fa5c/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea250f561291c184423c4372041c067f5233fa5c/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go?ref=ea250f561291c184423c4372041c067f5233fa5c", "patch": "@@ -2428,7 +2428,10 @@ func TestIssue16158(t *testing.T) {\n \terr := Unmarshal([]byte(data), &struct {\n \t\tB byte `xml:\"b,attr,omitempty\"`\n \t}{})\n-\tif err == nil {\n-\t\tt.Errorf(\"Unmarshal: expected error, got nil\")\n+\n+\t// For Go 1.8.1 we've restored the old \"no errors reported\" behavior.\n+\t// We'll try again in Go 1.9 to report errors.\n+\tif err != nil {\n+\t\tt.Errorf(\"Unmarshal: expected nil, got error\")\n \t}\n }"}, {"sha": "799b57e9d1515a09c81d8f8932f21871bf7c567c", "filename": "libgo/go/encoding/xml/read.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea250f561291c184423c4372041c067f5233fa5c/libgo%2Fgo%2Fencoding%2Fxml%2Fread.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea250f561291c184423c4372041c067f5233fa5c/libgo%2Fgo%2Fencoding%2Fxml%2Fread.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fread.go?ref=ea250f561291c184423c4372041c067f5233fa5c", "patch": "@@ -285,7 +285,8 @@ func (p *Decoder) unmarshalAttr(val reflect.Value, attr Attr) error {\n \t\treturn nil\n \t}\n \n-\treturn copyValue(val, []byte(attr.Value))\n+\tcopyValue(val, []byte(attr.Value))\n+\treturn nil\n }\n \n var ("}, {"sha": "f43a5e7eebc83cd9f6592b7ac5a9f7017bcfb9d4", "filename": "libgo/go/encoding/xml/xml_test.go", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea250f561291c184423c4372041c067f5233fa5c/libgo%2Fgo%2Fencoding%2Fxml%2Fxml_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea250f561291c184423c4372041c067f5233fa5c/libgo%2Fgo%2Fencoding%2Fxml%2Fxml_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fxml_test.go?ref=ea250f561291c184423c4372041c067f5233fa5c", "patch": "@@ -797,3 +797,37 @@ func TestIssue12417(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestIssue19333(t *testing.T) {\n+\ttype X struct {\n+\t\tXMLName Name `xml:\"X\"`\n+\t\tA       int  `xml:\",attr\"`\n+\t\tC       int\n+\t}\n+\n+\tvar tests = []struct {\n+\t\tinput string\n+\t\tok    bool\n+\t}{\n+\t\t{`<X></X>`, true},\n+\t\t{`<X A=\"\"></X>`, true},\n+\t\t{`<X A=\"bad\"></X>`, true},\n+\t\t{`<X></X>`, true},\n+\t\t{`<X><C></C></X>`, false},\n+\t\t{`<X><C/></X>`, false},\n+\t\t{`<X><C>bad</C></X>`, false},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\terr := Unmarshal([]byte(tt.input), new(X))\n+\t\tif tt.ok {\n+\t\t\tif err != nil {\n+\t\t\t\tt.Errorf(\"%s: unexpected error: %v\", tt.input, err)\n+\t\t\t}\n+\t\t} else {\n+\t\t\tif err == nil {\n+\t\t\t\tt.Errorf(\"%s: unexpected success\", tt.input)\n+\t\t\t}\n+\t\t}\n+\t}\n+}"}, {"sha": "8299df56735df09e27669143245bd9a365c3e67a", "filename": "libgo/go/image/png/reader.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea250f561291c184423c4372041c067f5233fa5c/libgo%2Fgo%2Fimage%2Fpng%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea250f561291c184423c4372041c067f5233fa5c/libgo%2Fgo%2Fimage%2Fpng%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Freader.go?ref=ea250f561291c184423c4372041c067f5233fa5c", "patch": "@@ -612,6 +612,11 @@ func (d *decoder) readImagePass(r io.Reader, pass int, allocateOnly bool) (image\n \t\t\t\t}\n \t\t\t}\n \t\tcase cbG8:\n+\t\t\tif d.useTransparent {\n+\t\t\t\t// Match error from Go 1.7 and earlier.\n+\t\t\t\t// Go 1.9 will decode this properly.\n+\t\t\t\treturn nil, chunkOrderError\n+\t\t\t}\n \t\t\tcopy(gray.Pix[pixOffset:], cdat)\n \t\t\tpixOffset += gray.Stride\n \t\tcase cbGA8:"}, {"sha": "503b5dc567b27df9d58385464feb726bd2d2bb35", "filename": "libgo/go/image/png/reader_test.go", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea250f561291c184423c4372041c067f5233fa5c/libgo%2Fgo%2Fimage%2Fpng%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea250f561291c184423c4372041c067f5233fa5c/libgo%2Fgo%2Fimage%2Fpng%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Freader_test.go?ref=ea250f561291c184423c4372041c067f5233fa5c", "patch": "@@ -629,3 +629,13 @@ func BenchmarkDecodeRGB(b *testing.B) {\n func BenchmarkDecodeInterlacing(b *testing.B) {\n \tbenchmarkDecode(b, \"testdata/benchRGB-interlace.png\", 4)\n }\n+\n+func TestIssue19553(t *testing.T) {\n+\tvar buf = []byte{\n+\t\t0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x0b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x85, 0x2c, 0x88, 0x80, 0x00, 0x00, 0x00, 0x02, 0x74, 0x52, 0x4e, 0x53, 0x00, 0xff, 0x5b, 0x91, 0x22, 0xb5, 0x00, 0x00, 0x00, 0x02, 0x62, 0x4b, 0x47, 0x44, 0x00, 0xff, 0x87, 0x8f, 0xcc, 0xbf, 0x00, 0x00, 0x00, 0x09, 0x70, 0x48, 0x59, 0x73, 0x00, 0x00, 0x0a, 0xf0, 0x00, 0x00, 0x0a, 0xf0, 0x01, 0x42, 0xac, 0x34, 0x98, 0x00, 0x00, 0x00, 0x07, 0x74, 0x49, 0x4d, 0x45, 0x07, 0xd5, 0x04, 0x02, 0x12, 0x11, 0x11, 0xf7, 0x65, 0x3d, 0x8b, 0x00, 0x00, 0x00, 0x4f, 0x49, 0x44, 0x41, 0x54, 0x08, 0xd7, 0x63, 0xf8, 0xff, 0xff, 0xff, 0xb9, 0xbd, 0x70, 0xf0, 0x8c, 0x01, 0xc8, 0xaf, 0x6e, 0x99, 0x02, 0x05, 0xd9, 0x7b, 0xc1, 0xfc, 0x6b, 0xff, 0xa1, 0xa0, 0x87, 0x30, 0xff, 0xd9, 0xde, 0xbd, 0xd5, 0x4b, 0xf7, 0xee, 0xfd, 0x0e, 0xe3, 0xef, 0xcd, 0x06, 0x19, 0x14, 0xf5, 0x1e, 0xce, 0xef, 0x01, 0x31, 0x92, 0xd7, 0x82, 0x41, 0x31, 0x9c, 0x3f, 0x07, 0x02, 0xee, 0xa1, 0xaa, 0xff, 0xff, 0x9f, 0xe1, 0xd9, 0x56, 0x30, 0xf8, 0x0e, 0xe5, 0x03, 0x00, 0xa9, 0x42, 0x84, 0x3d, 0xdf, 0x8f, 0xa6, 0x8f, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82,\n+\t}\n+\t_, err := Decode(bytes.NewReader(buf))\n+\tif err != chunkOrderError {\n+\t\tt.Errorf(\"Decode: expected chunkOrderError for transparent gray8, got %v\", err)\n+\t}\n+}"}, {"sha": "71a692b367e239d8771e7f5a655281c8d3472263", "filename": "libgo/go/internal/testenv/testenv.go", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea250f561291c184423c4372041c067f5233fa5c/libgo%2Fgo%2Finternal%2Ftestenv%2Ftestenv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea250f561291c184423c4372041c067f5233fa5c/libgo%2Fgo%2Finternal%2Ftestenv%2Ftestenv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Ftestenv%2Ftestenv.go?ref=ea250f561291c184423c4372041c067f5233fa5c", "patch": "@@ -141,6 +141,15 @@ func MustHaveExternalNetwork(t *testing.T) {\n \t}\n }\n \n+var haveCGO bool\n+\n+// MustHaveCGO calls t.Skip if cgo is not available.\n+func MustHaveCGO(t *testing.T) {\n+\tif !haveCGO {\n+\t\tt.Skipf(\"skipping test: no cgo\")\n+\t}\n+}\n+\n // HasSymlink reports whether the current system can use os.Symlink.\n func HasSymlink() bool {\n \tok, _ := hasSymlink()"}, {"sha": "e3d4d16b33e5fc152fb12c9bee41aa563b05da3e", "filename": "libgo/go/internal/testenv/testenv_cgo.go", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea250f561291c184423c4372041c067f5233fa5c/libgo%2Fgo%2Finternal%2Ftestenv%2Ftestenv_cgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea250f561291c184423c4372041c067f5233fa5c/libgo%2Fgo%2Finternal%2Ftestenv%2Ftestenv_cgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Ftestenv%2Ftestenv_cgo.go?ref=ea250f561291c184423c4372041c067f5233fa5c", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build cgo\n+\n+package testenv\n+\n+func init() {\n+\thaveCGO = true\n+}"}, {"sha": "b95ca89f4094c5f04445c83ad5c3d9069cc777f9", "filename": "libgo/go/net/http/http.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea250f561291c184423c4372041c067f5233fa5c/libgo%2Fgo%2Fnet%2Fhttp%2Fhttp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea250f561291c184423c4372041c067f5233fa5c/libgo%2Fgo%2Fnet%2Fhttp%2Fhttp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fhttp.go?ref=ea250f561291c184423c4372041c067f5233fa5c", "patch": "@@ -20,7 +20,7 @@ const maxInt64 = 1<<63 - 1\n \n // aLongTimeAgo is a non-zero time, far in the past, used for\n // immediate cancelation of network operations.\n-var aLongTimeAgo = time.Unix(233431200, 0)\n+var aLongTimeAgo = time.Unix(1, 0)\n \n // TODO(bradfitz): move common stuff here. The other files have accumulated\n // generic http stuff in random places."}, {"sha": "a8b57361e6c6b65b956be90b9b32af97b2c213bd", "filename": "libgo/go/net/net.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea250f561291c184423c4372041c067f5233fa5c/libgo%2Fgo%2Fnet%2Fnet.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea250f561291c184423c4372041c067f5233fa5c/libgo%2Fgo%2Fnet%2Fnet.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fnet.go?ref=ea250f561291c184423c4372041c067f5233fa5c", "patch": "@@ -468,7 +468,7 @@ func (e *OpError) Error() string {\n var (\n \t// aLongTimeAgo is a non-zero time, far in the past, used for\n \t// immediate cancelation of dials.\n-\taLongTimeAgo = time.Unix(233431200, 0)\n+\taLongTimeAgo = time.Unix(1, 0)\n \n \t// nonDeadline and noCancel are just zero values for\n \t// readability with functions taking too many parameters."}, {"sha": "f13635138a1bef98f786a3aff3444dfca8037174", "filename": "libgo/go/os/exec/exec_test.go", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea250f561291c184423c4372041c067f5233fa5c/libgo%2Fgo%2Fos%2Fexec%2Fexec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea250f561291c184423c4372041c067f5233fa5c/libgo%2Fgo%2Fos%2Fexec%2Fexec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec%2Fexec_test.go?ref=ea250f561291c184423c4372041c067f5233fa5c", "patch": "@@ -266,9 +266,13 @@ func TestStdinCloseRace(t *testing.T) {\n \t\tt.Fatalf(\"Start: %v\", err)\n \t}\n \tgo func() {\n-\t\tif err := cmd.Process.Kill(); err != nil {\n-\t\t\tt.Errorf(\"Kill: %v\", err)\n-\t\t}\n+\t\t// We don't check the error return of Kill. It is\n+\t\t// possible that the process has already exited, in\n+\t\t// which case Kill will return an error \"process\n+\t\t// already finished\". The purpose of this test is to\n+\t\t// see whether the race detector reports an error; it\n+\t\t// doesn't matter whether this Kill succeeds or not.\n+\t\tcmd.Process.Kill()\n \t}()\n \tgo func() {\n \t\t// Send the wrong string, so that the child fails even"}, {"sha": "3686167ed42cff52e1104337f8010b0db919f069", "filename": "libgo/go/reflect/all_test.go", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea250f561291c184423c4372041c067f5233fa5c/libgo%2Fgo%2Freflect%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea250f561291c184423c4372041c067f5233fa5c/libgo%2Fgo%2Freflect%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fall_test.go?ref=ea250f561291c184423c4372041c067f5233fa5c", "patch": "@@ -1681,6 +1681,11 @@ func (p Point) GCMethod(k int) int {\n }\n \n // This will be index 3.\n+func (p Point) NoArgs() {\n+\t// Exercise no-argument/no-result paths.\n+}\n+\n+// This will be index 4.\n func (p Point) TotalDist(points ...Point) int {\n \ttot := 0\n \tfor _, q := range points {\n@@ -1709,6 +1714,15 @@ func TestMethod(t *testing.T) {\n \t\tt.Errorf(\"Type MethodByName returned %d; want 275\", i)\n \t}\n \n+\tm, ok = TypeOf(p).MethodByName(\"NoArgs\")\n+\tif !ok {\n+\t\tt.Fatalf(\"method by name failed\")\n+\t}\n+\tn := len(m.Func.Call([]Value{ValueOf(p)}))\n+\tif n != 0 {\n+\t\tt.Errorf(\"NoArgs returned %d values; want 0\", n)\n+\t}\n+\n \ti = TypeOf(&p).Method(1).Func.Call([]Value{ValueOf(&p), ValueOf(12)})[0].Int()\n \tif i != 300 {\n \t\tt.Errorf(\"Pointer Type Method returned %d; want 300\", i)\n@@ -1723,6 +1737,15 @@ func TestMethod(t *testing.T) {\n \t\tt.Errorf(\"Pointer Type MethodByName returned %d; want 325\", i)\n \t}\n \n+\tm, ok = TypeOf(&p).MethodByName(\"NoArgs\")\n+\tif !ok {\n+\t\tt.Fatalf(\"method by name failed\")\n+\t}\n+\tn = len(m.Func.Call([]Value{ValueOf(&p)}))\n+\tif n != 0 {\n+\t\tt.Errorf(\"NoArgs returned %d values; want 0\", n)\n+\t}\n+\n \t// Curried method of value.\n \ttfunc := TypeOf((func(int) int)(nil))\n \tv := ValueOf(p).Method(1)\n@@ -1741,6 +1764,8 @@ func TestMethod(t *testing.T) {\n \tif i != 375 {\n \t\tt.Errorf(\"Value MethodByName returned %d; want 375\", i)\n \t}\n+\tv = ValueOf(p).MethodByName(\"NoArgs\")\n+\tv.Call(nil)\n \n \t// Curried method of pointer.\n \tv = ValueOf(&p).Method(1)\n@@ -1759,6 +1784,8 @@ func TestMethod(t *testing.T) {\n \tif i != 425 {\n \t\tt.Errorf(\"Pointer Value MethodByName returned %d; want 425\", i)\n \t}\n+\tv = ValueOf(&p).MethodByName(\"NoArgs\")\n+\tv.Call(nil)\n \n \t// Curried method of interface value.\n \t// Have to wrap interface value in a struct to get at it.\n@@ -1808,6 +1835,9 @@ func TestMethodValue(t *testing.T) {\n \tif i != 275 {\n \t\tt.Errorf(\"Value MethodByName returned %d; want 275\", i)\n \t}\n+\tv = ValueOf(p).MethodByName(\"NoArgs\")\n+\tValueOf(v.Interface()).Call(nil)\n+\tv.Interface().(func())()\n \n \t// Curried method of pointer.\n \tv = ValueOf(&p).Method(1)\n@@ -1826,6 +1856,9 @@ func TestMethodValue(t *testing.T) {\n \tif i != 325 {\n \t\tt.Errorf(\"Pointer Value MethodByName returned %d; want 325\", i)\n \t}\n+\tv = ValueOf(&p).MethodByName(\"NoArgs\")\n+\tValueOf(v.Interface()).Call(nil)\n+\tv.Interface().(func())()\n \n \t// Curried method of pointer to pointer.\n \tpp := &p\n@@ -1881,7 +1914,7 @@ func TestVariadicMethodValue(t *testing.T) {\n \n \t// Curried method of value.\n \ttfunc := TypeOf((func(...Point) int)(nil))\n-\tv := ValueOf(p).Method(3)\n+\tv := ValueOf(p).Method(4)\n \tif tt := v.Type(); tt != tfunc {\n \t\tt.Errorf(\"Variadic Method Type is %s; want %s\", tt, tfunc)\n \t}"}, {"sha": "182c84b6392c661534049b574ccb7efa4487197f", "filename": "libgo/go/runtime/crash_unix_test.go", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea250f561291c184423c4372041c067f5233fa5c/libgo%2Fgo%2Fruntime%2Fcrash_unix_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea250f561291c184423c4372041c067f5233fa5c/libgo%2Fgo%2Fruntime%2Fcrash_unix_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fcrash_unix_test.go?ref=ea250f561291c184423c4372041c067f5233fa5c", "patch": "@@ -9,6 +9,7 @@ package runtime_test\n import (\n \t\"bytes\"\n \t\"internal/testenv\"\n+\t\"io\"\n \t\"io/ioutil\"\n \t\"os\"\n \t\"os/exec\"\n@@ -153,6 +154,78 @@ func loop(i int, c chan bool) {\n }\n `\n \n+func TestPanicSystemstack(t *testing.T) {\n+\t// Test that GOTRACEBACK=crash prints both the system and user\n+\t// stack of other threads.\n+\n+\t// The GOTRACEBACK=crash handler takes 0.1 seconds even if\n+\t// it's not writing a core file and potentially much longer if\n+\t// it is. Skip in short mode.\n+\tif testing.Short() {\n+\t\tt.Skip(\"Skipping in short mode (GOTRACEBACK=crash is slow)\")\n+\t}\n+\n+\tt.Parallel()\n+\tcmd := exec.Command(os.Args[0], \"testPanicSystemstackInternal\")\n+\tcmd = testEnv(cmd)\n+\tcmd.Env = append(cmd.Env, \"GOTRACEBACK=crash\")\n+\tpr, pw, err := os.Pipe()\n+\tif err != nil {\n+\t\tt.Fatal(\"creating pipe: \", err)\n+\t}\n+\tcmd.Stderr = pw\n+\tif err := cmd.Start(); err != nil {\n+\t\tt.Fatal(\"starting command: \", err)\n+\t}\n+\tdefer cmd.Process.Wait()\n+\tdefer cmd.Process.Kill()\n+\tif err := pw.Close(); err != nil {\n+\t\tt.Log(\"closing write pipe: \", err)\n+\t}\n+\tdefer pr.Close()\n+\n+\t// Wait for \"x\\nx\\n\" to indicate readiness.\n+\tbuf := make([]byte, 4)\n+\t_, err = io.ReadFull(pr, buf)\n+\tif err != nil || string(buf) != \"x\\nx\\n\" {\n+\t\tt.Fatal(\"subprocess failed; output:\\n\", string(buf))\n+\t}\n+\n+\t// Send SIGQUIT.\n+\tif err := cmd.Process.Signal(syscall.SIGQUIT); err != nil {\n+\t\tt.Fatal(\"signaling subprocess: \", err)\n+\t}\n+\n+\t// Get traceback.\n+\ttb, err := ioutil.ReadAll(pr)\n+\tif err != nil {\n+\t\tt.Fatal(\"reading traceback from pipe: \", err)\n+\t}\n+\n+\t// Traceback should have two testPanicSystemstackInternal's\n+\t// and two blockOnSystemStackInternal's.\n+\tif bytes.Count(tb, []byte(\"testPanicSystemstackInternal\")) != 2 {\n+\t\tt.Fatal(\"traceback missing user stack:\\n\", string(tb))\n+\t} else if bytes.Count(tb, []byte(\"blockOnSystemStackInternal\")) != 2 {\n+\t\tt.Fatal(\"traceback missing system stack:\\n\", string(tb))\n+\t}\n+}\n+\n+func init() {\n+\tif len(os.Args) >= 2 && os.Args[1] == \"testPanicSystemstackInternal\" {\n+\t\t// Get two threads running on the system stack with\n+\t\t// something recognizable in the stack trace.\n+\t\truntime.GOMAXPROCS(2)\n+\t\tgo testPanicSystemstackInternal()\n+\t\ttestPanicSystemstackInternal()\n+\t}\n+}\n+\n+func testPanicSystemstackInternal() {\n+\truntime.BlockOnSystemStack()\n+\tos.Exit(1) // Should be unreachable.\n+}\n+\n func TestSignalExitStatus(t *testing.T) {\n \ttestenv.MustHaveGoBuild(t)\n \texe, err := buildTestProg(t, \"testprog\")"}, {"sha": "cc4b188b60c0a4502f9162b943a992b96e160fef", "filename": "libgo/go/runtime/export_test.go", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea250f561291c184423c4372041c067f5233fa5c/libgo%2Fgo%2Fruntime%2Fexport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea250f561291c184423c4372041c067f5233fa5c/libgo%2Fgo%2Fruntime%2Fexport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fexport_test.go?ref=ea250f561291c184423c4372041c067f5233fa5c", "patch": "@@ -243,3 +243,16 @@ func CountPagesInUse() (pagesInUse, counted uintptr) {\n \treturn\n }\n */\n+\n+// BlockOnSystemStack switches to the system stack, prints \"x\\n\" to\n+// stderr, and blocks in a stack containing\n+// \"runtime.blockOnSystemStackInternal\".\n+func BlockOnSystemStack() {\n+\tsystemstack(blockOnSystemStackInternal)\n+}\n+\n+func blockOnSystemStackInternal() {\n+\tprint(\"x\\n\")\n+\tlock(&deadlock)\n+\tlock(&deadlock)\n+}"}, {"sha": "99c0f11930fdfcca231099a61a5d7fc339c06798", "filename": "libgo/go/runtime/runtime1.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea250f561291c184423c4372041c067f5233fa5c/libgo%2Fgo%2Fruntime%2Fruntime1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea250f561291c184423c4372041c067f5233fa5c/libgo%2Fgo%2Fruntime%2Fruntime1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fruntime1.go?ref=ea250f561291c184423c4372041c067f5233fa5c", "patch": "@@ -280,6 +280,12 @@ func check() {\n \t\tthrow(\"atomicor8\")\n \t}\n \n+\tm = [4]byte{0xff, 0xff, 0xff, 0xff}\n+\tatomic.And8(&m[1], 0x1)\n+\tif m[0] != 0xff || m[1] != 0x1 || m[2] != 0xff || m[3] != 0xff {\n+\t\tthrow(\"atomicand8\")\n+\t}\n+\n \t*(*uint64)(unsafe.Pointer(&j)) = ^uint64(0)\n \tif j == j {\n \t\tthrow(\"float64nan\")"}, {"sha": "37318ff9d55cd387a6617532e89c9a8eb6c87337", "filename": "libgo/go/runtime/sema.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea250f561291c184423c4372041c067f5233fa5c/libgo%2Fgo%2Fruntime%2Fsema.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea250f561291c184423c4372041c067f5233fa5c/libgo%2Fgo%2Fruntime%2Fsema.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsema.go?ref=ea250f561291c184423c4372041c067f5233fa5c", "patch": "@@ -171,6 +171,7 @@ func semrelease(addr *uint32) {\n \t\t\tfor x := root.head; x != nil; x = x.next {\n \t\t\t\tif x.elem == unsafe.Pointer(addr) {\n \t\t\t\t\tx.acquiretime = t0\n+\t\t\t\t\tbreak\n \t\t\t\t}\n \t\t\t}\n \t\t\tmutexevent(t0-s.acquiretime, 3)"}, {"sha": "5d8c08f06f1ceaf92586c61b3a544163dddd05c4", "filename": "libgo/go/text/template/multi_test.go", "status": "modified", "additions": 35, "deletions": 2, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea250f561291c184423c4372041c067f5233fa5c/libgo%2Fgo%2Ftext%2Ftemplate%2Fmulti_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea250f561291c184423c4372041c067f5233fa5c/libgo%2Fgo%2Ftext%2Ftemplate%2Fmulti_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fmulti_test.go?ref=ea250f561291c184423c4372041c067f5233fa5c", "patch": "@@ -363,7 +363,7 @@ func TestEmptyTemplate(t *testing.T) {\n \t\t{[]string{\"{{.}}\", \"\"}, \"twice\", \"\"},\n \t}\n \n-\tfor _, c := range cases {\n+\tfor i, c := range cases {\n \t\troot := New(\"root\")\n \n \t\tvar (\n@@ -378,10 +378,43 @@ func TestEmptyTemplate(t *testing.T) {\n \t\t}\n \t\tbuf := &bytes.Buffer{}\n \t\tif err := m.Execute(buf, c.in); err != nil {\n-\t\t\tt.Fatal(err)\n+\t\t\tt.Error(i, err)\n+\t\t\tcontinue\n \t\t}\n \t\tif buf.String() != c.want {\n \t\t\tt.Errorf(\"expected string %q: got %q\", c.want, buf.String())\n \t\t}\n \t}\n }\n+\n+// Issue 19249 was a regression in 1.8 caused by the handling of empty\n+// templates added in that release, which got different answers depending\n+// on the order templates appeared in the internal map.\n+func TestIssue19294(t *testing.T) {\n+\t// The empty block in \"xhtml\" should be replaced during execution\n+\t// by the contents of \"stylesheet\", but if the internal map associating\n+\t// names with templates is built in the wrong order, the empty block\n+\t// looks non-empty and this doesn't happen.\n+\tvar inlined = map[string]string{\n+\t\t\"stylesheet\": `{{define \"stylesheet\"}}stylesheet{{end}}`,\n+\t\t\"xhtml\":      `{{block \"stylesheet\" .}}{{end}}`,\n+\t}\n+\tall := []string{\"stylesheet\", \"xhtml\"}\n+\tfor i := 0; i < 100; i++ {\n+\t\tres, err := New(\"title.xhtml\").Parse(`{{template \"xhtml\" .}}`)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\tfor _, name := range all {\n+\t\t\t_, err := res.New(name).Parse(inlined[name])\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t}\n+\t\tvar buf bytes.Buffer\n+\t\tres.Execute(&buf, 0)\n+\t\tif buf.String() != \"stylesheet\" {\n+\t\t\tt.Fatalf(\"iteration %d: got %q; expected %q\", i, buf.String(), \"stylesheet\")\n+\t\t}\n+\t}\n+}"}, {"sha": "3b4f34b4db0efe37febe0c637d4a2a8f06124562", "filename": "libgo/go/text/template/template.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea250f561291c184423c4372041c067f5233fa5c/libgo%2Fgo%2Ftext%2Ftemplate%2Ftemplate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea250f561291c184423c4372041c067f5233fa5c/libgo%2Fgo%2Ftext%2Ftemplate%2Ftemplate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Ftemplate.go?ref=ea250f561291c184423c4372041c067f5233fa5c", "patch": "@@ -127,7 +127,7 @@ func (t *Template) AddParseTree(name string, tree *parse.Tree) (*Template, error\n \t// Even if nt == t, we need to install it in the common.tmpl map.\n \tif replace, err := t.associate(nt, tree); err != nil {\n \t\treturn nil, err\n-\t} else if replace {\n+\t} else if replace || nt.Tree == nil {\n \t\tnt.Tree = tree\n \t}\n \treturn nt, nil\n@@ -215,7 +215,7 @@ func (t *Template) associate(new *Template, tree *parse.Tree) (bool, error) {\n \tif new.common != t.common {\n \t\tpanic(\"internal error: associate not common\")\n \t}\n-\tif t.tmpl[new.name] != nil && parse.IsEmptyTree(tree.Root) && t.Tree != nil {\n+\tif old := t.tmpl[new.name]; old != nil && parse.IsEmptyTree(tree.Root) && old.Tree != nil {\n \t\t// If a template by that name exists,\n \t\t// don't replace it with an empty template.\n \t\treturn false, nil"}]}