{"sha": "328aa7876732da9bbf851f7b9309b1f6fda1cd9d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzI4YWE3ODc2NzMyZGE5YmJmODUxZjdiOTMwOWIxZjZmZGExY2Q5ZA==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2018-07-26T10:16:48Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2018-07-26T10:16:48Z"}, "message": "combine: Another hard register problem (PR85805)\n\nThe current code in reg_nonzero_bits_for_combine allows using the\nreg_stat info when last_set_mode is a different integer mode.  This is\ncompletely wrong for non-pseudos.  For example, as in the PR, a value\nin a DImode hard register is set by eight writes to its constituent\nQImode parts.  The value written to the DImode is not the same as that\nwritten to the lowest-numbered QImode!\n\n\n\tPR rtl-optimization/85805\n\t* combine.c (reg_nonzero_bits_for_combine): Only use the last set\n\tvalue for hard registers if that was written in the same mode.\n\nFrom-SVN: r262994", "tree": {"sha": "c7dcf974de0227370ede0f4f56a783a580a95da1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c7dcf974de0227370ede0f4f56a783a580a95da1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/328aa7876732da9bbf851f7b9309b1f6fda1cd9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/328aa7876732da9bbf851f7b9309b1f6fda1cd9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/328aa7876732da9bbf851f7b9309b1f6fda1cd9d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/328aa7876732da9bbf851f7b9309b1f6fda1cd9d/comments", "author": null, "committer": null, "parents": [{"sha": "977667e6b74a56db3747caaed8ba776f6cae8cdf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/977667e6b74a56db3747caaed8ba776f6cae8cdf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/977667e6b74a56db3747caaed8ba776f6cae8cdf"}], "stats": {"total": 13, "additions": 10, "deletions": 3}, "files": [{"sha": "3518ecfc376b8927f5ab84ea56c9527403df33e1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/328aa7876732da9bbf851f7b9309b1f6fda1cd9d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/328aa7876732da9bbf851f7b9309b1f6fda1cd9d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=328aa7876732da9bbf851f7b9309b1f6fda1cd9d", "patch": "@@ -1,8 +1,14 @@\n+2018-07-26  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\tPR rtl-optimization/85805\n+\t* combine.c (reg_nonzero_bits_for_combine): Only use the last set\n+\tvalue for hard registers if that was written in the same mode.\n+\n 2018-07-26  Martin Liska  <mliska@suse.cz>\n \n-        PR gcov-profile/86536\n+\tPR gcov-profile/86536\n \t* gcov.c (format_gcov): Use printf format %.*f directly\n-        and do not handle special values.\n+\tand do not handle special values.\n \n 2018-07-25  Claudiu Zissulescu  <claziss@synopsys.com>\n "}, {"sha": "8f6db4ff95be5f1d7967a9ebba6e809b903cff6c", "filename": "gcc/combine.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/328aa7876732da9bbf851f7b9309b1f6fda1cd9d/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/328aa7876732da9bbf851f7b9309b1f6fda1cd9d/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=328aa7876732da9bbf851f7b9309b1f6fda1cd9d", "patch": "@@ -10169,7 +10169,8 @@ reg_nonzero_bits_for_combine (const_rtx x, scalar_int_mode xmode,\n   rsp = &reg_stat[REGNO (x)];\n   if (rsp->last_set_value != 0\n       && (rsp->last_set_mode == mode\n-\t  || (GET_MODE_CLASS (rsp->last_set_mode) == MODE_INT\n+\t  || (REGNO (x) >= FIRST_PSEUDO_REGISTER\n+\t      && GET_MODE_CLASS (rsp->last_set_mode) == MODE_INT\n \t      && GET_MODE_CLASS (mode) == MODE_INT))\n       && ((rsp->last_set_label >= label_tick_ebb_start\n \t   && rsp->last_set_label < label_tick)"}]}