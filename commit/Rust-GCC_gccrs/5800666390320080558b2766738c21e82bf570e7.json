{"sha": "5800666390320080558b2766738c21e82bf570e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTgwMDY2NjM5MDMyMDA4MDU1OGIyNzY2NzM4YzIxZTgyYmY1NzBlNw==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2018-02-09T02:22:11Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2018-02-09T02:22:11Z"}, "message": "[IEPM] Introduce inline entry point markers\n\nOutput DW_AT_entry_pc based on markers.\n\nIntroduce DW_AT_GNU_entry_view as a DWARF extension.\n\nIf views are enabled are we're not in strict compliance mode, output\nDW_AT_GNU_entry_view if it might be nonzero.\n\nThis patch depends on SFN and LVU patchsets, and on the IEPM patch that\nintroduces the inline_entry debug hook.\n\nfor  include/ChangeLog\n\n\t* dwarf2.def (DW_AT_GNU_entry_view): New.\n\nfor  gcc/ChangeLog\n\n\t* cfgexpand.c (expand_gimple_basic_block): Handle inline entry\n\tmarkers.\n\t* dwarf2out.c (dwarf2_debug_hooks): Enable inline_entry hook.\n\t(BLOCK_INLINE_ENTRY_LABEL): New.\n\t(dwarf2out_var_location): Disregard inline entry markers.\n\t(inline_entry_data): New struct.\n\t(inline_entry_data_hasher): New hashtable type.\n\t(inline_entry_data_hasher::hash): New.\n\t(inline_entry_data_hasher::equal): New.\n\t(inline_entry_data_table): New variable.\n\t(add_high_low_attributes): Add DW_AT_entry_pc and\n\tDW_AT_GNU_entry_view attributes if a pending entry is found\n\tin inline_entry_data_table.  Add old entry_pc attribute only\n\tif debug nonbinding markers are disabled.\n\t(gen_inlined_subroutine_die): Set BLOCK_DIE if nonbinding\n\tmarkers are enabled.\n\t(block_within_block_p, dwarf2out_inline_entry): New.\n\t(dwarf2out_finish): Check that no entries remained in\n\tinline_entry_data_table.\n\t* final.c (reemit_insn_block_notes): Handle inline entry notes.\n\t(final_scan_insn, notice_source_line): Likewise.\n\t(rest_of_clean_state): Skip inline entry markers.\n\t* gimple-pretty-print.c (dump_gimple_debug): Handle inline entry\n\tmarkers.\n\t* gimple.c (gimple_build_debug_inline_entry): New.\n\t* gimple.h (enum gimple_debug_subcode): Add\n\tGIMPLE_DEBUG_INLINE_ENTRY.\n\t(gimple_build_debug_inline_entry): Declare.\n\t(gimple_debug_inline_entry_p): New.\n\t(gimple_debug_nonbind_marker_p): Adjust.\n\t* insn-notes.def (INLINE_ENTRY): New.\n\t* print-rtl.c (rtx_writer::print_rtx_operand_code_0): Handle\n\tinline entry marker notes.\n\t(print_insn): Likewise.\n\t* rtl.h\t(NOTE_MARKER_P): Add INLINE_ENTRY support.\n\t(INSN_DEBUG_MARKER_KIND): Likewise.\n\t(GEN_RTX_DEBUG_MARKER_INLINE_ENTRY_PAT): New.\n\t* tree-inline.c\t(expand_call_inline): Build and insert\n\tdebug_inline_entry stmt.\n\t* tree-ssa-live.c (remove_unused_scope_block_p): Preserve\n\tinline entry blocks early, if nonbind markers are enabled.\n\t(dump_scope_block): Dump fragment info.\n\t* var-tracking.c (reemit_marker_as_note): Handle inline entry note.\n\t* doc/gimple.texi (gimple_debug_inline_entry_p): New.\n\t(gimple_build_debug_inline_entry): New.\n\t* doc/invoke.texi (gstatement-frontiers, gno-statement-frontiers):\n\tEnable/disable inline entry points too.\n\t* doc/rtl.texi (NOTE_INSN_INLINE_ENTRY): New.\n\t(DEBUG_INSN): Describe inline entry markers.\n\nFrom-SVN: r257511", "tree": {"sha": "6441c003a666182d94e15a68381e38066683fc83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6441c003a666182d94e15a68381e38066683fc83"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5800666390320080558b2766738c21e82bf570e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5800666390320080558b2766738c21e82bf570e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5800666390320080558b2766738c21e82bf570e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5800666390320080558b2766738c21e82bf570e7/comments", "author": null, "committer": null, "parents": [{"sha": "bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3"}], "stats": {"total": 432, "additions": 416, "deletions": 16}, "files": [{"sha": "b5e19ed8f5bbf1d4ad86a723e5ba95c3cae186c9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5800666390320080558b2766738c21e82bf570e7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5800666390320080558b2766738c21e82bf570e7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5800666390320080558b2766738c21e82bf570e7", "patch": "@@ -1,5 +1,55 @@\n 2018-02-09  Alexandre Oliva <aoliva@redhat.com>\n \n+\t* cfgexpand.c (expand_gimple_basic_block): Handle inline entry\n+\tmarkers.\n+\t* dwarf2out.c (dwarf2_debug_hooks): Enable inline_entry hook.\n+\t(BLOCK_INLINE_ENTRY_LABEL): New.\n+\t(dwarf2out_var_location): Disregard inline entry markers.\n+\t(inline_entry_data): New struct.\n+\t(inline_entry_data_hasher): New hashtable type.\n+\t(inline_entry_data_hasher::hash): New.\n+\t(inline_entry_data_hasher::equal): New.\n+\t(inline_entry_data_table): New variable.\n+\t(add_high_low_attributes): Add DW_AT_entry_pc and\n+\tDW_AT_GNU_entry_view attributes if a pending entry is found\n+\tin inline_entry_data_table.  Add old entry_pc attribute only\n+\tif debug nonbinding markers are disabled.\n+\t(gen_inlined_subroutine_die): Set BLOCK_DIE if nonbinding\n+\tmarkers are enabled.\n+\t(block_within_block_p, dwarf2out_inline_entry): New.\n+\t(dwarf2out_finish): Check that no entries remained in\n+\tinline_entry_data_table.\n+\t* final.c (reemit_insn_block_notes): Handle inline entry notes.\n+\t(final_scan_insn, notice_source_line): Likewise.\n+\t(rest_of_clean_state): Skip inline entry markers.\n+\t* gimple-pretty-print.c (dump_gimple_debug): Handle inline entry\n+\tmarkers.\n+\t* gimple.c (gimple_build_debug_inline_entry): New.\n+\t* gimple.h (enum gimple_debug_subcode): Add\n+\tGIMPLE_DEBUG_INLINE_ENTRY.\n+\t(gimple_build_debug_inline_entry): Declare.\n+\t(gimple_debug_inline_entry_p): New.\n+\t(gimple_debug_nonbind_marker_p): Adjust.\n+\t* insn-notes.def (INLINE_ENTRY): New.\n+\t* print-rtl.c (rtx_writer::print_rtx_operand_code_0): Handle\n+\tinline entry marker notes.\n+\t(print_insn): Likewise.\n+\t* rtl.h\t(NOTE_MARKER_P): Add INLINE_ENTRY support.\n+\t(INSN_DEBUG_MARKER_KIND): Likewise.\n+\t(GEN_RTX_DEBUG_MARKER_INLINE_ENTRY_PAT): New.\n+\t* tree-inline.c\t(expand_call_inline): Build and insert\n+\tdebug_inline_entry stmt.\n+\t* tree-ssa-live.c (remove_unused_scope_block_p): Preserve\n+\tinline entry blocks early, if nonbind markers are enabled.\n+\t(dump_scope_block): Dump fragment info.\n+\t* var-tracking.c (reemit_marker_as_note): Handle inline entry note.\n+\t* doc/gimple.texi (gimple_debug_inline_entry_p): New.\n+\t(gimple_build_debug_inline_entry): New.\n+\t* doc/invoke.texi (gstatement-frontiers, gno-statement-frontiers):\n+\tEnable/disable inline entry points too.\n+\t* doc/rtl.texi (NOTE_INSN_INLINE_ENTRY): New.\n+\t(DEBUG_INSN): Describe inline entry markers.\n+\n \t* common.opt (gvariable-location-views): New.\n \t(gvariable-location-views=incompat5): New.\n \t* config.in: Rebuilt."}, {"sha": "deab9296001aa1350c62c6543261015fcf123819", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5800666390320080558b2766738c21e82bf570e7/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5800666390320080558b2766738c21e82bf570e7/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=5800666390320080558b2766738c21e82bf570e7", "patch": "@@ -5731,6 +5731,15 @@ expand_gimple_basic_block (basic_block bb, bool disable_tail_calls)\n \t\tgoto delink_debug_stmt;\n \t      else if (gimple_debug_begin_stmt_p (stmt))\n \t\tval = GEN_RTX_DEBUG_MARKER_BEGIN_STMT_PAT ();\n+\t      else if (gimple_debug_inline_entry_p (stmt))\n+\t\t{\n+\t\t  tree block = gimple_block (stmt);\n+\n+\t\t  if (block)\n+\t\t    val = GEN_RTX_DEBUG_MARKER_INLINE_ENTRY_PAT ();\n+\t\t  else\n+\t\t    goto delink_debug_stmt;\n+\t\t}\n \t      else\n \t\tgcc_unreachable ();\n "}, {"sha": "1f9449f133bd65796a8ef0f25210ea30f2bd5b65", "filename": "gcc/doc/gimple.texi", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5800666390320080558b2766738c21e82bf570e7/gcc%2Fdoc%2Fgimple.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5800666390320080558b2766738c21e82bf570e7/gcc%2Fdoc%2Fgimple.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgimple.texi?ref=5800666390320080558b2766738c21e82bf570e7", "patch": "@@ -836,6 +836,11 @@ Return true if g is a @code{GIMPLE_DEBUG} that marks the beginning of\n a source statement.\n @end deftypefn\n \n+@deftypefn {GIMPLE function} gimple_debug_inline_entry_p (gimple g)\n+Return true if g is a @code{GIMPLE_DEBUG} that marks the entry\n+point of an inlined function.\n+@end deftypefn\n+\n @deftypefn {GIMPLE function} gimple_debug_nonbind_marker_p (gimple g)\n Return true if g is a @code{GIMPLE_DEBUG} that marks a program location,\n without any variable binding.\n@@ -1541,6 +1546,7 @@ Set the conditional @code{COND_STMT} to be of the form 'if (1 == 1)'.\n @cindex @code{GIMPLE_DEBUG}\n @cindex @code{GIMPLE_DEBUG_BIND}\n @cindex @code{GIMPLE_DEBUG_BEGIN_STMT}\n+@cindex @code{GIMPLE_DEBUG_INLINE_ENTRY}\n \n @deftypefn {GIMPLE function} gdebug *gimple_build_debug_bind (tree var, @\n tree value, gimple stmt)\n@@ -1626,6 +1632,18 @@ observable, and that none of the side effects of subsequent user\n statements are.\n @end deftypefn\n \n+@deftypefn {GIMPLE function} gimple gimple_build_debug_inline_entry (tree block, location_t location)\n+Build a @code{GIMPLE_DEBUG} statement with\n+@code{GIMPLE_DEBUG_INLINE_ENTRY} @code{subcode}.  The effect of this\n+statement is to tell debug information generation machinery that a\n+function call at @code{location} underwent inline substitution, that\n+@code{block} is the enclosing lexical block created for the\n+substitution, and that at the point of the program in which the stmt is\n+inserted, all parameters for the inlined function are bound to the\n+respective arguments, and none of the side effects of its stmts are\n+observable.\n+@end deftypefn\n+\n @node @code{GIMPLE_EH_FILTER}\n @subsection @code{GIMPLE_EH_FILTER}\n @cindex @code{GIMPLE_EH_FILTER}"}, {"sha": "43d5405ddb47e78983380845a2fdde9c3041efee", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5800666390320080558b2766738c21e82bf570e7/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5800666390320080558b2766738c21e82bf570e7/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=5800666390320080558b2766738c21e82bf570e7", "patch": "@@ -3670,7 +3670,10 @@ Refers to a parameter that was completely optimized out.\n @item (debug_marker:@var{mode})\n Marks a program location.  With @code{VOIDmode}, it stands for the\n beginning of a statement, a recommended inspection point logically after\n-all prior side effects, and before any subsequent side effects.\n+all prior side effects, and before any subsequent side effects.  With\n+@code{BLKmode}, it indicates an inline entry point: the lexical block\n+encoded in the @code{INSN_LOCATION} is the enclosing block that encloses\n+the inlined function.\n \n @end table\n \n@@ -3954,6 +3957,13 @@ This note is used to generate @code{is_stmt} markers in line number\n debuggign information.  It indicates the beginning of a user\n statement.\n \n+@findex NOTE_INSN_INLINE_ENTRY\n+@item NOTE_INSN_INLINE_ENTRY\n+This note is used to generate @code{entry_pc} for inlined subroutines in\n+debugging information.  It indicates an inspection point at which all\n+arguments for the inlined function have been bound, and before its first\n+statement.\n+\n @end table\n \n These codes are printed symbolically when they appear in debugging dumps.\n@@ -3971,8 +3981,12 @@ binds a user variable tree to an RTL representation of the\n it stands for the value bound to the corresponding\n @code{DEBUG_EXPR_DECL}.\n \n-@code{GIMPLE_DEBUG_BEGIN_STMT} is expanded to RTL as a @code{DEBUG_INSN}\n-with a @code{VOIDmode} @code{DEBUG_MARKER} @code{PATTERN}.  These\n+@code{GIMPLE_DEBUG_BEGIN_STMT} and @code{GIMPLE_DEBUG_INLINE_ENTRY} are\n+expanded to RTL as a @code{DEBUG_INSN} with a @code{DEBUG_MARKER}\n+@code{PATTERN}; the difference is the RTL mode: the former's\n+@code{DEBUG_MARKER} is @code{VOIDmode}, whereas the latter is\n+@code{BLKmode}; information about the inlined function can be taken from\n+the lexical block encoded in the @code{INSN_LOCATION}.  These\n @code{DEBUG_INSN}s, that do not carry @code{VAR_LOCATION} information,\n just @code{DEBUG_MARKER}s, can be detected by testing\n @code{DEBUG_MARKER_INSN_P}, whereas those that do can be recognized as\n@@ -3983,8 +3997,8 @@ with respect to each other, particularly during scheduling.  Binding\n information is kept in pseudo-instruction form, so that, unlike notes,\n it gets the same treatment and adjustments that regular instructions\n would.  It is the variable tracking pass that turns these\n-pseudo-instructions into @code{NOTE_INSN_VAR_LOCATION} and\n-@code{NOTE_INSN_BEGIN_STMT} notes,\n+pseudo-instructions into @code{NOTE_INSN_VAR_LOCATION},\n+@code{NOTE_INSN_BEGIN_STMT} and @code{NOTE_INSN_INLINE_ENTRY} notes,\n analyzing control flow, value equivalences and changes to registers and\n memory referenced in value expressions, propagating the values of debug\n temporaries and determining expressions that can be used to compute the"}, {"sha": "749c7e3b9bbcd114a5b8698cd65a51464e72a224", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 196, "deletions": 3, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5800666390320080558b2766738c21e82bf570e7/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5800666390320080558b2766738c21e82bf570e7/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=5800666390320080558b2766738c21e82bf570e7", "patch": "@@ -2747,6 +2747,7 @@ static void dwarf2out_imported_module_or_decl_1 (tree, tree, tree,\n \t\t\t\t\t\t dw_die_ref);\n static void dwarf2out_abstract_function (tree);\n static void dwarf2out_var_location (rtx_insn *);\n+static void dwarf2out_inline_entry (tree);\n static void dwarf2out_size_function (tree);\n static void dwarf2out_begin_function (tree);\n static void dwarf2out_end_function (unsigned int);\n@@ -2800,7 +2801,7 @@ const struct gcc_debug_hooks dwarf2_debug_hooks =\n   debug_nothing_rtx_code_label,\t/* label */\n   debug_nothing_int,\t\t/* handle_pch */\n   dwarf2out_var_location,\n-  debug_nothing_tree,\t\t/* inline_entry */\n+  dwarf2out_inline_entry,\t/* inline_entry */\n   dwarf2out_size_function,\t/* size_function */\n   dwarf2out_switch_text_section,\n   dwarf2out_set_name,\n@@ -4068,6 +4069,9 @@ static char ranges_base_label[2 * MAX_ARTIFICIAL_LABEL_BYTES];\n #ifndef BLOCK_BEGIN_LABEL\n #define BLOCK_BEGIN_LABEL\t\"LBB\"\n #endif\n+#ifndef BLOCK_INLINE_ENTRY_LABEL\n+#define BLOCK_INLINE_ENTRY_LABEL \"LBI\"\n+#endif\n #ifndef BLOCK_END_LABEL\n #define BLOCK_END_LABEL\t\t\"LBE\"\n #endif\n@@ -23215,6 +23219,48 @@ block_die_hasher::equal (die_struct *x, die_struct *y)\n   return x->decl_id == y->decl_id && x->die_parent == y->die_parent;\n }\n \n+/* Hold information about markers for inlined entry points.  */\n+struct GTY ((for_user)) inline_entry_data\n+{\n+  /* The block that's the inlined_function_outer_scope for an inlined\n+     function.  */\n+  tree block;\n+\n+  /* The label at the inlined entry point.  */\n+  const char *label_pfx;\n+  unsigned int label_num;\n+\n+  /* The view number to be used as the inlined entry point.  */\n+  var_loc_view view;\n+};\n+\n+struct inline_entry_data_hasher : ggc_ptr_hash <inline_entry_data>\n+{\n+  typedef tree compare_type;\n+  static inline hashval_t hash (const inline_entry_data *);\n+  static inline bool equal (const inline_entry_data *, const_tree);\n+};\n+\n+/* Hash table routines for inline_entry_data.  */\n+\n+inline hashval_t\n+inline_entry_data_hasher::hash (const inline_entry_data *data)\n+{\n+  return htab_hash_pointer (data->block);\n+}\n+\n+inline bool\n+inline_entry_data_hasher::equal (const inline_entry_data *data,\n+\t\t\t\t const_tree block)\n+{\n+  return data->block == block;\n+}\n+\n+/* Inlined entry points pending DIE creation in this compilation unit.  */\n+\n+static GTY(()) hash_table<inline_entry_data_hasher> *inline_entry_data_table;\n+\n+\n /* Return TRUE if DECL, which may have been previously generated as\n    OLD_DIE, is a candidate for a DW_AT_specification.  DECLARATION is\n    true if decl (or its origin) is either an extern declaration or a\n@@ -23667,14 +23713,50 @@ add_high_low_attributes (tree stmt, dw_die_ref die)\n {\n   char label[MAX_ARTIFICIAL_LABEL_BYTES];\n \n+  if (inline_entry_data **iedp\n+      = !inline_entry_data_table ? NULL\n+      : inline_entry_data_table->find_slot_with_hash (stmt,\n+\t\t\t\t\t\t      htab_hash_pointer (stmt),\n+\t\t\t\t\t\t      NO_INSERT))\n+    {\n+      inline_entry_data *ied = *iedp;\n+      gcc_assert (MAY_HAVE_DEBUG_MARKER_INSNS);\n+      gcc_assert (inlined_function_outer_scope_p (stmt));\n+      ASM_GENERATE_INTERNAL_LABEL (label, ied->label_pfx, ied->label_num);\n+      add_AT_lbl_id (die, DW_AT_entry_pc, label);\n+\n+      if (debug_variable_location_views && !ZERO_VIEW_P (ied->view))\n+\t{\n+\t  if (!output_asm_line_debug_info ())\n+\t    add_AT_unsigned (die, DW_AT_GNU_entry_view, ied->view);\n+\t  else\n+\t    {\n+\t      ASM_GENERATE_INTERNAL_LABEL (label, \"LVU\", ied->view);\n+\t      /* FIXME: this will resolve to a small number.  Could we\n+\t\t possibly emit smaller data?  Ideally we'd emit a\n+\t\t uleb128, but that would make the size of DIEs\n+\t\t impossible for the compiler to compute, since it's\n+\t\t the assembler that computes the value of the view\n+\t\t label in this case.  Ideally, we'd have a single form\n+\t\t encompassing both the address and the view, and\n+\t\t indirecting them through a table might make things\n+\t\t easier, but even that would be more wasteful,\n+\t\t space-wise, than what we have now.  */\n+\t      add_AT_lbl_id (die, DW_AT_GNU_entry_view, label);\n+\t    }\n+\t}\n+\n+      inline_entry_data_table->clear_slot (iedp);\n+    }\n+\n   if (BLOCK_FRAGMENT_CHAIN (stmt)\n       && (dwarf_version >= 3 || !dwarf_strict))\n     {\n       tree chain, superblock = NULL_TREE;\n       dw_die_ref pdie;\n       dw_attr_node *attr = NULL;\n \n-      if (inlined_function_outer_scope_p (stmt))\n+      if (!MAY_HAVE_DEBUG_MARKER_INSNS && inlined_function_outer_scope_p (stmt))\n \t{\n \t  ASM_GENERATE_INTERNAL_LABEL (label, BLOCK_BEGIN_LABEL,\n \t\t\t\t       BLOCK_NUMBER (stmt));\n@@ -23839,7 +23921,7 @@ gen_inlined_subroutine_die (tree stmt, dw_die_ref context_die)\n       dw_die_ref subr_die\n \t= new_die (DW_TAG_inlined_subroutine, context_die, stmt);\n \n-      if (call_arg_locations)\n+      if (call_arg_locations || MAY_HAVE_DEBUG_MARKER_INSNS)\n \tBLOCK_DIE (stmt) = subr_die;\n       add_abstract_origin_attribute (subr_die, decl);\n       if (TREE_ASM_WRITTEN (stmt))\n@@ -26871,6 +26953,7 @@ dwarf2out_var_location (rtx_insn *loc_note)\n       || ! NOTE_P (next_note)\n       || (NOTE_KIND (next_note) != NOTE_INSN_VAR_LOCATION\n \t  && NOTE_KIND (next_note) != NOTE_INSN_BEGIN_STMT\n+\t  && NOTE_KIND (next_note) != NOTE_INSN_INLINE_ENTRY\n \t  && NOTE_KIND (next_note) != NOTE_INSN_CALL_ARG_LOCATION))\n     next_note = NULL;\n \n@@ -27064,6 +27147,113 @@ dwarf2out_var_location (rtx_insn *loc_note)\n   last_in_cold_section_p = in_cold_section_p;\n }\n \n+/* Check whether BLOCK, a lexical block, is nested within OUTER, or is\n+   OUTER itself.  If BOTHWAYS, check not only that BLOCK can reach\n+   OUTER through BLOCK_SUPERCONTEXT links, but also that there is a\n+   path from OUTER to BLOCK through BLOCK_SUBBLOCKs and\n+   BLOCK_FRAGMENT_ORIGIN links.  */\n+static bool\n+block_within_block_p (tree block, tree outer, bool bothways)\n+{\n+  if (block == outer)\n+    return true;\n+\n+  /* Quickly check that OUTER is up BLOCK's supercontext chain.  */\n+  for (tree context = BLOCK_SUPERCONTEXT (block);\n+       context != outer;\n+       context = BLOCK_SUPERCONTEXT (context))\n+    if (!context || TREE_CODE (context) != BLOCK)\n+      return false;\n+\n+  if (!bothways)\n+    return true;\n+\n+  /* Now check that each block is actually referenced by its\n+     parent.  */\n+  for (tree context = BLOCK_SUPERCONTEXT (block); ;\n+       context = BLOCK_SUPERCONTEXT (context))\n+    {\n+      if (BLOCK_FRAGMENT_ORIGIN (context))\n+\t{\n+\t  gcc_assert (!BLOCK_SUBBLOCKS (context));\n+\t  context = BLOCK_FRAGMENT_ORIGIN (context);\n+\t}\n+      for (tree sub = BLOCK_SUBBLOCKS (context);\n+\t   sub != block;\n+\t   sub = BLOCK_CHAIN (sub))\n+\tif (!sub)\n+\t  return false;\n+      if (context == outer)\n+\treturn true;\n+      else\n+\tblock = context;\n+    }\n+}\n+\n+/* Called during final while assembling the marker of the entry point\n+   for an inlined function.  */\n+\n+static void\n+dwarf2out_inline_entry (tree block)\n+{\n+  /* If we can't represent it, don't bother.  */\n+  if (!(dwarf_version >= 3 || !dwarf_strict))\n+    return;\n+\n+  gcc_assert (DECL_P (block_ultimate_origin (block)));\n+\n+  /* Sanity check the block tree.  This would catch a case in which\n+     BLOCK got removed from the tree reachable from the outermost\n+     lexical block, but got retained in markers.  It would still link\n+     back to its parents, but some ancestor would be missing a link\n+     down the path to the sub BLOCK.  If the block got removed, its\n+     BLOCK_NUMBER will not be a usable value.  */\n+  if (flag_checking)\n+    gcc_assert (block_within_block_p (block,\n+\t\t\t\t      DECL_INITIAL (current_function_decl),\n+\t\t\t\t      true));\n+\n+  gcc_assert (inlined_function_outer_scope_p (block));\n+  gcc_assert (!BLOCK_DIE (block));\n+\n+  if (BLOCK_FRAGMENT_ORIGIN (block))\n+    block = BLOCK_FRAGMENT_ORIGIN (block);\n+  /* Can the entry point ever not be at the beginning of an\n+     unfragmented lexical block?  */\n+  else if (!(BLOCK_FRAGMENT_CHAIN (block)\n+\t     || (cur_line_info_table\n+\t\t && !ZERO_VIEW_P (cur_line_info_table->view))))\n+    return;\n+\n+  if (!inline_entry_data_table)\n+    inline_entry_data_table\n+      = hash_table<inline_entry_data_hasher>::create_ggc (10);\n+\n+\n+  inline_entry_data **iedp\n+    = inline_entry_data_table->find_slot_with_hash (block,\n+\t\t\t\t\t\t    htab_hash_pointer (block),\n+\t\t\t\t\t\t    INSERT);\n+  if (*iedp)\n+    /* ??? Ideally, we'd record all entry points for the same inlined\n+       function (some may have been duplicated by e.g. unrolling), but\n+       we have no way to represent that ATM.  */\n+    return;\n+\n+  inline_entry_data *ied = *iedp = ggc_cleared_alloc<inline_entry_data> ();\n+  ied->block = block;\n+  ied->label_pfx = BLOCK_INLINE_ENTRY_LABEL;\n+  ied->label_num = BLOCK_NUMBER (block);\n+  if (cur_line_info_table)\n+    ied->view = cur_line_info_table->view;\n+\n+  char label[MAX_ARTIFICIAL_LABEL_BYTES];\n+\n+  ASM_GENERATE_INTERNAL_LABEL (label, BLOCK_INLINE_ENTRY_LABEL,\n+\t\t\t       BLOCK_NUMBER (block));\n+  ASM_OUTPUT_LABEL (asm_out_file, label);\n+}\n+\n /* Called from finalize_size_functions for size functions so that their body\n    can be encoded in the debug info to describe the layout of variable-length\n    structures.  */\n@@ -30560,6 +30750,9 @@ dwarf2out_finish (const char *)\n   /* Flush out any latecomers to the limbo party.  */\n   flush_limbo_die_list ();\n \n+  if (inline_entry_data_table)\n+    gcc_assert (inline_entry_data_table->elements () == 0);\n+\n   if (flag_checking)\n     {\n       verify_die (comp_unit_die ());"}, {"sha": "99a7cadd7c9f9df7c7cc4629315154fac74334ed", "filename": "gcc/final.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5800666390320080558b2766738c21e82bf570e7/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5800666390320080558b2766738c21e82bf570e7/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=5800666390320080558b2766738c21e82bf570e7", "patch": "@@ -1611,6 +1611,7 @@ reemit_insn_block_notes (void)\n \t    break;\n \n \t  case NOTE_INSN_BEGIN_STMT:\n+\t  case NOTE_INSN_INLINE_ENTRY:\n \t    this_block = LOCATION_BLOCK (NOTE_MARKER_LOCATION (insn));\n \t    goto set_cur_block_to_this_block;\n \n@@ -2479,13 +2480,26 @@ final_scan_insn (rtx_insn *insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \t  if (!DECL_IGNORED_P (current_function_decl)\n \t      && notice_source_line (insn, NULL))\n \t    {\n+\t    output_source_line:\n \t      (*debug_hooks->source_line) (last_linenum, last_columnnum,\n \t\t\t\t\t   last_filename, last_discriminator,\n \t\t\t\t\t   true);\n \t      clear_next_view_needed (seen);\n \t    }\n \t  break;\n \n+\tcase NOTE_INSN_INLINE_ENTRY:\n+\t  gcc_checking_assert (cfun->debug_nonbind_markers);\n+\t  if (!DECL_IGNORED_P (current_function_decl))\n+\t    {\n+\t      if (!notice_source_line (insn, NULL))\n+\t\tbreak;\n+\t      (*debug_hooks->inline_entry) (LOCATION_BLOCK\n+\t\t\t\t\t    (NOTE_MARKER_LOCATION (insn)));\n+\t      goto output_source_line;\n+\t    }\n+\t  break;\n+\n \tdefault:\n \t  gcc_unreachable ();\n \t  break;\n@@ -3189,6 +3203,17 @@ notice_source_line (rtx_insn *insn, bool *is_stmt)\n   if (NOTE_MARKER_P (insn))\n     {\n       location_t loc = NOTE_MARKER_LOCATION (insn);\n+      /* The inline entry markers (gimple, insn, note) carry the\n+\t location of the call, because that's what we want to carry\n+\t during compilation, but the location we want to output in\n+\t debug information for the inline entry point is the location\n+\t of the function itself.  */\n+      if (NOTE_KIND (insn) == NOTE_INSN_INLINE_ENTRY)\n+\t{\n+\t  tree block = LOCATION_BLOCK (loc);\n+\t  tree fn = block_ultimate_origin (block);\n+\t  loc = DECL_SOURCE_LOCATION (fn);\n+\t}\n       expanded_location xloc = expand_location (loc);\n       if (xloc.line == 0)\n \t{\n@@ -4795,6 +4820,7 @@ rest_of_clean_state (void)\n \t  && (!NOTE_P (insn) ||\n \t      (NOTE_KIND (insn) != NOTE_INSN_VAR_LOCATION\n \t       && NOTE_KIND (insn) != NOTE_INSN_BEGIN_STMT\n+\t       && NOTE_KIND (insn) != NOTE_INSN_INLINE_ENTRY\n \t       && NOTE_KIND (insn) != NOTE_INSN_CALL_ARG_LOCATION\n \t       && NOTE_KIND (insn) != NOTE_INSN_BLOCK_BEG\n \t       && NOTE_KIND (insn) != NOTE_INSN_BLOCK_END"}, {"sha": "6695526f3702dbf7aa286b430e7042de6b159133", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5800666390320080558b2766738c21e82bf570e7/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5800666390320080558b2766738c21e82bf570e7/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=5800666390320080558b2766738c21e82bf570e7", "patch": "@@ -1371,6 +1371,19 @@ dump_gimple_debug (pretty_printer *buffer, gdebug *gs, int spc,\n \tdump_gimple_fmt (buffer, spc, flags, \"# DEBUG BEGIN_STMT\");\n       break;\n \n+    case GIMPLE_DEBUG_INLINE_ENTRY:\n+      if (flags & TDF_RAW)\n+\tdump_gimple_fmt (buffer, spc, flags, \"%G INLINE_ENTRY %T\", gs,\n+\t\t\t gimple_block (gs)\n+\t\t\t ? block_ultimate_origin (gimple_block (gs))\n+\t\t\t : NULL_TREE);\n+      else\n+\tdump_gimple_fmt (buffer, spc, flags, \"# DEBUG INLINE_ENTRY %T\",\n+\t\t\t gimple_block (gs)\n+\t\t\t ? block_ultimate_origin (gimple_block (gs))\n+\t\t\t : NULL_TREE);\n+      break;\n+\n     default:\n       gcc_unreachable ();\n     }"}, {"sha": "9dc4911a36e04c99102961a1d410de6d3cd0e816", "filename": "gcc/gimple.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5800666390320080558b2766738c21e82bf570e7/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5800666390320080558b2766738c21e82bf570e7/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=5800666390320080558b2766738c21e82bf570e7", "patch": "@@ -874,6 +874,27 @@ gimple_build_debug_begin_stmt (tree block, location_t location\n }\n \n \n+/* Build a new GIMPLE_DEBUG_INLINE_ENTRY statement in BLOCK at\n+   LOCATION.  The BLOCK links to the inlined function.  */\n+\n+gdebug *\n+gimple_build_debug_inline_entry (tree block, location_t location\n+\t\t\t\t      MEM_STAT_DECL)\n+{\n+  gdebug *p\n+    = as_a <gdebug *> (\n+        gimple_build_with_ops_stat (GIMPLE_DEBUG,\n+\t\t\t\t    (unsigned)GIMPLE_DEBUG_INLINE_ENTRY, 0\n+\t\t\t\t    PASS_MEM_STAT));\n+\n+  gimple_set_location (p, location);\n+  gimple_set_block (p, block);\n+  cfun->debug_marker_count++;\n+\n+  return p;\n+}\n+\n+\n /* Build a GIMPLE_OMP_CRITICAL statement.\n \n    BODY is the sequence of statements for which only one thread can execute."}, {"sha": "265e3e24398cc6129c6e2b9f2c475174cfbf1970", "filename": "gcc/gimple.h", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5800666390320080558b2766738c21e82bf570e7/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5800666390320080558b2766738c21e82bf570e7/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=5800666390320080558b2766738c21e82bf570e7", "patch": "@@ -202,7 +202,8 @@ enum gf_mask {\n enum gimple_debug_subcode {\n   GIMPLE_DEBUG_BIND = 0,\n   GIMPLE_DEBUG_SOURCE_BIND = 1,\n-  GIMPLE_DEBUG_BEGIN_STMT = 2\n+  GIMPLE_DEBUG_BEGIN_STMT = 2,\n+  GIMPLE_DEBUG_INLINE_ENTRY = 3\n };\n \n /* Masks for selecting a pass local flag (PLF) to work on.  These\n@@ -1454,6 +1455,7 @@ geh_dispatch *gimple_build_eh_dispatch (int);\n gdebug *gimple_build_debug_bind (tree, tree, gimple * CXX_MEM_STAT_INFO);\n gdebug *gimple_build_debug_source_bind (tree, tree, gimple * CXX_MEM_STAT_INFO);\n gdebug *gimple_build_debug_begin_stmt (tree, location_t CXX_MEM_STAT_INFO);\n+gdebug *gimple_build_debug_inline_entry (tree, location_t CXX_MEM_STAT_INFO);\n gomp_critical *gimple_build_omp_critical (gimple_seq, tree, tree);\n gomp_for *gimple_build_omp_for (gimple_seq, int, tree, size_t, gimple_seq);\n gomp_parallel *gimple_build_omp_parallel (gimple_seq, tree, tree, tree);\n@@ -4784,13 +4786,25 @@ gimple_debug_begin_stmt_p (const gimple *s)\n   return false;\n }\n \n+/* Return true if S is a GIMPLE_DEBUG INLINE_ENTRY statement.  */\n+\n+static inline bool\n+gimple_debug_inline_entry_p (const gimple *s)\n+{\n+  if (is_gimple_debug (s))\n+    return s->subcode == GIMPLE_DEBUG_INLINE_ENTRY;\n+\n+  return false;\n+}\n+\n /* Return true if S is a GIMPLE_DEBUG non-binding marker statement.  */\n \n static inline bool\n gimple_debug_nonbind_marker_p (const gimple *s)\n {\n   if (is_gimple_debug (s))\n-    return s->subcode == GIMPLE_DEBUG_BEGIN_STMT;\n+    return s->subcode == GIMPLE_DEBUG_BEGIN_STMT\n+      || s->subcode == GIMPLE_DEBUG_INLINE_ENTRY;\n \n   return false;\n }"}, {"sha": "9cac5f1549a75ca87f342ccaf3ebbd073334ac3e", "filename": "gcc/insn-notes.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5800666390320080558b2766738c21e82bf570e7/gcc%2Finsn-notes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5800666390320080558b2766738c21e82bf570e7/gcc%2Finsn-notes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finsn-notes.def?ref=5800666390320080558b2766738c21e82bf570e7", "patch": "@@ -71,6 +71,10 @@ INSN_NOTE (CALL_ARG_LOCATION)\n /* The beginning of a statement.  */\n INSN_NOTE (BEGIN_STMT)\n \n+/* The entry point for an inlined function.  Its NOTE_BLOCK references\n+   the lexical block whose abstract origin is the inlined function.  */\n+INSN_NOTE (INLINE_ENTRY)\n+\n /* Record the struct for the following basic block.  Uses\n    NOTE_BASIC_BLOCK.  FIXME: Redundant with the basic block pointer\n    now included in every insn.  NOTE: If there's no CFG anymore, in other words,"}, {"sha": "3ad11dc4cf9b3524d660a75694383c368e98628d", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5800666390320080558b2766738c21e82bf570e7/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5800666390320080558b2766738c21e82bf570e7/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=5800666390320080558b2766738c21e82bf570e7", "patch": "@@ -276,6 +276,7 @@ rtx_writer::print_rtx_operand_code_0 (const_rtx in_rtx ATTRIBUTE_UNUSED,\n \t  break;\n \n \tcase NOTE_INSN_BEGIN_STMT:\n+\tcase NOTE_INSN_INLINE_ENTRY:\n #ifndef GENERATOR_FILE\n \t  {\n \t    expanded_location xloc\n@@ -1879,6 +1880,10 @@ print_insn (pretty_printer *pp, const rtx_insn *x, int verbose)\n \t\tpp_string (pp, \"debug begin stmt marker\");\n \t\tbreak;\n \n+\t      case NOTE_INSN_INLINE_ENTRY:\n+\t\tpp_string (pp, \"debug inline entry marker\");\n+\t\tbreak;\n+\n \t      default:\n \t\tgcc_unreachable ();\n \t      }"}, {"sha": "c9dd7dd959fcaef387665ca60d9ef7b1e2eab566", "filename": "gcc/rtl.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5800666390320080558b2766738c21e82bf570e7/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5800666390320080558b2766738c21e82bf570e7/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=5800666390320080558b2766738c21e82bf570e7", "patch": "@@ -1654,7 +1654,8 @@ extern const char * const reg_note_name[];\n    for which NOTE_MARKER_LOCATION can be used.  */\n #define NOTE_MARKER_P(INSN)\t\t\t\t\\\n   (NOTE_P (INSN) &&\t\t\t\t\t\\\n-   (NOTE_KIND (INSN) == NOTE_INSN_BEGIN_STMT))\n+   (NOTE_KIND (INSN) == NOTE_INSN_BEGIN_STMT\t\t\\\n+    || NOTE_KIND (INSN) == NOTE_INSN_INLINE_ENTRY))\n \n /* Variable declaration and the location of a variable.  */\n #define PAT_VAR_LOCATION_DECL(PAT) (XCTREE ((PAT), 0, VAR_LOCATION))\n@@ -1692,6 +1693,8 @@ extern const char * const reg_note_name[];\n   (GET_CODE (PATTERN (INSN)) == DEBUG_MARKER\t  \\\n    ? (GET_MODE (PATTERN (INSN)) == VOIDmode\t  \\\n       ? NOTE_INSN_BEGIN_STMT\t\t\t  \\\n+      : GET_MODE (PATTERN (INSN)) == BLKmode\t  \\\n+      ? NOTE_INSN_INLINE_ENTRY\t\t\t  \\\n       : (enum insn_note)-1) \t\t\t  \\\n    : (enum insn_note)-1)\n /* Create patterns for debug markers.  These and the above abstract\n@@ -1701,6 +1704,8 @@ extern const char * const reg_note_name[];\n    wouldn't be a problem.  */\n #define GEN_RTX_DEBUG_MARKER_BEGIN_STMT_PAT() \\\n   gen_rtx_DEBUG_MARKER (VOIDmode)\n+#define GEN_RTX_DEBUG_MARKER_INLINE_ENTRY_PAT() \\\n+  gen_rtx_DEBUG_MARKER (BLKmode)\n \n /* The VAR_LOCATION rtx in a DEBUG_INSN.  */\n #define INSN_VAR_LOCATION(INSN) \\"}, {"sha": "7f9ec770e197c415fbd1fbd7ef0f494652ca1345", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5800666390320080558b2766738c21e82bf570e7/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5800666390320080558b2766738c21e82bf570e7/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=5800666390320080558b2766738c21e82bf570e7", "patch": "@@ -4605,6 +4605,13 @@ expand_call_inline (basic_block bb, gimple *stmt, copy_body_data *id)\n \t\t\tGSI_NEW_STMT);\n     }\n   initialize_inlined_parameters (id, stmt, fn, bb);\n+  if (debug_nonbind_markers_p && id->block\n+      && inlined_function_outer_scope_p (id->block))\n+    {\n+      gimple_stmt_iterator si = gsi_last_bb (bb);\n+      gsi_insert_after (&si, gimple_build_debug_inline_entry\n+\t\t\t(id->block, input_location), GSI_NEW_STMT);\n+    }\n \n   if (DECL_INITIAL (fn))\n     {"}, {"sha": "26da31f74cb29940943a2f41ea87bc769e793f31", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5800666390320080558b2766738c21e82bf570e7/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5800666390320080558b2766738c21e82bf570e7/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=5800666390320080558b2766738c21e82bf570e7", "patch": "@@ -520,6 +520,11 @@ remove_unused_scope_block_p (tree scope, bool in_ctor_dtor_block)\n    else if (!BLOCK_SUPERCONTEXT (scope)\n             || TREE_CODE (BLOCK_SUPERCONTEXT (scope)) == FUNCTION_DECL)\n      unused = false;\n+   /* Preserve the block, it is referenced by at least the inline\n+      entry point marker.  */\n+   else if (debug_nonbind_markers_p\n+\t    && inlined_function_outer_scope_p (scope))\n+     unused = false;\n    /* Innermost blocks with no live variables nor statements can be always\n       eliminated.  */\n    else if (!nsubblocks)\n@@ -548,11 +553,13 @@ remove_unused_scope_block_p (tree scope, bool in_ctor_dtor_block)\n      }\n    else if (BLOCK_VARS (scope) || BLOCK_NUM_NONLOCALIZED_VARS (scope))\n      unused = false;\n-   /* See if this block is important for representation of inlined function.\n-      Inlined functions are always represented by block with\n-      block_ultimate_origin being set to FUNCTION_DECL and DECL_SOURCE_LOCATION\n-      set...  */\n-   else if (inlined_function_outer_scope_p (scope))\n+   /* See if this block is important for representation of inlined\n+      function.  Inlined functions are always represented by block\n+      with block_ultimate_origin being set to FUNCTION_DECL and\n+      DECL_SOURCE_LOCATION set, unless they expand to nothing...  But\n+      see above for the case of statement frontiers.  */\n+   else if (!debug_nonbind_markers_p\n+\t    && inlined_function_outer_scope_p (scope))\n      unused = false;\n    else\n    /* Verfify that only blocks with source location set\n@@ -640,6 +647,16 @@ dump_scope_block (FILE *file, int indent, tree scope, dump_flags_t flags)\n \t    fprintf (file, \"#%i\", BLOCK_NUMBER (origin));\n \t}\n     }\n+  if (BLOCK_FRAGMENT_ORIGIN (scope))\n+    fprintf (file, \" Fragment of : #%i\",\n+\t     BLOCK_NUMBER (BLOCK_FRAGMENT_ORIGIN (scope)));\n+  else if (BLOCK_FRAGMENT_CHAIN (scope))\n+    {\n+      fprintf (file, \" Fragment chain :\");\n+      for (t = BLOCK_FRAGMENT_CHAIN (scope); t ;\n+\t   t = BLOCK_FRAGMENT_CHAIN (t))\n+\tfprintf (file, \" #%i\", BLOCK_NUMBER (t));\n+    }\n   fprintf (file, \" \\n\");\n   for (var = BLOCK_VARS (scope); var; var = DECL_CHAIN (var))\n     {"}, {"sha": "c3d4dac59ef20016fc758ebe63aa88f87acd655a", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5800666390320080558b2766738c21e82bf570e7/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5800666390320080558b2766738c21e82bf570e7/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=5800666390320080558b2766738c21e82bf570e7", "patch": "@@ -9959,6 +9959,7 @@ reemit_marker_as_note (rtx_insn *insn)\n   switch (kind)\n     {\n     case NOTE_INSN_BEGIN_STMT:\n+    case NOTE_INSN_INLINE_ENTRY:\n       {\n \trtx_insn *note = NULL;\n \tif (cfun->debug_nonbind_markers)"}, {"sha": "73d6b64398e5d7d35c1112a14811c39f8708466c", "filename": "include/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5800666390320080558b2766738c21e82bf570e7/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5800666390320080558b2766738c21e82bf570e7/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=5800666390320080558b2766738c21e82bf570e7", "patch": "@@ -1,5 +1,7 @@\n 2018-02-09  Alexandre Oliva <aoliva@redhat.com>\n \n+\t* dwarf2.def (DW_AT_GNU_entry_view): New.\n+\n \t* dwarf2.def (DW_AT_GNU_locviews): New.\n \t* dwarf2.h (enum dwarf_location_list_entry_type): Add\n \tDW_LLE_GNU_view_pair."}, {"sha": "3becd7f8219c5f86f81217ac9d894626935e40d6", "filename": "include/dwarf2.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5800666390320080558b2766738c21e82bf570e7/include%2Fdwarf2.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5800666390320080558b2766738c21e82bf570e7/include%2Fdwarf2.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fdwarf2.def?ref=5800666390320080558b2766738c21e82bf570e7", "patch": "@@ -444,6 +444,7 @@ DW_AT (DW_AT_GNU_pubtypes, 0x2135)\n    See http://gcc.gnu.org/wiki/Discriminator  */\n DW_AT (DW_AT_GNU_discriminator, 0x2136)\n DW_AT (DW_AT_GNU_locviews, 0x2137)\n+DW_AT (DW_AT_GNU_entry_view, 0x2138)\n /* VMS extensions.  */\n DW_AT (DW_AT_VMS_rtnbeg_pd_address, 0x2201)\n /* GNAT extensions.  */"}]}