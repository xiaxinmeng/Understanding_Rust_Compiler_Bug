{"sha": "33792684238fe1f68be7f6f953c9198b9d200f52", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzM3OTI2ODQyMzhmZTFmNjhiZTdmNmY5NTNjOTE5OGI5ZDIwMGY1Mg==", "commit": {"author": {"name": "Ranjit Mathew", "email": "rmathew@gcc.gnu.org", "date": "2006-06-29T14:57:39Z"}, "committer": {"name": "Ranjit Mathew", "email": "rmathew@gcc.gnu.org", "date": "2006-06-29T14:57:39Z"}, "message": "javaprims.h (_Jv_uintptr_t): New typedef similar to uintptr_t in C99.\n\n\t* gcj/javaprims.h (_Jv_uintptr_t): New typedef similar to uintptr_t in\n\tC99.\n\t* include/java-stack.h: Include stdlib.h.\n\t(_Jv_AddrInfo): New structure to hold address information.\n\t* include/posix.h (_Jv_platform_dladdr): Declare.\n\t* include/win32.h (_Jv_platform_dladdr): Declare.\n\t(backtrace): Remove declaration.\n\t* posix.cc: Include dlfcn.h if available.  Include java-stack.h.\n\t(_Jv_platform_dladdr): Define.\n\t* win32.cc: Include string.h.  Include java-stack.h.\n\t(backtrace): Remove.\n\t(_Jv_platform_dladdr): Define.\n\t* sysdep/i386/backtrace.h (fallback_backtrace): Check that a potential\n\tframe pointer value is 32-bit word-aligned.  Use operand of the CALL\n\tinstruction calling the current function to find its starting address.\n\t* stacktrace.cc: Do not include dlfcn.h.  Include platform.h.\n\t(_Jv_StackTrace::getLineNumberForFrame): Use _Jv_platform_dladdr()\n\tinstead of dladdr().\n\t(_Jv_StackTrace::GetStackTraceElements): Use nCodeMap even for Windows.\n\t(_Jv_StackTrace::GetClassContext): Use fallback_backtrace() for\n\ttargets with SJLJ exceptions instead of using _Unwind_Backtrace().\n\t(_Jv_StackTrace::GetFirstNonSystemClassLoader): Likewise.\n\nFrom-SVN: r115069", "tree": {"sha": "c184ad263e2312d7a38fbced2682933d1ad843bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c184ad263e2312d7a38fbced2682933d1ad843bc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/33792684238fe1f68be7f6f953c9198b9d200f52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33792684238fe1f68be7f6f953c9198b9d200f52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33792684238fe1f68be7f6f953c9198b9d200f52", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33792684238fe1f68be7f6f953c9198b9d200f52/comments", "author": null, "committer": null, "parents": [{"sha": "6150b6026194c4ed9003f788ced0c16b18c5c567", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6150b6026194c4ed9003f788ced0c16b18c5c567", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6150b6026194c4ed9003f788ced0c16b18c5c567"}], "stats": {"total": 267, "additions": 209, "deletions": 58}, "files": [{"sha": "9076505c5cf92afb0b0a6dc0652534997e411804", "filename": "libjava/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33792684238fe1f68be7f6f953c9198b9d200f52/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33792684238fe1f68be7f6f953c9198b9d200f52/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=33792684238fe1f68be7f6f953c9198b9d200f52", "patch": "@@ -1,3 +1,28 @@\n+2006-06-29  Ranjit Mathew  <rmathew@gcc.gnu.org>\n+\n+\t* gcj/javaprims.h (_Jv_uintptr_t): New typedef similar to uintptr_t in\n+\tC99.\n+\t* include/java-stack.h: Include stdlib.h.\n+\t(_Jv_AddrInfo): New structure to hold address information.\n+\t* include/posix.h (_Jv_platform_dladdr): Declare.\n+\t* include/win32.h (_Jv_platform_dladdr): Declare.\n+\t(backtrace): Remove declaration.\n+\t* posix.cc: Include dlfcn.h if available.  Include java-stack.h.\n+\t(_Jv_platform_dladdr): Define.\n+\t* win32.cc: Include string.h.  Include java-stack.h.\n+\t(backtrace): Remove.\n+\t(_Jv_platform_dladdr): Define.\n+\t* sysdep/i386/backtrace.h (fallback_backtrace): Check that a potential\n+\tframe pointer value is 32-bit word-aligned.  Use operand of the CALL\n+\tinstruction calling the current function to find its starting address.\n+\t* stacktrace.cc: Do not include dlfcn.h.  Include platform.h.\n+\t(_Jv_StackTrace::getLineNumberForFrame): Use _Jv_platform_dladdr()\n+\tinstead of dladdr().\n+\t(_Jv_StackTrace::GetStackTraceElements): Use nCodeMap even for Windows.\n+\t(_Jv_StackTrace::GetClassContext): Use fallback_backtrace() for\n+\ttargets with SJLJ exceptions instead of using _Unwind_Backtrace().\n+\t(_Jv_StackTrace::GetFirstNonSystemClassLoader): Likewise.\n+\n 2006-06-27  Tom Tromey  <tromey@redhat.com>\n \n \t* java/io/OutputStreamWriter.java (writeChars): Use a 'do' loop."}, {"sha": "61f5276c0229f473b1023263cea0125155e39aa9", "filename": "libjava/gcj/javaprims.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33792684238fe1f68be7f6f953c9198b9d200f52/libjava%2Fgcj%2Fjavaprims.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33792684238fe1f68be7f6f953c9198b9d200f52/libjava%2Fgcj%2Fjavaprims.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2Fjavaprims.h?ref=33792684238fe1f68be7f6f953c9198b9d200f52", "patch": "@@ -624,6 +624,10 @@ typedef unsigned short _Jv_ushort __attribute__((__mode__(__HI__)));\n typedef unsigned int _Jv_uint __attribute__((__mode__(__SI__)));\n typedef unsigned int _Jv_ulong __attribute__((__mode__(__DI__)));\n \n+// The type to use when treating a pointer as an integer.  Similar to\n+// uintptr_t in C99.\n+typedef unsigned int _Jv_uintptr_t __attribute__((__mode__(__pointer__)));\n+\n class _Jv_Utf8Const\n {\n   _Jv_ushort hash;"}, {"sha": "eb1ddcce4c770598eda1cbae0b13a8ffb4c64893", "filename": "libjava/include/java-stack.h", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33792684238fe1f68be7f6f953c9198b9d200f52/libjava%2Finclude%2Fjava-stack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33792684238fe1f68be7f6f953c9198b9d200f52/libjava%2Finclude%2Fjava-stack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjava-stack.h?ref=33792684238fe1f68be7f6f953c9198b9d200f52", "patch": "@@ -1,6 +1,6 @@\n // java-stack.h - Definitions for unwinding & inspecting the call stack.\n \n-/* Copyright (C) 2005  Free Software Foundation\n+/* Copyright (C) 2005, 2006  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -11,6 +11,7 @@ details.  */\n #ifndef __JV_STACKTRACE_H__\n #define __JV_STACKTRACE_H__\n \n+#include <stdlib.h>\n #include <unwind.h>\n \n #include <gcj/cni.h>\n@@ -126,5 +127,35 @@ class _Jv_StackTrace\n   \n };\n \n+// Information about a given address.\n+struct _Jv_AddrInfo\n+{\n+  // File name of the defining module.\n+  const char *file_name;\n+\n+  // Base address of the loaded module.\n+  void *base;\n+\n+  // Name of the nearest symbol.\n+  const char *sym_name;\n+\n+  // Address of the nearest symbol.\n+  void *sym_addr;\n+\n+  ~_Jv_AddrInfo (void)\n+    {\n+      // On systems with a real dladdr(), the file and symbol names given by\n+      // _Jv_platform_dladdr() are not dynamically allocated.  On Windows,\n+      // they are.\n+\n+#ifdef WIN32\n+      if (file_name)\n+        free ((void *)file_name);\n+\n+      if (sym_name)\n+        free ((void *)sym_name);\n+#endif /* WIN32 */\n+    }\n+};\n \n #endif /* __JV_STACKTRACE_H__ */"}, {"sha": "15795ddfdafe36d1fb940b8577e0e387718b578a", "filename": "libjava/include/posix.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33792684238fe1f68be7f6f953c9198b9d200f52/libjava%2Finclude%2Fposix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33792684238fe1f68be7f6f953c9198b9d200f52/libjava%2Finclude%2Fposix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fposix.h?ref=33792684238fe1f68be7f6f953c9198b9d200f52", "patch": "@@ -194,4 +194,11 @@ _Jv_pipe (int filedes[2])\n   return ::pipe (filedes);\n }\n \n+// Forward declaration.  See java-stack.h for definition.\n+struct _Jv_AddrInfo;\n+\n+// Given an address, determine the executable or shared object that defines\n+// it and the nearest named symbol.\n+extern int _Jv_platform_dladdr (const void *addr, _Jv_AddrInfo *info);\n+\n #endif /* __JV_POSIX_H__ */"}, {"sha": "26c307c1d47b401e223b7990a51049a7312d2f9c", "filename": "libjava/include/win32.h", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33792684238fe1f68be7f6f953c9198b9d200f52/libjava%2Finclude%2Fwin32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33792684238fe1f68be7f6f953c9198b9d200f52/libjava%2Finclude%2Fwin32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fwin32.h?ref=33792684238fe1f68be7f6f953c9198b9d200f52", "patch": "@@ -11,7 +11,7 @@ details.  */\n #ifndef __JV_WIN32_H__\n #define __JV_WIN32_H__\n \n-// Enable UNICODE Support.?\n+// Enable UNICODE support?\n \n #ifdef MINGW_LIBGCJ_UNICODE\n #define UNICODE\n@@ -175,8 +175,11 @@ _Jv_platform_usleep (unsigned long usecs)\n }\n #endif /* JV_HASH_SYNCHRONIZATION */\n \n-/* Store up to SIZE return address of the current program state in\n-   ARRAY and return the exact number of values stored.  */\n-extern int backtrace (void **__array, int __size);\n+// Forward declaration.  See java-stack.h for definition.\n+struct _Jv_AddrInfo;\n+\n+// Given an address, determine the executable or shared object that defines\n+// it and the nearest named symbol.\n+extern int _Jv_platform_dladdr (const void *addr, _Jv_AddrInfo *info);\n \n #endif /* __JV_WIN32_H__ */"}, {"sha": "41702dfffb90e4cc062435d467179d52f994aa39", "filename": "libjava/posix.cc", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33792684238fe1f68be7f6f953c9198b9d200f52/libjava%2Fposix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33792684238fe1f68be7f6f953c9198b9d200f52/libjava%2Fposix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fposix.cc?ref=33792684238fe1f68be7f6f953c9198b9d200f52", "patch": "@@ -17,7 +17,12 @@ details.  */\n #include <signal.h>\n #include <stdio.h>\n \n+#ifdef HAVE_DLFCN_H\n+#include <dlfcn.h>\n+#endif\n+\n #include <jvm.h>\n+#include <java-stack.h>\n #include <java/lang/Thread.h>\n #include <java/io/InterruptedIOException.h>\n #include <java/util/Properties.h>\n@@ -203,3 +208,31 @@ _Jv_select (int n, fd_set *readfds, fd_set  *writefds,\n   return 0;\n #endif\n }\n+\n+// Given an address, find the object that defines it and the nearest\n+// defined symbol to that address.  Returns 0 if no object defines this\n+// address.\n+int\n+_Jv_platform_dladdr (const void *addr, _Jv_AddrInfo *info)\n+{\n+  int ret_val = 0;\n+\n+#if defined (HAVE_DLFCN_H) && defined (HAVE_DLADDR)\n+  Dl_info addr_info;\n+  ret_val = dladdr (addr, &addr_info);\n+  if (ret_val != 0)\n+    {\n+      info->file_name = addr_info.dli_fname;\n+      info->base = addr_info.dli_fbase;\n+      info->sym_name = addr_info.dli_sname;\n+      info->sym_addr = addr_info.dli_saddr;\n+    }\n+#else\n+  info->file_name = NULL;\n+  info->base = NULL;\n+  info->sym_name = NULL;\n+  info->sym_addr = NULL;\n+#endif\n+\n+  return ret_val;\n+}"}, {"sha": "06a4dfadb98a4e2a275dcfede329667114b226b7", "filename": "libjava/stacktrace.cc", "status": "modified", "additions": 27, "deletions": 24, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33792684238fe1f68be7f6f953c9198b9d200f52/libjava%2Fstacktrace.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33792684238fe1f68be7f6f953c9198b9d200f52/libjava%2Fstacktrace.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fstacktrace.cc?ref=33792684238fe1f68be7f6f953c9198b9d200f52", "patch": "@@ -9,16 +9,13 @@ Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n details.  */\n \n #include <config.h>\n+#include <platform.h>\n \n #include <jvm.h>\n #include <gcj/cni.h>\n #include <java-interp.h>\n #include <java-stack.h>\n \n-#ifdef HAVE_DLFCN_H\n-#include <dlfcn.h>\n-#endif\n-\n #include <stdio.h>\n \n #include <java/lang/Class.h>\n@@ -184,41 +181,36 @@ _Jv_StackTrace::getLineNumberForFrame(_Jv_StackFrame *frame, NameFinder *finder,\n       return;\n     }\n #endif\n-  // Use dladdr() to determine in which binary the address IP resides.\n-#if defined (HAVE_DLFCN_H) && defined (HAVE_DLADDR)\n-  Dl_info info;\n+\n+  // Use _Jv_platform_dladdr() to determine in which binary the address IP\n+  // resides.\n+  _Jv_AddrInfo info;\n   jstring binaryName = NULL;\n   const char *argv0 = _Jv_GetSafeArg(0);\n \n   void *ip = frame->ip;\n   _Unwind_Ptr offset = 0;\n \n-  if (dladdr (ip, &info))\n+  if (_Jv_platform_dladdr (ip, &info))\n     {\n-      if (info.dli_fname)\n-\tbinaryName = JvNewStringUTF (info.dli_fname);\n+      if (info.file_name)\n+\tbinaryName = JvNewStringUTF (info.file_name);\n       else\n         return;\n \n-      if (*methodName == NULL && info.dli_sname)\n-\t*methodName = JvNewStringUTF (info.dli_sname);\n+      if (*methodName == NULL && info.sym_name)\n+\t*methodName = JvNewStringUTF (info.sym_name);\n \n       // addr2line expects relative addresses for shared libraries.\n-      if (strcmp (info.dli_fname, argv0) == 0)\n+      if (strcmp (info.file_name, argv0) == 0)\n         offset = (_Unwind_Ptr) ip;\n       else\n-        offset = (_Unwind_Ptr) ip - (_Unwind_Ptr) info.dli_fbase;\n+        offset = (_Unwind_Ptr) ip - (_Unwind_Ptr) info.base;\n \n-      //printf (\"linenum ip: %p\\n\", ip);\n-      //printf (\"%s: 0x%x\\n\", info.dli_fname, offset);\n-      //offset -= sizeof(void *);\n-      \n       // The unwinder gives us the return address. In order to get the right\n       // line number for the stack trace, roll it back a little.\n       offset -= 1;\n \n-      // printf (\"%s: 0x%x\\n\", info.dli_fname, offset);\n-      \n       finder->lookup (binaryName, (jlong) offset);\n       *sourceFileName = finder->getSourceFile();\n       *lineNum = finder->getLineNum();\n@@ -234,7 +226,6 @@ _Jv_StackTrace::getLineNumberForFrame(_Jv_StackFrame *frame, NameFinder *finder,\n           *sourceFileName = t->toString();\n         }\n     }\n-#endif\n }\n \n // Look up class and method info for the given stack frame, setting \n@@ -283,7 +274,7 @@ _Jv_StackTrace::GetStackTraceElements (_Jv_StackTrace *trace,\n {\n   ArrayList *list = new ArrayList ();\n \n-#ifdef SJLJ_EXCEPTIONS\n+#if defined (SJLJ_EXCEPTIONS) && ! defined (WIN32)\n   // We can't use the nCodeMap without unwinder support. Instead,\n   // fake the method name by giving the IP in hex - better than nothing.  \n   jstring hex = JvNewStringUTF (\"0x\");\n@@ -302,7 +293,7 @@ _Jv_StackTrace::GetStackTraceElements (_Jv_StackTrace *trace,\n       list->add (element);\n     }\n \n-#else /* SJLJ_EXCEPTIONS */\n+#else /* SJLJ_EXCEPTIONS && !WIN32 */\n \n   //JvSynchronized (ncodeMap);\n   UpdateNCodeMap ();\n@@ -370,7 +361,7 @@ _Jv_StackTrace::GetStackTraceElements (_Jv_StackTrace *trace,\n     }\n   \n   finder->close();\n-#endif /* SJLJ_EXCEPTIONS */\n+#endif /* SJLJ_EXCEPTIONS && !WIN32 */\n \n   JArray<Object *> *array = JvNewObjectArray (list->size (), \n     &StackTraceElement::class$, NULL);\n@@ -472,7 +463,13 @@ _Jv_StackTrace::GetClassContext (jclass checkClass)\n   //JvSynchronized (ncodeMap);\n   UpdateNCodeMap ();\n \n+#ifdef SJLJ_EXCEPTIONS\n+  // The Unwind interface doesn't work with the SJLJ exception model.\n+  // Fall back to a platform-specific unwinder.\n+  fallback_backtrace (&state);\n+#else /* SJLJ_EXCEPTIONS */  \n   _Unwind_Backtrace (UnwindTraceFn, &state);\n+#endif /* SJLJ_EXCEPTIONS */  \n \n   // Count the number of Java frames on the stack.\n   int jframe_count = 0;\n@@ -543,7 +540,13 @@ _Jv_StackTrace::GetFirstNonSystemClassLoader ()\n   //JvSynchronized (ncodeMap);\n   UpdateNCodeMap ();\n   \n+#ifdef SJLJ_EXCEPTIONS\n+  // The Unwind interface doesn't work with the SJLJ exception model.\n+  // Fall back to a platform-specific unwinder.\n+  fallback_backtrace (&state);\n+#else /* SJLJ_EXCEPTIONS */  \n   _Unwind_Backtrace (UnwindTraceFn, &state);\n+#endif /* SJLJ_EXCEPTIONS */  \n \n   if (state.trace_data)\n     return (ClassLoader *) state.trace_data;"}, {"sha": "8d46cbf1702ed1119c16798e5f91bdfa5ac75a17", "filename": "libjava/sysdep/i386/backtrace.h", "status": "modified", "additions": 32, "deletions": 7, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33792684238fe1f68be7f6f953c9198b9d200f52/libjava%2Fsysdep%2Fi386%2Fbacktrace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33792684238fe1f68be7f6f953c9198b9d200f52/libjava%2Fsysdep%2Fi386%2Fbacktrace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fsysdep%2Fi386%2Fbacktrace.h?ref=33792684238fe1f68be7f6f953c9198b9d200f52", "patch": "@@ -1,6 +1,6 @@\n // backtrace.h - Fallback backtrace implementation. i386 implementation.\n \n-/* Copyright (C) 2005  Free Software Foundation\n+/* Copyright (C) 2005, 2006  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -22,19 +22,44 @@ fallback_backtrace (_Jv_UnwindState *state)\n {\n   register void *_ebp __asm__ (\"ebp\");\n   register void *_esp __asm__ (\"esp\");\n-  unsigned int *rfp;\n+  _Jv_uintptr_t *rfp;\n \n   int i = state->pos;\n-  for (rfp = *(unsigned int**)_ebp;\n+  for (rfp = *(_Jv_uintptr_t **)_ebp;\n        rfp && i < state->length;\n-       rfp = *(unsigned int **)rfp)\n+       rfp = *(_Jv_uintptr_t **)rfp)\n     {\n-      int diff = *rfp - (unsigned int)rfp;\n-      if ((void*)rfp < _esp || diff > 4 * 1024 || diff < 0)\n+      /* Sanity checks to eliminate dubious-looking frame pointer chains.\n+         The frame pointer should be a 32-bit word-aligned stack address.\n+         Since the stack grows downwards on x86, the frame pointer must have\n+         a value greater than the current value of the stack pointer, it\n+         should not be below the supposed next frame pointer and it should\n+         not be too far off from the supposed next frame pointer.  */\n+      int diff = *rfp - (_Jv_uintptr_t)rfp;\n+      if (((_Jv_uintptr_t)rfp & 0x00000003) != 0 || (void*)rfp < _esp\n+          || diff > 4 * 1024 || diff < 0)\n         break;\n \n+      /* Use the return address in the calling function stored just before\n+         the current frame pointer to locate the address operand part of the\n+         \"CALL <XYZ>\" instruction in the calling function that called this\n+         function.  */\n+      void *ip = (void*)(rfp[1] - 4);\n+\n+      /* Verify that the instruction at this position is a \"CALL <XYZ>\" and\n+         use its operand to determine the starting address of the function\n+         that this function had called.  0xE8 is the opcode for this CALL\n+         instruction variant.  */\n+      if (*(unsigned char *)((_Jv_uintptr_t)ip - 1) == 0xE8 && i > state->pos\n+          && state->frames[i-1].type == frame_native)\n+        {\n+          state->frames[i-1].start_ip\n+            = (void *)((_Jv_uintptr_t)ip + 4 + *(_Jv_uintptr_t *)ip);\n+        }\n+\n       state->frames[i].type = frame_native;\n-      state->frames[i].ip = (void*)(rfp[1]-4);\n+      state->frames[i].ip = ip;\n+\n       i++;\n     }\n   state->pos = i;"}, {"sha": "a78f814c6873a087d3e96832b4037767767df281", "filename": "libjava/win32.cc", "status": "modified", "additions": 42, "deletions": 22, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33792684238fe1f68be7f6f953c9198b9d200f52/libjava%2Fwin32.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33792684238fe1f68be7f6f953c9198b9d200f52/libjava%2Fwin32.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fwin32.cc?ref=33792684238fe1f68be7f6f953c9198b9d200f52", "patch": "@@ -12,8 +12,11 @@ details.  */\n #include <platform.h>\n #include <sys/timeb.h>\n #include <stdlib.h>\n+#include <string.h>\n #include <fcntl.h>\n \n+#include <java-stack.h>\n+\n #include <java/lang/ArithmeticException.h>\n #include <java/lang/UnsupportedOperationException.h>\n #include <java/io/IOException.h>\n@@ -442,28 +445,6 @@ _Jv_platform_initProperties (java::util::Properties* newprops)\n     }\n }\n \n-/* Store up to SIZE return address of the current program state in\n-   ARRAY and return the exact number of values stored.  */\n-int\n-backtrace (void **__array, int __size)\n-{\n-  register void *_ebp __asm__ (\"ebp\");\n-  register void *_esp __asm__ (\"esp\");\n-  unsigned int *rfp;\n-\n-  int i=0;\n-  for (rfp = *(unsigned int**)_ebp;\n-       rfp && i < __size;\n-       rfp = *(unsigned int **)rfp)\n-    {\n-      int diff = *rfp - (unsigned int)rfp;\n-      if ((void*)rfp < _esp || diff > 4 * 1024 || diff < 0) break;\n-\n-    __array[i++] = (void*)(rfp[1]-4);\n-  }\n-  return i;\n-}\n-\n int\n _Jv_pipe (int filedes[2])\n {\n@@ -477,3 +458,42 @@ _Jv_platform_close_on_exec (HANDLE h)\n   // no effect under Win9X.\n   SetHandleInformation (h, HANDLE_FLAG_INHERIT, 0);\n }\n+\n+// Given an address, find the object that defines it and the nearest\n+// defined symbol to that address.  Returns 0 if no object defines this\n+// address.\n+int\n+_Jv_platform_dladdr (const void *addr, _Jv_AddrInfo *info)\n+{\n+  // Since we do not have dladdr() on Windows, we use a trick involving\n+  // VirtualQuery() to find the module (EXE or DLL) that contains a given\n+  // address.  This was taken from Matt Pietrek's \"Under the Hood\" column\n+  // for the April 1997 issue of Microsoft Systems Journal.\n+\n+  MEMORY_BASIC_INFORMATION mbi;\n+  if (!VirtualQuery (addr, &mbi, sizeof (mbi)))\n+  {\n+    return 0;\n+  }\n+  \n+  HMODULE hMod = (HMODULE) mbi.AllocationBase;\n+\n+  char moduleName[MAX_PATH];\n+\n+  // FIXME: We explicitly use the ANSI variant of the function here.\n+  if (!GetModuleFileNameA (hMod, moduleName, sizeof (moduleName)))\n+  {\n+    return 0;\n+  }\n+\n+  char *file_name = (char *)(malloc (strlen (moduleName) + 1));\n+  strcpy (file_name, moduleName);\n+  info->file_name = file_name;\n+\n+  // FIXME.\n+  info->base = NULL;\n+  info->sym_name = NULL;\n+  info->sym_addr = NULL;\n+\n+  return 1;\n+}"}]}