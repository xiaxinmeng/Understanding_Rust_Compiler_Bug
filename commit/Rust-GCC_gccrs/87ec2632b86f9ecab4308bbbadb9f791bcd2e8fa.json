{"sha": "87ec2632b86f9ecab4308bbbadb9f791bcd2e8fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODdlYzI2MzJiODZmOWVjYWI0MzA4YmJiYWRiOWY3OTFiY2QyZThmYQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2010-08-04T23:58:33Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2010-08-04T23:58:33Z"}, "message": "Remove code duplication in ix86_expand_epilogue.\n\nUnion the undo of the frame pointer between the pop and move\ncode paths.\n\nCombine the local frame stack deallocation with the one for\nix86_static_chain_on_stack, if possible.\n\nFrom-SVN: r162890", "tree": {"sha": "0cd27af831961cd09d4b844b2dffad6217d201ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0cd27af831961cd09d4b844b2dffad6217d201ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/87ec2632b86f9ecab4308bbbadb9f791bcd2e8fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87ec2632b86f9ecab4308bbbadb9f791bcd2e8fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87ec2632b86f9ecab4308bbbadb9f791bcd2e8fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87ec2632b86f9ecab4308bbbadb9f791bcd2e8fa/comments", "author": null, "committer": null, "parents": [{"sha": "c9f4c45115dfba1d84958c1a971a333763976b7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9f4c45115dfba1d84958c1a971a333763976b7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9f4c45115dfba1d84958c1a971a333763976b7f"}], "stats": {"total": 133, "additions": 46, "deletions": 87}, "files": [{"sha": "51249f2c33f700f17fc8a942b6635dc5658aa366", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87ec2632b86f9ecab4308bbbadb9f791bcd2e8fa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87ec2632b86f9ecab4308bbbadb9f791bcd2e8fa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=87ec2632b86f9ecab4308bbbadb9f791bcd2e8fa", "patch": "@@ -1,5 +1,9 @@\n 2010-08-04  Richard Henderson  <rth@redhat.com>\n \n+\t* config/i386/i386.c (ix86_expand_epilogue): Eliminate code\n+\tduplication deconstructing the frame pointer.  Simplify\n+\tdeallocation of the local stack frame.\n+\n \t* reg-notes.def (CFA_EXPRESSION): New.\n \t* dwarf2out.c (dwarf2out_frame_debug): Handle it.\n \t(dwarf2out_frame_debug_cfa_expression): New."}, {"sha": "4c1ebb8fb826e6f8bcc96ddd78e3b6da27361e64", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 42, "deletions": 87, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87ec2632b86f9ecab4308bbbadb9f791bcd2e8fa/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87ec2632b86f9ecab4308bbbadb9f791bcd2e8fa/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=87ec2632b86f9ecab4308bbbadb9f791bcd2e8fa", "patch": "@@ -10101,49 +10101,11 @@ ix86_expand_epilogue (int style)\n \t    }\n \t  m->fs.sp_offset = UNITS_PER_WORD;\n \t}\n-      else if (!frame_pointer_needed)\n-\t{\n-\t  pro_epilogue_adjust_stack (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t\t     GEN_INT (m->fs.sp_offset\n-\t\t\t\t\t      - frame.reg_save_offset\n-\t\t\t\t\t      + frame.nregs * UNITS_PER_WORD),\n-\t\t\t\t     style, !using_drap);\n-\t}\n-      else\n-\t{\n-          if (stack_realign_fp)\n-\t    {\n-\t      /* We're re-defining what it means to be the local stack\n-\t\t frame.  Thus the FP is suddenly valid and the SP isn't.  */\n-\t      m->fs.fp_valid = true;\n-\t      m->fs.sp_valid = false;\n-\t      m->fs.realigned = false;\n-\t    }\n-\n-\t  /* Leave results in shorter dependency chains on CPUs that are\n-\t     able to grok it fast.  */\n-\t  if (TARGET_USE_LEAVE\n-\t      || optimize_function_for_size_p (cfun)\n-\t      || !cfun->machine->use_fast_prologue_epilogue)\n-\t    ix86_emit_leave ();\n-          else\n-\t    {\n-\t      pro_epilogue_adjust_stack (stack_pointer_rtx,\n-\t\t\t\t         hard_frame_pointer_rtx,\n-\t\t\t\t         const0_rtx, style, !using_drap);\n-\t      ix86_emit_restore_reg_using_pop (hard_frame_pointer_rtx);\n-\t    }\n-\t}\n     }\n   else\n     {\n       /* First step is to deallocate the stack frame so that we can\n-\t pop the registers.\n-\n-\t If we realign stack with frame pointer, then stack pointer\n-         won't be able to recover via lea $offset(%bp), %sp, because\n-         there is a padding area between bp and sp for realign.\n-         \"add $to_allocate, %sp\" must be used instead.  */\n+\t pop the registers.  */\n       if (!m->fs.sp_valid)\n \t{\n \t  pro_epilogue_adjust_stack (stack_pointer_rtx, hard_frame_pointer_rtx,\n@@ -10161,34 +10123,38 @@ ix86_expand_epilogue (int style)\n \t}\n \n       ix86_emit_restore_regs_using_pop ();\n+    }\n \n-      if (frame_pointer_needed)\n+  /* If we used a stack pointer and haven't already got rid of it,\n+     then do so now.  */\n+  if (m->fs.fp_valid || stack_realign_fp)\n+    {\n+      if (stack_realign_fp)\n \t{\n-\t  if (stack_realign_fp)\n-\t    {\n-\t      /* We're re-defining what it means to be the local stack\n-\t\t frame.  Thus the FP is suddenly valid and the SP isn't.  */\n-\t      m->fs.fp_valid = true;\n-\t      m->fs.sp_valid = false;\n-\t      m->fs.realigned = false;\n-\t    }\n-\n-\t  /* Leave results in shorter dependency chains on CPUs that are\n-\t     able to grok it fast.  */\n-\t  if (TARGET_USE_LEAVE\n-\t      || (stack_realign_fp\n-\t\t  && (optimize_function_for_size_p (cfun)\n-\t\t      || !cfun->machine->use_fast_prologue_epilogue)))\n-\t    ix86_emit_leave ();\n-\t  else\n-            {\n-              if (stack_realign_fp)\n-\t\tpro_epilogue_adjust_stack (stack_pointer_rtx,\n-\t\t\t\t\t   hard_frame_pointer_rtx,\n-\t\t\t\t\t   const0_rtx, style, !using_drap);\n-\t      ix86_emit_restore_reg_using_pop (hard_frame_pointer_rtx);\n-            }\n-\t}\n+\t  /* We're re-defining what it means to be the local stack\n+\t     frame.  Thus the FP is suddenly valid and the SP isn't.  */\n+\t  m->fs.fp_valid = true;\n+\t  m->fs.sp_valid = false;\n+\t  m->fs.realigned = false;\n+\t}\n+\n+      /* If the stack pointer is valid and pointing at the frame\n+\t pointer store address, then we only need a pop.  */\n+      if (m->fs.sp_valid && m->fs.sp_offset == frame.hard_frame_pointer_offset)\n+\tix86_emit_restore_reg_using_pop (hard_frame_pointer_rtx);\n+      /* Leave results in shorter dependency chains on CPUs that are\n+\t able to grok it fast.  */\n+      else if (TARGET_USE_LEAVE\n+\t       || optimize_function_for_size_p (cfun)\n+\t       || !cfun->machine->use_fast_prologue_epilogue)\n+\tix86_emit_leave ();\n+      else\n+        {\n+\t  pro_epilogue_adjust_stack (stack_pointer_rtx,\n+\t\t\t\t     hard_frame_pointer_rtx,\n+\t\t\t\t     const0_rtx, style, !using_drap);\n+\t  ix86_emit_restore_reg_using_pop (hard_frame_pointer_rtx);\n+        }\n     }\n \n   if (using_drap)\n@@ -10222,31 +10188,20 @@ ix86_expand_epilogue (int style)\n \tix86_emit_restore_reg_using_pop (crtl->drap_reg);\n     }\n \n-  /* Remove the saved static chain from the stack.  The use of ECX is\n-     merely as a scratch register, not as the actual static chain.  */\n-  if (ix86_static_chain_on_stack)\n-    {\n-      rtx r, insn;\n-\n-      gcc_assert (m->fs.cfa_reg == stack_pointer_rtx);\n-      m->fs.cfa_offset -= UNITS_PER_WORD;\n-      m->fs.sp_offset -= UNITS_PER_WORD;\n-\n-      r = gen_rtx_REG (Pmode, CX_REG);\n-      insn = emit_insn (ix86_gen_pop1 (r));\n-\n-      r = plus_constant (stack_pointer_rtx, UNITS_PER_WORD);\n-      r = gen_rtx_SET (VOIDmode, stack_pointer_rtx, r);\n-      add_reg_note (insn, REG_CFA_ADJUST_CFA, r);\n-      RTX_FRAME_RELATED_P (insn) = 1;\n-    }\n-\n-  /* At this point we should have de-allocated the entire stack frame,\n-     so the stack pointer points to the return address.  */\n-  gcc_assert (m->fs.sp_offset == UNITS_PER_WORD);\n+  /* At this point the stack pointer must be valid, and we must have\n+     restored all of the registers.  We may not have deallocated the\n+     entire stack frame.  We've delayed this until now because it may\n+     be possible to merge the local stack deallocation with the\n+     deallocation forced by ix86_static_chain_on_stack.   */\n   gcc_assert (m->fs.sp_valid);\n   gcc_assert (!m->fs.fp_valid);\n   gcc_assert (!m->fs.realigned);\n+  if (m->fs.sp_offset != UNITS_PER_WORD)\n+    {\n+      pro_epilogue_adjust_stack (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\t GEN_INT (m->fs.sp_offset - UNITS_PER_WORD),\n+\t\t\t\t style, true);\n+    }\n \n   /* Sibcall epilogues don't want a return instruction.  */\n   if (style == 0)"}]}