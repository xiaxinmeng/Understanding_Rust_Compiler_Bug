{"sha": "524af0d6c72031c249aa737945fde6ac3d726ba2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTI0YWYwZDZjNzIwMzFjMjQ5YWE3Mzc5NDVmZGU2YWMzZDcyNmJhMg==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2013-04-10T21:36:58Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2013-04-10T21:36:58Z"}, "message": "Replace enum gfc_try with bool type.\n\n2013-04-11  Janne Blomqvist  <jb@gcc.gnu.org>\n\n        * gfortran.h: Remove enum gfc_try, replace gfc_try with bool type.\n        * arith.c: Replace gfc_try with bool type.\n        * array.c: Likewise.\n        * check.c: Likewise.\n        * class.c: Likewise.\n        * cpp.c: Likewise.\n        * cpp.h: Likewise.\n        * data.c: Likewise.\n        * data.h: Likewise.\n        * decl.c: Likewise.\n        * error.c: Likewise.\n        * expr.c: Likewise.\n        * f95-lang.c: Likewise.\n        * interface.c: Likewise.\n        * intrinsic.c: Likewise.\n        * intrinsic.h: Likewise.\n        * io.c: Likewise.\n        * match.c: Likewise.\n        * match.h: Likewise.\n        * module.c: Likewise.\n        * openmp.c: Likewise.\n        * parse.c: Likewise.\n        * parse.h: Likewise.\n        * primary.c: Likewise.\n        * resolve.c: Likewise.\n        * scanner.c: Likewise.\n        * simplify.c: Likewise.\n        * symbol.c: Likewise.\n        * trans-intrinsic.c: Likewise.\n        * trans-openmp.c: Likewise.\n        * trans-stmt.c: Likewise.\n        * trans-types.c: Likewise.\n\nFrom-SVN: r197682", "tree": {"sha": "3848fcd998968ff83378e8ad827c05578ce1d1fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3848fcd998968ff83378e8ad827c05578ce1d1fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/524af0d6c72031c249aa737945fde6ac3d726ba2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/524af0d6c72031c249aa737945fde6ac3d726ba2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/524af0d6c72031c249aa737945fde6ac3d726ba2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/524af0d6c72031c249aa737945fde6ac3d726ba2/comments", "author": null, "committer": null, "parents": [{"sha": "0ea8a6f9c72e6e8bf22a0f6da9295aed27e1ca1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ea8a6f9c72e6e8bf22a0f6da9295aed27e1ca1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ea8a6f9c72e6e8bf22a0f6da9295aed27e1ca1e"}], "stats": {"total": 9838, "additions": 4849, "deletions": 4989}, "files": [{"sha": "e6ec4f4bd16f54ec5aab10a48f4cc1ff7fcca928", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=524af0d6c72031c249aa737945fde6ac3d726ba2", "patch": "@@ -1,3 +1,38 @@\n+2013-04-11  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+        * gfortran.h: Remove enum gfc_try, replace gfc_try with bool type.\n+        * arith.c: Replace gfc_try with bool type.\n+        * array.c: Likewise.\n+        * check.c: Likewise.\n+        * class.c: Likewise.\n+        * cpp.c: Likewise.\n+        * cpp.h: Likewise.\n+        * data.c: Likewise.\n+        * data.h: Likewise.\n+        * decl.c: Likewise.\n+        * error.c: Likewise.\n+        * expr.c: Likewise.\n+        * f95-lang.c: Likewise.\n+        * interface.c: Likewise.\n+        * intrinsic.c: Likewise.\n+        * intrinsic.h: Likewise.\n+        * io.c: Likewise.\n+        * match.c: Likewise.\n+        * match.h: Likewise.\n+        * module.c: Likewise.\n+        * openmp.c: Likewise.\n+        * parse.c: Likewise.\n+        * parse.h: Likewise.\n+        * primary.c: Likewise.\n+        * resolve.c: Likewise.\n+        * scanner.c: Likewise.\n+        * simplify.c: Likewise.\n+        * symbol.c: Likewise.\n+        * trans-intrinsic.c: Likewise.\n+        * trans-openmp.c: Likewise.\n+        * trans-stmt.c: Likewise.\n+        * trans-types.c: Likewise.\n+\n 2013-04-09  Tobias Burnus  <burnus@net-b.de>\n \n \t* gfortran.texi (KIND Type Parameters,"}, {"sha": "3339585988a5db3aac00606d819b7b2a40245213", "filename": "gcc/fortran/arith.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Farith.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Farith.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farith.c?ref=524af0d6c72031c249aa737945fde6ac3d726ba2", "patch": "@@ -901,9 +901,9 @@ arith_power (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n \n       if (gfc_init_expr_flag)\n \t{\n-\t  if (gfc_notify_std (GFC_STD_F2003, \"Noninteger \"\n-\t\t\t      \"exponent in an initialization \"\n-\t\t\t      \"expression at %L\", &op2->where) == FAILURE)\n+\t  if (!gfc_notify_std (GFC_STD_F2003, \"Noninteger \"\n+\t\t\t       \"exponent in an initialization \"\n+\t\t\t       \"expression at %L\", &op2->where))\n \t    {\n \t      gfc_free_expr (result);\n \t      return ARITH_PROHIBIT;\n@@ -926,9 +926,9 @@ arith_power (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n       {\n \tif (gfc_init_expr_flag)\n \t  {\n-\t    if (gfc_notify_std (GFC_STD_F2003, \"Noninteger \"\n-\t\t\t\t\"exponent in an initialization \"\n-\t\t\t\t\"expression at %L\", &op2->where) == FAILURE)\n+\t    if (!gfc_notify_std (GFC_STD_F2003, \"Noninteger \"\n+\t\t\t\t \"exponent in an initialization \"\n+\t\t\t\t \"expression at %L\", &op2->where))\n \t      {\n \t\tgfc_free_expr (result);\n \t\treturn ARITH_PROHIBIT;\n@@ -1347,8 +1347,7 @@ reduce_binary_aa (arith (*eval) (gfc_expr *, gfc_expr *, gfc_expr **),\n   gfc_expr *r;\n   arith rc = ARITH_OK;\n \n-  if (gfc_check_conformance (op1, op2,\n-\t\t\t     \"elemental binary operation\") != SUCCESS)\n+  if (!gfc_check_conformance (op1, op2, \"elemental binary operation\"))\n     return ARITH_INCOMMENSURATE;\n \n   head = gfc_constructor_copy (op1->value.constructor);"}, {"sha": "c2ac1ece1e652010ff9675242784f5d07e898537", "filename": "gcc/fortran/array.c", "status": "modified", "additions": 175, "deletions": 180, "changes": 355, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Farray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Farray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farray.c?ref=524af0d6c72031c249aa737945fde6ac3d726ba2", "patch": "@@ -300,15 +300,15 @@ gfc_free_array_spec (gfc_array_spec *as)\n /* Take an array bound, resolves the expression, that make up the\n    shape and check associated constraints.  */\n \n-static gfc_try\n+static bool\n resolve_array_bound (gfc_expr *e, int check_constant)\n {\n   if (e == NULL)\n-    return SUCCESS;\n+    return true;\n \n-  if (gfc_resolve_expr (e) == FAILURE\n-      || gfc_specification_expr (e) == FAILURE)\n-    return FAILURE;\n+  if (!gfc_resolve_expr (e)\n+      || !gfc_specification_expr (e))\n+    return false;\n \n   if (check_constant && !gfc_is_constant_expr (e))\n     {\n@@ -318,34 +318,34 @@ resolve_array_bound (gfc_expr *e, int check_constant)\n       else\n \tgfc_error (\"Expression at %L in this context must be constant\",\n \t\t   &e->where);\n-      return FAILURE;\n+      return false;\n     }\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n /* Takes an array specification, resolves the expressions that make up\n    the shape and make sure everything is integral.  */\n \n-gfc_try\n+bool\n gfc_resolve_array_spec (gfc_array_spec *as, int check_constant)\n {\n   gfc_expr *e;\n   int i;\n \n   if (as == NULL)\n-    return SUCCESS;\n+    return true;\n \n   for (i = 0; i < as->rank + as->corank; i++)\n     {\n       e = as->lower[i];\n-      if (resolve_array_bound (e, check_constant) == FAILURE)\n-\treturn FAILURE;\n+      if (!resolve_array_bound (e, check_constant))\n+\treturn false;\n \n       e = as->upper[i];\n-      if (resolve_array_bound (e, check_constant) == FAILURE)\n-\treturn FAILURE;\n+      if (!resolve_array_bound (e, check_constant))\n+\treturn false;\n \n       if ((as->lower[i] == NULL) || (as->upper[i] == NULL))\n \tcontinue;\n@@ -363,7 +363,7 @@ gfc_resolve_array_spec (gfc_array_spec *as, int check_constant)\n \t}\n     }\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n@@ -412,7 +412,7 @@ match_array_element_spec (gfc_array_spec *as)\n     gfc_error (\"Expected expression in array specification at %C\");\n   if (m != MATCH_YES)\n     return AS_UNKNOWN;\n-  if (gfc_expr_check_typed (*upper, gfc_current_ns, false) == FAILURE)\n+  if (!gfc_expr_check_typed (*upper, gfc_current_ns, false))\n     return AS_UNKNOWN;\n \n   if (gfc_match_char (':') == MATCH_NO)\n@@ -432,7 +432,7 @@ match_array_element_spec (gfc_array_spec *as)\n     return AS_UNKNOWN;\n   if (m == MATCH_NO)\n     return AS_ASSUMED_SHAPE;\n-  if (gfc_expr_check_typed (*upper, gfc_current_ns, false) == FAILURE)\n+  if (!gfc_expr_check_typed (*upper, gfc_current_ns, false))\n     return AS_UNKNOWN;\n \n   return AS_EXPLICIT;\n@@ -467,8 +467,7 @@ gfc_match_array_spec (gfc_array_spec **asp, bool match_dim, bool match_codim)\n       as->type = AS_ASSUMED_RANK;\n       as->rank = -1;\n \n-      if (gfc_notify_std (GFC_STD_F2008_TS, \"Assumed-rank array at %C\")\n-\t  == FAILURE)\n+      if (!gfc_notify_std (GFC_STD_F2008_TS, \"Assumed-rank array at %C\"))\n \tgoto cleanup;\n \n       if (!match_codim)\n@@ -576,9 +575,8 @@ gfc_match_array_spec (gfc_array_spec **asp, bool match_dim, bool match_codim)\n \t}\n \n       if (as->corank + as->rank >= 7\n-\t  && gfc_notify_std (GFC_STD_F2008, \"Array \"\n-\t\t\t     \"specification at %C with more than 7 dimensions\")\n-\t     == FAILURE)\n+\t  && !gfc_notify_std (GFC_STD_F2008, \"Array specification at %C \"\n+\t\t\t      \"with more than 7 dimensions\"))\n \tgoto cleanup;\n     }\n \n@@ -589,8 +587,7 @@ gfc_match_array_spec (gfc_array_spec **asp, bool match_dim, bool match_codim)\n   if (gfc_match_char ('[')  != MATCH_YES)\n     goto done;\n \n-  if (gfc_notify_std (GFC_STD_F2008, \"Coarray declaration at %C\")\n-      == FAILURE)\n+  if (!gfc_notify_std (GFC_STD_F2008, \"Coarray declaration at %C\"))\n     goto cleanup;\n \n   if (gfc_option.coarray == GFC_FCOARRAY_NONE)\n@@ -730,34 +727,34 @@ gfc_match_array_spec (gfc_array_spec **asp, bool match_dim, bool match_codim)\n    have that array specification.  The error locus is needed in case\n    something goes wrong.  On failure, the caller must free the spec.  */\n \n-gfc_try\n+bool\n gfc_set_array_spec (gfc_symbol *sym, gfc_array_spec *as, locus *error_loc)\n {\n   int i;\n \n   if (as == NULL)\n-    return SUCCESS;\n+    return true;\n \n   if (as->rank\n-      && gfc_add_dimension (&sym->attr, sym->name, error_loc) == FAILURE)\n-    return FAILURE;\n+      && !gfc_add_dimension (&sym->attr, sym->name, error_loc))\n+    return false;\n \n   if (as->corank\n-      && gfc_add_codimension (&sym->attr, sym->name, error_loc) == FAILURE)\n-    return FAILURE;\n+      && !gfc_add_codimension (&sym->attr, sym->name, error_loc))\n+    return false;\n \n   if (sym->as == NULL)\n     {\n       sym->as = as;\n-      return SUCCESS;\n+      return true;\n     }\n \n   if ((sym->as->type == AS_ASSUMED_RANK && as->corank)\n       || (as->type == AS_ASSUMED_RANK && sym->as->corank))\n     {\n       gfc_error (\"The assumed-rank array '%s' at %L shall not have a \"\n \t\t \"codimension\", sym->name, error_loc);\n-      return FAILURE;\n+      return false;\n     }\n \n   if (as->corank)\n@@ -799,7 +796,7 @@ gfc_set_array_spec (gfc_symbol *sym, gfc_array_spec *as, locus *error_loc)\n     }\n \n   free (as);\n-  return SUCCESS;\n+  return true;\n }\n \n \n@@ -1060,8 +1057,8 @@ gfc_match_array_constructor (gfc_expr **result)\n \treturn MATCH_NO;\n       else\n \t{\n-\t  if (gfc_notify_std (GFC_STD_F2003, \"[...] \"\n-\t\t\t      \"style array constructors at %C\") == FAILURE)\n+\t  if (!gfc_notify_std (GFC_STD_F2003, \"[...] \"\n+\t\t\t       \"style array constructors at %C\"))\n \t    return MATCH_ERROR;\n \t  end_delim = \" ]\";\n \t}\n@@ -1082,8 +1079,8 @@ gfc_match_array_constructor (gfc_expr **result)\n \n       if (seen_ts)\n \t{\n-\t  if (gfc_notify_std (GFC_STD_F2003, \"Array constructor \"\n-\t\t\t      \"including type specification at %C\") == FAILURE)\n+\t  if (!gfc_notify_std (GFC_STD_F2003, \"Array constructor \"\n+\t\t\t       \"including type specification at %C\"))\n \t    {\n \t      gfc_restore_last_undo_checkpoint ();\n \t      goto cleanup;\n@@ -1196,7 +1193,7 @@ check_element_type (gfc_expr *expr, bool convert)\n     return 0;\n \n   if (convert)\n-    return gfc_convert_type (expr, &constructor_ts, 1) == SUCCESS ? 0 : 1;\n+    return gfc_convert_type(expr, &constructor_ts, 1) ? 0 : 1;\n \n   gfc_error (\"Element in %s array constructor at %L is %s\",\n \t     gfc_typename (&constructor_ts), &expr->where,\n@@ -1209,7 +1206,7 @@ check_element_type (gfc_expr *expr, bool convert)\n \n /* Recursive work function for gfc_check_constructor_type().  */\n \n-static gfc_try\n+static bool\n check_constructor_type (gfc_constructor_base base, bool convert)\n {\n   gfc_constructor *c;\n@@ -1221,27 +1218,27 @@ check_constructor_type (gfc_constructor_base base, bool convert)\n \n       if (e->expr_type == EXPR_ARRAY)\n \t{\n-\t  if (check_constructor_type (e->value.constructor, convert) == FAILURE)\n-\t    return FAILURE;\n+\t  if (!check_constructor_type (e->value.constructor, convert))\n+\t    return false;\n \n \t  continue;\n \t}\n \n       if (check_element_type (e, convert))\n-\treturn FAILURE;\n+\treturn false;\n     }\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n /* Check that all elements of an array constructor are the same type.\n-   On FAILURE, an error has been generated.  */\n+   On false, an error has been generated.  */\n \n-gfc_try\n+bool\n gfc_check_constructor_type (gfc_expr *e)\n {\n-  gfc_try t;\n+  bool t;\n \n   if (e->ts.type != BT_UNKNOWN)\n     {\n@@ -1257,7 +1254,7 @@ gfc_check_constructor_type (gfc_expr *e)\n   /* If e->ts.type != BT_UNKNOWN, the array constructor included a\n      typespec, and we will now convert the values on the fly.  */\n   t = check_constructor_type (e->value.constructor, e->ts.type != BT_UNKNOWN);\n-  if (t == SUCCESS && e->ts.type == BT_UNKNOWN)\n+  if (t && e->ts.type == BT_UNKNOWN)\n     e->ts = constructor_ts;\n \n   return t;\n@@ -1274,12 +1271,12 @@ cons_stack;\n \n static cons_stack *base;\n \n-static gfc_try check_constructor (gfc_constructor_base, gfc_try (*) (gfc_expr *));\n+static bool check_constructor (gfc_constructor_base, bool (*) (gfc_expr *));\n \n /* Check an EXPR_VARIABLE expression in a constructor to make sure\n    that that variable is an iteration variables.  */\n \n-gfc_try\n+bool\n gfc_check_iter_variable (gfc_expr *expr)\n {\n   gfc_symbol *sym;\n@@ -1289,22 +1286,22 @@ gfc_check_iter_variable (gfc_expr *expr)\n \n   for (c = base; c && c->iterator; c = c->previous)\n     if (sym == c->iterator->var->symtree->n.sym)\n-      return SUCCESS;\n+      return true;\n \n-  return FAILURE;\n+  return false;\n }\n \n \n /* Recursive work function for gfc_check_constructor().  This amounts\n    to calling the check function for each expression in the\n    constructor, giving variables with the names of iterators a pass.  */\n \n-static gfc_try\n-check_constructor (gfc_constructor_base ctor, gfc_try (*check_function) (gfc_expr *))\n+static bool\n+check_constructor (gfc_constructor_base ctor, bool (*check_function) (gfc_expr *))\n {\n   cons_stack element;\n   gfc_expr *e;\n-  gfc_try t;\n+  bool t;\n   gfc_constructor *c;\n \n   for (c = gfc_constructor_first (ctor); c; c = gfc_constructor_next (c))\n@@ -1313,8 +1310,8 @@ check_constructor (gfc_constructor_base ctor, gfc_try (*check_function) (gfc_exp\n \n       if (e->expr_type != EXPR_ARRAY)\n \t{\n-\t  if ((*check_function) (e) == FAILURE)\n-\t    return FAILURE;\n+\t  if (!(*check_function)(e))\n+\t    return false;\n \t  continue;\n \t}\n \n@@ -1325,24 +1322,24 @@ check_constructor (gfc_constructor_base ctor, gfc_try (*check_function) (gfc_exp\n       t = check_constructor (e->value.constructor, check_function);\n       base = element.previous;\n \n-      if (t == FAILURE)\n-\treturn FAILURE;\n+      if (!t)\n+\treturn false;\n     }\n \n   /* Nothing went wrong, so all OK.  */\n-  return SUCCESS;\n+  return true;\n }\n \n \n /* Checks a constructor to see if it is a particular kind of\n    expression -- specification, restricted, or initialization as\n    determined by the check_function.  */\n \n-gfc_try\n-gfc_check_constructor (gfc_expr *expr, gfc_try (*check_function) (gfc_expr *))\n+bool\n+gfc_check_constructor (gfc_expr *expr, bool (*check_function) (gfc_expr *))\n {\n   cons_stack *base_save;\n-  gfc_try t;\n+  bool t;\n \n   base_save = base;\n   base = NULL;\n@@ -1370,19 +1367,19 @@ typedef struct\n   gfc_component *component;\n   mpz_t *repeat;\n \n-  gfc_try (*expand_work_function) (gfc_expr *);\n+  bool (*expand_work_function) (gfc_expr *);\n }\n expand_info;\n \n static expand_info current_expand;\n \n-static gfc_try expand_constructor (gfc_constructor_base);\n+static bool expand_constructor (gfc_constructor_base);\n \n \n /* Work function that counts the number of elements present in a\n    constructor.  */\n \n-static gfc_try\n+static bool\n count_elements (gfc_expr *e)\n {\n   mpz_t result;\n@@ -1391,31 +1388,31 @@ count_elements (gfc_expr *e)\n     mpz_add_ui (*current_expand.count, *current_expand.count, 1);\n   else\n     {\n-      if (gfc_array_size (e, &result) == FAILURE)\n+      if (!gfc_array_size (e, &result))\n \t{\n \t  gfc_free_expr (e);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n \n       mpz_add (*current_expand.count, *current_expand.count, result);\n       mpz_clear (result);\n     }\n \n   gfc_free_expr (e);\n-  return SUCCESS;\n+  return true;\n }\n \n \n /* Work function that extracts a particular element from an array\n    constructor, freeing the rest.  */\n \n-static gfc_try\n+static bool\n extract_element (gfc_expr *e)\n {\n   if (e->rank != 0)\n     {\t\t\t\t/* Something unextractable */\n       gfc_free_expr (e);\n-      return FAILURE;\n+      return false;\n     }\n \n   if (current_expand.extract_count == current_expand.extract_n)\n@@ -1425,21 +1422,21 @@ extract_element (gfc_expr *e)\n \n   current_expand.extract_count++;\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n /* Work function that constructs a new constructor out of the old one,\n    stringing new elements together.  */\n \n-static gfc_try\n+static bool\n expand (gfc_expr *e)\n {\n   gfc_constructor *c = gfc_constructor_append_expr (&current_expand.base,\n \t\t\t\t\t\t    e, &e->where);\n \n   c->n.component = current_expand.component;\n-  return SUCCESS;\n+  return true;\n }\n \n \n@@ -1469,56 +1466,56 @@ gfc_simplify_iterator_var (gfc_expr *e)\n /* Expand an expression with that is inside of a constructor,\n    recursing into other constructors if present.  */\n \n-static gfc_try\n+static bool\n expand_expr (gfc_expr *e)\n {\n   if (e->expr_type == EXPR_ARRAY)\n     return expand_constructor (e->value.constructor);\n \n   e = gfc_copy_expr (e);\n \n-  if (gfc_simplify_expr (e, 1) == FAILURE)\n+  if (!gfc_simplify_expr (e, 1))\n     {\n       gfc_free_expr (e);\n-      return FAILURE;\n+      return false;\n     }\n \n   return current_expand.expand_work_function (e);\n }\n \n \n-static gfc_try\n+static bool\n expand_iterator (gfc_constructor *c)\n {\n   gfc_expr *start, *end, *step;\n   iterator_stack frame;\n   mpz_t trip;\n-  gfc_try t;\n+  bool t;\n \n   end = step = NULL;\n \n-  t = FAILURE;\n+  t = false;\n \n   mpz_init (trip);\n   mpz_init (frame.value);\n   frame.prev = NULL;\n \n   start = gfc_copy_expr (c->iterator->start);\n-  if (gfc_simplify_expr (start, 1) == FAILURE)\n+  if (!gfc_simplify_expr (start, 1))\n     goto cleanup;\n \n   if (start->expr_type != EXPR_CONSTANT || start->ts.type != BT_INTEGER)\n     goto cleanup;\n \n   end = gfc_copy_expr (c->iterator->end);\n-  if (gfc_simplify_expr (end, 1) == FAILURE)\n+  if (!gfc_simplify_expr (end, 1))\n     goto cleanup;\n \n   if (end->expr_type != EXPR_CONSTANT || end->ts.type != BT_INTEGER)\n     goto cleanup;\n \n   step = gfc_copy_expr (c->iterator->step);\n-  if (gfc_simplify_expr (step, 1) == FAILURE)\n+  if (!gfc_simplify_expr (step, 1))\n     goto cleanup;\n \n   if (step->expr_type != EXPR_CONSTANT || step->ts.type != BT_INTEGER)\n@@ -1543,14 +1540,14 @@ expand_iterator (gfc_constructor *c)\n \n   while (mpz_sgn (trip) > 0)\n     {\n-      if (expand_expr (c->expr) == FAILURE)\n+      if (!expand_expr (c->expr))\n \tgoto cleanup;\n \n       mpz_add (frame.value, frame.value, step->value.integer);\n       mpz_sub_ui (trip, trip, 1);\n     }\n \n-  t = SUCCESS;\n+  t = true;\n \n cleanup:\n   gfc_free_expr (start);\n@@ -1571,7 +1568,7 @@ expand_iterator (gfc_constructor *c)\n    expressions.  The work function needs to either save or free the\n    passed expression.  */\n \n-static gfc_try\n+static bool\n expand_constructor (gfc_constructor_base base)\n {\n   gfc_constructor *c;\n@@ -1581,34 +1578,34 @@ expand_constructor (gfc_constructor_base base)\n     {\n       if (c->iterator != NULL)\n \t{\n-\t  if (expand_iterator (c) == FAILURE)\n-\t    return FAILURE;\n+\t  if (!expand_iterator (c))\n+\t    return false;\n \t  continue;\n \t}\n \n       e = c->expr;\n \n       if (e->expr_type == EXPR_ARRAY)\n \t{\n-\t  if (expand_constructor (e->value.constructor) == FAILURE)\n-\t    return FAILURE;\n+\t  if (!expand_constructor (e->value.constructor))\n+\t    return false;\n \n \t  continue;\n \t}\n \n       e = gfc_copy_expr (e);\n-      if (gfc_simplify_expr (e, 1) == FAILURE)\n+      if (!gfc_simplify_expr (e, 1))\n \t{\n \t  gfc_free_expr (e);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n       current_expand.offset = &c->offset;\n       current_expand.repeat = &c->repeat;\n       current_expand.component = c->n.component;\n-      if (current_expand.expand_work_function (e) == FAILURE)\n-\treturn FAILURE;\n+      if (!current_expand.expand_work_function(e))\n+\treturn false;\n     }\n-  return SUCCESS;\n+  return true;\n }\n \n \n@@ -1624,7 +1621,7 @@ gfc_get_array_element (gfc_expr *array, int element)\n {\n   expand_info expand_save;\n   gfc_expr *e;\n-  gfc_try rc;\n+  bool rc;\n \n   expand_save = current_expand;\n   current_expand.extract_n = element;\n@@ -1638,7 +1635,7 @@ gfc_get_array_element (gfc_expr *array, int element)\n   e = current_expand.extracted;\n   current_expand = expand_save;\n \n-  if (rc == FAILURE)\n+  if (!rc)\n     return NULL;\n \n   return e;\n@@ -1648,12 +1645,12 @@ gfc_get_array_element (gfc_expr *array, int element)\n /* Top level subroutine for expanding constructors.  We only expand\n    constructor if they are small enough.  */\n \n-gfc_try\n+bool\n gfc_expand_constructor (gfc_expr *e, bool fatal)\n {\n   expand_info expand_save;\n   gfc_expr *f;\n-  gfc_try rc;\n+  bool rc;\n \n   /* If we can successfully get an array element at the max array size then\n      the array is too big to expand, so we just return.  */\n@@ -1668,9 +1665,9 @@ gfc_expand_constructor (gfc_expr *e, bool fatal)\n \t\t     \"upper limit.   See -fmax-array-constructor \"\n \t\t     \"option\", &e->where,\n \t\t     gfc_option.flag_max_array_constructor);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n-      return SUCCESS;\n+      return true;\n     }\n \n   /* We now know the array is not too big so go ahead and try to expand it.  */\n@@ -1681,17 +1678,17 @@ gfc_expand_constructor (gfc_expr *e, bool fatal)\n \n   current_expand.expand_work_function = expand;\n \n-  if (expand_constructor (e->value.constructor) == FAILURE)\n+  if (!expand_constructor (e->value.constructor))\n     {\n       gfc_constructor_free (current_expand.base);\n-      rc = FAILURE;\n+      rc = false;\n       goto done;\n     }\n \n   gfc_constructor_free (e->value.constructor);\n   e->value.constructor = current_expand.base;\n \n-  rc = SUCCESS;\n+  rc = true;\n \n done:\n   current_expand = expand_save;\n@@ -1702,17 +1699,17 @@ gfc_expand_constructor (gfc_expr *e, bool fatal)\n \n /* Work function for checking that an element of a constructor is a\n    constant, after removal of any iteration variables.  We return\n-   FAILURE if not so.  */\n+   false if not so.  */\n \n-static gfc_try\n+static bool\n is_constant_element (gfc_expr *e)\n {\n   int rv;\n \n   rv = gfc_is_constant_expr (e);\n   gfc_free_expr (e);\n \n-  return rv ? SUCCESS : FAILURE;\n+  return rv ? true : false;\n }\n \n \n@@ -1726,7 +1723,7 @@ int\n gfc_constant_ac (gfc_expr *e)\n {\n   expand_info expand_save;\n-  gfc_try rc;\n+  bool rc;\n \n   iter_stack = NULL;\n   expand_save = current_expand;\n@@ -1735,7 +1732,7 @@ gfc_constant_ac (gfc_expr *e)\n   rc = expand_constructor (e->value.constructor);\n \n   current_expand = expand_save;\n-  if (rc == FAILURE)\n+  if (!rc)\n     return 0;\n \n   return 1;\n@@ -1809,14 +1806,14 @@ find_symbol_in_expr (gfc_symbol *sym, gfc_expr *expr, locus *sym_loc)\n /* Recursive array list resolution function.  All of the elements must\n    be of the same type.  */\n \n-static gfc_try\n+static bool\n resolve_array_list (gfc_constructor_base base)\n {\n-  gfc_try t;\n+  bool t;\n   gfc_constructor *c;\n   gfc_iterator *iter;\n \n-  t = SUCCESS;\n+  t = true;\n \n   for (c = gfc_constructor_first (base); c; c = gfc_constructor_next (c))\n     {\n@@ -1826,43 +1823,43 @@ resolve_array_list (gfc_constructor_base base)\n \t  gfc_symbol *iter_var;\n \t  locus iter_var_loc;\n \n-\t  if (gfc_resolve_iterator (iter, false, true) == FAILURE)\n-\t    t = FAILURE;\n+\t  if (!gfc_resolve_iterator (iter, false, true))\n+\t    t = false;\n \n \t  /* Check for bounds referencing the iterator variable.  */\n \t  gcc_assert (iter->var->expr_type == EXPR_VARIABLE);\n \t  iter_var = iter->var->symtree->n.sym;\n \t  if (find_symbol_in_expr (iter_var, iter->start, &iter_var_loc))\n \t    {\n-\t      if (gfc_notify_std (GFC_STD_LEGACY, \"AC-IMPLIED-DO initial \"\n-\t\t\t\t  \"expression references control variable \"\n-\t\t\t\t  \"at %L\", &iter_var_loc) == FAILURE)\n-\t       t = FAILURE;\n+\t      if (!gfc_notify_std (GFC_STD_LEGACY, \"AC-IMPLIED-DO initial \"\n+\t\t\t\t   \"expression references control variable \"\n+\t\t\t\t   \"at %L\", &iter_var_loc))\n+\t       t = false;\n \t    }\n \t  if (find_symbol_in_expr (iter_var, iter->end, &iter_var_loc))\n \t    {\n-\t      if (gfc_notify_std (GFC_STD_LEGACY, \"AC-IMPLIED-DO final \"\n-\t\t\t\t  \"expression references control variable \"\n-\t\t\t\t  \"at %L\", &iter_var_loc) == FAILURE)\n-\t       t = FAILURE;\n+\t      if (!gfc_notify_std (GFC_STD_LEGACY, \"AC-IMPLIED-DO final \"\n+\t\t\t\t   \"expression references control variable \"\n+\t\t\t\t   \"at %L\", &iter_var_loc))\n+\t       t = false;\n \t    }\n \t  if (find_symbol_in_expr (iter_var, iter->step, &iter_var_loc))\n \t    {\n-\t      if (gfc_notify_std (GFC_STD_LEGACY, \"AC-IMPLIED-DO step \"\n-\t\t\t\t  \"expression references control variable \"\n-\t\t\t\t  \"at %L\", &iter_var_loc) == FAILURE)\n-\t       t = FAILURE;\n+\t      if (!gfc_notify_std (GFC_STD_LEGACY, \"AC-IMPLIED-DO step \"\n+\t\t\t\t   \"expression references control variable \"\n+\t\t\t\t   \"at %L\", &iter_var_loc))\n+\t       t = false;\n \t    }\n \t}\n \n-      if (gfc_resolve_expr (c->expr) == FAILURE)\n-\tt = FAILURE;\n+      if (!gfc_resolve_expr (c->expr))\n+\tt = false;\n \n       if (UNLIMITED_POLY (c->expr))\n \t{\n \t  gfc_error (\"Array constructor value at %L shall not be unlimited \"\n \t\t     \"polymorphic [F2008: C4106]\", &c->expr->where);\n-\t  t = FAILURE;\n+\t  t = false;\n \t}\n     }\n \n@@ -1874,7 +1871,7 @@ resolve_array_list (gfc_constructor_base base)\n    all elements are of compile-time known length, emit an error as this is\n    invalid.  */\n \n-gfc_try\n+bool\n gfc_resolve_character_array_constructor (gfc_expr *expr)\n {\n   gfc_constructor *p;\n@@ -1935,7 +1932,7 @@ gfc_resolve_character_array_constructor (gfc_expr *expr)\n \t      current_length = (int) j;\n \t    }\n \t  else\n-\t    return SUCCESS;\n+\t    return true;\n \n \t  gcc_assert (current_length != -1);\n \n@@ -1946,7 +1943,7 @@ gfc_resolve_character_array_constructor (gfc_expr *expr)\n \t      gfc_error (\"Different CHARACTER lengths (%d/%d) in array\"\n \t\t\t \" constructor at %L\", found_length, current_length,\n \t\t\t &p->expr->where);\n-\t      return FAILURE;\n+\t      return false;\n \t    }\n \n \t  gcc_assert (found_length == current_length);\n@@ -2000,19 +1997,19 @@ gfc_resolve_character_array_constructor (gfc_expr *expr)\n \t    }\n     }\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n /* Resolve all of the expressions in an array list.  */\n \n-gfc_try\n+bool\n gfc_resolve_array_constructor (gfc_expr *expr)\n {\n-  gfc_try t;\n+  bool t;\n \n   t = resolve_array_list (expr->value.constructor);\n-  if (t == SUCCESS)\n+  if (t)\n     t = gfc_check_constructor_type (expr);\n \n   /* gfc_resolve_character_array_constructor is called in gfc_resolve_expr after\n@@ -2054,11 +2051,11 @@ gfc_copy_iterator (gfc_iterator *src)\n /* Get the size of single dimension of an array specification.  The\n    array is guaranteed to be one dimensional.  */\n \n-gfc_try\n+bool\n spec_dimen_size (gfc_array_spec *as, int dimen, mpz_t *result)\n {\n   if (as == NULL)\n-    return FAILURE;\n+    return false;\n \n   if (dimen < 0 || dimen > as->rank - 1)\n     gfc_internal_error (\"spec_dimen_size(): Bad dimension\");\n@@ -2068,7 +2065,7 @@ spec_dimen_size (gfc_array_spec *as, int dimen, mpz_t *result)\n       || as->upper[dimen]->expr_type != EXPR_CONSTANT\n       || as->lower[dimen]->ts.type != BT_INTEGER\n       || as->upper[dimen]->ts.type != BT_INTEGER)\n-    return FAILURE;\n+    return false;\n \n   mpz_init (*result);\n \n@@ -2077,45 +2074,45 @@ spec_dimen_size (gfc_array_spec *as, int dimen, mpz_t *result)\n \n   mpz_add_ui (*result, *result, 1);\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n-gfc_try\n+bool\n spec_size (gfc_array_spec *as, mpz_t *result)\n {\n   mpz_t size;\n   int d;\n \n   if (as->type == AS_ASSUMED_RANK)\n-    return FAILURE;\n+    return false;\n \n   mpz_init_set_ui (*result, 1);\n \n   for (d = 0; d < as->rank; d++)\n     {\n-      if (spec_dimen_size (as, d, &size) == FAILURE)\n+      if (!spec_dimen_size (as, d, &size))\n \t{\n \t  mpz_clear (*result);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n \n       mpz_mul (*result, *result, size);\n       mpz_clear (size);\n     }\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n /* Get the number of elements in an array section. Optionally, also supply\n    the end value.  */\n \n-gfc_try\n+bool\n gfc_ref_dimen_size (gfc_array_ref *ar, int dimen, mpz_t *result, mpz_t *end)\n {\n   mpz_t upper, lower, stride;\n-  gfc_try t;\n+  bool t;\n \n   if (dimen < 0 || ar == NULL || dimen > ar->dimen - 1)\n     gfc_internal_error (\"gfc_ref_dimen_size(): Bad dimension\");\n@@ -2125,7 +2122,7 @@ gfc_ref_dimen_size (gfc_array_ref *ar, int dimen, mpz_t *result, mpz_t *end)\n     case DIMEN_ELEMENT:\n       mpz_init (*result);\n       mpz_set_ui (*result, 1);\n-      t = SUCCESS;\n+      t = true;\n       break;\n \n     case DIMEN_VECTOR:\n@@ -2136,7 +2133,7 @@ gfc_ref_dimen_size (gfc_array_ref *ar, int dimen, mpz_t *result, mpz_t *end)\n       mpz_init (upper);\n       mpz_init (lower);\n       mpz_init (stride);\n-      t = FAILURE;\n+      t = false;\n \n       if (ar->start[dimen] == NULL)\n \t{\n@@ -2183,7 +2180,7 @@ gfc_ref_dimen_size (gfc_array_ref *ar, int dimen, mpz_t *result, mpz_t *end)\n       /* Zero stride caught earlier.  */\n       if (mpz_cmp_ui (*result, 0) < 0)\n \tmpz_set_ui (*result, 0);\n-      t = SUCCESS;\n+      t = true;\n \n       if (end)\n \t{\n@@ -2208,7 +2205,7 @@ gfc_ref_dimen_size (gfc_array_ref *ar, int dimen, mpz_t *result, mpz_t *end)\n }\n \n \n-static gfc_try\n+static bool\n ref_size (gfc_array_ref *ar, mpz_t *result)\n {\n   mpz_t size;\n@@ -2218,26 +2215,26 @@ ref_size (gfc_array_ref *ar, mpz_t *result)\n \n   for (d = 0; d < ar->dimen; d++)\n     {\n-      if (gfc_ref_dimen_size (ar, d, &size, NULL) == FAILURE)\n+      if (!gfc_ref_dimen_size (ar, d, &size, NULL))\n \t{\n \t  mpz_clear (*result);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n \n       mpz_mul (*result, *result, size);\n       mpz_clear (size);\n     }\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n /* Given an array expression and a dimension, figure out how many\n-   elements it has along that dimension.  Returns SUCCESS if we were\n-   able to return a result in the 'result' variable, FAILURE\n+   elements it has along that dimension.  Returns true if we were\n+   able to return a result in the 'result' variable, false\n    otherwise.  */\n \n-gfc_try\n+bool\n gfc_array_dimen_size (gfc_expr *array, int dimen, mpz_t *result)\n {\n   gfc_ref *ref;\n@@ -2246,10 +2243,10 @@ gfc_array_dimen_size (gfc_expr *array, int dimen, mpz_t *result)\n   gcc_assert (array != NULL);\n \n   if (array->ts.type == BT_CLASS)\n-    return FAILURE;\n+    return false;\n \n   if (array->rank == -1)\n-    return FAILURE;\n+    return false;\n \n   if (dimen < 0 || dimen > array->rank - 1)\n     gfc_internal_error (\"gfc_array_dimen_size(): Bad dimension\");\n@@ -2279,19 +2276,17 @@ gfc_array_dimen_size (gfc_expr *array, int dimen, mpz_t *result)\n       if (array->shape && array->shape[dimen])\n \t{\n \t  mpz_init_set (*result, array->shape[dimen]);\n-\t  return SUCCESS;\n+\t  return true;\n \t}\n \n       if (array->symtree->n.sym->attr.generic\n \t  && array->value.function.esym != NULL)\n \t{\n-\t  if (spec_dimen_size (array->value.function.esym->as, dimen, result)\n-\t      == FAILURE)\n-\t    return FAILURE;\n+\t  if (!spec_dimen_size (array->value.function.esym->as, dimen, result))\n+\t    return false;\n \t}\n-      else if (spec_dimen_size (array->symtree->n.sym->as, dimen, result)\n-\t       == FAILURE)\n-\treturn FAILURE;\n+      else if (!spec_dimen_size (array->symtree->n.sym->as, dimen, result))\n+\treturn false;\n \n       break;\n \n@@ -2306,31 +2301,31 @@ gfc_array_dimen_size (gfc_expr *array, int dimen, mpz_t *result)\n       /* Fall through */\n     default:\n       if (array->shape == NULL)\n-\treturn FAILURE;\n+\treturn false;\n \n       mpz_init_set (*result, array->shape[dimen]);\n \n       break;\n     }\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n /* Given an array expression, figure out how many elements are in the\n-   array.  Returns SUCCESS if this is possible, and sets the 'result'\n-   variable.  Otherwise returns FAILURE.  */\n+   array.  Returns true if this is possible, and sets the 'result'\n+   variable.  Otherwise returns false.  */\n \n-gfc_try\n+bool\n gfc_array_size (gfc_expr *array, mpz_t *result)\n {\n   expand_info expand_save;\n   gfc_ref *ref;\n   int i;\n-  gfc_try t;\n+  bool t;\n \n   if (array->ts.type == BT_CLASS)\n-    return FAILURE;\n+    return false;\n \n   switch (array->expr_type)\n     {\n@@ -2349,7 +2344,7 @@ gfc_array_size (gfc_expr *array, mpz_t *result)\n \n       gfc_pop_suppress_errors ();\n \n-      if (t == FAILURE)\n+      if (!t)\n \tmpz_clear (*result);\n       current_expand = expand_save;\n       return t;\n@@ -2372,7 +2367,7 @@ gfc_array_size (gfc_expr *array, mpz_t *result)\n \n     default:\n       if (array->rank == 0 || array->shape == NULL)\n-\treturn FAILURE;\n+\treturn false;\n \n       mpz_init_set_ui (*result, 1);\n \n@@ -2382,14 +2377,14 @@ gfc_array_size (gfc_expr *array, mpz_t *result)\n       break;\n     }\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n /* Given an array reference, return the shape of the reference in an\n    array of mpz_t integers.  */\n \n-gfc_try\n+bool\n gfc_array_ref_shape (gfc_array_ref *ar, mpz_t *shape)\n {\n   int d;\n@@ -2401,31 +2396,31 @@ gfc_array_ref_shape (gfc_array_ref *ar, mpz_t *shape)\n     {\n     case AR_FULL:\n       for (; d < ar->as->rank; d++)\n-\tif (spec_dimen_size (ar->as, d, &shape[d]) == FAILURE)\n+\tif (!spec_dimen_size (ar->as, d, &shape[d]))\n \t  goto cleanup;\n \n-      return SUCCESS;\n+      return true;\n \n     case AR_SECTION:\n       for (i = 0; i < ar->dimen; i++)\n \t{\n \t  if (ar->dimen_type[i] != DIMEN_ELEMENT)\n \t    {\n-\t      if (gfc_ref_dimen_size (ar, i, &shape[d], NULL) == FAILURE)\n+\t      if (!gfc_ref_dimen_size (ar, i, &shape[d], NULL))\n \t\tgoto cleanup;\n \t      d++;\n \t    }\n \t}\n \n-      return SUCCESS;\n+      return true;\n \n     default:\n       break;\n     }\n \n cleanup:\n   gfc_clear_shape (shape, d);\n-  return FAILURE;\n+  return false;\n }\n \n "}, {"sha": "870ca7571923c02fcfa29f715efc2acea05feb49", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 1877, "deletions": 1878, "changes": 3755, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=524af0d6c72031c249aa737945fde6ac3d726ba2"}, {"sha": "f3fe1781e6d645edb7db5457388c614e8a133b59", "filename": "gcc/fortran/class.c", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fclass.c?ref=524af0d6c72031c249aa737945fde6ac3d726ba2", "patch": "@@ -543,7 +543,7 @@ gfc_intrinsic_hash_value (gfc_typespec *ts)\n    which contains the declared type as '_data' component, plus a pointer\n    component '_vptr' which determines the dynamic type.  */\n \n-gfc_try\n+bool\n gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,\n \t\t\tgfc_array_spec **as, bool delayed_vtab)\n {\n@@ -560,19 +560,19 @@ gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,\n     {\n       gfc_error (\"Assumed size polymorphic objects or components, such \"\n \t\t \"as that at %C, have not yet been implemented\");\n-      return FAILURE;\n+      return false;\n     }\n \n   if (attr->class_ok)\n     /* Class container has already been built.  */\n-    return SUCCESS;\n+    return true;\n \n   attr->class_ok = attr->dummy || attr->pointer || attr->allocatable\n \t\t   || attr->select_type_temporary || attr->associate_var;\n \n   if (!attr->class_ok)\n     /* We can not build the class container yet.  */\n-    return SUCCESS;\n+    return true;\n \n   /* Determine the name of the encapsulating type.  */\n   rank = !(*as) || (*as)->rank == -1 ? GFC_MAX_DIMENSIONS : (*as)->rank;\n@@ -614,13 +614,13 @@ gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,\n       if (!ts->u.derived->attr.unlimited_polymorphic)\n \tfclass->attr.abstract = ts->u.derived->attr.abstract;\n       fclass->f2k_derived = gfc_get_namespace (NULL, 0);\n-      if (gfc_add_flavor (&fclass->attr, FL_DERIVED,\n-\t  NULL, &gfc_current_locus) == FAILURE)\n-\treturn FAILURE;\n+      if (!gfc_add_flavor (&fclass->attr, FL_DERIVED, NULL, \n+\t\t\t   &gfc_current_locus))\n+\treturn false;\n \n       /* Add component '_data'.  */\n-      if (gfc_add_component (fclass, \"_data\", &c) == FAILURE)\n-\treturn FAILURE;\n+      if (!gfc_add_component (fclass, \"_data\", &c))\n+\treturn false;\n       c->ts = *ts;\n       c->ts.type = BT_DERIVED;\n       c->attr.access = ACCESS_PRIVATE;\n@@ -636,8 +636,8 @@ gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,\n       c->initializer = NULL;\n \n       /* Add component '_vptr'.  */\n-      if (gfc_add_component (fclass, \"_vptr\", &c) == FAILURE)\n-\treturn FAILURE;\n+      if (!gfc_add_component (fclass, \"_vptr\", &c))\n+\treturn false;\n       c->ts.type = BT_DERIVED;\n       if (delayed_vtab\n \t  || (ts->u.derived->f2k_derived\n@@ -661,7 +661,7 @@ gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,\n \t{\n \t  gfc_error (\"Maximum extension level reached with type '%s' at %L\",\n \t\t     ts->u.derived->name, &ts->u.derived->declared_at);\n-\treturn FAILURE;\n+\treturn false;\n \t}\n \n       fclass->attr.extension = ts->u.derived->attr.extension + 1;\n@@ -672,7 +672,7 @@ gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,\n   ts->u.derived = fclass;\n   attr->allocatable = attr->pointer = attr->dimension = attr->codimension = 0;\n   (*as) = NULL;\n-  return SUCCESS;\n+  return true;\n }\n \n \n@@ -692,7 +692,7 @@ add_proc_comp (gfc_symbol *vtype, const char *name, gfc_typebound_proc *tb)\n   if (c == NULL)\n     {\n       /* Add procedure component.  */\n-      if (gfc_add_component (vtype, name, &c) == FAILURE)\n+      if (!gfc_add_component (vtype, name, &c))\n \treturn;\n \n       if (!c->tb)\n@@ -1724,7 +1724,7 @@ generate_finalization_wrapper (gfc_symbol *derived, gfc_namespace *ns,\n      DO idx = 1, rank\n        strides(idx) = _F._stride (array, dim=idx)\n        sizes(idx) = sizes(i-1) * size(array, dim=idx, kind=index_kind)\n-       if (strides(idx) /= sizes(i-1)) is_contiguous = .false.\n+       if (strides (idx) /= sizes(i-1)) is_contiguous = .false.\n      END DO.  */\n \n   /* Create loop.  */\n@@ -1811,7 +1811,7 @@ generate_finalization_wrapper (gfc_symbol *derived, gfc_namespace *ns,\n   block->expr2->value.op.op2->ts.kind = gfc_index_integer_kind;\n   block->expr2->ts = idx->ts;\n \n-  /* if (strides(idx) /= sizes(idx-1)) is_contiguous = .false.  */\n+  /* if (strides (idx) /= sizes(idx-1)) is_contiguous = .false.  */\n   block->next = XCNEW (gfc_code);\n   block = block->next;\n   block->loc = gfc_current_locus;\n@@ -2202,8 +2202,8 @@ gfc_find_derived_vtab (gfc_symbol *derived)\n \t{\n \t  gfc_get_symbol (name, ns, &vtab);\n \t  vtab->ts.type = BT_DERIVED;\n-\t  if (gfc_add_flavor (&vtab->attr, FL_VARIABLE, NULL,\n-\t                      &gfc_current_locus) == FAILURE)\n+\t  if (!gfc_add_flavor (&vtab->attr, FL_VARIABLE, NULL, \n+\t\t\t       &gfc_current_locus))\n \t    goto cleanup;\n \t  vtab->attr.target = 1;\n \t  vtab->attr.save = SAVE_IMPLICIT;\n@@ -2219,15 +2219,15 @@ gfc_find_derived_vtab (gfc_symbol *derived)\n \t      gfc_symbol *parent = NULL, *parent_vtab = NULL;\n \n \t      gfc_get_symbol (name, ns, &vtype);\n-\t      if (gfc_add_flavor (&vtype->attr, FL_DERIVED,\n-\t\t\t\t  NULL, &gfc_current_locus) == FAILURE)\n+\t      if (!gfc_add_flavor (&vtype->attr, FL_DERIVED, NULL, \n+\t\t\t\t   &gfc_current_locus))\n \t\tgoto cleanup;\n \t      vtype->attr.access = ACCESS_PUBLIC;\n \t      vtype->attr.vtype = 1;\n \t      gfc_set_sym_referenced (vtype);\n \n \t      /* Add component '_hash'.  */\n-\t      if (gfc_add_component (vtype, \"_hash\", &c) == FAILURE)\n+\t      if (!gfc_add_component (vtype, \"_hash\", &c))\n \t\tgoto cleanup;\n \t      c->ts.type = BT_INTEGER;\n \t      c->ts.kind = 4;\n@@ -2236,7 +2236,7 @@ gfc_find_derived_vtab (gfc_symbol *derived)\n \t\t\t\t\t\t NULL, derived->hash_value);\n \n \t      /* Add component '_size'.  */\n-\t      if (gfc_add_component (vtype, \"_size\", &c) == FAILURE)\n+\t      if (!gfc_add_component (vtype, \"_size\", &c))\n \t\tgoto cleanup;\n \t      c->ts.type = BT_INTEGER;\n \t      c->ts.kind = 4;\n@@ -2249,7 +2249,7 @@ gfc_find_derived_vtab (gfc_symbol *derived)\n \t\t\t\t\t\t NULL, 0);\n \n \t      /* Add component _extends.  */\n-\t      if (gfc_add_component (vtype, \"_extends\", &c) == FAILURE)\n+\t      if (!gfc_add_component (vtype, \"_extends\", &c))\n \t\tgoto cleanup;\n \t      c->attr.pointer = 1;\n \t      c->attr.access = ACCESS_PRIVATE;\n@@ -2286,7 +2286,7 @@ gfc_find_derived_vtab (gfc_symbol *derived)\n \t\t}\n \n \t      /* Add component _def_init.  */\n-\t      if (gfc_add_component (vtype, \"_def_init\", &c) == FAILURE)\n+\t      if (!gfc_add_component (vtype, \"_def_init\", &c))\n \t\tgoto cleanup;\n \t      c->attr.pointer = 1;\n \t      c->attr.artificial = 1;\n@@ -2315,7 +2315,7 @@ gfc_find_derived_vtab (gfc_symbol *derived)\n \t\t}\n \n \t      /* Add component _copy.  */\n-\t      if (gfc_add_component (vtype, \"_copy\", &c) == FAILURE)\n+\t      if (!gfc_add_component (vtype, \"_copy\", &c))\n \t\tgoto cleanup;\n \t      c->attr.proc_pointer = 1;\n \t      c->attr.access = ACCESS_PRIVATE;\n@@ -2385,7 +2385,7 @@ gfc_find_derived_vtab (gfc_symbol *derived)\n \t    /* FIXME: Enable ABI-breaking \"_final\" generation.  */\n \t    if (0)\n \t    {\n-\t      if (gfc_add_component (vtype, \"_final\", &c) == FAILURE)\n+\t      if (!gfc_add_component (vtype, \"_final\", &c))\n \t\tgoto cleanup;\n \t      c->attr.proc_pointer = 1;\n \t      c->attr.access = ACCESS_PRIVATE;\n@@ -2528,8 +2528,8 @@ gfc_find_intrinsic_vtab (gfc_typespec *ts)\n \t{\n \t  gfc_get_symbol (name, ns, &vtab);\n \t  vtab->ts.type = BT_DERIVED;\n-\t  if (gfc_add_flavor (&vtab->attr, FL_VARIABLE, NULL,\n-\t                      &gfc_current_locus) == FAILURE)\n+\t  if (!gfc_add_flavor (&vtab->attr, FL_VARIABLE, NULL, \n+\t\t\t       &gfc_current_locus))\n \t    goto cleanup;\n \t  vtab->attr.target = 1;\n \t  vtab->attr.save = SAVE_IMPLICIT;\n@@ -2547,15 +2547,15 @@ gfc_find_intrinsic_vtab (gfc_typespec *ts)\n \t      gfc_namespace *contained;\n \n \t      gfc_get_symbol (name, ns, &vtype);\n-\t      if (gfc_add_flavor (&vtype->attr, FL_DERIVED,\n-\t\t\t\t  NULL, &gfc_current_locus) == FAILURE)\n+\t      if (!gfc_add_flavor (&vtype->attr, FL_DERIVED, NULL, \n+\t\t\t\t   &gfc_current_locus))\n \t\tgoto cleanup;\n \t      vtype->attr.access = ACCESS_PUBLIC;\n \t      vtype->attr.vtype = 1;\n \t      gfc_set_sym_referenced (vtype);\n \n \t      /* Add component '_hash'.  */\n-\t      if (gfc_add_component (vtype, \"_hash\", &c) == FAILURE)\n+\t      if (!gfc_add_component (vtype, \"_hash\", &c))\n \t\tgoto cleanup;\n \t      c->ts.type = BT_INTEGER;\n \t      c->ts.kind = 4;\n@@ -2565,7 +2565,7 @@ gfc_find_intrinsic_vtab (gfc_typespec *ts)\n \t\t\t\t\t\t NULL, hash);\n \n \t      /* Add component '_size'.  */\n-\t      if (gfc_add_component (vtype, \"_size\", &c) == FAILURE)\n+\t      if (!gfc_add_component (vtype, \"_size\", &c))\n \t\tgoto cleanup;\n \t      c->ts.type = BT_INTEGER;\n \t      c->ts.kind = 4;\n@@ -2578,23 +2578,23 @@ gfc_find_intrinsic_vtab (gfc_typespec *ts)\n \t\t\t\t\t\t   NULL, ts->kind);\n \n \t      /* Add component _extends.  */\n-\t      if (gfc_add_component (vtype, \"_extends\", &c) == FAILURE)\n+\t      if (!gfc_add_component (vtype, \"_extends\", &c))\n \t\tgoto cleanup;\n \t      c->attr.pointer = 1;\n \t      c->attr.access = ACCESS_PRIVATE;\n \t      c->ts.type = BT_VOID;\n \t      c->initializer = gfc_get_null_expr (NULL);\n \n \t      /* Add component _def_init.  */\n-\t      if (gfc_add_component (vtype, \"_def_init\", &c) == FAILURE)\n+\t      if (!gfc_add_component (vtype, \"_def_init\", &c))\n \t\tgoto cleanup;\n \t      c->attr.pointer = 1;\n \t      c->attr.access = ACCESS_PRIVATE;\n \t      c->ts.type = BT_VOID;\n \t      c->initializer = gfc_get_null_expr (NULL);\n \n \t      /* Add component _copy.  */\n-\t      if (gfc_add_component (vtype, \"_copy\", &c) == FAILURE)\n+\t      if (!gfc_add_component (vtype, \"_copy\", &c))\n \t\tgoto cleanup;\n \t      c->attr.proc_pointer = 1;\n \t      c->attr.access = ACCESS_PRIVATE;\n@@ -2666,7 +2666,7 @@ gfc_find_intrinsic_vtab (gfc_typespec *ts)\n \t      c->ts.interface = copy;\n \n \t      /* Add component _final.  */\n-\t      if (gfc_add_component (vtype, \"_final\", &c) == FAILURE)\n+\t      if (!gfc_add_component (vtype, \"_final\", &c))\n \t\tgoto cleanup;\n \t      c->attr.proc_pointer = 1;\n \t      c->attr.access = ACCESS_PRIVATE;\n@@ -2709,7 +2709,7 @@ gfc_find_intrinsic_vtab (gfc_typespec *ts)\n    type-bound user operator.  */\n \n static gfc_symtree*\n-find_typebound_proc_uop (gfc_symbol* derived, gfc_try* t,\n+find_typebound_proc_uop (gfc_symbol* derived, bool* t,\n \t\t\t const char* name, bool noaccess, bool uop,\n \t\t\t locus* where)\n {\n@@ -2718,7 +2718,7 @@ find_typebound_proc_uop (gfc_symbol* derived, gfc_try* t,\n \n   /* Set default to failure.  */\n   if (t)\n-    *t = FAILURE;\n+    *t = false;\n \n   if (derived->f2k_derived)\n     /* Set correct symbol-root.  */\n@@ -2733,7 +2733,7 @@ find_typebound_proc_uop (gfc_symbol* derived, gfc_try* t,\n     {\n       /* We found one.  */\n       if (t)\n-\t*t = SUCCESS;\n+\t*t = true;\n \n       if (!noaccess && derived->attr.use_assoc\n \t  && res->n.tb->access == ACCESS_PRIVATE)\n@@ -2742,7 +2742,7 @@ find_typebound_proc_uop (gfc_symbol* derived, gfc_try* t,\n \t    gfc_error (\"'%s' of '%s' is PRIVATE at %L\",\n \t\t       name, derived->name, where);\n \t  if (t)\n-\t    *t = FAILURE;\n+\t    *t = false;\n \t}\n \n       return res;\n@@ -2768,14 +2768,14 @@ find_typebound_proc_uop (gfc_symbol* derived, gfc_try* t,\n    (looking recursively through the super-types).  */\n \n gfc_symtree*\n-gfc_find_typebound_proc (gfc_symbol* derived, gfc_try* t,\n+gfc_find_typebound_proc (gfc_symbol* derived, bool* t,\n \t\t\t const char* name, bool noaccess, locus* where)\n {\n   return find_typebound_proc_uop (derived, t, name, noaccess, false, where);\n }\n \n gfc_symtree*\n-gfc_find_typebound_user_op (gfc_symbol* derived, gfc_try* t,\n+gfc_find_typebound_user_op (gfc_symbol* derived, bool* t,\n \t\t\t    const char* name, bool noaccess, locus* where)\n {\n   return find_typebound_proc_uop (derived, t, name, noaccess, true, where);\n@@ -2786,15 +2786,15 @@ gfc_find_typebound_user_op (gfc_symbol* derived, gfc_try* t,\n    super-type hierarchy.  */\n \n gfc_typebound_proc*\n-gfc_find_typebound_intrinsic_op (gfc_symbol* derived, gfc_try* t,\n+gfc_find_typebound_intrinsic_op (gfc_symbol* derived, bool* t,\n \t\t\t\t gfc_intrinsic_op op, bool noaccess,\n \t\t\t\t locus* where)\n {\n   gfc_typebound_proc* res;\n \n   /* Set default to failure.  */\n   if (t)\n-    *t = FAILURE;\n+    *t = false;\n \n   /* Try to find it in the current type's namespace.  */\n   if (derived->f2k_derived)\n@@ -2807,7 +2807,7 @@ gfc_find_typebound_intrinsic_op (gfc_symbol* derived, gfc_try* t,\n     {\n       /* We found one.  */\n       if (t)\n-\t*t = SUCCESS;\n+\t*t = true;\n \n       if (!noaccess && derived->attr.use_assoc\n \t  && res->access == ACCESS_PRIVATE)\n@@ -2816,7 +2816,7 @@ gfc_find_typebound_intrinsic_op (gfc_symbol* derived, gfc_try* t,\n \t    gfc_error (\"'%s' of '%s' is PRIVATE at %L\",\n \t\t       gfc_op2string (op), derived->name, where);\n \t  if (t)\n-\t    *t = FAILURE;\n+\t    *t = false;\n \t}\n \n       return res;"}, {"sha": "ea53681af0c16329bc4456fd2e1798295a0fa73f", "filename": "gcc/fortran/cpp.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Fcpp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Fcpp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcpp.c?ref=524af0d6c72031c249aa737945fde6ac3d726ba2", "patch": "@@ -609,11 +609,11 @@ gfc_cpp_init (void)\n     pp_dir_change (cpp_in, get_src_pwd ());\n }\n \n-gfc_try\n+bool\n gfc_cpp_preprocess (const char *source_file)\n {\n   if (!gfc_cpp_enabled ())\n-    return FAILURE;\n+    return false;\n \n   cpp_change_file (cpp_in, LC_RENAME, source_file);\n \n@@ -636,7 +636,7 @@ gfc_cpp_preprocess (const char *source_file)\n       || (gfc_cpp_preprocess_only () && gfc_cpp_option.output_filename))\n     fclose (print.outf);\n \n-  return SUCCESS;\n+  return true;\n }\n \n void"}, {"sha": "04e13bef93b222789676f655807d8064c8bf06f8", "filename": "gcc/fortran/cpp.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Fcpp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Fcpp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcpp.h?ref=524af0d6c72031c249aa737945fde6ac3d726ba2", "patch": "@@ -43,7 +43,7 @@ int gfc_cpp_handle_option(size_t scode, const char *arg, int value);\n \n void gfc_cpp_post_options (void);\n \n-gfc_try gfc_cpp_preprocess (const char *source_file);\n+bool gfc_cpp_preprocess (const char *source_file);\n \n void gfc_cpp_done (void);\n "}, {"sha": "f297ef56faf382253319770d8db6af9dc21d9780", "filename": "gcc/fortran/data.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Fdata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Fdata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdata.c?ref=524af0d6c72031c249aa737945fde6ac3d726ba2", "patch": "@@ -129,8 +129,8 @@ create_character_initializer (gfc_expr *init, gfc_typespec *ts,\n       start_expr = gfc_copy_expr (ref->u.ss.start);\n       end_expr = gfc_copy_expr (ref->u.ss.end);\n \n-      if ((gfc_simplify_expr (start_expr, 1) == FAILURE)\n-\t  || (gfc_simplify_expr (end_expr, 1)) == FAILURE)\n+      if ((!gfc_simplify_expr(start_expr, 1))\n+\t  || !(gfc_simplify_expr(end_expr, 1)))\n \t{\n \t  gfc_error (\"failure to simplify substring reference in DATA \"\n \t\t     \"statement at %L\", &ref->u.ss.start->where);\n@@ -196,7 +196,7 @@ create_character_initializer (gfc_expr *init, gfc_typespec *ts,\n    consecutive values in LVALUE the same value in RVALUE.  In that case,\n    LVALUE must refer to a full array, not an array section.  */\n \n-gfc_try\n+bool\n gfc_assign_data_value (gfc_expr *lvalue, gfc_expr *rvalue, mpz_t index,\n \t\t       mpz_t *repeat)\n {\n@@ -283,7 +283,7 @@ gfc_assign_data_value (gfc_expr *lvalue, gfc_expr *rvalue, mpz_t index,\n \t\t\t  && ref->next == NULL);\n \t      mpz_init_set (end, offset);\n \t      mpz_add (end, end, *repeat);\n-\t      if (spec_size (ref->u.ar.as, &size) == SUCCESS)\n+\t      if (spec_size (ref->u.ar.as, &size))\n \t\t{\n \t\t  if (mpz_cmp (end, size) > 0)\n \t\t    {\n@@ -319,8 +319,8 @@ gfc_assign_data_value (gfc_expr *lvalue, gfc_expr *rvalue, mpz_t index,\n \t\t\t  ? con->expr : rvalue;\n \t\t  if (gfc_notify_std (GFC_STD_GNU,\n \t\t\t\t      \"re-initialization of '%s' at %L\",\n-\t\t\t\t      symbol->name, &exprd->where) == FAILURE)\n-\t\t    return FAILURE;\n+\t\t\t\t      symbol->name, &exprd->where) == false)\n+\t\t    return false;\n \t\t}\n \n \t      while (con != NULL)\n@@ -372,7 +372,7 @@ gfc_assign_data_value (gfc_expr *lvalue, gfc_expr *rvalue, mpz_t index,\n \t  else\n \t    {\n \t      mpz_t size;\n-\t      if (spec_size (ref->u.ar.as, &size) == SUCCESS)\n+\t      if (spec_size (ref->u.ar.as, &size))\n \t\t{\n \t\t  if (mpz_cmp (offset, size) >= 0)\n \t\t    {\n@@ -468,7 +468,7 @@ gfc_assign_data_value (gfc_expr *lvalue, gfc_expr *rvalue, mpz_t index,\n   if (ref || last_ts->type == BT_CHARACTER)\n     {\n       if (lvalue->ts.u.cl->length == NULL && !(ref && ref->u.ss.length != NULL))\n-\treturn FAILURE;\n+\treturn false;\n       expr = create_character_initializer (init, last_ts, ref, rvalue);\n     }\n   else\n@@ -485,8 +485,8 @@ gfc_assign_data_value (gfc_expr *lvalue, gfc_expr *rvalue, mpz_t index,\n \t       ? init : rvalue;\n \t  if (gfc_notify_std (GFC_STD_GNU,\n \t\t\t      \"re-initialization of '%s' at %L\",\n-\t\t\t      symbol->name, &expr->where) == FAILURE)\n-\t    return FAILURE;\n+\t\t\t      symbol->name, &expr->where) == false)\n+\t    return false;\n \t}\n \n       expr = gfc_copy_expr (rvalue);\n@@ -499,13 +499,13 @@ gfc_assign_data_value (gfc_expr *lvalue, gfc_expr *rvalue, mpz_t index,\n   else\n     last_con->expr = expr;\n \n-  return SUCCESS;\n+  return true;\n \n abort:\n   if (!init)\n     gfc_free_expr (expr);\n   mpz_clear (offset);\n-  return FAILURE;\n+  return false;\n }\n \n "}, {"sha": "04114dc8817b2c60998867828d4699ac86dcab9f", "filename": "gcc/fortran/data.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Fdata.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Fdata.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdata.h?ref=524af0d6c72031c249aa737945fde6ac3d726ba2", "patch": "@@ -19,5 +19,5 @@ along with GCC; see the file COPYING3.  If not see\n \n void gfc_formalize_init_value (gfc_symbol *);\n void gfc_get_section_index (gfc_array_ref *, mpz_t *, mpz_t *);\n-gfc_try gfc_assign_data_value (gfc_expr *, gfc_expr *, mpz_t, mpz_t *);\n+bool gfc_assign_data_value (gfc_expr *, gfc_expr *, mpz_t, mpz_t *);\n void gfc_advance_section (mpz_t *, gfc_array_ref *, mpz_t *);"}, {"sha": "ffaa65d6a5a0ec4fbc369e3328183cb329ce3910", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 310, "deletions": 367, "changes": 677, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=524af0d6c72031c249aa737945fde6ac3d726ba2", "patch": "@@ -35,7 +35,7 @@ along with GCC; see the file COPYING3.  If not see\n #define gfc_get_data() XCNEW (gfc_data)\n \n \n-static gfc_try set_binding_label (const char **, const char *, int);\n+static bool set_binding_label (const char **, const char *, int);\n \n \n /* This flag is set if an old-style length selector is matched\n@@ -254,8 +254,7 @@ var_element (gfc_data_variable *new_var)\n   sym = new_var->expr->symtree->n.sym;\n \n   /* Symbol should already have an associated type.  */\n-  if (gfc_check_symbol_typed (sym, gfc_current_ns,\n-\t\t\t      false, gfc_current_locus) == FAILURE)\n+  if (!gfc_check_symbol_typed (sym, gfc_current_ns, false, gfc_current_locus))\n     return MATCH_ERROR;\n \n   if (!sym->attr.function && gfc_current_ns->parent\n@@ -268,12 +267,12 @@ var_element (gfc_data_variable *new_var)\n \n   if (gfc_current_state () != COMP_BLOCK_DATA\n       && sym->attr.in_common\n-      && gfc_notify_std (GFC_STD_GNU, \"initialization of \"\n-\t\t\t \"common block variable '%s' in DATA statement at %C\",\n-\t\t\t sym->name) == FAILURE)\n+      && !gfc_notify_std (GFC_STD_GNU, \"initialization of \"\n+\t\t\t  \"common block variable '%s' in DATA statement at %C\",\n+\t\t\t  sym->name))\n     return MATCH_ERROR;\n \n-  if (gfc_add_data (&sym->attr, sym->name, &new_var->expr->where) == FAILURE)\n+  if (!gfc_add_data (&sym->attr, sym->name, &new_var->expr->where))\n     return MATCH_ERROR;\n \n   return MATCH_YES;\n@@ -356,7 +355,7 @@ match_data_constant (gfc_expr **result)\n \n   if (m == MATCH_YES && (*result)->expr_type == EXPR_STRUCTURE)\n     {\n-      if (gfc_simplify_expr (*result, 0) == FAILURE)\n+      if (!gfc_simplify_expr (*result, 0))\n \tm = MATCH_ERROR;\n       return m;\n     }\n@@ -397,7 +396,7 @@ match_data_constant (gfc_expr **result)\n \n       if (m == MATCH_YES)\n \t{\n-\t  if (gfc_simplify_expr (*result, 0) == FAILURE)\n+\t  if (!gfc_simplify_expr (*result, 0))\n \t    m = MATCH_ERROR;\n \n \t  if ((*result)->expr_type == EXPR_CONSTANT)\n@@ -515,7 +514,7 @@ match_old_style_init (const char *name)\n     gfc_current_ns->proc_name->attr.implicit_pure = 0;\n \n   /* Mark the variable as having appeared in a data statement.  */\n-  if (gfc_add_data (&sym->attr, sym->name, &sym->declared_at) == FAILURE)\n+  if (!gfc_add_data (&sym->attr, sym->name, &sym->declared_at))\n     {\n       free (newdata);\n       return MATCH_ERROR;\n@@ -589,7 +588,7 @@ gfc_match_data (void)\n \n /* Auxiliary function to merge DIMENSION and CODIMENSION array specs.  */\n \n-static gfc_try\n+static bool\n merge_array_spec (gfc_array_spec *from, gfc_array_spec *to, bool copy)\n {\n   int i;\n@@ -598,7 +597,7 @@ merge_array_spec (gfc_array_spec *from, gfc_array_spec *to, bool copy)\n       || (to->type == AS_ASSUMED_RANK && from->corank))\n     {\n       gfc_error (\"The assumed-rank array at %C shall not have a codimension\");\n-      return FAILURE;\n+      return false;\n     }\n \n   if (to->rank == 0 && from->rank > 0)\n@@ -647,7 +646,7 @@ merge_array_spec (gfc_array_spec *from, gfc_array_spec *to, bool copy)\n \t}\n     }\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n@@ -686,8 +685,8 @@ char_len_param_value (gfc_expr **expr, bool *deferred)\n \n   if (gfc_match_char (':') == MATCH_YES)\n     {\n-      if (gfc_notify_std (GFC_STD_F2003, \"deferred type \"\n-\t\t\t  \"parameter at %C\") == FAILURE)\n+      if (!gfc_notify_std (GFC_STD_F2003, \"deferred type \"\n+\t\t\t   \"parameter at %C\"))\n \treturn MATCH_ERROR;\n \n       *deferred = true;\n@@ -698,7 +697,7 @@ char_len_param_value (gfc_expr **expr, bool *deferred)\n   m = gfc_match_expr (expr);\n \n   if (m == MATCH_YES\n-      && gfc_expr_check_typed (*expr, gfc_current_ns, false) == FAILURE)\n+      && !gfc_expr_check_typed (*expr, gfc_current_ns, false))\n     return MATCH_ERROR;\n \n   if (m == MATCH_YES && (*expr)->expr_type == EXPR_FUNCTION)\n@@ -749,8 +748,7 @@ match_char_length (gfc_expr **expr, bool *deferred, bool obsolescent_check)\n   if (m == MATCH_YES)\n     {\n       if (obsolescent_check\n-\t  && gfc_notify_std (GFC_STD_F95_OBS,\n-\t\t\t     \"Old-style character length at %C\") == FAILURE)\n+\t  && !gfc_notify_std (GFC_STD_F95_OBS, \"Old-style character length at %C\"))\n \treturn MATCH_ERROR;\n       *expr = gfc_get_int_expr (gfc_default_integer_kind, NULL, length);\n       return m;\n@@ -953,8 +951,7 @@ get_proc_name (const char *name, gfc_symbol **result, bool module_fcn_entry)\n \t\t&& sym->ns->proc_name->attr.flavor == FL_MODULE\n \t\t&& sym->attr.proc != PROC_MODULE)\n \t    || (module_fcn_entry && sym->attr.proc != PROC_MODULE))\n-\t&& gfc_add_procedure (&sym->attr, PROC_MODULE,\n-\t\t\t      sym->name, NULL) == FAILURE)\n+\t&& !gfc_add_procedure (&sym->attr, PROC_MODULE, sym->name, NULL))\n     rc = 2;\n \n   return rc;\n@@ -978,16 +975,16 @@ get_proc_name (const char *name, gfc_symbol **result, bool module_fcn_entry)\n    the compiler could have automatically handled the varying sizes\n    across platforms.  */\n \n-gfc_try\n+bool\n gfc_verify_c_interop_param (gfc_symbol *sym)\n {\n   int is_c_interop = 0;\n-  gfc_try retval = SUCCESS;\n+  bool retval = true;\n \n   /* We check implicitly typed variables in symbol.c:gfc_set_default_type().\n      Don't repeat the checks here.  */\n   if (sym->attr.implicit_type)\n-    return SUCCESS;\n+    return true;\n \n   /* For subroutines or functions that are passed to a BIND(C) procedure,\n      they're interoperable if they're BIND(C) and their params are all\n@@ -1000,13 +997,13 @@ gfc_verify_c_interop_param (gfc_symbol *sym)\n                          \"attribute to be C interoperable\", sym->name,\n                          &(sym->declared_at));\n \n-          return FAILURE;\n+          return false;\n         }\n       else\n         {\n           if (sym->attr.is_c_interop == 1)\n             /* We've already checked this procedure; don't check it again.  */\n-            return SUCCESS;\n+            return true;\n           else\n             return verify_bind_c_sym (sym, &(sym->ts), sym->attr.in_common,\n                                       sym->common_block);\n@@ -1018,7 +1015,7 @@ gfc_verify_c_interop_param (gfc_symbol *sym)\n     {\n       if (sym->ns->proc_name->attr.is_bind_c == 1)\n \t{\n-\t  is_c_interop = (gfc_verify_c_interop (&(sym->ts)) == SUCCESS ? 1 : 0);\n+\t  is_c_interop = (gfc_verify_c_interop(&(sym->ts)) ? 1 : 0);\n \n \t  if (is_c_interop != 1)\n \t    {\n@@ -1057,7 +1054,7 @@ gfc_verify_c_interop_param (gfc_symbol *sym)\n                              \"procedure '%s' is BIND(C)\",\n \t\t\t     sym->name, &sym->declared_at,\n                              sym->ns->proc_name->name);\n-\t\t  retval = FAILURE;\n+\t\t  retval = false;\n \t\t}\n \t    }\n \n@@ -1070,7 +1067,7 @@ gfc_verify_c_interop_param (gfc_symbol *sym)\n \t\t\t \"ALLOCATABLE attribute because procedure '%s'\"\n \t\t\t \" is BIND(C)\", sym->name, &(sym->declared_at),\n \t\t\t sym->ns->proc_name->name);\n-\t      retval = FAILURE;\n+\t      retval = false;\n \t    }\n \n \t  if (sym->attr.pointer == 1)\n@@ -1079,7 +1076,7 @@ gfc_verify_c_interop_param (gfc_symbol *sym)\n \t\t\t \"POINTER attribute because procedure '%s'\"\n \t\t\t \" is BIND(C)\", sym->name, &(sym->declared_at),\n \t\t\t sym->ns->proc_name->name);\n-\t      retval = FAILURE;\n+\t      retval = false;\n \t    }\n \n \t  if (sym->attr.optional == 1 && sym->attr.value)\n@@ -1088,27 +1085,27 @@ gfc_verify_c_interop_param (gfc_symbol *sym)\n \t\t\t \"and the VALUE attribute because procedure '%s' \"\n \t\t\t \"is BIND(C)\", sym->name, &(sym->declared_at),\n \t\t\t sym->ns->proc_name->name);\n-\t      retval = FAILURE;\n+\t      retval = false;\n \t    }\n \t  else if (sym->attr.optional == 1\n-\t\t   && gfc_notify_std (GFC_STD_F2008_TS, \"Variable '%s' \"\n-\t\t\t\t      \"at %L with OPTIONAL attribute in \"\n-\t\t\t\t      \"procedure '%s' which is BIND(C)\",\n-\t\t\t\t      sym->name, &(sym->declared_at),\n-\t\t\t\t      sym->ns->proc_name->name)\n-\t\t      == FAILURE)\n-\t    retval = FAILURE;\n+\t\t   && !gfc_notify_std (GFC_STD_F2008_TS, \"Variable '%s' \"\n+\t\t\t\t       \"at %L with OPTIONAL attribute in \"\n+\t\t\t\t       \"procedure '%s' which is BIND(C)\", \n+\t\t\t\t       sym->name, &(sym->declared_at), \n+\t\t\t\t       sym->ns->proc_name->name))\n+\t    retval = false;\n \n           /* Make sure that if it has the dimension attribute, that it is\n \t     either assumed size or explicit shape. Deferred shape is already\n \t     covered by the pointer/allocatable attribute.  */\n \t  if (sym->as != NULL && sym->as->type == AS_ASSUMED_SHAPE\n-\t      && gfc_notify_std (GFC_STD_F2008_TS, \"Assumed-shape array '%s' \"\n-\t\t\t      \"at %L as dummy argument to the BIND(C) \"\n-\t\t\t      \"procedure '%s' at %L\", sym->name,\n-\t\t\t      &(sym->declared_at), sym->ns->proc_name->name,\n-\t\t\t      &(sym->ns->proc_name->declared_at)) == FAILURE)\n-\t    retval = FAILURE;\n+\t      && !gfc_notify_std (GFC_STD_F2008_TS, \"Assumed-shape array '%s' \"\n+\t\t\t\t  \"at %L as dummy argument to the BIND(C) \"\n+\t\t\t\t  \"procedure '%s' at %L\", sym->name, \n+\t\t\t\t  &(sym->declared_at), \n+\t\t\t\t  sym->ns->proc_name->name, \n+\t\t\t\t  &(sym->ns->proc_name->declared_at)))\n+\t    retval = false;\n \t}\n     }\n \n@@ -1119,22 +1116,22 @@ gfc_verify_c_interop_param (gfc_symbol *sym)\n \n /* Function called by variable_decl() that adds a name to the symbol table.  */\n \n-static gfc_try\n+static bool\n build_sym (const char *name, gfc_charlen *cl, bool cl_deferred,\n \t   gfc_array_spec **as, locus *var_locus)\n {\n   symbol_attribute attr;\n   gfc_symbol *sym;\n \n   if (gfc_get_symbol (name, NULL, &sym))\n-    return FAILURE;\n+    return false;\n \n   /* Start updating the symbol table.  Add basic type attribute if present.  */\n   if (current_ts.type != BT_UNKNOWN\n       && (sym->attr.implicit_type == 0\n \t  || !gfc_compare_types (&sym->ts, &current_ts))\n-      && gfc_add_type (sym, &current_ts, var_locus) == FAILURE)\n-    return FAILURE;\n+      && !gfc_add_type (sym, &current_ts, var_locus))\n+    return false;\n \n   if (sym->ts.type == BT_CHARACTER)\n     {\n@@ -1143,8 +1140,8 @@ build_sym (const char *name, gfc_charlen *cl, bool cl_deferred,\n     }\n \n   /* Add dimension attribute if present.  */\n-  if (gfc_set_array_spec (sym, *as, var_locus) == FAILURE)\n-    return FAILURE;\n+  if (!gfc_set_array_spec (sym, *as, var_locus))\n+    return false;\n   *as = NULL;\n \n   /* Add attribute to symbol.  The copy is so that we can reset the\n@@ -1153,8 +1150,8 @@ build_sym (const char *name, gfc_charlen *cl, bool cl_deferred,\n   attr.dimension = 0;\n   attr.codimension = 0;\n \n-  if (gfc_copy_attr (&sym->attr, &attr, var_locus) == FAILURE)\n-    return FAILURE;\n+  if (!gfc_copy_attr (&sym->attr, &attr, var_locus))\n+    return false;\n \n   /* Finish any work that may need to be done for the binding label,\n      if it's a bind(c).  The bind(c) attr is found before the symbol\n@@ -1168,9 +1165,9 @@ build_sym (const char *name, gfc_charlen *cl, bool cl_deferred,\n         {\n \t  /* Set the binding label and verify that if a NAME= was specified\n \t     then only one identifier was in the entity-decl-list.  */\n-\t  if (set_binding_label (&sym->binding_label, sym->name,\n-\t\t\t\t num_idents_on_line) == FAILURE)\n-            return FAILURE;\n+\t  if (!set_binding_label (&sym->binding_label, sym->name, \n+\t\t\t\t  num_idents_on_line))\n+            return false;\n         }\n     }\n \n@@ -1196,7 +1193,7 @@ build_sym (const char *name, gfc_charlen *cl, bool cl_deferred,\n   if (sym->ts.type == BT_CLASS)\n     return gfc_build_class_symbol (&sym->ts, &sym->attr, &sym->as, false);\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n@@ -1302,7 +1299,7 @@ gfc_free_enum_history (void)\n /* Function called by variable_decl() that adds an initialization\n    expression to a symbol.  */\n \n-static gfc_try\n+static bool\n add_init_expr_to_sym (const char *name, gfc_expr **initp, locus *var_locus)\n {\n   symbol_attribute attr;\n@@ -1311,7 +1308,7 @@ add_init_expr_to_sym (const char *name, gfc_expr **initp, locus *var_locus)\n \n   init = *initp;\n   if (find_special (name, &sym, false))\n-    return FAILURE;\n+    return false;\n \n   attr = sym->attr;\n \n@@ -1323,7 +1320,7 @@ add_init_expr_to_sym (const char *name, gfc_expr **initp, locus *var_locus)\n     {\n       gfc_error (\"Initializer not allowed for PARAMETER '%s' at %C\",\n \t\t sym->name);\n-      return FAILURE;\n+      return false;\n     }\n \n   if (init == NULL)\n@@ -1332,7 +1329,7 @@ add_init_expr_to_sym (const char *name, gfc_expr **initp, locus *var_locus)\n       if (attr.flavor == FL_PARAMETER)\n \t{\n \t  gfc_error (\"PARAMETER at %L is missing an initializer\", var_locus);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n     }\n   else\n@@ -1343,23 +1340,23 @@ add_init_expr_to_sym (const char *name, gfc_expr **initp, locus *var_locus)\n \t{\n \t  gfc_error (\"Variable '%s' at %C with an initializer already \"\n \t\t     \"appears in a DATA statement\", sym->name);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n \n       /* Check if the assignment can happen. This has to be put off\n \t until later for derived type variables and procedure pointers.  */\n       if (sym->ts.type != BT_DERIVED && init->ts.type != BT_DERIVED\n \t  && sym->ts.type != BT_CLASS && init->ts.type != BT_CLASS\n \t  && !sym->attr.proc_pointer\n-\t  && gfc_check_assign_symbol (sym, NULL, init) == FAILURE)\n-\treturn FAILURE;\n+\t  && !gfc_check_assign_symbol (sym, NULL, init))\n+\treturn false;\n \n       if (sym->ts.type == BT_CHARACTER && sym->ts.u.cl\n \t    && init->ts.type == BT_CHARACTER)\n \t{\n \t  /* Update symbol character length according initializer.  */\n-\t  if (gfc_check_assign_symbol (sym, NULL, init) == FAILURE)\n-\t    return FAILURE;\n+\t  if (!gfc_check_assign_symbol (sym, NULL, init))\n+\t    return false;\n \n \t  if (sym->ts.u.cl->length == NULL)\n \t    {\n@@ -1424,7 +1421,7 @@ add_init_expr_to_sym (const char *name, gfc_expr **initp, locus *var_locus)\n \t    {\n \t      gfc_error (\"Can't initialize implied-shape array at %L\"\n \t\t\t \" with scalar\", &sym->declared_at);\n-\t      return FAILURE;\n+\t      return false;\n \t    }\n \t  gcc_assert (sym->as->rank == init->rank);\n \n@@ -1442,7 +1439,7 @@ add_init_expr_to_sym (const char *name, gfc_expr **initp, locus *var_locus)\n \t\t{\n \t\t  gfc_error (\"Non-constant lower bound in implied-shape\"\n \t\t\t     \" declaration at %L\", &lower->where);\n-\t\t  return FAILURE;\n+\t\t  return false;\n \t\t}\n \n \t      /* All dimensions must be without upper bound.  */\n@@ -1487,7 +1484,7 @@ add_init_expr_to_sym (const char *name, gfc_expr **initp, locus *var_locus)\n \t  int n;\n \t  if (sym->attr.flavor == FL_PARAMETER\n \t\t&& init->expr_type == EXPR_CONSTANT\n-\t\t&& spec_size (sym->as, &size) == SUCCESS\n+\t\t&& spec_size (sym->as, &size)\n \t\t&& mpz_cmp_si (size, 0) > 0)\n \t    {\n \t      array = gfc_get_array_expr (init->ts.type, init->ts.kind,\n@@ -1515,19 +1512,19 @@ add_init_expr_to_sym (const char *name, gfc_expr **initp, locus *var_locus)\n       *initp = NULL;\n     }\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n /* Function called by variable_decl() that adds a name to a structure\n    being built.  */\n \n-static gfc_try\n+static bool\n build_struct (const char *name, gfc_charlen *cl, gfc_expr **init,\n \t      gfc_array_spec **as)\n {\n   gfc_component *c;\n-  gfc_try t = SUCCESS;\n+  bool t = true;\n \n   /* F03:C438/C439. If the current symbol is of the same derived type that we're\n      constructing, it must have the pointer attribute.  */\n@@ -1536,7 +1533,7 @@ build_struct (const char *name, gfc_charlen *cl, gfc_expr **init,\n       && current_attr.pointer == 0)\n     {\n       gfc_error (\"Component at %C must have the POINTER attribute\");\n-      return FAILURE;\n+      return false;\n     }\n \n   if (gfc_current_block ()->attr.pointer && (*as)->rank != 0)\n@@ -1545,12 +1542,12 @@ build_struct (const char *name, gfc_charlen *cl, gfc_expr **init,\n \t{\n \t  gfc_error (\"Array component of structure at %C must have explicit \"\n \t\t     \"or deferred shape\");\n-\t  return FAILURE;\n+\t  return false;\n \t}\n     }\n \n-  if (gfc_add_component (gfc_current_block (), name, &c) == FAILURE)\n-    return FAILURE;\n+  if (!gfc_add_component (gfc_current_block(), name, &c))\n+    return false;\n \n   c->ts = current_ts;\n   if (c->ts.type == BT_CHARACTER)\n@@ -1626,7 +1623,7 @@ build_struct (const char *name, gfc_charlen *cl, gfc_expr **init,\n \t{\n \t  gfc_error (\"Pointer array component of structure at %C must have a \"\n \t\t     \"deferred shape\");\n-\t  t = FAILURE;\n+\t  t = false;\n \t}\n     }\n   else if (c->attr.allocatable)\n@@ -1635,7 +1632,7 @@ build_struct (const char *name, gfc_charlen *cl, gfc_expr **init,\n \t{\n \t  gfc_error (\"Allocatable component of structure at %C must have a \"\n \t\t     \"deferred shape\");\n-\t  t = FAILURE;\n+\t  t = false;\n \t}\n     }\n   else\n@@ -1644,7 +1641,7 @@ build_struct (const char *name, gfc_charlen *cl, gfc_expr **init,\n \t{\n \t  gfc_error (\"Array component of structure at %C must have an \"\n \t\t     \"explicit shape\");\n-\t  t = FAILURE;\n+\t  t = false;\n \t}\n     }\n \n@@ -1654,9 +1651,9 @@ build_struct (const char *name, gfc_charlen *cl, gfc_expr **init,\n       bool delayed = (gfc_state_stack->sym == c->ts.u.derived)\n \t\t     || (!c->ts.u.derived->components\n \t\t\t && !c->ts.u.derived->attr.zero_comp);\n-      gfc_try t2 = gfc_build_class_symbol (&c->ts, &c->attr, &c->as, delayed);\n+      bool t2 = gfc_build_class_symbol (&c->ts, &c->attr, &c->as, delayed);\n \n-      if (t != FAILURE)\n+      if (t)\n \tt = t2;\n     }\n \n@@ -1706,9 +1703,8 @@ gfc_match_null (gfc_expr **result)\n   gfc_intrinsic_symbol (sym);\n \n   if (sym->attr.proc != PROC_INTRINSIC\n-      && (gfc_add_procedure (&sym->attr, PROC_INTRINSIC,\n-\t\t\t     sym->name, NULL) == FAILURE\n-\t  || gfc_add_function (&sym->attr, sym->name, NULL) == FAILURE))\n+      && (!gfc_add_procedure(&sym->attr, PROC_INTRINSIC, sym->name, NULL)\n+\t  || !gfc_add_function (&sym->attr, sym->name, NULL)))\n     return MATCH_ERROR;\n \n   *result = gfc_get_null_expr (&gfc_current_locus);\n@@ -1760,15 +1756,15 @@ match_pointer_init (gfc_expr **init, int procptr)\n   if (!procptr)\n     gfc_resolve_expr (*init);\n \n-  if (gfc_notify_std (GFC_STD_F2008, \"non-NULL pointer \"\n-\t\t      \"initialization at %C\") == FAILURE)\n+  if (!gfc_notify_std (GFC_STD_F2008, \"non-NULL pointer \"\n+\t\t       \"initialization at %C\"))\n     return MATCH_ERROR;\n \n   return MATCH_YES;\n }\n \n \n-static gfc_try\n+static bool\n check_function_name (char *name)\n {\n   /* In functions that have a RESULT variable defined, the function name always\n@@ -1784,11 +1780,11 @@ check_function_name (char *name)\n \t  && strcmp (block->name, name) == 0)\n \t{\n \t  gfc_error (\"Function name '%s' not allowed at %C\", name);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n     }\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n@@ -1808,7 +1804,7 @@ variable_decl (int elem)\n   bool cl_deferred;\n   locus var_locus;\n   match m;\n-  gfc_try t;\n+  bool t;\n   gfc_symbol *sym;\n \n   initializer = NULL;\n@@ -1832,7 +1828,7 @@ variable_decl (int elem)\n   if (m == MATCH_NO)\n     as = gfc_copy_array_spec (current_as);\n   else if (current_as\n-\t   && merge_array_spec (current_as, as, true) == FAILURE)\n+\t   && !merge_array_spec (current_as, as, true))\n     {\n       m = MATCH_ERROR;\n       goto cleanup;\n@@ -1860,9 +1856,8 @@ variable_decl (int elem)\n \tas->type = AS_IMPLIED_SHAPE;\n \n       if (as->type == AS_IMPLIED_SHAPE\n-\t  && gfc_notify_std (GFC_STD_F2008,\n-\t\t\t     \"Implied-shape array at %L\",\n-\t\t\t     &var_locus) == FAILURE)\n+\t  && !gfc_notify_std (GFC_STD_F2008, \"Implied-shape array at %L\", \n+\t\t\t      &var_locus))\n \t{\n \t  m = MATCH_ERROR;\n \t  goto cleanup;\n@@ -1932,7 +1927,7 @@ variable_decl (int elem)\n \t\t}\n \t      else\n \t\t{\n-\t\t  if (gfc_set_array_spec (sym, cp_as, &var_locus) == FAILURE)\n+\t\t  if (!gfc_set_array_spec (sym, cp_as, &var_locus))\n \t\t    gfc_internal_error (\"Couldn't set pointee array spec.\");\n \n \t\t  /* Fix the array spec.  */\n@@ -1973,13 +1968,13 @@ variable_decl (int elem)\n      create a symbol for those yet.  If we fail to create the symbol,\n      bail out.  */\n   if (gfc_current_state () != COMP_DERIVED\n-      && build_sym (name, cl, cl_deferred, &as, &var_locus) == FAILURE)\n+      && !build_sym (name, cl, cl_deferred, &as, &var_locus))\n     {\n       m = MATCH_ERROR;\n       goto cleanup;\n     }\n \n-  if (check_function_name (name) == FAILURE)\n+  if (!check_function_name (name))\n     {\n       m = MATCH_ERROR;\n       goto cleanup;\n@@ -1996,8 +1991,8 @@ variable_decl (int elem)\n \n   if (!colon_seen && gfc_match (\" /\") == MATCH_YES)\n     {\n-      if (gfc_notify_std (GFC_STD_GNU, \"Old-style \"\n-\t\t\t  \"initialization at %C\") == FAILURE)\n+      if (!gfc_notify_std (GFC_STD_GNU, \"Old-style \"\n+\t\t\t   \"initialization at %C\"))\n \treturn MATCH_ERROR;\n \n       return match_old_style_init (name);\n@@ -2072,7 +2067,7 @@ variable_decl (int elem)\n       t = build_struct (name, cl, &initializer, &as);\n     }\n \n-  m = (t == SUCCESS) ? MATCH_YES : MATCH_ERROR;\n+  m = (t) ? MATCH_YES : MATCH_ERROR;\n \n cleanup:\n   /* Free stuff up and return.  */\n@@ -2148,8 +2143,9 @@ gfc_match_old_kind_spec (gfc_typespec *ts)\n       return MATCH_ERROR;\n     }\n \n-  if (gfc_notify_std (GFC_STD_GNU, \"Nonstandard type declaration %s*%d at %C\",\n-\t\t      gfc_basic_typename (ts->type), original_kind) == FAILURE)\n+  if (!gfc_notify_std (GFC_STD_GNU, \n+\t\t       \"Nonstandard type declaration %s*%d at %C\", \n+\t\t       gfc_basic_typename(ts->type), original_kind))\n     return MATCH_ERROR;\n \n   return MATCH_YES;\n@@ -2589,8 +2585,7 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)\n \n   if (gfc_match (\" byte\") == MATCH_YES)\n     {\n-      if (gfc_notify_std (GFC_STD_GNU, \"BYTE type at %C\")\n-\t  == FAILURE)\n+      if (!gfc_notify_std (GFC_STD_GNU, \"BYTE type at %C\"))\n \treturn MATCH_ERROR;\n \n       if (gfc_validate_kind (BT_INTEGER, 1, true) < 0)\n@@ -2620,8 +2615,8 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)\n \t      gfc_error (\"Assumed type at %C is not allowed for components\");\n \t      return MATCH_ERROR;\n \t    }\n-\t  if (gfc_notify_std (GFC_STD_F2008_TS, \"Assumed type \"\n-\t\t\t  \"at %C\") == FAILURE)\n+\t  if (!gfc_notify_std (GFC_STD_F2008_TS, \"Assumed type \"\n+\t\t\t       \"at %C\"))\n \t    return MATCH_ERROR;\n \t  ts->type = BT_ASSUMED;\n \t  return MATCH_YES;\n@@ -2643,8 +2638,8 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)\n       || (!matched_type && gfc_match (\" character\") == MATCH_YES))\n     {\n       if (matched_type\n-\t  && gfc_notify_std (GFC_STD_F2008, \"TYPE with \"\n-\t\t\t  \"intrinsic-type-spec at %C\") == FAILURE)\n+\t  && !gfc_notify_std (GFC_STD_F2008, \"TYPE with \"\n+\t\t\t      \"intrinsic-type-spec at %C\"))\n \treturn MATCH_ERROR;\n \n       ts->type = BT_CHARACTER;\n@@ -2674,8 +2669,8 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)\n       || (!matched_type && gfc_match (\" double precision\") == MATCH_YES))\n     {\n       if (matched_type\n-\t  && gfc_notify_std (GFC_STD_F2008, \"TYPE with \"\n-\t\t\t  \"intrinsic-type-spec at %C\") == FAILURE)\n+\t  && !gfc_notify_std (GFC_STD_F2008, \"TYPE with \"\n+\t\t\t      \"intrinsic-type-spec at %C\"))\n \treturn MATCH_ERROR;\n       if (matched_type && gfc_match_char (')') != MATCH_YES)\n \treturn MATCH_ERROR;\n@@ -2699,13 +2694,12 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)\n \t       && gfc_match (\" complex\") == MATCH_YES)))\n       || (!matched_type && gfc_match (\" double complex\") == MATCH_YES))\n     {\n-      if (gfc_notify_std (GFC_STD_GNU, \"DOUBLE COMPLEX at %C\")\n-\t  == FAILURE)\n+      if (!gfc_notify_std (GFC_STD_GNU, \"DOUBLE COMPLEX at %C\"))\n \treturn MATCH_ERROR;\n \n       if (matched_type\n-\t  && gfc_notify_std (GFC_STD_F2008, \"TYPE with \"\n-\t\t\t  \"intrinsic-type-spec at %C\") == FAILURE)\n+\t  && !gfc_notify_std (GFC_STD_F2008, \"TYPE with \"\n+\t\t\t      \"intrinsic-type-spec at %C\"))\n \treturn MATCH_ERROR;\n \n       if (matched_type && gfc_match_char (')') != MATCH_YES)\n@@ -2753,8 +2747,8 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)\n \t      /* This is essential to force the construction of\n \t\t unlimited polymorphic component class containers.  */\n \t      upe->attr.zero_comp = 1;\n-\t      if (gfc_add_flavor (&upe->attr, FL_DERIVED,\n-\t\t\t\t  NULL, &gfc_current_locus) == FAILURE)\n+\t      if (!gfc_add_flavor (&upe->attr, FL_DERIVED, NULL, \n+\t\t\t\t   &gfc_current_locus))\n \t  return MATCH_ERROR;\n \t}\n \t  else\n@@ -2774,8 +2768,7 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)\n \treturn m;\n       ts->type = BT_CLASS;\n \n-      if (gfc_notify_std (GFC_STD_F2003, \"CLASS statement at %C\")\n-\t\t\t  == FAILURE)\n+      if (!gfc_notify_std (GFC_STD_F2003, \"CLASS statement at %C\"))\n \treturn MATCH_ERROR;\n     }\n \n@@ -2846,11 +2839,11 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)\n \n   gfc_set_sym_referenced (sym);\n   if (!sym->attr.generic\n-      && gfc_add_generic (&sym->attr, sym->name, NULL) == FAILURE)\n+      && !gfc_add_generic (&sym->attr, sym->name, NULL))\n     return MATCH_ERROR;\n \n   if (!sym->attr.function\n-      && gfc_add_function (&sym->attr, sym->name, NULL) == FAILURE)\n+      && !gfc_add_function (&sym->attr, sym->name, NULL))\n     return MATCH_ERROR;\n \n   if (!dt_sym)\n@@ -2872,8 +2865,7 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)\n   gfc_set_sym_referenced (dt_sym);\n \n   if (dt_sym->attr.flavor != FL_DERIVED\n-      && gfc_add_flavor (&dt_sym->attr, FL_DERIVED, sym->name, NULL)\n-\t\t\t == FAILURE)\n+      && !gfc_add_flavor (&dt_sym->attr, FL_DERIVED, sym->name, NULL))\n     return MATCH_ERROR;\n \n   ts->u.derived = dt_sym;\n@@ -2882,8 +2874,8 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)\n \n get_kind:\n   if (matched_type\n-      && gfc_notify_std (GFC_STD_F2008, \"TYPE with \"\n-\t\t\t \"intrinsic-type-spec at %C\") == FAILURE)\n+      && !gfc_notify_std (GFC_STD_F2008, \"TYPE with \"\n+\t\t\t  \"intrinsic-type-spec at %C\"))\n     return MATCH_ERROR;\n \n   /* For all types except double, derived and character, look for an\n@@ -3014,7 +3006,7 @@ match_implicit_range (void)\n \t conflicts with whatever earlier IMPLICIT statements may have\n \t set.  This is done when we've successfully finished matching\n \t the current one.  */\n-      if (gfc_add_new_implicit_range (c1, c2) != SUCCESS)\n+      if (!gfc_add_new_implicit_range (c1, c2))\n \tgoto bad;\n     }\n \n@@ -3096,7 +3088,7 @@ gfc_match_implicit (void)\n \t\t}\n \n \t      /* Record the Successful match.  */\n-\t      if (gfc_merge_new_implicit (&ts) != SUCCESS)\n+\t      if (!gfc_merge_new_implicit (&ts))\n \t\treturn MATCH_ERROR;\n \t      continue;\n \t    }\n@@ -3136,7 +3128,7 @@ gfc_match_implicit (void)\n       if ((c != '\\n') && (c != ','))\n \tgoto syntax;\n \n-      if (gfc_merge_new_implicit (&ts) != SUCCESS)\n+      if (!gfc_merge_new_implicit (&ts))\n \treturn MATCH_ERROR;\n     }\n   while (c == ',');\n@@ -3167,8 +3159,7 @@ gfc_match_import (void)\n       return MATCH_ERROR;\n     }\n \n-  if (gfc_notify_std (GFC_STD_F2003, \"IMPORT statement at %C\")\n-      == FAILURE)\n+  if (!gfc_notify_std (GFC_STD_F2003, \"IMPORT statement at %C\"))\n     return MATCH_ERROR;\n \n   if (gfc_match_eos () == MATCH_YES)\n@@ -3313,7 +3304,7 @@ match_attr_spec (void)\n   unsigned int d;\n   const char *attr;\n   match m;\n-  gfc_try t;\n+  bool t;\n \n   gfc_clear_attr (&current_attr);\n   start = gfc_current_locus;\n@@ -3552,7 +3543,7 @@ match_attr_spec (void)\n \t    current_as = as;\n \t  else if (m == MATCH_YES)\n \t    {\n-\t      if (merge_array_spec (as, current_as, false) == FAILURE)\n+\t      if (!merge_array_spec (as, current_as, false))\n \t\tm = MATCH_ERROR;\n \t      free (as);\n \t    }\n@@ -3664,9 +3655,8 @@ match_attr_spec (void)\n \t{\n \t  if (d == DECL_ALLOCATABLE)\n \t    {\n-\t      if (gfc_notify_std (GFC_STD_F2003, \"ALLOCATABLE \"\n-\t\t\t\t  \"attribute at %C in a TYPE definition\")\n-\t\t  == FAILURE)\n+\t      if (!gfc_notify_std (GFC_STD_F2003, \"ALLOCATABLE \"\n+\t\t\t\t   \"attribute at %C in a TYPE definition\"))\n \t\t{\n \t\t  m = MATCH_ERROR;\n \t\t  goto cleanup;\n@@ -3692,10 +3682,9 @@ match_attr_spec (void)\n \t      && gfc_state_stack->previous\n \t      && gfc_state_stack->previous->state == COMP_MODULE)\n \t    {\n-\t      if (gfc_notify_std (GFC_STD_F2003, \"Attribute %s \"\n-\t\t\t\t  \"at %L in a TYPE definition\", attr,\n-\t\t\t\t  &seen_at[d])\n-\t\t  == FAILURE)\n+\t      if (!gfc_notify_std (GFC_STD_F2003, \"Attribute %s \"\n+\t\t\t\t   \"at %L in a TYPE definition\", attr, \n+\t\t\t\t   &seen_at[d]))\n \t\t{\n \t\t  m = MATCH_ERROR;\n \t\t  goto cleanup;\n@@ -3717,10 +3706,8 @@ match_attr_spec (void)\n \t  break;\n \n \tcase DECL_ASYNCHRONOUS:\n-\t  if (gfc_notify_std (GFC_STD_F2003,\n-\t\t\t      \"ASYNCHRONOUS attribute at %C\")\n-\t      == FAILURE)\n-\t    t = FAILURE;\n+\t  if (!gfc_notify_std (GFC_STD_F2003, \"ASYNCHRONOUS attribute at %C\"))\n+\t    t = false;\n \t  else\n \t    t = gfc_add_asynchronous (&current_attr, NULL, &seen_at[d]);\n \t  break;\n@@ -3730,10 +3717,8 @@ match_attr_spec (void)\n \t  break;\n \n \tcase DECL_CONTIGUOUS:\n-\t  if (gfc_notify_std (GFC_STD_F2008,\n-\t\t\t      \"CONTIGUOUS attribute at %C\")\n-\t      == FAILURE)\n-\t    t = FAILURE;\n+\t  if (!gfc_notify_std (GFC_STD_F2008, \"CONTIGUOUS attribute at %C\"))\n+\t    t = false;\n \t  else\n \t    t = gfc_add_contiguous (&current_attr, NULL, &seen_at[d]);\n \t  break;\n@@ -3779,14 +3764,12 @@ match_attr_spec (void)\n \t    {\n \t       gfc_error (\"PROTECTED at %C only allowed in specification \"\n \t\t\t  \"part of a module\");\n-\t       t = FAILURE;\n+\t       t = false;\n \t       break;\n \t    }\n \n-\t  if (gfc_notify_std (GFC_STD_F2003, \"PROTECTED \"\n-\t\t\t      \"attribute at %C\")\n-\t      == FAILURE)\n-\t    t = FAILURE;\n+\t  if (!gfc_notify_std (GFC_STD_F2003, \"PROTECTED attribute at %C\"))\n+\t    t = false;\n \t  else\n \t    t = gfc_add_protected (&current_attr, NULL, &seen_at[d]);\n \t  break;\n@@ -3814,19 +3797,15 @@ match_attr_spec (void)\n            break;\n \n \tcase DECL_VALUE:\n-\t  if (gfc_notify_std (GFC_STD_F2003, \"VALUE attribute \"\n-\t\t\t      \"at %C\")\n-\t      == FAILURE)\n-\t    t = FAILURE;\n+\t  if (!gfc_notify_std (GFC_STD_F2003, \"VALUE attribute at %C\"))\n+\t    t = false;\n \t  else\n \t    t = gfc_add_value (&current_attr, NULL, &seen_at[d]);\n \t  break;\n \n \tcase DECL_VOLATILE:\n-\t  if (gfc_notify_std (GFC_STD_F2003,\n-\t\t\t      \"VOLATILE attribute at %C\")\n-\t      == FAILURE)\n-\t    t = FAILURE;\n+\t  if (!gfc_notify_std (GFC_STD_F2003, \"VOLATILE attribute at %C\"))\n+\t    t = false;\n \t  else\n \t    t = gfc_add_volatile (&current_attr, NULL, &seen_at[d]);\n \t  break;\n@@ -3835,7 +3814,7 @@ match_attr_spec (void)\n \t  gfc_internal_error (\"match_attr_spec(): Bad attribute\");\n \t}\n \n-      if (t == FAILURE)\n+      if (!t)\n \t{\n \t  m = MATCH_ERROR;\n \t  goto cleanup;\n@@ -3864,15 +3843,15 @@ match_attr_spec (void)\n    (J3/04-007, section 15.4.1).  If a binding label was given and\n    there is more than one argument (num_idents), it is an error.  */\n \n-static gfc_try\n+static bool\n set_binding_label (const char **dest_label, const char *sym_name,\n \t\t   int num_idents)\n {\n   if (num_idents > 1 && has_name_equals)\n     {\n       gfc_error (\"Multiple identifiers provided with \"\n \t\t \"single NAME= specifier at %C\");\n-      return FAILURE;\n+      return false;\n     }\n \n   if (curr_binding_label)\n@@ -3886,7 +3865,7 @@ set_binding_label (const char **dest_label, const char *sym_name,\n         *dest_label = IDENTIFIER_POINTER (get_identifier (sym_name));\n     }\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n@@ -3903,18 +3882,18 @@ set_com_block_bind_c (gfc_common_head *com_block, int is_bind_c)\n \n /* Verify that the given gfc_typespec is for a C interoperable type.  */\n \n-gfc_try\n+bool\n gfc_verify_c_interop (gfc_typespec *ts)\n {\n   if (ts->type == BT_DERIVED && ts->u.derived != NULL)\n     return (ts->u.derived->ts.is_c_interop || ts->u.derived->attr.is_bind_c)\n-\t   ? SUCCESS : FAILURE;\n+\t   ? true : false;\n   else if (ts->type == BT_CLASS)\n-    return FAILURE;\n+    return false;\n   else if (ts->is_c_interop != 1 && ts->type != BT_ASSUMED)\n-    return FAILURE;\n+    return false;\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n@@ -3923,11 +3902,11 @@ gfc_verify_c_interop (gfc_typespec *ts)\n    interoperable type.  Errors will be reported here, if\n    encountered.  */\n \n-gfc_try\n+bool\n verify_com_block_vars_c_interop (gfc_common_head *com_block)\n {\n   gfc_symbol *curr_sym = NULL;\n-  gfc_try retval = SUCCESS;\n+  bool retval = true;\n \n   curr_sym = com_block->head;\n \n@@ -3951,12 +3930,12 @@ verify_com_block_vars_c_interop (gfc_common_head *com_block)\n /* Verify that a given BIND(C) symbol is C interoperable.  If it is not,\n    an appropriate error message is reported.  */\n \n-gfc_try\n+bool\n verify_bind_c_sym (gfc_symbol *tmp_sym, gfc_typespec *ts,\n                    int is_in_common, gfc_common_head *com_block)\n {\n   bool bind_c_function = false;\n-  gfc_try retval = SUCCESS;\n+  bool retval = true;\n \n   if (tmp_sym->attr.function && tmp_sym->attr.is_bind_c)\n     bind_c_function = true;\n@@ -3983,7 +3962,7 @@ verify_bind_c_sym (gfc_symbol *tmp_sym, gfc_typespec *ts,\n      the given ts (current_ts), so look in both.  */\n   if (tmp_sym->ts.type != BT_UNKNOWN || ts->type != BT_UNKNOWN)\n     {\n-      if (gfc_verify_c_interop (&(tmp_sym->ts)) != SUCCESS)\n+      if (!gfc_verify_c_interop (&(tmp_sym->ts)))\n \t{\n \t  /* See if we're dealing with a sym in a common block or not.\t*/\n \t  if (is_in_common == 1 && gfc_option.warn_c_binding_type)\n@@ -4018,7 +3997,7 @@ verify_bind_c_sym (gfc_symbol *tmp_sym, gfc_typespec *ts,\n \t\t     \"since it is not a global\",\n \t\t     tmp_sym->name, com_block->name,\n \t\t     &(tmp_sym->declared_at));\n-\t  retval = FAILURE;\n+\t  retval = false;\n \t}\n \n       /* Scalar variables that are bind(c) can not have the pointer\n@@ -4030,15 +4009,15 @@ verify_bind_c_sym (gfc_symbol *tmp_sym, gfc_typespec *ts,\n \t      gfc_error (\"Variable '%s' at %L cannot have both the \"\n \t\t\t \"POINTER and BIND(C) attributes\",\n \t\t\t tmp_sym->name, &(tmp_sym->declared_at));\n-\t      retval = FAILURE;\n+\t      retval = false;\n \t    }\n \n \t  if (tmp_sym->attr.allocatable == 1)\n \t    {\n \t      gfc_error (\"Variable '%s' at %L cannot have both the \"\n \t\t\t \"ALLOCATABLE and BIND(C) attributes\",\n \t\t\t tmp_sym->name, &(tmp_sym->declared_at));\n-\t      retval = FAILURE;\n+\t      retval = false;\n \t    }\n \n         }\n@@ -4079,19 +4058,18 @@ verify_bind_c_sym (gfc_symbol *tmp_sym, gfc_typespec *ts,\n    the type is C interoperable.  Errors are reported by the functions\n    used to set/test these fields.  */\n \n-gfc_try\n+bool\n set_verify_bind_c_sym (gfc_symbol *tmp_sym, int num_idents)\n {\n-  gfc_try retval = SUCCESS;\n+  bool retval = true;\n \n   /* TODO: Do we need to make sure the vars aren't marked private?  */\n \n   /* Set the is_bind_c bit in symbol_attribute.  */\n   gfc_add_is_bind_c (&(tmp_sym->attr), tmp_sym->name, &gfc_current_locus, 0);\n \n-  if (set_binding_label (&tmp_sym->binding_label, tmp_sym->name,\n-\t\t\t num_idents) != SUCCESS)\n-    return FAILURE;\n+  if (!set_binding_label (&tmp_sym->binding_label, tmp_sym->name, num_idents))\n+    return false;\n \n   return retval;\n }\n@@ -4100,16 +4078,15 @@ set_verify_bind_c_sym (gfc_symbol *tmp_sym, int num_idents)\n /* Set the fields marking the given common block as BIND(C), including\n    a binding label, and report any errors encountered.  */\n \n-gfc_try\n+bool\n set_verify_bind_c_com_block (gfc_common_head *com_block, int num_idents)\n {\n-  gfc_try retval = SUCCESS;\n+  bool retval = true;\n \n   /* destLabel, common name, typespec (which may have binding label).  */\n-  if (set_binding_label (&com_block->binding_label, com_block->name,\n-\t\t\t num_idents)\n-      != SUCCESS)\n-    return FAILURE;\n+  if (!set_binding_label (&com_block->binding_label, com_block->name, \n+\t\t\t  num_idents))\n+    return false;\n \n   /* Set the given common block (com_block) to being bind(c) (1).  */\n   set_com_block_bind_c (com_block, 1);\n@@ -4121,7 +4098,7 @@ set_verify_bind_c_com_block (gfc_common_head *com_block, int num_idents)\n /* Retrieve the list of one or more identifiers that the given bind(c)\n    attribute applies to.  */\n \n-gfc_try\n+bool\n get_bind_c_idents (void)\n {\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n@@ -4144,7 +4121,7 @@ get_bind_c_idents (void)\n     {\n       gfc_error (\"Need either entity or common block name for \"\n \t\t \"attribute specification statement at %C\");\n-      return FAILURE;\n+      return false;\n     }\n \n   /* Save the current identifier and look for more.  */\n@@ -4160,15 +4137,13 @@ get_bind_c_idents (void)\n         {\n \t  if (tmp_sym != NULL)\n \t    {\n-\t      if (set_verify_bind_c_sym (tmp_sym, num_idents)\n-\t\t  != SUCCESS)\n-\t\treturn FAILURE;\n+\t      if (!set_verify_bind_c_sym (tmp_sym, num_idents))\n+\t\treturn false;\n \t    }\n \t  else\n \t    {\n-\t      if (set_verify_bind_c_com_block(com_block, num_idents)\n-\t\t  != SUCCESS)\n-\t\treturn FAILURE;\n+\t      if (!set_verify_bind_c_com_block (com_block, num_idents))\n+\t\treturn false;\n \t    }\n \n \t  /* Look to see if we have another identifier.  */\n@@ -4191,7 +4166,7 @@ get_bind_c_idents (void)\n \t    {\n \t      gfc_error (\"Missing entity or common block name for \"\n \t\t\t \"attribute specification statement at %C\");\n-\t      return FAILURE;\n+\t      return false;\n \t    }\n \t}\n       else\n@@ -4201,7 +4176,7 @@ get_bind_c_idents (void)\n     } while (found_id == MATCH_YES);\n \n   /* if we get here we were successful */\n-  return SUCCESS;\n+  return true;\n }\n \n \n@@ -4233,7 +4208,7 @@ gfc_match_bind_c_stmt (void)\n \t found can have all appropriate parts updated (assuming that the same\n \t spec stmt can have multiple attrs, such as both bind(c) and\n \t allocatable...).  */\n-      if (get_bind_c_idents () != SUCCESS)\n+      if (!get_bind_c_idents ())\n \t/* Error message should have printed already.  */\n \treturn MATCH_ERROR;\n     }\n@@ -4380,23 +4355,23 @@ gfc_match_prefix (gfc_typespec *ts)\n \n       if (gfc_match (\"elemental% \") == MATCH_YES)\n \t{\n-\t  if (gfc_add_elemental (&current_attr, NULL) == FAILURE)\n+\t  if (!gfc_add_elemental (&current_attr, NULL))\n \t    goto error;\n \n \t  found_prefix = true;\n \t}\n \n       if (gfc_match (\"pure% \") == MATCH_YES)\n \t{\n-\t  if (gfc_add_pure (&current_attr, NULL) == FAILURE)\n+\t  if (!gfc_add_pure (&current_attr, NULL))\n \t    goto error;\n \n \t  found_prefix = true;\n \t}\n \n       if (gfc_match (\"recursive% \") == MATCH_YES)\n \t{\n-\t  if (gfc_add_recursive (&current_attr, NULL) == FAILURE)\n+\t  if (!gfc_add_recursive (&current_attr, NULL))\n \t    goto error;\n \n \t  found_prefix = true;\n@@ -4407,9 +4382,7 @@ gfc_match_prefix (gfc_typespec *ts)\n \t automatically PURE.  */\n       if (gfc_match (\"impure% \") == MATCH_YES)\n \t{\n-\t  if (gfc_notify_std (GFC_STD_F2008,\n-\t\t\t      \"IMPURE procedure at %C\")\n-\t\t== FAILURE)\n+\t  if (!gfc_notify_std (GFC_STD_F2008, \"IMPURE procedure at %C\"))\n \t    goto error;\n \n \t  seen_impure = true;\n@@ -4428,7 +4401,7 @@ gfc_match_prefix (gfc_typespec *ts)\n   /* If IMPURE it not seen but the procedure is ELEMENTAL, mark it as PURE.  */\n   if (!seen_impure && current_attr.elemental && !current_attr.pure)\n     {\n-      if (gfc_add_pure (&current_attr, NULL) == FAILURE)\n+      if (!gfc_add_pure (&current_attr, NULL))\n \tgoto error;\n     }\n \n@@ -4446,19 +4419,19 @@ gfc_match_prefix (gfc_typespec *ts)\n \n /* Copy attributes matched by gfc_match_prefix() to attributes on a symbol.  */\n \n-static gfc_try\n+static bool\n copy_prefix (symbol_attribute *dest, locus *where)\n {\n-  if (current_attr.pure && gfc_add_pure (dest, where) == FAILURE)\n-    return FAILURE;\n+  if (current_attr.pure && !gfc_add_pure (dest, where))\n+    return false;\n \n-  if (current_attr.elemental && gfc_add_elemental (dest, where) == FAILURE)\n-    return FAILURE;\n+  if (current_attr.elemental && !gfc_add_elemental (dest, where))\n+    return false;\n \n-  if (current_attr.recursive && gfc_add_recursive (dest, where) == FAILURE)\n-    return FAILURE;\n+  if (current_attr.recursive && !gfc_add_recursive (dest, where))\n+    return false;\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n@@ -4489,8 +4462,8 @@ gfc_match_formal_arglist (gfc_symbol *progname, int st_flag, int null_flag)\n       if (gfc_match_char ('*') == MATCH_YES)\n \t{\n \t  sym = NULL;\n-\t  if (gfc_notify_std (GFC_STD_F95_OBS, \"Alternate-return argument \"\n-\t\t\t      \"at %C\") == FAILURE)\n+\t  if (!gfc_notify_std (GFC_STD_F95_OBS, \"Alternate-return argument \"\n+\t\t\t       \"at %C\"))\n \t    {\n \t      m = MATCH_ERROR;\n \t      goto cleanup;\n@@ -4522,8 +4495,8 @@ gfc_match_formal_arglist (gfc_symbol *progname, int st_flag, int null_flag)\n \t dummy procedure.  We don't apply these attributes to formal\n \t arguments of statement functions.  */\n       if (sym != NULL && !st_flag\n-\t  && (gfc_add_dummy (&sym->attr, sym->name, NULL) == FAILURE\n-\t      || gfc_missing_attr (&sym->attr, NULL) == FAILURE))\n+\t  && (!gfc_add_dummy(&sym->attr, sym->name, NULL)\n+\t      || !gfc_missing_attr (&sym->attr, NULL)))\n \t{\n \t  m = MATCH_ERROR;\n \t  goto cleanup;\n@@ -4573,8 +4546,7 @@ gfc_match_formal_arglist (gfc_symbol *progname, int st_flag, int null_flag)\n \t}\n     }\n \n-  if (gfc_add_explicit_interface (progname, IFSRC_DECL, head, NULL)\n-      == FAILURE)\n+  if (!gfc_add_explicit_interface (progname, IFSRC_DECL, head, NULL))\n     {\n       m = MATCH_ERROR;\n       goto cleanup;\n@@ -4607,7 +4579,7 @@ match_result (gfc_symbol *function, gfc_symbol **result)\n \n   /* Get the right paren, and that's it because there could be the\n      bind(c) attribute after the result clause.  */\n-  if (gfc_match_char(')') != MATCH_YES)\n+  if (gfc_match_char (')') != MATCH_YES)\n     {\n      /* TODO: should report the missing right paren here.  */\n       return MATCH_ERROR;\n@@ -4622,7 +4594,7 @@ match_result (gfc_symbol *function, gfc_symbol **result)\n   if (gfc_get_symbol (name, NULL, &r))\n     return MATCH_ERROR;\n \n-  if (gfc_add_result (&r->attr, r->name, NULL) == FAILURE)\n+  if (!gfc_add_result (&r->attr, r->name, NULL))\n     return MATCH_ERROR;\n \n   *result = r;\n@@ -4702,14 +4674,12 @@ gfc_match_suffix (gfc_symbol *sym, gfc_symbol **result)\n       /* Fortran 2008 draft allows BIND(C) for internal procedures.  */\n       if (gfc_current_state () == COMP_CONTAINS\n \t  && sym->ns->proc_name->attr.flavor != FL_MODULE\n-\t  && gfc_notify_std (GFC_STD_F2008, \"BIND(C) attribute \"\n-\t\t\t     \"at %L may not be specified for an internal \"\n-\t\t\t     \"procedure\", &gfc_current_locus)\n-\t     == FAILURE)\n+\t  && !gfc_notify_std (GFC_STD_F2008, \"BIND(C) attribute \"\n+\t\t\t      \"at %L may not be specified for an internal \"\n+\t\t\t      \"procedure\", &gfc_current_locus))\n \treturn MATCH_ERROR;\n \n-      if (gfc_add_is_bind_c (&(sym->attr), sym->name, &gfc_current_locus, 1)\n-\t  == FAILURE)\n+      if (!gfc_add_is_bind_c (&(sym->attr), sym->name, &gfc_current_locus, 1))\n      \treturn MATCH_ERROR;\n     }\n \n@@ -4720,13 +4690,13 @@ gfc_match_suffix (gfc_symbol *sym, gfc_symbol **result)\n /* Procedure pointer return value without RESULT statement:\n    Add \"hidden\" result variable named \"ppr@\".  */\n \n-static gfc_try\n+static bool\n add_hidden_procptr_result (gfc_symbol *sym)\n {\n   bool case1,case2;\n \n   if (gfc_notification_std (GFC_STD_F2003) == ERROR)\n-    return FAILURE;\n+    return false;\n \n   /* First usage case: PROCEDURE and EXTERNAL statements.  */\n   case1 = gfc_current_state () == COMP_FUNCTION && gfc_current_block ()\n@@ -4776,10 +4746,10 @@ add_hidden_procptr_result (gfc_symbol *sym)\n     {\n       sym->result->attr.proc_pointer = 1;\n       sym->attr.pointer = 0;\n-      return SUCCESS;\n+      return true;\n     }\n   else\n-    return FAILURE;\n+    return false;\n }\n \n \n@@ -4845,8 +4815,8 @@ match_procedure_interface (gfc_symbol **proc_if)\n \n       if ((*proc_if)->attr.flavor == FL_UNKNOWN\n \t  && (*proc_if)->ts.type == BT_UNKNOWN\n-\t  && gfc_add_flavor (&(*proc_if)->attr, FL_PROCEDURE,\n-\t\t\t      (*proc_if)->name, NULL) == FAILURE)\n+\t  && !gfc_add_flavor (&(*proc_if)->attr, FL_PROCEDURE, \n+\t\t\t      (*proc_if)->name, NULL))\n \treturn MATCH_ERROR;\n     }\n \n@@ -4898,7 +4868,7 @@ match_procedure_decl (void)\n \treturn m;\n \n       /* Add current_attr to the symbol attributes.  */\n-      if (gfc_copy_attr (&sym->attr, &current_attr, NULL) == FAILURE)\n+      if (!gfc_copy_attr (&sym->attr, &current_attr, NULL))\n \treturn MATCH_ERROR;\n \n       if (sym->attr.is_bind_c)\n@@ -4924,18 +4894,17 @@ match_procedure_decl (void)\n \t      return MATCH_ERROR;\n \t    }\n \t  /* Set binding label for BIND(C).  */\n-\t  if (set_binding_label (&sym->binding_label, sym->name, num)\n-\t      != SUCCESS)\n+\t  if (!set_binding_label (&sym->binding_label, sym->name, num))\n \t    return MATCH_ERROR;\n \t}\n \n-      if (gfc_add_external (&sym->attr, NULL) == FAILURE)\n+      if (!gfc_add_external (&sym->attr, NULL))\n \treturn MATCH_ERROR;\n \n-      if (add_hidden_procptr_result (sym) == SUCCESS)\n+      if (add_hidden_procptr_result (sym))\n \tsym = sym->result;\n \n-      if (gfc_add_proc (&sym->attr, sym->name, NULL) == FAILURE)\n+      if (!gfc_add_proc (&sym->attr, sym->name, NULL))\n \treturn MATCH_ERROR;\n \n       /* Set interface.  */\n@@ -4954,7 +4923,7 @@ match_procedure_decl (void)\n \t}\n       else if (current_ts.type != BT_UNKNOWN)\n \t{\n-\t  if (gfc_add_type (sym, &current_ts, &gfc_current_locus) == FAILURE)\n+\t  if (!gfc_add_type (sym, &current_ts, &gfc_current_locus))\n \t    return MATCH_ERROR;\n \t  sym->ts.interface = gfc_new_symbol (\"\", gfc_current_ns);\n \t  sym->ts.interface->ts = current_ts;\n@@ -4977,8 +4946,7 @@ match_procedure_decl (void)\n \t  if (m != MATCH_YES)\n \t    goto cleanup;\n \n-\t  if (add_init_expr_to_sym (sym->name, &initializer, &gfc_current_locus)\n-\t      != SUCCESS)\n+\t  if (!add_init_expr_to_sym (sym->name, &initializer, &gfc_current_locus))\n \t    goto cleanup;\n \n \t}\n@@ -5050,8 +5018,7 @@ match_ppc_decl (void)\n       return MATCH_ERROR;\n     }\n \n-  if (gfc_notify_std (GFC_STD_F2003, \"Procedure pointer \"\n-                     \"component at %C\") == FAILURE)\n+  if (!gfc_notify_std (GFC_STD_F2003, \"Procedure pointer component at %C\"))\n     return MATCH_ERROR;\n \n   /* Match PPC names.  */\n@@ -5064,17 +5031,17 @@ match_ppc_decl (void)\n       else if (m == MATCH_ERROR)\n \treturn m;\n \n-      if (gfc_add_component (gfc_current_block (), name, &c) == FAILURE)\n+      if (!gfc_add_component (gfc_current_block(), name, &c))\n \treturn MATCH_ERROR;\n \n       /* Add current_attr to the symbol attributes.  */\n-      if (gfc_copy_attr (&c->attr, &current_attr, NULL) == FAILURE)\n+      if (!gfc_copy_attr (&c->attr, &current_attr, NULL))\n \treturn MATCH_ERROR;\n \n-      if (gfc_add_external (&c->attr, NULL) == FAILURE)\n+      if (!gfc_add_external (&c->attr, NULL))\n \treturn MATCH_ERROR;\n \n-      if (gfc_add_proc (&c->attr, name, NULL) == FAILURE)\n+      if (!gfc_add_proc (&c->attr, name, NULL))\n \treturn MATCH_ERROR;\n \n       c->tb = tb;\n@@ -5143,9 +5110,8 @@ match_procedure_in_interface (void)\n   old_locus = gfc_current_locus;\n   if (gfc_match (\"::\") == MATCH_YES)\n     {\n-      if (gfc_notify_std (GFC_STD_F2008, \"double colon in \"\n-\t\t\t \"MODULE PROCEDURE statement at %L\", &old_locus)\n-\t  == FAILURE)\n+      if (!gfc_notify_std (GFC_STD_F2008, \"double colon in \"\n+\t\t\t   \"MODULE PROCEDURE statement at %L\", &old_locus))\n \treturn MATCH_ERROR;\n     }\n   else\n@@ -5161,7 +5127,7 @@ match_procedure_in_interface (void)\n       if (gfc_get_symbol (name, gfc_current_ns->parent, &sym))\n \treturn MATCH_ERROR;\n \n-      if (gfc_add_interface (sym) == FAILURE)\n+      if (!gfc_add_interface (sym))\n \treturn MATCH_ERROR;\n \n       if (gfc_match_eos () == MATCH_YES)\n@@ -5213,8 +5179,7 @@ gfc_match_procedure (void)\n   if (m != MATCH_YES)\n     return m;\n \n-  if (gfc_notify_std (GFC_STD_F2003, \"PROCEDURE statement at %C\")\n-      == FAILURE)\n+  if (!gfc_notify_std (GFC_STD_F2003, \"PROCEDURE statement at %C\"))\n     return MATCH_ERROR;\n \n   return m;\n@@ -5273,7 +5238,7 @@ gfc_match_function_decl (void)\n   if (get_proc_name (name, &sym, false))\n     return MATCH_ERROR;\n \n-  if (add_hidden_procptr_result (sym) == SUCCESS)\n+  if (add_hidden_procptr_result (sym))\n     sym = sym->result;\n \n   gfc_new_block = sym;\n@@ -5331,11 +5296,11 @@ gfc_match_function_decl (void)\n       /* Make changes to the symbol.  */\n       m = MATCH_ERROR;\n \n-      if (gfc_add_function (&sym->attr, sym->name, NULL) == FAILURE)\n+      if (!gfc_add_function (&sym->attr, sym->name, NULL))\n \tgoto cleanup;\n \n-      if (gfc_missing_attr (&sym->attr, NULL) == FAILURE\n-\t  || copy_prefix (&sym->attr, &sym->declared_at) == FAILURE)\n+      if (!gfc_missing_attr (&sym->attr, NULL)\n+\t  || !copy_prefix (&sym->attr, &sym->declared_at))\n \tgoto cleanup;\n \n       /* Delay matching the function characteristics until after the\n@@ -5349,15 +5314,14 @@ gfc_match_function_decl (void)\n       if (result == NULL)\n \t{\n           if (current_ts.type != BT_UNKNOWN\n-\t      && gfc_add_type (sym, &current_ts, &gfc_current_locus) == FAILURE)\n+\t      && !gfc_add_type (sym, &current_ts, &gfc_current_locus))\n \t    goto cleanup;\n \t  sym->result = sym;\n \t}\n       else\n \t{\n           if (current_ts.type != BT_UNKNOWN\n-\t      && gfc_add_type (result, &current_ts, &gfc_current_locus)\n-\t\t == FAILURE)\n+\t      && !gfc_add_type (result, &current_ts, &gfc_current_locus))\n \t    goto cleanup;\n \t  sym->result = result;\n \t}\n@@ -5424,8 +5388,7 @@ gfc_match_entry (void)\n   if (m != MATCH_YES)\n     return m;\n \n-  if (gfc_notify_std (GFC_STD_F2008_OBS,\n-\t\t      \"ENTRY statement at %C\") == FAILURE)\n+  if (!gfc_notify_std (GFC_STD_F2008_OBS, \"ENTRY statement at %C\"))\n     return MATCH_ERROR;\n \n   state = gfc_current_state ();\n@@ -5548,13 +5511,13 @@ gfc_match_entry (void)\n \t      gfc_error (\"Missing required parentheses before BIND(C) at %C\");\n \t      return MATCH_ERROR;\n \t    }\n-\t    if (gfc_add_is_bind_c (&(entry->attr), entry->name, &(entry->declared_at), 1)\n-\t\t== FAILURE)\n+\t    if (!gfc_add_is_bind_c (&(entry->attr), entry->name, \n+\t\t\t\t    &(entry->declared_at), 1))\n \t      return MATCH_ERROR;\n \t}\n \n-      if (gfc_add_entry (&entry->attr, entry->name, NULL) == FAILURE\n-\t  || gfc_add_subroutine (&entry->attr, entry->name, NULL) == FAILURE)\n+      if (!gfc_add_entry (&entry->attr, entry->name, NULL)\n+\t  || !gfc_add_subroutine (&entry->attr, entry->name, NULL))\n \treturn MATCH_ERROR;\n     }\n   else\n@@ -5589,8 +5552,8 @@ gfc_match_entry (void)\n \n       if (gfc_match_eos () == MATCH_YES)\n \t{\n-\t  if (gfc_add_entry (&entry->attr, entry->name, NULL) == FAILURE\n-\t      || gfc_add_function (&entry->attr, entry->name, NULL) == FAILURE)\n+\t  if (!gfc_add_entry (&entry->attr, entry->name, NULL)\n+\t      || !gfc_add_function (&entry->attr, entry->name, NULL))\n \t    return MATCH_ERROR;\n \n \t  entry->result = entry;\n@@ -5605,17 +5568,16 @@ gfc_match_entry (void)\n \n           if (result)\n \t    {\n-\t      if (gfc_add_result (&result->attr, result->name, NULL) == FAILURE\n-\t\t  || gfc_add_entry (&entry->attr, result->name, NULL) == FAILURE\n-\t\t  || gfc_add_function (&entry->attr, result->name, NULL)\n-\t\t  == FAILURE)\n+\t      if (!gfc_add_result (&result->attr, result->name, NULL)\n+\t\t  || !gfc_add_entry (&entry->attr, result->name, NULL)\n+\t\t  || !gfc_add_function (&entry->attr, result->name, NULL))\n \t        return MATCH_ERROR;\n \t      entry->result = result;\n \t    }\n \t  else\n \t    {\n-\t      if (gfc_add_entry (&entry->attr, entry->name, NULL) == FAILURE\n-\t\t  || gfc_add_function (&entry->attr, entry->name, NULL) == FAILURE)\n+\t      if (!gfc_add_entry (&entry->attr, entry->name, NULL)\n+\t\t  || !gfc_add_function (&entry->attr, entry->name, NULL))\n \t\treturn MATCH_ERROR;\n \t      entry->result = entry;\n \t    }\n@@ -5680,7 +5642,7 @@ gfc_match_subroutine (void)\n      the symbol existed before. */\n   sym->declared_at = gfc_current_locus;\n \n-  if (add_hidden_procptr_result (sym) == SUCCESS)\n+  if (add_hidden_procptr_result (sym))\n     sym = sym->result;\n \n   gfc_new_block = sym;\n@@ -5690,7 +5652,7 @@ gfc_match_subroutine (void)\n   gfc_gobble_whitespace ();\n   peek_char = gfc_peek_ascii_char ();\n \n-  if (gfc_add_subroutine (&sym->attr, sym->name, NULL) == FAILURE)\n+  if (!gfc_add_subroutine (&sym->attr, sym->name, NULL))\n     return MATCH_ERROR;\n \n   if (gfc_match_formal_arglist (sym, 0, 1) != MATCH_YES)\n@@ -5735,19 +5697,18 @@ gfc_match_subroutine (void)\n       /* The following is allowed in the Fortran 2008 draft.  */\n       if (gfc_current_state () == COMP_CONTAINS\n \t  && sym->ns->proc_name->attr.flavor != FL_MODULE\n-\t  && gfc_notify_std (GFC_STD_F2008, \"BIND(C) attribute \"\n-\t\t\t     \"at %L may not be specified for an internal \"\n-\t\t\t     \"procedure\", &gfc_current_locus)\n-\t     == FAILURE)\n+\t  && !gfc_notify_std (GFC_STD_F2008, \"BIND(C) attribute \"\n+\t\t\t      \"at %L may not be specified for an internal \"\n+\t\t\t      \"procedure\", &gfc_current_locus))\n \treturn MATCH_ERROR;\n \n       if (peek_char != '(')\n         {\n           gfc_error (\"Missing required parentheses before BIND(C) at %C\");\n           return MATCH_ERROR;\n         }\n-      if (gfc_add_is_bind_c (&(sym->attr), sym->name, &(sym->declared_at), 1)\n-\t  == FAILURE)\n+      if (!gfc_add_is_bind_c (&(sym->attr), sym->name, \n+\t\t\t      &(sym->declared_at), 1))\n         return MATCH_ERROR;\n     }\n \n@@ -5757,7 +5718,7 @@ gfc_match_subroutine (void)\n       return MATCH_ERROR;\n     }\n \n-  if (copy_prefix (&sym->attr, &sym->declared_at) == FAILURE)\n+  if (!copy_prefix (&sym->attr, &sym->declared_at))\n     return MATCH_ERROR;\n \n   /* Warn if it has the same name as an intrinsic.  */\n@@ -6107,9 +6068,9 @@ gfc_match_end (gfc_statement *st)\n     {\n       if (!eos_ok && (*st == ST_END_SUBROUTINE || *st == ST_END_FUNCTION))\n \t{\n-\t  if (gfc_notify_std (GFC_STD_F2008, \"END statement \"\n-\t\t\t      \"instead of %s statement at %L\",\n-\t\t\t      gfc_ascii_statement (*st), &old_loc) == FAILURE)\n+\t  if (!gfc_notify_std (GFC_STD_F2008, \"END statement \"\n+\t\t\t       \"instead of %s statement at %L\", \n+\t\t\t       gfc_ascii_statement(*st), &old_loc))\n \t    goto cleanup;\n \t}\n       else if (!eos_ok)\n@@ -6246,7 +6207,7 @@ attr_decl1 (void)\n   if (find_special (name, &sym, false))\n     return MATCH_ERROR;\n \n-  if (check_function_name (name) == FAILURE)\n+  if (!check_function_name (name))\n     {\n       m = MATCH_ERROR;\n       goto cleanup;\n@@ -6306,8 +6267,7 @@ attr_decl1 (void)\n      to the first component, or '_data' field.  */\n   if (sym->ts.type == BT_CLASS && sym->ts.u.derived->attr.is_class)\n     {\n-      if (gfc_copy_attr (&CLASS_DATA (sym)->attr, &current_attr, &var_locus)\n-\t  == FAILURE)\n+      if (!gfc_copy_attr (&CLASS_DATA(sym)->attr, &current_attr, &var_locus))\n \t{\n \t  m = MATCH_ERROR;\n \t  goto cleanup;\n@@ -6316,21 +6276,21 @@ attr_decl1 (void)\n   else\n     {\n       if (current_attr.dimension == 0 && current_attr.codimension == 0\n-\t  && gfc_copy_attr (&sym->attr, &current_attr, &var_locus) == FAILURE)\n+\t  && !gfc_copy_attr (&sym->attr, &current_attr, &var_locus))\n \t{\n \t  m = MATCH_ERROR;\n \t  goto cleanup;\n \t}\n     }\n \n   if (sym->ts.type == BT_CLASS\n-      && gfc_build_class_symbol (&sym->ts, &sym->attr, &sym->as, false) == FAILURE)\n+      && !gfc_build_class_symbol (&sym->ts, &sym->attr, &sym->as, false))\n     {\n       m = MATCH_ERROR;\n       goto cleanup;\n     }\n \n-  if (gfc_set_array_spec (sym, as, &var_locus) == FAILURE)\n+  if (!gfc_set_array_spec (sym, as, &var_locus))\n     {\n       m = MATCH_ERROR;\n       goto cleanup;\n@@ -6344,15 +6304,15 @@ attr_decl1 (void)\n \tgoto cleanup;\n     }\n \n-  if (gfc_add_attribute (&sym->attr, &var_locus) == FAILURE)\n+  if (!gfc_add_attribute (&sym->attr, &var_locus))\n     {\n       m = MATCH_ERROR;\n       goto cleanup;\n     }\n \n   if ((current_attr.external || current_attr.intrinsic)\n       && sym->attr.flavor != FL_PROCEDURE\n-      && gfc_add_flavor (&sym->attr, FL_PROCEDURE, sym->name, NULL) == FAILURE)\n+      && !gfc_add_flavor (&sym->attr, FL_PROCEDURE, sym->name, NULL))\n     {\n       m = MATCH_ERROR;\n       goto cleanup;\n@@ -6449,7 +6409,7 @@ cray_pointer_decl (void)\n \t  return m;\n \t}\n \n-      if (gfc_add_cray_pointer (&cptr->attr, &var_locus) == FAILURE)\n+      if (!gfc_add_cray_pointer (&cptr->attr, &var_locus))\n \treturn MATCH_ERROR;\n \n       gfc_set_sym_referenced (cptr);\n@@ -6502,14 +6462,14 @@ cray_pointer_decl (void)\n \t  as = NULL;\n \t}\n \n-      if (gfc_add_cray_pointee (&cpte->attr, &var_locus) == FAILURE)\n+      if (!gfc_add_cray_pointee (&cpte->attr, &var_locus))\n \treturn MATCH_ERROR;\n \n       gfc_set_sym_referenced (cpte);\n \n       if (cpte->as == NULL)\n \t{\n-\t  if (gfc_set_array_spec (cpte, as, &var_locus) == FAILURE)\n+\t  if (!gfc_set_array_spec (cpte, as, &var_locus))\n \t    gfc_internal_error (\"Couldn't set Cray pointee array spec.\");\n \t}\n       else if (as != NULL)\n@@ -6662,8 +6622,7 @@ gfc_match_codimension (void)\n match\n gfc_match_contiguous (void)\n {\n-  if (gfc_notify_std (GFC_STD_F2008, \"CONTIGUOUS statement at %C\")\n-      == FAILURE)\n+  if (!gfc_notify_std (GFC_STD_F2008, \"CONTIGUOUS statement at %C\"))\n     return MATCH_ERROR;\n \n   gfc_clear_attr (&current_attr);\n@@ -6727,16 +6686,17 @@ access_attr_decl (gfc_statement st)\n \t  if (gfc_get_symbol (name, NULL, &sym))\n \t    goto done;\n \n-\t  if (gfc_add_access (&sym->attr, (st == ST_PUBLIC)\n-\t\t\t\t\t  ? ACCESS_PUBLIC : ACCESS_PRIVATE,\n-\t\t\t      sym->name, NULL) == FAILURE)\n+\t  if (!gfc_add_access (&sym->attr, \n+\t\t\t       (st == ST_PUBLIC) \n+\t\t\t       ? ACCESS_PUBLIC : ACCESS_PRIVATE, \n+\t\t\t       sym->name, NULL))\n \t    return MATCH_ERROR;\n \n \t  if (sym->attr.generic && (dt_sym = gfc_find_dt_in_generic (sym))\n-\t      && gfc_add_access (&dt_sym->attr,\n-\t\t\t\t (st == ST_PUBLIC) ? ACCESS_PUBLIC\n-\t\t\t\t\t\t   : ACCESS_PRIVATE,\n-\t\t\t\t sym->name, NULL) == FAILURE)\n+\t      && !gfc_add_access (&dt_sym->attr, \n+\t\t\t\t  (st == ST_PUBLIC) \n+\t\t\t\t  ? ACCESS_PUBLIC : ACCESS_PRIVATE, \n+\t\t\t\t  sym->name, NULL))\n \t    return MATCH_ERROR;\n \n \t  break;\n@@ -6815,8 +6775,7 @@ gfc_match_protected (void)\n \n     }\n \n-  if (gfc_notify_std (GFC_STD_F2003, \"PROTECTED statement at %C\")\n-      == FAILURE)\n+  if (!gfc_notify_std (GFC_STD_F2003, \"PROTECTED statement at %C\"))\n     return MATCH_ERROR;\n \n   if (gfc_match (\" ::\") == MATCH_NO && gfc_match_space () == MATCH_NO)\n@@ -6833,8 +6792,7 @@ gfc_match_protected (void)\n       switch (m)\n \t{\n \tcase MATCH_YES:\n-\t  if (gfc_add_protected (&sym->attr, sym->name, &gfc_current_locus)\n-\t      == FAILURE)\n+\t  if (!gfc_add_protected (&sym->attr, sym->name, &gfc_current_locus))\n \t    return MATCH_ERROR;\n \t  goto next_item;\n \n@@ -6940,7 +6898,7 @@ do_parm (void)\n   gfc_symbol *sym;\n   gfc_expr *init;\n   match m;\n-  gfc_try t;\n+  bool t;\n \n   m = gfc_match_symbol (&sym, 0);\n   if (m == MATCH_NO)\n@@ -6962,14 +6920,14 @@ do_parm (void)\n     return m;\n \n   if (sym->ts.type == BT_UNKNOWN\n-      && gfc_set_default_type (sym, 1, NULL) == FAILURE)\n+      && !gfc_set_default_type (sym, 1, NULL))\n     {\n       m = MATCH_ERROR;\n       goto cleanup;\n     }\n \n-  if (gfc_check_assign_symbol (sym, NULL, init) == FAILURE\n-      || gfc_add_flavor (&sym->attr, FL_PARAMETER, sym->name, NULL) == FAILURE)\n+  if (!gfc_check_assign_symbol (sym, NULL, init)\n+      || !gfc_add_flavor (&sym->attr, FL_PARAMETER, sym->name, NULL))\n     {\n       m = MATCH_ERROR;\n       goto cleanup;\n@@ -6983,7 +6941,7 @@ do_parm (void)\n     }\n \n   t = add_init_expr_to_sym (sym->name, &init, &gfc_current_locus);\n-  return (t == SUCCESS) ? MATCH_YES : MATCH_ERROR;\n+  return (t) ? MATCH_YES : MATCH_ERROR;\n \n cleanup:\n   gfc_free_expr (init);\n@@ -7036,9 +6994,8 @@ gfc_match_save (void)\n     {\n       if (gfc_current_ns->seen_save)\n \t{\n-\t  if (gfc_notify_std (GFC_STD_LEGACY, \"Blanket SAVE statement at %C \"\n-\t\t\t      \"follows previous SAVE statement\")\n-\t      == FAILURE)\n+\t  if (!gfc_notify_std (GFC_STD_LEGACY, \"Blanket SAVE statement at %C \"\n+\t\t\t       \"follows previous SAVE statement\"))\n \t    return MATCH_ERROR;\n \t}\n \n@@ -7048,9 +7005,8 @@ gfc_match_save (void)\n \n   if (gfc_current_ns->save_all)\n     {\n-      if (gfc_notify_std (GFC_STD_LEGACY, \"SAVE statement at %C follows \"\n-\t\t\t  \"blanket SAVE statement\")\n-\t  == FAILURE)\n+      if (!gfc_notify_std (GFC_STD_LEGACY, \"SAVE statement at %C follows \"\n+\t\t\t   \"blanket SAVE statement\"))\n \treturn MATCH_ERROR;\n     }\n \n@@ -7062,8 +7018,8 @@ gfc_match_save (void)\n       switch (m)\n \t{\n \tcase MATCH_YES:\n-\t  if (gfc_add_save (&sym->attr, SAVE_EXPLICIT, sym->name,\n-\t\t\t    &gfc_current_locus) == FAILURE)\n+\t  if (!gfc_add_save (&sym->attr, SAVE_EXPLICIT, sym->name, \n+\t\t\t     &gfc_current_locus))\n \t    return MATCH_ERROR;\n \t  goto next_item;\n \n@@ -7113,8 +7069,7 @@ gfc_match_value (void)\n       return MATCH_ERROR;\n     }\n \n-  if (gfc_notify_std (GFC_STD_F2003, \"VALUE statement at %C\")\n-      == FAILURE)\n+  if (!gfc_notify_std (GFC_STD_F2003, \"VALUE statement at %C\"))\n     return MATCH_ERROR;\n \n   if (gfc_match (\" ::\") == MATCH_NO && gfc_match_space () == MATCH_NO)\n@@ -7131,8 +7086,7 @@ gfc_match_value (void)\n       switch (m)\n \t{\n \tcase MATCH_YES:\n-\t  if (gfc_add_value (&sym->attr, sym->name, &gfc_current_locus)\n-\t      == FAILURE)\n+\t  if (!gfc_add_value (&sym->attr, sym->name, &gfc_current_locus))\n \t    return MATCH_ERROR;\n \t  goto next_item;\n \n@@ -7164,8 +7118,7 @@ gfc_match_volatile (void)\n   gfc_symbol *sym;\n   match m;\n \n-  if (gfc_notify_std (GFC_STD_F2003, \"VOLATILE statement at %C\")\n-      == FAILURE)\n+  if (!gfc_notify_std (GFC_STD_F2003, \"VOLATILE statement at %C\"))\n     return MATCH_ERROR;\n \n   if (gfc_match (\" ::\") == MATCH_NO && gfc_match_space () == MATCH_NO)\n@@ -7192,8 +7145,7 @@ gfc_match_volatile (void)\n \t\t\t \"%C, which is use-/host-associated\", sym->name);\n \t      return MATCH_ERROR;\n \t    }\n-\t  if (gfc_add_volatile (&sym->attr, sym->name, &gfc_current_locus)\n-\t      == FAILURE)\n+\t  if (!gfc_add_volatile (&sym->attr, sym->name, &gfc_current_locus))\n \t    return MATCH_ERROR;\n \t  goto next_item;\n \n@@ -7225,8 +7177,7 @@ gfc_match_asynchronous (void)\n   gfc_symbol *sym;\n   match m;\n \n-  if (gfc_notify_std (GFC_STD_F2003, \"ASYNCHRONOUS statement at %C\")\n-      == FAILURE)\n+  if (!gfc_notify_std (GFC_STD_F2003, \"ASYNCHRONOUS statement at %C\"))\n     return MATCH_ERROR;\n \n   if (gfc_match (\" ::\") == MATCH_NO && gfc_match_space () == MATCH_NO)\n@@ -7245,8 +7196,7 @@ gfc_match_asynchronous (void)\n       switch (m)\n \t{\n \tcase MATCH_YES:\n-\t  if (gfc_add_asynchronous (&sym->attr, sym->name, &gfc_current_locus)\n-\t      == FAILURE)\n+\t  if (!gfc_add_asynchronous (&sym->attr, sym->name, &gfc_current_locus))\n \t    return MATCH_ERROR;\n \t  goto next_item;\n \n@@ -7316,9 +7266,8 @@ gfc_match_modproc (void)\n   old_locus = gfc_current_locus;\n   if (gfc_match (\"::\") == MATCH_YES)\n     {\n-      if (gfc_notify_std (GFC_STD_F2008, \"double colon in \"\n-\t\t\t \"MODULE PROCEDURE statement at %L\", &old_locus)\n-\t  == FAILURE)\n+      if (!gfc_notify_std (GFC_STD_F2008, \"double colon in \"\n+\t\t\t   \"MODULE PROCEDURE statement at %L\", &old_locus))\n \treturn MATCH_ERROR;\n     }\n   else\n@@ -7356,11 +7305,10 @@ gfc_match_modproc (void)\n \t}\n \n       if (sym->attr.proc != PROC_MODULE\n-\t  && gfc_add_procedure (&sym->attr, PROC_MODULE,\n-\t\t\t\tsym->name, NULL) == FAILURE)\n+\t  && !gfc_add_procedure (&sym->attr, PROC_MODULE, sym->name, NULL))\n \treturn MATCH_ERROR;\n \n-      if (gfc_add_interface (sym) == FAILURE)\n+      if (!gfc_add_interface (sym))\n \treturn MATCH_ERROR;\n \n       sym->attr.mod_proc = 1;\n@@ -7455,7 +7403,7 @@ gfc_get_type_attr_spec (symbol_attribute *attr, char *name)\n \t  return MATCH_ERROR;\n \t}\n \n-      if (gfc_add_access (attr, ACCESS_PRIVATE, NULL, NULL) == FAILURE)\n+      if (!gfc_add_access (attr, ACCESS_PRIVATE, NULL, NULL))\n \treturn MATCH_ERROR;\n     }\n   else if (gfc_match (\" , public\") == MATCH_YES)\n@@ -7467,7 +7415,7 @@ gfc_get_type_attr_spec (symbol_attribute *attr, char *name)\n \t  return MATCH_ERROR;\n \t}\n \n-      if (gfc_add_access (attr, ACCESS_PUBLIC, NULL, NULL) == FAILURE)\n+      if (!gfc_add_access (attr, ACCESS_PUBLIC, NULL, NULL))\n \treturn MATCH_ERROR;\n     }\n   else if (gfc_match (\" , bind ( c )\") == MATCH_YES)\n@@ -7476,23 +7424,22 @@ gfc_get_type_attr_spec (symbol_attribute *attr, char *name)\n \t sure that all fields are interoperable.  This will\n \t need to be a semantic check on the finished derived type.\n \t See 15.2.3 (lines 9-12) of F2003 draft.  */\n-      if (gfc_add_is_bind_c (attr, NULL, &gfc_current_locus, 0) != SUCCESS)\n+      if (!gfc_add_is_bind_c (attr, NULL, &gfc_current_locus, 0))\n \treturn MATCH_ERROR;\n \n       /* TODO: attr conflicts need to be checked, probably in symbol.c.  */\n     }\n   else if (gfc_match (\" , abstract\") == MATCH_YES)\n     {\n-      if (gfc_notify_std (GFC_STD_F2003, \"ABSTRACT type at %C\")\n-\t    == FAILURE)\n+      if (!gfc_notify_std (GFC_STD_F2003, \"ABSTRACT type at %C\"))\n \treturn MATCH_ERROR;\n \n-      if (gfc_add_abstract (attr, &gfc_current_locus) == FAILURE)\n+      if (!gfc_add_abstract (attr, &gfc_current_locus))\n \treturn MATCH_ERROR;\n     }\n-  else if (name && gfc_match(\" , extends ( %n )\", name) == MATCH_YES)\n+  else if (name && gfc_match (\" , extends ( %n )\", name) == MATCH_YES)\n     {\n-      if (gfc_add_extension (attr, &gfc_current_locus) == FAILURE)\n+      if (!gfc_add_extension (attr, &gfc_current_locus))\n \treturn MATCH_ERROR;\n     }\n   else\n@@ -7575,11 +7522,11 @@ gfc_match_derived_decl (void)\n     }\n \n   if (!gensym->attr.generic\n-      && gfc_add_generic (&gensym->attr, gensym->name, NULL) == FAILURE)\n+      && !gfc_add_generic (&gensym->attr, gensym->name, NULL))\n     return MATCH_ERROR;\n \n   if (!gensym->attr.function\n-      && gfc_add_function (&gensym->attr, gensym->name, NULL) == FAILURE)\n+      && !gfc_add_function (&gensym->attr, gensym->name, NULL))\n     return MATCH_ERROR;\n \n   sym = gfc_find_dt_in_generic (gensym);\n@@ -7614,16 +7561,16 @@ gfc_match_derived_decl (void)\n      derived type that is a pointer.  The first part of the AND clause\n      is true if the symbol is not the return value of a function.  */\n   if (sym->attr.flavor != FL_DERIVED\n-      && gfc_add_flavor (&sym->attr, FL_DERIVED, sym->name, NULL) == FAILURE)\n+      && !gfc_add_flavor (&sym->attr, FL_DERIVED, sym->name, NULL))\n     return MATCH_ERROR;\n \n   if (attr.access != ACCESS_UNKNOWN\n-      && gfc_add_access (&sym->attr, attr.access, sym->name, NULL) == FAILURE)\n+      && !gfc_add_access (&sym->attr, attr.access, sym->name, NULL))\n     return MATCH_ERROR;\n   else if (sym->attr.access == ACCESS_UNKNOWN\n \t   && gensym->attr.access != ACCESS_UNKNOWN\n-\t   && gfc_add_access (&sym->attr, gensym->attr.access, sym->name, NULL)\n-\t      == FAILURE)\n+\t   && !gfc_add_access (&sym->attr, gensym->attr.access, \n+\t\t\t       sym->name, NULL))\n     return MATCH_ERROR;\n \n   if (sym->attr.access != ACCESS_UNKNOWN\n@@ -7714,8 +7661,7 @@ gfc_match_enum (void)\n   if (m != MATCH_YES)\n     return m;\n \n-  if (gfc_notify_std (GFC_STD_F2003, \"ENUM and ENUMERATOR at %C\")\n-      == FAILURE)\n+  if (!gfc_notify_std (GFC_STD_F2003, \"ENUM and ENUMERATOR at %C\"))\n     return MATCH_ERROR;\n \n   return MATCH_YES;\n@@ -7776,7 +7722,7 @@ enumerator_decl (void)\n   gfc_symbol *sym;\n   locus var_locus;\n   match m;\n-  gfc_try t;\n+  bool t;\n   locus old_locus;\n \n   initializer = NULL;\n@@ -7794,7 +7740,7 @@ enumerator_decl (void)\n   /* OK, we've successfully matched the declaration.  Now put the\n      symbol in the current namespace. If we fail to create the symbol,\n      bail out.  */\n-  if (build_sym (name, NULL, false, &as, &var_locus) == FAILURE)\n+  if (!build_sym (name, NULL, false, &as, &var_locus))\n     {\n       m = MATCH_ERROR;\n       goto cleanup;\n@@ -7842,7 +7788,7 @@ enumerator_decl (void)\n   gfc_find_symbol (name, NULL, 0, &sym);\n   create_enum_history (sym, last_initializer);\n \n-  return (t == SUCCESS) ? MATCH_YES : MATCH_ERROR;\n+  return (t) ? MATCH_YES : MATCH_ERROR;\n \n cleanup:\n   /* Free stuff up and return.  */\n@@ -7858,7 +7804,7 @@ match\n gfc_match_enumerator_def (void)\n {\n   match m;\n-  gfc_try t;\n+  bool t;\n \n   gfc_clear_ts (&current_ts);\n \n@@ -7884,7 +7830,7 @@ gfc_match_enumerator_def (void)\n \n   gfc_clear_attr (&current_attr);\n   t = gfc_add_flavor (&current_attr, FL_PARAMETER, NULL, NULL);\n-  if (t == FAILURE)\n+  if (!t)\n     {\n       m = MATCH_ERROR;\n       goto cleanup;\n@@ -8208,8 +8154,7 @@ match_procedure_in_type (void)\n \t  return MATCH_ERROR;\n \t}\n \n-      if (num>1 && gfc_notify_std (GFC_STD_F2008, \"PROCEDURE list\"\n-\t\t\t\t   \" at %C\") == FAILURE)\n+      if (num>1 && !gfc_notify_std (GFC_STD_F2008, \"PROCEDURE list at %C\"))\n \treturn MATCH_ERROR;\n \n       /* Try to match the '=> target', if it's there.  */\n@@ -8596,8 +8541,7 @@ gfc_match_final_decl (void)\n \n       /* Mark the symbol as module procedure.  */\n       if (sym->attr.proc != PROC_MODULE\n-\t  && gfc_add_procedure (&sym->attr, PROC_MODULE,\n-\t\t\t\tsym->name, NULL) == FAILURE)\n+\t  && !gfc_add_procedure (&sym->attr, PROC_MODULE, sym->name, NULL))\n \treturn MATCH_ERROR;\n \n       /* Check if we already have this symbol in the list, this is an error.  */\n@@ -8677,8 +8621,7 @@ gfc_match_gcc_attributes (void)\n \t  return MATCH_ERROR;\n \t}\n \n-      if (gfc_add_ext_attribute (&attr, (ext_attr_id_t) id, &gfc_current_locus)\n-\t  == FAILURE)\n+      if (!gfc_add_ext_attribute (&attr, (ext_attr_id_t)id, &gfc_current_locus))\n \treturn MATCH_ERROR;\n \n       gfc_gobble_whitespace ();"}, {"sha": "6f8e6dfbdc0dc5c3c7fd0bd19d1e46d2c75ac0b4", "filename": "gcc/fortran/dependency.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Fdependency.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Fdependency.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.c?ref=524af0d6c72031c249aa737945fde6ac3d726ba2", "patch": "@@ -756,7 +756,7 @@ gfc_dep_difference (gfc_expr *e1, gfc_expr *e2, mpz_t *result)\n \t}\n     }\n \n-  if (gfc_dep_compare_expr(e1, e2) == 0)\n+  if (gfc_dep_compare_expr (e1, e2) == 0)\n     {\n       /* Case 18: X - X = 0.  */\n       mpz_set_si (*result, 0);\n@@ -1548,7 +1548,7 @@ check_section_vs_section (gfc_array_ref *l_ar, gfc_array_ref *r_ar, int n)\n #define IS_CONSTANT_INTEGER(a) ((a) && ((a)->expr_type == EXPR_CONSTANT) \\\n \t\t\t      && (a)->ts.type == BT_INTEGER)\n \n-  if (IS_CONSTANT_INTEGER(l_stride) && IS_CONSTANT_INTEGER(r_stride)\n+  if (IS_CONSTANT_INTEGER (l_stride) && IS_CONSTANT_INTEGER (r_stride)\n       && gfc_dep_difference (l_start, r_start, &tmp))\n     {\n       mpz_t gcd;"}, {"sha": "60b209354c5742b69e975fa4624f4b6334239d02", "filename": "gcc/fortran/error.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ferror.c?ref=524af0d6c72031c249aa737945fde6ac3d726ba2", "patch": "@@ -806,10 +806,10 @@ gfc_notification_std (int std)\n \n /* Possibly issue a warning/error about use of a nonstandard (or deleted)\n    feature.  An error/warning will be issued if the currently selected\n-   standard does not contain the requested bits.  Return FAILURE if\n+   standard does not contain the requested bits.  Return false if\n    an error is generated.  */\n \n-gfc_try\n+bool\n gfc_notify_std (int std, const char *gmsgid, ...)\n {\n   va_list argp;\n@@ -819,10 +819,10 @@ gfc_notify_std (int std, const char *gmsgid, ...)\n \n   warning = ((gfc_option.warn_std & std) != 0) && !inhibit_warnings;\n   if ((gfc_option.allow_std & std) != 0 && !warning)\n-    return SUCCESS;\n+    return true;\n \n   if (suppress_errors)\n-    return warning ? SUCCESS : FAILURE;\n+    return warning ? true : false;\n \n   cur_error_buffer = warning ? &warning_buffer : &error_buffer;\n   cur_error_buffer->flag = 1;\n@@ -883,7 +883,7 @@ gfc_notify_std (int std, const char *gmsgid, ...)\n       cur_error_buffer->flag = 0;\n     }\n \n-  return (warning && !warnings_are_errors) ? SUCCESS : FAILURE;\n+  return (warning && !warnings_are_errors) ? true : false;\n }\n \n "}, {"sha": "1a531d92afcec043b09f118c29a14f3c30eeff24", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 319, "deletions": 327, "changes": 646, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=524af0d6c72031c249aa737945fde6ac3d726ba2", "patch": "@@ -610,7 +610,7 @@ gfc_replace_expr (gfc_expr *dest, gfc_expr *src)\n \n /* Try to extract an integer constant from the passed expression node.\n    Returns an error message or NULL if the result is set.  It is\n-   tempting to generate an error and return SUCCESS or FAILURE, but\n+   tempting to generate an error and return true or false, but\n    failure is OK for some callers.  */\n \n const char *\n@@ -1005,27 +1005,27 @@ is_subref_array (gfc_expr * e)\n \n /* Try to collapse intrinsic expressions.  */\n \n-static gfc_try\n+static bool\n simplify_intrinsic_op (gfc_expr *p, int type)\n {\n   gfc_intrinsic_op op;\n   gfc_expr *op1, *op2, *result;\n \n   if (p->value.op.op == INTRINSIC_USER)\n-    return SUCCESS;\n+    return true;\n \n   op1 = p->value.op.op1;\n   op2 = p->value.op.op2;\n   op  = p->value.op.op;\n \n-  if (gfc_simplify_expr (op1, type) == FAILURE)\n-    return FAILURE;\n-  if (gfc_simplify_expr (op2, type) == FAILURE)\n-    return FAILURE;\n+  if (!gfc_simplify_expr (op1, type))\n+    return false;\n+  if (!gfc_simplify_expr (op2, type))\n+    return false;\n \n   if (!gfc_is_constant_expr (op1)\n       || (op2 != NULL && !gfc_is_constant_expr (op2)))\n-    return SUCCESS;\n+    return true;\n \n   /* Rip p apart.  */\n   p->value.op.op1 = NULL;\n@@ -1127,21 +1127,21 @@ simplify_intrinsic_op (gfc_expr *p, int type)\n     {\n       gfc_free_expr (op1);\n       gfc_free_expr (op2);\n-      return FAILURE;\n+      return false;\n     }\n \n   result->rank = p->rank;\n   result->where = p->where;\n   gfc_replace_expr (p, result);\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n /* Subroutine to simplify constructor expressions.  Mutually recursive\n    with gfc_simplify_expr().  */\n \n-static gfc_try\n+static bool\n simplify_constructor (gfc_constructor_base base, int type)\n {\n   gfc_constructor *c;\n@@ -1150,10 +1150,10 @@ simplify_constructor (gfc_constructor_base base, int type)\n   for (c = gfc_constructor_first (base); c; c = gfc_constructor_next (c))\n     {\n       if (c->iterator\n-\t  && (gfc_simplify_expr (c->iterator->start, type) == FAILURE\n-\t      || gfc_simplify_expr (c->iterator->end, type) == FAILURE\n-\t      || gfc_simplify_expr (c->iterator->step, type) == FAILURE))\n-\treturn FAILURE;\n+\t  && (!gfc_simplify_expr(c->iterator->start, type)\n+\t      || !gfc_simplify_expr (c->iterator->end, type)\n+\t      || !gfc_simplify_expr (c->iterator->step, type)))\n+\treturn false;\n \n       if (c->expr)\n \t{\n@@ -1162,7 +1162,7 @@ simplify_constructor (gfc_constructor_base base, int type)\n \t     doing so can make a dog's dinner of complicated things.  */\n \t  p = gfc_copy_expr (c->expr);\n \n-\t  if (gfc_simplify_expr (p, type) == FAILURE)\n+\t  if (!gfc_simplify_expr (p, type))\n \t    {\n \t      gfc_free_expr (p);\n \t      continue;\n@@ -1172,13 +1172,13 @@ simplify_constructor (gfc_constructor_base base, int type)\n \t}\n     }\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n /* Pull a single array element out of an array constructor.  */\n \n-static gfc_try\n+static bool\n find_array_element (gfc_constructor_base base, gfc_array_ref *ar,\n \t\t    gfc_constructor **rval)\n {\n@@ -1190,9 +1190,9 @@ find_array_element (gfc_constructor_base base, gfc_array_ref *ar,\n   mpz_t tmp;\n   gfc_constructor *cons;\n   gfc_expr *e;\n-  gfc_try t;\n+  bool t;\n \n-  t = SUCCESS;\n+  t = true;\n   e = NULL;\n \n   mpz_init_set_ui (offset, 0);\n@@ -1201,10 +1201,10 @@ find_array_element (gfc_constructor_base base, gfc_array_ref *ar,\n   mpz_init_set_ui (span, 1);\n   for (i = 0; i < ar->dimen; i++)\n     {\n-      if (gfc_reduce_init_expr (ar->as->lower[i]) == FAILURE\n-\t  || gfc_reduce_init_expr (ar->as->upper[i]) == FAILURE)\n+      if (!gfc_reduce_init_expr (ar->as->lower[i])\n+\t  || !gfc_reduce_init_expr (ar->as->upper[i]))\n \t{\n-\t  t = FAILURE;\n+\t  t = false;\n \t  cons = NULL;\n \t  goto depart;\n \t}\n@@ -1229,7 +1229,7 @@ find_array_element (gfc_constructor_base base, gfc_array_ref *ar,\n \t  gfc_error (\"Index in dimension %d is out of bounds \"\n \t\t     \"at %L\", i + 1, &ar->c_where[i]);\n \t  cons = NULL;\n-\t  t = FAILURE;\n+\t  t = false;\n \t  goto depart;\n \t}\n \n@@ -1309,7 +1309,7 @@ remove_subobject_ref (gfc_expr *p, gfc_constructor *cons)\n \n /* Pull an array section out of an array constructor.  */\n \n-static gfc_try\n+static bool\n find_array_section (gfc_expr *expr, gfc_ref *ref)\n {\n   int idx;\n@@ -1335,9 +1335,9 @@ find_array_section (gfc_expr *expr, gfc_ref *ref)\n   gfc_expr *step;\n   gfc_expr *upper;\n   gfc_expr *lower;\n-  gfc_try t;\n+  bool t;\n \n-  t = SUCCESS;\n+  t = true;\n \n   base = expr->value.constructor;\n   expr->value.constructor = NULL;\n@@ -1381,7 +1381,7 @@ find_array_section (gfc_expr *expr, gfc_ref *ref)\n \n \t  if (begin->expr_type != EXPR_ARRAY || !gfc_is_constant_expr (begin))\n \t    {\n-\t      t = FAILURE;\n+\t      t = false;\n \t      goto cleanup;\n \t    }\n \n@@ -1407,7 +1407,7 @@ find_array_section (gfc_expr *expr, gfc_ref *ref)\n \t\t{\n \t\t  gfc_error (\"index in dimension %d is out of bounds \"\n \t\t\t     \"at %L\", d + 1, &ref->u.ar.c_where[d]);\n-\t\t  t = FAILURE;\n+\t\t  t = false;\n \t\t  goto cleanup;\n \t\t}\n \t    }\n@@ -1418,7 +1418,7 @@ find_array_section (gfc_expr *expr, gfc_ref *ref)\n \t      || (finish && finish->expr_type != EXPR_CONSTANT)\n \t      || (step && step->expr_type != EXPR_CONSTANT))\n \t    {\n-\t      t = FAILURE;\n+\t      t = false;\n \t      goto cleanup;\n \t    }\n \n@@ -1458,7 +1458,7 @@ find_array_section (gfc_expr *expr, gfc_ref *ref)\n \t    {\n \t      gfc_error (\"index in dimension %d is out of bounds \"\n \t\t\t \"at %L\", d + 1, &ref->u.ar.c_where[d]);\n-\t      t = FAILURE;\n+\t      t = false;\n \t      goto cleanup;\n \t    }\n \n@@ -1537,7 +1537,7 @@ find_array_section (gfc_expr *expr, gfc_ref *ref)\n \t\t     \"upper limit.   See -fmax-array-constructor \"\n \t\t     \"option\", &expr->where,\n \t\t     gfc_option.flag_max_array_constructor);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n \n       cons = gfc_constructor_lookup (base, limit);\n@@ -1567,7 +1567,7 @@ find_array_section (gfc_expr *expr, gfc_ref *ref)\n \n /* Pull a substring out of an expression.  */\n \n-static gfc_try\n+static bool\n find_substring_ref (gfc_expr *p, gfc_expr **newp)\n {\n   int end;\n@@ -1577,7 +1577,7 @@ find_substring_ref (gfc_expr *p, gfc_expr **newp)\n \n   if (p->ref->u.ss.start->expr_type != EXPR_CONSTANT\n       || p->ref->u.ss.end->expr_type != EXPR_CONSTANT)\n-    return FAILURE;\n+    return false;\n \n   *newp = gfc_copy_expr (p);\n   free ((*newp)->value.character.string);\n@@ -1591,15 +1591,15 @@ find_substring_ref (gfc_expr *p, gfc_expr **newp)\n   memcpy (chr, &p->value.character.string[start - 1],\n \t  length * sizeof (gfc_char_t));\n   chr[length] = '\\0';\n-  return SUCCESS;\n+  return true;\n }\n \n \n \n /* Simplify a subobject reference of a constructor.  This occurs when\n    parameter variable values are substituted.  */\n \n-static gfc_try\n+static bool\n simplify_const_ref (gfc_expr *p)\n {\n   gfc_constructor *cons, *c;\n@@ -1621,19 +1621,18 @@ simplify_const_ref (gfc_expr *p)\n \t\t  remove_subobject_ref (p, NULL);\n \t\t  break;\n \t\t}\n-\t      if (find_array_element (p->value.constructor, &p->ref->u.ar,\n-\t\t\t\t      &cons) == FAILURE)\n-\t\treturn FAILURE;\n+\t      if (!find_array_element (p->value.constructor, &p->ref->u.ar, &cons))\n+\t\treturn false;\n \n \t      if (!cons)\n-\t\treturn SUCCESS;\n+\t\treturn true;\n \n \t      remove_subobject_ref (p, cons);\n \t      break;\n \n \t    case AR_SECTION:\n-\t      if (find_array_section (p, p->ref) == FAILURE)\n-\t\treturn FAILURE;\n+\t      if (!find_array_section (p, p->ref))\n+\t\treturn false;\n \t      p->ref->u.ar.type = AR_FULL;\n \n \t    /* Fall through.  */\n@@ -1646,8 +1645,8 @@ simplify_const_ref (gfc_expr *p)\n \t\t       c; c = gfc_constructor_next (c))\n \t\t    {\n \t\t      c->expr->ref = gfc_copy_ref (p->ref->next);\n-\t\t      if (simplify_const_ref (c->expr) == FAILURE)\n-\t\t\treturn FAILURE;\n+\t\t      if (!simplify_const_ref (c->expr))\n+\t\t\treturn false;\n \t\t    }\n \n \t\t  if (p->ts.type == BT_DERIVED\n@@ -1695,7 +1694,7 @@ simplify_const_ref (gfc_expr *p)\n \t      break;\n \n \t    default:\n-\t      return SUCCESS;\n+\t      return true;\n \t    }\n \n \t  break;\n@@ -1706,8 +1705,8 @@ simplify_const_ref (gfc_expr *p)\n \t  break;\n \n \tcase REF_SUBSTRING:\n-  \t  if (find_substring_ref (p, &newp) == FAILURE)\n-\t    return FAILURE;\n+  \t  if (!find_substring_ref (p, &newp))\n+\t    return false;\n \n \t  gfc_replace_expr (p, newp);\n \t  gfc_free_ref_list (p->ref);\n@@ -1716,13 +1715,13 @@ simplify_const_ref (gfc_expr *p)\n \t}\n     }\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n /* Simplify a chain of references.  */\n \n-static gfc_try\n+static bool\n simplify_ref_chain (gfc_ref *ref, int type)\n {\n   int n;\n@@ -1734,41 +1733,41 @@ simplify_ref_chain (gfc_ref *ref, int type)\n \tcase REF_ARRAY:\n \t  for (n = 0; n < ref->u.ar.dimen; n++)\n \t    {\n-\t      if (gfc_simplify_expr (ref->u.ar.start[n], type) == FAILURE)\n-\t\treturn FAILURE;\n-\t      if (gfc_simplify_expr (ref->u.ar.end[n], type) == FAILURE)\n-\t\treturn FAILURE;\n-\t      if (gfc_simplify_expr (ref->u.ar.stride[n], type) == FAILURE)\n-\t\treturn FAILURE;\n+\t      if (!gfc_simplify_expr (ref->u.ar.start[n], type))\n+\t\treturn false;\n+\t      if (!gfc_simplify_expr (ref->u.ar.end[n], type))\n+\t\treturn false;\n+\t      if (!gfc_simplify_expr (ref->u.ar.stride[n], type))\n+\t\treturn false;\n \t    }\n \t  break;\n \n \tcase REF_SUBSTRING:\n-\t  if (gfc_simplify_expr (ref->u.ss.start, type) == FAILURE)\n-\t    return FAILURE;\n-\t  if (gfc_simplify_expr (ref->u.ss.end, type) == FAILURE)\n-\t    return FAILURE;\n+\t  if (!gfc_simplify_expr (ref->u.ss.start, type))\n+\t    return false;\n+\t  if (!gfc_simplify_expr (ref->u.ss.end, type))\n+\t    return false;\n \t  break;\n \n \tdefault:\n \t  break;\n \t}\n     }\n-  return SUCCESS;\n+  return true;\n }\n \n \n /* Try to substitute the value of a parameter variable.  */\n \n-static gfc_try\n+static bool\n simplify_parameter_variable (gfc_expr *p, int type)\n {\n   gfc_expr *e;\n-  gfc_try t;\n+  bool t;\n \n   e = gfc_copy_expr (p->symtree->n.sym->value);\n   if (e == NULL)\n-    return FAILURE;\n+    return false;\n \n   e->rank = p->rank;\n \n@@ -1778,7 +1777,7 @@ simplify_parameter_variable (gfc_expr *p, int type)\n   t = gfc_simplify_expr (e, type);\n \n   /* Only use the simplification if it eliminated all subobject references.  */\n-  if (t == SUCCESS && !e->ref)\n+  if (t && !e->ref)\n     gfc_replace_expr (p, e);\n   else\n     gfc_free_expr (e);\n@@ -1802,16 +1801,16 @@ simplify_parameter_variable (gfc_expr *p, int type)\n      0   Basic expression parsing\n      1   Simplifying array constructors -- will substitute\n \t iterator values.\n-   Returns FAILURE on error, SUCCESS otherwise.\n-   NOTE: Will return SUCCESS even if the expression can not be simplified.  */\n+   Returns false on error, true otherwise.\n+   NOTE: Will return true even if the expression can not be simplified.  */\n \n-gfc_try\n+bool\n gfc_simplify_expr (gfc_expr *p, int type)\n {\n   gfc_actual_arglist *ap;\n \n   if (p == NULL)\n-    return SUCCESS;\n+    return true;\n \n   switch (p->expr_type)\n     {\n@@ -1821,18 +1820,18 @@ gfc_simplify_expr (gfc_expr *p, int type)\n \n     case EXPR_FUNCTION:\n       for (ap = p->value.function.actual; ap; ap = ap->next)\n-\tif (gfc_simplify_expr (ap->expr, type) == FAILURE)\n-\t  return FAILURE;\n+\tif (!gfc_simplify_expr (ap->expr, type))\n+\t  return false;\n \n       if (p->value.function.isym != NULL\n \t  && gfc_intrinsic_func_interface (p, 1) == MATCH_ERROR)\n-\treturn FAILURE;\n+\treturn false;\n \n       break;\n \n     case EXPR_SUBSTRING:\n-      if (simplify_ref_chain (p->ref, type) == FAILURE)\n-\treturn FAILURE;\n+      if (!simplify_ref_chain (p->ref, type))\n+\treturn false;\n \n       if (gfc_is_constant_expr (p))\n \t{\n@@ -1871,8 +1870,8 @@ gfc_simplify_expr (gfc_expr *p, int type)\n       break;\n \n     case EXPR_OP:\n-      if (simplify_intrinsic_op (p, type) == FAILURE)\n-\treturn FAILURE;\n+      if (!simplify_intrinsic_op (p, type))\n+\treturn false;\n       break;\n \n     case EXPR_VARIABLE:\n@@ -1882,8 +1881,8 @@ gfc_simplify_expr (gfc_expr *p, int type)\n \t  && (gfc_init_expr_flag || p->ref\n \t      || p->symtree->n.sym->value->expr_type != EXPR_ARRAY))\n \t{\n-\t  if (simplify_parameter_variable (p, type) == FAILURE)\n-\t    return FAILURE;\n+\t  if (!simplify_parameter_variable (p, type))\n+\t    return false;\n \t  break;\n \t}\n \n@@ -1893,25 +1892,25 @@ gfc_simplify_expr (gfc_expr *p, int type)\n \t}\n \n       /* Simplify subcomponent references.  */\n-      if (simplify_ref_chain (p->ref, type) == FAILURE)\n-\treturn FAILURE;\n+      if (!simplify_ref_chain (p->ref, type))\n+\treturn false;\n \n       break;\n \n     case EXPR_STRUCTURE:\n     case EXPR_ARRAY:\n-      if (simplify_ref_chain (p->ref, type) == FAILURE)\n-\treturn FAILURE;\n+      if (!simplify_ref_chain (p->ref, type))\n+\treturn false;\n \n-      if (simplify_constructor (p->value.constructor, type) == FAILURE)\n-\treturn FAILURE;\n+      if (!simplify_constructor (p->value.constructor, type))\n+\treturn false;\n \n       if (p->expr_type == EXPR_ARRAY && p->ref && p->ref->type == REF_ARRAY\n \t  && p->ref->u.ar.type == AR_FULL)\n \t  gfc_expand_constructor (p, false);\n \n-      if (simplify_const_ref (p) == FAILURE)\n-\treturn FAILURE;\n+      if (!simplify_const_ref (p))\n+\treturn false;\n \n       break;\n \n@@ -1921,7 +1920,7 @@ gfc_simplify_expr (gfc_expr *p, int type)\n       break;\n     }\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n@@ -1932,7 +1931,7 @@ gfc_simplify_expr (gfc_expr *p, int type)\n static bt\n et0 (gfc_expr *e)\n {\n-  if (e->expr_type == EXPR_VARIABLE && gfc_check_iter_variable (e) == SUCCESS)\n+  if (e->expr_type == EXPR_VARIABLE && gfc_check_iter_variable (e))\n     return BT_INTEGER;\n \n   return e->ts.type;\n@@ -1941,7 +1940,7 @@ et0 (gfc_expr *e)\n \n /* Scalarize an expression for an elemental intrinsic call.  */\n \n-static gfc_try\n+static bool\n scalarize_intrinsic_call (gfc_expr *e)\n {\n   gfc_actual_arglist *a, *b;\n@@ -1967,7 +1966,7 @@ scalarize_intrinsic_call (gfc_expr *e)\n     }\n \n   if (!array_arg)\n-    return FAILURE;\n+    return false;\n \n   old = gfc_copy_expr (e);\n \n@@ -1984,7 +1983,7 @@ scalarize_intrinsic_call (gfc_expr *e)\n   for (; a; a = a->next)\n     {\n       /* Check that this is OK for an initialization expression.  */\n-      if (a->expr && gfc_check_init_expr (a->expr) == FAILURE)\n+      if (a->expr && !gfc_check_init_expr (a->expr))\n \tgoto cleanup;\n \n       rank[n] = 0;\n@@ -2060,26 +2059,26 @@ scalarize_intrinsic_call (gfc_expr *e)\n   /* Free \"expr\" but not the pointers it contains.  */\n   free (expr);\n   gfc_free_expr (old);\n-  return SUCCESS;\n+  return true;\n \n compliance:\n   gfc_error_now (\"elemental function arguments at %C are not compliant\");\n \n cleanup:\n   gfc_free_expr (expr);\n   gfc_free_expr (old);\n-  return FAILURE;\n+  return false;\n }\n \n \n-static gfc_try\n-check_intrinsic_op (gfc_expr *e, gfc_try (*check_function) (gfc_expr *))\n+static bool\n+check_intrinsic_op (gfc_expr *e, bool (*check_function) (gfc_expr *))\n {\n   gfc_expr *op1 = e->value.op.op1;\n   gfc_expr *op2 = e->value.op.op2;\n \n-  if ((*check_function) (op1) == FAILURE)\n-    return FAILURE;\n+  if (!(*check_function)(op1))\n+    return false;\n \n   switch (e->value.op.op)\n     {\n@@ -2101,15 +2100,15 @@ check_intrinsic_op (gfc_expr *e, gfc_try (*check_function) (gfc_expr *))\n     case INTRINSIC_LT_OS:\n     case INTRINSIC_LE:\n     case INTRINSIC_LE_OS:\n-      if ((*check_function) (op2) == FAILURE)\n-\treturn FAILURE;\n+      if (!(*check_function)(op2))\n+\treturn false;\n \n       if (!(et0 (op1) == BT_CHARACTER && et0 (op2) == BT_CHARACTER)\n \t  && !(numeric_type (et0 (op1)) && numeric_type (et0 (op2))))\n \t{\n \t  gfc_error (\"Numeric or CHARACTER operands are required in \"\n \t\t     \"expression at %L\", &e->where);\n-\t return FAILURE;\n+\t return false;\n \t}\n       break;\n \n@@ -2118,30 +2117,30 @@ check_intrinsic_op (gfc_expr *e, gfc_try (*check_function) (gfc_expr *))\n     case INTRINSIC_TIMES:\n     case INTRINSIC_DIVIDE:\n     case INTRINSIC_POWER:\n-      if ((*check_function) (op2) == FAILURE)\n-\treturn FAILURE;\n+      if (!(*check_function)(op2))\n+\treturn false;\n \n       if (!numeric_type (et0 (op1)) || !numeric_type (et0 (op2)))\n \tgoto not_numeric;\n \n       break;\n \n     case INTRINSIC_CONCAT:\n-      if ((*check_function) (op2) == FAILURE)\n-\treturn FAILURE;\n+      if (!(*check_function)(op2))\n+\treturn false;\n \n       if (et0 (op1) != BT_CHARACTER || et0 (op2) != BT_CHARACTER)\n \t{\n \t  gfc_error (\"Concatenation operator in expression at %L \"\n \t\t     \"must have two CHARACTER operands\", &op1->where);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n \n       if (op1->ts.kind != op2->ts.kind)\n \t{\n \t  gfc_error (\"Concat operator at %L must concatenate strings of the \"\n \t\t     \"same kind\", &e->where);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n \n       break;\n@@ -2151,7 +2150,7 @@ check_intrinsic_op (gfc_expr *e, gfc_try (*check_function) (gfc_expr *))\n \t{\n \t  gfc_error (\".NOT. operator in expression at %L must have a LOGICAL \"\n \t\t     \"operand\", &op1->where);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n \n       break;\n@@ -2160,14 +2159,14 @@ check_intrinsic_op (gfc_expr *e, gfc_try (*check_function) (gfc_expr *))\n     case INTRINSIC_OR:\n     case INTRINSIC_EQV:\n     case INTRINSIC_NEQV:\n-      if ((*check_function) (op2) == FAILURE)\n-\treturn FAILURE;\n+      if (!(*check_function)(op2))\n+\treturn false;\n \n       if (et0 (op1) != BT_LOGICAL || et0 (op2) != BT_LOGICAL)\n \t{\n \t  gfc_error (\"LOGICAL operands are required in expression at %L\",\n \t\t     &e->where);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n \n       break;\n@@ -2178,20 +2177,20 @@ check_intrinsic_op (gfc_expr *e, gfc_try (*check_function) (gfc_expr *))\n     default:\n       gfc_error (\"Only intrinsic operators can be used in expression at %L\",\n \t\t &e->where);\n-      return FAILURE;\n+      return false;\n     }\n \n-  return SUCCESS;\n+  return true;\n \n not_numeric:\n   gfc_error (\"Numeric operands are required in expression at %L\", &e->where);\n \n-  return FAILURE;\n+  return false;\n }\n \n /* F2003, 7.1.7 (3): In init expression, allocatable components\n    must not be data-initialized.  */\n-static gfc_try\n+static bool\n check_alloc_comp_init (gfc_expr *e)\n {\n   gfc_component *comp;\n@@ -2210,11 +2209,11 @@ check_alloc_comp_init (gfc_expr *e)\n \t  gfc_error(\"Invalid initialization expression for ALLOCATABLE \"\n \t            \"component '%s' in structure constructor at %L\",\n \t            comp->name, &ctor->expr->where);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n     }\n \n-  return SUCCESS;\n+  return true;\n }\n \n static match\n@@ -2223,13 +2222,13 @@ check_init_expr_arguments (gfc_expr *e)\n   gfc_actual_arglist *ap;\n \n   for (ap = e->value.function.actual; ap; ap = ap->next)\n-    if (gfc_check_init_expr (ap->expr) == FAILURE)\n+    if (!gfc_check_init_expr (ap->expr))\n       return MATCH_ERROR;\n \n   return MATCH_YES;\n }\n \n-static gfc_try check_restricted (gfc_expr *);\n+static bool check_restricted (gfc_expr *);\n \n /* F95, 7.1.6.1, Initialization expressions, (7)\n    F2003, 7.1.7 Initialization expression, (8)  */\n@@ -2305,8 +2304,7 @@ check_inquiry (gfc_expr *e, int not_restricted)\n       if (ap->expr->ts.type == BT_UNKNOWN)\n \t{\n \t  if (ap->expr->symtree->n.sym->ts.type == BT_UNKNOWN\n-\t      && gfc_set_default_type (ap->expr->symtree->n.sym, 0, gfc_current_ns)\n-\t      == FAILURE)\n+\t      && !gfc_set_default_type (ap->expr->symtree->n.sym, 0, gfc_current_ns))\n \t    return MATCH_NO;\n \n \t  ap->expr->ts = ap->expr->symtree->n.sym->ts;\n@@ -2325,12 +2323,12 @@ check_inquiry (gfc_expr *e, int not_restricted)\n \t\t\t&ap->expr->where);\n \t      return MATCH_ERROR;\n \t  }\n-\telse if (not_restricted && gfc_check_init_expr (ap->expr) == FAILURE)\n+\telse if (not_restricted && !gfc_check_init_expr (ap->expr))\n \t  return MATCH_ERROR;\n \n \tif (not_restricted == 0\n \t      && ap->expr->expr_type != EXPR_VARIABLE\n-\t      && check_restricted (ap->expr) == FAILURE)\n+\t      && !check_restricted (ap->expr))\n \t  return MATCH_ERROR;\n \n \tif (not_restricted == 0\n@@ -2416,9 +2414,8 @@ check_elemental (gfc_expr *e)\n \n   if (e->ts.type != BT_INTEGER\n       && e->ts.type != BT_CHARACTER\n-      && gfc_notify_std (GFC_STD_F2003, \"Evaluation of \"\n-\t\t\t\"nonstandard initialization expression at %L\",\n-\t\t\t&e->where) == FAILURE)\n+      && !gfc_notify_std (GFC_STD_F2003, \"Evaluation of nonstandard \"\n+\t\t\t  \"initialization expression at %L\", &e->where))\n     return MATCH_ERROR;\n \n   return check_init_expr_arguments (e);\n@@ -2441,28 +2438,28 @@ check_conversion (gfc_expr *e)\n    node if all goes well.  This would normally happen when the\n    expression is constructed but function references are assumed to be\n    intrinsics in the context of initialization expressions.  If\n-   FAILURE is returned an error message has been generated.  */\n+   false is returned an error message has been generated.  */\n \n-gfc_try\n+bool\n gfc_check_init_expr (gfc_expr *e)\n {\n   match m;\n-  gfc_try t;\n+  bool t;\n \n   if (e == NULL)\n-    return SUCCESS;\n+    return true;\n \n   switch (e->expr_type)\n     {\n     case EXPR_OP:\n       t = check_intrinsic_op (e, gfc_check_init_expr);\n-      if (t == SUCCESS)\n+      if (t)\n \tt = gfc_simplify_expr (e, 0);\n \n       break;\n \n     case EXPR_FUNCTION:\n-      t = FAILURE;\n+      t = false;\n \n       {\n \tgfc_intrinsic_sym* isym;\n@@ -2491,13 +2488,13 @@ gfc_check_init_expr (gfc_expr *e)\n \t  }\n \n \tif (m == MATCH_ERROR)\n-\t  return FAILURE;\n+\t  return false;\n \n \t/* Try to scalarize an elemental intrinsic function that has an\n \t   array argument.  */\n \tisym = gfc_find_function (e->symtree->n.sym->name);\n \tif (isym && isym->elemental\n-\t    && (t = scalarize_intrinsic_call (e)) == SUCCESS)\n+\t    && (t = scalarize_intrinsic_call(e)))\n \t  break;\n       }\n \n@@ -2507,9 +2504,9 @@ gfc_check_init_expr (gfc_expr *e)\n       break;\n \n     case EXPR_VARIABLE:\n-      t = SUCCESS;\n+      t = true;\n \n-      if (gfc_check_iter_variable (e) == SUCCESS)\n+      if (gfc_check_iter_variable (e))\n \tbreak;\n \n       if (e->symtree->n.sym->attr.flavor == FL_PARAMETER)\n@@ -2521,7 +2518,7 @@ gfc_check_init_expr (gfc_expr *e)\n \t    {\n \t      gfc_error(\"PARAMETER '%s' is used at %L before its definition \"\n \t\t\t\"is complete\", e->symtree->n.sym->name, &e->where);\n-\t      t = FAILURE;\n+\t      t = false;\n \t    }\n \t  else\n \t    t = simplify_parameter_variable (e, 0);\n@@ -2532,7 +2529,7 @@ gfc_check_init_expr (gfc_expr *e)\n       if (gfc_in_match_data ())\n \tbreak;\n \n-      t = FAILURE;\n+      t = false;\n \n       if (e->symtree->n.sym->as)\n \t{\n@@ -2575,42 +2572,42 @@ gfc_check_init_expr (gfc_expr *e)\n \n     case EXPR_CONSTANT:\n     case EXPR_NULL:\n-      t = SUCCESS;\n+      t = true;\n       break;\n \n     case EXPR_SUBSTRING:\n       t = gfc_check_init_expr (e->ref->u.ss.start);\n-      if (t == FAILURE)\n+      if (!t)\n \tbreak;\n \n       t = gfc_check_init_expr (e->ref->u.ss.end);\n-      if (t == SUCCESS)\n+      if (t)\n \tt = gfc_simplify_expr (e, 0);\n \n       break;\n \n     case EXPR_STRUCTURE:\n-      t = e->ts.is_iso_c ? SUCCESS : FAILURE;\n-      if (t == SUCCESS)\n+      t = e->ts.is_iso_c ? true : false;\n+      if (t)\n \tbreak;\n \n       t = check_alloc_comp_init (e);\n-      if (t == FAILURE)\n+      if (!t)\n \tbreak;\n \n       t = gfc_check_constructor (e, gfc_check_init_expr);\n-      if (t == FAILURE)\n+      if (!t)\n \tbreak;\n \n       break;\n \n     case EXPR_ARRAY:\n       t = gfc_check_constructor (e, gfc_check_init_expr);\n-      if (t == FAILURE)\n+      if (!t)\n \tbreak;\n \n       t = gfc_expand_constructor (e, true);\n-      if (t == FAILURE)\n+      if (!t)\n \tbreak;\n \n       t = gfc_check_constructor_type (e);\n@@ -2625,31 +2622,31 @@ gfc_check_init_expr (gfc_expr *e)\n \n /* Reduces a general expression to an initialization expression (a constant).\n    This used to be part of gfc_match_init_expr.\n-   Note that this function doesn't free the given expression on FAILURE.  */\n+   Note that this function doesn't free the given expression on false.  */\n \n-gfc_try\n+bool\n gfc_reduce_init_expr (gfc_expr *expr)\n {\n-  gfc_try t;\n+  bool t;\n \n   gfc_init_expr_flag = true;\n   t = gfc_resolve_expr (expr);\n-  if (t == SUCCESS)\n+  if (t)\n     t = gfc_check_init_expr (expr);\n   gfc_init_expr_flag = false;\n \n-  if (t == FAILURE)\n-    return FAILURE;\n+  if (!t)\n+    return false;\n \n   if (expr->expr_type == EXPR_ARRAY)\n     {\n-      if (gfc_check_constructor_type (expr) == FAILURE)\n-\treturn FAILURE;\n-      if (gfc_expand_constructor (expr, true) == FAILURE)\n-\treturn FAILURE;\n+      if (!gfc_check_constructor_type (expr))\n+\treturn false;\n+      if (!gfc_expand_constructor (expr, true))\n+\treturn false;\n     }\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n@@ -2661,7 +2658,7 @@ gfc_match_init_expr (gfc_expr **result)\n {\n   gfc_expr *expr;\n   match m;\n-  gfc_try t;\n+  bool t;\n \n   expr = NULL;\n \n@@ -2675,7 +2672,7 @@ gfc_match_init_expr (gfc_expr **result)\n     }\n \n   t = gfc_reduce_init_expr (expr);\n-  if (t != SUCCESS)\n+  if (!t)\n     {\n       gfc_free_expr (expr);\n       gfc_init_expr_flag = false;\n@@ -2693,16 +2690,16 @@ gfc_match_init_expr (gfc_expr **result)\n    restricted expression and optionally if the expression type is\n    integer or character.  */\n \n-static gfc_try\n+static bool\n restricted_args (gfc_actual_arglist *a)\n {\n   for (; a; a = a->next)\n     {\n-      if (check_restricted (a->expr) == FAILURE)\n-\treturn FAILURE;\n+      if (!check_restricted (a->expr))\n+\treturn false;\n     }\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n@@ -2711,7 +2708,7 @@ restricted_args (gfc_actual_arglist *a)\n \n /* Make sure a non-intrinsic function is a specification function.  */\n \n-static gfc_try\n+static bool\n external_spec_function (gfc_expr *e)\n {\n   gfc_symbol *f;\n@@ -2722,28 +2719,28 @@ external_spec_function (gfc_expr *e)\n     {\n       gfc_error (\"Specification function '%s' at %L cannot be a statement \"\n \t\t \"function\", f->name, &e->where);\n-      return FAILURE;\n+      return false;\n     }\n \n   if (f->attr.proc == PROC_INTERNAL)\n     {\n       gfc_error (\"Specification function '%s' at %L cannot be an internal \"\n \t\t \"function\", f->name, &e->where);\n-      return FAILURE;\n+      return false;\n     }\n \n   if (!f->attr.pure && !f->attr.elemental)\n     {\n       gfc_error (\"Specification function '%s' at %L must be PURE\", f->name,\n \t\t &e->where);\n-      return FAILURE;\n+      return false;\n     }\n \n   if (f->attr.recursive)\n     {\n       gfc_error (\"Specification function '%s' at %L cannot be RECURSIVE\",\n \t\t f->name, &e->where);\n-      return FAILURE;\n+      return false;\n     }\n \n   return restricted_args (e->value.function.actual);\n@@ -2753,52 +2750,52 @@ external_spec_function (gfc_expr *e)\n /* Check to see that a function reference to an intrinsic is a\n    restricted expression.  */\n \n-static gfc_try\n+static bool\n restricted_intrinsic (gfc_expr *e)\n {\n   /* TODO: Check constraints on inquiry functions.  7.1.6.2 (7).  */\n   if (check_inquiry (e, 0) == MATCH_YES)\n-    return SUCCESS;\n+    return true;\n \n   return restricted_args (e->value.function.actual);\n }\n \n \n /* Check the expressions of an actual arglist.  Used by check_restricted.  */\n \n-static gfc_try\n-check_arglist (gfc_actual_arglist* arg, gfc_try (*checker) (gfc_expr*))\n+static bool\n+check_arglist (gfc_actual_arglist* arg, bool (*checker) (gfc_expr*))\n {\n   for (; arg; arg = arg->next)\n-    if (checker (arg->expr) == FAILURE)\n-      return FAILURE;\n+    if (!checker (arg->expr))\n+      return false;\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n /* Check the subscription expressions of a reference chain with a checking\n    function; used by check_restricted.  */\n \n-static gfc_try\n-check_references (gfc_ref* ref, gfc_try (*checker) (gfc_expr*))\n+static bool\n+check_references (gfc_ref* ref, bool (*checker) (gfc_expr*))\n {\n   int dim;\n \n   if (!ref)\n-    return SUCCESS;\n+    return true;\n \n   switch (ref->type)\n     {\n     case REF_ARRAY:\n       for (dim = 0; dim != ref->u.ar.dimen; ++dim)\n \t{\n-\t  if (checker (ref->u.ar.start[dim]) == FAILURE)\n-\t    return FAILURE;\n-\t  if (checker (ref->u.ar.end[dim]) == FAILURE)\n-\t    return FAILURE;\n-\t  if (checker (ref->u.ar.stride[dim]) == FAILURE)\n-\t    return FAILURE;\n+\t  if (!checker (ref->u.ar.start[dim]))\n+\t    return false;\n+\t  if (!checker (ref->u.ar.end[dim]))\n+\t    return false;\n+\t  if (!checker (ref->u.ar.stride[dim]))\n+\t    return false;\n \t}\n       break;\n \n@@ -2807,10 +2804,10 @@ check_references (gfc_ref* ref, gfc_try (*checker) (gfc_expr*))\n       break;\n \n     case REF_SUBSTRING:\n-      if (checker (ref->u.ss.start) == FAILURE)\n-\treturn FAILURE;\n-      if (checker (ref->u.ss.end) == FAILURE)\n-\treturn FAILURE;\n+      if (!checker (ref->u.ss.start))\n+\treturn false;\n+      if (!checker (ref->u.ss.end))\n+\treturn false;\n       break;\n \n     default:\n@@ -2824,22 +2821,22 @@ check_references (gfc_ref* ref, gfc_try (*checker) (gfc_expr*))\n \n /* Verify that an expression is a restricted expression.  Like its\n    cousin check_init_expr(), an error message is generated if we\n-   return FAILURE.  */\n+   return false.  */\n \n-static gfc_try\n+static bool\n check_restricted (gfc_expr *e)\n {\n   gfc_symbol* sym;\n-  gfc_try t;\n+  bool t;\n \n   if (e == NULL)\n-    return SUCCESS;\n+    return true;\n \n   switch (e->expr_type)\n     {\n     case EXPR_OP:\n       t = check_intrinsic_op (e, check_restricted);\n-      if (t == SUCCESS)\n+      if (t)\n \tt = gfc_simplify_expr (e, 0);\n \n       break;\n@@ -2848,24 +2845,24 @@ check_restricted (gfc_expr *e)\n       if (e->value.function.esym)\n \t{\n \t  t = check_arglist (e->value.function.actual, &check_restricted);\n-\t  if (t == SUCCESS)\n+\t  if (t)\n \t    t = external_spec_function (e);\n \t}\n       else\n \t{\n \t  if (e->value.function.isym && e->value.function.isym->inquiry)\n-\t    t = SUCCESS;\n+\t    t = true;\n \t  else\n \t    t = check_arglist (e->value.function.actual, &check_restricted);\n \n-\t  if (t == SUCCESS)\n+\t  if (t)\n \t    t = restricted_intrinsic (e);\n \t}\n       break;\n \n     case EXPR_VARIABLE:\n       sym = e->symtree->n.sym;\n-      t = FAILURE;\n+      t = false;\n \n       /* If a dummy argument appears in a context that is valid for a\n \t restricted expression in an elemental procedure, it will have\n@@ -2895,7 +2892,7 @@ check_restricted (gfc_expr *e)\n \t}\n \n       /* Check reference chain if any.  */\n-      if (check_references (e->ref, &check_restricted) == FAILURE)\n+      if (!check_references (e->ref, &check_restricted))\n \tbreak;\n \n       /* gfc_is_formal_arg broadcasts that a formal argument list is being\n@@ -2916,7 +2913,7 @@ check_restricted (gfc_expr *e)\n \t\t  && sym->ns->proc_name->attr.flavor == FL_MODULE)\n \t    || (gfc_is_formal_arg () && (sym->ns == gfc_current_ns)))\n \t{\n-\t  t = SUCCESS;\n+\t  t = true;\n \t  break;\n \t}\n \n@@ -2928,16 +2925,16 @@ check_restricted (gfc_expr *e)\n \n     case EXPR_NULL:\n     case EXPR_CONSTANT:\n-      t = SUCCESS;\n+      t = true;\n       break;\n \n     case EXPR_SUBSTRING:\n       t = gfc_specification_expr (e->ref->u.ss.start);\n-      if (t == FAILURE)\n+      if (!t)\n \tbreak;\n \n       t = gfc_specification_expr (e->ref->u.ss.end);\n-      if (t == SUCCESS)\n+      if (t)\n \tt = gfc_simplify_expr (e, 0);\n \n       break;\n@@ -2959,21 +2956,21 @@ check_restricted (gfc_expr *e)\n \n \n /* Check to see that an expression is a specification expression.  If\n-   we return FAILURE, an error has been generated.  */\n+   we return false, an error has been generated.  */\n \n-gfc_try\n+bool\n gfc_specification_expr (gfc_expr *e)\n {\n   gfc_component *comp;\n \n   if (e == NULL)\n-    return SUCCESS;\n+    return true;\n \n   if (e->ts.type != BT_INTEGER)\n     {\n       gfc_error (\"Expression at %L must be of INTEGER type, found %s\",\n \t\t &e->where, gfc_basic_typename (e->ts.type));\n-      return FAILURE;\n+      return false;\n     }\n \n   comp = gfc_get_proc_ptr_comp (e);\n@@ -2987,17 +2984,17 @@ gfc_specification_expr (gfc_expr *e)\n \t\t e->symtree->n.sym->name, &e->where);\n       /* Prevent repeat error messages.  */\n       e->symtree->n.sym->attr.pure = 1;\n-      return FAILURE;\n+      return false;\n     }\n \n   if (e->rank != 0)\n     {\n       gfc_error (\"Expression at %L must be scalar\", &e->where);\n-      return FAILURE;\n+      return false;\n     }\n \n-  if (gfc_simplify_expr (e, 0) == FAILURE)\n-    return FAILURE;\n+  if (!gfc_simplify_expr (e, 0))\n+    return false;\n \n   return check_restricted (e);\n }\n@@ -3007,18 +3004,18 @@ gfc_specification_expr (gfc_expr *e)\n \n /* Given two expressions, make sure that the arrays are conformable.  */\n \n-gfc_try\n+bool\n gfc_check_conformance (gfc_expr *op1, gfc_expr *op2, const char *optype_msgid, ...)\n {\n   int op1_flag, op2_flag, d;\n   mpz_t op1_size, op2_size;\n-  gfc_try t;\n+  bool t;\n \n   va_list argp;\n   char buffer[240];\n \n   if (op1->rank == 0 || op2->rank == 0)\n-    return SUCCESS;\n+    return true;\n \n   va_start (argp, optype_msgid);\n   vsnprintf (buffer, 240, optype_msgid, argp);\n@@ -3028,15 +3025,15 @@ gfc_check_conformance (gfc_expr *op1, gfc_expr *op2, const char *optype_msgid, .\n     {\n       gfc_error (\"Incompatible ranks in %s (%d and %d) at %L\", _(buffer),\n \t\t op1->rank, op2->rank, &op1->where);\n-      return FAILURE;\n+      return false;\n     }\n \n-  t = SUCCESS;\n+  t = true;\n \n   for (d = 0; d < op1->rank; d++)\n     {\n-      op1_flag = gfc_array_dimen_size (op1, d, &op1_size) == SUCCESS;\n-      op2_flag = gfc_array_dimen_size (op2, d, &op2_size) == SUCCESS;\n+      op1_flag = gfc_array_dimen_size(op1, d, &op1_size);\n+      op2_flag = gfc_array_dimen_size(op2, d, &op2_size);\n \n       if (op1_flag && op2_flag && mpz_cmp (op1_size, op2_size) != 0)\n \t{\n@@ -3045,26 +3042,26 @@ gfc_check_conformance (gfc_expr *op1, gfc_expr *op2, const char *optype_msgid, .\n \t\t     (int) mpz_get_si (op1_size),\n \t\t     (int) mpz_get_si (op2_size));\n \n-\t  t = FAILURE;\n+\t  t = false;\n \t}\n \n       if (op1_flag)\n \tmpz_clear (op1_size);\n       if (op2_flag)\n \tmpz_clear (op2_size);\n \n-      if (t == FAILURE)\n-\treturn FAILURE;\n+      if (!t)\n+\treturn false;\n     }\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n /* Given an assignable expression and an arbitrary expression, make\n    sure that the assignment can take place.  */\n \n-gfc_try\n+bool\n gfc_check_assign (gfc_expr *lvalue, gfc_expr *rvalue, int conform)\n {\n   gfc_symbol *sym;\n@@ -3130,34 +3127,34 @@ gfc_check_assign (gfc_expr *lvalue, gfc_expr *rvalue, int conform)\n       if (bad_proc)\n \t{\n \t  gfc_error (\"'%s' at %L is not a VALUE\", sym->name, &lvalue->where);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n     }\n \n   if (rvalue->rank != 0 && lvalue->rank != rvalue->rank)\n     {\n       gfc_error (\"Incompatible ranks %d and %d in assignment at %L\",\n \t\t lvalue->rank, rvalue->rank, &lvalue->where);\n-      return FAILURE;\n+      return false;\n     }\n \n   if (lvalue->ts.type == BT_UNKNOWN)\n     {\n       gfc_error (\"Variable type is UNKNOWN in assignment at %L\",\n \t\t &lvalue->where);\n-      return FAILURE;\n+      return false;\n     }\n \n   if (rvalue->expr_type == EXPR_NULL)\n     {\n       if (has_pointer && (ref == NULL || ref->next == NULL)\n \t  && lvalue->symtree->n.sym->attr.data)\n-        return SUCCESS;\n+        return true;\n       else\n \t{\n \t  gfc_error (\"NULL appears on right-hand side in assignment at %L\",\n \t\t     &rvalue->where);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n     }\n \n@@ -3169,21 +3166,20 @@ gfc_check_assign (gfc_expr *lvalue, gfc_expr *rvalue, int conform)\n \n   /* Check size of array assignments.  */\n   if (lvalue->rank != 0 && rvalue->rank != 0\n-      && gfc_check_conformance (lvalue, rvalue, \"array assignment\") != SUCCESS)\n-    return FAILURE;\n+      && !gfc_check_conformance (lvalue, rvalue, \"array assignment\"))\n+    return false;\n \n   if (rvalue->is_boz && lvalue->ts.type != BT_INTEGER\n       && lvalue->symtree->n.sym->attr.data\n-      && gfc_notify_std (GFC_STD_GNU, \"BOZ literal at %L used to \"\n-                         \"initialize non-integer variable '%s'\",\n-\t\t\t &rvalue->where, lvalue->symtree->n.sym->name)\n-\t == FAILURE)\n-    return FAILURE;\n+      && !gfc_notify_std (GFC_STD_GNU, \"BOZ literal at %L used to \"\n+\t\t\t  \"initialize non-integer variable '%s'\", \n+\t\t\t  &rvalue->where, lvalue->symtree->n.sym->name))\n+    return false;\n   else if (rvalue->is_boz && !lvalue->symtree->n.sym->attr.data\n-      && gfc_notify_std (GFC_STD_GNU, \"BOZ literal at %L outside \"\n-\t\t\t \"a DATA statement and outside INT/REAL/DBLE/CMPLX\",\n-\t\t\t &rvalue->where) == FAILURE)\n-    return FAILURE;\n+      && !gfc_notify_std (GFC_STD_GNU, \"BOZ literal at %L outside \"\n+\t\t\t  \"a DATA statement and outside INT/REAL/DBLE/CMPLX\",\n+\t\t\t  &rvalue->where))\n+    return false;\n \n   /* Handle the case of a BOZ literal on the RHS.  */\n   if (rvalue->is_boz && lvalue->ts.type != BT_INTEGER)\n@@ -3194,7 +3190,7 @@ gfc_check_assign (gfc_expr *lvalue, gfc_expr *rvalue, int conform)\n                      \"non-integer symbol '%s'\", &rvalue->where,\n                      lvalue->symtree->n.sym->name);\n       if (!gfc_convert_boz (rvalue, &lvalue->ts))\n-\treturn FAILURE;\n+\treturn false;\n       if ((rc = gfc_range_check (rvalue)) != ARITH_OK)\n \t{\n \t  if (rc == ARITH_UNDERFLOW)\n@@ -3209,7 +3205,7 @@ gfc_check_assign (gfc_expr *lvalue, gfc_expr *rvalue, int conform)\n \t    gfc_error (\"Arithmetic NaN of bit-wise transferred BOZ at %L\"\n \t\t       \". This check can be disabled with the option \"\n \t\t       \"-fno-range-check\", &rvalue->where);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n     }\n \n@@ -3261,7 +3257,7 @@ gfc_check_assign (gfc_expr *lvalue, gfc_expr *rvalue, int conform)\n     }\n \n   if (gfc_compare_types (&lvalue->ts, &rvalue->ts))\n-    return SUCCESS;\n+    return true;\n \n   /* Only DATA Statements come here.  */\n   if (!conform)\n@@ -3270,16 +3266,16 @@ gfc_check_assign (gfc_expr *lvalue, gfc_expr *rvalue, int conform)\n \t converted to any other type.  */\n       if ((gfc_numeric_ts (&lvalue->ts) && gfc_numeric_ts (&rvalue->ts))\n \t  || rvalue->ts.type == BT_HOLLERITH)\n-\treturn SUCCESS;\n+\treturn true;\n \n       if (lvalue->ts.type == BT_LOGICAL && rvalue->ts.type == BT_LOGICAL)\n-\treturn SUCCESS;\n+\treturn true;\n \n       gfc_error (\"Incompatible types in DATA statement at %L; attempted \"\n \t\t \"conversion of %s to %s\", &lvalue->where,\n \t\t gfc_typename (&rvalue->ts), gfc_typename (&lvalue->ts));\n \n-      return FAILURE;\n+      return false;\n     }\n \n   /* Assignment is the only case where character variables of different\n@@ -3289,7 +3285,7 @@ gfc_check_assign (gfc_expr *lvalue, gfc_expr *rvalue, int conform)\n       if (lvalue->ts.kind != rvalue->ts.kind)\n \tgfc_convert_chartype (rvalue, &lvalue->ts);\n \n-      return SUCCESS;\n+      return true;\n     }\n \n   return gfc_convert_type (rvalue, &lvalue->ts, 1);\n@@ -3300,7 +3296,7 @@ gfc_check_assign (gfc_expr *lvalue, gfc_expr *rvalue, int conform)\n    we only check rvalue if it's not an assignment to NULL() or a\n    NULLIFY statement.  */\n \n-gfc_try\n+bool\n gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n {\n   symbol_attribute attr, lhs_attr;\n@@ -3313,7 +3309,7 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n     {\n       gfc_error (\"Pointer assignment target is not a POINTER at %L\",\n \t\t &lvalue->where);\n-      return FAILURE;\n+      return false;\n     }\n \n   if (lhs_attr.flavor == FL_PROCEDURE && lhs_attr.use_assoc\n@@ -3322,7 +3318,7 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n       gfc_error (\"'%s' in the pointer assignment at %L cannot be an \"\n \t\t \"l-value since it is a procedure\",\n \t\t lvalue->symtree->n.sym->name, &lvalue->where);\n-      return FAILURE;\n+      return false;\n     }\n \n   proc_pointer = lvalue->symtree->n.sym->attr.proc_pointer;\n@@ -3344,14 +3340,13 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n \t    {\n \t      gfc_error (\"Expected bounds specification for '%s' at %L\",\n \t\t\t lvalue->symtree->n.sym->name, &lvalue->where);\n-\t      return FAILURE;\n+\t      return false;\n \t    }\n \n-\t  if (gfc_notify_std (GFC_STD_F2003,\"Bounds \"\n-\t\t\t      \"specification for '%s' in pointer assignment \"\n-\t\t\t      \"at %L\", lvalue->symtree->n.sym->name,\n-\t\t\t      &lvalue->where) == FAILURE)\n-\t    return FAILURE;\n+\t  if (!gfc_notify_std (GFC_STD_F2003, \"Bounds specification \"\n+\t\t\t       \"for '%s' in pointer assignment at %L\", \n+\t\t\t       lvalue->symtree->n.sym->name, &lvalue->where))\n+\t    return false;\n \n \t  /* When bounds are given, all lbounds are necessary and either all\n \t     or none of the upper bounds; no strides are allowed.  If the\n@@ -3363,13 +3358,13 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n \t\t{\n \t\t  gfc_error (\"Lower bound has to be present at %L\",\n \t\t\t     &lvalue->where);\n-\t\t  return FAILURE;\n+\t\t  return false;\n \t\t}\n \t      if (ref->u.ar.stride[dim])\n \t\t{\n \t\t  gfc_error (\"Stride must not be present at %L\",\n \t\t\t     &lvalue->where);\n-\t\t  return FAILURE;\n+\t\t  return false;\n \t\t}\n \n \t      if (dim == 0)\n@@ -3381,7 +3376,7 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n \t\t    {\n \t\t      gfc_error (\"Either all or none of the upper bounds\"\n \t\t\t\t \" must be specified at %L\", &lvalue->where);\n-\t\t      return FAILURE;\n+\t\t      return false;\n \t\t    }\n \t\t}\n \t    }\n@@ -3395,7 +3390,7 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n      kind, etc for lvalue and rvalue must match, and rvalue must be a\n      pure variable if we're in a pure function.  */\n   if (rvalue->expr_type == EXPR_NULL && rvalue->ts.type == BT_UNKNOWN)\n-    return SUCCESS;\n+    return true;\n \n   /* F2008, C723 (pointer) and C726 (proc-pointer); for PURE also C1283.  */\n   if (lvalue->expr_type == EXPR_VARIABLE\n@@ -3407,7 +3402,7 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n \t  {\n \t    gfc_error (\"Pointer object at %L shall not have a coindex\",\n \t\t       &lvalue->where);\n-\t    return FAILURE;\n+\t    return false;\n \t  }\n     }\n \n@@ -3428,7 +3423,7 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n \t{\n \t  gfc_error (\"Invalid procedure pointer assignment at %L\",\n \t\t     &rvalue->where);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n       if (rvalue->expr_type == EXPR_VARIABLE && !attr.proc_pointer)\n \t{\n@@ -3453,7 +3448,7 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n \t\t    gfc_error (\"Function result '%s' is invalid as proc-target \"\n \t\t\t       \"in procedure pointer assignment at %L\",\n \t\t\t       sym->name, &rvalue->where);\n-\t\t    return FAILURE;\n+\t\t    return false;\n \t\t  }\n \t    }\n \t}\n@@ -3462,7 +3457,7 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n \t  gfc_error (\"Abstract interface '%s' is invalid \"\n \t\t     \"in procedure pointer assignment at %L\",\n \t\t     rvalue->symtree->name, &rvalue->where);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n       /* Check for F08:C729.  */\n       if (attr.flavor == FL_PROCEDURE)\n@@ -3472,20 +3467,19 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n \t      gfc_error (\"Statement function '%s' is invalid \"\n \t\t\t \"in procedure pointer assignment at %L\",\n \t\t\t rvalue->symtree->name, &rvalue->where);\n-\t      return FAILURE;\n+\t      return false;\n \t    }\n \t  if (attr.proc == PROC_INTERNAL &&\n-\t      gfc_notify_std (GFC_STD_F2008, \"Internal procedure \"\n-\t\t\t      \"'%s' is invalid in procedure pointer assignment \"\n-\t\t\t      \"at %L\", rvalue->symtree->name, &rvalue->where)\n-\t\t\t      == FAILURE)\n-\t    return FAILURE;\n+\t      !gfc_notify_std(GFC_STD_F2008, \"Internal procedure '%s' \"\n+\t\t\t      \"is invalid in procedure pointer assignment \"\n+\t\t\t      \"at %L\", rvalue->symtree->name, &rvalue->where))\n+\t    return false;\n \t  if (attr.intrinsic && gfc_intrinsic_actual_ok (rvalue->symtree->name,\n \t\t\t\t\t\t\t attr.subroutine) == 0)\n \t    {\n \t      gfc_error (\"Intrinsic '%s' at %L is invalid in procedure pointer \"\n \t\t\t \"assignment\", rvalue->symtree->name, &rvalue->where);\n-\t      return FAILURE;\n+\t      return false;\n \t    }\n \t}\n       /* Check for F08:C730.  */\n@@ -3494,7 +3488,7 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n \t  gfc_error (\"Nonintrinsic elemental procedure '%s' is invalid \"\n \t\t     \"in procedure pointer assignment at %L\",\n \t\t     rvalue->symtree->name, &rvalue->where);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n \n       /* Ensure that the calling convention is the same. As other attributes\n@@ -3517,7 +3511,7 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n \t      gfc_error (\"Mismatch in the procedure pointer assignment \"\n \t\t\t \"at %L: mismatch in the calling convention\",\n \t\t\t &rvalue->where);\n-\t  return FAILURE;\n+\t  return false;\n \t    }\n \t}\n \n@@ -3560,25 +3554,25 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n \ts2 = s2->ts.interface;\n \n       if (s1 == s2 || !s1 || !s2)\n-\treturn SUCCESS;\n+\treturn true;\n \n       if (!gfc_compare_interfaces (s1, s2, name, 0, 1,\n \t\t\t\t   err, sizeof(err), NULL, NULL))\n \t{\n \t  gfc_error (\"Interface mismatch in procedure pointer assignment \"\n \t\t     \"at %L: %s\", &rvalue->where, err);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n \n       if (!gfc_compare_interfaces (s2, s1, name, 0, 1,\n \t\t\t\t   err, sizeof(err), NULL, NULL))\n \t{\n \t  gfc_error (\"Interface mismatch in procedure pointer assignment \"\n \t\t     \"at %L: %s\", &rvalue->where, err);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n \n-      return SUCCESS;\n+      return true;\n     }\n \n   if (!gfc_compare_types (&lvalue->ts, &rvalue->ts))\n@@ -3599,20 +3593,20 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n \t\t   \"attempted assignment of %s to %s\", &lvalue->where,\n \t\t   gfc_typename (&rvalue->ts),\n \t\t   gfc_typename (&lvalue->ts));\n-      return FAILURE;\n+      return false;\n     }\n \n   if (lvalue->ts.type != BT_CLASS && lvalue->ts.kind != rvalue->ts.kind)\n     {\n       gfc_error (\"Different kind type parameters in pointer \"\n \t\t \"assignment at %L\", &lvalue->where);\n-      return FAILURE;\n+      return false;\n     }\n \n   if (lvalue->rank != rvalue->rank && !rank_remap)\n     {\n       gfc_error (\"Different ranks in pointer assignment at %L\", &lvalue->where);\n-      return FAILURE;\n+      return false;\n     }\n \n     /* Make sure the vtab is present.  */\n@@ -3628,15 +3622,15 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n \n       /* If this can be determined, check that the target must be at least as\n \t large as the pointer assigned to it is.  */\n-      if (gfc_array_size (lvalue, &lsize) == SUCCESS\n-\t  && gfc_array_size (rvalue, &rsize) == SUCCESS\n+      if (gfc_array_size (lvalue, &lsize)\n+\t  && gfc_array_size (rvalue, &rsize)\n \t  && mpz_cmp (rsize, lsize) < 0)\n \t{\n \t  gfc_error (\"Rank remapping target is smaller than size of the\"\n \t\t     \" pointer (%ld < %ld) at %L\",\n \t\t     mpz_get_si (rsize), mpz_get_si (lsize),\n \t\t     &lvalue->where);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n \n       /* The target must be either rank one or it must be simply contiguous\n@@ -3647,24 +3641,23 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n \t    {\n \t      gfc_error (\"Rank remapping target must be rank 1 or\"\n \t\t\t \" simply contiguous at %L\", &rvalue->where);\n-\t      return FAILURE;\n+\t      return false;\n \t    }\n-\t  if (gfc_notify_std (GFC_STD_F2008, \"Rank remapping\"\n-\t\t\t      \" target is not rank 1 at %L\", &rvalue->where)\n-\t\t== FAILURE)\n-\t    return FAILURE;\n+\t  if (!gfc_notify_std (GFC_STD_F2008, \"Rank remapping target is not \"\n+\t\t\t       \"rank 1 at %L\", &rvalue->where))\n+\t    return false;\n \t}\n     }\n \n   /* Now punt if we are dealing with a NULLIFY(X) or X = NULL(X).  */\n   if (rvalue->expr_type == EXPR_NULL)\n-    return SUCCESS;\n+    return true;\n \n   if (lvalue->ts.type == BT_CHARACTER)\n     {\n-      gfc_try t = gfc_check_same_strlen (lvalue, rvalue, \"pointer assignment\");\n-      if (t == FAILURE)\n-\treturn FAILURE;\n+      bool t = gfc_check_same_strlen (lvalue, rvalue, \"pointer assignment\");\n+      if (!t)\n+\treturn false;\n     }\n \n   if (rvalue->expr_type == EXPR_VARIABLE && is_subref_array (rvalue))\n@@ -3677,14 +3670,14 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n       gfc_error (\"Target expression in pointer assignment \"\n \t\t \"at %L must deliver a pointer result\",\n \t\t &rvalue->where);\n-      return FAILURE;\n+      return false;\n     }\n \n   if (!attr.target && !attr.pointer)\n     {\n       gfc_error (\"Pointer assignment target is neither TARGET \"\n \t\t \"nor POINTER at %L\", &rvalue->where);\n-      return FAILURE;\n+      return false;\n     }\n \n   if (is_pure && gfc_impure_variable (rvalue->symtree->n.sym))\n@@ -3701,15 +3694,15 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n     {\n       gfc_error (\"Pointer assignment with vector subscript \"\n \t\t \"on rhs at %L\", &rvalue->where);\n-      return FAILURE;\n+      return false;\n     }\n \n   if (attr.is_protected && attr.use_assoc\n       && !(attr.pointer || attr.proc_pointer))\n     {\n       gfc_error (\"Pointer assignment target has PROTECTED \"\n \t\t \"attribute at %L\", &rvalue->where);\n-      return FAILURE;\n+      return false;\n     }\n \n   /* F2008, C725. For PURE also C1283.  */\n@@ -3722,7 +3715,7 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n \t  {\n \t    gfc_error (\"Data target at %L shall not have a coindex\",\n \t\t       &rvalue->where);\n-\t    return FAILURE;\n+\t    return false;\n \t  }\n     }\n \n@@ -3761,18 +3754,18 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n \t\t     \"pointer target\", &lvalue->where);\n     }\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n /* Relative of gfc_check_assign() except that the lvalue is a single\n    symbol.  Used for initialization assignments.  */\n \n-gfc_try\n+bool\n gfc_check_assign_symbol (gfc_symbol *sym, gfc_component *comp, gfc_expr *rvalue)\n {\n   gfc_expr lvalue;\n-  gfc_try r;\n+  bool r;\n   bool pointer, proc_pointer;\n \n   memset (&lvalue, '\\0', sizeof (gfc_expr));\n@@ -3812,7 +3805,7 @@ gfc_check_assign_symbol (gfc_symbol *sym, gfc_component *comp, gfc_expr *rvalue)\n \n   free (lvalue.symtree);\n \n-  if (r == FAILURE)\n+  if (!r)\n     return r;\n \n   if (pointer && rvalue->expr_type != EXPR_NULL)\n@@ -3824,13 +3817,13 @@ gfc_check_assign_symbol (gfc_symbol *sym, gfc_component *comp, gfc_expr *rvalue)\n \t{\n \t  gfc_error (\"Pointer initialization target at %L \"\n \t             \"must not be ALLOCATABLE\", &rvalue->where);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n       if (!attr.target || attr.pointer)\n \t{\n \t  gfc_error (\"Pointer initialization target at %L \"\n \t\t     \"must have the TARGET attribute\", &rvalue->where);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n \n       if (!attr.save && rvalue->expr_type == EXPR_VARIABLE\n@@ -3845,7 +3838,7 @@ gfc_check_assign_symbol (gfc_symbol *sym, gfc_component *comp, gfc_expr *rvalue)\n \t{\n \t  gfc_error (\"Pointer initialization target at %L \"\n \t\t     \"must have the SAVE attribute\", &rvalue->where);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n     }\n \n@@ -3857,11 +3850,11 @@ gfc_check_assign_symbol (gfc_symbol *sym, gfc_component *comp, gfc_expr *rvalue)\n \t{\n \t  gfc_error (\"Procedure pointer initialization target at %L \"\n \t\t     \"may not be a procedure pointer\", &rvalue->where);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n     }\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n@@ -4275,7 +4268,7 @@ static bool\n expr_check_typed_help (gfc_expr* e, gfc_symbol* sym ATTRIBUTE_UNUSED,\n                        int* f ATTRIBUTE_UNUSED)\n {\n-  gfc_try t;\n+  bool t;\n \n   if (e->expr_type != EXPR_VARIABLE)\n     return false;\n@@ -4284,10 +4277,10 @@ expr_check_typed_help (gfc_expr* e, gfc_symbol* sym ATTRIBUTE_UNUSED,\n   t = gfc_check_symbol_typed (e->symtree->n.sym, check_typed_ns,\n                               true, e->where);\n \n-  return (t == FAILURE);\n+  return (!t);\n }\n \n-gfc_try\n+bool\n gfc_expr_check_typed (gfc_expr* e, gfc_namespace* ns, bool strict)\n {\n   bool error_found;\n@@ -4301,12 +4294,12 @@ gfc_expr_check_typed (gfc_expr* e, gfc_namespace* ns, bool strict)\n \n       if (e->expr_type == EXPR_OP)\n \t{\n-\t  gfc_try t = SUCCESS;\n+\t  bool t = true;\n \n \t  gcc_assert (e->value.op.op1);\n \t  t = gfc_expr_check_typed (e->value.op.op1, ns, strict);\n \n-\t  if (t == SUCCESS && e->value.op.op2)\n+\t  if (t && e->value.op.op2)\n \t    t = gfc_expr_check_typed (e->value.op.op2, ns, strict);\n \n \t  return t;\n@@ -4317,7 +4310,7 @@ gfc_expr_check_typed (gfc_expr* e, gfc_namespace* ns, bool strict)\n   check_typed_ns = ns;\n   error_found = gfc_traverse_expr (e, NULL, &expr_check_typed_help, 0);\n \n-  return error_found ? FAILURE : SUCCESS;\n+  return error_found ? false : true;\n }\n \n \n@@ -4676,9 +4669,9 @@ gfc_build_intrinsic_call (gfc_namespace *ns, gfc_isym_id id, const char* name,\n    variables), some checks are not performed.\n \n    Optionally, a possible error message can be suppressed if context is NULL\n-   and just the return status (SUCCESS / FAILURE) be requested.  */\n+   and just the return status (true / false) be requested.  */\n \n-gfc_try\n+bool\n gfc_check_vardef_context (gfc_expr* e, bool pointer, bool alloc_obj,\n \t\t\t  bool own_scope, const char* context)\n {\n@@ -4711,23 +4704,23 @@ gfc_check_vardef_context (gfc_expr* e, bool pointer, bool alloc_obj,\n \t  if (context)\n \t    gfc_error (\"Fortran 2008: Pointer functions in variable definition\"\n \t\t       \" context (%s) at %L\", context, &e->where);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n     }\n   else if (e->expr_type != EXPR_VARIABLE)\n     {\n       if (context)\n \tgfc_error (\"Non-variable expression in variable definition context (%s)\"\n \t\t   \" at %L\", context, &e->where);\n-      return FAILURE;\n+      return false;\n     }\n \n   if (!pointer && sym->attr.flavor == FL_PARAMETER)\n     {\n       if (context)\n \tgfc_error (\"Named constant '%s' in variable definition context (%s)\"\n \t\t   \" at %L\", sym->name, context, &e->where);\n-      return FAILURE;\n+      return false;\n     }\n   if (!pointer && sym->attr.flavor != FL_VARIABLE\n       && !(sym->attr.flavor == FL_PROCEDURE && sym == sym->result)\n@@ -4736,7 +4729,7 @@ gfc_check_vardef_context (gfc_expr* e, bool pointer, bool alloc_obj,\n       if (context)\n \tgfc_error (\"'%s' in variable definition context (%s) at %L is not\"\n \t\t   \" a variable\", sym->name, context, &e->where);\n-      return FAILURE;\n+      return false;\n     }\n \n   /* Find out whether the expr is a pointer; this also means following\n@@ -4747,7 +4740,7 @@ gfc_check_vardef_context (gfc_expr* e, bool pointer, bool alloc_obj,\n       if (context)\n \tgfc_error (\"Non-POINTER in pointer association context (%s)\"\n \t\t   \" at %L\", context, &e->where);\n-      return FAILURE;\n+      return false;\n     }\n \n   /* F2008, C1303.  */\n@@ -4760,7 +4753,7 @@ gfc_check_vardef_context (gfc_expr* e, bool pointer, bool alloc_obj,\n       if (context)\n \tgfc_error (\"LOCK_TYPE in variable definition context (%s) at %L\",\n \t\t   context, &e->where);\n-      return FAILURE;\n+      return false;\n     }\n \n   /* INTENT(IN) dummy argument.  Check this, unless the object itself is the\n@@ -4790,15 +4783,15 @@ gfc_check_vardef_context (gfc_expr* e, bool pointer, bool alloc_obj,\n \t    gfc_error (\"Dummy argument '%s' with INTENT(IN) in pointer\"\n \t\t       \" association context (%s) at %L\",\n \t\t       sym->name, context, &e->where);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n       if (!pointer && !is_pointer && !sym->attr.pointer)\n \t{\n \t  if (context)\n \t    gfc_error (\"Dummy argument '%s' with INTENT(IN) in variable\"\n \t\t       \" definition context (%s) at %L\",\n \t\t       sym->name, context, &e->where);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n     }\n \n@@ -4811,15 +4804,15 @@ gfc_check_vardef_context (gfc_expr* e, bool pointer, bool alloc_obj,\n \t    gfc_error (\"Variable '%s' is PROTECTED and can not appear in a\"\n \t\t       \" pointer association context (%s) at %L\",\n \t\t       sym->name, context, &e->where);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n       if (!pointer && !is_pointer)\n \t{\n \t  if (context)\n \t    gfc_error (\"Variable '%s' is PROTECTED and can not appear in a\"\n \t\t       \" variable definition context (%s) at %L\",\n \t\t       sym->name, context, &e->where);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n     }\n \n@@ -4831,7 +4824,7 @@ gfc_check_vardef_context (gfc_expr* e, bool pointer, bool alloc_obj,\n \tgfc_error (\"Variable '%s' can not appear in a variable definition\"\n \t\t   \" context (%s) at %L in PURE procedure\",\n \t\t   sym->name, context, &e->where);\n-      return FAILURE;\n+      return false;\n     }\n \n   if (!pointer && context && gfc_implicit_pure (NULL)\n@@ -4895,22 +4888,21 @@ gfc_check_vardef_context (gfc_expr* e, bool pointer, bool alloc_obj,\n \t\t\t   \" not be used in a variable definition context (%s)\",\n \t\t\t   name, &e->where, context);\n \t    }\n-\t  return FAILURE;\n+\t  return false;\n \t}\n \n       /* Target must be allowed to appear in a variable definition context.  */\n-      if (gfc_check_vardef_context (assoc->target, pointer, false, false, NULL)\n-\t  == FAILURE)\n+      if (!gfc_check_vardef_context (assoc->target, pointer, false, false, NULL))\n \t{\n \t  if (context)\n \t    gfc_error (\"Associate-name '%s' can not appear in a variable\"\n \t\t       \" definition context (%s) at %L because its target\"\n \t\t       \" at %L can not, either\",\n \t\t       name, context, &e->where,\n \t\t       &assoc->target->where);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n     }\n \n-  return SUCCESS;\n+  return true;\n }"}, {"sha": "30cbfe594769fd034a5e160edff5c2f50b14dc3a", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=524af0d6c72031c249aa737945fde6ac3d726ba2", "patch": "@@ -221,7 +221,7 @@ gfc_init (void)\n \n   gfc_init_1 ();\n \n-  if (gfc_new_file () != SUCCESS)\n+  if (!gfc_new_file ())\n     fatal_error (\"can't open input file: %s\", gfc_source_file);\n \n   return true;"}, {"sha": "974931416f9553df3287c8a54614e5f8d307c924", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=524af0d6c72031c249aa737945fde6ac3d726ba2", "patch": "@@ -588,7 +588,7 @@ cfe_expr_0 (gfc_expr **e, int *walk_subtrees,\n       newvar = NULL;\n       for (j=0; j<i; j++)\n \t{\n-\t  if (gfc_dep_compare_functions(*(expr_array[i]),\n+\t  if (gfc_dep_compare_functions (*(expr_array[i]),\n \t\t\t\t\t*(expr_array[j]), true)\t== 0)\n \t    {\n \t      if (newvar == NULL)\n@@ -936,7 +936,7 @@ optimize_assignment (gfc_code * c)\n       remove_trim (rhs);\n \n       /* Replace a = '   ' by a = '' to optimize away a memcpy.  */\n-      if (is_empty_string(rhs))\n+      if (is_empty_string (rhs))\n \trhs->value.character.length = 0;\n     }\n "}, {"sha": "b033b748901cba834454e92f72e81fa610887d74", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 123, "deletions": 131, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=524af0d6c72031c249aa737945fde6ac3d726ba2", "patch": "@@ -95,14 +95,6 @@ typedef enum\n { M_READ, M_WRITE, M_PRINT, M_INQUIRE }\n io_kind;\n \n-/* The author remains confused to this day about the convention of\n-   returning '0' for 'SUCCESS'... or was it the other way around?  The\n-   following enum makes things much more readable.  We also start\n-   values off at one instead of zero.  */\n-\n-typedef enum\n-{ SUCCESS = 1, FAILURE }\n-gfc_try;\n \n /* These are flags for identifying whether we are reading a character literal\n    between quotes or normal source code.  */\n@@ -1626,16 +1618,16 @@ gfc_intrinsic_arg;\n \n typedef union\n {\n-  gfc_try (*f0)(void);\n-  gfc_try (*f1)(struct gfc_expr *);\n-  gfc_try (*f1m)(gfc_actual_arglist *);\n-  gfc_try (*f2)(struct gfc_expr *, struct gfc_expr *);\n-  gfc_try (*f3)(struct gfc_expr *, struct gfc_expr *, struct gfc_expr *);\n-  gfc_try (*f3ml)(gfc_actual_arglist *);\n-  gfc_try (*f3red)(gfc_actual_arglist *);\n-  gfc_try (*f4)(struct gfc_expr *, struct gfc_expr *, struct gfc_expr *,\n+  bool (*f0)(void);\n+  bool (*f1)(struct gfc_expr *);\n+  bool (*f1m)(gfc_actual_arglist *);\n+  bool (*f2)(struct gfc_expr *, struct gfc_expr *);\n+  bool (*f3)(struct gfc_expr *, struct gfc_expr *, struct gfc_expr *);\n+  bool (*f3ml)(gfc_actual_arglist *);\n+  bool (*f3red)(gfc_actual_arglist *);\n+  bool (*f4)(struct gfc_expr *, struct gfc_expr *, struct gfc_expr *,\n \t    struct gfc_expr *);\n-  gfc_try (*f5)(struct gfc_expr *, struct gfc_expr *, struct gfc_expr *,\n+  bool (*f5)(struct gfc_expr *, struct gfc_expr *, struct gfc_expr *,\n \t    struct gfc_expr *, struct gfc_expr *);\n }\n gfc_check_f;\n@@ -2432,7 +2424,7 @@ gfc_char_t gfc_peek_char (void);\n char gfc_peek_ascii_char (void);\n void gfc_error_recovery (void);\n void gfc_gobble_whitespace (void);\n-gfc_try gfc_new_file (void);\n+bool gfc_new_file (void);\n const char * gfc_read_orig_filename (const char *, const char **);\n \n extern gfc_source_form gfc_current_form;\n@@ -2505,7 +2497,7 @@ int gfc_error_check (void);\n int gfc_error_flag_test (void);\n \n notification gfc_notification_std (int);\n-gfc_try gfc_notify_std (int, const char *, ...) ATTRIBUTE_GCC_GFC(2,3);\n+bool gfc_notify_std (int, const char *, ...) ATTRIBUTE_GCC_GFC(2,3);\n \n /* A general purpose syntax error.  */\n #define gfc_syntax_error(ST)\t\\\n@@ -2525,7 +2517,7 @@ arith gfc_check_integer_range (mpz_t p, int kind);\n bool gfc_check_character_range (gfc_char_t, int);\n \n /* trans-types.c */\n-gfc_try gfc_check_any_c_kind (gfc_typespec *);\n+bool gfc_check_any_c_kind (gfc_typespec *);\n int gfc_validate_kind (bt, int, bool);\n int gfc_get_int_kind_from_width_isofortranenv (int size);\n int gfc_get_real_kind_from_width_isofortranenv (int size);\n@@ -2548,80 +2540,80 @@ extern int gfc_character_storage_size;\n \n /* symbol.c */\n void gfc_clear_new_implicit (void);\n-gfc_try gfc_add_new_implicit_range (int, int);\n-gfc_try gfc_merge_new_implicit (gfc_typespec *);\n+bool gfc_add_new_implicit_range (int, int);\n+bool gfc_merge_new_implicit (gfc_typespec *);\n void gfc_set_implicit_none (void);\n void gfc_check_function_type (gfc_namespace *);\n bool gfc_is_intrinsic_typename (const char *);\n \n gfc_typespec *gfc_get_default_type (const char *, gfc_namespace *);\n-gfc_try gfc_set_default_type (gfc_symbol *, int, gfc_namespace *);\n+bool gfc_set_default_type (gfc_symbol *, int, gfc_namespace *);\n \n void gfc_set_sym_referenced (gfc_symbol *);\n \n-gfc_try gfc_add_attribute (symbol_attribute *, locus *);\n-gfc_try gfc_add_ext_attribute (symbol_attribute *, ext_attr_id_t, locus *);\n-gfc_try gfc_add_allocatable (symbol_attribute *, locus *);\n-gfc_try gfc_add_codimension (symbol_attribute *, const char *, locus *);\n-gfc_try gfc_add_contiguous (symbol_attribute *, const char *, locus *);\n-gfc_try gfc_add_dimension (symbol_attribute *, const char *, locus *);\n-gfc_try gfc_add_external (symbol_attribute *, locus *);\n-gfc_try gfc_add_intrinsic (symbol_attribute *, locus *);\n-gfc_try gfc_add_optional (symbol_attribute *, locus *);\n-gfc_try gfc_add_pointer (symbol_attribute *, locus *);\n-gfc_try gfc_add_cray_pointer (symbol_attribute *, locus *);\n-gfc_try gfc_add_cray_pointee (symbol_attribute *, locus *);\n+bool gfc_add_attribute (symbol_attribute *, locus *);\n+bool gfc_add_ext_attribute (symbol_attribute *, ext_attr_id_t, locus *);\n+bool gfc_add_allocatable (symbol_attribute *, locus *);\n+bool gfc_add_codimension (symbol_attribute *, const char *, locus *);\n+bool gfc_add_contiguous (symbol_attribute *, const char *, locus *);\n+bool gfc_add_dimension (symbol_attribute *, const char *, locus *);\n+bool gfc_add_external (symbol_attribute *, locus *);\n+bool gfc_add_intrinsic (symbol_attribute *, locus *);\n+bool gfc_add_optional (symbol_attribute *, locus *);\n+bool gfc_add_pointer (symbol_attribute *, locus *);\n+bool gfc_add_cray_pointer (symbol_attribute *, locus *);\n+bool gfc_add_cray_pointee (symbol_attribute *, locus *);\n match gfc_mod_pointee_as (gfc_array_spec *);\n-gfc_try gfc_add_protected (symbol_attribute *, const char *, locus *);\n-gfc_try gfc_add_result (symbol_attribute *, const char *, locus *);\n-gfc_try gfc_add_save (symbol_attribute *, save_state, const char *, locus *);\n-gfc_try gfc_add_threadprivate (symbol_attribute *, const char *, locus *);\n-gfc_try gfc_add_saved_common (symbol_attribute *, locus *);\n-gfc_try gfc_add_target (symbol_attribute *, locus *);\n-gfc_try gfc_add_dummy (symbol_attribute *, const char *, locus *);\n-gfc_try gfc_add_generic (symbol_attribute *, const char *, locus *);\n-gfc_try gfc_add_common (symbol_attribute *, locus *);\n-gfc_try gfc_add_in_common (symbol_attribute *, const char *, locus *);\n-gfc_try gfc_add_in_equivalence (symbol_attribute *, const char *, locus *);\n-gfc_try gfc_add_data (symbol_attribute *, const char *, locus *);\n-gfc_try gfc_add_in_namelist (symbol_attribute *, const char *, locus *);\n-gfc_try gfc_add_sequence (symbol_attribute *, const char *, locus *);\n-gfc_try gfc_add_elemental (symbol_attribute *, locus *);\n-gfc_try gfc_add_pure (symbol_attribute *, locus *);\n-gfc_try gfc_add_recursive (symbol_attribute *, locus *);\n-gfc_try gfc_add_function (symbol_attribute *, const char *, locus *);\n-gfc_try gfc_add_subroutine (symbol_attribute *, const char *, locus *);\n-gfc_try gfc_add_volatile (symbol_attribute *, const char *, locus *);\n-gfc_try gfc_add_asynchronous (symbol_attribute *, const char *, locus *);\n-gfc_try gfc_add_proc (symbol_attribute *attr, const char *name, locus *where);\n-gfc_try gfc_add_abstract (symbol_attribute* attr, locus* where);\n-\n-gfc_try gfc_add_access (symbol_attribute *, gfc_access, const char *, locus *);\n-gfc_try gfc_add_is_bind_c (symbol_attribute *, const char *, locus *, int);\n-gfc_try gfc_add_extension (symbol_attribute *, locus *);\n-gfc_try gfc_add_value (symbol_attribute *, const char *, locus *);\n-gfc_try gfc_add_flavor (symbol_attribute *, sym_flavor, const char *, locus *);\n-gfc_try gfc_add_entry (symbol_attribute *, const char *, locus *);\n-gfc_try gfc_add_procedure (symbol_attribute *, procedure_type,\n+bool gfc_add_protected (symbol_attribute *, const char *, locus *);\n+bool gfc_add_result (symbol_attribute *, const char *, locus *);\n+bool gfc_add_save (symbol_attribute *, save_state, const char *, locus *);\n+bool gfc_add_threadprivate (symbol_attribute *, const char *, locus *);\n+bool gfc_add_saved_common (symbol_attribute *, locus *);\n+bool gfc_add_target (symbol_attribute *, locus *);\n+bool gfc_add_dummy (symbol_attribute *, const char *, locus *);\n+bool gfc_add_generic (symbol_attribute *, const char *, locus *);\n+bool gfc_add_common (symbol_attribute *, locus *);\n+bool gfc_add_in_common (symbol_attribute *, const char *, locus *);\n+bool gfc_add_in_equivalence (symbol_attribute *, const char *, locus *);\n+bool gfc_add_data (symbol_attribute *, const char *, locus *);\n+bool gfc_add_in_namelist (symbol_attribute *, const char *, locus *);\n+bool gfc_add_sequence (symbol_attribute *, const char *, locus *);\n+bool gfc_add_elemental (symbol_attribute *, locus *);\n+bool gfc_add_pure (symbol_attribute *, locus *);\n+bool gfc_add_recursive (symbol_attribute *, locus *);\n+bool gfc_add_function (symbol_attribute *, const char *, locus *);\n+bool gfc_add_subroutine (symbol_attribute *, const char *, locus *);\n+bool gfc_add_volatile (symbol_attribute *, const char *, locus *);\n+bool gfc_add_asynchronous (symbol_attribute *, const char *, locus *);\n+bool gfc_add_proc (symbol_attribute *attr, const char *name, locus *where);\n+bool gfc_add_abstract (symbol_attribute* attr, locus* where);\n+\n+bool gfc_add_access (symbol_attribute *, gfc_access, const char *, locus *);\n+bool gfc_add_is_bind_c (symbol_attribute *, const char *, locus *, int);\n+bool gfc_add_extension (symbol_attribute *, locus *);\n+bool gfc_add_value (symbol_attribute *, const char *, locus *);\n+bool gfc_add_flavor (symbol_attribute *, sym_flavor, const char *, locus *);\n+bool gfc_add_entry (symbol_attribute *, const char *, locus *);\n+bool gfc_add_procedure (symbol_attribute *, procedure_type,\n \t\t       const char *, locus *);\n-gfc_try gfc_add_intent (symbol_attribute *, sym_intent, locus *);\n-gfc_try gfc_add_explicit_interface (gfc_symbol *, ifsrc,\n+bool gfc_add_intent (symbol_attribute *, sym_intent, locus *);\n+bool gfc_add_explicit_interface (gfc_symbol *, ifsrc,\n \t\t\t\tgfc_formal_arglist *, locus *);\n-gfc_try gfc_add_type (gfc_symbol *, gfc_typespec *, locus *);\n+bool gfc_add_type (gfc_symbol *, gfc_typespec *, locus *);\n \n void gfc_clear_attr (symbol_attribute *);\n-gfc_try gfc_missing_attr (symbol_attribute *, locus *);\n-gfc_try gfc_copy_attr (symbol_attribute *, symbol_attribute *, locus *);\n+bool gfc_missing_attr (symbol_attribute *, locus *);\n+bool gfc_copy_attr (symbol_attribute *, symbol_attribute *, locus *);\n \n-gfc_try gfc_add_component (gfc_symbol *, const char *, gfc_component **);\n+bool gfc_add_component (gfc_symbol *, const char *, gfc_component **);\n gfc_symbol *gfc_use_derived (gfc_symbol *);\n gfc_symtree *gfc_use_derived_tree (gfc_symtree *);\n gfc_component *gfc_find_component (gfc_symbol *, const char *, bool, bool);\n \n gfc_st_label *gfc_get_st_label (int);\n void gfc_free_st_label (gfc_st_label *);\n void gfc_define_st_label (gfc_st_label *, gfc_sl_type, locus *);\n-gfc_try gfc_reference_st_label (gfc_st_label *, gfc_sl_type);\n+bool gfc_reference_st_label (gfc_st_label *, gfc_sl_type);\n \n gfc_namespace *gfc_get_namespace (gfc_namespace *, int);\n gfc_symtree *gfc_new_symtree (gfc_symtree **, const char *);\n@@ -2637,11 +2629,11 @@ gfc_symtree* gfc_find_symtree_in_proc (const char *, gfc_namespace *);\n int gfc_find_symbol (const char *, gfc_namespace *, int, gfc_symbol **);\n int gfc_find_sym_tree (const char *, gfc_namespace *, int, gfc_symtree **);\n int gfc_get_symbol (const char *, gfc_namespace *, gfc_symbol **);\n-gfc_try gfc_verify_c_interop (gfc_typespec *);\n-gfc_try gfc_verify_c_interop_param (gfc_symbol *);\n-gfc_try verify_bind_c_sym (gfc_symbol *, gfc_typespec *, int, gfc_common_head *);\n-gfc_try verify_bind_c_derived_type (gfc_symbol *);\n-gfc_try verify_com_block_vars_c_interop (gfc_common_head *);\n+bool gfc_verify_c_interop (gfc_typespec *);\n+bool gfc_verify_c_interop_param (gfc_symbol *);\n+bool verify_bind_c_sym (gfc_symbol *, gfc_typespec *, int, gfc_common_head *);\n+bool verify_bind_c_derived_type (gfc_symbol *);\n+bool verify_com_block_vars_c_interop (gfc_common_head *);\n gfc_symtree *generate_isocbinding_symbol (const char *, iso_c_binding_symbol,\n \t\t\t\t\t  const char *, gfc_symtree *, bool);\n int gfc_get_sym_tree (const char *, gfc_namespace *, gfc_symtree **, bool);\n@@ -2683,7 +2675,7 @@ void gfc_copy_formal_args_intr (gfc_symbol *, gfc_intrinsic_sym *);\n \n void gfc_free_finalizer (gfc_finalizer *el); /* Needed in resolve.c, too  */\n \n-gfc_try gfc_check_symbol_typed (gfc_symbol*, gfc_namespace*, bool, locus);\n+bool gfc_check_symbol_typed (gfc_symbol*, gfc_namespace*, bool, locus);\n gfc_namespace* gfc_find_proc_namespace (gfc_namespace*);\n \n bool gfc_is_associate_pointer (gfc_symbol*);\n@@ -2704,9 +2696,9 @@ void gfc_intrinsic_done_1 (void);\n \n char gfc_type_letter (bt);\n gfc_symbol * gfc_get_intrinsic_sub_symbol (const char *);\n-gfc_try gfc_convert_type (gfc_expr *, gfc_typespec *, int);\n-gfc_try gfc_convert_type_warn (gfc_expr *, gfc_typespec *, int, int);\n-gfc_try gfc_convert_chartype (gfc_expr *, gfc_typespec *);\n+bool gfc_convert_type (gfc_expr *, gfc_typespec *, int);\n+bool gfc_convert_type_warn (gfc_expr *, gfc_typespec *, int, int);\n+bool gfc_convert_chartype (gfc_expr *, gfc_typespec *);\n int gfc_generic_intrinsic (const char *);\n int gfc_specific_intrinsic (const char *);\n bool gfc_is_intrinsic (gfc_symbol*, int, locus);\n@@ -2723,7 +2715,7 @@ match gfc_intrinsic_func_interface (gfc_expr *, int);\n match gfc_intrinsic_sub_interface (gfc_code *, int);\n \n void gfc_warn_intrinsic_shadow (const gfc_symbol*, bool, bool);\n-gfc_try gfc_check_intrinsic_standard (const gfc_intrinsic_sym*, const char**,\n+bool gfc_check_intrinsic_standard (const gfc_intrinsic_sym*, const char**,\n \t\t\t\t      bool, locus);\n \n /* match.c -- FIXME */\n@@ -2755,13 +2747,13 @@ gfc_actual_arglist *gfc_copy_actual_arglist (gfc_actual_arglist *);\n const char *gfc_extract_int (gfc_expr *, int *);\n bool is_subref_array (gfc_expr *);\n bool gfc_is_simply_contiguous (gfc_expr *, bool);\n-gfc_try gfc_check_init_expr (gfc_expr *);\n+bool gfc_check_init_expr (gfc_expr *);\n \n gfc_expr *gfc_build_conversion (gfc_expr *);\n void gfc_free_ref_list (gfc_ref *);\n void gfc_type_convert_binary (gfc_expr *, int);\n int gfc_is_constant_expr (gfc_expr *);\n-gfc_try gfc_simplify_expr (gfc_expr *, int);\n+bool gfc_simplify_expr (gfc_expr *, int);\n int gfc_has_vector_index (gfc_expr *);\n \n gfc_expr *gfc_get_expr (void);\n@@ -2784,15 +2776,15 @@ mpz_t *gfc_copy_shape_excluding (mpz_t *, int, gfc_expr *);\n gfc_expr *gfc_copy_expr (gfc_expr *);\n gfc_ref* gfc_copy_ref (gfc_ref*);\n \n-gfc_try gfc_specification_expr (gfc_expr *);\n+bool gfc_specification_expr (gfc_expr *);\n \n int gfc_numeric_ts (gfc_typespec *);\n int gfc_kind_max (gfc_expr *, gfc_expr *);\n \n-gfc_try gfc_check_conformance (gfc_expr *, gfc_expr *, const char *, ...) ATTRIBUTE_PRINTF_3;\n-gfc_try gfc_check_assign (gfc_expr *, gfc_expr *, int);\n-gfc_try gfc_check_pointer_assign (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_assign_symbol (gfc_symbol *, gfc_component *, gfc_expr *);\n+bool gfc_check_conformance (gfc_expr *, gfc_expr *, const char *, ...) ATTRIBUTE_PRINTF_3;\n+bool gfc_check_assign (gfc_expr *, gfc_expr *, int);\n+bool gfc_check_pointer_assign (gfc_expr *, gfc_expr *);\n+bool gfc_check_assign_symbol (gfc_symbol *, gfc_component *, gfc_expr *);\n \n bool gfc_has_default_initializer (gfc_symbol *);\n gfc_expr *gfc_default_initializer (gfc_typespec *);\n@@ -2806,7 +2798,7 @@ bool gfc_traverse_expr (gfc_expr *, gfc_symbol *,\n \t\t\tbool (*)(gfc_expr *, gfc_symbol *, int*),\n \t\t\tint);\n void gfc_expr_set_symbols_referenced (gfc_expr *);\n-gfc_try gfc_expr_check_typed (gfc_expr*, gfc_namespace*, bool);\n+bool gfc_expr_check_typed (gfc_expr*, gfc_namespace*, bool);\n \n gfc_component * gfc_get_proc_ptr_comp (gfc_expr *);\n bool gfc_is_proc_ptr_comp (gfc_expr *);\n@@ -2820,7 +2812,7 @@ bool gfc_has_ultimate_pointer (gfc_expr *);\n \n gfc_expr* gfc_build_intrinsic_call (gfc_namespace *, gfc_isym_id, const char*,\n \t\t\t\t    locus, unsigned, ...);\n-gfc_try gfc_check_vardef_context (gfc_expr*, bool, bool, bool, const char*);\n+bool gfc_check_vardef_context (gfc_expr*, bool, bool, bool, const char*);\n \n \n /* st.c */\n@@ -2834,23 +2826,23 @@ void gfc_free_statements (gfc_code *);\n void gfc_free_association_list (gfc_association_list *);\n \n /* resolve.c */\n-gfc_try gfc_resolve_expr (gfc_expr *);\n+bool gfc_resolve_expr (gfc_expr *);\n void gfc_resolve (gfc_namespace *);\n void gfc_resolve_blocks (gfc_code *, gfc_namespace *);\n int gfc_impure_variable (gfc_symbol *);\n int gfc_pure (gfc_symbol *);\n int gfc_implicit_pure (gfc_symbol *);\n int gfc_elemental (gfc_symbol *);\n-gfc_try gfc_resolve_iterator (gfc_iterator *, bool, bool);\n-gfc_try find_forall_index (gfc_expr *, gfc_symbol *, int);\n-gfc_try gfc_resolve_index (gfc_expr *, int);\n-gfc_try gfc_resolve_dim_arg (gfc_expr *);\n+bool gfc_resolve_iterator (gfc_iterator *, bool, bool);\n+bool find_forall_index (gfc_expr *, gfc_symbol *, int);\n+bool gfc_resolve_index (gfc_expr *, int);\n+bool gfc_resolve_dim_arg (gfc_expr *);\n int gfc_is_formal_arg (void);\n void gfc_resolve_substring_charlen (gfc_expr *);\n match gfc_iso_c_sub_interface(gfc_code *, gfc_symbol *);\n gfc_expr *gfc_expr_to_initialize (gfc_expr *);\n bool gfc_type_is_extensible (gfc_symbol *);\n-gfc_try gfc_resolve_intrinsic (gfc_symbol *, locus *);\n+bool gfc_resolve_intrinsic (gfc_symbol *, locus *);\n \n \n /* array.c */\n@@ -2859,31 +2851,31 @@ gfc_iterator *gfc_copy_iterator (gfc_iterator *);\n void gfc_free_array_spec (gfc_array_spec *);\n gfc_array_ref *gfc_copy_array_ref (gfc_array_ref *);\n \n-gfc_try gfc_set_array_spec (gfc_symbol *, gfc_array_spec *, locus *);\n+bool gfc_set_array_spec (gfc_symbol *, gfc_array_spec *, locus *);\n gfc_array_spec *gfc_copy_array_spec (gfc_array_spec *);\n-gfc_try gfc_resolve_array_spec (gfc_array_spec *, int);\n+bool gfc_resolve_array_spec (gfc_array_spec *, int);\n \n int gfc_compare_array_spec (gfc_array_spec *, gfc_array_spec *);\n \n void gfc_simplify_iterator_var (gfc_expr *);\n-gfc_try gfc_expand_constructor (gfc_expr *, bool);\n+bool gfc_expand_constructor (gfc_expr *, bool);\n int gfc_constant_ac (gfc_expr *);\n int gfc_expanded_ac (gfc_expr *);\n-gfc_try gfc_resolve_character_array_constructor (gfc_expr *);\n-gfc_try gfc_resolve_array_constructor (gfc_expr *);\n-gfc_try gfc_check_constructor_type (gfc_expr *);\n-gfc_try gfc_check_iter_variable (gfc_expr *);\n-gfc_try gfc_check_constructor (gfc_expr *, gfc_try (*)(gfc_expr *));\n-gfc_try gfc_array_size (gfc_expr *, mpz_t *);\n-gfc_try gfc_array_dimen_size (gfc_expr *, int, mpz_t *);\n-gfc_try gfc_array_ref_shape (gfc_array_ref *, mpz_t *);\n+bool gfc_resolve_character_array_constructor (gfc_expr *);\n+bool gfc_resolve_array_constructor (gfc_expr *);\n+bool gfc_check_constructor_type (gfc_expr *);\n+bool gfc_check_iter_variable (gfc_expr *);\n+bool gfc_check_constructor (gfc_expr *, bool (*)(gfc_expr *));\n+bool gfc_array_size (gfc_expr *, mpz_t *);\n+bool gfc_array_dimen_size (gfc_expr *, int, mpz_t *);\n+bool gfc_array_ref_shape (gfc_array_ref *, mpz_t *);\n gfc_array_ref *gfc_find_array_ref (gfc_expr *);\n tree gfc_conv_array_initializer (tree type, gfc_expr *);\n-gfc_try spec_size (gfc_array_spec *, mpz_t *);\n-gfc_try spec_dimen_size (gfc_array_spec *, int, mpz_t *);\n+bool spec_size (gfc_array_spec *, mpz_t *);\n+bool spec_dimen_size (gfc_array_spec *, int, mpz_t *);\n int gfc_is_compile_time_shape (gfc_array_spec *);\n \n-gfc_try gfc_ref_dimen_size (gfc_array_ref *, int dimen, mpz_t *, mpz_t *);\n+bool gfc_ref_dimen_size (gfc_array_ref *, int dimen, mpz_t *, mpz_t *);\n \n \n /* interface.c -- FIXME: some of these should be in symbol.c */\n@@ -2893,39 +2885,39 @@ int gfc_compare_types (gfc_typespec *, gfc_typespec *);\n int gfc_compare_interfaces (gfc_symbol*, gfc_symbol*, const char *, int, int,\n \t\t\t    char *, int, const char *, const char *);\n void gfc_check_interfaces (gfc_namespace *);\n-gfc_try gfc_procedure_use (gfc_symbol *, gfc_actual_arglist **, locus *);\n+bool gfc_procedure_use (gfc_symbol *, gfc_actual_arglist **, locus *);\n void gfc_ppc_use (gfc_component *, gfc_actual_arglist **, locus *);\n gfc_symbol *gfc_search_interface (gfc_interface *, int,\n \t\t\t\t  gfc_actual_arglist **);\n match gfc_extend_expr (gfc_expr *);\n void gfc_free_formal_arglist (gfc_formal_arglist *);\n-gfc_try gfc_extend_assign (gfc_code *, gfc_namespace *);\n-gfc_try gfc_check_new_interface (gfc_interface *, gfc_symbol *, locus);\n-gfc_try gfc_add_interface (gfc_symbol *);\n+bool gfc_extend_assign (gfc_code *, gfc_namespace *);\n+bool gfc_check_new_interface (gfc_interface *, gfc_symbol *, locus);\n+bool gfc_add_interface (gfc_symbol *);\n gfc_interface *gfc_current_interface_head (void);\n void gfc_set_current_interface_head (gfc_interface *);\n gfc_symtree* gfc_find_sym_in_symtree (gfc_symbol*);\n bool gfc_arglist_matches_symbol (gfc_actual_arglist**, gfc_symbol*);\n bool gfc_check_operator_interface (gfc_symbol*, gfc_intrinsic_op, locus);\n int gfc_has_vector_subscript (gfc_expr*);\n gfc_intrinsic_op gfc_equivalent_op (gfc_intrinsic_op);\n-gfc_try gfc_check_typebound_override (gfc_symtree*, gfc_symtree*);\n+bool gfc_check_typebound_override (gfc_symtree*, gfc_symtree*);\n \n /* io.c */\n extern gfc_st_label format_asterisk;\n \n void gfc_free_open (gfc_open *);\n-gfc_try gfc_resolve_open (gfc_open *);\n+bool gfc_resolve_open (gfc_open *);\n void gfc_free_close (gfc_close *);\n-gfc_try gfc_resolve_close (gfc_close *);\n+bool gfc_resolve_close (gfc_close *);\n void gfc_free_filepos (gfc_filepos *);\n-gfc_try gfc_resolve_filepos (gfc_filepos *);\n+bool gfc_resolve_filepos (gfc_filepos *);\n void gfc_free_inquire (gfc_inquire *);\n-gfc_try gfc_resolve_inquire (gfc_inquire *);\n+bool gfc_resolve_inquire (gfc_inquire *);\n void gfc_free_dt (gfc_dt *);\n-gfc_try gfc_resolve_dt (gfc_dt *, locus *);\n+bool gfc_resolve_dt (gfc_dt *, locus *);\n void gfc_free_wait (gfc_wait *);\n-gfc_try gfc_resolve_wait (gfc_wait *);\n+bool gfc_resolve_wait (gfc_wait *);\n \n /* module.c */\n void gfc_module_init_2 (void);\n@@ -2941,7 +2933,7 @@ match gfc_match_rvalue (gfc_expr **);\n match gfc_match_varspec (gfc_expr*, int, bool, bool);\n int gfc_check_digit (char, int);\n bool gfc_is_function_return_value (gfc_symbol *, gfc_namespace *);\n-gfc_try gfc_convert_to_structure_constructor (gfc_expr *, gfc_symbol *,\n+bool gfc_convert_to_structure_constructor (gfc_expr *, gfc_symbol *,\n \t\t\t\t\t      gfc_expr **,\n \t\t\t\t\t      gfc_actual_arglist **, bool);\n \n@@ -2962,7 +2954,7 @@ void gfc_delete_bbt (void *, void *, compare_fn);\n void gfc_dump_parse_tree (gfc_namespace *, FILE *);\n \n /* parse.c */\n-gfc_try gfc_parse_file (void);\n+bool gfc_parse_file (void);\n void gfc_global_used (gfc_gsymbol *, locus *);\n gfc_namespace* gfc_build_block_ns (gfc_namespace *);\n \n@@ -2972,8 +2964,8 @@ int gfc_dep_compare_expr (gfc_expr *, gfc_expr *);\n bool gfc_dep_difference (gfc_expr *, gfc_expr *, mpz_t *);\n \n /* check.c */\n-gfc_try gfc_check_same_strlen (const gfc_expr*, const gfc_expr*, const char*);\n-gfc_try gfc_calculate_transfer_sizes (gfc_expr*, gfc_expr*, gfc_expr*,\n+bool gfc_check_same_strlen (const gfc_expr*, const gfc_expr*, const char*);\n+bool gfc_calculate_transfer_sizes (gfc_expr*, gfc_expr*, gfc_expr*,\n \t\t\t\t      size_t*, size_t*, size_t*);\n \n /* class.c */\n@@ -2991,15 +2983,15 @@ bool gfc_is_class_scalar_expr (gfc_expr *);\n bool gfc_is_class_container_ref (gfc_expr *e);\n gfc_expr *gfc_class_null_initializer (gfc_typespec *, gfc_expr *);\n unsigned int gfc_hash_value (gfc_symbol *);\n-gfc_try gfc_build_class_symbol (gfc_typespec *, symbol_attribute *,\n+bool gfc_build_class_symbol (gfc_typespec *, symbol_attribute *,\n \t\t\t\tgfc_array_spec **, bool);\n gfc_symbol *gfc_find_derived_vtab (gfc_symbol *);\n gfc_symbol *gfc_find_intrinsic_vtab (gfc_typespec *);\n-gfc_symtree* gfc_find_typebound_proc (gfc_symbol*, gfc_try*,\n+gfc_symtree* gfc_find_typebound_proc (gfc_symbol*, bool*,\n \t\t\t\t      const char*, bool, locus*);\n-gfc_symtree* gfc_find_typebound_user_op (gfc_symbol*, gfc_try*,\n+gfc_symtree* gfc_find_typebound_user_op (gfc_symbol*, bool*,\n \t\t\t\t\t const char*, bool, locus*);\n-gfc_typebound_proc* gfc_find_typebound_intrinsic_op (gfc_symbol*, gfc_try*,\n+gfc_typebound_proc* gfc_find_typebound_intrinsic_op (gfc_symbol*, bool*,\n \t\t\t\t\t\t     gfc_intrinsic_op, bool,\n \t\t\t\t\t\t     locus*);\n gfc_symtree* gfc_get_tbp_symtree (gfc_symtree**, const char*);"}, {"sha": "2cadd8b0b2b1b774406c28bece26ce570e85b6cc", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 159, "deletions": 163, "changes": 322, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=524af0d6c72031c249aa737945fde6ac3d726ba2", "patch": "@@ -213,7 +213,7 @@ gfc_match_interface (void)\n \treturn MATCH_ERROR;\n \n       if (!sym->attr.generic\n-\t  && gfc_add_generic (&sym->attr, sym->name, NULL) == FAILURE)\n+\t  && !gfc_add_generic (&sym->attr, sym->name, NULL))\n \treturn MATCH_ERROR;\n \n       if (sym->attr.dummy)\n@@ -251,8 +251,7 @@ gfc_match_abstract_interface (void)\n {\n   match m;\n \n-  if (gfc_notify_std (GFC_STD_F2003, \"ABSTRACT INTERFACE at %C\")\n-\t\t      == FAILURE)\n+  if (!gfc_notify_std (GFC_STD_F2003, \"ABSTRACT INTERFACE at %C\"))\n     return MATCH_ERROR;\n \n   m = gfc_match_eos ();\n@@ -326,23 +325,23 @@ gfc_match_end_interface (void)\n \n \t      /* The following if-statements are used to enforce C1202\n \t\t from F2003.  */\n-\t      if ((strcmp(s1, \"==\") == 0 && strcmp(s2, \".eq.\") == 0)\n-\t\t  || (strcmp(s1, \".eq.\") == 0 && strcmp(s2, \"==\") == 0))\n+\t      if ((strcmp(s1, \"==\") == 0 && strcmp (s2, \".eq.\") == 0)\n+\t\t  || (strcmp(s1, \".eq.\") == 0 && strcmp (s2, \"==\") == 0))\n \t\tbreak;\n-\t      if ((strcmp(s1, \"/=\") == 0 && strcmp(s2, \".ne.\") == 0)\n-\t\t  || (strcmp(s1, \".ne.\") == 0 && strcmp(s2, \"/=\") == 0))\n+\t      if ((strcmp(s1, \"/=\") == 0 && strcmp (s2, \".ne.\") == 0)\n+\t\t  || (strcmp(s1, \".ne.\") == 0 && strcmp (s2, \"/=\") == 0))\n \t\tbreak;\n-\t      if ((strcmp(s1, \"<=\") == 0 && strcmp(s2, \".le.\") == 0)\n-\t\t  || (strcmp(s1, \".le.\") == 0 && strcmp(s2, \"<=\") == 0))\n+\t      if ((strcmp(s1, \"<=\") == 0 && strcmp (s2, \".le.\") == 0)\n+\t\t  || (strcmp(s1, \".le.\") == 0 && strcmp (s2, \"<=\") == 0))\n \t\tbreak;\n-\t      if ((strcmp(s1, \"<\") == 0 && strcmp(s2, \".lt.\") == 0)\n-\t\t  || (strcmp(s1, \".lt.\") == 0 && strcmp(s2, \"<\") == 0))\n+\t      if ((strcmp(s1, \"<\") == 0 && strcmp (s2, \".lt.\") == 0)\n+\t\t  || (strcmp(s1, \".lt.\") == 0 && strcmp (s2, \"<\") == 0))\n \t\tbreak;\n-\t      if ((strcmp(s1, \">=\") == 0 && strcmp(s2, \".ge.\") == 0)\n-\t\t  || (strcmp(s1, \".ge.\") == 0 && strcmp(s2, \">=\") == 0))\n+\t      if ((strcmp(s1, \">=\") == 0 && strcmp (s2, \".ge.\") == 0)\n+\t\t  || (strcmp(s1, \".ge.\") == 0 && strcmp (s2, \">=\") == 0))\n \t\tbreak;\n-\t      if ((strcmp(s1, \">\") == 0 && strcmp(s2, \".gt.\") == 0)\n-\t\t  || (strcmp(s1, \".gt.\") == 0 && strcmp(s2, \">\") == 0))\n+\t      if ((strcmp(s1, \">\") == 0 && strcmp (s2, \".gt.\") == 0)\n+\t\t  || (strcmp(s1, \".gt.\") == 0 && strcmp (s2, \">\") == 0))\n \t\tbreak;\n \n \t      m = MATCH_ERROR;\n@@ -1019,59 +1018,59 @@ generic_correspondence (gfc_formal_arglist *f1, gfc_formal_arglist *f2,\n /* Check if the characteristics of two dummy arguments match,\n    cf. F08:12.3.2.  */\n \n-static gfc_try\n+static bool\n check_dummy_characteristics (gfc_symbol *s1, gfc_symbol *s2,\n \t\t\t     bool type_must_agree, char *errmsg, int err_len)\n {\n   if (s1 == NULL || s2 == NULL)\n-    return s1 == s2 ? SUCCESS : FAILURE;\n+    return s1 == s2 ? true : false;\n \n   /* Check type and rank.  */\n   if (type_must_agree && !compare_type_rank (s2, s1))\n     {\n       snprintf (errmsg, err_len, \"Type/rank mismatch in argument '%s'\",\n \t\ts1->name);\n-      return FAILURE;\n+      return false;\n     }\n \n   /* Check INTENT.  */\n   if (s1->attr.intent != s2->attr.intent)\n     {\n       snprintf (errmsg, err_len, \"INTENT mismatch in argument '%s'\",\n \t\ts1->name);\n-      return FAILURE;\n+      return false;\n     }\n \n   /* Check OPTIONAL attribute.  */\n   if (s1->attr.optional != s2->attr.optional)\n     {\n       snprintf (errmsg, err_len, \"OPTIONAL mismatch in argument '%s'\",\n \t\ts1->name);\n-      return FAILURE;\n+      return false;\n     }\n \n   /* Check ALLOCATABLE attribute.  */\n   if (s1->attr.allocatable != s2->attr.allocatable)\n     {\n       snprintf (errmsg, err_len, \"ALLOCATABLE mismatch in argument '%s'\",\n \t\ts1->name);\n-      return FAILURE;\n+      return false;\n     }\n \n   /* Check POINTER attribute.  */\n   if (s1->attr.pointer != s2->attr.pointer)\n     {\n       snprintf (errmsg, err_len, \"POINTER mismatch in argument '%s'\",\n \t\ts1->name);\n-      return FAILURE;\n+      return false;\n     }\n \n   /* Check TARGET attribute.  */\n   if (s1->attr.target != s2->attr.target)\n     {\n       snprintf (errmsg, err_len, \"TARGET mismatch in argument '%s'\",\n \t\ts1->name);\n-      return FAILURE;\n+      return false;\n     }\n \n   /* FIXME: Do more comprehensive testing of attributes, like e.g.\n@@ -1086,7 +1085,7 @@ check_dummy_characteristics (gfc_symbol *s1, gfc_symbol *s2,\n \t{\n \t  snprintf (errmsg, err_len, \"Interface mismatch in dummy procedure \"\n \t\t    \"'%s': %s\", s1->name, err);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n     }\n \n@@ -1104,7 +1103,7 @@ check_dummy_characteristics (gfc_symbol *s1, gfc_symbol *s2,\n \tcase -3:\n \t  snprintf (errmsg, err_len, \"Character length mismatch \"\n \t\t    \"in argument '%s'\", s1->name);\n-\t  return FAILURE;\n+\t  return false;\n \n \tcase -2:\n \t  /* FIXME: Implement a warning for this case.\n@@ -1132,7 +1131,7 @@ check_dummy_characteristics (gfc_symbol *s1, gfc_symbol *s2,\n \t{\n \t  snprintf (errmsg, err_len, \"Shape mismatch in argument '%s'\",\n \t\t    s1->name);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n \n       if (s1->as->type == AS_EXPLICIT)\n@@ -1152,7 +1151,7 @@ check_dummy_characteristics (gfc_symbol *s1, gfc_symbol *s2,\n \t      case -3:\n \t\tsnprintf (errmsg, err_len, \"Shape mismatch in dimension %i of \"\n \t\t\t  \"argument '%s'\", i + 1, s1->name);\n-\t\treturn FAILURE;\n+\t\treturn false;\n \n \t      case -2:\n \t\t/* FIXME: Implement a warning for this case.\n@@ -1172,14 +1171,14 @@ check_dummy_characteristics (gfc_symbol *s1, gfc_symbol *s2,\n \t  }\n     }\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n /* Check if the characteristics of two function results match,\n    cf. F08:12.3.3.  */\n \n-static gfc_try\n+static bool\n check_result_characteristics (gfc_symbol *s1, gfc_symbol *s2,\n \t\t\t      char *errmsg, int err_len)\n {\n@@ -1189,45 +1188,45 @@ check_result_characteristics (gfc_symbol *s1, gfc_symbol *s2,\n   r2 = s2->result ? s2->result : s2;\n \n   if (r1->ts.type == BT_UNKNOWN)\n-    return SUCCESS;\n+    return true;\n \n   /* Check type and rank.  */\n   if (!compare_type_rank (r1, r2))\n     {\n       snprintf (errmsg, err_len, \"Type/rank mismatch in function result\");\n-      return FAILURE;\n+      return false;\n     }\n \n   /* Check ALLOCATABLE attribute.  */\n   if (r1->attr.allocatable != r2->attr.allocatable)\n     {\n       snprintf (errmsg, err_len, \"ALLOCATABLE attribute mismatch in \"\n \t\t\"function result\");\n-      return FAILURE;\n+      return false;\n     }\n \n   /* Check POINTER attribute.  */\n   if (r1->attr.pointer != r2->attr.pointer)\n     {\n       snprintf (errmsg, err_len, \"POINTER attribute mismatch in \"\n \t\t\"function result\");\n-      return FAILURE;\n+      return false;\n     }\n \n   /* Check CONTIGUOUS attribute.  */\n   if (r1->attr.contiguous != r2->attr.contiguous)\n     {\n       snprintf (errmsg, err_len, \"CONTIGUOUS attribute mismatch in \"\n \t\t\"function result\");\n-      return FAILURE;\n+      return false;\n     }\n \n   /* Check PROCEDURE POINTER attribute.  */\n   if (r1 != s1 && r1->attr.proc_pointer != r2->attr.proc_pointer)\n     {\n       snprintf (errmsg, err_len, \"PROCEDURE POINTER mismatch in \"\n \t\t\"function result\");\n-      return FAILURE;\n+      return false;\n     }\n \n   /* Check string length.  */\n@@ -1237,7 +1236,7 @@ check_result_characteristics (gfc_symbol *s1, gfc_symbol *s2,\n \t{\n \t  snprintf (errmsg, err_len, \"Character length mismatch \"\n \t\t    \"in function result\");\n-\t  return FAILURE;\n+\t  return false;\n \t}\n \n       if (r1->ts.u.cl->length)\n@@ -1251,7 +1250,7 @@ check_result_characteristics (gfc_symbol *s1, gfc_symbol *s2,\n \t    case -3:\n \t      snprintf (errmsg, err_len, \"Character length mismatch \"\n \t\t\t\"in function result\");\n-\t      return FAILURE;\n+\t      return false;\n \n \t    case -2:\n \t      /* FIXME: Implement a warning for this case.\n@@ -1279,7 +1278,7 @@ check_result_characteristics (gfc_symbol *s1, gfc_symbol *s2,\n       if (r1->as->type != r2->as->type)\n \t{\n \t  snprintf (errmsg, err_len, \"Shape mismatch in function result\");\n-\t  return FAILURE;\n+\t  return false;\n \t}\n \n       if (r1->as->type == AS_EXPLICIT)\n@@ -1299,7 +1298,7 @@ check_result_characteristics (gfc_symbol *s1, gfc_symbol *s2,\n \t      case -3:\n \t\tsnprintf (errmsg, err_len, \"Shape mismatch in dimension %i of \"\n \t\t\t  \"function result\", i + 1);\n-\t\treturn FAILURE;\n+\t\treturn false;\n \n \t      case -2:\n \t\t/* FIXME: Implement a warning for this case.\n@@ -1318,7 +1317,7 @@ check_result_characteristics (gfc_symbol *s1, gfc_symbol *s2,\n \t  }\n     }\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n@@ -1362,8 +1361,7 @@ gfc_compare_interfaces (gfc_symbol *s1, gfc_symbol *s2, const char *name2,\n       if (s1->attr.function && s2->attr.function)\n \t{\n \t  /* If both are functions, check result characteristics.  */\n-\t  if (check_result_characteristics (s1, s2, errmsg, err_len)\n-\t      == FAILURE)\n+\t  if (!check_result_characteristics (s1, s2, errmsg, err_len))\n \t    return 0;\n \t}\n \n@@ -1423,8 +1421,8 @@ gfc_compare_interfaces (gfc_symbol *s1, gfc_symbol *s2, const char *name2,\n \tif (strict_flag)\n \t  {\n \t    /* Check all characteristics.  */\n-\t    if (check_dummy_characteristics (f1->sym, f2->sym,\n-\t\t\t\t\t     true, errmsg, err_len) == FAILURE)\n+\t    if (!check_dummy_characteristics (f1->sym, f2->sym, true, \n+\t\t\t\t\t      errmsg, err_len))\n \t      return 0;\n \t  }\n \telse if (!compare_type_rank (f2->sym, f1->sym))\n@@ -1491,9 +1489,9 @@ check_interface0 (gfc_interface *p, const char *interface_name)\n \n       /* F2003, C1207. F2008, C1207.  */\n       if (p->sym->attr.proc == PROC_INTERNAL\n-\t  && gfc_notify_std (GFC_STD_F2008, \"Internal procedure \"\n-\t\t\t     \"'%s' in %s at %L\", p->sym->name, interface_name,\n-\t\t\t     &p->sym->declared_at) == FAILURE)\n+\t  && !gfc_notify_std (GFC_STD_F2008, \"Internal procedure \"\n+\t\t\t      \"'%s' in %s at %L\", p->sym->name, \n+\t\t\t      interface_name, &p->sym->declared_at))\n \treturn 1;\n     }\n   p = psave;\n@@ -1879,7 +1877,7 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n \t  gfc_add_function (&act_sym->attr, act_sym->name,\n \t  &act_sym->declared_at);\n \t  if (act_sym->ts.type == BT_UNKNOWN\n-\t      && gfc_set_default_type (act_sym, 1, act_sym->ns) == FAILURE)\n+\t      && !gfc_set_default_type (act_sym, 1, act_sym->ns))\n \t    return 0;\n \t}\n       else if (formal->attr.subroutine && !act_sym->attr.subroutine)\n@@ -2478,7 +2476,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \n       /* Make sure that intrinsic vtables exist for calls to unlimited\n \t polymorphic formal arguments.  */\n-      if (UNLIMITED_POLY(f->sym)\n+      if (UNLIMITED_POLY (f->sym)\n \t  && a->expr->ts.type != BT_DERIVED\n \t  && a->expr->ts.type != BT_CLASS)\n \tgfc_find_intrinsic_vtab (&a->expr->ts);\n@@ -2528,7 +2526,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t      gfc_error (\"Actual argument at %L to assumed-type dummy is of \"\n \t\t\t \"derived type with type-bound or FINAL procedures\",\n \t\t\t &a->expr->where);\n-\t      return FAILURE;\n+\t      return false;\n \t    }\n \t}\n \n@@ -2741,11 +2739,9 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t  if (((f->sym->ts.type == BT_CLASS && f->sym->attr.class_ok\n \t\t&& CLASS_DATA (f->sym)->attr.class_pointer)\n \t       || (f->sym->ts.type != BT_CLASS && f->sym->attr.pointer))\n-\t      && gfc_check_vardef_context (a->expr, true, false, false, context)\n-\t\t   == FAILURE)\n+\t      && !gfc_check_vardef_context (a->expr, true, false, false, context))\n \t    return 0;\n-\t  if (gfc_check_vardef_context (a->expr, false, false, false, context)\n-\t\t== FAILURE)\n+\t  if (!gfc_check_vardef_context (a->expr, false, false, false, context))\n \t    return 0;\n \t}\n \n@@ -2919,9 +2915,9 @@ pair_cmp (const void *p1, const void *p2)\n \n /* Given two expressions from some actual arguments, test whether they\n    refer to the same expression. The analysis is conservative.\n-   Returning FAILURE will produce no warning.  */\n+   Returning false will produce no warning.  */\n \n-static gfc_try\n+static bool\n compare_actual_expr (gfc_expr *e1, gfc_expr *e2)\n {\n   const gfc_ref *r1, *r2;\n@@ -2930,55 +2926,55 @@ compare_actual_expr (gfc_expr *e1, gfc_expr *e2)\n       || e1->expr_type != EXPR_VARIABLE\n       || e2->expr_type != EXPR_VARIABLE\n       || e1->symtree->n.sym != e2->symtree->n.sym)\n-    return FAILURE;\n+    return false;\n \n   /* TODO: improve comparison, see expr.c:show_ref().  */\n   for (r1 = e1->ref, r2 = e2->ref; r1 && r2; r1 = r1->next, r2 = r2->next)\n     {\n       if (r1->type != r2->type)\n-\treturn FAILURE;\n+\treturn false;\n       switch (r1->type)\n \t{\n \tcase REF_ARRAY:\n \t  if (r1->u.ar.type != r2->u.ar.type)\n-\t    return FAILURE;\n+\t    return false;\n \t  /* TODO: At the moment, consider only full arrays;\n \t     we could do better.  */\n \t  if (r1->u.ar.type != AR_FULL || r2->u.ar.type != AR_FULL)\n-\t    return FAILURE;\n+\t    return false;\n \t  break;\n \n \tcase REF_COMPONENT:\n \t  if (r1->u.c.component != r2->u.c.component)\n-\t    return FAILURE;\n+\t    return false;\n \t  break;\n \n \tcase REF_SUBSTRING:\n-\t  return FAILURE;\n+\t  return false;\n \n \tdefault:\n \t  gfc_internal_error (\"compare_actual_expr(): Bad component code\");\n \t}\n     }\n   if (!r1 && !r2)\n-    return SUCCESS;\n-  return FAILURE;\n+    return true;\n+  return false;\n }\n \n \n /* Given formal and actual argument lists that correspond to one\n    another, check that identical actual arguments aren't not\n    associated with some incompatible INTENTs.  */\n \n-static gfc_try\n+static bool\n check_some_aliasing (gfc_formal_arglist *f, gfc_actual_arglist *a)\n {\n   sym_intent f1_intent, f2_intent;\n   gfc_formal_arglist *f1;\n   gfc_actual_arglist *a1;\n   size_t n, i, j;\n   argpair *p;\n-  gfc_try t = SUCCESS;\n+  bool t = true;\n \n   n = 0;\n   for (f1 = f, a1 = a;; f1 = f1->next, a1 = a1->next)\n@@ -3015,7 +3011,7 @@ check_some_aliasing (gfc_formal_arglist *f, gfc_actual_arglist *a)\n \t    gfc_internal_error (\"check_some_aliasing(): corrupted data\");\n \n \t  /* Are the expression the same?  */\n-\t  if (compare_actual_expr (p[i].a->expr, p[j].a->expr) == FAILURE)\n+\t  if (!compare_actual_expr (p[i].a->expr, p[j].a->expr))\n \t    break;\n \t  f2_intent = p[j].f->sym->attr.intent;\n \t  if ((f1_intent == INTENT_IN && f2_intent == INTENT_OUT)\n@@ -3026,7 +3022,7 @@ check_some_aliasing (gfc_formal_arglist *f, gfc_actual_arglist *a)\n \t\t\t   gfc_intent_string (f1_intent), p[i].f->sym->name,\n \t\t\t   gfc_intent_string (f2_intent), p[j].f->sym->name,\n \t\t\t   &p[i].a->expr->where);\n-\t      t = FAILURE;\n+\t      t = false;\n \t    }\n \t}\n     }\n@@ -3039,7 +3035,7 @@ check_some_aliasing (gfc_formal_arglist *f, gfc_actual_arglist *a)\n    another, check that they are compatible in the sense that intents\n    are not mismatched.  */\n \n-static gfc_try\n+static bool\n check_intents (gfc_formal_arglist *f, gfc_actual_arglist *a)\n {\n   sym_intent f_intent;\n@@ -3065,7 +3061,7 @@ check_intents (gfc_formal_arglist *f, gfc_actual_arglist *a)\n \t      gfc_error (\"Procedure argument at %L is local to a PURE \"\n \t\t\t \"procedure and has the POINTER attribute\",\n \t\t\t &a->expr->where);\n-\t      return FAILURE;\n+\t      return false;\n \t    }\n \t}\n \n@@ -3077,7 +3073,7 @@ check_intents (gfc_formal_arglist *f, gfc_actual_arglist *a)\n \t      gfc_error (\"Coindexed actual argument at %L in PURE procedure \"\n \t\t\t \"is passed to an INTENT(%s) argument\",\n \t\t\t &a->expr->where, gfc_intent_string (f_intent));\n-\t      return FAILURE;\n+\t      return false;\n \t    }\n \n \t  if ((f->sym->ts.type == BT_CLASS && f->sym->attr.class_ok\n@@ -3087,7 +3083,7 @@ check_intents (gfc_formal_arglist *f, gfc_actual_arglist *a)\n \t      gfc_error (\"Coindexed actual argument at %L in PURE procedure \"\n \t\t\t \"is passed to a POINTER dummy argument\",\n \t\t\t &a->expr->where);\n-\t      return FAILURE;\n+\t      return false;\n \t    }\n \t}\n \n@@ -3098,19 +3094,19 @@ check_intents (gfc_formal_arglist *f, gfc_actual_arglist *a)\n \t   gfc_error (\"Coindexed polymorphic actual argument at %L is passed \"\n \t\t      \"polymorphic dummy argument '%s'\",\n \t\t\t &a->expr->where, f->sym->name);\n-\t   return FAILURE;\n+\t   return false;\n \t }\n     }\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n /* Check how a procedure is used against its interface.  If all goes\n    well, the actual argument list will also end up being properly\n    sorted.  */\n \n-gfc_try\n+bool\n gfc_procedure_use (gfc_symbol *sym, gfc_actual_arglist **ap, locus *where)\n {\n   gfc_formal_arglist *dummy_args;\n@@ -3139,22 +3135,22 @@ gfc_procedure_use (gfc_symbol *sym, gfc_actual_arglist **ap, locus *where)\n \t  gfc_error(\"The pointer object '%s' at %L must have an explicit \"\n \t\t    \"function interface or be declared as array\",\n \t\t    sym->name, where);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n \n       if (sym->attr.allocatable && !sym->attr.external)\n \t{\n \t  gfc_error(\"The allocatable object '%s' at %L must have an explicit \"\n \t\t    \"function interface or be declared as array\",\n \t\t    sym->name, where);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n \n       if (sym->attr.allocatable)\n \t{\n \t  gfc_error(\"Allocatable function '%s' at %L must have an explicit \"\n \t\t    \"function interface\", sym->name, where);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n \n       for (a = *ap; a; a = a->next)\n@@ -3194,7 +3190,7 @@ gfc_procedure_use (gfc_symbol *sym, gfc_actual_arglist **ap, locus *where)\n \t      && a->expr->ts.type == BT_UNKNOWN)\n \t    {\n \t      gfc_error (\"MOLD argument to NULL required at %L\", &a->expr->where);\n-\t      return FAILURE;\n+\t      return false;\n \t    }\n \n \t  /* TS 29113, C407b.  */\n@@ -3203,25 +3199,25 @@ gfc_procedure_use (gfc_symbol *sym, gfc_actual_arglist **ap, locus *where)\n \t    {\n \t      gfc_error (\"Assumed-rank argument requires an explicit interface \"\n \t\t\t \"at %L\", &a->expr->where);\n-\t      return FAILURE;\n+\t      return false;\n \t    }\n \t}\n \n-      return SUCCESS;\n+      return true;\n     }\n \n   dummy_args = gfc_sym_get_dummy_args (sym);\n \n   if (!compare_actual_formal (ap, dummy_args, 0, sym->attr.elemental, where))\n-    return FAILURE;\n+    return false;\n \n-  if (check_intents (dummy_args, *ap) == FAILURE)\n-    return FAILURE;\n+  if (!check_intents (dummy_args, *ap))\n+    return false;\n \n   if (gfc_option.warn_aliasing)\n     check_some_aliasing (dummy_args, *ap);\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n@@ -3427,7 +3423,7 @@ matching_typebound_op (gfc_expr** tb_base,\n       {\n \tgfc_typebound_proc* tb;\n \tgfc_symbol* derived;\n-\tgfc_try result;\n+\tbool result;\n \n \twhile (base->expr->expr_type == EXPR_OP\n \t       && base->expr->value.op.op == INTRINSIC_PARENTHESES)\n@@ -3462,7 +3458,7 @@ matching_typebound_op (gfc_expr** tb_base,\n \n \t/* This means we hit a PRIVATE operator which is use-associated and\n \t   should thus not be seen.  */\n-\tif (result == FAILURE)\n+\tif (!result)\n \t  tb = NULL;\n \n \t/* Look through the super-type hierarchy for a matching specific\n@@ -3653,13 +3649,13 @@ gfc_extend_expr (gfc_expr *e)\n \t a call to it and succeed.  */\n       if (tbo)\n \t{\n-\t  gfc_try result;\n+\t  bool result;\n \n \t  gcc_assert (tb_base);\n \t  build_compcall_for_operator (e, actual, tb_base, tbo, gname);\n \n \t  result = gfc_resolve_expr (e);\n-\t  if (result == FAILURE)\n+\t  if (!result)\n \t    return MATCH_ERROR;\n \n \t  return MATCH_YES;\n@@ -3681,7 +3677,7 @@ gfc_extend_expr (gfc_expr *e)\n   e->value.function.name = NULL;\n   e->user_operator = 1;\n \n-  if (gfc_resolve_expr (e) == FAILURE)\n+  if (!gfc_resolve_expr (e))\n     return MATCH_ERROR;\n \n   return MATCH_YES;\n@@ -3690,10 +3686,10 @@ gfc_extend_expr (gfc_expr *e)\n \n /* Tries to replace an assignment code node with a subroutine call to\n    the subroutine associated with the assignment operator.  Return\n-   SUCCESS if the node was replaced.  On FAILURE, no error is\n+   true if the node was replaced.  On false, no error is\n    generated.  */\n \n-gfc_try\n+bool\n gfc_extend_assign (gfc_code *c, gfc_namespace *ns)\n {\n   gfc_actual_arglist *actual;\n@@ -3711,7 +3707,7 @@ gfc_extend_assign (gfc_code *c, gfc_namespace *ns)\n       && (rhs->rank == 0 || rhs->rank == lhs->rank)\n       && (lhs->ts.type == rhs->ts.type\n \t  || (gfc_numeric_ts (&lhs->ts) && gfc_numeric_ts (&rhs->ts))))\n-    return FAILURE;\n+    return false;\n \n   actual = gfc_get_actual_arglist ();\n   actual->expr = lhs;\n@@ -3753,12 +3749,12 @@ gfc_extend_assign (gfc_code *c, gfc_namespace *ns)\n \n \t  /* c is resolved from the caller, so no need to do it here.  */\n \n-\t  return SUCCESS;\n+\t  return true;\n \t}\n \n       free (actual->next);\n       free (actual);\n-      return FAILURE;\n+      return false;\n     }\n \n   /* Replace the assignment with the call.  */\n@@ -3768,15 +3764,15 @@ gfc_extend_assign (gfc_code *c, gfc_namespace *ns)\n   c->expr2 = NULL;\n   c->ext.actual = actual;\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n /* Make sure that the interface just parsed is not already present in\n    the given interface list.  Ambiguity isn't checked yet since module\n    procedures can be present without interfaces.  */\n \n-gfc_try\n+bool\n gfc_check_new_interface (gfc_interface *base, gfc_symbol *new_sym, locus loc)\n {\n   gfc_interface *ip;\n@@ -3787,17 +3783,17 @@ gfc_check_new_interface (gfc_interface *base, gfc_symbol *new_sym, locus loc)\n \t{\n \t  gfc_error (\"Entity '%s' at %L is already present in the interface\",\n \t\t     new_sym->name, &loc);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n     }\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n /* Add a symbol to the current interface.  */\n \n-gfc_try\n+bool\n gfc_add_interface (gfc_symbol *new_sym)\n {\n   gfc_interface **head, *intr;\n@@ -3808,70 +3804,70 @@ gfc_add_interface (gfc_symbol *new_sym)\n     {\n     case INTERFACE_NAMELESS:\n     case INTERFACE_ABSTRACT:\n-      return SUCCESS;\n+      return true;\n \n     case INTERFACE_INTRINSIC_OP:\n       for (ns = current_interface.ns; ns; ns = ns->parent)\n \tswitch (current_interface.op)\n \t  {\n \t    case INTRINSIC_EQ:\n \t    case INTRINSIC_EQ_OS:\n-\t      if (gfc_check_new_interface (ns->op[INTRINSIC_EQ], new_sym,\n-\t\t\t\t\t   gfc_current_locus) == FAILURE\n-\t          || gfc_check_new_interface (ns->op[INTRINSIC_EQ_OS], new_sym,\n-\t\t\t\t\t      gfc_current_locus) == FAILURE)\n-\t\treturn FAILURE;\n+\t      if (!gfc_check_new_interface (ns->op[INTRINSIC_EQ], new_sym, \n+\t\t\t\t\t    gfc_current_locus)\n+\t          || !gfc_check_new_interface (ns->op[INTRINSIC_EQ_OS], \n+\t\t\t\t\t       new_sym, gfc_current_locus))\n+\t\treturn false;\n \t      break;\n \n \t    case INTRINSIC_NE:\n \t    case INTRINSIC_NE_OS:\n-\t      if (gfc_check_new_interface (ns->op[INTRINSIC_NE], new_sym,\n-\t\t\t\t\t   gfc_current_locus) == FAILURE\n-\t          || gfc_check_new_interface (ns->op[INTRINSIC_NE_OS], new_sym,\n-\t\t\t\t\t      gfc_current_locus) == FAILURE)\n-\t\treturn FAILURE;\n+\t      if (!gfc_check_new_interface (ns->op[INTRINSIC_NE], new_sym, \n+\t\t\t\t\t    gfc_current_locus)\n+\t          || !gfc_check_new_interface (ns->op[INTRINSIC_NE_OS], \n+\t\t\t\t\t       new_sym, gfc_current_locus))\n+\t\treturn false;\n \t      break;\n \n \t    case INTRINSIC_GT:\n \t    case INTRINSIC_GT_OS:\n-\t      if (gfc_check_new_interface (ns->op[INTRINSIC_GT], new_sym,\n-\t\t\t\t\t   gfc_current_locus) == FAILURE\n-\t          || gfc_check_new_interface (ns->op[INTRINSIC_GT_OS], new_sym,\n-\t\t\t\t\t      gfc_current_locus) == FAILURE)\n-\t\treturn FAILURE;\n+\t      if (!gfc_check_new_interface (ns->op[INTRINSIC_GT], \n+\t\t\t\t\t    new_sym, gfc_current_locus)\n+\t          || !gfc_check_new_interface (ns->op[INTRINSIC_GT_OS], \n+\t\t\t\t\t       new_sym, gfc_current_locus))\n+\t\treturn false;\n \t      break;\n \n \t    case INTRINSIC_GE:\n \t    case INTRINSIC_GE_OS:\n-\t      if (gfc_check_new_interface (ns->op[INTRINSIC_GE], new_sym,\n-\t\t\t\t\t   gfc_current_locus) == FAILURE\n-\t          || gfc_check_new_interface (ns->op[INTRINSIC_GE_OS], new_sym,\n-\t\t\t\t\t      gfc_current_locus) == FAILURE)\n-\t\treturn FAILURE;\n+\t      if (!gfc_check_new_interface (ns->op[INTRINSIC_GE], \n+\t\t\t\t\t    new_sym, gfc_current_locus)\n+\t          || !gfc_check_new_interface (ns->op[INTRINSIC_GE_OS], \n+\t\t\t\t\t       new_sym, gfc_current_locus))\n+\t\treturn false;\n \t      break;\n \n \t    case INTRINSIC_LT:\n \t    case INTRINSIC_LT_OS:\n-\t      if (gfc_check_new_interface (ns->op[INTRINSIC_LT], new_sym,\n-\t\t\t\t\t   gfc_current_locus) == FAILURE\n-\t          || gfc_check_new_interface (ns->op[INTRINSIC_LT_OS], new_sym,\n-\t\t\t\t\t      gfc_current_locus) == FAILURE)\n-\t\treturn FAILURE;\n+\t      if (!gfc_check_new_interface (ns->op[INTRINSIC_LT], \n+\t\t\t\t\t    new_sym, gfc_current_locus)\n+\t          || !gfc_check_new_interface (ns->op[INTRINSIC_LT_OS], \n+\t\t\t\t\t       new_sym, gfc_current_locus))\n+\t\treturn false;\n \t      break;\n \n \t    case INTRINSIC_LE:\n \t    case INTRINSIC_LE_OS:\n-\t      if (gfc_check_new_interface (ns->op[INTRINSIC_LE], new_sym,\n-\t\t\t\t\t   gfc_current_locus) == FAILURE\n-\t          || gfc_check_new_interface (ns->op[INTRINSIC_LE_OS], new_sym,\n-\t\t\t\t\t      gfc_current_locus) == FAILURE)\n-\t\treturn FAILURE;\n+\t      if (!gfc_check_new_interface (ns->op[INTRINSIC_LE], \n+\t\t\t\t\t    new_sym, gfc_current_locus)\n+\t          || !gfc_check_new_interface (ns->op[INTRINSIC_LE_OS], \n+\t\t\t\t\t       new_sym, gfc_current_locus))\n+\t\treturn false;\n \t      break;\n \n \t    default:\n-\t      if (gfc_check_new_interface (ns->op[current_interface.op], new_sym,\n-\t\t\t\t\t   gfc_current_locus) == FAILURE)\n-\t\treturn FAILURE;\n+\t      if (!gfc_check_new_interface (ns->op[current_interface.op], \n+\t\t\t\t\t    new_sym, gfc_current_locus))\n+\t\treturn false;\n \t  }\n \n       head = &current_interface.ns->op[current_interface.op];\n@@ -3884,18 +3880,18 @@ gfc_add_interface (gfc_symbol *new_sym)\n \t  if (sym == NULL)\n \t    continue;\n \n-\t  if (gfc_check_new_interface (sym->generic, new_sym, gfc_current_locus)\n-\t      == FAILURE)\n-\t    return FAILURE;\n+\t  if (!gfc_check_new_interface (sym->generic, \n+\t\t\t\t\tnew_sym, gfc_current_locus))\n+\t    return false;\n \t}\n \n       head = &current_interface.sym->generic;\n       break;\n \n     case INTERFACE_USER_OP:\n-      if (gfc_check_new_interface (current_interface.uop->op, new_sym,\n-\t\t\t\t   gfc_current_locus) == FAILURE)\n-\treturn FAILURE;\n+      if (!gfc_check_new_interface (current_interface.uop->op, \n+\t\t\t\t    new_sym, gfc_current_locus))\n+\treturn false;\n \n       head = &current_interface.uop->op;\n       break;\n@@ -3911,7 +3907,7 @@ gfc_add_interface (gfc_symbol *new_sym)\n   intr->next = *head;\n   *head = intr;\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n@@ -3980,7 +3976,7 @@ gfc_free_formal_arglist (gfc_formal_arglist *p)\n /* Check that it is ok for the type-bound procedure 'proc' to override the\n    procedure 'old', cf. F08:4.5.7.3.  */\n \n-gfc_try\n+bool\n gfc_check_typebound_override (gfc_symtree* proc, gfc_symtree* old)\n {\n   locus where;\n@@ -3998,7 +3994,7 @@ gfc_check_typebound_override (gfc_symtree* proc, gfc_symtree* old)\n     {\n       gfc_error (\"Can't overwrite GENERIC '%s' at %L\",\n \t\t old->name, &proc->n.tb->where);\n-      return FAILURE;\n+      return false;\n     }\n \n   where = proc->n.tb->where;\n@@ -4010,23 +4006,23 @@ gfc_check_typebound_override (gfc_symtree* proc, gfc_symtree* old)\n     {\n       gfc_error (\"'%s' at %L overrides a procedure binding declared\"\n \t\t \" NON_OVERRIDABLE\", proc->name, &where);\n-      return FAILURE;\n+      return false;\n     }\n \n   /* It's an error to override a non-DEFERRED procedure with a DEFERRED one.  */\n   if (!old->n.tb->deferred && proc->n.tb->deferred)\n     {\n       gfc_error (\"'%s' at %L must not be DEFERRED as it overrides a\"\n \t\t \" non-DEFERRED binding\", proc->name, &where);\n-      return FAILURE;\n+      return false;\n     }\n \n   /* If the overridden binding is PURE, the overriding must be, too.  */\n   if (old_target->attr.pure && !proc_target->attr.pure)\n     {\n       gfc_error (\"'%s' at %L overrides a PURE procedure and must also be PURE\",\n \t\t proc->name, &where);\n-      return FAILURE;\n+      return false;\n     }\n \n   /* If the overridden binding is ELEMENTAL, the overriding must be, too.  If it\n@@ -4035,13 +4031,13 @@ gfc_check_typebound_override (gfc_symtree* proc, gfc_symtree* old)\n     {\n       gfc_error (\"'%s' at %L overrides an ELEMENTAL procedure and must also be\"\n \t\t \" ELEMENTAL\", proc->name, &where);\n-      return FAILURE;\n+      return false;\n     }\n   if (!old_target->attr.elemental && proc_target->attr.elemental)\n     {\n       gfc_error (\"'%s' at %L overrides a non-ELEMENTAL procedure and must not\"\n \t\t \" be ELEMENTAL, either\", proc->name, &where);\n-      return FAILURE;\n+      return false;\n     }\n \n   /* If the overridden binding is a SUBROUTINE, the overriding must also be a\n@@ -4050,7 +4046,7 @@ gfc_check_typebound_override (gfc_symtree* proc, gfc_symtree* old)\n     {\n       gfc_error (\"'%s' at %L overrides a SUBROUTINE and must also be a\"\n \t\t \" SUBROUTINE\", proc->name, &where);\n-      return FAILURE;\n+      return false;\n     }\n \n   /* If the overridden binding is a FUNCTION, the overriding must also be a\n@@ -4061,15 +4057,15 @@ gfc_check_typebound_override (gfc_symtree* proc, gfc_symtree* old)\n \t{\n \t  gfc_error (\"'%s' at %L overrides a FUNCTION and must also be a\"\n \t\t     \" FUNCTION\", proc->name, &where);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n \n-      if (check_result_characteristics (proc_target, old_target,\n-\t\t\t\t\terr, sizeof(err)) == FAILURE)\n+      if (!check_result_characteristics (proc_target, old_target, err, \n+\t\t\t\t\t sizeof(err)))\n \t{\n \t  gfc_error (\"Result mismatch for the overriding procedure \"\n \t\t     \"'%s' at %L: %s\", proc->name, &where, err);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n     }\n \n@@ -4080,7 +4076,7 @@ gfc_check_typebound_override (gfc_symtree* proc, gfc_symtree* old)\n     {\n       gfc_error (\"'%s' at %L overrides a PUBLIC procedure and must not be\"\n \t\t \" PRIVATE\", proc->name, &where);\n-      return FAILURE;\n+      return false;\n     }\n \n   /* Compare the formal argument lists of both procedures.  This is also abused\n@@ -4112,16 +4108,16 @@ gfc_check_typebound_override (gfc_symtree* proc, gfc_symtree* old)\n \t\t     \" to match the corresponding argument of the overridden\"\n \t\t     \" procedure\", proc_formal->sym->name, proc->name, &where,\n \t\t     old_formal->sym->name);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n \n       check_type = proc_pass_arg != argpos && old_pass_arg != argpos;\n-      if (check_dummy_characteristics (proc_formal->sym, old_formal->sym,\n-\t\t\t\t       check_type, err, sizeof(err)) == FAILURE)\n+      if (!check_dummy_characteristics (proc_formal->sym, old_formal->sym, \n+\t\t\t\t\tcheck_type, err, sizeof(err)))\n \t{\n \t  gfc_error (\"Argument mismatch for the overriding procedure \"\n \t\t     \"'%s' at %L: %s\", proc->name, &where, err);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n \n       ++argpos;\n@@ -4130,7 +4126,7 @@ gfc_check_typebound_override (gfc_symtree* proc, gfc_symtree* old)\n     {\n       gfc_error (\"'%s' at %L must have the same number of formal arguments as\"\n \t\t \" the overridden procedure\", proc->name, &where);\n-      return FAILURE;\n+      return false;\n     }\n \n   /* If the overridden binding is NOPASS, the overriding one must also be\n@@ -4139,7 +4135,7 @@ gfc_check_typebound_override (gfc_symtree* proc, gfc_symtree* old)\n     {\n       gfc_error (\"'%s' at %L overrides a NOPASS binding and must also be\"\n \t\t \" NOPASS\", proc->name, &where);\n-      return FAILURE;\n+      return false;\n     }\n \n   /* If the overridden binding is PASS(x), the overriding one must also be\n@@ -4150,17 +4146,17 @@ gfc_check_typebound_override (gfc_symtree* proc, gfc_symtree* old)\n \t{\n \t  gfc_error (\"'%s' at %L overrides a binding with PASS and must also be\"\n \t\t     \" PASS\", proc->name, &where);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n \n       if (proc_pass_arg != old_pass_arg)\n \t{\n \t  gfc_error (\"Passed-object dummy argument of '%s' at %L must be at\"\n \t\t     \" the same position as the passed-object dummy argument of\"\n \t\t     \" the overridden procedure\", proc->name, &where);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n     }\n \n-  return SUCCESS;\n+  return true;\n }"}, {"sha": "c43127978af9daf6cb9e3699d3e78cc7577f9e45", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 86, "deletions": 89, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=524af0d6c72031c249aa737945fde6ac3d726ba2", "patch": "@@ -178,7 +178,7 @@ find_char_conv (gfc_typespec *from, gfc_typespec *to)\n    and call the proper check function rather than forcing each\n    function to manipulate the argument list.  */\n \n-static gfc_try\n+static bool\n do_check (gfc_intrinsic_sym *specific, gfc_actual_arglist *arg)\n {\n   gfc_expr *a1, *a2, *a3, *a4, *a5;\n@@ -343,7 +343,7 @@ add_sym (const char *name, gfc_isym_id id, enum klass cl, int actual_ok, bt type\n static void\n add_sym_0 (const char *name, gfc_isym_id id, enum klass cl, int actual_ok, bt type,\n \t   int kind, int standard,\n-\t   gfc_try (*check) (void),\n+\t   bool (*check) (void),\n \t   gfc_expr *(*simplify) (void),\n \t   void (*resolve) (gfc_expr *))\n {\n@@ -386,7 +386,7 @@ add_sym_0s (const char *name, gfc_isym_id id, int standard,\n static void\n add_sym_1 (const char *name, gfc_isym_id id, enum klass cl, int actual_ok, bt type,\n \t   int kind, int standard,\n-\t   gfc_try (*check) (gfc_expr *),\n+\t   bool (*check) (gfc_expr *),\n \t   gfc_expr *(*simplify) (gfc_expr *),\n \t   void (*resolve) (gfc_expr *, gfc_expr *),\n \t   const char *a1, bt type1, int kind1, int optional1)\n@@ -411,7 +411,7 @@ add_sym_1 (const char *name, gfc_isym_id id, enum klass cl, int actual_ok, bt ty\n static void\n add_sym_1_intent (const char *name, gfc_isym_id id, enum klass cl,\n \t\t  int actual_ok, bt type, int kind, int standard,\n-\t\t  gfc_try (*check) (gfc_expr *),\n+\t\t  bool (*check) (gfc_expr *),\n \t\t  gfc_expr *(*simplify) (gfc_expr *),\n \t\t  void (*resolve) (gfc_expr *, gfc_expr *),\n \t\t  const char *a1, bt type1, int kind1, int optional1,\n@@ -436,7 +436,7 @@ add_sym_1_intent (const char *name, gfc_isym_id id, enum klass cl,\n \n static void\n add_sym_1s (const char *name, gfc_isym_id id, enum klass cl, bt type, int kind,\n-\t    int standard, gfc_try (*check) (gfc_expr *),\n+\t    int standard, bool (*check) (gfc_expr *),\n \t    gfc_expr *(*simplify) (gfc_expr *), void (*resolve) (gfc_code *),\n \t    const char *a1, bt type1, int kind1, int optional1,\n \t    sym_intent intent1)\n@@ -461,7 +461,7 @@ add_sym_1s (const char *name, gfc_isym_id id, enum klass cl, bt type, int kind,\n static void\n add_sym_1m (const char *name, gfc_isym_id id, enum klass cl, int actual_ok, bt type,\n \t    int kind, int standard,\n-\t    gfc_try (*check) (gfc_actual_arglist *),\n+\t    bool (*check) (gfc_actual_arglist *),\n \t    gfc_expr *(*simplify) (gfc_expr *),\n \t    void (*resolve) (gfc_expr *, gfc_actual_arglist *),\n \t    const char *a1, bt type1, int kind1, int optional1,\n@@ -488,7 +488,7 @@ add_sym_1m (const char *name, gfc_isym_id id, enum klass cl, int actual_ok, bt t\n static void\n add_sym_2 (const char *name, gfc_isym_id id, enum klass cl, int actual_ok, bt type,\n \t   int kind, int standard,\n-\t   gfc_try (*check) (gfc_expr *, gfc_expr *),\n+\t   bool (*check) (gfc_expr *, gfc_expr *),\n \t   gfc_expr *(*simplify) (gfc_expr *, gfc_expr *),\n \t   void (*resolve) (gfc_expr *, gfc_expr *, gfc_expr *),\n \t   const char *a1, bt type1, int kind1, int optional1,\n@@ -515,7 +515,7 @@ add_sym_2 (const char *name, gfc_isym_id id, enum klass cl, int actual_ok, bt ty\n static void\n add_sym_2_intent (const char *name, gfc_isym_id id, enum klass cl,\n \t\t  int actual_ok, bt type, int kind, int standard,\n-\t\t  gfc_try (*check) (gfc_expr *, gfc_expr *),\n+\t\t  bool (*check) (gfc_expr *, gfc_expr *),\n \t\t  gfc_expr *(*simplify) (gfc_expr *, gfc_expr *),\n \t\t  void (*resolve) (gfc_expr *, gfc_expr *, gfc_expr *),\n \t\t  const char *a1, bt type1, int kind1, int optional1,\n@@ -543,7 +543,7 @@ add_sym_2_intent (const char *name, gfc_isym_id id, enum klass cl,\n static void\n add_sym_2s (const char *name, gfc_isym_id id, enum klass cl, bt type,\n \t    int kind, int standard,\n-\t    gfc_try (*check) (gfc_expr *, gfc_expr *),\n+\t    bool (*check) (gfc_expr *, gfc_expr *),\n \t    gfc_expr *(*simplify) (gfc_expr *, gfc_expr *),\n \t    void (*resolve) (gfc_code *),\n \t    const char *a1, bt type1, int kind1, int optional1,\n@@ -571,7 +571,7 @@ add_sym_2s (const char *name, gfc_isym_id id, enum klass cl, bt type,\n static void\n add_sym_3 (const char *name, gfc_isym_id id, enum klass cl, int actual_ok, bt type,\n \t   int kind, int standard,\n-\t   gfc_try (*check) (gfc_expr *, gfc_expr *, gfc_expr *),\n+\t   bool (*check) (gfc_expr *, gfc_expr *, gfc_expr *),\n \t   gfc_expr *(*simplify) (gfc_expr *, gfc_expr *, gfc_expr *),\n \t   void (*resolve) (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *),\n \t   const char *a1, bt type1, int kind1, int optional1,\n@@ -600,7 +600,7 @@ add_sym_3 (const char *name, gfc_isym_id id, enum klass cl, int actual_ok, bt ty\n static void\n add_sym_3ml (const char *name, gfc_isym_id id, enum klass cl, int actual_ok, bt type,\n \t     int kind, int standard,\n-\t     gfc_try (*check) (gfc_actual_arglist *),\n+\t     bool (*check) (gfc_actual_arglist *),\n \t     gfc_expr *(*simplify) (gfc_expr *, gfc_expr *, gfc_expr *),\n \t     void (*resolve) (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *),\n \t     const char *a1, bt type1, int kind1, int optional1,\n@@ -629,7 +629,7 @@ add_sym_3ml (const char *name, gfc_isym_id id, enum klass cl, int actual_ok, bt\n static void\n add_sym_3red (const char *name, gfc_isym_id id, enum klass cl, int actual_ok, bt type,\n \t      int kind, int standard,\n-\t      gfc_try (*check) (gfc_actual_arglist *),\n+\t      bool (*check) (gfc_actual_arglist *),\n \t      gfc_expr *(*simplify) (gfc_expr *, gfc_expr *, gfc_expr *),\n \t      void (*resolve) (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *),\n \t      const char *a1, bt type1, int kind1, int optional1,\n@@ -658,7 +658,7 @@ add_sym_3red (const char *name, gfc_isym_id id, enum klass cl, int actual_ok, bt\n static void\n add_sym_3s (const char *name, gfc_isym_id id, enum klass cl, bt type,\n \t    int kind, int standard,\n-\t    gfc_try (*check) (gfc_expr *, gfc_expr *, gfc_expr *),\n+\t    bool (*check) (gfc_expr *, gfc_expr *, gfc_expr *),\n \t    gfc_expr *(*simplify) (gfc_expr *, gfc_expr *, gfc_expr *),\n \t    void (*resolve) (gfc_code *),\n \t    const char *a1, bt type1, int kind1, int optional1,\n@@ -688,7 +688,7 @@ add_sym_3s (const char *name, gfc_isym_id id, enum klass cl, bt type,\n static void\n add_sym_4 (const char *name, gfc_isym_id id, enum klass cl, int actual_ok, bt type,\n \t   int kind, int standard,\n-\t   gfc_try (*check) (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *),\n+\t   bool (*check) (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *),\n \t   gfc_expr *(*simplify) (gfc_expr *, gfc_expr *, gfc_expr *,\n \t\t\t\t  gfc_expr *),\n \t   void (*resolve) (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *,\n@@ -721,7 +721,7 @@ add_sym_4 (const char *name, gfc_isym_id id, enum klass cl, int actual_ok, bt ty\n static void\n add_sym_4s (const char *name, gfc_isym_id id, enum klass cl, bt type, int kind,\n \t    int standard,\n-\t    gfc_try (*check) (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *),\n+\t    bool (*check) (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *),\n \t    gfc_expr *(*simplify) (gfc_expr *, gfc_expr *, gfc_expr *,\n \t\t\t\t   gfc_expr *),\n \t    void (*resolve) (gfc_code *),\n@@ -754,7 +754,7 @@ add_sym_4s (const char *name, gfc_isym_id id, enum klass cl, bt type, int kind,\n static void\n add_sym_5s (const char *name, gfc_isym_id id, enum klass cl, bt type, int kind,\n \t    int standard,\n-\t    gfc_try (*check) (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *,\n+\t    bool (*check) (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *,\n \t\t\t  gfc_expr *),\n \t    gfc_expr *(*simplify) (gfc_expr *, gfc_expr *, gfc_expr *,\n \t\t\t\t   gfc_expr *, gfc_expr *),\n@@ -981,7 +981,7 @@ gfc_is_intrinsic (gfc_symbol* sym, int subroutine_flag, locus loc)\n     return false;\n \n   /* See if this intrinsic is allowed in the current standard.  */\n-  if (gfc_check_intrinsic_standard (isym, &symstd, false, loc) == FAILURE)\n+  if (!gfc_check_intrinsic_standard (isym, &symstd, false, loc))\n     {\n       if (sym->attr.proc == PROC_UNKNOWN\n \t  && gfc_option.warn_intrinsics_std)\n@@ -3574,9 +3574,9 @@ remove_nullargs (gfc_actual_arglist **ap)\n    with the format arglist.  Arguments that are not present are given\n    a blank gfc_actual_arglist structure.  If something is obviously\n    wrong (say, a missing required argument) we abort sorting and\n-   return FAILURE.  */\n+   return false.  */\n \n-static gfc_try\n+static bool\n sort_actual (const char *name, gfc_actual_arglist **ap,\n \t     gfc_intrinsic_arg *formal, locus *where)\n {\n@@ -3593,7 +3593,7 @@ sort_actual (const char *name, gfc_actual_arglist **ap,\n   a = actual;\n \n   if (f == NULL && a == NULL)\t/* No arguments */\n-    return SUCCESS;\n+    return true;\n \n   for (;;)\n     {\t\t/* Put the nonkeyword arguments in a 1:1 correspondence */\n@@ -3615,7 +3615,7 @@ sort_actual (const char *name, gfc_actual_arglist **ap,\n     goto do_sort;\n \n   gfc_error (\"Too many arguments in call to '%s' at %L\", name, where);\n-  return FAILURE;\n+  return false;\n \n keywords:\n   /* Associate the remaining actual arguments, all of which have\n@@ -3634,14 +3634,14 @@ sort_actual (const char *name, gfc_actual_arglist **ap,\n \t  else\n \t    gfc_error (\"Can't find keyword named '%s' in call to '%s' at %L\",\n \t\t       a->name, name, where);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n \n       if (f->actual != NULL)\n \t{\n \t  gfc_error (\"Argument '%s' appears twice in call to '%s' at %L\",\n \t\t     f->name, name, where);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n \n       f->actual = a;\n@@ -3655,7 +3655,7 @@ sort_actual (const char *name, gfc_actual_arglist **ap,\n \t{\n \t  gfc_error (\"Missing actual argument '%s' in call to '%s' at %L\",\n \t\t     f->name, name, where);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n     }\n \n@@ -3669,7 +3669,7 @@ sort_actual (const char *name, gfc_actual_arglist **ap,\n       if (f->actual && f->actual->label != NULL && f->ts.type)\n \t{\n \t  gfc_error (\"ALTERNATE RETURN not permitted at %L\", where);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n \n       if (f->actual == NULL)\n@@ -3689,15 +3689,15 @@ sort_actual (const char *name, gfc_actual_arglist **ap,\n     }\n   actual->next = NULL;\t\t/* End the sorted argument list.  */\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n /* Compare an actual argument list with an intrinsic's formal argument\n    list.  The lists are checked for agreement of type.  We don't check\n    for arrayness here.  */\n \n-static gfc_try\n+static bool\n check_arglist (gfc_actual_arglist **ap, gfc_intrinsic_sym *sym,\n \t       int error_flag)\n {\n@@ -3730,7 +3730,7 @@ check_arglist (gfc_actual_arglist **ap, gfc_intrinsic_sym *sym,\n \t\t       gfc_current_intrinsic, &actual->expr->where,\n \t\t       gfc_typename (&formal->ts),\n \t\t       gfc_typename (&actual->expr->ts));\n-\t  return FAILURE;\n+\t  return false;\n \t}\n \n       /* If the formal argument is INTENT([IN]OUT), check for definability.  */\n@@ -3741,13 +3741,12 @@ check_arglist (gfc_actual_arglist **ap, gfc_intrinsic_sym *sym,\n \t\t\t\t : NULL);\n \n \t  /* No pointer arguments for intrinsics.  */\n-\t  if (gfc_check_vardef_context (actual->expr, false, false, false,\n-\t\t\t\t\tcontext) == FAILURE)\n-\t    return FAILURE;\n+\t  if (!gfc_check_vardef_context (actual->expr, false, false, false, context))\n+\t    return false;\n \t}\n     }\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n@@ -3838,11 +3837,11 @@ resolve_intrinsic (gfc_intrinsic_sym *specific, gfc_expr *e)\n \n /* Given an intrinsic symbol node and an expression node, call the\n    simplification function (if there is one), perhaps replacing the\n-   expression with something simpler.  We return FAILURE on an error\n-   of the simplification, SUCCESS if the simplification worked, even\n+   expression with something simpler.  We return false on an error\n+   of the simplification, true if the simplification worked, even\n    if nothing has changed in the expression itself.  */\n \n-static gfc_try\n+static bool\n do_simplify (gfc_intrinsic_sym *specific, gfc_expr *e)\n {\n   gfc_expr *result, *a1, *a2, *a3, *a4, *a5;\n@@ -3926,7 +3925,7 @@ do_simplify (gfc_intrinsic_sym *specific, gfc_expr *e)\n \n finish:\n   if (result == &gfc_bad_expr)\n-    return FAILURE;\n+    return false;\n \n   if (result == NULL)\n     resolve_intrinsic (specific, e);\t/* Must call at run-time */\n@@ -3936,12 +3935,12 @@ do_simplify (gfc_intrinsic_sym *specific, gfc_expr *e)\n       gfc_replace_expr (e, result);\n     }\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n /* Initialize the gfc_current_intrinsic_arg[] array for the benefit of\n-   error messages.  This subroutine returns FAILURE if a subroutine\n+   error messages.  This subroutine returns false if a subroutine\n    has more than MAX_INTRINSIC_ARGS, in which case the actual argument\n    list cannot match any intrinsic.  */\n \n@@ -3965,14 +3964,14 @@ init_arglist (gfc_intrinsic_sym *isym)\n \n /* Given a pointer to an intrinsic symbol and an expression consisting\n    of a function call, see if the function call is consistent with the\n-   intrinsic's formal argument list.  Return SUCCESS if the expression\n-   and intrinsic match, FAILURE otherwise.  */\n+   intrinsic's formal argument list.  Return true if the expression\n+   and intrinsic match, false otherwise.  */\n \n-static gfc_try\n+static bool\n check_specific (gfc_intrinsic_sym *specific, gfc_expr *expr, int error_flag)\n {\n   gfc_actual_arglist *arg, **ap;\n-  gfc_try t;\n+  bool t;\n \n   ap = &expr->value.function.actual;\n \n@@ -3985,9 +3984,8 @@ check_specific (gfc_intrinsic_sym *specific, gfc_expr *expr, int error_flag)\n       || specific->check.f1m == gfc_check_min_max_double)\n     return (*specific->check.f1m) (*ap);\n \n-  if (sort_actual (specific->name, ap, specific->formal,\n-\t\t   &expr->where) == FAILURE)\n-    return FAILURE;\n+  if (!sort_actual (specific->name, ap, specific->formal, &expr->where))\n+    return false;\n \n   if (specific->check.f3ml == gfc_check_minloc_maxloc)\n     /* This is special because we might have to reorder the argument list.  */\n@@ -4008,15 +4006,15 @@ check_specific (gfc_intrinsic_sym *specific, gfc_expr *expr, int error_flag)\n        if (specific->check.f1 == NULL)\n \t {\n \t   t = check_arglist (ap, specific, error_flag);\n-\t   if (t == SUCCESS)\n+\t   if (t)\n \t     expr->ts = specific->ts;\n \t }\n        else\n \t t = do_check (specific, *ap);\n      }\n \n   /* Check conformance of elemental intrinsics.  */\n-  if (t == SUCCESS && specific->elemental)\n+  if (t && specific->elemental)\n     {\n       int n = 0;\n       gfc_expr *first_expr;\n@@ -4027,16 +4025,16 @@ check_specific (gfc_intrinsic_sym *specific, gfc_expr *expr, int error_flag)\n       first_expr = arg->expr;\n \n       for ( ; arg && arg->expr; arg = arg->next, n++)\n-\tif (gfc_check_conformance (first_expr, arg->expr,\n-\t\t\t\t   \"arguments '%s' and '%s' for \"\n-\t\t\t\t   \"intrinsic '%s'\",\n-\t\t\t\t   gfc_current_intrinsic_arg[0]->name,\n-\t\t\t\t   gfc_current_intrinsic_arg[n]->name,\n-\t\t\t\t   gfc_current_intrinsic) == FAILURE)\n-\t  return FAILURE;\n+\tif (!gfc_check_conformance (first_expr, arg->expr, \n+\t\t\t\t    \"arguments '%s' and '%s' for \"\n+\t\t\t\t    \"intrinsic '%s'\", \n+\t\t\t\t    gfc_current_intrinsic_arg[0]->name, \n+\t\t\t\t    gfc_current_intrinsic_arg[n]->name, \n+\t\t\t\t    gfc_current_intrinsic))\n+\t  return false;\n     }\n \n-  if (t == FAILURE)\n+  if (!t)\n     remove_nullargs (ap);\n \n   return t;\n@@ -4049,17 +4047,17 @@ check_specific (gfc_intrinsic_sym *specific, gfc_expr *expr, int error_flag)\n    textual representation of the symbols standard status (like\n    \"new in Fortran 2008\", \"a GNU extension\" or \"obsolescent in Fortran 95\") that\n    can be used to construct a detailed warning/error message in case of\n-   a FAILURE.  */\n+   a false.  */\n \n-gfc_try\n+bool\n gfc_check_intrinsic_standard (const gfc_intrinsic_sym* isym,\n \t\t\t      const char** symstd, bool silent, locus where)\n {\n   const char* symstd_msg;\n \n   /* For -fall-intrinsics, just succeed.  */\n   if (gfc_option.flag_all_intrinsics)\n-    return SUCCESS;\n+    return true;\n \n   /* Find the symbol's standard message for later usage.  */\n   switch (isym->standard)\n@@ -4113,17 +4111,17 @@ gfc_check_intrinsic_standard (const gfc_intrinsic_sym* isym,\n \tgfc_warning (\"Intrinsic '%s' (is %s) is used at %L\",\n \t\t     isym->name, _(symstd_msg), &where);\n \n-      return SUCCESS;\n+      return true;\n     }\n \n   /* If allowing the symbol's standard, succeed, too.  */\n   if (gfc_option.allow_std & isym->standard)\n-    return SUCCESS;\n+    return true;\n \n   /* Otherwise, fail.  */\n   if (symstd)\n     *symstd = _(symstd_msg);\n-  return FAILURE;\n+  return false;\n }\n \n \n@@ -4149,7 +4147,7 @@ gfc_intrinsic_func_interface (gfc_expr *expr, int error_flag)\n   int flag;\n \n   if (expr->value.function.isym != NULL)\n-    return (do_simplify (expr->value.function.isym, expr) == FAILURE)\n+    return (!do_simplify(expr->value.function.isym, expr))\n \t   ? MATCH_ERROR : MATCH_YES;\n \n   if (!error_flag)\n@@ -4181,9 +4179,8 @@ gfc_intrinsic_func_interface (gfc_expr *expr, int error_flag)\n   if ((isym->id == GFC_ISYM_REAL || isym->id == GFC_ISYM_DBLE\n        || isym->id == GFC_ISYM_CMPLX)\n       && gfc_init_expr_flag\n-      && gfc_notify_std (GFC_STD_F2003, \"Function '%s' \"\n-\t\t\t \"as initialization expression at %L\", name,\n-\t\t\t &expr->where) == FAILURE)\n+      && !gfc_notify_std (GFC_STD_F2003, \"Function '%s' as initialization \"\n+\t\t\t  \"expression at %L\", name, &expr->where))\n     {\n       if (!error_flag)\n \tgfc_pop_suppress_errors ();\n@@ -4197,7 +4194,7 @@ gfc_intrinsic_func_interface (gfc_expr *expr, int error_flag)\n     {\n       init_arglist (isym);\n \n-      if (isym->check.f1m (expr->value.function.actual) == SUCCESS)\n+      if (isym->check.f1m(expr->value.function.actual))\n \tgoto got_specific;\n \n       if (!error_flag)\n@@ -4218,7 +4215,7 @@ gfc_intrinsic_func_interface (gfc_expr *expr, int error_flag)\n \t{\n \t  if (specific == isym)\n \t    continue;\n-\t  if (check_specific (specific, expr, 0) == SUCCESS)\n+\t  if (check_specific (specific, expr, 0))\n \t    {\n \t      gfc_pop_suppress_errors ();\n \t      goto got_specific;\n@@ -4228,7 +4225,7 @@ gfc_intrinsic_func_interface (gfc_expr *expr, int error_flag)\n \n   gfc_pop_suppress_errors ();\n \n-  if (check_specific (isym, expr, error_flag) == FAILURE)\n+  if (!check_specific (isym, expr, error_flag))\n     {\n       if (!error_flag)\n \tgfc_pop_suppress_errors ();\n@@ -4244,7 +4241,7 @@ gfc_intrinsic_func_interface (gfc_expr *expr, int error_flag)\n   if (!error_flag)\n     gfc_pop_suppress_errors ();\n \n-  if (do_simplify (specific, expr) == FAILURE)\n+  if (!do_simplify (specific, expr))\n     return MATCH_ERROR;\n \n   /* F95, 7.1.6.1, Initialization expressions\n@@ -4257,9 +4254,9 @@ gfc_intrinsic_func_interface (gfc_expr *expr, int error_flag)\n            where each argument is an initialization expression  */\n \n   if (gfc_init_expr_flag && isym->elemental && flag\n-      && gfc_notify_std (GFC_STD_F2003, \"Elemental function \"\n-\t\t\t\"as initialization expression with non-integer/non-\"\n-\t\t        \"character arguments at %L\", &expr->where) == FAILURE)\n+      && !gfc_notify_std (GFC_STD_F2003, \"Elemental function as \"\n+\t\t\t  \"initialization expression with non-integer/non-\"\n+\t\t\t  \"character arguments at %L\", &expr->where))\n     return MATCH_ERROR;\n \n   return MATCH_YES;\n@@ -4295,17 +4292,17 @@ gfc_intrinsic_sub_interface (gfc_code *c, int error_flag)\n \n   init_arglist (isym);\n \n-  if (sort_actual (name, &c->ext.actual, isym->formal, &c->loc) == FAILURE)\n+  if (!sort_actual (name, &c->ext.actual, isym->formal, &c->loc))\n     goto fail;\n \n   if (isym->check.f1 != NULL)\n     {\n-      if (do_check (isym, c->ext.actual) == FAILURE)\n+      if (!do_check (isym, c->ext.actual))\n \tgoto fail;\n     }\n   else\n     {\n-      if (check_arglist (&c->ext.actual, isym, 1) == FAILURE)\n+      if (!check_arglist (&c->ext.actual, isym, 1))\n \tgoto fail;\n     }\n \n@@ -4343,7 +4340,7 @@ gfc_intrinsic_sub_interface (gfc_code *c, int error_flag)\n \n /* Call gfc_convert_type() with warning enabled.  */\n \n-gfc_try\n+bool\n gfc_convert_type (gfc_expr *expr, gfc_typespec *ts, int eflag)\n {\n   return gfc_convert_type_warn (expr, ts, eflag, 1);\n@@ -4360,7 +4357,7 @@ gfc_convert_type (gfc_expr *expr, gfc_typespec *ts, int eflag)\n \n    'wflag' controls the warning related to conversion.  */\n \n-gfc_try\n+bool\n gfc_convert_type_warn (gfc_expr *expr, gfc_typespec *ts, int eflag, int wflag)\n {\n   gfc_intrinsic_sym *sym;\n@@ -4381,15 +4378,15 @@ gfc_convert_type_warn (gfc_expr *expr, gfc_typespec *ts, int eflag, int wflag)\n     {\n       /* Sometimes the RHS acquire the type.  */\n       expr->ts = *ts;\n-      return SUCCESS;\n+      return true;\n     }\n \n   if (expr->ts.type == BT_UNKNOWN)\n     goto bad;\n \n   if (expr->ts.type == BT_DERIVED && ts->type == BT_DERIVED\n       && gfc_compare_types (&expr->ts, ts))\n-    return SUCCESS;\n+    return true;\n \n   sym = find_conv (&expr->ts, ts);\n   if (sym == NULL)\n@@ -4499,22 +4496,22 @@ gfc_convert_type_warn (gfc_expr *expr, gfc_typespec *ts, int eflag, int wflag)\n   expr->ts = *ts;\n \n   if (gfc_is_constant_expr (expr->value.function.actual->expr)\n-      && do_simplify (sym, expr) == FAILURE)\n+      && !do_simplify (sym, expr))\n     {\n \n       if (eflag == 2)\n \tgoto bad;\n-      return FAILURE;\t\t/* Error already generated in do_simplify() */\n+      return false;\t\t/* Error already generated in do_simplify() */\n     }\n \n-  return SUCCESS;\n+  return true;\n \n bad:\n   if (eflag == 1)\n     {\n       gfc_error (\"Can't convert %s to %s at %L\",\n \t\t gfc_typename (&from_ts), gfc_typename (ts), &expr->where);\n-      return FAILURE;\n+      return false;\n     }\n \n   gfc_internal_error (\"Can't convert %s to %s at %L\",\n@@ -4524,7 +4521,7 @@ gfc_convert_type_warn (gfc_expr *expr, gfc_typespec *ts, int eflag, int wflag)\n }\n \n \n-gfc_try\n+bool\n gfc_convert_chartype (gfc_expr *expr, gfc_typespec *ts)\n {\n   gfc_intrinsic_sym *sym;\n@@ -4568,13 +4565,13 @@ gfc_convert_chartype (gfc_expr *expr, gfc_typespec *ts)\n   expr->ts = *ts;\n \n   if (gfc_is_constant_expr (expr->value.function.actual->expr)\n-      && do_simplify (sym, expr) == FAILURE)\n+      && !do_simplify (sym, expr))\n     {\n       /* Error already generated in do_simplify() */\n-      return FAILURE;\n+      return false;\n     }\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n@@ -4600,8 +4597,8 @@ gfc_warn_intrinsic_shadow (const gfc_symbol* sym, bool in_module, bool func)\n \n   /* If no intrinsic was found with this name or it's not included in the\n      selected standard, everything's fine.  */\n-  if (!isym || gfc_check_intrinsic_standard (isym, NULL, true,\n-\t\t\t\t\t     sym->declared_at) == FAILURE)\n+  if (!isym || !gfc_check_intrinsic_standard (isym, NULL, true, \n+\t\t\t\t\t      sym->declared_at))\n     return;\n \n   /* Emit the warning.  */"}, {"sha": "363bf3877162134b1a4568aa5f0dbe43fa427590", "filename": "gcc/fortran/intrinsic.h", "status": "modified", "additions": 184, "deletions": 184, "changes": 368, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Fintrinsic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Fintrinsic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.h?ref=524af0d6c72031c249aa737945fde6ac3d726ba2", "patch": "@@ -25,195 +25,195 @@ extern gfc_expr gfc_bad_expr;\n \n \n /* Check functions.  */\n-gfc_try gfc_check_a_ikind (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_a_xkind (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_a_p (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_x_yd (gfc_expr *, gfc_expr *);\n+bool gfc_check_a_ikind (gfc_expr *, gfc_expr *);\n+bool gfc_check_a_xkind (gfc_expr *, gfc_expr *);\n+bool gfc_check_a_p (gfc_expr *, gfc_expr *);\n+bool gfc_check_x_yd (gfc_expr *, gfc_expr *);\n \n-gfc_try gfc_check_abs (gfc_expr *);\n-gfc_try gfc_check_access_func (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_achar (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_all_any (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_allocated (gfc_expr *);\n-gfc_try gfc_check_associated (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_atan_2 (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_atan2 (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_atomic_def (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_atomic_ref (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_besn (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_bessel_n2 (gfc_expr *, gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_bge_bgt_ble_blt (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_bitfcn (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_char (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_chdir (gfc_expr *);\n-gfc_try gfc_check_chmod (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_cmplx (gfc_expr *, gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_complex (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_count (gfc_expr *, gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_cshift (gfc_expr *, gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_ctime (gfc_expr *);\n-gfc_try gfc_check_datan2 (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_dcmplx (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_dble (gfc_expr *);\n-gfc_try gfc_check_digits (gfc_expr *);\n-gfc_try gfc_check_dot_product (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_dprod (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_dshift (gfc_expr *, gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_eoshift (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_dtime_etime (gfc_expr *);\n-gfc_try gfc_check_fgetputc (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_fgetput (gfc_expr *);\n-gfc_try gfc_check_float (gfc_expr *);\n-gfc_try gfc_check_fstat (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_ftell (gfc_expr *);\n-gfc_try gfc_check_fn_c (gfc_expr *);\n-gfc_try gfc_check_fn_d (gfc_expr *);\n-gfc_try gfc_check_fn_r (gfc_expr *);\n-gfc_try gfc_check_fn_rc (gfc_expr *);\n-gfc_try gfc_check_fn_rc2008 (gfc_expr *);\n-gfc_try gfc_check_fnum (gfc_expr *);\n-gfc_try gfc_check_hostnm (gfc_expr *);\n-gfc_try gfc_check_huge (gfc_expr *);\n-gfc_try gfc_check_hypot (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_i (gfc_expr *);\n-gfc_try gfc_check_iand (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_and (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_ibits (gfc_expr *, gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_ichar_iachar (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_idnint (gfc_expr *);\n-gfc_try gfc_check_ieor (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_index (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_int (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_intconv (gfc_expr *);\n-gfc_try gfc_check_ior (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_irand (gfc_expr *);\n-gfc_try gfc_check_isatty (gfc_expr *);\n-gfc_try gfc_check_isnan (gfc_expr *);\n-gfc_try gfc_check_ishft (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_ishftc (gfc_expr *, gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_kill (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_kind (gfc_expr *);\n-gfc_try gfc_check_lbound (gfc_expr *, gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_lcobound (gfc_expr *, gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_len_lentrim (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_link (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_lge_lgt_lle_llt (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_loc (gfc_expr *);\n-gfc_try gfc_check_logical (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_min_max (gfc_actual_arglist *);\n-gfc_try gfc_check_min_max_integer (gfc_actual_arglist *);\n-gfc_try gfc_check_min_max_real (gfc_actual_arglist *);\n-gfc_try gfc_check_min_max_double (gfc_actual_arglist *);\n-gfc_try gfc_check_malloc (gfc_expr *);\n-gfc_try gfc_check_mask (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_matmul (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_merge (gfc_expr *, gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_merge_bits (gfc_expr *, gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_minloc_maxloc (gfc_actual_arglist *);\n-gfc_try gfc_check_minval_maxval (gfc_actual_arglist *);\n-gfc_try gfc_check_nearest (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_new_line (gfc_expr *);\n-gfc_try gfc_check_norm2 (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_null (gfc_expr *);\n-gfc_try gfc_check_pack (gfc_expr *, gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_parity (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_precision (gfc_expr *);\n-gfc_try gfc_check_present (gfc_expr *);\n-gfc_try gfc_check_product_sum (gfc_actual_arglist *);\n-gfc_try gfc_check_radix (gfc_expr *);\n-gfc_try gfc_check_rand (gfc_expr *);\n-gfc_try gfc_check_range (gfc_expr *);\n-gfc_try gfc_check_rank (gfc_expr *);\n-gfc_try gfc_check_real (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_rename (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_repeat (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_reshape (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_same_type_as (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_scale (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_scan (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_second_sub (gfc_expr *);\n-gfc_try gfc_check_secnds (gfc_expr *);\n-gfc_try gfc_check_selected_char_kind (gfc_expr *);\n-gfc_try gfc_check_selected_int_kind (gfc_expr *);\n-gfc_try gfc_check_selected_real_kind (gfc_expr *, gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_set_exponent (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_shape (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_shift (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_size (gfc_expr *, gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_sign (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_signal (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_sizeof (gfc_expr *);\n-gfc_try gfc_check_c_associated (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_c_f_pointer (gfc_expr *, gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_c_f_procpointer (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_c_funloc (gfc_expr *);\n-gfc_try gfc_check_c_loc (gfc_expr *);\n-gfc_try gfc_check_c_sizeof (gfc_expr *);\n-gfc_try gfc_check_sngl (gfc_expr *);\n-gfc_try gfc_check_spread (gfc_expr *, gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_srand (gfc_expr *);\n-gfc_try gfc_check_stat (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_storage_size (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_sum (gfc_expr *, gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_symlnk (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_transf_bit_intrins (gfc_actual_arglist *);\n-gfc_try gfc_check_transfer (gfc_expr *, gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_transpose (gfc_expr *);\n-gfc_try gfc_check_trim (gfc_expr *);\n-gfc_try gfc_check_ttynam (gfc_expr *);\n-gfc_try gfc_check_ubound (gfc_expr *, gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_ucobound (gfc_expr *, gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_umask (gfc_expr *);\n-gfc_try gfc_check_unlink (gfc_expr *);\n-gfc_try gfc_check_unpack (gfc_expr *, gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_verify (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_x (gfc_expr *);\n+bool gfc_check_abs (gfc_expr *);\n+bool gfc_check_access_func (gfc_expr *, gfc_expr *);\n+bool gfc_check_achar (gfc_expr *, gfc_expr *);\n+bool gfc_check_all_any (gfc_expr *, gfc_expr *);\n+bool gfc_check_allocated (gfc_expr *);\n+bool gfc_check_associated (gfc_expr *, gfc_expr *);\n+bool gfc_check_atan_2 (gfc_expr *, gfc_expr *);\n+bool gfc_check_atan2 (gfc_expr *, gfc_expr *);\n+bool gfc_check_atomic_def (gfc_expr *, gfc_expr *);\n+bool gfc_check_atomic_ref (gfc_expr *, gfc_expr *);\n+bool gfc_check_besn (gfc_expr *, gfc_expr *);\n+bool gfc_check_bessel_n2 (gfc_expr *, gfc_expr *, gfc_expr *);\n+bool gfc_check_bge_bgt_ble_blt (gfc_expr *, gfc_expr *);\n+bool gfc_check_bitfcn (gfc_expr *, gfc_expr *);\n+bool gfc_check_char (gfc_expr *, gfc_expr *);\n+bool gfc_check_chdir (gfc_expr *);\n+bool gfc_check_chmod (gfc_expr *, gfc_expr *);\n+bool gfc_check_cmplx (gfc_expr *, gfc_expr *, gfc_expr *);\n+bool gfc_check_complex (gfc_expr *, gfc_expr *);\n+bool gfc_check_count (gfc_expr *, gfc_expr *, gfc_expr *);\n+bool gfc_check_cshift (gfc_expr *, gfc_expr *, gfc_expr *);\n+bool gfc_check_ctime (gfc_expr *);\n+bool gfc_check_datan2 (gfc_expr *, gfc_expr *);\n+bool gfc_check_dcmplx (gfc_expr *, gfc_expr *);\n+bool gfc_check_dble (gfc_expr *);\n+bool gfc_check_digits (gfc_expr *);\n+bool gfc_check_dot_product (gfc_expr *, gfc_expr *);\n+bool gfc_check_dprod (gfc_expr *, gfc_expr *);\n+bool gfc_check_dshift (gfc_expr *, gfc_expr *, gfc_expr *);\n+bool gfc_check_eoshift (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n+bool gfc_check_dtime_etime (gfc_expr *);\n+bool gfc_check_fgetputc (gfc_expr *, gfc_expr *);\n+bool gfc_check_fgetput (gfc_expr *);\n+bool gfc_check_float (gfc_expr *);\n+bool gfc_check_fstat (gfc_expr *, gfc_expr *);\n+bool gfc_check_ftell (gfc_expr *);\n+bool gfc_check_fn_c (gfc_expr *);\n+bool gfc_check_fn_d (gfc_expr *);\n+bool gfc_check_fn_r (gfc_expr *);\n+bool gfc_check_fn_rc (gfc_expr *);\n+bool gfc_check_fn_rc2008 (gfc_expr *);\n+bool gfc_check_fnum (gfc_expr *);\n+bool gfc_check_hostnm (gfc_expr *);\n+bool gfc_check_huge (gfc_expr *);\n+bool gfc_check_hypot (gfc_expr *, gfc_expr *);\n+bool gfc_check_i (gfc_expr *);\n+bool gfc_check_iand (gfc_expr *, gfc_expr *);\n+bool gfc_check_and (gfc_expr *, gfc_expr *);\n+bool gfc_check_ibits (gfc_expr *, gfc_expr *, gfc_expr *);\n+bool gfc_check_ichar_iachar (gfc_expr *, gfc_expr *);\n+bool gfc_check_idnint (gfc_expr *);\n+bool gfc_check_ieor (gfc_expr *, gfc_expr *);\n+bool gfc_check_index (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n+bool gfc_check_int (gfc_expr *, gfc_expr *);\n+bool gfc_check_intconv (gfc_expr *);\n+bool gfc_check_ior (gfc_expr *, gfc_expr *);\n+bool gfc_check_irand (gfc_expr *);\n+bool gfc_check_isatty (gfc_expr *);\n+bool gfc_check_isnan (gfc_expr *);\n+bool gfc_check_ishft (gfc_expr *, gfc_expr *);\n+bool gfc_check_ishftc (gfc_expr *, gfc_expr *, gfc_expr *);\n+bool gfc_check_kill (gfc_expr *, gfc_expr *);\n+bool gfc_check_kind (gfc_expr *);\n+bool gfc_check_lbound (gfc_expr *, gfc_expr *, gfc_expr *);\n+bool gfc_check_lcobound (gfc_expr *, gfc_expr *, gfc_expr *);\n+bool gfc_check_len_lentrim (gfc_expr *, gfc_expr *);\n+bool gfc_check_link (gfc_expr *, gfc_expr *);\n+bool gfc_check_lge_lgt_lle_llt (gfc_expr *, gfc_expr *);\n+bool gfc_check_loc (gfc_expr *);\n+bool gfc_check_logical (gfc_expr *, gfc_expr *);\n+bool gfc_check_min_max (gfc_actual_arglist *);\n+bool gfc_check_min_max_integer (gfc_actual_arglist *);\n+bool gfc_check_min_max_real (gfc_actual_arglist *);\n+bool gfc_check_min_max_double (gfc_actual_arglist *);\n+bool gfc_check_malloc (gfc_expr *);\n+bool gfc_check_mask (gfc_expr *, gfc_expr *);\n+bool gfc_check_matmul (gfc_expr *, gfc_expr *);\n+bool gfc_check_merge (gfc_expr *, gfc_expr *, gfc_expr *);\n+bool gfc_check_merge_bits (gfc_expr *, gfc_expr *, gfc_expr *);\n+bool gfc_check_minloc_maxloc (gfc_actual_arglist *);\n+bool gfc_check_minval_maxval (gfc_actual_arglist *);\n+bool gfc_check_nearest (gfc_expr *, gfc_expr *);\n+bool gfc_check_new_line (gfc_expr *);\n+bool gfc_check_norm2 (gfc_expr *, gfc_expr *);\n+bool gfc_check_null (gfc_expr *);\n+bool gfc_check_pack (gfc_expr *, gfc_expr *, gfc_expr *);\n+bool gfc_check_parity (gfc_expr *, gfc_expr *);\n+bool gfc_check_precision (gfc_expr *);\n+bool gfc_check_present (gfc_expr *);\n+bool gfc_check_product_sum (gfc_actual_arglist *);\n+bool gfc_check_radix (gfc_expr *);\n+bool gfc_check_rand (gfc_expr *);\n+bool gfc_check_range (gfc_expr *);\n+bool gfc_check_rank (gfc_expr *);\n+bool gfc_check_real (gfc_expr *, gfc_expr *);\n+bool gfc_check_rename (gfc_expr *, gfc_expr *);\n+bool gfc_check_repeat (gfc_expr *, gfc_expr *);\n+bool gfc_check_reshape (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n+bool gfc_check_same_type_as (gfc_expr *, gfc_expr *);\n+bool gfc_check_scale (gfc_expr *, gfc_expr *);\n+bool gfc_check_scan (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n+bool gfc_check_second_sub (gfc_expr *);\n+bool gfc_check_secnds (gfc_expr *);\n+bool gfc_check_selected_char_kind (gfc_expr *);\n+bool gfc_check_selected_int_kind (gfc_expr *);\n+bool gfc_check_selected_real_kind (gfc_expr *, gfc_expr *, gfc_expr *);\n+bool gfc_check_set_exponent (gfc_expr *, gfc_expr *);\n+bool gfc_check_shape (gfc_expr *, gfc_expr *);\n+bool gfc_check_shift (gfc_expr *, gfc_expr *);\n+bool gfc_check_size (gfc_expr *, gfc_expr *, gfc_expr *);\n+bool gfc_check_sign (gfc_expr *, gfc_expr *);\n+bool gfc_check_signal (gfc_expr *, gfc_expr *);\n+bool gfc_check_sizeof (gfc_expr *);\n+bool gfc_check_c_associated (gfc_expr *, gfc_expr *);\n+bool gfc_check_c_f_pointer (gfc_expr *, gfc_expr *, gfc_expr *);\n+bool gfc_check_c_f_procpointer (gfc_expr *, gfc_expr *);\n+bool gfc_check_c_funloc (gfc_expr *);\n+bool gfc_check_c_loc (gfc_expr *);\n+bool gfc_check_c_sizeof (gfc_expr *);\n+bool gfc_check_sngl (gfc_expr *);\n+bool gfc_check_spread (gfc_expr *, gfc_expr *, gfc_expr *);\n+bool gfc_check_srand (gfc_expr *);\n+bool gfc_check_stat (gfc_expr *, gfc_expr *);\n+bool gfc_check_storage_size (gfc_expr *, gfc_expr *);\n+bool gfc_check_sum (gfc_expr *, gfc_expr *, gfc_expr *);\n+bool gfc_check_symlnk (gfc_expr *, gfc_expr *);\n+bool gfc_check_transf_bit_intrins (gfc_actual_arglist *);\n+bool gfc_check_transfer (gfc_expr *, gfc_expr *, gfc_expr *);\n+bool gfc_check_transpose (gfc_expr *);\n+bool gfc_check_trim (gfc_expr *);\n+bool gfc_check_ttynam (gfc_expr *);\n+bool gfc_check_ubound (gfc_expr *, gfc_expr *, gfc_expr *);\n+bool gfc_check_ucobound (gfc_expr *, gfc_expr *, gfc_expr *);\n+bool gfc_check_umask (gfc_expr *);\n+bool gfc_check_unlink (gfc_expr *);\n+bool gfc_check_unpack (gfc_expr *, gfc_expr *, gfc_expr *);\n+bool gfc_check_verify (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n+bool gfc_check_x (gfc_expr *);\n \n \n /* Intrinsic subroutines.  */\n-gfc_try gfc_check_alarm_sub (gfc_expr *, gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_chdir_sub (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_chmod_sub (gfc_expr *, gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_cpu_time (gfc_expr *);\n-gfc_try gfc_check_ctime_sub (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_system_clock (gfc_expr *, gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_date_and_time (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_exit (gfc_expr *);\n-gfc_try gfc_check_fdate_sub (gfc_expr *);\n-gfc_try gfc_check_flush (gfc_expr *);\n-gfc_try gfc_check_free (gfc_expr *);\n-gfc_try gfc_check_fstat_sub (gfc_expr *, gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_gerror (gfc_expr *);\n-gfc_try gfc_check_getarg (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_getlog (gfc_expr *);\n-gfc_try gfc_check_move_alloc (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_mvbits (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *,\n+bool gfc_check_alarm_sub (gfc_expr *, gfc_expr *, gfc_expr *);\n+bool gfc_check_chdir_sub (gfc_expr *, gfc_expr *);\n+bool gfc_check_chmod_sub (gfc_expr *, gfc_expr *, gfc_expr *);\n+bool gfc_check_cpu_time (gfc_expr *);\n+bool gfc_check_ctime_sub (gfc_expr *, gfc_expr *);\n+bool gfc_check_system_clock (gfc_expr *, gfc_expr *, gfc_expr *);\n+bool gfc_check_date_and_time (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n+bool gfc_check_exit (gfc_expr *);\n+bool gfc_check_fdate_sub (gfc_expr *);\n+bool gfc_check_flush (gfc_expr *);\n+bool gfc_check_free (gfc_expr *);\n+bool gfc_check_fstat_sub (gfc_expr *, gfc_expr *, gfc_expr *);\n+bool gfc_check_gerror (gfc_expr *);\n+bool gfc_check_getarg (gfc_expr *, gfc_expr *);\n+bool gfc_check_getlog (gfc_expr *);\n+bool gfc_check_move_alloc (gfc_expr *, gfc_expr *);\n+bool gfc_check_mvbits (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *,\n \t\t      gfc_expr *);\n-gfc_try gfc_check_random_number (gfc_expr *);\n-gfc_try gfc_check_random_seed (gfc_expr *, gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_dtime_etime_sub (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_fgetputc_sub (gfc_expr *, gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_fgetput_sub (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_fseek_sub (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_ftell_sub (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_getcwd_sub (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_hostnm_sub (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_image_index (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_itime_idate (gfc_expr *);\n-gfc_try gfc_check_kill_sub (gfc_expr *, gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_ltime_gmtime (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_perror (gfc_expr *);\n-gfc_try gfc_check_rename_sub (gfc_expr *, gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_link_sub (gfc_expr *, gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_symlnk_sub (gfc_expr *, gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_signal_sub (gfc_expr *, gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_sleep_sub (gfc_expr *);\n-gfc_try gfc_check_stat_sub (gfc_expr *, gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_system_sub (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_this_image (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_ttynam_sub (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_umask_sub (gfc_expr *, gfc_expr *);\n-gfc_try gfc_check_unlink_sub (gfc_expr *, gfc_expr *);\n+bool gfc_check_random_number (gfc_expr *);\n+bool gfc_check_random_seed (gfc_expr *, gfc_expr *, gfc_expr *);\n+bool gfc_check_dtime_etime_sub (gfc_expr *, gfc_expr *);\n+bool gfc_check_fgetputc_sub (gfc_expr *, gfc_expr *, gfc_expr *);\n+bool gfc_check_fgetput_sub (gfc_expr *, gfc_expr *);\n+bool gfc_check_fseek_sub (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n+bool gfc_check_ftell_sub (gfc_expr *, gfc_expr *);\n+bool gfc_check_getcwd_sub (gfc_expr *, gfc_expr *);\n+bool gfc_check_hostnm_sub (gfc_expr *, gfc_expr *);\n+bool gfc_check_image_index (gfc_expr *, gfc_expr *);\n+bool gfc_check_itime_idate (gfc_expr *);\n+bool gfc_check_kill_sub (gfc_expr *, gfc_expr *, gfc_expr *);\n+bool gfc_check_ltime_gmtime (gfc_expr *, gfc_expr *);\n+bool gfc_check_perror (gfc_expr *);\n+bool gfc_check_rename_sub (gfc_expr *, gfc_expr *, gfc_expr *);\n+bool gfc_check_link_sub (gfc_expr *, gfc_expr *, gfc_expr *);\n+bool gfc_check_symlnk_sub (gfc_expr *, gfc_expr *, gfc_expr *);\n+bool gfc_check_signal_sub (gfc_expr *, gfc_expr *, gfc_expr *);\n+bool gfc_check_sleep_sub (gfc_expr *);\n+bool gfc_check_stat_sub (gfc_expr *, gfc_expr *, gfc_expr *);\n+bool gfc_check_system_sub (gfc_expr *, gfc_expr *);\n+bool gfc_check_this_image (gfc_expr *, gfc_expr *);\n+bool gfc_check_ttynam_sub (gfc_expr *, gfc_expr *);\n+bool gfc_check_umask_sub (gfc_expr *, gfc_expr *);\n+bool gfc_check_unlink_sub (gfc_expr *, gfc_expr *);\n \n \n /* Simplification functions.  */"}, {"sha": "c5120dd78b104ddf40432932b454647ea98bc4ed", "filename": "gcc/fortran/io.c", "status": "modified", "additions": 153, "deletions": 164, "changes": 317, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Fio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Fio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fio.c?ref=524af0d6c72031c249aa737945fde6ac3d726ba2", "patch": "@@ -100,7 +100,7 @@ static const io_tag\n \n static gfc_dt *current_dt;\n \n-#define RESOLVE_TAG(x, y) if (resolve_tag(x, y) == FAILURE) return FAILURE;\n+#define RESOLVE_TAG(x, y) if (!resolve_tag (x, y)) return false;\n \n \n /**************** Fortran 95 FORMAT parser  *****************/\n@@ -452,15 +452,15 @@ format_lex (void)\n       c = next_char_not_space (&error);\n       if (c == 'P')\n \t{\n-\t  if (gfc_notify_std (GFC_STD_F2003, \"DP format \"\n-\t      \"specifier not allowed at %C\") == FAILURE)\n+\t  if (!gfc_notify_std (GFC_STD_F2003, \"DP format \"\n+\t\t\t       \"specifier not allowed at %C\"))\n \t    return FMT_ERROR;\n \t  token = FMT_DP;\n \t}\n       else if (c == 'C')\n \t{\n-\t  if (gfc_notify_std (GFC_STD_F2003, \"DC format \"\n-\t      \"specifier not allowed at %C\") == FAILURE)\n+\t  if (!gfc_notify_std (GFC_STD_F2003, \"DC format \"\n+\t\t\t       \"specifier not allowed at %C\"))\n \t    return FMT_ERROR;\n \t  token = FMT_DC;\n \t}\n@@ -545,7 +545,7 @@ token_to_string (format_token t)\n    by itself, and we are checking it for validity.  The dual origin\n    means that the warning message is a little less than great.  */\n \n-static gfc_try\n+static bool\n check_format (bool is_input)\n {\n   const char *posint_required\t  = _(\"Positive width required\");\n@@ -559,13 +559,13 @@ check_format (bool is_input)\n   format_token t, u;\n   int level;\n   int repeat;\n-  gfc_try rv;\n+  bool rv;\n \n   use_last_char = 0;\n   saved_token = FMT_NONE;\n   level = 0;\n   repeat = 0;\n-  rv = SUCCESS;\n+  rv = true;\n   format_string_pos = 0;\n \n   t = format_lex ();\n@@ -648,10 +648,9 @@ check_format (bool is_input)\n       /* X requires a prior number if we're being pedantic.  */\n       if (mode != MODE_FORMAT)\n \tformat_locus.nextc += format_string_pos;\n-      if (gfc_notify_std (GFC_STD_GNU, \"X descriptor \"\n-\t\t\t  \"requires leading space count at %L\", &format_locus)\n-\t  == FAILURE)\n-\treturn FAILURE;\n+      if (!gfc_notify_std (GFC_STD_GNU, \"X descriptor requires leading \"\n+\t\t\t   \"space count at %L\", &format_locus))\n+\treturn false;\n       goto between_desc;\n \n     case FMT_SIGN:\n@@ -678,9 +677,8 @@ check_format (bool is_input)\n       if (t == FMT_ERROR)\n \tgoto fail;\n \n-      if (gfc_notify_std (GFC_STD_GNU, \"$ descriptor at %L\",\n-\t  &format_locus) == FAILURE)\n-\treturn FAILURE;\n+      if (!gfc_notify_std (GFC_STD_GNU, \"$ descriptor at %L\", &format_locus))\n+\treturn false;\n       if (t != FMT_RPAREN || level > 0)\n \t{\n \t  gfc_warning (\"$ should be the last specifier in format at %L\",\n@@ -825,9 +823,9 @@ check_format (bool is_input)\n \t      error = zero_width;\n \t      goto syntax;\n \t    }\n-\t  if (gfc_notify_std (GFC_STD_F2008, \"'G0' in \"\n-\t\t\t      \"format at %L\", &format_locus) == FAILURE)\n-\t    return FAILURE;\n+\t  if (!gfc_notify_std (GFC_STD_F2008, \"'G0' in format at %L\", \n+\t\t\t       &format_locus))\n+\t    return false;\n \t  u = format_lex ();\n \t  if (u != FMT_PERIOD)\n \t    {\n@@ -1058,9 +1056,8 @@ check_format (bool is_input)\n     default:\n       if (mode != MODE_FORMAT)\n \tformat_locus.nextc += format_string_pos - 1;\n-      if (gfc_notify_std (GFC_STD_GNU, \"Missing comma at %L\",\n-\t  &format_locus) == FAILURE)\n-\treturn FAILURE;\n+      if (!gfc_notify_std (GFC_STD_GNU, \"Missing comma at %L\", &format_locus))\n+\treturn false;\n       /* If we do not actually return a failure, we need to unwind this\n          before the next round.  */\n       if (mode != MODE_FORMAT)\n@@ -1121,9 +1118,8 @@ check_format (bool is_input)\n     default:\n       if (mode != MODE_FORMAT)\n \tformat_locus.nextc += format_string_pos;\n-      if (gfc_notify_std (GFC_STD_GNU, \"Missing comma at %L\",\n-\t  &format_locus) == FAILURE)\n-\treturn FAILURE;\n+      if (!gfc_notify_std (GFC_STD_GNU, \"Missing comma at %L\", &format_locus))\n+\treturn false;\n       /* If we do not actually return a failure, we need to unwind this\n          before the next round.  */\n       if (mode != MODE_FORMAT)\n@@ -1142,7 +1138,7 @@ check_format (bool is_input)\n   else\n     gfc_error (\"%s in format string at %L\", error, &format_locus);\n fail:\n-  rv = FAILURE;\n+  rv = false;\n \n finished:\n   return rv;\n@@ -1152,13 +1148,13 @@ check_format (bool is_input)\n /* Given an expression node that is a constant string, see if it looks\n    like a format string.  */\n \n-static gfc_try\n+static bool\n check_format_string (gfc_expr *e, bool is_input)\n {\n-  gfc_try rv;\n+  bool rv;\n   int i;\n   if (!e || e->ts.type != BT_CHARACTER || e->expr_type != EXPR_CONSTANT)\n-    return SUCCESS;\n+    return true;\n \n   mode = MODE_STRING;\n   format_string = e->value.character.string;\n@@ -1172,7 +1168,7 @@ check_format_string (gfc_expr *e, bool is_input)\n      string, like '(A10,I3)F5'\n      start at the end and move back to the last character processed,\n      spaces are OK */\n-  if (rv == SUCCESS && e->value.character.length > format_string_pos)\n+  if (rv && e->value.character.length > format_string_pos)\n     for (i=e->value.character.length-1;i>format_string_pos-1;i--)\n       if (e->value.character.string[i] != ' ')\n         {\n@@ -1215,7 +1211,7 @@ gfc_match_format (void)\n \n   start = gfc_current_locus;\n \n-  if (check_format (false) == FAILURE)\n+  if (!check_format (false))\n     return MATCH_ERROR;\n \n   if (gfc_match_eos () != MATCH_YES)\n@@ -1366,7 +1362,7 @@ match_ltag (const io_tag *tag, gfc_st_label ** label)\n       return MATCH_ERROR;\n     }\n \n-  if (gfc_reference_st_label (*label, ST_LABEL_TARGET) == FAILURE)\n+  if (!gfc_reference_st_label (*label, ST_LABEL_TARGET))\n     return MATCH_ERROR;\n \n   return m;\n@@ -1375,7 +1371,7 @@ match_ltag (const io_tag *tag, gfc_st_label ** label)\n \n /* Resolution of the FORMAT tag, to be called from resolve_tag.  */\n \n-static gfc_try\n+static bool\n resolve_tag_format (const gfc_expr *e)\n {\n   if (e->expr_type == EXPR_CONSTANT\n@@ -1384,7 +1380,7 @@ resolve_tag_format (const gfc_expr *e)\n     {\n       gfc_error (\"Constant expression in FORMAT tag at %L must be \"\n \t\t \"of type default CHARACTER\", &e->where);\n-      return FAILURE;\n+      return false;\n     }\n \n   /* If e's rank is zero and e is not an element of an array, it should be\n@@ -1402,75 +1398,74 @@ resolve_tag_format (const gfc_expr *e)\n \t{\n \t  gfc_error (\"FORMAT tag at %L must be of type default-kind CHARACTER \"\n \t\t     \"or of INTEGER\", &e->where);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n       else if (e->ts.type == BT_INTEGER && e->expr_type == EXPR_VARIABLE)\n \t{\n-\t  if (gfc_notify_std (GFC_STD_F95_DEL, \"ASSIGNED \"\n-\t\t\t      \"variable in FORMAT tag at %L\", &e->where)\n-\t      == FAILURE)\n-\t    return FAILURE;\n+\t  if (!gfc_notify_std (GFC_STD_F95_DEL, \"ASSIGNED variable in \"\n+\t\t\t       \"FORMAT tag at %L\", &e->where))\n+\t    return false;\n \t  if (e->symtree->n.sym->attr.assign != 1)\n \t    {\n \t      gfc_error (\"Variable '%s' at %L has not been assigned a \"\n \t\t\t \"format label\", e->symtree->n.sym->name, &e->where);\n-\t      return FAILURE;\n+\t      return false;\n \t    }\n \t}\n       else if (e->ts.type == BT_INTEGER)\n \t{\n \t  gfc_error (\"Scalar '%s' in FORMAT tag at %L is not an ASSIGNED \"\n \t\t     \"variable\", gfc_basic_typename (e->ts.type), &e->where);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n \n-      return SUCCESS;\n+      return true;\n     }\n \n   /* If rank is nonzero and type is not character, we allow it under GFC_STD_LEGACY.\n      It may be assigned an Hollerith constant.  */\n   if (e->ts.type != BT_CHARACTER)\n     {\n-      if (gfc_notify_std (GFC_STD_LEGACY, \"Non-character \"\n-\t\t\t  \"in FORMAT tag at %L\", &e->where) == FAILURE)\n-\treturn FAILURE;\n+      if (!gfc_notify_std (GFC_STD_LEGACY, \"Non-character in FORMAT tag \"\n+\t\t\t   \"at %L\", &e->where))\n+\treturn false;\n \n       if (e->rank == 0 && e->symtree->n.sym->as->type == AS_ASSUMED_SHAPE)\n \t{\n \t  gfc_error (\"Non-character assumed shape array element in FORMAT\"\n \t\t     \" tag at %L\", &e->where);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n \n       if (e->rank == 0 && e->symtree->n.sym->as->type == AS_ASSUMED_SIZE)\n \t{\n \t  gfc_error (\"Non-character assumed size array element in FORMAT\"\n \t\t     \" tag at %L\", &e->where);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n \n       if (e->rank == 0 && e->symtree->n.sym->attr.pointer)\n \t{\n \t  gfc_error (\"Non-character pointer array element in FORMAT tag at %L\",\n \t\t     &e->where);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n     }\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n /* Do expression resolution and type-checking on an expression tag.  */\n \n-static gfc_try\n+static bool\n resolve_tag (const io_tag *tag, gfc_expr *e)\n {\n   if (e == NULL)\n-    return SUCCESS;\n+    return true;\n \n-  if (gfc_resolve_expr (e) == FAILURE)\n-    return FAILURE;\n+  if (!gfc_resolve_expr (e))\n+    return false;\n \n   if (tag == &tag_format)\n     return resolve_tag_format (e);\n@@ -1479,51 +1474,48 @@ resolve_tag (const io_tag *tag, gfc_expr *e)\n     {\n       gfc_error (\"%s tag at %L must be of type %s\", tag->name,\n \t\t &e->where, gfc_basic_typename (tag->type));\n-      return FAILURE;\n+      return false;\n     }\n \n   if (e->ts.type == BT_CHARACTER && e->ts.kind != gfc_default_character_kind)\n     {\n       gfc_error (\"%s tag at %L must be a character string of default kind\",\n \t\t tag->name, &e->where);\n-      return FAILURE;\n+      return false;\n     }\n \n   if (e->rank != 0)\n     {\n       gfc_error (\"%s tag at %L must be scalar\", tag->name, &e->where);\n-      return FAILURE;\n+      return false;\n     }\n \n   if (tag == &tag_iomsg)\n     {\n-      if (gfc_notify_std (GFC_STD_F2003, \"IOMSG tag at %L\",\n-\t\t\t  &e->where) == FAILURE)\n-\treturn FAILURE;\n+      if (!gfc_notify_std (GFC_STD_F2003, \"IOMSG tag at %L\", &e->where))\n+\treturn false;\n     }\n \n   if ((tag == &tag_iostat || tag == &tag_size || tag == &tag_iolength)\n       && e->ts.kind != gfc_default_integer_kind)\n     {\n-      if (gfc_notify_std (GFC_STD_F2003, \"Fortran 95 requires default \"\n-\t\t\t  \"INTEGER in %s tag at %L\", tag->name, &e->where)\n-\t  == FAILURE)\n-\treturn FAILURE;\n+      if (!gfc_notify_std (GFC_STD_F2003, \"Fortran 95 requires default \"\n+\t\t\t   \"INTEGER in %s tag at %L\", tag->name, &e->where))\n+\treturn false;\n     }\n \n   if (tag == &tag_exist && e->ts.kind != gfc_default_logical_kind)\n     {\n-      if (gfc_notify_std (GFC_STD_F2008, \"Nondefault LOGICAL \"\n-\t\t\t  \"in %s tag at %L\", tag->name, &e->where)\n-\t  == FAILURE)\n-\treturn FAILURE;\n+      if (!gfc_notify_std (GFC_STD_F2008, \"Nondefault LOGICAL \"\n+\t\t\t   \"in %s tag at %L\", tag->name, &e->where))\n+\treturn false;\n     }\n \n   if (tag == &tag_newunit)\n     {\n-      if (gfc_notify_std (GFC_STD_F2008, \"NEWUNIT specifier\"\n-\t\t\t  \" at %L\", &e->where) == FAILURE)\n-\treturn FAILURE;\n+      if (!gfc_notify_std (GFC_STD_F2008, \"NEWUNIT specifier at %L\", \n+\t\t\t   &e->where))\n+\treturn false;\n     }\n \n   /* NEWUNIT, IOSTAT, SIZE and IOMSG are variable definition contexts.  */\n@@ -1533,18 +1525,17 @@ resolve_tag (const io_tag *tag, gfc_expr *e)\n       char context[64];\n \n       sprintf (context, _(\"%s tag\"), tag->name);\n-      if (gfc_check_vardef_context (e, false, false, false, context) == FAILURE)\n-\treturn FAILURE;\n+      if (!gfc_check_vardef_context (e, false, false, false, context))\n+\treturn false;\n     }\n   \n   if (tag == &tag_convert)\n     {\n-      if (gfc_notify_std (GFC_STD_GNU, \"CONVERT tag at %L\",\n-\t\t\t  &e->where) == FAILURE)\n-\treturn FAILURE;\n+      if (!gfc_notify_std (GFC_STD_GNU, \"CONVERT tag at %L\", &e->where))\n+\treturn false;\n     }\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n@@ -1657,7 +1648,7 @@ gfc_free_open (gfc_open *open)\n \n /* Resolve everything in a gfc_open structure.  */\n \n-gfc_try\n+bool\n gfc_resolve_open (gfc_open *open)\n {\n \n@@ -1682,10 +1673,10 @@ gfc_resolve_open (gfc_open *open)\n   RESOLVE_TAG (&tag_convert, open->convert);\n   RESOLVE_TAG (&tag_newunit, open->newunit);\n \n-  if (gfc_reference_st_label (open->err, ST_LABEL_TARGET) == FAILURE)\n-    return FAILURE;\n+  if (!gfc_reference_st_label (open->err, ST_LABEL_TARGET))\n+    return false;\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n@@ -1895,8 +1886,8 @@ gfc_match_open (void)\n   /* Checks on the ASYNCHRONOUS specifier.  */\n   if (open->asynchronous)\n     {\n-      if (gfc_notify_std (GFC_STD_F2003, \"ASYNCHRONOUS= at %C \"\n-\t  \"not allowed in Fortran 95\") == FAILURE)\n+      if (!gfc_notify_std (GFC_STD_F2003, \"ASYNCHRONOUS= at %C \"\n+\t\t\t   \"not allowed in Fortran 95\"))\n \tgoto cleanup;\n \n       if (open->asynchronous->expr_type == EXPR_CONSTANT)\n@@ -1913,8 +1904,8 @@ gfc_match_open (void)\n   /* Checks on the BLANK specifier.  */\n   if (open->blank)\n     {\n-      if (gfc_notify_std (GFC_STD_F2003, \"BLANK= at %C \"\n-\t  \"not allowed in Fortran 95\") == FAILURE)\n+      if (!gfc_notify_std (GFC_STD_F2003, \"BLANK= at %C \"\n+\t\t\t   \"not allowed in Fortran 95\"))\n \tgoto cleanup;\n \n       if (open->blank->expr_type == EXPR_CONSTANT)\n@@ -1931,8 +1922,8 @@ gfc_match_open (void)\n   /* Checks on the DECIMAL specifier.  */\n   if (open->decimal)\n     {\n-      if (gfc_notify_std (GFC_STD_F2003, \"DECIMAL= at %C \"\n-\t  \"not allowed in Fortran 95\") == FAILURE)\n+      if (!gfc_notify_std (GFC_STD_F2003, \"DECIMAL= at %C \"\n+\t\t\t   \"not allowed in Fortran 95\"))\n \tgoto cleanup;\n \n       if (open->decimal->expr_type == EXPR_CONSTANT)\n@@ -1963,8 +1954,8 @@ gfc_match_open (void)\n   /* Checks on the ENCODING specifier.  */\n   if (open->encoding)\n     {\n-      if (gfc_notify_std (GFC_STD_F2003, \"ENCODING= at %C \"\n-\t  \"not allowed in Fortran 95\") == FAILURE)\n+      if (!gfc_notify_std (GFC_STD_F2003, \"ENCODING= at %C \"\n+\t\t\t   \"not allowed in Fortran 95\"))\n \tgoto cleanup;\n     \n       if (open->encoding->expr_type == EXPR_CONSTANT)\n@@ -2014,8 +2005,8 @@ gfc_match_open (void)\n   /* Checks on the ROUND specifier.  */\n   if (open->round)\n     {\n-      if (gfc_notify_std (GFC_STD_F2003, \"ROUND= at %C \"\n-\t  \"not allowed in Fortran 95\") == FAILURE)\n+      if (!gfc_notify_std (GFC_STD_F2003, \"ROUND= at %C \"\n+\t\t\t   \"not allowed in Fortran 95\"))\n       goto cleanup;\n \n       if (open->round->expr_type == EXPR_CONSTANT)\n@@ -2034,8 +2025,8 @@ gfc_match_open (void)\n   /* Checks on the SIGN specifier.  */\n   if (open->sign) \n     {\n-      if (gfc_notify_std (GFC_STD_F2003, \"SIGN= at %C \"\n-\t  \"not allowed in Fortran 95\") == FAILURE)\n+      if (!gfc_notify_std (GFC_STD_F2003, \"SIGN= at %C \"\n+\t\t\t   \"not allowed in Fortran 95\"))\n \tgoto cleanup;\n \n       if (open->sign->expr_type == EXPR_CONSTANT)\n@@ -2282,16 +2273,16 @@ gfc_match_close (void)\n \n /* Resolve everything in a gfc_close structure.  */\n \n-gfc_try\n+bool\n gfc_resolve_close (gfc_close *close)\n {\n   RESOLVE_TAG (&tag_unit, close->unit);\n   RESOLVE_TAG (&tag_iomsg, close->iomsg);\n   RESOLVE_TAG (&tag_iostat, close->iostat);\n   RESOLVE_TAG (&tag_status, close->status);\n \n-  if (gfc_reference_st_label (close->err, ST_LABEL_TARGET) == FAILURE)\n-    return FAILURE;\n+  if (!gfc_reference_st_label (close->err, ST_LABEL_TARGET))\n+    return false;\n \n   if (close->unit == NULL)\n     {\n@@ -2308,7 +2299,7 @@ gfc_resolve_close (gfc_close *close)\n \tloc = close->err->where;\n \n       gfc_error (\"CLOSE statement at %L requires a UNIT number\", &loc);\n-      return FAILURE;\n+      return false;\n     }\n \n   if (close->unit->expr_type == EXPR_CONSTANT\n@@ -2319,7 +2310,7 @@ gfc_resolve_close (gfc_close *close)\n \t\t &close->unit->where);\n     }\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n@@ -2435,14 +2426,14 @@ match_filepos (gfc_statement st, gfc_exec_op op)\n }\n \n \n-gfc_try\n+bool\n gfc_resolve_filepos (gfc_filepos *fp)\n {\n   RESOLVE_TAG (&tag_unit, fp->unit);\n   RESOLVE_TAG (&tag_iostat, fp->iostat);\n   RESOLVE_TAG (&tag_iomsg, fp->iomsg);\n-  if (gfc_reference_st_label (fp->err, ST_LABEL_TARGET) == FAILURE)\n-    return FAILURE;\n+  if (!gfc_reference_st_label (fp->err, ST_LABEL_TARGET))\n+    return false;\n \n   if (fp->unit->expr_type == EXPR_CONSTANT\n       && fp->unit->ts.type == BT_INTEGER\n@@ -2452,7 +2443,7 @@ gfc_resolve_filepos (gfc_filepos *fp)\n \t\t &fp->unit->where);\n     }\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n@@ -2480,8 +2471,7 @@ gfc_match_rewind (void)\n match\n gfc_match_flush (void)\n {\n-  if (gfc_notify_std (GFC_STD_F2003, \"FLUSH statement at %C\")\n-      == FAILURE)\n+  if (!gfc_notify_std (GFC_STD_F2003, \"FLUSH statement at %C\"))\n     return MATCH_ERROR;\n \n   return match_filepos (ST_FLUSH, EXEC_FLUSH);\n@@ -2583,7 +2573,7 @@ match_dt_format (gfc_dt *dt)\n \t      goto conflict;\n \t    }\n \n-\t  if (gfc_reference_st_label (label, ST_LABEL_FORMAT) == FAILURE)\n+\t  if (!gfc_reference_st_label (label, ST_LABEL_FORMAT))\n \t    return MATCH_ERROR;\n \n \t  dt->format_label = label;\n@@ -2785,7 +2775,7 @@ gfc_free_dt (gfc_dt *dt)\n \n /* Resolve everything in a gfc_dt structure.  */\n \n-gfc_try\n+bool\n gfc_resolve_dt (gfc_dt *dt, locus *loc)\n {\n   gfc_expr *e;\n@@ -2815,10 +2805,10 @@ gfc_resolve_dt (gfc_dt *dt, locus *loc)\n   if (e == NULL)\n     {\n       gfc_error (\"UNIT not specified at %L\", loc);\n-      return FAILURE;\n+      return false;\n     }\n \n-  if (gfc_resolve_expr (e) == SUCCESS\n+  if (gfc_resolve_expr (e)\n       && (e->ts.type != BT_INTEGER\n \t  && (e->ts.type != BT_CHARACTER || e->expr_type != EXPR_VARIABLE)))\n     {\n@@ -2828,7 +2818,7 @@ gfc_resolve_dt (gfc_dt *dt, locus *loc)\n \t{\n \t  gfc_error (\"UNIT specification at %L must be an INTEGER expression \"\n \t\t     \"or a CHARACTER variable\", &e->where);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n       else\n \t{\n@@ -2850,7 +2840,7 @@ gfc_resolve_dt (gfc_dt *dt, locus *loc)\n \t    {\n \t      gfc_error (\"Invalid form of WRITE statement at %L, UNIT required\",\n \t\t\t &dt->extra_comma->where);\n-\t      return FAILURE;\n+\t      return false;\n \t    }\n \t}\n     }\n@@ -2860,29 +2850,29 @@ gfc_resolve_dt (gfc_dt *dt, locus *loc)\n       if (gfc_has_vector_index (e))\n \t{\n \t  gfc_error (\"Internal unit with vector subscript at %L\", &e->where);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n \n       /* If we are writing, make sure the internal unit can be changed.  */\n       gcc_assert (k != M_PRINT);\n       if (k == M_WRITE\n-\t  && gfc_check_vardef_context (e, false, false, false,\n-\t\t\t\t       _(\"internal unit in WRITE\")) == FAILURE)\n-\treturn FAILURE;\n+\t  && !gfc_check_vardef_context (e, false, false, false, \n+\t\t\t\t\t_(\"internal unit in WRITE\")))\n+\treturn false;\n     }\n \n   if (e->rank && e->ts.type != BT_CHARACTER)\n     {\n       gfc_error (\"External IO UNIT cannot be an array at %L\", &e->where);\n-      return FAILURE;\n+      return false;\n     }\n \n   if (e->expr_type == EXPR_CONSTANT && e->ts.type == BT_INTEGER\n       && mpz_sgn (e->value.integer) < 0)\n     {\n       gfc_error (\"UNIT number in statement at %L must be non-negative\",\n \t\t &e->where);\n-      return FAILURE;\n+      return false;\n     }\n \n   /* If we are reading and have a namelist, check that all namelist symbols\n@@ -2893,61 +2883,61 @@ gfc_resolve_dt (gfc_dt *dt, locus *loc)\n       for (n = dt->namelist->namelist; n; n = n->next)\n \t{\n \t  gfc_expr* e;\n-\t  gfc_try t;\n+\t  bool t;\n \n \t  e = gfc_get_variable_expr (gfc_find_sym_in_symtree (n->sym));\n \t  t = gfc_check_vardef_context (e, false, false, false, NULL);\n \t  gfc_free_expr (e);\n \n-\t  if (t == FAILURE)\n+\t  if (!t)\n \t    {\n \t      gfc_error (\"NAMELIST '%s' in READ statement at %L contains\"\n \t\t\t \" the symbol '%s' which may not appear in a\"\n \t\t\t \" variable definition context\",\n \t\t\t dt->namelist->name, loc, n->sym->name);\n-\t      return FAILURE;\n+\t      return false;\n \t    }\n \t}\n     }\n \n   if (dt->extra_comma\n-      && gfc_notify_std (GFC_STD_GNU, \"Comma before i/o \"\n-\t\t\t \"item list at %L\", &dt->extra_comma->where) == FAILURE)\n-    return FAILURE;\n+      && !gfc_notify_std (GFC_STD_GNU, \"Comma before i/o item list at %L\", \n+\t\t\t  &dt->extra_comma->where))\n+    return false;\n \n   if (dt->err)\n     {\n-      if (gfc_reference_st_label (dt->err, ST_LABEL_TARGET) == FAILURE)\n-\treturn FAILURE;\n+      if (!gfc_reference_st_label (dt->err, ST_LABEL_TARGET))\n+\treturn false;\n       if (dt->err->defined == ST_LABEL_UNKNOWN)\n \t{\n \t  gfc_error (\"ERR tag label %d at %L not defined\",\n \t\t      dt->err->value, &dt->err_where);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n     }\n \n   if (dt->end)\n     {\n-      if (gfc_reference_st_label (dt->end, ST_LABEL_TARGET) == FAILURE)\n-\treturn FAILURE;\n+      if (!gfc_reference_st_label (dt->end, ST_LABEL_TARGET))\n+\treturn false;\n       if (dt->end->defined == ST_LABEL_UNKNOWN)\n \t{\n \t  gfc_error (\"END tag label %d at %L not defined\",\n \t\t      dt->end->value, &dt->end_where);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n     }\n \n   if (dt->eor)\n     {\n-      if (gfc_reference_st_label (dt->eor, ST_LABEL_TARGET) == FAILURE)\n-\treturn FAILURE;\n+      if (!gfc_reference_st_label (dt->eor, ST_LABEL_TARGET))\n+\treturn false;\n       if (dt->eor->defined == ST_LABEL_UNKNOWN)\n \t{\n \t  gfc_error (\"EOR tag label %d at %L not defined\",\n \t\t      dt->eor->value, &dt->eor_where);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n     }\n \n@@ -2957,10 +2947,10 @@ gfc_resolve_dt (gfc_dt *dt, locus *loc)\n     {\n       gfc_error (\"FORMAT label %d at %L not defined\", dt->format_label->value,\n \t\t &dt->format_label->where);\n-      return FAILURE;\n+      return false;\n     }\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n@@ -3257,9 +3247,8 @@ if (condition) \\\n \n       if (dt->namelist != NULL)\n \t{\n-\t  if (gfc_notify_std (GFC_STD_F2003, \"Internal file \"\n-\t\t\t      \"at %L with namelist\", &expr->where)\n-\t      == FAILURE)\n+\t  if (!gfc_notify_std (GFC_STD_F2003, \"Internal file at %L with \"\n+\t\t\t       \"namelist\", &expr->where))\n \t    m = MATCH_ERROR;\n \t}\n \n@@ -3313,7 +3302,7 @@ if (condition) \\\n     {\n       static const char * asynchronous[] = { \"YES\", \"NO\", NULL };\n \n-      if (gfc_reduce_init_expr (dt->asynchronous) != SUCCESS)\n+      if (!gfc_reduce_init_expr (dt->asynchronous))\n \t{\n \t  gfc_error (\"ASYNCHRONOUS= specifier at %L must be an initialization \"\n \t\t     \"expression\", &dt->asynchronous->where);\n@@ -3341,8 +3330,8 @@ if (condition) \\\n \n   if (dt->decimal)\n     {\n-      if (gfc_notify_std (GFC_STD_F2003, \"DECIMAL= at %C \"\n-\t  \"not allowed in Fortran 95\") == FAILURE)\n+      if (!gfc_notify_std (GFC_STD_F2003, \"DECIMAL= at %C \"\n+\t\t\t   \"not allowed in Fortran 95\"))\n \treturn MATCH_ERROR;\n \n       if (dt->decimal->expr_type == EXPR_CONSTANT)\n@@ -3362,8 +3351,8 @@ if (condition) \\\n   \n   if (dt->blank)\n     {\n-      if (gfc_notify_std (GFC_STD_F2003, \"BLANK= at %C \"\n-\t  \"not allowed in Fortran 95\") == FAILURE)\n+      if (!gfc_notify_std (GFC_STD_F2003, \"BLANK= at %C \"\n+\t\t\t   \"not allowed in Fortran 95\"))\n \treturn MATCH_ERROR;\n \n       if (dt->blank->expr_type == EXPR_CONSTANT)\n@@ -3383,8 +3372,8 @@ if (condition) \\\n \n   if (dt->pad)\n     {\n-      if (gfc_notify_std (GFC_STD_F2003, \"PAD= at %C \"\n-\t  \"not allowed in Fortran 95\") == FAILURE)\n+      if (!gfc_notify_std (GFC_STD_F2003, \"PAD= at %C \"\n+\t\t\t   \"not allowed in Fortran 95\"))\n \treturn MATCH_ERROR;\n \n       if (dt->pad->expr_type == EXPR_CONSTANT)\n@@ -3404,8 +3393,8 @@ if (condition) \\\n \n   if (dt->round)\n     {\n-      if (gfc_notify_std (GFC_STD_F2003, \"ROUND= at %C \"\n-\t  \"not allowed in Fortran 95\") == FAILURE)\n+      if (!gfc_notify_std (GFC_STD_F2003, \"ROUND= at %C \"\n+\t\t\t   \"not allowed in Fortran 95\"))\n \treturn MATCH_ERROR;\n \n       if (dt->round->expr_type == EXPR_CONSTANT)\n@@ -3425,7 +3414,7 @@ if (condition) \\\n     {\n       /* When implemented, change the following to use gfc_notify_std F2003.\n       if (gfc_notify_std (GFC_STD_F2003, \"SIGN= at %C \"\n-\t  \"not allowed in Fortran 95\") == FAILURE)\n+\t  \"not allowed in Fortran 95\") == false)\n \treturn MATCH_ERROR;  */\n       if (dt->sign->expr_type == EXPR_CONSTANT)\n \t{\n@@ -3449,8 +3438,8 @@ if (condition) \\\n \n   if (dt->delim)\n     {\n-      if (gfc_notify_std (GFC_STD_F2003, \"DELIM= at %C \"\n-\t  \"not allowed in Fortran 95\") == FAILURE)\n+      if (!gfc_notify_std (GFC_STD_F2003, \"DELIM= at %C \"\n+\t\t\t   \"not allowed in Fortran 95\"))\n \treturn MATCH_ERROR;\n \n       if (dt->delim->expr_type == EXPR_CONSTANT)\n@@ -3557,8 +3546,8 @@ if (condition) \\\n     }\n \n   expr = dt->format_expr;\n-  if (gfc_simplify_expr (expr, 0) == FAILURE\n-      || check_format_string (expr, k == M_READ) == FAILURE)\n+  if (!gfc_simplify_expr (expr, 0)\n+      || !check_format_string (expr, k == M_READ))\n     return MATCH_ERROR;\n \n   return m;\n@@ -3598,8 +3587,8 @@ match_io (io_kind k)\n \t      gfc_find_symbol (name, NULL, 1, &sym);\n \t      if (sym && sym->attr.flavor == FL_NAMELIST)\n \t\t{\n-\t\t  if (gfc_notify_std (GFC_STD_GNU, \"PRINT namelist at \"\n-\t\t\t\t      \"%C is an extension\") == FAILURE)\n+\t\t  if (!gfc_notify_std (GFC_STD_GNU, \"PRINT namelist at \"\n+\t\t\t\t       \"%C is an extension\"))\n \t\t    {\n \t\t      m = MATCH_ERROR;\n \t\t      goto cleanup;\n@@ -4048,7 +4037,7 @@ gfc_match_inquire (void)\n \n /* Resolve everything in a gfc_inquire structure.  */\n \n-gfc_try\n+bool\n gfc_resolve_inquire (gfc_inquire *inquire)\n {\n   RESOLVE_TAG (&tag_unit, inquire->unit);\n@@ -4064,8 +4053,8 @@ gfc_resolve_inquire (gfc_inquire *inquire)\n       char context[64]; \\\n       sprintf (context, _(\"%s tag with INQUIRE\"), (tag)->name); \\\n       if (gfc_check_vardef_context ((expr), false, false, false, \\\n-\t\t\t\t    context) == FAILURE) \\\n-\treturn FAILURE; \\\n+\t\t\t\t    context) == false) \\\n+\treturn false; \\\n     }\n   INQUIRE_RESOLVE_TAG (&tag_iomsg, inquire->iomsg);\n   INQUIRE_RESOLVE_TAG (&tag_iostat, inquire->iostat);\n@@ -4104,10 +4093,10 @@ gfc_resolve_inquire (gfc_inquire *inquire)\n   INQUIRE_RESOLVE_TAG (&tag_s_iqstream, inquire->iqstream);\n #undef INQUIRE_RESOLVE_TAG\n \n-  if (gfc_reference_st_label (inquire->err, ST_LABEL_TARGET) == FAILURE)\n-    return FAILURE;\n+  if (!gfc_reference_st_label (inquire->err, ST_LABEL_TARGET))\n+    return false;\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n@@ -4125,21 +4114,21 @@ gfc_free_wait (gfc_wait *wait)\n }\n \n \n-gfc_try\n+bool\n gfc_resolve_wait (gfc_wait *wait)\n {\n   RESOLVE_TAG (&tag_unit, wait->unit);\n   RESOLVE_TAG (&tag_iomsg, wait->iomsg);\n   RESOLVE_TAG (&tag_iostat, wait->iostat);\n   RESOLVE_TAG (&tag_id, wait->id);\n \n-  if (gfc_reference_st_label (wait->err, ST_LABEL_TARGET) == FAILURE)\n-    return FAILURE;\n+  if (!gfc_reference_st_label (wait->err, ST_LABEL_TARGET))\n+    return false;\n   \n-  if (gfc_reference_st_label (wait->end, ST_LABEL_TARGET) == FAILURE)\n-    return FAILURE;\n+  if (!gfc_reference_st_label (wait->end, ST_LABEL_TARGET))\n+    return false;\n \n-  return SUCCESS;\n+  return true;\n }\n \n /* Match an element of a WAIT statement.  */\n@@ -4202,8 +4191,8 @@ gfc_match_wait (void)\n \tgoto syntax;\n     }\n \n-  if (gfc_notify_std (GFC_STD_F2003, \"WAIT at %C \"\n-\t  \"not allowed in Fortran 95\") == FAILURE)\n+  if (!gfc_notify_std (GFC_STD_F2003, \"WAIT at %C \"\n+\t\t       \"not allowed in Fortran 95\"))\n     goto cleanup;\n \n   if (gfc_pure (NULL))"}, {"sha": "a1529da51c5b27fbd3291e472c3f1a19232d2008", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 79, "deletions": 102, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=524af0d6c72031c249aa737945fde6ac3d726ba2", "patch": "@@ -505,8 +505,8 @@ gfc_match_label (void)\n       return MATCH_ERROR;\n     }\n \n-  if (gfc_add_flavor (&gfc_new_block->attr, FL_LABEL,\n-\t\t      gfc_new_block->name, NULL) == FAILURE)\n+  if (!gfc_add_flavor (&gfc_new_block->attr, FL_LABEL, \n+\t\t       gfc_new_block->name, NULL))\n     return MATCH_ERROR;\n \n   return MATCH_YES;\n@@ -531,7 +531,7 @@ gfc_match_name (char *buffer)\n   c = gfc_next_ascii_char ();\n   if (!(ISALPHA (c) || (c == '_' && gfc_option.flag_allow_leading_underscore)))\n     {\n-      if (gfc_error_flag_test() == 0 && c != '(')\n+      if (gfc_error_flag_test () == 0 && c != '(')\n \tgfc_error (\"Invalid character in name at %C\");\n       gfc_current_locus = old_loc;\n       return MATCH_NO;\n@@ -1268,7 +1268,7 @@ gfc_match_program (void)\n   if (m == MATCH_ERROR)\n     return m;\n \n-  if (gfc_add_flavor (&sym->attr, FL_PROGRAM, sym->name, NULL) == FAILURE)\n+  if (!gfc_add_flavor (&sym->attr, FL_PROGRAM, sym->name, NULL))\n     return MATCH_ERROR;\n \n   gfc_new_block = sym;\n@@ -1383,16 +1383,15 @@ match_arithmetic_if (void)\n   if (m != MATCH_YES)\n     return m;\n \n-  if (gfc_reference_st_label (l1, ST_LABEL_TARGET) == FAILURE\n-      || gfc_reference_st_label (l2, ST_LABEL_TARGET) == FAILURE\n-      || gfc_reference_st_label (l3, ST_LABEL_TARGET) == FAILURE)\n+  if (!gfc_reference_st_label (l1, ST_LABEL_TARGET)\n+      || !gfc_reference_st_label (l2, ST_LABEL_TARGET)\n+      || !gfc_reference_st_label (l3, ST_LABEL_TARGET))\n     {\n       gfc_free_expr (expr);\n       return MATCH_ERROR;\n     }\n \n-  if (gfc_notify_std (GFC_STD_F95_OBS, \"Arithmetic IF \"\n-\t\t      \"statement at %C\") == FAILURE)\n+  if (!gfc_notify_std (GFC_STD_F95_OBS, \"Arithmetic IF statement at %C\"))\n     return MATCH_ERROR;\n \n   new_st.op = EXEC_ARITHMETIC_IF;\n@@ -1464,16 +1463,15 @@ gfc_match_if (gfc_statement *if_type)\n \t  return MATCH_ERROR;\n \t}\n \n-      if (gfc_reference_st_label (l1, ST_LABEL_TARGET) == FAILURE\n-\t  || gfc_reference_st_label (l2, ST_LABEL_TARGET) == FAILURE\n-\t  || gfc_reference_st_label (l3, ST_LABEL_TARGET) == FAILURE)\n+      if (!gfc_reference_st_label (l1, ST_LABEL_TARGET)\n+\t  || !gfc_reference_st_label (l2, ST_LABEL_TARGET)\n+\t  || !gfc_reference_st_label (l3, ST_LABEL_TARGET))\n \t{\n \t  gfc_free_expr (expr);\n \t  return MATCH_ERROR;\n \t}\n \n-      if (gfc_notify_std (GFC_STD_F95_OBS, \"Arithmetic IF \"\n-\t\t\t  \"statement at %C\") == FAILURE)\n+      if (!gfc_notify_std (GFC_STD_F95_OBS, \"Arithmetic IF statement at %C\"))\n \treturn MATCH_ERROR;\n \n       new_st.op = EXEC_ARITHMETIC_IF;\n@@ -1539,7 +1537,7 @@ gfc_match_if (gfc_statement *if_type)\n      restore between tries.  */\n \n #define match(string, subr, statement) \\\n-  if (gfc_match(string) == MATCH_YES) { m = subr(); goto got_match; }\n+  if (gfc_match (string) == MATCH_YES) { m = subr(); goto got_match; }\n \n   gfc_clear_error ();\n \n@@ -1746,7 +1744,7 @@ gfc_match_critical (void)\n       return MATCH_ERROR;\n     }\n \n-  if (gfc_find_state (COMP_DO_CONCURRENT) == SUCCESS)\n+  if (gfc_find_state (COMP_DO_CONCURRENT))\n     {\n       gfc_error (\"Image control statement CRITICAL at %C in DO CONCURRENT \"\n \t\t \"block\");\n@@ -1756,8 +1754,7 @@ gfc_match_critical (void)\n   if (gfc_implicit_pure (NULL))\n     gfc_current_ns->proc_name->attr.implicit_pure = 0;\n \n-  if (gfc_notify_std (GFC_STD_F2008, \"CRITICAL statement at %C\")\n-      == FAILURE)\n+  if (!gfc_notify_std (GFC_STD_F2008, \"CRITICAL statement at %C\"))\n     return MATCH_ERROR;\n \n   if (gfc_option.coarray == GFC_FCOARRAY_NONE)\n@@ -1766,7 +1763,7 @@ gfc_match_critical (void)\n        return MATCH_ERROR;\n     }\n \n-  if (gfc_find_state (COMP_CRITICAL) == SUCCESS)\n+  if (gfc_find_state (COMP_CRITICAL))\n     {\n       gfc_error (\"Nested CRITICAL block at %C\");\n       return MATCH_ERROR;\n@@ -1775,7 +1772,7 @@ gfc_match_critical (void)\n   new_st.op = EXEC_CRITICAL;\n \n   if (label != NULL\n-      && gfc_reference_st_label (label, ST_LABEL_TARGET) == FAILURE)\n+      && !gfc_reference_st_label (label, ST_LABEL_TARGET))\n     return MATCH_ERROR;\n \n   return MATCH_YES;\n@@ -2380,8 +2377,7 @@ gfc_match_do (void)\n       gfc_forall_iterator *head;\n       gfc_expr *mask;\n \n-      if (gfc_notify_std (GFC_STD_F2008, \"DO CONCURRENT \"\n-\t\t\t   \"construct at %C\") == FAILURE)\n+      if (!gfc_notify_std (GFC_STD_F2008, \"DO CONCURRENT construct at %C\"))\n \treturn MATCH_ERROR;\n \n \n@@ -2398,7 +2394,7 @@ gfc_match_do (void)\n \tgoto concurr_cleanup;\n \n       if (label != NULL\n-\t   && gfc_reference_st_label (label, ST_LABEL_DO_TARGET) == FAILURE)\n+\t   && !gfc_reference_st_label (label, ST_LABEL_DO_TARGET))\n \tgoto concurr_cleanup;\n \n       new_st.label1 = label;\n@@ -2452,7 +2448,7 @@ gfc_match_do (void)\n \n done:\n   if (label != NULL\n-      && gfc_reference_st_label (label, ST_LABEL_DO_TARGET) == FAILURE)\n+      && !gfc_reference_st_label (label, ST_LABEL_DO_TARGET))\n     goto cleanup;\n \n   new_st.label1 = label;\n@@ -2579,8 +2575,8 @@ match_exit_cycle (gfc_statement st, gfc_exec_op op)\n \t  return MATCH_ERROR;\n \t}\n       gcc_assert (op == EXEC_EXIT);\n-      if (gfc_notify_std (GFC_STD_F2008, \"EXIT statement with no\"\n-\t\t\t  \" do-construct-name at %C\") == FAILURE)\n+      if (!gfc_notify_std (GFC_STD_F2008, \"EXIT statement with no\"\n+\t\t\t   \" do-construct-name at %C\"))\n \treturn MATCH_ERROR;\n       break;\n \n@@ -2686,12 +2682,12 @@ gfc_match_stopcode (gfc_statement st)\n   if (gfc_implicit_pure (NULL))\n     gfc_current_ns->proc_name->attr.implicit_pure = 0;\n \n-  if (st == ST_STOP && gfc_find_state (COMP_CRITICAL) == SUCCESS)\n+  if (st == ST_STOP && gfc_find_state (COMP_CRITICAL))\n     {\n       gfc_error (\"Image control statement STOP at %C in CRITICAL block\");\n       goto cleanup;\n     }\n-  if (st == ST_STOP && gfc_find_state (COMP_DO_CONCURRENT) == SUCCESS)\n+  if (st == ST_STOP && gfc_find_state (COMP_DO_CONCURRENT))\n     {\n       gfc_error (\"Image control statement STOP at %C in DO CONCURRENT block\");\n       goto cleanup;\n@@ -2770,9 +2766,7 @@ gfc_match_pause (void)\n   m = gfc_match_stopcode (ST_PAUSE);\n   if (m == MATCH_YES)\n     {\n-      if (gfc_notify_std (GFC_STD_F95_DEL, \"PAUSE statement\"\n-\t  \" at %C\")\n-\t  == FAILURE)\n+      if (!gfc_notify_std (GFC_STD_F95_DEL, \"PAUSE statement at %C\"))\n \tm = MATCH_ERROR;\n     }\n   return m;\n@@ -2793,8 +2787,7 @@ gfc_match_stop (void)\n match\n gfc_match_error_stop (void)\n {\n-  if (gfc_notify_std (GFC_STD_F2008, \"ERROR STOP statement at %C\")\n-      == FAILURE)\n+  if (!gfc_notify_std (GFC_STD_F2008, \"ERROR STOP statement at %C\"))\n     return MATCH_ERROR;\n \n   return gfc_match_stopcode (ST_ERROR_STOP);\n@@ -2833,14 +2826,14 @@ lock_unlock_statement (gfc_statement st)\n        return MATCH_ERROR;\n     }\n \n-  if (gfc_find_state (COMP_CRITICAL) == SUCCESS)\n+  if (gfc_find_state (COMP_CRITICAL))\n     {\n       gfc_error (\"Image control statement %s at %C in CRITICAL block\",\n \t\t st == ST_LOCK ? \"LOCK\" : \"UNLOCK\");\n       return MATCH_ERROR;\n     }\n \n-  if (gfc_find_state (COMP_DO_CONCURRENT) == SUCCESS)\n+  if (gfc_find_state (COMP_DO_CONCURRENT))\n     {\n       gfc_error (\"Image control statement %s at %C in DO CONCURRENT block\",\n \t\t st == ST_LOCK ? \"LOCK\" : \"UNLOCK\");\n@@ -2979,8 +2972,7 @@ lock_unlock_statement (gfc_statement st)\n match\n gfc_match_lock (void)\n {\n-  if (gfc_notify_std (GFC_STD_F2008, \"LOCK statement at %C\")\n-      == FAILURE)\n+  if (!gfc_notify_std (GFC_STD_F2008, \"LOCK statement at %C\"))\n     return MATCH_ERROR;\n \n   return lock_unlock_statement (ST_LOCK);\n@@ -2990,8 +2982,7 @@ gfc_match_lock (void)\n match\n gfc_match_unlock (void)\n {\n-  if (gfc_notify_std (GFC_STD_F2008, \"UNLOCK statement at %C\")\n-      == FAILURE)\n+  if (!gfc_notify_std (GFC_STD_F2008, \"UNLOCK statement at %C\"))\n     return MATCH_ERROR;\n \n   return lock_unlock_statement (ST_UNLOCK);\n@@ -3023,8 +3014,7 @@ sync_statement (gfc_statement st)\n   if (gfc_implicit_pure (NULL))\n     gfc_current_ns->proc_name->attr.implicit_pure = 0;\n \n-  if (gfc_notify_std (GFC_STD_F2008, \"SYNC statement at %C\")\n-      == FAILURE)\n+  if (!gfc_notify_std (GFC_STD_F2008, \"SYNC statement at %C\"))\n     return MATCH_ERROR;\n \n   if (gfc_option.coarray == GFC_FCOARRAY_NONE)\n@@ -3033,13 +3023,13 @@ sync_statement (gfc_statement st)\n        return MATCH_ERROR;\n     }\n \n-  if (gfc_find_state (COMP_CRITICAL) == SUCCESS)\n+  if (gfc_find_state (COMP_CRITICAL))\n     {\n       gfc_error (\"Image control statement SYNC at %C in CRITICAL block\");\n       return MATCH_ERROR;\n     }\n \n-  if (gfc_find_state (COMP_DO_CONCURRENT) == SUCCESS)\n+  if (gfc_find_state (COMP_DO_CONCURRENT))\n     {\n       gfc_error (\"Image control statement SYNC at %C in DO CONCURRENT block\");\n       return MATCH_ERROR;\n@@ -3217,13 +3207,11 @@ gfc_match_assign (void)\n \n   if (gfc_match (\" %l\", &label) == MATCH_YES)\n     {\n-      if (gfc_reference_st_label (label, ST_LABEL_UNKNOWN) == FAILURE)\n+      if (!gfc_reference_st_label (label, ST_LABEL_UNKNOWN))\n \treturn MATCH_ERROR;\n       if (gfc_match (\" to %v%t\", &expr) == MATCH_YES)\n \t{\n-\t  if (gfc_notify_std (GFC_STD_F95_DEL, \"ASSIGN \"\n-\t\t\t      \"statement at %C\")\n-\t      == FAILURE)\n+\t  if (!gfc_notify_std (GFC_STD_F95_DEL, \"ASSIGN statement at %C\"))\n \t    return MATCH_ERROR;\n \n \t  expr->symtree->n.sym->attr.assign = 1;\n@@ -3255,7 +3243,7 @@ gfc_match_goto (void)\n \n   if (gfc_match (\" %l%t\", &label) == MATCH_YES)\n     {\n-      if (gfc_reference_st_label (label, ST_LABEL_TARGET) == FAILURE)\n+      if (!gfc_reference_st_label (label, ST_LABEL_TARGET))\n \treturn MATCH_ERROR;\n \n       new_st.op = EXEC_GOTO;\n@@ -3267,9 +3255,7 @@ gfc_match_goto (void)\n \n   if (gfc_match_variable (&expr, 0) == MATCH_YES)\n     {\n-      if (gfc_notify_std (GFC_STD_F95_DEL, \"Assigned GOTO \"\n-\t\t\t  \"statement at %C\")\n-\t  == FAILURE)\n+      if (!gfc_notify_std (GFC_STD_F95_DEL, \"Assigned GOTO statement at %C\"))\n \treturn MATCH_ERROR;\n \n       new_st.op = EXEC_GOTO;\n@@ -3293,7 +3279,7 @@ gfc_match_goto (void)\n \t  if (m != MATCH_YES)\n \t    goto syntax;\n \n-\t  if (gfc_reference_st_label (label, ST_LABEL_TARGET) == FAILURE)\n+\t  if (!gfc_reference_st_label (label, ST_LABEL_TARGET))\n \t    goto cleanup;\n \n \t  if (head == NULL)\n@@ -3338,7 +3324,7 @@ gfc_match_goto (void)\n       if (m != MATCH_YES)\n \tgoto syntax;\n \n-      if (gfc_reference_st_label (label, ST_LABEL_TARGET) == FAILURE)\n+      if (!gfc_reference_st_label (label, ST_LABEL_TARGET))\n \tgoto cleanup;\n \n       if (head == NULL)\n@@ -3377,8 +3363,7 @@ gfc_match_goto (void)\n   if (gfc_match (\" %e%t\", &expr) != MATCH_YES)\n     goto syntax;\n \n-  if (gfc_notify_std (GFC_STD_F95_OBS, \"Computed GOTO \"\n-\t\t      \"at %C\") == FAILURE)\n+  if (!gfc_notify_std (GFC_STD_F95_OBS, \"Computed GOTO at %C\"))\n     return MATCH_ERROR;\n \n   /* At this point, a computed GOTO has been fully matched and an\n@@ -3460,8 +3445,8 @@ gfc_match_allocate (void)\n     {\n       if (gfc_match (\" :: \") == MATCH_YES)\n \t{\n-\t  if (gfc_notify_std (GFC_STD_F2003, \"typespec in \"\n-\t\t\t      \"ALLOCATE at %L\", &old_locus) == FAILURE)\n+\t  if (!gfc_notify_std (GFC_STD_F2003, \"typespec in ALLOCATE at %L\", \n+\t\t\t       &old_locus))\n \t    goto cleanup;\n \n \t  if (ts.deferred)\n@@ -3516,21 +3501,21 @@ gfc_match_allocate (void)\n \t  deferred_locus = tail->expr->where;\n \t}\n \n-      if (gfc_find_state (COMP_DO_CONCURRENT) == SUCCESS\n-\t  || gfc_find_state (COMP_CRITICAL) == SUCCESS)\n+      if (gfc_find_state (COMP_DO_CONCURRENT)\n+\t  || gfc_find_state (COMP_CRITICAL))\n \t{\n \t  gfc_ref *ref;\n \t  bool coarray = tail->expr->symtree->n.sym->attr.codimension;\n \t  for (ref = tail->expr->ref; ref; ref = ref->next)\n \t    if (ref->type == REF_COMPONENT)\n \t      coarray = ref->u.c.component->attr.codimension;\n \n-\t  if (coarray && gfc_find_state (COMP_DO_CONCURRENT) == SUCCESS)\n+\t  if (coarray && gfc_find_state (COMP_DO_CONCURRENT))\n \t    {\n \t      gfc_error (\"ALLOCATE of coarray at %C in DO CONCURRENT block\");\n \t      goto cleanup;\n \t    }\n-\t  if (coarray && gfc_find_state (COMP_CRITICAL) == SUCCESS)\n+\t  if (coarray && gfc_find_state (COMP_CRITICAL))\n \t    {\n \t      gfc_error (\"ALLOCATE of coarray at %C in CRITICAL block\");\n \t      goto cleanup;\n@@ -3625,8 +3610,7 @@ gfc_match_allocate (void)\n \tgoto cleanup;\n       if (m == MATCH_YES)\n \t{\n-\t  if (gfc_notify_std (GFC_STD_F2003, \"ERRMSG tag at %L\",\n-\t\t\t      &tmp->where) == FAILURE)\n+\t  if (!gfc_notify_std (GFC_STD_F2003, \"ERRMSG tag at %L\", &tmp->where))\n \t    goto cleanup;\n \n \t  /* Enforce C630.  */\n@@ -3649,8 +3633,7 @@ gfc_match_allocate (void)\n \tgoto cleanup;\n       if (m == MATCH_YES)\n \t{\n-\t  if (gfc_notify_std (GFC_STD_F2003, \"SOURCE tag at %L\",\n-\t\t\t      &tmp->where) == FAILURE)\n+\t  if (!gfc_notify_std (GFC_STD_F2003, \"SOURCE tag at %L\", &tmp->where))\n \t    goto cleanup;\n \n \t  /* Enforce C630.  */\n@@ -3669,9 +3652,9 @@ gfc_match_allocate (void)\n \t    }\n \n \t  if (head->next\n-\t      && gfc_notify_std (GFC_STD_F2008, \"SOURCE tag at %L\"\n-\t\t\t\t \" with more than a single allocate object\",\n-\t\t\t\t &tmp->where) == FAILURE)\n+\t      && !gfc_notify_std (GFC_STD_F2008, \"SOURCE tag at %L\"\n+\t\t\t\t  \" with more than a single allocate object\", \n+\t\t\t\t  &tmp->where))\n \t    goto cleanup;\n \n \t  source = tmp;\n@@ -3687,8 +3670,7 @@ gfc_match_allocate (void)\n \tgoto cleanup;\n       if (m == MATCH_YES)\n \t{\n-\t  if (gfc_notify_std (GFC_STD_F2008, \"MOLD tag at %L\",\n-\t\t\t      &tmp->where) == FAILURE)\n+\t  if (!gfc_notify_std (GFC_STD_F2008, \"MOLD tag at %L\", &tmp->where))\n \t    goto cleanup;\n \n \t  /* Check F08:C636.  */\n@@ -3900,14 +3882,14 @@ gfc_match_deallocate (void)\n \tgfc_current_ns->proc_name->attr.implicit_pure = 0;\n \n       if (gfc_is_coarray (tail->expr)\n-\t  && gfc_find_state (COMP_DO_CONCURRENT) == SUCCESS)\n+\t  && gfc_find_state (COMP_DO_CONCURRENT))\n \t{\n \t  gfc_error (\"DEALLOCATE of coarray at %C in DO CONCURRENT block\");\n \t  goto cleanup;\n \t}\n \n       if (gfc_is_coarray (tail->expr)\n-\t  && gfc_find_state (COMP_CRITICAL) == SUCCESS)\n+\t  && gfc_find_state (COMP_CRITICAL))\n \t{\n \t  gfc_error (\"DEALLOCATE of coarray at %C in CRITICAL block\");\n \t  goto cleanup;\n@@ -3962,8 +3944,7 @@ gfc_match_deallocate (void)\n \tgoto cleanup;\n       if (m == MATCH_YES)\n \t{\n-\t  if (gfc_notify_std (GFC_STD_F2003, \"ERRMSG at %L\",\n-\t\t\t      &tmp->where) == FAILURE)\n+\t  if (!gfc_notify_std (GFC_STD_F2003, \"ERRMSG at %L\", &tmp->where))\n \t    goto cleanup;\n \n \t  if (saw_errmsg)\n@@ -4018,13 +3999,13 @@ gfc_match_return (void)\n \n   e = NULL;\n \n-  if (gfc_find_state (COMP_CRITICAL) == SUCCESS)\n+  if (gfc_find_state (COMP_CRITICAL))\n     {\n       gfc_error (\"Image control statement RETURN at %C in CRITICAL block\");\n       return MATCH_ERROR;\n     }\n \n-  if (gfc_find_state (COMP_DO_CONCURRENT) == SUCCESS)\n+  if (gfc_find_state (COMP_DO_CONCURRENT))\n     {\n       gfc_error (\"Image control statement RETURN at %C in DO CONCURRENT block\");\n       return MATCH_ERROR;\n@@ -4033,7 +4014,7 @@ gfc_match_return (void)\n   if (gfc_match_eos () == MATCH_YES)\n     goto done;\n \n-  if (gfc_find_state (COMP_SUBROUTINE) == FAILURE)\n+  if (!gfc_find_state (COMP_SUBROUTINE))\n     {\n       gfc_error (\"Alternate RETURN statement at %C is only allowed within \"\n \t\t \"a SUBROUTINE\");\n@@ -4066,8 +4047,8 @@ gfc_match_return (void)\n done:\n   gfc_enclosing_unit (&s);\n   if (s == COMP_PROGRAM\n-      && gfc_notify_std (GFC_STD_GNU, \"RETURN statement in \"\n-\t\t\t\"main program at %C\") == FAILURE)\n+      && !gfc_notify_std (GFC_STD_GNU, \"RETURN statement in \"\n+\t\t\t  \"main program at %C\"))\n       return MATCH_ERROR;\n \n   new_st.op = EXEC_RETURN;\n@@ -4178,7 +4159,7 @@ gfc_match_call (void)\n \t}\n \n       /* ...and then to try to make the symbol into a subroutine.  */\n-      if (gfc_add_subroutine (&sym->attr, sym->name, NULL) == FAILURE)\n+      if (!gfc_add_subroutine (&sym->attr, sym->name, NULL))\n \treturn MATCH_ERROR;\n     }\n \n@@ -4231,7 +4212,7 @@ gfc_match_call (void)\n \t  if (a->expr != NULL)\n \t    continue;\n \n-\t  if (gfc_reference_st_label (a->label, ST_LABEL_TARGET) == FAILURE)\n+\t  if (!gfc_reference_st_label (a->label, ST_LABEL_TARGET))\n \t    continue;\n \n \t  i++;\n@@ -4450,14 +4431,13 @@ gfc_match_common (void)\n \t  if (((sym->value != NULL && sym->value->expr_type != EXPR_NULL)\n \t       || sym->attr.data) && gfc_current_state () != COMP_BLOCK_DATA)\n \t    {\n-\t      if (gfc_notify_std (GFC_STD_GNU, \"Initialized symbol '%s' at %C \"\n-\t\t\t\t\t       \"can only be COMMON in \"\n-\t\t\t\t\t       \"BLOCK DATA\", sym->name)\n-\t\t  == FAILURE)\n+\t      if (!gfc_notify_std (GFC_STD_GNU, \"Initialized symbol '%s' at \"\n+\t\t\t\t   \"%C can only be COMMON in BLOCK DATA\", \n+\t\t\t\t   sym->name))\n \t\tgoto cleanup;\n \t    }\n \n-\t  if (gfc_add_in_common (&sym->attr, sym->name, NULL) == FAILURE)\n+\t  if (!gfc_add_in_common (&sym->attr, sym->name, NULL))\n \t    goto cleanup;\n \n \t  if (tail != NULL)\n@@ -4482,7 +4462,7 @@ gfc_match_common (void)\n \t\t  goto cleanup;\n \t\t}\n \n-\t      if (gfc_add_dimension (&sym->attr, sym->name, NULL) == FAILURE)\n+\t      if (!gfc_add_dimension (&sym->attr, sym->name, NULL))\n \t\tgoto cleanup;\n \n \t      if (sym->attr.pointer)\n@@ -4584,7 +4564,7 @@ gfc_match_block_data (void)\n   if (gfc_get_symbol (name, NULL, &sym))\n     return MATCH_ERROR;\n \n-  if (gfc_add_flavor (&sym->attr, FL_BLOCK_DATA, sym->name, NULL) == FAILURE)\n+  if (!gfc_add_flavor (&sym->attr, FL_BLOCK_DATA, sym->name, NULL))\n     return MATCH_ERROR;\n \n   gfc_new_block = sym;\n@@ -4635,15 +4615,14 @@ gfc_match_namelist (void)\n \n       if (group_name->attr.flavor == FL_NAMELIST\n \t  && group_name->attr.use_assoc\n-\t  && gfc_notify_std (GFC_STD_GNU, \"Namelist group name '%s' \"\n-\t\t\t     \"at %C already is USE associated and can\"\n-\t\t\t     \"not be respecified.\", group_name->name)\n-\t     == FAILURE)\n+\t  && !gfc_notify_std (GFC_STD_GNU, \"Namelist group name '%s' \"\n+\t\t\t      \"at %C already is USE associated and can\"\n+\t\t\t      \"not be respecified.\", group_name->name))\n \treturn MATCH_ERROR;\n \n       if (group_name->attr.flavor != FL_NAMELIST\n-\t  && gfc_add_flavor (&group_name->attr, FL_NAMELIST,\n-\t\t\t     group_name->name, NULL) == FAILURE)\n+\t  && !gfc_add_flavor (&group_name->attr, FL_NAMELIST, \n+\t\t\t      group_name->name, NULL))\n \treturn MATCH_ERROR;\n \n       for (;;)\n@@ -4655,7 +4634,7 @@ gfc_match_namelist (void)\n \t    goto error;\n \n \t  if (sym->attr.in_namelist == 0\n-\t      && gfc_add_in_namelist (&sym->attr, sym->name, NULL) == FAILURE)\n+\t      && !gfc_add_in_namelist (&sym->attr, sym->name, NULL))\n \t    goto error;\n \n \t  /* Use gfc_error_check here, rather than goto error, so that\n@@ -4721,8 +4700,8 @@ gfc_match_module (void)\n   if (m != MATCH_YES)\n     return m;\n \n-  if (gfc_add_flavor (&gfc_new_block->attr, FL_MODULE,\n-\t\t      gfc_new_block->name, NULL) == FAILURE)\n+  if (!gfc_add_flavor (&gfc_new_block->attr, FL_MODULE, \n+\t\t       gfc_new_block->name, NULL))\n     return MATCH_ERROR;\n \n   return MATCH_YES;\n@@ -4811,7 +4790,7 @@ gfc_match_equivalence (void)\n \n \t  sym = set->expr->symtree->n.sym;\n \n-\t  if (gfc_add_in_equivalence (&sym->attr, sym->name, NULL) == FAILURE)\n+\t  if (!gfc_add_in_equivalence (&sym->attr, sym->name, NULL))\n \t    goto cleanup;\n \n \t  if (sym->attr.in_common)\n@@ -4958,8 +4937,7 @@ gfc_match_st_function (void)\n \n   gfc_push_error (&old_error);\n \n-  if (gfc_add_procedure (&sym->attr, PROC_ST_FUNCTION,\n-\t\t\t sym->name, NULL) == FAILURE)\n+  if (!gfc_add_procedure (&sym->attr, PROC_ST_FUNCTION, sym->name, NULL))\n     goto undo_error;\n \n   if (gfc_match_formal_arglist (sym, 1, 0) != MATCH_YES)\n@@ -4981,8 +4959,7 @@ gfc_match_st_function (void)\n \n   sym->value = expr;\n \n-  if (gfc_notify_std (GFC_STD_F95_OBS,\n-\t\t      \"Statement function at %C\") == FAILURE)\n+  if (!gfc_notify_std (GFC_STD_F95_OBS, \"Statement function at %C\"))\n     return MATCH_ERROR;\n \n   return MATCH_YES;"}, {"sha": "ac8b9f84696078a0cdb8c0f30a001ad3d0f0638c", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=524af0d6c72031c249aa737945fde6ac3d726ba2", "patch": "@@ -195,9 +195,9 @@ match gfc_match_volatile (void);\n /* Fortran 2003 c interop.\n    TODO: some of these should be moved to another file rather than decl.c */\n void set_com_block_bind_c (gfc_common_head *, int);\n-gfc_try set_verify_bind_c_sym (gfc_symbol *, int);\n-gfc_try set_verify_bind_c_com_block (gfc_common_head *, int);\n-gfc_try get_bind_c_idents (void);\n+bool set_verify_bind_c_sym (gfc_symbol *, int);\n+bool set_verify_bind_c_com_block (gfc_common_head *, int);\n+bool get_bind_c_idents (void);\n match gfc_match_bind_c_stmt (void);\n match gfc_match_suffix (gfc_symbol *, gfc_symbol **);\n match gfc_match_bind_c (gfc_symbol *, bool);\n@@ -213,7 +213,7 @@ match gfc_match_literal_constant (gfc_expr **, int);\n /* expr.c -- FIXME: this one should be eliminated by moving the\n    matcher to matchexp.c and a call to a new function in expr.c that\n    only makes sure the init expr. is valid.  */\n-gfc_try gfc_reduce_init_expr (gfc_expr *expr);\n+bool gfc_reduce_init_expr (gfc_expr *expr);\n match gfc_match_init_expr (gfc_expr **);\n \n /* array.c.  */"}, {"sha": "046ba4835f287ccc16c7121195a30fabcc771ed4", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=524af0d6c72031c249aa737945fde6ac3d726ba2", "patch": "@@ -555,8 +555,8 @@ gfc_match_use (void)\n     {\n       if ((m = gfc_match (\" %n ::\", module_nature)) == MATCH_YES)\n \t{\n-\t  if (gfc_notify_std (GFC_STD_F2003, \"module \"\n-\t\t\t      \"nature in USE statement at %C\") == FAILURE)\n+\t  if (!gfc_notify_std (GFC_STD_F2003, \"module \"\n+\t\t\t       \"nature in USE statement at %C\"))\n \t    goto cleanup;\n \n \t  if (strcmp (module_nature, \"intrinsic\") == 0)\n@@ -590,8 +590,7 @@ gfc_match_use (void)\n     {\n       m = gfc_match (\" ::\");\n       if (m == MATCH_YES &&\n-\t  gfc_notify_std (GFC_STD_F2003,\n-\t\t\t  \"\\\"USE :: module\\\" at %C\") == FAILURE)\n+\t  !gfc_notify_std(GFC_STD_F2003, \"\\\"USE :: module\\\" at %C\"))\n \tgoto cleanup;\n \n       if (m != MATCH_YES)\n@@ -658,9 +657,8 @@ gfc_match_use (void)\n \t  m = gfc_match (\" =>\");\n \n \t  if (type == INTERFACE_USER_OP && m == MATCH_YES\n-\t      && (gfc_notify_std (GFC_STD_F2003, \"Renaming \"\n-\t\t\t\t  \"operators in USE statements at %C\")\n-\t\t == FAILURE))\n+\t      && (!gfc_notify_std(GFC_STD_F2003, \"Renaming \"\n+\t\t\t\t  \"operators in USE statements at %C\")))\n \t    goto cleanup;\n \n \t  if (type == INTERFACE_USER_OP)\n@@ -4089,7 +4087,7 @@ load_generic_interfaces (void)\n \t      if (st && !sym->attr.generic\n \t\t     && !st->ambiguous\n \t\t     && sym->module\n-\t\t     && strcmp(module, sym->module))\n+\t\t     && strcmp (module, sym->module))\n \t\t{\n \t\t  ambiguous_set = true;\n \t\t  st->ambiguous = 1;\n@@ -6096,10 +6094,9 @@ use_iso_fortran_env_module (void)\n \t      found = true;\n \t      u->found = 1;\n \n-\t      if (gfc_notify_std (symbol[i].standard, \"The symbol '%s', \"\n-\t\t\t\t  \"referenced at %L, is not in the selected \"\n-\t\t\t\t  \"standard\", symbol[i].name,\n-\t\t\t\t  &u->where) == FAILURE)\n+\t      if (!gfc_notify_std (symbol[i].standard, \"The symbol '%s', \"\n+\t\t\t\t   \"referenced at %L, is not in the selected \"\n+\t\t\t\t   \"standard\", symbol[i].name, &u->where))\n \t        continue;\n \n \t      if ((gfc_option.flag_default_integer || gfc_option.flag_default_real)\n@@ -6265,7 +6262,7 @@ gfc_use_module (gfc_use_list *module)\n     {\n       if (strcmp (module_name, \"iso_fortran_env\") == 0\n \t  && gfc_notify_std (GFC_STD_F2003, \"ISO_FORTRAN_ENV \"\n-\t\t\t     \"intrinsic module at %C\") != FAILURE)\n+\t\t\t     \"intrinsic module at %C\"))\n        {\n \t use_iso_fortran_env_module ();\n \t free_rename (module->rename);\n@@ -6276,8 +6273,7 @@ gfc_use_module (gfc_use_list *module)\n        }\n \n       if (strcmp (module_name, \"iso_c_binding\") == 0\n-\t  && gfc_notify_std (GFC_STD_F2003,\n-\t\t\t     \"ISO_C_BINDING module at %C\") != FAILURE)\n+\t  && gfc_notify_std (GFC_STD_F2003, \"ISO_C_BINDING module at %C\"))\n \t{\n \t  import_iso_c_binding_module();\n \t  free_rename (module->rename);"}, {"sha": "865f8365cfc9295f38f94498f71354691452eae2", "filename": "gcc/fortran/openmp.c", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Fopenmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Fopenmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fopenmp.c?ref=524af0d6c72031c249aa737945fde6ac3d726ba2", "patch": "@@ -316,9 +316,8 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, int mask)\n \t\t  && ! sym->attr.intrinsic\n \t\t  && ! sym->attr.use_assoc\n \t\t  && ((sym->attr.flavor == FL_UNKNOWN\n-\t\t       && gfc_add_flavor (&sym->attr, FL_PROCEDURE,\n-\t\t\t\t\t  sym->name, NULL) == FAILURE)\n-\t\t      || gfc_add_intrinsic (&sym->attr, NULL) == FAILURE))\n+\t\t       && !gfc_add_flavor (&sym->attr, FL_PROCEDURE, sym->name, NULL))\n+\t\t      || !gfc_add_intrinsic (&sym->attr, NULL)))\n \t\t{\n \t\t  gfc_free_omp_clauses (c);\n \t\t  return MATCH_ERROR;\n@@ -573,8 +572,7 @@ gfc_match_omp_threadprivate (void)\n \t  if (sym->attr.in_common)\n \t    gfc_error_now (\"Threadprivate variable at %C is an element of \"\n \t\t\t   \"a COMMON block\");\n-\t  else if (gfc_add_threadprivate (&sym->attr, sym->name,\n-\t\t   &sym->declared_at) == FAILURE)\n+\t  else if (!gfc_add_threadprivate (&sym->attr, sym->name, &sym->declared_at))\n \t    goto cleanup;\n \t  goto next_item;\n \tcase MATCH_NO:\n@@ -597,8 +595,7 @@ gfc_match_omp_threadprivate (void)\n \t}\n       st->n.common->threadprivate = 1;\n       for (sym = st->n.common->head; sym; sym = sym->common_next)\n-\tif (gfc_add_threadprivate (&sym->attr, sym->name,\n-\t\t\t\t   &sym->declared_at) == FAILURE)\n+\tif (!gfc_add_threadprivate (&sym->attr, sym->name, &sym->declared_at))\n \t  goto cleanup;\n \n     next_item:\n@@ -814,31 +811,31 @@ resolve_omp_clauses (gfc_code *code)\n   if (omp_clauses->if_expr)\n     {\n       gfc_expr *expr = omp_clauses->if_expr;\n-      if (gfc_resolve_expr (expr) == FAILURE\n+      if (!gfc_resolve_expr (expr)\n \t  || expr->ts.type != BT_LOGICAL || expr->rank != 0)\n \tgfc_error (\"IF clause at %L requires a scalar LOGICAL expression\",\n \t\t   &expr->where);\n     }\n   if (omp_clauses->final_expr)\n     {\n       gfc_expr *expr = omp_clauses->final_expr;\n-      if (gfc_resolve_expr (expr) == FAILURE\n+      if (!gfc_resolve_expr (expr)\n \t  || expr->ts.type != BT_LOGICAL || expr->rank != 0)\n \tgfc_error (\"FINAL clause at %L requires a scalar LOGICAL expression\",\n \t\t   &expr->where);\n     }\n   if (omp_clauses->num_threads)\n     {\n       gfc_expr *expr = omp_clauses->num_threads;\n-      if (gfc_resolve_expr (expr) == FAILURE\n+      if (!gfc_resolve_expr (expr)\n \t  || expr->ts.type != BT_INTEGER || expr->rank != 0)\n \tgfc_error (\"NUM_THREADS clause at %L requires a scalar \"\n \t\t   \"INTEGER expression\", &expr->where);\n     }\n   if (omp_clauses->chunk_size)\n     {\n       gfc_expr *expr = omp_clauses->chunk_size;\n-      if (gfc_resolve_expr (expr) == FAILURE\n+      if (!gfc_resolve_expr (expr)\n \t  || expr->ts.type != BT_INTEGER || expr->rank != 0)\n \tgfc_error (\"SCHEDULE clause's chunk_size at %L requires \"\n \t\t   \"a scalar INTEGER expression\", &expr->where);"}, {"sha": "6dde0c651b5d5fc75a545277271dc3ee9ef45638", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 29, "deletions": 33, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=524af0d6c72031c249aa737945fde6ac3d726ba2", "patch": "@@ -100,7 +100,7 @@ use_modules (void)\n \n #define match(keyword, subr, st)\t\t\t\t\\\n     do {\t\t\t\t\t\t\t\\\n-      if (match_word(keyword, subr, &old_locus) == MATCH_YES)\t\\\n+      if (match_word (keyword, subr, &old_locus) == MATCH_YES)\t\\\n \treturn st;\t\t\t\t\t\t\\\n       else\t\t\t\t\t\t\t\\\n \tundo_new_statement ();\t\t\t\t  \\\n@@ -1068,7 +1068,7 @@ pop_state (void)\n \n /* Try to find the given state in the state stack.  */\n \n-gfc_try\n+bool\n gfc_find_state (gfc_compile_state state)\n {\n   gfc_state_data *p;\n@@ -1077,7 +1077,7 @@ gfc_find_state (gfc_compile_state state)\n     if (p->state == state)\n       break;\n \n-  return (p == NULL) ? FAILURE : SUCCESS;\n+  return (p == NULL) ? false : true;\n }\n \n \n@@ -1763,7 +1763,7 @@ unexpected_statement (gfc_statement st)\n /* Given the next statement seen by the matcher, make sure that it is\n    in proper order with the last.  This subroutine is initialized by\n    calling it with an argument of ST_NONE.  If there is a problem, we\n-   issue an error and return FAILURE.  Otherwise we return SUCCESS.\n+   issue an error and return false.  Otherwise we return true.\n \n    Individual parsers need to verify that the statements seen are\n    valid before calling here, i.e., ENTRY statements are not allowed in\n@@ -1815,7 +1815,7 @@ typedef struct\n }\n st_state;\n \n-static gfc_try\n+static bool\n verify_st_order (st_state *p, gfc_statement st, bool silent)\n {\n \n@@ -1897,15 +1897,15 @@ verify_st_order (st_state *p, gfc_statement st, bool silent)\n   /* All is well, record the statement in case we need it next time.  */\n   p->where = gfc_current_locus;\n   p->last_statement = st;\n-  return SUCCESS;\n+  return true;\n \n order:\n   if (!silent)\n     gfc_error (\"%s statement at %C cannot follow %s statement at %L\",\n \t       gfc_ascii_statement (st),\n \t       gfc_ascii_statement (p->last_statement), &p->where);\n \n-  return FAILURE;\n+  return false;\n }\n \n \n@@ -1977,27 +1977,24 @@ parse_derived_contains (void)\n \t  goto error;\n \n \tcase ST_PROCEDURE:\n-\t  if (gfc_notify_std (GFC_STD_F2003, \"Type-bound\"\n-\t\t\t\t\t     \" procedure at %C\") == FAILURE)\n+\t  if (!gfc_notify_std (GFC_STD_F2003, \"Type-bound procedure at %C\"))\n \t    goto error;\n \n \t  accept_statement (ST_PROCEDURE);\n \t  seen_comps = true;\n \t  break;\n \n \tcase ST_GENERIC:\n-\t  if (gfc_notify_std (GFC_STD_F2003, \"GENERIC binding\"\n-\t\t\t\t\t     \" at %C\") == FAILURE)\n+\t  if (!gfc_notify_std (GFC_STD_F2003, \"GENERIC binding at %C\"))\n \t    goto error;\n \n \t  accept_statement (ST_GENERIC);\n \t  seen_comps = true;\n \t  break;\n \n \tcase ST_FINAL:\n-\t  if (gfc_notify_std (GFC_STD_F2003,\n-\t\t\t      \"FINAL procedure declaration\"\n-\t\t\t      \" at %C\") == FAILURE)\n+\t  if (!gfc_notify_std (GFC_STD_F2003, \"FINAL procedure declaration\"\n+\t\t\t       \" at %C\"))\n \t    goto error;\n \n \t  accept_statement (ST_FINAL);\n@@ -2008,16 +2005,15 @@ parse_derived_contains (void)\n \t  to_finish = true;\n \n \t  if (!seen_comps\n-\t      && (gfc_notify_std (GFC_STD_F2008, \"Derived type \"\n-\t\t\t\t  \"definition at %C with empty CONTAINS \"\n-\t\t\t\t  \"section\") == FAILURE))\n+\t      && (!gfc_notify_std(GFC_STD_F2008, \"Derived type definition \"\n+\t\t\t\t  \"at %C with empty CONTAINS section\")))\n \t    goto error;\n \n \t  /* ST_END_TYPE is accepted by parse_derived after return.  */\n \t  break;\n \n \tcase ST_PRIVATE:\n-\t  if (gfc_find_state (COMP_MODULE) == FAILURE)\n+\t  if (!gfc_find_state (COMP_MODULE))\n \t    {\n \t      gfc_error (\"PRIVATE statement in TYPE at %C must be inside \"\n \t\t\t \"a MODULE\");\n@@ -2120,7 +2116,7 @@ parse_derived (void)\n \t  break;\n \n \tcase ST_PRIVATE:\n-\t  if (gfc_find_state (COMP_MODULE) == FAILURE)\n+\t  if (!gfc_find_state (COMP_MODULE))\n \t    {\n \t      gfc_error (\"PRIVATE statement in TYPE at %C must be inside \"\n \t\t\t \"a MODULE\");\n@@ -2395,8 +2391,8 @@ parse_interface (void)\n \t  gfc_new_block->attr.pointer = 0;\n \t  gfc_new_block->attr.proc_pointer = 1;\n \t}\n-      if (gfc_add_explicit_interface (gfc_new_block, IFSRC_IFBODY,\n-\t\t\t\t  gfc_new_block->formal, NULL) == FAILURE)\n+      if (!gfc_add_explicit_interface (gfc_new_block, IFSRC_IFBODY, \n+\t\t\t\t       gfc_new_block->formal, NULL))\n \t{\n \t  reject_statement ();\n \t  gfc_free_namespace (gfc_current_ns);\n@@ -2642,7 +2638,7 @@ parse_spec (gfc_statement st)\n \t  verify_st_order (&dummyss, ST_NONE, false);\n \t  verify_st_order (&dummyss, st, false);\n \n-\t  if (verify_st_order (&dummyss, ST_IMPLICIT, true) == FAILURE)\n+\t  if (!verify_st_order (&dummyss, ST_IMPLICIT, true))\n \t    verify_now = true;\n \t}\n \n@@ -2683,7 +2679,7 @@ parse_spec (gfc_statement st)\n     case ST_DERIVED_DECL:\n     case_decl:\n declSt:\n-      if (verify_st_order (&ss, st, false) == FAILURE)\n+      if (!verify_st_order (&ss, st, false))\n \t{\n \t  reject_statement ();\n \t  st = next_statement ();\n@@ -3313,14 +3309,14 @@ gfc_build_block_ns (gfc_namespace *parent_ns)\n     my_ns->proc_name = gfc_new_block;\n   else\n     {\n-      gfc_try t;\n+      bool t;\n       char buffer[20];  /* Enough to hold \"block@2147483648\\n\".  */\n \n       snprintf(buffer, sizeof(buffer), \"block@%d\", numblock++);\n       gfc_get_symbol (buffer, my_ns, &my_ns->proc_name);\n       t = gfc_add_flavor (&my_ns->proc_name->attr, FL_LABEL,\n \t\t\t  my_ns->proc_name->name, NULL);\n-      gcc_assert (t == SUCCESS);\n+      gcc_assert (t);\n       gfc_commit_symbol (my_ns->proc_name);\n     }\n \n@@ -4026,9 +4022,9 @@ parse_contained (int module)\n \t\t\t   \"ambiguous\", gfc_new_block->name);\n \t      else\n \t\t{\n-\t\t  if (gfc_add_procedure (&sym->attr, PROC_INTERNAL, sym->name,\n-\t\t\t\t\t &gfc_new_block->declared_at) ==\n-\t\t      SUCCESS)\n+\t\t  if (gfc_add_procedure (&sym->attr, PROC_INTERNAL, \n+\t\t\t\t\t sym->name, \n+\t\t\t\t\t &gfc_new_block->declared_at))\n \t\t    {\n \t\t      if (st == ST_FUNCTION)\n \t\t\tgfc_add_function (&sym->attr, sym->name,\n@@ -4174,7 +4170,7 @@ parse_progunit (gfc_statement st)\n     if (p->state == COMP_CONTAINS)\n       n++;\n \n-  if (gfc_find_state (COMP_MODULE) == SUCCESS)\n+  if (gfc_find_state (COMP_MODULE) == true)\n     n--;\n \n   if (n > 0)\n@@ -4492,7 +4488,7 @@ translate_all_program_units (gfc_namespace *gfc_global_ns_list,\n \n /* Top level parser.  */\n \n-gfc_try\n+bool\n gfc_parse_file (void)\n {\n   int seen_program, errors_before, errors;\n@@ -4516,7 +4512,7 @@ gfc_parse_file (void)\n   gfc_statement_label = NULL;\n \n   if (setjmp (eof_buf))\n-    return FAILURE;\t/* Come here on unexpected EOF */\n+    return false;\t/* Come here on unexpected EOF */\n \n   /* Prepare the global namespace that will contain the\n      program units.  */\n@@ -4663,7 +4659,7 @@ gfc_parse_file (void)\n   translate_all_program_units (gfc_global_ns_list, seen_program);\n \n   gfc_end_source_files ();\n-  return SUCCESS;\n+  return true;\n \n duplicate_main:\n   /* If we see a duplicate main program, shut down.  If the second\n@@ -4672,5 +4668,5 @@ gfc_parse_file (void)\n   gfc_error (\"Two main PROGRAMs at %L and %C\", &prog_locus);\n   reject_statement ();\n   gfc_done_2 ();\n-  return SUCCESS;\n+  return true;\n }"}, {"sha": "acafe6c52ebb1249315135ea1dd3225ffb20c197", "filename": "gcc/fortran/parse.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.h?ref=524af0d6c72031c249aa737945fde6ac3d726ba2", "patch": "@@ -60,7 +60,7 @@ extern gfc_state_data *gfc_state_stack;\n #define gfc_current_state() (gfc_state_stack->state)\n \n int gfc_check_do_variable (gfc_symtree *);\n-gfc_try gfc_find_state (gfc_compile_state);\n+bool gfc_find_state (gfc_compile_state);\n gfc_state_data *gfc_enclosing_unit (gfc_compile_state *);\n const char *gfc_ascii_statement (gfc_statement);\n match gfc_match_enum (void);"}, {"sha": "cd8a41755944ef1a984b2bc54b70655ee35e8631", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 52, "deletions": 63, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=524af0d6c72031c249aa737945fde6ac3d726ba2", "patch": "@@ -267,8 +267,7 @@ match_hollerith_constant (gfc_expr **result)\n   if (match_integer_constant (&e, 0) == MATCH_YES\n       && gfc_match_char ('h') == MATCH_YES)\n     {\n-      if (gfc_notify_std (GFC_STD_LEGACY, \"Hollerith constant \"\n-\t\t\t  \"at %C\") == FAILURE)\n+      if (!gfc_notify_std (GFC_STD_LEGACY, \"Hollerith constant at %C\"))\n \tgoto cleanup;\n \n       msg = gfc_extract_int (e, &num);\n@@ -391,9 +390,8 @@ match_boz_constant (gfc_expr **result)\n     goto backup;\n \n   if (x_hex\n-      && (gfc_notify_std (GFC_STD_GNU, \"Hexadecimal \"\n-\t\t\t  \"constant at %C uses non-standard syntax\")\n-\t  == FAILURE))\n+      && (!gfc_notify_std(GFC_STD_GNU, \"Hexadecimal \"\n+\t\t\t  \"constant at %C uses non-standard syntax\")))\n       return MATCH_ERROR;\n \n   old_loc = gfc_current_locus;\n@@ -430,9 +428,8 @@ match_boz_constant (gfc_expr **result)\n \t  goto backup;\n \t}\n \n-      if (gfc_notify_std (GFC_STD_GNU, \"BOZ constant \"\n-\t\t\t  \"at %C uses non-standard postfix syntax\")\n-\t  == FAILURE)\n+      if (!gfc_notify_std (GFC_STD_GNU, \"BOZ constant \"\n+\t\t\t   \"at %C uses non-standard postfix syntax\"))\n \treturn MATCH_ERROR;\n     }\n \n@@ -467,9 +464,8 @@ match_boz_constant (gfc_expr **result)\n     }\n \n   if (!gfc_in_match_data ()\n-      && (gfc_notify_std (GFC_STD_F2003, \"BOZ used outside a DATA \"\n-\t\t\t  \"statement at %C\")\n-\t  == FAILURE))\n+      && (!gfc_notify_std(GFC_STD_F2003, \"BOZ used outside a DATA \"\n+\t\t\t  \"statement at %C\")))\n       return MATCH_ERROR;\n \n   *result = e;\n@@ -558,8 +554,8 @@ match_real_constant (gfc_expr **result, int signflag)\n \n   if (c == 'q')\n     {\n-      if (gfc_notify_std (GFC_STD_GNU, \"exponent-letter 'q' in \"\n-\t\t\t \"real-literal-constant at %C\") == FAILURE)\n+      if (!gfc_notify_std (GFC_STD_GNU, \"exponent-letter 'q' in \"\n+\t\t\t   \"real-literal-constant at %C\"))\n \treturn MATCH_ERROR;\n       else if (gfc_option.warn_real_q_constant)\n \tgfc_warning(\"Extension: exponent-letter 'q' in real-literal-constant \"\n@@ -1217,8 +1213,8 @@ match_sym_complex_part (gfc_expr **result)\n       return MATCH_ERROR;\n     }\n \n-  if (gfc_notify_std (GFC_STD_F2003, \"PARAMETER symbol in \"\n-\t\t      \"complex constant at %C\") == FAILURE)\n+  if (!gfc_notify_std (GFC_STD_F2003, \"PARAMETER symbol in \"\n+\t\t       \"complex constant at %C\"))\n     return MATCH_ERROR;\n \n   switch (sym->value->ts.type)\n@@ -1506,8 +1502,8 @@ match_actual_arg (gfc_expr **result)\n \n \t  if (sym->attr.in_common && !sym->attr.proc_pointer)\n \t    {\n-\t      if (gfc_add_flavor (&sym->attr, FL_VARIABLE, sym->name,\n-\t\t\t\t  &sym->declared_at) == FAILURE)\n+\t      if (!gfc_add_flavor (&sym->attr, FL_VARIABLE, \n+\t\t\t\t   sym->name, &sym->declared_at))\n \t\treturn MATCH_ERROR;\n \t      break;\n \t    }\n@@ -1646,8 +1642,7 @@ match_arg_list_function (gfc_actual_arglist *result)\n \t}\n     }\n \n-  if (gfc_notify_std (GFC_STD_GNU, \"argument list \"\n-\t\t      \"function at %C\") == FAILURE)\n+  if (!gfc_notify_std (GFC_STD_GNU, \"argument list function at %C\"))\n     {\n       m = MATCH_ERROR;\n       goto cleanup;\n@@ -1719,8 +1714,8 @@ gfc_match_actual_arglist (int sub_flag, gfc_actual_arglist **argp)\n \t  if (m != MATCH_YES)\n \t    goto cleanup;\n \n-\t  if (gfc_notify_std (GFC_STD_F95_OBS, \"Alternate-return argument \"\n-\t      \"at %C\") == FAILURE)\n+\t  if (!gfc_notify_std (GFC_STD_F95_OBS, \"Alternate-return argument \"\n+\t\t\t       \"at %C\"))\n \t    goto cleanup;\n \n \t  tail->label = label;\n@@ -1936,7 +1931,7 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,\n \n   for (;;)\n     {\n-      gfc_try t;\n+      bool t;\n       gfc_symtree *tbp;\n \n       m = gfc_match_name (name);\n@@ -1954,7 +1949,7 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,\n \t{\n \t  gfc_symbol* tbp_sym;\n \n-\t  if (t == FAILURE)\n+\t  if (!t)\n \t    return MATCH_ERROR;\n \n \t  gcc_assert (!tail || !tail->next);\n@@ -2311,7 +2306,7 @@ gfc_free_structure_ctor_component (gfc_structure_ctor_component *comp)\n    the order required; this also checks along the way that each and every\n    component actually has an initializer and handles default initializers\n    for components without explicit value given.  */\n-static gfc_try\n+static bool\n build_actual_constructor (gfc_structure_ctor_component **comp_head,\n \t\t\t  gfc_constructor_base *ctor_head, gfc_symbol *sym)\n {\n@@ -2341,11 +2336,12 @@ build_actual_constructor (gfc_structure_ctor_component **comp_head,\n \t\t\t\t\t\t      &gfc_current_locus);\n \t  value->ts = comp->ts;\n \n-\t  if (build_actual_constructor (comp_head, &value->value.constructor,\n-\t\t\t\t\tcomp->ts.u.derived) == FAILURE)\n+\t  if (!build_actual_constructor (comp_head, \n+\t\t\t\t\t &value->value.constructor, \n+\t\t\t\t\t comp->ts.u.derived))\n \t    {\n \t      gfc_free_expr (value);\n-\t      return FAILURE;\n+\t      return false;\n \t    }\n \n \t  gfc_constructor_append_expr (ctor_head, value, NULL);\n@@ -2358,17 +2354,16 @@ build_actual_constructor (gfc_structure_ctor_component **comp_head,\n \t{\n \t  if (comp->initializer)\n \t    {\n-\t      if (gfc_notify_std (GFC_STD_F2003, \"Structure\"\n-\t\t\t\t  \" constructor with missing optional arguments\"\n-\t\t\t\t  \" at %C\") == FAILURE)\n-\t\treturn FAILURE;\n+\t      if (!gfc_notify_std (GFC_STD_F2003, \"Structure constructor \"\n+\t\t\t\t   \"with missing optional arguments at %C\"))\n+\t\treturn false;\n \t      value = gfc_copy_expr (comp->initializer);\n \t    }\n \t  else\n \t    {\n \t      gfc_error (\"No initializer for component '%s' given in the\"\n \t\t\t \" structure constructor at %C!\", comp->name);\n-\t      return FAILURE;\n+\t      return false;\n \t    }\n \t}\n       else\n@@ -2386,11 +2381,11 @@ build_actual_constructor (gfc_structure_ctor_component **comp_head,\n \t  gfc_free_structure_ctor_component (comp_iter);\n \t}\n     }\n-  return SUCCESS;\n+  return true;\n }\n \n \n-gfc_try\n+bool\n gfc_convert_to_structure_constructor (gfc_expr *e, gfc_symbol *sym, gfc_expr **cexpr,\n \t\t\t\t      gfc_actual_arglist **arglist,\n \t\t\t\t      bool parent)\n@@ -2434,9 +2429,8 @@ gfc_convert_to_structure_constructor (gfc_expr *e, gfc_symbol *sym, gfc_expr **c\n        \t}\n       if (actual->name)\n \t{\n-\t  if (gfc_notify_std (GFC_STD_F2003, \"Structure\"\n-\t\t\t      \" constructor with named arguments at %C\")\n-\t      == FAILURE)\n+\t  if (!gfc_notify_std (GFC_STD_F2003, \"Structure\"\n+\t\t\t       \" constructor with named arguments at %C\"))\n \t    goto cleanup;\n \n \t  comp_tail->name = xstrdup (actual->name);\n@@ -2519,7 +2513,7 @@ gfc_convert_to_structure_constructor (gfc_expr *e, gfc_symbol *sym, gfc_expr **c\n                       ||\n                     comp_tail->val->ts.u.derived != this_comp->ts.u.derived))\n             {\n-              gfc_try m;\n+              bool m;\n \t      gfc_actual_arglist *arg_null = NULL;\n \n \t      actual->expr = comp_tail->val;\n@@ -2529,7 +2523,7 @@ gfc_convert_to_structure_constructor (gfc_expr *e, gfc_symbol *sym, gfc_expr **c\n \t\t\t\t\tcomp->ts.u.derived, &comp_tail->val,\n \t\t\t\t\tcomp->ts.u.derived->attr.zero_comp\n \t\t\t\t\t  ? &arg_null : &actual, true);\n-              if (m == FAILURE)\n+              if (!m)\n                 goto cleanup;\n \n \t      if (comp->ts.u.derived->attr.zero_comp)\n@@ -2547,7 +2541,7 @@ gfc_convert_to_structure_constructor (gfc_expr *e, gfc_symbol *sym, gfc_expr **c\n       actual = actual->next;\n     }\n \n-  if (build_actual_constructor (&comp_head, &ctor_head, sym) == FAILURE)\n+  if (!build_actual_constructor (&comp_head, &ctor_head, sym))\n     goto cleanup;\n \n   /* No component should be left, as this should have caused an error in the\n@@ -2585,7 +2579,7 @@ gfc_convert_to_structure_constructor (gfc_expr *e, gfc_symbol *sym, gfc_expr **c\n   gfc_current_locus = old_locus; \n   if (parent)\n     *arglist = actual;\n-  return SUCCESS;\n+  return true;\n \n   cleanup:\n   gfc_current_locus = old_locus; \n@@ -2598,7 +2592,7 @@ gfc_convert_to_structure_constructor (gfc_expr *e, gfc_symbol *sym, gfc_expr **c\n     }\n   gfc_constructor_free (ctor_head);\n \n-  return FAILURE;\n+  return false;\n }\n \n \n@@ -2627,8 +2621,7 @@ gfc_match_structure_constructor (gfc_symbol *sym, gfc_expr **result)\n        return m;\n      }\n \n-   if (gfc_convert_to_structure_constructor (e, sym, NULL, NULL, false)\n-       != SUCCESS)\n+   if (!gfc_convert_to_structure_constructor (e, sym, NULL, NULL, false))\n      {\n        gfc_free_expr (e);\n        return MATCH_ERROR;\n@@ -2664,7 +2657,7 @@ check_for_implicit_index (gfc_symtree **st, gfc_symbol **sym)\n /* Procedure pointer as function result: Replace the function symbol by the\n    auto-generated hidden result variable named \"ppr@\".  */\n \n-static gfc_try\n+static bool\n replace_hidden_procptr_result (gfc_symbol **sym, gfc_symtree **st)\n {\n   /* Check for procedure pointer result variable.  */\n@@ -2679,9 +2672,9 @@ replace_hidden_procptr_result (gfc_symbol **sym, gfc_symtree **st)\n       (*sym)->result->attr.referenced = (*sym)->attr.referenced;\n       *sym = (*sym)->result;\n       *st = gfc_find_symtree ((*sym)->ns->sym_root, (*sym)->name);\n-      return SUCCESS;\n+      return true;\n     }\n-  return FAILURE;\n+  return false;\n }\n \n \n@@ -2708,7 +2701,7 @@ gfc_match_rvalue (gfc_expr **result)\n   if (m != MATCH_YES)\n     return m;\n \n-  if (gfc_find_state (COMP_INTERFACE) == SUCCESS\n+  if (gfc_find_state (COMP_INTERFACE)\n       && !gfc_current_ns->has_import_set)\n     i = gfc_get_sym_tree (name, NULL, &symtree, false);\n   else\n@@ -2854,8 +2847,7 @@ gfc_match_rvalue (gfc_expr **result)\n \t  m = gfc_match_varspec (e, 0, false, true);\n \t  if (!e->ref && sym->attr.flavor == FL_UNKNOWN\n \t      && sym->ts.type == BT_UNKNOWN\n-\t      && gfc_add_flavor (&sym->attr, FL_PROCEDURE,\n-\t\t\t\t sym->name, NULL) == FAILURE)\n+\t      && !gfc_add_flavor (&sym->attr, FL_PROCEDURE, sym->name, NULL))\n \t    {\n \t      m = MATCH_ERROR;\n \t      break;\n@@ -2930,7 +2922,7 @@ gfc_match_rvalue (gfc_expr **result)\n \te->rank = sym->as->rank;\n \n       if (!sym->attr.function\n-\t  && gfc_add_function (&sym->attr, sym->name, NULL) == FAILURE)\n+\t  && !gfc_add_function (&sym->attr, sym->name, NULL))\n \t{\n \t  m = MATCH_ERROR;\n \t  break;\n@@ -2977,8 +2969,7 @@ gfc_match_rvalue (gfc_expr **result)\n \n       if (sym->attr.dimension || sym->attr.codimension)\n \t{\n-\t  if (gfc_add_flavor (&sym->attr, FL_VARIABLE,\n-\t\t\t      sym->name, NULL) == FAILURE)\n+\t  if (!gfc_add_flavor (&sym->attr, FL_VARIABLE, sym->name, NULL))\n \t    {\n \t      m = MATCH_ERROR;\n \t      break;\n@@ -2995,8 +2986,7 @@ gfc_match_rvalue (gfc_expr **result)\n \t  && (CLASS_DATA (sym)->attr.dimension\n \t      || CLASS_DATA (sym)->attr.codimension))\n \t{\n-\t  if (gfc_add_flavor (&sym->attr, FL_VARIABLE,\n-\t\t\t      sym->name, NULL) == FAILURE)\n+\t  if (!gfc_add_flavor (&sym->attr, FL_VARIABLE, sym->name, NULL))\n \t    {\n \t      m = MATCH_ERROR;\n \t      break;\n@@ -3021,8 +3011,7 @@ gfc_match_rvalue (gfc_expr **result)\n \t  e->symtree = symtree;\n \t  e->expr_type = EXPR_VARIABLE;\n \n-\t  if (gfc_add_flavor (&sym->attr, FL_VARIABLE,\n-\t\t\t      sym->name, NULL) == FAILURE)\n+\t  if (!gfc_add_flavor (&sym->attr, FL_VARIABLE, sym->name, NULL))\n \t    {\n \t      m = MATCH_ERROR;\n \t      break;\n@@ -3069,15 +3058,15 @@ gfc_match_rvalue (gfc_expr **result)\n \t      e->expr_type = EXPR_VARIABLE;\n \n \t      if (sym->attr.flavor != FL_VARIABLE\n-\t\t  && gfc_add_flavor (&sym->attr, FL_VARIABLE,\n-\t\t\t\t     sym->name, NULL) == FAILURE)\n+\t\t  && !gfc_add_flavor (&sym->attr, FL_VARIABLE, \n+\t\t\t\t      sym->name, NULL))\n \t\t{\n \t\t  m = MATCH_ERROR;\n \t\t  break;\n \t\t}\n \n \t      if (sym->ts.type == BT_UNKNOWN\n-\t\t  && gfc_set_default_type (sym, 1, NULL) == FAILURE)\n+\t\t  && !gfc_set_default_type (sym, 1, NULL))\n \t\t{\n \t\t  m = MATCH_ERROR;\n \t\t  break;\n@@ -3098,7 +3087,7 @@ gfc_match_rvalue (gfc_expr **result)\n       e->expr_type = EXPR_FUNCTION;\n \n       if (!sym->attr.function\n-\t  && gfc_add_function (&sym->attr, sym->name, NULL) == FAILURE)\n+\t  && !gfc_add_function (&sym->attr, sym->name, NULL))\n \t{\n \t  m = MATCH_ERROR;\n \t  break;\n@@ -3233,7 +3222,7 @@ match_variable (gfc_expr **result, int equiv_flag, int host_flag)\n \t  flavor = FL_VARIABLE;\n \n \tif (flavor != FL_UNKNOWN\n-\t    && gfc_add_flavor (&sym->attr, flavor, sym->name, NULL) == FAILURE)\n+\t    && !gfc_add_flavor (&sym->attr, flavor, sym->name, NULL))\n \t  return MATCH_ERROR;\n       }\n       break;\n@@ -3269,7 +3258,7 @@ match_variable (gfc_expr **result, int equiv_flag, int host_flag)\n \t}\n \n       if (sym->attr.proc_pointer\n-\t  || replace_hidden_procptr_result (&sym, &st) == SUCCESS)\n+\t  || replace_hidden_procptr_result (&sym, &st))\n \tbreak;\n \n       /* Fall through to error */"}, {"sha": "9098d2cc4bdb02964f6682400308067de173519c", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 853, "deletions": 873, "changes": 1726, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=524af0d6c72031c249aa737945fde6ac3d726ba2"}, {"sha": "fd8f284827c16350049983c6ef7dfcc07064b993", "filename": "gcc/fortran/scanner.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Fscanner.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Fscanner.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fscanner.c?ref=524af0d6c72031c249aa737945fde6ac3d726ba2", "patch": "@@ -326,7 +326,7 @@ add_path_to_list (gfc_directorylist **list, const char *path,\n   q = (char *) alloca (len + 1);\n   memcpy (q, p, len + 1);\n   i = len - 1;\n-  while (i >=0 && IS_DIR_SEPARATOR(q[i]))\n+  while (i >=0 && IS_DIR_SEPARATOR (q[i]))\n     q[i--] = '\\0';\n \n   if (stat (q, &st))\n@@ -1123,7 +1123,7 @@ gfc_next_char_literal (gfc_instring in_string)\n       else\n \tgfc_advance_line ();\n       \n-      if (gfc_at_eof())\n+      if (gfc_at_eof ())\n \tgoto not_continuation;\n \n       /* We've got a continuation line.  If we are on the very next line after\n@@ -1831,7 +1831,7 @@ preprocessor_line (gfc_char_t *c)\n }\n \n \n-static gfc_try load_file (const char *, const char *, bool);\n+static bool load_file (const char *, const char *, bool);\n \n /* include_line()-- Checks a line buffer to see if it is an include\n    line.  If so, we call load_file() recursively to load the included\n@@ -1902,7 +1902,7 @@ include_line (gfc_char_t *line)\n \t\t   read by anything else.  */\n \n   filename = gfc_widechar_to_char (begin, -1);\n-  if (load_file (filename, NULL, false) == FAILURE)\n+  if (!load_file (filename, NULL, false))\n     exit (FATAL_EXIT_CODE);\n \n   free (filename);\n@@ -1912,7 +1912,7 @@ include_line (gfc_char_t *line)\n \n /* Load a file into memory by calling load_line until the file ends.  */\n \n-static gfc_try\n+static bool\n load_file (const char *realfilename, const char *displayedname, bool initial)\n {\n   gfc_char_t *line;\n@@ -1936,7 +1936,7 @@ load_file (const char *realfilename, const char *displayedname, bool initial)\n \tfprintf (stderr, \"%s:%d: Error: File '%s' is being included \"\n \t\t \"recursively\\n\", current_file->filename, current_file->line,\n \t\t filename);\n-\treturn FAILURE;\n+\treturn false;\n       }\n \n   if (initial)\n@@ -1951,7 +1951,7 @@ load_file (const char *realfilename, const char *displayedname, bool initial)\n       if (input == NULL)\n \t{\n \t  gfc_error_now (\"Can't open file '%s'\", filename);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n     }\n   else\n@@ -1961,7 +1961,7 @@ load_file (const char *realfilename, const char *displayedname, bool initial)\n \t{\n \t  fprintf (stderr, \"%s:%d: Error: Can't open included file '%s'\\n\",\n \t\t   current_file->filename, current_file->line, filename);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n     }\n \n@@ -2096,19 +2096,19 @@ load_file (const char *realfilename, const char *displayedname, bool initial)\n     add_file_change (NULL, current_file->inclusion_line + 1);\n   current_file = current_file->up;\n   linemap_add (line_table, LC_LEAVE, 0, NULL, 0);\n-  return SUCCESS;\n+  return true;\n }\n \n \n-/* Open a new file and start scanning from that file. Returns SUCCESS\n-   if everything went OK, FAILURE otherwise.  If form == FORM_UNKNOWN\n+/* Open a new file and start scanning from that file. Returns true\n+   if everything went OK, false otherwise.  If form == FORM_UNKNOWN\n    it tries to determine the source form from the filename, defaulting\n    to free form.  */\n \n-gfc_try\n+bool\n gfc_new_file (void)\n {\n-  gfc_try result;\n+  bool result;\n \n   if (gfc_cpp_enabled ())\n     {"}, {"sha": "5dcbf028689a3c194f4aede247272f13e329b236", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=524af0d6c72031c249aa737945fde6ac3d726ba2", "patch": "@@ -3263,7 +3263,7 @@ simplify_bound_dim (gfc_expr *array, gfc_expr *kind, int d, int upper,\n   gcc_assert (array->expr_type == EXPR_VARIABLE);\n   gcc_assert (as);\n \n-  if (gfc_resolve_array_spec (as, 0) == FAILURE)\n+  if (!gfc_resolve_array_spec (as, 0))\n     return NULL;\n \n   /* The last dimension of an assumed-size array is special.  */\n@@ -3313,8 +3313,7 @@ simplify_bound_dim (gfc_expr *array, gfc_expr *kind, int d, int upper,\n     {\n       if (upper)\n \t{\n-\t  if (gfc_ref_dimen_size (&ref->u.ar, d-1, &result->value.integer, NULL)\n-\t      != SUCCESS)\n+\t  if (!gfc_ref_dimen_size (&ref->u.ar, d - 1, &result->value.integer, NULL))\n \t    goto returnNull;\n \t}\n       else\n@@ -4078,7 +4077,7 @@ min_max_choose (gfc_expr *arg, gfc_expr *extremum, int sign)\n       case BT_CHARACTER:\n #define LENGTH(x) ((x)->value.character.length)\n #define STRING(x) ((x)->value.character.string)\n-\tif (LENGTH(extremum) < LENGTH(arg))\n+\tif (LENGTH (extremum) < LENGTH(arg))\n \t  {\n \t    gfc_char_t *tmp = STRING(extremum);\n \n@@ -4629,10 +4628,10 @@ gfc_simplify_pack (gfc_expr *array, gfc_expr *mask, gfc_expr *vector)\n   gfc_expr *result;\n   gfc_constructor *array_ctor, *mask_ctor, *vector_ctor;\n \n-  if (!is_constant_array_expr(array)\n-      || !is_constant_array_expr(vector)\n+  if (!is_constant_array_expr (array)\n+      || !is_constant_array_expr (vector)\n       || (!gfc_is_constant_expr (mask)\n-          && !is_constant_array_expr(mask)))\n+          && !is_constant_array_expr (mask)))\n     return NULL;\n \n   result = gfc_get_array_expr (array->ts.type, array->ts.kind, &array->where);\n@@ -5506,7 +5505,7 @@ gfc_simplify_shape (gfc_expr *source, gfc_expr *kind)\n   gfc_expr *result, *e, *f;\n   gfc_array_ref *ar;\n   int n;\n-  gfc_try t;\n+  bool t;\n   int k = get_kind (BT_INTEGER, kind, \"SHAPE\", gfc_default_integer_kind);\n \n   if (source->rank == -1)\n@@ -5524,21 +5523,21 @@ gfc_simplify_shape (gfc_expr *source, gfc_expr *kind)\n     }\n   else if (source->shape)\n     {\n-      t = SUCCESS;\n+      t = true;\n       for (n = 0; n < source->rank; n++)\n \t{\n \t  mpz_init (shape[n]);\n \t  mpz_set (shape[n], source->shape[n]);\n \t}\n     }\n   else\n-    t = FAILURE;\n+    t = false;\n \n   for (n = 0; n < source->rank; n++)\n     {\n       e = gfc_get_constant_expr (BT_INTEGER, k, &source->where);\n \n-      if (t == SUCCESS)\n+      if (t)\n \t{\n \t  mpz_set (e->value.integer, shape[n]);\n \t  mpz_clear (shape[n]);\n@@ -5631,7 +5630,7 @@ gfc_simplify_size (gfc_expr *array, gfc_expr *dim, gfc_expr *kind)\n \n   if (dim == NULL)\n     {\n-      if (gfc_array_size (array, &size) == FAILURE)\n+      if (!gfc_array_size (array, &size))\n \treturn NULL;\n     }\n   else\n@@ -5640,7 +5639,7 @@ gfc_simplify_size (gfc_expr *array, gfc_expr *dim, gfc_expr *kind)\n \treturn NULL;\n \n       d = mpz_get_ui (dim->value.integer) - 1;\n-      if (gfc_array_dimen_size (array, d, &size) == FAILURE)\n+      if (!gfc_array_dimen_size (array, d, &size))\n \treturn NULL;\n     }\n \n@@ -5668,7 +5667,7 @@ gfc_simplify_sizeof (gfc_expr *x)\n     return NULL;\n \n   if (x->rank && x->expr_type != EXPR_ARRAY\n-      && gfc_array_size (x, &array_size) == FAILURE)\n+      && !gfc_array_size (x, &array_size))\n     return NULL;\n \n   result = gfc_get_constant_expr (BT_INTEGER, gfc_index_integer_kind,\n@@ -5897,7 +5896,7 @@ gfc_simplify_spread (gfc_expr *source, gfc_expr *dim_expr, gfc_expr *ncopies_exp\n      constructor.  */\n   if (source->expr_type == EXPR_ARRAY)\n     {\n-      if (gfc_array_size (source, &size) == FAILURE)\n+      if (!gfc_array_size (source, &size))\n \tgfc_internal_error (\"Failure getting length of a constant array.\");\n     }\n   else\n@@ -6123,13 +6122,13 @@ gfc_simplify_transfer (gfc_expr *source, gfc_expr *mold, gfc_expr *size)\n \t|| !gfc_is_constant_expr (size))\n     return NULL;\n \n-  if (gfc_calculate_transfer_sizes (source, mold, size, &source_size,\n-\t\t\t\t    &result_size, &result_length) == FAILURE)\n+  if (!gfc_calculate_transfer_sizes (source, mold, size, &source_size, \n+\t\t\t\t     &result_size, &result_length))\n     return NULL;\n \n   /* Calculate the size of the source.  */\n   if (source->expr_type == EXPR_ARRAY\n-      && gfc_array_size (source, &tmp) == FAILURE)\n+      && !gfc_array_size (source, &tmp))\n     gfc_internal_error (\"Failure getting length of a constant array.\");\n \n   /* Create an empty new expression with the appropriate characteristics.  */\n@@ -6395,7 +6394,7 @@ gfc_simplify_unpack (gfc_expr *vector, gfc_expr *mask, gfc_expr *field)\n   if (!is_constant_array_expr (vector)\n       || !is_constant_array_expr (mask)\n       || (!gfc_is_constant_expr (field)\n-\t  && !is_constant_array_expr(field)))\n+\t  && !is_constant_array_expr (field)))\n     return NULL;\n \n   result = gfc_get_array_expr (vector->ts.type, vector->ts.kind,"}, {"sha": "c72974dc00338f1fd5d53ac62f39f9f745b593a6", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 256, "deletions": 267, "changes": 523, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=524af0d6c72031c249aa737945fde6ac3d726ba2", "patch": "@@ -148,7 +148,7 @@ gfc_clear_new_implicit (void)\n \n /* Prepare for a new implicit range.  Sets flags in new_flag[].  */\n \n-gfc_try\n+bool\n gfc_add_new_implicit_range (int c1, int c2)\n {\n   int i;\n@@ -162,28 +162,28 @@ gfc_add_new_implicit_range (int c1, int c2)\n \t{\n \t  gfc_error (\"Letter '%c' already set in IMPLICIT statement at %C\",\n \t\t     i + 'A');\n-\t  return FAILURE;\n+\t  return false;\n \t}\n \n       new_flag[i] = 1;\n     }\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n /* Add a matched implicit range for gfc_set_implicit().  Check if merging\n    the new implicit types back into the existing types will work.  */\n \n-gfc_try\n+bool\n gfc_merge_new_implicit (gfc_typespec *ts)\n {\n   int i;\n \n   if (gfc_current_ns->seen_implicit_none)\n     {\n       gfc_error (\"Cannot specify IMPLICIT at %C after IMPLICIT NONE\");\n-      return FAILURE;\n+      return false;\n     }\n \n   for (i = 0; i < GFC_LETTERS; i++)\n@@ -194,15 +194,15 @@ gfc_merge_new_implicit (gfc_typespec *ts)\n \t    {\n \t      gfc_error (\"Letter %c already has an IMPLICIT type at %C\",\n \t\t\t i + 'A');\n-\t      return FAILURE;\n+\t      return false;\n \t    }\n \n \t  gfc_current_ns->default_type[i] = *ts;\n \t  gfc_current_ns->implicit_loc[i] = gfc_current_locus;\n \t  gfc_current_ns->set_flag[i] = 1;\n \t}\n     }\n-  return SUCCESS;\n+  return true;\n }\n \n \n@@ -234,7 +234,7 @@ gfc_get_default_type (const char *name, gfc_namespace *ns)\n    letter of its name.  Fails if the letter in question has no default\n    type.  */\n \n-gfc_try\n+bool\n gfc_set_default_type (gfc_symbol *sym, int error_flag, gfc_namespace *ns)\n {\n   gfc_typespec *ts;\n@@ -253,7 +253,7 @@ gfc_set_default_type (gfc_symbol *sym, int error_flag, gfc_namespace *ns)\n \t  sym->attr.untyped = 1; /* Ensure we only give an error once.  */\n \t}\n \n-      return FAILURE;\n+      return false;\n     }\n \n   sym->ts = *ts;\n@@ -262,9 +262,8 @@ gfc_set_default_type (gfc_symbol *sym, int error_flag, gfc_namespace *ns)\n   if (ts->type == BT_CHARACTER && ts->u.cl)\n     sym->ts.u.cl = gfc_new_charlen (sym->ns, ts->u.cl);\n   else if (ts->type == BT_CLASS\n-\t   && gfc_build_class_symbol (&sym->ts, &sym->attr,\n-\t\t\t\t      &sym->as, false) == FAILURE)\n-    return FAILURE;\n+\t   && !gfc_build_class_symbol (&sym->ts, &sym->attr, &sym->as, false))\n+    return false;\n \n   if (sym->attr.is_bind_c == 1 && gfc_option.warn_c_binding_type)\n     {\n@@ -293,7 +292,7 @@ gfc_set_default_type (gfc_symbol *sym, int error_flag, gfc_namespace *ns)\n         }\n     }\n   \n-  return SUCCESS;\n+  return true;\n }\n \n \n@@ -311,8 +310,7 @@ gfc_check_function_type (gfc_namespace *ns)\n \n   if (proc->result->ts.type == BT_UNKNOWN && proc->result->ts.interface == NULL)\n     {\n-      if (gfc_set_default_type (proc->result, 0, gfc_current_ns)\n-\t\t== SUCCESS)\n+      if (gfc_set_default_type (proc->result, 0, gfc_current_ns))\n \t{\n \t  if (proc->result != proc)\n \t    {\n@@ -348,7 +346,7 @@ gfc_check_function_type (gfc_namespace *ns)\n                                 goto conflict_std;\\\n                               }\n \n-static gfc_try\n+static bool\n check_conflict (symbol_attribute *attr, const char *name, locus *where)\n {\n   static const char *dummy = \"DUMMY\", *save = \"SAVE\", *pointer = \"POINTER\",\n@@ -416,7 +414,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n \t  gfc_error\n \t    (\"%s attribute not allowed in BLOCK DATA program unit at %L\",\n \t     a1, where);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n     }\n \n@@ -440,7 +438,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n \t  case FL_NAMELIST:\n \t    gfc_error (\"Namelist group name at %L cannot have the \"\n \t\t       \"SAVE attribute\", where);\n-\t    return FAILURE; \n+\t    return false; \n \t    break;\n \t  case FL_PROCEDURE:\n \t    /* Conflicts between SAVE and PROCEDURE will be checked at\n@@ -471,9 +469,9 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n   if ((attr->if_source == IFSRC_DECL && !attr->procedure) || attr->contained)\n     conf (external, subroutine);\n \n-  if (attr->proc_pointer && gfc_notify_std (GFC_STD_F2003,\n-\t\t\t    \"Procedure pointer at %C\") == FAILURE)\n-    return FAILURE;\n+  if (attr->proc_pointer && !gfc_notify_std (GFC_STD_F2003, \n+\t\t\t\t\t     \"Procedure pointer at %C\"))\n+    return false;\n \n   conf (allocatable, pointer);\n   conf_std (allocatable, dummy, GFC_STD_F2003);\n@@ -636,13 +634,13 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n \t  a2 = attr->access == ACCESS_PUBLIC ? publik : privat;\n \t  gfc_error (\"%s attribute applied to %s %s at %L\", a2, a1,\n \t    name, where);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n \n       if (attr->is_bind_c)\n \t{\n \t  gfc_error_now (\"BIND(C) applied to %s %s at %L\", a1, name, where);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n \n       break;\n@@ -748,7 +746,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n       break;\n     }\n \n-  return SUCCESS;\n+  return true;\n \n conflict:\n   if (name == NULL)\n@@ -758,7 +756,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n     gfc_error (\"%s attribute conflicts with %s attribute in '%s' at %L\",\n \t       a1, a2, name, where);\n \n-  return FAILURE;\n+  return false;\n \n conflict_std:\n   if (name == NULL)\n@@ -836,129 +834,129 @@ duplicate_attr (const char *attr, locus *where)\n }\n \n \n-gfc_try\n+bool\n gfc_add_ext_attribute (symbol_attribute *attr, ext_attr_id_t ext_attr,\n \t\t       locus *where ATTRIBUTE_UNUSED)\n {\n   attr->ext_attr |= 1 << ext_attr;\n-  return SUCCESS;\n+  return true;\n }\n \n \n /* Called from decl.c (attr_decl1) to check attributes, when declared\n    separately.  */\n \n-gfc_try\n+bool\n gfc_add_attribute (symbol_attribute *attr, locus *where)\n {\n   if (check_used (attr, NULL, where))\n-    return FAILURE;\n+    return false;\n \n   return check_conflict (attr, NULL, where);\n }\n \n \n-gfc_try\n+bool\n gfc_add_allocatable (symbol_attribute *attr, locus *where)\n {\n \n   if (check_used (attr, NULL, where))\n-    return FAILURE;\n+    return false;\n \n   if (attr->allocatable)\n     {\n       duplicate_attr (\"ALLOCATABLE\", where);\n-      return FAILURE;\n+      return false;\n     }\n \n   if (attr->flavor == FL_PROCEDURE && attr->if_source == IFSRC_IFBODY\n-      && gfc_find_state (COMP_INTERFACE) == FAILURE)\n+      && !gfc_find_state (COMP_INTERFACE))\n     {\n       gfc_error (\"ALLOCATABLE specified outside of INTERFACE body at %L\",\n \t\t where);\n-      return FAILURE;\n+      return false;\n     }\n \n   attr->allocatable = 1;\n   return check_conflict (attr, NULL, where);\n }\n \n \n-gfc_try\n+bool\n gfc_add_codimension (symbol_attribute *attr, const char *name, locus *where)\n {\n \n   if (check_used (attr, name, where))\n-    return FAILURE;\n+    return false;\n \n   if (attr->codimension)\n     {\n       duplicate_attr (\"CODIMENSION\", where);\n-      return FAILURE;\n+      return false;\n     }\n \n   if (attr->flavor == FL_PROCEDURE && attr->if_source == IFSRC_IFBODY\n-      && gfc_find_state (COMP_INTERFACE) == FAILURE)\n+      && !gfc_find_state (COMP_INTERFACE))\n     {\n       gfc_error (\"CODIMENSION specified for '%s' outside its INTERFACE body \"\n \t\t \"at %L\", name, where);\n-      return FAILURE;\n+      return false;\n     }\n \n   attr->codimension = 1;\n   return check_conflict (attr, name, where);\n }\n \n \n-gfc_try\n+bool\n gfc_add_dimension (symbol_attribute *attr, const char *name, locus *where)\n {\n \n   if (check_used (attr, name, where))\n-    return FAILURE;\n+    return false;\n \n   if (attr->dimension)\n     {\n       duplicate_attr (\"DIMENSION\", where);\n-      return FAILURE;\n+      return false;\n     }\n \n   if (attr->flavor == FL_PROCEDURE && attr->if_source == IFSRC_IFBODY\n-      && gfc_find_state (COMP_INTERFACE) == FAILURE)\n+      && !gfc_find_state (COMP_INTERFACE))\n     {\n       gfc_error (\"DIMENSION specified for '%s' outside its INTERFACE body \"\n \t\t \"at %L\", name, where);\n-      return FAILURE;\n+      return false;\n     }\n \n   attr->dimension = 1;\n   return check_conflict (attr, name, where);\n }\n \n \n-gfc_try\n+bool\n gfc_add_contiguous (symbol_attribute *attr, const char *name, locus *where)\n {\n \n   if (check_used (attr, name, where))\n-    return FAILURE;\n+    return false;\n \n   attr->contiguous = 1;\n   return check_conflict (attr, name, where);\n }\n \n \n-gfc_try\n+bool\n gfc_add_external (symbol_attribute *attr, locus *where)\n {\n \n   if (check_used (attr, NULL, where))\n-    return FAILURE;\n+    return false;\n \n   if (attr->external)\n     {\n       duplicate_attr (\"EXTERNAL\", where);\n-      return FAILURE;\n+      return false;\n     }\n \n   if (attr->pointer && attr->if_source != IFSRC_IFBODY)\n@@ -973,17 +971,17 @@ gfc_add_external (symbol_attribute *attr, locus *where)\n }\n \n \n-gfc_try\n+bool\n gfc_add_intrinsic (symbol_attribute *attr, locus *where)\n {\n \n   if (check_used (attr, NULL, where))\n-    return FAILURE;\n+    return false;\n \n   if (attr->intrinsic)\n     {\n       duplicate_attr (\"INTRINSIC\", where);\n-      return FAILURE;\n+      return false;\n     }\n \n   attr->intrinsic = 1;\n@@ -992,41 +990,41 @@ gfc_add_intrinsic (symbol_attribute *attr, locus *where)\n }\n \n \n-gfc_try\n+bool\n gfc_add_optional (symbol_attribute *attr, locus *where)\n {\n \n   if (check_used (attr, NULL, where))\n-    return FAILURE;\n+    return false;\n \n   if (attr->optional)\n     {\n       duplicate_attr (\"OPTIONAL\", where);\n-      return FAILURE;\n+      return false;\n     }\n \n   attr->optional = 1;\n   return check_conflict (attr, NULL, where);\n }\n \n \n-gfc_try\n+bool\n gfc_add_pointer (symbol_attribute *attr, locus *where)\n {\n \n   if (check_used (attr, NULL, where))\n-    return FAILURE;\n+    return false;\n \n   if (attr->pointer && !(attr->if_source == IFSRC_IFBODY\n-      && gfc_find_state (COMP_INTERFACE) == FAILURE))\n+      && !gfc_find_state (COMP_INTERFACE)))\n     {\n       duplicate_attr (\"POINTER\", where);\n-      return FAILURE;\n+      return false;\n     }\n \n   if (attr->procedure || (attr->external && attr->if_source != IFSRC_IFBODY)\n       || (attr->if_source == IFSRC_IFBODY\n-      && gfc_find_state (COMP_INTERFACE) == FAILURE))\n+      && !gfc_find_state (COMP_INTERFACE)))\n     attr->proc_pointer = 1;\n   else\n     attr->pointer = 1;\n@@ -1035,252 +1033,249 @@ gfc_add_pointer (symbol_attribute *attr, locus *where)\n }\n \n \n-gfc_try\n+bool\n gfc_add_cray_pointer (symbol_attribute *attr, locus *where)\n {\n \n   if (check_used (attr, NULL, where))\n-    return FAILURE;\n+    return false;\n \n   attr->cray_pointer = 1;\n   return check_conflict (attr, NULL, where);\n }\n \n \n-gfc_try\n+bool\n gfc_add_cray_pointee (symbol_attribute *attr, locus *where)\n {\n \n   if (check_used (attr, NULL, where))\n-    return FAILURE;\n+    return false;\n \n   if (attr->cray_pointee)\n     {\n       gfc_error (\"Cray Pointee at %L appears in multiple pointer()\"\n \t\t \" statements\", where);\n-      return FAILURE;\n+      return false;\n     }\n \n   attr->cray_pointee = 1;\n   return check_conflict (attr, NULL, where);\n }\n \n \n-gfc_try\n+bool\n gfc_add_protected (symbol_attribute *attr, const char *name, locus *where)\n {\n   if (check_used (attr, name, where))\n-    return FAILURE;\n+    return false;\n \n   if (attr->is_protected)\n     {\n-\tif (gfc_notify_std (GFC_STD_LEGACY, \n-\t\t\t    \"Duplicate PROTECTED attribute specified at %L\",\n-\t\t\t    where) \n-\t    == FAILURE)\n-\t  return FAILURE;\n+\tif (!gfc_notify_std (GFC_STD_LEGACY, \n+\t\t\t     \"Duplicate PROTECTED attribute specified at %L\", \n+\t\t\t     where))\n+\t  return false;\n     }\n \n   attr->is_protected = 1;\n   return check_conflict (attr, name, where);\n }\n \n \n-gfc_try\n+bool\n gfc_add_result (symbol_attribute *attr, const char *name, locus *where)\n {\n \n   if (check_used (attr, name, where))\n-    return FAILURE;\n+    return false;\n \n   attr->result = 1;\n   return check_conflict (attr, name, where);\n }\n \n \n-gfc_try\n+bool\n gfc_add_save (symbol_attribute *attr, save_state s, const char *name,\n \t      locus *where)\n {\n \n   if (check_used (attr, name, where))\n-    return FAILURE;\n+    return false;\n \n   if (s == SAVE_EXPLICIT && gfc_pure (NULL))\n     {\n       gfc_error\n \t(\"SAVE attribute at %L cannot be specified in a PURE procedure\",\n \t where);\n-      return FAILURE;\n+      return false;\n     }\n \n   if (s == SAVE_EXPLICIT && gfc_implicit_pure (NULL))\n     gfc_current_ns->proc_name->attr.implicit_pure = 0;\n \n   if (s == SAVE_EXPLICIT && attr->save == SAVE_EXPLICIT)\n     {\n-\tif (gfc_notify_std (GFC_STD_LEGACY, \n-\t\t\t    \"Duplicate SAVE attribute specified at %L\",\n-\t\t\t    where) \n-\t    == FAILURE)\n-\t  return FAILURE;\n+\tif (!gfc_notify_std (GFC_STD_LEGACY, \n+\t\t\t     \"Duplicate SAVE attribute specified at %L\", \n+\t\t\t     where))\n+\t  return false;\n     }\n \n   attr->save = s;\n   return check_conflict (attr, name, where);\n }\n \n \n-gfc_try\n+bool\n gfc_add_value (symbol_attribute *attr, const char *name, locus *where)\n {\n \n   if (check_used (attr, name, where))\n-    return FAILURE;\n+    return false;\n \n   if (attr->value)\n     {\n-\tif (gfc_notify_std (GFC_STD_LEGACY, \n-\t\t\t    \"Duplicate VALUE attribute specified at %L\",\n-\t\t\t    where) \n-\t    == FAILURE)\n-\t  return FAILURE;\n+\tif (!gfc_notify_std (GFC_STD_LEGACY, \n+\t\t\t     \"Duplicate VALUE attribute specified at %L\", \n+\t\t\t     where))\n+\t  return false;\n     }\n \n   attr->value = 1;\n   return check_conflict (attr, name, where);\n }\n \n \n-gfc_try\n+bool\n gfc_add_volatile (symbol_attribute *attr, const char *name, locus *where)\n {\n   /* No check_used needed as 11.2.1 of the F2003 standard allows\n      that the local identifier made accessible by a use statement can be\n      given a VOLATILE attribute - unless it is a coarray (F2008, C560).  */\n \n   if (attr->volatile_ && attr->volatile_ns == gfc_current_ns)\n-    if (gfc_notify_std (GFC_STD_LEGACY, \n-        \t\t\"Duplicate VOLATILE attribute specified at %L\", where)\n-        == FAILURE)\n-      return FAILURE;\n+    if (!gfc_notify_std (GFC_STD_LEGACY, \n+\t\t\t \"Duplicate VOLATILE attribute specified at %L\", \n+\t\t\t where))\n+      return false;\n \n   attr->volatile_ = 1;\n   attr->volatile_ns = gfc_current_ns;\n   return check_conflict (attr, name, where);\n }\n \n \n-gfc_try\n+bool\n gfc_add_asynchronous (symbol_attribute *attr, const char *name, locus *where)\n {\n   /* No check_used needed as 11.2.1 of the F2003 standard allows\n      that the local identifier made accessible by a use statement can be\n      given a ASYNCHRONOUS attribute.  */\n \n   if (attr->asynchronous && attr->asynchronous_ns == gfc_current_ns)\n-    if (gfc_notify_std (GFC_STD_LEGACY, \n-        \t\t\"Duplicate ASYNCHRONOUS attribute specified at %L\",\n-\t\t\twhere) == FAILURE)\n-      return FAILURE;\n+    if (!gfc_notify_std (GFC_STD_LEGACY, \n+\t\t\t \"Duplicate ASYNCHRONOUS attribute specified at %L\", \n+\t\t\t where))\n+      return false;\n \n   attr->asynchronous = 1;\n   attr->asynchronous_ns = gfc_current_ns;\n   return check_conflict (attr, name, where);\n }\n \n \n-gfc_try\n+bool\n gfc_add_threadprivate (symbol_attribute *attr, const char *name, locus *where)\n {\n \n   if (check_used (attr, name, where))\n-    return FAILURE;\n+    return false;\n \n   if (attr->threadprivate)\n     {\n       duplicate_attr (\"THREADPRIVATE\", where);\n-      return FAILURE;\n+      return false;\n     }\n \n   attr->threadprivate = 1;\n   return check_conflict (attr, name, where);\n }\n \n \n-gfc_try\n+bool\n gfc_add_target (symbol_attribute *attr, locus *where)\n {\n \n   if (check_used (attr, NULL, where))\n-    return FAILURE;\n+    return false;\n \n   if (attr->target)\n     {\n       duplicate_attr (\"TARGET\", where);\n-      return FAILURE;\n+      return false;\n     }\n \n   attr->target = 1;\n   return check_conflict (attr, NULL, where);\n }\n \n \n-gfc_try\n+bool\n gfc_add_dummy (symbol_attribute *attr, const char *name, locus *where)\n {\n \n   if (check_used (attr, name, where))\n-    return FAILURE;\n+    return false;\n \n   /* Duplicate dummy arguments are allowed due to ENTRY statements.  */\n   attr->dummy = 1;\n   return check_conflict (attr, name, where);\n }\n \n \n-gfc_try\n+bool\n gfc_add_in_common (symbol_attribute *attr, const char *name, locus *where)\n {\n \n   if (check_used (attr, name, where))\n-    return FAILURE;\n+    return false;\n \n   /* Duplicate attribute already checked for.  */\n   attr->in_common = 1;\n   return check_conflict (attr, name, where);\n }\n \n \n-gfc_try\n+bool\n gfc_add_in_equivalence (symbol_attribute *attr, const char *name, locus *where)\n {\n \n   /* Duplicate attribute already checked for.  */\n   attr->in_equivalence = 1;\n-  if (check_conflict (attr, name, where) == FAILURE)\n-    return FAILURE;\n+  if (!check_conflict (attr, name, where))\n+    return false;\n \n   if (attr->flavor == FL_VARIABLE)\n-    return SUCCESS;\n+    return true;\n \n   return gfc_add_flavor (attr, FL_VARIABLE, name, where);\n }\n \n \n-gfc_try\n+bool\n gfc_add_data (symbol_attribute *attr, const char *name, locus *where)\n {\n \n   if (check_used (attr, name, where))\n-    return FAILURE;\n+    return false;\n \n   attr->data = 1;\n   return check_conflict (attr, name, where);\n }\n \n \n-gfc_try\n+bool\n gfc_add_in_namelist (symbol_attribute *attr, const char *name, locus *where)\n {\n \n@@ -1289,144 +1284,144 @@ gfc_add_in_namelist (symbol_attribute *attr, const char *name, locus *where)\n }\n \n \n-gfc_try\n+bool\n gfc_add_sequence (symbol_attribute *attr, const char *name, locus *where)\n {\n \n   if (check_used (attr, name, where))\n-    return FAILURE;\n+    return false;\n \n   attr->sequence = 1;\n   return check_conflict (attr, name, where);\n }\n \n \n-gfc_try\n+bool\n gfc_add_elemental (symbol_attribute *attr, locus *where)\n {\n \n   if (check_used (attr, NULL, where))\n-    return FAILURE;\n+    return false;\n \n   if (attr->elemental)\n     {\n       duplicate_attr (\"ELEMENTAL\", where);\n-      return FAILURE;\n+      return false;\n     }\n \n   attr->elemental = 1;\n   return check_conflict (attr, NULL, where);\n }\n \n \n-gfc_try\n+bool\n gfc_add_pure (symbol_attribute *attr, locus *where)\n {\n \n   if (check_used (attr, NULL, where))\n-    return FAILURE;\n+    return false;\n \n   if (attr->pure)\n     {\n       duplicate_attr (\"PURE\", where);\n-      return FAILURE;\n+      return false;\n     }\n \n   attr->pure = 1;\n   return check_conflict (attr, NULL, where);\n }\n \n \n-gfc_try\n+bool\n gfc_add_recursive (symbol_attribute *attr, locus *where)\n {\n \n   if (check_used (attr, NULL, where))\n-    return FAILURE;\n+    return false;\n \n   if (attr->recursive)\n     {\n       duplicate_attr (\"RECURSIVE\", where);\n-      return FAILURE;\n+      return false;\n     }\n \n   attr->recursive = 1;\n   return check_conflict (attr, NULL, where);\n }\n \n \n-gfc_try\n+bool\n gfc_add_entry (symbol_attribute *attr, const char *name, locus *where)\n {\n \n   if (check_used (attr, name, where))\n-    return FAILURE;\n+    return false;\n \n   if (attr->entry)\n     {\n       duplicate_attr (\"ENTRY\", where);\n-      return FAILURE;\n+      return false;\n     }\n \n   attr->entry = 1;\n   return check_conflict (attr, name, where);\n }\n \n \n-gfc_try\n+bool\n gfc_add_function (symbol_attribute *attr, const char *name, locus *where)\n {\n \n   if (attr->flavor != FL_PROCEDURE\n-      && gfc_add_flavor (attr, FL_PROCEDURE, name, where) == FAILURE)\n-    return FAILURE;\n+      && !gfc_add_flavor (attr, FL_PROCEDURE, name, where))\n+    return false;\n \n   attr->function = 1;\n   return check_conflict (attr, name, where);\n }\n \n \n-gfc_try\n+bool\n gfc_add_subroutine (symbol_attribute *attr, const char *name, locus *where)\n {\n \n   if (attr->flavor != FL_PROCEDURE\n-      && gfc_add_flavor (attr, FL_PROCEDURE, name, where) == FAILURE)\n-    return FAILURE;\n+      && !gfc_add_flavor (attr, FL_PROCEDURE, name, where))\n+    return false;\n \n   attr->subroutine = 1;\n   return check_conflict (attr, name, where);\n }\n \n \n-gfc_try\n+bool\n gfc_add_generic (symbol_attribute *attr, const char *name, locus *where)\n {\n \n   if (attr->flavor != FL_PROCEDURE\n-      && gfc_add_flavor (attr, FL_PROCEDURE, name, where) == FAILURE)\n-    return FAILURE;\n+      && !gfc_add_flavor (attr, FL_PROCEDURE, name, where))\n+    return false;\n \n   attr->generic = 1;\n   return check_conflict (attr, name, where);\n }\n \n \n-gfc_try\n+bool\n gfc_add_proc (symbol_attribute *attr, const char *name, locus *where)\n {\n \n   if (check_used (attr, NULL, where))\n-    return FAILURE;\n+    return false;\n \n   if (attr->flavor != FL_PROCEDURE\n-      && gfc_add_flavor (attr, FL_PROCEDURE, name, where) == FAILURE)\n-    return FAILURE;\n+      && !gfc_add_flavor (attr, FL_PROCEDURE, name, where))\n+    return false;\n \n   if (attr->procedure)\n     {\n       duplicate_attr (\"PROCEDURE\", where);\n-      return FAILURE;\n+      return false;\n     }\n \n   attr->procedure = 1;\n@@ -1435,35 +1430,35 @@ gfc_add_proc (symbol_attribute *attr, const char *name, locus *where)\n }\n \n \n-gfc_try\n+bool\n gfc_add_abstract (symbol_attribute* attr, locus* where)\n {\n   if (attr->abstract)\n     {\n       duplicate_attr (\"ABSTRACT\", where);\n-      return FAILURE;\n+      return false;\n     }\n \n   attr->abstract = 1;\n-  return SUCCESS;\n+  return true;\n }\n \n \n /* Flavors are special because some flavors are not what Fortran\n    considers attributes and can be reaffirmed multiple times.  */\n \n-gfc_try\n+bool\n gfc_add_flavor (symbol_attribute *attr, sym_flavor f, const char *name,\n \t\tlocus *where)\n {\n \n   if ((f == FL_PROGRAM || f == FL_BLOCK_DATA || f == FL_MODULE\n        || f == FL_PARAMETER || f == FL_LABEL || f == FL_DERIVED\n        || f == FL_NAMELIST) && check_used (attr, name, where))\n-    return FAILURE;\n+    return false;\n \n   if (attr->flavor == f && f == FL_VARIABLE)\n-    return SUCCESS;\n+    return true;\n \n   if (attr->flavor != FL_UNKNOWN)\n     {\n@@ -1479,7 +1474,7 @@ gfc_add_flavor (symbol_attribute *attr, sym_flavor f, const char *name,\n \t\t   gfc_code2string (flavors, attr->flavor),\n \t\t   gfc_code2string (flavors, f), where);\n \n-      return FAILURE;\n+      return false;\n     }\n \n   attr->flavor = f;\n@@ -1488,17 +1483,17 @@ gfc_add_flavor (symbol_attribute *attr, sym_flavor f, const char *name,\n }\n \n \n-gfc_try\n+bool\n gfc_add_procedure (symbol_attribute *attr, procedure_type t,\n \t\t   const char *name, locus *where)\n {\n \n   if (check_used (attr, name, where))\n-    return FAILURE;\n+    return false;\n \n   if (attr->flavor != FL_PROCEDURE\n-      && gfc_add_flavor (attr, FL_PROCEDURE, name, where) == FAILURE)\n-    return FAILURE;\n+      && !gfc_add_flavor (attr, FL_PROCEDURE, name, where))\n+    return false;\n \n   if (where == NULL)\n     where = &gfc_current_locus;\n@@ -1509,27 +1504,27 @@ gfc_add_procedure (symbol_attribute *attr, procedure_type t,\n \t\t gfc_code2string (procedures, t), where,\n \t\t gfc_code2string (procedures, attr->proc));\n \n-      return FAILURE;\n+      return false;\n     }\n \n   attr->proc = t;\n \n   /* Statement functions are always scalar and functions.  */\n   if (t == PROC_ST_FUNCTION\n-      && ((!attr->function && gfc_add_function (attr, name, where) == FAILURE)\n+      && ((!attr->function && !gfc_add_function (attr, name, where))\n \t  || attr->dimension))\n-    return FAILURE;\n+    return false;\n \n   return check_conflict (attr, name, where);\n }\n \n \n-gfc_try\n+bool\n gfc_add_intent (symbol_attribute *attr, sym_intent intent, locus *where)\n {\n \n   if (check_used (attr, NULL, where))\n-    return FAILURE;\n+    return false;\n \n   if (attr->intent == INTENT_UNKNOWN)\n     {\n@@ -1544,13 +1539,13 @@ gfc_add_intent (symbol_attribute *attr, sym_intent intent, locus *where)\n \t     gfc_intent_string (attr->intent),\n \t     gfc_intent_string (intent), where);\n \n-  return FAILURE;\n+  return false;\n }\n \n \n /* No checks for use-association in public and private statements.  */\n \n-gfc_try\n+bool\n gfc_add_access (symbol_attribute *attr, gfc_access access,\n \t\tconst char *name, locus *where)\n {\n@@ -1566,13 +1561,13 @@ gfc_add_access (symbol_attribute *attr, gfc_access access,\n     where = &gfc_current_locus;\n   gfc_error (\"ACCESS specification at %L was already specified\", where);\n \n-  return FAILURE;\n+  return false;\n }\n \n \n /* Set the is_bind_c field for the given symbol_attribute.  */\n \n-gfc_try\n+bool\n gfc_add_is_bind_c (symbol_attribute *attr, const char *name, locus *where,\n                    int is_proc_lang_bind_spec)\n {\n@@ -1588,17 +1583,16 @@ gfc_add_is_bind_c (symbol_attribute *attr, const char *name, locus *where,\n   if (where == NULL)\n     where = &gfc_current_locus;\n    \n-  if (gfc_notify_std (GFC_STD_F2003, \"BIND(C) at %L\", where)\n-      == FAILURE)\n-    return FAILURE;\n+  if (!gfc_notify_std (GFC_STD_F2003, \"BIND(C) at %L\", where))\n+    return false;\n \n   return check_conflict (attr, name, where);\n }\n \n \n /* Set the extension field for the given symbol_attribute.  */\n \n-gfc_try\n+bool\n gfc_add_extension (symbol_attribute *attr, locus *where)\n {\n   if (where == NULL)\n@@ -1609,21 +1603,20 @@ gfc_add_extension (symbol_attribute *attr, locus *where)\n   else\n     attr->extension = 1;\n \n-  if (gfc_notify_std (GFC_STD_F2003, \"EXTENDS at %L\", where)\n-\t== FAILURE)\n-    return FAILURE;\n+  if (!gfc_notify_std (GFC_STD_F2003, \"EXTENDS at %L\", where))\n+    return false;\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n-gfc_try\n+bool\n gfc_add_explicit_interface (gfc_symbol *sym, ifsrc source,\n \t\t\t    gfc_formal_arglist * formal, locus *where)\n {\n \n   if (check_used (&sym->attr, sym->name, where))\n-    return FAILURE;\n+    return false;\n \n   if (where == NULL)\n     where = &gfc_current_locus;\n@@ -1633,26 +1626,26 @@ gfc_add_explicit_interface (gfc_symbol *sym, ifsrc source,\n     {\n       gfc_error (\"Symbol '%s' at %L already has an explicit interface\",\n \t\t sym->name, where);\n-      return FAILURE;\n+      return false;\n     }\n \n   if (source == IFSRC_IFBODY && (sym->attr.dimension || sym->attr.allocatable))\n     {\n       gfc_error (\"'%s' at %L has attributes specified outside its INTERFACE \"\n \t\t \"body\", sym->name, where);\n-      return FAILURE;\n+      return false;\n     }\n \n   sym->formal = formal;\n   sym->attr.if_source = source;\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n /* Add a type to a symbol.  */\n \n-gfc_try\n+bool\n gfc_add_type (gfc_symbol *sym, gfc_typespec *ts, locus *where)\n {\n   sym_flavor flavor;\n@@ -1678,14 +1671,14 @@ gfc_add_type (gfc_symbol *sym, gfc_typespec *ts, locus *where)\n       else\n \tgfc_error (\"Symbol '%s' at %L already has basic type of %s\", sym->name,\n \t\t where, gfc_basic_typename (type));\n-      return FAILURE;\n+      return false;\n     }\n \n   if (sym->attr.procedure && sym->ts.interface)\n     {\n       gfc_error (\"Procedure '%s' at %L may not have basic type of %s\",\n \t\t sym->name, where, gfc_basic_typename (ts->type));\n-      return FAILURE;\n+      return false;\n     }\n \n   flavor = sym->attr.flavor;\n@@ -1696,11 +1689,11 @@ gfc_add_type (gfc_symbol *sym, gfc_typespec *ts, locus *where)\n       || flavor == FL_DERIVED || flavor == FL_NAMELIST)\n     {\n       gfc_error (\"Symbol '%s' at %L cannot have a type\", sym->name, where);\n-      return FAILURE;\n+      return false;\n     }\n \n   sym->ts = *ts;\n-  return SUCCESS;\n+  return true;\n }\n \n \n@@ -1716,20 +1709,20 @@ gfc_clear_attr (symbol_attribute *attr)\n /* Check for missing attributes in the new symbol.  Currently does\n    nothing, but it's not clear that it is unnecessary yet.  */\n \n-gfc_try\n+bool\n gfc_missing_attr (symbol_attribute *attr ATTRIBUTE_UNUSED,\n \t\t  locus *where ATTRIBUTE_UNUSED)\n {\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n /* Copy an attribute to a symbol attribute, bit by bit.  Some\n    attributes have a lot of side-effects but cannot be present given\n    where we are called from, so we ignore some bits.  */\n \n-gfc_try\n+bool\n gfc_copy_attr (symbol_attribute *dest, symbol_attribute *src, locus *where)\n {\n   int is_proc_lang_bind_spec;\n@@ -1738,105 +1731,104 @@ gfc_copy_attr (symbol_attribute *dest, symbol_attribute *src, locus *where)\n      them; cf. also PR 41034.  */\n   dest->ext_attr |= src->ext_attr;\n \n-  if (src->allocatable && gfc_add_allocatable (dest, where) == FAILURE)\n+  if (src->allocatable && !gfc_add_allocatable (dest, where))\n     goto fail;\n \n-  if (src->dimension && gfc_add_dimension (dest, NULL, where) == FAILURE)\n+  if (src->dimension && !gfc_add_dimension (dest, NULL, where))\n     goto fail;\n-  if (src->codimension && gfc_add_codimension (dest, NULL, where) == FAILURE)\n+  if (src->codimension && !gfc_add_codimension (dest, NULL, where))\n     goto fail;\n-  if (src->contiguous && gfc_add_contiguous (dest, NULL, where) == FAILURE)\n+  if (src->contiguous && !gfc_add_contiguous (dest, NULL, where))\n     goto fail;\n-  if (src->optional && gfc_add_optional (dest, where) == FAILURE)\n+  if (src->optional && !gfc_add_optional (dest, where))\n     goto fail;\n-  if (src->pointer && gfc_add_pointer (dest, where) == FAILURE)\n+  if (src->pointer && !gfc_add_pointer (dest, where))\n     goto fail;\n-  if (src->is_protected && gfc_add_protected (dest, NULL, where) == FAILURE)\n+  if (src->is_protected && !gfc_add_protected (dest, NULL, where))\n     goto fail;\n-  if (src->save && gfc_add_save (dest, src->save, NULL, where) == FAILURE)\n+  if (src->save && !gfc_add_save (dest, src->save, NULL, where))\n     goto fail;\n-  if (src->value && gfc_add_value (dest, NULL, where) == FAILURE)\n+  if (src->value && !gfc_add_value (dest, NULL, where))\n     goto fail;\n-  if (src->volatile_ && gfc_add_volatile (dest, NULL, where) == FAILURE)\n+  if (src->volatile_ && !gfc_add_volatile (dest, NULL, where))\n     goto fail;\n-  if (src->asynchronous && gfc_add_asynchronous (dest, NULL, where) == FAILURE)\n+  if (src->asynchronous && !gfc_add_asynchronous (dest, NULL, where))\n     goto fail;\n   if (src->threadprivate\n-      && gfc_add_threadprivate (dest, NULL, where) == FAILURE)\n+      && !gfc_add_threadprivate (dest, NULL, where))\n     goto fail;\n-  if (src->target && gfc_add_target (dest, where) == FAILURE)\n+  if (src->target && !gfc_add_target (dest, where))\n     goto fail;\n-  if (src->dummy && gfc_add_dummy (dest, NULL, where) == FAILURE)\n+  if (src->dummy && !gfc_add_dummy (dest, NULL, where))\n     goto fail;\n-  if (src->result && gfc_add_result (dest, NULL, where) == FAILURE)\n+  if (src->result && !gfc_add_result (dest, NULL, where))\n     goto fail;\n   if (src->entry)\n     dest->entry = 1;\n \n-  if (src->in_namelist && gfc_add_in_namelist (dest, NULL, where) == FAILURE)\n+  if (src->in_namelist && !gfc_add_in_namelist (dest, NULL, where))\n     goto fail;\n \n-  if (src->in_common && gfc_add_in_common (dest, NULL, where) == FAILURE)\n+  if (src->in_common && !gfc_add_in_common (dest, NULL, where))\n     goto fail;\n \n-  if (src->generic && gfc_add_generic (dest, NULL, where) == FAILURE)\n+  if (src->generic && !gfc_add_generic (dest, NULL, where))\n     goto fail;\n-  if (src->function && gfc_add_function (dest, NULL, where) == FAILURE)\n+  if (src->function && !gfc_add_function (dest, NULL, where))\n     goto fail;\n-  if (src->subroutine && gfc_add_subroutine (dest, NULL, where) == FAILURE)\n+  if (src->subroutine && !gfc_add_subroutine (dest, NULL, where))\n     goto fail;\n \n-  if (src->sequence && gfc_add_sequence (dest, NULL, where) == FAILURE)\n+  if (src->sequence && !gfc_add_sequence (dest, NULL, where))\n     goto fail;\n-  if (src->elemental && gfc_add_elemental (dest, where) == FAILURE)\n+  if (src->elemental && !gfc_add_elemental (dest, where))\n     goto fail;\n-  if (src->pure && gfc_add_pure (dest, where) == FAILURE)\n+  if (src->pure && !gfc_add_pure (dest, where))\n     goto fail;\n-  if (src->recursive && gfc_add_recursive (dest, where) == FAILURE)\n+  if (src->recursive && !gfc_add_recursive (dest, where))\n     goto fail;\n \n   if (src->flavor != FL_UNKNOWN\n-      && gfc_add_flavor (dest, src->flavor, NULL, where) == FAILURE)\n+      && !gfc_add_flavor (dest, src->flavor, NULL, where))\n     goto fail;\n \n   if (src->intent != INTENT_UNKNOWN\n-      && gfc_add_intent (dest, src->intent, where) == FAILURE)\n+      && !gfc_add_intent (dest, src->intent, where))\n     goto fail;\n \n   if (src->access != ACCESS_UNKNOWN\n-      && gfc_add_access (dest, src->access, NULL, where) == FAILURE)\n+      && !gfc_add_access (dest, src->access, NULL, where))\n     goto fail;\n \n-  if (gfc_missing_attr (dest, where) == FAILURE)\n+  if (!gfc_missing_attr (dest, where))\n     goto fail;\n \n-  if (src->cray_pointer && gfc_add_cray_pointer (dest, where) == FAILURE)\n+  if (src->cray_pointer && !gfc_add_cray_pointer (dest, where))\n     goto fail;\n-  if (src->cray_pointee && gfc_add_cray_pointee (dest, where) == FAILURE)\n+  if (src->cray_pointee && !gfc_add_cray_pointee (dest, where))\n     goto fail;\n \n   is_proc_lang_bind_spec = (src->flavor == FL_PROCEDURE ? 1 : 0);\n   if (src->is_bind_c\n-      && gfc_add_is_bind_c (dest, NULL, where, is_proc_lang_bind_spec)\n-\t != SUCCESS)\n-    return FAILURE;\n+      && !gfc_add_is_bind_c (dest, NULL, where, is_proc_lang_bind_spec))\n+    return false;\n \n   if (src->is_c_interop)\n     dest->is_c_interop = 1;\n   if (src->is_iso_c)\n     dest->is_iso_c = 1;\n   \n-  if (src->external && gfc_add_external (dest, where) == FAILURE)\n+  if (src->external && !gfc_add_external (dest, where))\n     goto fail;\n-  if (src->intrinsic && gfc_add_intrinsic (dest, where) == FAILURE)\n+  if (src->intrinsic && !gfc_add_intrinsic (dest, where))\n     goto fail;\n   if (src->proc_pointer)\n     dest->proc_pointer = 1;\n \n-  return SUCCESS;\n+  return true;\n \n fail:\n-  return FAILURE;\n+  return false;\n }\n \n \n@@ -1852,7 +1844,7 @@ gfc_copy_attr (symbol_attribute *dest, symbol_attribute *src, locus *where)\n    already present.  On success, the component pointer is modified to\n    point to the additional component structure.  */\n \n-gfc_try\n+bool\n gfc_add_component (gfc_symbol *sym, const char *name,\n \t\t   gfc_component **component)\n {\n@@ -1866,7 +1858,7 @@ gfc_add_component (gfc_symbol *sym, const char *name,\n \t{\n \t  gfc_error (\"Component '%s' at %C already declared at %L\",\n \t\t     name, &p->loc);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n \n       tail = p;\n@@ -1877,7 +1869,7 @@ gfc_add_component (gfc_symbol *sym, const char *name,\n     {\n       gfc_error (\"Component '%s' at %C already in the parent type \"\n \t\t \"at %L\", name, &sym->components->ts.u.derived->declared_at);\n-      return FAILURE;\n+      return false;\n     }\n \n   /* Allocate a new component.  */\n@@ -1893,7 +1885,7 @@ gfc_add_component (gfc_symbol *sym, const char *name,\n   p->ts.type = BT_UNKNOWN;\n \n   *component = p;\n-  return SUCCESS;\n+  return true;\n }\n \n \n@@ -2214,9 +2206,9 @@ gfc_define_st_label (gfc_st_label *lp, gfc_sl_type type, locus *label_locus)\n \t    lp->defined = type;\n \n \t  if (lp->referenced == ST_LABEL_DO_TARGET && type != ST_LABEL_DO_TARGET\n-      \t      && gfc_notify_std (GFC_STD_F95_OBS, \"DO termination statement \"\n-\t\t\t\t \"which is not END DO or CONTINUE with label \"\n-\t\t\t\t \"%d at %C\", labelno) == FAILURE)\n+      \t      && !gfc_notify_std (GFC_STD_F95_OBS, \"DO termination statement \"\n+\t\t\t\t  \"which is not END DO or CONTINUE with \"\n+\t\t\t\t  \"label %d at %C\", labelno))\n \t    return;\n \t  break;\n \n@@ -2230,18 +2222,18 @@ gfc_define_st_label (gfc_st_label *lp, gfc_sl_type type, locus *label_locus)\n \n /* Reference a label.  Given a label and its type, see if that\n    reference is consistent with what is known about that label,\n-   updating the unknown state.  Returns FAILURE if something goes\n+   updating the unknown state.  Returns false if something goes\n    wrong.  */\n \n-gfc_try\n+bool\n gfc_reference_st_label (gfc_st_label *lp, gfc_sl_type type)\n {\n   gfc_sl_type label_type;\n   int labelno;\n-  gfc_try rc;\n+  bool rc;\n \n   if (lp == NULL)\n-    return SUCCESS;\n+    return true;\n \n   labelno = lp->value;\n \n@@ -2257,7 +2249,7 @@ gfc_reference_st_label (gfc_st_label *lp, gfc_sl_type type)\n       && (type == ST_LABEL_TARGET || type == ST_LABEL_DO_TARGET))\n     {\n       gfc_error (\"Label %d at %C previously used as a FORMAT label\", labelno);\n-      rc = FAILURE;\n+      rc = false;\n       goto done;\n     }\n \n@@ -2266,18 +2258,18 @@ gfc_reference_st_label (gfc_st_label *lp, gfc_sl_type type)\n       && type == ST_LABEL_FORMAT)\n     {\n       gfc_error (\"Label %d at %C previously used as branch target\", labelno);\n-      rc = FAILURE;\n+      rc = false;\n       goto done;\n     }\n \n   if (lp->referenced == ST_LABEL_DO_TARGET && type == ST_LABEL_DO_TARGET\n-      && gfc_notify_std (GFC_STD_F95_OBS, \"Shared DO termination label %d \"\n-\t\t\t \"at %C\", labelno) == FAILURE)\n-    return FAILURE;\n+      && !gfc_notify_std (GFC_STD_F95_OBS, \"Shared DO termination label %d \"\n+\t\t\t  \"at %C\", labelno))\n+    return false;\n \n   if (lp->referenced != ST_LABEL_DO_TARGET)\n     lp->referenced = type;\n-  rc = SUCCESS;\n+  rc = true;\n \n done:\n   return rc;\n@@ -3773,12 +3765,12 @@ get_iso_c_binding_dt (int sym_id)\n    for such.  If an error occurs, the errors are reported here, allowing for\n    multiple errors to be handled for a single derived type.  */\n \n-gfc_try\n+bool\n verify_bind_c_derived_type (gfc_symbol *derived_sym)\n {\n   gfc_component *curr_comp = NULL;\n-  gfc_try is_c_interop = FAILURE;\n-  gfc_try retval = SUCCESS;\n+  bool is_c_interop = false;\n+  bool retval = true;\n    \n   if (derived_sym == NULL)\n     gfc_internal_error (\"verify_bind_c_derived_type(): Given symbol is \"\n@@ -3787,7 +3779,7 @@ verify_bind_c_derived_type (gfc_symbol *derived_sym)\n   /* If we've already looked at this derived symbol, do not look at it again\n      so we don't repeat warnings/errors.  */\n   if (derived_sym->ts.is_c_interop)\n-    return SUCCESS;\n+    return true;\n   \n   /* The derived type must have the BIND attribute to be interoperable\n      J3/04-007, Section 15.2.3.  */\n@@ -3797,7 +3789,7 @@ verify_bind_c_derived_type (gfc_symbol *derived_sym)\n       gfc_error_now (\"Derived type '%s' declared at %L must have the BIND \"\n                      \"attribute to be C interoperable\", derived_sym->name,\n                      &(derived_sym->declared_at));\n-      retval = FAILURE;\n+      retval = false;\n     }\n   \n   curr_comp = derived_sym->components;\n@@ -3817,7 +3809,7 @@ verify_bind_c_derived_type (gfc_symbol *derived_sym)\n \t\t   derived_sym->name, &(derived_sym->declared_at));\n       derived_sym->ts.is_c_interop = 1;\n       derived_sym->attr.is_bind_c = 1;\n-      return SUCCESS;\n+      return true;\n     }\n \n \n@@ -3838,7 +3830,7 @@ verify_bind_c_derived_type (gfc_symbol *derived_sym)\n                      \"of the BIND(C) derived type '%s' at %L\",\n                      curr_comp->name, &(curr_comp->loc),\n                      derived_sym->name, &(derived_sym->declared_at));\n-          retval = FAILURE;\n+          retval = false;\n         }\n \n       if (curr_comp->attr.proc_pointer != 0)\n@@ -3847,7 +3839,7 @@ verify_bind_c_derived_type (gfc_symbol *derived_sym)\n \t\t     \" of the BIND(C) derived type '%s' at %L\", curr_comp->name,\n \t\t     &curr_comp->loc, derived_sym->name,\n \t\t     &derived_sym->declared_at);\n-          retval = FAILURE;\n+          retval = false;\n         }\n \n       /* The components cannot be allocatable.\n@@ -3859,7 +3851,7 @@ verify_bind_c_derived_type (gfc_symbol *derived_sym)\n                      \"of the BIND(C) derived type '%s' at %L\",\n                      curr_comp->name, &(curr_comp->loc),\n                      derived_sym->name, &(derived_sym->declared_at));\n-          retval = FAILURE;\n+          retval = false;\n         }\n       \n       /* BIND(C) derived types must have interoperable components.  */\n@@ -3878,7 +3870,7 @@ verify_bind_c_derived_type (gfc_symbol *derived_sym)\n \t  /* Grab the typespec for the given component and test the kind.  */ \n \t  is_c_interop = gfc_verify_c_interop (&(curr_comp->ts));\n \t  \n-\t  if (is_c_interop != SUCCESS)\n+\t  if (!is_c_interop)\n \t    {\n \t      /* Report warning and continue since not fatal.  The\n \t\t draft does specify a constraint that requires all fields\n@@ -3919,21 +3911,21 @@ verify_bind_c_derived_type (gfc_symbol *derived_sym)\n       gfc_error (\"Derived type '%s' at %L cannot be declared with both \"\n                  \"PRIVATE and BIND(C) attributes\", derived_sym->name,\n                  &(derived_sym->declared_at));\n-      retval = FAILURE;\n+      retval = false;\n     }\n \n   if (derived_sym->attr.sequence != 0)\n     {\n       gfc_error (\"Derived type '%s' at %L cannot have the SEQUENCE \"\n                  \"attribute because it is BIND(C)\", derived_sym->name,\n                  &(derived_sym->declared_at));\n-      retval = FAILURE;\n+      retval = false;\n     }\n \n   /* Mark the derived type as not being C interoperable if we found an\n      error.  If there were only warnings, proceed with the assumption\n      it's interoperable.  */\n-  if (retval == FAILURE)\n+  if (!retval)\n     derived_sym->ts.is_c_interop = 0;\n   \n   return retval;\n@@ -3942,7 +3934,7 @@ verify_bind_c_derived_type (gfc_symbol *derived_sym)\n \n /* Generate symbols for the named constants c_null_ptr and c_null_funptr.  */\n \n-static gfc_try\n+static bool\n gen_special_c_interop_ptr (gfc_symbol *tmp_sym, gfc_symtree *dt_symtree)\n {\n   gfc_constructor *c;\n@@ -3971,7 +3963,7 @@ gen_special_c_interop_ptr (gfc_symbol *tmp_sym, gfc_symtree *dt_symtree)\n   c->expr = gfc_get_int_expr (gfc_index_integer_kind, NULL, 0);\n   c->expr->ts.is_iso_c = 1;\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n@@ -4292,13 +4284,11 @@ generate_isocbinding_symbol (const char *mod_name, iso_c_binding_symbol s,\n \t      tmp_sym->generic = intr;\n \n \t      if (!tmp_sym->attr.generic\n-\t\t  && gfc_add_generic (&tmp_sym->attr, tmp_sym->name, NULL)\n-\t\t     == FAILURE)\n+\t\t  && !gfc_add_generic (&tmp_sym->attr, tmp_sym->name, NULL))\n \t\treturn NULL;\n \n \t      if (!tmp_sym->attr.function\n-\t\t  && gfc_add_function (&tmp_sym->attr, tmp_sym->name, NULL)\n-\t\t     == FAILURE)\n+\t\t  && !gfc_add_function (&tmp_sym->attr, tmp_sym->name, NULL))\n \t\treturn NULL;\n \t    }\n \n@@ -4375,34 +4365,33 @@ generate_isocbinding_symbol (const char *mod_name, iso_c_binding_symbol s,\n /* Check that a symbol is already typed.  If strict is not set, an untyped\n    symbol is acceptable for non-standard-conforming mode.  */\n \n-gfc_try\n+bool\n gfc_check_symbol_typed (gfc_symbol* sym, gfc_namespace* ns,\n \t\t\tbool strict, locus where)\n {\n   gcc_assert (sym);\n \n   if (gfc_matching_prefix)\n-    return SUCCESS;\n+    return true;\n \n   /* Check for the type and try to give it an implicit one.  */\n   if (sym->ts.type == BT_UNKNOWN\n-      && gfc_set_default_type (sym, 0, ns) == FAILURE)\n+      && !gfc_set_default_type (sym, 0, ns))\n     {\n       if (strict)\n \t{\n \t  gfc_error (\"Symbol '%s' is used before it is typed at %L\",\n \t\t     sym->name, &where);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n \n-      if (gfc_notify_std (GFC_STD_GNU,\n-\t\t\t  \"Symbol '%s' is used before\"\n-\t\t\t  \" it is typed at %L\", sym->name, &where) == FAILURE)\n-\treturn FAILURE;\n+      if (!gfc_notify_std (GFC_STD_GNU, \"Symbol '%s' is used before\"\n+\t\t\t   \" it is typed at %L\", sym->name, &where))\n+\treturn false;\n     }\n \n   /* Everything is ok.  */\n-  return SUCCESS;\n+  return true;\n }\n \n "}, {"sha": "05de50d2f049f21776564ffb563c101d86a6f5b0", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=524af0d6c72031c249aa737945fde6ac3d726ba2", "patch": "@@ -7582,7 +7582,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t      comp = fold_build3_loc (input_location, COMPONENT_REF,\n \t\t\t\t      TREE_TYPE (tmp), comp, tmp, NULL_TREE);\n \n-\t      if (GFC_DESCRIPTOR_TYPE_P(TREE_TYPE (comp)))\n+\t      if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (comp)))\n \t        tmp = gfc_trans_dealloc_allocated (comp,\n \t\t\t\t\tCLASS_DATA (c)->attr.codimension);\n \t      else\n@@ -7647,7 +7647,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t      tmp = CLASS_DATA (c)->backend_decl;\n \t      comp = fold_build3_loc (input_location, COMPONENT_REF,\n \t\t\t\t      TREE_TYPE (tmp), comp, tmp, NULL_TREE);\n-\t      if (GFC_DESCRIPTOR_TYPE_P(TREE_TYPE (comp)))\n+\t      if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (comp)))\n \t\tgfc_conv_descriptor_data_set (&fnblock, comp, null_pointer_node);\n \t      else\n \t\t{"}, {"sha": "2a16059c4c552b884f8d37c356f38d0c4ba5f93a", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=524af0d6c72031c249aa737945fde6ac3d726ba2", "patch": "@@ -2192,9 +2192,9 @@ gfc_conv_intrinsic_ttynam (gfc_se * se, gfc_expr * expr)\n     minmax (a1, a2, a3, ...)\n     {\n       mvar = a1;\n-      if (a2 .op. mvar || isnan(mvar))\n+      if (a2 .op. mvar || isnan (mvar))\n         mvar = a2;\n-      if (a3 .op. mvar || isnan(mvar))\n+      if (a3 .op. mvar || isnan (mvar))\n         mvar = a3;\n       ...\n       return mvar\n@@ -2749,7 +2749,7 @@ gfc_conv_intrinsic_arith (gfc_se * se, gfc_expr * expr, enum tree_code op,\n \n   if (norm2)\n     {\n-      /* if (x(i) != 0.0)\n+      /* if (x (i) != 0.0)\n \t   {\n \t     absX = abs(x(i))\n \t     if (absX > scale)\n@@ -3104,7 +3104,7 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, enum tree_code op)\n   else\n     {\n       mpz_t asize;\n-      if (gfc_array_size (arrayexpr, &asize) == SUCCESS)\n+      if (gfc_array_size (arrayexpr, &asize))\n \t{\n \t  nonempty = gfc_conv_mpz_to_tree (asize, gfc_index_integer_kind);\n \t  mpz_clear (asize);\n@@ -3594,7 +3594,7 @@ gfc_conv_intrinsic_minmaxval (gfc_se * se, gfc_expr * expr, enum tree_code op)\n   else\n     {\n       mpz_t asize;\n-      if (gfc_array_size (arrayexpr, &asize) == SUCCESS)\n+      if (gfc_array_size (arrayexpr, &asize))\n \t{\n \t  nonempty = gfc_conv_mpz_to_tree (asize, gfc_index_integer_kind);\n \t  mpz_clear (asize);"}, {"sha": "882927e639a9256b0433f6160e19e7046f54dd0b", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=524af0d6c72031c249aa737945fde6ac3d726ba2", "patch": "@@ -500,7 +500,7 @@ gfc_trans_omp_array_reduction (tree c, gfc_symbol *sym, locus where)\n   tree decl, backend_decl, stmt, type, outer_decl;\n   locus old_loc = gfc_current_locus;\n   const char *iname;\n-  gfc_try t;\n+  bool t;\n \n   decl = OMP_CLAUSE_DECL (c);\n   gfc_current_locus = where;\n@@ -562,20 +562,20 @@ gfc_trans_omp_array_reduction (tree c, gfc_symbol *sym, locus where)\n   ref->u.ar.type = AR_FULL;\n   ref->u.ar.dimen = 0;\n   t = gfc_resolve_expr (e1);\n-  gcc_assert (t == SUCCESS);\n+  gcc_assert (t);\n \n   e2 = gfc_get_expr ();\n   e2->expr_type = EXPR_VARIABLE;\n   e2->where = where;\n   e2->symtree = symtree2;\n   e2->ts = sym->ts;\n   t = gfc_resolve_expr (e2);\n-  gcc_assert (t == SUCCESS);\n+  gcc_assert (t);\n \n   e3 = gfc_copy_expr (e1);\n   e3->symtree = symtree3;\n   t = gfc_resolve_expr (e3);\n-  gcc_assert (t == SUCCESS);\n+  gcc_assert (t);\n \n   iname = NULL;\n   switch (OMP_CLAUSE_REDUCTION_CODE (c))\n@@ -647,7 +647,7 @@ gfc_trans_omp_array_reduction (tree c, gfc_symbol *sym, locus where)\n   e1 = gfc_copy_expr (e1);\n   e3 = gfc_copy_expr (e3);\n   t = gfc_resolve_expr (e4);\n-  gcc_assert (t == SUCCESS);\n+  gcc_assert (t);\n \n   /* Create the init statement list.  */\n   pushlevel ();"}, {"sha": "1b65f2ca78b3f0cf663d950195cd234d522e4b19", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=524af0d6c72031c249aa737945fde6ac3d726ba2", "patch": "@@ -2661,7 +2661,7 @@ check_forall_dependencies (gfc_code *c, stmtblock_t *pre, stmtblock_t *post)\n     return need_temp;\n \n   new_symtree = NULL;\n-  if (find_forall_index (c->expr1, lsym, 2) == SUCCESS)\n+  if (find_forall_index (c->expr1, lsym, 2))\n     {\n       forall_make_variable_temp (c, pre, post);\n       need_temp = 0;\n@@ -4757,21 +4757,21 @@ gfc_trans_where (gfc_code * code)\n \t     are the same.  In short, this is VERY conservative and this\n \t     is needed because the two loops, required by the standard\n \t     are coalesced in gfc_trans_where_3.  */\n-\t  if (!gfc_check_dependency(cblock->next->expr1,\n+\t  if (!gfc_check_dependency (cblock->next->expr1,\n \t\t\t\t    cblock->expr1, 0)\n-\t      && !gfc_check_dependency(eblock->next->expr1,\n+\t      && !gfc_check_dependency (eblock->next->expr1,\n \t\t\t\t       cblock->expr1, 0)\n-\t      && !gfc_check_dependency(cblock->next->expr1,\n+\t      && !gfc_check_dependency (cblock->next->expr1,\n \t\t\t\t       eblock->next->expr2, 1)\n-\t      && !gfc_check_dependency(eblock->next->expr1,\n+\t      && !gfc_check_dependency (eblock->next->expr1,\n \t\t\t\t       cblock->next->expr2, 1)\n-\t      && !gfc_check_dependency(cblock->next->expr1,\n+\t      && !gfc_check_dependency (cblock->next->expr1,\n \t\t\t\t       cblock->next->expr2, 1)\n-\t      && !gfc_check_dependency(eblock->next->expr1,\n+\t      && !gfc_check_dependency (eblock->next->expr1,\n \t\t\t\t       eblock->next->expr2, 1)\n-\t      && !gfc_check_dependency(cblock->next->expr1,\n+\t      && !gfc_check_dependency (cblock->next->expr1,\n \t\t\t\t       eblock->next->expr1, 0)\n-\t      && !gfc_check_dependency(eblock->next->expr1,\n+\t      && !gfc_check_dependency (eblock->next->expr1,\n \t\t\t\t       cblock->next->expr1, 0))\n \t    return gfc_trans_where_3 (cblock, eblock);\n \t}"}, {"sha": "379fe9463f07415f2beabcf6ccc2081dd39a56f8", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/524af0d6c72031c249aa737945fde6ac3d726ba2/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=524af0d6c72031c249aa737945fde6ac3d726ba2", "patch": "@@ -132,7 +132,7 @@ int gfc_numeric_storage_size;\n int gfc_character_storage_size;\n \n \n-gfc_try\n+bool\n gfc_check_any_c_kind (gfc_typespec *ts)\n {\n   int i;\n@@ -144,10 +144,10 @@ gfc_check_any_c_kind (gfc_typespec *ts)\n          Fortran kind being used exists in at least some form for C.  */\n       if (c_interop_kinds_table[i].f90_type == ts->type &&\n           c_interop_kinds_table[i].value == ts->kind)\n-        return SUCCESS;\n+        return true;\n     }\n \n-  return FAILURE;\n+  return false;\n }\n \n "}]}