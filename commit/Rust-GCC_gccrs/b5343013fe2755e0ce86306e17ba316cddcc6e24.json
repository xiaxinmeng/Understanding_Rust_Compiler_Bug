{"sha": "b5343013fe2755e0ce86306e17ba316cddcc6e24", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjUzNDMwMTNmZTI3NTVlMGNlODYzMDZlMTdiYTMxNmNkZGNjNmUyNA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2010-12-17T06:33:41Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2010-12-17T06:33:41Z"}, "message": "Avoid always splitting the stack when calling append and copy.\n\nFrom-SVN: r167970", "tree": {"sha": "eaa0d2dd05a12f27cd941019fb7010fb9d5cb99a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eaa0d2dd05a12f27cd941019fb7010fb9d5cb99a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5343013fe2755e0ce86306e17ba316cddcc6e24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5343013fe2755e0ce86306e17ba316cddcc6e24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5343013fe2755e0ce86306e17ba316cddcc6e24", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5343013fe2755e0ce86306e17ba316cddcc6e24/comments", "author": null, "committer": null, "parents": [{"sha": "94c4ae321544428ae014b59e0b3ee19c1431b277", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94c4ae321544428ae014b59e0b3ee19c1431b277", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94c4ae321544428ae014b59e0b3ee19c1431b277"}], "stats": {"total": 137, "additions": 103, "deletions": 34}, "files": [{"sha": "cb5c45c2eb19f548803eeff339be81d5f172429c", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 42, "deletions": 9, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5343013fe2755e0ce86306e17ba316cddcc6e24/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5343013fe2755e0ce86306e17ba316cddcc6e24/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=b5343013fe2755e0ce86306e17ba316cddcc6e24", "patch": "@@ -7785,9 +7785,23 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \t\t\t\t    bytecount, element_size);\n \tbytecount = fold_convert_loc(location, size_type_node, bytecount);\n \n-\ttree call = build_call_expr_loc(location,\n-\t\t\t\t\tbuilt_in_decls[BUILT_IN_MEMMOVE],\n-\t\t\t\t\t3, arg1_val, arg2_val, bytecount);\n+\targ1_val = fold_convert_loc(location, ptr_type_node, arg1_val);\n+\targ2_val = fold_convert_loc(location, ptr_type_node, arg2_val);\n+\n+\tstatic tree copy_fndecl;\n+\ttree call = Gogo::call_builtin(&copy_fndecl,\n+\t\t\t\t       location,\n+\t\t\t\t       \"__go_copy\",\n+\t\t\t\t       3,\n+\t\t\t\t       void_type_node,\n+\t\t\t\t       ptr_type_node,\n+\t\t\t\t       arg1_val,\n+\t\t\t\t       ptr_type_node,\n+\t\t\t\t       arg2_val,\n+\t\t\t\t       size_type_node,\n+\t\t\t\t       bytecount);\n+\tif (call == error_mark_node)\n+\t  return error_mark_node;\n \n \treturn fold_build2_loc(location, COMPOUND_EXPR, TREE_TYPE(len),\n \t\t\t       call, len);\n@@ -7800,27 +7814,46 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \tExpression* arg1 = args->front();\n \tExpression* arg2 = args->back();\n \n+\tArray_type* at = arg1->type()->array_type();\n+\tType* element_type = at->element_type();\n+\n \ttree arg1_tree = arg1->get_tree(context);\n \ttree arg2_tree = arg2->get_tree(context);\n \tif (arg1_tree == error_mark_node || arg2_tree == error_mark_node)\n \t  return error_mark_node;\n \n-\ttree descriptor_tree = arg1->type()->type_descriptor_pointer(gogo);\n+\tArray_type* at2 = arg2->type()->array_type();\n+\targ2_tree = save_expr(arg2_tree);\n+\ttree arg2_val = at2->value_pointer_tree(gogo, arg2_tree);\n+\ttree arg2_len = at2->length_tree(gogo, arg2_tree);\n+\tif (arg2_val == error_mark_node || arg2_len == error_mark_node)\n+\t  return error_mark_node;\n+\targ2_val = fold_convert_loc(location, ptr_type_node, arg2_val);\n+\targ2_len = fold_convert_loc(location, size_type_node, arg2_len);\n+\n+\ttree element_type_tree = element_type->get_tree(gogo);\n+\tif (element_type_tree == error_mark_node)\n+\t  return error_mark_node;\n+\ttree element_size = TYPE_SIZE_UNIT(element_type_tree);\n+\telement_size = fold_convert_loc(location, size_type_node,\n+\t\t\t\t\telement_size);\n \n \t// We rebuild the decl each time since the slice types may\n \t// change.\n \ttree append_fndecl = NULL_TREE;\n \treturn Gogo::call_builtin(&append_fndecl,\n \t\t\t\t  location,\n \t\t\t\t  \"__go_append\",\n-\t\t\t\t  3,\n+\t\t\t\t  4,\n \t\t\t\t  TREE_TYPE(arg1_tree),\n-\t\t\t\t  TREE_TYPE(descriptor_tree),\n-\t\t\t\t  descriptor_tree,\n \t\t\t\t  TREE_TYPE(arg1_tree),\n \t\t\t\t  arg1_tree,\n-\t\t\t\t  TREE_TYPE(arg2_tree),\n-\t\t\t\t  arg2_tree);\n+\t\t\t\t  ptr_type_node,\n+\t\t\t\t  arg2_val,\n+\t\t\t\t  size_type_node,\n+\t\t\t\t  arg2_len,\n+\t\t\t\t  size_type_node,\n+\t\t\t\t  element_size);\n       }\n \n     case BUILTIN_REAL:"}, {"sha": "cddcd2439e7f7643a1afb474f13abed5dbc3876b", "filename": "libgo/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5343013fe2755e0ce86306e17ba316cddcc6e24/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5343013fe2755e0ce86306e17ba316cddcc6e24/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=b5343013fe2755e0ce86306e17ba316cddcc6e24", "patch": "@@ -319,6 +319,7 @@ runtime_files = \\\n \truntime/go-closed.c \\\n \truntime/go-construct-map.c \\\n \truntime/go-convert-interface.c \\\n+\truntime/go-copy.c \\\n \truntime/go-defer.c \\\n \truntime/go-deferred-recover.c \\\n \truntime/go-eface-compare.c \\"}, {"sha": "4ccd863124c92d22d2dd3c187a0f8a876280e2be", "filename": "libgo/Makefile.in", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5343013fe2755e0ce86306e17ba316cddcc6e24/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5343013fe2755e0ce86306e17ba316cddcc6e24/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=b5343013fe2755e0ce86306e17ba316cddcc6e24", "patch": "@@ -129,10 +129,10 @@ am__libgo_la_SOURCES_DIST = runtime/go-append.c runtime/go-assert.c \\\n \truntime/go-chan-cap.c runtime/go-chan-len.c \\\n \truntime/go-check-interface.c runtime/go-close.c \\\n \truntime/go-closed.c runtime/go-construct-map.c \\\n-\truntime/go-convert-interface.c runtime/go-defer.c \\\n-\truntime/go-deferred-recover.c runtime/go-eface-compare.c \\\n-\truntime/go-eface-val-compare.c runtime/go-getgoroot.c \\\n-\truntime/go-go.c runtime/go-gomaxprocs.c \\\n+\truntime/go-convert-interface.c runtime/go-copy.c \\\n+\truntime/go-defer.c runtime/go-deferred-recover.c \\\n+\truntime/go-eface-compare.c runtime/go-eface-val-compare.c \\\n+\truntime/go-getgoroot.c runtime/go-go.c runtime/go-gomaxprocs.c \\\n \truntime/go-int-array-to-string.c runtime/go-int-to-string.c \\\n \truntime/go-interface-compare.c \\\n \truntime/go-interface-val-compare.c runtime/go-lock-os-thread.c \\\n@@ -174,8 +174,8 @@ am__objects_3 = go-append.lo go-assert.lo go-assert-interface.lo \\\n \tgo-byte-array-to-string.lo go-breakpoint.lo go-caller.lo \\\n \tgo-can-convert-interface.lo go-chan-cap.lo go-chan-len.lo \\\n \tgo-check-interface.lo go-close.lo go-closed.lo \\\n-\tgo-construct-map.lo go-convert-interface.lo go-defer.lo \\\n-\tgo-deferred-recover.lo go-eface-compare.lo \\\n+\tgo-construct-map.lo go-convert-interface.lo go-copy.lo \\\n+\tgo-defer.lo go-deferred-recover.lo go-eface-compare.lo \\\n \tgo-eface-val-compare.lo go-getgoroot.lo go-go.lo \\\n \tgo-gomaxprocs.lo go-int-array-to-string.lo go-int-to-string.lo \\\n \tgo-interface-compare.lo go-interface-val-compare.lo \\\n@@ -685,6 +685,7 @@ runtime_files = \\\n \truntime/go-closed.c \\\n \truntime/go-construct-map.c \\\n \truntime/go-convert-interface.c \\\n+\truntime/go-copy.c \\\n \truntime/go-defer.c \\\n \truntime/go-deferred-recover.c \\\n \truntime/go-eface-compare.c \\\n@@ -1892,6 +1893,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-closed.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-construct-map.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-convert-interface.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-copy.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-defer.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-deferred-recover.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-eface-compare.Plo@am__quote@\n@@ -2109,6 +2111,13 @@ go-convert-interface.lo: runtime/go-convert-interface.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-convert-interface.lo `test -f 'runtime/go-convert-interface.c' || echo '$(srcdir)/'`runtime/go-convert-interface.c\n \n+go-copy.lo: runtime/go-copy.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-copy.lo -MD -MP -MF $(DEPDIR)/go-copy.Tpo -c -o go-copy.lo `test -f 'runtime/go-copy.c' || echo '$(srcdir)/'`runtime/go-copy.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-copy.Tpo $(DEPDIR)/go-copy.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-copy.c' object='go-copy.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-copy.lo `test -f 'runtime/go-copy.c' || echo '$(srcdir)/'`runtime/go-copy.c\n+\n go-defer.lo: runtime/go-defer.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-defer.lo -MD -MP -MF $(DEPDIR)/go-defer.Tpo -c -o go-defer.lo `test -f 'runtime/go-defer.c' || echo '$(srcdir)/'`runtime/go-defer.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-defer.Tpo $(DEPDIR)/go-defer.Plo"}, {"sha": "91493b1b78d7ecb4082e1f0f99b0ec723eaa43c9", "filename": "libgo/runtime/go-append.c", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5343013fe2755e0ce86306e17ba316cddcc6e24/libgo%2Fruntime%2Fgo-append.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5343013fe2755e0ce86306e17ba316cddcc6e24/libgo%2Fruntime%2Fgo-append.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-append.c?ref=b5343013fe2755e0ce86306e17ba316cddcc6e24", "patch": "@@ -4,37 +4,43 @@\n    Use of this source code is governed by a BSD-style\n    license that can be found in the LICENSE file.  */\n \n-#include \"go-assert.h\"\n #include \"go-type.h\"\n+#include \"go-panic.h\"\n #include \"array.h\"\n #include \"runtime.h\"\n #include \"malloc.h\"\n \n+/* We should be OK if we don't split the stack here, since the only\n+   libc functions we call are memcpy and memmove.  If we don't do\n+   this, we will always split the stack, because of memcpy and\n+   memmove.  */\n+extern struct __go_open_array\n+__go_append (struct __go_open_array, void *, size_t, size_t)\n+  __attribute__ ((no_split_stack));\n+\n struct __go_open_array\n-__go_append (const struct __go_slice_type *type,\n-\t     struct __go_open_array a, struct __go_open_array b)\n+__go_append (struct __go_open_array a, void *bvalues, size_t bcount,\n+\t     size_t element_size)\n {\n-  size_t element_size;\n-  unsigned int ucount;\n+  size_t ucount;\n   int count;\n \n-  if (b.__values == NULL || b.__count == 0)\n+  if (bvalues == NULL || bcount == 0)\n     return a;\n \n-  __go_assert (type->__common.__code == GO_SLICE);\n-  element_size = type->__element_type->__size;\n-\n-  ucount = (unsigned int) a.__count + (unsigned int) b.__count;\n+  ucount = (size_t) a.__count + bcount;\n   count = (int) ucount;\n-  __go_assert (ucount == (unsigned int) count && count >= a.__count);\n+  if ((size_t) count != ucount || count <= a.__count)\n+    __go_panic_msg (\"append: slice overflow\");\n+\n   if (count > a.__capacity)\n     {\n       int m;\n-      struct __go_open_array n;\n+      void *n;\n \n       m = a.__capacity;\n       if (m == 0)\n-\tm = b.__count;\n+\tm = (int) bcount;\n       else\n \t{\n \t  do\n@@ -47,16 +53,15 @@ __go_append (const struct __go_slice_type *type,\n \t  while (m < count);\n \t}\n \n-      n.__values = __go_alloc (m * element_size);\n-      n.__count = a.__count;\n-      n.__capacity = m;\n-      __builtin_memcpy (n.__values, a.__values, n.__count * element_size);\n+      n = __go_alloc (m * element_size);\n+      __builtin_memcpy (n, a.__values, a.__count * element_size);\n \n-      a = n;\n+      a.__values = n;\n+      a.__capacity = m;\n     }\n \n   __builtin_memmove ((char *) a.__values + a.__count * element_size,\n-\t\t     b.__values, b.__count * element_size);\n+\t\t     bvalues, bcount * element_size);\n   a.__count = count;\n   return a;\n }"}, {"sha": "998aeb927d42d0d0b63def66539c1dfbdae296ca", "filename": "libgo/runtime/go-copy.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5343013fe2755e0ce86306e17ba316cddcc6e24/libgo%2Fruntime%2Fgo-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5343013fe2755e0ce86306e17ba316cddcc6e24/libgo%2Fruntime%2Fgo-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-copy.c?ref=b5343013fe2755e0ce86306e17ba316cddcc6e24", "patch": "@@ -0,0 +1,21 @@\n+/* go-append.c -- the go builtin copy function.\n+\n+   Copyright 2010 The Go Authors. All rights reserved.\n+   Use of this source code is governed by a BSD-style\n+   license that can be found in the LICENSE file.  */\n+\n+#include <stddef.h>\n+\n+/* We should be OK if we don't split the stack here, since we are just\n+   calling memmove which shouldn't need much stack.  If we don't do\n+   this we will always split the stack, because of memmove.  */\n+\n+extern void\n+__go_copy (void *, void *, size_t)\n+  __attribute__ ((no_split_stack));\n+\n+void\n+__go_copy (void *a, void *b, size_t len)\n+{\n+  __builtin_memmove (a, b, len);\n+}"}]}