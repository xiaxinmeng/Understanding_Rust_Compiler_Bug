{"sha": "d4f2852fbc4ef3dd705ba312c95288d465513333", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDRmMjg1MmZiYzRlZjNkZDcwNWJhMzEyYzk1Mjg4ZDQ2NTUxMzMzMw==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2001-04-29T12:43:20Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2001-04-29T12:43:20Z"}, "message": "c-aux-info.c: NULL_PTR->NULL in calls to `concat'.\n\n\t* c-aux-info.c: NULL_PTR->NULL in calls to `concat'.\n\n\t* gcc.c: Likewise.\n\n\t* prefix.c: Likewise.\n\nFrom-SVN: r41675", "tree": {"sha": "c834b9b8cd76b51e5d136f8e55a6f21b3ac421e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c834b9b8cd76b51e5d136f8e55a6f21b3ac421e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d4f2852fbc4ef3dd705ba312c95288d465513333", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4f2852fbc4ef3dd705ba312c95288d465513333", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4f2852fbc4ef3dd705ba312c95288d465513333", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4f2852fbc4ef3dd705ba312c95288d465513333/comments", "author": null, "committer": null, "parents": [{"sha": "7200764f6cd4acd841f55393bc908c0ccf81acbe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7200764f6cd4acd841f55393bc908c0ccf81acbe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7200764f6cd4acd841f55393bc908c0ccf81acbe"}], "stats": {"total": 151, "additions": 79, "deletions": 72}, "files": [{"sha": "a93fa931e52cfa27202ba7c9f350d14bdbeaaed1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4f2852fbc4ef3dd705ba312c95288d465513333/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4f2852fbc4ef3dd705ba312c95288d465513333/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d4f2852fbc4ef3dd705ba312c95288d465513333", "patch": "@@ -1,3 +1,11 @@\n+2001-04-29  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* c-aux-info.c: NULL_PTR->NULL in calls to `concat'.\n+\n+\t* gcc.c: Likewise.\n+\n+\t* prefix.c: Likewise.\n+\n 2001-04-28  Stan Shebs  <shebs@apple.com>\n \n \t* objc/objc-act.c (handle_class_ref): Rewrite to flush target"}, {"sha": "8cff76ef7e69e65c363766bc3405b67ddb475743", "filename": "gcc/c-aux-info.c", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4f2852fbc4ef3dd705ba312c95288d465513333/gcc%2Fc-aux-info.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4f2852fbc4ef3dd705ba312c95288d465513333/gcc%2Fc-aux-info.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-aux-info.c?ref=d4f2852fbc4ef3dd705ba312c95288d465513333", "patch": "@@ -92,13 +92,13 @@ affix_data_type (param)\n      add a blank after the data-type of course.  */\n \n   if (p == type_or_decl)\n-    return concat (data_type, \" \", type_or_decl, NULL_PTR);\n+    return concat (data_type, \" \", type_or_decl, NULL);\n \n   saved = *p;\n   *p = '\\0';\n-  qualifiers_then_data_type = concat (type_or_decl, data_type, NULL_PTR);\n+  qualifiers_then_data_type = concat (type_or_decl, data_type, NULL);\n   *p = saved;\n-  return concat (qualifiers_then_data_type, \" \", p, NULL_PTR);\n+  return concat (qualifiers_then_data_type, \" \", p, NULL);\n }\n \n /* Given a tree node which represents some \"function type\", generate the\n@@ -125,13 +125,13 @@ gen_formal_list_for_type (fntype, style)\n       const char *this_type;\n \n       if (*formal_list)\n-        formal_list = concat (formal_list, \", \", NULL_PTR);\n+        formal_list = concat (formal_list, \", \", NULL);\n \n       this_type = gen_type (\"\", TREE_VALUE (formal_type), ansi);\n       formal_list\n \t= ((strlen (this_type))\n-\t   ? concat (formal_list, affix_data_type (this_type), NULL_PTR)\n-\t   : concat (formal_list, data_type, NULL_PTR));\n+\t   ? concat (formal_list, affix_data_type (this_type), NULL)\n+\t   : concat (formal_list, data_type, NULL));\n \n       formal_type = TREE_CHAIN (formal_type);\n     }\n@@ -180,10 +180,10 @@ gen_formal_list_for_type (fntype, style)\n          petered out to a NULL (i.e. without being terminated by a\n          void_type_node) then we need to tack on an ellipsis.  */\n       if (!formal_type)\n-        formal_list = concat (formal_list, \", ...\", NULL_PTR);\n+        formal_list = concat (formal_list, \", ...\", NULL);\n     }\n \n-  return concat (\" (\", formal_list, \")\", NULL_PTR);\n+  return concat (\" (\", formal_list, \")\", NULL);\n }\n \n /* For the generation of an ANSI prototype for a function definition, we have\n@@ -242,23 +242,23 @@ gen_formal_list_for_func_def (fndecl, style)\n       const char *this_formal;\n \n       if (*formal_list && ((style == ansi) || (style == k_and_r_names)))\n-        formal_list = concat (formal_list, \", \", NULL_PTR);\n+        formal_list = concat (formal_list, \", \", NULL);\n       this_formal = gen_decl (formal_decl, 0, style);\n       if (style == k_and_r_decls)\n-        formal_list = concat (formal_list, this_formal, \"; \", NULL_PTR);\n+        formal_list = concat (formal_list, this_formal, \"; \", NULL);\n       else\n-        formal_list = concat (formal_list, this_formal, NULL_PTR);\n+        formal_list = concat (formal_list, this_formal, NULL);\n       formal_decl = TREE_CHAIN (formal_decl);\n     }\n   if (style == ansi)\n     {\n       if (!DECL_ARGUMENTS (fndecl))\n-        formal_list = concat (formal_list, \"void\", NULL_PTR);\n+        formal_list = concat (formal_list, \"void\", NULL);\n       if (deserves_ellipsis (TREE_TYPE (fndecl)))\n-        formal_list = concat (formal_list, \", ...\", NULL_PTR);\n+        formal_list = concat (formal_list, \", ...\", NULL);\n     }\n   if ((style == ansi) || (style == k_and_r_names))\n-    formal_list = concat (\" (\", formal_list, \")\", NULL_PTR);\n+    formal_list = concat (\" (\", formal_list, \")\", NULL);\n   return formal_list;\n }\n \n@@ -320,40 +320,40 @@ gen_type (ret_val, t, style)\n         {\n         case POINTER_TYPE:\n           if (TYPE_READONLY (t))\n-            ret_val = concat (\"const \", ret_val, NULL_PTR);\n+            ret_val = concat (\"const \", ret_val, NULL);\n           if (TYPE_VOLATILE (t))\n-            ret_val = concat (\"volatile \", ret_val, NULL_PTR);\n+            ret_val = concat (\"volatile \", ret_val, NULL);\n \n-          ret_val = concat (\"*\", ret_val, NULL_PTR);\n+          ret_val = concat (\"*\", ret_val, NULL);\n \n \t  if (TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE || TREE_CODE (TREE_TYPE (t)) == FUNCTION_TYPE)\n-\t    ret_val = concat (\"(\", ret_val, \")\", NULL_PTR);\n+\t    ret_val = concat (\"(\", ret_val, \")\", NULL);\n \n           ret_val = gen_type (ret_val, TREE_TYPE (t), style);\n \n           return ret_val;\n \n         case ARRAY_TYPE:\n \t  if (!COMPLETE_TYPE_P (t) || TREE_CODE (TYPE_SIZE (t)) != INTEGER_CST)\n-\t    ret_val = gen_type (concat (ret_val, \"[]\", NULL_PTR),\n+\t    ret_val = gen_type (concat (ret_val, \"[]\", NULL),\n \t\t\t\tTREE_TYPE (t), style);\n \t  else if (int_size_in_bytes (t) == 0)\n-\t    ret_val = gen_type (concat (ret_val, \"[0]\", NULL_PTR),\n+\t    ret_val = gen_type (concat (ret_val, \"[0]\", NULL),\n \t\t\t\tTREE_TYPE (t), style);\n \t  else\n \t    {\n \t      int size = (int_size_in_bytes (t) / int_size_in_bytes (TREE_TYPE (t)));\n \t      char buff[10];\n \t      sprintf (buff, \"[%d]\", size);\n-\t      ret_val = gen_type (concat (ret_val, buff, NULL_PTR),\n+\t      ret_val = gen_type (concat (ret_val, buff, NULL),\n \t\t\t\t  TREE_TYPE (t), style);\n \t    }\n           break;\n \n         case FUNCTION_TYPE:\n           ret_val = gen_type (concat (ret_val,\n \t\t\t\t      gen_formal_list_for_type (t, style),\n-\t\t\t\t      NULL_PTR),\n+\t\t\t\t      NULL),\n \t\t\t      TREE_TYPE (t), style);\n           break;\n \n@@ -382,13 +382,13 @@ gen_type (ret_val, t, style)\n \t      while (chain_p)\n \t\t{\n \t\t  data_type = concat (data_type, gen_decl (chain_p, 0, ansi),\n-\t\t\t\t      NULL_PTR);\n+\t\t\t\t      NULL);\n \t\t  chain_p = TREE_CHAIN (chain_p);\n-\t\t  data_type = concat (data_type, \"; \", NULL_PTR);\n+\t\t  data_type = concat (data_type, \"; \", NULL);\n \t\t}\n-\t      data_type = concat (\"{ \", data_type, \"}\", NULL_PTR);\n+\t      data_type = concat (\"{ \", data_type, \"}\", NULL);\n \t    }\n-\t  data_type = concat (\"struct \", data_type, NULL_PTR);\n+\t  data_type = concat (\"struct \", data_type, NULL);\n \t  break;\n \n         case UNION_TYPE:\n@@ -401,13 +401,13 @@ gen_type (ret_val, t, style)\n \t      while (chain_p)\n \t\t{\n \t\t  data_type = concat (data_type, gen_decl (chain_p, 0, ansi),\n-\t\t\t\t      NULL_PTR);\n+\t\t\t\t      NULL);\n \t\t  chain_p = TREE_CHAIN (chain_p);\n-\t\t  data_type = concat (data_type, \"; \", NULL_PTR);\n+\t\t  data_type = concat (data_type, \"; \", NULL);\n \t\t}\n-\t      data_type = concat (\"{ \", data_type, \"}\", NULL_PTR);\n+\t      data_type = concat (\"{ \", data_type, \"}\", NULL);\n \t    }\n-\t  data_type = concat (\"union \", data_type, NULL_PTR);\n+\t  data_type = concat (\"union \", data_type, NULL);\n \t  break;\n \n         case ENUMERAL_TYPE:\n@@ -420,14 +420,14 @@ gen_type (ret_val, t, style)\n \t      while (chain_p)\n \t\t{\n \t\t  data_type = concat (data_type,\n-\t\t\tIDENTIFIER_POINTER (TREE_PURPOSE (chain_p)), NULL_PTR);\n+\t\t\tIDENTIFIER_POINTER (TREE_PURPOSE (chain_p)), NULL);\n \t\t  chain_p = TREE_CHAIN (chain_p);\n \t\t  if (chain_p)\n-\t\t    data_type = concat (data_type, \", \", NULL_PTR);\n+\t\t    data_type = concat (data_type, \", \", NULL);\n \t\t}\n-\t      data_type = concat (\"{ \", data_type, \" }\", NULL_PTR);\n+\t      data_type = concat (\"{ \", data_type, \" }\", NULL);\n \t    }\n-\t  data_type = concat (\"enum \", data_type, NULL_PTR);\n+\t  data_type = concat (\"enum \", data_type, NULL);\n \t  break;\n \n         case TYPE_DECL:\n@@ -439,7 +439,7 @@ gen_type (ret_val, t, style)\n           /* Normally, `unsigned' is part of the deal.  Not so if it comes\n     \t     with a type qualifier.  */\n           if (TREE_UNSIGNED (t) && TYPE_QUALS (t))\n-    \t    data_type = concat (\"unsigned \", data_type, NULL_PTR);\n+    \t    data_type = concat (\"unsigned \", data_type, NULL);\n \t  break;\n \n         case REAL_TYPE:\n@@ -459,11 +459,11 @@ gen_type (ret_val, t, style)\n         }\n     }\n   if (TYPE_READONLY (t))\n-    ret_val = concat (\"const \", ret_val, NULL_PTR);\n+    ret_val = concat (\"const \", ret_val, NULL);\n   if (TYPE_VOLATILE (t))\n-    ret_val = concat (\"volatile \", ret_val, NULL_PTR);\n+    ret_val = concat (\"volatile \", ret_val, NULL);\n   if (TYPE_RESTRICT (t))\n-    ret_val = concat (\"restrict \", ret_val, NULL_PTR);\n+    ret_val = concat (\"restrict \", ret_val, NULL);\n   return ret_val;\n }\n \n@@ -505,9 +505,9 @@ gen_decl (decl, is_func_definition, style)\n      generate the qualifiers here.  */\n \n   if (TREE_THIS_VOLATILE (decl))\n-    ret_val = concat (\"volatile \", ret_val, NULL_PTR);\n+    ret_val = concat (\"volatile \", ret_val, NULL);\n   if (TREE_READONLY (decl))\n-    ret_val = concat (\"const \", ret_val, NULL_PTR);\n+    ret_val = concat (\"const \", ret_val, NULL);\n \n   data_type = \"\";\n \n@@ -526,7 +526,7 @@ gen_decl (decl, is_func_definition, style)\n   if (TREE_CODE (decl) == FUNCTION_DECL && is_func_definition)\n     {\n       ret_val = concat (ret_val, gen_formal_list_for_func_def (decl, ansi),\n-\t\t\tNULL_PTR);\n+\t\t\tNULL);\n \n       /* Since we have already added in the formals list stuff, here we don't\n          add the whole \"type\" of the function we are considering (which\n@@ -543,11 +543,11 @@ gen_decl (decl, is_func_definition, style)\n   ret_val = affix_data_type (ret_val);\n \n   if (TREE_CODE (decl) != FUNCTION_DECL && DECL_REGISTER (decl))\n-    ret_val = concat (\"register \", ret_val, NULL_PTR);\n+    ret_val = concat (\"register \", ret_val, NULL);\n   if (TREE_PUBLIC (decl))\n-    ret_val = concat (\"extern \", ret_val, NULL_PTR);\n+    ret_val = concat (\"extern \", ret_val, NULL);\n   if (TREE_CODE (decl) == FUNCTION_DECL && !TREE_PUBLIC (decl))\n-    ret_val = concat (\"static \", ret_val, NULL_PTR);\n+    ret_val = concat (\"static \", ret_val, NULL);\n \n   return ret_val;\n }"}, {"sha": "298bbce141ac6261ab08c2d6e9851fa2684ed5e0", "filename": "gcc/gcc.c", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4f2852fbc4ef3dd705ba312c95288d465513333/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4f2852fbc4ef3dd705ba312c95288d465513333/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=d4f2852fbc4ef3dd705ba312c95288d465513333", "patch": "@@ -1058,7 +1058,7 @@ translate_options (argcp, argvp)\n \t\t  /* Store the translation as one argv elt or as two.  */\n \t\t  if (arg != 0 && strchr (arginfo, 'j') != 0)\n \t\t    newv[newindex++] = concat (option_map[j].equivalent, arg,\n-\t\t\t\t\t       NULL_PTR);\n+\t\t\t\t\t       NULL);\n \t\t  else if (arg != 0)\n \t\t    {\n \t\t      newv[newindex++] = option_map[j].equivalent;\n@@ -1505,7 +1505,7 @@ set_spec (name, spec)\n \n   old_spec = *(sl->ptr_spec);\n   *(sl->ptr_spec) = ((spec[0] == '+' && ISSPACE ((unsigned char)spec[1]))\n-\t\t     ? concat (old_spec, spec + 1, NULL_PTR)\n+\t\t     ? concat (old_spec, spec + 1, NULL)\n \t\t     : xstrdup (spec));\n \n #ifdef DEBUG_SPECS\n@@ -3030,7 +3030,7 @@ process_command (argc, argv)\n       gcc_exec_prefix = make_relative_prefix (argv[0], standard_bindir_prefix,\n \t\t\t\t\t      standard_exec_prefix);\n       if (gcc_exec_prefix)\n-\tputenv (concat (\"GCC_EXEC_PREFIX=\", gcc_exec_prefix, NULL_PTR));\n+\tputenv (concat (\"GCC_EXEC_PREFIX=\", gcc_exec_prefix, NULL));\n     }\n #endif\n \n@@ -3072,7 +3072,7 @@ process_command (argc, argv)\n \t    {\n \t      strncpy (nstore, startp, endp - startp);\n \t      if (endp == startp)\n-\t\tstrcpy (nstore, concat (\".\", dir_separator_str, NULL_PTR));\n+\t\tstrcpy (nstore, concat (\".\", dir_separator_str, NULL));\n \t      else if (!IS_DIR_SEPARATOR (endp[-1]))\n \t\t{\n \t\t  nstore[endp - startp] = DIR_SEPARATOR;\n@@ -3083,7 +3083,7 @@ process_command (argc, argv)\n \t      add_prefix (&exec_prefixes, nstore, 0,\n \t\t\t  PREFIX_PRIORITY_LAST, 0, NULL_PTR);\n \t      add_prefix (&include_prefixes,\n-\t\t\t  concat (nstore, \"include\", NULL_PTR),\n+\t\t\t  concat (nstore, \"include\", NULL),\n \t\t\t  0, PREFIX_PRIORITY_LAST, 0, NULL_PTR);\n \t      if (*endp == 0)\n \t\tbreak;\n@@ -3107,7 +3107,7 @@ process_command (argc, argv)\n \t    {\n \t      strncpy (nstore, startp, endp - startp);\n \t      if (endp == startp)\n-\t\tstrcpy (nstore, concat (\".\", dir_separator_str, NULL_PTR));\n+\t\tstrcpy (nstore, concat (\".\", dir_separator_str, NULL));\n \t      else if (!IS_DIR_SEPARATOR (endp[-1]))\n \t\t{\n \t\t  nstore[endp - startp] = DIR_SEPARATOR;\n@@ -3140,7 +3140,7 @@ process_command (argc, argv)\n \t    {\n \t      strncpy (nstore, startp, endp - startp);\n \t      if (endp == startp)\n-\t\tstrcpy (nstore, concat (\".\", dir_separator_str, NULL_PTR));\n+\t\tstrcpy (nstore, concat (\".\", dir_separator_str, NULL));\n \t      else if (!IS_DIR_SEPARATOR (endp[-1]))\n \t\t{\n \t\t  nstore[endp - startp] = DIR_SEPARATOR;\n@@ -3390,8 +3390,7 @@ process_command (argc, argv)\n \t\t\t    PREFIX_PRIORITY_B_OPT, 0, &warn_B);\n \t\tadd_prefix (&startfile_prefixes, value, NULL_PTR,\n \t\t\t    PREFIX_PRIORITY_B_OPT, 0, &warn_B);\n-\t\tadd_prefix (&include_prefixes, concat (value, \"include\",\n-\t\t\t\t\t\t       NULL_PTR),\n+\t\tadd_prefix (&include_prefixes, concat (value, \"include\", NULL),\n \t\t\t    NULL_PTR,\n \t\t\t    PREFIX_PRIORITY_B_OPT, 0, NULL_PTR);\n \t\tn_switches++;\n@@ -3579,7 +3578,7 @@ process_command (argc, argv)\n \t      PREFIX_PRIORITY_LAST, 1, warn_std_ptr);\n \n   tooldir_prefix = concat (tooldir_base_prefix, spec_machine,\n-\t\t\t   dir_separator_str, NULL_PTR);\n+\t\t\t   dir_separator_str, NULL);\n \n   /* If tooldir is relative, base it on exec_prefixes.  A relative\n      tooldir lets us move the installed tree as a unit.\n@@ -3594,28 +3593,28 @@ process_command (argc, argv)\n \t{\n \t  char *gcc_exec_tooldir_prefix\n \t    = concat (gcc_exec_prefix, spec_machine, dir_separator_str,\n-\t\t      spec_version, dir_separator_str, tooldir_prefix, NULL_PTR);\n+\t\t      spec_version, dir_separator_str, tooldir_prefix, NULL);\n \n \t  add_prefix (&exec_prefixes,\n \t\t      concat (gcc_exec_tooldir_prefix, \"bin\",\n-\t\t\t      dir_separator_str, NULL_PTR),\n+\t\t\t      dir_separator_str, NULL),\n \t\t      NULL_PTR, PREFIX_PRIORITY_LAST, 0, NULL_PTR);\n \t  add_prefix (&startfile_prefixes,\n \t\t      concat (gcc_exec_tooldir_prefix, \"lib\",\n-\t\t\t      dir_separator_str, NULL_PTR),\n+\t\t\t      dir_separator_str, NULL),\n \t\t      NULL_PTR, PREFIX_PRIORITY_LAST, 0, NULL_PTR);\n \t}\n \n       tooldir_prefix = concat (standard_exec_prefix, spec_machine,\n \t\t\t       dir_separator_str, spec_version,\n-\t\t\t       dir_separator_str, tooldir_prefix, NULL_PTR);\n+\t\t\t       dir_separator_str, tooldir_prefix, NULL);\n     }\n \n   add_prefix (&exec_prefixes,\n-\t      concat (tooldir_prefix, \"bin\", dir_separator_str, NULL_PTR),\n+\t      concat (tooldir_prefix, \"bin\", dir_separator_str, NULL),\n \t      \"BINUTILS\", PREFIX_PRIORITY_LAST, 0, NULL_PTR);\n   add_prefix (&startfile_prefixes,\n-\t      concat (tooldir_prefix, \"lib\", dir_separator_str, NULL_PTR),\n+\t      concat (tooldir_prefix, \"lib\", dir_separator_str, NULL),\n \t      \"BINUTILS\", PREFIX_PRIORITY_LAST, 0, NULL_PTR);\n \n   /* More prefixes are enabled in main, after we read the specs file\n@@ -3740,7 +3739,7 @@ process_command (argc, argv)\n \t{ /* POSIX allows separation of -l and the lib arg;\n \t     canonicalize by concatenating -l with its arg */\n \t  infiles[n_infiles].language = \"*\";\n-\t  infiles[n_infiles++].name = concat (\"-l\", argv[++i], NULL_PTR);\n+\t  infiles[n_infiles++].name = concat (\"-l\", argv[++i], NULL);\n \t}\n       else if (strncmp (argv[i], \"-l\", 2) == 0)\n \t{\n@@ -5374,11 +5373,11 @@ is_directory (path1, path2, linker)\n   if (linker\n       && ((cp - path == 6\n \t   && strcmp (path, concat (dir_separator_str, \"lib\",\n-\t\t\t\t    dir_separator_str, \".\", NULL_PTR)) == 0)\n+\t\t\t\t    dir_separator_str, \".\", NULL)) == 0)\n \t  || (cp - path == 10\n \t      && strcmp (path, concat (dir_separator_str, \"usr\",\n \t\t\t\t       dir_separator_str, \"lib\",\n-\t\t\t\t       dir_separator_str, \".\", NULL_PTR)) == 0)))\n+\t\t\t\t       dir_separator_str, \".\", NULL)) == 0)))\n     return 0;\n \n   return (stat (path, &st) >= 0 && S_ISDIR (st.st_mode));\n@@ -5617,8 +5616,8 @@ main (argc, argv)\n   /* Read specs from a file if there is one.  */\n \n   machine_suffix = concat (spec_machine, dir_separator_str,\n-\t\t\t   spec_version, dir_separator_str, NULL_PTR);\n-  just_machine_suffix = concat (spec_machine, dir_separator_str, NULL_PTR);\n+\t\t\t   spec_version, dir_separator_str, NULL);\n+  just_machine_suffix = concat (spec_machine, dir_separator_str, NULL);\n \n   specs_file = find_a_file (&startfile_prefixes, \"specs\", R_OK);\n   /* Read the specs file unless it is a default one.  */\n@@ -5670,12 +5669,12 @@ main (argc, argv)\n \t  if (gcc_exec_prefix)\n \t    add_prefix (&startfile_prefixes,\n \t\t\tconcat (gcc_exec_prefix, machine_suffix,\n-\t\t\t\tstandard_startfile_prefix, NULL_PTR),\n+\t\t\t\tstandard_startfile_prefix, NULL),\n \t\t\tNULL_PTR, PREFIX_PRIORITY_LAST, 0, NULL_PTR);\n \t  add_prefix (&startfile_prefixes,\n \t\t      concat (standard_exec_prefix,\n \t\t\t      machine_suffix,\n-\t\t\t      standard_startfile_prefix, NULL_PTR),\n+\t\t\t      standard_startfile_prefix, NULL),\n \t\t      NULL_PTR, PREFIX_PRIORITY_LAST, 0, NULL_PTR);\n \t}\n \n@@ -5694,7 +5693,7 @@ main (argc, argv)\n \t  && gcc_exec_prefix)\n \tadd_prefix (&startfile_prefixes,\n \t\t    concat (gcc_exec_prefix, machine_suffix,\n-\t\t\t    standard_startfile_prefix, NULL_PTR),\n+\t\t\t    standard_startfile_prefix, NULL),\n \t\t    \"BINUTILS\", PREFIX_PRIORITY_LAST, 0, NULL_PTR);\n     }\n "}, {"sha": "7cb2e7b1befd70c91abb2b1e2aaaf888cbd36873", "filename": "gcc/prefix.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4f2852fbc4ef3dd705ba312c95288d465513333/gcc%2Fprefix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4f2852fbc4ef3dd705ba312c95288d465513333/gcc%2Fprefix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprefix.c?ref=d4f2852fbc4ef3dd705ba312c95288d465513333", "patch": "@@ -96,7 +96,7 @@ get_key_value (key)\n #endif\n \n   if (prefix == 0)\n-    prefix = getenv (temp = concat (key, \"_ROOT\", NULL_PTR));\n+    prefix = getenv (temp = concat (key, \"_ROOT\", NULL));\n \n   if (prefix == 0)\n     prefix = std_prefix;\n@@ -273,7 +273,7 @@ translate_name (name)\n      and intended by the user, causing two path components to run\n      together.  */\n \n-  return concat (prefix, name, NULL_PTR);\n+  return concat (prefix, name, NULL);\n }\n \n /* Update PATH using KEY if PATH starts with PREFIX.  */\n@@ -286,9 +286,9 @@ update_path (path, key)\n   if (! strncmp (path, std_prefix, strlen (std_prefix)) && key != 0)\n     {\n       if (key[0] != '$')\n-\tkey = concat (\"@\", key, NULL_PTR);\n+\tkey = concat (\"@\", key, NULL);\n \n-      path = concat (key, &path[strlen (std_prefix)], NULL_PTR);\n+      path = concat (key, &path[strlen (std_prefix)], NULL);\n \n       while (path[0] == '@' || path[0] == '$')\n \tpath = translate_name (path);"}]}