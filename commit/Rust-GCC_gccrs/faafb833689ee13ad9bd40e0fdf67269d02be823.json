{"sha": "faafb833689ee13ad9bd40e0fdf67269d02be823", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmFhZmI4MzM2ODllZTEzYWQ5YmQ0MGUwZmRmNjcyNjlkMDJiZTgyMw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2016-01-22T09:40:54Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2016-01-22T09:40:54Z"}, "message": "re PR debug/66668 (FAIL: gcc.dg/debug/dwarf2/stacked-qualified-types-3.c scan-assembler-times DIE \\\\([^\\n]*\\\\) DW_TAG_(?:const|volatile|atomic|restrict)_type 8)\n\n\tPR debug/66668\n\t* dwarf2out.c (add_child_die_after): New function.\n\t(dwarf_qual_info_t): New type.\n\t(dwarf_qual_info): New variable.\n\t(qualified_die_p): New function.\n\t(modified_type_die): For -fdebug-types-section, ensure\n\tcanonical order of qualifiers.  Put qualified DIEs adjacent\n\tto the corresponding non-qualified type DIE and search there\n\tfor existing qualified DIEs.\n\nFrom-SVN: r232719", "tree": {"sha": "f0eedfda54881bd57dd33a21c7022ee09650fd70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f0eedfda54881bd57dd33a21c7022ee09650fd70"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/faafb833689ee13ad9bd40e0fdf67269d02be823", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/faafb833689ee13ad9bd40e0fdf67269d02be823", "html_url": "https://github.com/Rust-GCC/gccrs/commit/faafb833689ee13ad9bd40e0fdf67269d02be823", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/faafb833689ee13ad9bd40e0fdf67269d02be823/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e1cf192b12c2b025dc675a05e88e9eb38ae82731", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1cf192b12c2b025dc675a05e88e9eb38ae82731", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1cf192b12c2b025dc675a05e88e9eb38ae82731"}], "stats": {"total": 160, "additions": 148, "deletions": 12}, "files": [{"sha": "f80de9c14505241496210b01370b16b742244de5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faafb833689ee13ad9bd40e0fdf67269d02be823/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faafb833689ee13ad9bd40e0fdf67269d02be823/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=faafb833689ee13ad9bd40e0fdf67269d02be823", "patch": "@@ -1,3 +1,15 @@\n+2016-01-22  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR debug/66668\n+\t* dwarf2out.c (add_child_die_after): New function.\n+\t(dwarf_qual_info_t): New type.\n+\t(dwarf_qual_info): New variable.\n+\t(qualified_die_p): New function.\n+\t(modified_type_die): For -fdebug-types-section, ensure\n+\tcanonical order of qualifiers.  Put qualified DIEs adjacent\n+\tto the corresponding non-qualified type DIE and search there\n+\tfor existing qualified DIEs.\n+\n 2016-01-22  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* doc/extend.texi (scalar_storage_order type attribute): Document"}, {"sha": "c657866ce7e62a7be66b6ec2d88dc16c3252a373", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 136, "deletions": 12, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faafb833689ee13ad9bd40e0fdf67269d02be823/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faafb833689ee13ad9bd40e0fdf67269d02be823/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=faafb833689ee13ad9bd40e0fdf67269d02be823", "patch": "@@ -4970,6 +4970,25 @@ add_child_die (dw_die_ref die, dw_die_ref child_die)\n   die->die_child = child_die;\n }\n \n+/* Like add_child_die, but put CHILD_DIE after AFTER_DIE.  */\n+\n+static void\n+add_child_die_after (dw_die_ref die, dw_die_ref child_die,\n+\t\t     dw_die_ref after_die)\n+{\n+  gcc_assert (die\n+\t      && child_die\n+\t      && after_die\n+\t      && die->die_child\n+\t      && die != child_die);\n+\n+  child_die->die_parent = die;\n+  child_die->die_sib = after_die->die_sib;\n+  after_die->die_sib = child_die;\n+  if (die->die_child == after_die)\n+    die->die_child = child_die;\n+}\n+\n /* Unassociate CHILD from its parent, and make its parent be\n    NEW_PARENT.  */\n \n@@ -11149,6 +11168,45 @@ get_nearest_type_subqualifiers (tree type, int type_quals, int qual_mask)\n   return best_qual;\n }\n \n+struct dwarf_qual_info_t { int q; enum dwarf_tag t; };\n+static const dwarf_qual_info_t dwarf_qual_info[] =\n+{\n+  { TYPE_QUAL_CONST, DW_TAG_const_type },\n+  { TYPE_QUAL_VOLATILE, DW_TAG_volatile_type },\n+  { TYPE_QUAL_RESTRICT, DW_TAG_restrict_type },\n+  { TYPE_QUAL_ATOMIC, DW_TAG_atomic_type }\n+};\n+static const unsigned int dwarf_qual_info_size\n+  = sizeof (dwarf_qual_info) / sizeof (dwarf_qual_info[0]);\n+\n+/* If DIE is a qualified DIE of some base DIE with the same parent,\n+   return the base DIE, otherwise return NULL.  Set MASK to the\n+   qualifiers added compared to the returned DIE.  */\n+\n+static dw_die_ref\n+qualified_die_p (dw_die_ref die, int *mask, unsigned int depth)\n+{\n+  unsigned int i;\n+  for (i = 0; i < dwarf_qual_info_size; i++)\n+    if (die->die_tag == dwarf_qual_info[i].t)\n+      break;\n+  if (i == dwarf_qual_info_size)\n+    return NULL;\n+  if (vec_safe_length (die->die_attr) != 1)\n+    return NULL;\n+  dw_die_ref type = get_AT_ref (die, DW_AT_type);\n+  if (type == NULL || type->die_parent != die->die_parent)\n+    return NULL;\n+  *mask |= dwarf_qual_info[i].q;\n+  if (depth)\n+    {\n+      dw_die_ref ret = qualified_die_p (type, mask, depth - 1);\n+      if (ret)\n+\treturn ret;\n+    }\n+  return type;\n+}\n+\n /* Given a pointer to an arbitrary ..._TYPE tree node, return a debugging\n    entry that chains the modifiers specified by CV_QUALS in front of the\n    given type.  REVERSE is true if the type is to be interpreted in the\n@@ -11255,31 +11313,97 @@ modified_type_die (tree type, int cv_quals, bool reverse,\n \n   if (cv_quals)\n     {\n-      struct qual_info { int q; enum dwarf_tag t; };\n-      static const struct qual_info qual_info[] =\n-\t{\n-\t  { TYPE_QUAL_ATOMIC, DW_TAG_atomic_type },\n-\t  { TYPE_QUAL_RESTRICT, DW_TAG_restrict_type },\n-\t  { TYPE_QUAL_VOLATILE, DW_TAG_volatile_type },\n-\t  { TYPE_QUAL_CONST, DW_TAG_const_type },\n-\t};\n-      int sub_quals;\n+      int sub_quals = 0, first_quals = 0;\n       unsigned i;\n+      dw_die_ref first = NULL, last = NULL;\n \n       /* Determine a lesser qualified type that most closely matches\n \t this one.  Then generate DW_TAG_* entries for the remaining\n \t qualifiers.  */\n       sub_quals = get_nearest_type_subqualifiers (type, cv_quals,\n \t\t\t\t\t\t  cv_qual_mask);\n+      if (sub_quals && use_debug_types)\n+\t{\n+\t  bool needed = false;\n+\t  /* If emitting type units, make sure the order of qualifiers\n+\t     is canonical.  Thus, start from unqualified type if\n+\t     an earlier qualifier is missing in sub_quals, but some later\n+\t     one is present there.  */\n+\t  for (i = 0; i < dwarf_qual_info_size; i++)\n+\t    if (dwarf_qual_info[i].q & cv_quals & ~sub_quals)\n+\t      needed = true;\n+\t    else if (needed && (dwarf_qual_info[i].q & cv_quals))\n+\t      {\n+\t\tsub_quals = 0;\n+\t\tbreak;\n+\t      }\n+\t}\n       mod_type_die = modified_type_die (type, sub_quals, reverse, context_die);\n+      if (mod_scope && mod_type_die && mod_type_die->die_parent == mod_scope)\n+\t{\n+\t  /* As not all intermediate qualified DIEs have corresponding\n+\t     tree types, ensure that qualified DIEs in the same scope\n+\t     as their DW_AT_type are emitted after their DW_AT_type,\n+\t     only with other qualified DIEs for the same type possibly\n+\t     in between them.  Determine the range of such qualified\n+\t     DIEs now (first being the base type, last being corresponding\n+\t     last qualified DIE for it).  */\n+\t  unsigned int count = 0;\n+\t  first = qualified_die_p (mod_type_die, &first_quals,\n+\t\t\t\t   dwarf_qual_info_size);\n+\t  if (first == NULL)\n+\t    first = mod_type_die;\n+\t  gcc_assert ((first_quals & ~sub_quals) == 0);\n+\t  for (count = 0, last = first;\n+\t       count < (1U << dwarf_qual_info_size);\n+\t       count++, last = last->die_sib)\n+\t    {\n+\t      int quals = 0;\n+\t      if (last == mod_scope->die_child)\n+\t\tbreak;\n+\t      if (qualified_die_p (last->die_sib, &quals, dwarf_qual_info_size)\n+\t\t  != first)\n+\t\tbreak;\n+\t    }\n+\t}\n \n-      for (i = 0; i < sizeof (qual_info) / sizeof (qual_info[0]); i++)\n-\tif (qual_info[i].q & cv_quals & ~sub_quals)\n+      for (i = 0; i < dwarf_qual_info_size; i++)\n+\tif (dwarf_qual_info[i].q & cv_quals & ~sub_quals)\n \t  {\n-\t    dw_die_ref d = new_die (qual_info[i].t, mod_scope, type);\n+\t    dw_die_ref d;\n+\t    if (first && first != last)\n+\t      {\n+\t\tfor (d = first->die_sib; ; d = d->die_sib)\n+\t\t  {\n+\t\t    int quals = 0;\n+\t\t    qualified_die_p (d, &quals, dwarf_qual_info_size);\n+\t\t    if (quals == (first_quals | dwarf_qual_info[i].q))\n+\t\t      break;\n+\t\t    if (d == last)\n+\t\t      {\n+\t\t\td = NULL;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t\tif (d)\n+\t\t  {\n+\t\t    mod_type_die = d;\n+\t\t    continue;\n+\t\t  }\n+\t      }\n+\t    if (first)\n+\t      {\n+\t\td = ggc_cleared_alloc<die_node> ();\n+\t\td->die_tag = dwarf_qual_info[i].t;\n+\t\tadd_child_die_after (mod_scope, d, last);\n+\t\tlast = d;\n+\t      }\n+\t    else\n+\t      d = new_die (dwarf_qual_info[i].t, mod_scope, type);\n \t    if (mod_type_die)\n \t      add_AT_die_ref (d, DW_AT_type, mod_type_die);\n \t    mod_type_die = d;\n+\t    first_quals |= dwarf_qual_info[i].q;\n \t  }\n     }\n   else if (code == POINTER_TYPE || code == REFERENCE_TYPE)"}]}