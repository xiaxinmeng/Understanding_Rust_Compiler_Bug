{"sha": "459f9f82ec0fe88bf83a5fbee366c6063a461c2b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDU5ZjlmODJlYzBmZTg4YmY4M2E1ZmJlZTM2NmM2MDYzYTQ2MWMyYg==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2006-09-22T14:22:21Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2006-09-22T14:22:21Z"}, "message": "boost_shared_ptr.h: Trivial formatting fixes.\n\n2006-09-22  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/tr1/boost_shared_ptr.h: Trivial formatting fixes.\n\nFrom-SVN: r117145", "tree": {"sha": "ba9e6a3ff8bc46ef12188b7b7e12db16ff927a69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba9e6a3ff8bc46ef12188b7b7e12db16ff927a69"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/459f9f82ec0fe88bf83a5fbee366c6063a461c2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/459f9f82ec0fe88bf83a5fbee366c6063a461c2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/459f9f82ec0fe88bf83a5fbee366c6063a461c2b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/459f9f82ec0fe88bf83a5fbee366c6063a461c2b/comments", "author": null, "committer": null, "parents": [{"sha": "53e3e587a9bf08ed74527e81c4a01ec933706a26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53e3e587a9bf08ed74527e81c4a01ec933706a26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53e3e587a9bf08ed74527e81c4a01ec933706a26"}], "stats": {"total": 1765, "additions": 890, "deletions": 875}, "files": [{"sha": "b10764cbe47abc81e98b27382db52989ad26c829", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/459f9f82ec0fe88bf83a5fbee366c6063a461c2b/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/459f9f82ec0fe88bf83a5fbee366c6063a461c2b/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=459f9f82ec0fe88bf83a5fbee366c6063a461c2b", "patch": "@@ -1,3 +1,7 @@\n+2006-09-22  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/tr1/boost_shared_ptr.h: Trivial formatting fixes.\n+\n 2006-09-21  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* include/ext/type_traits.h (__numeric_traits_integer): New."}, {"sha": "03632075e465a257c89a1e65ede3d4ea4b890f10", "filename": "libstdc++-v3/include/tr1/boost_shared_ptr.h", "status": "modified", "additions": 886, "deletions": 875, "changes": 1761, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/459f9f82ec0fe88bf83a5fbee366c6063a461c2b/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fboost_shared_ptr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/459f9f82ec0fe88bf83a5fbee366c6063a461c2b/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fboost_shared_ptr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fboost_shared_ptr.h?ref=459f9f82ec0fe88bf83a5fbee366c6063a461c2b", "patch": "@@ -58,1009 +58,1020 @@ namespace std\n {\n _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \n-class bad_weak_ptr : public std::exception\n-{\n-public:\n-  virtual char const*\n-  what() const throw() { return \"tr1::bad_weak_ptr\"; }\n-};\n+  class bad_weak_ptr : public std::exception\n+  {\n+  public:\n+    virtual char const*\n+    what() const throw()\n+    { return \"tr1::bad_weak_ptr\"; }\n+  };\n \n   // Substitute for bad_weak_ptr object in the case of -fno-exceptions.\n-inline void\n-__throw_bad_weak_ptr()\n-{\n+  inline void\n+  __throw_bad_weak_ptr()\n+  {\n #if __EXCEPTIONS\n-  throw bad_weak_ptr();\n+    throw bad_weak_ptr();\n #else\n-  std::abort();\n+    std::abort();\n #endif\n-}\n-\n-using __gnu_cxx::_Lock_policy;\n-using __gnu_cxx::__default_lock_policy;\n-using __gnu_cxx::_S_single;\n-using __gnu_cxx::_S_mutex;\n-using __gnu_cxx::_S_atomic;\n+  }\n \n-template<typename _Tp>\n-  struct _Sp_deleter\n-  {\n-    typedef void result_type;\n-    typedef _Tp* argument_type;\n+  using __gnu_cxx::_Lock_policy;\n+  using __gnu_cxx::__default_lock_policy;\n+  using __gnu_cxx::_S_single;\n+  using __gnu_cxx::_S_mutex;\n+  using __gnu_cxx::_S_atomic;\n \n-    void\n-    operator()(_Tp* p) const\n-    { delete p; }\n-  };\n+  template<typename _Tp>\n+    struct _Sp_deleter\n+    {\n+      typedef void result_type;\n+      typedef _Tp* argument_type;\n \n-// Empty helper class except when the template argument is _S_mutex.\n-template<_Lock_policy _Lp>\n-  class _Mutex_base\n-  { };\n+      void\n+      operator()(_Tp* p) const\n+      { delete p; }\n+    };\n \n-template<>\n-  class _Mutex_base<_S_mutex> : public __gnu_cxx::__mutex\n-  { };\n+  // Empty helper class except when the template argument is _S_mutex.\n+  template<_Lock_policy _Lp>\n+    class _Mutex_base\n+    { };\n \n+  template<>\n+    class _Mutex_base<_S_mutex> : public __gnu_cxx::__mutex\n+    { };\n \n-template<_Lock_policy _Lp = __default_lock_policy>\n-  class _Sp_counted_base : public _Mutex_base<_Lp>\n-  {\n-  public:  \n-    _Sp_counted_base() : _M_use_count(1), _M_weak_count(1) { }\n-  \n-    virtual\n-    ~_Sp_counted_base() // nothrow \n-    { }\n-  \n-    // Called when _M_use_count drops to zero, to release the resources\n-    // managed by *this.\n-    virtual void\n-    dispose() = 0; // nothrow\n-  \n-    // Called when _M_weak_count drops to zero.\n-    virtual void\n-    destroy() // nothrow\n-    { delete this; }\n-  \n-    virtual void*\n-    get_deleter(const std::type_info&) = 0;\n-  \n-    void\n-    add_ref_copy()\n-    { __gnu_cxx::__atomic_add(&_M_use_count, 1); }\n-  \n-    void\n-    add_ref_lock();\n-  \n-    void\n-    release() // nothrow\n+  template<_Lock_policy _Lp = __default_lock_policy>\n+    class _Sp_counted_base : public _Mutex_base<_Lp>\n     {\n-      if (__gnu_cxx::__exchange_and_add(&_M_use_count, -1) == 1)\n-        {\n-          dispose();\n-  #ifdef __GTHREADS\t\n-          _GLIBCXX_READ_MEM_BARRIER;\n-          _GLIBCXX_WRITE_MEM_BARRIER;\n-  #endif\n-          if (__gnu_cxx::__exchange_and_add(&_M_weak_count, -1) == 1)\n-            destroy();\n-        }\n-    }\n+    public:  \n+      _Sp_counted_base() : _M_use_count(1), _M_weak_count(1) { }\n+      \n+      virtual\n+      ~_Sp_counted_base() // nothrow \n+      { }\n   \n-    void\n-    weak_add_ref() // nothrow\n-    { __gnu_cxx::__atomic_add(&_M_weak_count, 1); }\n+      // Called when _M_use_count drops to zero, to release the resources\n+      // managed by *this.\n+      virtual void\n+      dispose() = 0; // nothrow\n+      \n+      // Called when _M_weak_count drops to zero.\n+      virtual void\n+      destroy() // nothrow\n+      { delete this; }\n+      \n+      virtual void*\n+      get_deleter(const std::type_info&) = 0;\n+      \n+      void\n+      add_ref_copy()\n+      { __gnu_cxx::__atomic_add(&_M_use_count, 1); }\n   \n-    void\n-    weak_release() // nothrow\n-    {\n-      if (__gnu_cxx::__exchange_and_add(&_M_weak_count, -1) == 1)\n-        {\n-#ifdef __GTHREADS\n-          _GLIBCXX_READ_MEM_BARRIER;\n-          _GLIBCXX_WRITE_MEM_BARRIER;\n+      void\n+      add_ref_lock();\n+      \n+      void\n+      release() // nothrow\n+      {\n+\tif (__gnu_cxx::__exchange_and_add(&_M_use_count, -1) == 1)\n+\t  {\n+\t    dispose();\n+#ifdef __GTHREADS\t\n+\t    _GLIBCXX_READ_MEM_BARRIER;\n+\t    _GLIBCXX_WRITE_MEM_BARRIER;\n #endif\n-          destroy();\n-        }\n-    }\n-  \n-    long\n-    use_count() const // nothrow\n-    { return _M_use_count; }  // XXX is this MT safe? \n+\t    if (__gnu_cxx::__exchange_and_add(&_M_weak_count, -1) == 1)\n+\t      destroy();\n+\t  }\n+      }\n   \n-  private:  \n-    _Sp_counted_base(_Sp_counted_base const&);\n-    _Sp_counted_base& operator=(_Sp_counted_base const&);\n+      void\n+      weak_add_ref() // nothrow\n+      { __gnu_cxx::__atomic_add(&_M_weak_count, 1); }\n   \n-    _Atomic_word _M_use_count;        // #shared\n-    _Atomic_word _M_weak_count;       // #weak + (#shared != 0)\n-  };\n-\n-template<>\n-  inline void\n-  _Sp_counted_base<_S_single>::add_ref_lock()\n-  {\n-    if (__gnu_cxx::__exchange_and_add(&_M_use_count, 1) == 0)\n+      void\n+      weak_release() // nothrow\n       {\n-        _M_use_count = 0;\n-        __throw_bad_weak_ptr();\n+\tif (__gnu_cxx::__exchange_and_add(&_M_weak_count, -1) == 1)\n+\t  {\n+#ifdef __GTHREADS\n+\t    _GLIBCXX_READ_MEM_BARRIER;\n+\t    _GLIBCXX_WRITE_MEM_BARRIER;\n+#endif\n+\t    destroy();\n+\t  }\n       }\n-  }\n+  \n+      long\n+      use_count() const // nothrow\n+      { return _M_use_count; }  // XXX is this MT safe? \n+      \n+    private:  \n+      _Sp_counted_base(_Sp_counted_base const&);\n+      _Sp_counted_base& operator=(_Sp_counted_base const&);\n+      \n+      _Atomic_word _M_use_count;        // #shared\n+      _Atomic_word _M_weak_count;       // #weak + (#shared != 0)\n+    };\n+\n+  template<>\n+    inline void\n+    _Sp_counted_base<_S_single>::add_ref_lock()\n+    {\n+      if (__gnu_cxx::__exchange_and_add(&_M_use_count, 1) == 0)\n+\t{\n+\t  _M_use_count = 0;\n+\t  __throw_bad_weak_ptr();\n+\t}\n+    }\n   \n #ifdef __GTHREADS\n-template<>\n-  inline void\n-  _Sp_counted_base<_S_mutex>::add_ref_lock()\n-  {\n-    __gnu_cxx::__scoped_lock sentry(*this);\n-    if (__gnu_cxx::__exchange_and_add(&_M_use_count, 1) == 0)\n-      {\n-        _M_use_count = 0;\n-        __throw_bad_weak_ptr();\n-      }\n-  }\n+  template<>\n+    inline void\n+    _Sp_counted_base<_S_mutex>::add_ref_lock()\n+    {\n+      __gnu_cxx::__scoped_lock sentry(*this);\n+      if (__gnu_cxx::__exchange_and_add(&_M_use_count, 1) == 0)\n+\t{\n+\t  _M_use_count = 0;\n+\t  __throw_bad_weak_ptr();\n+\t}\n+    }\n #endif\n \n-template<> \n-  inline void\n-  _Sp_counted_base<_S_atomic>::add_ref_lock()\n-  {\n-    // Perform lock-free add-if-not-zero operation.\n-    _Atomic_word __count;\n-    do\n+  template<> \n+    inline void\n+    _Sp_counted_base<_S_atomic>::add_ref_lock()\n     {\n-      __count = _M_use_count;\n-      if (__count == 0)\n-\t__throw_bad_weak_ptr();\n-\n-      // Replace the current counter value with the old value + 1, as\n-      // long as it's not changed meanwhile. \n+      // Perform lock-free add-if-not-zero operation.\n+      _Atomic_word __count;\n+      do\n+\t{\n+\t  __count = _M_use_count;\n+\t  if (__count == 0)\n+\t    __throw_bad_weak_ptr();\n+\t  \n+\t  // Replace the current counter value with the old value + 1, as\n+\t  // long as it's not changed meanwhile. \n+\t}\n+      while (!__sync_bool_compare_and_swap(&_M_use_count, __count,\n+\t\t\t\t\t   __count + 1));\n     }\n-    while (!__sync_bool_compare_and_swap(&_M_use_count, __count, __count + 1));\n-  }\n \n-template<typename _Ptr, typename _Deleter, _Lock_policy _Lp>\n-  class _Sp_counted_base_impl : public _Sp_counted_base<_Lp>\n-  {\n-  public:\n-    /**\n-     *  @brief   \n-     *  @pre     d(p) must not throw.\n-     */\n-    _Sp_counted_base_impl(_Ptr __p, _Deleter __d)\n-    : _M_ptr(__p), _M_del(__d) { }\n-    \n-    virtual void\n-    dispose() // nothrow\n-    { _M_del(_M_ptr); }\n-    \n-    virtual void*\n-    get_deleter(const std::type_info& __ti)\n-    { return __ti == typeid(_Deleter) ? &_M_del : 0; }\n-    \n-  private:\n-    _Sp_counted_base_impl(const _Sp_counted_base_impl&);\n-    _Sp_counted_base_impl& operator=(const _Sp_counted_base_impl&);\n+  template<typename _Ptr, typename _Deleter, _Lock_policy _Lp>\n+    class _Sp_counted_base_impl : public _Sp_counted_base<_Lp>\n+    {\n+    public:\n+      /**\n+       *  @brief   \n+       *  @pre     d(p) must not throw.\n+       */\n+      _Sp_counted_base_impl(_Ptr __p, _Deleter __d)\n+      : _M_ptr(__p), _M_del(__d) { }\n     \n-    _Ptr     _M_ptr; // copy constructor must not throw\n-    _Deleter _M_del; // copy constructor must not throw\n-  };\n+      virtual void\n+      dispose() // nothrow\n+      { _M_del(_M_ptr); }\n+      \n+      virtual void*\n+      get_deleter(const std::type_info& __ti)\n+      { return __ti == typeid(_Deleter) ? &_M_del : 0; }\n+      \n+    private:\n+      _Sp_counted_base_impl(const _Sp_counted_base_impl&);\n+      _Sp_counted_base_impl& operator=(const _Sp_counted_base_impl&);\n+      \n+      _Ptr     _M_ptr; // copy constructor must not throw\n+      _Deleter _M_del; // copy constructor must not throw\n+    };\n \n-template<_Lock_policy _Lp = __default_lock_policy>\n-  class weak_count;\n+  template<_Lock_policy _Lp = __default_lock_policy>\n+    class weak_count;\n \n-template<_Lock_policy _Lp = __default_lock_policy>\n-  class shared_count\n-  {\n-  private:  \n-    _Sp_counted_base<_Lp>* _M_pi;\n-  \n-    friend class weak_count<_Lp>;\n-  \n-  public:  \n-    shared_count() : _M_pi(0) // nothrow\n-    { }\n-  \n-    template<typename _Ptr, typename _Deleter>\n-      shared_count(_Ptr __p, _Deleter __d) : _M_pi(0)\n-      {\n-        try\n-          {\n-            _M_pi = new _Sp_counted_base_impl<_Ptr, _Deleter, _Lp>(__p, __d);\n-          }\n-        catch(...)\n-          {\n-            __d(__p); // Call _Deleter on __p.\n-            __throw_exception_again;\n-          }\n-      }\n-  \n-    // Special case for auto_ptr<_Tp> to provide the strong guarantee.\n-    template<typename _Tp>\n-      explicit shared_count(std::auto_ptr<_Tp>& __r)\n-      : _M_pi(new _Sp_counted_base_impl<_Tp*,\n-\t      _Sp_deleter<_Tp>, _Lp >(__r.get(), _Sp_deleter<_Tp>()))\n-      { __r.release(); }\n-  \n-    // Throw bad_weak_ptr when __r.use_count() == 0.\n-    explicit shared_count(const weak_count<_Lp>& __r);\n-  \n-    ~shared_count() // nothrow\n-    {\n-      if (_M_pi != 0)\n-        _M_pi->release();\n-    }\n-  \n-    shared_count(const shared_count& __r)\n-    : _M_pi(__r._M_pi) // nothrow\n-    {\n-      if (_M_pi != 0)\n-        _M_pi->add_ref_copy();\n-    }\n-  \n-    shared_count&\n-    operator=(const shared_count& __r) // nothrow\n+  template<_Lock_policy _Lp = __default_lock_policy>\n+    class shared_count\n     {\n-      _Sp_counted_base<_Lp>* __tmp = __r._M_pi;\n-      if (__tmp != _M_pi)\n-        {\n-          if (__tmp != 0)\n-            __tmp->add_ref_copy();\n-          if (_M_pi != 0)\n-            _M_pi->release();\n-          _M_pi = __tmp;\n-        }\n-      return *this;\n-    }\n+    private:  \n+      _Sp_counted_base<_Lp>* _M_pi;\n   \n-    void swap(shared_count& __r) // nothrow\n-    {\n-      _Sp_counted_base<_Lp>* __tmp = __r._M_pi;\n-      __r._M_pi = _M_pi;\n-      _M_pi = __tmp;\n-    }\n+      friend class weak_count<_Lp>;\n   \n-    long\n-    use_count() const // nothrow\n-    { return _M_pi != 0 ? _M_pi->use_count() : 0; }\n+    public: \n+      shared_count() : _M_pi(0) // nothrow\n+      { }\n   \n-    bool\n-    unique() const // nothrow\n-    { return this->use_count() == 1; }\n+      template<typename _Ptr, typename _Deleter>\n+        shared_count(_Ptr __p, _Deleter __d) : _M_pi(0)\n+        {\n+\t  try\n+\t    {\n+\t      _M_pi = new _Sp_counted_base_impl<_Ptr, _Deleter, _Lp>(__p, __d);\n+\t    }\n+\t  catch(...)\n+\t    {\n+\t      __d(__p); // Call _Deleter on __p.\n+\t      __throw_exception_again;\n+\t    }\n+\t}\n+      \n+      // Special case for auto_ptr<_Tp> to provide the strong guarantee.\n+      template<typename _Tp>\n+        explicit\n+        shared_count(std::auto_ptr<_Tp>& __r)\n+\t: _M_pi(new _Sp_counted_base_impl<_Tp*,\n+\t\t_Sp_deleter<_Tp>, _Lp >(__r.get(), _Sp_deleter<_Tp>()))\n+        { __r.release(); }\n   \n-    friend inline bool\n-    operator==(const shared_count& __a, const shared_count& __b)\n-    { return __a._M_pi == __b._M_pi; }\n+      // Throw bad_weak_ptr when __r.use_count() == 0.\n+      explicit shared_count(const weak_count<_Lp>& __r);\n   \n-    friend inline bool\n-    operator<(const shared_count& __a, const shared_count& __b)\n-    { return std::less<_Sp_counted_base<_Lp>*>()(__a._M_pi, __b._M_pi); }\n+      ~shared_count() // nothrow\n+      {\n+\tif (_M_pi != 0)\n+\t  _M_pi->release();\n+      }\n+      \n+      shared_count(const shared_count& __r)\n+      : _M_pi(__r._M_pi) // nothrow\n+      {\n+\tif (_M_pi != 0)\n+\t  _M_pi->add_ref_copy();\n+      }\n   \n-    void*\n-    get_deleter(const std::type_info& __ti) const\n-    { return _M_pi ? _M_pi->get_deleter(__ti) : 0; }\n-  };\n-\n-template<_Lock_policy _Lp>\n-  class weak_count\n-  {\n-  private:  \n-    _Sp_counted_base<_Lp>* _M_pi;\n+      shared_count&\n+      operator=(const shared_count& __r) // nothrow\n+      {\n+\t_Sp_counted_base<_Lp>* __tmp = __r._M_pi;\n+\tif (__tmp != _M_pi)\n+\t  {\n+\t    if (__tmp != 0)\n+\t      __tmp->add_ref_copy();\n+\t    if (_M_pi != 0)\n+\t      _M_pi->release();\n+\t    _M_pi = __tmp;\n+\t  }\n+\treturn *this;\n+      }\n   \n-    friend class shared_count<_Lp>;\n+      void\n+      swap(shared_count& __r) // nothrow\n+      {\n+\t_Sp_counted_base<_Lp>* __tmp = __r._M_pi;\n+\t__r._M_pi = _M_pi;\n+\t_M_pi = __tmp;\n+      }\n   \n-  public:  \n-    weak_count()\n-    : _M_pi(0) // nothrow\n-    { }\n+      long\n+      use_count() const // nothrow\n+      { return _M_pi != 0 ? _M_pi->use_count() : 0; }\n+      \n+      bool\n+      unique() const // nothrow\n+      { return this->use_count() == 1; }\n+      \n+      friend inline bool\n+      operator==(const shared_count& __a, const shared_count& __b)\n+      { return __a._M_pi == __b._M_pi; }\n   \n-    weak_count(const shared_count<_Lp>& __r)\n-    : _M_pi(__r._M_pi) // nothrow\n-    {\n-      if (_M_pi != 0)\n-        _M_pi->weak_add_ref();\n-    }\n+      friend inline bool\n+      operator<(const shared_count& __a, const shared_count& __b)\n+      { return std::less<_Sp_counted_base<_Lp>*>()(__a._M_pi, __b._M_pi); }\n   \n-    weak_count(const weak_count<_Lp>& __r)\n-    : _M_pi(__r._M_pi) // nothrow\n+      void*\n+      get_deleter(const std::type_info& __ti) const\n+      { return _M_pi ? _M_pi->get_deleter(__ti) : 0; }\n+    };\n+\n+  template<_Lock_policy _Lp>\n+    class weak_count\n     {\n-      if (_M_pi != 0)\n-        _M_pi->weak_add_ref();\n-    }\n+    private:  \n+      _Sp_counted_base<_Lp>* _M_pi;\n+      \n+      friend class shared_count<_Lp>;\n+      \n+    public:  \n+      weak_count()\n+      : _M_pi(0) // nothrow\n+      { }\n   \n-    ~weak_count() // nothrow\n-    {\n-      if (_M_pi != 0)\n-        _M_pi->weak_release();\n-    }\n+      weak_count(const shared_count<_Lp>& __r)\n+      : _M_pi(__r._M_pi) // nothrow\n+      {\n+\tif (_M_pi != 0)\n+\t  _M_pi->weak_add_ref();\n+      }\n+      \n+      weak_count(const weak_count<_Lp>& __r)\n+      : _M_pi(__r._M_pi) // nothrow\n+      {\n+\tif (_M_pi != 0)\n+\t  _M_pi->weak_add_ref();\n+      }\n+      \n+      ~weak_count() // nothrow\n+      {\n+\tif (_M_pi != 0)\n+\t  _M_pi->weak_release();\n+      }\n+      \n+      weak_count<_Lp>&\n+      operator=(const shared_count<_Lp>& __r) // nothrow\n+      {\n+\t_Sp_counted_base<_Lp>* __tmp = __r._M_pi;\n+\tif (__tmp != 0)\n+\t  __tmp->weak_add_ref();\n+\tif (_M_pi != 0)\n+\t  _M_pi->weak_release();\n+\t_M_pi = __tmp;  \n+\treturn *this;\n+      }\n+      \n+      weak_count<_Lp>&\n+      operator=(const weak_count<_Lp>& __r) // nothrow\n+      {\n+\t_Sp_counted_base<_Lp> * __tmp = __r._M_pi;\n+\tif (__tmp != 0)\n+\t  __tmp->weak_add_ref();\n+\tif (_M_pi != 0)\n+\t  _M_pi->weak_release();\n+\t_M_pi = __tmp;\n+\treturn *this;\n+      }\n   \n-    weak_count<_Lp>&\n-    operator=(const shared_count<_Lp>& __r) // nothrow\n-    {\n-      _Sp_counted_base<_Lp>* __tmp = __r._M_pi;\n-      if (__tmp != 0)\n-        __tmp->weak_add_ref();\n-      if (_M_pi != 0)\n-        _M_pi->weak_release();\n-      _M_pi = __tmp;  \n-      return *this;\n-    }\n+      void\n+      swap(weak_count<_Lp>& __r) // nothrow\n+      {\n+\t_Sp_counted_base<_Lp> * __tmp = __r._M_pi;\n+\t__r._M_pi = _M_pi;\n+\t_M_pi = __tmp;\n+      }\n   \n-    weak_count<_Lp>&\n-    operator=(const weak_count<_Lp>& __r) // nothrow\n+      long\n+      use_count() const // nothrow\n+      { return _M_pi != 0 ? _M_pi->use_count() : 0; }\n+      \n+      friend inline bool\n+      operator==(const weak_count<_Lp>& __a, const weak_count<_Lp>& __b)\n+      { return __a._M_pi == __b._M_pi; }\n+      \n+      friend inline bool\n+      operator<(const weak_count<_Lp>& __a, const weak_count<_Lp>& __b)\n+      { return std::less<_Sp_counted_base<_Lp>*>()(__a._M_pi, __b._M_pi); }\n+    };\n+\n+  template<_Lock_policy _Lp>\n+    inline\n+    shared_count<_Lp>::\n+    shared_count(const weak_count<_Lp>& __r)\n+    : _M_pi(__r._M_pi)\n     {\n-      _Sp_counted_base<_Lp> * __tmp = __r._M_pi;\n-      if (__tmp != 0)\n-        __tmp->weak_add_ref();\n       if (_M_pi != 0)\n-        _M_pi->weak_release();\n-      _M_pi = __tmp;\n-      return *this;\n-    }\n-  \n-    void\n-    swap(weak_count<_Lp>& __r) // nothrow\n-    {\n-      _Sp_counted_base<_Lp> * __tmp = __r._M_pi;\n-      __r._M_pi = _M_pi;\n-      _M_pi = __tmp;\n+\t_M_pi->add_ref_lock();\n+      else\n+\t__throw_bad_weak_ptr();\n     }\n   \n-    long\n-    use_count() const // nothrow\n-    { return _M_pi != 0 ? _M_pi->use_count() : 0; }\n-  \n-    friend inline bool\n-    operator==(const weak_count<_Lp>& __a, const weak_count<_Lp>& __b)\n-    { return __a._M_pi == __b._M_pi; }\n+\n+  // Forward decls.\n+  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>\n+    class __shared_ptr;\n   \n-    friend inline bool\n-    operator<(const weak_count<_Lp>& __a, const weak_count<_Lp>& __b)\n-    { return std::less<_Sp_counted_base<_Lp>*>()(__a._M_pi, __b._M_pi); }\n-  };\n+  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>\n+    class __weak_ptr;\n \n-template<_Lock_policy _Lp>\n-  inline\n-  shared_count<_Lp>::shared_count(const weak_count<_Lp>& __r)\n-  : _M_pi(__r._M_pi)\n-  {\n-    if (_M_pi != 0)\n-      _M_pi->add_ref_lock();\n-    else\n-      __throw_bad_weak_ptr();\n-  }\n+  template<typename _Tp, _Lock_policy _Lp>\n+    class __enable_shared_from_this;\n \n+  struct __static_cast_tag { };\n+  struct __const_cast_tag { };\n+  struct __dynamic_cast_tag { };\n+  struct __polymorphic_cast_tag { };\n \n-// Forward decls.\n-template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>\n-  class __shared_ptr;\n+  template<class _Tp>\n+    struct __shared_ptr_reference\n+    { typedef _Tp& __type; };\n \n-template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>\n-  class __weak_ptr;\n+  template<>\n+    struct __shared_ptr_reference<void>\n+    { typedef void __type; };\n \n-template<typename _Tp, _Lock_policy _Lp>\n-  class __enable_shared_from_this;\n+  template<>\n+    struct __shared_ptr_reference<void const>\n+    { typedef void __type; };\n \n-struct __static_cast_tag { };\n-struct __const_cast_tag { };\n-struct __dynamic_cast_tag { };\n-struct __polymorphic_cast_tag { };\n+  template<>\n+    struct __shared_ptr_reference<void volatile>\n+    { typedef void __type; };\n \n-template<class _Tp>\n-  struct shared_ptr_traits\n-  { typedef _Tp& reference; };\n+  template<>\n+    struct __shared_ptr_reference<void const volatile>\n+    { typedef void __type; };\n \n-template<>\n-  struct shared_ptr_traits<void>\n-  { typedef void reference; };\n \n-template<>\n-  struct shared_ptr_traits<void const>\n-  { typedef void reference; };\n+  // Support for enable_shared_from_this.\n \n-template<>\n-  struct shared_ptr_traits<void volatile>\n-  { typedef void reference; };\n+  // Friend of __enable_shared_from_this.\n+  template<_Lock_policy _Lp, typename _Tp1, typename _Tp2>\n+    void\n+    __enable_shared_from_this_helper(const shared_count<_Lp>&,\n+\t\t\t\t     const __enable_shared_from_this<_Tp1,\n+\t\t\t\t     _Lp>*, const _Tp2*);\n \n-template<>\n-  struct shared_ptr_traits<void const volatile>\n-  { typedef void reference; };\n+  template<_Lock_policy _Lp>\n+    inline void\n+    __enable_shared_from_this_helper(const shared_count<_Lp>&, ...)\n+    { }\n \n \n-// Support for enable_shared_from_this.\n+  /**\n+   *  @class shared_ptr <tr1/memory>\n+   *\n+   *  A smart pointer with reference-counted copy semantics.\n+   *  The object pointed to is deleted when the last shared_ptr pointing to\n+   *  it is destroyed or reset.\n+   */\n+  template<typename _Tp, _Lock_policy _Lp>\n+    class __shared_ptr\n+    {\n+      typedef typename __shared_ptr_reference<_Tp>::__type _Reference;\n \n-// Friend of __enable_shared_from_this.\n-template<_Lock_policy _Lp, typename _Tp1, typename _Tp2>\n-  void\n-  __enable_shared_from_this_helper(const shared_count<_Lp>&,\n-                            const __enable_shared_from_this<_Tp1, _Lp>*,\n-                            const _Tp2*);\n+    public:\n+      typedef _Tp   element_type;\n+      \n+      /** @brief  Construct an empty %__shared_ptr.\n+       *  @post   use_count()==0 && get()==0\n+       */\n+      __shared_ptr()\n+      : _M_ptr(0), _M_refcount() // never throws\n+      { }\n \n-template<_Lock_policy _Lp>\n-  inline void\n-  __enable_shared_from_this_helper(const shared_count<_Lp>&, ...)\n-  { }\n+      /** @brief  Construct a %__shared_ptr that owns the pointer @a p.\n+       *  @param  p  A pointer that is convertible to element_type*.\n+       *  @post   use_count() == 1 && get() == p\n+       *  @throw  std::bad_alloc, in which case @c delete @a p is called.\n+       */\n+      template<typename _Tp1>\n+        explicit\n+        __shared_ptr(_Tp1* __p)\n+\t: _M_ptr(__p), _M_refcount(__p, _Sp_deleter<_Tp1>())\n+        {\n+\t  __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n+\t  // __glibcxx_function_requires(_CompleteConcept<_Tp1*>)\n+\t  __enable_shared_from_this_helper( _M_refcount, __p, __p );\n+\t}\n \n+      //\n+      // Requirements: D's copy constructor and destructor must not throw\n+      //\n+      // __shared_ptr will release p by calling d(p)\n+      //\n+      /** @brief  Construct a %__shared_ptr that owns the pointer @a p\n+       *          and the deleter @a d.\n+       *  @param  p  A pointer.\n+       *  @param  d  A deleter.\n+       *  @post   use_count() == 1 && get() == p\n+       *  @throw  std::bad_alloc, in which case @a d(p) is called.\n+       */\n+      template<typename _Tp1, typename _Deleter>\n+        __shared_ptr(_Tp1* __p, _Deleter __d)\n+\t: _M_ptr(__p), _M_refcount(__p, __d)\n+        {\n+\t  __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n+\t  // TODO requires D is CopyConstructible and d(p) well-formed\n+\t  __enable_shared_from_this_helper( _M_refcount, __p, __p );\n+\t}\n+      \n+      //  generated copy constructor, assignment, destructor are fine.\n+      \n+      /** @brief  If @a r is empty, constructs an empty %__shared_ptr;\n+       *          otherwise construct a %__shared_ptr that shares ownership\n+       *          with @a r.\n+       *  @param  r  A %__shared_ptr.\n+       *  @post   get() == r.get() && use_count() == r.use_count()\n+       *  @throw  std::bad_alloc, in which case \n+       */\n+      template<typename _Tp1>\n+        __shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r)\n+\t: _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount) // never throws\n+        { __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>) }\n+\n+      /** @brief  Constructs a %__shared_ptr that shares ownership with @a r\n+       *          and stores a copy of the pointer stored in @a r.\n+       *  @param  r  A weak_ptr.\n+       *  @post   use_count() == r.use_count()\n+       *  @throw  bad_weak_ptr when r.expired(),\n+       *          in which case the constructor has no effect.\n+       */\n+      template<typename _Tp1>\n+        explicit\n+        __shared_ptr(const __weak_ptr<_Tp1, _Lp>& __r)\n+\t: _M_refcount(__r._M_refcount) // may throw\n+        {\n+\t  __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n+\t  // It is now safe to copy r__._M_ptr, as _M_refcount(__r._M_refcount)\n+\t  // did not throw.\n+\t  _M_ptr = __r._M_ptr;\n+\t}\n \n-/**\n- *  @class shared_ptr <tr1/memory>\n- *\n- *  A smart pointer with reference-counted copy semantics.\n- *  The object pointed to is deleted when the last shared_ptr pointing to it\n- *  is destroyed or reset.\n- */\n-template<typename _Tp, _Lock_policy _Lp>\n-  class __shared_ptr\n-  {\n-    typedef typename shared_ptr_traits<_Tp>::reference _Reference;\n+      /**\n+       * @post use_count() == 1 and r.get() == 0\n+       */\n+      template<typename _Tp1>\n+        explicit\n+        __shared_ptr(std::auto_ptr<_Tp1>& __r)\n+\t: _M_ptr(__r.get()), _M_refcount()\n+        {\n+\t  // TODO requires r.release() convertible to _Tp*, Tp1 is complete,\n+\t  // delete r.release() well-formed\n+\t  _Tp1 * __tmp = __r.get();\n+\t  _M_refcount = shared_count<_Lp>(__r);\n+\t  __enable_shared_from_this_helper( _M_refcount, __tmp, __tmp );\n+\t}\n \n-  public:\n-    typedef _Tp   element_type;\n+      template<typename _Tp1>\n+        __shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r, __static_cast_tag)\n+\t: _M_ptr(static_cast<element_type*>(__r._M_ptr)),\n+\t  _M_refcount(__r._M_refcount)\n+        { }\n+\n+      template<typename _Tp1>\n+        __shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r, __const_cast_tag)\n+\t: _M_ptr(const_cast<element_type*>(__r._M_ptr)),\n+\t  _M_refcount(__r._M_refcount)\n+        { }\n+\n+      template<typename _Tp1>\n+        __shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r, __dynamic_cast_tag)\n+\t: _M_ptr(dynamic_cast<element_type*>(__r._M_ptr)),\n+\t  _M_refcount(__r._M_refcount)\n+        {\n+\t  if (_M_ptr == 0) // need to allocate new counter -- the cast failed\n+\t    _M_refcount = shared_count<_Lp>();\n+\t}\n+      \n+      template<typename _Tp1>\n+        __shared_ptr&\n+        operator=(const __shared_ptr<_Tp1, _Lp>& __r) // never throws\n+        {\n+\t  _M_ptr = __r._M_ptr;\n+\t  _M_refcount = __r._M_refcount; // shared_count::op= doesn't throw\n+\t  return *this;\n+\t}\n \n-    /** @brief  Construct an empty %__shared_ptr.\n-     *  @post   use_count()==0 && get()==0\n-     */\n-    __shared_ptr()\n-    : _M_ptr(0), _M_refcount() // never throws\n-    { }\n+      template<typename _Tp1>\n+        __shared_ptr&\n+        operator=(std::auto_ptr<_Tp1>& __r)\n+        {\n+\t  __shared_ptr(__r).swap(*this);\n+\t  return *this;\n+\t}\n \n-    /** @brief  Construct a %__shared_ptr that owns the pointer @a p.\n-     *  @param  p  A pointer that is convertible to element_type*.\n-     *  @post   use_count() == 1 && get() == p\n-     *  @throw  std::bad_alloc, in which case @c delete @a p is called.\n-     */\n-    template<typename _Tp1>\n-      explicit __shared_ptr(_Tp1* __p)\n-      : _M_ptr(__p), _M_refcount(__p, _Sp_deleter<_Tp1>())\n-      {\n-        __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n-        // __glibcxx_function_requires(_CompleteConcept<_Tp1*>)\n-        __enable_shared_from_this_helper( _M_refcount, __p, __p );\n-      }\n+      void\n+      reset() // never throws\n+      { __shared_ptr().swap(*this); }\n \n-    //\n-    // Requirements: D's copy constructor and destructor must not throw\n-    //\n-    // __shared_ptr will release p by calling d(p)\n-    //\n-    /** @brief  Construct a %__shared_ptr that owns the pointer @a p\n-     *          and the deleter @a d.\n-     *  @param  p  A pointer.\n-     *  @param  d  A deleter.\n-     *  @post   use_count() == 1 && get() == p\n-     *  @throw  std::bad_alloc, in which case @a d(p) is called.\n-     */\n-    template<typename _Tp1, typename _Deleter>\n-      __shared_ptr(_Tp1* __p, _Deleter __d)\n-      : _M_ptr(__p), _M_refcount(__p, __d)\n-      {\n-        __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n-        // TODO requires D is CopyConstructible and d(p) well-formed\n-        __enable_shared_from_this_helper( _M_refcount, __p, __p );\n-      }\n+      template<typename _Tp1>\n+        void\n+        reset(_Tp1* __p) // _Tp1 must be complete.\n+        {\n+\t  // Catch self-reset errors.\n+\t  _GLIBCXX_DEBUG_ASSERT(__p == 0 || __p != _M_ptr); \n+\t  __shared_ptr(__p).swap(*this);\n+\t}\n \n-    //  generated copy constructor, assignment, destructor are fine.\n-\n-    /** @brief  If @a r is empty, constructs an empty %__shared_ptr; otherwise\n-     *          construct a %__shared_ptr that shares ownership with @a r.\n-     *  @param  r  A %__shared_ptr.\n-     *  @post   get() == r.get() && use_count() == r.use_count()\n-     *  @throw  std::bad_alloc, in which case \n-     */\n-    template<typename _Tp1>\n-      __shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r)\n-      : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount) // never throws\n-      { __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>) }\n-\n-    /** @brief  Constructs a %__shared_ptr that shares ownership with @a r\n-     *          and stores a copy of the pointer stored in @a r.\n-     *  @param  r  A weak_ptr.\n-     *  @post   use_count() == r.use_count()\n-     *  @throw  bad_weak_ptr when r.expired(),\n-     *          in which case the constructor has no effect.\n-     */\n-    template<typename _Tp1>\n-      explicit __shared_ptr(const __weak_ptr<_Tp1, _Lp>& __r)\n-      : _M_refcount(__r._M_refcount) // may throw\n-      {\n-        __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n-        // It is now safe to copy r__._M_ptr, as _M_refcount(__r._M_refcount)\n-        // did not throw.\n-        _M_ptr = __r._M_ptr;\n-      }\n+      template<typename _Tp1, typename _Deleter>\n+        void\n+        reset(_Tp1 * __p, _Deleter __d)\n+        { __shared_ptr(__p, __d).swap(*this); }\n \n-    /**\n-     * @post use_count() == 1 and r.get() == 0\n-     */\n-    template<typename _Tp1>\n-      explicit __shared_ptr(std::auto_ptr<_Tp1>& __r)\n-      : _M_ptr(__r.get()), _M_refcount()\n+      // Error to instantiate if _Tp is [cv-qual] void.\n+      _Reference\n+      operator*() const // never throws\n       {\n-        // TODO requires r.release() convertible to _Tp*, Tp1 is complete,\n-        // delete r.release() well-formed\n-        _Tp1 * __tmp = __r.get();\n-        _M_refcount = shared_count<_Lp>(__r);\n-        __enable_shared_from_this_helper( _M_refcount, __tmp, __tmp );\n+\t_GLIBCXX_DEBUG_ASSERT(_M_ptr != 0);\n+\treturn *_M_ptr;\n       }\n \n-    template<typename _Tp1>\n-      __shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r, __static_cast_tag)\n-      : _M_ptr(static_cast<element_type*>(__r._M_ptr)),\n-\t_M_refcount(__r._M_refcount)\n-      { }\n-\n-    template<typename _Tp1>\n-      __shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r, __const_cast_tag)\n-      : _M_ptr(const_cast<element_type*>(__r._M_ptr)),\n-\t_M_refcount(__r._M_refcount)\n-      { }\n-\n-    template<typename _Tp1>\n-      __shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r, __dynamic_cast_tag)\n-      : _M_ptr(dynamic_cast<element_type*>(__r._M_ptr)),\n-\t_M_refcount(__r._M_refcount)\n+      _Tp*\n+      operator->() const // never throws\n       {\n-        if (_M_ptr == 0) // need to allocate new counter -- the cast failed\n-          _M_refcount = shared_count<_Lp>();\n+\t_GLIBCXX_DEBUG_ASSERT(_M_ptr != 0);\n+\treturn _M_ptr;\n       }\n+    \n+      _Tp*\n+      get() const // never throws\n+      { return _M_ptr; }\n \n-    template<typename _Tp1>\n-      __shared_ptr&\n-      operator=(const __shared_ptr<_Tp1, _Lp>& __r) // never throws\n-      {\n-        _M_ptr = __r._M_ptr;\n-        _M_refcount = __r._M_refcount; // shared_count::op= doesn't throw\n-        return *this;\n-      }\n+      // Implicit conversion to \"bool\"\n+    private:\n+      typedef _Tp* __shared_ptr::*__unspecified_bool_type;\n \n-    template<typename _Tp1>\n-      __shared_ptr&\n-      operator=(std::auto_ptr<_Tp1>& __r)\n-      {\n-        __shared_ptr(__r).swap(*this);\n-        return *this;\n-      }\n+    public:\n+      operator __unspecified_bool_type() const // never throws\n+      { return _M_ptr == 0 ? 0 : &__shared_ptr::_M_ptr; }\n \n-    void\n-    reset() // never throws\n-    { __shared_ptr().swap(*this); }\n+      bool\n+      unique() const // never throws\n+      { return _M_refcount.unique(); }\n+\n+      long\n+      use_count() const // never throws\n+      { return _M_refcount.use_count(); }\n \n-    template<typename _Tp1>\n       void\n-      reset(_Tp1* __p) // _Tp1 must be complete.\n+      swap(__shared_ptr<_Tp, _Lp>& __other) // never throws\n       {\n-\t// Catch self-reset errors.\n-        _GLIBCXX_DEBUG_ASSERT(__p == 0 || __p != _M_ptr); \n-        __shared_ptr(__p).swap(*this);\n+\tstd::swap(_M_ptr, __other._M_ptr);\n+\t_M_refcount.swap(__other._M_refcount);\n       }\n \n-    template<typename _Tp1, typename _Deleter>\n-      void\n-      reset(_Tp1 * __p, _Deleter __d)\n-      { __shared_ptr(__p, __d).swap(*this); }\n-\n-    // Error to instantiate if _Tp is [cv-qual] void.\n-    _Reference\n-    operator*() const // never throws\n-    {\n-      _GLIBCXX_DEBUG_ASSERT(_M_ptr != 0);\n-      return *_M_ptr;\n-    }\n-\n-    _Tp*\n-    operator->() const // never throws\n+    private:\n+      void*\n+      _M_get_deleter(const std::type_info& __ti) const\n+      { return _M_refcount.get_deleter(__ti); }\n+\n+      template<typename _Tp1, _Lock_policy _Lp1>\n+        bool\n+        _M_less(const __shared_ptr<_Tp1, _Lp1>& __rhs) const\n+        { return _M_refcount < __rhs._M_refcount; }\n+\n+      template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;\n+      template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;\n+\n+      template<typename _Del, typename _Tp1, _Lock_policy _Lp1>\n+        friend _Del* get_deleter(const __shared_ptr<_Tp1, _Lp1>&);\n+\n+      // Friends injected into enclosing namespace and found by ADL:\n+      template<typename _Tp1>\n+        friend inline bool\n+        operator==(const __shared_ptr& __a, const __shared_ptr<_Tp1, _Lp>& __b)\n+        { return __a.get() == __b.get(); }\n+\n+      template<typename _Tp1>\n+        friend inline bool\n+        operator!=(const __shared_ptr& __a, const __shared_ptr<_Tp1, _Lp>& __b)\n+        { return __a.get() != __b.get(); }\n+\n+      template<typename _Tp1>\n+        friend inline bool\n+        operator<(const __shared_ptr& __a, const __shared_ptr<_Tp1, _Lp>& __b)\n+        { return __a._M_less(__b); }\n+\n+      _Tp*         \t        _M_ptr;         // Contained pointer.\n+      shared_count<_Lp> \t_M_refcount;    // Reference counter.\n+    };\n+\n+  // 2.2.3.8 shared_ptr specialized algorithms.\n+  template<typename _Tp, _Lock_policy _Lp>\n+    inline void\n+    swap(__shared_ptr<_Tp, _Lp>& __a, __shared_ptr<_Tp, _Lp>& __b)\n+    { __a.swap(__b); }\n+\n+  // 2.2.3.9 shared_ptr casts\n+  /** @warning The seemingly equivalent\n+   *           <code>shared_ptr<T>(static_cast<T*>(r.get()))</code>\n+   *           will eventually result in undefined behaviour,\n+   *           attempting to delete the same object twice.\n+   */\n+  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>\n+    __shared_ptr<_Tp, _Lp>\n+    static_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r)\n+    { return __shared_ptr<_Tp, _Lp>(__r, __static_cast_tag()); }\n+\n+  /** @warning The seemingly equivalent\n+   *           <code>shared_ptr<T>(const_cast<T*>(r.get()))</code>\n+   *           will eventually result in undefined behaviour,\n+   *           attempting to delete the same object twice.\n+   */\n+  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>\n+    __shared_ptr<_Tp, _Lp>\n+    const_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r)\n+    { return __shared_ptr<_Tp, _Lp>(__r, __const_cast_tag()); }\n+\n+  /** @warning The seemingly equivalent\n+   *           <code>shared_ptr<T>(dynamic_cast<T*>(r.get()))</code>\n+   *           will eventually result in undefined behaviour,\n+   *           attempting to delete the same object twice.\n+   */\n+  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>\n+    __shared_ptr<_Tp, _Lp>\n+    dynamic_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r)\n+    { return __shared_ptr<_Tp, _Lp>(__r, __dynamic_cast_tag()); }\n+\n+  // 2.2.3.7 shared_ptr I/O\n+  template<typename _Ch, typename _Tr, typename _Tp, _Lock_policy _Lp>\n+    std::basic_ostream<_Ch, _Tr>&\n+    operator<<(std::basic_ostream<_Ch, _Tr>& __os, \n+\t       const __shared_ptr<_Tp, _Lp>& __p)\n     {\n-      _GLIBCXX_DEBUG_ASSERT(_M_ptr != 0);\n-      return _M_ptr;\n+      __os << __p.get();\n+      return __os;\n     }\n-    \n-    _Tp*\n-    get() const // never throws\n-    { return _M_ptr; }\n-\n-    // Implicit conversion to \"bool\"\n-  private:\n-    typedef _Tp* __shared_ptr::*__unspecified_bool_type;\n-\n-  public:\n-    operator __unspecified_bool_type() const // never throws\n-    { return _M_ptr == 0 ? 0 : &__shared_ptr::_M_ptr; }\n \n-    bool\n-    unique() const // never throws\n-    { return _M_refcount.unique(); }\n+  // 2.2.3.10 shared_ptr get_deleter (experimental)\n+  template<typename _Del, typename _Tp, _Lock_policy _Lp>\n+    inline _Del*\n+    get_deleter(const __shared_ptr<_Tp, _Lp>& __p)\n+    { return static_cast<_Del*>(__p._M_get_deleter(typeid(_Del))); }\n \n-    long\n-    use_count() const // never throws\n-    { return _M_refcount.use_count(); }\n \n-    void\n-    swap(__shared_ptr<_Tp, _Lp>& __other) // never throws\n+  template<typename _Tp, _Lock_policy _Lp>\n+    class __weak_ptr\n     {\n-      std::swap(_M_ptr, __other._M_ptr);\n-      _M_refcount.swap(__other._M_refcount);\n-    }\n-\n-  private:\n-    void*\n-    _M_get_deleter(const std::type_info& __ti) const\n-    { return _M_refcount.get_deleter(__ti); }\n-\n-    template<typename _Tp1, _Lock_policy _Lp1>\n-      bool\n-      _M_less(const __shared_ptr<_Tp1, _Lp1>& __rhs) const\n-      { return _M_refcount < __rhs._M_refcount; }\n-\n-    template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;\n-    template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;\n-\n-    template<typename _Del, typename _Tp1, _Lock_policy _Lp1>\n-      friend _Del* get_deleter(const __shared_ptr<_Tp1, _Lp1>&);\n-\n-    // Friends injected into enclosing namespace and found by ADL:\n-    template<typename _Tp1>\n-      friend inline bool\n-      operator==(const __shared_ptr& __a, const __shared_ptr<_Tp1, _Lp>& __b)\n-      { return __a.get() == __b.get(); }\n-\n-    template<typename _Tp1>\n-      friend inline bool\n-      operator!=(const __shared_ptr& __a, const __shared_ptr<_Tp1, _Lp>& __b)\n-      { return __a.get() != __b.get(); }\n-\n-    template<typename _Tp1>\n-      friend inline bool\n-      operator<(const __shared_ptr& __a, const __shared_ptr<_Tp1, _Lp>& __b)\n-      { return __a._M_less(__b); }\n-\n-    _Tp*         \t_M_ptr;         // Contained pointer.\n-    shared_count<_Lp> \t_M_refcount;    // Reference counter.\n-  }; \n-\n-// 2.2.3.8 shared_ptr specialized algorithms.\n-template<typename _Tp, _Lock_policy _Lp>\n-  inline void\n-  swap(__shared_ptr<_Tp, _Lp>& __a, __shared_ptr<_Tp, _Lp>& __b)\n-  { __a.swap(__b); }\n-\n-// 2.2.3.9 shared_ptr casts\n-/** @warning The seemingly equivalent\n- *           <code>shared_ptr<T>(static_cast<T*>(r.get()))</code>\n- *           will eventually result in undefined behaviour,\n- *           attempting to delete the same object twice.\n- */\n-template<typename _Tp, typename _Tp1, _Lock_policy _Lp>\n-  __shared_ptr<_Tp, _Lp>\n-  static_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r)\n-  { return __shared_ptr<_Tp, _Lp>(__r, __static_cast_tag()); }\n-\n-/** @warning The seemingly equivalent\n- *           <code>shared_ptr<T>(const_cast<T*>(r.get()))</code>\n- *           will eventually result in undefined behaviour,\n- *           attempting to delete the same object twice.\n- */\n-template<typename _Tp, typename _Tp1, _Lock_policy _Lp>\n-  __shared_ptr<_Tp, _Lp>\n-  const_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r)\n-  { return __shared_ptr<_Tp, _Lp>(__r, __const_cast_tag()); }\n-\n-/** @warning The seemingly equivalent\n- *           <code>shared_ptr<T>(dynamic_cast<T*>(r.get()))</code>\n- *           will eventually result in undefined behaviour,\n- *           attempting to delete the same object twice.\n- */\n-template<typename _Tp, typename _Tp1, _Lock_policy _Lp>\n-  __shared_ptr<_Tp, _Lp>\n-  dynamic_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r)\n-  { return __shared_ptr<_Tp, _Lp>(__r, __dynamic_cast_tag()); }\n-\n-// 2.2.3.7 shared_ptr I/O\n-template<typename _Ch, typename _Tr, typename _Tp, _Lock_policy _Lp>\n-  std::basic_ostream<_Ch, _Tr>&\n-  operator<<(std::basic_ostream<_Ch, _Tr>& __os, \n-\t     const __shared_ptr<_Tp, _Lp>& __p)\n-  {\n-    __os << __p.get();\n-    return __os;\n-  }\n-\n-// 2.2.3.10 shared_ptr get_deleter (experimental)\n-template<typename _Del, typename _Tp, _Lock_policy _Lp>\n-  inline _Del*\n-  get_deleter(const __shared_ptr<_Tp, _Lp>& __p)\n-  { return static_cast<_Del*>(__p._M_get_deleter(typeid(_Del))); }\n-\n-\n-template<typename _Tp, _Lock_policy _Lp>\n-  class __weak_ptr\n-  {\n-  public:\n-    typedef _Tp element_type;\n-\n-    __weak_ptr() : _M_ptr(0), _M_refcount() // never throws\n-    { }\n+    public:\n+      typedef _Tp element_type;\n+      \n+      __weak_ptr() : _M_ptr(0), _M_refcount() // never throws\n+      { }\n \n-    // Generated copy constructor, assignment, destructor are fine.\n-\n-    // The \"obvious\" converting constructor implementation:\n-    //\n-    //  template<class Y>\n-    //    __weak_ptr(__weak_ptr<Y> const & r)\n-    //    : _M_ptr(r._M_ptr), _M_refcount(r._M_refcount) // never throws\n-    //    { }\n-    //\n-    // has a serious problem.\n-    //\n-    //  r._M_ptr may already have been invalidated. The _M_ptr(r._M_ptr)\n-    //  conversion may require access to *r._M_ptr (virtual inheritance).\n-    //\n-    // It is not possible to avoid spurious access violations since\n-    // in multithreaded programs r._M_ptr may be invalidated at any point.\n-    template<typename _Tp1>\n-      __weak_ptr(const __weak_ptr<_Tp1, _Lp>& r)\n-      : _M_refcount(r._M_refcount) // never throws\n-      {\n-        __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n-        _M_ptr = r.lock().get();\n-      }\n+      // Generated copy constructor, assignment, destructor are fine.\n+      \n+      // The \"obvious\" converting constructor implementation:\n+      //\n+      //  template<class Y>\n+      //    __weak_ptr(__weak_ptr<Y> const & r)\n+      //    : _M_ptr(r._M_ptr), _M_refcount(r._M_refcount) // never throws\n+      //    { }\n+      //\n+      // has a serious problem.\n+      //\n+      //  r._M_ptr may already have been invalidated. The _M_ptr(r._M_ptr)\n+      //  conversion may require access to *r._M_ptr (virtual inheritance).\n+      //\n+      // It is not possible to avoid spurious access violations since\n+      // in multithreaded programs r._M_ptr may be invalidated at any point.\n+      template<typename _Tp1>\n+        __weak_ptr(const __weak_ptr<_Tp1, _Lp>& r)\n+\t: _M_refcount(r._M_refcount) // never throws\n+        {\n+\t  __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n+\t    _M_ptr = r.lock().get();\n+\t}\n \n-    template<typename _Tp1>\n-      __weak_ptr(const __shared_ptr<_Tp1, _Lp>& r)\n-      : _M_ptr(r._M_ptr), _M_refcount(r._M_refcount) // never throws\n-      { __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>) }\n+      template<typename _Tp1>\n+        __weak_ptr(const __shared_ptr<_Tp1, _Lp>& r)\n+\t: _M_ptr(r._M_ptr), _M_refcount(r._M_refcount) // never throws\n+        { __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>) }\n \n-    template<typename _Tp1>\n-      __weak_ptr&\n-      operator=(const __weak_ptr<_Tp1, _Lp>& r) // never throws\n-      {\n-        _M_ptr = r.lock().get();\n-        _M_refcount = r._M_refcount;\n-        return *this;\n-      }\n+      template<typename _Tp1>\n+        __weak_ptr&\n+        operator=(const __weak_ptr<_Tp1, _Lp>& r) // never throws\n+        {\n+\t  _M_ptr = r.lock().get();\n+\t  _M_refcount = r._M_refcount;\n+\t  return *this;\n+\t}\n+      \n+      template<typename _Tp1>\n+        __weak_ptr&\n+        operator=(const __shared_ptr<_Tp1, _Lp>& r) // never throws\n+        {\n+\t  _M_ptr = r._M_ptr;\n+\t  _M_refcount = r._M_refcount;\n+\t  return *this;\n+\t}\n \n-    template<typename _Tp1>\n-      __weak_ptr&\n-      operator=(const __shared_ptr<_Tp1, _Lp>& r) // never throws\n+      __shared_ptr<_Tp, _Lp>\n+      lock() const // never throws\n       {\n-        _M_ptr = r._M_ptr;\n-        _M_refcount = r._M_refcount;\n-        return *this;\n-      }\n-\n-    __shared_ptr<_Tp, _Lp>\n-    lock() const // never throws\n-    {\n #ifdef __GTHREADS\n-      // Optimization: avoid throw overhead.\n-      if (expired())\n-\treturn __shared_ptr<element_type, _Lp>();\n+\t// Optimization: avoid throw overhead.\n+\tif (expired())\n+\t  return __shared_ptr<element_type, _Lp>();\n       \n-      try\n-\t{\n-\t  return __shared_ptr<element_type, _Lp>(*this);\n-\t}\n-      catch (const bad_weak_ptr&)\n-\t{\n-\t  // Q: How can we get here?\n-\t  // A: Another thread may have invalidated r after the\n-\t  //    use_count test above.\n-\t  return __shared_ptr<element_type>();\n-\t}\n-\n+\ttry\n+\t  {\n+\t    return __shared_ptr<element_type, _Lp>(*this);\n+\t  }\n+\tcatch (const bad_weak_ptr&)\n+\t  {\n+\t    // Q: How can we get here?\n+\t    // A: Another thread may have invalidated r after the\n+\t    //    use_count test above.\n+\t    return __shared_ptr<element_type>();\n+\t  }\n+\t\n #else\n-      // Optimization: avoid try/catch overhead when single threaded.\n-      return expired() ? __shared_ptr<element_type, _Lp>()\n-\t               : __shared_ptr<element_type, _Lp>(*this);\n+\t// Optimization: avoid try/catch overhead when single threaded.\n+\treturn expired() ? __shared_ptr<element_type, _Lp>()\n+\t                 : __shared_ptr<element_type, _Lp>(*this);\n \n #endif\n-    } // XXX MT\n-\n-    long\n-    use_count() const // never throws\n-    { return _M_refcount.use_count(); }\n-\n-    bool\n-    expired() const // never throws\n-    { return _M_refcount.use_count() == 0; }\n+      } // XXX MT\n \n-    void\n-    reset() // never throws\n-    { __weak_ptr().swap(*this); }\n-\n-    void\n-    swap(__weak_ptr& __s) // never throws\n-    {\n-      std::swap(_M_ptr, __s._M_ptr);\n-      _M_refcount.swap(__s._M_refcount);\n-    }\n+      long\n+      use_count() const // never throws\n+      { return _M_refcount.use_count(); }\n \n-  private:\n-    template<typename _Tp1>\n       bool\n-      _M_less(const __weak_ptr<_Tp1, _Lp>& __rhs) const\n-      { return _M_refcount < __rhs._M_refcount; }\n-\n-    // Used by __enable_shared_from_this.\n-    void\n-    _M_assign(_Tp* __ptr, const shared_count<_Lp>& __refcount)\n-    {\n-      _M_ptr = __ptr;\n-      _M_refcount = __refcount;\n-    }\n-\n-    // Friend injected into namespace and found by ADL.\n-    template<typename _Tp1>\n-      friend inline bool\n-      operator<(const __weak_ptr& __lhs, const __weak_ptr<_Tp1, _Lp>& __rhs)\n-      { return __lhs._M_less(__rhs); }\n-\n-    template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;\n-    template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;\n-    friend class __enable_shared_from_this<_Tp, _Lp>;\n-\n-    _Tp*       \t\t_M_ptr;           // Contained pointer.\n-    weak_count<_Lp> \t_M_refcount;      // Reference counter.\n-  };  \n-\n-// 2.2.4.7 weak_ptr specialized algorithms.\n-template<typename _Tp, _Lock_policy _Lp>\n-  void\n-  swap(__weak_ptr<_Tp, _Lp>& __a, __weak_ptr<_Tp, _Lp>& __b)\n-  { __a.swap(__b); }\n+      expired() const // never throws\n+      { return _M_refcount.use_count() == 0; }\n+      \n+      void\n+      reset() // never throws\n+      { __weak_ptr().swap(*this); }\n \n+      void\n+      swap(__weak_ptr& __s) // never throws\n+      {\n+\tstd::swap(_M_ptr, __s._M_ptr);\n+\t_M_refcount.swap(__s._M_refcount);\n+      }\n \n-template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>\n-  class __enable_shared_from_this\n-  {\n-  protected:\n-    __enable_shared_from_this() { }\n+    private:\n+      template<typename _Tp1>\n+        bool\n+        _M_less(const __weak_ptr<_Tp1, _Lp>& __rhs) const\n+        { return _M_refcount < __rhs._M_refcount; }\n \n-    __enable_shared_from_this(const __enable_shared_from_this&) { }\n+      // Used by __enable_shared_from_this.\n+      void\n+      _M_assign(_Tp* __ptr, const shared_count<_Lp>& __refcount)\n+      {\n+\t_M_ptr = __ptr;\n+\t_M_refcount = __refcount;\n+      }\n \n-    __enable_shared_from_this&\n-    operator=(const __enable_shared_from_this&)\n-    { return *this; }\n+      // Friend injected into namespace and found by ADL.\n+      template<typename _Tp1>\n+        friend inline bool\n+        operator<(const __weak_ptr& __lhs, const __weak_ptr<_Tp1, _Lp>& __rhs)\n+        { return __lhs._M_less(__rhs); }\n+      \n+      template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;\n+      template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;\n+      friend class __enable_shared_from_this<_Tp, _Lp>;\n+      \n+      _Tp*       \t\t_M_ptr;           // Contained pointer.\n+      weak_count<_Lp> \t        _M_refcount;      // Reference counter.\n+    };\n \n-    ~__enable_shared_from_this() { }\n+  // 2.2.4.7 weak_ptr specialized algorithms.\n+  template<typename _Tp, _Lock_policy _Lp>\n+    void\n+    swap(__weak_ptr<_Tp, _Lp>& __a, __weak_ptr<_Tp, _Lp>& __b)\n+    { __a.swap(__b); }\n \n-  public:\n-    __shared_ptr<_Tp, _Lp>\n-    shared_from_this()\n-    {\n-      __shared_ptr<_Tp, _Lp> __p(this->_M_weak_this);\n-      return __p;\n-    }\n \n-    __shared_ptr<const _Tp, _Lp>\n-    shared_from_this() const\n+  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>\n+    class __enable_shared_from_this\n     {\n-      __shared_ptr<const _Tp, _Lp> __p(this->_M_weak_this);\n-      return __p;\n-    }\n+    protected:\n+      __enable_shared_from_this() { }\n+      \n+      __enable_shared_from_this(const __enable_shared_from_this&) { }\n+      \n+      __enable_shared_from_this&\n+      operator=(const __enable_shared_from_this&)\n+      { return *this; }\n \n-  private:\n-    template<typename _Tp1>\n-      void\n-      _M_weak_assign(_Tp1* __p, const shared_count<_Lp>& __n) const\n-      { _M_weak_this._M_assign(__p, __n); }\n-\n-    template<typename _Tp1>\n-      friend void\n-      __enable_shared_from_this_helper(const shared_count<_Lp>& __pn,\n-\t\t\t\t       const __enable_shared_from_this* __pe,\n-\t\t\t\t       const _Tp1* __px)\n+      ~__enable_shared_from_this() { }\n+      \n+    public:\n+      __shared_ptr<_Tp, _Lp>\n+      shared_from_this()\n       {\n-        if (__pe != 0)\n-          __pe->_M_weak_assign(const_cast<_Tp1*>(__px), __pn);\n+\t__shared_ptr<_Tp, _Lp> __p(this->_M_weak_this);\n+\treturn __p;\n       }\n+      \n+      __shared_ptr<const _Tp, _Lp>\n+      shared_from_this() const\n+      {\n+\t__shared_ptr<const _Tp, _Lp> __p(this->_M_weak_this);\n+\treturn __p;\n+      }\n+      \n+    private:\n+      template<typename _Tp1>\n+        void\n+        _M_weak_assign(_Tp1* __p, const shared_count<_Lp>& __n) const\n+        { _M_weak_this._M_assign(__p, __n); }\n+\n+      template<typename _Tp1>\n+        friend void\n+        __enable_shared_from_this_helper(const shared_count<_Lp>& __pn,\n+\t\t\t\t\t const __enable_shared_from_this* __pe,\n+\t\t\t\t\t const _Tp1* __px)\n+        {\n+\t  if (__pe != 0)\n+\t    __pe->_M_weak_assign(const_cast<_Tp1*>(__px), __pn);\n+\t}\n+      \n+      mutable __weak_ptr<_Tp, _Lp> _M_weak_this;\n+    };\n \n-    mutable __weak_ptr<_Tp, _Lp> _M_weak_this;\n-  };\n-\n-template<typename _Tp>\n-  class shared_ptr;\n+  template<typename _Tp>\n+    class shared_ptr;\n \n-// The actual TR1 weak_ptr, with forwarding constructors and\n-// assignment operators.\n-template<typename _Tp>\n-  class weak_ptr : public __weak_ptr<_Tp>\n-  {\n-  public:\n-    weak_ptr() : __weak_ptr<_Tp>() { }\n-  \n-    template<typename _Tp1>\n-      weak_ptr(const __weak_ptr<_Tp1>& r) : __weak_ptr<_Tp>(r) { }\n+  // The actual TR1 weak_ptr, with forwarding constructors and\n+  // assignment operators.\n+  template<typename _Tp>\n+    class weak_ptr : public __weak_ptr<_Tp>\n+    {\n+    public:\n+      weak_ptr() : __weak_ptr<_Tp>() { }\n+      \n+      template<typename _Tp1>\n+        weak_ptr(const __weak_ptr<_Tp1>& r) : __weak_ptr<_Tp>(r) { }\n     \n-    template<typename _Tp1>\n-      weak_ptr(const __shared_ptr<_Tp1>& r) : __weak_ptr<_Tp>(r) { }\n+      template<typename _Tp1>\n+        weak_ptr(const __shared_ptr<_Tp1>& r) : __weak_ptr<_Tp>(r) { }\n \n-    template<typename _Tp1>\n-      weak_ptr&\n-      operator=(const weak_ptr<_Tp1>& r) // never throws\n-      {\n-        this->__weak_ptr<_Tp>::operator=(r);\n-        return *this;\n-      }\n+      template<typename _Tp1>\n+        weak_ptr&\n+        operator=(const weak_ptr<_Tp1>& r) // never throws\n+        {\n+\t  this->__weak_ptr<_Tp>::operator=(r);\n+\t  return *this;\n+\t}\n \n-    template<typename _Tp1>\n-      weak_ptr&\n-      operator=(const shared_ptr<_Tp1>& r) // never throws\n-      {\n-        this->__weak_ptr<_Tp>::operator=(r);\n-        return *this;\n-      }\n-  };\n+      template<typename _Tp1>\n+        weak_ptr&\n+        operator=(const shared_ptr<_Tp1>& r) // never throws\n+        {\n+\t  this->__weak_ptr<_Tp>::operator=(r);\n+\t  return *this;\n+\t}\n+    };\n \n-// The actual TR1 shared_ptr, with forwarding constructors and\n-// assignment operators.\n-template<typename _Tp>\n-  class shared_ptr : public __shared_ptr<_Tp>\n-  {\n-  public:\n-    shared_ptr() : __shared_ptr<_Tp>() { }\n-    \n-    template<typename _Tp1>\n-      explicit shared_ptr(_Tp1* __p)\n-      : __shared_ptr<_Tp>(__p) { }\n+  // The actual TR1 shared_ptr, with forwarding constructors and\n+  // assignment operators.\n+  template<typename _Tp>\n+    class shared_ptr : public __shared_ptr<_Tp>\n+    {\n+    public:\n+      shared_ptr() : __shared_ptr<_Tp>() { }\n+      \n+      template<typename _Tp1>\n+        explicit\n+        shared_ptr(_Tp1* __p)\n+\t: __shared_ptr<_Tp>(__p) { }\n     \n-    template<typename _Tp1, typename _Deleter>\n-      shared_ptr(_Tp1* __p, _Deleter __d)\n-      : __shared_ptr<_Tp>(__p, __d) { }\n+      template<typename _Tp1, typename _Deleter>\n+        shared_ptr(_Tp1* __p, _Deleter __d)\n+\t: __shared_ptr<_Tp>(__p, __d) { }\n     \n-    template<typename _Tp1>\n-      shared_ptr(const __shared_ptr<_Tp1>& __r)\n-      : __shared_ptr<_Tp>(__r) { }\n+      template<typename _Tp1>\n+        shared_ptr(const __shared_ptr<_Tp1>& __r)\n+\t: __shared_ptr<_Tp>(__r) { }\n     \n-    template<typename _Tp1>\n-      explicit shared_ptr(const __weak_ptr<_Tp1>& __r)\n-      : __shared_ptr<_Tp>(__r) { }\n+      template<typename _Tp1>\n+        explicit\n+        shared_ptr(const __weak_ptr<_Tp1>& __r)\n+\t: __shared_ptr<_Tp>(__r) { }\n     \n-    template<typename _Tp1>\n-      explicit shared_ptr(std::auto_ptr<_Tp1>& __r)\n-      : __shared_ptr<_Tp>(__r) { }\n-\n-    template<typename _Tp1>\n-      shared_ptr(const __shared_ptr<_Tp1>& __r, __static_cast_tag)\n-      : __shared_ptr<_Tp>(__r, __static_cast_tag()) { }\n-\n-    template<typename _Tp1>\n-      shared_ptr(const __shared_ptr<_Tp1>& __r, __const_cast_tag)\n-      : __shared_ptr<_Tp>(__r, __const_cast_tag()) { }\n+      template<typename _Tp1>\n+        explicit\n+        shared_ptr(std::auto_ptr<_Tp1>& __r)\n+\t: __shared_ptr<_Tp>(__r) { }\n+\n+      template<typename _Tp1>\n+        shared_ptr(const __shared_ptr<_Tp1>& __r, __static_cast_tag)\n+\t: __shared_ptr<_Tp>(__r, __static_cast_tag()) { }\n+\n+      template<typename _Tp1>\n+        shared_ptr(const __shared_ptr<_Tp1>& __r, __const_cast_tag)\n+\t: __shared_ptr<_Tp>(__r, __const_cast_tag()) { }\n     \n-    template<typename _Tp1>\n-      shared_ptr(const __shared_ptr<_Tp1>& __r, __dynamic_cast_tag)\n-      : __shared_ptr<_Tp>(__r, __dynamic_cast_tag()) { }\n-\n-    // Additional non-base assignment operators to avoid excessive errors.\n-    template<typename _Tp1>\n-      shared_ptr&\n-      operator=(std::auto_ptr<_Tp1>& __r)\n-      {\n-        this->__shared_ptr<_Tp>::operator=(__r);\n-        return *this;\n-      }\n-\n-    template<typename _Tp1>\n-      shared_ptr&\n-      operator=(const shared_ptr<_Tp1>& __r) // never throws\n-      {\n-        this->__shared_ptr<_Tp>::operator=(__r);\n-        return *this;\n-      }\n-  };\n+      template<typename _Tp1>\n+        shared_ptr(const __shared_ptr<_Tp1>& __r, __dynamic_cast_tag)\n+\t: __shared_ptr<_Tp>(__r, __dynamic_cast_tag()) { }\n+\n+      // Additional non-base assignment operators to avoid excessive errors.\n+      template<typename _Tp1>\n+        shared_ptr&\n+        operator=(std::auto_ptr<_Tp1>& __r)\n+        {\n+\t  this->__shared_ptr<_Tp>::operator=(__r);\n+\t  return *this;\n+\t}\n \n-template<typename _Tp>\n-  class enable_shared_from_this : public __enable_shared_from_this<_Tp>\n-  {\n-  protected:\n-    enable_shared_from_this()\n-    : __enable_shared_from_this<_Tp>() { }\n-    \n-    enable_shared_from_this(const enable_shared_from_this&)\n-    : __enable_shared_from_this<_Tp>(enable_shared_from_this<_Tp>()) { }\n-  };\n+      template<typename _Tp1>\n+        shared_ptr&\n+        operator=(const shared_ptr<_Tp1>& __r) // never throws\n+        {\n+\t  this->__shared_ptr<_Tp>::operator=(__r);\n+\t  return *this;\n+\t}\n+    };\n \n+  template<typename _Tp>\n+    class enable_shared_from_this : public __enable_shared_from_this<_Tp>\n+    {\n+    protected:\n+      enable_shared_from_this()\n+      : __enable_shared_from_this<_Tp>() { }\n+      \n+      enable_shared_from_this(const enable_shared_from_this&)\n+      : __enable_shared_from_this<_Tp>(enable_shared_from_this<_Tp>()) { }\n+    };\n+  \n _GLIBCXX_END_NAMESPACE\n } // namespace std\n "}]}