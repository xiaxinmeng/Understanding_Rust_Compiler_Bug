{"sha": "499b07700f0e679a490c2e3b80ca7c382dd737ab", "node_id": "C_kwDOANBUbNoAKDQ5OWIwNzcwMGYwZTY3OWE0OTBjMmUzYjgwY2E3YzM4MmRkNzM3YWI", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2023-03-12T20:43:31Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2023-03-13T20:57:03Z"}, "message": "d: Refactor DECL_ARGUMENT and DECL_RESULT generation to own function\n\nWhen looking into PR109108, the reason why things go awry is because\nof the logic around functions with thunks - they have their definitions\ngenerated even when they are external.  This subsequently then relied on\nthe detection of whether a function receiving codegen really is extern\nor not, and this check ultimately prunes too much.\n\nThis is a first step to both removing the call to `build_decl_tree' from\n`make_thunk' and the pruning of symbols within the `build_decl_tree'\nvisitor method for functions.  Move the generation of DECL_ARGUMENT and\nDECL_RESULT out of `build_decl_tree' and into their own functions.\n\ngcc/d/ChangeLog:\n\n\t* decl.cc (get_fndecl_result): New function.\n\t(get_fndecl_arguments): New function.\n\t(DeclVisitor::visit (FuncDeclaration *)): Adjust to call\n\tget_fndecl_arguments.\n\t(make_thunk): Adjust to call get_fndecl_arguments and\n\tget_fndecl_result.\n\t(start_function): Adjust to call get_fndecl_result.", "tree": {"sha": "e7c4275262cf9c28ee167e917ebf00b0a949fddd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e7c4275262cf9c28ee167e917ebf00b0a949fddd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/499b07700f0e679a490c2e3b80ca7c382dd737ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/499b07700f0e679a490c2e3b80ca7c382dd737ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/499b07700f0e679a490c2e3b80ca7c382dd737ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/499b07700f0e679a490c2e3b80ca7c382dd737ab/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6360bf9a2d08f08c151464c77c0da53cd702ff25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6360bf9a2d08f08c151464c77c0da53cd702ff25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6360bf9a2d08f08c151464c77c0da53cd702ff25"}], "stats": {"total": 206, "additions": 118, "deletions": 88}, "files": [{"sha": "d4e936d0f83a5e5b29c33ff5f3a42d4eb74dde51", "filename": "gcc/d/decl.cc", "status": "modified", "additions": 118, "deletions": 88, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/499b07700f0e679a490c2e3b80ca7c382dd737ab/gcc%2Fd%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/499b07700f0e679a490c2e3b80ca7c382dd737ab/gcc%2Fd%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdecl.cc?ref=499b07700f0e679a490c2e3b80ca7c382dd737ab", "patch": "@@ -117,6 +117,113 @@ gcc_attribute_p (Dsymbol *decl)\n   return false;\n }\n \n+/* Return the DECL_RESULT for the function declaration DECL, create it if it\n+   doesn't already exist.  */\n+\n+static tree\n+get_fndecl_result (FuncDeclaration *decl)\n+{\n+  tree fndecl = get_symbol_decl (decl);\n+  tree resdecl = DECL_RESULT (fndecl);\n+\n+  if (resdecl != NULL_TREE)\n+    return resdecl;\n+\n+  resdecl = build_decl (make_location_t (decl->loc), RESULT_DECL,\n+\t\t\tNULL_TREE, TREE_TYPE (TREE_TYPE (fndecl)));\n+\n+  DECL_ARTIFICIAL (resdecl) = 1;\n+  DECL_IGNORED_P (resdecl) = 1;\n+  DECL_CONTEXT (resdecl) = fndecl;\n+  DECL_RESULT (fndecl) = resdecl;\n+  return resdecl;\n+}\n+\n+/* Return the list of PARAM_DECLs for the function declaration DECL, create it\n+   if it doesn't already exist.  */\n+\n+static tree\n+get_fndecl_arguments (FuncDeclaration *decl)\n+{\n+  tree fndecl = get_symbol_decl (decl);\n+  tree param_list = DECL_ARGUMENTS (fndecl);\n+\n+  if (param_list != NULL_TREE)\n+    return param_list;\n+\n+  if (decl->fbody)\n+    {\n+      /* Handle special arguments first.  */\n+\n+      /* `this' parameter:\n+\t For nested functions, D still generates a vthis, but it\n+\t should not be referenced in any expression.  */\n+      if (decl->vthis)\n+\t{\n+\t  tree parm_decl = get_symbol_decl (decl->vthis);\n+\t  DECL_ARTIFICIAL (parm_decl) = 1;\n+\t  TREE_READONLY (parm_decl) = 1;\n+\n+\t  if (decl->vthis->type == Type::tvoidptr)\n+\t    {\n+\t      /* Replace generic pointer with back-end closure type\n+\t\t (this wins for gdb).  */\n+\t      tree frame_type = FRAMEINFO_TYPE (get_frameinfo (decl));\n+\t      gcc_assert (frame_type != NULL_TREE);\n+\t      TREE_TYPE (parm_decl) = build_pointer_type (frame_type);\n+\t    }\n+\n+\t  param_list = chainon (param_list, parm_decl);\n+\t}\n+\n+      /* `_arguments' parameter.  */\n+      if (decl->v_arguments)\n+\t{\n+\t  tree parm_decl = get_symbol_decl (decl->v_arguments);\n+\t  param_list = chainon (param_list, parm_decl);\n+\t}\n+\n+      /* Now add on formal function parameters.  */\n+      size_t n_parameters = decl->parameters ? decl->parameters->length : 0;\n+\n+      for (size_t i = 0; i < n_parameters; i++)\n+\t{\n+\t  VarDeclaration *param = (*decl->parameters)[i];\n+\t  tree parm_decl = get_symbol_decl (param);\n+\n+\t  /* Type `noreturn` is a terminator, as no other arguments can possibly\n+\t     be evaluated after it.  */\n+\t  if (TREE_TYPE (parm_decl) == noreturn_type_node)\n+\t    break;\n+\n+\t  /* Chain them in the correct order.  */\n+\t  param_list = chainon (param_list, parm_decl);\n+\t}\n+    }\n+  else\n+    {\n+      /* Build parameters from the function type.  */\n+      tree fntype = TREE_TYPE (fndecl);\n+\n+      for (tree t = TYPE_ARG_TYPES (fntype); t; t = TREE_CHAIN (t))\n+\t{\n+\t  if (t == void_list_node)\n+\t    break;\n+\n+\t  tree param = build_decl (DECL_SOURCE_LOCATION (fndecl),\n+\t\t\t\t   PARM_DECL, NULL_TREE, TREE_VALUE (t));\n+\t  DECL_ARG_TYPE (param) = TREE_TYPE (param);\n+\t  DECL_ARTIFICIAL (param) = 1;\n+\t  DECL_IGNORED_P (param) = 1;\n+\t  DECL_CONTEXT (param) = fndecl;\n+\t  param_list = chainon (param_list, param);\n+\t}\n+    }\n+\n+  DECL_ARGUMENTS (fndecl) = param_list;\n+  return param_list;\n+}\n+\n /* Implements the visitor interface to lower all Declaration AST classes\n    emitted from the D Front-end to GCC trees.\n    All visit methods accept one parameter D, which holds the frontend AST\n@@ -861,66 +968,17 @@ class DeclVisitor : public Visitor\n       message (\"function  %s\", d->toPrettyChars ());\n \n     tree old_context = start_function (d);\n+    tree param_list = get_fndecl_arguments (d);\n \n-    tree parm_decl = NULL_TREE;\n-    tree param_list = NULL_TREE;\n-\n-    /* Special arguments...  */\n-\n-    /* `this' parameter:\n-       For nested functions, D still generates a vthis, but it\n-       should not be referenced in any expression.  */\n-    if (d->vthis)\n-      {\n-\tparm_decl = get_symbol_decl (d->vthis);\n-\tDECL_ARTIFICIAL (parm_decl) = 1;\n-\tTREE_READONLY (parm_decl) = 1;\n-\n-\tif (d->vthis->type == Type::tvoidptr)\n-\t  {\n-\t    /* Replace generic pointer with back-end closure type\n-\t       (this wins for gdb).  */\n-\t    tree frame_type = FRAMEINFO_TYPE (get_frameinfo (d));\n-\t    gcc_assert (frame_type != NULL_TREE);\n-\t    TREE_TYPE (parm_decl) = build_pointer_type (frame_type);\n-\t  }\n-\n-\tparam_list = chainon (param_list, parm_decl);\n-\td_function_chain->static_chain = parm_decl;\n-      }\n-\n-    /* _arguments parameter.  */\n-    if (d->v_arguments)\n-      {\n-\tparm_decl = get_symbol_decl (d->v_arguments);\n-\tparam_list = chainon (param_list, parm_decl);\n-      }\n-\n-    /* formal function parameters.  */\n-    const size_t n_parameters = d->parameters ? d->parameters->length : 0;\n-\n-    for (size_t i = 0; i < n_parameters; i++)\n-      {\n-\tVarDeclaration *param = (*d->parameters)[i];\n-\n-\tparm_decl = get_symbol_decl (param);\n-\n-\t/* Type `noreturn` is a terminator, as no other arguments can possibly\n-\t   be evaluated after it.  */\n-\tif (TREE_TYPE (parm_decl) == noreturn_type_node)\n-\t  break;\n-\n-\t/* Chain them in the correct order.  */\n-\tparam_list = chainon (param_list, parm_decl);\n-      }\n-\n-    DECL_ARGUMENTS (fndecl) = param_list;\n     DECL_IN_UNITTEST_CONDITION_P (fndecl) = this->in_version_unittest_;\n     rest_of_decl_compilation (fndecl, 1, 0);\n \n     /* If this is a member function that nested (possibly indirectly) in another\n        function, construct an expession for this member function's static chain\n        by going through parent link of nested classes.  */\n+    if (d->vthis)\n+      d_function_chain->static_chain = get_symbol_decl (d->vthis);\n+\n     if (d->isThis ())\n       {\n \tAggregateDeclaration *ad = d->isThis ();\n@@ -935,7 +993,7 @@ class DeclVisitor : public Visitor\n \t    ad = pd->isAggregateDeclaration ();\n \t    if (ad == NULL)\n \t      {\n-\t\tcfun->language->static_chain = this_tree;\n+\t\td_function_chain->static_chain = this_tree;\n \t\tbreak;\n \t      }\n \t  }\n@@ -996,7 +1054,7 @@ class DeclVisitor : public Visitor\n \tvar = build_address (var);\n \n \ttree init = build_call_expr (builtin_decl_explicit (BUILT_IN_VA_START),\n-\t\t\t\t     2, var, parm_decl);\n+\t\t\t\t     2, var, tree_last (param_list));\n \tdeclare_local_var (d->v_argptr);\n \tadd_stmt (init);\n \n@@ -1879,34 +1937,12 @@ make_thunk (FuncDeclaration *decl, int offset)\n \t{\n \t  /* Build parameters for functions that are not being compiled,\n \t     so that they can be correctly cloned in finish_thunk.  */\n-\t  tree fntype = TREE_TYPE (function);\n-\t  tree params = NULL_TREE;\n-\n-\t  for (tree t = TYPE_ARG_TYPES (fntype); t; t = TREE_CHAIN (t))\n-\t    {\n-\t      if (t == void_list_node)\n-\t\tbreak;\n-\n-\t      tree param = build_decl (DECL_SOURCE_LOCATION (function),\n-\t\t\t\t       PARM_DECL, NULL_TREE, TREE_VALUE (t));\n-\t      DECL_ARG_TYPE (param) = TREE_TYPE (param);\n-\t      DECL_ARTIFICIAL (param) = 1;\n-\t      DECL_IGNORED_P (param) = 1;\n-\t      DECL_CONTEXT (param) = function;\n-\t      params = chainon (params, param);\n-\t    }\n-\n-\t  DECL_ARGUMENTS (function) = params;\n+\t  tree function = get_symbol_decl (decl);\n+\t  DECL_ARGUMENTS (function) = get_fndecl_arguments (decl);\n \n \t  /* Also build the result decl, which is needed when force creating\n \t     the thunk in gimple inside cgraph_node::expand_thunk.  */\n-\t  tree resdecl = build_decl (DECL_SOURCE_LOCATION (function),\n-\t\t\t\t     RESULT_DECL, NULL_TREE,\n-\t\t\t\t     TREE_TYPE (fntype));\n-\t  DECL_ARTIFICIAL (resdecl) = 1;\n-\t  DECL_IGNORED_P (resdecl) = 1;\n-\t  DECL_CONTEXT (resdecl) = function;\n-\t  DECL_RESULT (function) = resdecl;\n+\t  DECL_RESULT (function) = get_fndecl_result (decl);\n \t}\n     }\n \n@@ -2018,14 +2054,8 @@ start_function (FuncDeclaration *fd)\n   /* Let GCC know the current scope is this function.  */\n   current_function_decl = fndecl;\n \n-  tree restype = TREE_TYPE (TREE_TYPE (fndecl));\n-  tree resdecl = build_decl (make_location_t (fd->loc), RESULT_DECL,\n-\t\t\t     NULL_TREE, restype);\n-\n-  DECL_RESULT (fndecl) = resdecl;\n-  DECL_CONTEXT (resdecl) = fndecl;\n-  DECL_ARTIFICIAL (resdecl) = 1;\n-  DECL_IGNORED_P (resdecl) = 1;\n+  /* Build the result decl before calling allocate_struct_function.  */\n+  DECL_RESULT (fndecl) = get_fndecl_result (fd);\n \n   /* Initialize the RTL code for the function.  */\n   allocate_struct_function (fndecl, false);"}]}