{"sha": "9407058a430316db5299bc7867e4a31f900cd197", "node_id": "C_kwDOANBUbNoAKDk0MDcwNThhNDMwMzE2ZGI1Mjk5YmM3ODY3ZTRhMzFmOTAwY2QxOTc", "commit": {"author": {"name": "H.J. Lu", "email": "hjl.tools@gmail.com", "date": "2021-12-19T16:47:03Z"}, "committer": {"name": "H.J. Lu", "email": "hjl.tools@gmail.com", "date": "2021-12-27T13:27:06Z"}, "message": "ix86: Don't use the 'm' constraint for x86_64_general_operand\n\nThe 'm' constraint is defined with define_memory_constraint which allows\nLRA to convert the operand to the form '(mem (reg X))', where X is a\nbase register.  To prevent LRA from generating '(mem (reg X))' from a\nregister:\n\n1. Add a 'BM' constraint which is similar to the 'm' constraint, but\nis defined with define_constraint.\n2. Add a 'm' mode attribute which is mapped to the 'm' constraint for\ngeneral_operand and the 'BM' constraint for x86_64_general_operand.\n3. Replace the 'm' constraint on <general_operand> with the '<m>'\nconstraint.\n4. Replace the 'm' constraint on x86_64_general_operand with the 'BM'\nconstraint.\n\ngcc/\n\n\tPR target/103762\n\t* config/i386/constraints.md (BM): New constraint.\n\t* config/i386/i386.md (m): New mode attribute.\n\tReplace the 'm' constraint on <general_operand> with the '<m>'\n\tconstraint.\n\tReplace the 'm' constraint on x86_64_general_operand with the\n\t'BM' constraint.\n\ngcc/testsuite/\n\n\t* gcc.target/i386/pr103762-1a.c: New test.\n\t* gcc.target/i386/pr103762-1b.c: Likewise.\n\t* gcc.target/i386/pr103762-1c.c: Likewise.", "tree": {"sha": "084c9fae36e32f13f8beea793a4ae220c276971f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/084c9fae36e32f13f8beea793a4ae220c276971f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9407058a430316db5299bc7867e4a31f900cd197", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9407058a430316db5299bc7867e4a31f900cd197", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9407058a430316db5299bc7867e4a31f900cd197", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9407058a430316db5299bc7867e4a31f900cd197/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e078de24eae8253fd4f24342f65166b525dd99c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e078de24eae8253fd4f24342f65166b525dd99c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e078de24eae8253fd4f24342f65166b525dd99c6"}], "stats": {"total": 738, "additions": 706, "deletions": 32}, "files": [{"sha": "ded2e195bb0b38c06121e47c08b06ef65e3c1065", "filename": "gcc/config/i386/constraints.md", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9407058a430316db5299bc7867e4a31f900cd197/gcc%2Fconfig%2Fi386%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9407058a430316db5299bc7867e4a31f900cd197/gcc%2Fconfig%2Fi386%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fconstraints.md?ref=9407058a430316db5299bc7867e4a31f900cd197", "patch": "@@ -168,6 +168,7 @@\n ;;  z  Constant call address operand.\n ;;  C  Integer SSE constant with all bits set operand.\n ;;  F  Floating-point SSE constant with all bits set operand.\n+;;  M  x86-64 memory operand.\n \n (define_constraint \"Bf\"\n   \"@internal Flags register operand.\"\n@@ -232,6 +233,15 @@\n   (and (match_test \"TARGET_SSE\")\n        (match_operand 0 \"float_vector_all_ones_operand\")))\n \n+;; NB: Similar to 'm', but don't use define_memory_constraint on x86-64\n+;; to prevent LRA from converting the operand to the form '(mem (reg X))'\n+;; where X is a base register.\n+(define_constraint \"BM\"\n+  \"@internal x86-64 memory operand.\"\n+  (and (match_code \"mem\")\n+       (match_test \"memory_address_addr_space_p (GET_MODE (op), XEXP (op, 0),\n+\t\t\t\t\t\t MEM_ADDR_SPACE (op))\")))\n+\n ;; Integer constant constraints.\n (define_constraint \"Wb\"\n   \"Integer constant in the range 0 @dots{} 7, for 8-bit shifts.\""}, {"sha": "e670e7d9ad1f3558cd4d4de7880f40b714980b4e", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 35, "deletions": 32, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9407058a430316db5299bc7867e4a31f900cd197/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9407058a430316db5299bc7867e4a31f900cd197/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=9407058a430316db5299bc7867e4a31f900cd197", "patch": "@@ -1148,6 +1148,9 @@\n ;; General operand constraint for word modes.\n (define_mode_attr g [(QI \"qmn\") (HI \"rmn\") (SI \"rme\") (DI \"rme\")])\n \n+;; Memory operand constraint for word modes.\n+(define_mode_attr m [(QI \"m\") (HI \"m\") (SI \"BM\") (DI \"BM\")])\n+\n ;; Immediate operand constraint for double integer modes.\n (define_mode_attr di [(SI \"nF\") (DI \"Wd\")])\n \n@@ -1390,7 +1393,7 @@\n (define_insn \"*cmp<mode>_1\"\n   [(set (reg FLAGS_REG)\n \t(compare (match_operand:SWI 0 \"nonimmediate_operand\" \"<r>m,<r>\")\n-\t\t (match_operand:SWI 1 \"<general_operand>\" \"<r><i>,<r>m\")))]\n+\t\t (match_operand:SWI 1 \"<general_operand>\" \"<r><i>,<r><m>\")))]\n   \"ix86_match_ccmode (insn, CCmode)\"\n   \"cmp{<imodesuffix>}\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"icmp\")\n@@ -1400,7 +1403,7 @@\n   [(set (reg FLAGS_REG)\n \t(compare\n \t  (minus:SWI (match_operand:SWI 0 \"nonimmediate_operand\" \"<r>m,<r>\")\n-\t\t     (match_operand:SWI 1 \"<general_operand>\" \"<r><i>,<r>m\"))\n+\t\t     (match_operand:SWI 1 \"<general_operand>\" \"<r><i>,<r><m>\"))\n \t  (const_int 0)))]\n   \"ix86_match_ccmode (insn, CCGOCmode)\"\n   \"cmp{<imodesuffix>}\\t{%1, %0|%0, %1}\"\n@@ -5684,7 +5687,7 @@\n   [(set (match_operand:SWI48 0 \"nonimmediate_operand\" \"=rm,r,r,r\")\n \t(plus:SWI48\n \t  (match_operand:SWI48 1 \"nonimmediate_operand\" \"%0,0,r,r\")\n-\t  (match_operand:SWI48 2 \"x86_64_general_operand\" \"re,m,0,le\")))\n+\t  (match_operand:SWI48 2 \"x86_64_general_operand\" \"re,BM,0,le\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"ix86_binary_operator_ok (PLUS, <MODE>mode, operands)\"\n {\n@@ -5740,7 +5743,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r,r\")\n \t(zero_extend:DI\n \t  (plus:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0,r,r\")\n-\t\t   (match_operand:SI 2 \"x86_64_general_operand\" \"rme,0,le\"))))\n+\t\t   (match_operand:SI 2 \"x86_64_general_operand\" \"rBMe,0,le\"))))\n    (clobber (reg:CC FLAGS_REG))]\n   \"TARGET_64BIT && ix86_binary_operator_ok (PLUS, SImode, operands)\"\n {\n@@ -5998,7 +6001,7 @@\n \t(compare\n \t  (plus:SWI\n \t    (match_operand:SWI 1 \"nonimmediate_operand\" \"%0,0,<r>\")\n-\t    (match_operand:SWI 2 \"<general_operand>\" \"<r><i>,m,0\"))\n+\t    (match_operand:SWI 2 \"<general_operand>\" \"<r><i>,<m>,0\"))\n \t  (const_int 0)))\n    (set (match_operand:SWI 0 \"nonimmediate_operand\" \"=<r>m,<r>,<r>\")\n \t(plus:SWI (match_dup 1) (match_dup 2)))]\n@@ -6043,7 +6046,7 @@\n   [(set (reg FLAGS_REG)\n \t(compare\n \t  (plus:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0,r\")\n-\t\t   (match_operand:SI 2 \"x86_64_general_operand\" \"rme,0\"))\n+\t\t   (match_operand:SI 2 \"x86_64_general_operand\" \"rBMe,0\"))\n \t  (const_int 0)))\n    (set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n \t(zero_extend:DI (plus:SI (match_dup 1) (match_dup 2))))]\n@@ -6128,7 +6131,7 @@\n (define_insn \"*addsi_3_zext\"\n   [(set (reg FLAGS_REG)\n \t(compare\n-\t  (neg:SI (match_operand:SI 2 \"x86_64_general_operand\" \"rme,0\"))\n+\t  (neg:SI (match_operand:SI 2 \"x86_64_general_operand\" \"rBMe,0\"))\n \t  (match_operand:SI 1 \"nonimmediate_operand\" \"%0,r\")))\n    (set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n \t(zero_extend:DI (plus:SI (match_dup 1) (match_dup 2))))]\n@@ -6832,7 +6835,7 @@\n   [(set (match_operand:SWI 0 \"nonimmediate_operand\" \"=<r>m,<r>\")\n \t(minus:SWI\n \t  (match_operand:SWI 1 \"nonimmediate_operand\" \"0,0\")\n-\t  (match_operand:SWI 2 \"<general_operand>\" \"<r><i>,m\")))\n+\t  (match_operand:SWI 2 \"<general_operand>\" \"<r><i>,<m>\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"ix86_binary_operator_ok (MINUS, <MODE>mode, operands)\"\n   \"sub{<imodesuffix>}\\t{%2, %0|%0, %2}\"\n@@ -6843,7 +6846,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(zero_extend:DI\n \t  (minus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t    (match_operand:SI 2 \"x86_64_general_operand\" \"rme\"))))\n+\t\t    (match_operand:SI 2 \"x86_64_general_operand\" \"rBMe\"))))\n    (clobber (reg:CC FLAGS_REG))]\n   \"TARGET_64BIT && ix86_binary_operator_ok (MINUS, SImode, operands)\"\n   \"sub{l}\\t{%2, %k0|%k0, %2}\"\n@@ -6875,7 +6878,7 @@\n \t(compare\n \t  (minus:SWI\n \t    (match_operand:SWI 1 \"nonimmediate_operand\" \"0,0\")\n-\t    (match_operand:SWI 2 \"<general_operand>\" \"<r><i>,m\"))\n+\t    (match_operand:SWI 2 \"<general_operand>\" \"<r><i>,<m>\"))\n \t  (const_int 0)))\n    (set (match_operand:SWI 0 \"nonimmediate_operand\" \"=<r>m,<r>\")\n \t(minus:SWI (match_dup 1) (match_dup 2)))]\n@@ -6889,7 +6892,7 @@\n   [(set (reg FLAGS_REG)\n \t(compare\n \t  (minus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t    (match_operand:SI 2 \"x86_64_general_operand\" \"rme\"))\n+\t\t    (match_operand:SI 2 \"x86_64_general_operand\" \"rBMe\"))\n \t  (const_int 0)))\n    (set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(zero_extend:DI\n@@ -7142,7 +7145,7 @@\n (define_insn \"*sub<mode>_3\"\n   [(set (reg FLAGS_REG)\n \t(compare (match_operand:SWI 1 \"nonimmediate_operand\" \"0,0\")\n-\t\t (match_operand:SWI 2 \"<general_operand>\" \"<r><i>,m\")))\n+\t\t (match_operand:SWI 2 \"<general_operand>\" \"<r><i>,<m>\")))\n    (set (match_operand:SWI 0 \"nonimmediate_operand\" \"=<r>m,<r>\")\n \t(minus:SWI (match_dup 1) (match_dup 2)))]\n   \"ix86_match_ccmode (insn, CCmode)\n@@ -7218,7 +7221,7 @@\n (define_insn \"*subsi_3_zext\"\n   [(set (reg FLAGS_REG)\n \t(compare (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t (match_operand:SI 2 \"x86_64_general_operand\" \"rme\")))\n+\t\t (match_operand:SI 2 \"x86_64_general_operand\" \"rBMe\")))\n    (set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(zero_extend:DI\n \t  (minus:SI (match_dup 1)\n@@ -7238,7 +7241,7 @@\n \t    (match_operator:SWI 4 \"ix86_carry_flag_operator\"\n \t     [(match_operand 3 \"flags_reg_operand\") (const_int 0)])\n \t    (match_operand:SWI 1 \"nonimmediate_operand\" \"%0,0\"))\n-\t  (match_operand:SWI 2 \"<general_operand>\" \"<r><i>,m\")))\n+\t  (match_operand:SWI 2 \"<general_operand>\" \"<r><i>,<m>\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"ix86_binary_operator_ok (PLUS, <MODE>mode, operands)\"\n   \"adc{<imodesuffix>}\\t{%2, %0|%0, %2}\"\n@@ -7282,7 +7285,7 @@\n \t    (plus:SI (match_operator:SI 3 \"ix86_carry_flag_operator\"\n \t\t      [(reg FLAGS_REG) (const_int 0)])\n \t\t     (match_operand:SI 1 \"register_operand\" \"%0\"))\n-\t    (match_operand:SI 2 \"x86_64_general_operand\" \"rme\"))))\n+\t    (match_operand:SI 2 \"x86_64_general_operand\" \"rBMe\"))))\n    (clobber (reg:CC FLAGS_REG))]\n   \"TARGET_64BIT && ix86_binary_operator_ok (PLUS, SImode, operands)\"\n   \"adc{l}\\t{%2, %k0|%k0, %2}\"\n@@ -7408,7 +7411,7 @@\n \t    (match_operand:SWI 1 \"nonimmediate_operand\" \"0,0\")\n \t    (match_operator:SWI 4 \"ix86_carry_flag_operator\"\n \t     [(match_operand 3 \"flags_reg_operand\") (const_int 0)]))\n-\t  (match_operand:SWI 2 \"<general_operand>\" \"<r><i>,m\")))\n+\t  (match_operand:SWI 2 \"<general_operand>\" \"<r><i>,<m>\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"ix86_binary_operator_ok (MINUS, <MODE>mode, operands)\"\n   \"sbb{<imodesuffix>}\\t{%2, %0|%0, %2}\"\n@@ -7453,7 +7456,7 @@\n \t      (match_operand:SI 1 \"register_operand\" \"0\")\n \t      (match_operator:SI 3 \"ix86_carry_flag_operator\"\n \t       [(reg FLAGS_REG) (const_int 0)]))\n-\t    (match_operand:SI 2 \"x86_64_general_operand\" \"rme\"))))\n+\t    (match_operand:SI 2 \"x86_64_general_operand\" \"rBMe\"))))\n    (clobber (reg:CC FLAGS_REG))]\n   \"TARGET_64BIT && ix86_binary_operator_ok (MINUS, SImode, operands)\"\n   \"sbb{l}\\t{%2, %k0|%k0, %2}\"\n@@ -7529,7 +7532,7 @@\n (define_insn \"@sub<mode>3_carry_ccgz\"\n   [(set (reg:CCGZ FLAGS_REG)\n \t(unspec:CCGZ [(match_operand:DWIH 1 \"register_operand\" \"0\")\n-\t\t      (match_operand:DWIH 2 \"x86_64_general_operand\" \"rme\")\n+\t\t      (match_operand:DWIH 2 \"x86_64_general_operand\" \"rBMe\")\n \t\t      (ltu:DWIH (reg:CC FLAGS_REG) (const_int 0))]\n \t\t     UNSPEC_SBB))\n    (clobber (match_scratch:DWIH 0 \"=r\"))]\n@@ -7616,7 +7619,7 @@\n \t(compare:CCC\n \t    (plus:SWI\n \t\t(match_operand:SWI 1 \"nonimmediate_operand\" \"%0,0\")\n-\t\t(match_operand:SWI 2 \"<general_operand>\" \"<r><i>,m\"))\n+\t\t(match_operand:SWI 2 \"<general_operand>\" \"<r><i>,<m>\"))\n \t    (match_dup 1)))\n    (set (match_operand:SWI 0 \"nonimmediate_operand\" \"=<r>m,<r>\")\n \t(plus:SWI (match_dup 1) (match_dup 2)))]\n@@ -7647,7 +7650,7 @@\n \t(compare:CCC\n \t  (plus:SI\n \t    (match_operand:SI 1 \"nonimmediate_operand\" \"%0\")\n-\t    (match_operand:SI 2 \"x86_64_general_operand\" \"rme\"))\n+\t    (match_operand:SI 2 \"x86_64_general_operand\" \"rBMe\"))\n \t  (match_dup 1)))\n    (set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(zero_extend:DI (plus:SI (match_dup 1) (match_dup 2))))]\n@@ -7674,7 +7677,7 @@\n \t(compare:CCC\n \t    (plus:SWI\n \t\t(match_operand:SWI 1 \"nonimmediate_operand\" \"%0,0\")\n-\t\t(match_operand:SWI 2 \"<general_operand>\" \"<r><i>,m\"))\n+\t\t(match_operand:SWI 2 \"<general_operand>\" \"<r><i>,<m>\"))\n \t    (match_dup 2)))\n    (set (match_operand:SWI 0 \"nonimmediate_operand\" \"=<r>m,<r>\")\n \t(plus:SWI (match_dup 1) (match_dup 2)))]\n@@ -7688,7 +7691,7 @@\n \t(compare:CCC\n \t  (plus:SI\n \t    (match_operand:SI 1 \"nonimmediate_operand\" \"%0\")\n-\t    (match_operand:SI 2 \"x86_64_general_operand\" \"rme\"))\n+\t    (match_operand:SI 2 \"x86_64_general_operand\" \"rBMe\"))\n \t  (match_dup 2)))\n    (set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(zero_extend:DI (plus:SI (match_dup 1) (match_dup 2))))]\n@@ -8032,7 +8035,7 @@\n   [(set (match_operand:SWIM248 0 \"register_operand\" \"=r,r,r\")\n \t(mult:SWIM248\n \t  (match_operand:SWIM248 1 \"nonimmediate_operand\" \"%rm,rm,0\")\n-\t  (match_operand:SWIM248 2 \"<general_operand>\" \"K,<i>,mr\")))\n+\t  (match_operand:SWIM248 2 \"<general_operand>\" \"K,<i>,<m>r\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"!(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n   \"@\n@@ -8068,7 +8071,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r,r\")\n \t(zero_extend:DI\n \t  (mult:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%rm,rm,0\")\n-\t\t   (match_operand:SI 2 \"x86_64_general_operand\" \"K,e,mr\"))))\n+\t\t   (match_operand:SI 2 \"x86_64_general_operand\" \"K,e,BMr\"))))\n    (clobber (reg:CC FLAGS_REG))]\n   \"TARGET_64BIT\n    && !(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n@@ -9813,7 +9816,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(zero_extend:DI\n \t  (and:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0\")\n-\t\t  (match_operand:SI 2 \"x86_64_general_operand\" \"rme\"))))\n+\t\t  (match_operand:SI 2 \"x86_64_general_operand\" \"rBMe\"))))\n    (clobber (reg:CC FLAGS_REG))]\n   \"TARGET_64BIT && ix86_binary_operator_ok (AND, SImode, operands)\"\n   \"and{l}\\t{%2, %k0|%k0, %2}\"\n@@ -9823,7 +9826,7 @@\n (define_insn \"*and<mode>_1\"\n   [(set (match_operand:SWI24 0 \"nonimmediate_operand\" \"=rm,r,Ya,?k\")\n \t(and:SWI24 (match_operand:SWI24 1 \"nonimmediate_operand\" \"%0,0,qm,k\")\n-\t\t   (match_operand:SWI24 2 \"<general_operand>\" \"r<i>,m,L,k\")))\n+\t\t   (match_operand:SWI24 2 \"<general_operand>\" \"r<i>,<m>,L,k\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"ix86_binary_operator_ok (AND, <MODE>mode, operands)\"\n   \"@\n@@ -10005,7 +10008,7 @@\n   [(set (reg FLAGS_REG)\n \t(compare (and:SI\n \t\t  (match_operand:SI 1 \"nonimmediate_operand\" \"%0\")\n-\t\t  (match_operand:SI 2 \"x86_64_general_operand\" \"rme\"))\n+\t\t  (match_operand:SI 2 \"x86_64_general_operand\" \"rBMe\"))\n \t\t (const_int 0)))\n    (set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(zero_extend:DI (and:SI (match_dup 1) (match_dup 2))))]\n@@ -10048,7 +10051,7 @@\n   [(set (reg FLAGS_REG)\n \t(compare (and:SWI124\n \t\t  (match_operand:SWI124 1 \"nonimmediate_operand\" \"%0,0\")\n-\t\t  (match_operand:SWI124 2 \"<general_operand>\" \"<r><i>,m\"))\n+\t\t  (match_operand:SWI124 2 \"<general_operand>\" \"<r><i>,<m>\"))\n \t\t (const_int 0)))\n    (set (match_operand:SWI124 0 \"nonimmediate_operand\" \"=<r>m,<r>\")\n \t(and:SWI124 (match_dup 1) (match_dup 2)))]\n@@ -10362,7 +10365,7 @@\n   [(set (match_operand:SWI248 0 \"nonimmediate_operand\" \"=rm,r,?k\")\n \t(any_or:SWI248\n \t (match_operand:SWI248 1 \"nonimmediate_operand\" \"%0,0,k\")\n-\t (match_operand:SWI248 2 \"<general_operand>\" \"r<i>,m,k\")))\n+\t (match_operand:SWI248 2 \"<general_operand>\" \"r<i>,<m>,k\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"ix86_binary_operator_ok (<CODE>, <MODE>mode, operands)\"\n   \"@\n@@ -10430,7 +10433,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(zero_extend:DI\n \t (any_or:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0\")\n-\t\t    (match_operand:SI 2 \"x86_64_general_operand\" \"rme\"))))\n+\t\t    (match_operand:SI 2 \"x86_64_general_operand\" \"rBMe\"))))\n    (clobber (reg:CC FLAGS_REG))]\n   \"TARGET_64BIT && ix86_binary_operator_ok (<CODE>, SImode, operands)\"\n   \"<logic>{l}\\t{%2, %k0|%k0, %2}\"\n@@ -10533,7 +10536,7 @@\n   [(set (reg FLAGS_REG)\n \t(compare (any_or:SWI\n \t\t  (match_operand:SWI 1 \"nonimmediate_operand\" \"%0,0\")\n-\t\t  (match_operand:SWI 2 \"<general_operand>\" \"<r><i>,m\"))\n+\t\t  (match_operand:SWI 2 \"<general_operand>\" \"<r><i>,<m>\"))\n \t\t (const_int 0)))\n    (set (match_operand:SWI 0 \"nonimmediate_operand\" \"=<r>m,<r>\")\n \t(any_or:SWI (match_dup 1) (match_dup 2)))]\n@@ -10548,7 +10551,7 @@\n (define_insn \"*<code>si_2_zext\"\n   [(set (reg FLAGS_REG)\n \t(compare (any_or:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0\")\n-\t\t\t    (match_operand:SI 2 \"x86_64_general_operand\" \"rme\"))\n+\t\t\t    (match_operand:SI 2 \"x86_64_general_operand\" \"rBMe\"))\n \t\t (const_int 0)))\n    (set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(zero_extend:DI (any_or:SI (match_dup 1) (match_dup 2))))]"}, {"sha": "c9e75bc12d8dced368a8b8e9f32e06392cf4cf02", "filename": "gcc/testsuite/gcc.target/i386/pr103762-1a.c", "status": "added", "additions": 647, "deletions": 0, "changes": 647, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9407058a430316db5299bc7867e4a31f900cd197/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103762-1a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9407058a430316db5299bc7867e4a31f900cd197/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103762-1a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103762-1a.c?ref=9407058a430316db5299bc7867e4a31f900cd197", "patch": "@@ -0,0 +1,647 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -std=gnu11 -fgnu89-inline\" } */\n+/* { dg-final { scan-assembler-not \".quad\\[\\\\t \\]+tunable_list\" { target lp64 } } } */\n+/* { dg-final { scan-assembler-not \".long\\[\\\\t \\]+tunable_list\" { target { ! lp64 } } } } */\n+\n+typedef unsigned long int size_t;\n+typedef long long int intmax_t;\n+typedef unsigned long long int uintmax_t;\n+typedef unsigned long long int uint64_t;\n+typedef intmax_t tunable_num_t;\n+typedef union\n+{\n+  tunable_num_t numval;\n+  const char *strval;\n+} tunable_val_t;\n+enum\n+{\n+  HWCAP_X86_SSE2 = 1 << 0,\n+  HWCAP_X86_64 = 1 << 1,\n+  HWCAP_X86_AVX512_1 = 1 << 2\n+};\n+typedef void (*tunable_callback_t) (tunable_val_t *);\n+extern void *__minimal_malloc (size_t n)\n+    __attribute__ ((visibility (\"hidden\")));\n+extern int __libc_enable_secure __attribute__ ((section (\".data.rel.ro\")));\n+extern uint64_t _dl_strtoul (const char *, char **)\n+    __attribute__ ((visibility (\"hidden\")));\n+extern void _dl_fatal_printf (const char *fmt, ...)\n+    __attribute__ ((__format__ (__printf__, 1, 2), __noreturn__));\n+typedef enum\n+{\n+  glibc_rtld_nns,\n+  glibc_elision_skip_lock_after_retries,\n+  glibc_malloc_trim_threshold,\n+  glibc_malloc_perturb,\n+  glibc_cpu_x86_shared_cache_size,\n+  glibc_pthread_rseq,\n+  glibc_mem_tagging,\n+  glibc_elision_tries,\n+  glibc_elision_enable,\n+  glibc_malloc_hugetlb,\n+  glibc_cpu_x86_rep_movsb_threshold,\n+  glibc_malloc_mxfast,\n+  glibc_rtld_dynamic_sort,\n+  glibc_elision_skip_lock_busy,\n+  glibc_malloc_top_pad,\n+  glibc_cpu_x86_rep_stosb_threshold,\n+  glibc_cpu_x86_non_temporal_threshold,\n+  glibc_cpu_x86_shstk,\n+  glibc_pthread_stack_cache_size,\n+  glibc_cpu_hwcap_mask,\n+  glibc_malloc_mmap_max,\n+  glibc_elision_skip_trylock_internal_abort,\n+  glibc_malloc_tcache_unsorted_limit,\n+  glibc_cpu_x86_ibt,\n+  glibc_cpu_hwcaps,\n+  glibc_elision_skip_lock_internal_abort,\n+  glibc_malloc_arena_max,\n+  glibc_malloc_mmap_threshold,\n+  glibc_cpu_x86_data_cache_size,\n+  glibc_malloc_tcache_count,\n+  glibc_malloc_arena_test,\n+  glibc_pthread_mutex_spin_count,\n+  glibc_rtld_optional_static_tls,\n+  glibc_malloc_tcache_max,\n+  glibc_malloc_check,\n+} tunable_id_t;\n+typedef enum\n+{\n+  TUNABLE_TYPE_INT_32,\n+  TUNABLE_TYPE_UINT_64,\n+  TUNABLE_TYPE_SIZE_T,\n+  TUNABLE_TYPE_STRING\n+} tunable_type_code_t;\n+typedef struct\n+{\n+  tunable_type_code_t type_code;\n+  tunable_num_t min;\n+  tunable_num_t max;\n+} tunable_type_t;\n+typedef enum\n+{\n+  TUNABLE_SECLEVEL_SXID_ERASE = 0,\n+  TUNABLE_SECLEVEL_SXID_IGNORE = 1,\n+  TUNABLE_SECLEVEL_NONE = 2,\n+} tunable_seclevel_t;\n+struct _tunable\n+{\n+  const char name[42];\n+  tunable_type_t type;\n+  tunable_val_t val;\n+  _Bool initialized;\n+  tunable_seclevel_t security_level;\n+  const char env_alias[23];\n+};\n+typedef struct _tunable tunable_t;\n+extern _Bool unsigned_tunable_type (tunable_type_code_t t);\n+\n+static tunable_t tunable_list[] __attribute__ ((section (\".data.rel.ro\"))) = {\n+  { \"glibc\"\n+    \".\"\n+    \"rtld\"\n+    \".\"\n+    \"nns\",\n+    { TUNABLE_TYPE_SIZE_T, 1, 16 },\n+    { .numval = 4 },\n+    ((void *)0),\n+    TUNABLE_SECLEVEL_SXID_ERASE,\n+    { 0 } },\n+  { \"glibc\"\n+    \".\"\n+    \"elision\"\n+    \".\"\n+    \"skip_lock_after_retries\",\n+    { TUNABLE_TYPE_INT_32, 0, (2147483647) },\n+    { .numval = 3 },\n+    ((void *)0),\n+    TUNABLE_SECLEVEL_SXID_ERASE,\n+    { 0 } },\n+  { \"glibc\"\n+    \".\"\n+    \"malloc\"\n+    \".\"\n+    \"trim_threshold\",\n+    { TUNABLE_TYPE_SIZE_T, 0, (18446744073709551615UL) },\n+    {},\n+    ((void *)0),\n+    TUNABLE_SECLEVEL_SXID_IGNORE,\n+    \"MALLOC_TRIM_THRESHOLD_\" },\n+  { \"glibc\"\n+    \".\"\n+    \"malloc\"\n+    \".\"\n+    \"perturb\",\n+    { TUNABLE_TYPE_INT_32, 0, 0xff },\n+    {},\n+    ((void *)0),\n+    TUNABLE_SECLEVEL_SXID_IGNORE,\n+    \"MALLOC_PERTURB_\" },\n+  { \"glibc\"\n+    \".\"\n+    \"cpu\"\n+    \".\"\n+    \"x86_shared_cache_size\",\n+    { TUNABLE_TYPE_SIZE_T, 0, (18446744073709551615UL) },\n+    {},\n+    ((void *)0),\n+    TUNABLE_SECLEVEL_SXID_ERASE,\n+    { 0 } },\n+  { \"glibc\"\n+    \".\"\n+    \"pthread\"\n+    \".\"\n+    \"rseq\",\n+    { TUNABLE_TYPE_INT_32, 0, 1 },\n+    { .numval = 1 },\n+    ((void *)0),\n+    TUNABLE_SECLEVEL_SXID_ERASE,\n+    { 0 } },\n+  { \"glibc\"\n+    \".\"\n+    \"mem\"\n+    \".\"\n+    \"tagging\",\n+    { TUNABLE_TYPE_INT_32, 0, 255 },\n+    {},\n+    ((void *)0),\n+    TUNABLE_SECLEVEL_SXID_IGNORE,\n+    { 0 } },\n+  { \"glibc\"\n+    \".\"\n+    \"elision\"\n+    \".\"\n+    \"tries\",\n+    { TUNABLE_TYPE_INT_32, 0, (2147483647) },\n+    { .numval = 3 },\n+    ((void *)0),\n+    TUNABLE_SECLEVEL_SXID_ERASE,\n+    { 0 } },\n+  { \"glibc\"\n+    \".\"\n+    \"elision\"\n+    \".\"\n+    \"enable\",\n+    { TUNABLE_TYPE_INT_32, 0, 1 },\n+    {},\n+    ((void *)0),\n+    TUNABLE_SECLEVEL_SXID_ERASE,\n+    { 0 } },\n+  { \"glibc\"\n+    \".\"\n+    \"malloc\"\n+    \".\"\n+    \"hugetlb\",\n+    { TUNABLE_TYPE_SIZE_T, 0, (18446744073709551615UL) },\n+    {},\n+    ((void *)0),\n+    TUNABLE_SECLEVEL_SXID_ERASE,\n+    { 0 } },\n+  { \"glibc\"\n+    \".\"\n+    \"cpu\"\n+    \".\"\n+    \"x86_rep_movsb_threshold\",\n+    { TUNABLE_TYPE_SIZE_T, 1, (18446744073709551615UL) },\n+    {},\n+    ((void *)0),\n+    TUNABLE_SECLEVEL_SXID_ERASE,\n+    { 0 } },\n+  { \"glibc\"\n+    \".\"\n+    \"malloc\"\n+    \".\"\n+    \"mxfast\",\n+    { TUNABLE_TYPE_SIZE_T, 0, (18446744073709551615UL) },\n+    {},\n+    ((void *)0),\n+    TUNABLE_SECLEVEL_SXID_IGNORE,\n+    { 0 } },\n+  { \"glibc\"\n+    \".\"\n+    \"rtld\"\n+    \".\"\n+    \"dynamic_sort\",\n+    { TUNABLE_TYPE_INT_32, 1, 2 },\n+    { .numval = 2 },\n+    ((void *)0),\n+    TUNABLE_SECLEVEL_SXID_ERASE,\n+    { 0 } },\n+  { \"glibc\"\n+    \".\"\n+    \"elision\"\n+    \".\"\n+    \"skip_lock_busy\",\n+    { TUNABLE_TYPE_INT_32, 0, (2147483647) },\n+    { .numval = 3 },\n+    ((void *)0),\n+    TUNABLE_SECLEVEL_SXID_ERASE,\n+    { 0 } },\n+  { \"glibc\"\n+    \".\"\n+    \"malloc\"\n+    \".\"\n+    \"top_pad\",\n+    { TUNABLE_TYPE_SIZE_T, 0, (18446744073709551615UL) },\n+    {},\n+    ((void *)0),\n+    TUNABLE_SECLEVEL_SXID_IGNORE,\n+    \"MALLOC_TOP_PAD_\" },\n+  { \"glibc\"\n+    \".\"\n+    \"cpu\"\n+    \".\"\n+    \"x86_rep_stosb_threshold\",\n+    { TUNABLE_TYPE_SIZE_T, 1, (18446744073709551615UL) },\n+    { .numval = 2048 },\n+    ((void *)0),\n+    TUNABLE_SECLEVEL_SXID_ERASE,\n+    { 0 } },\n+  { \"glibc\"\n+    \".\"\n+    \"cpu\"\n+    \".\"\n+    \"x86_non_temporal_threshold\",\n+    { TUNABLE_TYPE_SIZE_T, 0, (18446744073709551615UL) },\n+    {},\n+    ((void *)0),\n+    TUNABLE_SECLEVEL_SXID_ERASE,\n+    { 0 } },\n+  { \"glibc\"\n+    \".\"\n+    \"cpu\"\n+    \".\"\n+    \"x86_shstk\",\n+    { TUNABLE_TYPE_STRING, 0, 0 },\n+    {},\n+    ((void *)0),\n+    TUNABLE_SECLEVEL_SXID_ERASE,\n+    { 0 } },\n+  { \"glibc\"\n+    \".\"\n+    \"pthread\"\n+    \".\"\n+    \"stack_cache_size\",\n+    { TUNABLE_TYPE_SIZE_T, 0, (18446744073709551615UL) },\n+    { .numval = 41943040 },\n+    ((void *)0),\n+    TUNABLE_SECLEVEL_SXID_ERASE,\n+    { 0 } },\n+  { \"glibc\"\n+    \".\"\n+    \"cpu\"\n+    \".\"\n+    \"hwcap_mask\",\n+    { TUNABLE_TYPE_UINT_64, 0, (18446744073709551615UL) },\n+    { .numval = (HWCAP_X86_64 | HWCAP_X86_AVX512_1) },\n+    ((void *)0),\n+    TUNABLE_SECLEVEL_SXID_ERASE,\n+    \"LD_HWCAP_MASK\" },\n+  { \"glibc\"\n+    \".\"\n+    \"malloc\"\n+    \".\"\n+    \"mmap_max\",\n+    { TUNABLE_TYPE_INT_32, 0, (2147483647) },\n+    {},\n+    ((void *)0),\n+    TUNABLE_SECLEVEL_SXID_IGNORE,\n+    \"MALLOC_MMAP_MAX_\" },\n+  { \"glibc\"\n+    \".\"\n+    \"elision\"\n+    \".\"\n+    \"skip_trylock_internal_abort\",\n+    { TUNABLE_TYPE_INT_32, 0, (2147483647) },\n+    { .numval = 3 },\n+    ((void *)0),\n+    TUNABLE_SECLEVEL_SXID_ERASE,\n+    { 0 } },\n+  { \"glibc\"\n+    \".\"\n+    \"malloc\"\n+    \".\"\n+    \"tcache_unsorted_limit\",\n+    { TUNABLE_TYPE_SIZE_T, 0, (18446744073709551615UL) },\n+    {},\n+    ((void *)0),\n+    TUNABLE_SECLEVEL_SXID_ERASE,\n+    { 0 } },\n+  { \"glibc\"\n+    \".\"\n+    \"cpu\"\n+    \".\"\n+    \"x86_ibt\",\n+    { TUNABLE_TYPE_STRING, 0, 0 },\n+    {},\n+    ((void *)0),\n+    TUNABLE_SECLEVEL_SXID_ERASE,\n+    { 0 } },\n+  { \"glibc\"\n+    \".\"\n+    \"cpu\"\n+    \".\"\n+    \"hwcaps\",\n+    { TUNABLE_TYPE_STRING, 0, 0 },\n+    {},\n+    ((void *)0),\n+    TUNABLE_SECLEVEL_SXID_ERASE,\n+    { 0 } },\n+  { \"glibc\"\n+    \".\"\n+    \"elision\"\n+    \".\"\n+    \"skip_lock_internal_abort\",\n+    { TUNABLE_TYPE_INT_32, 0, (2147483647) },\n+    { .numval = 3 },\n+    ((void *)0),\n+    TUNABLE_SECLEVEL_SXID_ERASE,\n+    { 0 } },\n+  { \"glibc\"\n+    \".\"\n+    \"malloc\"\n+    \".\"\n+    \"arena_max\",\n+    { TUNABLE_TYPE_SIZE_T, 1, (18446744073709551615UL) },\n+    {},\n+    ((void *)0),\n+    TUNABLE_SECLEVEL_SXID_IGNORE,\n+    \"MALLOC_ARENA_MAX\" },\n+  { \"glibc\"\n+    \".\"\n+    \"malloc\"\n+    \".\"\n+    \"mmap_threshold\",\n+    { TUNABLE_TYPE_SIZE_T, 0, (18446744073709551615UL) },\n+    {},\n+    ((void *)0),\n+    TUNABLE_SECLEVEL_SXID_IGNORE,\n+    \"MALLOC_MMAP_THRESHOLD_\" },\n+  { \"glibc\"\n+    \".\"\n+    \"cpu\"\n+    \".\"\n+    \"x86_data_cache_size\",\n+    { TUNABLE_TYPE_SIZE_T, 0, (18446744073709551615UL) },\n+    {},\n+    ((void *)0),\n+    TUNABLE_SECLEVEL_SXID_ERASE,\n+    { 0 } },\n+  { \"glibc\"\n+    \".\"\n+    \"malloc\"\n+    \".\"\n+    \"tcache_count\",\n+    { TUNABLE_TYPE_SIZE_T, 0, (18446744073709551615UL) },\n+    {},\n+    ((void *)0),\n+    TUNABLE_SECLEVEL_SXID_ERASE,\n+    { 0 } },\n+  { \"glibc\"\n+    \".\"\n+    \"malloc\"\n+    \".\"\n+    \"arena_test\",\n+    { TUNABLE_TYPE_SIZE_T, 1, (18446744073709551615UL) },\n+    {},\n+    ((void *)0),\n+    TUNABLE_SECLEVEL_SXID_IGNORE,\n+    \"MALLOC_ARENA_TEST\" },\n+  { \"glibc\"\n+    \".\"\n+    \"pthread\"\n+    \".\"\n+    \"mutex_spin_count\",\n+    { TUNABLE_TYPE_INT_32, 0, 32767 },\n+    { .numval = 100 },\n+    ((void *)0),\n+    TUNABLE_SECLEVEL_SXID_ERASE,\n+    { 0 } },\n+  { \"glibc\"\n+    \".\"\n+    \"rtld\"\n+    \".\"\n+    \"optional_static_tls\",\n+    { TUNABLE_TYPE_SIZE_T, 0, (18446744073709551615UL) },\n+    { .numval = 512 },\n+    ((void *)0),\n+    TUNABLE_SECLEVEL_SXID_ERASE,\n+    { 0 } },\n+  { \"glibc\"\n+    \".\"\n+    \"malloc\"\n+    \".\"\n+    \"tcache_max\",\n+    { TUNABLE_TYPE_SIZE_T, 0, (18446744073709551615UL) },\n+    {},\n+    ((void *)0),\n+    TUNABLE_SECLEVEL_SXID_ERASE,\n+    { 0 } },\n+  { \"glibc\"\n+    \".\"\n+    \"malloc\"\n+    \".\"\n+    \"check\",\n+    { TUNABLE_TYPE_INT_32, 0, 3 },\n+    {},\n+    ((void *)0),\n+    TUNABLE_SECLEVEL_SXID_ERASE,\n+    \"MALLOC_CHECK_\" },\n+};\n+extern void __tunables_init (char **);\n+extern void __tunables_print (void);\n+extern void __tunable_get_val (tunable_id_t, void *, tunable_callback_t);\n+extern void __tunable_set_val (tunable_id_t, tunable_val_t *, tunable_num_t *,\n+                               tunable_num_t *);\n+static __inline __attribute__ ((__always_inline__)) _Bool\n+tunable_val_lt (tunable_num_t lhs, tunable_num_t rhs, _Bool unsigned_cmp)\n+{\n+  if (unsigned_cmp)\n+    return (uintmax_t)lhs < (uintmax_t)rhs;\n+  else\n+    return lhs < rhs;\n+}\n+static __inline __attribute__ ((__always_inline__)) _Bool\n+tunable_val_gt (tunable_num_t lhs, tunable_num_t rhs, _Bool unsigned_cmp)\n+{\n+  if (unsigned_cmp)\n+    return (uintmax_t)lhs > (uintmax_t)rhs;\n+  else\n+    return lhs > rhs;\n+}\n+static __inline __attribute__ ((__always_inline__)) _Bool\n+tunable_is_name (const char *orig, const char *envname)\n+{\n+  for (; *orig != '\\0' && *envname != '\\0'; envname++, orig++)\n+    if (*orig != *envname)\n+      break;\n+  if (*orig == '\\0' && *envname == '=')\n+    return 1;\n+  else\n+    return 0;\n+}\n+static char *\n+tunables_strdup (const char *in)\n+{\n+  size_t i = 0;\n+  while (in[i++] != '\\0')\n+    ;\n+  char *out = __minimal_malloc (i + 1);\n+  if (out == ((void *)0))\n+    _dl_fatal_printf (\"failed to allocate memory to process tunables\\n\");\n+  while (i-- > 0)\n+    out[i] = in[i];\n+  return out;\n+}\n+static char **\n+get_next_env (char **envp, char **name, size_t *namelen, char **val,\n+              char ***prev_envp)\n+{\n+  while (envp != ((void *)0) && *envp != ((void *)0))\n+    {\n+      char **prev = envp;\n+      char *envline = *envp++;\n+      int len = 0;\n+      while (envline[len] != '\\0' && envline[len] != '=')\n+        len++;\n+      if (envline[len] == '\\0')\n+        continue;\n+      *name = envline;\n+      *namelen = len;\n+      *val = &envline[len + 1];\n+      *prev_envp = prev;\n+      return envp;\n+    }\n+  return ((void *)0);\n+}\n+static void\n+do_tunable_update_val (tunable_t *cur, const tunable_val_t *valp,\n+                       const tunable_num_t *minp, const tunable_num_t *maxp)\n+{\n+  tunable_num_t val, min, max;\n+  if (cur->type.type_code == TUNABLE_TYPE_STRING)\n+    {\n+      cur->val.strval = valp->strval;\n+      cur->initialized = 1;\n+      return;\n+    }\n+  _Bool unsigned_cmp = unsigned_tunable_type (cur->type.type_code);\n+  val = valp->numval;\n+  min = minp != ((void *)0) ? *minp : cur->type.min;\n+  max = maxp != ((void *)0) ? *maxp : cur->type.max;\n+  if (tunable_val_lt (min, cur->type.min, unsigned_cmp))\n+    min = cur->type.min;\n+  if (tunable_val_gt (max, cur->type.max, unsigned_cmp))\n+    max = cur->type.max;\n+  if (tunable_val_gt (min, max, unsigned_cmp))\n+    {\n+      min = cur->type.min;\n+      max = cur->type.max;\n+    }\n+  if (tunable_val_lt (val, min, unsigned_cmp)\n+      || tunable_val_lt (max, val, unsigned_cmp))\n+    return;\n+  cur->val.numval = val;\n+  cur->type.min = min;\n+  cur->type.max = max;\n+  cur->initialized = 1;\n+}\n+static void\n+tunable_initialize (tunable_t *cur, const char *strval)\n+{\n+  tunable_val_t val;\n+  if (cur->type.type_code != TUNABLE_TYPE_STRING)\n+    val.numval = (tunable_num_t)_dl_strtoul (strval, ((void *)0));\n+  else\n+    val.strval = strval;\n+  do_tunable_update_val (cur, &val, ((void *)0), ((void *)0));\n+}\n+static void\n+parse_tunables (char *tunestr, char *valstring)\n+{\n+  if (tunestr == ((void *)0) || *tunestr == '\\0')\n+    return;\n+  char *p = tunestr;\n+  size_t off = 0;\n+  while (1)\n+    {\n+      char *name = p;\n+      size_t len = 0;\n+      while (p[len] != '=' && p[len] != ':' && p[len] != '\\0')\n+        len++;\n+      if (p[len] == '\\0')\n+        {\n+          if (__libc_enable_secure)\n+            tunestr[off] = '\\0';\n+          return;\n+        }\n+      if (p[len] == ':')\n+        {\n+          p += len + 1;\n+          continue;\n+        }\n+      p += len + 1;\n+      char *value = &valstring[p - tunestr];\n+      len = 0;\n+      while (p[len] != ':' && p[len] != '\\0')\n+        len++;\n+      for (size_t i = 0; i < sizeof (tunable_list) / sizeof (tunable_t); i++)\n+        {\n+          tunable_t *cur = &tunable_list[i];\n+          if (tunable_is_name (cur->name, name))\n+            {\n+              if (__libc_enable_secure)\n+                {\n+                  if (cur->security_level != TUNABLE_SECLEVEL_SXID_ERASE)\n+                    {\n+                      if (off > 0)\n+                        tunestr[off++] = ':';\n+                      const char *n = cur->name;\n+                      while (*n != '\\0')\n+                        tunestr[off++] = *n++;\n+                      tunestr[off++] = '=';\n+                      for (size_t j = 0; j < len; j++)\n+                        tunestr[off++] = value[j];\n+                    }\n+                  if (cur->security_level != TUNABLE_SECLEVEL_NONE)\n+                    break;\n+                }\n+              value[len] = '\\0';\n+              tunable_initialize (cur, value);\n+              break;\n+            }\n+        }\n+      if (p[len] != '\\0')\n+        p += len + 1;\n+    }\n+}\n+void\n+__tunables_init (char **envp)\n+{\n+  char *envname = ((void *)0);\n+  char *envval = ((void *)0);\n+  size_t len = 0;\n+  char **prev_envp = envp;\n+  while ((envp = get_next_env (envp, &envname, &len, &envval, &prev_envp))\n+         != ((void *)0))\n+    {\n+      if (tunable_is_name (\"GLIBC_TUNABLES\", envname))\n+        {\n+          char *new_env = tunables_strdup (envname);\n+          if (new_env != ((void *)0))\n+            parse_tunables (new_env + len + 1, envval);\n+          *prev_envp = new_env;\n+          continue;\n+        }\n+      for (int i = 0; i < sizeof (tunable_list) / sizeof (tunable_t); i++)\n+        {\n+          tunable_t *cur = &tunable_list[i];\n+          const char *name = cur->env_alias;\n+          if (tunable_is_name (name, envname))\n+            {\n+              tunable_initialize (cur, envval);\n+              break;\n+            }\n+        }\n+    }\n+}"}, {"sha": "391f51cf7f1a35c17000d6e76a41e8648700d0c4", "filename": "gcc/testsuite/gcc.target/i386/pr103762-1b.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9407058a430316db5299bc7867e4a31f900cd197/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103762-1b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9407058a430316db5299bc7867e4a31f900cd197/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103762-1b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103762-1b.c?ref=9407058a430316db5299bc7867e4a31f900cd197", "patch": "@@ -0,0 +1,7 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target pie } */\n+/* { dg-options \"-O2 -std=gnu11 -fgnu89-inline -fpie\" } */\n+/* { dg-final { scan-assembler-not \".quad\\[\\\\t \\]+tunable_list\" { target lp64 } } } */\n+/* { dg-final { scan-assembler-not \".long\\[\\\\t \\]+tunable_list\" { target { ! lp64 } } } } */\n+\n+#include \"pr103762-1a.c\""}, {"sha": "4667b06c171daa4ada52736dd745c6599015e197", "filename": "gcc/testsuite/gcc.target/i386/pr103762-1c.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9407058a430316db5299bc7867e4a31f900cd197/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103762-1c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9407058a430316db5299bc7867e4a31f900cd197/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103762-1c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103762-1c.c?ref=9407058a430316db5299bc7867e4a31f900cd197", "patch": "@@ -0,0 +1,7 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target fpic } */\n+/* { dg-options \"-O2 -std=gnu11 -fgnu89-inline -fpic\" } */\n+/* { dg-final { scan-assembler-not \".quad\\[\\\\t \\]+tunable_list\" { target lp64 } } } */\n+/* { dg-final { scan-assembler-not \".long\\[\\\\t \\]+tunable_list\" { target { ! lp64 } } } } */\n+\n+#include \"pr103762-1a.c\""}]}