{"sha": "f290100275139ccb59832bb75ff7fb2606e110d7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjI5MDEwMDI3NTEzOWNjYjU5ODMyYmI3NWZmN2ZiMjYwNmUxMTBkNw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2018-07-06T21:42:41Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2018-07-06T21:42:41Z"}, "message": "re PR tree-optimization/86401 (The \"For constants M and N, if M == (1LL << cst) - 1 && (N & M) == M,...\" opts are only in fold-const.c and in RTL)\n\n\tPR tree-optimization/86401\n\t* fold-const.c (fold_binary_loc) <case BIT_AND_EXPR>: Move the\n\t((A & N) + B) & M -> (A + B) & M etc. optimization into ...\n\t(fold_bit_and_mask): ... here.  New helper function for match.pd.\n\t* fold-const.h (fold_bit_and_mask): Declare.\n\t* match.pd (((A & N) + B) & M -> (A + B) & M): New optimization.\n\n\t* gcc.dg/tree-ssa/pr86401-1.c: New test.\n\t* gcc.dg/tree-ssa/pr86401-2.c: New test.\n\t* c-c++-common/rotate-9.c: New test.\n\nFrom-SVN: r262485", "tree": {"sha": "18cda432e83a3fcae530b889830983dd4a7f0efb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/18cda432e83a3fcae530b889830983dd4a7f0efb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f290100275139ccb59832bb75ff7fb2606e110d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f290100275139ccb59832bb75ff7fb2606e110d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f290100275139ccb59832bb75ff7fb2606e110d7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f290100275139ccb59832bb75ff7fb2606e110d7/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8de583fc5301987f31e1897e07d545e218b943da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8de583fc5301987f31e1897e07d545e218b943da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8de583fc5301987f31e1897e07d545e218b943da"}], "stats": {"total": 397, "additions": 282, "deletions": 115}, "files": [{"sha": "7a9789710660bbbc03908c8cb412254d7d454d4b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f290100275139ccb59832bb75ff7fb2606e110d7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f290100275139ccb59832bb75ff7fb2606e110d7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f290100275139ccb59832bb75ff7fb2606e110d7", "patch": "@@ -1,3 +1,12 @@\n+2018-07-06  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/86401\n+\t* fold-const.c (fold_binary_loc) <case BIT_AND_EXPR>: Move the\n+\t((A & N) + B) & M -> (A + B) & M etc. optimization into ...\n+\t(fold_bit_and_mask): ... here.  New helper function for match.pd.\n+\t* fold-const.h (fold_bit_and_mask): Declare.\n+\t* match.pd (((A & N) + B) & M -> (A + B) & M): New optimization.\n+\n 2018-07-06  Peter Bergner  <bergner@linux.ibm.com>\n \n \tPR target/86324"}, {"sha": "6d5c8f529fbea8e0a3a91ad6d1b9b8f04af4b5ff", "filename": "gcc/fold-const.c", "status": "modified", "additions": 94, "deletions": 115, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f290100275139ccb59832bb75ff7fb2606e110d7/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f290100275139ccb59832bb75ff7fb2606e110d7/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=f290100275139ccb59832bb75ff7fb2606e110d7", "patch": "@@ -10236,121 +10236,6 @@ fold_binary_loc (location_t loc, enum tree_code code, tree type,\n \t    }\n \t}\n \n-      /* For constants M and N, if M == (1LL << cst) - 1 && (N & M) == M,\n-\t ((A & N) + B) & M -> (A + B) & M\n-\t Similarly if (N & M) == 0,\n-\t ((A | N) + B) & M -> (A + B) & M\n-\t and for - instead of + (or unary - instead of +)\n-\t and/or ^ instead of |.\n-\t If B is constant and (B & M) == 0, fold into A & M.  */\n-      if (TREE_CODE (arg1) == INTEGER_CST)\n-\t{\n-\t  wi::tree_to_wide_ref cst1 = wi::to_wide (arg1);\n-\t  if ((~cst1 != 0) && (cst1 & (cst1 + 1)) == 0\n-\t      && INTEGRAL_TYPE_P (TREE_TYPE (arg0))\n-\t      && (TREE_CODE (arg0) == PLUS_EXPR\n-\t\t  || TREE_CODE (arg0) == MINUS_EXPR\n-\t\t  || TREE_CODE (arg0) == NEGATE_EXPR)\n-\t      && (TYPE_OVERFLOW_WRAPS (TREE_TYPE (arg0))\n-\t\t  || TREE_CODE (TREE_TYPE (arg0)) == INTEGER_TYPE))\n-\t    {\n-\t      tree pmop[2];\n-\t      int which = 0;\n-\t      wide_int cst0;\n-\n-\t      /* Now we know that arg0 is (C + D) or (C - D) or\n-\t\t -C and arg1 (M) is == (1LL << cst) - 1.\n-\t\t Store C into PMOP[0] and D into PMOP[1].  */\n-\t      pmop[0] = TREE_OPERAND (arg0, 0);\n-\t      pmop[1] = NULL;\n-\t      if (TREE_CODE (arg0) != NEGATE_EXPR)\n-\t\t{\n-\t\t  pmop[1] = TREE_OPERAND (arg0, 1);\n-\t\t  which = 1;\n-\t\t}\n-\n-\t      if ((wi::max_value (TREE_TYPE (arg0)) & cst1) != cst1)\n-\t\twhich = -1;\n-\n-\t      for (; which >= 0; which--)\n-\t\tswitch (TREE_CODE (pmop[which]))\n-\t\t  {\n-\t\t  case BIT_AND_EXPR:\n-\t\t  case BIT_IOR_EXPR:\n-\t\t  case BIT_XOR_EXPR:\n-\t\t    if (TREE_CODE (TREE_OPERAND (pmop[which], 1))\n-\t\t\t!= INTEGER_CST)\n-\t\t      break;\n-\t\t    cst0 = wi::to_wide (TREE_OPERAND (pmop[which], 1)) & cst1;\n-\t\t    if (TREE_CODE (pmop[which]) == BIT_AND_EXPR)\n-\t\t      {\n-\t\t\tif (cst0 != cst1)\n-\t\t\t  break;\n-\t\t      }\n-\t\t    else if (cst0 != 0)\n-\t\t      break;\n-\t\t    /* If C or D is of the form (A & N) where\n-\t\t       (N & M) == M, or of the form (A | N) or\n-\t\t       (A ^ N) where (N & M) == 0, replace it with A.  */\n-\t\t    pmop[which] = TREE_OPERAND (pmop[which], 0);\n-\t\t    break;\n-\t\t  case INTEGER_CST:\n-\t\t    /* If C or D is a N where (N & M) == 0, it can be\n-\t\t       omitted (assumed 0).  */\n-\t\t    if ((TREE_CODE (arg0) == PLUS_EXPR\n-\t\t\t || (TREE_CODE (arg0) == MINUS_EXPR && which == 0))\n-\t\t\t&& (cst1 & wi::to_wide (pmop[which])) == 0)\n-\t\t      pmop[which] = NULL;\n-\t\t    break;\n-\t\t  default:\n-\t\t    break;\n-\t\t  }\n-\n-\t      /* Only build anything new if we optimized one or both arguments\n-\t\t above.  */\n-\t      if (pmop[0] != TREE_OPERAND (arg0, 0)\n-\t\t  || (TREE_CODE (arg0) != NEGATE_EXPR\n-\t\t      && pmop[1] != TREE_OPERAND (arg0, 1)))\n-\t\t{\n-\t\t  tree utype = TREE_TYPE (arg0);\n-\t\t  if (! TYPE_OVERFLOW_WRAPS (TREE_TYPE (arg0)))\n-\t\t    {\n-\t\t      /* Perform the operations in a type that has defined\n-\t\t\t overflow behavior.  */\n-\t\t      utype = unsigned_type_for (TREE_TYPE (arg0));\n-\t\t      if (pmop[0] != NULL)\n-\t\t\tpmop[0] = fold_convert_loc (loc, utype, pmop[0]);\n-\t\t      if (pmop[1] != NULL)\n-\t\t\tpmop[1] = fold_convert_loc (loc, utype, pmop[1]);\n-\t\t    }\n-\n-\t\t  if (TREE_CODE (arg0) == NEGATE_EXPR)\n-\t\t    tem = fold_build1_loc (loc, NEGATE_EXPR, utype, pmop[0]);\n-\t\t  else if (TREE_CODE (arg0) == PLUS_EXPR)\n-\t\t    {\n-\t\t      if (pmop[0] != NULL && pmop[1] != NULL)\n-\t\t\ttem = fold_build2_loc (loc, PLUS_EXPR, utype,\n-\t\t\t\t\t       pmop[0], pmop[1]);\n-\t\t      else if (pmop[0] != NULL)\n-\t\t\ttem = pmop[0];\n-\t\t      else if (pmop[1] != NULL)\n-\t\t\ttem = pmop[1];\n-\t\t      else\n-\t\t\treturn build_int_cst (type, 0);\n-\t\t    }\n-\t\t  else if (pmop[0] == NULL)\n-\t\t    tem = fold_build1_loc (loc, NEGATE_EXPR, utype, pmop[1]);\n-\t\t  else\n-\t\t    tem = fold_build2_loc (loc, MINUS_EXPR, utype,\n-\t\t\t\t\t   pmop[0], pmop[1]);\n-\t\t  /* TEM is now the new binary +, - or unary - replacement.  */\n-\t\t  tem = fold_build2_loc (loc, BIT_AND_EXPR, utype, tem,\n-\t\t\t\t\t fold_convert_loc (loc, utype, arg1));\n-\t\t  return fold_convert_loc (loc, type, tem);\n-\t\t}\n-\t    }\n-\t}\n-\n       /* Simplify ((int)c & 0377) into (int)c, if c is unsigned char.  */\n       if (TREE_CODE (arg1) == INTEGER_CST && TREE_CODE (arg0) == NOP_EXPR\n \t  && TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (arg0, 0))))\n@@ -11264,6 +11149,100 @@ fold_binary_loc (location_t loc, enum tree_code code, tree type,\n     } /* switch (code) */\n }\n \n+/* For constants M and N, if M == (1LL << cst) - 1 && (N & M) == M,\n+   ((A & N) + B) & M -> (A + B) & M\n+   Similarly if (N & M) == 0,\n+   ((A | N) + B) & M -> (A + B) & M\n+   and for - instead of + (or unary - instead of +)\n+   and/or ^ instead of |.\n+   If B is constant and (B & M) == 0, fold into A & M.\n+\n+   This function is a helper for match.pd patterns.  Return non-NULL\n+   type in which the simplified operation should be performed only\n+   if any optimization is possible.\n+\n+   ARG1 is M above, ARG00 is left operand of +/-, if CODE00 is BIT_*_EXPR,\n+   then ARG00{0,1} are operands of that bitop, otherwise CODE00 is ERROR_MARK.\n+   Similarly for ARG01, CODE01 and ARG01{0,1}, just for the right operand of\n+   +/-.  */\n+tree\n+fold_bit_and_mask (tree type, tree arg1, enum tree_code code,\n+\t\t   tree arg00, enum tree_code code00, tree arg000, tree arg001,\n+\t\t   tree arg01, enum tree_code code01, tree arg010, tree arg011,\n+\t\t   tree *pmop)\n+{\n+  gcc_assert (TREE_CODE (arg1) == INTEGER_CST);\n+  gcc_assert (code == PLUS_EXPR || code == MINUS_EXPR || code == NEGATE_EXPR);\n+  wi::tree_to_wide_ref cst1 = wi::to_wide (arg1);\n+  if (~cst1 == 0\n+      || (cst1 & (cst1 + 1)) != 0\n+      || !INTEGRAL_TYPE_P (type)\n+      || (!TYPE_OVERFLOW_WRAPS (type)\n+\t  && TREE_CODE (type) != INTEGER_TYPE)\n+      || (wi::max_value (type) & cst1) != cst1)\n+    return NULL_TREE;\n+\n+  enum tree_code codes[2] = { code00, code01 };\n+  tree arg0xx[4] = { arg000, arg001, arg010, arg011 };\n+  int which = 0;\n+  wide_int cst0;\n+\n+  /* Now we know that arg0 is (C + D) or (C - D) or -C and\n+     arg1 (M) is == (1LL << cst) - 1.\n+     Store C into PMOP[0] and D into PMOP[1].  */\n+  pmop[0] = arg00;\n+  pmop[1] = arg01;\n+  which = code != NEGATE_EXPR;\n+\n+  for (; which >= 0; which--)\n+    switch (codes[which])\n+      {\n+      case BIT_AND_EXPR:\n+      case BIT_IOR_EXPR:\n+      case BIT_XOR_EXPR:\n+\tgcc_assert (TREE_CODE (arg0xx[2 * which + 1]) == INTEGER_CST);\n+\tcst0 = wi::to_wide (arg0xx[2 * which + 1]) & cst1;\n+\tif (codes[which] == BIT_AND_EXPR)\n+\t  {\n+\t    if (cst0 != cst1)\n+\t      break;\n+\t  }\n+\telse if (cst0 != 0)\n+\t  break;\n+\t/* If C or D is of the form (A & N) where\n+\t   (N & M) == M, or of the form (A | N) or\n+\t   (A ^ N) where (N & M) == 0, replace it with A.  */\n+\tpmop[which] = arg0xx[2 * which];\n+\tbreak;\n+      case ERROR_MARK:\n+\tif (TREE_CODE (pmop[which]) != INTEGER_CST)\n+\t  break;\n+\t/* If C or D is a N where (N & M) == 0, it can be\n+\t   omitted (replaced with 0).  */\n+\tif ((code == PLUS_EXPR\n+\t     || (code == MINUS_EXPR && which == 0))\n+\t    && (cst1 & wi::to_wide (pmop[which])) == 0)\n+\t  pmop[which] = build_int_cst (type, 0);\n+\t/* Similarly, with C - N where (-N & M) == 0.  */\n+\tif (code == MINUS_EXPR\n+\t    && which == 1\n+\t    && (cst1 & -wi::to_wide (pmop[which])) == 0)\n+\t  pmop[which] = build_int_cst (type, 0);\n+\tbreak;\n+      default:\n+\tgcc_unreachable ();\n+      }\n+\n+  /* Only build anything new if we optimized one or both arguments above.  */\n+  if (pmop[0] == arg00 && pmop[1] == arg01)\n+    return NULL_TREE;\n+\n+  if (TYPE_OVERFLOW_WRAPS (type))\n+    return type;\n+  else\n+    return unsigned_type_for (type);\n+}\n+\n /* Used by contains_label_[p1].  */\n \n struct contains_label_data"}, {"sha": "c64b8d0ecf74f07b81397e5a00e53d2d736e70aa", "filename": "gcc/fold-const.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f290100275139ccb59832bb75ff7fb2606e110d7/gcc%2Ffold-const.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f290100275139ccb59832bb75ff7fb2606e110d7/gcc%2Ffold-const.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.h?ref=f290100275139ccb59832bb75ff7fb2606e110d7", "patch": "@@ -96,6 +96,9 @@ extern tree omit_two_operands_loc (location_t, tree, tree, tree, tree);\n extern tree invert_truthvalue_loc (location_t, tree);\n extern tree fold_unary_to_constant (enum tree_code, tree, tree);\n extern tree fold_binary_to_constant (enum tree_code, tree, tree, tree);\n+extern tree fold_bit_and_mask (tree, tree, enum tree_code,\n+\t\t\t       tree, enum tree_code, tree, tree,\n+\t\t\t       tree, enum tree_code, tree, tree, tree *);\n extern tree fold_read_from_constant_string (tree);\n extern tree int_const_binop (enum tree_code, const_tree, const_tree);\n #define build_fold_addr_expr(T)\\"}, {"sha": "3b02db35a28d1c295710ab1319d31d19c2a592d2", "filename": "gcc/match.pd", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f290100275139ccb59832bb75ff7fb2606e110d7/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f290100275139ccb59832bb75ff7fb2606e110d7/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=f290100275139ccb59832bb75ff7fb2606e110d7", "patch": "@@ -779,6 +779,60 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n   (bit_xor @0 @1)))\n #endif\n \n+/* For constants M and N, if M == (1LL << cst) - 1 && (N & M) == M,\n+   ((A & N) + B) & M -> (A + B) & M\n+   Similarly if (N & M) == 0,\n+   ((A | N) + B) & M -> (A + B) & M\n+   and for - instead of + (or unary - instead of +)\n+   and/or ^ instead of |.\n+   If B is constant and (B & M) == 0, fold into A & M.  */\n+(for op (plus minus)\n+ (for bitop (bit_and bit_ior bit_xor)\n+  (simplify\n+   (bit_and (op:s (bitop:s@0 @3 INTEGER_CST@4) @1) INTEGER_CST@2)\n+    (with\n+     { tree pmop[2];\n+       tree utype = fold_bit_and_mask (TREE_TYPE (@0), @2, op, @0, bitop,\n+\t\t\t\t       @3, @4, @1, ERROR_MARK, NULL_TREE,\n+\t\t\t\t       NULL_TREE, pmop); }\n+     (if (utype)\n+      (convert (bit_and (op (convert:utype { pmop[0]; })\n+\t\t\t    (convert:utype { pmop[1]; }))\n+\t\t\t(convert:utype @2))))))\n+  (simplify\n+   (bit_and (op:s @0 (bitop:s@1 @3 INTEGER_CST@4)) INTEGER_CST@2)\n+    (with\n+     { tree pmop[2];\n+       tree utype = fold_bit_and_mask (TREE_TYPE (@0), @2, op, @0, ERROR_MARK,\n+\t\t\t\t       NULL_TREE, NULL_TREE, @1, bitop, @3,\n+\t\t\t\t       @4, pmop); }\n+     (if (utype)\n+      (convert (bit_and (op (convert:utype { pmop[0]; })\n+\t\t\t    (convert:utype { pmop[1]; }))\n+\t\t\t(convert:utype @2)))))))\n+ (simplify\n+  (bit_and (op:s @0 @1) INTEGER_CST@2)\n+   (with\n+    { tree pmop[2];\n+      tree utype = fold_bit_and_mask (TREE_TYPE (@0), @2, op, @0, ERROR_MARK,\n+\t\t\t\t      NULL_TREE, NULL_TREE, @1, ERROR_MARK,\n+\t\t\t\t      NULL_TREE, NULL_TREE, pmop); }\n+    (if (utype)\n+     (convert (bit_and (op (convert:utype { pmop[0]; })\n+\t\t\t   (convert:utype { pmop[1]; }))\n+\t\t       (convert:utype @2)))))))\n+(for bitop (bit_and bit_ior bit_xor)\n+ (simplify\n+  (bit_and (negate:s (bitop:s@0 @2 INTEGER_CST@3)) INTEGER_CST@1)\n+   (with\n+    { tree pmop[2];\n+      tree utype = fold_bit_and_mask (TREE_TYPE (@0), @1, NEGATE_EXPR, @0,\n+\t\t\t\t      bitop, @2, @3, NULL_TREE, ERROR_MARK,\n+\t\t\t\t      NULL_TREE, NULL_TREE, pmop); }\n+    (if (utype)\n+     (convert (bit_and (negate (convert:utype { pmop[0]; }))\n+\t\t       (convert:utype @1)))))))\n+\n /* X % Y is smaller than Y.  */\n (for cmp (lt ge)\n  (simplify"}, {"sha": "4242c23396161da909c4f1ff95609381e356b7f0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f290100275139ccb59832bb75ff7fb2606e110d7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f290100275139ccb59832bb75ff7fb2606e110d7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f290100275139ccb59832bb75ff7fb2606e110d7", "patch": "@@ -1,3 +1,10 @@\n+2018-07-06  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/86401\n+\t* gcc.dg/tree-ssa/pr86401-1.c: New test.\n+\t* gcc.dg/tree-ssa/pr86401-2.c: New test.\n+\t* c-c++-common/rotate-9.c: New test.\n+\n 2018-07-06  Peter Bergner  <bergner@linux.ibm.com>\n \n \tPR target/86324"}, {"sha": "b1a1d052e43c080ef7fa5eaad6999040f6dac539", "filename": "gcc/testsuite/c-c++-common/rotate-9.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f290100275139ccb59832bb75ff7fb2606e110d7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Frotate-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f290100275139ccb59832bb75ff7fb2606e110d7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Frotate-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Frotate-9.c?ref=f290100275139ccb59832bb75ff7fb2606e110d7", "patch": "@@ -0,0 +1,19 @@\n+/* PR tree-optimization/86401 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-ipa-icf -fdump-tree-optimized\" } */\n+/* { dg-final { scan-tree-dump-times \"r\\[<>]\\[<>]\" 2 \"optimized\" } } */\n+\n+unsigned int\n+f1 (unsigned int x, unsigned int s)\n+{\n+  unsigned int t = s % (__CHAR_BIT__ * __SIZEOF_INT__);\n+  return (x << t) | (x >> (((__CHAR_BIT__ * __SIZEOF_INT__) - t) % (__CHAR_BIT__ * __SIZEOF_INT__)));\n+}\n+\n+unsigned int\n+f2 (unsigned int x, unsigned int s)\n+{\n+  int n = __CHAR_BIT__ * __SIZEOF_INT__;\n+  unsigned int t = s % n;\n+  return (x << t) | (x >> ((n - t) % n));\n+}"}, {"sha": "3bf56cc34d74f85ce9d3c1b7d4489d08f34d9aac", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr86401-1.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f290100275139ccb59832bb75ff7fb2606e110d7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr86401-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f290100275139ccb59832bb75ff7fb2606e110d7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr86401-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr86401-1.c?ref=f290100275139ccb59832bb75ff7fb2606e110d7", "patch": "@@ -0,0 +1,48 @@\n+/* PR tree-optimization/86401 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+/* { dg-final { scan-tree-dump-not \" \\\\+ 64\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-not \"64 - \" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-not \" \\\\+ 4294967232\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-not \" & 319\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-not \" \\\\| 4294967168\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-not \" \\\\^ 4294966912\" \"optimized\" } } */\n+\n+unsigned f1 (unsigned x) { unsigned m = 64; return (m + x) & (m - 1); }\n+unsigned f2 (unsigned x) { return (64 + x) & 63; }\n+unsigned f3 (unsigned x) { unsigned m = 64; return (x + m) & (m - 1); }\n+unsigned f4 (unsigned x) { return (x + 64) & 63; }\n+unsigned f5 (unsigned x) { unsigned m = 64; return (m - x) & (m - 1); }\n+unsigned f6 (unsigned x) { return (64 - x) & 63; }\n+unsigned f7 (unsigned x) { unsigned m = 64; return (x - m) & (m - 1); }\n+unsigned f8 (unsigned x) { return (x - 64) & 63; }\n+unsigned f9 (unsigned x, unsigned y) { unsigned m = 64, n = 256 | (m - 1); return ((x & n) + y) & (m - 1); }\n+unsigned f10 (unsigned x, unsigned y) { return ((x & 319) + y) & 63; }\n+unsigned f11 (unsigned x, unsigned y) { unsigned m = 64, n = -128; return ((x | n) + y) & (m - 1); }\n+unsigned f12 (unsigned x, unsigned y) { return ((x | -128) + y) & 63; }\n+unsigned f13 (unsigned x, unsigned y) { unsigned m = 64, n = -384; return ((x ^ n) + y) & (m - 1); }\n+unsigned f14 (unsigned x, unsigned y) { return ((x ^ -384) + y) & 63; }\n+unsigned f15 (unsigned x, unsigned y) { unsigned m = 64, n = 256 | (m - 1); return (y + (x & n)) & (m - 1); }\n+unsigned f16 (unsigned x, unsigned y) { return (y + (x & 319)) & 63; }\n+unsigned f17 (unsigned x, unsigned y) { unsigned m = 64, n = -128; return (y + (x | n)) & (m - 1); }\n+unsigned f18 (unsigned x, unsigned y) { return (y + (x | -128)) & 63; }\n+unsigned f19 (unsigned x, unsigned y) { unsigned m = 64, n = -384; return (y + (x ^ n)) & (m - 1); }\n+unsigned f20 (unsigned x, unsigned y) { return (y + (x ^ -384)) & 63; }\n+unsigned f21 (unsigned x, unsigned y) { unsigned m = 64, n = 256 | (m - 1); return ((x & n) - y) & (m - 1); }\n+unsigned f22 (unsigned x, unsigned y) { return ((x & 319) - y) & 63; }\n+unsigned f23 (unsigned x, unsigned y) { unsigned m = 64, n = -128; return ((x | n) - y) & (m - 1); }\n+unsigned f24 (unsigned x, unsigned y) { return ((x | -128) - y) & 63; }\n+unsigned f25 (unsigned x, unsigned y) { unsigned m = 64, n = -384; return ((x ^ n) - y) & (m - 1); }\n+unsigned f26 (unsigned x, unsigned y) { return ((x ^ -384) - y) & 63; }\n+unsigned f27 (unsigned x, unsigned y) { unsigned m = 64, n = 256 | (m - 1); return (y - (x & n)) & (m - 1); }\n+unsigned f28 (unsigned x, unsigned y) { return (y - (x & 319)) & 63; }\n+unsigned f29 (unsigned x, unsigned y) { unsigned m = 64, n = -128; return (y - (x | n)) & (m - 1); }\n+unsigned f30 (unsigned x, unsigned y) { return (y - (x | -128)) & 63; }\n+unsigned f31 (unsigned x, unsigned y) { unsigned m = 64, n = -384; return (y - (x ^ n)) & (m - 1); }\n+unsigned f32 (unsigned x, unsigned y) { return (y - (x ^ -384)) & 63; }\n+unsigned f33 (unsigned x) { unsigned m = 64, n = 256 | (m - 1); return (-(x & n)) & (m - 1); }\n+unsigned f34 (unsigned x) { return (-(x & 319)) & 63; }\n+unsigned f35 (unsigned x) { unsigned m = 64, n = -128; return (-(x | n)) & (m - 1); }\n+unsigned f36 (unsigned x) { return (-(x | -128)) & 63; }\n+unsigned f37 (unsigned x) { unsigned m = 64, n = -384; return (-(x ^ n)) & (m - 1); }\n+unsigned f38 (unsigned x) { return (-(x ^ -384)) & 63; }"}, {"sha": "0375d8a387370ebc6bcf48a1fc5c3c62e00aa9c9", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr86401-2.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f290100275139ccb59832bb75ff7fb2606e110d7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr86401-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f290100275139ccb59832bb75ff7fb2606e110d7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr86401-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr86401-2.c?ref=f290100275139ccb59832bb75ff7fb2606e110d7", "patch": "@@ -0,0 +1,48 @@\n+/* PR tree-optimization/86401 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+/* { dg-final { scan-tree-dump-not \" \\\\+ 64\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-not \"64 - \" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-not \" \\\\+ -64\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-not \" & 319\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-not \" \\\\| -128\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-not \" \\\\^ -384\" \"optimized\" } } */\n+\n+int f1 (int x) { int m = 64; return (m + x) & (m - 1); }\n+int f2 (int x) { return (64 + x) & 63; }\n+int f3 (int x) { int m = 64; return (x + m) & (m - 1); }\n+int f4 (int x) { return (x + 64) & 63; }\n+int f5 (int x) { int m = 64; return (m - x) & (m - 1); }\n+int f6 (int x) { return (64 - x) & 63; }\n+int f7 (int x) { int m = 64; return (x - m) & (m - 1); }\n+int f8 (int x) { return (x - 64) & 63; }\n+int f9 (int x, int y) { int m = 64, n = 256 | (m - 1); return ((x & n) + y) & (m - 1); }\n+int f10 (int x, int y) { return ((x & 319) + y) & 63; }\n+int f11 (int x, int y) { int m = 64, n = -128; return ((x | n) + y) & (m - 1); }\n+int f12 (int x, int y) { return ((x | -128) + y) & 63; }\n+int f13 (int x, int y) { int m = 64, n = -384; return ((x ^ n) + y) & (m - 1); }\n+int f14 (int x, int y) { return ((x ^ -384) + y) & 63; }\n+int f15 (int x, int y) { int m = 64, n = 256 | (m - 1); return (y + (x & n)) & (m - 1); }\n+int f16 (int x, int y) { return (y + (x & 319)) & 63; }\n+int f17 (int x, int y) { int m = 64, n = -128; return (y + (x | n)) & (m - 1); }\n+int f18 (int x, int y) { return (y + (x | -128)) & 63; }\n+int f19 (int x, int y) { int m = 64, n = -384; return (y + (x ^ n)) & (m - 1); }\n+int f20 (int x, int y) { return (y + (x ^ -384)) & 63; }\n+int f21 (int x, int y) { int m = 64, n = 256 | (m - 1); return ((x & n) - y) & (m - 1); }\n+int f22 (int x, int y) { return ((x & 319) - y) & 63; }\n+int f23 (int x, int y) { int m = 64, n = -128; return ((x | n) - y) & (m - 1); }\n+int f24 (int x, int y) { return ((x | -128) - y) & 63; }\n+int f25 (int x, int y) { int m = 64, n = -384; return ((x ^ n) - y) & (m - 1); }\n+int f26 (int x, int y) { return ((x ^ -384) - y) & 63; }\n+int f27 (int x, int y) { int m = 64, n = 256 | (m - 1); return (y - (x & n)) & (m - 1); }\n+int f28 (int x, int y) { return (y - (x & 319)) & 63; }\n+int f29 (int x, int y) { int m = 64, n = -128; return (y - (x | n)) & (m - 1); }\n+int f30 (int x, int y) { return (y - (x | -128)) & 63; }\n+int f31 (int x, int y) { int m = 64, n = -384; return (y - (x ^ n)) & (m - 1); }\n+int f32 (int x, int y) { return (y - (x ^ -384)) & 63; }\n+int f33 (int x) { int m = 64, n = 256 | (m - 1); return (-(x & n)) & (m - 1); }\n+int f34 (int x) { return (-(x & 319)) & 63; }\n+int f35 (int x) { int m = 64, n = -128; return (-(x | n)) & (m - 1); }\n+int f36 (int x) { return (-(x | -128)) & 63; }\n+int f37 (int x) { int m = 64, n = -384; return (-(x ^ n)) & (m - 1); }\n+int f38 (int x) { return (-(x ^ -384)) & 63; }"}]}