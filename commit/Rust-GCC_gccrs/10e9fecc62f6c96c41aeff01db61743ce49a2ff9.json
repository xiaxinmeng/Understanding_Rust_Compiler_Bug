{"sha": "10e9fecc62f6c96c41aeff01db61743ce49a2ff9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBlOWZlY2M2MmY2Yzk2YzQxYWVmZjAxZGI2MTc0M2NlNDlhMmZmOQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2003-06-08T14:50:18Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2003-06-08T14:50:18Z"}, "message": "i386.md (subsi_3_zext, [...]): Fix predicates.\n\n\n\t* i386.md (subsi_3_zext, sse2_nandv2di3): Fix predicates.\n\t* i386.c (k8_avoid_jump_misspredicts): Fix debug output.\n\n\t* cfg.c (verify_flow_info): Move IL independent checks from cfgrtl here.\n\t(dump_bb): New based on old dump_bb in cfgrtl.c\n\t(debug_bb, debug_bb_n): Move the functions from cfgrtl.c here.\n\t* cfghooks.h (cfgh_verify_flow_info): Return status.\n\t* cfglayout.c (cfg_layout_finalize): Verify CFG correctness.\n\t* cfgrtl.c (debug_bb, debug_bb_n): Move to cfg.c\n\t(dump_bb): Remove generic parts.\n\t(rtl_verify_flow_info_1): Break out from rtl_verify_flow_info.\n\t(rtl_verify_flow_info): Only check things dependeing on linearized RTL.\n\n\t* i386-cmov1.c: Fix regular expression.\n\t* i386-cvt-1.c: Likewise.\n\t* i386-local.c: Likewise.\n\t* i386-local2.c: Likewise.\n\t* i386-mul.c: Likewise.\n\t* i386-ssetype-1.c: Likewise.\n\t* i386-ssetype-3.c: Likewise.\n\t* i386-ssetype-5.c: Likewise.\n\nFrom-SVN: r67630", "tree": {"sha": "6695ebea74baaaa2226f81de735a9efbc2408442", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6695ebea74baaaa2226f81de735a9efbc2408442"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10e9fecc62f6c96c41aeff01db61743ce49a2ff9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10e9fecc62f6c96c41aeff01db61743ce49a2ff9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10e9fecc62f6c96c41aeff01db61743ce49a2ff9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10e9fecc62f6c96c41aeff01db61743ce49a2ff9/comments", "author": null, "committer": null, "parents": [{"sha": "2cdfea3ae80f8952df6bae07d7ebf6c0fceecc51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cdfea3ae80f8952df6bae07d7ebf6c0fceecc51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2cdfea3ae80f8952df6bae07d7ebf6c0fceecc51"}], "stats": {"total": 583, "additions": 340, "deletions": 243}, "files": [{"sha": "85a12dbce65d5570347b03213a789d778ed63a7b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10e9fecc62f6c96c41aeff01db61743ce49a2ff9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10e9fecc62f6c96c41aeff01db61743ce49a2ff9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=10e9fecc62f6c96c41aeff01db61743ce49a2ff9", "patch": "@@ -1,3 +1,18 @@\n+Sun Jun  8 15:52:17 CEST 2003  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.md (subsi_3_zext, sse2_nandv2di3): Fix predicates.\n+\t* i386.c (k8_avoid_jump_misspredicts): Fix debug output.\n+\n+\t* cfg.c (verify_flow_info): Move IL independent checks from cfgrtl here.\n+\t(dump_bb): New based on old dump_bb in cfgrtl.c\n+\t(debug_bb, debug_bb_n): Move the functions from cfgrtl.c here.\n+\t* cfghooks.h (cfgh_verify_flow_info): Return status.\n+\t* cfglayout.c (cfg_layout_finalize): Verify CFG correctness.\n+\t* cfgrtl.c (debug_bb, debug_bb_n): Move to cfg.c\n+\t(dump_bb): Remove generic parts.\n+\t(rtl_verify_flow_info_1): Break out from rtl_verify_flow_info.\n+\t(rtl_verify_flow_info): Only check things dependeing on linearized RTL.\n+\n 2003-06-08  Neil Booth  <neil@daikokuya.co.uk>\n \n \t* Makefile.in: Rename options.c and options.h to c-options.c and"}, {"sha": "80b32c19af9c05e2ca33bd4db0d717ae0136175b", "filename": "gcc/cfg.c", "status": "modified", "additions": 182, "deletions": 2, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10e9fecc62f6c96c41aeff01db61743ce49a2ff9/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10e9fecc62f6c96c41aeff01db61743ce49a2ff9/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=10e9fecc62f6c96c41aeff01db61743ce49a2ff9", "patch": "@@ -39,6 +39,10 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n      - Allocation of AUX fields for basic blocks\n \t alloc_aux_for_blocks, free_aux_for_blocks, alloc_aux_for_block\n      - clear_bb_flags\n+     - Consistency checking\n+\t verify_flow_info\n+     - Dumping and debugging\n+\t print_rtl_with_bb, dump_bb, debug_bb, debug_bb_n\n  */\n \f\n #include \"config.h\"\n@@ -832,9 +836,185 @@ free_aux_for_edges ()\n }\n \n /* Verify the CFG consistency.  \n-   ??? In the future move IL idepdendent checks here.  */\n+  \n+   Currently it does following checks edge and basic block list correctness\n+   and calls into IL dependent checking then.  */\n void\n verify_flow_info ()\n {\n-  cfg_hooks->cfgh_verify_flow_info ();\n+  size_t *edge_checksum;\n+  int num_bb_notes, err = 0;\n+  basic_block bb, last_bb_seen;\n+  basic_block *last_visited;\n+\n+  last_visited = (basic_block *) xcalloc (last_basic_block + 2,\n+\t\t\t\t\t  sizeof (basic_block));\n+  edge_checksum = (size_t *) xcalloc (last_basic_block + 2, sizeof (size_t));\n+\n+  /* Check bb chain & numbers.  */\n+  last_bb_seen = ENTRY_BLOCK_PTR;\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR->next_bb, NULL, next_bb)\n+    {\n+      if (bb != EXIT_BLOCK_PTR\n+\t  && bb != BASIC_BLOCK (bb->index))\n+\t{\n+\t  error (\"bb %d on wrong place\", bb->index);\n+\t  err = 1;\n+\t}\n+\n+      if (bb->prev_bb != last_bb_seen)\n+\t{\n+\t  error (\"prev_bb of %d should be %d, not %d\",\n+\t\t bb->index, last_bb_seen->index, bb->prev_bb->index);\n+\t  err = 1;\n+\t}\n+\n+      last_bb_seen = bb;\n+    }\n+\n+  /* Now check the basic blocks (boundaries etc.) */\n+  FOR_EACH_BB_REVERSE (bb)\n+    {\n+      int n_fallthru = 0;\n+      edge e;\n+\n+      if (bb->count < 0)\n+\t{\n+\t  error (\"verify_flow_info: Wrong count of block %i %i\",\n+\t         bb->index, (int)bb->count);\n+\t  err = 1;\n+\t}\n+      if (bb->frequency < 0)\n+\t{\n+\t  error (\"verify_flow_info: Wrong frequency of block %i %i\",\n+\t         bb->index, bb->frequency);\n+\t  err = 1;\n+\t}\n+      for (e = bb->succ; e; e = e->succ_next)\n+\t{\n+\t  if (last_visited [e->dest->index + 2] == bb)\n+\t    {\n+\t      error (\"verify_flow_info: Duplicate edge %i->%i\",\n+\t\t     e->src->index, e->dest->index);\n+\t      err = 1;\n+\t    }\n+\t  if (e->probability < 0 || e->probability > REG_BR_PROB_BASE)\n+\t    {\n+\t      error (\"verify_flow_info: Wrong probability of edge %i->%i %i\",\n+\t\t     e->src->index, e->dest->index, e->probability);\n+\t      err = 1;\n+\t    }\n+\t  if (e->count < 0)\n+\t    {\n+\t      error (\"verify_flow_info: Wrong count of edge %i->%i %i\",\n+\t\t     e->src->index, e->dest->index, (int)e->count);\n+\t      err = 1;\n+\t    }\n+\n+\t  last_visited [e->dest->index + 2] = bb;\n+\n+\t  if (e->flags & EDGE_FALLTHRU)\n+\t    n_fallthru++;\n+\n+\t  if (e->src != bb)\n+\t    {\n+\t      error (\"verify_flow_info: Basic block %d succ edge is corrupted\",\n+\t\t     bb->index);\n+\t      fprintf (stderr, \"Predecessor: \");\n+\t      dump_edge_info (stderr, e, 0);\n+\t      fprintf (stderr, \"\\nSuccessor: \");\n+\t      dump_edge_info (stderr, e, 1);\n+\t      fprintf (stderr, \"\\n\");\n+\t      err = 1;\n+\t    }\n+\n+\t  edge_checksum[e->dest->index + 2] += (size_t) e;\n+\t}\n+      if (n_fallthru > 1)\n+\t{\n+\t  error (\"Wrong amount of branch edges after unconditional jump %i\", bb->index);\n+\t  err = 1;\n+\t}\n+\n+      for (e = bb->pred; e; e = e->pred_next)\n+\t{\n+\t  if (e->dest != bb)\n+\t    {\n+\t      error (\"basic block %d pred edge is corrupted\", bb->index);\n+\t      fputs (\"Predecessor: \", stderr);\n+\t      dump_edge_info (stderr, e, 0);\n+\t      fputs (\"\\nSuccessor: \", stderr);\n+\t      dump_edge_info (stderr, e, 1);\n+\t      fputc ('\\n', stderr);\n+\t      err = 1;\n+\t    }\n+\t  edge_checksum[e->dest->index + 2] -= (size_t) e;\n+\t}\n+    }\n+\n+  /* Complete edge checksumming for ENTRY and EXIT.  */\n+  {\n+    edge e;\n+\n+    for (e = ENTRY_BLOCK_PTR->succ; e ; e = e->succ_next)\n+      edge_checksum[e->dest->index + 2] += (size_t) e;\n+\n+    for (e = EXIT_BLOCK_PTR->pred; e ; e = e->pred_next)\n+      edge_checksum[e->dest->index + 2] -= (size_t) e;\n+  }\n+\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n+    if (edge_checksum[bb->index + 2])\n+      {\n+\terror (\"basic block %i edge lists are corrupted\", bb->index);\n+\terr = 1;\n+      }\n+\n+  num_bb_notes = 0;\n+  last_bb_seen = ENTRY_BLOCK_PTR;\n+\n+  /* Clean up.  */\n+  free (last_visited);\n+  free (edge_checksum);\n+  err |= cfg_hooks->cfgh_verify_flow_info ();\n+  if (err)\n+    internal_error (\"verify_flow_info failed\");\n+}\n+\n+/* Print out one basic block with live information at start and end.  */\n+\n+void\n+dump_bb (bb, outf)\n+     basic_block bb;\n+     FILE *outf;\n+{\n+  edge e;\n+\n+  fprintf (outf, \";; Basic block %d, loop depth %d, count \",\n+\t   bb->index, bb->loop_depth);\n+  fprintf (outf, HOST_WIDEST_INT_PRINT_DEC, (HOST_WIDEST_INT) bb->count);\n+  putc ('\\n', outf);\n+\n+  cfg_hooks->dump_bb (bb, outf);\n+\n+  fputs (\";; Successors: \", outf);\n+  for (e = bb->succ; e; e = e->succ_next)\n+    dump_edge_info (outf, e, 1);\n+  putc ('\\n', outf);\n+}\n+\n+void\n+debug_bb (bb)\n+     basic_block bb;\n+{\n+  dump_bb (bb, stderr);\n+}\n+\n+basic_block\n+debug_bb_n (n)\n+     int n;\n+{\n+  basic_block bb = BASIC_BLOCK (n);\n+  dump_bb (bb, stderr);\n+  return bb;\n }"}, {"sha": "39acd662b279fc4bb7b3f4834e6250456b11d7e0", "filename": "gcc/cfghooks.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10e9fecc62f6c96c41aeff01db61743ce49a2ff9/gcc%2Fcfghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10e9fecc62f6c96c41aeff01db61743ce49a2ff9/gcc%2Fcfghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.h?ref=10e9fecc62f6c96c41aeff01db61743ce49a2ff9", "patch": "@@ -26,7 +26,8 @@ struct cfg_hooks\n {\n   /* Debugging.  Do not use macros to hook these so they can be called from\n      debugger!  */\n-  void (*cfgh_verify_flow_info)\t        PARAMS ((void));\n+  int (*cfgh_verify_flow_info)\t        PARAMS ((void));\n+  void (*dump_bb)\t\t\tPARAMS ((basic_block, FILE *));\n \n   /* Basic CFG manipulation.  */\n "}, {"sha": "83634dd3d3a397785f535271e26e952cb3559fb3", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10e9fecc62f6c96c41aeff01db61743ce49a2ff9/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10e9fecc62f6c96c41aeff01db61743ce49a2ff9/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=10e9fecc62f6c96c41aeff01db61743ce49a2ff9", "patch": "@@ -1032,6 +1032,9 @@ break_superblocks ()\n void\n cfg_layout_finalize ()\n {\n+#ifdef ENABLE_CHECKING\n+  verify_flow_info ();\n+#endif\n   rtl_register_cfg_hooks ();\n   fixup_fallthru_exit_predecessor ();\n   fixup_reorder_chain ();"}, {"sha": "e597cf837f615ee08d7ceaa7c53adc08875f0b92", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 93, "deletions": 209, "changes": 302, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10e9fecc62f6c96c41aeff01db61743ce49a2ff9/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10e9fecc62f6c96c41aeff01db61743ce49a2ff9/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=10e9fecc62f6c96c41aeff01db61743ce49a2ff9", "patch": "@@ -35,10 +35,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \t redirect_edge_and_branch_force, tidy_fallthru_edge, force_nonfallthru\n      - Edge splitting and committing to edges\n \t split_edge, insert_insn_on_edge, commit_edge_insertions\n-     - Dumping and debugging\n-\t print_rtl_with_bb, dump_bb, debug_bb, debug_bb_n\n-     - Consistency checking\n-\t verify_flow_info\n      - CFG updating after constant propagation\n \t purge_dead_edges, purge_all_dead_edges   */\n \f\n@@ -81,7 +77,7 @@ static rtx last_loop_beg_note\t\tPARAMS ((rtx));\n static bool back_edge_of_syntactic_loop_p PARAMS ((basic_block, basic_block));\n basic_block force_nonfallthru_and_redirect PARAMS ((edge, basic_block));\n static basic_block rtl_split_edge\tPARAMS ((edge));\n-static void rtl_verify_flow_info\tPARAMS ((void));\n+static int rtl_verify_flow_info\t\tPARAMS ((void));\n static edge cfg_layout_split_block\tPARAMS ((basic_block, void *));\n static bool cfg_layout_redirect_edge_and_branch\tPARAMS ((edge, basic_block));\n static basic_block cfg_layout_redirect_edge_and_branch_force PARAMS ((edge, basic_block));\n@@ -90,6 +86,8 @@ static void rtl_delete_block\t\tPARAMS ((basic_block));\n static basic_block rtl_redirect_edge_and_branch_force PARAMS ((edge, basic_block));\n static bool rtl_redirect_edge_and_branch PARAMS ((edge, basic_block));\n static edge rtl_split_block\t\tPARAMS ((basic_block, void *));\n+static void rtl_dump_bb\t\t\tPARAMS ((basic_block, FILE *));\n+static int rtl_verify_flow_info_1\tPARAMS ((void));\n \f\n /* Return true if NOTE is not one of the ones that must be kept paired,\n    so that we may simply delete it.  */\n@@ -1570,24 +1568,13 @@ commit_edge_insertions_watch_calls ()\n \f\n /* Print out one basic block with live information at start and end.  */\n \n-void\n-dump_bb (bb, outf)\n+static void\n+rtl_dump_bb (bb, outf)\n      basic_block bb;\n      FILE *outf;\n {\n   rtx insn;\n   rtx last;\n-  edge e;\n-\n-  fprintf (outf, \";; Basic block %d, loop depth %d, count \",\n-\t   bb->index, bb->loop_depth);\n-  fprintf (outf, HOST_WIDEST_INT_PRINT_DEC, (HOST_WIDEST_INT) bb->count);\n-  putc ('\\n', outf);\n-\n-  fputs (\";; Predecessors: \", outf);\n-  for (e = bb->pred; e; e = e->pred_next)\n-    dump_edge_info (outf, e, 0);\n-  putc ('\\n', outf);\n \n   fputs (\";; Registers live at start:\", outf);\n   dump_regset (bb->global_live_at_start, outf);\n@@ -1600,27 +1587,6 @@ dump_bb (bb, outf)\n   fputs (\";; Registers live at end:\", outf);\n   dump_regset (bb->global_live_at_end, outf);\n   putc ('\\n', outf);\n-\n-  fputs (\";; Successors: \", outf);\n-  for (e = bb->succ; e; e = e->succ_next)\n-    dump_edge_info (outf, e, 1);\n-  putc ('\\n', outf);\n-}\n-\n-void\n-debug_bb (bb)\n-     basic_block bb;\n-{\n-  dump_bb (bb, stderr);\n-}\n-\n-basic_block\n-debug_bb_n (n)\n-     int n;\n-{\n-  basic_block bb = BASIC_BLOCK (n);\n-  dump_bb (bb, stderr);\n-  return bb;\n }\n \f\n /* Like print_rtl, but also print out live information for the start of each\n@@ -1727,63 +1693,34 @@ update_br_prob_note (bb)\n   XEXP (note, 0) = GEN_INT (BRANCH_EDGE (bb)->probability);\n }\n \f\n-/* Verify the CFG consistency.  This function check some CFG invariants and\n-   aborts when something is wrong.  Hope that this function will help to\n-   convert many optimization passes to preserve CFG consistent.\n+/* Verify the CFG and RTL consistency common for both underlying RTL and\n+   cfglayout RTL.\n \n    Currently it does following checks:\n \n    - test head/end pointers\n    - overlapping of basic blocks\n-   - edge list correctness\n    - headers of basic blocks (the NOTE_INSN_BASIC_BLOCK note)\n    - tails of basic blocks (ensure that boundary is necessary)\n    - scans body of the basic block for JUMP_INSN, CODE_LABEL\n      and NOTE_INSN_BASIC_BLOCK\n-   - check that all insns are in the basic blocks\n-     (except the switch handling code, barriers and notes)\n-   - check that all returns are followed by barriers\n \n    In future it can be extended check a lot of other stuff as well\n    (reachability of basic blocks, life information, etc. etc.).  */\n-\n-void\n-rtl_verify_flow_info ()\n+static int\n+rtl_verify_flow_info_1 ()\n {\n   const int max_uid = get_max_uid ();\n-  const rtx rtx_first = get_insns ();\n   rtx last_head = get_last_insn ();\n-  basic_block *bb_info, *last_visited;\n-  size_t *edge_checksum;\n+  basic_block *bb_info;\n   rtx x;\n-  int num_bb_notes, err = 0;\n+  int err = 0;\n   basic_block bb, last_bb_seen;\n \n   bb_info = (basic_block *) xcalloc (max_uid, sizeof (basic_block));\n-  last_visited = (basic_block *) xcalloc (last_basic_block + 2,\n-\t\t\t\t\t  sizeof (basic_block));\n-  edge_checksum = (size_t *) xcalloc (last_basic_block + 2, sizeof (size_t));\n \n   /* Check bb chain & numbers.  */\n   last_bb_seen = ENTRY_BLOCK_PTR;\n-  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR->next_bb, NULL, next_bb)\n-    {\n-      if (bb != EXIT_BLOCK_PTR\n-\t  && bb != BASIC_BLOCK (bb->index))\n-\t{\n-\t  error (\"bb %d on wrong place\", bb->index);\n-\t  err = 1;\n-\t}\n-\n-      if (bb->prev_bb != last_bb_seen)\n-\t{\n-\t  error (\"prev_bb of %d should be %d, not %d\",\n-\t\t bb->index, last_bb_seen->index, bb->prev_bb->index);\n-\t  err = 1;\n-\t}\n-\n-      last_bb_seen = bb;\n-    }\n \n   FOR_EACH_BB_REVERSE (bb)\n     {\n@@ -1850,41 +1787,8 @@ rtl_verify_flow_info ()\n \t      err = 1;\n \t    }\n \t}\n-      if (bb->count < 0)\n-\t{\n-\t  error (\"verify_flow_info: Wrong count of block %i %i\",\n-\t         bb->index, (int)bb->count);\n-\t  err = 1;\n-\t}\n-      if (bb->frequency < 0)\n-\t{\n-\t  error (\"verify_flow_info: Wrong frequency of block %i %i\",\n-\t         bb->index, bb->frequency);\n-\t  err = 1;\n-\t}\n       for (e = bb->succ; e; e = e->succ_next)\n \t{\n-\t  if (last_visited [e->dest->index + 2] == bb)\n-\t    {\n-\t      error (\"verify_flow_info: Duplicate edge %i->%i\",\n-\t\t     e->src->index, e->dest->index);\n-\t      err = 1;\n-\t    }\n-\t  if (e->probability < 0 || e->probability > REG_BR_PROB_BASE)\n-\t    {\n-\t      error (\"verify_flow_info: Wrong probability of edge %i->%i %i\",\n-\t\t     e->src->index, e->dest->index, e->probability);\n-\t      err = 1;\n-\t    }\n-\t  if (e->count < 0)\n-\t    {\n-\t      error (\"verify_flow_info: Wrong count of edge %i->%i %i\",\n-\t\t     e->src->index, e->dest->index, (int)e->count);\n-\t      err = 1;\n-\t    }\n-\n-\t  last_visited [e->dest->index + 2] = bb;\n-\n \t  if (e->flags & EDGE_FALLTHRU)\n \t    n_fallthru++;\n \n@@ -1898,51 +1802,6 @@ rtl_verify_flow_info ()\n \t    n_eh++;\n \t  else if (e->flags & EDGE_ABNORMAL)\n \t    n_abnormal++;\n-\n-\t  if ((e->flags & EDGE_FALLTHRU)\n-\t      && e->src != ENTRY_BLOCK_PTR\n-\t      && e->dest != EXIT_BLOCK_PTR)\n-\t    {\n-\t      rtx insn;\n-\n-\t      if (e->src->next_bb != e->dest)\n-\t\t{\n-\t\t  error\n-\t\t    (\"verify_flow_info: Incorrect blocks for fallthru %i->%i\",\n-\t\t     e->src->index, e->dest->index);\n-\t\t  err = 1;\n-\t\t}\n-\t      else\n-\t\tfor (insn = NEXT_INSN (e->src->end); insn != e->dest->head;\n-\t\t     insn = NEXT_INSN (insn))\n-\t\t  if (GET_CODE (insn) == BARRIER\n-#ifndef CASE_DROPS_THROUGH\n-\t\t      || INSN_P (insn)\n-#else\n-\t\t      || (INSN_P (insn) && ! JUMP_TABLE_DATA_P (insn))\n-#endif\n-\t\t      )\n-\t\t    {\n-\t\t      error (\"verify_flow_info: Incorrect fallthru %i->%i\",\n-\t\t\t     e->src->index, e->dest->index);\n-\t\t      fatal_insn (\"wrong insn in the fallthru edge\", insn);\n-\t\t      err = 1;\n-\t\t    }\n-\t    }\n-\n-\t  if (e->src != bb)\n-\t    {\n-\t      error (\"verify_flow_info: Basic block %d succ edge is corrupted\",\n-\t\t     bb->index);\n-\t      fprintf (stderr, \"Predecessor: \");\n-\t      dump_edge_info (stderr, e, 0);\n-\t      fprintf (stderr, \"\\nSuccessor: \");\n-\t      dump_edge_info (stderr, e, 1);\n-\t      fprintf (stderr, \"\\n\");\n-\t      err = 1;\n-\t    }\n-\n-\t  edge_checksum[e->dest->index + 2] += (size_t) e;\n \t}\n \n       if (n_eh && GET_CODE (PATTERN (bb->end)) != RESX\n@@ -1990,38 +1849,6 @@ rtl_verify_flow_info ()\n \t  err = 1;\n \t}\n \n-      if (!n_fallthru)\n-\t{\n-\t  rtx insn;\n-\n-\t  /* Ensure existence of barrier in BB with no fallthru edges.  */\n-\t  for (insn = bb->end; !insn || GET_CODE (insn) != BARRIER;\n-\t       insn = NEXT_INSN (insn))\n-\t    if (!insn\n-\t\t|| (GET_CODE (insn) == NOTE\n-\t\t    && NOTE_LINE_NUMBER (insn) == NOTE_INSN_BASIC_BLOCK))\n-\t\t{\n-\t\t  error (\"missing barrier after block %i\", bb->index);\n-\t\t  err = 1;\n-\t\t  break;\n-\t\t}\n-\t}\n-\n-      for (e = bb->pred; e; e = e->pred_next)\n-\t{\n-\t  if (e->dest != bb)\n-\t    {\n-\t      error (\"basic block %d pred edge is corrupted\", bb->index);\n-\t      fputs (\"Predecessor: \", stderr);\n-\t      dump_edge_info (stderr, e, 0);\n-\t      fputs (\"\\nSuccessor: \", stderr);\n-\t      dump_edge_info (stderr, e, 1);\n-\t      fputc ('\\n', stderr);\n-\t      err = 1;\n-\t    }\n-\t  edge_checksum[e->dest->index + 2] -= (size_t) e;\n-\t}\n-\n       for (x = bb->head; x != NEXT_INSN (bb->end); x = NEXT_INSN (x))\n \tif (BLOCK_FOR_INSN (x) != bb)\n \t  {\n@@ -2085,23 +1912,82 @@ rtl_verify_flow_info ()\n \t  }\n     }\n \n-  /* Complete edge checksumming for ENTRY and EXIT.  */\n-  {\n-    edge e;\n+  /* Clean up.  */\n+  free (bb_info);\n+  return err;\n+}\n \n-    for (e = ENTRY_BLOCK_PTR->succ; e ; e = e->succ_next)\n-      edge_checksum[e->dest->index + 2] += (size_t) e;\n+/* Verify the CFG and RTL consistency common for both underlying RTL and\n+   cfglayout RTL.\n \n-    for (e = EXIT_BLOCK_PTR->pred; e ; e = e->pred_next)\n-      edge_checksum[e->dest->index + 2] -= (size_t) e;\n-  }\n+   Currently it does following checks:\n+   - all checks of rtl_verify_flow_info_1\n+   - check that all insns are in the basic blocks\n+     (except the switch handling code, barriers and notes)\n+   - check that all returns are followed by barriers\n+   - check that all fallthru edge points to the adjacent blocks.  */\n+static int\n+rtl_verify_flow_info ()\n+{\n+  basic_block bb;\n+  int err = rtl_verify_flow_info_1 ();\n+  rtx x;\n+  int num_bb_notes;\n+  const rtx rtx_first = get_insns ();\n+  basic_block last_bb_seen = ENTRY_BLOCK_PTR, curr_bb = NULL;\n \n-  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n-    if (edge_checksum[bb->index + 2])\n-      {\n-\terror (\"basic block %i edge lists are corrupted\", bb->index);\n-\terr = 1;\n-      }\n+  FOR_EACH_BB_REVERSE (bb)\n+    {\n+      edge e;\n+      for (e = bb->succ; e; e = e->succ_next)\n+\tif (e->flags & EDGE_FALLTHRU)\n+\t  break;\n+      if (!e)\n+\t{\n+\t  rtx insn;\n+\n+\t  /* Ensure existence of barrier in BB with no fallthru edges.  */\n+\t  for (insn = bb->end; !insn || GET_CODE (insn) != BARRIER;\n+\t       insn = NEXT_INSN (insn))\n+\t    if (!insn\n+\t\t|| (GET_CODE (insn) == NOTE\n+\t\t    && NOTE_LINE_NUMBER (insn) == NOTE_INSN_BASIC_BLOCK))\n+\t\t{\n+\t\t  error (\"missing barrier after block %i\", bb->index);\n+\t\t  err = 1;\n+\t\t  break;\n+\t\t}\n+\t}\n+      else if (e->src != ENTRY_BLOCK_PTR\n+\t       && e->dest != EXIT_BLOCK_PTR)\n+        {\n+\t  rtx insn;\n+\n+\t  if (e->src->next_bb != e->dest)\n+\t    {\n+\t      error\n+\t\t(\"verify_flow_info: Incorrect blocks for fallthru %i->%i\",\n+\t\t e->src->index, e->dest->index);\n+\t      err = 1;\n+\t    }\n+\t  else\n+\t    for (insn = NEXT_INSN (e->src->end); insn != e->dest->head;\n+\t\t insn = NEXT_INSN (insn))\n+\t      if (GET_CODE (insn) == BARRIER\n+#ifndef CASE_DROPS_THROUGH\n+\t\t  || INSN_P (insn)\n+#else\n+\t\t  || (INSN_P (insn) && ! JUMP_TABLE_DATA_P (insn))\n+#endif\n+\t\t  )\n+\t\t{\n+\t\t  error (\"verify_flow_info: Incorrect fallthru %i->%i\",\n+\t\t\t e->src->index, e->dest->index);\n+\t\t  fatal_insn (\"wrong insn in the fallthru edge\", insn);\n+\t\t  err = 1;\n+\t\t}\n+        }\n+    }\n \n   num_bb_notes = 0;\n   last_bb_seen = ENTRY_BLOCK_PTR;\n@@ -2114,12 +2000,12 @@ rtl_verify_flow_info ()\n \n \t  num_bb_notes++;\n \t  if (bb != last_bb_seen->next_bb)\n-\t    internal_error (\"basic blocks not numbered consecutively\");\n+\t    internal_error (\"basic blocks not laid down consecutively\");\n \n-\t  last_bb_seen = bb;\n+\t  curr_bb = last_bb_seen = bb;\n \t}\n \n-      if (!bb_info[INSN_UID (x)])\n+      if (!curr_bb)\n \t{\n \t  switch (GET_CODE (x))\n \t    {\n@@ -2148,20 +2034,16 @@ rtl_verify_flow_info ()\n \t  && returnjump_p (x) && ! condjump_p (x)\n \t  && ! (NEXT_INSN (x) && GET_CODE (NEXT_INSN (x)) == BARRIER))\n \t    fatal_insn (\"return not followed by barrier\", x);\n+      if (curr_bb && x == curr_bb->end)\n+\tcurr_bb = NULL;\n     }\n \n   if (num_bb_notes != n_basic_blocks)\n     internal_error\n       (\"number of bb notes in insn chain (%d) != n_basic_blocks (%d)\",\n        num_bb_notes, n_basic_blocks);\n \n-  if (err)\n-    internal_error (\"verify_flow_info failed\");\n-\n-  /* Clean up.  */\n-  free (bb_info);\n-  free (last_visited);\n-  free (edge_checksum);\n+   return err;\n }\n \f\n /* Assume that the preceding pass has possibly eliminated jump instructions\n@@ -2532,6 +2414,7 @@ cfg_layout_delete_block (bb)\n /* Implementation of CFG manipulation for linearized RTL.  */\n struct cfg_hooks rtl_cfg_hooks = {\n   rtl_verify_flow_info,\n+  rtl_dump_bb,\n   rtl_redirect_edge_and_branch,\n   rtl_redirect_edge_and_branch_force,\n   rtl_delete_block,\n@@ -2544,7 +2427,8 @@ struct cfg_hooks rtl_cfg_hooks = {\n    This representation will hopefully become the default one in future\n    version of the compiler.  */\n struct cfg_hooks cfg_layout_rtl_cfg_hooks = {\n-  NULL,   /* verify_flow_info.  */\n+  rtl_verify_flow_info_1,   /* verify_flow_info.  */\n+  rtl_dump_bb,\n   cfg_layout_redirect_edge_and_branch,\n   cfg_layout_redirect_edge_and_branch_force,\n   cfg_layout_delete_block,"}, {"sha": "aaf25f3678ce40a89ce602363bb85934c8e7e114", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10e9fecc62f6c96c41aeff01db61743ce49a2ff9/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10e9fecc62f6c96c41aeff01db61743ce49a2ff9/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=10e9fecc62f6c96c41aeff01db61743ce49a2ff9", "patch": "@@ -15685,7 +15685,7 @@ k8_avoid_jump_misspredicts ()\n       if (njumps < 0)\n \tabort ();\n       if (rtl_dump_file)\n-        fprintf(stderr,\"Interval %i to %i has %i bytes\\n\",\n+        fprintf(rtl_dump_file, \"Interval %i to %i has %i bytes\\n\",\n \t\tINSN_UID (start), INSN_UID (insn), nbytes);\n \n       if (njumps == 3 && isjump && nbytes < 16)\n@@ -15750,8 +15750,7 @@ ix86_reorg ()\n \tdelete_insn (ret);\n       }\n   }\n-  if (TARGET_K8)\n-    k8_avoid_jump_misspredicts ();\n+  k8_avoid_jump_misspredicts ();\n }\n \n /* Return nonzero when QImode register that must be represented via REX prefix"}, {"sha": "8713bca6a6e9e28bacb292cc17b90cb61d4ded57", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10e9fecc62f6c96c41aeff01db61743ce49a2ff9/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10e9fecc62f6c96c41aeff01db61743ce49a2ff9/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=10e9fecc62f6c96c41aeff01db61743ce49a2ff9", "patch": "@@ -97,8 +97,12 @@ extern int target_flags;\n /* configure can arrange to make this 2, to force a 486.  */\n \n #ifndef TARGET_CPU_DEFAULT\n+#ifdef TARGET_64BIT_DEFAULT\n+#define TARGET_CPU_DEFAULT TARGET_CPU_DEFAULT_k8\n+#else\n #define TARGET_CPU_DEFAULT 0\n #endif\n+#endif\n \n /* Masks for the -m switches */\n #define MASK_80387\t\t0x00000001\t/* Hardware floating point */"}, {"sha": "850e9a1dfdc1a81e6417be1dcfe5f0caa357c8cc", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10e9fecc62f6c96c41aeff01db61743ce49a2ff9/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10e9fecc62f6c96c41aeff01db61743ce49a2ff9/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=10e9fecc62f6c96c41aeff01db61743ce49a2ff9", "patch": "@@ -7055,7 +7055,7 @@\n \n (define_insn \"*subsi_3_zext\"\n   [(set (reg 17)\n-\t(compare (match_operand:SI 1 \"nonimmediate_operand\" \"0\")\n+\t(compare (match_operand:SI 1 \"register_operand\" \"0\")\n \t\t (match_operand:SI 2 \"general_operand\" \"rim\")))\n    (set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(zero_extend:DI\n@@ -20151,7 +20151,7 @@\n \n (define_insn \"sse2_nandv2di3\"\n   [(set (match_operand:V2DI 0 \"register_operand\" \"=x\")\n-        (and:V2DI (not:V2DI (match_operand:V2DI 1 \"nonimmediate_operand\" \"0\"))\n+        (and:V2DI (not:V2DI (match_operand:V2DI 1 \"register_operand\" \"0\"))\n \t\t  (match_operand:V2DI 2 \"nonimmediate_operand\" \"xm\")))]\n   \"TARGET_SSE2\n    && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\""}, {"sha": "3aa5d981fbe85bd3613849980a596cfb78f340c8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10e9fecc62f6c96c41aeff01db61743ce49a2ff9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10e9fecc62f6c96c41aeff01db61743ce49a2ff9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=10e9fecc62f6c96c41aeff01db61743ce49a2ff9", "patch": "@@ -1,3 +1,14 @@\n+Sun Jun  8 16:46:04 CEST 2003  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386-cmov1.c: Fix regular expression.\n+\t* i386-cvt-1.c: Likewise.\n+\t* i386-local.c: Likewise.\n+\t* i386-local2.c: Likewise.\n+\t* i386-mul.c: Likewise.\n+\t* i386-ssetype-1.c: Likewise.\n+\t* i386-ssetype-3.c: Likewise.\n+\t* i386-ssetype-5.c: Likewise.\n+\n 2003-06-08  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n \n \tPR c++/11039"}, {"sha": "71f03ae9fead46999b539862ef652a5b034e2565", "filename": "gcc/testsuite/gcc.dg/i386-cmov1.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10e9fecc62f6c96c41aeff01db61743ce49a2ff9/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-cmov1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10e9fecc62f6c96c41aeff01db61743ce49a2ff9/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-cmov1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-cmov1.c?ref=10e9fecc62f6c96c41aeff01db61743ce49a2ff9", "patch": "@@ -1,11 +1,11 @@\n /* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n /* { dg-options \"-O2 -march=k8\" } */\n-/* { dg-final { scan-assembler \"sar.*magic_namea\" } } */\n-/* { dg-final { scan-assembler \"sar.*magic_nameb\" } } */\n-/* { dg-final { scan-assembler \"sar.*magic_namec\" } } */\n-/* { dg-final { scan-assembler \"shr.*magic_named\" } } */\n-/* { dg-final { scan-assembler \"shr.*magic_namee\" } } */\n-/* { dg-final { scan-assembler \"shr.*magic_namef\" } } */\n+/* { dg-final { scan-assembler \"sar\\[^\\\\n\\]*magic_namea\" } } */\n+/* { dg-final { scan-assembler \"sar\\[^\\\\n\\]*magic_nameb\" } } */\n+/* { dg-final { scan-assembler \"sar\\[^\\\\n\\]*magic_namec\" } } */\n+/* { dg-final { scan-assembler \"shr\\[^\\\\n\\]*magic_named\" } } */\n+/* { dg-final { scan-assembler \"shr\\[^\\\\n\\]*magic_namee\" } } */\n+/* { dg-final { scan-assembler \"shr\\[^\\\\n\\]*magic_namef\" } } */\n \n /* Check code generation for several conditional moves doable by single arithmetics.  */\n "}, {"sha": "d2456f60189dc13304902e860e956e0e71dde87e", "filename": "gcc/testsuite/gcc.dg/i386-cvt-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10e9fecc62f6c96c41aeff01db61743ce49a2ff9/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-cvt-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10e9fecc62f6c96c41aeff01db61743ce49a2ff9/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-cvt-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-cvt-1.c?ref=10e9fecc62f6c96c41aeff01db61743ce49a2ff9", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n /* { dg-options \"-O2 -march=k8 -mfpmath=sse\" } */\n-/* { dg-final { scan-assembler \"cvttsd2si.*xmm\" } } */\n-/* { dg-final { scan-assembler \"cvttss2si.*xmm\" } } */\n+/* { dg-final { scan-assembler \"cvttsd2si\\[^\\\\n\\]*xmm\" } } */\n+/* { dg-final { scan-assembler \"cvttss2si\\[^\\\\n\\]*xmm\" } } */\n int a,a1;\n double b;\n float b1;"}, {"sha": "0c3103007cfc99166affb20e7dfb8a4924382257", "filename": "gcc/testsuite/gcc.dg/i386-local.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10e9fecc62f6c96c41aeff01db61743ce49a2ff9/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-local.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10e9fecc62f6c96c41aeff01db61743ce49a2ff9/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-local.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-local.c?ref=10e9fecc62f6c96c41aeff01db61743ce49a2ff9", "patch": "@@ -1,6 +1,6 @@\n /* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n /* { dg-options \"-O2 -funit-at-a-time\" } */\n-/* { dg-final { scan-assembler \"magic.*eax\" } } */\n+/* { dg-final { scan-assembler \"magic\\[^\\\\n\\]*eax\" } } */\n \n /* Verify that local calling convention is used.  */\n static t(int) __attribute__ ((noinline));"}, {"sha": "2225aeea0d92dc5320bfb51469d1891b0a65eaf9", "filename": "gcc/testsuite/gcc.dg/i386-local2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10e9fecc62f6c96c41aeff01db61743ce49a2ff9/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-local2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10e9fecc62f6c96c41aeff01db61743ce49a2ff9/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-local2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-local2.c?ref=10e9fecc62f6c96c41aeff01db61743ce49a2ff9", "patch": "@@ -1,6 +1,6 @@\n /* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n /* { dg-options \"-O2 -funit-at-a-time -fomit-frame-pointer\" } */\n-/* { dg-final { scan-assembler-not \"sub.*sp\" } } */\n+/* { dg-final { scan-assembler-not \"sub\\[^\\\\n\\]*sp\" } } */\n \n static __attribute__ ((noinline)) q ();\n int a;"}, {"sha": "2a864af76d0de3b67b34a831054b2d9187124295", "filename": "gcc/testsuite/gcc.dg/i386-mul.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10e9fecc62f6c96c41aeff01db61743ce49a2ff9/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-mul.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10e9fecc62f6c96c41aeff01db61743ce49a2ff9/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-mul.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-mul.c?ref=10e9fecc62f6c96c41aeff01db61743ce49a2ff9", "patch": "@@ -1,6 +1,6 @@\n /* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n /* { dg-options \"-O2 -march=k8\" } */\n-/* { dg-final { scan-assembler \"and.*magic\" } } */\n+/* { dg-final { scan-assembler \"and\\[^\\\\n\\]*magic\" } } */\n \n /* Should be done as \"andw $32767, magic\".  */\n unsigned short magic;"}, {"sha": "50d0fcaa58a8807ed326af0193dfa04c8a91eecc", "filename": "gcc/testsuite/gcc.dg/i386-ssetype-1.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10e9fecc62f6c96c41aeff01db61743ce49a2ff9/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-ssetype-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10e9fecc62f6c96c41aeff01db61743ce49a2ff9/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-ssetype-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-ssetype-1.c?ref=10e9fecc62f6c96c41aeff01db61743ce49a2ff9", "patch": "@@ -1,11 +1,11 @@\n /* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n /* { dg-options \"-O2 -msse2 -march=k8\" } */\n-/* { dg-final { scan-assembler \"andpd.*magic\" } } */\n-/* { dg-final { scan-assembler \"andnpd.*magic\" } } */\n-/* { dg-final { scan-assembler \"xorpd.*magic\" } } */\n-/* { dg-final { scan-assembler \"orpd.*magic\" } } */\n+/* { dg-final { scan-assembler \"andpd\\[^\\\\n\\]*magic\" } } */\n+/* { dg-final { scan-assembler \"andnpd\\[^\\\\n\\]*magic\" } } */\n+/* { dg-final { scan-assembler \"xorpd\\[^\\\\n\\]*magic\" } } */\n+/* { dg-final { scan-assembler \"orpd\\[^\\\\n\\]*magic\" } } */\n /* { dg-final { scan-assembler-not \"movdqa\" } } */\n-/* { dg-final { scan-assembler \"movapd.*magic\" } } */\n+/* { dg-final { scan-assembler \"movapd\\[^\\\\n\\]*magic\" } } */\n \n /* Verify that we generate proper instruction with memory operand.  */\n "}, {"sha": "3b2461be32cb6f460e2b422ab3b3464cf2380d42", "filename": "gcc/testsuite/gcc.dg/i386-ssetype-3.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10e9fecc62f6c96c41aeff01db61743ce49a2ff9/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-ssetype-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10e9fecc62f6c96c41aeff01db61743ce49a2ff9/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-ssetype-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-ssetype-3.c?ref=10e9fecc62f6c96c41aeff01db61743ce49a2ff9", "patch": "@@ -1,11 +1,11 @@\n /* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n /* { dg-options \"-O2 -msse2 -march=k8\" } */\n-/* { dg-final { scan-assembler \"andps.*magic\" } } */\n-/* { dg-final { scan-assembler \"andnps.*magic\" } } */\n-/* { dg-final { scan-assembler \"xorps.*magic\" } } */\n-/* { dg-final { scan-assembler \"orps.*magic\" } } */\n+/* { dg-final { scan-assembler \"andps\\[^\\\\n\\]*magic\" } } */\n+/* { dg-final { scan-assembler \"andnps\\[^\\\\n\\]*magic\" } } */\n+/* { dg-final { scan-assembler \"xorps\\[^\\\\n\\]*magic\" } } */\n+/* { dg-final { scan-assembler \"orps\\[^\\\\n\\]*magic\" } } */\n /* { dg-final { scan-assembler-not \"movdqa\" } } */\n-/* { dg-final { scan-assembler \"movaps.*magic\" } } */\n+/* { dg-final { scan-assembler \"movaps\\[^\\\\n\\]*magic\" } } */\n \n /* Verify that we generate proper instruction with memory operand.  */\n "}, {"sha": "866c4d3d5778363efda142967dee66622a78c9ef", "filename": "gcc/testsuite/gcc.dg/i386-ssetype-5.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10e9fecc62f6c96c41aeff01db61743ce49a2ff9/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-ssetype-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10e9fecc62f6c96c41aeff01db61743ce49a2ff9/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-ssetype-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-ssetype-5.c?ref=10e9fecc62f6c96c41aeff01db61743ce49a2ff9", "patch": "@@ -1,11 +1,11 @@\n /* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n /* { dg-options \"-O2 -msse2 -march=k8\" } */\n-/* { dg-final { scan-assembler \"pand.*magic\" } } */\n-/* { dg-final { scan-assembler \"pandn.*magic\" } } */\n-/* { dg-final { scan-assembler \"pxor.*magic\" } } */\n-/* { dg-final { scan-assembler \"por.*magic\" } } */\n+/* { dg-final { scan-assembler \"pand\\[^\\\\n\\]*magic\" } } */\n+/* { dg-final { scan-assembler \"pandn\\[^\\\\n\\]*magic\" } } */\n+/* { dg-final { scan-assembler \"pxor\\[^\\\\n\\]*magic\" } } */\n+/* { dg-final { scan-assembler \"por\\[^\\\\n\\]*magic\" } } */\n /* { dg-final { scan-assembler \"movdqa\" } } */\n-/* { dg-final { scan-assembler-not \"movaps.*magic\" } } */\n+/* { dg-final { scan-assembler-not \"movaps\\[^\\\\n\\]*magic\" } } */\n \n /* Verify that we generate proper instruction with memory operand.  */\n "}]}