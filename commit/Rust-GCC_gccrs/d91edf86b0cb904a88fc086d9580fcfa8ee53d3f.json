{"sha": "d91edf86b0cb904a88fc086d9580fcfa8ee53d3f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDkxZWRmODZiMGNiOTA0YTg4ZmMwODZkOTU4MGZjZmE4ZWU1M2QzZg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2003-11-21T06:52:23Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2003-11-21T06:52:23Z"}, "message": "ChangeLog.7: Fix comment typos.\n\n\t* ChangeLog.7: Fix comment typos.\n\t* c-common.c: Likewise.\n\t* c-pretty-print.c: Likewise.\n\t* cgraphunit.c: Likewise.\n\t* et-forest.h: Likewise.\n\t* expr.c: Likewise.\n\t* gcse.c: Likewise.\n\t* genautomata.c: Likewise.\n\t* genrecog.c: Likewise.\n\t* gensupport.c: Likewise.\n\t* ggc-zone.c: Likewise.\n\t* haifa-sched.c: Likewise.\n\t* ifcvt.c: Likewise.\n\t* loop.c: Likewise.\n\t* optabs.c: Likewise.\n\t* pretty-print.h: Likewise.\n\t* regrename.c: Likewise.\n\t* rtl.h: Likewise.\n\t* sched-rgn.c: Likewise.\n\t* target.h: Likewise.\n\t* value-prof.c: Likewise.\n\t* web.c: Likewise.\n\nFrom-SVN: r73795", "tree": {"sha": "0d4b948f3cd1c5a953e88b9bfe820b459208b6a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0d4b948f3cd1c5a953e88b9bfe820b459208b6a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d91edf86b0cb904a88fc086d9580fcfa8ee53d3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d91edf86b0cb904a88fc086d9580fcfa8ee53d3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d91edf86b0cb904a88fc086d9580fcfa8ee53d3f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d91edf86b0cb904a88fc086d9580fcfa8ee53d3f/comments", "author": null, "committer": null, "parents": [{"sha": "9313cfddf9b1c7f3b9c6e19815fdfa37ec1a5b43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9313cfddf9b1c7f3b9c6e19815fdfa37ec1a5b43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9313cfddf9b1c7f3b9c6e19815fdfa37ec1a5b43"}], "stats": {"total": 52, "additions": 26, "deletions": 26}, "files": [{"sha": "f9c6a7dbcb0f863d9bdc91392b71fe8cb2f96c6d", "filename": "gcc/ChangeLog.7", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d91edf86b0cb904a88fc086d9580fcfa8ee53d3f/gcc%2FChangeLog.7", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d91edf86b0cb904a88fc086d9580fcfa8ee53d3f/gcc%2FChangeLog.7", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.7?ref=d91edf86b0cb904a88fc086d9580fcfa8ee53d3f", "patch": "@@ -12648,7 +12648,7 @@ Thu Mar 28 16:35:31 2002  Jeffrey A Law  (law@redhat.com)\n \n Thu Mar 28 19:13:36 CET 2002  Jan Hubicka  <jh@suse.cz>\n \n-\t* ifcvt.c (if_convert): Clear aux_for_blocks early enought.\n+\t* ifcvt.c (if_convert): Clear aux_for_blocks early enough.\n \n Thu Mar 28 13:21:53 CET 2002  Jan Hubicka  <jh@suse.cz>\n "}, {"sha": "acc1e4471c7851f3ea2a3702d96ac29dcc43af55", "filename": "gcc/c-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d91edf86b0cb904a88fc086d9580fcfa8ee53d3f/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d91edf86b0cb904a88fc086d9580fcfa8ee53d3f/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=d91edf86b0cb904a88fc086d9580fcfa8ee53d3f", "patch": "@@ -5774,7 +5774,7 @@ c_estimate_num_insns_1 (tree *tp, int *walk_subtrees, void *data)\n     return NULL;\n   switch (TREE_CODE (x))\n     { \n-    /* Reconginze assignments of large structures and constructors of\n+    /* Recognize assignments of large structures and constructors of\n        big arrays.  */\n     case MODIFY_EXPR:\n     case CONSTRUCTOR:"}, {"sha": "7d0a157acf180a9660fa60f14c3a5a5ef4bcc6bd", "filename": "gcc/c-pretty-print.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d91edf86b0cb904a88fc086d9580fcfa8ee53d3f/gcc%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d91edf86b0cb904a88fc086d9580fcfa8ee53d3f/gcc%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pretty-print.c?ref=d91edf86b0cb904a88fc086d9580fcfa8ee53d3f", "patch": "@@ -1820,7 +1820,7 @@ pp_c_expression (c_pretty_printer *pp, tree e)\n \n /* statement:\n       labeled-statement\n-      coumpound-statement\n+      compound-statement\n       expression-statement\n       selection-statement\n       iteration-statement\n@@ -1870,7 +1870,7 @@ pp_c_statement (c_pretty_printer *pp, tree stmt)\n       pp_needs_newline (pp) = true;\n       break;\n \n-      /* coumpound-statement:\n+      /* compound-statement:\n             {  block-item-list(opt) }\n \n          block-item-list:"}, {"sha": "d2d4d4cb996c07f691c1c092fb3f7c4afabebc6e", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d91edf86b0cb904a88fc086d9580fcfa8ee53d3f/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d91edf86b0cb904a88fc086d9580fcfa8ee53d3f/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=d91edf86b0cb904a88fc086d9580fcfa8ee53d3f", "patch": "@@ -931,7 +931,7 @@ cgraph_default_inline_p (struct cgraph_node *n)\n    All inline candidates are put into prioritized heap based on estimated\n    growth of the overall number of instructions and then update the estimates.\n \n-   INLINED and INLINED_CALEES are just pointers to arrays large enought\n+   INLINED and INLINED_CALEES are just pointers to arrays large enough\n    to be passed to cgraph_inlined_into and cgraph_inlined_callees.  */\n \n static void"}, {"sha": "f646d59b9107cf308707a19cc3ac3df39f94b584", "filename": "gcc/et-forest.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d91edf86b0cb904a88fc086d9580fcfa8ee53d3f/gcc%2Fet-forest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d91edf86b0cb904a88fc086d9580fcfa8ee53d3f/gcc%2Fet-forest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fet-forest.h?ref=d91edf86b0cb904a88fc086d9580fcfa8ee53d3f", "patch": "@@ -20,7 +20,7 @@ Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n    for tree operations (insertion and removal of nodes and edges) and\n    poly-logarithmic time for nearest common ancestor.\n \n-   ET tree stores its structue as a sequence of symbols obtained\n+   ET tree stores its structure as a sequence of symbols obtained\n    by dfs(root)\n \n    dfs (node)"}, {"sha": "79b94867f6bc3d7c62160898e62463b4a674bb76", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d91edf86b0cb904a88fc086d9580fcfa8ee53d3f/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d91edf86b0cb904a88fc086d9580fcfa8ee53d3f/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=d91edf86b0cb904a88fc086d9580fcfa8ee53d3f", "patch": "@@ -9341,7 +9341,7 @@ expand_increment (tree exp, int post, int ignore)\n     {\n       /* We have a true reference to the value in OP0.\n \t If there is an insn to add or subtract in this mode, queue it.\n-\t Queueing the increment insn avoids the register shuffling\n+\t Queuing the increment insn avoids the register shuffling\n \t that often results if we must increment now and first save\n \t the old value for subsequent use.  */\n "}, {"sha": "8f9f13aa4cb3d39dd667f4696cd85a03fbb42a9e", "filename": "gcc/gcse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d91edf86b0cb904a88fc086d9580fcfa8ee53d3f/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d91edf86b0cb904a88fc086d9580fcfa8ee53d3f/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=d91edf86b0cb904a88fc086d9580fcfa8ee53d3f", "patch": "@@ -2205,7 +2205,7 @@ hash_scan_set (rtx pat, rtx insn, struct hash_table *table)\n \t\t       && oprs_available_p (pat, tmp))))\n \tinsert_set_in_table (pat, insn, table);\n     }\n-  /* In case of store we want to consider the memory value as avaiable in\n+  /* In case of store we want to consider the memory value as available in\n      the REG stored in that memory. This makes it possible to remove\n      redundant loads from due to stores to the same location.  */\n   else if (flag_gcse_las && GET_CODE (src) == REG && GET_CODE (dest) == MEM)"}, {"sha": "b343d6e65ba5f56db3ab105be327b3697490c26c", "filename": "gcc/genautomata.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d91edf86b0cb904a88fc086d9580fcfa8ee53d3f/gcc%2Fgenautomata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d91edf86b0cb904a88fc086d9580fcfa8ee53d3f/gcc%2Fgenautomata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenautomata.c?ref=d91edf86b0cb904a88fc086d9580fcfa8ee53d3f", "patch": "@@ -6282,7 +6282,7 @@ merge_states (automaton_t automaton, vla_ptr_t *equiv_classes)\n \t\t}\n           }\n \t/* Its is important that alt states were sorted before and\n-           after merging to have the same quering results.  */\n+           after merging to have the same querying results.  */\n         new_state->component_states = uniq_sort_alt_states (alt_states);\n       }\n     else"}, {"sha": "adf81dd70a2a4e0da4c52f992d1f1b3a069f7437", "filename": "gcc/genrecog.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d91edf86b0cb904a88fc086d9580fcfa8ee53d3f/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d91edf86b0cb904a88fc086d9580fcfa8ee53d3f/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=d91edf86b0cb904a88fc086d9580fcfa8ee53d3f", "patch": "@@ -633,7 +633,7 @@ validate_pattern (rtx pattern, rtx insn, rtx set, int set_code)\n \tif (GET_CODE (dest) == STRICT_LOW_PART)\n \t  dest = XEXP (dest, 0);\n \n-\t/* Find the referant for a DUP.  */\n+\t/* Find the referent for a DUP.  */\n \n \tif (GET_CODE (dest) == MATCH_DUP\n \t    || GET_CODE (dest) == MATCH_OP_DUP"}, {"sha": "0d4a8570c6920e48f6e6aee7b2e126b96e10baff", "filename": "gcc/gensupport.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d91edf86b0cb904a88fc086d9580fcfa8ee53d3f/gcc%2Fgensupport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d91edf86b0cb904a88fc086d9580fcfa8ee53d3f/gcc%2Fgensupport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.c?ref=d91edf86b0cb904a88fc086d9580fcfa8ee53d3f", "patch": "@@ -259,7 +259,7 @@ process_include (rtx desc, int lineno)\n   fclose (input_file);\n }\n \n-/* Process a top level rtx in some way, queueing as appropriate.  */\n+/* Process a top level rtx in some way, queuing as appropriate.  */\n \n static void\n process_rtx (rtx desc, int lineno)"}, {"sha": "dbca7614a8b0cc1d9d1a7e000a0f67f94b60a0db", "filename": "gcc/ggc-zone.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d91edf86b0cb904a88fc086d9580fcfa8ee53d3f/gcc%2Fggc-zone.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d91edf86b0cb904a88fc086d9580fcfa8ee53d3f/gcc%2Fggc-zone.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-zone.c?ref=d91edf86b0cb904a88fc086d9580fcfa8ee53d3f", "patch": "@@ -1001,7 +1001,7 @@ ggc_alloc_zone_1 (size_t size, struct alloc_zone *zone, short type)\n   return result;\n }\n \n-/* Allocate a SIZE of chunk memory of GTE type, into an approriate zone\n+/* Allocate a SIZE of chunk memory of GTE type, into an appropriate zone\n    for that type.  */\n \n void *\n@@ -1288,7 +1288,7 @@ sweep_pages (struct alloc_zone *zone)\n \t}\n \n       /* Large pages are all or none affairs. Either they are\n-\t completely empty, or they are completeley full.\n+\t completely empty, or they are completely full.\n \t Thus, if the above didn't catch it, we need not do anything\n \t except remove the mark and reset the bytes_free.\n "}, {"sha": "41ed7718dd838590517307adcf9519156c04cfdd", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d91edf86b0cb904a88fc086d9580fcfa8ee53d3f/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d91edf86b0cb904a88fc086d9580fcfa8ee53d3f/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=d91edf86b0cb904a88fc086d9580fcfa8ee53d3f", "patch": "@@ -973,7 +973,7 @@ priority (rtx insn)\n }\n \f\n /* Macros and functions for keeping the priority queue sorted, and\n-   dealing with queueing and dequeueing of instructions.  */\n+   dealing with queuing and dequeuing of instructions.  */\n \n #define SCHED_SORT(READY, N_READY)                                   \\\n do { if ((N_READY) == 2)\t\t\t\t             \\"}, {"sha": "f7fddf987649af88a20bb1812084b6b3e967fd6a", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d91edf86b0cb904a88fc086d9580fcfa8ee53d3f/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d91edf86b0cb904a88fc086d9580fcfa8ee53d3f/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=d91edf86b0cb904a88fc086d9580fcfa8ee53d3f", "patch": "@@ -1652,7 +1652,7 @@ noce_try_abs (struct noce_if_info *if_info)\n \n   target = expand_abs_nojump (GET_MODE (if_info->x), b, if_info->x, 1);\n \n-  /* ??? It's a quandry whether cmove would be better here, especially\n+  /* ??? It's a quandary whether cmove would be better here, especially\n      for integers.  Perhaps combine will clean things up.  */\n   if (target && negate)\n     target = expand_simple_unop (GET_MODE (target), NEG, target, if_info->x, 0);"}, {"sha": "77567f868d4343e772c7504fce025a414cfd90aa", "filename": "gcc/loop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d91edf86b0cb904a88fc086d9580fcfa8ee53d3f/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d91edf86b0cb904a88fc086d9580fcfa8ee53d3f/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=d91edf86b0cb904a88fc086d9580fcfa8ee53d3f", "patch": "@@ -6223,7 +6223,7 @@ basic_induction_var (const struct loop *loop, rtx x, enum machine_mode mode,\n       /* convert_modes can emit new instructions, e.g. when arg is a loop\n \t invariant MEM and dest_reg has a different mode.\n \t These instructions would be emitted after the end of the function\n-\t and then *inc_val would be an unitialized pseudo.\n+\t and then *inc_val would be an uninitialized pseudo.\n \t Detect this and bail in this case.\n \t Other alternatives to solve this can be introducing a convert_modes\n \t variant which is allowed to fail but not allowed to emit new"}, {"sha": "3a5705f9334a0d784e1ef96c93141120e260aada", "filename": "gcc/optabs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d91edf86b0cb904a88fc086d9580fcfa8ee53d3f/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d91edf86b0cb904a88fc086d9580fcfa8ee53d3f/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=d91edf86b0cb904a88fc086d9580fcfa8ee53d3f", "patch": "@@ -5371,7 +5371,7 @@ init_optabs (void)\n     abs_optab->handlers[TYPE_MODE (complex_double_type_node)].libfunc\n       = init_one_libfunc (\"cabs\");\n \n-  /* The ffs function op[1erates on `int'.  */\n+  /* The ffs function operates on `int'.  */\n   ffs_optab->handlers[(int) mode_for_size (INT_TYPE_SIZE, MODE_INT, 0)].libfunc\n     = init_one_libfunc (\"ffs\");\n "}, {"sha": "1691aec274a9a753544bff097f40141538a0db38", "filename": "gcc/pretty-print.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d91edf86b0cb904a88fc086d9580fcfa8ee53d3f/gcc%2Fpretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d91edf86b0cb904a88fc086d9580fcfa8ee53d3f/gcc%2Fpretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpretty-print.h?ref=d91edf86b0cb904a88fc086d9580fcfa8ee53d3f", "patch": "@@ -234,7 +234,7 @@ struct pretty_print_info\n \n #define pp_buffer(PP) pp_base (PP)->buffer\n /* Clients that directly derive from pretty_printer need to override\n-   this macro to return a pointer to the base pretty_printer structrure.  */\n+   this macro to return a pointer to the base pretty_printer structure.  */\n #define pp_base(PP) (PP)\n \n extern void pp_construct (pretty_printer *, const char *, int);"}, {"sha": "b22e56e19c13971334bdab05dda692c4302dc6af", "filename": "gcc/regrename.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d91edf86b0cb904a88fc086d9580fcfa8ee53d3f/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d91edf86b0cb904a88fc086d9580fcfa8ee53d3f/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=d91edf86b0cb904a88fc086d9580fcfa8ee53d3f", "patch": "@@ -1734,7 +1734,7 @@ copyprop_hardreg_forward (void)\n       /* If a block has a single predecessor, that we've already\n \t processed, begin with the value data that was live at\n \t the end of the predecessor block.  */\n-      /* ??? Ought to use more intelligent queueing of blocks.  */\n+      /* ??? Ought to use more intelligent queuing of blocks.  */\n       if (bb->pred)\n \tfor (bbp = bb; bbp && bbp != bb->pred->src; bbp = bbp->prev_bb);\n       if (bb->pred"}, {"sha": "33027e68f0e777cff81ba4fb0c588a87734f71b2", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d91edf86b0cb904a88fc086d9580fcfa8ee53d3f/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d91edf86b0cb904a88fc086d9580fcfa8ee53d3f/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=d91edf86b0cb904a88fc086d9580fcfa8ee53d3f", "patch": "@@ -1742,7 +1742,7 @@ rtx alloc_EXPR_LIST\t\t\t(int, rtx, rtx);\n /* regclass.c */\n \n /* Maximum number of parallel sets and clobbers in any insn in this fn.\n-   Always at least 3, since the combiner could put that many togetherm\n+   Always at least 3, since the combiner could put that many together\n    and we want this to remain correct for all the remaining passes.  */\n \n extern int max_parallel;"}, {"sha": "f052f1b9938fda4d156d9b1cf86424cae2d2041a", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d91edf86b0cb904a88fc086d9580fcfa8ee53d3f/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d91edf86b0cb904a88fc086d9580fcfa8ee53d3f/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=d91edf86b0cb904a88fc086d9580fcfa8ee53d3f", "patch": "@@ -2036,7 +2036,7 @@ add_branch_dependences (rtx head, rtx tail)\n      end since moving them results in worse register allocation.  Uses remain\n      at the end to ensure proper register allocation.\n \n-     cc0 setters remaim at the end because they can't be moved away from\n+     cc0 setters remain at the end because they can't be moved away from\n      their cc0 user.\n \n      Insns setting CLASS_LIKELY_SPILLED_P registers (usually return values)"}, {"sha": "c959656e6b2dd31a073dd48825002eb97a3815c6", "filename": "gcc/target.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d91edf86b0cb904a88fc086d9580fcfa8ee53d3f/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d91edf86b0cb904a88fc086d9580fcfa8ee53d3f/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=d91edf86b0cb904a88fc086d9580fcfa8ee53d3f", "patch": "@@ -207,7 +207,7 @@ struct gcc_target\n        correspondingly starts and finishes.  The function defined by\n        init_dfa_pre_cycle_insn and init_dfa_post_cycle_insn are used\n        to initialize the corresponding insns.  The default values of\n-       the memebers result in not changing the automaton state when\n+       the members result in not changing the automaton state when\n        the new simulated processor cycle correspondingly starts and\n        finishes.  */\n     void (* init_dfa_pre_cycle_insn) (void);"}, {"sha": "4f6f3da599a90b1c834b01ef4ddd8a24f224f484", "filename": "gcc/value-prof.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d91edf86b0cb904a88fc086d9580fcfa8ee53d3f/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d91edf86b0cb904a88fc086d9580fcfa8ee53d3f/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=d91edf86b0cb904a88fc086d9580fcfa8ee53d3f", "patch": "@@ -132,7 +132,7 @@ insn_divmod_values_to_profile (rtx insn, unsigned *n_values,\n \t  (*n_values)++;\n \t}\n \n-      /* For mod, check whether it is not often a noop (or replacable by\n+      /* For mod, check whether it is not often a noop (or replaceable by\n \t a few subtractions).  */\n       if (GET_CODE (set_src) == UMOD && !side_effects_p (op1))\n \t{\n@@ -446,9 +446,9 @@ divmod_fixed_value_transform (rtx insn)\n   histogram = XEXP (histogram, 1);\n   all = INTVAL (XEXP (histogram, 0));\n \n-  /* We requiere that count is at least half of all; this means\n+  /* We require that count is at least half of all; this means\n      that for the transformation to fire the value must be constant\n-     at least 50% of time (and 75% gives the garantee of usage).  */\n+     at least 50% of time (and 75% gives the guarantee of usage).  */\n   if (!rtx_equal_p (op2, value) || 2 * count < all)\n     return false;\n "}, {"sha": "e846ee1d2fc7836a9141a938e16893d2310d9ac4", "filename": "gcc/web.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d91edf86b0cb904a88fc086d9580fcfa8ee53d3f/gcc%2Fweb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d91edf86b0cb904a88fc086d9580fcfa8ee53d3f/gcc%2Fweb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fweb.c?ref=d91edf86b0cb904a88fc086d9580fcfa8ee53d3f", "patch": "@@ -20,7 +20,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n 02111-1307, USA.  */\n \n /* Simple optimization pass that splits independent uses of each pseudo,\n-   increasing effectivity of other optimizations.  The optimization can\n+   increasing effectiveness of other optimizations.  The optimization can\n    serve as an example of use for the dataflow module.\n \n    We don't split registers with REG_USERVAR set unless -fmessy-debugging"}]}