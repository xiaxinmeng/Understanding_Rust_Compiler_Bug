{"sha": "3af4ba41cc98aa2c50c2a5c3ebcb7197b736994a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2FmNGJhNDFjYzk4YWEyYzUwYzJhNWMzZWJjYjcxOTdiNzM2OTk0YQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2009-10-20T19:50:38Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2009-10-20T19:50:38Z"}, "message": "rtl.h (simplify_replace_fn_rtx): Declare.\n\ngcc/\n\t* rtl.h (simplify_replace_fn_rtx): Declare.\n\t(wrap_constant, unwrap_constant): Delete.\n\t* cfgexpand.c (unwrap_constant, wrap_constant): Delete.\n\t(expand_debug_expr): Don't call wrap_constant.\n\t* combine.c (rtx_subst_pair): Only define for AUTO_INC_DEC.\n\t(auto_adjust_pair): Fold into...\n\t(propagate_for_debug_subst): ...here.  Only define for AUTO_INC_DEC.\n\tJust return a new value.\n\t(propagate_for_debug): Use simplify_replace_fn_rtx for AUTO_INC_DEC,\n\totherwise use simplify_replace_rtx.\n\t* cselib.c (wrap_constant): Reinstate old definition.\n\t(cselib_expand_value_rtx_1): Don't wrap constants.\n\t* gcse.c (try_replace_reg): Don't use copy_rtx in the call to\n\tsimplify_replace_rtx.\n\t(bypass_block): Fix formatting in calls to simplify_replace_rtx.\n\t* reload1.c (reload): Skip all uses for an insn before adjusting it.\n\tUse simplify_replace_rtx.\n\t* simplify-rtx.c (simplify_replace_fn_rtx): New function,\n\tadapted from...\n\t(simplify_replace_rtx): ...here.  Turn into a wrapper for\n\tsimplify_replace_fn_rtx.\n\t(simplify_unary_operation): Don't unwrap CONSTs.\n\t* var-tracking.c (check_wrap_constant): Delete.\n\t(vt_expand_loc_callback): Don't call it.\n\t(vt_expand_loc): Likewise.\n\nFrom-SVN: r153037", "tree": {"sha": "d2712a2600e01b99ea494a11870796fdeedfb4c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2712a2600e01b99ea494a11870796fdeedfb4c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3af4ba41cc98aa2c50c2a5c3ebcb7197b736994a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3af4ba41cc98aa2c50c2a5c3ebcb7197b736994a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3af4ba41cc98aa2c50c2a5c3ebcb7197b736994a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3af4ba41cc98aa2c50c2a5c3ebcb7197b736994a/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6a1868c766cec7ccaa1073f1b9d0ff30da8169d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a1868c766cec7ccaa1073f1b9d0ff30da8169d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a1868c766cec7ccaa1073f1b9d0ff30da8169d3"}], "stats": {"total": 300, "additions": 117, "deletions": 183}, "files": [{"sha": "a31dfe3207b0ca7adc3b501e671370c6105f0be5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3af4ba41cc98aa2c50c2a5c3ebcb7197b736994a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3af4ba41cc98aa2c50c2a5c3ebcb7197b736994a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3af4ba41cc98aa2c50c2a5c3ebcb7197b736994a", "patch": "@@ -1,3 +1,31 @@\n+2009-10-20  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* rtl.h (simplify_replace_fn_rtx): Declare.\n+\t(wrap_constant, unwrap_constant): Delete.\n+\t* cfgexpand.c (unwrap_constant, wrap_constant): Delete.\n+\t(expand_debug_expr): Don't call wrap_constant.\n+\t* combine.c (rtx_subst_pair): Only define for AUTO_INC_DEC.\n+\t(auto_adjust_pair): Fold into...\n+\t(propagate_for_debug_subst): ...here.  Only define for AUTO_INC_DEC.\n+\tJust return a new value.\n+\t(propagate_for_debug): Use simplify_replace_fn_rtx for AUTO_INC_DEC,\n+\totherwise use simplify_replace_rtx.\n+\t* cselib.c (wrap_constant): Reinstate old definition.\n+\t(cselib_expand_value_rtx_1): Don't wrap constants.\n+\t* gcse.c (try_replace_reg): Don't use copy_rtx in the call to\n+\tsimplify_replace_rtx.\n+\t(bypass_block): Fix formatting in calls to simplify_replace_rtx.\n+\t* reload1.c (reload): Skip all uses for an insn before adjusting it.\n+\tUse simplify_replace_rtx.\n+\t* simplify-rtx.c (simplify_replace_fn_rtx): New function,\n+\tadapted from...\n+\t(simplify_replace_rtx): ...here.  Turn into a wrapper for\n+\tsimplify_replace_fn_rtx.\n+\t(simplify_unary_operation): Don't unwrap CONSTs.\n+\t* var-tracking.c (check_wrap_constant): Delete.\n+\t(vt_expand_loc_callback): Don't call it.\n+\t(vt_expand_loc): Likewise.\n+\n 2009-10-20  Pascal Obry  <obry@adacore.com>\n \t    Eric Botcazou  <ebotcazou@adacore.com>\n "}, {"sha": "2678d7e7ffe6c345e177de76a5fa988cae7f7c75", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3af4ba41cc98aa2c50c2a5c3ebcb7197b736994a/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3af4ba41cc98aa2c50c2a5c3ebcb7197b736994a/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=3af4ba41cc98aa2c50c2a5c3ebcb7197b736994a", "patch": "@@ -2194,46 +2194,6 @@ round_udiv_adjust (enum machine_mode mode, rtx mod, rtx op1)\n      const1_rtx, const0_rtx);\n }\n \n-/* Wrap modeless constants in CONST:MODE.  */\n-rtx\n-wrap_constant (enum machine_mode mode, rtx x)\n-{\n-  if (GET_MODE (x) != VOIDmode)\n-    return x;\n-\n-  if (CONST_INT_P (x)\n-      || GET_CODE (x) == CONST_FIXED\n-      || GET_CODE (x) == CONST_DOUBLE\n-      || GET_CODE (x) == LABEL_REF)\n-    {\n-      gcc_assert (mode != VOIDmode);\n-\n-      x = gen_rtx_CONST (mode, x);\n-    }\n-\n-  return x;\n-}\n-\n-/* Remove CONST wrapper added by wrap_constant().  */\n-rtx\n-unwrap_constant (rtx x)\n-{\n-  rtx ret = x;\n-\n-  if (GET_CODE (x) != CONST)\n-    return x;\n-\n-  x = XEXP (x, 0);\n-\n-  if (CONST_INT_P (x)\n-      || GET_CODE (x) == CONST_FIXED\n-      || GET_CODE (x) == CONST_DOUBLE\n-      || GET_CODE (x) == LABEL_REF)\n-    ret = x;\n-\n-  return ret;\n-}\n-\n /* Convert X to MODE, that must be Pmode or ptr_mode, without emitting\n    any rtl.  */\n \n@@ -2356,9 +2316,7 @@ expand_debug_expr (tree exp)\n     case COMPLEX_CST:\n       gcc_assert (COMPLEX_MODE_P (mode));\n       op0 = expand_debug_expr (TREE_REALPART (exp));\n-      op0 = wrap_constant (GET_MODE_INNER (mode), op0);\n       op1 = expand_debug_expr (TREE_IMAGPART (exp));\n-      op1 = wrap_constant (GET_MODE_INNER (mode), op1);\n       return gen_rtx_CONCAT (mode, op0, op1);\n \n     case DEBUG_EXPR_DECL:"}, {"sha": "129cd4dff39d7277637ca7e3b0243bab07065406", "filename": "gcc/combine.c", "status": "modified", "additions": 21, "deletions": 55, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3af4ba41cc98aa2c50c2a5c3ebcb7197b736994a/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3af4ba41cc98aa2c50c2a5c3ebcb7197b736994a/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=3af4ba41cc98aa2c50c2a5c3ebcb7197b736994a", "patch": "@@ -2264,68 +2264,33 @@ cleanup_auto_inc_dec (rtx src, bool after, enum machine_mode mem_mode)\n \n   return x;\n }\n-#endif\n \n /* Auxiliary data structure for propagate_for_debug_stmt.  */\n \n struct rtx_subst_pair\n {\n-  rtx from, to;\n-  bool changed;\n-#ifdef AUTO_INC_DEC\n+  rtx to;\n   bool adjusted;\n   bool after;\n-#endif\n };\n \n-/* Clean up any auto-updates in PAIR->to the first time it is called\n-   for a PAIR.  PAIR->adjusted is used to tell whether we've cleaned\n-   up before.  */\n+/* DATA points to an rtx_subst_pair.  Return the value that should be\n+   substituted.  */\n \n-static void\n-auto_adjust_pair (struct rtx_subst_pair *pair ATTRIBUTE_UNUSED)\n+static rtx\n+propagate_for_debug_subst (rtx from ATTRIBUTE_UNUSED, void *data)\n {\n-#ifdef AUTO_INC_DEC\n+  struct rtx_subst_pair *pair = (struct rtx_subst_pair *)data;\n+\n   if (!pair->adjusted)\n     {\n       pair->adjusted = true;\n       pair->to = cleanup_auto_inc_dec (pair->to, pair->after, VOIDmode);\n+      return pair->to;\n     }\n-#endif\n-}\n-\n-/* If *LOC is the same as FROM in the struct rtx_subst_pair passed as\n-   DATA, replace it with a copy of TO.  Handle SUBREGs of *LOC as\n-   well.  */\n-\n-static int\n-propagate_for_debug_subst (rtx *loc, void *data)\n-{\n-  struct rtx_subst_pair *pair = (struct rtx_subst_pair *)data;\n-  rtx from = pair->from, to = pair->to;\n-  rtx x = *loc, s = x;\n-\n-  if (rtx_equal_p (x, from)\n-      || (GET_CODE (x) == SUBREG && rtx_equal_p ((s = SUBREG_REG (x)), from)))\n-    {\n-      auto_adjust_pair (pair);\n-      if (pair->to != to)\n-\tto = pair->to;\n-      else\n-\tto = copy_rtx (to);\n-      if (s != x)\n-\t{\n-\t  gcc_assert (GET_CODE (x) == SUBREG && SUBREG_REG (x) == s);\n-\t  to = simplify_gen_subreg (GET_MODE (x), to,\n-\t\t\t\t    GET_MODE (from), SUBREG_BYTE (x));\n-\t}\n-      *loc = wrap_constant (GET_MODE (x), to);\n-      pair->changed = true;\n-      return -1;\n-    }\n-\n-  return 0;\n+  return copy_rtx (pair->to);\n }\n+#endif\n \n /* Replace occurrences of DEST with SRC in DEBUG_INSNs between INSN\n    and LAST.  If MOVE holds, debug insns must also be moved past\n@@ -2334,14 +2299,11 @@ propagate_for_debug_subst (rtx *loc, void *data)\n static void\n propagate_for_debug (rtx insn, rtx last, rtx dest, rtx src, bool move)\n {\n-  struct rtx_subst_pair p;\n-  rtx next, move_pos = move ? last : NULL_RTX;\n-\n-  p.from = dest;\n-  p.to = src;\n-  p.changed = false;\n+  rtx next, move_pos = move ? last : NULL_RTX, loc;\n \n #ifdef AUTO_INC_DEC\n+  struct rtx_subst_pair p;\n+  p.to = src;\n   p.adjusted = false;\n   p.after = move;\n #endif\n@@ -2353,11 +2315,15 @@ propagate_for_debug (rtx insn, rtx last, rtx dest, rtx src, bool move)\n       next = NEXT_INSN (insn);\n       if (DEBUG_INSN_P (insn))\n \t{\n-\t  for_each_rtx (&INSN_VAR_LOCATION_LOC (insn),\n-\t\t\tpropagate_for_debug_subst, &p);\n-\t  if (!p.changed)\n+#ifdef AUTO_INC_DEC\n+\t  loc = simplify_replace_fn_rtx (INSN_VAR_LOCATION_LOC (insn),\n+\t\t\t\t\t dest, propagate_for_debug_subst, &p);\n+#else\n+\t  loc = simplify_replace_rtx (INSN_VAR_LOCATION_LOC (insn), dest, src);\n+#endif\n+\t  if (loc == INSN_VAR_LOCATION_LOC (insn))\n \t    continue;\n-\t  p.changed = false;\n+\t  INSN_VAR_LOCATION_LOC (insn) = loc;\n \t  if (move_pos)\n \t    {\n \t      remove_insn (insn);"}, {"sha": "aa5f7b022bc005c76d5e3d6b328feed5976e294e", "filename": "gcc/cselib.c", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3af4ba41cc98aa2c50c2a5c3ebcb7197b736994a/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3af4ba41cc98aa2c50c2a5c3ebcb7197b736994a/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=3af4ba41cc98aa2c50c2a5c3ebcb7197b736994a", "patch": "@@ -662,6 +662,19 @@ rtx_equal_for_cselib_p (rtx x, rtx y)\n   return 1;\n }\n \n+/* We need to pass down the mode of constants through the hash table\n+   functions.  For that purpose, wrap them in a CONST of the appropriate\n+   mode.  */\n+static rtx\n+wrap_constant (enum machine_mode mode, rtx x)\n+{\n+  if (!CONST_INT_P (x) && GET_CODE (x) != CONST_FIXED\n+      && (GET_CODE (x) != CONST_DOUBLE || GET_MODE (x) != VOIDmode))\n+    return x;\n+  gcc_assert (mode != VOIDmode);\n+  return gen_rtx_CONST (mode, x);\n+}\n+\n /* Hash an rtx.  Return 0 if we couldn't hash the rtx.\n    For registers and memory locations, we look up their cselib_val structure\n    and return its VALUE element.\n@@ -1340,21 +1353,9 @@ cselib_expand_value_rtx_1 (rtx orig, struct expand_value_data *evd,\n     default:\n       break;\n     }\n-  if (scopy == NULL_RTX)\n-    {\n-      XEXP (copy, 0)\n-\t= gen_rtx_CONST (GET_MODE (XEXP (orig, 0)), XEXP (copy, 0));\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \"  wrapping const_int result in const to preserve mode %s\\n\",\n-\t\t GET_MODE_NAME (GET_MODE (XEXP (copy, 0))));\n-    }\n   scopy = simplify_rtx (copy);\n   if (scopy)\n-    {\n-      if (GET_MODE (copy) != GET_MODE (scopy))\n-\tscopy = wrap_constant (GET_MODE (copy), scopy);\n-      return scopy;\n-    }\n+    return scopy;\n   return copy;\n }\n "}, {"sha": "7ccb05e1d85fbab65b72a4d6643ffbcff30a35c2", "filename": "gcc/gcse.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3af4ba41cc98aa2c50c2a5c3ebcb7197b736994a/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3af4ba41cc98aa2c50c2a5c3ebcb7197b736994a/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=3af4ba41cc98aa2c50c2a5c3ebcb7197b736994a", "patch": "@@ -2276,8 +2276,7 @@ try_replace_reg (rtx from, rtx to, rtx insn)\n      with our replacement.  */\n   if (note != 0 && REG_NOTE_KIND (note) == REG_EQUAL)\n     set_unique_reg_note (insn, REG_EQUAL,\n-\t\t\t simplify_replace_rtx (XEXP (note, 0), from,\n-\t\t\t copy_rtx (to)));\n+\t\t\t simplify_replace_rtx (XEXP (note, 0), from, to));\n   if (!success && set && reg_mentioned_p (from, SET_SRC (set)))\n     {\n       /* If above failed and this is a single set, try to simplify the source of\n@@ -3038,12 +3037,12 @@ bypass_block (basic_block bb, rtx setcc, rtx jump)\n \t  src = SET_SRC (pc_set (jump));\n \n \t  if (setcc != NULL)\n-\t      src = simplify_replace_rtx (src,\n-\t\t\t\t\t  SET_DEST (PATTERN (setcc)),\n-\t\t\t\t\t  SET_SRC (PATTERN (setcc)));\n+\t    src = simplify_replace_rtx (src,\n+\t\t\t\t\tSET_DEST (PATTERN (setcc)),\n+\t\t\t\t\tSET_SRC (PATTERN (setcc)));\n \n \t  new_rtx = simplify_replace_rtx (src, reg_used->reg_rtx,\n-\t\t\t\t      SET_SRC (set->expr));\n+\t\t\t\t\t  SET_SRC (set->expr));\n \n \t  /* Jump bypassing may have already placed instructions on\n \t     edges of the CFG.  We can't bypass an outgoing edge that"}, {"sha": "e9a0aba83bc3a5db45f9164ffd8c4f65de4b358d", "filename": "gcc/reload1.c", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3af4ba41cc98aa2c50c2a5c3ebcb7197b736994a/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3af4ba41cc98aa2c50c2a5c3ebcb7197b736994a/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=3af4ba41cc98aa2c50c2a5c3ebcb7197b736994a", "patch": "@@ -1257,36 +1257,25 @@ reload (rtx first, int global)\n \n \t  for (use = DF_REG_USE_CHAIN (i); use; use = next)\n \t    {\n-\t      rtx *loc = DF_REF_LOC (use);\n-\t      rtx x = *loc;\n-\n \t      insn = DF_REF_INSN (use);\n+\n+\t      /* Make sure the next ref is for a different instruction,\n+\t\t so that we're not affected by the rescan.  */\n \t      next = DF_REF_NEXT_REG (use);\n+\t      while (next && DF_REF_INSN (next) == insn)\n+\t\tnext = DF_REF_NEXT_REG (next);\n \n \t      if (DEBUG_INSN_P (insn))\n \t\t{\n-\t\t  gcc_assert (x == reg\n-\t\t\t      || (GET_CODE (x) == SUBREG\n-\t\t\t\t  && SUBREG_REG (x) == reg));\n-\n \t\t  if (!equiv)\n \t\t    {\n \t\t      INSN_VAR_LOCATION_LOC (insn) = gen_rtx_UNKNOWN_VAR_LOC ();\n \t\t      df_insn_rescan_debug_internal (insn);\n \t\t    }\n \t\t  else\n-\t\t    {\n-\t\t      if (x == reg)\n-\t\t\t*loc = copy_rtx (equiv);\n-\t\t      else if (GET_CODE (x) == SUBREG\n-\t\t\t       && SUBREG_REG (x) == reg)\n-\t\t\t*loc = simplify_gen_subreg (GET_MODE (x), equiv,\n-\t\t\t\t\t\t    GET_MODE (reg),\n-\t\t\t\t\t\t    SUBREG_BYTE (x));\n-\t\t      else\n-\t\t\tgcc_unreachable ();\n-\t\t    *loc = wrap_constant (GET_MODE (x), *loc);\n-\t\t    }\n+\t\t    INSN_VAR_LOCATION_LOC (insn)\n+\t\t      = simplify_replace_rtx (INSN_VAR_LOCATION_LOC (insn),\n+\t\t\t\t\t      reg, equiv);\n \t\t}\n \t    }\n \t}"}, {"sha": "ee464b7c7f3000be469b32502b68cabdb6199387", "filename": "gcc/rtl.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3af4ba41cc98aa2c50c2a5c3ebcb7197b736994a/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3af4ba41cc98aa2c50c2a5c3ebcb7197b736994a/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=3af4ba41cc98aa2c50c2a5c3ebcb7197b736994a", "patch": "@@ -1768,6 +1768,8 @@ extern rtx simplify_subreg (enum machine_mode, rtx, enum machine_mode,\n \t\t\t    unsigned int);\n extern rtx simplify_gen_subreg (enum machine_mode, rtx, enum machine_mode,\n \t\t\t\tunsigned int);\n+extern rtx simplify_replace_fn_rtx (rtx, const_rtx,\n+\t\t\t\t    rtx (*fn) (rtx, void *), void *);\n extern rtx simplify_replace_rtx (rtx, const_rtx, rtx);\n extern rtx simplify_rtx (const_rtx);\n extern rtx avoid_constant_pool_reference (rtx);\n@@ -2409,8 +2411,6 @@ extern void invert_br_probabilities (rtx);\n extern bool expensive_function_p (int);\n /* In cfgexpand.c */\n extern void add_reg_br_prob_note (rtx last, int probability);\n-extern rtx wrap_constant (enum machine_mode, rtx);\n-extern rtx unwrap_constant (rtx);\n \n /* In var-tracking.c */\n extern unsigned int variable_tracking_main (void);"}, {"sha": "f0c4d11e9424105547d96cef04af297a6ff2af6c", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 37, "deletions": 22, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3af4ba41cc98aa2c50c2a5c3ebcb7197b736994a/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3af4ba41cc98aa2c50c2a5c3ebcb7197b736994a/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=3af4ba41cc98aa2c50c2a5c3ebcb7197b736994a", "patch": "@@ -350,38 +350,47 @@ simplify_gen_relational (enum rtx_code code, enum machine_mode mode,\n   return gen_rtx_fmt_ee (code, mode, op0, op1);\n }\n \f\n-/* Replace all occurrences of OLD_RTX in X with NEW_RTX and try to simplify the\n-   resulting RTX.  Return a new RTX which is as simplified as possible.  */\n+/* Replace all occurrences of OLD_RTX in X with FN (X', DATA), where X'\n+   is an expression in X that is equal to OLD_RTX.  Canonicalize and\n+   simplify the result.\n+\n+   If FN is null, assume FN (X', DATA) == copy_rtx (DATA).  */\n \n rtx\n-simplify_replace_rtx (rtx x, const_rtx old_rtx, rtx new_rtx)\n+simplify_replace_fn_rtx (rtx x, const_rtx old_rtx,\n+\t\t\t rtx (*fn) (rtx, void *), void *data)\n {\n   enum rtx_code code = GET_CODE (x);\n   enum machine_mode mode = GET_MODE (x);\n   enum machine_mode op_mode;\n   rtx op0, op1, op2;\n \n-  /* If X is OLD_RTX, return NEW_RTX.  Otherwise, if this is an expression, try\n-     to build a new expression substituting recursively.  If we can't do\n-     anything, return our input.  */\n+  /* If X is OLD_RTX, return FN (X, DATA), with a null FN.  Otherwise,\n+     if this is an expression, try to build a new expression, substituting\n+     recursively.  If we can't do anything, return our input.  */\n \n   if (rtx_equal_p (x, old_rtx))\n-    return copy_rtx (new_rtx);\n+    {\n+      if (fn)\n+\treturn fn (x, data);\n+      else\n+\treturn copy_rtx ((rtx) data);\n+    }\n \n   switch (GET_RTX_CLASS (code))\n     {\n     case RTX_UNARY:\n       op0 = XEXP (x, 0);\n       op_mode = GET_MODE (op0);\n-      op0 = simplify_replace_rtx (op0, old_rtx, new_rtx);\n+      op0 = simplify_replace_fn_rtx (op0, old_rtx, fn, data);\n       if (op0 == XEXP (x, 0))\n \treturn x;\n       return simplify_gen_unary (code, mode, op0, op_mode);\n \n     case RTX_BIN_ARITH:\n     case RTX_COMM_ARITH:\n-      op0 = simplify_replace_rtx (XEXP (x, 0), old_rtx, new_rtx);\n-      op1 = simplify_replace_rtx (XEXP (x, 1), old_rtx, new_rtx);\n+      op0 = simplify_replace_fn_rtx (XEXP (x, 0), old_rtx, fn, data);\n+      op1 = simplify_replace_fn_rtx (XEXP (x, 1), old_rtx, fn, data);\n       if (op0 == XEXP (x, 0) && op1 == XEXP (x, 1))\n \treturn x;\n       return simplify_gen_binary (code, mode, op0, op1);\n@@ -391,8 +400,8 @@ simplify_replace_rtx (rtx x, const_rtx old_rtx, rtx new_rtx)\n       op0 = XEXP (x, 0);\n       op1 = XEXP (x, 1);\n       op_mode = GET_MODE (op0) != VOIDmode ? GET_MODE (op0) : GET_MODE (op1);\n-      op0 = simplify_replace_rtx (op0, old_rtx, new_rtx);\n-      op1 = simplify_replace_rtx (op1, old_rtx, new_rtx);\n+      op0 = simplify_replace_fn_rtx (op0, old_rtx, fn, data);\n+      op1 = simplify_replace_fn_rtx (op1, old_rtx, fn, data);\n       if (op0 == XEXP (x, 0) && op1 == XEXP (x, 1))\n \treturn x;\n       return simplify_gen_relational (code, mode, op_mode, op0, op1);\n@@ -401,9 +410,9 @@ simplify_replace_rtx (rtx x, const_rtx old_rtx, rtx new_rtx)\n     case RTX_BITFIELD_OPS:\n       op0 = XEXP (x, 0);\n       op_mode = GET_MODE (op0);\n-      op0 = simplify_replace_rtx (op0, old_rtx, new_rtx);\n-      op1 = simplify_replace_rtx (XEXP (x, 1), old_rtx, new_rtx);\n-      op2 = simplify_replace_rtx (XEXP (x, 2), old_rtx, new_rtx);\n+      op0 = simplify_replace_fn_rtx (op0, old_rtx, fn, data);\n+      op1 = simplify_replace_fn_rtx (XEXP (x, 1), old_rtx, fn, data);\n+      op2 = simplify_replace_fn_rtx (XEXP (x, 2), old_rtx, fn, data);\n       if (op0 == XEXP (x, 0) && op1 == XEXP (x, 1) && op2 == XEXP (x, 2))\n \treturn x;\n       if (op_mode == VOIDmode)\n@@ -414,7 +423,7 @@ simplify_replace_rtx (rtx x, const_rtx old_rtx, rtx new_rtx)\n       /* The only case we try to handle is a SUBREG.  */\n       if (code == SUBREG)\n \t{\n-\t  op0 = simplify_replace_rtx (SUBREG_REG (x), old_rtx, new_rtx);\n+\t  op0 = simplify_replace_fn_rtx (SUBREG_REG (x), old_rtx, fn, data);\n \t  if (op0 == SUBREG_REG (x))\n \t    return x;\n \t  op0 = simplify_gen_subreg (GET_MODE (x), op0,\n@@ -427,15 +436,15 @@ simplify_replace_rtx (rtx x, const_rtx old_rtx, rtx new_rtx)\n     case RTX_OBJ:\n       if (code == MEM)\n \t{\n-\t  op0 = simplify_replace_rtx (XEXP (x, 0), old_rtx, new_rtx);\n+\t  op0 = simplify_replace_fn_rtx (XEXP (x, 0), old_rtx, fn, data);\n \t  if (op0 == XEXP (x, 0))\n \t    return x;\n \t  return replace_equiv_address_nv (x, op0);\n \t}\n       else if (code == LO_SUM)\n \t{\n-\t  op0 = simplify_replace_rtx (XEXP (x, 0), old_rtx, new_rtx);\n-\t  op1 = simplify_replace_rtx (XEXP (x, 1), old_rtx, new_rtx);\n+\t  op0 = simplify_replace_fn_rtx (XEXP (x, 0), old_rtx, fn, data);\n+\t  op1 = simplify_replace_fn_rtx (XEXP (x, 1), old_rtx, fn, data);\n \n \t  /* (lo_sum (high x) x) -> x  */\n \t  if (GET_CODE (op0) == HIGH && rtx_equal_p (XEXP (op0, 0), op1))\n@@ -452,6 +461,15 @@ simplify_replace_rtx (rtx x, const_rtx old_rtx, rtx new_rtx)\n     }\n   return x;\n }\n+\n+/* Replace all occurrences of OLD_RTX in X with NEW_RTX and try to simplify the\n+   resulting RTX.  Return a new RTX which is as simplified as possible.  */\n+\n+rtx\n+simplify_replace_rtx (rtx x, const_rtx old_rtx, rtx new_rtx)\n+{\n+  return simplify_replace_fn_rtx (x, old_rtx, 0, new_rtx);\n+}\n \f\n /* Try to simplify a unary operation CODE whose output mode is to be\n    MODE with input operand OP whose mode was originally OP_MODE.\n@@ -462,9 +480,6 @@ simplify_unary_operation (enum rtx_code code, enum machine_mode mode,\n {\n   rtx trueop, tem;\n \n-  if (GET_CODE (op) == CONST)\n-    op = XEXP (op, 0);\n-\n   trueop = avoid_constant_pool_reference (op);\n \n   tem = simplify_const_unary_operation (code, mode, trueop, op_mode);"}, {"sha": "cfcc839b96c826bbce1501fd5f4ce1047870bcad", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 2, "deletions": 24, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3af4ba41cc98aa2c50c2a5c3ebcb7197b736994a/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3af4ba41cc98aa2c50c2a5c3ebcb7197b736994a/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=3af4ba41cc98aa2c50c2a5c3ebcb7197b736994a", "patch": "@@ -6246,24 +6246,6 @@ delete_variable_part (dataflow_set *set, rtx loc, decl_or_value dv,\n   slot = delete_slot_part (set, loc, slot, offset);\n }\n \n-/* Wrap result in CONST:MODE if needed to preserve the mode.  */\n-\n-static rtx\n-check_wrap_constant (enum machine_mode mode, rtx result)\n-{\n-  if (!result || GET_MODE (result) == mode)\n-    return result;\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"  wrapping result in const to preserve mode %s\\n\",\n-\t     GET_MODE_NAME (mode));\n-\n-  result = wrap_constant (mode, result);\n-  gcc_assert (GET_MODE (result) == mode);\n-\n-  return result;\n-}\n-\n /* Callback for cselib_expand_value, that looks for expressions\n    holding the value in the var-tracking hash tables.  Return X for\n    standard processing, anything else is to be used as-is.  */\n@@ -6337,7 +6319,6 @@ vt_expand_loc_callback (rtx x, bitmap regs, int max_depth, void *data)\n     {\n       result = cselib_expand_value_rtx_cb (loc->loc, regs, max_depth,\n \t\t\t\t\t   vt_expand_loc_callback, vars);\n-      result = check_wrap_constant (GET_MODE (loc->loc), result);\n       if (result)\n \tbreak;\n     }\n@@ -6355,14 +6336,11 @@ vt_expand_loc_callback (rtx x, bitmap regs, int max_depth, void *data)\n static rtx\n vt_expand_loc (rtx loc, htab_t vars)\n {\n-  rtx newloc;\n-\n   if (!MAY_HAVE_DEBUG_INSNS)\n     return loc;\n \n-  newloc = cselib_expand_value_rtx_cb (loc, scratch_regs, 5,\n-\t\t\t\t       vt_expand_loc_callback, vars);\n-  loc = check_wrap_constant (GET_MODE (loc), newloc);\n+  loc = cselib_expand_value_rtx_cb (loc, scratch_regs, 5,\n+\t\t\t\t    vt_expand_loc_callback, vars);\n \n   if (loc && MEM_P (loc))\n     loc = targetm.delegitimize_address (loc);"}]}