{"sha": "cbb22e6143e5a2c47bf2006312173c19594c12dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2JiMjJlNjE0M2U1YTJjNDdiZjIwMDYzMTIxNzNjMTk1OTRjMTJkYw==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2016-10-19T11:02:23Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2016-10-19T11:02:23Z"}, "message": "re PR tree-optimization/78005 (172.mgrid and 450.soplex miscompare)\n\n\tPR tree-optimization/78005\n\t* tree-vect-loop-manip.c (vect_gen_prolog_loop_niters): Compute\n\tupper (included) bound for niters of prolog loop.\n\t(vect_gen_scalar_loop_niters): Change parameter VF to VFM1.\n\tCompute niters of scalar loop above which vectorized loop is\n\tpreferred, as well as the upper (included) bound for the niters.\n\t(vect_do_peeling): Record niter bound for loops accordingly.\n\n\tgcc/testsuite\n\tPR tree-optimization/78005\n\t* gcc.dg/vect/pr78005.c: New.\n\t* gcc.target/i386/l_fma_float_1.c: Revise test.\n\t* gcc.target/i386/l_fma_float_2.c: Ditto.\n\t* gcc.target/i386/l_fma_float_3.c: Ditto.\n\t* gcc.target/i386/l_fma_float_4.c: Ditto.\n\t* gcc.target/i386/l_fma_float_5.c: Ditto.\n\t* gcc.target/i386/l_fma_float_6.c: Ditto.\n\t* gcc.target/i386/l_fma_double_1.c: Ditto.\n\t* gcc.target/i386/l_fma_double_2.c: Ditto.\n\t* gcc.target/i386/l_fma_double_3.c: Ditto.\n\t* gcc.target/i386/l_fma_double_4.c: Ditto.\n\t* gcc.target/i386/l_fma_double_5.c: Ditto.\n\t* gcc.target/i386/l_fma_double_6.c: Ditto.\n\nFrom-SVN: r241339", "tree": {"sha": "2af08fcc0b698ef8e79c06f60781eedecdbbc073", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2af08fcc0b698ef8e79c06f60781eedecdbbc073"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cbb22e6143e5a2c47bf2006312173c19594c12dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbb22e6143e5a2c47bf2006312173c19594c12dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbb22e6143e5a2c47bf2006312173c19594c12dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbb22e6143e5a2c47bf2006312173c19594c12dc/comments", "author": null, "committer": null, "parents": [{"sha": "3b834a2e0161ace8a7b494dfc6794d61ba200706", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b834a2e0161ace8a7b494dfc6794d61ba200706", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b834a2e0161ace8a7b494dfc6794d61ba200706"}], "stats": {"total": 256, "additions": 166, "deletions": 90}, "files": [{"sha": "a212b55af203cde1448d4f60c384b51571dccedd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb22e6143e5a2c47bf2006312173c19594c12dc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb22e6143e5a2c47bf2006312173c19594c12dc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cbb22e6143e5a2c47bf2006312173c19594c12dc", "patch": "@@ -1,3 +1,13 @@\n+2016-10-19  Bin Cheng  <bin.cheng@arm.com>\n+\n+\tPR tree-optimization/78005\n+\t* tree-vect-loop-manip.c (vect_gen_prolog_loop_niters): Compute\n+\tupper (included) bound for niters of prolog loop.\n+\t(vect_gen_scalar_loop_niters): Change parameter VF to VFM1.\n+\tCompute niters of scalar loop above which vectorized loop is\n+\tpreferred, as well as the upper (included) bound for the niters.\n+\t(vect_do_peeling): Record niter bound for loops accordingly.\n+\n 2016-10-19  Thomas Schwinge  <thomas@codesourcery.com>\n \n \tPR lto/77458\n@@ -1071,8 +1081,6 @@\n \t(vect_can_advance_ivs_p): Call iv_phi_p.\n \t(vect_update_ivs_after_vectorizer): Call iv_phi_p.  Directly insert\n \tnew gimple stmts in basic block.\n-\t(vect_do_peeling_for_loop_bound):\n-\t(vect_do_peeling_for_alignment):\n \t(vect_gen_niters_for_prolog_loop): Rename to...\n \t(vect_gen_prolog_loop_niters): ...Rename from.  Change parameters and\n \tadjust implementation."}, {"sha": "a2707003931387bb7ea4803ad3479ddc62a1b674", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb22e6143e5a2c47bf2006312173c19594c12dc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb22e6143e5a2c47bf2006312173c19594c12dc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cbb22e6143e5a2c47bf2006312173c19594c12dc", "patch": "@@ -1,3 +1,20 @@\n+2016-10-19  Bin Cheng  <bin.cheng@arm.com>\n+\n+\tPR tree-optimization/78005\n+\t* gcc.dg/vect/pr78005.c: New.\n+\t* gcc.target/i386/l_fma_float_1.c: Revise test.\n+\t* gcc.target/i386/l_fma_float_2.c: Ditto.\n+\t* gcc.target/i386/l_fma_float_3.c: Ditto.\n+\t* gcc.target/i386/l_fma_float_4.c: Ditto.\n+\t* gcc.target/i386/l_fma_float_5.c: Ditto.\n+\t* gcc.target/i386/l_fma_float_6.c: Ditto.\n+\t* gcc.target/i386/l_fma_double_1.c: Ditto.\n+\t* gcc.target/i386/l_fma_double_2.c: Ditto.\n+\t* gcc.target/i386/l_fma_double_3.c: Ditto.\n+\t* gcc.target/i386/l_fma_double_4.c: Ditto.\n+\t* gcc.target/i386/l_fma_double_5.c: Ditto.\n+\t* gcc.target/i386/l_fma_double_6.c: Ditto.\n+\n 2016-10-19  Thomas Schwinge  <thomas@codesourcery.com>\n \n \tPR tree-optimization/78024"}, {"sha": "7cefe73fe1b3d0050befeb5e25aec169867fd96a", "filename": "gcc/testsuite/gcc.dg/vect/pr78005.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb22e6143e5a2c47bf2006312173c19594c12dc/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr78005.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb22e6143e5a2c47bf2006312173c19594c12dc/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr78005.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr78005.c?ref=cbb22e6143e5a2c47bf2006312173c19594c12dc", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-require-effective-target vect_int } */\n+#include \"tree-vect.h\"\n+\n+#define N 20\n+int u[N] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19};\n+int z[N] = {-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,  10, 11, 12, 13, 14, 15, 16, 17, 18};\n+int res4[N] = {0, 1, 8, 3, 22, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19};\n+int res5[N] = {0, 1, 8, 3, 22, 5, 36, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19};\n+int res6[N] = {0, 1, 8, 3, 22, 5, 36, 7, 50, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19};\n+int res7[N] = {0, 1, 8, 3, 22, 5, 36, 7, 50, 9, 64, 11, 12, 13, 14, 15, 16, 17, 18, 19};\n+int res8[N] = {0, 1, 8, 3, 22, 5, 36, 7, 50, 9, 64, 11, 78, 13, 14, 15, 16, 17, 18, 19};\n+int res9[N] = {0, 1, 8, 3, 22, 5, 36, 7, 50, 9, 64, 11, 78, 13, 92, 15, 16, 17, 18, 19};\n+int res10[N] = {0, 1, 8, 3, 22, 5, 36, 7, 50, 9, 64, 11, 78, 13, 92, 15, 106, 17, 18, 19};\n+\n+__attribute__ ((noinline)) void\n+foo (int n, int d)\n+{\n+  int i;\n+  for (i = 2; i < n; i++)\n+    u[2*i-2] = u[2*i-2] + d * (z[i-1] + z[i] + z[i-1] + z[i] + z[i-1] + z[i]);\n+}\n+\n+#define check_u(x)\t\t\\\n+  foo (x, 2);\t\t\t\\\n+  for (i = 0; i < N; i++)\t\\\n+    {\t\t\t\t\\\n+      if (u[i] != res##x[i])\t\\\n+\tabort ();\t\t\\\n+      u[i] = i;\t\t\t\\\n+    }\n+\n+int main(void)\n+{\n+  int i;\n+\n+  check_vect ();\n+\n+  /* Need to check for all possible vector factors.  */\n+  check_u(4);\n+  check_u(5);\n+  check_u(6);\n+  check_u(7);\n+  check_u(8);\n+  check_u(9);\n+  check_u(10);\n+\n+  return 0;\n+}"}, {"sha": "c8ea28a6ab371ae3a78732ae900a1272aeb12968", "filename": "gcc/testsuite/gcc.target/i386/l_fma_double_1.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb22e6143e5a2c47bf2006312173c19594c12dc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb22e6143e5a2c47bf2006312173c19594c12dc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_1.c?ref=cbb22e6143e5a2c47bf2006312173c19594c12dc", "patch": "@@ -13,7 +13,7 @@ typedef double adouble __attribute__((aligned(sizeof (double))));\n /* { dg-final { scan-assembler-times \"vfmsub\\[123\\]+pd\" 8 } } */\n /* { dg-final { scan-assembler-times \"vfnmadd\\[123\\]+pd\" 8 } } */\n /* { dg-final { scan-assembler-times \"vfnmsub\\[123\\]+pd\" 8 } } */\n-/* { dg-final { scan-assembler-times \"vfmadd\\[123\\]+sd\" 88 } } */\n-/* { dg-final { scan-assembler-times \"vfmsub\\[123\\]+sd\" 88 } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd\\[123\\]+sd\" 88 } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub\\[123\\]+sd\" 88 } } */\n+/* { dg-final { scan-assembler-times \"vfmadd\\[123\\]+sd\" 80 } } */\n+/* { dg-final { scan-assembler-times \"vfmsub\\[123\\]+sd\" 80 } } */\n+/* { dg-final { scan-assembler-times \"vfnmadd\\[123\\]+sd\" 80 } } */\n+/* { dg-final { scan-assembler-times \"vfnmsub\\[123\\]+sd\" 80 } } */"}, {"sha": "bd873bc854c542fae21299dae3e56650d7395bad", "filename": "gcc/testsuite/gcc.target/i386/l_fma_double_2.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb22e6143e5a2c47bf2006312173c19594c12dc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb22e6143e5a2c47bf2006312173c19594c12dc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_2.c?ref=cbb22e6143e5a2c47bf2006312173c19594c12dc", "patch": "@@ -13,7 +13,7 @@ typedef double adouble __attribute__((aligned(sizeof (double))));\n /* { dg-final { scan-assembler-times \"vfmsub\\[123\\]+pd\" 8 } } */\n /* { dg-final { scan-assembler-times \"vfnmadd\\[123\\]+pd\" 8 } } */\n /* { dg-final { scan-assembler-times \"vfnmsub\\[123\\]+pd\" 8 } } */\n-/* { dg-final { scan-assembler-times \"vfmadd\\[123\\]+sd\" 88 } } */\n-/* { dg-final { scan-assembler-times \"vfmsub\\[123\\]+sd\" 88 } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd\\[123\\]+sd\" 88 } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub\\[123\\]+sd\" 88 } } */\n+/* { dg-final { scan-assembler-times \"vfmadd\\[123\\]+sd\" 80 } } */\n+/* { dg-final { scan-assembler-times \"vfmsub\\[123\\]+sd\" 80 } } */\n+/* { dg-final { scan-assembler-times \"vfnmadd\\[123\\]+sd\" 80 } } */\n+/* { dg-final { scan-assembler-times \"vfnmsub\\[123\\]+sd\" 80 } } */"}, {"sha": "7677ecb21058e537756801d4ddbbb92de71be34c", "filename": "gcc/testsuite/gcc.target/i386/l_fma_double_3.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb22e6143e5a2c47bf2006312173c19594c12dc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb22e6143e5a2c47bf2006312173c19594c12dc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_3.c?ref=cbb22e6143e5a2c47bf2006312173c19594c12dc", "patch": "@@ -13,7 +13,7 @@ typedef double adouble __attribute__((aligned(sizeof (double))));\n /* { dg-final { scan-assembler-times \"vfmsub\\[123\\]+pd\" 8 } } */\n /* { dg-final { scan-assembler-times \"vfnmadd\\[123\\]+pd\" 8 } } */\n /* { dg-final { scan-assembler-times \"vfnmsub\\[123\\]+pd\" 8 } } */\n-/* { dg-final { scan-assembler-times \"vfmadd\\[123\\]+sd\" 88 } } */\n-/* { dg-final { scan-assembler-times \"vfmsub\\[123\\]+sd\" 88 } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd\\[123\\]+sd\" 88 } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub\\[123\\]+sd\" 88 } } */\n+/* { dg-final { scan-assembler-times \"vfmadd\\[123\\]+sd\" 80 } } */\n+/* { dg-final { scan-assembler-times \"vfmsub\\[123\\]+sd\" 80 } } */\n+/* { dg-final { scan-assembler-times \"vfnmadd\\[123\\]+sd\" 80 } } */\n+/* { dg-final { scan-assembler-times \"vfnmsub\\[123\\]+sd\" 80 } } */"}, {"sha": "e5de796f5c51b8bb856c89c5182b769264d8da34", "filename": "gcc/testsuite/gcc.target/i386/l_fma_double_4.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb22e6143e5a2c47bf2006312173c19594c12dc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb22e6143e5a2c47bf2006312173c19594c12dc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_4.c?ref=cbb22e6143e5a2c47bf2006312173c19594c12dc", "patch": "@@ -13,7 +13,7 @@ typedef double adouble __attribute__((aligned(sizeof (double))));\n /* { dg-final { scan-assembler-times \"vfmsub\\[123\\]+pd\" 8 } } */\n /* { dg-final { scan-assembler-times \"vfnmadd\\[123\\]+pd\" 8 } } */\n /* { dg-final { scan-assembler-times \"vfnmsub\\[123\\]+pd\" 8 } } */\n-/* { dg-final { scan-assembler-times \"vfmadd\\[123\\]+sd\" 88 } } */\n-/* { dg-final { scan-assembler-times \"vfmsub\\[123\\]+sd\" 88 } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd\\[123\\]+sd\" 88 } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub\\[123\\]+sd\" 88 } } */\n+/* { dg-final { scan-assembler-times \"vfmadd\\[123\\]+sd\" 80 } } */\n+/* { dg-final { scan-assembler-times \"vfmsub\\[123\\]+sd\" 80 } } */\n+/* { dg-final { scan-assembler-times \"vfnmadd\\[123\\]+sd\" 80 } } */\n+/* { dg-final { scan-assembler-times \"vfnmsub\\[123\\]+sd\" 80 } } */"}, {"sha": "dfeb96be01a325ce3b14c3994b97dec4eb71e49f", "filename": "gcc/testsuite/gcc.target/i386/l_fma_double_5.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb22e6143e5a2c47bf2006312173c19594c12dc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb22e6143e5a2c47bf2006312173c19594c12dc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_5.c?ref=cbb22e6143e5a2c47bf2006312173c19594c12dc", "patch": "@@ -13,7 +13,7 @@ typedef double adouble __attribute__((aligned(sizeof (double))));\n /* { dg-final { scan-assembler-times \"vfmsub\\[123\\]+pd\" 8 } } */\n /* { dg-final { scan-assembler-times \"vfnmadd\\[123\\]+pd\" 8 } } */\n /* { dg-final { scan-assembler-times \"vfnmsub\\[123\\]+pd\" 8 } } */\n-/* { dg-final { scan-assembler-times \"vfmadd\\[123\\]+sd\" 88 } } */\n-/* { dg-final { scan-assembler-times \"vfmsub\\[123\\]+sd\" 88 } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd\\[123\\]+sd\" 88 } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub\\[123\\]+sd\" 88 } } */\n+/* { dg-final { scan-assembler-times \"vfmadd\\[123\\]+sd\" 80 } } */\n+/* { dg-final { scan-assembler-times \"vfmsub\\[123\\]+sd\" 80 } } */\n+/* { dg-final { scan-assembler-times \"vfnmadd\\[123\\]+sd\" 80 } } */\n+/* { dg-final { scan-assembler-times \"vfnmsub\\[123\\]+sd\" 80 } } */"}, {"sha": "13cbd7a35e6fe2850df09afac1c4504eb49a5e39", "filename": "gcc/testsuite/gcc.target/i386/l_fma_double_6.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb22e6143e5a2c47bf2006312173c19594c12dc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb22e6143e5a2c47bf2006312173c19594c12dc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_6.c?ref=cbb22e6143e5a2c47bf2006312173c19594c12dc", "patch": "@@ -13,7 +13,7 @@ typedef double adouble __attribute__((aligned(sizeof (double))));\n /* { dg-final { scan-assembler-times \"vfmsub\\[123\\]+pd\" 8 } } */\n /* { dg-final { scan-assembler-times \"vfnmadd\\[123\\]+pd\" 8 } } */\n /* { dg-final { scan-assembler-times \"vfnmsub\\[123\\]+pd\" 8 } } */\n-/* { dg-final { scan-assembler-times \"vfmadd\\[123\\]+sd\" 88 } } */\n-/* { dg-final { scan-assembler-times \"vfmsub\\[123\\]+sd\" 88 } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd\\[123\\]+sd\" 88 } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub\\[123\\]+sd\" 88 } } */\n+/* { dg-final { scan-assembler-times \"vfmadd\\[123\\]+sd\" 80 } } */\n+/* { dg-final { scan-assembler-times \"vfmsub\\[123\\]+sd\" 80 } } */\n+/* { dg-final { scan-assembler-times \"vfnmadd\\[123\\]+sd\" 80 } } */\n+/* { dg-final { scan-assembler-times \"vfnmsub\\[123\\]+sd\" 80 } } */"}, {"sha": "f20c009b19c9678f8311a930603f68611f9db962", "filename": "gcc/testsuite/gcc.target/i386/l_fma_float_1.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb22e6143e5a2c47bf2006312173c19594c12dc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb22e6143e5a2c47bf2006312173c19594c12dc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_1.c?ref=cbb22e6143e5a2c47bf2006312173c19594c12dc", "patch": "@@ -12,7 +12,7 @@\n /* { dg-final { scan-assembler-times \"vfmsub\\[123\\]+ps\" 8 } } */\n /* { dg-final { scan-assembler-times \"vfnmadd\\[123\\]+ps\" 8 } } */\n /* { dg-final { scan-assembler-times \"vfnmsub\\[123\\]+ps\" 8 } } */\n-/* { dg-final { scan-assembler-times \"vfmadd\\[123\\]+ss\" 184 } } */\n-/* { dg-final { scan-assembler-times \"vfmsub\\[123\\]+ss\" 184 } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd\\[123\\]+ss\" 184 } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub\\[123\\]+ss\" 184 } } */\n+/* { dg-final { scan-assembler-times \"vfmadd\\[123\\]+ss\" 176 } } */\n+/* { dg-final { scan-assembler-times \"vfmsub\\[123\\]+ss\" 176 } } */\n+/* { dg-final { scan-assembler-times \"vfnmadd\\[123\\]+ss\" 176 } } */\n+/* { dg-final { scan-assembler-times \"vfnmsub\\[123\\]+ss\" 176 } } */"}, {"sha": "ce4efe92f79fa25dfcad7d86c3d63b964639c5cb", "filename": "gcc/testsuite/gcc.target/i386/l_fma_float_2.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb22e6143e5a2c47bf2006312173c19594c12dc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb22e6143e5a2c47bf2006312173c19594c12dc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_2.c?ref=cbb22e6143e5a2c47bf2006312173c19594c12dc", "patch": "@@ -12,7 +12,7 @@\n /* { dg-final { scan-assembler-times \"vfmsub\\[123\\]+ps\" 8 } } */\n /* { dg-final { scan-assembler-times \"vfnmadd\\[123\\]+ps\" 8 } } */\n /* { dg-final { scan-assembler-times \"vfnmsub\\[123\\]+ps\" 8 } } */\n-/* { dg-final { scan-assembler-times \"vfmadd\\[123\\]+ss\" 184 } } */\n-/* { dg-final { scan-assembler-times \"vfmsub\\[123\\]+ss\" 184 } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd\\[123\\]+ss\" 184 } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub\\[123\\]+ss\" 184 } } */\n+/* { dg-final { scan-assembler-times \"vfmadd\\[123\\]+ss\" 176 } } */\n+/* { dg-final { scan-assembler-times \"vfmsub\\[123\\]+ss\" 176 } } */\n+/* { dg-final { scan-assembler-times \"vfnmadd\\[123\\]+ss\" 176 } } */\n+/* { dg-final { scan-assembler-times \"vfnmsub\\[123\\]+ss\" 176 } } */"}, {"sha": "91b953ac631f555f0c4eadffa02730f758c910d2", "filename": "gcc/testsuite/gcc.target/i386/l_fma_float_3.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb22e6143e5a2c47bf2006312173c19594c12dc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb22e6143e5a2c47bf2006312173c19594c12dc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_3.c?ref=cbb22e6143e5a2c47bf2006312173c19594c12dc", "patch": "@@ -12,7 +12,7 @@\n /* { dg-final { scan-assembler-times \"vfmsub\\[123\\]+ps\" 8 } } */\n /* { dg-final { scan-assembler-times \"vfnmadd\\[123\\]+ps\" 8 } } */\n /* { dg-final { scan-assembler-times \"vfnmsub\\[123\\]+ps\" 8 } } */\n-/* { dg-final { scan-assembler-times \"vfmadd\\[123\\]+ss\" 184 } } */\n-/* { dg-final { scan-assembler-times \"vfmsub\\[123\\]+ss\" 184 } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd\\[123\\]+ss\" 184 } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub\\[123\\]+ss\" 184 } } */\n+/* { dg-final { scan-assembler-times \"vfmadd\\[123\\]+ss\" 176 } } */\n+/* { dg-final { scan-assembler-times \"vfmsub\\[123\\]+ss\" 176 } } */\n+/* { dg-final { scan-assembler-times \"vfnmadd\\[123\\]+ss\" 176 } } */\n+/* { dg-final { scan-assembler-times \"vfnmsub\\[123\\]+ss\" 176 } } */"}, {"sha": "447be12f524a4704fe33d122f9177dc3ccf72eb3", "filename": "gcc/testsuite/gcc.target/i386/l_fma_float_4.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb22e6143e5a2c47bf2006312173c19594c12dc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb22e6143e5a2c47bf2006312173c19594c12dc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_4.c?ref=cbb22e6143e5a2c47bf2006312173c19594c12dc", "patch": "@@ -12,7 +12,7 @@\n /* { dg-final { scan-assembler-times \"vfmsub\\[123\\]+ps\" 8 } } */\n /* { dg-final { scan-assembler-times \"vfnmadd\\[123\\]+ps\" 8 } } */\n /* { dg-final { scan-assembler-times \"vfnmsub\\[123\\]+ps\" 8 } } */\n-/* { dg-final { scan-assembler-times \"vfmadd\\[123\\]+ss\" 184 } } */\n-/* { dg-final { scan-assembler-times \"vfmsub\\[123\\]+ss\" 184 } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd\\[123\\]+ss\" 184 } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub\\[123\\]+ss\" 184 } } */\n+/* { dg-final { scan-assembler-times \"vfmadd\\[123\\]+ss\" 176 } } */\n+/* { dg-final { scan-assembler-times \"vfmsub\\[123\\]+ss\" 176 } } */\n+/* { dg-final { scan-assembler-times \"vfnmadd\\[123\\]+ss\" 176 } } */\n+/* { dg-final { scan-assembler-times \"vfnmsub\\[123\\]+ss\" 176 } } */"}, {"sha": "99a5b969cd4c0024ff47c2d671bfde1f2b5f6be9", "filename": "gcc/testsuite/gcc.target/i386/l_fma_float_5.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb22e6143e5a2c47bf2006312173c19594c12dc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb22e6143e5a2c47bf2006312173c19594c12dc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_5.c?ref=cbb22e6143e5a2c47bf2006312173c19594c12dc", "patch": "@@ -12,7 +12,7 @@\n /* { dg-final { scan-assembler-times \"vfmsub\\[123\\]+ps\" 8 } } */\n /* { dg-final { scan-assembler-times \"vfnmadd\\[123\\]+ps\" 8 } } */\n /* { dg-final { scan-assembler-times \"vfnmsub\\[123\\]+ps\" 8 } } */\n-/* { dg-final { scan-assembler-times \"vfmadd\\[123\\]+ss\" 184 } } */\n-/* { dg-final { scan-assembler-times \"vfmsub\\[123\\]+ss\" 184 } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd\\[123\\]+ss\" 184 } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub\\[123\\]+ss\" 184 } } */\n+/* { dg-final { scan-assembler-times \"vfmadd\\[123\\]+ss\" 176 } } */\n+/* { dg-final { scan-assembler-times \"vfmsub\\[123\\]+ss\" 176 } } */\n+/* { dg-final { scan-assembler-times \"vfnmadd\\[123\\]+ss\" 176 } } */\n+/* { dg-final { scan-assembler-times \"vfnmsub\\[123\\]+ss\" 176 } } */"}, {"sha": "02f4b100111290d7aa57d8b0a8df4ec8640caf82", "filename": "gcc/testsuite/gcc.target/i386/l_fma_float_6.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb22e6143e5a2c47bf2006312173c19594c12dc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb22e6143e5a2c47bf2006312173c19594c12dc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_6.c?ref=cbb22e6143e5a2c47bf2006312173c19594c12dc", "patch": "@@ -12,7 +12,7 @@\n /* { dg-final { scan-assembler-times \"vfmsub\\[123\\]+ps\" 8 } } */\n /* { dg-final { scan-assembler-times \"vfnmadd\\[123\\]+ps\" 8 } } */\n /* { dg-final { scan-assembler-times \"vfnmsub\\[123\\]+ps\" 8 } } */\n-/* { dg-final { scan-assembler-times \"vfmadd\\[123\\]+ss\" 184 } } */\n-/* { dg-final { scan-assembler-times \"vfmsub\\[123\\]+ss\" 184 } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd\\[123\\]+ss\" 184 } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub\\[123\\]+ss\" 184 } } */\n+/* { dg-final { scan-assembler-times \"vfmadd\\[123\\]+ss\" 176 } } */\n+/* { dg-final { scan-assembler-times \"vfmsub\\[123\\]+ss\" 176 } } */\n+/* { dg-final { scan-assembler-times \"vfnmadd\\[123\\]+ss\" 176 } } */\n+/* { dg-final { scan-assembler-times \"vfnmsub\\[123\\]+ss\" 176 } } */"}, {"sha": "6bfd332a1019f7a72365b61a5aba28f4a0b3c47e", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 43, "deletions": 40, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb22e6143e5a2c47bf2006312173c19594c12dc/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb22e6143e5a2c47bf2006312173c19594c12dc/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=cbb22e6143e5a2c47bf2006312173c19594c12dc", "patch": "@@ -904,7 +904,7 @@ vect_update_ivs_after_vectorizer (loop_vec_info loop_vinfo,\n    is the inner type of the vectype)\n \n    The computations will be emitted at the end of BB.  We also compute and\n-   store upper bound of the result in BOUND.\n+   store upper bound (included) of the result in BOUND.\n \n    When the step of the data-ref in the loop is not 1 (as in interleaved data\n    and SLP), the number of iterations of the prolog must be divided by the step\n@@ -941,7 +941,7 @@ vect_gen_prolog_loop_niters (loop_vec_info loop_vinfo,\n                          \"known peeling = %d.\\n\", npeel);\n \n       iters = build_int_cst (niters_type, npeel);\n-      *bound = LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo) + 1;\n+      *bound = LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo);\n     }\n   else\n     {\n@@ -976,7 +976,7 @@ vect_gen_prolog_loop_niters (loop_vec_info loop_vinfo,\n \titers = fold_build2 (MINUS_EXPR, type, nelements_tree, elem_misalign);\n       iters = fold_build2 (BIT_AND_EXPR, type, iters, nelements_minus_1);\n       iters = fold_convert (niters_type, iters);\n-      *bound = nelements;\n+      *bound = nelements - 1;\n     }\n \n   if (dump_enabled_p ())\n@@ -1090,43 +1090,47 @@ vect_build_loop_niters (loop_vec_info loop_vinfo)\n     }\n }\n \n-/* Calculate the number of iterations under which scalar loop will be\n-   preferred than vectorized loop.  NITERS_PROLOG is the number of\n-   iterations of prolog loop.  If it's integer const, the integer\n-   number is also passed by INT_NITERS_PROLOG.  VF is vector factor;\n-   TH is the threshold for vectorized loop if CHECK_PROFITABILITY is\n-   true.  This function also store upper bound of the result in BOUND.  */\n+/* Calculate the number of iterations above which vectorized loop will be\n+   preferred than scalar loop.  NITERS_PROLOG is the number of iterations\n+   of prolog loop.  If it's integer const, the integer number is also passed\n+   in INT_NITERS_PROLOG.  BOUND_PROLOG is the upper bound (included) of\n+   number of iterations of prolog loop.  VFM1 is vector factor minus one.\n+   If CHECK_PROFITABILITY is true, TH is the threshold below which scalar\n+   (rather than vectorized) loop will be executed.  This function stores\n+   upper bound (included) of the result in BOUND_SCALAR.  */\n \n static tree\n vect_gen_scalar_loop_niters (tree niters_prolog, int int_niters_prolog,\n-\t\t\t     int bound_prolog, int vf, int th, int *bound,\n-\t\t\t     bool check_profitability)\n+\t\t\t     int bound_prolog, int vfm1, int th,\n+\t\t\t     int *bound_scalar, bool check_profitability)\n {\n   tree type = TREE_TYPE (niters_prolog);\n   tree niters = fold_build2 (PLUS_EXPR, type, niters_prolog,\n-\t\t\t     build_int_cst (type, vf));\n+\t\t\t     build_int_cst (type, vfm1));\n \n-  *bound = vf + bound_prolog;\n+  *bound_scalar = vfm1 + bound_prolog;\n   if (check_profitability)\n     {\n-      th++;\n+      /* TH indicates the minimum niters of vectorized loop, while we\n+\t compute the maximum niters of scalar loop.  */\n+      th--;\n       /* Peeling for constant times.  */\n       if (int_niters_prolog >= 0)\n \t{\n-\t  *bound = (int_niters_prolog + vf < th\n-\t\t\t\t\t   ? th\n-\t\t\t\t\t   : vf + int_niters_prolog);\n-\t  return build_int_cst (type, *bound);\n+\t  *bound_scalar = (int_niters_prolog + vfm1 < th\n+\t\t\t    ? th\n+\t\t\t    : vfm1 + int_niters_prolog);\n+\t  return build_int_cst (type, *bound_scalar);\n \t}\n-      /* Peeling for unknown times, in this case, prolog loop must\n-\t execute less than bound_prolog times.  */\n-      if (th >=  vf + bound_prolog - 1)\n+      /* Peeling for unknown times.  Note BOUND_PROLOG is the upper\n+\t bound (inlcuded) of niters of prolog loop.  */\n+      if (th >=  vfm1 + bound_prolog)\n \t{\n-\t  *bound = th;\n+\t  *bound_scalar = th;\n \t  return build_int_cst (type, th);\n \t}\n-      /* Need to do runtime comparison, but bound remains the same.  */\n-      else if (th > vf)\n+      /* Need to do runtime comparison, but BOUND_SCALAR remains the same.  */\n+      else if (th > vfm1)\n \treturn fold_build2 (MAX_EXPR, type, build_int_cst (type, th), niters);\n     }\n   return niters;\n@@ -1620,7 +1624,7 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n   tree type = TREE_TYPE (niters), guard_cond;\n   basic_block guard_bb, guard_to;\n   int prob_prolog, prob_vector, prob_epilog;\n-  int bound_prolog = 0, bound_epilog = 0, bound = 0;\n+  int bound_prolog = 0, bound_scalar = 0, bound = 0;\n   int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n   int prolog_peeling = LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo);\n   bool epilog_peeling = (LOOP_VINFO_PEELING_FOR_NITER (loop_vinfo)\n@@ -1721,9 +1725,9 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n \t\t       LOOP_VINFO_NITERSM1 (loop_vinfo), niters_prolog);\n       niters = vect_build_loop_niters (loop_vinfo);\n \n-      /* Prolog iterates at most bound_prolog - 1 times, latch iterates\n-\t at most bound_prolog - 2 times.  */\n-      record_niter_bound (prolog, bound_prolog - 2, false, true);\n+      /* Prolog iterates at most bound_prolog times, latch iterates at\n+\t most bound_prolog - 1 times.  */\n+      record_niter_bound (prolog, bound_prolog - 1, false, true);\n       delete_update_ssa ();\n       adjust_vec_debug_stmts ();\n       scev_reset ();\n@@ -1754,16 +1758,15 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n \t won't be vectorized.  */\n       if (skip_vector)\n \t{\n-\t  /* Guard_cond needs is based on NITERSM1 because NITERS might\n-\t     overflow, so here it is niters_scalar - 1 generated.  In\n-\t     other words, both niters_scalar and bound_epilog are for\n-\t     scalar loop's latch.  */\n+\t  /* Additional epilogue iteration is peeled if gap exists.  */\n+\t  bool peel_for_gaps = LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo);\n \t  tree t = vect_gen_scalar_loop_niters (niters_prolog, prolog_peeling,\n-\t\t\t\t\t\tbound_prolog, vf - 1, th - 1,\n-\t\t\t\t\t\t&bound_epilog,\n+\t\t\t\t\t\tbound_prolog,\n+\t\t\t\t\t\tpeel_for_gaps ? vf : vf - 1,\n+\t\t\t\t\t\tth, &bound_scalar,\n \t\t\t\t\t\tcheck_profitability);\n-\t  guard_cond = fold_build2 (LT_EXPR, boolean_type_node,\n-\t\t\t\t    nitersm1, t);\n+\t  /* Build guard against NITERSM1 since NITERS may overflow.  */\n+\t  guard_cond = fold_build2 (LT_EXPR, boolean_type_node, nitersm1, t);\n \t  guard_bb = anchor;\n \t  guard_to = split_edge (loop_preheader_edge (epilog));\n \t  guard_e = slpeel_add_loop_guard (guard_bb, guard_cond,\n@@ -1772,7 +1775,7 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n \t  e = EDGE_PRED (guard_to, 0);\n \t  e = (e != guard_e ? e : EDGE_PRED (guard_to, 1));\n \t  slpeel_update_phi_nodes_for_guard1 (first_loop, epilog, guard_e, e);\n-\t  scale_loop_profile (epilog, prob_vector, bound_epilog);\n+\t  scale_loop_profile (epilog, prob_vector, bound_scalar);\n \t}\n \n       tree niters_vector_mult_vf;\n@@ -1807,10 +1810,10 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n       else\n \tslpeel_update_phi_nodes_for_lcssa (epilog);\n \n-      bound = (LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo) ? vf * 2 : vf) - 2;\n+      bound = LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo) ? vf - 1 : vf - 2;\n       /* We share epilog loop with scalar version loop.  */\n-      bound_epilog = MAX (bound, bound_epilog - 1);\n-      record_niter_bound (epilog, bound_epilog, false, true);\n+      bound = MAX (bound, bound_scalar - 1);\n+      record_niter_bound (epilog, bound, false, true);\n \n       delete_update_ssa ();\n       adjust_vec_debug_stmts ();"}]}