{"sha": "2a238a974bdff827ac0d0928ca9fe10ff59e683a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmEyMzhhOTc0YmRmZjgyN2FjMGQwOTI4Y2E5ZmUxMGZmNTllNjgzYQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-06-12T09:47:04Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-06-12T09:47:04Z"}, "message": "class.c (instantiate_type): Don't treat template-ids that don't specify any template arguments as...\n\n\t* class.c (instantiate_type): Don't treat template-ids that don't\n\tspecify any template arguments as equivalent to ordinary\n\tidentifiers.  Use OFFSET_REF instead of SCOPE_REF to refer to\n\tpointer-to-members for member templates.  Tidy slightly.\n\t* cp-tree.def (TEMPLATE_ID_EXPR): Revise documentation.\n\t* init.c (build_offset_ref): Handle template-ids like ordinary\n\tidentifiers, for the most part, but store a TEMPLATE_ID_EXPR in the\n\toffset part of the OFFSET_REF.\n\t* typeck.c (build_unary_op): Change check for unknown types to\n\tlook for OFFSET_REFs, not SCOPE_REFs.\n\nFrom-SVN: r20442", "tree": {"sha": "e7672496825b85cd9dad0dd7a5fe954b17903b9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e7672496825b85cd9dad0dd7a5fe954b17903b9d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a238a974bdff827ac0d0928ca9fe10ff59e683a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a238a974bdff827ac0d0928ca9fe10ff59e683a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a238a974bdff827ac0d0928ca9fe10ff59e683a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a238a974bdff827ac0d0928ca9fe10ff59e683a/comments", "author": null, "committer": null, "parents": [{"sha": "77a45a2ea44010cabd700d777ac8b3557021bafa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77a45a2ea44010cabd700d777ac8b3557021bafa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77a45a2ea44010cabd700d777ac8b3557021bafa"}], "stats": {"total": 146, "additions": 94, "deletions": 52}, "files": [{"sha": "aced36520885a1cd92fa4e43773fdcb7a6e68bd2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a238a974bdff827ac0d0928ca9fe10ff59e683a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a238a974bdff827ac0d0928ca9fe10ff59e683a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2a238a974bdff827ac0d0928ca9fe10ff59e683a", "patch": "@@ -1,3 +1,16 @@\n+1998-06-12  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* class.c (instantiate_type): Don't treat template-ids that don't\n+\tspecify any template arguments as equivalent to ordinary\n+\tidentifiers.  Use OFFSET_REF instead of SCOPE_REF to refer to\n+\tpointer-to-members for member templates.  Tidy slightly.\n+\t* cp-tree.def (TEMPLATE_ID_EXPR): Revise documentation.\n+\t* init.c (build_offset_ref): Handle template-ids like ordinary\n+\tidentifiers, for the most part, but store a TEMPLATE_ID_EXPR in the\n+\toffset part of the OFFSET_REF.\n+\t* typeck.c (build_unary_op): Change check for unknown types to\n+\tlook for OFFSET_REFs, not SCOPE_REFs.\n+\n 1998-06-11  Mark Mitchell  <mark@markmitchell.com>\n \n \t* pt.c (is_member_template_class): New function."}, {"sha": "6e3942f0ee8891df1b0aecbc9f1de617237248e1", "filename": "gcc/cp/class.c", "status": "modified", "additions": 39, "deletions": 44, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a238a974bdff827ac0d0928ca9fe10ff59e683a/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a238a974bdff827ac0d0928ca9fe10ff59e683a/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=2a238a974bdff827ac0d0928ca9fe10ff59e683a", "patch": "@@ -4961,6 +4961,7 @@ instantiate_type (lhstype, rhs, complain)\n      int complain;\n {\n   tree explicit_targs = NULL_TREE;\n+  int template_only = 0;\n \n   if (TREE_CODE (lhstype) == UNKNOWN_TYPE)\n     {\n@@ -5090,69 +5091,61 @@ instantiate_type (lhstype, rhs, complain)\n \treturn rhs;\n       }\n \n-    case SCOPE_REF:\n-      {\n-\t/* This can happen if we are forming a pointer-to-member for a\n-\t   member template.  */\n-\ttree template_id_expr = TREE_OPERAND (rhs, 1);\n-\ttree name;\n-\tmy_friendly_assert (TREE_CODE (template_id_expr) == TEMPLATE_ID_EXPR,\n-\t\t\t    0);\n-\texplicit_targs = TREE_OPERAND (template_id_expr, 1);\n-\tname = TREE_OPERAND (template_id_expr, 0);\n-\tmy_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE, 0);\n-\trhs = lookup_fnfields (TYPE_BINFO (TREE_OPERAND (rhs, 0)), name, 1);\n-\tgoto overload;\n-      }\n+    case OFFSET_REF:\n+      /* This can happen if we are forming a pointer-to-member for a\n+\t member template.  */\n+      rhs = TREE_OPERAND (rhs, 1);\n+      my_friendly_assert (TREE_CODE (rhs) == TEMPLATE_ID_EXPR, 0);\n+\t\n+      /* Fall through.  */\n \n     case TEMPLATE_ID_EXPR:\n       {\n \texplicit_targs = TREE_OPERAND (rhs, 1);\n+\ttemplate_only = 1;\n \trhs = TREE_OPERAND (rhs, 0);\n       }\n       /* fall through */\n       my_friendly_assert (TREE_CODE (rhs) == OVERLOAD, 980401);\n \n     case OVERLOAD:\n-    overload:\n       {\n \ttree elem, elems;\n \n-\t/* First look for an exact match.  Search overloaded\n-\t   functions.  May have to undo what `default_conversion'\n-\t   might do to lhstype.  */\n-\n+\t/* Check that the LHSTYPE and the RHS are reasonable.  */\n \tlhstype = validate_lhs (lhstype, complain);\n \tif (lhstype == error_mark_node)\n \t  return lhstype;\n \n \tif (TREE_CODE (lhstype) != FUNCTION_TYPE\n \t    && TREE_CODE (lhstype) != METHOD_TYPE)\n \t  {\n-\t    rhs = DECL_NAME (OVL_FUNCTION (rhs));\n \t    if (complain)\n \t      cp_error(\"cannot resolve overloaded function `%D' \" \n-\t\t       \"based on non-function type\", rhs);\n+\t\t       \"based on non-function type\", \n+\t\t       DECL_NAME (OVL_FUNCTION (rhs)));\n \t    return error_mark_node;\n \t  }\n \t\n-\telems = rhs;\n-\t/* If there are explicit_targs, only a template function\n-\t   can match.  */\n-\tif (explicit_targs == NULL_TREE)\n-\t  while (elems)\n-\t    {\n-\t      elem = OVL_FUNCTION (elems);\n-\t      if (! comptypes (lhstype, TREE_TYPE (elem), 1))\n-\t\telems = OVL_CHAIN (elems);\n-\t      else\n-\t\t{\n-\t\t  mark_used (elem);\n-\t\t  return elem;\n-\t\t}\n-\t    }\n+\t/* Look for an exact match, by searching through the\n+\t   overloaded functions.  */\n+\tif (template_only)\n+\t  /* If we're processing a template-id, only a template\n+\t     function can match, so we don't look through the\n+\t     overloaded functions.  */\n+\t  ;\n+\telse for (elems = rhs; elems; elems = OVL_CHAIN (elems))\n+\t  {\n+\t    elem = OVL_FUNCTION (elems);\n+\t    if (comptypes (lhstype, TREE_TYPE (elem), 1))\n+\t      {\n+\t\tmark_used (elem);\n+\t\treturn elem;\n+\t      }\n+\t  }\n \n-\t/* No exact match found, look for a compatible template.  */\n+\t/* No overloaded function was an exact match.  See if we can\n+\t   instantiate some template to match.  */\n \t{\n \t  tree save_elem = 0;\n \t  elems = rhs;\n@@ -5189,14 +5182,14 @@ instantiate_type (lhstype, rhs, complain)\n \t    }\n \t}\n \n-\t/* If there are explicit_targs, only a template function\n-\t   can match.  */\n-\tif (explicit_targs == NULL_TREE) \n+\t/* There's no exact match, and no templates can be\n+\t   instantiated to match.  The last thing we try is to see if\n+\t   some ordinary overloaded function is close enough.  If\n+\t   we're only looking for template functions, we don't do\n+\t   this.  */\n+\tif (!template_only)\n \t  {\n-\t    /* No match found, look for a compatible function.  */\n-\t    tree elems = rhs;\n-\t    elems = rhs;\n-\t    for (; elems; elems = OVL_NEXT (elems))\n+\t    for (elems = rhs; elems; elems = OVL_NEXT (elems))\n \t      {\n \t\telem = OVL_CURRENT (elems);\n \t\tif (comp_target_types (lhstype, TREE_TYPE (elem), 1) > 0)\n@@ -5228,6 +5221,8 @@ instantiate_type (lhstype, rhs, complain)\n \t\treturn save_elem;\n \t      }\n \t  }\n+\n+\t/* We failed to find a match.  */\n \tif (complain)\n \t  {\n \t    cp_error (\"cannot resolve overload to target type `%#T'\", lhstype);"}, {"sha": "dbbdb6603d08955dc39972d9553b13c30a725550", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a238a974bdff827ac0d0928ca9fe10ff59e683a/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a238a974bdff827ac0d0928ca9fe10ff59e683a/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=2a238a974bdff827ac0d0928ca9fe10ff59e683a", "patch": "@@ -163,7 +163,7 @@ DEFTREECODE (DEFAULT_ARG, \"default_arg\", 'c', 2)\n    template will be a FUNCTION_DECL, TEMPLATE_DECL, or a list of\n    overloaded functions and templates if the template-id refers to\n    a global template.  If the template-id refers to a member template,\n-   the template will be an IDENTIFIER_NODE.  */\n+   the template may be an IDENTIFIER_NODE.  */\n DEFTREECODE (TEMPLATE_ID_EXPR, \"template_id_expr\", 'e', 2)\n \n /* An association between namespace and entity. Parameters are the"}, {"sha": "cf6378b86ca815a5c0ea0dc443f0d773b803c188", "filename": "gcc/cp/init.c", "status": "modified", "additions": 35, "deletions": 3, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a238a974bdff827ac0d0928ca9fe10ff59e683a/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a238a974bdff827ac0d0928ca9fe10ff59e683a/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=2a238a974bdff827ac0d0928ca9fe10ff59e683a", "patch": "@@ -1522,6 +1522,7 @@ build_offset_ref (type, name)\n   tree decl, fnfields, fields, t = error_mark_node;\n   tree basebinfo = NULL_TREE;\n   int dtor = 0;\n+  tree orig_name = name;\n \n   /* class templates can come in as TEMPLATE_DECLs here.  */\n   if (TREE_CODE (name) == TEMPLATE_DECL)\n@@ -1532,8 +1533,6 @@ build_offset_ref (type, name)\n \n   if (processing_template_decl || uses_template_parms (type))\n     return build_min_nt (SCOPE_REF, type, name);\n-  else if (TREE_CODE (name) == TEMPLATE_ID_EXPR)\n-    return build (SCOPE_REF, unknown_type_node, type, name);\n \n   /* Handle namespace names fully here.  */\n   if (TREE_CODE (type) == NAMESPACE_DECL)\n@@ -1542,6 +1541,16 @@ build_offset_ref (type, name)\n   if (type == NULL_TREE || ! is_aggr_type (type, 1))\n     return error_mark_node;\n \n+  if (TREE_CODE (name) == TEMPLATE_ID_EXPR)\n+    {\n+      /* If the NAME is a TEMPLATE_ID_EXPR, we are looking at\n+\t something like `a.template f<int>' or the like.  For the most\n+\t part, we treat this just like a.f.  We do remember, however,\n+\t the template-id that was used.  */\n+      name = TREE_OPERAND (orig_name, 0);\n+      my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE, 0);\n+    }\n+\n   if (TREE_CODE (name) == BIT_NOT_EXPR)\n     {\n       dtor = 1;\n@@ -1612,11 +1621,33 @@ build_offset_ref (type, name)\n   if (fnfields)\n     {\n       extern int flag_save_memoized_contexts;\n-      basebinfo = TREE_PURPOSE (fnfields);\n \n       /* Go from the TREE_BASELINK to the member function info.  */\n       t = TREE_VALUE (fnfields);\n \n+      if (TREE_CODE (orig_name) == TEMPLATE_ID_EXPR)\n+\t{\n+\t  /* The FNFIELDS are going to contain functions that aren't\n+\t     necessarily templates, and templates that don't\n+\t     necessarily match the explicit template parameters.  We\n+\t     save all the functions, and the explicit parameters, and\n+\t     then figure out exactly what to instantiate with what\n+\t     arguments in instantiate_type.  */\n+\n+\t  if (TREE_CODE (t) != OVERLOAD)\n+\t    /* The code in instantiate_type which will process this\n+\t       expects to encounter OVERLOADs, not raw functions.  */\n+\t    t = ovl_cons (t, NULL_TREE);\n+\t  \n+\t  return build (OFFSET_REF, \n+\t\t\tbuild_offset_type (type, unknown_type_node),\n+\t\t\tdecl,\n+\t\t\tbuild (TEMPLATE_ID_EXPR, \n+\t\t\t       TREE_TYPE (t),\n+\t\t\t       t,\n+\t\t\t       TREE_OPERAND (orig_name, 1)));\n+\t}\n+\n       if (!really_overloaded_fn (t))\n \t{\n \t  tree access;\n@@ -1625,6 +1656,7 @@ build_offset_ref (type, name)\n \t  t = OVL_CURRENT (t);\n \n \t  /* unique functions are handled easily.  */\n+\t  basebinfo = TREE_PURPOSE (fnfields);\n \t  access = compute_access (basebinfo, t);\n \t  if (access == access_protected_node)\n \t    {"}, {"sha": "4b2e587c724c99ce3e96efe170d6061ab3d875db", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a238a974bdff827ac0d0928ca9fe10ff59e683a/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a238a974bdff827ac0d0928ca9fe10ff59e683a/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=2a238a974bdff827ac0d0928ca9fe10ff59e683a", "patch": "@@ -4527,7 +4527,7 @@ build_unary_op (code, xarg, noconvert)\n \t}\n \n       if (TREE_CODE (arg) == OVERLOAD \n-\t  || (TREE_CODE (arg) == SCOPE_REF \n+\t  || (TREE_CODE (arg) == OFFSET_REF\n \t      && TREE_CODE (TREE_OPERAND (arg, 1)) == TEMPLATE_ID_EXPR))\n \treturn build1 (ADDR_EXPR, unknown_type_node, arg);\n       else if (TREE_CODE (arg) == TREE_LIST)"}, {"sha": "e14c726c1d7241ddf17b0e32ea575ce52e2376fd", "filename": "gcc/testsuite/g++.old-deja/g++.pt/ptrmem1.C", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a238a974bdff827ac0d0928ca9fe10ff59e683a/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fptrmem1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a238a974bdff827ac0d0928ca9fe10ff59e683a/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fptrmem1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fptrmem1.C?ref=2a238a974bdff827ac0d0928ca9fe10ff59e683a", "patch": "@@ -1,10 +1,8 @@\n-// Build don't run:\n-\n class foo\n {\n public:\n   template<class T>\n-  T bar() {}\n+  T bar() { return 7; }\n };\n \n int\n@@ -13,4 +11,8 @@ main()\n   foo f;\n   \n   int (foo::*s)() = &foo::template bar<int>;\n+  if ((f.*s)() == 7)\n+    return 0;\n+  else \n+    return 1;\n }"}]}