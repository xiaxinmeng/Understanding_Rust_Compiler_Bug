{"sha": "e28f2090dbbb50728e9c0933df59e1788307f59b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTI4ZjIwOTBkYmJiNTA3MjhlOWMwOTMzZGY1OWUxNzg4MzA3ZjU5Yg==", "commit": {"author": {"name": "Yury Gribov", "email": "y.gribov@samsung.com", "date": "2014-12-03T09:23:28Z"}, "committer": {"name": "Yury Gribov", "email": "ygribov@gcc.gnu.org", "date": "2014-12-03T09:23:28Z"}, "message": "Improve optimization of ASan checks.\n\n2014-12-03  Yury Gribov  <y.gribov@samsung.com>\n\ngcc/\n\t* sanopt.c (maybe_get_single_definition): New function.\n\t(maybe_get_dominating_check): Ditto.\n\t(can_remove_asan_check): Ditto.\n\t(struct tree_map_traits): New struct.\n\t(struct sanopt_ctx): Use custom traits for asan_check_map.\n\t(maybe_optimize_ubsan_null_ifn): Move code to\n\tmaybe_get_dominating_check.\n\t(maybe_optimize_asan_check_ifn): Move code and take non-SSA expressions\n\tinto account when optimizing.\n\t(sanopt_optimize_walker): Optimize ASan checks even when\n\trecovering.\n\nFrom-SVN: r218304", "tree": {"sha": "1c2d2b5bc2b0c7ac4b2506c7c626622a96199bd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c2d2b5bc2b0c7ac4b2506c7c626622a96199bd0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e28f2090dbbb50728e9c0933df59e1788307f59b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e28f2090dbbb50728e9c0933df59e1788307f59b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e28f2090dbbb50728e9c0933df59e1788307f59b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e28f2090dbbb50728e9c0933df59e1788307f59b/comments", "author": null, "committer": null, "parents": [{"sha": "45392c76508048665ea5ad3269b59894724d5cb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45392c76508048665ea5ad3269b59894724d5cb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45392c76508048665ea5ad3269b59894724d5cb5"}], "stats": {"total": 247, "additions": 156, "deletions": 91}, "files": [{"sha": "fb97618b3ba3a80eccbab1c0117a9d98a5d5b060", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28f2090dbbb50728e9c0933df59e1788307f59b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28f2090dbbb50728e9c0933df59e1788307f59b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e28f2090dbbb50728e9c0933df59e1788307f59b", "patch": "@@ -1,3 +1,17 @@\n+2014-12-03  Yury Gribov  <y.gribov@samsung.com>\n+\n+\t* sanopt.c (maybe_get_single_definition): New function.\n+\t(maybe_get_dominating_check): Ditto.\n+\t(can_remove_asan_check): Ditto.\n+\t(struct tree_map_traits): New struct.\n+\t(struct sanopt_ctx): Use custom traits for asan_check_map.\n+\t(maybe_optimize_ubsan_null_ifn): Move code to\n+\tmaybe_get_dominating_check.\n+\t(maybe_optimize_asan_check_ifn): Move code and take non-SSA expressions\n+\tinto account when optimizing.\n+\t(sanopt_optimize_walker): Optimize ASan checks even when\n+\trecovering.\n+\n 2014-12-03  Ilya Enkovich  <ilya.enkovich@intel.com>\n \n \t* config/i386/constraints.md (Yr): New."}, {"sha": "e0d3a8562b37b9ca3f5ea5980342520167f6d908", "filename": "gcc/sanopt.c", "status": "modified", "additions": 142, "deletions": 91, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28f2090dbbb50728e9c0933df59e1788307f59b/gcc%2Fsanopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28f2090dbbb50728e9c0933df59e1788307f59b/gcc%2Fsanopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsanopt.c?ref=e28f2090dbbb50728e9c0933df59e1788307f59b", "patch": "@@ -84,6 +84,35 @@ struct sanopt_info\n   bool visited_p;\n };\n \n+/* If T has a single definition of form T = T2, return T2.  */\n+\n+static tree\n+maybe_get_single_definition (tree t)\n+{\n+  if (TREE_CODE (t) == SSA_NAME)\n+    {\n+      gimple g = SSA_NAME_DEF_STMT (t);\n+      if (gimple_assign_single_p (g))\n+\treturn gimple_assign_rhs1 (g);\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Traits class for tree hash maps below.  */\n+\n+struct tree_map_traits : default_hashmap_traits\n+{\n+  static inline hashval_t hash (const_tree ref)\n+  {\n+    return iterative_hash_expr (ref, 0);\n+  }\n+\n+  static inline bool equal_keys (const_tree ref1, const_tree ref2)\n+  {\n+    return operand_equal_p (ref1, ref2, 0);\n+  }\n+}; \n+\n /* This is used to carry various hash maps and variables used\n    in sanopt_optimize_walker.  */\n \n@@ -95,7 +124,7 @@ struct sanopt_ctx\n \n   /* This map maps a pointer (the second argument of ASAN_CHECK) to\n      a vector of ASAN_CHECK call statements that check the access.  */\n-  hash_map<tree, auto_vec<gimple> > asan_check_map;\n+  hash_map<tree, auto_vec<gimple>, tree_map_traits> asan_check_map;\n \n   /* Number of IFN_ASAN_CHECK statements.  */\n   int asan_num_accesses;\n@@ -197,6 +226,24 @@ imm_dom_path_with_freeing_call (basic_block bb, basic_block dom)\n   return false;\n }\n \n+/* Get the first dominating check from the list of stored checks.\n+   Non-dominating checks are silently dropped.  */\n+\n+static gimple\n+maybe_get_dominating_check (auto_vec<gimple> &v)\n+{\n+  for (; !v.is_empty (); v.pop ())\n+    {\n+      gimple g = v.last ();\n+      sanopt_info *si = (sanopt_info *) gimple_bb (g)->aux;\n+      if (!si->visited_p)\n+\t/* At this point we shouldn't have any statements\n+\t   that aren't dominating the current BB.  */\n+\treturn g;\n+    }\n+  return NULL;\n+}\n+\n /* Optimize away redundant UBSAN_NULL calls.  */\n \n static bool\n@@ -209,7 +256,8 @@ maybe_optimize_ubsan_null_ifn (struct sanopt_ctx *ctx, gimple stmt)\n   bool remove = false;\n \n   auto_vec<gimple> &v = ctx->null_check_map.get_or_insert (ptr);\n-  if (v.is_empty ())\n+  gimple g = maybe_get_dominating_check (v);\n+  if (!g)\n     {\n       /* For this PTR we don't have any UBSAN_NULL stmts recorded, so there's\n \t nothing to optimize yet.  */\n@@ -220,90 +268,42 @@ maybe_optimize_ubsan_null_ifn (struct sanopt_ctx *ctx, gimple stmt)\n   /* We already have recorded a UBSAN_NULL check for this pointer. Perhaps we\n      can drop this one.  But only if this check doesn't specify stricter\n      alignment.  */\n-  while (!v.is_empty ())\n-    {\n-      gimple g = v.last ();\n-      /* Remove statements for BBs that have been already processed.  */\n-      sanopt_info *si = (sanopt_info *) gimple_bb (g)->aux;\n-      if (si->visited_p)\n-\t{\n-\t  v.pop ();\n-\t  continue;\n-\t}\n \n-      /* At this point we shouldn't have any statements that aren't dominating\n-\t the current BB.  */\n-      tree align = gimple_call_arg (g, 2);\n-      int kind = tree_to_shwi (gimple_call_arg (g, 1));\n-      /* If this is a NULL pointer check where we had segv anyway, we can\n-\t remove it.  */\n-      if (integer_zerop (align)\n-\t  && (kind == UBSAN_LOAD_OF\n-\t      || kind == UBSAN_STORE_OF\n-\t      || kind == UBSAN_MEMBER_ACCESS))\n-\tremove = true;\n-      /* Otherwise remove the check in non-recovering mode, or if the\n-\t stmts have same location.  */\n-      else if (integer_zerop (align))\n-\tremove = (flag_sanitize_recover & SANITIZE_NULL) == 0\n-\t\t || flag_sanitize_undefined_trap_on_error\n-\t\t || gimple_location (g) == gimple_location (stmt);\n-      else if (tree_int_cst_le (cur_align, align))\n-\tremove = (flag_sanitize_recover & SANITIZE_ALIGNMENT) == 0\n-\t\t || flag_sanitize_undefined_trap_on_error\n-\t\t || gimple_location (g) == gimple_location (stmt);\n-      if (!remove && gimple_bb (g) == gimple_bb (stmt)\n-\t  && tree_int_cst_compare (cur_align, align) == 0)\n-\tv.pop ();\n-      break;\n-    }\n+  tree align = gimple_call_arg (g, 2);\n+  int kind = tree_to_shwi (gimple_call_arg (g, 1));\n+  /* If this is a NULL pointer check where we had segv anyway, we can\n+     remove it.  */\n+  if (integer_zerop (align)\n+      && (kind == UBSAN_LOAD_OF\n+\t  || kind == UBSAN_STORE_OF\n+\t  || kind == UBSAN_MEMBER_ACCESS))\n+    remove = true;\n+  /* Otherwise remove the check in non-recovering mode, or if the\n+     stmts have same location.  */\n+  else if (integer_zerop (align))\n+    remove = (flag_sanitize_recover & SANITIZE_NULL) == 0\n+\t      || flag_sanitize_undefined_trap_on_error\n+\t      || gimple_location (g) == gimple_location (stmt);\n+  else if (tree_int_cst_le (cur_align, align))\n+    remove = (flag_sanitize_recover & SANITIZE_ALIGNMENT) == 0\n+\t      || flag_sanitize_undefined_trap_on_error\n+\t      || gimple_location (g) == gimple_location (stmt);\n+\n+  if (!remove && gimple_bb (g) == gimple_bb (stmt)\n+      && tree_int_cst_compare (cur_align, align) == 0)\n+    v.pop ();\n \n   if (!remove)\n     v.safe_push (stmt);\n   return remove;\n }\n \n-/* Optimize away redundant ASAN_CHECK calls.  */\n+/* Returns TRUE if ASan check of length LEN in block BB can be removed\n+   if preceded by checks in V.  */\n \n static bool\n-maybe_optimize_asan_check_ifn (struct sanopt_ctx *ctx, gimple stmt)\n+can_remove_asan_check (auto_vec<gimple> &v, tree len, basic_block bb)\n {\n-  gcc_assert (gimple_call_num_args (stmt) == 4);\n-  tree ptr = gimple_call_arg (stmt, 1);\n-  tree len = gimple_call_arg (stmt, 2);\n-  basic_block bb = gimple_bb (stmt);\n-  sanopt_info *info = (sanopt_info *) bb->aux;\n-\n-  if (TREE_CODE (len) != INTEGER_CST)\n-    return false;\n-  if (integer_zerop (len))\n-    return false;\n-\n-  gimple_set_uid (stmt, info->freeing_call_events);\n-\n-  auto_vec<gimple> &v = ctx->asan_check_map.get_or_insert (ptr);\n-  if (v.is_empty ())\n-    {\n-      /* For this PTR we don't have any ASAN_CHECK stmts recorded, so there's\n-\t nothing to optimize yet.  */\n-      v.safe_push (stmt);\n-      return false;\n-    }\n-\n-  /* We already have recorded a ASAN_CHECK check for this pointer.  Perhaps\n-     we can drop this one.  But only if this check doesn't specify larger\n-     size.  */\n-  while (!v.is_empty ())\n-    {\n-      gimple g = v.last ();\n-      /* Remove statements for BBs that have been already processed.  */\n-      sanopt_info *si = (sanopt_info *) gimple_bb (g)->aux;\n-      if (si->visited_p)\n-\tv.pop ();\n-      else\n-\tbreak;\n-    }\n-\n   unsigned int i;\n   gimple g;\n   gimple to_pop = NULL;\n@@ -323,17 +323,9 @@ maybe_optimize_asan_check_ifn (struct sanopt_ctx *ctx, gimple stmt)\n \t  continue;\n \t}\n \n-      if (TREE_CODE (len) != INTEGER_CST)\n-\t{\n-\t  /* If there is some stmts not followed by freeing call event\n-\t     for ptr already in the current bb, no need to insert anything.\n-\t     Non-constant len is treated just as length 1.  */\n-\t  if (gbb == bb)\n-\t    return false;\n-\t  break;\n-\t}\n-\n       tree glen = gimple_call_arg (g, 2);\n+      gcc_assert (TREE_CODE (glen) == INTEGER_CST);\n+\n       /* If we've checked only smaller length than we want to check now,\n \t we can't remove the current stmt.  If g is in the same basic block,\n \t we want to remove it though, as the current stmt is better.  */\n@@ -383,8 +375,70 @@ maybe_optimize_asan_check_ifn (struct sanopt_ctx *ctx, gimple stmt)\n       v.truncate (j);\n     }\n \n+  return remove;\n+}\n+\n+/* Optimize away redundant ASAN_CHECK calls.  */\n+\n+static bool\n+maybe_optimize_asan_check_ifn (struct sanopt_ctx *ctx, gimple stmt)\n+{\n+  gcc_assert (gimple_call_num_args (stmt) == 4);\n+  tree ptr = gimple_call_arg (stmt, 1);\n+  tree len = gimple_call_arg (stmt, 2);\n+  basic_block bb = gimple_bb (stmt);\n+  sanopt_info *info = (sanopt_info *) bb->aux;\n+\n+  if (TREE_CODE (len) != INTEGER_CST)\n+    return false;\n+  if (integer_zerop (len))\n+    return false;\n+\n+  gimple_set_uid (stmt, info->freeing_call_events);\n+\n+  auto_vec<gimple> *ptr_checks = &ctx->asan_check_map.get_or_insert (ptr);\n+\n+  tree base_addr = maybe_get_single_definition (ptr);\n+  auto_vec<gimple> *base_checks = NULL;\n+  if (base_addr)\n+    {\n+      base_checks = &ctx->asan_check_map.get_or_insert (base_addr);\n+      /* Original pointer might have been invalidated.  */\n+      ptr_checks = ctx->asan_check_map.get (ptr);\n+    }\n+\n+  gimple g = maybe_get_dominating_check (*ptr_checks);\n+\n+  if (!g && base_checks)\n+    /* Try with base address as well.  */\n+    g = maybe_get_dominating_check (*base_checks);\n+\n+  if (!g)\n+    {\n+      /* For this PTR we don't have any ASAN_CHECK stmts recorded, so there's\n+\t nothing to optimize yet.  */\n+      ptr_checks->safe_push (stmt);\n+      if (base_checks)\n+\tbase_checks->safe_push (stmt);\n+      return false;\n+    }\n+\n+  bool remove = false;\n+\n+  if (ptr_checks)\n+    remove = can_remove_asan_check (*ptr_checks, len, bb);\n+\n+  if (!remove && base_checks)\n+    /* Try with base address as well.  */\n+    remove = can_remove_asan_check (*base_checks, len, bb);\n+\n   if (!remove)\n-    v.safe_push (stmt);\n+    {\n+      ptr_checks->safe_push (stmt);\n+      if (base_checks)\n+\tbase_checks->safe_push (stmt);\n+    }\n+\n   return remove;\n }\n \n@@ -404,10 +458,7 @@ sanopt_optimize_walker (basic_block bb, struct sanopt_ctx *ctx)\n   basic_block son;\n   gimple_stmt_iterator gsi;\n   sanopt_info *info = (sanopt_info *) bb->aux;\n-  bool asan_check_optimize\n-    = (flag_sanitize & SANITIZE_ADDRESS)\n-      && ((flag_sanitize & flag_sanitize_recover\n-\t   & SANITIZE_KERNEL_ADDRESS) == 0);\n+  bool asan_check_optimize = (flag_sanitize & SANITIZE_ADDRESS) != 0;\n \n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi);)\n     {"}]}