{"sha": "61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjFmMGNjZmZhMzZmOTZmYzFhMWYyMGZkOGQ0ZWMyYmZiOTExMTQwZA==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2004-05-15T12:41:35Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2004-05-15T12:41:35Z"}, "message": "arm.h (TARGET_APCS_32): Delete.\n\n* arm.h (TARGET_APCS_32): Delete.\n(TARGET_MMU_TRAPS): Delete.\n(TARGET_CPU_CPP_BUILTINS): Unconditionally define __APCS_32__.  Never\ndefine __APCS_26__.\n(CPP_SPEC): Remove checking of -mapcs-{26,32}.\n(ARM_FLAG_APCS_32, ARM_FLAG_MMU_TRAPS): Delete.\n(TARGET_SWITCHES): Remove alignment_traps and apcs-{26,32} switches.\n(prog_mode_type): Delete.\n(PROMOTE_MODE): Always promote unsigned for HImode.\n(SECONDARY_INPUT_RELOAD_CLASS): Simplify.\n(MASK_RETURN_ADDR): Simplify.\n* arm.c (arm_prgmode): Delete.\n(arm_override_options, arm_gen_rotated_half_load): Simplify.\n(print_multi_reg, output_return_instruction): Simplify.\n(arm_output_epilogue, arm_final_prescan_insn): Simplify.\n(arm_return_addr): Simplify.\n* arm.md (prog_mode): Delete.\n(conds): Simplify.\n(zero_extendhisi2, extendhisi2, movhi, movhi_bytes): Simplify.\n(rotated_loadsi, movhi_insn_littleend, movhi_insn_bigend): Delete.\n(loadhi_si_bigend, loadhi_preinc, loadhi_shiftpreinc): Delete.\n(loadhi_shiftpredec): Delete.\n(peephole for post-increment on HImode load): Delete.\n* arm/crtn.asm: (FUNC_END): Simplify.\n* arm/lib1funcs.asm: Remove APCS-26 return macros.\n* arm/aof.h, arm/coff.h arm/elf.h arm/linux-elf.h arm/netbsd-elf.h\n* arm/netbsd.h arm/pe.h arm/semi.h arm/semiaof.h arm/unknown-elf.h\n* arm/vxworks.h arm/wince-pe.h: Tidy TARGET_DEFAULTS and\nMULTILIB_DEFAULTS as required.\n* arm/t-arm-elf arm/t-linux arm/t-pe arm/t-semi arm/t-wince-pe\n* arm/t-xscale-coff arm/t-xscale-elf arm/uclinux-elf: Tidy MULTILIB\nvariables as required.\n* doc/invoke.texi (ARM Options): Remove obsolete flags.\n\nFrom-SVN: r81881", "tree": {"sha": "28610dfea2c7c28279a8f56679c5dda559cb2f63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28610dfea2c7c28279a8f56679c5dda559cb2f63"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/comments", "author": null, "committer": null, "parents": [{"sha": "11c01dcc46761825183da2f641d81aec89e38393", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11c01dcc46761825183da2f641d81aec89e38393", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11c01dcc46761825183da2f641d81aec89e38393"}], "stats": {"total": 720, "additions": 153, "deletions": 567}, "files": [{"sha": "dfd84927c0070407b040a3cce0d4e36d855dd4b3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d", "patch": "@@ -1,3 +1,39 @@\n+2004-05-15  Richard Earnshaw  <reanrsha@arm.com>\n+\n+\t* arm.h (TARGET_APCS_32): Delete.\n+\t(TARGET_MMU_TRAPS): Delete.\n+\t(TARGET_CPU_CPP_BUILTINS): Unconditionally define __APCS_32__.  Never\n+\tdefine __APCS_26__.\n+\t(CPP_SPEC): Remove checking of -mapcs-{26,32}.\n+\t(ARM_FLAG_APCS_32, ARM_FLAG_MMU_TRAPS): Delete.\n+\t(TARGET_SWITCHES): Remove alignment_traps and apcs-{26,32} switches.\n+\t(prog_mode_type): Delete.\n+\t(PROMOTE_MODE): Always promote unsigned for HImode.\n+\t(SECONDARY_INPUT_RELOAD_CLASS): Simplify.\n+\t(MASK_RETURN_ADDR): Simplify.\n+\t* arm.c (arm_prgmode): Delete.\n+\t(arm_override_options, arm_gen_rotated_half_load): Simplify.\n+\t(print_multi_reg, output_return_instruction): Simplify.\n+\t(arm_output_epilogue, arm_final_prescan_insn): Simplify.\n+\t(arm_return_addr): Simplify.\n+\t* arm.md (prog_mode): Delete.\n+\t(conds): Simplify.\n+\t(zero_extendhisi2, extendhisi2, movhi, movhi_bytes): Simplify.\n+\t(rotated_loadsi, movhi_insn_littleend, movhi_insn_bigend): Delete.\n+\t(loadhi_si_bigend, loadhi_preinc, loadhi_shiftpreinc): Delete.\n+\t(loadhi_shiftpredec): Delete.\n+\t(peephole for post-increment on HImode load): Delete.\n+\t* arm/crtn.asm: (FUNC_END): Simplify.\n+\t* arm/lib1funcs.asm: Remove APCS-26 return macros.\n+\t* arm/aof.h, arm/coff.h arm/elf.h arm/linux-elf.h arm/netbsd-elf.h\n+\t* arm/netbsd.h arm/pe.h arm/semi.h arm/semiaof.h arm/unknown-elf.h \n+\t* arm/vxworks.h arm/wince-pe.h: Tidy TARGET_DEFAULTS and\n+\tMULTILIB_DEFAULTS as required.\n+\t* arm/t-arm-elf arm/t-linux arm/t-pe arm/t-semi arm/t-wince-pe\n+\t* arm/t-xscale-coff arm/t-xscale-elf arm/uclinux-elf: Tidy MULTILIB\n+\tvariables as required.\n+\t* doc/invoke.texi (ARM Options): Remove obsolete flags.\n+\n 2004-05-15  Alan Modra  <amodra@bigpond.net.au>\n \n \t* config/rs6000/rs6000.c (rs6000_va_arg <ABI_V4>): Don't use"}, {"sha": "aae95d41e8cead7f6855e7e0e56497b5bb5c48fe", "filename": "gcc/config/arm/aof.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Faof.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Faof.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faof.h?ref=61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d", "patch": "@@ -35,8 +35,7 @@\n #define ENDFILE_SPEC \"crtend.o%s\"\n \n #ifndef ASM_SPEC\n-#define ASM_SPEC \"%{g -g} -arch 4 \\\n--apcs 3%{mapcs-32:/32bit}%{mapcs-26:/26bit}%{!mapcs-26:%{!macps-32:/26bit}}\"\n+#define ASM_SPEC \"%{g -g} -arch 4 -apcs 3/32bit\"\n #endif\n \n #ifndef LIB_SPEC"}, {"sha": "6e85b11de8925e7cdafd1eea87592e021f8f3e57", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 30, "deletions": 106, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d", "patch": "@@ -301,9 +301,6 @@ enum float_abi_type arm_float_abi;\n /* Which ABI to use.  */\n enum arm_abi_type arm_abi;\n \n-/* What program mode is the cpu running in? 26-bit mode or 32-bit mode.  */\n-enum prog_mode_type arm_prgmode;\n-\n /* Set by the -mfpu=... option.  */\n const char * target_fpu_name = NULL;\n \n@@ -672,17 +669,12 @@ arm_override_options (void)\n \t{\n \t  sought |= (FL_THUMB | FL_MODE32);\n \t  \n-\t  /* Force apcs-32 to be used for interworking.  */\n-\t  target_flags |= ARM_FLAG_APCS_32;\n-\n \t  /* There are no ARM processors that support both APCS-26 and\n \t     interworking.  Therefore we force FL_MODE26 to be removed\n \t     from insn_flags here (if it was set), so that the search\n \t     below will always be able to find a compatible processor.  */\n \t  insn_flags &= ~FL_MODE26;\n \t}\n-      else if (!TARGET_APCS_32)\n-\tsought |= FL_MODE26;\n       \n       if (sought != 0 && ((sought & insn_flags) != sought))\n \t{\n@@ -705,12 +697,10 @@ arm_override_options (void)\n \t\t ought to use the -mcpu=<name> command line option to\n \t\t override the default CPU type.\n \n-\t\t Unfortunately this does not work with multilibing.  We\n-\t\t need to be able to support multilibs for -mapcs-26 and for\n-\t\t -mthumb-interwork and there is no CPU that can support both\n-\t\t options.  Instead if we cannot find a cpu that has both the\n-\t\t characteristics of the default cpu and the given command line\n-\t\t options we scan the array again looking for a best match.  */\n+\t\t If we cannot find a cpu that has both the\n+\t\t characteristics of the default cpu and the given\n+\t\t command line options we scan the array again looking\n+\t\t for a best match.  */\n \t      for (sel = all_cores; sel->name != NULL; sel++)\n \t\tif ((sel->flags & sought) == sought)\n \t\t  {\n@@ -748,21 +738,6 @@ arm_override_options (void)\n \n   /* Make sure that the processor choice does not conflict with any of the\n      other command line choices.  */\n-  if (TARGET_APCS_32 && !(insn_flags & FL_MODE32))\n-    {\n-      /* If APCS-32 was not the default then it must have been set by the\n-\t user, so issue a warning message.  If the user has specified\n-\t \"-mapcs-32 -mcpu=arm2\" then we loose here.  */\n-      if ((TARGET_DEFAULT & ARM_FLAG_APCS_32) == 0)\n-\twarning (\"target CPU does not support APCS-32\" );\n-      target_flags &= ~ARM_FLAG_APCS_32;\n-    }\n-  else if (!TARGET_APCS_32 && !(insn_flags & FL_MODE26))\n-    {\n-      warning (\"target CPU does not support APCS-26\" );\n-      target_flags |= ARM_FLAG_APCS_32;\n-    }\n-  \n   if (TARGET_INTERWORK && !(insn_flags & FL_THUMB))\n     {\n       warning (\"target CPU does not support interworking\" );\n@@ -793,14 +768,6 @@ arm_override_options (void)\n   if (TARGET_ARM && TARGET_CALLER_INTERWORKING)\n     warning (\"enabling caller interworking support is only meaningful when compiling for the Thumb\");\n \n-  /* If interworking is enabled then APCS-32 must be selected as well.  */\n-  if (TARGET_INTERWORK)\n-    {\n-      if (!TARGET_APCS_32)\n-\twarning (\"interworking forces APCS-32 to be used\" );\n-      target_flags |= ARM_FLAG_APCS_32;\n-    }\n-  \n   if (TARGET_APCS_STACK && !TARGET_APCS_FRAME)\n     {\n       warning (\"-mapcs-stack-check incompatible with -mno-apcs-frame\");\n@@ -963,8 +930,6 @@ arm_override_options (void)\n       && (tune_flags & FL_MODE32) == 0)\n     flag_schedule_insns = flag_schedule_insns_after_reload = 0;\n   \n-  arm_prgmode = TARGET_APCS_32 ? PROG_MODE_PROG32 : PROG_MODE_PROG26;\n-  \n   /* Override the default structure alignment for AAPCS ABI.  */\n   if (arm_abi == ARM_ABI_AAPCS)\n     arm_structure_size_boundary = 8;\n@@ -6136,8 +6101,7 @@ arm_gen_rotated_half_load (rtx memref)\n     }\n \n   /* If we aren't allowed to generate unaligned addresses, then fail.  */\n-  if (TARGET_MMU_TRAPS\n-      && ((BYTES_BIG_ENDIAN ? 1 : 0) ^ ((offset & 2) == 0)))\n+  if ((BYTES_BIG_ENDIAN ? 1 : 0) ^ ((offset & 2) == 0))\n     return NULL;\n \n   base = gen_rtx_MEM (SImode, plus_constant (base, offset & ~2));\n@@ -7892,20 +7856,7 @@ print_multi_reg (FILE *stream, const char *instr, int reg, int mask)\n \tnot_first = TRUE;\n       }\n \n-  fprintf (stream, \"}\");\n-\n-  /* Add a ^ character for the 26-bit ABI, but only if we were loading\n-     the PC.  Otherwise we would generate an UNPREDICTABLE instruction.\n-     Strictly speaking the instruction would be unpredictable only if\n-     we were writing back the base register as well, but since we never\n-     want to generate an LDM type 2 instruction (register bank switching)\n-     which is what you get if the PC is not being loaded, we do not need\n-     to check for writeback.  */\n-  if (! TARGET_APCS_32\n-      && ((mask & (1 << PC_REGNUM)) != 0))\n-    fprintf (stream, \"^\");\n-  \n-  fprintf (stream, \"\\n\");\n+  fprintf (stream, \"}\\n\");\n }\n \n \n@@ -9210,7 +9161,7 @@ output_return_instruction (rtx operand, int really_return, int reverse)\n       if (reg <= LAST_ARM_REGNUM\n \t  && (reg != LR_REGNUM\n \t      || ! really_return \n-\t      || (TARGET_APCS_32 && ! IS_INTERRUPT (func_type))))\n+\t      || ! IS_INTERRUPT (func_type)))\n \t{\n \t  sprintf (instr, \"ldr%s\\t%%|%s, [%%|sp], #4\", conditional, \n \t\t   (reg == LR_REGNUM) ? return_reg : reg_names[reg]);\n@@ -9270,20 +9221,8 @@ output_return_instruction (rtx operand, int really_return, int reverse)\n \t  if (live_regs_mask & (1 << LR_REGNUM))\n \t    {\n \t      sprintf (p, \"%s%%|%s}\", first ? \"\" : \", \", return_reg);\n-\t      /* Decide if we need to add the ^ symbol to the end of the\n-\t\t register list.\t This causes the saved condition codes\n-\t\t register to be copied into the current condition codes\n-\t\t register.  We do the copy if we are conforming to the 32-bit\n-\t\t ABI and this is an interrupt function, or if we are\n-\t\t conforming to the 26-bit ABI.  There is a special case for\n-\t\t the 26-bit ABI however, which is if we are writing back the\n-\t\t stack pointer but not loading the PC.  In this case adding\n-\t\t the ^ symbol would create a type 2 LDM instruction, where\n-\t\t writeback is UNPREDICTABLE.  We are safe in leaving the ^\n-\t\t character off in this case however, since the actual return\n-\t\t instruction will be a MOVS which will restore the CPSR.  */\n-\t      if ((TARGET_APCS_32 && IS_INTERRUPT (func_type))\n-\t\t  || (! TARGET_APCS_32 && really_return))\n+\t      /* If returning from an interrupt, restore the CPSR.  */\n+\t      if (IS_INTERRUPT (func_type))\n \t\tstrcat (p, \"^\");\n \t    }\n \t  else\n@@ -9323,12 +9262,11 @@ output_return_instruction (rtx operand, int really_return, int reverse)\n \n \tdefault:\n \t  /* ARMv5 implementations always provide BX, so interworking\n-\t     is the default unless APCS-26 is in use.  */\n-\t  if ((insn_flags & FL_ARCH5) != 0 && TARGET_APCS_32)\n+\t     is the default.  */\n+\t  if ((insn_flags & FL_ARCH5) != 0)\n \t    sprintf (instr, \"bx%s\\t%%|lr\", conditional);\t    \n \t  else\n-\t    sprintf (instr, \"mov%s%s\\t%%|pc, %%|lr\",\n-\t\t     conditional, TARGET_APCS_32 ? \"\" : \"s\");\n+\t    sprintf (instr, \"mov%s\\t%%|pc, %%|lr\", conditional);\n \t  break;\n \t}\n \n@@ -9806,10 +9744,8 @@ arm_output_epilogue (rtx sibling)\n \t/* Similarly we may have been able to load LR into the PC\n \t   even if we did not create a stack frame.  */\n \t;\n-      else if (TARGET_APCS_32)\n-\tasm_fprintf (f, \"\\tmov\\t%r, %r\\n\", PC_REGNUM, LR_REGNUM);\n       else\n-\tasm_fprintf (f, \"\\tmovs\\t%r, %r\\n\", PC_REGNUM, LR_REGNUM);\n+\tasm_fprintf (f, \"\\tmov\\t%r, %r\\n\", PC_REGNUM, LR_REGNUM);\n       break;\n     }\n \n@@ -11303,32 +11239,27 @@ arm_final_prescan_insn (rtx insn)\n \t      break;\n \n \t    case CALL_INSN:\n-\t      /* If using 32-bit addresses the cc is not preserved over\n-\t\t calls.  */\n-\t      if (TARGET_APCS_32)\n-\t\t{\n-\t\t  /* Succeed if the following insn is the target label,\n-\t\t     or if the following two insns are a barrier and\n-\t\t     the target label.  */\n-\t\t  this_insn = next_nonnote_insn (this_insn);\n-\t\t  if (this_insn && GET_CODE (this_insn) == BARRIER)\n-\t\t    this_insn = next_nonnote_insn (this_insn);\n+\t      /* Succeed if the following insn is the target label, or\n+\t\t if the following two insns are a barrier and the\n+\t\t target label.  */\n+\t      this_insn = next_nonnote_insn (this_insn);\n+\t      if (this_insn && GET_CODE (this_insn) == BARRIER)\n+\t\tthis_insn = next_nonnote_insn (this_insn);\n \n-\t\t  if (this_insn && this_insn == label\n-\t\t      && insns_skipped < max_insns_skipped)\n+\t      if (this_insn && this_insn == label\n+\t\t  && insns_skipped < max_insns_skipped)\n+\t\t{\n+\t\t  if (jump_clobbers)\n \t\t    {\n-\t\t      if (jump_clobbers)\n-\t\t\t{\n-\t\t\t  arm_ccfsm_state = 2;\n-\t\t\t  this_insn = next_nonnote_insn (this_insn);\n-\t\t\t}\n-\t\t      else\n-\t\t\tarm_ccfsm_state = 1;\n-\t\t      succeed = TRUE;\n+\t\t      arm_ccfsm_state = 2;\n+\t\t      this_insn = next_nonnote_insn (this_insn);\n \t\t    }\n \t\t  else\n-\t\t    fail = TRUE;\n+\t\t    arm_ccfsm_state = 1;\n+\t\t  succeed = TRUE;\n \t\t}\n+\t      else\n+\t\tfail = TRUE;\n \t      break;\n \n \t    case JUMP_INSN:\n@@ -13173,14 +13104,7 @@ arm_return_addr (int count, rtx frame ATTRIBUTE_UNUSED)\n   if (count != 0)\n     return NULL_RTX;\n \n-  if (TARGET_APCS_32)\n-    return get_hard_reg_initial_val (Pmode, LR_REGNUM);\n-  else\n-    {\n-      rtx lr = gen_rtx_AND (Pmode, gen_rtx_REG (Pmode, LR_REGNUM),\n-\t\t\t    GEN_INT (RETURN_ADDR_MASK26));\n-      return get_func_hard_reg_initial_val (cfun, lr);\n-    }\n+  return get_hard_reg_initial_val (Pmode, LR_REGNUM);\n }\n \n /* Do anything needed before RTL is emitted for each function.  */"}, {"sha": "8241b2cb95ee7cd1fd80065d6c13bf7f09431191", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 7, "deletions": 46, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d", "patch": "@@ -36,6 +36,7 @@ extern char arm_arch_name[];\n \t/* Define __arm__ even when in thumb mode, for\t\\\n \t   consistency with armcc.  */\t\t\t\\\n \tbuiltin_define (\"__arm__\");\t\t\t\\\n+\tbuiltin_define (\"__APCS_32__\");\t\t\t\\\n \tif (TARGET_THUMB)\t\t\t\t\\\n \t  builtin_define (\"__thumb__\");\t\t\t\\\n \t\t\t\t\t\t\t\\\n@@ -54,11 +55,6 @@ extern char arm_arch_name[];\n \t      builtin_define (\"__THUMBEL__\");\t\t\\\n \t  }\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\\\n-\tif (TARGET_APCS_32)\t\t\t\t\\\n-\t  builtin_define (\"__APCS_32__\");\t\t\\\n-\telse\t\t\t\t\t\t\\\n-\t  builtin_define (\"__APCS_26__\");\t\t\\\n-\t\t\t\t\t\t\t\\\n \tif (TARGET_SOFT_FLOAT)\t\t\t\t\\\n \t  builtin_define (\"__SOFTFP__\");\t\t\\\n \t\t\t\t\t\t\t\\\n@@ -149,8 +145,6 @@ extern GTY(()) rtx aof_pic_label;\n \n #undef  CPP_SPEC\n #define CPP_SPEC \"%(subtarget_cpp_spec)\t\t\t\t\t\\\n-%{mapcs-32:%{mapcs-26:\t\t\t\t\t\t\t\\\n-\t%e-mapcs-26 and -mapcs-32 may not be used together}}\t\t\\\n %{msoft-float:%{mhard-float:\t\t\t\t\t\t\\\n \t%e-msoft-float and -mhard_float may not be used together}}\t\\\n %{mbig-endian:%{mlittle-endian:\t\t\t\t\t\t\\\n@@ -201,12 +195,7 @@ extern GTY(()) rtx aof_pic_label;\n    case instruction scheduling becomes very uninteresting.  */\n #define ARM_FLAG_FPE\t\t(1 << 2)\n \n-/* Nonzero if destined for a processor in 32-bit program mode.  Takes out bit\n-   that assume restoration of the condition flags when returning from a\n-   branch and link (ie a function).  */\n-#define ARM_FLAG_APCS_32\t(1 << 3)\n-\n-/* FLAGS 0x0008 and 0x0010 are now spare (used to be arm3/6 selection).  */\n+/* FLAG 0x0008 now spare (used to be apcs-32 selection).  */\n \n /* Nonzero if stack checking should be performed on entry to each function\n    which allocates temporary variables on the stack.  */\n@@ -220,10 +209,7 @@ extern GTY(()) rtx aof_pic_label;\n    This is equivalent to -fpic.  */\n #define ARM_FLAG_APCS_REENT\t(1 << 6)\n \n-/* Nonzero if the MMU will trap unaligned word accesses, so shorts must\n-   be loaded using either LDRH or LDRB instructions.  */\n-#define ARM_FLAG_MMU_TRAPS\t(1 << 7)\n-\n+  /* FLAG 0x0080 now spare (used to be alignment traps).  */\n /* Nonzero if all floating point instructions are missing (and there is no\n    emulator either).  Generate function calls for all ops in this case.  */\n #define ARM_FLAG_SOFT_FLOAT\t(1 << 8)\n@@ -276,11 +262,9 @@ extern GTY(()) rtx aof_pic_label;\n #define TARGET_APCS_FRAME\t\t(target_flags & ARM_FLAG_APCS_FRAME)\n #define TARGET_POKE_FUNCTION_NAME\t(target_flags & ARM_FLAG_POKE)\n #define TARGET_FPE\t\t\t(target_flags & ARM_FLAG_FPE)\n-#define TARGET_APCS_32\t\t\t(target_flags & ARM_FLAG_APCS_32)\n #define TARGET_APCS_STACK\t\t(target_flags & ARM_FLAG_APCS_STACK)\n #define TARGET_APCS_FLOAT\t\t(target_flags & ARM_FLAG_APCS_FLOAT)\n #define TARGET_APCS_REENT\t\t(target_flags & ARM_FLAG_APCS_REENT)\n-#define TARGET_MMU_TRAPS\t\t(target_flags & ARM_FLAG_MMU_TRAPS)\n #define TARGET_SOFT_FLOAT\t\t(arm_float_abi == ARM_FLOAT_ABI_SOFT)\n #define TARGET_SOFT_FLOAT_ABI\t\t(arm_float_abi != ARM_FLOAT_ABI_HARD)\n #define TARGET_HARD_FLOAT\t\t(arm_float_abi == ARM_FLOAT_ABI_HARD)\n@@ -325,10 +309,6 @@ extern GTY(()) rtx aof_pic_label;\n    N_(\"Store function names in object code\") },\t\t\t\t\\\n   {\"no-poke-function-name\",    -ARM_FLAG_POKE, \"\" },\t\t\t\\\n   {\"fpe\",\t\t\tARM_FLAG_FPE,  \"\" },\t\t\t\\\n-  {\"apcs-32\",\t\t\tARM_FLAG_APCS_32,\t\t\t\\\n-   N_(\"Use the 32-bit version of the APCS\") },\t\t\t\t\\\n-  {\"apcs-26\",\t\t       -ARM_FLAG_APCS_32,\t\t\t\\\n-   N_(\"Use the 26-bit version of the APCS\") },\t\t\t\t\\\n   {\"apcs-stack-check\",\t\tARM_FLAG_APCS_STACK, \"\" },\t\t\\\n   {\"no-apcs-stack-check\",      -ARM_FLAG_APCS_STACK, \"\" },\t\t\\\n   {\"apcs-float\",\t\tARM_FLAG_APCS_FLOAT,\t\t\t\\\n@@ -337,13 +317,6 @@ extern GTY(()) rtx aof_pic_label;\n   {\"apcs-reentrant\",\t\tARM_FLAG_APCS_REENT,\t\t\t\\\n    N_(\"Generate re-entrant, PIC code\") },\t\t\t\t\\\n   {\"no-apcs-reentrant\",\t       -ARM_FLAG_APCS_REENT, \"\" },\t\t\\\n-  {\"alignment-traps\",           ARM_FLAG_MMU_TRAPS,\t\t\t\\\n-   N_(\"The MMU will trap on unaligned accesses\") },\t\t\t\\\n-  {\"no-alignment-traps\",       -ARM_FLAG_MMU_TRAPS, \"\" },\t\t\\\n-  {\"short-load-bytes\",\t\tARM_FLAG_MMU_TRAPS, \"\" },\t\t\\\n-  {\"no-short-load-bytes\",      -ARM_FLAG_MMU_TRAPS, \"\" },\t\t\\\n-  {\"short-load-words\",\t       -ARM_FLAG_MMU_TRAPS, \"\" },\t\t\\\n-  {\"no-short-load-words\",\tARM_FLAG_MMU_TRAPS, \"\" },\t\t\\\n   {\"soft-float\",\t\tARM_FLAG_SOFT_FLOAT,\t\t\t\\\n    N_(\"Use library calls to perform FP operations\") },\t\t\t\\\n   {\"hard-float\",\t       -ARM_FLAG_SOFT_FLOAT,\t\t\t\\\n@@ -446,17 +419,6 @@ struct arm_cpu_select\n    string pointer will be set to the value specified by the user.  */\n extern struct arm_cpu_select arm_select[];\n \n-enum prog_mode_type\n-{\n-  prog_mode26,\n-  prog_mode32\n-};\n-\n-/* Recast the program mode class to be the prog_mode attribute.  */\n-#define arm_prog_mode ((enum attr_prog_mode) arm_prgmode)\n-\n-extern enum prog_mode_type arm_prgmode;\n-\n /* Which floating point model to use.  */\n enum arm_fp_model\n {\n@@ -617,7 +579,7 @@ extern int arm_is_6_or_7;\n       if (MODE == QImode)\t\t\t\\\n \tUNSIGNEDP = 1;\t\t\t\t\\\n       else if (MODE == HImode)\t\t\t\\\n-\tUNSIGNEDP = TARGET_MMU_TRAPS != 0;\t\\\n+\tUNSIGNEDP = 1;\t\t\t\t\\\n       (MODE) = SImode;\t\t\t\t\\\n     }\n \n@@ -1394,7 +1356,7 @@ enum reg_class\n    (((CLASS) == IWMMXT_REGS || (CLASS) == IWMMXT_GR_REGS)\t\\\n       && CONSTANT_P (X))\t\t\t\t\t\\\n    ? GENERAL_REGS :\t\t\t\t\t\t\\\n-   (((MODE) == HImode && ! arm_arch4 && TARGET_MMU_TRAPS\t\\\n+   (((MODE) == HImode && ! arm_arch4\t\t\t\t\\\n      && (GET_CODE (X) == MEM\t\t\t\t\t\\\n \t || ((GET_CODE (X) == REG || GET_CODE (X) == SUBREG)\t\\\n \t     && true_regnum (X) == -1)))\t\t\t\\\n@@ -2621,9 +2583,8 @@ extern int making_const_table;\n      in 26 bit mode, the condition codes must be masked out of the\t\\\n      return address.  This does not apply to ARM6 and later processors\t\\\n      when running in 32 bit mode.  */\t\t\t\t\t\\\n-  ((!TARGET_APCS_32) ? (gen_int_mode (RETURN_ADDR_MASK26, Pmode))\t\\\n-   : (arm_arch4 || TARGET_THUMB) ?\t\t\t\t\t\\\n-     (gen_int_mode ((unsigned long)0xffffffff, Pmode))\t\t\t\\\n+  ((arm_arch4 || TARGET_THUMB)\t\t\t\t\t\t\\\n+   ? (gen_int_mode ((unsigned long)0xffffffff, Pmode))\t\t\t\\\n    : arm_gen_return_addr_mask ())\n \n \f"}, {"sha": "dd4b667a2797e9ebdd91f9664ad656fe5a464248", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 35, "deletions": 266, "changes": 301, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d", "patch": "@@ -128,11 +128,6 @@\n ; patterns that share the same RTL in both ARM and Thumb code.\n (define_attr \"is_thumb\" \"no,yes\" (const (symbol_ref \"thumb_code\")))\n \n-; PROG_MODE attribute is used to determine whether condition codes are\n-; clobbered by a call insn: they are if in prog32 mode.  This is controlled\n-; by the -mapcs-{32,26} flag, and possibly the -mcpu=... option.\n-(define_attr \"prog_mode\" \"prog26,prog32\" (const (symbol_ref \"arm_prog_mode\")))\n-\n ; IS_STRONGARM is set to 'yes' when compiling for StrongARM, it affects\n ; scheduling decisions for the load unit and the multiplier.\n (define_attr \"is_strongarm\" \"no,yes\" (const (symbol_ref \"arm_is_strong\")))\n@@ -254,8 +249,7 @@\n \n (define_attr \"conds\" \"use,set,clob,jump_clob,nocond\"\n \t(if_then_else (eq_attr \"type\" \"call\")\n-\t (if_then_else (eq_attr \"prog_mode\" \"prog32\")\n-\t  (const_string \"clob\") (const_string \"nocond\"))\n+\t (const_string \"clob\")\n \t (const_string \"nocond\")))\n \n ; Predicable means that the insn can be conditionally executed based on\n@@ -3144,16 +3138,12 @@\n   {\n     if ((TARGET_THUMB || arm_arch4) && GET_CODE (operands[1]) == MEM)\n       {\n-       /* Note: We do not have to worry about TARGET_MMU_TRAPS\n-\t  here because the insn below will generate an LDRH instruction\n-\t  rather than an LDR instruction, so we cannot get an unaligned\n-\t  word access.  */\n \temit_insn (gen_rtx_SET (VOIDmode, operands[0],\n \t\t\t\tgen_rtx_ZERO_EXTEND (SImode, operands[1])));\n \tDONE;\n       }\n \n-    if (TARGET_ARM && TARGET_MMU_TRAPS && GET_CODE (operands[1]) == MEM)\n+    if (TARGET_ARM && GET_CODE (operands[1]) == MEM)\n       {\n \temit_insn (gen_movhi_bytes (operands[0], operands[1]));\n \tDONE;\n@@ -3461,17 +3451,13 @@\n           }\n \telse if (arm_arch4)\n \t  {\n-\t    /* Note: We do not have to worry about TARGET_MMU_TRAPS\n-\t       here because the insn below will generate an LDRH instruction\n-\t       rather than an LDR instruction, so we cannot get an unaligned\n-\t       word access.  */\n \t    emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n \t\t       gen_rtx_SIGN_EXTEND (SImode, operands[1])));\n \t    DONE;\n \t  }\n       }\n \n-    if (TARGET_ARM && TARGET_MMU_TRAPS && GET_CODE (operands[1]) == MEM)\n+    if (TARGET_ARM && GET_CODE (operands[1]) == MEM)\n       {\n         emit_insn (gen_extendhisi2_mem (operands[0], operands[1]));\n         DONE;\n@@ -4577,89 +4563,40 @@\n \t    }\n           else if (!arm_arch4)\n \t    {\n-\t     /* Note: We do not have to worry about TARGET_MMU_TRAPS\n-\t        for v4 and up architectures because LDRH instructions will\n-\t        be used to access the HI values, and these cannot generate\n-\t        unaligned word access faults in the MMU.  */\n \t      if (GET_CODE (operands[1]) == MEM)\n \t        {\n-\t          if (TARGET_MMU_TRAPS)\n-\t\t    {\n-\t\t      rtx base;\n-\t\t      rtx offset = const0_rtx;\n-\t\t      rtx reg = gen_reg_rtx (SImode);\n-\n-\t\t      if ((GET_CODE (base = XEXP (operands[1], 0)) == REG\n-\t\t           || (GET_CODE (base) == PLUS\n-\t\t\t       && (GET_CODE (offset = XEXP (base, 1))\n-\t\t\t\t   == CONST_INT)\n-                               && ((INTVAL(offset) & 1) != 1)\n-\t\t\t       && GET_CODE (base = XEXP (base, 0)) == REG))\n-\t\t          && REGNO_POINTER_ALIGN (REGNO (base)) >= 32)\n-\t\t        {\n-\t\t          HOST_WIDE_INT new_offset = INTVAL (offset) & ~3;\n-\t\t          rtx new;\n-\n-\t\t          new = gen_rtx_MEM (SImode,\n-\t\t\t\t   \t     plus_constant (base, new_offset));\n-\t                  MEM_COPY_ATTRIBUTES (new, operands[1]);\n-\t\t          emit_insn (gen_movsi (reg, new));\n-\t\t          if (((INTVAL (offset) & 2) != 0)\n-\t\t\t      ^ (BYTES_BIG_ENDIAN ? 1 : 0))\n-\t\t\t    {\n-\t\t\t      rtx reg2 = gen_reg_rtx (SImode);\n-\n-\t\t\t      emit_insn (gen_lshrsi3 (reg2, reg,\n-\t\t\t\t\t GEN_INT (16)));\n-\t\t\t      reg = reg2;\n-\t\t\t    }\n-\t\t        }\n-\t\t      else\n-\t\t        emit_insn (gen_movhi_bytes (reg, operands[1]));\n-\n-\t\t      operands[1] = gen_lowpart (HImode, reg);\n-\t\t    }\n-\t          else if (BYTES_BIG_ENDIAN)\n+\t\t  rtx base;\n+\t\t  rtx offset = const0_rtx;\n+\t\t  rtx reg = gen_reg_rtx (SImode);\n+\n+\t\t  if ((GET_CODE (base = XEXP (operands[1], 0)) == REG\n+\t\t       || (GET_CODE (base) == PLUS\n+\t\t\t   && (GET_CODE (offset = XEXP (base, 1))\n+\t\t\t       == CONST_INT)\n+                           && ((INTVAL(offset) & 1) != 1)\n+\t\t\t   && GET_CODE (base = XEXP (base, 0)) == REG))\n+\t\t      && REGNO_POINTER_ALIGN (REGNO (base)) >= 32)\n \t\t    {\n-\t\t      rtx base;\n-\t\t      rtx offset = const0_rtx;\n-\n-\t\t      if ((GET_CODE (base = XEXP (operands[1], 0)) == REG\n-\t\t           || (GET_CODE (base) == PLUS\n-\t\t\t      && (GET_CODE (offset = XEXP (base, 1))\n-\t\t\t\t  == CONST_INT)\n-\t\t\t      && GET_CODE (base = XEXP (base, 0)) == REG))\n-\t\t          && REGNO_POINTER_ALIGN (REGNO (base)) >= 32)\n-\t\t        {\n-\t\t          rtx reg = gen_reg_rtx (SImode);\n-\t\t          rtx new;\n-\n-\t\t          if ((INTVAL (offset) & 2) == 2)\n-\t\t\t    {\n-\t\t\t      HOST_WIDE_INT new_offset = INTVAL (offset) ^ 2;\n-\t\t\t      new = gen_rtx_MEM (SImode,\n-\t\t\t\t  \t         plus_constant (base,\n-\t\t\t\t\t\t\t\tnew_offset));\n-                              MEM_COPY_ATTRIBUTES (new, operands[1]);\n-\t\t\t      emit_insn (gen_movsi (reg, new));\n-\t\t\t    }\n-\t\t          else\n-\t\t\t    {\n-\t\t\t      new = gen_rtx_MEM (SImode,\n-\t\t\t\t\t\t XEXP (operands[1], 0));\n-\t                      MEM_COPY_ATTRIBUTES (new, operands[1]);\n-\t\t\t      emit_insn (gen_rotated_loadsi (reg, new));\n-\t\t\t    }\n-\n-\t\t          operands[1] = gen_lowpart (HImode, reg);\n-\t\t        }\n-\t\t      else\n-\t\t        {\n-\t\t          emit_insn (gen_movhi_bigend (operands[0],\n-\t\t\t\t\t\t       operands[1]));\n-\t\t          DONE;\n-\t\t        }\n+\t\t      HOST_WIDE_INT new_offset = INTVAL (offset) & ~3;\n+\t\t      rtx new;\n+\n+\t\t      new = gen_rtx_MEM (SImode,\n+\t\t\t\t\t plus_constant (base, new_offset));\n+\t              MEM_COPY_ATTRIBUTES (new, operands[1]);\n+\t\t      emit_insn (gen_movsi (reg, new));\n+\t\t      if (((INTVAL (offset) & 2) != 0)\n+\t\t\t  ^ (BYTES_BIG_ENDIAN ? 1 : 0))\n+\t\t\t{\n+\t\t\t  rtx reg2 = gen_reg_rtx (SImode);\n+\n+\t\t\t  emit_insn (gen_lshrsi3 (reg2, reg, GEN_INT (16)));\n+\t\t\t  reg = reg2;\n+\t\t\t}\n \t\t    }\n+\t\t  else\n+\t\t    emit_insn (gen_movhi_bytes (reg, operands[1]));\n+\n+\t\t  operands[1] = gen_lowpart (HImode, reg);\n \t       }\n \t   }\n         }\n@@ -4762,24 +4699,6 @@\n )\n \n \n-(define_insn \"rotated_loadsi\"\n-  [(set (match_operand:SI            0 \"s_register_operand\"        \"=r\")\n-\t(rotate:SI (match_operand:SI 1 \"offsettable_memory_operand\" \"o\")\n-\t\t   (const_int 16)))]\n-  \"TARGET_ARM && (!TARGET_MMU_TRAPS)\"\n-  \"*\n-  {\n-    rtx ops[2];\n-\n-    ops[0] = operands[0];\n-    ops[1] = gen_rtx_MEM (SImode, plus_constant (XEXP (operands[1], 0), 2));\n-    output_asm_insn (\\\"ldr%?\\\\t%0, %1\\\\t%@ load-rotate\\\", ops);\n-    return \\\"\\\";\n-  }\"\n-  [(set_attr \"type\" \"load1\")\n-   (set_attr \"predicable\" \"yes\")]\n-)\n-\n (define_expand \"movhi_bytes\"\n   [(set (match_dup 2) (zero_extend:SI (match_operand:HI 1 \"\" \"\")))\n    (set (match_dup 3)\n@@ -4851,65 +4770,10 @@\n    (set_attr \"neg_pool_range\" \"*,*,*,244\")]\n )\n \n-(define_insn \"*movhi_insn_littleend\"\n-  [(set (match_operand:HI 0 \"s_register_operand\" \"=r,r,r\")\n-\t(match_operand:HI 1 \"general_operand\"  \"rI,K,m\"))]\n-  \"TARGET_ARM\n-   && !arm_arch4\n-   && !BYTES_BIG_ENDIAN\n-   && !TARGET_MMU_TRAPS\n-   && (GET_CODE (operands[1]) != CONST_INT\n-       || const_ok_for_arm (INTVAL (operands[1]))\n-       || const_ok_for_arm (~INTVAL (operands[1])))\"\n-  \"@\n-   mov%?\\\\t%0, %1\\\\t%@ movhi\n-   mvn%?\\\\t%0, #%B1\\\\t%@ movhi\n-   ldr%?\\\\t%0, %1\\\\t%@ movhi\"\n-  [(set_attr \"type\" \"*,*,load1\")\n-   (set_attr \"predicable\" \"yes\")\n-   (set_attr \"pool_range\" \"4096\")\n-   (set_attr \"neg_pool_range\" \"4084\")]\n-)\n-\n-(define_insn \"*movhi_insn_bigend\"\n-  [(set (match_operand:HI 0 \"s_register_operand\" \"=r,r,r\")\n-\t(match_operand:HI 1 \"general_operand\"    \"rI,K,m\"))]\n-  \"TARGET_ARM\n-   && !arm_arch4\n-   && BYTES_BIG_ENDIAN\n-   && !TARGET_MMU_TRAPS\n-   && (GET_CODE (operands[1]) != CONST_INT\n-       || const_ok_for_arm (INTVAL (operands[1]))\n-       || const_ok_for_arm (~INTVAL (operands[1])))\"\n-  \"@\n-   mov%?\\\\t%0, %1\\\\t%@ movhi\n-   mvn%?\\\\t%0, #%B1\\\\t%@ movhi\n-   ldr%?\\\\t%0, %1\\\\t%@ movhi_bigend\\;mov%?\\\\t%0, %0, asr #16\"\n-  [(set_attr \"type\" \"*,*,load1\")\n-   (set_attr \"predicable\" \"yes\")\n-   (set_attr \"length\" \"4,4,8\")\n-   (set_attr \"pool_range\" \"*,*,4092\")\n-   (set_attr \"neg_pool_range\" \"*,*,4084\")]\n-)\n-\n-(define_insn \"*loadhi_si_bigend\"\n-  [(set (match_operand:SI                       0 \"s_register_operand\" \"=r\")\n-\t(rotate:SI (subreg:SI (match_operand:HI 1 \"memory_operand\"      \"m\") 0)\n-\t\t   (const_int 16)))]\n-  \"TARGET_ARM\n-   && BYTES_BIG_ENDIAN\n-   && !TARGET_MMU_TRAPS\"\n-  \"ldr%?\\\\t%0, %1\\\\t%@ movhi_bigend\"\n-  [(set_attr \"type\" \"load1\")\n-   (set_attr \"predicable\" \"yes\")\n-   (set_attr \"pool_range\" \"4096\")\n-   (set_attr \"neg_pool_range\" \"4084\")]\n-)\n-\n (define_insn \"*movhi_bytes\"\n   [(set (match_operand:HI 0 \"s_register_operand\" \"=r,r\")\n \t(match_operand:HI 1 \"arm_rhs_operand\"  \"rI,K\"))]\n-  \"TARGET_ARM && TARGET_MMU_TRAPS\"\n+  \"TARGET_ARM\"\n   \"@\n    mov%?\\\\t%0, %1\\\\t%@ movhi\n    mvn%?\\\\t%0, #%B1\\\\t%@ movhi\"\n@@ -4945,7 +4809,7 @@\n   [(parallel [(match_operand:HI 0 \"s_register_operand\" \"=r\")\n \t      (match_operand:HI 1 \"arm_reload_memory_operand\" \"o\")\n \t      (match_operand:DI 2 \"s_register_operand\" \"=&r\")])]\n-  \"TARGET_THUMB || (TARGET_ARM && TARGET_MMU_TRAPS)\"\n+  \"TARGET_EITHER\"\n   \"\n   if (TARGET_ARM)\n     arm_reload_in_hi (operands);\n@@ -9324,44 +9188,6 @@\n    (set_attr \"predicable\" \"yes\")]\n )\n \n-(define_insn \"*loadhi_preinc\"\n-  [(set (match_operand:HI 3 \"s_register_operand\" \"=r\")\n-\t(mem:HI (plus:SI (match_operand:SI 1 \"s_register_operand\" \"%0\")\n-\t\t\t (match_operand:SI 2 \"index_operand\" \"rJ\"))))\n-   (set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n-\t(plus:SI (match_dup 1) (match_dup 2)))]\n-  \"TARGET_ARM\n-   && !BYTES_BIG_ENDIAN\n-   && !TARGET_MMU_TRAPS\n-   && !arm_arch4\n-   && REGNO (operands[0]) != FRAME_POINTER_REGNUM\n-   && REGNO (operands[1]) != FRAME_POINTER_REGNUM\n-   && (GET_CODE (operands[2]) != REG\n-       || REGNO (operands[2]) != FRAME_POINTER_REGNUM)\"\n-  \"ldr%?\\\\t%3, [%0, %2]!\\\\t%@ loadhi\"\n-  [(set_attr \"type\" \"load_byte\")\n-   (set_attr \"predicable\" \"yes\")]\n-)\n-\n-(define_insn \"*loadhi_predec\"\n-  [(set (match_operand:HI 3 \"s_register_operand\" \"=r\")\n-\t(mem:HI (minus:SI (match_operand:SI 1 \"s_register_operand\" \"0\")\n-\t\t\t  (match_operand:SI 2 \"s_register_operand\" \"r\"))))\n-   (set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n-\t(minus:SI (match_dup 1) (match_dup 2)))]\n-  \"TARGET_ARM\n-   && !BYTES_BIG_ENDIAN\n-   && !TARGET_MMU_TRAPS\n-   && !arm_arch4\n-   && REGNO (operands[0]) != FRAME_POINTER_REGNUM\n-   && REGNO (operands[1]) != FRAME_POINTER_REGNUM\n-   && (GET_CODE (operands[2]) != REG\n-       || REGNO (operands[2]) != FRAME_POINTER_REGNUM)\"\n-  \"ldr%?\\\\t%3, [%0, -%2]!\\\\t%@ loadhi\"\n-  [(set_attr \"type\" \"load_byte\")\n-   (set_attr \"predicable\" \"yes\")]\n-)\n-\n (define_insn \"*strqi_shiftpreinc\"\n   [(set (mem:QI (plus:SI (match_operator:SI 2 \"shift_operator\"\n \t\t\t  [(match_operand:SI 3 \"s_register_operand\" \"r\")\n@@ -9505,48 +9331,6 @@\n   [(set_attr \"type\" \"load1\")\n    (set_attr \"predicable\" \"yes\")])\n \n-(define_insn \"*loadhi_shiftpreinc\"\n-  [(set (match_operand:HI 5 \"s_register_operand\" \"=r\")\n-\t(mem:HI (plus:SI (match_operator:SI 2 \"shift_operator\"\n-\t\t\t  [(match_operand:SI 3 \"s_register_operand\" \"r\")\n-\t\t\t   (match_operand:SI 4 \"const_shift_operand\" \"n\")])\n-\t\t\t (match_operand:SI 1 \"s_register_operand\" \"0\"))))\n-   (set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n-\t(plus:SI (match_op_dup 2 [(match_dup 3)\t(match_dup 4)])\n-\t\t (match_dup 1)))]\n-  \"TARGET_ARM\n-   && !BYTES_BIG_ENDIAN\n-   && !TARGET_MMU_TRAPS\n-   && !arm_arch4\n-   && REGNO (operands[0]) != FRAME_POINTER_REGNUM\n-   && REGNO (operands[1]) != FRAME_POINTER_REGNUM\n-   && REGNO (operands[3]) != FRAME_POINTER_REGNUM\"\n-  \"ldr%?\\\\t%5, [%0, %3%S2]!\\\\t%@ loadhi\"\n-  [(set_attr \"type\" \"load_byte\")\n-   (set_attr \"predicable\" \"yes\")]\n-)\n-\n-(define_insn \"*loadhi_shiftpredec\"\n-  [(set (match_operand:HI 5 \"s_register_operand\" \"=r\")\n-\t(mem:HI (minus:SI (match_operand:SI 1 \"s_register_operand\" \"0\")\n-\t\t\t  (match_operator:SI 2 \"shift_operator\"\n-\t\t\t   [(match_operand:SI 3 \"s_register_operand\" \"r\")\n-\t\t\t    (match_operand:SI 4 \"const_shift_operand\" \"n\")]))))\n-   (set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n-\t(minus:SI (match_dup 1) (match_op_dup 2 [(match_dup 3)\n-\t\t\t\t\t\t (match_dup 4)])))]\n-  \"TARGET_ARM\n-   && !BYTES_BIG_ENDIAN\n-   && !TARGET_MMU_TRAPS\n-   && !arm_arch4\n-   && REGNO (operands[0]) != FRAME_POINTER_REGNUM\n-   && REGNO (operands[1]) != FRAME_POINTER_REGNUM\n-   && REGNO (operands[3]) != FRAME_POINTER_REGNUM\"\n-  \"ldr%?\\\\t%5, [%0, -%3%S2]!\\\\t%@ loadhi\"\n-  [(set_attr \"type\" \"load_byte\")\n-   (set_attr \"predicable\" \"yes\")]\n-)\n-\n ; It can also support extended post-inc expressions, but combine doesn't\n ; try these....\n ; It doesn't seem worth adding peepholes for anything but the most common\n@@ -9594,21 +9378,6 @@\n   \"str%?\\\\t%2, [%0], %1\"\n )\n \n-(define_peephole\n-  [(set (match_operand:HI 0 \"s_register_operand\" \"=r\")\n-\t(mem:HI (match_operand:SI 1 \"s_register_operand\" \"+r\")))\n-   (set (match_dup 1)\n-\t(plus:SI (match_dup 1) (match_operand:SI 2 \"index_operand\" \"rJ\")))]\n-  \"TARGET_ARM\n-   && !BYTES_BIG_ENDIAN\n-   && !TARGET_MMU_TRAPS\n-   && !arm_arch4\n-   && REGNO (operands[0]) != REGNO(operands[1])\n-   && (GET_CODE (operands[2]) != REG\n-       || REGNO(operands[0]) != REGNO (operands[2]))\"\n-  \"ldr%?\\\\t%0, [%1], %2\\\\t%@ loadhi\"\n-)\n-\n (define_peephole\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n \t(mem:SI (match_operand:SI 1 \"s_register_operand\" \"+r\")))"}, {"sha": "1be5ea1fa85ccd68742b9bee059a6cc8160838e3", "filename": "gcc/config/arm/coff.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Fcoff.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Fcoff.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fcoff.h?ref=61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler.\n    For ARM with COFF object format.\n-   Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2002, 2003\n+   Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2002, 2003, 2004\n    Free Software Foundation, Inc.\n    Contributed by Doug Evans (devans@cygnus.com).\n    \n@@ -31,11 +31,11 @@\n #define TARGET_VERSION fputs (\" (ARM/coff)\", stderr)\n \n #undef  TARGET_DEFAULT\n-#define TARGET_DEFAULT (ARM_FLAG_SOFT_FLOAT | ARM_FLAG_APCS_32 | ARM_FLAG_APCS_FRAME)\n+#define TARGET_DEFAULT (ARM_FLAG_SOFT_FLOAT | ARM_FLAG_APCS_FRAME)\n \n #ifndef MULTILIB_DEFAULTS\n #define MULTILIB_DEFAULTS \\\n-  { \"marm\", \"mlittle-endian\", \"msoft-float\", \"mapcs-32\", \"mno-thumb-interwork\" }\n+  { \"marm\", \"mlittle-endian\", \"msoft-float\", \"mno-thumb-interwork\" }\n #endif\n \f\n /* This is COFF, but prefer stabs.  */"}, {"sha": "3bb9b02e8cb74244856db6884f157593a3632ae2", "filename": "gcc/config/arm/crtn.asm", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Fcrtn.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Fcrtn.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fcrtn.asm?ref=61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d", "patch": "@@ -1,4 +1,4 @@\n-#   Copyright (C) 2001 Free Software Foundation, Inc.\n+#   Copyright (C) 2001, 2004 Free Software Foundation, Inc.\n #   Written By Nick Clifton\n # \n # This file is free software; you can redistribute it and/or modify it\n@@ -60,13 +60,9 @@\n \t\n #if defined __THUMB_INTERWORK__ || defined __thumb__\n \tbx\tlr\n-#else\n-#ifdef __APCS_26__\n-\tmovs\tpc, lr\n #else\n \tmov\tpc, lr\n #endif\n-#endif\n .endm\n \t\t\n \t"}, {"sha": "dae8acdfdf29f7120678e263a1df7e0a408b5d52", "filename": "gcc/config/arm/elf.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Felf.h?ref=61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d", "patch": "@@ -108,12 +108,12 @@\n #endif\n \n #ifndef TARGET_DEFAULT\n-#define TARGET_DEFAULT (ARM_FLAG_SOFT_FLOAT | ARM_FLAG_APCS_32 | ARM_FLAG_APCS_FRAME)\n+#define TARGET_DEFAULT (ARM_FLAG_SOFT_FLOAT | ARM_FLAG_APCS_FRAME)\n #endif\n \n #ifndef MULTILIB_DEFAULTS\n #define MULTILIB_DEFAULTS \\\n-  { \"marm\", \"mlittle-endian\", \"msoft-float\", \"mapcs-32\", \"mno-thumb-interwork\", \"fno-leading-underscore\" }\n+  { \"marm\", \"mlittle-endian\", \"msoft-float\", \"mno-thumb-interwork\", \"fno-leading-underscore\" }\n #endif\n \f\n #define TARGET_ASM_FILE_START_APP_OFF true"}, {"sha": "c36ce4b9d4d2e2a99d8659e21fc428b7f92af250", "filename": "gcc/config/arm/lib1funcs.asm", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Flib1funcs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Flib1funcs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Flib1funcs.asm?ref=61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d", "patch": "@@ -60,7 +60,7 @@ Boston, MA 02111-1307, USA.  */\n #define LSYM(x) x\n #endif\n \n-/* Function end macros.  Variants for 26 bit APCS and interworking.  */\n+/* Function end macros.  Variants for interworking.  */\n \n @ This selects the minimum architecture level required.\n #define __ARM_ARCH__ 3\n@@ -87,12 +87,7 @@ Boston, MA 02111-1307, USA.  */\n \n /* How to return from a function call depends on the architecture variant.  */\n \n-#ifdef __APCS_26__\n-\n-# define RET\t\tmovs\tpc, lr\n-# define RETc(x)\tmov##x##s\tpc, lr\n-\n-#elif (__ARM_ARCH__ > 4) || defined(__ARM_ARCH_4T__)\n+#if (__ARM_ARCH__ > 4) || defined(__ARM_ARCH_4T__)\n \n # define RET\t\tbx\tlr\n # define RETc(x)\tbx##x\tlr\n@@ -112,13 +107,7 @@ Boston, MA 02111-1307, USA.  */\n /* Don't pass dirn, it's there just to get token pasting right.  */\n \n .macro\tRETLDM\tregs=, cond=, dirn=ia\n-#ifdef __APCS_26__\n-\t.ifc \"\\regs\",\"\"\n-\tldm\\cond\\dirn\tsp!, {pc}^\n-\t.else\n-\tldm\\cond\\dirn\tsp!, {\\regs, pc}^\n-\t.endif\n-#elif defined (__INTERWORKING__)\n+#if defined (__INTERWORKING__)\n \t.ifc \"\\regs\",\"\"\n \tldr\\cond\tlr, [sp], #4\n \t.else"}, {"sha": "616921b20c3f4e6b13ecb4dcbf4295bbb73c6b75", "filename": "gcc/config/arm/linux-elf.h", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Flinux-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Flinux-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Flinux-elf.h?ref=61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d", "patch": "@@ -30,19 +30,16 @@\n /* Do not assume anything about header files.  */\n #define NO_IMPLICIT_EXTERN_C\n \n-/* Default is to use APCS-32 mode.  */\n #undef  TARGET_DEFAULT\n-#define TARGET_DEFAULT (ARM_FLAG_APCS_32 | ARM_FLAG_MMU_TRAPS)\n+#define TARGET_DEFAULT (0)\n \n #define SUBTARGET_CPU_DEFAULT TARGET_CPU_arm6\n \n #define SUBTARGET_EXTRA_LINK_SPEC \" -m armelf_linux -p\"\n \n #undef  MULTILIB_DEFAULTS\n #define MULTILIB_DEFAULTS \\\n-\t{ \"marm\", \"mlittle-endian\", \"mhard-float\", \"mapcs-32\", \"mno-thumb-interwork\" }\n-\n-#define CPP_APCS_PC_DEFAULT_SPEC \"-D__APCS_32__\"\n+\t{ \"marm\", \"mlittle-endian\", \"mhard-float\", \"mno-thumb-interwork\" }\n \n /* The GNU C++ standard library requires that these macros be defined.  */\n #undef CPLUSPLUS_CPP_SPEC"}, {"sha": "32251bcec5403732e3c758711226160c2fb4ff7f", "filename": "gcc/config/arm/netbsd-elf.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Fnetbsd-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Fnetbsd-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fnetbsd-elf.h?ref=61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d", "patch": "@@ -35,10 +35,8 @@\n /* Default it to use ATPCS with soft-VFP.  */\n #undef TARGET_DEFAULT\n #define TARGET_DEFAULT\t\t\t\\\n-  (ARM_FLAG_APCS_32\t\t\t\\\n-   | ARM_FLAG_SOFT_FLOAT\t\t\\\n+  (ARM_FLAG_SOFT_FLOAT\t\t\t\\\n    | ARM_FLAG_APCS_FRAME\t\t\\\n-   | ARM_FLAG_MMU_TRAPS\t\t\t\\\n    | TARGET_ENDIAN_DEFAULT)\n \n #undef ARM_DEFAULT_ABI"}, {"sha": "326fabaf8b251b99eb50567dc4321779aba2fcaf", "filename": "gcc/config/arm/netbsd.h", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Fnetbsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Fnetbsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fnetbsd.h?ref=61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d", "patch": "@@ -35,9 +35,8 @@\n /* ARM6 family default cpu.  */\n #define SUBTARGET_CPU_DEFAULT TARGET_CPU_arm6\n \n-/* Default is to use APCS-32 mode.  */\n #undef TARGET_DEFAULT\n-#define TARGET_DEFAULT (ARM_FLAG_APCS_32 | ARM_FLAG_SOFT_FLOAT | ARM_FLAG_APCS_FRAME)\n+#define TARGET_DEFAULT (ARM_FLAG_SOFT_FLOAT | ARM_FLAG_APCS_FRAME)\n \n /* Some defines for CPP.\n    arm32 is the NetBSD port name, so we always define arm32 and __arm32__.  */\n@@ -56,13 +55,9 @@\n \n #undef CPP_SPEC\n #define CPP_SPEC \"\\\n-%(cpp_cpu_arch) %(cpp_apcs_pc) %(cpp_float) %(cpp_endian) %(netbsd_cpp_spec) \\\n+%(cpp_cpu_arch) %(cpp_float) %(cpp_endian) %(netbsd_cpp_spec) \\\n \"\n \n-/* Because TARGET_DEFAULT sets ARM_FLAG_APCS_32 */\n-#undef CPP_APCS_PC_DEFAULT_SPEC\n-#define CPP_APCS_PC_DEFAULT_SPEC \"-D__APCS_32__\"\n-\n /* Because TARGET_DEFAULT sets ARM_FLAG_SOFT_FLOAT */\n #undef CPP_FLOAT_DEFAULT_SPEC\n #define CPP_FLOAT_DEFAULT_SPEC \"-D__SOFTFP__\""}, {"sha": "8eea54ce1f2a8538ccddd793b540ee56cfa16a1a", "filename": "gcc/config/arm/pe.h", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Fpe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Fpe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fpe.h?ref=61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d", "patch": "@@ -1,5 +1,6 @@\n /* Definitions of target machine for GNU compiler, for ARM with PE obj format.\n-   Copyright (C) 1995, 1996, 1999, 2000, 2002, 2003 Free Software Foundation, Inc.\n+   Copyright (C) 1995, 1996, 1999, 2000, 2002, 2003, 2004\n+   Free Software Foundation, Inc.\n    Contributed by Doug Evans (dje@cygnus.com).\n    \n    This file is part of GCC.\n@@ -65,18 +66,12 @@\n   N_(\"Ignore dllimport attribute for functions\") },\t\t\\\n { \"no-nop-fun-dllimport\",\t- TARGET_FLAG_NOP_FUN, \"\" },\n \n-/* Defaulting to APCS-26 support is a legacy issue.   It has been done\n-   that way for a long time, so changing it will probably break some\n-   people's worlds.  Support for APCS-32 is now enabled as a multilib,\n-   and at some point in the future APCS-32 may become the default.\n-   Possibly when chips that support APCS-26 are no longer made.  */\n-\n #undef  TARGET_DEFAULT\n #define TARGET_DEFAULT\t(ARM_FLAG_SOFT_FLOAT | TARGET_FLAG_NOP_FUN)\n \n #undef  MULTILIB_DEFAULTS\n #define MULTILIB_DEFAULTS \\\n-  { \"marm\", \"mlittle-endian\", \"msoft-float\", \"mapcs-26\", \"mno-thumb-interwork\" }  \n+  { \"marm\", \"mlittle-endian\", \"msoft-float\", \"mno-thumb-interwork\" }  \n \f\n #undef  WCHAR_TYPE\n #define WCHAR_TYPE \t\"short unsigned int\""}, {"sha": "e30c0fcc326cdbb0366e1554e06e22563fbefb25", "filename": "gcc/config/arm/semi.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Fsemi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Fsemi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fsemi.h?ref=61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d", "patch": "@@ -39,7 +39,7 @@\n #endif\n \n #ifndef TARGET_DEFAULT\n-#define TARGET_DEFAULT (ARM_FLAG_APCS_32 | ARM_FLAG_APCS_FRAME)\n+#define TARGET_DEFAULT (ARM_FLAG_APCS_FRAME)\n #endif\n \n #ifndef SUBTARGET_EXTRA_SPECS\n@@ -70,6 +70,3 @@\n %{mthumb-interwork:-mthumb-interwork} \\\n %(subtarget_extra_asm_spec)\"\n #endif\n-\n-#undef  CPP_APCS_PC_DEFAULT_SPEC\n-#define CPP_APCS_PC_DEFAULT_SPEC \"-D__APCS_32__\""}, {"sha": "8e660836890b9464abcc6a3ef85eec31eaf92657", "filename": "gcc/config/arm/semiaof.h", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Fsemiaof.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Fsemiaof.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fsemiaof.h?ref=61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler.  ARM on semi-hosted platform\n    AOF Syntax assembler.\n-   Copyright (C) 1995, 1996, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1995, 1996, 1997, 2004 Free Software Foundation, Inc.\n    Contributed by Richard Earnshaw (richard.earnshaw@armltd.co.uk)\n \n    This file is part of GCC.\n@@ -26,17 +26,13 @@\n \tbuiltin_define_std (\"semi\");\t\t\\\n     } while (0)\n \n-#define ASM_SPEC \"%{g -g} -arch 4 \\\n--apcs 3%{mapcs-32:/32bit}%{mapcs-26:/26bit}%{!mapcs-26:%{!macps-32:/32bit}}\"\n+#define ASM_SPEC \"%{g -g} -arch 4 -apcs 3/32bit\"\n \n #define LIB_SPEC \"%{Eb: armlib_h.32b%s}%{!Eb: armlib_h.32l%s}\"\n \n #define TARGET_VERSION fputs (\" (ARM/semi-hosted)\", stderr);\n \n-#define TARGET_DEFAULT ARM_FLAG_APCS_32\n+#define TARGET_DEFAULT (0)\n \n /* The Norcroft C library defines size_t as \"unsigned int\".  */\n #define SIZE_TYPE \"unsigned int\"\n-\n-#undef CPP_APCS_PC_DEFAULT_SPEC\n-#define CPP_APCS_PC_DEFAULT_SPEC \"-D__APCS_32__\""}, {"sha": "c834220b7fe34aadde17580812f46b76f4bac465", "filename": "gcc/config/arm/t-arm-elf", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Ft-arm-elf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Ft-arm-elf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-arm-elf?ref=61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d", "patch": "@@ -13,7 +13,7 @@ MULTILIB_MATCHES     =\n # MULTILIB_OPTIONS    += mcpu=ep9312\n # MULTILIB_DIRNAMES   += ep9312\n # MULTILIB_EXCEPTIONS += *mthumb/*mcpu=ep9312*\n-\t\n+# \t\n # MULTILIB_OPTIONS     += mlittle-endian/mbig-endian\n # MULTILIB_DIRNAMES    += le be\n # MULTILIB_MATCHES     += mbig-endian=mbe mlittle-endian=mle\n@@ -22,13 +22,8 @@ MULTILIB_MATCHES     =\n # MULTILIB_DIRNAMES   += fpu soft\n # MULTILIB_EXCEPTIONS += *mthumb/*mhard-float*\n # \n-# MULTILIB_OPTIONS    += mapcs-32/mapcs-26\n-# MULTILIB_DIRNAMES   += 32bit 26bit\n-# MULTILIB_EXCEPTIONS += *mthumb/*mapcs-26*\n-# \n # MULTILIB_OPTIONS    += mno-thumb-interwork/mthumb-interwork\n # MULTILIB_DIRNAMES   += normal interwork\n-# MULTILIB_EXCEPTIONS += *mapcs-26/*mthumb-interwork*\n # \n # MULTILIB_OPTIONS    += fno-leading-underscore/fleading-underscore\n # MULTILIB_DIRNAMES   += elf under"}, {"sha": "b2697e66e674abe6028755587510f8b49756e61c", "filename": "gcc/config/arm/t-linux", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Ft-linux", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Ft-linux", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-linux?ref=61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d", "patch": "@@ -9,11 +9,6 @@ LIB1ASMFUNCS = _udivsi3 _divsi3 _umodsi3 _modsi3 _dvmd_lnx\n # MULTILIB_OPTIONS = mhard-float/msoft-float\n # MULTILIB_DIRNAMES = hard-float soft-float\n \n-# If you want to build both APCS variants as multilib options this is how\n-# to do it.\n-# MULTILIB_OPTIONS += mapcs-32/mapcs-26\n-# MULTILIB_DIRNAMES += apcs-32 apcs-26\n-\n # EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o\n \n # LIBGCC = stmp-multilib"}, {"sha": "ba4ea10e402d9bfa421c8969e0f413367f886af8", "filename": "gcc/config/arm/t-pe", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Ft-pe", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Ft-pe", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-pe?ref=61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d", "patch": "@@ -24,8 +24,8 @@ pe.o: $(srcdir)/config/arm/pe.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n   $(RTL_H) output.h flags.h $(TREE_H) expr.h toplev.h $(TM_P_H)\n \t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(srcdir)/config/arm/pe.c\n \n-MULTILIB_OPTIONS = mhard-float mthumb mapcs-32\n-MULTILIB_DIRNAMES = fpu thumb apcs32\n+MULTILIB_OPTIONS = mhard-float mthumb\n+MULTILIB_DIRNAMES = fpu thumb\n \n LIBGCC = stmp-multilib\n INSTALL_LIBGCC = install-multilib"}, {"sha": "f5d8f1a6f5c88ca30b504e8cf64b1d070efc20db", "filename": "gcc/config/arm/t-semi", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Ft-semi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Ft-semi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-semi?ref=61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d", "patch": "@@ -29,9 +29,9 @@ dp-bit.c: $(srcdir)/config/fp-bit.c\n \tcat $(srcdir)/config/fp-bit.c >> dp-bit.c\n \techo '#endif' >> dp-bit.c\n \n-MULTILIB_OPTIONS = msoft-float mapcs-26 mbig-endian mwords-little-endian\n-MULTILIB_DIRNAMES = soft apcs26 big wlittle\n-MULTILIB_EXCEPTIONS = *mapcs-26/*mbig-endian* mwords-little-endian *mapcs-26/mwords-little-endian msoft-float/mwords-little-endian\n+MULTILIB_OPTIONS = msoft-float mbig-endian mwords-little-endian\n+MULTILIB_DIRNAMES = soft big wlittle\n+MULTILIB_EXCEPTIONS = mwords-little-endian msoft-float/mwords-little-endian\n \n LIBGCC = stmp-multilib\n INSTALL_LIBGCC = install-multilib"}, {"sha": "c59fc54b89e071ae3c9e72449e0513a9351957f0", "filename": "gcc/config/arm/t-wince-pe", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Ft-wince-pe", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Ft-wince-pe", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-wince-pe?ref=61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d", "patch": "@@ -24,9 +24,9 @@ pe.o: $(srcdir)/config/arm/pe.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n   $(RTL_H) output.h flags.h $(TREE_H) expr.h toplev.h $(TM_P_H)\n \t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(srcdir)/config/arm/pe.c\n \n-MULTILIB_OPTIONS = mhard-float mapcs-26\n-MULTILIB_DIRNAMES = fpu apcs26\n-# Note - Thumb multilib omitted because Thumb apcs32 support for\n+MULTILIB_OPTIONS = mhard-float\n+MULTILIB_DIRNAMES = fpu\n+# Note - Thumb multilib omitted because Thumb support for\n # arm-wince-pe target does not appear to be working in binutils\n # yet... \n # MULTILIB_OPTIONS += thumb"}, {"sha": "93abfe20450436fef31b9f77730c318ad0dc8dc3", "filename": "gcc/config/arm/t-xscale-coff", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Ft-xscale-coff", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Ft-xscale-coff", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-xscale-coff?ref=61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d", "patch": "@@ -25,7 +25,6 @@ MULTILIB_DIRNAMES    = be\n MULTILIB_EXCEPTIONS  = \n MULTILIB_MATCHES     = mbig-endian=mbe mlittle-endian=mle\n \n-# Note XScale does not support 26 bit APCS.\n # Note XScale does not support hard FP\n \n MULTILIB_OPTIONS    += mthumb-interwork"}, {"sha": "51c89487c6c74c5db6d2aa8b1293bcb71c537b21", "filename": "gcc/config/arm/t-xscale-elf", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Ft-xscale-elf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Ft-xscale-elf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-xscale-elf?ref=61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d", "patch": "@@ -25,7 +25,6 @@ MULTILIB_DIRNAMES    = be\n MULTILIB_EXCEPTIONS  = \n MULTILIB_MATCHES     = mbig-endian=mbe mlittle-endian=mle\n \n-# Note XScale does not support 26 bit APCS.\n # Note XScale does not support hard FP\n \n MULTILIB_OPTIONS    += mthumb-interwork"}, {"sha": "4bfb64b86781c0c90c272268fa69eb874c4834bd", "filename": "gcc/config/arm/uclinux-elf.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Fuclinux-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Fuclinux-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fuclinux-elf.h?ref=61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d", "patch": "@@ -1,5 +1,5 @@\n /* Definitions for ARM running ucLinux using ELF\n-   Copyright (C) 1999, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2001, 2004 Free Software Foundation, Inc.\n    Contributed by Philip Blundell <pb@nexus.co.uk>\n \n    This file is part of GCC.\n@@ -27,4 +27,4 @@\n #define TARGET_VERSION fputs (\" (ARM/ELF ucLinux)\", stderr);\n \n #undef  TARGET_DEFAULT\n-#define TARGET_DEFAULT (ARM_FLAG_APCS_32 | ARM_FLAG_MMU_TRAPS | ARM_FLAG_SINGLE_PIC_BASE)\n+#define TARGET_DEFAULT (ARM_FLAG_SINGLE_PIC_BASE)"}, {"sha": "4ef81356162771ee1bf0752bdfe75cf07816f2f5", "filename": "gcc/config/arm/unknown-elf.h", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Funknown-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Funknown-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Funknown-elf.h?ref=61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d", "patch": "@@ -28,9 +28,9 @@\n #define TARGET_VERSION\tfputs (\" (ARM/ELF)\", stderr);\n #endif\n \n-/* Default to using APCS-32 and software floating point.  */\n+/* Default to using software floating point.  */\n #ifndef TARGET_DEFAULT\n-#define TARGET_DEFAULT\t(ARM_FLAG_SOFT_FLOAT | ARM_FLAG_APCS_32 | ARM_FLAG_APCS_FRAME)\n+#define TARGET_DEFAULT\t(ARM_FLAG_SOFT_FLOAT | ARM_FLAG_APCS_FRAME)\n #endif\n \n /* Now we define the strings used to build the spec file.  */\n@@ -85,10 +85,6 @@\n     }\t\t\t\t\t\t\t\t\t\\\n   while (0)\n \n-#ifndef CPP_APCS_PC_DEFAULT_SPEC\n-#define CPP_APCS_PC_DEFAULT_SPEC\t\"-D__APCS_32__\"\n-#endif\n-     \n #ifndef SUBTARGET_CPU_DEFAULT\n #define SUBTARGET_CPU_DEFAULT \t\tTARGET_CPU_arm7tdmi\n #endif"}, {"sha": "e6db09aa8905f4e7b265f63d8e6bc346a4da50ab", "filename": "gcc/config/arm/vxworks.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Fvxworks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Fvxworks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvxworks.h?ref=61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GCC,\n    for ARM with targetting the VXWorks run time environment. \n-   Copyright (C) 1999, 2000, 2003 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2000, 2003, 2004 Free Software Foundation, Inc.\n \n    Contributed by: Mike Stump <mrs@wrs.com>\n    Brought up to date by CodeSourcery, LLC.\n@@ -46,16 +46,16 @@ Boston, MA 02111-1307, USA.  */\n \n #undef  CC1_SPEC\n #define CC1_SPEC\t\t\t\t\t\t\t\\\n-\"%{t4:        -mapcs-32 -mlittle-endian -march=armv4 ;\t\t\t\\\n-   t4be:      -mapcs-32 -mbig-endian -march=armv4 ;\t\t\t\\\n+\"%{t4:        -mlittle-endian -march=armv4 ;\t\t\t\\\n+   t4be:      -mbig-endian -march=armv4 ;\t\t\t\\\n    t4t:       -mthumb -mthumb-interwork -mlittle-endian -march=armv4t ;\t\\\n    t4tbe:     -mthumb -mthumb-interwork -mbig-endian -march=armv4t ;\t\\\n-   t5:        -mapcs-32 -mlittle-endian -march=armv5 ;\t\t\t\\\n-   t5be:      -mapcs-32 -mbig-endian -march=armv5 ;\t\t\t\\\n+   t5:        -mlittle-endian -march=armv5 ;\t\t\t\\\n+   t5be:      -mbig-endian -march=armv5 ;\t\t\t\\\n    t5t:       -mthumb -mthumb-interwork -mlittle-endian -march=armv5 ;\t\\\n    t5tbe:     -mthumb -mthumb-interwork -mbig-endian -march=armv5 ;\t\\\n-   txscale:   -mapcs-32 -mlittle-endian -mcpu=xscale ;\t\t\t\\\n-   txscalebe: -mapcs-32 -mbig-endian -mcpu=xscale ;\t\t\t\\\n+   txscale:   -mlittle-endian -mcpu=xscale ;\t\t\t\\\n+   txscalebe: -mbig-endian -mcpu=xscale ;\t\t\t\\\n             : -march=armv4}\"\n \n /* The -Q options from svr4.h aren't understood and must be removed.  */"}, {"sha": "143ed204b078cbc3fd3363087c1bf1042ce8b99d", "filename": "gcc/config/arm/wince-pe.h", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Fwince-pe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fconfig%2Farm%2Fwince-pe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fwince-pe.h?ref=61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler, for ARM with WINCE-PE obj format.\n-   Copyright (C) 2003 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n    Contributed by Nick Clifton <nickc@redhat.com>\n    \n    This file is part of GCC.\n@@ -19,11 +19,9 @@\n    the Free Software Foundation, 59 Temple Place - Suite 330,\n    Boston, MA 02111-1307, USA.  */\n \n-/* Override arm/pe.h's default apcs26 support.  */\n-\n #undef  TARGET_DEFAULT\n-#define TARGET_DEFAULT\t(ARM_FLAG_APCS_32 | ARM_FLAG_SOFT_FLOAT | TARGET_FLAG_NOP_FUN)\n+#define TARGET_DEFAULT\t(ARM_FLAG_SOFT_FLOAT | TARGET_FLAG_NOP_FUN)\n \n #undef  MULTILIB_DEFAULTS\n #define MULTILIB_DEFAULTS \\\n-  { \"marm\", \"mlittle-endian\", \"msoft-float\", \"mapcs-32\", \"mno-thumb-interwork\" }  \n+  { \"marm\", \"mlittle-endian\", \"msoft-float\", \"mno-thumb-interwork\" }  "}, {"sha": "5b8556634cdd8bb98226017535000427aa6f0070", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=61f0ccffa36f96fc1a1f20fd8d4ec2bfb911140d", "patch": "@@ -386,13 +386,11 @@ in the following sections.\n @emph{ARM Options}\n @gccoptlist{-mapcs-frame  -mno-apcs-frame @gol\n -mabi=@var{name} @gol\n--mapcs-26  -mapcs-32 @gol\n -mapcs-stack-check  -mno-apcs-stack-check @gol\n -mapcs-float  -mno-apcs-float @gol\n -mapcs-reentrant  -mno-apcs-reentrant @gol\n -msched-prolog  -mno-sched-prolog @gol\n -mlittle-endian  -mbig-endian  -mwords-little-endian @gol\n--malignment-traps  -mno-alignment-traps @gol\n -mfloat-abi=@var{name}  soft-float  -mhard-float  -mfpe @gol\n -mthumb-interwork  -mno-thumb-interwork @gol\n -mcpu=@var{name}  -march=@var{name}  -mfpu=@var{name}  @gol\n@@ -6791,20 +6789,6 @@ leaf functions.  The default is @option{-mno-apcs-frame}.\n @opindex mapcs\n This is a synonym for @option{-mapcs-frame}.\n \n-@item -mapcs-26\n-@opindex mapcs-26\n-Generate code for a processor running with a 26-bit program counter,\n-and conforming to the function calling standards for the APCS 26-bit\n-option.  This option replaces the @option{-m2} and @option{-m3} options\n-of previous releases of the compiler.\n-\n-@item -mapcs-32\n-@opindex mapcs-32\n-Generate code for a processor running with a 32-bit program counter,\n-and conforming to the function calling standards for the APCS 32-bit\n-option.  This option replaces the @option{-m6} option of previous releases\n-of the compiler.\n-\n @ignore\n @c not currently implemented\n @item -mapcs-stack-check\n@@ -6901,38 +6885,6 @@ option should only be used if you require compatibility with code for\n big-endian ARM processors generated by versions of the compiler prior to\n 2.8.\n \n-@item -malignment-traps\n-@opindex malignment-traps\n-Generate code that will not trap if the MMU has alignment traps enabled.\n-On ARM architectures prior to ARMv4, there were no instructions to\n-access half-word objects stored in memory.  However, when reading from\n-memory a feature of the ARM architecture allows a word load to be used,\n-even if the address is unaligned, and the processor core will rotate the\n-data as it is being loaded.  This option tells the compiler that such\n-misaligned accesses will cause a MMU trap and that it should instead\n-synthesize the access as a series of byte accesses.  The compiler can\n-still use word accesses to load half-word data if it knows that the\n-address is aligned to a word boundary.\n-\n-This option is ignored when compiling for ARM architecture 4 or later,\n-since these processors have instructions to directly access half-word\n-objects in memory.\n-\n-@item -mno-alignment-traps\n-@opindex mno-alignment-traps\n-Generate code that assumes that the MMU will not trap unaligned\n-accesses.  This produces better code when the target instruction set\n-does not have half-word memory operations (i.e.@: implementations prior to\n-ARMv4).\n-\n-Note that you cannot use this option to access unaligned word objects,\n-since the processor will only fetch one 32-bit aligned object from\n-memory.\n-\n-The default setting for most targets is @option{-mno-alignment-traps}, since\n-this produces better code when there are no half-word memory\n-instructions available.\n-\n @item -mshort-load-bytes\n @itemx -mno-short-load-words\n @opindex mshort-load-bytes"}]}