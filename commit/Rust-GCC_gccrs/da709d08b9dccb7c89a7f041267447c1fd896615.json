{"sha": "da709d08b9dccb7c89a7f041267447c1fd896615", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGE3MDlkMDhiOWRjY2I3Yzg5YTdmMDQxMjY3NDQ3YzFmZDg5NjYxNQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-01-03T15:41:36Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-01-03T15:41:36Z"}, "message": "sem_ch4.adb (Has_Fixed_Op): New predicate in Check_Arithmetic_Pair...\n\n\t* sem_ch4.adb (Has_Fixed_Op): New predicate in Check_Arithmetic_Pair,\n\tto determine whether one of the operands is a fixed-point type for\n\twhich a user-defined multiplication or division operation might be\n\tdefined.\n\n\t* sem_res.adb (Valid_Conversion): The legality rules for conversions\n\tof access types are symmetric in Ada 2005: either designated type can\n\tbe unconstrained.\n\nFrom-SVN: r92849", "tree": {"sha": "c686442352752fe7e5ecb5206614ab5bfcb175de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c686442352752fe7e5ecb5206614ab5bfcb175de"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/da709d08b9dccb7c89a7f041267447c1fd896615", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da709d08b9dccb7c89a7f041267447c1fd896615", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da709d08b9dccb7c89a7f041267447c1fd896615", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da709d08b9dccb7c89a7f041267447c1fd896615/comments", "author": null, "committer": null, "parents": [{"sha": "416cd96afe0f7c597b89448a0f8481050eb30675", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/416cd96afe0f7c597b89448a0f8481050eb30675", "html_url": "https://github.com/Rust-GCC/gccrs/commit/416cd96afe0f7c597b89448a0f8481050eb30675"}], "stats": {"total": 113, "additions": 92, "deletions": 21}, "files": [{"sha": "417c8c7c49054eab91d3cb9e0c428f609593c89d", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 78, "deletions": 15, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da709d08b9dccb7c89a7f041267447c1fd896615/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da709d08b9dccb7c89a7f041267447c1fd896615/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=da709d08b9dccb7c89a7f041267447c1fd896615", "patch": "@@ -205,20 +205,21 @@ package body Sem_Ch4 is\n    --  the operand is not an inappropriate entity kind, return False.\n \n    procedure Operator_Check (N : Node_Id);\n-   --  Verify that an operator has received some valid interpretation.\n-   --  If none was found, determine whether a use clause would make the\n-   --  operation legal. The variable Candidate_Type (defined in Sem_Type) is\n-   --  set for every type compatible with the operator, even if the operator\n-   --  for the type is not directly visible. The routine uses this type to emit\n-   --  a more informative message.\n+   --  Verify that an operator has received some valid interpretation. If none\n+   --  was found, determine whether a use clause would make the operation\n+   --  legal. The variable Candidate_Type (defined in Sem_Type) is set for\n+   --  every type compatible with the operator, even if the operator for the\n+   --  type is not directly visible. The routine uses this type to emit a more\n+   --  informative message.\n \n    procedure Process_Implicit_Dereference_Prefix\n-     (E : Entity_Id; P : Node_Id);\n-   --  Called when P is the prefix of an implicit dereference, denoting\n-   --  an object E. If in semantics only mode (-gnatc), record that P\n-   --  is a reference to E. Normally, such a reference is generated only\n-   --  when the implicit dereference is expanded into an explicit one.\n-   --  E may be empty, in which case this procedure does nothing.\n+     (E : Entity_Id;\n+      P : Node_Id);\n+   --  Called when P is the prefix of an implicit dereference, denoting an\n+   --  object E. If in semantics only mode (-gnatc), record that is a\n+   --  reference to E. Normally, such a reference is generated only when the\n+   --  implicit dereference is expanded into an explicit one. E may be empty,\n+   --  in which case this procedure does nothing.\n \n    procedure Remove_Abstract_Operations (N : Node_Id);\n    --  Ada 2005: implementation of AI-310. An abstract non-dispatching\n@@ -2519,13 +2520,15 @@ package body Sem_Ch4 is\n \n          else\n             Error_Msg_NW (Warn_On_Dereference, \"?implicit dereference\", N);\n+\n             if Is_Entity_Name (Name) then\n                Pent := Entity (Name);\n             elsif Nkind (Name) = N_Selected_Component\n               and then Is_Entity_Name (Selector_Name (Name))\n             then\n                Pent := Entity (Selector_Name (Name));\n             end if;\n+\n             Process_Implicit_Dereference_Prefix (Pent, Name);\n          end if;\n \n@@ -3267,9 +3270,60 @@ package body Sem_Ch4 is\n    is\n       Op_Name : constant Name_Id   := Chars (Op_Id);\n \n+      function Has_Fixed_Op (Typ : Entity_Id; Op : Entity_Id) return Boolean;\n+      --  Check whether the fixed-point type Typ has a user-defined operator\n+      --  (multiplication or division) that should hide the corresponding\n+      --  predefined operator. Used to implement Ada 2005 AI-264, to make\n+      --  such operators more visible and therefore useful.\n+\n       function Specific_Type (T1, T2 : Entity_Id) return Entity_Id;\n       --  Get specific type (i.e. non-universal type if there is one)\n \n+      ------------------\n+      -- Has_Fixed_Op --\n+      ------------------\n+\n+      function Has_Fixed_Op (Typ : Entity_Id; Op : Entity_Id) return Boolean is\n+         Ent : Entity_Id;\n+         F1  : Entity_Id;\n+         F2  : Entity_Id;\n+\n+      begin\n+         --  The operation is treated as primitive if it is declared in the\n+         --  same scope as the type, and therefore on the same entity chain.\n+\n+         Ent := Next_Entity (Typ);\n+         while Present (Ent) loop\n+            if Chars (Ent) = Chars (Op) then\n+               F1 := First_Formal (Ent);\n+               F2 := Next_Formal (F1);\n+\n+               --  The operation counts as primitive if either operand or\n+               --  result are of the given type, and both operands are fixed\n+               --  point types.\n+\n+               if (Etype (F1) = Typ\n+                    and then Is_Fixed_Point_Type (Etype (F2)))\n+\n+                 or else\n+                   (Etype (F2) = Typ\n+                     and then Is_Fixed_Point_Type (Etype (F1)))\n+\n+                 or else\n+                   (Etype (Ent) = Typ\n+                     and then Is_Fixed_Point_Type (Etype (F1))\n+                     and then Is_Fixed_Point_Type (Etype (F2)))\n+               then\n+                  return True;\n+               end if;\n+            end if;\n+\n+            Next_Entity (Ent);\n+         end loop;\n+\n+         return False;\n+      end Has_Fixed_Op;\n+\n       -------------------\n       -- Specific_Type --\n       -------------------\n@@ -3308,8 +3362,11 @@ package body Sem_Ch4 is\n             --  If the operator is given in  functional notation, it comes\n             --  from source and Fixed_As_Integer cannot apply.\n \n-            if Nkind (N) not in N_Op\n-              or else not Treat_Fixed_As_Integer (N)\n+            if (Nkind (N) not in N_Op\n+                 or else not Treat_Fixed_As_Integer (N))\n+              and then\n+                (not (Ada_Version >= Ada_05 and then Has_Fixed_Op (T1, Op_Id))\n+                  or else Nkind (Parent (N)) = N_Type_Conversion)\n             then\n                Add_One_Interp (N, Op_Id, Universal_Fixed);\n             end if;\n@@ -3318,6 +3375,9 @@ package body Sem_Ch4 is\n            and then (Nkind (N) not in N_Op\n                       or else not Treat_Fixed_As_Integer (N))\n            and then T1 = Universal_Real\n+           and then\n+             (not (Ada_Version >= Ada_05 and then Has_Fixed_Op (T1, Op_Id))\n+               or else Nkind (Parent (N)) = N_Type_Conversion)\n          then\n             Add_One_Interp (N, Op_Id, Universal_Fixed);\n \n@@ -4362,11 +4422,14 @@ package body Sem_Ch4 is\n    -----------------------------------------\n \n    procedure Process_Implicit_Dereference_Prefix\n-     (E : Entity_Id; P : Entity_Id)\n+     (E : Entity_Id;\n+      P : Entity_Id)\n    is\n       Ref : Node_Id;\n+\n    begin\n       if Operating_Mode = Check_Semantics and then Present (E) then\n+\n          --  We create a dummy reference to E to ensure that the reference\n          --  is not considered as part of an assignment (an implicit\n          --  dereference can never assign to its prefix). The Comes_From_Source"}, {"sha": "b89f82b0097b77a786ff8627b02272d2c78d77dd", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da709d08b9dccb7c89a7f041267447c1fd896615/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da709d08b9dccb7c89a7f041267447c1fd896615/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=da709d08b9dccb7c89a7f041267447c1fd896615", "patch": "@@ -7112,17 +7112,25 @@ package body Sem_Res is\n                      N, Base_Type (Opnd));\n                   return False;\n \n-               elsif not Subtypes_Statically_Match (Target, Opnd)\n-                  and then (not Has_Discriminants (Target)\n-                             or else Is_Constrained (Target))\n+               --  Ada 2005 AI-384: legality rule is symmetric in both\n+               --  designated types. The conversion is legal (with possible\n+               --  constraint check) if either designated type is\n+               --  unconstrained.\n+\n+               elsif Subtypes_Statically_Match (Target, Opnd)\n+                 or else\n+                   (Has_Discriminants (Target)\n+                     and then\n+                      (not Is_Constrained (Opnd)\n+                        or else not Is_Constrained (Target)))\n                then\n+                  return True;\n+\n+               else\n                   Error_Msg_NE\n                     (\"target designated subtype not compatible with }\",\n                      N, Opnd);\n                   return False;\n-\n-               else\n-                  return True;\n                end if;\n             end if;\n          end;"}]}