{"sha": "c5d67833be0e181b1a8017117d3dff128079dd98", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzVkNjc4MzNiZTBlMTgxYjFhODAxNzExN2QzZGZmMTI4MDc5ZGQ5OA==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1995-05-04T18:11:46Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1995-05-04T18:11:46Z"}, "message": "Clean up whitespace, comments, etc.\n\n(TARGET_SH, RTL_BIT, DT_BIT, C_BIT, R_BIT, TARGET_DUMP_RTL,\nTARGET_DUMP_R, TARGET_CDUMP): Delete.\n(TARGET_SWITCHES): Delete -mR, -mc, -mr options.\n(CONST_DOUBLE_OK_FOR_LETTER_P): Delete 'G' contraint.\n(FUNCTION_VALUE): Simplify.\n(REG_OK_FOR_PRE_POST_P, IS_INDEX): Delete.\n(BASE_REGISTER_RTX_P, INDEX_REGISTER_RTX_P): Rewrite to allow\nSUBREGs.\n(GO_IF_LEGITIMATE_INDEX): Delete unused REGNO argument.\n(GO_IF_LEGITIMATE_ADDRESS): Use BASE_REGISTER_RTX_P instead of\nREG_OK_FOR_PRE_POST_P.  Don't accept PRE_INC or POST_DEC addresses.\n(PREDICATE_CODES, PROMOTE_MODE): Define.\n\nFrom-SVN: r9570", "tree": {"sha": "31e6ad0676c3cb40f2e60a343a2d957925d74c58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/31e6ad0676c3cb40f2e60a343a2d957925d74c58"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5d67833be0e181b1a8017117d3dff128079dd98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5d67833be0e181b1a8017117d3dff128079dd98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5d67833be0e181b1a8017117d3dff128079dd98", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5d67833be0e181b1a8017117d3dff128079dd98/comments", "author": null, "committer": null, "parents": [{"sha": "3595d104fa983e9760fe9c4de303993f400aca18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3595d104fa983e9760fe9c4de303993f400aca18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3595d104fa983e9760fe9c4de303993f400aca18"}], "stats": {"total": 430, "additions": 198, "deletions": 232}, "files": [{"sha": "fd19ef387c1f5af205922a61607f59fcfcc659d0", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 198, "deletions": 232, "changes": 430, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d67833be0e181b1a8017117d3dff128079dd98/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d67833be0e181b1a8017117d3dff128079dd98/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=c5d67833be0e181b1a8017117d3dff128079dd98", "patch": "@@ -20,15 +20,12 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n \n-/* Run-time Target Specification.  */\n-#define TARGET_SH\n-\n-#define TARGET_VERSION  \\\n+#define TARGET_VERSION \\\n   fputs (\" (Hitachi SH)\", stderr);\n \n /* Generate SDB debugging information.  */\n \n-#define SDB_DEBUGGING_INFO  1\n+#define SDB_DEBUGGING_INFO\n \n /* Output DBX (stabs) debugging information if doing -gstabs.  */\n \n@@ -51,7 +48,6 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n /* Show we can debug even without a frame pointer.  */\n #define CAN_DEBUG_WITHOUT_FP\n \n-\n #define CONDITIONAL_REGISTER_USAGE\t\t\t\t\\\n   /* Hitachi saves and restores mac registers on call.  */\t\\\n   if (TARGET_HITACHI)\t\t\t\t\t\t\\\n@@ -64,22 +60,26 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n extern int target_flags;\n #define ISIZE_BIT      \t(1<<1)\n-#define RTL_BIT        \t(1<<4)\n-#define DT_BIT         \t(1<<5)\n #define DALIGN_BIT     \t(1<<6)\n #define SH0_BIT\t       \t(1<<7)\n #define SH1_BIT\t       \t(1<<8)\n #define SH2_BIT\t       \t(1<<9)\n #define SH3_BIT\t       \t(1<<10)\n-#define C_BIT\t       \t(1<<11)\n-#define R_BIT     \t(1<<12)\n #define SPACE_BIT \t(1<<13)\n #define BIGTABLE_BIT  \t(1<<14)\n #define HITACHI_BIT     (1<<22)\n #define PADSTRUCT_BIT  (1<<28)\n #define LITTLE_ENDIAN_BIT (1<<29)\n \n+/* Nonzero if we should dump out instruction size info.  */\n+#define TARGET_DUMPISIZE  (target_flags & ISIZE_BIT)\n+\n+/* Nonzero to align doubles on 64 bit boundaries.  */\n+#define TARGET_ALIGN_DOUBLE (target_flags & DALIGN_BIT)\n+\n /* Nonzero if we should generate code using type 0 insns.  */\n+/* ??? Is there such a thing as SH0?  If not, we should delete all\n+   references to it.  */\n #define TARGET_SH0 (target_flags & SH0_BIT)\n \n /* Nonzero if we should generate code using type 1 insns.  */\n@@ -94,24 +94,9 @@ extern int target_flags;\n /* Nonzero if we should generate smaller code rather than faster code.  */\n #define TARGET_SMALLCODE   (target_flags & SPACE_BIT)\n \n-/* Nonzero if we should dump out instruction size info.  */\n-#define TARGET_DUMPISIZE  (target_flags & ISIZE_BIT)\n-\n-/* Nonzero if we should dump the rtl in the assembly file.  */\n-#define TARGET_DUMP_RTL\t  (target_flags & RTL_BIT)\n-\n-/* Nonzero if we should dump the rtl somewher else.  */\n-#define TARGET_DUMP_R\t  (target_flags & R_BIT)\n-\n-/* Nonzero to align doubles on 64 bit boundaries.  */\n-#define TARGET_ALIGN_DOUBLE (target_flags & DALIGN_BIT)\n-\n /* Nonzero to use long jump tables.  */\n #define TARGET_BIGTABLE     (target_flags & BIGTABLE_BIT)\n \n-/* Nonzero if combine dumping wanted.  */\n-#define TARGET_CDUMP (target_flags & C_BIT)\n-\n /* Nonzero if using Hitachi's calling convention.  */\n #define TARGET_HITACHI \t\t(target_flags & HITACHI_BIT)\n \n@@ -122,25 +107,23 @@ extern int target_flags;\n    who are still relying on it.  It may be deleted in the future.  */\n #define TARGET_PADSTRUCT       (target_flags & PADSTRUCT_BIT)\n \n+/* Nonzero if generating code for a little endian SH.  */\n #define TARGET_LITTLE_ENDIAN     (target_flags & LITTLE_ENDIAN_BIT)\n \n #define TARGET_SWITCHES  \t\t\t\\\n-{ {\"0\",\t        (SH0_BIT) },\t\t\t\\\n-  {\"1\",\t        (SH1_BIT) },\t\t\t\\\n-  {\"2\",\t        (SH2_BIT) },\t\t\t\\\n-  {\"3\",\t        (SH3_BIT|SH2_BIT) },\t\t\\\n-  {\"3l\",        (SH3_BIT|SH2_BIT|LITTLE_ENDIAN_BIT)},\t\\\n-  {\"R\",  \t(R_BIT) },\t\t\t\\\n-  {\"b\",\t\t(-LITTLE_ENDIAN_BIT) },  \t\\\n-  {\"bigtable\", \t(BIGTABLE_BIT)},\t\t\\\n-  {\"c\",  \t(C_BIT) },\t\t\t\\\n-  {\"dalign\",  \t(DALIGN_BIT) },\t\t\t\\\n-  {\"hitachi\",\t(HITACHI_BIT) },\t\t\\\n-  {\"isize\", \t(ISIZE_BIT) },\t\t\t\\\n-  {\"l\",\t\t(LITTLE_ENDIAN_BIT) },  \t\\\n-  {\"padstruct\",(PADSTRUCT_BIT) },    \t\t\\\n-  {\"r\",  \t(RTL_BIT) },\t\t\t\\\n-  {\"space\", \t(SPACE_BIT) },\t\t\t\\\n+{ {\"0\",\t        SH0_BIT},\t\t\t\\\n+  {\"1\",\t        SH1_BIT},\t\t\t\\\n+  {\"2\",\t        SH2_BIT},\t\t\t\\\n+  {\"3\",\t        SH3_BIT|SH2_BIT},\t\t\\\n+  {\"3l\",        SH3_BIT|SH2_BIT|LITTLE_ENDIAN_BIT},\t\\\n+  {\"b\",\t\t-LITTLE_ENDIAN_BIT},  \t\t\\\n+  {\"bigtable\", \tBIGTABLE_BIT},\t\t\t\\\n+  {\"dalign\",  \tDALIGN_BIT},\t\t\t\\\n+  {\"hitachi\",\tHITACHI_BIT},\t\t\t\\\n+  {\"isize\", \tISIZE_BIT},\t\t\t\\\n+  {\"l\",\t\tLITTLE_ENDIAN_BIT},  \t\t\\\n+  {\"padstruct\", PADSTRUCT_BIT},    \t\t\\\n+  {\"space\", \tSPACE_BIT},\t\t\t\\\n   {\"\",   \tTARGET_DEFAULT} \t\t\\\n }\n \n@@ -156,18 +139,22 @@ do {\t\t\t\t\t\t\t\t\\\n   if (TARGET_SH3)\t\t\t\t\t\t\\\n     sh_cpu = CPU_SH3;\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\\\n-  /*  We *MUST* always define optimize since we *HAVE* to run   \\\n-      shorten branches to get correct code.  */                 \\\n-                                                                \\\n-  optimize = 1;                                                 \\\n+  /* We *MUST* always define optimize since we *HAVE* to run\t\\\n+     shorten branches to get correct code.  */\t\t\t\\\n+  /* ??? This is obsolete, since now shorten branches is no\t\\\n+     longer required by the SH, and is always run once even\t\\\n+     when not optimizing.  Changing this now might be\t\t\\\n+     confusing though.  */\t\t\t\t\t\\\n+  optimize = 1;\t\t\t\t\t\t\t\\\n   flag_delayed_branch = 1;\t\t\t\t\t\\\n-  /* But never run scheduling before reload, since than can     \\\n-     break global alloc, and generates slower code anyway due   \\\n-     to the pressure on R0.  */                                 \\\n-  flag_schedule_insns = 0;            \t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+  /* But never run scheduling before reload, since that can\t\\\n+     break global alloc, and generates slower code anyway due\t\\\n+     to the pressure on R0.  */\t\t\t\t\t\\\n+  flag_schedule_insns = 0;\t\t\t\t\t\\\n } while (0)\n \f\n-/* Target machine storage Layout.  */\n+/* Target machine storage layout.  */\n \n /* Define to use software floating point emulator for REAL_ARITHMETIC and\n    decimal <-> binary conversion.  */\n@@ -178,15 +165,13 @@ do {\t\t\t\t\t\t\t\t\\\n \n #define BITS_BIG_ENDIAN  0\n \n-\n /* Define this if most significant byte of a word is the lowest numbered.  */\n #define BYTES_BIG_ENDIAN (TARGET_LITTLE_ENDIAN == 0)\n \n /* Define this if most significant word of a multiword number is the lowest\n    numbered.  */\n #define WORDS_BIG_ENDIAN (TARGET_LITTLE_ENDIAN == 0)\n \n-\n /* Define this to set the endianness to use in libgcc2.c, which can\n    not depend on target_flags.  */\n #if defined(__LITTLE_ENDIAN__)\n@@ -233,7 +218,7 @@ do {\t\t\t\t\t\t\t\t\\\n #define FASTEST_ALIGNMENT 32\n \n /* Make strings word-aligned so strcpy from constants will be faster.  */\n-#define CONSTANT_ALIGNMENT(EXP, ALIGN)  \\\n+#define CONSTANT_ALIGNMENT(EXP, ALIGN)\t\\\n   ((TREE_CODE (EXP) == STRING_CST\t\\\n     && (ALIGN) < FASTEST_ALIGNMENT)\t\\\n     ? FASTEST_ALIGNMENT : (ALIGN))\n@@ -259,7 +244,7 @@ do {\t\t\t\t\t\t\t\t\\\n \n         r0\t\targ return\n \tr1..r3          scratch\n-\tr4-r7\t\targs in\n+\tr4..r7\t\targs in\n \tr8..r13\t\tcall saved\n \tr14\t\tframe pointer/call saved\n \tr15\t\tstack pointer\n@@ -291,13 +276,6 @@ do {\t\t\t\t\t\t\t\t\\\n    Mach register is fixed 'cause it's only 10 bits wide for SH1.\n    It is 32 bits wide for SH2.  */\n \n- /*  r0  r1  r2  r3\n-     r4  r5  r6  r7\n-     r8  r9  r10 r11\n-     r12 r13 r14 r15\n-     ap  pr  t   gbr\n-     mh   ml */\n-\n #define FIXED_REGISTERS  \t\\\n   { 0,  0,  0,  0, \t\t\\\n     0,  0,  0,  0, \t\t\\\n@@ -306,21 +284,13 @@ do {\t\t\t\t\t\t\t\t\\\n     1,  1,  1,  1, \t\t\\\n     1,  1}\n \n-\n /* 1 for registers not available across function calls.\n    These must include the FIXED_REGISTERS and also any\n    registers that can be used without being saved.\n    The latter must include the registers where values are returned\n    and the register where structure-value addresses are passed.\n    Aside from that, you can include as many other registers as you like.  */\n \n- /*  r0  r1  r2  r3\n-     r4  r5  r6  r7\n-     r8  r9  r10 r11\n-     r12 r13 r14 r15\n-     ap  pr  t   gbr\n-     mh  ml */\n-\n #define CALL_USED_REGISTERS \t\\\n    { 1,  1,  1,  1,\t\t\\\n      1,  1,  1,  1, \t\t\\\n@@ -336,14 +306,14 @@ do {\t\t\t\t\t\t\t\t\\\n \n    On the SH regs are UNITS_PER_WORD bits wide.  */\n \n-#define HARD_REGNO_NREGS(REGNO, MODE)  \\\n+#define HARD_REGNO_NREGS(REGNO, MODE) \\\n    (((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n \n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n    We can allow any mode in any general register.  The special registers\n    only allow SImode.  Don't allow any mode in the PR.  */\n \n-#define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n+#define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\\\n   (SPECIAL_REG (REGNO) ? (MODE) == SImode\t\\\n    : (REGNO) == PR_REG ? 0\t\t\t\\\n    : 1)\n@@ -391,7 +361,6 @@ do {\t\t\t\t\t\t\t\t\\\n  { ARG_POINTER_REGNUM,   STACK_POINTER_REGNUM},\t\\\n  { ARG_POINTER_REGNUM,   FRAME_POINTER_REGNUM},}\n \n-\n /* Given FROM and TO register numbers, say whether this elimination\n    is allowed.  */\n #define CAN_ELIMINATE(FROM, TO) \\\n@@ -420,7 +389,6 @@ do {\t\t\t\t\t\t\t\t\\\n \n /*#define STRUCT_VALUE ((rtx)0)*/\n \n-\n /* Don't default to pcc-struct-return, because we have already specified\n    exactly how to return structures in the RETURN_IN_MEMORY macro.  */\n \n@@ -466,7 +434,7 @@ enum reg_class\n #define N_REG_CLASSES  (int) LIM_REG_CLASSES\n \n /* Give names of register classes as strings for dump file.  */\n-#define REG_CLASS_NAMES  \\\n+#define REG_CLASS_NAMES\t\\\n {\t\t\t\\\n   \"NO_REGS\",\t\t\\\n   \"R0_REGS\",\t\t\\\n@@ -481,7 +449,7 @@ enum reg_class\n    This is an initializer for a vector of HARD_REG_SET\n    of length N_REG_CLASSES.  */\n \n-#define REG_CLASS_CONTENTS      \\\n+#define REG_CLASS_CONTENTS\t\\\n {\t\t\t\t\\\n   0x000000,  /* NO_REGS      */\t\\\n   0x000001,  /* R0_REGS      */\t\\\n@@ -507,7 +475,7 @@ extern int regno_reg_class[];\n #define SMALL_REGISTER_CLASSES\n \n /* The order in which register should be allocated.  */\n-#define REG_ALLOC_ORDER  \\\n+#define REG_ALLOC_ORDER \\\n   { 1,2,3,7,6,5,4,0,8,9,10,11,12,13,14,15,16,17,18,19,20,21 }\n \n /* The class value for index registers, and the one for base regs.  */\n@@ -520,8 +488,7 @@ extern enum reg_class reg_class_from_letter[];\n \n #define REG_CLASS_FROM_LETTER(C) \\\n    ( (C) >= 'a' && (C) <= 'z' ? reg_class_from_letter[(C)-'a'] : NO_REGS )\n-\n-\n+\f\n /* The letters I, J, K, L and M in a register constraint string\n    can be used to stand for particular ranges of immediate operands.\n    This macro defines what the ranges are.\n@@ -533,27 +500,23 @@ extern enum reg_class reg_class_from_letter[];\n \tM: constant 1\n \tN: constant 0  */\n \n-\n #define CONST_OK_FOR_I(VALUE) (((int)(VALUE))>= -128 && ((int)(VALUE)) <= 127)\n #define CONST_OK_FOR_K(VALUE) ((VALUE)==1||(VALUE)==2||(VALUE)==8||(VALUE)==16)\n #define CONST_OK_FOR_L(VALUE) (((int)(VALUE))>=    0 && ((int)(VALUE)) <= 255)\n #define CONST_OK_FOR_M(VALUE) ((VALUE)==1)\n #define CONST_OK_FOR_N(VALUE) ((VALUE)==0)\n-#define CONST_OK_FOR_LETTER_P(VALUE, C)     \\\n-     ((C) == 'I' ? CONST_OK_FOR_I (VALUE)   \\\n-    : (C) == 'K' ? CONST_OK_FOR_K (VALUE)   \\\n-    : (C) == 'L' ? CONST_OK_FOR_L (VALUE)   \\\n-    : (C) == 'M' ? CONST_OK_FOR_M (VALUE)   \\\n-    : (C) == 'N' ? CONST_OK_FOR_N (VALUE)   \\\n+#define CONST_OK_FOR_LETTER_P(VALUE, C)\t\t\\\n+     ((C) == 'I' ? CONST_OK_FOR_I (VALUE)\t\\\n+    : (C) == 'K' ? CONST_OK_FOR_K (VALUE)\t\\\n+    : (C) == 'L' ? CONST_OK_FOR_L (VALUE)\t\\\n+    : (C) == 'M' ? CONST_OK_FOR_M (VALUE)\t\\\n+    : (C) == 'N' ? CONST_OK_FOR_N (VALUE)\t\\\n     : 0)\n \n /* Similar, but for floating constants, and defining letters G and H.\n    Here VALUE is the CONST_DOUBLE rtx itself.  */\n \n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C) \\\n-   ((C) == 'G' ? CONST_OK_FOR_I (CONST_DOUBLE_HIGH (VALUE)) \\\n-\t      && CONST_OK_FOR_I (CONST_DOUBLE_LOW (VALUE))  \\\n-    : 0)\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C) 0\n \n /* Given an rtx X being reloaded into a reg required to be\n    in class CLASS, return the class of reg to actually use.\n@@ -566,13 +529,13 @@ extern enum reg_class reg_class_from_letter[];\n    needed to represent mode MODE in a register of class CLASS.\n \n    On SH this is the size of MODE in words.  */\n-#define CLASS_MAX_NREGS(CLASS, MODE)  \\\n+#define CLASS_MAX_NREGS(CLASS, MODE) \\\n      ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \f\n /* Stack layout; function entry, exit and calling.  */\n \n-/* Define the number of register that can hold parameters.\n-   These two macros are used only in other macro definitions below.  */\n+/* Define the number of registers that can hold parameters.\n+   These three macros are used only in other macro definitions below.  */\n #define NPARM_REGS 4\n #define FIRST_PARM_REG 4\n #define FIRST_RET_REG  0\n@@ -615,23 +578,19 @@ extern enum reg_class reg_class_from_letter[];\n    otherwise, FUNC is 0.  */\n \n #define FUNCTION_VALUE(VALTYPE, FUNC) \\\n-  gen_rtx (REG, \\\n-\t   TYPE_MODE (VALTYPE) == BLKmode ? SImode : TYPE_MODE (VALTYPE), \\\n-\t   FIRST_RET_REG)\n+  gen_rtx (REG, TYPE_MODE (VALTYPE), FIRST_RET_REG)\n \n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n-#define LIBCALL_VALUE(MODE)  \\\n-    gen_rtx (REG, MODE, FIRST_RET_REG)\n+#define LIBCALL_VALUE(MODE)\tgen_rtx (REG, MODE, FIRST_RET_REG)\n \n /* 1 if N is a possible register number for a function value.\n    On the SH, only r0 can return results.  */\n-#define FUNCTION_VALUE_REGNO_P(REGNO)  \\\n-\t  ((REGNO) == FIRST_RET_REG)\n+#define FUNCTION_VALUE_REGNO_P(REGNO)\t((REGNO) == FIRST_RET_REG)\n \n /* 1 if N is a possible register number for function argument passing.  */\n \n-#define FUNCTION_ARG_REGNO_P(REGNO)  \\\n+#define FUNCTION_ARG_REGNO_P(REGNO) \\\n   ((REGNO) >= FIRST_PARM_REG && (REGNO) < (NPARM_REGS + FIRST_PARM_REG))\n \f\n /* Define a data type for recording info about an argument list\n@@ -647,7 +606,7 @@ extern enum reg_class reg_class_from_letter[];\n \n #define CUMULATIVE_ARGS  int\n \n-#define ROUND_ADVANCE(SIZE)\t\\\n+#define ROUND_ADVANCE(SIZE) \\\n   ((SIZE + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n /* Round a register number up to a proper boundary for an arg of mode\n@@ -661,15 +620,14 @@ extern enum reg_class reg_class_from_letter[];\n    && GET_MODE_UNIT_SIZE ((MODE)) > UNITS_PER_WORD) \t\t\\\n    ? ((X) + ((X) & 1)) : (X))\n \n-\n /* Initialize a variable CUM of type CUMULATIVE_ARGS\n    for a call to a function whose data type is FNTYPE.\n    For a library call, FNTYPE is 0.\n \n    On SH, the offset always starts at 0: the first parm reg is always\n    the same reg.  */\n \n-#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME)  \\\n+#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME) \\\n   ((CUM) = 0)\n \n /* Update the data in CUM to advance over an argument\n@@ -702,7 +660,7 @@ extern enum reg_class reg_class_from_letter[];\n    its data type forbids.  */\n \n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n-    sh_function_arg (CUM, MODE, TYPE, NAMED)\n+  sh_function_arg (CUM, MODE, TYPE, NAMED)\n \n extern struct rtx_def *sh_function_arg();\n \n@@ -758,7 +716,7 @@ extern int current_function_anonymous_args;\n {\t\t\t\t\t\t\\\n   fprintf ((FILE), \"\t.word\t0xd301\\n\");\t\\\n   fprintf ((FILE), \"\t.word\t0xdd02\\n\");\t\\\n-  fprintf ((FILE), \"\t.word\t0x4d2b\\n\");        \\\n+  fprintf ((FILE), \"\t.word\t0x4d2b\\n\");\t\\\n   fprintf ((FILE), \"\t.word\t0x200b\\n\");\t\\\n   fprintf ((FILE), \"\t.long\t0\\n\");\t\t\\\n   fprintf ((FILE), \"\t.long\t0\\n\");\t\t\\\n@@ -774,7 +732,7 @@ extern int current_function_anonymous_args;\n    FNADDR is an RTX for the address of the function's pure code.\n    CXT is an RTX for the static chain value for the function.  */\n \n-#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)  \\\n+#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   emit_move_insn (gen_rtx (MEM, SImode, plus_constant ((TRAMP), 8)),\t\\\n \t\t  (CXT));\t\t\t\t\t\t\\\n@@ -796,9 +754,9 @@ extern int current_function_anonymous_args;\n    Since they use reg_renumber, they are safe only once reg_renumber\n    has been allocated, which happens in local-alloc.c.  */\n \n-#define REGNO_OK_FOR_BASE_P(REGNO)  \\\n+#define REGNO_OK_FOR_BASE_P(REGNO) \\\n   ((REGNO) < PR_REG || (unsigned) reg_renumber[(REGNO)] < PR_REG)\n-#define REGNO_OK_FOR_INDEX_P(REGNO)   \\\n+#define REGNO_OK_FOR_INDEX_P(REGNO) \\\n   ((REGNO) == 0 || (unsigned) reg_renumber[(REGNO)] == 0)\n \n /* Maximum number of registers that can appear in a valid memory\n@@ -808,17 +766,15 @@ extern int current_function_anonymous_args;\n \n /* Recognize any constant value that is a valid address.  */\n \n-#define CONSTANT_ADDRESS_P(X) \t\\\n-  (GET_CODE (X) == LABEL_REF)\n+#define CONSTANT_ADDRESS_P(X)\t(GET_CODE (X) == LABEL_REF)\n \n /* Nonzero if the constant value X is a legitimate general operand.  */\n \n /* ??? Should modify this to accept CONST_DOUBLE, and then modify the\n    constant pool table code to fix loads of CONST_DOUBLEs.  If that doesn't\n-   work well, then we can at least handle 'G' constraint CONST_DOUBLEs\n-   here.  */\n-#define LEGITIMATE_CONSTANT_P(X) \\\n-  (GET_CODE(X) != CONST_DOUBLE /*&& GET_CODE(X) != LABEL_REF*/)\n+   work well, then we can at least handle simple CONST_DOUBLEs here\n+   such as 0.0.  */\n+#define LEGITIMATE_CONSTANT_P(X)\t(GET_CODE(X) != CONST_DOUBLE)\n \n /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n    and check its validity for a certain class.\n@@ -836,29 +792,25 @@ extern int current_function_anonymous_args;\n    or if it is a pseudo reg.  */\n #define REG_OK_FOR_BASE_P(X) \\\n   (REGNO (X) <= 16 || REGNO(X) >= FIRST_PSEUDO_REGISTER)\n+\n /* Nonzero if X is a hard reg that can be used as an index\n    or if it is a pseudo reg.  */\n-\n #define REG_OK_FOR_INDEX_P(X) \\\n   (REGNO (X) == 0 || REGNO(X) >= FIRST_PSEUDO_REGISTER)\n \n-#define REG_OK_FOR_PRE_POST_P(X) \\\n-  \t(REG_OK_FOR_BASE_P (X))\n-\n #else\n+\n /* Nonzero if X is a hard reg that can be used as a base reg.  */\n-#define REG_OK_FOR_BASE_P(X)\t\\\n+#define REG_OK_FOR_BASE_P(X) \\\n \tREGNO_OK_FOR_BASE_P (REGNO (X))\n \n /* Nonzero if X is a hard reg that can be used as an index.  */\n-#define REG_OK_FOR_INDEX_P(X) \t\\\n+#define REG_OK_FOR_INDEX_P(X) \\\n   \tREGNO_OK_FOR_INDEX_P (REGNO (X))\n \n-#define REG_OK_FOR_PRE_POST_P(X)  \\\n-\t(REGNO_OK_FOR_BASE_P (REGNO (X)))\n #endif\n \n-/* The Q is a pc relative load operand.  */\n+/* The 'Q' constraint is a pc relative load operand.  */\n #define EXTRA_CONSTRAINT_Q(OP)                          \t\t\\\n   (GET_CODE (OP) == MEM && \t\t\t\t\t\t\\\n    ((GET_CODE (XEXP (OP, 0)) == LABEL_REF)\t\t\t\t\\\n@@ -867,16 +819,9 @@ extern int current_function_anonymous_args;\n \t&& GET_CODE (XEXP (XEXP (XEXP (OP, 0), 0), 0)) == LABEL_REF\t\\\n \t&& GET_CODE (XEXP (XEXP (XEXP (OP, 0), 0), 1)) == CONST_INT)))\n \n-#define IS_INDEX(OP) \t\t\t\t\t\t\t\t\t\\\n-  ((GET_CODE (OP) == PLUS && \t\t\t\t\t\t\t\t\\\n-    (INDEX_REGISTER_RTX_P (XEXP (OP, 0)) && BASE_REGISTER_RTX_P (XEXP (OP, 1))) ||\t\\\n-    (INDEX_REGISTER_RTX_P (XEXP (OP, 1)) && BASE_REGISTER_RTX_P (XEXP (OP, 0)))))\n-\n-\n-\n-#define EXTRA_CONSTRAINT(OP, C)   \\\n-     ((C) == 'Q' ? EXTRA_CONSTRAINT_Q (OP)   \\\n-    : 0)\n+#define EXTRA_CONSTRAINT(OP, C)\t\t\\\n+  ((C) == 'Q' ? EXTRA_CONSTRAINT_Q (OP)\t\\\n+   : 0)\n \f\n /* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n    that is a valid memory address for an instruction.\n@@ -885,12 +830,17 @@ extern int current_function_anonymous_args;\n \n    The other macros defined here are used only in GO_IF_LEGITIMATE_ADDRESS.  */\n \n-#define BASE_REGISTER_RTX_P(X)  \\\n-  (GET_CODE (X) == REG && REG_OK_FOR_BASE_P (X))\n-\n-#define INDEX_REGISTER_RTX_P(X)  \\\n-  (GET_CODE (X) == REG && REG_OK_FOR_INDEX_P (X))\n+#define BASE_REGISTER_RTX_P(X)\t\t\t\t\\\n+  ((GET_CODE (X) == REG && REG_OK_FOR_BASE_P (X))\t\\\n+   || (GET_CODE (X) == SUBREG\t\t\t\t\\\n+       && GET_CODE (SUBREG_REG (X)) == REG\t\t\\\n+       && REG_OK_FOR_BASE_P (SUBREG_REG (X))))\n \n+#define INDEX_REGISTER_RTX_P(X)\t\t\t\t\\\n+  ((GET_CODE (X) == REG && REG_OK_FOR_INDEX_P (X))\t\\\n+   || (GET_CODE (X) == SUBREG\t\t\t\t\\\n+       && GET_CODE (SUBREG_REG (X)) == REG\t\t\\\n+       && REG_OK_FOR_INDEX_P (SUBREG_REG (X))))\n \n /* Jump to LABEL if X is a valid address RTX.  This must also take\n    REG_OK_STRICT into account when deciding about valid registers, but it uses\n@@ -906,10 +856,10 @@ extern int current_function_anonymous_args;\n    other operand is R0. GCC doesn't handle this very well, so we forgo\n    all of that.\n \n-   A legitimate index for a QI or HI is 0, SI and above can be any\n-   number 0..63.  */\n+   A legitimate index for a QI or HI is 0, SI can be any number 0..63,\n+   DI can be any number 0..60.  */\n \n-#define GO_IF_LEGITIMATE_INDEX(MODE, REGNO, OP, LABEL)  \t\t\\\n+#define GO_IF_LEGITIMATE_INDEX(MODE, OP, LABEL)  \t\t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n     if (GET_CODE (OP) == CONST_INT) \t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n@@ -918,32 +868,27 @@ extern int current_function_anonymous_args;\n       }\t\t\t\t\t\t\t\t\t\\\n   } while(0)\n \n-\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, LABEL)                  \\\n-{ \t\t\t\t\t\t\t\t  \\\n-  if (BASE_REGISTER_RTX_P (X))\t\t\t\t\t  \\\n-    goto LABEL;\t\t\t\t\t\t\t  \\\n-  else if ((GET_CODE (X) == POST_INC || GET_CODE (X) == PRE_DEC)  \\\n-\t   && GET_CODE (XEXP (X, 0)) == REG\t\t\t  \\\n-\t   && REG_OK_FOR_PRE_POST_P (XEXP (X, 0)))\t\t  \\\n-    goto LABEL;\t\t\t\t\t\t\t  \\\n-  else if (GET_CODE (X) == PLUS) \t  \t\t\t  \\\n-    {\t\t\t\t\t\t\t\t  \\\n-      rtx xop0 = XEXP(X,0);\t\t\t\t\t  \\\n-      rtx xop1 = XEXP(X,1);\t\t\t\t\t  \\\n-      if (GET_MODE_SIZE(MODE) <= 8 && BASE_REGISTER_RTX_P (xop0)) \\\n-\tGO_IF_LEGITIMATE_INDEX (MODE, REGNO (xop0), xop1, LABEL); \\\n-      if (GET_MODE_SIZE(MODE)<= 4) {\t\t\t\t  \\\n-\tif(BASE_REGISTER_RTX_P(xop1) &&\t\t\t \t  \\\n-\t   INDEX_REGISTER_RTX_P(xop0)) goto LABEL;\t\t  \\\n-\tif(INDEX_REGISTER_RTX_P(xop1) &&\t\t\t  \\\n-\t   BASE_REGISTER_RTX_P(xop0)) goto LABEL;\t\t  \\\n-      }\t\t\t\t\t\t\t \t  \\\n-    }\t\t\t\t\t\t\t\t  \\\n-  else if ((GET_CODE (X) == PRE_INC || GET_CODE (X) == POST_DEC)  \\\n-\t   && GET_CODE (XEXP (X, 0)) == REG\t\t\t  \\\n-\t   && REG_OK_FOR_PRE_POST_P (XEXP (X, 0)))\t\t  \\\n-    goto LABEL;                                                   \\\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, LABEL)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (BASE_REGISTER_RTX_P (X))\t\t\t\t\t\t\\\n+    goto LABEL;\t\t\t\t\t\t\t\t\\\n+  else if ((GET_CODE (X) == POST_INC || GET_CODE (X) == PRE_DEC)\t\\\n+\t   && BASE_REGISTER_RTX_P (XEXP (X, 0)))\t\t\t\\\n+    goto LABEL;\t\t\t\t\t\t\t\t\\\n+  else if (GET_CODE (X) == PLUS)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      rtx xop0 = XEXP (X, 0);\t\t\t\t\t\t\\\n+      rtx xop1 = XEXP (X, 1);\t\t\t\t\t\t\\\n+      if (GET_MODE_SIZE (MODE) <= 8 && BASE_REGISTER_RTX_P (xop0))\t\\\n+\tGO_IF_LEGITIMATE_INDEX (MODE, xop1, LABEL);\t\t\t\\\n+      if (GET_MODE_SIZE (MODE) <= 4)\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  if (BASE_REGISTER_RTX_P (xop1) && INDEX_REGISTER_RTX_P (xop0))\\\n+\t    goto LABEL;\t\t\t\t\t\t\t\\\n+\t  if (INDEX_REGISTER_RTX_P (xop1) && BASE_REGISTER_RTX_P (xop0))\\\n+\t    goto LABEL;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n }\n \f\n /* Try machine-dependent ways of modifying an illegitimate address\n@@ -963,10 +908,9 @@ extern int current_function_anonymous_args;\n \n /* Go to LABEL if ADDR (a legitimate address expression)\n    has an effect that depends on the machine mode it is used for.  */\n-#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)  \\\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n-  if (GET_CODE(ADDR) == PRE_DEC || GET_CODE(ADDR) == POST_DEC\t\t\\\n-      || GET_CODE(ADDR) == PRE_INC || GET_CODE(ADDR) == POST_INC)\t\\\n+  if (GET_CODE(ADDR) == PRE_DEC || GET_CODE(ADDR) == POST_INC)\t\t\\\n     goto LABEL;\t\t\t\t\t\t\t\t\\\n }\n \f\n@@ -1049,7 +993,7 @@ extern int current_function_anonymous_args;\n /* The relative costs of various types of constants.  Note that cse.c defines\n    REG = 1, SUBREG = 2, any node = (2 + sum of subnodes).  */\n \n-#define CONST_COSTS(RTX, CODE, OUTER_CODE)      \\\n+#define CONST_COSTS(RTX, CODE, OUTER_CODE)\t\\\n   case CONST_INT:\t\t\t\t\\\n     if (INTVAL (RTX) == 0)\t\t\t\\\n       return 0;\t\t\t\t\t\\\n@@ -1069,7 +1013,7 @@ extern int current_function_anonymous_args;\n \n #define RTX_COSTS(X, CODE, OUTER_CODE)\t\t\t\\\n   case AND:\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (andcosts (X));                \\\n+    return COSTS_N_INSNS (andcosts (X));\t\t\\\n   case MULT:\t\t\t\t\t\t\\\n     return COSTS_N_INSNS (multcosts (X));\t\t\\\n   case ASHIFT:\t\t\t\t\t\t\\\n@@ -1085,7 +1029,6 @@ extern int current_function_anonymous_args;\n   case FIX:\t\t\t\t\t\t\\\n     return 100;\n \n-\n /* The multiply insn on the SH1 and the divide insns on the SH1 and SH2\n    are actually function calls with some special constraints on arguments\n    and register usage.\n@@ -1120,7 +1063,7 @@ extern int current_function_anonymous_args;\n    On the SH it is hard to move into the T reg, but simple to load\n    from it.  */\n \n-#define REGISTER_MOVE_COST(SRCCLASS, DSTCLASS)  \\\n+#define REGISTER_MOVE_COST(SRCCLASS, DSTCLASS) \\\n \t(((DSTCLASS == T_REGS) || (DSTCLASS == PR_REG)) ? 10 : 1)\n \f\n /* Assembler output control.  */\n@@ -1146,24 +1089,24 @@ extern int current_function_anonymous_args;\n #define DTORS_SECTION_ASM_OP \t\t\"\\t.section\\t.dtors\\n\"\n #define INIT_SECTION_ASM_OP  \t\t\"\\t.section\\t.init\\n\"\n #define EXTRA_SECTIONS \t\t\tin_ctors, in_dtors\n-#define EXTRA_SECTION_FUNCTIONS                              \\\n-void\t\t\t\t\t\t\t     \\\n-ctors_section() \t\t\t\t\t     \\\n-{\t\t\t\t\t\t\t     \\\n-  if (in_section != in_ctors)\t\t\t\t     \\\n-    {\t\t\t\t\t\t\t     \\\n-      fprintf (asm_out_file, \"%s\\n\", CTORS_SECTION_ASM_OP);  \\\n-      in_section = in_ctors;\t\t\t\t     \\\n-    }\t\t\t\t\t\t\t     \\\n-}\t\t\t\t\t\t\t     \\\n-void\t\t\t\t\t\t\t     \\\n-dtors_section() \t\t\t\t\t     \\\n-{\t\t\t\t\t\t\t     \\\n-  if (in_section != in_dtors)\t\t\t\t     \\\n-    {\t\t\t\t\t\t\t     \\\n-      fprintf (asm_out_file, \"%s\\n\", DTORS_SECTION_ASM_OP);  \\\n-      in_section = in_dtors;\t\t\t\t     \\\n-    }\t\t\t\t\t\t\t     \\\n+#define EXTRA_SECTION_FUNCTIONS\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\\\n+ctors_section()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_ctors)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", CTORS_SECTION_ASM_OP);\t\\\n+      in_section = in_ctors;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\\\n+dtors_section()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_dtors)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", DTORS_SECTION_ASM_OP);\t\\\n+      in_section = in_dtors;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n }\n \n /* A C statement to output something to the assembler file to switch to section\n@@ -1174,10 +1117,10 @@ dtors_section() \t\t\t\t\t     \\\n #define ASM_OUTPUT_SECTION_NAME(FILE, DECL, NAME) \\\n    do { fprintf (FILE, \".section\\t%s\\n\", NAME); } while (0)\n \n-#define ASM_OUTPUT_CONSTRUCTOR(FILE,NAME)\t\\\n+#define ASM_OUTPUT_CONSTRUCTOR(FILE,NAME) \\\n    do { ctors_section();  fprintf(FILE,\"\\t.long\\t_%s\\n\", NAME); } while (0)\n \n-#define ASM_OUTPUT_DESTRUCTOR(FILE,NAME)\t\\\n+#define ASM_OUTPUT_DESTRUCTOR(FILE,NAME) \\\n    do {  dtors_section();  fprintf(FILE,\"\\t.long\\t_%s\\n\", NAME); } while (0)\n \n #undef DO_GLOBAL_CTORS_BODY\n@@ -1195,7 +1138,7 @@ dtors_section() \t\t\t\t\t     \\\n }\n \n #undef DO_GLOBAL_DTORS_BODY\n-#define DO_GLOBAL_DTORS_BODY                    \\\n+#define DO_GLOBAL_DTORS_BODY\t\t\t\\\n {\t\t\t\t\t\t\\\n   typedef (*pfunc)();\t\t\t\t\\\n   extern pfunc __dtors[];\t\t\t\\\n@@ -1207,14 +1150,12 @@ dtors_section() \t\t\t\t\t     \\\n     }\t\t\t\t\t\t\\\n }\n \n-\n #define ASM_OUTPUT_REG_PUSH(file, v) \\\n   fprintf (file, \"\\tmov.l\tr%s,-@r15\\n\", v);\n \n #define ASM_OUTPUT_REG_POP(file, v) \\\n   fprintf (file, \"\\tmov.l\t@r15+,r%s\\n\", v);\n \n-\n /* The assembler's names for the registers.  RFP need not always be used as\n    the Real framepointer; it can also be used as a normal general register.\n    Note that the name `fp' is horribly misleading since `fp' is in fact only\n@@ -1230,10 +1171,9 @@ dtors_section() \t\t\t\t\t     \\\n #define DBX_REGISTER_NUMBER(REGNO)  (REGNO)\n \n /* Output a label definition.  */\n-#define ASM_OUTPUT_LABEL(FILE,NAME)  \\\n+#define ASM_OUTPUT_LABEL(FILE,NAME) \\\n   do { assemble_name (FILE, NAME); fputs (\":\\n\", FILE); } while (0)\n \n-\n /* This is how to output an assembler line\n    that says to advance the location counter\n    to a multiple of 2**LOG bytes.  */\n@@ -1247,53 +1187,52 @@ dtors_section() \t\t\t\t\t     \\\n     ASM_OUTPUT_LABEL(STREAM, NAME)\n \n /* Output a globalising directive for a label.  */\n-#define ASM_GLOBALIZE_LABEL(STREAM,NAME)  \\\n-  (fprintf (STREAM, \"\\t.global\\t\"),\t  \\\n-   assemble_name (STREAM, NAME),\t  \\\n-   fputc ('\\n',STREAM))                   \\\n+#define ASM_GLOBALIZE_LABEL(STREAM,NAME)\t\\\n+  (fprintf (STREAM, \"\\t.global\\t\"),\t\t\\\n+   assemble_name (STREAM, NAME),\t\t\\\n+   fputc ('\\n',STREAM))\n \n /* Output a reference to a label.  */\n-#define ASM_OUTPUT_LABELREF(STREAM,NAME)  \\\n+#define ASM_OUTPUT_LABELREF(STREAM,NAME) \\\n   fprintf (STREAM, \"_%s\", NAME)\n \n /* Make an internal label into a string.  */\n-#define ASM_GENERATE_INTERNAL_LABEL(STRING, PREFIX, NUM)  \\\n+#define ASM_GENERATE_INTERNAL_LABEL(STRING, PREFIX, NUM) \\\n   sprintf (STRING, \"*%s%d\", PREFIX, NUM)\n \n /* Output an internal label definition.  */\n-#define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)\t\\\n+#define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM) \\\n   fprintf (FILE, \"%s%d:\\n\", PREFIX, NUM)\n \n /* #define ASM_OUTPUT_CASE_END(STREAM,NUM,TABLE)\t    */\n \n /* Construct a private name.  */\n-#define ASM_FORMAT_PRIVATE_NAME(OUTVAR,NAME,NUMBER)  \\\n-  ((OUTVAR) = (char *) alloca (strlen (NAME) + 10),  \\\n+#define ASM_FORMAT_PRIVATE_NAME(OUTVAR,NAME,NUMBER)\t\\\n+  ((OUTVAR) = (char *) alloca (strlen (NAME) + 10),\t\\\n    sprintf ((OUTVAR), \"%s.%d\", (NAME), (NUMBER)))\n \n /* Jump tables must be 32 bit aligned, no matter the size of the element.  */\n #define ASM_OUTPUT_CASE_LABEL(STREAM,PREFIX,NUM,TABLE) \\\n-    fprintf (STREAM, \"\\t.align 2\\n%s%d:\\n\",  PREFIX, NUM);\n+  fprintf (STREAM, \"\\t.align 2\\n%s%d:\\n\",  PREFIX, NUM);\n \n /* Output a relative address table.  */\n \n #define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM,VALUE,REL)  \t\t\t\\\n   if (TARGET_BIGTABLE) \t\t\t\t\t\t\t\\\n-\tfprintf (STREAM, \"\\t.long\tL%d-L%d\\n\", VALUE,REL); \t\\\n+    fprintf (STREAM, \"\\t.long\tL%d-L%d\\n\", VALUE,REL); \t\t\\\n   else\t\t\t\t\t\t\t\t\t\\\n-\tfprintf (STREAM, \"\\t.word\tL%d-L%d\\n\", VALUE,REL); \t\\\n+    fprintf (STREAM, \"\\t.word\tL%d-L%d\\n\", VALUE,REL); \t\t\\\n \n /* Output an absolute table element.  */\n \n #define ASM_OUTPUT_ADDR_VEC_ELT(STREAM,VALUE)  \t\t\t\t\\\n   if (TARGET_BIGTABLE) \t\t\t\t\t\t\t\\\n-\tfprintf (STREAM, \"\\t.long\tL%d\\n\", VALUE); \t\t\\\n+    fprintf (STREAM, \"\\t.long\tL%d\\n\", VALUE); \t\t\t\\\n   else\t\t\t\t\t\t\t\t\t\\\n-        fprintf (STREAM, \"\\t.word\tL%d\\n\", VALUE); \t\t\\\n+    fprintf (STREAM, \"\\t.word\tL%d\\n\", VALUE); \t\t\t\\\n \n /* Output various types of constants.  */\n \n-\n /* This is how to output an assembler line defining a `double'.  */\n \n #define ASM_OUTPUT_DOUBLE(FILE,VALUE)\t\t\t\\\n@@ -1302,9 +1241,8 @@ do { char dstr[30];\t\t\t\t\t\\\n      fprintf (FILE, \"\\t.double %s\\n\", dstr);\t\t\\\n    } while (0)\n \n-\n /* This is how to output an assembler line defining a `float' constant.  */\n-#define ASM_OUTPUT_FLOAT(FILE,VALUE)\t\t\\\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)\t\t\t\\\n do { char dstr[30];\t\t\t\t\t\\\n      REAL_VALUE_TO_DECIMAL ((VALUE), \"%.20e\", dstr);\t\\\n      fprintf (FILE, \"\\t.float %s\\n\", dstr);\t\t\\\n@@ -1315,9 +1253,9 @@ do { char dstr[30];\t\t\t\t\t\\\n    output_addr_const (STREAM, (EXP)),  \t\\\n    fputc ('\\n', STREAM))\n \n-#define ASM_OUTPUT_SHORT(STREAM, EXP)  \\\n-  (fprintf (STREAM, \"\\t.short\\t\"),     \\\n-   output_addr_const (STREAM, (EXP)),  \\\n+#define ASM_OUTPUT_SHORT(STREAM, EXP)\t\\\n+  (fprintf (STREAM, \"\\t.short\\t\"),\t\\\n+   output_addr_const (STREAM, (EXP)),\t\\\n    fputc ('\\n', STREAM))\n \n #define ASM_OUTPUT_CHAR(STREAM, EXP)  \t\\\n@@ -1331,13 +1269,13 @@ do { char dstr[30];\t\t\t\t\t\\\n /* This is how to output an assembler line\n    that says to advance the location counter by SIZE bytes.  */\n \n-#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n+#define ASM_OUTPUT_SKIP(FILE,SIZE) \\\n   fprintf (FILE, \"\\t.space %d\\n\", (SIZE))\n \n /* This says how to output an assembler line\n    to define a global common symbol.  */\n \n-#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)\t\\\n ( fputs (\"\\t.comm \", (FILE)),\t\t\t\\\n   assemble_name ((FILE), (NAME)),\t\t\\\n   fprintf ((FILE), \",%d\\n\", (SIZE)))\n@@ -1350,7 +1288,6 @@ do { char dstr[30];\t\t\t\t\t\\\n   assemble_name ((FILE), (NAME)),\t\t\t\\\n   fprintf ((FILE), \",%d\\n\", (SIZE)))\n \n-\n /* The assembler's parentheses characters.  */\n #define ASM_OPEN_PAREN \"(\"\n #define ASM_CLOSE_PAREN \")\"\n@@ -1365,9 +1302,9 @@ do { char dstr[30];\t\t\t\t\t\\\n #define TARGET_CR\t015\n \f\n /* Only perform branch elimination (by making instructions conditional) if\n-   we're optimising.  Otherwise it's of no use anyway.  */\n-#define FINAL_PRESCAN_INSN(INSN, OPVEC, NOPERANDS)  \\\n-     final_prescan_insn (INSN, OPVEC, NOPERANDS)\n+   we're optimizing.  Otherwise it's of no use anyway.  */\n+#define FINAL_PRESCAN_INSN(INSN, OPVEC, NOPERANDS) \\\n+  final_prescan_insn (INSN, OPVEC, NOPERANDS)\n \n /* Print operand X (an rtx) in assembler syntax to file FILE.\n    CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n@@ -1386,7 +1323,6 @@ extern struct rtx_def *sh_compare_op0;\n extern struct rtx_def *sh_compare_op1;\n extern struct rtx_def *prepare_scc_operands();\n \n-\n /* Which processor to schedule for.  The elements of the enumeration must\n    match exactly the cpu attribute in the sh.md file.  */\n \n@@ -1440,9 +1376,39 @@ extern int pragma_interrupt;\n \n /* Enable a bug fix for the shorten_branches pass.  */\n #define SHORTEN_WITH_ADJUST_INSN_LENGTH\n-\n-/* ??? Define CANONICALIZE_COMPARISON?  */\n-\n-/* ??? Define PREDICATE_CODES.  */\n-\n-/* ??? Define PROMOTE_MDOES?  */\n+\f\n+/* Define the codes that are matched by predicates in sh.c.  */\n+#define PREDICATE_CODES \\\n+  {\"arith_reg_operand\", {SUBREG, REG}},\t\t\t\t\t\\\n+  {\"arith_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\t\\\n+  {\"arith_reg_or_0_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n+  {\"logical_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n+  {\"general_movsrc_operand\", {SUBREG, REG, CONST_INT, MEM}},\t\t\\\n+  {\"general_movdst_operand\", {SUBREG, REG, CONST_INT, MEM}},\n+\n+/* Define this macro if it is advisable to hold scalars in registers\n+   in a wider mode than that declared by the program.  In such cases, \n+   the value is constrained to be within the bounds of the declared\n+   type, but kept valid in the wider mode.  The signedness of the\n+   extension may differ from that of the type.\n+\n+   Leaving the unsignedp unchanged gives better code than always setting it\n+   to 0.  This is despite the fact that we have only signed char and short\n+   load instructions.  */\n+#define PROMOTE_MODE(MODE, UNSIGNEDP, TYPE) \\\n+  if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\t\\\n+      && GET_MODE_SIZE (MODE) < UNITS_PER_WORD)\t\t\\\n+    MODE = SImode;\n+\n+/* PROMOTE_FUNCTION_ARGS and PROMOTE_FUNCTION_RETURN appear to have no\n+   effect, because all unprototyped char/shorts are already promoted to\n+   int, and because PROMOTE_PROTOTYPES causes all prototypes char/shorts\n+   to be promoted to it.  */\n+\n+/* ??? Define ACCUMULATE_OUTGOING_ARGS?  This is more efficient than pushing\n+   and poping arguments.  However, we do have push/pop instructions, and\n+   rather limited offsets (4 bits) in load/store instructions, so it isn't\n+   clear if this would give better code.  If implemented, should check for\n+   compatibility problems.  */\n+\n+/* ??? Define ADJUST_COSTS?  */"}]}