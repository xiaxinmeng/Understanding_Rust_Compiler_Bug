{"sha": "d8c4447d837d01e68fee9f34328b8472c6785149", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDhjNDQ0N2Q4MzdkMDFlNjhmZWU5ZjM0MzI4Yjg0NzJjNjc4NTE0OQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-08-24T19:44:48Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-08-24T19:44:48Z"}, "message": "pt.c (tsubst_decl): Move special case code for dealing with tricky friend templates here from ...\n\n\t* pt.c (tsubst_decl): Move special case code for dealing with\n\ttricky friend templates here from ...\n\t(regenerate_decl_from_template): Here.\n\nFrom-SVN: r21953", "tree": {"sha": "74fb0bb47f4792bd06b0de7aab21dc2e51ef28c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74fb0bb47f4792bd06b0de7aab21dc2e51ef28c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d8c4447d837d01e68fee9f34328b8472c6785149", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8c4447d837d01e68fee9f34328b8472c6785149", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8c4447d837d01e68fee9f34328b8472c6785149", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8c4447d837d01e68fee9f34328b8472c6785149/comments", "author": null, "committer": null, "parents": [{"sha": "6f77675fd9d508dfd431a888275f369bb30d89ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f77675fd9d508dfd431a888275f369bb30d89ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f77675fd9d508dfd431a888275f369bb30d89ab"}], "stats": {"total": 110, "additions": 68, "deletions": 42}, "files": [{"sha": "edd3764178d0eb944c0d6b07f708e52aef942397", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8c4447d837d01e68fee9f34328b8472c6785149/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8c4447d837d01e68fee9f34328b8472c6785149/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d8c4447d837d01e68fee9f34328b8472c6785149", "patch": "@@ -1,3 +1,9 @@\n+1998-08-24  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* pt.c (tsubst_decl): Move special case code for dealing with\n+\ttricky friend templates here from ...\n+\t(regenerate_decl_from_template): Here.\n+\n 1998-08-24  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* decl.c (start_decl): Remove redundant linkage check."}, {"sha": "f817896981fdb211d3e3b99ab5db5e0f4e6300fd", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 46, "deletions": 42, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8c4447d837d01e68fee9f34328b8472c6785149/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8c4447d837d01e68fee9f34328b8472c6785149/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=d8c4447d837d01e68fee9f34328b8472c6785149", "patch": "@@ -4863,6 +4863,8 @@ tsubst_decl (t, args, type, in_decl)\n \ttree argvec;\n \ttree gen_tmpl;\n \tint member;\n+\tint args_depth;\n+\tint parms_depth;\n \n \t/* Nobody should be tsubst'ing into non-template functions.  */\n \tmy_friendly_assert (DECL_TEMPLATE_INFO (t) != NULL_TREE, 0);\n@@ -4885,6 +4887,47 @@ tsubst_decl (t, args, type, in_decl)\n \t\tr = spec;\n \t\tbreak;\n \t      }\n+\n+\t    /* Here, we deal with the peculiar case:\n+\n+\t\t template <class T> struct S { \n+\t\t   template <class U> friend void f();\n+\t\t };\n+\t\t template <class U> friend void f() {}\n+\t\t template S<int>;\n+\t\t template void f<double>();\n+\n+\t       Here, the ARGS for the instantiation of will be {int,\n+\t       double}.  But, we only need as many ARGS as there are\n+\t       levels of template parameters in CODE_PATTERN.  We are\n+\t       careful not to get fooled into reducing the ARGS in\n+\t       situations like:\n+\n+\t\t template <class T> struct S { template <class U> void f(U); }\n+\t\t template <class T> template <> void S<T>::f(int) {}\n+\n+\t       which we can spot because the pattern will be a\n+\t       specialization in this case.  */\n+\t    args_depth = TMPL_ARGS_DEPTH (args);\n+\t    parms_depth = \n+\t      TMPL_PARMS_DEPTH (DECL_TEMPLATE_PARMS (DECL_TI_TEMPLATE (t))); \n+\t    if (args_depth > parms_depth\n+\t\t&& !DECL_TEMPLATE_SPECIALIZATION (t))\n+\t      {\n+\t\tmy_friendly_assert (DECL_FRIEND_P (t), 0);\n+\n+\t\tif (parms_depth > 1)\n+\t\t  {\n+\t\t    int i;\n+\n+\t\t    args = make_temp_vec (parms_depth);\n+\t\t    for (i = 0; i < parms_depth; ++i)\n+\t\t      TREE_VEC_ELT (args, i) = \n+\t\t\tTREE_VEC_ELT (args, i + (args_depth - parms_depth));\n+\t\t  }\n+\t\telse\n+\t\t  args = TREE_VEC_ELT (args, args_depth - parms_depth);\n+\t      }\n \t  }\n \telse\n \t  {\n@@ -7739,9 +7782,6 @@ regenerate_decl_from_template (decl, tmpl)\n   tree code_pattern;\n   tree new_decl;\n   tree gen_tmpl;\n-  tree subst_args;\n-  int args_depth;\n-  int parms_depth;\n   int unregistered;\n \n   args = DECL_TI_ARGS (decl);\n@@ -7760,51 +7800,15 @@ regenerate_decl_from_template (decl, tmpl)\n      register_specialization for it.  */\n   my_friendly_assert (unregistered, 0);\n \n-  /* Do the substitution to get the new declaration.  Normally, of\n-     course, we want the full set of ARGS.  However, one peculiar case\n-     is code like this: \n-\n-       template <class T> struct S { \n-\t template <class U> friend void f();\n-       };\n-       template <class U> friend void f() {}\n-       template S<int>;\n-       template void f<double>();\n-\n-     Here, the ARGS for the instantiation of will be {int, double}.\n-     But, we only need as many ARGS as there are levels of template\n-     parameters in CODE_PATTERN.  We are careful not to get fooled\n-     into reducing the ARGS in situations like:\n-\n-       template <class T> struct S { template <class U> void f(U); }\n-       template <class T> template <> void S<T>::f(int) {}\n-\n-     which we can spot because the innermost template args for the\n-     CODE_PATTERN don't use any template parameters.  */\n-  args_depth = TMPL_ARGS_DEPTH (args);\n-  parms_depth = \n-    TMPL_PARMS_DEPTH (DECL_TEMPLATE_PARMS (DECL_TI_TEMPLATE (code_pattern)));\n-  if (args_depth > parms_depth\n-      && !DECL_TEMPLATE_SPECIALIZATION (code_pattern))\n-    {\n-      int i;\n-\n-      subst_args = make_temp_vec (parms_depth);\n-      for (i = 0; i < parms_depth; ++i)\n-\tTREE_VEC_ELT (subst_args, i) = \n-\t  TREE_VEC_ELT (args, i + (args_depth - parms_depth));\n-    }\n-  else\n-    subst_args = args;\n-\n-  new_decl = tsubst (code_pattern, subst_args, NULL_TREE);\n+  /* Do the substitution to get the new declaration.  */\n+  new_decl = tsubst (code_pattern, args, NULL_TREE);\n \n   if (TREE_CODE (decl) == VAR_DECL)\n     {\n       /* Set up DECL_INITIAL, since tsubst doesn't.  */\n       pushclass (DECL_CONTEXT (decl), 2);\n       DECL_INITIAL (new_decl) = \n-\ttsubst_expr (DECL_INITIAL (code_pattern), subst_args, \n+\ttsubst_expr (DECL_INITIAL (code_pattern), args, \n \t\t     DECL_TI_TEMPLATE (decl));\n       popclass (1);\n     }"}, {"sha": "b1f173a4623bc1b7033b55df156a74f6e36fcb93", "filename": "gcc/testsuite/g++.old-deja/g++.pt/friend32.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8c4447d837d01e68fee9f34328b8472c6785149/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend32.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8c4447d837d01e68fee9f34328b8472c6785149/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend32.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend32.C?ref=d8c4447d837d01e68fee9f34328b8472c6785149", "patch": "@@ -0,0 +1,16 @@\n+// Build don't link:\n+\n+template <class T, class U>\n+struct S {\n+  template <class X, class Y, class Z>\n+  friend X f(X, Y, Z);\n+};\n+\n+template class S<int, double>;\n+template char f(char, long, short);\n+template char* f(char*, long*, short*);\n+\n+template <class X, class Y, class Z>\n+X f(X x, Y, Z) {\n+  return x;\n+}"}]}