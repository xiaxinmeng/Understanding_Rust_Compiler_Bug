{"sha": "e65bf4e814d38c87232445a9cb6f995678d70095", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTY1YmY0ZTgxNGQzOGM4NzIzMjQ0NWE5Y2I2Zjk5NTY3OGQ3MDA5NQ==", "commit": {"author": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2015-09-01T12:33:51Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "ktkachov@gcc.gnu.org", "date": "2015-09-01T12:33:51Z"}, "message": "[RTL-ifcvt] Make non-conditional execution if-conversion more aggressive\n\n\t* ifcvt.c (struct noce_if_info): Add then_simple, else_simple,\n\tthen_cost, else_cost fields.  Change branch_cost field to unsigned\n\tint.\n\t(end_ifcvt_sequence): Call set_used_flags on each insn in the\n\tsequence.\n\tInclude rtl-iter.h.\n\t(noce_simple_bbs): New function.\n\t(noce_try_move): Bail if basic blocks are not simple.\n\t(noce_try_store_flag): Likewise.\n\t(noce_try_store_flag_constants): Likewise.\n\t(noce_try_addcc): Likewise.\n\t(noce_try_store_flag_mask): Likewise.\n\t(noce_try_cmove): Likewise.\n\t(noce_try_minmax): Likewise.\n\t(noce_try_abs): Likewise.\n\t(noce_try_sign_mask): Likewise.\n\t(noce_try_bitop): Likewise.\n\t(bbs_ok_for_cmove_arith): New function.\n\t(noce_emit_all_but_last): Likewise.\n\t(noce_emit_insn): Likewise.\n\t(noce_emit_bb): Likewise.\n\t(noce_try_cmove_arith): Handle non-simple basic blocks.\n\t(insn_valid_noce_process_p): New function.\n\t(contains_mem_rtx_p): Likewise.\n\t(bb_valid_for_noce_process_p): Likewise.\n\t(noce_process_if_block): Allow non-simple basic blocks\n\twhere appropriate.\n\n\t* gcc.dg/ifcvt-1.c: New test.\n\t* gcc.dg/ifcvt-2.c: Likewise.\n\t* gcc.dg/ifcvt-3.c: Likewise.\n\nFrom-SVN: r227368", "tree": {"sha": "29c71966823c22f1f859dbddac68e205f0c9364d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/29c71966823c22f1f859dbddac68e205f0c9364d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e65bf4e814d38c87232445a9cb6f995678d70095", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e65bf4e814d38c87232445a9cb6f995678d70095", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e65bf4e814d38c87232445a9cb6f995678d70095", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e65bf4e814d38c87232445a9cb6f995678d70095/comments", "author": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2674213872182bcf844b0f495478cf168b0bb3d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2674213872182bcf844b0f495478cf168b0bb3d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2674213872182bcf844b0f495478cf168b0bb3d8"}], "stats": {"total": 548, "additions": 480, "deletions": 68}, "files": [{"sha": "c14f3540ff4c056e34ce8574dc8cdd94cac72453", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e65bf4e814d38c87232445a9cb6f995678d70095/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e65bf4e814d38c87232445a9cb6f995678d70095/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e65bf4e814d38c87232445a9cb6f995678d70095", "patch": "@@ -1,3 +1,33 @@\n+2015-09-01  Kyrylo Tkachov <kyrylo.tkachov@arm.com>\n+\n+\t* ifcvt.c (struct noce_if_info): Add then_simple, else_simple,\n+\tthen_cost, else_cost fields.  Change branch_cost field to unsigned\n+\tint.\n+\t(end_ifcvt_sequence): Call set_used_flags on each insn in the\n+\tsequence.\n+\tInclude rtl-iter.h.\n+\t(noce_simple_bbs): New function.\n+\t(noce_try_move): Bail if basic blocks are not simple.\n+\t(noce_try_store_flag): Likewise.\n+\t(noce_try_store_flag_constants): Likewise.\n+\t(noce_try_addcc): Likewise.\n+\t(noce_try_store_flag_mask): Likewise.\n+\t(noce_try_cmove): Likewise.\n+\t(noce_try_minmax): Likewise.\n+\t(noce_try_abs): Likewise.\n+\t(noce_try_sign_mask): Likewise.\n+\t(noce_try_bitop): Likewise.\n+\t(bbs_ok_for_cmove_arith): New function.\n+\t(noce_emit_all_but_last): Likewise.\n+\t(noce_emit_insn): Likewise.\n+\t(noce_emit_bb): Likewise.\n+\t(noce_try_cmove_arith): Handle non-simple basic blocks.\n+\t(insn_valid_noce_process_p): New function.\n+\t(contains_mem_rtx_p): Likewise.\n+\t(bb_valid_for_noce_process_p): Likewise.\n+\t(noce_process_if_block): Allow non-simple basic blocks\n+\twhere appropriate.\n+\n 2015-08-31  Alan Lawrence  <alan.lawrence@arm.com>\n \n \t* tree-ssa-dom.c (record_equivalences_from_phis,"}, {"sha": "157a716ff6e8f2c80d8ef2acea815e8d59549260", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 398, "deletions": 68, "changes": 466, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e65bf4e814d38c87232445a9cb6f995678d70095/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e65bf4e814d38c87232445a9cb6f995678d70095/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=e65bf4e814d38c87232445a9cb6f995678d70095", "patch": "@@ -53,6 +53,7 @@\n #include \"tree-pass.h\"\n #include \"dbgcnt.h\"\n #include \"shrink-wrap.h\"\n+#include \"rtl-iter.h\"\n #include \"ifcvt.h\"\n \n #ifndef MAX_CONDITIONAL_EXECUTE\n@@ -808,8 +809,17 @@ struct noce_if_info\n      form as well.  */\n   bool then_else_reversed;\n \n+  /* True if the contents of then_bb and else_bb are a\n+     simple single set instruction.  */\n+  bool then_simple;\n+  bool else_simple;\n+\n+  /* The total rtx cost of the instructions in then_bb and else_bb.  */\n+  unsigned int then_cost;\n+  unsigned int else_cost;\n+\n   /* Estimated cost of the particular branch instruction.  */\n-  int branch_cost;\n+  unsigned int branch_cost;\n };\n \n static rtx noce_emit_store_flag (struct noce_if_info *, rtx, int, int);\n@@ -1029,6 +1039,10 @@ end_ifcvt_sequence (struct noce_if_info *if_info)\n   set_used_flags (if_info->cond);\n   set_used_flags (if_info->a);\n   set_used_flags (if_info->b);\n+\n+  for (insn = seq; insn; insn = NEXT_INSN (insn))\n+    set_used_flags (insn);\n+\n   unshare_all_rtl_in_chain (seq);\n   end_sequence ();\n \n@@ -1046,6 +1060,21 @@ end_ifcvt_sequence (struct noce_if_info *if_info)\n   return seq;\n }\n \n+/* Return true iff the then and else basic block (if it exists)\n+   consist of a single simple set instruction.  */\n+\n+static bool\n+noce_simple_bbs (struct noce_if_info *if_info)\n+{\n+  if (!if_info->then_simple)\n+    return false;\n+\n+  if (if_info->else_bb)\n+    return if_info->else_simple;\n+\n+  return true;\n+}\n+\n /* Convert \"if (a != b) x = a; else x = b\" into \"x = a\" and\n    \"if (a == b) x = a; else x = b\" into \"x = b\".  */\n \n@@ -1060,6 +1089,9 @@ noce_try_move (struct noce_if_info *if_info)\n   if (code != NE && code != EQ)\n     return FALSE;\n \n+  if (!noce_simple_bbs (if_info))\n+    return FALSE;\n+\n   /* This optimization isn't valid if either A or B could be a NaN\n      or a signed zero.  */\n   if (HONOR_NANS (if_info->x)\n@@ -1108,6 +1140,9 @@ noce_try_store_flag (struct noce_if_info *if_info)\n   rtx target;\n   rtx_insn *seq;\n \n+  if (!noce_simple_bbs (if_info))\n+    return FALSE;\n+\n   if (CONST_INT_P (if_info->b)\n       && INTVAL (if_info->b) == STORE_FLAG_VALUE\n       && if_info->a == const0_rtx)\n@@ -1177,6 +1212,9 @@ noce_try_store_flag_constants (struct noce_if_info *if_info)\n       b = XEXP (b, 1);\n     }\n \n+  if (!noce_simple_bbs (if_info))\n+    return FALSE;\n+\n   if (CONST_INT_P (a)\n       && CONST_INT_P (b))\n     {\n@@ -1365,6 +1403,9 @@ noce_try_addcc (struct noce_if_info *if_info)\n   rtx_insn *seq;\n   int subtract, normalize;\n \n+  if (!noce_simple_bbs (if_info))\n+    return FALSE;\n+\n   if (GET_CODE (if_info->a) == PLUS\n       && rtx_equal_p (XEXP (if_info->a, 0), if_info->b)\n       && (reversed_comparison_code (if_info->cond, if_info->jump)\n@@ -1456,6 +1497,9 @@ noce_try_store_flag_mask (struct noce_if_info *if_info)\n   rtx_insn *seq;\n   int reversep;\n \n+  if (!noce_simple_bbs (if_info))\n+    return FALSE;\n+\n   reversep = 0;\n   if ((if_info->branch_cost >= 2\n        || STORE_FLAG_VALUE == -1)\n@@ -1624,6 +1668,9 @@ noce_try_cmove (struct noce_if_info *if_info)\n   rtx target;\n   rtx_insn *seq;\n \n+  if (!noce_simple_bbs (if_info))\n+    return FALSE;\n+\n   if ((CONSTANT_P (if_info->a) || register_operand (if_info->a, VOIDmode))\n       && (CONSTANT_P (if_info->b) || register_operand (if_info->b, VOIDmode)))\n     {\n@@ -1714,6 +1761,152 @@ noce_try_cmove (struct noce_if_info *if_info)\n   return FALSE;\n }\n \n+/* Helper for bb_valid_for_noce_process_p.  Validate that\n+   the rtx insn INSN is a single set that does not set\n+   the conditional register CC and is in general valid for\n+   if-conversion.  */\n+\n+static bool\n+insn_valid_noce_process_p (rtx_insn *insn, rtx cc)\n+{\n+  if (!insn\n+      || !NONJUMP_INSN_P (insn)\n+      || (cc && set_of (cc, insn)))\n+      return false;\n+\n+  rtx sset = single_set (insn);\n+\n+  /* Currently support only simple single sets in test_bb.  */\n+  if (!sset\n+      || !noce_operand_ok (SET_DEST (sset))\n+      || !noce_operand_ok (SET_SRC (sset)))\n+    return false;\n+\n+  return true;\n+}\n+\n+\n+/* Return true iff the registers that the insns in BB_A set do not\n+   get used in BB_B.  */\n+\n+static bool\n+bbs_ok_for_cmove_arith (basic_block bb_a, basic_block bb_b)\n+{\n+  rtx_insn *a_insn;\n+  bitmap bba_sets = BITMAP_ALLOC (&reg_obstack);\n+\n+  df_ref def;\n+  df_ref use;\n+\n+  FOR_BB_INSNS (bb_a, a_insn)\n+    {\n+      if (!active_insn_p (a_insn))\n+\tcontinue;\n+\n+      rtx sset_a = single_set (a_insn);\n+\n+      if (!sset_a)\n+\t{\n+\t  BITMAP_FREE (bba_sets);\n+\t  return false;\n+\t}\n+\n+      /* Record all registers that BB_A sets.  */\n+      FOR_EACH_INSN_DEF (def, a_insn)\n+\tbitmap_set_bit (bba_sets, DF_REF_REGNO (def));\n+    }\n+\n+  rtx_insn *b_insn;\n+\n+  FOR_BB_INSNS (bb_b, b_insn)\n+    {\n+      if (!active_insn_p (b_insn))\n+\tcontinue;\n+\n+      rtx sset_b = single_set (b_insn);\n+\n+      if (!sset_b)\n+\t{\n+\t  BITMAP_FREE (bba_sets);\n+\t  return false;\n+\t}\n+\n+      /* Make sure this is a REG and not some instance\n+\t of ZERO_EXTRACT or SUBREG or other dangerous stuff.  */\n+      if (!REG_P (SET_DEST (sset_b)))\n+\t{\n+\t  BITMAP_FREE (bba_sets);\n+\t  return false;\n+\t}\n+\n+      /* If the insn uses a reg set in BB_A return false.  */\n+      FOR_EACH_INSN_USE (use, b_insn)\n+\t{\n+\t  if (bitmap_bit_p (bba_sets, DF_REF_REGNO (use)))\n+\t    {\n+\t      BITMAP_FREE (bba_sets);\n+\t      return false;\n+\t    }\n+\t}\n+\n+    }\n+\n+  BITMAP_FREE (bba_sets);\n+  return true;\n+}\n+\n+/* Emit copies of all the active instructions in BB except the last.\n+   This is a helper for noce_try_cmove_arith.  */\n+\n+static void\n+noce_emit_all_but_last (basic_block bb)\n+{\n+  rtx_insn *last = last_active_insn (bb, FALSE);\n+  rtx_insn *insn;\n+  FOR_BB_INSNS (bb, insn)\n+    {\n+      if (insn != last && active_insn_p (insn))\n+\t{\n+\t  rtx_insn *to_emit = as_a <rtx_insn *> (copy_rtx (insn));\n+\n+\t  emit_insn (PATTERN (to_emit));\n+\t}\n+    }\n+}\n+\n+/* Helper for noce_try_cmove_arith.  Emit the pattern TO_EMIT and return\n+   the resulting insn or NULL if it's not a valid insn.  */\n+\n+static rtx_insn *\n+noce_emit_insn (rtx to_emit)\n+{\n+  gcc_assert (to_emit);\n+  rtx_insn *insn = emit_insn (to_emit);\n+\n+  if (recog_memoized (insn) < 0)\n+    return NULL;\n+\n+  return insn;\n+}\n+\n+/* Helper for noce_try_cmove_arith.  Emit a copy of the insns up to\n+   and including the penultimate one in BB if it is not simple\n+   (as indicated by SIMPLE).  Then emit LAST_INSN as the last\n+   insn in the block.  The reason for that is that LAST_INSN may\n+   have been modified by the preparation in noce_try_cmove_arith.  */\n+\n+static bool\n+noce_emit_bb (rtx last_insn, basic_block bb, bool simple)\n+{\n+  if (bb && !simple)\n+    noce_emit_all_but_last (bb);\n+\n+  if (last_insn && !noce_emit_insn (last_insn))\n+    return false;\n+\n+  return true;\n+}\n+\n /* Try more complex cases involving conditional_move.  */\n \n static int\n@@ -1724,9 +1917,12 @@ noce_try_cmove_arith (struct noce_if_info *if_info)\n   rtx x = if_info->x;\n   rtx orig_a, orig_b;\n   rtx_insn *insn_a, *insn_b;\n+  bool a_simple = if_info->then_simple;\n+  bool b_simple = if_info->else_simple;\n+  basic_block then_bb = if_info->then_bb;\n+  basic_block else_bb = if_info->else_bb;\n   rtx target;\n   int is_mem = 0;\n-  int insn_cost;\n   enum rtx_code code;\n   rtx_insn *ifcvt_seq;\n \n@@ -1765,27 +1961,22 @@ noce_try_cmove_arith (struct noce_if_info *if_info)\n   insn_a = if_info->insn_a;\n   insn_b = if_info->insn_b;\n \n-  /* Total insn_rtx_cost should be smaller than branch cost.  Exit\n-     if insn_rtx_cost can't be estimated.  */\n+  unsigned int then_cost;\n+  unsigned int else_cost;\n   if (insn_a)\n-    {\n-      insn_cost\n-\t= insn_rtx_cost (PATTERN (insn_a),\n-      \t\t\t optimize_bb_for_speed_p (BLOCK_FOR_INSN (insn_a)));\n-      if (insn_cost == 0 || insn_cost > COSTS_N_INSNS (if_info->branch_cost))\n-\treturn FALSE;\n-    }\n+    then_cost = if_info->then_cost;\n   else\n-    insn_cost = 0;\n+    then_cost = 0;\n \n   if (insn_b)\n-    {\n-      insn_cost\n-\t+= insn_rtx_cost (PATTERN (insn_b),\n-      \t\t\t  optimize_bb_for_speed_p (BLOCK_FOR_INSN (insn_b)));\n-      if (insn_cost == 0 || insn_cost > COSTS_N_INSNS (if_info->branch_cost))\n-        return FALSE;\n-    }\n+    else_cost = if_info->else_cost;\n+  else\n+    else_cost = 0;\n+\n+  /* We're going to execute one of the basic blocks anyway, so\n+     bail out if the most expensive of the two blocks is unacceptable.  */\n+  if (MAX (then_cost, else_cost) > COSTS_N_INSNS (if_info->branch_cost))\n+    return FALSE;\n \n   /* Possibly rearrange operands to make things come out more natural.  */\n   if (reversed_comparison_code (if_info->cond, if_info->jump) != UNKNOWN)\n@@ -1801,26 +1992,36 @@ noce_try_cmove_arith (struct noce_if_info *if_info)\n \t  code = reversed_comparison_code (if_info->cond, if_info->jump);\n \t  std::swap (a, b);\n \t  std::swap (insn_a, insn_b);\n+\t  std::swap (a_simple, b_simple);\n+\t  std::swap (then_bb, else_bb);\n \t}\n     }\n \n+  if (!a_simple && then_bb && !b_simple && else_bb\n+      && (!bbs_ok_for_cmove_arith (then_bb, else_bb)\n+\t  || !bbs_ok_for_cmove_arith (else_bb, then_bb)))\n+    return FALSE;\n+\n   start_sequence ();\n \n   orig_a = a;\n   orig_b = b;\n \n+  rtx emit_a = NULL_RTX;\n+  rtx emit_b = NULL_RTX;\n+\n   /* If either operand is complex, load it into a register first.\n      The best way to do this is to copy the original insn.  In this\n      way we preserve any clobbers etc that the insn may have had.\n      This is of course not possible in the IS_MEM case.  */\n+\n   if (! general_operand (a, GET_MODE (a)))\n     {\n-      rtx_insn *insn;\n \n       if (is_mem)\n \t{\n \t  rtx reg = gen_reg_rtx (GET_MODE (a));\n-\t  insn = emit_insn (gen_rtx_SET (reg, a));\n+\t  emit_a = gen_rtx_SET (reg, a);\n \t}\n       else if (! insn_a)\n \tgoto end_seq_and_fail;\n@@ -1830,49 +2031,58 @@ noce_try_cmove_arith (struct noce_if_info *if_info)\n \t  rtx_insn *copy_of_a = as_a <rtx_insn *> (copy_rtx (insn_a));\n \t  rtx set = single_set (copy_of_a);\n \t  SET_DEST (set) = a;\n-\t  insn = emit_insn (PATTERN (copy_of_a));\n+\n+\t  emit_a = PATTERN (copy_of_a);\n \t}\n-      if (recog_memoized (insn) < 0)\n-\tgoto end_seq_and_fail;\n     }\n+\n   if (! general_operand (b, GET_MODE (b)))\n     {\n-      rtx pat;\n-      rtx_insn *last;\n-      rtx_insn *new_insn;\n-\n       if (is_mem)\n \t{\n           rtx reg = gen_reg_rtx (GET_MODE (b));\n-\t  pat = gen_rtx_SET (reg, b);\n+\t  emit_b = gen_rtx_SET (reg, b);\n \t}\n       else if (! insn_b)\n \tgoto end_seq_and_fail;\n       else\n \t{\n           b = gen_reg_rtx (GET_MODE (b));\n-\t  rtx_insn *copy_of_insn_b = as_a <rtx_insn *> (copy_rtx (insn_b));\n-\t  rtx set = single_set (copy_of_insn_b);\n+\t  rtx_insn *copy_of_b = as_a <rtx_insn *> (copy_rtx (insn_b));\n+\t  rtx set = single_set (copy_of_b);\n+\n \t  SET_DEST (set) = b;\n-\t  pat = PATTERN (copy_of_insn_b);\n+\t  emit_b = PATTERN (copy_of_b);\n \t}\n+    }\n \n-      /* If insn to set up A clobbers any registers B depends on, try to\n-\t swap insn that sets up A with the one that sets up B.  If even\n-\t that doesn't help, punt.  */\n-      last = get_last_insn ();\n-      if (last && modified_in_p (orig_b, last))\n-\t{\n-\t  new_insn = emit_insn_before (pat, get_insns ());\n-\t  if (modified_in_p (orig_a, new_insn))\n-\t    goto end_seq_and_fail;\n-\t}\n-      else\n-\tnew_insn = emit_insn (pat);\n+    /* If insn to set up A clobbers any registers B depends on, try to\n+       swap insn that sets up A with the one that sets up B.  If even\n+       that doesn't help, punt.  */\n \n-      if (recog_memoized (new_insn) < 0)\n-\tgoto end_seq_and_fail;\n-    }\n+    if (emit_a && modified_in_p (orig_b, emit_a))\n+      {\n+\tif (modified_in_p (orig_a, emit_b))\n+\t  goto end_seq_and_fail;\n+\n+\tif (else_bb && !b_simple)\n+\t  {\n+\t    if (!noce_emit_bb (emit_b, else_bb, b_simple))\n+\t      goto end_seq_and_fail;\n+\t  }\n+\n+\tif (!noce_emit_bb (emit_a, then_bb, a_simple))\n+\t  goto end_seq_and_fail;\n+      }\n+    else\n+      {\n+\tif (!noce_emit_bb (emit_a, then_bb, a_simple))\n+\t  goto end_seq_and_fail;\n+\n+\tif (!noce_emit_bb (emit_b, else_bb, b_simple))\n+\t  goto end_seq_and_fail;\n+\n+      }\n \n   target = noce_emit_cmove (if_info, x, code, XEXP (if_info->cond, 0),\n \t\t\t    XEXP (if_info->cond, 1), a, b);\n@@ -2076,6 +2286,9 @@ noce_try_minmax (struct noce_if_info *if_info)\n   enum rtx_code code, op;\n   int unsignedp;\n \n+  if (!noce_simple_bbs (if_info))\n+    return FALSE;\n+\n   /* ??? Reject modes with NaNs or signed zeros since we don't know how\n      they will be resolved with an SMIN/SMAX.  It wouldn't be too hard\n      to get the target to tell us...  */\n@@ -2172,6 +2385,9 @@ noce_try_abs (struct noce_if_info *if_info)\n   int negate;\n   bool one_cmpl = false;\n \n+  if (!noce_simple_bbs (if_info))\n+    return FALSE;\n+\n   /* Reject modes with signed zeros.  */\n   if (HONOR_SIGNED_ZEROS (if_info->x))\n     return FALSE;\n@@ -2320,6 +2536,9 @@ noce_try_sign_mask (struct noce_if_info *if_info)\n   enum rtx_code code;\n   bool t_unconditional;\n \n+  if (!noce_simple_bbs (if_info))\n+    return FALSE;\n+\n   cond = if_info->cond;\n   code = GET_CODE (cond);\n   m = XEXP (cond, 0);\n@@ -2403,6 +2622,9 @@ noce_try_bitop (struct noce_if_info *if_info)\n   cond = if_info->cond;\n   code = GET_CODE (cond);\n \n+  if (!noce_simple_bbs (if_info))\n+    return FALSE;\n+\n   /* Check for no else condition.  */\n   if (! rtx_equal_p (x, if_info->b))\n     return FALSE;\n@@ -2653,6 +2875,113 @@ noce_can_store_speculate_p (basic_block top_bb, const_rtx mem)\n   return false;\n }\n \n+/* Return true if X contains a MEM subrtx.  */\n+\n+static bool\n+contains_mem_rtx_p (rtx x)\n+{\n+  subrtx_iterator::array_type array;\n+  FOR_EACH_SUBRTX (iter, array, x, ALL)\n+    if (MEM_P (*iter))\n+      return true;\n+\n+  return false;\n+}\n+\n+/* Return true iff basic block TEST_BB is valid for noce if-conversion.\n+   The condition used in this if-conversion is in COND.\n+   In practice, check that TEST_BB ends with a single set\n+   x := a and all previous computations\n+   in TEST_BB don't produce any values that are live after TEST_BB.\n+   In other words, all the insns in TEST_BB are there only\n+   to compute a value for x.  Put the rtx cost of the insns\n+   in TEST_BB into COST.  Record whether TEST_BB is a single simple\n+   set instruction in SIMPLE_P.  */\n+\n+static bool\n+bb_valid_for_noce_process_p (basic_block test_bb, rtx cond,\n+\t\t\t      unsigned int *cost, bool *simple_p)\n+{\n+  if (!test_bb)\n+    return false;\n+\n+  rtx_insn *last_insn = last_active_insn (test_bb, FALSE);\n+  rtx last_set = NULL_RTX;\n+\n+  rtx cc = cc_in_cond (cond);\n+\n+  if (!insn_valid_noce_process_p (last_insn, cc))\n+    return false;\n+  last_set = single_set (last_insn);\n+\n+  rtx x = SET_DEST (last_set);\n+  rtx_insn *first_insn = first_active_insn (test_bb);\n+  rtx first_set = single_set (first_insn);\n+\n+  if (!first_set)\n+    return false;\n+\n+  /* We have a single simple set, that's okay.  */\n+  bool speed_p = optimize_bb_for_speed_p (test_bb);\n+\n+  if (first_insn == last_insn)\n+    {\n+      *simple_p = noce_operand_ok (SET_DEST (first_set));\n+      *cost = insn_rtx_cost (first_set, speed_p);\n+      return *simple_p;\n+    }\n+\n+  rtx_insn *prev_last_insn = PREV_INSN (last_insn);\n+  gcc_assert (prev_last_insn);\n+\n+  /* For now, disallow setting x multiple times in test_bb.  */\n+  if (REG_P (x) && reg_set_between_p (x, first_insn, prev_last_insn))\n+    return false;\n+\n+  bitmap test_bb_temps = BITMAP_ALLOC (&reg_obstack);\n+\n+  /* The regs that are live out of test_bb.  */\n+  bitmap test_bb_live_out = df_get_live_out (test_bb);\n+\n+  int potential_cost = insn_rtx_cost (last_set, speed_p);\n+  rtx_insn *insn;\n+  FOR_BB_INSNS (test_bb, insn)\n+    {\n+      if (insn != last_insn)\n+\t{\n+\t  if (!active_insn_p (insn))\n+\t    continue;\n+\n+\t  if (!insn_valid_noce_process_p (insn, cc))\n+\t    goto free_bitmap_and_fail;\n+\n+\t  rtx sset = single_set (insn);\n+\t  gcc_assert (sset);\n+\n+\t  if (contains_mem_rtx_p (SET_SRC (sset))\n+\t      || !REG_P (SET_DEST (sset)))\n+\t    goto free_bitmap_and_fail;\n+\n+\t  potential_cost += insn_rtx_cost (sset, speed_p);\n+\t  bitmap_set_bit (test_bb_temps, REGNO (SET_DEST (sset)));\n+\t}\n+    }\n+\n+  /* If any of the intermediate results in test_bb are live after test_bb\n+     then fail.  */\n+  if (bitmap_intersect_p (test_bb_live_out, test_bb_temps))\n+    goto free_bitmap_and_fail;\n+\n+  BITMAP_FREE (test_bb_temps);\n+  *cost = potential_cost;\n+  *simple_p = false;\n+  return true;\n+\n+ free_bitmap_and_fail:\n+  BITMAP_FREE (test_bb_temps);\n+  return false;\n+}\n+\n /* Given a simple IF-THEN-JOIN or IF-THEN-ELSE-JOIN block, attempt to convert\n    it without using conditional execution.  Return TRUE if we were successful\n    at converting the block.  */\n@@ -2669,7 +2998,6 @@ noce_process_if_block (struct noce_if_info *if_info)\n   rtx_insn *insn_a, *insn_b;\n   rtx set_a, set_b;\n   rtx orig_x, x, a, b;\n-  rtx cc;\n \n   /* We're looking for patterns of the form\n \n@@ -2678,15 +3006,23 @@ noce_process_if_block (struct noce_if_info *if_info)\n      (3) if (...) x = a;   // as if with an initial x = x.\n \n      The later patterns require jumps to be more expensive.\n-\n+     For the if (...) x = a; else x = b; case we allow multiple insns\n+     inside the then and else blocks as long as their only effect is\n+     to calculate a value for x.\n      ??? For future expansion, look for multiple X in such patterns.  */\n \n-  /* Look for one of the potential sets.  */\n-  insn_a = first_active_insn (then_bb);\n-  if (! insn_a\n-      || insn_a != last_active_insn (then_bb, FALSE)\n-      || (set_a = single_set (insn_a)) == NULL_RTX)\n-    return FALSE;\n+  if (! bb_valid_for_noce_process_p (then_bb, cond, &if_info->then_cost,\n+\t\t\t\t    &if_info->then_simple))\n+    return false;\n+\n+  if (else_bb\n+      && ! bb_valid_for_noce_process_p (else_bb, cond, &if_info->else_cost,\n+\t\t\t\t      &if_info->else_simple))\n+    return false;\n+\n+  insn_a = last_active_insn (then_bb, FALSE);\n+  set_a = single_set (insn_a);\n+  gcc_assert (set_a);\n \n   x = SET_DEST (set_a);\n   a = SET_SRC (set_a);\n@@ -2701,11 +3037,11 @@ noce_process_if_block (struct noce_if_info *if_info)\n   set_b = NULL_RTX;\n   if (else_bb)\n     {\n-      insn_b = first_active_insn (else_bb);\n-      if (! insn_b\n-\t  || insn_b != last_active_insn (else_bb, FALSE)\n-\t  || (set_b = single_set (insn_b)) == NULL_RTX\n-\t  || ! rtx_interchangeable_p (x, SET_DEST (set_b)))\n+      insn_b = last_active_insn (else_bb, FALSE);\n+      set_b = single_set (insn_b);\n+      gcc_assert (set_b);\n+\n+      if (!rtx_interchangeable_p (x, SET_DEST (set_b)))\n \treturn FALSE;\n     }\n   else\n@@ -2781,20 +3117,14 @@ noce_process_if_block (struct noce_if_info *if_info)\n   if_info->a = a;\n   if_info->b = b;\n \n-  /* Skip it if the instruction to be moved might clobber CC.  */\n-  cc = cc_in_cond (cond);\n-  if (cc\n-      && (set_of (cc, insn_a)\n-\t  || (insn_b && set_of (cc, insn_b))))\n-    return FALSE;\n-\n   /* Try optimizations in some approximation of a useful order.  */\n   /* ??? Should first look to see if X is live incoming at all.  If it\n      isn't, we don't need anything but an unconditional set.  */\n \n   /* Look and see if A and B are really the same.  Avoid creating silly\n      cmove constructs that no one will fix up later.  */\n-  if (rtx_interchangeable_p (a, b))\n+  if (noce_simple_bbs (if_info)\n+      && rtx_interchangeable_p (a, b))\n     {\n       /* If we have an INSN_B, we don't have to create any new rtl.  Just\n \t move the instruction that we already have.  If we don't have an"}, {"sha": "e23126558c982352abea14c7b2d766eb8cc2aca7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e65bf4e814d38c87232445a9cb6f995678d70095/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e65bf4e814d38c87232445a9cb6f995678d70095/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e65bf4e814d38c87232445a9cb6f995678d70095", "patch": "@@ -1,3 +1,9 @@\n+2015-09-01  Kyrylo Tkachov <kyrylo.tkachov@arm.com>\n+\n+\t* gcc.dg/ifcvt-1.c: New test.\n+\t* gcc.dg/ifcvt-2.c: Likewise.\n+\t* gcc.dg/ifcvt-3.c: Likewise.\n+\n 2015-09-01  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \tPR libfortran/67412"}, {"sha": "92bc17a9285534b21166522e30156cd1558cf2a2", "filename": "gcc/testsuite/gcc.dg/ifcvt-1.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e65bf4e814d38c87232445a9cb6f995678d70095/gcc%2Ftestsuite%2Fgcc.dg%2Fifcvt-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e65bf4e814d38c87232445a9cb6f995678d70095/gcc%2Ftestsuite%2Fgcc.dg%2Fifcvt-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fifcvt-1.c?ref=e65bf4e814d38c87232445a9cb6f995678d70095", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile { target aarch64*-*-* x86_64-*-* } } */\n+/* { dg-options \"-fdump-rtl-ce1 -O2\" } */\n+\n+int\n+foo (int x)\n+{\n+  return x > 100 ? x - 2 : x - 1;\n+}\n+\n+/* { dg-final { scan-rtl-dump \"3 true changes made\" \"ce1\" } } */"}, {"sha": "e0e1728a34c0edb2abf8822ca9007e967ed02c4e", "filename": "gcc/testsuite/gcc.dg/ifcvt-2.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e65bf4e814d38c87232445a9cb6f995678d70095/gcc%2Ftestsuite%2Fgcc.dg%2Fifcvt-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e65bf4e814d38c87232445a9cb6f995678d70095/gcc%2Ftestsuite%2Fgcc.dg%2Fifcvt-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fifcvt-2.c?ref=e65bf4e814d38c87232445a9cb6f995678d70095", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile { target aarch64*-*-* x86_64-*-* } } */\n+/* { dg-options \"-fdump-rtl-ce1 -O2\" } */\n+\n+\n+typedef unsigned char uint8_t;\n+typedef unsigned int uint16_t;\n+\n+uint8_t\n+_xtime (const uint8_t byte, const uint16_t generator)\n+{\n+  if (byte & 0x80)\n+    return byte ^ generator;\n+  else\n+    return byte << 1;\n+}\n+\n+/* { dg-final { scan-rtl-dump \"3 true changes made\" \"ce1\" } } */"}, {"sha": "2e104a4ffd5238c9587946f62440f4fd5629010b", "filename": "gcc/testsuite/gcc.dg/ifcvt-3.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e65bf4e814d38c87232445a9cb6f995678d70095/gcc%2Ftestsuite%2Fgcc.dg%2Fifcvt-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e65bf4e814d38c87232445a9cb6f995678d70095/gcc%2Ftestsuite%2Fgcc.dg%2Fifcvt-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fifcvt-3.c?ref=e65bf4e814d38c87232445a9cb6f995678d70095", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile { target aarch64*-*-* x86_64-*-* }  } */\n+/* { dg-options \"-fdump-rtl-ce1 -O2\" } */\n+\n+typedef long long s64;\n+\n+int\n+foo (s64 a, s64 b, s64 c)\n+{\n+ s64 d = a - b;\n+\n+  if (d == 0)\n+    return a + c;\n+  else\n+    return b + d + c;\n+}\n+\n+/* This test can be reduced to just return a + c;  */\n+/* { dg-final { scan-rtl-dump \"3 true changes made\" \"ce1\" } } */\n+/* { dg-final { scan-assembler-not \"sub\\.*\\tx\\[0-9\\]+, x\\[0-9\\]+, x\\[0-9\\]+\\.*\" { target { aarch64*-*-* } } } } */"}]}