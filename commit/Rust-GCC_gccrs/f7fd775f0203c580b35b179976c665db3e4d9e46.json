{"sha": "f7fd775f0203c580b35b179976c665db3e4d9e46", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjdmZDc3NWYwMjAzYzU4MGIzNWIxNzk5NzZjNjY1ZGIzZTRkOWU0Ng==", "commit": {"author": {"name": "Joerg Wunsch", "email": "j.gnu@uriah.heep.sax.de", "date": "2007-06-05T22:25:27Z"}, "committer": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2007-06-05T22:25:27Z"}, "message": "re PR preprocessor/23479 (Implement binary constants with a \"0b\" prefix)\n\n2007-06-05  Joerg Wunsch  <j.gnu@uriah.heep.sax.de>\n\n\tPR preprocessor/23479\ngcc/\n\t* doc/extend.texi: Document the 0b-prefixed binary integer\n\tconstant extension.\n\nlibcpp/\n\t* expr.c (cpp_classify_number): Implement 0b-prefixed binary\n\tinteger constants.\n\t(append_digit): Likewise.\n\t* include/cpplib.h: Add CPP_N_BINARY, to be used for 0b-prefixed\n\tbinary integer constants.\n\ntestsuite/\n\t* testsuite/gcc.dg/binary-constants-1.c: Add test suites for\n\tthe 0b-prefixed binary integer constants.\n\t* testsuite/gcc.dg/binary-constants-2.c: Ditto.\n\t* testsuite/gcc.dg/binary-constants-3.c: Ditto.\n\t* testsuite/gcc.dg/binary-constants-4.c: Ditto.\n\nFrom-SVN: r125346", "tree": {"sha": "f7bdd99b29a4dc2624af52e3f3a9d6c816e0b468", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f7bdd99b29a4dc2624af52e3f3a9d6c816e0b468"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f7fd775f0203c580b35b179976c665db3e4d9e46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7fd775f0203c580b35b179976c665db3e4d9e46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7fd775f0203c580b35b179976c665db3e4d9e46", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7fd775f0203c580b35b179976c665db3e4d9e46/comments", "author": null, "committer": null, "parents": [{"sha": "1a5f8b894c144cc15f6a63b3b52ba28b5bd4e94f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a5f8b894c144cc15f6a63b3b52ba28b5bd4e94f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a5f8b894c144cc15f6a63b3b52ba28b5bd4e94f"}], "stats": {"total": 456, "additions": 453, "deletions": 3}, "files": [{"sha": "f28d732f8512fde235a3539537c08b47338256c6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7fd775f0203c580b35b179976c665db3e4d9e46/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7fd775f0203c580b35b179976c665db3e4d9e46/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f7fd775f0203c580b35b179976c665db3e4d9e46", "patch": "@@ -1,3 +1,9 @@\n+2007-06-05  Joerg Wunsch  <j.gnu@uriah.heep.sax.de>\n+\n+\tPR preprocessor/23479\n+\t* doc/extend.texi: Document the 0b-prefixed binary integer\n+\tconstant extension.\n+\t\n 2007-06-05  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR tree-optimization/32215"}, {"sha": "3390bb164375e0012dafa1baa96ee06bf0789788", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7fd775f0203c580b35b179976c665db3e4d9e46/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7fd775f0203c580b35b179976c665db3e4d9e46/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=f7fd775f0203c580b35b179976c665db3e4d9e46", "patch": "@@ -81,6 +81,7 @@ extensions, accepted by GCC in C89 mode and in C++.\n * Pragmas::             Pragmas accepted by GCC.\n * Unnamed Fields::      Unnamed struct/union fields within structs/unions.\n * Thread-Local::        Per-thread variables.\n+* Binary constants::    Binary constants using the @samp{0b} prefix.\n @end menu\n \n @node Statement Exprs\n@@ -10860,6 +10861,28 @@ Non-@code{static} members shall not be @code{__thread}.\n @end quotation\n @end itemize\n \n+@node Binary constants\n+@section Binary constants using the @samp{0b} prefix\n+@cindex Binary constants using the @samp{0b} prefix\n+\n+Integer constants can be written as binary constants, consisting of a\n+sequence of @samp{0} and @samp{1} digits, prefixed by @samp{0b} or\n+@samp{0B}.  This is particularly useful in environments that operate a\n+lot on the bit-level (like microcontrollers).\n+\n+The following statements are identical:\n+\n+@smallexample\n+i =       42;\n+i =     0x2a;\n+i =      052;\n+i = 0b101010;\n+@end smallexample\n+\n+The type of these constants follows the same rules as for octal or\n+hexadecimal integer constants, so suffixes like @samp{L} or @samp{UL}\n+can be applied.\n+\n @node C++ Extensions\n @chapter Extensions to the C++ Language\n @cindex extensions, C++ language"}, {"sha": "067322c6a2a7ed6c5dc8f14bfb343dedfdf8837a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7fd775f0203c580b35b179976c665db3e4d9e46/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7fd775f0203c580b35b179976c665db3e4d9e46/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f7fd775f0203c580b35b179976c665db3e4d9e46", "patch": "@@ -1,3 +1,12 @@\n+2007-06-05  Joerg Wunsch  <j.gnu@uriah.heep.sax.de>\n+\n+\tPR preprocessor/23479\n+\t* testsuite/gcc.dg/binary-constants-1.c: Add test suites for\n+\tthe 0b-prefixed binary integer constants.\n+\t* testsuite/gcc.dg/binary-constants-2.c: Ditto.\n+\t* testsuite/gcc.dg/binary-constants-3.c: Ditto.\n+\t* testsuite/gcc.dg/binary-constants-4.c: Ditto.\n+\t\n 2007-06-05  Ian Lance Taylor  <iant@google.com>\n \n \t* gcc.dg/Wstrict-overflow-19.c: New test."}, {"sha": "b7cc5fd0dbe6a6ae86de70fa5a6458658ef49ece", "filename": "gcc/testsuite/gcc.dg/binary-constants-1.c", "status": "added", "additions": 312, "deletions": 0, "changes": 312, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7fd775f0203c580b35b179976c665db3e4d9e46/gcc%2Ftestsuite%2Fgcc.dg%2Fbinary-constants-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7fd775f0203c580b35b179976c665db3e4d9e46/gcc%2Ftestsuite%2Fgcc.dg%2Fbinary-constants-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbinary-constants-1.c?ref=f7fd775f0203c580b35b179976c665db3e4d9e46", "patch": "@@ -0,0 +1,312 @@\n+/* Test for binary integer constants.  */\n+\n+/* Derived from: c99-intconst-1.c, bye Joseph Myers <jsm28@cam.ac.uk>.  */\n+/* Origin: Joerg Wunsch <j.gnu@uriah.heep.sax.de>.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=gnu99\" } */\n+\n+#include <limits.h>\n+\n+/* Assertion that constant C is of type T.  */\n+#define ASSERT_CONST_TYPE(C, T)\t\t\t\\\n+\tdo {\t\t\t\t\t\\\n+\t  typedef T type;\t\t\t\\\n+\t  typedef type **typepp;\t\t\\\n+\t  typedef __typeof__((C)) ctype;\t\\\n+\t  typedef ctype **ctypepp;\t\t\\\n+\t  typepp x = 0;\t\t\t\t\\\n+\t  ctypepp y = 0;\t\t\t\\\n+\t  x = y;\t\t\t\t\\\n+\t  y = x;\t\t\t\t\\\n+\t} while (0)\n+\n+/* (T *) if E is zero, (void *) otherwise.  */\n+#define type_if_not(T, E) __typeof__(0 ? (T *)0 : (void *)(E))\n+\n+/* (T *) if E is nonzero, (void *) otherwise.  */\n+#define type_if(T, E) type_if_not(T, !(E))\n+\n+/* Combine pointer types, all but one (void *).  */\n+#define type_comb2(T1, T2) __typeof__(0 ? (T1)0 : (T2)0)\n+#define type_comb3(T1, T2, T3) type_comb2(T1, type_comb2(T2, T3))\n+#define type_comb4(T1, T2, T3, T4)\t\t\t\t\\\n+\ttype_comb2(T1, type_comb2(T2, type_comb2(T3, T4)))\n+#define type_comb6(T1, T2, T3, T4, T5, T6)\t\t\t\t   \\\n+\ttype_comb2(T1,\t\t\t\t\t\t\t   \\\n+\t\t   type_comb2(T2,\t\t\t\t\t   \\\n+\t\t\t      type_comb2(T3,\t\t\t\t   \\\n+\t\t\t\t\t type_comb2(T4,\t\t\t   \\\n+\t\t\t\t\t\t    type_comb2(T5, T6)))))\n+\n+/* (T1 *) if E1, otherwise (T2 *) if E2.  */\n+#define first_of2p(T1, E1, T2, E2) type_comb2(type_if(T1, (E1)),\t   \\\n+\t\t\t\t\t     type_if(T2, (!(E1) && (E2))))\n+/* (T1 *) if E1, otherwise (T2 *) if E2, otherwise (T3 *) if E3.  */\n+#define first_of3p(T1, E1, T2, E2, T3, E3)\t\t\t\\\n+\ttype_comb3(type_if(T1, (E1)),\t\t\t\t\\\n+\t\t   type_if(T2, (!(E1) && (E2))),\t\t\\\n+\t\t   type_if(T3, (!(E1) && !(E2) && (E3))))\n+/* (T1 *) if E1, otherwise (T2 *) if E2, otherwise (T3 *) if E3, otherwise\n+   (T4 *) if E4.  */\n+#define first_of4p(T1, E1, T2, E2, T3, E3, T4, E4)\t\t\t\\\n+\ttype_comb4(type_if(T1, (E1)),\t\t\t\t\t\\\n+\t\t   type_if(T2, (!(E1) && (E2))),\t\t\t\\\n+\t\t   type_if(T3, (!(E1) && !(E2) && (E3))),\t\t\\\n+\t\t   type_if(T4, (!(E1) && !(E2) && !(E3) && (E4))))\n+/* (T1 *) if E1, otherwise (T2 *) if E2, otherwise (T3 *) if E3, otherwise\n+   (T4 *) if E4, otherwise (T5 *) if E5, otherwise (T6 *) if E6.  */\n+#define first_of6p(T1, E1, T2, E2, T3, E3, T4, E4, T5, E5, T6, E6)\t    \\\n+\ttype_comb6(type_if(T1, (E1)),\t\t\t\t\t    \\\n+\t\t   type_if(T2, (!(E1) && (E2))),\t\t\t    \\\n+\t\t   type_if(T3, (!(E1) && !(E2) && (E3))),\t\t    \\\n+\t\t   type_if(T4, (!(E1) && !(E2) && !(E3) && (E4))),\t    \\\n+\t\t   type_if(T5, (!(E1) && !(E2) && !(E3) && !(E4) && (E5))), \\\n+\t\t   type_if(T6, (!(E1) && !(E2) && !(E3)\t\t\t    \\\n+\t\t\t\t&& !(E4) && !(E5) && (E6))))\n+\n+/* Likewise, but return the original type rather than a pointer type.  */\n+#define first_of2(T1, E1, T2, E2)\t\t\t\\\n+\t__typeof__(*((first_of2p(T1, (E1), T2, (E2)))0))\n+#define first_of3(T1, E1, T2, E2, T3, E3)\t\t\t\t\\\n+\t__typeof__(*((first_of3p(T1, (E1), T2, (E2), T3, (E3)))0))\n+#define first_of4(T1, E1, T2, E2, T3, E3, T4, E4)\t\t\t    \\\n+\t__typeof__(*((first_of4p(T1, (E1), T2, (E2), T3, (E3), T4, (E4)))0))\n+#define first_of6(T1, E1, T2, E2, T3, E3, T4, E4, T5, E5, T6, E6)\t\\\n+\t__typeof__(*((first_of6p(T1, (E1), T2, (E2), T3, (E3),\t\t\\\n+\t\t\t\t T4, (E4), T5, (E5), T6, (E6)))0))\n+\n+/* Types of constants according to the C99 rules.  */\n+#define C99_UNSUF_TYPE(C)\t\t\t\t\t\\\n+\tfirst_of6(int, (C) <= INT_MAX,\t\t\t\t\\\n+\t\t  unsigned int, (C) <= UINT_MAX,\t\t\\\n+\t\t  long int, (C) <= LONG_MAX,\t\t\t\\\n+\t\t  unsigned long int, (C) <= ULONG_MAX,\t\t\\\n+\t\t  long long int, (C) <= LLONG_MAX,\t\t\\\n+\t\t  unsigned long long int, (C) <= ULLONG_MAX)\n+#define C99_SUFu_TYPE(C)\t\t\t\t\t\\\n+\tfirst_of3(unsigned int, (C) <= UINT_MAX,\t\t\\\n+\t\t  unsigned long int, (C) <= ULONG_MAX,\t\t\\\n+\t\t  unsigned long long int, (C) <= ULLONG_MAX)\n+#define C99_SUFl_TYPE(C)\t\t\t\t\t\\\n+\tfirst_of4(long int, (C) <= LONG_MAX,\t\t\t\\\n+\t\t  unsigned long int, (C) <= ULONG_MAX,\t\t\\\n+\t\t  long long int, (C) <= LLONG_MAX,\t\t\\\n+\t\t  unsigned long long int, (C) <= ULLONG_MAX)\n+#define C99_SUFul_TYPE(C)\t\t\t\t\t\\\n+\tfirst_of2(unsigned long int, (C) <= ULONG_MAX,\t\t\\\n+\t\t  unsigned long long int, (C) <= ULLONG_MAX)\n+#define C99_SUFll_TYPE(C)\t\t\t\t\t\\\n+\tfirst_of2(long long int, (C) <= LLONG_MAX,\t\t\\\n+\t\t  unsigned long long int, (C) <= ULLONG_MAX)\n+\n+/* Checks that constants have correct type.  */\n+#define CHECK_UNSUF_TYPE(C)\t\t\t\t\\\n+\tASSERT_CONST_TYPE((C), C99_UNSUF_TYPE((C)))\n+#define CHECK_SUFu_TYPE(C) ASSERT_CONST_TYPE((C), C99_SUFu_TYPE((C)))\n+#define CHECK_SUFl_TYPE(C)\t\t\t\t\\\n+\tASSERT_CONST_TYPE((C), C99_SUFl_TYPE((C)))\n+#define CHECK_SUFul_TYPE(C) ASSERT_CONST_TYPE((C), C99_SUFul_TYPE((C)))\n+#define CHECK_SUFll_TYPE(C)\t\t\t\t\\\n+\tASSERT_CONST_TYPE((C), C99_SUFll_TYPE((C)))\n+#define CHECK_SUFull_TYPE(C) ASSERT_CONST_TYPE((C), unsigned long long int)\n+\n+/* Check an octal or hexadecimal value, with all suffixes.  */\n+#define CHECK_CONST(C)                  \t\\\n+\tCHECK_UNSUF_TYPE(C);                    \\\n+\tCHECK_SUFu_TYPE(C##u);\t\t\t\\\n+\tCHECK_SUFu_TYPE(C##U);\t\t\t\\\n+\tCHECK_SUFl_TYPE(C##l);                  \\\n+\tCHECK_SUFl_TYPE(C##L);                  \\\n+\tCHECK_SUFul_TYPE(C##ul);\t\t\\\n+\tCHECK_SUFul_TYPE(C##uL);\t\t\\\n+\tCHECK_SUFul_TYPE(C##Ul);\t\t\\\n+\tCHECK_SUFul_TYPE(C##UL);\t\t\\\n+\tCHECK_SUFll_TYPE(C##ll);\t\t\\\n+\tCHECK_SUFll_TYPE(C##LL);\t\t\\\n+\tCHECK_SUFull_TYPE(C##ull);\t\t\\\n+\tCHECK_SUFull_TYPE(C##uLL);\t\t\\\n+\tCHECK_SUFull_TYPE(C##Ull);\t\t\\\n+\tCHECK_SUFull_TYPE(C##ULL);\n+\n+#define CHECK_BIN_CONST(C)\t\t\t\\\n+\tCHECK_CONST(0b##C);                     \\\n+\tCHECK_CONST(0B##C);\n+\n+/* True iff \"long long\" is at least B bits.  This presumes that (B-2)/3 is at\n+   most 63.  */\n+#define LLONG_AT_LEAST(B)\t\t\t\\\n+\t(LLONG_MAX >> ((B)-2)/3 >> ((B)-2)/3\t\\\n+\t >> ((B)-2 - ((B)-2)/3 - ((B)-2)/3))\n+\n+#define LLONG_HAS_BITS(B) (LLONG_AT_LEAST((B)) && !LLONG_AT_LEAST((B) + 1))\n+\n+#define FOO 0b1101\n+#if !FOO\n+# error \"preprocessor does not accept binary constants\"\n+#endif\n+\n+void\n+foo (void)\n+{\n+  /* Check all 2^n and 2^n - 1 up to 2^72 - 1.  */\n+  CHECK_BIN_CONST(1);\n+  CHECK_BIN_CONST(10);\n+  CHECK_BIN_CONST(11);\n+  CHECK_BIN_CONST(100);\n+  CHECK_BIN_CONST(111);\n+  CHECK_BIN_CONST(1000);\n+  CHECK_BIN_CONST(1111);\n+  CHECK_BIN_CONST(10000);\n+  CHECK_BIN_CONST(11111);\n+  CHECK_BIN_CONST(100000);\n+  CHECK_BIN_CONST(111111);\n+  CHECK_BIN_CONST(1000000);\n+  CHECK_BIN_CONST(1111111);\n+  CHECK_BIN_CONST(10000000);\n+  CHECK_BIN_CONST(11111111);\n+  CHECK_BIN_CONST(100000000);\n+  CHECK_BIN_CONST(111111111);\n+  CHECK_BIN_CONST(1000000000);\n+  CHECK_BIN_CONST(1111111111);\n+  CHECK_BIN_CONST(10000000000);\n+  CHECK_BIN_CONST(11111111111);\n+  CHECK_BIN_CONST(100000000000);\n+  CHECK_BIN_CONST(111111111111);\n+  CHECK_BIN_CONST(1000000000000);\n+  CHECK_BIN_CONST(1111111111111);\n+  CHECK_BIN_CONST(10000000000000);\n+  CHECK_BIN_CONST(11111111111111);\n+  CHECK_BIN_CONST(100000000000000);\n+  CHECK_BIN_CONST(111111111111111);\n+  CHECK_BIN_CONST(1000000000000000);\n+  CHECK_BIN_CONST(1111111111111111);\n+  CHECK_BIN_CONST(10000000000000000);\n+  CHECK_BIN_CONST(11111111111111111);\n+  CHECK_BIN_CONST(100000000000000000);\n+  CHECK_BIN_CONST(111111111111111111);\n+  CHECK_BIN_CONST(1000000000000000000);\n+  CHECK_BIN_CONST(1111111111111111111);\n+  CHECK_BIN_CONST(10000000000000000000);\n+  CHECK_BIN_CONST(11111111111111111111);\n+  CHECK_BIN_CONST(100000000000000000000);\n+  CHECK_BIN_CONST(111111111111111111111);\n+  CHECK_BIN_CONST(1000000000000000000000);\n+  CHECK_BIN_CONST(1111111111111111111111);\n+  CHECK_BIN_CONST(10000000000000000000000);\n+  CHECK_BIN_CONST(11111111111111111111111);\n+  CHECK_BIN_CONST(100000000000000000000000);\n+  CHECK_BIN_CONST(111111111111111111111111);\n+  CHECK_BIN_CONST(1000000000000000000000000);\n+  CHECK_BIN_CONST(1111111111111111111111111);\n+  CHECK_BIN_CONST(10000000000000000000000000);\n+  CHECK_BIN_CONST(11111111111111111111111111);\n+  CHECK_BIN_CONST(100000000000000000000000000);\n+  CHECK_BIN_CONST(111111111111111111111111111);\n+  CHECK_BIN_CONST(1000000000000000000000000000);\n+  CHECK_BIN_CONST(1111111111111111111111111111);\n+  CHECK_BIN_CONST(10000000000000000000000000000);\n+  CHECK_BIN_CONST(11111111111111111111111111111);\n+  CHECK_BIN_CONST(100000000000000000000000000000);\n+  CHECK_BIN_CONST(111111111111111111111111111111);\n+  CHECK_BIN_CONST(1000000000000000000000000000000);\n+  CHECK_BIN_CONST(1111111111111111111111111111111);\n+  CHECK_BIN_CONST(10000000000000000000000000000000);\n+  CHECK_BIN_CONST(11111111111111111111111111111111);\n+  CHECK_BIN_CONST(100000000000000000000000000000000);\n+  CHECK_BIN_CONST(111111111111111111111111111111111);\n+  CHECK_BIN_CONST(1000000000000000000000000000000000);\n+  CHECK_BIN_CONST(1111111111111111111111111111111111);\n+  CHECK_BIN_CONST(10000000000000000000000000000000000);\n+  CHECK_BIN_CONST(11111111111111111111111111111111111);\n+  CHECK_BIN_CONST(100000000000000000000000000000000000);\n+  CHECK_BIN_CONST(111111111111111111111111111111111111);\n+  CHECK_BIN_CONST(1000000000000000000000000000000000000);\n+  CHECK_BIN_CONST(1111111111111111111111111111111111111);\n+  CHECK_BIN_CONST(10000000000000000000000000000000000000);\n+  CHECK_BIN_CONST(11111111111111111111111111111111111111);\n+  CHECK_BIN_CONST(100000000000000000000000000000000000000);\n+  CHECK_BIN_CONST(111111111111111111111111111111111111111);\n+  CHECK_BIN_CONST(1000000000000000000000000000000000000000);\n+  CHECK_BIN_CONST(1111111111111111111111111111111111111111);\n+  CHECK_BIN_CONST(10000000000000000000000000000000000000000);\n+  CHECK_BIN_CONST(11111111111111111111111111111111111111111);\n+  CHECK_BIN_CONST(100000000000000000000000000000000000000000);\n+  CHECK_BIN_CONST(111111111111111111111111111111111111111111);\n+  CHECK_BIN_CONST(1000000000000000000000000000000000000000000);\n+  CHECK_BIN_CONST(1111111111111111111111111111111111111111111);\n+  CHECK_BIN_CONST(10000000000000000000000000000000000000000000);\n+  CHECK_BIN_CONST(11111111111111111111111111111111111111111111);\n+  CHECK_BIN_CONST(100000000000000000000000000000000000000000000);\n+  CHECK_BIN_CONST(111111111111111111111111111111111111111111111);\n+  CHECK_BIN_CONST(1000000000000000000000000000000000000000000000);\n+  CHECK_BIN_CONST(1111111111111111111111111111111111111111111111);\n+  CHECK_BIN_CONST(10000000000000000000000000000000000000000000000);\n+  CHECK_BIN_CONST(11111111111111111111111111111111111111111111111);\n+  CHECK_BIN_CONST(100000000000000000000000000000000000000000000000);\n+  CHECK_BIN_CONST(111111111111111111111111111111111111111111111111);\n+  CHECK_BIN_CONST(1000000000000000000000000000000000000000000000000);\n+  CHECK_BIN_CONST(1111111111111111111111111111111111111111111111111);\n+  CHECK_BIN_CONST(10000000000000000000000000000000000000000000000000);\n+  CHECK_BIN_CONST(11111111111111111111111111111111111111111111111111);\n+  CHECK_BIN_CONST(100000000000000000000000000000000000000000000000000);\n+  CHECK_BIN_CONST(111111111111111111111111111111111111111111111111111);\n+  CHECK_BIN_CONST(1000000000000000000000000000000000000000000000000000);\n+  CHECK_BIN_CONST(1111111111111111111111111111111111111111111111111111);\n+  CHECK_BIN_CONST(10000000000000000000000000000000000000000000000000000);\n+  CHECK_BIN_CONST(11111111111111111111111111111111111111111111111111111);\n+  CHECK_BIN_CONST(100000000000000000000000000000000000000000000000000000);\n+  CHECK_BIN_CONST(111111111111111111111111111111111111111111111111111111);\n+  CHECK_BIN_CONST(1000000000000000000000000000000000000000000000000000000);\n+  CHECK_BIN_CONST(1111111111111111111111111111111111111111111111111111111);\n+  CHECK_BIN_CONST(10000000000000000000000000000000000000000000000000000000);\n+  CHECK_BIN_CONST(11111111111111111111111111111111111111111111111111111111);\n+  CHECK_BIN_CONST(100000000000000000000000000000000000000000000000000000000);\n+  CHECK_BIN_CONST(111111111111111111111111111111111111111111111111111111111);\n+  CHECK_BIN_CONST(1000000000000000000000000000000000000000000000000000000000);\n+  CHECK_BIN_CONST(1111111111111111111111111111111111111111111111111111111111);\n+  CHECK_BIN_CONST(10000000000000000000000000000000000000000000000000000000000);\n+  CHECK_BIN_CONST(11111111111111111111111111111111111111111111111111111111111);\n+  CHECK_BIN_CONST(100000000000000000000000000000000000000000000000000000000000);\n+  CHECK_BIN_CONST(111111111111111111111111111111111111111111111111111111111111);\n+  CHECK_BIN_CONST(1000000000000000000000000000000000000000000000000000000000000);\n+  CHECK_BIN_CONST(1111111111111111111111111111111111111111111111111111111111111);\n+  CHECK_BIN_CONST(10000000000000000000000000000000000000000000000000000000000000);\n+  CHECK_BIN_CONST(11111111111111111111111111111111111111111111111111111111111111);\n+  CHECK_BIN_CONST(100000000000000000000000000000000000000000000000000000000000000);\n+  CHECK_BIN_CONST(111111111111111111111111111111111111111111111111111111111111111);\n+  CHECK_BIN_CONST(1000000000000000000000000000000000000000000000000000000000000000);\n+  CHECK_BIN_CONST(1111111111111111111111111111111111111111111111111111111111111111);\n+#if LLONG_AT_LEAST(65)\n+  CHECK_BIN_CONST(10000000000000000000000000000000000000000000000000000000000000000);\n+  CHECK_BIN_CONST(11111111111111111111111111111111111111111111111111111111111111111);\n+#endif\n+#if LLONG_AT_LEAST(66)\n+  CHECK_BIN_CONST(100000000000000000000000000000000000000000000000000000000000000000);\n+  CHECK_BIN_CONST(111111111111111111111111111111111111111111111111111111111111111111);\n+#endif\n+#if LLONG_AT_LEAST(67)\n+  CHECK_BIN_CONST(1000000000000000000000000000000000000000000000000000000000000000000);\n+  CHECK_BIN_CONST(1111111111111111111111111111111111111111111111111111111111111111111);\n+#endif\n+#if LLONG_AT_LEAST(68)\n+  CHECK_BIN_CONST(10000000000000000000000000000000000000000000000000000000000000000000);\n+  CHECK_BIN_CONST(11111111111111111111111111111111111111111111111111111111111111111111);\n+#endif\n+#if LLONG_AT_LEAST(69)\n+  CHECK_BIN_CONST(100000000000000000000000000000000000000000000000000000000000000000000);\n+  CHECK_BIN_CONST(111111111111111111111111111111111111111111111111111111111111111111111);\n+#endif\n+#if LLONG_AT_LEAST(70)\n+  CHECK_BIN_CONST(1000000000000000000000000000000000000000000000000000000000000000000000);\n+  CHECK_BIN_CONST(1111111111111111111111111111111111111111111111111111111111111111111111);\n+#endif\n+#if LLONG_AT_LEAST(71)\n+  CHECK_BIN_CONST(10000000000000000000000000000000000000000000000000000000000000000000000);\n+  CHECK_BIN_CONST(11111111111111111111111111111111111111111111111111111111111111111111111);\n+#endif\n+#if LLONG_AT_LEAST(72)\n+  CHECK_BIN_CONST(100000000000000000000000000000000000000000000000000000000000000000000000);\n+  CHECK_BIN_CONST(111111111111111111111111111111111111111111111111111111111111111111111111);\n+#endif\n+}\n+"}, {"sha": "40d7636465668e234d521025898af88b1d561898", "filename": "gcc/testsuite/gcc.dg/binary-constants-2.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7fd775f0203c580b35b179976c665db3e4d9e46/gcc%2Ftestsuite%2Fgcc.dg%2Fbinary-constants-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7fd775f0203c580b35b179976c665db3e4d9e46/gcc%2Ftestsuite%2Fgcc.dg%2Fbinary-constants-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbinary-constants-2.c?ref=f7fd775f0203c580b35b179976c665db3e4d9e46", "patch": "@@ -0,0 +1,16 @@\n+/* Test for binary integer constants: -pedantic warnings.  */\n+\n+/* Origin: Joerg Wunsch <j.gnu@uriah.heep.sax.de>.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=iso9899:1999 -pedantic\" } */\n+\n+#define FOO 0b1101\n+\n+int\n+foo (void)\n+{\n+#if FOO /* { dg-warning \"binary constants are a GCC extension\" } */\n+  return 23;\n+#endif\n+  return 0b1101; /* { dg-warning \"binary constants are a GCC extension\" } */\n+}"}, {"sha": "984477dca18162aaa47f749f7eea2e0d0aff04e8", "filename": "gcc/testsuite/gcc.dg/binary-constants-3.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7fd775f0203c580b35b179976c665db3e4d9e46/gcc%2Ftestsuite%2Fgcc.dg%2Fbinary-constants-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7fd775f0203c580b35b179976c665db3e4d9e46/gcc%2Ftestsuite%2Fgcc.dg%2Fbinary-constants-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbinary-constants-3.c?ref=f7fd775f0203c580b35b179976c665db3e4d9e46", "patch": "@@ -0,0 +1,16 @@\n+/* Test for binary integer constants: -pedantic-errors.  */\n+\n+/* Origin: Joerg Wunsch <j.gnu@uriah.heep.sax.de>.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=iso9899:1999 -pedantic-errors\" } */\n+\n+#define FOO 0b1101\n+\n+int\n+foo (void)\n+{\n+#if FOO /* { dg-error \"binary constants are a GCC extension\" } */\n+  return 23;\n+#endif\n+  return 0b1101; /* { dg-error \"binary constants are a GCC extension\" } */\n+}"}, {"sha": "32c9d65a5ed2c5e29d7e45e91276bfffd0e81809", "filename": "gcc/testsuite/gcc.dg/binary-constants-4.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7fd775f0203c580b35b179976c665db3e4d9e46/gcc%2Ftestsuite%2Fgcc.dg%2Fbinary-constants-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7fd775f0203c580b35b179976c665db3e4d9e46/gcc%2Ftestsuite%2Fgcc.dg%2Fbinary-constants-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbinary-constants-4.c?ref=f7fd775f0203c580b35b179976c665db3e4d9e46", "patch": "@@ -0,0 +1,18 @@\n+/* Test for binary integer constants: random errors.  */\n+\n+/* Origin: Joerg Wunsch <j.gnu@uriah.heep.sax.de>.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=gnu99\" } */\n+\n+void\n+foo(void)\n+{\n+  double d;\n+  int i;\n+\n+  d = 0b1101;\n+  d = 0b1101p1; /* { dg-error \"invalid suffix \\\"p1\\\" on integer constant\" } */\n+  d = 0x1101p1;\n+  i = 0b3011;   /* { dg-error \"invalid suffix \\\"b3011\\\" on integer constant\" } */\n+  i = 0b113;    /* { dg-error \"invalid digit \\\"3\\\" in binary constant\" } */\n+}"}, {"sha": "712bc32784b5599f8e21398a6ce0bafd0266bf00", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7fd775f0203c580b35b179976c665db3e4d9e46/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7fd775f0203c580b35b179976c665db3e4d9e46/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=f7fd775f0203c580b35b179976c665db3e4d9e46", "patch": "@@ -1,3 +1,12 @@\n+2007-06-05  Joerg Wunsch  <j.gnu@uriah.heep.sax.de>\n+\n+\tPR preprocessor/23479\n+\t* expr.c (cpp_classify_number): Implement 0b-prefixed binary\n+\tinteger constants.\n+\t(append_digit): Likewise.\n+\t* include/cpplib.h: Add CPP_N_BINARY, to be used for 0b-prefixed\n+\tbinary integer constants.\n+\n 2007-05-31  Dave Korn  <dave.korn@artimi.com>\n \n \tPR preprocessor/14331"}, {"sha": "59de8ef9ec973db28feca84a59c51c4cfdd5d6fd", "filename": "libcpp/expr.c", "status": "modified", "additions": 43, "deletions": 3, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7fd775f0203c580b35b179976c665db3e4d9e46/libcpp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7fd775f0203c580b35b179976c665db3e4d9e46/libcpp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fexpr.c?ref=f7fd775f0203c580b35b179976c665db3e4d9e46", "patch": "@@ -185,6 +185,11 @@ cpp_classify_number (cpp_reader *pfile, const cpp_token *token)\n \t  radix = 16;\n \t  str++;\n \t}\n+      else if ((*str == 'b' || *str == 'B') && (str[1] == '0' || str[1] == '1'))\n+\t{\n+\t  radix = 2;\n+\t  str++;\n+\t}\n     }\n \n   /* Now scan for a well-formed integer or float.  */\n@@ -223,10 +228,22 @@ cpp_classify_number (cpp_reader *pfile, const cpp_token *token)\n     radix = 10;\n \n   if (max_digit >= radix)\n-    SYNTAX_ERROR2 (\"invalid digit \\\"%c\\\" in octal constant\", '0' + max_digit);\n+    {\n+      if (radix == 2)\n+\tSYNTAX_ERROR2 (\"invalid digit \\\"%c\\\" in binary constant\", '0' + max_digit);\n+      else\n+\tSYNTAX_ERROR2 (\"invalid digit \\\"%c\\\" in octal constant\", '0' + max_digit);\n+    }\n \n   if (float_flag != NOT_FLOAT)\n     {\n+      if (radix == 2)\n+\t{\n+\t  cpp_error (pfile, CPP_DL_ERROR,\n+\t\t     \"invalid prefix \\\"0b\\\" for floating constant\");\n+\t  return CPP_N_INVALID;\n+\t}\n+\n       if (radix == 16 && CPP_PEDANTIC (pfile) && !CPP_OPTION (pfile, c99))\n \tcpp_error (pfile, CPP_DL_PEDWARN,\n \t\t   \"use of C99 hexadecimal floating constant\");\n@@ -315,11 +332,16 @@ cpp_classify_number (cpp_reader *pfile, const cpp_token *token)\n   if ((result & CPP_N_IMAGINARY) && CPP_PEDANTIC (pfile))\n     cpp_error (pfile, CPP_DL_PEDWARN,\n \t       \"imaginary constants are a GCC extension\");\n+  if (radix == 2 && CPP_PEDANTIC (pfile))\n+    cpp_error (pfile, CPP_DL_PEDWARN,\n+\t       \"binary constants are a GCC extension\");\n \n   if (radix == 10)\n     result |= CPP_N_DECIMAL;\n   else if (radix == 16)\n     result |= CPP_N_HEX;\n+  else if (radix == 2)\n+    result |= CPP_N_BINARY;\n   else\n     result |= CPP_N_OCTAL;\n \n@@ -370,6 +392,11 @@ cpp_interpret_integer (cpp_reader *pfile, const cpp_token *token,\n \t  base = 16;\n \t  p += 2;\n \t}\n+      else if ((type & CPP_N_RADIX) == CPP_N_BINARY)\n+\t{\n+\t  base = 2;\n+\t  p += 2;\n+\t}\n \n       /* We can add a digit to numbers strictly less than this without\n \t needing the precision and slowness of double integers.  */\n@@ -425,12 +452,25 @@ static cpp_num\n append_digit (cpp_num num, int digit, int base, size_t precision)\n {\n   cpp_num result;\n-  unsigned int shift = 3 + (base == 16);\n+  unsigned int shift;\n   bool overflow;\n   cpp_num_part add_high, add_low;\n \n-  /* Multiply by 8 or 16.  Catching this overflow here means we don't\n+  /* Multiply by 2, 8 or 16.  Catching this overflow here means we don't\n      need to worry about add_high overflowing.  */\n+  switch (base)\n+    {\n+    case 2:\n+      shift = 1;\n+      break;\n+\n+    case 16:\n+      shift = 4;\n+      break;\n+\n+    default:\n+      shift = 3;\n+    }\n   overflow = !!(num.high >> (PART_PRECISION - shift));\n   result.high = num.high << shift;\n   result.low = num.low << shift;"}, {"sha": "0edcf655c92a0996a2b17c34278429ff510a9840", "filename": "libcpp/include/cpplib.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7fd775f0203c580b35b179976c665db3e4d9e46/libcpp%2Finclude%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7fd775f0203c580b35b179976c665db3e4d9e46/libcpp%2Finclude%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fcpplib.h?ref=f7fd775f0203c580b35b179976c665db3e4d9e46", "patch": "@@ -748,6 +748,7 @@ struct cpp_num\n #define CPP_N_DECIMAL\t0x0100\n #define CPP_N_HEX\t0x0200\n #define CPP_N_OCTAL\t0x0400\n+#define CPP_N_BINARY\t0x0800\n \n #define CPP_N_UNSIGNED\t0x1000\t/* Properties.  */\n #define CPP_N_IMAGINARY\t0x2000"}]}