{"sha": "e9840398cdbad4b4cea71552cd74daac15f20a3e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTk4NDAzOThjZGJhZDRiNGNlYTcxNTUyY2Q3NGRhYWMxNWYyMGEzZQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2004-12-15T20:22:26Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2004-12-15T20:22:26Z"}, "message": "reload.c (SMALL_REGISTER_CLASS_P): New.\n\n* reload.c (SMALL_REGISTER_CLASS_P): New.\n(push_secondary_reload, find_reusable_reload, find_reloads): Use\nit instead of testing only the class size.\n\nFrom-SVN: r92221", "tree": {"sha": "bb89cb914132ddf7612552e79b22268789031b24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb89cb914132ddf7612552e79b22268789031b24"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9840398cdbad4b4cea71552cd74daac15f20a3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9840398cdbad4b4cea71552cd74daac15f20a3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9840398cdbad4b4cea71552cd74daac15f20a3e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9840398cdbad4b4cea71552cd74daac15f20a3e/comments", "author": null, "committer": null, "parents": [{"sha": "e2435498541e4b7925abecdad08cec55280d8971", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2435498541e4b7925abecdad08cec55280d8971", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2435498541e4b7925abecdad08cec55280d8971"}], "stats": {"total": 28, "additions": 21, "deletions": 7}, "files": [{"sha": "41e4ebaf3656661b17760b6ec998ff40ee36c283", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9840398cdbad4b4cea71552cd74daac15f20a3e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9840398cdbad4b4cea71552cd74daac15f20a3e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e9840398cdbad4b4cea71552cd74daac15f20a3e", "patch": "@@ -1,3 +1,9 @@\n+2004-12-15  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* reload.c (SMALL_REGISTER_CLASS_P): New.\n+\t(push_secondary_reload, find_reusable_reload, find_reloads): Use\n+\tit instead of testing only the class size.\n+\n 2004-12-15  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \tPR c++/17972"}, {"sha": "dc45ea5e0f33d691905b889b83463ab86ee63c52", "filename": "gcc/reload.c", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9840398cdbad4b4cea71552cd74daac15f20a3e/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9840398cdbad4b4cea71552cd74daac15f20a3e/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=e9840398cdbad4b4cea71552cd74daac15f20a3e", "patch": "@@ -113,6 +113,13 @@ a register with any other reload.  */\n   (CONSTANT_P (X)\t\t\t\t\\\n    && GET_CODE (X) != HIGH\t\t\t\\\n    && !targetm.cannot_force_const_mem (X))\n+\n+/* True if C is a non-empty register class that has too few registers\n+   to be safely used as a reload target class.  */\n+#define SMALL_REGISTER_CLASS_P(C) \\\n+  (reg_class_size [(C)] == 1 \\\n+   || (reg_class_size [(C)] >= 1 && CLASS_LIKELY_SPILLED_P (C)))\n+\n \f\n /* All reloads of the current insn are recorded here.  See reload.h for\n    comments.  */\n@@ -443,7 +450,7 @@ push_secondary_reload (int in_p, rtx x, int opnum, int optional,\n \t\t\t  == CODE_FOR_nothing))\n \t\t|| (! in_p &&(rld[t_reload].secondary_out_icode\n \t\t\t      == CODE_FOR_nothing)))\n-\t    && (reg_class_size[(int) t_class] == 1 || SMALL_REGISTER_CLASSES)\n+\t    && (SMALL_REGISTER_CLASS_P (t_class) || SMALL_REGISTER_CLASSES)\n \t    && MERGABLE_RELOADS (secondary_type,\n \t\t\t\t rld[t_reload].when_needed,\n \t\t\t\t opnum, rld[t_reload].opnum))\n@@ -501,7 +508,7 @@ push_secondary_reload (int in_p, rtx x, int opnum, int optional,\n \t    || (! in_p && rld[s_reload].secondary_out_reload == t_reload))\n \t&& ((in_p && rld[s_reload].secondary_in_icode == t_icode)\n \t    || (! in_p && rld[s_reload].secondary_out_icode == t_icode))\n-\t&& (reg_class_size[(int) class] == 1 || SMALL_REGISTER_CLASSES)\n+\t&& (SMALL_REGISTER_CLASS_P (class) || SMALL_REGISTER_CLASSES)\n \t&& MERGABLE_RELOADS (secondary_type, rld[s_reload].when_needed,\n \t\t\t     opnum, rld[s_reload].opnum))\n       {\n@@ -755,7 +762,7 @@ find_reusable_reload (rtx *p_in, rtx out, enum reg_class class,\n \t    || (out != 0 && MATCHES (rld[i].out, out)\n \t\t&& (in == 0 || rld[i].in == 0 || MATCHES (rld[i].in, in))))\n \t&& (rld[i].out == 0 || ! earlyclobber_operand_p (rld[i].out))\n-\t&& (reg_class_size[(int) class] == 1 || SMALL_REGISTER_CLASSES)\n+\t&& (SMALL_REGISTER_CLASS_P (class) || SMALL_REGISTER_CLASSES)\n \t&& MERGABLE_RELOADS (type, rld[i].when_needed, opnum, rld[i].opnum))\n       return i;\n \n@@ -780,7 +787,7 @@ find_reusable_reload (rtx *p_in, rtx out, enum reg_class class,\n \t\t&& GET_RTX_CLASS (GET_CODE (in)) == RTX_AUTOINC\n \t\t&& MATCHES (XEXP (in, 0), rld[i].in)))\n \t&& (rld[i].out == 0 || ! earlyclobber_operand_p (rld[i].out))\n-\t&& (reg_class_size[(int) class] == 1 || SMALL_REGISTER_CLASSES)\n+\t&& (SMALL_REGISTER_CLASS_P (class) || SMALL_REGISTER_CLASSES)\n \t&& MERGABLE_RELOADS (type, rld[i].when_needed,\n \t\t\t     opnum, rld[i].opnum))\n       {\n@@ -3484,7 +3491,8 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t  if (! win && ! did_match\n \t      && this_alternative[i] != (int) NO_REGS\n \t      && GET_MODE_SIZE (operand_mode[i]) <= UNITS_PER_WORD\n-\t      && reg_class_size[(int) preferred_class[i]] > 1)\n+\t      && reg_class_size [(int) preferred_class[i]] > 0\n+\t      && ! SMALL_REGISTER_CLASS_P (preferred_class[i]))\n \t    {\n \t      if (! reg_class_subset_p (this_alternative[i],\n \t\t\t\t\tpreferred_class[i]))\n@@ -3540,9 +3548,9 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\t  && !immune_p (recog_data.operand[j], recog_data.operand[i],\n \t\t\t\tearly_data))\n \t\t{\n-\t\t  /* If the output is in a single-reg class,\n+\t\t  /* If the output is in a non-empty few-regs class,\n \t\t     it's costly to reload it, so reload the input instead.  */\n-\t\t  if (reg_class_size[this_alternative[i]] == 1\n+\t\t  if (SMALL_REGISTER_CLASS_P (this_alternative[i])\n \t\t      && (REG_P (recog_data.operand[j])\n \t\t\t  || GET_CODE (recog_data.operand[j]) == SUBREG))\n \t\t    {"}]}