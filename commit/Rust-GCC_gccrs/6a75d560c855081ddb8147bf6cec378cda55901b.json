{"sha": "6a75d560c855081ddb8147bf6cec378cda55901b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmE3NWQ1NjBjODU1MDgxZGRiODE0N2JmNmNlYzM3OGNkYTU1OTAxYg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2015-10-21T20:11:33Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2015-10-21T20:11:33Z"}, "message": "Add a pass to back-propagate use information\n\nThis patch adds a pass that collects information that is common to\nall uses of an SSA name X and back-propagates that information up\nthe statements that generate X.  The general idea is to use the\ninformation to simplify instructions (rather than a pure DCE) so\nI've simply called it gimple-ssa-backprop.c, to go with\ntree-ssa-forwprop.c.\n\nAt the moment the only use of the pass is to remove unnecessary\nsign operations, so that it's effectively a global version of\nfold_strip_sign_ops.  I'm hoping it could be extended in future\nto record which bits of an integer are significant.  There are\nprobably other potential uses too.\n\nA later patch gets rid of fold_strip_sign_ops.\n\nTested on x86_64-linux-gnu, aarch64-linux-gnu and arm-linux-gnueabi.\n\ngcc/\n\t* doc/invoke.texi (-fdump-tree-backprop, -fssa-backprop): Document.\n\t* Makefile.in (OBJS): Add gimple-ssa-backprop.o.\n\t* common.opt (fssa-backprop): New option.\n\t* fold-const.h (negate_mathfn_p): Declare.\n\t* fold-const.c (negate_mathfn_p): Make public.\n\t* timevar.def (TV_TREE_BACKPROP): New.\n\t* tree-pass.h (make_pass_backprop): Declare.\n\t* passes.def (pass_backprop): Add.\n\t* gimple-ssa-backprop.c: New file.\n\ngcc/testsuite/\n\t* gcc.dg/tree-ssa/backprop-1.c, gcc.dg/tree-ssa/backprop-2.c,\n\tgcc.dg/tree-ssa/backprop-3.c, gcc.dg/tree-ssa/backprop-4.c,\n\tgcc.dg/tree-ssa/backprop-5.c, gcc.dg/tree-ssa/backprop-6.c: New tests.\n\nFrom-SVN: r229139", "tree": {"sha": "468c0e4a1b28417766a235b583ad1633ef8b346f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/468c0e4a1b28417766a235b583ad1633ef8b346f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a75d560c855081ddb8147bf6cec378cda55901b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a75d560c855081ddb8147bf6cec378cda55901b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a75d560c855081ddb8147bf6cec378cda55901b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a75d560c855081ddb8147bf6cec378cda55901b/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "77ec8b8c0f75a5f0b953e5dd6696e6b07253f21b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77ec8b8c0f75a5f0b953e5dd6696e6b07253f21b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77ec8b8c0f75a5f0b953e5dd6696e6b07253f21b"}], "stats": {"total": 1144, "additions": 1138, "deletions": 6}, "files": [{"sha": "bd59f87188ea50ab417338a244e11fcaba078565", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a75d560c855081ddb8147bf6cec378cda55901b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a75d560c855081ddb8147bf6cec378cda55901b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6a75d560c855081ddb8147bf6cec378cda55901b", "patch": "@@ -1,3 +1,15 @@\n+2015-10-21  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* doc/invoke.texi (-fdump-tree-backprop, -fssa-backprop): Document.\n+\t* Makefile.in (OBJS): Add gimple-ssa-backprop.o.\n+\t* common.opt (fssa-backprop): New option.\n+\t* fold-const.h (negate_mathfn_p): Declare.\n+\t* fold-const.c (negate_mathfn_p): Make public.\n+\t* timevar.def (TV_TREE_BACKPROP): New.\n+\t* tree-pass.h (make_pass_backprop): Declare.\n+\t* passes.def (pass_backprop): Add.\n+\t* gimple-ssa-backprop.c: New file.\n+\n 2015-10-21  Aditya Kumar  <aditya.k7@samsung.com>\n \t    Sebastian Pop  <s.pop@samsung.com>\n "}, {"sha": "b91b8dcffeaaca69475cfbbceaf7412135c697e4", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a75d560c855081ddb8147bf6cec378cda55901b/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a75d560c855081ddb8147bf6cec378cda55901b/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=6a75d560c855081ddb8147bf6cec378cda55901b", "patch": "@@ -1266,6 +1266,7 @@ OBJS = \\\n \tgimple-laddress.o \\\n \tgimple-low.o \\\n \tgimple-pretty-print.o \\\n+\tgimple-ssa-backprop.o \\\n \tgimple-ssa-isolate-paths.o \\\n \tgimple-ssa-strength-reduction.o \\\n \tgimple-streamer-in.o \\"}, {"sha": "f497236f735031466c566d7ebbc8f61620a735be", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a75d560c855081ddb8147bf6cec378cda55901b/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a75d560c855081ddb8147bf6cec378cda55901b/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=6a75d560c855081ddb8147bf6cec378cda55901b", "patch": "@@ -2114,6 +2114,10 @@ fsplit-wide-types\n Common Report Var(flag_split_wide_types) Optimization\n Split wide types into independent registers\n \n+fssa-backprop\n+Common Report Var(flag_ssa_backprop) Init(1) Optimization\n+Enable backward propagation of use properties at the SSA level.\n+\n fssa-phiopt\n Common Report Var(flag_ssa_phiopt) Optimization\n Optimize conditional patterns using SSA PHI nodes"}, {"sha": "cd8254464b4731e725a6b20fa2f2de8a065c4f30", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a75d560c855081ddb8147bf6cec378cda55901b/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a75d560c855081ddb8147bf6cec378cda55901b/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=6a75d560c855081ddb8147bf6cec378cda55901b", "patch": "@@ -343,6 +343,7 @@ Objective-C and Objective-C++ Dialects}.\n -fdump-tree-dse@r{[}-@var{n}@r{]} @gol\n -fdump-tree-phiprop@r{[}-@var{n}@r{]} @gol\n -fdump-tree-phiopt@r{[}-@var{n}@r{]} @gol\n+-fdump-tree-backprop@r{[}-@var{n}@r{]} @gol\n -fdump-tree-forwprop@r{[}-@var{n}@r{]} @gol\n -fdump-tree-nrv -fdump-tree-vect @gol\n -fdump-tree-sink @gol\n@@ -443,9 +444,9 @@ Objective-C and Objective-C++ Dialects}.\n -fschedule-insns -fschedule-insns2 -fsection-anchors @gol\n -fselective-scheduling -fselective-scheduling2 @gol\n -fsel-sched-pipelining -fsel-sched-pipelining-outer-loops @gol\n--fsemantic-interposition @gol\n--fshrink-wrap -fsignaling-nans -fsingle-precision-constant @gol\n--fsplit-ivs-in-unroller -fsplit-wide-types -fssa-phiopt @gol\n+-fsemantic-interposition -fshrink-wrap -fsignaling-nans @gol\n+-fsingle-precision-constant -fsplit-ivs-in-unroller @gol\n+-fsplit-wide-types -fssa-backprop -fssa-phiopt @gol\n -fstack-protector -fstack-protector-all -fstack-protector-strong @gol\n -fstack-protector-explicit -fstdarg-opt -fstrict-aliasing @gol\n -fstrict-overflow -fthread-jumps -ftracer -ftree-bit-ccp @gol\n@@ -7236,6 +7237,12 @@ name is made by appending @file{.dse} to the source file name.\n Dump each function after optimizing PHI nodes into straightline code.  The file\n name is made by appending @file{.phiopt} to the source file name.\n \n+@item backprop\n+@opindex fdump-tree-backprop\n+Dump each function after back-propagating use information up the definition\n+chain.  The file name is made by appending @file{.backprop} to the\n+source file name.\n+\n @item forwprop\n @opindex fdump-tree-forwprop\n Dump each function after forward propagating single use variables.  The file\n@@ -7707,9 +7714,10 @@ compilation time.\n -freorder-blocks @gol\n -fshrink-wrap @gol\n -fsplit-wide-types @gol\n+-fssa-backprop @gol\n+-fssa-phiopt @gol\n -ftree-bit-ccp @gol\n -ftree-ccp @gol\n--fssa-phiopt @gol\n -ftree-ch @gol\n -ftree-coalesce-vars @gol\n -ftree-copy-prop @gol\n@@ -8795,6 +8803,13 @@ Perform sparse conditional constant propagation (CCP) on trees.  This\n pass only operates on local scalar variables and is enabled by default\n at @option{-O} and higher.\n \n+@item -fssa-backprop\n+@opindex fssa-backprop\n+Propagate information about uses of a value up the definition chain\n+in order to simplify the definitions.  For example, this pass strips\n+sign operations if the sign of a value never matters.  The flag is\n+enabled by default at @option{-O} and higher.\n+\n @item -fssa-phiopt\n @opindex fssa-phiopt\n Perform pattern matching on SSA PHI nodes to optimize conditional"}, {"sha": "dff1d5545efc2101f71e652a116726a38fe8e4ea", "filename": "gcc/fold-const.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a75d560c855081ddb8147bf6cec378cda55901b/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a75d560c855081ddb8147bf6cec378cda55901b/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=6a75d560c855081ddb8147bf6cec378cda55901b", "patch": "@@ -112,7 +112,6 @@ enum comparison_code {\n   COMPCODE_TRUE = 15\n };\n \n-static bool negate_mathfn_p (enum built_in_function);\n static bool negate_expr_p (tree);\n static tree negate_expr (tree);\n static tree split_tree (tree, enum tree_code, tree *, tree *, tree *, int);\n@@ -321,7 +320,7 @@ fold_overflow_warning (const char* gmsgid, enum warn_strict_overflow_code wc)\n /* Return true if the built-in mathematical function specified by CODE\n    is odd, i.e. -f(x) == f(-x).  */\n \n-static bool\n+bool\n negate_mathfn_p (enum built_in_function code)\n {\n   switch (code)"}, {"sha": "4d5b24b1833961dc32d8514a25813f858b4b55bd", "filename": "gcc/fold-const.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a75d560c855081ddb8147bf6cec378cda55901b/gcc%2Ffold-const.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a75d560c855081ddb8147bf6cec378cda55901b/gcc%2Ffold-const.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.h?ref=6a75d560c855081ddb8147bf6cec378cda55901b", "patch": "@@ -173,6 +173,7 @@ extern tree sign_bit_p (tree, const_tree);\n extern tree exact_inverse (tree, tree);\n extern tree const_unop (enum tree_code, tree, tree);\n extern tree const_binop (enum tree_code, tree, tree, tree);\n+extern bool negate_mathfn_p (enum built_in_function);\n \n /* Return OFF converted to a pointer offset type suitable as offset for\n    POINTER_PLUS_EXPR.  Use location LOC for this conversion.  */"}, {"sha": "91a3c79fb1c7a31ee05fe1fb222687dbda96e435", "filename": "gcc/gimple-ssa-backprop.c", "status": "added", "additions": 956, "deletions": 0, "changes": 956, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a75d560c855081ddb8147bf6cec378cda55901b/gcc%2Fgimple-ssa-backprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a75d560c855081ddb8147bf6cec378cda55901b/gcc%2Fgimple-ssa-backprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-backprop.c?ref=6a75d560c855081ddb8147bf6cec378cda55901b", "patch": "@@ -0,0 +1,956 @@\n+/* Back-propagation of usage information to definitions.\n+   Copyright (C) 2015 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* This pass propagates information that is common to all uses of an SSA\n+   name back up through the sequence of statements that generate it,\n+   simplifying the statements where possible.  Sometimes this can expose\n+   fully or partially dead code, but the main focus is simplifying\n+   computations.\n+\n+   At the moment the pass only handles one piece of information: whether the\n+   sign of a value matters, and therefore whether sign-changing operations\n+   can be skipped.  The pass could be extended to more interesting\n+   information in future, such as which bits of an integer are significant.\n+\n+   For example, take the function:\n+\n+     double\n+     f (double *a, int n, double start)\n+     {\n+       double x = fabs (start);\n+       for (int i = 0; i < n; ++i)\n+\t x *= a[i];\n+       return __builtin_cos (x);\n+     }\n+\n+   cos(x) == cos(-x), so the sign of the final x doesn't matter.\n+   That x is the result of a series of multiplications, and if\n+   the sign of the result of a multiplication doesn't matter,\n+   the signs of the inputs don't matter either.\n+\n+   The pass would replace the incoming value of x (i.e. fabs(start))\n+   with start.  Since there are no other uses of the fabs result,\n+   the call would get deleted as dead.\n+\n+   The algorithm is:\n+\n+   (1) Do a post-order traversal of the blocks in the function, walking\n+       each block backwards.  For each potentially-simplifiable statement\n+       that defines an SSA name X, examine all uses of X to see what\n+       information is actually significant.  Record this as INFO_MAP[X].\n+       Optimistically ignore for now any back-edge references to\n+       unprocessed phis.\n+\n+       (An alternative would be to record each use when we visit its\n+       statement and take the intersection as we go along.  However,\n+       this would lead to more SSA names being entered into INFO_MAP\n+       unnecessarily, only to be taken out again later.  At the moment\n+       very few SSA names end up with useful information.)\n+\n+   (2) Iteratively reduce the optimistic result of (1) until we reach\n+       a maximal fixed point (which at the moment would mean revisiting\n+       statements at most once).  First push all SSA names that used an\n+       optimistic assumption about a backedge phi onto a worklist.\n+       While the worklist is nonempty, pick off an SSA name X and recompute\n+       INFO_MAP[X].  If the value changes, push all SSA names used in the\n+       definition of X onto the worklist.\n+\n+   (3) Iterate over each SSA name X with info in INFO_MAP, in the\n+       opposite order to (1), i.e. a forward reverse-post-order walk.\n+       Try to optimize the definition of X using INFO_MAP[X] and fold\n+       the result.  (This ensures that we fold definitions before uses.)\n+\n+   (4) Iterate over each SSA name X with info in INFO_MAP, in the same\n+       order as (1), and delete any statements that are now dead.\n+       (This ensures that if a sequence of statements is dead,\n+       we delete the last statement first.)\n+\n+   Note that this pass does not deal with direct redundancies,\n+   such as cos(-x)->cos(x).  match.pd handles those cases instead.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"gimple-iterator.h\"\n+#include \"ssa.h\"\n+#include \"fold-const.h\"\n+#include \"tree-pass.h\"\n+#include \"cfganal.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"tree-cfg.h\"\n+#include \"tree-ssa.h\"\n+#include \"tree-ssa-propagate.h\"\n+#include \"gimple-fold.h\"\n+#include \"alloc-pool.h\"\n+#include \"tree-hash-traits.h\"\n+\n+namespace {\n+\n+/* Information about a group of uses of an SSA name.  */\n+struct usage_info\n+{\n+  usage_info () : flag_word (0) {}\n+  usage_info &operator &= (const usage_info &);\n+  usage_info operator & (const usage_info &) const;\n+  bool operator == (const usage_info &) const;\n+  bool operator != (const usage_info &) const;\n+  bool is_useful () const;\n+\n+  static usage_info intersection_identity ();\n+\n+  union\n+  {\n+    struct\n+    {\n+      /* True if the uses treat x and -x in the same way.  */\n+      unsigned int ignore_sign : 1;\n+    } flags;\n+    /* All the flag bits as a single int.  */\n+    unsigned int flag_word;\n+  };\n+};\n+\n+/* Return an X such that X & Y == Y for all Y.  This is the most\n+   optimistic assumption possible.  */\n+\n+usage_info\n+usage_info::intersection_identity ()\n+{\n+  usage_info ret;\n+  ret.flag_word = -1;\n+  return ret;\n+}\n+\n+/* Intersect *THIS with OTHER, so that *THIS describes all uses covered\n+   by the original *THIS and OTHER.  */\n+\n+usage_info &\n+usage_info::operator &= (const usage_info &other)\n+{\n+  flag_word &= other.flag_word;\n+  return *this;\n+}\n+\n+/* Return the intersection of *THIS and OTHER, i.e. a structure that\n+   describes all uses covered by *THIS and OTHER.  */\n+\n+usage_info\n+usage_info::operator & (const usage_info &other) const\n+{\n+  usage_info info (*this);\n+  info &= other;\n+  return info;\n+}\n+\n+bool\n+usage_info::operator == (const usage_info &other) const\n+{\n+  return flag_word == other.flag_word;\n+}\n+\n+bool\n+usage_info::operator != (const usage_info &other) const\n+{\n+  return !operator == (other);\n+}\n+\n+/* Return true if *THIS is not simply the default, safe assumption.  */\n+\n+bool\n+usage_info::is_useful () const\n+{\n+  return flag_word != 0;\n+}\n+\n+/* Start a dump line about SSA name VAR.  */\n+\n+static void\n+dump_usage_prefix (FILE *file, tree var)\n+{\n+  fprintf (file, \"  \");\n+  print_generic_expr (file, var, 0);\n+  fprintf (file, \": \");\n+}\n+\n+/* Print INFO to FILE.  */\n+\n+static void\n+dump_usage_info (FILE *file, tree var, usage_info *info)\n+{\n+  if (info->flags.ignore_sign)\n+    {\n+      dump_usage_prefix (file, var);\n+      fprintf (file, \"sign bit not important\\n\");\n+    }\n+}\n+\n+/* Represents one execution of the pass.  */\n+class backprop\n+{\n+public:\n+  backprop (function *);\n+  ~backprop ();\n+\n+  void execute ();\n+\n+private:\n+  const usage_info *lookup_operand (tree);\n+\n+  void push_to_worklist (tree);\n+  tree pop_from_worklist ();\n+\n+  void process_builtin_call_use (gcall *, tree, usage_info *);\n+  void process_assign_use (gassign *, tree, usage_info *);\n+  void process_phi_use (gphi *, usage_info *);\n+  void process_use (gimple *, tree, usage_info *);\n+  bool intersect_uses (tree, usage_info *);\n+  void reprocess_inputs (gimple *);\n+  void process_var (tree);\n+  void process_block (basic_block);\n+\n+  void prepare_change (tree);\n+  void complete_change (gimple *);\n+  void optimize_builtin_call (gcall *, tree, const usage_info *);\n+  void replace_assign_rhs (gassign *, tree, tree, tree, tree);\n+  void optimize_assign (gassign *, tree, const usage_info *);\n+  void optimize_phi (gphi *, tree, const usage_info *);\n+\n+  typedef hash_map <tree_ssa_name_hash, usage_info *> info_map_type;\n+  typedef std::pair <tree, usage_info *> var_info_pair;\n+\n+  /* The function we're optimizing.  */\n+  function *m_fn;\n+\n+  /* Pool for allocating usage_info structures.  */\n+  object_allocator <usage_info> m_info_pool;\n+\n+  /* Maps an SSA name to a description of all uses of that SSA name.\n+     All the usage_infos satisfy is_useful.\n+\n+     We use a hash_map because the map is expected to be sparse\n+     (i.e. most SSA names won't have useful information attached to them).\n+     We could move to a directly-indexed array if that situation changes.  */\n+  info_map_type m_info_map;\n+\n+  /* Post-ordered list of all potentially-interesting SSA names,\n+     along with information that describes all uses.  */\n+  auto_vec <var_info_pair, 128> m_vars;\n+\n+  /* A bitmap of blocks that we have finished processing in the initial\n+     post-order walk.  */\n+  sbitmap m_visited_blocks;\n+\n+  /* A worklist of SSA names whose definitions need to be reconsidered.  */\n+  auto_vec <tree, 64> m_worklist;\n+\n+  /* The SSA names in M_WORKLIST, identified by their SSA_NAME_VERSION.\n+     We use a bitmap rather than an sbitmap because most SSA names are\n+     never added to the worklist.  */\n+  bitmap m_worklist_names;\n+};\n+\n+backprop::backprop (function *fn)\n+  : m_fn (fn),\n+    m_info_pool (\"usage_info\"),\n+    m_visited_blocks (sbitmap_alloc (last_basic_block_for_fn (m_fn))),\n+    m_worklist_names (BITMAP_ALLOC (NULL))\n+{\n+  bitmap_clear (m_visited_blocks);\n+}\n+\n+backprop::~backprop ()\n+{\n+  BITMAP_FREE (m_worklist_names);\n+  sbitmap_free (m_visited_blocks);\n+  m_info_pool.release ();\n+}\n+\n+/* Return usage information for general operand OP, or null if none.  */\n+\n+const usage_info *\n+backprop::lookup_operand (tree op)\n+{\n+  if (op && TREE_CODE (op) == SSA_NAME)\n+    {\n+      usage_info **slot = m_info_map.get (op);\n+      if (slot)\n+\treturn *slot;\n+    }\n+  return NULL;\n+}\n+\n+/* Add SSA name VAR to the worklist, if it isn't on the worklist already.  */\n+\n+void\n+backprop::push_to_worklist (tree var)\n+{\n+  if (!bitmap_set_bit (m_worklist_names, SSA_NAME_VERSION (var)))\n+    return;\n+  m_worklist.safe_push (var);\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"[WORKLIST] Pushing \");\n+      print_generic_expr (dump_file, var, 0);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+}\n+\n+/* Remove and return the next SSA name from the worklist.  The worklist\n+   is known to be nonempty.  */\n+\n+tree\n+backprop::pop_from_worklist ()\n+{\n+  tree var = m_worklist.pop ();\n+  bitmap_clear_bit (m_worklist_names, SSA_NAME_VERSION (var));\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"[WORKLIST] Popping \");\n+      print_generic_expr (dump_file, var, 0);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+  return var;\n+}\n+\n+/* Make INFO describe all uses of RHS in CALL, which is a call to a\n+   built-in function.  */\n+\n+void\n+backprop::process_builtin_call_use (gcall *call, tree rhs, usage_info *info)\n+{\n+  enum built_in_function fn = DECL_FUNCTION_CODE (gimple_call_fndecl (call));\n+  tree lhs = gimple_call_lhs (call);\n+  switch (fn)\n+    {\n+    CASE_FLT_FN (BUILT_IN_COS):\n+    CASE_FLT_FN (BUILT_IN_COSH):\n+    CASE_FLT_FN (BUILT_IN_CCOS):\n+    CASE_FLT_FN (BUILT_IN_CCOSH):\n+    CASE_FLT_FN (BUILT_IN_HYPOT):\n+      /* The signs of all inputs are ignored.  */\n+      info->flags.ignore_sign = true;\n+      break;\n+\n+    CASE_FLT_FN (BUILT_IN_COPYSIGN):\n+      /* The sign of the first input is ignored.  */\n+      if (rhs != gimple_call_arg (call, 1))\n+\tinfo->flags.ignore_sign = true;\n+      break;\n+\n+    CASE_FLT_FN (BUILT_IN_POW):\n+      {\n+\t/* The sign of the first input is ignored as long as the second\n+\t   input is an even real.  */\n+\ttree power = gimple_call_arg (call, 1);\n+\tHOST_WIDE_INT n;\n+\tif (TREE_CODE (power) == REAL_CST\n+\t    && real_isinteger (&TREE_REAL_CST (power), &n)\n+\t    && (n & 1) == 0)\n+\t  info->flags.ignore_sign = true;\n+\tbreak;\n+      }\n+\n+    CASE_FLT_FN (BUILT_IN_FMA):\n+      /* In X * X + Y, where Y is distinct from X, the sign of X doesn't\n+\t matter.  */\n+      if (gimple_call_arg (call, 0) == rhs\n+\t  && gimple_call_arg (call, 1) == rhs\n+\t  && gimple_call_arg (call, 2) != rhs)\n+\tinfo->flags.ignore_sign = true;\n+      break;\n+\n+    default:\n+      if (negate_mathfn_p (fn))\n+\t{\n+\t  /* The sign of the (single) input doesn't matter provided\n+\t     that the sign of the output doesn't matter.  */\n+\t  const usage_info *lhs_info = lookup_operand (lhs);\n+\t  if (lhs_info)\n+\t    info->flags.ignore_sign = lhs_info->flags.ignore_sign;\n+\t}\n+      break;\n+    }\n+}\n+\n+/* Make INFO describe all uses of RHS in ASSIGN.  */\n+\n+void\n+backprop::process_assign_use (gassign *assign, tree rhs, usage_info *info)\n+{\n+  tree lhs = gimple_assign_lhs (assign);\n+  switch (gimple_assign_rhs_code (assign))\n+    {\n+    case ABS_EXPR:\n+      /* The sign of the input doesn't matter.  */\n+      info->flags.ignore_sign = true;\n+      break;\n+\n+    case COND_EXPR:\n+      /* For A = B ? C : D, propagate information about all uses of A\n+\t to C and D.  */\n+      if (rhs != gimple_assign_rhs1 (assign))\n+\t{\n+\t  const usage_info *lhs_info = lookup_operand (lhs);\n+\t  if (lhs_info)\n+\t    *info = *lhs_info;\n+\t}\n+      break;\n+\n+    case FMA_EXPR:\n+      /* In X * X + Y, where Y is distinct from X, the sign of X doesn't\n+\t matter.  */\n+      if (gimple_assign_rhs1 (assign) == rhs\n+\t  && gimple_assign_rhs2 (assign) == rhs\n+\t  && gimple_assign_rhs3 (assign) != rhs)\n+\tinfo->flags.ignore_sign = true;\n+      break;\n+\n+    case MULT_EXPR:\n+      /* In X * X, the sign of X doesn't matter.  */\n+      if (gimple_assign_rhs1 (assign) == rhs\n+\t  && gimple_assign_rhs2 (assign) == rhs)\n+\tinfo->flags.ignore_sign = true;\n+      /* Fall through.  */\n+\n+    case NEGATE_EXPR:\n+    case RDIV_EXPR:\n+      /* If the sign of the result doesn't matter, the sign of the inputs\n+\t doesn't matter either.  */\n+      if (FLOAT_TYPE_P (TREE_TYPE (rhs)))\n+\t{\n+\t  const usage_info *lhs_info = lookup_operand (lhs);\n+\t  if (lhs_info)\n+\t    info->flags.ignore_sign = lhs_info->flags.ignore_sign;\n+\t}\n+      break;\n+\n+    default:\n+      break;\n+    }\n+}\n+\n+/* Make INFO describe the uses of PHI's result.  */\n+\n+void\n+backprop::process_phi_use (gphi *phi, usage_info *info)\n+{\n+  tree result = gimple_phi_result (phi);\n+  if (const usage_info *result_info = lookup_operand (result))\n+    *info = *result_info;\n+}\n+\n+/* Make INFO describe all uses of RHS in STMT.  */\n+\n+void\n+backprop::process_use (gimple *stmt, tree rhs, usage_info *info)\n+{\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"[USE] \");\n+      print_generic_expr (dump_file, rhs, 0);\n+      fprintf (dump_file, \" in \");\n+      print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n+    }\n+\n+  if (gcall *call = dyn_cast <gcall *> (stmt))\n+    {\n+      if (gimple_call_builtin_p (call, BUILT_IN_NORMAL))\n+\tprocess_builtin_call_use (call, rhs, info);\n+    }\n+  else if (gassign *assign = dyn_cast <gassign *> (stmt))\n+    process_assign_use (assign, rhs, info);\n+  else if (gphi *phi = dyn_cast <gphi *> (stmt))\n+    process_phi_use (phi, info);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    dump_usage_info (dump_file, rhs, info);\n+}\n+\n+/* Make INFO describe all uses of VAR, returning true if the result\n+   is useful.  If the uses include phis that haven't been processed yet,\n+   make the most optimistic assumption possible, so that we aim for\n+   a maximum rather than a minimum fixed point.  */\n+\n+bool\n+backprop::intersect_uses (tree var, usage_info *info)\n+{\n+  imm_use_iterator iter;\n+  gimple *stmt;\n+  *info = usage_info::intersection_identity ();\n+  FOR_EACH_IMM_USE_STMT (stmt, iter, var)\n+    {\n+      if (is_gimple_debug (stmt))\n+\tcontinue;\n+      if (is_a <gphi *> (stmt)\n+\t  && !bitmap_bit_p (m_visited_blocks, gimple_bb (stmt)->index))\n+\t{\n+\t  /* Skip unprocessed phis.  */\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"[BACKEDGE] \");\n+\t      print_generic_expr (dump_file, var, 0);\n+\t      fprintf (dump_file, \" in \");\n+\t      print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  usage_info subinfo;\n+\t  process_use (stmt, var, &subinfo);\n+\t  *info &= subinfo;\n+\t  if (!info->is_useful ())\n+\t    {\n+\t      BREAK_FROM_IMM_USE_STMT (iter);\n+\t      return false;\n+\t    }\n+\t}\n+    }\n+  return true;\n+}\n+\n+/* Queue for reconsideration any input of STMT that has information\n+   associated with it.  This is used if that information might be\n+   too optimistic.  */\n+\n+void\n+backprop::reprocess_inputs (gimple *stmt)\n+{\n+  use_operand_p use_p;\n+  ssa_op_iter oi;\n+  FOR_EACH_PHI_OR_STMT_USE (use_p, stmt, oi, SSA_OP_USE)\n+    {\n+      tree var = get_use_from_ptr (use_p);\n+      if (lookup_operand (var))\n+\tpush_to_worklist (var);\n+    }\n+}\n+\n+/* Say that we're recording INFO for SSA name VAR, or that we're deleting\n+   existing information if INFO is null.  INTRO describes the change.  */\n+\n+static void\n+dump_var_info (tree var, usage_info *info, const char *intro)\n+{\n+  fprintf (dump_file, \"[DEF] %s for \", intro);\n+  print_gimple_stmt (dump_file, SSA_NAME_DEF_STMT (var), 0, TDF_SLIM);\n+  if (info)\n+    dump_usage_info (dump_file, var, info);\n+}\n+\n+/* Process all uses of VAR and record or update the result in\n+   M_INFO_MAP and M_VARS.  */\n+\n+void\n+backprop::process_var (tree var)\n+{\n+  if (has_zero_uses (var))\n+    return;\n+\n+  usage_info info;\n+  intersect_uses (var, &info);\n+\n+  gimple *stmt = SSA_NAME_DEF_STMT (var);\n+  if (info.is_useful ())\n+    {\n+      bool existed;\n+      usage_info *&map_info = m_info_map.get_or_insert (var, &existed);\n+      if (!existed)\n+\t{\n+\t  /* Recording information about VAR for the first time.  */\n+\t  map_info = m_info_pool.allocate ();\n+\t  *map_info = info;\n+\t  m_vars.safe_push (var_info_pair (var, map_info));\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    dump_var_info (var, map_info, \"Recording new information\");\n+\n+\t  /* If STMT is a phi, reprocess any backedge uses.  This is a\n+\t     no-op for other uses, which won't have any information\n+\t     associated with them.  */\n+\t  if (is_a <gphi *> (stmt))\n+\t    reprocess_inputs (stmt);\n+\t}\n+      else if (info != *map_info)\n+\t{\n+\t  /* Recording information that is less optimistic than before.  */\n+\t  gcc_checking_assert ((info & *map_info) == info);\n+\t  *map_info = info;\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    dump_var_info (var, map_info, \"Updating information\");\n+\t  reprocess_inputs (stmt);\n+\t}\n+    }\n+  else\n+    {\n+      if (usage_info **slot = m_info_map.get (var))\n+\t{\n+\t  /* Removing previously-recorded information.  */\n+\t  **slot = info;\n+\t  m_info_map.remove (var);\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    dump_var_info (var, NULL, \"Deleting information\");\n+\t  reprocess_inputs (stmt);\n+\t}\n+      else\n+\t{\n+\t  /* If STMT is a phi, remove any information recorded for\n+\t     its arguments.  */\n+\t  if (is_a <gphi *> (stmt))\n+\t    reprocess_inputs (stmt);\n+\t}\n+    }\n+}\n+\n+/* Process all statements and phis in BB, during the first post-order walk.  */\n+\n+void\n+backprop::process_block (basic_block bb)\n+{\n+  for (gimple_stmt_iterator gsi = gsi_last_bb (bb); !gsi_end_p (gsi);\n+       gsi_prev (&gsi))\n+    {\n+      tree lhs = gimple_get_lhs (gsi_stmt (gsi));\n+      if (lhs && TREE_CODE (lhs) == SSA_NAME)\n+\tprocess_var (lhs);\n+    }\n+  for (gphi_iterator gpi = gsi_start_phis (bb); !gsi_end_p (gpi);\n+       gsi_next (&gpi))\n+    process_var (gimple_phi_result (gpi.phi ()));\n+}\n+\n+/* Delete the definition of VAR, which has no uses.  */\n+\n+static void\n+remove_unused_var (tree var)\n+{\n+  gimple *stmt = SSA_NAME_DEF_STMT (var);\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Deleting \");\n+      print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n+    }\n+  gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n+  gsi_remove (&gsi, true);\n+  release_defs (stmt);\n+}\n+\n+/* Note that we're replacing OLD_RHS with NEW_RHS in STMT.  */\n+\n+static void\n+note_replacement (gimple *stmt, tree old_rhs, tree new_rhs)\n+{\n+  fprintf (dump_file, \"Replacing use of \");\n+  print_generic_expr (dump_file, old_rhs, 0);\n+  fprintf (dump_file, \" with \");\n+  print_generic_expr (dump_file, new_rhs, 0);\n+  fprintf (dump_file, \" in \");\n+  print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n+}\n+\n+/* If RHS is an SSA name whose definition just changes the sign of a value,\n+   return that other value, otherwise return null.  */\n+\n+static tree\n+strip_sign_op_1 (tree rhs)\n+{\n+  if (TREE_CODE (rhs) != SSA_NAME)\n+    return NULL_TREE;\n+\n+  gimple *def_stmt = SSA_NAME_DEF_STMT (rhs);\n+  if (gassign *assign = dyn_cast <gassign *> (def_stmt))\n+    switch (gimple_assign_rhs_code (assign))\n+      {\n+      case ABS_EXPR:\n+      case NEGATE_EXPR:\n+\treturn gimple_assign_rhs1 (assign);\n+\n+      default:\n+\tbreak;\n+      }\n+  else if (gcall *call = dyn_cast <gcall *> (def_stmt))\n+    {\n+      if (gimple_call_builtin_p (call, BUILT_IN_NORMAL))\n+\tswitch (DECL_FUNCTION_CODE (gimple_call_fndecl (call)))\n+\t  {\n+\t  CASE_FLT_FN (BUILT_IN_COPYSIGN):\n+\t    return gimple_call_arg (call, 0);\n+\n+\t  default:\n+\t    break;\n+\t  }\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* If RHS is an SSA name whose definition just changes the sign of a value,\n+   strip all such operations and return the ultimate input to them.\n+   Return null otherwise.\n+\n+   Although this could in principle lead to quadratic searching,\n+   in practice a long sequence of sign manipulations should already\n+   have been folded down.  E.g. --x -> x, abs(-x) -> abs(x).  We search\n+   for more than one operation in order to catch cases like -abs(x).  */\n+\n+static tree\n+strip_sign_op (tree rhs)\n+{\n+  tree new_rhs = strip_sign_op_1 (rhs);\n+  if (!new_rhs)\n+    return NULL_TREE;\n+  while (tree next = strip_sign_op_1 (new_rhs))\n+    new_rhs = next;\n+  return new_rhs;\n+}\n+\n+/* Start a change in the value of VAR that is suitable for all non-debug\n+   uses of VAR.  We need to make sure that debug statements continue to\n+   use the original definition of VAR where possible, or are nullified\n+   otherwise.  */\n+\n+void\n+backprop::prepare_change (tree var)\n+{\n+  if (MAY_HAVE_DEBUG_STMTS)\n+    insert_debug_temp_for_var_def (NULL, var);\n+}\n+\n+/* STMT has been changed.  Give the fold machinery a chance to simplify\n+   and canonicalize it (e.g. by ensuring that commutative operands have\n+   the right order), then record the updates.  */\n+\n+void\n+backprop::complete_change (gimple *stmt)\n+{\n+  gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n+  if (fold_stmt (&gsi))\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"  which folds to: \");\n+\t  print_gimple_stmt (dump_file, gsi_stmt (gsi), 0, TDF_SLIM);\n+\t}\n+    }\n+  update_stmt (gsi_stmt (gsi));\n+}\n+\n+/* Optimize CALL, a call to a built-in function with lhs LHS, on the\n+   basis that INFO describes all uses of LHS.  */\n+\n+void\n+backprop::optimize_builtin_call (gcall *call, tree lhs, const usage_info *info)\n+{\n+  tree fndecl = gimple_call_fndecl (call);\n+  enum built_in_function fn = DECL_FUNCTION_CODE (fndecl);\n+  /* If we have an f such that -f(x) = f(-x), and if the sign of the result\n+     doesn't matter, strip any sign operations from the input.  */\n+  if (info->flags.ignore_sign && negate_mathfn_p (fn))\n+    {\n+      tree new_arg = strip_sign_op (gimple_call_arg (call, 0));\n+      if (new_arg)\n+\t{\n+\t  prepare_change (lhs);\n+\t  gimple_call_set_arg (call, 0, new_arg);\n+\t  complete_change (call);\n+\t}\n+    }\n+}\n+\n+/* Optimize ASSIGN, an assignment to LHS, by replacing rhs operand N\n+   with RHS<N>, if RHS<N> is nonnull.  This may change the value of LHS.  */\n+\n+void\n+backprop::replace_assign_rhs (gassign *assign, tree lhs, tree rhs1,\n+\t\t\t      tree rhs2, tree rhs3)\n+{\n+  if (!rhs1 && !rhs2 && !rhs3)\n+    return;\n+\n+  prepare_change (lhs);\n+  if (rhs1)\n+    gimple_assign_set_rhs1 (assign, rhs1);\n+  if (rhs2)\n+    gimple_assign_set_rhs2 (assign, rhs2);\n+  if (rhs3)\n+    gimple_assign_set_rhs3 (assign, rhs3);\n+  complete_change (assign);\n+}\n+\n+/* Optimize ASSIGN, an assignment to LHS, on the basis that INFO\n+   describes all uses of LHS.  */\n+\n+void\n+backprop::optimize_assign (gassign *assign, tree lhs, const usage_info *info)\n+{\n+  switch (gimple_assign_rhs_code (assign))\n+    {\n+    case MULT_EXPR:\n+    case RDIV_EXPR:\n+      /* If the sign of the result doesn't matter, strip sign operations\n+\t from both inputs.  */\n+      if (info->flags.ignore_sign)\n+\treplace_assign_rhs (assign, lhs,\n+\t\t\t    strip_sign_op (gimple_assign_rhs1 (assign)),\n+\t\t\t    strip_sign_op (gimple_assign_rhs2 (assign)),\n+\t\t\t    NULL_TREE);\n+      break;\n+\n+    case COND_EXPR:\n+      /* If the sign of A ? B : C doesn't matter, strip sign operations\n+\t from both B and C.  */\n+      if (info->flags.ignore_sign)\n+\treplace_assign_rhs (assign, lhs,\n+\t\t\t    NULL_TREE,\n+\t\t\t    strip_sign_op (gimple_assign_rhs2 (assign)),\n+\t\t\t    strip_sign_op (gimple_assign_rhs3 (assign)));\n+      break;\n+\n+    default:\n+      break;\n+    }\n+}\n+\n+/* Optimize PHI, which defines VAR, on the basis that INFO describes all\n+   uses of the result.  */\n+\n+void\n+backprop::optimize_phi (gphi *phi, tree var, const usage_info *info)\n+{\n+  /* If the sign of the result doesn't matter, strip sign operations\n+     from all arguments.  */\n+  if (info->flags.ignore_sign)\n+    {\n+      use_operand_p use;\n+      ssa_op_iter oi;\n+      bool replaced = false;\n+      FOR_EACH_PHI_ARG (use, phi, oi, SSA_OP_USE)\n+\t{\n+\t  tree new_arg = strip_sign_op (USE_FROM_PTR (use));\n+\t  if (new_arg)\n+\t    {\n+\t      if (!replaced)\n+\t\tprepare_change (var);\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tnote_replacement (phi, USE_FROM_PTR (use), new_arg);\n+\t      replace_exp (use, new_arg);\n+\t      replaced = true;\n+\t    }\n+\t}\n+    }\n+}\n+\n+void\n+backprop::execute ()\n+{\n+  /* Phase 1: Traverse the function, making optimistic assumptions\n+     about any phi whose definition we haven't seen.  */\n+  int *postorder = XNEWVEC (int, n_basic_blocks_for_fn (m_fn));\n+  unsigned int postorder_num = post_order_compute (postorder, false, false);\n+  for (unsigned int i = 0; i < postorder_num; ++i)\n+    {\n+      process_block (BASIC_BLOCK_FOR_FN (m_fn, postorder[i]));\n+      bitmap_set_bit (m_visited_blocks, postorder[i]);\n+    }\n+  XDELETEVEC (postorder);\n+\n+  /* Phase 2: Use the initial (perhaps overly optimistic) information\n+     to create a maximal fixed point solution.  */\n+  while (!m_worklist.is_empty ())\n+    process_var (pop_from_worklist ());\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"\\n\");\n+\n+  /* Phase 3: Do a reverse post-order walk, using information about\n+     the uses of SSA names to optimize their definitions.  */\n+  for (unsigned int i = m_vars.length (); i-- > 0;)\n+    {\n+      usage_info *info = m_vars[i].second;\n+      if (info->is_useful ())\n+\t{\n+\t  tree var = m_vars[i].first;\n+\t  gimple *stmt = SSA_NAME_DEF_STMT (var);\n+\t  if (gcall *call = dyn_cast <gcall *> (stmt))\n+\t    {\n+\t      if (gimple_call_builtin_p (call, BUILT_IN_NORMAL))\n+\t\toptimize_builtin_call (call, var, info);\n+\t    }\n+\t  else if (gassign *assign = dyn_cast <gassign *> (stmt))\n+\t    optimize_assign (assign, var, info);\n+\t  else if (gphi *phi = dyn_cast <gphi *> (stmt))\n+\t    optimize_phi (phi, var, info);\n+\t}\n+    }\n+\n+  /* Phase 4: Do a post-order walk, deleting statements that are no\n+     longer needed.  */\n+  for (unsigned int i = 0; i < m_vars.length (); ++i)\n+    {\n+      tree var = m_vars[i].first;\n+      if (has_zero_uses (var))\n+\tremove_unused_var (var);\n+    }\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"\\n\");\n+}\n+\n+const pass_data pass_data_backprop =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"backprop\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  TV_TREE_BACKPROP, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_backprop : public gimple_opt_pass\n+{\n+public:\n+  pass_backprop (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_backprop, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_backprop (m_ctxt); }\n+  virtual bool gate (function *) { return flag_ssa_backprop; }\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_backprop\n+\n+unsigned int\n+pass_backprop::execute (function *fn)\n+{\n+  backprop (fn).execute ();\n+  return 0;\n+}\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_backprop (gcc::context *ctxt)\n+{\n+  return new pass_backprop (ctxt);\n+}"}, {"sha": "36d2b3bb47100590709c6b7e88e319beace1b628", "filename": "gcc/passes.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a75d560c855081ddb8147bf6cec378cda55901b/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a75d560c855081ddb8147bf6cec378cda55901b/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=6a75d560c855081ddb8147bf6cec378cda55901b", "patch": "@@ -159,6 +159,7 @@ along with GCC; see the file COPYING3.  If not see\n       /* After CCP we rewrite no longer addressed locals into SSA\n \t form if possible.  */\n       NEXT_PASS (pass_complete_unrolli);\n+      NEXT_PASS (pass_backprop);\n       NEXT_PASS (pass_phiprop);\n       NEXT_PASS (pass_forwprop);\n       NEXT_PASS (pass_object_sizes);"}, {"sha": "b852d3b798489ff3e53fd4a8529452743edb2cf1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a75d560c855081ddb8147bf6cec378cda55901b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a75d560c855081ddb8147bf6cec378cda55901b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6a75d560c855081ddb8147bf6cec378cda55901b", "patch": "@@ -1,3 +1,9 @@\n+2015-10-21  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* gcc.dg/tree-ssa/backprop-1.c, gcc.dg/tree-ssa/backprop-2.c,\n+\tgcc.dg/tree-ssa/backprop-3.c, gcc.dg/tree-ssa/backprop-4.c,\n+\tgcc.dg/tree-ssa/backprop-5.c, gcc.dg/tree-ssa/backprop-6.c: New tests.\n+\n 2015-10-21  Alan Lawrence  <alan.lawrence@arm.com>\n \n \t* gcc.dg/tree-ssa/sra-12.c: Enable test on all targets; add --param"}, {"sha": "302fdb570b6383633e50893b947442a51fa2f87e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/backprop-1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a75d560c855081ddb8147bf6cec378cda55901b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbackprop-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a75d560c855081ddb8147bf6cec378cda55901b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbackprop-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbackprop-1.c?ref=6a75d560c855081ddb8147bf6cec378cda55901b", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -g -fdump-tree-backprop-details\" }  */\n+\n+/* Test a simple case of non-looping code in which both uses ignore\n+   the sign and both definitions are sign ops.  */\n+#define TEST_FUNCTION(TYPE, SUFFIX)\t\t\t\t\\\n+  TYPE\t\t\t\t\t\t\t\t\\\n+  test##SUFFIX (TYPE x, int sel1, int sel2)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    TYPE input = sel1 ? -x : __builtin_fabs##SUFFIX (x);\t\\\n+    if (sel2)\t\t\t\t\t\t\t\\\n+      return __builtin_cos##SUFFIX (input);\t\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      return __builtin_cosh##SUFFIX (input);\t\t\t\\\n+  }\n+\n+TEST_FUNCTION (float, f)\n+TEST_FUNCTION (double, )\n+TEST_FUNCTION (long double, l)\n+\n+/* { dg-final { scan-tree-dump-times {Deleting[^\\n]* = -x} 3 \"backprop\" } } */\n+/* { dg-final { scan-tree-dump-times {Deleting[^\\n]* = ABS_EXPR <x} 3 \"backprop\" } } */"}, {"sha": "d54fd36e2fb3c8836adaaa7fe5ddd4cc4d8cdb00", "filename": "gcc/testsuite/gcc.dg/tree-ssa/backprop-2.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a75d560c855081ddb8147bf6cec378cda55901b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbackprop-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a75d560c855081ddb8147bf6cec378cda55901b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbackprop-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbackprop-2.c?ref=6a75d560c855081ddb8147bf6cec378cda55901b", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -g -fdump-tree-backprop-details\" }  */\n+\n+/* Test a simple case of non-looping code in which both uses ignore\n+   the sign but only one definition is a sign op.  */\n+#define TEST_FUNCTION(TYPE, SUFFIX)\t\t\t\t\\\n+  TYPE\t\t\t\t\t\t\t\t\\\n+  test##SUFFIX (TYPE x, int sel1, int sel2)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    TYPE input = sel1 ? -x : x + 1;\t\t\t\t\\\n+    if (sel2)\t\t\t\t\t\t\t\\\n+      return __builtin_cos##SUFFIX (input);\t\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      return __builtin_cosh##SUFFIX (input);\t\t\t\\\n+  }\n+\n+TEST_FUNCTION (float, f)\n+TEST_FUNCTION (double, )\n+TEST_FUNCTION (long double, l)\n+\n+/* { dg-final { scan-tree-dump-times {Deleting[^\\n]* = -x} 3 \"backprop\" } } */"}, {"sha": "a244b4af2ac2f74c6db9c19cb4e3bd2372fea660", "filename": "gcc/testsuite/gcc.dg/tree-ssa/backprop-3.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a75d560c855081ddb8147bf6cec378cda55901b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbackprop-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a75d560c855081ddb8147bf6cec378cda55901b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbackprop-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbackprop-3.c?ref=6a75d560c855081ddb8147bf6cec378cda55901b", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -g -fdump-tree-backprop-details\" }  */\n+\n+/* Test a simple case of non-looping code in which one use ignores\n+   the sign but another doesn't.  */\n+#define TEST_FUNCTION(TYPE, SUFFIX)\t\t\t\t\\\n+  TYPE\t\t\t\t\t\t\t\t\\\n+  test##SUFFIX (TYPE x, int sel1, int sel2)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    TYPE input = sel1 ? -x : __builtin_fabs##SUFFIX (x);\t\\\n+    if (sel2)\t\t\t\t\t\t\t\\\n+      return __builtin_cos##SUFFIX (input);\t\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      return __builtin_sin##SUFFIX (input);\t\t\t\\\n+  }\n+\n+TEST_FUNCTION (float, f)\n+TEST_FUNCTION (double, )\n+TEST_FUNCTION (long double, l)\n+\n+/* { dg-final { scan-tree-dump-times {Deleting[^\\n]* = -x} 0 \"backprop\" } } */"}, {"sha": "54355009c744ec4f2e7463c7e37cc09c188e9239", "filename": "gcc/testsuite/gcc.dg/tree-ssa/backprop-4.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a75d560c855081ddb8147bf6cec378cda55901b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbackprop-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a75d560c855081ddb8147bf6cec378cda55901b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbackprop-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbackprop-4.c?ref=6a75d560c855081ddb8147bf6cec378cda55901b", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -g -fdump-tree-backprop-details\" }  */\n+\n+/* Test a simple reduction loop in which all inputs are sign ops and\n+   the consumer doesn't care about the sign.  */\n+#define TEST_FUNCTION(TYPE, SUFFIX)\t\t\t\\\n+  TYPE\t\t\t\t\t\t\t\\\n+  test##SUFFIX (TYPE x, TYPE y, TYPE *array, int n)\t\\\n+  {\t\t\t\t\t\t\t\\\n+    x = __builtin_copysign##SUFFIX (x, y);\t\t\\\n+    for (int i = 0; i < n; ++i)\t\t\t\t\\\n+      x *= -array[i];\t\t\t\t\t\\\n+    return __builtin_hypot##SUFFIX (x, y);\t\t\\\n+  }\n+\n+TEST_FUNCTION (float, f)\n+TEST_FUNCTION (double, )\n+TEST_FUNCTION (long double, l)\n+\n+/* { dg-final { scan-tree-dump-times {Deleting[^\\n]* = __builtin_copysign} 3 \"backprop\" } } */\n+/* { dg-final { scan-tree-dump-times {Deleting[^\\n]* = -} 3 \"backprop\" } } */"}, {"sha": "e4f0f856ff6b09208db5e9a26bfe8d3b6e42e569", "filename": "gcc/testsuite/gcc.dg/tree-ssa/backprop-5.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a75d560c855081ddb8147bf6cec378cda55901b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbackprop-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a75d560c855081ddb8147bf6cec378cda55901b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbackprop-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbackprop-5.c?ref=6a75d560c855081ddb8147bf6cec378cda55901b", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -g -fdump-tree-backprop-details\" }  */\n+\n+/* Test a loop that does both a multiplication and addition.  The addition\n+   should prevent any sign ops from being removed.  */\n+#define TEST_FUNCTION(TYPE, SUFFIX)\t\t\t\\\n+  TYPE\t\t\t\t\t\t\t\\\n+  test##SUFFIX (TYPE x, TYPE y, TYPE *array, int n)\t\\\n+  {\t\t\t\t\t\t\t\\\n+    x = __builtin_copysign##SUFFIX (x, y);\t\t\\\n+    for (int i = 0; i < n; ++i)\t\t\t\t\\\n+      x = (x + 1) * array[i];\t\t\t\t\\\n+    return __builtin_hypot##SUFFIX (x, y);\t\t\\\n+  }\n+\n+TEST_FUNCTION (float, f)\n+TEST_FUNCTION (double, )\n+TEST_FUNCTION (long double, l)\n+\n+/* { dg-final { scan-tree-dump-times {Deleting[^\\n]* = __builtin_copysign} 0 \"backprop\" } } */"}, {"sha": "31f05716f1498dc709cac95fa20fb5796642c77e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/backprop-6.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a75d560c855081ddb8147bf6cec378cda55901b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbackprop-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a75d560c855081ddb8147bf6cec378cda55901b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbackprop-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbackprop-6.c?ref=6a75d560c855081ddb8147bf6cec378cda55901b", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-backprop-details\" }  */\n+\n+void start (void *);\n+void end (void *);\n+\n+/* Test that we optimize the contents of infinite loops.  */\n+#define TEST_FUNCTION(TYPE, SUFFIX)\t\t\t\\\n+  void\t\t\t\t\t\t\t\\\n+  test##SUFFIX (TYPE *array, TYPE y, int n)\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    for (;;)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tstart (array);\t\t\t\t\t\\\n+\tTYPE x = -__builtin_fabs##SUFFIX (array[-1]);\t\\\n+\tfor (int i = 0; i < n; ++i)\t\t\t\\\n+\t  x = -x / array[i];\t\t\t\t\\\n+\tarray[-1] = x * x;\t\t\t\t\\\n+\tarray[-2] = __builtin_fma##SUFFIX (x, x, y);\t\\\n+\tarray[-3] = __builtin_pow##SUFFIX (x, 20);\t\\\n+\tend (array);\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+  }\n+\n+TEST_FUNCTION (float, f)\n+TEST_FUNCTION (double, )\n+TEST_FUNCTION (long double, l)\n+\n+/* { dg-final { scan-tree-dump-times {Deleting[^\\n]* = -} 6 \"backprop\" } } */\n+/* { dg-final { scan-tree-dump-times {Deleting[^\\n]* = ABS_EXPR <} 3 \"backprop\" } } */"}, {"sha": "b429faf6d5515c23f7864156152b4d2107723b72", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a75d560c855081ddb8147bf6cec378cda55901b/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a75d560c855081ddb8147bf6cec378cda55901b/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=6a75d560c855081ddb8147bf6cec378cda55901b", "patch": "@@ -164,6 +164,7 @@ DEFTIMEVAR (TV_TREE_PRE\t\t     , \"tree PRE\")\n DEFTIMEVAR (TV_TREE_FRE\t\t     , \"tree FRE\")\n DEFTIMEVAR (TV_TREE_SINK             , \"tree code sinking\")\n DEFTIMEVAR (TV_TREE_PHIOPT\t     , \"tree linearize phis\")\n+DEFTIMEVAR (TV_TREE_BACKPROP\t     , \"tree backward propagate\")\n DEFTIMEVAR (TV_TREE_FORWPROP\t     , \"tree forward propagate\")\n DEFTIMEVAR (TV_TREE_PHIPROP\t     , \"tree phiprop\")\n DEFTIMEVAR (TV_TREE_DCE\t\t     , \"tree conservative DCE\")"}, {"sha": "333b5a768bcfe18aa46ed19cc48c5ffcfe888112", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a75d560c855081ddb8147bf6cec378cda55901b/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a75d560c855081ddb8147bf6cec378cda55901b/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=6a75d560c855081ddb8147bf6cec378cda55901b", "patch": "@@ -497,6 +497,7 @@ extern gimple_opt_pass *make_pass_cleanup_cfg_post_optimizing (gcc::context\n \t\t\t\t\t\t\t       *ctxt);\n extern gimple_opt_pass *make_pass_init_datastructures (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_fixup_cfg (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_backprop (gcc::context *ctxt);\n \n extern rtl_opt_pass *make_pass_expand (gcc::context *ctxt);\n extern rtl_opt_pass *make_pass_instantiate_virtual_regs (gcc::context *ctxt);"}]}