{"sha": "93cb9a5aa147c94d18c708fa67e6fcb546dd7391", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTNjYjlhNWFhMTQ3Yzk0ZDE4YzcwOGZhNjdlNmZjYjU0NmRkNzM5MQ==", "commit": {"author": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2016-07-31T01:51:37Z"}, "committer": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2016-07-31T01:51:37Z"}, "message": "re PR fortran/41922 (Diagnostic: No location shown for overlappingly initialized EQUIVALENCEd character vars)\n\n2016-07-30  Steven G. Kargl <kargl@gcc.gnu.org>\n\n\tPR fortran/41922\n\t* target-memory.c (expr_to_char): Pass in locus and use it in error\n\tmessages.\n\t(gfc_merge_initializers): Ditto.\n\t* target-memory.h: Update prototype for gfc_merge_initializers ().\n\t* trans-common.c (get_init_field): Use the correct locus.\n\n2016-07-30  Steven G. Kargl <kargl@gcc.gnu.org>\n\n\tPR fortran/41922\n\t* gfortran.dg/equiv_constraint_5.f90: Adjust the error message.\n\t* gfortran.dg/equiv_constraint_7.f90: Ditto.\n\t* gfortran.dg/pr41922.f90: New test.\n\nFrom-SVN: r238915", "tree": {"sha": "1bd2d1bb99c6fd9044ff58b2c1250dde11ce8bcb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1bd2d1bb99c6fd9044ff58b2c1250dde11ce8bcb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93cb9a5aa147c94d18c708fa67e6fcb546dd7391", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93cb9a5aa147c94d18c708fa67e6fcb546dd7391", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93cb9a5aa147c94d18c708fa67e6fcb546dd7391", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93cb9a5aa147c94d18c708fa67e6fcb546dd7391/comments", "author": null, "committer": null, "parents": [{"sha": "01afb976deb6122c3c4832d4ad04276f8816c97f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01afb976deb6122c3c4832d4ad04276f8816c97f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01afb976deb6122c3c4832d4ad04276f8816c97f"}], "stats": {"total": 67, "additions": 52, "deletions": 15}, "files": [{"sha": "d39bd9a1cfc127340e267c09cd1d058e41474cd2", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93cb9a5aa147c94d18c708fa67e6fcb546dd7391/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93cb9a5aa147c94d18c708fa67e6fcb546dd7391/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=93cb9a5aa147c94d18c708fa67e6fcb546dd7391", "patch": "@@ -1,3 +1,12 @@\n+2016-07-30  Steven G. Kargl <kargl@gcc.gnu.org>\n+\n+\tPR fortran/41922\n+\t* target-memory.c (expr_to_char): Pass in locus and use it in error\n+\tmessages.\n+\t(gfc_merge_initializers): Ditto.\n+\t* target-memory.h: Update prototype for gfc_merge_initializers ().\n+\t* trans-common.c (get_init_field): Use the correct locus.\n+\n 2016-07-30  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/68566"}, {"sha": "ac9cce262e3acf65eae50095815efaa70a610f9f", "filename": "gcc/fortran/target-memory.c", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93cb9a5aa147c94d18c708fa67e6fcb546dd7391/gcc%2Ffortran%2Ftarget-memory.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93cb9a5aa147c94d18c708fa67e6fcb546dd7391/gcc%2Ffortran%2Ftarget-memory.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftarget-memory.c?ref=93cb9a5aa147c94d18c708fa67e6fcb546dd7391", "patch": "@@ -639,7 +639,8 @@ gfc_target_interpret_expr (unsigned char *buffer, size_t buffer_size,\n    error.  */\n \n static size_t\n-expr_to_char (gfc_expr *e, unsigned char *data, unsigned char *chk, size_t len)\n+expr_to_char (gfc_expr *e, locus *loc,\n+\t      unsigned char *data, unsigned char *chk, size_t len)\n {\n   int i;\n   int ptr;\n@@ -663,7 +664,7 @@ expr_to_char (gfc_expr *e, unsigned char *data, unsigned char *chk, size_t len)\n \t    continue;\n \t  ptr = TREE_INT_CST_LOW(DECL_FIELD_OFFSET(cmp->backend_decl))\n \t    + TREE_INT_CST_LOW(DECL_FIELD_BIT_OFFSET(cmp->backend_decl))/8;\n-\t  expr_to_char (c->expr, &data[ptr], &chk[ptr], len);\n+\t  expr_to_char (c->expr, loc, &data[ptr], &chk[ptr], len);\n \t}\n       return len;\n     }\n@@ -674,12 +675,16 @@ expr_to_char (gfc_expr *e, unsigned char *data, unsigned char *chk, size_t len)\n   buffer = (unsigned char*)alloca (len);\n   len = gfc_target_encode_expr (e, buffer, len);\n \n-    for (i = 0; i < (int)len; i++)\n+  for (i = 0; i < (int)len; i++)\n     {\n       if (chk[i] && (buffer[i] != data[i]))\n \t{\n-\t  gfc_error (\"Overlapping unequal initializers in EQUIVALENCE \"\n-\t\t     \"at %L\", &e->where);\n+\t  if (loc)\n+\t    gfc_error (\"Overlapping unequal initializers in EQUIVALENCE \"\n+\t\t\t\"at %L\", loc);\n+\t  else\n+\t    gfc_error (\"Overlapping unequal initializers in EQUIVALENCE \"\n+\t\t\t\"at %C\");\n \t  return 0;\n \t}\n       chk[i] = 0xFF;\n@@ -695,7 +700,8 @@ expr_to_char (gfc_expr *e, unsigned char *data, unsigned char *chk, size_t len)\n    the union declaration.  */\n \n size_t\n-gfc_merge_initializers (gfc_typespec ts, gfc_expr *e, unsigned char *data,\n+gfc_merge_initializers (gfc_typespec ts, gfc_expr *e, locus *loc,\n+\t\t\tunsigned char *data,\n \t\t\tunsigned char *chk, size_t length)\n {\n   size_t len = 0;\n@@ -705,8 +711,7 @@ gfc_merge_initializers (gfc_typespec ts, gfc_expr *e, unsigned char *data,\n     {\n     case EXPR_CONSTANT:\n     case EXPR_STRUCTURE:\n-      len = expr_to_char (e, &data[0], &chk[0], length);\n-\n+      len = expr_to_char (e, loc, &data[0], &chk[0], length);\n       break;\n \n     case EXPR_ARRAY:\n@@ -718,7 +723,7 @@ gfc_merge_initializers (gfc_typespec ts, gfc_expr *e, unsigned char *data,\n \t  if (mpz_cmp_si (c->offset, 0) != 0)\n \t    len = elt_size * (size_t)mpz_get_si (c->offset);\n \n-\t  len = len + gfc_merge_initializers (ts, c->expr, &data[len],\n+\t  len = len + gfc_merge_initializers (ts, c->expr, loc, &data[len],\n \t\t\t\t\t      &chk[len], length - len);\n \t}\n       break;"}, {"sha": "0d79c104b2f041fd5f899ab4d29556c6427fc45a", "filename": "gcc/fortran/target-memory.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93cb9a5aa147c94d18c708fa67e6fcb546dd7391/gcc%2Ffortran%2Ftarget-memory.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93cb9a5aa147c94d18c708fa67e6fcb546dd7391/gcc%2Ffortran%2Ftarget-memory.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftarget-memory.h?ref=93cb9a5aa147c94d18c708fa67e6fcb546dd7391", "patch": "@@ -44,7 +44,7 @@ int gfc_interpret_derived (unsigned char *, size_t, gfc_expr *);\n int gfc_target_interpret_expr (unsigned char *, size_t, gfc_expr *, bool);\n \n /* Merge overlapping equivalence initializers for trans-common.c. */\n-size_t gfc_merge_initializers (gfc_typespec, gfc_expr *,\n+size_t gfc_merge_initializers (gfc_typespec, gfc_expr *, locus *,\n \t\t\t       unsigned char *, unsigned char *,\n \t\t\t       size_t);\n "}, {"sha": "20ec69eb5701c327314446ec250e9ae740587f54", "filename": "gcc/fortran/trans-common.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93cb9a5aa147c94d18c708fa67e6fcb546dd7391/gcc%2Ffortran%2Ftrans-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93cb9a5aa147c94d18c708fa67e6fcb546dd7391/gcc%2Ffortran%2Ftrans-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-common.c?ref=93cb9a5aa147c94d18c708fa67e6fcb546dd7391", "patch": "@@ -532,10 +532,15 @@ get_init_field (segment_info *head, tree union_type, tree *field_init,\n   memset (chk, '\\0', (size_t)length);\n   for (s = head; s; s = s->next)\n     if (s->sym->value)\n-      gfc_merge_initializers (s->sym->ts, s->sym->value,\n+      {\n+\tlocus *loc = NULL;\n+\tif (s->sym->ns->equiv && s->sym->ns->equiv->eq)\n+\t  loc = &s->sym->ns->equiv->eq->expr->where;\n+\tgfc_merge_initializers (s->sym->ts, s->sym->value, loc,\n \t\t\t      &data[s->offset],\n \t\t\t      &chk[s->offset],\n \t\t\t     (size_t)s->length);\n+      }\n   \n   for (i = 0; i < length; i++)\n     CONSTRUCTOR_APPEND_ELT (v, NULL, build_int_cst (type, data[i]));"}, {"sha": "829d89750372a6b1ffe2de2c1c84a0a6e495c6f9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93cb9a5aa147c94d18c708fa67e6fcb546dd7391/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93cb9a5aa147c94d18c708fa67e6fcb546dd7391/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=93cb9a5aa147c94d18c708fa67e6fcb546dd7391", "patch": "@@ -1,3 +1,10 @@\n+2016-07-30  Steven G. Kargl <kargl@gcc.gnu.org>\n+\n+\tPR fortran/41922\n+\t* gfortran.dg/equiv_constraint_5.f90: Adjust the error message.\n+\t* gfortran.dg/equiv_constraint_7.f90: Ditto.\n+\t* gfortran.dg/pr41922.f90: New test.\n+\n 2016-07-30  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/68566"}, {"sha": "199b9548900a876acc5938f987c47256f215c58b", "filename": "gcc/testsuite/gfortran.dg/equiv_constraint_5.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93cb9a5aa147c94d18c708fa67e6fcb546dd7391/gcc%2Ftestsuite%2Fgfortran.dg%2Fequiv_constraint_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93cb9a5aa147c94d18c708fa67e6fcb546dd7391/gcc%2Ftestsuite%2Fgfortran.dg%2Fequiv_constraint_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fequiv_constraint_5.f90?ref=93cb9a5aa147c94d18c708fa67e6fcb546dd7391", "patch": "@@ -19,13 +19,13 @@\n   END TYPE T2\n   TYPE T3\n     sequence\n-    integer :: i=2 ! { dg-error \"Overlapping unequal initializers\" }\n+    integer :: i=2\n   END TYPE T3\n   TYPE(T1) :: a1\n   TYPE(T2) :: a2\n   TYPE(T3) :: a3\n   EQUIVALENCE (a1, a2)\n-  EQUIVALENCE (a1, a3)\n+  EQUIVALENCE (a1, a3) ! { dg-error \"Overlapping unequal initializers\" }\n   write(6, *) a1, a2, a3\n END\n "}, {"sha": "f999d00665bf56f0806bcb6d3e975e21a5dda746", "filename": "gcc/testsuite/gfortran.dg/equiv_constraint_7.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93cb9a5aa147c94d18c708fa67e6fcb546dd7391/gcc%2Ftestsuite%2Fgfortran.dg%2Fequiv_constraint_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93cb9a5aa147c94d18c708fa67e6fcb546dd7391/gcc%2Ftestsuite%2Fgfortran.dg%2Fequiv_constraint_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fequiv_constraint_7.f90?ref=93cb9a5aa147c94d18c708fa67e6fcb546dd7391", "patch": "@@ -5,7 +5,7 @@\n ! Started out being in BLOCK DATA; however, blockdata variables must be in\n ! COMMON and therefore cannot have F95 style initializers....\n  MODULE DATA\n-  INTEGER :: I=1,J=2  ! { dg-error \"Overlapping unequal initializers\" }\n-  EQUIVALENCE(I,J)\n+  INTEGER :: I=1,J=2\n+  EQUIVALENCE(I,J)  ! { dg-error \"Overlapping unequal initializers\" }\n  END MODULE DATA\n  END"}, {"sha": "cbbfa6f15f59576982cc9e8327492dba3e98749f", "filename": "gcc/testsuite/gfortran.dg/pr41922.f90", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93cb9a5aa147c94d18c708fa67e6fcb546dd7391/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr41922.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93cb9a5aa147c94d18c708fa67e6fcb546dd7391/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr41922.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr41922.f90?ref=93cb9a5aa147c94d18c708fa67e6fcb546dd7391", "patch": "@@ -0,0 +1,11 @@\n+! { dg-do compile}\n+! { dg-options -std=gnu }\n+      Subroutine RestoreR8Run()\n+      Implicit NONE\n+      Integer   ISTORE\n+      Real      XSTORE\n+      character   CSTORE(8)\n+      data cstore/8*' '/\n+      data istore/0/\n+      EQUIVALENCE (CSTORE(1),XSTORE,ISTORE) ! { dg-error \"Overlapping unequal\" }\n+      end"}]}