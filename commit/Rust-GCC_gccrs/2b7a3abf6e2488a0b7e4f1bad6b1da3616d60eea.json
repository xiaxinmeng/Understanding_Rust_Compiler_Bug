{"sha": "2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmI3YTNhYmY2ZTI0ODhhMGI3ZTRmMWJhZDZiMWRhMzYxNmQ2MGVlYQ==", "commit": {"author": {"name": "Dodji Seketeli", "email": "dseketel@redhat.com", "date": "2008-07-11T12:54:22Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2008-07-11T12:54:22Z"}, "message": "re PR c++/31754 (Improve column number accuracy in error messages)\n\n2008-07-11 Dodji Seketeli <dseketel@redhat.com>\n\n\tPR c++/31754\n\t* pt.c, semantic.c:\n\t* semantic.c (qualified_name_lookup_error, finish_id_expression):\n\tadd a location_t parameter so that\n\terror message can have a more accurate location.\n\t* cp-tree.h: updated prototype\n\t* pt.c (tsubst_qualified_id): use location in error messages.\n\t* parser.c (cp_parser_postfix_expression,\n\tcp_parser_objc_statement, cp_parser_trait_expr,\n\tcp_parser_token_is_class_key,\n\tcp_parser_uncommitted_to_tentative_parse_p,\n\tcp_parser_check_for_invalid_template_id, cp_parser_is_string_literal,\n\tcp_parser_error, cp_parser_name_lookup_error,\n\tcp_parser_simulate_error, cp_parser_check_decl_spec,\n\tcp_parser_check_decl_spec, cp_parser_non_integral_constant_expression,\n\tcp_parser_diagnose_invalid_type_name,\n\tcp_parser_parse_and_diagnose_invalid_type_name,\n\tcp_parser_require_pragma_eol, cp_parser_make_typename_type,\n\tcp_parser_string_literal, cp_parser_primary_expression,\n\tcp_parser_primary_expression, cp_parser_unqualified_id,\n\tcp_parser_nested_name_specifier_opt, cp_parser_postfix_expression,\n\tcp_parser_postfix_dot_deref_expression, cp_parser_new_expression,\n\tcp_parser_direct_new_declarator, cp_parser_builtin_offsetof,\n\tcp_parser_label_for_labeled_statement, cp_parser_statement_seq_opt,\n\tcp_parser_jump_statement, cp_parser_block_declaration,\n\tcp_parser_simple_declaration, cp_parser_decl_specifier_seq,\n\tcp_parser_function_specifier_opt, cp_parser_decltype,\n\tcp_parser_mem_initializer_list, cp_parser_mem_initializer,\n\tcp_parser_mem_initializer_id, cp_parser_template_parameter,\n\tcp_parser_type_parameter, cp_parser_template_id, cp_parser_template_name,\n\tcp_parser_template_argument): likewise.\n\nFrom-SVN: r137716", "tree": {"sha": "67a98c7d92d1fd0e083fc056e53338895ee34a08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67a98c7d92d1fd0e083fc056e53338895ee34a08"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/comments", "author": null, "committer": null, "parents": [{"sha": "941a9479d0a4d5fb26182ee6c485c4bf210a6499", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/941a9479d0a4d5fb26182ee6c485c4bf210a6499", "html_url": "https://github.com/Rust-GCC/gccrs/commit/941a9479d0a4d5fb26182ee6c485c4bf210a6499"}], "stats": {"total": 1045, "additions": 697, "deletions": 348}, "files": [{"sha": "0161f2e8c10855cb0f202925c01cb14d7c48f4dc", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea", "patch": "@@ -1,3 +1,37 @@\n+2008-07-11 Dodji Seketeli <dseketel@redhat.com>\n+\n+\tPR c++/31754\n+\t* pt.c, semantic.c:\n+\t* semantic.c (qualified_name_lookup_error, finish_id_expression):\n+\tadd a location_t parameter so that\n+\terror message can have a more accurate location.\n+\t* cp-tree.h: updated prototype\n+\t* pt.c (tsubst_qualified_id): use location in error messages.\n+\t* parser.c (cp_parser_postfix_expression,\n+\tcp_parser_objc_statement, cp_parser_trait_expr,\n+\tcp_parser_token_is_class_key,\n+\tcp_parser_uncommitted_to_tentative_parse_p,\n+\tcp_parser_check_for_invalid_template_id, cp_parser_is_string_literal,\n+\tcp_parser_error, cp_parser_name_lookup_error,\n+\tcp_parser_simulate_error, cp_parser_check_decl_spec,\n+\tcp_parser_check_decl_spec, cp_parser_non_integral_constant_expression,\n+\tcp_parser_diagnose_invalid_type_name,\n+\tcp_parser_parse_and_diagnose_invalid_type_name,\n+\tcp_parser_require_pragma_eol, cp_parser_make_typename_type,\n+\tcp_parser_string_literal, cp_parser_primary_expression,\n+\tcp_parser_primary_expression, cp_parser_unqualified_id,\n+\tcp_parser_nested_name_specifier_opt, cp_parser_postfix_expression,\n+\tcp_parser_postfix_dot_deref_expression, cp_parser_new_expression,\n+\tcp_parser_direct_new_declarator, cp_parser_builtin_offsetof,\n+\tcp_parser_label_for_labeled_statement, cp_parser_statement_seq_opt,\n+\tcp_parser_jump_statement, cp_parser_block_declaration,\n+\tcp_parser_simple_declaration, cp_parser_decl_specifier_seq,\n+\tcp_parser_function_specifier_opt, cp_parser_decltype,\n+\tcp_parser_mem_initializer_list, cp_parser_mem_initializer,\n+\tcp_parser_mem_initializer_id, cp_parser_template_parameter,\n+\tcp_parser_type_parameter, cp_parser_template_id, cp_parser_template_name,\n+\tcp_parser_template_argument): likewise.\n+\n 2008-07-09  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/36760"}, {"sha": "10eba33ea3eb9ab906819082f772b4dbe615d224", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea", "patch": "@@ -4653,13 +4653,15 @@ extern void finish_template_decl\t\t(tree);\n extern tree finish_template_type\t\t(tree, tree, int);\n extern tree finish_base_specifier\t\t(tree, tree, bool);\n extern void finish_member_declaration\t\t(tree);\n-extern void qualified_name_lookup_error\t\t(tree, tree, tree);\n+extern void qualified_name_lookup_error\t\t(tree, tree, tree,\n+\t\t\t\t\t\t location_t);\n extern void check_template_keyword\t\t(tree);\n extern tree finish_id_expression\t\t(tree, tree, tree,\n \t\t\t\t\t\t cp_id_kind *,\n \t\t\t\t\t\t bool, bool, bool *,\n \t\t\t\t\t\t bool, bool, bool, bool,\n-\t\t\t\t\t\t const char **);\n+\t\t\t\t\t\t const char **,\n+                                                 location_t);\n extern tree finish_typeof\t\t\t(tree);\n extern tree finish_offsetof\t\t\t(tree);\n extern void finish_decl_cleanup\t\t\t(tree, tree);"}, {"sha": "2429bfc20a8c1f3f60a8ab71b28846888a67de8c", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 444, "deletions": 242, "changes": 686, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea", "patch": "@@ -1593,7 +1593,7 @@ static tree cp_parser_postfix_expression\n static tree cp_parser_postfix_open_square_expression\n   (cp_parser *, tree, bool);\n static tree cp_parser_postfix_dot_deref_expression\n-  (cp_parser *, enum cpp_ttype, tree, bool, cp_id_kind *);\n+  (cp_parser *, enum cpp_ttype, tree, bool, cp_id_kind *, location_t);\n static tree cp_parser_parenthesized_expression_list\n   (cp_parser *, bool, bool, bool, bool *);\n static void cp_parser_pseudo_destructor_name\n@@ -1904,15 +1904,15 @@ static tree cp_parser_objc_statement\n /* Utility Routines */\n \n static tree cp_parser_lookup_name\n-  (cp_parser *, tree, enum tag_types, bool, bool, bool, tree *);\n+  (cp_parser *, tree, enum tag_types, bool, bool, bool, tree *, location_t);\n static tree cp_parser_lookup_name_simple\n-  (cp_parser *, tree);\n+  (cp_parser *, tree, location_t);\n static tree cp_parser_maybe_treat_template_as_class\n   (tree, bool);\n static bool cp_parser_check_declarator_template_parameters\n-  (cp_parser *, cp_declarator *);\n+  (cp_parser *, cp_declarator *, location_t);\n static bool cp_parser_check_template_parameters\n-  (cp_parser *, unsigned);\n+  (cp_parser *, unsigned, location_t);\n static tree cp_parser_simple_cast_expression\n   (cp_parser *);\n static tree cp_parser_global_scope_opt\n@@ -1948,7 +1948,7 @@ static tree cp_parser_trait_expr\n static bool cp_parser_declares_only_class_p\n   (cp_parser *);\n static void cp_parser_set_storage_class\n-  (cp_parser *, cp_decl_specifier_seq *, enum rid);\n+  (cp_parser *, cp_decl_specifier_seq *, enum rid, location_t);\n static void cp_parser_set_decl_spec_type\n   (cp_decl_specifier_seq *, tree, bool);\n static bool cp_parser_friend_p\n@@ -1970,7 +1970,7 @@ static enum tag_types cp_parser_token_is_class_key\n static void cp_parser_check_class_key\n   (enum tag_types, tree type);\n static void cp_parser_check_access_in_redeclaration\n-  (tree type);\n+  (tree type, location_t location);\n static bool cp_parser_optional_template_keyword\n   (cp_parser *);\n static void cp_parser_pre_parsed_nested_name_specifier\n@@ -1992,7 +1992,7 @@ static bool cp_parser_uncommitted_to_tentative_parse_p\n static void cp_parser_error\n   (cp_parser *, const char *);\n static void cp_parser_name_lookup_error\n-  (cp_parser *, tree, tree, const char *);\n+  (cp_parser *, tree, tree, const char *, location_t);\n static bool cp_parser_simulate_error\n   (cp_parser *);\n static bool cp_parser_check_type_definition\n@@ -2004,7 +2004,7 @@ static void cp_parser_check_for_invalid_template_id\n static bool cp_parser_non_integral_constant_expression\n   (cp_parser *, const char *);\n static void cp_parser_diagnose_invalid_type_name\n-  (cp_parser *, tree, tree);\n+  (cp_parser *, tree, tree, location_t);\n static bool cp_parser_parse_and_diagnose_invalid_type_name\n   (cp_parser *);\n static int cp_parser_skip_to_closing_parenthesis\n@@ -2030,7 +2030,7 @@ static bool cp_parser_is_string_literal\n static bool cp_parser_is_keyword\n   (cp_token *, enum rid);\n static tree cp_parser_make_typename_type\n-  (cp_parser *, tree, tree);\n+  (cp_parser *, tree, tree, location_t location);\n static cp_declarator * cp_parser_make_indirect_declarator\n   (enum tree_code, tree, cp_cv_quals, cp_declarator *);\n \n@@ -2079,7 +2079,7 @@ cp_parser_error (cp_parser* parser, const char* message)\n \n       if (token->type == CPP_PRAGMA)\n \t{\n-\t  error (\"%<#pragma%> is not allowed here\");\n+\t  error (\"%H%<#pragma%> is not allowed here\", &token->location);\n \t  cp_parser_skip_to_pragma_eol (parser, token);\n \t  return;\n \t}\n@@ -2102,33 +2102,34 @@ static void\n cp_parser_name_lookup_error (cp_parser* parser,\n \t\t\t     tree name,\n \t\t\t     tree decl,\n-\t\t\t     const char* desired)\n+\t\t\t     const char* desired,\n+\t\t\t     location_t location)\n {\n   /* If name lookup completely failed, tell the user that NAME was not\n      declared.  */\n   if (decl == error_mark_node)\n     {\n       if (parser->scope && parser->scope != global_namespace)\n-\terror (\"%<%E::%E%> has not been declared\",\n-\t       parser->scope, name);\n+\terror (\"%H%<%E::%E%> has not been declared\",\n+\t       &location, parser->scope, name);\n       else if (parser->scope == global_namespace)\n-\terror (\"%<::%E%> has not been declared\", name);\n+\terror (\"%H%<::%E%> has not been declared\", &location, name);\n       else if (parser->object_scope\n \t       && !CLASS_TYPE_P (parser->object_scope))\n-\terror (\"request for member %qE in non-class type %qT\",\n-\t       name, parser->object_scope);\n+\terror (\"%Hrequest for member %qE in non-class type %qT\",\n+\t       &location, name, parser->object_scope);\n       else if (parser->object_scope)\n-\terror (\"%<%T::%E%> has not been declared\",\n-\t       parser->object_scope, name);\n+\terror (\"%H%<%T::%E%> has not been declared\",\n+\t       &location, parser->object_scope, name);\n       else\n-\terror (\"%qE has not been declared\", name);\n+\terror (\"%H%qE has not been declared\", &location, name);\n     }\n   else if (parser->scope && parser->scope != global_namespace)\n-    error (\"%<%E::%E%> %s\", parser->scope, name, desired);\n+    error (\"%H%<%E::%E%> %s\", &location, parser->scope, name, desired);\n   else if (parser->scope == global_namespace)\n-    error (\"%<::%E%> %s\", name, desired);\n+    error (\"%H%<::%E%> %s\", &location, name, desired);\n   else\n-    error (\"%qE %s\", name, desired);\n+    error (\"%H%qE %s\", &location, name, desired);\n }\n \n /* If we are parsing tentatively, remember that an error has occurred\n@@ -2149,7 +2150,8 @@ cp_parser_simulate_error (cp_parser* parser)\n /* Check for repeated decl-specifiers.  */\n \n static void\n-cp_parser_check_decl_spec (cp_decl_specifier_seq *decl_specs)\n+cp_parser_check_decl_spec (cp_decl_specifier_seq *decl_specs,\n+\t\t\t   location_t location)\n {\n   cp_decl_spec ds;\n \n@@ -2162,10 +2164,11 @@ cp_parser_check_decl_spec (cp_decl_specifier_seq *decl_specs)\n       if (ds == ds_long)\n \t{\n \t  if (count > 2)\n-\t    error (\"%<long long long%> is too long for GCC\");\n+\t    error (\"%H%<long long long%> is too long for GCC\", &location);\n \t  else if (pedantic && !in_system_header && warn_long_long\n                    && cxx_dialect == cxx98)\n-\t    pedwarn (\"ISO C++ 1998 does not support %<long long%>\");\n+\t    pedwarn (\"%HISO C++ 1998 does not support %<long long%>\",\n+\t\t     &location);\n \t}\n       else if (count > 1)\n \t{\n@@ -2185,7 +2188,7 @@ cp_parser_check_decl_spec (cp_decl_specifier_seq *decl_specs)\n \t    \"__complex\",\n \t    \"__thread\"\n \t  };\n-\t  error (\"duplicate %qs\", decl_spec_names[(int)ds]);\n+\t  error (\"%Hduplicate %qs\", &location, decl_spec_names[(int)ds]);\n \t}\n     }\n }\n@@ -2301,13 +2304,15 @@ cp_parser_non_integral_constant_expression (cp_parser  *parser,\n    in duplicate error messages.)  */\n \n static void\n-cp_parser_diagnose_invalid_type_name (cp_parser *parser, tree scope, tree id)\n+cp_parser_diagnose_invalid_type_name (cp_parser *parser,\n+\t\t\t\t      tree scope, tree id,\n+\t\t\t\t      location_t id_location)\n {\n   tree decl, old_scope;\n   /* Try to lookup the identifier.  */\n   old_scope = parser->scope;\n   parser->scope = scope;\n-  decl = cp_parser_lookup_name_simple (parser, id);\n+  decl = cp_parser_lookup_name_simple (parser, id, id_location);\n   parser->scope = old_scope;\n   /* If the lookup found a template-name, it means that the user forgot\n   to specify an argument list. Emit a useful error message.  */\n@@ -2392,6 +2397,7 @@ static bool\n cp_parser_parse_and_diagnose_invalid_type_name (cp_parser *parser)\n {\n   tree id;\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n \n   cp_parser_parse_tentatively (parser);\n   id = cp_parser_id_expression (parser,\n@@ -2415,7 +2421,8 @@ cp_parser_parse_and_diagnose_invalid_type_name (cp_parser *parser)\n     return false;\n \n   /* Emit a diagnostic for the invalid type.  */\n-  cp_parser_diagnose_invalid_type_name (parser, parser->scope, id);\n+  cp_parser_diagnose_invalid_type_name (parser, parser->scope,\n+\t\t\t\t\tid, token->location);\n   /* Skip to the end of the declaration; there's no point in\n      trying to process it.  */\n   cp_parser_skip_to_end_of_block_or_statement (parser);\n@@ -2703,15 +2710,16 @@ cp_parser_require_pragma_eol (cp_parser *parser, cp_token *pragma_tok)\n    using cp_parser_diagnose_invalid_type_name.  */\n \n static tree\n-cp_parser_make_typename_type (cp_parser *parser, tree scope, tree id)\n+cp_parser_make_typename_type (cp_parser *parser, tree scope,\n+\t\t\t      tree id, location_t id_location)\n {\n   tree result;\n   if (TREE_CODE (id) == IDENTIFIER_NODE)\n     {\n       result = make_typename_type (scope, id, typename_type,\n \t\t\t\t   /*complain=*/tf_none);\n       if (result == error_mark_node)\n-\tcp_parser_diagnose_invalid_type_name (parser, scope, id);\n+\tcp_parser_diagnose_invalid_type_name (parser, scope, id, id_location);\n       return result;\n     }\n   return make_typename_type (scope, id, typename_type, tf_error);\n@@ -2929,7 +2937,8 @@ cp_parser_string_literal (cp_parser *parser, bool translate, bool wide_ok)\n \t      if (type == CPP_STRING)\n \t\ttype = tok->type;\n \t      else if (tok->type != CPP_STRING)\n-\t\terror (\"unsupported non-standard concatenation of string literals\");\n+\t\terror (\"%Hunsupported non-standard concatenation \"\n+                       \"of string literals\", &tok->location);\n \t    }\n \n \t  obstack_grow (&str_ob, &str, sizeof (cpp_string));\n@@ -3108,7 +3117,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \t\t\t      bool template_arg_p,\n \t\t\t      cp_id_kind *idk)\n {\n-  cp_token *token;\n+  cp_token *token = NULL;\n \n   /* Assume the primary expression is not an id-expression.  */\n   *idk = CP_ID_KIND_NONE;\n@@ -3206,7 +3215,8 @@ cp_parser_primary_expression (cp_parser *parser,\n \t  {\n \t    /* Statement-expressions are not allowed by the standard.  */\n \t    if (pedantic)\n-\t      pedwarn (\"ISO C++ forbids braced-groups within expressions\");\n+\t      pedwarn (\"%HISO C++ forbids braced-groups within expressions\",\n+\t\t       &token->location);\n \n \t    /* And they're not allowed outside of a function-body; you\n \t       cannot, for example, write:\n@@ -3217,8 +3227,9 @@ cp_parser_primary_expression (cp_parser *parser,\n \t    if (!parser->in_function_body\n \t\t|| parser->in_template_argument_list_p)\n \t      {\n-\t\terror (\"statement-expressions are not allowed outside \"\n-\t\t       \"functions nor in template-argument lists\");\n+\t\terror (\"%Hstatement-expressions are not allowed outside \"\n+\t\t       \"functions nor in template-argument lists\",\n+\t\t       &token->location);\n \t\tcp_parser_skip_to_end_of_block_or_statement (parser);\n \t\texpr = error_mark_node;\n \t      }\n@@ -3275,7 +3286,8 @@ cp_parser_primary_expression (cp_parser *parser,\n \t  cp_lexer_consume_token (parser->lexer);\n \t  if (parser->local_variables_forbidden_p)\n \t    {\n-\t      error (\"%<this%> may not be used in this context\");\n+\t      error (\"%H%<this%> may not be used in this context\",\n+                     &token->location);\n \t      return error_mark_node;\n \t    }\n \t  /* Pointers cannot appear in constant-expressions.  */\n@@ -3375,6 +3387,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \tconst char *error_msg;\n \tbool template_p;\n \tbool done;\n+\tcp_token *id_expr_token;\n \n       id_expression:\n \t/* Parse the id-expression.  */\n@@ -3387,6 +3400,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \t\t\t\t     /*optional_p=*/false);\n \tif (id_expression == error_mark_node)\n \t  return error_mark_node;\n+\tid_expr_token = token;\n \ttoken = cp_lexer_peek_token (parser->lexer);\n \tdone = (token->type != CPP_OPEN_SQUARE\n \t\t&& token->type != CPP_OPEN_PAREN\n@@ -3410,7 +3424,8 @@ cp_parser_primary_expression (cp_parser *parser,\n \t\t\t\t\t  template_p,\n \t\t\t\t\t  /*is_namespace=*/false,\n \t\t\t\t\t  /*check_dependency=*/true,\n-\t\t\t\t\t  &ambiguous_decls);\n+\t\t\t\t\t  &ambiguous_decls,\n+\t\t\t\t\t  id_expr_token->location);\n \t    /* If the lookup was ambiguous, an error will already have\n \t       been issued.  */\n \t    if (ambiguous_decls)\n@@ -3457,8 +3472,8 @@ cp_parser_primary_expression (cp_parser *parser,\n \t\tdecl = check_for_out_of_scope_variable (decl);\n \t\tif (local_variable_p (decl))\n \t\t  {\n-\t\t    error (\"local variable %qD may not appear in this context\",\n-\t\t\t   decl);\n+\t\t    error (\"%Hlocal variable %qD may not appear in this context\",\n+\t\t\t   &id_expr_token->location, decl);\n \t\t    return error_mark_node;\n \t\t  }\n \t      }\n@@ -3472,7 +3487,8 @@ cp_parser_primary_expression (cp_parser *parser,\n \t\t &parser->non_integral_constant_expression_p,\n \t\t template_p, done, address_p,\n \t\t template_arg_p,\n-\t\t &error_msg));\n+\t\t &error_msg,\n+                 id_expr_token->location));\n \tif (error_msg)\n \t  cp_parser_error (parser, error_msg);\n \treturn decl;\n@@ -3756,7 +3772,8 @@ cp_parser_unqualified_id (cp_parser* parser,\n \tif (scope && TREE_CODE (scope) == NAMESPACE_DECL)\n \t  {\n \t    if (!cp_parser_uncommitted_to_tentative_parse_p (parser))\n-\t      error (\"scope %qT before %<~%> is not a class-name\", scope);\n+\t      error (\"%Hscope %qT before %<~%> is not a class-name\",\n+\t\t     &token->location, scope);\n \t    cp_parser_simulate_error (parser);\n \t    if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n \t      cp_lexer_consume_token (parser->lexer);\n@@ -3857,8 +3874,8 @@ cp_parser_unqualified_id (cp_parser* parser,\n \tif (declarator_p && scope && !check_dtor_name (scope, type_decl))\n \t  {\n \t    if (!cp_parser_uncommitted_to_tentative_parse_p (parser))\n-\t      error (\"declaration of %<~%T%> as member of %qT\",\n-\t\t     type_decl, scope);\n+\t      error (\"%Hdeclaration of %<~%T%> as member of %qT\",\n+\t\t     &token->location, type_decl, scope);\n \t    cp_parser_simulate_error (parser);\n \t    return error_mark_node;\n \t  }\n@@ -3871,8 +3888,8 @@ cp_parser_unqualified_id (cp_parser* parser,\n \t    && !DECL_IMPLICIT_TYPEDEF_P (type_decl)\n \t    && !DECL_SELF_REFERENCE_P (type_decl)\n \t    && !cp_parser_uncommitted_to_tentative_parse_p (parser))\n-\t  error (\"typedef-name %qD used as destructor declarator\",\n-\t\t type_decl);\n+\t  error (\"%Htypedef-name %qD used as destructor declarator\",\n+\t\t &token->location, type_decl);\n \n \treturn build_nt (BIT_NOT_EXPR, TREE_TYPE (type_decl));\n       }\n@@ -4076,20 +4093,23 @@ cp_parser_nested_name_specifier_opt (cp_parser *parser,\n \t\t\t\t\t\t    /*is_template=*/false,\n \t\t\t\t\t\t    /*is_namespace=*/false,\n \t\t\t\t\t\t    /*check_dependency=*/true,\n-\t\t\t\t\t\t    &ambiguous_decls);\n+\t\t\t\t\t\t    &ambiguous_decls,\n+\t\t\t\t\t\t    token->location);\n \t\t      if (TREE_CODE (decl) == TEMPLATE_DECL)\n-\t\t\terror (\"%qD used without template parameters\", decl);\n+\t\t\terror (\"%H%qD used without template parameters\",\n+\t\t\t       &token->location, decl);\n \t\t      else if (ambiguous_decls)\n \t\t\t{\n-\t\t\t  error (\"reference to %qD is ambiguous\",\n-\t\t\t\t token->u.value);\n+\t\t\t  error (\"%Hreference to %qD is ambiguous\",\n+\t\t\t\t &token->location, token->u.value);\n \t\t\t  print_candidates (ambiguous_decls);\n \t\t\t  decl = error_mark_node;\n \t\t\t}\n \t\t      else\n \t\t\tcp_parser_name_lookup_error\n \t\t\t  (parser, token->u.value, decl,\n-\t\t\t   \"is not a class or namespace\");\n+\t\t\t   \"is not a class or namespace\",\n+\t\t\t   token->location);\n \t\t    }\n \t\t  parser->scope = error_mark_node;\n \t\t  error_p = true;\n@@ -4746,7 +4766,8 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t  postfix_expression\n \t    = cp_parser_postfix_dot_deref_expression (parser, token->type,\n \t\t\t\t\t\t      postfix_expression,\n-\t\t\t\t\t\t      false, &idk);\n+\t\t\t\t\t\t      false, &idk,\n+\t\t\t\t\t\t      token->location);\n \n           is_member_access = true;\n \t  break;\n@@ -4860,7 +4881,8 @@ static tree\n cp_parser_postfix_dot_deref_expression (cp_parser *parser,\n \t\t\t\t\tenum cpp_ttype token_type,\n \t\t\t\t\ttree postfix_expression,\n-\t\t\t\t\tbool for_offsetof, cp_id_kind *idk)\n+\t\t\t\t\tbool for_offsetof, cp_id_kind *idk,\n+\t\t\t\t\tlocation_t location)\n {\n   tree name;\n   bool dependent_p;\n@@ -4892,7 +4914,7 @@ cp_parser_postfix_dot_deref_expression (cp_parser *parser,\n       /* The type of the POSTFIX_EXPRESSION must be complete.  */\n       if (scope == unknown_type_node)\n \t{\n-\t  error (\"%qE does not have class type\", postfix_expression);\n+\t  error (\"%H%qE does not have class type\", &location, postfix_expression);\n \t  scope = NULL_TREE;\n \t}\n       else\n@@ -4948,6 +4970,7 @@ cp_parser_postfix_dot_deref_expression (cp_parser *parser,\n \t ordinary class member access expression, rather than a\n \t pseudo-destructor-name.  */\n       bool template_p;\n+      cp_token *token = cp_lexer_peek_token (parser->lexer);\n       /* Parse the id-expression.  */\n       name = (cp_parser_id_expression\n \t      (parser,\n@@ -4975,7 +4998,7 @@ cp_parser_postfix_dot_deref_expression (cp_parser *parser,\n \t TYPE_DECL here.  That is invalid code.  */\n       if (TREE_CODE (name) == TYPE_DECL)\n \t{\n-\t  error (\"invalid use of %qD\", name);\n+\t  error (\"%Hinvalid use of %qD\", &token->location, name);\n \t  postfix_expression = error_mark_node;\n \t}\n       else\n@@ -5538,18 +5561,21 @@ cp_parser_new_expression (cp_parser* parser)\n      type-id.  */\n   if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n     {\n+      cp_token *token;\n       /* Consume the `('.  */\n       cp_lexer_consume_token (parser->lexer);\n       /* Parse the type-id.  */\n       type = cp_parser_type_id (parser);\n       /* Look for the closing `)'.  */\n       cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n+      token = cp_lexer_peek_token (parser->lexer);\n       /* There should not be a direct-new-declarator in this production,\n \t but GCC used to allowed this, so we check and emit a sensible error\n \t message for this case.  */\n       if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_SQUARE))\n \t{\n-\t  error (\"array bound forbidden after parenthesized type-id\");\n+\t  error (\"%Harray bound forbidden after parenthesized type-id\",\n+\t\t &token->location);\n \t  inform (\"try removing the parentheses around the type-id\");\n \t  cp_parser_direct_new_declarator (parser);\n \t}\n@@ -5727,6 +5753,7 @@ cp_parser_direct_new_declarator (cp_parser* parser)\n       /* The first expression is not required to be constant.  */\n       if (!declarator)\n \t{\n+\t  cp_token *token = cp_lexer_peek_token (parser->lexer);\n \t  expression = cp_parser_expression (parser, /*cast_p=*/false);\n \t  /* The standard requires that the expression have integral\n \t     type.  DR 74 adds enumeration types.  We believe that the\n@@ -5742,8 +5769,8 @@ cp_parser_direct_new_declarator (cp_parser* parser)\n \t\t\t\t\t      /*complain=*/true);\n \t      if (!expression)\n \t\t{\n-\t\t  error (\"expression in new-declarator must have integral \"\n-\t\t\t \"or enumeration type\");\n+\t\t  error (\"%Hexpression in new-declarator must have integral \"\n+\t\t\t \"or enumeration type\", &token->location);\n \t\t  expression = error_mark_node;\n \t\t}\n \t    }\n@@ -6484,6 +6511,7 @@ cp_parser_builtin_offsetof (cp_parser *parser)\n   int save_ice_p, save_non_ice_p;\n   tree type, expr;\n   cp_id_kind dummy;\n+  cp_token *token;\n \n   /* We're about to accept non-integral-constant things, but will\n      definitely yield an integral constant expression.  Save and\n@@ -6499,17 +6527,18 @@ cp_parser_builtin_offsetof (cp_parser *parser)\n   type = cp_parser_type_id (parser);\n   /* Look for the `,'.  */\n   cp_parser_require (parser, CPP_COMMA, \"%<,%>\");\n+  token = cp_lexer_peek_token (parser->lexer);\n \n   /* Build the (type *)null that begins the traditional offsetof macro.  */\n   expr = build_static_cast (build_pointer_type (type), null_pointer_node,\n                             tf_warning_or_error);\n \n   /* Parse the offsetof-member-designator.  We begin as if we saw \"expr->\".  */\n   expr = cp_parser_postfix_dot_deref_expression (parser, CPP_DEREF, expr,\n-\t\t\t\t\t\t true, &dummy);\n+\t\t\t\t\t\t true, &dummy, token->location);\n   while (true)\n     {\n-      cp_token *token = cp_lexer_peek_token (parser->lexer);\n+      token = cp_lexer_peek_token (parser->lexer);\n       switch (token->type)\n \t{\n \tcase CPP_OPEN_SQUARE:\n@@ -6521,7 +6550,8 @@ cp_parser_builtin_offsetof (cp_parser *parser)\n \t  /* offsetof-member-designator \".\" identifier */\n \t  cp_lexer_consume_token (parser->lexer);\n \t  expr = cp_parser_postfix_dot_deref_expression (parser, CPP_DOT, expr,\n-\t\t\t\t\t\t\t true, &dummy);\n+\t\t\t\t\t\t\t true, &dummy,\n+\t\t\t\t\t\t\t token->location);\n \t  break;\n \n \tcase CPP_CLOSE_PAREN:\n@@ -6883,7 +6913,8 @@ cp_parser_label_for_labeled_statement (cp_parser* parser)\n \tif (parser->in_switch_statement_p)\n \t  finish_case_label (expr, expr_hi);\n \telse\n-\t  error (\"case label %qE not within a switch statement\", expr);\n+\t  error (\"%Hcase label %qE not within a switch statement\",\n+\t\t &token->location, expr);\n       }\n       break;\n \n@@ -6894,7 +6925,7 @@ cp_parser_label_for_labeled_statement (cp_parser* parser)\n       if (parser->in_switch_statement_p)\n \tfinish_case_label (NULL_TREE, NULL_TREE);\n       else\n-\terror (\"case label not within a switch statement\");\n+\terror (\"%Hcase label not within a switch statement\", &token->location);\n       break;\n \n     default:\n@@ -7012,7 +7043,7 @@ cp_parser_statement_seq_opt (cp_parser* parser, tree in_statement_expr)\n \t  else\n \t    {\n \t      token = cp_lexer_consume_token (parser->lexer);\n-\t      error (\"%<else%> without a previous %<if%>\");\n+\t      error (\"%H%<else%> without a previous %<if%>\", &token->location);\n \t    }\n \t}\n \n@@ -7514,18 +7545,18 @@ cp_parser_jump_statement (cp_parser* parser)\n       switch (in_statement)\n \t{\n \tcase 0:\n-\t  error (\"break statement not within loop or switch\");\n+\t  error (\"%Hbreak statement not within loop or switch\", &token->location);\n \t  break;\n \tdefault:\n \t  gcc_assert ((in_statement & IN_SWITCH_STMT)\n \t\t      || in_statement == IN_ITERATION_STMT);\n \t  statement = finish_break_stmt ();\n \t  break;\n \tcase IN_OMP_BLOCK:\n-\t  error (\"invalid exit from OpenMP structured block\");\n+\t  error (\"%Hinvalid exit from OpenMP structured block\", &token->location);\n \t  break;\n \tcase IN_OMP_FOR:\n-\t  error (\"break statement used with OpenMP for loop\");\n+\t  error (\"%Hbreak statement used with OpenMP for loop\", &token->location);\n \t  break;\n \t}\n       cp_parser_require (parser, CPP_SEMICOLON, \"%<;%>\");\n@@ -7535,14 +7566,14 @@ cp_parser_jump_statement (cp_parser* parser)\n       switch (parser->in_statement & ~(IN_SWITCH_STMT | IN_IF_STMT))\n \t{\n \tcase 0:\n-\t  error (\"continue statement not within a loop\");\n+\t  error (\"%Hcontinue statement not within a loop\", &token->location);\n \t  break;\n \tcase IN_ITERATION_STMT:\n \tcase IN_OMP_FOR:\n \t  statement = finish_continue_stmt ();\n \t  break;\n \tcase IN_OMP_BLOCK:\n-\t  error (\"invalid exit from OpenMP structured block\");\n+\t  error (\"%Hinvalid exit from OpenMP structured block\", &token->location);\n \t  break;\n \tdefault:\n \t  gcc_unreachable ();\n@@ -7579,7 +7610,7 @@ cp_parser_jump_statement (cp_parser* parser)\n \t{\n \t  /* Issue a warning about this use of a GNU extension.  */\n \t  if (pedantic)\n-\t    pedwarn (\"ISO C++ forbids computed gotos\");\n+\t    pedwarn (\"%HISO C++ forbids computed gotos\", &token->location);\n \t  /* Consume the '*' token.  */\n \t  cp_lexer_consume_token (parser->lexer);\n \t  /* Parse the dependent expression.  */\n@@ -7940,7 +7971,7 @@ cp_parser_block_declaration (cp_parser *parser,\n   else if (token1->keyword == RID_LABEL)\n     {\n       cp_lexer_consume_token (parser->lexer);\n-      error (\"%<__label__%> not at the beginning of a block\");\n+      error (\"%H%<__label__%> not at the beginning of a block\", &token1->location);\n       cp_parser_skip_to_end_of_statement (parser);\n       /* If the next token is now a `;', consume it.  */\n       if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON))\n@@ -8074,7 +8105,11 @@ cp_parser_simple_declaration (cp_parser* parser,\n \n \t     which is erroneous.  */\n \t  if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n-\t    error (\"mixing declarations and function-definitions is forbidden\");\n+\t    {\n+\t      cp_token *token = cp_lexer_peek_token (parser->lexer);\n+\t      error (\"%Hmixing declarations and function-definitions is forbidden\",\n+\t\t     &token->location);\n+\t    }\n \t  /* Otherwise, we're done with the list of declarators.  */\n \t  else\n \t    {\n@@ -8170,6 +8205,7 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n \t\t\t      int* declares_class_or_enum)\n {\n   bool constructor_possible_p = !parser->in_declarator_p;\n+  cp_token *start_token = NULL;\n \n   /* Clear DECL_SPECS.  */\n   clear_decl_specs (decl_specs);\n@@ -8186,6 +8222,11 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n \n       /* Peek at the next token.  */\n       token = cp_lexer_peek_token (parser->lexer);\n+\n+      /* Save the first token of the decl spec list for error\n+         reporting.  */\n+      if (!start_token)\n+\tstart_token = token;\n       /* Handle attributes.  */\n       if (token->keyword == RID_ATTRIBUTE)\n \t{\n@@ -8262,15 +8303,17 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n                  we're complaining about C++0x compatibility.  */\n               warning \n                 (OPT_Wc__0x_compat, \n-                 \"%<auto%> will change meaning in C++0x; please remove it\");\n+                 \"%H%<auto%> will change meaning in C++0x; please remove it\",\n+\t\t &token->location);\n \n               /* Set the storage class anyway.  */\n-              cp_parser_set_storage_class (parser, decl_specs, RID_AUTO);\n+              cp_parser_set_storage_class (parser, decl_specs, RID_AUTO,\n+\t\t\t\t\t   token->location);\n             }\n           else \n             /* We do not yet support the use of `auto' as a\n                type-specifier.  */\n-            error (\"C++0x %<auto%> specifier not supported\");\n+            error (\"%HC++0x %<auto%> specifier not supported\", &token->location);\n           break;\n \n \tcase RID_REGISTER:\n@@ -8279,7 +8322,8 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n \tcase RID_MUTABLE:\n \t  /* Consume the token.  */\n \t  cp_lexer_consume_token (parser->lexer);\n-          cp_parser_set_storage_class (parser, decl_specs, token->keyword);\n+          cp_parser_set_storage_class (parser, decl_specs, token->keyword,\n+\t\t\t\t       token->location);\n \t  break;\n \tcase RID_THREAD:\n \t  /* Consume the token.  */\n@@ -8315,7 +8359,6 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n \t\t\t\t\t/*is_declaration=*/true,\n \t\t\t\t\t&decl_spec_declares_class_or_enum,\n \t\t\t\t\t&is_cv_qualifier);\n-\n \t  *declares_class_or_enum |= decl_spec_declares_class_or_enum;\n \n \t  /* If this type-specifier referenced a user-defined type\n@@ -8375,12 +8418,13 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n       flags |= CP_PARSER_FLAGS_OPTIONAL;\n     }\n \n-  cp_parser_check_decl_spec (decl_specs);\n+  cp_parser_check_decl_spec (decl_specs, start_token->location);\n \n   /* Don't allow a friend specifier with a class definition.  */\n   if (decl_specs->specs[(int) ds_friend] != 0\n       && (*declares_class_or_enum & 2))\n-    error (\"class definition may not be declared a friend\");\n+    error (\"%Hclass definition may not be declared a friend\",\n+\t    &start_token->location);\n }\n \n /* Parse an (optional) storage-class-specifier.\n@@ -8436,7 +8480,8 @@ static tree\n cp_parser_function_specifier_opt (cp_parser* parser,\n \t\t\t\t  cp_decl_specifier_seq *decl_specs)\n {\n-  switch (cp_lexer_peek_token (parser->lexer)->keyword)\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+  switch (token->keyword)\n     {\n     case RID_INLINE:\n       if (decl_specs)\n@@ -8448,7 +8493,7 @@ cp_parser_function_specifier_opt (cp_parser* parser,\n \n \t A member function template shall not be virtual.  */\n       if (PROCESSING_REAL_TEMPLATE_DECL_P ())\n-\terror (\"templates may not be %<virtual%>\");\n+\terror (\"%Htemplates may not be %<virtual%>\", &token->location);\n       else if (decl_specs)\n \t++decl_specs->specs[(int) ds_virtual];\n       break;\n@@ -8602,6 +8647,7 @@ cp_parser_decltype (cp_parser *parser)\n   const char *saved_message;\n   bool saved_integral_constant_expression_p;\n   bool saved_non_integral_constant_expression_p;\n+  cp_token *id_expr_start_token;\n \n   /* Look for the `decltype' token.  */\n   if (!cp_parser_require_keyword (parser, RID_DECLTYPE, \"%<decltype%>\"))\n@@ -8631,6 +8677,7 @@ cp_parser_decltype (cp_parser *parser)\n     return error_mark_node;\n   \n   /* First, try parsing an id-expression.  */\n+  id_expr_start_token = cp_lexer_peek_token (parser->lexer);\n   cp_parser_parse_tentatively (parser);\n   expr = cp_parser_id_expression (parser,\n                                   /*template_keyword_p=*/false,\n@@ -8653,7 +8700,8 @@ cp_parser_decltype (cp_parser *parser)\n \t\t\t\t      /*is_template=*/false,\n \t\t\t\t      /*is_namespace=*/false,\n \t\t\t\t      /*check_dependency=*/true,\n-\t\t\t\t      /*ambiguous_decls=*/NULL);\n+\t\t\t\t      /*ambiguous_decls=*/NULL,\n+\t\t\t\t      id_expr_start_token->location);\n \n       if (expr\n           && expr != error_mark_node\n@@ -8673,7 +8721,8 @@ cp_parser_decltype (cp_parser *parser)\n                    /*done=*/true,\n                    /*address_p=*/false,\n                    /*template_arg_p=*/false,\n-                   &error_msg));\n+                   &error_msg,\n+\t\t   id_expr_start_token->location));\n \n           if (expr == error_mark_node)\n             /* We found an id-expression, but it was something that we\n@@ -8916,17 +8965,20 @@ static void\n cp_parser_mem_initializer_list (cp_parser* parser)\n {\n   tree mem_initializer_list = NULL_TREE;\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n \n   /* Let the semantic analysis code know that we are starting the\n      mem-initializer-list.  */\n   if (!DECL_CONSTRUCTOR_P (current_function_decl))\n-    error (\"only constructors take base initializers\");\n+    error (\"%Honly constructors take base initializers\",\n+\t   &token->location);\n \n   /* Loop through the list.  */\n   while (true)\n     {\n       tree mem_initializer;\n \n+      token = cp_lexer_peek_token (parser->lexer);\n       /* Parse the mem-initializer.  */\n       mem_initializer = cp_parser_mem_initializer (parser);\n       /* If the next token is a `...', we're expanding member initializers. */\n@@ -8940,8 +8992,8 @@ cp_parser_mem_initializer_list (cp_parser* parser)\n           if (mem_initializer != error_mark_node\n               && !TYPE_P (TREE_PURPOSE (mem_initializer)))\n             {\n-              error (\"cannot expand initializer for member %<%D%>\", \n-                     TREE_PURPOSE (mem_initializer));\n+              error (\"%Hcannot expand initializer for member %<%D%>\",\n+                     &token->location, TREE_PURPOSE (mem_initializer));\n               mem_initializer = error_mark_node;\n             }\n \n@@ -8989,11 +9041,13 @@ cp_parser_mem_initializer (cp_parser* parser)\n   tree mem_initializer_id;\n   tree expression_list;\n   tree member;\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n \n   /* Find out what is being initialized.  */\n   if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n     {\n-      permerror (\"anachronistic old-style base class initializer\");\n+      permerror (\"%Hanachronistic old-style base class initializer\",\n+                 &token->location);\n       mem_initializer_id = NULL_TREE;\n     }\n   else\n@@ -9044,11 +9098,14 @@ cp_parser_mem_initializer_id (cp_parser* parser)\n   bool template_p = false;\n   tree id;\n \n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+\n   /* `typename' is not allowed in this context ([temp.res]).  */\n   if (cp_lexer_next_token_is_keyword (parser->lexer, RID_TYPENAME))\n     {\n-      error (\"keyword %<typename%> not allowed in this context (a qualified \"\n-\t     \"member initializer is implicitly a type)\");\n+      error (\"%Hkeyword %<typename%> not allowed in this context (a qualified \"\n+\t     \"member initializer is implicitly a type)\",\n+\t     &token->location);\n       cp_lexer_consume_token (parser->lexer);\n     }\n   /* Look for the optional `::' operator.  */\n@@ -9565,6 +9622,7 @@ cp_parser_template_parameter (cp_parser* parser, bool *is_non_type,\n \t appropriate diagnostic here.  */\n \n       /* Consume the `='.  */\n+      cp_token *start_token = cp_lexer_peek_token (parser->lexer);\n       cp_lexer_consume_token (parser->lexer);\n       \n       /* Find the name of the parameter pack.  */     \n@@ -9573,10 +9631,11 @@ cp_parser_template_parameter (cp_parser* parser, bool *is_non_type,\n \tid_declarator = id_declarator->declarator;\n       \n       if (id_declarator && id_declarator->kind == cdk_id)\n-\terror (\"template parameter pack %qD cannot have a default argument\",\n-\t       id_declarator->u.id.unqualified_name);\n+\terror (\"%Htemplate parameter pack %qD cannot have a default argument\",\n+\t       &start_token->location, id_declarator->u.id.unqualified_name);\n       else\n-\terror (\"template parameter pack cannot have a default argument\");\n+\terror (\"%Htemplate parameter pack cannot have a default argument\",\n+\t       &start_token->location);\n       \n       /* Parse the default argument, but throw away the result.  */\n       cp_parser_default_argument (parser, /*template_parm_p=*/true);\n@@ -9670,10 +9729,11 @@ cp_parser_type_parameter (cp_parser* parser, bool *is_parameter_pack)\n             if (*is_parameter_pack)\n               {\n                 if (identifier)\n-                  error (\"template parameter pack %qD cannot have a default argument\", \n-                         identifier);\n+                  error (\"%Htemplate parameter pack %qD cannot have a \"\n+\t\t\t \"default argument\", &token->location, identifier);\n                 else\n-                  error (\"template parameter packs cannot have default arguments\");\n+                  error (\"%Htemplate parameter packs cannot have \"\n+\t\t\t \"default arguments\", &token->location);\n                 default_argument = NULL_TREE;\n               }\n \t    pop_deferring_access_checks ();\n@@ -9741,6 +9801,9 @@ cp_parser_type_parameter (cp_parser* parser, bool *is_parameter_pack)\n \t    cp_lexer_consume_token (parser->lexer);\n \t    /* Parse the id-expression.  */\n \t    push_deferring_access_checks (dk_no_deferred);\n+\t    /* save token before parsing the id-expression, for error\n+\t       reporting */\n+\t    token = cp_lexer_peek_token (parser->lexer);\n \t    default_argument\n \t      = cp_parser_id_expression (parser,\n \t\t\t\t\t /*template_keyword_p=*/false,\n@@ -9761,7 +9824,8 @@ cp_parser_type_parameter (cp_parser* parser, bool *is_parameter_pack)\n \t\t\t\t\t /*is_template=*/is_template,\n \t\t\t\t\t /*is_namespace=*/false,\n \t\t\t\t\t /*check_dependency=*/true,\n-\t\t\t\t\t /*ambiguous_decls=*/NULL);\n+\t\t\t\t\t /*ambiguous_decls=*/NULL,\n+\t\t\t\t\t token->location);\n \t    /* See if the default argument is valid.  */\n \t    default_argument\n \t      = check_template_template_default_arg (default_argument);\n@@ -9771,10 +9835,13 @@ cp_parser_type_parameter (cp_parser* parser, bool *is_parameter_pack)\n             if (*is_parameter_pack)\n               {\n                 if (identifier)\n-                  error (\"template parameter pack %qD cannot have a default argument\", \n-                         identifier);\n+                  error (\"%Htemplate parameter pack %qD cannot \"\n+\t\t\t \"have a default argument\",\n+\t\t\t &token->location, identifier);\n                 else\n-                  error (\"template parameter packs cannot have default arguments\");\n+                  error (\"%Htemplate parameter packs cannot \"\n+\t\t\t \"have default arguments\",\n+\t\t\t &token->location);\n                 default_argument = NULL_TREE;\n               }\n \t    pop_deferring_access_checks ();\n@@ -9823,7 +9890,7 @@ cp_parser_template_id (cp_parser *parser,\n   cp_token_position start_of_id = 0;\n   deferred_access_check *chk;\n   VEC (deferred_access_check,gc) *access_check;\n-  cp_token *next_token, *next_token_2;\n+  cp_token *next_token = NULL, *next_token_2 = NULL, *token = NULL;\n   bool is_identifier;\n \n   /* If the next token corresponds to a template-id, there is no need\n@@ -9871,6 +9938,7 @@ cp_parser_template_id (cp_parser *parser,\n \n   /* Parse the template-name.  */\n   is_identifier = false;\n+  token = cp_lexer_peek_token (parser->lexer);\n   template = cp_parser_template_name (parser, template_keyword_p,\n \t\t\t\t      check_dependency_p,\n \t\t\t\t      is_declaration,\n@@ -9897,6 +9965,7 @@ cp_parser_template_id (cp_parser *parser,\n       /* Consume the first token (CPP_OPEN_SQUARE - which we pretend it is\n \t CPP_LESS.  */\n       cp_lexer_consume_token (parser->lexer);\n+\n       /* Parse the arguments.  */\n       arguments = cp_parser_enclosed_template_argument_list (parser);\n       if (!cp_parser_parse_definitely (parser))\n@@ -9911,15 +9980,18 @@ cp_parser_template_id (cp_parser *parser,\n \t}\n       /* Otherwise, emit an error about the invalid digraph, but continue\n \t parsing because we got our argument list.  */\n-      permerror (\"%<<::%> cannot begin a template-argument list\");\n-      inform (\"%<<:%> is an alternate spelling for %<[%>. Insert whitespace \"\n-\t      \"between %<<%> and %<::%>\");\n+      permerror (\"%H%<<::%> cannot begin a template-argument list\",\n+\t\t &next_token->location);\n+      inform (\"%H%<<:%> is an alternate spelling for %<[%>. Insert whitespace \"\n+\t      \"between %<<%> and %<::%>\",\n+\t      &next_token->location);\n       if (!flag_permissive)\n \t{\n \t  static bool hint;\n \t  if (!hint)\n \t    {\n-\t      inform (\"(if you use %<-fpermissive%> G++ will accept your code)\");\n+\t      inform (\"%H(if you use %<-fpermissive%> G++ will accept your code)\",\n+                      &next_token->location);\n \t      hint = true;\n \t    }\n \t}\n@@ -9992,7 +10064,8 @@ cp_parser_template_id (cp_parser *parser,\n \t user, as opposed to simply marking the tentative parse as\n \t failed?  */\n       if (cp_parser_error_occurred (parser) && template_id != error_mark_node)\n-\terror (\"parse error in template argument list\");\n+\terror (\"%Hparse error in template argument list\",\n+\t       &token->location);\n     }\n \n   pop_deferring_access_checks ();\n@@ -10046,6 +10119,7 @@ cp_parser_template_name (cp_parser* parser,\n   tree identifier;\n   tree decl;\n   tree fns;\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n \n   /* If the next token is `operator', then we have either an\n      operator-function-id or a conversion-function-id.  */\n@@ -10105,7 +10179,8 @@ cp_parser_template_name (cp_parser* parser,\n \t  cp_token_position start = 0;\n \n \t  /* Explain what went wrong.  */\n-\t  error (\"non-template %qD used as template\", identifier);\n+\t  error (\"%Hnon-template %qD used as template\",\n+\t\t &token->location, identifier);\n \t  inform (\"use %<%T::template %D%> to indicate that it is a template\",\n \t\t  parser->scope, identifier);\n \t  /* If parsing tentatively, find the location of the \"<\" token.  */\n@@ -10149,7 +10224,8 @@ cp_parser_template_name (cp_parser* parser,\n \t\t\t\t/*is_template=*/false,\n \t\t\t\t/*is_namespace=*/false,\n \t\t\t\tcheck_dependency_p,\n-\t\t\t\t/*ambiguous_decls=*/NULL);\n+\t\t\t\t/*ambiguous_decls=*/NULL,\n+\t\t\t\ttoken->location);\n   decl = maybe_get_template_decl_from_type_decl (decl);\n \n   /* If DECL is a template, then the name was a template-name.  */\n@@ -10295,7 +10371,7 @@ cp_parser_template_argument (cp_parser* parser)\n   bool template_p;\n   bool address_p;\n   bool maybe_type_id = false;\n-  cp_token *token;\n+  cp_token *token = NULL, *argument_start_token = NULL;\n   cp_id_kind idk;\n \n   /* There's really no way to know what we're looking at, so we just\n@@ -10342,6 +10418,7 @@ cp_parser_template_argument (cp_parser* parser)\n   /* We're still not sure what the argument will be.  */\n   cp_parser_parse_tentatively (parser);\n   /* Try a template.  */\n+  argument_start_token = cp_lexer_peek_token (parser->lexer);\n   argument = cp_parser_id_expression (parser,\n \t\t\t\t      /*template_keyword_p=*/false,\n \t\t\t\t      /*check_dependency_p=*/true,\n@@ -10364,7 +10441,8 @@ cp_parser_template_argument (cp_parser* parser)\n \t\t\t\t\t  /*is_template=*/template_p,\n \t\t\t\t\t  /*is_namespace=*/false,\n \t\t\t\t\t  /*check_dependency=*/true,\n-\t\t\t\t\t  /*ambiguous_decls=*/NULL);\n+\t\t\t\t\t  /*ambiguous_decls=*/NULL,\n+\t\t\t\t\t  argument_start_token->location);\n       if (TREE_CODE (argument) != TEMPLATE_DECL\n \t  && TREE_CODE (argument) != UNBOUND_CLASS_TEMPLATE)\n \tcp_parser_error (parser, \"expected template-name\");\n@@ -10616,6 +10694,8 @@ static void\n cp_parser_explicit_specialization (cp_parser* parser)\n {\n   bool need_lang_pop;\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+\n   /* Look for the `template' keyword.  */\n   cp_parser_require_keyword (parser, RID_TEMPLATE, \"%<template%>\");\n   /* Look for the `<'.  */\n@@ -10630,7 +10710,7 @@ cp_parser_explicit_specialization (cp_parser* parser)\n      linkage.  */\n   if (current_lang_name == lang_name_c)\n     {\n-      error (\"template specialization with C linkage\");\n+      error (\"%Htemplate specialization with C linkage\", &token->location);\n       /* Give it C++ linkage to avoid confusing other parts of the\n \t front end.  */\n       push_lang_context (lang_name_cplusplus);\n@@ -10955,7 +11035,7 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n           cp_lexer_consume_token (parser->lexer);\n           /* We do not yet support the use of `auto' as a\n              type-specifier.  */\n-          error (\"C++0x %<auto%> specifier not supported\");\n+          error (\"%HC++0x %<auto%> specifier not supported\", &token->location);\n         }\n       break;\n \n@@ -11168,12 +11248,13 @@ cp_parser_nonclass_name (cp_parser* parser)\n   tree type_decl;\n   tree identifier;\n \n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n   identifier = cp_parser_identifier (parser);\n   if (identifier == error_mark_node)\n     return error_mark_node;\n \n   /* Look up the type-name.  */\n-  type_decl = cp_parser_lookup_name_simple (parser, identifier);\n+  type_decl = cp_parser_lookup_name_simple (parser, identifier, token->location);\n \n   if (TREE_CODE (type_decl) != TYPE_DECL\n       && (objc_is_id (identifier) || objc_is_class_name (identifier)))\n@@ -11190,7 +11271,7 @@ cp_parser_nonclass_name (cp_parser* parser)\n     {\n       if (!cp_parser_simulate_error (parser))\n \tcp_parser_name_lookup_error (parser, identifier, type_decl,\n-\t\t\t\t     \"is not a type\");\n+\t\t\t\t     \"is not a type\", token->location);\n       return error_mark_node;\n     }\n   /* Remember that the name was used in the definition of the\n@@ -11239,6 +11320,7 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n   tree identifier;\n   tree type = NULL_TREE;\n   tree attributes = NULL_TREE;\n+  cp_token *token = NULL;\n \n   /* See if we're looking at the `enum' keyword.  */\n   if (cp_lexer_next_token_is_keyword (parser->lexer, RID_ENUM))\n@@ -11308,6 +11390,7 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n       if (!template_p)\n \tcp_parser_parse_tentatively (parser);\n       /* Parse the template-id.  */\n+      token = cp_lexer_peek_token (parser->lexer);\n       decl = cp_parser_template_id (parser, template_p,\n \t\t\t\t    /*check_dependency_p=*/true,\n \t\t\t\t    is_declaration);\n@@ -11329,6 +11412,7 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n \n   if (!type)\n     {\n+      token = cp_lexer_peek_token (parser->lexer);\n       identifier = cp_parser_identifier (parser);\n \n       if (identifier == error_mark_node)\n@@ -11341,7 +11425,8 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n       if (tag_type == typename_type\n \t  && TREE_CODE (parser->scope) != NAMESPACE_DECL)\n \treturn cp_parser_make_typename_type (parser, parser->scope,\n-\t\t\t\t\t     identifier);\n+\t\t\t\t\t     identifier,\n+\t\t\t\t\t     token->location);\n       /* Look up a qualified name in the usual way.  */\n       if (parser->scope)\n \t{\n@@ -11353,7 +11438,8 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n \t\t\t\t\t/*is_template=*/false,\n \t\t\t\t\t/*is_namespace=*/false,\n \t\t\t\t\t/*check_dependency=*/true,\n-\t\t\t\t\t&ambiguous_decls);\n+\t\t\t\t\t&ambiguous_decls,\n+\t\t\t\t\ttoken->location);\n \n \t  /* If the lookup was ambiguous, an error will already have been\n \t     issued.  */\n@@ -11389,7 +11475,8 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n \t    {\n \t      cp_parser_diagnose_invalid_type_name (parser,\n \t\t\t\t\t\t    parser->scope,\n-\t\t\t\t\t\t    identifier);\n+\t\t\t\t\t\t    identifier,\n+\t\t\t\t\t\t    token->location);\n \t      return error_mark_node;\n \t    }\n \n@@ -11489,7 +11576,8 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n \t  /* An unqualified name was used to reference this type, so\n \t     there were no qualifying templates.  */\n \t  if (!cp_parser_check_template_parameters (parser,\n-\t\t\t\t\t\t    /*num_templates=*/0))\n+\t\t\t\t\t\t    /*num_templates=*/0,\n+\t\t\t\t\t\t    token->location))\n \t    return error_mark_node;\n \t  type = xref_tag (tag_type, identifier, ts, template_p);\n \t}\n@@ -11692,6 +11780,8 @@ cp_parser_namespace_name (cp_parser* parser)\n   tree identifier;\n   tree namespace_decl;\n \n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+\n   /* Get the name of the namespace.  */\n   identifier = cp_parser_identifier (parser);\n   if (identifier == error_mark_node)\n@@ -11720,13 +11810,14 @@ cp_parser_namespace_name (cp_parser* parser)\n \t\t\t\t\t  /*is_template=*/false,\n \t\t\t\t\t  /*is_namespace=*/true,\n \t\t\t\t\t  /*check_dependency=*/true,\n-\t\t\t\t\t  /*ambiguous_decls=*/NULL);\n+\t\t\t\t\t  /*ambiguous_decls=*/NULL,\n+\t\t\t\t\t  token->location);\n   /* If it's not a namespace, issue an error.  */\n   if (namespace_decl == error_mark_node\n       || TREE_CODE (namespace_decl) != NAMESPACE_DECL)\n     {\n       if (!cp_parser_uncommitted_to_tentative_parse_p (parser))\n-\terror (\"%qD is not a namespace-name\", identifier);\n+\terror (\"%H%qD is not a namespace-name\", &token->location, identifier);\n       cp_parser_error (parser, \"expected namespace-name\");\n       namespace_decl = error_mark_node;\n     }\n@@ -11841,6 +11932,8 @@ cp_parser_namespace_alias_definition (cp_parser* parser)\n   tree identifier;\n   tree namespace_specifier;\n \n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+\n   /* Look for the `namespace' keyword.  */\n   cp_parser_require_keyword (parser, RID_NAMESPACE, \"%<namespace%>\");\n   /* Look for the identifier.  */\n@@ -11851,7 +11944,7 @@ cp_parser_namespace_alias_definition (cp_parser* parser)\n   if (!cp_parser_uncommitted_to_tentative_parse_p (parser)\n       && cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE)) \n     {\n-      error (\"%<namespace%> definition is not allowed here\");\n+      error (\"%H%<namespace%> definition is not allowed here\", &token->location);\n       /* Skip the definition.  */\n       cp_lexer_consume_token (parser->lexer);\n       if (cp_parser_skip_to_closing_brace (parser))\n@@ -11966,6 +12059,7 @@ cp_parser_using_declaration (cp_parser* parser,\n        cp_parser_parse_definitely will be false, as required.  */\n     return cp_parser_parse_definitely (parser);\n \n+  token = cp_lexer_peek_token (parser->lexer);\n   /* Parse the unqualified-id.  */\n   identifier = cp_parser_unqualified_id (parser,\n \t\t\t\t\t /*template_keyword_p=*/false,\n@@ -11990,7 +12084,8 @@ cp_parser_using_declaration (cp_parser* parser,\n     /* [namespace.udecl]\n \n        A using declaration shall not name a template-id.  */\n-    error (\"a template-id may not appear in a using-declaration\");\n+    error (\"%Ha template-id may not appear in a using-declaration\",\n+            &token->location);\n   else\n     {\n       if (at_class_scope_p ())\n@@ -12006,9 +12101,13 @@ cp_parser_using_declaration (cp_parser* parser,\n \t}\n       else\n \t{\n-\t  decl = cp_parser_lookup_name_simple (parser, identifier);\n+\t  decl = cp_parser_lookup_name_simple (parser,\n+\t\t\t\t\t       identifier,\n+\t\t\t\t\t       token->location);\n \t  if (decl == error_mark_node)\n-\t    cp_parser_name_lookup_error (parser, identifier, decl, NULL);\n+\t    cp_parser_name_lookup_error (parser, identifier,\n+\t\t\t\t\t decl, NULL,\n+\t\t\t\t\t token->location);\n \t  else if (check_for_bare_parameter_packs (decl))\n \t    return false;\n \t  else if (!at_namespace_scope_p ())\n@@ -12258,7 +12357,8 @@ cp_parser_init_declarator (cp_parser* parser,\n \t\t\t   int declares_class_or_enum,\n \t\t\t   bool* function_definition_p)\n {\n-  cp_token *token;\n+  cp_token *token = NULL, *asm_spec_start_token = NULL,\n+           *attributes_start_token = NULL;\n   cp_declarator *declarator;\n   tree prefix_attributes;\n   tree attributes;\n@@ -12292,6 +12392,7 @@ cp_parser_init_declarator (cp_parser* parser,\n   resume_deferring_access_checks ();\n \n   /* Parse the declarator.  */\n+  token = cp_lexer_peek_token (parser->lexer);\n   declarator\n     = cp_parser_declarator (parser, CP_PARSER_DECLARATOR_NAMED,\n \t\t\t    &ctor_dtor_or_conv_p,\n@@ -12306,7 +12407,8 @@ cp_parser_init_declarator (cp_parser* parser,\n     return error_mark_node;\n \n   /* Check that the number of template-parameter-lists is OK.  */\n-  if (!cp_parser_check_declarator_template_parameters (parser, declarator))\n+  if (!cp_parser_check_declarator_template_parameters (parser, declarator,\n+\t\t\t\t\t\t       token->location))\n     return error_mark_node;\n \n   if (declares_class_or_enum & 2)\n@@ -12323,8 +12425,10 @@ cp_parser_init_declarator (cp_parser* parser,\n   if (cp_parser_allow_gnu_extensions_p (parser))\n     {\n       /* Look for an asm-specification.  */\n+      asm_spec_start_token = cp_lexer_peek_token (parser->lexer);\n       asm_specification = cp_parser_asm_specification_opt (parser);\n       /* And attributes.  */\n+      attributes_start_token = cp_lexer_peek_token (parser->lexer);\n       attributes = cp_parser_attributes_opt (parser);\n     }\n   else\n@@ -12353,9 +12457,12 @@ cp_parser_init_declarator (cp_parser* parser,\n \t  /* Neither attributes nor an asm-specification are allowed\n \t     on a function-definition.  */\n \t  if (asm_specification)\n-\t    error (\"an asm-specification is not allowed on a function-definition\");\n+\t    error (\"%Han asm-specification is not allowed \"\n+\t\t   \"on a function-definition\",\n+\t\t   &asm_spec_start_token->location);\n \t  if (attributes)\n-\t    error (\"attributes are not allowed on a function-definition\");\n+\t    error (\"%Hattributes are not allowed on a function-definition\",\n+\t\t   &attributes_start_token->location);\n \t  /* This is a function-definition.  */\n \t  *function_definition_p = true;\n \n@@ -12481,6 +12588,7 @@ cp_parser_init_declarator (cp_parser* parser,\n     {\n       if (function_declarator_p (declarator))\n \t{\n+\t  cp_token *initializer_start_token = cp_lexer_peek_token (parser->lexer);\n \t   if (initialization_kind == CPP_EQ)\n \t     initializer = cp_parser_pure_specifier (parser);\n \t   else\n@@ -12489,7 +12597,8 @@ cp_parser_init_declarator (cp_parser* parser,\n \t\t  know what the user intended, so just silently\n \t\t  consume the initializer.  */\n \t       if (decl != error_mark_node)\n-\t\t error (\"initializer provided for function\");\n+\t\t error (\"%Hinitializer provided for function\",\n+\t\t\t&initializer_start_token->location);\n \t       cp_parser_skip_to_closing_parenthesis (parser,\n \t\t\t\t\t\t      /*recovering=*/true,\n \t\t\t\t\t\t      /*or_comma=*/false,\n@@ -12891,7 +13000,8 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\t in function scopes.  */\n \t      else if (!parser->in_function_body)\n \t\t{\n-\t\t  error (\"array bound is not an integer constant\");\n+\t\t  error (\"%Harray bound is not an integer constant\",\n+\t\t\t &token->location);\n \t\t  bounds = error_mark_node;\n \t\t}\n \t    }\n@@ -12913,6 +13023,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t  special_function_kind sfk;\n \t  bool abstract_ok;\n           bool pack_expansion_p = false;\n+\t  cp_token *declarator_id_start_token;\n \n \t  /* Parse a declarator-id */\n \t  abstract_ok = (dcl_kind == CP_PARSER_DECLARATOR_EITHER);\n@@ -12931,6 +13042,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n                 }\n             }\n \n+\t  declarator_id_start_token = cp_lexer_peek_token (parser->lexer);\n \t  unqualified_name\n \t    = cp_parser_declarator_id (parser, /*optional_p=*/abstract_ok);\n \t  qualifying_scope = parser->scope;\n@@ -13000,7 +13112,8 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\t\t\t\t    /*only_current_p=*/false);\n \t      /* If that failed, the declarator is invalid.  */\n \t      if (TREE_CODE (type) == TYPENAME_TYPE)\n-\t\terror (\"%<%T::%E%> is not a type\",\n+\t\terror (\"%H%<%T::%E%> is not a type\",\n+\t\t       &declarator_id_start_token->location,\n \t\t       TYPE_CONTEXT (qualifying_scope),\n \t\t       TYPE_IDENTIFIER (qualifying_scope));\n \t      qualifying_scope = type;\n@@ -13026,7 +13139,8 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\t      if (qualifying_scope\n \t\t\t  && CLASSTYPE_USE_TEMPLATE (name_type))\n \t\t\t{\n-\t\t\t  error (\"invalid use of constructor as a template\");\n+\t\t\t  error (\"%Hinvalid use of constructor as a template\",\n+\t\t\t\t &declarator_id_start_token->location);\n \t\t\t  inform (\"use %<%T::%D%> instead of %<%T::%D%> to \"\n \t\t\t\t  \"name the constructor in a qualified name\",\n \t\t\t\t  class_type,\n@@ -13185,6 +13299,7 @@ cp_parser_ptr_operator (cp_parser* parser,\n       cp_parser_global_scope_opt (parser,\n \t\t\t\t  /*current_scope_valid_p=*/false);\n       /* Look for the nested-name specifier.  */\n+      token = cp_lexer_peek_token (parser->lexer);\n       cp_parser_nested_name_specifier (parser,\n \t\t\t\t       /*typename_keyword_p=*/false,\n \t\t\t\t       /*check_dependency_p=*/true,\n@@ -13199,7 +13314,7 @@ cp_parser_ptr_operator (cp_parser* parser,\n \t  code = INDIRECT_REF;\n \n \t  if (TREE_CODE (parser->scope) == NAMESPACE_DECL)\n-\t    error (\"%qD is a namespace\", parser->scope);\n+\t    error (\"%H%qD is a namespace\", &token->location, parser->scope);\n \t  else\n \t    {\n \t      /* The type of which the member is a member is given by the\n@@ -13274,7 +13389,7 @@ cp_parser_cv_qualifier_seq_opt (cp_parser* parser)\n \n       if (cv_quals & cv_qualifier)\n \t{\n-\t  error (\"duplicate cv-qualifier\");\n+\t  error (\"%Hduplicate cv-qualifier\", &token->location);\n \t  cp_lexer_purge_token (parser->lexer);\n \t}\n       else\n@@ -13384,6 +13499,7 @@ cp_parser_type_specifier_seq (cp_parser* parser,\n {\n   bool seen_type_specifier = false;\n   cp_parser_flags flags = CP_PARSER_FLAGS_OPTIONAL;\n+  cp_token *start_token = NULL;\n \n   /* Clear the TYPE_SPECIFIER_SEQ.  */\n   clear_decl_specs (type_specifier_seq);\n@@ -13403,6 +13519,11 @@ cp_parser_type_specifier_seq (cp_parser* parser,\n \t  continue;\n \t}\n \n+      /* record the token of the beginning of the type specifier seq,\n+         for error reporting purposes*/\n+     if (!start_token)\n+       start_token = cp_lexer_peek_token (parser->lexer);\n+\n       /* Look for the type-specifier.  */\n       type_specifier = cp_parser_type_specifier (parser,\n \t\t\t\t\t\t flags,\n@@ -13446,7 +13567,7 @@ cp_parser_type_specifier_seq (cp_parser* parser,\n \tflags |= CP_PARSER_FLAGS_NO_USER_DEFINED_TYPES;\n     }\n \n-  cp_parser_check_decl_spec (type_specifier_seq);\n+  cp_parser_check_decl_spec (type_specifier_seq, start_token->location);\n }\n \n /* Parse a parameter-declaration-clause.\n@@ -13673,7 +13794,7 @@ cp_parser_parameter_declaration (cp_parser *parser,\n   cp_decl_specifier_seq decl_specifiers;\n   cp_declarator *declarator;\n   tree default_argument;\n-  cp_token *token;\n+  cp_token *token = NULL, *declarator_token_start = NULL;\n   const char *saved_message;\n \n   /* In a template parameter, `>' is not an operator.\n@@ -13742,6 +13863,7 @@ cp_parser_parameter_declaration (cp_parser *parser,\n \t  && cp_lexer_next_token_is_not (parser->lexer, CPP_OPEN_PAREN))\n \tcp_parser_commit_to_tentative_parse (parser);\n       /* Parse the declarator.  */\n+      declarator_token_start = token;\n       declarator = cp_parser_declarator (parser,\n \t\t\t\t\t CP_PARSER_DECLARATOR_EITHER,\n \t\t\t\t\t /*ctor_dtor_or_conv_p=*/NULL,\n@@ -13900,7 +14022,7 @@ cp_parser_parameter_declaration (cp_parser *parser,\n \t\t  /* If we run out of tokens, issue an error message.  */\n \t\tcase CPP_EOF:\n \t\tcase CPP_PRAGMA_EOL:\n-\t\t  error (\"file ends in default argument\");\n+\t\t  error (\"%Hfile ends in default argument\", &token->location);\n \t\t  done = true;\n \t\t  break;\n \n@@ -13937,16 +14059,21 @@ cp_parser_parameter_declaration (cp_parser *parser,\n       /* Outside of a class definition, we can just parse the\n \t assignment-expression.  */\n       else\n-        default_argument \n-          = cp_parser_default_argument (parser, template_parm_p);\n+\t{\n+\t  token = cp_lexer_peek_token (parser->lexer);\n+\t  default_argument \n+\t    = cp_parser_default_argument (parser, template_parm_p);\n+\t}\n \n       if (!parser->default_arg_ok_p)\n \t{\n \t  if (flag_permissive)\n \t    warning (0, \"deprecated use of default argument for parameter of non-function\");\n \t  else\n \t    {\n-\t      error (\"default arguments are only permitted for function parameters\");\n+\t      error (\"%Hdefault arguments are only \"\n+\t\t     \"permitted for function parameters\",\n+\t\t     &token->location);\n \t      default_argument = NULL_TREE;\n \t    }\n \t}\n@@ -13962,11 +14089,12 @@ cp_parser_parameter_declaration (cp_parser *parser,\n \t    id_declarator = id_declarator->declarator;\n \t  \n \t  if (id_declarator && id_declarator->kind == cdk_id)\n-\t    error (\"%sparameter pack %qD cannot have a default argument\",\n+\t    error (\"%H%sparameter pack %qD cannot have a default argument\",\n+\t\t   &declarator_token_start->location,\n \t\t   kind, id_declarator->u.id.unqualified_name);\n \t  else\n-\t    error (\"%sparameter pack cannot have a default argument\",\n-\t\t   kind);\n+\t    error (\"%H%sparameter pack cannot have a default argument\",\n+\t\t   &declarator_token_start->location, kind);\n \t  \n \t  default_argument = NULL_TREE;\n \t}\n@@ -14377,10 +14505,12 @@ cp_parser_class_name (cp_parser *parser,\n \t\t\t\t\t/*is_template=*/false,\n \t\t\t\t\t/*is_namespace=*/false,\n \t\t\t\t\tcheck_dependency_p,\n-\t\t\t\t\t&ambiguous_decls);\n+\t\t\t\t\t&ambiguous_decls,\n+\t\t\t\t\tidentifier_token->location);\n \t  if (ambiguous_decls)\n \t    {\n-\t      error (\"reference to %qD is ambiguous\", identifier);\n+\t      error (\"%Hreference to %qD is ambiguous\",\n+\t\t     &identifier_token->location, identifier);\n \t      print_candidates (ambiguous_decls);\n \t      if (cp_parser_parsing_tentatively (parser))\n \t\t{\n@@ -14671,7 +14801,7 @@ cp_parser_class_head (cp_parser* parser,\n   bool invalid_explicit_specialization_p = false;\n   tree pushed_scope = NULL_TREE;\n   unsigned num_templates;\n-\n+  cp_token *type_start_token = NULL, *nested_name_specifier_token_start = NULL;\n   /* Assume no nested-name-specifier will be present.  */\n   *nested_name_specifier_p = false;\n   /* Assume no template parameter lists will be used in defining the\n@@ -14704,6 +14834,7 @@ cp_parser_class_head (cp_parser* parser,\n \n   /* Determine the name of the class.  Begin by looking for an\n      optional nested-name-specifier.  */\n+  nested_name_specifier_token_start = cp_lexer_peek_token (parser->lexer);\n   nested_name_specifier\n     = cp_parser_nested_name_specifier_opt (parser,\n \t\t\t\t\t   /*typename_keyword_p=*/false,\n@@ -14714,6 +14845,7 @@ cp_parser_class_head (cp_parser* parser,\n      identifier.  */\n   if (nested_name_specifier)\n     {\n+      type_start_token = cp_lexer_peek_token (parser->lexer);\n       /* Although the grammar says `identifier', it really means\n \t `class-name' or `template-name'.  You are only allowed to\n \t define a class that has already been declared with this\n@@ -14777,6 +14909,7 @@ cp_parser_class_head (cp_parser* parser,\n \t an identifier, or nothing at all.  */\n       cp_parser_parse_tentatively (parser);\n       /* Check for a template-id.  */\n+      type_start_token = cp_lexer_peek_token (parser->lexer);\n       id = cp_parser_template_id (parser,\n \t\t\t\t  /*template_keyword_p=*/false,\n \t\t\t\t  /*check_dependency_p=*/true,\n@@ -14828,7 +14961,8 @@ cp_parser_class_head (cp_parser* parser,\n       /* Reject typedef-names in class heads.  */\n       if (!DECL_IMPLICIT_TYPEDEF_P (type))\n \t{\n-\t  error (\"invalid class name in declaration of %qD\", type);\n+\t  error (\"%Hinvalid class name in declaration of %qD\",\n+\t\t &type_start_token->location, type);\n \t  type = NULL_TREE;\n \t  goto done;\n \t}\n@@ -14840,10 +14974,13 @@ cp_parser_class_head (cp_parser* parser,\n       if (scope && !is_ancestor (scope, nested_name_specifier))\n \t{\n \t  if (at_namespace_scope_p ())\n-\t    error (\"declaration of %qD in namespace %qD which does not \"\n-\t\t   \"enclose %qD\", type, scope, nested_name_specifier);\n+\t    error (\"%Hdeclaration of %qD in namespace %qD which does not \"\n+\t\t   \"enclose %qD\",\n+\t\t   &type_start_token->location,\n+\t\t   type, scope, nested_name_specifier);\n \t  else\n-\t    error (\"declaration of %qD in %qD which does not enclose %qD\",\n+\t    error (\"%Hdeclaration of %qD in %qD which does not enclose %qD\",\n+\t\t   &type_start_token->location,\n \t\t   type, scope, nested_name_specifier);\n \t  type = NULL_TREE;\n \t  goto done;\n@@ -14856,7 +14993,8 @@ cp_parser_class_head (cp_parser* parser,\n \t class member of a namespace outside of its namespace.  */\n       if (scope == nested_name_specifier)\n \t{\n-\t  permerror (\"extra qualification not allowed\");\n+\t  permerror (\"%Hextra qualification not allowed\",\n+\t\t     &nested_name_specifier_token_start->location);\n \t  nested_name_specifier = NULL_TREE;\n \t  num_templates = 0;\n \t}\n@@ -14867,7 +15005,8 @@ cp_parser_class_head (cp_parser* parser,\n       && parser->num_template_parameter_lists == 0\n       && template_id_p)\n     {\n-      error (\"an explicit specialization must be preceded by %<template <>%>\");\n+      error (\"%Han explicit specialization must be preceded by %<template <>%>\",\n+\t     &type_start_token->location);\n       invalid_explicit_specialization_p = true;\n       /* Take the same action that would have been taken by\n \t cp_parser_explicit_specialization.  */\n@@ -14879,7 +15018,8 @@ cp_parser_class_head (cp_parser* parser,\n      use \"goto done;\" to return.  */\n   /* Make sure that the right number of template parameters were\n      present.  */\n-  if (!cp_parser_check_template_parameters (parser, num_templates))\n+  if (!cp_parser_check_template_parameters (parser, num_templates,\n+\t\t\t\t\t    type_start_token->location))\n     {\n       /* If something went wrong, there is no point in even trying to\n \t process the class-definition.  */\n@@ -14894,7 +15034,8 @@ cp_parser_class_head (cp_parser* parser,\n \t  && (DECL_FUNCTION_TEMPLATE_P (TREE_OPERAND (id, 0))\n \t      || TREE_CODE (TREE_OPERAND (id, 0)) == OVERLOAD))\n \t{\n-\t  error (\"function template %qD redeclared as a class template\", id);\n+\t  error (\"%Hfunction template %qD redeclared as a class template\",\n+\t\t &type_start_token->location, id);\n \t  type = error_mark_node;\n \t}\n       else\n@@ -14975,8 +15116,10 @@ cp_parser_class_head (cp_parser* parser,\n      that's an error.  */\n   if (type != error_mark_node && COMPLETE_TYPE_P (type))\n     {\n-      error (\"redefinition of %q#T\", type);\n-      error (\"previous definition of %q+#T\", type);\n+      error (\"%Hredefinition of %q#T\",\n+\t     &type_start_token->location, type);\n+      error (\"%Hprevious definition of %q+#T\",\n+\t     &type_start_token->location, type);\n       type = NULL_TREE;\n       goto done;\n     }\n@@ -15131,7 +15274,9 @@ cp_parser_member_declaration (cp_parser* parser)\n   tree decl;\n   int declares_class_or_enum;\n   bool friend_p;\n-  cp_token *token;\n+  cp_token *token = NULL;\n+  cp_token *decl_spec_token_start = NULL;\n+  cp_token *initializer_token_start = NULL;\n   int saved_pedantic;\n \n   /* Check for the `__extension__' keyword.  */\n@@ -15195,6 +15340,7 @@ cp_parser_member_declaration (cp_parser* parser)\n     return;\n \n   /* Parse the decl-specifier-seq.  */\n+  decl_spec_token_start = cp_lexer_peek_token (parser->lexer);\n   cp_parser_decl_specifier_seq (parser,\n \t\t\t\tCP_PARSER_FLAGS_OPTIONAL,\n \t\t\t\t&decl_specifiers,\n@@ -15240,7 +15386,8 @@ cp_parser_member_declaration (cp_parser* parser)\n \t      /* If the `friend' keyword was present, the friend must\n \t\t be introduced with a class-key.  */\n \t       if (!declares_class_or_enum)\n-\t\t error (\"a class-key must be used when declaring a friend\");\n+\t\t error (\"%Ha class-key must be used when declaring a friend\",\n+                        &decl_spec_token_start->location);\n \t       /* In this case:\n \n \t\t    template <typename T> struct A {\n@@ -15254,8 +15401,8 @@ cp_parser_member_declaration (cp_parser* parser)\n \t\t   && TYPE_P (decl_specifiers.type))\n \t\t type = decl_specifiers.type;\n \t       if (!type || !TYPE_P (type))\n-\t\t error (\"friend declaration does not name a class or \"\n-\t\t\t\"function\");\n+\t\t error (\"%Hfriend declaration does not name a class or \"\n+\t\t\t\"function\", &decl_spec_token_start->location);\n \t       else\n \t\t make_friend_class (current_class_type, type,\n \t\t\t\t    /*complain=*/true);\n@@ -15278,7 +15425,9 @@ cp_parser_member_declaration (cp_parser* parser)\n \t      finish_member_declaration (decl);\n \t    }\n \t  else\n-\t    cp_parser_check_access_in_redeclaration (TYPE_NAME (type));\n+\t    cp_parser_check_access_in_redeclaration\n+\t\t\t\t\t      (TYPE_NAME (type),\n+\t\t\t\t\t       decl_spec_token_start->location);\n \t}\n     }\n   else\n@@ -15406,6 +15555,7 @@ cp_parser_member_declaration (cp_parser* parser)\n \t\t     for a pure-specifier; otherwise, we look for a\n \t\t     constant-initializer.  When we call `grokfield', it will\n \t\t     perform more stringent semantics checks.  */\n+\t\t  initializer_token_start = cp_lexer_peek_token (parser->lexer);\n \t\t  if (function_declarator_p (declarator))\n \t\t    initializer = cp_parser_pure_specifier (parser);\n \t\t  else\n@@ -15430,7 +15580,8 @@ cp_parser_member_declaration (cp_parser* parser)\n \t\t     standard, since a pure function may be defined\n \t\t     outside of the class-specifier.  */\n \t\t  if (initializer)\n-\t\t    error (\"pure-specifier on function-definition\");\n+\t\t    error (\"%Hpure-specifier on function-definition\",\n+\t\t\t   &initializer_token_start->location);\n \t\t  decl = cp_parser_save_member_function_body (parser,\n \t\t\t\t\t\t\t      &decl_specifiers,\n \t\t\t\t\t\t\t      declarator,\n@@ -15521,7 +15672,7 @@ cp_parser_pure_specifier (cp_parser* parser)\n     }\n   if (PROCESSING_REAL_TEMPLATE_DECL_P ())\n     {\n-      error (\"templates may not be %<virtual%>\");\n+      error (\"%Htemplates may not be %<virtual%>\", &token->location);\n       return error_mark_node;\n     }\n \n@@ -15723,11 +15874,14 @@ cp_parser_base_specifier (cp_parser* parser)\n      as base classes.  */\n   if (cp_lexer_next_token_is_keyword (parser->lexer, RID_TYPENAME))\n     {\n+      token = cp_lexer_peek_token (parser->lexer);\n       if (!processing_template_decl)\n-\terror (\"keyword %<typename%> not allowed outside of templates\");\n+\terror (\"%Hkeyword %<typename%> not allowed outside of templates\",\n+\t       &token->location);\n       else\n-\terror (\"keyword %<typename%> not allowed in this context \"\n-\t       \"(the base class is implicitly a type)\");\n+\terror (\"%Hkeyword %<typename%> not allowed in this context \"\n+\t       \"(the base class is implicitly a type)\",\n+\t       &token->location);\n       cp_lexer_consume_token (parser->lexer);\n     }\n \n@@ -16428,7 +16582,8 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n \t\t       bool is_template,\n \t\t       bool is_namespace,\n \t\t       bool check_dependency,\n-\t\t       tree *ambiguous_decls)\n+\t\t       tree *ambiguous_decls,\n+\t\t       location_t name_location)\n {\n   int flags = 0;\n   tree decl;\n@@ -16609,7 +16764,8 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n \t cp_parser_error, so we incorporate its actions directly.  */\n       if (!cp_parser_simulate_error (parser))\n \t{\n-\t  error (\"reference to %qD is ambiguous\", name);\n+\t  error (\"%Hreference to %qD is ambiguous\",\n+\t\t &name_location, name);\n \t  print_candidates (decl);\n \t}\n       return error_mark_node;\n@@ -16639,14 +16795,15 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n    IS_NAMESPACE is FALSE, and CHECK_DEPENDENCY is TRUE.  */\n \n static tree\n-cp_parser_lookup_name_simple (cp_parser* parser, tree name)\n+cp_parser_lookup_name_simple (cp_parser* parser, tree name, location_t location)\n {\n   return cp_parser_lookup_name (parser, name,\n \t\t\t\tnone_type,\n \t\t\t\t/*is_template=*/false,\n \t\t\t\t/*is_namespace=*/false,\n \t\t\t\t/*check_dependency=*/true,\n-\t\t\t\t/*ambiguous_decls=*/NULL);\n+\t\t\t\t/*ambiguous_decls=*/NULL,\n+\t\t\t\tlocation);\n }\n \n /* If DECL is a TEMPLATE_DECL that can be treated like a TYPE_DECL in\n@@ -16699,7 +16856,8 @@ cp_parser_maybe_treat_template_as_class (tree decl, bool tag_name_p)\n \n static bool\n cp_parser_check_declarator_template_parameters (cp_parser* parser,\n-\t\t\t\t\t\tcp_declarator *declarator)\n+\t\t\t\t\t\tcp_declarator *declarator,\n+\t\t\t\t\t\tlocation_t declarator_location)\n {\n   unsigned num_templates;\n \n@@ -16749,15 +16907,16 @@ cp_parser_check_declarator_template_parameters (cp_parser* parser,\n \t++num_templates;\n \n       return cp_parser_check_template_parameters (parser,\n-\t\t\t\t\t\t  num_templates);\n+\t\t\t\t\t\t  num_templates,\n+\t\t\t\t\t\t  declarator_location);\n \n     case cdk_function:\n     case cdk_array:\n     case cdk_pointer:\n     case cdk_reference:\n     case cdk_ptrmem:\n       return (cp_parser_check_declarator_template_parameters\n-\t      (parser, declarator->declarator));\n+\t      (parser, declarator->declarator, declarator_location));\n \n     case cdk_error:\n       return true;\n@@ -16774,15 +16933,16 @@ cp_parser_check_declarator_template_parameters (cp_parser* parser,\n \n static bool\n cp_parser_check_template_parameters (cp_parser* parser,\n-\t\t\t\t     unsigned num_templates)\n+\t\t\t\t     unsigned num_templates,\n+\t\t\t\t     location_t location)\n {\n   /* If there are more template classes than parameter lists, we have\n      something like:\n \n        template <class T> void S<T>::R<T>::f ();  */\n   if (parser->num_template_parameter_lists < num_templates)\n     {\n-      error (\"too few template-parameter-lists\");\n+      error (\"%Htoo few template-parameter-lists\", &location);\n       return false;\n     }\n   /* If there are the same number of template classes and parameter\n@@ -16797,7 +16957,7 @@ cp_parser_check_template_parameters (cp_parser* parser,\n      something like:\n \n      template <class T> template <class U> void S::f();  */\n-  error (\"too many template-parameter-lists\");\n+  error (\"%Htoo many template-parameter-lists\", &location);\n   return false;\n }\n \n@@ -17055,12 +17215,14 @@ cp_parser_function_definition_after_declarator (cp_parser* parser,\n   bool saved_in_unbraced_linkage_specification_p;\n   bool saved_in_function_body;\n   unsigned saved_num_template_parameter_lists;\n+  cp_token *token;\n \n   saved_in_function_body = parser->in_function_body;\n   parser->in_function_body = true;\n   /* If the next token is `return', then the code may be trying to\n      make use of the \"named return value\" extension that G++ used to\n      support.  */\n+  token = cp_lexer_peek_token (parser->lexer);\n   if (cp_lexer_next_token_is_keyword (parser->lexer, RID_RETURN))\n     {\n       /* Consume the `return' keyword.  */\n@@ -17069,7 +17231,8 @@ cp_parser_function_definition_after_declarator (cp_parser* parser,\n \t returned.  */\n       cp_parser_identifier (parser);\n       /* Issue an error message.  */\n-      error (\"named return values are no longer supported\");\n+      error (\"%Hnamed return values are no longer supported\",\n+\t     &token->location);\n       /* Skip tokens until we reach the start of the function body.  */\n       while (true)\n \t{\n@@ -17128,8 +17291,10 @@ cp_parser_template_declaration_after_export (cp_parser* parser, bool member_p)\n   tree parameter_list;\n   bool friend_p = false;\n   bool need_lang_pop;\n+  cp_token *token;\n \n   /* Look for the `template' keyword.  */\n+  token = cp_lexer_peek_token (parser->lexer);\n   if (!cp_parser_require_keyword (parser, RID_TEMPLATE, \"%<template%>\"))\n     return;\n \n@@ -17141,7 +17306,8 @@ cp_parser_template_declaration_after_export (cp_parser* parser, bool member_p)\n       /* 14.5.2.2 [temp.mem]\n \n          A local class shall not have member templates.  */\n-      error (\"invalid declaration of member template in local class\");\n+      error (\"%Hinvalid declaration of member template in local class\",\n+\t     &token->location);\n       cp_parser_skip_to_end_of_block_or_statement (parser);\n       return;\n     }\n@@ -17150,7 +17316,7 @@ cp_parser_template_declaration_after_export (cp_parser* parser, bool member_p)\n      A template ... shall not have C linkage.  */\n   if (current_lang_name == lang_name_c)\n     {\n-      error (\"template with C linkage\");\n+      error (\"%Htemplate with C linkage\", &token->location);\n       /* Give it C++ linkage to avoid confusing other parts of the\n \t front end.  */\n       push_lang_context (lang_name_cplusplus);\n@@ -17197,6 +17363,7 @@ cp_parser_template_declaration_after_export (cp_parser* parser, bool member_p)\n       /* There are no access checks when parsing a template, as we do not\n \t know if a specialization will be a friend.  */\n       push_deferring_access_checks (dk_no_check);\n+      token = cp_lexer_peek_token (parser->lexer);\n       decl = cp_parser_single_declaration (parser,\n \t\t\t\t\t   checks,\n \t\t\t\t\t   member_p,\n@@ -17209,7 +17376,7 @@ cp_parser_template_declaration_after_export (cp_parser* parser, bool member_p)\n       if (member_p && !friend_p && decl)\n \t{\n \t  if (TREE_CODE (decl) == TYPE_DECL)\n-\t    cp_parser_check_access_in_redeclaration (decl);\n+\t    cp_parser_check_access_in_redeclaration (decl, token->location);\n \n \t  decl = finish_member_template_decl (decl);\n \t}\n@@ -17273,6 +17440,7 @@ cp_parser_single_declaration (cp_parser* parser,\n   tree decl = NULL_TREE;\n   cp_decl_specifier_seq decl_specifiers;\n   bool function_definition_p = false;\n+  cp_token *decl_spec_token_start;\n \n   /* This function is only used when processing a template\n      declaration.  */\n@@ -17284,6 +17452,7 @@ cp_parser_single_declaration (cp_parser* parser,\n \n   /* Try the `decl-specifier-seq [opt] init-declarator [opt]'\n      alternative.  */\n+  decl_spec_token_start = cp_lexer_peek_token (parser->lexer);\n   cp_parser_decl_specifier_seq (parser,\n \t\t\t\tCP_PARSER_FLAGS_OPTIONAL,\n \t\t\t\t&decl_specifiers,\n@@ -17294,7 +17463,8 @@ cp_parser_single_declaration (cp_parser* parser,\n   /* There are no template typedefs.  */\n   if (decl_specifiers.specs[(int) ds_typedef])\n     {\n-      error (\"template declaration of %qs\", \"typedef\");\n+      error (\"%Htemplate declaration of %qs\",\n+\t     &decl_spec_token_start->location, \"typedef\");\n       decl = error_mark_node;\n     }\n \n@@ -17357,7 +17527,8 @@ cp_parser_single_declaration (cp_parser* parser,\n         && explicit_specialization_p\n         && decl_specifiers.storage_class != sc_none)\n       {\n-        error (\"explicit template specialization cannot have a storage class\");\n+        error (\"%Hexplicit template specialization cannot have a storage class\",\n+\t       &decl_spec_token_start->location);\n         decl = error_mark_node;\n       }\n     }\n@@ -17586,9 +17757,9 @@ cp_parser_enclosed_template_argument_list (cp_parser* parser)\n \t    is a typo for '>'. Emit an error message and continue.\n \t    Same deal about the token location, but here we can get it\n \t    right by consuming the '>>' before issuing the diagnostic.  */\n-\t  cp_lexer_consume_token (parser->lexer);\n-\t  error (\"spurious %<>>%>, use %<>%> to terminate \"\n-\t\t \"a template argument list\");\n+\t  cp_token *token = cp_lexer_consume_token (parser->lexer);\n+\t  error (\"%Hspurious %<>>%>, use %<>%> to terminate \"\n+\t\t \"a template argument list\", &token->location);\n \t}\n     }\n   else\n@@ -17909,14 +18080,15 @@ cp_parser_declares_only_class_p (cp_parser *parser)\n static void\n cp_parser_set_storage_class (cp_parser *parser,\n \t\t\t     cp_decl_specifier_seq *decl_specs,\n-\t\t\t     enum rid keyword)\n+\t\t\t     enum rid keyword,\n+\t\t\t     location_t location)\n {\n   cp_storage_class storage_class;\n \n   if (parser->in_unbraced_linkage_specification_p)\n     {\n-      error (\"invalid use of %qD in linkage specification\",\n-\t     ridpointers[keyword]);\n+      error (\"%Hinvalid use of %qD in linkage specification\",\n+\t     &location, ridpointers[keyword]);\n       return;\n     }\n   else if (decl_specs->storage_class != sc_none)\n@@ -17928,7 +18100,7 @@ cp_parser_set_storage_class (cp_parser *parser,\n   if ((keyword == RID_EXTERN || keyword == RID_STATIC)\n       && decl_specs->specs[(int) ds_thread])\n     {\n-      error (\"%<__thread%> before %qD\", ridpointers[keyword]);\n+      error (\"%H%<__thread%> before %qD\", &location, ridpointers[keyword]);\n       decl_specs->specs[(int) ds_thread] = 0;\n     }\n \n@@ -18258,7 +18430,7 @@ cp_parser_check_class_key (enum tag_types class_key, tree type)\n    [class.mem/1].  */\n \n static void\n-cp_parser_check_access_in_redeclaration (tree decl)\n+cp_parser_check_access_in_redeclaration (tree decl, location_t location)\n {\n   if (!decl || !CLASS_TYPE_P (TREE_TYPE (decl)))\n     return;\n@@ -18267,7 +18439,7 @@ cp_parser_check_access_in_redeclaration (tree decl)\n        != (current_access_specifier == access_private_node))\n       || (TREE_PROTECTED (decl)\n \t  != (current_access_specifier == access_protected_node)))\n-    error (\"%qD redeclared with different access\", decl);\n+    error (\"%H%qD redeclared with different access\", &location, decl);\n }\n \n /* Look for the `template' keyword, as a syntactic disambiguator.\n@@ -18284,8 +18456,9 @@ cp_parser_optional_template_keyword (cp_parser *parser)\n \t template and what is not.  */\n       if (!processing_template_decl)\n \t{\n-\t  error (\"%<template%> (as a disambiguator) is only allowed \"\n-\t\t \"within templates\");\n+\t  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+\t  error (\"%H%<template%> (as a disambiguator) is only allowed \"\n+\t\t \"within templates\", &token->location);\n \t  /* If this part of the token stream is rescanned, the same\n \t     error message would be generated.  So, we purge the token\n \t     from the stream.  */\n@@ -18550,7 +18723,8 @@ cp_parser_objc_expression (cp_parser* parser)\n \t  break;\n \t}\n     default:\n-      error (\"misplaced %<@%D%> Objective-C++ construct\", kwd->u.value);\n+      error (\"%Hmisplaced %<@%D%> Objective-C++ construct\",\n+\t     &kwd->location, kwd->u.value);\n       cp_parser_skip_to_end_of_block_or_statement (parser);\n     }\n \n@@ -18683,15 +18857,18 @@ static tree\n cp_parser_objc_encode_expression (cp_parser* parser)\n {\n   tree type;\n+  cp_token *token;\n \n   cp_lexer_consume_token (parser->lexer);  /* Eat '@encode'.  */\n   cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\");\n+  token = cp_lexer_peek_token (parser->lexer);\n   type = complete_type (cp_parser_type_id (parser));\n   cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n \n   if (!type)\n     {\n-      error (\"%<@encode%> must specify a type as an argument\");\n+      error (\"%H%<@encode%> must specify a type as an argument\",\n+\t     &token->location);\n       return error_mark_node;\n     }\n \n@@ -19006,7 +19183,7 @@ cp_parser_objc_selector (cp_parser* parser)\n \n   if (!cp_parser_objc_selector_p (token->type))\n     {\n-      error (\"invalid Objective-C++ selector name\");\n+      error (\"%Hinvalid Objective-C++ selector name\", &token->location);\n       return error_mark_node;\n     }\n \n@@ -19336,7 +19513,8 @@ cp_parser_objc_protocol_declaration (cp_parser* parser)\n   cp_lexer_consume_token (parser->lexer);  /* Eat '@protocol'.  */\n   if (cp_lexer_next_token_is_not (parser->lexer, CPP_NAME))\n     {\n-      error (\"identifier expected after %<@protocol%>\");\n+      tok = cp_lexer_peek_token (parser->lexer);\n+      error (\"%Hidentifier expected after %<@protocol%>\", &tok->location);\n       goto finish;\n     }\n \n@@ -19472,7 +19650,8 @@ cp_parser_objc_declaration (cp_parser* parser)\n       cp_parser_objc_end_implementation (parser);\n       break;\n     default:\n-      error (\"misplaced %<@%D%> Objective-C++ construct\", kwd->u.value);\n+      error (\"%Hmisplaced %<@%D%> Objective-C++ construct\",\n+\t     &kwd->location, kwd->u.value);\n       cp_parser_skip_to_end_of_block_or_statement (parser);\n     }\n }\n@@ -19603,7 +19782,8 @@ cp_parser_objc_statement (cp_parser * parser) {\n     case RID_AT_THROW:\n       return cp_parser_objc_throw_statement (parser);\n     default:\n-      error (\"misplaced %<@%D%> Objective-C++ construct\", kwd->u.value);\n+      error (\"%Hmisplaced %<@%D%> Objective-C++ construct\",\n+\t     &kwd->location, kwd->u.value);\n       cp_parser_skip_to_end_of_block_or_statement (parser);\n     }\n \n@@ -19687,14 +19867,15 @@ cp_parser_omp_clause_name (cp_parser *parser)\n /* Validate that a clause of the given type does not already exist.  */\n \n static void\n-check_no_duplicate_clause (tree clauses, enum tree_code code, const char *name)\n+check_no_duplicate_clause (tree clauses, enum tree_code code,\n+\t\t\t   const char *name, location_t location)\n {\n   tree c;\n \n   for (c = clauses; c ; c = OMP_CLAUSE_CHAIN (c))\n     if (OMP_CLAUSE_CODE (c) == code)\n       {\n-\terror (\"too many %qs clauses\", name);\n+\terror (\"%Htoo many %qs clauses\", &location, name);\n \tbreak;\n       }\n }\n@@ -19717,10 +19898,12 @@ static tree\n cp_parser_omp_var_list_no_open (cp_parser *parser, enum omp_clause_code kind,\n \t\t\t\ttree list)\n {\n+  cp_token *token;\n   while (1)\n     {\n       tree name, decl;\n \n+      token = cp_lexer_peek_token (parser->lexer);\n       name = cp_parser_id_expression (parser, /*template_p=*/false,\n \t\t\t\t      /*check_dependency_p=*/true,\n \t\t\t\t      /*template_p=*/NULL,\n@@ -19729,9 +19912,9 @@ cp_parser_omp_var_list_no_open (cp_parser *parser, enum omp_clause_code kind,\n       if (name == error_mark_node)\n \tgoto skip_comma;\n \n-      decl = cp_parser_lookup_name_simple (parser, name);\n+      decl = cp_parser_lookup_name_simple (parser, name, token->location);\n       if (decl == error_mark_node)\n-\tcp_parser_name_lookup_error (parser, name, decl, NULL);\n+\tcp_parser_name_lookup_error (parser, name, decl, NULL, token->location);\n       else if (kind != 0)\n \t{\n \t  tree u = build_omp_clause (kind);\n@@ -19781,7 +19964,7 @@ cp_parser_omp_var_list (cp_parser *parser, enum omp_clause_code kind, tree list)\n    collapse ( constant-expression ) */\n \n static tree\n-cp_parser_omp_clause_collapse (cp_parser *parser, tree list)\n+cp_parser_omp_clause_collapse (cp_parser *parser, tree list, location_t location)\n {\n   tree c, num;\n   location_t loc;\n@@ -19806,11 +19989,12 @@ cp_parser_omp_clause_collapse (cp_parser *parser, tree list)\n       || (n = tree_low_cst (num, 0)) <= 0\n       || (int) n != n)\n     {\n-      error (\"%Hcollapse argument needs positive constant integer expression\", &loc);\n+      error (\"%Hcollapse argument needs positive constant integer expression\",\n+\t     &loc);\n       return list;\n     }\n \n-  check_no_duplicate_clause (list, OMP_CLAUSE_COLLAPSE, \"collapse\");\n+  check_no_duplicate_clause (list, OMP_CLAUSE_COLLAPSE, \"collapse\", location);\n   c = build_omp_clause (OMP_CLAUSE_COLLAPSE);\n   OMP_CLAUSE_CHAIN (c) = list;\n   OMP_CLAUSE_COLLAPSE_EXPR (c) = num;\n@@ -19822,7 +20006,7 @@ cp_parser_omp_clause_collapse (cp_parser *parser, tree list)\n    default ( shared | none ) */\n \n static tree\n-cp_parser_omp_clause_default (cp_parser *parser, tree list)\n+cp_parser_omp_clause_default (cp_parser *parser, tree list, location_t location)\n {\n   enum omp_clause_default_kind kind = OMP_CLAUSE_DEFAULT_UNSPECIFIED;\n   tree c;\n@@ -19868,7 +20052,7 @@ cp_parser_omp_clause_default (cp_parser *parser, tree list)\n   if (kind == OMP_CLAUSE_DEFAULT_UNSPECIFIED)\n     return list;\n \n-  check_no_duplicate_clause (list, OMP_CLAUSE_DEFAULT, \"default\");\n+  check_no_duplicate_clause (list, OMP_CLAUSE_DEFAULT, \"default\", location);\n   c = build_omp_clause (OMP_CLAUSE_DEFAULT);\n   OMP_CLAUSE_CHAIN (c) = list;\n   OMP_CLAUSE_DEFAULT_KIND (c) = kind;\n@@ -19880,7 +20064,7 @@ cp_parser_omp_clause_default (cp_parser *parser, tree list)\n    if ( expression ) */\n \n static tree\n-cp_parser_omp_clause_if (cp_parser *parser, tree list)\n+cp_parser_omp_clause_if (cp_parser *parser, tree list, location_t location)\n {\n   tree t, c;\n \n@@ -19895,7 +20079,7 @@ cp_parser_omp_clause_if (cp_parser *parser, tree list)\n \t\t\t\t\t   /*or_comma=*/false,\n \t\t\t\t\t   /*consume_paren=*/true);\n \n-  check_no_duplicate_clause (list, OMP_CLAUSE_IF, \"if\");\n+  check_no_duplicate_clause (list, OMP_CLAUSE_IF, \"if\", location);\n \n   c = build_omp_clause (OMP_CLAUSE_IF);\n   OMP_CLAUSE_IF_EXPR (c) = t;\n@@ -19908,11 +20092,12 @@ cp_parser_omp_clause_if (cp_parser *parser, tree list)\n    nowait */\n \n static tree\n-cp_parser_omp_clause_nowait (cp_parser *parser ATTRIBUTE_UNUSED, tree list)\n+cp_parser_omp_clause_nowait (cp_parser *parser ATTRIBUTE_UNUSED,\n+\t\t\t     tree list, location_t location)\n {\n   tree c;\n \n-  check_no_duplicate_clause (list, OMP_CLAUSE_NOWAIT, \"nowait\");\n+  check_no_duplicate_clause (list, OMP_CLAUSE_NOWAIT, \"nowait\", location);\n \n   c = build_omp_clause (OMP_CLAUSE_NOWAIT);\n   OMP_CLAUSE_CHAIN (c) = list;\n@@ -19923,7 +20108,8 @@ cp_parser_omp_clause_nowait (cp_parser *parser ATTRIBUTE_UNUSED, tree list)\n    num_threads ( expression ) */\n \n static tree\n-cp_parser_omp_clause_num_threads (cp_parser *parser, tree list)\n+cp_parser_omp_clause_num_threads (cp_parser *parser, tree list,\n+\t\t\t\t  location_t location)\n {\n   tree t, c;\n \n@@ -19938,7 +20124,8 @@ cp_parser_omp_clause_num_threads (cp_parser *parser, tree list)\n \t\t\t\t\t   /*or_comma=*/false,\n \t\t\t\t\t   /*consume_paren=*/true);\n \n-  check_no_duplicate_clause (list, OMP_CLAUSE_NUM_THREADS, \"num_threads\");\n+  check_no_duplicate_clause (list, OMP_CLAUSE_NUM_THREADS,\n+\t\t\t     \"num_threads\", location);\n \n   c = build_omp_clause (OMP_CLAUSE_NUM_THREADS);\n   OMP_CLAUSE_NUM_THREADS_EXPR (c) = t;\n@@ -19951,11 +20138,13 @@ cp_parser_omp_clause_num_threads (cp_parser *parser, tree list)\n    ordered */\n \n static tree\n-cp_parser_omp_clause_ordered (cp_parser *parser ATTRIBUTE_UNUSED, tree list)\n+cp_parser_omp_clause_ordered (cp_parser *parser ATTRIBUTE_UNUSED,\n+\t\t\t      tree list, location_t location)\n {\n   tree c;\n \n-  check_no_duplicate_clause (list, OMP_CLAUSE_ORDERED, \"ordered\");\n+  check_no_duplicate_clause (list, OMP_CLAUSE_ORDERED,\n+\t\t\t     \"ordered\", location);\n \n   c = build_omp_clause (OMP_CLAUSE_ORDERED);\n   OMP_CLAUSE_CHAIN (c) = list;\n@@ -20032,7 +20221,7 @@ cp_parser_omp_clause_reduction (cp_parser *parser, tree list)\n      static | dynamic | guided | runtime | auto  */\n \n static tree\n-cp_parser_omp_clause_schedule (cp_parser *parser, tree list)\n+cp_parser_omp_clause_schedule (cp_parser *parser, tree list, location_t location)\n {\n   tree c, t;\n \n@@ -20080,18 +20269,20 @@ cp_parser_omp_clause_schedule (cp_parser *parser, tree list)\n \n   if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n     {\n+      cp_token *token;\n       cp_lexer_consume_token (parser->lexer);\n \n+      token = cp_lexer_peek_token (parser->lexer);\n       t = cp_parser_assignment_expression (parser, false);\n \n       if (t == error_mark_node)\n \tgoto resync_fail;\n       else if (OMP_CLAUSE_SCHEDULE_KIND (c) == OMP_CLAUSE_SCHEDULE_RUNTIME)\n-\terror (\"schedule %<runtime%> does not take \"\n-\t       \"a %<chunk_size%> parameter\");\n+\terror (\"%Hschedule %<runtime%> does not take \"\n+\t       \"a %<chunk_size%> parameter\", &token->location);\n       else if (OMP_CLAUSE_SCHEDULE_KIND (c) == OMP_CLAUSE_SCHEDULE_AUTO)\n-\terror (\"schedule %<auto%> does not take \"\n-\t       \"a %<chunk_size%> parameter\");\n+\terror (\"%Hschedule %<auto%> does not take \"\n+\t       \"a %<chunk_size%> parameter\", &token->location);\n       else\n \tOMP_CLAUSE_SCHEDULE_CHUNK_EXPR (c) = t;\n \n@@ -20101,7 +20292,7 @@ cp_parser_omp_clause_schedule (cp_parser *parser, tree list)\n   else if (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<,%> or %<)%>\"))\n     goto resync_fail;\n \n-  check_no_duplicate_clause (list, OMP_CLAUSE_SCHEDULE, \"schedule\");\n+  check_no_duplicate_clause (list, OMP_CLAUSE_SCHEDULE, \"schedule\", location);\n   OMP_CLAUSE_CHAIN (c) = list;\n   return c;\n \n@@ -20118,11 +20309,12 @@ cp_parser_omp_clause_schedule (cp_parser *parser, tree list)\n    untied */\n \n static tree\n-cp_parser_omp_clause_untied (cp_parser *parser ATTRIBUTE_UNUSED, tree list)\n+cp_parser_omp_clause_untied (cp_parser *parser ATTRIBUTE_UNUSED,\n+\t\t\t     tree list, location_t location)\n {\n   tree c;\n \n-  check_no_duplicate_clause (list, OMP_CLAUSE_UNTIED, \"untied\");\n+  check_no_duplicate_clause (list, OMP_CLAUSE_UNTIED, \"untied\", location);\n \n   c = build_omp_clause (OMP_CLAUSE_UNTIED);\n   OMP_CLAUSE_CHAIN (c) = list;\n@@ -20139,6 +20331,7 @@ cp_parser_omp_all_clauses (cp_parser *parser, unsigned int mask,\n {\n   tree clauses = NULL;\n   bool first = true;\n+  cp_token *token = NULL;\n \n   while (cp_lexer_next_token_is_not (parser->lexer, CPP_PRAGMA_EOL))\n     {\n@@ -20149,13 +20342,15 @@ cp_parser_omp_all_clauses (cp_parser *parser, unsigned int mask,\n       if (!first && cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n \tcp_lexer_consume_token (parser->lexer);\n \n+      token = cp_lexer_peek_token (parser->lexer);\n       c_kind = cp_parser_omp_clause_name (parser);\n       first = false;\n \n       switch (c_kind)\n \t{\n \tcase PRAGMA_OMP_CLAUSE_COLLAPSE:\n-\t  clauses = cp_parser_omp_clause_collapse (parser, clauses);\n+\t  clauses = cp_parser_omp_clause_collapse (parser, clauses,\n+\t\t\t\t\t\t   token->location);\n \t  c_name = \"collapse\";\n \t  break;\n \tcase PRAGMA_OMP_CLAUSE_COPYIN:\n@@ -20168,7 +20363,8 @@ cp_parser_omp_all_clauses (cp_parser *parser, unsigned int mask,\n \t  c_name = \"copyprivate\";\n \t  break;\n \tcase PRAGMA_OMP_CLAUSE_DEFAULT:\n-\t  clauses = cp_parser_omp_clause_default (parser, clauses);\n+\t  clauses = cp_parser_omp_clause_default (parser, clauses,\n+\t\t\t\t\t\t  token->location);\n \t  c_name = \"default\";\n \t  break;\n \tcase PRAGMA_OMP_CLAUSE_FIRSTPRIVATE:\n@@ -20177,7 +20373,7 @@ cp_parser_omp_all_clauses (cp_parser *parser, unsigned int mask,\n \t  c_name = \"firstprivate\";\n \t  break;\n \tcase PRAGMA_OMP_CLAUSE_IF:\n-\t  clauses = cp_parser_omp_clause_if (parser, clauses);\n+\t  clauses = cp_parser_omp_clause_if (parser, clauses, token->location);\n \t  c_name = \"if\";\n \t  break;\n \tcase PRAGMA_OMP_CLAUSE_LASTPRIVATE:\n@@ -20186,15 +20382,17 @@ cp_parser_omp_all_clauses (cp_parser *parser, unsigned int mask,\n \t  c_name = \"lastprivate\";\n \t  break;\n \tcase PRAGMA_OMP_CLAUSE_NOWAIT:\n-\t  clauses = cp_parser_omp_clause_nowait (parser, clauses);\n+\t  clauses = cp_parser_omp_clause_nowait (parser, clauses, token->location);\n \t  c_name = \"nowait\";\n \t  break;\n \tcase PRAGMA_OMP_CLAUSE_NUM_THREADS:\n-\t  clauses = cp_parser_omp_clause_num_threads (parser, clauses);\n+\t  clauses = cp_parser_omp_clause_num_threads (parser, clauses,\n+\t\t\t\t\t\t      token->location);\n \t  c_name = \"num_threads\";\n \t  break;\n \tcase PRAGMA_OMP_CLAUSE_ORDERED:\n-\t  clauses = cp_parser_omp_clause_ordered (parser, clauses);\n+\t  clauses = cp_parser_omp_clause_ordered (parser, clauses,\n+\t\t\t\t\t\t  token->location);\n \t  c_name = \"ordered\";\n \t  break;\n \tcase PRAGMA_OMP_CLAUSE_PRIVATE:\n@@ -20207,7 +20405,8 @@ cp_parser_omp_all_clauses (cp_parser *parser, unsigned int mask,\n \t  c_name = \"reduction\";\n \t  break;\n \tcase PRAGMA_OMP_CLAUSE_SCHEDULE:\n-\t  clauses = cp_parser_omp_clause_schedule (parser, clauses);\n+\t  clauses = cp_parser_omp_clause_schedule (parser, clauses,\n+\t\t\t\t\t\t   token->location);\n \t  c_name = \"schedule\";\n \t  break;\n \tcase PRAGMA_OMP_CLAUSE_SHARED:\n@@ -20216,7 +20415,8 @@ cp_parser_omp_all_clauses (cp_parser *parser, unsigned int mask,\n \t  c_name = \"shared\";\n \t  break;\n \tcase PRAGMA_OMP_CLAUSE_UNTIED:\n-\t  clauses = cp_parser_omp_clause_untied (parser, clauses);\n+\t  clauses = cp_parser_omp_clause_untied (parser, clauses,\n+\t\t\t\t\t\t token->location);\n \t  c_name = \"nowait\";\n \t  break;\n \tdefault:\n@@ -20229,7 +20429,7 @@ cp_parser_omp_all_clauses (cp_parser *parser, unsigned int mask,\n \t  /* Remove the invalid clause(s) from the list to avoid\n \t     confusing the rest of the compiler.  */\n \t  clauses = prev;\n-\t  error (\"%qs is not valid for %qs\", c_name, where);\n+\t  error (\"%H%qs is not valid for %qs\", &token->location, c_name, where);\n \t}\n     }\n  saw_error:\n@@ -21315,10 +21515,11 @@ cp_parser_initial_pragma (cp_token *first_token)\n \n       cp_lexer_get_preprocessor_token (NULL, first_token);\n       if (first_token->type != CPP_PRAGMA_EOL)\n-\terror (\"junk at end of %<#pragma GCC pch_preprocess%>\");\n+\terror (\"%Hjunk at end of %<#pragma GCC pch_preprocess%>\",\n+               &first_token->location);\n     }\n   else\n-    error (\"expected string literal\");\n+    error (\"%Hexpected string literal\", &first_token->location);\n \n   /* Skip to the end of the pragma.  */\n   while (first_token->type != CPP_PRAGMA_EOL && first_token->type != CPP_EOF)\n@@ -21351,7 +21552,8 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context)\n   switch (id)\n     {\n     case PRAGMA_GCC_PCH_PREPROCESS:\n-      error (\"%<#pragma GCC pch_preprocess%> must be first\");\n+      error (\"%H%<#pragma GCC pch_preprocess%> must be first\",\n+             &pragma_tok->location);\n       break;\n \n     case PRAGMA_OMP_BARRIER:\n@@ -21361,8 +21563,8 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context)\n \t  cp_parser_omp_barrier (parser, pragma_tok);\n \t  return false;\n \tcase pragma_stmt:\n-\t  error (\"%<#pragma omp barrier%> may only be \"\n-\t\t \"used in compound statements\");\n+\t  error (\"%H%<#pragma omp barrier%> may only be \"\n+\t\t \"used in compound statements\", &pragma_tok->location);\n \t  break;\n \tdefault:\n \t  goto bad_stmt;\n@@ -21376,8 +21578,8 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context)\n \t  cp_parser_omp_flush (parser, pragma_tok);\n \t  return false;\n \tcase pragma_stmt:\n-\t  error (\"%<#pragma omp flush%> may only be \"\n-\t\t \"used in compound statements\");\n+\t  error (\"%H%<#pragma omp flush%> may only be \"\n+\t\t \"used in compound statements\", &pragma_tok->location);\n \t  break;\n \tdefault:\n \t  goto bad_stmt;\n@@ -21418,8 +21620,8 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context)\n       return true;\n \n     case PRAGMA_OMP_SECTION:\n-      error (\"%<#pragma omp section%> may only be used in \"\n-\t     \"%<#pragma omp sections%> construct\");\n+      error (\"%H%<#pragma omp section%> may only be used in \"\n+\t     \"%<#pragma omp sections%> construct\", &pragma_tok->location);\n       break;\n \n     default:"}, {"sha": "1378e5618dc783aabd4ecd1394704d5dca7d3c54", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea", "patch": "@@ -9743,7 +9743,7 @@ tsubst_qualified_id (tree qualified_id, tree args,\n       if (complain & tf_error)\n \tqualified_name_lookup_error (scope,\n \t\t\t\t     TREE_OPERAND (qualified_id, 1),\n-\t\t\t\t     expr);\n+\t\t\t\t     expr, input_location);\n       return error_mark_node;\n     }\n \n@@ -9752,7 +9752,7 @@ tsubst_qualified_id (tree qualified_id, tree args,\n \n   if (expr == error_mark_node && complain & tf_error)\n     qualified_name_lookup_error (scope, TREE_OPERAND (qualified_id, 1),\n-\t\t\t\t expr);\n+\t\t\t\t expr, input_location);\n   else if (TYPE_P (scope))\n     {\n       expr = (adjust_result_of_qualified_name_lookup\n@@ -10484,7 +10484,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \t\t\t\t\t  /*is_type_p=*/false,\n \t\t\t\t\t  /*complain=*/false);\n \t    if (decl == error_mark_node || TREE_CODE (decl) == TREE_LIST)\n-\t      qualified_name_lookup_error (scope, name, decl);\n+\t      qualified_name_lookup_error (scope, name, decl, input_location);\n \t    else\n \t      do_local_using_decl (decl, scope, name);\n \t  }\n@@ -10931,7 +10931,8 @@ tsubst_copy_and_build (tree t,\n \t\t\t\t     /*done=*/true,\n \t\t\t\t     /*address_p=*/false,\n \t\t\t\t     /*template_arg_p=*/false,\n-\t\t\t\t     &error_msg);\n+\t\t\t\t     &error_msg,\n+\t\t\t\t     input_location);\n \tif (error_msg)\n \t  error (error_msg);\n \tif (!function_p && TREE_CODE (decl) == IDENTIFIER_NODE)\n@@ -11460,7 +11461,8 @@ tsubst_copy_and_build (tree t,\n \t      }\n \t    else\n \t      {\n-\t\tqualified_name_lookup_error (object_type, tmpl, member);\n+\t\tqualified_name_lookup_error (object_type, tmpl, member,\n+\t\t\t\t\t     input_location);\n \t\treturn error_mark_node;\n \t      }\n \t  }"}, {"sha": "17b1e5dee498afba533b4d3670f275ca618d260d", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea", "patch": "@@ -2502,29 +2502,33 @@ finish_base_specifier (tree base, tree access, bool virtual_p)\n }\n \n /* Issue a diagnostic that NAME cannot be found in SCOPE.  DECL is\n-   what we found when we tried to do the lookup.  */\n+   what we found when we tried to do the lookup.\n+   LOCATION is the location of the NAME identifier;\n+   The location is used in the error message*/\n \n void\n-qualified_name_lookup_error (tree scope, tree name, tree decl)\n+qualified_name_lookup_error (tree scope, tree name,\n+\t\t\t     tree decl, location_t location)\n {\n   if (scope == error_mark_node)\n     ; /* We already complained.  */\n   else if (TYPE_P (scope))\n     {\n       if (!COMPLETE_TYPE_P (scope))\n-\terror (\"incomplete type %qT used in nested name specifier\", scope);\n+\terror (\"%Hincomplete type %qT used in nested name specifier\",\n+\t       &location, scope);\n       else if (TREE_CODE (decl) == TREE_LIST)\n \t{\n-\t  error (\"reference to %<%T::%D%> is ambiguous\", scope, name);\n+\t  error (\"%Hreference to %<%T::%D%> is ambiguous\", &location, scope, name);\n \t  print_candidates (decl);\n \t}\n       else\n-\terror (\"%qD is not a member of %qT\", name, scope);\n+\terror (\"%H%qD is not a member of %qT\", &location, name, scope);\n     }\n   else if (scope != global_namespace)\n-    error (\"%qD is not a member of %qD\", name, scope);\n+    error (\"%H%qD is not a member of %qD\", &location, name, scope);\n   else\n-    error (\"%<::%D%> has not been declared\", name);\n+    error (\"%H%<::%D%> has not been declared\", &location, name);\n }\n \n /* If FNS is a member function, a set of member functions, or a\n@@ -2589,7 +2593,6 @@ baselink_for_fns (tree fns)\n    the use of \"this\" explicit.\n \n    Upon return, *IDK will be filled in appropriately.  */\n-\n tree\n finish_id_expression (tree id_expression,\n \t\t      tree decl,\n@@ -2602,7 +2605,8 @@ finish_id_expression (tree id_expression,\n \t\t      bool done,\n \t\t      bool address_p,\n \t\t      bool template_arg_p,\n-\t\t      const char **error_msg)\n+\t\t      const char **error_msg,\n+\t\t      location_t location)\n {\n   /* Initialize the output parameters.  */\n   *idk = CP_ID_KIND_NONE;\n@@ -2632,7 +2636,7 @@ finish_id_expression (tree id_expression,\n \t      /* If the qualifying type is non-dependent (and the name\n \t\t does not name a conversion operator to a dependent\n \t\t type), issue an error.  */\n-\t      qualified_name_lookup_error (scope, id_expression, decl);\n+\t      qualified_name_lookup_error (scope, id_expression, decl, location);\n \t      return error_mark_node;\n \t    }\n \t  else if (!scope)"}, {"sha": "c558bb675a89d1e6916f2987a3f4b4240c5081ad", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea", "patch": "@@ -1,3 +1,10 @@\n+2008-07-11 Dodji Seketeli <dseketel@redhat.com>\n+\n+\t* g++.dg/parse/constructor1.C, g++.dg/parse/error*.C: update these\n+\t  tests to make them catch column number regressions. Make these tests\n+\t  run with the -fshow-column option.\n+\t* g++.dg/parse/error-column.C: new column number test.\n+\n 2008-07-11  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/36765"}, {"sha": "8f222f80b10f293e29a7b5864f43b89ec2d6ab15", "filename": "gcc/testsuite/g++.dg/parse/constructor1.C", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fconstructor1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fconstructor1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fconstructor1.C?ref=2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea", "patch": "@@ -1,4 +1,7 @@\n+// { dg-do compile }\n+// { dg-options \"-fshow-column\" }\n+\n ACE_Process_Descriptor::ACE_Process_Descriptor () : // { dg-error \"\" }\n-  process_ (0)\n+  process_ (0) // { dg-error \"3: error: only constructors take base initializers\" }\n {\n }"}, {"sha": "812a499ff4df46a93c06ae025d42448835062015", "filename": "gcc/testsuite/g++.dg/parse/error-column.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror-column.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror-column.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror-column.C?ref=2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea", "patch": "@@ -0,0 +1,9 @@\n+// { dg-do compile }\n+// Make sure column information is correctly shown in error reporting\n+// { dg-options \"-fshow-column\" }\n+\n+\n+void foo ()\n+{\n+  cout << \"blah\"; // { dg-error \"3: error: 'cout'\" }\n+}"}, {"sha": "60e7d6587b3b2b2e05b9fe198032324a8f97f529", "filename": "gcc/testsuite/g++.dg/parse/error1.C", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror1.C?ref=2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea", "patch": "@@ -1,6 +1,7 @@\n+// { dg-options \"-fshow-column\" }\n struct INCOMPLETE;\n template <int> struct X {\n     static INCOMPLETE value;\n };\n-template <> INCOMPLETE X<1>::value = 0; // { dg-error \"\" }\n+template <> INCOMPLETE X<1>::value = 0; // { dg-error \"30: error: variable 'INCOMPLETE X<1>::value' has initializer but incomplete type\" }\n "}, {"sha": "6e46922a115188e91ad292bbd5289e994b92f666", "filename": "gcc/testsuite/g++.dg/parse/error10.C", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror10.C?ref=2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea", "patch": "@@ -1,5 +1,5 @@\n // PR c++/3478\n-// { dg-options \"\" }\n+// { dg-options \"-fshow-column\" }\n \n template <typename> struct A\n {\n@@ -11,5 +11,9 @@ template <typename T> void foo()\n   enum          A<void>::E e1;\n   typename      A<T>::E    e2;\n   enum          A<T>::E    e3;\n-  enum typename A<T>::E    e4; // { dg-error \"\" }\n+  enum typename A<T>::E    e4;\n }\n+\n+// Here, columns nums are not very accurate either. Still acceptable though\n+// { dg-error \"30: error: invalid type in declaration before ';' token\" \"\" { target *-*-* } { 14 } }\n+// { dg-error \"30: error: two or more data types in declaration of 'e4'\" \"\" { target *-*-* } { 14 } }"}, {"sha": "f7093a8f987557e16705dffa4a2f6beb79a797c2", "filename": "gcc/testsuite/g++.dg/parse/error11.C", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror11.C?ref=2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea", "patch": "@@ -1,4 +1,5 @@\n // { dg-do compile }\n+// { dg-options \"-fshow-column\" }\"\n // Origin: Giovanni Bajo <giovannibajo at gcc dot gnu dot org>\n // Try to find out when the digraph '<:' is used as a mistake, and parse it\n //  correctly to avoid cascaded errors.\n@@ -15,39 +16,45 @@ struct Foo\n   };\n \n   void method(void) {\n-    typename Foo<::B>::template Nested<::B> n; // { dg-error \"cannot begin|alternate spelling\" }\n+    typename Foo<::B>::template Nested<::B> n; // { dg-error \"17: error: '<::' cannot begin|17: note: '<:' is an alternate spelling|39: error: '<::' cannot begin|39: note: '<:' is an alternate\" }\n     n.template Nested<B>::method();\n-    n.template Nested<::B>::method();  // { dg-error \"cannot begin|alternate spelling\" }\n+    n.template Nested<::B>::method();  // { dg-error \"22: error: '<::' cannot begin|22: note: '<:' is an alternate\" }\n     Nested<B>::method();\n-    Nested<::B>::method(); // { dg-error \"cannot begin|alternate spelling\" }\n+    Nested<::B>::method(); // { dg-error \"11: error: '<::' cannot begin|11: note: '<:' is an alternate\" }\n   }\n };\n \n template <int N> struct Foo2 {};\n-template struct Foo2<::B>;  // { dg-error \"cannot begin|alternate spelling|type/value mismatch|expected a constant\" }\n+template struct Foo2<::B>;  // { dg-error \"21: error: '<::' cannot begin|21: note: '<:' is an alternate|25: error: type/value mismatch|25: error:   expected a constant\" }\n \n int value = 0;\n \n void func(void)\n {\n   Foo<::B> f; // { dg-error \"cannot begin|alternate spelling\" }\n   f.Foo<B>::method();\n-  f.Foo<::B>::method(); // { dg-error \"cannot begin|alternate spelling\" }\n+  f.Foo<::B>::method(); // { dg-error \"8: error|8: note\" }\n \n   // Check cases where we the token sequence is the correct one, but there\n   //  was no digraph or whitespaces in the middle, so we should not emit\n   //  the special error message.\n   Foo<: :B> k2;     // { dg-bogus \"cannot begin|alternate spelling\" \"smart error should not be triggered here\" }\n   Foo[:B> k1;       // { dg-bogus \"cannot begin|alternate spelling\" \"smart error should not be triggered here\" } \n-// { dg-error \"\" \"\" { target *-*-* } 40 }\n-// { dg-error \"\" \"\" { target *-*-* } 41 }\n-\n+// { dg-error \"6: error: missing template arguments before\" \"\" { target *-*-* } { 41 } }\n+// { dg-error \"9: error: expected primary-expression before ':' token\" \"\" { target *-*-* } 41 }\n+// { dg-error \"9: error: expected '\\]' before ':' token\" \"\" { target *-*-* } 41 }\n+// { dg-error \"9: error: expected ';' before ':' token\" \"\" { target *-*-* } 41 }\n+// { dg-error \"6: error: missing template arguments before\" \"\" { target *-*-* } 42 }\n+// { dg-error \"7: error: expected primary-expression before ':' token\" \"\" { target *-*-* } 42 }\n+// { dg-error \"7: error: expected '\\]' before ':' token\" \"\" { target *-*-* } 42 }\n+// { dg-error \"7: error: expected ';' before ':' token\" \"\" { target *-*-* } 42 }\n+//\n   int Foo[2];\n   Foo[::value] = 0;\n }\n \n-template struct Foo<::B>; // { dg-error \"cannot begin|alternate spelling\" }\n+template struct Foo<::B>; // { dg-error \"20: error: '<::' cannot begin|20: note: '<:' is an alternate\" }\n \n // On the first error message, an additional note about the use of \n //  -fpermissive should be present\n-// { dg-error \"-fpermissive\" \"-fpermissive\" { target *-*-* } 18 }\n+// { dg-error \"17: note: \\\\(if you use '-fpermissive' G\\\\+\\\\+ will accept your code\\\\)\" \"-fpermissive\" { target *-*-* } 19 }"}, {"sha": "b0025885bf4e0a5d97c9cbdc2a459628385e6063", "filename": "gcc/testsuite/g++.dg/parse/error12.C", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror12.C?ref=2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea", "patch": "@@ -1,12 +1,13 @@\n // { dg-do compile }\n // Origin: Giovanni Bajo <giovannibajo at gcc dot gnu dot org>\n // Make sure the error about '<:' can be turned into a warning\n-// { dg-options \"-fpermissive\" }\n+// { dg-options \"-fpermissive -fshow-column\" }\n \n struct B;\n \n template <class A>\n struct Foo {};\n \n Foo<::B> foo;   // { dg-bogus \"error\" \"error in place of warning\" }\n-// { dg-error \"\" \"\" { target *-*-* } 11 }\n+// { dg-error \"4: warning: '<::' cannot begin a template-argument list\" \"warning <::\" { target *-*-* } 11 }\n+// { dg-error \"4: note: '<:' is an alternate spelling for '.'. Insert whitespace between '<' and '::'\" \"note <:\" { target *-*-* } 11 }"}, {"sha": "94ddae89705dfe6f3592dfe770b36c84b7c2b1c4", "filename": "gcc/testsuite/g++.dg/parse/error13.C", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror13.C?ref=2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea", "patch": "@@ -1,13 +1,14 @@\n+// { dg-options \"-fshow-column\" }\n // PR c++/13975\n \n-public: // { dg-error \"\" }\n+public: // { dg-error \"1: error: expected unqualified-id before 'public'\" }\n \n int i;\n \n-protected: // { dg-error \"\" }\n+protected: // { dg-error \"1: error: expected unqualified-id before 'protected'\" }\n \n int j;\n \n-private: // { dg-error \"\" }\n+private: // { dg-error \"1: error: expected unqualified-id before 'private'\" }\n \n int k;"}, {"sha": "906b98f87e218ea492b4d8ea7d3a4891322f4881", "filename": "gcc/testsuite/g++.dg/parse/error14.C", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror14.C?ref=2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea", "patch": "@@ -1,3 +1,4 @@\n+// { dg-options \"-fshow-column\" }\n // PR c++/13970\n \n struct X\n@@ -18,5 +19,5 @@ struct X\n         Zinc<int>( //);\n \t\t  //    }\n \n-}; // { dg-error \"\" }\n+}; // { dg-error \"2: error: expected '.' at end of input|1: error: expected primary-expression before '.' token|1: error: expected ';' before '.' token|1: error: expected unqualified-id at end of input\" }\n "}, {"sha": "b65175cfc91cc17d4848f75e85e43648f2ce6558", "filename": "gcc/testsuite/g++.dg/parse/error15.C", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror15.C?ref=2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea", "patch": "@@ -1,5 +1,6 @@\n // { dg-do compile }\n // Contributed by Volker Reichelt <reichelt at gcc dot gnu dot org> \n+// { dg-options \"-fshow-column\" }\n // PR c++/14008: Improve diagnostic on invalid types in declarators.\n \n namespace N\n@@ -9,29 +10,29 @@ namespace N\n   int K;\n }\n \n-N::A f2;              // { dg-error \"without an argument list\" }\n-N::INVALID f3;        // { dg-error \"in namespace 'N' does not name a type\" }\n-N::C::INVALID f4;     // { dg-error \"in class 'N::C' does not name a type\" }\n-N::K f6;              // { dg-error \"in namespace 'N' does not name a type\" }\n-typename N::A f7;     // { dg-error \"without an argument list|outside of template\" }\n+N::A f2;              // { dg-error \"4: error: invalid use of template-name 'N::A' without an argument list\" }\n+N::INVALID f3;        // { dg-error \"4: error: 'INVALID' in namespace 'N' does not name a type\" }\n+N::C::INVALID f4;     // { dg-error \"7: error: 'INVALID' in class 'N::C' does not name a type\" }\n+N::K f6;              // { dg-error \"4: error: 'K' in namespace 'N' does not name a type\" }\n+typename N::A f7;     // { dg-error \"1: error: using 'typename' outside of template|13: error: invalid use of template-name 'N::A' without an argument list|17: error: invalid type in declaration before ';' token\" }\n \n struct B\n {\n-  N::A f2;            // { dg-error \"without an argument list\" }\n-  N::INVALID f3;      // { dg-error \"in namespace 'N' does not name a type\" }\n-  N::C::INVALID f4;   // { dg-error \"in class 'N::C' does not name a type\" }\n-  N::K f6;            // { dg-error \"in namespace 'N' does not name a type\" }\n-  typename N::A f7;   // { dg-error \"without an argument list|outside of template\" }\n+  N::A f2;            // { dg-error \"6: error: invalid use of template-name 'N::A' without an argument list\" }\n+  N::INVALID f3;      // { dg-error \"6: error: 'INVALID' in namespace 'N' does not name a type\" }\n+  N::C::INVALID f4;   // { dg-error \"9: error: 'INVALID' in class 'N::C' does not name a type\" }\n+  N::K f6;            // { dg-error \"6: error: 'K' in namespace 'N' does not name a type\" }\n+  typename N::A f7;   // { dg-error \"3: error: using 'typename' outside of template|15: error: invalid use of template-name 'N::A' without an argument list\" }\n };\n \n template <int>\n struct C\n {\n-  N::A f2;            // { dg-error \"without an argument list\" }\n-  N::INVALID f3;      // { dg-error \"in namespace 'N' does not name a type\" }\n-  N::C::INVALID f4;   // { dg-error \"in class 'N::C' does not name a type\" }\n-  N::K f6;            // { dg-error \"in namespace 'N' does not name a type\" }\n-  typename N::A f7;   // { dg-error \"without an argument list\" }\n+  N::A f2;            // { dg-error \"6: error: invalid use of template-name 'N::A' without an argument list\" }\n+  N::INVALID f3;      // { dg-error \"6: error: 'INVALID' in namespace 'N' does not name a type\" }\n+  N::C::INVALID f4;   // { dg-error \"9: error: 'INVALID' in class 'N::C' does not name a type\" }\n+  N::K f6;            // { dg-error \"6: error: 'K' in namespace 'N' does not name a type\" }\n+  typename N::A f7;   // { dg-error \"15: error: invalid use of template-name 'N::A' without an argument list\" }\n };\n \n-// { dg-bogus \"\" \"bogus excess errors in declaration\" { xfail *-*-* } 16 }\n+// { dg-bogus \"bogus excess errors in declaration\" \"bogus excess errors in declaration\" { xfail *-*-* } 17 }"}, {"sha": "ddc302c7cd6aaa8d38cee7b5273b8717a8cb0300", "filename": "gcc/testsuite/g++.dg/parse/error16.C", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror16.C?ref=2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea", "patch": "@@ -1,8 +1,9 @@\n+// { dg-options \"-fshow-column\" }\n // PR c++/16964\n \n struct A\n {\n-  struct B {}; // { dg-error \"previous\" }\n+  struct B {}; // { dg-error \"12: error: previous definition of 'struct A::B'\" }\n };\n \n-struct A::B{}; // { dg-error \"redefinition\" }\n+struct A::B{}; // { dg-error \"11: error: redefinition of 'struct A::B'\" }"}, {"sha": "0e05217c04ddcf971b760e57ac7b632423c51d43", "filename": "gcc/testsuite/g++.dg/parse/error17.C", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror17.C?ref=2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea", "patch": "@@ -1,8 +1,9 @@\n+// { dg-options \"-fshow-column\" }\n // PR c++/16965\n \n template <typename T> struct B { \n-  static int Bar(T); // { dg-error \"\" }\n+  static int Bar(T); // { dg-error \"19: error: candidates are: |19: error:  \" }\n }; \n struct D : B<int>, B<char> {}; \n  \n-int i2 = D::Bar(2); // { dg-error \"\" }\n+int i2 = D::Bar(2); // { dg-error \"13: error: reference to 'Bar' is ambiguous|10: error: reference to 'Bar' is ambiguous\" }"}, {"sha": "926af11eb6a8f3ba106b20c4e864e5f1feb69e77", "filename": "gcc/testsuite/g++.dg/parse/error18.C", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror18.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror18.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror18.C?ref=2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea", "patch": "@@ -1,7 +1,8 @@\n+// { dg-options \"-fshow-column\" }\n // PR c++/16002\n \n void f()\n {\n-  double Q *= 5.0; // { dg-error \"initializer\" }\n+  double Q *= 5.0; // { dg-error \"12: error: expected initializer before '..' token\" }\n }\n "}, {"sha": "b22156a5d717f5594ea41b4e7ebfee0ab418f647", "filename": "gcc/testsuite/g++.dg/parse/error19.C", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror19.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror19.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror19.C?ref=2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea", "patch": "@@ -1,13 +1,14 @@\n+// { dg-options \"-fshow-column -fmessage-length=0   -ansi -pedantic-errors -Wno-long-long \" }\n // PR C++/17867\n \n struct A\n-{  // { dg-error \"candidate\" }\n+{  // { dg-error \"1: note: candidates are:\" }\n   A(int);\n };\n \n const A& foo();\n \n void bar()\n {\n-  foo()=A(0); // { dg-error \"A\" }\n+  foo()=A(0); // { dg-error \"12: error: no match for 'operator='\" }\n }"}, {"sha": "075dcc2b0d15c86dc733c485fedf06090441d508", "filename": "gcc/testsuite/g++.dg/parse/error2.C", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror2.C?ref=2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea", "patch": "@@ -1,4 +1,5 @@\n // { dg-do compile }\n+// { dg-options \"-fshow-column\" }\n // Properly print CALL_EXPRs while dumping expressions\n \n double g;\n@@ -7,4 +8,8 @@ int func(double);\n template <int>\n struct Foo {};\n \n-Foo<func(g)> f; // { dg-error \"\" \"func(g)\" }\n+Foo<func(g)> f; // { dg-error \"5: error: 'int func.double.' cannot appear in a constant-expression\" \"\" { target *-*-* } { 11 } }\n+// { dg-error \"10: error: 'g' cannot appear in a constant-expression\" \"\" { target *-*-* } { 11 } }\n+// { dg-error \"11: error: a function call cannot appear in a constant-expression\" \"\" { target *-*-* } { 11 } }\n+// { dg-error \"12: error: template argument 1 is invalid\" \"\" { target *-*-* } { 11 } }\n+// { dg-error \"15: error: invalid type in declaration before ';' token\" \"\" { target *-*-* } { 11 } }"}, {"sha": "9564fab757b7ff89a8e9e2b1698fc7ff1957c9a9", "filename": "gcc/testsuite/g++.dg/parse/error20.C", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror20.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror20.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror20.C?ref=2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea", "patch": "@@ -1,3 +1,4 @@\n+// { dg-options \"-fshow-column -ansi -pedantic-errors -Wno-long-long\" }\n // PR c++/17821\n \n struct A {\n@@ -11,7 +12,7 @@ struct C {\n };\n int main() {\n   C c;\n-  A(c.p.i); // { dg-error \"member.*non-class\" }\n+  A(c.p.i); // { dg-error \"9: error: request for member 'i' in 'c.C::p', which is of non-class type 'B\" }\n   return 0;\n }\n "}, {"sha": "f60bf2b9c54aed23d860a1ce55137fe86de2662c", "filename": "gcc/testsuite/g++.dg/parse/error21.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror21.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror21.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror21.C?ref=2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea", "patch": "@@ -1,12 +1,12 @@\n // PR c++/17393\n-// { dg-options \"-Wall\" }\n+// { dg-options \"-Wall -fshow-column\" }\n \n struct A { };\n \n void foo()\n {\n   // Check that we do not complain about an unused\n   // compiler-generated variable.\n-  A& = a; // { dg-error \"token|declarator|not declared\" }\n+  A& = a; // { dg-error \"6: error: expected unqualified-id before '=' token|8: error: 'a' was not declared in this scope\" }\n }\n "}, {"sha": "30141219abc885e4250bcd23850d9a51af7be008", "filename": "gcc/testsuite/g++.dg/parse/error22.C", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror22.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror22.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror22.C?ref=2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea", "patch": "@@ -1,5 +1,6 @@\n+// { dg-options \"-fshow-column -ansi -pedantic-errors -Wno-long-long\" }\n // PR c++/15786\n \n struct A {\n-  void foo(bar* p); /* { dg-error \"declared\" } */\n+  void foo(bar* p); /* { dg-error \"12: error: 'bar' has not been declared\" } */\n };"}, {"sha": "21b24349608bb845714f1b3591819c408db88dc1", "filename": "gcc/testsuite/g++.dg/parse/error23.C", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror23.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror23.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror23.C?ref=2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea", "patch": "@@ -1,7 +1,9 @@\n+// { dg-options \"-fshow-column -ansi -pedantic-errors -Wno-long-long\" }\n // PR c++/19149\n \n struct QChar {\n   QChar( char c );\n   QChar( const QChar& c );\n-  static const ; // { dg-error \"\" }\n+  //following column number is not accurate enough but will make it for now\n+  static const ; // { dg-error \"10: error: declaration does not declare anything\" }\n };"}, {"sha": "e341c341291da3868f5bd7a34a06d726f7fee803", "filename": "gcc/testsuite/g++.dg/parse/error24.C", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror24.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror24.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror24.C?ref=2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea", "patch": "@@ -1,7 +1,8 @@\n+// { dg-options \"-fshow-column -ansi -pedantic-errors -Wno-long-long\" }\n // PR c++/19395\n \n struct A {\n-  typedef int ::X; // { dg-error \"\" }\n+  typedef int ::X; // { dg-error \"17: error: typedef name may not be a nested-name-specifier\" }\n };\n \n "}, {"sha": "b5cb57ee1f045de68f155929acddab39078a9347", "filename": "gcc/testsuite/g++.dg/parse/error25.C", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror25.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror25.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror25.C?ref=2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea", "patch": "@@ -1,4 +1,5 @@\n // { dg-do compile }\n+// { dg-options \"-fshow-column -ansi -pedantic-errors -Wno-long-long\" }\n // Origin: Steven Bosscher <steven at gcc dot gnu dot org>\n // PR c++/17401: ICE with invalid pure specifier\n \n@@ -8,10 +9,10 @@\n class foo\n {\n   virtual void bar1 () = 0;\n-  virtual void bar2 () = __null;  // { dg-error \"invalid pure specifier\" }\n-  virtual void bar3 () = 4;       // { dg-error \"invalid pure specifier\" }\n-  virtual void bar4 () = A::f;    // { dg-error \"invalid pure specifier\" }\n-  virtual void bar5 () = 0l;      // { dg-error \"invalid pure specifier\" }\n-  virtual void bar6 () = 00;      // { dg-error \"invalid pure specifier\" }\n-  virtual void bar7 () = 0x0;     // { dg-error \"invalid pure specifier\" }\n+  virtual void bar2 () = __null;  // { dg-error \"32: error: invalid pure specifier\" }\n+  virtual void bar3 () = 4;       // { dg-error \"27: error: invalid pure specifier\" }\n+  virtual void bar4 () = A::f;    // { dg-error \"27: error: invalid pure specifier\" }\n+  virtual void bar5 () = 0l;      // { dg-error \"28: error: invalid pure specifier\" }\n+  virtual void bar6 () = 00;      // { dg-error \"28: error: invalid pure specifier\" }\n+  virtual void bar7 () = 0x0;     // { dg-error \"29: error: invalid pure specifier\" }\n };"}, {"sha": "81f7ba6d382f7362dc7143356b5ff9713cf5f02c", "filename": "gcc/testsuite/g++.dg/parse/error26.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror26.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror26.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror26.C?ref=2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea", "patch": "@@ -1,12 +1,12 @@\n // PR c++/20148\n-// { dg-options \"\" }\n+// { dg-options \"-fshow-column -ansi -pedantic-errors -Wno-long-long\" }\n \n void foo()\n {\n-  if (({int c[2];})) ; // { dg-error \"\\{\\.\\.\\.\\}\" }\n+  if (({int c[2];})) ; // { dg-error \"7: error: ISO C.. forbids|20: error: could not convert\" }\n }\n \n void bar()\n {\n-  if (({})); // { dg-error \"\\{\\.\\.\\.\\}\" }\n+  if (({})); // { dg-error \"7: error: ISO C.. forbids|11: error: could not convert\" }\n }"}, {"sha": "f1fd5376e5972e65c4bcdf638b07d65b6bd3e920", "filename": "gcc/testsuite/g++.dg/parse/error27.C", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror27.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror27.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror27.C?ref=2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea", "patch": "@@ -1,7 +1,8 @@\n+// { dg-options \"-fshow-column -ansi -pedantic-errors -Wno-long-long\" }\n // PR c++/20152\n \n-struct KrSelectionMode {  virtual void init() = 0; }; // { dg-error \"previous definition\" }\n-struct KrKDESelectionMode : public KrSelectionMode { void init() { } }; // { dg-error \"previous definition\" }\n-struct KrSelectionMode {  virtual void init() = 0; }; // { dg-error \"\" }\n-struct KrKDESelectionMode : public KrSelectionMode { void init() { } }; // { dg-error \"\" }\n+struct KrSelectionMode {  virtual void init() = 0; }; // { dg-error \"24: error: previous definition of 'struct KrSelectionMode'\" }\n+struct KrKDESelectionMode : public KrSelectionMode { void init() { } }; // { dg-error \"52: error: previous definition of 'struct KrKDESelectionMode'\" }\n+struct KrSelectionMode {  virtual void init() = 0; }; // { dg-error \"8: error: redefinition of 'struct KrSelectionMode'\" }\n+struct KrKDESelectionMode : public KrSelectionMode { void init() { } }; // { dg-error \"8: error: redefinition of 'struct KrKDESelectionMode'\" }\n KrKDESelectionMode krKDESelectionMode;"}, {"sha": "fd202a107672cb6b8527d3c1e9b58582c686d783", "filename": "gcc/testsuite/g++.dg/parse/error28.C", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror28.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror28.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror28.C?ref=2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea", "patch": "@@ -1,10 +1,11 @@\n+// { dg-options \"-fshow-column -ansi -pedantic-errors -Wno-long-long\" }\n // PR c++/21908\n \n struct virt { virt () {} virt (int i) {} };\n-struct der : public virtual virt { // { dg-error \"der\" }\n-  der (int i) : virt(i) {} // { dg-error \"der\" }\n+struct der : public virtual virt { // { dg-error \"34: note:                 der::der\" }\n+  der (int i) : virt(i) {} // { dg-error \"13: note: candidates are: der\" }\n };\n struct top : public der { \n-  // { dg-error \"der\\\\(\\\\)\" \"\" { target *-*-* } 9 } \n   top () {} // { dg-bogus \"der\\\\(const\" }\n };\n+// { dg-error \"10: error: no matching function for call to 'der\" \"\" { target *-*-* } 9 }"}, {"sha": "fcd091b0b6509c20256f8473b5b7653de982288b", "filename": "gcc/testsuite/g++.dg/parse/error29.C", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror29.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror29.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror29.C?ref=2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea", "patch": "@@ -1,3 +1,4 @@\n+// { dg-options \"-fshow-column -ansi -pedantic-errors -Wno-long-long\" }\n // PR c++/25637\n \n struct A { \n@@ -6,7 +7,7 @@ struct A {\n   void operator delete(void *);\n };\n struct B { \n-  friend void A::foo() {} // { dg-error \"define\" }\n-  friend void A::operator delete(void*) {} // { dg-error \"define\" }\n-  friend A::A() {} // { dg-error \"define\" }\n+  friend void A::foo() {} // { dg-error \"22: error: cannot define member function 'A::foo' within 'B'\" }\n+  friend void A::operator delete(void*) {} // { dg-error \"39: error: cannot define member function 'A::operator delete' within 'B'\" }\n+  friend A::A() {} // { dg-error \"15: error: cannot define member function 'A::A' within 'B'\" }\n };"}, {"sha": "1f337e91cde4ac90a8ce95c922602f77db0afeff", "filename": "gcc/testsuite/g++.dg/parse/error3.C", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror3.C?ref=2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea", "patch": "@@ -1,6 +1,19 @@\n+// { dg-options \"-fshow-column\" }\n // PR c++/10779\n \n static void InstantiateConstraint(const float&, unsigned,\n-                                  void(*AddFunction)(const TYPE&,bool&, // { dg-error \"\" }\n+                                  void(*AddFunction)(const TYPE&,bool&,\n                                                      char*, char*,\n-                                                     unsigned*)); // { dg-error \"\" }\n+                                                     unsigned*));\n+// { dg-error \"64: error: expected ',' or '...' before '&' token\" \"\" { target *-*-* }  { 5 } }\n+\n+/// in the coming test, the column information is broken as it points to\n+//  the end of the declaration instead of pointing to the begining of the\n+//  'TYPE' identifier. This is due to the warning being generated by the\n+//  declaration groking code (gcc/cp/decl.c) and not the parser. So in that\n+//  code, the exact token location information is lost as the declaration\n+//  groking code manipulates TREEs only. The token location used is then\n+//  the global one that is not accurate enough. Anyway, let's say it is\n+//  good enough for now, until we find a way to propagate token location to\n+//  code paths that manipulate TREEs only.\n+// { dg-error \"64: error: ISO C\\\\+\\\\+ forbids declaration of 'TYPE' with no type\" \"\" { target *-*-* } { 7 } }"}, {"sha": "5c52d1ee67a706ddec09f2595f3966141a8fbe2b", "filename": "gcc/testsuite/g++.dg/parse/error30.C", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror30.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror30.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror30.C?ref=2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea", "patch": "@@ -1,11 +1,12 @@\n // PR c++/30854\n // { dg-do compile }\n+// { dg-options \"-fshow-column -ansi -pedantic-errors -Wno-long-long\" }\n \n struct A\n {\n   A();\n   A(int);\n };\n \n-A a = -A();\t// { dg-error \"no match for.*operator-.*in.*-A\\\\(\\\\)\" }\n-A b = -A(5);\t// { dg-error \"no match for.*operator-.*in.*-A\\\\(5\\\\)\" }\n+A a = -A();\t// { dg-error \"10: error: no match for.*operator-.*in.*-A\\\\(\\\\)\" }\n+A b = -A(5);\t// { dg-error \"11: error: no match for.*operator-.*in.*-A\\\\(5\\\\)\" }"}, {"sha": "d354cc3e0dda8433cab6c54900802b06bf587a5d", "filename": "gcc/testsuite/g++.dg/parse/error31.C", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror31.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror31.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror31.C?ref=2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea", "patch": "@@ -1,10 +1,12 @@\n+// { dg-options \"-fshow-column -ansi -pedantic-errors -Wno-long-long\" }\n // PR c++/32190\n \n template<typename T> class foo{ };\n \n int main() {\n     foo<int> i;\n-    foo<foo<int> j; // { dg-error \"template argument\" }\n+    // this column number is not accurate yet, but that will make it for now.\n+    foo<foo<int> j; // { dg-error \"18: error: template argument 1 is invalid\" }\n     int k;\n     int l;\n     foo<int> m;"}, {"sha": "790e5c9a40b6d6097b0f5dc396147a5f431bbded", "filename": "gcc/testsuite/g++.dg/parse/error4.C", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror4.C?ref=2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea", "patch": "@@ -1,7 +1,10 @@\n // PR c++/12160\n+// { dg-options \"-fshow-column\" }\n \n-struct X { \n-  virtual void f(int, \n-\t\t itn,        // { dg-error \"declared\" }\n+struct X {\n+  virtual void f(int,\n+\t\t itn,\n \t\t int);\n-}; \n+};\n+\n+// { dg-error \"4: error: 'itn' has not been declared\" \"\" { target *-*-* } { 6 } }"}, {"sha": "8c9a039ac3ce65b15caf99af0d4bf0c70d2eeb60", "filename": "gcc/testsuite/g++.dg/parse/error5.C", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror5.C?ref=2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea", "patch": "@@ -1,4 +1,19 @@\n // PR c++/13269\n+// { dg-options \"-fshow-column\" }\n \n-class Foo { int foo() return 0; } }; // { dg-error \"\" }\n+class Foo { int foo() return 0; } };\n+\n+// { dg-error \"30: error: expected identifier before numeric constant\" \"\" { target *-*-* } { 4 } }\n+\n+// { dg-error \"23: error: named return values are no longer supported\" \"\" { target *-*-* } { 4 } }\n+\n+// the column number info of this error output is still wrong because the error\n+// message has been generated by cp_parser_error() which does not\n+// necessarily allow accurate column number display. At some point, we will\n+// need make cp_parser_error() report more accurate column numbers.\n+// { dg-error \"30: error: expected '\\{' at end of input\" \"\" { target *-*-* } { 4 } }\n+\n+// { dg-error \"35: error: expected unqualified-id before '\\}' token\" \"\" {target *-*-*  } { 4 } }\n+\n+// { dg-error \"35: error: expected declaration before '\\}' token\" \"\" {target *-*-*  } { 4 } }\n "}, {"sha": "cd1b6b8cd33850c16cd00a7d2c235d2ed20a83a2", "filename": "gcc/testsuite/g++.dg/parse/error6.C", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror6.C?ref=2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea", "patch": "@@ -1,6 +1,11 @@\n // PR c++/10603\n+// { dg-options \"-fshow-column\" }\n \n-int f(int not) { // { dg-error \"!\" }\n-  return 1-not; // { dg-error \"\" }\n+int f(int not) {\n+  return 1-not;\n } \n \n+// { dg-error \"11: error: expected ',' or '...' before '!' token\" \"\" { target *-*-* } { 4 } }\n+\n+// { dg-error \"15: error: expected primary\\\\-expression before ';' token\" \"\" { target *-*-* }  { 5 } }\n+"}, {"sha": "f71c9aa9fa0fdcccbf7022254dc6511e8aea6a5b", "filename": "gcc/testsuite/g++.dg/parse/error7.C", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror7.C?ref=2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea", "patch": "@@ -1,4 +1,7 @@\n // PR c++/12827\n+// { dg-options \"-fshow-column\" }\n \n void f(int x\n-       int y); // { dg-error \",\" }\n+       int y);\n+\n+// { dg-error \"8: error: expected ',' or '...' before 'int'\" \"\" { target *-*-* } { 5 } }"}, {"sha": "a399cfe63f777bdd02aa10282551997d02642355", "filename": "gcc/testsuite/g++.dg/parse/error8.C", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror8.C?ref=2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea", "patch": "@@ -1,4 +1,10 @@\n // PR c++/13438\n+// {  dg-options \"-fshow-column\" }\n \n-struct A { friend typename struct B; };  // { dg-error \"\" }\n-  \n+struct A { friend typename struct B; };\n+\n+\n+// { dg-error \"19: error: using 'typename' outside of template\" \"\" { target *-*-* } { 4 } }\n+// { dg-error \"28: error: expected nested-name-specifier before 'struct'\" \"\" { target *-*-* } { 4 } }\n+// { dg-error \"35: error: multiple types in one declaration\" \"\" { target *-*-* } { 4 } }\n+// { dg-error \"12: error: friend declaration does not name a class or function\" \"\" { target *-*-* } { 4 } }"}, {"sha": "c1be6979b47d7f96a044168dda09c7bd9e6d694e", "filename": "gcc/testsuite/g++.dg/parse/error9.C", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror9.C?ref=2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea", "patch": "@@ -1,5 +1,9 @@\n // PR c++/12613\n-// { dg-options \"\" }\n+// { dg-options \"-fshow-column\" }\n \n enum { FOO = 1, BAR = 2 };\n-int a[] = { FOO: 1, BAR: 2 }; // { dg-error \"\" }\n+int a[] = { FOO: 1, BAR: 2 };\n+\n+// the following 2 column locations are still not accurate enough\n+// { dg-error \"28: error: name 'FOO' used in a GNU-style designated initializer for an array\" \"\" { target *-*-* }  { 5 } }\n+// { dg-error \"28: error: name 'BAR' used in a GNU-style designated initializer for an array\" \"\" { target *-*-* }  { 5 } }"}, {"sha": "7fe07a2df0ed93e2d92c7e5c100d94c6dd2c54c3", "filename": "gcc/testsuite/g++.old-deja/g++.pt/niklas01a.C", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fniklas01a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fniklas01a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fniklas01a.C?ref=2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea", "patch": "@@ -1,8 +1,9 @@\n // { dg-do assemble  }\n+// { dg-options \"-fshow-column\" }\n \n struct A { // { dg-error \"\" } forward declaration\n-  friend struct B : A {\t\t// { dg-error \"\" } \n+  friend struct B : A {\t\t// { dg-error \"invalid use of incomplete type 'struct A'\" }\n     int x;\n-  };\t// { dg-error \"\" } class definition cannot be a friend\n+  };\t// { dg-error \"class definition may not be declared a friend\" \"\"  { target *-*-* } { 5 } }\n   int y;\n };"}, {"sha": "7ca5b7397818d77df8c6f855776f1666389323f1", "filename": "gcc/testsuite/lib/g++.exp", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Flib%2Fg%2B%2B.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea/gcc%2Ftestsuite%2Flib%2Fg%2B%2B.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fg%2B%2B.exp?ref=2b7a3abf6e2488a0b7e4f1bad6b1da3616d60eea", "patch": "@@ -273,7 +273,6 @@ proc g++_target_compile { source dest type options } {\n     }\n \n     lappend options \"additional_flags=[libio_include_flags]\"\n-    lappend options \"additional_flags=-fno-show-column\"\n     lappend options \"compiler=$GXX_UNDER_TEST\"\n \n     set options [concat $gpp_compile_options $options]"}]}