{"sha": "4f4a855d82a889cebcfca150a7a43909bcb6a346", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGY0YTg1NWQ4MmE4ODljZWJjZmNhMTUwYTdhNDM5MDliY2I2YTM0Ng==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2019-01-18T19:04:36Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-01-18T19:04:36Z"}, "message": "libgo: update to Go1.12beta2\n    \n    Reviewed-on: https://go-review.googlesource.com/c/158019\n\ngotools/:\n\t* Makefile.am (go_cmd_vet_files): Update for Go1.12beta2 release.\n\t(GOTOOLS_TEST_TIMEOUT): Increase to 600.\n\t(check-runtime): Export LD_LIBRARY_PATH before computing GOARCH\n\tand GOOS.\n\t(check-vet): Copy golang.org/x/tools into check-vet-dir.\n\t* Makefile.in: Regenerate.\n\ngcc/testsuite/:\n\t* go.go-torture/execute/names-1.go: Stop using debug/xcoff, which\n\tis no longer externally visible.\n\nFrom-SVN: r268084", "tree": {"sha": "f12bae0781920fa34669fe30b6f4615a86d9fb80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f12bae0781920fa34669fe30b6f4615a86d9fb80"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f4a855d82a889cebcfca150a7a43909bcb6a346", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f4a855d82a889cebcfca150a7a43909bcb6a346", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f4a855d82a889cebcfca150a7a43909bcb6a346", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f4a855d82a889cebcfca150a7a43909bcb6a346/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "225220d668dafb8262db7012bced688acbe63b33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/225220d668dafb8262db7012bced688acbe63b33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/225220d668dafb8262db7012bced688acbe63b33"}], "stats": {"total": 116614, "additions": 71628, "deletions": 44986}, "files": [{"sha": "3c1d270cb5c93b9dc9e9a0223cbbd151b926a13e", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -1,4 +1,4 @@\n-d16e9181a760796802c067730bb030b92b63fb2c\n+c76ba3014e42cc6adc3d43709bba28c5ad7a6ba2\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "1c0de25df4804aca7216016346f483c7e4011391", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -1,3 +1,8 @@\n+2019-01-18  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* go.go-torture/execute/names-1.go: Stop using debug/xcoff, which\n+\tis no longer externally visible.\n+\n 2019-01-18  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/86926"}, {"sha": "88399f36cee1f2d26a00c78f7afd358747201888", "filename": "gcc/testsuite/go.go-torture/execute/names-1.go", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fnames-1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fnames-1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fnames-1.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -7,9 +7,9 @@ import (\n \t\"debug/elf\"\n \t\"debug/macho\"\n \t\"debug/pe\"\n-\t\"debug/xcoff\"\n \t\"fmt\"\n \t\"os\"\n+\t\"runtime\"\n \t\"strings\"\n )\n \n@@ -61,6 +61,12 @@ func Function3(out *bytes.Buffer) {\n }\n \n func main() {\n+\tif runtime.GOOS == \"aix\" {\n+\t\t// Not supported on AIX until there is an externally\n+\t\t// visible version of internal/xcoff.\n+\t\treturn\n+\t}\n+\n \tvar b bytes.Buffer\n \tFunction1(&b)\n \tFunction2(&b)\n@@ -95,10 +101,6 @@ func checkFile(f *os.File) {\n \t\tfor _, psym := range pf.Symbols {\n \t\t\tsyms = append(syms, psym.Name)\n \t\t}\n-\t} else if xf, err := xcoff.NewFile(f); err == nil {\n-\t\tfor _, xsym := range xf.Symbols {\n-\t\t\tsyms = append(syms, xsym.Name)\n-\t\t}\n \t} else {\n \t\tfmt.Println(\"checksyms: could not parse executable\")\n \t\tfmt.Println(\"UNSUPPORTED: checksyms\")"}, {"sha": "ff5020ac2a1203b99833117137a2687daffe6799", "filename": "gotools/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/gotools%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/gotools%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gotools%2FChangeLog?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -1,3 +1,12 @@\n+2019-01-18  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* Makefile.am (go_cmd_vet_files): Update for Go1.12beta2 release.\n+\t(GOTOOLS_TEST_TIMEOUT): Increase to 600.\n+\t(check-runtime): Export LD_LIBRARY_PATH before computing GOARCH\n+\tand GOOS.\n+\t(check-vet): Copy golang.org/x/tools into check-vet-dir.\n+\t* Makefile.in: Regenerate.\n+\n 2018-10-31  Joseph Myers  <joseph@codesourcery.com>\n \n \tPR bootstrap/82856"}, {"sha": "ad0ad24e206497762d1969eb1925db57baece002", "filename": "gotools/Makefile.am", "status": "modified", "additions": 5, "deletions": 26, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/gotools%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/gotools%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gotools%2FMakefile.am?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -70,31 +70,8 @@ go_cmd_cgo_files = \\\n \t$(cmdsrcdir)/cgo/util.go\n \n go_cmd_vet_files = \\\n-\t$(cmdsrcdir)/vet/asmdecl.go \\\n-\t$(cmdsrcdir)/vet/assign.go \\\n-\t$(cmdsrcdir)/vet/atomic.go \\\n-\t$(cmdsrcdir)/vet/bool.go \\\n-\t$(cmdsrcdir)/vet/buildtag.go \\\n-\t$(cmdsrcdir)/vet/cgo.go \\\n-\t$(cmdsrcdir)/vet/composite.go \\\n-\t$(cmdsrcdir)/vet/copylock.go \\\n-\t$(cmdsrcdir)/vet/deadcode.go \\\n-\t$(cmdsrcdir)/vet/dead.go \\\n \t$(cmdsrcdir)/vet/doc.go \\\n-\t$(cmdsrcdir)/vet/httpresponse.go \\\n-\t$(cmdsrcdir)/vet/lostcancel.go \\\n-\t$(cmdsrcdir)/vet/main.go \\\n-\t$(cmdsrcdir)/vet/method.go \\\n-\t$(cmdsrcdir)/vet/nilfunc.go \\\n-\t$(cmdsrcdir)/vet/print.go \\\n-\t$(cmdsrcdir)/vet/rangeloop.go \\\n-\t$(cmdsrcdir)/vet/shadow.go \\\n-\t$(cmdsrcdir)/vet/shift.go \\\n-\t$(cmdsrcdir)/vet/structtag.go \\\n-\t$(cmdsrcdir)/vet/tests.go \\\n-\t$(cmdsrcdir)/vet/types.go \\\n-\t$(cmdsrcdir)/vet/unsafeptr.go \\\n-\t$(cmdsrcdir)/vet/unused.go\n+\t$(cmdsrcdir)/vet/main.go\n \n go_cmd_buildid_files = \\\n \t$(cmdsrcdir)/buildid/buildid.go \\\n@@ -163,7 +140,7 @@ uninstall-local:\n GOTESTFLAGS =\n \n # Number of seconds before tests time out.\n-GOTOOLS_TEST_TIMEOUT = 480\n+GOTOOLS_TEST_TIMEOUT = 600\n \n # Run tests using the go tool, and frob the output to look like that\n # generated by DejaGNU.  The main output of this is two files:\n@@ -256,6 +233,7 @@ check-runtime: go$(EXEEXT) $(noinst_PROGRAMS) check-head check-gccgo check-gcc\n \t$(MKDIR_P) check-runtime-dir\n \t@abs_libgodir=`cd $(libgodir) && $(PWD_COMMAND)`; \\\n \tLD_LIBRARY_PATH=`echo $${abs_libgodir}/.libs:$${LD_LIBRARY_PATH} | sed 's,::*,:,g;s,^:*,,;s,:*$$,,'`; \\\n+\texport LD_LIBRARY_PATH; \\\n \tGOARCH=`$(abs_builddir)/go$(EXEEXT) env GOARCH`; \\\n \tGOOS=`$(abs_builddir)/go$(EXEEXT) env GOOS`; \\\n \tfiles=`$(SHELL) $(libgosrcdir)/../match.sh --goarch=$${GOARCH} --goos=$${GOOS} --srcdir=$(libgosrcdir)/runtime --extrafiles=\"$(libgodir)/runtime_sysinfo.go $(libgodir)/sigtab.go\" --tag=libffi`; \\\n@@ -299,10 +277,11 @@ check-carchive-test: go$(EXEEXT) $(noinst_PROGRAMS) check-head check-gccgo check\n # check-vet runs `go test cmd/vet` in our environment.\n check-vet: go$(EXEEXT) $(noinst_PROGRAMS) check-head check-gccgo check-gcc\n \trm -rf check-vet-dir cmd_vet-testlog\n-\t$(MKDIR_P) check-vet-dir/src/cmd/internal\n+\t$(MKDIR_P) check-vet-dir/src/cmd/internal check-vet-dir/src/cmd/vendor/golang.org/x\n \tcp -r $(cmdsrcdir)/vet check-vet-dir/src/cmd/\n \tcp -r $(cmdsrcdir)/internal/objabi check-vet-dir/src/cmd/internal\n \tcp $(libgodir)/objabi.go check-vet-dir/src/cmd/internal/objabi/\n+\tcp -r $(libgosrcdir)/golang.org/x/tools check-vet-dir/src/cmd/vendor/golang.org/x/\n \t@abs_libgodir=`cd $(libgodir) && $(PWD_COMMAND)`; \\\n \tabs_checkdir=`cd check-vet-dir && $(PWD_COMMAND)`; \\\n \techo \"cd check-vet-dir/src/cmd/vet && $(ECHO_ENV) GOPATH=$${abs_checkdir} $(abs_builddir)/go$(EXEEXT) test -test.short -test.timeout=$(GOTOOLS_TEST_TIMEOUT)s -test.v\" > cmd_vet-testlog"}, {"sha": "47235df52ae989ba2e72ea3f157a028b858b4f21", "filename": "gotools/Makefile.in", "status": "modified", "additions": 5, "deletions": 26, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/gotools%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/gotools%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gotools%2FMakefile.in?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -373,31 +373,8 @@ go_cmd_cgo_files = \\\n \t$(cmdsrcdir)/cgo/util.go\n \n go_cmd_vet_files = \\\n-\t$(cmdsrcdir)/vet/asmdecl.go \\\n-\t$(cmdsrcdir)/vet/assign.go \\\n-\t$(cmdsrcdir)/vet/atomic.go \\\n-\t$(cmdsrcdir)/vet/bool.go \\\n-\t$(cmdsrcdir)/vet/buildtag.go \\\n-\t$(cmdsrcdir)/vet/cgo.go \\\n-\t$(cmdsrcdir)/vet/composite.go \\\n-\t$(cmdsrcdir)/vet/copylock.go \\\n-\t$(cmdsrcdir)/vet/deadcode.go \\\n-\t$(cmdsrcdir)/vet/dead.go \\\n \t$(cmdsrcdir)/vet/doc.go \\\n-\t$(cmdsrcdir)/vet/httpresponse.go \\\n-\t$(cmdsrcdir)/vet/lostcancel.go \\\n-\t$(cmdsrcdir)/vet/main.go \\\n-\t$(cmdsrcdir)/vet/method.go \\\n-\t$(cmdsrcdir)/vet/nilfunc.go \\\n-\t$(cmdsrcdir)/vet/print.go \\\n-\t$(cmdsrcdir)/vet/rangeloop.go \\\n-\t$(cmdsrcdir)/vet/shadow.go \\\n-\t$(cmdsrcdir)/vet/shift.go \\\n-\t$(cmdsrcdir)/vet/structtag.go \\\n-\t$(cmdsrcdir)/vet/tests.go \\\n-\t$(cmdsrcdir)/vet/types.go \\\n-\t$(cmdsrcdir)/vet/unsafeptr.go \\\n-\t$(cmdsrcdir)/vet/unused.go\n+\t$(cmdsrcdir)/vet/main.go\n \n go_cmd_buildid_files = \\\n \t$(cmdsrcdir)/buildid/buildid.go \\\n@@ -726,8 +703,8 @@ distclean-generic:\n maintainer-clean-generic:\n \t@echo \"This command is intended for maintainers to use\"\n \t@echo \"it deletes files that may require special tools to rebuild.\"\n-@NATIVE_FALSE@install-exec-local:\n @NATIVE_FALSE@uninstall-local:\n+@NATIVE_FALSE@install-exec-local:\n clean: clean-am\n \n clean-am: clean-binPROGRAMS clean-generic clean-noinstPROGRAMS \\\n@@ -927,6 +904,7 @@ mostlyclean-local:\n @NATIVE_TRUE@\t$(MKDIR_P) check-runtime-dir\n @NATIVE_TRUE@\t@abs_libgodir=`cd $(libgodir) && $(PWD_COMMAND)`; \\\n @NATIVE_TRUE@\tLD_LIBRARY_PATH=`echo $${abs_libgodir}/.libs:$${LD_LIBRARY_PATH} | sed 's,::*,:,g;s,^:*,,;s,:*$$,,'`; \\\n+@NATIVE_TRUE@\texport LD_LIBRARY_PATH; \\\n @NATIVE_TRUE@\tGOARCH=`$(abs_builddir)/go$(EXEEXT) env GOARCH`; \\\n @NATIVE_TRUE@\tGOOS=`$(abs_builddir)/go$(EXEEXT) env GOOS`; \\\n @NATIVE_TRUE@\tfiles=`$(SHELL) $(libgosrcdir)/../match.sh --goarch=$${GOARCH} --goos=$${GOOS} --srcdir=$(libgosrcdir)/runtime --extrafiles=\"$(libgodir)/runtime_sysinfo.go $(libgodir)/sigtab.go\" --tag=libffi`; \\\n@@ -970,10 +948,11 @@ mostlyclean-local:\n # check-vet runs `go test cmd/vet` in our environment.\n @NATIVE_TRUE@check-vet: go$(EXEEXT) $(noinst_PROGRAMS) check-head check-gccgo check-gcc\n @NATIVE_TRUE@\trm -rf check-vet-dir cmd_vet-testlog\n-@NATIVE_TRUE@\t$(MKDIR_P) check-vet-dir/src/cmd/internal\n+@NATIVE_TRUE@\t$(MKDIR_P) check-vet-dir/src/cmd/internal check-vet-dir/src/cmd/vendor/golang.org/x\n @NATIVE_TRUE@\tcp -r $(cmdsrcdir)/vet check-vet-dir/src/cmd/\n @NATIVE_TRUE@\tcp -r $(cmdsrcdir)/internal/objabi check-vet-dir/src/cmd/internal\n @NATIVE_TRUE@\tcp $(libgodir)/objabi.go check-vet-dir/src/cmd/internal/objabi/\n+@NATIVE_TRUE@\tcp -r $(libgosrcdir)/golang.org/x/tools check-vet-dir/src/cmd/vendor/golang.org/x/\n @NATIVE_TRUE@\t@abs_libgodir=`cd $(libgodir) && $(PWD_COMMAND)`; \\\n @NATIVE_TRUE@\tabs_checkdir=`cd check-vet-dir && $(PWD_COMMAND)`; \\\n @NATIVE_TRUE@\techo \"cd check-vet-dir/src/cmd/vet && $(ECHO_ENV) GOPATH=$${abs_checkdir} $(abs_builddir)/go$(EXEEXT) test -test.short -test.timeout=$(GOTOOLS_TEST_TIMEOUT)s -test.v\" > cmd_vet-testlog"}, {"sha": "4674467244f42ddb00e71ea84ff58f30cd4342e5", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -1,4 +1,4 @@\n-26957168c4c0cdcc7ca4f0b19d0eb19474d224ac\n+4b3f04c63b5b1a1bbc4dfd71c34341ea4e935115\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "2ee4a28a53c72fdd3c4674f773909080bd08d3b0", "filename": "libgo/Makefile.am", "status": "modified", "additions": 24, "deletions": 32, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -217,8 +217,7 @@ toolexeclibgodebug_DATA = \\\n \tdebug/gosym.gox \\\n \tdebug/macho.gox \\\n \tdebug/pe.gox \\\n-\tdebug/plan9obj.gox \\\n-\tdebug/xcoff.gox\n+\tdebug/plan9obj.gox\n \n toolexeclibgoencodingdir = $(toolexeclibgodir)/encoding\n \n@@ -394,8 +393,8 @@ toolexeclibgounicode_DATA = \\\n # internal packages nothing will explicitly depend on them.\n # Force them to be built.\n noinst_DATA = \\\n-\tgolang_org/x/net/internal/nettest.gox \\\n-\tgolang_org/x/net/nettest.gox \\\n+\tinternal/x/net/internal/nettest.gox \\\n+\tinternal/x/net/nettest.gox \\\n \tinternal/testenv.gox \\\n \tinternal/trace.gox \\\n \tnet/internal/socktest.gox \\\n@@ -536,7 +535,7 @@ cpugen.go: s-cpu; @true\n s-cpu: Makefile\n \trm -f cpugen.go.tmp\n \techo \"package cpu\" > cpugen.go.tmp\n-\techo \"const CacheLineSize = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) cachelinesize`\" >> cpugen.go.tmp\n+\techo \"const CacheLinePadSize = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) cachelinesize`\" >> cpugen.go.tmp\n \t$(SHELL) $(srcdir)/mvifdiff.sh cpugen.go.tmp cpugen.go\n \t$(STAMP) $@\n \n@@ -554,7 +553,7 @@ s-objabi: Makefile\n \techo 'const defaultGOARCH = runtime.GOARCH' >> objabi.go.tmp\n \techo 'const defaultGO_EXTLINK_ENABLED = ``' >> objabi.go.tmp\n \techo 'const version = `'`cat $(srcdir)/VERSION | sed 1q`' '`$(GOC) --version | sed 1q`'`' >> objabi.go.tmp\n-\techo 'const stackGuardMultiplier = 1' >> objabi.go.tmp\n+\techo 'const stackGuardMultiplierDefault = 1' >> objabi.go.tmp\n \techo 'const goexperiment = ``' >> objabi.go.tmp\n \t$(SHELL) $(srcdir)/mvifdiff.sh objabi.go.tmp objabi.go\n \t$(STAMP) $@\n@@ -715,16 +714,14 @@ PACKAGES = $(shell cat $(srcdir)/libgo-packages.txt)\n \n libgo_go_objs = \\\n \t$(addsuffix .lo,$(PACKAGES)) \\\n-\tbytes/index.lo \\\n \tinternal/bytealg/bytealg.lo \\\n \treflect/makefunc_ffi_c.lo \\\n-\tstrings/index.lo \\\n \t$(syscall_lib_clone_lo) \\\n \tsyscall/errno.lo \\\n \tsyscall/signame.lo \\\n \tsyscall/wait.lo \\\n-\t$(golang_org_x_net_lif_lo) \\\n-\t$(golang_org_x_net_route_lo) \\\n+\t$(internal_x_net_lif_lo) \\\n+\t$(internal_x_net_route_lo) \\\n \tlog/syslog/syslog_c.lo \\\n \t$(os_lib_inotify_lo) \\\n \truntime/internal/atomic_c.lo \\\n@@ -807,7 +804,7 @@ BUILDDEPS = \\\n BUILDPACKAGE = \\\n \t$(MKDIR_P) $(@D); \\\n \tfiles=`echo $^ | sed -e 's/[^ ]*\\.gox//g' -e 's/[^ ]*\\.dep//'`; \\\n-\t$(LTGOCOMPILE) -I . -c -fgo-pkgpath=`echo $@ | sed -e 's/.lo$$//' -e 's|golang_org|vendor/golang_org|'` $($(subst -,_,$(subst .,_,$(subst /,_,$@)))_GOCFLAGS) -o $@ $$files\n+\t$(LTGOCOMPILE) -I . -c -fgo-pkgpath=`echo $@ | sed -e 's/.lo$$//'` $($(subst -,_,$(subst .,_,$(subst /,_,$@)))_GOCFLAGS) -o $@ $$files\n \n # How to build a .gox file from a .lo file.\n # Matching .o file can either be in the same directory as the .lo (non-PIC\n@@ -990,6 +987,7 @@ extra_check_libs_cmd_go_internal_cache = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_generate = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_get = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_load = $(abs_builddir)/libgotool.a\n+extra_check_libs_cmd_go_internal_lockedfile = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_imports = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_modconv = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_modfetch = $(abs_builddir)/libgotool.a\n@@ -1007,13 +1005,7 @@ extra_check_libs_cmd_vet_internal_cfg = $(abs_builddir)/libgotool.a\n # FIXME: The following C files may as well move to the runtime\n # directory and be treated like other C files.\n \n-# Use C code to speed up {bytes,strings}.IndexByte and friends.\n-bytes/index.lo: go/bytes/indexbyte.c runtime.inc\n-\t@$(MKDIR_P) bytes\n-\t$(LTCOMPILE) -c -o $@ $(srcdir)/go/bytes/indexbyte.c\n-strings/index.lo: go/strings/indexbyte.c runtime.inc\n-\t@$(MKDIR_P) strings\n-\t$(LTCOMPILE) -c -o $@ $(srcdir)/go/strings/indexbyte.c\n+# Use C code to speed up internal/bytealg.IndexByte and friends.\n internal/bytealg/bytealg.lo: go/internal/bytealg/bytealg.c runtime.inc\n \t@$(MKDIR_P) internal/bytealg\n \t$(LTCOMPILE) -c -o $@ $(srcdir)/go/internal/bytealg/bytealg.c\n@@ -1070,34 +1062,34 @@ endif\n \n if LIBGO_IS_BSD\n \n-# Build golang_org/x/net/route only on BSD systems.\n+# Build internal/x/net/route only on BSD systems.\n \n-$(eval $(call PACKAGE_template,golang_org/x/net/route))\n+$(eval $(call PACKAGE_template,internal/x/net/route))\n \n-golang_org_x_net_route_lo = \\\n-\tgolang_org/x/net/route.lo\n-golang_org_x_net_route_check = \\\n-\tgolang_org/x/net/route/check\n+internal_x_net_route_lo = \\\n+\tinternal/x/net/route.lo\n+internal_x_net_route_check = \\\n+\tinternal/x/net/route/check\n \n endif\n \n if LIBGO_IS_SOLARIS\n \n-# Build golang_org/x/net/lif only on Solaris systems.\n+# Build internal/x/net/lif only on Solaris systems.\n \n-$(eval $(call PACKAGE_template,golang_org/x/net/lif))\n+$(eval $(call PACKAGE_template,internal/x/net/lif))\n \n-golang_org_x_net_lif_lo = \\\n-\tgolang_org/x/net/lif.lo\n-golang_org_x_net_lif_check = \\\n-\tgolang_org/x/net/lif/check\n+internal_x_net_lif_lo = \\\n+\tinternal/x/net/lif.lo\n+internal_x_net_lif_check = \\\n+\tinternal_org/x/net/lif/check\n \n endif\n \n TPACKAGES = $(shell cat $(srcdir)/check-packages.txt)\n TEST_PACKAGES = $(addsuffix /check,$(TPACKAGES)) \\\n-\t$(golang_org_x_net_lif_check) \\\n-\t$(golang_org_x_net_route_check)\n+\t$(internal_x_net_lif_check) \\\n+\t$(internal_x_net_route_check)\n \n check: check-tail\n check-recursive: check-head"}, {"sha": "1695dd0faec1fb6638e34980e595b91f04bd3404", "filename": "libgo/Makefile.in", "status": "modified", "additions": 28, "deletions": 36, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -215,11 +215,11 @@ am_libgotool_a_OBJECTS =\n libgotool_a_OBJECTS = $(am_libgotool_a_OBJECTS)\n LTLIBRARIES = $(toolexeclib_LTLIBRARIES)\n @LIBGO_IS_LINUX_TRUE@am__DEPENDENCIES_1 = syscall/clone_linux.lo\n-am__DEPENDENCIES_2 = $(addsuffix .lo,$(PACKAGES)) bytes/index.lo \\\n+am__DEPENDENCIES_2 = $(addsuffix .lo,$(PACKAGES)) \\\n \tinternal/bytealg/bytealg.lo reflect/makefunc_ffi_c.lo \\\n-\tstrings/index.lo $(am__DEPENDENCIES_1) syscall/errno.lo \\\n-\tsyscall/signame.lo syscall/wait.lo $(golang_org_x_net_lif_lo) \\\n-\t$(golang_org_x_net_route_lo) log/syslog/syslog_c.lo \\\n+\t$(am__DEPENDENCIES_1) syscall/errno.lo syscall/signame.lo \\\n+\tsyscall/wait.lo $(internal_x_net_lif_lo) \\\n+\t$(internal_x_net_route_lo) log/syslog/syslog_c.lo \\\n \truntime/internal/atomic_c.lo sync/atomic_c.lo \\\n \tinternal/cpu/cpu_gccgo.lo\n am__DEPENDENCIES_3 =\n@@ -696,8 +696,7 @@ toolexeclibgodebug_DATA = \\\n \tdebug/gosym.gox \\\n \tdebug/macho.gox \\\n \tdebug/pe.gox \\\n-\tdebug/plan9obj.gox \\\n-\tdebug/xcoff.gox\n+\tdebug/plan9obj.gox\n \n toolexeclibgoencodingdir = $(toolexeclibgodir)/encoding\n toolexeclibgoencoding_DATA = \\\n@@ -849,8 +848,8 @@ toolexeclibgounicode_DATA = \\\n # Some packages are only needed for tests, so unlike the other\n # internal packages nothing will explicitly depend on them.\n # Force them to be built.\n-noinst_DATA = golang_org/x/net/internal/nettest.gox \\\n-\tgolang_org/x/net/nettest.gox internal/testenv.gox \\\n+noinst_DATA = internal/x/net/internal/nettest.gox \\\n+\tinternal/x/net/nettest.gox internal/testenv.gox \\\n \tinternal/trace.gox net/internal/socktest.gox \\\n \tos/signal/internal/pty.gox runtime/pprof/internal/profile.gox \\\n \tzdefaultcc.go\n@@ -917,16 +916,14 @@ SYSINFO_FLAGS = \\\n PACKAGES = $(shell cat $(srcdir)/libgo-packages.txt)\n libgo_go_objs = \\\n \t$(addsuffix .lo,$(PACKAGES)) \\\n-\tbytes/index.lo \\\n \tinternal/bytealg/bytealg.lo \\\n \treflect/makefunc_ffi_c.lo \\\n-\tstrings/index.lo \\\n \t$(syscall_lib_clone_lo) \\\n \tsyscall/errno.lo \\\n \tsyscall/signame.lo \\\n \tsyscall/wait.lo \\\n-\t$(golang_org_x_net_lif_lo) \\\n-\t$(golang_org_x_net_route_lo) \\\n+\t$(internal_x_net_lif_lo) \\\n+\t$(internal_x_net_route_lo) \\\n \tlog/syslog/syslog_c.lo \\\n \t$(os_lib_inotify_lo) \\\n \truntime/internal/atomic_c.lo \\\n@@ -991,7 +988,7 @@ BUILDDEPS = \\\n BUILDPACKAGE = \\\n \t$(MKDIR_P) $(@D); \\\n \tfiles=`echo $^ | sed -e 's/[^ ]*\\.gox//g' -e 's/[^ ]*\\.dep//'`; \\\n-\t$(LTGOCOMPILE) -I . -c -fgo-pkgpath=`echo $@ | sed -e 's/.lo$$//' -e 's|golang_org|vendor/golang_org|'` $($(subst -,_,$(subst .,_,$(subst /,_,$@)))_GOCFLAGS) -o $@ $$files\n+\t$(LTGOCOMPILE) -I . -c -fgo-pkgpath=`echo $@ | sed -e 's/.lo$$//'` $($(subst -,_,$(subst .,_,$(subst /,_,$@)))_GOCFLAGS) -o $@ $$files\n \n \n # How to build a .gox file from a .lo file.\n@@ -1105,6 +1102,7 @@ extra_check_libs_cmd_go_internal_cache = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_generate = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_get = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_load = $(abs_builddir)/libgotool.a\n+extra_check_libs_cmd_go_internal_lockedfile = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_imports = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_modconv = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_modfetch = $(abs_builddir)/libgotool.a\n@@ -1123,22 +1121,22 @@ extra_check_libs_cmd_vet_internal_cfg = $(abs_builddir)/libgotool.a\n # Use a build tag, based on a configure check, to cope.\n @HAVE_STAT_TIMESPEC_TRUE@@LIBGO_IS_SOLARIS_TRUE@matchargs_os = --tag=solaristag\n @LIBGO_IS_SOLARIS_FALSE@matchargs_os = \n-@LIBGO_IS_BSD_TRUE@golang_org_x_net_route_lo = \\\n-@LIBGO_IS_BSD_TRUE@\tgolang_org/x/net/route.lo\n+@LIBGO_IS_BSD_TRUE@internal_x_net_route_lo = \\\n+@LIBGO_IS_BSD_TRUE@\tinternal/x/net/route.lo\n \n-@LIBGO_IS_BSD_TRUE@golang_org_x_net_route_check = \\\n-@LIBGO_IS_BSD_TRUE@\tgolang_org/x/net/route/check\n+@LIBGO_IS_BSD_TRUE@internal_x_net_route_check = \\\n+@LIBGO_IS_BSD_TRUE@\tinternal/x/net/route/check\n \n-@LIBGO_IS_SOLARIS_TRUE@golang_org_x_net_lif_lo = \\\n-@LIBGO_IS_SOLARIS_TRUE@\tgolang_org/x/net/lif.lo\n+@LIBGO_IS_SOLARIS_TRUE@internal_x_net_lif_lo = \\\n+@LIBGO_IS_SOLARIS_TRUE@\tinternal/x/net/lif.lo\n \n-@LIBGO_IS_SOLARIS_TRUE@golang_org_x_net_lif_check = \\\n-@LIBGO_IS_SOLARIS_TRUE@\tgolang_org/x/net/lif/check\n+@LIBGO_IS_SOLARIS_TRUE@internal_x_net_lif_check = \\\n+@LIBGO_IS_SOLARIS_TRUE@\tinternal_org/x/net/lif/check\n \n TPACKAGES = $(shell cat $(srcdir)/check-packages.txt)\n TEST_PACKAGES = $(addsuffix /check,$(TPACKAGES)) \\\n-\t$(golang_org_x_net_lif_check) \\\n-\t$(golang_org_x_net_route_check)\n+\t$(internal_x_net_lif_check) \\\n+\t$(internal_x_net_route_check)\n \n MOSTLYCLEANFILES = \\\n \ts-runtime_sysinfo s-sigtab s-runtime-inc s-zstdpkglist \\\n@@ -2635,7 +2633,7 @@ cpugen.go: s-cpu; @true\n s-cpu: Makefile\n \trm -f cpugen.go.tmp\n \techo \"package cpu\" > cpugen.go.tmp\n-\techo \"const CacheLineSize = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) cachelinesize`\" >> cpugen.go.tmp\n+\techo \"const CacheLinePadSize = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) cachelinesize`\" >> cpugen.go.tmp\n \t$(SHELL) $(srcdir)/mvifdiff.sh cpugen.go.tmp cpugen.go\n \t$(STAMP) $@\n \n@@ -2653,7 +2651,7 @@ s-objabi: Makefile\n \techo 'const defaultGOARCH = runtime.GOARCH' >> objabi.go.tmp\n \techo 'const defaultGO_EXTLINK_ENABLED = ``' >> objabi.go.tmp\n \techo 'const version = `'`cat $(srcdir)/VERSION | sed 1q`' '`$(GOC) --version | sed 1q`'`' >> objabi.go.tmp\n-\techo 'const stackGuardMultiplier = 1' >> objabi.go.tmp\n+\techo 'const stackGuardMultiplierDefault = 1' >> objabi.go.tmp\n \techo 'const goexperiment = ``' >> objabi.go.tmp\n \t$(SHELL) $(srcdir)/mvifdiff.sh objabi.go.tmp objabi.go\n \t$(STAMP) $@\n@@ -2846,13 +2844,7 @@ cmd/go/internal/cfg.lo.dep: $(extra_go_files_cmd_go_internal_cfg)\n # FIXME: The following C files may as well move to the runtime\n # directory and be treated like other C files.\n \n-# Use C code to speed up {bytes,strings}.IndexByte and friends.\n-bytes/index.lo: go/bytes/indexbyte.c runtime.inc\n-\t@$(MKDIR_P) bytes\n-\t$(LTCOMPILE) -c -o $@ $(srcdir)/go/bytes/indexbyte.c\n-strings/index.lo: go/strings/indexbyte.c runtime.inc\n-\t@$(MKDIR_P) strings\n-\t$(LTCOMPILE) -c -o $@ $(srcdir)/go/strings/indexbyte.c\n+# Use C code to speed up internal/bytealg.IndexByte and friends.\n internal/bytealg/bytealg.lo: go/internal/bytealg/bytealg.c runtime.inc\n \t@$(MKDIR_P) internal/bytealg\n \t$(LTCOMPILE) -c -o $@ $(srcdir)/go/internal/bytealg/bytealg.c\n@@ -2895,13 +2887,13 @@ internal/cpu/cpu_gccgo.lo: go/internal/cpu/cpu_gccgo.c runtime.inc\n \t@$(MKDIR_P) internal/cpu\n \t$(LTCOMPILE) -c -o $@ $(srcdir)/go/internal/cpu/cpu_gccgo.c\n \n-# Build golang_org/x/net/route only on BSD systems.\n+# Build internal/x/net/route only on BSD systems.\n \n-@LIBGO_IS_BSD_TRUE@$(eval $(call PACKAGE_template,golang_org/x/net/route))\n+@LIBGO_IS_BSD_TRUE@$(eval $(call PACKAGE_template,internal/x/net/route))\n \n-# Build golang_org/x/net/lif only on Solaris systems.\n+# Build internal/x/net/lif only on Solaris systems.\n \n-@LIBGO_IS_SOLARIS_TRUE@$(eval $(call PACKAGE_template,golang_org/x/net/lif))\n+@LIBGO_IS_SOLARIS_TRUE@$(eval $(call PACKAGE_template,internal/x/net/lif))\n \n check: check-tail\n check-recursive: check-head"}, {"sha": "b23185da1d36fd61e2e6de2a1986f117a7521e61", "filename": "libgo/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FVERSION?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -1 +1 @@\n-go1.11.1\n+go1.12beta2"}, {"sha": "298f9e06261c4248796711f800f9b34b2eb2a092", "filename": "libgo/check-packages.txt", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fcheck-packages.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fcheck-packages.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fcheck-packages.txt?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -8,6 +8,8 @@ cmd/go/internal/generate\n cmd/go/internal/get\n cmd/go/internal/imports\n cmd/go/internal/load\n+cmd/go/internal/lockedfile\n+cmd/go/internal/lockedfile/internal/filelock\n cmd/go/internal/modconv\n cmd/go/internal/modfetch\n cmd/go/internal/modfetch/codehost\n@@ -25,7 +27,6 @@ cmd/internal/buildid\n cmd/internal/edit\n cmd/internal/objabi\n cmd/internal/test2json\n-cmd/vet/internal/cfg\n compress/bzip2\n compress/flate\n compress/gzip\n@@ -61,7 +62,6 @@ debug/elf\n debug/macho\n debug/pe\n debug/plan9obj\n-debug/xcoff\n encoding/ascii85\n encoding/asn1\n encoding/base32\n@@ -91,19 +91,6 @@ go/printer\n go/scanner\n go/token\n go/types\n-golang_org/x/crypto/internal/chacha20\n-golang_org/x/crypto/chacha20poly1305\n-golang_org/x/crypto/chacha20poly1305/internal/chacha20\n-golang_org/x/crypto/cryptobyte\n-golang_org/x/crypto/curve25519\n-golang_org/x/crypto/poly1305\n-golang_org/x/net/dns/dnsmessage\n-golang_org/x/net/http/httpguts\n-golang_org/x/net/http/httpproxy\n-golang_org/x/net/http2/hpack\n-golang_org/x/net/idna\n-golang_org/x/net/lex/httplex\n-golang_org/x/net/proxy\n hash\n hash/adler32\n hash/crc32\n@@ -118,9 +105,22 @@ image/jpeg\n image/png\n index/suffixarray\n internal/cpu\n+internal/fmtsort\n internal/poll\n internal/singleflight\n internal/trace\n+internal/x/crypto/chacha20poly1305\n+internal/x/crypto/cryptobyte\n+internal/x/crypto/curve25519\n+internal/x/crypto/hkdf\n+internal/x/crypto/internal/chacha20\n+internal/x/crypto/poly1305\n+internal/x/net/dns/dnsmessage\n+internal/x/net/http/httpguts\n+internal/x/net/http/httpproxy\n+internal/x/net/http2/hpack\n+internal/x/net/idna\n+internal/xcoff\n io\n io/ioutil\n log\n@@ -162,6 +162,7 @@ regexp/syntax\n runtime\n runtime/debug\n runtime/internal/atomic\n+runtime/internal/math\n runtime/internal/sys\n runtime/pprof\n runtime/pprof/internal/profile"}, {"sha": "4f6840099c49e8b07cf4d683f1d8ec6d5ca71831", "filename": "libgo/configure", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -2532,7 +2532,7 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu\n ac_config_headers=\"$ac_config_headers config.h\"\n \n \n-libtool_VERSION=13:0:0\n+libtool_VERSION=14:0:0\n \n \n # Default to --enable-multilib\n@@ -13744,7 +13744,7 @@ go_include=\"-include\"\n # All known GOOS values.  This is the union of all operating systems\n # supported by the gofrontend and all operating systems supported by\n # the gc toolchain.\n-ALLGOOS=\"aix android darwin dragonfly freebsd irix linux netbsd openbsd plan9 rtems solaris windows\"\n+ALLGOOS=\"aix android darwin dragonfly freebsd hurd irix js linux netbsd openbsd plan9 rtems solaris windows\"\n \n is_darwin=no\n is_freebsd=no"}, {"sha": "2b7e191075357a7bbc70661deccd76e1491226e5", "filename": "libgo/configure.ac", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure.ac?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -10,7 +10,7 @@ AC_INIT(package-unused, version-unused,, libgo)\n AC_CONFIG_SRCDIR(Makefile.am)\n AC_CONFIG_HEADER(config.h)\n \n-libtool_VERSION=13:0:0\n+libtool_VERSION=14:0:0\n AC_SUBST(libtool_VERSION)\n \n AM_ENABLE_MULTILIB(, ..)\n@@ -153,7 +153,7 @@ AC_SUBST(go_include)\n # All known GOOS values.  This is the union of all operating systems\n # supported by the gofrontend and all operating systems supported by\n # the gc toolchain.\n-ALLGOOS=\"aix android darwin dragonfly freebsd irix linux netbsd openbsd plan9 rtems solaris windows\"\n+ALLGOOS=\"aix android darwin dragonfly freebsd hurd irix js linux netbsd openbsd plan9 rtems solaris windows\"\n \n is_darwin=no\n is_freebsd=no"}, {"sha": "cfe24a5e1d339540c26feb898bfa6ce09d1813d8", "filename": "libgo/go/archive/tar/format.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Farchive%2Ftar%2Fformat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Farchive%2Ftar%2Fformat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fformat.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -160,7 +160,7 @@ func (b *block) V7() *headerV7       { return (*headerV7)(b) }\n func (b *block) GNU() *headerGNU     { return (*headerGNU)(b) }\n func (b *block) STAR() *headerSTAR   { return (*headerSTAR)(b) }\n func (b *block) USTAR() *headerUSTAR { return (*headerUSTAR)(b) }\n-func (b *block) Sparse() sparseArray { return (sparseArray)(b[:]) }\n+func (b *block) Sparse() sparseArray { return sparseArray(b[:]) }\n \n // GetFormat checks that the block is a valid tar header based on the checksum.\n // It then attempts to guess the specific format based on magic values.\n@@ -263,7 +263,7 @@ func (h *headerGNU) DevMajor() []byte    { return h[329:][:8] }\n func (h *headerGNU) DevMinor() []byte    { return h[337:][:8] }\n func (h *headerGNU) AccessTime() []byte  { return h[345:][:12] }\n func (h *headerGNU) ChangeTime() []byte  { return h[357:][:12] }\n-func (h *headerGNU) Sparse() sparseArray { return (sparseArray)(h[386:][:24*4+1]) }\n+func (h *headerGNU) Sparse() sparseArray { return sparseArray(h[386:][:24*4+1]) }\n func (h *headerGNU) RealSize() []byte    { return h[483:][:12] }\n \n type headerSTAR [blockSize]byte\n@@ -293,7 +293,7 @@ func (h *headerUSTAR) Prefix() []byte    { return h[345:][:155] }\n \n type sparseArray []byte\n \n-func (s sparseArray) Entry(i int) sparseElem { return (sparseElem)(s[i*24:]) }\n+func (s sparseArray) Entry(i int) sparseElem { return sparseElem(s[i*24:]) }\n func (s sparseArray) IsExtended() []byte     { return s[24*s.MaxEntries():][:1] }\n func (s sparseArray) MaxEntries() int        { return len(s) / 24 }\n "}, {"sha": "cf9cc79c5915bace0af0e81fa4df961f3a68553c", "filename": "libgo/go/archive/tar/stat_actime1.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Farchive%2Ftar%2Fstat_actime1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Farchive%2Ftar%2Fstat_actime1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fstat_actime1.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build aix linux dragonfly openbsd solaris\n+// +build linux dragonfly openbsd solaris\n \n package tar\n "}, {"sha": "2260b398c34e9e95962f1e021d3d847c678ba48c", "filename": "libgo/go/archive/zip/reader.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -69,6 +69,9 @@ func OpenReader(name string) (*ReadCloser, error) {\n // NewReader returns a new Reader reading from r, which is assumed to\n // have the given size in bytes.\n func NewReader(r io.ReaderAt, size int64) (*Reader, error) {\n+\tif size < 0 {\n+\t\treturn nil, errors.New(\"zip: size cannot be negative\")\n+\t}\n \tzr := new(Reader)\n \tif err := zr.init(r, size); err != nil {\n \t\treturn nil, err"}, {"sha": "6b3f2f33bb4f2c57ed7e15d06d2ef2a936960484", "filename": "libgo/go/archive/zip/reader_test.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -658,6 +658,12 @@ func TestInvalidFiles(t *testing.T) {\n \tif err != ErrFormat {\n \t\tt.Errorf(\"sigs: error=%v, want %v\", err, ErrFormat)\n \t}\n+\n+\t// negative size\n+\t_, err = NewReader(bytes.NewReader([]byte(\"foobar\")), -1)\n+\tif err == nil {\n+\t\tt.Errorf(\"archive/zip.NewReader: expected error when negative size is passed\")\n+\t}\n }\n \n func messWith(fileName string, corrupter func(b []byte)) (r io.ReaderAt, size int64) {"}, {"sha": "bd637d185b743c2f75a2e561eeb4854ca2d12abb", "filename": "libgo/go/archive/zip/struct.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -303,8 +303,8 @@ func (h *FileHeader) SetMode(mode os.FileMode) {\n }\n \n // isZip64 reports whether the file size exceeds the 32 bit limit\n-func (fh *FileHeader) isZip64() bool {\n-\treturn fh.CompressedSize64 >= uint32max || fh.UncompressedSize64 >= uint32max\n+func (h *FileHeader) isZip64() bool {\n+\treturn h.CompressedSize64 >= uint32max || h.UncompressedSize64 >= uint32max\n }\n \n func msdosModeToFileMode(m uint32) (mode os.FileMode) {"}, {"sha": "cdc534eaf01922df345eb4a44b372ef4c8fbc1bc", "filename": "libgo/go/archive/zip/writer.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -178,7 +178,7 @@ func (w *Writer) Close() error {\n \t\t\treturn err\n \t\t}\n \n-\t\t// store max values in the regular end record to signal that\n+\t\t// store max values in the regular end record to signal\n \t\t// that the zip64 values should be used instead\n \t\trecords = uint16max\n \t\tsize = uint32max"}, {"sha": "3d5c759851a3a4fe0bbfe5e67c057215778ae85f", "filename": "libgo/go/archive/zip/zip_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -159,7 +159,7 @@ func (r *rleBuffer) Write(p []byte) (n int, err error) {\n \treturn len(p), nil\n }\n \n-func min(x, y int) int {\n+func min(x, y int64) int64 {\n \tif x < y {\n \t\treturn x\n \t}\n@@ -190,7 +190,7 @@ func (r *rleBuffer) ReadAt(p []byte, off int64) (n int, err error) {\n \tif len(parts) > 0 {\n \t\tskipBytes := off - parts[0].off\n \t\tfor _, part := range parts {\n-\t\t\trepeat := min(int(part.n-skipBytes), len(p)-n)\n+\t\t\trepeat := int(min(part.n-skipBytes, int64(len(p)-n)))\n \t\t\tmemset(p[n:n+repeat], part.b)\n \t\t\tn += repeat\n \t\t\tif n == len(p) {"}, {"sha": "0125d729d1b31e679ab390d122e1c927c8d5a313", "filename": "libgo/go/bufio/bufio.go", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fbufio%2Fbufio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fbufio%2Fbufio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -33,8 +33,8 @@ type Reader struct {\n \trd           io.Reader // reader provided by the client\n \tr, w         int       // buf read and write positions\n \terr          error\n-\tlastByte     int\n-\tlastRuneSize int\n+\tlastByte     int // last byte read for UnreadByte; -1 means invalid\n+\tlastRuneSize int // size of last rune read for UnreadRune; -1 means invalid\n }\n \n const minReadBufferSize = 16\n@@ -63,7 +63,7 @@ func NewReader(rd io.Reader) *Reader {\n }\n \n // Size returns the size of the underlying buffer in bytes.\n-func (r *Reader) Size() int { return len(r.buf) }\n+func (b *Reader) Size() int { return len(b.buf) }\n \n // Reset discards any buffered data, resets all state, and switches\n // the buffered reader to read from r.\n@@ -123,11 +123,17 @@ func (b *Reader) readErr() error {\n // being valid at the next read call. If Peek returns fewer than n bytes, it\n // also returns an error explaining why the read is short. The error is\n // ErrBufferFull if n is larger than b's buffer size.\n+//\n+// Calling Peek prevents a UnreadByte or UnreadRune call from succeeding\n+// until the next read operation.\n func (b *Reader) Peek(n int) ([]byte, error) {\n \tif n < 0 {\n \t\treturn nil, ErrNegativeCount\n \t}\n \n+\tb.lastByte = -1\n+\tb.lastRuneSize = -1\n+\n \tfor b.w-b.r < n && b.w-b.r < len(b.buf) && b.err == nil {\n \t\tb.fill() // b.w-b.r < len(b.buf) => buffer is not full\n \t}\n@@ -186,6 +192,7 @@ func (b *Reader) Discard(n int) (discarded int, err error) {\n // It returns the number of bytes read into p.\n // The bytes are taken from at most one Read on the underlying Reader,\n // hence n may be less than len(p).\n+// To read exactly len(p) bytes, use io.ReadFull(b, p).\n // At EOF, the count will be zero and err will be io.EOF.\n func (b *Reader) Read(p []byte) (n int, err error) {\n \tn = len(p)\n@@ -248,6 +255,10 @@ func (b *Reader) ReadByte() (byte, error) {\n }\n \n // UnreadByte unreads the last byte. Only the most recently read byte can be unread.\n+//\n+// UnreadByte returns an error if the most recent method called on the\n+// Reader was not a read operation. Notably, Peek is not considered a\n+// read operation.\n func (b *Reader) UnreadByte() error {\n \tif b.lastByte < 0 || b.r == 0 && b.w > 0 {\n \t\treturn ErrInvalidUnreadByte\n@@ -286,8 +297,8 @@ func (b *Reader) ReadRune() (r rune, size int, err error) {\n \treturn r, size, nil\n }\n \n-// UnreadRune unreads the last rune. If the most recent read operation on\n-// the buffer was not a ReadRune, UnreadRune returns an error.  (In this\n+// UnreadRune unreads the last rune. If the most recent method called on\n+// the Reader was not a ReadRune, UnreadRune returns an error. (In this\n // regard it is stricter than UnreadByte, which will unread the last byte\n // from any read operation.)\n func (b *Reader) UnreadRune() error {\n@@ -314,9 +325,11 @@ func (b *Reader) Buffered() int { return b.w - b.r }\n // ReadBytes or ReadString instead.\n // ReadSlice returns err != nil if and only if line does not end in delim.\n func (b *Reader) ReadSlice(delim byte) (line []byte, err error) {\n+\ts := 0 // search start index\n \tfor {\n \t\t// Search buffer.\n-\t\tif i := bytes.IndexByte(b.buf[b.r:b.w], delim); i >= 0 {\n+\t\tif i := bytes.IndexByte(b.buf[b.r+s:b.w], delim); i >= 0 {\n+\t\t\ti += s\n \t\t\tline = b.buf[b.r : b.r+i+1]\n \t\t\tb.r += i + 1\n \t\t\tbreak\n@@ -338,6 +351,8 @@ func (b *Reader) ReadSlice(delim byte) (line []byte, err error) {\n \t\t\tbreak\n \t\t}\n \n+\t\ts = b.w - b.r // do not rescan area we scanned before\n+\n \t\tb.fill() // buffer is not full\n \t}\n "}, {"sha": "f7a0682e7033dd2f4c6b6664b98fd7d1df9fea06", "filename": "libgo/go/bufio/bufio_test.go", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio_test.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -285,6 +285,24 @@ func TestUnreadRune(t *testing.T) {\n \t}\n }\n \n+func TestNoUnreadRuneAfterPeek(t *testing.T) {\n+\tbr := NewReader(strings.NewReader(\"example\"))\n+\tbr.ReadRune()\n+\tbr.Peek(1)\n+\tif err := br.UnreadRune(); err == nil {\n+\t\tt.Error(\"UnreadRune didn't fail after Peek\")\n+\t}\n+}\n+\n+func TestNoUnreadByteAfterPeek(t *testing.T) {\n+\tbr := NewReader(strings.NewReader(\"example\"))\n+\tbr.ReadByte()\n+\tbr.Peek(1)\n+\tif err := br.UnreadByte(); err == nil {\n+\t\tt.Error(\"UnreadByte didn't fail after Peek\")\n+\t}\n+}\n+\n func TestUnreadByte(t *testing.T) {\n \tsegments := []string{\"Hello, \", \"world\"}\n \tr := NewReader(&StringReader{data: segments})\n@@ -550,7 +568,7 @@ func TestWriter(t *testing.T) {\n \t\t\t\tt.Errorf(\"%s: %d bytes written\", context, len(written))\n \t\t\t}\n \t\t\tfor l := 0; l < len(written); l++ {\n-\t\t\t\tif written[i] != data[i] {\n+\t\t\t\tif written[l] != data[l] {\n \t\t\t\t\tt.Errorf(\"wrong bytes written\")\n \t\t\t\t\tt.Errorf(\"want=%q\", data[0:len(written)])\n \t\t\t\t\tt.Errorf(\"have=%q\", written)"}, {"sha": "c78fe09ea66022cceff857fb883aa93e4f342f59", "filename": "libgo/go/builtin/builtin.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fbuiltin%2Fbuiltin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fbuiltin%2Fbuiltin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbuiltin%2Fbuiltin.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -152,6 +152,9 @@ func delete(m map[Type]Type1, key Type)\n //\tString: the number of bytes in v.\n //\tChannel: the number of elements queued (unread) in the channel buffer;\n //\tif v is nil, len(v) is zero.\n+// For some arguments, such as a string literal or a simple array expression, the\n+// result can be a constant. See the Go language specification's \"Length and\n+// capacity\" section for details.\n func len(v Type) int\n \n // The cap built-in function returns the capacity of v, according to its type:\n@@ -161,6 +164,9 @@ func len(v Type) int\n //\tif v is nil, cap(v) is zero.\n //\tChannel: the channel buffer capacity, in units of elements;\n //\tif v is nil, cap(v) is zero.\n+// For some arguments, such as a simple array expression, the result can be a\n+// constant. See the Go language specification's \"Length and capacity\" section for\n+// details.\n func cap(v Type) int\n \n // The make built-in function allocates and initializes an object of type"}, {"sha": "aff2db5084f11e20657f9e61897f278b26e626fc", "filename": "libgo/go/bytes/buffer.go", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fbytes%2Fbuffer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fbytes%2Fbuffer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbuffer.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -12,13 +12,15 @@ import (\n \t\"unicode/utf8\"\n )\n \n+// smallBufferSize is an initial allocation minimal capacity.\n+const smallBufferSize = 64\n+\n // A Buffer is a variable-sized buffer of bytes with Read and Write methods.\n // The zero value for Buffer is an empty buffer ready to use.\n type Buffer struct {\n-\tbuf       []byte   // contents are the bytes buf[off : len(buf)]\n-\toff       int      // read at &buf[off], write at &buf[len(buf)]\n-\tbootstrap [64]byte // memory to hold first slice; helps small buffers avoid allocation.\n-\tlastRead  readOp   // last read operation, so that Unread* can work correctly.\n+\tbuf      []byte // contents are the bytes buf[off : len(buf)]\n+\toff      int    // read at &buf[off], write at &buf[len(buf)]\n+\tlastRead readOp // last read operation, so that Unread* can work correctly.\n \n \t// FIXME: it would be advisable to align Buffer to cachelines to avoid false\n \t// sharing.\n@@ -66,7 +68,7 @@ func (b *Buffer) String() string {\n \treturn string(b.buf[b.off:])\n }\n \n-// empty returns whether the unread portion of the buffer is empty.\n+// empty reports whether the unread portion of the buffer is empty.\n func (b *Buffer) empty() bool { return len(b.buf) <= b.off }\n \n // Len returns the number of bytes of the unread portion of the buffer;\n@@ -125,9 +127,8 @@ func (b *Buffer) grow(n int) int {\n \tif i, ok := b.tryGrowByReslice(n); ok {\n \t\treturn i\n \t}\n-\t// Check if we can make use of bootstrap array.\n-\tif b.buf == nil && n <= len(b.bootstrap) {\n-\t\tb.buf = b.bootstrap[:n]\n+\tif b.buf == nil && n <= smallBufferSize {\n+\t\tb.buf = make([]byte, n, smallBufferSize)\n \t\treturn 0\n \t}\n \tc := cap(b.buf)\n@@ -441,9 +442,9 @@ func (b *Buffer) ReadString(delim byte) (line string, err error) {\n // NewBuffer creates and initializes a new Buffer using buf as its\n // initial contents. The new Buffer takes ownership of buf, and the\n // caller should not use buf after this call. NewBuffer is intended to\n-// prepare a Buffer to read existing data. It can also be used to size\n-// the internal buffer for writing. To do that, buf should have the\n-// desired capacity but a length of zero.\n+// prepare a Buffer to read existing data. It can also be used to set\n+// the initial size of the internal buffer for writing. To do that,\n+// buf should have the desired capacity but a length of zero.\n //\n // In most cases, new(Buffer) (or just declaring a Buffer variable) is\n // sufficient to initialize a Buffer."}, {"sha": "6e9d6952a51a588f8627a6bd4fbba291040dc98d", "filename": "libgo/go/bytes/buffer_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fbytes%2Fbuffer_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fbytes%2Fbuffer_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbuffer_test.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -293,7 +293,7 @@ func TestReadFromPanicReader(t *testing.T) {\n \t}\n \tcheck(t, \"TestReadFromPanicReader (1)\", &buf, \"\")\n \n-\t// Confirm that when Reader panics, the emtpy buffer remains empty\n+\t// Confirm that when Reader panics, the empty buffer remains empty\n \tvar buf2 Buffer\n \tdefer func() {\n \t\trecover()"}, {"sha": "daf4a32f26f29e25159ba1ec1c64f785536f1835", "filename": "libgo/go/bytes/bytes.go", "status": "modified", "additions": 46, "deletions": 16, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fbytes%2Fbytes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fbytes%2Fbytes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -12,6 +12,13 @@ import (\n \t\"unicode/utf8\"\n )\n \n+// Equal returns a boolean reporting whether a and b\n+// are the same length and contain the same bytes.\n+// A nil argument is equivalent to an empty slice.\n+func Equal(a, b []byte) bool {\n+\treturn bytealg.Equal(a, b)\n+}\n+\n func equalPortable(a, b []byte) bool {\n \tif len(a) != len(b) {\n \t\treturn false\n@@ -24,6 +31,13 @@ func equalPortable(a, b []byte) bool {\n \treturn true\n }\n \n+// Compare returns an integer comparing two byte slices lexicographically.\n+// The result will be 0 if a==b, -1 if a < b, and +1 if a > b.\n+// A nil argument is equivalent to an empty slice.\n+func Compare(a, b []byte) int {\n+\treturn bytealg.Compare(a, b)\n+}\n+\n // explode splits s into a slice of UTF-8 sequences, one per Unicode code point (still slices of bytes),\n // up to a maximum of n byte slices. Invalid UTF-8 sequences are chopped into individual bytes.\n func explode(s []byte, n int) [][]byte {\n@@ -83,6 +97,11 @@ func ContainsRune(b []byte, r rune) bool {\n \treturn IndexRune(b, r) >= 0\n }\n \n+// IndexByte returns the index of the first instance of c in b, or -1 if c is not present in b.\n+func IndexByte(b []byte, c byte) int {\n+\treturn bytealg.IndexByte(b, c)\n+}\n+\n func indexBytePortable(s []byte, c byte) int {\n \tfor i, b := range s {\n \t\tif b == c {\n@@ -489,19 +508,19 @@ func ToTitle(s []byte) []byte { return Map(unicode.ToTitle, s) }\n // ToUpperSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their\n // upper case, giving priority to the special casing rules.\n func ToUpperSpecial(c unicode.SpecialCase, s []byte) []byte {\n-\treturn Map(func(r rune) rune { return c.ToUpper(r) }, s)\n+\treturn Map(c.ToUpper, s)\n }\n \n // ToLowerSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their\n // lower case, giving priority to the special casing rules.\n func ToLowerSpecial(c unicode.SpecialCase, s []byte) []byte {\n-\treturn Map(func(r rune) rune { return c.ToLower(r) }, s)\n+\treturn Map(c.ToLower, s)\n }\n \n // ToTitleSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their\n // title case, giving priority to the special casing rules.\n func ToTitleSpecial(c unicode.SpecialCase, s []byte) []byte {\n-\treturn Map(func(r rune) rune { return c.ToTitle(r) }, s)\n+\treturn Map(c.ToTitle, s)\n }\n \n // isSeparator reports whether the rune could mark a word boundary.\n@@ -774,6 +793,15 @@ func Replace(s, old, new []byte, n int) []byte {\n \treturn t[0:w]\n }\n \n+// ReplaceAll returns a copy of the slice s with all\n+// non-overlapping instances of old replaced by new.\n+// If old is empty, it matches at the beginning of the slice\n+// and after each UTF-8 sequence, yielding up to k+1 replacements\n+// for a k-rune slice.\n+func ReplaceAll(s, old, new []byte) []byte {\n+\treturn Replace(s, old, new, -1)\n+}\n+\n // EqualFold reports whether s and t, interpreted as UTF-8 strings,\n // are equal under Unicode case-folding.\n func EqualFold(s, t []byte) bool {\n@@ -849,21 +877,22 @@ func Index(s, sep []byte) int {\n \t\tif len(s) <= bytealg.MaxBruteForce {\n \t\t\treturn bytealg.Index(s, sep)\n \t\t}\n-\t\tc := sep[0]\n+\t\tc0 := sep[0]\n+\t\tc1 := sep[1]\n \t\ti := 0\n-\t\tt := s[:len(s)-n+1]\n+\t\tt := len(s) - n + 1\n \t\tfails := 0\n-\t\tfor i < len(t) {\n-\t\t\tif t[i] != c {\n+\t\tfor i < t {\n+\t\t\tif s[i] != c0 {\n \t\t\t\t// IndexByte is faster than bytealg.Index, so use it as long as\n \t\t\t\t// we're not getting lots of false positives.\n-\t\t\t\to := IndexByte(t[i:], c)\n+\t\t\t\to := IndexByte(s[i:t], c0)\n \t\t\t\tif o < 0 {\n \t\t\t\t\treturn -1\n \t\t\t\t}\n \t\t\t\ti += o\n \t\t\t}\n-\t\t\tif Equal(s[i:i+n], sep) {\n+\t\t\tif s[i+1] == c1 && Equal(s[i:i+n], sep) {\n \t\t\t\treturn i\n \t\t\t}\n \t\t\tfails++\n@@ -879,24 +908,25 @@ func Index(s, sep []byte) int {\n \t\t}\n \t\treturn -1\n \t}\n-\tc := sep[0]\n+\tc0 := sep[0]\n+\tc1 := sep[1]\n \ti := 0\n \tfails := 0\n-\tt := s[:len(s)-n+1]\n-\tfor i < len(t) {\n-\t\tif t[i] != c {\n-\t\t\to := IndexByte(t[i:], c)\n+\tt := len(s) - n + 1\n+\tfor i < t {\n+\t\tif s[i] != c0 {\n+\t\t\to := IndexByte(s[i:t], c0)\n \t\t\tif o < 0 {\n \t\t\t\tbreak\n \t\t\t}\n \t\t\ti += o\n \t\t}\n-\t\tif Equal(s[i:i+n], sep) {\n+\t\tif s[i+1] == c1 && Equal(s[i:i+n], sep) {\n \t\t\treturn i\n \t\t}\n \t\ti++\n \t\tfails++\n-\t\tif fails >= 4+i>>4 && i < len(t) {\n+\t\tif fails >= 4+i>>4 && i < t {\n \t\t\t// Give up on IndexByte, it isn't skipping ahead\n \t\t\t// far enough to be better than Rabin-Karp.\n \t\t\t// Experiments (using IndexPeriodic) suggest"}, {"sha": "af0f8b179fddb92daf1540db5c49dd8635a682b8", "filename": "libgo/go/bytes/bytes_decl.go", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fbytes%2Fbytes_decl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fbytes%2Fbytes_decl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes_decl.go?ref=225220d668dafb8262db7012bced688acbe63b33", "patch": "@@ -1,24 +0,0 @@\n-// Copyright 2010 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package bytes\n-\n-//go:noescape\n-\n-// IndexByte returns the index of the first instance of c in b, or -1 if c is not present in b.\n-func IndexByte(b []byte, c byte) int // in internal/bytealg\n-\n-//go:noescape\n-\n-// Equal returns a boolean reporting whether a and b\n-// are the same length and contain the same bytes.\n-// A nil argument is equivalent to an empty slice.\n-func Equal(a, b []byte) bool // in internal/bytealg\n-\n-//go:noescape\n-\n-// Compare returns an integer comparing two byte slices lexicographically.\n-// The result will be 0 if a==b, -1 if a < b, and +1 if a > b.\n-// A nil argument is equivalent to an empty slice.\n-func Compare(a, b []byte) int // in internal/bytealg"}, {"sha": "ec4ecf31032c525373af1900abd3bcdc1355b202", "filename": "libgo/go/bytes/bytes_test.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fbytes%2Fbytes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fbytes%2Fbytes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes_test.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -1367,6 +1367,12 @@ func TestReplace(t *testing.T) {\n \t\tif cap(in) == cap(out) && &in[:1][0] == &out[:1][0] {\n \t\t\tt.Errorf(\"Replace(%q, %q, %q, %d) didn't copy\", tt.in, tt.old, tt.new, tt.n)\n \t\t}\n+\t\tif tt.n == -1 {\n+\t\t\tout := ReplaceAll(in, []byte(tt.old), []byte(tt.new))\n+\t\t\tif s := string(out); s != tt.out {\n+\t\t\t\tt.Errorf(\"ReplaceAll(%q, %q, %q) = %q, want %q\", tt.in, tt.old, tt.new, s, tt.out)\n+\t\t\t}\n+\t\t}\n \t}\n }\n "}, {"sha": "a321f2e08618439c2e62413dfed0542bc33cc2e5", "filename": "libgo/go/bytes/compare_test.go", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fbytes%2Fcompare_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fbytes%2Fcompare_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fcompare_test.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -41,9 +41,16 @@ var compareTests = []struct {\n \n func TestCompare(t *testing.T) {\n \tfor _, tt := range compareTests {\n-\t\tcmp := Compare(tt.a, tt.b)\n-\t\tif cmp != tt.i {\n-\t\t\tt.Errorf(`Compare(%q, %q) = %v`, tt.a, tt.b, cmp)\n+\t\tnumShifts := 16\n+\t\tbuffer := make([]byte, len(tt.b)+numShifts)\n+\t\t// vary the input alignment of tt.b\n+\t\tfor offset := 0; offset <= numShifts; offset++ {\n+\t\t\tshiftedB := buffer[offset : len(tt.b)+offset]\n+\t\t\tcopy(shiftedB, tt.b)\n+\t\t\tcmp := Compare(tt.a, shiftedB)\n+\t\t\tif cmp != tt.i {\n+\t\t\t\tt.Errorf(`Compare(%q, %q), offset %d = %v; want %v`, tt.a, tt.b, offset, cmp, tt.i)\n+\t\t\t}\n \t\t}\n \t}\n }"}, {"sha": "6d328378fabdc48a99aff201905487aa12131521", "filename": "libgo/go/bytes/example_test.go", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fbytes%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fbytes%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fexample_test.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -39,6 +39,14 @@ func ExampleBuffer_Grow() {\n \t// Output: \"64 bytes or fewer\"\n }\n \n+func ExampleBuffer_Len() {\n+\tvar b bytes.Buffer\n+\tb.Grow(64)\n+\tb.Write([]byte(\"abcde\"))\n+\tfmt.Printf(\"%d\", b.Len())\n+\t// Output: 5\n+}\n+\n func ExampleCompare() {\n \t// Interpret Compare's result by comparing it to zero.\n \tvar a, b []byte\n@@ -290,6 +298,12 @@ func ExampleReplace() {\n \t// moo moo moo\n }\n \n+func ExampleReplaceAll() {\n+\tfmt.Printf(\"%s\\n\", bytes.ReplaceAll([]byte(\"oink oink oink\"), []byte(\"oink\"), []byte(\"moo\")))\n+\t// Output:\n+\t// moo moo moo\n+}\n+\n func ExampleRunes() {\n \trs := bytes.Runes([]byte(\"go gopher\"))\n \tfor _, r := range rs {"}, {"sha": "b248108e404a5dec4e19a730d50a272bbeafdff5", "filename": "libgo/go/bytes/indexbyte.c", "status": "removed", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fbytes%2Findexbyte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fbytes%2Findexbyte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Findexbyte.c?ref=225220d668dafb8262db7012bced688acbe63b33", "patch": "@@ -1,73 +0,0 @@\n-/* indexbyte.c -- implement bytes.IndexByte for Go.\n-\n-   Copyright 2009 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include <stddef.h>\n-\n-#include \"runtime.h\"\n-#include \"array.h\"\n-\n-/* This is in C so that the compiler can optimize it appropriately.\n-   We deliberately don't split the stack in case it does call the\n-   library function, which shouldn't need much stack space.  */\n-\n-intgo IndexByte (struct __go_open_array, char)\n-  __asm__ (GOSYM_PREFIX \"bytes.IndexByte\")\n-  __attribute__ ((no_split_stack));\n-\n-intgo\n-IndexByte (struct __go_open_array s, char b)\n-{\n-  char *p;\n-\n-  p = __builtin_memchr (s.__values, b, s.__count);\n-  if (p == NULL)\n-    return -1;\n-  return p - (char *) s.__values;\n-}\n-\n-/* Comparison.  */\n-\n-_Bool Equal (struct __go_open_array a, struct __go_open_array b)\n-  __asm__ (GOSYM_PREFIX \"bytes.Equal\")\n-  __attribute__ ((no_split_stack));\n-\n-_Bool\n-Equal (struct __go_open_array a, struct __go_open_array b)\n-{\n-  if (a.__count != b.__count)\n-    return 0;\n-  return __builtin_memcmp (a.__values, b.__values, a.__count) == 0;\n-}\n-\n-intgo Compare (struct __go_open_array a, struct __go_open_array b)\n-  __asm__ (GOSYM_PREFIX \"bytes.Compare\")\n-  __attribute__ ((no_split_stack));\n-\n-intgo\n-Compare (struct __go_open_array a, struct __go_open_array b)\n-{\n-  intgo len;\n-\n-  len = a.__count;\n-  if (len > b.__count)\n-    len = b.__count;\n-  if (len > 0)\n-    {\n-      intgo ret;\n-\n-      ret = __builtin_memcmp (a.__values, b.__values, len);\n-      if (ret < 0)\n-\treturn -1;\n-      else if (ret > 0)\n-\treturn 1;\n-    }\n-  if (a.__count < b.__count)\n-    return -1;\n-  else if (a.__count > b.__count)\n-    return 1;\n-  else\n-    return 0;\n-}"}, {"sha": "5946cf9780b0e170f3398429958c1ae30a3a0952", "filename": "libgo/go/bytes/reader.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fbytes%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fbytes%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Freader.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -14,6 +14,7 @@ import (\n // io.ByteScanner, and io.RuneScanner interfaces by reading from\n // a byte slice.\n // Unlike a Buffer, a Reader is read-only and supports seeking.\n+// The zero value for Reader operates like a Reader of an empty slice.\n type Reader struct {\n \ts        []byte\n \ti        int64 // current reading index\n@@ -75,10 +76,10 @@ func (r *Reader) ReadByte() (byte, error) {\n \n // UnreadByte complements ReadByte in implementing the io.ByteScanner interface.\n func (r *Reader) UnreadByte() error {\n-\tr.prevRune = -1\n \tif r.i <= 0 {\n \t\treturn errors.New(\"bytes.Reader.UnreadByte: at beginning of slice\")\n \t}\n+\tr.prevRune = -1\n \tr.i--\n \treturn nil\n }\n@@ -101,6 +102,9 @@ func (r *Reader) ReadRune() (ch rune, size int, err error) {\n \n // UnreadRune complements ReadRune in implementing the io.RuneScanner interface.\n func (r *Reader) UnreadRune() error {\n+\tif r.i <= 0 {\n+\t\treturn errors.New(\"bytes.Reader.UnreadRune: at beginning of slice\")\n+\t}\n \tif r.prevRune < 0 {\n \t\treturn errors.New(\"bytes.Reader.UnreadRune: previous operation was not ReadRune\")\n \t}"}, {"sha": "d799e036f0c00160a7e03fdf269b376e54ea3120", "filename": "libgo/go/bytes/reader_test.go", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fbytes%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fbytes%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Freader_test.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -276,3 +276,45 @@ func TestReaderReset(t *testing.T) {\n \t\tt.Errorf(\"ReadAll: got %q, want %q\", got, want)\n \t}\n }\n+\n+func TestReaderZero(t *testing.T) {\n+\tif l := (&Reader{}).Len(); l != 0 {\n+\t\tt.Errorf(\"Len: got %d, want 0\", l)\n+\t}\n+\n+\tif n, err := (&Reader{}).Read(nil); n != 0 || err != io.EOF {\n+\t\tt.Errorf(\"Read: got %d, %v; want 0, io.EOF\", n, err)\n+\t}\n+\n+\tif n, err := (&Reader{}).ReadAt(nil, 11); n != 0 || err != io.EOF {\n+\t\tt.Errorf(\"ReadAt: got %d, %v; want 0, io.EOF\", n, err)\n+\t}\n+\n+\tif b, err := (&Reader{}).ReadByte(); b != 0 || err != io.EOF {\n+\t\tt.Errorf(\"ReadByte: got %d, %v; want 0, io.EOF\", b, err)\n+\t}\n+\n+\tif ch, size, err := (&Reader{}).ReadRune(); ch != 0 || size != 0 || err != io.EOF {\n+\t\tt.Errorf(\"ReadRune: got %d, %d, %v; want 0, 0, io.EOF\", ch, size, err)\n+\t}\n+\n+\tif offset, err := (&Reader{}).Seek(11, io.SeekStart); offset != 11 || err != nil {\n+\t\tt.Errorf(\"Seek: got %d, %v; want 11, nil\", offset, err)\n+\t}\n+\n+\tif s := (&Reader{}).Size(); s != 0 {\n+\t\tt.Errorf(\"Size: got %d, want 0\", s)\n+\t}\n+\n+\tif (&Reader{}).UnreadByte() == nil {\n+\t\tt.Errorf(\"UnreadByte: got nil, want error\")\n+\t}\n+\n+\tif (&Reader{}).UnreadRune() == nil {\n+\t\tt.Errorf(\"UnreadRune: got nil, want error\")\n+\t}\n+\n+\tif n, err := (&Reader{}).WriteTo(ioutil.Discard); n != 0 || err != nil {\n+\t\tt.Errorf(\"WriteTo: got %d, %v; want 0, nil\", n, err)\n+\t}\n+}"}, {"sha": "83d727a8a5da6846865076daff262df8ef7b01f9", "filename": "libgo/go/cmd/cgo/ast.go", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fcgo%2Fast.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fcgo%2Fast.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fast.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -145,6 +145,7 @@ func (f *File) ParseGo(name string, src []byte) {\n \tif f.Ref == nil {\n \t\tf.Ref = make([]*Ref, 0, 8)\n \t}\n+\tf.walk(ast2, ctxProg, (*File).validateIdents)\n \tf.walk(ast2, ctxProg, (*File).saveExprs)\n \n \t// Accumulate exported functions.\n@@ -181,6 +182,14 @@ func commentText(g *ast.CommentGroup) string {\n \treturn strings.Join(pieces, \"\")\n }\n \n+func (f *File) validateIdents(x interface{}, context astContext) {\n+\tif x, ok := x.(*ast.Ident); ok {\n+\t\tif f.isMangledName(x.Name) {\n+\t\t\terror_(x.Pos(), \"identifier %q may conflict with identifiers generated by cgo\", x.Name)\n+\t\t}\n+\t}\n+}\n+\n // Save various references we are going to need later.\n func (f *File) saveExprs(x interface{}, context astContext) {\n \tswitch x := x.(type) {\n@@ -191,6 +200,18 @@ func (f *File) saveExprs(x interface{}, context astContext) {\n \t\t}\n \tcase *ast.CallExpr:\n \t\tf.saveCall(x, context)\n+\tcase *ast.GenDecl:\n+\t\tif x.Tok == token.CONST {\n+\t\t\tfor _, spec := range x.Specs {\n+\t\t\t\tvs := spec.(*ast.ValueSpec)\n+\t\t\t\tif vs.Type == nil {\n+\t\t\t\t\tfor _, name := range spec.(*ast.ValueSpec).Names {\n+\t\t\t\t\t\tconsts[name.Name] = true\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n \t}\n }\n "}, {"sha": "cceb33edbdb738e39bf8ff0ee1e4af9797f26562", "filename": "libgo/go/cmd/cgo/doc.go", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -413,6 +413,8 @@ type in Go are instead represented by a uintptr. Those include:\n \tjobjectArray\n \tjweak\n \n+3. The EGLDisplay type from the EGL API.\n+\n These types are uintptr on the Go side because they would otherwise\n confuse the Go garbage collector; they are sometimes not really\n pointers but data structures encoded in a pointer type. All operations\n@@ -427,6 +429,11 @@ from Go 1.9 and earlier, use the cftype or jni rewrites in the Go fix tool:\n \n It will replace nil with 0 in the appropriate places.\n \n+The EGLDisplay case were introduced in Go 1.12. Use the egl rewrite\n+to auto-update code from Go 1.11 and earlier:\n+\n+\tgo tool fix -r egl <pkg>\n+\n Using cgo directly\n \n Usage:\n@@ -827,6 +834,10 @@ The directives are:\n \tpossibly version in the dynamic library, and the optional \"<library>\"\n \tnames the specific library where the symbol should be found.\n \n+\tOn AIX, the library pattern is slightly different. It must be\n+\t\"lib.a/obj.o\" with obj.o the member of this library exporting\n+\tthis symbol.\n+\n \tIn the <remote>, # or @ can be used to introduce a symbol version.\n \n \tExamples:"}, {"sha": "a842972520915be6da9f5bcbab47c53cc3abb505", "filename": "libgo/go/cmd/cgo/gcc.go", "status": "modified", "additions": 598, "deletions": 328, "changes": 926, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -13,14 +13,14 @@ import (\n \t\"debug/elf\"\n \t\"debug/macho\"\n \t\"debug/pe\"\n-\t\"debug/xcoff\"\n \t\"encoding/binary\"\n \t\"errors\"\n \t\"flag\"\n \t\"fmt\"\n \t\"go/ast\"\n \t\"go/parser\"\n \t\"go/token\"\n+\t\"internal/xcoff\"\n \t\"math\"\n \t\"os\"\n \t\"strconv\"\n@@ -89,8 +89,14 @@ func (f *File) DiscardCgoDirectives() {\n // _cgo_flags file for the build system to use.\n func (p *Package) addToFlag(flag string, args []string) {\n \tif flag == \"CFLAGS\" {\n-\t\t// We'll need these when preprocessing for dwarf information.\n-\t\tp.GccOptions = append(p.GccOptions, args...)\n+\t\t// We'll also need these when preprocessing for dwarf information.\n+\t\t// However, discard any -g options: we need to be able\n+\t\t// to parse the debug info, so stick to what we expect.\n+\t\tfor _, arg := range args {\n+\t\t\tif !strings.HasPrefix(arg, \"-g\") {\n+\t\t\t\tp.GccOptions = append(p.GccOptions, arg)\n+\t\t\t}\n+\t\t}\n \t}\n \n \tskip := false\n@@ -182,22 +188,28 @@ func (p *Package) Translate(f *File) {\n \t\t// Convert C.ulong to C.unsigned long, etc.\n \t\tcref.Name.C = cname(cref.Name.Go)\n \t}\n+\n+\tvar conv typeConv\n+\tconv.Init(p.PtrSize, p.IntSize)\n+\n \tp.loadDefines(f)\n \tp.typedefs = map[string]bool{}\n \tp.typedefList = nil\n \tnumTypedefs := -1\n \tfor len(p.typedefs) > numTypedefs {\n \t\tnumTypedefs = len(p.typedefs)\n \t\t// Also ask about any typedefs we've seen so far.\n-\t\tfor _, a := range p.typedefList {\n-\t\t\tf.Name[a] = &Name{\n-\t\t\t\tGo: a,\n-\t\t\t\tC:  a,\n+\t\tfor _, info := range p.typedefList {\n+\t\t\tn := &Name{\n+\t\t\t\tGo: info.typedef,\n+\t\t\t\tC:  info.typedef,\n \t\t\t}\n+\t\t\tf.Name[info.typedef] = n\n+\t\t\tf.NamePos[n] = info.pos\n \t\t}\n \t\tneedType := p.guessKinds(f)\n \t\tif len(needType) > 0 {\n-\t\t\tp.loadDWARF(f, needType)\n+\t\t\tp.loadDWARF(f, &conv, needType)\n \t\t}\n \n \t\t// In godefs mode we're OK with the typedefs, which\n@@ -207,6 +219,7 @@ func (p *Package) Translate(f *File) {\n \t\t\tbreak\n \t\t}\n \t}\n+\tp.prepareNames(f)\n \tif p.rewriteCalls(f) {\n \t\t// Add `import _cgo_unsafe \"unsafe\"` after the package statement.\n \t\tf.Edit.Insert(f.offset(f.AST.Name.End()), \"; import _cgo_unsafe \\\"unsafe\\\"\")\n@@ -491,7 +504,7 @@ func (p *Package) guessKinds(f *File) []*Name {\n // loadDWARF parses the DWARF debug information generated\n // by gcc to learn the details of the constants, variables, and types\n // being referred to as C.xxx.\n-func (p *Package) loadDWARF(f *File, names []*Name) {\n+func (p *Package) loadDWARF(f *File, conv *typeConv, names []*Name) {\n \t// Extract the types from the DWARF section of an object\n \t// from a well-formed C program. Gcc only generates DWARF info\n \t// for symbols in the object file, so it is not enough to print the\n@@ -590,16 +603,14 @@ func (p *Package) loadDWARF(f *File, names []*Name) {\n \t\t\t\tfatalf(\"malformed __cgo__ name: %s\", name)\n \t\t\t}\n \t\t\ttypes[i] = t.Type\n-\t\t\tp.recordTypedefs(t.Type)\n+\t\t\tp.recordTypedefs(t.Type, f.NamePos[names[i]])\n \t\t}\n \t\tif e.Tag != dwarf.TagCompileUnit {\n \t\t\tr.SkipChildren()\n \t\t}\n \t}\n \n \t// Record types and typedef information.\n-\tvar conv typeConv\n-\tconv.Init(p.PtrSize, p.IntSize)\n \tfor i, n := range names {\n \t\tif strings.HasSuffix(n.Go, \"GetTypeID\") && types[i].String() == \"func() CFTypeID\" {\n \t\t\tconv.getTypeIDs[n.Go[:len(n.Go)-9]] = true\n@@ -658,10 +669,11 @@ func (p *Package) loadDWARF(f *File, names []*Name) {\n }\n \n // recordTypedefs remembers in p.typedefs all the typedefs used in dtypes and its children.\n-func (p *Package) recordTypedefs(dtype dwarf.Type) {\n-\tp.recordTypedefs1(dtype, map[dwarf.Type]bool{})\n+func (p *Package) recordTypedefs(dtype dwarf.Type, pos token.Pos) {\n+\tp.recordTypedefs1(dtype, pos, map[dwarf.Type]bool{})\n }\n-func (p *Package) recordTypedefs1(dtype dwarf.Type, visited map[dwarf.Type]bool) {\n+\n+func (p *Package) recordTypedefs1(dtype dwarf.Type, pos token.Pos, visited map[dwarf.Type]bool) {\n \tif dtype == nil {\n \t\treturn\n \t}\n@@ -677,24 +689,45 @@ func (p *Package) recordTypedefs1(dtype dwarf.Type, visited map[dwarf.Type]bool)\n \t\t}\n \t\tif !p.typedefs[dt.Name] {\n \t\t\tp.typedefs[dt.Name] = true\n-\t\t\tp.typedefList = append(p.typedefList, dt.Name)\n-\t\t\tp.recordTypedefs1(dt.Type, visited)\n+\t\t\tp.typedefList = append(p.typedefList, typedefInfo{dt.Name, pos})\n+\t\t\tp.recordTypedefs1(dt.Type, pos, visited)\n \t\t}\n \tcase *dwarf.PtrType:\n-\t\tp.recordTypedefs1(dt.Type, visited)\n+\t\tp.recordTypedefs1(dt.Type, pos, visited)\n \tcase *dwarf.ArrayType:\n-\t\tp.recordTypedefs1(dt.Type, visited)\n+\t\tp.recordTypedefs1(dt.Type, pos, visited)\n \tcase *dwarf.QualType:\n-\t\tp.recordTypedefs1(dt.Type, visited)\n+\t\tp.recordTypedefs1(dt.Type, pos, visited)\n \tcase *dwarf.FuncType:\n-\t\tp.recordTypedefs1(dt.ReturnType, visited)\n+\t\tp.recordTypedefs1(dt.ReturnType, pos, visited)\n \t\tfor _, a := range dt.ParamType {\n-\t\t\tp.recordTypedefs1(a, visited)\n+\t\t\tp.recordTypedefs1(a, pos, visited)\n \t\t}\n \tcase *dwarf.StructType:\n \t\tfor _, f := range dt.Field {\n-\t\t\tp.recordTypedefs1(f.Type, visited)\n+\t\t\tp.recordTypedefs1(f.Type, pos, visited)\n+\t\t}\n+\t}\n+}\n+\n+// prepareNames finalizes the Kind field of not-type names and sets\n+// the mangled name of all names.\n+func (p *Package) prepareNames(f *File) {\n+\tfor _, n := range f.Name {\n+\t\tif n.Kind == \"not-type\" {\n+\t\t\tif n.Define == \"\" {\n+\t\t\t\tn.Kind = \"var\"\n+\t\t\t} else {\n+\t\t\t\tn.Kind = \"macro\"\n+\t\t\t\tn.FuncType = &FuncType{\n+\t\t\t\t\tResult: n.Type,\n+\t\t\t\t\tGo: &ast.FuncType{\n+\t\t\t\t\t\tResults: &ast.FieldList{List: []*ast.Field{{Type: n.Type.Go}}},\n+\t\t\t\t\t},\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n+\t\tp.mangleName(n)\n \t}\n }\n \n@@ -712,24 +745,37 @@ func (p *Package) mangleName(n *Name) {\n \tn.Mangle = prefix + n.Kind + \"_\" + n.Go\n }\n \n+func (f *File) isMangledName(s string) bool {\n+\tprefix := \"_C\"\n+\tif strings.HasPrefix(s, prefix) {\n+\t\tt := s[len(prefix):]\n+\t\tfor _, k := range nameKinds {\n+\t\t\tif strings.HasPrefix(t, k+\"_\") {\n+\t\t\t\treturn true\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n // rewriteCalls rewrites all calls that pass pointers to check that\n // they follow the rules for passing pointers between Go and C.\n-// This returns whether the package needs to import unsafe as _cgo_unsafe.\n+// This reports whether the package needs to import unsafe as _cgo_unsafe.\n func (p *Package) rewriteCalls(f *File) bool {\n \tneedsUnsafe := false\n+\t// Walk backward so that in C.f1(C.f2()) we rewrite C.f2 first.\n \tfor _, call := range f.Calls {\n-\t\t// This is a call to C.xxx; set goname to \"xxx\".\n-\t\tgoname := call.Call.Fun.(*ast.SelectorExpr).Sel.Name\n-\t\tif goname == \"malloc\" {\n-\t\t\tcontinue\n-\t\t}\n-\t\tname := f.Name[goname]\n-\t\tif name.Kind != \"func\" {\n-\t\t\t// Probably a type conversion.\n+\t\tif call.Done {\n \t\t\tcontinue\n \t\t}\n-\t\tif p.rewriteCall(f, call, name) {\n-\t\t\tneedsUnsafe = true\n+\t\tstart := f.offset(call.Call.Pos())\n+\t\tend := f.offset(call.Call.End())\n+\t\tstr, nu := p.rewriteCall(f, call)\n+\t\tif str != \"\" {\n+\t\t\tf.Edit.Replace(start, end, str)\n+\t\t\tif nu {\n+\t\t\t\tneedsUnsafe = true\n+\t\t\t}\n \t\t}\n \t}\n \treturn needsUnsafe\n@@ -739,162 +785,206 @@ func (p *Package) rewriteCalls(f *File) bool {\n // If any pointer checks are required, we rewrite the call into a\n // function literal that calls _cgoCheckPointer for each pointer\n // argument and then calls the original function.\n-// This returns whether the package needs to import unsafe as _cgo_unsafe.\n-func (p *Package) rewriteCall(f *File, call *Call, name *Name) bool {\n+// This returns the rewritten call and whether the package needs to\n+// import unsafe as _cgo_unsafe.\n+// If it returns the empty string, the call did not need to be rewritten.\n+func (p *Package) rewriteCall(f *File, call *Call) (string, bool) {\n+\t// This is a call to C.xxx; set goname to \"xxx\".\n+\t// It may have already been mangled by rewriteName.\n+\tvar goname string\n+\tswitch fun := call.Call.Fun.(type) {\n+\tcase *ast.SelectorExpr:\n+\t\tgoname = fun.Sel.Name\n+\tcase *ast.Ident:\n+\t\tgoname = strings.TrimPrefix(fun.Name, \"_C2func_\")\n+\t\tgoname = strings.TrimPrefix(goname, \"_Cfunc_\")\n+\t}\n+\tif goname == \"\" || goname == \"malloc\" {\n+\t\treturn \"\", false\n+\t}\n+\tname := f.Name[goname]\n+\tif name == nil || name.Kind != \"func\" {\n+\t\t// Probably a type conversion.\n+\t\treturn \"\", false\n+\t}\n+\n+\tparams := name.FuncType.Params\n+\targs := call.Call.Args\n+\n \t// Avoid a crash if the number of arguments is\n \t// less than the number of parameters.\n \t// This will be caught when the generated file is compiled.\n-\tif len(call.Call.Args) < len(name.FuncType.Params) {\n-\t\treturn false\n+\tif len(args) < len(params) {\n+\t\treturn \"\", false\n \t}\n \n \tany := false\n-\tfor i, param := range name.FuncType.Params {\n-\t\tif p.needsPointerCheck(f, param.Go, call.Call.Args[i]) {\n+\tfor i, param := range params {\n+\t\tif p.needsPointerCheck(f, param.Go, args[i]) {\n \t\t\tany = true\n \t\t\tbreak\n \t\t}\n \t}\n \tif !any {\n-\t\treturn false\n+\t\treturn \"\", false\n \t}\n \n \t// We need to rewrite this call.\n \t//\n-\t// We are going to rewrite C.f(p) to\n-\t//    func (_cgo0 ptype) {\n+\t// Rewrite C.f(p) to\n+\t//    func() {\n+\t//            _cgo0 := p\n \t//            _cgoCheckPointer(_cgo0)\n \t//            C.f(_cgo0)\n-\t//    }(p)\n-\t// Using a function literal like this lets us do correct\n-\t// argument type checking, and works correctly if the call is\n-\t// deferred.\n+\t//    }()\n+\t// Using a function literal like this lets us evaluate the\n+\t// function arguments only once while doing pointer checks.\n+\t// This is particularly useful when passing additional arguments\n+\t// to _cgoCheckPointer, as done in checkIndex and checkAddr.\n+\t//\n+\t// When the function argument is a conversion to unsafe.Pointer,\n+\t// we unwrap the conversion before checking the pointer,\n+\t// and then wrap again when calling C.f. This lets us check\n+\t// the real type of the pointer in some cases. See issue #25941.\n+\t//\n+\t// When the call to C.f is deferred, we use an additional function\n+\t// literal to evaluate the arguments at the right time.\n+\t//    defer func() func() {\n+\t//            _cgo0 := p\n+\t//            return func() {\n+\t//                    _cgoCheckPointer(_cgo0)\n+\t//                    C.f(_cgo0)\n+\t//            }\n+\t//    }()()\n+\t// This works because the defer statement evaluates the first\n+\t// function literal in order to get the function to call.\n+\n+\tvar sb bytes.Buffer\n+\tsb.WriteString(\"func() \")\n+\tif call.Deferred {\n+\t\tsb.WriteString(\"func() \")\n+\t}\n+\n \tneedsUnsafe := false\n-\tparams := make([]*ast.Field, len(name.FuncType.Params))\n-\tnargs := make([]ast.Expr, len(name.FuncType.Params))\n-\tvar stmts []ast.Stmt\n-\tfor i, param := range name.FuncType.Params {\n-\t\t// params is going to become the parameters of the\n-\t\t// function literal.\n-\t\t// nargs is going to become the list of arguments made\n-\t\t// by the call within the function literal.\n-\t\t// nparam is the parameter of the function literal that\n-\t\t// corresponds to param.\n-\n-\t\torigArg := call.Call.Args[i]\n-\t\tnparam := ast.NewIdent(fmt.Sprintf(\"_cgo%d\", i))\n-\t\tnargs[i] = nparam\n-\n-\t\t// The Go version of the C type might use unsafe.Pointer,\n-\t\t// but the file might not import unsafe.\n-\t\t// Rewrite the Go type if necessary to use _cgo_unsafe.\n-\t\tptype := p.rewriteUnsafe(param.Go)\n-\t\tif ptype != param.Go {\n-\t\t\tneedsUnsafe = true\n+\tresult := false\n+\ttwoResults := false\n+\tif !call.Deferred {\n+\t\t// Check whether this call expects two results.\n+\t\tfor _, ref := range f.Ref {\n+\t\t\tif ref.Expr != &call.Call.Fun {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif ref.Context == ctxCall2 {\n+\t\t\t\tsb.WriteString(\"(\")\n+\t\t\t\tresult = true\n+\t\t\t\ttwoResults = true\n+\t\t\t}\n+\t\t\tbreak\n \t\t}\n \n-\t\tparams[i] = &ast.Field{\n-\t\t\tNames: []*ast.Ident{nparam},\n-\t\t\tType:  ptype,\n+\t\t// Add the result type, if any.\n+\t\tif name.FuncType.Result != nil {\n+\t\t\trtype := p.rewriteUnsafe(name.FuncType.Result.Go)\n+\t\t\tif rtype != name.FuncType.Result.Go {\n+\t\t\t\tneedsUnsafe = true\n+\t\t\t}\n+\t\t\tsb.WriteString(gofmtLine(rtype))\n+\t\t\tresult = true\n \t\t}\n \n-\t\tif !p.needsPointerCheck(f, param.Go, origArg) {\n-\t\t\tcontinue\n+\t\t// Add the second result type, if any.\n+\t\tif twoResults {\n+\t\t\tif name.FuncType.Result == nil {\n+\t\t\t\t// An explicit void result looks odd but it\n+\t\t\t\t// seems to be how cgo has worked historically.\n+\t\t\t\tsb.WriteString(\"_Ctype_void\")\n+\t\t\t}\n+\t\t\tsb.WriteString(\", error)\")\n \t\t}\n+\t}\n \n-\t\t// Run the cgo pointer checks on nparam.\n+\tsb.WriteString(\"{ \")\n \n-\t\t// Change the function literal to call the real function\n-\t\t// with the parameter passed through _cgoCheckPointer.\n-\t\tc := &ast.CallExpr{\n-\t\t\tFun: ast.NewIdent(\"_cgoCheckPointer\"),\n-\t\t\tArgs: []ast.Expr{\n-\t\t\t\tnparam,\n-\t\t\t},\n+\t// Define _cgoN for each argument value.\n+\t// Write _cgoCheckPointer calls to sbCheck.\n+\tvar sbCheck bytes.Buffer\n+\tfor i, param := range params {\n+\t\torigArg := args[i]\n+\t\targ, nu := p.mangle(f, &args[i])\n+\t\tif nu {\n+\t\t\tneedsUnsafe = true\n \t\t}\n \n-\t\t// Add optional additional arguments for an address\n-\t\t// expression.\n-\t\tc.Args = p.checkAddrArgs(f, c.Args, origArg)\n+\t\t// Explicitly convert untyped constants to the\n+\t\t// parameter type, to avoid a type mismatch.\n+\t\tif p.isConst(f, arg) {\n+\t\t\tptype := p.rewriteUnsafe(param.Go)\n+\t\t\tif ptype != param.Go {\n+\t\t\t\tneedsUnsafe = true\n+\t\t\t}\n+\t\t\targ = &ast.CallExpr{\n+\t\t\t\tFun:  ptype,\n+\t\t\t\tArgs: []ast.Expr{arg},\n+\t\t\t}\n+\t\t}\n+\n+\t\tif !p.needsPointerCheck(f, param.Go, args[i]) {\n+\t\t\tfmt.Fprintf(&sb, \"_cgo%d := %s; \", i, gofmtPos(arg, origArg.Pos()))\n+\t\t\tcontinue\n+\t\t}\n \n-\t\tstmt := &ast.ExprStmt{\n-\t\t\tX: c,\n+\t\t// Check for &a[i].\n+\t\tif p.checkIndex(&sb, &sbCheck, arg, i) {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// Check for &x.\n+\t\tif p.checkAddr(&sb, &sbCheck, arg, i) {\n+\t\t\tcontinue\n \t\t}\n-\t\tstmts = append(stmts, stmt)\n+\n+\t\tfmt.Fprintf(&sb, \"_cgo%d := %s; \", i, gofmtPos(arg, origArg.Pos()))\n+\t\tfmt.Fprintf(&sbCheck, \"_cgoCheckPointer(_cgo%d); \", i)\n \t}\n \n-\tconst cgoMarker = \"__cgo__###__marker__\"\n-\tfcall := &ast.CallExpr{\n-\t\tFun:  ast.NewIdent(cgoMarker),\n-\t\tArgs: nargs,\n+\tif call.Deferred {\n+\t\tsb.WriteString(\"return func() { \")\n \t}\n-\tftype := &ast.FuncType{\n-\t\tParams: &ast.FieldList{\n-\t\t\tList: params,\n-\t\t},\n+\n+\t// Write out the calls to _cgoCheckPointer.\n+\tsb.WriteString(sbCheck.String())\n+\n+\tif result {\n+\t\tsb.WriteString(\"return \")\n \t}\n-\tif name.FuncType.Result != nil {\n-\t\trtype := p.rewriteUnsafe(name.FuncType.Result.Go)\n-\t\tif rtype != name.FuncType.Result.Go {\n-\t\t\tneedsUnsafe = true\n-\t\t}\n-\t\tftype.Results = &ast.FieldList{\n-\t\t\tList: []*ast.Field{\n-\t\t\t\t&ast.Field{\n-\t\t\t\t\tType: rtype,\n-\t\t\t\t},\n-\t\t\t},\n-\t\t}\n-\t}\n-\n-\t// If this call expects two results, we have to\n-\t// adjust the results of the function we generated.\n-\tfor _, ref := range f.Ref {\n-\t\tif ref.Expr == &call.Call.Fun && ref.Context == ctxCall2 {\n-\t\t\tif ftype.Results == nil {\n-\t\t\t\t// An explicit void argument\n-\t\t\t\t// looks odd but it seems to\n-\t\t\t\t// be how cgo has worked historically.\n-\t\t\t\tftype.Results = &ast.FieldList{\n-\t\t\t\t\tList: []*ast.Field{\n-\t\t\t\t\t\t&ast.Field{\n-\t\t\t\t\t\t\tType: ast.NewIdent(\"_Ctype_void\"),\n-\t\t\t\t\t\t},\n-\t\t\t\t\t},\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tftype.Results.List = append(ftype.Results.List,\n-\t\t\t\t&ast.Field{\n-\t\t\t\t\tType: ast.NewIdent(\"error\"),\n-\t\t\t\t})\n-\t\t}\n+\n+\tm, nu := p.mangle(f, &call.Call.Fun)\n+\tif nu {\n+\t\tneedsUnsafe = true\n \t}\n+\tsb.WriteString(gofmtLine(m))\n \n-\tvar fbody ast.Stmt\n-\tif ftype.Results == nil {\n-\t\tfbody = &ast.ExprStmt{\n-\t\t\tX: fcall,\n-\t\t}\n-\t} else {\n-\t\tfbody = &ast.ReturnStmt{\n-\t\t\tResults: []ast.Expr{fcall},\n+\tsb.WriteString(\"(\")\n+\tfor i := range params {\n+\t\tif i > 0 {\n+\t\t\tsb.WriteString(\", \")\n \t\t}\n+\t\tfmt.Fprintf(&sb, \"_cgo%d\", i)\n \t}\n-\tlit := &ast.FuncLit{\n-\t\tType: ftype,\n-\t\tBody: &ast.BlockStmt{\n-\t\t\tList: append(stmts, fbody),\n-\t\t},\n+\tsb.WriteString(\"); \")\n+\tif call.Deferred {\n+\t\tsb.WriteString(\"}\")\n \t}\n-\ttext := strings.Replace(gofmt(lit), \"\\n\", \";\", -1)\n-\trepl := strings.Split(text, cgoMarker)\n-\tf.Edit.Insert(f.offset(call.Call.Fun.Pos()), repl[0])\n-\tf.Edit.Insert(f.offset(call.Call.Fun.End()), repl[1])\n+\tsb.WriteString(\"}\")\n+\tif call.Deferred {\n+\t\tsb.WriteString(\"()\")\n+\t}\n+\tsb.WriteString(\"()\")\n \n-\treturn needsUnsafe\n+\treturn sb.String(), needsUnsafe\n }\n \n-// needsPointerCheck returns whether the type t needs a pointer check.\n+// needsPointerCheck reports whether the type t needs a pointer check.\n // This is true if t is a pointer and if the value to which it points\n // might contain a pointer.\n func (p *Package) needsPointerCheck(f *File, t ast.Expr, arg ast.Expr) bool {\n@@ -911,7 +1001,7 @@ func (p *Package) needsPointerCheck(f *File, t ast.Expr, arg ast.Expr) bool {\n \n // hasPointer is used by needsPointerCheck. If top is true it returns\n // whether t is or contains a pointer that might point to a pointer.\n-// If top is false it returns whether t is or contains a pointer.\n+// If top is false it reports whether t is or contains a pointer.\n // f may be nil.\n func (p *Package) hasPointer(f *File, t ast.Expr, top bool) bool {\n \tswitch t := t.(type) {\n@@ -998,19 +1088,68 @@ func (p *Package) hasPointer(f *File, t ast.Expr, top bool) bool {\n \t}\n }\n \n-// checkAddrArgs tries to add arguments to the call of\n-// _cgoCheckPointer when the argument is an address expression. We\n-// pass true to mean that the argument is an address operation of\n-// something other than a slice index, which means that it's only\n-// necessary to check the specific element pointed to, not the entire\n-// object. This is for &s.f, where f is a field in a struct. We can\n-// pass a slice or array, meaning that we should check the entire\n-// slice or array but need not check any other part of the object.\n-// This is for &s.a[i], where we need to check all of a. However, we\n-// only pass the slice or array if we can refer to it without side\n-// effects.\n-func (p *Package) checkAddrArgs(f *File, args []ast.Expr, x ast.Expr) []ast.Expr {\n+// mangle replaces references to C names in arg with the mangled names,\n+// rewriting calls when it finds them.\n+// It removes the corresponding references in f.Ref and f.Calls, so that we\n+// don't try to do the replacement again in rewriteRef or rewriteCall.\n+func (p *Package) mangle(f *File, arg *ast.Expr) (ast.Expr, bool) {\n+\tneedsUnsafe := false\n+\tf.walk(arg, ctxExpr, func(f *File, arg interface{}, context astContext) {\n+\t\tpx, ok := arg.(*ast.Expr)\n+\t\tif !ok {\n+\t\t\treturn\n+\t\t}\n+\t\tsel, ok := (*px).(*ast.SelectorExpr)\n+\t\tif ok {\n+\t\t\tif l, ok := sel.X.(*ast.Ident); !ok || l.Name != \"C\" {\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tfor _, r := range f.Ref {\n+\t\t\t\tif r.Expr == px {\n+\t\t\t\t\t*px = p.rewriteName(f, r)\n+\t\t\t\t\tr.Done = true\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn\n+\t\t}\n+\n+\t\tcall, ok := (*px).(*ast.CallExpr)\n+\t\tif !ok {\n+\t\t\treturn\n+\t\t}\n+\n+\t\tfor _, c := range f.Calls {\n+\t\t\tif !c.Done && c.Call.Lparen == call.Lparen {\n+\t\t\t\tcstr, nu := p.rewriteCall(f, c)\n+\t\t\t\tif cstr != \"\" {\n+\t\t\t\t\t// Smuggle the rewritten call through an ident.\n+\t\t\t\t\t*px = ast.NewIdent(cstr)\n+\t\t\t\t\tif nu {\n+\t\t\t\t\t\tneedsUnsafe = true\n+\t\t\t\t\t}\n+\t\t\t\t\tc.Done = true\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t})\n+\treturn *arg, needsUnsafe\n+}\n+\n+// checkIndex checks whether arg has the form &a[i], possibly inside\n+// type conversions. If so, it writes\n+//    _cgoIndexNN := a\n+//    _cgoNN := &cgoIndexNN[i] // with type conversions, if any\n+// to sb, and writes\n+//    _cgoCheckPointer(_cgoNN, _cgoIndexNN)\n+// to sbCheck, and returns true. This tells _cgoCheckPointer to check\n+// the complete contents of the slice or array being indexed, but no\n+// other part of the memory allocation.\n+func (p *Package) checkIndex(sb, sbCheck *bytes.Buffer, arg ast.Expr, i int) bool {\n \t// Strip type conversions.\n+\tx := arg\n \tfor {\n \t\tc, ok := x.(*ast.CallExpr)\n \t\tif !ok || len(c.Args) != 1 || !p.isType(c.Fun) {\n@@ -1020,40 +1159,63 @@ func (p *Package) checkAddrArgs(f *File, args []ast.Expr, x ast.Expr) []ast.Expr\n \t}\n \tu, ok := x.(*ast.UnaryExpr)\n \tif !ok || u.Op != token.AND {\n-\t\treturn args\n+\t\treturn false\n \t}\n \tindex, ok := u.X.(*ast.IndexExpr)\n \tif !ok {\n-\t\t// This is the address of something that is not an\n-\t\t// index expression. We only need to examine the\n-\t\t// single value to which it points.\n-\t\t// TODO: what if true is shadowed?\n-\t\treturn append(args, ast.NewIdent(\"true\"))\n-\t}\n-\tif !p.hasSideEffects(f, index.X) {\n-\t\t// Examine the entire slice.\n-\t\treturn append(args, index.X)\n-\t}\n-\t// Treat the pointer as unknown.\n-\treturn args\n+\t\treturn false\n+\t}\n+\n+\tfmt.Fprintf(sb, \"_cgoIndex%d := %s; \", i, gofmtPos(index.X, index.X.Pos()))\n+\torigX := index.X\n+\tindex.X = ast.NewIdent(fmt.Sprintf(\"_cgoIndex%d\", i))\n+\tfmt.Fprintf(sb, \"_cgo%d := %s; \", i, gofmtPos(arg, arg.Pos()))\n+\tindex.X = origX\n+\n+\tfmt.Fprintf(sbCheck, \"_cgoCheckPointer(_cgo%d, _cgoIndex%d); \", i, i)\n+\n+\treturn true\n }\n \n-// hasSideEffects returns whether the expression x has any side\n-// effects.  x is an expression, not a statement, so the only side\n-// effect is a function call.\n-func (p *Package) hasSideEffects(f *File, x ast.Expr) bool {\n-\tfound := false\n-\tf.walk(x, ctxExpr,\n-\t\tfunc(f *File, x interface{}, context astContext) {\n-\t\t\tswitch x.(type) {\n-\t\t\tcase *ast.CallExpr:\n-\t\t\t\tfound = true\n-\t\t\t}\n-\t\t})\n-\treturn found\n+// checkAddr checks whether arg has the form &x, possibly inside type\n+// conversions. If so, it writes\n+//    _cgoBaseNN := &x\n+//    _cgoNN := _cgoBaseNN // with type conversions, if any\n+// to sb, and writes\n+//    _cgoCheckPointer(_cgoBaseNN, true)\n+// to sbCheck, and returns true. This tells _cgoCheckPointer to check\n+// just the contents of the pointer being passed, not any other part\n+// of the memory allocation. This is run after checkIndex, which looks\n+// for the special case of &a[i], which requires different checks.\n+func (p *Package) checkAddr(sb, sbCheck *bytes.Buffer, arg ast.Expr, i int) bool {\n+\t// Strip type conversions.\n+\tpx := &arg\n+\tfor {\n+\t\tc, ok := (*px).(*ast.CallExpr)\n+\t\tif !ok || len(c.Args) != 1 || !p.isType(c.Fun) {\n+\t\t\tbreak\n+\t\t}\n+\t\tpx = &c.Args[0]\n+\t}\n+\tif u, ok := (*px).(*ast.UnaryExpr); !ok || u.Op != token.AND {\n+\t\treturn false\n+\t}\n+\n+\tfmt.Fprintf(sb, \"_cgoBase%d := %s; \", i, gofmtPos(*px, (*px).Pos()))\n+\n+\torigX := *px\n+\t*px = ast.NewIdent(fmt.Sprintf(\"_cgoBase%d\", i))\n+\tfmt.Fprintf(sb, \"_cgo%d := %s; \", i, gofmtPos(arg, arg.Pos()))\n+\t*px = origX\n+\n+\t// Use \"0 == 0\" to do the right thing in the unlikely event\n+\t// that \"true\" is shadowed.\n+\tfmt.Fprintf(sbCheck, \"_cgoCheckPointer(_cgoBase%d, 0 == 0); \", i)\n+\n+\treturn true\n }\n \n-// isType returns whether the expression is definitely a type.\n+// isType reports whether the expression is definitely a type.\n // This is conservative--it returns false for an unknown identifier.\n func (p *Package) isType(t ast.Expr) bool {\n \tswitch t := t.(type) {\n@@ -1082,6 +1244,9 @@ func (p *Package) isType(t ast.Expr) bool {\n \n \t\t\treturn true\n \t\t}\n+\t\tif strings.HasPrefix(t.Name, \"_Ctype_\") {\n+\t\t\treturn true\n+\t\t}\n \tcase *ast.StarExpr:\n \t\treturn p.isType(t.X)\n \tcase *ast.ArrayType, *ast.StructType, *ast.FuncType, *ast.InterfaceType,\n@@ -1092,6 +1257,47 @@ func (p *Package) isType(t ast.Expr) bool {\n \treturn false\n }\n \n+// isConst reports whether x is an untyped constant expression.\n+func (p *Package) isConst(f *File, x ast.Expr) bool {\n+\tswitch x := x.(type) {\n+\tcase *ast.BasicLit:\n+\t\treturn true\n+\tcase *ast.SelectorExpr:\n+\t\tid, ok := x.X.(*ast.Ident)\n+\t\tif !ok || id.Name != \"C\" {\n+\t\t\treturn false\n+\t\t}\n+\t\tname := f.Name[x.Sel.Name]\n+\t\tif name != nil {\n+\t\t\treturn name.IsConst()\n+\t\t}\n+\tcase *ast.Ident:\n+\t\treturn x.Name == \"nil\" ||\n+\t\t\tstrings.HasPrefix(x.Name, \"_Ciconst_\") ||\n+\t\t\tstrings.HasPrefix(x.Name, \"_Cfconst_\") ||\n+\t\t\tstrings.HasPrefix(x.Name, \"_Csconst_\") ||\n+\t\t\tconsts[x.Name]\n+\tcase *ast.UnaryExpr:\n+\t\treturn p.isConst(f, x.X)\n+\tcase *ast.BinaryExpr:\n+\t\treturn p.isConst(f, x.X) && p.isConst(f, x.Y)\n+\tcase *ast.ParenExpr:\n+\t\treturn p.isConst(f, x.X)\n+\tcase *ast.CallExpr:\n+\t\t// Calling the builtin function complex on two untyped\n+\t\t// constants returns an untyped constant.\n+\t\t// TODO: It's possible to construct a case that will\n+\t\t// erroneously succeed if there is a local function\n+\t\t// named \"complex\", shadowing the builtin, that returns\n+\t\t// a numeric type. I can't think of any cases that will\n+\t\t// erroneously fail.\n+\t\tif id, ok := x.Fun.(*ast.Ident); ok && id.Name == \"complex\" && len(x.Args) == 2 {\n+\t\t\treturn p.isConst(f, x.Args[0]) && p.isConst(f, x.Args[1])\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n // rewriteUnsafe returns a version of t with references to unsafe.Pointer\n // rewritten to use _cgo_unsafe.Pointer instead.\n func (p *Package) rewriteUnsafe(t ast.Expr) ast.Expr {\n@@ -1150,24 +1356,7 @@ func (p *Package) rewriteRef(f *File) {\n \t// code for them.\n \tfunctions := make(map[string]bool)\n \n-\t// Assign mangled names.\n \tfor _, n := range f.Name {\n-\t\tif n.Kind == \"not-type\" {\n-\t\t\tif n.Define == \"\" {\n-\t\t\t\tn.Kind = \"var\"\n-\t\t\t} else {\n-\t\t\t\tn.Kind = \"macro\"\n-\t\t\t\tn.FuncType = &FuncType{\n-\t\t\t\t\tResult: n.Type,\n-\t\t\t\t\tGo: &ast.FuncType{\n-\t\t\t\t\t\tResults: &ast.FieldList{List: []*ast.Field{{Type: n.Type.Go}}},\n-\t\t\t\t\t},\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\tif n.Mangle == \"\" {\n-\t\t\tp.mangleName(n)\n-\t\t}\n \t\tif n.Kind == \"func\" {\n \t\t\tfunctions[n.Go] = false\n \t\t}\n@@ -1181,104 +1370,16 @@ func (p *Package) rewriteRef(f *File) {\n \t\tif r.Name.IsConst() && r.Name.Const == \"\" {\n \t\t\terror_(r.Pos(), \"unable to find value of constant C.%s\", fixGo(r.Name.Go))\n \t\t}\n-\t\tvar expr ast.Expr = ast.NewIdent(r.Name.Mangle) // default\n-\t\tswitch r.Context {\n-\t\tcase ctxCall, ctxCall2:\n-\t\t\tif r.Name.Kind != \"func\" {\n-\t\t\t\tif r.Name.Kind == \"type\" {\n-\t\t\t\t\tr.Context = ctxType\n-\t\t\t\t\tif r.Name.Type == nil {\n-\t\t\t\t\t\terror_(r.Pos(), \"invalid conversion to C.%s: undefined C type '%s'\", fixGo(r.Name.Go), r.Name.C)\n-\t\t\t\t\t\tbreak\n-\t\t\t\t\t}\n-\t\t\t\t\texpr = r.Name.Type.Go\n-\t\t\t\t\tbreak\n-\t\t\t\t}\n-\t\t\t\terror_(r.Pos(), \"call of non-function C.%s\", fixGo(r.Name.Go))\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tfunctions[r.Name.Go] = true\n-\t\t\tif r.Context == ctxCall2 {\n-\t\t\t\tif r.Name.Go == \"_CMalloc\" {\n-\t\t\t\t\terror_(r.Pos(), \"no two-result form for C.malloc\")\n-\t\t\t\t\tbreak\n-\t\t\t\t}\n-\t\t\t\t// Invent new Name for the two-result function.\n-\t\t\t\tn := f.Name[\"2\"+r.Name.Go]\n-\t\t\t\tif n == nil {\n-\t\t\t\t\tn = new(Name)\n-\t\t\t\t\t*n = *r.Name\n-\t\t\t\t\tn.AddError = true\n-\t\t\t\t\tn.Mangle = \"_C2func_\" + n.Go\n-\t\t\t\t\tf.Name[\"2\"+r.Name.Go] = n\n-\t\t\t\t}\n-\t\t\t\texpr = ast.NewIdent(n.Mangle)\n-\t\t\t\tr.Name = n\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\tcase ctxExpr:\n-\t\t\tswitch r.Name.Kind {\n-\t\t\tcase \"func\":\n-\t\t\t\tif builtinDefs[r.Name.C] != \"\" {\n-\t\t\t\t\terror_(r.Pos(), \"use of builtin '%s' not in function call\", fixGo(r.Name.C))\n-\t\t\t\t}\n \n-\t\t\t\t// Function is being used in an expression, to e.g. pass around a C function pointer.\n-\t\t\t\t// Create a new Name for this Ref which causes the variable to be declared in Go land.\n-\t\t\t\tfpName := \"fp_\" + r.Name.Go\n-\t\t\t\tname := f.Name[fpName]\n-\t\t\t\tif name == nil {\n-\t\t\t\t\tname = &Name{\n-\t\t\t\t\t\tGo:   fpName,\n-\t\t\t\t\t\tC:    r.Name.C,\n-\t\t\t\t\t\tKind: \"fpvar\",\n-\t\t\t\t\t\tType: &Type{Size: p.PtrSize, Align: p.PtrSize, C: c(\"void*\"), Go: ast.NewIdent(\"unsafe.Pointer\")},\n-\t\t\t\t\t}\n-\t\t\t\t\tp.mangleName(name)\n-\t\t\t\t\tf.Name[fpName] = name\n-\t\t\t\t}\n-\t\t\t\tr.Name = name\n-\t\t\t\t// Rewrite into call to _Cgo_ptr to prevent assignments. The _Cgo_ptr\n-\t\t\t\t// function is defined in out.go and simply returns its argument. See\n-\t\t\t\t// issue 7757.\n-\t\t\t\texpr = &ast.CallExpr{\n-\t\t\t\t\tFun:  &ast.Ident{NamePos: (*r.Expr).Pos(), Name: \"_Cgo_ptr\"},\n-\t\t\t\t\tArgs: []ast.Expr{ast.NewIdent(name.Mangle)},\n-\t\t\t\t}\n-\t\t\tcase \"type\":\n-\t\t\t\t// Okay - might be new(T)\n-\t\t\t\tif r.Name.Type == nil {\n-\t\t\t\t\terror_(r.Pos(), \"expression C.%s: undefined C type '%s'\", fixGo(r.Name.Go), r.Name.C)\n-\t\t\t\t\tbreak\n-\t\t\t\t}\n-\t\t\t\texpr = r.Name.Type.Go\n-\t\t\tcase \"var\":\n-\t\t\t\texpr = &ast.StarExpr{Star: (*r.Expr).Pos(), X: expr}\n-\t\t\tcase \"macro\":\n-\t\t\t\texpr = &ast.CallExpr{Fun: expr}\n-\t\t\t}\n-\t\tcase ctxSelector:\n-\t\t\tif r.Name.Kind == \"var\" {\n-\t\t\t\texpr = &ast.StarExpr{Star: (*r.Expr).Pos(), X: expr}\n-\t\t\t} else {\n-\t\t\t\terror_(r.Pos(), \"only C variables allowed in selector expression %s\", fixGo(r.Name.Go))\n-\t\t\t}\n-\t\tcase ctxType:\n-\t\t\tif r.Name.Kind != \"type\" {\n-\t\t\t\terror_(r.Pos(), \"expression C.%s used as type\", fixGo(r.Name.Go))\n-\t\t\t} else if r.Name.Type == nil {\n-\t\t\t\t// Use of C.enum_x, C.struct_x or C.union_x without C definition.\n-\t\t\t\t// GCC won't raise an error when using pointers to such unknown types.\n-\t\t\t\terror_(r.Pos(), \"type C.%s: undefined C type '%s'\", fixGo(r.Name.Go), r.Name.C)\n-\t\t\t} else {\n-\t\t\t\texpr = r.Name.Type.Go\n-\t\t\t}\n-\t\tdefault:\n-\t\t\tif r.Name.Kind == \"func\" {\n-\t\t\t\terror_(r.Pos(), \"must call C.%s\", fixGo(r.Name.Go))\n+\t\tif r.Name.Kind == \"func\" {\n+\t\t\tswitch r.Context {\n+\t\t\tcase ctxCall, ctxCall2:\n+\t\t\t\tfunctions[r.Name.Go] = true\n \t\t\t}\n \t\t}\n \n+\t\texpr := p.rewriteName(f, r)\n+\n \t\tif *godefs {\n \t\t\t// Substitute definition for mangled type name.\n \t\t\tif id, ok := expr.(*ast.Ident); ok {\n@@ -1295,8 +1396,7 @@ func (p *Package) rewriteRef(f *File) {\n \t\t// in case expression being replaced is first on line.\n \t\t// See golang.org/issue/6563.\n \t\tpos := (*r.Expr).Pos()\n-\t\tswitch x := expr.(type) {\n-\t\tcase *ast.Ident:\n+\t\tif x, ok := expr.(*ast.Ident); ok {\n \t\t\texpr = &ast.Ident{NamePos: pos, Name: x.Name}\n \t\t}\n \n@@ -1306,11 +1406,26 @@ func (p *Package) rewriteRef(f *File) {\n \t\t*r.Expr = expr\n \n \t\t// Record source-level edit for cgo output.\n-\t\trepl := gofmt(expr)\n-\t\tif r.Name.Kind != \"type\" {\n-\t\t\trepl = \"(\" + repl + \")\"\n+\t\tif !r.Done {\n+\t\t\t// Prepend a space in case the earlier code ends\n+\t\t\t// with '/', which would give us a \"//\" comment.\n+\t\t\trepl := \" \" + gofmtPos(expr, old.Pos())\n+\t\t\tend := fset.Position(old.End())\n+\t\t\t// Subtract 1 from the column if we are going to\n+\t\t\t// append a close parenthesis. That will set the\n+\t\t\t// correct column for the following characters.\n+\t\t\tsub := 0\n+\t\t\tif r.Name.Kind != \"type\" {\n+\t\t\t\tsub = 1\n+\t\t\t}\n+\t\t\tif end.Column > sub {\n+\t\t\t\trepl = fmt.Sprintf(\"%s /*line :%d:%d*/\", repl, end.Line, end.Column-sub)\n+\t\t\t}\n+\t\t\tif r.Name.Kind != \"type\" {\n+\t\t\t\trepl = \"(\" + repl + \")\"\n+\t\t\t}\n+\t\t\tf.Edit.Replace(f.offset(old.Pos()), f.offset(old.End()), repl)\n \t\t}\n-\t\tf.Edit.Replace(f.offset(old.Pos()), f.offset(old.End()), repl)\n \t}\n \n \t// Remove functions only used as expressions, so their respective\n@@ -1322,6 +1437,118 @@ func (p *Package) rewriteRef(f *File) {\n \t}\n }\n \n+// rewriteName returns the expression used to rewrite a reference.\n+func (p *Package) rewriteName(f *File, r *Ref) ast.Expr {\n+\tvar expr ast.Expr = ast.NewIdent(r.Name.Mangle) // default\n+\tswitch r.Context {\n+\tcase ctxCall, ctxCall2:\n+\t\tif r.Name.Kind != \"func\" {\n+\t\t\tif r.Name.Kind == \"type\" {\n+\t\t\t\tr.Context = ctxType\n+\t\t\t\tif r.Name.Type == nil {\n+\t\t\t\t\terror_(r.Pos(), \"invalid conversion to C.%s: undefined C type '%s'\", fixGo(r.Name.Go), r.Name.C)\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\texpr = r.Name.Type.Go\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\terror_(r.Pos(), \"call of non-function C.%s\", fixGo(r.Name.Go))\n+\t\t\tbreak\n+\t\t}\n+\t\tif r.Context == ctxCall2 {\n+\t\t\tif r.Name.Go == \"_CMalloc\" {\n+\t\t\t\terror_(r.Pos(), \"no two-result form for C.malloc\")\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\t// Invent new Name for the two-result function.\n+\t\t\tn := f.Name[\"2\"+r.Name.Go]\n+\t\t\tif n == nil {\n+\t\t\t\tn = new(Name)\n+\t\t\t\t*n = *r.Name\n+\t\t\t\tn.AddError = true\n+\t\t\t\tn.Mangle = \"_C2func_\" + n.Go\n+\t\t\t\tf.Name[\"2\"+r.Name.Go] = n\n+\t\t\t}\n+\t\t\texpr = ast.NewIdent(n.Mangle)\n+\t\t\tr.Name = n\n+\t\t\tbreak\n+\t\t}\n+\tcase ctxExpr:\n+\t\tswitch r.Name.Kind {\n+\t\tcase \"func\":\n+\t\t\tif builtinDefs[r.Name.C] != \"\" {\n+\t\t\t\terror_(r.Pos(), \"use of builtin '%s' not in function call\", fixGo(r.Name.C))\n+\t\t\t}\n+\n+\t\t\t// Function is being used in an expression, to e.g. pass around a C function pointer.\n+\t\t\t// Create a new Name for this Ref which causes the variable to be declared in Go land.\n+\t\t\tfpName := \"fp_\" + r.Name.Go\n+\t\t\tname := f.Name[fpName]\n+\t\t\tif name == nil {\n+\t\t\t\tname = &Name{\n+\t\t\t\t\tGo:   fpName,\n+\t\t\t\t\tC:    r.Name.C,\n+\t\t\t\t\tKind: \"fpvar\",\n+\t\t\t\t\tType: &Type{Size: p.PtrSize, Align: p.PtrSize, C: c(\"void*\"), Go: ast.NewIdent(\"unsafe.Pointer\")},\n+\t\t\t\t}\n+\t\t\t\tp.mangleName(name)\n+\t\t\t\tf.Name[fpName] = name\n+\t\t\t}\n+\t\t\tr.Name = name\n+\t\t\t// Rewrite into call to _Cgo_ptr to prevent assignments. The _Cgo_ptr\n+\t\t\t// function is defined in out.go and simply returns its argument. See\n+\t\t\t// issue 7757.\n+\t\t\texpr = &ast.CallExpr{\n+\t\t\t\tFun:  &ast.Ident{NamePos: (*r.Expr).Pos(), Name: \"_Cgo_ptr\"},\n+\t\t\t\tArgs: []ast.Expr{ast.NewIdent(name.Mangle)},\n+\t\t\t}\n+\t\tcase \"type\":\n+\t\t\t// Okay - might be new(T)\n+\t\t\tif r.Name.Type == nil {\n+\t\t\t\terror_(r.Pos(), \"expression C.%s: undefined C type '%s'\", fixGo(r.Name.Go), r.Name.C)\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\texpr = r.Name.Type.Go\n+\t\tcase \"var\":\n+\t\t\texpr = &ast.StarExpr{Star: (*r.Expr).Pos(), X: expr}\n+\t\tcase \"macro\":\n+\t\t\texpr = &ast.CallExpr{Fun: expr}\n+\t\t}\n+\tcase ctxSelector:\n+\t\tif r.Name.Kind == \"var\" {\n+\t\t\texpr = &ast.StarExpr{Star: (*r.Expr).Pos(), X: expr}\n+\t\t} else {\n+\t\t\terror_(r.Pos(), \"only C variables allowed in selector expression %s\", fixGo(r.Name.Go))\n+\t\t}\n+\tcase ctxType:\n+\t\tif r.Name.Kind != \"type\" {\n+\t\t\terror_(r.Pos(), \"expression C.%s used as type\", fixGo(r.Name.Go))\n+\t\t} else if r.Name.Type == nil {\n+\t\t\t// Use of C.enum_x, C.struct_x or C.union_x without C definition.\n+\t\t\t// GCC won't raise an error when using pointers to such unknown types.\n+\t\t\terror_(r.Pos(), \"type C.%s: undefined C type '%s'\", fixGo(r.Name.Go), r.Name.C)\n+\t\t} else {\n+\t\t\texpr = r.Name.Type.Go\n+\t\t}\n+\tdefault:\n+\t\tif r.Name.Kind == \"func\" {\n+\t\t\terror_(r.Pos(), \"must call C.%s\", fixGo(r.Name.Go))\n+\t\t}\n+\t}\n+\treturn expr\n+}\n+\n+// gofmtPos returns the gofmt-formatted string for an AST node,\n+// with a comment setting the position before the node.\n+func gofmtPos(n ast.Expr, pos token.Pos) string {\n+\ts := gofmtLine(n)\n+\tp := fset.Position(pos)\n+\tif p.Column == 0 {\n+\t\treturn s\n+\t}\n+\treturn fmt.Sprintf(\"/*line :%d:%d*/%s\", p.Line, p.Column, s)\n+}\n+\n // gccBaseCmd returns the start of the compiler command line.\n // It uses $CC if set, or else $GCC, or else the compiler recorded\n // during the initial build as defaultCC.\n@@ -1400,6 +1627,9 @@ func (p *Package) gccCmd() []string {\n \n \tc = append(c, p.GccOptions...)\n \tc = append(c, p.gccMachine()...)\n+\tif goos == \"aix\" {\n+\t\tc = append(c, \"-maix64\")\n+\t}\n \tc = append(c, \"-\") //read input from standard input\n \treturn c\n }\n@@ -1754,10 +1984,8 @@ func (p *Package) gccDebug(stdin []byte, nnames int) (d *dwarf.Data, ints []int6\n \t\t}\n \n \t\tbuildStrings()\n-\n \t\treturn d, ints, floats, strs\n \t}\n-\n \tfatalf(\"cannot parse gcc output %s as ELF, Mach-O, PE, XCOFF object\", gccTmp())\n \tpanic(\"not reached\")\n }\n@@ -1788,6 +2016,11 @@ func (p *Package) gccErrors(stdin []byte) string {\n \t\t}\n \t}\n \n+\t// Force -O0 optimization but keep the trailing \"-\" at the end.\n+\tnargs = append(nargs, \"-O0\")\n+\tnl := len(nargs)\n+\tnargs[nl-2], nargs[nl-1] = nargs[nl-1], nargs[nl-2]\n+\n \tif *debugGcc {\n \t\tfmt.Fprintf(os.Stderr, \"$ %s <<EOF\\n\", strings.Join(nargs, \" \"))\n \t\tos.Stderr.Write(stdin)\n@@ -1829,10 +2062,10 @@ func runGcc(stdin []byte, args []string) (string, string) {\n // with equivalent memory layout.\n type typeConv struct {\n \t// Cache of already-translated or in-progress types.\n-\tm map[dwarf.Type]*Type\n+\tm map[string]*Type\n \n \t// Map from types to incomplete pointers to those types.\n-\tptrs map[dwarf.Type][]*Type\n+\tptrs map[string][]*Type\n \t// Keys of ptrs in insertion order (deterministic worklist)\n \t// ptrKeys contains exactly the keys in ptrs.\n \tptrKeys []dwarf.Type\n@@ -1867,8 +2100,8 @@ var unionWithPointer = make(map[ast.Expr]bool)\n func (c *typeConv) Init(ptrSize, intSize int64) {\n \tc.ptrSize = ptrSize\n \tc.intSize = intSize\n-\tc.m = make(map[dwarf.Type]*Type)\n-\tc.ptrs = make(map[dwarf.Type][]*Type)\n+\tc.m = make(map[string]*Type)\n+\tc.ptrs = make(map[string][]*Type)\n \tc.getTypeIDs = make(map[string]bool)\n \tc.bool = c.Ident(\"bool\")\n \tc.byte = c.Ident(\"byte\")\n@@ -1976,11 +2209,12 @@ func (c *typeConv) FinishType(pos token.Pos) {\n \t// Keep looping until they're all done.\n \tfor len(c.ptrKeys) > 0 {\n \t\tdtype := c.ptrKeys[0]\n+\t\tdtypeKey := dtype.String()\n \t\tc.ptrKeys = c.ptrKeys[1:]\n-\t\tptrs := c.ptrs[dtype]\n-\t\tdelete(c.ptrs, dtype)\n+\t\tptrs := c.ptrs[dtypeKey]\n+\t\tdelete(c.ptrs, dtypeKey)\n \n-\t\t// Note Type might invalidate c.ptrs[dtype].\n+\t\t// Note Type might invalidate c.ptrs[dtypeKey].\n \t\tt := c.Type(dtype, pos)\n \t\tfor _, ptr := range ptrs {\n \t\t\tptr.Go.(*ast.StarExpr).X = t.Go\n@@ -1992,18 +2226,29 @@ func (c *typeConv) FinishType(pos token.Pos) {\n // Type returns a *Type with the same memory layout as\n // dtype when used as the type of a variable or a struct field.\n func (c *typeConv) Type(dtype dwarf.Type, pos token.Pos) *Type {\n-\tif t, ok := c.m[dtype]; ok {\n-\t\tif t.Go == nil {\n-\t\t\tfatalf(\"%s: type conversion loop at %s\", lineno(pos), dtype)\n+\t// Always recompute bad pointer typedefs, as the set of such\n+\t// typedefs changes as we see more types.\n+\tcheckCache := true\n+\tif dtt, ok := dtype.(*dwarf.TypedefType); ok && c.badPointerTypedef(dtt) {\n+\t\tcheckCache = false\n+\t}\n+\n+\tkey := dtype.String()\n+\n+\tif checkCache {\n+\t\tif t, ok := c.m[key]; ok {\n+\t\t\tif t.Go == nil {\n+\t\t\t\tfatalf(\"%s: type conversion loop at %s\", lineno(pos), dtype)\n+\t\t\t}\n+\t\t\treturn t\n \t\t}\n-\t\treturn t\n \t}\n \n \tt := new(Type)\n \tt.Size = dtype.Size() // note: wrong for array of pointers, corrected below\n \tt.Align = -1\n \tt.C = &TypeRepr{Repr: dtype.Common().Name}\n-\tc.m[dtype] = t\n+\tc.m[key] = t\n \n \tswitch dt := dtype.(type) {\n \tdefault:\n@@ -2166,10 +2411,11 @@ func (c *typeConv) Type(dtype dwarf.Type, pos token.Pos) *Type {\n \t\t// Placeholder initialization; completed in FinishType.\n \t\tt.Go = &ast.StarExpr{}\n \t\tt.C.Set(\"<incomplete>*\")\n-\t\tif _, ok := c.ptrs[dt.Type]; !ok {\n+\t\tkey := dt.Type.String()\n+\t\tif _, ok := c.ptrs[key]; !ok {\n \t\t\tc.ptrKeys = append(c.ptrKeys, dt.Type)\n \t\t}\n-\t\tc.ptrs[dt.Type] = append(c.ptrs[dt.Type], t)\n+\t\tc.ptrs[key] = append(c.ptrs[key], t)\n \n \tcase *dwarf.QualType:\n \t\tt1 := c.Type(dt.Type, pos)\n@@ -2557,11 +2803,6 @@ func (c *typeConv) Struct(dt *dwarf.StructType, pos token.Pos) (expr *ast.Struct\n \n \tanon := 0\n \tfor _, f := range dt.Field {\n-\t\tif f.ByteOffset > off {\n-\t\t\tfld, sizes = c.pad(fld, sizes, f.ByteOffset-off)\n-\t\t\toff = f.ByteOffset\n-\t\t}\n-\n \t\tname := f.Name\n \t\tft := f.Type\n \n@@ -2610,6 +2851,19 @@ func (c *typeConv) Struct(dt *dwarf.StructType, pos token.Pos) (expr *ast.Struct\n \t\t\t// structs are in system headers that cannot be corrected.\n \t\t\tcontinue\n \t\t}\n+\n+\t\t// Round off up to talign, assumed to be a power of 2.\n+\t\toff = (off + talign - 1) &^ (talign - 1)\n+\n+\t\tif f.ByteOffset > off {\n+\t\t\tfld, sizes = c.pad(fld, sizes, f.ByteOffset-off)\n+\t\t\toff = f.ByteOffset\n+\t\t}\n+\t\tif f.ByteOffset < off {\n+\t\t\t// Drop a packed field that we can't represent.\n+\t\t\tcontinue\n+\t\t}\n+\n \t\tn := len(fld)\n \t\tfld = fld[0 : n+1]\n \t\tif name == \"\" {\n@@ -2659,7 +2913,7 @@ func (c *typeConv) Struct(dt *dwarf.StructType, pos token.Pos) (expr *ast.Struct\n \treturn\n }\n \n-// dwarfHasPointer returns whether the DWARF type dt contains a pointer.\n+// dwarfHasPointer reports whether the DWARF type dt contains a pointer.\n func (c *typeConv) dwarfHasPointer(dt dwarf.Type, pos token.Pos) bool {\n \tswitch dt := dt.(type) {\n \tdefault:\n@@ -2776,6 +3030,9 @@ func (c *typeConv) badPointerTypedef(dt *dwarf.TypedefType) bool {\n \tif c.badJNI(dt) {\n \t\treturn true\n \t}\n+\tif c.badEGLDisplay(dt) {\n+\t\treturn true\n+\t}\n \treturn false\n }\n \n@@ -2912,6 +3169,19 @@ func (c *typeConv) badJNI(dt *dwarf.TypedefType) bool {\n \treturn false\n }\n \n+func (c *typeConv) badEGLDisplay(dt *dwarf.TypedefType) bool {\n+\tif dt.Name != \"EGLDisplay\" {\n+\t\treturn false\n+\t}\n+\t// Check that the typedef is \"typedef void *EGLDisplay\".\n+\tif ptr, ok := dt.Type.(*dwarf.PtrType); ok {\n+\t\tif _, ok := ptr.Type.(*dwarf.VoidType); ok {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n // jniTypes maps from JNI types that we want to be uintptrs, to the underlying type to which\n // they are mapped. The base \"jobject\" maps to the empty string.\n var jniTypes = map[string]string{"}, {"sha": "9c763a22fb01c23318b479f0f48330aa539cba3f", "filename": "libgo/go/cmd/cgo/godefs.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fcgo%2Fgodefs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fcgo%2Fgodefs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fgodefs.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -126,3 +126,9 @@ func gofmt(n interface{}) string {\n \t}\n \treturn gofmtBuf.String()\n }\n+\n+// gofmtLine returns the gofmt-formatted string for an AST node,\n+// ensuring that it is on a single line.\n+func gofmtLine(n interface{}) string {\n+\treturn strings.Replace(gofmt(n), \"\\n\", \";\", -1)\n+}"}, {"sha": "4a5c0ca2babb7360eb7f5c2e271dacd8168c9481", "filename": "libgo/go/cmd/cgo/main.go", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fcgo%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fcgo%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fmain.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -47,7 +47,14 @@ type Package struct {\n \tGccFiles    []string        // list of gcc output files\n \tPreamble    string          // collected preamble for _cgo_export.h\n \ttypedefs    map[string]bool // type names that appear in the types of the objects we're interested in\n-\ttypedefList []string\n+\ttypedefList []typedefInfo\n+}\n+\n+// A typedefInfo is an element on Package.typedefList: a typedef name\n+// and the position where it was required.\n+type typedefInfo struct {\n+\ttypedef string\n+\tpos     token.Pos\n }\n \n // A File collects information about a single Go input file.\n@@ -64,6 +71,9 @@ type File struct {\n \tEdit     *edit.Buffer\n }\n \n+// Untyped constants in the current package.\n+var consts = make(map[string]bool)\n+\n func (f *File) offset(p token.Pos) int {\n \treturn fset.Position(p).Offset\n }\n@@ -81,26 +91,30 @@ func nameKeys(m map[string]*Name) []string {\n type Call struct {\n \tCall     *ast.CallExpr\n \tDeferred bool\n+\tDone     bool\n }\n \n // A Ref refers to an expression of the form C.xxx in the AST.\n type Ref struct {\n \tName    *Name\n \tExpr    *ast.Expr\n \tContext astContext\n+\tDone    bool\n }\n \n func (r *Ref) Pos() token.Pos {\n \treturn (*r.Expr).Pos()\n }\n \n+var nameKinds = []string{\"iconst\", \"fconst\", \"sconst\", \"type\", \"var\", \"fpvar\", \"func\", \"macro\", \"not-type\"}\n+\n // A Name collects information about C.xxx.\n type Name struct {\n \tGo       string // name used in Go referring to package C\n \tMangle   string // name used in generated Go\n \tC        string // name used in C\n \tDefine   string // #define expansion\n-\tKind     string // \"iconst\", \"fconst\", \"sconst\", \"type\", \"var\", \"fpvar\", \"func\", \"macro\", \"not-type\"\n+\tKind     string // one of the nameKinds\n \tType     *Type  // the type of xxx\n \tFuncType *FuncType\n \tAddError bool"}, {"sha": "f44da9c8b12ff9fe031264e4a2bed6bf5069f302", "filename": "libgo/go/cmd/cgo/out.go", "status": "modified", "additions": 41, "deletions": 5, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -9,11 +9,11 @@ import (\n \t\"debug/elf\"\n \t\"debug/macho\"\n \t\"debug/pe\"\n-\t\"debug/xcoff\"\n \t\"fmt\"\n \t\"go/ast\"\n \t\"go/printer\"\n \t\"go/token\"\n+\t\"internal/xcoff\"\n \t\"io\"\n \t\"io/ioutil\"\n \t\"os\"\n@@ -251,7 +251,22 @@ func (p *Package) writeDefs() {\n \n \tinit := gccgoInit.String()\n \tif init != \"\" {\n-\t\tfmt.Fprintln(fc, \"static void init(void) __attribute__ ((constructor));\")\n+\t\t// The init function does nothing but simple\n+\t\t// assignments, so it won't use much stack space, so\n+\t\t// it's OK to not split the stack. Splitting the stack\n+\t\t// can run into a bug in clang (as of 2018-11-09):\n+\t\t// this is a leaf function, and when clang sees a leaf\n+\t\t// function it won't emit the split stack prologue for\n+\t\t// the function. However, if this function refers to a\n+\t\t// non-split-stack function, which will happen if the\n+\t\t// cgo code refers to a C function not compiled with\n+\t\t// -fsplit-stack, then the linker will think that it\n+\t\t// needs to adjust the split stack prologue, but there\n+\t\t// won't be one. Marking the function explicitly\n+\t\t// no_split_stack works around this problem by telling\n+\t\t// the linker that it's OK if there is no split stack\n+\t\t// prologue.\n+\t\tfmt.Fprintln(fc, \"static void init(void) __attribute__ ((constructor, no_split_stack));\")\n \t\tfmt.Fprintln(fc, \"static void init(void) {\")\n \t\tfmt.Fprint(fc, init)\n \t\tfmt.Fprintln(fc, \"}\")\n@@ -1193,7 +1208,7 @@ func (p *Package) writeExportHeader(fgcch io.Writer) {\n \tfmt.Fprintf(fgcch, \"%s\\n\", p.gccExportHeaderProlog())\n }\n \n-// gccgoUsesNewMangling returns whether gccgo uses the new collision-free\n+// gccgoUsesNewMangling reports whether gccgo uses the new collision-free\n // packagepath mangling scheme (see determineGccgoManglingScheme for more\n // info).\n func gccgoUsesNewMangling() bool {\n@@ -1545,6 +1560,7 @@ const builtinProlog = `\n /* Define intgo when compiling with GCC.  */\n typedef ptrdiff_t intgo;\n \n+#define GO_CGO_GOSTRING_TYPEDEF\n typedef struct { const char *p; intgo n; } _GoString_;\n typedef struct { char *p; intgo n; intgo c; } _GoBytes_;\n _GoString_ GoString(char *p);\n@@ -1555,7 +1571,7 @@ void *CBytes(_GoBytes_);\n void *_CMalloc(size_t);\n \n __attribute__ ((unused))\n-static size_t _GoStringLen(_GoString_ s) { return s.n; }\n+static size_t _GoStringLen(_GoString_ s) { return (size_t)s.n; }\n \n __attribute__ ((unused))\n static const char *_GoStringPtr(_GoString_ s) { return s.p; }\n@@ -1796,15 +1812,20 @@ void localCgoCheckResult(Eface val) {\n // because _cgo_export.h defines GoString as a struct while builtinProlog\n // defines it as a function. We don't change this to avoid unnecessarily\n // breaking existing code.\n+// The test of GO_CGO_GOSTRING_TYPEDEF avoids a duplicate definition\n+// error if a Go file with a cgo comment #include's the export header\n+// generated by a different package.\n const builtinExportProlog = `\n-#line 1 \"cgo-builtin-prolog\"\n+#line 1 \"cgo-builtin-export-prolog\"\n \n #include <stddef.h> /* for ptrdiff_t below */\n \n #ifndef GO_CGO_EXPORT_PROLOGUE_H\n #define GO_CGO_EXPORT_PROLOGUE_H\n \n+#ifndef GO_CGO_GOSTRING_TYPEDEF\n typedef struct { const char *p; ptrdiff_t n; } _GoString_;\n+#endif\n \n #endif\n `\n@@ -1813,6 +1834,19 @@ func (p *Package) gccExportHeaderProlog() string {\n \treturn strings.Replace(gccExportHeaderProlog, \"GOINTBITS\", fmt.Sprint(8*p.IntSize), -1)\n }\n \n+// gccExportHeaderProlog is written to the exported header, after the\n+// import \"C\" comment preamble but before the generated declarations\n+// of exported functions. This permits the generated declarations to\n+// use the type names that appear in goTypes, above.\n+//\n+// The test of GO_CGO_GOSTRING_TYPEDEF avoids a duplicate definition\n+// error if a Go file with a cgo comment #include's the export header\n+// generated by a different package. Unfortunately GoString means two\n+// different things: in this prolog it means a C name for the Go type,\n+// while in the prolog written into the start of the C code generated\n+// from a cgo-using Go file it means the C.GoString function. There is\n+// no way to resolve this conflict, but it also doesn't make much\n+// difference, as Go code never wants to refer to the latter meaning.\n const gccExportHeaderProlog = `\n /* Start of boilerplate cgo prologue.  */\n #line 1 \"cgo-gcc-export-header-prolog\"\n@@ -1842,7 +1876,9 @@ typedef double _Complex GoComplex128;\n */\n typedef char _check_for_GOINTBITS_bit_pointer_matching_GoInt[sizeof(void*)==GOINTBITS/8 ? 1:-1];\n \n+#ifndef GO_CGO_GOSTRING_TYPEDEF\n typedef _GoString_ GoString;\n+#endif\n typedef void *GoMap;\n typedef void *GoChan;\n typedef struct { void *t; void *v; } GoInterface;"}, {"sha": "9d9304a3b64faee39af961492336af8e600bde00", "filename": "libgo/go/cmd/go/alldocs.go", "status": "modified", "additions": 44, "deletions": 16, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -144,7 +144,7 @@\n // \t\tlink against shared libraries previously created with\n // \t\t-buildmode=shared.\n // \t-mod mode\n-// \t\tmodule download mode to use: readonly, release, or vendor.\n+// \t\tmodule download mode to use: readonly or vendor.\n // \t\tSee 'go help modules' for more.\n // \t-pkgdir dir\n // \t\tinstall and load all packages from dir instead of the usual locations.\n@@ -342,12 +342,21 @@\n // \tcd go/src/encoding/json; go doc decode\n //\n // Flags:\n+// \t-all\n+// \t\tShow all the documentation for the package.\n // \t-c\n // \t\tRespect case when matching symbols.\n // \t-cmd\n // \t\tTreat a command (package main) like a regular package.\n // \t\tOtherwise package main's exported symbols are hidden\n // \t\twhen showing the package's top-level documentation.\n+// \t-src\n+// \t\tShow the full source code for the symbol. This will\n+// \t\tdisplay the full Go source of its declaration and\n+// \t\tdefinition, such as a function definition (including\n+// \t\tthe body), type declaration or enclosing const\n+// \t\tblock. The output may therefore include unexported\n+// \t\tdetails.\n // \t-u\n // \t\tShow documentation for unexported as well as exported\n // \t\tsymbols, methods, and fields.\n@@ -889,7 +898,7 @@\n //\n // Usage:\n //\n-// \tgo mod download [-dir] [-json] [modules]\n+// \tgo mod download [-json] [modules]\n //\n // Download downloads the named modules, which can be module patterns selecting\n // dependencies of the main module or module queries of the form path@version.\n@@ -963,6 +972,8 @@\n // and -dropreplace editing flags may be repeated, and the changes\n // are applied in the order given.\n //\n+// The -go=version flag sets the expected Go language version.\n+//\n // The -print flag prints the final go.mod in its text format instead of\n // writing it back to go.mod.\n //\n@@ -975,7 +986,8 @@\n // \t}\n //\n // \ttype GoMod struct {\n-// \t\tModule Module\n+// \t\tModule  Module\n+// \t\tGo      string\n // \t\tRequire []Require\n // \t\tExclude []Module\n // \t\tReplace []Replace\n@@ -1287,16 +1299,25 @@\n //\n // Usage:\n //\n-// \tgo vet [-n] [-x] [build flags] [vet flags] [packages]\n+// \tgo vet [-n] [-x] [-vettool prog] [build flags] [vet flags] [packages]\n //\n // Vet runs the Go vet command on the packages named by the import paths.\n //\n // For more about vet and its flags, see 'go doc cmd/vet'.\n // For more about specifying packages, see 'go help packages'.\n+// For a list of checkers and their flags, see 'go tool vet help'.\n+// For details of a specific checker such as 'printf', see 'go tool vet help printf'.\n //\n // The -n flag prints commands that would be executed.\n // The -x flag prints commands as they are executed.\n //\n+// The -vettool=prog flag selects a different analysis tool with alternative\n+// or additional checks.\n+// For example, the 'shadow' analyzer can be built and run using these commands:\n+//\n+//   go install golang.org/x/tools/go/analysis/passes/shadow/cmd/shadow\n+//   go vet -vettool=$(which shadow)\n+//\n // The build flags supported by go vet are those that control package resolution\n // and execution, such as -n, -x, -v, -tags, and -toolexec.\n // For more about these flags, see 'go help build'.\n@@ -1451,9 +1472,7 @@\n //\n // Each entry in the GOFLAGS list must be a standalone flag.\n // Because the entries are space-separated, flag values must\n-// not contain spaces. In some cases, you can provide multiple flag\n-// values instead: for example, to set '-ldflags=-s -w'\n-// you can use 'GOFLAGS=-ldflags=-s -ldflags=-w'.\n+// not contain spaces.\n //\n // Environment variables for use with cgo:\n //\n@@ -1488,6 +1507,10 @@\n // \t\tThe command to use to compile C++ code.\n // \tPKG_CONFIG\n // \t\tPath to pkg-config tool.\n+// \tAR\n+// \t\tThe command to use to manipulate library archives when\n+// \t\tbuilding with the gccgo compiler.\n+// \t\tThe default is 'ar'.\n //\n // Architecture-specific environment variables:\n //\n@@ -1595,17 +1618,20 @@\n // verb followed by arguments. For example:\n //\n // \tmodule my/thing\n+// \tgo 1.12\n // \trequire other/thing v1.0.2\n-// \trequire new/thing v2.3.4\n+// \trequire new/thing/v2 v2.3.4\n // \texclude old/thing v1.2.3\n // \treplace bad/thing v1.4.5 => good/thing v1.4.5\n //\n-// The verbs are module, to define the module path; require, to require\n-// a particular module at a given version or later; exclude, to exclude\n-// a particular module version from use; and replace, to replace a module\n-// version with a different module version. Exclude and replace apply only\n-// in the main module's go.mod and are ignored in dependencies.\n-// See https://research.swtch.com/vgo-mvs for details.\n+// The verbs are\n+// \tmodule, to define the module path;\n+// \tgo, to set the expected language version;\n+// \trequire, to require a particular module at a given version or later;\n+// \texclude, to exclude a particular module version from use; and\n+// \treplace, to replace a module version with a different module version.\n+// Exclude and replace apply only in the main module's go.mod and are ignored\n+// in dependencies.  See https://research.swtch.com/vgo-mvs for details.\n //\n // The leading verb can be factored out of adjacent lines to create a block,\n // like in Go imports:\n@@ -2028,7 +2054,7 @@\n // (See 'go help gopath-get' and 'go help gopath'.)\n //\n // When using modules, downloaded packages are stored in the module cache.\n-// (See 'go help modules-get' and 'go help goproxy'.)\n+// (See 'go help module-get' and 'go help goproxy'.)\n //\n // When using modules, an additional variant of the go-import meta tag is\n // recognized and is preferred over those listing version control systems.\n@@ -2490,7 +2516,7 @@\n // In general, adding a new dependency may require upgrading\n // existing dependencies to keep a working build, and 'go get' does\n // this automatically. Similarly, downgrading one dependency may\n-// require downgrading other dependenceis, and 'go get' does\n+// require downgrading other dependencies, and 'go get' does\n // this automatically as well.\n //\n // The -m flag instructs get to stop here, after resolving, upgrading,\n@@ -2652,6 +2678,8 @@\n // \t    Run enough iterations of each benchmark to take t, specified\n // \t    as a time.Duration (for example, -benchtime 1h30s).\n // \t    The default is 1 second (1s).\n+// \t    The special syntax Nx means to run the benchmark N times\n+// \t    (for example, -benchtime 100x).\n //\n // \t-count n\n // \t    Run each test and benchmark n times (default 1)."}, {"sha": "63549cfded693127e08d75ffc66de4506bd6ed7c", "filename": "libgo/go/cmd/go/go_test.go", "status": "modified", "additions": 71, "deletions": 92, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -6,6 +6,8 @@ package main_test\n \n import (\n \t\"bytes\"\n+\t\"cmd/internal/sys\"\n+\t\"context\"\n \t\"debug/elf\"\n \t\"debug/macho\"\n \t\"flag\"\n@@ -107,6 +109,12 @@ var testGo string\n var testTmpDir string\n var testBin string\n \n+// testCtx is canceled when the test binary is about to time out.\n+//\n+// If https://golang.org/issue/28135 is accepted, uses of this variable in test\n+// functions should be replaced by t.Context().\n+var testCtx = context.Background()\n+\n // The TestMain function creates a go command for testing purposes and\n // deletes it after the tests have been run.\n func TestMain(m *testing.M) {\n@@ -119,6 +127,20 @@ func TestMain(m *testing.M) {\n \tos.Unsetenv(\"GOROOT_FINAL\")\n \n \tflag.Parse()\n+\n+\ttimeoutFlag := flag.Lookup(\"test.timeout\")\n+\tif timeoutFlag != nil {\n+\t\t// TODO(golang.org/issue/28147): The go command does not pass the\n+\t\t// test.timeout flag unless either -timeout or -test.timeout is explicitly\n+\t\t// set on the command line.\n+\t\tif d := timeoutFlag.Value.(flag.Getter).Get().(time.Duration); d != 0 {\n+\t\t\taBitShorter := d * 95 / 100\n+\t\t\tvar cancel context.CancelFunc\n+\t\t\ttestCtx, cancel = context.WithTimeout(testCtx, aBitShorter)\n+\t\t\tdefer cancel()\n+\t\t}\n+\t}\n+\n \tif *proxyAddr != \"\" {\n \t\tStartProxy()\n \t\tselect {}\n@@ -209,15 +231,13 @@ func TestMain(m *testing.M) {\n \t\t}\n \t\ttestGOCACHE = strings.TrimSpace(string(out))\n \n-\t\t// As of Sept 2017, MSan is only supported on linux/amd64.\n-\t\t// https://github.com/google/sanitizers/wiki/MemorySanitizer#getting-memorysanitizer\n-\t\tcanMSan = canCgo && runtime.GOOS == \"linux\" && runtime.GOARCH == \"amd64\"\n-\n-\t\tswitch runtime.GOOS {\n-\t\tcase \"linux\", \"darwin\", \"freebsd\", \"windows\":\n-\t\t\t// The race detector doesn't work on Alpine Linux:\n-\t\t\t// golang.org/issue/14481\n-\t\t\tcanRace = canCgo && runtime.GOARCH == \"amd64\" && !isAlpineLinux() && runtime.Compiler != \"gccgo\"\n+\t\tcanMSan = canCgo && sys.MSanSupported(runtime.GOOS, runtime.GOARCH)\n+\t\tcanRace = canCgo && sys.RaceDetectorSupported(runtime.GOOS, runtime.GOARCH)\n+\t\t// The race detector doesn't work on Alpine Linux:\n+\t\t// golang.org/issue/14481\n+\t\t// gccgo does not support the race detector.\n+\t\tif isAlpineLinux() || runtime.Compiler == \"gccgo\" {\n+\t\t\tcanRace = false\n \t\t}\n \t}\n \t// Don't let these environment variables confuse the test.\n@@ -1075,6 +1095,8 @@ func testMove(t *testing.T, vcs, url, base, config string) {\n \tdefer tg.cleanup()\n \ttg.parallel()\n \ttg.tempDir(\"src\")\n+\ttg.must(os.Mkdir(tg.path(\".hg\"), 0700))\n+\ttg.must(ioutil.WriteFile(filepath.Join(tg.path(\".hg\"), \"hgrc\"), nil, 0600))\n \ttg.setenv(\"GOPATH\", tg.path(\".\"))\n \ttg.run(\"get\", \"-d\", url)\n \ttg.run(\"get\", \"-d\", \"-u\", url)\n@@ -1089,7 +1111,7 @@ func testMove(t *testing.T, vcs, url, base, config string) {\n \t\tpath := tg.path(filepath.Join(\"src\", config))\n \t\tdata, err := ioutil.ReadFile(path)\n \t\ttg.must(err)\n-\t\tdata = bytes.Replace(data, []byte(base), []byte(base+\"XXX\"), -1)\n+\t\tdata = bytes.ReplaceAll(data, []byte(base), []byte(base+\"XXX\"))\n \t\ttg.must(ioutil.WriteFile(path, data, 0644))\n \t}\n \tif vcs == \"git\" {\n@@ -1185,22 +1207,6 @@ func TestImportCycle(t *testing.T) {\n \ttg.run(\"list\", \"-e\", \"-json\", \"selfimport\")\n }\n \n-func TestListImportMap(t *testing.T) {\n-\tskipIfGccgo(t, \"gccgo does not have standard packages\")\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.parallel()\n-\ttg.run(\"list\", \"-f\", \"{{.ImportPath}}: {{.ImportMap}}\", \"net\", \"fmt\")\n-\ttg.grepStdout(`^net: map\\[(.* )?golang_org/x/net/dns/dnsmessage:vendor/golang_org/x/net/dns/dnsmessage.*\\]`, \"net/http should have rewritten dnsmessage import\")\n-\ttg.grepStdout(`^fmt: map\\[\\]`, \"fmt should have no rewritten imports\")\n-\ttg.run(\"list\", \"-deps\", \"-test\", \"-f\", \"{{.ImportPath}} MAP: {{.ImportMap}}\\n{{.ImportPath}} IMPORT: {{.Imports}}\", \"fmt\")\n-\ttg.grepStdout(`^flag \\[fmt\\.test\\] MAP: map\\[fmt:fmt \\[fmt\\.test\\]\\]`, \"flag [fmt.test] should import fmt [fmt.test] as fmt\")\n-\ttg.grepStdout(`^fmt\\.test MAP: map\\[(.* )?testing:testing \\[fmt\\.test\\]`, \"fmt.test should import testing [fmt.test] as testing\")\n-\ttg.grepStdout(`^fmt\\.test MAP: map\\[(.* )?testing:testing \\[fmt\\.test\\]`, \"fmt.test should import testing [fmt.test] as testing\")\n-\ttg.grepStdoutNot(`^fmt\\.test MAP: map\\[(.* )?os:`, \"fmt.test should not import a modified os\")\n-\ttg.grepStdout(`^fmt\\.test IMPORT: \\[fmt \\[fmt\\.test\\] fmt_test \\[fmt\\.test\\] os testing \\[fmt\\.test\\] testing/internal/testdeps \\[fmt\\.test\\]\\]`, \"wrong imports for fmt.test\")\n-}\n-\n // cmd/go: custom import path checking should not apply to Go packages without import comment.\n func TestIssue10952(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n@@ -1421,6 +1427,7 @@ func TestRelativeGOBINFail(t *testing.T) {\n \ttg.tempFile(\"triv.go\", `package main; func main() {}`)\n \ttg.cd(tg.path(\".\"))\n \ttg.setenv(\"GOBIN\", \".\")\n+\ttg.cd(tg.path(\".\"))\n \ttg.runFail(\"install\")\n \ttg.grepStderr(\"cannot install, GOBIN must be an absolute path\", \"go install must fail if $GOBIN is a relative path\")\n }\n@@ -1440,8 +1447,38 @@ func TestInstallIntoGOPATH(t *testing.T) {\n func TestBuildOutputToDevNull(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n+\tfi1, err1 := os.Lstat(os.DevNull)\n \ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n \ttg.run(\"build\", \"-o\", os.DevNull, \"go-cmd-test\")\n+\tfi2, err2 := os.Lstat(os.DevNull)\n+\tif err1 == nil {\n+\t\tif err2 != nil {\n+\t\t\tt.Errorf(\"second stat of /dev/null failed: %v\", err2)\n+\t\t} else if !os.SameFile(fi1, fi2) {\n+\t\t\tt.Errorf(\"/dev/null changed: now %v was %v\", fi1, fi2)\n+\t\t}\n+\t}\n+}\n+\n+// Issue 28549.\n+func TestTestOutputToDevNull(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\tfi1, err1 := os.Lstat(os.DevNull)\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.tempFile(\"src/p/p.go\", \"package p\\n\")\n+\ttg.tempFile(\"src/p/p_test.go\", \"package p\\nimport \\\"testing\\\"\\nfunc TestX(t *testing.T) {}\\n\")\n+\ttg.run(\"test\", \"-o\", os.DevNull, \"-c\", \"p\")\n+\ttg.mustNotExist(\"p.test\")\n+\tfi2, err2 := os.Lstat(os.DevNull)\n+\tif err1 == nil {\n+\t\tif err2 != nil {\n+\t\t\tt.Errorf(\"second stat of /dev/null failed: %v\", err2)\n+\t\t} else if !os.SameFile(fi1, fi2) {\n+\t\t\tt.Errorf(\"/dev/null changed: now %v was %v\", fi1, fi2)\n+\t\t}\n+\t}\n }\n \n func TestPackageMainTestImportsArchiveNotBinary(t *testing.T) {\n@@ -1735,11 +1772,11 @@ func TestGoListDeps(t *testing.T) {\n \tif runtime.Compiler != \"gccgo\" {\n \t\t// Check the list is in dependency order.\n \t\ttg.run(\"list\", \"-deps\", \"math\")\n-\t\twant := \"internal/cpu\\nunsafe\\nmath\\n\"\n+\t\twant := \"internal/cpu\\nunsafe\\nmath/bits\\nmath\\n\"\n \t\tout := tg.stdout.String()\n \t\tif !strings.Contains(out, \"internal/cpu\") {\n \t\t\t// Some systems don't use internal/cpu.\n-\t\t\twant = \"unsafe\\nmath\\n\"\n+\t\t\twant = \"unsafe\\nmath/bits\\nmath\\n\"\n \t\t}\n \t\tif tg.stdout.String() != want {\n \t\t\tt.Fatalf(\"list -deps math: wrong order\\nhave %q\\nwant %q\", tg.stdout.String(), want)\n@@ -2359,14 +2396,14 @@ func TestShadowingLogic(t *testing.T) {\n \n \t// The math in root1 is not \"math\" because the standard math is.\n \ttg.run(\"list\", \"-f\", \"({{.ImportPath}}) ({{.ConflictDir}})\", \"./testdata/shadow/root1/src/math\")\n-\tpwdForwardSlash := strings.Replace(pwd, string(os.PathSeparator), \"/\", -1)\n+\tpwdForwardSlash := strings.ReplaceAll(pwd, string(os.PathSeparator), \"/\")\n \tif !strings.HasPrefix(pwdForwardSlash, \"/\") {\n \t\tpwdForwardSlash = \"/\" + pwdForwardSlash\n \t}\n \t// The output will have makeImportValid applies, but we only\n \t// bother to deal with characters we might reasonably see.\n \tfor _, r := range \" :\" {\n-\t\tpwdForwardSlash = strings.Replace(pwdForwardSlash, string(r), \"_\", -1)\n+\t\tpwdForwardSlash = strings.ReplaceAll(pwdForwardSlash, string(r), \"_\")\n \t}\n \twant := \"(_\" + pwdForwardSlash + \"/testdata/shadow/root1/src/math) (\" + filepath.Join(runtime.GOROOT(), \"src\", \"math\") + \")\"\n \tif strings.TrimSpace(tg.getStdout()) != want {\n@@ -2556,7 +2593,7 @@ func TestCoverageErrorLine(t *testing.T) {\n \n \t// It's OK that stderr2 drops the character position in the error,\n \t// because of the //line directive (see golang.org/issue/22662).\n-\tstderr = strings.Replace(stderr, \"p.go:4:2:\", \"p.go:4:\", -1)\n+\tstderr = strings.ReplaceAll(stderr, \"p.go:4:2:\", \"p.go:4:\")\n \tif stderr != stderr2 {\n \t\tt.Logf(\"test -cover changed error messages:\\nbefore:\\n%s\\n\\nafter:\\n%s\", stderr, stderr2)\n \t\tt.Skip(\"golang.org/issue/22660\")\n@@ -4027,8 +4064,6 @@ func TestCgoConsistentResults(t *testing.T) {\n \t\tt.Skip(\"skipping because cgo not enabled\")\n \t}\n \tswitch runtime.GOOS {\n-\tcase \"freebsd\":\n-\t\ttestenv.SkipFlaky(t, 15405)\n \tcase \"solaris\":\n \t\ttestenv.SkipFlaky(t, 13247)\n \t}\n@@ -4977,7 +5012,8 @@ func TestExecBuildX(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \n-\ttg.setenv(\"GOCACHE\", \"off\")\n+\ttg.tempDir(\"cache\")\n+\ttg.setenv(\"GOCACHE\", tg.path(\"cache\"))\n \n \ttg.tempFile(\"main.go\", `package main; import \"C\"; func main() { print(\"hello\") }`)\n \tsrc := tg.path(\"main.go\")\n@@ -5508,30 +5544,6 @@ func TestTestCacheInputs(t *testing.T) {\n \t}\n }\n \n-func TestNoCache(t *testing.T) {\n-\tswitch runtime.GOOS {\n-\tcase \"windows\":\n-\t\tt.Skipf(\"no unwritable directories on %s\", runtime.GOOS)\n-\t}\n-\tif os.Getuid() == 0 {\n-\t\tt.Skip(\"skipping test because running as root\")\n-\t}\n-\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.parallel()\n-\ttg.tempFile(\"triv.go\", `package main; func main() {}`)\n-\ttg.must(os.MkdirAll(tg.path(\"unwritable\"), 0555))\n-\thome := \"HOME\"\n-\tif runtime.GOOS == \"plan9\" {\n-\t\thome = \"home\"\n-\t}\n-\ttg.setenv(home, tg.path(filepath.Join(\"unwritable\", \"home\")))\n-\ttg.unsetenv(\"GOCACHE\")\n-\ttg.run(\"build\", \"-o\", tg.path(\"triv\"), tg.path(\"triv.go\"))\n-\ttg.grepStderr(\"disabling cache\", \"did not disable cache\")\n-}\n-\n func TestTestVet(t *testing.T) {\n \ttooSlow(t)\n \ttg := testgo(t)\n@@ -5681,17 +5693,6 @@ func TestFmtLoadErrors(t *testing.T) {\n \ttg.run(\"fmt\", \"-n\", \"exclude\")\n }\n \n-func TestRelativePkgdir(t *testing.T) {\n-\ttooSlow(t)\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.makeTempdir()\n-\ttg.setenv(\"GOCACHE\", \"off\")\n-\ttg.cd(tg.tempdir)\n-\n-\ttg.run(\"build\", \"-i\", \"-pkgdir=.\", \"runtime\")\n-}\n-\n func TestGoTestMinusN(t *testing.T) {\n \t// Intent here is to verify that 'go test -n' works without crashing.\n \t// This reuses flag_test.go, but really any test would do.\n@@ -6073,28 +6074,6 @@ func TestDontReportRemoveOfEmptyDir(t *testing.T) {\n \t}\n }\n \n-// Issue 23264.\n-func TestNoRelativeTmpdir(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\n-\ttg.tempFile(\"src/a/a.go\", `package a`)\n-\ttg.cd(tg.path(\".\"))\n-\ttg.must(os.Mkdir(\"tmp\", 0777))\n-\n-\ttg.setenv(\"GOCACHE\", \"off\")\n-\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n-\ttg.setenv(\"GOTMPDIR\", \"tmp\")\n-\ttg.run(\"build\", \"-work\", \"a\")\n-\ttg.grepStderr(\"WORK=[^t]\", \"work should be absolute path\")\n-\n-\ttg.unsetenv(\"GOTMPDIR\")\n-\ttg.setenv(\"TMP\", \"tmp\")    // windows\n-\ttg.setenv(\"TMPDIR\", \"tmp\") // unix\n-\ttg.run(\"build\", \"-work\", \"a\")\n-\ttg.grepStderr(\"WORK=[^t]\", \"work should be absolute path\")\n-}\n-\n // Issue 24704.\n func TestLinkerTmpDirIsDeleted(t *testing.T) {\n \tskipIfGccgo(t, \"gccgo does not use cmd/link\")\n@@ -6172,7 +6151,7 @@ func TestCDAndGOPATHAreDifferent(t *testing.T) {\n \n \ttestCDAndGOPATHAreDifferent(tg, cd, gopath)\n \tif runtime.GOOS == \"windows\" {\n-\t\ttestCDAndGOPATHAreDifferent(tg, cd, strings.Replace(gopath, `\\`, `/`, -1))\n+\t\ttestCDAndGOPATHAreDifferent(tg, cd, strings.ReplaceAll(gopath, `\\`, `/`))\n \t\ttestCDAndGOPATHAreDifferent(tg, cd, strings.ToUpper(gopath))\n \t\ttestCDAndGOPATHAreDifferent(tg, cd, strings.ToLower(gopath))\n \t}"}, {"sha": "ec6a9d11cbe2e0ed649ae56e6676a4fb7c9f427b", "filename": "libgo/go/cmd/go/help_test.go", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Fhelp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Fhelp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fhelp_test.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build !nacl\n+\n+package main_test\n+\n+import (\n+\t\"bytes\"\n+\t\"io/ioutil\"\n+\t\"testing\"\n+\n+\t\"cmd/go/internal/help\"\n+)\n+\n+func TestDocsUpToDate(t *testing.T) {\n+\tbuf := new(bytes.Buffer)\n+\t// Match the command in mkalldocs.sh that generates alldocs.go.\n+\thelp.Help(buf, []string{\"documentation\"})\n+\tdata, err := ioutil.ReadFile(\"alldocs.go\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"error reading alldocs.go: %v\", err)\n+\t}\n+\tif !bytes.Equal(data, buf.Bytes()) {\n+\t\tt.Errorf(\"alldocs.go is not up to date; run mkalldocs.sh to regenerate it\")\n+\t}\n+}"}, {"sha": "ab84cf6302c0d1ec952db6dc0a53bfb7a84aad8e", "filename": "libgo/go/cmd/go/internal/cache/cache.go", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fcache.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fcache.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fcache.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -18,6 +18,8 @@ import (\n \t\"strconv\"\n \t\"strings\"\n \t\"time\"\n+\n+\t\"cmd/go/internal/renameio\"\n )\n \n // An ActionID is a cache action key, the hash of a complete description of a\n@@ -283,7 +285,9 @@ func (c *Cache) Trim() {\n \t\tc.trimSubdir(subdir, cutoff)\n \t}\n \n-\tioutil.WriteFile(filepath.Join(c.dir, \"trim.txt\"), []byte(fmt.Sprintf(\"%d\", now.Unix())), 0666)\n+\t// Ignore errors from here: if we don't write the complete timestamp, the\n+\t// cache will appear older than it is, and we'll trim it again next time.\n+\trenameio.WriteFile(filepath.Join(c.dir, \"trim.txt\"), []byte(fmt.Sprintf(\"%d\", now.Unix())))\n }\n \n // trimSubdir trims a single cache subdirectory.\n@@ -338,6 +342,8 @@ func (c *Cache) putIndexEntry(id ActionID, out OutputID, size int64, allowVerify\n \t}\n \tfile := c.fileName(id, \"a\")\n \tif err := ioutil.WriteFile(file, entry, 0666); err != nil {\n+\t\t// TODO(bcmills): This Remove potentially races with another go command writing to file.\n+\t\t// Can we eliminate it?\n \t\tos.Remove(file)\n \t\treturn err\n \t}"}, {"sha": "f545c147009f247e3dbc25c76efe68940391bc11", "filename": "libgo/go/cmd/go/internal/cache/default.go", "status": "modified", "additions": 33, "deletions": 70, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fdefault.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fdefault.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fdefault.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -9,8 +9,9 @@ import (\n \t\"io/ioutil\"\n \t\"os\"\n \t\"path/filepath\"\n-\t\"runtime\"\n \t\"sync\"\n+\n+\t\"cmd/go/internal/base\"\n )\n \n // Default returns the default cache to use, or nil if no cache should be used.\n@@ -35,15 +36,15 @@ See golang.org to learn more about Go.\n // initDefaultCache does the work of finding the default cache\n // the first time Default is called.\n func initDefaultCache() {\n-\tdir, showWarnings := defaultDir()\n-\tif dir == \"off\" {\n-\t\treturn\n+\tdir := DefaultDir()\n+\tif dir == \"off\" || dir == \"\" {\n+\t\tif defaultDirErr != nil {\n+\t\t\tbase.Fatalf(\"build cache is required, but could not be located: %v\", defaultDirErr)\n+\t\t}\n+\t\tbase.Fatalf(\"build cache is disabled by GOCACHE=off, but required as of Go 1.12\")\n \t}\n \tif err := os.MkdirAll(dir, 0777); err != nil {\n-\t\tif showWarnings {\n-\t\t\tfmt.Fprintf(os.Stderr, \"go: disabling cache (%s) due to initialization failure: %s\\n\", dir, err)\n-\t\t}\n-\t\treturn\n+\t\tbase.Fatalf(\"failed to initialize build cache at %s: %s\\n\", dir, err)\n \t}\n \tif _, err := os.Stat(filepath.Join(dir, \"README\")); err != nil {\n \t\t// Best effort.\n@@ -52,78 +53,40 @@ func initDefaultCache() {\n \n \tc, err := Open(dir)\n \tif err != nil {\n-\t\tif showWarnings {\n-\t\t\tfmt.Fprintf(os.Stderr, \"go: disabling cache (%s) due to initialization failure: %s\\n\", dir, err)\n-\t\t}\n-\t\treturn\n+\t\tbase.Fatalf(\"failed to initialize build cache at %s: %s\\n\", dir, err)\n \t}\n \tdefaultCache = c\n }\n \n+var (\n+\tdefaultDirOnce sync.Once\n+\tdefaultDir     string\n+\tdefaultDirErr  error\n+)\n+\n // DefaultDir returns the effective GOCACHE setting.\n // It returns \"off\" if the cache is disabled.\n func DefaultDir() string {\n-\tdir, _ := defaultDir()\n-\treturn dir\n-}\n+\t// Save the result of the first call to DefaultDir for later use in\n+\t// initDefaultCache. cmd/go/main.go explicitly sets GOCACHE so that\n+\t// subprocesses will inherit it, but that means initDefaultCache can't\n+\t// otherwise distinguish between an explicit \"off\" and a UserCacheDir error.\n \n-// defaultDir returns the effective GOCACHE setting.\n-// It returns \"off\" if the cache is disabled.\n-// The second return value reports whether warnings should\n-// be shown if the cache fails to initialize.\n-func defaultDir() (string, bool) {\n-\tdir := os.Getenv(\"GOCACHE\")\n-\tif dir != \"\" {\n-\t\treturn dir, true\n-\t}\n-\n-\t// Compute default location.\n-\t// TODO(rsc): This code belongs somewhere else,\n-\t// like maybe ioutil.CacheDir or os.CacheDir.\n-\tshowWarnings := true\n-\tswitch runtime.GOOS {\n-\tcase \"windows\":\n-\t\tdir = os.Getenv(\"LocalAppData\")\n-\t\tif dir == \"\" {\n-\t\t\t// Fall back to %AppData%, the old name of\n-\t\t\t// %LocalAppData% on Windows XP.\n-\t\t\tdir = os.Getenv(\"AppData\")\n-\t\t}\n-\t\tif dir == \"\" {\n-\t\t\treturn \"off\", true\n+\tdefaultDirOnce.Do(func() {\n+\t\tdefaultDir = os.Getenv(\"GOCACHE\")\n+\t\tif defaultDir != \"\" {\n+\t\t\treturn\n \t\t}\n \n-\tcase \"darwin\":\n-\t\tdir = os.Getenv(\"HOME\")\n-\t\tif dir == \"\" {\n-\t\t\treturn \"off\", true\n+\t\t// Compute default location.\n+\t\tdir, err := os.UserCacheDir()\n+\t\tif err != nil {\n+\t\t\tdefaultDir = \"off\"\n+\t\t\tdefaultDirErr = fmt.Errorf(\"GOCACHE is not defined and %v\", err)\n+\t\t\treturn\n \t\t}\n-\t\tdir += \"/Library/Caches\"\n+\t\tdefaultDir = filepath.Join(dir, \"go-build\")\n+\t})\n \n-\tcase \"plan9\":\n-\t\tdir = os.Getenv(\"home\")\n-\t\tif dir == \"\" {\n-\t\t\treturn \"off\", true\n-\t\t}\n-\t\t// Plan 9 has no established per-user cache directory,\n-\t\t// but $home/lib/xyz is the usual equivalent of $HOME/.xyz on Unix.\n-\t\tdir += \"/lib/cache\"\n-\n-\tdefault: // Unix\n-\t\t// https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html\n-\t\tdir = os.Getenv(\"XDG_CACHE_HOME\")\n-\t\tif dir == \"\" {\n-\t\t\tdir = os.Getenv(\"HOME\")\n-\t\t\tif dir == \"\" {\n-\t\t\t\treturn \"off\", true\n-\t\t\t}\n-\t\t\tif dir == \"/\" {\n-\t\t\t\t// probably docker run with -u flag\n-\t\t\t\t// https://golang.org/issue/26280\n-\t\t\t\tshowWarnings = false\n-\t\t\t}\n-\t\t\tdir += \"/.cache\"\n-\t\t}\n-\t}\n-\treturn filepath.Join(dir, \"go-build\"), showWarnings\n+\treturn defaultDir\n }"}, {"sha": "a207497a42cc01ef162d7d56dc2fcf3a135b646d", "filename": "libgo/go/cmd/go/internal/cache/default_unix_test.go", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fdefault_unix_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fdefault_unix_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fdefault_unix_test.go?ref=225220d668dafb8262db7012bced688acbe63b33", "patch": "@@ -1,67 +0,0 @@\n-// Copyright 2018 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build !windows,!darwin,!plan9\n-\n-package cache\n-\n-import (\n-\t\"os\"\n-\t\"strings\"\n-\t\"testing\"\n-)\n-\n-func TestDefaultDir(t *testing.T) {\n-\tgoCacheDir := \"/tmp/test-go-cache\"\n-\txdgCacheDir := \"/tmp/test-xdg-cache\"\n-\thomeDir := \"/tmp/test-home\"\n-\n-\t// undo env changes when finished\n-\tdefer func(GOCACHE, XDG_CACHE_HOME, HOME string) {\n-\t\tos.Setenv(\"GOCACHE\", GOCACHE)\n-\t\tos.Setenv(\"XDG_CACHE_HOME\", XDG_CACHE_HOME)\n-\t\tos.Setenv(\"HOME\", HOME)\n-\t}(os.Getenv(\"GOCACHE\"), os.Getenv(\"XDG_CACHE_HOME\"), os.Getenv(\"HOME\"))\n-\n-\tos.Setenv(\"GOCACHE\", goCacheDir)\n-\tos.Setenv(\"XDG_CACHE_HOME\", xdgCacheDir)\n-\tos.Setenv(\"HOME\", homeDir)\n-\n-\tdir, showWarnings := defaultDir()\n-\tif dir != goCacheDir {\n-\t\tt.Errorf(\"Cache DefaultDir %q should be $GOCACHE %q\", dir, goCacheDir)\n-\t}\n-\tif !showWarnings {\n-\t\tt.Error(\"Warnings should be shown when $GOCACHE is set\")\n-\t}\n-\n-\tos.Unsetenv(\"GOCACHE\")\n-\tdir, showWarnings = defaultDir()\n-\tif !strings.HasPrefix(dir, xdgCacheDir+\"/\") {\n-\t\tt.Errorf(\"Cache DefaultDir %q should be under $XDG_CACHE_HOME %q when $GOCACHE is unset\", dir, xdgCacheDir)\n-\t}\n-\tif !showWarnings {\n-\t\tt.Error(\"Warnings should be shown when $XDG_CACHE_HOME is set\")\n-\t}\n-\n-\tos.Unsetenv(\"XDG_CACHE_HOME\")\n-\tdir, showWarnings = defaultDir()\n-\tif !strings.HasPrefix(dir, homeDir+\"/.cache/\") {\n-\t\tt.Errorf(\"Cache DefaultDir %q should be under $HOME/.cache %q when $GOCACHE and $XDG_CACHE_HOME are unset\", dir, homeDir+\"/.cache\")\n-\t}\n-\tif !showWarnings {\n-\t\tt.Error(\"Warnings should be shown when $HOME is not /\")\n-\t}\n-\n-\tos.Unsetenv(\"HOME\")\n-\tif dir, _ := defaultDir(); dir != \"off\" {\n-\t\tt.Error(\"Cache not disabled when $GOCACHE, $XDG_CACHE_HOME, and $HOME are unset\")\n-\t}\n-\n-\tos.Setenv(\"HOME\", \"/\")\n-\tif _, showWarnings := defaultDir(); showWarnings {\n-\t\t// https://golang.org/issue/26280\n-\t\tt.Error(\"Cache initalization warnings should be squelched when $GOCACHE and $XDG_CACHE_HOME are unset and $HOME is /\")\n-\t}\n-}"}, {"sha": "e4bb2a34bb4a1a371193864fb8b24139b52bd16c", "filename": "libgo/go/cmd/go/internal/cache/hash.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fhash.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fhash.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fhash.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -123,7 +123,7 @@ var hashFileCache struct {\n \tm map[string][HashSize]byte\n }\n \n-// HashFile returns the hash of the named file.\n+// FileHash returns the hash of the named file.\n // It caches repeated lookups for a given file,\n // and the cache entry for a file can be initialized\n // using SetFileHash."}, {"sha": "32cc80736df4b84796f9e7bc3784aebbcb7fe274", "filename": "libgo/go/cmd/go/internal/clean/clean.go", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fclean%2Fclean.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fclean%2Fclean.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fclean%2Fclean.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -10,13 +10,15 @@ import (\n \t\"io/ioutil\"\n \t\"os\"\n \t\"path/filepath\"\n+\t\"strconv\"\n \t\"strings\"\n \t\"time\"\n \n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cache\"\n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/load\"\n+\t\"cmd/go/internal/lockedfile\"\n \t\"cmd/go/internal/modfetch\"\n \t\"cmd/go/internal/modload\"\n \t\"cmd/go/internal/work\"\n@@ -103,18 +105,16 @@ func init() {\n }\n \n func runClean(cmd *base.Command, args []string) {\n-\tif len(args) == 0 && modload.Failed() {\n-\t\t// Don't try to clean current directory,\n-\t\t// which will cause modload to base.Fatalf.\n-\t} else {\n+\tif len(args) > 0 || !modload.Enabled() || modload.HasModRoot() {\n \t\tfor _, pkg := range load.PackagesAndErrors(args) {\n \t\t\tclean(pkg)\n \t\t}\n \t}\n \n+\tvar b work.Builder\n+\tb.Print = fmt.Print\n+\n \tif cleanCache {\n-\t\tvar b work.Builder\n-\t\tb.Print = fmt.Print\n \t\tdir := cache.DefaultDir()\n \t\tif dir != \"off\" {\n \t\t\t// Remove the cache subdirectories but not the top cache directory.\n@@ -145,7 +145,20 @@ func runClean(cmd *base.Command, args []string) {\n \t\t// right now are to be ignored.\n \t\tdir := cache.DefaultDir()\n \t\tif dir != \"off\" {\n-\t\t\terr := ioutil.WriteFile(filepath.Join(dir, \"testexpire.txt\"), []byte(fmt.Sprintf(\"%d\\n\", time.Now().UnixNano())), 0666)\n+\t\t\tf, err := lockedfile.Edit(filepath.Join(dir, \"testexpire.txt\"))\n+\t\t\tif err == nil {\n+\t\t\t\tnow := time.Now().UnixNano()\n+\t\t\t\tbuf, _ := ioutil.ReadAll(f)\n+\t\t\t\tprev, _ := strconv.ParseInt(strings.TrimSpace(string(buf)), 10, 64)\n+\t\t\t\tif now > prev {\n+\t\t\t\t\tif err = f.Truncate(0); err == nil {\n+\t\t\t\t\t\t_, err = fmt.Fprintf(f, \"%d\\n\", now)\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif closeErr := f.Close(); err == nil {\n+\t\t\t\t\terr = closeErr\n+\t\t\t\t}\n+\t\t\t}\n \t\t\tif err != nil {\n \t\t\t\tbase.Errorf(\"go clean -testcache: %v\", err)\n \t\t\t}\n@@ -156,24 +169,15 @@ func runClean(cmd *base.Command, args []string) {\n \t\tif modfetch.PkgMod == \"\" {\n \t\t\tbase.Fatalf(\"go clean -modcache: no module cache\")\n \t\t}\n-\t\tif err := removeAll(modfetch.PkgMod); err != nil {\n-\t\t\tbase.Errorf(\"go clean -modcache: %v\", err)\n-\t\t}\n-\t}\n-}\n-\n-func removeAll(dir string) error {\n-\t// Module cache has 0555 directories; make them writable in order to remove content.\n-\tfilepath.Walk(dir, func(path string, info os.FileInfo, err error) error {\n-\t\tif err != nil {\n-\t\t\treturn nil // ignore errors walking in file system\n+\t\tif cfg.BuildN || cfg.BuildX {\n+\t\t\tb.Showcmd(\"\", \"rm -rf %s\", modfetch.PkgMod)\n \t\t}\n-\t\tif info.IsDir() {\n-\t\t\tos.Chmod(path, 0777)\n+\t\tif !cfg.BuildN {\n+\t\t\tif err := modfetch.RemoveAll(modfetch.PkgMod); err != nil {\n+\t\t\t\tbase.Errorf(\"go clean -modcache: %v\", err)\n+\t\t\t}\n \t\t}\n-\t\treturn nil\n-\t})\n-\treturn os.RemoveAll(dir)\n+\t}\n }\n \n var cleaned = map[*load.Package]bool{}"}, {"sha": "7f2c53def8fa2b3ce5baa9e54251d508bf5a926e", "filename": "libgo/go/cmd/go/internal/cmdflag/flag.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcmdflag%2Fflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcmdflag%2Fflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcmdflag%2Fflag.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -79,15 +79,15 @@ func AddKnownFlags(cmd string, defns []*Defn) {\n \n // Parse sees if argument i is present in the definitions and if so,\n // returns its definition, value, and whether it consumed an extra word.\n-// If the flag begins (cmd+\".\") it is ignored for the purpose of this function.\n-func Parse(cmd string, defns []*Defn, args []string, i int) (f *Defn, value string, extra bool) {\n+// If the flag begins (cmd.Name()+\".\") it is ignored for the purpose of this function.\n+func Parse(cmd string, usage func(), defns []*Defn, args []string, i int) (f *Defn, value string, extra bool) {\n \targ := args[i]\n \tif strings.HasPrefix(arg, \"--\") { // reduce two minuses to one\n \t\targ = arg[1:]\n \t}\n \tswitch arg {\n \tcase \"-?\", \"-h\", \"-help\":\n-\t\tbase.Usage()\n+\t\tusage()\n \t}\n \tif arg == \"\" || arg[0] != '-' {\n \t\treturn"}, {"sha": "bad05ff9128cb523fa6553b353b7117fab81ab9c", "filename": "libgo/go/cmd/go/internal/doc/doc.go", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fdoc%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fdoc%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fdoc%2Fdoc.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -106,12 +106,21 @@ Examples:\n \tcd go/src/encoding/json; go doc decode\n \n Flags:\n+\t-all\n+\t\tShow all the documentation for the package.\n \t-c\n \t\tRespect case when matching symbols.\n \t-cmd\n \t\tTreat a command (package main) like a regular package.\n \t\tOtherwise package main's exported symbols are hidden\n \t\twhen showing the package's top-level documentation.\n+\t-src\n+\t\tShow the full source code for the symbol. This will\n+\t\tdisplay the full Go source of its declaration and\n+\t\tdefinition, such as a function definition (including\n+\t\tthe body), type declaration or enclosing const\n+\t\tblock. The output may therefore include unexported\n+\t\tdetails.\n \t-u\n \t\tShow documentation for unexported as well as exported\n \t\tsymbols, methods, and fields."}, {"sha": "ae98d3999a1fa429c8105aa0968b00d3a2812545", "filename": "libgo/go/cmd/go/internal/envcmd/env.go", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fenvcmd%2Fenv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fenvcmd%2Fenv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fenvcmd%2Fenv.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -115,8 +115,10 @@ func findEnv(env []cfg.EnvVar, name string) string {\n // ExtraEnvVars returns environment variables that should not leak into child processes.\n func ExtraEnvVars() []cfg.EnvVar {\n \tgomod := \"\"\n-\tif modload.Init(); modload.ModRoot != \"\" {\n-\t\tgomod = filepath.Join(modload.ModRoot, \"go.mod\")\n+\tif modload.HasModRoot() {\n+\t\tgomod = filepath.Join(modload.ModRoot(), \"go.mod\")\n+\t} else if modload.Enabled() {\n+\t\tgomod = os.DevNull\n \t}\n \treturn []cfg.EnvVar{\n \t\t{Name: \"GOMOD\", Value: gomod},\n@@ -203,7 +205,7 @@ func runEnv(cmd *base.Command, args []string) {\n \t\t\t\tfmt.Printf(\"%s=\\\"%s\\\"\\n\", e.Name, e.Value)\n \t\t\tcase \"plan9\":\n \t\t\t\tif strings.IndexByte(e.Value, '\\x00') < 0 {\n-\t\t\t\t\tfmt.Printf(\"%s='%s'\\n\", e.Name, strings.Replace(e.Value, \"'\", \"''\", -1))\n+\t\t\t\t\tfmt.Printf(\"%s='%s'\\n\", e.Name, strings.ReplaceAll(e.Value, \"'\", \"''\"))\n \t\t\t\t} else {\n \t\t\t\t\tv := strings.Split(e.Value, \"\\x00\")\n \t\t\t\t\tfmt.Printf(\"%s=(\", e.Name)"}, {"sha": "4d741df2b4f1a6a83c0a16705f69ef28f81163f2", "filename": "libgo/go/cmd/go/internal/fix/fix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffix%2Ffix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffix%2Ffix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffix%2Ffix.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -34,7 +34,7 @@ See also: go fmt, go vet.\n func runFix(cmd *base.Command, args []string) {\n \tprinted := false\n \tfor _, pkg := range load.Packages(args) {\n-\t\tif modload.Enabled() && !pkg.Module.Main {\n+\t\tif modload.Enabled() && pkg.Module != nil && !pkg.Module.Main {\n \t\t\tif !printed {\n \t\t\t\tfmt.Fprintf(os.Stderr, \"go: not fixing packages in dependency modules\\n\")\n \t\t\t\tprinted = true"}, {"sha": "7cbc448e6dd7c56d74055f17d94765df4b1fc5d4", "filename": "libgo/go/cmd/go/internal/generate/generate.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fgenerate%2Fgenerate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fgenerate%2Fgenerate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fgenerate%2Fgenerate.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -161,7 +161,7 @@ func runGenerate(cmd *base.Command, args []string) {\n \t// Even if the arguments are .go files, this loop suffices.\n \tprinted := false\n \tfor _, pkg := range load.Packages(args) {\n-\t\tif modload.Enabled() && !pkg.Module.Main {\n+\t\tif modload.Enabled() && pkg.Module != nil && !pkg.Module.Main {\n \t\t\tif !printed {\n \t\t\t\tfmt.Fprintf(os.Stderr, \"go: not generating in packages in dependency modules\\n\")\n \t\t\t\tprinted = true"}, {"sha": "a314c57160b396203d8db3638c150d31ea908392", "filename": "libgo/go/cmd/go/internal/get/get.go", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fget.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fget.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fget.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -232,7 +232,7 @@ var downloadCache = map[string]bool{}\n var downloadRootCache = map[string]bool{}\n \n // download runs the download half of the get command\n-// for the package named by the argument.\n+// for the package or pattern named by the argument.\n func download(arg string, parent *load.Package, stk *load.ImportStack, mode int) {\n \tif mode&load.ResolveImport != 0 {\n \t\t// Caller is responsible for expanding vendor paths.\n@@ -402,6 +402,23 @@ func downloadPackage(p *load.Package) error {\n \t\tsecurity = web.Insecure\n \t}\n \n+\t// p can be either a real package, or a pseudo-package whose \u201cimport path\u201d is\n+\t// actually a wildcard pattern.\n+\t// Trim the path at the element containing the first wildcard,\n+\t// and hope that it applies to the wildcarded parts too.\n+\t// This makes 'go get rsc.io/pdf/...' work in a fresh GOPATH.\n+\timportPrefix := p.ImportPath\n+\tif i := strings.Index(importPrefix, \"...\"); i >= 0 {\n+\t\tslash := strings.LastIndexByte(importPrefix[:i], '/')\n+\t\tif slash < 0 {\n+\t\t\treturn fmt.Errorf(\"cannot expand ... in %q\", p.ImportPath)\n+\t\t}\n+\t\timportPrefix = importPrefix[:slash]\n+\t}\n+\tif err := CheckImportPath(importPrefix); err != nil {\n+\t\treturn fmt.Errorf(\"%s: invalid import path: %v\", p.ImportPath, err)\n+\t}\n+\n \tif p.Internal.Build.SrcRoot != \"\" {\n \t\t// Directory exists. Look for checkout along path to src.\n \t\tvcs, rootPath, err = vcsFromDir(p.Dir, p.Internal.Build.SrcRoot)\n@@ -421,7 +438,7 @@ func downloadPackage(p *load.Package) error {\n \t\t\t}\n \t\t\trepo = remote\n \t\t\tif !*getF && err == nil {\n-\t\t\t\tif rr, err := RepoRootForImportPath(p.ImportPath, IgnoreMod, security); err == nil {\n+\t\t\t\tif rr, err := RepoRootForImportPath(importPrefix, IgnoreMod, security); err == nil {\n \t\t\t\t\trepo := rr.Repo\n \t\t\t\t\tif rr.vcs.resolveRepo != nil {\n \t\t\t\t\t\tresolved, err := rr.vcs.resolveRepo(rr.vcs, dir, repo)\n@@ -438,7 +455,7 @@ func downloadPackage(p *load.Package) error {\n \t} else {\n \t\t// Analyze the import path to determine the version control system,\n \t\t// repository, and the import path for the root of the repository.\n-\t\trr, err := RepoRootForImportPath(p.ImportPath, IgnoreMod, security)\n+\t\trr, err := RepoRootForImportPath(importPrefix, IgnoreMod, security)\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}"}, {"sha": "d443bd28a9656fb86f78e63921d0c6054c4b1f5a", "filename": "libgo/go/cmd/go/internal/get/path.go", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fpath.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -0,0 +1,192 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package get\n+\n+import (\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"unicode\"\n+\t\"unicode/utf8\"\n+)\n+\n+// The following functions are copied verbatim from cmd/go/internal/module/module.go,\n+// with a change to additionally reject Windows short-names,\n+// and one to accept arbitrary letters (golang.org/issue/29101).\n+//\n+// TODO(bcmills): After the call site for this function is backported,\n+// consolidate this back down to a single copy.\n+//\n+// NOTE: DO NOT MERGE THESE UNTIL WE DECIDE ABOUT ARBITRARY LETTERS IN MODULE MODE.\n+\n+// CheckImportPath checks that an import path is valid.\n+func CheckImportPath(path string) error {\n+\tif err := checkPath(path, false); err != nil {\n+\t\treturn fmt.Errorf(\"malformed import path %q: %v\", path, err)\n+\t}\n+\treturn nil\n+}\n+\n+// checkPath checks that a general path is valid.\n+// It returns an error describing why but not mentioning path.\n+// Because these checks apply to both module paths and import paths,\n+// the caller is expected to add the \"malformed ___ path %q: \" prefix.\n+// fileName indicates whether the final element of the path is a file name\n+// (as opposed to a directory name).\n+func checkPath(path string, fileName bool) error {\n+\tif !utf8.ValidString(path) {\n+\t\treturn fmt.Errorf(\"invalid UTF-8\")\n+\t}\n+\tif path == \"\" {\n+\t\treturn fmt.Errorf(\"empty string\")\n+\t}\n+\tif strings.Contains(path, \"..\") {\n+\t\treturn fmt.Errorf(\"double dot\")\n+\t}\n+\tif strings.Contains(path, \"//\") {\n+\t\treturn fmt.Errorf(\"double slash\")\n+\t}\n+\tif path[len(path)-1] == '/' {\n+\t\treturn fmt.Errorf(\"trailing slash\")\n+\t}\n+\telemStart := 0\n+\tfor i, r := range path {\n+\t\tif r == '/' {\n+\t\t\tif err := checkElem(path[elemStart:i], fileName); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\telemStart = i + 1\n+\t\t}\n+\t}\n+\tif err := checkElem(path[elemStart:], fileName); err != nil {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+// checkElem checks whether an individual path element is valid.\n+// fileName indicates whether the element is a file name (not a directory name).\n+func checkElem(elem string, fileName bool) error {\n+\tif elem == \"\" {\n+\t\treturn fmt.Errorf(\"empty path element\")\n+\t}\n+\tif strings.Count(elem, \".\") == len(elem) {\n+\t\treturn fmt.Errorf(\"invalid path element %q\", elem)\n+\t}\n+\tif elem[0] == '.' && !fileName {\n+\t\treturn fmt.Errorf(\"leading dot in path element\")\n+\t}\n+\tif elem[len(elem)-1] == '.' {\n+\t\treturn fmt.Errorf(\"trailing dot in path element\")\n+\t}\n+\n+\tcharOK := pathOK\n+\tif fileName {\n+\t\tcharOK = fileNameOK\n+\t}\n+\tfor _, r := range elem {\n+\t\tif !charOK(r) {\n+\t\t\treturn fmt.Errorf(\"invalid char %q\", r)\n+\t\t}\n+\t}\n+\n+\t// Windows disallows a bunch of path elements, sadly.\n+\t// See https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file\n+\tshort := elem\n+\tif i := strings.Index(short, \".\"); i >= 0 {\n+\t\tshort = short[:i]\n+\t}\n+\tfor _, bad := range badWindowsNames {\n+\t\tif strings.EqualFold(bad, short) {\n+\t\t\treturn fmt.Errorf(\"disallowed path element %q\", elem)\n+\t\t}\n+\t}\n+\n+\t// Reject path components that look like Windows short-names.\n+\t// Those usually end in a tilde followed by one or more ASCII digits.\n+\tif tilde := strings.LastIndexByte(short, '~'); tilde >= 0 && tilde < len(short)-1 {\n+\t\tsuffix := short[tilde+1:]\n+\t\tsuffixIsDigits := true\n+\t\tfor _, r := range suffix {\n+\t\t\tif r < '0' || r > '9' {\n+\t\t\t\tsuffixIsDigits = false\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t\tif suffixIsDigits {\n+\t\t\treturn fmt.Errorf(\"trailing tilde and digits in path element\")\n+\t\t}\n+\t}\n+\n+\treturn nil\n+}\n+\n+// pathOK reports whether r can appear in an import path element.\n+//\n+// NOTE: This function DIVERGES from module mode pathOK by accepting Unicode letters.\n+func pathOK(r rune) bool {\n+\tif r < utf8.RuneSelf {\n+\t\treturn r == '+' || r == '-' || r == '.' || r == '_' || r == '~' ||\n+\t\t\t'0' <= r && r <= '9' ||\n+\t\t\t'A' <= r && r <= 'Z' ||\n+\t\t\t'a' <= r && r <= 'z'\n+\t}\n+\treturn unicode.IsLetter(r)\n+}\n+\n+// fileNameOK reports whether r can appear in a file name.\n+// For now we allow all Unicode letters but otherwise limit to pathOK plus a few more punctuation characters.\n+// If we expand the set of allowed characters here, we have to\n+// work harder at detecting potential case-folding and normalization collisions.\n+// See note about \"safe encoding\" below.\n+func fileNameOK(r rune) bool {\n+\tif r < utf8.RuneSelf {\n+\t\t// Entire set of ASCII punctuation, from which we remove characters:\n+\t\t//     ! \" # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \\ ] ^ _ ` { | } ~\n+\t\t// We disallow some shell special characters: \" ' * < > ? ` |\n+\t\t// (Note that some of those are disallowed by the Windows file system as well.)\n+\t\t// We also disallow path separators / : and \\ (fileNameOK is only called on path element characters).\n+\t\t// We allow spaces (U+0020) in file names.\n+\t\tconst allowed = \"!#$%&()+,-.=@[]^_{}~ \"\n+\t\tif '0' <= r && r <= '9' || 'A' <= r && r <= 'Z' || 'a' <= r && r <= 'z' {\n+\t\t\treturn true\n+\t\t}\n+\t\tfor i := 0; i < len(allowed); i++ {\n+\t\t\tif rune(allowed[i]) == r {\n+\t\t\t\treturn true\n+\t\t\t}\n+\t\t}\n+\t\treturn false\n+\t}\n+\t// It may be OK to add more ASCII punctuation here, but only carefully.\n+\t// For example Windows disallows < > \\, and macOS disallows :, so we must not allow those.\n+\treturn unicode.IsLetter(r)\n+}\n+\n+// badWindowsNames are the reserved file path elements on Windows.\n+// See https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file\n+var badWindowsNames = []string{\n+\t\"CON\",\n+\t\"PRN\",\n+\t\"AUX\",\n+\t\"NUL\",\n+\t\"COM1\",\n+\t\"COM2\",\n+\t\"COM3\",\n+\t\"COM4\",\n+\t\"COM5\",\n+\t\"COM6\",\n+\t\"COM7\",\n+\t\"COM8\",\n+\t\"COM9\",\n+\t\"LPT1\",\n+\t\"LPT2\",\n+\t\"LPT3\",\n+\t\"LPT4\",\n+\t\"LPT5\",\n+\t\"LPT6\",\n+\t\"LPT7\",\n+\t\"LPT8\",\n+\t\"LPT9\",\n+}"}, {"sha": "a7a2ba32cc33cbe0baebb7152cbe78a646abf8ae", "filename": "libgo/go/cmd/go/internal/get/vcs.go", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fvcs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fvcs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fvcs.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -647,14 +647,7 @@ const (\n func RepoRootForImportPath(importPath string, mod ModuleMode, security web.SecurityMode) (*RepoRoot, error) {\n \trr, err := repoRootFromVCSPaths(importPath, \"\", security, vcsPaths)\n \tif err == errUnknownSite {\n-\t\t// If there are wildcards, look up the thing before the wildcard,\n-\t\t// hoping it applies to the wildcarded parts too.\n-\t\t// This makes 'go get rsc.io/pdf/...' work in a fresh GOPATH.\n-\t\tlookup := strings.TrimSuffix(importPath, \"/...\")\n-\t\tif i := strings.Index(lookup, \"/.../\"); i >= 0 {\n-\t\t\tlookup = lookup[:i]\n-\t\t}\n-\t\trr, err = repoRootForImportDynamic(lookup, mod, security)\n+\t\trr, err = repoRootForImportDynamic(importPath, mod, security)\n \t\tif err != nil {\n \t\t\terr = fmt.Errorf(\"unrecognized import path %q (%v)\", importPath, err)\n \t\t}\n@@ -667,6 +660,7 @@ func RepoRootForImportPath(importPath string, mod ModuleMode, security web.Secur\n \t\t}\n \t}\n \n+\t// Should have been taken care of above, but make sure.\n \tif err == nil && strings.Contains(importPath, \"...\") && strings.Contains(rr.Root, \"...\") {\n \t\t// Do not allow wildcards in the repo root.\n \t\trr = nil\n@@ -903,16 +897,16 @@ type metaImport struct {\n \tPrefix, VCS, RepoRoot string\n }\n \n-func splitPathHasPrefix(path, prefix []string) bool {\n-\tif len(path) < len(prefix) {\n+// pathPrefix reports whether sub is a prefix of s,\n+// only considering entire path components.\n+func pathPrefix(s, sub string) bool {\n+\t// strings.HasPrefix is necessary but not sufficient.\n+\tif !strings.HasPrefix(s, sub) {\n \t\treturn false\n \t}\n-\tfor i, p := range prefix {\n-\t\tif path[i] != p {\n-\t\t\treturn false\n-\t\t}\n-\t}\n-\treturn true\n+\t// The remainder after the prefix must either be empty or start with a slash.\n+\trem := s[len(sub):]\n+\treturn rem == \"\" || rem[0] == '/'\n }\n \n // A ImportMismatchError is returned where metaImport/s are present\n@@ -935,13 +929,10 @@ func (m ImportMismatchError) Error() string {\n // errNoMatch is returned if none match.\n func matchGoImport(imports []metaImport, importPath string) (metaImport, error) {\n \tmatch := -1\n-\timp := strings.Split(importPath, \"/\")\n \n \terrImportMismatch := ImportMismatchError{importPath: importPath}\n \tfor i, im := range imports {\n-\t\tpre := strings.Split(im.Prefix, \"/\")\n-\n-\t\tif !splitPathHasPrefix(imp, pre) {\n+\t\tif !pathPrefix(importPath, im.Prefix) {\n \t\t\terrImportMismatch.mismatches = append(errImportMismatch.mismatches, im.Prefix)\n \t\t\tcontinue\n \t\t}\n@@ -966,10 +957,14 @@ func matchGoImport(imports []metaImport, importPath string) (metaImport, error)\n \n // expand rewrites s to replace {k} with match[k] for each key k in match.\n func expand(match map[string]string, s string) string {\n+\t// We want to replace each match exactly once, and the result of expansion\n+\t// must not depend on the iteration order through the map.\n+\t// A strings.Replacer has exactly the properties we're looking for.\n+\toldNew := make([]string, 0, 2*len(match))\n \tfor k, v := range match {\n-\t\ts = strings.Replace(s, \"{\"+k+\"}\", v, -1)\n+\t\toldNew = append(oldNew, \"{\"+k+\"}\", v)\n \t}\n-\treturn s\n+\treturn strings.NewReplacer(oldNew...).Replace(s)\n }\n \n // vcsPaths defines the meaning of import paths referring to"}, {"sha": "312a29590f43f0fbd65aea08de3caff15cdce6bc", "filename": "libgo/go/cmd/go/internal/help/help.go", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelp.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -20,16 +20,16 @@ import (\n )\n \n // Help implements the 'help' command.\n-func Help(args []string) {\n+func Help(w io.Writer, args []string) {\n \t// 'go help documentation' generates doc.go.\n \tif len(args) == 1 && args[0] == \"documentation\" {\n-\t\tfmt.Println(\"// Copyright 2011 The Go Authors. All rights reserved.\")\n-\t\tfmt.Println(\"// Use of this source code is governed by a BSD-style\")\n-\t\tfmt.Println(\"// license that can be found in the LICENSE file.\")\n-\t\tfmt.Println()\n-\t\tfmt.Println(\"// Code generated by mkalldocs.sh; DO NOT EDIT.\")\n-\t\tfmt.Println(\"// Edit the documentation in other files and rerun mkalldocs.sh to generate this one.\")\n-\t\tfmt.Println()\n+\t\tfmt.Fprintln(w, \"// Copyright 2011 The Go Authors. All rights reserved.\")\n+\t\tfmt.Fprintln(w, \"// Use of this source code is governed by a BSD-style\")\n+\t\tfmt.Fprintln(w, \"// license that can be found in the LICENSE file.\")\n+\t\tfmt.Fprintln(w)\n+\t\tfmt.Fprintln(w, \"// Code generated by mkalldocs.sh; DO NOT EDIT.\")\n+\t\tfmt.Fprintln(w, \"// Edit the documentation in other files and rerun mkalldocs.sh to generate this one.\")\n+\t\tfmt.Fprintln(w)\n \t\tbuf := new(bytes.Buffer)\n \t\tPrintUsage(buf, base.Go)\n \t\tusage := &base.Command{Long: buf.String()}\n@@ -42,8 +42,8 @@ func Help(args []string) {\n \t\t\tcmds = append(cmds, cmd)\n \t\t\tcmds = append(cmds, cmd.Commands...)\n \t\t}\n-\t\ttmpl(&commentWriter{W: os.Stdout}, documentationTemplate, cmds)\n-\t\tfmt.Println(\"package main\")\n+\t\ttmpl(&commentWriter{W: w}, documentationTemplate, cmds)\n+\t\tfmt.Fprintln(w, \"package main\")\n \t\treturn\n \t}\n "}, {"sha": "973bfbc611d89d025ed1f2f451217d2f4c6f40ed", "filename": "libgo/go/cmd/go/internal/help/helpdoc.go", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelpdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelpdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelpdoc.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -266,7 +266,7 @@ listed in the GOPATH environment variable.\n (See 'go help gopath-get' and 'go help gopath'.)\n \n When using modules, downloaded packages are stored in the module cache.\n-(See 'go help modules-get' and 'go help goproxy'.)\n+(See 'go help module-get' and 'go help goproxy'.)\n \n When using modules, an additional variant of the go-import meta tag is\n recognized and is preferred over those listing version control systems.\n@@ -509,9 +509,7 @@ General-purpose environment variables:\n \n Each entry in the GOFLAGS list must be a standalone flag.\n Because the entries are space-separated, flag values must\n-not contain spaces. In some cases, you can provide multiple flag\n-values instead: for example, to set '-ldflags=-s -w'\n-you can use 'GOFLAGS=-ldflags=-s -ldflags=-w'.\n+not contain spaces.\n \n Environment variables for use with cgo:\n \n@@ -546,6 +544,10 @@ Environment variables for use with cgo:\n \t\tThe command to use to compile C++ code.\n \tPKG_CONFIG\n \t\tPath to pkg-config tool.\n+\tAR\n+\t\tThe command to use to manipulate library archives when\n+\t\tbuilding with the gccgo compiler.\n+\t\tThe default is 'ar'.\n \n Architecture-specific environment variables:\n "}, {"sha": "ddf425b0204dcf6885ef7bd33a91d49f536040b4", "filename": "libgo/go/cmd/go/internal/imports/build.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fbuild.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -207,5 +207,5 @@ func init() {\n \t}\n }\n \n-const goosList = \"android darwin dragonfly freebsd js linux nacl netbsd openbsd plan9 solaris windows zos \"\n+const goosList = \"aix android darwin dragonfly freebsd hurd js linux nacl netbsd openbsd plan9 solaris windows zos \"\n const goarchList = \"386 amd64 amd64p32 arm armbe arm64 arm64be ppc64 ppc64le mips mipsle mips64 mips64le mips64p32 mips64p32le ppc riscv riscv64 s390 s390x sparc sparc64 wasm \""}, {"sha": "966a38cfef3adf2ad353ba0c6eab85b9493f46a2", "filename": "libgo/go/cmd/go/internal/imports/scan.go", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fscan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fscan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fscan.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -22,6 +22,16 @@ func ScanDir(dir string, tags map[string]bool) ([]string, []string, error) {\n \tvar files []string\n \tfor _, info := range infos {\n \t\tname := info.Name()\n+\n+\t\t// If the directory entry is a symlink, stat it to obtain the info for the\n+\t\t// link target instead of the link itself.\n+\t\tif info.Mode()&os.ModeSymlink != 0 {\n+\t\t\tinfo, err = os.Stat(name)\n+\t\t\tif err != nil {\n+\t\t\t\tcontinue // Ignore broken symlinks.\n+\t\t\t}\n+\t\t}\n+\n \t\tif info.Mode().IsRegular() && !strings.HasPrefix(name, \"_\") && strings.HasSuffix(name, \".go\") && MatchFile(name, tags) {\n \t\t\tfiles = append(files, filepath.Join(dir, name))\n \t\t}"}, {"sha": "543250e86c1c89a045fb791676ba8f633d4c448b", "filename": "libgo/go/cmd/go/internal/load/pkg.go", "status": "modified", "additions": 20, "deletions": 25, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -440,6 +440,10 @@ const (\n // this package, as part of a bigger load operation, and by GOPATH-based \"go get\".\n // TODO(rsc): When GOPATH-based \"go get\" is removed, unexport this function.\n func LoadImport(path, srcDir string, parent *Package, stk *ImportStack, importPos []token.Position, mode int) *Package {\n+\tif path == \"\" {\n+\t\tpanic(\"LoadImport called with empty package path\")\n+\t}\n+\n \tstk.Push(path)\n \tdefer stk.Pop()\n \n@@ -999,10 +1003,12 @@ func disallowInternal(srcDir string, importer *Package, importerPath string, p *\n \t} else {\n \t\t// p is in a module, so make it available based on the importer's import path instead\n \t\t// of the file path (https://golang.org/issue/23970).\n-\t\tif importerPath == \".\" {\n+\t\tif importer.Internal.CmdlineFiles {\n \t\t\t// The importer is a list of command-line files.\n \t\t\t// Pretend that the import path is the import path of the\n \t\t\t// directory containing them.\n+\t\t\t// If the directory is outside the main module, this will resolve to \".\",\n+\t\t\t// which is not a prefix of any valid module.\n \t\t\timporterPath = ModDirImportPath(importer.Dir)\n \t\t}\n \t\tparentOfInternal := p.ImportPath[:i]\n@@ -1053,20 +1059,6 @@ func disallowVendor(srcDir string, importer *Package, importerPath, path string,\n \t\treturn p\n \t}\n \n-\t// Modules must not import vendor packages in the standard library,\n-\t// but the usual vendor visibility check will not catch them\n-\t// because the module loader presents them with an ImportPath starting\n-\t// with \"golang_org/\" instead of \"vendor/\".\n-\tif p.Standard && !importer.Standard && strings.HasPrefix(p.ImportPath, \"golang_org\") {\n-\t\tperr := *p\n-\t\tperr.Error = &PackageError{\n-\t\t\tImportStack: stk.Copy(),\n-\t\t\tErr:         \"use of vendored package \" + path + \" not allowed\",\n-\t\t}\n-\t\tperr.Incomplete = true\n-\t\treturn &perr\n-\t}\n-\n \tif perr := disallowVendorVisibility(srcDir, p, stk); perr != p {\n \t\treturn perr\n \t}\n@@ -1345,6 +1337,7 @@ func (p *Package) load(stk *ImportStack, bp *build.Package, err error) {\n \n \t// SWIG adds imports of some standard packages.\n \tif p.UsesSwig() {\n+\t\taddImport(\"unsafe\", true)\n \t\tif cfg.BuildContext.Compiler != \"gccgo\" {\n \t\t\taddImport(\"runtime/cgo\", true)\n \t\t}\n@@ -1530,9 +1523,13 @@ func (p *Package) load(stk *ImportStack, bp *build.Package, err error) {\n \t}\n \n \tif cfg.ModulesEnabled {\n-\t\tp.Module = ModPackageModuleInfo(p.ImportPath)\n+\t\tmainPath := p.ImportPath\n+\t\tif p.Internal.CmdlineFiles {\n+\t\t\tmainPath = \"command-line-arguments\"\n+\t\t}\n+\t\tp.Module = ModPackageModuleInfo(mainPath)\n \t\tif p.Name == \"main\" {\n-\t\t\tp.Internal.BuildInfo = ModPackageBuildInfo(p.ImportPath, p.Deps)\n+\t\t\tp.Internal.BuildInfo = ModPackageBuildInfo(mainPath, p.Deps)\n \t\t}\n \t}\n }\n@@ -1756,6 +1753,9 @@ func LoadPackageNoFlags(arg string, stk *ImportStack) *Package {\n // loadPackage accepts pseudo-paths beginning with cmd/ to denote commands\n // in the Go command directory, as well as paths to those directories.\n func loadPackage(arg string, stk *ImportStack) *Package {\n+\tif arg == \"\" {\n+\t\tpanic(\"loadPackage called with empty package path\")\n+\t}\n \tif build.IsLocalImport(arg) {\n \t\tdir := arg\n \t\tif !filepath.IsAbs(dir) {\n@@ -1779,9 +1779,6 @@ func loadPackage(arg string, stk *ImportStack) *Package {\n \t\tbp.ImportPath = arg\n \t\tbp.Goroot = true\n \t\tbp.BinDir = cfg.GOROOTbin\n-\t\tif cfg.GOROOTbin != \"\" {\n-\t\t\tbp.BinDir = cfg.GOROOTbin\n-\t\t}\n \t\tbp.Root = cfg.GOROOT\n \t\tbp.SrcRoot = cfg.GOROOTsrc\n \t\tp := new(Package)\n@@ -1854,6 +1851,9 @@ func PackagesAndErrors(patterns []string) []*Package {\n \n \tfor _, m := range matches {\n \t\tfor _, pkg := range m.Pkgs {\n+\t\t\tif pkg == \"\" {\n+\t\t\t\tpanic(fmt.Sprintf(\"ImportPaths returned empty package for pattern %s\", m.Pattern))\n+\t\t\t}\n \t\t\tp := loadPackage(pkg, &stk)\n \t\t\tp.Match = append(p.Match, m.Pattern)\n \t\t\tp.Internal.CmdlinePkg = true\n@@ -1996,11 +1996,6 @@ func GoFilesPackage(gofiles []string) *Package {\n \t}\n \n \tbp, err := ctxt.ImportDir(dir, 0)\n-\tif ModDirImportPath != nil {\n-\t\t// Use the effective import path of the directory\n-\t\t// for deciding visibility during pkg.load.\n-\t\tbp.ImportPath = ModDirImportPath(dir)\n-\t}\n \tpkg := new(Package)\n \tpkg.Internal.Local = true\n \tpkg.Internal.CmdlineFiles = true"}, {"sha": "5f9daa4957845d4a54f3d561f0cb9fdfe3f00c4d", "filename": "libgo/go/cmd/go/internal/load/test.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ftest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ftest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ftest.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -227,6 +227,12 @@ func GetTestPackagesFor(p *Package, cover *TestCover) (pmain, ptest, pxtest *Pac\n \t\t}\n \t}\n \n+\tallTestImports := make([]*Package, 0, len(pmain.Internal.Imports)+len(imports)+len(ximports))\n+\tallTestImports = append(allTestImports, pmain.Internal.Imports...)\n+\tallTestImports = append(allTestImports, imports...)\n+\tallTestImports = append(allTestImports, ximports...)\n+\tsetToolFlags(allTestImports...)\n+\n \t// Do initial scan for metadata needed for writing _testmain.go\n \t// Use that metadata to update the list of imports for package main.\n \t// The list of imports is used by recompileForTest and by the loop"}, {"sha": "aba3eed7767db7c9fa5ebfa9f822de71e0fac2db", "filename": "libgo/go/cmd/go/internal/lockedfile/internal/filelock/filelock.go", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -0,0 +1,98 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package filelock provides a platform-independent API for advisory file\n+// locking. Calls to functions in this package on platforms that do not support\n+// advisory locks will return errors for which IsNotSupported returns true.\n+package filelock\n+\n+import (\n+\t\"errors\"\n+\t\"os\"\n+)\n+\n+// A File provides the minimal set of methods required to lock an open file.\n+// File implementations must be usable as map keys.\n+// The usual implementation is *os.File.\n+type File interface {\n+\t// Name returns the name of the file.\n+\tName() string\n+\n+\t// Fd returns a valid file descriptor.\n+\t// (If the File is an *os.File, it must not be closed.)\n+\tFd() uintptr\n+\n+\t// Stat returns the FileInfo structure describing file.\n+\tStat() (os.FileInfo, error)\n+}\n+\n+// Lock places an advisory write lock on the file, blocking until it can be\n+// locked.\n+//\n+// If Lock returns nil, no other process will be able to place a read or write\n+// lock on the file until this process exits, closes f, or calls Unlock on it.\n+//\n+// If f's descriptor is already read- or write-locked, the behavior of Lock is\n+// unspecified.\n+//\n+// Closing the file may or may not release the lock promptly. Callers should\n+// ensure that Unlock is always called when Lock succeeds.\n+func Lock(f File) error {\n+\treturn lock(f, writeLock)\n+}\n+\n+// RLock places an advisory read lock on the file, blocking until it can be locked.\n+//\n+// If RLock returns nil, no other process will be able to place a write lock on\n+// the file until this process exits, closes f, or calls Unlock on it.\n+//\n+// If f is already read- or write-locked, the behavior of RLock is unspecified.\n+//\n+// Closing the file may or may not release the lock promptly. Callers should\n+// ensure that Unlock is always called if RLock succeeds.\n+func RLock(f File) error {\n+\treturn lock(f, readLock)\n+}\n+\n+// Unlock removes an advisory lock placed on f by this process.\n+//\n+// The caller must not attempt to unlock a file that is not locked.\n+func Unlock(f File) error {\n+\treturn unlock(f)\n+}\n+\n+// String returns the name of the function corresponding to lt\n+// (Lock, RLock, or Unlock).\n+func (lt lockType) String() string {\n+\tswitch lt {\n+\tcase readLock:\n+\t\treturn \"RLock\"\n+\tcase writeLock:\n+\t\treturn \"Lock\"\n+\tdefault:\n+\t\treturn \"Unlock\"\n+\t}\n+}\n+\n+// IsNotSupported returns a boolean indicating whether the error is known to\n+// report that a function is not supported (possibly for a specific input).\n+// It is satisfied by ErrNotSupported as well as some syscall errors.\n+func IsNotSupported(err error) bool {\n+\treturn isNotSupported(underlyingError(err))\n+}\n+\n+var ErrNotSupported = errors.New(\"operation not supported\")\n+\n+// underlyingError returns the underlying error for known os error types.\n+func underlyingError(err error) error {\n+\tswitch err := err.(type) {\n+\tcase *os.PathError:\n+\t\treturn err.Err\n+\tcase *os.LinkError:\n+\t\treturn err.Err\n+\tcase *os.SyscallError:\n+\t\treturn err.Err\n+\t}\n+\treturn err\n+}"}, {"sha": "2831975c0c69ef386bf9fdcdc8bf608d536d2f8e", "filename": "libgo/go/cmd/go/internal/lockedfile/internal/filelock/filelock_fcntl.go", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_fcntl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_fcntl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_fcntl.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -0,0 +1,159 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build aix solaris\n+\n+// This code implements the filelock API using POSIX 'fcntl' locks, which attach\n+// to an (inode, process) pair rather than a file descriptor. To avoid unlocking\n+// files prematurely when the same file is opened through different descriptors,\n+// we allow only one read-lock at a time.\n+//\n+// Most platforms provide some alternative API, such as an 'flock' system call\n+// or an F_OFD_SETLK command for 'fcntl', that allows for better concurrency and\n+// does not require per-inode bookkeeping in the application.\n+//\n+// TODO(bcmills): If we add a build tag for Illumos (see golang.org/issue/20603)\n+// then Illumos should use F_OFD_SETLK, and the resulting code would be as\n+// simple as filelock_unix.go. We will still need the code in this file for AIX\n+// or as long as Oracle Solaris provides only F_SETLK.\n+\n+package filelock\n+\n+import (\n+\t\"errors\"\n+\t\"io\"\n+\t\"os\"\n+\t\"sync\"\n+\t\"syscall\"\n+)\n+\n+type lockType int16\n+\n+const (\n+\treadLock  lockType = syscall.F_RDLCK\n+\twriteLock lockType = syscall.F_WRLCK\n+)\n+\n+type inode = uint64 // type of syscall.Stat_t.Ino\n+\n+type inodeLock struct {\n+\towner File\n+\tqueue []<-chan File\n+}\n+\n+type token struct{}\n+\n+var (\n+\tmu     sync.Mutex\n+\tinodes = map[File]inode{}\n+\tlocks  = map[inode]inodeLock{}\n+)\n+\n+func lock(f File, lt lockType) (err error) {\n+\t// POSIX locks apply per inode and process, and the lock for an inode is\n+\t// released when *any* descriptor for that inode is closed. So we need to\n+\t// synchronize access to each inode internally, and must serialize lock and\n+\t// unlock calls that refer to the same inode through different descriptors.\n+\tfi, err := f.Stat()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tino := fi.Sys().(*syscall.Stat_t).Ino\n+\n+\tmu.Lock()\n+\tif i, dup := inodes[f]; dup && i != ino {\n+\t\tmu.Unlock()\n+\t\treturn &os.PathError{\n+\t\t\tOp:   lt.String(),\n+\t\t\tPath: f.Name(),\n+\t\t\tErr:  errors.New(\"inode for file changed since last Lock or RLock\"),\n+\t\t}\n+\t}\n+\tinodes[f] = ino\n+\n+\tvar wait chan File\n+\tl := locks[ino]\n+\tif l.owner == f {\n+\t\t// This file already owns the lock, but the call may change its lock type.\n+\t} else if l.owner == nil {\n+\t\t// No owner: it's ours now.\n+\t\tl.owner = f\n+\t} else {\n+\t\t// Already owned: add a channel to wait on.\n+\t\twait = make(chan File)\n+\t\tl.queue = append(l.queue, wait)\n+\t}\n+\tlocks[ino] = l\n+\tmu.Unlock()\n+\n+\tif wait != nil {\n+\t\twait <- f\n+\t}\n+\n+\terr = setlkw(f.Fd(), lt)\n+\n+\tif err != nil {\n+\t\tunlock(f)\n+\t\treturn &os.PathError{\n+\t\t\tOp:   lt.String(),\n+\t\t\tPath: f.Name(),\n+\t\t\tErr:  err,\n+\t\t}\n+\t}\n+\n+\treturn nil\n+}\n+\n+func unlock(f File) error {\n+\tvar owner File\n+\n+\tmu.Lock()\n+\tino, ok := inodes[f]\n+\tif ok {\n+\t\towner = locks[ino].owner\n+\t}\n+\tmu.Unlock()\n+\n+\tif owner != f {\n+\t\tpanic(\"unlock called on a file that is not locked\")\n+\t}\n+\n+\terr := setlkw(f.Fd(), syscall.F_UNLCK)\n+\n+\tmu.Lock()\n+\tl := locks[ino]\n+\tif len(l.queue) == 0 {\n+\t\t// No waiters: remove the map entry.\n+\t\tdelete(locks, ino)\n+\t} else {\n+\t\t// The first waiter is sending us their file now.\n+\t\t// Receive it and update the queue.\n+\t\tl.owner = <-l.queue[0]\n+\t\tl.queue = l.queue[1:]\n+\t\tlocks[ino] = l\n+\t}\n+\tdelete(inodes, f)\n+\tmu.Unlock()\n+\n+\treturn err\n+}\n+\n+// setlkw calls FcntlFlock with F_SETLKW for the entire file indicated by fd.\n+func setlkw(fd uintptr, lt lockType) error {\n+\tfor {\n+\t\terr := syscall.FcntlFlock(fd, syscall.F_SETLKW, &syscall.Flock_t{\n+\t\t\tType:   int16(lt),\n+\t\t\tWhence: io.SeekStart,\n+\t\t\tStart:  0,\n+\t\t\tLen:    0, // All bytes.\n+\t\t})\n+\t\tif err != syscall.EINTR {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+}\n+\n+func isNotSupported(err error) bool {\n+\treturn err == syscall.ENOSYS || err == syscall.ENOTSUP || err == syscall.EOPNOTSUPP || err == ErrNotSupported\n+}"}, {"sha": "107611e1ce85f63b56d103ee7fec7456c6891a11", "filename": "libgo/go/cmd/go/internal/lockedfile/internal/filelock/filelock_other.go", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_other.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_other.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_other.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build !aix,!darwin,!dragonfly,!freebsd,!linux,!netbsd,!openbsd,!plan9,!solaris,!windows\n+\n+package filelock\n+\n+import \"os\"\n+\n+type lockType int8\n+\n+const (\n+\treadLock = iota + 1\n+\twriteLock\n+)\n+\n+func lock(f File, lt lockType) error {\n+\treturn &os.PathError{\n+\t\tOp:   lt.String(),\n+\t\tPath: f.Name(),\n+\t\tErr:  ErrNotSupported,\n+\t}\n+}\n+\n+func unlock(f File) error {\n+\treturn &os.PathError{\n+\t\tOp:   \"Unlock\",\n+\t\tPath: f.Name(),\n+\t\tErr:  ErrNotSupported,\n+\t}\n+}\n+\n+func isNotSupported(err error) bool {\n+\treturn err == ErrNotSupported\n+}"}, {"sha": "afdffe323fcde60d00511d8bdfb26fc73a6fa8a3", "filename": "libgo/go/cmd/go/internal/lockedfile/internal/filelock/filelock_plan9.go", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_plan9.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build plan9\n+\n+package filelock\n+\n+import (\n+\t\"os\"\n+)\n+\n+type lockType int8\n+\n+const (\n+\treadLock = iota + 1\n+\twriteLock\n+)\n+\n+func lock(f File, lt lockType) error {\n+\treturn &os.PathError{\n+\t\tOp:   lt.String(),\n+\t\tPath: f.Name(),\n+\t\tErr:  ErrNotSupported,\n+\t}\n+}\n+\n+func unlock(f File) error {\n+\treturn &os.PathError{\n+\t\tOp:   \"Unlock\",\n+\t\tPath: f.Name(),\n+\t\tErr:  ErrNotSupported,\n+\t}\n+}\n+\n+func isNotSupported(err error) bool {\n+\treturn err == ErrNotSupported\n+}"}, {"sha": "aa67093a48aad68cb7adff8dc99c718a3032d88f", "filename": "libgo/go/cmd/go/internal/lockedfile/internal/filelock/filelock_test.go", "status": "added", "additions": 209, "deletions": 0, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_test.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -0,0 +1,209 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build !js,!nacl,!plan9\n+\n+package filelock_test\n+\n+import (\n+\t\"fmt\"\n+\t\"internal/testenv\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"path/filepath\"\n+\t\"runtime\"\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"cmd/go/internal/lockedfile/internal/filelock\"\n+)\n+\n+func lock(t *testing.T, f *os.File) {\n+\tt.Helper()\n+\terr := filelock.Lock(f)\n+\tt.Logf(\"Lock(fd %d) = %v\", f.Fd(), err)\n+\tif err != nil {\n+\t\tt.Fail()\n+\t}\n+}\n+\n+func rLock(t *testing.T, f *os.File) {\n+\tt.Helper()\n+\terr := filelock.RLock(f)\n+\tt.Logf(\"RLock(fd %d) = %v\", f.Fd(), err)\n+\tif err != nil {\n+\t\tt.Fail()\n+\t}\n+}\n+\n+func unlock(t *testing.T, f *os.File) {\n+\tt.Helper()\n+\terr := filelock.Unlock(f)\n+\tt.Logf(\"Unlock(fd %d) = %v\", f.Fd(), err)\n+\tif err != nil {\n+\t\tt.Fail()\n+\t}\n+}\n+\n+func mustTempFile(t *testing.T) (f *os.File, remove func()) {\n+\tt.Helper()\n+\n+\tbase := filepath.Base(t.Name())\n+\tf, err := ioutil.TempFile(\"\", base)\n+\tif err != nil {\n+\t\tt.Fatalf(`ioutil.TempFile(\"\", %q) = %v`, base, err)\n+\t}\n+\tt.Logf(\"fd %d = %s\", f.Fd(), f.Name())\n+\n+\treturn f, func() {\n+\t\tf.Close()\n+\t\tos.Remove(f.Name())\n+\t}\n+}\n+\n+func mustOpen(t *testing.T, name string) *os.File {\n+\tt.Helper()\n+\n+\tf, err := os.OpenFile(name, os.O_RDWR, 0)\n+\tif err != nil {\n+\t\tt.Fatalf(\"os.Open(%q) = %v\", name, err)\n+\t}\n+\n+\tt.Logf(\"fd %d = os.Open(%q)\", f.Fd(), name)\n+\treturn f\n+}\n+\n+const (\n+\tquiescent            = 10 * time.Millisecond\n+\tprobablyStillBlocked = 10 * time.Second\n+)\n+\n+func mustBlock(t *testing.T, op string, f *os.File) (wait func(*testing.T)) {\n+\tt.Helper()\n+\n+\tdesc := fmt.Sprintf(\"%s(fd %d)\", op, f.Fd())\n+\n+\tdone := make(chan struct{})\n+\tgo func() {\n+\t\tt.Helper()\n+\t\tswitch op {\n+\t\tcase \"Lock\":\n+\t\t\tlock(t, f)\n+\t\tcase \"RLock\":\n+\t\t\trLock(t, f)\n+\t\tdefault:\n+\t\t\tpanic(\"invalid op: \" + op)\n+\t\t}\n+\t\tclose(done)\n+\t}()\n+\n+\tselect {\n+\tcase <-done:\n+\t\tt.Fatalf(\"%s unexpectedly did not block\", desc)\n+\t\treturn nil\n+\n+\tcase <-time.After(quiescent):\n+\t\tt.Logf(\"%s is blocked (as expected)\", desc)\n+\t\treturn func(t *testing.T) {\n+\t\t\tt.Helper()\n+\t\t\tselect {\n+\t\t\tcase <-time.After(probablyStillBlocked):\n+\t\t\t\tt.Fatalf(\"%s is unexpectedly still blocked\", desc)\n+\t\t\tcase <-done:\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+func TestLockExcludesLock(t *testing.T) {\n+\tt.Parallel()\n+\n+\tf, remove := mustTempFile(t)\n+\tdefer remove()\n+\n+\tother := mustOpen(t, f.Name())\n+\tdefer other.Close()\n+\n+\tlock(t, f)\n+\tlockOther := mustBlock(t, \"Lock\", other)\n+\tunlock(t, f)\n+\tlockOther(t)\n+\tunlock(t, other)\n+}\n+\n+func TestLockExcludesRLock(t *testing.T) {\n+\tt.Parallel()\n+\n+\tf, remove := mustTempFile(t)\n+\tdefer remove()\n+\n+\tother := mustOpen(t, f.Name())\n+\tdefer other.Close()\n+\n+\tlock(t, f)\n+\trLockOther := mustBlock(t, \"RLock\", other)\n+\tunlock(t, f)\n+\trLockOther(t)\n+\tunlock(t, other)\n+}\n+\n+func TestRLockExcludesOnlyLock(t *testing.T) {\n+\tt.Parallel()\n+\n+\tf, remove := mustTempFile(t)\n+\tdefer remove()\n+\trLock(t, f)\n+\n+\tf2 := mustOpen(t, f.Name())\n+\tdefer f2.Close()\n+\n+\tif runtime.GOOS == \"solaris\" || runtime.GOOS == \"aix\" {\n+\t\t// When using POSIX locks (as on Solaris), we can't safely read-lock the\n+\t\t// same inode through two different descriptors at the same time: when the\n+\t\t// first descriptor is closed, the second descriptor would still be open but\n+\t\t// silently unlocked. So a second RLock must block instead of proceeding.\n+\t\tlockF2 := mustBlock(t, \"RLock\", f2)\n+\t\tunlock(t, f)\n+\t\tlockF2(t)\n+\t} else {\n+\t\trLock(t, f2)\n+\t}\n+\n+\tother := mustOpen(t, f.Name())\n+\tdefer other.Close()\n+\tlockOther := mustBlock(t, \"Lock\", other)\n+\n+\tunlock(t, f2)\n+\tif runtime.GOOS != \"solaris\" && runtime.GOOS != \"aix\" {\n+\t\tunlock(t, f)\n+\t}\n+\tlockOther(t)\n+\tunlock(t, other)\n+}\n+\n+func TestLockNotDroppedByExecCommand(t *testing.T) {\n+\ttestenv.MustHaveExec(t)\n+\n+\tf, remove := mustTempFile(t)\n+\tdefer remove()\n+\n+\tlock(t, f)\n+\n+\tother := mustOpen(t, f.Name())\n+\tdefer other.Close()\n+\n+\t// Some kinds of file locks are dropped when a duplicated or forked file\n+\t// descriptor is unlocked. Double-check that the approach used by os/exec does\n+\t// not accidentally drop locks.\n+\tcmd := exec.Command(os.Args[0], \"-test.run=^$\")\n+\tif err := cmd.Run(); err != nil {\n+\t\tt.Fatalf(\"exec failed: %v\", err)\n+\t}\n+\n+\tlockOther := mustBlock(t, \"Lock\", other)\n+\tunlock(t, f)\n+\tlockOther(t)\n+\tunlock(t, other)\n+}"}, {"sha": "00c4262832214f48189c7ea92ac06335a9772e17", "filename": "libgo/go/cmd/go/internal/lockedfile/internal/filelock/filelock_unix.go", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_unix.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build darwin dragonfly freebsd linux netbsd openbsd\n+\n+package filelock\n+\n+import (\n+\t\"os\"\n+\t\"syscall\"\n+)\n+\n+type lockType int16\n+\n+const (\n+\treadLock  lockType = syscall.LOCK_SH\n+\twriteLock lockType = syscall.LOCK_EX\n+)\n+\n+func lock(f File, lt lockType) (err error) {\n+\tfor {\n+\t\terr = syscall.Flock(int(f.Fd()), int(lt))\n+\t\tif err != syscall.EINTR {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\tif err != nil {\n+\t\treturn &os.PathError{\n+\t\t\tOp:   lt.String(),\n+\t\t\tPath: f.Name(),\n+\t\t\tErr:  err,\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func unlock(f File) error {\n+\treturn lock(f, syscall.LOCK_UN)\n+}\n+\n+func isNotSupported(err error) bool {\n+\treturn err == syscall.ENOSYS || err == syscall.ENOTSUP || err == syscall.EOPNOTSUPP || err == ErrNotSupported\n+}"}, {"sha": "43e85e450ec0116281f681b48c65843009ccc8af", "filename": "libgo/go/cmd/go/internal/lockedfile/internal/filelock/filelock_windows.go", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_windows.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -0,0 +1,66 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build windows\n+\n+package filelock\n+\n+import (\n+\t\"internal/syscall/windows\"\n+\t\"os\"\n+\t\"syscall\"\n+)\n+\n+type lockType uint32\n+\n+const (\n+\treadLock  lockType = 0\n+\twriteLock lockType = windows.LOCKFILE_EXCLUSIVE_LOCK\n+)\n+\n+const (\n+\treserved = 0\n+\tallBytes = ^uint32(0)\n+)\n+\n+func lock(f File, lt lockType) error {\n+\t// Per https://golang.org/issue/19098, \u201cPrograms currently expect the Fd\n+\t// method to return a handle that uses ordinary synchronous I/O.\u201d\n+\t// However, LockFileEx still requires an OVERLAPPED structure,\n+\t// which contains the file offset of the beginning of the lock range.\n+\t// We want to lock the entire file, so we leave the offset as zero.\n+\tol := new(syscall.Overlapped)\n+\n+\terr := windows.LockFileEx(syscall.Handle(f.Fd()), uint32(lt), reserved, allBytes, allBytes, ol)\n+\tif err != nil {\n+\t\treturn &os.PathError{\n+\t\t\tOp:   lt.String(),\n+\t\t\tPath: f.Name(),\n+\t\t\tErr:  err,\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func unlock(f File) error {\n+\tol := new(syscall.Overlapped)\n+\terr := windows.UnlockFileEx(syscall.Handle(f.Fd()), reserved, allBytes, allBytes, ol)\n+\tif err != nil {\n+\t\treturn &os.PathError{\n+\t\t\tOp:   \"Unlock\",\n+\t\t\tPath: f.Name(),\n+\t\t\tErr:  err,\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func isNotSupported(err error) bool {\n+\tswitch err {\n+\tcase windows.ERROR_NOT_SUPPORTED, windows.ERROR_CALL_NOT_IMPLEMENTED, ErrNotSupported:\n+\t\treturn true\n+\tdefault:\n+\t\treturn false\n+\t}\n+}"}, {"sha": "bb184b1085e4ee8f7c467df50bdcbc5bbdd5cffc", "filename": "libgo/go/cmd/go/internal/lockedfile/lockedfile.go", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -0,0 +1,122 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package lockedfile creates and manipulates files whose contents should only\n+// change atomically.\n+package lockedfile\n+\n+import (\n+\t\"fmt\"\n+\t\"io\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"runtime\"\n+)\n+\n+// A File is a locked *os.File.\n+//\n+// Closing the file releases the lock.\n+//\n+// If the program exits while a file is locked, the operating system releases\n+// the lock but may not do so promptly: callers must ensure that all locked\n+// files are closed before exiting.\n+type File struct {\n+\tosFile\n+\tclosed bool\n+}\n+\n+// osFile embeds a *os.File while keeping the pointer itself unexported.\n+// (When we close a File, it must be the same file descriptor that we opened!)\n+type osFile struct {\n+\t*os.File\n+}\n+\n+// OpenFile is like os.OpenFile, but returns a locked file.\n+// If flag includes os.O_WRONLY or os.O_RDWR, the file is write-locked;\n+// otherwise, it is read-locked.\n+func OpenFile(name string, flag int, perm os.FileMode) (*File, error) {\n+\tvar (\n+\t\tf   = new(File)\n+\t\terr error\n+\t)\n+\tf.osFile.File, err = openFile(name, flag, perm)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\t// Although the operating system will drop locks for open files when the go\n+\t// command exits, we want to hold locks for as little time as possible, and we\n+\t// especially don't want to leave a file locked after we're done with it. Our\n+\t// Close method is what releases the locks, so use a finalizer to report\n+\t// missing Close calls on a best-effort basis.\n+\truntime.SetFinalizer(f, func(f *File) {\n+\t\tpanic(fmt.Sprintf(\"lockedfile.File %s became unreachable without a call to Close\", f.Name()))\n+\t})\n+\n+\treturn f, nil\n+}\n+\n+// Open is like os.Open, but returns a read-locked file.\n+func Open(name string) (*File, error) {\n+\treturn OpenFile(name, os.O_RDONLY, 0)\n+}\n+\n+// Create is like os.Create, but returns a write-locked file.\n+func Create(name string) (*File, error) {\n+\treturn OpenFile(name, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0666)\n+}\n+\n+// Edit creates the named file with mode 0666 (before umask),\n+// but does not truncate existing contents.\n+//\n+// If Edit succeeds, methods on the returned File can be used for I/O.\n+// The associated file descriptor has mode O_RDWR and the file is write-locked.\n+func Edit(name string) (*File, error) {\n+\treturn OpenFile(name, os.O_RDWR|os.O_CREATE, 0666)\n+}\n+\n+// Close unlocks and closes the underlying file.\n+//\n+// Close may be called multiple times; all calls after the first will return a\n+// non-nil error.\n+func (f *File) Close() error {\n+\tif f.closed {\n+\t\treturn &os.PathError{\n+\t\t\tOp:   \"close\",\n+\t\t\tPath: f.Name(),\n+\t\t\tErr:  os.ErrClosed,\n+\t\t}\n+\t}\n+\tf.closed = true\n+\n+\terr := closeFile(f.osFile.File)\n+\truntime.SetFinalizer(f, nil)\n+\treturn err\n+}\n+\n+// Read opens the named file with a read-lock and returns its contents.\n+func Read(name string) ([]byte, error) {\n+\tf, err := Open(name)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer f.Close()\n+\n+\treturn ioutil.ReadAll(f)\n+}\n+\n+// Write opens the named file (creating it with the given permissions if needed),\n+// then write-locks it and overwrites it with the given content.\n+func Write(name string, content io.Reader, perm os.FileMode) (err error) {\n+\tf, err := OpenFile(name, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, perm)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\t_, err = io.Copy(f, content)\n+\tif closeErr := f.Close(); err == nil {\n+\t\terr = closeErr\n+\t}\n+\treturn err\n+}"}, {"sha": "f63dd8664b0ab12e2038d746c9744f57187b4b24", "filename": "libgo/go/cmd/go/internal/lockedfile/lockedfile_filelock.go", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile_filelock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile_filelock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile_filelock.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -0,0 +1,64 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build !plan9\n+\n+package lockedfile\n+\n+import (\n+\t\"os\"\n+\n+\t\"cmd/go/internal/lockedfile/internal/filelock\"\n+)\n+\n+func openFile(name string, flag int, perm os.FileMode) (*os.File, error) {\n+\t// On BSD systems, we could add the O_SHLOCK or O_EXLOCK flag to the OpenFile\n+\t// call instead of locking separately, but we have to support separate locking\n+\t// calls for Linux and Windows anyway, so it's simpler to use that approach\n+\t// consistently.\n+\n+\tf, err := os.OpenFile(name, flag&^os.O_TRUNC, perm)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tswitch flag & (os.O_RDONLY | os.O_WRONLY | os.O_RDWR) {\n+\tcase os.O_WRONLY, os.O_RDWR:\n+\t\terr = filelock.Lock(f)\n+\tdefault:\n+\t\terr = filelock.RLock(f)\n+\t}\n+\tif err != nil {\n+\t\tf.Close()\n+\t\treturn nil, err\n+\t}\n+\n+\tif flag&os.O_TRUNC == os.O_TRUNC {\n+\t\tif err := f.Truncate(0); err != nil {\n+\t\t\t// The documentation for os.O_TRUNC says \u201cif possible, truncate file when\n+\t\t\t// opened\u201d, but doesn't define \u201cpossible\u201d (golang.org/issue/28699).\n+\t\t\t// We'll treat regular files (and symlinks to regular files) as \u201cpossible\u201d\n+\t\t\t// and ignore errors for the rest.\n+\t\t\tif fi, statErr := f.Stat(); statErr != nil || fi.Mode().IsRegular() {\n+\t\t\t\tfilelock.Unlock(f)\n+\t\t\t\tf.Close()\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn f, nil\n+}\n+\n+func closeFile(f *os.File) error {\n+\t// Since locking syscalls operate on file descriptors, we must unlock the file\n+\t// while the descriptor is still valid \u2014 that is, before the file is closed \u2014\n+\t// and avoid unlocking files that are already closed.\n+\terr := filelock.Unlock(f)\n+\n+\tif closeErr := f.Close(); err == nil {\n+\t\terr = closeErr\n+\t}\n+\treturn err\n+}"}, {"sha": "4a52c94976381eb8a3846f798b76c8b259da5f8e", "filename": "libgo/go/cmd/go/internal/lockedfile/lockedfile_plan9.go", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile_plan9.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -0,0 +1,93 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build plan9\n+\n+package lockedfile\n+\n+import (\n+\t\"math/rand\"\n+\t\"os\"\n+\t\"strings\"\n+\t\"time\"\n+)\n+\n+// Opening an exclusive-use file returns an error.\n+// The expected error strings are:\n+//\n+//  - \"open/create -- file is locked\" (cwfs, kfs)\n+//  - \"exclusive lock\" (fossil)\n+//  - \"exclusive use file already open\" (ramfs)\n+var lockedErrStrings = [...]string{\n+\t\"file is locked\",\n+\t\"exclusive lock\",\n+\t\"exclusive use file already open\",\n+}\n+\n+// Even though plan9 doesn't support the Lock/RLock/Unlock functions to\n+// manipulate already-open files, IsLocked is still meaningful: os.OpenFile\n+// itself may return errors that indicate that a file with the ModeExclusive bit\n+// set is already open.\n+func isLocked(err error) bool {\n+\ts := err.Error()\n+\n+\tfor _, frag := range lockedErrStrings {\n+\t\tif strings.Contains(s, frag) {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\n+\treturn false\n+}\n+\n+func openFile(name string, flag int, perm os.FileMode) (*os.File, error) {\n+\t// Plan 9 uses a mode bit instead of explicit lock/unlock syscalls.\n+\t//\n+\t// Per http://man.cat-v.org/plan_9/5/stat: \u201cExclusive use files may be open\n+\t// for I/O by only one fid at a time across all clients of the server. If a\n+\t// second open is attempted, it draws an error.\u201d\n+\t//\n+\t// So we can try to open a locked file, but if it fails we're on our own to\n+\t// figure out when it becomes available. We'll use exponential backoff with\n+\t// some jitter and an arbitrary limit of 500ms.\n+\n+\t// If the file was unpacked or created by some other program, it might not\n+\t// have the ModeExclusive bit set. Set it before we call OpenFile, so that we\n+\t// can be confident that a successful OpenFile implies exclusive use.\n+\tif fi, err := os.Stat(name); err == nil {\n+\t\tif fi.Mode()&os.ModeExclusive == 0 {\n+\t\t\tif err := os.Chmod(name, fi.Mode()|os.ModeExclusive); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t}\n+\t} else if !os.IsNotExist(err) {\n+\t\treturn nil, err\n+\t}\n+\n+\tnextSleep := 1 * time.Millisecond\n+\tconst maxSleep = 500 * time.Millisecond\n+\tfor {\n+\t\tf, err := os.OpenFile(name, flag, perm|os.ModeExclusive)\n+\t\tif err == nil {\n+\t\t\treturn f, nil\n+\t\t}\n+\n+\t\tif !isLocked(err) {\n+\t\t\treturn nil, err\n+\t\t}\n+\n+\t\ttime.Sleep(nextSleep)\n+\n+\t\tnextSleep += nextSleep\n+\t\tif nextSleep > maxSleep {\n+\t\t\tnextSleep = maxSleep\n+\t\t}\n+\t\t// Apply 10% jitter to avoid synchronizing collisions.\n+\t\tnextSleep += time.Duration((0.1*rand.Float64() - 0.05) * float64(nextSleep))\n+\t}\n+}\n+\n+func closeFile(f *os.File) error {\n+\treturn f.Close()\n+}"}, {"sha": "6d5819efdb0e91864f59fd2f879960a4b276db9e", "filename": "libgo/go/cmd/go/internal/lockedfile/lockedfile_test.go", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile_test.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -0,0 +1,174 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// js and nacl do not support inter-process file locking.\n+// +build !js,!nacl\n+\n+package lockedfile_test\n+\n+import (\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"cmd/go/internal/lockedfile\"\n+)\n+\n+func mustTempDir(t *testing.T) (dir string, remove func()) {\n+\tt.Helper()\n+\n+\tdir, err := ioutil.TempDir(\"\", filepath.Base(t.Name()))\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\treturn dir, func() { os.RemoveAll(dir) }\n+}\n+\n+const (\n+\tquiescent            = 10 * time.Millisecond\n+\tprobablyStillBlocked = 10 * time.Second\n+)\n+\n+func mustBlock(t *testing.T, desc string, f func()) (wait func(*testing.T)) {\n+\tt.Helper()\n+\n+\tdone := make(chan struct{})\n+\tgo func() {\n+\t\tf()\n+\t\tclose(done)\n+\t}()\n+\n+\tselect {\n+\tcase <-done:\n+\t\tt.Fatalf(\"%s unexpectedly did not block\", desc)\n+\t\treturn nil\n+\n+\tcase <-time.After(quiescent):\n+\t\treturn func(t *testing.T) {\n+\t\t\tt.Helper()\n+\t\t\tselect {\n+\t\t\tcase <-time.After(probablyStillBlocked):\n+\t\t\t\tt.Fatalf(\"%s is unexpectedly still blocked after %v\", desc, probablyStillBlocked)\n+\t\t\tcase <-done:\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+func TestMutexExcludes(t *testing.T) {\n+\tt.Parallel()\n+\n+\tdir, remove := mustTempDir(t)\n+\tdefer remove()\n+\n+\tpath := filepath.Join(dir, \"lock\")\n+\n+\tmu := lockedfile.MutexAt(path)\n+\tt.Logf(\"mu := MutexAt(_)\")\n+\n+\tunlock, err := mu.Lock()\n+\tif err != nil {\n+\t\tt.Fatalf(\"mu.Lock: %v\", err)\n+\t}\n+\tt.Logf(\"unlock, _  := mu.Lock()\")\n+\n+\tmu2 := lockedfile.MutexAt(mu.Path)\n+\tt.Logf(\"mu2 := MutexAt(mu.Path)\")\n+\n+\twait := mustBlock(t, \"mu2.Lock()\", func() {\n+\t\tunlock2, err := mu2.Lock()\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"mu2.Lock: %v\", err)\n+\t\t\treturn\n+\t\t}\n+\t\tt.Logf(\"unlock2, _ := mu2.Lock()\")\n+\t\tt.Logf(\"unlock2()\")\n+\t\tunlock2()\n+\t})\n+\n+\tt.Logf(\"unlock()\")\n+\tunlock()\n+\twait(t)\n+}\n+\n+func TestReadWaitsForLock(t *testing.T) {\n+\tt.Parallel()\n+\n+\tdir, remove := mustTempDir(t)\n+\tdefer remove()\n+\n+\tpath := filepath.Join(dir, \"timestamp.txt\")\n+\n+\tf, err := lockedfile.Create(path)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Create: %v\", err)\n+\t}\n+\tdefer f.Close()\n+\n+\tconst (\n+\t\tpart1 = \"part 1\\n\"\n+\t\tpart2 = \"part 2\\n\"\n+\t)\n+\t_, err = f.WriteString(part1)\n+\tif err != nil {\n+\t\tt.Fatalf(\"WriteString: %v\", err)\n+\t}\n+\tt.Logf(\"WriteString(%q) = <nil>\", part1)\n+\n+\twait := mustBlock(t, \"Read\", func() {\n+\t\tb, err := lockedfile.Read(path)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"Read: %v\", err)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tconst want = part1 + part2\n+\t\tgot := string(b)\n+\t\tif got == want {\n+\t\t\tt.Logf(\"Read(_) = %q\", got)\n+\t\t} else {\n+\t\t\tt.Errorf(\"Read(_) = %q, _; want %q\", got, want)\n+\t\t}\n+\t})\n+\n+\t_, err = f.WriteString(part2)\n+\tif err != nil {\n+\t\tt.Errorf(\"WriteString: %v\", err)\n+\t} else {\n+\t\tt.Logf(\"WriteString(%q) = <nil>\", part2)\n+\t}\n+\tf.Close()\n+\n+\twait(t)\n+}\n+\n+func TestCanLockExistingFile(t *testing.T) {\n+\tt.Parallel()\n+\n+\tdir, remove := mustTempDir(t)\n+\tdefer remove()\n+\tpath := filepath.Join(dir, \"existing.txt\")\n+\n+\tif err := ioutil.WriteFile(path, []byte(\"ok\"), 0777); err != nil {\n+\t\tt.Fatalf(\"ioutil.WriteFile: %v\", err)\n+\t}\n+\n+\tf, err := lockedfile.Edit(path)\n+\tif err != nil {\n+\t\tt.Fatalf(\"first Edit: %v\", err)\n+\t}\n+\n+\twait := mustBlock(t, \"Edit\", func() {\n+\t\tother, err := lockedfile.Edit(path)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"second Edit: %v\", err)\n+\t\t}\n+\t\tother.Close()\n+\t})\n+\n+\tf.Close()\n+\twait(t)\n+}"}, {"sha": "17f3751c371694d60001bc13775129d557198316", "filename": "libgo/go/cmd/go/internal/lockedfile/mutex.go", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Fmutex.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Fmutex.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Fmutex.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -0,0 +1,60 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package lockedfile\n+\n+import (\n+\t\"fmt\"\n+\t\"os\"\n+)\n+\n+// A Mutex provides mutual exclusion within and across processes by locking a\n+// well-known file. Such a file generally guards some other part of the\n+// filesystem: for example, a Mutex file in a directory might guard access to\n+// the entire tree rooted in that directory.\n+//\n+// Mutex does not implement sync.Locker: unlike a sync.Mutex, a lockedfile.Mutex\n+// can fail to lock (e.g. if there is a permission error in the filesystem).\n+//\n+// Like a sync.Mutex, a Mutex may be included as a field of a larger struct but\n+// must not be copied after first use. The Path field must be set before first\n+// use and must not be change thereafter.\n+type Mutex struct {\n+\tPath string // The path to the well-known lock file. Must be non-empty.\n+}\n+\n+// MutexAt returns a new Mutex with Path set to the given non-empty path.\n+func MutexAt(path string) *Mutex {\n+\tif path == \"\" {\n+\t\tpanic(\"lockedfile.MutexAt: path must be non-empty\")\n+\t}\n+\treturn &Mutex{Path: path}\n+}\n+\n+func (mu *Mutex) String() string {\n+\treturn fmt.Sprintf(\"lockedfile.Mutex(%s)\", mu.Path)\n+}\n+\n+// Lock attempts to lock the Mutex.\n+//\n+// If successful, Lock returns a non-nil unlock function: it is provided as a\n+// return-value instead of a separate method to remind the caller to check the\n+// accompanying error. (See https://golang.org/issue/20803.)\n+func (mu *Mutex) Lock() (unlock func(), err error) {\n+\tif mu.Path == \"\" {\n+\t\tpanic(\"lockedfile.Mutex: missing Path during Lock\")\n+\t}\n+\n+\t// We could use either O_RDWR or O_WRONLY here. If we choose O_RDWR and the\n+\t// file at mu.Path is write-only, the call to OpenFile will fail with a\n+\t// permission error. That's actually what we want: if we add an RLock method\n+\t// in the future, it should call OpenFile with O_RDONLY and will require the\n+\t// files must be readable, so we should not let the caller make any\n+\t// assumptions about Mutex working with write-only files.\n+\tf, err := OpenFile(mu.Path, os.O_RDWR|os.O_CREATE, 0666)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn func() { f.Close() }, nil\n+}"}, {"sha": "bbaba444f507f64c5ca647f559894a08b10eae5d", "filename": "libgo/go/cmd/go/internal/modcmd/download.go", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fdownload.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fdownload.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fdownload.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -15,7 +15,7 @@ import (\n )\n \n var cmdDownload = &base.Command{\n-\tUsageLine: \"go mod download [-dir] [-json] [modules]\",\n+\tUsageLine: \"go mod download [-json] [modules]\",\n \tShort:     \"download modules to local cache\",\n \tLong: `\n Download downloads the named modules, which can be module patterns selecting\n@@ -128,6 +128,16 @@ func runDownload(cmd *base.Command, args []string) {\n \t\t\t\tbase.Fatalf(\"%v\", err)\n \t\t\t}\n \t\t\tos.Stdout.Write(append(b, '\\n'))\n+\t\t\tif m.Error != \"\" {\n+\t\t\t\tbase.SetExitStatus(1)\n+\t\t\t}\n+\t\t}\n+\t} else {\n+\t\tfor _, m := range mods {\n+\t\t\tif m.Error != \"\" {\n+\t\t\t\tbase.Errorf(\"%s@%s: %s\\n\", m.Path, m.Version, m.Error)\n+\t\t\t}\n \t\t}\n+\t\tbase.ExitIfErrors()\n \t}\n }"}, {"sha": "5066e4ddf75f97394c44549dda8113f72f7ca32e", "filename": "libgo/go/cmd/go/internal/modcmd/edit.go", "status": "modified", "additions": 35, "deletions": 10, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fedit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fedit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fedit.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -7,6 +7,7 @@\n package modcmd\n \n import (\n+\t\"bytes\"\n \t\"encoding/json\"\n \t\"fmt\"\n \t\"io/ioutil\"\n@@ -15,6 +16,7 @@ import (\n \t\"strings\"\n \n \t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/modfetch\"\n \t\"cmd/go/internal/modfile\"\n \t\"cmd/go/internal/modload\"\n \t\"cmd/go/internal/module\"\n@@ -62,6 +64,8 @@ The -require, -droprequire, -exclude, -dropexclude, -replace,\n and -dropreplace editing flags may be repeated, and the changes\n are applied in the order given.\n \n+The -go=version flag sets the expected Go language version.\n+\n The -print flag prints the final go.mod in its text format instead of\n writing it back to go.mod.\n \n@@ -74,7 +78,8 @@ writing it back to go.mod. The JSON output corresponds to these Go types:\n \t}\n \n \ttype GoMod struct {\n-\t\tModule Module\n+\t\tModule  Module\n+\t\tGo      string\n \t\tRequire []Require\n \t\tExclude []Module\n \t\tReplace []Replace\n@@ -102,8 +107,8 @@ by invoking 'go mod edit' with -require, -exclude, and so on.\n }\n \n var (\n-\teditFmt = cmdEdit.Flag.Bool(\"fmt\", false, \"\")\n-\t// editGo     = cmdEdit.Flag.String(\"go\", \"\", \"\")\n+\teditFmt    = cmdEdit.Flag.Bool(\"fmt\", false, \"\")\n+\teditGo     = cmdEdit.Flag.String(\"go\", \"\", \"\")\n \teditJSON   = cmdEdit.Flag.Bool(\"json\", false, \"\")\n \teditPrint  = cmdEdit.Flag.Bool(\"print\", false, \"\")\n \teditModule = cmdEdit.Flag.String(\"module\", \"\", \"\")\n@@ -131,6 +136,7 @@ func init() {\n func runEdit(cmd *base.Command, args []string) {\n \tanyFlags :=\n \t\t*editModule != \"\" ||\n+\t\t\t*editGo != \"\" ||\n \t\t\t*editJSON ||\n \t\t\t*editPrint ||\n \t\t\t*editFmt ||\n@@ -151,8 +157,7 @@ func runEdit(cmd *base.Command, args []string) {\n \tif len(args) == 1 {\n \t\tgomod = args[0]\n \t} else {\n-\t\tmodload.MustInit()\n-\t\tgomod = filepath.Join(modload.ModRoot, \"go.mod\")\n+\t\tgomod = filepath.Join(modload.ModRoot(), \"go.mod\")\n \t}\n \n \tif *editModule != \"\" {\n@@ -161,7 +166,11 @@ func runEdit(cmd *base.Command, args []string) {\n \t\t}\n \t}\n \n-\t// TODO(rsc): Implement -go= once we start advertising it.\n+\tif *editGo != \"\" {\n+\t\tif !modfile.GoVersionRE.MatchString(*editGo) {\n+\t\t\tbase.Fatalf(`go mod: invalid -go option; expecting something like \"-go 1.12\"`)\n+\t\t}\n+\t}\n \n \tdata, err := ioutil.ReadFile(gomod)\n \tif err != nil {\n@@ -174,7 +183,13 @@ func runEdit(cmd *base.Command, args []string) {\n \t}\n \n \tif *editModule != \"\" {\n-\t\tmodFile.AddModuleStmt(modload.CmdModModule)\n+\t\tmodFile.AddModuleStmt(*editModule)\n+\t}\n+\n+\tif *editGo != \"\" {\n+\t\tif err := modFile.AddGoStmt(*editGo); err != nil {\n+\t\t\tbase.Fatalf(\"go: internal error: %v\", err)\n+\t\t}\n \t}\n \n \tif len(edits) > 0 {\n@@ -190,17 +205,23 @@ func runEdit(cmd *base.Command, args []string) {\n \t\treturn\n \t}\n \n-\tdata, err = modFile.Format()\n+\tout, err := modFile.Format()\n \tif err != nil {\n \t\tbase.Fatalf(\"go: %v\", err)\n \t}\n \n \tif *editPrint {\n-\t\tos.Stdout.Write(data)\n+\t\tos.Stdout.Write(out)\n \t\treturn\n \t}\n \n-\tif err := ioutil.WriteFile(gomod, data, 0666); err != nil {\n+\tunlock := modfetch.SideLock()\n+\tdefer unlock()\n+\tlockedData, err := ioutil.ReadFile(gomod)\n+\tif err == nil && !bytes.Equal(lockedData, data) {\n+\t\tbase.Fatalf(\"go: go.mod changed during editing; not overwriting\")\n+\t}\n+\tif err := ioutil.WriteFile(gomod, out, 0666); err != nil {\n \t\tbase.Fatalf(\"go: %v\", err)\n \t}\n }\n@@ -344,6 +365,7 @@ func flagDropReplace(arg string) {\n // fileJSON is the -json output data structure.\n type fileJSON struct {\n \tModule  module.Version\n+\tGo      string `json:\",omitempty\"`\n \tRequire []requireJSON\n \tExclude []module.Version\n \tReplace []replaceJSON\n@@ -364,6 +386,9 @@ type replaceJSON struct {\n func editPrintJSON(modFile *modfile.File) {\n \tvar f fileJSON\n \tf.Module = modFile.Module.Mod\n+\tif modFile.Go != nil {\n+\t\tf.Go = modFile.Go.Version\n+\t}\n \tfor _, r := range modFile.Require {\n \t\tf.Require = append(f.Require, requireJSON{Path: r.Mod.Path, Version: r.Mod.Version, Indirect: r.Indirect})\n \t}"}, {"sha": "0f7421e5849f2f934c94ece4e58ff1793e1161f1", "filename": "libgo/go/cmd/go/internal/modcmd/init.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Finit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Finit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Finit.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -10,6 +10,7 @@ import (\n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/modload\"\n \t\"os\"\n+\t\"strings\"\n )\n \n var cmdInit = &base.Command{\n@@ -37,5 +38,8 @@ func runInit(cmd *base.Command, args []string) {\n \tif _, err := os.Stat(\"go.mod\"); err == nil {\n \t\tbase.Fatalf(\"go mod init: go.mod already exists\")\n \t}\n+\tif strings.Contains(modload.CmdModModule, \"@\") {\n+\t\tbase.Fatalf(\"go mod init: module path must not contain '@'\")\n+\t}\n \tmodload.InitMod() // does all the hard work\n }"}, {"sha": "839c92a0a02b4433aa44a2c847b0b5ed9df48957", "filename": "libgo/go/cmd/go/internal/modcmd/tidy.go", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Ftidy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Ftidy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Ftidy.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -77,7 +77,17 @@ func modTidyGoSum() {\n \tkeep := make(map[module.Version]bool)\n \tvar walk func(module.Version)\n \twalk = func(m module.Version) {\n-\t\tkeep[m] = true\n+\t\t// If we build using a replacement module, keep the sum for the replacement,\n+\t\t// since that's the code we'll actually use during a build.\n+\t\t//\n+\t\t// TODO(golang.org/issue/29182): Perhaps we should keep both sums, and the\n+\t\t// sums for both sets of transitive requirements.\n+\t\tr := modload.Replacement(m)\n+\t\tif r.Path == \"\" {\n+\t\t\tkeep[m] = true\n+\t\t} else {\n+\t\t\tkeep[r] = true\n+\t\t}\n \t\tlist, _ := reqs.Required(m)\n \t\tfor _, r := range list {\n \t\t\tif !keep[r] {"}, {"sha": "b70f25cec3952f6a515d82d08f45a8e3e58cb4a0", "filename": "libgo/go/cmd/go/internal/modcmd/vendor.go", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fvendor.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fvendor.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fvendor.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -43,9 +43,9 @@ func runVendor(cmd *base.Command, args []string) {\n \t}\n \tpkgs := modload.LoadVendor()\n \n-\tvdir := filepath.Join(modload.ModRoot, \"vendor\")\n+\tvdir := filepath.Join(modload.ModRoot(), \"vendor\")\n \tif err := os.RemoveAll(vdir); err != nil {\n-\t\tbase.Fatalf(\"go vendor: %v\", err)\n+\t\tbase.Fatalf(\"go mod vendor: %v\", err)\n \t}\n \n \tmodpkgs := make(map[module.Version][]string)\n@@ -85,7 +85,7 @@ func runVendor(cmd *base.Command, args []string) {\n \t\treturn\n \t}\n \tif err := ioutil.WriteFile(filepath.Join(vdir, \"modules.txt\"), buf.Bytes(), 0666); err != nil {\n-\t\tbase.Fatalf(\"go vendor: %v\", err)\n+\t\tbase.Fatalf(\"go mod vendor: %v\", err)\n \t}\n }\n \n@@ -172,29 +172,29 @@ func matchNonTest(info os.FileInfo) bool {\n func copyDir(dst, src string, match func(os.FileInfo) bool) {\n \tfiles, err := ioutil.ReadDir(src)\n \tif err != nil {\n-\t\tbase.Fatalf(\"go vendor: %v\", err)\n+\t\tbase.Fatalf(\"go mod vendor: %v\", err)\n \t}\n \tif err := os.MkdirAll(dst, 0777); err != nil {\n-\t\tbase.Fatalf(\"go vendor: %v\", err)\n+\t\tbase.Fatalf(\"go mod vendor: %v\", err)\n \t}\n \tfor _, file := range files {\n \t\tif file.IsDir() || !file.Mode().IsRegular() || !match(file) {\n \t\t\tcontinue\n \t\t}\n \t\tr, err := os.Open(filepath.Join(src, file.Name()))\n \t\tif err != nil {\n-\t\t\tbase.Fatalf(\"go vendor: %v\", err)\n+\t\t\tbase.Fatalf(\"go mod vendor: %v\", err)\n \t\t}\n \t\tw, err := os.Create(filepath.Join(dst, file.Name()))\n \t\tif err != nil {\n-\t\t\tbase.Fatalf(\"go vendor: %v\", err)\n+\t\t\tbase.Fatalf(\"go mod vendor: %v\", err)\n \t\t}\n \t\tif _, err := io.Copy(w, r); err != nil {\n-\t\t\tbase.Fatalf(\"go vendor: %v\", err)\n+\t\t\tbase.Fatalf(\"go mod vendor: %v\", err)\n \t\t}\n \t\tr.Close()\n \t\tif err := w.Close(); err != nil {\n-\t\t\tbase.Fatalf(\"go vendor: %v\", err)\n+\t\t\tbase.Fatalf(\"go mod vendor: %v\", err)\n \t\t}\n \t}\n }"}, {"sha": "4d55d73f21423646a8f0f57d0d84389348d4eaa6", "filename": "libgo/go/cmd/go/internal/modconv/convert_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fconvert_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fconvert_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fconvert_test.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -146,7 +146,7 @@ func TestConvertLegacyConfig(t *testing.T) {\n \t}\n \n \tfor _, tt := range tests {\n-\t\tt.Run(strings.Replace(tt.path, \"/\", \"_\", -1)+\"_\"+tt.vers, func(t *testing.T) {\n+\t\tt.Run(strings.ReplaceAll(tt.path, \"/\", \"_\")+\"_\"+tt.vers, func(t *testing.T) {\n \t\t\tf, err := modfile.Parse(\"golden\", []byte(tt.gomod), nil)\n \t\t\tif err != nil {\n \t\t\t\tt.Fatal(err)"}, {"sha": "1ccd43dc2ae845d859f2c2d9447c00ed8003ca1a", "filename": "libgo/go/cmd/go/internal/modfetch/cache.go", "status": "modified", "additions": 62, "deletions": 28, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcache.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcache.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcache.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -8,15 +8,18 @@ import (\n \t\"bytes\"\n \t\"encoding/json\"\n \t\"fmt\"\n+\t\"io\"\n \t\"io/ioutil\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"strings\"\n \n \t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/lockedfile\"\n \t\"cmd/go/internal/modfetch/codehost\"\n \t\"cmd/go/internal/module\"\n \t\"cmd/go/internal/par\"\n+\t\"cmd/go/internal/renameio\"\n \t\"cmd/go/internal/semver\"\n )\n \n@@ -53,6 +56,8 @@ func CachePath(m module.Version, suffix string) (string, error) {\n \treturn filepath.Join(dir, encVer+\".\"+suffix), nil\n }\n \n+// DownloadDir returns the directory to which m should be downloaded.\n+// Note that the directory may not yet exist.\n func DownloadDir(m module.Version) (string, error) {\n \tif PkgMod == \"\" {\n \t\treturn \"\", fmt.Errorf(\"internal error: modfetch.PkgMod not set\")\n@@ -74,6 +79,37 @@ func DownloadDir(m module.Version) (string, error) {\n \treturn filepath.Join(PkgMod, enc+\"@\"+encVer), nil\n }\n \n+// lockVersion locks a file within the module cache that guards the downloading\n+// and extraction of the zipfile for the given module version.\n+func lockVersion(mod module.Version) (unlock func(), err error) {\n+\tpath, err := CachePath(mod, \"lock\")\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif err := os.MkdirAll(filepath.Dir(path), 0777); err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn lockedfile.MutexAt(path).Lock()\n+}\n+\n+// SideLock locks a file within the module cache that that guards edits to files\n+// outside the cache, such as go.sum and go.mod files in the user's working\n+// directory. It returns a function that must be called to unlock the file.\n+func SideLock() (unlock func()) {\n+\tif PkgMod == \"\" {\n+\t\tbase.Fatalf(\"go: internal error: modfetch.PkgMod not set\")\n+\t}\n+\tpath := filepath.Join(PkgMod, \"cache\", \"lock\")\n+\tif err := os.MkdirAll(filepath.Dir(path), 0777); err != nil {\n+\t\tbase.Fatalf(\"go: failed to create cache directory %s: %v\", filepath.Dir(path), err)\n+\t}\n+\tunlock, err := lockedfile.MutexAt(path).Lock()\n+\tif err != nil {\n+\t\tbase.Fatalf(\"go: failed to lock file at %v\", path)\n+\t}\n+\treturn unlock\n+}\n+\n // A cachingRepo is a cache around an underlying Repo,\n // avoiding redundant calls to ModulePath, Versions, Stat, Latest, and GoMod (but not Zip).\n // It is also safe for simultaneous use by multiple goroutines\n@@ -129,16 +165,18 @@ func (r *cachingRepo) Stat(rev string) (*RevInfo, error) {\n \t\t}\n \t\tinfo, err = r.r.Stat(rev)\n \t\tif err == nil {\n-\t\t\tif err := writeDiskStat(file, info); err != nil {\n-\t\t\t\tfmt.Fprintf(os.Stderr, \"go: writing stat cache: %v\\n\", err)\n-\t\t\t}\n \t\t\t// If we resolved, say, 1234abcde to v0.0.0-20180604122334-1234abcdef78,\n \t\t\t// then save the information under the proper version, for future use.\n \t\t\tif info.Version != rev {\n+\t\t\t\tfile, _ = CachePath(module.Version{Path: r.path, Version: info.Version}, \"info\")\n \t\t\t\tr.cache.Do(\"stat:\"+info.Version, func() interface{} {\n \t\t\t\t\treturn cachedInfo{info, err}\n \t\t\t\t})\n \t\t\t}\n+\n+\t\t\tif err := writeDiskStat(file, info); err != nil {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"go: writing stat cache: %v\\n\", err)\n+\t\t\t}\n \t\t}\n \t\treturn cachedInfo{info, err}\n \t}).(cachedInfo)\n@@ -213,8 +251,8 @@ func (r *cachingRepo) GoMod(rev string) ([]byte, error) {\n \treturn append([]byte(nil), c.text...), nil\n }\n \n-func (r *cachingRepo) Zip(version, tmpdir string) (string, error) {\n-\treturn r.r.Zip(version, tmpdir)\n+func (r *cachingRepo) Zip(dst io.Writer, version string) error {\n+\treturn r.r.Zip(dst, version)\n }\n \n // Stat is like Lookup(path).Stat(rev) but avoids the\n@@ -383,7 +421,7 @@ func readDiskStatByHash(path, rev string) (file string, info *RevInfo, err error\n // and should ignore it.\n var oldVgoPrefix = []byte(\"//vgo 0.0.\")\n \n-// readDiskGoMod reads a cached stat result from disk,\n+// readDiskGoMod reads a cached go.mod file from disk,\n // returning the name of the cache file and the result.\n // If the read fails, the caller can use\n // writeDiskGoMod(file, data) to write a new cache entry.\n@@ -449,22 +487,8 @@ func writeDiskCache(file string, data []byte) error {\n \tif err := os.MkdirAll(filepath.Dir(file), 0777); err != nil {\n \t\treturn err\n \t}\n-\t// Write data to temp file next to target file.\n-\tf, err := ioutil.TempFile(filepath.Dir(file), filepath.Base(file)+\".tmp-\")\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\tdefer os.Remove(f.Name())\n-\tdefer f.Close()\n-\tif _, err := f.Write(data); err != nil {\n-\t\treturn err\n-\t}\n-\tif err := f.Close(); err != nil {\n-\t\treturn err\n-\t}\n-\t// Rename temp file onto cache file,\n-\t// so that the cache file is always a complete file.\n-\tif err := os.Rename(f.Name(), file); err != nil {\n+\n+\tif err := renameio.WriteFile(file, data); err != nil {\n \t\treturn err\n \t}\n \n@@ -481,8 +505,18 @@ func rewriteVersionList(dir string) {\n \t\tbase.Fatalf(\"go: internal error: misuse of rewriteVersionList\")\n \t}\n \n-\t// TODO(rsc): We should do some kind of directory locking here,\n-\t// to avoid lost updates.\n+\tlistFile := filepath.Join(dir, \"list\")\n+\n+\t// We use a separate lockfile here instead of locking listFile itself because\n+\t// we want to use Rename to write the file atomically. The list may be read by\n+\t// a GOPROXY HTTP server, and if we crash midway through a rewrite (or if the\n+\t// HTTP server ignores our locking and serves the file midway through a\n+\t// rewrite) it's better to serve a stale list than a truncated one.\n+\tunlock, err := lockedfile.MutexAt(listFile + \".lock\").Lock()\n+\tif err != nil {\n+\t\tbase.Fatalf(\"go: can't lock version list lockfile: %v\", err)\n+\t}\n+\tdefer unlock()\n \n \tinfos, err := ioutil.ReadDir(dir)\n \tif err != nil {\n@@ -511,12 +545,12 @@ func rewriteVersionList(dir string) {\n \t\tbuf.WriteString(v)\n \t\tbuf.WriteString(\"\\n\")\n \t}\n-\tlistFile := filepath.Join(dir, \"list\")\n \told, _ := ioutil.ReadFile(listFile)\n \tif bytes.Equal(buf.Bytes(), old) {\n \t\treturn\n \t}\n-\t// TODO: Use rename to install file,\n-\t// so that readers never see an incomplete file.\n-\tioutil.WriteFile(listFile, buf.Bytes(), 0666)\n+\n+\tif err := renameio.WriteFile(listFile, buf.Bytes()); err != nil {\n+\t\tbase.Fatalf(\"go: failed to write version list: %v\", err)\n+\t}\n }"}, {"sha": "6c17f7886f19e5aea14f17675eb6772dd28156ae", "filename": "libgo/go/cmd/go/internal/modfetch/codehost/codehost.go", "status": "modified", "additions": 37, "deletions": 13, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fcodehost.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fcodehost.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fcodehost.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -20,6 +20,7 @@ import (\n \t\"time\"\n \n \t\"cmd/go/internal/cfg\"\n+\t\"cmd/go/internal/lockedfile\"\n \t\"cmd/go/internal/str\"\n )\n \n@@ -131,9 +132,9 @@ var WorkRoot string\n \n // WorkDir returns the name of the cached work directory to use for the\n // given repository type and name.\n-func WorkDir(typ, name string) (string, error) {\n+func WorkDir(typ, name string) (dir, lockfile string, err error) {\n \tif WorkRoot == \"\" {\n-\t\treturn \"\", fmt.Errorf(\"codehost.WorkRoot not set\")\n+\t\treturn \"\", \"\", fmt.Errorf(\"codehost.WorkRoot not set\")\n \t}\n \n \t// We name the work directory for the SHA256 hash of the type and name.\n@@ -142,22 +143,41 @@ func WorkDir(typ, name string) (string, error) {\n \t// that one checkout is never nested inside another. That nesting has\n \t// led to security problems in the past.\n \tif strings.Contains(typ, \":\") {\n-\t\treturn \"\", fmt.Errorf(\"codehost.WorkDir: type cannot contain colon\")\n+\t\treturn \"\", \"\", fmt.Errorf(\"codehost.WorkDir: type cannot contain colon\")\n \t}\n \tkey := typ + \":\" + name\n-\tdir := filepath.Join(WorkRoot, fmt.Sprintf(\"%x\", sha256.Sum256([]byte(key))))\n+\tdir = filepath.Join(WorkRoot, fmt.Sprintf(\"%x\", sha256.Sum256([]byte(key))))\n+\n+\tif cfg.BuildX {\n+\t\tfmt.Fprintf(os.Stderr, \"mkdir -p %s # %s %s\\n\", filepath.Dir(dir), typ, name)\n+\t}\n+\tif err := os.MkdirAll(filepath.Dir(dir), 0777); err != nil {\n+\t\treturn \"\", \"\", err\n+\t}\n+\n+\tlockfile = dir + \".lock\"\n+\tif cfg.BuildX {\n+\t\tfmt.Fprintf(os.Stderr, \"# lock %s\", lockfile)\n+\t}\n+\n+\tunlock, err := lockedfile.MutexAt(lockfile).Lock()\n+\tif err != nil {\n+\t\treturn \"\", \"\", fmt.Errorf(\"codehost.WorkDir: can't find or create lock file: %v\", err)\n+\t}\n+\tdefer unlock()\n+\n \tdata, err := ioutil.ReadFile(dir + \".info\")\n \tinfo, err2 := os.Stat(dir)\n \tif err == nil && err2 == nil && info.IsDir() {\n \t\t// Info file and directory both already exist: reuse.\n \t\thave := strings.TrimSuffix(string(data), \"\\n\")\n \t\tif have != key {\n-\t\t\treturn \"\", fmt.Errorf(\"%s exists with wrong content (have %q want %q)\", dir+\".info\", have, key)\n+\t\t\treturn \"\", \"\", fmt.Errorf(\"%s exists with wrong content (have %q want %q)\", dir+\".info\", have, key)\n \t\t}\n \t\tif cfg.BuildX {\n \t\t\tfmt.Fprintf(os.Stderr, \"# %s for %s %s\\n\", dir, typ, name)\n \t\t}\n-\t\treturn dir, nil\n+\t\treturn dir, lockfile, nil\n \t}\n \n \t// Info file or directory missing. Start from scratch.\n@@ -166,26 +186,30 @@ func WorkDir(typ, name string) (string, error) {\n \t}\n \tos.RemoveAll(dir)\n \tif err := os.MkdirAll(dir, 0777); err != nil {\n-\t\treturn \"\", err\n+\t\treturn \"\", \"\", err\n \t}\n \tif err := ioutil.WriteFile(dir+\".info\", []byte(key), 0666); err != nil {\n \t\tos.RemoveAll(dir)\n-\t\treturn \"\", err\n+\t\treturn \"\", \"\", err\n \t}\n-\treturn dir, nil\n+\treturn dir, lockfile, nil\n }\n \n type RunError struct {\n-\tCmd    string\n-\tErr    error\n-\tStderr []byte\n+\tCmd      string\n+\tErr      error\n+\tStderr   []byte\n+\tHelpText string\n }\n \n func (e *RunError) Error() string {\n \ttext := e.Cmd + \": \" + e.Err.Error()\n \tstderr := bytes.TrimRight(e.Stderr, \"\\n\")\n \tif len(stderr) > 0 {\n-\t\ttext += \":\\n\\t\" + strings.Replace(string(stderr), \"\\n\", \"\\n\\t\", -1)\n+\t\ttext += \":\\n\\t\" + strings.ReplaceAll(string(stderr), \"\\n\", \"\\n\\t\")\n+\t}\n+\tif len(e.HelpText) > 0 {\n+\t\ttext += \"\\n\" + e.HelpText\n \t}\n \treturn text\n }"}, {"sha": "588e7496cc50362ddbce4304d84fc36a8311d970", "filename": "libgo/go/cmd/go/internal/modfetch/codehost/git.go", "status": "modified", "additions": 89, "deletions": 18, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fgit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fgit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fgit.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -17,6 +17,7 @@ import (\n \t\"sync\"\n \t\"time\"\n \n+\t\"cmd/go/internal/lockedfile\"\n \t\"cmd/go/internal/par\"\n )\n \n@@ -57,22 +58,29 @@ func newGitRepo(remote string, localOK bool) (Repo, error) {\n \tr := &gitRepo{remote: remote}\n \tif strings.Contains(remote, \"://\") {\n \t\t// This is a remote path.\n-\t\tdir, err := WorkDir(gitWorkDirType, r.remote)\n+\t\tvar err error\n+\t\tr.dir, r.mu.Path, err = WorkDir(gitWorkDirType, r.remote)\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n-\t\tr.dir = dir\n-\t\tif _, err := os.Stat(filepath.Join(dir, \"objects\")); err != nil {\n-\t\t\tif _, err := Run(dir, \"git\", \"init\", \"--bare\"); err != nil {\n-\t\t\t\tos.RemoveAll(dir)\n+\n+\t\tunlock, err := r.mu.Lock()\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tdefer unlock()\n+\n+\t\tif _, err := os.Stat(filepath.Join(r.dir, \"objects\")); err != nil {\n+\t\t\tif _, err := Run(r.dir, \"git\", \"init\", \"--bare\"); err != nil {\n+\t\t\t\tos.RemoveAll(r.dir)\n \t\t\t\treturn nil, err\n \t\t\t}\n \t\t\t// We could just say git fetch https://whatever later,\n \t\t\t// but this lets us say git fetch origin instead, which\n \t\t\t// is a little nicer. More importantly, using a named remote\n \t\t\t// avoids a problem with Git LFS. See golang.org/issue/25605.\n-\t\t\tif _, err := Run(dir, \"git\", \"remote\", \"add\", \"origin\", r.remote); err != nil {\n-\t\t\t\tos.RemoveAll(dir)\n+\t\t\tif _, err := Run(r.dir, \"git\", \"remote\", \"add\", \"origin\", r.remote); err != nil {\n+\t\t\t\tos.RemoveAll(r.dir)\n \t\t\t\treturn nil, err\n \t\t\t}\n \t\t\tr.remote = \"origin\"\n@@ -97,6 +105,7 @@ func newGitRepo(remote string, localOK bool) (Repo, error) {\n \t\t\treturn nil, fmt.Errorf(\"%s exists but is not a directory\", remote)\n \t\t}\n \t\tr.dir = remote\n+\t\tr.mu.Path = r.dir + \".lock\"\n \t}\n \treturn r, nil\n }\n@@ -106,7 +115,8 @@ type gitRepo struct {\n \tlocal  bool\n \tdir    string\n \n-\tmu         sync.Mutex // protects fetchLevel, some git repo state\n+\tmu lockedfile.Mutex // protects fetchLevel and git repo state\n+\n \tfetchLevel int\n \n \tstatCache par.Cache\n@@ -154,6 +164,11 @@ func (r *gitRepo) loadRefs() {\n \t// Most of the time we only care about tags but sometimes we care about heads too.\n \tout, err := Run(r.dir, \"git\", \"ls-remote\", \"-q\", r.remote)\n \tif err != nil {\n+\t\tif rerr, ok := err.(*RunError); ok {\n+\t\t\tif bytes.Contains(rerr.Stderr, []byte(\"fatal: could not read Username\")) {\n+\t\t\t\trerr.HelpText = \"If this is a private repository, see https://golang.org/doc/faq#git_https for additional information.\"\n+\t\t\t}\n+\t\t}\n \t\tr.refsErr = err\n \t\treturn\n \t}\n@@ -304,11 +319,11 @@ func (r *gitRepo) stat(rev string) (*RevInfo, error) {\n \t}\n \n \t// Protect r.fetchLevel and the \"fetch more and more\" sequence.\n-\t// TODO(rsc): Add LockDir and use it for protecting that\n-\t// sequence, so that multiple processes don't collide in their\n-\t// git commands.\n-\tr.mu.Lock()\n-\tdefer r.mu.Unlock()\n+\tunlock, err := r.mu.Lock()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer unlock()\n \n \t// Perhaps r.localTags did not have the ref when we loaded local tags,\n \t// but we've since done fetches that pulled down the hash we need\n@@ -495,8 +510,11 @@ func (r *gitRepo) ReadFileRevs(revs []string, file string, maxSize int64) (map[s\n \n \t// Protect r.fetchLevel and the \"fetch more and more\" sequence.\n \t// See stat method above.\n-\tr.mu.Lock()\n-\tdefer r.mu.Unlock()\n+\tunlock, err := r.mu.Lock()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer unlock()\n \n \tvar refs []string\n \tvar protoFlag []string\n@@ -658,8 +676,11 @@ func (r *gitRepo) RecentTag(rev, prefix string) (tag string, err error) {\n \t// There are plausible tags, but we don't know if rev is a descendent of any of them.\n \t// Fetch the history to find out.\n \n-\tr.mu.Lock()\n-\tdefer r.mu.Unlock()\n+\tunlock, err := r.mu.Lock()\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tdefer unlock()\n \n \tif r.fetchLevel < fetchAll {\n \t\t// Fetch all heads and tags and see if that gives us enough history.\n@@ -678,7 +699,7 @@ func (r *gitRepo) RecentTag(rev, prefix string) (tag string, err error) {\n \t// unreachable for a reason).\n \t//\n \t// Try one last time in case some other goroutine fetched rev while we were\n-\t// waiting on r.mu.\n+\t// waiting on the lock.\n \tdescribe()\n \treturn tag, err\n }\n@@ -694,6 +715,16 @@ func (r *gitRepo) ReadZip(rev, subdir string, maxSize int64) (zip io.ReadCloser,\n \t\treturn nil, \"\", err\n \t}\n \n+\tunlock, err := r.mu.Lock()\n+\tif err != nil {\n+\t\treturn nil, \"\", err\n+\t}\n+\tdefer unlock()\n+\n+\tif err := ensureGitAttributes(r.dir); err != nil {\n+\t\treturn nil, \"\", err\n+\t}\n+\n \t// Incredibly, git produces different archives depending on whether\n \t// it is running on a Windows system or not, in an attempt to normalize\n \t// text file line endings. Setting -c core.autocrlf=input means only\n@@ -709,3 +740,43 @@ func (r *gitRepo) ReadZip(rev, subdir string, maxSize int64) (zip io.ReadCloser,\n \n \treturn ioutil.NopCloser(bytes.NewReader(archive)), \"\", nil\n }\n+\n+// ensureGitAttributes makes sure export-subst and export-ignore features are\n+// disabled for this repo. This is intended to be run prior to running git\n+// archive so that zip files are generated that produce consistent ziphashes\n+// for a given revision, independent of variables such as git version and the\n+// size of the repo.\n+//\n+// See: https://github.com/golang/go/issues/27153\n+func ensureGitAttributes(repoDir string) (err error) {\n+\tconst attr = \"\\n* -export-subst -export-ignore\\n\"\n+\n+\td := repoDir + \"/info\"\n+\tp := d + \"/attributes\"\n+\n+\tif err := os.MkdirAll(d, 0755); err != nil {\n+\t\treturn err\n+\t}\n+\n+\tf, err := os.OpenFile(p, os.O_CREATE|os.O_APPEND|os.O_RDWR, 0666)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tdefer func() {\n+\t\tcloseErr := f.Close()\n+\t\tif closeErr != nil {\n+\t\t\terr = closeErr\n+\t\t}\n+\t}()\n+\n+\tb, err := ioutil.ReadAll(f)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif !bytes.HasSuffix(b, []byte(attr)) {\n+\t\t_, err := f.WriteString(attr)\n+\t\treturn err\n+\t}\n+\n+\treturn nil\n+}"}, {"sha": "59c2b15d19a06c4fb6b525f45ca3cf7db68be201", "filename": "libgo/go/cmd/go/internal/modfetch/codehost/vcs.go", "status": "modified", "additions": 86, "deletions": 19, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fvcs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fvcs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fvcs.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -18,6 +18,7 @@ import (\n \t\"sync\"\n \t\"time\"\n \n+\t\"cmd/go/internal/lockedfile\"\n \t\"cmd/go/internal/par\"\n \t\"cmd/go/internal/str\"\n )\n@@ -27,12 +28,19 @@ import (\n // to get the code, but we can't access it due to the error.\n // The caller should report this error instead of continuing to probe\n // other possible module paths.\n+//\n+// TODO(bcmills): See if we can invert this. (Return a distinguished error for\n+// \u201crepo not found\u201d and treat everything else as terminal.)\n type VCSError struct {\n \tErr error\n }\n \n func (e *VCSError) Error() string { return e.Err.Error() }\n \n+func vcsErrorf(format string, a ...interface{}) error {\n+\treturn &VCSError{Err: fmt.Errorf(format, a...)}\n+}\n+\n func NewRepo(vcs, remote string) (Repo, error) {\n \ttype key struct {\n \t\tvcs    string\n@@ -56,6 +64,8 @@ func NewRepo(vcs, remote string) (Repo, error) {\n var vcsRepoCache par.Cache\n \n type vcsRepo struct {\n+\tmu lockedfile.Mutex // protects all commands, so we don't have to decide which are safe on a per-VCS basis\n+\n \tremote string\n \tcmd    *vcsCmd\n \tdir    string\n@@ -81,18 +91,27 @@ func newVCSRepo(vcs, remote string) (Repo, error) {\n \tif !strings.Contains(remote, \"://\") {\n \t\treturn nil, fmt.Errorf(\"invalid vcs remote: %s %s\", vcs, remote)\n \t}\n+\n \tr := &vcsRepo{remote: remote, cmd: cmd}\n+\tvar err error\n+\tr.dir, r.mu.Path, err = WorkDir(vcsWorkDirType+vcs, r.remote)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n \tif cmd.init == nil {\n \t\treturn r, nil\n \t}\n-\tdir, err := WorkDir(vcsWorkDirType+vcs, r.remote)\n+\n+\tunlock, err := r.mu.Lock()\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\tr.dir = dir\n-\tif _, err := os.Stat(filepath.Join(dir, \".\"+vcs)); err != nil {\n-\t\tif _, err := Run(dir, cmd.init(r.remote)); err != nil {\n-\t\t\tos.RemoveAll(dir)\n+\tdefer unlock()\n+\n+\tif _, err := os.Stat(filepath.Join(r.dir, \".\"+vcs)); err != nil {\n+\t\tif _, err := Run(r.dir, cmd.init(r.remote)); err != nil {\n+\t\t\tos.RemoveAll(r.dir)\n \t\t\treturn nil, err\n \t\t}\n \t}\n@@ -270,6 +289,12 @@ func (r *vcsRepo) loadBranches() {\n }\n \n func (r *vcsRepo) Tags(prefix string) ([]string, error) {\n+\tunlock, err := r.mu.Lock()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer unlock()\n+\n \tr.tagsOnce.Do(r.loadTags)\n \n \ttags := []string{}\n@@ -283,6 +308,12 @@ func (r *vcsRepo) Tags(prefix string) ([]string, error) {\n }\n \n func (r *vcsRepo) Stat(rev string) (*RevInfo, error) {\n+\tunlock, err := r.mu.Lock()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer unlock()\n+\n \tif rev == \"latest\" {\n \t\trev = r.cmd.latest\n \t}\n@@ -315,7 +346,7 @@ func (r *vcsRepo) fetch() {\n func (r *vcsRepo) statLocal(rev string) (*RevInfo, error) {\n \tout, err := Run(r.dir, r.cmd.statLocal(rev, r.remote))\n \tif err != nil {\n-\t\treturn nil, fmt.Errorf(\"unknown revision %s\", rev)\n+\t\treturn nil, vcsErrorf(\"unknown revision %s\", rev)\n \t}\n \treturn r.cmd.parseStat(rev, string(out))\n }\n@@ -332,6 +363,14 @@ func (r *vcsRepo) ReadFile(rev, file string, maxSize int64) ([]byte, error) {\n \tif err != nil {\n \t\treturn nil, err\n \t}\n+\n+\t// r.Stat acquires r.mu, so lock after that.\n+\tunlock, err := r.mu.Lock()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer unlock()\n+\n \tout, err := Run(r.dir, r.cmd.readFile(rev, file, r.remote))\n \tif err != nil {\n \t\treturn nil, os.ErrNotExist\n@@ -340,14 +379,42 @@ func (r *vcsRepo) ReadFile(rev, file string, maxSize int64) ([]byte, error) {\n }\n \n func (r *vcsRepo) ReadFileRevs(revs []string, file string, maxSize int64) (map[string]*FileRev, error) {\n-\treturn nil, fmt.Errorf(\"ReadFileRevs not implemented\")\n+\t// We don't technically need to lock here since we're returning an error\n+\t// uncondititonally, but doing so anyway will help to avoid baking in\n+\t// lock-inversion bugs.\n+\tunlock, err := r.mu.Lock()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer unlock()\n+\n+\treturn nil, vcsErrorf(\"ReadFileRevs not implemented\")\n }\n \n func (r *vcsRepo) RecentTag(rev, prefix string) (tag string, err error) {\n-\treturn \"\", fmt.Errorf(\"RecentTags not implemented\")\n+\t// We don't technically need to lock here since we're returning an error\n+\t// uncondititonally, but doing so anyway will help to avoid baking in\n+\t// lock-inversion bugs.\n+\tunlock, err := r.mu.Lock()\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tdefer unlock()\n+\n+\treturn \"\", vcsErrorf(\"RecentTag not implemented\")\n }\n \n func (r *vcsRepo) ReadZip(rev, subdir string, maxSize int64) (zip io.ReadCloser, actualSubdir string, err error) {\n+\tif r.cmd.readZip == nil {\n+\t\treturn nil, \"\", vcsErrorf(\"ReadZip not implemented for %s\", r.cmd.vcs)\n+\t}\n+\n+\tunlock, err := r.mu.Lock()\n+\tif err != nil {\n+\t\treturn nil, \"\", err\n+\t}\n+\tdefer unlock()\n+\n \tif rev == \"latest\" {\n \t\trev = r.cmd.latest\n \t}\n@@ -392,7 +459,7 @@ func (d *deleteCloser) Close() error {\n func hgParseStat(rev, out string) (*RevInfo, error) {\n \tf := strings.Fields(string(out))\n \tif len(f) < 3 {\n-\t\treturn nil, fmt.Errorf(\"unexpected response from hg log: %q\", out)\n+\t\treturn nil, vcsErrorf(\"unexpected response from hg log: %q\", out)\n \t}\n \thash := f[0]\n \tversion := rev\n@@ -401,7 +468,7 @@ func hgParseStat(rev, out string) (*RevInfo, error) {\n \t}\n \tt, err := strconv.ParseInt(f[1], 10, 64)\n \tif err != nil {\n-\t\treturn nil, fmt.Errorf(\"invalid time from hg log: %q\", out)\n+\t\treturn nil, vcsErrorf(\"invalid time from hg log: %q\", out)\n \t}\n \n \tvar tags []string\n@@ -430,12 +497,12 @@ func svnParseStat(rev, out string) (*RevInfo, error) {\n \t\t} `xml:\"logentry\"`\n \t}\n \tif err := xml.Unmarshal([]byte(out), &log); err != nil {\n-\t\treturn nil, fmt.Errorf(\"unexpected response from svn log --xml: %v\\n%s\", err, out)\n+\t\treturn nil, vcsErrorf(\"unexpected response from svn log --xml: %v\\n%s\", err, out)\n \t}\n \n \tt, err := time.Parse(time.RFC3339, log.Logentry.Date)\n \tif err != nil {\n-\t\treturn nil, fmt.Errorf(\"unexpected response from svn log --xml: %v\\n%s\", err, out)\n+\t\treturn nil, vcsErrorf(\"unexpected response from svn log --xml: %v\\n%s\", err, out)\n \t}\n \n \tinfo := &RevInfo{\n@@ -471,23 +538,23 @@ func bzrParseStat(rev, out string) (*RevInfo, error) {\n \t\t\t}\n \t\t\ti, err := strconv.ParseInt(val, 10, 64)\n \t\t\tif err != nil {\n-\t\t\t\treturn nil, fmt.Errorf(\"unexpected revno from bzr log: %q\", line)\n+\t\t\t\treturn nil, vcsErrorf(\"unexpected revno from bzr log: %q\", line)\n \t\t\t}\n \t\t\trevno = i\n \t\tcase \"timestamp\":\n \t\t\tj := strings.Index(val, \" \")\n \t\t\tif j < 0 {\n-\t\t\t\treturn nil, fmt.Errorf(\"unexpected timestamp from bzr log: %q\", line)\n+\t\t\t\treturn nil, vcsErrorf(\"unexpected timestamp from bzr log: %q\", line)\n \t\t\t}\n \t\t\tt, err := time.Parse(\"2006-01-02 15:04:05 -0700\", val[j+1:])\n \t\t\tif err != nil {\n-\t\t\t\treturn nil, fmt.Errorf(\"unexpected timestamp from bzr log: %q\", line)\n+\t\t\t\treturn nil, vcsErrorf(\"unexpected timestamp from bzr log: %q\", line)\n \t\t\t}\n \t\t\ttm = t.UTC()\n \t\t}\n \t}\n \tif revno == 0 || tm.IsZero() {\n-\t\treturn nil, fmt.Errorf(\"unexpected response from bzr log: %q\", out)\n+\t\treturn nil, vcsErrorf(\"unexpected response from bzr log: %q\", out)\n \t}\n \n \tinfo := &RevInfo{\n@@ -504,11 +571,11 @@ func fossilParseStat(rev, out string) (*RevInfo, error) {\n \t\tif strings.HasPrefix(line, \"uuid:\") {\n \t\t\tf := strings.Fields(line)\n \t\t\tif len(f) != 5 || len(f[1]) != 40 || f[4] != \"UTC\" {\n-\t\t\t\treturn nil, fmt.Errorf(\"unexpected response from fossil info: %q\", line)\n+\t\t\t\treturn nil, vcsErrorf(\"unexpected response from fossil info: %q\", line)\n \t\t\t}\n \t\t\tt, err := time.Parse(\"2006-01-02 15:04:05\", f[2]+\" \"+f[3])\n \t\t\tif err != nil {\n-\t\t\t\treturn nil, fmt.Errorf(\"unexpected response from fossil info: %q\", line)\n+\t\t\t\treturn nil, vcsErrorf(\"unexpected response from fossil info: %q\", line)\n \t\t\t}\n \t\t\thash := f[1]\n \t\t\tversion := rev\n@@ -524,5 +591,5 @@ func fossilParseStat(rev, out string) (*RevInfo, error) {\n \t\t\treturn info, nil\n \t\t}\n \t}\n-\treturn nil, fmt.Errorf(\"unexpected response from fossil info: %q\", out)\n+\treturn nil, vcsErrorf(\"unexpected response from fossil info: %q\", out)\n }"}, {"sha": "5018b6d8af7c7f7f7d4690277ac572f4649d3965", "filename": "libgo/go/cmd/go/internal/modfetch/coderepo.go", "status": "modified", "additions": 31, "deletions": 41, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -407,61 +407,51 @@ func (r *codeRepo) modPrefix(rev string) string {\n \treturn r.modPath + \"@\" + rev\n }\n \n-func (r *codeRepo) Zip(version string, tmpdir string) (tmpfile string, err error) {\n+func (r *codeRepo) Zip(dst io.Writer, version string) error {\n \trev, dir, _, err := r.findDir(version)\n \tif err != nil {\n-\t\treturn \"\", err\n+\t\treturn err\n \t}\n \tdl, actualDir, err := r.code.ReadZip(rev, dir, codehost.MaxZipFile)\n \tif err != nil {\n-\t\treturn \"\", err\n+\t\treturn err\n \t}\n+\tdefer dl.Close()\n \tif actualDir != \"\" && !hasPathPrefix(dir, actualDir) {\n-\t\treturn \"\", fmt.Errorf(\"internal error: downloading %v %v: dir=%q but actualDir=%q\", r.path, rev, dir, actualDir)\n+\t\treturn fmt.Errorf(\"internal error: downloading %v %v: dir=%q but actualDir=%q\", r.path, rev, dir, actualDir)\n \t}\n \tsubdir := strings.Trim(strings.TrimPrefix(dir, actualDir), \"/\")\n \n \t// Spool to local file.\n-\tf, err := ioutil.TempFile(tmpdir, \"go-codehost-\")\n+\tf, err := ioutil.TempFile(\"\", \"go-codehost-\")\n \tif err != nil {\n \t\tdl.Close()\n-\t\treturn \"\", err\n+\t\treturn err\n \t}\n \tdefer os.Remove(f.Name())\n \tdefer f.Close()\n \tmaxSize := int64(codehost.MaxZipFile)\n \tlr := &io.LimitedReader{R: dl, N: maxSize + 1}\n \tif _, err := io.Copy(f, lr); err != nil {\n \t\tdl.Close()\n-\t\treturn \"\", err\n+\t\treturn err\n \t}\n \tdl.Close()\n \tif lr.N <= 0 {\n-\t\treturn \"\", fmt.Errorf(\"downloaded zip file too large\")\n+\t\treturn fmt.Errorf(\"downloaded zip file too large\")\n \t}\n \tsize := (maxSize + 1) - lr.N\n \tif _, err := f.Seek(0, 0); err != nil {\n-\t\treturn \"\", err\n+\t\treturn err\n \t}\n \n \t// Translate from zip file we have to zip file we want.\n \tzr, err := zip.NewReader(f, size)\n \tif err != nil {\n-\t\treturn \"\", err\n-\t}\n-\tf2, err := ioutil.TempFile(tmpdir, \"go-codezip-\")\n-\tif err != nil {\n-\t\treturn \"\", err\n+\t\treturn err\n \t}\n \n-\tzw := zip.NewWriter(f2)\n-\tnewName := f2.Name()\n-\tdefer func() {\n-\t\tf2.Close()\n-\t\tif err != nil {\n-\t\t\tos.Remove(newName)\n-\t\t}\n-\t}()\n+\tzw := zip.NewWriter(dst)\n \tif subdir != \"\" {\n \t\tsubdir += \"/\"\n \t}\n@@ -472,12 +462,12 @@ func (r *codeRepo) Zip(version string, tmpdir string) (tmpfile string, err error\n \t\tif topPrefix == \"\" {\n \t\t\ti := strings.Index(zf.Name, \"/\")\n \t\t\tif i < 0 {\n-\t\t\t\treturn \"\", fmt.Errorf(\"missing top-level directory prefix\")\n+\t\t\t\treturn fmt.Errorf(\"missing top-level directory prefix\")\n \t\t\t}\n \t\t\ttopPrefix = zf.Name[:i+1]\n \t\t}\n \t\tif !strings.HasPrefix(zf.Name, topPrefix) {\n-\t\t\treturn \"\", fmt.Errorf(\"zip file contains more than one top-level directory\")\n+\t\t\treturn fmt.Errorf(\"zip file contains more than one top-level directory\")\n \t\t}\n \t\tdir, file := path.Split(zf.Name)\n \t\tif file == \"go.mod\" {\n@@ -497,19 +487,25 @@ func (r *codeRepo) Zip(version string, tmpdir string) (tmpfile string, err error\n \t\t\tname = dir[:len(dir)-1]\n \t\t}\n \t}\n+\n \tfor _, zf := range zr.File {\n+\t\tif !zf.FileInfo().Mode().IsRegular() {\n+\t\t\t// Skip symlinks (golang.org/issue/27093).\n+\t\t\tcontinue\n+\t\t}\n+\n \t\tif topPrefix == \"\" {\n \t\t\ti := strings.Index(zf.Name, \"/\")\n \t\t\tif i < 0 {\n-\t\t\t\treturn \"\", fmt.Errorf(\"missing top-level directory prefix\")\n+\t\t\t\treturn fmt.Errorf(\"missing top-level directory prefix\")\n \t\t\t}\n \t\t\ttopPrefix = zf.Name[:i+1]\n \t\t}\n \t\tif strings.HasSuffix(zf.Name, \"/\") { // drop directory dummy entries\n \t\t\tcontinue\n \t\t}\n \t\tif !strings.HasPrefix(zf.Name, topPrefix) {\n-\t\t\treturn \"\", fmt.Errorf(\"zip file contains more than one top-level directory\")\n+\t\t\treturn fmt.Errorf(\"zip file contains more than one top-level directory\")\n \t\t}\n \t\tname := strings.TrimPrefix(zf.Name, topPrefix)\n \t\tif !strings.HasPrefix(name, subdir) {\n@@ -529,28 +525,28 @@ func (r *codeRepo) Zip(version string, tmpdir string) (tmpfile string, err error\n \t\t}\n \t\tbase := path.Base(name)\n \t\tif strings.ToLower(base) == \"go.mod\" && base != \"go.mod\" {\n-\t\t\treturn \"\", fmt.Errorf(\"zip file contains %s, want all lower-case go.mod\", zf.Name)\n+\t\t\treturn fmt.Errorf(\"zip file contains %s, want all lower-case go.mod\", zf.Name)\n \t\t}\n \t\tif name == \"LICENSE\" {\n \t\t\thaveLICENSE = true\n \t\t}\n-\t\tsize := int64(zf.UncompressedSize)\n+\t\tsize := int64(zf.UncompressedSize64)\n \t\tif size < 0 || maxSize < size {\n-\t\t\treturn \"\", fmt.Errorf(\"module source tree too big\")\n+\t\t\treturn fmt.Errorf(\"module source tree too big\")\n \t\t}\n \t\tmaxSize -= size\n \n \t\trc, err := zf.Open()\n \t\tif err != nil {\n-\t\t\treturn \"\", err\n+\t\t\treturn err\n \t\t}\n \t\tw, err := zw.Create(r.modPrefix(version) + \"/\" + name)\n \t\tlr := &io.LimitedReader{R: rc, N: size + 1}\n \t\tif _, err := io.Copy(w, lr); err != nil {\n-\t\t\treturn \"\", err\n+\t\t\treturn err\n \t\t}\n \t\tif lr.N <= 0 {\n-\t\t\treturn \"\", fmt.Errorf(\"individual file too large\")\n+\t\t\treturn fmt.Errorf(\"individual file too large\")\n \t\t}\n \t}\n \n@@ -559,21 +555,15 @@ func (r *codeRepo) Zip(version string, tmpdir string) (tmpfile string, err error\n \t\tif err == nil {\n \t\t\tw, err := zw.Create(r.modPrefix(version) + \"/LICENSE\")\n \t\t\tif err != nil {\n-\t\t\t\treturn \"\", err\n+\t\t\t\treturn err\n \t\t\t}\n \t\t\tif _, err := w.Write(data); err != nil {\n-\t\t\t\treturn \"\", err\n+\t\t\t\treturn err\n \t\t\t}\n \t\t}\n \t}\n-\tif err := zw.Close(); err != nil {\n-\t\treturn \"\", err\n-\t}\n-\tif err := f2.Close(); err != nil {\n-\t\treturn \"\", err\n-\t}\n \n-\treturn f2.Name(), nil\n+\treturn zw.Close()\n }\n \n // hasPathPrefix reports whether the path s begins with the"}, {"sha": "c93d8dbe44284f84eef58d0a7dc35f00179c8189", "filename": "libgo/go/cmd/go/internal/modfetch/coderepo_test.go", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo_test.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -284,10 +284,10 @@ var codeRepoTests = []struct {\n \t{\n \t\tpath:    \"gopkg.in/yaml.v2\",\n \t\trev:     \"v2\",\n-\t\tversion: \"v2.2.1\",\n-\t\tname:    \"5420a8b6744d3b0345ab293f6fcba19c978f1183\",\n-\t\tshort:   \"5420a8b6744d\",\n-\t\ttime:    time.Date(2018, 3, 28, 19, 50, 20, 0, time.UTC),\n+\t\tversion: \"v2.2.2\",\n+\t\tname:    \"51d6538a90f86fe93ac480b35f37b2be17fef232\",\n+\t\tshort:   \"51d6538a90f8\",\n+\t\ttime:    time.Date(2018, 11, 15, 11, 05, 04, 0, time.UTC),\n \t\tgomod:   \"module \\\"gopkg.in/yaml.v2\\\"\\n\\nrequire (\\n\\t\\\"gopkg.in/check.v1\\\" v0.0.0-20161208181325-20d25e280405\\n)\\n\",\n \t},\n \t{\n@@ -391,7 +391,13 @@ func TestCodeRepo(t *testing.T) {\n \t\t\t\t}\n \t\t\t}\n \t\t\tif tt.zip != nil || tt.ziperr != \"\" {\n-\t\t\t\tzipfile, err := repo.Zip(tt.version, tmpdir)\n+\t\t\t\tf, err := ioutil.TempFile(tmpdir, tt.version+\".zip.\")\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Fatalf(\"ioutil.TempFile: %v\", err)\n+\t\t\t\t}\n+\t\t\t\tzipfile := f.Name()\n+\t\t\t\terr = repo.Zip(f, tt.version)\n+\t\t\t\tf.Close()\n \t\t\t\tif err != nil {\n \t\t\t\t\tif tt.ziperr != \"\" {\n \t\t\t\t\t\tif err.Error() == tt.ziperr {\n@@ -423,7 +429,7 @@ func TestCodeRepo(t *testing.T) {\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\tt.Run(strings.Replace(tt.path, \"/\", \"_\", -1)+\"/\"+tt.rev, f)\n+\t\tt.Run(strings.ReplaceAll(tt.path, \"/\", \"_\")+\"/\"+tt.rev, f)\n \t\tif strings.HasPrefix(tt.path, vgotest1git) {\n \t\t\tfor _, alt := range altVgotests {\n \t\t\t\t// Note: Communicating with f through tt; should be cleaned up.\n@@ -442,7 +448,7 @@ func TestCodeRepo(t *testing.T) {\n \t\t\t\ttt.rev = remap(tt.rev, m)\n \t\t\t\ttt.gomoderr = remap(tt.gomoderr, m)\n \t\t\t\ttt.ziperr = remap(tt.ziperr, m)\n-\t\t\t\tt.Run(strings.Replace(tt.path, \"/\", \"_\", -1)+\"/\"+tt.rev, f)\n+\t\t\t\tt.Run(strings.ReplaceAll(tt.path, \"/\", \"_\")+\"/\"+tt.rev, f)\n \t\t\t\ttt = old\n \t\t\t}\n \t\t}\n@@ -473,9 +479,9 @@ func remap(name string, m map[string]string) string {\n \t\t}\n \t}\n \tfor k, v := range m {\n-\t\tname = strings.Replace(name, k, v, -1)\n+\t\tname = strings.ReplaceAll(name, k, v)\n \t\tif codehost.AllHex(k) {\n-\t\t\tname = strings.Replace(name, k[:12], v[:12], -1)\n+\t\t\tname = strings.ReplaceAll(name, k[:12], v[:12])\n \t\t}\n \t}\n \treturn name\n@@ -505,11 +511,11 @@ var codeRepoVersionsTests = []struct {\n \t},\n \t{\n \t\tpath:     \"gopkg.in/russross/blackfriday.v2\",\n-\t\tversions: []string{\"v2.0.0\"},\n+\t\tversions: []string{\"v2.0.0\", \"v2.0.1\"},\n \t},\n \t{\n \t\tpath:     \"gopkg.in/natefinch/lumberjack.v2\",\n-\t\tversions: nil,\n+\t\tversions: []string{\"v2.0.0\"},\n \t},\n }\n \n@@ -522,7 +528,7 @@ func TestCodeRepoVersions(t *testing.T) {\n \t}\n \tdefer os.RemoveAll(tmpdir)\n \tfor _, tt := range codeRepoVersionsTests {\n-\t\tt.Run(strings.Replace(tt.path, \"/\", \"_\", -1), func(t *testing.T) {\n+\t\tt.Run(strings.ReplaceAll(tt.path, \"/\", \"_\"), func(t *testing.T) {\n \t\t\trepo, err := Lookup(tt.path)\n \t\t\tif err != nil {\n \t\t\t\tt.Fatalf(\"Lookup(%q): %v\", tt.path, err)\n@@ -570,7 +576,7 @@ func TestLatest(t *testing.T) {\n \t}\n \tdefer os.RemoveAll(tmpdir)\n \tfor _, tt := range latestTests {\n-\t\tname := strings.Replace(tt.path, \"/\", \"_\", -1)\n+\t\tname := strings.ReplaceAll(tt.path, \"/\", \"_\")\n \t\tt.Run(name, func(t *testing.T) {\n \t\t\trepo, err := Lookup(tt.path)\n \t\t\tif err != nil {"}, {"sha": "81a6c843abccf5c3fb211b934fb00ad56506c39d", "filename": "libgo/go/cmd/go/internal/modfetch/fetch.go", "status": "modified", "additions": 247, "deletions": 71, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Ffetch.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Ffetch.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Ffetch.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -21,6 +21,7 @@ import (\n \t\"cmd/go/internal/dirhash\"\n \t\"cmd/go/internal/module\"\n \t\"cmd/go/internal/par\"\n+\t\"cmd/go/internal/renameio\"\n )\n \n var downloadCache par.Cache\n@@ -34,9 +35,7 @@ func Download(mod module.Version) (dir string, err error) {\n \t\treturn \"\", fmt.Errorf(\"missing modfetch.PkgMod\")\n \t}\n \n-\t// The par.Cache here avoids duplicate work but also\n-\t// avoids conflicts from simultaneous calls by multiple goroutines\n-\t// for the same version.\n+\t// The par.Cache here avoids duplicate work.\n \ttype cached struct {\n \t\tdir string\n \t\terr error\n@@ -46,31 +45,97 @@ func Download(mod module.Version) (dir string, err error) {\n \t\tif err != nil {\n \t\t\treturn cached{\"\", err}\n \t\t}\n-\t\tif files, _ := ioutil.ReadDir(dir); len(files) == 0 {\n-\t\t\tzipfile, err := DownloadZip(mod)\n-\t\t\tif err != nil {\n-\t\t\t\treturn cached{\"\", err}\n-\t\t\t}\n-\t\t\tmodpath := mod.Path + \"@\" + mod.Version\n-\t\t\tif err := Unzip(dir, zipfile, modpath, 0); err != nil {\n-\t\t\t\tfmt.Fprintf(os.Stderr, \"-> %s\\n\", err)\n-\t\t\t\treturn cached{\"\", err}\n-\t\t\t}\n+\t\tif err := download(mod, dir); err != nil {\n+\t\t\treturn cached{\"\", err}\n \t\t}\n \t\tcheckSum(mod)\n \t\treturn cached{dir, nil}\n \t}).(cached)\n \treturn c.dir, c.err\n }\n \n+func download(mod module.Version, dir string) (err error) {\n+\t// If the directory exists, the module has already been extracted.\n+\tfi, err := os.Stat(dir)\n+\tif err == nil && fi.IsDir() {\n+\t\treturn nil\n+\t}\n+\n+\t// To avoid cluttering the cache with extraneous files,\n+\t// DownloadZip uses the same lockfile as Download.\n+\t// Invoke DownloadZip before locking the file.\n+\tzipfile, err := DownloadZip(mod)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif cfg.CmdName != \"mod download\" {\n+\t\tfmt.Fprintf(os.Stderr, \"go: extracting %s %s\\n\", mod.Path, mod.Version)\n+\t}\n+\n+\tunlock, err := lockVersion(mod)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tdefer unlock()\n+\n+\t// Check whether the directory was populated while we were waiting on the lock.\n+\tfi, err = os.Stat(dir)\n+\tif err == nil && fi.IsDir() {\n+\t\treturn nil\n+\t}\n+\n+\t// Clean up any remaining temporary directories from previous runs.\n+\t// This is only safe to do because the lock file ensures that their writers\n+\t// are no longer active.\n+\tparentDir := filepath.Dir(dir)\n+\ttmpPrefix := filepath.Base(dir) + \".tmp-\"\n+\tif old, err := filepath.Glob(filepath.Join(parentDir, tmpPrefix+\"*\")); err == nil {\n+\t\tfor _, path := range old {\n+\t\t\tRemoveAll(path) // best effort\n+\t\t}\n+\t}\n+\n+\t// Extract the zip file to a temporary directory, then rename it to the\n+\t// final path. That way, we can use the existence of the source directory to\n+\t// signal that it has been extracted successfully, and if someone deletes\n+\t// the entire directory (e.g. as an attempt to prune out file corruption)\n+\t// the module cache will still be left in a recoverable state.\n+\tif err := os.MkdirAll(parentDir, 0777); err != nil {\n+\t\treturn err\n+\t}\n+\ttmpDir, err := ioutil.TempDir(parentDir, tmpPrefix)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tdefer func() {\n+\t\tif err != nil {\n+\t\t\tRemoveAll(tmpDir)\n+\t\t}\n+\t}()\n+\n+\tmodpath := mod.Path + \"@\" + mod.Version\n+\tif err := Unzip(tmpDir, zipfile, modpath, 0); err != nil {\n+\t\tfmt.Fprintf(os.Stderr, \"-> %s\\n\", err)\n+\t\treturn err\n+\t}\n+\n+\tif err := os.Rename(tmpDir, dir); err != nil {\n+\t\treturn err\n+\t}\n+\n+\t// Make dir read-only only *after* renaming it.\n+\t// os.Rename was observed to fail for read-only directories on macOS.\n+\tmakeDirsReadOnly(dir)\n+\treturn nil\n+}\n+\n var downloadZipCache par.Cache\n \n // DownloadZip downloads the specific module version to the\n // local zip cache and returns the name of the zip file.\n func DownloadZip(mod module.Version) (zipfile string, err error) {\n-\t// The par.Cache here avoids duplicate work but also\n-\t// avoids conflicts from simultaneous calls by multiple goroutines\n-\t// for the same version.\n+\t// The par.Cache here avoids duplicate work.\n \ttype cached struct {\n \t\tzipfile string\n \t\terr     error\n@@ -80,83 +145,134 @@ func DownloadZip(mod module.Version) (zipfile string, err error) {\n \t\tif err != nil {\n \t\t\treturn cached{\"\", err}\n \t\t}\n+\n+\t\t// Skip locking if the zipfile already exists.\n \t\tif _, err := os.Stat(zipfile); err == nil {\n-\t\t\t// Use it.\n-\t\t\t// This should only happen if the mod/cache directory is preinitialized\n-\t\t\t// or if pkg/mod/path was removed but not pkg/mod/cache/download.\n-\t\t\tif cfg.CmdName != \"mod download\" {\n-\t\t\t\tfmt.Fprintf(os.Stderr, \"go: extracting %s %s\\n\", mod.Path, mod.Version)\n-\t\t\t}\n-\t\t} else {\n-\t\t\tif err := os.MkdirAll(filepath.Dir(zipfile), 0777); err != nil {\n-\t\t\t\treturn cached{\"\", err}\n-\t\t\t}\n-\t\t\tif cfg.CmdName != \"mod download\" {\n-\t\t\t\tfmt.Fprintf(os.Stderr, \"go: downloading %s %s\\n\", mod.Path, mod.Version)\n-\t\t\t}\n-\t\t\tif err := downloadZip(mod, zipfile); err != nil {\n-\t\t\t\treturn cached{\"\", err}\n-\t\t\t}\n+\t\t\treturn cached{zipfile, nil}\n+\t\t}\n+\n+\t\t// The zip file does not exist. Acquire the lock and create it.\n+\t\tif cfg.CmdName != \"mod download\" {\n+\t\t\tfmt.Fprintf(os.Stderr, \"go: downloading %s %s\\n\", mod.Path, mod.Version)\n+\t\t}\n+\t\tunlock, err := lockVersion(mod)\n+\t\tif err != nil {\n+\t\t\treturn cached{\"\", err}\n+\t\t}\n+\t\tdefer unlock()\n+\n+\t\t// Double-check that the zipfile was not created while we were waiting for\n+\t\t// the lock.\n+\t\tif _, err := os.Stat(zipfile); err == nil {\n+\t\t\treturn cached{zipfile, nil}\n+\t\t}\n+\t\tif err := os.MkdirAll(filepath.Dir(zipfile), 0777); err != nil {\n+\t\t\treturn cached{\"\", err}\n+\t\t}\n+\t\tif err := downloadZip(mod, zipfile); err != nil {\n+\t\t\treturn cached{\"\", err}\n \t\t}\n \t\treturn cached{zipfile, nil}\n \t}).(cached)\n \treturn c.zipfile, c.err\n }\n \n-func downloadZip(mod module.Version, target string) error {\n-\trepo, err := Lookup(mod.Path)\n+func downloadZip(mod module.Version, zipfile string) (err error) {\n+\t// Clean up any remaining tempfiles from previous runs.\n+\t// This is only safe to do because the lock file ensures that their\n+\t// writers are no longer active.\n+\tfor _, base := range []string{zipfile, zipfile + \"hash\"} {\n+\t\tif old, err := filepath.Glob(renameio.Pattern(base)); err == nil {\n+\t\t\tfor _, path := range old {\n+\t\t\t\tos.Remove(path) // best effort\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// From here to the os.Rename call below is functionally almost equivalent to\n+\t// renameio.WriteToFile, with one key difference: we want to validate the\n+\t// contents of the file (by hashing it) before we commit it. Because the file\n+\t// is zip-compressed, we need an actual file \u2014 or at least an io.ReaderAt \u2014 to\n+\t// validate it: we can't just tee the stream as we write it.\n+\tf, err := ioutil.TempFile(filepath.Dir(zipfile), filepath.Base(renameio.Pattern(zipfile)))\n \tif err != nil {\n \t\treturn err\n \t}\n-\ttmpfile, err := repo.Zip(mod.Version, os.TempDir())\n+\tdefer func() {\n+\t\tif err != nil {\n+\t\t\tf.Close()\n+\t\t\tos.Remove(f.Name())\n+\t\t}\n+\t}()\n+\n+\trepo, err := Lookup(mod.Path)\n \tif err != nil {\n \t\treturn err\n \t}\n-\tdefer os.Remove(tmpfile)\n+\tif err := repo.Zip(f, mod.Version); err != nil {\n+\t\treturn err\n+\t}\n \n-\t// Double-check zip file looks OK.\n-\tz, err := zip.OpenReader(tmpfile)\n+\t// Double-check that the paths within the zip file are well-formed.\n+\t//\n+\t// TODO(bcmills): There is a similar check within the Unzip function. Can we eliminate one?\n+\tfi, err := f.Stat()\n \tif err != nil {\n \t\treturn err\n \t}\n-\tprefix := mod.Path + \"@\" + mod.Version\n+\tz, err := zip.NewReader(f, fi.Size())\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tprefix := mod.Path + \"@\" + mod.Version + \"/\"\n \tfor _, f := range z.File {\n \t\tif !strings.HasPrefix(f.Name, prefix) {\n-\t\t\tz.Close()\n \t\t\treturn fmt.Errorf(\"zip for %s has unexpected file %s\", prefix[:len(prefix)-1], f.Name)\n \t\t}\n \t}\n-\tz.Close()\n \n-\thash, err := dirhash.HashZip(tmpfile, dirhash.DefaultHash)\n-\tif err != nil {\n+\t// Sync the file before renaming it: otherwise, after a crash the reader may\n+\t// observe a 0-length file instead of the actual contents.\n+\t// See https://golang.org/issue/22397#issuecomment-380831736.\n+\tif err := f.Sync(); err != nil {\n \t\treturn err\n \t}\n-\tcheckOneSum(mod, hash) // check before installing the zip file\n-\tr, err := os.Open(tmpfile)\n-\tif err != nil {\n+\tif err := f.Close(); err != nil {\n \t\treturn err\n \t}\n-\tdefer r.Close()\n-\tw, err := os.Create(target)\n+\n+\t// Hash the zip file and check the sum before renaming to the final location.\n+\thash, err := dirhash.HashZip(f.Name(), dirhash.DefaultHash)\n \tif err != nil {\n \t\treturn err\n \t}\n-\tif _, err := io.Copy(w, r); err != nil {\n-\t\tw.Close()\n-\t\treturn fmt.Errorf(\"copying: %v\", err)\n+\tcheckOneSum(mod, hash)\n+\n+\tif err := renameio.WriteFile(zipfile+\"hash\", []byte(hash)); err != nil {\n+\t\treturn err\n \t}\n-\tif err := w.Close(); err != nil {\n+\tif err := os.Rename(f.Name(), zipfile); err != nil {\n \t\treturn err\n \t}\n-\treturn ioutil.WriteFile(target+\"hash\", []byte(hash), 0666)\n+\n+\t// TODO(bcmills): Should we make the .zip and .ziphash files read-only to discourage tampering?\n+\n+\treturn nil\n }\n \n var GoSumFile string // path to go.sum; set by package modload\n \n+type modSum struct {\n+\tmod module.Version\n+\tsum string\n+}\n+\n var goSum struct {\n \tmu        sync.Mutex\n \tm         map[module.Version][]string // content of go.sum file (+ go.modverify if present)\n+\tchecked   map[modSum]bool             // sums actually checked during execution\n+\tdirty     bool                        // whether we added any new sums to m\n+\toverwrite bool                        // if true, overwrite go.sum without incorporating its contents\n \tenabled   bool                        // whether to use go.sum at all\n \tmodverify string                      // path to go.modverify, to be deleted\n }\n@@ -173,18 +289,25 @@ func initGoSum() bool {\n \t}\n \n \tgoSum.m = make(map[module.Version][]string)\n+\tgoSum.checked = make(map[modSum]bool)\n \tdata, err := ioutil.ReadFile(GoSumFile)\n \tif err != nil && !os.IsNotExist(err) {\n \t\tbase.Fatalf(\"go: %v\", err)\n \t}\n \tgoSum.enabled = true\n-\treadGoSum(GoSumFile, data)\n+\treadGoSum(goSum.m, GoSumFile, data)\n \n \t// Add old go.modverify file.\n \t// We'll delete go.modverify in WriteGoSum.\n \talt := strings.TrimSuffix(GoSumFile, \".sum\") + \".modverify\"\n \tif data, err := ioutil.ReadFile(alt); err == nil {\n-\t\treadGoSum(alt, data)\n+\t\tmigrate := make(map[module.Version][]string)\n+\t\treadGoSum(migrate, alt, data)\n+\t\tfor mod, sums := range migrate {\n+\t\t\tfor _, sum := range sums {\n+\t\t\t\tcheckOneSumLocked(mod, sum)\n+\t\t\t}\n+\t\t}\n \t\tgoSum.modverify = alt\n \t}\n \treturn true\n@@ -197,7 +320,7 @@ const emptyGoModHash = \"h1:G7mAYYxgmS0lVkHyy2hEOLQCFB0DlQFTMLWggykrydY=\"\n \n // readGoSum parses data, which is the content of file,\n // and adds it to goSum.m. The goSum lock must be held.\n-func readGoSum(file string, data []byte) {\n+func readGoSum(dst map[module.Version][]string, file string, data []byte) {\n \tlineno := 0\n \tfor len(data) > 0 {\n \t\tvar line []byte\n@@ -221,7 +344,7 @@ func readGoSum(file string, data []byte) {\n \t\t\tcontinue\n \t\t}\n \t\tmod := module.Version{Path: f[0], Version: f[1]}\n-\t\tgoSum.m[mod] = append(goSum.m[mod], f[2])\n+\t\tdst[mod] = append(dst[mod], f[2])\n \t}\n }\n \n@@ -235,19 +358,19 @@ func checkSum(mod module.Version) {\n \t// Do the file I/O before acquiring the go.sum lock.\n \tziphash, err := CachePath(mod, \"ziphash\")\n \tif err != nil {\n-\t\tbase.Fatalf(\"go: verifying %s@%s: %v\", mod.Path, mod.Version, err)\n+\t\tbase.Fatalf(\"verifying %s@%s: %v\", mod.Path, mod.Version, err)\n \t}\n \tdata, err := ioutil.ReadFile(ziphash)\n \tif err != nil {\n \t\tif os.IsNotExist(err) {\n \t\t\t// This can happen if someone does rm -rf GOPATH/src/cache/download. So it goes.\n \t\t\treturn\n \t\t}\n-\t\tbase.Fatalf(\"go: verifying %s@%s: %v\", mod.Path, mod.Version, err)\n+\t\tbase.Fatalf(\"verifying %s@%s: %v\", mod.Path, mod.Version, err)\n \t}\n \th := strings.TrimSpace(string(data))\n \tif !strings.HasPrefix(h, \"h1:\") {\n-\t\tbase.Fatalf(\"go: verifying %s@%s: unexpected ziphash: %q\", mod.Path, mod.Version, h)\n+\t\tbase.Fatalf(\"verifying %s@%s: unexpected ziphash: %q\", mod.Path, mod.Version, h)\n \t}\n \n \tcheckOneSum(mod, h)\n@@ -265,7 +388,7 @@ func goModSum(data []byte) (string, error) {\n func checkGoMod(path, version string, data []byte) {\n \th, err := goModSum(data)\n \tif err != nil {\n-\t\tbase.Fatalf(\"go: verifying %s %s go.mod: %v\", path, version, err)\n+\t\tbase.Fatalf(\"verifying %s %s go.mod: %v\", path, version, err)\n \t}\n \n \tcheckOneSum(module.Version{Path: path, Version: version + \"/go.mod\"}, h)\n@@ -275,22 +398,27 @@ func checkGoMod(path, version string, data []byte) {\n func checkOneSum(mod module.Version, h string) {\n \tgoSum.mu.Lock()\n \tdefer goSum.mu.Unlock()\n-\tif !initGoSum() {\n-\t\treturn\n+\tif initGoSum() {\n+\t\tcheckOneSumLocked(mod, h)\n \t}\n+}\n+\n+func checkOneSumLocked(mod module.Version, h string) {\n+\tgoSum.checked[modSum{mod, h}] = true\n \n \tfor _, vh := range goSum.m[mod] {\n \t\tif h == vh {\n \t\t\treturn\n \t\t}\n \t\tif strings.HasPrefix(vh, \"h1:\") {\n-\t\t\tbase.Fatalf(\"go: verifying %s@%s: checksum mismatch\\n\\tdownloaded: %v\\n\\tgo.sum:     %v\", mod.Path, mod.Version, h, vh)\n+\t\t\tbase.Fatalf(\"verifying %s@%s: checksum mismatch\\n\\tdownloaded: %v\\n\\tgo.sum:     %v\", mod.Path, mod.Version, h, vh)\n \t\t}\n \t}\n \tif len(goSum.m[mod]) > 0 {\n \t\tfmt.Fprintf(os.Stderr, \"warning: verifying %s@%s: unknown hashes in go.sum: %v; adding %v\", mod.Path, mod.Version, strings.Join(goSum.m[mod], \", \"), h)\n \t}\n \tgoSum.m[mod] = append(goSum.m[mod], h)\n+\tgoSum.dirty = true\n }\n \n // Sum returns the checksum for the downloaded copy of the given module,\n@@ -316,10 +444,55 @@ func Sum(mod module.Version) string {\n func WriteGoSum() {\n \tgoSum.mu.Lock()\n \tdefer goSum.mu.Unlock()\n-\tif !initGoSum() {\n+\n+\tif !goSum.enabled {\n+\t\t// If we haven't read the go.sum file yet, don't bother writing it: at best,\n+\t\t// we could rename the go.modverify file if it isn't empty, but we haven't\n+\t\t// needed to touch it so far \u2014 how important could it be?\n+\t\treturn\n+\t}\n+\tif !goSum.dirty {\n+\t\t// Don't bother opening the go.sum file if we don't have anything to add.\n \t\treturn\n \t}\n \n+\t// We want to avoid races between creating the lockfile and deleting it, but\n+\t// we also don't want to leave a permanent lockfile in the user's repository.\n+\t//\n+\t// On top of that, if we crash while writing go.sum, we don't want to lose the\n+\t// sums that were already present in the file, so it's important that we write\n+\t// the file by renaming rather than truncating \u2014 which means that we can't\n+\t// lock the go.sum file itself.\n+\t//\n+\t// Instead, we'll lock a distinguished file in the cache directory: that will\n+\t// only race if the user runs `go clean -modcache` concurrently with a command\n+\t// that updates go.sum, and that's already racy to begin with.\n+\t//\n+\t// We'll end up slightly over-synchronizing go.sum writes if the user runs a\n+\t// bunch of go commands that update sums in separate modules simultaneously,\n+\t// but that's unlikely to matter in practice.\n+\n+\tunlock := SideLock()\n+\tdefer unlock()\n+\n+\tif !goSum.overwrite {\n+\t\t// Re-read the go.sum file to incorporate any sums added by other processes\n+\t\t// in the meantime.\n+\t\tdata, err := ioutil.ReadFile(GoSumFile)\n+\t\tif err != nil && !os.IsNotExist(err) {\n+\t\t\tbase.Fatalf(\"go: re-reading go.sum: %v\", err)\n+\t\t}\n+\n+\t\t// Add only the sums that we actually checked: the user may have edited or\n+\t\t// truncated the file to remove erroneous hashes, and we shouldn't restore\n+\t\t// them without good reason.\n+\t\tgoSum.m = make(map[module.Version][]string, len(goSum.m))\n+\t\treadGoSum(goSum.m, GoSumFile, data)\n+\t\tfor ms := range goSum.checked {\n+\t\t\tcheckOneSumLocked(ms.mod, ms.sum)\n+\t\t}\n+\t}\n+\n \tvar mods []module.Version\n \tfor m := range goSum.m {\n \t\tmods = append(mods, m)\n@@ -334,15 +507,16 @@ func WriteGoSum() {\n \t\t}\n \t}\n \n-\tdata, _ := ioutil.ReadFile(GoSumFile)\n-\tif !bytes.Equal(data, buf.Bytes()) {\n-\t\tif err := ioutil.WriteFile(GoSumFile, buf.Bytes(), 0666); err != nil {\n-\t\t\tbase.Fatalf(\"go: writing go.sum: %v\", err)\n-\t\t}\n+\tif err := renameio.WriteFile(GoSumFile, buf.Bytes()); err != nil {\n+\t\tbase.Fatalf(\"go: writing go.sum: %v\", err)\n \t}\n \n+\tgoSum.checked = make(map[modSum]bool)\n+\tgoSum.dirty = false\n+\tgoSum.overwrite = false\n+\n \tif goSum.modverify != \"\" {\n-\t\tos.Remove(goSum.modverify)\n+\t\tos.Remove(goSum.modverify) // best effort\n \t}\n }\n \n@@ -360,6 +534,8 @@ func TrimGoSum(keep map[module.Version]bool) {\n \t\tnoGoMod := module.Version{Path: m.Path, Version: strings.TrimSuffix(m.Version, \"/go.mod\")}\n \t\tif !keep[m] && !keep[noGoMod] {\n \t\t\tdelete(goSum.m, m)\n+\t\t\tgoSum.dirty = true\n+\t\t\tgoSum.overwrite = true\n \t\t}\n \t}\n }"}, {"sha": "60ed2a37966067dc9f9647facbe9c6aed9749a00", "filename": "libgo/go/cmd/go/internal/modfetch/proxy.go", "status": "modified", "additions": 9, "deletions": 23, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fproxy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fproxy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fproxy.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -8,7 +8,6 @@ import (\n \t\"encoding/json\"\n \t\"fmt\"\n \t\"io\"\n-\t\"io/ioutil\"\n \t\"net/url\"\n \t\"os\"\n \t\"strings\"\n@@ -209,44 +208,31 @@ func (p *proxyRepo) GoMod(version string) ([]byte, error) {\n \treturn data, nil\n }\n \n-func (p *proxyRepo) Zip(version string, tmpdir string) (tmpfile string, err error) {\n+func (p *proxyRepo) Zip(dst io.Writer, version string) error {\n \tvar body io.ReadCloser\n \tencVer, err := module.EncodeVersion(version)\n \tif err != nil {\n-\t\treturn \"\", err\n+\t\treturn err\n \t}\n \terr = webGetBody(p.url+\"/@v/\"+pathEscape(encVer)+\".zip\", &body)\n \tif err != nil {\n-\t\treturn \"\", err\n+\t\treturn err\n \t}\n \tdefer body.Close()\n \n-\t// Spool to local file.\n-\tf, err := ioutil.TempFile(tmpdir, \"go-proxy-download-\")\n-\tif err != nil {\n-\t\treturn \"\", err\n-\t}\n-\tdefer f.Close()\n-\tmaxSize := int64(codehost.MaxZipFile)\n-\tlr := &io.LimitedReader{R: body, N: maxSize + 1}\n-\tif _, err := io.Copy(f, lr); err != nil {\n-\t\tos.Remove(f.Name())\n-\t\treturn \"\", err\n+\tlr := &io.LimitedReader{R: body, N: codehost.MaxZipFile + 1}\n+\tif _, err := io.Copy(dst, lr); err != nil {\n+\t\treturn err\n \t}\n \tif lr.N <= 0 {\n-\t\tos.Remove(f.Name())\n-\t\treturn \"\", fmt.Errorf(\"downloaded zip file too large\")\n-\t}\n-\tif err := f.Close(); err != nil {\n-\t\tos.Remove(f.Name())\n-\t\treturn \"\", err\n+\t\treturn fmt.Errorf(\"downloaded zip file too large\")\n \t}\n-\treturn f.Name(), nil\n+\treturn nil\n }\n \n // pathEscape escapes s so it can be used in a path.\n // That is, it escapes things like ? and # (which really shouldn't appear anyway).\n // It does not escape / to %2F: our REST API is designed so that / can be left as is.\n func pathEscape(s string) string {\n-\treturn strings.Replace(url.PathEscape(s), \"%2F\", \"/\", -1)\n+\treturn strings.ReplaceAll(url.PathEscape(s), \"%2F\", \"/\")\n }"}, {"sha": "c63f6b04221dd570a7e4e8d34a79a83b27995e18", "filename": "libgo/go/cmd/go/internal/modfetch/repo.go", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Frepo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Frepo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Frepo.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -6,8 +6,10 @@ package modfetch\n \n import (\n \t\"fmt\"\n+\t\"io\"\n \t\"os\"\n \t\"sort\"\n+\t\"strconv\"\n \t\"time\"\n \n \t\"cmd/go/internal/cfg\"\n@@ -45,11 +47,8 @@ type Repo interface {\n \t// GoMod returns the go.mod file for the given version.\n \tGoMod(version string) (data []byte, err error)\n \n-\t// Zip downloads a zip file for the given version\n-\t// to a new file in a given temporary directory.\n-\t// It returns the name of the new file.\n-\t// The caller should remove the file when finished with it.\n-\tZip(version, tmpdir string) (tmpfile string, err error)\n+\t// Zip writes a zip file for the given version to dst.\n+\tZip(dst io.Writer, version string) error\n }\n \n // A Rev describes a single revision in a module repository.\n@@ -357,7 +356,11 @@ func (l *loggingRepo) GoMod(version string) ([]byte, error) {\n \treturn l.r.GoMod(version)\n }\n \n-func (l *loggingRepo) Zip(version, tmpdir string) (string, error) {\n-\tdefer logCall(\"Repo[%s]: Zip(%q, %q)\", l.r.ModulePath(), version, tmpdir)()\n-\treturn l.r.Zip(version, tmpdir)\n+func (l *loggingRepo) Zip(dst io.Writer, version string) error {\n+\tdstName := \"_\"\n+\tif dst, ok := dst.(interface{ Name() string }); ok {\n+\t\tdstName = strconv.Quote(dst.Name())\n+\t}\n+\tdefer logCall(\"Repo[%s]: Zip(%s, %q)\", l.r.ModulePath(), dstName, version)()\n+\treturn l.r.Zip(dst, version)\n }"}, {"sha": "ac13ede257b61dde833b4e636355978031af1089", "filename": "libgo/go/cmd/go/internal/modfetch/unzip.go", "status": "modified", "additions": 37, "deletions": 17, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Funzip.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Funzip.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Funzip.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -12,7 +12,6 @@ import (\n \t\"os\"\n \t\"path\"\n \t\"path/filepath\"\n-\t\"sort\"\n \t\"strings\"\n \n \t\"cmd/go/internal/modfetch/codehost\"\n@@ -21,12 +20,12 @@ import (\n )\n \n func Unzip(dir, zipfile, prefix string, maxSize int64) error {\n+\t// TODO(bcmills): The maxSize parameter is invariantly 0. Remove it.\n \tif maxSize == 0 {\n \t\tmaxSize = codehost.MaxZipFile\n \t}\n \n \t// Directory can exist, but must be empty.\n-\t// except maybe\n \tfiles, _ := ioutil.ReadDir(dir)\n \tif len(files) > 0 {\n \t\treturn fmt.Errorf(\"target directory %v exists and is not empty\", dir)\n@@ -98,22 +97,16 @@ func Unzip(dir, zipfile, prefix string, maxSize int64) error {\n \t}\n \n \t// Unzip, enforcing sizes checked earlier.\n-\tdirs := map[string]bool{dir: true}\n \tfor _, zf := range z.File {\n \t\tif zf.Name == prefix || strings.HasSuffix(zf.Name, \"/\") {\n \t\t\tcontinue\n \t\t}\n \t\tname := zf.Name[len(prefix):]\n \t\tdst := filepath.Join(dir, name)\n-\t\tparent := filepath.Dir(dst)\n-\t\tfor parent != dir {\n-\t\t\tdirs[parent] = true\n-\t\t\tparent = filepath.Dir(parent)\n-\t\t}\n \t\tif err := os.MkdirAll(filepath.Dir(dst), 0777); err != nil {\n \t\t\treturn err\n \t\t}\n-\t\tw, err := os.OpenFile(dst, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0444)\n+\t\tw, err := os.OpenFile(dst, os.O_WRONLY|os.O_CREATE|os.O_EXCL, 0444)\n \t\tif err != nil {\n \t\t\treturn fmt.Errorf(\"unzip %v: %v\", zipfile, err)\n \t\t}\n@@ -137,17 +130,44 @@ func Unzip(dir, zipfile, prefix string, maxSize int64) error {\n \t\t}\n \t}\n \n-\t// Mark directories unwritable, best effort.\n-\tvar dirlist []string\n-\tfor dir := range dirs {\n-\t\tdirlist = append(dirlist, dir)\n+\treturn nil\n+}\n+\n+// makeDirsReadOnly makes a best-effort attempt to remove write permissions for dir\n+// and its transitive contents.\n+func makeDirsReadOnly(dir string) {\n+\ttype pathMode struct {\n+\t\tpath string\n+\t\tmode os.FileMode\n \t}\n-\tsort.Strings(dirlist)\n+\tvar dirs []pathMode // in lexical order\n+\tfilepath.Walk(dir, func(path string, info os.FileInfo, err error) error {\n+\t\tif err == nil && info.Mode()&0222 != 0 {\n+\t\t\tif info.IsDir() {\n+\t\t\t\tdirs = append(dirs, pathMode{path, info.Mode()})\n+\t\t\t}\n+\t\t}\n+\t\treturn nil\n+\t})\n \n \t// Run over list backward to chmod children before parents.\n-\tfor i := len(dirlist) - 1; i >= 0; i-- {\n-\t\tos.Chmod(dirlist[i], 0555)\n+\tfor i := len(dirs) - 1; i >= 0; i-- {\n+\t\tos.Chmod(dirs[i].path, dirs[i].mode&^0222)\n \t}\n+}\n \n-\treturn nil\n+// RemoveAll removes a directory written by Download or Unzip, first applying\n+// any permission changes needed to do so.\n+func RemoveAll(dir string) error {\n+\t// Module cache has 0555 directories; make them writable in order to remove content.\n+\tfilepath.Walk(dir, func(path string, info os.FileInfo, err error) error {\n+\t\tif err != nil {\n+\t\t\treturn nil // ignore errors walking in file system\n+\t\t}\n+\t\tif info.IsDir() {\n+\t\t\tos.Chmod(path, 0777)\n+\t\t}\n+\t\treturn nil\n+\t})\n+\treturn os.RemoveAll(dir)\n }"}, {"sha": "7f9a18c6c2a6c02c9aa90beb1bd32b8d95ccabc9", "filename": "libgo/go/cmd/go/internal/modfile/rule.go", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Frule.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Frule.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Frule.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -154,7 +154,7 @@ func parseToFile(file string, data []byte, fix VersionFixer, strict bool) (*File\n \treturn f, nil\n }\n \n-var goVersionRE = regexp.MustCompile(`([1-9][0-9]*)\\.(0|[1-9][0-9]*)`)\n+var GoVersionRE = regexp.MustCompile(`([1-9][0-9]*)\\.(0|[1-9][0-9]*)`)\n \n func (f *File) add(errs *bytes.Buffer, line *Line, verb string, args []string, fix VersionFixer, strict bool) {\n \t// If strict is false, this module is a dependency.\n@@ -181,7 +181,7 @@ func (f *File) add(errs *bytes.Buffer, line *Line, verb string, args []string, f\n \t\t\tfmt.Fprintf(errs, \"%s:%d: repeated go statement\\n\", f.Syntax.Name, line.Start.Line)\n \t\t\treturn\n \t\t}\n-\t\tif len(args) != 1 || !goVersionRE.MatchString(args[0]) {\n+\t\tif len(args) != 1 || !GoVersionRE.MatchString(args[0]) {\n \t\t\tfmt.Fprintf(errs, \"%s:%d: usage: go 1.23\\n\", f.Syntax.Name, line.Start.Line)\n \t\t\treturn\n \t\t}\n@@ -477,6 +477,22 @@ func (f *File) Cleanup() {\n \tf.Syntax.Cleanup()\n }\n \n+func (f *File) AddGoStmt(version string) error {\n+\tif !GoVersionRE.MatchString(version) {\n+\t\treturn fmt.Errorf(\"invalid language version string %q\", version)\n+\t}\n+\tif f.Go == nil {\n+\t\tf.Go = &Go{\n+\t\t\tVersion: version,\n+\t\t\tSyntax:  f.Syntax.addLine(nil, \"go\", version),\n+\t\t}\n+\t} else {\n+\t\tf.Go.Version = version\n+\t\tf.Syntax.updateLine(f.Go.Syntax, \"go\", version)\n+\t}\n+\treturn nil\n+}\n+\n func (f *File) AddRequire(path, vers string) error {\n \tneed := true\n \tfor _, r := range f.Require {"}, {"sha": "2bfe6d3bb23fe2b460212e720bfa70d67924c031", "filename": "libgo/go/cmd/go/internal/modget/get.go", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodget%2Fget.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodget%2Fget.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodget%2Fget.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -78,7 +78,7 @@ to use newer patch releases when available. Continuing the previous example,\n In general, adding a new dependency may require upgrading\n existing dependencies to keep a working build, and 'go get' does\n this automatically. Similarly, downgrading one dependency may\n-require downgrading other dependenceis, and 'go get' does\n+require downgrading other dependencies, and 'go get' does\n this automatically as well.\n \n The -m flag instructs get to stop here, after resolving, upgrading,\n@@ -247,7 +247,7 @@ func runGet(cmd *base.Command, args []string) {\n \t\t// Deciding which module to upgrade/downgrade for a particular argument is difficult.\n \t\t// Patterns only make it more difficult.\n \t\t// We impose restrictions to avoid needing to interlace pattern expansion,\n-\t\t// like in in modload.ImportPaths.\n+\t\t// like in modload.ImportPaths.\n \t\t// Specifically, these patterns are supported:\n \t\t//\n \t\t//\t- Relative paths like ../../foo or ../../foo... are restricted to matching directories\n@@ -281,8 +281,8 @@ func runGet(cmd *base.Command, args []string) {\n \t\t\t\tbase.Errorf(\"go get %s: %v\", arg, err)\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\tif !str.HasFilePathPrefix(abs, modload.ModRoot) {\n-\t\t\t\tbase.Errorf(\"go get %s: directory %s is outside module root %s\", arg, abs, modload.ModRoot)\n+\t\t\tif !str.HasFilePathPrefix(abs, modload.ModRoot()) {\n+\t\t\t\tbase.Errorf(\"go get %s: directory %s is outside module root %s\", arg, abs, modload.ModRoot())\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\t// TODO: Check if abs is inside a nested module.\n@@ -534,9 +534,11 @@ func runGet(cmd *base.Command, args []string) {\n \t\t\t\t\t// module root.\n \t\t\t\t\tcontinue\n \t\t\t\t}\n+\t\t\t\tbase.Errorf(\"%s\", p.Error)\n \t\t\t}\n \t\t\ttodo = append(todo, p)\n \t\t}\n+\t\tbase.ExitIfErrors()\n \n \t\t// If -d was specified, we're done after the download: no build.\n \t\t// (The load.PackagesAndErrors is what did the download"}, {"sha": "af89b192fe4ed7243654b4b7cf7a350d05bb136f", "filename": "libgo/go/cmd/go/internal/modload/build.go", "status": "modified", "additions": 59, "deletions": 43, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuild.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -17,6 +17,7 @@ import (\n \t\"internal/goroot\"\n \t\"os\"\n \t\"path/filepath\"\n+\t\"runtime/debug\"\n \t\"strings\"\n )\n \n@@ -30,6 +31,9 @@ func isStandardImportPath(path string) bool {\n }\n \n func findStandardImportPath(path string) string {\n+\tif path == \"\" {\n+\t\tpanic(\"findStandardImportPath called with empty path\")\n+\t}\n \tif search.IsStandardImportPath(path) {\n \t\tif goroot.IsStandardPackage(cfg.GOROOT, cfg.BuildContext.Compiler, path) {\n \t\t\treturn filepath.Join(cfg.GOROOT, \"src\", path)\n@@ -95,11 +99,13 @@ func moduleInfo(m module.Version, fromBuildList bool) *modinfo.ModulePublic {\n \t\t\tPath:    m.Path,\n \t\t\tVersion: m.Version,\n \t\t\tMain:    true,\n-\t\t\tDir:     ModRoot,\n-\t\t\tGoMod:   filepath.Join(ModRoot, \"go.mod\"),\n \t\t}\n-\t\tif modFile.Go != nil {\n-\t\t\tinfo.GoVersion = modFile.Go.Version\n+\t\tif HasModRoot() {\n+\t\t\tinfo.Dir = ModRoot()\n+\t\t\tinfo.GoMod = filepath.Join(info.Dir, \"go.mod\")\n+\t\t\tif modFile.Go != nil {\n+\t\t\t\tinfo.GoVersion = modFile.Go.Version\n+\t\t\t}\n \t\t}\n \t\treturn info\n \t}\n@@ -114,7 +120,7 @@ func moduleInfo(m module.Version, fromBuildList bool) *modinfo.ModulePublic {\n \t}\n \n \tif cfg.BuildMod == \"vendor\" {\n-\t\tinfo.Dir = filepath.Join(ModRoot, \"vendor\", m.Path)\n+\t\tinfo.Dir = filepath.Join(ModRoot(), \"vendor\", m.Path)\n \t\treturn info\n \t}\n \n@@ -142,41 +148,46 @@ func moduleInfo(m module.Version, fromBuildList bool) *modinfo.ModulePublic {\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\tif cfg.BuildMod == \"vendor\" {\n-\t\t\tm.Dir = filepath.Join(ModRoot, \"vendor\", m.Path)\n-\t\t}\n \t}\n \n-\tcomplete(info)\n+\tif !fromBuildList {\n+\t\tcomplete(info)\n+\t\treturn info\n+\t}\n \n-\tif fromBuildList {\n-\t\tif r := Replacement(m); r.Path != \"\" {\n-\t\t\tinfo.Replace = &modinfo.ModulePublic{\n-\t\t\t\tPath:      r.Path,\n-\t\t\t\tVersion:   r.Version,\n-\t\t\t\tGoVersion: info.GoVersion,\n-\t\t\t}\n-\t\t\tif r.Version == \"\" {\n-\t\t\t\tif filepath.IsAbs(r.Path) {\n-\t\t\t\t\tinfo.Replace.Dir = r.Path\n-\t\t\t\t} else {\n-\t\t\t\t\tinfo.Replace.Dir = filepath.Join(ModRoot, r.Path)\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tcomplete(info.Replace)\n-\t\t\tinfo.Dir = info.Replace.Dir\n-\t\t\tinfo.GoMod = filepath.Join(info.Dir, \"go.mod\")\n-\t\t\tinfo.Error = nil // ignore error loading original module version (it has been replaced)\n-\t\t}\n+\tr := Replacement(m)\n+\tif r.Path == \"\" {\n+\t\tcomplete(info)\n+\t\treturn info\n \t}\n \n+\t// Don't hit the network to fill in extra data for replaced modules.\n+\t// The original resolved Version and Time don't matter enough to be\n+\t// worth the cost, and we're going to overwrite the GoMod and Dir from the\n+\t// replacement anyway. See https://golang.org/issue/27859.\n+\tinfo.Replace = &modinfo.ModulePublic{\n+\t\tPath:      r.Path,\n+\t\tVersion:   r.Version,\n+\t\tGoVersion: info.GoVersion,\n+\t}\n+\tif r.Version == \"\" {\n+\t\tif filepath.IsAbs(r.Path) {\n+\t\t\tinfo.Replace.Dir = r.Path\n+\t\t} else {\n+\t\t\tinfo.Replace.Dir = filepath.Join(ModRoot(), r.Path)\n+\t\t}\n+\t}\n+\tcomplete(info.Replace)\n+\tinfo.Dir = info.Replace.Dir\n+\tinfo.GoMod = filepath.Join(info.Dir, \"go.mod\")\n \treturn info\n }\n \n func PackageBuildInfo(path string, deps []string) string {\n \tif isStandardImportPath(path) || !Enabled() {\n \t\treturn \"\"\n \t}\n+\n \ttarget := findModule(path, path)\n \tmdeps := make(map[module.Version]bool)\n \tfor _, dep := range deps {\n@@ -216,28 +227,33 @@ func PackageBuildInfo(path string, deps []string) string {\n \treturn buf.String()\n }\n \n+// findModule returns the module containing the package at path,\n+// needed to build the package at target.\n func findModule(target, path string) module.Version {\n-\t// TODO: This should use loaded.\n-\tif path == \".\" {\n-\t\treturn buildList[0]\n-\t}\n-\tfor _, mod := range buildList {\n-\t\tif maybeInModule(path, mod.Path) {\n-\t\t\treturn mod\n+\tpkg, ok := loaded.pkgCache.Get(path).(*loadPkg)\n+\tif ok {\n+\t\tif pkg.err != nil {\n+\t\t\tbase.Fatalf(\"build %v: cannot load %v: %v\", target, path, pkg.err)\n \t\t}\n+\t\treturn pkg.mod\n+\t}\n+\n+\tif path == \"command-line-arguments\" {\n+\t\treturn Target\n+\t}\n+\n+\tif printStackInDie {\n+\t\tdebug.PrintStack()\n \t}\n \tbase.Fatalf(\"build %v: cannot find module for path %v\", target, path)\n \tpanic(\"unreachable\")\n }\n \n func ModInfoProg(info string) []byte {\n-\treturn []byte(fmt.Sprintf(`\n-\t\tpackage main\n-\t\timport _ \"unsafe\"\n-\t\t//go:linkname __debug_modinfo__ runtime/debug.modinfo\n-\t\tvar __debug_modinfo__ string\n-\t\tfunc init() {\n-\t\t\t__debug_modinfo__ = %q\n-\t\t}\n+\treturn []byte(fmt.Sprintf(`package main\n+import _ \"unsafe\"\n+//go:linkname __set_debug_modinfo__ runtime..z2fdebug.setmodinfo\n+func __set_debug_modinfo__(string)\n+func init() { __set_debug_modinfo__(%q) }\n \t`, string(infoStart)+info+string(infoEnd)))\n }"}, {"sha": "d9c8ae40d88f39a80109a31f3116210d6e6b9127", "filename": "libgo/go/cmd/go/internal/modload/help.go", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fhelp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fhelp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fhelp.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -393,17 +393,20 @@ no /* */ comments. Each line holds a single directive, made up of a\n verb followed by arguments. For example:\n \n \tmodule my/thing\n+\tgo 1.12\n \trequire other/thing v1.0.2\n-\trequire new/thing v2.3.4\n+\trequire new/thing/v2 v2.3.4\n \texclude old/thing v1.2.3\n \treplace bad/thing v1.4.5 => good/thing v1.4.5\n \n-The verbs are module, to define the module path; require, to require\n-a particular module at a given version or later; exclude, to exclude\n-a particular module version from use; and replace, to replace a module\n-version with a different module version. Exclude and replace apply only\n-in the main module's go.mod and are ignored in dependencies.\n-See https://research.swtch.com/vgo-mvs for details.\n+The verbs are\n+\tmodule, to define the module path;\n+\tgo, to set the expected language version;\n+\trequire, to require a particular module at a given version or later;\n+\texclude, to exclude a particular module version from use; and\n+\treplace, to replace a module version with a different module version.\n+Exclude and replace apply only in the main module's go.mod and are ignored\n+in dependencies.  See https://research.swtch.com/vgo-mvs for details.\n \n The leading verb can be factored out of adjacent lines to create a block,\n like in Go imports:"}, {"sha": "3210e16c25b084be98d6066a0dbc2c0a18e5dc35", "filename": "libgo/go/cmd/go/internal/modload/import.go", "status": "modified", "additions": 52, "deletions": 7, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -12,13 +12,17 @@ import (\n \t\"internal/goroot\"\n \t\"os\"\n \t\"path/filepath\"\n+\t\"sort\"\n \t\"strings\"\n+\t\"time\"\n \n \t\"cmd/go/internal/cfg\"\n+\t\"cmd/go/internal/modfetch\"\n \t\"cmd/go/internal/modfetch/codehost\"\n \t\"cmd/go/internal/module\"\n \t\"cmd/go/internal/par\"\n \t\"cmd/go/internal/search\"\n+\t\"cmd/go/internal/semver\"\n )\n \n type ImportMissingError struct {\n@@ -58,9 +62,6 @@ func Import(path string) (m module.Version, dir string, err error) {\n \n \t// Is the package in the standard library?\n \tif search.IsStandardImportPath(path) {\n-\t\tif strings.HasPrefix(path, \"golang_org/\") {\n-\t\t\treturn module.Version{}, filepath.Join(cfg.GOROOT, \"src/vendor\", path), nil\n-\t\t}\n \t\tif goroot.IsStandardPackage(cfg.GOROOT, cfg.BuildContext.Compiler, path) {\n \t\t\tdir := filepath.Join(cfg.GOROOT, \"src\", path)\n \t\t\treturn module.Version{}, dir, nil\n@@ -70,8 +71,8 @@ func Import(path string) (m module.Version, dir string, err error) {\n \t// -mod=vendor is special.\n \t// Everything must be in the main module or the main module's vendor directory.\n \tif cfg.BuildMod == \"vendor\" {\n-\t\tmainDir, mainOK := dirInModule(path, Target.Path, ModRoot, true)\n-\t\tvendorDir, vendorOK := dirInModule(path, \"\", filepath.Join(ModRoot, \"vendor\"), false)\n+\t\tmainDir, mainOK := dirInModule(path, Target.Path, ModRoot(), true)\n+\t\tvendorDir, vendorOK := dirInModule(path, \"\", filepath.Join(ModRoot(), \"vendor\"), false)\n \t\tif mainOK && vendorOK {\n \t\t\treturn module.Version{}, \"\", fmt.Errorf(\"ambiguous import: found %s in multiple directories:\\n\\t%s\\n\\t%s\", path, mainDir, vendorDir)\n \t\t}\n@@ -125,14 +126,58 @@ func Import(path string) (m module.Version, dir string, err error) {\n \t\treturn module.Version{}, \"\", errors.New(buf.String())\n \t}\n \n-\t// Not on build list.\n-\n \t// Look up module containing the package, for addition to the build list.\n \t// Goal is to determine the module, download it to dir, and return m, dir, ErrMissing.\n \tif cfg.BuildMod == \"readonly\" {\n \t\treturn module.Version{}, \"\", fmt.Errorf(\"import lookup disabled by -mod=%s\", cfg.BuildMod)\n \t}\n \n+\t// Not on build list.\n+\t// To avoid spurious remote fetches, next try the latest replacement for each module.\n+\t// (golang.org/issue/26241)\n+\tif modFile != nil {\n+\t\tlatest := map[string]string{} // path -> version\n+\t\tfor _, r := range modFile.Replace {\n+\t\t\tif maybeInModule(path, r.Old.Path) {\n+\t\t\t\tlatest[r.Old.Path] = semver.Max(r.Old.Version, latest[r.Old.Path])\n+\t\t\t}\n+\t\t}\n+\n+\t\tmods = make([]module.Version, 0, len(latest))\n+\t\tfor p, v := range latest {\n+\t\t\t// If the replacement didn't specify a version, synthesize a\n+\t\t\t// pseudo-version with an appropriate major version and a timestamp below\n+\t\t\t// any real timestamp. That way, if the main module is used from within\n+\t\t\t// some other module, the user will be able to upgrade the requirement to\n+\t\t\t// any real version they choose.\n+\t\t\tif v == \"\" {\n+\t\t\t\tif _, pathMajor, ok := module.SplitPathVersion(p); ok && len(pathMajor) > 0 {\n+\t\t\t\t\tv = modfetch.PseudoVersion(pathMajor[1:], \"\", time.Time{}, \"000000000000\")\n+\t\t\t\t} else {\n+\t\t\t\t\tv = modfetch.PseudoVersion(\"v0\", \"\", time.Time{}, \"000000000000\")\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tmods = append(mods, module.Version{Path: p, Version: v})\n+\t\t}\n+\n+\t\t// Every module path in mods is a prefix of the import path.\n+\t\t// As in QueryPackage, prefer the longest prefix that satisfies the import.\n+\t\tsort.Slice(mods, func(i, j int) bool {\n+\t\t\treturn len(mods[i].Path) > len(mods[j].Path)\n+\t\t})\n+\t\tfor _, m := range mods {\n+\t\t\troot, isLocal, err := fetch(m)\n+\t\t\tif err != nil {\n+\t\t\t\t// Report fetch error as above.\n+\t\t\t\treturn module.Version{}, \"\", err\n+\t\t\t}\n+\t\t\t_, ok := dirInModule(path, m.Path, root, isLocal)\n+\t\t\tif ok {\n+\t\t\t\treturn m, \"\", &ImportMissingError{ImportPath: path, Module: m}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \tm, _, err = QueryPackage(path, \"latest\", Allowed)\n \tif err != nil {\n \t\tif _, ok := err.(*codehost.VCSError); ok {"}, {"sha": "9422a3d960c16278fad5df23576a4f6a2603cd5b", "filename": "libgo/go/cmd/go/internal/modload/import_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport_test.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -45,7 +45,7 @@ func TestImport(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n \n \tfor _, tt := range importTests {\n-\t\tt.Run(strings.Replace(tt.path, \"/\", \"_\", -1), func(t *testing.T) {\n+\t\tt.Run(strings.ReplaceAll(tt.path, \"/\", \"_\"), func(t *testing.T) {\n \t\t\t// Note that there is no build list, so Import should always fail.\n \t\t\tm, dir, err := Import(tt.path)\n \t\t\tif err == nil {"}, {"sha": "22d14ccce78b241d780ee526754bd3ca8510144a", "filename": "libgo/go/cmd/go/internal/modload/init.go", "status": "modified", "additions": 195, "deletions": 76, "changes": 271, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Finit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Finit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Finit.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -16,27 +16,31 @@ import (\n \t\"cmd/go/internal/modfile\"\n \t\"cmd/go/internal/module\"\n \t\"cmd/go/internal/mvs\"\n+\t\"cmd/go/internal/renameio\"\n \t\"cmd/go/internal/search\"\n \t\"encoding/json\"\n \t\"fmt\"\n+\t\"go/build\"\n \t\"io/ioutil\"\n \t\"os\"\n \t\"path\"\n \t\"path/filepath\"\n \t\"regexp\"\n+\t\"runtime/debug\"\n \t\"strconv\"\n \t\"strings\"\n )\n \n var (\n-\tcwd            string\n+\tcwd            string // TODO(bcmills): Is this redundant with base.Cwd?\n \tMustUseModules = mustUseModules()\n \tinitialized    bool\n \n-\tModRoot  string\n-\tmodFile  *modfile.File\n-\texcluded map[module.Version]bool\n-\tTarget   module.Version\n+\tmodRoot     string\n+\tmodFile     *modfile.File\n+\tmodFileData []byte\n+\texcluded    map[module.Version]bool\n+\tTarget      module.Version\n \n \tgopath string\n \n@@ -53,11 +57,15 @@ var (\n // To make permanent changes to the require statements\n // in go.mod, edit it before calling ImportPaths or LoadBuildList.\n func ModFile() *modfile.File {\n+\tInit()\n+\tif modFile == nil {\n+\t\tdie()\n+\t}\n \treturn modFile\n }\n \n func BinDir() string {\n-\tMustInit()\n+\tInit()\n \treturn filepath.Join(gopath, \"bin\")\n }\n \n@@ -73,6 +81,10 @@ func mustUseModules() bool {\n \n var inGOPATH bool // running in GOPATH/src\n \n+// Init determines whether module mode is enabled, locates the root of the\n+// current module (if any), sets environment variables for Git subprocesses, and\n+// configures the cfg, codehost, load, modfetch, and search packages for use\n+// with modules.\n func Init() {\n \tif initialized {\n \t\treturn\n@@ -138,6 +150,9 @@ func Init() {\n \t}\n \n \tif inGOPATH && !MustUseModules {\n+\t\tif CmdModInit {\n+\t\t\tdie() // Don't init a module that we're just going to ignore.\n+\t\t}\n \t\t// No automatic enabling in GOPATH.\n \t\tif root, _ := FindModuleRoot(cwd, \"\", false); root != \"\" {\n \t\t\tcfg.GoModInGOPATH = filepath.Join(root, \"go.mod\")\n@@ -147,26 +162,54 @@ func Init() {\n \n \tif CmdModInit {\n \t\t// Running 'go mod init': go.mod will be created in current directory.\n-\t\tModRoot = cwd\n+\t\tmodRoot = cwd\n \t} else {\n-\t\tModRoot, _ = FindModuleRoot(cwd, \"\", MustUseModules)\n-\t\tif !MustUseModules {\n-\t\t\tif ModRoot == \"\" {\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t\tif search.InDir(ModRoot, os.TempDir()) == \".\" {\n-\t\t\t\t// If you create /tmp/go.mod for experimenting,\n-\t\t\t\t// then any tests that create work directories under /tmp\n-\t\t\t\t// will find it and get modules when they're not expecting them.\n-\t\t\t\t// It's a bit of a peculiar thing to disallow but quite mysterious\n-\t\t\t\t// when it happens. See golang.org/issue/26708.\n-\t\t\t\tModRoot = \"\"\n-\t\t\t\tfmt.Fprintf(os.Stderr, \"go: warning: ignoring go.mod in system temp root %v\\n\", os.TempDir())\n+\t\tmodRoot, _ = FindModuleRoot(cwd, \"\", MustUseModules)\n+\t\tif modRoot == \"\" {\n+\t\t\tif !MustUseModules {\n+\t\t\t\t// GO111MODULE is 'auto' (or unset), and we can't find a module root.\n+\t\t\t\t// Stay in GOPATH mode.\n \t\t\t\treturn\n \t\t\t}\n+\t\t} else if search.InDir(modRoot, os.TempDir()) == \".\" {\n+\t\t\t// If you create /tmp/go.mod for experimenting,\n+\t\t\t// then any tests that create work directories under /tmp\n+\t\t\t// will find it and get modules when they're not expecting them.\n+\t\t\t// It's a bit of a peculiar thing to disallow but quite mysterious\n+\t\t\t// when it happens. See golang.org/issue/26708.\n+\t\t\tmodRoot = \"\"\n+\t\t\tfmt.Fprintf(os.Stderr, \"go: warning: ignoring go.mod in system temp root %v\\n\", os.TempDir())\n \t\t}\n \t}\n \n+\t// We're in module mode. Install the hooks to make it work.\n+\n+\tif c := cache.Default(); c == nil {\n+\t\t// With modules, there are no install locations for packages\n+\t\t// other than the build cache.\n+\t\tbase.Fatalf(\"go: cannot use modules with build cache disabled\")\n+\t}\n+\n+\tlist := filepath.SplitList(cfg.BuildContext.GOPATH)\n+\tif len(list) == 0 || list[0] == \"\" {\n+\t\tbase.Fatalf(\"missing $GOPATH\")\n+\t}\n+\tgopath = list[0]\n+\tif _, err := os.Stat(filepath.Join(gopath, \"go.mod\")); err == nil {\n+\t\tbase.Fatalf(\"$GOPATH/go.mod exists but should not\")\n+\t}\n+\n+\toldSrcMod := filepath.Join(list[0], \"src/mod\")\n+\tpkgMod := filepath.Join(list[0], \"pkg/mod\")\n+\tinfoOld, errOld := os.Stat(oldSrcMod)\n+\t_, errMod := os.Stat(pkgMod)\n+\tif errOld == nil && infoOld.IsDir() && errMod != nil && os.IsNotExist(errMod) {\n+\t\tos.Rename(oldSrcMod, pkgMod)\n+\t}\n+\n+\tmodfetch.PkgMod = pkgMod\n+\tcodehost.WorkRoot = filepath.Join(pkgMod, \"cache/vcs\")\n+\n \tcfg.ModulesEnabled = true\n \tload.ModBinDir = BinDir\n \tload.ModLookup = Lookup\n@@ -177,7 +220,35 @@ func Init() {\n \tload.ModImportFromFiles = ImportFromFiles\n \tload.ModDirImportPath = DirImportPath\n \n-\tsearch.SetModRoot(ModRoot)\n+\tif modRoot == \"\" {\n+\t\t// We're in module mode, but not inside a module.\n+\t\t//\n+\t\t// If the command is 'go get' or 'go list' and all of the args are in the\n+\t\t// same existing module, we could use that module's download directory in\n+\t\t// the module cache as the module root, applying any replacements and/or\n+\t\t// exclusions specified by that module. However, that would leave us in a\n+\t\t// strange state: we want 'go get' to be consistent with 'go list', and 'go\n+\t\t// list' should be able to operate on multiple modules. Moreover, the 'get'\n+\t\t// target might specify relative file paths (e.g. in the same repository) as\n+\t\t// replacements, and we would not be able to apply those anyway: we would\n+\t\t// need to either error out or ignore just those replacements, when a build\n+\t\t// from an empty module could proceed without error.\n+\t\t//\n+\t\t// Instead, we'll operate as though we're in some ephemeral external module,\n+\t\t// ignoring all replacements and exclusions uniformly.\n+\n+\t\t// Normally we check sums using the go.sum file from the main module, but\n+\t\t// without a main module we do not have an authoritative go.sum file.\n+\t\t//\n+\t\t// TODO(bcmills): In Go 1.13, check sums when outside the main module.\n+\t\t//\n+\t\t// One possible approach is to merge the go.sum files from all of the\n+\t\t// modules we download: that doesn't protect us against bad top-level\n+\t\t// modules, but it at least ensures consistency for transitive dependencies.\n+\t} else {\n+\t\tmodfetch.GoSumFile = filepath.Join(modRoot, \"go.sum\")\n+\t\tsearch.SetModRoot(modRoot)\n+\t}\n }\n \n func init() {\n@@ -190,38 +261,41 @@ func init() {\n }\n \n // Enabled reports whether modules are (or must be) enabled.\n-// If modules must be enabled but are not, Enabled returns true\n+// If modules are enabled but there is no main module, Enabled returns true\n // and then the first use of module information will call die\n-// (usually through InitMod and MustInit).\n+// (usually through MustModRoot).\n func Enabled() bool {\n-\tif !initialized {\n-\t\tpanic(\"go: Enabled called before Init\")\n-\t}\n-\treturn ModRoot != \"\" || MustUseModules\n+\tInit()\n+\treturn modRoot != \"\" || MustUseModules\n }\n \n-// MustInit calls Init if needed and checks that\n-// modules are enabled and the main module has been found.\n-// If not, MustInit calls base.Fatalf with an appropriate message.\n-func MustInit() {\n-\tif Init(); ModRoot == \"\" {\n+// ModRoot returns the root of the main module.\n+// It calls base.Fatalf if there is no main module.\n+func ModRoot() string {\n+\tif !HasModRoot() {\n \t\tdie()\n \t}\n-\tif c := cache.Default(); c == nil {\n-\t\t// With modules, there are no install locations for packages\n-\t\t// other than the build cache.\n-\t\tbase.Fatalf(\"go: cannot use modules with build cache disabled\")\n-\t}\n+\treturn modRoot\n }\n \n-// Failed reports whether module loading failed.\n-// If Failed returns true, then any use of module information will call die.\n-func Failed() bool {\n+// HasModRoot reports whether a main module is present.\n+// HasModRoot may return false even if Enabled returns true: for example, 'get'\n+// does not require a main module.\n+func HasModRoot() bool {\n \tInit()\n-\treturn cfg.ModulesEnabled && ModRoot == \"\"\n+\treturn modRoot != \"\"\n }\n \n+// printStackInDie causes die to print a stack trace.\n+//\n+// It is enabled by the testgo tag, and helps to diagnose paths that\n+// unexpectedly require a main module.\n+var printStackInDie = false\n+\n func die() {\n+\tif printStackInDie {\n+\t\tdebug.PrintStack()\n+\t}\n \tif os.Getenv(\"GO111MODULE\") == \"off\" {\n \t\tbase.Fatalf(\"go: modules disabled by GO111MODULE=off; see 'go help modules'\")\n \t}\n@@ -231,33 +305,20 @@ func die() {\n \tbase.Fatalf(\"go: cannot find main module; see 'go help modules'\")\n }\n \n+// InitMod sets Target and, if there is a main module, parses the initial build\n+// list from its go.mod file, creating and populating that file if needed.\n func InitMod() {\n-\tMustInit()\n-\tif modFile != nil {\n+\tif len(buildList) > 0 {\n \t\treturn\n \t}\n \n-\tlist := filepath.SplitList(cfg.BuildContext.GOPATH)\n-\tif len(list) == 0 || list[0] == \"\" {\n-\t\tbase.Fatalf(\"missing $GOPATH\")\n-\t}\n-\tgopath = list[0]\n-\tif _, err := os.Stat(filepath.Join(gopath, \"go.mod\")); err == nil {\n-\t\tbase.Fatalf(\"$GOPATH/go.mod exists but should not\")\n-\t}\n-\n-\toldSrcMod := filepath.Join(list[0], \"src/mod\")\n-\tpkgMod := filepath.Join(list[0], \"pkg/mod\")\n-\tinfoOld, errOld := os.Stat(oldSrcMod)\n-\t_, errMod := os.Stat(pkgMod)\n-\tif errOld == nil && infoOld.IsDir() && errMod != nil && os.IsNotExist(errMod) {\n-\t\tos.Rename(oldSrcMod, pkgMod)\n+\tInit()\n+\tif modRoot == \"\" {\n+\t\tTarget = module.Version{Path: \"command-line-arguments\"}\n+\t\tbuildList = []module.Version{Target}\n+\t\treturn\n \t}\n \n-\tmodfetch.PkgMod = pkgMod\n-\tmodfetch.GoSumFile = filepath.Join(ModRoot, \"go.sum\")\n-\tcodehost.WorkRoot = filepath.Join(pkgMod, \"cache/vcs\")\n-\n \tif CmdModInit {\n \t\t// Running go mod init: do legacy module conversion\n \t\tlegacyModInit()\n@@ -266,7 +327,7 @@ func InitMod() {\n \t\treturn\n \t}\n \n-\tgomod := filepath.Join(ModRoot, \"go.mod\")\n+\tgomod := filepath.Join(modRoot, \"go.mod\")\n \tdata, err := ioutil.ReadFile(gomod)\n \tif err != nil {\n \t\tif os.IsNotExist(err) {\n@@ -284,10 +345,11 @@ func InitMod() {\n \t\tbase.Fatalf(\"go: errors parsing go.mod:\\n%s\\n\", err)\n \t}\n \tmodFile = f\n+\tmodFileData = data\n \n \tif len(f.Syntax.Stmt) == 0 || f.Module == nil {\n \t\t// Empty mod file. Must add module path.\n-\t\tpath, err := FindModulePath(ModRoot)\n+\t\tpath, err := FindModulePath(modRoot)\n \t\tif err != nil {\n \t\t\tbase.Fatalf(\"go: %v\", err)\n \t\t}\n@@ -325,7 +387,7 @@ func Allowed(m module.Version) bool {\n \n func legacyModInit() {\n \tif modFile == nil {\n-\t\tpath, err := FindModulePath(ModRoot)\n+\t\tpath, err := FindModulePath(modRoot)\n \t\tif err != nil {\n \t\t\tbase.Fatalf(\"go: %v\", err)\n \t\t}\n@@ -334,8 +396,10 @@ func legacyModInit() {\n \t\tmodFile.AddModuleStmt(path)\n \t}\n \n+\taddGoStmt()\n+\n \tfor _, name := range altConfigs {\n-\t\tcfg := filepath.Join(ModRoot, name)\n+\t\tcfg := filepath.Join(modRoot, name)\n \t\tdata, err := ioutil.ReadFile(cfg)\n \t\tif err == nil {\n \t\t\tconvert := modconv.Converters[name]\n@@ -356,6 +420,25 @@ func legacyModInit() {\n \t}\n }\n \n+// InitGoStmt adds a go statement, unless there already is one.\n+func InitGoStmt() {\n+\tif modFile.Go == nil {\n+\t\taddGoStmt()\n+\t}\n+}\n+\n+// addGoStmt adds a go statement referring to the current version.\n+func addGoStmt() {\n+\ttags := build.Default.ReleaseTags\n+\tversion := tags[len(tags)-1]\n+\tif !strings.HasPrefix(version, \"go\") || !modfile.GoVersionRE.MatchString(version[2:]) {\n+\t\tbase.Fatalf(\"go: unrecognized default version %q\", version)\n+\t}\n+\tif err := modFile.AddGoStmt(version[2:]); err != nil {\n+\t\tbase.Fatalf(\"go: internal error: %v\", err)\n+\t}\n+}\n+\n var altConfigs = []string{\n \t\"Gopkg.lock\",\n \n@@ -379,7 +462,7 @@ func FindModuleRoot(dir, limit string, legacyConfigOK bool) (root, file string)\n \n \t// Look for enclosing go.mod.\n \tfor {\n-\t\tif _, err := os.Stat(filepath.Join(dir, \"go.mod\")); err == nil {\n+\t\tif fi, err := os.Stat(filepath.Join(dir, \"go.mod\")); err == nil && !fi.IsDir() {\n \t\t\treturn dir, \"go.mod\"\n \t\t}\n \t\tif dir == limit {\n@@ -397,7 +480,7 @@ func FindModuleRoot(dir, limit string, legacyConfigOK bool) (root, file string)\n \t\tdir = dir1\n \t\tfor {\n \t\t\tfor _, name := range altConfigs {\n-\t\t\t\tif _, err := os.Stat(filepath.Join(dir, name)); err == nil {\n+\t\t\t\tif fi, err := os.Stat(filepath.Join(dir, name)); err == nil && !fi.IsDir() {\n \t\t\t\t\treturn dir, name\n \t\t\t\t}\n \t\t\t}\n@@ -541,6 +624,11 @@ func WriteGoMod() {\n \t\treturn\n \t}\n \n+\t// If we aren't in a module, we don't have anywhere to write a go.mod file.\n+\tif modRoot == \"\" {\n+\t\treturn\n+\t}\n+\n \tif loaded != nil {\n \t\treqs := MinReqs()\n \t\tmin, err := reqs.Required(Target)\n@@ -557,22 +645,53 @@ func WriteGoMod() {\n \t\tmodFile.SetRequire(list)\n \t}\n \n-\tfile := filepath.Join(ModRoot, \"go.mod\")\n-\told, _ := ioutil.ReadFile(file)\n \tmodFile.Cleanup() // clean file after edits\n \tnew, err := modFile.Format()\n \tif err != nil {\n \t\tbase.Fatalf(\"go: %v\", err)\n \t}\n-\tif !bytes.Equal(old, new) {\n-\t\tif cfg.BuildMod == \"readonly\" {\n-\t\t\tbase.Fatalf(\"go: updates to go.mod needed, disabled by -mod=readonly\")\n+\n+\t// Always update go.sum, even if we didn't change go.mod: we may have\n+\t// downloaded modules that we didn't have before.\n+\tmodfetch.WriteGoSum()\n+\n+\tif bytes.Equal(new, modFileData) {\n+\t\t// We don't need to modify go.mod from what we read previously.\n+\t\t// Ignore any intervening edits.\n+\t\treturn\n+\t}\n+\tif cfg.BuildMod == \"readonly\" {\n+\t\tbase.Fatalf(\"go: updates to go.mod needed, disabled by -mod=readonly\")\n+\t}\n+\n+\tunlock := modfetch.SideLock()\n+\tdefer unlock()\n+\n+\tfile := filepath.Join(modRoot, \"go.mod\")\n+\told, err := ioutil.ReadFile(file)\n+\tif !bytes.Equal(old, modFileData) {\n+\t\tif bytes.Equal(old, new) {\n+\t\t\t// Some other process wrote the same go.mod file that we were about to write.\n+\t\t\tmodFileData = new\n+\t\t\treturn\n \t\t}\n-\t\tif err := ioutil.WriteFile(file, new, 0666); err != nil {\n-\t\t\tbase.Fatalf(\"go: %v\", err)\n+\t\tif err != nil {\n+\t\t\tbase.Fatalf(\"go: can't determine whether go.mod has changed: %v\", err)\n \t\t}\n+\t\t// The contents of the go.mod file have changed. In theory we could add all\n+\t\t// of the new modules to the build list, recompute, and check whether any\n+\t\t// module in *our* build list got bumped to a different version, but that's\n+\t\t// a lot of work for marginal benefit. Instead, fail the command: if users\n+\t\t// want to run concurrent commands, they need to start with a complete,\n+\t\t// consistent module definition.\n+\t\tbase.Fatalf(\"go: updates to go.mod needed, but contents have changed\")\n+\n \t}\n-\tmodfetch.WriteGoSum()\n+\n+\tif err := renameio.WriteFile(file, new); err != nil {\n+\t\tbase.Fatalf(\"error writing go.mod: %v\", err)\n+\t}\n+\tmodFileData = new\n }\n \n func fixVersion(path, vers string) (string, error) {"}, {"sha": "2df9d8af7df1b6a9d68c40154b1cce53f44e13f7", "filename": "libgo/go/cmd/go/internal/modload/init_test.go", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Finit_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Finit_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Finit_test.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package modload\n+\n+import (\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"testing\"\n+)\n+\n+func TestFindModuleRootIgnoreDir(t *testing.T) {\n+\t// In Plan 9, directories are automatically created in /n.\n+\t// For example, /n/go.mod always exist, but it's a directory.\n+\t// Test that we ignore directories when trying to find go.mod and other config files.\n+\n+\tdir, err := ioutil.TempDir(\"\", \"gotest\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"failed to create temporary directory: %v\", err)\n+\t}\n+\tdefer os.RemoveAll(dir)\n+\tif err := os.Mkdir(filepath.Join(dir, \"go.mod\"), os.ModeDir|0755); err != nil {\n+\t\tt.Fatalf(\"Mkdir failed: %v\", err)\n+\t}\n+\tfor _, name := range altConfigs {\n+\t\tif err := os.MkdirAll(filepath.Join(dir, name), os.ModeDir|0755); err != nil {\n+\t\t\tt.Fatalf(\"MkdirAll failed: %v\", err)\n+\t\t}\n+\t}\n+\tp := filepath.Join(dir, \"example\")\n+\tif err := os.Mkdir(p, os.ModeDir|0755); err != nil {\n+\t\tt.Fatalf(\"Mkdir failed: %v\", err)\n+\t}\n+\tif root, _ := FindModuleRoot(p, \"\", false); root != \"\" {\n+\t\tt.Errorf(\"FindModuleRoot(%q, \\\"\\\", false): %q, want empty string\", p, root)\n+\t}\n+\tif root, _ := FindModuleRoot(p, \"\", true); root != \"\" {\n+\t\tt.Errorf(\"FindModuleRoot(%q, \\\"\\\", true): %q, want empty string\", p, root)\n+\t}\n+}"}, {"sha": "2f1a3c24d223cf007299bf5a049b139e9ba97b04", "filename": "libgo/go/cmd/go/internal/modload/list.go", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Flist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Flist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Flist.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -17,7 +17,7 @@ import (\n )\n \n func ListModules(args []string, listU, listVersions bool) []*modinfo.ModulePublic {\n-\tmods := listModules(args)\n+\tmods := listModules(args, listVersions)\n \tif listU || listVersions {\n \t\tvar work par.Work\n \t\tfor _, m := range mods {\n@@ -39,7 +39,7 @@ func ListModules(args []string, listU, listVersions bool) []*modinfo.ModulePubli\n \treturn mods\n }\n \n-func listModules(args []string) []*modinfo.ModulePublic {\n+func listModules(args []string, listVersions bool) []*modinfo.ModulePublic {\n \tLoadBuildList()\n \tif len(args) == 0 {\n \t\treturn []*modinfo.ModulePublic{moduleInfo(buildList[0], true)}\n@@ -83,6 +83,10 @@ func listModules(args []string) []*modinfo.ModulePublic {\n \t\t}\n \t\tmatched := false\n \t\tfor i, m := range buildList {\n+\t\t\tif i == 0 && !HasModRoot() {\n+\t\t\t\t// The root module doesn't actually exist: omit it.\n+\t\t\t\tcontinue\n+\t\t\t}\n \t\t\tif match(m.Path) {\n \t\t\t\tmatched = true\n \t\t\t\tif !matchedBuildList[i] {\n@@ -93,6 +97,16 @@ func listModules(args []string) []*modinfo.ModulePublic {\n \t\t}\n \t\tif !matched {\n \t\t\tif literal {\n+\t\t\t\tif listVersions {\n+\t\t\t\t\t// Don't make the user provide an explicit '@latest' when they're\n+\t\t\t\t\t// explicitly asking what the available versions are.\n+\t\t\t\t\t// Instead, resolve the module, even if it isn't an existing dependency.\n+\t\t\t\t\tinfo, err := Query(arg, \"latest\", nil)\n+\t\t\t\t\tif err == nil {\n+\t\t\t\t\t\tmods = append(mods, moduleInfo(module.Version{Path: arg, Version: info.Version}, false))\n+\t\t\t\t\t\tcontinue\n+\t\t\t\t\t}\n+\t\t\t\t}\n \t\t\t\tmods = append(mods, &modinfo.ModulePublic{\n \t\t\t\t\tPath: arg,\n \t\t\t\t\tError: &modinfo.ModuleError{"}, {"sha": "9a1fb76bb9566cfde5fb27be44a5fb0946337ff3", "filename": "libgo/go/cmd/go/internal/modload/load.go", "status": "modified", "additions": 29, "deletions": 25, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fload.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fload.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fload.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -90,7 +90,7 @@ func ImportPaths(patterns []string) []*search.Match {\n \t\t\t\t// the exact version of a particular module increases during\n \t\t\t\t// the loader iterations.\n \t\t\t\tm.Pkgs = str.StringList(fsDirs[i])\n-\t\t\t\tfor i, pkg := range m.Pkgs {\n+\t\t\t\tfor j, pkg := range m.Pkgs {\n \t\t\t\t\tdir := pkg\n \t\t\t\t\tif !filepath.IsAbs(dir) {\n \t\t\t\t\t\tdir = filepath.Join(cwd, pkg)\n@@ -101,10 +101,10 @@ func ImportPaths(patterns []string) []*search.Match {\n \t\t\t\t\t// Note: The checks for @ here are just to avoid misinterpreting\n \t\t\t\t\t// the module cache directories (formerly GOPATH/src/mod/foo@v1.5.2/bar).\n \t\t\t\t\t// It's not strictly necessary but helpful to keep the checks.\n-\t\t\t\t\tif dir == ModRoot {\n+\t\t\t\t\tif modRoot != \"\" && dir == modRoot {\n \t\t\t\t\t\tpkg = Target.Path\n-\t\t\t\t\t} else if strings.HasPrefix(dir, ModRoot+string(filepath.Separator)) && !strings.Contains(dir[len(ModRoot):], \"@\") {\n-\t\t\t\t\t\tsuffix := filepath.ToSlash(dir[len(ModRoot):])\n+\t\t\t\t\t} else if modRoot != \"\" && strings.HasPrefix(dir, modRoot+string(filepath.Separator)) && !strings.Contains(dir[len(modRoot):], \"@\") {\n+\t\t\t\t\t\tsuffix := filepath.ToSlash(dir[len(modRoot):])\n \t\t\t\t\t\tif strings.HasPrefix(suffix, \"/vendor/\") {\n \t\t\t\t\t\t\t// TODO getmode vendor check\n \t\t\t\t\t\t\tpkg = strings.TrimPrefix(suffix, \"/vendor/\")\n@@ -118,24 +118,21 @@ func ImportPaths(patterns []string) []*search.Match {\n \t\t\t\t\t} else {\n \t\t\t\t\t\tpkg = \"\"\n \t\t\t\t\t\tif !iterating {\n+\t\t\t\t\t\t\tModRoot()\n \t\t\t\t\t\t\tbase.Errorf(\"go: directory %s outside available modules\", base.ShortPath(dir))\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tinfo, err := os.Stat(dir)\n \t\t\t\t\tif err != nil || !info.IsDir() {\n-\t\t\t\t\t\t// If the directory does not exist,\n-\t\t\t\t\t\t// don't turn it into an import path\n-\t\t\t\t\t\t// that will trigger a lookup.\n-\t\t\t\t\t\tpkg = \"\"\n-\t\t\t\t\t\tif !iterating {\n-\t\t\t\t\t\t\tif err != nil {\n-\t\t\t\t\t\t\t\tbase.Errorf(\"go: no such directory %v\", m.Pattern)\n-\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\tbase.Errorf(\"go: %s is not a directory\", m.Pattern)\n-\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t// If the directory is local but does not exist, don't return it\n+\t\t\t\t\t\t// while loader is iterating, since this would trigger a fetch.\n+\t\t\t\t\t\t// After loader is done iterating, we still need to return the\n+\t\t\t\t\t\t// path, so that \"go list -e\" produces valid output.\n+\t\t\t\t\t\tif iterating {\n+\t\t\t\t\t\t\tpkg = \"\"\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n-\t\t\t\t\tm.Pkgs[i] = pkg\n+\t\t\t\t\tm.Pkgs[j] = pkg\n \t\t\t\t}\n \n \t\t\tcase strings.Contains(m.Pattern, \"...\"):\n@@ -251,17 +248,21 @@ func ImportFromFiles(gofiles []string) {\n // DirImportPath returns the effective import path for dir,\n // provided it is within the main module, or else returns \".\".\n func DirImportPath(dir string) string {\n+\tif modRoot == \"\" {\n+\t\treturn \".\"\n+\t}\n+\n \tif !filepath.IsAbs(dir) {\n \t\tdir = filepath.Join(cwd, dir)\n \t} else {\n \t\tdir = filepath.Clean(dir)\n \t}\n \n-\tif dir == ModRoot {\n+\tif dir == modRoot {\n \t\treturn Target.Path\n \t}\n-\tif strings.HasPrefix(dir, ModRoot+string(filepath.Separator)) {\n-\t\tsuffix := filepath.ToSlash(dir[len(ModRoot):])\n+\tif strings.HasPrefix(dir, modRoot+string(filepath.Separator)) {\n+\t\tsuffix := filepath.ToSlash(dir[len(modRoot):])\n \t\tif strings.HasPrefix(suffix, \"/vendor/\") {\n \t\t\treturn strings.TrimPrefix(suffix, \"/vendor/\")\n \t\t}\n@@ -397,6 +398,9 @@ func ModuleUsedDirectly(path string) bool {\n // Lookup requires that one of the Load functions in this package has already\n // been called.\n func Lookup(path string) (dir, realPath string, err error) {\n+\tif path == \"\" {\n+\t\tpanic(\"Lookup called with empty package path\")\n+\t}\n \tpkg, ok := loaded.pkgCache.Get(path).(*loadPkg)\n \tif !ok {\n \t\t// The loader should have found all the relevant paths.\n@@ -762,7 +766,7 @@ func (pkg *loadPkg) stackText() string {\n }\n \n // why returns the text to use in \"go mod why\" output about the given package.\n-// It is less ornate than the stackText but conatins the same information.\n+// It is less ornate than the stackText but contains the same information.\n func (pkg *loadPkg) why() string {\n \tvar buf strings.Builder\n \tvar stack []*loadPkg\n@@ -811,7 +815,7 @@ func WhyDepth(path string) int {\n // a module.Version with Path == \"\".\n func Replacement(mod module.Version) module.Version {\n \tif modFile == nil {\n-\t\t// Happens during testing.\n+\t\t// Happens during testing and if invoking 'go get' or 'go list' outside a module.\n \t\treturn module.Version{}\n \t}\n \n@@ -888,7 +892,7 @@ func readVendorList() {\n \tvendorOnce.Do(func() {\n \t\tvendorList = nil\n \t\tvendorMap = make(map[string]module.Version)\n-\t\tdata, _ := ioutil.ReadFile(filepath.Join(ModRoot, \"vendor/modules.txt\"))\n+\t\tdata, _ := ioutil.ReadFile(filepath.Join(ModRoot(), \"vendor/modules.txt\"))\n \t\tvar m module.Version\n \t\tfor _, line := range strings.Split(string(data), \"\\n\") {\n \t\t\tif strings.HasPrefix(line, \"# \") {\n@@ -918,7 +922,7 @@ func (r *mvsReqs) modFileToList(f *modfile.File) []module.Version {\n \n func (r *mvsReqs) required(mod module.Version) ([]module.Version, error) {\n \tif mod == Target {\n-\t\tif modFile.Go != nil {\n+\t\tif modFile != nil && modFile.Go != nil {\n \t\t\tr.versions.LoadOrStore(mod, modFile.Go.Version)\n \t\t}\n \t\tvar list []module.Version\n@@ -938,7 +942,7 @@ func (r *mvsReqs) required(mod module.Version) ([]module.Version, error) {\n \t\t\t// TODO: need to slip the new version into the tags list etc.\n \t\t\tdir := repl.Path\n \t\t\tif !filepath.IsAbs(dir) {\n-\t\t\t\tdir = filepath.Join(ModRoot, dir)\n+\t\t\t\tdir = filepath.Join(ModRoot(), dir)\n \t\t\t}\n \t\t\tgomod := filepath.Join(dir, \"go.mod\")\n \t\t\tdata, err := ioutil.ReadFile(gomod)\n@@ -1053,13 +1057,13 @@ func (*mvsReqs) next(m module.Version) (module.Version, error) {\n \n func fetch(mod module.Version) (dir string, isLocal bool, err error) {\n \tif mod == Target {\n-\t\treturn ModRoot, true, nil\n+\t\treturn ModRoot(), true, nil\n \t}\n \tif r := Replacement(mod); r.Path != \"\" {\n \t\tif r.Version == \"\" {\n \t\t\tdir = r.Path\n \t\t\tif !filepath.IsAbs(dir) {\n-\t\t\t\tdir = filepath.Join(ModRoot, dir)\n+\t\t\t\tdir = filepath.Join(ModRoot(), dir)\n \t\t\t}\n \t\t\treturn dir, true, nil\n \t\t}"}, {"sha": "0856486c212c237e81be477c660e5f1ee8c28b24", "filename": "libgo/go/cmd/go/internal/modload/query.go", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -207,21 +207,23 @@ func matchSemverPrefix(p, v string) bool {\n // If multiple modules with revisions matching the query provide the requested\n // package, QueryPackage picks the one with the longest module path.\n //\n-// If the path is in the the main module and the query is \"latest\",\n+// If the path is in the main module and the query is \"latest\",\n // QueryPackage returns Target as the version.\n func QueryPackage(path, query string, allowed func(module.Version) bool) (module.Version, *modfetch.RevInfo, error) {\n-\tif _, ok := dirInModule(path, Target.Path, ModRoot, true); ok {\n-\t\tif query != \"latest\" {\n-\t\t\treturn module.Version{}, nil, fmt.Errorf(\"can't query specific version (%q) for package %s in the main module (%s)\", query, path, Target.Path)\n-\t\t}\n-\t\tif !allowed(Target) {\n-\t\t\treturn module.Version{}, nil, fmt.Errorf(\"internal error: package %s is in the main module (%s), but version is not allowed\", path, Target.Path)\n+\tif HasModRoot() {\n+\t\tif _, ok := dirInModule(path, Target.Path, modRoot, true); ok {\n+\t\t\tif query != \"latest\" {\n+\t\t\t\treturn module.Version{}, nil, fmt.Errorf(\"can't query specific version (%q) for package %s in the main module (%s)\", query, path, Target.Path)\n+\t\t\t}\n+\t\t\tif !allowed(Target) {\n+\t\t\t\treturn module.Version{}, nil, fmt.Errorf(\"internal error: package %s is in the main module (%s), but version is not allowed\", path, Target.Path)\n+\t\t\t}\n+\t\t\treturn Target, &modfetch.RevInfo{Version: Target.Version}, nil\n \t\t}\n-\t\treturn Target, &modfetch.RevInfo{Version: Target.Version}, nil\n \t}\n \n \tfinalErr := errMissing\n-\tfor p := path; p != \".\"; p = pathpkg.Dir(p) {\n+\tfor p := path; p != \".\" && p != \"/\"; p = pathpkg.Dir(p) {\n \t\tinfo, err := Query(p, query, allowed)\n \t\tif err != nil {\n \t\t\tif _, ok := err.(*codehost.VCSError); ok {"}, {"sha": "9b07383217175cafb4eee83c7db5b4cec2b22faf", "filename": "libgo/go/cmd/go/internal/modload/query_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery_test.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -132,7 +132,7 @@ func TestQuery(t *testing.T) {\n \t\t\tok, _ := path.Match(allow, m.Version)\n \t\t\treturn ok\n \t\t}\n-\t\tt.Run(strings.Replace(tt.path, \"/\", \"_\", -1)+\"/\"+tt.query+\"/\"+allow, func(t *testing.T) {\n+\t\tt.Run(strings.ReplaceAll(tt.path, \"/\", \"_\")+\"/\"+tt.query+\"/\"+allow, func(t *testing.T) {\n \t\t\tinfo, err := Query(tt.path, tt.query, allowed)\n \t\t\tif tt.err != \"\" {\n \t\t\t\tif err != nil && err.Error() == tt.err {"}, {"sha": "7d8852d01d7f7e172d3800b643ebfbf637c103e1", "filename": "libgo/go/cmd/go/internal/modload/search.go", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fsearch.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fsearch.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fsearch.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -118,7 +118,10 @@ func matchPackages(pattern string, tags map[string]bool, useStd bool, modules []\n \t\t}\n \t\tvar root string\n \t\tif mod.Version == \"\" {\n-\t\t\troot = ModRoot\n+\t\t\tif !HasModRoot() {\n+\t\t\t\tcontinue // If there is no main module, we can't search in it.\n+\t\t\t}\n+\t\t\troot = ModRoot()\n \t\t} else {\n \t\t\tvar err error\n \t\t\troot, _, err = fetch(mod)"}, {"sha": "663b24a68d7924a37d3f6dbc85afc8c59e000af7", "filename": "libgo/go/cmd/go/internal/modload/testgo.go", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Ftestgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Ftestgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Ftestgo.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -1,11 +1,11 @@\n-// Copyright 2014 The Go Authors. All rights reserved.\n+// Copyright 2018 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build race\n+//+build testgo\n \n-package http\n+package modload\n \n func init() {\n-\traceEnabled = true\n+\tprintStackInDie = true\n }", "previous_filename": "libgo/go/net/http/race.go"}, {"sha": "481a90b1c46d3548545f0be070fe7cca22160ccf", "filename": "libgo/go/cmd/go/internal/module/module.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodule%2Fmodule.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodule%2Fmodule.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodule%2Fmodule.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -226,7 +226,7 @@ func checkElem(elem string, fileName bool) error {\n \t}\n \tfor _, bad := range badWindowsNames {\n \t\tif strings.EqualFold(bad, short) {\n-\t\t\treturn fmt.Errorf(\"disallowed path element %q\", elem)\n+\t\t\treturn fmt.Errorf(\"%q disallowed as path element component on Windows\", short)\n \t\t}\n \t}\n \treturn nil\n@@ -284,7 +284,7 @@ func SplitPathVersion(path string) (prefix, pathMajor string, ok bool) {\n \t\t}\n \t\ti--\n \t}\n-\tif i <= 1 || path[i-1] != 'v' || path[i-2] != '/' {\n+\tif i <= 1 || i == len(path) || path[i-1] != 'v' || path[i-2] != '/' {\n \t\treturn path, \"\", true\n \t}\n \tprefix, pathMajor = path[:i-2], path[i-2:]"}, {"sha": "b40bd03dfa65bc679c3f9044b4ca723a57da98d2", "filename": "libgo/go/cmd/go/internal/module/module_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodule%2Fmodule_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodule%2Fmodule_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodule%2Fmodule_test.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -214,6 +214,7 @@ var splitPathVersionTests = []struct {\n \t{\"x.y/z\", \"\"},\n \t{\"x.y/z\", \"/v2\"},\n \t{\"x.y/z\", \"/v3\"},\n+\t{\"x.y/v\", \"\"},\n \t{\"gopkg.in/yaml\", \".v0\"},\n \t{\"gopkg.in/yaml\", \".v1\"},\n \t{\"gopkg.in/yaml\", \".v2\"},"}, {"sha": "aa109693f307e5b30e6deae93c81f1e238bc818e", "filename": "libgo/go/cmd/go/internal/mvs/mvs.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fmvs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fmvs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fmvs.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -68,6 +68,7 @@ func (e *MissingModuleError) Error() string {\n }\n \n // BuildList returns the build list for the target module.\n+// The first element is the target itself, with the remainder of the list sorted by path.\n func BuildList(target module.Version, reqs Reqs) ([]module.Version, error) {\n \treturn buildList(target, reqs, nil)\n }"}, {"sha": "8f59e1a57732579bfc547e49b227955f300cdba5", "filename": "libgo/go/cmd/go/internal/renameio/renameio.go", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frenameio%2Frenameio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frenameio%2Frenameio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frenameio%2Frenameio.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -0,0 +1,63 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package renameio writes files atomically by renaming temporary files.\n+package renameio\n+\n+import (\n+\t\"bytes\"\n+\t\"io\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path/filepath\"\n+)\n+\n+const patternSuffix = \"*.tmp\"\n+\n+// Pattern returns a glob pattern that matches the unrenamed temporary files\n+// created when writing to filename.\n+func Pattern(filename string) string {\n+\treturn filepath.Join(filepath.Dir(filename), filepath.Base(filename)+patternSuffix)\n+}\n+\n+// WriteFile is like ioutil.WriteFile, but first writes data to an arbitrary\n+// file in the same directory as filename, then renames it atomically to the\n+// final name.\n+//\n+// That ensures that the final location, if it exists, is always a complete file.\n+func WriteFile(filename string, data []byte) (err error) {\n+\treturn WriteToFile(filename, bytes.NewReader(data))\n+}\n+\n+// WriteToFile is a variant of WriteFile that accepts the data as an io.Reader\n+// instead of a slice.\n+func WriteToFile(filename string, data io.Reader) (err error) {\n+\tf, err := ioutil.TempFile(filepath.Dir(filename), filepath.Base(filename)+patternSuffix)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tdefer func() {\n+\t\t// Only call os.Remove on f.Name() if we failed to rename it: otherwise,\n+\t\t// some other process may have created a new file with the same name after\n+\t\t// that.\n+\t\tif err != nil {\n+\t\t\tf.Close()\n+\t\t\tos.Remove(f.Name())\n+\t\t}\n+\t}()\n+\n+\tif _, err := io.Copy(f, data); err != nil {\n+\t\treturn err\n+\t}\n+\t// Sync the file before renaming it: otherwise, after a crash the reader may\n+\t// observe a 0-length file instead of the actual contents.\n+\t// See https://golang.org/issue/22397#issuecomment-380831736.\n+\tif err := f.Sync(); err != nil {\n+\t\treturn err\n+\t}\n+\tif err := f.Close(); err != nil {\n+\t\treturn err\n+\t}\n+\treturn os.Rename(f.Name(), filename)\n+}"}, {"sha": "feccf23b2782a868fbf822be029935a959d765ff", "filename": "libgo/go/cmd/go/internal/run/run.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frun%2Frun.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frun%2Frun.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frun%2Frun.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -78,6 +78,9 @@ func runRun(cmd *base.Command, args []string) {\n \t\tp = load.GoFilesPackage(files)\n \t} else if len(args) > 0 && !strings.HasPrefix(args[0], \"-\") {\n \t\tpkgs := load.PackagesAndErrors(args[:1])\n+\t\tif len(pkgs) == 0 {\n+\t\t\tbase.Fatalf(\"go run: no packages loaded from %s\", args[0])\n+\t\t}\n \t\tif len(pkgs) > 1 {\n \t\t\tvar names []string\n \t\t\tfor _, p := range pkgs {"}, {"sha": "0ca60e73497e2188a424dbb0fcbdfe8a0bb325ca", "filename": "libgo/go/cmd/go/internal/search/search.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsearch%2Fsearch.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsearch%2Fsearch.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsearch%2Fsearch.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -275,7 +275,7 @@ func MatchPattern(pattern string) func(name string) bool {\n \tcase strings.HasSuffix(re, `/\\.\\.\\.`):\n \t\tre = strings.TrimSuffix(re, `/\\.\\.\\.`) + `(/\\.\\.\\.)?`\n \t}\n-\tre = strings.Replace(re, `\\.\\.\\.`, `[^`+vendorChar+`]*`, -1)\n+\tre = strings.ReplaceAll(re, `\\.\\.\\.`, `[^`+vendorChar+`]*`)\n \n \treg := regexp.MustCompile(`^` + re + `$`)\n \n@@ -353,7 +353,7 @@ func CleanPatterns(patterns []string) []string {\n \t\t// as a courtesy to Windows developers, rewrite \\ to /\n \t\t// in command-line arguments. Handles .\\... and so on.\n \t\tif filepath.Separator == '\\\\' {\n-\t\t\ta = strings.Replace(a, `\\`, `/`, -1)\n+\t\t\ta = strings.ReplaceAll(a, `\\`, `/`)\n \t\t}\n \n \t\t// Put argument in canonical form, but preserve leading ./."}, {"sha": "122e612dd4b8f0b62445a2430f73a04d0c229086", "filename": "libgo/go/cmd/go/internal/semver/semver.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsemver%2Fsemver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsemver%2Fsemver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsemver%2Fsemver.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -263,7 +263,7 @@ func parseBuild(v string) (t, rest string, ok bool) {\n \ti := 1\n \tstart := 1\n \tfor i < len(v) {\n-\t\tif !isIdentChar(v[i]) {\n+\t\tif !isIdentChar(v[i]) && v[i] != '.' {\n \t\t\treturn\n \t\t}\n \t\tif v[i] == '.' {"}, {"sha": "77025a44abd60a36f8e21eeb000b71f5e8d62409", "filename": "libgo/go/cmd/go/internal/semver/semver_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsemver%2Fsemver_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsemver%2Fsemver_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsemver%2Fsemver_test.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -44,6 +44,7 @@ var tests = []struct {\n \t{\"v1.2.3\", \"v1.2.3\"},\n \t{\"v1.2.3+meta\", \"v1.2.3\"},\n \t{\"v1.2.3+meta-pre\", \"v1.2.3\"},\n+\t{\"v1.2.3+meta-pre.sha.256a\", \"v1.2.3\"},\n }\n \n func TestIsValid(t *testing.T) {"}, {"sha": "332f31244154165d50cfd3ad82c12e4595e2c480", "filename": "libgo/go/cmd/go/internal/test/test.go", "status": "modified", "additions": 26, "deletions": 35, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -27,6 +27,7 @@ import (\n \t\"cmd/go/internal/cache\"\n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/load\"\n+\t\"cmd/go/internal/lockedfile\"\n \t\"cmd/go/internal/modload\"\n \t\"cmd/go/internal/str\"\n \t\"cmd/go/internal/work\"\n@@ -124,16 +125,6 @@ A cached test result is treated as executing in no time at all,\n so a successful package test result will be cached and reused\n regardless of -timeout setting.\n \n-` + strings.TrimSpace(testFlag1) + ` See 'go help testflag' for details.\n-\n-For more about build flags, see 'go help build'.\n-For more about specifying packages, see 'go help packages'.\n-\n-See also: go build, go vet.\n-`,\n-}\n-\n-const testFlag1 = `\n In addition to the build flags, the flags handled by 'go test' itself are:\n \n \t-args\n@@ -164,15 +155,13 @@ In addition to the build flags, the flags handled by 'go test' itself are:\n \t    The test still runs (unless -c or -i is specified).\n \n The test binary also accepts flags that control execution of the test; these\n-flags are also accessible by 'go test'.\n-`\n-\n-// Usage prints the usage message for 'go test -h' and exits.\n-func Usage() {\n-\tos.Stderr.WriteString(\"usage: \" + testUsage + \"\\n\\n\" +\n-\t\tstrings.TrimSpace(testFlag1) + \"\\n\\n\\t\" +\n-\t\tstrings.TrimSpace(testFlag2) + \"\\n\")\n-\tos.Exit(2)\n+flags are also accessible by 'go test'. See 'go help testflag' for details.\n+\n+For more about build flags, see 'go help build'.\n+For more about specifying packages, see 'go help packages'.\n+\n+See also: go build, go vet.\n+`,\n }\n \n var HelpTestflag = &base.Command{\n@@ -190,11 +179,6 @@ options of pprof control how the information is presented.\n The following flags are recognized by the 'go test' command and\n control the execution of any test:\n \n-\t` + strings.TrimSpace(testFlag2) + `\n-`,\n-}\n-\n-const testFlag2 = `\n \t-bench regexp\n \t    Run only those benchmarks matching a regular expression.\n \t    By default, no benchmarks are run.\n@@ -212,6 +196,8 @@ const testFlag2 = `\n \t    Run enough iterations of each benchmark to take t, specified\n \t    as a time.Duration (for example, -benchtime 1h30s).\n \t    The default is 1 second (1s).\n+\t    The special syntax Nx means to run the benchmark N times\n+\t    (for example, -benchtime 100x).\n \n \t-count n\n \t    Run each test and benchmark n times (default 1).\n@@ -412,7 +398,8 @@ In the first example, the -x and the second -v are passed through to the\n test binary unchanged and with no effect on the go command itself.\n In the second example, the argument math is passed through to the test\n binary, instead of being interpreted as the package list.\n-`\n+`,\n+}\n \n var HelpTestfunc = &base.Command{\n \tUsageLine: \"testfunc\",\n@@ -530,7 +517,7 @@ var testVetFlags = []string{\n func runTest(cmd *base.Command, args []string) {\n \tmodload.LoadTests = true\n \n-\tpkgArgs, testArgs = testFlags(args)\n+\tpkgArgs, testArgs = testFlags(cmd.Usage, args)\n \n \twork.FindExecCmd() // initialize cached result\n \n@@ -580,7 +567,7 @@ func runTest(cmd *base.Command, args []string) {\n \t// (We implement go clean -testcache by writing an expiration date\n \t// instead of searching out and deleting test result cache entries.)\n \tif dir := cache.DefaultDir(); dir != \"off\" {\n-\t\tif data, _ := ioutil.ReadFile(filepath.Join(dir, \"testexpire.txt\")); len(data) > 0 && data[len(data)-1] == '\\n' {\n+\t\tif data, _ := lockedfile.Read(filepath.Join(dir, \"testexpire.txt\")); len(data) > 0 && data[len(data)-1] == '\\n' {\n \t\t\tif t, err := strconv.ParseInt(string(data[:len(data)-1]), 10, 64); err == nil {\n \t\t\t\ttestCacheExpire = time.Unix(0, t)\n \t\t\t}\n@@ -885,15 +872,19 @@ func builderTest(b *work.Builder, p *load.Package) (buildAction, runAction, prin\n \t\t\t\ttarget = filepath.Join(base.Cwd, target)\n \t\t\t}\n \t\t}\n-\t\tpmain.Target = target\n-\t\tinstallAction = &work.Action{\n-\t\t\tMode:    \"test build\",\n-\t\t\tFunc:    work.BuildInstallFunc,\n-\t\t\tDeps:    []*work.Action{buildAction},\n-\t\t\tPackage: pmain,\n-\t\t\tTarget:  target,\n+\t\tif target == os.DevNull {\n+\t\t\trunAction = buildAction\n+\t\t} else {\n+\t\t\tpmain.Target = target\n+\t\t\tinstallAction = &work.Action{\n+\t\t\t\tMode:    \"test build\",\n+\t\t\t\tFunc:    work.BuildInstallFunc,\n+\t\t\t\tDeps:    []*work.Action{buildAction},\n+\t\t\t\tPackage: pmain,\n+\t\t\t\tTarget:  target,\n+\t\t\t}\n+\t\t\trunAction = installAction // make sure runAction != nil even if not running test\n \t\t}\n-\t\trunAction = installAction // make sure runAction != nil even if not running test\n \t}\n \tvar vetRunAction *work.Action\n \tif testC {"}, {"sha": "ebcf49a4e9c92df667e8b7d29d1a05f2d435f094", "filename": "libgo/go/cmd/go/internal/test/testflag.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftestflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftestflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftestflag.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -87,7 +87,7 @@ func init() {\n // to allow both\n //\tgo test fmt -custom-flag-for-fmt-test\n //\tgo test -x math\n-func testFlags(args []string) (packageNames, passToTest []string) {\n+func testFlags(usage func(), args []string) (packageNames, passToTest []string) {\n \targs = str.StringList(cmdflag.FindGOFLAGS(testFlagDefn), args)\n \tinPkg := false\n \tvar explicitArgs []string\n@@ -108,7 +108,7 @@ func testFlags(args []string) (packageNames, passToTest []string) {\n \t\t\tinPkg = false\n \t\t}\n \n-\t\tf, value, extraWord := cmdflag.Parse(cmd, testFlagDefn, args, i)\n+\t\tf, value, extraWord := cmdflag.Parse(cmd, usage, testFlagDefn, args, i)\n \t\tif f == nil {\n \t\t\t// This is a flag we do not know; we must assume\n \t\t\t// that any args we see after this might be flag"}, {"sha": "3d828a2a4a4c28fbab95969f496aa13090d7ee32", "filename": "libgo/go/cmd/go/internal/vet/vet.go", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvet.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvet.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvet.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -16,17 +16,26 @@ import (\n var CmdVet = &base.Command{\n \tRun:         runVet,\n \tCustomFlags: true,\n-\tUsageLine:   \"go vet [-n] [-x] [build flags] [vet flags] [packages]\",\n+\tUsageLine:   \"go vet [-n] [-x] [-vettool prog] [build flags] [vet flags] [packages]\",\n \tShort:       \"report likely mistakes in packages\",\n \tLong: `\n Vet runs the Go vet command on the packages named by the import paths.\n \n For more about vet and its flags, see 'go doc cmd/vet'.\n For more about specifying packages, see 'go help packages'.\n+For a list of checkers and their flags, see 'go tool vet help'.\n+For details of a specific checker such as 'printf', see 'go tool vet help printf'.\n \n The -n flag prints commands that would be executed.\n The -x flag prints commands as they are executed.\n \n+The -vettool=prog flag selects a different analysis tool with alternative\n+or additional checks.\n+For example, the 'shadow' analyzer can be built and run using these commands:\n+\n+  go install golang.org/x/tools/go/analysis/passes/shadow/cmd/shadow\n+  go vet -vettool=$(which shadow)\n+\n The build flags supported by go vet are those that control package resolution\n and execution, such as -n, -x, -v, -tags, and -toolexec.\n For more about these flags, see 'go help build'.\n@@ -38,7 +47,7 @@ See also: go fmt, go fix.\n func runVet(cmd *base.Command, args []string) {\n \tmodload.LoadTests = true\n \n-\tvetFlags, pkgArgs := vetFlags(args)\n+\tvetFlags, pkgArgs := vetFlags(vetUsage, args)\n \n \twork.BuildInit()\n \twork.VetFlags = vetFlags"}, {"sha": "37342f41633420dd90d530f006021b24519ed029", "filename": "libgo/go/cmd/go/internal/vet/vetflag.go", "status": "modified", "additions": 115, "deletions": 48, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvetflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvetflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvetflag.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -5,9 +5,14 @@\n package vet\n \n import (\n+\t\"bytes\"\n+\t\"encoding/json\"\n \t\"flag\"\n \t\"fmt\"\n+\t\"log\"\n \t\"os\"\n+\t\"os/exec\"\n+\t\"path/filepath\"\n \t\"strings\"\n \n \t\"cmd/go/internal/base\"\n@@ -16,72 +21,116 @@ import (\n \t\"cmd/go/internal/work\"\n )\n \n-const cmd = \"vet\"\n-\n-// vetFlagDefn is the set of flags we process.\n-var vetFlagDefn = []*cmdflag.Defn{\n-\t// Note: Some flags, in particular -tags and -v, are known to\n-\t// vet but also defined as build flags. This works fine, so we\n-\t// don't define them here but use AddBuildFlags to init them.\n-\t// However some, like -x, are known to the build but not\n-\t// to vet. We handle them in vetFlags.\n-\n-\t// local.\n-\t{Name: \"all\", BoolVar: new(bool), PassToTest: true},\n-\t{Name: \"asmdecl\", BoolVar: new(bool), PassToTest: true},\n-\t{Name: \"assign\", BoolVar: new(bool), PassToTest: true},\n-\t{Name: \"atomic\", BoolVar: new(bool), PassToTest: true},\n-\t{Name: \"bool\", BoolVar: new(bool), PassToTest: true},\n-\t{Name: \"buildtags\", BoolVar: new(bool), PassToTest: true},\n-\t{Name: \"cgocall\", BoolVar: new(bool), PassToTest: true},\n-\t{Name: \"composites\", BoolVar: new(bool), PassToTest: true},\n-\t{Name: \"copylocks\", BoolVar: new(bool), PassToTest: true},\n-\t{Name: \"httpresponse\", BoolVar: new(bool), PassToTest: true},\n-\t{Name: \"lostcancel\", BoolVar: new(bool), PassToTest: true},\n-\t{Name: \"methods\", BoolVar: new(bool), PassToTest: true},\n-\t{Name: \"nilfunc\", BoolVar: new(bool), PassToTest: true},\n-\t{Name: \"printf\", BoolVar: new(bool), PassToTest: true},\n-\t{Name: \"printfuncs\", PassToTest: true},\n-\t{Name: \"rangeloops\", BoolVar: new(bool), PassToTest: true},\n-\t{Name: \"shadow\", BoolVar: new(bool), PassToTest: true},\n-\t{Name: \"shadowstrict\", BoolVar: new(bool), PassToTest: true},\n-\t{Name: \"shift\", BoolVar: new(bool), PassToTest: true},\n-\t{Name: \"source\", BoolVar: new(bool), PassToTest: true},\n-\t{Name: \"structtags\", BoolVar: new(bool), PassToTest: true},\n-\t{Name: \"tests\", BoolVar: new(bool), PassToTest: true},\n-\t{Name: \"unreachable\", BoolVar: new(bool), PassToTest: true},\n-\t{Name: \"unsafeptr\", BoolVar: new(bool), PassToTest: true},\n-\t{Name: \"unusedfuncs\", PassToTest: true},\n-\t{Name: \"unusedresult\", BoolVar: new(bool), PassToTest: true},\n-\t{Name: \"unusedstringmethods\", PassToTest: true},\n-}\n+// go vet flag processing\n+//\n+// We query the flags of the tool specified by -vettool and accept any\n+// of those flags plus any flag valid for 'go build'. The tool must\n+// support -flags, which prints a description of its flags in JSON to\n+// stdout.\n \n-var vetTool string\n+// vetTool specifies the vet command to run.\n+// Any tool that supports the (still unpublished) vet\n+// command-line protocol may be supplied; see\n+// golang.org/x/tools/go/analysis/unitchecker for one\n+// implementation. It is also used by tests.\n+//\n+// The default behavior (vetTool==\"\") runs 'go tool vet'.\n+//\n+var vetTool string // -vettool\n \n-// add build flags to vetFlagDefn.\n func init() {\n-\tcmdflag.AddKnownFlags(\"vet\", vetFlagDefn)\n+\t// Extract -vettool by ad hoc flag processing:\n+\t// its value is needed even before we can declare\n+\t// the flags available during main flag processing.\n+\tfor i, arg := range os.Args {\n+\t\tif arg == \"-vettool\" || arg == \"--vettool\" {\n+\t\t\tif i+1 >= len(os.Args) {\n+\t\t\t\tlog.Fatalf(\"%s requires a filename\", arg)\n+\t\t\t}\n+\t\t\tvetTool = os.Args[i+1]\n+\t\t\tbreak\n+\t\t} else if strings.HasPrefix(arg, \"-vettool=\") ||\n+\t\t\tstrings.HasPrefix(arg, \"--vettool=\") {\n+\t\t\tvetTool = arg[strings.IndexByte(arg, '=')+1:]\n+\t\t\tbreak\n+\t\t}\n+\t}\n+}\n+\n+// vetFlags processes the command line, splitting it at the first non-flag\n+// into the list of flags and list of packages.\n+func vetFlags(usage func(), args []string) (passToVet, packageNames []string) {\n+\t// Query the vet command for its flags.\n+\ttool := vetTool\n+\tif tool != \"\" {\n+\t\tvar err error\n+\t\ttool, err = filepath.Abs(tool)\n+\t\tif err != nil {\n+\t\t\tlog.Fatal(err)\n+\t\t}\n+\t} else {\n+\t\ttool = base.Tool(\"vet\")\n+\t}\n+\tout := new(bytes.Buffer)\n+\tvetcmd := exec.Command(tool, \"-flags\")\n+\tvetcmd.Stdout = out\n+\tif err := vetcmd.Run(); err != nil {\n+\t\tfmt.Fprintf(os.Stderr, \"go vet: can't execute %s -flags: %v\\n\", tool, err)\n+\t\tos.Exit(2)\n+\t}\n+\tvar analysisFlags []struct {\n+\t\tName  string\n+\t\tBool  bool\n+\t\tUsage string\n+\t}\n+\tif err := json.Unmarshal(out.Bytes(), &analysisFlags); err != nil {\n+\t\tfmt.Fprintf(os.Stderr, \"go vet: can't unmarshal JSON from %s -flags: %v\", tool, err)\n+\t\tos.Exit(2)\n+\t}\n+\n+\t// Add vet's flags to vetflagDefn.\n+\t//\n+\t// Some flags, in particular -tags and -v, are known to vet but\n+\t// also defined as build flags. This works fine, so we don't\n+\t// define them here but use AddBuildFlags to init them.\n+\t// However some, like -x, are known to the build but not to vet.\n+\tvar vetFlagDefn []*cmdflag.Defn\n+\tfor _, f := range analysisFlags {\n+\t\tswitch f.Name {\n+\t\tcase \"tags\", \"v\":\n+\t\t\tcontinue\n+\t\t}\n+\t\tdefn := &cmdflag.Defn{\n+\t\t\tName:       f.Name,\n+\t\t\tPassToTest: true,\n+\t\t}\n+\t\tif f.Bool {\n+\t\t\tdefn.BoolVar = new(bool)\n+\t\t}\n+\t\tvetFlagDefn = append(vetFlagDefn, defn)\n+\t}\n+\n+\t// Add build flags to vetFlagDefn.\n \tvar cmd base.Command\n \twork.AddBuildFlags(&cmd)\n-\tcmd.Flag.StringVar(&vetTool, \"vettool\", \"\", \"path to vet tool binary\") // for cmd/vet tests; undocumented for now\n+\t// This flag declaration is a placeholder:\n+\t// -vettool is actually parsed by the init function above.\n+\tcmd.Flag.StringVar(new(string), \"vettool\", \"\", \"path to vet tool binary\")\n \tcmd.Flag.VisitAll(func(f *flag.Flag) {\n \t\tvetFlagDefn = append(vetFlagDefn, &cmdflag.Defn{\n \t\t\tName:  f.Name,\n \t\t\tValue: f.Value,\n \t\t})\n \t})\n-}\n \n-// vetFlags processes the command line, splitting it at the first non-flag\n-// into the list of flags and list of packages.\n-func vetFlags(args []string) (passToVet, packageNames []string) {\n+\t// Process args.\n \targs = str.StringList(cmdflag.FindGOFLAGS(vetFlagDefn), args)\n \tfor i := 0; i < len(args); i++ {\n \t\tif !strings.HasPrefix(args[i], \"-\") {\n \t\t\treturn args[:i], args[i:]\n \t\t}\n \n-\t\tf, value, extraWord := cmdflag.Parse(cmd, vetFlagDefn, args, i)\n+\t\tf, value, extraWord := cmdflag.Parse(\"vet\", usage, vetFlagDefn, args, i)\n \t\tif f == nil {\n \t\t\tfmt.Fprintf(os.Stderr, \"vet: flag %q not defined\\n\", args[i])\n \t\t\tfmt.Fprintf(os.Stderr, \"Run \\\"go help vet\\\" for more information\\n\")\n@@ -117,3 +166,21 @@ func vetFlags(args []string) (passToVet, packageNames []string) {\n \t}\n \treturn args, nil\n }\n+\n+var vetUsage func()\n+\n+func init() { vetUsage = usage } // break initialization cycle\n+\n+func usage() {\n+\tfmt.Fprintf(os.Stderr, \"usage: %s\\n\", CmdVet.UsageLine)\n+\tfmt.Fprintf(os.Stderr, \"Run 'go help %s' for details.\\n\", CmdVet.LongName())\n+\n+\t// This part is additional to what (*Command).Usage does:\n+\tcmd := \"go tool vet\"\n+\tif vetTool != \"\" {\n+\t\tcmd = vetTool\n+\t}\n+\tfmt.Fprintf(os.Stderr, \"Run '%s -help' for the vet tool's flags.\\n\", cmd)\n+\n+\tos.Exit(2)\n+}"}, {"sha": "64934f1d506dbfa4142550a57656a8816dec75c4", "filename": "libgo/go/cmd/go/internal/web2/web.go", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb2%2Fweb.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb2%2Fweb.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb2%2Fweb.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -7,11 +7,13 @@ package web2\n import (\n \t\"bytes\"\n \t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/cfg\"\n \t\"encoding/json\"\n \t\"flag\"\n \t\"fmt\"\n \t\"io\"\n \t\"io/ioutil\"\n+\t\"log\"\n \t\"net/http\"\n \t\"os\"\n \t\"path/filepath\"\n@@ -187,10 +189,10 @@ func SetHTTPDoForTesting(do func(*http.Request) (*http.Response, error)) {\n }\n \n func Get(url string, options ...Option) error {\n-\tif TraceGET || webstack {\n-\t\tprintln(\"GET\", url)\n+\tif TraceGET || webstack || cfg.BuildV {\n+\t\tlog.Printf(\"Fetching %s\", url)\n \t\tif webstack {\n-\t\t\tprintln(string(debug.Stack()))\n+\t\t\tlog.Println(string(debug.Stack()))\n \t\t}\n \t}\n "}, {"sha": "d0d02117a73c57949e597f5a864a069ed2fbc50a", "filename": "libgo/go/cmd/go/internal/work/action.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Faction.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Faction.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Faction.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -11,9 +11,9 @@ import (\n \t\"bytes\"\n \t\"container/heap\"\n \t\"debug/elf\"\n-\t\"debug/xcoff\"\n \t\"encoding/json\"\n \t\"fmt\"\n+\t\"internal/xcoff\"\n \t\"io/ioutil\"\n \t\"os\"\n \t\"path/filepath\""}, {"sha": "145b87513a9166aecb9d9c7b7efd690425f3b1b3", "filename": "libgo/go/cmd/go/internal/work/build.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -99,7 +99,7 @@ and test commands:\n \t\tlink against shared libraries previously created with\n \t\t-buildmode=shared.\n \t-mod mode\n-\t\tmodule download mode to use: readonly, release, or vendor.\n+\t\tmodule download mode to use: readonly or vendor.\n \t\tSee 'go help modules' for more.\n \t-pkgdir dir\n \t\tinstall and load all packages from dir instead of the usual locations.\n@@ -398,10 +398,10 @@ func libname(args []string, pkgs []*load.Package) (string, error) {\n \t\t\t\t\targ = bp.ImportPath\n \t\t\t\t}\n \t\t\t}\n-\t\t\tappendName(strings.Replace(arg, \"/\", \"-\", -1))\n+\t\t\tappendName(strings.ReplaceAll(arg, \"/\", \"-\"))\n \t\t} else {\n \t\t\tfor _, pkg := range pkgs {\n-\t\t\t\tappendName(strings.Replace(pkg.ImportPath, \"/\", \"-\", -1))\n+\t\t\t\tappendName(strings.ReplaceAll(pkg.ImportPath, \"/\", \"-\"))\n \t\t\t}\n \t\t}\n \t} else if haveNonMeta { // have both meta package and a non-meta one"}, {"sha": "ef95a408ca31bbc7fddbcef31aac019853bc41fe", "filename": "libgo/go/cmd/go/internal/work/build_test.go", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild_test.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -227,6 +227,8 @@ func TestRespectSetgidDir(t *testing.T) {\n \t\tif runtime.GOARCH == \"arm\" || runtime.GOARCH == \"arm64\" {\n \t\t\tt.Skip(\"can't set SetGID bit with chmod on iOS\")\n \t\t}\n+\tcase \"windows\", \"plan9\", \"js\":\n+\t\tt.Skip(\"chown/chmod setgid are not supported on Windows, Plan 9, or JS\")\n \t}\n \n \tvar b Builder\n@@ -245,11 +247,13 @@ func TestRespectSetgidDir(t *testing.T) {\n \t}\n \tdefer os.RemoveAll(setgiddir)\n \n-\tif runtime.GOOS == \"freebsd\" {\n-\t\terr = os.Chown(setgiddir, os.Getuid(), os.Getgid())\n-\t\tif err != nil {\n-\t\t\tt.Fatal(err)\n-\t\t}\n+\t// BSD mkdir(2) inherits the parent directory group, and other platforms\n+\t// can inherit the parent directory group via setgid. The test setup (chmod\n+\t// setgid) will fail if the process does not have the group permission to\n+\t// the new temporary directory.\n+\terr = os.Chown(setgiddir, os.Getuid(), os.Getgid())\n+\tif err != nil {\n+\t\tt.Fatal(err)\n \t}\n \n \t// Change setgiddir's permissions to include the SetGID bit."}, {"sha": "750bc3c6cdbe450e5c6e87bd953bd174a61ee974", "filename": "libgo/go/cmd/go/internal/work/buildid.go", "status": "modified", "additions": 10, "deletions": 49, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuildid.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuildid.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuildid.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -18,7 +18,6 @@ import (\n \t\"cmd/go/internal/load\"\n \t\"cmd/go/internal/str\"\n \t\"cmd/internal/buildid\"\n-\t\"cmd/internal/objabi\"\n )\n \n // Build IDs\n@@ -178,7 +177,8 @@ func (b *Builder) toolID(name string) string {\n \tpath := base.Tool(name)\n \tdesc := \"go tool \" + name\n \n-\t// Special case: undocumented -vettool overrides usual vet, for testing vet.\n+\t// Special case: undocumented -vettool overrides usual vet,\n+\t// for testing vet or supplying an alternative analysis tool.\n \tif name == \"vet\" && VetTool != \"\" {\n \t\tpath = VetTool\n \t\tdesc = VetTool\n@@ -207,11 +207,6 @@ func (b *Builder) toolID(name string) string {\n \t\tid = f[2]\n \t}\n \n-\t// For the compiler, add any experiments.\n-\tif name == \"compile\" {\n-\t\tid += \" \" + objabi.Expstring()\n-\t}\n-\n \tb.id.Lock()\n \tb.toolIDCache[name] = id\n \tb.id.Unlock()\n@@ -322,13 +317,16 @@ func assemblerIsGas() bool {\n \t}\n }\n \n-// gccgoBuildIDELFFile creates an assembler file that records the\n-// action's build ID in an SHF_EXCLUDE section.\n-func (b *Builder) gccgoBuildIDELFFile(a *Action) (string, error) {\n+// gccgoBuildIDFile creates an assembler file that records the\n+// action's build ID in an SHF_EXCLUDE section for ELF files or\n+// in a CSECT in XCOFF files.\n+func (b *Builder) gccgoBuildIDFile(a *Action) (string, error) {\n \tsfile := a.Objdir + \"_buildid.s\"\n \n \tvar buf bytes.Buffer\n-\tif cfg.Goos != \"solaris\" || assemblerIsGas() {\n+\tif cfg.Goos == \"aix\" {\n+\t\tfmt.Fprintf(&buf, \"\\t.csect .go.buildid[XO]\\n\")\n+\t} else if cfg.Goos != \"solaris\" || assemblerIsGas() {\n \t\tfmt.Fprintf(&buf, \"\\t\"+`.section .go.buildid,\"e\"`+\"\\n\")\n \t} else if cfg.Goarch == \"sparc\" || cfg.Goarch == \"sparc64\" {\n \t\tfmt.Fprintf(&buf, \"\\t\"+`.section \".go.buildid\",#exclude`+\"\\n\")\n@@ -347,7 +345,7 @@ func (b *Builder) gccgoBuildIDELFFile(a *Action) (string, error) {\n \t\tfmt.Fprintf(&buf, \"%#02x\", a.buildID[i])\n \t}\n \tfmt.Fprintf(&buf, \"\\n\")\n-\tif cfg.Goos != \"solaris\" {\n+\tif cfg.Goos != \"solaris\" && cfg.Goos != \"aix\" {\n \t\tsecType := \"@progbits\"\n \t\tif cfg.Goarch == \"arm\" {\n \t\t\tsecType = \"%progbits\"\n@@ -372,43 +370,6 @@ func (b *Builder) gccgoBuildIDELFFile(a *Action) (string, error) {\n \treturn sfile, nil\n }\n \n-// gccgoBuildIDXCOFFFile creates an assembler file that records the\n-// action's build ID in a CSECT (AIX linker deletes CSECTs that are\n-// not referenced in the output file).\n-func (b *Builder) gccgoBuildIDXCOFFFile(a *Action) (string, error) {\n-\tsfile := a.Objdir + \"_buildid.s\"\n-\n-\tvar buf bytes.Buffer\n-\tfmt.Fprintf(&buf, \"\\t.csect .go.buildid[XO]\\n\")\n-\tfmt.Fprintf(&buf, \"\\t.byte \")\n-\tfor i := 0; i < len(a.buildID); i++ {\n-\t\tif i > 0 {\n-\t\t\tif i%8 == 0 {\n-\t\t\t\tfmt.Fprintf(&buf, \"\\n\\t.byte \")\n-\t\t\t} else {\n-\t\t\t\tfmt.Fprintf(&buf, \",\")\n-\t\t\t}\n-\t\t}\n-\t\tfmt.Fprintf(&buf, \"%#02x\", a.buildID[i])\n-\t}\n-\tfmt.Fprintf(&buf, \"\\n\")\n-\n-\tif cfg.BuildN || cfg.BuildX {\n-\t\tfor _, line := range bytes.Split(buf.Bytes(), []byte(\"\\n\")) {\n-\t\t\tb.Showcmd(\"\", \"echo '%s' >> %s\", line, sfile)\n-\t\t}\n-\t\tif cfg.BuildN {\n-\t\t\treturn sfile, nil\n-\t\t}\n-\t}\n-\n-\tif err := ioutil.WriteFile(sfile, buf.Bytes(), 0666); err != nil {\n-\t\treturn \"\", err\n-\t}\n-\n-\treturn sfile, nil\n-}\n-\n // buildID returns the build ID found in the given file.\n // If no build ID is found, buildID returns the content hash of the file.\n func (b *Builder) buildID(file string) string {"}, {"sha": "a4feb1d005863691fa2e136651e903cae560a79b", "filename": "libgo/go/cmd/go/internal/work/exec.go", "status": "modified", "additions": 126, "deletions": 46, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -377,7 +377,7 @@ func (b *Builder) build(a *Action) (err error) {\n \t\t\tif b.NeedExport {\n \t\t\t\tp.Export = a.built\n \t\t\t}\n-\t\t\tif need&needCompiledGoFiles != 0 && b.loadCachedGoFiles(a) {\n+\t\t\tif need&needCompiledGoFiles != 0 && b.loadCachedSrcFiles(a) {\n \t\t\t\tneed &^= needCompiledGoFiles\n \t\t\t}\n \t\t\t// Otherwise, we need to write files to a.Objdir (needVet, needCgoHdr).\n@@ -386,6 +386,13 @@ func (b *Builder) build(a *Action) (err error) {\n \t\t\tcached = true\n \t\t\ta.output = []byte{} // start saving output in case we miss any cache results\n \t\t}\n+\n+\t\t// Source files might be cached, even if the full action is not\n+\t\t// (e.g., go list -compiled -find).\n+\t\tif !cached && need&needCompiledGoFiles != 0 && b.loadCachedSrcFiles(a) {\n+\t\t\tneed &^= needCompiledGoFiles\n+\t\t}\n+\n \t\tif need == 0 {\n \t\t\treturn nil\n \t\t}\n@@ -434,10 +441,6 @@ func (b *Builder) build(a *Action) (err error) {\n \t\treturn fmt.Errorf(\"missing or invalid binary-only package; expected file %q\", a.Package.Target)\n \t}\n \n-\tif p.Module != nil && !allowedVersion(p.Module.GoVersion) {\n-\t\treturn fmt.Errorf(\"module requires Go %s\", p.Module.GoVersion)\n-\t}\n-\n \tif err := b.Mkdir(a.Objdir); err != nil {\n \t\treturn err\n \t}\n@@ -579,7 +582,13 @@ func (b *Builder) build(a *Action) (err error) {\n \t\t\tb.cacheCgoHdr(a)\n \t\t}\n \t}\n-\tb.cacheGofiles(a, gofiles)\n+\n+\tvar srcfiles []string // .go and non-.go\n+\tsrcfiles = append(srcfiles, gofiles...)\n+\tsrcfiles = append(srcfiles, sfiles...)\n+\tsrcfiles = append(srcfiles, cfiles...)\n+\tsrcfiles = append(srcfiles, cxxfiles...)\n+\tb.cacheSrcFiles(a, srcfiles)\n \n \t// Running cgo generated the cgo header.\n \tneed &^= needCgoHdr\n@@ -591,11 +600,11 @@ func (b *Builder) build(a *Action) (err error) {\n \n \t// Prepare Go vet config if needed.\n \tif need&needVet != 0 {\n-\t\tbuildVetConfig(a, gofiles)\n+\t\tbuildVetConfig(a, srcfiles)\n \t\tneed &^= needVet\n \t}\n \tif need&needCompiledGoFiles != 0 {\n-\t\tif !b.loadCachedGoFiles(a) {\n+\t\tif !b.loadCachedSrcFiles(a) {\n \t\t\treturn fmt.Errorf(\"failed to cache compiled Go files\")\n \t\t}\n \t\tneed &^= needCompiledGoFiles\n@@ -605,6 +614,12 @@ func (b *Builder) build(a *Action) (err error) {\n \t\treturn nil\n \t}\n \n+\t// Collect symbol ABI requirements from assembly.\n+\tsymabis, err := BuildToolchain.symabis(b, a, sfiles)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n \t// Prepare Go import config.\n \t// We start it off with a comment so it can't be empty, so icfg.Bytes() below is never nil.\n \t// It should never be empty anyway, but there have been bugs in the past that resulted\n@@ -638,14 +653,21 @@ func (b *Builder) build(a *Action) (err error) {\n \n \t// Compile Go.\n \tobjpkg := objdir + \"_pkg_.a\"\n-\tofile, out, err := BuildToolchain.gc(b, a, objpkg, icfg.Bytes(), len(sfiles) > 0, gofiles)\n+\tofile, out, err := BuildToolchain.gc(b, a, objpkg, icfg.Bytes(), symabis, len(sfiles) > 0, gofiles)\n \tif len(out) > 0 {\n-\t\tb.showOutput(a, a.Package.Dir, a.Package.Desc(), b.processOutput(out))\n+\t\toutput := b.processOutput(out)\n+\t\tif p.Module != nil && !allowedVersion(p.Module.GoVersion) {\n+\t\t\toutput += \"note: module requires Go \" + p.Module.GoVersion\n+\t\t}\n+\t\tb.showOutput(a, a.Package.Dir, a.Package.Desc(), output)\n \t\tif err != nil {\n \t\t\treturn errPrintedOutput\n \t\t}\n \t}\n \tif err != nil {\n+\t\tif p.Module != nil && !allowedVersion(p.Module.GoVersion) {\n+\t\t\tb.showOutput(a, a.Package.Dir, a.Package.Desc(), \"note: module requires Go \"+p.Module.GoVersion)\n+\t\t}\n \t\treturn err\n \t}\n \tif ofile != objpkg {\n@@ -701,18 +723,8 @@ func (b *Builder) build(a *Action) (err error) {\n \t// This is read by readGccgoArchive in cmd/internal/buildid/buildid.go.\n \tif a.buildID != \"\" && cfg.BuildToolchainName == \"gccgo\" {\n \t\tswitch cfg.Goos {\n-\t\tcase \"android\", \"dragonfly\", \"freebsd\", \"linux\", \"netbsd\", \"openbsd\", \"solaris\":\n-\t\t\tasmfile, err := b.gccgoBuildIDELFFile(a)\n-\t\t\tif err != nil {\n-\t\t\t\treturn err\n-\t\t\t}\n-\t\t\tofiles, err := BuildToolchain.asm(b, a, []string{asmfile})\n-\t\t\tif err != nil {\n-\t\t\t\treturn err\n-\t\t\t}\n-\t\t\tobjects = append(objects, ofiles...)\n-\t\tcase \"aix\":\n-\t\t\tasmfile, err := b.gccgoBuildIDXCOFFFile(a)\n+\t\tcase \"aix\", \"android\", \"dragonfly\", \"freebsd\", \"linux\", \"netbsd\", \"openbsd\", \"solaris\":\n+\t\t\tasmfile, err := b.gccgoBuildIDFile(a)\n \t\t\tif err != nil {\n \t\t\t\treturn err\n \t\t\t}\n@@ -797,13 +809,13 @@ func (b *Builder) loadCachedCgoHdr(a *Action) bool {\n \treturn err == nil\n }\n \n-func (b *Builder) cacheGofiles(a *Action, gofiles []string) {\n+func (b *Builder) cacheSrcFiles(a *Action, srcfiles []string) {\n \tc := cache.Default()\n \tif c == nil {\n \t\treturn\n \t}\n \tvar buf bytes.Buffer\n-\tfor _, file := range gofiles {\n+\tfor _, file := range srcfiles {\n \t\tif !strings.HasPrefix(file, a.Objdir) {\n \t\t\t// not generated\n \t\t\tbuf.WriteString(\"./\")\n@@ -818,42 +830,42 @@ func (b *Builder) cacheGofiles(a *Action, gofiles []string) {\n \t\t\treturn\n \t\t}\n \t}\n-\tc.PutBytes(cache.Subkey(a.actionID, \"gofiles\"), buf.Bytes())\n+\tc.PutBytes(cache.Subkey(a.actionID, \"srcfiles\"), buf.Bytes())\n }\n \n func (b *Builder) loadCachedVet(a *Action) bool {\n \tc := cache.Default()\n \tif c == nil {\n \t\treturn false\n \t}\n-\tlist, _, err := c.GetBytes(cache.Subkey(a.actionID, \"gofiles\"))\n+\tlist, _, err := c.GetBytes(cache.Subkey(a.actionID, \"srcfiles\"))\n \tif err != nil {\n \t\treturn false\n \t}\n-\tvar gofiles []string\n+\tvar srcfiles []string\n \tfor _, name := range strings.Split(string(list), \"\\n\") {\n \t\tif name == \"\" { // end of list\n \t\t\tcontinue\n \t\t}\n \t\tif strings.HasPrefix(name, \"./\") {\n-\t\t\tgofiles = append(gofiles, name[2:])\n+\t\t\tsrcfiles = append(srcfiles, name[2:])\n \t\t\tcontinue\n \t\t}\n \t\tif err := b.loadCachedObjdirFile(a, c, name); err != nil {\n \t\t\treturn false\n \t\t}\n-\t\tgofiles = append(gofiles, a.Objdir+name)\n+\t\tsrcfiles = append(srcfiles, a.Objdir+name)\n \t}\n-\tbuildVetConfig(a, gofiles)\n+\tbuildVetConfig(a, srcfiles)\n \treturn true\n }\n \n-func (b *Builder) loadCachedGoFiles(a *Action) bool {\n+func (b *Builder) loadCachedSrcFiles(a *Action) bool {\n \tc := cache.Default()\n \tif c == nil {\n \t\treturn false\n \t}\n-\tlist, _, err := c.GetBytes(cache.Subkey(a.actionID, \"gofiles\"))\n+\tlist, _, err := c.GetBytes(cache.Subkey(a.actionID, \"srcfiles\"))\n \tif err != nil {\n \t\treturn false\n \t}\n@@ -878,10 +890,12 @@ func (b *Builder) loadCachedGoFiles(a *Action) bool {\n \n // vetConfig is the configuration passed to vet describing a single package.\n type vetConfig struct {\n+\tID         string   // package ID (example: \"fmt [fmt.test]\")\n \tCompiler   string   // compiler name (gc, gccgo)\n \tDir        string   // directory containing package\n \tImportPath string   // canonical import path (\"package path\")\n \tGoFiles    []string // absolute paths to package source files\n+\tNonGoFiles []string // absolute paths to package non-Go files\n \n \tImportMap   map[string]string // map import path in source code to package path\n \tPackageFile map[string]string // map package path to .a file with export data\n@@ -893,15 +907,28 @@ type vetConfig struct {\n \tSucceedOnTypecheckFailure bool // awful hack; see #18395 and below\n }\n \n-func buildVetConfig(a *Action, gofiles []string) {\n+func buildVetConfig(a *Action, srcfiles []string) {\n+\t// Classify files based on .go extension.\n+\t// srcfiles does not include raw cgo files.\n+\tvar gofiles, nongofiles []string\n+\tfor _, name := range srcfiles {\n+\t\tif strings.HasSuffix(name, \".go\") {\n+\t\t\tgofiles = append(gofiles, name)\n+\t\t} else {\n+\t\t\tnongofiles = append(nongofiles, name)\n+\t\t}\n+\t}\n+\n \t// Pass list of absolute paths to vet,\n \t// so that vet's error messages will use absolute paths,\n \t// so that we can reformat them relative to the directory\n \t// in which the go command is invoked.\n \tvcfg := &vetConfig{\n+\t\tID:          a.Package.ImportPath,\n \t\tCompiler:    cfg.BuildToolchainName,\n \t\tDir:         a.Package.Dir,\n \t\tGoFiles:     mkAbsFiles(a.Package.Dir, gofiles),\n+\t\tNonGoFiles:  mkAbsFiles(a.Package.Dir, nongofiles),\n \t\tImportPath:  a.Package.ImportPath,\n \t\tImportMap:   make(map[string]string),\n \t\tPackageFile: make(map[string]string),\n@@ -998,6 +1025,8 @@ func (b *Builder) vet(a *Action) error {\n \t\t}\n \t}\n \n+\t// TODO(adonovan): delete this when we use the new vet printf checker.\n+\t// https://github.com/golang/go/issues/28756\n \tif vcfg.ImportMap[\"fmt\"] == \"\" {\n \t\ta1 := a.Deps[1]\n \t\tvcfg.ImportMap[\"fmt\"] = \"fmt\"\n@@ -1621,6 +1650,25 @@ func (b *Builder) writeFile(file string, text []byte) error {\n \treturn ioutil.WriteFile(file, text, 0666)\n }\n \n+// appendFile appends the text to file.\n+func (b *Builder) appendFile(file string, text []byte) error {\n+\tif cfg.BuildN || cfg.BuildX {\n+\t\tb.Showcmd(\"\", \"cat >>%s << 'EOF' # internal\\n%sEOF\", file, text)\n+\t}\n+\tif cfg.BuildN {\n+\t\treturn nil\n+\t}\n+\tf, err := os.OpenFile(file, os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0666)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tdefer f.Close()\n+\tif _, err = f.Write(text); err != nil {\n+\t\treturn err\n+\t}\n+\treturn f.Close()\n+}\n+\n // Install the cgo export header file, if there is one.\n func (b *Builder) installHeader(a *Action) error {\n \tsrc := a.Objdir + \"_cgo_install.h\"\n@@ -1671,8 +1719,8 @@ var objectMagic = [][]byte{\n \t{0x00, 0x00, 0x8a, 0x97},                  // Plan 9 amd64\n \t{0x00, 0x00, 0x06, 0x47},                  // Plan 9 arm\n \t{0x00, 0x61, 0x73, 0x6D},                  // WASM\n-\t{0x01, 0xDF},                              // XCOFF32\n-\t{0x01, 0xF7},                              // XCOFF64\n+\t{0x01, 0xDF},                              // XCOFF 32bit\n+\t{0x01, 0xF7},                              // XCOFF 64bit\n }\n \n func isObject(s string) bool {\n@@ -1720,14 +1768,14 @@ func (b *Builder) fmtcmd(dir string, format string, args ...interface{}) string\n \t\tif dir[len(dir)-1] == filepath.Separator {\n \t\t\tdot += string(filepath.Separator)\n \t\t}\n-\t\tcmd = strings.Replace(\" \"+cmd, \" \"+dir, dot, -1)[1:]\n+\t\tcmd = strings.ReplaceAll(\" \"+cmd, \" \"+dir, dot)[1:]\n \t\tif b.scriptDir != dir {\n \t\t\tb.scriptDir = dir\n \t\t\tcmd = \"cd \" + dir + \"\\n\" + cmd\n \t\t}\n \t}\n \tif b.WorkDir != \"\" {\n-\t\tcmd = strings.Replace(cmd, b.WorkDir, \"$WORK\", -1)\n+\t\tcmd = strings.ReplaceAll(cmd, b.WorkDir, \"$WORK\")\n \t}\n \treturn cmd\n }\n@@ -1769,10 +1817,10 @@ func (b *Builder) showOutput(a *Action, dir, desc, out string) {\n \tprefix := \"# \" + desc\n \tsuffix := \"\\n\" + out\n \tif reldir := base.ShortPath(dir); reldir != dir {\n-\t\tsuffix = strings.Replace(suffix, \" \"+dir, \" \"+reldir, -1)\n-\t\tsuffix = strings.Replace(suffix, \"\\n\"+dir, \"\\n\"+reldir, -1)\n+\t\tsuffix = strings.ReplaceAll(suffix, \" \"+dir, \" \"+reldir)\n+\t\tsuffix = strings.ReplaceAll(suffix, \"\\n\"+dir, \"\\n\"+reldir)\n \t}\n-\tsuffix = strings.Replace(suffix, \" \"+b.WorkDir, \" $WORK\", -1)\n+\tsuffix = strings.ReplaceAll(suffix, \" \"+b.WorkDir, \" $WORK\")\n \n \tif a != nil && a.output != nil {\n \t\ta.output = append(a.output, prefix...)\n@@ -1976,13 +2024,18 @@ func mkAbs(dir, f string) string {\n type toolchain interface {\n \t// gc runs the compiler in a specific directory on a set of files\n \t// and returns the name of the generated output file.\n-\tgc(b *Builder, a *Action, archive string, importcfg []byte, asmhdr bool, gofiles []string) (ofile string, out []byte, err error)\n+\t//\n+\t// TODO: This argument list is long. Consider putting it in a struct.\n+\tgc(b *Builder, a *Action, archive string, importcfg []byte, symabis string, asmhdr bool, gofiles []string) (ofile string, out []byte, err error)\n \t// cc runs the toolchain's C compiler in a directory on a C file\n \t// to produce an output file.\n \tcc(b *Builder, a *Action, ofile, cfile string) error\n \t// asm runs the assembler in a specific directory on specific files\n \t// and returns a list of named output files.\n \tasm(b *Builder, a *Action, sfiles []string) ([]string, error)\n+\t// symabis scans the symbol ABIs from sfiles and returns the\n+\t// path to the output symbol ABIs file, or \"\" if none.\n+\tsymabis(b *Builder, a *Action, sfiles []string) (string, error)\n \t// pack runs the archive packer in a specific directory to create\n \t// an archive from a set of object files.\n \t// typically it is run in the object directory.\n@@ -2013,14 +2066,18 @@ func (noToolchain) linker() string {\n \treturn \"\"\n }\n \n-func (noToolchain) gc(b *Builder, a *Action, archive string, importcfg []byte, asmhdr bool, gofiles []string) (ofile string, out []byte, err error) {\n+func (noToolchain) gc(b *Builder, a *Action, archive string, importcfg []byte, symabis string, asmhdr bool, gofiles []string) (ofile string, out []byte, err error) {\n \treturn \"\", nil, noCompiler()\n }\n \n func (noToolchain) asm(b *Builder, a *Action, sfiles []string) ([]string, error) {\n \treturn nil, noCompiler()\n }\n \n+func (noToolchain) symabis(b *Builder, a *Action, sfiles []string) (string, error) {\n+\treturn \"\", noCompiler()\n+}\n+\n func (noToolchain) pack(b *Builder, a *Action, afile string, ofiles []string) error {\n \treturn noCompiler()\n }\n@@ -2092,14 +2149,37 @@ func (b *Builder) ccompile(a *Action, p *load.Package, outfile string, flags []s\n }\n \n // gccld runs the gcc linker to create an executable from a set of object files.\n-func (b *Builder) gccld(p *load.Package, objdir, out string, flags []string, objs []string) error {\n+func (b *Builder) gccld(p *load.Package, objdir, outfile string, flags []string, objs []string) error {\n \tvar cmd []string\n \tif len(p.CXXFiles) > 0 || len(p.SwigCXXFiles) > 0 {\n \t\tcmd = b.GxxCmd(p.Dir, objdir)\n \t} else {\n \t\tcmd = b.GccCmd(p.Dir, objdir)\n \t}\n-\treturn b.run(nil, p.Dir, p.ImportPath, b.cCompilerEnv(), cmd, \"-o\", out, objs, flags)\n+\n+\tcmdargs := []interface{}{cmd, \"-o\", outfile, objs, flags}\n+\tdir := p.Dir\n+\tout, err := b.runOut(dir, b.cCompilerEnv(), cmdargs...)\n+\tif len(out) > 0 {\n+\t\t// Filter out useless linker warnings caused by bugs outside Go.\n+\t\t// See also cmd/link/internal/ld's hostlink method.\n+\t\tvar save [][]byte\n+\t\tfor _, line := range bytes.SplitAfter(out, []byte(\"\\n\")) {\n+\t\t\t// golang.org/issue/26073 - Apple Xcode bug\n+\t\t\tif bytes.Contains(line, []byte(\"ld: warning: text-based stub file\")) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tsave = append(save, line)\n+\t\t}\n+\t\tout = bytes.Join(save, nil)\n+\t\tif len(out) > 0 {\n+\t\t\tb.showOutput(nil, dir, p.ImportPath, b.processOutput(out))\n+\t\t\tif err != nil {\n+\t\t\t\terr = errPrintedOutput\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn err\n }\n \n // Grab these before main helpfully overwrites them.\n@@ -2686,7 +2766,7 @@ func (b *Builder) swigDoIntSize(objdir string) (intsize string, err error) {\n \n \tp := load.GoFilesPackage(srcs)\n \n-\tif _, _, e := BuildToolchain.gc(b, &Action{Mode: \"swigDoIntSize\", Package: p, Objdir: objdir}, \"\", nil, false, srcs); e != nil {\n+\tif _, _, e := BuildToolchain.gc(b, &Action{Mode: \"swigDoIntSize\", Package: p, Objdir: objdir}, \"\", nil, \"\", false, srcs); e != nil {\n \t\treturn \"32\", nil\n \t}\n \treturn \"64\", nil\n@@ -2884,7 +2964,7 @@ func useResponseFile(path string, argLen int) bool {\n \t}\n \n \t// On the Go build system, use response files about 10% of the\n-\t// time, just to excercise this codepath.\n+\t// time, just to exercise this codepath.\n \tisBuilder := os.Getenv(\"GO_BUILDER_NAME\") != \"\"\n \tif isBuilder && rand.Intn(10) == 0 {\n \t\treturn true"}, {"sha": "3d09f69fcc3e43698dbb8182695bb4f4746247f9", "filename": "libgo/go/cmd/go/internal/work/gc.go", "status": "modified", "additions": 98, "deletions": 4, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgc.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -36,7 +36,7 @@ func (gcToolchain) linker() string {\n \treturn base.Tool(\"link\")\n }\n \n-func (gcToolchain) gc(b *Builder, a *Action, archive string, importcfg []byte, asmhdr bool, gofiles []string) (ofile string, output []byte, err error) {\n+func (gcToolchain) gc(b *Builder, a *Action, archive string, importcfg []byte, symabis string, asmhdr bool, gofiles []string) (ofile string, output []byte, err error) {\n \tp := a.Package\n \tobjdir := a.Objdir\n \tif archive != \"\" {\n@@ -53,6 +53,9 @@ func (gcToolchain) gc(b *Builder, a *Action, archive string, importcfg []byte, a\n \t\tpkgpath = \"main\"\n \t}\n \tgcargs := []string{\"-p\", pkgpath}\n+\tif p.Module != nil && p.Module.GoVersion != \"\" && allowedVersion(p.Module.GoVersion) {\n+\t\tgcargs = append(gcargs, \"-lang=go\"+p.Module.GoVersion)\n+\t}\n \tif p.Standard {\n \t\tgcargs = append(gcargs, \"-std\")\n \t}\n@@ -95,6 +98,9 @@ func (gcToolchain) gc(b *Builder, a *Action, archive string, importcfg []byte, a\n \tif strings.HasPrefix(runtimeVersion, \"go1\") && !strings.Contains(os.Args[0], \"go_bootstrap\") {\n \t\tgcargs = append(gcargs, \"-goversion\", runtimeVersion)\n \t}\n+\tif symabis != \"\" {\n+\t\tgcargs = append(gcargs, \"-symabis\", symabis)\n+\t}\n \n \tgcflags := str.StringList(forcedGcflags, p.Internal.Gcflags)\n \tif compilingRuntime {\n@@ -168,7 +174,7 @@ CheckFlags:\n \t}\n \n \t// TODO: Test and delete these conditions.\n-\tif objabi.Fieldtrack_enabled != 0 || objabi.Preemptibleloops_enabled != 0 || objabi.Clobberdead_enabled != 0 {\n+\tif objabi.Fieldtrack_enabled != 0 || objabi.Preemptibleloops_enabled != 0 {\n \t\tcanDashC = false\n \t}\n \n@@ -215,8 +221,7 @@ func trimDir(dir string) string {\n \treturn dir\n }\n \n-func (gcToolchain) asm(b *Builder, a *Action, sfiles []string) ([]string, error) {\n-\tp := a.Package\n+func asmArgs(a *Action, p *load.Package) []interface{} {\n \t// Add -I pkg/GOOS_GOARCH so #include \"textflag.h\" works in .s files.\n \tinc := filepath.Join(cfg.GOROOT, \"pkg\", \"include\")\n \targs := []interface{}{cfg.BuildToolexec, base.Tool(\"asm\"), \"-trimpath\", trimDir(a.Objdir), \"-I\", a.Objdir, \"-I\", inc, \"-D\", \"GOOS_\" + cfg.Goos, \"-D\", \"GOARCH_\" + cfg.Goarch, forcedAsmflags, p.Internal.Asmflags}\n@@ -238,6 +243,13 @@ func (gcToolchain) asm(b *Builder, a *Action, sfiles []string) ([]string, error)\n \t\targs = append(args, \"-D\", \"GOMIPS64_\"+cfg.GOMIPS64)\n \t}\n \n+\treturn args\n+}\n+\n+func (gcToolchain) asm(b *Builder, a *Action, sfiles []string) ([]string, error) {\n+\tp := a.Package\n+\targs := asmArgs(a, p)\n+\n \tvar ofiles []string\n \tfor _, sfile := range sfiles {\n \t\tofile := a.Objdir + sfile[:len(sfile)-len(\".s\")] + \".o\"\n@@ -250,6 +262,88 @@ func (gcToolchain) asm(b *Builder, a *Action, sfiles []string) ([]string, error)\n \treturn ofiles, nil\n }\n \n+func (gcToolchain) symabis(b *Builder, a *Action, sfiles []string) (string, error) {\n+\tmkSymabis := func(p *load.Package, sfiles []string, path string) error {\n+\t\targs := asmArgs(a, p)\n+\t\targs = append(args, \"-gensymabis\", \"-o\", path)\n+\t\tfor _, sfile := range sfiles {\n+\t\t\tif p.ImportPath == \"runtime/cgo\" && strings.HasPrefix(sfile, \"gcc_\") {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\targs = append(args, mkAbs(p.Dir, sfile))\n+\t\t}\n+\n+\t\t// Supply an empty go_asm.h as if the compiler had been run.\n+\t\t// -gensymabis parsing is lax enough that we don't need the\n+\t\t// actual definitions that would appear in go_asm.h.\n+\t\tif err := b.writeFile(a.Objdir+\"go_asm.h\", nil); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\n+\t\treturn b.run(a, p.Dir, p.ImportPath, nil, args...)\n+\t}\n+\n+\tvar symabis string // Only set if we actually create the file\n+\tp := a.Package\n+\tif len(sfiles) != 0 {\n+\t\tsymabis = a.Objdir + \"symabis\"\n+\t\tif err := mkSymabis(p, sfiles, symabis); err != nil {\n+\t\t\treturn \"\", err\n+\t\t}\n+\t}\n+\n+\t// Gather known cross-package references from assembly code.\n+\tvar otherPkgs []string\n+\tif p.ImportPath == \"runtime\" {\n+\t\t// Assembly in the following packages references\n+\t\t// symbols in runtime.\n+\t\totherPkgs = []string{\"syscall\", \"internal/syscall/unix\", \"runtime/cgo\"}\n+\t} else if p.ImportPath == \"runtime/internal/atomic\" {\n+\t\t// sync/atomic is an assembly wrapper around\n+\t\t// runtime/internal/atomic.\n+\t\totherPkgs = []string{\"sync/atomic\"}\n+\t}\n+\tfor _, p2name := range otherPkgs {\n+\t\tp2 := load.LoadPackage(p2name, &load.ImportStack{})\n+\t\tif len(p2.SFiles) == 0 {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tsymabis2 := a.Objdir + \"symabis2\"\n+\t\tif err := mkSymabis(p2, p2.SFiles, symabis2); err != nil {\n+\t\t\treturn \"\", err\n+\t\t}\n+\n+\t\t// Filter out just the symbol refs and append them to\n+\t\t// the symabis file.\n+\t\tif cfg.BuildN {\n+\t\t\t// -x will print the lines from symabis2 that are actually appended\n+\t\t\t// to symabis. With -n, we don't know what those lines will be.\n+\t\t\tb.Showcmd(\"\", `grep '^ref' <%s | grep -v '^ref\\s*\"\"\\.' >>%s`, symabis2, a.Objdir+\"symabis\")\n+\t\t\tcontinue\n+\t\t}\n+\t\tabis2, err := ioutil.ReadFile(symabis2)\n+\t\tif err != nil {\n+\t\t\treturn \"\", err\n+\t\t}\n+\t\tvar refs bytes.Buffer\n+\t\tfor _, line := range strings.Split(string(abis2), \"\\n\") {\n+\t\t\tfs := strings.Fields(line)\n+\t\t\tif len(fs) >= 2 && fs[0] == \"ref\" && !strings.HasPrefix(fs[1], `\"\".`) {\n+\t\t\t\tfmt.Fprintf(&refs, \"%s\\n\", line)\n+\t\t\t}\n+\t\t}\n+\t\tif refs.Len() != 0 {\n+\t\t\tsymabis = a.Objdir + \"symabis\"\n+\t\t\tif err := b.appendFile(symabis, refs.Bytes()); err != nil {\n+\t\t\t\treturn \"\", err\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn symabis, nil\n+}\n+\n // toolVerify checks that the command line args writes the same output file\n // if run using newTool instead.\n // Unused now but kept around for future use."}, {"sha": "82da5912b2d9862014d95cc3782cdbc89a770358", "filename": "libgo/go/cmd/go/internal/work/gccgo.go", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgccgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgccgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgccgo.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -43,6 +43,14 @@ func (gccgoToolchain) linker() string {\n \treturn GccgoBin\n }\n \n+func (gccgoToolchain) ar() string {\n+\tar := os.Getenv(\"AR\")\n+\tif ar == \"\" {\n+\t\tar = \"ar\"\n+\t}\n+\treturn ar\n+}\n+\n func checkGccgoBin() {\n \tif gccgoErr == nil {\n \t\treturn\n@@ -51,7 +59,7 @@ func checkGccgoBin() {\n \tos.Exit(2)\n }\n \n-func (tools gccgoToolchain) gc(b *Builder, a *Action, archive string, importcfg []byte, asmhdr bool, gofiles []string) (ofile string, output []byte, err error) {\n+func (tools gccgoToolchain) gc(b *Builder, a *Action, archive string, importcfg []byte, symabis string, asmhdr bool, gofiles []string) (ofile string, output []byte, err error) {\n \tp := a.Package\n \tobjdir := a.Objdir\n \tout := \"_go_.o\"\n@@ -174,33 +182,33 @@ func (tools gccgoToolchain) asm(b *Builder, a *Action, sfiles []string) ([]strin\n \treturn ofiles, nil\n }\n \n+func (gccgoToolchain) symabis(b *Builder, a *Action, sfiles []string) (string, error) {\n+\treturn \"\", nil\n+}\n+\n func gccgoArchive(basedir, imp string) string {\n \tend := filepath.FromSlash(imp + \".a\")\n \tafile := filepath.Join(basedir, end)\n \t// add \"lib\" to the final element\n \treturn filepath.Join(filepath.Dir(afile), \"lib\"+filepath.Base(afile))\n }\n \n-func (gccgoToolchain) pack(b *Builder, a *Action, afile string, ofiles []string) error {\n+func (tools gccgoToolchain) pack(b *Builder, a *Action, afile string, ofiles []string) error {\n \tp := a.Package\n \tobjdir := a.Objdir\n \tvar absOfiles []string\n \tfor _, f := range ofiles {\n \t\tabsOfiles = append(absOfiles, mkAbs(objdir, f))\n \t}\n-\tabsAfile := mkAbs(objdir, afile)\n-\t// Try with D modifier first, then without if that fails.\n-\tif cfg.Goos == \"aix\" || b.run(a, p.Dir, p.ImportPath, nil, \"ar\", \"rcD\", absAfile, absOfiles) != nil {\n-\t\tvar arArgs []string\n-\t\tif cfg.Goos == \"aix\" && cfg.Goarch == \"ppc64\" {\n-\t\t\t// AIX puts both 32-bit and 64-bit objects in the same archive.\n-\t\t\t// Tell the AIX \"ar\" command to only care about 64-bit objects.\n-\t\t\t// AIX \"ar\" command does not know D option.\n-\t\t\tarArgs = append(arArgs, \"-X64\")\n-\t\t}\n-\t\treturn b.run(a, p.Dir, p.ImportPath, nil, \"ar\", arArgs, \"rc\", absAfile, absOfiles)\n+\tvar arArgs []string\n+\tif cfg.Goos == \"aix\" && cfg.Goarch == \"ppc64\" {\n+\t\t// AIX puts both 32-bit and 64-bit objects in the same archive.\n+\t\t// Tell the AIX \"ar\" command to only care about 64-bit objects.\n+\t\t// AIX \"ar\" command does not know D option.\n+\t\tarArgs = []string{\"-X64\"}\n \t}\n-\treturn nil\n+\n+\treturn b.run(a, p.Dir, p.ImportPath, nil, tools.ar(), arArgs, \"rc\", mkAbs(objdir, afile), absOfiles)\n }\n \n func (tools gccgoToolchain) link(b *Builder, root *Action, out, importcfg string, allactions []*Action, buildmode, desc string) error {\n@@ -281,11 +289,11 @@ func (tools gccgoToolchain) link(b *Builder, root *Action, out, importcfg string\n \t\t\tb.Showcmd(\"\", \"ar d %s _cgo_flags\", newArchive)\n \t\t\treturn \"\", nil\n \t\t}\n-\t\terr := b.run(root, root.Objdir, desc, nil, \"ar\", \"x\", newArchive, \"_cgo_flags\")\n+\t\terr := b.run(root, root.Objdir, desc, nil, tools.ar(), \"x\", newArchive, \"_cgo_flags\")\n \t\tif err != nil {\n \t\t\treturn \"\", err\n \t\t}\n-\t\terr = b.run(root, \".\", desc, nil, \"ar\", \"d\", newArchive, \"_cgo_flags\")\n+\t\terr = b.run(root, \".\", desc, nil, tools.ar(), \"d\", newArchive, \"_cgo_flags\")\n \t\tif err != nil {\n \t\t\treturn \"\", err\n \t\t}\n@@ -393,7 +401,6 @@ func (tools gccgoToolchain) link(b *Builder, root *Action, out, importcfg string\n \tif root.Package != nil {\n \t\tldflags = append(ldflags, root.Package.CgoLDFLAGS...)\n \t}\n-\n \tif cfg.Goos != \"aix\" {\n \t\tldflags = str.StringList(\"-Wl,-(\", ldflags, \"-Wl,-)\")\n \t}\n@@ -505,7 +512,7 @@ func (tools gccgoToolchain) link(b *Builder, root *Action, out, importcfg string\n \n \tswitch buildmode {\n \tcase \"c-archive\":\n-\t\tif err := b.run(root, \".\", desc, nil, \"ar\", \"rc\", realOut, out); err != nil {\n+\t\tif err := b.run(root, \".\", desc, nil, tools.ar(), \"rc\", realOut, out); err != nil {\n \t\t\treturn err\n \t\t}\n \t}"}, {"sha": "693a53e9ab78d012f493bb619f5471f6c2d1f9ed", "filename": "libgo/go/cmd/go/internal/work/init.go", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Finit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Finit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Finit.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -10,6 +10,7 @@ import (\n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/load\"\n+\t\"cmd/internal/sys\"\n \t\"flag\"\n \t\"fmt\"\n \t\"os\"\n@@ -42,18 +43,14 @@ func instrumentInit() {\n \t\tfmt.Fprintf(os.Stderr, \"go %s: may not use -race and -msan simultaneously\\n\", flag.Args()[0])\n \t\tos.Exit(2)\n \t}\n-\tif cfg.BuildMSan && (cfg.Goos != \"linux\" || cfg.Goarch != \"amd64\" && cfg.Goarch != \"arm64\") {\n+\tif cfg.BuildMSan && !sys.MSanSupported(cfg.Goos, cfg.Goarch) {\n \t\tfmt.Fprintf(os.Stderr, \"-msan is not supported on %s/%s\\n\", cfg.Goos, cfg.Goarch)\n \t\tos.Exit(2)\n \t}\n \tif cfg.BuildRace {\n-\t\tplatform := cfg.Goos + \"/\" + cfg.Goarch\n-\t\tswitch platform {\n-\t\tdefault:\n-\t\t\tfmt.Fprintf(os.Stderr, \"go %s: -race is only supported on linux/amd64, linux/ppc64le, freebsd/amd64, netbsd/amd64, darwin/amd64 and windows/amd64\\n\", flag.Args()[0])\n+\t\tif !sys.RaceDetectorSupported(cfg.Goos, cfg.Goarch) {\n+\t\t\tfmt.Fprintf(os.Stderr, \"go %s: -race is only supported on linux/amd64, linux/ppc64le, linux/arm64, freebsd/amd64, netbsd/amd64, darwin/amd64 and windows/amd64\\n\", flag.Args()[0])\n \t\t\tos.Exit(2)\n-\t\tcase \"linux/amd64\", \"linux/ppc64le\", \"freebsd/amd64\", \"netbsd/amd64\", \"darwin/amd64\", \"windows/amd64\":\n-\t\t\t// race supported on these platforms\n \t\t}\n \t}\n \tmode := \"race\""}, {"sha": "1a401b8981ec2141c72385bf7c8a4a627d272e2e", "filename": "libgo/go/cmd/go/internal/work/security.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -89,7 +89,9 @@ var validCompilerFlags = []*regexp.Regexp{\n \tre(`-m32`),\n \tre(`-m64`),\n \tre(`-m(abi|arch|cpu|fpu|tune)=([^@\\-].*)`),\n+\tre(`-m(no-)?v?aes`),\n \tre(`-marm`),\n+\tre(`-m(no-)?avx[0-9a-z]*`),\n \tre(`-mfloat-abi=([^@\\-].*)`),\n \tre(`-mfpmath=[0-9a-z,+]*`),\n \tre(`-m(no-)?avx[0-9a-z.]*`),\n@@ -100,6 +102,7 @@ var validCompilerFlags = []*regexp.Regexp{\n \tre(`-miphoneos-version-min=(.+)`),\n \tre(`-mnop-fun-dllimport`),\n \tre(`-m(no-)?sse[0-9.]*`),\n+\tre(`-m(no-)?ssse3`),\n \tre(`-mthumb(-interwork)?`),\n \tre(`-mthreads`),\n \tre(`-mwindows`),"}, {"sha": "d986f5508d91dd0073d74e5bdb839f33384790e8", "filename": "libgo/go/cmd/go/main.go", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -93,9 +93,18 @@ func main() {\n \t\t*get.CmdGet = *modget.CmdGet\n \t}\n \n+\tif args[0] == \"get\" || args[0] == \"help\" {\n+\t\t// Replace get with module-aware get if appropriate.\n+\t\t// Note that if MustUseModules is true, this happened already above,\n+\t\t// but no harm in doing it again.\n+\t\tif modload.Init(); modload.Enabled() {\n+\t\t\t*get.CmdGet = *modget.CmdGet\n+\t\t}\n+\t}\n+\n \tcfg.CmdName = args[0] // for error messages\n \tif args[0] == \"help\" {\n-\t\thelp.Help(args[1:])\n+\t\thelp.Help(os.Stdout, args[1:])\n \t\treturn\n \t}\n \n@@ -145,10 +154,10 @@ func main() {\n \t\t\t\tflag = flag[:i]\n \t\t\t}\n \t\t\tswitch flag {\n-\t\t\tcase \"-sync\":\n-\t\t\t\tfmt.Fprintf(os.Stderr, \"go: go mod -sync is now go mod tidy\\n\")\n+\t\t\tcase \"-sync\", \"-fix\":\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"go: go mod %s is now go mod tidy\\n\", flag)\n \t\t\t\tos.Exit(2)\n-\t\t\tcase \"-init\", \"-fix\", \"-graph\", \"-vendor\", \"-verify\":\n+\t\t\tcase \"-init\", \"-graph\", \"-vendor\", \"-verify\":\n \t\t\t\tfmt.Fprintf(os.Stderr, \"go: go mod %s is now go mod %s\\n\", flag, flag[1:])\n \t\t\t\tos.Exit(2)\n \t\t\tcase \"-fmt\", \"-json\", \"-module\", \"-require\", \"-droprequire\", \"-replace\", \"-dropreplace\", \"-exclude\", \"-dropexclude\":\n@@ -164,15 +173,6 @@ func main() {\n \t\tos.Exit(2)\n \t}\n \n-\tif args[0] == \"get\" {\n-\t\t// Replace get with module-aware get if appropriate.\n-\t\t// Note that if MustUseModules is true, this happened already above,\n-\t\t// but no harm in doing it again.\n-\t\tif modload.Init(); modload.Enabled() {\n-\t\t\t*get.CmdGet = *modget.CmdGet\n-\t\t}\n-\t}\n-\n \t// Set environment (GOOS, GOARCH, etc) explicitly.\n \t// In theory all the commands we invoke should have\n \t// the same default computation of these as we do,\n@@ -202,7 +202,7 @@ BigCmdLoop:\n \t\t\t\t}\n \t\t\t\tif args[0] == \"help\" {\n \t\t\t\t\t// Accept 'go mod help' and 'go mod help foo' for 'go help mod' and 'go help mod foo'.\n-\t\t\t\t\thelp.Help(append(strings.Split(cfg.CmdName, \" \"), args[1:]...))\n+\t\t\t\t\thelp.Help(os.Stdout, append(strings.Split(cfg.CmdName, \" \"), args[1:]...))\n \t\t\t\t\treturn\n \t\t\t\t}\n \t\t\t\tcfg.CmdName += \" \" + args[0]\n@@ -238,10 +238,6 @@ func init() {\n }\n \n func mainUsage() {\n-\t// special case \"go test -h\"\n-\tif len(os.Args) > 1 && os.Args[1] == \"test\" {\n-\t\ttest.Usage()\n-\t}\n \thelp.PrintUsage(os.Stderr, base.Go)\n \tos.Exit(2)\n }"}, {"sha": "830cea029b7ac2ef4787fa8b22f91170296aacfa", "filename": "libgo/go/cmd/go/proxy_test.go", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Fproxy_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Fproxy_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fproxy_test.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -78,7 +78,7 @@ func readModList() {\n \t\tif i < 0 {\n \t\t\tcontinue\n \t\t}\n-\t\tencPath := strings.Replace(name[:i], \"_\", \"/\", -1)\n+\t\tencPath := strings.ReplaceAll(name[:i], \"_\", \"/\")\n \t\tpath, err := module.DecodePath(encPath)\n \t\tif err != nil {\n \t\t\tfmt.Fprintf(os.Stderr, \"go proxy_test: %v\\n\", err)\n@@ -197,7 +197,13 @@ func proxyHandler(w http.ResponseWriter, r *http.Request) {\n \t\t\t\tif strings.HasPrefix(f.Name, \".\") {\n \t\t\t\t\tcontinue\n \t\t\t\t}\n-\t\t\t\tzf, err := z.Create(path + \"@\" + vers + \"/\" + f.Name)\n+\t\t\t\tvar zipName string\n+\t\t\t\tif strings.HasPrefix(f.Name, \"/\") {\n+\t\t\t\t\tzipName = f.Name[1:]\n+\t\t\t\t} else {\n+\t\t\t\t\tzipName = path + \"@\" + vers + \"/\" + f.Name\n+\t\t\t\t}\n+\t\t\t\tzf, err := z.Create(zipName)\n \t\t\t\tif err != nil {\n \t\t\t\t\treturn cached{nil, err}\n \t\t\t\t}\n@@ -256,7 +262,7 @@ func readArchive(path, vers string) *txtar.Archive {\n \t\treturn nil\n \t}\n \n-\tprefix := strings.Replace(enc, \"/\", \"_\", -1)\n+\tprefix := strings.ReplaceAll(enc, \"/\", \"_\")\n \tname := filepath.Join(cmdGoDir, \"testdata/mod\", prefix+\"_\"+encVers+\".txt\")\n \ta := archiveCache.Do(name, func() interface{} {\n \t\ta, err := txtar.ParseFile(name)"}, {"sha": "f6facfd944f228ba7c32ad0b0c80e731c80e8726", "filename": "libgo/go/cmd/go/script_test.go", "status": "modified", "additions": 250, "deletions": 38, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Fscript_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Fscript_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fscript_test.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -9,7 +9,9 @@ package main_test\n \n import (\n \t\"bytes\"\n+\t\"context\"\n \t\"fmt\"\n+\t\"go/build\"\n \t\"internal/testenv\"\n \t\"io/ioutil\"\n \t\"os\"\n@@ -25,6 +27,7 @@ import (\n \t\"cmd/go/internal/imports\"\n \t\"cmd/go/internal/par\"\n \t\"cmd/go/internal/txtar\"\n+\t\"cmd/go/internal/work\"\n )\n \n // TestScript runs the tests in testdata/script/*.txt.\n@@ -55,21 +58,28 @@ func TestScript(t *testing.T) {\n \n // A testScript holds execution state for a single test script.\n type testScript struct {\n-\tt       *testing.T\n-\tworkdir string            // temporary work dir ($WORK)\n-\tlog     bytes.Buffer      // test execution log (printed at end of test)\n-\tmark    int               // offset of next log truncation\n-\tcd      string            // current directory during test execution; initially $WORK/gopath/src\n-\tname    string            // short name of test (\"foo\")\n-\tfile    string            // full file name (\"testdata/script/foo.txt\")\n-\tlineno  int               // line number currently executing\n-\tline    string            // line currently executing\n-\tenv     []string          // environment list (for os/exec)\n-\tenvMap  map[string]string // environment mapping (matches env)\n-\tstdout  string            // standard output from last 'go' command; for 'stdout' command\n-\tstderr  string            // standard error from last 'go' command; for 'stderr' command\n-\tstopped bool              // test wants to stop early\n-\tstart   time.Time         // time phase started\n+\tt          *testing.T\n+\tworkdir    string            // temporary work dir ($WORK)\n+\tlog        bytes.Buffer      // test execution log (printed at end of test)\n+\tmark       int               // offset of next log truncation\n+\tcd         string            // current directory during test execution; initially $WORK/gopath/src\n+\tname       string            // short name of test (\"foo\")\n+\tfile       string            // full file name (\"testdata/script/foo.txt\")\n+\tlineno     int               // line number currently executing\n+\tline       string            // line currently executing\n+\tenv        []string          // environment list (for os/exec)\n+\tenvMap     map[string]string // environment mapping (matches env)\n+\tstdout     string            // standard output from last 'go' command; for 'stdout' command\n+\tstderr     string            // standard error from last 'go' command; for 'stderr' command\n+\tstopped    bool              // test wants to stop early\n+\tstart      time.Time         // time phase started\n+\tbackground []backgroundCmd   // backgrounded 'exec' and 'go' commands\n+}\n+\n+type backgroundCmd struct {\n+\tcmd  *exec.Cmd\n+\twait <-chan struct{}\n+\tneg  bool // if true, cmd should fail\n }\n \n var extraEnvKeys = []string{\n@@ -102,6 +112,7 @@ func (ts *testScript) setup() {\n \t\t\"GOROOT=\" + testGOROOT,\n \t\ttempEnvName() + \"=\" + filepath.Join(ts.workdir, \"tmp\"),\n \t\t\"devnull=\" + os.DevNull,\n+\t\t\"goversion=\" + goVersion(ts),\n \t\t\":=\" + string(os.PathListSeparator),\n \t}\n \n@@ -128,6 +139,16 @@ func (ts *testScript) setup() {\n \t}\n }\n \n+// goVersion returns the current Go version.\n+func goVersion(ts *testScript) string {\n+\ttags := build.Default.ReleaseTags\n+\tversion := tags[len(tags)-1]\n+\tif !regexp.MustCompile(`^go([1-9][0-9]*)\\.(0|[1-9][0-9]*)$`).MatchString(version) {\n+\t\tts.fatalf(\"invalid go version %q\", version)\n+\t}\n+\treturn version[2:]\n+}\n+\n var execCache par.Cache\n \n // run runs the test script.\n@@ -152,6 +173,17 @@ func (ts *testScript) run() {\n \t}\n \n \tdefer func() {\n+\t\t// On a normal exit from the test loop, background processes are cleaned up\n+\t\t// before we print PASS. If we return early (e.g., due to a test failure),\n+\t\t// don't print anything about the processes that were still running.\n+\t\tfor _, bg := range ts.background {\n+\t\t\tinterruptProcess(bg.cmd.Process)\n+\t\t}\n+\t\tfor _, bg := range ts.background {\n+\t\t\t<-bg.wait\n+\t\t}\n+\t\tts.background = nil\n+\n \t\tmarkTime()\n \t\t// Flush testScript log to testing.T log.\n \t\tts.t.Log(\"\\n\" + ts.abbrev(ts.log.String()))\n@@ -249,12 +281,19 @@ Script:\n \t\t\t\tok = testenv.HasExternalNetwork()\n \t\t\tcase \"link\":\n \t\t\t\tok = testenv.HasLink()\n+\t\t\tcase \"root\":\n+\t\t\t\tok = os.Geteuid() == 0\n \t\t\tcase \"symlink\":\n \t\t\t\tok = testenv.HasSymlink()\n \t\t\tdefault:\n \t\t\t\tif strings.HasPrefix(cond, \"exec:\") {\n \t\t\t\t\tprog := cond[len(\"exec:\"):]\n \t\t\t\t\tok = execCache.Do(prog, func() interface{} {\n+\t\t\t\t\t\tif runtime.GOOS == \"plan9\" && prog == \"git\" {\n+\t\t\t\t\t\t\t// The Git command is usually not the real Git on Plan 9.\n+\t\t\t\t\t\t\t// See https://golang.org/issues/29640.\n+\t\t\t\t\t\t\treturn false\n+\t\t\t\t\t\t}\n \t\t\t\t\t\t_, err := exec.LookPath(prog)\n \t\t\t\t\t\treturn err == nil\n \t\t\t\t\t}).(bool)\n@@ -290,14 +329,23 @@ Script:\n \n \t\t// Command can ask script to stop early.\n \t\tif ts.stopped {\n-\t\t\treturn\n+\t\t\t// Break instead of returning, so that we check the status of any\n+\t\t\t// background processes and print PASS.\n+\t\t\tbreak\n \t\t}\n \t}\n \n+\tfor _, bg := range ts.background {\n+\t\tinterruptProcess(bg.cmd.Process)\n+\t}\n+\tts.cmdWait(false, nil)\n+\n \t// Final phase ended.\n \trewind()\n \tmarkTime()\n-\tfmt.Fprintf(&ts.log, \"PASS\\n\")\n+\tif !ts.stopped {\n+\t\tfmt.Fprintf(&ts.log, \"PASS\\n\")\n+\t}\n }\n \n // scriptCmds are the script command implementations.\n@@ -307,8 +355,11 @@ Script:\n //\n var scriptCmds = map[string]func(*testScript, bool, []string){\n \t\"addcrlf\": (*testScript).cmdAddcrlf,\n+\t\"cc\":      (*testScript).cmdCc,\n \t\"cd\":      (*testScript).cmdCd,\n+\t\"chmod\":   (*testScript).cmdChmod,\n \t\"cmp\":     (*testScript).cmdCmp,\n+\t\"cmpenv\":  (*testScript).cmdCmpenv,\n \t\"cp\":      (*testScript).cmdCp,\n \t\"env\":     (*testScript).cmdEnv,\n \t\"exec\":    (*testScript).cmdExec,\n@@ -323,6 +374,7 @@ var scriptCmds = map[string]func(*testScript, bool, []string){\n \t\"stdout\":  (*testScript).cmdStdout,\n \t\"stop\":    (*testScript).cmdStop,\n \t\"symlink\": (*testScript).cmdSymlink,\n+\t\"wait\":    (*testScript).cmdWait,\n }\n \n // addcrlf adds CRLF line endings to the named files.\n@@ -335,10 +387,21 @@ func (ts *testScript) cmdAddcrlf(neg bool, args []string) {\n \t\tfile = ts.mkabs(file)\n \t\tdata, err := ioutil.ReadFile(file)\n \t\tts.check(err)\n-\t\tts.check(ioutil.WriteFile(file, bytes.Replace(data, []byte(\"\\n\"), []byte(\"\\r\\n\"), -1), 0666))\n+\t\tts.check(ioutil.WriteFile(file, bytes.ReplaceAll(data, []byte(\"\\n\"), []byte(\"\\r\\n\")), 0666))\n \t}\n }\n \n+// cc runs the C compiler along with platform specific options.\n+func (ts *testScript) cmdCc(neg bool, args []string) {\n+\tif len(args) < 1 || (len(args) == 1 && args[0] == \"&\") {\n+\t\tts.fatalf(\"usage: cc args... [&]\")\n+\t}\n+\n+\tvar b work.Builder\n+\tb.Init()\n+\tts.cmdExec(neg, append(b.GccCmd(\".\", \"\"), args...))\n+}\n+\n // cd changes to a different directory.\n func (ts *testScript) cmdCd(neg bool, args []string) {\n \tif neg {\n@@ -364,6 +427,24 @@ func (ts *testScript) cmdCd(neg bool, args []string) {\n \tfmt.Fprintf(&ts.log, \"%s\\n\", ts.cd)\n }\n \n+// chmod changes permissions for a file or directory.\n+func (ts *testScript) cmdChmod(neg bool, args []string) {\n+\tif neg {\n+\t\tts.fatalf(\"unsupported: ! chmod\")\n+\t}\n+\tif len(args) < 2 {\n+\t\tts.fatalf(\"usage: chmod perm paths...\")\n+\t}\n+\tperm, err := strconv.ParseUint(args[0], 0, 32)\n+\tif err != nil || perm&uint64(os.ModePerm) != perm {\n+\t\tts.fatalf(\"invalid mode: %s\", args[0])\n+\t}\n+\tfor _, path := range args[1:] {\n+\t\terr := os.Chmod(path, os.FileMode(perm))\n+\t\tts.check(err)\n+\t}\n+}\n+\n // cmp compares two files.\n func (ts *testScript) cmdCmp(neg bool, args []string) {\n \tif neg {\n@@ -373,7 +454,21 @@ func (ts *testScript) cmdCmp(neg bool, args []string) {\n \tif len(args) != 2 {\n \t\tts.fatalf(\"usage: cmp file1 file2\")\n \t}\n+\tts.doCmdCmp(args, false)\n+}\n \n+// cmpenv compares two files with environment variable substitution.\n+func (ts *testScript) cmdCmpenv(neg bool, args []string) {\n+\tif neg {\n+\t\tts.fatalf(\"unsupported: ! cmpenv\")\n+\t}\n+\tif len(args) != 2 {\n+\t\tts.fatalf(\"usage: cmpenv file1 file2\")\n+\t}\n+\tts.doCmdCmp(args, true)\n+}\n+\n+func (ts *testScript) doCmdCmp(args []string, env bool) {\n \tname1, name2 := args[0], args[1]\n \tvar text1, text2 string\n \tif name1 == \"stdout\" {\n@@ -390,6 +485,11 @@ func (ts *testScript) cmdCmp(neg bool, args []string) {\n \tts.check(err)\n \ttext2 = string(data)\n \n+\tif env {\n+\t\ttext1 = ts.expand(text1)\n+\t\ttext2 = ts.expand(text2)\n+\t}\n+\n \tif text1 == text2 {\n \t\treturn\n \t}\n@@ -457,26 +557,43 @@ func (ts *testScript) cmdEnv(neg bool, args []string) {\n \n // exec runs the given command.\n func (ts *testScript) cmdExec(neg bool, args []string) {\n-\tif len(args) < 1 {\n-\t\tts.fatalf(\"usage: exec program [args...]\")\n+\tif len(args) < 1 || (len(args) == 1 && args[0] == \"&\") {\n+\t\tts.fatalf(\"usage: exec program [args...] [&]\")\n \t}\n+\n \tvar err error\n-\tts.stdout, ts.stderr, err = ts.exec(args[0], args[1:]...)\n-\tif ts.stdout != \"\" {\n-\t\tfmt.Fprintf(&ts.log, \"[stdout]\\n%s\", ts.stdout)\n-\t}\n-\tif ts.stderr != \"\" {\n-\t\tfmt.Fprintf(&ts.log, \"[stderr]\\n%s\", ts.stderr)\n+\tif len(args) > 0 && args[len(args)-1] == \"&\" {\n+\t\tvar cmd *exec.Cmd\n+\t\tcmd, err = ts.execBackground(args[0], args[1:len(args)-1]...)\n+\t\tif err == nil {\n+\t\t\twait := make(chan struct{})\n+\t\t\tgo func() {\n+\t\t\t\tctxWait(testCtx, cmd)\n+\t\t\t\tclose(wait)\n+\t\t\t}()\n+\t\t\tts.background = append(ts.background, backgroundCmd{cmd, wait, neg})\n+\t\t}\n+\t\tts.stdout, ts.stderr = \"\", \"\"\n+\t} else {\n+\t\tts.stdout, ts.stderr, err = ts.exec(args[0], args[1:]...)\n+\t\tif ts.stdout != \"\" {\n+\t\t\tfmt.Fprintf(&ts.log, \"[stdout]\\n%s\", ts.stdout)\n+\t\t}\n+\t\tif ts.stderr != \"\" {\n+\t\t\tfmt.Fprintf(&ts.log, \"[stderr]\\n%s\", ts.stderr)\n+\t\t}\n+\t\tif err == nil && neg {\n+\t\t\tts.fatalf(\"unexpected command success\")\n+\t\t}\n \t}\n+\n \tif err != nil {\n \t\tfmt.Fprintf(&ts.log, \"[%v]\\n\", err)\n-\t\tif !neg {\n+\t\tif testCtx.Err() != nil {\n+\t\t\tts.fatalf(\"test timed out while running command\")\n+\t\t} else if !neg {\n \t\t\tts.fatalf(\"unexpected command failure\")\n \t\t}\n-\t} else {\n-\t\tif neg {\n-\t\t\tts.fatalf(\"unexpected command success\")\n-\t\t}\n \t}\n }\n \n@@ -551,6 +668,14 @@ func (ts *testScript) cmdSkip(neg bool, args []string) {\n \tif neg {\n \t\tts.fatalf(\"unsupported: ! skip\")\n \t}\n+\n+\t// Before we mark the test as skipped, shut down any background processes and\n+\t// make sure they have returned the correct status.\n+\tfor _, bg := range ts.background {\n+\t\tinterruptProcess(bg.cmd.Process)\n+\t}\n+\tts.cmdWait(false, nil)\n+\n \tif len(args) == 1 {\n \t\tts.t.Skip(args[0])\n \t}\n@@ -620,7 +745,7 @@ func scriptMatch(ts *testScript, neg bool, args []string, text, name string) {\n \t\twant = 2\n \t}\n \tif len(args) != want {\n-\t\tts.fatalf(\"usage: %s [-count=N] 'pattern' file%s\", name, extraUsage)\n+\t\tts.fatalf(\"usage: %s [-count=N] 'pattern'%s\", name, extraUsage)\n \t}\n \n \tpattern := args[0]\n@@ -636,7 +761,7 @@ func scriptMatch(ts *testScript, neg bool, args []string, text, name string) {\n \t}\n \n \t// Matching against workdir would be misleading.\n-\ttext = strings.Replace(text, ts.workdir, \"$WORK\", -1)\n+\ttext = strings.ReplaceAll(text, ts.workdir, \"$WORK\")\n \n \tif neg {\n \t\tif re.MatchString(text) {\n@@ -693,11 +818,57 @@ func (ts *testScript) cmdSymlink(neg bool, args []string) {\n \tts.check(os.Symlink(args[2], ts.mkabs(args[0])))\n }\n \n+// wait waits for background commands to exit, setting stderr and stdout to their result.\n+func (ts *testScript) cmdWait(neg bool, args []string) {\n+\tif neg {\n+\t\tts.fatalf(\"unsupported: ! wait\")\n+\t}\n+\tif len(args) > 0 {\n+\t\tts.fatalf(\"usage: wait\")\n+\t}\n+\n+\tvar stdouts, stderrs []string\n+\tfor _, bg := range ts.background {\n+\t\t<-bg.wait\n+\n+\t\targs := append([]string{filepath.Base(bg.cmd.Args[0])}, bg.cmd.Args[1:]...)\n+\t\tfmt.Fprintf(&ts.log, \"[background] %s: %v\\n\", strings.Join(args, \" \"), bg.cmd.ProcessState)\n+\n+\t\tcmdStdout := bg.cmd.Stdout.(*strings.Builder).String()\n+\t\tif cmdStdout != \"\" {\n+\t\t\tfmt.Fprintf(&ts.log, \"[stdout]\\n%s\", cmdStdout)\n+\t\t\tstdouts = append(stdouts, cmdStdout)\n+\t\t}\n+\n+\t\tcmdStderr := bg.cmd.Stderr.(*strings.Builder).String()\n+\t\tif cmdStderr != \"\" {\n+\t\t\tfmt.Fprintf(&ts.log, \"[stderr]\\n%s\", cmdStderr)\n+\t\t\tstderrs = append(stderrs, cmdStderr)\n+\t\t}\n+\n+\t\tif bg.cmd.ProcessState.Success() {\n+\t\t\tif bg.neg {\n+\t\t\t\tts.fatalf(\"unexpected command success\")\n+\t\t\t}\n+\t\t} else {\n+\t\t\tif testCtx.Err() != nil {\n+\t\t\t\tts.fatalf(\"test timed out while running command\")\n+\t\t\t} else if !bg.neg {\n+\t\t\t\tts.fatalf(\"unexpected command failure\")\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tts.stdout = strings.Join(stdouts, \"\")\n+\tts.stderr = strings.Join(stderrs, \"\")\n+\tts.background = nil\n+}\n+\n // Helpers for command implementations.\n \n // abbrev abbreviates the actual work directory in the string s to the literal string \"$WORK\".\n func (ts *testScript) abbrev(s string) string {\n-\ts = strings.Replace(s, ts.workdir, \"$WORK\", -1)\n+\ts = strings.ReplaceAll(s, ts.workdir, \"$WORK\")\n \tif *testWork {\n \t\t// Expose actual $WORK value in environment dump on first line of work script,\n \t\t// so that the user can find out what directory -testwork left behind.\n@@ -722,10 +893,51 @@ func (ts *testScript) exec(command string, args ...string) (stdout, stderr strin\n \tvar stdoutBuf, stderrBuf strings.Builder\n \tcmd.Stdout = &stdoutBuf\n \tcmd.Stderr = &stderrBuf\n-\terr = cmd.Run()\n+\tif err = cmd.Start(); err == nil {\n+\t\terr = ctxWait(testCtx, cmd)\n+\t}\n \treturn stdoutBuf.String(), stderrBuf.String(), err\n }\n \n+// execBackground starts the given command line (an actual subprocess, not simulated)\n+// in ts.cd with environment ts.env.\n+func (ts *testScript) execBackground(command string, args ...string) (*exec.Cmd, error) {\n+\tcmd := exec.Command(command, args...)\n+\tcmd.Dir = ts.cd\n+\tcmd.Env = append(ts.env, \"PWD=\"+ts.cd)\n+\tvar stdoutBuf, stderrBuf strings.Builder\n+\tcmd.Stdout = &stdoutBuf\n+\tcmd.Stderr = &stderrBuf\n+\treturn cmd, cmd.Start()\n+}\n+\n+// ctxWait is like cmd.Wait, but terminates cmd with os.Interrupt if ctx becomes done.\n+//\n+// This differs from exec.CommandContext in that it prefers os.Interrupt over os.Kill.\n+// (See https://golang.org/issue/21135.)\n+func ctxWait(ctx context.Context, cmd *exec.Cmd) error {\n+\terrc := make(chan error, 1)\n+\tgo func() { errc <- cmd.Wait() }()\n+\n+\tselect {\n+\tcase err := <-errc:\n+\t\treturn err\n+\tcase <-ctx.Done():\n+\t\tinterruptProcess(cmd.Process)\n+\t\treturn <-errc\n+\t}\n+}\n+\n+// interruptProcess sends os.Interrupt to p if supported, or os.Kill otherwise.\n+func interruptProcess(p *os.Process) {\n+\tif err := p.Signal(os.Interrupt); err != nil {\n+\t\t// Per https://golang.org/pkg/os/#Signal, \u201cInterrupt is not implemented on\n+\t\t// Windows; using it with os.Process.Signal will return an error.\u201d\n+\t\t// Fall back to Kill instead.\n+\t\tp.Kill()\n+\t}\n+}\n+\n // expand applies environment variable expansion to the string s.\n func (ts *testScript) expand(s string) string {\n \treturn os.Expand(s, func(key string) string { return ts.envMap[key] })\n@@ -891,17 +1103,17 @@ var diffTests = []struct {\n func TestDiff(t *testing.T) {\n \tfor _, tt := range diffTests {\n \t\t// Turn spaces into \\n.\n-\t\ttext1 := strings.Replace(tt.text1, \" \", \"\\n\", -1)\n+\t\ttext1 := strings.ReplaceAll(tt.text1, \" \", \"\\n\")\n \t\tif text1 != \"\" {\n \t\t\ttext1 += \"\\n\"\n \t\t}\n-\t\ttext2 := strings.Replace(tt.text2, \" \", \"\\n\", -1)\n+\t\ttext2 := strings.ReplaceAll(tt.text2, \" \", \"\\n\")\n \t\tif text2 != \"\" {\n \t\t\ttext2 += \"\\n\"\n \t\t}\n \t\tout := diff(text1, text2)\n \t\t// Cut final \\n, cut spaces, turn remaining \\n into spaces.\n-\t\tout = strings.Replace(strings.Replace(strings.TrimSuffix(out, \"\\n\"), \" \", \"\", -1), \"\\n\", \" \", -1)\n+\t\tout = strings.ReplaceAll(strings.ReplaceAll(strings.TrimSuffix(out, \"\\n\"), \" \", \"\"), \"\\n\", \" \")\n \t\tif out != tt.diff {\n \t\t\tt.Errorf(\"diff(%q, %q) = %q, want %q\", text1, text2, out, tt.diff)\n \t\t}"}, {"sha": "8bb6056a540ae24850eb74f557fd56c5ac2ffdac", "filename": "libgo/go/cmd/go/testdata/addmod.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Faddmod.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Faddmod.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Faddmod.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -142,7 +142,7 @@ func main() {\n \t\t}\n \n \t\tdata := txtar.Format(a)\n-\t\ttarget := filepath.Join(\"mod\", strings.Replace(path, \"/\", \"_\", -1)+\"_\"+vers+\".txt\")\n+\t\ttarget := filepath.Join(\"mod\", strings.ReplaceAll(path, \"/\", \"_\")+\"_\"+vers+\".txt\")\n \t\tif err := ioutil.WriteFile(target, data, 0666); err != nil {\n \t\t\tlog.Printf(\"%s: %v\", arg, err)\n \t\t\texitCode = 1"}, {"sha": "0f060dc8e32fedcdbdf1a8b2f67823f891d273a4", "filename": "libgo/go/cmd/go/testdata/mod/research.swtch.com_vgo-tour_v1.0.0.txt", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fresearch.swtch.com_vgo-tour_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fresearch.swtch.com_vgo-tour_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fresearch.swtch.com_vgo-tour_v1.0.0.txt?ref=225220d668dafb8262db7012bced688acbe63b33", "patch": "@@ -1,23 +0,0 @@\n-research.swtch.com/vgo-tour@v1.0.0\n-\n--- .mod --\n-module \"research.swtch.com/vgo-tour\"\n--- .info --\n-{\"Version\":\"v1.0.0\",\"Name\":\"84de74b35823c1e49634f2262f1a58cfc951ebae\",\"Short\":\"84de74b35823\",\"Time\":\"2018-02-20T00:04:00Z\"}\n--- go.mod --\n-module \"research.swtch.com/vgo-tour\"\n--- hello.go --\n-// Copyright 2018 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package main\n-\n-import (\n-\t\"fmt\"\n-\t\"rsc.io/quote\"\n-)\n-\n-func main() {\n-\tfmt.Println(quote.Hello())\n-}"}, {"sha": "a7b50fff1645456710fa262e580d3d5b3f102781", "filename": "libgo/go/cmd/go/testdata/script/README", "status": "modified", "additions": 32, "deletions": 4, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2FREADME?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -36,6 +36,7 @@ Scripts also have access to these other environment variables:\n \tPATH=<actual PATH>\n \tTMPDIR=$WORK/tmp\n \tdevnull=<value of os.DevNull>\n+\tgoversion=<current Go version; for example, 1.12>\n \n The environment variable $exe (lowercase) is an empty string on most systems, \".exe\" on Windows.\n \n@@ -74,6 +75,7 @@ should only run when the condition is satisfied. The available conditions are:\n    - [cgo], [msan], [race] for whether cgo, msan, and the race detector can be used\n    - [net] for whether the external network can be used\n    - [link] for testenv.HasLink()\n+   - [root] for os.Geteuid() == 0\n    - [symlink] for testenv.HasSymlink()\n    - [exec:prog] for whether prog is available for execution (found by exec.LookPath)\n \n@@ -82,33 +84,52 @@ when testing.Short() is false.\n \n The commands are:\n \n+- [!] cc args... [&]\n+  Run the C compiler, the platform specific flags (i.e. `go env GOGCCFLAGS`) will be\n+  added automatically before args.\n+\n - cd dir\n   Change to the given directory for future commands.\n \n+- chmod perm path...\n+  Change the permissions of the files or directories named by the path arguments\n+  to be equal to perm. Only numerical permissions are supported.\n+\n - cmp file1 file2\n   Check that the named files have the same content.\n   By convention, file1 is the actual data and file2 the expected data.\n   File1 can be \"stdout\" or \"stderr\" to use the standard output or standard error\n   from the most recent exec or go command.\n   (If the files have differing content, the failure prints a diff.)\n \n+- cmpenv file1 file2\n+  Like cmp, but environment variables are substituted in the file contents\n+  before the comparison. For example, $GOOS is replaced by the target GOOS.\n+\n - cp src... dst\n   Copy the listed files to the target file or existing directory.\n \n - env [key=value...]\n   With no arguments, print the environment (useful for debugging).\n   Otherwise add the listed key=value pairs to the environment.\n \n-- [!] exec program [args...]\n+- [!] exec program [args...] [&]\n   Run the given executable program with the arguments.\n   It must (or must not) succeed.\n   Note that 'exec' does not terminate the script (unlike in Unix shells).\n \n+  If the last token is '&', the program executes in the background. The standard\n+  output and standard error of the previous command is cleared, but the output\n+  of the background process is buffered \u2014 and checking of its exit status is\n+  delayed \u2014 until the next call to 'wait', 'skip', or 'stop' or the end of the\n+  test. At the end of the test, any remaining background processes are\n+  terminated using os.Interrupt (if supported) or os.Kill.\n+\n - [!] exists [-readonly] file...\n   Each of the listed files or directories must (or must not) exist.\n   If -readonly is given, the files or directories must be unwritable.\n \n-- [!] go args...\n+- [!] go args... [&]\n   Run the (test copy of the) go command with the given arguments.\n   It must (or must not) succeed.\n \n@@ -131,18 +152,25 @@ The commands are:\n \n - [!] stderr [-count=N] pattern\n   Apply the grep command (see above) to the standard error\n-  from the most recent exec or go command.\n+  from the most recent exec, go, or wait command.\n \n - [!] stdout [-count=N] pattern\n   Apply the grep command (see above) to the standard output\n-  from the most recent exec or go command.\n+  from the most recent exec, go, or wait command.\n \n - stop [message]\n   Stop the test early (marking it as passing), including the message if given.\n \n - symlink file -> target\n   Create file as a symlink to target. The -> (like in ls -l output) is required.\n \n+- wait\n+  Wait for all 'exec' and 'go' commands started in the background (with the '&'\n+  token) to exit, and display success or failure status for them.\n+  After a call to wait, the 'stderr' and 'stdout' commands will apply to the\n+  concatenation of the corresponding streams of the background commands,\n+  in the order in which those commands were started.\n+\n When TestScript runs a script and the script fails, by default TestScript shows\n the execution of the most recent phase of the script (since the last # comment)\n and only shows the # comments for earlier phases. For example, here is a"}, {"sha": "ea06dcc472def69ec7a68dd8bf569c827beb5f2e", "filename": "libgo/go/cmd/go/testdata/script/build_GOTMPDIR.txt", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_GOTMPDIR.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_GOTMPDIR.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_GOTMPDIR.txt?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -1,11 +1,12 @@\n+# Set GOCACHE to a clean directory to ensure that 'go build' has work to report.\n+env GOCACHE=$WORK/gocache\n+\n # Build should use GOTMPDIR if set.\n env GOTMPDIR=$WORK/my-favorite-tmpdir\n-env GOCACHE=off\n mkdir $GOTMPDIR\n go build -work hello.go\n stderr ^WORK=.*my-favorite-tmpdir\n \n -- hello.go --\n package main\n func main() { println(\"hello\") }\n-"}, {"sha": "9f455256f72d880d558fd0c4572e6189bc06353d", "filename": "libgo/go/cmd/go/testdata/script/help.txt", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fhelp.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fhelp.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fhelp.txt?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -28,3 +28,21 @@ stdout 'usage: go mod tidy'\n # go mod --help doesn't print help but at least suggests it.\n ! go mod --help\n stderr 'Run ''go help mod'' for usage.'\n+\n+# Earlier versions of Go printed the same as 'go -h' here.\n+# Also make sure we print the short help line.\n+! go vet -h\n+stderr 'usage: go vet'\n+stderr 'Run ''go help vet'' for details'\n+stderr 'Run ''go tool vet -help'' for the vet tool''s flags'\n+\n+# Earlier versions of Go printed a large document here, instead of these two\n+# lines.\n+! go test -h\n+stderr 'usage: go test'\n+stderr 'Run ''go help test'' for details'\n+\n+# go help get shows usage for get\n+go help get\n+stdout 'usage: go get'\n+stdout 'get when using GOPATH'"}, {"sha": "3d9cac0d5f5495b0bfb8a52856a9e6f840a385c1", "filename": "libgo/go/cmd/go/testdata/script/list_bad_import.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_bad_import.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_bad_import.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_bad_import.txt?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -47,7 +47,7 @@ stdout error\n stdout incomplete\n \n \n-# The pattern \"all\" should match only packages that acutally exist,\n+# The pattern \"all\" should match only packages that actually exist,\n # ignoring those whose existence is merely implied by imports.\n go list -e -f '{{.ImportPath}}' all\n stdout example.com/direct"}, {"sha": "046bec6ac54b054e817539e6efa8d137276c937b", "filename": "libgo/go/cmd/go/testdata/script/list_std.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_std.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_std.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_std.txt?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -8,5 +8,5 @@ go list -f '{{if not .Standard}}{{.ImportPath}}{{end}}' ./...\n \n # our vendored packages should be reported as standard\n go list std cmd\n-stdout golang_org/x/net/http2/hpack\n+stdout internal/x/net/http2/hpack\n stdout cmd/vendor/golang\\.org/x/arch/x86/x86asm"}, {"sha": "22f07c33c7565adf68afc02434b83fa801ecbe3c", "filename": "libgo/go/cmd/go/testdata/script/mod_download.txt", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download.txt?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -8,6 +8,12 @@ exists $GOPATH/pkg/mod/cache/download/rsc.io/quote/@v/v1.5.0.info\n exists $GOPATH/pkg/mod/cache/download/rsc.io/quote/@v/v1.5.0.mod\n exists $GOPATH/pkg/mod/cache/download/rsc.io/quote/@v/v1.5.0.zip\n \n+# download of an invalid path should report the error\n+! go mod download this.domain.is.invalid/somemodule@v1.0.0\n+stderr 'this.domain.is.invalid'\n+! go mod download -json this.domain.is.invalid/somemodule@v1.0.0\n+stdout '\"Error\": \".*this.domain.is.invalid.*\"'\n+\n # download -json with version should print JSON\n go mod download -json 'rsc.io/quote@<=v1.5.0'\n stdout '^\\t\"Path\": \"rsc.io/quote\"'\n@@ -42,6 +48,21 @@ exists $GOPATH/pkg/mod/cache/download/rsc.io/quote/@v/v1.5.2.mod\n exists $GOPATH/pkg/mod/cache/download/rsc.io/quote/@v/v1.5.2.zip\n exists $GOPATH/pkg/mod/rsc.io/quote@v1.5.2\n \n+# download repopulates deleted files and directories independently.\n+rm $GOPATH/pkg/mod/cache/download/rsc.io/quote/@v/v1.5.2.info\n+go mod download\n+exists $GOPATH/pkg/mod/cache/download/rsc.io/quote/@v/v1.5.2.info\n+rm $GOPATH/pkg/mod/cache/download/rsc.io/quote/@v/v1.5.2.mod\n+go mod download\n+exists $GOPATH/pkg/mod/cache/download/rsc.io/quote/@v/v1.5.2.mod\n+rm $GOPATH/pkg/mod/cache/download/rsc.io/quote/@v/v1.5.2.zip\n+go mod download\n+exists $GOPATH/pkg/mod/cache/download/rsc.io/quote/@v/v1.5.2.zip\n+rm -r $GOPATH/pkg/mod/rsc.io/quote@v1.5.2\n+go mod download\n+exists $GOPATH/pkg/mod/rsc.io/quote@v1.5.2\n+\n+# download reports the locations of downloaded files\n go mod download -json\n stdout '^\\t\"Path\": \"rsc.io/quote\"'\n stdout '^\\t\"Version\": \"v1.5.2\"'"}, {"sha": "aa714e8b3cd7baeb6cc6a9e7862d05a92dad2ec2", "filename": "libgo/go/cmd/go/testdata/script/mod_edit.txt", "status": "modified", "additions": 45, "deletions": 10, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_edit.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_edit.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_edit.txt?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -10,37 +10,43 @@ stderr 'cannot determine module path'\n \n go mod init x.x/y/z\n stderr 'creating new go.mod: module x.x/y/z'\n-cmp go.mod $WORK/go.mod.init\n+cmpenv go.mod $WORK/go.mod.init\n \n ! go mod init\n-cmp go.mod $WORK/go.mod.init\n+cmpenv go.mod $WORK/go.mod.init\n \n # go mod edits\n go mod edit -droprequire=x.1 -require=x.1@v1.0.0 -require=x.2@v1.1.0 -droprequire=x.2 -exclude='x.1 @ v1.2.0' -exclude=x.1@v1.2.1 -replace=x.1@v1.3.0=y.1@v1.4.0 -replace='x.1@v1.4.0 = ../z'\n-cmp go.mod $WORK/go.mod.edit1\n+cmpenv go.mod $WORK/go.mod.edit1\n go mod edit -droprequire=x.1 -dropexclude=x.1@v1.2.1 -dropreplace=x.1@v1.3.0 -require=x.3@v1.99.0\n-cmp go.mod $WORK/go.mod.edit2\n+cmpenv go.mod $WORK/go.mod.edit2\n \n # go mod edit -json\n go mod edit -json\n-cmp stdout $WORK/go.mod.json\n+cmpenv stdout $WORK/go.mod.json\n \n # go mod edit -replace\n go mod edit -replace=x.1@v1.3.0=y.1/v2@v2.3.5 -replace=x.1@v1.4.0=y.1/v2@v2.3.5\n-cmp go.mod $WORK/go.mod.edit3\n+cmpenv go.mod $WORK/go.mod.edit3\n go mod edit -replace=x.1=y.1/v2@v2.3.6\n-cmp go.mod $WORK/go.mod.edit4\n+cmpenv go.mod $WORK/go.mod.edit4\n go mod edit -dropreplace=x.1\n-cmp go.mod $WORK/go.mod.edit5\n+cmpenv go.mod $WORK/go.mod.edit5\n \n # go mod edit -fmt\n cp $WORK/go.mod.badfmt go.mod\n go mod edit -fmt -print # -print should avoid writing file\n-cmp stdout $WORK/go.mod.edit4\n+cmpenv stdout $WORK/go.mod.edit6\n cmp go.mod $WORK/go.mod.badfmt\n go mod edit -fmt # without -print, should write file (and nothing to stdout)\n ! stdout .\n-cmp go.mod $WORK/go.mod.edit4\n+cmpenv go.mod $WORK/go.mod.edit6\n+\n+# go mod edit -module\n+cd $WORK/m\n+go mod init a.a/b/c\n+go mod edit -module x.x/y/z\n+cmpenv go.mod go.mod.edit\n \n -- x.go --\n package x\n@@ -50,9 +56,13 @@ package w\n \n -- $WORK/go.mod.init --\n module x.x/y/z\n+\n+go $goversion\n -- $WORK/go.mod.edit1 --\n module x.x/y/z\n \n+go $goversion\n+\n require x.1 v1.0.0\n \n exclude (\n@@ -67,6 +77,8 @@ replace (\n -- $WORK/go.mod.edit2 --\n module x.x/y/z\n \n+go $goversion\n+\n exclude x.1 v1.2.0\n \n replace x.1 v1.4.0 => ../z\n@@ -77,6 +89,7 @@ require x.3 v1.99.0\n \t\"Module\": {\n \t\t\"Path\": \"x.x/y/z\"\n \t},\n+\t\"Go\": \"$goversion\",\n \t\"Require\": [\n \t\t{\n \t\t\t\"Path\": \"x.3\",\n@@ -104,6 +117,8 @@ require x.3 v1.99.0\n -- $WORK/go.mod.edit3 --\n module x.x/y/z\n \n+go $goversion\n+\n exclude x.1 v1.2.0\n \n replace (\n@@ -115,6 +130,8 @@ require x.3 v1.99.0\n -- $WORK/go.mod.edit4 --\n module x.x/y/z\n \n+go $goversion\n+\n exclude x.1 v1.2.0\n \n replace x.1 => y.1/v2 v2.3.6\n@@ -123,14 +140,32 @@ require x.3 v1.99.0\n -- $WORK/go.mod.edit5 --\n module x.x/y/z\n \n+go $goversion\n+\n+exclude x.1 v1.2.0\n+\n+require x.3 v1.99.0\n+-- $WORK/go.mod.edit6 --\n+module x.x/y/z\n+\n+go 1.10\n+\n exclude x.1 v1.2.0\n \n+replace x.1 => y.1/v2 v2.3.6\n+\n require x.3 v1.99.0\n -- $WORK/go.mod.badfmt --\n module     x.x/y/z\n \n+go 1.10\n+\n exclude x.1     v1.2.0\n \n replace x.1    =>   y.1/v2 v2.3.6\n \n require x.3   v1.99.0\n+-- $WORK/m/go.mod.edit --\n+module x.x/y/z\n+\n+go $goversion\n\\ No newline at end of file"}, {"sha": "ab5ee3d6dfa656cb36e7a311d8699fd5d85788a5", "filename": "libgo/go/cmd/go/testdata/script/mod_enabled.txt", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_enabled.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_enabled.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_enabled.txt?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -38,9 +38,9 @@ stdout z[/\\\\]go.mod\n \n cd $GOPATH/src/x/y\n go env GOMOD\n-! stdout .\n-! go list -m\n-stderr 'cannot find main module'\n+stdout 'NUL|/dev/null'\n+go list -m\n+stdout '^command-line-arguments$'\n \n cd $GOPATH/foo\n go env GOMOD"}, {"sha": "9341a1d08305f83d95a6a89064f5106a59f559b0", "filename": "libgo/go/cmd/go/testdata/script/mod_fs_patterns.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_fs_patterns.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_fs_patterns.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_fs_patterns.txt?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -34,11 +34,11 @@ stderr 'import lookup disabled'\n \n ! go build -mod=readonly ./nonexist\n ! stderr 'import lookup disabled'\n-stderr '^go: no such directory ./nonexist'\n+stderr 'unknown import path \"m/nonexist\": cannot find package'\n \n ! go build -mod=readonly ./go.mod\n ! stderr 'import lookup disabled'\n-stderr '^go: ./go.mod is not a directory'\n+stderr 'unknown import path \"m/go.mod\": cannot find package'\n \n -- x/go.mod --\n module m"}, {"sha": "37f173531b699b83800216196d29418f7a178bfe", "filename": "libgo/go/cmd/go/testdata/script/mod_go_version.txt", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_go_version.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_go_version.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_go_version.txt?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -3,9 +3,10 @@\n env GO111MODULE=on\n \n go list\n-! go build\n-stderr 'module requires Go 1.999'\n+go build\n go build sub.1\n+go build subver.1\n+! stderr 'module requires'\n ! go build badsub.1\n stderr 'module requires Go 1.11111'\n \n@@ -19,11 +20,13 @@ module m\n go 1.999\n require (\n \tsub.1 v1.0.0\n+\tsubver.1 v1.0.0\n \tbadsub.1 v1.0.0\n \tversioned.1 v1.0.0\n )\n replace (\n \tsub.1 => ./sub\n+\tsubver.1 => ./subver\n \tbadsub.1 => ./badsub\n \tversioned.1 v1.0.0 => ./versioned1\n \tversioned.1 v1.1.0 => ./versioned2\n@@ -39,12 +42,20 @@ go 1.11\n -- sub/x.go --\n package x\n \n+-- subver/go.mod --\n+module m\n+go 1.11111\n+\n+-- subver/x.go --\n+package x\n+\n -- badsub/go.mod --\n module m\n go 1.11111\n \n -- badsub/x.go --\n package x\n+invalid syntax\n \n -- versioned1/go.mod --\n module versioned\n@@ -59,3 +70,4 @@ go 1.99999\n \n -- versioned2/x.go --\n package x\n+invalid syntax"}, {"sha": "5a47c3fa44ae6c78e9840b1bd61c76722af37c3d", "filename": "libgo/go/cmd/go/testdata/script/mod_internal.txt", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_internal.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_internal.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_internal.txt?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -18,15 +18,6 @@ stderr 'use of internal package golang.org/x/.* not allowed'\n ! go build ./fromstd\n stderr 'use of internal package internal/testenv not allowed'\n \n-# Packages found via standard-library vendoring should not leak.\n-! go build ./fromstdvendor\n-stderr 'use of vendored package golang_org/x/net/http/httpguts not allowed'\n-\n-env GO111MODULE=off\n-! go build ./fromstdvendor\n-[!gccgo] stderr 'cannot find package \"golang_org/x/net/http/httpguts\" in any of:'\n-env GO111MODULE=on\n-\n # Dependencies should be able to use their own internal modules...\n rm go.mod\n go mod init golang.org/notx\n@@ -83,10 +74,6 @@ import _ \"golang.org/notx/useinternal\"\n package fromstd\n import _ \"internal/testenv\"\n \n--- fromstdvendor/useinternal.go --\n-package fromstdvendor\n-import _ \"golang_org/x/net/http/httpguts\"\n-\n -- replace/golang.org/notx/internal/go.mod --\n module golang.org/x/internal\n "}, {"sha": "8a66e0b72a0a5acd15031f685784371a301f24c0", "filename": "libgo/go/cmd/go/testdata/script/mod_list_bad_import.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_bad_import.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_bad_import.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_bad_import.txt?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -47,7 +47,7 @@ stdout error\n stdout incomplete\n \n \n-# The pattern \"all\" should match only packages that acutally exist,\n+# The pattern \"all\" should match only packages that actually exist,\n # ignoring those whose existence is merely implied by imports.\n go list -e -f '{{.ImportPath}} {{.Error}}' all\n stdout example.com/direct"}, {"sha": "31cd27d75611841c97c8270e1d5a66c58174139a", "filename": "libgo/go/cmd/go/testdata/script/mod_list_dir.txt", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_dir.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_dir.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_dir.txt?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -12,7 +12,9 @@ stdout ^math$\n go list -f '{{.ImportPath}}' .\n stdout ^x$\n ! go list -f '{{.ImportPath}}' $GOPATH/pkg/mod/rsc.io/quote@v1.5.2\n-stderr '^go: no such directory.*quote@v1.5.2'\n+stderr 'unknown import path \"rsc.io/quote\": cannot find package'\n+go list -e -f '{{with .Error}}{{.}}{{end}}' $GOPATH/pkg/mod/rsc.io/quote@v1.5.2\n+stdout 'unknown import path \"rsc.io/quote\": cannot find package'\n go mod download rsc.io/quote@v1.5.2\n go list -f '{{.ImportPath}}' $GOPATH/pkg/mod/rsc.io/quote@v1.5.2\n stdout '^rsc.io/quote$'"}, {"sha": "b347deea7fff50cb47c1a126fbd06f2666d9afc1", "filename": "libgo/go/cmd/go/testdata/script/mod_nomod.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_nomod.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_nomod.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_nomod.txt?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -16,7 +16,7 @@ go mod edit -json x.mod\n ! go get\n ! go install\n ! go list\n-! go run x.go\n+! go run\n ! go test\n ! go vet\n "}, {"sha": "539b64a246106503d129a43bb4d32470f5c40bba", "filename": "libgo/go/cmd/go/testdata/script/mod_patterns.txt", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_patterns.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_patterns.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_patterns.txt?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -34,6 +34,13 @@ env CGO_ENABLED=0\n go list -f '{{.ImportPath}}: {{.Match}}' all ... example.com/m/... ./... ./xyz...\n ! stdout example.com/m/useC\n \n+# 'go list ./...' should not try to resolve the main module.\n+cd ../empty\n+go list -deps ./...\n+! stdout .\n+! stderr 'finding'\n+stderr -count=1 '^go: warning: \"./...\" matched no packages'\n+\n -- m/go.mod --\n module example.com/m\n \n@@ -64,3 +71,6 @@ module example.com/m/nested\n -- nested/useencoding/useencoding.go --\n package useencoding\n import _ \"encoding\"\n+\n+-- empty/go.mod --\n+module example.com/empty"}, {"sha": "188a66d0e15fa8826c526744332771a72e846327", "filename": "libgo/go/cmd/go/testdata/script/mod_readonly.txt", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_readonly.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_readonly.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_readonly.txt?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -37,6 +37,8 @@ cmp go.mod go.mod.inconsistent\n -- go.mod --\n module m\n \n+go 1.20\n+\n -- x.go --\n package x\n import _ \"rsc.io/quote\""}, {"sha": "78d6729fce322adb56306d30af1b6dd343caf430", "filename": "libgo/go/cmd/go/testdata/script/mod_replace.txt", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_replace.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_replace.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_replace.txt?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -1,27 +1,42 @@\n env GO111MODULE=on\n \n+cp go.mod go.mod.orig\n+\n+# Make sure the test builds without replacement.\n go build -o a1.exe .\n exec ./a1.exe\n stdout 'Don''t communicate by sharing memory'\n \n # Modules can be replaced by local packages.\n+cp go.mod.orig go.mod\n go mod edit -replace=rsc.io/quote/v3=./local/rsc.io/quote/v3\n go build -o a2.exe .\n exec ./a2.exe\n stdout 'Concurrency is not parallelism.'\n \n # The module path of the replacement doesn't need to match.\n # (For example, it could be a long-running fork with its own import path.)\n+cp go.mod.orig go.mod\n go mod edit -replace=rsc.io/quote/v3=./local/not-rsc.io/quote/v3\n go build -o a3.exe .\n exec ./a3.exe\n stdout 'Clear is better than clever.'\n \n # However, the same module can't be used as two different paths.\n-go mod edit -dropreplace=rsc.io/quote/v3 -replace=not-rsc.io/quote/v3@v3.0.0=rsc.io/quote/v3@v3.0.0 -require=not-rsc.io/quote/v3@v3.0.0\n+cp go.mod.orig go.mod\n+go mod edit -replace=not-rsc.io/quote/v3@v3.0.0=rsc.io/quote/v3@v3.0.0 -require=not-rsc.io/quote/v3@v3.0.0\n ! go build -o a4.exe .\n stderr 'rsc.io/quote/v3@v3.0.0 used for two different module paths \\(not-rsc.io/quote/v3 and rsc.io/quote/v3\\)'\n \n+# Modules that do not (yet) exist upstream can be replaced too.\n+cp go.mod.orig go.mod\n+go mod edit -replace=not-rsc.io/quote/v3@v3.1.0=./local/rsc.io/quote/v3\n+go build -o a5.exe ./usenewmodule\n+! stderr 'finding not-rsc.io/quote/v3'\n+grep 'not-rsc.io/quote/v3 v3.1.0' go.mod\n+exec ./a5.exe\n+stdout 'Concurrency is not parallelism.'\n+\n -- go.mod --\n module quoter\n \n@@ -39,6 +54,18 @@ func main() {\n \tfmt.Println(quote.GoV3())\n }\n \n+-- usenewmodule/main.go --\n+package main\n+\n+import (\n+\t\"fmt\"\n+\t\"not-rsc.io/quote/v3\"\n+)\n+\n+func main() {\n+\tfmt.Println(quote.GoV3())\n+}\n+\n -- local/rsc.io/quote/v3/go.mod --\n module rsc.io/quote/v3\n "}, {"sha": "af4fd76d706cff5a75c7da1fd6227621ee849f91", "filename": "libgo/go/cmd/go/testdata/script/mod_test.txt", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_test.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_test.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_test.txt?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -1,5 +1,8 @@\n env GO111MODULE=on\n \n+# TODO(bcmills): Convert the 'go test' calls below to 'go list -test' once 'go\n+# list' is more sensitive to package loading errors.\n+\n # A test in the module's root package should work.\n cd a/\n cp go.mod.empty go.mod\n@@ -48,6 +51,10 @@ cd ../d_test\n go test\n stdout PASS\n \n+cd ../e\n+go test\n+stdout PASS\n+\n -- a/go.mod.empty --\n module example.com/user/a\n "}, {"sha": "de3b52e2c023caa51a3ee4c73903b680cae46d08", "filename": "libgo/go/cmd/go/testdata/script/mod_tidy.txt", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_tidy.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_tidy.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_tidy.txt?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -5,18 +5,27 @@ go mod tidy -v\n stderr '^unused y.1'\n ! stderr '^unused [^y]'\n \n+# tidy should not touch existing go line\n+grep 'go 1.10' go.mod\n+\n go list -m all\n ! stdout '^y'\n stdout '^w.1 v1.2.0'\n stdout '^z.1 v1.2.0'\n \n # empty tidy should not crash\n cd triv\n+! grep 'go ' go.mod\n go mod tidy\n \n+# tidy should add missing go line\n+grep 'go ' go.mod\n+\n -- go.mod --\n module m\n \n+go 1.10\n+\n require (\n \tx.1 v1.0.0\n \ty.1 v1.0.0"}, {"sha": "203183be881f2a43366ef4710785a7e0a2e11488", "filename": "libgo/go/cmd/go/testdata/script/mod_vendor.txt", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_vendor.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_vendor.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_vendor.txt?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -67,6 +67,7 @@ module m\n \n require (\n \ta v1.0.0\n+\tdiamondroot v0.0.0\n \tmysite/myname/mypkg v1.0.0\n \tw v1.0.0 // indirect\n \tx v1.0.0\n@@ -76,6 +77,10 @@ require (\n \n replace (\n \ta v1.0.0 => ./a\n+\tdiamondleft => ./diamondleft\n+\tdiamondpoint => ./diamondpoint\n+\tdiamondright => ./diamondright\n+\tdiamondroot => ./diamondroot\n \tmysite/myname/mypkg v1.0.0 => ./mypkg\n \tw v1.0.0 => ./w\n \tx v1.0.0 => ./x\n@@ -200,6 +205,10 @@ import _ \"z\"\n package m\n \n import _ \"x/x1\"\n+-- importdiamond.go --\n+package m\n+\n+import _ \"diamondroot\"\n -- w/go.mod --\n module w\n -- w/w.go --\n@@ -228,3 +237,42 @@ package y\n module z\n -- z/z.go --\n package z\n+\n+-- diamondroot/go.mod --\n+module diamondroot\n+\n+require (\n+\tdiamondleft v0.0.0\n+\tdiamondright v0.0.0\n+)\n+-- diamondroot/x.go --\n+package diamondroot\n+\n+import (\n+\t_ \"diamondleft\"\n+\t_ \"diamondright\"\n+)\n+-- diamondleft/go.mod --\n+module diamondleft\n+\n+require (\n+\tdiamondpoint v0.0.0\n+)\n+-- diamondleft/x.go --\n+package diamondleft\n+\n+import _ \"diamondpoint\"\n+-- diamondright/go.mod --\n+module diamondright\n+\n+require (\n+\tdiamondpoint v0.0.0\n+)\n+-- diamondright/x.go --\n+package diamondright\n+\n+import _ \"diamondpoint\"\n+-- diamondpoint/go.mod --\n+module diamondpoint\n+-- diamondpoint/x.go --\n+package diamondpoint"}, {"sha": "71493efe983741d6f3a41b5a9cb72b2036990116", "filename": "libgo/go/cmd/go/testdata/testterminal18153/terminal_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestterminal18153%2Fterminal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestterminal18153%2Fterminal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestterminal18153%2Fterminal_test.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -5,7 +5,7 @@\n // +build linux\n \n // This test is run by src/cmd/dist/test.go (cmd_go_test_terminal),\n-// and not by cmd/go's tests. This is because this test requires that\n+// and not by cmd/go's tests. This is because this test requires\n // that it be called with its stdout and stderr being a terminal.\n // dist doesn't run `cmd/go test` against this test directory if\n // dist's stdout/stderr aren't terminals."}, {"sha": "c302d7e9b584146f1df0261a7b8ebceb6dd265ac", "filename": "libgo/go/cmd/go/vendor_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Fvendor_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgo%2Fvendor_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fvendor_test.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -37,7 +37,7 @@ func TestVendorImports(t *testing.T) {\n \t\tvend/x/vendor/p/p [notfound]\n \t\tvend/x/vendor/r []\n \t`\n-\twant = strings.Replace(want+\"\\t\", \"\\n\\t\\t\", \"\\n\", -1)\n+\twant = strings.ReplaceAll(want+\"\\t\", \"\\n\\t\\t\", \"\\n\")\n \twant = strings.TrimPrefix(want, \"\\n\")\n \n \thave := tg.stdout.String()"}, {"sha": "ac6852f2e4e3841e049070b878038c849bab0675", "filename": "libgo/go/cmd/gofmt/gofmt.go", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -319,10 +319,7 @@ func backupFile(filename string, data []byte, perm os.FileMode) (string, error)\n \t}\n \n \t// write data to backup file\n-\tn, err := f.Write(data)\n-\tif err == nil && n < len(data) {\n-\t\terr = io.ErrShortWrite\n-\t}\n+\t_, err = f.Write(data)\n \tif err1 := f.Close(); err == nil {\n \t\terr = err1\n \t}"}, {"sha": "3008365cd237ca4ac4513a370b51dd326292ad0c", "filename": "libgo/go/cmd/gofmt/gofmt_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt_test.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -200,7 +200,7 @@ func TestDiff(t *testing.T) {\n \t}\n \n \tif runtime.GOOS == \"windows\" {\n-\t\tb = bytes.Replace(b, []byte{'\\r', '\\n'}, []byte{'\\n'}, -1)\n+\t\tb = bytes.ReplaceAll(b, []byte{'\\r', '\\n'}, []byte{'\\n'})\n \t}\n \n \tbs := bytes.SplitN(b, []byte{'\\n'}, 3)"}, {"sha": "e2a6208f871ea3bfa70add68fad9555bad4e2bbb", "filename": "libgo/go/cmd/gofmt/long_test.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgofmt%2Flong_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fgofmt%2Flong_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Flong_test.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -85,6 +85,12 @@ func testFile(t *testing.T, b1, b2 *bytes.Buffer, filename string) {\n \n \t// the first and 2nd result should be identical\n \tif !bytes.Equal(b1.Bytes(), b2.Bytes()) {\n+\t\t// A known instance of gofmt not being idempotent\n+\t\t// (see Issue #24472)\n+\t\tif strings.HasSuffix(filename, \"issue22662.go\") {\n+\t\t\tt.Log(\"known gofmt idempotency bug (Issue #24472)\")\n+\t\t\treturn\n+\t\t}\n \t\tt.Errorf(\"gofmt %s not idempotent\", filename)\n \t}\n }"}, {"sha": "ac238d70ea0cd92e825e06492522775a9643a344", "filename": "libgo/go/cmd/internal/buildid/buildid.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Finternal%2Fbuildid%2Fbuildid.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Finternal%2Fbuildid%2Fbuildid.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fbuildid%2Fbuildid.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -7,8 +7,8 @@ package buildid\n import (\n \t\"bytes\"\n \t\"debug/elf\"\n-\t\"debug/xcoff\"\n \t\"fmt\"\n+\t\"internal/xcoff\"\n \t\"io\"\n \t\"os\"\n \t\"strconv\""}, {"sha": "03dc9fb88bc769157b2cd4414e843f0a607052b9", "filename": "libgo/go/cmd/internal/objabi/doc.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fdoc.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -22,7 +22,7 @@\n //\n // The file format is:\n //\n-//\t- magic header: \"\\x00\\x00go19ld\"\n+//\t- magic header: \"\\x00go112ld\"\n //\t- byte 1 - version number\n //\t- sequence of strings giving dependencies (imported packages)\n //\t- empty string (marks end of sequence)\n@@ -38,15 +38,15 @@\n //\t- data, the content of the defined symbols\n //\t- sequence of defined symbols\n //\t- byte 0xff (marks end of sequence)\n-//\t- magic footer: \"\\xff\\xffgo19ld\"\n+//\t- magic footer: \"\\xffgo112ld\"\n //\n // All integers are stored in a zigzag varint format.\n // See golang.org/s/go12symtab for a definition.\n //\n // Data blocks and strings are both stored as an integer\n // followed by that many bytes.\n //\n-// A symbol reference is a string name followed by a version.\n+// A symbol reference is a string name followed by an ABI or -1 for static.\n //\n // A symbol points to other symbols using an index into the symbol\n // reference sequence. Index 0 corresponds to a nil symbol pointer.\n@@ -57,7 +57,7 @@\n //\n //\t- byte 0xfe (sanity check for synchronization)\n //\t- type [byte]\n-//\t- name & version [symref index]\n+//\t- name & ABI [symref index]\n //\t- flags [int]\n //\t\t1<<0 dupok\n //\t\t1<<1 local"}, {"sha": "90e944656bb8a2ebeca5dd2d593ac0a124a222f6", "filename": "libgo/go/cmd/internal/objabi/flag.go", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fflag.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -100,9 +100,18 @@ func (versionFlag) Set(s string) error {\n \t// for releases, but during development we include the full\n \t// build ID of the binary, so that if the compiler is changed and\n \t// rebuilt, we notice and rebuild all packages.\n-\tif s == \"full\" && strings.HasPrefix(Version, \"devel\") {\n-\t\tp += \" buildID=\" + buildID\n+\tif s == \"full\" {\n+\t\t// If there's an active experiment, include that,\n+\t\t// to distinguish go1.10.2 with an experiment\n+\t\t// from go1.10.2 without an experiment.\n+\t\tif x := Expstring(); x != \"\" {\n+\t\t\tp += \" \" + x\n+\t\t}\n+\t\tif strings.HasPrefix(Version, \"devel\") {\n+\t\t\tp += \" buildID=\" + buildID\n+\t\t}\n \t}\n+\n \tfmt.Printf(\"%s version %s%s%s\\n\", name, Version, sep, p)\n \tos.Exit(0)\n \treturn nil"}, {"sha": "231d11b18572c599e26b3c06c0d0570fb63311f6", "filename": "libgo/go/cmd/internal/objabi/funcdata.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Ffuncdata.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Ffuncdata.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Ffuncdata.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -18,6 +18,7 @@ const (\n \tFUNCDATA_LocalsPointerMaps = 1\n \tFUNCDATA_InlTree           = 2\n \tFUNCDATA_RegPointerMaps    = 3\n+\tFUNCDATA_StackObjects      = 4\n \n \t// ArgsSizeUnknown is set in Func.argsize to mark all functions\n \t// whose argument size is unknown (C vararg functions, and"}, {"sha": "1792df7cc1d0fc697d16d449d4b7aec2199d9917", "filename": "libgo/go/cmd/internal/objabi/funcid.go", "status": "modified", "additions": 67, "deletions": 1, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Ffuncid.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Ffuncid.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Ffuncid.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -4,12 +4,17 @@\n \n package objabi\n \n+import (\n+\t\"strconv\"\n+\t\"strings\"\n+)\n+\n // A FuncID identifies particular functions that need to be treated\n // specially by the runtime.\n // Note that in some situations involving plugins, there may be multiple\n // copies of a particular special runtime function.\n // Note: this list must match the list in runtime/symtab.go.\n-type FuncID uint32\n+type FuncID uint8\n \n const (\n \tFuncID_normal FuncID = iota // not a special function\n@@ -30,4 +35,65 @@ const (\n \tFuncID_gogo\n \tFuncID_externalthreadhandler\n \tFuncID_debugCallV1\n+\tFuncID_gopanic\n+\tFuncID_panicwrap\n+\tFuncID_wrapper // any autogenerated code (hash/eq algorithms, method wrappers, etc.)\n )\n+\n+// Get the function ID for the named function in the named file.\n+// The function should be package-qualified.\n+func GetFuncID(name, file string) FuncID {\n+\tswitch name {\n+\tcase \"runtime.main\":\n+\t\treturn FuncID_runtime_main\n+\tcase \"runtime.goexit\":\n+\t\treturn FuncID_goexit\n+\tcase \"runtime.jmpdefer\":\n+\t\treturn FuncID_jmpdefer\n+\tcase \"runtime.mcall\":\n+\t\treturn FuncID_mcall\n+\tcase \"runtime.morestack\":\n+\t\treturn FuncID_morestack\n+\tcase \"runtime.mstart\":\n+\t\treturn FuncID_mstart\n+\tcase \"runtime.rt0_go\":\n+\t\treturn FuncID_rt0_go\n+\tcase \"runtime.asmcgocall\":\n+\t\treturn FuncID_asmcgocall\n+\tcase \"runtime.sigpanic\":\n+\t\treturn FuncID_sigpanic\n+\tcase \"runtime.runfinq\":\n+\t\treturn FuncID_runfinq\n+\tcase \"runtime.gcBgMarkWorker\":\n+\t\treturn FuncID_gcBgMarkWorker\n+\tcase \"runtime.systemstack_switch\":\n+\t\treturn FuncID_systemstack_switch\n+\tcase \"runtime.systemstack\":\n+\t\treturn FuncID_systemstack\n+\tcase \"runtime.cgocallback_gofunc\":\n+\t\treturn FuncID_cgocallback_gofunc\n+\tcase \"runtime.gogo\":\n+\t\treturn FuncID_gogo\n+\tcase \"runtime.externalthreadhandler\":\n+\t\treturn FuncID_externalthreadhandler\n+\tcase \"runtime.debugCallV1\":\n+\t\treturn FuncID_debugCallV1\n+\tcase \"runtime.gopanic\":\n+\t\treturn FuncID_gopanic\n+\tcase \"runtime.panicwrap\":\n+\t\treturn FuncID_panicwrap\n+\t}\n+\tif file == \"<autogenerated>\" && !strings.HasSuffix(name, \".init\") {\n+\t\treturn FuncID_wrapper\n+\t}\n+\tif strings.HasPrefix(name, \"runtime.call\") {\n+\t\tif _, err := strconv.Atoi(name[12:]); err == nil {\n+\t\t\t// runtime.callXX reflect call wrappers.\n+\t\t\treturn FuncID_wrapper\n+\t\t}\n+\t}\n+\tif strings.HasSuffix(name, \"-fm\") {\n+\t\treturn FuncID_wrapper\n+\t}\n+\treturn FuncID_normal\n+}"}, {"sha": "db2221d6b145e1cddb162bb4f495899739802177", "filename": "libgo/go/cmd/internal/objabi/head.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fhead.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fhead.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fhead.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -48,10 +48,13 @@ const (\n \tHplan9\n \tHsolaris\n \tHwindows\n+\tHaix\n )\n \n func (h *HeadType) Set(s string) error {\n \tswitch s {\n+\tcase \"aix\":\n+\t\t*h = Haix\n \tcase \"darwin\":\n \t\t*h = Hdarwin\n \tcase \"dragonfly\":\n@@ -82,6 +85,8 @@ func (h *HeadType) Set(s string) error {\n \n func (h *HeadType) String() string {\n \tswitch *h {\n+\tcase Haix:\n+\t\treturn \"aix\"\n \tcase Hdarwin:\n \t\treturn \"darwin\"\n \tcase Hdragonfly:"}, {"sha": "355882c63880af3d0e60f7cd3a56d4f1a3ce2c9d", "filename": "libgo/go/cmd/internal/objabi/reloctype.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Freloctype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Freloctype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Freloctype.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -198,7 +198,7 @@ const (\n \tR_WASMIMPORT\n )\n \n-// IsDirectJump returns whether r is a relocation for a direct jump.\n+// IsDirectJump reports whether r is a relocation for a direct jump.\n // A direct jump is a CALL or JMP instruction that takes the target address\n // as immediate. The address is embedded into the instruction, possibly\n // with limited width."}, {"sha": "62ab0398a6653407859428a2d750214dac6d127c", "filename": "libgo/go/cmd/internal/objabi/stack.go", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fstack.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fstack.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fstack.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -10,11 +10,24 @@ const (\n \tSTACKSYSTEM = 0\n \tStackSystem = STACKSYSTEM\n \tStackBig    = 4096\n-\tStackGuard  = 880*stackGuardMultiplier + StackSystem\n \tStackSmall  = 128\n-\tStackLimit  = StackGuard - StackSystem - StackSmall\n )\n \n const (\n \tStackPreempt = -1314 // 0xfff...fade\n )\n+\n+// Initialize StackGuard and StackLimit according to target system.\n+var StackGuard = 880*stackGuardMultiplier() + StackSystem\n+var StackLimit = StackGuard - StackSystem - StackSmall\n+\n+// stackGuardMultiplier returns a multiplier to apply to the default\n+// stack guard size. Larger multipliers are used for non-optimized\n+// builds that have larger stack frames or for specific targets.\n+func stackGuardMultiplier() int {\n+\t// On AIX, a larger stack is needed for syscalls.\n+\tif GOOS == \"aix\" {\n+\t\treturn 2\n+\t}\n+\treturn stackGuardMultiplierDefault\n+}"}, {"sha": "16b4c535ed85b2fcb56286dcc6cc649bc5212183", "filename": "libgo/go/cmd/internal/objabi/symkind.go", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fsymkind.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fsymkind.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fsymkind.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -60,6 +60,13 @@ const (\n \tSDWARFRANGE\n \tSDWARFLOC\n \tSDWARFMISC\n+\t// ABI alias. An ABI alias symbol is an empty symbol with a\n+\t// single relocation with 0 size that references the native\n+\t// function implementation symbol.\n+\t//\n+\t// TODO(austin): Remove this and all uses once the compiler\n+\t// generates real ABI wrappers rather than symbol aliases.\n+\tSABIALIAS\n \t// Update cmd/link/internal/sym/AbiSymKindToSymKind for new SymKind values.\n \n )"}, {"sha": "2b9a9080e8c0fb6e49af9e1159da1946dbfba2bf", "filename": "libgo/go/cmd/internal/objabi/symkind_string.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fsymkind_string.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fsymkind_string.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fsymkind_string.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -4,9 +4,9 @@ package objabi\n \n import \"strconv\"\n \n-const _SymKind_name = \"SxxxSTEXTSRODATASNOPTRDATASDATASBSSSNOPTRBSSSTLSBSSSDWARFINFOSDWARFRANGESDWARFLOCSDWARFMISC\"\n+const _SymKind_name = \"SxxxSTEXTSRODATASNOPTRDATASDATASBSSSNOPTRBSSSTLSBSSSDWARFINFOSDWARFRANGESDWARFLOCSDWARFMISCSABIALIAS\"\n \n-var _SymKind_index = [...]uint8{0, 4, 9, 16, 26, 31, 35, 44, 51, 61, 72, 81, 91}\n+var _SymKind_index = [...]uint8{0, 4, 9, 16, 26, 31, 35, 44, 51, 61, 72, 81, 91, 100}\n \n func (i SymKind) String() string {\n \tif i >= SymKind(len(_SymKind_index)-1) {"}, {"sha": "da49f706f603384a976395e93e0ee0bfaad09d75", "filename": "libgo/go/cmd/internal/objabi/util.go", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Futil.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Futil.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Futil.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -76,7 +76,7 @@ func init() {\n }\n \n func Framepointer_enabled(goos, goarch string) bool {\n-\treturn framepointer_enabled != 0 && goarch == \"amd64\" && goos != \"nacl\"\n+\treturn framepointer_enabled != 0 && (goarch == \"amd64\" && goos != \"nacl\" || goarch == \"arm64\" && goos == \"linux\")\n }\n \n func addexp(s string) {\n@@ -104,8 +104,6 @@ var (\n \tframepointer_enabled     int = 1\n \tFieldtrack_enabled       int\n \tPreemptibleloops_enabled int\n-\tClobberdead_enabled      int\n-\tDebugCPU_enabled         int\n )\n \n // Toolchain experiments.\n@@ -119,8 +117,6 @@ var exper = []struct {\n \t{\"fieldtrack\", &Fieldtrack_enabled},\n \t{\"framepointer\", &framepointer_enabled},\n \t{\"preemptibleloops\", &Preemptibleloops_enabled},\n-\t{\"clobberdead\", &Clobberdead_enabled},\n-\t{\"debugcpu\", &DebugCPU_enabled},\n }\n \n var defaultExpstring = Expstring()"}, {"sha": "487c9260e8576a325ff8597de0bf19bdec564387", "filename": "libgo/go/cmd/internal/sys/arch.go", "status": "added", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Finternal%2Fsys%2Farch.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Finternal%2Fsys%2Farch.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fsys%2Farch.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -0,0 +1,187 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package sys\n+\n+import \"encoding/binary\"\n+\n+// ArchFamily represents a family of one or more related architectures.\n+// For example, amd64 and amd64p32 are both members of the AMD64 family,\n+// and ppc64 and ppc64le are both members of the PPC64 family.\n+type ArchFamily byte\n+\n+const (\n+\tNoArch ArchFamily = iota\n+\tAMD64\n+\tARM\n+\tARM64\n+\tI386\n+\tMIPS\n+\tMIPS64\n+\tPPC64\n+\tS390X\n+\tWasm\n+)\n+\n+// Arch represents an individual architecture.\n+type Arch struct {\n+\tName   string\n+\tFamily ArchFamily\n+\n+\tByteOrder binary.ByteOrder\n+\n+\t// PtrSize is the size in bytes of pointers and the\n+\t// predeclared \"int\", \"uint\", and \"uintptr\" types.\n+\tPtrSize int\n+\n+\t// RegSize is the size in bytes of general purpose registers.\n+\tRegSize int\n+\n+\t// MinLC is the minimum length of an instruction code.\n+\tMinLC int\n+}\n+\n+// InFamily reports whether a is a member of any of the specified\n+// architecture families.\n+func (a *Arch) InFamily(xs ...ArchFamily) bool {\n+\tfor _, x := range xs {\n+\t\tif a.Family == x {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n+var Arch386 = &Arch{\n+\tName:      \"386\",\n+\tFamily:    I386,\n+\tByteOrder: binary.LittleEndian,\n+\tPtrSize:   4,\n+\tRegSize:   4,\n+\tMinLC:     1,\n+}\n+\n+var ArchAMD64 = &Arch{\n+\tName:      \"amd64\",\n+\tFamily:    AMD64,\n+\tByteOrder: binary.LittleEndian,\n+\tPtrSize:   8,\n+\tRegSize:   8,\n+\tMinLC:     1,\n+}\n+\n+var ArchAMD64P32 = &Arch{\n+\tName:      \"amd64p32\",\n+\tFamily:    AMD64,\n+\tByteOrder: binary.LittleEndian,\n+\tPtrSize:   4,\n+\tRegSize:   8,\n+\tMinLC:     1,\n+}\n+\n+var ArchARM = &Arch{\n+\tName:      \"arm\",\n+\tFamily:    ARM,\n+\tByteOrder: binary.LittleEndian,\n+\tPtrSize:   4,\n+\tRegSize:   4,\n+\tMinLC:     4,\n+}\n+\n+var ArchARM64 = &Arch{\n+\tName:      \"arm64\",\n+\tFamily:    ARM64,\n+\tByteOrder: binary.LittleEndian,\n+\tPtrSize:   8,\n+\tRegSize:   8,\n+\tMinLC:     4,\n+}\n+\n+var ArchMIPS = &Arch{\n+\tName:      \"mips\",\n+\tFamily:    MIPS,\n+\tByteOrder: binary.BigEndian,\n+\tPtrSize:   4,\n+\tRegSize:   4,\n+\tMinLC:     4,\n+}\n+\n+var ArchMIPSLE = &Arch{\n+\tName:      \"mipsle\",\n+\tFamily:    MIPS,\n+\tByteOrder: binary.LittleEndian,\n+\tPtrSize:   4,\n+\tRegSize:   4,\n+\tMinLC:     4,\n+}\n+\n+var ArchMIPS64 = &Arch{\n+\tName:      \"mips64\",\n+\tFamily:    MIPS64,\n+\tByteOrder: binary.BigEndian,\n+\tPtrSize:   8,\n+\tRegSize:   8,\n+\tMinLC:     4,\n+}\n+\n+var ArchMIPS64LE = &Arch{\n+\tName:      \"mips64le\",\n+\tFamily:    MIPS64,\n+\tByteOrder: binary.LittleEndian,\n+\tPtrSize:   8,\n+\tRegSize:   8,\n+\tMinLC:     4,\n+}\n+\n+var ArchPPC64 = &Arch{\n+\tName:      \"ppc64\",\n+\tFamily:    PPC64,\n+\tByteOrder: binary.BigEndian,\n+\tPtrSize:   8,\n+\tRegSize:   8,\n+\tMinLC:     4,\n+}\n+\n+var ArchPPC64LE = &Arch{\n+\tName:      \"ppc64le\",\n+\tFamily:    PPC64,\n+\tByteOrder: binary.LittleEndian,\n+\tPtrSize:   8,\n+\tRegSize:   8,\n+\tMinLC:     4,\n+}\n+\n+var ArchS390X = &Arch{\n+\tName:      \"s390x\",\n+\tFamily:    S390X,\n+\tByteOrder: binary.BigEndian,\n+\tPtrSize:   8,\n+\tRegSize:   8,\n+\tMinLC:     2,\n+}\n+\n+var ArchWasm = &Arch{\n+\tName:      \"wasm\",\n+\tFamily:    Wasm,\n+\tByteOrder: binary.LittleEndian,\n+\tPtrSize:   8,\n+\tRegSize:   8,\n+\tMinLC:     1,\n+}\n+\n+var Archs = [...]*Arch{\n+\tArch386,\n+\tArchAMD64,\n+\tArchAMD64P32,\n+\tArchARM,\n+\tArchARM64,\n+\tArchMIPS,\n+\tArchMIPSLE,\n+\tArchMIPS64,\n+\tArchMIPS64LE,\n+\tArchPPC64,\n+\tArchPPC64LE,\n+\tArchS390X,\n+\tArchWasm,\n+}"}, {"sha": "a53da6ed2cbebc993fc0704b9811fd82e59eedee", "filename": "libgo/go/cmd/internal/sys/supported.go", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Finternal%2Fsys%2Fsupported.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Finternal%2Fsys%2Fsupported.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fsys%2Fsupported.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package sys\n+\n+// RaceDetectorSupported reports whether goos/goarch supports the race\n+// detector. There is a copy of this function in cmd/dist/test.go.\n+func RaceDetectorSupported(goos, goarch string) bool {\n+\tswitch goos {\n+\tcase \"linux\":\n+\t\treturn goarch == \"amd64\" || goarch == \"ppc64le\" || goarch == \"arm64\"\n+\tcase \"darwin\", \"freebsd\", \"netbsd\", \"windows\":\n+\t\treturn goarch == \"amd64\"\n+\tdefault:\n+\t\treturn false\n+\t}\n+}\n+\n+// MSanSupported reports whether goos/goarch supports the memory\n+// sanitizer option. There is a copy of this function in cmd/dist/test.go.\n+func MSanSupported(goos, goarch string) bool {\n+\tswitch goos {\n+\tcase \"linux\":\n+\t\treturn goarch == \"amd64\" || goarch == \"arm64\"\n+\tdefault:\n+\t\treturn false\n+\t}\n+}"}, {"sha": "2500c690bfd6ebf2ab9c20906f0c1ac8ae0aa292", "filename": "libgo/go/cmd/vet/all/main.go", "status": "modified", "additions": 81, "deletions": 13, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fmain.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -7,6 +7,9 @@\n // The vet/all command runs go vet on the standard library and commands.\n // It compares the output against a set of whitelists\n // maintained in the whitelist directory.\n+//\n+// This program attempts to build packages from golang.org/x/tools,\n+// which must be in your GOPATH.\n package main\n \n import (\n@@ -18,6 +21,7 @@ import (\n \t\"go/types\"\n \t\"internal/testenv\"\n \t\"io\"\n+\t\"io/ioutil\"\n \t\"log\"\n \t\"os\"\n \t\"os/exec\"\n@@ -192,9 +196,21 @@ func vetPlatforms(pp []platform) {\n }\n \n func (p platform) vet() {\n-\tif p.os == \"linux\" && p.arch == \"riscv64\" {\n-\t\t// TODO(tklauser): enable as soon as the riscv64 port has fully landed\n-\t\tfmt.Println(\"skipping linux/riscv64\")\n+\tif p.os == \"linux\" && (p.arch == \"riscv64\" || p.arch == \"sparc64\") {\n+\t\t// TODO(tklauser): enable as soon as these ports have fully landed\n+\t\tfmt.Printf(\"skipping %s/%s\\n\", p.os, p.arch)\n+\t\treturn\n+\t}\n+\n+\tif p.os == \"windows\" && p.arch == \"arm\" {\n+\t\t// TODO(jordanrh1): enable as soon as the windows/arm port has fully landed\n+\t\tfmt.Println(\"skipping windows/arm\")\n+\t\treturn\n+\t}\n+\n+\tif p.os == \"aix\" && p.arch == \"ppc64\" {\n+\t\t// TODO(aix): enable as soon as the aix/ppc64 port has fully landed\n+\t\tfmt.Println(\"skipping aix/ppc64\")\n \t\treturn\n \t}\n \n@@ -205,13 +221,36 @@ func (p platform) vet() {\n \tw := make(whitelist)\n \tw.load(p.os, p.arch)\n \n-\t// 'go tool vet .' is considerably faster than 'go vet ./...'\n+\ttmpdir, err := ioutil.TempDir(\"\", \"cmd-vet-all\")\n+\tif err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\tdefer os.RemoveAll(tmpdir)\n+\n+\t// Build the go/packages-based vet command from the x/tools\n+\t// repo. It is considerably faster than \"go vet\", which rebuilds\n+\t// the standard library.\n+\tvetTool := filepath.Join(tmpdir, \"vet\")\n+\tcmd := exec.Command(cmdGoPath, \"build\", \"-o\", vetTool, \"golang.org/x/tools/go/analysis/cmd/vet\")\n+\tcmd.Dir = filepath.Join(runtime.GOROOT(), \"src\")\n+\tcmd.Stderr = os.Stderr\n+\tcmd.Stdout = os.Stderr\n+\tif err := cmd.Run(); err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\n \t// TODO: The unsafeptr checks are disabled for now,\n \t// because there are so many false positives,\n \t// and no clear way to improve vet to eliminate large chunks of them.\n \t// And having them in the whitelists will just cause annoyance\n \t// and churn when working on the runtime.\n-\tcmd := exec.Command(cmdGoPath, \"tool\", \"vet\", \"-unsafeptr=false\", \"-source\", \".\")\n+\tcmd = exec.Command(vetTool,\n+\t\t\"-unsafeptr=0\",\n+\t\t\"-nilness=0\", // expensive, uses SSA\n+\t\t\"std\",\n+\t\t\"cmd/...\",\n+\t\t\"cmd/compile/internal/gc/testdata\",\n+\t)\n \tcmd.Dir = filepath.Join(runtime.GOROOT(), \"src\")\n \tcmd.Env = append(os.Environ(), \"GOOS=\"+p.os, \"GOARCH=\"+p.arch, \"CGO_ENABLED=0\")\n \tstderr, err := cmd.StderrPipe()\n@@ -231,6 +270,9 @@ NextLine:\n \t\tif strings.HasPrefix(line, \"vet: \") {\n \t\t\t// Typecheck failure: Malformed syntax or multiple packages or the like.\n \t\t\t// This will yield nicer error messages elsewhere, so ignore them here.\n+\n+\t\t\t// This includes warnings from asmdecl of the form:\n+\t\t\t//   \"vet: foo.s:16: [amd64] cannot check cross-package assembly function\"\n \t\t\tcontinue\n \t\t}\n \n@@ -242,22 +284,48 @@ NextLine:\n \t\t\tio.Copy(os.Stderr, stderr)\n \t\t\tbreak\n \t\t}\n+\t\tif strings.HasPrefix(line, \"# \") {\n+\t\t\t// 'go vet' prefixes the output of each vet invocation by a comment:\n+\t\t\t//    # [package]\n+\t\t\tcontinue\n+\t\t}\n \n-\t\tfields := strings.SplitN(line, \":\", 3)\n+\t\t// Parse line.\n+\t\t// Assume the part before the first \": \"\n+\t\t// is the \"file:line:col: \" information.\n+\t\t// TODO(adonovan): parse vet -json output.\n \t\tvar file, lineno, msg string\n-\t\tswitch len(fields) {\n-\t\tcase 2:\n-\t\t\t// vet message with no line number\n-\t\t\tfile, msg = fields[0], fields[1]\n-\t\tcase 3:\n-\t\t\tfile, lineno, msg = fields[0], fields[1], fields[2]\n-\t\tdefault:\n+\t\tif i := strings.Index(line, \": \"); i >= 0 {\n+\t\t\tmsg = line[i+len(\": \"):]\n+\n+\t\t\twords := strings.Split(line[:i], \":\")\n+\t\t\tswitch len(words) {\n+\t\t\tcase 3:\n+\t\t\t\t_ = words[2] // ignore column\n+\t\t\t\tfallthrough\n+\t\t\tcase 2:\n+\t\t\t\tlineno = words[1]\n+\t\t\t\tfallthrough\n+\t\t\tcase 1:\n+\t\t\t\tfile = words[0]\n+\n+\t\t\t\t// Make the file name relative to GOROOT/src.\n+\t\t\t\tif rel, err := filepath.Rel(cmd.Dir, file); err == nil {\n+\t\t\t\t\tfile = rel\n+\t\t\t\t}\n+\t\t\tdefault:\n+\t\t\t\t// error: too many columns\n+\t\t\t}\n+\t\t}\n+\t\tif file == \"\" {\n \t\t\tif !parseFailed {\n \t\t\t\tparseFailed = true\n \t\t\t\tfmt.Fprintf(os.Stderr, \"failed to parse %s vet output:\\n\", p)\n \t\t\t}\n \t\t\tfmt.Fprintln(os.Stderr, line)\n+\t\t\tcontinue\n \t\t}\n+\n \t\tmsg = strings.TrimSpace(msg)\n \n \t\tfor _, ignore := range ignorePathPrefixes {"}, {"sha": "223e80d400710b243e6981530bd01bcf799040e2", "filename": "libgo/go/cmd/vet/assign.go", "status": "removed", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Fassign.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Fassign.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fassign.go?ref=225220d668dafb8262db7012bced688acbe63b33", "patch": "@@ -1,52 +0,0 @@\n-// Copyright 2013 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-/*\n-This file contains the code to check for useless assignments.\n-*/\n-\n-package main\n-\n-import (\n-\t\"go/ast\"\n-\t\"go/token\"\n-\t\"reflect\"\n-)\n-\n-func init() {\n-\tregister(\"assign\",\n-\t\t\"check for useless assignments\",\n-\t\tcheckAssignStmt,\n-\t\tassignStmt)\n-}\n-\n-// TODO: should also check for assignments to struct fields inside methods\n-// that are on T instead of *T.\n-\n-// checkAssignStmt checks for assignments of the form \"<expr> = <expr>\".\n-// These are almost always useless, and even when they aren't they are usually a mistake.\n-func checkAssignStmt(f *File, node ast.Node) {\n-\tstmt := node.(*ast.AssignStmt)\n-\tif stmt.Tok != token.ASSIGN {\n-\t\treturn // ignore :=\n-\t}\n-\tif len(stmt.Lhs) != len(stmt.Rhs) {\n-\t\t// If LHS and RHS have different cardinality, they can't be the same.\n-\t\treturn\n-\t}\n-\tfor i, lhs := range stmt.Lhs {\n-\t\trhs := stmt.Rhs[i]\n-\t\tif hasSideEffects(f, lhs) || hasSideEffects(f, rhs) {\n-\t\t\tcontinue // expressions may not be equal\n-\t\t}\n-\t\tif reflect.TypeOf(lhs) != reflect.TypeOf(rhs) {\n-\t\t\tcontinue // short-circuit the heavy-weight gofmt check\n-\t\t}\n-\t\tle := f.gofmt(lhs)\n-\t\tre := f.gofmt(rhs)\n-\t\tif le == re {\n-\t\t\tf.Badf(stmt.Pos(), \"self-assignment of %s to %s\", re, le)\n-\t\t}\n-\t}\n-}"}, {"sha": "b425669e1ae0573661a52b72503b040408c6864c", "filename": "libgo/go/cmd/vet/atomic.go", "status": "removed", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Fatomic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Fatomic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fatomic.go?ref=225220d668dafb8262db7012bced688acbe63b33", "patch": "@@ -1,71 +0,0 @@\n-// Copyright 2013 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package main\n-\n-import (\n-\t\"go/ast\"\n-\t\"go/token\"\n-\t\"go/types\"\n-)\n-\n-func init() {\n-\tregister(\"atomic\",\n-\t\t\"check for common mistaken usages of the sync/atomic package\",\n-\t\tcheckAtomicAssignment,\n-\t\tassignStmt)\n-}\n-\n-// checkAtomicAssignment walks the assignment statement checking for common\n-// mistaken usage of atomic package, such as: x = atomic.AddUint64(&x, 1)\n-func checkAtomicAssignment(f *File, node ast.Node) {\n-\tn := node.(*ast.AssignStmt)\n-\tif len(n.Lhs) != len(n.Rhs) {\n-\t\treturn\n-\t}\n-\tif len(n.Lhs) == 1 && n.Tok == token.DEFINE {\n-\t\treturn\n-\t}\n-\n-\tfor i, right := range n.Rhs {\n-\t\tcall, ok := right.(*ast.CallExpr)\n-\t\tif !ok {\n-\t\t\tcontinue\n-\t\t}\n-\t\tsel, ok := call.Fun.(*ast.SelectorExpr)\n-\t\tif !ok {\n-\t\t\tcontinue\n-\t\t}\n-\t\tpkgIdent, _ := sel.X.(*ast.Ident)\n-\t\tpkgName, ok := f.pkg.uses[pkgIdent].(*types.PkgName)\n-\t\tif !ok || pkgName.Imported().Path() != \"sync/atomic\" {\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tswitch sel.Sel.Name {\n-\t\tcase \"AddInt32\", \"AddInt64\", \"AddUint32\", \"AddUint64\", \"AddUintptr\":\n-\t\t\tf.checkAtomicAddAssignment(n.Lhs[i], call)\n-\t\t}\n-\t}\n-}\n-\n-// checkAtomicAddAssignment walks the atomic.Add* method calls checking for assigning the return value\n-// to the same variable being used in the operation\n-func (f *File) checkAtomicAddAssignment(left ast.Expr, call *ast.CallExpr) {\n-\tif len(call.Args) != 2 {\n-\t\treturn\n-\t}\n-\targ := call.Args[0]\n-\tbroken := false\n-\n-\tif uarg, ok := arg.(*ast.UnaryExpr); ok && uarg.Op == token.AND {\n-\t\tbroken = f.gofmt(left) == f.gofmt(uarg.X)\n-\t} else if star, ok := left.(*ast.StarExpr); ok {\n-\t\tbroken = f.gofmt(star.X) == f.gofmt(arg)\n-\t}\n-\n-\tif broken {\n-\t\tf.Bad(left.Pos(), \"direct assignment to atomic value\")\n-\t}\n-}"}, {"sha": "ba3a361b9113bb01d547d8614da0586afb865b1f", "filename": "libgo/go/cmd/vet/buildtag.go", "status": "removed", "additions": 0, "deletions": 126, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Fbuildtag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Fbuildtag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fbuildtag.go?ref=225220d668dafb8262db7012bced688acbe63b33", "patch": "@@ -1,126 +0,0 @@\n-// Copyright 2013 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package main\n-\n-import (\n-\t\"bytes\"\n-\t\"fmt\"\n-\t\"os\"\n-\t\"strings\"\n-\t\"unicode\"\n-)\n-\n-var (\n-\tnl         = []byte(\"\\n\")\n-\tslashSlash = []byte(\"//\")\n-\tplusBuild  = []byte(\"+build\")\n-)\n-\n-func badfLine(f *File, line int, format string, args ...interface{}) {\n-\tmsg := fmt.Sprintf(format, args...)\n-\tfmt.Fprintf(os.Stderr, \"%s:%d: %s\\n\", f.name, line, msg)\n-\tsetExit(1)\n-}\n-\n-// checkBuildTag checks that build tags are in the correct location and well-formed.\n-func checkBuildTag(f *File) {\n-\tif !vet(\"buildtags\") {\n-\t\treturn\n-\t}\n-\n-\t// we must look at the raw lines, as build tags may appear in non-Go\n-\t// files such as assembly files.\n-\tlines := bytes.SplitAfter(f.content, nl)\n-\n-\t// lineWithComment reports whether a line corresponds to a comment in\n-\t// the source file. If the source file wasn't Go, the function always\n-\t// returns true.\n-\tlineWithComment := func(line int) bool {\n-\t\tif f.file == nil {\n-\t\t\t// Current source file is not Go, so be conservative.\n-\t\t\treturn true\n-\t\t}\n-\t\tfor _, group := range f.file.Comments {\n-\t\t\tstartLine := f.fset.Position(group.Pos()).Line\n-\t\t\tendLine := f.fset.Position(group.End()).Line\n-\t\t\tif startLine <= line && line <= endLine {\n-\t\t\t\treturn true\n-\t\t\t}\n-\t\t}\n-\t\treturn false\n-\t}\n-\n-\t// Determine cutpoint where +build comments are no longer valid.\n-\t// They are valid in leading // comments in the file followed by\n-\t// a blank line.\n-\tvar cutoff int\n-\tfor i, line := range lines {\n-\t\tline = bytes.TrimSpace(line)\n-\t\tif len(line) == 0 {\n-\t\t\tcutoff = i\n-\t\t\tcontinue\n-\t\t}\n-\t\tif bytes.HasPrefix(line, slashSlash) {\n-\t\t\tcontinue\n-\t\t}\n-\t\tbreak\n-\t}\n-\n-\tfor i, line := range lines {\n-\t\tline = bytes.TrimSpace(line)\n-\t\tif !bytes.HasPrefix(line, slashSlash) {\n-\t\t\tcontinue\n-\t\t}\n-\t\tif !bytes.Contains(line, plusBuild) {\n-\t\t\t// Check that the comment contains \"+build\" early, to\n-\t\t\t// avoid unnecessary lineWithComment calls that may\n-\t\t\t// incur linear searches.\n-\t\t\tcontinue\n-\t\t}\n-\t\tif !lineWithComment(i + 1) {\n-\t\t\t// This is a line in a Go source file that looks like a\n-\t\t\t// comment, but actually isn't - such as part of a raw\n-\t\t\t// string.\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\ttext := bytes.TrimSpace(line[2:])\n-\t\tif bytes.HasPrefix(text, plusBuild) {\n-\t\t\tfields := bytes.Fields(text)\n-\t\t\tif !bytes.Equal(fields[0], plusBuild) {\n-\t\t\t\t// Comment is something like +buildasdf not +build.\n-\t\t\t\tbadfLine(f, i+1, \"possible malformed +build comment\")\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tif i >= cutoff {\n-\t\t\t\tbadfLine(f, i+1, \"+build comment must appear before package clause and be followed by a blank line\")\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\t// Check arguments.\n-\t\tArgs:\n-\t\t\tfor _, arg := range fields[1:] {\n-\t\t\t\tfor _, elem := range strings.Split(string(arg), \",\") {\n-\t\t\t\t\tif strings.HasPrefix(elem, \"!!\") {\n-\t\t\t\t\t\tbadfLine(f, i+1, \"invalid double negative in build constraint: %s\", arg)\n-\t\t\t\t\t\tbreak Args\n-\t\t\t\t\t}\n-\t\t\t\t\telem = strings.TrimPrefix(elem, \"!\")\n-\t\t\t\t\tfor _, c := range elem {\n-\t\t\t\t\t\tif !unicode.IsLetter(c) && !unicode.IsDigit(c) && c != '_' && c != '.' {\n-\t\t\t\t\t\t\tbadfLine(f, i+1, \"invalid non-alphanumeric build constraint: %s\", arg)\n-\t\t\t\t\t\t\tbreak Args\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tcontinue\n-\t\t}\n-\t\t// Comment with +build but not at beginning.\n-\t\tif i < cutoff {\n-\t\t\tbadfLine(f, i+1, \"possible malformed +build comment\")\n-\t\t\tcontinue\n-\t\t}\n-\t}\n-}"}, {"sha": "76364ff6ed8bec5cf26c143828f9cc1717780ff8", "filename": "libgo/go/cmd/vet/cgo.go", "status": "removed", "additions": 0, "deletions": 141, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Fcgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Fcgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fcgo.go?ref=225220d668dafb8262db7012bced688acbe63b33", "patch": "@@ -1,141 +0,0 @@\n-// Copyright 2015 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Check for invalid cgo pointer passing.\n-// This looks for code that uses cgo to call C code passing values\n-// whose types are almost always invalid according to the cgo pointer\n-// sharing rules.\n-// Specifically, it warns about attempts to pass a Go chan, map, func,\n-// or slice to C, either directly, or via a pointer, array, or struct.\n-\n-package main\n-\n-import (\n-\t\"go/ast\"\n-\t\"go/token\"\n-\t\"go/types\"\n-)\n-\n-func init() {\n-\tregister(\"cgocall\",\n-\t\t\"check for types that may not be passed to cgo calls\",\n-\t\tcheckCgoCall,\n-\t\tcallExpr)\n-}\n-\n-func checkCgoCall(f *File, node ast.Node) {\n-\tx := node.(*ast.CallExpr)\n-\n-\t// We are only looking for calls to functions imported from\n-\t// the \"C\" package.\n-\tsel, ok := x.Fun.(*ast.SelectorExpr)\n-\tif !ok {\n-\t\treturn\n-\t}\n-\tid, ok := sel.X.(*ast.Ident)\n-\tif !ok {\n-\t\treturn\n-\t}\n-\n-\tpkgname, ok := f.pkg.uses[id].(*types.PkgName)\n-\tif !ok || pkgname.Imported().Path() != \"C\" {\n-\t\treturn\n-\t}\n-\n-\t// A call to C.CBytes passes a pointer but is always safe.\n-\tif sel.Sel.Name == \"CBytes\" {\n-\t\treturn\n-\t}\n-\n-\tfor _, arg := range x.Args {\n-\t\tif !typeOKForCgoCall(cgoBaseType(f, arg), make(map[types.Type]bool)) {\n-\t\t\tf.Badf(arg.Pos(), \"possibly passing Go type with embedded pointer to C\")\n-\t\t}\n-\n-\t\t// Check for passing the address of a bad type.\n-\t\tif conv, ok := arg.(*ast.CallExpr); ok && len(conv.Args) == 1 && f.hasBasicType(conv.Fun, types.UnsafePointer) {\n-\t\t\targ = conv.Args[0]\n-\t\t}\n-\t\tif u, ok := arg.(*ast.UnaryExpr); ok && u.Op == token.AND {\n-\t\t\tif !typeOKForCgoCall(cgoBaseType(f, u.X), make(map[types.Type]bool)) {\n-\t\t\t\tf.Badf(arg.Pos(), \"possibly passing Go type with embedded pointer to C\")\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-// cgoBaseType tries to look through type conversions involving\n-// unsafe.Pointer to find the real type. It converts:\n-//   unsafe.Pointer(x) => x\n-//   *(*unsafe.Pointer)(unsafe.Pointer(&x)) => x\n-func cgoBaseType(f *File, arg ast.Expr) types.Type {\n-\tswitch arg := arg.(type) {\n-\tcase *ast.CallExpr:\n-\t\tif len(arg.Args) == 1 && f.hasBasicType(arg.Fun, types.UnsafePointer) {\n-\t\t\treturn cgoBaseType(f, arg.Args[0])\n-\t\t}\n-\tcase *ast.StarExpr:\n-\t\tcall, ok := arg.X.(*ast.CallExpr)\n-\t\tif !ok || len(call.Args) != 1 {\n-\t\t\tbreak\n-\t\t}\n-\t\t// Here arg is *f(v).\n-\t\tt := f.pkg.types[call.Fun].Type\n-\t\tif t == nil {\n-\t\t\tbreak\n-\t\t}\n-\t\tptr, ok := t.Underlying().(*types.Pointer)\n-\t\tif !ok {\n-\t\t\tbreak\n-\t\t}\n-\t\t// Here arg is *(*p)(v)\n-\t\telem, ok := ptr.Elem().Underlying().(*types.Basic)\n-\t\tif !ok || elem.Kind() != types.UnsafePointer {\n-\t\t\tbreak\n-\t\t}\n-\t\t// Here arg is *(*unsafe.Pointer)(v)\n-\t\tcall, ok = call.Args[0].(*ast.CallExpr)\n-\t\tif !ok || len(call.Args) != 1 {\n-\t\t\tbreak\n-\t\t}\n-\t\t// Here arg is *(*unsafe.Pointer)(f(v))\n-\t\tif !f.hasBasicType(call.Fun, types.UnsafePointer) {\n-\t\t\tbreak\n-\t\t}\n-\t\t// Here arg is *(*unsafe.Pointer)(unsafe.Pointer(v))\n-\t\tu, ok := call.Args[0].(*ast.UnaryExpr)\n-\t\tif !ok || u.Op != token.AND {\n-\t\t\tbreak\n-\t\t}\n-\t\t// Here arg is *(*unsafe.Pointer)(unsafe.Pointer(&v))\n-\t\treturn cgoBaseType(f, u.X)\n-\t}\n-\n-\treturn f.pkg.types[arg].Type\n-}\n-\n-// typeOKForCgoCall reports whether the type of arg is OK to pass to a\n-// C function using cgo. This is not true for Go types with embedded\n-// pointers. m is used to avoid infinite recursion on recursive types.\n-func typeOKForCgoCall(t types.Type, m map[types.Type]bool) bool {\n-\tif t == nil || m[t] {\n-\t\treturn true\n-\t}\n-\tm[t] = true\n-\tswitch t := t.Underlying().(type) {\n-\tcase *types.Chan, *types.Map, *types.Signature, *types.Slice:\n-\t\treturn false\n-\tcase *types.Pointer:\n-\t\treturn typeOKForCgoCall(t.Elem(), m)\n-\tcase *types.Array:\n-\t\treturn typeOKForCgoCall(t.Elem(), m)\n-\tcase *types.Struct:\n-\t\tfor i := 0; i < t.NumFields(); i++ {\n-\t\t\tif !typeOKForCgoCall(t.Field(i).Type(), m) {\n-\t\t\t\treturn false\n-\t\t\t}\n-\t\t}\n-\t}\n-\treturn true\n-}"}, {"sha": "861e040aac4e529bb6be21a5c211508fae2c64b1", "filename": "libgo/go/cmd/vet/composite.go", "status": "removed", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Fcomposite.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Fcomposite.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fcomposite.go?ref=225220d668dafb8262db7012bced688acbe63b33", "patch": "@@ -1,86 +0,0 @@\n-// Copyright 2012 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// This file contains the test for unkeyed struct literals.\n-\n-package main\n-\n-import (\n-\t\"cmd/vet/internal/whitelist\"\n-\t\"flag\"\n-\t\"go/ast\"\n-\t\"go/types\"\n-\t\"strings\"\n-)\n-\n-var compositeWhiteList = flag.Bool(\"compositewhitelist\", true, \"use composite white list; for testing only\")\n-\n-func init() {\n-\tregister(\"composites\",\n-\t\t\"check that composite literals of types from imported packages use field-keyed elements\",\n-\t\tcheckUnkeyedLiteral,\n-\t\tcompositeLit)\n-}\n-\n-// checkUnkeyedLiteral checks if a composite literal is a struct literal with\n-// unkeyed fields.\n-func checkUnkeyedLiteral(f *File, node ast.Node) {\n-\tcl := node.(*ast.CompositeLit)\n-\n-\ttyp := f.pkg.types[cl].Type\n-\tif typ == nil {\n-\t\t// cannot determine composite literals' type, skip it\n-\t\treturn\n-\t}\n-\ttypeName := typ.String()\n-\tif *compositeWhiteList && whitelist.UnkeyedLiteral[typeName] {\n-\t\t// skip whitelisted types\n-\t\treturn\n-\t}\n-\tunder := typ.Underlying()\n-\tfor {\n-\t\tptr, ok := under.(*types.Pointer)\n-\t\tif !ok {\n-\t\t\tbreak\n-\t\t}\n-\t\tunder = ptr.Elem().Underlying()\n-\t}\n-\tif _, ok := under.(*types.Struct); !ok {\n-\t\t// skip non-struct composite literals\n-\t\treturn\n-\t}\n-\tif isLocalType(f, typ) {\n-\t\t// allow unkeyed locally defined composite literal\n-\t\treturn\n-\t}\n-\n-\t// check if the CompositeLit contains an unkeyed field\n-\tallKeyValue := true\n-\tfor _, e := range cl.Elts {\n-\t\tif _, ok := e.(*ast.KeyValueExpr); !ok {\n-\t\t\tallKeyValue = false\n-\t\t\tbreak\n-\t\t}\n-\t}\n-\tif allKeyValue {\n-\t\t// all the composite literal fields are keyed\n-\t\treturn\n-\t}\n-\n-\tf.Badf(cl.Pos(), \"%s composite literal uses unkeyed fields\", typeName)\n-}\n-\n-func isLocalType(f *File, typ types.Type) bool {\n-\tswitch x := typ.(type) {\n-\tcase *types.Struct:\n-\t\t// struct literals are local types\n-\t\treturn true\n-\tcase *types.Pointer:\n-\t\treturn isLocalType(f, x.Elem())\n-\tcase *types.Named:\n-\t\t// names in package foo are local to foo_test too\n-\t\treturn strings.TrimSuffix(x.Obj().Pkg().Path(), \"_test\") == strings.TrimSuffix(f.pkg.path, \"_test\")\n-\t}\n-\treturn false\n-}"}, {"sha": "279d081be39c93ffc6c361f762c8eafebbf05b22", "filename": "libgo/go/cmd/vet/doc.go", "status": "modified", "additions": 48, "deletions": 196, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fdoc.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2010 The Go Authors. All rights reserved.\n+// Copyright 2018 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n@@ -9,211 +9,63 @@ calls whose arguments do not align with the format string. Vet uses heuristics\n that do not guarantee all reports are genuine problems, but it can find errors\n not caught by the compilers.\n \n-Vet is normally invoked using the go command by running \"go vet\":\n+Vet is normally invoked through the go command.\n+This command vets the package in the current directory:\n \n \tgo vet\n-vets the package in the current directory.\n \n-\tgo vet package/path/name\n-vets the package whose path is provided.\n+whereas this one vets the packages whose path is provided:\n+\n+\tgo vet my/project/...\n \n Use \"go help packages\" to see other ways of specifying which packages to vet.\n \n-Vet's exit code is 2 for erroneous invocation of the tool, 1 if a\n+Vet's exit code is non-zero for erroneous invocation of the tool or if a\n problem was reported, and 0 otherwise. Note that the tool does not\n-check every possible problem and depends on unreliable heuristics\n+check every possible problem and depends on unreliable heuristics,\n so it should be used as guidance only, not as a firm indicator of\n program correctness.\n \n-By default the -all flag is set so all checks are performed.\n-If any flags are explicitly set to true, only those tests are run. Conversely, if\n-any flag is explicitly set to false, only those tests are disabled.  Thus -printf=true\n-runs the printf check, -printf=false runs all checks except the printf check.\n-\n-By default vet uses the object files generated by 'go install some/pkg' to typecheck the code.\n-If the -source flag is provided, vet uses only source code.\n-\n-Available checks:\n-\n-Assembly declarations\n-\n-Flag: -asmdecl\n-\n-Mismatches between assembly files and Go function declarations.\n-\n-Useless assignments\n-\n-Flag: -assign\n-\n-Check for useless assignments.\n-\n-Atomic mistakes\n-\n-Flag: -atomic\n-\n-Common mistaken usages of the sync/atomic package.\n-\n-Boolean conditions\n-\n-Flag: -bool\n-\n-Mistakes involving boolean operators.\n-\n-Build tags\n-\n-Flag: -buildtags\n-\n-Badly formed or misplaced +build tags.\n-\n-Invalid uses of cgo\n-\n-Flag: -cgocall\n-\n-Detect some violations of the cgo pointer passing rules.\n-\n-Unkeyed composite literals\n-\n-Flag: -composites\n-\n-Composite struct literals that do not use the field-keyed syntax.\n-\n-Copying locks\n-\n-Flag: -copylocks\n-\n-Locks that are erroneously passed by value.\n-\n-HTTP responses used incorrectly\n-\n-Flag: -httpresponse\n-\n-Mistakes deferring a function call on an HTTP response before\n-checking whether the error returned with the response was nil.\n-\n-Failure to call the cancelation function returned by WithCancel\n-\n-Flag: -lostcancel\n-\n-The cancelation function returned by context.WithCancel, WithTimeout,\n-and WithDeadline must be called or the new context will remain live\n-until its parent context is cancelled.\n-(The background context is never cancelled.)\n-\n-Methods\n-\n-Flag: -methods\n-\n-Non-standard signatures for methods with familiar names, including:\n-\tFormat GobEncode GobDecode MarshalJSON MarshalXML\n-\tPeek ReadByte ReadFrom ReadRune Scan Seek\n-\tUnmarshalJSON UnreadByte UnreadRune WriteByte\n-\tWriteTo\n-\n-Nil function comparison\n-\n-Flag: -nilfunc\n-\n-Comparisons between functions and nil.\n-\n-Printf family\n-\n-Flag: -printf\n-\n-Suspicious calls to fmt.Print, fmt.Printf, and related functions.\n-The check applies to known functions (for example, those in package fmt)\n-as well as any detected wrappers of known functions.\n-\n-The -printfuncs flag specifies a comma-separated list of names of\n-additional known formatting functions. Each name can be of the form\n-pkg.Name or pkg.Type.Name, where pkg is a complete import path,\n-or else can be a case-insensitive unqualified identifier like \"errorf\".\n-If a listed name ends in f, the function is assumed to be Printf-like,\n-taking a format string before the argument list. Otherwise it is\n-assumed to be Print-like, taking a list of arguments with no format string.\n-\n-Range loop variables\n-\n-Flag: -rangeloops\n-\n-Incorrect uses of range loop variables in closures.\n-\n-Shadowed variables\n-\n-Flag: -shadow=false (experimental; must be set explicitly)\n-\n-Variables that may have been unintentionally shadowed.\n-\n-Shifts\n-\n-Flag: -shift\n-\n-Shifts equal to or longer than the variable's length.\n-\n-Struct tags\n-\n-Flag: -structtags\n-\n-Struct tags that do not follow the format understood by reflect.StructTag.Get.\n-Well-known encoding struct tags (json, xml) used with unexported fields.\n-\n-Tests and documentation examples\n-\n-Flag: -tests\n-\n-Mistakes involving tests including functions with incorrect names or signatures\n-and example tests that document identifiers not in the package.\n-\n-Unreachable code\n-\n-Flag: -unreachable\n-\n-Unreachable code.\n-\n-Misuse of unsafe Pointers\n-\n-Flag: -unsafeptr\n-\n-Likely incorrect uses of unsafe.Pointer to convert integers to pointers.\n-A conversion from uintptr to unsafe.Pointer is invalid if it implies that\n-there is a uintptr-typed word in memory that holds a pointer value,\n-because that word will be invisible to stack copying and to the garbage\n-collector.\n-\n-Unused result of certain function calls\n-\n-Flag: -unusedresult\n-\n-Calls to well-known functions and methods that return a value that is\n-discarded.  By default, this includes functions like fmt.Errorf and\n-fmt.Sprintf and methods like String and Error. The flags -unusedfuncs\n-and -unusedstringmethods control the set.\n-\n-Other flags\n-\n-These flags configure the behavior of vet:\n-\n-\t-all (default true)\n-\t\tEnable all non-experimental checks.\n-\t-v\n-\t\tVerbose mode\n-\t-printfuncs\n-\t\tA comma-separated list of print-like function names\n-\t\tto supplement the standard list.\n-\t\tFor more information, see the discussion of the -printf flag.\n-\t-shadowstrict\n-\t\tWhether to be strict about shadowing; can be noisy.\n-\n-Using vet directly\n-\n-For testing and debugging vet can be run directly by invoking\n-\"go tool vet\" or just running the binary. Run this way, vet might not\n-have up to date information for imported packages.\n-\n-\tgo tool vet source/directory/*.go\n-vets the files named, all of which must be in the same package.\n-\n-\tgo tool vet source/directory\n-recursively descends the directory, vetting each package it finds.\n+To list the available checks, run \"go tool vet help\":\n+\n+    asmdecl      report mismatches between assembly files and Go declarations\n+    assign       check for useless assignments\n+    atomic       check for common mistakes using the sync/atomic package\n+    bools        check for common mistakes involving boolean operators\n+    buildtag     check that +build tags are well-formed and correctly located\n+    cgocall      detect some violations of the cgo pointer passing rules\n+    composites   check for unkeyed composite literals\n+    copylocks    check for locks erroneously passed by value\n+    httpresponse check for mistakes using HTTP responses\n+    loopclosure  check references to loop variables from within nested functions\n+    lostcancel   check cancel func returned by context.WithCancel is called\n+    nilfunc      check for useless comparisons between functions and nil\n+    printf       check consistency of Printf format strings and arguments\n+    shift        check for shifts that equal or exceed the width of the integer\n+    stdmethods   check signature of methods of well-known interfaces\n+    structtag    check that struct field tags conform to reflect.StructTag.Get\n+    tests        check for common mistaken usages of tests and examples\n+    unmarshal    report passing non-pointer or non-interface values to unmarshal\n+    unreachable  check for unreachable code\n+    unsafeptr    check for invalid conversions of uintptr to unsafe.Pointer\n+    unusedresult check for unused results of calls to some functions\n+\n+For details and flags of a particular check, such as printf, run \"go tool vet help printf\".\n+\n+By default, all checks are performed.\n+If any flags are explicitly set to true, only those tests are run.\n+Conversely, if any flag is explicitly set to false, only those tests are disabled.\n+Thus -printf=true runs the printf check,\n+and -printf=false runs all checks except the printf check.\n+\n+For information on writing a new check, see golang.org/x/tools/go/analysis.\n+\n+Core flags:\n+\n+  -c=N\n+    \tdisplay offending line plus N lines of surrounding context\n+  -json\n+    \temit analysis diagnostics (and errors) in JSON format\n \n */\n package main"}, {"sha": "791d11d5bdef047349a8fd9c5a8ff6f6360fe568", "filename": "libgo/go/cmd/vet/httpresponse.go", "status": "removed", "additions": 0, "deletions": 137, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Fhttpresponse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Fhttpresponse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fhttpresponse.go?ref=225220d668dafb8262db7012bced688acbe63b33", "patch": "@@ -1,137 +0,0 @@\n-// Copyright 2016 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// This file contains the check for http.Response values being used before\n-// checking for errors.\n-\n-package main\n-\n-import (\n-\t\"go/ast\"\n-\t\"go/types\"\n-)\n-\n-func init() {\n-\tregister(\"httpresponse\",\n-\t\t\"check errors are checked before using an http Response\",\n-\t\tcheckHTTPResponse, callExpr)\n-}\n-\n-func checkHTTPResponse(f *File, node ast.Node) {\n-\tcall := node.(*ast.CallExpr)\n-\tif !isHTTPFuncOrMethodOnClient(f, call) {\n-\t\treturn // the function call is not related to this check.\n-\t}\n-\n-\tfinder := &blockStmtFinder{node: call}\n-\tast.Walk(finder, f.file)\n-\tstmts := finder.stmts()\n-\tif len(stmts) < 2 {\n-\t\treturn // the call to the http function is the last statement of the block.\n-\t}\n-\n-\tasg, ok := stmts[0].(*ast.AssignStmt)\n-\tif !ok {\n-\t\treturn // the first statement is not assignment.\n-\t}\n-\tresp := rootIdent(asg.Lhs[0])\n-\tif resp == nil {\n-\t\treturn // could not find the http.Response in the assignment.\n-\t}\n-\n-\tdef, ok := stmts[1].(*ast.DeferStmt)\n-\tif !ok {\n-\t\treturn // the following statement is not a defer.\n-\t}\n-\troot := rootIdent(def.Call.Fun)\n-\tif root == nil {\n-\t\treturn // could not find the receiver of the defer call.\n-\t}\n-\n-\tif resp.Obj == root.Obj {\n-\t\tf.Badf(root.Pos(), \"using %s before checking for errors\", resp.Name)\n-\t}\n-}\n-\n-// isHTTPFuncOrMethodOnClient checks whether the given call expression is on\n-// either a function of the net/http package or a method of http.Client that\n-// returns (*http.Response, error).\n-func isHTTPFuncOrMethodOnClient(f *File, expr *ast.CallExpr) bool {\n-\tfun, _ := expr.Fun.(*ast.SelectorExpr)\n-\tsig, _ := f.pkg.types[fun].Type.(*types.Signature)\n-\tif sig == nil {\n-\t\treturn false // the call is not on of the form x.f()\n-\t}\n-\n-\tres := sig.Results()\n-\tif res.Len() != 2 {\n-\t\treturn false // the function called does not return two values.\n-\t}\n-\tif ptr, ok := res.At(0).Type().(*types.Pointer); !ok || !isNamedType(ptr.Elem(), \"net/http\", \"Response\") {\n-\t\treturn false // the first return type is not *http.Response.\n-\t}\n-\tif !types.Identical(res.At(1).Type().Underlying(), errorType) {\n-\t\treturn false // the second return type is not error\n-\t}\n-\n-\ttyp := f.pkg.types[fun.X].Type\n-\tif typ == nil {\n-\t\tid, ok := fun.X.(*ast.Ident)\n-\t\treturn ok && id.Name == \"http\" // function in net/http package.\n-\t}\n-\n-\tif isNamedType(typ, \"net/http\", \"Client\") {\n-\t\treturn true // method on http.Client.\n-\t}\n-\tptr, ok := typ.(*types.Pointer)\n-\treturn ok && isNamedType(ptr.Elem(), \"net/http\", \"Client\") // method on *http.Client.\n-}\n-\n-// blockStmtFinder is an ast.Visitor that given any ast node can find the\n-// statement containing it and its succeeding statements in the same block.\n-type blockStmtFinder struct {\n-\tnode  ast.Node       // target of search\n-\tstmt  ast.Stmt       // innermost statement enclosing argument to Visit\n-\tblock *ast.BlockStmt // innermost block enclosing argument to Visit.\n-}\n-\n-// Visit finds f.node performing a search down the ast tree.\n-// It keeps the last block statement and statement seen for later use.\n-func (f *blockStmtFinder) Visit(node ast.Node) ast.Visitor {\n-\tif node == nil || f.node.Pos() < node.Pos() || f.node.End() > node.End() {\n-\t\treturn nil // not here\n-\t}\n-\tswitch n := node.(type) {\n-\tcase *ast.BlockStmt:\n-\t\tf.block = n\n-\tcase ast.Stmt:\n-\t\tf.stmt = n\n-\t}\n-\tif f.node.Pos() == node.Pos() && f.node.End() == node.End() {\n-\t\treturn nil // found\n-\t}\n-\treturn f // keep looking\n-}\n-\n-// stmts returns the statements of f.block starting from the one including f.node.\n-func (f *blockStmtFinder) stmts() []ast.Stmt {\n-\tfor i, v := range f.block.List {\n-\t\tif f.stmt == v {\n-\t\t\treturn f.block.List[i:]\n-\t\t}\n-\t}\n-\treturn nil\n-}\n-\n-// rootIdent finds the root identifier x in a chain of selections x.y.z, or nil if not found.\n-func rootIdent(n ast.Node) *ast.Ident {\n-\tswitch n := n.(type) {\n-\tcase *ast.SelectorExpr:\n-\t\treturn rootIdent(n.X)\n-\tcase *ast.Ident:\n-\t\treturn n\n-\tdefault:\n-\t\treturn nil\n-\t}\n-}"}, {"sha": "2400fed6f4b2fc6c6012bbdc4f059ba29ff27870", "filename": "libgo/go/cmd/vet/internal/cfg/cfg_test.go", "status": "removed", "additions": 0, "deletions": 190, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Finternal%2Fcfg%2Fcfg_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Finternal%2Fcfg%2Fcfg_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Finternal%2Fcfg%2Fcfg_test.go?ref=225220d668dafb8262db7012bced688acbe63b33", "patch": "@@ -1,190 +0,0 @@\n-// Copyright 2016 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package cfg\n-\n-import (\n-\t\"bytes\"\n-\t\"fmt\"\n-\t\"go/ast\"\n-\t\"go/parser\"\n-\t\"go/token\"\n-\t\"testing\"\n-)\n-\n-const src = `package main\n-\n-import \"log\"\n-\n-func f1() {\n-\tlive()\n-\treturn\n-\tdead()\n-}\n-\n-func f2() {\n-\tfor {\n-\t\tlive()\n-\t}\n-\tdead()\n-}\n-\n-func f3() {\n-\tif true { // even known values are ignored\n-\t\treturn\n-\t}\n-\tfor true { // even known values are ignored\n-\t\tlive()\n-\t}\n-\tfor {\n-\t\tlive()\n-\t}\n-\tdead()\n-}\n-\n-func f4(x int) {\n-\tswitch x {\n-\tcase 1:\n-\t\tlive()\n-\t\tfallthrough\n-\tcase 2:\n-\t\tlive()\n-\t\tlog.Fatal()\n-\tdefault:\n-\t\tpanic(\"oops\")\n-\t}\n-\tdead()\n-}\n-\n-func f4(ch chan int) {\n-\tselect {\n-\tcase <-ch:\n-\t\tlive()\n-\t\treturn\n-\tdefault:\n-\t\tlive()\n-\t\tpanic(\"oops\")\n-\t}\n-\tdead()\n-}\n-\n-func f5(unknown bool) {\n-\tfor {\n-\t\tif unknown {\n-\t\t\tbreak\n-\t\t}\n-\t\tcontinue\n-\t\tdead()\n-\t}\n-\tlive()\n-}\n-\n-func f6(unknown bool) {\n-outer:\n-\tfor {\n-\t\tfor {\n-\t\t\tbreak outer\n-\t\t\tdead()\n-\t\t}\n-\t\tdead()\n-\t}\n-\tlive()\n-}\n-\n-func f7() {\n-\tfor {\n-\t\tbreak nosuchlabel\n-\t\tdead()\n-\t}\n-\tdead()\n-}\n-\n-func f8() {\n-\tselect{}\n-\tdead()\n-}\n-\n-func f9(ch chan int) {\n-\tselect {\n-\tcase <-ch:\n-\t\treturn\n-\t}\n-\tdead()\n-}\n-\n-func f10(ch chan int) {\n-\tselect {\n-\tcase <-ch:\n-\t\treturn\n-\t\tdead()\n-\tdefault:\n-\t}\n-\tlive()\n-}\n-\n-func f11() {\n-\tgoto; // mustn't crash\n-\tdead()\n-}\n-\n-`\n-\n-func TestDeadCode(t *testing.T) {\n-\t// We'll use dead code detection to verify the CFG.\n-\n-\tfset := token.NewFileSet()\n-\tf, err := parser.ParseFile(fset, \"dummy.go\", src, parser.Mode(0))\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tfor _, decl := range f.Decls {\n-\t\tif decl, ok := decl.(*ast.FuncDecl); ok {\n-\t\t\tg := New(decl.Body, mayReturn)\n-\n-\t\t\t// Mark blocks reachable from entry.\n-\t\t\tlive := make(map[*Block]bool)\n-\t\t\tvar visit func(*Block)\n-\t\t\tvisit = func(b *Block) {\n-\t\t\t\tif !live[b] {\n-\t\t\t\t\tlive[b] = true\n-\t\t\t\t\tfor _, succ := range b.Succs {\n-\t\t\t\t\t\tvisit(succ)\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tvisit(g.Blocks[0])\n-\n-\t\t\t// Print statements in unreachable blocks\n-\t\t\t// (in order determined by builder).\n-\t\t\tvar buf bytes.Buffer\n-\t\t\tfor _, b := range g.Blocks {\n-\t\t\t\tif !live[b] {\n-\t\t\t\t\tfor _, n := range b.Nodes {\n-\t\t\t\t\t\tfmt.Fprintf(&buf, \"\\t%s\\n\", formatNode(fset, n))\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t// Check that the result contains \"dead\" at least once but not \"live\".\n-\t\t\tif !bytes.Contains(buf.Bytes(), []byte(\"dead\")) ||\n-\t\t\t\tbytes.Contains(buf.Bytes(), []byte(\"live\")) {\n-\t\t\t\tt.Errorf(\"unexpected dead statements in function %s:\\n%s\",\n-\t\t\t\t\tdecl.Name.Name,\n-\t\t\t\t\t&buf)\n-\t\t\t\tt.Logf(\"control flow graph:\\n%s\", g.Format(fset))\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-// A trivial mayReturn predicate that looks only at syntax, not types.\n-func mayReturn(call *ast.CallExpr) bool {\n-\tswitch fun := call.Fun.(type) {\n-\tcase *ast.Ident:\n-\t\treturn fun.Name != \"panic\"\n-\tcase *ast.SelectorExpr:\n-\t\treturn fun.Sel.Name != \"Fatal\"\n-\t}\n-\treturn true\n-}"}, {"sha": "ee0342035fe3729efb3774e0d51f1cea10cd0ef3", "filename": "libgo/go/cmd/vet/lostcancel.go", "status": "removed", "additions": 0, "deletions": 322, "changes": 322, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Flostcancel.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Flostcancel.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Flostcancel.go?ref=225220d668dafb8262db7012bced688acbe63b33", "patch": "@@ -1,322 +0,0 @@\n-// Copyright 2016 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package main\n-\n-import (\n-\t\"cmd/vet/internal/cfg\"\n-\t\"fmt\"\n-\t\"go/ast\"\n-\t\"go/types\"\n-\t\"strconv\"\n-)\n-\n-func init() {\n-\tregister(\"lostcancel\",\n-\t\t\"check for failure to call cancelation function returned by context.WithCancel\",\n-\t\tcheckLostCancel,\n-\t\tfuncDecl, funcLit)\n-}\n-\n-const debugLostCancel = false\n-\n-var contextPackage = \"context\"\n-\n-// checkLostCancel reports a failure to the call the cancel function\n-// returned by context.WithCancel, either because the variable was\n-// assigned to the blank identifier, or because there exists a\n-// control-flow path from the call to a return statement and that path\n-// does not \"use\" the cancel function.  Any reference to the variable\n-// counts as a use, even within a nested function literal.\n-//\n-// checkLostCancel analyzes a single named or literal function.\n-func checkLostCancel(f *File, node ast.Node) {\n-\t// Fast path: bypass check if file doesn't use context.WithCancel.\n-\tif !hasImport(f.file, contextPackage) {\n-\t\treturn\n-\t}\n-\n-\t// Maps each cancel variable to its defining ValueSpec/AssignStmt.\n-\tcancelvars := make(map[*types.Var]ast.Node)\n-\n-\t// Find the set of cancel vars to analyze.\n-\tstack := make([]ast.Node, 0, 32)\n-\tast.Inspect(node, func(n ast.Node) bool {\n-\t\tswitch n.(type) {\n-\t\tcase *ast.FuncLit:\n-\t\t\tif len(stack) > 0 {\n-\t\t\t\treturn false // don't stray into nested functions\n-\t\t\t}\n-\t\tcase nil:\n-\t\t\tstack = stack[:len(stack)-1] // pop\n-\t\t\treturn true\n-\t\t}\n-\t\tstack = append(stack, n) // push\n-\n-\t\t// Look for [{AssignStmt,ValueSpec} CallExpr SelectorExpr]:\n-\t\t//\n-\t\t//   ctx, cancel    := context.WithCancel(...)\n-\t\t//   ctx, cancel     = context.WithCancel(...)\n-\t\t//   var ctx, cancel = context.WithCancel(...)\n-\t\t//\n-\t\tif isContextWithCancel(f, n) && isCall(stack[len(stack)-2]) {\n-\t\t\tvar id *ast.Ident // id of cancel var\n-\t\t\tstmt := stack[len(stack)-3]\n-\t\t\tswitch stmt := stmt.(type) {\n-\t\t\tcase *ast.ValueSpec:\n-\t\t\t\tif len(stmt.Names) > 1 {\n-\t\t\t\t\tid = stmt.Names[1]\n-\t\t\t\t}\n-\t\t\tcase *ast.AssignStmt:\n-\t\t\t\tif len(stmt.Lhs) > 1 {\n-\t\t\t\t\tid, _ = stmt.Lhs[1].(*ast.Ident)\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif id != nil {\n-\t\t\t\tif id.Name == \"_\" {\n-\t\t\t\t\tf.Badf(id.Pos(), \"the cancel function returned by context.%s should be called, not discarded, to avoid a context leak\",\n-\t\t\t\t\t\tn.(*ast.SelectorExpr).Sel.Name)\n-\t\t\t\t} else if v, ok := f.pkg.uses[id].(*types.Var); ok {\n-\t\t\t\t\tcancelvars[v] = stmt\n-\t\t\t\t} else if v, ok := f.pkg.defs[id].(*types.Var); ok {\n-\t\t\t\t\tcancelvars[v] = stmt\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn true\n-\t})\n-\n-\tif len(cancelvars) == 0 {\n-\t\treturn // no need to build CFG\n-\t}\n-\n-\t// Tell the CFG builder which functions never return.\n-\tinfo := &types.Info{Uses: f.pkg.uses, Selections: f.pkg.selectors}\n-\tmayReturn := func(call *ast.CallExpr) bool {\n-\t\tname := callName(info, call)\n-\t\treturn !noReturnFuncs[name]\n-\t}\n-\n-\t// Build the CFG.\n-\tvar g *cfg.CFG\n-\tvar sig *types.Signature\n-\tswitch node := node.(type) {\n-\tcase *ast.FuncDecl:\n-\t\tobj := f.pkg.defs[node.Name]\n-\t\tif obj == nil {\n-\t\t\treturn // type error (e.g. duplicate function declaration)\n-\t\t}\n-\t\tsig, _ = obj.Type().(*types.Signature)\n-\t\tg = cfg.New(node.Body, mayReturn)\n-\tcase *ast.FuncLit:\n-\t\tsig, _ = f.pkg.types[node.Type].Type.(*types.Signature)\n-\t\tg = cfg.New(node.Body, mayReturn)\n-\t}\n-\n-\t// Print CFG.\n-\tif debugLostCancel {\n-\t\tfmt.Println(g.Format(f.fset))\n-\t}\n-\n-\t// Examine the CFG for each variable in turn.\n-\t// (It would be more efficient to analyze all cancelvars in a\n-\t// single pass over the AST, but seldom is there more than one.)\n-\tfor v, stmt := range cancelvars {\n-\t\tif ret := lostCancelPath(f, g, v, stmt, sig); ret != nil {\n-\t\t\tlineno := f.fset.Position(stmt.Pos()).Line\n-\t\t\tf.Badf(stmt.Pos(), \"the %s function is not used on all paths (possible context leak)\", v.Name())\n-\t\t\tf.Badf(ret.Pos(), \"this return statement may be reached without using the %s var defined on line %d\", v.Name(), lineno)\n-\t\t}\n-\t}\n-}\n-\n-func isCall(n ast.Node) bool { _, ok := n.(*ast.CallExpr); return ok }\n-\n-func hasImport(f *ast.File, path string) bool {\n-\tfor _, imp := range f.Imports {\n-\t\tv, _ := strconv.Unquote(imp.Path.Value)\n-\t\tif v == path {\n-\t\t\treturn true\n-\t\t}\n-\t}\n-\treturn false\n-}\n-\n-// isContextWithCancel reports whether n is one of the qualified identifiers\n-// context.With{Cancel,Timeout,Deadline}.\n-func isContextWithCancel(f *File, n ast.Node) bool {\n-\tif sel, ok := n.(*ast.SelectorExpr); ok {\n-\t\tswitch sel.Sel.Name {\n-\t\tcase \"WithCancel\", \"WithTimeout\", \"WithDeadline\":\n-\t\t\tif x, ok := sel.X.(*ast.Ident); ok {\n-\t\t\t\tif pkgname, ok := f.pkg.uses[x].(*types.PkgName); ok {\n-\t\t\t\t\treturn pkgname.Imported().Path() == contextPackage\n-\t\t\t\t}\n-\t\t\t\t// Import failed, so we can't check package path.\n-\t\t\t\t// Just check the local package name (heuristic).\n-\t\t\t\treturn x.Name == \"context\"\n-\t\t\t}\n-\t\t}\n-\t}\n-\treturn false\n-}\n-\n-// lostCancelPath finds a path through the CFG, from stmt (which defines\n-// the 'cancel' variable v) to a return statement, that doesn't \"use\" v.\n-// If it finds one, it returns the return statement (which may be synthetic).\n-// sig is the function's type, if known.\n-func lostCancelPath(f *File, g *cfg.CFG, v *types.Var, stmt ast.Node, sig *types.Signature) *ast.ReturnStmt {\n-\tvIsNamedResult := sig != nil && tupleContains(sig.Results(), v)\n-\n-\t// uses reports whether stmts contain a \"use\" of variable v.\n-\tuses := func(f *File, v *types.Var, stmts []ast.Node) bool {\n-\t\tfound := false\n-\t\tfor _, stmt := range stmts {\n-\t\t\tast.Inspect(stmt, func(n ast.Node) bool {\n-\t\t\t\tswitch n := n.(type) {\n-\t\t\t\tcase *ast.Ident:\n-\t\t\t\t\tif f.pkg.uses[n] == v {\n-\t\t\t\t\t\tfound = true\n-\t\t\t\t\t}\n-\t\t\t\tcase *ast.ReturnStmt:\n-\t\t\t\t\t// A naked return statement counts as a use\n-\t\t\t\t\t// of the named result variables.\n-\t\t\t\t\tif n.Results == nil && vIsNamedResult {\n-\t\t\t\t\t\tfound = true\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\treturn !found\n-\t\t\t})\n-\t\t}\n-\t\treturn found\n-\t}\n-\n-\t// blockUses computes \"uses\" for each block, caching the result.\n-\tmemo := make(map[*cfg.Block]bool)\n-\tblockUses := func(f *File, v *types.Var, b *cfg.Block) bool {\n-\t\tres, ok := memo[b]\n-\t\tif !ok {\n-\t\t\tres = uses(f, v, b.Nodes)\n-\t\t\tmemo[b] = res\n-\t\t}\n-\t\treturn res\n-\t}\n-\n-\t// Find the var's defining block in the CFG,\n-\t// plus the rest of the statements of that block.\n-\tvar defblock *cfg.Block\n-\tvar rest []ast.Node\n-outer:\n-\tfor _, b := range g.Blocks {\n-\t\tfor i, n := range b.Nodes {\n-\t\t\tif n == stmt {\n-\t\t\t\tdefblock = b\n-\t\t\t\trest = b.Nodes[i+1:]\n-\t\t\t\tbreak outer\n-\t\t\t}\n-\t\t}\n-\t}\n-\tif defblock == nil {\n-\t\tpanic(\"internal error: can't find defining block for cancel var\")\n-\t}\n-\n-\t// Is v \"used\" in the remainder of its defining block?\n-\tif uses(f, v, rest) {\n-\t\treturn nil\n-\t}\n-\n-\t// Does the defining block return without using v?\n-\tif ret := defblock.Return(); ret != nil {\n-\t\treturn ret\n-\t}\n-\n-\t// Search the CFG depth-first for a path, from defblock to a\n-\t// return block, in which v is never \"used\".\n-\tseen := make(map[*cfg.Block]bool)\n-\tvar search func(blocks []*cfg.Block) *ast.ReturnStmt\n-\tsearch = func(blocks []*cfg.Block) *ast.ReturnStmt {\n-\t\tfor _, b := range blocks {\n-\t\t\tif !seen[b] {\n-\t\t\t\tseen[b] = true\n-\n-\t\t\t\t// Prune the search if the block uses v.\n-\t\t\t\tif blockUses(f, v, b) {\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n-\n-\t\t\t\t// Found path to return statement?\n-\t\t\t\tif ret := b.Return(); ret != nil {\n-\t\t\t\t\tif debugLostCancel {\n-\t\t\t\t\t\tfmt.Printf(\"found path to return in block %s\\n\", b)\n-\t\t\t\t\t}\n-\t\t\t\t\treturn ret // found\n-\t\t\t\t}\n-\n-\t\t\t\t// Recur\n-\t\t\t\tif ret := search(b.Succs); ret != nil {\n-\t\t\t\t\tif debugLostCancel {\n-\t\t\t\t\t\tfmt.Printf(\" from block %s\\n\", b)\n-\t\t\t\t\t}\n-\t\t\t\t\treturn ret\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn nil\n-\t}\n-\treturn search(defblock.Succs)\n-}\n-\n-func tupleContains(tuple *types.Tuple, v *types.Var) bool {\n-\tfor i := 0; i < tuple.Len(); i++ {\n-\t\tif tuple.At(i) == v {\n-\t\t\treturn true\n-\t\t}\n-\t}\n-\treturn false\n-}\n-\n-var noReturnFuncs = map[string]bool{\n-\t\"(*testing.common).FailNow\": true,\n-\t\"(*testing.common).Fatal\":   true,\n-\t\"(*testing.common).Fatalf\":  true,\n-\t\"(*testing.common).Skip\":    true,\n-\t\"(*testing.common).SkipNow\": true,\n-\t\"(*testing.common).Skipf\":   true,\n-\t\"log.Fatal\":                 true,\n-\t\"log.Fatalf\":                true,\n-\t\"log.Fatalln\":               true,\n-\t\"os.Exit\":                   true,\n-\t\"panic\":                     true,\n-\t\"runtime.Goexit\":            true,\n-}\n-\n-// callName returns the canonical name of the builtin, method, or\n-// function called by call, if known.\n-func callName(info *types.Info, call *ast.CallExpr) string {\n-\tswitch fun := call.Fun.(type) {\n-\tcase *ast.Ident:\n-\t\t// builtin, e.g. \"panic\"\n-\t\tif obj, ok := info.Uses[fun].(*types.Builtin); ok {\n-\t\t\treturn obj.Name()\n-\t\t}\n-\tcase *ast.SelectorExpr:\n-\t\tif sel, ok := info.Selections[fun]; ok && sel.Kind() == types.MethodVal {\n-\t\t\t// method call, e.g. \"(*testing.common).Fatal\"\n-\t\t\tmeth := sel.Obj()\n-\t\t\treturn fmt.Sprintf(\"(%s).%s\",\n-\t\t\t\tmeth.Type().(*types.Signature).Recv().Type(),\n-\t\t\t\tmeth.Name())\n-\t\t}\n-\t\tif obj, ok := info.Uses[fun.Sel]; ok {\n-\t\t\t// qualified identifier, e.g. \"os.Exit\"\n-\t\t\treturn fmt.Sprintf(\"%s.%s\",\n-\t\t\t\tobj.Pkg().Path(),\n-\t\t\t\tobj.Name())\n-\t\t}\n-\t}\n-\n-\t// function with no name, or defined in missing imported package\n-\treturn \"\"\n-}"}, {"sha": "4ec174b3cd1e06de48aeb36e40cf4aebfb6e178c", "filename": "libgo/go/cmd/vet/main.go", "status": "modified", "additions": 46, "deletions": 743, "changes": 789, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fmain.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "patch": "@@ -1,750 +1,53 @@\n-// Copyright 2010 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Vet is a simple checker for static errors in Go source code.\n-// See doc.go for more information.\n-\n package main\n \n import (\n-\t\"bytes\"\n-\t\"encoding/gob\"\n-\t\"encoding/json\"\n-\t\"flag\"\n-\t\"fmt\"\n-\t\"go/ast\"\n-\t\"go/build\"\n-\t\"go/importer\"\n-\t\"go/parser\"\n-\t\"go/printer\"\n-\t\"go/token\"\n-\t\"go/types\"\n-\t\"io\"\n-\t\"io/ioutil\"\n-\t\"os\"\n-\t\"path/filepath\"\n-\t\"sort\"\n-\t\"strconv\"\n-\t\"strings\"\n-\n-\t\"cmd/internal/objabi\"\n-)\n-\n-// Important! If you add flags here, make sure to update cmd/go/internal/vet/vetflag.go.\n-\n-var (\n-\tverbose = flag.Bool(\"v\", false, \"verbose\")\n-\tsource  = flag.Bool(\"source\", false, \"import from source instead of compiled object files\")\n-\ttags    = flag.String(\"tags\", \"\", \"space-separated list of build tags to apply when parsing\")\n-\ttagList = []string{} // exploded version of tags flag; set in main\n-\n-\tvcfg          vetConfig\n-\tmustTypecheck bool\n-)\n-\n-var exitCode = 0\n-\n-// \"-all\" flag enables all non-experimental checks\n-var all = triStateFlag(\"all\", unset, \"enable all non-experimental checks\")\n-\n-// Flags to control which individual checks to perform.\n-var report = map[string]*triState{\n-\t// Only unusual checks are written here.\n-\t// Most checks that operate during the AST walk are added by register.\n-\t\"asmdecl\":   triStateFlag(\"asmdecl\", unset, \"check assembly against Go declarations\"),\n-\t\"buildtags\": triStateFlag(\"buildtags\", unset, \"check that +build tags are valid\"),\n-}\n-\n-// experimental records the flags enabling experimental features. These must be\n-// requested explicitly; they are not enabled by -all.\n-var experimental = map[string]bool{}\n-\n-// setTrueCount record how many flags are explicitly set to true.\n-var setTrueCount int\n-\n-// dirsRun and filesRun indicate whether the vet is applied to directory or\n-// file targets. The distinction affects which checks are run.\n-var dirsRun, filesRun bool\n-\n-// includesNonTest indicates whether the vet is applied to non-test targets.\n-// Certain checks are relevant only if they touch both test and non-test files.\n-var includesNonTest bool\n-\n-// A triState is a boolean that knows whether it has been set to either true or false.\n-// It is used to identify if a flag appears; the standard boolean flag cannot\n-// distinguish missing from unset. It also satisfies flag.Value.\n-type triState int\n-\n-const (\n-\tunset triState = iota\n-\tsetTrue\n-\tsetFalse\n-)\n-\n-func triStateFlag(name string, value triState, usage string) *triState {\n-\tflag.Var(&value, name, usage)\n-\treturn &value\n-}\n-\n-// triState implements flag.Value, flag.Getter, and flag.boolFlag.\n-// They work like boolean flags: we can say vet -printf as well as vet -printf=true\n-func (ts *triState) Get() interface{} {\n-\treturn *ts == setTrue\n-}\n-\n-func (ts triState) isTrue() bool {\n-\treturn ts == setTrue\n-}\n-\n-func (ts *triState) Set(value string) error {\n-\tb, err := strconv.ParseBool(value)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\tif b {\n-\t\t*ts = setTrue\n-\t\tsetTrueCount++\n-\t} else {\n-\t\t*ts = setFalse\n-\t}\n-\treturn nil\n-}\n-\n-func (ts *triState) String() string {\n-\tswitch *ts {\n-\tcase unset:\n-\t\treturn \"true\" // An unset flag will be set by -all, so defaults to true.\n-\tcase setTrue:\n-\t\treturn \"true\"\n-\tcase setFalse:\n-\t\treturn \"false\"\n-\t}\n-\tpanic(\"not reached\")\n-}\n-\n-func (ts triState) IsBoolFlag() bool {\n-\treturn true\n-}\n-\n-// vet tells whether to report errors for the named check, a flag name.\n-func vet(name string) bool {\n-\treturn report[name].isTrue()\n-}\n-\n-// setExit sets the value for os.Exit when it is called, later. It\n-// remembers the highest value.\n-func setExit(err int) {\n-\tif err > exitCode {\n-\t\texitCode = err\n-\t}\n-}\n-\n-var (\n-\t// Each of these vars has a corresponding case in (*File).Visit.\n-\tassignStmt    *ast.AssignStmt\n-\tbinaryExpr    *ast.BinaryExpr\n-\tcallExpr      *ast.CallExpr\n-\tcompositeLit  *ast.CompositeLit\n-\texprStmt      *ast.ExprStmt\n-\tforStmt       *ast.ForStmt\n-\tfuncDecl      *ast.FuncDecl\n-\tfuncLit       *ast.FuncLit\n-\tgenDecl       *ast.GenDecl\n-\tinterfaceType *ast.InterfaceType\n-\trangeStmt     *ast.RangeStmt\n-\treturnStmt    *ast.ReturnStmt\n-\tstructType    *ast.StructType\n-\n-\t// checkers is a two-level map.\n-\t// The outer level is keyed by a nil pointer, one of the AST vars above.\n-\t// The inner level is keyed by checker name.\n-\tcheckers    = make(map[ast.Node]map[string]func(*File, ast.Node))\n-\tpkgCheckers = make(map[string]func(*Package))\n-\texporters   = make(map[string]func() interface{})\n+\t\"golang.org/x/tools/go/analysis/unitchecker\"\n+\n+\t\"golang.org/x/tools/go/analysis/passes/asmdecl\"\n+\t\"golang.org/x/tools/go/analysis/passes/assign\"\n+\t\"golang.org/x/tools/go/analysis/passes/atomic\"\n+\t\"golang.org/x/tools/go/analysis/passes/bools\"\n+\t\"golang.org/x/tools/go/analysis/passes/buildtag\"\n+\t\"golang.org/x/tools/go/analysis/passes/cgocall\"\n+\t\"golang.org/x/tools/go/analysis/passes/composite\"\n+\t\"golang.org/x/tools/go/analysis/passes/copylock\"\n+\t\"golang.org/x/tools/go/analysis/passes/httpresponse\"\n+\t\"golang.org/x/tools/go/analysis/passes/loopclosure\"\n+\t\"golang.org/x/tools/go/analysis/passes/lostcancel\"\n+\t\"golang.org/x/tools/go/analysis/passes/nilfunc\"\n+\t\"golang.org/x/tools/go/analysis/passes/printf\"\n+\t\"golang.org/x/tools/go/analysis/passes/shift\"\n+\t\"golang.org/x/tools/go/analysis/passes/stdmethods\"\n+\t\"golang.org/x/tools/go/analysis/passes/structtag\"\n+\t\"golang.org/x/tools/go/analysis/passes/tests\"\n+\t\"golang.org/x/tools/go/analysis/passes/unmarshal\"\n+\t\"golang.org/x/tools/go/analysis/passes/unreachable\"\n+\t\"golang.org/x/tools/go/analysis/passes/unsafeptr\"\n+\t\"golang.org/x/tools/go/analysis/passes/unusedresult\"\n )\n \n-// The exporters data as written to the vetx output file.\n-type vetxExport struct {\n-\tName string\n-\tData interface{}\n-}\n-\n-// Vet can provide its own \"export information\"\n-// about package A to future invocations of vet\n-// on packages importing A. If B imports A,\n-// then running \"go vet B\" actually invokes vet twice:\n-// first, it runs vet on A, in \"vetx-only\" mode, which\n-// skips most checks and only computes export data\n-// describing A. Then it runs vet on B, making A's vetx\n-// data available for consultation. The vet of B\n-// computes vetx data for B in addition to its\n-// usual vet checks.\n-\n-// register registers the named check function,\n-// to be called with AST nodes of the given types.\n-// The registered functions are not called in vetx-only mode.\n-func register(name, usage string, fn func(*File, ast.Node), types ...ast.Node) {\n-\treport[name] = triStateFlag(name, unset, usage)\n-\tfor _, typ := range types {\n-\t\tm := checkers[typ]\n-\t\tif m == nil {\n-\t\t\tm = make(map[string]func(*File, ast.Node))\n-\t\t\tcheckers[typ] = m\n-\t\t}\n-\t\tm[name] = fn\n-\t}\n-}\n-\n-// registerPkgCheck registers a package-level checking function,\n-// to be invoked with the whole package being vetted\n-// before any of the per-node handlers.\n-// The registered function fn is called even in vetx-only mode\n-// (see comment above), so fn must take care not to report\n-// errors when vcfg.VetxOnly is true.\n-func registerPkgCheck(name string, fn func(*Package)) {\n-\tpkgCheckers[name] = fn\n-}\n-\n-// registerExport registers a function to return vetx export data\n-// that should be saved and provided to future invocations of vet\n-// when checking packages importing this one.\n-// The value returned by fn should be nil or else valid to encode using gob.\n-// Typically a registerExport call is paired with a call to gob.Register.\n-func registerExport(name string, fn func() interface{}) {\n-\texporters[name] = fn\n-}\n-\n-// Usage is a replacement usage function for the flags package.\n-func Usage() {\n-\tfmt.Fprintf(os.Stderr, \"Usage of vet:\\n\")\n-\tfmt.Fprintf(os.Stderr, \"\\tvet [flags] directory...\\n\")\n-\tfmt.Fprintf(os.Stderr, \"\\tvet [flags] files... # Must be a single package\\n\")\n-\tfmt.Fprintf(os.Stderr, \"By default, -all is set and all non-experimental checks are run.\\n\")\n-\tfmt.Fprintf(os.Stderr, \"For more information run\\n\")\n-\tfmt.Fprintf(os.Stderr, \"\\tgo doc cmd/vet\\n\\n\")\n-\tfmt.Fprintf(os.Stderr, \"Flags:\\n\")\n-\tflag.PrintDefaults()\n-\tos.Exit(2)\n-}\n-\n-// File is a wrapper for the state of a file used in the parser.\n-// The parse tree walkers are all methods of this type.\n-type File struct {\n-\tpkg     *Package\n-\tfset    *token.FileSet\n-\tname    string\n-\tcontent []byte\n-\tfile    *ast.File\n-\tb       bytes.Buffer // for use by methods\n-\n-\t// Parsed package \"foo\" when checking package \"foo_test\"\n-\tbasePkg *Package\n-\n-\t// The keys are the objects that are receivers of a \"String()\n-\t// string\" method. The value reports whether the method has a\n-\t// pointer receiver.\n-\t// This is used by the recursiveStringer method in print.go.\n-\tstringerPtrs map[*ast.Object]bool\n-\n-\t// Registered checkers to run.\n-\tcheckers map[ast.Node][]func(*File, ast.Node)\n-\n-\t// Unreachable nodes; can be ignored in shift check.\n-\tdead map[ast.Node]bool\n-}\n-\n func main() {\n-\tobjabi.AddVersionFlag()\n-\tflag.Usage = Usage\n-\tflag.Parse()\n-\n-\t// If any flag is set, we run only those checks requested.\n-\t// If all flag is set true or if no flags are set true, set all the non-experimental ones\n-\t// not explicitly set (in effect, set the \"-all\" flag).\n-\tif setTrueCount == 0 || *all == setTrue {\n-\t\tfor name, setting := range report {\n-\t\t\tif *setting == unset && !experimental[name] {\n-\t\t\t\t*setting = setTrue\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t// Accept space-separated tags because that matches\n-\t// the go command's other subcommands.\n-\t// Accept commas because go tool vet traditionally has.\n-\ttagList = strings.Fields(strings.Replace(*tags, \",\", \" \", -1))\n-\n-\tinitPrintFlags()\n-\tinitUnusedFlags()\n-\n-\tif flag.NArg() == 0 {\n-\t\tUsage()\n-\t}\n-\n-\t// Special case for \"go vet\" passing an explicit configuration:\n-\t// single argument ending in vet.cfg.\n-\t// Once we have a more general mechanism for obtaining this\n-\t// information from build tools like the go command,\n-\t// vet should be changed to use it. This vet.cfg hack is an\n-\t// experiment to learn about what form that information should take.\n-\tif flag.NArg() == 1 && strings.HasSuffix(flag.Arg(0), \"vet.cfg\") {\n-\t\tdoPackageCfg(flag.Arg(0))\n-\t\tos.Exit(exitCode)\n-\t}\n-\n-\tfor _, name := range flag.Args() {\n-\t\t// Is it a directory?\n-\t\tfi, err := os.Stat(name)\n-\t\tif err != nil {\n-\t\t\twarnf(\"error walking tree: %s\", err)\n-\t\t\tcontinue\n-\t\t}\n-\t\tif fi.IsDir() {\n-\t\t\tdirsRun = true\n-\t\t} else {\n-\t\t\tfilesRun = true\n-\t\t\tif !strings.HasSuffix(name, \"_test.go\") {\n-\t\t\t\tincludesNonTest = true\n-\t\t\t}\n-\t\t}\n-\t}\n-\tif dirsRun && filesRun {\n-\t\tUsage()\n-\t}\n-\tif dirsRun {\n-\t\tfor _, name := range flag.Args() {\n-\t\t\twalkDir(name)\n-\t\t}\n-\t\tos.Exit(exitCode)\n-\t}\n-\tif doPackage(flag.Args(), nil) == nil {\n-\t\twarnf(\"no files checked\")\n-\t}\n-\tos.Exit(exitCode)\n-}\n-\n-// prefixDirectory places the directory name on the beginning of each name in the list.\n-func prefixDirectory(directory string, names []string) {\n-\tif directory != \".\" {\n-\t\tfor i, name := range names {\n-\t\t\tnames[i] = filepath.Join(directory, name)\n-\t\t}\n-\t}\n-}\n-\n-// vetConfig is the JSON config struct prepared by the Go command.\n-type vetConfig struct {\n-\tCompiler    string\n-\tDir         string\n-\tImportPath  string\n-\tGoFiles     []string\n-\tImportMap   map[string]string\n-\tPackageFile map[string]string\n-\tStandard    map[string]bool\n-\tPackageVetx map[string]string // map from import path to vetx data file\n-\tVetxOnly    bool              // only compute vetx output; don't run ordinary checks\n-\tVetxOutput  string            // file where vetx output should be written\n-\n-\tSucceedOnTypecheckFailure bool\n-\n-\timp types.Importer\n-}\n-\n-func (v *vetConfig) Import(path string) (*types.Package, error) {\n-\tif v.imp == nil {\n-\t\tv.imp = importer.For(v.Compiler, v.openPackageFile)\n-\t}\n-\tif path == \"unsafe\" {\n-\t\treturn v.imp.Import(\"unsafe\")\n-\t}\n-\tp := v.ImportMap[path]\n-\tif p == \"\" {\n-\t\treturn nil, fmt.Errorf(\"unknown import path %q\", path)\n-\t}\n-\tif v.PackageFile[p] == \"\" {\n-\t\tif v.Compiler == \"gccgo\" && v.Standard[path] {\n-\t\t\t// gccgo doesn't have sources for standard library packages,\n-\t\t\t// but the importer will do the right thing.\n-\t\t\treturn v.imp.Import(path)\n-\t\t}\n-\t\treturn nil, fmt.Errorf(\"unknown package file for import %q\", path)\n-\t}\n-\treturn v.imp.Import(p)\n-}\n-\n-func (v *vetConfig) openPackageFile(path string) (io.ReadCloser, error) {\n-\tfile := v.PackageFile[path]\n-\tif file == \"\" {\n-\t\tif v.Compiler == \"gccgo\" && v.Standard[path] {\n-\t\t\t// The importer knows how to handle this.\n-\t\t\treturn nil, nil\n-\t\t}\n-\t\t// Note that path here has been translated via v.ImportMap,\n-\t\t// unlike in the error in Import above. We prefer the error in\n-\t\t// Import, but it's worth diagnosing this one too, just in case.\n-\t\treturn nil, fmt.Errorf(\"unknown package file for %q\", path)\n-\t}\n-\tf, err := os.Open(file)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\treturn f, nil\n-}\n-\n-// doPackageCfg analyzes a single package described in a config file.\n-func doPackageCfg(cfgFile string) {\n-\tjs, err := ioutil.ReadFile(cfgFile)\n-\tif err != nil {\n-\t\terrorf(\"%v\", err)\n-\t}\n-\tif err := json.Unmarshal(js, &vcfg); err != nil {\n-\t\terrorf(\"parsing vet config %s: %v\", cfgFile, err)\n-\t}\n-\tstdImporter = &vcfg\n-\tinittypes()\n-\tmustTypecheck = true\n-\tdoPackage(vcfg.GoFiles, nil)\n-\tif vcfg.VetxOutput != \"\" {\n-\t\tout := make([]vetxExport, 0, len(exporters))\n-\t\tfor name, fn := range exporters {\n-\t\t\tout = append(out, vetxExport{\n-\t\t\t\tName: name,\n-\t\t\t\tData: fn(),\n-\t\t\t})\n-\t\t}\n-\t\t// Sort the data so that it is consistent across builds.\n-\t\tsort.Slice(out, func(i, j int) bool {\n-\t\t\treturn out[i].Name < out[j].Name\n-\t\t})\n-\t\tvar buf bytes.Buffer\n-\t\tif err := gob.NewEncoder(&buf).Encode(out); err != nil {\n-\t\t\terrorf(\"encoding vet output: %v\", err)\n-\t\t\treturn\n-\t\t}\n-\t\tif err := ioutil.WriteFile(vcfg.VetxOutput, buf.Bytes(), 0666); err != nil {\n-\t\t\terrorf(\"saving vet output: %v\", err)\n-\t\t\treturn\n-\t\t}\n-\t}\n-}\n-\n-// doPackageDir analyzes the single package found in the directory, if there is one,\n-// plus a test package, if there is one.\n-func doPackageDir(directory string) {\n-\tcontext := build.Default\n-\tif len(context.BuildTags) != 0 {\n-\t\twarnf(\"build tags %s previously set\", context.BuildTags)\n-\t}\n-\tcontext.BuildTags = append(tagList, context.BuildTags...)\n-\n-\tpkg, err := context.ImportDir(directory, 0)\n-\tif err != nil {\n-\t\t// If it's just that there are no go source files, that's fine.\n-\t\tif _, nogo := err.(*build.NoGoError); nogo {\n-\t\t\treturn\n-\t\t}\n-\t\t// Non-fatal: we are doing a recursive walk and there may be other directories.\n-\t\twarnf(\"cannot process directory %s: %s\", directory, err)\n-\t\treturn\n-\t}\n-\tvar names []string\n-\tnames = append(names, pkg.GoFiles...)\n-\tnames = append(names, pkg.CgoFiles...)\n-\tnames = append(names, pkg.TestGoFiles...) // These are also in the \"foo\" package.\n-\tnames = append(names, pkg.SFiles...)\n-\tprefixDirectory(directory, names)\n-\tbasePkg := doPackage(names, nil)\n-\t// Is there also a \"foo_test\" package? If so, do that one as well.\n-\tif len(pkg.XTestGoFiles) > 0 {\n-\t\tnames = pkg.XTestGoFiles\n-\t\tprefixDirectory(directory, names)\n-\t\tdoPackage(names, basePkg)\n-\t}\n-}\n-\n-type Package struct {\n-\tpath      string\n-\tdefs      map[*ast.Ident]types.Object\n-\tuses      map[*ast.Ident]types.Object\n-\tselectors map[*ast.SelectorExpr]*types.Selection\n-\ttypes     map[ast.Expr]types.TypeAndValue\n-\tspans     map[types.Object]Span\n-\tfiles     []*File\n-\ttypesPkg  *types.Package\n-}\n-\n-// doPackage analyzes the single package constructed from the named files.\n-// It returns the parsed Package or nil if none of the files have been checked.\n-func doPackage(names []string, basePkg *Package) *Package {\n-\tvar files []*File\n-\tvar astFiles []*ast.File\n-\tfs := token.NewFileSet()\n-\tfor _, name := range names {\n-\t\tdata, err := ioutil.ReadFile(name)\n-\t\tif err != nil {\n-\t\t\t// Warn but continue to next package.\n-\t\t\twarnf(\"%s: %s\", name, err)\n-\t\t\treturn nil\n-\t\t}\n-\t\tvar parsedFile *ast.File\n-\t\tif strings.HasSuffix(name, \".go\") {\n-\t\t\tparsedFile, err = parser.ParseFile(fs, name, data, parser.ParseComments)\n-\t\t\tif err != nil {\n-\t\t\t\twarnf(\"%s: %s\", name, err)\n-\t\t\t\treturn nil\n-\t\t\t}\n-\t\t\tastFiles = append(astFiles, parsedFile)\n-\t\t}\n-\t\tfile := &File{\n-\t\t\tfset:    fs,\n-\t\t\tcontent: data,\n-\t\t\tname:    name,\n-\t\t\tfile:    parsedFile,\n-\t\t\tdead:    make(map[ast.Node]bool),\n-\t\t}\n-\t\tfiles = append(files, file)\n-\t}\n-\tif len(astFiles) == 0 {\n-\t\treturn nil\n-\t}\n-\tpkg := new(Package)\n-\tpkg.path = astFiles[0].Name.Name\n-\tpkg.files = files\n-\t// Type check the package.\n-\terrs := pkg.check(fs, astFiles)\n-\tif errs != nil {\n-\t\tif vcfg.SucceedOnTypecheckFailure {\n-\t\t\tos.Exit(0)\n-\t\t}\n-\t\tif *verbose || mustTypecheck {\n-\t\t\tfor _, err := range errs {\n-\t\t\t\tfmt.Fprintf(os.Stderr, \"%v\\n\", err)\n-\t\t\t}\n-\t\t\tif mustTypecheck {\n-\t\t\t\t// This message could be silenced, and we could just exit,\n-\t\t\t\t// but it might be helpful at least at first to make clear that the\n-\t\t\t\t// above errors are coming from vet and not the compiler\n-\t\t\t\t// (they often look like compiler errors, such as \"declared but not used\").\n-\t\t\t\terrorf(\"typecheck failures\")\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t// Check.\n-\tfor _, file := range files {\n-\t\tfile.pkg = pkg\n-\t\tfile.basePkg = basePkg\n-\t}\n-\tfor name, fn := range pkgCheckers {\n-\t\tif vet(name) {\n-\t\t\tfn(pkg)\n-\t\t}\n-\t}\n-\tif vcfg.VetxOnly {\n-\t\treturn pkg\n-\t}\n-\n-\tchk := make(map[ast.Node][]func(*File, ast.Node))\n-\tfor typ, set := range checkers {\n-\t\tfor name, fn := range set {\n-\t\t\tif vet(name) {\n-\t\t\t\tchk[typ] = append(chk[typ], fn)\n-\t\t\t}\n-\t\t}\n-\t}\n-\tfor _, file := range files {\n-\t\tcheckBuildTag(file)\n-\t\tfile.checkers = chk\n-\t\tif file.file != nil {\n-\t\t\tfile.walkFile(file.name, file.file)\n-\t\t}\n-\t}\n-\treturn pkg\n-}\n-\n-func visit(path string, f os.FileInfo, err error) error {\n-\tif err != nil {\n-\t\twarnf(\"walk error: %s\", err)\n-\t\treturn err\n-\t}\n-\t// One package per directory. Ignore the files themselves.\n-\tif !f.IsDir() {\n-\t\treturn nil\n-\t}\n-\tdoPackageDir(path)\n-\treturn nil\n-}\n-\n-func (pkg *Package) hasFileWithSuffix(suffix string) bool {\n-\tfor _, f := range pkg.files {\n-\t\tif strings.HasSuffix(f.name, suffix) {\n-\t\t\treturn true\n-\t\t}\n-\t}\n-\treturn false\n-}\n-\n-// walkDir recursively walks the tree looking for Go packages.\n-func walkDir(root string) {\n-\tfilepath.Walk(root, visit)\n-}\n-\n-// errorf formats the error to standard error, adding program\n-// identification and a newline, and exits.\n-func errorf(format string, args ...interface{}) {\n-\tfmt.Fprintf(os.Stderr, \"vet: \"+format+\"\\n\", args...)\n-\tos.Exit(2)\n-}\n-\n-// warnf formats the error to standard error, adding program\n-// identification and a newline, but does not exit.\n-func warnf(format string, args ...interface{}) {\n-\tfmt.Fprintf(os.Stderr, \"vet: \"+format+\"\\n\", args...)\n-\tsetExit(1)\n-}\n-\n-// Println is fmt.Println guarded by -v.\n-func Println(args ...interface{}) {\n-\tif !*verbose {\n-\t\treturn\n-\t}\n-\tfmt.Println(args...)\n-}\n-\n-// Printf is fmt.Printf guarded by -v.\n-func Printf(format string, args ...interface{}) {\n-\tif !*verbose {\n-\t\treturn\n-\t}\n-\tfmt.Printf(format+\"\\n\", args...)\n-}\n-\n-// Bad reports an error and sets the exit code..\n-func (f *File) Bad(pos token.Pos, args ...interface{}) {\n-\tf.Warn(pos, args...)\n-\tsetExit(1)\n-}\n-\n-// Badf reports a formatted error and sets the exit code.\n-func (f *File) Badf(pos token.Pos, format string, args ...interface{}) {\n-\tf.Warnf(pos, format, args...)\n-\tsetExit(1)\n-}\n-\n-// loc returns a formatted representation of the position.\n-func (f *File) loc(pos token.Pos) string {\n-\tif pos == token.NoPos {\n-\t\treturn \"\"\n-\t}\n-\t// Do not print columns. Because the pos often points to the start of an\n-\t// expression instead of the inner part with the actual error, the\n-\t// precision can mislead.\n-\tposn := f.fset.Position(pos)\n-\treturn fmt.Sprintf(\"%s:%d\", posn.Filename, posn.Line)\n-}\n-\n-// locPrefix returns a formatted representation of the position for use as a line prefix.\n-func (f *File) locPrefix(pos token.Pos) string {\n-\tif pos == token.NoPos {\n-\t\treturn \"\"\n-\t}\n-\treturn fmt.Sprintf(\"%s: \", f.loc(pos))\n-}\n-\n-// Warn reports an error but does not set the exit code.\n-func (f *File) Warn(pos token.Pos, args ...interface{}) {\n-\tfmt.Fprintf(os.Stderr, \"%s%s\", f.locPrefix(pos), fmt.Sprintln(args...))\n-}\n-\n-// Warnf reports a formatted error but does not set the exit code.\n-func (f *File) Warnf(pos token.Pos, format string, args ...interface{}) {\n-\tfmt.Fprintf(os.Stderr, \"%s%s\\n\", f.locPrefix(pos), fmt.Sprintf(format, args...))\n-}\n-\n-// walkFile walks the file's tree.\n-func (f *File) walkFile(name string, file *ast.File) {\n-\tPrintln(\"Checking file\", name)\n-\tast.Walk(f, file)\n-}\n-\n-// Visit implements the ast.Visitor interface.\n-func (f *File) Visit(node ast.Node) ast.Visitor {\n-\tf.updateDead(node)\n-\tvar key ast.Node\n-\tswitch node.(type) {\n-\tcase *ast.AssignStmt:\n-\t\tkey = assignStmt\n-\tcase *ast.BinaryExpr:\n-\t\tkey = binaryExpr\n-\tcase *ast.CallExpr:\n-\t\tkey = callExpr\n-\tcase *ast.CompositeLit:\n-\t\tkey = compositeLit\n-\tcase *ast.ExprStmt:\n-\t\tkey = exprStmt\n-\tcase *ast.ForStmt:\n-\t\tkey = forStmt\n-\tcase *ast.FuncDecl:\n-\t\tkey = funcDecl\n-\tcase *ast.FuncLit:\n-\t\tkey = funcLit\n-\tcase *ast.GenDecl:\n-\t\tkey = genDecl\n-\tcase *ast.InterfaceType:\n-\t\tkey = interfaceType\n-\tcase *ast.RangeStmt:\n-\t\tkey = rangeStmt\n-\tcase *ast.ReturnStmt:\n-\t\tkey = returnStmt\n-\tcase *ast.StructType:\n-\t\tkey = structType\n-\t}\n-\tfor _, fn := range f.checkers[key] {\n-\t\tfn(f, node)\n-\t}\n-\treturn f\n-}\n-\n-// gofmt returns a string representation of the expression.\n-func (f *File) gofmt(x ast.Expr) string {\n-\tf.b.Reset()\n-\tprinter.Fprint(&f.b, f.fset, x)\n-\treturn f.b.String()\n-}\n-\n-// imported[path][key] is previously written export data.\n-var imported = make(map[string]map[string]interface{})\n-\n-// readVetx reads export data written by a previous\n-// invocation of vet on an imported package (path).\n-// The key is the name passed to registerExport\n-// when the data was originally generated.\n-// readVetx returns nil if the data is unavailable.\n-func readVetx(path, key string) interface{} {\n-\tif path == \"unsafe\" || vcfg.ImportPath == \"\" {\n-\t\treturn nil\n-\t}\n-\tm := imported[path]\n-\tif m == nil {\n-\t\tfile := vcfg.PackageVetx[path]\n-\t\tif file == \"\" {\n-\t\t\treturn nil\n-\t\t}\n-\t\tdata, err := ioutil.ReadFile(file)\n-\t\tif err != nil {\n-\t\t\treturn nil\n-\t\t}\n-\t\tvar out []vetxExport\n-\t\terr = gob.NewDecoder(bytes.NewReader(data)).Decode(&out)\n-\t\tif err != nil {\n-\t\t\treturn nil\n-\t\t}\n-\t\tm = make(map[string]interface{})\n-\t\tfor _, x := range out {\n-\t\t\tm[x.Name] = x.Data\n-\t\t}\n-\t\timported[path] = m\n-\t}\n-\treturn m[key]\n+\tunitchecker.Main(\n+\t\tasmdecl.Analyzer,\n+\t\tassign.Analyzer,\n+\t\tatomic.Analyzer,\n+\t\tbools.Analyzer,\n+\t\tbuildtag.Analyzer,\n+\t\tcgocall.Analyzer,\n+\t\tcomposite.Analyzer,\n+\t\tcopylock.Analyzer,\n+\t\thttpresponse.Analyzer,\n+\t\tloopclosure.Analyzer,\n+\t\tlostcancel.Analyzer,\n+\t\tnilfunc.Analyzer,\n+\t\tprintf.Analyzer,\n+\t\tshift.Analyzer,\n+\t\tstdmethods.Analyzer,\n+\t\tstructtag.Analyzer,\n+\t\ttests.Analyzer,\n+\t\tunmarshal.Analyzer,\n+\t\tunreachable.Analyzer,\n+\t\tunsafeptr.Analyzer,\n+\t\tunusedresult.Analyzer,\n+\t)\n }"}, {"sha": "bfe05e3353da9a098ac2c84e749876cdbae93ad7", "filename": "libgo/go/cmd/vet/nilfunc.go", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Fnilfunc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Fnilfunc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fnilfunc.go?ref=225220d668dafb8262db7012bced688acbe63b33", "patch": "@@ -1,67 +0,0 @@\n-// Copyright 2013 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-/*\n-This file contains the code to check for useless function comparisons.\n-A useless comparison is one like f == nil as opposed to f() == nil.\n-*/\n-\n-package main\n-\n-import (\n-\t\"go/ast\"\n-\t\"go/token\"\n-\t\"go/types\"\n-)\n-\n-func init() {\n-\tregister(\"nilfunc\",\n-\t\t\"check for comparisons between functions and nil\",\n-\t\tcheckNilFuncComparison,\n-\t\tbinaryExpr)\n-}\n-\n-func checkNilFuncComparison(f *File, node ast.Node) {\n-\te := node.(*ast.BinaryExpr)\n-\n-\t// Only want == or != comparisons.\n-\tif e.Op != token.EQL && e.Op != token.NEQ {\n-\t\treturn\n-\t}\n-\n-\t// Only want comparisons with a nil identifier on one side.\n-\tvar e2 ast.Expr\n-\tswitch {\n-\tcase f.isNil(e.X):\n-\t\te2 = e.Y\n-\tcase f.isNil(e.Y):\n-\t\te2 = e.X\n-\tdefault:\n-\t\treturn\n-\t}\n-\n-\t// Only want identifiers or selector expressions.\n-\tvar obj types.Object\n-\tswitch v := e2.(type) {\n-\tcase *ast.Ident:\n-\t\tobj = f.pkg.uses[v]\n-\tcase *ast.SelectorExpr:\n-\t\tobj = f.pkg.uses[v.Sel]\n-\tdefault:\n-\t\treturn\n-\t}\n-\n-\t// Only want functions.\n-\tif _, ok := obj.(*types.Func); !ok {\n-\t\treturn\n-\t}\n-\n-\tf.Badf(e.Pos(), \"comparison of function %v %v nil is always %v\", obj.Name(), e.Op, e.Op == token.NEQ)\n-}\n-\n-// isNil reports whether the provided expression is the built-in nil\n-// identifier.\n-func (f *File) isNil(e ast.Expr) bool {\n-\treturn f.pkg.types[e].Type == types.Typ[types.UntypedNil]\n-}"}, {"sha": "53a41364dfe1b84e79d2d0bdfa4ac25694e7b29b", "filename": "libgo/go/cmd/vet/rangeloop.go", "status": "removed", "additions": 0, "deletions": 105, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Frangeloop.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Frangeloop.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Frangeloop.go?ref=225220d668dafb8262db7012bced688acbe63b33", "patch": "@@ -1,105 +0,0 @@\n-// Copyright 2012 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-/*\n-This file contains the code to check range loop variables bound inside function\n-literals that are deferred or launched in new goroutines. We only check\n-instances where the defer or go statement is the last statement in the loop\n-body, as otherwise we would need whole program analysis.\n-\n-For example:\n-\n-\tfor i, v := range s {\n-\t\tgo func() {\n-\t\t\tprintln(i, v) // not what you might expect\n-\t\t}()\n-\t}\n-\n-See: https://golang.org/doc/go_faq.html#closures_and_goroutines\n-*/\n-\n-package main\n-\n-import \"go/ast\"\n-\n-func init() {\n-\tregister(\"rangeloops\",\n-\t\t\"check that loop variables are used correctly\",\n-\t\tcheckLoop,\n-\t\trangeStmt, forStmt)\n-}\n-\n-// checkLoop walks the body of the provided loop statement, checking whether\n-// its index or value variables are used unsafely inside goroutines or deferred\n-// function literals.\n-func checkLoop(f *File, node ast.Node) {\n-\t// Find the variables updated by the loop statement.\n-\tvar vars []*ast.Ident\n-\taddVar := func(expr ast.Expr) {\n-\t\tif id, ok := expr.(*ast.Ident); ok {\n-\t\t\tvars = append(vars, id)\n-\t\t}\n-\t}\n-\tvar body *ast.BlockStmt\n-\tswitch n := node.(type) {\n-\tcase *ast.RangeStmt:\n-\t\tbody = n.Body\n-\t\taddVar(n.Key)\n-\t\taddVar(n.Value)\n-\tcase *ast.ForStmt:\n-\t\tbody = n.Body\n-\t\tswitch post := n.Post.(type) {\n-\t\tcase *ast.AssignStmt:\n-\t\t\t// e.g. for p = head; p != nil; p = p.next\n-\t\t\tfor _, lhs := range post.Lhs {\n-\t\t\t\taddVar(lhs)\n-\t\t\t}\n-\t\tcase *ast.IncDecStmt:\n-\t\t\t// e.g. for i := 0; i < n; i++\n-\t\t\taddVar(post.X)\n-\t\t}\n-\t}\n-\tif vars == nil {\n-\t\treturn\n-\t}\n-\n-\t// Inspect a go or defer statement\n-\t// if it's the last one in the loop body.\n-\t// (We give up if there are following statements,\n-\t// because it's hard to prove go isn't followed by wait,\n-\t// or defer by return.)\n-\tif len(body.List) == 0 {\n-\t\treturn\n-\t}\n-\tvar last *ast.CallExpr\n-\tswitch s := body.List[len(body.List)-1].(type) {\n-\tcase *ast.GoStmt:\n-\t\tlast = s.Call\n-\tcase *ast.DeferStmt:\n-\t\tlast = s.Call\n-\tdefault:\n-\t\treturn\n-\t}\n-\tlit, ok := last.Fun.(*ast.FuncLit)\n-\tif !ok {\n-\t\treturn\n-\t}\n-\tast.Inspect(lit.Body, func(n ast.Node) bool {\n-\t\tid, ok := n.(*ast.Ident)\n-\t\tif !ok || id.Obj == nil {\n-\t\t\treturn true\n-\t\t}\n-\t\tif f.pkg.types[id].Type == nil {\n-\t\t\t// Not referring to a variable (e.g. struct field name)\n-\t\t\treturn true\n-\t\t}\n-\t\tfor _, v := range vars {\n-\t\t\tif v.Obj == id.Obj {\n-\t\t\t\tf.Badf(id.Pos(), \"loop variable %s captured by func literal\",\n-\t\t\t\t\tid.Name)\n-\t\t\t}\n-\t\t}\n-\t\treturn true\n-\t})\n-}"}, {"sha": "29c952fd8858eae7fb8a4d1747d7798e141e8444", "filename": "libgo/go/cmd/vet/shadow.go", "status": "removed", "additions": 0, "deletions": 246, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Fshadow.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Fshadow.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fshadow.go?ref=225220d668dafb8262db7012bced688acbe63b33", "patch": "@@ -1,246 +0,0 @@\n-// Copyright 2013 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-/*\n-This file contains the code to check for shadowed variables.\n-A shadowed variable is a variable declared in an inner scope\n-with the same name and type as a variable in an outer scope,\n-and where the outer variable is mentioned after the inner one\n-is declared.\n-\n-(This definition can be refined; the module generates too many\n-false positives and is not yet enabled by default.)\n-\n-For example:\n-\n-\tfunc BadRead(f *os.File, buf []byte) error {\n-\t\tvar err error\n-\t\tfor {\n-\t\t\tn, err := f.Read(buf) // shadows the function variable 'err'\n-\t\t\tif err != nil {\n-\t\t\t\tbreak // causes return of wrong value\n-\t\t\t}\n-\t\t\tfoo(buf)\n-\t\t}\n-\t\treturn err\n-\t}\n-\n-*/\n-\n-package main\n-\n-import (\n-\t\"flag\"\n-\t\"go/ast\"\n-\t\"go/token\"\n-\t\"go/types\"\n-)\n-\n-var strictShadowing = flag.Bool(\"shadowstrict\", false, \"whether to be strict about shadowing; can be noisy\")\n-\n-func init() {\n-\tregister(\"shadow\",\n-\t\t\"check for shadowed variables (experimental; must be set explicitly)\",\n-\t\tcheckShadow,\n-\t\tassignStmt, genDecl)\n-\texperimental[\"shadow\"] = true\n-}\n-\n-func checkShadow(f *File, node ast.Node) {\n-\tswitch n := node.(type) {\n-\tcase *ast.AssignStmt:\n-\t\tcheckShadowAssignment(f, n)\n-\tcase *ast.GenDecl:\n-\t\tcheckShadowDecl(f, n)\n-\t}\n-}\n-\n-// Span stores the minimum range of byte positions in the file in which a\n-// given variable (types.Object) is mentioned. It is lexically defined: it spans\n-// from the beginning of its first mention to the end of its last mention.\n-// A variable is considered shadowed (if *strictShadowing is off) only if the\n-// shadowing variable is declared within the span of the shadowed variable.\n-// In other words, if a variable is shadowed but not used after the shadowed\n-// variable is declared, it is inconsequential and not worth complaining about.\n-// This simple check dramatically reduces the nuisance rate for the shadowing\n-// check, at least until something cleverer comes along.\n-//\n-// One wrinkle: A \"naked return\" is a silent use of a variable that the Span\n-// will not capture, but the compilers catch naked returns of shadowed\n-// variables so we don't need to.\n-//\n-// Cases this gets wrong (TODO):\n-// - If a for loop's continuation statement mentions a variable redeclared in\n-// the block, we should complain about it but don't.\n-// - A variable declared inside a function literal can falsely be identified\n-// as shadowing a variable in the outer function.\n-//\n-type Span struct {\n-\tmin token.Pos\n-\tmax token.Pos\n-}\n-\n-// contains reports whether the position is inside the span.\n-func (s Span) contains(pos token.Pos) bool {\n-\treturn s.min <= pos && pos < s.max\n-}\n-\n-// growSpan expands the span for the object to contain the instance represented\n-// by the identifier.\n-func (pkg *Package) growSpan(ident *ast.Ident, obj types.Object) {\n-\tif *strictShadowing {\n-\t\treturn // No need\n-\t}\n-\tpos := ident.Pos()\n-\tend := ident.End()\n-\tspan, ok := pkg.spans[obj]\n-\tif ok {\n-\t\tif span.min > pos {\n-\t\t\tspan.min = pos\n-\t\t}\n-\t\tif span.max < end {\n-\t\t\tspan.max = end\n-\t\t}\n-\t} else {\n-\t\tspan = Span{pos, end}\n-\t}\n-\tpkg.spans[obj] = span\n-}\n-\n-// checkShadowAssignment checks for shadowing in a short variable declaration.\n-func checkShadowAssignment(f *File, a *ast.AssignStmt) {\n-\tif a.Tok != token.DEFINE {\n-\t\treturn\n-\t}\n-\tif f.idiomaticShortRedecl(a) {\n-\t\treturn\n-\t}\n-\tfor _, expr := range a.Lhs {\n-\t\tident, ok := expr.(*ast.Ident)\n-\t\tif !ok {\n-\t\t\tf.Badf(expr.Pos(), \"invalid AST: short variable declaration of non-identifier\")\n-\t\t\treturn\n-\t\t}\n-\t\tcheckShadowing(f, ident)\n-\t}\n-}\n-\n-// idiomaticShortRedecl reports whether this short declaration can be ignored for\n-// the purposes of shadowing, that is, that any redeclarations it contains are deliberate.\n-func (f *File) idiomaticShortRedecl(a *ast.AssignStmt) bool {\n-\t// Don't complain about deliberate redeclarations of the form\n-\t//\ti := i\n-\t// Such constructs are idiomatic in range loops to create a new variable\n-\t// for each iteration. Another example is\n-\t//\tswitch n := n.(type)\n-\tif len(a.Rhs) != len(a.Lhs) {\n-\t\treturn false\n-\t}\n-\t// We know it's an assignment, so the LHS must be all identifiers. (We check anyway.)\n-\tfor i, expr := range a.Lhs {\n-\t\tlhs, ok := expr.(*ast.Ident)\n-\t\tif !ok {\n-\t\t\tf.Badf(expr.Pos(), \"invalid AST: short variable declaration of non-identifier\")\n-\t\t\treturn true // Don't do any more processing.\n-\t\t}\n-\t\tswitch rhs := a.Rhs[i].(type) {\n-\t\tcase *ast.Ident:\n-\t\t\tif lhs.Name != rhs.Name {\n-\t\t\t\treturn false\n-\t\t\t}\n-\t\tcase *ast.TypeAssertExpr:\n-\t\t\tif id, ok := rhs.X.(*ast.Ident); ok {\n-\t\t\t\tif lhs.Name != id.Name {\n-\t\t\t\t\treturn false\n-\t\t\t\t}\n-\t\t\t}\n-\t\tdefault:\n-\t\t\treturn false\n-\t\t}\n-\t}\n-\treturn true\n-}\n-\n-// idiomaticRedecl reports whether this declaration spec can be ignored for\n-// the purposes of shadowing, that is, that any redeclarations it contains are deliberate.\n-func (f *File) idiomaticRedecl(d *ast.ValueSpec) bool {\n-\t// Don't complain about deliberate redeclarations of the form\n-\t//\tvar i, j = i, j\n-\tif len(d.Names) != len(d.Values) {\n-\t\treturn false\n-\t}\n-\tfor i, lhs := range d.Names {\n-\t\tif rhs, ok := d.Values[i].(*ast.Ident); ok {\n-\t\t\tif lhs.Name != rhs.Name {\n-\t\t\t\treturn false\n-\t\t\t}\n-\t\t}\n-\t}\n-\treturn true\n-}\n-\n-// checkShadowDecl checks for shadowing in a general variable declaration.\n-func checkShadowDecl(f *File, d *ast.GenDecl) {\n-\tif d.Tok != token.VAR {\n-\t\treturn\n-\t}\n-\tfor _, spec := range d.Specs {\n-\t\tvalueSpec, ok := spec.(*ast.ValueSpec)\n-\t\tif !ok {\n-\t\t\tf.Badf(spec.Pos(), \"invalid AST: var GenDecl not ValueSpec\")\n-\t\t\treturn\n-\t\t}\n-\t\t// Don't complain about deliberate redeclarations of the form\n-\t\t//\tvar i = i\n-\t\tif f.idiomaticRedecl(valueSpec) {\n-\t\t\treturn\n-\t\t}\n-\t\tfor _, ident := range valueSpec.Names {\n-\t\t\tcheckShadowing(f, ident)\n-\t\t}\n-\t}\n-}\n-\n-// checkShadowing checks whether the identifier shadows an identifier in an outer scope.\n-func checkShadowing(f *File, ident *ast.Ident) {\n-\tif ident.Name == \"_\" {\n-\t\t// Can't shadow the blank identifier.\n-\t\treturn\n-\t}\n-\tobj := f.pkg.defs[ident]\n-\tif obj == nil {\n-\t\treturn\n-\t}\n-\t// obj.Parent.Parent is the surrounding scope. If we can find another declaration\n-\t// starting from there, we have a shadowed identifier.\n-\t_, shadowed := obj.Parent().Parent().LookupParent(obj.Name(), obj.Pos())\n-\tif shadowed == nil {\n-\t\treturn\n-\t}\n-\t// Don't complain if it's shadowing a universe-declared identifier; that's fine.\n-\tif shadowed.Parent() == types.Universe {\n-\t\treturn\n-\t}\n-\tif *strictShadowing {\n-\t\t// The shadowed identifier must appear before this one to be an instance of shadowing.\n-\t\tif shadowed.Pos() > ident.Pos() {\n-\t\t\treturn\n-\t\t}\n-\t} else {\n-\t\t// Don't complain if the span of validity of the shadowed identifier doesn't include\n-\t\t// the shadowing identifier.\n-\t\tspan, ok := f.pkg.spans[shadowed]\n-\t\tif !ok {\n-\t\t\tf.Badf(ident.Pos(), \"internal error: no range for %q\", ident.Name)\n-\t\t\treturn\n-\t\t}\n-\t\tif !span.contains(ident.Pos()) {\n-\t\t\treturn\n-\t\t}\n-\t}\n-\t// Don't complain if the types differ: that implies the programmer really wants two different things.\n-\tif types.Identical(obj.Type(), shadowed.Type()) {\n-\t\tf.Badf(ident.Pos(), \"declaration of %q shadows declaration at %s\", obj.Name(), f.loc(shadowed.Pos()))\n-\t}\n-}"}, {"sha": "1e48d325242bde32fdacf24431ef3ab2e1e07f9b", "filename": "libgo/go/cmd/vet/shift.go", "status": "removed", "additions": 0, "deletions": 98, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Fshift.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Fshift.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fshift.go?ref=225220d668dafb8262db7012bced688acbe63b33", "patch": "@@ -1,98 +0,0 @@\n-// Copyright 2014 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-/*\n-This file contains the code to check for suspicious shifts.\n-*/\n-\n-package main\n-\n-import (\n-\t\"go/ast\"\n-\t\"go/constant\"\n-\t\"go/token\"\n-\t\"go/types\"\n-)\n-\n-func init() {\n-\tregister(\"shift\",\n-\t\t\"check for useless shifts\",\n-\t\tcheckShift,\n-\t\tbinaryExpr, assignStmt)\n-}\n-\n-func checkShift(f *File, node ast.Node) {\n-\tif f.dead[node] {\n-\t\t// Skip shift checks on unreachable nodes.\n-\t\treturn\n-\t}\n-\n-\tswitch node := node.(type) {\n-\tcase *ast.BinaryExpr:\n-\t\tif node.Op == token.SHL || node.Op == token.SHR {\n-\t\t\tcheckLongShift(f, node, node.X, node.Y)\n-\t\t}\n-\tcase *ast.AssignStmt:\n-\t\tif len(node.Lhs) != 1 || len(node.Rhs) != 1 {\n-\t\t\treturn\n-\t\t}\n-\t\tif node.Tok == token.SHL_ASSIGN || node.Tok == token.SHR_ASSIGN {\n-\t\t\tcheckLongShift(f, node, node.Lhs[0], node.Rhs[0])\n-\t\t}\n-\t}\n-}\n-\n-// checkLongShift checks if shift or shift-assign operations shift by more than\n-// the length of the underlying variable.\n-func checkLongShift(f *File, node ast.Node, x, y ast.Expr) {\n-\tif f.pkg.types[x].Value != nil {\n-\t\t// Ignore shifts of constants.\n-\t\t// These are frequently used for bit-twiddling tricks\n-\t\t// like ^uint(0) >> 63 for 32/64 bit detection and compatibility.\n-\t\treturn\n-\t}\n-\n-\tv := f.pkg.types[y].Value\n-\tif v == nil {\n-\t\treturn\n-\t}\n-\tamt, ok := constant.Int64Val(v)\n-\tif !ok {\n-\t\treturn\n-\t}\n-\tt := f.pkg.types[x].Type\n-\tif t == nil {\n-\t\treturn\n-\t}\n-\tb, ok := t.Underlying().(*types.Basic)\n-\tif !ok {\n-\t\treturn\n-\t}\n-\tvar size int64\n-\tswitch b.Kind() {\n-\tcase types.Uint8, types.Int8:\n-\t\tsize = 8\n-\tcase types.Uint16, types.Int16:\n-\t\tsize = 16\n-\tcase types.Uint32, types.Int32:\n-\t\tsize = 32\n-\tcase types.Uint64, types.Int64:\n-\t\tsize = 64\n-\tcase types.Int, types.Uint:\n-\t\tsize = uintBitSize\n-\tcase types.Uintptr:\n-\t\tsize = uintptrBitSize\n-\tdefault:\n-\t\treturn\n-\t}\n-\tif amt >= size {\n-\t\tident := f.gofmt(x)\n-\t\tf.Badf(node.Pos(), \"%s (%d bits) too small for shift of %d\", ident, size, amt)\n-\t}\n-}\n-\n-var (\n-\tuintBitSize    = 8 * archSizes.Sizeof(types.Typ[types.Uint])\n-\tuintptrBitSize = 8 * archSizes.Sizeof(types.Typ[types.Uintptr])\n-)"}, {"sha": "3bc30c47405d8f6707adb653617abcba80210317", "filename": "libgo/go/cmd/vet/structtag.go", "status": "removed", "additions": 0, "deletions": 226, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Fstructtag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Fstructtag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fstructtag.go?ref=225220d668dafb8262db7012bced688acbe63b33", "patch": "@@ -1,226 +0,0 @@\n-// Copyright 2010 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// This file contains the test for canonical struct tags.\n-\n-package main\n-\n-import (\n-\t\"errors\"\n-\t\"go/ast\"\n-\t\"go/token\"\n-\t\"reflect\"\n-\t\"strconv\"\n-\t\"strings\"\n-)\n-\n-func init() {\n-\tregister(\"structtags\",\n-\t\t\"check that struct field tags have canonical format and apply to exported fields as needed\",\n-\t\tcheckStructFieldTags,\n-\t\tstructType)\n-}\n-\n-// checkStructFieldTags checks all the field tags of a struct, including checking for duplicates.\n-func checkStructFieldTags(f *File, node ast.Node) {\n-\tvar seen map[[2]string]token.Pos\n-\tfor _, field := range node.(*ast.StructType).Fields.List {\n-\t\tcheckCanonicalFieldTag(f, field, &seen)\n-\t}\n-}\n-\n-var checkTagDups = []string{\"json\", \"xml\"}\n-var checkTagSpaces = map[string]bool{\"json\": true, \"xml\": true, \"asn1\": true}\n-\n-// checkCanonicalFieldTag checks a single struct field tag.\n-func checkCanonicalFieldTag(f *File, field *ast.Field, seen *map[[2]string]token.Pos) {\n-\tif field.Tag == nil {\n-\t\treturn\n-\t}\n-\n-\ttag, err := strconv.Unquote(field.Tag.Value)\n-\tif err != nil {\n-\t\tf.Badf(field.Pos(), \"unable to read struct tag %s\", field.Tag.Value)\n-\t\treturn\n-\t}\n-\n-\tif err := validateStructTag(tag); err != nil {\n-\t\traw, _ := strconv.Unquote(field.Tag.Value) // field.Tag.Value is known to be a quoted string\n-\t\tf.Badf(field.Pos(), \"struct field tag %#q not compatible with reflect.StructTag.Get: %s\", raw, err)\n-\t}\n-\n-\tfor _, key := range checkTagDups {\n-\t\tval := reflect.StructTag(tag).Get(key)\n-\t\tif val == \"\" || val == \"-\" || val[0] == ',' {\n-\t\t\tcontinue\n-\t\t}\n-\t\tif key == \"xml\" && len(field.Names) > 0 && field.Names[0].Name == \"XMLName\" {\n-\t\t\t// XMLName defines the XML element name of the struct being\n-\t\t\t// checked. That name cannot collide with element or attribute\n-\t\t\t// names defined on other fields of the struct. Vet does not have a\n-\t\t\t// check for untagged fields of type struct defining their own name\n-\t\t\t// by containing a field named XMLName; see issue 18256.\n-\t\t\tcontinue\n-\t\t}\n-\t\tif i := strings.Index(val, \",\"); i >= 0 {\n-\t\t\tif key == \"xml\" {\n-\t\t\t\t// Use a separate namespace for XML attributes.\n-\t\t\t\tfor _, opt := range strings.Split(val[i:], \",\") {\n-\t\t\t\t\tif opt == \"attr\" {\n-\t\t\t\t\t\tkey += \" attribute\" // Key is part of the error message.\n-\t\t\t\t\t\tbreak\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tval = val[:i]\n-\t\t}\n-\t\tif *seen == nil {\n-\t\t\t*seen = map[[2]string]token.Pos{}\n-\t\t}\n-\t\tif pos, ok := (*seen)[[2]string{key, val}]; ok {\n-\t\t\tvar name string\n-\t\t\tif len(field.Names) > 0 {\n-\t\t\t\tname = field.Names[0].Name\n-\t\t\t} else {\n-\t\t\t\tname = field.Type.(*ast.Ident).Name\n-\t\t\t}\n-\t\t\tf.Badf(field.Pos(), \"struct field %s repeats %s tag %q also at %s\", name, key, val, f.loc(pos))\n-\t\t} else {\n-\t\t\t(*seen)[[2]string{key, val}] = field.Pos()\n-\t\t}\n-\t}\n-\n-\t// Check for use of json or xml tags with unexported fields.\n-\n-\t// Embedded struct. Nothing to do for now, but that\n-\t// may change, depending on what happens with issue 7363.\n-\tif len(field.Names) == 0 {\n-\t\treturn\n-\t}\n-\n-\tif field.Names[0].IsExported() {\n-\t\treturn\n-\t}\n-\n-\tfor _, enc := range [...]string{\"json\", \"xml\"} {\n-\t\tif reflect.StructTag(tag).Get(enc) != \"\" {\n-\t\t\tf.Badf(field.Pos(), \"struct field %s has %s tag but is not exported\", field.Names[0].Name, enc)\n-\t\t\treturn\n-\t\t}\n-\t}\n-}\n-\n-var (\n-\terrTagSyntax      = errors.New(\"bad syntax for struct tag pair\")\n-\terrTagKeySyntax   = errors.New(\"bad syntax for struct tag key\")\n-\terrTagValueSyntax = errors.New(\"bad syntax for struct tag value\")\n-\terrTagValueSpace  = errors.New(\"suspicious space in struct tag value\")\n-\terrTagSpace       = errors.New(\"key:\\\"value\\\" pairs not separated by spaces\")\n-)\n-\n-// validateStructTag parses the struct tag and returns an error if it is not\n-// in the canonical format, which is a space-separated list of key:\"value\"\n-// settings. The value may contain spaces.\n-func validateStructTag(tag string) error {\n-\t// This code is based on the StructTag.Get code in package reflect.\n-\n-\tn := 0\n-\tfor ; tag != \"\"; n++ {\n-\t\tif n > 0 && tag != \"\" && tag[0] != ' ' {\n-\t\t\t// More restrictive than reflect, but catches likely mistakes\n-\t\t\t// like `x:\"foo\",y:\"bar\"`, which parses as `x:\"foo\" ,y:\"bar\"` with second key \",y\".\n-\t\t\treturn errTagSpace\n-\t\t}\n-\t\t// Skip leading space.\n-\t\ti := 0\n-\t\tfor i < len(tag) && tag[i] == ' ' {\n-\t\t\ti++\n-\t\t}\n-\t\ttag = tag[i:]\n-\t\tif tag == \"\" {\n-\t\t\tbreak\n-\t\t}\n-\n-\t\t// Scan to colon. A space, a quote or a control character is a syntax error.\n-\t\t// Strictly speaking, control chars include the range [0x7f, 0x9f], not just\n-\t\t// [0x00, 0x1f], but in practice, we ignore the multi-byte control characters\n-\t\t// as it is simpler to inspect the tag's bytes than the tag's runes.\n-\t\ti = 0\n-\t\tfor i < len(tag) && tag[i] > ' ' && tag[i] != ':' && tag[i] != '\"' && tag[i] != 0x7f {\n-\t\t\ti++\n-\t\t}\n-\t\tif i == 0 {\n-\t\t\treturn errTagKeySyntax\n-\t\t}\n-\t\tif i+1 >= len(tag) || tag[i] != ':' {\n-\t\t\treturn errTagSyntax\n-\t\t}\n-\t\tif tag[i+1] != '\"' {\n-\t\t\treturn errTagValueSyntax\n-\t\t}\n-\t\tkey := tag[:i]\n-\t\ttag = tag[i+1:]\n-\n-\t\t// Scan quoted string to find value.\n-\t\ti = 1\n-\t\tfor i < len(tag) && tag[i] != '\"' {\n-\t\t\tif tag[i] == '\\\\' {\n-\t\t\t\ti++\n-\t\t\t}\n-\t\t\ti++\n-\t\t}\n-\t\tif i >= len(tag) {\n-\t\t\treturn errTagValueSyntax\n-\t\t}\n-\t\tqvalue := tag[:i+1]\n-\t\ttag = tag[i+1:]\n-\n-\t\tvalue, err := strconv.Unquote(qvalue)\n-\t\tif err != nil {\n-\t\t\treturn errTagValueSyntax\n-\t\t}\n-\n-\t\tif !checkTagSpaces[key] {\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tswitch key {\n-\t\tcase \"xml\":\n-\t\t\t// If the first or last character in the XML tag is a space, it is\n-\t\t\t// suspicious.\n-\t\t\tif strings.Trim(value, \" \") != value {\n-\t\t\t\treturn errTagValueSpace\n-\t\t\t}\n-\n-\t\t\t// If there are multiple spaces, they are suspicious.\n-\t\t\tif strings.Count(value, \" \") > 1 {\n-\t\t\t\treturn errTagValueSpace\n-\t\t\t}\n-\n-\t\t\t// If there is no comma, skip the rest of the checks.\n-\t\t\tcomma := strings.IndexRune(value, ',')\n-\t\t\tif comma < 0 {\n-\t\t\t\tcontinue\n-\t\t\t}\n-\n-\t\t\t// If the character before a comma is a space, this is suspicious.\n-\t\t\tif comma > 0 && value[comma-1] == ' ' {\n-\t\t\t\treturn errTagValueSpace\n-\t\t\t}\n-\t\t\tvalue = value[comma+1:]\n-\t\tcase \"json\":\n-\t\t\t// JSON allows using spaces in the name, so skip it.\n-\t\t\tcomma := strings.IndexRune(value, ',')\n-\t\t\tif comma < 0 {\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tvalue = value[comma+1:]\n-\t\t}\n-\n-\t\tif strings.IndexByte(value, ' ') >= 0 {\n-\t\t\treturn errTagValueSpace\n-\t\t}\n-\t}\n-\treturn nil\n-}"}, {"sha": "2237ddc3b05c9324cf9c1dabbf0fba4093810bbc", "filename": "libgo/go/cmd/vet/testdata/asm/asm.go", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm%2Fasm.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm%2Fasm.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm%2Fasm.go?ref=225220d668dafb8262db7012bced688acbe63b33", "patch": "@@ -1,48 +0,0 @@\n-// Copyright 2010 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build ignore\n-\n-// This file contains declarations to test the assembly in test_asm.s.\n-\n-package testdata\n-\n-type S struct {\n-\ti int32\n-\tb bool\n-\ts string\n-}\n-\n-func arg1(x int8, y uint8)\n-func arg2(x int16, y uint16)\n-func arg4(x int32, y uint32)\n-func arg8(x int64, y uint64)\n-func argint(x int, y uint)\n-func argptr(x *byte, y *byte, c chan int, m map[int]int, f func())\n-func argstring(x, y string)\n-func argslice(x, y []string)\n-func argiface(x interface{}, y interface {\n-\tm()\n-})\n-func argcomplex(x complex64, y complex128)\n-func argstruct(x S, y struct{})\n-func argarray(x [2]S)\n-func returnint() int\n-func returnbyte(x int) byte\n-func returnnamed(x byte) (r1 int, r2 int16, r3 string, r4 byte)\n-func returnintmissing() int\n-func leaf(x, y int) int\n-\n-func noprof(x int)\n-func dupok(x int)\n-func nosplit(x int)\n-func rodata(x int)\n-func noptr(x int)\n-func wrapper(x int)\n-\n-func f15271() (x uint32)\n-func f17584(x float32, y complex64)\n-\n-func noframe1(x int32)\n-func noframe2(x int32)"}, {"sha": "cac6ed22cd0031f16c37689e4e750cb0ee15682f", "filename": "libgo/go/cmd/vet/testdata/asm/asm1.s", "status": "removed", "additions": 0, "deletions": 315, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm%2Fasm1.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm%2Fasm1.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm%2Fasm1.s?ref=225220d668dafb8262db7012bced688acbe63b33", "patch": "@@ -1,315 +0,0 @@\n-// Copyright 2013 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build amd64\n-// +build vet_test\n-\n-TEXT \u00b7arg1(SB),0,$0-2\n-\tMOVB\tx+0(FP), AX\n-\t// MOVB x+0(FP), AX // commented out instructions used to panic\n-\tMOVB\ty+1(FP), BX\n-\tMOVW\tx+0(FP), AX // ERROR \"\\[amd64\\] arg1: invalid MOVW of x\\+0\\(FP\\); int8 is 1-byte value\"\n-\tMOVW\ty+1(FP), AX // ERROR \"invalid MOVW of y\\+1\\(FP\\); uint8 is 1-byte value\"\n-\tMOVL\tx+0(FP), AX // ERROR \"invalid MOVL of x\\+0\\(FP\\); int8 is 1-byte value\"\n-\tMOVL\ty+1(FP), AX // ERROR \"invalid MOVL of y\\+1\\(FP\\); uint8 is 1-byte value\"\n-\tMOVQ\tx+0(FP), AX // ERROR \"invalid MOVQ of x\\+0\\(FP\\); int8 is 1-byte value\"\n-\tMOVQ\ty+1(FP), AX // ERROR \"invalid MOVQ of y\\+1\\(FP\\); uint8 is 1-byte value\"\n-\tMOVB\tx+1(FP), AX // ERROR \"invalid offset x\\+1\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tMOVB\ty+2(FP), AX // ERROR \"invalid offset y\\+2\\(FP\\); expected y\\+1\\(FP\\)\"\n-\tTESTB\tx+0(FP), AX\n-\tTESTB\ty+1(FP), BX\n-\tTESTW\tx+0(FP), AX // ERROR \"invalid TESTW of x\\+0\\(FP\\); int8 is 1-byte value\"\n-\tTESTW\ty+1(FP), AX // ERROR \"invalid TESTW of y\\+1\\(FP\\); uint8 is 1-byte value\"\n-\tTESTL\tx+0(FP), AX // ERROR \"invalid TESTL of x\\+0\\(FP\\); int8 is 1-byte value\"\n-\tTESTL\ty+1(FP), AX // ERROR \"invalid TESTL of y\\+1\\(FP\\); uint8 is 1-byte value\"\n-\tTESTQ\tx+0(FP), AX // ERROR \"invalid TESTQ of x\\+0\\(FP\\); int8 is 1-byte value\"\n-\tTESTQ\ty+1(FP), AX // ERROR \"invalid TESTQ of y\\+1\\(FP\\); uint8 is 1-byte value\"\n-\tTESTB\tx+1(FP), AX // ERROR \"invalid offset x\\+1\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tTESTB\ty+2(FP), AX // ERROR \"invalid offset y\\+2\\(FP\\); expected y\\+1\\(FP\\)\"\n-\tMOVB\t8(SP), AX // ERROR \"8\\(SP\\) should be x\\+0\\(FP\\)\"\n-\tMOVB\t9(SP), AX // ERROR \"9\\(SP\\) should be y\\+1\\(FP\\)\"\n-\tMOVB\t10(SP), AX // ERROR \"use of 10\\(SP\\) points beyond argument frame\"\n-\tRET\n-\n-TEXT \u00b7arg2(SB),0,$0-4\n-\tMOVB\tx+0(FP), AX // ERROR \"arg2: invalid MOVB of x\\+0\\(FP\\); int16 is 2-byte value\"\n-\tMOVB\ty+2(FP), AX // ERROR \"invalid MOVB of y\\+2\\(FP\\); uint16 is 2-byte value\"\n-\tMOVW\tx+0(FP), AX\n-\tMOVW\ty+2(FP), BX\n-\tMOVL\tx+0(FP), AX // ERROR \"invalid MOVL of x\\+0\\(FP\\); int16 is 2-byte value\"\n-\tMOVL\ty+2(FP), AX // ERROR \"invalid MOVL of y\\+2\\(FP\\); uint16 is 2-byte value\"\n-\tMOVQ\tx+0(FP), AX // ERROR \"invalid MOVQ of x\\+0\\(FP\\); int16 is 2-byte value\"\n-\tMOVQ\ty+2(FP), AX // ERROR \"invalid MOVQ of y\\+2\\(FP\\); uint16 is 2-byte value\"\n-\tMOVW\tx+2(FP), AX // ERROR \"invalid offset x\\+2\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tMOVW\ty+0(FP), AX // ERROR \"invalid offset y\\+0\\(FP\\); expected y\\+2\\(FP\\)\"\n-\tTESTB\tx+0(FP), AX // ERROR \"invalid TESTB of x\\+0\\(FP\\); int16 is 2-byte value\"\n-\tTESTB\ty+2(FP), AX // ERROR \"invalid TESTB of y\\+2\\(FP\\); uint16 is 2-byte value\"\n-\tTESTW\tx+0(FP), AX\n-\tTESTW\ty+2(FP), BX\n-\tTESTL\tx+0(FP), AX // ERROR \"invalid TESTL of x\\+0\\(FP\\); int16 is 2-byte value\"\n-\tTESTL\ty+2(FP), AX // ERROR \"invalid TESTL of y\\+2\\(FP\\); uint16 is 2-byte value\"\n-\tTESTQ\tx+0(FP), AX // ERROR \"invalid TESTQ of x\\+0\\(FP\\); int16 is 2-byte value\"\n-\tTESTQ\ty+2(FP), AX // ERROR \"invalid TESTQ of y\\+2\\(FP\\); uint16 is 2-byte value\"\n-\tTESTW\tx+2(FP), AX // ERROR \"invalid offset x\\+2\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tTESTW\ty+0(FP), AX // ERROR \"invalid offset y\\+0\\(FP\\); expected y\\+2\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7arg4(SB),0,$0-2 // ERROR \"arg4: wrong argument size 2; expected \\$\\.\\.\\.-8\"\n-\tMOVB\tx+0(FP), AX // ERROR \"invalid MOVB of x\\+0\\(FP\\); int32 is 4-byte value\"\n-\tMOVB\ty+4(FP), BX // ERROR \"invalid MOVB of y\\+4\\(FP\\); uint32 is 4-byte value\"\n-\tMOVW\tx+0(FP), AX // ERROR \"invalid MOVW of x\\+0\\(FP\\); int32 is 4-byte value\"\n-\tMOVW\ty+4(FP), AX // ERROR \"invalid MOVW of y\\+4\\(FP\\); uint32 is 4-byte value\"\n-\tMOVL\tx+0(FP), AX\n-\tMOVL\ty+4(FP), AX\n-\tMOVQ\tx+0(FP), AX // ERROR \"invalid MOVQ of x\\+0\\(FP\\); int32 is 4-byte value\"\n-\tMOVQ\ty+4(FP), AX // ERROR \"invalid MOVQ of y\\+4\\(FP\\); uint32 is 4-byte value\"\n-\tMOVL\tx+4(FP), AX // ERROR \"invalid offset x\\+4\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tMOVL\ty+2(FP), AX // ERROR \"invalid offset y\\+2\\(FP\\); expected y\\+4\\(FP\\)\"\n-\tTESTB\tx+0(FP), AX // ERROR \"invalid TESTB of x\\+0\\(FP\\); int32 is 4-byte value\"\n-\tTESTB\ty+4(FP), BX // ERROR \"invalid TESTB of y\\+4\\(FP\\); uint32 is 4-byte value\"\n-\tTESTW\tx+0(FP), AX // ERROR \"invalid TESTW of x\\+0\\(FP\\); int32 is 4-byte value\"\n-\tTESTW\ty+4(FP), AX // ERROR \"invalid TESTW of y\\+4\\(FP\\); uint32 is 4-byte value\"\n-\tTESTL\tx+0(FP), AX\n-\tTESTL\ty+4(FP), AX\n-\tTESTQ\tx+0(FP), AX // ERROR \"invalid TESTQ of x\\+0\\(FP\\); int32 is 4-byte value\"\n-\tTESTQ\ty+4(FP), AX // ERROR \"invalid TESTQ of y\\+4\\(FP\\); uint32 is 4-byte value\"\n-\tTESTL\tx+4(FP), AX // ERROR \"invalid offset x\\+4\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tTESTL\ty+2(FP), AX // ERROR \"invalid offset y\\+2\\(FP\\); expected y\\+4\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7arg8(SB),7,$0-2 // ERROR \"wrong argument size 2; expected \\$\\.\\.\\.-16\"\n-\tMOVB\tx+0(FP), AX // ERROR \"invalid MOVB of x\\+0\\(FP\\); int64 is 8-byte value\"\n-\tMOVB\ty+8(FP), BX // ERROR \"invalid MOVB of y\\+8\\(FP\\); uint64 is 8-byte value\"\n-\tMOVW\tx+0(FP), AX // ERROR \"invalid MOVW of x\\+0\\(FP\\); int64 is 8-byte value\"\n-\tMOVW\ty+8(FP), AX // ERROR \"invalid MOVW of y\\+8\\(FP\\); uint64 is 8-byte value\"\n-\tMOVL\tx+0(FP), AX // ERROR \"invalid MOVL of x\\+0\\(FP\\); int64 is 8-byte value\"\n-\tMOVL\ty+8(FP), AX // ERROR \"invalid MOVL of y\\+8\\(FP\\); uint64 is 8-byte value\"\n-\tMOVQ\tx+0(FP), AX\n-\tMOVQ\ty+8(FP), AX\n-\tMOVQ\tx+8(FP), AX // ERROR \"invalid offset x\\+8\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tMOVQ\ty+2(FP), AX // ERROR \"invalid offset y\\+2\\(FP\\); expected y\\+8\\(FP\\)\"\n-\tTESTB\tx+0(FP), AX // ERROR \"invalid TESTB of x\\+0\\(FP\\); int64 is 8-byte value\"\n-\tTESTB\ty+8(FP), BX // ERROR \"invalid TESTB of y\\+8\\(FP\\); uint64 is 8-byte value\"\n-\tTESTW\tx+0(FP), AX // ERROR \"invalid TESTW of x\\+0\\(FP\\); int64 is 8-byte value\"\n-\tTESTW\ty+8(FP), AX // ERROR \"invalid TESTW of y\\+8\\(FP\\); uint64 is 8-byte value\"\n-\tTESTL\tx+0(FP), AX // ERROR \"invalid TESTL of x\\+0\\(FP\\); int64 is 8-byte value\"\n-\tTESTL\ty+8(FP), AX // ERROR \"invalid TESTL of y\\+8\\(FP\\); uint64 is 8-byte value\"\n-\tTESTQ\tx+0(FP), AX\n-\tTESTQ\ty+8(FP), AX\n-\tTESTQ\tx+8(FP), AX // ERROR \"invalid offset x\\+8\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tTESTQ\ty+2(FP), AX // ERROR \"invalid offset y\\+2\\(FP\\); expected y\\+8\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7argint(SB),0,$0-2 // ERROR \"wrong argument size 2; expected \\$\\.\\.\\.-16\"\n-\tMOVB\tx+0(FP), AX // ERROR \"invalid MOVB of x\\+0\\(FP\\); int is 8-byte value\"\n-\tMOVB\ty+8(FP), BX // ERROR \"invalid MOVB of y\\+8\\(FP\\); uint is 8-byte value\"\n-\tMOVW\tx+0(FP), AX // ERROR \"invalid MOVW of x\\+0\\(FP\\); int is 8-byte value\"\n-\tMOVW\ty+8(FP), AX // ERROR \"invalid MOVW of y\\+8\\(FP\\); uint is 8-byte value\"\n-\tMOVL\tx+0(FP), AX // ERROR \"invalid MOVL of x\\+0\\(FP\\); int is 8-byte value\"\n-\tMOVL\ty+8(FP), AX // ERROR \"invalid MOVL of y\\+8\\(FP\\); uint is 8-byte value\"\n-\tMOVQ\tx+0(FP), AX\n-\tMOVQ\ty+8(FP), AX\n-\tMOVQ\tx+8(FP), AX // ERROR \"invalid offset x\\+8\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tMOVQ\ty+2(FP), AX // ERROR \"invalid offset y\\+2\\(FP\\); expected y\\+8\\(FP\\)\"\n-\tTESTB\tx+0(FP), AX // ERROR \"invalid TESTB of x\\+0\\(FP\\); int is 8-byte value\"\n-\tTESTB\ty+8(FP), BX // ERROR \"invalid TESTB of y\\+8\\(FP\\); uint is 8-byte value\"\n-\tTESTW\tx+0(FP), AX // ERROR \"invalid TESTW of x\\+0\\(FP\\); int is 8-byte value\"\n-\tTESTW\ty+8(FP), AX // ERROR \"invalid TESTW of y\\+8\\(FP\\); uint is 8-byte value\"\n-\tTESTL\tx+0(FP), AX // ERROR \"invalid TESTL of x\\+0\\(FP\\); int is 8-byte value\"\n-\tTESTL\ty+8(FP), AX // ERROR \"invalid TESTL of y\\+8\\(FP\\); uint is 8-byte value\"\n-\tTESTQ\tx+0(FP), AX\n-\tTESTQ\ty+8(FP), AX\n-\tTESTQ\tx+8(FP), AX // ERROR \"invalid offset x\\+8\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tTESTQ\ty+2(FP), AX // ERROR \"invalid offset y\\+2\\(FP\\); expected y\\+8\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7argptr(SB),7,$0-2 // ERROR \"wrong argument size 2; expected \\$\\.\\.\\.-40\"\n-\tMOVB\tx+0(FP), AX // ERROR \"invalid MOVB of x\\+0\\(FP\\); \\*byte is 8-byte value\"\n-\tMOVB\ty+8(FP), BX // ERROR \"invalid MOVB of y\\+8\\(FP\\); \\*byte is 8-byte value\"\n-\tMOVW\tx+0(FP), AX // ERROR \"invalid MOVW of x\\+0\\(FP\\); \\*byte is 8-byte value\"\n-\tMOVW\ty+8(FP), AX // ERROR \"invalid MOVW of y\\+8\\(FP\\); \\*byte is 8-byte value\"\n-\tMOVL\tx+0(FP), AX // ERROR \"invalid MOVL of x\\+0\\(FP\\); \\*byte is 8-byte value\"\n-\tMOVL\ty+8(FP), AX // ERROR \"invalid MOVL of y\\+8\\(FP\\); \\*byte is 8-byte value\"\n-\tMOVQ\tx+0(FP), AX\n-\tMOVQ\ty+8(FP), AX\n-\tMOVQ\tx+8(FP), AX // ERROR \"invalid offset x\\+8\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tMOVQ\ty+2(FP), AX // ERROR \"invalid offset y\\+2\\(FP\\); expected y\\+8\\(FP\\)\"\n-\tTESTB\tx+0(FP), AX // ERROR \"invalid TESTB of x\\+0\\(FP\\); \\*byte is 8-byte value\"\n-\tTESTB\ty+8(FP), BX // ERROR \"invalid TESTB of y\\+8\\(FP\\); \\*byte is 8-byte value\"\n-\tTESTW\tx+0(FP), AX // ERROR \"invalid TESTW of x\\+0\\(FP\\); \\*byte is 8-byte value\"\n-\tTESTW\ty+8(FP), AX // ERROR \"invalid TESTW of y\\+8\\(FP\\); \\*byte is 8-byte value\"\n-\tTESTL\tx+0(FP), AX // ERROR \"invalid TESTL of x\\+0\\(FP\\); \\*byte is 8-byte value\"\n-\tTESTL\ty+8(FP), AX // ERROR \"invalid TESTL of y\\+8\\(FP\\); \\*byte is 8-byte value\"\n-\tTESTQ\tx+0(FP), AX\n-\tTESTQ\ty+8(FP), AX\n-\tTESTQ\tx+8(FP), AX // ERROR \"invalid offset x\\+8\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tTESTQ\ty+2(FP), AX // ERROR \"invalid offset y\\+2\\(FP\\); expected y\\+8\\(FP\\)\"\n-\tMOVL\tc+16(FP), AX // ERROR \"invalid MOVL of c\\+16\\(FP\\); chan int is 8-byte value\"\n-\tMOVL\tm+24(FP), AX // ERROR \"invalid MOVL of m\\+24\\(FP\\); map\\[int\\]int is 8-byte value\"\n-\tMOVL\tf+32(FP), AX // ERROR \"invalid MOVL of f\\+32\\(FP\\); func\\(\\) is 8-byte value\"\n-\tRET\n-\n-TEXT \u00b7argstring(SB),0,$32 // ERROR \"wrong argument size 0; expected \\$\\.\\.\\.-32\"\n-\tMOVW\tx+0(FP), AX // ERROR \"invalid MOVW of x\\+0\\(FP\\); string base is 8-byte value\"\n-\tMOVL\tx+0(FP), AX // ERROR \"invalid MOVL of x\\+0\\(FP\\); string base is 8-byte value\"\n-\tMOVQ\tx+0(FP), AX\n-\tMOVW\tx_base+0(FP), AX // ERROR \"invalid MOVW of x_base\\+0\\(FP\\); string base is 8-byte value\"\n-\tMOVL\tx_base+0(FP), AX // ERROR \"invalid MOVL of x_base\\+0\\(FP\\); string base is 8-byte value\"\n-\tMOVQ\tx_base+0(FP), AX\n-\tMOVW\tx_len+0(FP), AX // ERROR \"invalid offset x_len\\+0\\(FP\\); expected x_len\\+8\\(FP\\)\"\n-\tMOVL\tx_len+0(FP), AX // ERROR \"invalid offset x_len\\+0\\(FP\\); expected x_len\\+8\\(FP\\)\"\n-\tMOVQ\tx_len+0(FP), AX // ERROR \"invalid offset x_len\\+0\\(FP\\); expected x_len\\+8\\(FP\\)\"\n-\tMOVW\tx_len+8(FP), AX // ERROR \"invalid MOVW of x_len\\+8\\(FP\\); string len is 8-byte value\"\n-\tMOVL\tx_len+8(FP), AX // ERROR \"invalid MOVL of x_len\\+8\\(FP\\); string len is 8-byte value\"\n-\tMOVQ\tx_len+8(FP), AX\n-\tMOVQ\ty+0(FP), AX // ERROR \"invalid offset y\\+0\\(FP\\); expected y\\+16\\(FP\\)\"\n-\tMOVQ\ty_len+8(FP), AX // ERROR \"invalid offset y_len\\+8\\(FP\\); expected y_len\\+24\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7argslice(SB),0,$48 // ERROR \"wrong argument size 0; expected \\$\\.\\.\\.-48\"\n-\tMOVW\tx+0(FP), AX // ERROR \"invalid MOVW of x\\+0\\(FP\\); slice base is 8-byte value\"\n-\tMOVL\tx+0(FP), AX // ERROR \"invalid MOVL of x\\+0\\(FP\\); slice base is 8-byte value\"\n-\tMOVQ\tx+0(FP), AX\n-\tMOVW\tx_base+0(FP), AX // ERROR \"invalid MOVW of x_base\\+0\\(FP\\); slice base is 8-byte value\"\n-\tMOVL\tx_base+0(FP), AX // ERROR \"invalid MOVL of x_base\\+0\\(FP\\); slice base is 8-byte value\"\n-\tMOVQ\tx_base+0(FP), AX\n-\tMOVW\tx_len+0(FP), AX // ERROR \"invalid offset x_len\\+0\\(FP\\); expected x_len\\+8\\(FP\\)\"\n-\tMOVL\tx_len+0(FP), AX // ERROR \"invalid offset x_len\\+0\\(FP\\); expected x_len\\+8\\(FP\\)\"\n-\tMOVQ\tx_len+0(FP), AX // ERROR \"invalid offset x_len\\+0\\(FP\\); expected x_len\\+8\\(FP\\)\"\n-\tMOVW\tx_len+8(FP), AX // ERROR \"invalid MOVW of x_len\\+8\\(FP\\); slice len is 8-byte value\"\n-\tMOVL\tx_len+8(FP), AX // ERROR \"invalid MOVL of x_len\\+8\\(FP\\); slice len is 8-byte value\"\n-\tMOVQ\tx_len+8(FP), AX\n-\tMOVW\tx_cap+0(FP), AX // ERROR \"invalid offset x_cap\\+0\\(FP\\); expected x_cap\\+16\\(FP\\)\"\n-\tMOVL\tx_cap+0(FP), AX // ERROR \"invalid offset x_cap\\+0\\(FP\\); expected x_cap\\+16\\(FP\\)\"\n-\tMOVQ\tx_cap+0(FP), AX // ERROR \"invalid offset x_cap\\+0\\(FP\\); expected x_cap\\+16\\(FP\\)\"\n-\tMOVW\tx_cap+16(FP), AX // ERROR \"invalid MOVW of x_cap\\+16\\(FP\\); slice cap is 8-byte value\"\n-\tMOVL\tx_cap+16(FP), AX // ERROR \"invalid MOVL of x_cap\\+16\\(FP\\); slice cap is 8-byte value\"\n-\tMOVQ\tx_cap+16(FP), AX\n-\tMOVQ\ty+0(FP), AX // ERROR \"invalid offset y\\+0\\(FP\\); expected y\\+24\\(FP\\)\"\n-\tMOVQ\ty_len+8(FP), AX // ERROR \"invalid offset y_len\\+8\\(FP\\); expected y_len\\+32\\(FP\\)\"\n-\tMOVQ\ty_cap+16(FP), AX // ERROR \"invalid offset y_cap\\+16\\(FP\\); expected y_cap\\+40\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7argiface(SB),0,$0-32\n-\tMOVW\tx+0(FP), AX // ERROR \"invalid MOVW of x\\+0\\(FP\\); interface type is 8-byte value\"\n-\tMOVL\tx+0(FP), AX // ERROR \"invalid MOVL of x\\+0\\(FP\\); interface type is 8-byte value\"\n-\tMOVQ\tx+0(FP), AX\n-\tMOVW\tx_type+0(FP), AX // ERROR \"invalid MOVW of x_type\\+0\\(FP\\); interface type is 8-byte value\"\n-\tMOVL\tx_type+0(FP), AX // ERROR \"invalid MOVL of x_type\\+0\\(FP\\); interface type is 8-byte value\"\n-\tMOVQ\tx_type+0(FP), AX\n-\tMOVQ\tx_itable+0(FP), AX // ERROR \"unknown variable x_itable; offset 0 is x_type\\+0\\(FP\\)\"\n-\tMOVQ\tx_itable+1(FP), AX // ERROR \"unknown variable x_itable; offset 1 is x_type\\+0\\(FP\\)\"\n-\tMOVW\tx_data+0(FP), AX // ERROR \"invalid offset x_data\\+0\\(FP\\); expected x_data\\+8\\(FP\\)\"\n-\tMOVL\tx_data+0(FP), AX // ERROR \"invalid offset x_data\\+0\\(FP\\); expected x_data\\+8\\(FP\\)\"\n-\tMOVQ\tx_data+0(FP), AX // ERROR \"invalid offset x_data\\+0\\(FP\\); expected x_data\\+8\\(FP\\)\"\n-\tMOVW\tx_data+8(FP), AX // ERROR \"invalid MOVW of x_data\\+8\\(FP\\); interface data is 8-byte value\"\n-\tMOVL\tx_data+8(FP), AX // ERROR \"invalid MOVL of x_data\\+8\\(FP\\); interface data is 8-byte value\"\n-\tMOVQ\tx_data+8(FP), AX\n-\tMOVW\ty+16(FP), AX // ERROR \"invalid MOVW of y\\+16\\(FP\\); interface itable is 8-byte value\"\n-\tMOVL\ty+16(FP), AX // ERROR \"invalid MOVL of y\\+16\\(FP\\); interface itable is 8-byte value\"\n-\tMOVQ\ty+16(FP), AX\n-\tMOVW\ty_itable+16(FP), AX // ERROR \"invalid MOVW of y_itable\\+16\\(FP\\); interface itable is 8-byte value\"\n-\tMOVL\ty_itable+16(FP), AX // ERROR \"invalid MOVL of y_itable\\+16\\(FP\\); interface itable is 8-byte value\"\n-\tMOVQ\ty_itable+16(FP), AX\n-\tMOVQ\ty_type+16(FP), AX // ERROR \"unknown variable y_type; offset 16 is y_itable\\+16\\(FP\\)\"\n-\tMOVW\ty_data+16(FP), AX // ERROR \"invalid offset y_data\\+16\\(FP\\); expected y_data\\+24\\(FP\\)\"\n-\tMOVL\ty_data+16(FP), AX // ERROR \"invalid offset y_data\\+16\\(FP\\); expected y_data\\+24\\(FP\\)\"\n-\tMOVQ\ty_data+16(FP), AX // ERROR \"invalid offset y_data\\+16\\(FP\\); expected y_data\\+24\\(FP\\)\"\n-\tMOVW\ty_data+24(FP), AX // ERROR \"invalid MOVW of y_data\\+24\\(FP\\); interface data is 8-byte value\"\n-\tMOVL\ty_data+24(FP), AX // ERROR \"invalid MOVL of y_data\\+24\\(FP\\); interface data is 8-byte value\"\n-\tMOVQ\ty_data+24(FP), AX\n-\tRET\n-\n-TEXT \u00b7argcomplex(SB),0,$24 // ERROR \"wrong argument size 0; expected \\$\\.\\.\\.-24\"\n-\tMOVSS\tx+0(FP), X0 // ERROR \"invalid MOVSS of x\\+0\\(FP\\); complex64 is 8-byte value containing x_real\\+0\\(FP\\) and x_imag\\+4\\(FP\\)\"\n-\tMOVSD\tx+0(FP), X0 // ERROR \"invalid MOVSD of x\\+0\\(FP\\); complex64 is 8-byte value containing x_real\\+0\\(FP\\) and x_imag\\+4\\(FP\\)\"\n-\tMOVSS\tx_real+0(FP), X0\n-\tMOVSD\tx_real+0(FP), X0 // ERROR \"invalid MOVSD of x_real\\+0\\(FP\\); real\\(complex64\\) is 4-byte value\"\n-\tMOVSS\tx_real+4(FP), X0 // ERROR \"invalid offset x_real\\+4\\(FP\\); expected x_real\\+0\\(FP\\)\"\n-\tMOVSS\tx_imag+4(FP), X0\n-\tMOVSD\tx_imag+4(FP), X0 // ERROR \"invalid MOVSD of x_imag\\+4\\(FP\\); imag\\(complex64\\) is 4-byte value\"\n-\tMOVSS\tx_imag+8(FP), X0 // ERROR \"invalid offset x_imag\\+8\\(FP\\); expected x_imag\\+4\\(FP\\)\"\n-\tMOVSD\ty+8(FP), X0 // ERROR \"invalid MOVSD of y\\+8\\(FP\\); complex128 is 16-byte value containing y_real\\+8\\(FP\\) and y_imag\\+16\\(FP\\)\"\n-\tMOVSS\ty_real+8(FP), X0 // ERROR \"invalid MOVSS of y_real\\+8\\(FP\\); real\\(complex128\\) is 8-byte value\"\n-\tMOVSD\ty_real+8(FP), X0\n-\tMOVSS\ty_real+16(FP), X0 // ERROR \"invalid offset y_real\\+16\\(FP\\); expected y_real\\+8\\(FP\\)\"\n-\tMOVSS\ty_imag+16(FP), X0 // ERROR \"invalid MOVSS of y_imag\\+16\\(FP\\); imag\\(complex128\\) is 8-byte value\"\n-\tMOVSD\ty_imag+16(FP), X0\n-\tMOVSS\ty_imag+24(FP), X0 // ERROR \"invalid offset y_imag\\+24\\(FP\\); expected y_imag\\+16\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7argstruct(SB),0,$64 // ERROR \"wrong argument size 0; expected \\$\\.\\.\\.-24\"\n-\tMOVQ\tx+0(FP), AX // ERROR \"invalid MOVQ of x\\+0\\(FP\\); testdata.S is 24-byte value\"\n-\tMOVQ\tx_i+0(FP), AX // ERROR \"invalid MOVQ of x_i\\+0\\(FP\\); int32 is 4-byte value\"\n-\tMOVQ\tx_b+0(FP), AX // ERROR \"invalid offset x_b\\+0\\(FP\\); expected x_b\\+4\\(FP\\)\"\n-\tMOVQ\tx_s+8(FP), AX\n-\tMOVQ\tx_s_base+8(FP), AX\n-\tMOVQ\tx_s+16(FP), AX // ERROR \"invalid offset x_s\\+16\\(FP\\); expected x_s\\+8\\(FP\\), x_s_base\\+8\\(FP\\), or x_s_len\\+16\\(FP\\)\"\n-\tMOVQ\tx_s_len+16(FP), AX\n-\tRET\n-\n-TEXT \u00b7argarray(SB),0,$64 // ERROR \"wrong argument size 0; expected \\$\\.\\.\\.-48\"\n-\tMOVQ\tx+0(FP), AX // ERROR \"invalid MOVQ of x\\+0\\(FP\\); \\[2\\]testdata.S is 48-byte value\"\n-\tMOVQ\tx_0_i+0(FP), AX // ERROR \"invalid MOVQ of x_0_i\\+0\\(FP\\); int32 is 4-byte value\"\n-\tMOVQ\tx_0_b+0(FP), AX // ERROR \"invalid offset x_0_b\\+0\\(FP\\); expected x_0_b\\+4\\(FP\\)\"\n-\tMOVQ\tx_0_s+8(FP), AX\n-\tMOVQ\tx_0_s_base+8(FP), AX\n-\tMOVQ\tx_0_s+16(FP), AX // ERROR \"invalid offset x_0_s\\+16\\(FP\\); expected x_0_s\\+8\\(FP\\), x_0_s_base\\+8\\(FP\\), or x_0_s_len\\+16\\(FP\\)\"\n-\tMOVQ\tx_0_s_len+16(FP), AX\n-\tMOVB\tfoo+25(FP), AX // ERROR \"unknown variable foo; offset 25 is x_1_i\\+24\\(FP\\)\"\n-\tMOVQ\tx_1_s+32(FP), AX\n-\tMOVQ\tx_1_s_base+32(FP), AX\n-\tMOVQ\tx_1_s+40(FP), AX // ERROR \"invalid offset x_1_s\\+40\\(FP\\); expected x_1_s\\+32\\(FP\\), x_1_s_base\\+32\\(FP\\), or x_1_s_len\\+40\\(FP\\)\"\n-\tMOVQ\tx_1_s_len+40(FP), AX\n-\tRET\n-\n-TEXT \u00b7returnint(SB),0,$0-8\n-\tMOVB\tAX, ret+0(FP) // ERROR \"invalid MOVB of ret\\+0\\(FP\\); int is 8-byte value\"\n-\tMOVW\tAX, ret+0(FP) // ERROR \"invalid MOVW of ret\\+0\\(FP\\); int is 8-byte value\"\n-\tMOVL\tAX, ret+0(FP) // ERROR \"invalid MOVL of ret\\+0\\(FP\\); int is 8-byte value\"\n-\tMOVQ\tAX, ret+0(FP)\n-\tMOVQ\tAX, ret+1(FP) // ERROR \"invalid offset ret\\+1\\(FP\\); expected ret\\+0\\(FP\\)\"\n-\tMOVQ\tAX, r+0(FP) // ERROR \"unknown variable r; offset 0 is ret\\+0\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7returnbyte(SB),0,$0-9\n-\tMOVQ\tx+0(FP), AX\n-\tMOVB\tAX, ret+8(FP)\n-\tMOVW\tAX, ret+8(FP) // ERROR \"invalid MOVW of ret\\+8\\(FP\\); byte is 1-byte value\"\n-\tMOVL\tAX, ret+8(FP) // ERROR \"invalid MOVL of ret\\+8\\(FP\\); byte is 1-byte value\"\n-\tMOVQ\tAX, ret+8(FP) // ERROR \"invalid MOVQ of ret\\+8\\(FP\\); byte is 1-byte value\"\n-\tMOVB\tAX, ret+7(FP) // ERROR \"invalid offset ret\\+7\\(FP\\); expected ret\\+8\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7returnnamed(SB),0,$0-41\n-\tMOVB\tx+0(FP), AX\n-\tMOVQ\tAX, r1+8(FP)\n-\tMOVW\tAX, r2+16(FP)\n-\tMOVQ\tAX, r3+24(FP)\n-\tMOVQ\tAX, r3_base+24(FP)\n-\tMOVQ\tAX, r3_len+32(FP)\n-\tMOVB\tAX, r4+40(FP)\n-\tMOVL\tAX, r1+8(FP) // ERROR \"invalid MOVL of r1\\+8\\(FP\\); int is 8-byte value\"\n-\tRET\n-\n-TEXT \u00b7returnintmissing(SB),0,$0-8\n-\tRET // ERROR \"RET without writing to 8-byte ret\\+0\\(FP\\)\"\n-\n-\n-// issue 15271\n-TEXT \u00b7f15271(SB), NOSPLIT, $0-4\n-    // Stick 123 into the low 32 bits of X0.\n-    MOVQ $123, AX\n-    PINSRD $0, AX, X0\n-\n-    // Return them.\n-    PEXTRD $0, X0, x+0(FP)\n-    RET\n-\n-// issue 17584\n-TEXT \u00b7f17584(SB), NOSPLIT, $12\n-\tMOVSS\tx+0(FP), X0\n-\tMOVSS\ty_real+4(FP), X0\n-\tMOVSS\ty_imag+8(FP), X0\n-\tRET"}, {"sha": "c33c02a70b27e34ad5205501eb0bd935750be51d", "filename": "libgo/go/cmd/vet/testdata/asm/asm2.s", "status": "removed", "additions": 0, "deletions": 257, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm%2Fasm2.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm%2Fasm2.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm%2Fasm2.s?ref=225220d668dafb8262db7012bced688acbe63b33", "patch": "@@ -1,257 +0,0 @@\n-// Copyright 2013 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build 386\n-// +build vet_test\n-\n-TEXT \u00b7arg1(SB),0,$0-2\n-\tMOVB\tx+0(FP), AX\n-\tMOVB\ty+1(FP), BX\n-\tMOVW\tx+0(FP), AX // ERROR \"\\[386\\] arg1: invalid MOVW of x\\+0\\(FP\\); int8 is 1-byte value\"\n-\tMOVW\ty+1(FP), AX // ERROR \"invalid MOVW of y\\+1\\(FP\\); uint8 is 1-byte value\"\n-\tMOVL\tx+0(FP), AX // ERROR \"invalid MOVL of x\\+0\\(FP\\); int8 is 1-byte value\"\n-\tMOVL\ty+1(FP), AX // ERROR \"invalid MOVL of y\\+1\\(FP\\); uint8 is 1-byte value\"\n-\tMOVQ\tx+0(FP), AX // ERROR \"invalid MOVQ of x\\+0\\(FP\\); int8 is 1-byte value\"\n-\tMOVQ\ty+1(FP), AX // ERROR \"invalid MOVQ of y\\+1\\(FP\\); uint8 is 1-byte value\"\n-\tMOVB\tx+1(FP), AX // ERROR \"invalid offset x\\+1\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tMOVB\ty+2(FP), AX // ERROR \"invalid offset y\\+2\\(FP\\); expected y\\+1\\(FP\\)\"\n-\tTESTB\tx+0(FP), AX\n-\tTESTB\ty+1(FP), BX\n-\tTESTW\tx+0(FP), AX // ERROR \"invalid TESTW of x\\+0\\(FP\\); int8 is 1-byte value\"\n-\tTESTW\ty+1(FP), AX // ERROR \"invalid TESTW of y\\+1\\(FP\\); uint8 is 1-byte value\"\n-\tTESTL\tx+0(FP), AX // ERROR \"invalid TESTL of x\\+0\\(FP\\); int8 is 1-byte value\"\n-\tTESTL\ty+1(FP), AX // ERROR \"invalid TESTL of y\\+1\\(FP\\); uint8 is 1-byte value\"\n-\tTESTQ\tx+0(FP), AX // ERROR \"invalid TESTQ of x\\+0\\(FP\\); int8 is 1-byte value\"\n-\tTESTQ\ty+1(FP), AX // ERROR \"invalid TESTQ of y\\+1\\(FP\\); uint8 is 1-byte value\"\n-\tTESTB\tx+1(FP), AX // ERROR \"invalid offset x\\+1\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tTESTB\ty+2(FP), AX // ERROR \"invalid offset y\\+2\\(FP\\); expected y\\+1\\(FP\\)\"\n-\tMOVB\t4(SP), AX // ERROR \"4\\(SP\\) should be x\\+0\\(FP\\)\"\n-\tMOVB\t5(SP), AX // ERROR \"5\\(SP\\) should be y\\+1\\(FP\\)\"\n-\tMOVB\t6(SP), AX // ERROR \"use of 6\\(SP\\) points beyond argument frame\"\n-\tRET\n-\n-TEXT \u00b7arg2(SB),0,$0-4\n-\tMOVB\tx+0(FP), AX // ERROR \"arg2: invalid MOVB of x\\+0\\(FP\\); int16 is 2-byte value\"\n-\tMOVB\ty+2(FP), AX // ERROR \"invalid MOVB of y\\+2\\(FP\\); uint16 is 2-byte value\"\n-\tMOVW\tx+0(FP), AX\n-\tMOVW\ty+2(FP), BX\n-\tMOVL\tx+0(FP), AX // ERROR \"invalid MOVL of x\\+0\\(FP\\); int16 is 2-byte value\"\n-\tMOVL\ty+2(FP), AX // ERROR \"invalid MOVL of y\\+2\\(FP\\); uint16 is 2-byte value\"\n-\tMOVQ\tx+0(FP), AX // ERROR \"invalid MOVQ of x\\+0\\(FP\\); int16 is 2-byte value\"\n-\tMOVQ\ty+2(FP), AX // ERROR \"invalid MOVQ of y\\+2\\(FP\\); uint16 is 2-byte value\"\n-\tMOVW\tx+2(FP), AX // ERROR \"invalid offset x\\+2\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tMOVW\ty+0(FP), AX // ERROR \"invalid offset y\\+0\\(FP\\); expected y\\+2\\(FP\\)\"\n-\tTESTB\tx+0(FP), AX // ERROR \"invalid TESTB of x\\+0\\(FP\\); int16 is 2-byte value\"\n-\tTESTB\ty+2(FP), AX // ERROR \"invalid TESTB of y\\+2\\(FP\\); uint16 is 2-byte value\"\n-\tTESTW\tx+0(FP), AX\n-\tTESTW\ty+2(FP), BX\n-\tTESTL\tx+0(FP), AX // ERROR \"invalid TESTL of x\\+0\\(FP\\); int16 is 2-byte value\"\n-\tTESTL\ty+2(FP), AX // ERROR \"invalid TESTL of y\\+2\\(FP\\); uint16 is 2-byte value\"\n-\tTESTQ\tx+0(FP), AX // ERROR \"invalid TESTQ of x\\+0\\(FP\\); int16 is 2-byte value\"\n-\tTESTQ\ty+2(FP), AX // ERROR \"invalid TESTQ of y\\+2\\(FP\\); uint16 is 2-byte value\"\n-\tTESTW\tx+2(FP), AX // ERROR \"invalid offset x\\+2\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tTESTW\ty+0(FP), AX // ERROR \"invalid offset y\\+0\\(FP\\); expected y\\+2\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7arg4(SB),0,$0-2 // ERROR \"arg4: wrong argument size 2; expected \\$\\.\\.\\.-8\"\n-\tMOVB\tx+0(FP), AX // ERROR \"invalid MOVB of x\\+0\\(FP\\); int32 is 4-byte value\"\n-\tMOVB\ty+4(FP), BX // ERROR \"invalid MOVB of y\\+4\\(FP\\); uint32 is 4-byte value\"\n-\tMOVW\tx+0(FP), AX // ERROR \"invalid MOVW of x\\+0\\(FP\\); int32 is 4-byte value\"\n-\tMOVW\ty+4(FP), AX // ERROR \"invalid MOVW of y\\+4\\(FP\\); uint32 is 4-byte value\"\n-\tMOVL\tx+0(FP), AX\n-\tMOVL\ty+4(FP), AX\n-\tMOVQ\tx+0(FP), AX // ERROR \"invalid MOVQ of x\\+0\\(FP\\); int32 is 4-byte value\"\n-\tMOVQ\ty+4(FP), AX // ERROR \"invalid MOVQ of y\\+4\\(FP\\); uint32 is 4-byte value\"\n-\tMOVL\tx+4(FP), AX // ERROR \"invalid offset x\\+4\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tMOVL\ty+2(FP), AX // ERROR \"invalid offset y\\+2\\(FP\\); expected y\\+4\\(FP\\)\"\n-\tTESTB\tx+0(FP), AX // ERROR \"invalid TESTB of x\\+0\\(FP\\); int32 is 4-byte value\"\n-\tTESTB\ty+4(FP), BX // ERROR \"invalid TESTB of y\\+4\\(FP\\); uint32 is 4-byte value\"\n-\tTESTW\tx+0(FP), AX // ERROR \"invalid TESTW of x\\+0\\(FP\\); int32 is 4-byte value\"\n-\tTESTW\ty+4(FP), AX // ERROR \"invalid TESTW of y\\+4\\(FP\\); uint32 is 4-byte value\"\n-\tTESTL\tx+0(FP), AX\n-\tTESTL\ty+4(FP), AX\n-\tTESTQ\tx+0(FP), AX // ERROR \"invalid TESTQ of x\\+0\\(FP\\); int32 is 4-byte value\"\n-\tTESTQ\ty+4(FP), AX // ERROR \"invalid TESTQ of y\\+4\\(FP\\); uint32 is 4-byte value\"\n-\tTESTL\tx+4(FP), AX // ERROR \"invalid offset x\\+4\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tTESTL\ty+2(FP), AX // ERROR \"invalid offset y\\+2\\(FP\\); expected y\\+4\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7arg8(SB),7,$0-2 // ERROR \"wrong argument size 2; expected \\$\\.\\.\\.-16\"\n-\tMOVB\tx+0(FP), AX // ERROR \"invalid MOVB of x\\+0\\(FP\\); int64 is 8-byte value\"\n-\tMOVB\ty+8(FP), BX // ERROR \"invalid MOVB of y\\+8\\(FP\\); uint64 is 8-byte value\"\n-\tMOVW\tx+0(FP), AX // ERROR \"invalid MOVW of x\\+0\\(FP\\); int64 is 8-byte value\"\n-\tMOVW\ty+8(FP), AX // ERROR \"invalid MOVW of y\\+8\\(FP\\); uint64 is 8-byte value\"\n-\tMOVL\tx+0(FP), AX // ERROR \"invalid MOVL of x\\+0\\(FP\\); int64 is 8-byte value containing x_lo\\+0\\(FP\\) and x_hi\\+4\\(FP\\)\"\n-\tMOVL\tx_lo+0(FP), AX\n-\tMOVL\tx_hi+4(FP), AX\n-\tMOVL\ty+8(FP), AX // ERROR \"invalid MOVL of y\\+8\\(FP\\); uint64 is 8-byte value containing y_lo\\+8\\(FP\\) and y_hi\\+12\\(FP\\)\"\n-\tMOVL\ty_lo+8(FP), AX\n-\tMOVL\ty_hi+12(FP), AX\n-\tMOVQ\tx+0(FP), AX\n-\tMOVQ\ty+8(FP), AX\n-\tMOVQ\tx+8(FP), AX // ERROR \"invalid offset x\\+8\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tMOVQ\ty+2(FP), AX // ERROR \"invalid offset y\\+2\\(FP\\); expected y\\+8\\(FP\\)\"\n-\tTESTB\tx+0(FP), AX // ERROR \"invalid TESTB of x\\+0\\(FP\\); int64 is 8-byte value\"\n-\tTESTB\ty+8(FP), BX // ERROR \"invalid TESTB of y\\+8\\(FP\\); uint64 is 8-byte value\"\n-\tTESTW\tx+0(FP), AX // ERROR \"invalid TESTW of x\\+0\\(FP\\); int64 is 8-byte value\"\n-\tTESTW\ty+8(FP), AX // ERROR \"invalid TESTW of y\\+8\\(FP\\); uint64 is 8-byte value\"\n-\tTESTL\tx+0(FP), AX // ERROR \"invalid TESTL of x\\+0\\(FP\\); int64 is 8-byte value containing x_lo\\+0\\(FP\\) and x_hi\\+4\\(FP\\)\"\n-\tTESTL\ty+8(FP), AX // ERROR \"invalid TESTL of y\\+8\\(FP\\); uint64 is 8-byte value containing y_lo\\+8\\(FP\\) and y_hi\\+12\\(FP\\)\"\n-\tTESTQ\tx+0(FP), AX\n-\tTESTQ\ty+8(FP), AX\n-\tTESTQ\tx+8(FP), AX // ERROR \"invalid offset x\\+8\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tTESTQ\ty+2(FP), AX // ERROR \"invalid offset y\\+2\\(FP\\); expected y\\+8\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7argint(SB),0,$0-2 // ERROR \"wrong argument size 2; expected \\$\\.\\.\\.-8\"\n-\tMOVB\tx+0(FP), AX // ERROR \"invalid MOVB of x\\+0\\(FP\\); int is 4-byte value\"\n-\tMOVB\ty+4(FP), BX // ERROR \"invalid MOVB of y\\+4\\(FP\\); uint is 4-byte value\"\n-\tMOVW\tx+0(FP), AX // ERROR \"invalid MOVW of x\\+0\\(FP\\); int is 4-byte value\"\n-\tMOVW\ty+4(FP), AX // ERROR \"invalid MOVW of y\\+4\\(FP\\); uint is 4-byte value\"\n-\tMOVL\tx+0(FP), AX\n-\tMOVL\ty+4(FP), AX\n-\tMOVQ\tx+0(FP), AX // ERROR \"invalid MOVQ of x\\+0\\(FP\\); int is 4-byte value\"\n-\tMOVQ\ty+4(FP), AX // ERROR \"invalid MOVQ of y\\+4\\(FP\\); uint is 4-byte value\"\n-\tMOVQ\tx+4(FP), AX // ERROR \"invalid offset x\\+4\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tMOVQ\ty+2(FP), AX // ERROR \"invalid offset y\\+2\\(FP\\); expected y\\+4\\(FP\\)\"\n-\tTESTB\tx+0(FP), AX // ERROR \"invalid TESTB of x\\+0\\(FP\\); int is 4-byte value\"\n-\tTESTB\ty+4(FP), BX // ERROR \"invalid TESTB of y\\+4\\(FP\\); uint is 4-byte value\"\n-\tTESTW\tx+0(FP), AX // ERROR \"invalid TESTW of x\\+0\\(FP\\); int is 4-byte value\"\n-\tTESTW\ty+4(FP), AX // ERROR \"invalid TESTW of y\\+4\\(FP\\); uint is 4-byte value\"\n-\tTESTL\tx+0(FP), AX\n-\tTESTL\ty+4(FP), AX\n-\tTESTQ\tx+0(FP), AX // ERROR \"invalid TESTQ of x\\+0\\(FP\\); int is 4-byte value\"\n-\tTESTQ\ty+4(FP), AX // ERROR \"invalid TESTQ of y\\+4\\(FP\\); uint is 4-byte value\"\n-\tTESTQ\tx+4(FP), AX // ERROR \"invalid offset x\\+4\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tTESTQ\ty+2(FP), AX // ERROR \"invalid offset y\\+2\\(FP\\); expected y\\+4\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7argptr(SB),7,$0-2 // ERROR \"wrong argument size 2; expected \\$\\.\\.\\.-20\"\n-\tMOVB\tx+0(FP), AX // ERROR \"invalid MOVB of x\\+0\\(FP\\); \\*byte is 4-byte value\"\n-\tMOVB\ty+4(FP), BX // ERROR \"invalid MOVB of y\\+4\\(FP\\); \\*byte is 4-byte value\"\n-\tMOVW\tx+0(FP), AX // ERROR \"invalid MOVW of x\\+0\\(FP\\); \\*byte is 4-byte value\"\n-\tMOVW\ty+4(FP), AX // ERROR \"invalid MOVW of y\\+4\\(FP\\); \\*byte is 4-byte value\"\n-\tMOVL\tx+0(FP), AX\n-\tMOVL\ty+4(FP), AX\n-\tMOVQ\tx+0(FP), AX // ERROR \"invalid MOVQ of x\\+0\\(FP\\); \\*byte is 4-byte value\"\n-\tMOVQ\ty+4(FP), AX // ERROR \"invalid MOVQ of y\\+4\\(FP\\); \\*byte is 4-byte value\"\n-\tMOVQ\tx+4(FP), AX // ERROR \"invalid offset x\\+4\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tMOVQ\ty+2(FP), AX // ERROR \"invalid offset y\\+2\\(FP\\); expected y\\+4\\(FP\\)\"\n-\tTESTB\tx+0(FP), AX // ERROR \"invalid TESTB of x\\+0\\(FP\\); \\*byte is 4-byte value\"\n-\tTESTB\ty+4(FP), BX // ERROR \"invalid TESTB of y\\+4\\(FP\\); \\*byte is 4-byte value\"\n-\tTESTW\tx+0(FP), AX // ERROR \"invalid TESTW of x\\+0\\(FP\\); \\*byte is 4-byte value\"\n-\tTESTW\ty+4(FP), AX // ERROR \"invalid TESTW of y\\+4\\(FP\\); \\*byte is 4-byte value\"\n-\tTESTL\tx+0(FP), AX\n-\tTESTL\ty+4(FP), AX\n-\tTESTQ\tx+0(FP), AX // ERROR \"invalid TESTQ of x\\+0\\(FP\\); \\*byte is 4-byte value\"\n-\tTESTQ\ty+4(FP), AX // ERROR \"invalid TESTQ of y\\+4\\(FP\\); \\*byte is 4-byte value\"\n-\tTESTQ\tx+4(FP), AX // ERROR \"invalid offset x\\+4\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tTESTQ\ty+2(FP), AX // ERROR \"invalid offset y\\+2\\(FP\\); expected y\\+4\\(FP\\)\"\n-\tMOVW\tc+8(FP), AX // ERROR \"invalid MOVW of c\\+8\\(FP\\); chan int is 4-byte value\"\n-\tMOVW\tm+12(FP), AX // ERROR \"invalid MOVW of m\\+12\\(FP\\); map\\[int\\]int is 4-byte value\"\n-\tMOVW\tf+16(FP), AX // ERROR \"invalid MOVW of f\\+16\\(FP\\); func\\(\\) is 4-byte value\"\n-\tRET\n-\n-TEXT \u00b7argstring(SB),0,$16 // ERROR \"wrong argument size 0; expected \\$\\.\\.\\.-16\"\n-\tMOVW\tx+0(FP), AX // ERROR \"invalid MOVW of x\\+0\\(FP\\); string base is 4-byte value\"\n-\tMOVL\tx+0(FP), AX\n-\tMOVQ\tx+0(FP), AX // ERROR \"invalid MOVQ of x\\+0\\(FP\\); string base is 4-byte value\"\n-\tMOVW\tx_base+0(FP), AX // ERROR \"invalid MOVW of x_base\\+0\\(FP\\); string base is 4-byte value\"\n-\tMOVL\tx_base+0(FP), AX\n-\tMOVQ\tx_base+0(FP), AX // ERROR \"invalid MOVQ of x_base\\+0\\(FP\\); string base is 4-byte value\"\n-\tMOVW\tx_len+0(FP), AX // ERROR \"invalid offset x_len\\+0\\(FP\\); expected x_len\\+4\\(FP\\)\"\n-\tMOVL\tx_len+0(FP), AX // ERROR \"invalid offset x_len\\+0\\(FP\\); expected x_len\\+4\\(FP\\)\"\n-\tMOVQ\tx_len+0(FP), AX // ERROR \"invalid offset x_len\\+0\\(FP\\); expected x_len\\+4\\(FP\\)\"\n-\tMOVW\tx_len+4(FP), AX // ERROR \"invalid MOVW of x_len\\+4\\(FP\\); string len is 4-byte value\"\n-\tMOVL\tx_len+4(FP), AX\n-\tMOVQ\tx_len+4(FP), AX // ERROR \"invalid MOVQ of x_len\\+4\\(FP\\); string len is 4-byte value\"\n-\tMOVQ\ty+0(FP), AX // ERROR \"invalid offset y\\+0\\(FP\\); expected y\\+8\\(FP\\)\"\n-\tMOVQ\ty_len+4(FP), AX // ERROR \"invalid offset y_len\\+4\\(FP\\); expected y_len\\+12\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7argslice(SB),0,$24 // ERROR \"wrong argument size 0; expected \\$\\.\\.\\.-24\"\n-\tMOVW\tx+0(FP), AX // ERROR \"invalid MOVW of x\\+0\\(FP\\); slice base is 4-byte value\"\n-\tMOVL\tx+0(FP), AX\n-\tMOVQ\tx+0(FP), AX // ERROR \"invalid MOVQ of x\\+0\\(FP\\); slice base is 4-byte value\"\n-\tMOVW\tx_base+0(FP), AX // ERROR \"invalid MOVW of x_base\\+0\\(FP\\); slice base is 4-byte value\"\n-\tMOVL\tx_base+0(FP), AX\n-\tMOVQ\tx_base+0(FP), AX // ERROR \"invalid MOVQ of x_base\\+0\\(FP\\); slice base is 4-byte value\"\n-\tMOVW\tx_len+0(FP), AX // ERROR \"invalid offset x_len\\+0\\(FP\\); expected x_len\\+4\\(FP\\)\"\n-\tMOVL\tx_len+0(FP), AX // ERROR \"invalid offset x_len\\+0\\(FP\\); expected x_len\\+4\\(FP\\)\"\n-\tMOVQ\tx_len+0(FP), AX // ERROR \"invalid offset x_len\\+0\\(FP\\); expected x_len\\+4\\(FP\\)\"\n-\tMOVW\tx_len+4(FP), AX // ERROR \"invalid MOVW of x_len\\+4\\(FP\\); slice len is 4-byte value\"\n-\tMOVL\tx_len+4(FP), AX\n-\tMOVQ\tx_len+4(FP), AX // ERROR \"invalid MOVQ of x_len\\+4\\(FP\\); slice len is 4-byte value\"\n-\tMOVW\tx_cap+0(FP), AX // ERROR \"invalid offset x_cap\\+0\\(FP\\); expected x_cap\\+8\\(FP\\)\"\n-\tMOVL\tx_cap+0(FP), AX // ERROR \"invalid offset x_cap\\+0\\(FP\\); expected x_cap\\+8\\(FP\\)\"\n-\tMOVQ\tx_cap+0(FP), AX // ERROR \"invalid offset x_cap\\+0\\(FP\\); expected x_cap\\+8\\(FP\\)\"\n-\tMOVW\tx_cap+8(FP), AX // ERROR \"invalid MOVW of x_cap\\+8\\(FP\\); slice cap is 4-byte value\"\n-\tMOVL\tx_cap+8(FP), AX\n-\tMOVQ\tx_cap+8(FP), AX // ERROR \"invalid MOVQ of x_cap\\+8\\(FP\\); slice cap is 4-byte value\"\n-\tMOVQ\ty+0(FP), AX // ERROR \"invalid offset y\\+0\\(FP\\); expected y\\+12\\(FP\\)\"\n-\tMOVQ\ty_len+4(FP), AX // ERROR \"invalid offset y_len\\+4\\(FP\\); expected y_len\\+16\\(FP\\)\"\n-\tMOVQ\ty_cap+8(FP), AX // ERROR \"invalid offset y_cap\\+8\\(FP\\); expected y_cap\\+20\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7argiface(SB),0,$0-16\n-\tMOVW\tx+0(FP), AX // ERROR \"invalid MOVW of x\\+0\\(FP\\); interface type is 4-byte value\"\n-\tMOVL\tx+0(FP), AX\n-\tMOVQ\tx+0(FP), AX // ERROR \"invalid MOVQ of x\\+0\\(FP\\); interface type is 4-byte value\"\n-\tMOVW\tx_type+0(FP), AX // ERROR \"invalid MOVW of x_type\\+0\\(FP\\); interface type is 4-byte value\"\n-\tMOVL\tx_type+0(FP), AX\n-\tMOVQ\tx_type+0(FP), AX // ERROR \"invalid MOVQ of x_type\\+0\\(FP\\); interface type is 4-byte value\"\n-\tMOVQ\tx_itable+0(FP), AX // ERROR \"unknown variable x_itable; offset 0 is x_type\\+0\\(FP\\)\"\n-\tMOVQ\tx_itable+1(FP), AX // ERROR \"unknown variable x_itable; offset 1 is x_type\\+0\\(FP\\)\"\n-\tMOVW\tx_data+0(FP), AX // ERROR \"invalid offset x_data\\+0\\(FP\\); expected x_data\\+4\\(FP\\)\"\n-\tMOVL\tx_data+0(FP), AX // ERROR \"invalid offset x_data\\+0\\(FP\\); expected x_data\\+4\\(FP\\)\"\n-\tMOVQ\tx_data+0(FP), AX // ERROR \"invalid offset x_data\\+0\\(FP\\); expected x_data\\+4\\(FP\\)\"\n-\tMOVW\tx_data+4(FP), AX // ERROR \"invalid MOVW of x_data\\+4\\(FP\\); interface data is 4-byte value\"\n-\tMOVL\tx_data+4(FP), AX\n-\tMOVQ\tx_data+4(FP), AX // ERROR \"invalid MOVQ of x_data\\+4\\(FP\\); interface data is 4-byte value\"\n-\tMOVW\ty+8(FP), AX // ERROR \"invalid MOVW of y\\+8\\(FP\\); interface itable is 4-byte value\"\n-\tMOVL\ty+8(FP), AX\n-\tMOVQ\ty+8(FP), AX // ERROR \"invalid MOVQ of y\\+8\\(FP\\); interface itable is 4-byte value\"\n-\tMOVW\ty_itable+8(FP), AX // ERROR \"invalid MOVW of y_itable\\+8\\(FP\\); interface itable is 4-byte value\"\n-\tMOVL\ty_itable+8(FP), AX\n-\tMOVQ\ty_itable+8(FP), AX // ERROR \"invalid MOVQ of y_itable\\+8\\(FP\\); interface itable is 4-byte value\"\n-\tMOVQ\ty_type+8(FP), AX // ERROR \"unknown variable y_type; offset 8 is y_itable\\+8\\(FP\\)\"\n-\tMOVW\ty_data+8(FP), AX // ERROR \"invalid offset y_data\\+8\\(FP\\); expected y_data\\+12\\(FP\\)\"\n-\tMOVL\ty_data+8(FP), AX // ERROR \"invalid offset y_data\\+8\\(FP\\); expected y_data\\+12\\(FP\\)\"\n-\tMOVQ\ty_data+8(FP), AX // ERROR \"invalid offset y_data\\+8\\(FP\\); expected y_data\\+12\\(FP\\)\"\n-\tMOVW\ty_data+12(FP), AX // ERROR \"invalid MOVW of y_data\\+12\\(FP\\); interface data is 4-byte value\"\n-\tMOVL\ty_data+12(FP), AX\n-\tMOVQ\ty_data+12(FP), AX // ERROR \"invalid MOVQ of y_data\\+12\\(FP\\); interface data is 4-byte value\"\n-\tRET\n-\n-TEXT \u00b7returnint(SB),0,$0-4\n-\tMOVB\tAX, ret+0(FP) // ERROR \"invalid MOVB of ret\\+0\\(FP\\); int is 4-byte value\"\n-\tMOVW\tAX, ret+0(FP) // ERROR \"invalid MOVW of ret\\+0\\(FP\\); int is 4-byte value\"\n-\tMOVL\tAX, ret+0(FP)\n-\tMOVQ\tAX, ret+0(FP) // ERROR \"invalid MOVQ of ret\\+0\\(FP\\); int is 4-byte value\"\n-\tMOVQ\tAX, ret+1(FP) // ERROR \"invalid offset ret\\+1\\(FP\\); expected ret\\+0\\(FP\\)\"\n-\tMOVQ\tAX, r+0(FP) // ERROR \"unknown variable r; offset 0 is ret\\+0\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7returnbyte(SB),0,$0-5\n-\tMOVL\tx+0(FP), AX\n-\tMOVB\tAX, ret+4(FP)\n-\tMOVW\tAX, ret+4(FP) // ERROR \"invalid MOVW of ret\\+4\\(FP\\); byte is 1-byte value\"\n-\tMOVL\tAX, ret+4(FP) // ERROR \"invalid MOVL of ret\\+4\\(FP\\); byte is 1-byte value\"\n-\tMOVQ\tAX, ret+4(FP) // ERROR \"invalid MOVQ of ret\\+4\\(FP\\); byte is 1-byte value\"\n-\tMOVB\tAX, ret+3(FP) // ERROR \"invalid offset ret\\+3\\(FP\\); expected ret\\+4\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7returnnamed(SB),0,$0-21\n-\tMOVB\tx+0(FP), AX\n-\tMOVL\tAX, r1+4(FP)\n-\tMOVW\tAX, r2+8(FP)\n-\tMOVL\tAX, r3+12(FP)\n-\tMOVL\tAX, r3_base+12(FP)\n-\tMOVL\tAX, r3_len+16(FP)\n-\tMOVB\tAX, r4+20(FP)\n-\tMOVQ\tAX, r1+4(FP) // ERROR \"invalid MOVQ of r1\\+4\\(FP\\); int is 4-byte value\"\n-\tRET\n-\n-TEXT \u00b7returnintmissing(SB),0,$0-4\n-\tRET // ERROR \"RET without writing to 4-byte ret\\+0\\(FP\\)\""}, {"sha": "83e53862d7d1b6e649cb8fe048c78b27358d1997", "filename": "libgo/go/cmd/vet/testdata/asm/asm3.s", "status": "removed", "additions": 0, "deletions": 192, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm%2Fasm3.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm%2Fasm3.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm%2Fasm3.s?ref=225220d668dafb8262db7012bced688acbe63b33", "patch": "@@ -1,192 +0,0 @@\n-// Copyright 2013 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build arm\n-// +build vet_test\n-\n-TEXT \u00b7arg1(SB),0,$0-2\n-\tMOVB\tx+0(FP), AX\n-\tMOVB\ty+1(FP), BX\n-\tMOVH\tx+0(FP), AX // ERROR \"\\[arm\\] arg1: invalid MOVH of x\\+0\\(FP\\); int8 is 1-byte value\"\n-\tMOVH\ty+1(FP), AX // ERROR \"invalid MOVH of y\\+1\\(FP\\); uint8 is 1-byte value\"\n-\tMOVW\tx+0(FP), AX // ERROR \"invalid MOVW of x\\+0\\(FP\\); int8 is 1-byte value\"\n-\tMOVW\ty+1(FP), AX // ERROR \"invalid MOVW of y\\+1\\(FP\\); uint8 is 1-byte value\"\n-\tMOVB\tx+1(FP), AX // ERROR \"invalid offset x\\+1\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tMOVB\ty+2(FP), AX // ERROR \"invalid offset y\\+2\\(FP\\); expected y\\+1\\(FP\\)\"\n-\tMOVB\t8(R13), AX // ERROR \"8\\(R13\\) should be x\\+0\\(FP\\)\"\n-\tMOVB\t9(R13), AX // ERROR \"9\\(R13\\) should be y\\+1\\(FP\\)\"\n-\tMOVB\t10(R13), AX // ERROR \"use of 10\\(R13\\) points beyond argument frame\"\n-\tRET\n-\n-TEXT \u00b7arg2(SB),0,$0-4\n-\tMOVB\tx+0(FP), AX // ERROR \"arg2: invalid MOVB of x\\+0\\(FP\\); int16 is 2-byte value\"\n-\tMOVB\ty+2(FP), AX // ERROR \"invalid MOVB of y\\+2\\(FP\\); uint16 is 2-byte value\"\n-\tMOVH\tx+0(FP), AX\n-\tMOVH\ty+2(FP), BX\n-\tMOVW\tx+0(FP), AX // ERROR \"invalid MOVW of x\\+0\\(FP\\); int16 is 2-byte value\"\n-\tMOVW\ty+2(FP), AX // ERROR \"invalid MOVW of y\\+2\\(FP\\); uint16 is 2-byte value\"\n-\tMOVH\tx+2(FP), AX // ERROR \"invalid offset x\\+2\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tMOVH\ty+0(FP), AX // ERROR \"invalid offset y\\+0\\(FP\\); expected y\\+2\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7arg4(SB),0,$0-2 // ERROR \"arg4: wrong argument size 2; expected \\$\\.\\.\\.-8\"\n-\tMOVB\tx+0(FP), AX // ERROR \"invalid MOVB of x\\+0\\(FP\\); int32 is 4-byte value\"\n-\tMOVB\ty+4(FP), BX // ERROR \"invalid MOVB of y\\+4\\(FP\\); uint32 is 4-byte value\"\n-\tMOVH\tx+0(FP), AX // ERROR \"invalid MOVH of x\\+0\\(FP\\); int32 is 4-byte value\"\n-\tMOVH\ty+4(FP), AX // ERROR \"invalid MOVH of y\\+4\\(FP\\); uint32 is 4-byte value\"\n-\tMOVW\tx+0(FP), AX\n-\tMOVW\ty+4(FP), AX\n-\tMOVW\tx+4(FP), AX // ERROR \"invalid offset x\\+4\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tMOVW\ty+2(FP), AX // ERROR \"invalid offset y\\+2\\(FP\\); expected y\\+4\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7arg8(SB),7,$0-2 // ERROR \"wrong argument size 2; expected \\$\\.\\.\\.-16\"\n-\tMOVB\tx+0(FP), AX // ERROR \"invalid MOVB of x\\+0\\(FP\\); int64 is 8-byte value\"\n-\tMOVB\ty+8(FP), BX // ERROR \"invalid MOVB of y\\+8\\(FP\\); uint64 is 8-byte value\"\n-\tMOVH\tx+0(FP), AX // ERROR \"invalid MOVH of x\\+0\\(FP\\); int64 is 8-byte value\"\n-\tMOVH\ty+8(FP), AX // ERROR \"invalid MOVH of y\\+8\\(FP\\); uint64 is 8-byte value\"\n-\tMOVW\tx+0(FP), AX // ERROR \"invalid MOVW of x\\+0\\(FP\\); int64 is 8-byte value containing x_lo\\+0\\(FP\\) and x_hi\\+4\\(FP\\)\"\n-\tMOVW\tx_lo+0(FP), AX\n-\tMOVW\tx_hi+4(FP), AX\n-\tMOVW\ty+8(FP), AX // ERROR \"invalid MOVW of y\\+8\\(FP\\); uint64 is 8-byte value containing y_lo\\+8\\(FP\\) and y_hi\\+12\\(FP\\)\"\n-\tMOVW\ty_lo+8(FP), AX\n-\tMOVW\ty_hi+12(FP), AX\n-\tMOVQ\tx+0(FP), AX\n-\tMOVQ\ty+8(FP), AX\n-\tMOVQ\tx+8(FP), AX // ERROR \"invalid offset x\\+8\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tMOVQ\ty+2(FP), AX // ERROR \"invalid offset y\\+2\\(FP\\); expected y\\+8\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7argint(SB),0,$0-2 // ERROR \"wrong argument size 2; expected \\$\\.\\.\\.-8\"\n-\tMOVB\tx+0(FP), AX // ERROR \"invalid MOVB of x\\+0\\(FP\\); int is 4-byte value\"\n-\tMOVB\ty+4(FP), BX // ERROR \"invalid MOVB of y\\+4\\(FP\\); uint is 4-byte value\"\n-\tMOVH\tx+0(FP), AX // ERROR \"invalid MOVH of x\\+0\\(FP\\); int is 4-byte value\"\n-\tMOVH\ty+4(FP), AX // ERROR \"invalid MOVH of y\\+4\\(FP\\); uint is 4-byte value\"\n-\tMOVW\tx+0(FP), AX\n-\tMOVW\ty+4(FP), AX\n-\tMOVQ\tx+4(FP), AX // ERROR \"invalid offset x\\+4\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tMOVQ\ty+2(FP), AX // ERROR \"invalid offset y\\+2\\(FP\\); expected y\\+4\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7argptr(SB),7,$0-2 // ERROR \"wrong argument size 2; expected \\$\\.\\.\\.-20\"\n-\tMOVB\tx+0(FP), AX // ERROR \"invalid MOVB of x\\+0\\(FP\\); \\*byte is 4-byte value\"\n-\tMOVB\ty+4(FP), BX // ERROR \"invalid MOVB of y\\+4\\(FP\\); \\*byte is 4-byte value\"\n-\tMOVH\tx+0(FP), AX // ERROR \"invalid MOVH of x\\+0\\(FP\\); \\*byte is 4-byte value\"\n-\tMOVH\ty+4(FP), AX // ERROR \"invalid MOVH of y\\+4\\(FP\\); \\*byte is 4-byte value\"\n-\tMOVW\tx+0(FP), AX\n-\tMOVW\ty+4(FP), AX\n-\tMOVQ\tx+4(FP), AX // ERROR \"invalid offset x\\+4\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tMOVQ\ty+2(FP), AX // ERROR \"invalid offset y\\+2\\(FP\\); expected y\\+4\\(FP\\)\"\n-\tMOVH\tc+8(FP), AX // ERROR \"invalid MOVH of c\\+8\\(FP\\); chan int is 4-byte value\"\n-\tMOVH\tm+12(FP), AX // ERROR \"invalid MOVH of m\\+12\\(FP\\); map\\[int\\]int is 4-byte value\"\n-\tMOVH\tf+16(FP), AX // ERROR \"invalid MOVH of f\\+16\\(FP\\); func\\(\\) is 4-byte value\"\n-\tRET\n-\n-TEXT \u00b7argstring(SB),0,$16 // ERROR \"wrong argument size 0; expected \\$\\.\\.\\.-16\"\n-\tMOVH\tx+0(FP), AX // ERROR \"invalid MOVH of x\\+0\\(FP\\); string base is 4-byte value\"\n-\tMOVW\tx+0(FP), AX\n-\tMOVH\tx_base+0(FP), AX // ERROR \"invalid MOVH of x_base\\+0\\(FP\\); string base is 4-byte value\"\n-\tMOVW\tx_base+0(FP), AX\n-\tMOVH\tx_len+0(FP), AX // ERROR \"invalid offset x_len\\+0\\(FP\\); expected x_len\\+4\\(FP\\)\"\n-\tMOVW\tx_len+0(FP), AX // ERROR \"invalid offset x_len\\+0\\(FP\\); expected x_len\\+4\\(FP\\)\"\n-\tMOVQ\tx_len+0(FP), AX // ERROR \"invalid offset x_len\\+0\\(FP\\); expected x_len\\+4\\(FP\\)\"\n-\tMOVH\tx_len+4(FP), AX // ERROR \"invalid MOVH of x_len\\+4\\(FP\\); string len is 4-byte value\"\n-\tMOVW\tx_len+4(FP), AX\n-\tMOVQ\ty+0(FP), AX // ERROR \"invalid offset y\\+0\\(FP\\); expected y\\+8\\(FP\\)\"\n-\tMOVQ\ty_len+4(FP), AX // ERROR \"invalid offset y_len\\+4\\(FP\\); expected y_len\\+12\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7argslice(SB),0,$24 // ERROR \"wrong argument size 0; expected \\$\\.\\.\\.-24\"\n-\tMOVH\tx+0(FP), AX // ERROR \"invalid MOVH of x\\+0\\(FP\\); slice base is 4-byte value\"\n-\tMOVW\tx+0(FP), AX\n-\tMOVH\tx_base+0(FP), AX // ERROR \"invalid MOVH of x_base\\+0\\(FP\\); slice base is 4-byte value\"\n-\tMOVW\tx_base+0(FP), AX\n-\tMOVH\tx_len+0(FP), AX // ERROR \"invalid offset x_len\\+0\\(FP\\); expected x_len\\+4\\(FP\\)\"\n-\tMOVW\tx_len+0(FP), AX // ERROR \"invalid offset x_len\\+0\\(FP\\); expected x_len\\+4\\(FP\\)\"\n-\tMOVQ\tx_len+0(FP), AX // ERROR \"invalid offset x_len\\+0\\(FP\\); expected x_len\\+4\\(FP\\)\"\n-\tMOVH\tx_len+4(FP), AX // ERROR \"invalid MOVH of x_len\\+4\\(FP\\); slice len is 4-byte value\"\n-\tMOVW\tx_len+4(FP), AX\n-\tMOVH\tx_cap+0(FP), AX // ERROR \"invalid offset x_cap\\+0\\(FP\\); expected x_cap\\+8\\(FP\\)\"\n-\tMOVW\tx_cap+0(FP), AX // ERROR \"invalid offset x_cap\\+0\\(FP\\); expected x_cap\\+8\\(FP\\)\"\n-\tMOVQ\tx_cap+0(FP), AX // ERROR \"invalid offset x_cap\\+0\\(FP\\); expected x_cap\\+8\\(FP\\)\"\n-\tMOVH\tx_cap+8(FP), AX // ERROR \"invalid MOVH of x_cap\\+8\\(FP\\); slice cap is 4-byte value\"\n-\tMOVW\tx_cap+8(FP), AX\n-\tMOVQ\ty+0(FP), AX // ERROR \"invalid offset y\\+0\\(FP\\); expected y\\+12\\(FP\\)\"\n-\tMOVQ\ty_len+4(FP), AX // ERROR \"invalid offset y_len\\+4\\(FP\\); expected y_len\\+16\\(FP\\)\"\n-\tMOVQ\ty_cap+8(FP), AX // ERROR \"invalid offset y_cap\\+8\\(FP\\); expected y_cap\\+20\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7argiface(SB),0,$0-16\n-\tMOVH\tx+0(FP), AX // ERROR \"invalid MOVH of x\\+0\\(FP\\); interface type is 4-byte value\"\n-\tMOVW\tx+0(FP), AX\n-\tMOVH\tx_type+0(FP), AX // ERROR \"invalid MOVH of x_type\\+0\\(FP\\); interface type is 4-byte value\"\n-\tMOVW\tx_type+0(FP), AX\n-\tMOVQ\tx_itable+0(FP), AX // ERROR \"unknown variable x_itable; offset 0 is x_type\\+0\\(FP\\)\"\n-\tMOVQ\tx_itable+1(FP), AX // ERROR \"unknown variable x_itable; offset 1 is x_type\\+0\\(FP\\)\"\n-\tMOVH\tx_data+0(FP), AX // ERROR \"invalid offset x_data\\+0\\(FP\\); expected x_data\\+4\\(FP\\)\"\n-\tMOVW\tx_data+0(FP), AX // ERROR \"invalid offset x_data\\+0\\(FP\\); expected x_data\\+4\\(FP\\)\"\n-\tMOVQ\tx_data+0(FP), AX // ERROR \"invalid offset x_data\\+0\\(FP\\); expected x_data\\+4\\(FP\\)\"\n-\tMOVH\tx_data+4(FP), AX // ERROR \"invalid MOVH of x_data\\+4\\(FP\\); interface data is 4-byte value\"\n-\tMOVW\tx_data+4(FP), AX\n-\tMOVH\ty+8(FP), AX // ERROR \"invalid MOVH of y\\+8\\(FP\\); interface itable is 4-byte value\"\n-\tMOVW\ty+8(FP), AX\n-\tMOVH\ty_itable+8(FP), AX // ERROR \"invalid MOVH of y_itable\\+8\\(FP\\); interface itable is 4-byte value\"\n-\tMOVW\ty_itable+8(FP), AX\n-\tMOVQ\ty_type+8(FP), AX // ERROR \"unknown variable y_type; offset 8 is y_itable\\+8\\(FP\\)\"\n-\tMOVH\ty_data+8(FP), AX // ERROR \"invalid offset y_data\\+8\\(FP\\); expected y_data\\+12\\(FP\\)\"\n-\tMOVW\ty_data+8(FP), AX // ERROR \"invalid offset y_data\\+8\\(FP\\); expected y_data\\+12\\(FP\\)\"\n-\tMOVQ\ty_data+8(FP), AX // ERROR \"invalid offset y_data\\+8\\(FP\\); expected y_data\\+12\\(FP\\)\"\n-\tMOVH\ty_data+12(FP), AX // ERROR \"invalid MOVH of y_data\\+12\\(FP\\); interface data is 4-byte value\"\n-\tMOVW\ty_data+12(FP), AX\n-\tRET\n-\n-TEXT \u00b7returnint(SB),0,$0-4\n-\tMOVB\tAX, ret+0(FP) // ERROR \"invalid MOVB of ret\\+0\\(FP\\); int is 4-byte value\"\n-\tMOVH\tAX, ret+0(FP) // ERROR \"invalid MOVH of ret\\+0\\(FP\\); int is 4-byte value\"\n-\tMOVW\tAX, ret+0(FP)\n-\tMOVQ\tAX, ret+1(FP) // ERROR \"invalid offset ret\\+1\\(FP\\); expected ret\\+0\\(FP\\)\"\n-\tMOVQ\tAX, r+0(FP) // ERROR \"unknown variable r; offset 0 is ret\\+0\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7returnbyte(SB),0,$0-5\n-\tMOVW\tx+0(FP), AX\n-\tMOVB\tAX, ret+4(FP)\n-\tMOVH\tAX, ret+4(FP) // ERROR \"invalid MOVH of ret\\+4\\(FP\\); byte is 1-byte value\"\n-\tMOVW\tAX, ret+4(FP) // ERROR \"invalid MOVW of ret\\+4\\(FP\\); byte is 1-byte value\"\n-\tMOVB\tAX, ret+3(FP) // ERROR \"invalid offset ret\\+3\\(FP\\); expected ret\\+4\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7returnnamed(SB),0,$0-21\n-\tMOVB\tx+0(FP), AX\n-\tMOVW\tAX, r1+4(FP)\n-\tMOVH\tAX, r2+8(FP)\n-\tMOVW\tAX, r3+12(FP)\n-\tMOVW\tAX, r3_base+12(FP)\n-\tMOVW\tAX, r3_len+16(FP)\n-\tMOVB\tAX, r4+20(FP)\n-\tMOVB\tAX, r1+4(FP) // ERROR \"invalid MOVB of r1\\+4\\(FP\\); int is 4-byte value\"\n-\tRET\n-\n-TEXT \u00b7returnintmissing(SB),0,$0-4\n-\tRET // ERROR \"RET without writing to 4-byte ret\\+0\\(FP\\)\"\n-\n-TEXT \u00b7leaf(SB),0,$-4-12\n-\tMOVW\tx+0(FP), AX\n-\tMOVW\ty+4(FP), AX\n-\tMOVW\tAX, ret+8(FP)\n-\tRET\n-\n-TEXT \u00b7noframe1(SB),0,$0-4\n-\tMOVW\t0(R13), AX // Okay; our saved LR\n-\tMOVW\t4(R13), AX // Okay; caller's saved LR\n-\tMOVW\tx+8(R13), AX // Okay; x argument\n-\tMOVW\t12(R13), AX // ERROR \"use of 12\\(R13\\) points beyond argument frame\"\n-\tRET\n-\n-TEXT \u00b7noframe2(SB),NOFRAME,$0-4\n-\tMOVW\t0(R13), AX // Okay; caller's saved LR\n-\tMOVW\tx+4(R13), AX // Okay; x argument\n-\tMOVW\t8(R13), AX // ERROR \"use of 8\\(R13\\) points beyond argument frame\"\n-\tMOVW\t12(R13), AX // ERROR \"use of 12\\(R13\\) points beyond argument frame\"\n-\tRET"}, {"sha": "044b050b6b99e1426f1cc653bb4c25428dd1b52d", "filename": "libgo/go/cmd/vet/testdata/asm/asm4.s", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm%2Fasm4.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm%2Fasm4.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm%2Fasm4.s?ref=225220d668dafb8262db7012bced688acbe63b33", "patch": "@@ -1,26 +0,0 @@\n-// Copyright 2013 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build amd64\n-// +build vet_test\n-\n-// Test cases for symbolic NOSPLIT etc. on TEXT symbols.\n-\n-TEXT \u00b7noprof(SB),NOPROF,$0-8\n-\tRET\n-\n-TEXT \u00b7dupok(SB),DUPOK,$0-8\n-\tRET\n-\n-TEXT \u00b7nosplit(SB),NOSPLIT,$0\n-\tRET\n-\n-TEXT \u00b7rodata(SB),RODATA,$0-8\n-\tRET\n-\n-TEXT \u00b7noptr(SB),NOPTR|NOSPLIT,$0\n-\tRET\n-\n-TEXT \u00b7wrapper(SB),WRAPPER,$0-8\n-\tRET"}, {"sha": "c6176e9669f57268c2fa3e9499c27605a7a57f22", "filename": "libgo/go/cmd/vet/testdata/asm/asm5.s", "status": "removed", "additions": 0, "deletions": 193, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm%2Fasm5.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm%2Fasm5.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm%2Fasm5.s?ref=225220d668dafb8262db7012bced688acbe63b33", "patch": "@@ -1,193 +0,0 @@\n-// Copyright 2016 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build mips64\n-// +build vet_test\n-\n-TEXT \u00b7arg1(SB),0,$0-2\n-\tMOVB\tx+0(FP), R1\n-\tMOVBU\ty+1(FP), R2\n-\tMOVH\tx+0(FP), R1 // ERROR \"\\[mips64\\] arg1: invalid MOVH of x\\+0\\(FP\\); int8 is 1-byte value\"\n-\tMOVHU\ty+1(FP), R1 // ERROR \"invalid MOVHU of y\\+1\\(FP\\); uint8 is 1-byte value\"\n-\tMOVW\tx+0(FP), R1 // ERROR \"invalid MOVW of x\\+0\\(FP\\); int8 is 1-byte value\"\n-\tMOVWU\ty+1(FP), R1 // ERROR \"invalid MOVWU of y\\+1\\(FP\\); uint8 is 1-byte value\"\n-\tMOVV\tx+0(FP), R1 // ERROR \"invalid MOVV of x\\+0\\(FP\\); int8 is 1-byte value\"\n-\tMOVV\ty+1(FP), R1 // ERROR \"invalid MOVV of y\\+1\\(FP\\); uint8 is 1-byte value\"\n-\tMOVB\tx+1(FP), R1 // ERROR \"invalid offset x\\+1\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tMOVBU\ty+2(FP), R1 // ERROR \"invalid offset y\\+2\\(FP\\); expected y\\+1\\(FP\\)\"\n-\tMOVB\t16(R29), R1 // ERROR \"16\\(R29\\) should be x\\+0\\(FP\\)\"\n-\tMOVB\t17(R29), R1 // ERROR \"17\\(R29\\) should be y\\+1\\(FP\\)\"\n-\tMOVB\t18(R29), R1 // ERROR \"use of 18\\(R29\\) points beyond argument frame\"\n-\tRET\n-\n-TEXT \u00b7arg2(SB),0,$0-4\n-\tMOVBU\tx+0(FP), R1 // ERROR \"arg2: invalid MOVBU of x\\+0\\(FP\\); int16 is 2-byte value\"\n-\tMOVB\ty+2(FP), R1 // ERROR \"invalid MOVB of y\\+2\\(FP\\); uint16 is 2-byte value\"\n-\tMOVHU\tx+0(FP), R1\n-\tMOVH\ty+2(FP), R2\n-\tMOVWU\tx+0(FP), R1 // ERROR \"invalid MOVWU of x\\+0\\(FP\\); int16 is 2-byte value\"\n-\tMOVW\ty+2(FP), R1 // ERROR \"invalid MOVW of y\\+2\\(FP\\); uint16 is 2-byte value\"\n-\tMOVV\tx+0(FP), R1 // ERROR \"invalid MOVV of x\\+0\\(FP\\); int16 is 2-byte value\"\n-\tMOVV\ty+2(FP), R1 // ERROR \"invalid MOVV of y\\+2\\(FP\\); uint16 is 2-byte value\"\n-\tMOVHU\tx+2(FP), R1 // ERROR \"invalid offset x\\+2\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tMOVH\ty+0(FP), R1 // ERROR \"invalid offset y\\+0\\(FP\\); expected y\\+2\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7arg4(SB),0,$0-2 // ERROR \"arg4: wrong argument size 2; expected \\$\\.\\.\\.-8\"\n-\tMOVB\tx+0(FP), R1 // ERROR \"invalid MOVB of x\\+0\\(FP\\); int32 is 4-byte value\"\n-\tMOVB\ty+4(FP), R2 // ERROR \"invalid MOVB of y\\+4\\(FP\\); uint32 is 4-byte value\"\n-\tMOVH\tx+0(FP), R1 // ERROR \"invalid MOVH of x\\+0\\(FP\\); int32 is 4-byte value\"\n-\tMOVH\ty+4(FP), R1 // ERROR \"invalid MOVH of y\\+4\\(FP\\); uint32 is 4-byte value\"\n-\tMOVW\tx+0(FP), R1\n-\tMOVW\ty+4(FP), R1\n-\tMOVV\tx+0(FP), R1 // ERROR \"invalid MOVV of x\\+0\\(FP\\); int32 is 4-byte value\"\n-\tMOVV\ty+4(FP), R1 // ERROR \"invalid MOVV of y\\+4\\(FP\\); uint32 is 4-byte value\"\n-\tMOVW\tx+4(FP), R1 // ERROR \"invalid offset x\\+4\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tMOVW\ty+2(FP), R1 // ERROR \"invalid offset y\\+2\\(FP\\); expected y\\+4\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7arg8(SB),7,$0-2 // ERROR \"wrong argument size 2; expected \\$\\.\\.\\.-16\"\n-\tMOVB\tx+0(FP), R1 // ERROR \"invalid MOVB of x\\+0\\(FP\\); int64 is 8-byte value\"\n-\tMOVB\ty+8(FP), R2 // ERROR \"invalid MOVB of y\\+8\\(FP\\); uint64 is 8-byte value\"\n-\tMOVH\tx+0(FP), R1 // ERROR \"invalid MOVH of x\\+0\\(FP\\); int64 is 8-byte value\"\n-\tMOVH\ty+8(FP), R1 // ERROR \"invalid MOVH of y\\+8\\(FP\\); uint64 is 8-byte value\"\n-\tMOVW\tx+0(FP), R1 // ERROR \"invalid MOVW of x\\+0\\(FP\\); int64 is 8-byte value\"\n-\tMOVW\ty+8(FP), R1 // ERROR \"invalid MOVW of y\\+8\\(FP\\); uint64 is 8-byte value\"\n-\tMOVV\tx+0(FP), R1\n-\tMOVV\ty+8(FP), R1\n-\tMOVV\tx+8(FP), R1 // ERROR \"invalid offset x\\+8\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tMOVV\ty+2(FP), R1 // ERROR \"invalid offset y\\+2\\(FP\\); expected y\\+8\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7argint(SB),0,$0-2 // ERROR \"wrong argument size 2; expected \\$\\.\\.\\.-16\"\n-\tMOVB\tx+0(FP), R1 // ERROR \"invalid MOVB of x\\+0\\(FP\\); int is 8-byte value\"\n-\tMOVB\ty+8(FP), R2 // ERROR \"invalid MOVB of y\\+8\\(FP\\); uint is 8-byte value\"\n-\tMOVH\tx+0(FP), R1 // ERROR \"invalid MOVH of x\\+0\\(FP\\); int is 8-byte value\"\n-\tMOVH\ty+8(FP), R1 // ERROR \"invalid MOVH of y\\+8\\(FP\\); uint is 8-byte value\"\n-\tMOVW\tx+0(FP), R1 // ERROR \"invalid MOVW of x\\+0\\(FP\\); int is 8-byte value\"\n-\tMOVW\ty+8(FP), R1 // ERROR \"invalid MOVW of y\\+8\\(FP\\); uint is 8-byte value\"\n-\tMOVV\tx+0(FP), R1\n-\tMOVV\ty+8(FP), R1\n-\tMOVV\tx+8(FP), R1 // ERROR \"invalid offset x\\+8\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tMOVV\ty+2(FP), R1 // ERROR \"invalid offset y\\+2\\(FP\\); expected y\\+8\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7argptr(SB),7,$0-2 // ERROR \"wrong argument size 2; expected \\$\\.\\.\\.-40\"\n-\tMOVB\tx+0(FP), R1 // ERROR \"invalid MOVB of x\\+0\\(FP\\); \\*byte is 8-byte value\"\n-\tMOVB\ty+8(FP), R2 // ERROR \"invalid MOVB of y\\+8\\(FP\\); \\*byte is 8-byte value\"\n-\tMOVH\tx+0(FP), R1 // ERROR \"invalid MOVH of x\\+0\\(FP\\); \\*byte is 8-byte value\"\n-\tMOVH\ty+8(FP), R1 // ERROR \"invalid MOVH of y\\+8\\(FP\\); \\*byte is 8-byte value\"\n-\tMOVW\tx+0(FP), R1 // ERROR \"invalid MOVW of x\\+0\\(FP\\); \\*byte is 8-byte value\"\n-\tMOVW\ty+8(FP), R1 // ERROR \"invalid MOVW of y\\+8\\(FP\\); \\*byte is 8-byte value\"\n-\tMOVV\tx+0(FP), R1\n-\tMOVV\ty+8(FP), R1\n-\tMOVV\tx+8(FP), R1 // ERROR \"invalid offset x\\+8\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tMOVV\ty+2(FP), R1 // ERROR \"invalid offset y\\+2\\(FP\\); expected y\\+8\\(FP\\)\"\n-\tMOVW\tc+16(FP), R1 // ERROR \"invalid MOVW of c\\+16\\(FP\\); chan int is 8-byte value\"\n-\tMOVW\tm+24(FP), R1 // ERROR \"invalid MOVW of m\\+24\\(FP\\); map\\[int\\]int is 8-byte value\"\n-\tMOVW\tf+32(FP), R1 // ERROR \"invalid MOVW of f\\+32\\(FP\\); func\\(\\) is 8-byte value\"\n-\tRET\n-\n-TEXT \u00b7argstring(SB),0,$32 // ERROR \"wrong argument size 0; expected \\$\\.\\.\\.-32\"\n-\tMOVH\tx+0(FP), R1 // ERROR \"invalid MOVH of x\\+0\\(FP\\); string base is 8-byte value\"\n-\tMOVW\tx+0(FP), R1 // ERROR \"invalid MOVW of x\\+0\\(FP\\); string base is 8-byte value\"\n-\tMOVV\tx+0(FP), R1\n-\tMOVH\tx_base+0(FP), R1 // ERROR \"invalid MOVH of x_base\\+0\\(FP\\); string base is 8-byte value\"\n-\tMOVW\tx_base+0(FP), R1 // ERROR \"invalid MOVW of x_base\\+0\\(FP\\); string base is 8-byte value\"\n-\tMOVV\tx_base+0(FP), R1\n-\tMOVH\tx_len+0(FP), R1 // ERROR \"invalid offset x_len\\+0\\(FP\\); expected x_len\\+8\\(FP\\)\"\n-\tMOVW\tx_len+0(FP), R1 // ERROR \"invalid offset x_len\\+0\\(FP\\); expected x_len\\+8\\(FP\\)\"\n-\tMOVV\tx_len+0(FP), R1 // ERROR \"invalid offset x_len\\+0\\(FP\\); expected x_len\\+8\\(FP\\)\"\n-\tMOVH\tx_len+8(FP), R1 // ERROR \"invalid MOVH of x_len\\+8\\(FP\\); string len is 8-byte value\"\n-\tMOVW\tx_len+8(FP), R1 // ERROR \"invalid MOVW of x_len\\+8\\(FP\\); string len is 8-byte value\"\n-\tMOVV\tx_len+8(FP), R1\n-\tMOVV\ty+0(FP), R1 // ERROR \"invalid offset y\\+0\\(FP\\); expected y\\+16\\(FP\\)\"\n-\tMOVV\ty_len+8(FP), R1 // ERROR \"invalid offset y_len\\+8\\(FP\\); expected y_len\\+24\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7argslice(SB),0,$48 // ERROR \"wrong argument size 0; expected \\$\\.\\.\\.-48\"\n-\tMOVH\tx+0(FP), R1 // ERROR \"invalid MOVH of x\\+0\\(FP\\); slice base is 8-byte value\"\n-\tMOVW\tx+0(FP), R1 // ERROR \"invalid MOVW of x\\+0\\(FP\\); slice base is 8-byte value\"\n-\tMOVV\tx+0(FP), R1\n-\tMOVH\tx_base+0(FP), R1 // ERROR \"invalid MOVH of x_base\\+0\\(FP\\); slice base is 8-byte value\"\n-\tMOVW\tx_base+0(FP), R1 // ERROR \"invalid MOVW of x_base\\+0\\(FP\\); slice base is 8-byte value\"\n-\tMOVV\tx_base+0(FP), R1\n-\tMOVH\tx_len+0(FP), R1 // ERROR \"invalid offset x_len\\+0\\(FP\\); expected x_len\\+8\\(FP\\)\"\n-\tMOVW\tx_len+0(FP), R1 // ERROR \"invalid offset x_len\\+0\\(FP\\); expected x_len\\+8\\(FP\\)\"\n-\tMOVV\tx_len+0(FP), R1 // ERROR \"invalid offset x_len\\+0\\(FP\\); expected x_len\\+8\\(FP\\)\"\n-\tMOVH\tx_len+8(FP), R1 // ERROR \"invalid MOVH of x_len\\+8\\(FP\\); slice len is 8-byte value\"\n-\tMOVW\tx_len+8(FP), R1 // ERROR \"invalid MOVW of x_len\\+8\\(FP\\); slice len is 8-byte value\"\n-\tMOVV\tx_len+8(FP), R1\n-\tMOVH\tx_cap+0(FP), R1 // ERROR \"invalid offset x_cap\\+0\\(FP\\); expected x_cap\\+16\\(FP\\)\"\n-\tMOVW\tx_cap+0(FP), R1 // ERROR \"invalid offset x_cap\\+0\\(FP\\); expected x_cap\\+16\\(FP\\)\"\n-\tMOVV\tx_cap+0(FP), R1 // ERROR \"invalid offset x_cap\\+0\\(FP\\); expected x_cap\\+16\\(FP\\)\"\n-\tMOVH\tx_cap+16(FP), R1 // ERROR \"invalid MOVH of x_cap\\+16\\(FP\\); slice cap is 8-byte value\"\n-\tMOVW\tx_cap+16(FP), R1 // ERROR \"invalid MOVW of x_cap\\+16\\(FP\\); slice cap is 8-byte value\"\n-\tMOVV\tx_cap+16(FP), R1\n-\tMOVV\ty+0(FP), R1 // ERROR \"invalid offset y\\+0\\(FP\\); expected y\\+24\\(FP\\)\"\n-\tMOVV\ty_len+8(FP), R1 // ERROR \"invalid offset y_len\\+8\\(FP\\); expected y_len\\+32\\(FP\\)\"\n-\tMOVV\ty_cap+16(FP), R1 // ERROR \"invalid offset y_cap\\+16\\(FP\\); expected y_cap\\+40\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7argiface(SB),0,$0-32\n-\tMOVH\tx+0(FP), R1 // ERROR \"invalid MOVH of x\\+0\\(FP\\); interface type is 8-byte value\"\n-\tMOVW\tx+0(FP), R1 // ERROR \"invalid MOVW of x\\+0\\(FP\\); interface type is 8-byte value\"\n-\tMOVV\tx+0(FP), R1\n-\tMOVH\tx_type+0(FP), R1 // ERROR \"invalid MOVH of x_type\\+0\\(FP\\); interface type is 8-byte value\"\n-\tMOVW\tx_type+0(FP), R1 // ERROR \"invalid MOVW of x_type\\+0\\(FP\\); interface type is 8-byte value\"\n-\tMOVV\tx_type+0(FP), R1\n-\tMOVV\tx_itable+0(FP), R1 // ERROR \"unknown variable x_itable; offset 0 is x_type\\+0\\(FP\\)\"\n-\tMOVV\tx_itable+1(FP), R1 // ERROR \"unknown variable x_itable; offset 1 is x_type\\+0\\(FP\\)\"\n-\tMOVH\tx_data+0(FP), R1 // ERROR \"invalid offset x_data\\+0\\(FP\\); expected x_data\\+8\\(FP\\)\"\n-\tMOVW\tx_data+0(FP), R1 // ERROR \"invalid offset x_data\\+0\\(FP\\); expected x_data\\+8\\(FP\\)\"\n-\tMOVV\tx_data+0(FP), R1 // ERROR \"invalid offset x_data\\+0\\(FP\\); expected x_data\\+8\\(FP\\)\"\n-\tMOVH\tx_data+8(FP), R1 // ERROR \"invalid MOVH of x_data\\+8\\(FP\\); interface data is 8-byte value\"\n-\tMOVW\tx_data+8(FP), R1 // ERROR \"invalid MOVW of x_data\\+8\\(FP\\); interface data is 8-byte value\"\n-\tMOVV\tx_data+8(FP), R1\n-\tMOVH\ty+16(FP), R1 // ERROR \"invalid MOVH of y\\+16\\(FP\\); interface itable is 8-byte value\"\n-\tMOVW\ty+16(FP), R1 // ERROR \"invalid MOVW of y\\+16\\(FP\\); interface itable is 8-byte value\"\n-\tMOVV\ty+16(FP), R1\n-\tMOVH\ty_itable+16(FP), R1 // ERROR \"invalid MOVH of y_itable\\+16\\(FP\\); interface itable is 8-byte value\"\n-\tMOVW\ty_itable+16(FP), R1 // ERROR \"invalid MOVW of y_itable\\+16\\(FP\\); interface itable is 8-byte value\"\n-\tMOVV\ty_itable+16(FP), R1\n-\tMOVV\ty_type+16(FP), R1 // ERROR \"unknown variable y_type; offset 16 is y_itable\\+16\\(FP\\)\"\n-\tMOVH\ty_data+16(FP), R1 // ERROR \"invalid offset y_data\\+16\\(FP\\); expected y_data\\+24\\(FP\\)\"\n-\tMOVW\ty_data+16(FP), R1 // ERROR \"invalid offset y_data\\+16\\(FP\\); expected y_data\\+24\\(FP\\)\"\n-\tMOVV\ty_data+16(FP), R1 // ERROR \"invalid offset y_data\\+16\\(FP\\); expected y_data\\+24\\(FP\\)\"\n-\tMOVH\ty_data+24(FP), R1 // ERROR \"invalid MOVH of y_data\\+24\\(FP\\); interface data is 8-byte value\"\n-\tMOVW\ty_data+24(FP), R1 // ERROR \"invalid MOVW of y_data\\+24\\(FP\\); interface data is 8-byte value\"\n-\tMOVV\ty_data+24(FP), R1\n-\tRET\n-\n-TEXT \u00b7returnint(SB),0,$0-8\n-\tMOVB\tR1, ret+0(FP) // ERROR \"invalid MOVB of ret\\+0\\(FP\\); int is 8-byte value\"\n-\tMOVH\tR1, ret+0(FP) // ERROR \"invalid MOVH of ret\\+0\\(FP\\); int is 8-byte value\"\n-\tMOVW\tR1, ret+0(FP) // ERROR \"invalid MOVW of ret\\+0\\(FP\\); int is 8-byte value\"\n-\tMOVV\tR1, ret+0(FP)\n-\tMOVV\tR1, ret+1(FP) // ERROR \"invalid offset ret\\+1\\(FP\\); expected ret\\+0\\(FP\\)\"\n-\tMOVV\tR1, r+0(FP) // ERROR \"unknown variable r; offset 0 is ret\\+0\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7returnbyte(SB),0,$0-9\n-\tMOVV\tx+0(FP), R1\n-\tMOVB\tR1, ret+8(FP)\n-\tMOVH\tR1, ret+8(FP) // ERROR \"invalid MOVH of ret\\+8\\(FP\\); byte is 1-byte value\"\n-\tMOVW\tR1, ret+8(FP) // ERROR \"invalid MOVW of ret\\+8\\(FP\\); byte is 1-byte value\"\n-\tMOVV\tR1, ret+8(FP) // ERROR \"invalid MOVV of ret\\+8\\(FP\\); byte is 1-byte value\"\n-\tMOVB\tR1, ret+7(FP) // ERROR \"invalid offset ret\\+7\\(FP\\); expected ret\\+8\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7returnnamed(SB),0,$0-41\n-\tMOVB\tx+0(FP), R1\n-\tMOVV\tR1, r1+8(FP)\n-\tMOVH\tR1, r2+16(FP)\n-\tMOVV\tR1, r3+24(FP)\n-\tMOVV\tR1, r3_base+24(FP)\n-\tMOVV\tR1, r3_len+32(FP)\n-\tMOVB\tR1, r4+40(FP)\n-\tMOVW\tR1, r1+8(FP) // ERROR \"invalid MOVW of r1\\+8\\(FP\\); int is 8-byte value\"\n-\tRET\n-\n-TEXT \u00b7returnintmissing(SB),0,$0-8\n-\tRET // ERROR \"RET without writing to 8-byte ret\\+0\\(FP\\)\""}, {"sha": "4e85ab3dcf967731e1e2227075d6fa221f6e79fb", "filename": "libgo/go/cmd/vet/testdata/asm/asm6.s", "status": "removed", "additions": 0, "deletions": 193, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm%2Fasm6.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm%2Fasm6.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm%2Fasm6.s?ref=225220d668dafb8262db7012bced688acbe63b33", "patch": "@@ -1,193 +0,0 @@\n-// Copyright 2016 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build s390x\n-// +build vet_test\n-\n-TEXT \u00b7arg1(SB),0,$0-2\n-\tMOVB\tx+0(FP), R1\n-\tMOVBZ\ty+1(FP), R2\n-\tMOVH\tx+0(FP), R1 // ERROR \"\\[s390x\\] arg1: invalid MOVH of x\\+0\\(FP\\); int8 is 1-byte value\"\n-\tMOVHZ\ty+1(FP), R1 // ERROR \"invalid MOVHZ of y\\+1\\(FP\\); uint8 is 1-byte value\"\n-\tMOVW\tx+0(FP), R1 // ERROR \"invalid MOVW of x\\+0\\(FP\\); int8 is 1-byte value\"\n-\tMOVWZ\ty+1(FP), R1 // ERROR \"invalid MOVWZ of y\\+1\\(FP\\); uint8 is 1-byte value\"\n-\tMOVD\tx+0(FP), R1 // ERROR \"invalid MOVD of x\\+0\\(FP\\); int8 is 1-byte value\"\n-\tMOVD\ty+1(FP), R1 // ERROR \"invalid MOVD of y\\+1\\(FP\\); uint8 is 1-byte value\"\n-\tMOVB\tx+1(FP), R1 // ERROR \"invalid offset x\\+1\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tMOVBZ\ty+2(FP), R1 // ERROR \"invalid offset y\\+2\\(FP\\); expected y\\+1\\(FP\\)\"\n-\tMOVB\t16(R15), R1 // ERROR \"16\\(R15\\) should be x\\+0\\(FP\\)\"\n-\tMOVB\t17(R15), R1 // ERROR \"17\\(R15\\) should be y\\+1\\(FP\\)\"\n-\tMOVB\t18(R15), R1 // ERROR \"use of 18\\(R15\\) points beyond argument frame\"\n-\tRET\n-\n-TEXT \u00b7arg2(SB),0,$0-4\n-\tMOVBZ\tx+0(FP), R1 // ERROR \"arg2: invalid MOVBZ of x\\+0\\(FP\\); int16 is 2-byte value\"\n-\tMOVB\ty+2(FP), R1 // ERROR \"invalid MOVB of y\\+2\\(FP\\); uint16 is 2-byte value\"\n-\tMOVHZ\tx+0(FP), R1\n-\tMOVH\ty+2(FP), R2\n-\tMOVWZ\tx+0(FP), R1 // ERROR \"invalid MOVWZ of x\\+0\\(FP\\); int16 is 2-byte value\"\n-\tMOVW\ty+2(FP), R1 // ERROR \"invalid MOVW of y\\+2\\(FP\\); uint16 is 2-byte value\"\n-\tMOVD\tx+0(FP), R1 // ERROR \"invalid MOVD of x\\+0\\(FP\\); int16 is 2-byte value\"\n-\tMOVD\ty+2(FP), R1 // ERROR \"invalid MOVD of y\\+2\\(FP\\); uint16 is 2-byte value\"\n-\tMOVHZ\tx+2(FP), R1 // ERROR \"invalid offset x\\+2\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tMOVH\ty+0(FP), R1 // ERROR \"invalid offset y\\+0\\(FP\\); expected y\\+2\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7arg4(SB),0,$0-2 // ERROR \"arg4: wrong argument size 2; expected \\$\\.\\.\\.-8\"\n-\tMOVB\tx+0(FP), R1 // ERROR \"invalid MOVB of x\\+0\\(FP\\); int32 is 4-byte value\"\n-\tMOVB\ty+4(FP), R2 // ERROR \"invalid MOVB of y\\+4\\(FP\\); uint32 is 4-byte value\"\n-\tMOVH\tx+0(FP), R1 // ERROR \"invalid MOVH of x\\+0\\(FP\\); int32 is 4-byte value\"\n-\tMOVH\ty+4(FP), R1 // ERROR \"invalid MOVH of y\\+4\\(FP\\); uint32 is 4-byte value\"\n-\tMOVW\tx+0(FP), R1\n-\tMOVW\ty+4(FP), R1\n-\tMOVD\tx+0(FP), R1 // ERROR \"invalid MOVD of x\\+0\\(FP\\); int32 is 4-byte value\"\n-\tMOVD\ty+4(FP), R1 // ERROR \"invalid MOVD of y\\+4\\(FP\\); uint32 is 4-byte value\"\n-\tMOVW\tx+4(FP), R1 // ERROR \"invalid offset x\\+4\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tMOVW\ty+2(FP), R1 // ERROR \"invalid offset y\\+2\\(FP\\); expected y\\+4\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7arg8(SB),7,$0-2 // ERROR \"wrong argument size 2; expected \\$\\.\\.\\.-16\"\n-\tMOVB\tx+0(FP), R1 // ERROR \"invalid MOVB of x\\+0\\(FP\\); int64 is 8-byte value\"\n-\tMOVB\ty+8(FP), R2 // ERROR \"invalid MOVB of y\\+8\\(FP\\); uint64 is 8-byte value\"\n-\tMOVH\tx+0(FP), R1 // ERROR \"invalid MOVH of x\\+0\\(FP\\); int64 is 8-byte value\"\n-\tMOVH\ty+8(FP), R1 // ERROR \"invalid MOVH of y\\+8\\(FP\\); uint64 is 8-byte value\"\n-\tMOVW\tx+0(FP), R1 // ERROR \"invalid MOVW of x\\+0\\(FP\\); int64 is 8-byte value\"\n-\tMOVW\ty+8(FP), R1 // ERROR \"invalid MOVW of y\\+8\\(FP\\); uint64 is 8-byte value\"\n-\tMOVD\tx+0(FP), R1\n-\tMOVD\ty+8(FP), R1\n-\tMOVD\tx+8(FP), R1 // ERROR \"invalid offset x\\+8\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tMOVD\ty+2(FP), R1 // ERROR \"invalid offset y\\+2\\(FP\\); expected y\\+8\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7argint(SB),0,$0-2 // ERROR \"wrong argument size 2; expected \\$\\.\\.\\.-16\"\n-\tMOVB\tx+0(FP), R1 // ERROR \"invalid MOVB of x\\+0\\(FP\\); int is 8-byte value\"\n-\tMOVB\ty+8(FP), R2 // ERROR \"invalid MOVB of y\\+8\\(FP\\); uint is 8-byte value\"\n-\tMOVH\tx+0(FP), R1 // ERROR \"invalid MOVH of x\\+0\\(FP\\); int is 8-byte value\"\n-\tMOVH\ty+8(FP), R1 // ERROR \"invalid MOVH of y\\+8\\(FP\\); uint is 8-byte value\"\n-\tMOVW\tx+0(FP), R1 // ERROR \"invalid MOVW of x\\+0\\(FP\\); int is 8-byte value\"\n-\tMOVW\ty+8(FP), R1 // ERROR \"invalid MOVW of y\\+8\\(FP\\); uint is 8-byte value\"\n-\tMOVD\tx+0(FP), R1\n-\tMOVD\ty+8(FP), R1\n-\tMOVD\tx+8(FP), R1 // ERROR \"invalid offset x\\+8\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tMOVD\ty+2(FP), R1 // ERROR \"invalid offset y\\+2\\(FP\\); expected y\\+8\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7argptr(SB),7,$0-2 // ERROR \"wrong argument size 2; expected \\$\\.\\.\\.-40\"\n-\tMOVB\tx+0(FP), R1 // ERROR \"invalid MOVB of x\\+0\\(FP\\); \\*byte is 8-byte value\"\n-\tMOVB\ty+8(FP), R2 // ERROR \"invalid MOVB of y\\+8\\(FP\\); \\*byte is 8-byte value\"\n-\tMOVH\tx+0(FP), R1 // ERROR \"invalid MOVH of x\\+0\\(FP\\); \\*byte is 8-byte value\"\n-\tMOVH\ty+8(FP), R1 // ERROR \"invalid MOVH of y\\+8\\(FP\\); \\*byte is 8-byte value\"\n-\tMOVW\tx+0(FP), R1 // ERROR \"invalid MOVW of x\\+0\\(FP\\); \\*byte is 8-byte value\"\n-\tMOVW\ty+8(FP), R1 // ERROR \"invalid MOVW of y\\+8\\(FP\\); \\*byte is 8-byte value\"\n-\tMOVD\tx+0(FP), R1\n-\tMOVD\ty+8(FP), R1\n-\tMOVD\tx+8(FP), R1 // ERROR \"invalid offset x\\+8\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tMOVD\ty+2(FP), R1 // ERROR \"invalid offset y\\+2\\(FP\\); expected y\\+8\\(FP\\)\"\n-\tMOVW\tc+16(FP), R1 // ERROR \"invalid MOVW of c\\+16\\(FP\\); chan int is 8-byte value\"\n-\tMOVW\tm+24(FP), R1 // ERROR \"invalid MOVW of m\\+24\\(FP\\); map\\[int\\]int is 8-byte value\"\n-\tMOVW\tf+32(FP), R1 // ERROR \"invalid MOVW of f\\+32\\(FP\\); func\\(\\) is 8-byte value\"\n-\tRET\n-\n-TEXT \u00b7argstring(SB),0,$32 // ERROR \"wrong argument size 0; expected \\$\\.\\.\\.-32\"\n-\tMOVH\tx+0(FP), R1 // ERROR \"invalid MOVH of x\\+0\\(FP\\); string base is 8-byte value\"\n-\tMOVW\tx+0(FP), R1 // ERROR \"invalid MOVW of x\\+0\\(FP\\); string base is 8-byte value\"\n-\tMOVD\tx+0(FP), R1\n-\tMOVH\tx_base+0(FP), R1 // ERROR \"invalid MOVH of x_base\\+0\\(FP\\); string base is 8-byte value\"\n-\tMOVW\tx_base+0(FP), R1 // ERROR \"invalid MOVW of x_base\\+0\\(FP\\); string base is 8-byte value\"\n-\tMOVD\tx_base+0(FP), R1\n-\tMOVH\tx_len+0(FP), R1 // ERROR \"invalid offset x_len\\+0\\(FP\\); expected x_len\\+8\\(FP\\)\"\n-\tMOVW\tx_len+0(FP), R1 // ERROR \"invalid offset x_len\\+0\\(FP\\); expected x_len\\+8\\(FP\\)\"\n-\tMOVD\tx_len+0(FP), R1 // ERROR \"invalid offset x_len\\+0\\(FP\\); expected x_len\\+8\\(FP\\)\"\n-\tMOVH\tx_len+8(FP), R1 // ERROR \"invalid MOVH of x_len\\+8\\(FP\\); string len is 8-byte value\"\n-\tMOVW\tx_len+8(FP), R1 // ERROR \"invalid MOVW of x_len\\+8\\(FP\\); string len is 8-byte value\"\n-\tMOVD\tx_len+8(FP), R1\n-\tMOVD\ty+0(FP), R1 // ERROR \"invalid offset y\\+0\\(FP\\); expected y\\+16\\(FP\\)\"\n-\tMOVD\ty_len+8(FP), R1 // ERROR \"invalid offset y_len\\+8\\(FP\\); expected y_len\\+24\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7argslice(SB),0,$48 // ERROR \"wrong argument size 0; expected \\$\\.\\.\\.-48\"\n-\tMOVH\tx+0(FP), R1 // ERROR \"invalid MOVH of x\\+0\\(FP\\); slice base is 8-byte value\"\n-\tMOVW\tx+0(FP), R1 // ERROR \"invalid MOVW of x\\+0\\(FP\\); slice base is 8-byte value\"\n-\tMOVD\tx+0(FP), R1\n-\tMOVH\tx_base+0(FP), R1 // ERROR \"invalid MOVH of x_base\\+0\\(FP\\); slice base is 8-byte value\"\n-\tMOVW\tx_base+0(FP), R1 // ERROR \"invalid MOVW of x_base\\+0\\(FP\\); slice base is 8-byte value\"\n-\tMOVD\tx_base+0(FP), R1\n-\tMOVH\tx_len+0(FP), R1 // ERROR \"invalid offset x_len\\+0\\(FP\\); expected x_len\\+8\\(FP\\)\"\n-\tMOVW\tx_len+0(FP), R1 // ERROR \"invalid offset x_len\\+0\\(FP\\); expected x_len\\+8\\(FP\\)\"\n-\tMOVD\tx_len+0(FP), R1 // ERROR \"invalid offset x_len\\+0\\(FP\\); expected x_len\\+8\\(FP\\)\"\n-\tMOVH\tx_len+8(FP), R1 // ERROR \"invalid MOVH of x_len\\+8\\(FP\\); slice len is 8-byte value\"\n-\tMOVW\tx_len+8(FP), R1 // ERROR \"invalid MOVW of x_len\\+8\\(FP\\); slice len is 8-byte value\"\n-\tMOVD\tx_len+8(FP), R1\n-\tMOVH\tx_cap+0(FP), R1 // ERROR \"invalid offset x_cap\\+0\\(FP\\); expected x_cap\\+16\\(FP\\)\"\n-\tMOVW\tx_cap+0(FP), R1 // ERROR \"invalid offset x_cap\\+0\\(FP\\); expected x_cap\\+16\\(FP\\)\"\n-\tMOVD\tx_cap+0(FP), R1 // ERROR \"invalid offset x_cap\\+0\\(FP\\); expected x_cap\\+16\\(FP\\)\"\n-\tMOVH\tx_cap+16(FP), R1 // ERROR \"invalid MOVH of x_cap\\+16\\(FP\\); slice cap is 8-byte value\"\n-\tMOVW\tx_cap+16(FP), R1 // ERROR \"invalid MOVW of x_cap\\+16\\(FP\\); slice cap is 8-byte value\"\n-\tMOVD\tx_cap+16(FP), R1\n-\tMOVD\ty+0(FP), R1 // ERROR \"invalid offset y\\+0\\(FP\\); expected y\\+24\\(FP\\)\"\n-\tMOVD\ty_len+8(FP), R1 // ERROR \"invalid offset y_len\\+8\\(FP\\); expected y_len\\+32\\(FP\\)\"\n-\tMOVD\ty_cap+16(FP), R1 // ERROR \"invalid offset y_cap\\+16\\(FP\\); expected y_cap\\+40\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7argiface(SB),0,$0-32\n-\tMOVH\tx+0(FP), R1 // ERROR \"invalid MOVH of x\\+0\\(FP\\); interface type is 8-byte value\"\n-\tMOVW\tx+0(FP), R1 // ERROR \"invalid MOVW of x\\+0\\(FP\\); interface type is 8-byte value\"\n-\tMOVD\tx+0(FP), R1\n-\tMOVH\tx_type+0(FP), R1 // ERROR \"invalid MOVH of x_type\\+0\\(FP\\); interface type is 8-byte value\"\n-\tMOVW\tx_type+0(FP), R1 // ERROR \"invalid MOVW of x_type\\+0\\(FP\\); interface type is 8-byte value\"\n-\tMOVD\tx_type+0(FP), R1\n-\tMOVD\tx_itable+0(FP), R1 // ERROR \"unknown variable x_itable; offset 0 is x_type\\+0\\(FP\\)\"\n-\tMOVD\tx_itable+1(FP), R1 // ERROR \"unknown variable x_itable; offset 1 is x_type\\+0\\(FP\\)\"\n-\tMOVH\tx_data+0(FP), R1 // ERROR \"invalid offset x_data\\+0\\(FP\\); expected x_data\\+8\\(FP\\)\"\n-\tMOVW\tx_data+0(FP), R1 // ERROR \"invalid offset x_data\\+0\\(FP\\); expected x_data\\+8\\(FP\\)\"\n-\tMOVD\tx_data+0(FP), R1 // ERROR \"invalid offset x_data\\+0\\(FP\\); expected x_data\\+8\\(FP\\)\"\n-\tMOVH\tx_data+8(FP), R1 // ERROR \"invalid MOVH of x_data\\+8\\(FP\\); interface data is 8-byte value\"\n-\tMOVW\tx_data+8(FP), R1 // ERROR \"invalid MOVW of x_data\\+8\\(FP\\); interface data is 8-byte value\"\n-\tMOVD\tx_data+8(FP), R1\n-\tMOVH\ty+16(FP), R1 // ERROR \"invalid MOVH of y\\+16\\(FP\\); interface itable is 8-byte value\"\n-\tMOVW\ty+16(FP), R1 // ERROR \"invalid MOVW of y\\+16\\(FP\\); interface itable is 8-byte value\"\n-\tMOVD\ty+16(FP), R1\n-\tMOVH\ty_itable+16(FP), R1 // ERROR \"invalid MOVH of y_itable\\+16\\(FP\\); interface itable is 8-byte value\"\n-\tMOVW\ty_itable+16(FP), R1 // ERROR \"invalid MOVW of y_itable\\+16\\(FP\\); interface itable is 8-byte value\"\n-\tMOVD\ty_itable+16(FP), R1\n-\tMOVD\ty_type+16(FP), R1 // ERROR \"unknown variable y_type; offset 16 is y_itable\\+16\\(FP\\)\"\n-\tMOVH\ty_data+16(FP), R1 // ERROR \"invalid offset y_data\\+16\\(FP\\); expected y_data\\+24\\(FP\\)\"\n-\tMOVW\ty_data+16(FP), R1 // ERROR \"invalid offset y_data\\+16\\(FP\\); expected y_data\\+24\\(FP\\)\"\n-\tMOVD\ty_data+16(FP), R1 // ERROR \"invalid offset y_data\\+16\\(FP\\); expected y_data\\+24\\(FP\\)\"\n-\tMOVH\ty_data+24(FP), R1 // ERROR \"invalid MOVH of y_data\\+24\\(FP\\); interface data is 8-byte value\"\n-\tMOVW\ty_data+24(FP), R1 // ERROR \"invalid MOVW of y_data\\+24\\(FP\\); interface data is 8-byte value\"\n-\tMOVD\ty_data+24(FP), R1\n-\tRET\n-\n-TEXT \u00b7returnint(SB),0,$0-8\n-\tMOVB\tR1, ret+0(FP) // ERROR \"invalid MOVB of ret\\+0\\(FP\\); int is 8-byte value\"\n-\tMOVH\tR1, ret+0(FP) // ERROR \"invalid MOVH of ret\\+0\\(FP\\); int is 8-byte value\"\n-\tMOVW\tR1, ret+0(FP) // ERROR \"invalid MOVW of ret\\+0\\(FP\\); int is 8-byte value\"\n-\tMOVD\tR1, ret+0(FP)\n-\tMOVD\tR1, ret+1(FP) // ERROR \"invalid offset ret\\+1\\(FP\\); expected ret\\+0\\(FP\\)\"\n-\tMOVD\tR1, r+0(FP) // ERROR \"unknown variable r; offset 0 is ret\\+0\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7returnbyte(SB),0,$0-9\n-\tMOVD\tx+0(FP), R1\n-\tMOVB\tR1, ret+8(FP)\n-\tMOVH\tR1, ret+8(FP) // ERROR \"invalid MOVH of ret\\+8\\(FP\\); byte is 1-byte value\"\n-\tMOVW\tR1, ret+8(FP) // ERROR \"invalid MOVW of ret\\+8\\(FP\\); byte is 1-byte value\"\n-\tMOVD\tR1, ret+8(FP) // ERROR \"invalid MOVD of ret\\+8\\(FP\\); byte is 1-byte value\"\n-\tMOVB\tR1, ret+7(FP) // ERROR \"invalid offset ret\\+7\\(FP\\); expected ret\\+8\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7returnnamed(SB),0,$0-41\n-\tMOVB\tx+0(FP), R1\n-\tMOVD\tR1, r1+8(FP)\n-\tMOVH\tR1, r2+16(FP)\n-\tMOVD\tR1, r3+24(FP)\n-\tMOVD\tR1, r3_base+24(FP)\n-\tMOVD\tR1, r3_len+32(FP)\n-\tMOVB\tR1, r4+40(FP)\n-\tMOVW\tR1, r1+8(FP) // ERROR \"invalid MOVW of r1\\+8\\(FP\\); int is 8-byte value\"\n-\tRET\n-\n-TEXT \u00b7returnintmissing(SB),0,$0-8\n-\tRET // ERROR \"RET without writing to 8-byte ret\\+0\\(FP\\)\""}, {"sha": "d5ff5460a565d70091195d9fcaf13b4feba0d5b1", "filename": "libgo/go/cmd/vet/testdata/asm/asm7.s", "status": "removed", "additions": 0, "deletions": 193, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm%2Fasm7.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm%2Fasm7.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm%2Fasm7.s?ref=225220d668dafb8262db7012bced688acbe63b33", "patch": "@@ -1,193 +0,0 @@\n-// Copyright 2016 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build ppc64 ppc64le\n-// +build vet_test\n-\n-TEXT \u00b7arg1(SB),0,$0-2\n-\tMOVB\tx+0(FP), R3\n-\tMOVBZ\ty+1(FP), R4\n-\tMOVH\tx+0(FP), R3 // ERROR \"\\[(ppc64|ppc64le)\\] arg1: invalid MOVH of x\\+0\\(FP\\); int8 is 1-byte value\"\n-\tMOVHZ\ty+1(FP), R3 // ERROR \"invalid MOVHZ of y\\+1\\(FP\\); uint8 is 1-byte value\"\n-\tMOVW\tx+0(FP), R3 // ERROR \"invalid MOVW of x\\+0\\(FP\\); int8 is 1-byte value\"\n-\tMOVWZ\ty+1(FP), R3 // ERROR \"invalid MOVWZ of y\\+1\\(FP\\); uint8 is 1-byte value\"\n-\tMOVD\tx+0(FP), R3 // ERROR \"invalid MOVD of x\\+0\\(FP\\); int8 is 1-byte value\"\n-\tMOVD\ty+1(FP), R3 // ERROR \"invalid MOVD of y\\+1\\(FP\\); uint8 is 1-byte value\"\n-\tMOVB\tx+1(FP), R3 // ERROR \"invalid offset x\\+1\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tMOVBZ\ty+2(FP), R3 // ERROR \"invalid offset y\\+2\\(FP\\); expected y\\+1\\(FP\\)\"\n-\tMOVB\t16(R1), R3 // ERROR \"16\\(R1\\) should be x\\+0\\(FP\\)\"\n-\tMOVB\t17(R1), R3 // ERROR \"17\\(R1\\) should be y\\+1\\(FP\\)\"\n-\tMOVB\t18(R1), R3 // ERROR \"use of 18\\(R1\\) points beyond argument frame\"\n-\tRET\n-\n-TEXT \u00b7arg2(SB),0,$0-4\n-\tMOVBZ\tx+0(FP), R3 // ERROR \"arg2: invalid MOVBZ of x\\+0\\(FP\\); int16 is 2-byte value\"\n-\tMOVB\ty+2(FP), R3 // ERROR \"invalid MOVB of y\\+2\\(FP\\); uint16 is 2-byte value\"\n-\tMOVHZ\tx+0(FP), R3\n-\tMOVH\ty+2(FP), R4\n-\tMOVWZ\tx+0(FP), R3 // ERROR \"invalid MOVWZ of x\\+0\\(FP\\); int16 is 2-byte value\"\n-\tMOVW\ty+2(FP), R3 // ERROR \"invalid MOVW of y\\+2\\(FP\\); uint16 is 2-byte value\"\n-\tMOVD\tx+0(FP), R3 // ERROR \"invalid MOVD of x\\+0\\(FP\\); int16 is 2-byte value\"\n-\tMOVD\ty+2(FP), R3 // ERROR \"invalid MOVD of y\\+2\\(FP\\); uint16 is 2-byte value\"\n-\tMOVHZ\tx+2(FP), R3 // ERROR \"invalid offset x\\+2\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tMOVH\ty+0(FP), R3 // ERROR \"invalid offset y\\+0\\(FP\\); expected y\\+2\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7arg4(SB),0,$0-2 // ERROR \"arg4: wrong argument size 2; expected \\$\\.\\.\\.-8\"\n-\tMOVB\tx+0(FP), R3 // ERROR \"invalid MOVB of x\\+0\\(FP\\); int32 is 4-byte value\"\n-\tMOVB\ty+4(FP), R4 // ERROR \"invalid MOVB of y\\+4\\(FP\\); uint32 is 4-byte value\"\n-\tMOVH\tx+0(FP), R3 // ERROR \"invalid MOVH of x\\+0\\(FP\\); int32 is 4-byte value\"\n-\tMOVH\ty+4(FP), R3 // ERROR \"invalid MOVH of y\\+4\\(FP\\); uint32 is 4-byte value\"\n-\tMOVW\tx+0(FP), R3\n-\tMOVW\ty+4(FP), R3\n-\tMOVD\tx+0(FP), R3 // ERROR \"invalid MOVD of x\\+0\\(FP\\); int32 is 4-byte value\"\n-\tMOVD\ty+4(FP), R3 // ERROR \"invalid MOVD of y\\+4\\(FP\\); uint32 is 4-byte value\"\n-\tMOVW\tx+4(FP), R3 // ERROR \"invalid offset x\\+4\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tMOVW\ty+2(FP), R3 // ERROR \"invalid offset y\\+2\\(FP\\); expected y\\+4\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7arg8(SB),7,$0-2 // ERROR \"wrong argument size 2; expected \\$\\.\\.\\.-16\"\n-\tMOVB\tx+0(FP), R3 // ERROR \"invalid MOVB of x\\+0\\(FP\\); int64 is 8-byte value\"\n-\tMOVB\ty+8(FP), R4 // ERROR \"invalid MOVB of y\\+8\\(FP\\); uint64 is 8-byte value\"\n-\tMOVH\tx+0(FP), R3 // ERROR \"invalid MOVH of x\\+0\\(FP\\); int64 is 8-byte value\"\n-\tMOVH\ty+8(FP), R3 // ERROR \"invalid MOVH of y\\+8\\(FP\\); uint64 is 8-byte value\"\n-\tMOVW\tx+0(FP), R3 // ERROR \"invalid MOVW of x\\+0\\(FP\\); int64 is 8-byte value\"\n-\tMOVW\ty+8(FP), R3 // ERROR \"invalid MOVW of y\\+8\\(FP\\); uint64 is 8-byte value\"\n-\tMOVD\tx+0(FP), R3\n-\tMOVD\ty+8(FP), R3\n-\tMOVD\tx+8(FP), R3 // ERROR \"invalid offset x\\+8\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tMOVD\ty+2(FP), R3 // ERROR \"invalid offset y\\+2\\(FP\\); expected y\\+8\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7argint(SB),0,$0-2 // ERROR \"wrong argument size 2; expected \\$\\.\\.\\.-16\"\n-\tMOVB\tx+0(FP), R3 // ERROR \"invalid MOVB of x\\+0\\(FP\\); int is 8-byte value\"\n-\tMOVB\ty+8(FP), R4 // ERROR \"invalid MOVB of y\\+8\\(FP\\); uint is 8-byte value\"\n-\tMOVH\tx+0(FP), R3 // ERROR \"invalid MOVH of x\\+0\\(FP\\); int is 8-byte value\"\n-\tMOVH\ty+8(FP), R3 // ERROR \"invalid MOVH of y\\+8\\(FP\\); uint is 8-byte value\"\n-\tMOVW\tx+0(FP), R3 // ERROR \"invalid MOVW of x\\+0\\(FP\\); int is 8-byte value\"\n-\tMOVW\ty+8(FP), R3 // ERROR \"invalid MOVW of y\\+8\\(FP\\); uint is 8-byte value\"\n-\tMOVD\tx+0(FP), R3\n-\tMOVD\ty+8(FP), R3\n-\tMOVD\tx+8(FP), R3 // ERROR \"invalid offset x\\+8\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tMOVD\ty+2(FP), R3 // ERROR \"invalid offset y\\+2\\(FP\\); expected y\\+8\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7argptr(SB),7,$0-2 // ERROR \"wrong argument size 2; expected \\$\\.\\.\\.-40\"\n-\tMOVB\tx+0(FP), R3 // ERROR \"invalid MOVB of x\\+0\\(FP\\); \\*byte is 8-byte value\"\n-\tMOVB\ty+8(FP), R4 // ERROR \"invalid MOVB of y\\+8\\(FP\\); \\*byte is 8-byte value\"\n-\tMOVH\tx+0(FP), R3 // ERROR \"invalid MOVH of x\\+0\\(FP\\); \\*byte is 8-byte value\"\n-\tMOVH\ty+8(FP), R3 // ERROR \"invalid MOVH of y\\+8\\(FP\\); \\*byte is 8-byte value\"\n-\tMOVW\tx+0(FP), R3 // ERROR \"invalid MOVW of x\\+0\\(FP\\); \\*byte is 8-byte value\"\n-\tMOVW\ty+8(FP), R3 // ERROR \"invalid MOVW of y\\+8\\(FP\\); \\*byte is 8-byte value\"\n-\tMOVD\tx+0(FP), R3\n-\tMOVD\ty+8(FP), R3\n-\tMOVD\tx+8(FP), R3 // ERROR \"invalid offset x\\+8\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tMOVD\ty+2(FP), R3 // ERROR \"invalid offset y\\+2\\(FP\\); expected y\\+8\\(FP\\)\"\n-\tMOVW\tc+16(FP), R3 // ERROR \"invalid MOVW of c\\+16\\(FP\\); chan int is 8-byte value\"\n-\tMOVW\tm+24(FP), R3 // ERROR \"invalid MOVW of m\\+24\\(FP\\); map\\[int\\]int is 8-byte value\"\n-\tMOVW\tf+32(FP), R3 // ERROR \"invalid MOVW of f\\+32\\(FP\\); func\\(\\) is 8-byte value\"\n-\tRET\n-\n-TEXT \u00b7argstring(SB),0,$32 // ERROR \"wrong argument size 0; expected \\$\\.\\.\\.-32\"\n-\tMOVH\tx+0(FP), R3 // ERROR \"invalid MOVH of x\\+0\\(FP\\); string base is 8-byte value\"\n-\tMOVW\tx+0(FP), R3 // ERROR \"invalid MOVW of x\\+0\\(FP\\); string base is 8-byte value\"\n-\tMOVD\tx+0(FP), R3\n-\tMOVH\tx_base+0(FP), R3 // ERROR \"invalid MOVH of x_base\\+0\\(FP\\); string base is 8-byte value\"\n-\tMOVW\tx_base+0(FP), R3 // ERROR \"invalid MOVW of x_base\\+0\\(FP\\); string base is 8-byte value\"\n-\tMOVD\tx_base+0(FP), R3\n-\tMOVH\tx_len+0(FP), R3 // ERROR \"invalid offset x_len\\+0\\(FP\\); expected x_len\\+8\\(FP\\)\"\n-\tMOVW\tx_len+0(FP), R3 // ERROR \"invalid offset x_len\\+0\\(FP\\); expected x_len\\+8\\(FP\\)\"\n-\tMOVD\tx_len+0(FP), R3 // ERROR \"invalid offset x_len\\+0\\(FP\\); expected x_len\\+8\\(FP\\)\"\n-\tMOVH\tx_len+8(FP), R3 // ERROR \"invalid MOVH of x_len\\+8\\(FP\\); string len is 8-byte value\"\n-\tMOVW\tx_len+8(FP), R3 // ERROR \"invalid MOVW of x_len\\+8\\(FP\\); string len is 8-byte value\"\n-\tMOVD\tx_len+8(FP), R3\n-\tMOVD\ty+0(FP), R3 // ERROR \"invalid offset y\\+0\\(FP\\); expected y\\+16\\(FP\\)\"\n-\tMOVD\ty_len+8(FP), R3 // ERROR \"invalid offset y_len\\+8\\(FP\\); expected y_len\\+24\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7argslice(SB),0,$48 // ERROR \"wrong argument size 0; expected \\$\\.\\.\\.-48\"\n-\tMOVH\tx+0(FP), R3 // ERROR \"invalid MOVH of x\\+0\\(FP\\); slice base is 8-byte value\"\n-\tMOVW\tx+0(FP), R3 // ERROR \"invalid MOVW of x\\+0\\(FP\\); slice base is 8-byte value\"\n-\tMOVD\tx+0(FP), R3\n-\tMOVH\tx_base+0(FP), R3 // ERROR \"invalid MOVH of x_base\\+0\\(FP\\); slice base is 8-byte value\"\n-\tMOVW\tx_base+0(FP), R3 // ERROR \"invalid MOVW of x_base\\+0\\(FP\\); slice base is 8-byte value\"\n-\tMOVD\tx_base+0(FP), R3\n-\tMOVH\tx_len+0(FP), R3 // ERROR \"invalid offset x_len\\+0\\(FP\\); expected x_len\\+8\\(FP\\)\"\n-\tMOVW\tx_len+0(FP), R3 // ERROR \"invalid offset x_len\\+0\\(FP\\); expected x_len\\+8\\(FP\\)\"\n-\tMOVD\tx_len+0(FP), R3 // ERROR \"invalid offset x_len\\+0\\(FP\\); expected x_len\\+8\\(FP\\)\"\n-\tMOVH\tx_len+8(FP), R3 // ERROR \"invalid MOVH of x_len\\+8\\(FP\\); slice len is 8-byte value\"\n-\tMOVW\tx_len+8(FP), R3 // ERROR \"invalid MOVW of x_len\\+8\\(FP\\); slice len is 8-byte value\"\n-\tMOVD\tx_len+8(FP), R3\n-\tMOVH\tx_cap+0(FP), R3 // ERROR \"invalid offset x_cap\\+0\\(FP\\); expected x_cap\\+16\\(FP\\)\"\n-\tMOVW\tx_cap+0(FP), R3 // ERROR \"invalid offset x_cap\\+0\\(FP\\); expected x_cap\\+16\\(FP\\)\"\n-\tMOVD\tx_cap+0(FP), R3 // ERROR \"invalid offset x_cap\\+0\\(FP\\); expected x_cap\\+16\\(FP\\)\"\n-\tMOVH\tx_cap+16(FP), R3 // ERROR \"invalid MOVH of x_cap\\+16\\(FP\\); slice cap is 8-byte value\"\n-\tMOVW\tx_cap+16(FP), R3 // ERROR \"invalid MOVW of x_cap\\+16\\(FP\\); slice cap is 8-byte value\"\n-\tMOVD\tx_cap+16(FP), R3\n-\tMOVD\ty+0(FP), R3 // ERROR \"invalid offset y\\+0\\(FP\\); expected y\\+24\\(FP\\)\"\n-\tMOVD\ty_len+8(FP), R3 // ERROR \"invalid offset y_len\\+8\\(FP\\); expected y_len\\+32\\(FP\\)\"\n-\tMOVD\ty_cap+16(FP), R3 // ERROR \"invalid offset y_cap\\+16\\(FP\\); expected y_cap\\+40\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7argiface(SB),0,$0-32\n-\tMOVH\tx+0(FP), R3 // ERROR \"invalid MOVH of x\\+0\\(FP\\); interface type is 8-byte value\"\n-\tMOVW\tx+0(FP), R3 // ERROR \"invalid MOVW of x\\+0\\(FP\\); interface type is 8-byte value\"\n-\tMOVD\tx+0(FP), R3\n-\tMOVH\tx_type+0(FP), R3 // ERROR \"invalid MOVH of x_type\\+0\\(FP\\); interface type is 8-byte value\"\n-\tMOVW\tx_type+0(FP), R3 // ERROR \"invalid MOVW of x_type\\+0\\(FP\\); interface type is 8-byte value\"\n-\tMOVD\tx_type+0(FP), R3\n-\tMOVD\tx_itable+0(FP), R3 // ERROR \"unknown variable x_itable; offset 0 is x_type\\+0\\(FP\\)\"\n-\tMOVD\tx_itable+1(FP), R3 // ERROR \"unknown variable x_itable; offset 1 is x_type\\+0\\(FP\\)\"\n-\tMOVH\tx_data+0(FP), R3 // ERROR \"invalid offset x_data\\+0\\(FP\\); expected x_data\\+8\\(FP\\)\"\n-\tMOVW\tx_data+0(FP), R3 // ERROR \"invalid offset x_data\\+0\\(FP\\); expected x_data\\+8\\(FP\\)\"\n-\tMOVD\tx_data+0(FP), R3 // ERROR \"invalid offset x_data\\+0\\(FP\\); expected x_data\\+8\\(FP\\)\"\n-\tMOVH\tx_data+8(FP), R3 // ERROR \"invalid MOVH of x_data\\+8\\(FP\\); interface data is 8-byte value\"\n-\tMOVW\tx_data+8(FP), R3 // ERROR \"invalid MOVW of x_data\\+8\\(FP\\); interface data is 8-byte value\"\n-\tMOVD\tx_data+8(FP), R3\n-\tMOVH\ty+16(FP), R3 // ERROR \"invalid MOVH of y\\+16\\(FP\\); interface itable is 8-byte value\"\n-\tMOVW\ty+16(FP), R3 // ERROR \"invalid MOVW of y\\+16\\(FP\\); interface itable is 8-byte value\"\n-\tMOVD\ty+16(FP), R3\n-\tMOVH\ty_itable+16(FP), R3 // ERROR \"invalid MOVH of y_itable\\+16\\(FP\\); interface itable is 8-byte value\"\n-\tMOVW\ty_itable+16(FP), R3 // ERROR \"invalid MOVW of y_itable\\+16\\(FP\\); interface itable is 8-byte value\"\n-\tMOVD\ty_itable+16(FP), R3\n-\tMOVD\ty_type+16(FP), R3 // ERROR \"unknown variable y_type; offset 16 is y_itable\\+16\\(FP\\)\"\n-\tMOVH\ty_data+16(FP), R3 // ERROR \"invalid offset y_data\\+16\\(FP\\); expected y_data\\+24\\(FP\\)\"\n-\tMOVW\ty_data+16(FP), R3 // ERROR \"invalid offset y_data\\+16\\(FP\\); expected y_data\\+24\\(FP\\)\"\n-\tMOVD\ty_data+16(FP), R3 // ERROR \"invalid offset y_data\\+16\\(FP\\); expected y_data\\+24\\(FP\\)\"\n-\tMOVH\ty_data+24(FP), R3 // ERROR \"invalid MOVH of y_data\\+24\\(FP\\); interface data is 8-byte value\"\n-\tMOVW\ty_data+24(FP), R3 // ERROR \"invalid MOVW of y_data\\+24\\(FP\\); interface data is 8-byte value\"\n-\tMOVD\ty_data+24(FP), R3\n-\tRET\n-\n-TEXT \u00b7returnint(SB),0,$0-8\n-\tMOVB\tR3, ret+0(FP) // ERROR \"invalid MOVB of ret\\+0\\(FP\\); int is 8-byte value\"\n-\tMOVH\tR3, ret+0(FP) // ERROR \"invalid MOVH of ret\\+0\\(FP\\); int is 8-byte value\"\n-\tMOVW\tR3, ret+0(FP) // ERROR \"invalid MOVW of ret\\+0\\(FP\\); int is 8-byte value\"\n-\tMOVD\tR3, ret+0(FP)\n-\tMOVD\tR3, ret+1(FP) // ERROR \"invalid offset ret\\+1\\(FP\\); expected ret\\+0\\(FP\\)\"\n-\tMOVD\tR3, r+0(FP) // ERROR \"unknown variable r; offset 0 is ret\\+0\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7returnbyte(SB),0,$0-9\n-\tMOVD\tx+0(FP), R3\n-\tMOVB\tR3, ret+8(FP)\n-\tMOVH\tR3, ret+8(FP) // ERROR \"invalid MOVH of ret\\+8\\(FP\\); byte is 1-byte value\"\n-\tMOVW\tR3, ret+8(FP) // ERROR \"invalid MOVW of ret\\+8\\(FP\\); byte is 1-byte value\"\n-\tMOVD\tR3, ret+8(FP) // ERROR \"invalid MOVD of ret\\+8\\(FP\\); byte is 1-byte value\"\n-\tMOVB\tR3, ret+7(FP) // ERROR \"invalid offset ret\\+7\\(FP\\); expected ret\\+8\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7returnnamed(SB),0,$0-41\n-\tMOVB\tx+0(FP), R3\n-\tMOVD\tR3, r1+8(FP)\n-\tMOVH\tR3, r2+16(FP)\n-\tMOVD\tR3, r3+24(FP)\n-\tMOVD\tR3, r3_base+24(FP)\n-\tMOVD\tR3, r3_len+32(FP)\n-\tMOVB\tR3, r4+40(FP)\n-\tMOVW\tR3, r1+8(FP) // ERROR \"invalid MOVW of r1\\+8\\(FP\\); int is 8-byte value\"\n-\tRET\n-\n-TEXT \u00b7returnintmissing(SB),0,$0-8\n-\tRET // ERROR \"RET without writing to 8-byte ret\\+0\\(FP\\)\""}, {"sha": "550d92a8d2daa6fcc8b714486ba8e534e7850a6e", "filename": "libgo/go/cmd/vet/testdata/asm8.s", "status": "removed", "additions": 0, "deletions": 165, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm8.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm8.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm8.s?ref=225220d668dafb8262db7012bced688acbe63b33", "patch": "@@ -1,165 +0,0 @@\n-// Copyright 2016 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build mipsle\n-// +build vet_test\n-\n-TEXT \u00b7arg1(SB),0,$0-2\n-\tMOVB\tx+0(FP), R1\n-\tMOVBU\ty+1(FP), R2\n-\tMOVH\tx+0(FP), R1 // ERROR \"\\[mipsle\\] arg1: invalid MOVH of x\\+0\\(FP\\); int8 is 1-byte value\"\n-\tMOVHU\ty+1(FP), R1 // ERROR \"invalid MOVHU of y\\+1\\(FP\\); uint8 is 1-byte value\"\n-\tMOVW\tx+0(FP), R1 // ERROR \"invalid MOVW of x\\+0\\(FP\\); int8 is 1-byte value\"\n-\tMOVWU\ty+1(FP), R1 // ERROR \"invalid MOVWU of y\\+1\\(FP\\); uint8 is 1-byte value\"\n-\tMOVW\ty+1(FP), R1 // ERROR \"invalid MOVW of y\\+1\\(FP\\); uint8 is 1-byte value\"\n-\tMOVB\tx+1(FP), R1 // ERROR \"invalid offset x\\+1\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tMOVBU\ty+2(FP), R1 // ERROR \"invalid offset y\\+2\\(FP\\); expected y\\+1\\(FP\\)\"\n-\tMOVB\t8(R29), R1 // ERROR \"8\\(R29\\) should be x\\+0\\(FP\\)\"\n-\tMOVB\t9(R29), R1 // ERROR \"9\\(R29\\) should be y\\+1\\(FP\\)\"\n-\tMOVB\t10(R29), R1 // ERROR \"use of 10\\(R29\\) points beyond argument frame\"\n-\tRET\n-\n-TEXT \u00b7arg2(SB),0,$0-4\n-\tMOVBU\tx+0(FP), R1 // ERROR \"arg2: invalid MOVBU of x\\+0\\(FP\\); int16 is 2-byte value\"\n-\tMOVB\ty+2(FP), R1 // ERROR \"invalid MOVB of y\\+2\\(FP\\); uint16 is 2-byte value\"\n-\tMOVHU\tx+0(FP), R1\n-\tMOVH\ty+2(FP), R2\n-\tMOVWU\tx+0(FP), R1 // ERROR \"invalid MOVWU of x\\+0\\(FP\\); int16 is 2-byte value\"\n-\tMOVW\ty+2(FP), R1 // ERROR \"invalid MOVW of y\\+2\\(FP\\); uint16 is 2-byte value\"\n-\tMOVHU\tx+2(FP), R1 // ERROR \"invalid offset x\\+2\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tMOVH\ty+0(FP), R1 // ERROR \"invalid offset y\\+0\\(FP\\); expected y\\+2\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7arg4(SB),0,$0-2 // ERROR \"arg4: wrong argument size 2; expected \\$\\.\\.\\.-8\"\n-\tMOVB\tx+0(FP), R1 // ERROR \"invalid MOVB of x\\+0\\(FP\\); int32 is 4-byte value\"\n-\tMOVB\ty+4(FP), R2 // ERROR \"invalid MOVB of y\\+4\\(FP\\); uint32 is 4-byte value\"\n-\tMOVH\tx+0(FP), R1 // ERROR \"invalid MOVH of x\\+0\\(FP\\); int32 is 4-byte value\"\n-\tMOVH\ty+4(FP), R1 // ERROR \"invalid MOVH of y\\+4\\(FP\\); uint32 is 4-byte value\"\n-\tMOVW\tx+0(FP), R1\n-\tMOVW\ty+4(FP), R1\n-\tMOVW\tx+4(FP), R1 // ERROR \"invalid offset x\\+4\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tMOVW\ty+2(FP), R1 // ERROR \"invalid offset y\\+2\\(FP\\); expected y\\+4\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7arg8(SB),7,$0-2 // ERROR \"wrong argument size 2; expected \\$\\.\\.\\.-16\"\n-\tMOVB\tx+0(FP), R1 // ERROR \"invalid MOVB of x\\+0\\(FP\\); int64 is 8-byte value\"\n-\tMOVB\ty+8(FP), R2 // ERROR \"invalid MOVB of y\\+8\\(FP\\); uint64 is 8-byte value\"\n-\tMOVH\tx+0(FP), R1 // ERROR \"invalid MOVH of x\\+0\\(FP\\); int64 is 8-byte value\"\n-\tMOVH\ty+8(FP), R1 // ERROR \"invalid MOVH of y\\+8\\(FP\\); uint64 is 8-byte value\"\n-\tMOVW\tx+0(FP), R1 // ERROR \"invalid MOVW of x\\+0\\(FP\\); int64 is 8-byte value containing x_lo\\+0\\(FP\\) and x_hi\\+4\\(FP\\)\"\n-\tMOVW\tx_lo+0(FP), R1\n-\tMOVW\tx_hi+4(FP), R1\n-\tMOVW\ty+8(FP), R1 // ERROR \"invalid MOVW of y\\+8\\(FP\\); uint64 is 8-byte value containing y_lo\\+8\\(FP\\) and y_hi\\+12\\(FP\\)\"\n-\tMOVW\ty_lo+8(FP),  R1\n-\tMOVW\ty_hi+12(FP), R1\n-\tRET\n-\n-TEXT \u00b7argint(SB),0,$0-2 // ERROR \"wrong argument size 2; expected \\$\\.\\.\\.-8\"\n-\tMOVB\tx+0(FP), R1 // ERROR \"invalid MOVB of x\\+0\\(FP\\); int is 4-byte value\"\n-\tMOVB\ty+4(FP), R2 // ERROR \"invalid MOVB of y\\+4\\(FP\\); uint is 4-byte value\"\n-\tMOVH\tx+0(FP), R1 // ERROR \"invalid MOVH of x\\+0\\(FP\\); int is 4-byte value\"\n-\tMOVH\ty+4(FP), R1 // ERROR \"invalid MOVH of y\\+4\\(FP\\); uint is 4-byte value\"\n-\tMOVW\tx+0(FP), R1\n-\tMOVW\ty+4(FP), R1\n-\tMOVW\tx+4(FP), R1 // ERROR \"invalid offset x\\+4\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tMOVW\ty+2(FP), R1 // ERROR \"invalid offset y\\+2\\(FP\\); expected y\\+4\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7argptr(SB),7,$0-2 // ERROR \"wrong argument size 2; expected \\$\\.\\.\\.-20\"\n-\tMOVB\tx+0(FP), R1 // ERROR \"invalid MOVB of x\\+0\\(FP\\); \\*byte is 4-byte value\"\n-\tMOVB\ty+4(FP), R2 // ERROR \"invalid MOVB of y\\+4\\(FP\\); \\*byte is 4-byte value\"\n-\tMOVH\tx+0(FP), R1 // ERROR \"invalid MOVH of x\\+0\\(FP\\); \\*byte is 4-byte value\"\n-\tMOVH\ty+4(FP), R1 // ERROR \"invalid MOVH of y\\+4\\(FP\\); \\*byte is 4-byte value\"\n-\tMOVW\tx+0(FP), R1\n-\tMOVW\ty+4(FP), R1\n-\tMOVW\tx+4(FP), R1 // ERROR \"invalid offset x\\+4\\(FP\\); expected x\\+0\\(FP\\)\"\n-\tMOVW\ty+2(FP), R1 // ERROR \"invalid offset y\\+2\\(FP\\); expected y\\+4\\(FP\\)\"\n-\tMOVH\tc+8(FP), R1 // ERROR \"invalid MOVH of c\\+8\\(FP\\); chan int is 4-byte value\"\n-\tMOVH\tm+12(FP), R1 // ERROR \"invalid MOVH of m\\+12\\(FP\\); map\\[int\\]int is 4-byte value\"\n-\tMOVH\tf+16(FP), R1 // ERROR \"invalid MOVH of f\\+16\\(FP\\); func\\(\\) is 4-byte value\"\n-\tRET\n-\n-TEXT \u00b7argstring(SB),0,$16 // ERROR \"wrong argument size 0; expected \\$\\.\\.\\.-16\"\n-\tMOVH\tx+0(FP), R1 // ERROR \"invalid MOVH of x\\+0\\(FP\\); string base is 4-byte value\"\n-\tMOVW\tx+0(FP), R1\n-\tMOVH\tx_base+0(FP), R1 // ERROR \"invalid MOVH of x_base\\+0\\(FP\\); string base is 4-byte value\"\n-\tMOVW\tx_base+0(FP), R1\n-\tMOVH\tx_len+0(FP), R1 // ERROR \"invalid offset x_len\\+0\\(FP\\); expected x_len\\+4\\(FP\\)\"\n-\tMOVW\tx_len+0(FP), R1 // ERROR \"invalid offset x_len\\+0\\(FP\\); expected x_len\\+4\\(FP\\)\"\n-\tMOVH\tx_len+4(FP), R1 // ERROR \"invalid MOVH of x_len\\+4\\(FP\\); string len is 4-byte value\"\n-\tMOVW\tx_len+4(FP), R1\n-\tMOVW\ty+0(FP), R1 // ERROR \"invalid offset y\\+0\\(FP\\); expected y\\+8\\(FP\\)\"\n-\tMOVW\ty_len+4(FP), R1 // ERROR \"invalid offset y_len\\+4\\(FP\\); expected y_len\\+12\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7argslice(SB),0,$24 // ERROR \"wrong argument size 0; expected \\$\\.\\.\\.-24\"\n-\tMOVH\tx+0(FP), R1 // ERROR \"invalid MOVH of x\\+0\\(FP\\); slice base is 4-byte value\"\n-\tMOVW\tx+0(FP), R1\n-\tMOVH\tx_base+0(FP), R1 // ERROR \"invalid MOVH of x_base\\+0\\(FP\\); slice base is 4-byte value\"\n-\tMOVW\tx_base+0(FP), R1\n-\tMOVH\tx_len+0(FP), R1 // ERROR \"invalid offset x_len\\+0\\(FP\\); expected x_len\\+4\\(FP\\)\"\n-\tMOVW\tx_len+0(FP), R1 // ERROR \"invalid offset x_len\\+0\\(FP\\); expected x_len\\+4\\(FP\\)\"\n-\tMOVH\tx_len+4(FP), R1 // ERROR \"invalid MOVH of x_len\\+4\\(FP\\); slice len is 4-byte value\"\n-\tMOVW\tx_len+4(FP), R1\n-\tMOVH\tx_cap+0(FP), R1 // ERROR \"invalid offset x_cap\\+0\\(FP\\); expected x_cap\\+8\\(FP\\)\"\n-\tMOVW\tx_cap+0(FP), R1 // ERROR \"invalid offset x_cap\\+0\\(FP\\); expected x_cap\\+8\\(FP\\)\"\n-\tMOVH\tx_cap+8(FP), R1 // ERROR \"invalid MOVH of x_cap\\+8\\(FP\\); slice cap is 4-byte value\"\n-\tMOVW\tx_cap+8(FP), R1\n-\tMOVW\ty+0(FP), R1 // ERROR \"invalid offset y\\+0\\(FP\\); expected y\\+12\\(FP\\)\"\n-\tMOVW\ty_len+4(FP), R1 // ERROR \"invalid offset y_len\\+4\\(FP\\); expected y_len\\+16\\(FP\\)\"\n-\tMOVW\ty_cap+8(FP), R1 // ERROR \"invalid offset y_cap\\+8\\(FP\\); expected y_cap\\+20\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7argiface(SB),0,$0-16\n-\tMOVH\tx+0(FP), R1 // ERROR \"invalid MOVH of x\\+0\\(FP\\); interface type is 4-byte value\"\n-\tMOVW\tx+0(FP), R1\n-\tMOVH\tx_type+0(FP), R1 // ERROR \"invalid MOVH of x_type\\+0\\(FP\\); interface type is 4-byte value\"\n-\tMOVW\tx_type+0(FP), R1\n-\tMOVQ\tx_itable+0(FP), R1 // ERROR \"unknown variable x_itable; offset 0 is x_type\\+0\\(FP\\)\"\n-\tMOVQ\tx_itable+1(FP), R1 // ERROR \"unknown variable x_itable; offset 1 is x_type\\+0\\(FP\\)\"\n-\tMOVH\tx_data+0(FP), R1 // ERROR \"invalid offset x_data\\+0\\(FP\\); expected x_data\\+4\\(FP\\)\"\n-\tMOVW\tx_data+0(FP), R1 // ERROR \"invalid offset x_data\\+0\\(FP\\); expected x_data\\+4\\(FP\\)\"\n-\tMOVQ\tx_data+0(FP), R1 // ERROR \"invalid offset x_data\\+0\\(FP\\); expected x_data\\+4\\(FP\\)\"\n-\tMOVH\tx_data+4(FP), R1 // ERROR \"invalid MOVH of x_data\\+4\\(FP\\); interface data is 4-byte value\"\n-\tMOVW\tx_data+4(FP), R1\n-\tMOVH\ty+8(FP), R1 // ERROR \"invalid MOVH of y\\+8\\(FP\\); interface itable is 4-byte value\"\n-\tMOVW\ty+8(FP), R1\n-\tMOVH\ty_itable+8(FP), R1 // ERROR \"invalid MOVH of y_itable\\+8\\(FP\\); interface itable is 4-byte value\"\n-\tMOVW\ty_itable+8(FP), R1\n-\tMOVW\ty_type+8(FP), AX // ERROR \"unknown variable y_type; offset 8 is y_itable\\+8\\(FP\\)\"\n-\tMOVH\ty_data+8(FP), AX // ERROR \"invalid offset y_data\\+8\\(FP\\); expected y_data\\+12\\(FP\\)\"\n-\tMOVW\ty_data+8(FP), AX // ERROR \"invalid offset y_data\\+8\\(FP\\); expected y_data\\+12\\(FP\\)\"\n-\tMOVH\ty_data+12(FP), AX // ERROR \"invalid MOVH of y_data\\+12\\(FP\\); interface data is 4-byte value\"\n-\tMOVW\ty_data+12(FP), AX\n-\tRET\n-\n-TEXT \u00b7returnbyte(SB),0,$0-5\n-\tMOVW\tx+0(FP), R1\n-\tMOVB\tR1, ret+4(FP)\n-\tMOVH\tR1, ret+4(FP) // ERROR \"invalid MOVH of ret\\+4\\(FP\\); byte is 1-byte value\"\n-\tMOVW\tR1, ret+4(FP) // ERROR \"invalid MOVW of ret\\+4\\(FP\\); byte is 1-byte value\"\n-\tMOVB\tR1, ret+3(FP) // ERROR \"invalid offset ret\\+3\\(FP\\); expected ret\\+4\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7returnbyte(SB),0,$0-5\n-\tMOVW\tx+0(FP), R1\n-\tMOVB\tR1, ret+4(FP)\n-\tMOVH\tR1, ret+4(FP) // ERROR \"invalid MOVH of ret\\+4\\(FP\\); byte is 1-byte value\"\n-\tMOVW\tR1, ret+4(FP) // ERROR \"invalid MOVW of ret\\+4\\(FP\\); byte is 1-byte value\"\n-\tMOVB\tR1, ret+3(FP) // ERROR \"invalid offset ret\\+3\\(FP\\); expected ret\\+4\\(FP\\)\"\n-\tRET\n-\n-TEXT \u00b7returnnamed(SB),0,$0-21\n-\tMOVB\tx+0(FP), AX\n-\tMOVW\tR1, r1+4(FP)\n-\tMOVH\tR1, r2+8(FP)\n-\tMOVW\tR1, r3+12(FP)\n-\tMOVW\tR1, r3_base+12(FP)\n-\tMOVW\tR1, r3_len+16(FP)\n-\tMOVB\tR1, r4+20(FP)\n-\tMOVB\tR1, r1+4(FP) // ERROR \"invalid MOVB of r1\\+4\\(FP\\); int is 4-byte value\"\n-\tRET\n-\n-TEXT \u00b7returnintmissing(SB),0,$0-4\n-\tRET // ERROR \"RET without writing to 4-byte ret\\+0\\(FP\\)\""}, {"sha": "69730b4e6f03fb90c20d013f3e5e5d37871b93c9", "filename": "libgo/go/cmd/vet/testdata/atomic.go", "status": "removed", "additions": 0, "deletions": 62, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fatomic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fatomic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fatomic.go?ref=225220d668dafb8262db7012bced688acbe63b33", "patch": "@@ -1,62 +0,0 @@\n-// Copyright 2013 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// This file contains tests for the atomic checker.\n-\n-package testdata\n-\n-import (\n-\t\"sync/atomic\"\n-)\n-\n-type Counter uint64\n-\n-func AtomicTests() {\n-\tx := uint64(1)\n-\tx = atomic.AddUint64(&x, 1)        // ERROR \"direct assignment to atomic value\"\n-\t_, x = 10, atomic.AddUint64(&x, 1) // ERROR \"direct assignment to atomic value\"\n-\tx, _ = atomic.AddUint64(&x, 1), 10 // ERROR \"direct assignment to atomic value\"\n-\n-\ty := &x\n-\t*y = atomic.AddUint64(y, 1) // ERROR \"direct assignment to atomic value\"\n-\n-\tvar su struct{ Counter uint64 }\n-\tsu.Counter = atomic.AddUint64(&su.Counter, 1) // ERROR \"direct assignment to atomic value\"\n-\tz1 := atomic.AddUint64(&su.Counter, 1)\n-\t_ = z1 // Avoid err \"z declared and not used\"\n-\n-\tvar sp struct{ Counter *uint64 }\n-\t*sp.Counter = atomic.AddUint64(sp.Counter, 1) // ERROR \"direct assignment to atomic value\"\n-\tz2 := atomic.AddUint64(sp.Counter, 1)\n-\t_ = z2 // Avoid err \"z declared and not used\"\n-\n-\tau := []uint64{10, 20}\n-\tau[0] = atomic.AddUint64(&au[0], 1) // ERROR \"direct assignment to atomic value\"\n-\tau[1] = atomic.AddUint64(&au[0], 1)\n-\n-\tap := []*uint64{&au[0], &au[1]}\n-\t*ap[0] = atomic.AddUint64(ap[0], 1) // ERROR \"direct assignment to atomic value\"\n-\t*ap[1] = atomic.AddUint64(ap[0], 1)\n-\n-\tx = atomic.AddUint64() // Used to make vet crash; now silently ignored.\n-\n-\t{\n-\t\t// A variable declaration creates a new variable in the current scope.\n-\t\tx := atomic.AddUint64(&x, 1) // ERROR \"declaration of .x. shadows declaration at atomic.go:16\"\n-\n-\t\t// Re-declaration assigns a new value.\n-\t\tx, w := atomic.AddUint64(&x, 1), 10 // ERROR \"direct assignment to atomic value\"\n-\t\t_ = w\n-\t}\n-}\n-\n-type T struct{}\n-\n-func (T) AddUint64(addr *uint64, delta uint64) uint64 { return 0 }\n-\n-func NonAtomic() {\n-\tx := uint64(1)\n-\tvar atomic T\n-\tx = atomic.AddUint64(&x, 1) // ok; not the imported pkg\n-}"}, {"sha": "80c44d25ca38890e06e1c0933d6fd67007b48868", "filename": "libgo/go/cmd/vet/testdata/bool.go", "status": "removed", "additions": 0, "deletions": 131, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fbool.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fbool.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fbool.go?ref=225220d668dafb8262db7012bced688acbe63b33", "patch": "@@ -1,131 +0,0 @@\n-// Copyright 2014 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// This file contains tests for the bool checker.\n-\n-package testdata\n-\n-import \"io\"\n-\n-type T int\n-\n-func (t T) Foo() int { return int(t) }\n-\n-type FT func() int\n-\n-var S []int\n-\n-func RatherStupidConditions() {\n-\tvar f, g func() int\n-\tif f() == 0 || f() == 0 { // OK f might have side effects\n-\t}\n-\tvar t T\n-\t_ = t.Foo() == 2 || t.Foo() == 2        // OK Foo might have side effects\n-\tif v, w := f(), g(); v == w || v == w { // ERROR \"redundant or: v == w || v == w\"\n-\t}\n-\t_ = f == nil || f == nil // ERROR \"redundant or: f == nil || f == nil\"\n-\n-\t_ = i == byte(1) || i == byte(1) // ERROR \"redundant or: i == byte(1) || i == byte(1)\"\n-\t_ = i == T(2) || i == T(2)       // ERROR \"redundant or: i == T(2) || i == T(2)\"\n-\t_ = FT(f) == nil || FT(f) == nil // ERROR \"redundant or: FT(f) == nil || FT(f) == nil\"\n-\n-\t_ = (func() int)(f) == nil || (func() int)(f) == nil // ERROR \"redundant or: (func() int)(f) == nil || (func() int)(f) == nil\"\n-\t_ = append(S, 3) == nil || append(S, 3) == nil       // OK append has side effects\n-\n-\tvar namedFuncVar FT\n-\t_ = namedFuncVar() == namedFuncVar() // OK still func calls\n-\n-\tvar c chan int\n-\t_ = 0 == <-c || 0 == <-c                                  // OK subsequent receives may yield different values\n-\tfor i, j := <-c, <-c; i == j || i == j; i, j = <-c, <-c { // ERROR \"redundant or: i == j || i == j\"\n-\t}\n-\n-\tvar i, j, k int\n-\t_ = i+1 == 1 || i+1 == 1         // ERROR \"redundant or: i\\+1 == 1 || i\\+1 == 1\"\n-\t_ = i == 1 || j+1 == i || i == 1 // ERROR \"redundant or: i == 1 || i == 1\"\n-\n-\t_ = i == 1 || i == 1 || f() == 1 // ERROR \"redundant or: i == 1 || i == 1\"\n-\t_ = i == 1 || f() == 1 || i == 1 // OK f may alter i as a side effect\n-\t_ = f() == 1 || i == 1 || i == 1 // ERROR \"redundant or: i == 1 || i == 1\"\n-\n-\t// Test partition edge cases\n-\t_ = f() == 1 || i == 1 || i == 1 || j == 1 // ERROR \"redundant or: i == 1 || i == 1\"\n-\t_ = f() == 1 || j == 1 || i == 1 || i == 1 // ERROR \"redundant or: i == 1 || i == 1\"\n-\t_ = i == 1 || f() == 1 || i == 1 || i == 1 // ERROR \"redundant or: i == 1 || i == 1\"\n-\t_ = i == 1 || i == 1 || f() == 1 || i == 1 // ERROR \"redundant or: i == 1 || i == 1\"\n-\t_ = i == 1 || i == 1 || j == 1 || f() == 1 // ERROR \"redundant or: i == 1 || i == 1\"\n-\t_ = j == 1 || i == 1 || i == 1 || f() == 1 // ERROR \"redundant or: i == 1 || i == 1\"\n-\t_ = i == 1 || f() == 1 || f() == 1 || i == 1\n-\n-\t_ = i == 1 || (i == 1 || i == 2)             // ERROR \"redundant or: i == 1 || i == 1\"\n-\t_ = i == 1 || (f() == 1 || i == 1)           // OK f may alter i as a side effect\n-\t_ = i == 1 || (i == 1 || f() == 1)           // ERROR \"redundant or: i == 1 || i == 1\"\n-\t_ = i == 1 || (i == 2 || (i == 1 || i == 3)) // ERROR \"redundant or: i == 1 || i == 1\"\n-\n-\tvar a, b bool\n-\t_ = i == 1 || (a || (i == 1 || b)) // ERROR \"redundant or: i == 1 || i == 1\"\n-\n-\t// Check that all redundant ors are flagged\n-\t_ = j == 0 ||\n-\t\ti == 1 ||\n-\t\tf() == 1 ||\n-\t\tj == 0 || // ERROR \"redundant or: j == 0 || j == 0\"\n-\t\ti == 1 || // ERROR \"redundant or: i == 1 || i == 1\"\n-\t\ti == 1 || // ERROR \"redundant or: i == 1 || i == 1\"\n-\t\ti == 1 ||\n-\t\tj == 0 ||\n-\t\tk == 0\n-\n-\t_ = i == 1*2*3 || i == 1*2*3 // ERROR \"redundant or: i == 1\\*2\\*3 || i == 1\\*2\\*3\"\n-\n-\t// These test that redundant, suspect expressions do not trigger multiple errors.\n-\t_ = i != 0 || i != 0 // ERROR \"redundant or: i != 0 || i != 0\"\n-\t_ = i == 0 && i == 0 // ERROR \"redundant and: i == 0 && i == 0\"\n-\n-\t// and is dual to or; check the basics and\n-\t// let the or tests pull the rest of the weight.\n-\t_ = 0 != <-c && 0 != <-c         // OK subsequent receives may yield different values\n-\t_ = f() != 0 && f() != 0         // OK f might have side effects\n-\t_ = f != nil && f != nil         // ERROR \"redundant and: f != nil && f != nil\"\n-\t_ = i != 1 && i != 1 && f() != 1 // ERROR \"redundant and: i != 1 && i != 1\"\n-\t_ = i != 1 && f() != 1 && i != 1 // OK f may alter i as a side effect\n-\t_ = f() != 1 && i != 1 && i != 1 // ERROR \"redundant and: i != 1 && i != 1\"\n-}\n-\n-func RoyallySuspectConditions() {\n-\tvar i, j int\n-\n-\t_ = i == 0 || i == 1 // OK\n-\t_ = i != 0 || i != 1 // ERROR \"suspect or: i != 0 || i != 1\"\n-\t_ = i != 0 || 1 != i // ERROR \"suspect or: i != 0 || 1 != i\"\n-\t_ = 0 != i || 1 != i // ERROR \"suspect or: 0 != i || 1 != i\"\n-\t_ = 0 != i || i != 1 // ERROR \"suspect or: 0 != i || i != 1\"\n-\n-\t_ = (0 != i) || i != 1 // ERROR \"suspect or: 0 != i || i != 1\"\n-\n-\t_ = i+3 != 7 || j+5 == 0 || i+3 != 9 // ERROR \"suspect or: i\\+3 != 7 || i\\+3 != 9\"\n-\n-\t_ = i != 0 || j == 0 || i != 1 // ERROR \"suspect or: i != 0 || i != 1\"\n-\n-\t_ = i != 0 || i != 1<<4 // ERROR \"suspect or: i != 0 || i != 1<<4\"\n-\n-\t_ = i != 0 || j != 0\n-\t_ = 0 != i || 0 != j\n-\n-\tvar s string\n-\t_ = s != \"one\" || s != \"the other\" // ERROR \"suspect or: s != .one. || s != .the other.\"\n-\n-\t_ = \"et\" != \"alii\" || \"et\" != \"cetera\"         // ERROR \"suspect or: .et. != .alii. || .et. != .cetera.\"\n-\t_ = \"me gustas\" != \"tu\" || \"le gustas\" != \"tu\" // OK we could catch this case, but it's not worth the code\n-\n-\tvar err error\n-\t_ = err != nil || err != io.EOF // TODO catch this case?\n-\n-\t// Sanity check and.\n-\t_ = i != 0 && i != 1 // OK\n-\t_ = i == 0 && i == 1 // ERROR \"suspect and: i == 0 && i == 1\"\n-\t_ = i == 0 && 1 == i // ERROR \"suspect and: i == 0 && 1 == i\"\n-\t_ = 0 == i && 1 == i // ERROR \"suspect and: 0 == i && 1 == i\"\n-\t_ = 0 == i && i == 1 // ERROR \"suspect and: 0 == i && i == 1\"\n-}"}, {"sha": "fbe10cf748f58b1a1291117d4d684b0dc941c782", "filename": "libgo/go/cmd/vet/testdata/buildtag/buildtag_bad.go", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fbuildtag%2Fbuildtag_bad.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fbuildtag%2Fbuildtag_bad.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fbuildtag%2Fbuildtag_bad.go?ref=225220d668dafb8262db7012bced688acbe63b33", "patch": "@@ -1,15 +0,0 @@\n-// This file contains misplaced or malformed build constraints.\n-// The Go tool will skip it, because the constraints are invalid.\n-// It serves only to test the tag checker during make test.\n-\n-// Mention +build // ERROR \"possible malformed \\+build comment\"\n-\n-// +build !!bang // ERROR \"invalid double negative in build constraint\"\n-// +build @#$ // ERROR \"invalid non-alphanumeric build constraint\"\n-\n-// +build toolate // ERROR \"build comment must appear before package clause and be followed by a blank line\"\n-package bad\n-\n-// This is package 'bad' rather than 'main' so the erroneous build\n-// tag doesn't end up looking like a package doc for the vet command\n-// when examined by godoc."}, {"sha": "d0df7cf6787fe00f12054f9fed434a8b8e1edad7", "filename": "libgo/go/cmd/vet/testdata/cgo/cgo.go", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fcgo%2Fcgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fcgo%2Fcgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fcgo%2Fcgo.go?ref=225220d668dafb8262db7012bced688acbe63b33", "patch": "@@ -1,59 +0,0 @@\n-// Copyright 2015 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// This file contains tests for the cgo checker.\n-\n-package testdata\n-\n-// void f(void *);\n-import \"C\"\n-\n-import \"unsafe\"\n-\n-func CgoTests() {\n-\tvar c chan bool\n-\tC.f(*(*unsafe.Pointer)(unsafe.Pointer(&c))) // ERROR \"embedded pointer\"\n-\tC.f(unsafe.Pointer(&c))                     // ERROR \"embedded pointer\"\n-\n-\tvar m map[string]string\n-\tC.f(*(*unsafe.Pointer)(unsafe.Pointer(&m))) // ERROR \"embedded pointer\"\n-\tC.f(unsafe.Pointer(&m))                     // ERROR \"embedded pointer\"\n-\n-\tvar f func()\n-\tC.f(*(*unsafe.Pointer)(unsafe.Pointer(&f))) // ERROR \"embedded pointer\"\n-\tC.f(unsafe.Pointer(&f))                     // ERROR \"embedded pointer\"\n-\n-\tvar s []int\n-\tC.f(*(*unsafe.Pointer)(unsafe.Pointer(&s))) // ERROR \"embedded pointer\"\n-\tC.f(unsafe.Pointer(&s))                     // ERROR \"embedded pointer\"\n-\n-\tvar a [1][]int\n-\tC.f(*(*unsafe.Pointer)(unsafe.Pointer(&a))) // ERROR \"embedded pointer\"\n-\tC.f(unsafe.Pointer(&a))                     // ERROR \"embedded pointer\"\n-\n-\tvar st struct{ f []int }\n-\tC.f(*(*unsafe.Pointer)(unsafe.Pointer(&st))) // ERROR \"embedded pointer\"\n-\tC.f(unsafe.Pointer(&st))                     // ERROR \"embedded pointer\"\n-\n-\t// The following cases are OK.\n-\tvar i int\n-\tC.f(*(*unsafe.Pointer)(unsafe.Pointer(&i)))\n-\tC.f(unsafe.Pointer(&i))\n-\n-\tC.f(*(*unsafe.Pointer)(unsafe.Pointer(&s[0])))\n-\tC.f(unsafe.Pointer(&s[0]))\n-\n-\tvar a2 [1]int\n-\tC.f(*(*unsafe.Pointer)(unsafe.Pointer(&a2)))\n-\tC.f(unsafe.Pointer(&a2))\n-\n-\tvar st2 struct{ i int }\n-\tC.f(*(*unsafe.Pointer)(unsafe.Pointer(&st2)))\n-\tC.f(unsafe.Pointer(&st2))\n-\n-\ttype cgoStruct struct{ p *cgoStruct }\n-\tC.f(unsafe.Pointer(&cgoStruct{}))\n-\n-\tC.CBytes([]byte(\"hello\"))\n-}"}, {"sha": "4f27116893138361a13a404e7cada585f4e13426", "filename": "libgo/go/cmd/vet/testdata/cgo/cgo2.go", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fcgo%2Fcgo2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fcgo%2Fcgo2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fcgo%2Fcgo2.go?ref=225220d668dafb8262db7012bced688acbe63b33", "patch": "@@ -1,12 +0,0 @@\n-// Copyright 2016 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Test the cgo checker on a file that doesn't use cgo.\n-\n-package testdata\n-\n-var _ = C.f(*p(**p))\n-\n-// Passing a pointer (via the slice), but C isn't cgo.\n-var _ = C.f([]int{3})"}, {"sha": "67b54506abae1ad4d25282dcbce60eea0e8b1af3", "filename": "libgo/go/cmd/vet/testdata/cgo/cgo4.go", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fcgo%2Fcgo4.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fcgo%2Fcgo4.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fcgo%2Fcgo4.go?ref=225220d668dafb8262db7012bced688acbe63b33", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2017 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Test the cgo checker on a file that doesn't use cgo, but has an\n-// import named \"C\".\n-\n-package testdata\n-\n-import C \"fmt\"\n-\n-var _ = C.Println(*p(**p))\n-\n-// Passing a pointer (via a slice), but C is fmt, not cgo.\n-var _ = C.Println([]int{3})"}, {"sha": "3fe3eac78cb38a7ccf32d2f76f57c964d1bee8e0", "filename": "libgo/go/cmd/vet/testdata/composite.go", "status": "removed", "additions": 0, "deletions": 120, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fcomposite.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fcomposite.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fcomposite.go?ref=225220d668dafb8262db7012bced688acbe63b33", "patch": "@@ -1,120 +0,0 @@\n-// Copyright 2012 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// This file contains the test for untagged struct literals.\n-\n-package testdata\n-\n-import (\n-\t\"flag\"\n-\t\"go/scanner\"\n-\t\"image\"\n-\t\"unicode\"\n-\n-\t\"path/to/unknownpkg\"\n-)\n-\n-var Okay1 = []string{\n-\t\"Name\",\n-\t\"Usage\",\n-\t\"DefValue\",\n-}\n-\n-var Okay2 = map[string]bool{\n-\t\"Name\":     true,\n-\t\"Usage\":    true,\n-\t\"DefValue\": true,\n-}\n-\n-var Okay3 = struct {\n-\tX string\n-\tY string\n-\tZ string\n-}{\n-\t\"Name\",\n-\t\"Usage\",\n-\t\"DefValue\",\n-}\n-\n-var Okay4 = []struct {\n-\tA int\n-\tB int\n-}{\n-\t{1, 2},\n-\t{3, 4},\n-}\n-\n-type MyStruct struct {\n-\tX string\n-\tY string\n-\tZ string\n-}\n-\n-var Okay5 = &MyStruct{\n-\t\"Name\",\n-\t\"Usage\",\n-\t\"DefValue\",\n-}\n-\n-var Okay6 = []MyStruct{\n-\t{\"foo\", \"bar\", \"baz\"},\n-\t{\"aa\", \"bb\", \"cc\"},\n-}\n-\n-var Okay7 = []*MyStruct{\n-\t{\"foo\", \"bar\", \"baz\"},\n-\t{\"aa\", \"bb\", \"cc\"},\n-}\n-\n-// Testing is awkward because we need to reference things from a separate package\n-// to trigger the warnings.\n-\n-var goodStructLiteral = flag.Flag{\n-\tName:  \"Name\",\n-\tUsage: \"Usage\",\n-}\n-var badStructLiteral = flag.Flag{ // ERROR \"unkeyed fields\"\n-\t\"Name\",\n-\t\"Usage\",\n-\tnil, // Value\n-\t\"DefValue\",\n-}\n-\n-// SpecialCase is a named slice of CaseRange to test issue 9171.\n-var goodNamedSliceLiteral = unicode.SpecialCase{\n-\t{Lo: 1, Hi: 2},\n-\tunicode.CaseRange{Lo: 1, Hi: 2},\n-}\n-var badNamedSliceLiteral = unicode.SpecialCase{\n-\t{1, 2},                  // ERROR \"unkeyed fields\"\n-\tunicode.CaseRange{1, 2}, // ERROR \"unkeyed fields\"\n-}\n-\n-// ErrorList is a named slice, so no warnings should be emitted.\n-var goodScannerErrorList = scanner.ErrorList{\n-\t&scanner.Error{Msg: \"foobar\"},\n-}\n-var badScannerErrorList = scanner.ErrorList{\n-\t&scanner.Error{\"foobar\"}, // ERROR \"unkeyed fields\"\n-}\n-\n-// Check whitelisted structs: if vet is run with --compositewhitelist=false,\n-// this line triggers an error.\n-var whitelistedPoint = image.Point{1, 2}\n-\n-// Do not check type from unknown package.\n-// See issue 15408.\n-var unknownPkgVar = unknownpkg.Foobar{\"foo\", \"bar\"}\n-\n-// A named pointer slice of CaseRange to test issue 23539. In\n-// particular, we're interested in how some slice elements omit their\n-// type.\n-var goodNamedPointerSliceLiteral = []*unicode.CaseRange{\n-\t{Lo: 1, Hi: 2},\n-\t&unicode.CaseRange{Lo: 1, Hi: 2},\n-}\n-var badNamedPointerSliceLiteral = []*unicode.CaseRange{\n-\t{1, 2},                   // ERROR \"unkeyed fields\"\n-\t&unicode.CaseRange{1, 2}, // ERROR \"unkeyed fields\"\n-}"}, {"sha": "e9902a27f10dd204a77138beb28aabdbefc946f3", "filename": "libgo/go/cmd/vet/testdata/copylock.go", "status": "removed", "additions": 0, "deletions": 188, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fcopylock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fcopylock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fcopylock.go?ref=225220d668dafb8262db7012bced688acbe63b33", "patch": "@@ -1,188 +0,0 @@\n-package testdata\n-\n-import (\n-\t\"sync\"\n-\t\"sync/atomic\"\n-\t\"unsafe\"\n-\t. \"unsafe\"\n-\tunsafe1 \"unsafe\"\n-)\n-\n-func OkFunc() {\n-\tvar x *sync.Mutex\n-\tp := x\n-\tvar y sync.Mutex\n-\tp = &y\n-\n-\tvar z = sync.Mutex{}\n-\tw := sync.Mutex{}\n-\n-\tw = sync.Mutex{}\n-\tq := struct{ L sync.Mutex }{\n-\t\tL: sync.Mutex{},\n-\t}\n-\n-\tyy := []Tlock{\n-\t\tTlock{},\n-\t\tTlock{\n-\t\t\tonce: sync.Once{},\n-\t\t},\n-\t}\n-\n-\tnl := new(sync.Mutex)\n-\tmx := make([]sync.Mutex, 10)\n-\txx := struct{ L *sync.Mutex }{\n-\t\tL: new(sync.Mutex),\n-\t}\n-}\n-\n-type Tlock struct {\n-\tonce sync.Once\n-}\n-\n-func BadFunc() {\n-\tvar x *sync.Mutex\n-\tp := x\n-\tvar y sync.Mutex\n-\tp = &y\n-\t*p = *x // ERROR \"assignment copies lock value to \\*p: sync.Mutex\"\n-\n-\tvar t Tlock\n-\tvar tp *Tlock\n-\ttp = &t\n-\t*tp = t // ERROR \"assignment copies lock value to \\*tp: testdata.Tlock contains sync.Once contains sync.Mutex\"\n-\tt = *tp // ERROR \"assignment copies lock value to t: testdata.Tlock contains sync.Once contains sync.Mutex\"\n-\n-\ty := *x   // ERROR \"assignment copies lock value to y: sync.Mutex\"\n-\tvar z = t // ERROR \"variable declaration copies lock value to z: testdata.Tlock contains sync.Once contains sync.Mutex\"\n-\n-\tw := struct{ L sync.Mutex }{\n-\t\tL: *x, // ERROR \"literal copies lock value from \\*x: sync.Mutex\"\n-\t}\n-\tvar q = map[int]Tlock{\n-\t\t1: t,   // ERROR \"literal copies lock value from t: testdata.Tlock contains sync.Once contains sync.Mutex\"\n-\t\t2: *tp, // ERROR \"literal copies lock value from \\*tp: testdata.Tlock contains sync.Once contains sync.Mutex\"\n-\t}\n-\tyy := []Tlock{\n-\t\tt,   // ERROR \"literal copies lock value from t: testdata.Tlock contains sync.Once contains sync.Mutex\"\n-\t\t*tp, // ERROR \"literal copies lock value from \\*tp: testdata.Tlock contains sync.Once contains sync.Mutex\"\n-\t}\n-\n-\t// override 'new' keyword\n-\tnew := func(interface{}) {}\n-\tnew(t) // ERROR \"call of new copies lock value: testdata.Tlock contains sync.Once contains sync.Mutex\"\n-\n-\t// copy of array of locks\n-\tvar muA [5]sync.Mutex\n-\tmuB := muA        // ERROR \"assignment copies lock value to muB: sync.Mutex\"\n-\tmuA = muB         // ERROR \"assignment copies lock value to muA: sync.Mutex\"\n-\tmuSlice := muA[:] // OK\n-\n-\t// multidimensional array\n-\tvar mmuA [5][5]sync.Mutex\n-\tmmuB := mmuA        // ERROR \"assignment copies lock value to mmuB: sync.Mutex\"\n-\tmmuA = mmuB         // ERROR \"assignment copies lock value to mmuA: sync.Mutex\"\n-\tmmuSlice := mmuA[:] // OK\n-\n-\t// slice copy is ok\n-\tvar fmuA [5][][5]sync.Mutex\n-\tfmuB := fmuA        // OK\n-\tfmuA = fmuB         // OK\n-\tfmuSlice := fmuA[:] // OK\n-}\n-\n-func LenAndCapOnLockArrays() {\n-\tvar a [5]sync.Mutex\n-\taLen := len(a) // OK\n-\taCap := cap(a) // OK\n-\n-\t// override 'len' and 'cap' keywords\n-\n-\tlen := func(interface{}) {}\n-\tlen(a) // ERROR \"call of len copies lock value: sync.Mutex\"\n-\n-\tcap := func(interface{}) {}\n-\tcap(a) // ERROR \"call of cap copies lock value: sync.Mutex\"\n-}\n-\n-func SizeofMutex() {\n-\tvar mu sync.Mutex\n-\tunsafe.Sizeof(mu)  // OK\n-\tunsafe1.Sizeof(mu) // OK\n-\tSizeof(mu)         // OK\n-\tunsafe := struct{ Sizeof func(interface{}) }{}\n-\tunsafe.Sizeof(mu) // ERROR \"call of unsafe.Sizeof copies lock value: sync.Mutex\"\n-\tSizeof := func(interface{}) {}\n-\tSizeof(mu) // ERROR \"call of Sizeof copies lock value: sync.Mutex\"\n-}\n-\n-// SyncTypesCheck checks copying of sync.* types except sync.Mutex\n-func SyncTypesCheck() {\n-\t// sync.RWMutex copying\n-\tvar rwmuX sync.RWMutex\n-\tvar rwmuXX = sync.RWMutex{}\n-\trwmuX1 := new(sync.RWMutex)\n-\trwmuY := rwmuX     // ERROR \"assignment copies lock value to rwmuY: sync.RWMutex\"\n-\trwmuY = rwmuX      // ERROR \"assignment copies lock value to rwmuY: sync.RWMutex\"\n-\tvar rwmuYY = rwmuX // ERROR \"variable declaration copies lock value to rwmuYY: sync.RWMutex\"\n-\trwmuP := &rwmuX\n-\trwmuZ := &sync.RWMutex{}\n-\n-\t// sync.Cond copying\n-\tvar condX sync.Cond\n-\tvar condXX = sync.Cond{}\n-\tcondX1 := new(sync.Cond)\n-\tcondY := condX     // ERROR \"assignment copies lock value to condY: sync.Cond contains sync.noCopy\"\n-\tcondY = condX      // ERROR \"assignment copies lock value to condY: sync.Cond contains sync.noCopy\"\n-\tvar condYY = condX // ERROR \"variable declaration copies lock value to condYY: sync.Cond contains sync.noCopy\"\n-\tcondP := &condX\n-\tcondZ := &sync.Cond{\n-\t\tL: &sync.Mutex{},\n-\t}\n-\tcondZ = sync.NewCond(&sync.Mutex{})\n-\n-\t// sync.WaitGroup copying\n-\tvar wgX sync.WaitGroup\n-\tvar wgXX = sync.WaitGroup{}\n-\twgX1 := new(sync.WaitGroup)\n-\twgY := wgX     // ERROR \"assignment copies lock value to wgY: sync.WaitGroup contains sync.noCopy\"\n-\twgY = wgX      // ERROR \"assignment copies lock value to wgY: sync.WaitGroup contains sync.noCopy\"\n-\tvar wgYY = wgX // ERROR \"variable declaration copies lock value to wgYY: sync.WaitGroup contains sync.noCopy\"\n-\twgP := &wgX\n-\twgZ := &sync.WaitGroup{}\n-\n-\t// sync.Pool copying\n-\tvar poolX sync.Pool\n-\tvar poolXX = sync.Pool{}\n-\tpoolX1 := new(sync.Pool)\n-\tpoolY := poolX     // ERROR \"assignment copies lock value to poolY: sync.Pool contains sync.noCopy\"\n-\tpoolY = poolX      // ERROR \"assignment copies lock value to poolY: sync.Pool contains sync.noCopy\"\n-\tvar poolYY = poolX // ERROR \"variable declaration copies lock value to poolYY: sync.Pool contains sync.noCopy\"\n-\tpoolP := &poolX\n-\tpoolZ := &sync.Pool{}\n-\n-\t// sync.Once copying\n-\tvar onceX sync.Once\n-\tvar onceXX = sync.Once{}\n-\tonceX1 := new(sync.Once)\n-\tonceY := onceX     // ERROR \"assignment copies lock value to onceY: sync.Once contains sync.Mutex\"\n-\tonceY = onceX      // ERROR \"assignment copies lock value to onceY: sync.Once contains sync.Mutex\"\n-\tvar onceYY = onceX // ERROR \"variable declaration copies lock value to onceYY: sync.Once contains sync.Mutex\"\n-\tonceP := &onceX\n-\tonceZ := &sync.Once{}\n-}\n-\n-// AtomicTypesCheck checks copying of sync/atomic types\n-func AtomicTypesCheck() {\n-\t// atomic.Value copying\n-\tvar vX atomic.Value\n-\tvar vXX = atomic.Value{}\n-\tvX1 := new(atomic.Value)\n-\t// These are OK because the value has not been used yet.\n-\t// (And vet can't tell whether it has been used, so they're always OK.)\n-\tvY := vX\n-\tvY = vX\n-\tvar vYY = vX\n-\tvP := &vX\n-\tvZ := &atomic.Value{}\n-}"}, {"sha": "280747a3bf46d3b54539a4c0af140f919674e3d7", "filename": "libgo/go/cmd/vet/testdata/copylock_func.go", "status": "removed", "additions": 0, "deletions": 136, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fcopylock_func.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fcopylock_func.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fcopylock_func.go?ref=225220d668dafb8262db7012bced688acbe63b33", "patch": "@@ -1,136 +0,0 @@\n-// Copyright 2013 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// This file contains tests for the copylock checker's\n-// function declaration analysis.\n-\n-package testdata\n-\n-import \"sync\"\n-\n-func OkFunc(*sync.Mutex) {}\n-func BadFunc(sync.Mutex) {} // ERROR \"BadFunc passes lock by value: sync.Mutex\"\n-func BadFunc2(sync.Map)  {} // ERROR \"BadFunc2 passes lock by value: sync.Map contains sync.Mutex\"\n-func OkRet() *sync.Mutex {}\n-func BadRet() sync.Mutex {} // Don't warn about results\n-\n-var (\n-\tOkClosure   = func(*sync.Mutex) {}\n-\tBadClosure  = func(sync.Mutex) {} // ERROR \"func passes lock by value: sync.Mutex\"\n-\tBadClosure2 = func(sync.Map) {}   // ERROR \"func passes lock by value: sync.Map contains sync.Mutex\"\n-)\n-\n-type EmbeddedRWMutex struct {\n-\tsync.RWMutex\n-}\n-\n-func (*EmbeddedRWMutex) OkMeth() {}\n-func (EmbeddedRWMutex) BadMeth() {} // ERROR \"BadMeth passes lock by value: testdata.EmbeddedRWMutex\"\n-func OkFunc(e *EmbeddedRWMutex)  {}\n-func BadFunc(EmbeddedRWMutex)    {} // ERROR \"BadFunc passes lock by value: testdata.EmbeddedRWMutex\"\n-func OkRet() *EmbeddedRWMutex    {}\n-func BadRet() EmbeddedRWMutex    {} // Don't warn about results\n-\n-type FieldMutex struct {\n-\ts sync.Mutex\n-}\n-\n-func (*FieldMutex) OkMeth()   {}\n-func (FieldMutex) BadMeth()   {} // ERROR \"BadMeth passes lock by value: testdata.FieldMutex contains sync.Mutex\"\n-func OkFunc(*FieldMutex)      {}\n-func BadFunc(FieldMutex, int) {} // ERROR \"BadFunc passes lock by value: testdata.FieldMutex contains sync.Mutex\"\n-\n-type L0 struct {\n-\tL1\n-}\n-\n-type L1 struct {\n-\tl L2\n-}\n-\n-type L2 struct {\n-\tsync.Mutex\n-}\n-\n-func (*L0) Ok() {}\n-func (L0) Bad() {} // ERROR \"Bad passes lock by value: testdata.L0 contains testdata.L1 contains testdata.L2\"\n-\n-type EmbeddedMutexPointer struct {\n-\ts *sync.Mutex // safe to copy this pointer\n-}\n-\n-func (*EmbeddedMutexPointer) Ok()      {}\n-func (EmbeddedMutexPointer) AlsoOk()   {}\n-func StillOk(EmbeddedMutexPointer)     {}\n-func LookinGood() EmbeddedMutexPointer {}\n-\n-type EmbeddedLocker struct {\n-\tsync.Locker // safe to copy interface values\n-}\n-\n-func (*EmbeddedLocker) Ok()    {}\n-func (EmbeddedLocker) AlsoOk() {}\n-\n-type CustomLock struct{}\n-\n-func (*CustomLock) Lock()   {}\n-func (*CustomLock) Unlock() {}\n-\n-func Ok(*CustomLock) {}\n-func Bad(CustomLock) {} // ERROR \"Bad passes lock by value: testdata.CustomLock\"\n-\n-// Passing lock values into interface function arguments\n-func FuncCallInterfaceArg(f func(a int, b interface{})) {\n-\tvar m sync.Mutex\n-\tvar t struct{ lock sync.Mutex }\n-\n-\tf(1, \"foo\")\n-\tf(2, &t)\n-\tf(3, &sync.Mutex{})\n-\tf(4, m) // ERROR \"call of f copies lock value: sync.Mutex\"\n-\tf(5, t) // ERROR \"call of f copies lock value: struct.lock sync.Mutex. contains sync.Mutex\"\n-\tvar fntab []func(t)\n-\tfntab[0](t) // ERROR \"call of fntab.0. copies lock value: struct.lock sync.Mutex. contains sync.Mutex\"\n-}\n-\n-// Returning lock via interface value\n-func ReturnViaInterface(x int) (int, interface{}) {\n-\tvar m sync.Mutex\n-\tvar t struct{ lock sync.Mutex }\n-\n-\tswitch x % 4 {\n-\tcase 0:\n-\t\treturn 0, \"qwe\"\n-\tcase 1:\n-\t\treturn 1, &sync.Mutex{}\n-\tcase 2:\n-\t\treturn 2, m // ERROR \"return copies lock value: sync.Mutex\"\n-\tdefault:\n-\t\treturn 3, t // ERROR \"return copies lock value: struct.lock sync.Mutex. contains sync.Mutex\"\n-\t}\n-}\n-\n-// Some cases that we don't warn about.\n-\n-func AcceptedCases() {\n-\tx := EmbeddedRwMutex{} // composite literal on RHS is OK (#16227)\n-\tx = BadRet()           // function call on RHS is OK (#16227)\n-\tx = *OKRet()           // indirection of function call on RHS is OK (#16227)\n-}\n-\n-// TODO: Unfortunate cases\n-\n-// Non-ideal error message:\n-// Since we're looking for Lock methods, sync.Once's underlying\n-// sync.Mutex gets called out, but without any reference to the sync.Once.\n-type LocalOnce sync.Once\n-\n-func (LocalOnce) Bad() {} // ERROR \"Bad passes lock by value: testdata.LocalOnce contains sync.Mutex\"\n-\n-// False negative:\n-// LocalMutex doesn't have a Lock method.\n-// Nevertheless, it is probably a bad idea to pass it by value.\n-type LocalMutex sync.Mutex\n-\n-func (LocalMutex) Bad() {} // WANTED: An error here :("}, {"sha": "f127381213cd7571e4d5ed350f615420be7279ad", "filename": "libgo/go/cmd/vet/testdata/copylock_range.go", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fcopylock_range.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fcopylock_range.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fcopylock_range.go?ref=225220d668dafb8262db7012bced688acbe63b33", "patch": "@@ -1,67 +0,0 @@\n-// Copyright 2014 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// This file contains tests for the copylock checker's\n-// range statement analysis.\n-\n-package testdata\n-\n-import \"sync\"\n-\n-func rangeMutex() {\n-\tvar mu sync.Mutex\n-\tvar i int\n-\n-\tvar s []sync.Mutex\n-\tfor range s {\n-\t}\n-\tfor i = range s {\n-\t}\n-\tfor i := range s {\n-\t}\n-\tfor i, _ = range s {\n-\t}\n-\tfor i, _ := range s {\n-\t}\n-\tfor _, mu = range s { // ERROR \"range var mu copies lock: sync.Mutex\"\n-\t}\n-\tfor _, m := range s { // ERROR \"range var m copies lock: sync.Mutex\"\n-\t}\n-\tfor i, mu = range s { // ERROR \"range var mu copies lock: sync.Mutex\"\n-\t}\n-\tfor i, m := range s { // ERROR \"range var m copies lock: sync.Mutex\"\n-\t}\n-\n-\tvar a [3]sync.Mutex\n-\tfor _, m := range a { // ERROR \"range var m copies lock: sync.Mutex\"\n-\t}\n-\n-\tvar m map[sync.Mutex]sync.Mutex\n-\tfor k := range m { // ERROR \"range var k copies lock: sync.Mutex\"\n-\t}\n-\tfor mu, _ = range m { // ERROR \"range var mu copies lock: sync.Mutex\"\n-\t}\n-\tfor k, _ := range m { // ERROR \"range var k copies lock: sync.Mutex\"\n-\t}\n-\tfor _, mu = range m { // ERROR \"range var mu copies lock: sync.Mutex\"\n-\t}\n-\tfor _, v := range m { // ERROR \"range var v copies lock: sync.Mutex\"\n-\t}\n-\n-\tvar c chan sync.Mutex\n-\tfor range c {\n-\t}\n-\tfor mu = range c { // ERROR \"range var mu copies lock: sync.Mutex\"\n-\t}\n-\tfor v := range c { // ERROR \"range var v copies lock: sync.Mutex\"\n-\t}\n-\n-\t// Test non-idents in range variables\n-\tvar t struct {\n-\t\ti  int\n-\t\tmu sync.Mutex\n-\t}\n-\tfor t.i, t.mu = range s { // ERROR \"range var t.mu copies lock: sync.Mutex\"\n-\t}\n-}"}, {"sha": "d1a7adee38d2c9c30dc93f9e67bbd2b2049e9693", "filename": "libgo/go/cmd/vet/testdata/deadcode.go", "status": "removed", "additions": 0, "deletions": 2134, "changes": 2134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fdeadcode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fdeadcode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fdeadcode.go?ref=225220d668dafb8262db7012bced688acbe63b33", "patch": "@@ -1,2134 +0,0 @@\n-// Copyright 2013 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build ignore\n-\n-// This file contains tests for the dead code checker.\n-\n-package testdata\n-\n-type T int\n-\n-var x interface{}\n-var c chan int\n-\n-func external() int // ok\n-\n-func _() int {\n-}\n-\n-func _() int {\n-\tprint(1)\n-}\n-\n-func _() int {\n-\tprint(1)\n-\treturn 2\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-func _() int {\n-L:\n-\tprint(1)\n-\tgoto L\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-func _() int {\n-\tprint(1)\n-\tpanic(2)\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-// but only builtin panic\n-func _() int {\n-\tvar panic = func(int) {}\n-\tprint(1)\n-\tpanic(2)\n-\tprintln() // ok\n-}\n-\n-func _() int {\n-\t{\n-\t\tprint(1)\n-\t\treturn 2\n-\t\tprintln() // ERROR \"unreachable code\"\n-\t}\n-\tprintln() // ok\n-}\n-\n-func _() int {\n-\t{\n-\t\tprint(1)\n-\t\treturn 2\n-\t}\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-func _() int {\n-L:\n-\t{\n-\t\tprint(1)\n-\t\tgoto L\n-\t\tprintln() // ERROR \"unreachable code\"\n-\t}\n-\tprintln() // ok\n-}\n-\n-func _() int {\n-L:\n-\t{\n-\t\tprint(1)\n-\t\tgoto L\n-\t}\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-func _() int {\n-\tprint(1)\n-\t{\n-\t\tpanic(2)\n-\t}\n-}\n-\n-func _() int {\n-\tprint(1)\n-\t{\n-\t\tpanic(2)\n-\t\tprintln() // ERROR \"unreachable code\"\n-\t}\n-}\n-\n-func _() int {\n-\tprint(1)\n-\t{\n-\t\tpanic(2)\n-\t}\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-func _() int {\n-\tprint(1)\n-\treturn 2\n-\t{ // ERROR \"unreachable code\"\n-\t}\n-}\n-\n-func _() int {\n-L:\n-\tprint(1)\n-\tgoto L\n-\t{ // ERROR \"unreachable code\"\n-\t}\n-}\n-\n-func _() int {\n-\tprint(1)\n-\tpanic(2)\n-\t{ // ERROR \"unreachable code\"\n-\t}\n-}\n-\n-func _() int {\n-\t{\n-\t\tprint(1)\n-\t\treturn 2\n-\t\t{ // ERROR \"unreachable code\"\n-\t\t}\n-\t}\n-}\n-\n-func _() int {\n-L:\n-\t{\n-\t\tprint(1)\n-\t\tgoto L\n-\t\t{ // ERROR \"unreachable code\"\n-\t\t}\n-\t}\n-}\n-\n-func _() int {\n-\tprint(1)\n-\t{\n-\t\tpanic(2)\n-\t\t{ // ERROR \"unreachable code\"\n-\t\t}\n-\t}\n-}\n-\n-func _() int {\n-\t{\n-\t\tprint(1)\n-\t\treturn 2\n-\t}\n-\t{ // ERROR \"unreachable code\"\n-\t}\n-}\n-\n-func _() int {\n-L:\n-\t{\n-\t\tprint(1)\n-\t\tgoto L\n-\t}\n-\t{ // ERROR \"unreachable code\"\n-\t}\n-}\n-\n-func _() int {\n-\tprint(1)\n-\t{\n-\t\tpanic(2)\n-\t}\n-\t{ // ERROR \"unreachable code\"\n-\t}\n-}\n-\n-func _() int {\n-\tprint(1)\n-\tif x == nil {\n-\t\tpanic(2)\n-\t} else {\n-\t\tpanic(3)\n-\t}\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-func _() int {\n-L:\n-\tprint(1)\n-\tif x == nil {\n-\t\tpanic(2)\n-\t} else {\n-\t\tgoto L\n-\t}\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-func _() int {\n-L:\n-\tprint(1)\n-\tif x == nil {\n-\t\tpanic(2)\n-\t} else if x == 1 {\n-\t\treturn 0\n-\t} else if x != 2 {\n-\t\tpanic(3)\n-\t} else {\n-\t\tgoto L\n-\t}\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-// if-else chain missing final else is not okay, even if the\n-// conditions cover every possible case.\n-\n-func _() int {\n-\tprint(1)\n-\tif x == nil {\n-\t\tpanic(2)\n-\t} else if x != nil {\n-\t\tpanic(3)\n-\t}\n-\tprintln() // ok\n-}\n-\n-func _() int {\n-\tprint(1)\n-\tif x == nil {\n-\t\tpanic(2)\n-\t}\n-\tprintln() // ok\n-}\n-\n-func _() int {\n-L:\n-\tprint(1)\n-\tif x == nil {\n-\t\tpanic(2)\n-\t} else if x == 1 {\n-\t\treturn 0\n-\t} else if x != 1 {\n-\t\tpanic(3)\n-\t}\n-\tprintln() // ok\n-}\n-\n-func _() int {\n-\tprint(1)\n-\tfor {\n-\t}\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-func _() int {\n-\tfor {\n-\t\tfor {\n-\t\t\tbreak\n-\t\t}\n-\t}\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-func _() int {\n-\tfor {\n-\t\tfor {\n-\t\t\tbreak\n-\t\t\tprintln() // ERROR \"unreachable code\"\n-\t\t}\n-\t}\n-}\n-\n-func _() int {\n-\tfor {\n-\t\tfor {\n-\t\t\tcontinue\n-\t\t\tprintln() // ERROR \"unreachable code\"\n-\t\t}\n-\t}\n-}\n-\n-func _() int {\n-\tfor {\n-\tL:\n-\t\tfor {\n-\t\t\tbreak L\n-\t\t}\n-\t}\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-func _() int {\n-\tprint(1)\n-\tfor {\n-\t\tbreak\n-\t}\n-\tprintln() // ok\n-}\n-\n-func _() int {\n-\tfor {\n-\t\tfor {\n-\t\t}\n-\t\tbreak // ERROR \"unreachable code\"\n-\t}\n-\tprintln() // ok\n-}\n-\n-func _() int {\n-L:\n-\tfor {\n-\t\tfor {\n-\t\t\tbreak L\n-\t\t}\n-\t}\n-\tprintln() // ok\n-}\n-\n-func _() int {\n-\tprint(1)\n-\tfor x == nil {\n-\t}\n-\tprintln() // ok\n-}\n-\n-func _() int {\n-\tfor x == nil {\n-\t\tfor {\n-\t\t\tbreak\n-\t\t}\n-\t}\n-\tprintln() // ok\n-}\n-\n-func _() int {\n-\tfor x == nil {\n-\tL:\n-\t\tfor {\n-\t\t\tbreak L\n-\t\t}\n-\t}\n-\tprintln() // ok\n-}\n-\n-func _() int {\n-\tprint(1)\n-\tfor true {\n-\t}\n-\tprintln() // ok\n-}\n-\n-func _() int {\n-\tfor true {\n-\t\tfor {\n-\t\t\tbreak\n-\t\t}\n-\t}\n-\tprintln() // ok\n-}\n-\n-func _() int {\n-\tfor true {\n-\tL:\n-\t\tfor {\n-\t\t\tbreak L\n-\t\t}\n-\t}\n-\tprintln() // ok\n-}\n-\n-func _() int {\n-\tprint(1)\n-\tselect {}\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-func _() int {\n-\tprint(1)\n-\tselect {\n-\tcase <-c:\n-\t\tprint(2)\n-\t\tpanic(\"abc\")\n-\t\tprintln() // ERROR \"unreachable code\"\n-\t}\n-}\n-\n-func _() int {\n-\tprint(1)\n-\tselect {\n-\tcase <-c:\n-\t\tprint(2)\n-\t\tpanic(\"abc\")\n-\t}\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-func _() int {\n-\tprint(1)\n-\tselect {\n-\tcase <-c:\n-\t\tprint(2)\n-\t\tfor {\n-\t\t}\n-\t\tprintln() // ERROR \"unreachable code\"\n-\t}\n-}\n-\n-func _() int {\n-\tprint(1)\n-\tselect {\n-\tcase <-c:\n-\t\tprint(2)\n-\t\tfor {\n-\t\t}\n-\t}\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-func _() int {\n-L:\n-\tprint(1)\n-\tselect {\n-\tcase <-c:\n-\t\tprint(2)\n-\t\tpanic(\"abc\")\n-\t\tprintln() // ERROR \"unreachable code\"\n-\tcase c <- 1:\n-\t\tprint(2)\n-\t\tgoto L\n-\t\tprintln() // ERROR \"unreachable code\"\n-\t}\n-}\n-\n-func _() int {\n-L:\n-\tprint(1)\n-\tselect {\n-\tcase <-c:\n-\t\tprint(2)\n-\t\tpanic(\"abc\")\n-\tcase c <- 1:\n-\t\tprint(2)\n-\t\tgoto L\n-\t}\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-func _() int {\n-\tprint(1)\n-\tselect {\n-\tcase <-c:\n-\t\tprint(2)\n-\t\tpanic(\"abc\")\n-\t\tprintln() // ERROR \"unreachable code\"\n-\tdefault:\n-\t\tselect {}\n-\t\tprintln() // ERROR \"unreachable code\"\n-\t}\n-}\n-\n-func _() int {\n-\tprint(1)\n-\tselect {\n-\tcase <-c:\n-\t\tprint(2)\n-\t\tpanic(\"abc\")\n-\tdefault:\n-\t\tselect {}\n-\t}\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-func _() int {\n-\tprint(1)\n-\tselect {\n-\tcase <-c:\n-\t\tprint(2)\n-\t}\n-\tprintln() // ok\n-}\n-\n-func _() int {\n-L:\n-\tprint(1)\n-\tselect {\n-\tcase <-c:\n-\t\tprint(2)\n-\t\tpanic(\"abc\")\n-\t\tgoto L // ERROR \"unreachable code\"\n-\tcase c <- 1:\n-\t\tprint(2)\n-\t}\n-\tprintln() // ok\n-}\n-\n-func _() int {\n-\tprint(1)\n-\tselect {\n-\tcase <-c:\n-\t\tprint(2)\n-\t\tpanic(\"abc\")\n-\tdefault:\n-\t\tprint(2)\n-\t}\n-\tprintln() // ok\n-}\n-\n-func _() int {\n-\tprint(1)\n-\tselect {\n-\tdefault:\n-\t\tbreak\n-\t}\n-\tprintln() // ok\n-}\n-\n-func _() int {\n-\tprint(1)\n-\tselect {\n-\tcase <-c:\n-\t\tprint(2)\n-\t\tpanic(\"abc\")\n-\t\tbreak // ERROR \"unreachable code\"\n-\t}\n-\tprintln() // ok\n-}\n-\n-func _() int {\n-\tprint(1)\n-L:\n-\tselect {\n-\tcase <-c:\n-\t\tprint(2)\n-\t\tfor {\n-\t\t\tbreak L\n-\t\t}\n-\t}\n-\tprintln() // ok\n-}\n-\n-func _() int {\n-\tprint(1)\n-L:\n-\tselect {\n-\tcase <-c:\n-\t\tprint(2)\n-\t\tpanic(\"abc\")\n-\tcase c <- 1:\n-\t\tprint(2)\n-\t\tbreak L\n-\t}\n-\tprintln() // ok\n-}\n-\n-func _() int {\n-\tprint(1)\n-\tselect {\n-\tcase <-c:\n-\t\tprint(1)\n-\t\tpanic(\"abc\")\n-\tdefault:\n-\t\tselect {}\n-\t\tbreak // ERROR \"unreachable code\"\n-\t}\n-\tprintln() // ok\n-}\n-\n-func _() int {\n-\tprint(1)\n-\tswitch x {\n-\tcase 1:\n-\t\tprint(2)\n-\t\tpanic(3)\n-\t\tprintln() // ERROR \"unreachable code\"\n-\tdefault:\n-\t\treturn 4\n-\t\tprintln() // ERROR \"unreachable code\"\n-\t}\n-}\n-\n-func _() int {\n-\tprint(1)\n-\tswitch x {\n-\tcase 1:\n-\t\tprint(2)\n-\t\tpanic(3)\n-\tdefault:\n-\t\treturn 4\n-\t}\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-func _() int {\n-\tprint(1)\n-\tswitch x {\n-\tdefault:\n-\t\treturn 4\n-\t\tprintln() // ERROR \"unreachable code\"\n-\tcase 1:\n-\t\tprint(2)\n-\t\tpanic(3)\n-\t\tprintln() // ERROR \"unreachable code\"\n-\t}\n-}\n-\n-func _() int {\n-\tprint(1)\n-\tswitch x {\n-\tdefault:\n-\t\treturn 4\n-\tcase 1:\n-\t\tprint(2)\n-\t\tpanic(3)\n-\t}\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-func _() int {\n-\tprint(1)\n-\tswitch x {\n-\tcase 1:\n-\t\tprint(2)\n-\t\tfallthrough\n-\tdefault:\n-\t\treturn 4\n-\t\tprintln() // ERROR \"unreachable code\"\n-\t}\n-}\n-\n-func _() int {\n-\tprint(1)\n-\tswitch x {\n-\tcase 1:\n-\t\tprint(2)\n-\t\tfallthrough\n-\tdefault:\n-\t\treturn 4\n-\t}\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-func _() int {\n-\tprint(1)\n-\tswitch {\n-\t}\n-\tprintln() // ok\n-}\n-\n-func _() int {\n-\tprint(1)\n-\tswitch x {\n-\tcase 1:\n-\t\tprint(2)\n-\t\tpanic(3)\n-\tcase 2:\n-\t\treturn 4\n-\t}\n-\tprintln() // ok\n-}\n-\n-func _() int {\n-\tprint(1)\n-\tswitch x {\n-\tcase 2:\n-\t\treturn 4\n-\tcase 1:\n-\t\tprint(2)\n-\t\tpanic(3)\n-\t}\n-\tprintln() // ok\n-}\n-\n-func _() int {\n-\tprint(1)\n-\tswitch x {\n-\tcase 1:\n-\t\tprint(2)\n-\t\tfallthrough\n-\tcase 2:\n-\t\treturn 4\n-\t}\n-\tprintln() // ok\n-}\n-\n-func _() int {\n-\tprint(1)\n-\tswitch x {\n-\tcase 1:\n-\t\tprint(2)\n-\t\tpanic(3)\n-\t}\n-\tprintln() // ok\n-}\n-\n-func _() int {\n-\tprint(1)\n-L:\n-\tswitch x {\n-\tcase 1:\n-\t\tprint(2)\n-\t\tpanic(3)\n-\t\tbreak L // ERROR \"unreachable code\"\n-\tdefault:\n-\t\treturn 4\n-\t}\n-\tprintln() // ok\n-}\n-\n-func _() int {\n-\tprint(1)\n-\tswitch x {\n-\tdefault:\n-\t\treturn 4\n-\t\tbreak // ERROR \"unreachable code\"\n-\tcase 1:\n-\t\tprint(2)\n-\t\tpanic(3)\n-\t}\n-\tprintln() // ok\n-}\n-\n-func _() int {\n-\tprint(1)\n-L:\n-\tswitch x {\n-\tcase 1:\n-\t\tprint(2)\n-\t\tfor {\n-\t\t\tbreak L\n-\t\t}\n-\tdefault:\n-\t\treturn 4\n-\t}\n-\tprintln() // ok\n-}\n-\n-func _() int {\n-\tprint(1)\n-\tswitch x.(type) {\n-\tcase int:\n-\t\tprint(2)\n-\t\tpanic(3)\n-\t\tprintln() // ERROR \"unreachable code\"\n-\tdefault:\n-\t\treturn 4\n-\t\tprintln() // ERROR \"unreachable code\"\n-\t}\n-}\n-\n-func _() int {\n-\tprint(1)\n-\tswitch x.(type) {\n-\tcase int:\n-\t\tprint(2)\n-\t\tpanic(3)\n-\tdefault:\n-\t\treturn 4\n-\t}\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-func _() int {\n-\tprint(1)\n-\tswitch x.(type) {\n-\tdefault:\n-\t\treturn 4\n-\t\tprintln() // ERROR \"unreachable code\"\n-\tcase int:\n-\t\tprint(2)\n-\t\tpanic(3)\n-\t\tprintln() // ERROR \"unreachable code\"\n-\t}\n-}\n-\n-func _() int {\n-\tprint(1)\n-\tswitch x.(type) {\n-\tdefault:\n-\t\treturn 4\n-\tcase int:\n-\t\tprint(2)\n-\t\tpanic(3)\n-\t}\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-func _() int {\n-\tprint(1)\n-\tswitch x.(type) {\n-\tcase int:\n-\t\tprint(2)\n-\t\tfallthrough\n-\tdefault:\n-\t\treturn 4\n-\t\tprintln() // ERROR \"unreachable code\"\n-\t}\n-}\n-\n-func _() int {\n-\tprint(1)\n-\tswitch x.(type) {\n-\tcase int:\n-\t\tprint(2)\n-\t\tfallthrough\n-\tdefault:\n-\t\treturn 4\n-\t}\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-func _() int {\n-\tprint(1)\n-\tswitch {\n-\t}\n-\tprintln() // ok\n-}\n-\n-func _() int {\n-\tprint(1)\n-\tswitch x.(type) {\n-\tcase int:\n-\t\tprint(2)\n-\t\tpanic(3)\n-\tcase float64:\n-\t\treturn 4\n-\t}\n-\tprintln() // ok\n-}\n-\n-func _() int {\n-\tprint(1)\n-\tswitch x.(type) {\n-\tcase float64:\n-\t\treturn 4\n-\tcase int:\n-\t\tprint(2)\n-\t\tpanic(3)\n-\t}\n-\tprintln() // ok\n-}\n-\n-func _() int {\n-\tprint(1)\n-\tswitch x.(type) {\n-\tcase int:\n-\t\tprint(2)\n-\t\tfallthrough\n-\tcase float64:\n-\t\treturn 4\n-\t}\n-\tprintln() // ok\n-}\n-\n-func _() int {\n-\tprint(1)\n-\tswitch x.(type) {\n-\tcase int:\n-\t\tprint(2)\n-\t\tpanic(3)\n-\t}\n-\tprintln() // ok\n-}\n-\n-func _() int {\n-\tprint(1)\n-L:\n-\tswitch x.(type) {\n-\tcase int:\n-\t\tprint(2)\n-\t\tpanic(3)\n-\t\tbreak L // ERROR \"unreachable code\"\n-\tdefault:\n-\t\treturn 4\n-\t}\n-\tprintln() // ok\n-}\n-\n-func _() int {\n-\tprint(1)\n-\tswitch x.(type) {\n-\tdefault:\n-\t\treturn 4\n-\t\tbreak // ERROR \"unreachable code\"\n-\tcase int:\n-\t\tprint(2)\n-\t\tpanic(3)\n-\t}\n-\tprintln() // ok\n-}\n-\n-func _() int {\n-\tprint(1)\n-L:\n-\tswitch x.(type) {\n-\tcase int:\n-\t\tprint(2)\n-\t\tfor {\n-\t\t\tbreak L\n-\t\t}\n-\tdefault:\n-\t\treturn 4\n-\t}\n-\tprintln() // ok\n-}\n-\n-// again, but without the leading print(1).\n-// testing that everything works when the terminating statement is first.\n-\n-func _() int {\n-\tprintln() // ok\n-}\n-\n-func _() int {\n-\treturn 2\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-func _() int {\n-L:\n-\tgoto L\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-func _() int {\n-\tpanic(2)\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-// but only builtin panic\n-func _() int {\n-\tvar panic = func(int) {}\n-\tpanic(2)\n-\tprintln() // ok\n-}\n-\n-func _() int {\n-\t{\n-\t\treturn 2\n-\t\tprintln() // ERROR \"unreachable code\"\n-\t}\n-}\n-\n-func _() int {\n-\t{\n-\t\treturn 2\n-\t}\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-func _() int {\n-L:\n-\t{\n-\t\tgoto L\n-\t\tprintln() // ERROR \"unreachable code\"\n-\t}\n-}\n-\n-func _() int {\n-L:\n-\t{\n-\t\tgoto L\n-\t}\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-func _() int {\n-\t{\n-\t\tpanic(2)\n-\t\tprintln() // ERROR \"unreachable code\"\n-\t}\n-}\n-\n-func _() int {\n-\t{\n-\t\tpanic(2)\n-\t}\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-func _() int {\n-\treturn 2\n-\t{ // ERROR \"unreachable code\"\n-\t}\n-\tprintln() // ok\n-}\n-\n-func _() int {\n-L:\n-\tgoto L\n-\t{ // ERROR \"unreachable code\"\n-\t}\n-\tprintln() // ok\n-}\n-\n-func _() int {\n-\tpanic(2)\n-\t{ // ERROR \"unreachable code\"\n-\t}\n-\tprintln() // ok\n-}\n-\n-func _() int {\n-\t{\n-\t\treturn 2\n-\t\t{ // ERROR \"unreachable code\"\n-\t\t}\n-\t}\n-\tprintln() // ok\n-}\n-\n-func _() int {\n-L:\n-\t{\n-\t\tgoto L\n-\t\t{ // ERROR \"unreachable code\"\n-\t\t}\n-\t}\n-\tprintln() // ok\n-}\n-\n-func _() int {\n-\t{\n-\t\tpanic(2)\n-\t\t{ // ERROR \"unreachable code\"\n-\t\t}\n-\t}\n-\tprintln() // ok\n-}\n-\n-func _() int {\n-\t{\n-\t\treturn 2\n-\t}\n-\t{ // ERROR \"unreachable code\"\n-\t}\n-\tprintln() // ok\n-}\n-\n-func _() int {\n-L:\n-\t{\n-\t\tgoto L\n-\t}\n-\t{ // ERROR \"unreachable code\"\n-\t}\n-\tprintln() // ok\n-}\n-\n-func _() int {\n-\t{\n-\t\tpanic(2)\n-\t}\n-\t{ // ERROR \"unreachable code\"\n-\t}\n-\tprintln() // ok\n-}\n-\n-// again, with func literals\n-\n-var _ = func() int {\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\treturn 2\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-var _ = func() int {\n-L:\n-\tprint(1)\n-\tgoto L\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\tpanic(2)\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-// but only builtin panic\n-var _ = func() int {\n-\tvar panic = func(int) {}\n-\tprint(1)\n-\tpanic(2)\n-\tprintln() // ok\n-}\n-\n-var _ = func() int {\n-\t{\n-\t\tprint(1)\n-\t\treturn 2\n-\t\tprintln() // ERROR \"unreachable code\"\n-\t}\n-\tprintln() // ok\n-}\n-\n-var _ = func() int {\n-\t{\n-\t\tprint(1)\n-\t\treturn 2\n-\t}\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-var _ = func() int {\n-L:\n-\t{\n-\t\tprint(1)\n-\t\tgoto L\n-\t\tprintln() // ERROR \"unreachable code\"\n-\t}\n-\tprintln() // ok\n-}\n-\n-var _ = func() int {\n-L:\n-\t{\n-\t\tprint(1)\n-\t\tgoto L\n-\t}\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\t{\n-\t\tpanic(2)\n-\t}\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\t{\n-\t\tpanic(2)\n-\t\tprintln() // ERROR \"unreachable code\"\n-\t}\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\t{\n-\t\tpanic(2)\n-\t}\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\treturn 2\n-\t{ // ERROR \"unreachable code\"\n-\t}\n-}\n-\n-var _ = func() int {\n-L:\n-\tprint(1)\n-\tgoto L\n-\t{ // ERROR \"unreachable code\"\n-\t}\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\tpanic(2)\n-\t{ // ERROR \"unreachable code\"\n-\t}\n-}\n-\n-var _ = func() int {\n-\t{\n-\t\tprint(1)\n-\t\treturn 2\n-\t\t{ // ERROR \"unreachable code\"\n-\t\t}\n-\t}\n-}\n-\n-var _ = func() int {\n-L:\n-\t{\n-\t\tprint(1)\n-\t\tgoto L\n-\t\t{ // ERROR \"unreachable code\"\n-\t\t}\n-\t}\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\t{\n-\t\tpanic(2)\n-\t\t{ // ERROR \"unreachable code\"\n-\t\t}\n-\t}\n-}\n-\n-var _ = func() int {\n-\t{\n-\t\tprint(1)\n-\t\treturn 2\n-\t}\n-\t{ // ERROR \"unreachable code\"\n-\t}\n-}\n-\n-var _ = func() int {\n-L:\n-\t{\n-\t\tprint(1)\n-\t\tgoto L\n-\t}\n-\t{ // ERROR \"unreachable code\"\n-\t}\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\t{\n-\t\tpanic(2)\n-\t}\n-\t{ // ERROR \"unreachable code\"\n-\t}\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\tif x == nil {\n-\t\tpanic(2)\n-\t} else {\n-\t\tpanic(3)\n-\t}\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-var _ = func() int {\n-L:\n-\tprint(1)\n-\tif x == nil {\n-\t\tpanic(2)\n-\t} else {\n-\t\tgoto L\n-\t}\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-var _ = func() int {\n-L:\n-\tprint(1)\n-\tif x == nil {\n-\t\tpanic(2)\n-\t} else if x == 1 {\n-\t\treturn 0\n-\t} else if x != 2 {\n-\t\tpanic(3)\n-\t} else {\n-\t\tgoto L\n-\t}\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-// if-else chain missing final else is not okay, even if the\n-// conditions cover every possible case.\n-\n-var _ = func() int {\n-\tprint(1)\n-\tif x == nil {\n-\t\tpanic(2)\n-\t} else if x != nil {\n-\t\tpanic(3)\n-\t}\n-\tprintln() // ok\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\tif x == nil {\n-\t\tpanic(2)\n-\t}\n-\tprintln() // ok\n-}\n-\n-var _ = func() int {\n-L:\n-\tprint(1)\n-\tif x == nil {\n-\t\tpanic(2)\n-\t} else if x == 1 {\n-\t\treturn 0\n-\t} else if x != 1 {\n-\t\tpanic(3)\n-\t}\n-\tprintln() // ok\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\tfor {\n-\t}\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-var _ = func() int {\n-\tfor {\n-\t\tfor {\n-\t\t\tbreak\n-\t\t}\n-\t}\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-var _ = func() int {\n-\tfor {\n-\t\tfor {\n-\t\t\tbreak\n-\t\t\tprintln() // ERROR \"unreachable code\"\n-\t\t}\n-\t}\n-}\n-\n-var _ = func() int {\n-\tfor {\n-\t\tfor {\n-\t\t\tcontinue\n-\t\t\tprintln() // ERROR \"unreachable code\"\n-\t\t}\n-\t}\n-}\n-\n-var _ = func() int {\n-\tfor {\n-\tL:\n-\t\tfor {\n-\t\t\tbreak L\n-\t\t}\n-\t}\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\tfor {\n-\t\tbreak\n-\t}\n-\tprintln() // ok\n-}\n-\n-var _ = func() int {\n-\tfor {\n-\t\tfor {\n-\t\t}\n-\t\tbreak // ERROR \"unreachable code\"\n-\t}\n-\tprintln() // ok\n-}\n-\n-var _ = func() int {\n-L:\n-\tfor {\n-\t\tfor {\n-\t\t\tbreak L\n-\t\t}\n-\t}\n-\tprintln() // ok\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\tfor x == nil {\n-\t}\n-\tprintln() // ok\n-}\n-\n-var _ = func() int {\n-\tfor x == nil {\n-\t\tfor {\n-\t\t\tbreak\n-\t\t}\n-\t}\n-\tprintln() // ok\n-}\n-\n-var _ = func() int {\n-\tfor x == nil {\n-\tL:\n-\t\tfor {\n-\t\t\tbreak L\n-\t\t}\n-\t}\n-\tprintln() // ok\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\tfor true {\n-\t}\n-\tprintln() // ok\n-}\n-\n-var _ = func() int {\n-\tfor true {\n-\t\tfor {\n-\t\t\tbreak\n-\t\t}\n-\t}\n-\tprintln() // ok\n-}\n-\n-var _ = func() int {\n-\tfor true {\n-\tL:\n-\t\tfor {\n-\t\t\tbreak L\n-\t\t}\n-\t}\n-\tprintln() // ok\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\tselect {}\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\tselect {\n-\tcase <-c:\n-\t\tprint(2)\n-\t\tpanic(\"abc\")\n-\t\tprintln() // ERROR \"unreachable code\"\n-\t}\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\tselect {\n-\tcase <-c:\n-\t\tprint(2)\n-\t\tpanic(\"abc\")\n-\t}\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\tselect {\n-\tcase <-c:\n-\t\tprint(2)\n-\t\tfor {\n-\t\t}\n-\t\tprintln() // ERROR \"unreachable code\"\n-\t}\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\tselect {\n-\tcase <-c:\n-\t\tprint(2)\n-\t\tfor {\n-\t\t}\n-\t}\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-var _ = func() int {\n-L:\n-\tprint(1)\n-\tselect {\n-\tcase <-c:\n-\t\tprint(2)\n-\t\tpanic(\"abc\")\n-\t\tprintln() // ERROR \"unreachable code\"\n-\tcase c <- 1:\n-\t\tprint(2)\n-\t\tgoto L\n-\t\tprintln() // ERROR \"unreachable code\"\n-\t}\n-}\n-\n-var _ = func() int {\n-L:\n-\tprint(1)\n-\tselect {\n-\tcase <-c:\n-\t\tprint(2)\n-\t\tpanic(\"abc\")\n-\tcase c <- 1:\n-\t\tprint(2)\n-\t\tgoto L\n-\t}\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\tselect {\n-\tcase <-c:\n-\t\tprint(2)\n-\t\tpanic(\"abc\")\n-\t\tprintln() // ERROR \"unreachable code\"\n-\tdefault:\n-\t\tselect {}\n-\t\tprintln() // ERROR \"unreachable code\"\n-\t}\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\tselect {\n-\tcase <-c:\n-\t\tprint(2)\n-\t\tpanic(\"abc\")\n-\tdefault:\n-\t\tselect {}\n-\t}\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\tselect {\n-\tcase <-c:\n-\t\tprint(2)\n-\t}\n-\tprintln() // ok\n-}\n-\n-var _ = func() int {\n-L:\n-\tprint(1)\n-\tselect {\n-\tcase <-c:\n-\t\tprint(2)\n-\t\tpanic(\"abc\")\n-\t\tgoto L // ERROR \"unreachable code\"\n-\tcase c <- 1:\n-\t\tprint(2)\n-\t}\n-\tprintln() // ok\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\tselect {\n-\tcase <-c:\n-\t\tprint(2)\n-\t\tpanic(\"abc\")\n-\tdefault:\n-\t\tprint(2)\n-\t}\n-\tprintln() // ok\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\tselect {\n-\tdefault:\n-\t\tbreak\n-\t}\n-\tprintln() // ok\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\tselect {\n-\tcase <-c:\n-\t\tprint(2)\n-\t\tpanic(\"abc\")\n-\t\tbreak // ERROR \"unreachable code\"\n-\t}\n-\tprintln() // ok\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-L:\n-\tselect {\n-\tcase <-c:\n-\t\tprint(2)\n-\t\tfor {\n-\t\t\tbreak L\n-\t\t}\n-\t}\n-\tprintln() // ok\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-L:\n-\tselect {\n-\tcase <-c:\n-\t\tprint(2)\n-\t\tpanic(\"abc\")\n-\tcase c <- 1:\n-\t\tprint(2)\n-\t\tbreak L\n-\t}\n-\tprintln() // ok\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\tselect {\n-\tcase <-c:\n-\t\tprint(1)\n-\t\tpanic(\"abc\")\n-\tdefault:\n-\t\tselect {}\n-\t\tbreak // ERROR \"unreachable code\"\n-\t}\n-\tprintln() // ok\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\tswitch x {\n-\tcase 1:\n-\t\tprint(2)\n-\t\tpanic(3)\n-\t\tprintln() // ERROR \"unreachable code\"\n-\tdefault:\n-\t\treturn 4\n-\t\tprintln() // ERROR \"unreachable code\"\n-\t}\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\tswitch x {\n-\tcase 1:\n-\t\tprint(2)\n-\t\tpanic(3)\n-\tdefault:\n-\t\treturn 4\n-\t}\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\tswitch x {\n-\tdefault:\n-\t\treturn 4\n-\t\tprintln() // ERROR \"unreachable code\"\n-\tcase 1:\n-\t\tprint(2)\n-\t\tpanic(3)\n-\t\tprintln() // ERROR \"unreachable code\"\n-\t}\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\tswitch x {\n-\tdefault:\n-\t\treturn 4\n-\tcase 1:\n-\t\tprint(2)\n-\t\tpanic(3)\n-\t}\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\tswitch x {\n-\tcase 1:\n-\t\tprint(2)\n-\t\tfallthrough\n-\tdefault:\n-\t\treturn 4\n-\t\tprintln() // ERROR \"unreachable code\"\n-\t}\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\tswitch x {\n-\tcase 1:\n-\t\tprint(2)\n-\t\tfallthrough\n-\tdefault:\n-\t\treturn 4\n-\t}\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\tswitch {\n-\t}\n-\tprintln() // ok\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\tswitch x {\n-\tcase 1:\n-\t\tprint(2)\n-\t\tpanic(3)\n-\tcase 2:\n-\t\treturn 4\n-\t}\n-\tprintln() // ok\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\tswitch x {\n-\tcase 2:\n-\t\treturn 4\n-\tcase 1:\n-\t\tprint(2)\n-\t\tpanic(3)\n-\t}\n-\tprintln() // ok\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\tswitch x {\n-\tcase 1:\n-\t\tprint(2)\n-\t\tfallthrough\n-\tcase 2:\n-\t\treturn 4\n-\t}\n-\tprintln() // ok\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\tswitch x {\n-\tcase 1:\n-\t\tprint(2)\n-\t\tpanic(3)\n-\t}\n-\tprintln() // ok\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-L:\n-\tswitch x {\n-\tcase 1:\n-\t\tprint(2)\n-\t\tpanic(3)\n-\t\tbreak L // ERROR \"unreachable code\"\n-\tdefault:\n-\t\treturn 4\n-\t}\n-\tprintln() // ok\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\tswitch x {\n-\tdefault:\n-\t\treturn 4\n-\t\tbreak // ERROR \"unreachable code\"\n-\tcase 1:\n-\t\tprint(2)\n-\t\tpanic(3)\n-\t}\n-\tprintln() // ok\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-L:\n-\tswitch x {\n-\tcase 1:\n-\t\tprint(2)\n-\t\tfor {\n-\t\t\tbreak L\n-\t\t}\n-\tdefault:\n-\t\treturn 4\n-\t}\n-\tprintln() // ok\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\tswitch x.(type) {\n-\tcase int:\n-\t\tprint(2)\n-\t\tpanic(3)\n-\t\tprintln() // ERROR \"unreachable code\"\n-\tdefault:\n-\t\treturn 4\n-\t\tprintln() // ERROR \"unreachable code\"\n-\t}\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\tswitch x.(type) {\n-\tcase int:\n-\t\tprint(2)\n-\t\tpanic(3)\n-\tdefault:\n-\t\treturn 4\n-\t}\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\tswitch x.(type) {\n-\tdefault:\n-\t\treturn 4\n-\t\tprintln() // ERROR \"unreachable code\"\n-\tcase int:\n-\t\tprint(2)\n-\t\tpanic(3)\n-\t\tprintln() // ERROR \"unreachable code\"\n-\t}\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\tswitch x.(type) {\n-\tdefault:\n-\t\treturn 4\n-\tcase int:\n-\t\tprint(2)\n-\t\tpanic(3)\n-\t}\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\tswitch x.(type) {\n-\tcase int:\n-\t\tprint(2)\n-\t\tfallthrough\n-\tdefault:\n-\t\treturn 4\n-\t\tprintln() // ERROR \"unreachable code\"\n-\t}\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\tswitch x.(type) {\n-\tcase int:\n-\t\tprint(2)\n-\t\tfallthrough\n-\tdefault:\n-\t\treturn 4\n-\t}\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\tswitch {\n-\t}\n-\tprintln() // ok\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\tswitch x.(type) {\n-\tcase int:\n-\t\tprint(2)\n-\t\tpanic(3)\n-\tcase float64:\n-\t\treturn 4\n-\t}\n-\tprintln() // ok\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\tswitch x.(type) {\n-\tcase float64:\n-\t\treturn 4\n-\tcase int:\n-\t\tprint(2)\n-\t\tpanic(3)\n-\t}\n-\tprintln() // ok\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\tswitch x.(type) {\n-\tcase int:\n-\t\tprint(2)\n-\t\tfallthrough\n-\tcase float64:\n-\t\treturn 4\n-\t}\n-\tprintln() // ok\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\tswitch x.(type) {\n-\tcase int:\n-\t\tprint(2)\n-\t\tpanic(3)\n-\t}\n-\tprintln() // ok\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-L:\n-\tswitch x.(type) {\n-\tcase int:\n-\t\tprint(2)\n-\t\tpanic(3)\n-\t\tbreak L // ERROR \"unreachable code\"\n-\tdefault:\n-\t\treturn 4\n-\t}\n-\tprintln() // ok\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-\tswitch x.(type) {\n-\tdefault:\n-\t\treturn 4\n-\t\tbreak // ERROR \"unreachable code\"\n-\tcase int:\n-\t\tprint(2)\n-\t\tpanic(3)\n-\t}\n-\tprintln() // ok\n-}\n-\n-var _ = func() int {\n-\tprint(1)\n-L:\n-\tswitch x.(type) {\n-\tcase int:\n-\t\tprint(2)\n-\t\tfor {\n-\t\t\tbreak L\n-\t\t}\n-\tdefault:\n-\t\treturn 4\n-\t}\n-\tprintln() // ok\n-}\n-\n-// again, but without the leading print(1).\n-// testing that everything works when the terminating statement is first.\n-\n-var _ = func() int {\n-\tprintln() // ok\n-}\n-\n-var _ = func() int {\n-\treturn 2\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-var _ = func() int {\n-L:\n-\tgoto L\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-var _ = func() int {\n-\tpanic(2)\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-// but only builtin panic\n-var _ = func() int {\n-\tvar panic = func(int) {}\n-\tpanic(2)\n-\tprintln() // ok\n-}\n-\n-var _ = func() int {\n-\t{\n-\t\treturn 2\n-\t\tprintln() // ERROR \"unreachable code\"\n-\t}\n-}\n-\n-var _ = func() int {\n-\t{\n-\t\treturn 2\n-\t}\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-var _ = func() int {\n-L:\n-\t{\n-\t\tgoto L\n-\t\tprintln() // ERROR \"unreachable code\"\n-\t}\n-}\n-\n-var _ = func() int {\n-L:\n-\t{\n-\t\tgoto L\n-\t}\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-var _ = func() int {\n-\t{\n-\t\tpanic(2)\n-\t\tprintln() // ERROR \"unreachable code\"\n-\t}\n-}\n-\n-var _ = func() int {\n-\t{\n-\t\tpanic(2)\n-\t}\n-\tprintln() // ERROR \"unreachable code\"\n-}\n-\n-var _ = func() int {\n-\treturn 2\n-\t{ // ERROR \"unreachable code\"\n-\t}\n-\tprintln() // ok\n-}\n-\n-var _ = func() int {\n-L:\n-\tgoto L\n-\t{ // ERROR \"unreachable code\"\n-\t}\n-\tprintln() // ok\n-}\n-\n-var _ = func() int {\n-\tpanic(2)\n-\t{ // ERROR \"unreachable code\"\n-\t}\n-\tprintln() // ok\n-}\n-\n-var _ = func() int {\n-\t{\n-\t\treturn 2\n-\t\t{ // ERROR \"unreachable code\"\n-\t\t}\n-\t}\n-\tprintln() // ok\n-}\n-\n-var _ = func() int {\n-L:\n-\t{\n-\t\tgoto L\n-\t\t{ // ERROR \"unreachable code\"\n-\t\t}\n-\t}\n-\tprintln() // ok\n-}\n-\n-var _ = func() int {\n-\t{\n-\t\tpanic(2)\n-\t\t{ // ERROR \"unreachable code\"\n-\t\t}\n-\t}\n-\tprintln() // ok\n-}\n-\n-var _ = func() int {\n-\t{\n-\t\treturn 2\n-\t}\n-\t{ // ERROR \"unreachable code\"\n-\t}\n-\tprintln() // ok\n-}\n-\n-var _ = func() int {\n-L:\n-\t{\n-\t\tgoto L\n-\t}\n-\t{ // ERROR \"unreachable code\"\n-\t}\n-\tprintln() // ok\n-}\n-\n-var _ = func() int {\n-\t{\n-\t\tpanic(2)\n-\t}\n-\t{ // ERROR \"unreachable code\"\n-\t}\n-\tprintln() // ok\n-}\n-\n-var _ = func() {\n-\t// goto without label used to panic\n-\tgoto\n-}\n-\n-func _() int {\n-\t// Empty switch tag with non-bool case value used to panic.\n-\tswitch {\n-\tcase 1:\n-\t\tprintln()\n-\t}\n-\tprintln()\n-}"}, {"sha": "0efe0f838d56ee6017b22aab81d9fe94dc1e1bd2", "filename": "libgo/go/cmd/vet/testdata/divergent/buf.go", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fdivergent%2Fbuf.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fdivergent%2Fbuf.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fdivergent%2Fbuf.go?ref=225220d668dafb8262db7012bced688acbe63b33", "patch": "@@ -1,17 +0,0 @@\n-// Test of examples with divergent packages.\n-\n-// Package buf ...\n-package buf\n-\n-// Buf is a ...\n-type Buf []byte\n-\n-// Append ...\n-func (*Buf) Append([]byte) {}\n-\n-func (Buf) Reset() {}\n-\n-func (Buf) Len() int { return 0 }\n-\n-// DefaultBuf is a ...\n-var DefaultBuf Buf"}, {"sha": "b75d55eaf4f2dd4e7314a98cba17e55a3b02cd57", "filename": "libgo/go/cmd/vet/testdata/divergent/buf_test.go", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fdivergent%2Fbuf_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fdivergent%2Fbuf_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fdivergent%2Fbuf_test.go?ref=225220d668dafb8262db7012bced688acbe63b33", "patch": "@@ -1,35 +0,0 @@\n-// Test of examples with divergent packages.\n-\n-package buf_test\n-\n-func Example() {} // OK because is package-level.\n-\n-func Example_suffix() {} // OK because refers to suffix annotation.\n-\n-func Example_BadSuffix() {} // ERROR \"Example_BadSuffix has malformed example suffix: BadSuffix\"\n-\n-func ExampleBuf() {} // OK because refers to known top-level type.\n-\n-func ExampleBuf_Append() {} // OK because refers to known method.\n-\n-func ExampleBuf_Clear() {} // ERROR \"ExampleBuf_Clear refers to unknown field or method: Buf.Clear\"\n-\n-func ExampleBuf_suffix() {} // OK because refers to suffix annotation.\n-\n-func ExampleBuf_Append_Bad() {} // ERROR \"ExampleBuf_Append_Bad has malformed example suffix: Bad\"\n-\n-func ExampleBuf_Append_suffix() {} // OK because refers to known method with valid suffix.\n-\n-func ExampleDefaultBuf() {} // OK because refers to top-level identifier.\n-\n-func ExampleBuf_Reset() bool { return true } // ERROR \"ExampleBuf_Reset should return nothing\"\n-\n-func ExampleBuf_Len(i int) {} // ERROR \"ExampleBuf_Len should be niladic\"\n-\n-// \"Puffer\" is German for \"Buffer\".\n-\n-func ExamplePuffer() {} // ERROR \"ExamplePuffer refers to unknown identifier: Puffer\"\n-\n-func ExamplePuffer_Append() {} // ERROR \"ExamplePuffer_Append refers to unknown identifier: Puffer\"\n-\n-func ExamplePuffer_suffix() {} // ERROR \"ExamplePuffer_suffix refers to unknown identifier: Puffer\""}, {"sha": "7302a64a3b6a59a6f1f9ae7a432790468cccc0d5", "filename": "libgo/go/cmd/vet/testdata/httpresponse.go", "status": "removed", "additions": 0, "deletions": 85, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fhttpresponse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fhttpresponse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fhttpresponse.go?ref=225220d668dafb8262db7012bced688acbe63b33", "patch": "@@ -1,85 +0,0 @@\n-package testdata\n-\n-import (\n-\t\"log\"\n-\t\"net/http\"\n-)\n-\n-func goodHTTPGet() {\n-\tres, err := http.Get(\"http://foo.com\")\n-\tif err != nil {\n-\t\tlog.Fatal(err)\n-\t}\n-\tdefer res.Body.Close()\n-}\n-\n-func badHTTPGet() {\n-\tres, err := http.Get(\"http://foo.com\")\n-\tdefer res.Body.Close() // ERROR \"using res before checking for errors\"\n-\tif err != nil {\n-\t\tlog.Fatal(err)\n-\t}\n-}\n-\n-func badHTTPHead() {\n-\tres, err := http.Head(\"http://foo.com\")\n-\tdefer res.Body.Close() // ERROR \"using res before checking for errors\"\n-\tif err != nil {\n-\t\tlog.Fatal(err)\n-\t}\n-}\n-\n-func goodClientGet() {\n-\tclient := http.DefaultClient\n-\tres, err := client.Get(\"http://foo.com\")\n-\tif err != nil {\n-\t\tlog.Fatal(err)\n-\t}\n-\tdefer res.Body.Close()\n-}\n-\n-func badClientPtrGet() {\n-\tclient := http.DefaultClient\n-\tresp, err := client.Get(\"http://foo.com\")\n-\tdefer resp.Body.Close() // ERROR \"using resp before checking for errors\"\n-\tif err != nil {\n-\t\tlog.Fatal(err)\n-\t}\n-}\n-\n-func badClientGet() {\n-\tclient := http.Client{}\n-\tresp, err := client.Get(\"http://foo.com\")\n-\tdefer resp.Body.Close() // ERROR \"using resp before checking for errors\"\n-\tif err != nil {\n-\t\tlog.Fatal(err)\n-\t}\n-}\n-\n-func badClientPtrDo() {\n-\tclient := http.DefaultClient\n-\treq, err := http.NewRequest(\"GET\", \"http://foo.com\", nil)\n-\tif err != nil {\n-\t\tlog.Fatal(err)\n-\t}\n-\n-\tresp, err := client.Do(req)\n-\tdefer resp.Body.Close() // ERROR \"using resp before checking for errors\"\n-\tif err != nil {\n-\t\tlog.Fatal(err)\n-\t}\n-}\n-\n-func badClientDo() {\n-\tvar client http.Client\n-\treq, err := http.NewRequest(\"GET\", \"http://foo.com\", nil)\n-\tif err != nil {\n-\t\tlog.Fatal(err)\n-\t}\n-\n-\tresp, err := client.Do(req)\n-\tdefer resp.Body.Close() // ERROR \"using resp before checking for errors\"\n-\tif err != nil {\n-\t\tlog.Fatal(err)\n-\t}\n-}"}, {"sha": "445502b39ecdef8f037228fa9521eeeb37607acb", "filename": "libgo/go/cmd/vet/testdata/incomplete/examples_test.go", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fincomplete%2Fexamples_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fincomplete%2Fexamples_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fincomplete%2Fexamples_test.go?ref=225220d668dafb8262db7012bced688acbe63b33", "patch": "@@ -1,33 +0,0 @@\n-// Test of examples.\n-\n-package testdata\n-\n-func Example() {} // OK because is package-level.\n-\n-func Example_suffix() // OK because refers to suffix annotation.\n-\n-func Example_BadSuffix() // OK because non-test package was excluded.  No false positives wanted.\n-\n-func ExampleBuf() // OK because non-test package was excluded.  No false positives wanted.\n-\n-func ExampleBuf_Append() {} // OK because non-test package was excluded.  No false positives wanted.\n-\n-func ExampleBuf_Clear() {} // OK because non-test package was excluded.  No false positives wanted.\n-\n-func ExampleBuf_suffix() {} // OK because refers to suffix annotation.\n-\n-func ExampleBuf_Append_Bad() {} // OK because non-test package was excluded.  No false positives wanted.\n-\n-func ExampleBuf_Append_suffix() {} // OK because refers to known method with valid suffix.\n-\n-func ExampleBuf_Reset() bool { return true } // ERROR \"ExampleBuf_Reset should return nothing\"\n-\n-func ExampleBuf_Len(i int) {} // ERROR \"ExampleBuf_Len should be niladic\"\n-\n-// \"Puffer\" is German for \"Buffer\".\n-\n-func ExamplePuffer() // OK because non-test package was excluded.  No false positives wanted.\n-\n-func ExamplePuffer_Append() // OK because non-test package was excluded.  No false positives wanted.\n-\n-func ExamplePuffer_suffix() // OK because non-test package was excluded.  No false positives wanted."}, {"sha": "b7549c00511127819183818ba3895b5c03536ba8", "filename": "libgo/go/cmd/vet/testdata/lostcancel.go", "status": "removed", "additions": 0, "deletions": 155, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Flostcancel.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Flostcancel.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Flostcancel.go?ref=225220d668dafb8262db7012bced688acbe63b33", "patch": "@@ -1,155 +0,0 @@\n-// Copyright 2016 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package testdata\n-\n-import (\n-\t\"context\"\n-\t\"log\"\n-\t\"os\"\n-\t\"testing\"\n-)\n-\n-// Check the three functions and assignment forms (var, :=, =) we look for.\n-// (Do these early: line numbers are fragile.)\n-func _() {\n-\tvar ctx, cancel = context.WithCancel() // ERROR \"the cancel function is not used on all paths \\(possible context leak\\)\"\n-} // ERROR \"this return statement may be reached without using the cancel var defined on line 17\"\n-\n-func _() {\n-\tctx, cancel2 := context.WithDeadline() // ERROR \"the cancel2 function is not used...\"\n-} // ERROR \"may be reached without using the cancel2 var defined on line 21\"\n-\n-func _() {\n-\tvar ctx context.Context\n-\tvar cancel3 func()\n-\tctx, cancel3 = context.WithTimeout() // ERROR \"function is not used...\"\n-} // ERROR \"this return statement may be reached without using the cancel3 var defined on line 27\"\n-\n-func _() {\n-\tctx, _ := context.WithCancel()  // ERROR \"the cancel function returned by context.WithCancel should be called, not discarded, to avoid a context leak\"\n-\tctx, _ = context.WithTimeout()  // ERROR \"the cancel function returned by context.WithTimeout should be called, not discarded, to avoid a context leak\"\n-\tctx, _ = context.WithDeadline() // ERROR \"the cancel function returned by context.WithDeadline should be called, not discarded, to avoid a context leak\"\n-}\n-\n-func _() {\n-\tctx, cancel := context.WithCancel()\n-\tdefer cancel() // ok\n-}\n-\n-func _() {\n-\tctx, cancel := context.WithCancel() // ERROR \"not used on all paths\"\n-\tif condition {\n-\t\tcancel()\n-\t}\n-\treturn // ERROR \"this return statement may be reached without using the cancel var\"\n-}\n-\n-func _() {\n-\tctx, cancel := context.WithCancel()\n-\tif condition {\n-\t\tcancel()\n-\t} else {\n-\t\t// ok: infinite loop\n-\t\tfor {\n-\t\t\tprint(0)\n-\t\t}\n-\t}\n-}\n-\n-func _() {\n-\tctx, cancel := context.WithCancel() // ERROR \"not used on all paths\"\n-\tif condition {\n-\t\tcancel()\n-\t} else {\n-\t\tfor i := 0; i < 10; i++ {\n-\t\t\tprint(0)\n-\t\t}\n-\t}\n-} // ERROR \"this return statement may be reached without using the cancel var\"\n-\n-func _() {\n-\tctx, cancel := context.WithCancel()\n-\t// ok: used on all paths\n-\tswitch someInt {\n-\tcase 0:\n-\t\tnew(testing.T).FailNow()\n-\tcase 1:\n-\t\tlog.Fatal()\n-\tcase 2:\n-\t\tcancel()\n-\tcase 3:\n-\t\tprint(\"hi\")\n-\t\tfallthrough\n-\tdefault:\n-\t\tos.Exit(1)\n-\t}\n-}\n-\n-func _() {\n-\tctx, cancel := context.WithCancel() // ERROR \"not used on all paths\"\n-\tswitch someInt {\n-\tcase 0:\n-\t\tnew(testing.T).FailNow()\n-\tcase 1:\n-\t\tlog.Fatal()\n-\tcase 2:\n-\t\tcancel()\n-\tcase 3:\n-\t\tprint(\"hi\") // falls through to implicit return\n-\tdefault:\n-\t\tos.Exit(1)\n-\t}\n-} // ERROR \"this return statement may be reached without using the cancel var\"\n-\n-func _(ch chan int) int {\n-\tctx, cancel := context.WithCancel() // ERROR \"not used on all paths\"\n-\tselect {\n-\tcase <-ch:\n-\t\tnew(testing.T).FailNow()\n-\tcase y <- ch:\n-\t\tprint(\"hi\") // falls through to implicit return\n-\tcase ch <- 1:\n-\t\tcancel()\n-\tdefault:\n-\t\tos.Exit(1)\n-\t}\n-} // ERROR \"this return statement may be reached without using the cancel var\"\n-\n-func _(ch chan int) int {\n-\tctx, cancel := context.WithCancel()\n-\t// A blocking select must execute one of its cases.\n-\tselect {\n-\tcase <-ch:\n-\t\tpanic()\n-\t}\n-}\n-\n-func _() {\n-\tgo func() {\n-\t\tctx, cancel := context.WithCancel() // ERROR \"not used on all paths\"\n-\t\tprint(ctx)\n-\t}() // ERROR \"may be reached without using the cancel var\"\n-}\n-\n-var condition bool\n-var someInt int\n-\n-// Regression test for Go issue 16143.\n-func _() {\n-\tvar x struct{ f func() }\n-\tx.f()\n-}\n-\n-// Regression test for Go issue 16230.\n-func _() (ctx context.Context, cancel func()) {\n-\tctx, cancel = context.WithCancel()\n-\treturn // a naked return counts as a load of the named result values\n-}\n-\n-// Same as above, but for literal function.\n-var _ = func() (ctx context.Context, cancel func()) {\n-\tctx, cancel = context.WithCancel()\n-\treturn\n-}"}, {"sha": "2ce7bc8ca82eccc641e7d6879ac7dcdb02f5399d", "filename": "libgo/go/cmd/vet/testdata/nilfunc.go", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fnilfunc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fnilfunc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fnilfunc.go?ref=225220d668dafb8262db7012bced688acbe63b33", "patch": "@@ -1,35 +0,0 @@\n-// Copyright 2013 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package testdata\n-\n-func F() {}\n-\n-type T struct {\n-\tF func()\n-}\n-\n-func (T) M() {}\n-\n-var Fv = F\n-\n-func Comparison() {\n-\tvar t T\n-\tvar fn func()\n-\tif fn == nil || Fv == nil || t.F == nil {\n-\t\t// no error; these func vars or fields may be nil\n-\t}\n-\tif F == nil { // ERROR \"comparison of function F == nil is always false\"\n-\t\tpanic(\"can't happen\")\n-\t}\n-\tif t.M == nil { // ERROR \"comparison of function M == nil is always false\"\n-\t\tpanic(\"can't happen\")\n-\t}\n-\tif F != nil { // ERROR \"comparison of function F != nil is always true\"\n-\t\tif t.M != nil { // ERROR \"comparison of function M != nil is always true\"\n-\t\t\treturn\n-\t\t}\n-\t}\n-\tpanic(\"can't happen\")\n-}"}, {"sha": "cd3b4cbc452231cda898b0a17bd9d4afdd774dc3", "filename": "libgo/go/cmd/vet/testdata/rangeloop.go", "status": "removed", "additions": 0, "deletions": 90, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Frangeloop.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Frangeloop.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Frangeloop.go?ref=225220d668dafb8262db7012bced688acbe63b33", "patch": "@@ -1,90 +0,0 @@\n-// Copyright 2012 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// This file contains tests for the rangeloop checker.\n-\n-package testdata\n-\n-func RangeLoopTests() {\n-\tvar s []int\n-\tfor i, v := range s {\n-\t\tgo func() {\n-\t\t\tprintln(i) // ERROR \"loop variable i captured by func literal\"\n-\t\t\tprintln(v) // ERROR \"loop variable v captured by func literal\"\n-\t\t}()\n-\t}\n-\tfor i, v := range s {\n-\t\tdefer func() {\n-\t\t\tprintln(i) // ERROR \"loop variable i captured by func literal\"\n-\t\t\tprintln(v) // ERROR \"loop variable v captured by func literal\"\n-\t\t}()\n-\t}\n-\tfor i := range s {\n-\t\tgo func() {\n-\t\t\tprintln(i) // ERROR \"loop variable i captured by func literal\"\n-\t\t}()\n-\t}\n-\tfor _, v := range s {\n-\t\tgo func() {\n-\t\t\tprintln(v) // ERROR \"loop variable v captured by func literal\"\n-\t\t}()\n-\t}\n-\tfor i, v := range s {\n-\t\tgo func() {\n-\t\t\tprintln(i, v)\n-\t\t}()\n-\t\tprintln(\"unfortunately, we don't catch the error above because of this statement\")\n-\t}\n-\tfor i, v := range s {\n-\t\tgo func(i, v int) {\n-\t\t\tprintln(i, v)\n-\t\t}(i, v)\n-\t}\n-\tfor i, v := range s {\n-\t\ti, v := i, v\n-\t\tgo func() {\n-\t\t\tprintln(i, v)\n-\t\t}()\n-\t}\n-\t// If the key of the range statement is not an identifier\n-\t// the code should not panic (it used to).\n-\tvar x [2]int\n-\tvar f int\n-\tfor x[0], f = range s {\n-\t\tgo func() {\n-\t\t\t_ = f // ERROR \"loop variable f captured by func literal\"\n-\t\t}()\n-\t}\n-\ttype T struct {\n-\t\tv int\n-\t}\n-\tfor _, v := range s {\n-\t\tgo func() {\n-\t\t\t_ = T{v: 1}\n-\t\t\t_ = []int{v: 1} // ERROR \"loop variable v captured by func literal\"\n-\t\t}()\n-\t}\n-\n-\t// ordinary for-loops\n-\tfor i := 0; i < 10; i++ {\n-\t\tgo func() {\n-\t\t\tprint(i) // ERROR \"loop variable i captured by func literal\"\n-\t\t}()\n-\t}\n-\tfor i, j := 0, 1; i < 100; i, j = j, i+j {\n-\t\tgo func() {\n-\t\t\tprint(j) // ERROR \"loop variable j captured by func literal\"\n-\t\t}()\n-\t}\n-\ttype cons struct {\n-\t\tcar int\n-\t\tcdr *cons\n-\t}\n-\tvar head *cons\n-\tfor p := head; p != nil; p = p.next {\n-\t\tgo func() {\n-\t\t\tprint(p.car) // ERROR \"loop variable p captured by func literal\"\n-\t\t}()\n-\t}\n-}"}, {"sha": "c55cb2772a9c67d9698094a0c0d9a8ac2a94ba03", "filename": "libgo/go/cmd/vet/testdata/shadow.go", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fshadow.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fshadow.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fshadow.go?ref=225220d668dafb8262db7012bced688acbe63b33", "patch": "@@ -1,59 +0,0 @@\n-// Copyright 2013 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// This file contains tests for the shadowed variable checker.\n-// Some of these errors are caught by the compiler (shadowed return parameters for example)\n-// but are nonetheless useful tests.\n-\n-package testdata\n-\n-import \"os\"\n-\n-func ShadowRead(f *os.File, buf []byte) (err error) {\n-\tvar x int\n-\tif f != nil {\n-\t\terr := 3 // OK - different type.\n-\t\t_ = err\n-\t}\n-\tif f != nil {\n-\t\t_, err := f.Read(buf) // ERROR \"declaration of .err. shadows declaration at shadow.go:13\"\n-\t\tif err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t\ti := 3 // OK\n-\t\t_ = i\n-\t}\n-\tif f != nil {\n-\t\tx := one()               // ERROR \"declaration of .x. shadows declaration at shadow.go:14\"\n-\t\tvar _, err = f.Read(buf) // ERROR \"declaration of .err. shadows declaration at shadow.go:13\"\n-\t\tif x == 1 && err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t}\n-\tfor i := 0; i < 10; i++ {\n-\t\ti := i // OK: obviously intentional idiomatic redeclaration\n-\t\tgo func() {\n-\t\t\tprintln(i)\n-\t\t}()\n-\t}\n-\tvar shadowTemp interface{}\n-\tswitch shadowTemp := shadowTemp.(type) { // OK: obviously intentional idiomatic redeclaration\n-\tcase int:\n-\t\tprintln(\"OK\")\n-\t\t_ = shadowTemp\n-\t}\n-\tif shadowTemp := shadowTemp; true { // OK: obviously intentional idiomatic redeclaration\n-\t\tvar f *os.File // OK because f is not mentioned later in the function.\n-\t\t// The declaration of x is a shadow because x is mentioned below.\n-\t\tvar x int // ERROR \"declaration of .x. shadows declaration at shadow.go:14\"\n-\t\t_, _, _ = x, f, shadowTemp\n-\t}\n-\t// Use a couple of variables to trigger shadowing errors.\n-\t_, _ = err, x\n-\treturn\n-}\n-\n-func one() int {\n-\treturn 1\n-}"}, {"sha": "73cbaf884180c661446d071b062705c4328338c0", "filename": "libgo/go/cmd/vet/testdata/shift.go", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fshift.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fshift.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fshift.go?ref=225220d668dafb8262db7012bced688acbe63b33"}, {"sha": "72ff452aae84453d6b37518b8334947d1e2eaaf9", "filename": "libgo/go/cmd/vet/testdata/src/asm/asm.go", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Fasm%2Fasm.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Fasm%2Fasm.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Fasm%2Fasm.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "c3ba986fb8b1217f08536d758a33d63ccb045f04", "filename": "libgo/go/cmd/vet/testdata/src/asm/asm1.s", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Fasm%2Fasm1.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Fasm%2Fasm1.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Fasm%2Fasm1.s?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "112614e562c683bd6320ce223b8ffa36180d6dbb", "filename": "libgo/go/cmd/vet/testdata/src/assign/assign.go", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Fassign%2Fassign.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Fassign%2Fassign.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Fassign%2Fassign.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "previous_filename": "libgo/go/cmd/vet/testdata/assign.go"}, {"sha": "650d56bdadaef720def5438ee99d48c49ea98a53", "filename": "libgo/go/cmd/vet/testdata/src/atomic/atomic.go", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Fatomic%2Fatomic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Fatomic%2Fatomic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Fatomic%2Fatomic.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "20e01aa46f091bf40b91143ff11cdf8e7b9529cd", "filename": "libgo/go/cmd/vet/testdata/src/bool/bool.go", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Fbool%2Fbool.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Fbool%2Fbool.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Fbool%2Fbool.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "c2fd6aaaf2fa01deb087090a78756eabf2e365bb", "filename": "libgo/go/cmd/vet/testdata/src/buildtag/buildtag.go", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Fbuildtag%2Fbuildtag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Fbuildtag%2Fbuildtag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Fbuildtag%2Fbuildtag.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "previous_filename": "libgo/go/cmd/vet/testdata/buildtag/buildtag.go"}, {"sha": "292d7fdab7dff4c98eb45d24cf7e4c1c5fb07467", "filename": "libgo/go/cmd/vet/testdata/src/cgo/cgo.go", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Fcgo%2Fcgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Fcgo%2Fcgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Fcgo%2Fcgo.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "63a28378515cc2cdafb15b0c932d92aea4989f35", "filename": "libgo/go/cmd/vet/testdata/src/composite/composite.go", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Fcomposite%2Fcomposite.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Fcomposite%2Fcomposite.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Fcomposite%2Fcomposite.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "8079cf3248b785afbcf7b1097e509047e48c0a56", "filename": "libgo/go/cmd/vet/testdata/src/copylock/copylock.go", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Fcopylock%2Fcopylock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Fcopylock%2Fcopylock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Fcopylock%2Fcopylock.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "af83cdfbb1e82dc57e96acee476dba851151c2a3", "filename": "libgo/go/cmd/vet/testdata/src/deadcode/deadcode.go", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Fdeadcode%2Fdeadcode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Fdeadcode%2Fdeadcode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Fdeadcode%2Fdeadcode.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "6141f6e06dce69cfbeaaf976b8d872bf71e1f3df", "filename": "libgo/go/cmd/vet/testdata/src/httpresponse/httpresponse.go", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Fhttpresponse%2Fhttpresponse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Fhttpresponse%2Fhttpresponse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Fhttpresponse%2Fhttpresponse.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "1bbb22d27b4b3f529538841538182fab7d8e16f1", "filename": "libgo/go/cmd/vet/testdata/src/lostcancel/lostcancel.go", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Flostcancel%2Flostcancel.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Flostcancel%2Flostcancel.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Flostcancel%2Flostcancel.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "51c3f65fcc728e9531ae0f8b5d62f6976bb607fa", "filename": "libgo/go/cmd/vet/testdata/src/method/method.go", "status": "renamed", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Fmethod%2Fmethod.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Fmethod%2Fmethod.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Fmethod%2Fmethod.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "previous_filename": "libgo/go/cmd/vet/testdata/method.go"}, {"sha": "c34d60e05214cf106ccc9c746b0f781256b75fce", "filename": "libgo/go/cmd/vet/testdata/src/nilfunc/nilfunc.go", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Fnilfunc%2Fnilfunc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Fnilfunc%2Fnilfunc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Fnilfunc%2Fnilfunc.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "6bacd0fd747c8659875ceabb86668ff4841f0f3d", "filename": "libgo/go/cmd/vet/testdata/src/print/print.go", "status": "renamed", "additions": 71, "deletions": 57, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Fprint%2Fprint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Fprint%2Fprint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Fprint%2Fprint.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "previous_filename": "libgo/go/cmd/vet/testdata/print.go"}, {"sha": "4e21564186969d0f5c6d954a031bd87d6325827d", "filename": "libgo/go/cmd/vet/testdata/src/rangeloop/rangeloop.go", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Frangeloop%2Frangeloop.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Frangeloop%2Frangeloop.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Frangeloop%2Frangeloop.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "6b7a5ac9e180ad81611cfecbdbe93f8e01fc808c", "filename": "libgo/go/cmd/vet/testdata/src/shift/shift.go", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Fshift%2Fshift.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Fshift%2Fshift.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Fshift%2Fshift.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "cbcc453376070a2fb78aaf6e5a5da3842a94b7af", "filename": "libgo/go/cmd/vet/testdata/src/structtag/structtag.go", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Fstructtag%2Fstructtag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Fstructtag%2Fstructtag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Fstructtag%2Fstructtag.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "47fe3c80afe347edec1b8ed09c596997538b0e3a", "filename": "libgo/go/cmd/vet/testdata/src/tagtest/file1.go", "status": "renamed", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Ftagtest%2Ffile1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Ftagtest%2Ffile1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Ftagtest%2Ffile1.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "previous_filename": "libgo/go/cmd/vet/testdata/tagtest/file1.go"}, {"sha": "1f45efcbf2f43eeb99bb15955eb14c81f5953312", "filename": "libgo/go/cmd/vet/testdata/src/tagtest/file2.go", "status": "renamed", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Ftagtest%2Ffile2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Ftagtest%2Ffile2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Ftagtest%2Ffile2.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "previous_filename": "libgo/go/cmd/vet/testdata/tagtest/file2.go"}, {"sha": "69d29d3c6c65ef548cc4e2226ca19f16e072def0", "filename": "libgo/go/cmd/vet/testdata/src/testingpkg/tests.go", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Ftestingpkg%2Ftests.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Ftestingpkg%2Ftests.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Ftestingpkg%2Ftests.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "previous_filename": "libgo/go/cmd/vet/testdata/testingpkg/tests.go"}, {"sha": "09bb98d980ecd38e820d357211f454c12ba9c3d3", "filename": "libgo/go/cmd/vet/testdata/src/testingpkg/tests_test.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Ftestingpkg%2Ftests_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Ftestingpkg%2Ftests_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Ftestingpkg%2Ftests_test.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "b387bbbd23420355bf42988fa242b930353efecf", "filename": "libgo/go/cmd/vet/testdata/src/unmarshal/unmarshal.go", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Funmarshal%2Funmarshal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Funmarshal%2Funmarshal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Funmarshal%2Funmarshal.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "e9b866ea21b305562adbf0c231a6653c56c60280", "filename": "libgo/go/cmd/vet/testdata/src/unsafeptr/unsafeptr.go", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Funsafeptr%2Funsafeptr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Funsafeptr%2Funsafeptr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Funsafeptr%2Funsafeptr.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "1e83e90d68fc389ddcb8fd89b99012deb625c5dc", "filename": "libgo/go/cmd/vet/testdata/src/unused/unused.go", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Funused%2Funused.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Funused%2Funused.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fsrc%2Funused%2Funused.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "ce21e803c802e3ceae415ddd4365062544326432", "filename": "libgo/go/cmd/vet/testdata/structtag.go", "status": "removed", "additions": 0, "deletions": 102, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fstructtag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fstructtag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fstructtag.go?ref=225220d668dafb8262db7012bced688acbe63b33"}, {"sha": "f5bbc3922a99f1938b567c8c2156ad46314417c7", "filename": "libgo/go/cmd/vet/testdata/testingpkg/tests_test.go", "status": "removed", "additions": 0, "deletions": 74, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Ftestingpkg%2Ftests_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Ftestingpkg%2Ftests_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Ftestingpkg%2Ftests_test.go?ref=225220d668dafb8262db7012bced688acbe63b33"}, {"sha": "ce852009ea7336cfc47e17fb35920b0c0381d5e8", "filename": "libgo/go/cmd/vet/testdata/unsafeptr.go", "status": "removed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Funsafeptr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Funsafeptr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Funsafeptr.go?ref=225220d668dafb8262db7012bced688acbe63b33"}, {"sha": "d50f6594d9b464e340b35af78406d5e4d933c54d", "filename": "libgo/go/cmd/vet/testdata/unused.go", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Funused.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Funused.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Funused.go?ref=225220d668dafb8262db7012bced688acbe63b33"}, {"sha": "5b157084fa2570abccf0a09cbeafcf0d5a43306a", "filename": "libgo/go/cmd/vet/tests.go", "status": "removed", "additions": 0, "deletions": 187, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftests.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftests.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftests.go?ref=225220d668dafb8262db7012bced688acbe63b33"}, {"sha": "60b61250b85946d4368bd53c0cbce01633d10bed", "filename": "libgo/go/cmd/vet/types.go", "status": "removed", "additions": 0, "deletions": 313, "changes": 313, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftypes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Ftypes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftypes.go?ref=225220d668dafb8262db7012bced688acbe63b33"}, {"sha": "cb2cc818897aa474df00d258f182387923a9e81f", "filename": "libgo/go/cmd/vet/unsafeptr.go", "status": "removed", "additions": 0, "deletions": 97, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Funsafeptr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Funsafeptr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Funsafeptr.go?ref=225220d668dafb8262db7012bced688acbe63b33"}, {"sha": "02fcd841cd06db44eb25ae134c63107d45778820", "filename": "libgo/go/cmd/vet/unused.go", "status": "removed", "additions": 0, "deletions": 93, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Funused.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcmd%2Fvet%2Funused.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Funused.go?ref=225220d668dafb8262db7012bced688acbe63b33"}, {"sha": "1c7b8625f35a37e0f9f4f7824c785a824fbaa6c1", "filename": "libgo/go/cmd/vet/vet_test.go", "status": "modified", "additions": 89, "deletions": 126, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Fvet_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcmd%2Fvet%2Fvet_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fvet_test.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "c432bb5226ff98755d8ea8d9aeef063ac91d9e0d", "filename": "libgo/go/compress/bzip2/bzip2_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbzip2_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbzip2_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbzip2_test.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "libgo/go/compress/bzip2/testdata/Isaac.Newton-Opticks.txt.bz2", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcompress%2Fbzip2%2Ftestdata%2FIsaac.Newton-Opticks.txt.bz2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcompress%2Fbzip2%2Ftestdata%2FIsaac.Newton-Opticks.txt.bz2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fbzip2%2Ftestdata%2FIsaac.Newton-Opticks.txt.bz2?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "034040e56decbf465e177c3754cfa53a3bf0d22c", "filename": "libgo/go/compress/flate/deflate_test.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "49921398e2ba9001a0bbb1ad83a78fe0dd27cc5e", "filename": "libgo/go/compress/flate/inflate.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcompress%2Fflate%2Finflate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcompress%2Fflate%2Finflate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Finflate.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "e39d7f0f97ec617b02c4fc5aac188c484353b5ec", "filename": "libgo/go/compress/flate/reader_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcompress%2Fflate%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcompress%2Fflate%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Freader_test.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "15bb4c54d0b755d77290b13650d4e78e94da0f97", "filename": "libgo/go/compress/flate/testdata/Isaac.Newton-Opticks.txt", "status": "added", "additions": 9286, "deletions": 0, "changes": 9286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2FIsaac.Newton-Opticks.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2FIsaac.Newton-Opticks.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2FIsaac.Newton-Opticks.txt?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "c9106fd522cec80b8de64958de765776a1476488", "filename": "libgo/go/compress/testdata/Mark.Twain-Tom.Sawyer.txt", "status": "removed", "additions": 0, "deletions": 8465, "changes": 8465, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcompress%2Ftestdata%2FMark.Twain-Tom.Sawyer.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcompress%2Ftestdata%2FMark.Twain-Tom.Sawyer.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Ftestdata%2FMark.Twain-Tom.Sawyer.txt?ref=225220d668dafb8262db7012bced688acbe63b33"}, {"sha": "a195b380d8dd0bc25b7d78f1e5780c2581d37070", "filename": "libgo/go/compress/zlib/reader.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcompress%2Fzlib%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcompress%2Fzlib%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fzlib%2Freader.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "9986e3834d4d0963e98642eb0afc3f8921a65942", "filename": "libgo/go/compress/zlib/writer.go", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcompress%2Fzlib%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcompress%2Fzlib%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fzlib%2Fwriter.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "2e09da8613aa3ed2822bedc6cabbdf8b081161be", "filename": "libgo/go/container/heap/heap.go", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcontainer%2Fheap%2Fheap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcontainer%2Fheap%2Fheap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Fheap%2Fheap.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "b8b599aabb11d297cf7f61e31ddf11ab3dadb9dd", "filename": "libgo/go/container/list/list.go", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcontainer%2Flist%2Flist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcontainer%2Flist%2Flist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Flist%2Flist.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "21a40d59477b4bc3277b4a2a036c9cb9e9d209b0", "filename": "libgo/go/context/context.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcontext%2Fcontext.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcontext%2Fcontext.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontext%2Fcontext.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "1e8bac4bb5fc926b94add604aca3bf32f1fd617c", "filename": "libgo/go/crypto/aes/aes_test.go", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Faes%2Faes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Faes%2Faes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Faes%2Faes_test.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "40bd0d335d3b204db9c0044f7d8dffe87ac7cdd6", "filename": "libgo/go/crypto/aes/block.go", "status": "modified", "additions": 27, "deletions": 21, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Faes%2Fblock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Faes%2Fblock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Faes%2Fblock.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "aed493de814f5e13c2b3c7ad6bb57bcb35d9bbc4", "filename": "libgo/go/crypto/aes/ctr_s390x.go", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Faes%2Fctr_s390x.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Faes%2Fctr_s390x.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Faes%2Fctr_s390x.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "bd1f9a0781dbc8b18eaf271ec3498ae31c46fa33", "filename": "libgo/go/crypto/aes/gcm_s390x.go", "status": "modified", "additions": 6, "deletions": 25, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Faes%2Fgcm_s390x.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Faes%2Fgcm_s390x.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Faes%2Fgcm_s390x.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "90d0cd71385fb0ca88e2aab32748379b859dc1c1", "filename": "libgo/go/crypto/cipher/benchmark_test.go", "status": "modified", "additions": 23, "deletions": 44, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Fcipher%2Fbenchmark_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Fcipher%2Fbenchmark_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fbenchmark_test.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "9c32d6a934f86c6ecc37c535eba781c088e5bd38", "filename": "libgo/go/crypto/cipher/example_test.go", "status": "modified", "additions": 16, "deletions": 27, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Fcipher%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Fcipher%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fexample_test.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "cf8007ab491c4dcf34fac84927fdcabbccb12012", "filename": "libgo/go/crypto/cipher/export_test.go", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Fcipher%2Fexport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Fcipher%2Fexport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fexport_test.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "73d78550f897b8a951e480210692646b9b952451", "filename": "libgo/go/crypto/cipher/gcm.go", "status": "modified", "additions": 13, "deletions": 41, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Fcipher%2Fgcm.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Fcipher%2Fgcm.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fgcm.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "2e1e26a1372666776b5d9fecbef628915a4b82b9", "filename": "libgo/go/crypto/cipher/xor_amd64.go", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Fcipher%2Fxor_amd64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Fcipher%2Fxor_amd64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fxor_amd64.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "86abbb744aed093df5d7f2139c4ea60b78cb59d5", "filename": "libgo/go/crypto/cipher/xor_generic.go", "status": "renamed", "additions": 32, "deletions": 30, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Fcipher%2Fxor_generic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Fcipher%2Fxor_generic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fxor_generic.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "previous_filename": "libgo/go/crypto/cipher/xor.go"}, {"sha": "e7d67f423d57a5526f73713550ed8c5fed52da7d", "filename": "libgo/go/crypto/cipher/xor_ppc64x.go", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Fcipher%2Fxor_ppc64x.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Fcipher%2Fxor_ppc64x.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fxor_ppc64x.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "24877efc367e24478c357ea38632abf051a2926d", "filename": "libgo/go/crypto/cipher/xor_test.go", "status": "modified", "additions": 56, "deletions": 12, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Fcipher%2Fxor_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Fcipher%2Fxor_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fxor_test.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "e059f181c7ea340774176e1534de9c412568481f", "filename": "libgo/go/crypto/ecdsa/ecdsa.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "40c0929cd0e8dfec73001eebc31654cd7a1de4ba", "filename": "libgo/go/crypto/elliptic/p256_s390x.go", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp256_s390x.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp256_s390x.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp256_s390x.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "801ece67ae415e4f0efe0e1ff7e689283b4b0353", "filename": "libgo/go/crypto/hmac/hmac.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "a11f22059fa1a63cfda6173692e9fee172702a96", "filename": "libgo/go/crypto/md5/gen.go", "status": "modified", "additions": 62, "deletions": 133, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Fmd5%2Fgen.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Fmd5%2Fgen.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fmd5%2Fgen.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "011578404751aca16699dfe73949247798564723", "filename": "libgo/go/crypto/md5/md5.go", "status": "modified", "additions": 43, "deletions": 57, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "34c7f541c5740ca95492bc87fabc05abdb71f462", "filename": "libgo/go/crypto/md5/md5_test.go", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5_test.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "4ff289e860f96468b46ce998130a1e7246ec88ae", "filename": "libgo/go/crypto/md5/md5block.go", "status": "modified", "additions": 104, "deletions": 243, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5block.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5block.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5block.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "761398f38e9d92d07297258ce484537879772605", "filename": "libgo/go/crypto/md5/md5block_decl.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5block_decl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5block_decl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5block_decl.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "69c4456a4bdeff72d5f08c0d2df4dbd0db657016", "filename": "libgo/go/crypto/md5/md5block_generic.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5block_generic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5block_generic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5block_generic.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "a5ccd19de3299489e30dc432483b5fbf9d3fa3a7", "filename": "libgo/go/crypto/rand/rand.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Frand%2Frand.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Frand%2Frand.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Frand.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "60267fd4bc229263c39d016493b34c879cc0ccb0", "filename": "libgo/go/crypto/rand/rand_batched.go", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Frand%2Frand_batched.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Frand%2Frand_batched.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Frand_batched.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "837db83f770844ef92d4b644fed2a491feed267f", "filename": "libgo/go/crypto/rand/rand_batched_test.go", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Frand%2Frand_batched_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Frand%2Frand_batched_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Frand_batched_test.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346", "previous_filename": "libgo/go/crypto/rand/rand_linux_test.go"}, {"sha": "75f683c386d50d3cfb5a45a995fc900b8f3cf0a0", "filename": "libgo/go/crypto/rand/rand_freebsd.go", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Frand%2Frand_freebsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Frand%2Frand_freebsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Frand_freebsd.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "26b93c54d286b94aaae92c64d5008a40c18cec31", "filename": "libgo/go/crypto/rand/rand_linux.go", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Frand%2Frand_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Frand%2Frand_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Frand_linux.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "f3091f51c5fd8ffcd38480e2949d5304d49e40fe", "filename": "libgo/go/crypto/rand/rand_unix.go", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Frand%2Frand_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Frand%2Frand_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Frand_unix.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "78a4ed6d67b5c843d94f89e5c5bfea5b1a77c9b6", "filename": "libgo/go/crypto/rand/rand_windows.go", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Frand%2Frand_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Frand%2Frand_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Frand_windows.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "d5e6ebcd712ae170ac284f05054b5c676987a087", "filename": "libgo/go/crypto/rc4/rc4.go", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Frc4%2Frc4.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Frc4%2Frc4.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frc4%2Frc4.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "ce2162df60341db88e416be146235d82fec2f775", "filename": "libgo/go/crypto/rc4/rc4_asm.go", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcrypto%2Frc4%2Frc4_asm.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcrypto%2Frc4%2Frc4_asm.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frc4%2Frc4_asm.go?ref=225220d668dafb8262db7012bced688acbe63b33"}, {"sha": "d20dbb14a38ac55e0be4d2297f764a029cf66280", "filename": "libgo/go/crypto/rc4/rc4_ref.go", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcrypto%2Frc4%2Frc4_ref.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225220d668dafb8262db7012bced688acbe63b33/libgo%2Fgo%2Fcrypto%2Frc4%2Frc4_ref.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frc4%2Frc4_ref.go?ref=225220d668dafb8262db7012bced688acbe63b33"}, {"sha": "e7356aa45de1b2b75c48720bea9b7345bc9a84d0", "filename": "libgo/go/crypto/rc4/rc4_test.go", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Frc4%2Frc4_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Frc4%2Frc4_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frc4%2Frc4_test.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "dfa8d8bb5ad02e6feb3420348680c146b03740ad", "filename": "libgo/go/crypto/rsa/pss_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Frsa%2Fpss_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Frsa%2Fpss_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Fpss_test.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "8c48042b1ce3f987c437d2825fedfb8e3d2ec48b", "filename": "libgo/go/crypto/sha1/sha1.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "c047204bf3164c2f5b4b2ff0598666b8d2d3ac42", "filename": "libgo/go/crypto/sha1/sha1_test.go", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1_test.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "c5bd0041d8c8187e75158bc4cab785201a579b96", "filename": "libgo/go/crypto/sha1/sha1block_arm64.go", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1block_arm64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1block_arm64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1block_arm64.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "3fd446f94b6f2835326e49406982e72533e8a73e", "filename": "libgo/go/crypto/sha256/sha256.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "a606190753505ee0968a10a9a40e34fd0fac961d", "filename": "libgo/go/crypto/sha256/sha256_test.go", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256_test.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "d8f3437f7d853634ae82058711b6962b746c3ab5", "filename": "libgo/go/crypto/sha256/sha256block_arm64.go", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256block_arm64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256block_arm64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256block_arm64.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "c685319480c24470578f88649d5de9cba8a0de3f", "filename": "libgo/go/crypto/sha512/sha512.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}, {"sha": "96a1aa69a4fcc090e7f4b08da4eb9e189078de4f", "filename": "libgo/go/crypto/sha512/sha512_test.go", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4a855d82a889cebcfca150a7a43909bcb6a346/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512_test.go?ref=4f4a855d82a889cebcfca150a7a43909bcb6a346"}]}