{"sha": "520b52b24e73d2ec48fd6f492266df42c218bdf2", "node_id": "C_kwDOANBUbNoAKDUyMGI1MmIyNGU3M2QyZWM0OGZkNmY0OTIyNjZkZjQyYzIxOGJkZjI", "commit": {"author": {"name": "Thomas Young", "email": "wenzhang5800@gmail.com", "date": "2022-08-23T15:34:35Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-12-13T13:00:06Z"}, "message": "gccrs: Add dead code scan on HIR\n\nIn order to find dead code we use a depth first search and keep liveness\nvariables, after type resolution. In this case, if a function is unused\nand it calls another function the 2nd function is now unused since the\ncaller is not used etc. The algorithm is a depth first search.\n\n\tgcc/rust/\n\t* checks/lints/rust-lint-marklive-base.h: New.\n\t* checks/lints/rust-lint-marklive.cc: New.\n\t* checks/lints/rust-lint-marklive.h: New.\n\t* checks/lints/rust-lint-scan-deadcode.h: New.", "tree": {"sha": "ae9e6163fb2b700a41e8f1d07c3b95837350b354", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae9e6163fb2b700a41e8f1d07c3b95837350b354"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/520b52b24e73d2ec48fd6f492266df42c218bdf2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/520b52b24e73d2ec48fd6f492266df42c218bdf2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/520b52b24e73d2ec48fd6f492266df42c218bdf2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/520b52b24e73d2ec48fd6f492266df42c218bdf2/comments", "author": {"login": "thomasyonug", "id": 17464490, "node_id": "MDQ6VXNlcjE3NDY0NDkw", "avatar_url": "https://avatars.githubusercontent.com/u/17464490?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thomasyonug", "html_url": "https://github.com/thomasyonug", "followers_url": "https://api.github.com/users/thomasyonug/followers", "following_url": "https://api.github.com/users/thomasyonug/following{/other_user}", "gists_url": "https://api.github.com/users/thomasyonug/gists{/gist_id}", "starred_url": "https://api.github.com/users/thomasyonug/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thomasyonug/subscriptions", "organizations_url": "https://api.github.com/users/thomasyonug/orgs", "repos_url": "https://api.github.com/users/thomasyonug/repos", "events_url": "https://api.github.com/users/thomasyonug/events{/privacy}", "received_events_url": "https://api.github.com/users/thomasyonug/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca246e573fb3f53fba5794f72b9245382eb46180", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca246e573fb3f53fba5794f72b9245382eb46180", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca246e573fb3f53fba5794f72b9245382eb46180"}], "stats": {"total": 789, "additions": 789, "deletions": 0}, "files": [{"sha": "97c068188b1b1e58e96a9d4f36915ff58efda5ee", "filename": "gcc/rust/checks/lints/rust-lint-marklive-base.h", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520b52b24e73d2ec48fd6f492266df42c218bdf2/gcc%2Frust%2Fchecks%2Flints%2Frust-lint-marklive-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520b52b24e73d2ec48fd6f492266df42c218bdf2/gcc%2Frust%2Fchecks%2Flints%2Frust-lint-marklive-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fchecks%2Flints%2Frust-lint-marklive-base.h?ref=520b52b24e73d2ec48fd6f492266df42c218bdf2", "patch": "@@ -0,0 +1,45 @@\n+// Copyright (C) 2021-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_LIVENESS_BASE\n+#define RUST_HIR_LIVENESS_BASE\n+\n+#include \"rust-diagnostics.h\"\n+#include \"rust-lint-marklive.h\"\n+#include \"rust-lint-marklive-base.h\"\n+#include \"rust-hir-visitor.h\"\n+#include \"rust-hir-map.h\"\n+\n+namespace Rust {\n+namespace Analysis {\n+\n+class MarkLiveBase : public HIR::HIRFullVisitorBase\n+{\n+public:\n+  virtual ~MarkLiveBase () {}\n+\n+protected:\n+  MarkLiveBase () : mappings (Analysis::Mappings::get ()) {}\n+\n+  Analysis::Mappings *mappings;\n+};\n+\n+} // namespace Analysis\n+} // namespace Rust\n+\n+#endif"}, {"sha": "245632b4b4c507d5c4acdb4511e9aec4d1554c15", "filename": "gcc/rust/checks/lints/rust-lint-marklive.cc", "status": "added", "additions": 282, "deletions": 0, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520b52b24e73d2ec48fd6f492266df42c218bdf2/gcc%2Frust%2Fchecks%2Flints%2Frust-lint-marklive.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520b52b24e73d2ec48fd6f492266df42c218bdf2/gcc%2Frust%2Fchecks%2Flints%2Frust-lint-marklive.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fchecks%2Flints%2Frust-lint-marklive.cc?ref=520b52b24e73d2ec48fd6f492266df42c218bdf2", "patch": "@@ -0,0 +1,282 @@\n+// Copyright (C) 2021-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// The idea is that all reachable symbols are live, codes called\n+// from live codes are live, and everything else is dead.\n+\n+#include \"rust-lint-marklive.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-name-resolver.h\"\n+\n+namespace Rust {\n+namespace Analysis {\n+\n+// This class trys to find the live symbols which can be used as\n+// seeds in MarkLive\n+//\n+// 1. TODO: explicit live\n+//    - Attribute like #[allow(dead_code)]\n+//    - Attribute like #[lang=\"..\"], it's not a intra-crate item.\n+// 2. TODO: foreign item\n+class FindEntryPoint : public MarkLiveBase\n+{\n+  using Rust::Analysis::MarkLiveBase::visit;\n+\n+public:\n+  static std::vector<HirId> find (HIR::Crate &crate)\n+  {\n+    FindEntryPoint findEntryPoint;\n+    for (auto it = crate.items.begin (); it != crate.items.end (); it++)\n+      {\n+\tit->get ()->accept_vis (findEntryPoint);\n+      }\n+    return findEntryPoint.getEntryPoint ();\n+  }\n+\n+  // TODO not only fn main can be a entry point.\n+  void visit (HIR::Function &function) override\n+  {\n+    if (function.get_function_name () == \"main\")\n+      {\n+\tentryPoints.push_back (function.get_mappings ().get_hirid ());\n+      }\n+  }\n+\n+private:\n+  FindEntryPoint () : MarkLiveBase () {}\n+  std::vector<HirId> entryPoints;\n+  std::vector<HirId> getEntryPoint () { return entryPoints; }\n+};\n+\n+std::set<HirId>\n+MarkLive::Analysis (HIR::Crate &crate)\n+{\n+  MarkLive marklive (FindEntryPoint::find (crate));\n+  marklive.go (crate);\n+\n+  return marklive.liveSymbols;\n+}\n+\n+// pop a live symbol from worklist every iteration,\n+// if it's a function then walk the function body, and\n+// 1. save all the live symbols in worklist which is\n+//    visited first time\n+// 2. save all the live symbols in liveSymbols\n+void\n+MarkLive::go (HIR::Crate &crate)\n+{\n+  while (!worklist.empty ())\n+    {\n+      HirId hirId = worklist.back ();\n+      worklist.pop_back ();\n+      scannedSymbols.emplace (hirId);\n+      HIR::Item *item = mappings->lookup_hir_item (hirId);\n+      liveSymbols.emplace (hirId);\n+      if (item != nullptr)\n+\t{\n+\t  item->accept_vis (*this);\n+\t}\n+      else\n+\t{ // the item maybe inside a trait impl\n+\t  HirId parent_impl_id = UNKNOWN_HIRID;\n+\t  HIR::ImplItem *implItem\n+\t    = mappings->lookup_hir_implitem (hirId, &parent_impl_id);\n+\t  if (implItem != nullptr)\n+\t    implItem->accept_vis (*this);\n+\t}\n+    }\n+}\n+\n+void\n+MarkLive::visit (HIR::PathInExpression &expr)\n+{\n+  // We should iterate every path segment in order to mark the struct which\n+  // is used in expression like Foo::bar(), we should mark the Foo alive.\n+  expr.iterate_path_segments ([&] (HIR::PathExprSegment &seg) -> bool {\n+    return visit_path_segment (seg);\n+  });\n+\n+  // after iterate the path segments, we should mark functions and associated\n+  // functions alive.\n+  NodeId ast_node_id = expr.get_mappings ().get_nodeid ();\n+  NodeId ref_node_id = UNKNOWN_NODEID;\n+  find_ref_node_id (ast_node_id, ref_node_id);\n+\n+  // node back to HIR\n+  HirId ref;\n+  bool ok = mappings->lookup_node_to_hir (ref_node_id, &ref);\n+  rust_assert (ok);\n+\n+  // it must resolve to some kind of HIR::Item or HIR::InheritImplItem\n+  HIR::Item *resolved_item = mappings->lookup_hir_item (ref);\n+  if (resolved_item != nullptr)\n+    {\n+      mark_hir_id (resolved_item->get_mappings ().get_hirid ());\n+    }\n+  else\n+    {\n+      HirId parent_impl_id = UNKNOWN_HIRID;\n+      HIR::ImplItem *resolved_item\n+\t= mappings->lookup_hir_implitem (ref, &parent_impl_id);\n+      if (resolved_item != nullptr)\n+\t{\n+\t  mark_hir_id (resolved_item->get_impl_mappings ().get_hirid ());\n+\t}\n+    }\n+}\n+\n+void\n+MarkLive::visit (HIR::MethodCallExpr &expr)\n+{\n+  expr.get_receiver ()->accept_vis (*this);\n+  visit_path_segment (expr.get_method_name ());\n+  for (auto &argument : expr.get_arguments ())\n+    argument->accept_vis (*this);\n+\n+  // Trying to find the method definition and mark it alive.\n+  NodeId ast_node_id = expr.get_mappings ().get_nodeid ();\n+  NodeId ref_node_id = UNKNOWN_NODEID;\n+  find_ref_node_id (ast_node_id, ref_node_id);\n+\n+  // node back to HIR\n+  HirId ref;\n+  bool ok = mappings->lookup_node_to_hir (ref_node_id, &ref);\n+  rust_assert (ok);\n+  mark_hir_id (ref);\n+}\n+\n+bool\n+MarkLive::visit_path_segment (HIR::PathExprSegment seg)\n+{\n+  NodeId ast_node_id = seg.get_mappings ().get_nodeid ();\n+  NodeId ref_node_id = UNKNOWN_NODEID;\n+\n+  // There are two different kinds of segment for us.\n+  // 1. function segment\n+  //      like the symbol \"foo\" in expression `foo()`.\n+  // 2. type segment\n+  //      like the symbol \"Foo\" in expression `Foo{a: 1, b: 2}`\n+  //\n+  // We should mark them alive all and ignoring other kind of segments.\n+  // If the segment we dont care then just return false is fine\n+  if (!resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n+    {\n+      if (!resolver->lookup_resolved_type (ast_node_id, &ref_node_id))\n+\treturn false;\n+    }\n+  HirId ref;\n+  bool ok = mappings->lookup_node_to_hir (ref_node_id, &ref);\n+  rust_assert (ok);\n+  mark_hir_id (ref);\n+  return true;\n+}\n+\n+void\n+MarkLive::visit (HIR::FieldAccessExpr &expr)\n+{\n+  // visit receiver at first\n+  expr.get_receiver_expr ()->accept_vis (*this);\n+\n+  // resolve the receiver back to ADT type\n+  TyTy::BaseType *receiver = nullptr;\n+  if (!tyctx->lookup_type (\n+\texpr.get_receiver_expr ()->get_mappings ().get_hirid (), &receiver))\n+    {\n+      rust_error_at (expr.get_receiver_expr ()->get_locus (),\n+\t\t     \"unresolved type for receiver\");\n+    }\n+\n+  TyTy::ADTType *adt = nullptr;\n+  if (receiver->get_kind () == TyTy::TypeKind::ADT)\n+    {\n+      adt = static_cast<TyTy::ADTType *> (receiver);\n+    }\n+  else if (receiver->get_kind () == TyTy::TypeKind::REF)\n+    {\n+      TyTy::ReferenceType *r = static_cast<TyTy::ReferenceType *> (receiver);\n+      TyTy::BaseType *b = r->get_base ();\n+      rust_assert (b->get_kind () == TyTy::TypeKind::ADT);\n+\n+      adt = static_cast<TyTy::ADTType *> (b);\n+    }\n+\n+  rust_assert (adt != nullptr);\n+  rust_assert (!adt->is_enum ());\n+  rust_assert (adt->number_of_variants () == 1);\n+\n+  TyTy::VariantDef *variant = adt->get_variants ().at (0);\n+\n+  // get the field index\n+  size_t index;\n+  TyTy::StructFieldType *field;\n+  bool ok = variant->lookup_field (expr.get_field_name (), &field, &index);\n+  rust_assert (ok);\n+  if (index >= variant->num_fields ())\n+    {\n+      rust_error_at (expr.get_receiver_expr ()->get_locus (),\n+\t\t     \"cannot access struct %s by index: %lu\",\n+\t\t     adt->get_name ().c_str (), (unsigned long) index);\n+      return;\n+    }\n+\n+  // get the field hir id\n+  HirId field_id = field->get_ref ();\n+  mark_hir_id (field_id);\n+}\n+\n+void\n+MarkLive::visit (HIR::TupleIndexExpr &expr)\n+{\n+  // TODO: unused tuple field detection\n+  expr.get_tuple_expr ()->accept_vis (*this);\n+}\n+\n+void\n+MarkLive::visit (HIR::TypeAlias &alias)\n+{\n+  NodeId ast_node_id;\n+  resolver->lookup_resolved_type (\n+    alias.get_type_aliased ()->get_mappings ().get_nodeid (), &ast_node_id);\n+  HirId hir_id;\n+  bool ok = mappings->lookup_node_to_hir (ast_node_id, &hir_id);\n+  rust_assert (ok);\n+  mark_hir_id (hir_id);\n+}\n+\n+void\n+MarkLive::mark_hir_id (HirId id)\n+{\n+  if (scannedSymbols.find (id) == scannedSymbols.end ())\n+    {\n+      worklist.push_back (id);\n+    }\n+  liveSymbols.emplace (id);\n+}\n+\n+void\n+MarkLive::find_ref_node_id (NodeId ast_node_id, NodeId &ref_node_id)\n+{\n+  if (!resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n+    {\n+      bool ok = resolver->lookup_resolved_type (ast_node_id, &ref_node_id);\n+      rust_assert (ok);\n+    }\n+}\n+\n+} // namespace Analysis\n+} // namespace Rust"}, {"sha": "119af8b8c9545d4cd26a3c199a4cdbb5913ff455", "filename": "gcc/rust/checks/lints/rust-lint-marklive.h", "status": "added", "additions": 308, "deletions": 0, "changes": 308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520b52b24e73d2ec48fd6f492266df42c218bdf2/gcc%2Frust%2Fchecks%2Flints%2Frust-lint-marklive.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520b52b24e73d2ec48fd6f492266df42c218bdf2/gcc%2Frust%2Fchecks%2Flints%2Frust-lint-marklive.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fchecks%2Flints%2Frust-lint-marklive.h?ref=520b52b24e73d2ec48fd6f492266df42c218bdf2", "patch": "@@ -0,0 +1,308 @@\n+// Copyright (C) 2021-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_LIVENESS\n+#define RUST_HIR_LIVENESS\n+\n+#include \"rust-hir-full-decls.h\"\n+#include \"rust-hir-map.h\"\n+#include \"rust-lint-marklive-base.h\"\n+#include \"rust-name-resolver.h\"\n+\n+namespace Rust {\n+namespace Analysis {\n+\n+class MarkLive : public MarkLiveBase\n+{\n+  using Rust::Analysis::MarkLiveBase::visit;\n+\n+public:\n+  static std::set<HirId> Analysis (HIR::Crate &crate);\n+  void go (HIR::Crate &crate);\n+\n+  void visit (HIR::PathInExpression &expr) override;\n+  void visit (HIR::FieldAccessExpr &expr) override;\n+  void visit (HIR::TupleIndexExpr &expr) override;\n+  void visit (HIR::MethodCallExpr &expr) override;\n+  void visit (HIR::TypeAlias &alias) override;\n+\n+  void visit (HIR::BorrowExpr &expr) override\n+  {\n+    expr.get_expr ()->accept_vis (*this);\n+  }\n+\n+  void visit (HIR::DereferenceExpr &expr) override\n+  {\n+    expr.get_expr ()->accept_vis (*this);\n+  }\n+\n+  void visit (HIR::NegationExpr &expr) override\n+  {\n+    expr.get_expr ()->accept_vis (*this);\n+  }\n+\n+  void visit (HIR::LazyBooleanExpr &expr) override\n+  {\n+    expr.get_lhs ()->accept_vis (*this);\n+    expr.get_rhs ()->accept_vis (*this);\n+  }\n+\n+  void visit (HIR::TypeCastExpr &expr) override\n+  {\n+    expr.get_expr ()->accept_vis (*this);\n+  }\n+\n+  void visit (HIR::GroupedExpr &expr) override\n+  {\n+    expr.get_expr_in_parens ()->accept_vis (*this);\n+  }\n+\n+  void visit (HIR::ArrayExpr &expr) override\n+  {\n+    expr.get_internal_elements ()->accept_vis (*this);\n+  }\n+\n+  void visit (HIR::ArrayIndexExpr &expr) override\n+  {\n+    expr.get_array_expr ()->accept_vis (*this);\n+    expr.get_index_expr ()->accept_vis (*this);\n+  }\n+\n+  void visit (HIR::ArrayElemsValues &expr) override\n+  {\n+    for (auto &elem : expr.get_values ())\n+      {\n+\telem->accept_vis (*this);\n+      }\n+  }\n+\n+  void visit (HIR::TupleExpr &expr) override\n+  {\n+    for (auto &elem : expr.get_tuple_elems ())\n+      {\n+\telem->accept_vis (*this);\n+      }\n+  }\n+\n+  void visit (HIR::BlockExpr &expr) override\n+  {\n+    for (auto &s : expr.get_statements ())\n+      {\n+\ts->accept_vis (*this);\n+      }\n+    if (expr.has_expr ())\n+      {\n+\texpr.get_final_expr ()->accept_vis (*this);\n+      }\n+  }\n+\n+  void visit (HIR::UnsafeBlockExpr &expr) override\n+  {\n+    expr.get_block_expr ()->accept_vis (*this);\n+  }\n+\n+  void visit (HIR::LoopExpr &expr) override\n+  {\n+    expr.get_loop_block ()->accept_vis (*this);\n+  }\n+\n+  void visit (HIR::BreakExpr &expr) override\n+  {\n+    if (expr.has_break_expr ())\n+      expr.get_expr ()->accept_vis (*this);\n+  }\n+\n+  void visit (HIR::WhileLoopExpr &expr) override\n+  {\n+    expr.get_loop_block ()->accept_vis (*this);\n+    expr.get_predicate_expr ()->accept_vis (*this);\n+  }\n+\n+  void visit (HIR::Function &function) override\n+  {\n+    function.get_definition ()->accept_vis (*this);\n+  }\n+\n+  void visit (HIR::ReturnExpr &expr) override\n+  {\n+    if (expr.has_return_expr ())\n+      expr.get_expr ()->accept_vis (*this);\n+  }\n+\n+  void visit (HIR::WhileLetLoopExpr &expr) override\n+  {\n+    expr.get_loop_block ()->accept_vis (*this);\n+    expr.get_cond ()->accept_vis (*this);\n+  }\n+\n+  void visit (HIR::ForLoopExpr &expr) override\n+  {\n+    expr.get_loop_block ()->accept_vis (*this);\n+    expr.get_iterator_expr ()->accept_vis (*this);\n+  }\n+\n+  void visit (HIR::ExprStmtWithoutBlock &stmt) override\n+  {\n+    stmt.get_expr ()->accept_vis (*this);\n+  }\n+\n+  void visit (HIR::ExprStmtWithBlock &stmt) override\n+  {\n+    stmt.get_expr ()->accept_vis (*this);\n+  }\n+\n+  void visit (HIR::CallExpr &expr) override\n+  {\n+    expr.get_fnexpr ()->accept_vis (*this);\n+    for (auto &argument : expr.get_arguments ())\n+      argument->accept_vis (*this);\n+  }\n+\n+  void visit (HIR::ArithmeticOrLogicalExpr &expr) override\n+  {\n+    expr.visit_lhs (*this);\n+    expr.visit_rhs (*this);\n+  }\n+  void visit (HIR::ComparisonExpr &expr) override\n+  {\n+    expr.get_lhs ()->accept_vis (*this);\n+    expr.get_rhs ()->accept_vis (*this);\n+  }\n+\n+  void visit (HIR::AssignmentExpr &expr) override\n+  {\n+    expr.visit_lhs (*this);\n+    expr.visit_rhs (*this);\n+  }\n+\n+  void visit (HIR::CompoundAssignmentExpr &expr) override\n+  {\n+    expr.visit_lhs (*this);\n+    expr.visit_rhs (*this);\n+  }\n+\n+  void visit (HIR::IfExpr &expr) override\n+  {\n+    expr.get_if_condition ()->accept_vis (*this);\n+    expr.get_if_block ()->accept_vis (*this);\n+  }\n+\n+  void visit (HIR::IfExprConseqElse &expr) override\n+  {\n+    expr.get_if_condition ()->accept_vis (*this);\n+    expr.get_if_block ()->accept_vis (*this);\n+    expr.get_else_block ()->accept_vis (*this);\n+  }\n+\n+  void visit (HIR::MatchExpr &expr) override\n+  {\n+    expr.get_scrutinee_expr ()->accept_vis (*this);\n+    std::vector<HIR::MatchCase> &cases = expr.get_match_cases ();\n+    for (auto &&caz : cases)\n+      {\n+\tauto case_arm = caz.get_arm ();\n+\tif (case_arm.has_match_arm_guard ())\n+\t  case_arm.get_guard_expr ()->accept_vis (*this);\n+\tcaz.get_expr ()->accept_vis (*this);\n+      }\n+  }\n+\n+  void visit (HIR::IfExprConseqIf &expr) override\n+  {\n+    expr.get_if_condition ()->accept_vis (*this);\n+    expr.get_if_block ()->accept_vis (*this);\n+    expr.get_conseq_if_expr ()->accept_vis (*this);\n+  }\n+\n+  void visit (HIR::TraitItemFunc &item) override\n+  {\n+    item.get_block_expr ()->accept_vis (*this);\n+  }\n+\n+  void visit (HIR::ImplBlock &impl) override\n+  {\n+    for (auto &&item : impl.get_impl_items ())\n+      {\n+\titem->accept_vis (*this);\n+      }\n+  }\n+\n+  void visit (HIR::LetStmt &stmt) override\n+  {\n+    if (stmt.has_init_expr ())\n+      {\n+\tstmt.get_init_expr ()->accept_vis (*this);\n+      }\n+  }\n+\n+  void visit (HIR::StructExprStruct &stct) override\n+  {\n+    stct.get_struct_name ().accept_vis (*this);\n+  }\n+\n+  void visit (HIR::StructExprStructFields &stct) override\n+  {\n+    for (auto &field : stct.get_fields ())\n+      {\n+\tfield->accept_vis (*this);\n+      }\n+\n+    stct.get_struct_name ().accept_vis (*this);\n+    if (stct.has_struct_base ())\n+      {\n+\tstct.struct_base->base_struct->accept_vis (*this);\n+      }\n+  }\n+\n+  virtual void visit (HIR::StructExprFieldIdentifierValue &field) override\n+  {\n+    field.get_value ()->accept_vis (*this);\n+  }\n+\n+  void visit (HIR::StructExprStructBase &stct) override\n+  {\n+    stct.get_struct_base ()->base_struct->accept_vis (*this);\n+  }\n+\n+  void visit (HIR::Module &module) override\n+  {\n+    for (auto &item : module.get_items ())\n+      item->accept_vis (*this);\n+  }\n+\n+private:\n+  std::vector<HirId> worklist;\n+  std::set<HirId> liveSymbols;\n+  std::set<HirId> scannedSymbols;\n+  Analysis::Mappings *mappings;\n+  Resolver::Resolver *resolver;\n+  Resolver::TypeCheckContext *tyctx;\n+  MarkLive (std::vector<HirId> worklist)\n+    : worklist (worklist), mappings (Analysis::Mappings::get ()),\n+      resolver (Resolver::Resolver::get ()),\n+      tyctx (Resolver::TypeCheckContext::get ()){};\n+\n+  void mark_hir_id (HirId);\n+  bool visit_path_segment (HIR::PathExprSegment);\n+  void find_ref_node_id (NodeId ast_node_id, NodeId &ref_node_id);\n+};\n+\n+} // namespace Analysis\n+} // namespace Rust\n+\n+#endif"}, {"sha": "591cb30bc24d158c10d7dd498e20eb0ca914c0db", "filename": "gcc/rust/checks/lints/rust-lint-scan-deadcode.h", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520b52b24e73d2ec48fd6f492266df42c218bdf2/gcc%2Frust%2Fchecks%2Flints%2Frust-lint-scan-deadcode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520b52b24e73d2ec48fd6f492266df42c218bdf2/gcc%2Frust%2Fchecks%2Flints%2Frust-lint-scan-deadcode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fchecks%2Flints%2Frust-lint-scan-deadcode.h?ref=520b52b24e73d2ec48fd6f492266df42c218bdf2", "patch": "@@ -0,0 +1,154 @@\n+// Copyright (C) 2021-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_SCAN_DEADCODE\n+#define RUST_HIR_SCAN_DEADCODE\n+\n+#include \"rust-hir-full-decls.h\"\n+#include \"rust-hir-map.h\"\n+#include \"rust-lint-marklive.h\"\n+#include \"rust-name-resolver.h\"\n+#include \"rust-diagnostics.h\"\n+\n+namespace Rust {\n+namespace Analysis {\n+\n+// Scan item symbols and warn the symbol if it is not in the live_symbols set.\n+// There are three kinds of item we should handle in this pass.\n+// 1. Function item\n+// 2. The function item in the impl block without trait\n+// 3. StructStruct, e.g., `Struct Foo{one: 1, two: 2}`. Furthermore, the unused\n+//    struct fields will be warned too.\n+// 4. TupleStruct, e.g., `Struct Foo(i32, i32)`\n+class ScanDeadcode : public MarkLiveBase\n+{\n+  using Rust::Analysis::MarkLiveBase::visit;\n+\n+public:\n+  static void Scan (HIR::Crate &crate)\n+  {\n+    std::set<HirId> live_symbols = Analysis::MarkLive::Analysis (crate);\n+    ScanDeadcode sdc (live_symbols);\n+    for (auto it = crate.items.begin (); it != crate.items.end (); it++)\n+      {\n+\tit->get ()->accept_vis (sdc);\n+      }\n+  };\n+\n+  void visit (HIR::Function &function) override\n+  {\n+    HirId hirId = function.get_mappings ().get_hirid ();\n+    if (should_warn (hirId))\n+      {\n+\tif (mappings->is_impl_item (hirId))\n+\t  {\n+\t    HIR::ImplBlock *implBlock\n+\t      = mappings->lookup_associated_impl (hirId);\n+\t    if (!implBlock->has_trait_ref ())\n+\t      {\n+\t\trust_warning_at (function.get_locus (), 0,\n+\t\t\t\t \"associated function is never used: %<%s%>\",\n+\t\t\t\t function.get_function_name ().c_str ());\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    rust_warning_at (function.get_locus (), 0,\n+\t\t\t     \"function is never used: %<%s%>\",\n+\t\t\t     function.get_function_name ().c_str ());\n+\t  }\n+      }\n+  }\n+\n+  void visit (HIR::StructStruct &stct) override\n+  {\n+    HirId hirId = stct.get_mappings ().get_hirid ();\n+    if (should_warn (hirId))\n+      {\n+\tbool name_starts_underscore = stct.get_identifier ().at (0) == '_';\n+\tif (!name_starts_underscore)\n+\t  rust_warning_at (stct.get_locus (), 0,\n+\t\t\t   \"struct is never constructed: %<%s%>\",\n+\t\t\t   stct.get_identifier ().c_str ());\n+      }\n+    else\n+      {\n+\t// only warn the unused fields when in unwarned struct.\n+\tfor (auto &field : stct.get_fields ())\n+\t  {\n+\t    HirId field_hir_id = field.get_mappings ().get_hirid ();\n+\t    if (should_warn (field_hir_id))\n+\t      {\n+\t\trust_warning_at (field.get_locus (), 0,\n+\t\t\t\t \"field is never read: %<%s%>\",\n+\t\t\t\t field.get_field_name ().c_str ());\n+\t      }\n+\t  }\n+      }\n+  }\n+\n+  void visit (HIR::TupleStruct &stct) override\n+  {\n+    // only warn tuple struct unconstructed, and ignoring unused field\n+    HirId hirId = stct.get_mappings ().get_hirid ();\n+    if (should_warn (hirId))\n+      {\n+\trust_warning_at (stct.get_locus (), 0,\n+\t\t\t \"struct is never constructed: %<%s%>\",\n+\t\t\t stct.get_identifier ().c_str ());\n+      }\n+  }\n+\n+  void visit (HIR::ImplBlock &blc) override\n+  {\n+    if (blc.has_impl_items ())\n+      {\n+\tfor (auto &implItem : blc.get_impl_items ())\n+\t  {\n+\t    implItem->accept_vis (*this);\n+\t  }\n+      }\n+  }\n+\n+  void visit (HIR::Module &mod) override\n+  {\n+    for (auto &item : mod.get_items ())\n+      item->accept_vis (*this);\n+  }\n+\n+private:\n+  std::set<HirId> live_symbols;\n+  Resolver::Resolver *resolver;\n+  Analysis::Mappings *mappings;\n+\n+  ScanDeadcode (std::set<HirId> &live_symbols)\n+    : live_symbols (live_symbols), resolver (Resolver::Resolver::get ()),\n+      mappings (Analysis::Mappings::get ()){};\n+\n+  bool should_warn (HirId hirId)\n+  {\n+    // TODO: There are more condition to check if should warn, i.e visibility,\n+    // attributes.\n+    return live_symbols.find (hirId) == live_symbols.end ();\n+  }\n+};\n+\n+} // namespace Analysis\n+} // namespace Rust\n+\n+#endif"}]}