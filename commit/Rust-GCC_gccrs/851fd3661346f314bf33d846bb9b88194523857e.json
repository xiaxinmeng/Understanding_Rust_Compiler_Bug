{"sha": "851fd3661346f314bf33d846bb9b88194523857e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODUxZmQzNjYxMzQ2ZjMxNGJmMzNkODQ2YmI5Yjg4MTk0NTIzODU3ZQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2018-07-19T12:19:07Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2018-07-19T12:19:07Z"}, "message": "tree-ssa-sccvn.h (struct vn_phi_s): Make phiargs member a trailing array.\n\n2018-07-19  Richard Biener  <rguenther@suse.de>\n\n\t* tree-ssa-sccvn.h (struct vn_phi_s): Make phiargs member\n\ta trailing array.\n\t* tree-ssa-sccvn.c: Remove alloc-pool.h use.\n\t(vn_phi_hasher): Derive from nofree_ptr_hash and remove remove method.\n\t(vn_reference_hasher): Likewise.\n\t(struct vn_tables_s): Remove obstack and alloc-pool members.\n\t(vn_tables_obstack, vn_tables_insert_obstack): New global obstacks.\n\t(vn_nary_build_or_lookup_1): Manually build in vn_tables_insert_obstack.\n\t(vn_reference_insert): Allocate from obstack instead of from alloc-pool.\n\t(vn_reference_insert_pieces): Likewise.\n\t(alloc_vn_nary_op_noinit): Adjust.\n\t(vn_nary_op_insert_stmt): Allocate phiargs in-place.\n\t(vn_phi_eq): Adjust.\n\t(shared_lookup_phiargs): Remove.\n\t(vn_phi_lookup): Allocate temporary vn_phi_s on the stack.\n\t(vn_phi_insert): Allocate from obstack instead of from alloc-pool.\n\t(visit_reference_op_call): Likewise.\n\t(copy_nary, copy_phi, copy_reference): Remove.\n\t(process_scc): Rewind the obstack when iterating.  Do not\n\tcopy the elements to valid_info but just move them from one\n\thashtable to the other.\n\t(allocate_vn_table): Adjust.\n\t(free_vn_table): Likewise.\n\t(init_scc_vn): Likewise.\n\t(free_scc_vn): Likewise.\n\nFrom-SVN: r262879", "tree": {"sha": "44764015b393324b246686a32099b8ef51045a93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44764015b393324b246686a32099b8ef51045a93"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/851fd3661346f314bf33d846bb9b88194523857e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/851fd3661346f314bf33d846bb9b88194523857e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/851fd3661346f314bf33d846bb9b88194523857e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/851fd3661346f314bf33d846bb9b88194523857e/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ea298fe5e6de519926d4aa121885d041c191e397", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea298fe5e6de519926d4aa121885d041c191e397", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea298fe5e6de519926d4aa121885d041c191e397"}], "stats": {"total": 261, "additions": 130, "deletions": 131}, "files": [{"sha": "164f1e549a756afac1c452d2bef39bec05fcc805", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851fd3661346f314bf33d846bb9b88194523857e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851fd3661346f314bf33d846bb9b88194523857e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=851fd3661346f314bf33d846bb9b88194523857e", "patch": "@@ -1,3 +1,31 @@\n+2018-07-19  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-ssa-sccvn.h (struct vn_phi_s): Make phiargs member\n+\ta trailing array.\n+\t* tree-ssa-sccvn.c: Remove alloc-pool.h use.\n+\t(vn_phi_hasher): Derive from nofree_ptr_hash and remove remove method.\n+\t(vn_reference_hasher): Likewise.\n+\t(struct vn_tables_s): Remove obstack and alloc-pool members.\n+\t(vn_tables_obstack, vn_tables_insert_obstack): New global obstacks.\n+\t(vn_nary_build_or_lookup_1): Manually build in vn_tables_insert_obstack.\n+\t(vn_reference_insert): Allocate from obstack instead of from alloc-pool.\n+\t(vn_reference_insert_pieces): Likewise.\n+\t(alloc_vn_nary_op_noinit): Adjust.\n+\t(vn_nary_op_insert_stmt): Allocate phiargs in-place.\n+\t(vn_phi_eq): Adjust.\n+\t(shared_lookup_phiargs): Remove.\n+\t(vn_phi_lookup): Allocate temporary vn_phi_s on the stack.\n+\t(vn_phi_insert): Allocate from obstack instead of from alloc-pool.\n+\t(visit_reference_op_call): Likewise.\n+\t(copy_nary, copy_phi, copy_reference): Remove.\n+\t(process_scc): Rewind the obstack when iterating.  Do not\n+\tcopy the elements to valid_info but just move them from one\n+\thashtable to the other.\n+\t(allocate_vn_table): Adjust.\n+\t(free_vn_table): Likewise.\n+\t(init_scc_vn): Likewise.\n+\t(free_scc_vn): Likewise.\n+\n 2018-07-19  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/86560"}, {"sha": "b3ed4d60c70ead616c4d5aaf86d53ca32ad7f291", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 100, "deletions": 130, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851fd3661346f314bf33d846bb9b88194523857e/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851fd3661346f314bf33d846bb9b88194523857e/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=851fd3661346f314bf33d846bb9b88194523857e", "patch": "@@ -25,7 +25,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"rtl.h\"\n #include \"tree.h\"\n #include \"gimple.h\"\n-#include \"alloc-pool.h\"\n #include \"ssa.h\"\n #include \"expmed.h\"\n #include \"insn-config.h\"\n@@ -169,11 +168,10 @@ typedef vn_nary_op_table_type::iterator vn_nary_op_iterator_type;\n static int\n vn_phi_eq (const_vn_phi_t const vp1, const_vn_phi_t const vp2);\n \n-struct vn_phi_hasher : pointer_hash <vn_phi_s>\n+struct vn_phi_hasher : nofree_ptr_hash <vn_phi_s>\n { \n   static inline hashval_t hash (const vn_phi_s *);\n   static inline bool equal (const vn_phi_s *, const vn_phi_s *);\n-  static inline void remove (vn_phi_s *);\n };\n \n /* Return the computed hashcode for phi operation P1.  */\n@@ -192,14 +190,6 @@ vn_phi_hasher::equal (const vn_phi_s *vp1, const vn_phi_s *vp2)\n   return vn_phi_eq (vp1, vp2);\n }\n \n-/* Free a phi operation structure VP.  */\n-\n-inline void\n-vn_phi_hasher::remove (vn_phi_s *phi)\n-{\n-  phi->phiargs.release ();\n-}\n-\n typedef hash_table<vn_phi_hasher> vn_phi_table_type;\n typedef vn_phi_table_type::iterator vn_phi_iterator_type;\n \n@@ -235,11 +225,10 @@ free_reference (vn_reference_s *vr)\n \n /* vn_reference hashtable helpers.  */\n \n-struct vn_reference_hasher : pointer_hash <vn_reference_s>\n+struct vn_reference_hasher : nofree_ptr_hash <vn_reference_s>\n {\n   static inline hashval_t hash (const vn_reference_s *);\n   static inline bool equal (const vn_reference_s *, const vn_reference_s *);\n-  static inline void remove (vn_reference_s *);\n };\n \n /* Return the hashcode for a given reference operation P1.  */\n@@ -256,26 +245,17 @@ vn_reference_hasher::equal (const vn_reference_s *v, const vn_reference_s *c)\n   return vn_reference_eq (v, c);\n }\n \n-inline void\n-vn_reference_hasher::remove (vn_reference_s *v)\n-{\n-  free_reference (v);\n-}\n-\n typedef hash_table<vn_reference_hasher> vn_reference_table_type;\n typedef vn_reference_table_type::iterator vn_reference_iterator_type;\n \n \n-/* The set of hashtables and alloc_pool's for their items.  */\n+/* The set of VN hashtables.  */\n \n typedef struct vn_tables_s\n {\n   vn_nary_op_table_type *nary;\n   vn_phi_table_type *phis;\n   vn_reference_table_type *references;\n-  struct obstack nary_obstack;\n-  object_allocator<vn_phi_s> *phis_pool;\n-  object_allocator<vn_reference_s> *references_pool;\n } *vn_tables_t;\n \n \n@@ -310,25 +290,26 @@ static hash_table<vn_constant_hasher> *constant_to_value_id;\n static bitmap constant_value_ids;\n \n \n+/* Obstack we allocate the vn-tables elements from.  */\n+static obstack vn_tables_obstack;\n+/* Special obstack we never unwind.  */\n+static obstack vn_tables_insert_obstack;\n+\n /* Valid hashtables storing information we have proven to be\n    correct.  */\n-\n static vn_tables_t valid_info;\n \n /* Optimistic hashtables storing information we are making assumptions about\n    during iterations.  */\n-\n static vn_tables_t optimistic_info;\n \n /* Pointer to the set of hashtables that is currently being used.\n    Should always point to either the optimistic_info, or the\n    valid_info.  */\n-\n static vn_tables_t current_info;\n \n \n /* Reverse post order index for each basic block.  */\n-\n static int *rpo_numbers;\n \n #define SSA_VAL(x) (VN_INFO ((x))->valnum)\n@@ -1647,7 +1628,12 @@ vn_reference_lookup_or_insert_for_pieces (tree vuse,\n \t\t\t\t     operands.copy (), value, value_id);\n }\n \n-static vn_nary_op_t vn_nary_op_insert_stmt (gimple *stmt, tree result);\n+static vn_nary_op_t vn_nary_op_insert_stmt (gimple *, tree);\n+static unsigned int vn_nary_length_from_stmt (gimple *);\n+static vn_nary_op_t alloc_vn_nary_op_noinit (unsigned int, obstack *);\n+static vn_nary_op_t vn_nary_op_insert_into (vn_nary_op_t,\n+\t\t\t\t\t    vn_nary_op_table_type *, bool);\n+static void init_vn_nary_op_from_stmt (vn_nary_op_t, gimple *);\n \n /* Hook for maybe_push_res_to_seq, lookup the expression in the VN tables.  */\n \n@@ -1751,9 +1737,14 @@ vn_nary_build_or_lookup_1 (gimple_match_op *res_op, bool insert)\n \t lookups there will fall back to the valid table.  */\n       else if (current_info == optimistic_info)\n \t{\n-\t  current_info = valid_info;\n-\t  vn_nary_op_insert_stmt (new_stmt, result);\n-\t  current_info = optimistic_info;\n+\t  unsigned int length = vn_nary_length_from_stmt (new_stmt);\n+\t  vn_nary_op_t vno1\n+\t    = alloc_vn_nary_op_noinit (length, &vn_tables_insert_obstack);\n+\t  vno1->value_id = VN_INFO (result)->value_id;\n+\t  vno1->length = length;\n+\t  vno1->result = result;\n+\t  init_vn_nary_op_from_stmt (vno1, new_stmt);\n+\t  vn_nary_op_insert_into (vno1, valid_info->nary, true);\n \t}\n       else\n \tvn_nary_op_insert_stmt (new_stmt, result);\n@@ -2620,7 +2611,7 @@ vn_reference_insert (tree op, tree result, tree vuse, tree vdef)\n   vn_reference_t vr1;\n   bool tem;\n \n-  vr1 = current_info->references_pool->allocate ();\n+  vr1 = XOBNEW (&vn_tables_obstack, vn_reference_s);\n   if (TREE_CODE (result) == SSA_NAME)\n     vr1->value_id = VN_INFO (result)->value_id;\n   else\n@@ -2665,7 +2656,7 @@ vn_reference_insert_pieces (tree vuse, alias_set_type set, tree type,\n   vn_reference_s **slot;\n   vn_reference_t vr1;\n \n-  vr1 = current_info->references_pool->allocate ();\n+  vr1 = XOBNEW (&vn_tables_obstack, vn_reference_s);\n   vr1->value_id = value_id;\n   vr1->vuse = vuse ? SSA_VAL (vuse) : NULL_TREE;\n   vr1->operands = valueize_refs (operands);\n@@ -2931,8 +2922,7 @@ alloc_vn_nary_op_noinit (unsigned int length, struct obstack *stack)\n static vn_nary_op_t\n alloc_vn_nary_op (unsigned int length, tree result, unsigned int value_id)\n {\n-  vn_nary_op_t vno1 = alloc_vn_nary_op_noinit (length,\n-\t\t\t\t\t       &current_info->nary_obstack);\n+  vn_nary_op_t vno1 = alloc_vn_nary_op_noinit (length, &vn_tables_obstack);\n \n   vno1->value_id = value_id;\n   vno1->length = length;\n@@ -3016,8 +3006,8 @@ vn_nary_op_insert_stmt (gimple *stmt, tree result)\n static inline hashval_t\n vn_phi_compute_hash (vn_phi_t vp1)\n {\n-  inchash::hash hstate (vp1->phiargs.length () > 2\n-\t\t\t? vp1->block->index : vp1->phiargs.length ());\n+  inchash::hash hstate (EDGE_COUNT (vp1->block->preds) > 2\n+\t\t\t? vp1->block->index : EDGE_COUNT (vp1->block->preds));\n   tree phi1op;\n   tree type;\n   edge e;\n@@ -3089,10 +3079,10 @@ vn_phi_eq (const_vn_phi_t const vp1, const_vn_phi_t const vp2)\n \n   if (vp1->block != vp2->block)\n     {\n-      if (vp1->phiargs.length () != vp2->phiargs.length ())\n+      if (EDGE_COUNT (vp1->block->preds) != EDGE_COUNT (vp2->block->preds))\n \treturn false;\n \n-      switch (vp1->phiargs.length ())\n+      switch (EDGE_COUNT (vp1->block->preds))\n \t{\n \tcase 1:\n \t  /* Single-arg PHIs are just copies.  */\n@@ -3167,10 +3157,9 @@ vn_phi_eq (const_vn_phi_t const vp1, const_vn_phi_t const vp2)\n \n   /* Any phi in the same block will have it's arguments in the\n      same edge order, because of how we store phi nodes.  */\n-  int i;\n-  tree phi1op;\n-  FOR_EACH_VEC_ELT (vp1->phiargs, i, phi1op)\n+  for (unsigned i = 0; i < EDGE_COUNT (vp1->block->preds); ++i)\n     {\n+      tree phi1op = vp1->phiargs[i];\n       tree phi2op = vp2->phiargs[i];\n       if (phi1op == VN_TOP || phi2op == VN_TOP)\n \tcontinue;\n@@ -3181,8 +3170,6 @@ vn_phi_eq (const_vn_phi_t const vp1, const_vn_phi_t const vp2)\n   return true;\n }\n \n-static vec<tree> shared_lookup_phiargs;\n-\n /* Lookup PHI in the current hash table, and return the resulting\n    value number if it exists in the hash table.  Return NULL_TREE if\n    it does not exist in the hash table. */\n@@ -3191,38 +3178,38 @@ static tree\n vn_phi_lookup (gimple *phi)\n {\n   vn_phi_s **slot;\n-  struct vn_phi_s vp1;\n+  struct vn_phi_s *vp1;\n   edge e;\n   edge_iterator ei;\n \n-  shared_lookup_phiargs.truncate (0);\n-  shared_lookup_phiargs.safe_grow (gimple_phi_num_args (phi));\n+  vp1 = XALLOCAVAR (struct vn_phi_s,\n+\t\t    sizeof (struct vn_phi_s)\n+\t\t    + (gimple_phi_num_args (phi) - 1) * sizeof (tree));\n \n   /* Canonicalize the SSA_NAME's to their value number.  */\n   FOR_EACH_EDGE (e, ei, gimple_bb (phi)->preds)\n     {\n       tree def = PHI_ARG_DEF_FROM_EDGE (phi, e);\n       def = TREE_CODE (def) == SSA_NAME ? SSA_VAL (def) : def;\n-      shared_lookup_phiargs[e->dest_idx] = def;\n+      vp1->phiargs[e->dest_idx] = def;\n     }\n-  vp1.type = TREE_TYPE (gimple_phi_result (phi));\n-  vp1.phiargs = shared_lookup_phiargs;\n-  vp1.block = gimple_bb (phi);\n+  vp1->type = TREE_TYPE (gimple_phi_result (phi));\n+  vp1->block = gimple_bb (phi);\n   /* Extract values of the controlling condition.  */\n-  vp1.cclhs = NULL_TREE;\n-  vp1.ccrhs = NULL_TREE;\n-  basic_block idom1 = get_immediate_dominator (CDI_DOMINATORS, vp1.block);\n+  vp1->cclhs = NULL_TREE;\n+  vp1->ccrhs = NULL_TREE;\n+  basic_block idom1 = get_immediate_dominator (CDI_DOMINATORS, vp1->block);\n   if (EDGE_COUNT (idom1->succs) == 2)\n     if (gcond *last1 = safe_dyn_cast <gcond *> (last_stmt (idom1)))\n       {\n-\tvp1.cclhs = vn_valueize (gimple_cond_lhs (last1));\n-\tvp1.ccrhs = vn_valueize (gimple_cond_rhs (last1));\n+\tvp1->cclhs = vn_valueize (gimple_cond_lhs (last1));\n+\tvp1->ccrhs = vn_valueize (gimple_cond_rhs (last1));\n       }\n-  vp1.hashcode = vn_phi_compute_hash (&vp1);\n-  slot = current_info->phis->find_slot_with_hash (&vp1, vp1.hashcode,\n+  vp1->hashcode = vn_phi_compute_hash (vp1);\n+  slot = current_info->phis->find_slot_with_hash (vp1, vp1->hashcode,\n \t\t\t\t\t\t  NO_INSERT);\n   if (!slot && current_info == optimistic_info)\n-    slot = valid_info->phis->find_slot_with_hash (&vp1, vp1.hashcode,\n+    slot = valid_info->phis->find_slot_with_hash (vp1, vp1->hashcode,\n \t\t\t\t\t\t  NO_INSERT);\n   if (!slot)\n     return NULL_TREE;\n@@ -3236,23 +3223,22 @@ static vn_phi_t\n vn_phi_insert (gimple *phi, tree result)\n {\n   vn_phi_s **slot;\n-  vn_phi_t vp1 = current_info->phis_pool->allocate ();\n-  vec<tree> args = vNULL;\n+  vn_phi_t vp1 = (vn_phi_t) obstack_alloc (&vn_tables_obstack,\n+\t\t\t\t\t   sizeof (vn_phi_s)\n+\t\t\t\t\t   + ((gimple_phi_num_args (phi) - 1)\n+\t\t\t\t\t      * sizeof (tree)));\n   edge e;\n   edge_iterator ei;\n \n-  args.safe_grow (gimple_phi_num_args (phi));\n-\n   /* Canonicalize the SSA_NAME's to their value number.  */\n   FOR_EACH_EDGE (e, ei, gimple_bb (phi)->preds)\n     {\n       tree def = PHI_ARG_DEF_FROM_EDGE (phi, e);\n       def = TREE_CODE (def) == SSA_NAME ? SSA_VAL (def) : def;\n-      args[e->dest_idx] = def;\n+      vp1->phiargs[e->dest_idx] = def;\n     }\n   vp1->value_id = VN_INFO (result)->value_id;\n   vp1->type = TREE_TYPE (gimple_phi_result (phi));\n-  vp1->phiargs = args;\n   vp1->block = gimple_bb (phi);\n   /* Extract values of the controlling condition.  */\n   vp1->cclhs = NULL_TREE;\n@@ -3781,7 +3767,7 @@ visit_reference_op_call (tree lhs, gcall *stmt)\n \t}\n       if (lhs)\n \tchanged |= set_ssa_val_to (lhs, lhs);\n-      vr2 = current_info->references_pool->allocate ();\n+      vr2 = XOBNEW (&vn_tables_obstack, vn_reference_s);\n       vr2->vuse = vr1.vuse;\n       /* As we are not walking the virtual operand chain we know the\n \t shared_lookup_references are still original so we can re-use\n@@ -4317,48 +4303,6 @@ sort_scc (vec<tree> scc)\n   scc.qsort (compare_ops);\n }\n \n-/* Insert the no longer used nary ONARY to the hash INFO.  */\n-\n-static void\n-copy_nary (vn_nary_op_t onary, vn_tables_t info)\n-{\n-  size_t size = sizeof_vn_nary_op (onary->length);\n-  vn_nary_op_t nary = alloc_vn_nary_op_noinit (onary->length,\n-\t\t\t\t\t       &info->nary_obstack);\n-  memcpy (nary, onary, size);\n-  vn_nary_op_insert_into (nary, info->nary, false);\n-}\n-\n-/* Insert the no longer used phi OPHI to the hash INFO.  */\n-\n-static void\n-copy_phi (vn_phi_t ophi, vn_tables_t info)\n-{\n-  vn_phi_t phi = info->phis_pool->allocate ();\n-  vn_phi_s **slot;\n-  memcpy (phi, ophi, sizeof (*phi));\n-  ophi->phiargs.create (0);\n-  slot = info->phis->find_slot_with_hash (phi, phi->hashcode, INSERT);\n-  gcc_assert (!*slot);\n-  *slot = phi;\n-}\n-\n-/* Insert the no longer used reference OREF to the hash INFO.  */\n-\n-static void\n-copy_reference (vn_reference_t oref, vn_tables_t info)\n-{\n-  vn_reference_t ref;\n-  vn_reference_s **slot;\n-  ref = info->references_pool->allocate ();\n-  memcpy (ref, oref, sizeof (*ref));\n-  oref->operands.create (0);\n-  slot = info->references->find_slot_with_hash (ref, ref->hashcode, INSERT);\n-  if (*slot)\n-    free_reference (*slot);\n-  *slot = ref;\n-}\n-\n /* Process a strongly connected component in the SSA graph.  */\n \n static void\n@@ -4410,33 +4354,60 @@ process_scc (vec<tree> scc)\n       /* As we are value-numbering optimistically we have to\n \t clear the expression tables and the simplified expressions\n \t in each iteration until we converge.  */\n-      optimistic_info->nary->empty ();\n-      optimistic_info->phis->empty ();\n-      optimistic_info->references->empty ();\n-      obstack_free (&optimistic_info->nary_obstack, NULL);\n-      gcc_obstack_init (&optimistic_info->nary_obstack);\n-      optimistic_info->phis_pool->release ();\n-      optimistic_info->references_pool->release ();\n+      gcc_assert (optimistic_info->nary->elements () == 0\n+\t\t  && optimistic_info->phis->elements () == 0\n+\t\t  && optimistic_info->references->elements () == 0);\n+      void *ob_top = obstack_alloc (&vn_tables_obstack, 0);\n       FOR_EACH_VEC_ELT (scc, i, var)\n \tgcc_assert (!VN_INFO (var)->needs_insertion\n \t\t    && VN_INFO (var)->expr == NULL);\n       FOR_EACH_VEC_ELT (scc, i, var)\n \tchanged |= visit_use (var);\n+      if (changed)\n+\t{\n+\t  optimistic_info->nary->empty ();\n+\t  optimistic_info->phis->empty ();\n+\t  FOR_EACH_HASH_TABLE_ELEMENT (*optimistic_info->references,\n+\t\t\t\t       ref, vn_reference_t, hir)\n+\t    {\n+\t      ref->operands.release ();\n+\t      optimistic_info->references->clear_slot (&*hir);\n+\t    }\n+\t  optimistic_info->references->empty ();\n+\t  obstack_free (&vn_tables_obstack, ob_top);\n+\t}\n     }\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"Processing SCC needed %d iterations\\n\", iterations);\n   statistics_histogram_event (cfun, \"SCC iterations\", iterations);\n \n-  /* Finally, copy the contents of the no longer used optimistic\n-     table to the valid table.  */\n+  /* Finally, move the contents of the no longer used optimistic\n+     table to the valid table and clear the optimistic table.  */\n   FOR_EACH_HASH_TABLE_ELEMENT (*optimistic_info->nary, nary, vn_nary_op_t, hin)\n-    copy_nary (nary, valid_info);\n+    {\n+      optimistic_info->nary->clear_slot (&*hin);\n+      vn_nary_op_insert_into (nary, valid_info->nary, false);\n+    }\n   FOR_EACH_HASH_TABLE_ELEMENT (*optimistic_info->phis, phi, vn_phi_t, hip)\n-    copy_phi (phi, valid_info);\n+    {\n+      optimistic_info->phis->clear_slot (&*hip);\n+      vn_phi_s **slot\n+\t= valid_info->phis->find_slot_with_hash (phi, phi->hashcode, INSERT);\n+      gcc_assert (!*slot);\n+      *slot = phi;\n+    }\n   FOR_EACH_HASH_TABLE_ELEMENT (*optimistic_info->references,\n \t\t\t       ref, vn_reference_t, hir)\n-    copy_reference (ref, valid_info);\n+    {\n+      optimistic_info->references->clear_slot (&*hir);\n+      vn_reference_s **slot\n+\t= valid_info->references->find_slot_with_hash (ref, ref->hashcode,\n+\t\t\t\t\t\t       INSERT);\n+      if (*slot)\n+\tfree_reference (*slot);\n+      *slot = ref;\n+    }\n \n   current_info = valid_info;\n }\n@@ -4596,27 +4567,24 @@ allocate_vn_table (vn_tables_t table)\n   table->phis = new vn_phi_table_type (23);\n   table->nary = new vn_nary_op_table_type (23);\n   table->references = new vn_reference_table_type (23);\n-\n-  gcc_obstack_init (&table->nary_obstack);\n-  table->phis_pool = new object_allocator<vn_phi_s> (\"VN phis\");\n-  table->references_pool = new object_allocator<vn_reference_s>\n-    (\"VN references\");\n }\n \n /* Free a value number table.  */\n \n static void\n free_vn_table (vn_tables_t table)\n {\n+  /* Walk over elements and release vectors.  */\n+  vn_reference_iterator_type hir;\n+  vn_reference_t vr;\n+  FOR_EACH_HASH_TABLE_ELEMENT (*table->references, vr, vn_reference_t, hir)\n+    vr->operands.release ();\n   delete table->phis;\n   table->phis = NULL;\n   delete table->nary;\n   table->nary = NULL;\n   delete table->references;\n   table->references = NULL;\n-  obstack_free (&table->nary_obstack, NULL);\n-  delete table->phis_pool;\n-  delete table->references_pool;\n }\n \n static void\n@@ -4642,7 +4610,6 @@ init_scc_vn (void)\n   vn_ssa_aux_table.safe_grow_cleared (num_ssa_names + 1);\n   gcc_obstack_init (&vn_ssa_aux_obstack);\n \n-  shared_lookup_phiargs.create (0);\n   shared_lookup_references.create (0);\n   rpo_numbers = XNEWVEC (int, last_basic_block_for_fn (cfun));\n   rpo_numbers_temp =\n@@ -4663,6 +4630,8 @@ init_scc_vn (void)\n   renumber_gimple_stmt_uids ();\n \n   /* Create the valid and optimistic value numbering tables.  */\n+  gcc_obstack_init (&vn_tables_obstack);\n+  gcc_obstack_init (&vn_tables_insert_obstack);\n   valid_info = XCNEW (struct vn_tables_s);\n   allocate_vn_table (valid_info);\n   optimistic_info = XCNEW (struct vn_tables_s);\n@@ -4765,7 +4734,6 @@ free_scc_vn (void)\n   delete constant_to_value_id;\n   constant_to_value_id = NULL;\n   BITMAP_FREE (constant_value_ids);\n-  shared_lookup_phiargs.release ();\n   shared_lookup_references.release ();\n   XDELETEVEC (rpo_numbers);\n \n@@ -4783,6 +4751,8 @@ free_scc_vn (void)\n   XDELETE (valid_info);\n   free_vn_table (optimistic_info);\n   XDELETE (optimistic_info);\n+  obstack_free (&vn_tables_obstack, NULL);\n+  obstack_free (&vn_tables_insert_obstack, NULL);\n \n   BITMAP_FREE (const_parms);\n }"}, {"sha": "4a3bdae5c8a5c8ab4de7905d8a516aa13f92320d", "filename": "gcc/tree-ssa-sccvn.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851fd3661346f314bf33d846bb9b88194523857e/gcc%2Ftree-ssa-sccvn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851fd3661346f314bf33d846bb9b88194523857e/gcc%2Ftree-ssa-sccvn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.h?ref=851fd3661346f314bf33d846bb9b88194523857e", "patch": "@@ -65,13 +65,14 @@ typedef struct vn_phi_s\n   /* Unique identifier that all expressions with the same value have. */\n   unsigned int value_id;\n   hashval_t hashcode;\n-  vec<tree> phiargs;\n   basic_block block;\n   /* Controlling condition lhs/rhs.  */\n   tree cclhs;\n   tree ccrhs;\n   tree type;\n   tree result;\n+  /* The number of args is determined by EDGE_COUT (block->preds).  */\n+  tree phiargs[1];\n } *vn_phi_t;\n typedef const struct vn_phi_s *const_vn_phi_t;\n "}]}