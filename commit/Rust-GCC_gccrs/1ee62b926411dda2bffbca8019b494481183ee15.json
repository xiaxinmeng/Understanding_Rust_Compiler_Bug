{"sha": "1ee62b926411dda2bffbca8019b494481183ee15", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWVlNjJiOTI2NDExZGRhMmJmZmJjYTgwMTliNDk0NDgxMTgzZWUxNQ==", "commit": {"author": {"name": "Prasad Ghangal", "email": "prasad.ghangal@gmail.com", "date": "2016-11-14T13:51:48Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2016-11-14T13:51:48Z"}, "message": "Make-lang.in (C_AND_OBJC_OBJS): Add gimple-parser.o.\n\n2016-11-14  Prasad Ghangal  <prasad.ghangal@gmail.com>\n\tRichard Biener  <rguenther@suse.de>\n    \n    \tc/\n    \t* Make-lang.in (C_AND_OBJC_OBJS): Add gimple-parser.o.\n    \t* config-lang.in (gtfiles): Add c/c-parser.h.\n    \t* c-tree.h (enum c_declspec_word): Add cdw_gimple.\n    \t(struct c_declspecs): Add gimple_pass member and gimple_p flag.\n    \t* c-parser.c (enum c_id_kind, struct c_token,\n    \tc_parser_next_token_is, c_parser_next_token_is_not,\n    \tc_parser_next_token_is_keyword,\n    \tenum c_lookahead_kind, enum c_dtr_syn, enum c_parser_prec):\n    \tSplit out to ...\n    \t* c-parser.h: ... new header.\n    \t* c-parser.c: Include c-parser.h and gimple-parser.h.\n\t(c_parser_peek_token, c_parser_peek_2nd_token,\n    \tc_token_starts_typename, c_parser_next_token_starts_declspecs,\n    \tc_parser_next_tokens_start_declaration, c_parser_consume_token,\n    \tc_parser_error, c_parser_require, c_parser_skip_until_found,\n    \tc_parser_declspecs, c_parser_declarator, c_parser_peek_nth_token,\n    \tc_parser_type_name): Export.\n    \t(c_parser_tokens_buf): New function.\n    \t(c_parser_error): Likewise.\n    \t(c_parser_set_error): Likewise.\n    \t(c_parser_declspecs): Handle RID_GIMPLE.\n\t(c_parser_declaration_or_fndef): Parse __GIMPLE marked body\n\tvia c_parser_parse_gimple_body.\n    \t* c-parser.h (c_parser_peek_token, c_parser_peek_2nd_token,\n    \tc_token_starts_typename, c_parser_next_token_starts_declspecs,\n    \tc_parser_next_tokens_start_declaration, c_parser_consume_token,\n    \tc_parser_error, c_parser_require, c_parser_skip_until_found,\n    \tc_parser_declspecs, c_parser_declarator, c_parser_peek_nth_token,\n    \tc_parser_type_name): Declare.\n\t(struct c_parser): Declare forward.\n\t(c_parser_tokens_buf): Declare.\n        (c_parser_error): Likewise.\n        (c_parser_set_error): Likewise.\n    \t* gimple-parser.c: New file.\n    \t* gimple-parser.h: Likewise.\n    \n    \tobj-c/\n    \t* config-lang.in (gtfiles): Add c/c-parser.h.\n\n    \tc-family/\n    \t* c-common.h (c_common_resword): Add RID_GIMPLE, RID_PHI types.\n    \t* c-common.h (enum rid): Add RID_GIMPLE, RID_PHI.\n    \t* c.opt (fgimple): New option.\n\n\t* doc/invoke.texi (fgimple): Document.\n \n    \t* dumpfile.h (TDF_GIMPLE): Add.\n    \t* dumpfile.c (dump_options): Add gimple.\n    \t* gimple-pretty-print.c (dump_gimple_switch): Adjust dump\n\tfor TDF_GIMPLE.\n\t(dump_gimple_label): Likewise.\n\t(dump_gimple_phi): Likewise.\n\t(dump_gimple_bb_header): Likewise.\n\t(dump_phi_nodes): Likewise.\n\t(pp_cfg_jump): Likewise.  Pass in dump flags.\n\t(dump_implicit_edges): Adjust.\n    \t* passes.c (pass_init_dump_file): Do not dump function header\n    \tfor TDF_GIMPLE.\n    \t* tree-cfg.c (dump_function_to_file): Dump function return type\n\tand __GIMPLE keyword for TDF_GIMPLE.  Change guard for dumping\n\tGIMPLE stmts.\n    \t* tree-pretty-print.c (dump_decl_name): Adjust dump for TDF_GIMPLE.\n    \t(dump_generic_node): Likewise.\n\n\t* function.h (struct function): Add pass_startwith member.\n\t* passes.c (execute_one_pass): Implement startwith.\n\n    \t* tree-ssanames.c (make_ssa_name_fn): New argument, check for version\n    \tand assign proper version for parsed ssa names.\n    \t* tree-ssanames.h (make_ssa_name_fn): Add new argument to the function.\n    \t* internal-fn.c (expand_PHI): New function.\n    \t* internal-fn.h (expand_PHI): Declared here.\n    \t* internal-fn.def: New defination for PHI.\n    \t* tree-cfg.c (lower_phi_internal_fn): New function.\n\t(build_gimple_cfg): Call it.\n    \t(verify_gimple_call): Condition for passing label as arg in internal\n    \tfunction PHI.\n\t* tree-into-ssa.c (rewrite_add_phi_arguments): Handle already\n\tpresent PHIs with arguments.\n\n    \ttestsuite/\n    \t* gcc.dg/gimplefe-1.c: New testcase.\n    \t* gcc.dg/gimplefe-2.c: Likewise.\n    \t* gcc.dg/gimplefe-3.c: Likewise.\n    \t* gcc.dg/gimplefe-4.c: Likewise.\n    \t* gcc.dg/gimplefe-5.c: Likewise.\n    \t* gcc.dg/gimplefe-6.c: Likewise.\n    \t* gcc.dg/gimplefe-7.c: Likewise.\n    \t* gcc.dg/gimplefe-8.c: Likewise.\n    \t* gcc.dg/gimplefe-9.c: Likewise.\n    \t* gcc.dg/gimplefe-10.c: Likewise.\n    \t* gcc.dg/gimplefe-11.c: Likewise.\n    \t* gcc.dg/gimplefe-12.c: Likewise.\n    \t* gcc.dg/gimplefe-13.c: Likewise.\n    \t* gcc.dg/gimplefe-14.c: Likewise.\n    \t* gcc.dg/gimplefe-15.c: Likewise.\n    \t* gcc.dg/gimplefe-16.c: Likewise.\n    \t* gcc.dg/gimplefe-17.c: Likewise.\n    \t* gcc.dg/gimplefe-18.c: Likewise.\n\nCo-Authored-By: Richard Biener <rguenther@suse.de>\n\nFrom-SVN: r242387", "tree": {"sha": "8d83980f6ddcd52182f277bc95f6bdd8c523ebf2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d83980f6ddcd52182f277bc95f6bdd8c523ebf2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ee62b926411dda2bffbca8019b494481183ee15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ee62b926411dda2bffbca8019b494481183ee15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ee62b926411dda2bffbca8019b494481183ee15", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ee62b926411dda2bffbca8019b494481183ee15/comments", "author": {"login": "PrasadG193", "id": 7098659, "node_id": "MDQ6VXNlcjcwOTg2NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/7098659?v=4", "gravatar_id": "", "url": "https://api.github.com/users/PrasadG193", "html_url": "https://github.com/PrasadG193", "followers_url": "https://api.github.com/users/PrasadG193/followers", "following_url": "https://api.github.com/users/PrasadG193/following{/other_user}", "gists_url": "https://api.github.com/users/PrasadG193/gists{/gist_id}", "starred_url": "https://api.github.com/users/PrasadG193/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/PrasadG193/subscriptions", "organizations_url": "https://api.github.com/users/PrasadG193/orgs", "repos_url": "https://api.github.com/users/PrasadG193/repos", "events_url": "https://api.github.com/users/PrasadG193/events{/privacy}", "received_events_url": "https://api.github.com/users/PrasadG193/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4d2098539a53d9e2dddd6233fb68820715d95862", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d2098539a53d9e2dddd6233fb68820715d95862", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d2098539a53d9e2dddd6233fb68820715d95862"}], "stats": {"total": 655, "additions": 447, "deletions": 208}, "files": [{"sha": "4fea3461b765951034eaec3dcbb3a9ae400bea31", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1ee62b926411dda2bffbca8019b494481183ee15", "patch": "@@ -1,3 +1,39 @@\n+2016-11-14  Prasad Ghangal  <prasad.ghangal@gmail.com>\n+\tRichard Biener  <rguenther@suse.de>\n+    \n+\t* doc/invoke.texi (fgimple): Document.\n+    \t* dumpfile.h (TDF_GIMPLE): Add.\n+    \t* dumpfile.c (dump_options): Add gimple.\n+    \t* gimple-pretty-print.c (dump_gimple_switch): Adjust dump\n+\tfor TDF_GIMPLE.\n+\t(dump_gimple_label): Likewise.\n+\t(dump_gimple_phi): Likewise.\n+\t(dump_gimple_bb_header): Likewise.\n+\t(dump_phi_nodes): Likewise.\n+\t(pp_cfg_jump): Likewise.  Pass in dump flags.\n+\t(dump_implicit_edges): Adjust.\n+    \t* passes.c (pass_init_dump_file): Do not dump function header\n+    \tfor TDF_GIMPLE.\n+    \t* tree-cfg.c (dump_function_to_file): Dump function return type\n+\tand __GIMPLE keyword for TDF_GIMPLE.  Change guard for dumping\n+\tGIMPLE stmts.\n+    \t* tree-pretty-print.c (dump_decl_name): Adjust dump for TDF_GIMPLE.\n+    \t(dump_generic_node): Likewise.\n+\t* function.h (struct function): Add pass_startwith member.\n+\t* passes.c (execute_one_pass): Implement startwith.\n+    \t* tree-ssanames.c (make_ssa_name_fn): New argument, check for version\n+    \tand assign proper version for parsed ssa names.\n+    \t* tree-ssanames.h (make_ssa_name_fn): Add new argument to the function.\n+    \t* internal-fn.c (expand_PHI): New function.\n+    \t* internal-fn.h (expand_PHI): Declared here.\n+    \t* internal-fn.def: New defination for PHI.\n+    \t* tree-cfg.c (lower_phi_internal_fn): New function.\n+\t(build_gimple_cfg): Call it.\n+    \t(verify_gimple_call): Condition for passing label as arg in internal\n+    \tfunction PHI.\n+\t* tree-into-ssa.c (rewrite_add_phi_arguments): Handle already\n+\tpresent PHIs with arguments.\n+\n 2016-11-14  Martin Liska  <mliska@suse.cz>\n \n \tPR bootstrap/78069"}, {"sha": "2360d9ed17c6e2cc4ed2af6d27b081d88a601009", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=1ee62b926411dda2bffbca8019b494481183ee15", "patch": "@@ -1,3 +1,10 @@\n+2016-11-14  Prasad Ghangal  <prasad.ghangal@gmail.com>\n+\tRichard Biener  <rguenther@suse.de>\n+    \n+    \t* c-common.h (c_common_resword): Add RID_GIMPLE, RID_PHI types.\n+    \t* c-common.h (enum rid): Add RID_GIMPLE, RID_PHI.\n+    \t* c.opt (fgimple): New option.\n+\n 2016-11-13  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* c-ada-spec.c (print_ada_declaration): For typedef declarations, look"}, {"sha": "2997c83925f36d761ce3933ff816e0acd3ed38de", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=1ee62b926411dda2bffbca8019b494481183ee15", "patch": "@@ -435,6 +435,8 @@ const struct c_common_resword c_common_reswords[] =\n   { \"__underlying_type\", RID_UNDERLYING_TYPE, D_CXXONLY },\n   { \"__volatile\",\tRID_VOLATILE,\t0 },\n   { \"__volatile__\",\tRID_VOLATILE,\t0 },\n+  { \"__GIMPLE\",\t\tRID_GIMPLE,\tD_CONLY },\n+  { \"__PHI\",\t\tRID_PHI,\tD_CONLY },\n   { \"alignas\",\t\tRID_ALIGNAS,\tD_CXXONLY | D_CXX11 | D_CXXWARN },\n   { \"alignof\",\t\tRID_ALIGNOF,\tD_CXXONLY | D_CXX11 | D_CXXWARN },\n   { \"asm\",\t\tRID_ASM,\tD_ASM },"}, {"sha": "241b3454e06478cc0a4e589263b258ceeb2aa457", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=1ee62b926411dda2bffbca8019b494481183ee15", "patch": "@@ -118,6 +118,12 @@ enum rid\n \n   RID_FRACT, RID_ACCUM, RID_AUTO_TYPE, RID_BUILTIN_CALL_WITH_STATIC_CHAIN,\n \n+  /* \"__GIMPLE\", for the GIMPLE-parsing extension to the C frontend. */\n+  RID_GIMPLE,\n+\n+  /* \"__PHI\", for parsing PHI function in GIMPLE FE.  */\n+  RID_PHI,\n+\n   /* C11 */\n   RID_ALIGNAS, RID_GENERIC,\n "}, {"sha": "722d3800cf0b9303a6eebbb1d88818f4fc7710e9", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=1ee62b926411dda2bffbca8019b494481183ee15", "patch": "@@ -200,6 +200,10 @@ F\n Driver C ObjC C++ ObjC++ Joined Separate MissingArgError(missing path after %qs)\n -F <dir>\tAdd <dir> to the end of the main framework include path.\n \n+fgimple\n+C Var(flag_gimple) Init(0)\n+Enable parsing GIMPLE.\n+\n H\n C ObjC C++ ObjC++\n Print the name of header files as they are used."}, {"sha": "75f39d7ed8b40a78083be1d64d508fa77a731952", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=1ee62b926411dda2bffbca8019b494481183ee15", "patch": "@@ -1,3 +1,42 @@\n+2016-11-14  Prasad Ghangal  <prasad.ghangal@gmail.com>\n+\tRichard Biener  <rguenther@suse.de>\n+    \n+    \t* Make-lang.in (C_AND_OBJC_OBJS): Add gimple-parser.o.\n+    \t* config-lang.in (gtfiles): Add c/c-parser.h.\n+    \t* c-tree.h (enum c_declspec_word): Add cdw_gimple.\n+    \t(struct c_declspecs): Add gimple_pass member and gimple_p flag.\n+    \t* c-parser.c (enum c_id_kind, struct c_token,\n+    \tc_parser_next_token_is, c_parser_next_token_is_not,\n+    \tc_parser_next_token_is_keyword,\n+    \tenum c_lookahead_kind, enum c_dtr_syn, enum c_parser_prec):\n+    \tSplit out to ...\n+    \t* c-parser.h: ... new header.\n+    \t* c-parser.c: Include c-parser.h and gimple-parser.h.\n+\t(c_parser_peek_token, c_parser_peek_2nd_token,\n+    \tc_token_starts_typename, c_parser_next_token_starts_declspecs,\n+    \tc_parser_next_tokens_start_declaration, c_parser_consume_token,\n+    \tc_parser_error, c_parser_require, c_parser_skip_until_found,\n+    \tc_parser_declspecs, c_parser_declarator, c_parser_peek_nth_token,\n+    \tc_parser_type_name): Export.\n+    \t(c_parser_tokens_buf): New function.\n+    \t(c_parser_error): Likewise.\n+    \t(c_parser_set_error): Likewise.\n+    \t(c_parser_declspecs): Handle RID_GIMPLE.\n+\t(c_parser_declaration_or_fndef): Parse __GIMPLE marked body\n+\tvia c_parser_parse_gimple_body.\n+    \t* c-parser.h (c_parser_peek_token, c_parser_peek_2nd_token,\n+    \tc_token_starts_typename, c_parser_next_token_starts_declspecs,\n+    \tc_parser_next_tokens_start_declaration, c_parser_consume_token,\n+    \tc_parser_error, c_parser_require, c_parser_skip_until_found,\n+    \tc_parser_declspecs, c_parser_declarator, c_parser_peek_nth_token,\n+    \tc_parser_type_name): Declare.\n+\t(struct c_parser): Declare forward.\n+\t(c_parser_tokens_buf): Declare.\n+        (c_parser_error): Likewise.\n+        (c_parser_set_error): Likewise.\n+    \t* gimple-parser.c: New file.\n+    \t* gimple-parser.h: Likewise.\n+\n 2016-09-11  Le-Chun Wu  <lcwu@google.com>\n \t    Mark Wielaard  <mjw@redhat.com>\n "}, {"sha": "cd7108b8afab05162cf787be97364eaab088642a", "filename": "gcc/c/Make-lang.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Fc%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Fc%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FMake-lang.in?ref=1ee62b926411dda2bffbca8019b494481183ee15", "patch": "@@ -51,7 +51,8 @@ CFLAGS-c/gccspec.o += $(DRIVER_DEFINES)\n # Language-specific object files for C and Objective C.\n C_AND_OBJC_OBJS = attribs.o c/c-errors.o c/c-decl.o c/c-typeck.o \\\n   c/c-convert.o c/c-aux-info.o c/c-objc-common.o c/c-parser.o \\\n-  c/c-array-notation.o c/c-fold.o $(C_COMMON_OBJS) $(C_TARGET_OBJS)\n+  c/c-array-notation.o c/c-fold.o c/gimple-parser.o \\\n+  $(C_COMMON_OBJS) $(C_TARGET_OBJS)\n \n # Language-specific object files for C.\n C_OBJS = c/c-lang.o c-family/stub-objc.o $(C_AND_OBJC_OBJS)"}, {"sha": "00fe7312c4c836196737efe5cd4068c192316675", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 79, "deletions": 156, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=1ee62b926411dda2bffbca8019b494481183ee15", "patch": "@@ -59,6 +59,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-expr.h\"\n #include \"context.h\"\n #include \"gcc-rich-location.h\"\n+#include \"c-parser.h\"\n+#include \"gimple-parser.h\"\n \n /* We need to walk over decls with incomplete struct/union/enum types\n    after parsing the whole translation unit.\n@@ -150,63 +152,6 @@ c_parse_init (void)\n     }\n }\n \f\n-/* The C lexer intermediates between the lexer in cpplib and c-lex.c\n-   and the C parser.  Unlike the C++ lexer, the parser structure\n-   stores the lexer information instead of using a separate structure.\n-   Identifiers are separated into ordinary identifiers, type names,\n-   keywords and some other Objective-C types of identifiers, and some\n-   look-ahead is maintained.\n-\n-   ??? It might be a good idea to lex the whole file up front (as for\n-   C++).  It would then be possible to share more of the C and C++\n-   lexer code, if desired.  */\n-\n-/* More information about the type of a CPP_NAME token.  */\n-enum c_id_kind {\n-  /* An ordinary identifier.  */\n-  C_ID_ID,\n-  /* An identifier declared as a typedef name.  */\n-  C_ID_TYPENAME,\n-  /* An identifier declared as an Objective-C class name.  */\n-  C_ID_CLASSNAME,\n-  /* An address space identifier.  */\n-  C_ID_ADDRSPACE,\n-  /* Not an identifier.  */\n-  C_ID_NONE\n-};\n-\n-/* A single C token after string literal concatenation and conversion\n-   of preprocessing tokens to tokens.  */\n-struct GTY (()) c_token {\n-  /* The kind of token.  */\n-  ENUM_BITFIELD (cpp_ttype) type : 8;\n-  /* If this token is a CPP_NAME, this value indicates whether also\n-     declared as some kind of type.  Otherwise, it is C_ID_NONE.  */\n-  ENUM_BITFIELD (c_id_kind) id_kind : 8;\n-  /* If this token is a keyword, this value indicates which keyword.\n-     Otherwise, this value is RID_MAX.  */\n-  ENUM_BITFIELD (rid) keyword : 8;\n-  /* If this token is a CPP_PRAGMA, this indicates the pragma that\n-     was seen.  Otherwise it is PRAGMA_NONE.  */\n-  ENUM_BITFIELD (pragma_kind) pragma_kind : 8;\n-  /* The location at which this token was found.  */\n-  location_t location;\n-  /* The value associated with this token, if any.  */\n-  tree value;\n-  /* Token flags.  */\n-  unsigned char flags;\n-\n-  source_range get_range () const\n-  {\n-    return get_range_from_loc (line_table, location);\n-  }\n-\n-  location_t get_finish () const\n-  {\n-    return get_range ().m_finish;\n-  }\n-};\n-\n /* A parser structure recording information about the state and\n    context of parsing.  Includes lexer information with up to two\n    tokens of look-ahead; more are not needed for C.  */\n@@ -259,6 +204,30 @@ struct GTY(()) c_parser {\n   vec <c_token, va_gc> *cilk_simd_fn_tokens;\n };\n \n+/* Return a pointer to the Nth token in PARSERs tokens_buf.  */\n+\n+c_token *\n+c_parser_tokens_buf (c_parser *parser, unsigned n)\n+{\n+  return &parser->tokens_buf[n];\n+}\n+\n+/* Return the error state of PARSER.  */\n+\n+bool\n+c_parser_error (c_parser *parser)\n+{\n+  return parser->error;\n+}\n+\n+/* Set the error state of PARSER to ERR.  */\n+\n+void\n+c_parser_set_error (c_parser *parser, bool err)\n+{\n+  parser->error = err;\n+}\n+\n \n /* The actual parser and external interface.  ??? Does this need to be\n    garbage-collected?  */\n@@ -454,7 +423,7 @@ c_lex_one_token (c_parser *parser, c_token *token)\n /* Return a pointer to the next token from PARSER, reading it in if\n    necessary.  */\n \n-static inline c_token *\n+c_token *\n c_parser_peek_token (c_parser *parser)\n {\n   if (parser->tokens_avail == 0)\n@@ -465,37 +434,10 @@ c_parser_peek_token (c_parser *parser)\n   return &parser->tokens[0];\n }\n \n-/* Return true if the next token from PARSER has the indicated\n-   TYPE.  */\n-\n-static inline bool\n-c_parser_next_token_is (c_parser *parser, enum cpp_ttype type)\n-{\n-  return c_parser_peek_token (parser)->type == type;\n-}\n-\n-/* Return true if the next token from PARSER does not have the\n-   indicated TYPE.  */\n-\n-static inline bool\n-c_parser_next_token_is_not (c_parser *parser, enum cpp_ttype type)\n-{\n-  return !c_parser_next_token_is (parser, type);\n-}\n-\n-/* Return true if the next token from PARSER is the indicated\n-   KEYWORD.  */\n-\n-static inline bool\n-c_parser_next_token_is_keyword (c_parser *parser, enum rid keyword)\n-{\n-  return c_parser_peek_token (parser)->keyword == keyword;\n-}\n-\n /* Return a pointer to the next-but-one token from PARSER, reading it\n    in if necessary.  The next token is already read in.  */\n \n-static c_token *\n+c_token *\n c_parser_peek_2nd_token (c_parser *parser)\n {\n   if (parser->tokens_avail >= 2)\n@@ -511,7 +453,7 @@ c_parser_peek_2nd_token (c_parser *parser)\n /* Return a pointer to the Nth token from PARSER, reading it\n    in if necessary.  The N-1th token is already read in.  */\n \n-static c_token *\n+c_token *\n c_parser_peek_nth_token (c_parser *parser, unsigned int n)\n {\n   /* N is 1-based, not zero-based.  */\n@@ -570,7 +512,7 @@ c_keyword_starts_typename (enum rid keyword)\n \n /* Return true if TOKEN can start a type name,\n    false otherwise.  */\n-static bool\n+bool\n c_token_starts_typename (c_token *token)\n {\n   switch (token->type)\n@@ -601,18 +543,6 @@ c_token_starts_typename (c_token *token)\n     }\n }\n \n-enum c_lookahead_kind {\n-  /* Always treat unknown identifiers as typenames.  */\n-  cla_prefer_type,\n-\n-  /* Could be parsing a nonabstract declarator.  Only treat an identifier\n-     as a typename if followed by another identifier or a star.  */\n-  cla_nonabstract_decl,\n-\n-  /* Never treat identifiers as typenames.  */\n-  cla_prefer_id\n-};\n-\n /* Return true if the next token from PARSER can start a type name,\n    false otherwise.  LA specifies how to do lookahead in order to\n    detect unknown type names.  If unsure, pick CLA_PREFER_ID.  */\n@@ -779,7 +709,7 @@ c_token_starts_declaration (c_token *token)\n \n /* Return true if the next token from PARSER can start declaration\n    specifiers, false otherwise.  */\n-static inline bool\n+bool\n c_parser_next_token_starts_declspecs (c_parser *parser)\n {\n   c_token *token = c_parser_peek_token (parser);\n@@ -801,7 +731,7 @@ c_parser_next_token_starts_declspecs (c_parser *parser)\n \n /* Return true if the next tokens from PARSER can start declaration\n    specifiers or a static assertion, false otherwise.  */\n-static inline bool\n+bool\n c_parser_next_tokens_start_declaration (c_parser *parser)\n {\n   c_token *token = c_parser_peek_token (parser);\n@@ -829,7 +759,7 @@ c_parser_next_tokens_start_declaration (c_parser *parser)\n \n /* Consume the next token from PARSER.  */\n \n-static void\n+void\n c_parser_consume_token (c_parser *parser)\n {\n   gcc_assert (parser->tokens_avail >= 1);\n@@ -922,7 +852,7 @@ c_parser_peek_conflict_marker (c_parser *parser, enum cpp_ttype tok1_kind,\n    this way is not i18n-friendly and some other approach should be\n    used.  */\n \n-static void\n+void\n c_parser_error (c_parser *parser, const char *gmsgid)\n {\n   c_token *token = c_parser_peek_token (parser);\n@@ -965,7 +895,7 @@ c_parser_error (c_parser *parser, const char *gmsgid)\n    been produced and no message will be produced this time.  Returns\n    true if found, false otherwise.  */\n \n-static bool\n+bool\n c_parser_require (c_parser *parser,\n \t\t  enum cpp_ttype type,\n \t\t  const char *msgid)\n@@ -1008,7 +938,7 @@ c_parser_require_keyword (c_parser *parser,\n    already been produced and no message will be produced this\n    time.  */\n \n-static void\n+void\n c_parser_skip_until_found (c_parser *parser,\n \t\t\t   enum cpp_ttype type,\n \t\t\t   const char *msgid)\n@@ -1243,42 +1173,6 @@ restore_extension_diagnostics (int flags)\n   warn_c99_c11_compat = (flags >> 9) & 1 ? 1 : ((flags >> 10) & 1 ? -1 : 0);\n }\n \n-/* Possibly kinds of declarator to parse.  */\n-enum c_dtr_syn {\n-  /* A normal declarator with an identifier.  */\n-  C_DTR_NORMAL,\n-  /* An abstract declarator (maybe empty).  */\n-  C_DTR_ABSTRACT,\n-  /* A parameter declarator: may be either, but after a type name does\n-     not redeclare a typedef name as an identifier if it can\n-     alternatively be interpreted as a typedef name; see DR#009,\n-     applied in C90 TC1, omitted from C99 and reapplied in C99 TC2\n-     following DR#249.  For example, given a typedef T, \"int T\" and\n-     \"int *T\" are valid parameter declarations redeclaring T, while\n-     \"int (T)\" and \"int * (T)\" and \"int (T[])\" and \"int (T (int))\" are\n-     abstract declarators rather than involving redundant parentheses;\n-     the same applies with attributes inside the parentheses before\n-     \"T\".  */\n-  C_DTR_PARM\n-};\n-\n-/* The binary operation precedence levels, where 0 is a dummy lowest level\n-   used for the bottom of the stack.  */\n-enum c_parser_prec {\n-  PREC_NONE,\n-  PREC_LOGOR,\n-  PREC_LOGAND,\n-  PREC_BITOR,\n-  PREC_BITXOR,\n-  PREC_BITAND,\n-  PREC_EQ,\n-  PREC_REL,\n-  PREC_SHIFT,\n-  PREC_ADD,\n-  PREC_MULT,\n-  NUM_PRECS\n-};\n-\n /* Helper data structure for parsing #pragma acc routine.  */\n struct oacc_routine_data {\n   bool error_seen; /* Set if error has been reported.  */\n@@ -1295,15 +1189,11 @@ static void c_parser_declaration_or_fndef (c_parser *, bool, bool, bool,\n \t\t\t\t\t   bool * = NULL);\n static void c_parser_static_assert_declaration_no_semi (c_parser *);\n static void c_parser_static_assert_declaration (c_parser *);\n-static void c_parser_declspecs (c_parser *, struct c_declspecs *, bool, bool,\n-\t\t\t\tbool, bool, bool, enum c_lookahead_kind);\n static struct c_typespec c_parser_enum_specifier (c_parser *);\n static struct c_typespec c_parser_struct_or_union_specifier (c_parser *);\n static tree c_parser_struct_declaration (c_parser *);\n static struct c_typespec c_parser_typeof_specifier (c_parser *);\n static tree c_parser_alignas_specifier (c_parser *);\n-static struct c_declarator *c_parser_declarator (c_parser *, bool, c_dtr_syn,\n-\t\t\t\t\t\t bool *);\n static struct c_declarator *c_parser_direct_declarator (c_parser *, bool,\n \t\t\t\t\t\t\tc_dtr_syn, bool *);\n static struct c_declarator *c_parser_direct_declarator_inner (c_parser *,\n@@ -1315,7 +1205,6 @@ static struct c_arg_info *c_parser_parms_list_declarator (c_parser *, tree,\n static struct c_parm *c_parser_parameter_declaration (c_parser *, tree);\n static tree c_parser_simple_asm_expr (c_parser *);\n static tree c_parser_attributes (c_parser *);\n-static struct c_type_name *c_parser_type_name (c_parser *);\n static struct c_expr c_parser_initializer (c_parser *);\n static struct c_expr c_parser_braced_init (c_parser *, tree, bool,\n \t\t\t\t\t   struct obstack *);\n@@ -1652,7 +1541,13 @@ static void c_finish_oacc_routine (struct oacc_routine_data *, tree, bool);\n    OpenMP:\n \n    declaration:\n-     threadprivate-directive  */\n+     threadprivate-directive\n+\n+   GIMPLE:\n+\n+   gimple-function-definition:\n+     declaration-specifiers[opt] __GIMPLE (gimple-pass-list) declarator\n+       declaration-list[opt] compound-statement  */\n \n static void\n c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n@@ -1752,6 +1647,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n       c_parser_skip_to_end_of_block_or_statement (parser);\n       return;\n     }\n+\n   finish_declspecs (specs);\n   bool auto_type_p = specs->typespec_word == cts_auto_type;\n   if (c_parser_next_token_is (parser, CPP_SEMICOLON))\n@@ -1882,7 +1778,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n       struct c_declarator *declarator;\n       bool dummy = false;\n       timevar_id_t tv;\n-      tree fnbody;\n+      tree fnbody = NULL_TREE;\n       /* Declaring either one or more declarators (in which case we\n \t should diagnose if there were no declaration specifiers) or a\n \t function definition (in which case the diagnostic for\n@@ -2173,9 +2069,24 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \tc_finish_oacc_routine (oacc_routine_data, current_function_decl, true);\n       DECL_STRUCT_FUNCTION (current_function_decl)->function_start_locus\n \t= c_parser_peek_token (parser)->location;\n-      fnbody = c_parser_compound_statement (parser);\n-      if (flag_cilkplus && contains_array_notation_expr (fnbody))\n-\tfnbody = expand_array_notation_exprs (fnbody);\n+\n+      /* If the definition was marked with __GIMPLE then parse the\n+         function body as GIMPLE.  */\n+      if (specs->gimple_p)\n+\t{\n+\t  cfun->pass_startwith = specs->gimple_pass;\n+\t  bool saved = in_late_binary_op;\n+\t  in_late_binary_op = true;\n+\t  c_parser_parse_gimple_body (parser);\n+\t  in_late_binary_op = saved;\n+\t}\n+      else\n+\t{\n+\t  fnbody = c_parser_compound_statement (parser);\n+\t  if (flag_cilkplus && contains_array_notation_expr (fnbody))\n+\t    fnbody = expand_array_notation_exprs (fnbody);\n+\t}\n+      tree fndecl = current_function_decl;\n       if (nested)\n \t{\n \t  tree decl = current_function_decl;\n@@ -2191,9 +2102,13 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t}\n       else\n \t{\n-\t  add_stmt (fnbody);\n+\t  if (fnbody)\n+\t    add_stmt (fnbody);\n \t  finish_function ();\n \t}\n+      /* Get rid of the empty stmt list for GIMPLE.  */\n+      if (specs->gimple_p)\n+\tDECL_SAVED_TREE (fndecl) = NULL_TREE;\n \n       timevar_pop (tv);\n       break;\n@@ -2416,7 +2331,7 @@ c_parser_static_assert_declaration_no_semi (c_parser *parser)\n      objc-protocol-refs\n */\n \n-static void\n+void\n c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n \t\t    bool scspec_ok, bool typespec_ok, bool start_attr_ok,\n \t\t    bool alignspec_ok, bool auto_type_ok,\n@@ -2681,6 +2596,14 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n \t  align = c_parser_alignas_specifier (parser);\n \t  declspecs_add_alignas (loc, specs, align);\n \t  break;\n+\tcase RID_GIMPLE:\n+\t  if (! flag_gimple)\n+\t    error_at (loc, \"%<__GIMPLE%> only valid with -fgimple\");\n+\t  c_parser_consume_token (parser);\n+\t  specs->gimple_p = true;\n+\t  specs->locations[cdw_gimple] = loc;\n+\t  specs->gimple_pass = c_parser_gimple_pass_list (parser);\n+\t  break;\n \tdefault:\n \t  goto out;\n \t}\n@@ -3415,7 +3338,7 @@ c_parser_alignas_specifier (c_parser * parser)\n    This function also accepts an omitted abstract declarator as being\n    an abstract declarator, although not part of the formal syntax.  */\n \n-static struct c_declarator *\n+struct c_declarator *\n c_parser_declarator (c_parser *parser, bool type_seen_p, c_dtr_syn kind,\n \t\t     bool *seen_id)\n {\n@@ -4311,7 +4234,7 @@ c_parser_attributes (c_parser *parser)\n      specifier-qualifier-list abstract-declarator[opt]\n */\n \n-static struct c_type_name *\n+struct c_type_name *\n c_parser_type_name (c_parser *parser)\n {\n   struct c_declspecs *specs = build_null_declspecs ();"}, {"sha": "a8cf353eb4dc37c70043edbbf220c57a6fae67e3", "filename": "gcc/c/c-tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Fc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Fc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-tree.h?ref=1ee62b926411dda2bffbca8019b494481183ee15", "patch": "@@ -267,6 +267,7 @@ enum c_declspec_word {\n   cdw_saturating,\n   cdw_alignas,\n   cdw_address_space,\n+  cdw_gimple,\n   cdw_number_of_elements /* This one must always be the last\n \t\t\t    enumerator.  */\n };\n@@ -290,6 +291,8 @@ struct c_declspecs {\n      NULL; attributes (possibly from multiple lists) will be passed\n      separately.  */\n   tree attrs;\n+  /* The pass to start compiling a __GIMPLE function with.  */\n+  char *gimple_pass;\n   /* The base-2 log of the greatest alignment required by an _Alignas\n      specifier, in bytes, or -1 if no such specifiers with nonzero\n      alignment.  */\n@@ -362,6 +365,8 @@ struct c_declspecs {\n   /* Whether any alignment specifier (even with zero alignment) was\n      specified.  */\n   BOOL_BITFIELD alignas_p : 1;\n+  /* Whether any __GIMPLE specifier was specified.  */\n+  BOOL_BITFIELD gimple_p : 1;\n   /* The address space that the declaration belongs to.  */\n   addr_space_t address_space;\n };"}, {"sha": "51fbb5366d3e349ee0da906d7b7ec3f3c834226e", "filename": "gcc/c/config-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Fc%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Fc%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fconfig-lang.in?ref=1ee62b926411dda2bffbca8019b494481183ee15", "patch": "@@ -29,4 +29,4 @@ compilers=\"cc1\\$(exeext)\"\n \n target_libs=\n \n-gtfiles=\"\\$(srcdir)/c/c-lang.c \\$(srcdir)/c/c-tree.h \\$(srcdir)/c/c-decl.c \\$(srcdir)/c-family/c-common.c \\$(srcdir)/c-family/c-common.h \\$(srcdir)/c-family/c-objc.h \\$(srcdir)/c-family/c-cppbuiltin.c \\$(srcdir)/c-family/c-pragma.h \\$(srcdir)/c-family/c-pragma.c \\$(srcdir)/c/c-objc-common.c \\$(srcdir)/c/c-parser.c \\$(srcdir)/c/c-lang.h\"\n+gtfiles=\"\\$(srcdir)/c/c-lang.c \\$(srcdir)/c/c-tree.h \\$(srcdir)/c/c-decl.c \\$(srcdir)/c-family/c-common.c \\$(srcdir)/c-family/c-common.h \\$(srcdir)/c-family/c-objc.h \\$(srcdir)/c-family/c-cppbuiltin.c \\$(srcdir)/c-family/c-pragma.h \\$(srcdir)/c-family/c-pragma.c \\$(srcdir)/c/c-objc-common.c \\$(srcdir)/c/c-parser.h \\$(srcdir)/c/c-parser.c \\$(srcdir)/c/c-lang.h\""}, {"sha": "8e2f46617b8e44ccf16941c31029ab5625322867", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=1ee62b926411dda2bffbca8019b494481183ee15", "patch": "@@ -179,7 +179,7 @@ in the following sections.\n @xref{C Dialect Options,,Options Controlling C Dialect}.\n @gccoptlist{-ansi  -std=@var{standard}  -fgnu89-inline @gol\n -aux-info @var{filename} -fallow-parameterless-variadic-functions @gol\n--fno-asm  -fno-builtin  -fno-builtin-@var{function} @gol\n+-fno-asm  -fno-builtin  -fno-builtin-@var{function} -fgimple@gol\n -fhosted  -ffreestanding -fopenacc -fopenmp -fopenmp-simd @gol\n -fms-extensions -fplan9-extensions -fsso-struct=@var{endianness}\n -fallow-single-precision  -fcond-mismatch -flax-vector-conversions @gol\n@@ -1951,6 +1951,13 @@ built-in functions selectively when using @option{-fno-builtin} or\n #define strcpy(d, s)    __builtin_strcpy ((d), (s))\n @end smallexample\n \n+@item -fgimple\n+@opindex fgimple\n+\n+Enable parsing of function definitions marked with @code{__GIMPLE}.\n+This is an experimental feature that allows unit testing of GIMPLE\n+passes.\n+\n @item -fhosted\n @opindex fhosted\n @cindex hosted environment"}, {"sha": "e9483bc8d4d4e9ef3caa1de860fa456aabf61524", "filename": "gcc/dumpfile.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Fdumpfile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Fdumpfile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdumpfile.c?ref=1ee62b926411dda2bffbca8019b494481183ee15", "patch": "@@ -108,13 +108,15 @@ static const struct dump_option_value_info dump_options[] =\n   {\"nouid\", TDF_NOUID},\n   {\"enumerate_locals\", TDF_ENUMERATE_LOCALS},\n   {\"scev\", TDF_SCEV},\n+  {\"gimple\", TDF_GIMPLE},\n   {\"optimized\", MSG_OPTIMIZED_LOCATIONS},\n   {\"missed\", MSG_MISSED_OPTIMIZATION},\n   {\"note\", MSG_NOTE},\n   {\"optall\", MSG_ALL},\n   {\"all\", ~(TDF_RAW | TDF_SLIM | TDF_LINENO | TDF_TREE | TDF_RTL | TDF_IPA\n \t    | TDF_STMTADDR | TDF_GRAPH | TDF_DIAGNOSTIC | TDF_VERBOSE\n-\t    | TDF_RHS_ONLY | TDF_NOUID | TDF_ENUMERATE_LOCALS | TDF_SCEV)},\n+\t    | TDF_RHS_ONLY | TDF_NOUID | TDF_ENUMERATE_LOCALS | TDF_SCEV\n+\t    | TDF_GIMPLE)},\n   {NULL, 0}\n };\n "}, {"sha": "b7d70f2804bb4d8c3813a83b4d9d96b33d7eab6a", "filename": "gcc/dumpfile.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Fdumpfile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Fdumpfile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdumpfile.h?ref=1ee62b926411dda2bffbca8019b494481183ee15", "patch": "@@ -82,9 +82,10 @@ enum tree_dump_index\n #define TDF_CSELIB\t(1 << 23)\t/* Dump cselib details.  */\n #define TDF_SCEV\t(1 << 24)\t/* Dump SCEV details.  */\n #define TDF_COMMENT\t(1 << 25)\t/* Dump lines with prefix \";;\"  */\n-#define MSG_OPTIMIZED_LOCATIONS  (1 << 26)  /* -fopt-info optimized sources */\n-#define MSG_MISSED_OPTIMIZATION  (1 << 27)  /* missed opportunities */\n-#define MSG_NOTE                 (1 << 28)  /* general optimization info */\n+#define TDF_GIMPLE\t(1 << 26)\t/* Dump in GIMPLE FE syntax  */\n+#define MSG_OPTIMIZED_LOCATIONS  (1 << 27)  /* -fopt-info optimized sources */\n+#define MSG_MISSED_OPTIMIZATION  (1 << 28)  /* missed opportunities */\n+#define MSG_NOTE                 (1 << 29)  /* general optimization info */\n #define MSG_ALL         (MSG_OPTIMIZED_LOCATIONS | MSG_MISSED_OPTIMIZATION \\\n                          | MSG_NOTE)\n "}, {"sha": "b564f4533f2aca1028bb6765a1f55a408a8dae16", "filename": "gcc/function.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=1ee62b926411dda2bffbca8019b494481183ee15", "patch": "@@ -234,6 +234,9 @@ struct GTY(()) function {\n   /* The loops in this function.  */\n   struct loops *x_current_loops;\n \n+  /* Filled by the GIMPLE FE, pass to start compilation with.  */\n+  char *pass_startwith;\n+\n   /* The stack usage of this function.  */\n   struct stack_usage *su;\n "}, {"sha": "82863260ac3afa53903453b535c26eb63a678943", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 77, "deletions": 29, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=1ee62b926411dda2bffbca8019b494481183ee15", "patch": "@@ -893,7 +893,10 @@ dump_gimple_switch (pretty_printer *buffer, gswitch *gs, int spc,\n     {\n       pp_string (buffer, \"switch (\");\n       dump_generic_node (buffer, gimple_switch_index (gs), spc, flags, true);\n-      pp_string (buffer, \") <\");\n+      if (flags & TDF_GIMPLE)\n+\tpp_string (buffer, \") {\");\n+      else\n+\tpp_string (buffer, \") <\");\n     }\n \n   for (i = 0; i < gimple_switch_num_labels (gs); i++)\n@@ -904,9 +907,17 @@ dump_gimple_switch (pretty_printer *buffer, gswitch *gs, int spc,\n       pp_space (buffer);\n       dump_generic_node (buffer, CASE_LABEL (case_label), spc, flags, false);\n       if (i < gimple_switch_num_labels (gs) - 1)\n-        pp_string (buffer, \", \");\n+\t{\n+\t  if (flags & TDF_GIMPLE)\n+\t    pp_string (buffer, \"; \");\n+\t  else\n+\t    pp_string (buffer, \", \");\n+\t}\n     }\n-  pp_greater (buffer);\n+  if (flags & TDF_GIMPLE)\n+    pp_string (buffer, \"; }\");\n+  else\n+    pp_greater (buffer);\n }\n \n \n@@ -962,12 +973,14 @@ dump_gimple_label (pretty_printer *buffer, glabel *gs, int spc, int flags)\n {\n   tree label = gimple_label_label (gs);\n   if (flags & TDF_RAW)\n-      dump_gimple_fmt (buffer, spc, flags, \"%G <%T>\", gs, label);\n+    dump_gimple_fmt (buffer, spc, flags, \"%G <%T>\", gs, label);\n   else\n     {\n       dump_generic_node (buffer, label, spc, flags, false);\n       pp_colon (buffer);\n     }\n+  if (flags & TDF_GIMPLE)\n+    return;\n   if (DECL_NONLOCAL (label))\n     pp_string (buffer, \" [non-local]\");\n   if ((flags & TDF_EH) && EH_LANDING_PAD_NR (label))\n@@ -2039,21 +2052,44 @@ dump_gimple_phi (pretty_printer *buffer, gphi *phi, int spc, bool comment,\n   else\n     {\n       dump_generic_node (buffer, lhs, spc, flags, false);\n-      pp_string (buffer, \" = PHI <\");\n+      if (flags & TDF_GIMPLE)\n+\tpp_string (buffer, \" = __PHI (\");\n+      else\n+\tpp_string (buffer, \" = PHI <\");\n     }\n   for (i = 0; i < gimple_phi_num_args (phi); i++)\n     {\n       if ((flags & TDF_LINENO) && gimple_phi_arg_has_location (phi, i))\n \tdump_location (buffer, gimple_phi_arg_location (phi, i));\n+      if (flags & TDF_GIMPLE)\n+\t{\n+\t  basic_block src = gimple_phi_arg_edge (phi, i)->src;\n+\t  gimple *stmt = first_stmt (src);\n+\t  if (!stmt || gimple_code (stmt) != GIMPLE_LABEL)\n+\t    {\n+\t      pp_string (buffer, \"bb_\");\n+\t      pp_decimal_int (buffer, src->index);\n+\t    }\n+\t  else\n+\t    dump_generic_node (buffer, gimple_label_label (as_a <glabel *> (stmt)), 0, flags,\n+\t\t\t       false);\n+\t  pp_string (buffer, \": \");\n+\t}\n       dump_generic_node (buffer, gimple_phi_arg_def (phi, i), spc, flags,\n \t\t\t false);\n-      pp_left_paren (buffer);\n-      pp_decimal_int (buffer, gimple_phi_arg_edge (phi, i)->src->index);\n-      pp_right_paren (buffer);\n+      if (! (flags & TDF_GIMPLE))\n+\t{\n+\t  pp_left_paren (buffer);\n+\t  pp_decimal_int (buffer, gimple_phi_arg_edge (phi, i)->src->index);\n+\t  pp_right_paren (buffer);\n+\t}\n       if (i < gimple_phi_num_args (phi) - 1)\n \tpp_string (buffer, \", \");\n     }\n-  pp_greater (buffer);\n+  if (flags & TDF_GIMPLE)\n+    pp_string (buffer, \");\");\n+  else\n+    pp_greater (buffer);\n }\n \n \n@@ -2502,7 +2538,12 @@ dump_gimple_bb_header (FILE *outf, basic_block bb, int indent, int flags)\n     {\n       gimple *stmt = first_stmt (bb);\n       if (!stmt || gimple_code (stmt) != GIMPLE_LABEL)\n-\tfprintf (outf, \"%*s<bb %d>:\\n\", indent, \"\", bb->index);\n+\t{\n+\t  if (flags & TDF_GIMPLE)\n+\t    fprintf (outf, \"%*sbb_%d:\\n\", indent, \"\", bb->index);\n+\t  else\n+\t    fprintf (outf, \"%*s<bb %d>:\\n\", indent, \"\", bb->index);\n+\t}\n     }\n }\n \n@@ -2535,7 +2576,8 @@ dump_phi_nodes (pretty_printer *buffer, basic_block bb, int indent, int flags)\n       if (!virtual_operand_p (gimple_phi_result (phi)) || (flags & TDF_VOPS))\n         {\n           INDENT (indent);\n-\t  dump_gimple_phi (buffer, phi, indent, true, flags);\n+\t  dump_gimple_phi (buffer, phi, indent,\n+\t\t\t   (flags & TDF_GIMPLE) ? false : true, flags);\n           pp_newline (buffer);\n         }\n     }\n@@ -2546,26 +2588,32 @@ dump_phi_nodes (pretty_printer *buffer, basic_block bb, int indent, int flags)\n    to BUFFER.  */\n \n static void\n-pp_cfg_jump (pretty_printer *buffer, basic_block bb)\n+pp_cfg_jump (pretty_printer *buffer, basic_block bb, int flags)\n {\n-  gimple *stmt;\n-\n-  stmt = first_stmt (bb);\n-\n-  pp_string (buffer, \"goto <bb \");\n-  pp_decimal_int (buffer, bb->index);\n-  pp_greater (buffer);\n-  if (stmt && gimple_code (stmt) == GIMPLE_LABEL)\n+  if (flags & TDF_GIMPLE)\n     {\n-      pp_string (buffer, \" (\");\n-      dump_generic_node (buffer,\n-\t\t\t gimple_label_label (as_a <glabel *> (stmt)),\n-\t\t\t 0, 0, false);\n-      pp_right_paren (buffer);\n+      pp_string (buffer, \"goto bb_\");\n+      pp_decimal_int (buffer, bb->index);\n       pp_semicolon (buffer);\n     }\n   else\n-    pp_semicolon (buffer);\n+    {\n+      gimple *stmt = first_stmt (bb);\n+      pp_string (buffer, \"goto <bb \");\n+      pp_decimal_int (buffer, bb->index);\n+      pp_greater (buffer);\n+      if (stmt && gimple_code (stmt) == GIMPLE_LABEL)\n+\t{\n+\t  pp_string (buffer, \" (\");\n+\t  dump_generic_node (buffer,\n+\t\t\t     gimple_label_label (as_a <glabel *> (stmt)),\n+\t\t\t     0, 0, false);\n+\t  pp_right_paren (buffer);\n+\t  pp_semicolon (buffer);\n+\t}\n+      else\n+\tpp_semicolon (buffer);\n+    }\n }\n \n \n@@ -2593,11 +2641,11 @@ dump_implicit_edges (pretty_printer *buffer, basic_block bb, int indent,\n       extract_true_false_edges_from_block (bb, &true_edge, &false_edge);\n \n       INDENT (indent + 2);\n-      pp_cfg_jump (buffer, true_edge->dest);\n+      pp_cfg_jump (buffer, true_edge->dest, flags);\n       newline_and_indent (buffer, indent);\n       pp_string (buffer, \"else\");\n       newline_and_indent (buffer, indent + 2);\n-      pp_cfg_jump (buffer, false_edge->dest);\n+      pp_cfg_jump (buffer, false_edge->dest, flags);\n       pp_newline (buffer);\n       return;\n     }\n@@ -2614,7 +2662,7 @@ dump_implicit_edges (pretty_printer *buffer, basic_block bb, int indent,\n \t  && e->goto_locus != UNKNOWN_LOCATION)\n \tdump_location (buffer, e->goto_locus);\n \n-      pp_cfg_jump (buffer, e->dest);\n+      pp_cfg_jump (buffer, e->dest, flags);\n       pp_newline (buffer);\n     }\n }"}, {"sha": "08755594db1402682473c14d1d457085d5325f85", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=1ee62b926411dda2bffbca8019b494481183ee15", "patch": "@@ -2505,3 +2505,9 @@ expand_internal_call (gcall *stmt)\n {\n   expand_internal_call (gimple_call_internal_fn (stmt), stmt);\n }\n+\n+void\n+expand_PHI (internal_fn, gcall *)\n+{\n+    gcc_unreachable ();\n+}"}, {"sha": "d1cd1a55b8fd71eb0484e17a3fd0afbe033f341b", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=1ee62b926411dda2bffbca8019b494481183ee15", "patch": "@@ -170,6 +170,7 @@ DEF_INTERNAL_FN (VA_ARG, ECF_NOTHROW | ECF_LEAF, NULL)\n    other such optimizations.  The first argument distinguishes\n    between uses.  See internal-fn.h for usage.  */\n DEF_INTERNAL_FN (UNIQUE, ECF_NOTHROW, NULL)\n+DEF_INTERNAL_FN (PHI, 0, NULL)\n \n /* DIM_SIZE and DIM_POS return the size of a particular compute\n    dimension and the executing thread's position within that"}, {"sha": "672a60f0619fc5bd7a24b4d9911b4df565f05c15", "filename": "gcc/internal-fn.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Finternal-fn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Finternal-fn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.h?ref=1ee62b926411dda2bffbca8019b494481183ee15", "patch": "@@ -178,5 +178,6 @@ extern bool set_edom_supported_p (void);\n \n extern void expand_internal_call (gcall *);\n extern void expand_internal_call (internal_fn, gcall *);\n+extern void expand_PHI (internal_fn, gcall *);\n \n #endif"}, {"sha": "4963e812fe4958feb6279783112cc9cff89f0a9f", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=1ee62b926411dda2bffbca8019b494481183ee15", "patch": "@@ -1,3 +1,8 @@\n+2016-11-14  Prasad Ghangal  <prasad.ghangal@gmail.com>\n+\tRichard Biener  <rguenther@suse.de>\n+    \n+    \t* config-lang.in (gtfiles): Add c/c-parser.h.\n+\n 2016-09-27  Jakub Jelinek  <jakub@redhat.com>\n \n \t* objc-act.c (continue_class): Remove break after return."}, {"sha": "912af224b00a92e5c45dc583cfe706eacf92377f", "filename": "gcc/objc/config-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Fobjc%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Fobjc%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fconfig-lang.in?ref=1ee62b926411dda2bffbca8019b494481183ee15", "patch": "@@ -35,4 +35,4 @@ lang_requires=\"c\"\n # Order is important.  If you change this list, make sure you test\n # building without C++ as well; that is, remove the gcc/cp directory,\n # and build with --enable-languages=c,objc.\n-gtfiles=\"\\$(srcdir)/objc/objc-map.h \\$(srcdir)/c-family/c-objc.h \\$(srcdir)/objc/objc-act.h \\$(srcdir)/objc/objc-act.c \\$(srcdir)/objc/objc-runtime-shared-support.c \\$(srcdir)/objc/objc-gnu-runtime-abi-01.c \\$(srcdir)/objc/objc-next-runtime-abi-01.c \\$(srcdir)/objc/objc-next-runtime-abi-02.c \\$(srcdir)/c/c-parser.c \\$(srcdir)/c/c-tree.h \\$(srcdir)/c/c-decl.c \\$(srcdir)/c/c-lang.h \\$(srcdir)/c/c-objc-common.c \\$(srcdir)/c-family/c-common.c \\$(srcdir)/c-family/c-common.h \\$(srcdir)/c-family/c-cppbuiltin.c \\$(srcdir)/c-family/c-pragma.h \\$(srcdir)/c-family/c-pragma.c\"\n+gtfiles=\"\\$(srcdir)/objc/objc-map.h \\$(srcdir)/c-family/c-objc.h \\$(srcdir)/objc/objc-act.h \\$(srcdir)/objc/objc-act.c \\$(srcdir)/objc/objc-runtime-shared-support.c \\$(srcdir)/objc/objc-gnu-runtime-abi-01.c \\$(srcdir)/objc/objc-next-runtime-abi-01.c \\$(srcdir)/objc/objc-next-runtime-abi-02.c \\$(srcdir)/c/c-parser.h \\$(srcdir)/c/c-parser.c \\$(srcdir)/c/c-tree.h \\$(srcdir)/c/c-decl.c \\$(srcdir)/c/c-lang.h \\$(srcdir)/c/c-objc-common.c \\$(srcdir)/c-family/c-common.c \\$(srcdir)/c-family/c-common.h \\$(srcdir)/c-family/c-cppbuiltin.c \\$(srcdir)/c-family/c-pragma.h \\$(srcdir)/c-family/c-pragma.c\""}, {"sha": "51d0d84b74de3a0db6ead04a26cd517844f59d83", "filename": "gcc/passes.c", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=1ee62b926411dda2bffbca8019b494481183ee15", "patch": "@@ -2099,7 +2099,7 @@ pass_init_dump_file (opt_pass *pass)\n       release_dump_file_name ();\n       dump_file_name = dumps->get_dump_file_name (pass->static_pass_number);\n       dumps->dump_start (pass->static_pass_number, &dump_flags);\n-      if (dump_file && current_function_decl)\n+      if (dump_file && current_function_decl && ! (dump_flags & TDF_GIMPLE))\n         dump_function_header (dump_file, current_function_decl, dump_flags);\n       if (initializing_dump\n \t  && dump_file && (dump_flags & TDF_GRAPH)\n@@ -2313,6 +2313,35 @@ execute_one_pass (opt_pass *pass)\n       return false;\n     }\n \n+  /* For skipping passes until startwith pass */\n+  if (cfun\n+      && cfun->pass_startwith\n+      /* But we can't skip the lowering phase yet -- ideally we'd\n+         drive that phase fully via properties.  */\n+      && (cfun->curr_properties & PROP_ssa))\n+    {\n+      size_t namelen = strlen (pass->name);\n+      if (! strncmp (pass->name, cfun->pass_startwith, namelen))\n+\t{\n+\t  /* The following supports starting with the Nth invocation\n+\t     of a pass (where N does not necessarily is equal to the\n+\t     dump file suffix).  */\n+\t  if (cfun->pass_startwith[namelen] == '\\0'\n+\t      || (cfun->pass_startwith[namelen] == '1'\n+\t\t  && cfun->pass_startwith[namelen + 1] == '\\0'))\n+\t    cfun->pass_startwith = NULL;\n+\t  else\n+\t    {\n+\t      if (cfun->pass_startwith[namelen + 1] != '\\0')\n+\t\treturn true;\n+\t      --cfun->pass_startwith[namelen];\n+\t      return true;\n+\t    }\n+\t}\n+      else\n+\treturn true;\n+    }\n+\n   /* Pass execution event trigger: useful to identify passes being\n      executed.  */\n   invoke_plugin_callbacks (PLUGIN_PASS_EXECUTION, pass);\n@@ -2428,7 +2457,7 @@ execute_pass_list_1 (opt_pass *pass)\n       if (cfun == NULL)\n \treturn;\n       if (execute_one_pass (pass) && pass->sub)\n-        execute_pass_list_1 (pass->sub);\n+\texecute_pass_list_1 (pass->sub);\n       pass = pass->next;\n     }\n   while (pass);"}, {"sha": "e9485591659a2414c8ab2ec236a52544c91b1790", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1ee62b926411dda2bffbca8019b494481183ee15", "patch": "@@ -1,3 +1,25 @@\n+2016-11-14  Prasad Ghangal  <prasad.ghangal@gmail.com>\n+\tRichard Biener  <rguenther@suse.de>\n+    \n+    \t* gcc.dg/gimplefe-1.c: New testcase.\n+    \t* gcc.dg/gimplefe-2.c: Likewise.\n+    \t* gcc.dg/gimplefe-3.c: Likewise.\n+    \t* gcc.dg/gimplefe-4.c: Likewise.\n+    \t* gcc.dg/gimplefe-5.c: Likewise.\n+    \t* gcc.dg/gimplefe-6.c: Likewise.\n+    \t* gcc.dg/gimplefe-7.c: Likewise.\n+    \t* gcc.dg/gimplefe-8.c: Likewise.\n+    \t* gcc.dg/gimplefe-9.c: Likewise.\n+    \t* gcc.dg/gimplefe-10.c: Likewise.\n+    \t* gcc.dg/gimplefe-11.c: Likewise.\n+    \t* gcc.dg/gimplefe-12.c: Likewise.\n+    \t* gcc.dg/gimplefe-13.c: Likewise.\n+    \t* gcc.dg/gimplefe-14.c: Likewise.\n+    \t* gcc.dg/gimplefe-15.c: Likewise.\n+    \t* gcc.dg/gimplefe-16.c: Likewise.\n+    \t* gcc.dg/gimplefe-17.c: Likewise.\n+    \t* gcc.dg/gimplefe-18.c: Likewise.\n+\n 2016-11-14  Martin Liska  <mliska@suse.cz>\n \n \tPR bootstrap/78069"}, {"sha": "e99e1022b6c9cf44ff0520910eb52648b37dd645", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 59, "deletions": 2, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=1ee62b926411dda2bffbca8019b494481183ee15", "patch": "@@ -170,6 +170,7 @@ static edge find_taken_edge_computed_goto (basic_block, tree);\n static edge find_taken_edge_cond_expr (basic_block, tree);\n static edge find_taken_edge_switch_expr (gswitch *, basic_block, tree);\n static tree find_case_label_for_value (gswitch *, tree);\n+static void lower_phi_internal_fn ();\n \n void\n init_empty_tree_cfg_for_function (struct function *fn)\n@@ -244,6 +245,7 @@ build_gimple_cfg (gimple_seq seq)\n   discriminator_per_locus = new hash_table<locus_discrim_hasher> (13);\n   make_edges ();\n   assign_discriminators ();\n+  lower_phi_internal_fn ();\n   cleanup_dead_labels ();\n   delete discriminator_per_locus;\n   discriminator_per_locus = NULL;\n@@ -345,6 +347,49 @@ replace_loop_annotate (void)\n     }\n }\n \n+/* Lower internal PHI function from GIMPLE FE.  */\n+\n+static void\n+lower_phi_internal_fn ()\n+{\n+  basic_block bb, pred = NULL;\n+  gimple_stmt_iterator gsi;\n+  tree lhs;\n+  gphi *phi_node;\n+  gimple *stmt;\n+\n+  /* After edge creation, handle __PHI function from GIMPLE FE.  */\n+  FOR_EACH_BB_FN (bb, cfun)\n+    {\n+      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi);)\n+\t{\n+\t  stmt = gsi_stmt (gsi);\n+\t  if (! gimple_call_internal_p (stmt, IFN_PHI))\n+\t    {\n+\t      gsi_next (&gsi);\n+\t      continue;\n+\t    }\n+\n+\t  lhs = gimple_call_lhs (stmt);\n+\t  phi_node = create_phi_node (lhs, bb);\n+\n+\t  /* Add arguments to the PHI node.  */\n+\t  for (unsigned i = 0; i < gimple_call_num_args (stmt); ++i)\n+\t    {\n+\t      tree arg = gimple_call_arg (stmt, i);\n+\t      if (TREE_CODE (arg) == LABEL_DECL)\n+\t\tpred = label_to_block (arg);\n+\t      else\n+\t\t{\n+\t\t  edge e = find_edge (pred, bb);\n+\t\t  add_phi_arg (phi_node, arg, e, UNKNOWN_LOCATION);\n+\t\t}\n+\t    }\n+\n+\t  gsi_remove (&gsi, true);\n+\t}\n+    }\n+}\n \n static unsigned int\n execute_build_cfg (void)\n@@ -3337,6 +3382,11 @@ verify_gimple_call (gcall *stmt)\n \t  debug_generic_stmt (fn);\n \t  return true;\n \t}\n+      /* FIXME : for passing label as arg in internal fn PHI from GIMPLE FE*/\n+      else if (gimple_call_internal_fn (stmt) == IFN_PHI)\n+\t{\n+\t  return false;\n+\t}\n     }\n   else\n     {\n@@ -7497,7 +7547,14 @@ dump_function_to_file (tree fndecl, FILE *file, int flags)\n     }\n \n   current_function_decl = fndecl;\n-  fprintf (file, \"%s %s(\", function_name (fun), tmclone ? \"[tm-clone] \" : \"\");\n+  if (flags & TDF_GIMPLE)\n+    {\n+      print_generic_expr (file, TREE_TYPE (TREE_TYPE (fndecl)),\n+\t\t\t  dump_flags | TDF_SLIM);\n+      fprintf (file, \" __GIMPLE ()\\n%s (\", function_name (fun));\n+    }\n+  else\n+    fprintf (file, \"%s %s(\", function_name (fun), tmclone ? \"[tm-clone] \" : \"\");\n \n   arg = DECL_ARGUMENTS (fndecl);\n   while (arg)\n@@ -7609,7 +7666,7 @@ dump_function_to_file (tree fndecl, FILE *file, int flags)\n \n       fprintf (file, \"}\\n\");\n     }\n-  else if (DECL_SAVED_TREE (fndecl) == NULL)\n+  else if (fun->curr_properties & PROP_gimple_any)\n     {\n       /* The function is now in GIMPLE form but the CFG has not been\n \t built yet.  Emit the single sequence of GIMPLE statements"}, {"sha": "0e7884519d681df0549d12a62352c5928b276086", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=1ee62b926411dda2bffbca8019b494481183ee15", "patch": "@@ -1378,12 +1378,20 @@ rewrite_add_phi_arguments (basic_block bb)\n       for (gsi = gsi_start_phis (e->dest); !gsi_end_p (gsi);\n \t   gsi_next (&gsi))\n \t{\n-\t  tree currdef, res;\n+\t  tree currdef, res, argvar;\n \t  location_t loc;\n \n \t  phi = gsi.phi ();\n \t  res = gimple_phi_result (phi);\n-\t  currdef = get_reaching_def (SSA_NAME_VAR (res));\n+\t  /* If we have pre-existing PHI (via the GIMPLE FE) its args may\n+\t     be different vars than existing vars and they may be constants\n+\t     as well.  Note the following supports partial SSA for PHI args.  */\n+\t  argvar = gimple_phi_arg_def (phi, e->dest_idx);\n+\t  if (argvar && ! DECL_P (argvar))\n+\t    continue;\n+\t  if (!argvar)\n+\t    argvar = SSA_NAME_VAR (res);\n+\t  currdef = get_reaching_def (argvar);\n \t  /* Virtual operand PHI args do not need a location.  */\n \t  if (virtual_operand_p (res))\n \t    loc = UNKNOWN_LOCATION;"}, {"sha": "096eefdd4f63ceb5636994b84fab46ccf64e30b4", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=1ee62b926411dda2bffbca8019b494481183ee15", "patch": "@@ -257,10 +257,11 @@ dump_decl_name (pretty_printer *pp, tree node, int flags)\n       else\n \tpp_tree_identifier (pp, DECL_NAME (node));\n     }\n+  char uid_sep = (flags & TDF_GIMPLE) ? '_' : '.';\n   if ((flags & TDF_UID) || DECL_NAME (node) == NULL_TREE)\n     {\n       if (TREE_CODE (node) == LABEL_DECL && LABEL_DECL_UID (node) != -1)\n-\tpp_printf (pp, \"L.%d\", (int) LABEL_DECL_UID (node));\n+\tpp_printf (pp, \"L%c%d\", uid_sep, (int) LABEL_DECL_UID (node));\n       else if (TREE_CODE (node) == DEBUG_EXPR_DECL)\n \t{\n \t  if (flags & TDF_NOUID)\n@@ -274,7 +275,7 @@ dump_decl_name (pretty_printer *pp, tree node, int flags)\n \t  if (flags & TDF_NOUID)\n \t    pp_printf (pp, \"%c.xxxx\", c);\n \t  else\n-\t    pp_printf (pp, \"%c.%u\", c, DECL_UID (node));\n+\t    pp_printf (pp, \"%c%c%u\", c, uid_sep, DECL_UID (node));\n \t}\n     }\n   if ((flags & TDF_ALIAS) && DECL_PT_UID (node) != DECL_UID (node))\n@@ -1762,13 +1763,23 @@ dump_generic_node (pretty_printer *pp, tree node, int spc, int flags,\n       if (DECL_NAME (node))\n \tdump_decl_name (pp, node, flags);\n       else if (LABEL_DECL_UID (node) != -1)\n-\tpp_printf (pp, \"<L%d>\", (int) LABEL_DECL_UID (node));\n+\t{\n+\t  if (flags & TDF_GIMPLE)\n+\t    pp_printf (pp, \"L%d\", (int) LABEL_DECL_UID (node));\n+\t  else\n+\t    pp_printf (pp, \"<L%d>\", (int) LABEL_DECL_UID (node));\n+\t}\n       else\n \t{\n \t  if (flags & TDF_NOUID)\n \t    pp_string (pp, \"<D.xxxx>\");\n \t  else\n-\t    pp_printf (pp, \"<D.%u>\", DECL_UID (node));\n+\t    {\n+\t      if (flags & TDF_GIMPLE)\n+\t\tpp_printf (pp, \"<D%u>\", DECL_UID (node));\n+\t      else\n+\t\tpp_printf (pp, \"<D.%u>\", DECL_UID (node));\n+\t    }\n \t}\n       break;\n \n@@ -2695,7 +2706,8 @@ dump_generic_node (pretty_printer *pp, tree node, int spc, int flags,\n \t      && SSA_NAME_VAR (node)\n \t      && DECL_NAMELESS (SSA_NAME_VAR (node)))\n \t    dump_fancy_name (pp, SSA_NAME_IDENTIFIER (node));\n-\t  else\n+\t  else if (! (flags & TDF_GIMPLE)\n+\t\t   || SSA_NAME_VAR (node))\n \t    dump_generic_node (pp, SSA_NAME_IDENTIFIER (node),\n \t\t\t       spc, flags, false);\n \t}"}, {"sha": "bd5d10ab28b53420fa8ffdba0141eff844279769", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=1ee62b926411dda2bffbca8019b494481183ee15", "patch": "@@ -252,10 +252,12 @@ flush_ssaname_freelist (void)\n /* Return an SSA_NAME node for variable VAR defined in statement STMT\n    in function FN.  STMT may be an empty statement for artificial\n    references (e.g., default definitions created when a variable is\n-   used without a preceding definition).  */\n+   used without a preceding definition).  If VERISON is not zero then\n+   allocate the SSA name with that version.  */\n \n tree\n-make_ssa_name_fn (struct function *fn, tree var, gimple *stmt)\n+make_ssa_name_fn (struct function *fn, tree var, gimple *stmt,\n+\t\t  unsigned int version)\n {\n   tree t;\n   use_operand_p imm;\n@@ -265,8 +267,19 @@ make_ssa_name_fn (struct function *fn, tree var, gimple *stmt)\n \t      || TREE_CODE (var) == RESULT_DECL\n \t      || (TYPE_P (var) && is_gimple_reg_type (var)));\n \n+  /* Get the specified SSA name version.  */\n+  if (version != 0)\n+    {\n+      t = make_node (SSA_NAME);\n+      SSA_NAME_VERSION (t) = version;\n+      if (version >= SSANAMES (fn)->length ())\n+\tvec_safe_grow_cleared (SSANAMES (fn), version + 1);\n+      gcc_assert ((*SSANAMES (fn))[version] == NULL);\n+      (*SSANAMES (fn))[version] = t;\n+      ssa_name_nodes_created++;\n+    }\n   /* If our free list has an element, then use it.  */\n-  if (!vec_safe_is_empty (FREE_SSANAMES (fn)))\n+  else if (!vec_safe_is_empty (FREE_SSANAMES (fn)))\n     {\n       t = FREE_SSANAMES (fn)->pop ();\n       ssa_name_nodes_reused++;"}, {"sha": "57e887ec7ae1cb3de80d958a7f3a12b004a736fc", "filename": "gcc/tree-ssanames.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Ftree-ssanames.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ee62b926411dda2bffbca8019b494481183ee15/gcc%2Ftree-ssanames.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.h?ref=1ee62b926411dda2bffbca8019b494481183ee15", "patch": "@@ -78,7 +78,8 @@ extern bool ssa_name_has_boolean_range (tree);\n extern void init_ssanames (struct function *, int);\n extern void fini_ssanames (struct function *);\n extern void ssanames_print_statistics (void);\n-extern tree make_ssa_name_fn (struct function *, tree, gimple *);\n+extern tree make_ssa_name_fn (struct function *, tree, gimple *,\n+\t\t\t      unsigned int version = 0);\n extern void release_ssa_name_fn (struct function *, tree);\n extern bool get_ptr_info_alignment (struct ptr_info_def *, unsigned int *,\n \t\t\t\t    unsigned int *);"}]}