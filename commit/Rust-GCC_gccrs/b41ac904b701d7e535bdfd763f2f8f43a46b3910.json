{"sha": "b41ac904b701d7e535bdfd763f2f8f43a46b3910", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQxYWM5MDRiNzAxZDdlNTM1YmRmZDc2M2YyZjhmNDNhNDZiMzkxMA==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1995-03-23T02:41:36Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1995-03-23T02:41:36Z"}, "message": "i960.c (i960_function_arg_advance): Ensure all regs marked as used if stack is also used (for va_start).\n\n\t* i960/i960.c (i960_function_arg_advance): Ensure all regs marked\n\tas used if stack is also used (for va_start).\n\t(i960_setup_incoming_varargs): Rewrite to be similar to Intel's\n\tversion, but don't allocate reg block unless necessary.\n\nFrom-SVN: r9226", "tree": {"sha": "7896f57430dafef1a2ae92225dc410b28b32593c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7896f57430dafef1a2ae92225dc410b28b32593c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b41ac904b701d7e535bdfd763f2f8f43a46b3910", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b41ac904b701d7e535bdfd763f2f8f43a46b3910", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b41ac904b701d7e535bdfd763f2f8f43a46b3910", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b41ac904b701d7e535bdfd763f2f8f43a46b3910/comments", "author": null, "committer": null, "parents": [{"sha": "28cbf42c14d84ef906619aa7c180a72c6acea2fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28cbf42c14d84ef906619aa7c180a72c6acea2fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28cbf42c14d84ef906619aa7c180a72c6acea2fb"}], "stats": {"total": 86, "additions": 47, "deletions": 39}, "files": [{"sha": "18175b72e2c4c3f9062d6059c42c55595dc31b9f", "filename": "gcc/config/i960/i960.c", "status": "modified", "additions": 47, "deletions": 39, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b41ac904b701d7e535bdfd763f2f8f43a46b3910/gcc%2Fconfig%2Fi960%2Fi960.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b41ac904b701d7e535bdfd763f2f8f43a46b3910/gcc%2Fconfig%2Fi960%2Fi960.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.c?ref=b41ac904b701d7e535bdfd763f2f8f43a46b3910", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines used for code generation on intel 80960.\n-   Copyright (C) 1992 Free Software Foundation, Inc.\n+   Copyright (C) 1992, 1995 Free Software Foundation, Inc.\n    Contributed by Steven McGeady, Intel Corp.\n    Additional Work by Glenn Colon-Bonet, Jonathan Shapiro, Andy Wilson\n    Converted to GCC 2.0 by Jim Wilson and Michael Tiemann, Cygnus Support.\n@@ -2069,7 +2069,12 @@ i960_function_arg_advance (cum, mode, type, named)\n   if (size > 4 || cum->ca_nstackparms != 0\n       || (size + ROUND_PARM (cum->ca_nregparms, align)) > NPARM_REGS\n       || MUST_PASS_IN_STACK (mode, type))\n-    cum->ca_nstackparms = ROUND_PARM (cum->ca_nstackparms, align) + size;\n+    {\n+      /* Indicate that all the registers are in use, even if all are not,\n+\t so va_start will compute the right value.  */\n+      cum->ca_nregparms = NPARM_REGS;\n+      cum->ca_nstackparms = ROUND_PARM (cum->ca_nstackparms, align) + size;\n+    }\n   else\n     cum->ca_nregparms = ROUND_PARM (cum->ca_nregparms, align) + size;\n }\n@@ -2200,44 +2205,47 @@ i960_setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n      int *pretend_size;\n      int no_rtl;\n {\n-  if (cum->ca_nregparms < NPARM_REGS)\n-    {\n-      int first_reg_offset = cum->ca_nregparms;\n+  /* Note: for a varargs fn with only a va_alist argument, this is 0.  */\n+  int first_reg = cum->ca_nregparms;\n \n-      if (! (no_rtl))\n-\t{\n-\t  rtx label = gen_label_rtx ();\n-\t  rtx regblock;\n-\n-\t  /* If arg_pointer_rtx == 0, no arguments were passed on the stack\n-\t     and we need to allocate a chunk to save the registers (if any\n-\t     arguments were passed on the stack the caller would allocate the\n-\t     48 bytes as well).  We must allocate all 48 bytes (12*4) because\n-\t     arg_pointer_rtx is saved at the front, the anonymous args are\n-\t     saved at the end.  */\n-\t  emit_insn (gen_cmpsi (arg_pointer_rtx, const0_rtx));\n-\t  emit_jump_insn (gen_bne (label));\n-\t  emit_insn (gen_rtx (SET, VOIDmode, arg_pointer_rtx,\n-\t\t\t      stack_pointer_rtx));\n-\t  emit_insn (gen_rtx (SET, VOIDmode, stack_pointer_rtx,\n-\t\t\t      memory_address (SImode,\n-\t\t\t\t\t      plus_constant (stack_pointer_rtx,\n-\t\t\t\t\t\t\t     48))));\n-\t  emit_label (label);\n-\n-\t  /* Any anonymous args passed in regs?  */\n-\t  if (first_reg_offset + 1 < NPARM_REGS)\n-\t    {\n-\t      rtx regblock;\n-\t      regblock = gen_rtx (MEM, BLKmode,\n-\t\t\t\t  plus_constant (arg_pointer_rtx,\n-\t\t\t\t\t\t (first_reg_offset + 1) * 4));\n-\t      move_block_from_reg (first_reg_offset + 1, regblock,\n-\t\t\t\t   NPARM_REGS - first_reg_offset - 1,\n-\t\t\t\t   ((NPARM_REGS - first_reg_offset - 1)\n-\t\t\t\t    * UNITS_PER_WORD));\n-\t    }\n-\t}\n+  /* Copy only unnamed register arguments to memory.  If there are\n+     any stack parms, there are no unnamed arguments in registers, and\n+     an argument block was already allocated by the caller.\n+     Remember that any arg bigger than 4 words is passed on the stack as\n+     are all subsequent args.\n+\n+     If there are no stack arguments but there are exactly NPARM_REGS\n+     registers, either there were no extra arguments or the caller\n+     allocated an argument block. */\n+\n+  if (cum->ca_nstackparms == 0 && first_reg < NPARM_REGS && !no_rtl)\n+    {\n+      rtx label = gen_label_rtx ();\n+      rtx regblock;\n+\n+      /* If arg_pointer_rtx == 0, no arguments were passed on the stack\n+\t and we need to allocate a chunk to save the registers (if any\n+\t arguments were passed on the stack the caller would allocate the\n+\t 48 bytes as well).  We must allocate all 48 bytes (12*4) because\n+\t va_start assumes it.  */\n+      emit_insn (gen_cmpsi (arg_pointer_rtx, const0_rtx));\n+      emit_jump_insn (gen_bne (label));\n+      emit_insn (gen_rtx (SET, VOIDmode, arg_pointer_rtx,\n+\t\t\t  stack_pointer_rtx));\n+      emit_insn (gen_rtx (SET, VOIDmode, stack_pointer_rtx,\n+\t\t\t  memory_address (SImode,\n+\t\t\t\t\t  plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\t\t 48))));\n+      emit_label (label);\n+\n+      /* ??? Note that we unnecessarily store one extra register for stdarg\n+\t fns.  We could optimize this, but it's kept as for now.  */\n+      regblock = gen_rtx (MEM, BLKmode,\n+\t\t\t  plus_constant (arg_pointer_rtx,\n+\t\t\t\t\t first_reg * 4));\n+      move_block_from_reg (first_reg, regblock,\n+\t\t\t   NPARM_REGS - first_reg,\n+\t\t\t   (NPARM_REGS - first_reg) * UNITS_PER_WORD);\n     }\n }\n "}]}