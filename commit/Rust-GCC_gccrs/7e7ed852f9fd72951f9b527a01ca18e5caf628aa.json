{"sha": "7e7ed852f9fd72951f9b527a01ca18e5caf628aa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2U3ZWQ4NTJmOWZkNzI5NTFmOWI1MjdhMDFjYTE4ZTVjYWY2MjhhYQ==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2003-03-24T13:45:29Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-03-24T13:45:29Z"}, "message": "RandomAccessFile.java: More little merges with libgcj.\n\n2003-03-24  Michael Koch  <konqueror@gmx.de>\n\n\t* java/io/RandomAccessFile.java:\n\tMore little merges with libgcj.\n\nFrom-SVN: r64796", "tree": {"sha": "2fe5bde9134c0f368a33629ba28a807d5b01c242", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2fe5bde9134c0f368a33629ba28a807d5b01c242"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e7ed852f9fd72951f9b527a01ca18e5caf628aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e7ed852f9fd72951f9b527a01ca18e5caf628aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e7ed852f9fd72951f9b527a01ca18e5caf628aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e7ed852f9fd72951f9b527a01ca18e5caf628aa/comments", "author": null, "committer": null, "parents": [{"sha": "24a3f7ac04bfbf789dfc2bbaac070bb6947551be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24a3f7ac04bfbf789dfc2bbaac070bb6947551be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24a3f7ac04bfbf789dfc2bbaac070bb6947551be"}], "stats": {"total": 450, "additions": 408, "deletions": 42}, "files": [{"sha": "16febfd83b6875704e71dab5d5e259c4a36d5f33", "filename": "libjava/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e7ed852f9fd72951f9b527a01ca18e5caf628aa/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e7ed852f9fd72951f9b527a01ca18e5caf628aa/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=7e7ed852f9fd72951f9b527a01ca18e5caf628aa", "patch": "@@ -1,3 +1,8 @@\n+2003-03-24  Michael Koch  <konqueror@gmx.de>\n+\n+\t* java/io/RandomAccessFile.java:\n+\tMore little merges with libgcj.\n+\n 2003-03-24  Michael Koch  <konqueror@gmx.de>\n \n \t* java/net/natInetAddressNoNet.cc:"}, {"sha": "91acb5d3d6cb77995867f8bfa615ced788395430", "filename": "libjava/java/io/RandomAccessFile.java", "status": "modified", "additions": 403, "deletions": 42, "changes": 445, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e7ed852f9fd72951f9b527a01ca18e5caf628aa/libjava%2Fjava%2Fio%2FRandomAccessFile.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e7ed852f9fd72951f9b527a01ca18e5caf628aa/libjava%2Fjava%2Fio%2FRandomAccessFile.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FRandomAccessFile.java?ref=7e7ed852f9fd72951f9b527a01ca18e5caf628aa", "patch": "@@ -53,34 +53,58 @@\n \n public class RandomAccessFile implements DataOutput, DataInput\n {\n-  public void close () throws IOException\n-  {\n-    if (fd.valid())\n-      fd.close();\n-  }\n-\n-  public final FileDescriptor getFD () throws IOException\n-  {\n-    if (! fd.valid())\n-      throw new IOException ();\n-    return fd;\n-  }\n \n-  public long getFilePointer () throws IOException\n-  {\n-    return fd.getFilePointer();\n-  }\n-\n-  public void setLength (long pos) throws IOException\n-  {\n-    fd.setLength(pos);\n-  }\n-\n-  public long length () throws IOException\n+  // The underlying file.\n+  private FileDescriptor fd;\n+  // The corresponding input and output streams.\n+  private DataOutputStream out;\n+  private DataInputStream in;\n+  \n+  private FileChannel ch; /* cached associated file-channel */\n+  \n+  /**\n+   * This method initializes a new instance of <code>RandomAccessFile</code>\n+   * to read from the specified <code>File</code> object with the specified \n+   * access mode.   The access mode is either \"r\" for read only access or \"rw\" \n+   * for read-write access.\n+   * <p>\n+   * Note that a <code>SecurityManager</code> check is made prior to\n+   * opening the file to determine whether or not this file is allowed to\n+   * be read or written.\n+   *\n+   * @param file The <code>File</code> object to read and/or write.\n+   * @param mode \"r\" for read only or \"rw\" for read-write access to the file\n+   *\n+   * @exception IllegalArgumentException If <code>mode</code> has an \n+   * illegal value\n+   * @exception SecurityException If the requested access to the file \n+   * is not allowed\n+   * @exception IOException If any other error occurs\n+   */\n+  public RandomAccessFile (File file, String mode) throws FileNotFoundException\n   {\n-    return fd.length();\n+    this (file.getPath(), mode);\n   }\n \n+  /**\n+   * This method initializes a new instance of <code>RandomAccessFile</code>\n+   * to read from the specified file name with the specified access mode.\n+   * The access mode is either \"r\" for read only access or \"rw\" for read\n+   * write access.\n+   * <p>\n+   * Note that a <code>SecurityManager</code> check is made prior to\n+   * opening the file to determine whether or not this file is allowed to\n+   * be read or written.\n+   *\n+   * @param name The name of the file to read and/or write\n+   * @param mode \"r\" for read only or \"rw\" for read-write access to the file\n+   *\n+   * @exception IllegalArgumentException If <code>mode</code> has an \n+   * illegal value\n+   * @exception SecurityException If the requested access to the file \n+   * is not allowed\n+   * @exception FileNotFoundException If any other error occurs\n+   */\n   public RandomAccessFile (String fileName, String mode)\n     throws FileNotFoundException\n   {\n@@ -105,72 +129,382 @@ else if (mode.compareTo (\"rw\") == 0)\n     in = new DataInputStream (new FileInputStream (fd));\n   }\n \n-  public RandomAccessFile (File file, String mode) throws FileNotFoundException\n+  /**\n+   * This method closes the file and frees up all file related system\n+   * resources.  Since most operating systems put a limit on how many files\n+   * may be opened at any given time, it is a good idea to close all files\n+   * when no longer needed to avoid hitting this limit\n+   */\n+  public void close () throws IOException\n   {\n-    this (file.getPath(), mode);\n+    if (fd.valid())\n+      fd.close();\n+  }\n+\n+  /**\n+   * This method returns a <code>FileDescriptor</code> object that \n+   * represents the native file handle for this file.\n+   *\n+   * @return The <code>FileDescriptor</code> object for this file\n+   *\n+   * @exception IOException If an error occurs\n+   */\n+  public final FileDescriptor getFD () throws IOException\n+  {\n+    if (! fd.valid())\n+      throw new IOException ();\n+    return fd;\n   }\n \n+  /**\n+   * This method returns the current offset in the file at which the next\n+   * read or write will occur\n+   *\n+   * @return The current file position\n+   *\n+   * @exception IOException If an error occurs\n+   */\n+  public long getFilePointer () throws IOException\n+  {\n+    return fd.getFilePointer();\n+  }\n+\n+  /**\n+   * This method sets the length of the file to the specified length.  If\n+   * the currently length of the file is longer than the specified length,\n+   * then the file is truncated to the specified length.  If the current\n+   * length of the file is shorter than the specified length, the file\n+   * is extended with bytes of an undefined value.\n+   *  <p>\n+   * The file must be open for write access for this operation to succeed.\n+   *\n+   * @param newlen The new length of the file\n+   *\n+   * @exception IOException If an error occurs\n+   */\n+  public void setLength (long pos) throws IOException\n+  {\n+    fd.setLength(pos);\n+  }\n+\n+  /**\n+   * This method returns the length of the file in bytes\n+   *\n+   * @return The length of the file\n+   *\n+   * @exception IOException If an error occurs\n+   */\n+  public long length () throws IOException\n+  {\n+    return fd.length();\n+  }\n+\n+  /**\n+   * This method reads a single byte of data from the file and returns it\n+   * as an integer.\n+   *\n+   * @return The byte read as an int, or -1 if the end of the file was reached.\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public int read () throws IOException\n   {\n     return in.read();\n   }\n \n+  /**\n+   * This method reads bytes from the file into the specified array.  The\n+   * bytes are stored starting at the beginning of the array and up to \n+   * <code>buf.length</code> bytes can be read.\n+   *\n+   * @param buf The buffer to read bytes from the file into\n+   *\n+   * @return The actual number of bytes read or -1 if end of file\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public int read (byte[] buffer) throws IOException\n   {\n     return in.read(buffer);\n   }\n \n+  /**\n+   * This methods reads up to <code>len</code> bytes from the file into the s\n+   * pecified array starting at position <code>offset</code> into the array.\n+   *\n+   * @param buf The array to read the bytes into\n+   * @param offset The index into the array to start storing bytes\n+   * @param len The requested number of bytes to read\n+   *\n+   * @return The actual number of bytes read, or -1 if end of file\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public int read (byte[] buffer, int offset, int count) throws IOException\n   {\n     return in.read(buffer, offset, count);\n   }\n \n+  /**\n+   * This method reads a Java boolean value from an input stream.  It does\n+   * so by reading a single byte of data.  If that byte is zero, then the\n+   * value returned is <code>false</code>  If the byte is non-zero, then\n+   * the value returned is <code>true</code>\n+   * <p>\n+   * This method can read a <code>boolean</code> written by an object \n+   * implementing the\n+   * <code>writeBoolean()</code> method in the <code>DataOutput</code> \n+   * interface.\n+   *\n+   * @return The <code>boolean</code> value read\n+   *\n+   * @exception EOFException If end of file is reached before reading the \n+   * boolean\n+   * @exception IOException If any other error occurs\n+   */\n   public final boolean readBoolean () throws IOException\n   {\n     return in.readBoolean();\n   }\n \n+  /**\n+   * This method reads a Java byte value from an input stream.  The value\n+   * is in the range of -128 to 127.\n+   * <p>\n+   * This method can read a <code>byte</code> written by an object \n+   * implementing the \n+   * <code>writeByte()</code> method in the <code>DataOutput</code> interface.\n+   *\n+   * @return The <code>byte</code> value read\n+   *\n+   * @exception EOFException If end of file is reached before reading the byte\n+   * @exception IOException If any other error occurs\n+   *\n+   * @see DataOutput\n+   */\n   public final byte readByte () throws IOException\n   {\n     return in.readByte();\n   }\n \n+  /**\n+   * This method reads a Java <code>char</code> value from an input stream.  \n+   * It operates by reading two bytes from the stream and converting them to \n+   * a single 16-bit Java <code>char</code>  The two bytes are stored most\n+   * significant byte first (i.e., \"big endian\") regardless of the native\n+   * host byte ordering. \n+   * <p>\n+   * As an example, if <code>byte1</code> and code{byte2</code> represent \n+   * the first\n+   * and second byte read from the stream respectively, they will be\n+   * transformed to a <code>char</code> in the following manner:\n+   * <p>\n+   * <code>(char)(((byte1 & 0xFF) << 8) | (byte2 & 0xFF)</code>\n+   * <p>\n+   * This method can read a <code>char</code> written by an object \n+   * implementing the\n+   * <code>writeChar()</code> method in the <code>DataOutput</code> interface.\n+   *\n+   * @return The <code>char</code> value read \n+   *\n+   * @exception EOFException If end of file is reached before reading the char\n+   * @exception IOException If any other error occurs\n+   *\n+   * @see DataOutput\n+   */\n   public final char readChar () throws IOException\n   {\n     return in.readChar();\n   }\n \n+  /**\n+   * This method reads a Java double value from an input stream.  It operates\n+   * by first reading a <code>logn</code> value from the stream by calling the\n+   * <code>readLong()</code> method in this interface, then \n+   * converts that <code>long</code>\n+   * to a <code>double</code> using the <code>longBitsToDouble</code> \n+   * method in the class <code>java.lang.Double</code>\n+   * <p>\n+   * This method can read a <code>double</code> written by an object \n+   * implementing the\n+   * <code>writeDouble()</code> method in the <code>DataOutput</code> \n+   * interface.\n+   *\n+   * @return The <code>double</code> value read\n+   *\n+   * @exception EOFException If end of file is reached before reading \n+   * the double\n+   * @exception IOException If any other error occurs\n+   *\n+   * @see java.lang.Double\n+   * @see DataOutput\n+   */\n   public final double readDouble () throws IOException\n   {\n     return in.readDouble();\n   }\n \n+  /**\n+   * This method reads a Java float value from an input stream.  It operates\n+   * by first reading an <code>int</code> value from the stream by calling the\n+   * <code>readInt()</code> method in this interface, then converts \n+   * that <code>int</code>\n+   * to a <code>float</code> using the <code>intBitsToFloat</code> method in \n+   * the class <code>java.lang.Float</code>\n+   * <p>\n+   * This method can read a <code>float</code> written by an object \n+   * implementing the\n+   * <code>writeFloat()</code> method in the <code>DataOutput</code> interface.\n+   *\n+   * @return The <code>float</code> value read\n+   *\n+   * @exception EOFException If end of file is reached before reading the float\n+   * @exception IOException If any other error occurs\n+   *\n+   * @see java.lang.Float\n+   * @see DataOutput\n+   */\n   public final float readFloat () throws IOException\n   {\n     return in.readFloat();\n   }\n \n+  /**\n+   * This method reads raw bytes into the passed array until the array is\n+   * full.  Note that this method blocks until the data is available and\n+   * throws an exception if there is not enough data left in the stream to\n+   * fill the buffer\n+   *\n+   * @param buf The buffer into which to read the data\n+   *\n+   * @exception EOFException If end of file is reached before filling the \n+   * buffer\n+   * @exception IOException If any other error occurs\n+   */\n   public final void readFully (byte[] buffer) throws IOException\n   {\n     in.readFully(buffer);\n   }\n \n+  /**\n+   * This method reads raw bytes into the passed array <code>buf</code> \n+   * starting\n+   * <code>offset</code> bytes into the buffer.  The number of bytes read \n+   * will be\n+   * exactly <code>len</code>  Note that this method blocks until the data is \n+   * available and throws an exception if there is not enough data left in \n+   * the stream to read <code>len</code> bytes.\n+   *\n+   * @param buf The buffer into which to read the data\n+   * @param offset The offset into the buffer to start storing data\n+   * @param len The number of bytes to read into the buffer\n+   *\n+   * @exception EOFException If end of file is reached before filling \n+   * the buffer\n+   * @exception IOException If any other error occurs\n+   */\n   public final void readFully (byte[] buffer, int offset, int count)\n     throws IOException\n   {\n     in.readFully(buffer, offset, count);\n   }\n \n+  /**\n+   * This method reads a Java <code>int</code> value from an input stream\n+   * It operates by reading four bytes from the stream and converting them to \n+   * a single Java <code>int</code>  The bytes are stored most\n+   * significant byte first (i.e., \"big endian\") regardless of the native\n+   * host byte ordering. \n+   * <p>\n+   * As an example, if <code>byte1</code> through <code>byte4</code> \n+   * represent the first\n+   * four bytes read from the stream, they will be\n+   * transformed to an <code>int</code> in the following manner:\n+   * <p>\n+   * <code>(int)(((byte1 & 0xFF) << 24) + ((byte2 & 0xFF) << 16) + \n+   * ((byte3 & 0xFF) << 8) + (byte4 & 0xFF)))</code>\n+   * <p>\n+   * The value returned is in the range of 0 to 65535.\n+   * <p>\n+   * This method can read an <code>int</code> written by an object \n+   * implementing the\n+   * <code>writeInt()</code> method in the <code>DataOutput</code> interface.\n+   *\n+   * @return The <code>int</code> value read\n+   *\n+   * @exception EOFException If end of file is reached before reading the int\n+   * @exception IOException If any other error occurs\n+   *\n+   * @see DataOutput\n+   */\n   public final int readInt () throws IOException\n   {\n     return in.readInt();\n   }\n \n+  /**\n+   * This method reads the next line of text data from an input stream.\n+   * It operates by reading bytes and converting those bytes to \n+   * <code>char</code>\n+   * values by treating the byte read as the low eight bits of the \n+   * <code>char</code>\n+   * and using <code>0</code> as the high eight bits.  Because of this, it does\n+   * not support the full 16-bit Unicode character set.\n+   * <p>\n+   * The reading of bytes ends when either the end of file or a line terminator\n+   * is encountered.  The bytes read are then returned as a <code>String</code>\n+   * A line terminator is a byte sequence consisting of either \n+   * <code>\\r</code> <code>\\n</code> or <code>\\r\\n</code>  These \n+   * termination charaters are\n+   * discarded and are not returned as part of the string.\n+   * <p>\n+   * This method can read data that was written by an object implementing the\n+   * <code>writeLine()</code> method in <code>DataOutput</code>\n+   *\n+   * @return The line read as a <code>String</code>\n+   *\n+   * @exception IOException If an error occurs\n+   *\n+   * @see DataOutput\n+   *\n+   * @deprecated\n+   */\n   public final String readLine () throws IOException\n   {\n     return in.readLine();\n   }\n \n+  /**\n+   * This method reads a Java long value from an input stream\n+   * It operates by reading eight bytes from the stream and converting them to \n+   * a single Java <code>long</code>  The bytes are stored most\n+   * significant byte first (i.e., \"big endian\") regardless of the native\n+   * host byte ordering. \n+   * <p>\n+   * As an example, if <code>byte1</code> through <code>byte8</code> \n+   * represent the first\n+   * eight bytes read from the stream, they will be\n+   * transformed to an <code>long</code> in the following manner:\n+   * <p>\n+   * <code>\n+   * (long)((((long)byte1 & 0xFF) << 56) + (((long)byte2 & 0xFF) << 48) + \n+   * (((long)byte3 & 0xFF) << 40) + (((long)byte4 & 0xFF) << 32) + \n+   * (((long)byte5 & 0xFF) << 24) + (((long)byte6 & 0xFF) << 16) + \n+   * (((long)byte7 & 0xFF) << 8) + ((long)byte9 & 0xFF)))</code>\n+   * <p>\n+   * The value returned is in the range of 0 to 65535.\n+   * <p>\n+   * This method can read an <code>long</code> written by an object \n+   * implementing the\n+   * <code>writeLong()</code> method in the <code>DataOutput</code> interface.\n+   *\n+   * @return The <code>long</code> value read\n+   *\n+   * @exception EOFException If end of file is reached before reading the long\n+   * @exception IOException If any other error occurs\n+   *\n+   * @see DataOutput\n+   */\n   public final long readLong () throws IOException\n   {\n     return in.readLong();\n@@ -275,26 +609,53 @@ public final void writeChars (String s) throws IOException\n     out.writeChars(s);\n   }\n   \n-  public final void writeUTF (String s) throws IOException\n+  /**\n+   * This method writes a Java <code>String</code> to the stream in a modified\n+   * UTF-8 format.  First, two bytes are written to the stream indicating the\n+   * number of bytes to follow.  Note that this is the number of bytes in the\n+   * encoded <code>String</code> not the <code>String</code> length.  Next\n+   * come the encoded characters.  Each character in the <code>String</code>\n+   * is encoded as either one, two or three bytes.  For characters in the\n+   * range of <code>&#92;u0001</code> to <code>&#92;u007F</code>, \n+   * one byte is used.  The character\n+   * value goes into bits 0-7 and bit eight is 0.  For characters in the range\n+   * of <code>&#92;u0080</code> to <code>&#92;u007FF</code>, two \n+   * bytes are used.  Bits\n+   * 6-10 of the character value are encoded bits 0-4 of the first byte, with\n+   * the high bytes having a value of \"110\".  Bits 0-5 of the character value\n+   * are stored in bits 0-5 of the second byte, with the high bits set to\n+   * \"10\".  This type of encoding is also done for the null character\n+   * <code>&#92;u0000</code>.  This eliminates any C style NUL character values\n+   * in the output.  All remaining characters are stored as three bytes.\n+   * Bits 12-15 of the character value are stored in bits 0-3 of the first\n+   * byte.  The high bits of the first bytes are set to \"1110\".  Bits 6-11\n+   * of the character value are stored in bits 0-5 of the second byte.  The\n+   * high bits of the second byte are set to \"10\".  And bits 0-5 of the\n+   * character value are stored in bits 0-5 of byte three, with the high bits\n+   * of that byte set to \"10\".\n+   *\n+   * @param s The <code>String</code> to write to the output in UTF format\n+   *\n+   * @exception IOException If an error occurs\n+   */\n+  public final void writeUTF(String s) throws IOException\n   {\n     out.writeUTF(s);\n   }\n-\n-  public FileChannel getChannel ()\n+  \n+  /**\n+   * This method creates a java.nio.channels.FileChannel.\n+   * Nio does not allow one to create a file channel directly.\n+   * A file channel must be created by first creating an instance of\n+   * Input/Output/RandomAccessFile and invoking the getChannel() method on it.\n+   */\n+  public synchronized FileChannel getChannel() \n   {\n-    synchronized (this)\n-      {\n-        if (ch == null)\n-          ch = new FileChannelImpl (fd, true, this);\n+    if (ch == null)\n+      ch = new FileChannelImpl (fd, true, this);\n \n-\treturn ch;\n-      }\n+    return ch;\n   }\n \n-  // The underlying file.\n-  private FileDescriptor fd;\n-  // The corresponding input and output streams.\n-  private DataOutputStream out;\n-  private DataInputStream in;\n-  private FileChannel ch;\n-}\n+} // class RandomAccessFile\n+"}]}