{"sha": "b5144086d5b3629755524744084a6d696723efc5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjUxNDQwODZkNWIzNjI5NzU1NTI0NzQ0MDg0YTZkNjk2NzIzZWZjNQ==", "commit": {"author": {"name": "Stan Cox", "email": "scox@redhat.com", "date": "2003-12-16T15:20:51Z"}, "committer": {"name": "Stan Cox", "email": "scox@gcc.gnu.org", "date": "2003-12-16T15:20:51Z"}, "message": "iq2000.h: Formatting.\n\n\t* config/iq2000/iq2000.h: Formatting.\n\t(MAX_INT_TYPE_SIZE, MAX_INT_TYPE_SIZE, CONST_COSTS, RTX_COSTS)\n\t(ADDRESS_COST, ASM_OUTPUT_INTERNAL_LABEL, ASM_OUTPUT_INTERNAL_LABEL)\n\t(IMPLICIT_FIX_EXPR, EASY_DIV_EXPR, SLOW_ZERO_EXTEND): Remove\n\t* config/iq2000/iq2000.c: Formatting.\n\t(iq2000_rtx_costs): New.\n\nFrom-SVN: r74697", "tree": {"sha": "767ce4fe6367d586e14e124098f47940a01463e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/767ce4fe6367d586e14e124098f47940a01463e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5144086d5b3629755524744084a6d696723efc5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5144086d5b3629755524744084a6d696723efc5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5144086d5b3629755524744084a6d696723efc5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5144086d5b3629755524744084a6d696723efc5/comments", "author": {"login": "stanfordcox", "id": 18171344, "node_id": "MDQ6VXNlcjE4MTcxMzQ0", "avatar_url": "https://avatars.githubusercontent.com/u/18171344?v=4", "gravatar_id": "", "url": "https://api.github.com/users/stanfordcox", "html_url": "https://github.com/stanfordcox", "followers_url": "https://api.github.com/users/stanfordcox/followers", "following_url": "https://api.github.com/users/stanfordcox/following{/other_user}", "gists_url": "https://api.github.com/users/stanfordcox/gists{/gist_id}", "starred_url": "https://api.github.com/users/stanfordcox/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/stanfordcox/subscriptions", "organizations_url": "https://api.github.com/users/stanfordcox/orgs", "repos_url": "https://api.github.com/users/stanfordcox/repos", "events_url": "https://api.github.com/users/stanfordcox/events{/privacy}", "received_events_url": "https://api.github.com/users/stanfordcox/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d159598dda60194ebb9ffe697568d273423d0f19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d159598dda60194ebb9ffe697568d273423d0f19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d159598dda60194ebb9ffe697568d273423d0f19"}], "stats": {"total": 1277, "additions": 616, "deletions": 661}, "files": [{"sha": "a9a86f312f7da49808cd3aef0dc53be5f15dad96", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5144086d5b3629755524744084a6d696723efc5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5144086d5b3629755524744084a6d696723efc5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b5144086d5b3629755524744084a6d696723efc5", "patch": "@@ -1,3 +1,12 @@\n+2003-12-16  Stan Cox  <scox@redhat.com>\n+\n+\t* config/iq2000/iq2000.h: Formatting.\n+\t(MAX_INT_TYPE_SIZE, MAX_INT_TYPE_SIZE, CONST_COSTS, RTX_COSTS)\n+\t(ADDRESS_COST, ASM_OUTPUT_INTERNAL_LABEL, ASM_OUTPUT_INTERNAL_LABEL)\n+\t(IMPLICIT_FIX_EXPR, EASY_DIV_EXPR, SLOW_ZERO_EXTEND): Remove\n+\t* config/iq2000/iq2000.c: Formatting.\n+\t(iq2000_rtx_costs): New.\n+\n 2003-12-16  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* arm.md (addsi3_carryin_shift): Add missing register constraints."}, {"sha": "2a37f276eb2eb1748896d07c1a317052c77d2e7f", "filename": "gcc/config/iq2000/iq2000-protos.h", "status": "modified", "additions": 29, "deletions": 33, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5144086d5b3629755524744084a6d696723efc5/gcc%2Fconfig%2Fiq2000%2Fiq2000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5144086d5b3629755524744084a6d696723efc5/gcc%2Fconfig%2Fiq2000%2Fiq2000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000-protos.h?ref=b5144086d5b3629755524744084a6d696723efc5", "patch": "@@ -21,44 +21,40 @@\n #ifndef GCC_IQ2000_PROTOS_H\n #define GCC_IQ2000_PROTOS_H\n \n-extern int iq2000_check_split (rtx, enum machine_mode);\n-extern int iq2000_reg_mode_ok_for_base_p (rtx, enum machine_mode, int);\n-extern int iq2000_legitimate_address_p (enum machine_mode, rtx, int);\n-extern const char* iq2000_fill_delay_slot (const char*, enum delay_type, rtx*, rtx);\n-extern const char *iq2000_move_1word (rtx *, rtx, int);\n-extern int iq2000_address_cost (rtx);\n-extern void override_options (void);\n-extern HOST_WIDE_INT iq2000_debugger_offset (rtx, HOST_WIDE_INT);\n-extern void final_prescan_insn (rtx, rtx*, int);\n-extern HOST_WIDE_INT compute_frame_size (HOST_WIDE_INT);\n-extern int iq2000_initial_elimination_offset (int, int);\n-extern void iq2000_expand_prologue (void);\n-extern void iq2000_expand_epilogue (void);\n-extern void iq2000_expand_eh_return (rtx);\n-extern int iq2000_can_use_return_insn (void);\n-int function_arg_pass_by_reference (CUMULATIVE_ARGS*, enum machine_mode, tree, int);\n-int iq2000_adjust_insn_length (rtx, int);\n-char *iq2000_output_conditional_branch (rtx, rtx*, int, int, int, int);\n-extern void iq2000_init_builtins (void);\n-extern void iq2000_setup_incoming_varargs (CUMULATIVE_ARGS, int, tree, int*, int);\n-extern void print_operand_address (FILE*, rtx);\n-extern void print_operand (FILE*, rtx, int);\n+extern int              iq2000_check_split (rtx, enum machine_mode);\n+extern int              iq2000_reg_mode_ok_for_base_p (rtx, enum machine_mode, int);\n+extern int              iq2000_legitimate_address_p (enum machine_mode, rtx, int);\n+extern const char *     iq2000_fill_delay_slot (const char *, enum delay_type, rtx *, rtx);\n+extern const char *     iq2000_move_1word (rtx *, rtx, int);\n+extern void             override_options (void);\n+extern HOST_WIDE_INT    iq2000_debugger_offset (rtx, HOST_WIDE_INT);\n+extern void             final_prescan_insn (rtx, rtx *, int);\n+extern HOST_WIDE_INT    compute_frame_size (HOST_WIDE_INT);\n+extern int              iq2000_initial_elimination_offset (int, int);\n+extern void             iq2000_expand_prologue (void);\n+extern void             iq2000_expand_epilogue (void);\n+extern void             iq2000_expand_eh_return (rtx);\n+extern int              iq2000_can_use_return_insn (void);\n+extern int              function_arg_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode, tree, int);\n+extern int              iq2000_adjust_insn_length (rtx, int);\n+extern char *           iq2000_output_conditional_branch (rtx, rtx *, int, int, int, int);\n+extern void             iq2000_setup_incoming_varargs (CUMULATIVE_ARGS, int, tree, int*, int);\n+extern void             print_operand_address (FILE *, rtx);\n+extern void             print_operand (FILE *, rtx, int);\n \n #ifdef RTX_CODE\n-extern rtx gen_int_relational (enum rtx_code, rtx, rtx, rtx, int*);\n-extern void gen_conditional_branch (rtx *, enum rtx_code);\n+extern rtx              gen_int_relational (enum rtx_code, rtx, rtx, rtx, int *);\n+extern void             gen_conditional_branch (rtx *, enum rtx_code);\n #endif\n \n #ifdef TREE_CODE\n-extern void init_cumulative_args (CUMULATIVE_ARGS*, tree, rtx);\n-extern void function_arg_advance (CUMULATIVE_ARGS*, enum machine_mode, tree, int);\n-extern struct rtx_def* function_arg (CUMULATIVE_ARGS*, enum machine_mode, tree, int);\n-extern int function_arg_partial_nregs (CUMULATIVE_ARGS*, enum machine_mode, tree, int);\n-extern void iq2000_va_start (tree, rtx);\n-extern rtx iq2000_va_arg (tree, tree);\n-extern rtx iq2000_function_value (tree, tree);\n-extern rtx iq2000_expand_builtin (tree, rtx, rtx,\n-\t\t\t\t  enum machine_mode, int);\n+extern void             init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx);\n+extern void             function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode, tree, int);\n+extern struct rtx_def * function_arg (CUMULATIVE_ARGS *, enum machine_mode, tree, int);\n+extern int              function_arg_partial_nregs (CUMULATIVE_ARGS *, enum machine_mode, tree, int);\n+extern void             iq2000_va_start (tree, rtx);\n+extern rtx              iq2000_va_arg (tree, tree);\n+extern rtx              iq2000_function_value (tree, tree);\n #endif\n \n #endif /* ! GCC_IQ2000_PROTOS_H */"}, {"sha": "d895bb3c88d3ceb1bdc28dca4182539b570db0eb", "filename": "gcc/config/iq2000/iq2000.c", "status": "modified", "additions": 426, "deletions": 286, "changes": 712, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5144086d5b3629755524744084a6d696723efc5/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5144086d5b3629755524744084a6d696723efc5/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.c?ref=b5144086d5b3629755524744084a6d696723efc5", "patch": "@@ -50,7 +50,8 @@ Boston, MA 02111-1307, USA.  */\n    arrays indexed by the test type, and not worry about the order\n    of EQ, NE, etc.  */\n \n-enum internal_test {\n+enum internal_test\n+  {\n     ITEST_EQ,\n     ITEST_NE,\n     ITEST_GT,\n@@ -66,114 +67,118 @@ enum internal_test {\n \n struct constant;\n \n-static void iq2000_count_memory_refs (rtx, int);\n-static enum internal_test map_test_to_internal_test (enum rtx_code);\n-static rtx iq2000_add_large_offset_to_sp (HOST_WIDE_INT);\n-static void iq2000_annotate_frame_insn (rtx, rtx);\n-static void iq2000_emit_frame_related_store (rtx, rtx,\n-\t\t\t\t\t     HOST_WIDE_INT);\n-static struct machine_function * iq2000_init_machine_status (void);\n-static void save_restore_insns (int);\n-static void abort_with_insn (rtx, const char *)\n-     ATTRIBUTE_NORETURN;\n-static int symbolic_expression_p (rtx);\n-static enum processor_type iq2000_parse_cpu (const char *);\n-static void iq2000_select_rtx_section (enum machine_mode, rtx,\n-\t\t\t\t       unsigned HOST_WIDE_INT);\n-static void iq2000_select_section (tree, int, unsigned HOST_WIDE_INT);\n-static rtx expand_one_builtin (enum insn_code, rtx, tree, enum rtx_code*,\n-\t\t\t       int);\n \f\n /* Structure to be filled in by compute_frame_size with register\n    save masks, and offsets for the current function.  */\n \n struct iq2000_frame_info\n {\n-  long total_size;\t\t/* # bytes that the entire frame takes up */\n-  long var_size;\t\t/* # bytes that variables take up */\n-  long args_size;\t\t/* # bytes that outgoing arguments take up */\n-  long extra_size;\t\t/* # bytes of extra gunk */\n-  int  gp_reg_size;\t\t/* # bytes needed to store gp regs */\n-  int  fp_reg_size;\t\t/* # bytes needed to store fp regs */\n-  long mask;\t\t\t/* mask of saved gp registers */\n-  long gp_save_offset;\t\t/* offset from vfp to store gp registers */\n-  long fp_save_offset;\t\t/* offset from vfp to store fp registers */\n-  long gp_sp_offset;\t\t/* offset from new sp to store gp registers */\n-  long fp_sp_offset;\t\t/* offset from new sp to store fp registers */\n-  int  initialized;\t\t/* != 0 if frame size already calculated */\n-  int  num_gp;\t\t\t/* number of gp registers saved */\n-};\n-\n-struct machine_function\n+  long total_size;\t\t/* # bytes that the entire frame takes up.  */\n+  long var_size;\t\t/* # bytes that variables take up.  */\n+  long args_size;\t\t/* # bytes that outgoing arguments take up.  */\n+  long extra_size;\t\t/* # bytes of extra gunk.  */\n+  int  gp_reg_size;\t\t/* # bytes needed to store gp regs.  */\n+  int  fp_reg_size;\t\t/* # bytes needed to store fp regs.  */\n+  long mask;\t\t\t/* Mask of saved gp registers.  */\n+  long gp_save_offset;\t\t/* Offset from vfp to store gp registers.  */\n+  long fp_save_offset;\t\t/* Offset from vfp to store fp registers.  */\n+  long gp_sp_offset;\t\t/* Offset from new sp to store gp registers.  */\n+  long fp_sp_offset;\t\t/* Offset from new sp to store fp registers.  */\n+  int  initialized;\t\t/* != 0 if frame size already calculated.  */\n+  int  num_gp;\t\t\t/* Number of gp registers saved.  */\n+} iq2000_frame_info;\n+\n+struct machine_function GTY(())\n {\n   /* Current frame information, calculated by compute_frame_size.  */\n-  struct iq2000_frame_info frame;\n+  long total_size;\t\t/* # bytes that the entire frame takes up.  */\n+  long var_size;\t\t/* # bytes that variables take up.  */\n+  long args_size;\t\t/* # bytes that outgoing arguments take up.  */\n+  long extra_size;\t\t/* # bytes of extra gunk.  */\n+  int  gp_reg_size;\t\t/* # bytes needed to store gp regs.  */\n+  int  fp_reg_size;\t\t/* # bytes needed to store fp regs.  */\n+  long mask;\t\t\t/* Mask of saved gp registers.  */\n+  long gp_save_offset;\t\t/* Offset from vfp to store gp registers.  */\n+  long fp_save_offset;\t\t/* Offset from vfp to store fp registers.  */\n+  long gp_sp_offset;\t\t/* Offset from new sp to store gp registers.  */\n+  long fp_sp_offset;\t\t/* Offset from new sp to store fp registers.  */\n+  int  initialized;\t\t/* != 0 if frame size already calculated.  */\n+  int  num_gp;\t\t\t/* Number of gp registers saved.  */\n };\n \n /* Global variables for machine-dependent things.  */\n \n-/* Count the number of .file directives, so that .loc is up to date.  */\n-int num_source_filenames = 0;\n-\n-/* Files to separate the text and the data output, so that all of the data\n-   can be emitted before the text, which will mean that the assembler will\n-   generate smaller code, based on the global pointer.  */\n-FILE *asm_out_data_file;\n-FILE *asm_out_text_file;\n-\n-/* The next branch instruction is a branch likely, not branch normal.  */\n-int iq2000_branch_likely;\n-\n-/* Count of delay slots and how many are filled.  */\n-int dslots_load_total;\n-int dslots_load_filled;\n-int dslots_jump_total;\n-int dslots_jump_filled;\n-\n-/* # of nops needed by previous insn */\n-int dslots_number_nops;\n+/* List of all IQ2000 punctuation characters used by print_operand.  */\n+char iq2000_print_operand_punct[256];\n \n-/* Number of 1/2/3 word references to data items (ie, not jal's).  */\n-int num_refs[3];\n+/* The target cpu for optimization and scheduling.  */\n+enum processor_type iq2000_tune;\n \n-/* registers to check for load delay */\n-rtx iq2000_load_reg, iq2000_load_reg2, iq2000_load_reg3, iq2000_load_reg4;\n+/* Which instruction set architecture to use.  */\n+int iq2000_isa;\n \n /* Cached operands, and operator to compare for use in set/branch/trap\n    on condition codes.  */\n rtx branch_cmp[2];\n \n-/* what type of branch to use */\n+/* What type of branch to use.  */\n enum cmp_type branch_type;\n \n-/* The target cpu for code generation.  */\n-enum processor_type iq2000_arch;\n+/* Strings to hold which cpu and instruction set architecture to use.  */\n+const char * iq2000_cpu_string;\t  /* For -mcpu=<xxx>.  */\n+const char * iq2000_arch_string;  /* For -march=<xxx>.  */\n \n-/* The target cpu for optimization and scheduling.  */\n-enum processor_type iq2000_tune;\n \n-/* which instruction set architecture to use.  */\n-int iq2000_isa;\n+/* Local variables.  */\n \n-/* Strings to hold which cpu and instruction set architecture to use.  */\n-const char *iq2000_cpu_string;\t/* for -mcpu=<xxx> */\n-const char *iq2000_arch_string;   /* for -march=<xxx> */\n+/* The next branch instruction is a branch likely, not branch normal.  */\n+static int iq2000_branch_likely;\n+\n+/* Count of delay slots and how many are filled.  */\n+static int dslots_load_total;\n+static int dslots_load_filled;\n+static int dslots_jump_total;\n+\n+/* # of nops needed by previous insn.  */\n+static int dslots_number_nops;\n+\n+/* Number of 1/2/3 word references to data items (ie, not jal's).  */\n+static int num_refs[3];\n+\n+/* Registers to check for load delay.  */\n+static rtx iq2000_load_reg;\n+static rtx iq2000_load_reg2;\n+static rtx iq2000_load_reg3;\n+static rtx iq2000_load_reg4;\n+\n+/* The target cpu for code generation.  */\n+static enum processor_type iq2000_arch;\n \n /* Mode used for saving/restoring general purpose registers.  */\n static enum machine_mode gpr_mode;\n \n-/* List of all IQ2000 punctuation characters used by print_operand.  */\n-char iq2000_print_operand_punct[256];\n \f\n /* Initialize the GCC target structure.  */\n-#undef TARGET_INIT_BUILTINS\n-#define TARGET_INIT_BUILTINS iq2000_init_builtins\n-\n-#undef TARGET_EXPAND_BUILTIN\n-#define TARGET_EXPAND_BUILTIN iq2000_expand_builtin\n-\n-#undef TARGET_ASM_SELECT_RTX_SECTION\n-#define TARGET_ASM_SELECT_RTX_SECTION iq2000_select_rtx_section\n+static struct machine_function* iq2000_init_machine_status (void);\n+static void iq2000_select_rtx_section (enum machine_mode, rtx, unsigned HOST_WIDE_INT);\n+static void iq2000_init_builtins      (void);\n+static rtx  iq2000_expand_builtin     (tree, rtx, rtx, enum machine_mode, int);\n+static bool iq2000_rtx_costs          (rtx, int, int, int *);\n+static int  iq2000_address_cost       (rtx);\n+static void iq2000_select_section     (tree, int, unsigned HOST_WIDE_INT);\n+\n+#undef  TARGET_INIT_BUILTINS\n+#define TARGET_INIT_BUILTINS \t\tiq2000_init_builtins\n+#undef  TARGET_EXPAND_BUILTIN\n+#define TARGET_EXPAND_BUILTIN \t\tiq2000_expand_builtin\n+#undef  TARGET_ASM_SELECT_RTX_SECTION\n+#define TARGET_ASM_SELECT_RTX_SECTION\tiq2000_select_rtx_section\n+#undef  TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS\t\tiq2000_rtx_costs\n+#undef  TARGET_ADDRESS_COST\n+#define TARGET_ADDRESS_COST\t\tiq2000_address_cost\n+#undef  TARGET_ASM_SELECT_SECTION\n+#define TARGET_ASM_SELECT_SECTION\tiq2000_select_section\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n@@ -189,7 +194,7 @@ uns_arith_operand (rtx op, enum machine_mode mode)\n   return register_operand (op, mode);\n }\n \n-/* Return 1 if OP can be used as an operand where a 16 bit integer is needed. */\n+/* Return 1 if OP can be used as an operand where a 16 bit integer is needed.  */\n \n int\n arith_operand (rtx op, enum machine_mode mode)\n@@ -200,7 +205,7 @@ arith_operand (rtx op, enum machine_mode mode)\n   return register_operand (op, mode);\n }\n \n-/* Return 1 if OP is a integer which fits in 16 bits  */\n+/* Return 1 if OP is a integer which fits in 16 bits.  */\n \n int\n small_int (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n@@ -221,15 +226,15 @@ large_int (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n \n   value = INTVAL (op);\n \n-  /* ior reg,$r0,value */\n+  /* IOR reg,$r0,value.  */\n   if ((value & ~ ((HOST_WIDE_INT) 0x0000ffff)) == 0)\n     return 0;\n \n-  /* subu reg,$r0,value */\n+  /* SUBU reg,$r0,value.  */\n   if (((unsigned HOST_WIDE_INT) (value + 32768)) <= 32767)\n     return 0;\n \n-  /* lui reg,value>>16 */\n+  /* LUI reg,value >> 16.  */\n   if ((value & 0x0000ffff) == 0)\n     return 0;\n \n@@ -268,11 +273,11 @@ simple_memory_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   rtx addr, plus0, plus1;\n \n-  /* Eliminate non-memory operations */\n+  /* Eliminate non-memory operations.  */\n   if (GET_CODE (op) != MEM)\n     return 0;\n \n-  /* dword operations really put out 2 instructions, so eliminate them.  */\n+  /* Dword operations really put out 2 instructions, so eliminate them.  */\n   if (GET_MODE_SIZE (GET_MODE (op)) > (unsigned) UNITS_PER_WORD)\n     return 0;\n \n@@ -292,12 +297,12 @@ simple_memory_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n       plus1 = XEXP (addr, 1);\n       if (GET_CODE (plus0) == REG\n \t  && GET_CODE (plus1) == CONST_INT && SMALL_INT (plus1)\n-\t  && SMALL_INT_UNSIGNED (plus1) /* No negative offsets */)\n+\t  && SMALL_INT_UNSIGNED (plus1) /* No negative offsets.  */)\n \treturn 1;\n \n       else if (GET_CODE (plus1) == REG\n \t       && GET_CODE (plus0) == CONST_INT && SMALL_INT (plus0)\n-\t       && SMALL_INT_UNSIGNED (plus1) /* No negative offsets */)\n+\t       && SMALL_INT_UNSIGNED (plus1) /* No negative offsets.  */)\n \treturn 1;\n \n       else\n@@ -324,7 +329,7 @@ equality_op (rtx op, enum machine_mode mode)\n   return GET_CODE (op) == EQ || GET_CODE (op) == NE;\n }\n \n-/* Return nonzero if the code is a relational operations (EQ, LE, etc.) */\n+/* Return nonzero if the code is a relational operations (EQ, LE, etc).  */\n \n int\n cmp_op (rtx op, enum machine_mode mode)\n@@ -449,8 +454,8 @@ iq2000_legitimate_address_p (enum machine_mode mode, rtx xinsn, int strict)\n \n   if (GET_CODE (xinsn) == LO_SUM)\n     {\n-      register rtx xlow0 = XEXP (xinsn, 0);\n-      register rtx xlow1 = XEXP (xinsn, 1);\n+      rtx xlow0 = XEXP (xinsn, 0);\n+      rtx xlow1 = XEXP (xinsn, 1);\n \n       while (GET_CODE (xlow0) == SUBREG)\n \txlow0 = SUBREG_REG (xlow0);\n@@ -462,10 +467,10 @@ iq2000_legitimate_address_p (enum machine_mode mode, rtx xinsn, int strict)\n \n   if (GET_CODE (xinsn) == PLUS)\n     {\n-      register rtx xplus0 = XEXP (xinsn, 0);\n-      register rtx xplus1 = XEXP (xinsn, 1);\n-      register enum rtx_code code0;\n-      register enum rtx_code code1;\n+      rtx xplus0 = XEXP (xinsn, 0);\n+      rtx xplus1 = XEXP (xinsn, 1);\n+      enum rtx_code code0;\n+      enum rtx_code code1;\n \n       while (GET_CODE (xplus0) == SUBREG)\n \txplus0 = SUBREG_REG (xplus0);\n@@ -504,10 +509,10 @@ const char *\n iq2000_fill_delay_slot (const char *ret, enum delay_type type, rtx operands[],\n \t\t\trtx cur_insn)\n {\n-  register rtx set_reg;\n-  register enum machine_mode mode;\n-  register rtx next_insn = cur_insn ? NEXT_INSN (cur_insn) : NULL_RTX;\n-  register int num_nops;\n+  rtx set_reg;\n+  enum machine_mode mode;\n+  rtx next_insn = cur_insn ? NEXT_INSN (cur_insn) : NULL_RTX;\n+  int num_nops;\n \n   if (type == DELAY_LOAD || type == DELAY_FCMP)\n     num_nops = 1;\n@@ -536,6 +541,7 @@ iq2000_fill_delay_slot (const char *ret, enum delay_type type, rtx operands[],\n       iq2000_load_reg2 = 0;\n       iq2000_load_reg3 = 0;\n       iq2000_load_reg4 = 0;\n+\n       return ret;\n     }\n \n@@ -644,7 +650,7 @@ iq2000_count_memory_refs (rtx op, int num)\n \t  break;\n \n \tcase LABEL_REF:\n-\t  n_words = 2;\t\t/* always 2 words */\n+\t  n_words = 2;\t\t/* Always 2 words.  */\n \t  break;\n \n \tcase CONST:\n@@ -672,6 +678,16 @@ iq2000_count_memory_refs (rtx op, int num)\n   num_refs[n_words-1] += num;\n }\n \f\n+/* Abort after printing out a specific insn.  */\n+\n+static void\n+abort_with_insn (rtx insn, const char * reason)\n+{\n+  error (reason);\n+  debug_rtx (insn);\n+  abort ();\n+}\n+\f\n /* Return the appropriate instructions to move one operand to another.  */\n \n const char *\n@@ -904,7 +920,7 @@ iq2000_move_1word (rtx operands[], rtx insn, int unsignedp)\n \f\n /* Provide the costs of an addressing mode that contains ADDR.  */\n \n-int\n+static int\n iq2000_address_cost (rtx addr)\n {\n   switch (GET_CODE (addr))\n@@ -918,7 +934,8 @@ iq2000_address_cost (rtx addr)\n     case CONST:\n       {\n \trtx offset = const0_rtx;\n-\taddr = eliminate_constant_term (XEXP (addr, 0), &offset);\n+\n+\taddr = eliminate_constant_term (XEXP (addr, 0), & offset);\n \tif (GET_CODE (addr) == LABEL_REF)\n \t  return 2;\n \n@@ -929,15 +946,15 @@ iq2000_address_cost (rtx addr)\n \t  return 2;\n       }\n \n-      /* ... fall through ... */\n+      /* Fall through.  */\n \n     case SYMBOL_REF:\n       return SYMBOL_REF_FLAG (addr) ? 1 : 2;\n \n     case PLUS:\n       {\n-\tregister rtx plus0 = XEXP (addr, 0);\n-\tregister rtx plus1 = XEXP (addr, 1);\n+\trtx plus0 = XEXP (addr, 0);\n+\trtx plus1 = XEXP (addr, 1);\n \n \tif (GET_CODE (plus0) != REG && GET_CODE (plus1) == REG)\n \t  plus0 = XEXP (addr, 1), plus1 = XEXP (addr, 0);\n@@ -994,34 +1011,30 @@ map_test_to_internal_test (enum rtx_code test_code)\n   return test;\n }\n \f\n-/* Generate the code to compare two integer values.  The return value is:\n+/* Generate the code to do a TEST_CODE comparison on two integer values CMP0\n+   and CMP1.  P_INVERT is NULL or ptr if branch needs to reverse its test.\n+   The return value RESULT is:\n    (reg:SI xx)\t\tThe pseudo register the comparison is in\n-   0\t\t       \tNo register, generate a simple branch.\n-\n-   TEST_CODE: relational test (EQ, etc).\n-   RESULT: result to store comp. or 0 if branch.\n-   CMP0: first operand to compare \n-   CMP1: second operand to compare \n-   *P_INVERT: NULL or ptr to hold whether branch needs to reverse its test.  */\n+   0\t\t       \tNo register, generate a simple branch.  */\n \n rtx\n gen_int_relational (enum rtx_code test_code, rtx result, rtx cmp0, rtx cmp1,\n \t\t    int *p_invert)\n {\n   struct cmp_info\n   {\n-    enum rtx_code test_code;\t/* code to use in instruction (LT vs. LTU) */\n-    int const_low;\t\t/* low bound of constant we can accept */\n-    int const_high;\t\t/* high bound of constant we can accept */\n-    int const_add;\t\t/* constant to add (convert LE -> LT) */\n-    int reverse_regs;\t\t/* reverse registers in test */\n-    int invert_const;\t\t/* != 0 if invert value if cmp1 is constant */\n-    int invert_reg;\t\t/* != 0 if invert value if cmp1 is register */\n+    enum rtx_code test_code;\t/* Code to use in instruction (LT vs. LTU).  */\n+    int const_low;\t\t/* Low bound of constant we can accept.  */\n+    int const_high;\t\t/* High bound of constant we can accept.  */\n+    int const_add;\t\t/* Constant to add (convert LE -> LT).  */\n+    int reverse_regs;\t\t/* Reverse registers in test.  */\n+    int invert_const;\t\t/* != 0 if invert value if cmp1 is constant.  */\n+    int invert_reg;\t\t/* != 0 if invert value if cmp1 is register.  */\n     int unsignedp;\t\t/* != 0 for unsigned comparisons.  */\n   };\n \n-  static struct cmp_info info[ (int)ITEST_MAX ] = {\n-\n+  static struct cmp_info info[ (int)ITEST_MAX ] =\n+  {\n     { XOR,\t 0,  65535,  0,\t 0,  0,\t 0, 0 },\t/* EQ  */\n     { XOR,\t 0,  65535,  0,\t 0,  1,\t 1, 0 },\t/* NE  */\n     { LT,   -32769,  32766,  1,\t 1,  1,\t 0, 0 },\t/* GT  */\n@@ -1054,13 +1067,13 @@ gen_int_relational (enum rtx_code test_code, rtx result, rtx cmp0, rtx cmp1,\n   if (mode == VOIDmode)\n     mode = GET_MODE (cmp1);\n \n-  /* Eliminate simple branches */\n+  /* Eliminate simple branches.  */\n   branch_p = (result == 0);\n   if (branch_p)\n     {\n       if (GET_CODE (cmp0) == REG || GET_CODE (cmp0) == SUBREG)\n \t{\n-\t  /* Comparisons against zero are simple branches */\n+\t  /* Comparisons against zero are simple branches.  */\n \t  if (GET_CODE (cmp1) == CONST_INT && INTVAL (cmp1) == 0)\n \t    return 0;\n \n@@ -1069,7 +1082,7 @@ gen_int_relational (enum rtx_code test_code, rtx result, rtx cmp0, rtx cmp1,\n \t    return 0;\n \t}\n \n-      /* allocate a pseudo to calculate the value in.  */\n+      /* Allocate a pseudo to calculate the value in.  */\n       result = gen_reg_rtx (mode);\n     }\n \n@@ -1205,7 +1218,7 @@ gen_conditional_branch (rtx operands[], enum rtx_code test_code)\n     case CMP_DF:\n       reg = gen_reg_rtx (CCmode);\n \n-      /* For cmp0 != cmp1, build cmp0 == cmp1, and test for result == 0 */\n+      /* For cmp0 != cmp1, build cmp0 == cmp1, and test for result == 0.  */\n       emit_insn (gen_rtx_SET (VOIDmode, reg,\n \t\t\t      gen_rtx (test_code == NE ? EQ : test_code,\n \t\t\t\t       CCmode, cmp0, cmp1)));\n@@ -1222,7 +1235,6 @@ gen_conditional_branch (rtx operands[], enum rtx_code test_code)\n     }\n \n   /* Generate the branch.  */\n-\n   label1 = gen_rtx_LABEL_REF (VOIDmode, operands[0]);\n   label2 = pc_rtx;\n \n@@ -1239,26 +1251,28 @@ gen_conditional_branch (rtx operands[], enum rtx_code test_code)\n \t\t\t\t\t\t     label1, label2)));\n }\n \f\n-/* Initialize CUMULATIVE_ARGS for a function.  */\n+/* Initialize CUM for a function FNTYPE.  */\n \n void\n init_cumulative_args (CUMULATIVE_ARGS *cum, tree fntype,\n \t\t      rtx libname ATTRIBUTE_UNUSED)\n {\n   static CUMULATIVE_ARGS zero_cum;\n-  tree param, next_param;\n+  tree param;\n+  tree next_param;\n \n   if (TARGET_DEBUG_D_MODE)\n     {\n       fprintf (stderr,\n-\t       \"\\ninit_cumulative_args, fntype = 0x%.8lx\", (long)fntype);\n+\t       \"\\ninit_cumulative_args, fntype = 0x%.8lx\", (long) fntype);\n \n       if (!fntype)\n \tfputc ('\\n', stderr);\n \n       else\n \t{\n \t  tree ret_type = TREE_TYPE (fntype);\n+\n \t  fprintf (stderr, \", fntype code = %s, ret code = %s\\n\",\n \t\t   tree_code_name[(int)TREE_CODE (fntype)],\n \t\t   tree_code_name[(int)TREE_CODE (ret_type)]);\n@@ -1281,7 +1295,8 @@ init_cumulative_args (CUMULATIVE_ARGS *cum, tree fntype,\n     }\n }\n \n-/* Advance the argument to the next argument position.  */\n+/* Advance the argument of type TYPE and mode MODE to the next argument\n+   position in CUM.  */\n \n void\n function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type,\n@@ -1320,7 +1335,7 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type,\n       break;\n \n     case SFmode:\n-      cum->arg_words++;\n+      cum->arg_words ++;\n       if (! cum->gp_reg_found && cum->arg_number <= 2)\n \tcum->fp_code += 1 << ((cum->arg_number - 1) * 2);\n       break;\n@@ -1340,13 +1355,13 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type,\n     case HImode:\n     case SImode:\n       cum->gp_reg_found = 1;\n-      cum->arg_words++;\n+      cum->arg_words ++;\n       break;\n     }\n }\n \n-/* Return an RTL expression containing the register for the given mode,\n-   or 0 if the argument is to be passed on the stack.  */\n+/* Return an RTL expression containing the register for the given mode MODE\n+   and type TYPE in CUM, or 0 if the argument is to be passed on the stack.  */\n \n struct rtx_def *\n function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type,\n@@ -1450,13 +1465,12 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type,\n \n \t      /* ??? If this is a packed structure, then the last hunk won't\n \t\t be 64 bits.  */\n-\n \t      chunks\n \t\t= tree_low_cst (TYPE_SIZE_UNIT (type), 1) / UNITS_PER_WORD;\n \t      if (chunks + *arg_words + bias > (unsigned) MAX_ARGS_IN_REGISTERS)\n \t\tchunks = MAX_ARGS_IN_REGISTERS - *arg_words - bias;\n \n-\t      /* assign_parms checks the mode of ENTRY_PARM, so we must\n+\t      /* Assign_parms checks the mode of ENTRY_PARM, so we must\n \t\t use the actual mode here.  */\n \t      ret = gen_rtx_PARALLEL (mode, rtvec_alloc (chunks));\n \n@@ -1532,21 +1546,20 @@ void\n iq2000_va_start (tree valist, rtx nextarg)\n {\n   int int_arg_words;\n-\n-  /* Find out how many non-float named formals */\n+  /* Find out how many non-float named formals.  */\n   int gpr_save_area_size;\n-  /* Note UNITS_PER_WORD is 4 bytes */\n+  /* Note UNITS_PER_WORD is 4 bytes.  */\n   int_arg_words = current_function_args_info.arg_words;\n+\n   if (int_arg_words < 8 )\n-    /* Adjust for the prologue's economy measure */\n+    /* Adjust for the prologue's economy measure.  */\n     gpr_save_area_size = (8 - int_arg_words) * UNITS_PER_WORD;\n   else\n     gpr_save_area_size = 0;\n \n   /* Everything is in the GPR save area, or in the overflow\n      area which is contiguous with it.  */\n-\n-  nextarg = plus_constant (nextarg, -gpr_save_area_size);\n+  nextarg = plus_constant (nextarg, - gpr_save_area_size);\n   std_expand_builtin_va_start (valist, nextarg);\n }\n \n@@ -1558,7 +1571,6 @@ iq2000_va_arg (tree valist, tree type)\n   HOST_WIDE_INT size, rsize;\n   rtx addr_rtx;\n   tree t;\n-\n   int indirect;\n   rtx r, lab_over = NULL_RTX, lab_false;\n   tree f_ovfl, f_gtop, f_ftop, f_goff, f_foff;\n@@ -1579,8 +1591,8 @@ iq2000_va_arg (tree valist, tree type)\n   {\n     /* Case of all args in a merged stack. No need to check bounds,\n        just advance valist along the stack.  */\n-\n     tree gpr = valist;\n+\n     if (! indirect\n \t&& TYPE_ALIGN (type) > (unsigned) BITS_PER_WORD)\n       {\n@@ -1616,7 +1628,6 @@ iq2000_va_arg (tree valist, tree type)\n   }\n \n   /* Not a simple merged stack.  Need ptrs and indexes left by va_start.  */\n-\n   f_ovfl  = TYPE_FIELDS (va_list_type_node);\n   f_gtop = TREE_CHAIN (f_ovfl);\n   f_ftop = TREE_CHAIN (f_gtop);\n@@ -1634,26 +1645,25 @@ iq2000_va_arg (tree valist, tree type)\n \n   if (TREE_CODE (type) == REAL_TYPE)\n     {\n-\n       /* Emit code to branch if foff == 0.  */\n       r = expand_expr (foff, NULL_RTX, TYPE_MODE (TREE_TYPE (foff)),\n \t\t       EXPAND_NORMAL);\n       emit_cmp_and_jump_insns (r, const0_rtx, EQ,\n \t\t\t       const1_rtx, GET_MODE (r), 1, lab_false);\n \n-      /* Emit code for addr_rtx = ftop - foff */\n+      /* Emit code for addr_rtx = ftop - foff.  */\n       t = build (MINUS_EXPR, TREE_TYPE (ftop), ftop, foff );\n       r = expand_expr (t, addr_rtx, Pmode, EXPAND_NORMAL);\n       if (r != addr_rtx)\n \temit_move_insn (addr_rtx, r);\n \n       /* Emit code for foff-=8.\n-\t Advances the offset up FPR save area by one double */\n+\t Advances the offset up FPR save area by one double.  */\n       t = build (MINUS_EXPR, TREE_TYPE (foff), foff, build_int_2 (8, 0));\n       t = build (MODIFY_EXPR, TREE_TYPE (foff), foff, t);\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n-      emit_queue();\n+      emit_queue ();\n       emit_jump (lab_over);\n       emit_barrier ();\n       emit_label (lab_false);\n@@ -1681,7 +1691,7 @@ iq2000_va_arg (tree valist, tree type)\n     }\n   else\n     {\n-      /* not REAL_TYPE */\n+      /* Not REAL_TYPE.  */\n       int step_size;\n \n       if (TREE_CODE (type) == INTEGER_TYPE\n@@ -1726,7 +1736,7 @@ iq2000_va_arg (tree valist, tree type)\n       emit_barrier ();\n       emit_label (lab_false);\n \n-      /* Emit code for addr_rtx -> overflow area, postinc by step_size */\n+      /* Emit code for addr_rtx -> overflow area, postinc by step_size.  */\n       t = build (POSTINCREMENT_EXPR, TREE_TYPE(ovfl), ovfl,\n \t\t size_int (step_size));\n       r = expand_expr (t, addr_rtx, Pmode, EXPAND_NORMAL);\n@@ -1751,22 +1761,46 @@ iq2000_va_arg (tree valist, tree type)\n     }\n }\n \f\n-/* Abort after printing out a specific insn.  */\n+/* Allocate a chunk of memory for per-function machine-dependent data.  */\n \n-static void\n-abort_with_insn (rtx insn, const char *reason)\n+static struct machine_function *\n+iq2000_init_machine_status (void)\n {\n-  error (reason);\n-  debug_rtx (insn);\n-  abort ();\n+  struct machine_function *f;\n+\n+  f = ggc_alloc_cleared (sizeof (struct machine_function));\n+\n+  return f;\n }\n-\f\n+\n+static enum processor_type\n+iq2000_parse_cpu (const char * cpu_string)\n+{\n+  const char *p = cpu_string;\n+  enum processor_type cpu;\n+\n+  cpu = PROCESSOR_DEFAULT;\n+  switch (p[2])\n+    {\n+    case '1':\n+      if (!strcmp (p, \"iq10\"))\n+\tcpu = PROCESSOR_IQ10;\n+      break;\n+    case '2':\n+      if (!strcmp (p, \"iq2000\"))\n+\tcpu = PROCESSOR_IQ2000;\n+      break;\n+    }\n+\n+  return cpu;\n+}\n+\n /* Detect any conflicts in the switches.  */\n \n void\n override_options (void)\n {\n-  register enum processor_type iq2000_cpu;\n+  enum processor_type iq2000_cpu;\n \n   target_flags &= ~MASK_GPOPT;\n \n@@ -1838,16 +1872,7 @@ override_options (void)\n   gpr_mode = SImode;\n \n   /* Function to allocate machine-dependent function status.  */\n-  init_machine_status = &iq2000_init_machine_status;\n-}\n-\n-/* Allocate a chunk of memory for per-function machine-dependent data.  */\n-\n-static struct machine_function *\n-iq2000_init_machine_status (void)\n-{\n-  return ((struct machine_function *)\n-\t  ggc_alloc_cleared (sizeof (struct machine_function)));\n+  init_machine_status = iq2000_init_machine_status;\n }\n \f\n /* The arg pointer (which is eliminated) points to the virtual frame pointer,\n@@ -1858,17 +1883,17 @@ HOST_WIDE_INT\n iq2000_debugger_offset (rtx addr, HOST_WIDE_INT offset)\n {\n   rtx offset2 = const0_rtx;\n-  rtx reg = eliminate_constant_term (addr, &offset2);\n+  rtx reg = eliminate_constant_term (addr, & offset2);\n \n   if (offset == 0)\n     offset = INTVAL (offset2);\n \n   if (reg == stack_pointer_rtx || reg == frame_pointer_rtx\n       || reg == hard_frame_pointer_rtx)\n     {\n-      HOST_WIDE_INT frame_size = (!cfun->machine->frame.initialized)\n+      HOST_WIDE_INT frame_size = (!cfun->machine->initialized)\n \t\t\t\t  ? compute_frame_size (get_frame_size ())\n-\t\t\t\t  : cfun->machine->frame.total_size;\n+\t\t\t\t  : cfun->machine->total_size;\n \n       offset = offset - frame_size;\n     }\n@@ -1898,7 +1923,7 @@ final_prescan_insn (rtx insn, rtx opvec[] ATTRIBUTE_UNUSED,\n       rtx pattern = PATTERN (insn);\n       int length = get_attr_length (insn);\n \n-      /* Do we need to emit a NOP? */\n+      /* Do we need to emit a NOP?  */\n       if (length == 0\n \t  || (iq2000_load_reg != 0 && reg_mentioned_p (iq2000_load_reg,  pattern))\n \t  || (iq2000_load_reg2 != 0 && reg_mentioned_p (iq2000_load_reg2, pattern))\n@@ -1908,7 +1933,7 @@ final_prescan_insn (rtx insn, rtx opvec[] ATTRIBUTE_UNUSED,\n \tfputs (\"\\tnop\\n\", asm_out_file);\n \n       else\n-\tdslots_load_filled++;\n+\tdslots_load_filled ++;\n \n       while (--dslots_number_nops > 0)\n \tfputs (\"\\tnop\\n\", asm_out_file);\n@@ -1919,22 +1944,23 @@ final_prescan_insn (rtx insn, rtx opvec[] ATTRIBUTE_UNUSED,\n       iq2000_load_reg4 = 0;\n     }\n \n-  if ((GET_CODE (insn) == JUMP_INSN\n+  if (   (GET_CODE (insn) == JUMP_INSN\n        || GET_CODE (insn) == CALL_INSN\n        || (GET_CODE (PATTERN (insn)) == RETURN))\n \t   && NEXT_INSN (PREV_INSN (insn)) == insn)\n     {\n       rtx nop_insn = emit_insn_after (gen_nop (), insn);\n+\n       INSN_ADDRESSES_NEW (nop_insn, -1);\n     }\n   \n   if (TARGET_STATS\n       && (GET_CODE (insn) == JUMP_INSN || GET_CODE (insn) == CALL_INSN))\n-    dslots_jump_total++;\n+    dslots_jump_total ++;\n }\n \f\n /* Return the bytes needed to compute the frame pointer from the current\n-   stack pointer.\n+   stack pointer where SIZE is the # of var. bytes allocated.\n \n    IQ2000 stack frames look like:\n \n@@ -1982,24 +2008,22 @@ final_prescan_insn (rtx insn, rtx opvec[] ATTRIBUTE_UNUSED,\n \t\t\t\t\t|  arguments passed     |\n                                         |  in registers, even   |\n    low                              SP->|  if not passed.       |\n-   memory        \t\t\t+-----------------------+\n-\n-*/\n+   memory        \t\t\t+-----------------------+  */\n \n HOST_WIDE_INT\n compute_frame_size (HOST_WIDE_INT size)\n {\n   int regno;\n-  HOST_WIDE_INT total_size;\t/* # bytes that the entire frame takes up */\n-  HOST_WIDE_INT var_size;\t/* # bytes that variables take up */\n-  HOST_WIDE_INT args_size;\t/* # bytes that outgoing arguments take up */\n-  HOST_WIDE_INT extra_size;\t/* # extra bytes */\n-  HOST_WIDE_INT gp_reg_rounded;\t/* # bytes needed to store gp after rounding */\n-  HOST_WIDE_INT gp_reg_size;\t/* # bytes needed to store gp regs */\n-  HOST_WIDE_INT fp_reg_size;\t/* # bytes needed to store fp regs */\n-  long mask;\t\t\t/* mask of saved gp registers */\n-  int  fp_inc;\t\t\t/* 1 or 2 depending on the size of fp regs */\n-  long fp_bits;\t\t\t/* bitmask to use for each fp register */\n+  HOST_WIDE_INT total_size;\t/* # bytes that the entire frame takes up.  */\n+  HOST_WIDE_INT var_size;\t/* # bytes that variables take up.  */\n+  HOST_WIDE_INT args_size;\t/* # bytes that outgoing arguments take up.  */\n+  HOST_WIDE_INT extra_size;\t/* # extra bytes.  */\n+  HOST_WIDE_INT gp_reg_rounded;\t/* # bytes needed to store gp after rounding.  */\n+  HOST_WIDE_INT gp_reg_size;\t/* # bytes needed to store gp regs.  */\n+  HOST_WIDE_INT fp_reg_size;\t/* # bytes needed to store fp regs.  */\n+  long mask;\t\t\t/* mask of saved gp registers.  */\n+  int  fp_inc;\t\t\t/* 1 or 2 depending on the size of fp regs.  */\n+  long fp_bits;\t\t\t/* bitmask to use for each fp register.  */\n \n   gp_reg_size = 0;\n   fp_reg_size = 0;\n@@ -2009,8 +2033,7 @@ compute_frame_size (HOST_WIDE_INT size)\n   args_size = IQ2000_STACK_ALIGN (current_function_outgoing_args_size);\n \n   /* If a function dynamically allocates the stack and\n-     has 0 for STACK_DYNAMIC_OFFSET then allocate some stack space */\n-\n+     has 0 for STACK_DYNAMIC_OFFSET then allocate some stack space.  */\n   if (args_size == 0 && current_function_calls_alloca)\n     args_size = 4 * UNITS_PER_WORD;\n \n@@ -2029,11 +2052,12 @@ compute_frame_size (HOST_WIDE_INT size)\n   /* We need to restore these for the handler.  */\n   if (current_function_calls_eh_return)\n     {\n-      int i;\n+      unsigned int i;\n+\n       for (i = 0; ; ++i)\n \t{\n \t  regno = EH_RETURN_DATA_REGNO (i);\n-\t  if (regno == (signed int) INVALID_REGNUM)\n+\t  if (regno == (int) INVALID_REGNUM)\n \t    break;\n \t  gp_reg_size += GET_MODE_SIZE (gpr_mode);\n \t  mask |= 1L << (regno - GP_REG_FIRST);\n@@ -2054,15 +2078,15 @@ compute_frame_size (HOST_WIDE_INT size)\n   total_size += IQ2000_STACK_ALIGN (current_function_pretend_args_size);\n \n   /* Save other computed information.  */\n-  cfun->machine->frame.total_size = total_size;\n-  cfun->machine->frame.var_size = var_size;\n-  cfun->machine->frame.args_size = args_size;\n-  cfun->machine->frame.extra_size = extra_size;\n-  cfun->machine->frame.gp_reg_size = gp_reg_size;\n-  cfun->machine->frame.fp_reg_size = fp_reg_size;\n-  cfun->machine->frame.mask = mask;\n-  cfun->machine->frame.initialized = reload_completed;\n-  cfun->machine->frame.num_gp = gp_reg_size / UNITS_PER_WORD;\n+  cfun->machine->total_size = total_size;\n+  cfun->machine->var_size = var_size;\n+  cfun->machine->args_size = args_size;\n+  cfun->machine->extra_size = extra_size;\n+  cfun->machine->gp_reg_size = gp_reg_size;\n+  cfun->machine->fp_reg_size = fp_reg_size;\n+  cfun->machine->mask = mask;\n+  cfun->machine->initialized = reload_completed;\n+  cfun->machine->num_gp = gp_reg_size / UNITS_PER_WORD;\n \n   if (mask)\n     {\n@@ -2071,17 +2095,17 @@ compute_frame_size (HOST_WIDE_INT size)\n       offset = (args_size + extra_size + var_size\n \t\t+ gp_reg_size - GET_MODE_SIZE (gpr_mode));\n \n-      cfun->machine->frame.gp_sp_offset = offset;\n-      cfun->machine->frame.gp_save_offset = offset - total_size;\n+      cfun->machine->gp_sp_offset = offset;\n+      cfun->machine->gp_save_offset = offset - total_size;\n     }\n   else\n     {\n-      cfun->machine->frame.gp_sp_offset = 0;\n-      cfun->machine->frame.gp_save_offset = 0;\n+      cfun->machine->gp_sp_offset = 0;\n+      cfun->machine->gp_save_offset = 0;\n     }\n \n-  cfun->machine->frame.fp_sp_offset = 0;\n-  cfun->machine->frame.fp_save_offset = 0;\n+  cfun->machine->fp_sp_offset = 0;\n+  cfun->machine->fp_save_offset = 0;\n \n   /* Ok, we're done.  */\n   return total_size;\n@@ -2100,15 +2124,15 @@ iq2000_initial_elimination_offset (int from, int to ATTRIBUTE_UNUSED)\n   if ((from) == FRAME_POINTER_REGNUM) \n     (offset) = 0; \n   else if ((from) == ARG_POINTER_REGNUM) \n-    (offset) = (cfun->machine->frame.total_size); \n+    (offset) = (cfun->machine->total_size); \n   else if ((from) == RETURN_ADDRESS_POINTER_REGNUM) \n-  {\n-   if (leaf_function_p ()) \n-      (offset) = 0; \n-   else (offset) = cfun->machine->frame.gp_sp_offset \n-\t       + ((UNITS_PER_WORD - (POINTER_SIZE / BITS_PER_UNIT)) \n-\t\t  * (BYTES_BIG_ENDIAN != 0)); \n-  } \n+    {\n+      if (leaf_function_p ()) \n+\t(offset) = 0; \n+      else (offset) = cfun->machine->gp_sp_offset \n+\t     + ((UNITS_PER_WORD - (POINTER_SIZE / BITS_PER_UNIT)) \n+\t\t* (BYTES_BIG_ENDIAN != 0)); \n+    }\n \n   return offset;\n }\n@@ -2164,10 +2188,12 @@ iq2000_emit_frame_related_store (rtx mem, rtx reg, HOST_WIDE_INT offset)\n \t\t\t    gen_rtx_SET (GET_MODE (reg), dwarf_mem, reg));\n }\n \n+/* Emit instructions to save/restore registers, as determined by STORE_P.  */\n+\n static void\n save_restore_insns (int store_p)\n {\n-  long mask = cfun->machine->frame.mask;\n+  long mask = cfun->machine->mask;\n   int regno;\n   rtx base_reg_rtx;\n   HOST_WIDE_INT base_offset;\n@@ -2196,9 +2222,9 @@ save_restore_insns (int store_p)\n      the constant created in the prologue/epilogue to adjust the stack\n      frame.  */\n \n-  gp_offset = cfun->machine->frame.gp_sp_offset;\n+  gp_offset = cfun->machine->gp_sp_offset;\n   end_offset\n-    = gp_offset - (cfun->machine->frame.gp_reg_size\n+    = gp_offset - (cfun->machine->gp_reg_size\n \t\t   - GET_MODE_SIZE (gpr_mode));\n \n   if (gp_offset < 0 || end_offset < 0)\n@@ -2212,6 +2238,7 @@ save_restore_insns (int store_p)\n     {\n       int regno;\n       int reg_save_count = 0;\n+\n       for (regno = GP_REG_LAST; regno >= GP_REG_FIRST; regno--)\n \tif (BITSET_P (mask, regno - GP_REG_FIRST)) reg_save_count += 1;\n       base_offset = gp_offset - ((reg_save_count - 1) * 4);\n@@ -2263,9 +2290,9 @@ iq2000_expand_prologue (void)\n   int store_args_on_stack = (iq2000_can_use_return_insn ());\n \n   /* If struct value address is treated as the first argument.  */\n-  if (aggregate_value_p (DECL_RESULT (fndecl))\n+  if (aggregate_value_p (DECL_RESULT (fndecl), fndecl)\n       && ! current_function_returns_pcc_struct\n-      && struct_value_incoming_rtx == 0)\n+      && targetm.calls.struct_value_rtx (TREE_TYPE (fndecl), 1) == 0)\n     {\n       tree type = build_pointer_type (fntype);\n       tree function_result_decl = build_decl (PARM_DECL, NULL_TREE, type);\n@@ -2282,7 +2309,6 @@ iq2000_expand_prologue (void)\n      variable arguments.\n \n      This is only needed if store_args_on_stack is true.  */\n-\n   INIT_CUMULATIVE_ARGS (args_so_far, fntype, NULL_RTX, 0);\n   regno = GP_ARG_FIRST;\n \n@@ -2343,7 +2369,6 @@ iq2000_expand_prologue (void)\n      Function_arg has encoded a PARALLEL rtx, holding a vector of\n      adjustments to be made as the next_arg_reg variable, so we split up the\n      insns, and emit them separately.  */\n-\n   next_arg_reg = FUNCTION_ARG (args_so_far, VOIDmode, void_type_node, 1);\n   if (next_arg_reg != 0 && GET_CODE (next_arg_reg) == PARALLEL)\n     {\n@@ -2438,7 +2463,7 @@ iq2000_expand_prologue (void)\n void\n iq2000_expand_epilogue (void)\n {\n-  HOST_WIDE_INT tsize = cfun->machine->frame.total_size;\n+  HOST_WIDE_INT tsize = cfun->machine->total_size;\n   rtx tsize_rtx = GEN_INT (tsize);\n   rtx tmp_rtx = (rtx)0;\n \n@@ -2499,7 +2524,7 @@ iq2000_expand_epilogue (void)\n void\n iq2000_expand_eh_return (rtx address)\n {\n-  HOST_WIDE_INT gp_offset = cfun->machine->frame.gp_sp_offset;\n+  HOST_WIDE_INT gp_offset = cfun->machine->gp_sp_offset;\n   rtx scratch;\n \n   scratch = plus_constant (stack_pointer_rtx, gp_offset);\n@@ -2519,8 +2544,8 @@ iq2000_can_use_return_insn (void)\n   if (regs_ever_live[31] || profile_flag)\n     return 0;\n \n-  if (cfun->machine->frame.initialized)\n-    return cfun->machine->frame.total_size == 0;\n+  if (cfun->machine->initialized)\n+    return cfun->machine->total_size == 0;\n \n   return compute_frame_size (get_frame_size ()) == 0;\n }\n@@ -2576,7 +2601,6 @@ iq2000_select_section (tree decl, int reloc ATTRIBUTE_UNUSED,\n     {\n       /* For embedded applications, always put an object in read-only data\n \t if possible, in order to reduce RAM usage.  */\n-\n       if (((TREE_CODE (decl) == VAR_DECL\n \t    && TREE_READONLY (decl) && !TREE_SIDE_EFFECTS (decl)\n \t    && DECL_INITIAL (decl)\n@@ -2594,7 +2618,6 @@ iq2000_select_section (tree decl, int reloc ATTRIBUTE_UNUSED,\n     {\n       /* For hosted applications, always put an object in small data if\n \t possible, as this gives the best performance.  */\n-\n       if (((TREE_CODE (decl) == VAR_DECL\n \t\t && TREE_READONLY (decl) && !TREE_SIDE_EFFECTS (decl)\n \t\t && DECL_INITIAL (decl)\n@@ -2639,13 +2662,13 @@ function_arg_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n   /* We must pass by reference if we would be both passing in registers\n      and the stack.  This is because any subsequent partial arg would be\n      handled incorrectly in this case.  */\n-\n   if (cum && MUST_PASS_IN_STACK (mode, type))\n      {\n        /* Don't pass the actual CUM to FUNCTION_ARG, because we would\n \t  get double copies of any offsets generated for small structs\n \t  passed in registers.  */\n        CUMULATIVE_ARGS temp;\n+\n        temp = *cum;\n        if (FUNCTION_ARG (temp, mode, type, named) != 0)\n \t return 1;\n@@ -2665,10 +2688,10 @@ int\n iq2000_adjust_insn_length (rtx insn, int length)\n {\n   /* A unconditional jump has an unfilled delay slot if it is not part\n-     of a sequence.  A conditional jump normally has a delay slot */\n+     of a sequence.  A conditional jump normally has a delay slot.  */\n   if (simplejump_p (insn)\n-      || ((GET_CODE (insn) == JUMP_INSN\n-\t\t\t      || GET_CODE (insn) == CALL_INSN)))\n+      || (   (GET_CODE (insn) == JUMP_INSN\n+\t   || GET_CODE (insn) == CALL_INSN)))\n     length += 4;\n \n   return length;\n@@ -2690,13 +2713,13 @@ iq2000_adjust_insn_length (rtx insn, int length)\n    reversed conditional branch around a `jr' instruction.  */\n \n char *\n-iq2000_output_conditional_branch (rtx insn, rtx *operands, int two_operands_p,\n+iq2000_output_conditional_branch (rtx insn, rtx * operands, int two_operands_p,\n \t\t\t\t  int float_p, int inverted_p, int length)\n {\n   static char buffer[200];\n   /* The kind of comparison we are doing.  */\n   enum rtx_code code = GET_CODE (operands[0]);\n-  /* Nonzero if the opcode for the comparison needs a `z' indicating\n+  /* nonzero if the opcode for the comparison needs a `z' indicating\n      that it is a comparison against zero.  */\n   int need_z_p;\n   /* A string to use in the assembly output to represent the first\n@@ -2711,7 +2734,7 @@ iq2000_output_conditional_branch (rtx insn, rtx *operands, int two_operands_p,\n   /* The operand-printing string for the inverted comparison.  */\n   const char *inverted_comp = (float_p ? \"%W0\" : \"%N0\");\n \n-  /* likely variants of each branch instruction annul the instruction\n+  /* Likely variants of each branch instruction annul the instruction\n      in the delay slot if the branch is not taken.  */\n   iq2000_branch_likely = (final_sequence && INSN_ANNULLED_BRANCH_P (insn));\n \n@@ -2813,7 +2836,7 @@ iq2000_output_conditional_branch (rtx insn, rtx *operands, int two_operands_p,\n \tchar *c;\n \n \tc = strchr (buffer, '\\0');\n-\t/* Generate the reversed comparison.  This takes four\n+\t/* Generate the reversed comparision.  This takes four\n \t   bytes.  */\n \tif (float_p)\n \t  sprintf (c, \"b%s\\t%%Z2%s\",\n@@ -2843,32 +2866,10 @@ iq2000_output_conditional_branch (rtx insn, rtx *operands, int two_operands_p,\n   return 0;\n }\n \n-static enum processor_type\n-iq2000_parse_cpu (const char *cpu_string)\n-{\n-  const char *p = cpu_string;\n-  enum processor_type cpu;\n-\n-  cpu = PROCESSOR_DEFAULT;\n-  switch (p[2])\n-    {\n-    case '1':\n-      if (!strcmp (p, \"iq10\"))\n-\tcpu = PROCESSOR_IQ10;\n-      break;\n-    case '2':\n-      if (!strcmp (p, \"iq2000\"))\n-\tcpu = PROCESSOR_IQ2000;\n-      break;\n-    }\n-\n-  return cpu;\n-}\n-\n #define def_builtin(NAME, TYPE, CODE) \\\n   builtin_function ((NAME), (TYPE), (CODE), BUILT_IN_MD, NULL, NULL_TREE)\n \n-void\n+static void\n iq2000_init_builtins (void)\n {\n   tree endlink = void_list_node;\n@@ -2999,7 +3000,7 @@ void_ftype_int_int_int\n }\n \n /* Builtin for ICODE having ARGCOUNT args in ARGLIST where each arg\n-   has an rtx CODE */\n+   has an rtx CODE.  */\n \n static rtx\n expand_one_builtin (enum insn_code icode, rtx target, tree arglist,\n@@ -3079,7 +3080,7 @@ expand_one_builtin (enum insn_code icode, rtx target, tree arglist,\n    SUBTARGET may be used as the target for computing one of EXP's operands.\n    IGNORE is nonzero if the value is to be ignored.  */\n \n-rtx\n+static rtx\n iq2000_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n \t\t       enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t       int ignore ATTRIBUTE_UNUSED)\n@@ -3263,11 +3264,12 @@ iq2000_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n \f\n void\n iq2000_setup_incoming_varargs (CUMULATIVE_ARGS cum, int mode ATTRIBUTE_UNUSED,\n-\t\t\t       tree type ATTRIBUTE_UNUSED, int *pretend_size,\n-\t\t\t       int no_rtl) \n+\t\t\t       tree type ATTRIBUTE_UNUSED, int * pretend_size,\n+\t\t\t       int no_rtl)\n {\n   unsigned int iq2000_off = (! (cum).last_arg_fp); \n   unsigned int iq2000_fp_off = ((cum).last_arg_fp); \n+\n   if (((cum).arg_words < MAX_ARGS_IN_REGISTERS - iq2000_off))\n     {\n       int iq2000_save_gp_regs \n@@ -3303,11 +3305,10 @@ iq2000_setup_incoming_varargs (CUMULATIVE_ARGS cum, int mode ATTRIBUTE_UNUSED,\n \f\n /* A C compound statement to output to stdio stream STREAM the\n    assembler syntax for an instruction operand that is a memory\n-   reference whose address is ADDR.  ADDR is an RTL expression.\n-*/\n+   reference whose address is ADDR.  ADDR is an RTL expression.  */\n \n void\n-print_operand_address (FILE *file, rtx addr)\n+print_operand_address (FILE * file, rtx addr)\n {\n   if (!addr)\n     error (\"PRINT_OPERAND_ADDRESS, null pointer\");\n@@ -3324,8 +3325,8 @@ print_operand_address (FILE *file, rtx addr)\n \n       case LO_SUM:\n \t{\n-\t  register rtx arg0 = XEXP (addr, 0);\n-\t  register rtx arg1 = XEXP (addr, 1);\n+\t  rtx arg0 = XEXP (addr, 0);\n+\t  rtx arg1 = XEXP (addr, 1);\n \n \t  if (GET_CODE (arg0) != REG)\n \t    abort_with_insn (addr,\n@@ -3339,10 +3340,10 @@ print_operand_address (FILE *file, rtx addr)\n \n       case PLUS:\n \t{\n-\t  register rtx reg = 0;\n-\t  register rtx offset = 0;\n-\t  register rtx arg0 = XEXP (addr, 0);\n-\t  register rtx arg1 = XEXP (addr, 1);\n+\t  rtx reg = 0;\n+\t  rtx offset = 0;\n+\t  rtx arg0 = XEXP (addr, 0);\n+\t  rtx arg1 = XEXP (addr, 1);\n \n \t  if (GET_CODE (arg0) == REG)\n \t    {\n@@ -3388,25 +3389,24 @@ print_operand_address (FILE *file, rtx addr)\n     }\n }\n \f\n-/* A C compound statement to output to stdio stream STREAM the\n-   assembler syntax for an instruction operand X.  X is an RTL\n-   expression.\n+/* A C compound statement to output to stdio stream FILE the\n+   assembler syntax for an instruction operand OP.\n \n-   CODE is a value that can be used to specify one of several ways\n+   LETTER is a value that can be used to specify one of several ways\n    of printing the operand.  It is used when identical operands\n-   must be printed differently depending on the context.  CODE\n+   must be printed differently depending on the context.  LETTER\n    comes from the `%' specification that was used to request\n    printing of the operand.  If the specification was just `%DIGIT'\n-   then CODE is 0; if the specification was `%LTR DIGIT' then CODE\n+   then LETTER is 0; if the specification was `%LTR DIGIT' then LETTER\n    is the ASCII code for LTR.\n \n-   If X is a register, this macro should print the register's name.\n+   If OP is a register, this macro should print the register's name.\n    The names can be found in an array `reg_names' whose type is\n    `char *[]'.  `reg_names' is initialized from `REGISTER_NAMES'.\n \n    When the machine description has a specification `%PUNCT' (a `%'\n    followed by a punctuation character), this macro is called with\n-   a null pointer for X and the punctuation character for CODE.\n+   a null pointer for X and the punctuation character for LETTER.\n \n    The IQ2000 specific codes are:\n \n@@ -3438,7 +3438,7 @@ print_operand_address (FILE *file, rtx addr)\n void\n print_operand (FILE *file, rtx op, int letter)\n {\n-  register enum rtx_code code;\n+  enum rtx_code code;\n \n   if (PRINT_OPERAND_PUNCT_VALID_P (letter))\n     {\n@@ -3558,7 +3558,7 @@ print_operand (FILE *file, rtx op, int letter)\n \n   else if (letter == 'Z')\n     {\n-      register int regnum;\n+      int regnum;\n \n       if (code != REG)\n \tabort ();\n@@ -3571,7 +3571,7 @@ print_operand (FILE *file, rtx op, int letter)\n \n   else if (code == REG || code == SUBREG)\n     {\n-      register int regnum;\n+      int regnum;\n \n       if (code == REG)\n \tregnum = REGNO (op);\n@@ -3635,3 +3635,143 @@ print_operand (FILE *file, rtx op, int letter)\n   else\n     output_addr_const (file, op);\n }\n+\n+static bool\n+iq2000_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED, int * total)\n+{\n+  enum machine_mode mode = GET_MODE (x);\n+\n+  switch (code)\n+    {\n+    case MEM:\n+      {\n+\tint num_words = (GET_MODE_SIZE (mode) > UNITS_PER_WORD) ? 2 : 1;\n+\n+\tif (simple_memory_operand (x, mode))\n+\t  return COSTS_N_INSNS (num_words);\n+\n+\t* total = COSTS_N_INSNS (2 * num_words);\n+\tbreak;\n+      }\n+      \n+    case FFS:\n+      * total = COSTS_N_INSNS (6);\n+      break;\n+\n+    case AND:\n+    case IOR:\n+    case XOR:\n+    case NOT:\n+      * total = COSTS_N_INSNS (mode == DImode ? 2 : 1);\n+      break;\n+\n+    case ASHIFT:\n+    case ASHIFTRT:\n+    case LSHIFTRT:\n+      if (mode == DImode)\n+\t* total = COSTS_N_INSNS ((GET_CODE (XEXP (x, 1)) == CONST_INT) ? 4 : 12);\n+      else\n+\t* total = COSTS_N_INSNS (1);\n+    break;\t\t\t\t\t\t\t\t\n+\n+    case ABS:\n+      if (mode == SFmode || mode == DFmode)\n+\t* total = COSTS_N_INSNS (1);\n+      else\n+\t* total = COSTS_N_INSNS (4);\n+      break;\n+    \n+    case PLUS:\n+    case MINUS:\n+      if (mode == SFmode || mode == DFmode)\n+\t* total = COSTS_N_INSNS (6);\n+      else if (mode == DImode)\n+\t* total = COSTS_N_INSNS (4);\n+      else\n+\t* total = COSTS_N_INSNS (1);\n+      break;\n+    \n+    case NEG:\n+      * total = (mode == DImode) ? 4 : 1;\n+      break;\n+\n+    case MULT:\n+      if (mode == SFmode)\n+\t* total = COSTS_N_INSNS (7);\n+      else if (mode == DFmode)\n+\t* total = COSTS_N_INSNS (8);\n+      else\n+\t* total = COSTS_N_INSNS (10);\n+      break;\n+\n+    case DIV:\n+    case MOD:\n+      if (mode == SFmode)\n+\t* total = COSTS_N_INSNS (23);\n+      else if (mode == DFmode)\n+\t* total = COSTS_N_INSNS (36);\n+      else\n+\t* total = COSTS_N_INSNS (69);\n+      break;\n+      \n+    case UDIV:\n+    case UMOD:\n+      * total = COSTS_N_INSNS (69);\n+      break;\n+      \n+    case SIGN_EXTEND:\n+      * total = COSTS_N_INSNS (2);\n+      break;\n+    \n+    case ZERO_EXTEND:\n+      * total = COSTS_N_INSNS (1);\n+      break;\n+\n+    case CONST_INT:\n+      * total = 0;\n+      break;\n+    \n+    case LABEL_REF:\n+      * total = COSTS_N_INSNS (2);\n+      break;\n+\n+    case CONST:\n+      {\n+\trtx offset = const0_rtx;\n+\trtx symref = eliminate_constant_term (XEXP (x, 0), & offset);\n+\n+\tif (GET_CODE (symref) == LABEL_REF)\n+\t  * total = COSTS_N_INSNS (2);\n+\telse if (GET_CODE (symref) != SYMBOL_REF)\n+\t  * total = COSTS_N_INSNS (4);\n+\t/* let's be paranoid....  */\n+\telse if (INTVAL (offset) < -32768 || INTVAL (offset) > 32767)\n+\t  * total = COSTS_N_INSNS (2);\n+\telse\n+\t  * total = COSTS_N_INSNS (SYMBOL_REF_FLAG (symref) ? 1 : 2);\n+\tbreak;\n+      }\n+\n+    case SYMBOL_REF:\n+      * total = COSTS_N_INSNS (SYMBOL_REF_FLAG (x) ? 1 : 2);\n+      break;\n+    \n+    case CONST_DOUBLE:\n+      {\n+\trtx high, low;\n+      \n+\tsplit_double (x, & high, & low);\n+      \n+\t* total = COSTS_N_INSNS (  (high == CONST0_RTX (GET_MODE (high))\n+\t\t\t\t  || low == CONST0_RTX (GET_MODE (low)))\n+\t\t\t\t   ? 2 : 4);\n+\tbreak;\n+      }\n+    \n+    default:\n+      return false;\n+    }\n+  return true;\n+}\n+\n+#include \"gt-iq2000.h\""}, {"sha": "a54856a402be97823ef15995ad5e87859c3ebdde", "filename": "gcc/config/iq2000/iq2000.h", "status": "modified", "additions": 152, "deletions": 342, "changes": 494, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5144086d5b3629755524744084a6d696723efc5/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5144086d5b3629755524744084a6d696723efc5/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.h?ref=b5144086d5b3629755524744084a6d696723efc5", "patch": "@@ -21,7 +21,7 @@\n \n /* Driver configuration.  */\n \n-#undef SWITCH_TAKES_ARG\n+#undef  SWITCH_TAKES_ARG\n #define SWITCH_TAKES_ARG(CHAR)\t\t\t\t\t\t\\\n   (DEFAULT_SWITCH_TAKES_ARG (CHAR) || (CHAR) == 'G')\n \n@@ -38,28 +38,26 @@\n #define TARGET_CPU_CPP_BUILTINS()               \\\n   do                                            \\\n     {                                           \\\n-     builtin_define (\"__iq2000__\"); \\\n-     builtin_assert (\"cpu=iq2000\"); \\\n-     builtin_assert (\"machine=iq2000\"); \\\n+      builtin_define (\"__iq2000__\"); \t\t\\\n+      builtin_assert (\"cpu=iq2000\"); \t\t\\\n+      builtin_assert (\"machine=iq2000\");\t\\\n     }                                           \\\n   while (0)\n \n-\n extern int\ttarget_flags;\n \n-#define MASK_GPOPT         0x00000008   /* Optimize for global pointer */\n-#define MASK_EMBEDDED_DATA 0x00008000   /* Reduce RAM usage, not fast code */\n+#define MASK_GPOPT         0x00000008   /* Optimize for global pointer.  */\n+#define MASK_EMBEDDED_DATA 0x00008000   /* Reduce RAM usage, not fast code.  */\n #define MASK_UNINIT_CONST_IN_RODATA \\\n                            0x00800000   /* Store uninitialized\n-                                           consts in rodata */\n+                                           consts in rodata.  */\n \n /* Macros used in the machine description to test the flags.  */\n \n #define TARGET_STATS\t\t0\n \n-\t\t\t\t\t/* for embedded systems, optimize for\n-\t\t\t\t\t   reduced RAM space instead of for\n-\t\t\t\t\t   fastest code.  */\n+/* For embedded systems, optimize for reduced RAM space instead of for\n+   fastest code.  */\n #define TARGET_EMBEDDED_DATA\t(target_flags & MASK_EMBEDDED_DATA)\n \n #define TARGET_DEBUG_MODE\t(target_flags & 0)\n@@ -134,23 +132,15 @@ extern int\ttarget_flags;\n \f\n /* Storage Layout.  */\n \n-#define BITS_BIG_ENDIAN 0\n-\n-#define BYTES_BIG_ENDIAN 1 \n-\n-#define WORDS_BIG_ENDIAN 1\n-\n-#define LIBGCC2_WORDS_BIG_ENDIAN 1\n-\n-#define BITS_PER_WORD 32\n-\n-#define MAX_BITS_PER_WORD 64\n-\n-#define UNITS_PER_WORD 4\n-\n-#define MIN_UNITS_PER_WORD 4\n-\n-#define POINTER_SIZE 32\n+#define BITS_BIG_ENDIAN \t\t0\n+#define BYTES_BIG_ENDIAN \t\t1 \n+#define WORDS_BIG_ENDIAN \t\t1\n+#define LIBGCC2_WORDS_BIG_ENDIAN\t1\n+#define BITS_PER_WORD \t\t\t32\n+#define MAX_BITS_PER_WORD \t\t64\n+#define UNITS_PER_WORD \t\t\t4\n+#define MIN_UNITS_PER_WORD \t\t4\n+#define POINTER_SIZE \t\t\t32\n \n /* Define this macro if it is advisable to hold scalars in registers\n    in a wider mode than that declared by the program.  In such cases,\n@@ -177,7 +167,7 @@ extern int\ttarget_flags;\n \n #define BIGGEST_ALIGNMENT 64\n \n-#undef DATA_ALIGNMENT\n+#undef  DATA_ALIGNMENT\n #define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\t\t\t\\\n   ((((ALIGN) < BITS_PER_WORD)\t\t\t\t\t\t\\\n     && (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\t\t\t\\\n@@ -201,27 +191,16 @@ extern int\ttarget_flags;\n \f\n /* Layout of Source Language Data Types.  */\n \n-#define INT_TYPE_SIZE 32\n-\n-#define MAX_INT_TYPE_SIZE 32\n-\n-#define SHORT_TYPE_SIZE 16\n-\n-#define LONG_TYPE_SIZE 32\n-\n-#define LONG_LONG_TYPE_SIZE 64\n-\n-#define CHAR_TYPE_SIZE BITS_PER_UNIT\n-\n-#define FLOAT_TYPE_SIZE 32\n-\n-#define DOUBLE_TYPE_SIZE 64\n-\n-#define LONG_DOUBLE_TYPE_SIZE 64\n-\n-#define DEFAULT_SIGNED_CHAR 1\n-\n-#define MAX_WCHAR_TYPE_SIZE MAX_INT_TYPE_SIZE\n+#define INT_TYPE_SIZE \t\t32\n+#define SHORT_TYPE_SIZE \t16\n+#define LONG_TYPE_SIZE \t\t32\n+#define LONG_LONG_TYPE_SIZE \t64\n+#define CHAR_TYPE_SIZE\t\tBITS_PER_UNIT\n+#define FLOAT_TYPE_SIZE \t32\n+#define DOUBLE_TYPE_SIZE \t64\n+#define LONG_DOUBLE_TYPE_SIZE\t64\n+#define DEFAULT_SIGNED_CHAR\t1\n+#define MAX_WCHAR_TYPE_SIZE\t32\n \n \f\n /* Register Basics.  */\n@@ -255,15 +234,15 @@ extern int\ttarget_flags;\n #define HARD_REGNO_NREGS(REGNO, MODE)   \\\n   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n-#define HARD_REGNO_MODE_OK(REGNO, MODE) \t\t\t\t\\\n- ((REGNO_REG_CLASS (REGNO) == GR_REGS)\t\t\t\t\t\\\n-  ? ((REGNO) & 1) == 0 || GET_MODE_SIZE (MODE) <= 4     \t\t\\\n+#define HARD_REGNO_MODE_OK(REGNO, MODE) \t\t\t\\\n+ ((REGNO_REG_CLASS (REGNO) == GR_REGS)\t\t\t\t\\\n+  ? ((REGNO) & 1) == 0 || GET_MODE_SIZE (MODE) <= 4     \t\\\n   : ((REGNO) & 1) == 0 || GET_MODE_SIZE (MODE) == 4)\n \n-#define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\t\t\\\n-  ((GET_MODE_CLASS (MODE1) == MODE_FLOAT ||\t\t\t\t\\\n-    GET_MODE_CLASS (MODE1) == MODE_COMPLEX_FLOAT)\t\t\t\\\n-   == (GET_MODE_CLASS (MODE2) == MODE_FLOAT ||\t\t\t\t\\\n+#define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\t\\\n+  ((GET_MODE_CLASS (MODE1) == MODE_FLOAT ||\t\t\t\\\n+    GET_MODE_CLASS (MODE1) == MODE_COMPLEX_FLOAT)\t\t\\\n+   == (GET_MODE_CLASS (MODE2) == MODE_FLOAT ||\t\t\t\\\n        GET_MODE_CLASS (MODE2) == MODE_COMPLEX_FLOAT))\n \n #define AVOID_CCMODE_COPIES\n@@ -273,28 +252,28 @@ extern int\ttarget_flags;\n \n enum reg_class\n {\n-  NO_REGS,\t\t\t/* no registers in set */\n-  GR_REGS,\t\t\t/* integer registers */\n-  ALL_REGS,\t\t\t/* all registers */\n-  LIM_REG_CLASSES\t\t/* max value + 1 */\n+  NO_REGS,\t\t\t/* No registers in set.  */\n+  GR_REGS,\t\t\t/* Integer registers.  */\n+  ALL_REGS,\t\t\t/* All registers.  */\n+  LIM_REG_CLASSES\t\t/* Max value + 1.  */\n };\n \n #define GENERAL_REGS GR_REGS\n \n #define N_REG_CLASSES (int) LIM_REG_CLASSES\n \n-#define REG_CLASS_NAMES\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  \"NO_REGS\",\t\t\t\t\t\t\t\t\\\n-  \"GR_REGS\",\t\t\t\t\t\t\t\t\\\n-  \"ALL_REGS\"\t\t\t\t\t\t\t\t\\\n+#define REG_CLASS_NAMES\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  \"NO_REGS\",\t\t\t\t\t\t\t\\\n+  \"GR_REGS\",\t\t\t\t\t\t\t\\\n+  \"ALL_REGS\"\t\t\t\t\t\t\t\\\n }\n \n-#define REG_CLASS_CONTENTS\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  { 0x00000000, 0x00000000 },\t/* no registers */\t\\\n-  { 0xffffffff, 0x00000000 },\t/* integer registers */\t\\\n-  { 0xffffffff, 0x00000001 }\t/* all registers */\t\\\n+#define REG_CLASS_CONTENTS\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  { 0x00000000, 0x00000000 },\t/* No registers,  */\t\t\\\n+  { 0xffffffff, 0x00000000 },\t/* Integer registers.  */\t\\\n+  { 0xffffffff, 0x00000001 }\t/* All registers.  */\t\t\\\n }\n \n #define REGNO_REG_CLASS(REGNO) \\\n@@ -305,22 +284,22 @@ enum reg_class\n #define INDEX_REG_CLASS NO_REGS\n \n #define REG_CLASS_FROM_LETTER(C) \\\n-  ((C) == 'd' ? GR_REGS : \\\n-   (C) == 'b' ? ALL_REGS : \\\n-   (C) == 'y' ? GR_REGS : \\\n+  ((C) == 'd' ? GR_REGS :        \\\n+   (C) == 'b' ? ALL_REGS :       \\\n+   (C) == 'y' ? GR_REGS :        \\\n    NO_REGS)\n \n #define REGNO_OK_FOR_INDEX_P(regno)\t0\n \n-#define PREFERRED_RELOAD_CLASS(X,CLASS)\t\t\t\t\t\\\n-  ((CLASS) != ALL_REGS\t\t\t\t\t\t\t\\\n-   ? (CLASS)\t\t\t\t\t\t\t\t\\\n-   : ((GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT\t\t\t\\\n-       || GET_MODE_CLASS (GET_MODE (X)) == MODE_COMPLEX_FLOAT)\t\t\\\n-      ? (GR_REGS)\t\t\t\t\\\n-      : ((GET_MODE_CLASS (GET_MODE (X)) == MODE_INT\t\t\t\\\n-\t  || GET_MODE (X) == VOIDmode)\t\t\t\t\t\\\n-\t ? (GR_REGS)\t\t\t\t\\\n+#define PREFERRED_RELOAD_CLASS(X,CLASS)\t\t\t\t\\\n+  ((CLASS) != ALL_REGS\t\t\t\t\t\t\\\n+   ? (CLASS)\t\t\t\t\t\t\t\\\n+   : ((GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT\t\t\\\n+       || GET_MODE_CLASS (GET_MODE (X)) == MODE_COMPLEX_FLOAT)\t\\\n+      ? (GR_REGS)\t\t\t\t\t\t\\\n+      : ((GET_MODE_CLASS (GET_MODE (X)) == MODE_INT\t\t\\\n+\t  || GET_MODE (X) == VOIDmode)\t\t\t\t\\\n+\t ? (GR_REGS)\t\t\t\t\t\t\\\n \t : (CLASS))))\n \n #define SMALL_REGISTER_CLASSES 0\n@@ -346,8 +325,7 @@ enum reg_class\n \n    `N'\tis used for constants 0xffffnnnn or 0xnnnnffff\n \n-   `O'\tis a 5 bit zero-extended integer.\n-*/\n+   `O'\tis a 5 bit zero-extended integer.  */\n \n #define CONST_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\t\\\n   ((C) == 'I' ? ((unsigned HOST_WIDE_INT) ((VALUE) + 0x8000) < 0x10000)\t\\\n@@ -412,18 +390,12 @@ enum reg_class\n \f\n /* Register That Address the Stack Frame.  */\n \n-#define STACK_POINTER_REGNUM (GP_REG_FIRST + 29)\n-\n-#define FRAME_POINTER_REGNUM (GP_REG_FIRST + 1)\n-\n-#define HARD_FRAME_POINTER_REGNUM \\\n-  (GP_REG_FIRST + 27)\n-\n-#define ARG_POINTER_REGNUM GP_REG_FIRST\n-\n-#define RETURN_ADDRESS_POINTER_REGNUM RAP_REG_NUM\n-\n-#define STATIC_CHAIN_REGNUM (GP_REG_FIRST + 2)\n+#define STACK_POINTER_REGNUM \t\t(GP_REG_FIRST + 29)\n+#define FRAME_POINTER_REGNUM \t\t(GP_REG_FIRST + 1)\n+#define HARD_FRAME_POINTER_REGNUM \t(GP_REG_FIRST + 27)\n+#define ARG_POINTER_REGNUM \t\tGP_REG_FIRST\n+#define RETURN_ADDRESS_POINTER_REGNUM\tRAP_REG_NUM\n+#define STATIC_CHAIN_REGNUM \t\t(GP_REG_FIRST + 2)\n \n \f\n /* Eliminating the Frame Pointer and the Arg Pointer.  */\n@@ -471,39 +443,40 @@ enum reg_class\n /* Function Arguments in Registers.  */\n \n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n-  function_arg( &CUM, MODE, TYPE, NAMED)\n+  function_arg (& CUM, MODE, TYPE, NAMED)\n \n #define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n-  function_arg_partial_nregs (&CUM, MODE, TYPE, NAMED)\n+  function_arg_partial_nregs (& CUM, MODE, TYPE, NAMED)\n \n #define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED)\t\t\\\n-  function_arg_pass_by_reference (&CUM, MODE, TYPE, NAMED)\n+  function_arg_pass_by_reference (& CUM, MODE, TYPE, NAMED)\n \n #define FUNCTION_ARG_CALLEE_COPIES(CUM, MODE, TYPE, NAMED)\t\t\\\n   ((NAMED) && FUNCTION_ARG_PASS_BY_REFERENCE (CUM, MODE, TYPE, NAMED))\n \n #define MAX_ARGS_IN_REGISTERS 8\n \n-typedef struct iq2000_args {\n-  int gp_reg_found;\t\t/* whether a gp register was found yet */\n-  unsigned int arg_number;\t/* argument number */\n-  unsigned int arg_words;\t/* # total words the arguments take */\n-  unsigned int fp_arg_words;\t/* # words for FP args (IQ2000_EABI only) */\n-  int last_arg_fp;\t\t/* nonzero if last arg was FP (EABI only) */\n-  int fp_code;\t\t\t/* Mode of FP arguments */\n-  unsigned int num_adjusts;\t/* number of adjustments made */\n+typedef struct iq2000_args\n+{\n+  int gp_reg_found;\t\t/* Whether a gp register was found yet.  */\n+  unsigned int arg_number;\t/* Argument number.  */\n+  unsigned int arg_words;\t/* # total words the arguments take.  */\n+  unsigned int fp_arg_words;\t/* # words for FP args (IQ2000_EABI only).  */\n+  int last_arg_fp;\t\t/* Nonzero if last arg was FP (EABI only).  */\n+  int fp_code;\t\t\t/* Mode of FP arguments.  */\n+  unsigned int num_adjusts;\t/* Number of adjustments made.  */\n \t\t\t\t/* Adjustments made to args pass in regs.  */\n-  struct rtx_def *adjust[MAX_ARGS_IN_REGISTERS*2];\n+  struct rtx_def * adjust[MAX_ARGS_IN_REGISTERS * 2];\n } CUMULATIVE_ARGS;\n \n /* Initialize a variable CUM of type CUMULATIVE_ARGS\n    for a call to a function whose data type is FNTYPE.\n    For a library call, FNTYPE is 0.  */\n #define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,INDIRECT)\t\t\\\n-  init_cumulative_args (&CUM, FNTYPE, LIBNAME)\t\t\t\t\\\n+  init_cumulative_args (& CUM, FNTYPE, LIBNAME)\t\t\t\t\\\n \n #define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\t\t\\\n-  function_arg_advance (&CUM, MODE, TYPE, NAMED)\n+  function_arg_advance (& CUM, MODE, TYPE, NAMED)\n \n #define FUNCTION_ARG_PADDING(MODE, TYPE)\t\t\t\t\\\n   (! BYTES_BIG_ENDIAN\t\t\t\t\t\t\t\\\n@@ -641,24 +614,24 @@ typedef struct iq2000_args {\n /* Addressing Modes.  */\n \n #define CONSTANT_ADDRESS_P(X)\t\t\t\t\t\t\\\n-  ((GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\t\\\n+  (   (GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\t\\\n     || GET_CODE (X) == CONST_INT || GET_CODE (X) == HIGH\t\t\\\n     || (GET_CODE (X) == CONST)))\n \n #define MAX_REGS_PER_ADDRESS 1\n \n #ifdef REG_OK_STRICT\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\\\n-{\t\t\t\t\t\t\\\n-  if (iq2000_legitimate_address_p (MODE, X, 1))\t\\\n-    goto ADDR;\t\t\t\t\t\\\n-}\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    if (iq2000_legitimate_address_p (MODE, X, 1))\t\\\n+      goto ADDR;\t\t\t\t\t\\\n+  }\n #else\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\\\n-{\t\t\t\t\t\t\\\n-  if (iq2000_legitimate_address_p (MODE, X, 0))\t\\\n-    goto ADDR;\t\t\t\t\t\\\n-}\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    if (iq2000_legitimate_address_p (MODE, X, 0))\t\\\n+      goto ADDR;\t\t\t\t\t\\\n+  }\n #endif\n \n #define REG_OK_FOR_INDEX_P(X) 0\n@@ -675,7 +648,7 @@ typedef struct iq2000_args {\n \n #define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n-  register rtx xinsn = (X);\t\t\t\t\t\t\\\n+  rtx xinsn = (X);\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   if (TARGET_DEBUG_B_MODE)\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n@@ -694,10 +667,10 @@ typedef struct iq2000_args {\n \t\t\t\t\t\t\t\t\t\\\n   if (GET_CODE (xinsn) == PLUS)\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      register rtx xplus0 = XEXP (xinsn, 0);\t\t\t\t\\\n-      register rtx xplus1 = XEXP (xinsn, 1);\t\t\t\t\\\n-      register enum rtx_code code0 = GET_CODE (xplus0);\t\t\t\\\n-      register enum rtx_code code1 = GET_CODE (xplus1);\t\t\t\\\n+      rtx xplus0 = XEXP (xinsn, 0);\t\t\t\t\t\\\n+      rtx xplus1 = XEXP (xinsn, 1);\t\t\t\t\t\\\n+      enum rtx_code code0 = GET_CODE (xplus0);\t\t\t\t\\\n+      enum rtx_code code1 = GET_CODE (xplus1);\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n       if (code0 != REG && code1 == REG)\t\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\t\\\n@@ -736,149 +709,6 @@ typedef struct iq2000_args {\n \f\n /* Describing Relative Costs of Operations.  */\n \n-#define CONST_COSTS(X,CODE,OUTER_CODE)\t\t\t\t\t\\\n-  case CONST_INT:\t\t\t\t\t\t\t\\\n-    return 0;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case LABEL_REF:\t\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (2);\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case CONST:\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      rtx offset = const0_rtx;\t\t\t\t\t\t\\\n-      rtx symref = eliminate_constant_term (XEXP (X, 0), &offset);\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      if (GET_CODE (symref) == LABEL_REF)\t\t\t\t\\\n-\treturn COSTS_N_INSNS (2);\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      if (GET_CODE (symref) != SYMBOL_REF)\t\t\t\t\\\n-\treturn COSTS_N_INSNS (4);\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      /* let's be paranoid....  */\t\t\t\t\t\\\n-      if (INTVAL (offset) < -32768 || INTVAL (offset) > 32767)\t\t\\\n-\treturn COSTS_N_INSNS (2);\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      return COSTS_N_INSNS (SYMBOL_REF_FLAG (symref) ? 1 : 2);\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case SYMBOL_REF:\t\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (SYMBOL_REF_FLAG (X) ? 1 : 2);\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case CONST_DOUBLE:\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      rtx high, low;\t\t\t\t\t\t\t\\\n-      split_double (X, &high, &low);\t\t\t\t\t\\\n-      return COSTS_N_INSNS ((high == CONST0_RTX (GET_MODE (high))\t\\\n-\t\t\t     || low == CONST0_RTX (GET_MODE (low)))\t\\\n-\t\t\t    ? 2 : 4);\t\t\t\t\t\\\n-    }\n-\n-#define RTX_COSTS(X,CODE,OUTER_CODE)\t\t\t\t\t\\\n-  case MEM:\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      int num_words = (GET_MODE_SIZE (GET_MODE (X)) > UNITS_PER_WORD) ? 2 : 1; \\\n-      if (simple_memory_operand (X, GET_MODE (X)))\t\t\t\\\n-\treturn COSTS_N_INSNS (num_words);\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      return COSTS_N_INSNS (2*num_words);\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case FFS:\t\t\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (6);\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case NOT:\t\t\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (GET_MODE (X) == DImode && 2); \t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case AND:\t\t\t\t\t\t\t\t\\\n-  case IOR:\t\t\t\t\t\t\t\t\\\n-  case XOR:\t\t\t\t\t\t\t\t\\\n-    if (GET_MODE (X) == DImode)\t\t\t\t\t\t\\\n-      return COSTS_N_INSNS (2);\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    break;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case ASHIFT:\t\t\t\t\t\t\t\t\\\n-  case ASHIFTRT:\t\t\t\t\t\t\t\\\n-  case LSHIFTRT:\t\t\t\t\t\t\t\\\n-    if (GET_MODE (X) == DImode)\t\t\t\t\t\t\\\n-      return COSTS_N_INSNS ((GET_CODE (XEXP (X, 1)) == CONST_INT) ? 4 : 12); \\\n-\t\t\t\t\t\t\t\t\t\\\n-    break;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case ABS:\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      enum machine_mode xmode = GET_MODE (X);\t\t\t\t\\\n-      if (xmode == SFmode || xmode == DFmode)\t\t\t\t\\\n-\treturn COSTS_N_INSNS (1);\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      return COSTS_N_INSNS (4);\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case PLUS:\t\t\t\t\t\t\t\t\\\n-  case MINUS:\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      enum machine_mode xmode = GET_MODE (X);\t\t\t\t\\\n-      if (xmode == SFmode || xmode == DFmode)\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t   return COSTS_N_INSNS (6);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      if (xmode == DImode)\t\t\t\t\t\t\\\n-\treturn COSTS_N_INSNS (4);\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case NEG:\t\t\t\t\t\t\t\t\\\n-    if (GET_MODE (X) == DImode)\t\t\t\t\t\t\\\n-      return 4;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    break;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case MULT:\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      enum machine_mode xmode = GET_MODE (X);\t\t\t\t\\\n-      if (xmode == SFmode)\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t    return COSTS_N_INSNS (7);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      if (xmode == DFmode)\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t    return COSTS_N_INSNS (8);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\treturn COSTS_N_INSNS (10);\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case DIV:\t\t\t\t\t\t\t\t\\\n-  case MOD:\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      enum machine_mode xmode = GET_MODE (X);\t\t\t\t\\\n-      if (xmode == SFmode)\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t    return COSTS_N_INSNS (23);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      if (xmode == DFmode)\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t    return COSTS_N_INSNS (36);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-    /* fall through */\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case UDIV:\t\t\t\t\t\t\t\t\\\n-  case UMOD:\t\t\t\t\t\t\t\t\\\n-      return COSTS_N_INSNS (69);\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case SIGN_EXTEND:\t\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (2);\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case ZERO_EXTEND:\t\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (1);\n-\n-#define ADDRESS_COST(ADDR) (REG_P (ADDR) ? 1 : iq2000_address_cost (ADDR))\n-\n #define REGISTER_MOVE_COST(MODE, FROM, TO)\t2\n \n #define MEMORY_MOVE_COST(MODE,CLASS,TO_P)\t\\\n@@ -899,9 +729,9 @@ typedef struct iq2000_args {\n \f\n /* Dividing the output into sections.  */\n \n-#define TEXT_SECTION_ASM_OP\t\"\\t.text\"\t/* instructions */\n+#define TEXT_SECTION_ASM_OP\t\"\\t.text\"\t/* Instructions.  */\n \n-#define DATA_SECTION_ASM_OP\t\"\\t.data\"\t/* large data */\n+#define DATA_SECTION_ASM_OP\t\"\\t.data\"\t/* Large data.  */\n \n \f\n /* The Overall Framework of an Assembler File.  */\n@@ -915,13 +745,9 @@ typedef struct iq2000_args {\n \f\n /* Output and Generation of Labels.  */\n \n-#undef ASM_OUTPUT_INTERNAL_LABEL\n-#define ASM_OUTPUT_INTERNAL_LABEL(STREAM,PREFIX,NUM)\t\t\t\\\n-  fprintf (STREAM, \"%s%s%d:\\n\", LOCAL_LABEL_PREFIX, PREFIX, NUM)\n-\n #undef ASM_GENERATE_INTERNAL_LABEL\n #define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\t\t\\\n-  sprintf ((LABEL), \"*%s%s%ld\", (LOCAL_LABEL_PREFIX), (PREFIX), (long)(NUM))\n+  sprintf ((LABEL), \"*%s%s%ld\", (LOCAL_LABEL_PREFIX), (PREFIX), (long) (NUM))\n \n #define GLOBAL_ASM_OP \"\\t.globl\\t\"\n \n@@ -989,7 +815,6 @@ typedef struct iq2000_args {\n #define DBR_OUTPUT_SEQEND(STREAM)\t\t\t\t\t\\\n do\t\t\t\t\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\t\\\n-    dslots_jump_filled++;\t\t\t\t\t\t\\\n     fputs (\"\\n\", STREAM);\t\t\t\t\t\t\\\n   }\t\t\t\t\t\t\t\t\t\\\n while (0)\n@@ -1002,11 +827,13 @@ while (0)\n /* Output of dispatch tables.  */\n \n #define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM, BODY, VALUE, REL)\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  fprintf (STREAM, \"\\t%s\\t%sL%d\\n\",\t\t\t\t\t\\\n-\t   Pmode == DImode ? \".dword\" : \".word\",\t\t\t\\\n-\t   LOCAL_LABEL_PREFIX, VALUE);\t\t\t\t\t\\\n-} while (0)\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (STREAM, \"\\t%s\\t%sL%d\\n\",\t\t\t\t\t\\\n+\t       Pmode == DImode ? \".dword\" : \".word\",\t\t\t\\\n+\t       LOCAL_LABEL_PREFIX, VALUE);\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n #define ASM_OUTPUT_ADDR_VEC_ELT(STREAM, VALUE)\t\t\t\t\\\n   fprintf (STREAM, \"\\t%s\\t%sL%d\\n\",\t\t\t\t\t\\\n@@ -1089,19 +916,19 @@ extern char\tcall_used_regs[];\n /* Comparison type.  */\n enum cmp_type\n {\n-  CMP_SI,\t\t\t\t/* compare four byte integers */\n-  CMP_DI,\t\t\t\t/* compare eight byte integers */\n-  CMP_SF,\t\t\t\t/* compare single precision floats */\n-  CMP_DF,\t\t\t\t/* compare double precision floats */\n-  CMP_MAX\t\t\t\t/* max comparison type */\n+  CMP_SI,\t\t\t\t/* Compare four byte integers.  */\n+  CMP_DI,\t\t\t\t/* Compare eight byte integers.  */\n+  CMP_SF,\t\t\t\t/* Compare single precision floats.  */\n+  CMP_DF,\t\t\t\t/* Compare double precision floats.  */\n+  CMP_MAX\t\t\t\t/* Max comparison type.  */\n };\n \n /* Types of delay slot.  */\n enum delay_type\n {\n-  DELAY_NONE,\t\t\t\t/* no delay slot */\n-  DELAY_LOAD,\t\t\t\t/* load from memory delay */\n-  DELAY_FCMP\t\t\t\t/* delay after doing c.<xx>.{d,s} */\n+  DELAY_NONE,\t\t\t\t/* No delay slot.  */\n+  DELAY_LOAD,\t\t\t\t/* Load from memory delay.  */\n+  DELAY_FCMP\t\t\t\t/* Delay after doing c.<xx>.{d,s}.  */\n };\n \n /* Which processor to schedule for.  */\n@@ -1114,36 +941,15 @@ enum processor_type\n };\n \n /* Recast the cpu class to be the cpu attribute.  */\n-#define iq2000_cpu_attr ((enum attr_cpu)iq2000_tune)\n-\n-extern char iq2000_print_operand_punct[];\t/* print_operand punctuation chars */\n-extern int num_source_filenames;\t/* current .file # */\n-extern int iq2000_branch_likely;\t\t/* emit 'l' after br (branch likely) */\n-extern struct rtx_def *branch_cmp[2];\t/* operands for compare */\n-extern enum cmp_type branch_type;\t/* what type of branch to use */\n-extern enum processor_type iq2000_arch;   /* which cpu to codegen for */\n-extern enum processor_type iq2000_tune;   /* which cpu to schedule for */\n-extern int iq2000_isa;\t\t\t/* architectural level */\n-extern const char *iq2000_cpu_string;\t/* for -mcpu=<xxx> */\n-extern const char *iq2000_arch_string;    /* for -march=<xxx> */\n-extern int dslots_load_total;\t\t/* total # load related delay slots */\n-extern int dslots_load_filled;\t\t/* # filled load delay slots */\n-extern int dslots_jump_total;\t\t/* total # jump related delay slots */\n-extern int dslots_jump_filled;\t\t/* # filled jump delay slots */\n-extern int dslots_number_nops;\t\t/* # of nops needed by previous insn */\n-extern int num_refs[3];\t\t\t/* # 1/2/3 word references */\n-extern struct rtx_def *iq2000_load_reg;\t/* register to check for load delay */\n-extern struct rtx_def *iq2000_load_reg2;\t/* 2nd reg to check for load delay */\n-extern struct rtx_def *iq2000_load_reg3;\t/* 3rd reg to check for load delay */\n-extern struct rtx_def *iq2000_load_reg4;\t/* 4th reg to check for load delay */\n+#define iq2000_cpu_attr ((enum attr_cpu) iq2000_tune)\n \n /* Functions to change what output section we are using.  */\n extern void\t\trdata_section (void);\n extern void\t\tsdata_section (void);\n-extern void\t\tsbss_section (void);\n+extern void\t\tsbss_section  (void);\n \n-#define BITMASK_UPPER16\t((unsigned long)0xffff << 16)\t/* 0xffff0000 */\n-#define BITMASK_LOWER16\t((unsigned long)0xffff)\t\t/* 0x0000ffff */\n+#define BITMASK_UPPER16\t((unsigned long) 0xffff << 16)\t/* 0xffff0000 */\n+#define BITMASK_LOWER16\t((unsigned long) 0xffff)\t/* 0x0000ffff */\n \n \f\n #define GENERATE_BRANCHLIKELY  (ISA_HAS_BRANCHLIKELY)\n@@ -1262,10 +1068,10 @@ extern void\t\tsbss_section (void);\n \n #ifndef STACK_ARGS_ADJUST\n #define STACK_ARGS_ADJUST(SIZE)\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (SIZE.constant < 4 * UNITS_PER_WORD)\t\t\t\t\\\n-    SIZE.constant = 4 * UNITS_PER_WORD;\t\t\t\t\t\\\n-}\n+  {\t\t\t\t\t\t\t\t\t\\\n+    if (SIZE.constant < 4 * UNITS_PER_WORD)\t\t\t\t\\\n+      SIZE.constant = 4 * UNITS_PER_WORD;\t\t\t\t\\\n+  }\n #endif\n \n \f\n@@ -1333,25 +1139,16 @@ extern void\t\tsbss_section (void);\n #endif\n \n #if 1\n-#define GO_PRINTF(x)\tfprintf(stderr, (x))\n-#define GO_PRINTF2(x,y)\tfprintf(stderr, (x), (y))\n-#define GO_DEBUG_RTX(x) debug_rtx(x)\n+#define GO_PRINTF(x)\tfprintf (stderr, (x))\n+#define GO_PRINTF2(x,y)\tfprintf (stderr, (x), (y))\n+#define GO_DEBUG_RTX(x) debug_rtx (x)\n \n #else\n #define GO_PRINTF(x)\n #define GO_PRINTF2(x,y)\n #define GO_DEBUG_RTX(x)\n #endif\n \n-/* Specify the tree operation to be used to convert reals to integers.  */\n-#define IMPLICIT_FIX_EXPR FIX_ROUND_EXPR\n-\n-/* This is the kind of divide that is easiest to do in the general case.  */\n-#define EASY_DIV_EXPR TRUNC_DIV_EXPR\n-\n-/* Define this if zero-extension is slow (more than one real instruction).  */\n-#define SLOW_ZERO_EXTEND\n-\n /* If defined, modifies the length assigned to instruction INSN as a\n    function of the context in which it is used.  LENGTH is an lvalue\n    that contains the initially computed length of the insn and should\n@@ -1372,7 +1169,7 @@ extern void\t\tsbss_section (void);\n /* How to tell the debugger about changes of source files.  */\n \n #ifndef SET_FILE_NUMBER\n-#define SET_FILE_NUMBER() ++num_source_filenames\n+#define SET_FILE_NUMBER() ++ num_source_filenames\n #endif\n \n /* This is how to output a note the debugger telling it the line number\n@@ -1382,28 +1179,41 @@ extern void\t\tsbss_section (void);\n #define LABEL_AFTER_LOC(STREAM)\n #endif\n \n-/* Handle certain cpp directives used in header files on sysV.  */\n-#define SCCS_DIRECTIVE\n-\n \f\n /* Default to -G 8 */\n #ifndef IQ2000_DEFAULT_GVALUE\n #define IQ2000_DEFAULT_GVALUE 8\n #endif\n \n-#define SDATA_SECTION_ASM_OP\t\"\\t.sdata\"\t/* small data */\n-\n-/* Given a decl node or constant node, choose the section to output it in\n-   and select that section.  */\n+#define SDATA_SECTION_ASM_OP\t\"\\t.sdata\"\t/* Small data.  */\n \n-#undef  TARGET_ASM_SELECT_SECTION\n-#define TARGET_ASM_SELECT_SECTION  iq2000_select_section\n \f\n /* See iq2000_expand_prologue's use of loadgp for when this should be\n    true.  */\n \n #define DONT_ACCESS_GBLS_AFTER_EPILOGUE 0\n \f\n+/* List of all IQ2000 punctuation characters used by print_operand.  */\n+extern char iq2000_print_operand_punct[256];\n+\n+/* The target cpu for optimization and scheduling.  */\n+extern enum processor_type iq2000_tune;\n+\n+/* Which instruction set architecture to use.  */\n+extern int iq2000_isa;\n+\n+/* Cached operands, and operator to compare for use in set/branch/trap\n+   on condition codes.  */\n+extern rtx branch_cmp[2];\n+\n+/* What type of branch to use.  */\n+extern enum cmp_type branch_type;\n+\n+/* Strings to hold which cpu and instruction set architecture to use.  */\n+extern const char * iq2000_cpu_string;\t  /* For -mcpu=<xxx>.  */\n+extern const char * iq2000_arch_string;   /* For -march=<xxx>.  */\n+\n+\n \n enum iq2000_builtins\n {"}]}