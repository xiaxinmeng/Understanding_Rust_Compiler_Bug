{"sha": "710384268d9df98e595cd68c5e8db84d766d5513", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzEwMzg0MjY4ZDlkZjk4ZTU5NWNkNjhjNWU4ZGI4NGQ3NjZkNTUxMw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1998-09-15T19:19:12Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1998-09-15T19:19:12Z"}, "message": "tree.h (BUILT_IN_CALLER_RETURN_ADDRESS): Unused.\n\n\t* tree.h (BUILT_IN_CALLER_RETURN_ADDRESS): Unused.  Kill.\n\t(BUILT_IN_FP, BUILT_IN_SP, BUILT_IN_SET_RETURN_ADDR_REG): Kill.\n\t(BUILT_IN_EH_STUB_OLD, BUILT_IN_EH_STUB, BUILT_IN_SET_EH_REGS): Kill.\n\t(BUILT_IN_EH_RETURN, BUILT_IN_DWARF_CFA): New.\n\t* c-decl.c (init_decl_processing): Update accordingly.\n\t* expr.c (expand_builtin): Likewise.\n\t* cp/decl.c (init_decl_processing): Likewise.\n\t* rtl.h (global_rtl): Add cfa entry.\n\t(virtual_cfa_rtx, VIRTUAL_CFA_REGNUM): New.\n\t(LAST_VIRTUAL_REGISTER): Update.\n\t* emit-rtl.c (global_rtl): Add cfa entry.\n\t(init_emit): Initialize it.\n\t* function.c (cfa_offset): New.\n\t(instantiate_virtual_regs): Initialize it.\n\t(instantiate_virtual_regs_1): Instantiate virtual_cfa_rtx.\n\t(expand_function_end): Call expand_eh_return.\n\t* tm.texi (ARG_POINTER_CFA_OFFSET): New.\n\t* except.c (current_function_eh_stub_label): Kill.\n\t(current_function_eh_old_stub_label): Likwise; update all references.\n\t(expand_builtin_set_return_addr_reg): Kill.\n\t(expand_builtin_eh_stub_old, expand_builtin_eh_stub): Kill.\n\t(expand_builtin_set_eh_regs): Kill.\n\t(eh_regs): Produce a third reg for the actual handler address.\n\t(eh_return_context, eh_return_stack_adjust): New.\n\t(eh_return_handler, eh_return_stub_label): New.\n\t(init_eh_for_function): Initialize them.\n\t(expand_builtin_eh_return, expand_eh_return): New.\n\t* except.h: Update prototypes.\n\t* flow.c (find_basic_blocks_1): Update references to the stub label.\n\t* function.h (struct function): Kill stub label elements.\n\t* libgcc2.c (in_reg_window): For REG_SAVED_REG, check that the\n\tregister number is one that would be in the previous window.\n\tProvide a dummy definition for non-windowed targets.\n\t(get_reg_addr): New function.\n\t(get_reg, put_reg, copy_reg): Use it.\n\t(__throw): Rely on in_reg_window, not INCOMING_REGNO.  Kill stub\n\tgenerating code and use __builtin_eh_return.  Use __builtin_dwarf_cfa.\n\t* alpha.c (alpha_eh_epilogue_sp_ofs): New.\n\t(alpha_init_expanders): Initialize it.\n\t(alpha_expand_epilogue): Use it.\n\t* alpha.h: Declare it.\n\t* alpha.md (eh_epilogue): New.\n\t* m68h.h (ARG_POINTER_CFA_OFFSET): New.\n\t* sparc.h (ARG_POINTER_CFA_OFFSET): New.\n\nFrom-SVN: r22436", "tree": {"sha": "5f8b92560efd1078cbd16601e8b3502296539971", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f8b92560efd1078cbd16601e8b3502296539971"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/710384268d9df98e595cd68c5e8db84d766d5513", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/710384268d9df98e595cd68c5e8db84d766d5513", "html_url": "https://github.com/Rust-GCC/gccrs/commit/710384268d9df98e595cd68c5e8db84d766d5513", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/710384268d9df98e595cd68c5e8db84d766d5513/comments", "author": null, "committer": null, "parents": [{"sha": "dfb16e8307d6ca6f9ddf22dea3400324355a60a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfb16e8307d6ca6f9ddf22dea3400324355a60a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfb16e8307d6ca6f9ddf22dea3400324355a60a7"}], "stats": {"total": 649, "additions": 372, "deletions": 277}, "files": [{"sha": "5e646cdae0657eacf68055610b31c0d227798eeb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/710384268d9df98e595cd68c5e8db84d766d5513/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/710384268d9df98e595cd68c5e8db84d766d5513/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=710384268d9df98e595cd68c5e8db84d766d5513", "patch": "@@ -1,3 +1,54 @@\n+Tue Sep 15 19:09:06 1998  Richard Henderson  <rth@cygnus.com>\n+\n+\t* tree.h (BUILT_IN_CALLER_RETURN_ADDRESS): Unused.  Kill.\n+\t(BUILT_IN_FP, BUILT_IN_SP, BUILT_IN_SET_RETURN_ADDR_REG): Kill.\n+\t(BUILT_IN_EH_STUB_OLD, BUILT_IN_EH_STUB, BUILT_IN_SET_EH_REGS): Kill.\n+\t(BUILT_IN_EH_RETURN, BUILT_IN_DWARF_CFA): New.\n+\t* c-decl.c (init_decl_processing): Update accordingly.\n+\t* expr.c (expand_builtin): Likewise.\n+\n+\t* rtl.h (global_rtl): Add cfa entry.\n+\t(virtual_cfa_rtx, VIRTUAL_CFA_REGNUM): New.\n+\t(LAST_VIRTUAL_REGISTER): Update.\n+\t* emit-rtl.c (global_rtl): Add cfa entry.\n+\t(init_emit): Initialize it.\n+\t* function.c (cfa_offset): New.\n+\t(instantiate_virtual_regs): Initialize it.\n+\t(instantiate_virtual_regs_1): Instantiate virtual_cfa_rtx.\n+\t(expand_function_end): Call expand_eh_return.\n+\t* tm.texi (ARG_POINTER_CFA_OFFSET): New.\n+\n+\t* except.c (current_function_eh_stub_label): Kill.\n+\t(current_function_eh_old_stub_label): Likwise; update all references.\n+\t(expand_builtin_set_return_addr_reg): Kill.\n+\t(expand_builtin_eh_stub_old, expand_builtin_eh_stub): Kill.\n+\t(expand_builtin_set_eh_regs): Kill.\n+\t(eh_regs): Produce a third reg for the actual handler address.\n+\t(eh_return_context, eh_return_stack_adjust): New.\n+\t(eh_return_handler, eh_return_stub_label): New.\n+\t(init_eh_for_function): Initialize them.\n+\t(expand_builtin_eh_return, expand_eh_return): New.\n+\t* except.h: Update prototypes.\n+\t* flow.c (find_basic_blocks_1): Update references to the stub label.\n+\t* function.h (struct function): Kill stub label elements.\n+\n+\t* libgcc2.c (in_reg_window): For REG_SAVED_REG, check that the\n+\tregister number is one that would be in the previous window.\n+\tProvide a dummy definition for non-windowed targets.\n+\t(get_reg_addr): New function.\n+\t(get_reg, put_reg, copy_reg): Use it.\n+\t(__throw): Rely on in_reg_window, not INCOMING_REGNO.  Kill stub\n+\tgenerating code and use __builtin_eh_return.  Use __builtin_dwarf_cfa.\n+\n+\t* alpha.c (alpha_eh_epilogue_sp_ofs): New.\n+\t(alpha_init_expanders): Initialize it.\n+\t(alpha_expand_epilogue): Use it.\n+\t* alpha.h: Declare it.\n+\t* alpha.md (eh_epilogue): New.\n+\n+\t* m68h.h (ARG_POINTER_CFA_OFFSET): New.\n+\t* sparc.h (ARG_POINTER_CFA_OFFSET): New.\n+\n Tue Sep 15 19:31:58 1998  Michael Meissner  <meissner@cygnus.com>\n \n \t* i960.h (CONST_COSTS): Fix thinko.  Test flag, not the constant"}, {"sha": "f05dc27a1a775f66507a891c17d60e75d2f80ae4", "filename": "gcc/c-decl.c", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/710384268d9df98e595cd68c5e8db84d766d5513/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/710384268d9df98e595cd68c5e8db84d766d5513/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=710384268d9df98e595cd68c5e8db84d766d5513", "patch": "@@ -3291,8 +3291,8 @@ init_decl_processing ()\n   builtin_function (\"__builtin_unwind_init\",\n \t\t    build_function_type (void_type_node, endlink),\n \t\t    BUILT_IN_UNWIND_INIT, NULL_PTR);\n-  builtin_function (\"__builtin_fp\", ptr_ftype_void, BUILT_IN_FP, NULL_PTR);\n-  builtin_function (\"__builtin_sp\", ptr_ftype_void, BUILT_IN_SP, NULL_PTR);\n+  builtin_function (\"__builtin_dwarf_cfa\", ptr_ftype_void,\n+\t\t    BUILT_IN_DWARF_CFA, NULL_PTR);\n   builtin_function (\"__builtin_dwarf_fp_regnum\",\n \t\t    build_function_type (unsigned_type_node, endlink),\n \t\t    BUILT_IN_DWARF_FP_REGNUM, NULL_PTR);\n@@ -3302,24 +3302,16 @@ init_decl_processing ()\n \t\t    BUILT_IN_FROB_RETURN_ADDR, NULL_PTR);\n   builtin_function (\"__builtin_extract_return_addr\", ptr_ftype_ptr,\n \t\t    BUILT_IN_EXTRACT_RETURN_ADDR, NULL_PTR);\n-  builtin_function (\"__builtin_set_return_addr_reg\",\n-\t\t    build_function_type (void_type_node, \n-\t\t\t\t\t tree_cons (NULL_TREE,\n-\t\t\t\t\t\t    ptr_type_node,\n-\t\t\t\t\t\t    endlink)),\n-\t\t    BUILT_IN_SET_RETURN_ADDR_REG, NULL_PTR);\n-  builtin_function (\"__builtin_eh_stub_old\", ptr_ftype_void,\n-\t\t    BUILT_IN_EH_STUB_OLD, NULL_PTR);\n-  builtin_function (\"__builtin_eh_stub\", ptr_ftype_void,\n-\t\t    BUILT_IN_EH_STUB, NULL_PTR);\n   builtin_function\n-    (\"__builtin_set_eh_regs\",\n+    (\"__builtin_eh_return\",\n      build_function_type (void_type_node,\n \t\t\t  tree_cons (NULL_TREE, ptr_type_node,\n \t\t\t\t     tree_cons (NULL_TREE,\n \t\t\t\t\t\ttype_for_mode (ptr_mode, 0),\n-\t\t\t\t\t\tendlink))),\n-     BUILT_IN_SET_EH_REGS, NULL_PTR);\n+\t\t\t\t\t        tree_cons (NULL_TREE,\n+\t\t\t\t\t\t\t   ptr_type_node,\n+\t\t\t\t\t\t\t   endlink)))),\n+     BUILT_IN_EH_RETURN, NULL_PTR);\n \n   builtin_function (\"__builtin_alloca\",\n \t\t    build_function_type (ptr_type_node,"}, {"sha": "2b2971452a70cdc9eb87835ce88b519155c72325", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 30, "deletions": 15, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/710384268d9df98e595cd68c5e8db84d766d5513/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/710384268d9df98e595cd68c5e8db84d766d5513/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=710384268d9df98e595cd68c5e8db84d766d5513", "patch": "@@ -79,6 +79,10 @@ char *alpha_mlat_string;\t/* -mmemory-latency= */\n rtx alpha_compare_op0, alpha_compare_op1;\n int alpha_compare_fp_p;\n \n+/* Define the information needed to modify the epilogue for EH.  */\n+\n+rtx alpha_eh_epilogue_sp_ofs;\n+\n /* Non-zero if inside of a function, because the Alpha asm can't\n    handle .files inside of functions.  */\n \n@@ -2431,6 +2435,7 @@ void\n alpha_init_expanders ()\n {\n   alpha_return_addr_rtx = NULL_RTX;\n+  alpha_eh_epilogue_sp_ofs = NULL_RTX;\n \n   /* Arrange to save and restore machine status around nested functions.  */\n   save_machine_status = alpha_save_machine_status;\n@@ -3731,9 +3736,13 @@ alpha_expand_epilogue ()\n \t  \n       /* Restore registers in order, excepting a true frame pointer. */\n \n-      FRP (emit_move_insn (gen_rtx_REG (DImode, REG_RA),\n-\t\t           gen_rtx_MEM (DImode, plus_constant(sa_reg,\n-\t\t\t\t\t\t\t      reg_offset))));\n+      if (! alpha_eh_epilogue_sp_ofs)\n+\t{\n+          FRP (emit_move_insn (gen_rtx_REG (DImode, REG_RA),\n+\t\t               gen_rtx_MEM (DImode,\n+\t\t\t\t\t    plus_constant(sa_reg,\n+\t\t\t\t\t\t\t  reg_offset))));\n+\t}\n       reg_offset += 8;\n       imask &= ~(1L << REG_RA);\n \n@@ -3763,21 +3772,28 @@ alpha_expand_epilogue ()\n \t  }\n     }\n \n-  if (frame_size)\n+  if (frame_size || alpha_eh_epilogue_sp_ofs)\n     {\n+      sp_adj1 = stack_pointer_rtx;\n+\n+      if (alpha_eh_epilogue_sp_ofs)\n+\t{\n+\t  sp_adj1 = gen_rtx_REG (DImode, 23);\n+\t  emit_move_insn (sp_adj1,\n+\t\t\t  gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n+\t\t\t\t\talpha_eh_epilogue_sp_ofs));\n+\t}\n+\n       /* If the stack size is large, begin computation into a temporary\n \t register so as not to interfere with a potential fp restore,\n \t which must be consecutive with an SP restore.  */\n       if (frame_size < 32768)\n-\t{\n-\t  sp_adj1 = stack_pointer_rtx;\n-\t  sp_adj2 = GEN_INT (frame_size);\n-\t}\n+\tsp_adj2 = GEN_INT (frame_size);\n       else if (frame_size < 0x40007fffL)\n \t{\n \t  int low = ((frame_size & 0xffff) ^ 0x8000) - 0x8000;\n \n-\t  sp_adj2 = plus_constant (stack_pointer_rtx, frame_size - low);\n+\t  sp_adj2 = plus_constant (sp_adj1, frame_size - low);\n \t  if (sa_reg_exp && rtx_equal_p (sa_reg_exp, sp_adj2))\n \t    sp_adj1 = sa_reg;\n \t  else\n@@ -3789,21 +3805,20 @@ alpha_expand_epilogue ()\n \t}\n       else\n \t{\n-\t  sp_adj2 = gen_rtx_REG (DImode, 23);\n-\t  FRP (sp_adj1 = alpha_emit_set_const (sp_adj2, DImode, frame_size, 3));\n-\t  if (!sp_adj1)\n+\t  rtx tmp = gen_rtx_REG (DImode, 23);\n+\t  FRP (sp_adj2 = alpha_emit_set_const (tmp, DImode, frame_size, 3));\n+\t  if (!sp_adj2)\n \t    {\n \t      /* We can't drop new things to memory this late, afaik,\n \t\t so build it up by pieces.  */\n #if HOST_BITS_PER_WIDE_INT == 64\n-\t      FRP (sp_adj1 = alpha_emit_set_long_const (sp_adj2, frame_size));\n-\t      if (!sp_adj1)\n+\t      FRP (sp_adj2 = alpha_emit_set_long_const (tmp, frame_size));\n+\t      if (!sp_adj2)\n \t\tabort ();\n #else\n \t      abort ();\n #endif\n \t    }\n-\t  sp_adj2 = stack_pointer_rtx;\n \t}\n \n       /* From now on, things must be in order.  So emit blockages.  */"}, {"sha": "0a99e07a556e74d57901e01f7cad4a23f5f0f176", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/710384268d9df98e595cd68c5e8db84d766d5513/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/710384268d9df98e595cd68c5e8db84d766d5513/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=710384268d9df98e595cd68c5e8db84d766d5513", "patch": "@@ -1180,6 +1180,10 @@ extern struct rtx_def *alpha_builtin_saveregs ();\n extern struct rtx_def *alpha_compare_op0, *alpha_compare_op1;\n extern int alpha_compare_fp_p;\n \n+/* Define the information needed to modify the epilogue for EH.  */\n+\n+extern struct rtx_def *alpha_eh_epilogue_sp_ofs;\n+\n /* Make (or fake) .linkage entry for function call.\n    IS_LOCAL is 0 if name is used in call, 1 if name is used in definition.  */\n extern void alpha_need_linkage ();"}, {"sha": "a214cc487c1bb8a6223d113f60aa4a02225eb14b", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/710384268d9df98e595cd68c5e8db84d766d5513/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/710384268d9df98e595cd68c5e8db84d766d5513/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=710384268d9df98e595cd68c5e8db84d766d5513", "patch": "@@ -5144,6 +5144,22 @@\n   \"\"\n   \"alpha_expand_epilogue (); DONE;\")\n \n+(define_expand \"eh_epilogue\"\n+  [(use (match_operand:DI 0 \"register_operand\" \"r\"))\n+   (use (match_operand:DI 1 \"register_operand\" \"r\"))\n+   (use (match_operand:DI 2 \"register_operand\" \"r\"))]\n+  \"! TARGET_OPEN_VMS\"\n+  \"\n+{\n+  alpha_eh_epilogue_sp_ofs = operands[1];\n+  if (GET_CODE (operands[2]) != REG || REGNO (operands[2]) != 26)\n+    {\n+      rtx ra = gen_rtx_REG (Pmode, 26);\n+      emit_move_insn (ra, operands[2]);\n+      operands[2] = ra;\n+    }\n+}\")\n+\n (define_expand \"builtin_longjmp\"\n   [(unspec_volatile [(match_operand 0 \"register_operand\" \"r\")] 3)]\n   \"! TARGET_OPEN_VMS && ! TARGET_WINDOWS_NT\""}, {"sha": "a4bfef9a638419d04decc464297b8d291094ff3a", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/710384268d9df98e595cd68c5e8db84d766d5513/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/710384268d9df98e595cd68c5e8db84d766d5513/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=710384268d9df98e595cd68c5e8db84d766d5513", "patch": "@@ -858,6 +858,9 @@ extern enum reg_class regno_reg_class[];\n /* Offset of first parameter from the argument pointer register value.  */\n #define FIRST_PARM_OFFSET(FNDECL) 8\n \n+/* Offset of the CFA from the argument pointer register value.  */\n+#define ARG_POINTER_CFA_OFFSET 8\n+\n /* Value is the number of byte of arguments automatically\n    popped when returning from a subroutine call.\n    FUNDECL is the declaration node of the function (as a tree),"}, {"sha": "d5812d0dbdd3abc87befc936c7df840a95aa9646", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/710384268d9df98e595cd68c5e8db84d766d5513/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/710384268d9df98e595cd68c5e8db84d766d5513/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=710384268d9df98e595cd68c5e8db84d766d5513", "patch": "@@ -1478,6 +1478,10 @@ extern char leaf_reg_remap[];\n   (TARGET_ARCH64 ? (SPARC_STACK_BIAS + 16 * UNITS_PER_WORD) \\\n    : (STRUCT_VALUE_OFFSET + UNITS_PER_WORD))\n \n+/* Offset from the argument pointer register value to the CFA.  */\n+\n+#define ARG_POINTER_CFA_OFFSET  SPARC_STACK_BIAS\n+\n /* When a parameter is passed in a register, stack space is still\n    allocated for it.\n    !v9: All 6 possible integer registers have backing store allocated."}, {"sha": "f1af3744c394f2b5fb38cb426e8ed13aeb63d72f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/710384268d9df98e595cd68c5e8db84d766d5513/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/710384268d9df98e595cd68c5e8db84d766d5513/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=710384268d9df98e595cd68c5e8db84d766d5513", "patch": "@@ -1,3 +1,7 @@\n+1998-09-16  Richard Henderson  <rth@cygnus.com>\n+\n+        * decl.c (init_decl_processing): Kill __builtin_fp and __builtin_sp.\n+\n 1998-09-15  Alexandre Oliva  <oliva@dcc.unicamp.br>\n \n \t* call.c (build_field_call): handle static data members too"}, {"sha": "ee094e5d419d0ffccff42b824f113d4ff0aeee1e", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/710384268d9df98e595cd68c5e8db84d766d5513/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/710384268d9df98e595cd68c5e8db84d766d5513/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=710384268d9df98e595cd68c5e8db84d766d5513", "patch": "@@ -5891,10 +5891,6 @@ init_decl_processing ()\n   builtin_function (\"__builtin_frame_address\", ptr_ftype_unsigned,\n \t\t    BUILT_IN_FRAME_ADDRESS, NULL_PTR);\n \n-  ptr_ftype_void = build_function_type (ptr_type_node, endlink);\n-  builtin_function (\"__builtin_fp\", ptr_ftype_void, BUILT_IN_FP, NULL_PTR);\n-  builtin_function (\"__builtin_sp\", ptr_ftype_void, BUILT_IN_SP, NULL_PTR);\n-\n   builtin_function (\"__builtin_alloca\", ptr_ftype_sizetype,\n \t\t    BUILT_IN_ALLOCA, \"alloca\");\n   builtin_function (\"__builtin_ffs\", int_ftype_int, BUILT_IN_FFS, NULL_PTR);"}, {"sha": "e5510a6dbebdcede123635af4acbe76d0626a16d", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/710384268d9df98e595cd68c5e8db84d766d5513/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/710384268d9df98e595cd68c5e8db84d766d5513/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=710384268d9df98e595cd68c5e8db84d766d5513", "patch": "@@ -103,6 +103,7 @@ struct _global_rtl global_rtl =\n   {REG},\t\t\t\t/* virtual_stack_vars_rtx */\n   {REG},\t\t\t\t/* virtual_stack_dynamic_rtx */\n   {REG},\t\t\t\t/* virtual_outgoing_args_rtx */\n+  {REG},\t\t\t\t/* virtual_cfa_rtx */\n };\n \n /* We record floating-point CONST_DOUBLEs in each floating-point mode for\n@@ -3342,6 +3343,7 @@ init_emit ()\n   regno_reg_rtx[VIRTUAL_STACK_VARS_REGNUM] = virtual_stack_vars_rtx;\n   regno_reg_rtx[VIRTUAL_STACK_DYNAMIC_REGNUM] = virtual_stack_dynamic_rtx;\n   regno_reg_rtx[VIRTUAL_OUTGOING_ARGS_REGNUM] = virtual_outgoing_args_rtx;\n+  regno_reg_rtx[VIRTUAL_CFA_REGNUM] = virtual_cfa_rtx;\n \n   /* Indicate that the virtual registers and stack locations are\n      all pointers.  */\n@@ -3354,6 +3356,7 @@ init_emit ()\n   REGNO_POINTER_FLAG (VIRTUAL_STACK_VARS_REGNUM) = 1;\n   REGNO_POINTER_FLAG (VIRTUAL_STACK_DYNAMIC_REGNUM) = 1;\n   REGNO_POINTER_FLAG (VIRTUAL_OUTGOING_ARGS_REGNUM) = 1;\n+  REGNO_POINTER_FLAG (VIRTUAL_CFA_REGNUM) = 1;\n \n #ifdef STACK_BOUNDARY\n   REGNO_POINTER_ALIGN (STACK_POINTER_REGNUM) = STACK_BOUNDARY / BITS_PER_UNIT;\n@@ -3370,6 +3373,7 @@ init_emit ()\n     = STACK_BOUNDARY / BITS_PER_UNIT;\n   REGNO_POINTER_ALIGN (VIRTUAL_OUTGOING_ARGS_REGNUM)\n     = STACK_BOUNDARY / BITS_PER_UNIT;\n+  REGNO_POINTER_ALIGN (VIRTUAL_CFA_REGNUM) = UNITS_PER_WORD;\n #endif\n \n #ifdef INIT_EXPANDERS\n@@ -3504,6 +3508,8 @@ init_emit_once (line_numbers)\n   PUT_MODE (virtual_stack_dynamic_rtx, Pmode);\n   REGNO (virtual_outgoing_args_rtx) = VIRTUAL_OUTGOING_ARGS_REGNUM;\n   PUT_MODE (virtual_outgoing_args_rtx, Pmode);\n+  REGNO (virtual_cfa_rtx) = VIRTUAL_CFA_REGNUM;\n+  PUT_MODE (virtual_cfa_rtx, Pmode);\n \n #ifdef RETURN_ADDRESS_POINTER_REGNUM\n   return_address_pointer_rtx"}, {"sha": "d1e82208d42205c78430bf1e2f3fb4c26465e922", "filename": "gcc/except.c", "status": "modified", "additions": 121, "deletions": 121, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/710384268d9df98e595cd68c5e8db84d766d5513/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/710384268d9df98e595cd68c5e8db84d766d5513/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=710384268d9df98e595cd68c5e8db84d766d5513", "patch": "@@ -431,12 +431,6 @@ rtx exception_handler_labels;\n \n rtx current_function_ehc;\n \n-/* The labels generated by expand_builtin_eh_stub and\n-   expand_builtin_eh_stub_old.  */\n-\n-rtx current_function_eh_stub_label;\n-rtx current_function_eh_old_stub_label;\n-\n /* A stack used for keeping track of the currently active exception\n    handling region.  As each exception region is started, an entry\n    describing the region is pushed onto this stack.  The current\n@@ -496,6 +490,20 @@ struct label_node *outer_context_label_stack = NULL;\n \n struct label_node *false_label_stack = NULL;\n \n+/* Pseudos used to hold exception return data in the interim between\n+   __builtin_eh_return and the end of the function.  */\n+\n+static rtx eh_return_context;\n+static rtx eh_return_stack_adjust;\n+static rtx eh_return_handler;\n+\n+/* Used to mark the eh return stub for flow, so that the Right Thing\n+   happens with the values for the hardregs therin.  */\n+\n+rtx eh_return_stub_label;\n+\n+/* Prototypes for local functions.  */\n+\n static void push_eh_entry\tPROTO((struct eh_stack *));\n static struct eh_entry * pop_eh_entry\t\tPROTO((struct eh_stack *));\n static void enqueue_eh_entry\tPROTO((struct eh_queue *, struct eh_entry *));\n@@ -507,13 +515,12 @@ static void expand_rethrow\tPROTO((rtx));\n static void output_exception_table_entry\tPROTO((FILE *, int));\n static int can_throw\t\tPROTO((rtx));\n static rtx scan_region\t\tPROTO((rtx, int, int *));\n-static void eh_regs\t\tPROTO((rtx *, rtx *, int));\n+static void eh_regs\t\tPROTO((rtx *, rtx *, rtx *, int));\n static void set_insn_eh_region\tPROTO((rtx *, int));\n #ifdef DONT_USE_BUILTIN_SETJMP\n static void jumpif_rtx\t\tPROTO((rtx, rtx));\n #endif\n \n-\n rtx expand_builtin_return_addr\tPROTO((enum built_in_function, int, rtx));\n \f\n /* Various support routines to manipulate the various data structures\n@@ -2203,8 +2210,10 @@ init_eh_for_function ()\n   caught_return_label_stack = 0;\n   protect_list = NULL_TREE;\n   current_function_ehc = NULL_RTX;\n-  current_function_eh_stub_label = NULL_RTX;\n-  current_function_eh_old_stub_label = NULL_RTX;\n+  eh_return_context = NULL_RTX;\n+  eh_return_stack_adjust = NULL_RTX;\n+  eh_return_handler = NULL_RTX;\n+  eh_return_stub_label = NULL_RTX;\n }\n \n /* Save some of the per-function EH info into the save area denoted by\n@@ -2227,8 +2236,6 @@ save_eh_status (p)\n   p->caught_return_label_stack = caught_return_label_stack;\n   p->protect_list = protect_list;\n   p->ehc = current_function_ehc;\n-  p->eh_stub_label = current_function_eh_stub_label;\n-  p->eh_old_stub_label = current_function_eh_old_stub_label;\n \n   init_eh_for_function ();\n }\n@@ -2252,8 +2259,6 @@ restore_eh_status (p)\n   ehstack = p->ehstack;\n   catchstack = p->catchstack;\n   current_function_ehc = p->ehc;\n-  current_function_eh_stub_label = p->eh_stub_label;\n-  current_function_eh_old_stub_label = p->eh_old_stub_label;\n }\n \f\n /* This section is for the exception handling specific optimization\n@@ -2465,79 +2470,72 @@ expand_builtin_frob_return_addr (addr_tree)\n   return addr;\n }\n \n-/* Given an actual address in addr_tree, set the return address register up\n-   so the epilogue will return to that address.  If the return address is\n-   not in a register, do nothing.  */\n+/* Choose three registers for communication between the main body of\n+   __throw and the epilogue (or eh stub) and the exception handler. \n+   We must do this with hard registers because the epilogue itself\n+   will be generated after reload, at which point we may not reference\n+   pseudos at all.\n \n-void\n-expand_builtin_set_return_addr_reg (addr_tree)\n-     tree addr_tree;\n-{\n-  rtx tmp;\n-  rtx ra = expand_builtin_return_addr (BUILT_IN_RETURN_ADDRESS,\n-\t\t\t\t       0, hard_frame_pointer_rtx);\n-\n-  if (GET_CODE (ra) != REG || REGNO (ra) >= FIRST_PSEUDO_REGISTER)\n-    return;\n-\n-  tmp = force_operand (expand_builtin_frob_return_addr (addr_tree), ra);\n-  if (tmp != ra)\n-    emit_move_insn (ra, tmp);\n-}\n+   The first passes the exception context to the handler.  For this\n+   we use the return value register for a void*.\n \n-/* Choose two registers for communication between the main body of\n-   __throw and the stub for adjusting the stack pointer.  The first register\n-   is used to pass the address of the exception handler; the second register\n-   is used to pass the stack pointer offset.\n+   The second holds the stack pointer value to be restored.  For\n+   this we use the static chain register if it exists and is different\n+   from the previous, otherwise some arbitrary call-clobbered register.\n \n-   For register 1 we use the return value register for a void *.\n-   For register 2 we use the static chain register if it exists and is\n-     different from register 1, otherwise some arbitrary call-clobbered\n-     register.  */\n+   The third holds the address of the handler itself.  Here we use\n+   some arbitrary call-clobbered register.  */\n \n static void\n-eh_regs (r1, r2, outgoing)\n-     rtx *r1, *r2;\n+eh_regs (pcontext, psp, pra, outgoing)\n+     rtx *pcontext, *psp, *pra;\n      int outgoing;\n {\n-  rtx reg1, reg2;\n+  rtx rcontext, rsp, rra;\n+  int i;\n \n #ifdef FUNCTION_OUTGOING_VALUE\n   if (outgoing)\n-    reg1 = FUNCTION_OUTGOING_VALUE (build_pointer_type (void_type_node),\n-\t\t\t\t    current_function_decl);\n+    rcontext = FUNCTION_OUTGOING_VALUE (build_pointer_type (void_type_node),\n+\t\t\t\t        current_function_decl);\n   else\n #endif\n-    reg1 = FUNCTION_VALUE (build_pointer_type (void_type_node),\n-\t\t\t   current_function_decl);\n+    rcontext = FUNCTION_VALUE (build_pointer_type (void_type_node),\n+\t\t\t       current_function_decl);\n \n #ifdef STATIC_CHAIN_REGNUM\n   if (outgoing)\n-    reg2 = static_chain_incoming_rtx;\n+    rsp = static_chain_incoming_rtx;\n   else\n-    reg2 = static_chain_rtx;\n-  if (REGNO (reg2) == REGNO (reg1))\n+    rsp = static_chain_rtx;\n+  if (REGNO (rsp) == REGNO (rcontext))\n #endif /* STATIC_CHAIN_REGNUM */\n-    reg2 = NULL_RTX;\n+    rsp = NULL_RTX;\n \n-  if (reg2 == NULL_RTX)\n+  if (rsp == NULL_RTX)\n     {\n-      int i;\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; ++i)\n-\tif (call_used_regs[i] && ! fixed_regs[i] && i != REGNO (reg1))\n-\t  {\n-\t    reg2 = gen_rtx_REG (Pmode, i);\n-\t    break;\n-\t  }\n+\tif (call_used_regs[i] && ! fixed_regs[i] && i != REGNO (rcontext))\n+\t  break;\n+      if (i == FIRST_PSEUDO_REGISTER)\n+\tabort();\n \n-      if (reg2 == NULL_RTX)\n-\tabort ();\n+      rsp = gen_rtx_REG (Pmode, i);\n     }\n \n-  *r1 = reg1;\n-  *r2 = reg2;\n-}\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; ++i)\n+    if (call_used_regs[i] && ! fixed_regs[i]\n+\t&& i != REGNO (rcontext) && i != REGNO (rsp))\n+      break;\n+  if (i == FIRST_PSEUDO_REGISTER)\n+    abort();\n+\n+  rra = gen_rtx_REG (Pmode, i);\n \n+  *pcontext = rcontext;\n+  *psp = rsp;\n+  *pra = rra;\n+}\n \n /* Retrieve the register which contains the pointer to the eh_context\n    structure set the __throw. */\n@@ -2551,83 +2549,85 @@ get_reg_for_handler ()\n   return reg1;\n }\n \n+/* Set up the epilogue with the magic bits we'll need to return to the\n+   exception handler.  */\n \n-/* Emit inside of __throw a stub which adjusts the stack pointer and jumps\n-   to the exception handler.  __throw will set up the necessary values\n-   and then return to the stub.  */\n-\n-rtx\n-expand_builtin_eh_stub_old ()\n+void\n+expand_builtin_eh_return (context, stack, handler)\n+    tree context, stack, handler;\n {\n-  rtx stub_start = gen_label_rtx ();\n-  rtx after_stub = gen_label_rtx ();\n-  rtx handler, offset;\n+  if (eh_return_context)\n+    error(\"Duplicate call to __builtin_eh_return\");\n \n-  current_function_eh_old_stub_label = stub_start;\n-\n-  emit_jump (after_stub);\n-  emit_label (stub_start);\n-\n-  eh_regs (&handler, &offset, 0);\n-\n-  adjust_stack (offset);\n-  emit_indirect_jump (handler);\n-  emit_label (after_stub);\n-  return gen_rtx_LABEL_REF (Pmode, stub_start);\n+  eh_return_context\n+    = copy_to_reg (expand_expr (context, NULL_RTX, VOIDmode, 0));\n+  eh_return_stack_adjust\n+    = copy_to_reg (expand_expr (stack, NULL_RTX, VOIDmode, 0));\n+  eh_return_handler\n+    = copy_to_reg (expand_expr (handler, NULL_RTX, VOIDmode, 0));\n }\n \n-rtx\n-expand_builtin_eh_stub ()\n+void\n+expand_eh_return ()\n {\n-  rtx stub_start = gen_label_rtx ();\n-  rtx after_stub = gen_label_rtx ();\n-  rtx handler, offset;\n-  rtx temp;\n-\n-  current_function_eh_stub_label = stub_start;\n-\n-  emit_jump (after_stub);\n-  emit_label (stub_start);\n+  rtx reg1, reg2, reg3;\n+  rtx stub_start, after_stub;\n+  rtx ra, tmp;\n \n-  eh_regs (&handler, &offset, 0);\n+  if (!eh_return_context)\n+    return;\n \n-  adjust_stack (offset);\n+  eh_regs (&reg1, &reg2, &reg3, 1);\n+  emit_move_insn (reg1, eh_return_context);\n+  emit_move_insn (reg2, eh_return_stack_adjust);\n+  emit_move_insn (reg3, eh_return_handler);\n \n-  /* Handler is in fact a pointer to the _eh_context structure, we need \n-     to pick out the handler field (first element), and jump to there, \n-     leaving the pointer to _eh_conext in the same hardware register. */\n+  /* Talk directly to the target's epilogue code when possible.  */\n \n-  temp = gen_rtx_MEM (Pmode, handler);\n-  MEM_IN_STRUCT_P (temp) = 1;\n-  RTX_UNCHANGING_P (temp) = 1;\n-  emit_move_insn (offset, temp);\n-  emit_insn (gen_rtx_USE (Pmode, handler));\n+#ifdef HAVE_eh_epilogue\n+  if (HAVE_eh_epilogue)\n+    {\n+      emit_insn (gen_eh_epilogue (reg1, reg2, reg3));\n+      return;\n+    }\n+#endif\n \n-  emit_indirect_jump (offset);\n-   \n-  emit_label (after_stub);\n-  return gen_rtx_LABEL_REF (Pmode, stub_start);\n-}\n+  /* Otherwise, use the same stub technique we had before.  */\n \n-/* Set up the registers for passing the handler address and stack offset\n-   to the stub above.  */\n+  eh_return_stub_label = stub_start = gen_label_rtx ();\n+  after_stub = gen_label_rtx ();\n \n-void\n-expand_builtin_set_eh_regs (handler, offset)\n-     tree handler, offset;\n-{\n-  rtx reg1, reg2;\n+  /* Set the return address to the stub label.  */\n \n-  eh_regs (&reg1, &reg2, 1);\n+  ra = expand_builtin_return_addr (BUILT_IN_RETURN_ADDRESS,\n+\t\t\t\t   0, hard_frame_pointer_rtx);\n+  if (GET_CODE (ra) == REG && REGNO (ra) >= FIRST_PSEUDO_REGISTER)\n+    abort();\n \n-  store_expr (offset,  reg2, 0);\n-  store_expr (handler, reg1, 0);\n+  tmp = memory_address (Pmode, gen_rtx_LABEL_REF (Pmode, stub_start)); \n+#ifdef RETURN_ADDR_OFFSET\n+  tmp = plus_constant (tmp, -RETURN_ADDR_OFFSET);\n+#endif\n+  emit_move_insn (ra, tmp);\n \n-  /* These will be used by the stub.  */\n+  /* Indicate that the registers are in fact used.  */\n   emit_insn (gen_rtx_USE (VOIDmode, reg1));\n   emit_insn (gen_rtx_USE (VOIDmode, reg2));\n-}\n+  emit_insn (gen_rtx_USE (VOIDmode, reg3));\n+  if (GET_CODE (ra) == REG)\n+    emit_insn (gen_rtx_USE (VOIDmode, ra));\n \n+  /* Generate the stub.  */\n+\n+  emit_jump (after_stub);\n+  emit_label (stub_start);\n+\n+  eh_regs (&reg1, &reg2, &reg3, 0);\n+  adjust_stack (reg2);\n+  emit_indirect_jump (reg3);\n+\n+  emit_label (after_stub);\n+}\n \f\n \n /* This contains the code required to verify whether arbitrary instructions"}, {"sha": "540044bde02812e2c21f169db05b4c751b693f5f", "filename": "gcc/except.h", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/710384268d9df98e595cd68c5e8db84d766d5513/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/710384268d9df98e595cd68c5e8db84d766d5513/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=710384268d9df98e595cd68c5e8db84d766d5513", "patch": "@@ -24,11 +24,9 @@ typedef struct rtx_def *_except_rtx;\n #define rtx _except_rtx\n #endif\n \n-/* The labels generated by expand_builtin_eh_stub and\n-   expand_builtin_eh_stub_old.  */\n+/* The label generated by expand_builtin_eh_return.  */\n \n-extern rtx current_function_eh_stub_label;\n-extern rtx current_function_eh_old_stub_label;\n+extern rtx eh_return_stub_label;\n \n #ifdef TREE_CODE\n \n@@ -377,15 +375,13 @@ extern void expand_fixup_region_end\tPROTO((tree));\n \n void expand_builtin_unwind_init\t\tPROTO((void));\n rtx expand_builtin_dwarf_fp_regnum\tPROTO((void));\n-rtx expand_builtin_eh_stub\t\tPROTO((void));\n-rtx expand_builtin_eh_stub_old          PROTO((void));\n #ifdef TREE_CODE\n rtx expand_builtin_frob_return_addr\tPROTO((tree));\n rtx expand_builtin_extract_return_addr\tPROTO((tree));\n-void expand_builtin_set_return_addr_reg PROTO((tree));\n-void expand_builtin_set_eh_regs\t\tPROTO((tree, tree));\n rtx expand_builtin_dwarf_reg_size\tPROTO((tree, rtx));\n+void expand_builtin_eh_return\t\tPROTO((tree, tree, tree));\n #endif\n+void expand_eh_return\t\t\tPROTO((void));\n \n \n /* Checking whether 2 instructions are within the same exception region. */"}, {"sha": "028f9b21cfda28e73651d81caa8a95e58c745607", "filename": "gcc/expr.c", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/710384268d9df98e595cd68c5e8db84d766d5513/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/710384268d9df98e595cd68c5e8db84d766d5513/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=710384268d9df98e595cd68c5e8db84d766d5513", "patch": "@@ -9370,10 +9370,8 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n     case BUILT_IN_UNWIND_INIT:\n       expand_builtin_unwind_init ();\n       return const0_rtx;\n-    case BUILT_IN_FP:\n-      return frame_pointer_rtx;\n-    case BUILT_IN_SP:\n-      return stack_pointer_rtx;\n+    case BUILT_IN_DWARF_CFA:\n+      return virtual_cfa_rtx;\n #ifdef DWARF2_UNWIND_INFO\n     case BUILT_IN_DWARF_FP_REGNUM:\n       return expand_builtin_dwarf_fp_regnum ();\n@@ -9384,16 +9382,10 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n       return expand_builtin_frob_return_addr (TREE_VALUE (arglist));\n     case BUILT_IN_EXTRACT_RETURN_ADDR:\n       return expand_builtin_extract_return_addr (TREE_VALUE (arglist));\n-    case BUILT_IN_SET_RETURN_ADDR_REG:\n-      expand_builtin_set_return_addr_reg (TREE_VALUE (arglist));\n-      return const0_rtx;\n-    case BUILT_IN_EH_STUB_OLD:\n-      return expand_builtin_eh_stub_old ();\n-    case BUILT_IN_EH_STUB:\n-      return expand_builtin_eh_stub ();\n-    case BUILT_IN_SET_EH_REGS:\n-      expand_builtin_set_eh_regs (TREE_VALUE (arglist),\n-\t\t\t\t  TREE_VALUE (TREE_CHAIN (arglist)));\n+    case BUILT_IN_EH_RETURN:\n+      expand_builtin_eh_return (TREE_VALUE (arglist),\n+\t\t\t\tTREE_VALUE (TREE_CHAIN (arglist)),\n+\t\t\t\tTREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist))));\n       return const0_rtx;\n \n     default:\t\t\t/* just do library call, if unknown builtin */"}, {"sha": "fb309be735a9b580865b652f8071585fe561f3aa", "filename": "gcc/flow.c", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/710384268d9df98e595cd68c5e8db84d766d5513/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/710384268d9df98e595cd68c5e8db84d766d5513/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=710384268d9df98e595cd68c5e8db84d766d5513", "patch": "@@ -485,8 +485,7 @@ find_basic_blocks_1 (f, nonlocal_label_list, live_reachable_p)\n \t  /* Make a list of all labels referred to other than by jumps.  */\n \t  for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n \t    if (REG_NOTE_KIND (note) == REG_LABEL\n-\t\t&& XEXP (note, 0) != current_function_eh_stub_label\n-\t\t&& XEXP (note, 0) != current_function_eh_old_stub_label)\n+\t\t&& XEXP (note, 0) != eh_return_stub_label)\n \t      label_value_list = gen_rtx_EXPR_LIST (VOIDmode, XEXP (note, 0),\n \t\t\t\t\t\t    label_value_list);\n \t}\n@@ -619,8 +618,7 @@ find_basic_blocks_1 (f, nonlocal_label_list, live_reachable_p)\n \t\t\t     note = XEXP (note, 1))\n \t\t\t  {\n \t\t\t    if (REG_NOTE_KIND (note) == REG_LABEL\n-\t\t\t\t&& XEXP (note, 0) != current_function_eh_stub_label\n-\t\t\t\t&& XEXP (note, 0) != current_function_eh_old_stub_label)\n+\t\t\t\t&& XEXP (note, 0) != eh_return_stub_label)\n \t\t\t      {\n \t\t\t\tx = XEXP (note, 0);\n \t\t\t\tblock_live[BLOCK_NUM (x)] = 1;\n@@ -708,13 +706,10 @@ find_basic_blocks_1 (f, nonlocal_label_list, live_reachable_p)\n \t\t   within it.  So we have to make additional edges in the\n \t\t   flow graph.  */\n \t\tif (i + 1 == n_basic_blocks\n-\t\t    && current_function_eh_stub_label != 0)\n+\t\t    && eh_return_stub_label != 0)\n \t\t  {\n \t\t    mark_label_ref (gen_rtx_LABEL_REF (VOIDmode,\n-\t\t\t\t\t\t       current_function_eh_stub_label),\n-\t\t\t\t    basic_block_end[i], 0);\n-\t\t    mark_label_ref (gen_rtx_LABEL_REF (VOIDmode,\n-\t\t\t\t\t\t       current_function_eh_old_stub_label),\n+\t\t\t\t\t\t       eh_return_stub_label),\n \t\t\t\t    basic_block_end[i], 0);\n \t\t  }\n \t      }"}, {"sha": "a5f8f0591c1ec84638e14273e90237caab12e525", "filename": "gcc/function.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/710384268d9df98e595cd68c5e8db84d766d5513/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/710384268d9df98e595cd68c5e8db84d766d5513/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=710384268d9df98e595cd68c5e8db84d766d5513", "patch": "@@ -2688,6 +2688,7 @@ static int in_arg_offset;\n static int var_offset;\n static int dynamic_offset;\n static int out_arg_offset;\n+static int cfa_offset;\n \n /* In most machines, the stack pointer register is equivalent to the bottom\n    of the stack.  */\n@@ -2726,6 +2727,13 @@ static int out_arg_offset;\n #endif\n #endif\n \n+/* On a few machines, the CFA coincides with the arg pointer.  */\n+\n+#ifndef ARG_POINTER_CFA_OFFSET\n+#define ARG_POINTER_CFA_OFFSET 0\n+#endif\n+\n+\n /* Build up a (MEM (ADDRESSOF (REG))) rtx for a register REG that just had\n    its address taken.  DECL is the decl for the object stored in the\n    register, for later use if we do need to force REG into the stack.\n@@ -2910,6 +2918,7 @@ instantiate_virtual_regs (fndecl, insns)\n   var_offset = STARTING_FRAME_OFFSET;\n   dynamic_offset = STACK_DYNAMIC_OFFSET (fndecl);\n   out_arg_offset = STACK_POINTER_OFFSET;\n+  cfa_offset = ARG_POINTER_CFA_OFFSET;\n \n   /* Scan all variables and parameters of this function.  For each that is\n      in memory, instantiate all virtual registers if the result is a valid\n@@ -3143,6 +3152,8 @@ instantiate_virtual_regs_1 (loc, object, extra_insns)\n \tnew = stack_pointer_rtx, offset = - dynamic_offset;\n       else if (SET_DEST (x) == virtual_outgoing_args_rtx)\n \tnew = stack_pointer_rtx, offset = - out_arg_offset;\n+      else if (SET_DEST (x) == virtual_cfa_rtx)\n+\tnew = arg_pointer_rtx, offset = - cfa_offset;\n \n       if (new)\n \t{\n@@ -3194,6 +3205,8 @@ instantiate_virtual_regs_1 (loc, object, extra_insns)\n \t\tnew = stack_pointer_rtx, offset = dynamic_offset;\n \t      else if (inner == virtual_outgoing_args_rtx)\n \t\tnew = stack_pointer_rtx, offset = out_arg_offset;\n+\t      else if (inner == virtual_cfa_rtx)\n+\t        new = arg_pointer_rtx, offset = cfa_offset;\n \t      else\n \t\t{\n \t\t  loc = &XEXP (x, 0);\n@@ -3213,6 +3226,8 @@ instantiate_virtual_regs_1 (loc, object, extra_insns)\n \t    new = stack_pointer_rtx, offset = dynamic_offset;\n \t  else if (XEXP (x, 0) == virtual_outgoing_args_rtx)\n \t    new = stack_pointer_rtx, offset = out_arg_offset;\n+          else if (XEXP (x, 0) == virtual_cfa_rtx)\n+            new = arg_pointer_rtx, offset = cfa_offset;\n \t  else\n \t    {\n \t      /* We know the second operand is a constant.  Unless the\n@@ -3420,6 +3435,8 @@ instantiate_virtual_regs_1 (loc, object, extra_insns)\n \tnew = stack_pointer_rtx, offset = dynamic_offset;\n       else if (x == virtual_outgoing_args_rtx)\n \tnew = stack_pointer_rtx, offset = out_arg_offset;\n+      else if (x == virtual_cfa_rtx)\n+        new = arg_pointer_rtx, offset = cfa_offset;\n \n       if (new)\n \t{\n@@ -5981,6 +5998,10 @@ expand_function_end (filename, line, end_bindings)\n       use_variable (outgoing);\n     }\n \n+  /* If this is an implementation of __throw, do what's necessary to \n+     communicate between __builtin_eh_return and the epilogue.  */\n+  expand_eh_return ();\n+\n   /* Output a return insn if we are using one.\n      Otherwise, let the rtl chain end here, to drop through\n      into the epilogue.  */"}, {"sha": "06e90dc88aa34b759d7a097090b52922059e1c6f", "filename": "gcc/function.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/710384268d9df98e595cd68c5e8db84d766d5513/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/710384268d9df98e595cd68c5e8db84d766d5513/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=710384268d9df98e595cd68c5e8db84d766d5513", "patch": "@@ -142,8 +142,6 @@ struct function\n   rtx catch_clauses;\n   struct label_node *false_label_stack;\n   struct label_node *caught_return_label_stack;\n-  rtx eh_stub_label;\n-  rtx eh_old_stub_label;\n   tree protect_list;\n   rtx ehc;\n "}, {"sha": "821387b396040301f77a4500dca6f3a31ba52c97", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 66, "deletions": 82, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/710384268d9df98e595cd68c5e8db84d766d5513/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/710384268d9df98e595cd68c5e8db84d766d5513/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=710384268d9df98e595cd68c5e8db84d766d5513", "patch": "@@ -3492,31 +3492,71 @@ find_exception_handler (void *pc, exception_descriptor *table, void *eh_info)\n \n typedef int ptr_type __attribute__ ((mode (pointer)));\n \n-/* Get the value of register REG as saved in UDATA, where SUB_UDATA is a\n+#ifdef INCOMING_REGNO\n+/* Is the saved value for register REG in frame UDATA stored in a register\n+   window in the previous frame?  */\n+\n+/* ??? The Sparc INCOMING_REGNO references TARGET_FLAT.  This allows us\n+   to use the macro here.  One wonders, though, that perhaps TARGET_FLAT\n+   compiled functions won't work with the frame-unwind stuff here.  \n+   Perhaps the entireity of in_reg_window should be conditional on having\n+   seen a DW_CFA_GNU_window_save?  */\n+#define target_flags 0\n+\n+static int\n+in_reg_window (int reg, frame_state *udata)\n+{\n+  if (udata->saved[reg] == REG_SAVED_REG)\n+    return INCOMING_REGNO (reg) == reg;\n+  if (udata->saved[reg] != REG_SAVED_OFFSET)\n+    return 0;\n+\n+#ifdef STACK_GROWS_DOWNWARD\n+  return udata->reg_or_offset[reg] > 0;\n+#else\n+  return udata->reg_or_offset[reg] < 0;\n+#endif\n+}\n+#else\n+static inline int in_reg_window (int reg, frame_state *udata) { return 0; }\n+#endif /* INCOMING_REGNO */\n+\n+/* Get the address of register REG as saved in UDATA, where SUB_UDATA is a\n    frame called by UDATA or 0.  */\n \n-static void*\n-get_reg (unsigned reg, frame_state *udata, frame_state *sub_udata)\n+static word_type *\n+get_reg_addr (unsigned reg, frame_state *udata, frame_state *sub_udata)\n {\n+  while (udata->saved[reg] == REG_SAVED_REG)\n+    {\n+      reg = udata->reg_or_offset[reg];\n+      if (in_reg_window (reg, udata))\n+\t{\n+          udata = sub_udata;\n+\t  sub_udata = NULL;\n+\t}\n+    }\n   if (udata->saved[reg] == REG_SAVED_OFFSET)\n-    return (void *)(ptr_type)\n-      *(word_type *)(udata->cfa + udata->reg_or_offset[reg]);\n-  else if (udata->saved[reg] == REG_SAVED_REG && sub_udata)\n-    return get_reg (udata->reg_or_offset[reg], sub_udata, 0);\n+    return (word_type *)(udata->cfa + udata->reg_or_offset[reg]);\n   else\n     abort ();\n }\n \n+/* Get the value of register REG as saved in UDATA, where SUB_UDATA is a\n+   frame called by UDATA or 0.  */\n+\n+static inline void *\n+get_reg (unsigned reg, frame_state *udata, frame_state *sub_udata)\n+{\n+  return (void *)(ptr_type) *get_reg_addr (reg, udata, sub_udata);\n+}\n+\n /* Overwrite the saved value for register REG in frame UDATA with VAL.  */\n \n-static void\n+static inline void\n put_reg (unsigned reg, void *val, frame_state *udata)\n {\n-  if (udata->saved[reg] == REG_SAVED_OFFSET)\n-    *(word_type *)(udata->cfa + udata->reg_or_offset[reg])\n-      = (word_type)(ptr_type) val;\n-  else\n-    abort ();\n+  *get_reg_addr (reg, udata, NULL) = (word_type)(ptr_type) val;\n }\n \n /* Copy the saved value for register REG from frame UDATA to frame\n@@ -3526,17 +3566,13 @@ put_reg (unsigned reg, void *val, frame_state *udata)\n static void\n copy_reg (unsigned reg, frame_state *udata, frame_state *target_udata)\n {\n-  if (udata->saved[reg] == REG_SAVED_OFFSET\n-      && target_udata->saved[reg] == REG_SAVED_OFFSET)\n-    memcpy (target_udata->cfa + target_udata->reg_or_offset[reg],\n-\t    udata->cfa + udata->reg_or_offset[reg],\n-\t    __builtin_dwarf_reg_size (reg));\n-  else\n-    abort ();\n+  word_type *preg = get_reg_addr (reg, udata, NULL);\n+  word_type *ptreg = get_reg_addr (reg, target_udata, NULL);\n+\n+  memcpy (ptreg, preg, __builtin_dwarf_reg_size (reg));\n }\n \n-/* Retrieve the return address for frame UDATA, where SUB_UDATA is a\n-   frame called by UDATA or 0.  */\n+/* Retrieve the return address for frame UDATA.  */\n \n static inline void *\n get_return_addr (frame_state *udata, frame_state *sub_udata)\n@@ -3576,24 +3612,6 @@ next_stack_level (void *pc, frame_state *udata, frame_state *caller_udata)\n   return caller_udata;\n }\n \n-#ifdef INCOMING_REGNO\n-/* Is the saved value for register REG in frame UDATA stored in a register\n-   window in the previous frame?  */\n-\n-static int\n-in_reg_window (int reg, frame_state *udata)\n-{\n-  if (udata->saved[reg] != REG_SAVED_OFFSET)\n-    return 0;\n-\n-#ifdef STACK_GROWS_DOWNWARD\n-  return udata->reg_or_offset[reg] > 0;\n-#else\n-  return udata->reg_or_offset[reg] < 0;\n-#endif\n-}\n-#endif /* INCOMING_REGNO */\n-\n /* We first search for an exception handler, and if we don't find\n    it, we call __terminate on the current stack frame so that we may\n    use the debugger to walk the stack and understand why no handler\n@@ -3606,7 +3624,7 @@ void\n __throw ()\n {\n   struct eh_context *eh = (*get_eh_context) ();\n-  void *saved_pc, *pc, *handler, *retaddr;\n+  void *saved_pc, *pc, *handler;\n   frame_state ustruct, ustruct2;\n   frame_state *udata = &ustruct;\n   frame_state *sub_udata = &ustruct2;\n@@ -3626,14 +3644,8 @@ __throw ()\n   if (! udata)\n     __terminate ();\n \n-  /* We need to get the value from the CFA register.  At this point in\n-     compiling __throw we don't know whether or not we will use the frame\n-     pointer register for the CFA, so we check our unwind info.  */\n-  if (udata->cfa_reg == __builtin_dwarf_fp_regnum ())\n-    udata->cfa = __builtin_fp ();\n-  else\n-    udata->cfa = __builtin_sp ();\n-  udata->cfa += udata->cfa_offset;\n+  /* We need to get the value from the CFA register. */\n+  udata->cfa = __builtin_dwarf_cfa ();\n \n   memcpy (my_udata, udata, sizeof (*udata));\n \n@@ -3712,7 +3724,6 @@ __throw ()\n \t  for (i = 0; i < FIRST_PSEUDO_REGISTER; ++i)\n \t    if (i != udata->retaddr_column && udata->saved[i])\n \t      {\n-#ifdef INCOMING_REGNO\n \t\t/* If you modify the saved value of the return address\n \t\t   register on the SPARC, you modify the return address for\n \t\t   your caller's frame.  Don't do that here, as it will\n@@ -3721,14 +3732,12 @@ __throw ()\n \t\t    && udata->saved[udata->retaddr_column] == REG_SAVED_REG\n \t\t    && udata->reg_or_offset[udata->retaddr_column] == i)\n \t\t  continue;\n-#endif\n \t\tcopy_reg (i, udata, my_udata);\n \t      }\n \n \t  pc = get_return_addr (udata, sub_udata) - 1;\n \t}\n \n-#ifdef INCOMING_REGNO\n       /* But we do need to update the saved return address register from\n \t the last frame we unwind, or the handler frame will have the wrong\n \t return address.  */\n@@ -3738,42 +3747,17 @@ __throw ()\n \t  if (in_reg_window (i, udata))\n \t    copy_reg (i, udata, my_udata);\n \t}\n-#endif\n     }\n-  /* udata now refers to the frame called by the handler frame.  */\n \n-  /* Emit the stub to adjust sp and jump to the handler.  */\n-  if (new_exception_model)\n-    retaddr = __builtin_eh_stub ();\n-  else\n-    retaddr =  __builtin_eh_stub_old ();\n-\n-  /* And then set our return address to point to the stub.  */\n-  if (my_udata->saved[my_udata->retaddr_column] == REG_SAVED_OFFSET)\n-    put_return_addr (retaddr, my_udata);\n-  else\n-    __builtin_set_return_addr_reg (retaddr);\n-\n-  /* Set up the registers we use to communicate with the stub.\n-     We check STACK_GROWS_DOWNWARD so the stub can use adjust_stack.  */\n-\n-  if (new_exception_model)\n-    __builtin_set_eh_regs ((void *)eh,\n-#ifdef STACK_GROWS_DOWNWARD\n-\t\t\t udata->cfa - my_udata->cfa\n-#else\n-\t\t\t my_udata->cfa - udata->cfa\n-#endif\n-\t\t\t + args_size);\n-  else\n-    __builtin_set_eh_regs (handler,\n+  /* Now go!  */\n \n+  __builtin_eh_return ((void *)eh,\n #ifdef STACK_GROWS_DOWNWARD\n-\t\t\t udata->cfa - my_udata->cfa\n+\t\t       udata->cfa - my_udata->cfa,\n #else\n-\t\t\t my_udata->cfa - udata->cfa\n+\t\t       my_udata->cfa - udata->cfa,\n #endif\n-\t\t\t + args_size);\n+\t\t       handler);\n \n   /* Epilogue:  restore the handler frame's register values and return\n      to the stub.  */"}, {"sha": "e72fd60259677670cd7b25d6a467418e40843f40", "filename": "gcc/rtl.h", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/710384268d9df98e595cd68c5e8db84d766d5513/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/710384268d9df98e595cd68c5e8db84d766d5513/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=710384268d9df98e595cd68c5e8db84d766d5513", "patch": "@@ -1055,6 +1055,7 @@ extern struct _global_rtl\n   struct rtx_def virtual_stack_vars_val;\n   struct rtx_def virtual_stack_dynamic_val;\n   struct rtx_def virtual_outgoing_args_val;\n+  struct rtx_def virtual_cfa_val;\n } global_rtl;\n \n /* All references to certain hard regs, except those created\n@@ -1159,7 +1160,17 @@ extern rtx gen_rtx_MEM PROTO((enum machine_mode, rtx));\n \n #define VIRTUAL_OUTGOING_ARGS_REGNUM\t((FIRST_VIRTUAL_REGISTER) + 3)\n \n-#define LAST_VIRTUAL_REGISTER\t((FIRST_VIRTUAL_REGISTER) + 3)\n+/* This points to the Canonical Frame Address of the function.  This\n+   should corrospond to the CFA produced by INCOMING_FRAME_SP_OFFSET,\n+   but is calculated relative to the arg pointer for simplicity; the\n+   frame pointer nor stack pointer are necessarily fixed relative to \n+   the CFA until after reload.  */\n+\n+#define virtual_cfa_rtx\t\t\t(&global_rtl.virtual_cfa_val)\n+\n+#define VIRTUAL_CFA_REGNUM\t\t((FIRST_VIRTUAL_REGISTER) + 4)\n+\n+#define LAST_VIRTUAL_REGISTER\t\t((FIRST_VIRTUAL_REGISTER) + 4)\n \n extern rtx find_next_ref\t\tPROTO((rtx, rtx));\n extern rtx *find_single_use\t\tPROTO((rtx, rtx, rtx *));"}, {"sha": "ea3e8b3110a97e89e5669a4082be7599a3e85a2e", "filename": "gcc/tm.texi", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/710384268d9df98e595cd68c5e8db84d766d5513/gcc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/710384268d9df98e595cd68c5e8db84d766d5513/gcc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftm.texi?ref=710384268d9df98e595cd68c5e8db84d766d5513", "patch": "@@ -2275,6 +2275,17 @@ frame at the beginning of any function, before the prologue.  The top of\n the frame is defined to be the value of the stack pointer in the\n previous frame, just before the call instruction.\n \n+You only need to define this macro if you want to support call frame\n+debugging information like that provided by DWARF 2.\n+\n+@findex ARG_POINTER_CFA_OFFSET\n+@item ARG_POINTER_CFA_OFFSET\n+A C expression whose value is an integer giving the offset, in bytes,\n+from the argument pointer to the canonical frame address (cfa).  The\n+final value should coincide with that calculated by \n+@code{INCOMING_FRAME_SP_OFFSET}.  Which is unfortunately not usable\n+during virtual register instantiation.\n+\n You only need to define this macro if you want to support call frame\n debugging information like that provided by DWARF 2.\n @end table"}, {"sha": "58293e49d5e71c5da5e8541c4c013ca36457404c", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/710384268d9df98e595cd68c5e8db84d766d5513/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/710384268d9df98e595cd68c5e8db84d766d5513/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=710384268d9df98e595cd68c5e8db84d766d5513", "patch": "@@ -101,7 +101,6 @@ enum built_in_function\n   BUILT_IN_FRAME_ADDRESS,\n   BUILT_IN_RETURN_ADDRESS,\n   BUILT_IN_AGGREGATE_INCOMING_ADDRESS,\n-  BUILT_IN_CALLER_RETURN_ADDRESS,\n   BUILT_IN_APPLY_ARGS,\n   BUILT_IN_APPLY,\n   BUILT_IN_RETURN,\n@@ -110,16 +109,13 @@ enum built_in_function\n   BUILT_IN_TRAP,\n \n   /* Various hooks for the DWARF 2 __throw routine.  */\n-  BUILT_IN_FP, BUILT_IN_SP,\n   BUILT_IN_UNWIND_INIT,\n+  BUILT_IN_DWARF_CFA,\n   BUILT_IN_DWARF_FP_REGNUM,\n   BUILT_IN_DWARF_REG_SIZE,\n   BUILT_IN_FROB_RETURN_ADDR,\n   BUILT_IN_EXTRACT_RETURN_ADDR,\n-  BUILT_IN_SET_RETURN_ADDR_REG,\n-  BUILT_IN_EH_STUB_OLD,\n-  BUILT_IN_EH_STUB,\n-  BUILT_IN_SET_EH_REGS,\n+  BUILT_IN_EH_RETURN,\n \n   /* C++ extensions */\n   BUILT_IN_NEW,"}]}