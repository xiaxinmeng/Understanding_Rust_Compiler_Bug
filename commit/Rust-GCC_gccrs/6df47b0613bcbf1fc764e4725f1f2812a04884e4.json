{"sha": "6df47b0613bcbf1fc764e4725f1f2812a04884e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmRmNDdiMDYxM2JjYmYxZmM3NjRlNDcyNWYxZjI4MTJhMDQ4ODRlNA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-10-11T17:38:53Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-10-11T17:38:53Z"}, "message": "cp-tree.h (specializations_of_same_template_p): Declare.\n\n\t* cp-tree.h (specializations_of_same_template_p): Declare.\n\t* pt.c (specializations_of_same_template_p): New function.\n\t(unify): Use it.\n\t* search.c (get_template_base): Use it.\n\t(get_template_base_recursive): Likewise.\n\nFrom-SVN: r22987", "tree": {"sha": "5b6459c4e5a4e5e20273edeac8b690ed48db7fb2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b6459c4e5a4e5e20273edeac8b690ed48db7fb2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6df47b0613bcbf1fc764e4725f1f2812a04884e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6df47b0613bcbf1fc764e4725f1f2812a04884e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6df47b0613bcbf1fc764e4725f1f2812a04884e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6df47b0613bcbf1fc764e4725f1f2812a04884e4/comments", "author": null, "committer": null, "parents": [{"sha": "4a7bd8e25b9441695adb7923a93fa42a18881a59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a7bd8e25b9441695adb7923a93fa42a18881a59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a7bd8e25b9441695adb7923a93fa42a18881a59"}], "stats": {"total": 59, "additions": 53, "deletions": 6}, "files": [{"sha": "e09fca870ab604db70a1bf7b979e964d9a682d0f", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6df47b0613bcbf1fc764e4725f1f2812a04884e4/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6df47b0613bcbf1fc764e4725f1f2812a04884e4/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=6df47b0613bcbf1fc764e4725f1f2812a04884e4", "patch": "@@ -2869,6 +2869,7 @@ extern int is_specialization_of                 PROTO((tree, tree));\n extern int comp_template_args                   PROTO((tree, tree));\n extern void maybe_process_partial_specialization PROTO((tree));\n extern void maybe_check_template_type           PROTO((tree));\n+extern int specializations_of_same_template_p   PROTO((tree, tree));\n \n extern int processing_specialization;\n extern int processing_explicit_instantiation;"}, {"sha": "6a6aac6fa917b28a0a29788629b500887a9bd2c7", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6df47b0613bcbf1fc764e4725f1f2812a04884e4/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6df47b0613bcbf1fc764e4725f1f2812a04884e4/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=6df47b0613bcbf1fc764e4725f1f2812a04884e4", "patch": "@@ -756,6 +756,22 @@ is_specialization_of (decl, tmpl)\n   return 0;\n }\n \n+/* Returns nonzero if T1 and T2 are instances of the same template.\n+   (They may have different template arguments.)  */\n+\n+int\n+specializations_of_same_template_p (t1, t2)\n+     tree t1;\n+     tree t2;\n+{\n+  /* For now, we only deal with instances of class templates, since\n+     that is the only way in which this function is used.  */\n+\n+  return (most_general_template (CLASSTYPE_TI_TEMPLATE (t1))\n+\t  == most_general_template (CLASSTYPE_TI_TEMPLATE (t2)));\n+}\n+\n+\n /* Register the specialization SPEC as a specialization of TMPL with\n    the indicated ARGS.  Returns SPEC, or an equivalent prior\n    declaration, if available.  */\n@@ -7340,12 +7356,18 @@ unify (tparms, targs, parm, arg, strict, explicit_mask)\n \t       can be a derived class of the deduced A.  Likewise, if\n \t       P is a pointer to a class of the form template-id, A\n \t       can be a pointer to a derived class pointed to by the\n-\t       deduced A.  */\n+\t       deduced A. \n+\n+\t       The call to get_template_base also handles the case\n+\t       where PARM and ARG are the same type, i.e., where no\n+\t       derivation is involved.  */\n \t    t = get_template_base (CLASSTYPE_TI_TEMPLATE (parm), arg);\n-\t  else if\n-\t    (CLASSTYPE_TEMPLATE_INFO (arg)\n-\t     && CLASSTYPE_TI_TEMPLATE (parm) == CLASSTYPE_TI_TEMPLATE (arg))\n+\t  else if (CLASSTYPE_TEMPLATE_INFO (arg) \n+\t\t   && specializations_of_same_template_p (parm, arg))\n+\t    /* Perhaps PARM is something like S<U> and ARG is S<int>.\n+\t       Then, we should unify `int' and `U'.  */\n \t    t = arg;\n+\n \t  if (! t || t == error_mark_node)\n \t    return 1;\n "}, {"sha": "5905674c4af495d1aa5777c30f64623c375308e6", "filename": "gcc/cp/search.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6df47b0613bcbf1fc764e4725f1f2812a04884e4/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6df47b0613bcbf1fc764e4725f1f2812a04884e4/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=6df47b0613bcbf1fc764e4725f1f2812a04884e4", "patch": "@@ -3317,7 +3317,8 @@ get_template_base_recursive (binfo, rval, template, via_virtual)\n   tree type = BINFO_TYPE (binfo);\n \n   if (CLASSTYPE_TEMPLATE_INFO (type)\n-      && CLASSTYPE_TI_TEMPLATE (type) == template)\n+      && specializations_of_same_template_p (TREE_TYPE (template), \n+\t\t\t\t\t     type))\n     {\n       if (rval == NULL_TREE || rval == type)\n \treturn type;\n@@ -3375,7 +3376,8 @@ get_template_base (template, binfo)\n     my_friendly_abort (92);\n \n   if (CLASSTYPE_TEMPLATE_INFO (type)\n-      && CLASSTYPE_TI_TEMPLATE (type) == template)\n+      && specializations_of_same_template_p (TREE_TYPE (template), \n+\t\t\t\t\t     type))\n     return type;\n \n   rval = get_template_base_recursive (binfo, NULL_TREE, template, 0);"}, {"sha": "96024e2185928d3df1757ffb0d8fba367d38fb3a", "filename": "gcc/testsuite/g++.old-deja/g++.pt/memclass17.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6df47b0613bcbf1fc764e4725f1f2812a04884e4/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemclass17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6df47b0613bcbf1fc764e4725f1f2812a04884e4/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemclass17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemclass17.C?ref=6df47b0613bcbf1fc764e4725f1f2812a04884e4", "patch": "@@ -0,0 +1,22 @@\n+// Build don't link:\n+\n+template <class T> struct S \n+{\n+  template <class U> struct I \n+  {\n+  };\n+\n+  S();\n+  S(S& s);\n+  S(I<T>);\n+\n+  template <class U> operator I<U>();\n+};\n+\n+S<int> f();\n+void g(S<int>);\n+\n+void h()\n+{\n+  g(f());\n+}"}]}