{"sha": "079c527f5e7593f8563e3415ad04cf1f0e5d9269", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDc5YzUyN2Y1ZTc1OTNmODU2M2UzNDE1YWQwNGNmMWYwZTVkOTI2OQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2012-06-15T11:07:47Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2012-06-15T11:07:47Z"}, "message": "re PR tree-optimization/51581 (Integer division by constant is not vectorized)\n\n\tPR tree-optimization/51581\n\t* expr.h (choose_multiplier): New prototype.\n\t* expmed.c (choose_multiplier): No longer static.\n\tChange multiplier_ptr from rtx * to UHWI *.\n\t(expand_divmod): Adjust callers.\n\t* tree-vect-patterns.c (vect_recog_sdivmod_pow2_pattern):\n\tRenamed to...\n\t(vect_recog_divmod_pattern): ... this.  Pass bb_vinfo as last\n\targument to new_stmt_vec_info.  Attempt to optimize also divisions\n\tby non-pow2 constants if integer vector division isn't supported.\n\t* tree-vect-stmts.c (vect_analyze_stmt): If node != NULL,\n\tdon't look at pattern stmts and sequences.\n\n\t* gcc.c-torture/execute/pr51581-1.c: New test.\n\t* gcc.c-torture/execute/pr51581-2.c: New test.\n\t* gcc.dg/vect/pr51581-1.c: New test.\n\t* gcc.dg/vect/pr51581-2.c: New test.\n\t* gcc.dg/vect/pr51581-3.c: New test.\n\t* gcc.target/i386/avx-pr51581-1.c: New test.\n\t* gcc.target/i386/avx-pr51581-2.c: New test.\n\t* gcc.target/i386/avx2-pr51581-1.c: New test.\n\t* gcc.target/i386/avx2-pr51581-2.c: New test.\n\t* gcc.dg/vect/slp-26.c (main1): Divide by 0x8031 instead of 3.\n\nFrom-SVN: r188656", "tree": {"sha": "5c72c952d5e64996ab124de5c892988b2985f3d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c72c952d5e64996ab124de5c892988b2985f3d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/079c527f5e7593f8563e3415ad04cf1f0e5d9269", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/079c527f5e7593f8563e3415ad04cf1f0e5d9269", "html_url": "https://github.com/Rust-GCC/gccrs/commit/079c527f5e7593f8563e3415ad04cf1f0e5d9269", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/079c527f5e7593f8563e3415ad04cf1f0e5d9269/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c55224dc4d22bbb0536f2386371f362fe066527e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c55224dc4d22bbb0536f2386371f362fe066527e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c55224dc4d22bbb0536f2386371f362fe066527e"}], "stats": {"total": 1139, "additions": 1031, "deletions": 108}, "files": [{"sha": "00cffd6b4b7900e79869f797207a3ff4b638d395", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/079c527f5e7593f8563e3415ad04cf1f0e5d9269/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/079c527f5e7593f8563e3415ad04cf1f0e5d9269/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=079c527f5e7593f8563e3415ad04cf1f0e5d9269", "patch": "@@ -1,3 +1,18 @@\n+2012-06-15  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/51581\n+\t* expr.h (choose_multiplier): New prototype.\n+\t* expmed.c (choose_multiplier): No longer static.\n+\tChange multiplier_ptr from rtx * to UHWI *.\n+\t(expand_divmod): Adjust callers.\n+\t* tree-vect-patterns.c (vect_recog_sdivmod_pow2_pattern):\n+\tRenamed to...\n+\t(vect_recog_divmod_pattern): ... this.  Pass bb_vinfo as last\n+\targument to new_stmt_vec_info.  Attempt to optimize also divisions\n+\tby non-pow2 constants if integer vector division isn't supported.\n+\t* tree-vect-stmts.c (vect_analyze_stmt): If node != NULL,\n+\tdon't look at pattern stmts and sequences.\n+\n 2012-06-15  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR middle-end/53590"}, {"sha": "b456bac177c71fbd3f2b8fa534bf6e7f563c5cdc", "filename": "gcc/expmed.c", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/079c527f5e7593f8563e3415ad04cf1f0e5d9269/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/079c527f5e7593f8563e3415ad04cf1f0e5d9269/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=079c527f5e7593f8563e3415ad04cf1f0e5d9269", "patch": "@@ -2363,8 +2363,6 @@ static bool choose_mult_variant (enum machine_mode, HOST_WIDE_INT,\n \t\t\t\t struct algorithm *, enum mult_variant *, int);\n static rtx expand_mult_const (enum machine_mode, rtx, HOST_WIDE_INT, rtx,\n \t\t\t      const struct algorithm *, enum mult_variant);\n-static unsigned HOST_WIDE_INT choose_multiplier (unsigned HOST_WIDE_INT, int,\n-\t\t\t\t\t\t int, rtx *, int *, int *);\n static unsigned HOST_WIDE_INT invert_mod2n (unsigned HOST_WIDE_INT, int);\n static rtx extract_high_half (enum machine_mode, rtx);\n static rtx expand_mult_highpart (enum machine_mode, rtx, rtx, rtx, int, int);\n@@ -3293,10 +3291,10 @@ ceil_log2 (unsigned HOST_WIDE_INT x)\n    Using this function, x/D will be equal to (x * m) >> (*POST_SHIFT_PTR),\n    where m is the full HOST_BITS_PER_WIDE_INT + 1 bit multiplier.  */\n \n-static\n unsigned HOST_WIDE_INT\n choose_multiplier (unsigned HOST_WIDE_INT d, int n, int precision,\n-\t\t   rtx *multiplier_ptr, int *post_shift_ptr, int *lgup_ptr)\n+\t\t   unsigned HOST_WIDE_INT *multiplier_ptr,\n+\t\t   int *post_shift_ptr, int *lgup_ptr)\n {\n   HOST_WIDE_INT mhigh_hi, mlow_hi;\n   unsigned HOST_WIDE_INT mhigh_lo, mlow_lo;\n@@ -3368,12 +3366,12 @@ choose_multiplier (unsigned HOST_WIDE_INT d, int n, int precision,\n   if (n < HOST_BITS_PER_WIDE_INT)\n     {\n       unsigned HOST_WIDE_INT mask = ((unsigned HOST_WIDE_INT) 1 << n) - 1;\n-      *multiplier_ptr = GEN_INT (mhigh_lo & mask);\n+      *multiplier_ptr = mhigh_lo & mask;\n       return mhigh_lo >= mask;\n     }\n   else\n     {\n-      *multiplier_ptr = GEN_INT (mhigh_lo);\n+      *multiplier_ptr = mhigh_lo;\n       return mhigh_hi;\n     }\n }\n@@ -4053,10 +4051,9 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t  {\n \t    if (unsignedp)\n \t      {\n-\t\tunsigned HOST_WIDE_INT mh;\n+\t\tunsigned HOST_WIDE_INT mh, ml;\n \t\tint pre_shift, post_shift;\n \t\tint dummy;\n-\t\trtx ml;\n \t\tunsigned HOST_WIDE_INT d = (INTVAL (op1)\n \t\t\t\t\t    & GET_MODE_MASK (compute_mode));\n \n@@ -4118,7 +4115,8 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\t      = (shift_cost[speed][compute_mode][post_shift - 1]\n \t\t\t\t + shift_cost[speed][compute_mode][1]\n \t\t\t\t + 2 * add_cost[speed][compute_mode]);\n-\t\t\t    t1 = expand_mult_highpart (compute_mode, op0, ml,\n+\t\t\t    t1 = expand_mult_highpart (compute_mode, op0,\n+\t\t\t\t\t\t       GEN_INT (ml),\n \t\t\t\t\t\t       NULL_RTX, 1,\n \t\t\t\t\t\t       max_cost - extra_cost);\n \t\t\t    if (t1 == 0)\n@@ -4149,7 +4147,8 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\t    extra_cost\n \t\t\t      = (shift_cost[speed][compute_mode][pre_shift]\n \t\t\t\t + shift_cost[speed][compute_mode][post_shift]);\n-\t\t\t    t2 = expand_mult_highpart (compute_mode, t1, ml,\n+\t\t\t    t2 = expand_mult_highpart (compute_mode, t1,\n+\t\t\t\t\t\t       GEN_INT (ml),\n \t\t\t\t\t\t       NULL_RTX, 1,\n \t\t\t\t\t\t       max_cost - extra_cost);\n \t\t\t    if (t2 == 0)\n@@ -4262,8 +4261,7 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\telse if (size <= HOST_BITS_PER_WIDE_INT)\n \t\t  {\n \t\t    choose_multiplier (abs_d, size, size - 1,\n-\t\t\t\t       &mlr, &post_shift, &lgup);\n-\t\t    ml = (unsigned HOST_WIDE_INT) INTVAL (mlr);\n+\t\t\t\t       &ml, &post_shift, &lgup);\n \t\t    if (ml < (unsigned HOST_WIDE_INT) 1 << (size - 1))\n \t\t      {\n \t\t\trtx t1, t2, t3;\n@@ -4275,8 +4273,8 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\textra_cost = (shift_cost[speed][compute_mode][post_shift]\n \t\t\t\t      + shift_cost[speed][compute_mode][size - 1]\n \t\t\t\t      + add_cost[speed][compute_mode]);\n-\t\t\tt1 = expand_mult_highpart (compute_mode, op0, mlr,\n-\t\t\t\t\t\t   NULL_RTX, 0,\n+\t\t\tt1 = expand_mult_highpart (compute_mode, op0,\n+\t\t\t\t\t\t   GEN_INT (ml), NULL_RTX, 0,\n \t\t\t\t\t\t   max_cost - extra_cost);\n \t\t\tif (t1 == 0)\n \t\t\t  goto fail1;\n@@ -4356,10 +4354,9 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n       /* We will come here only for signed operations.  */\n \tif (op1_is_constant && HOST_BITS_PER_WIDE_INT >= size)\n \t  {\n-\t    unsigned HOST_WIDE_INT mh;\n+\t    unsigned HOST_WIDE_INT mh, ml;\n \t    int pre_shift, lgup, post_shift;\n \t    HOST_WIDE_INT d = INTVAL (op1);\n-\t    rtx ml;\n \n \t    if (d > 0)\n \t      {\n@@ -4399,8 +4396,8 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\textra_cost = (shift_cost[speed][compute_mode][post_shift]\n \t\t\t\t      + shift_cost[speed][compute_mode][size - 1]\n \t\t\t\t      + 2 * add_cost[speed][compute_mode]);\n-\t\t\tt3 = expand_mult_highpart (compute_mode, t2, ml,\n-\t\t\t\t\t\t   NULL_RTX, 1,\n+\t\t\tt3 = expand_mult_highpart (compute_mode, t2,\n+\t\t\t\t\t\t   GEN_INT (ml), NULL_RTX, 1,\n \t\t\t\t\t\t   max_cost - extra_cost);\n \t\t\tif (t3 != 0)\n \t\t\t  {"}, {"sha": "7444baf166d6080ab51aeb496d481b410e20c2b0", "filename": "gcc/expr.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/079c527f5e7593f8563e3415ad04cf1f0e5d9269/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/079c527f5e7593f8563e3415ad04cf1f0e5d9269/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=079c527f5e7593f8563e3415ad04cf1f0e5d9269", "patch": "@@ -243,6 +243,13 @@ extern rtx emit_store_flag (rtx, enum rtx_code, rtx, rtx, enum machine_mode,\n /* Like emit_store_flag, but always succeeds.  */\n extern rtx emit_store_flag_force (rtx, enum rtx_code, rtx, rtx,\n \t\t\t\t  enum machine_mode, int, int);\n+\n+/* Choose a minimal N + 1 bit approximation to 1/D that can be used to\n+   replace division by D, and put the least significant N bits of the result\n+   in *MULTIPLIER_PTR and return the most significant bit.  */\n+extern unsigned HOST_WIDE_INT choose_multiplier (unsigned HOST_WIDE_INT, int,\n+\t\t\t\t\t\t int, unsigned HOST_WIDE_INT *,\n+\t\t\t\t\t\t int *, int *);\n \f\n /* Functions from builtins.c:  */\n extern rtx expand_builtin (tree, rtx, rtx, enum machine_mode, int);"}, {"sha": "f3d10e3fb5e581f17ee352f630a04067ab7938a3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/079c527f5e7593f8563e3415ad04cf1f0e5d9269/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/079c527f5e7593f8563e3415ad04cf1f0e5d9269/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=079c527f5e7593f8563e3415ad04cf1f0e5d9269", "patch": "@@ -1,3 +1,17 @@\n+2012-06-15  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/51581\n+\t* gcc.c-torture/execute/pr51581-1.c: New test.\n+\t* gcc.c-torture/execute/pr51581-2.c: New test.\n+\t* gcc.dg/vect/pr51581-1.c: New test.\n+\t* gcc.dg/vect/pr51581-2.c: New test.\n+\t* gcc.dg/vect/pr51581-3.c: New test.\n+\t* gcc.target/i386/avx-pr51581-1.c: New test.\n+\t* gcc.target/i386/avx-pr51581-2.c: New test.\n+\t* gcc.target/i386/avx2-pr51581-1.c: New test.\n+\t* gcc.target/i386/avx2-pr51581-2.c: New test.\n+\t* gcc.dg/vect/slp-26.c (main1): Divide by 0x8031 instead of 3.\n+\n 2012-06-15  Richard Guenther  <rguenther@suse.de>\n \n \t* gcc.c-torture/execute/20120615-1.c: New testcase."}, {"sha": "396b7aab2269ff5f39b4383aa277e75b8471865e", "filename": "gcc/testsuite/gcc.c-torture/execute/pr51581-1.c", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/079c527f5e7593f8563e3415ad04cf1f0e5d9269/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr51581-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/079c527f5e7593f8563e3415ad04cf1f0e5d9269/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr51581-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr51581-1.c?ref=079c527f5e7593f8563e3415ad04cf1f0e5d9269", "patch": "@@ -0,0 +1,157 @@\n+/* PR tree-optimization/51581 */\n+\n+extern void abort (void);\n+\n+#define N 4096\n+int a[N], c[N];\n+unsigned int b[N], d[N];\n+\n+__attribute__((noinline, noclone)) void\n+f1 (void)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    c[i] = a[i] / 3;\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f2 (void)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    d[i] = b[i] / 3;\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f3 (void)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    c[i] = a[i] / 18;\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f4 (void)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    d[i] = b[i] / 18;\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f5 (void)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    c[i] = a[i] / 19;\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f6 (void)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    d[i] = b[i] / 19;\n+}\n+\n+#if __SIZEOF_INT__ == 4 && __SIZEOF_LONG_LONG__ == 8\n+__attribute__((noinline, noclone)) void\n+f7 (void)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    c[i] = (int) ((unsigned long long) (a[i] * 0x55555556LL) >> 32) - (a[i] >> 31);\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f8 (void)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    d[i] = ((unsigned int) ((b[i] * 0xaaaaaaabULL) >> 32) >> 1);\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f9 (void)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    c[i] = (((int) ((unsigned long long) (a[i] * 0x38e38e39LL) >> 32)) >> 2) - (a[i] >> 31);\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f10 (void)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    d[i] = (unsigned int) ((b[i] * 0x38e38e39ULL) >> 32) >> 2;\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f11 (void)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    c[i] = (((int) ((unsigned long long) (a[i] * 0x6bca1af3LL) >> 32)) >> 3) - (a[i] >> 31);\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f12 (void)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    {\n+      unsigned int tmp = (b[i] * 0xaf286bcbULL) >> 32;\n+      d[i] = (((b[i] - tmp) >> 1) + tmp) >> 4;\n+    }\n+}\n+#endif\n+\n+int\n+main ()\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    {\n+      asm (\"\");\n+      a[i] = i - N / 2;\n+      b[i] = i;\n+    }\n+  a[0] = -__INT_MAX__ - 1;\n+  a[1] = -__INT_MAX__;\n+  a[N - 1] = __INT_MAX__;\n+  b[N - 1] = ~0;\n+  f1 ();\n+  f2 ();\n+  for (i = 0; i < N; i++)\n+    if (c[i] != a[i] / 3 || d[i] != b[i] / 3)\n+      abort ();\n+  f3 ();\n+  f4 ();\n+  for (i = 0; i < N; i++)\n+    if (c[i] != a[i] / 18 || d[i] != b[i] / 18)\n+      abort ();\n+  f5 ();\n+  f6 ();\n+  for (i = 0; i < N; i++)\n+    if (c[i] != a[i] / 19 || d[i] != b[i] / 19)\n+      abort ();\n+#if __SIZEOF_INT__ == 4 && __SIZEOF_LONG_LONG__ == 8\n+  f7 ();\n+  f8 ();\n+  for (i = 0; i < N; i++)\n+    if (c[i] != a[i] / 3 || d[i] != b[i] / 3)\n+      abort ();\n+  f9 ();\n+  f10 ();\n+  for (i = 0; i < N; i++)\n+    if (c[i] != a[i] / 18 || d[i] != b[i] / 18)\n+      abort ();\n+  f11 ();\n+  f12 ();\n+  for (i = 0; i < N; i++)\n+    if (c[i] != a[i] / 19 || d[i] != b[i] / 19)\n+      abort ();\n+#endif\n+  return 0;\n+}"}, {"sha": "dc111c4215886b5a1f436c2c75bb41fd7bc2b59b", "filename": "gcc/testsuite/gcc.c-torture/execute/pr51581-2.c", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/079c527f5e7593f8563e3415ad04cf1f0e5d9269/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr51581-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/079c527f5e7593f8563e3415ad04cf1f0e5d9269/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr51581-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr51581-2.c?ref=079c527f5e7593f8563e3415ad04cf1f0e5d9269", "patch": "@@ -0,0 +1,173 @@\n+/* PR tree-optimization/51581 */\n+\n+extern void abort (void);\n+\n+#define N 4096\n+int a[N], c[N];\n+unsigned int b[N], d[N];\n+\n+__attribute__((noinline, noclone)) void\n+f1 (void)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    c[i] = a[i] % 3;\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f2 (void)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    d[i] = b[i] % 3;\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f3 (void)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    c[i] = a[i] % 18;\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f4 (void)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    d[i] = b[i] % 18;\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f5 (void)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    c[i] = a[i] % 19;\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f6 (void)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    d[i] = b[i] % 19;\n+}\n+\n+#if __SIZEOF_INT__ == 4 && __SIZEOF_LONG_LONG__ == 8\n+__attribute__((noinline, noclone)) void\n+f7 (void)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    {\n+      int x = (int) ((unsigned long long) (a[i] * 0x55555556LL) >> 32) - (a[i] >> 31);\n+      c[i] = a[i] - x * 3;\n+    }\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f8 (void)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    {\n+      unsigned int x = ((unsigned int) ((b[i] * 0xaaaaaaabULL) >> 32) >> 1);\n+      d[i] = b[i] - x * 3;\n+    }\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f9 (void)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    {\n+      int x = (((int) ((unsigned long long) (a[i] * 0x38e38e39LL) >> 32)) >> 2) - (a[i] >> 31);\n+      c[i] = a[i] - x * 18;\n+    }\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f10 (void)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    {\n+      unsigned int x = (unsigned int) ((b[i] * 0x38e38e39ULL) >> 32) >> 2;\n+      d[i] = b[i] - x * 18;\n+    }\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f11 (void)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    {\n+      int x = (((int) ((unsigned long long) (a[i] * 0x6bca1af3LL) >> 32)) >> 3) - (a[i] >> 31);\n+      c[i] = a[i] - x * 19;\n+    }\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f12 (void)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    {\n+      unsigned int tmp = (b[i] * 0xaf286bcbULL) >> 32;\n+      unsigned int x = (((b[i] - tmp) >> 1) + tmp) >> 4;\n+      d[i] = b[i] - x * 19;\n+    }\n+}\n+#endif\n+\n+int\n+main ()\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    {\n+      asm (\"\");\n+      a[i] = i - N / 2;\n+      b[i] = i;\n+    }\n+  a[0] = -__INT_MAX__ - 1;\n+  a[1] = -__INT_MAX__;\n+  a[N - 1] = __INT_MAX__;\n+  b[N - 1] = ~0;\n+  f1 ();\n+  f2 ();\n+  for (i = 0; i < N; i++)\n+    if (c[i] != a[i] % 3 || d[i] != b[i] % 3)\n+      abort ();\n+  f3 ();\n+  f4 ();\n+  for (i = 0; i < N; i++)\n+    if (c[i] != a[i] % 18 || d[i] != b[i] % 18)\n+      abort ();\n+  f5 ();\n+  f6 ();\n+  for (i = 0; i < N; i++)\n+    if (c[i] != a[i] % 19 || d[i] != b[i] % 19)\n+      abort ();\n+#if __SIZEOF_INT__ == 4 && __SIZEOF_LONG_LONG__ == 8\n+  f7 ();\n+  f8 ();\n+  for (i = 0; i < N; i++)\n+    if (c[i] != a[i] % 3 || d[i] != b[i] % 3)\n+      abort ();\n+  f9 ();\n+  f10 ();\n+  for (i = 0; i < N; i++)\n+    if (c[i] != a[i] % 18 || d[i] != b[i] % 18)\n+      abort ();\n+  f11 ();\n+  f12 ();\n+  for (i = 0; i < N; i++)\n+    if (c[i] != a[i] % 19 || d[i] != b[i] % 19)\n+      abort ();\n+#endif\n+  return 0;\n+}"}, {"sha": "d8d61be902cb704afc2fd8d1fcc11b78bdb373c8", "filename": "gcc/testsuite/gcc.dg/vect/pr51581-1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/079c527f5e7593f8563e3415ad04cf1f0e5d9269/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr51581-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/079c527f5e7593f8563e3415ad04cf1f0e5d9269/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr51581-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr51581-1.c?ref=079c527f5e7593f8563e3415ad04cf1f0e5d9269", "patch": "@@ -0,0 +1,18 @@\n+/* PR tree-optimization/51581 */\n+\n+#include \"tree-vect.h\"\n+\n+#define main main1\n+#include \"../../gcc.c-torture/execute/pr51581-1.c\"\n+#undef main\n+\n+int\n+main ()\n+{\n+  int i;\n+  check_vect ();\n+  asm (\"\");\n+  return main1 ();\n+}\n+\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "13b8ba92cf6cb99c87c05b65fc9c969041cf9ace", "filename": "gcc/testsuite/gcc.dg/vect/pr51581-2.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/079c527f5e7593f8563e3415ad04cf1f0e5d9269/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr51581-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/079c527f5e7593f8563e3415ad04cf1f0e5d9269/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr51581-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr51581-2.c?ref=079c527f5e7593f8563e3415ad04cf1f0e5d9269", "patch": "@@ -0,0 +1,18 @@\n+/* PR tree-optimization/51581 */\n+\n+#include \"tree-vect.h\"\n+\n+#define main main1\n+#include \"../../gcc.c-torture/execute/pr51581-2.c\"\n+#undef main\n+\n+int\n+main ()\n+{\n+  int i;\n+  check_vect ();\n+  asm (\"\");\n+  return main1 ();\n+}\n+\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "a478136172f7eceb4fd2c8ebc038ff6e10a66421", "filename": "gcc/testsuite/gcc.dg/vect/pr51581-3.c", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/079c527f5e7593f8563e3415ad04cf1f0e5d9269/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr51581-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/079c527f5e7593f8563e3415ad04cf1f0e5d9269/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr51581-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr51581-3.c?ref=079c527f5e7593f8563e3415ad04cf1f0e5d9269", "patch": "@@ -0,0 +1,118 @@\n+/* PR tree-optimization/51581 */\n+\n+#include \"tree-vect.h\"\n+\n+int a[8], b[8];\n+unsigned int c[8], d[8];\n+\n+void\n+f1 (void)\n+{\n+  a[0] = b[0] / 8;\n+  a[1] = b[1] / 8;\n+  a[2] = b[2] / 8;\n+  a[3] = b[3] / 8;\n+  a[4] = b[4] / 8;\n+  a[5] = b[5] / 8;\n+  a[6] = b[6] / 8;\n+  a[7] = b[7] / 8;\n+}\n+\n+void\n+f2 (void)\n+{\n+  c[0] = d[0] / 3;\n+  c[1] = d[1] / 3;\n+  c[2] = d[2] / 3;\n+  c[3] = d[3] / 3;\n+  c[4] = d[4] / 3;\n+  c[5] = d[5] / 3;\n+  c[6] = d[6] / 3;\n+  c[7] = d[7] / 3;\n+}\n+\n+void\n+f3 (void)\n+{\n+  a[0] = b[0] / 8;\n+  a[1] = b[1] / 4;\n+  a[2] = b[2] / 8;\n+  a[3] = b[3] / 4;\n+  a[4] = b[4] / 8;\n+  a[5] = b[5] / 4;\n+  a[6] = b[6] / 8;\n+  a[7] = b[7] / 4;\n+}\n+\n+void\n+f4 (void)\n+{\n+  c[0] = d[0] / 3;\n+  c[1] = d[1] / 5;\n+  c[2] = d[2] / 3;\n+  c[3] = d[3] / 5;\n+  c[4] = d[4] / 3;\n+  c[5] = d[5] / 5;\n+  c[6] = d[6] / 3;\n+  c[7] = d[7] / 5;\n+}\n+\n+void\n+f5 (void)\n+{\n+  a[0] = b[0] / 14;\n+  a[1] = b[1] / 15;\n+  a[2] = b[2] / 14;\n+  a[3] = b[3] / 15;\n+  a[4] = b[4] / 14;\n+  a[5] = b[5] / 15;\n+  a[6] = b[6] / 14;\n+  a[7] = b[7] / 15;\n+}\n+\n+void\n+f6 (void)\n+{\n+  c[0] = d[0] / 6;\n+  c[1] = d[1] / 5;\n+  c[2] = d[2] / 6;\n+  c[3] = d[3] / 5;\n+  c[4] = d[4] / 6;\n+  c[5] = d[5] / 5;\n+  c[6] = d[6] / 13;\n+  c[7] = d[7] / 5;\n+}\n+\n+int\n+main ()\n+{\n+  int i;\n+  check_vect ();\n+  asm (\"\");\n+  for (i = 0; i < 8; i++)\n+    {\n+      asm (\"\");\n+      b[i] = i - 4;\n+      d[i] = i - 4;\n+    }\n+  f1 ();\n+  f2 ();\n+  for (i = 0; i < 8; i++)\n+    if (a[i] != b[i] / 8 || c[i] != d[i] / 3)\n+      abort ();\n+  f3 ();\n+  f4 ();\n+  for (i = 0; i < 8; i+= 2)\n+    if (a[i] != b[i] / 8 || a[i + 1] != b[i + 1] / 4\n+\t|| c[i] != d[i] / 3 || c[i + 1] != d[i + 1] / 5)\n+      abort ();\n+  f5 ();\n+  f6 ();\n+  for (i = 0; i < 8; i+= 2)\n+    if (a[i] != b[i] / 14 || a[i + 1] != b[i + 1] / 15\n+\t|| c[i] != d[i] / (i == 6 ? 13 : 6) || c[i + 1] != d[i + 1] / 5)\n+      abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "09a1ecd9c427232d2b7a1e97dfe15c4753b27e68", "filename": "gcc/testsuite/gcc.dg/vect/slp-26.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/079c527f5e7593f8563e3415ad04cf1f0e5d9269/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-26.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/079c527f5e7593f8563e3415ad04cf1f0e5d9269/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-26.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-26.c?ref=079c527f5e7593f8563e3415ad04cf1f0e5d9269", "patch": "@@ -10,7 +10,7 @@ main1 ()\n {\n   int i;\n   unsigned short in[N*8] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};\n-  unsigned short out[N*8], a[N], b[N] = {3,6,9,12,15,18,21,24};\n+  unsigned short out[N*8], a[N], b[N] = {3,0x8031,0x7fff,0x8032,0xffff,0,0x8030,0x8000};\n \n   /* Partial SLP is not supported.  */\n   for (i = 0; i < N; i++)\n@@ -20,7 +20,7 @@ main1 ()\n       out[i*4 + 2] = in[i*4 + 2];\n       out[i*4 + 3] = in[i*4 + 3];\n \n-      a[i] = b[i] / 3;\n+      a[i] = b[i] / 0x8031;\n     }\n \n   /* check results:  */\n@@ -30,7 +30,7 @@ main1 ()\n          || out[i*4 + 1] != in[i*4 + 1]\n          || out[i*4 + 2] != in[i*4 + 2]\n          || out[i*4 + 3] != in[i*4 + 3]\n-         || a[i] != b[i] / 3)\n+\t || a[i] != b[i] / 0x8031)\n         abort ();\n     }\n "}, {"sha": "a1d84bf6845cbacd487440148b4d857620a81585", "filename": "gcc/testsuite/gcc.target/i386/avx-pr51581-1.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/079c527f5e7593f8563e3415ad04cf1f0e5d9269/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-pr51581-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/079c527f5e7593f8563e3415ad04cf1f0e5d9269/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-pr51581-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-pr51581-1.c?ref=079c527f5e7593f8563e3415ad04cf1f0e5d9269", "patch": "@@ -0,0 +1,23 @@\n+/* PR tree-optimization/51581 */\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -ftree-vectorize -mavx -fno-vect-cost-model\" } */\n+/* { dg-require-effective-target avx } */\n+\n+#ifndef CHECK_H\n+#define CHECK_H \"avx-check.h\"\n+#endif\n+#ifndef TEST\n+#define TEST avx_test\n+#endif\n+\n+#define main main1\n+#include \"../../gcc.c-torture/execute/pr51581-1.c\"\n+#undef main\n+\n+#include CHECK_H\n+\n+static void\n+TEST (void)\n+{\n+  main1 ();\n+}"}, {"sha": "6ff54d997d040724376b60552154d3abbcb9a454", "filename": "gcc/testsuite/gcc.target/i386/avx-pr51581-2.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/079c527f5e7593f8563e3415ad04cf1f0e5d9269/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-pr51581-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/079c527f5e7593f8563e3415ad04cf1f0e5d9269/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-pr51581-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-pr51581-2.c?ref=079c527f5e7593f8563e3415ad04cf1f0e5d9269", "patch": "@@ -0,0 +1,23 @@\n+/* PR tree-optimization/51581 */\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -ftree-vectorize -mavx -fno-vect-cost-model\" } */\n+/* { dg-require-effective-target avx } */\n+\n+#ifndef CHECK_H\n+#define CHECK_H \"avx-check.h\"\n+#endif\n+#ifndef TEST\n+#define TEST avx_test\n+#endif\n+\n+#define main main1\n+#include \"../../gcc.c-torture/execute/pr51581-2.c\"\n+#undef main\n+\n+#include CHECK_H\n+\n+static void\n+TEST (void)\n+{\n+  main1 ();\n+}"}, {"sha": "74d507fd9b95059925a1e5cdba76ef191d068fe2", "filename": "gcc/testsuite/gcc.target/i386/avx2-pr51581-1.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/079c527f5e7593f8563e3415ad04cf1f0e5d9269/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx2-pr51581-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/079c527f5e7593f8563e3415ad04cf1f0e5d9269/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx2-pr51581-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx2-pr51581-1.c?ref=079c527f5e7593f8563e3415ad04cf1f0e5d9269", "patch": "@@ -0,0 +1,9 @@\n+/* PR tree-optimization/51581 */\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -ftree-vectorize -mavx2 -fno-vect-cost-model\" } */\n+/* { dg-require-effective-target avx2 } */\n+\n+#define CHECK_H \"avx2-check.h\"\n+#define TEST avx2_test\n+\n+#include \"avx-pr51581-1.c\""}, {"sha": "bf063c2ef30d2ff1d9fe869229212df623f4bff8", "filename": "gcc/testsuite/gcc.target/i386/avx2-pr51581-2.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/079c527f5e7593f8563e3415ad04cf1f0e5d9269/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx2-pr51581-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/079c527f5e7593f8563e3415ad04cf1f0e5d9269/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx2-pr51581-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx2-pr51581-2.c?ref=079c527f5e7593f8563e3415ad04cf1f0e5d9269", "patch": "@@ -0,0 +1,9 @@\n+/* PR tree-optimization/51581 */\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -ftree-vectorize -mavx2 -fno-vect-cost-model\" } */\n+/* { dg-require-effective-target avx2 } */\n+\n+#define CHECK_H \"avx2-check.h\"\n+#define TEST avx2_test\n+\n+#include \"avx-pr51581-2.c\""}, {"sha": "aeb7eb23eb402436f2f91390b416853a6cf1a50c", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 424, "deletions": 86, "changes": 510, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/079c527f5e7593f8563e3415ad04cf1f0e5d9269/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/079c527f5e7593f8563e3415ad04cf1f0e5d9269/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=079c527f5e7593f8563e3415ad04cf1f0e5d9269", "patch": "@@ -53,8 +53,8 @@ static gimple vect_recog_widen_shift_pattern (VEC (gimple, heap) **,\n \t                                tree *, tree *);\n static gimple vect_recog_vector_vector_shift_pattern (VEC (gimple, heap) **,\n \t\t\t\t\t\t      tree *, tree *);\n-static gimple vect_recog_sdivmod_pow2_pattern (VEC (gimple, heap) **,\n-\t\t\t\t\t       tree *, tree *);\n+static gimple vect_recog_divmod_pattern (VEC (gimple, heap) **,\n+\t\t\t\t\t tree *, tree *);\n static gimple vect_recog_mixed_size_cond_pattern (VEC (gimple, heap) **,\n \t\t\t\t\t\t  tree *, tree *);\n static gimple vect_recog_bool_pattern (VEC (gimple, heap) **, tree *, tree *);\n@@ -66,7 +66,7 @@ static vect_recog_func_ptr vect_vect_recog_func_ptrs[NUM_PATTERNS] = {\n \tvect_recog_widen_shift_pattern,\n \tvect_recog_over_widening_pattern,\n \tvect_recog_vector_vector_shift_pattern,\n-\tvect_recog_sdivmod_pow2_pattern,\n+\tvect_recog_divmod_pattern,\n \tvect_recog_mixed_size_cond_pattern,\n \tvect_recog_bool_pattern};\n \n@@ -1585,29 +1585,30 @@ vect_recog_vector_vector_shift_pattern (VEC (gimple, heap) **stmts,\n   return pattern_stmt;\n }\n \n-/* Detect a signed division by power of two constant that wouldn't be\n+/* Detect a signed division by a constant that wouldn't be\n    otherwise vectorized:\n \n    type a_t, b_t;\n \n    S1 a_t = b_t / N;\n \n-  where type 'type' is a signed integral type and N is a constant positive\n-  power of two.\n+  where type 'type' is an integral type and N is a constant.\n \n-  Similarly handle signed modulo by power of two constant:\n+  Similarly handle modulo by a constant:\n \n    S4 a_t = b_t % N;\n \n   Input/Output:\n \n   * STMTS: Contains a stmt from which the pattern search begins,\n-    i.e. the division stmt.  S1 is replaced by:\n+    i.e. the division stmt.  S1 is replaced by if N is a power\n+    of two constant and type is signed:\n   S3  y_t = b_t < 0 ? N - 1 : 0;\n   S2  x_t = b_t + y_t;\n   S1' a_t = x_t >> log2 (N);\n \n-    S4 is replaced by (where *_T temporaries have unsigned type):\n+    S4 is replaced if N is a power of two constant and\n+    type is signed by (where *_T temporaries have unsigned type):\n   S9  y_T = b_t < 0 ? -1U : 0U;\n   S8  z_T = y_T >> (sizeof (type_t) * CHAR_BIT - log2 (N));\n   S7  z_t = (type) z_T;\n@@ -1625,16 +1626,22 @@ vect_recog_vector_vector_shift_pattern (VEC (gimple, heap) **stmts,\n     S1 or modulo S4 stmt.  */\n \n static gimple\n-vect_recog_sdivmod_pow2_pattern (VEC (gimple, heap) **stmts,\n-\t\t\t\t tree *type_in, tree *type_out)\n+vect_recog_divmod_pattern (VEC (gimple, heap) **stmts,\n+\t\t\t   tree *type_in, tree *type_out)\n {\n   gimple last_stmt = VEC_pop (gimple, *stmts);\n-  tree oprnd0, oprnd1, vectype, itype, cond;\n+  tree oprnd0, oprnd1, vectype, itype, witype, vecwtype, cond;\n   gimple pattern_stmt, def_stmt;\n   enum tree_code rhs_code;\n   stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n+  bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_vinfo);\n   optab optab;\n+  tree dummy, q;\n+  enum tree_code dummy_code;\n+  int dummy_int, prec;\n+  VEC (tree, heap) *dummy_vec;\n+  stmt_vec_info def_stmt_vinfo;\n \n   if (!is_gimple_assign (last_stmt))\n     return NULL;\n@@ -1658,10 +1665,7 @@ vect_recog_sdivmod_pow2_pattern (VEC (gimple, heap) **stmts,\n   if (TREE_CODE (oprnd0) != SSA_NAME\n       || TREE_CODE (oprnd1) != INTEGER_CST\n       || TREE_CODE (itype) != INTEGER_TYPE\n-      || TYPE_UNSIGNED (itype)\n-      || TYPE_PRECISION (itype) != GET_MODE_PRECISION (TYPE_MODE (itype))\n-      || !integer_pow2p (oprnd1)\n-      || tree_int_cst_sgn (oprnd1) != 1)\n+      || TYPE_PRECISION (itype) != GET_MODE_PRECISION (TYPE_MODE (itype)))\n     return NULL;\n \n   vectype = get_vectype_for_scalar_type (itype);\n@@ -1680,104 +1684,438 @@ vect_recog_sdivmod_pow2_pattern (VEC (gimple, heap) **stmts,\n \treturn NULL;\n     }\n \n-  /* Pattern detected.  */\n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"vect_recog_sdivmod_pow2_pattern: detected: \");\n-\n-  cond = build2 (LT_EXPR, boolean_type_node, oprnd0, build_int_cst (itype, 0));\n-  if (rhs_code == TRUNC_DIV_EXPR)\n+  prec = TYPE_PRECISION (itype);\n+  if (integer_pow2p (oprnd1))\n     {\n-      tree var = vect_recog_temp_ssa_var (itype, NULL);\n-      def_stmt\n-\t= gimple_build_assign_with_ops3 (COND_EXPR, var, cond,\n-\t\t\t\t\t fold_build2 (MINUS_EXPR, itype,\n-\t\t\t\t\t\t      oprnd1,\n-\t\t\t\t\t\t      build_int_cst (itype,\n-\t\t\t\t\t\t\t\t     1)),\n-\t\t\t\t\t build_int_cst (itype, 0));\n-      new_pattern_def_seq (stmt_vinfo, def_stmt);\n-      var = vect_recog_temp_ssa_var (itype, NULL);\n-      def_stmt\n-\t= gimple_build_assign_with_ops (PLUS_EXPR, var, oprnd0,\n-\t\t\t\t\tgimple_assign_lhs (def_stmt));\n-      append_pattern_def_seq (stmt_vinfo, def_stmt);\n+      if (TYPE_UNSIGNED (itype) || tree_int_cst_sgn (oprnd1) != 1)\n+\treturn NULL;\n \n-      pattern_stmt\n-\t= gimple_build_assign_with_ops (RSHIFT_EXPR,\n-\t\t\t\t\tvect_recog_temp_ssa_var (itype, NULL),\n-\t\t\t\t\tvar,\n-\t\t\t\t\tbuild_int_cst (itype,\n-\t\t\t\t\t\t       tree_log2 (oprnd1)));\n+      /* Pattern detected.  */\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+\tfprintf (vect_dump, \"vect_recog_divmod_pattern: detected: \");\n+\n+      cond = build2 (LT_EXPR, boolean_type_node, oprnd0,\n+\t\t     build_int_cst (itype, 0));\n+      if (rhs_code == TRUNC_DIV_EXPR)\n+\t{\n+\t  tree var = vect_recog_temp_ssa_var (itype, NULL);\n+\t  tree shift;\n+\t  def_stmt\n+\t    = gimple_build_assign_with_ops3 (COND_EXPR, var, cond,\n+\t\t\t\t\t     fold_build2 (MINUS_EXPR, itype,\n+\t\t\t\t\t\t\t  oprnd1,\n+\t\t\t\t\t\t\t  build_int_cst (itype,\n+\t\t\t\t\t\t\t\t\t 1)),\n+\t\t\t\t\t     build_int_cst (itype, 0));\n+\t  new_pattern_def_seq (stmt_vinfo, def_stmt);\n+\t  var = vect_recog_temp_ssa_var (itype, NULL);\n+\t  def_stmt\n+\t    = gimple_build_assign_with_ops (PLUS_EXPR, var, oprnd0,\n+\t\t\t\t\t    gimple_assign_lhs (def_stmt));\n+\t  append_pattern_def_seq (stmt_vinfo, def_stmt);\n+\n+\t  shift = build_int_cst (itype, tree_log2 (oprnd1));\n+\t  pattern_stmt\n+\t    = gimple_build_assign_with_ops (RSHIFT_EXPR,\n+\t\t\t\t\t    vect_recog_temp_ssa_var (itype,\n+\t\t\t\t\t\t\t\t     NULL),\n+\t\t\t\t\t    var, shift);\n+\t}\n+      else\n+\t{\n+\t  tree signmask;\n+\t  STMT_VINFO_PATTERN_DEF_SEQ (stmt_vinfo) = NULL;\n+\t  if (compare_tree_int (oprnd1, 2) == 0)\n+\t    {\n+\t      signmask = vect_recog_temp_ssa_var (itype, NULL);\n+\t      def_stmt\n+\t\t= gimple_build_assign_with_ops3 (COND_EXPR, signmask, cond,\n+\t\t\t\t\t\t build_int_cst (itype, 1),\n+\t\t\t\t\t\t build_int_cst (itype, 0));\n+\t      append_pattern_def_seq (stmt_vinfo, def_stmt);\n+\t    }\n+\t  else\n+\t    {\n+\t      tree utype\n+\t\t= build_nonstandard_integer_type (prec, 1);\n+\t      tree vecutype = get_vectype_for_scalar_type (utype);\n+\t      tree shift\n+\t\t= build_int_cst (utype, GET_MODE_BITSIZE (TYPE_MODE (itype))\n+\t\t\t\t\t- tree_log2 (oprnd1));\n+\t      tree var = vect_recog_temp_ssa_var (utype, NULL);\n+\n+\t      def_stmt\n+\t\t= gimple_build_assign_with_ops3 (COND_EXPR, var, cond,\n+\t\t\t\t\t\t build_int_cst (utype, -1),\n+\t\t\t\t\t\t build_int_cst (utype, 0));\n+\t      def_stmt_vinfo\n+\t\t= new_stmt_vec_info (def_stmt, loop_vinfo, bb_vinfo);\n+\t      set_vinfo_for_stmt (def_stmt, def_stmt_vinfo);\n+\t      STMT_VINFO_VECTYPE (def_stmt_vinfo) = vecutype;\n+\t      append_pattern_def_seq (stmt_vinfo, def_stmt);\n+\t      var = vect_recog_temp_ssa_var (utype, NULL);\n+\t      def_stmt\n+\t\t= gimple_build_assign_with_ops (RSHIFT_EXPR, var,\n+\t\t\t\t\t\tgimple_assign_lhs (def_stmt),\n+\t\t\t\t\t\tshift);\n+\t      def_stmt_vinfo\n+\t\t= new_stmt_vec_info (def_stmt, loop_vinfo, bb_vinfo);\n+\t      set_vinfo_for_stmt (def_stmt, def_stmt_vinfo);\n+\t      STMT_VINFO_VECTYPE (def_stmt_vinfo) = vecutype;\n+\t      append_pattern_def_seq (stmt_vinfo, def_stmt);\n+\t      signmask = vect_recog_temp_ssa_var (itype, NULL);\n+\t      def_stmt\n+\t\t= gimple_build_assign_with_ops (NOP_EXPR, signmask, var,\n+\t\t\t\t\t\tNULL_TREE);\n+\t      append_pattern_def_seq (stmt_vinfo, def_stmt);\n+\t    }\n+\t  def_stmt\n+\t    = gimple_build_assign_with_ops (PLUS_EXPR,\n+\t\t\t\t\t    vect_recog_temp_ssa_var (itype,\n+\t\t\t\t\t\t\t\t     NULL),\n+\t\t\t\t\t    oprnd0, signmask);\n+\t  append_pattern_def_seq (stmt_vinfo, def_stmt);\n+\t  def_stmt\n+\t    = gimple_build_assign_with_ops (BIT_AND_EXPR,\n+\t\t\t\t\t    vect_recog_temp_ssa_var (itype,\n+\t\t\t\t\t\t\t\t     NULL),\n+\t\t\t\t\t    gimple_assign_lhs (def_stmt),\n+\t\t\t\t\t    fold_build2 (MINUS_EXPR, itype,\n+\t\t\t\t\t\t\t oprnd1,\n+\t\t\t\t\t\t\t build_int_cst (itype,\n+\t\t\t\t\t\t\t\t\t1)));\n+\t  append_pattern_def_seq (stmt_vinfo, def_stmt);\n+\n+\t  pattern_stmt\n+\t    = gimple_build_assign_with_ops (MINUS_EXPR,\n+\t\t\t\t\t    vect_recog_temp_ssa_var (itype,\n+\t\t\t\t\t\t\t\t     NULL),\n+\t\t\t\t\t    gimple_assign_lhs (def_stmt),\n+\t\t\t\t\t    signmask);\n+\t}\n+\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+\tprint_gimple_stmt (vect_dump, pattern_stmt, 0, TDF_SLIM);\n+\n+      VEC_safe_push (gimple, heap, *stmts, last_stmt);\n+\n+      *type_in = vectype;\n+      *type_out = vectype;\n+      return pattern_stmt;\n     }\n-  else\n+\n+  if (!host_integerp (oprnd1, TYPE_UNSIGNED (itype))\n+      || integer_zerop (oprnd1)\n+      || prec > HOST_BITS_PER_WIDE_INT)\n+    return NULL;\n+\n+  witype = build_nonstandard_integer_type (prec * 2,\n+\t\t\t\t\t   TYPE_UNSIGNED (itype));\n+  vecwtype = get_vectype_for_scalar_type (witype);\n+  if (vecwtype == NULL_TREE)\n+    return NULL;\n+\n+  if (!supportable_widening_operation (WIDEN_MULT_EXPR, last_stmt,\n+\t\t\t\t       vecwtype, vectype,\n+\t\t\t\t       &dummy, &dummy, &dummy_code,\n+\t\t\t\t       &dummy_code, &dummy_int, &dummy_vec))\n+    return NULL;\n+\n+  STMT_VINFO_PATTERN_DEF_SEQ (stmt_vinfo) = NULL;\n+\n+  if (TYPE_UNSIGNED (itype))\n     {\n-      tree signmask;\n-      STMT_VINFO_PATTERN_DEF_SEQ (stmt_vinfo) = NULL;\n-      if (compare_tree_int (oprnd1, 2) == 0)\n+      unsigned HOST_WIDE_INT mh, ml;\n+      int pre_shift, post_shift;\n+      unsigned HOST_WIDE_INT d = tree_low_cst (oprnd1, 1)\n+\t\t\t\t & GET_MODE_MASK (TYPE_MODE (itype));\n+      tree t1, t2, t3, t4, t5, t6;\n+\n+      if (d >= ((unsigned HOST_WIDE_INT) 1 << (prec - 1)))\n+\t/* FIXME: Can transform this into oprnd0 >= oprnd1 ? 1 : 0.  */\n+\treturn NULL;\n+\n+      /* Find a suitable multiplier and right shift count\n+\t instead of multiplying with D.  */\n+      mh = choose_multiplier (d, prec, prec, &ml, &post_shift, &dummy_int);\n+\n+      /* If the suggested multiplier is more than SIZE bits, we can do better\n+\t for even divisors, using an initial right shift.  */\n+      if (mh != 0 && (d & 1) == 0)\n+\t{\n+\t  pre_shift = floor_log2 (d & -d);\n+\t  mh = choose_multiplier (d >> pre_shift, prec, prec - pre_shift,\n+\t\t\t\t  &ml, &post_shift, &dummy_int);\n+\t  gcc_assert (!mh);\n+\t}\n+      else\n+\tpre_shift = 0;\n+\n+      if (mh != 0)\n \t{\n-\t  signmask = vect_recog_temp_ssa_var (itype, NULL);\n+\t  if (post_shift - 1 >= prec)\n+\t    return NULL;\n+\n+\t  /* t1 = oprnd0 w* ml;\n+\t     t2 = t1 >> prec;\n+\t     t3 = (type) t2;\n+\t     t4 = oprnd0 - t3;\n+\t     t5 = t4 >> 1;\n+\t     t6 = t3 + t5;\n+\t     q = t6 >> (post_shift - 1);  */\n+\t  t1 = vect_recog_temp_ssa_var (witype, NULL);\n \t  def_stmt\n-\t    = gimple_build_assign_with_ops3 (COND_EXPR, signmask, cond,\n-\t\t\t\t\t     build_int_cst (itype, 1),\n-\t\t\t\t\t     build_int_cst (itype, 0));\n+\t    = gimple_build_assign_with_ops (WIDEN_MULT_EXPR, t1, oprnd0,\n+\t\t\t\t\t    build_int_cst (itype, ml));\n+\t  append_pattern_def_seq (stmt_vinfo, def_stmt);\n+\t  def_stmt_vinfo = new_stmt_vec_info (def_stmt, loop_vinfo, bb_vinfo);\n+\t  set_vinfo_for_stmt (def_stmt, def_stmt_vinfo);\n+\t  STMT_VINFO_VECTYPE (def_stmt_vinfo) = vecwtype;\n+\n+\t  t2 = vect_recog_temp_ssa_var (witype, NULL);\n+\t  def_stmt\n+\t    = gimple_build_assign_with_ops (RSHIFT_EXPR, t2, t1,\n+\t\t\t\t\t    build_int_cst (itype, prec));\n+\t  append_pattern_def_seq (stmt_vinfo, def_stmt);\n+\t  def_stmt_vinfo = new_stmt_vec_info (def_stmt, loop_vinfo, bb_vinfo);\n+\t  set_vinfo_for_stmt (def_stmt, def_stmt_vinfo);\n+\t  STMT_VINFO_VECTYPE (def_stmt_vinfo) = vecwtype;\n+\n+\t  t3 = vect_recog_temp_ssa_var (itype, NULL);\n+\t  def_stmt\n+\t    = gimple_build_assign_with_ops (NOP_EXPR, t3, t2, NULL_TREE);\n+\t  append_pattern_def_seq (stmt_vinfo, def_stmt);\n+\n+\t  t4 = vect_recog_temp_ssa_var (itype, NULL);\n+\t  def_stmt\n+\t    = gimple_build_assign_with_ops (MINUS_EXPR, t4, oprnd0, t3);\n \t  append_pattern_def_seq (stmt_vinfo, def_stmt);\n+\n+\t  t5 = vect_recog_temp_ssa_var (itype, NULL);\n+\t  def_stmt\n+\t    = gimple_build_assign_with_ops (RSHIFT_EXPR, t5, t4,\n+\t\t\t\t\t    integer_one_node);\n+\t  append_pattern_def_seq (stmt_vinfo, def_stmt);\n+\n+\t  t6 = vect_recog_temp_ssa_var (itype, NULL);\n+\t  def_stmt\n+\t    = gimple_build_assign_with_ops (PLUS_EXPR, t6, t3, t5);\n+\n+\t  if (post_shift != 1)\n+\t    {\n+\t      append_pattern_def_seq (stmt_vinfo, def_stmt);\n+\n+\t      q = vect_recog_temp_ssa_var (witype, NULL);\n+\t      pattern_stmt\n+\t\t= gimple_build_assign_with_ops (RSHIFT_EXPR, q, t6,\n+\t\t\t\t\t\tbuild_int_cst (itype,\n+\t\t\t\t\t\t\t       post_shift\n+\t\t\t\t\t\t\t       - 1));\n+\t    }\n+\t  else\n+\t    {\n+\t      q = t6;\n+\t      pattern_stmt = def_stmt;\n+\t    }\n \t}\n       else\n \t{\n-\t  tree utype\n-\t    = build_nonstandard_integer_type (TYPE_PRECISION (itype), 1);\n-\t  tree vecutype = get_vectype_for_scalar_type (utype);\n-\t  tree shift\n-\t    = build_int_cst (utype, GET_MODE_BITSIZE (TYPE_MODE (itype))\n-\t\t\t\t    - tree_log2 (oprnd1));\n-\t  tree var = vect_recog_temp_ssa_var (utype, NULL);\n-\t  stmt_vec_info def_stmt_vinfo;\n+\t  if (pre_shift >= prec || post_shift >= prec)\n+\t    return NULL;\n+\n+\t  /* t1 = oprnd0 >> pre_shift;\n+\t     t2 = t1 w* ml;\n+\t     t3 = t2 >> (prec + post_shift);\n+\t     q = (type) t3;  */\n+\t  if (pre_shift)\n+\t    {\n+\t      t1 = vect_recog_temp_ssa_var (itype, NULL);\n+\t      def_stmt\n+\t\t= gimple_build_assign_with_ops (RSHIFT_EXPR, t1, oprnd0,\n+\t\t\t\t\t\tbuild_int_cst (NULL,\n+\t\t\t\t\t\t\t       pre_shift));\n+\t      append_pattern_def_seq (stmt_vinfo, def_stmt);\n+\t    }\n+\t  else\n+\t    t1 = oprnd0;\n \n+\t  t2 = vect_recog_temp_ssa_var (witype, NULL);\n \t  def_stmt\n-\t    = gimple_build_assign_with_ops3 (COND_EXPR, var, cond,\n-\t\t\t\t\t     build_int_cst (utype, -1),\n-\t\t\t\t\t     build_int_cst (utype, 0));\n-\t  def_stmt_vinfo = new_stmt_vec_info (def_stmt, loop_vinfo, NULL);\n+\t    = gimple_build_assign_with_ops (WIDEN_MULT_EXPR, t2, t1,\n+\t\t\t\t\t    build_int_cst (itype, ml));\n+\t  append_pattern_def_seq (stmt_vinfo, def_stmt);\n+\t  def_stmt_vinfo = new_stmt_vec_info (def_stmt, loop_vinfo, bb_vinfo);\n \t  set_vinfo_for_stmt (def_stmt, def_stmt_vinfo);\n-\t  STMT_VINFO_VECTYPE (def_stmt_vinfo) = vecutype;\n+\t  STMT_VINFO_VECTYPE (def_stmt_vinfo) = vecwtype;\n+\n+\t  t3 = vect_recog_temp_ssa_var (witype, NULL);\n+\t  def_stmt\n+\t    = gimple_build_assign_with_ops (RSHIFT_EXPR, t3, t2,\n+\t\t\t\t\t    build_int_cst (itype, post_shift\n+\t\t\t\t\t\t\t\t  + prec));\n \t  append_pattern_def_seq (stmt_vinfo, def_stmt);\n-\t  var = vect_recog_temp_ssa_var (utype, NULL);\n+\t  def_stmt_vinfo = new_stmt_vec_info (def_stmt, loop_vinfo, bb_vinfo);\n+\t  set_vinfo_for_stmt (def_stmt, def_stmt_vinfo);\n+\t  STMT_VINFO_VECTYPE (def_stmt_vinfo) = vecwtype;\n+\n+\t  q = vect_recog_temp_ssa_var (itype, NULL);\n+\t  pattern_stmt\n+\t    = gimple_build_assign_with_ops (NOP_EXPR, q, t3, NULL_TREE);\n+\t}\n+    }\n+  else\n+    {\n+      unsigned HOST_WIDE_INT ml;\n+      int lgup, post_shift;\n+      HOST_WIDE_INT d = tree_low_cst (oprnd1, 0);\n+      unsigned HOST_WIDE_INT abs_d;\n+      bool add = false;\n+      tree uwitype = NULL, vecuwtype = NULL;\n+      tree t1, t2, t3, t4, t5, t6, t7;\n+\n+      /* Give up for -1.  */\n+      if (d == -1)\n+\treturn NULL;\n+\n+      if (!vect_supportable_shift (RSHIFT_EXPR, witype))\n+\t{\n+\t  uwitype = build_nonstandard_integer_type (prec * 2, 1);\n+\t  vecuwtype = get_vectype_for_scalar_type (uwitype);\n+\t  if (vecuwtype == NULL_TREE)\n+\t    return NULL;\n+\t}\n+\n+      /* Since d might be INT_MIN, we have to cast to\n+\t unsigned HOST_WIDE_INT before negating to avoid\n+\t undefined signed overflow.  */\n+      abs_d = (d >= 0\n+\t       ? (unsigned HOST_WIDE_INT) d\n+\t       : - (unsigned HOST_WIDE_INT) d);\n+\n+      /* n rem d = n rem -d */\n+      if (rhs_code == TRUNC_MOD_EXPR && d < 0)\n+\t{\n+\t  d = abs_d;\n+\t  oprnd1 = build_int_cst (itype, abs_d);\n+\t}\n+      else if (HOST_BITS_PER_WIDE_INT >= prec\n+\t       && abs_d == (unsigned HOST_WIDE_INT) 1 << (prec - 1))\n+\t/* This case is not handled correctly below.  */\n+\treturn NULL;\n+\n+      choose_multiplier (abs_d, prec, prec - 1, &ml, &post_shift, &lgup);\n+      if (ml >= (unsigned HOST_WIDE_INT) 1 << (prec - 1))\n+\t{\n+\t  add = true;\n+\t  ml |= (~(unsigned HOST_WIDE_INT) 0) << (prec - 1);\n+\t}\n+      if (post_shift >= prec)\n+\treturn NULL;\n+\n+      /* t1 = oprnd1 w* ml;  */\n+      t1 = vect_recog_temp_ssa_var (witype, NULL);\n+      def_stmt\n+\t= gimple_build_assign_with_ops (WIDEN_MULT_EXPR, t1, oprnd0,\n+\t\t\t\t\tbuild_int_cst (itype, ml));\n+      append_pattern_def_seq (stmt_vinfo, def_stmt);\n+      def_stmt_vinfo = new_stmt_vec_info (def_stmt, loop_vinfo, bb_vinfo);\n+      set_vinfo_for_stmt (def_stmt, def_stmt_vinfo);\n+      STMT_VINFO_VECTYPE (def_stmt_vinfo) = vecwtype;\n+\n+      if (vecuwtype != NULL)\n+\t{\n+\t  /* t2 = (uwtype) t1;  */\n+\t  t2 = vect_recog_temp_ssa_var (uwitype, NULL);\n \t  def_stmt\n-\t    = gimple_build_assign_with_ops (RSHIFT_EXPR, var,\n-\t\t\t\t\t    gimple_assign_lhs (def_stmt),\n-\t\t\t\t\t    shift);\n-\t  def_stmt_vinfo = new_stmt_vec_info (def_stmt, loop_vinfo, NULL);\n+\t    = gimple_build_assign_with_ops (NOP_EXPR, t2, t1, NULL_TREE);\n+\t  append_pattern_def_seq (stmt_vinfo, def_stmt);\n+\t  def_stmt_vinfo = new_stmt_vec_info (def_stmt, loop_vinfo, bb_vinfo);\n \t  set_vinfo_for_stmt (def_stmt, def_stmt_vinfo);\n-\t  STMT_VINFO_VECTYPE (def_stmt_vinfo) = vecutype;\n+\t  STMT_VINFO_VECTYPE (def_stmt_vinfo) = vecuwtype;\n+\t}\n+      else\n+\tt2 = t1;\n+\n+      /* t3 = t2 >> prec;  or t3 = t2 >> (prec + post_shift);  */\n+      t3 = vect_recog_temp_ssa_var (vecuwtype ? uwitype : witype, NULL);\n+      def_stmt\n+\t= gimple_build_assign_with_ops (RSHIFT_EXPR, t3, t2,\n+\t\t\t\t\tbuild_int_cst (itype,\n+\t\t\t\t\t\t       prec\n+\t\t\t\t\t\t       + (!add\n+\t\t\t\t\t\t\t  && vecuwtype == NULL\n+\t\t\t\t\t\t\t  ? post_shift : 0)));\n+      append_pattern_def_seq (stmt_vinfo, def_stmt);\n+      def_stmt_vinfo = new_stmt_vec_info (def_stmt, loop_vinfo, bb_vinfo);\n+      set_vinfo_for_stmt (def_stmt, def_stmt_vinfo);\n+      STMT_VINFO_VECTYPE (def_stmt_vinfo) = vecuwtype ? vecuwtype : vecwtype;\n+\n+      /* t4 = (type) t3;  */\n+      t4 = vect_recog_temp_ssa_var (itype, NULL);\n+      def_stmt\n+\t= gimple_build_assign_with_ops (NOP_EXPR, t4, t3, NULL_TREE);\n+      append_pattern_def_seq (stmt_vinfo, def_stmt);\n+\n+      if (add)\n+\t{\n+\t  /* t5 = t4 + oprnd0;  */\n+\t  t5 = vect_recog_temp_ssa_var (itype, NULL);\n+\t  def_stmt\n+\t    = gimple_build_assign_with_ops (PLUS_EXPR, t5, t4, oprnd0);\n \t  append_pattern_def_seq (stmt_vinfo, def_stmt);\n-\t  signmask = vect_recog_temp_ssa_var (itype, NULL);\n+\t}\n+      else\n+\tt5 = t4;\n+\n+      if ((add || vecuwtype != NULL) && post_shift)\n+\t{\n+\t  /* t6 = t5 >> post_shift;  */\n+\t  t6 = vect_recog_temp_ssa_var (itype, NULL);\n \t  def_stmt\n-\t    = gimple_build_assign_with_ops (NOP_EXPR, signmask, var,\n-\t\t\t\t\t    NULL_TREE);\n+\t    = gimple_build_assign_with_ops (RSHIFT_EXPR, t6, t5,\n+\t\t\t\t\t    build_int_cst (itype, post_shift));\n \t  append_pattern_def_seq (stmt_vinfo, def_stmt);\n \t}\n+      else\n+\tt6 = t5;\n+\n+      /* t7 = oprnd0 >> (prec - 1);  */\n+      t7 = vect_recog_temp_ssa_var (itype, NULL);\n       def_stmt\n-\t= gimple_build_assign_with_ops (PLUS_EXPR,\n-\t\t\t\t\tvect_recog_temp_ssa_var (itype, NULL),\n-\t\t\t\t\toprnd0, signmask);\n+\t= gimple_build_assign_with_ops (RSHIFT_EXPR, t7, oprnd0,\n+\t\t\t\t\tbuild_int_cst (itype, prec - 1));\n       append_pattern_def_seq (stmt_vinfo, def_stmt);\n+\n+      /* q = t6 - t7;  or q = t7 - t6;  */\n+      q = vect_recog_temp_ssa_var (itype, NULL);\n+      pattern_stmt\n+\t= gimple_build_assign_with_ops (MINUS_EXPR, q, d < 0 ? t7 : t6,\n+\t\t\t\t\td < 0 ? t6 : t7);\n+    }\n+\n+  if (rhs_code == TRUNC_MOD_EXPR)\n+    {\n+      tree r, t1;\n+\n+      /* We divided.  Now finish by:\n+\t t1 = q * oprnd1;\n+\t r = oprnd0 - t1;  */\n+      append_pattern_def_seq (stmt_vinfo, pattern_stmt);\n+\n+      t1 = vect_recog_temp_ssa_var (itype, NULL);\n       def_stmt\n-\t= gimple_build_assign_with_ops (BIT_AND_EXPR,\n-\t\t\t\t\tvect_recog_temp_ssa_var (itype, NULL),\n-\t\t\t\t\tgimple_assign_lhs (def_stmt),\n-\t\t\t\t\tfold_build2 (MINUS_EXPR, itype,\n-\t\t\t\t\t\t     oprnd1,\n-\t\t\t\t\t\t     build_int_cst (itype,\n-\t\t\t\t\t\t\t\t    1)));\n+\t= gimple_build_assign_with_ops (MULT_EXPR, t1, q, oprnd1);\n       append_pattern_def_seq (stmt_vinfo, def_stmt);\n \n+      r = vect_recog_temp_ssa_var (itype, NULL);\n       pattern_stmt\n-\t= gimple_build_assign_with_ops (MINUS_EXPR,\n-\t\t\t\t\tvect_recog_temp_ssa_var (itype, NULL),\n-\t\t\t\t\tgimple_assign_lhs (def_stmt),\n-\t\t\t\t\tsignmask);\n+\t= gimple_build_assign_with_ops (MINUS_EXPR, r, oprnd0, t1);\n     }\n \n+  /* Pattern detected.  */\n+  if (vect_print_dump_info (REPORT_DETAILS))\n+    fprintf (vect_dump, \"vect_recog_divmod_pattern: detected: \");\n+\n   if (vect_print_dump_info (REPORT_DETAILS))\n     print_gimple_stmt (vect_dump, pattern_stmt, 0, TDF_SLIM);\n "}, {"sha": "5853d4fdec9392529cbacadb71f665d69ec30a45", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/079c527f5e7593f8563e3415ad04cf1f0e5d9269/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/079c527f5e7593f8563e3415ad04cf1f0e5d9269/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=079c527f5e7593f8563e3415ad04cf1f0e5d9269", "patch": "@@ -5361,7 +5361,9 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n \n      Pattern statement needs to be analyzed instead of the original statement\n      if the original statement is not relevant.  Otherwise, we analyze both\n-     statements.  */\n+     statements.  In basic blocks we are called from some SLP instance\n+     traversal, don't analyze pattern stmts instead, the pattern stmts\n+     already will be part of SLP instance.  */\n \n   pattern_stmt = STMT_VINFO_RELATED_STMT (stmt_info);\n   if (!STMT_VINFO_RELEVANT_P (stmt_info)\n@@ -5390,6 +5392,7 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n         }\n     }\n   else if (STMT_VINFO_IN_PATTERN_P (stmt_info)\n+\t   && node == NULL\n            && pattern_stmt\n            && (STMT_VINFO_RELEVANT_P (vinfo_for_stmt (pattern_stmt))\n                || STMT_VINFO_LIVE_P (vinfo_for_stmt (pattern_stmt))))\n@@ -5406,6 +5409,7 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n    }\n \n   if (is_pattern_stmt_p (stmt_info)\n+      && node == NULL\n       && (pattern_def_seq = STMT_VINFO_PATTERN_DEF_SEQ (stmt_info)))\n     {\n       gimple_stmt_iterator si;"}]}