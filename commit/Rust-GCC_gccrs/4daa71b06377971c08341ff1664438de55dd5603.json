{"sha": "4daa71b06377971c08341ff1664438de55dd5603", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGRhYTcxYjA2Mzc3OTcxYzA4MzQxZmYxNjY0NDM4ZGU1NWRkNTYwMw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2012-01-27T10:05:56Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2012-01-27T10:05:56Z"}, "message": "re PR fortran/48705 ([OOP] ALLOCATE with non-trivial SOURCE)\n\n2012-01-27  Paul Thomas  <pault@gcc.gnu.org>\n\t    Tobias Burnus <burnus@gcc.gnu.org>\n\n\tPR fortran/48705\n\tPR fortran/51870\n\tPR fortran/51943\n\tPR fortran/51946\n\t* trans-array.c (gfc_array_init_size): Add two extra arguments\n\tto convey the dynamic element size of a calls object and to\n\treturn the number of elements that have been allocated.\n\t(gfc_array_allocate): Add the same arguments and use them to\n\tcall gfc_array_init_size.  Before the allocation dereference\n\tthe data pointer, if necessary. Set the allocated array to zero\n\tif the class element size or expr3 are non-null.\n\t* trans-expr.c (gfc_conv_class_to_class): Give this function\n\tglobal scope.\n\t(get_class_array_ref): New function.\n\t(gfc_copy_class_to_class): New function.\n\t* trans-array.h : Update prototype for gfc_array_allocate.\n\t* trans-stmt.c (gfc_trans_allocate): For non-variable class\n\tSTATUS expressions extract the class object and the dynamic\n\telement size. Use the latter to call gfc_array_allocate and\n\tthe former for setting the vptr and, via\n\tgfc_copy_class_to_clasfc_cs, to copy to the allocated data.\n\t* trans.h : Prototypes for gfc_get_class_array_ref,\n\tgfc_copy_class_to_class and gfc_conv_class_to_class.\n  \n\n2012-01-27  Paul Thomas  <pault@gcc.gnu.org>\n\t    Tobias Burnus <burnus@gcc.gnu.org>\n\n\tPR fortran/48705\n\t* gfortran.dg/class_allocate_11.f03: New.\n\n\tPR fortran/51870\n\tPR fortran/51943\n\tPR fortran/51946\n\t* gfortran.dg/class_allocate_7.f03: New.\n\t* gfortran.dg/class_allocate_8.f03: New.\n\t* gfortran.dg/class_allocate_9.f03: New.\n\t* gfortran.dg/class_allocate_10.f03: New.\n\n\nCo-Authored-By: Tobias Burnus <burnus@gcc.gnu.org>\n\nFrom-SVN: r183613", "tree": {"sha": "2f2b76a32e0f1e1dd26a98bf3470caf96f4b01eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f2b76a32e0f1e1dd26a98bf3470caf96f4b01eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4daa71b06377971c08341ff1664438de55dd5603", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4daa71b06377971c08341ff1664438de55dd5603", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4daa71b06377971c08341ff1664438de55dd5603", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4daa71b06377971c08341ff1664438de55dd5603/comments", "author": null, "committer": null, "parents": [{"sha": "46c91e45189f62bc959245d9ca5d40f44a65ac82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46c91e45189f62bc959245d9ca5d40f44a65ac82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46c91e45189f62bc959245d9ca5d40f44a65ac82"}], "stats": {"total": 501, "additions": 473, "deletions": 28}, "files": [{"sha": "1dcbfeaa0cda2fbf7ee36b80097ec342a7da5d51", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4daa71b06377971c08341ff1664438de55dd5603/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4daa71b06377971c08341ff1664438de55dd5603/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=4daa71b06377971c08341ff1664438de55dd5603", "patch": "@@ -1,3 +1,30 @@\n+2012-01-27  Paul Thomas  <pault@gcc.gnu.org>\n+\t    Tobias Burnus <burnus@gcc.gnu.org>\n+\n+\tPR fortran/48705\n+\tPR fortran/51870\n+\tPR fortran/51943\n+\tPR fortran/51946\n+\t* trans-array.c (gfc_array_init_size): Add two extra arguments\n+\tto convey the dynamic element size of a calls object and to\n+\treturn the number of elements that have been allocated.\n+\t(gfc_array_allocate): Add the same arguments and use them to\n+\tcall gfc_array_init_size.  Before the allocation dereference\n+\tthe data pointer, if necessary. Set the allocated array to zero\n+\tif the class element size or expr3 are non-null.\n+\t* trans-expr.c (gfc_conv_class_to_class): Give this function\n+\tglobal scope.\n+\t(get_class_array_ref): New function.\n+\t(gfc_copy_class_to_class): New function.\n+\t* trans-array.h : Update prototype for gfc_array_allocate.\n+\t* trans-stmt.c (gfc_trans_allocate): For non-variable class\n+\tSTATUS expressions extract the class object and the dynamic\n+\telement size. Use the latter to call gfc_array_allocate and\n+\tthe former for setting the vptr and, via\n+\tgfc_copy_class_to_clasfc_cs, to copy to the allocated data.\n+\t* trans.h : Prototypes for gfc_get_class_array_ref,\n+\tgfc_copy_class_to_class and gfc_conv_class_to_class.\n+  \n 2012-01-25  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/51995"}, {"sha": "b8516afc5346cc4bb00df423595ad8f98a994cc9", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4daa71b06377971c08341ff1664438de55dd5603/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4daa71b06377971c08341ff1664438de55dd5603/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=4daa71b06377971c08341ff1664438de55dd5603", "patch": "@@ -4719,7 +4719,7 @@ static tree\n gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n \t\t     gfc_expr ** lower, gfc_expr ** upper, stmtblock_t * pblock,\n \t\t     stmtblock_t * descriptor_block, tree * overflow,\n-\t\t     gfc_expr *expr3)\n+\t\t     tree expr3_elem_size, tree *nelems, gfc_expr *expr3)\n {\n   tree type;\n   tree tmp;\n@@ -4876,7 +4876,9 @@ gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n   /* The stride is the number of elements in the array, so multiply by the\n      size of an element to get the total size.  Obviously, if there ia a\n      SOURCE expression (expr3) we must use its element size.  */\n-  if (expr3 != NULL)\n+  if (expr3_elem_size != NULL_TREE)\n+    tmp = expr3_elem_size;\n+  else if (expr3 != NULL)\n     {\n       if (expr3->ts.type == BT_CLASS)\n \t{\n@@ -4904,6 +4906,7 @@ gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n   if (rank == 0)\n     return element_size;\n \n+  *nelems = gfc_evaluate_now (stride, pblock);\n   stride = fold_convert (size_type_node, stride);\n \n   /* First check for overflow. Since an array of type character can\n@@ -4962,7 +4965,8 @@ gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n \n bool\n gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n-\t\t    tree errlen, tree label_finish, gfc_expr *expr3)\n+\t\t    tree errlen, tree label_finish, tree expr3_elem_size,\n+\t\t    tree *nelems, gfc_expr *expr3)\n {\n   tree tmp;\n   tree pointer;\n@@ -5047,7 +5051,7 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n   size = gfc_array_init_size (se->expr, ref->u.ar.as->rank,\n \t\t\t      ref->u.ar.as->corank, &offset, lower, upper,\n \t\t\t      &se->pre, &set_descriptor_block, &overflow,\n-\t\t\t      expr3);\n+\t\t\t      expr3_elem_size, nelems, expr3);\n \n   if (dimension)\n     {\n@@ -5078,6 +5082,9 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n   gfc_start_block (&elseblock);\n \n   /* Allocate memory to store the data.  */\n+  if (POINTER_TYPE_P (TREE_TYPE (se->expr)))\n+    se->expr = build_fold_indirect_ref_loc (input_location, se->expr);\n+\n   pointer = gfc_conv_descriptor_data_get (se->expr);\n   STRIP_NOPS (pointer);\n \n@@ -5104,7 +5111,8 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n \n   gfc_add_expr_to_block (&se->pre, tmp);\n \n-  if (expr->ts.type == BT_CLASS && expr3)\n+  if (expr->ts.type == BT_CLASS\n+\t&& (expr3_elem_size != NULL_TREE || expr3))\n     {\n       tmp = build_int_cst (unsigned_char_type_node, 0);\n       /* With class objects, it is best to play safe and null the "}, {"sha": "6ca630e9ed91fa750c9c37ff4fd458d042dca966", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4daa71b06377971c08341ff1664438de55dd5603/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4daa71b06377971c08341ff1664438de55dd5603/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=4daa71b06377971c08341ff1664438de55dd5603", "patch": "@@ -25,7 +25,7 @@ tree gfc_array_deallocate (tree, tree, tree, tree, tree, gfc_expr*);\n /* Generate code to initialize and allocate an array.  Statements are added to\n    se, which should contain an expression for the array descriptor.  */\n bool gfc_array_allocate (gfc_se *, gfc_expr *, tree, tree, tree, tree,\n-\t\t\t gfc_expr *);\n+\t\t\t tree, tree *, gfc_expr *);\n \n /* Allow the bounds of a loop to be set from a callee's array spec.  */\n void gfc_set_loop_bounds_from_array_spec (gfc_interface_mapping *,"}, {"sha": "250f30fa41b33afc9891209fbb5564a50e231172", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 104, "deletions": 1, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4daa71b06377971c08341ff1664438de55dd5603/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4daa71b06377971c08341ff1664438de55dd5603/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=4daa71b06377971c08341ff1664438de55dd5603", "patch": "@@ -215,7 +215,7 @@ gfc_conv_derived_to_class (gfc_se *parmse, gfc_expr *e,\n    OOP-TODO: This could be improved by adding code that branched on\n    the dynamic type being the same as the declared type. In this case\n    the original class expression can be passed directly.  */ \n-static void\n+void\n gfc_conv_class_to_class (gfc_se *parmse, gfc_expr *e,\n \t\t\t gfc_typespec class_ts, bool elemental)\n {\n@@ -303,6 +303,109 @@ gfc_conv_class_to_class (gfc_se *parmse, gfc_expr *e,\n }\n \n \n+/* Given a class array declaration and an index, returns the address\n+   of the referenced element.  */\n+\n+tree\n+gfc_get_class_array_ref (tree index, tree class_decl)\n+{\n+  tree data = gfc_class_data_get (class_decl);\n+  tree size = gfc_vtable_size_get (class_decl);\n+  tree offset = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t gfc_array_index_type,\n+\t\t\t\t index, size);\n+  tree ptr;\n+  data = gfc_conv_descriptor_data_get (data);\n+  ptr = fold_convert (pvoid_type_node, data);\n+  ptr = fold_build_pointer_plus_loc (input_location, ptr, offset);\n+  return fold_convert (TREE_TYPE (data), ptr);\n+}\n+\n+\n+/* Copies one class expression to another, assuming that if either\n+   'to' or 'from' are arrays they are packed.  Should 'from' be\n+   NULL_TREE, the inialization expression for 'to' is used, assuming\n+   that the _vptr is set.  */\n+\n+tree\n+gfc_copy_class_to_class (tree from, tree to, tree nelems)\n+{\n+  tree fcn;\n+  tree fcn_type;\n+  tree from_data;\n+  tree to_data;\n+  tree to_ref;\n+  tree from_ref;\n+  VEC(tree,gc) *args;\n+  tree tmp;\n+  tree index;\n+  stmtblock_t loopbody;\n+  stmtblock_t body;\n+  gfc_loopinfo loop;\n+\n+  args = NULL;\n+\n+  if (from != NULL_TREE)\n+    fcn = gfc_vtable_copy_get (from);\n+  else\n+    fcn = gfc_vtable_copy_get (to);\n+\n+  fcn_type = TREE_TYPE (TREE_TYPE (fcn));\n+\n+  if (from != NULL_TREE)\n+    from_data = gfc_class_data_get (from);\n+  else\n+    from_data = gfc_vtable_def_init_get (to);\n+\n+  to_data = gfc_class_data_get (to);\n+\n+  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (to_data)))\n+    {\n+      gfc_init_block (&body);\n+      tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t     gfc_array_index_type, nelems,\n+\t\t\t     gfc_index_one_node);\n+      nelems = gfc_evaluate_now (tmp, &body);\n+      index = gfc_create_var (gfc_array_index_type, \"S\");\n+\n+      if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (from_data)))\n+\t{\n+\t  from_ref = gfc_get_class_array_ref (index, from);\n+\t  VEC_safe_push (tree, gc, args, from_ref);\n+\t}\n+      else\n+        VEC_safe_push (tree, gc, args, from_data);\n+\n+      to_ref = gfc_get_class_array_ref (index, to);\n+      VEC_safe_push (tree, gc, args, to_ref);\n+\n+      tmp = build_call_vec (fcn_type, fcn, args);\n+\n+      /* Build the body of the loop.  */\n+      gfc_init_block (&loopbody);\n+      gfc_add_expr_to_block (&loopbody, tmp);\n+\n+      /* Build the loop and return.  */\n+      gfc_init_loopinfo (&loop);\n+      loop.dimen = 1;\n+      loop.from[0] = gfc_index_zero_node;\n+      loop.loopvar[0] = index;\n+      loop.to[0] = nelems;\n+      gfc_trans_scalarizing_loops (&loop, &loopbody);\n+      gfc_add_block_to_block (&body, &loop.pre);\n+      tmp = gfc_finish_block (&body);\n+    }\n+  else\n+    {\n+      gcc_assert (!GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (from_data)));\n+      VEC_safe_push (tree, gc, args, from_data);\n+      VEC_safe_push (tree, gc, args, to_data);\n+      tmp = build_call_vec (fcn_type, fcn, args);\n+    }\n+\n+  return tmp;\n+}\n+\n static tree\n gfc_trans_class_array_init_assign (gfc_expr *rhs, gfc_expr *lhs, gfc_expr *obj)\n {"}, {"sha": "19a8e7af42908574776c0d1f487378a0455f2054", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 61, "deletions": 21, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4daa71b06377971c08341ff1664438de55dd5603/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4daa71b06377971c08341ff1664438de55dd5603/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=4daa71b06377971c08341ff1664438de55dd5603", "patch": "@@ -4740,6 +4740,10 @@ gfc_trans_allocate (gfc_code * code)\n   stmtblock_t post;\n   gfc_expr *sz;\n   gfc_se se_sz;\n+  tree class_expr;\n+  tree nelems;\n+  tree memsize = NULL_TREE;\n+  tree classexpr = NULL_TREE;\n \n   if (!code->ext.alloc.list)\n     return NULL_TREE;\n@@ -4794,13 +4798,39 @@ gfc_trans_allocate (gfc_code * code)\n       se.descriptor_only = 1;\n       gfc_conv_expr (&se, expr);\n \n+      /* Evaluate expr3 just once if not a variable.  */\n+      if (al == code->ext.alloc.list\n+\t    && al->expr->ts.type == BT_CLASS\n+\t    && code->expr3\n+\t    && code->expr3->ts.type == BT_CLASS\n+\t    && code->expr3->expr_type != EXPR_VARIABLE)\n+\t{\n+\t  gfc_init_se (&se_sz, NULL);\n+\t  gfc_conv_expr_reference (&se_sz, code->expr3);\n+\t  gfc_conv_class_to_class (&se_sz, code->expr3,\n+\t\t\t\t   code->expr3->ts, false);\n+\t  gfc_add_block_to_block (&se.pre, &se_sz.pre);\n+\t  gfc_add_block_to_block (&se.post, &se_sz.post);\n+\t  classexpr = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t\t   se_sz.expr);\n+\t  classexpr = gfc_evaluate_now (classexpr, &se.pre);\n+\t  memsize = gfc_vtable_size_get (classexpr);\n+\t  memsize = fold_convert (sizetype, memsize);\n+\t}\n+\n+      memsz = memsize;\n+      class_expr = classexpr;\n+\n+      nelems = NULL_TREE;\n       if (!gfc_array_allocate (&se, expr, stat, errmsg, errlen, label_finish,\n-\t\t\t       code->expr3))\n+\t\t\t       memsz, &nelems, code->expr3))\n \t{\n \t  /* A scalar or derived type.  */\n \n \t  /* Determine allocate size.  */\n-\t  if (al->expr->ts.type == BT_CLASS && code->expr3)\n+\t  if (al->expr->ts.type == BT_CLASS\n+\t\t&& code->expr3\n+\t\t&& memsz == NULL_TREE)\n \t    {\n \t      if (code->expr3->ts.type == BT_CLASS)\n \t\t{\n@@ -4897,7 +4927,7 @@ gfc_trans_allocate (gfc_code * code)\n \t    }\n \t  else if (code->ext.alloc.ts.type != BT_UNKNOWN)\n \t    memsz = TYPE_SIZE_UNIT (gfc_typenode_for_spec (&code->ext.alloc.ts));\n-\t  else\n+\t  else if (memsz == NULL_TREE)\n \t    memsz = TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (se.expr)));\n \n \t  if (expr->ts.type == BT_CHARACTER && memsz == NULL_TREE)\n@@ -4956,13 +4986,23 @@ gfc_trans_allocate (gfc_code * code)\n       e = gfc_copy_expr (al->expr);\n       if (e->ts.type == BT_CLASS)\n \t{\n-\t  gfc_expr *lhs,*rhs;\n+\t  gfc_expr *lhs, *rhs;\n \t  gfc_se lse;\n \n \t  lhs = gfc_expr_to_initialize (e);\n \t  gfc_add_vptr_component (lhs);\n-\t  rhs = NULL;\n-\t  if (code->expr3 && code->expr3->ts.type == BT_CLASS)\n+\n+\t  if (class_expr != NULL_TREE)\n+\t    {\n+\t      /* Polymorphic SOURCE: VPTR must be determined at run time.  */\n+\t      gfc_init_se (&lse, NULL);\n+\t      lse.want_pointer = 1;\n+\t      gfc_conv_expr (&lse, lhs);\n+\t      tmp = gfc_class_vptr_get (class_expr);\n+\t      gfc_add_modify (&block, lse.expr,\n+\t\t\tfold_convert (TREE_TYPE (lse.expr), tmp));\n+\t    }\n+\t  else if (code->expr3 && code->expr3->ts.type == BT_CLASS)\n \t    {\n \t      /* Polymorphic SOURCE: VPTR must be determined at run time.  */\n \t      rhs = gfc_copy_expr (code->expr3);\n@@ -5011,7 +5051,14 @@ gfc_trans_allocate (gfc_code * code)\n \t  /* Initialization via SOURCE block\n \t     (or static default initializer).  */\n \t  gfc_expr *rhs = gfc_copy_expr (code->expr3);\n-\t  if (al->expr->ts.type == BT_CLASS)\n+\t  if (class_expr != NULL_TREE)\n+\t    {\n+\t      tree to;\n+\t      to = TREE_OPERAND (se.expr, 0);\n+\n+\t      tmp = gfc_copy_class_to_class (class_expr, to, nelems);\n+\t    }\n+\t  else if (al->expr->ts.type == BT_CLASS)\n \t    {\n \t      gfc_actual_arglist *actual;\n \t      gfc_expr *ppc;\n@@ -5098,25 +5145,18 @@ gfc_trans_allocate (gfc_code * code)\n \t  gfc_free_expr (rhs);\n \t  gfc_add_expr_to_block (&block, tmp);\n \t}\n-      else if (code->expr3 && code->expr3->mold\n+     else if (code->expr3 && code->expr3->mold\n \t    && code->expr3->ts.type == BT_CLASS)\n \t{\n-\t  /* Default-initialization via MOLD (polymorphic).  */\n-\t  gfc_expr *rhs = gfc_copy_expr (code->expr3);\n-\t  gfc_se dst,src;\n-\t  gfc_add_vptr_component (rhs);\n-\t  gfc_add_def_init_component (rhs);\n-\t  gfc_init_se (&dst, NULL);\n-\t  gfc_init_se (&src, NULL);\n-\t  gfc_conv_expr (&dst, expr);\n-\t  gfc_conv_expr (&src, rhs);\n-\t  gfc_add_block_to_block (&block, &src.pre);\n-\t  tmp = gfc_build_memcpy_call (dst.expr, src.expr, memsz);\n+\t  /* Since the _vptr has already been assigned to the allocate\n+\t     object, we can use gfc_copy_class_to_class in its\n+\t     initialization mode.  */\n+\t  tmp = TREE_OPERAND (se.expr, 0);\n+\t  tmp = gfc_copy_class_to_class (NULL_TREE, tmp, nelems);\n \t  gfc_add_expr_to_block (&block, tmp);\n-\t  gfc_free_expr (rhs);\n \t}\n \n-      gfc_free_expr (expr);\n+       gfc_free_expr (expr);\n     }\n \n   /* STAT.  */"}, {"sha": "e685a84c388154156e97865373d6c3b6e20f66ac", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4daa71b06377971c08341ff1664438de55dd5603/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4daa71b06377971c08341ff1664438de55dd5603/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=4daa71b06377971c08341ff1664438de55dd5603", "patch": "@@ -346,6 +346,9 @@ tree gfc_vtable_size_get (tree);\n tree gfc_vtable_extends_get (tree);\n tree gfc_vtable_def_init_get (tree);\n tree gfc_vtable_copy_get (tree);\n+tree gfc_get_class_array_ref (tree, tree);\n+tree gfc_copy_class_to_class (tree, tree, tree);\n+void gfc_conv_class_to_class (gfc_se *, gfc_expr *, gfc_typespec, bool);\n \n /* Initialize an init/cleanup block.  */\n void gfc_start_wrapped_block (gfc_wrapped_block* block, tree code);"}, {"sha": "f08fb6c656154aff271a37469cefdd9dac691113", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4daa71b06377971c08341ff1664438de55dd5603/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4daa71b06377971c08341ff1664438de55dd5603/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4daa71b06377971c08341ff1664438de55dd5603", "patch": "@@ -1,3 +1,17 @@\n+2012-01-27  Paul Thomas  <pault@gcc.gnu.org>\n+\t    Tobias Burnus <burnus@gcc.gnu.org>\n+\n+\tPR fortran/48705\n+\t* gfortran.dg/class_allocate_11.f03: New.\n+\n+\tPR fortran/51870\n+\tPR fortran/51943\n+\tPR fortran/51946\n+\t* gfortran.dg/class_allocate_7.f03: New.\n+\t* gfortran.dg/class_allocate_8.f03: New.\n+\t* gfortran.dg/class_allocate_9.f03: New.\n+\t* gfortran.dg/class_allocate_10.f03: New.\n+\n 2012-01-27  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/discr34.adb: New test."}, {"sha": "d3afa395ec9f468cbc7f2e43996acb649caf9ef9", "filename": "gcc/testsuite/gfortran.dg/class_allocate_10.f03", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4daa71b06377971c08341ff1664438de55dd5603/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_allocate_10.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4daa71b06377971c08341ff1664438de55dd5603/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_allocate_10.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_allocate_10.f03?ref=4daa71b06377971c08341ff1664438de55dd5603", "patch": "@@ -0,0 +1,64 @@\n+! { dg-do run }\n+! PR51870 - ALLOCATE with class function expression for SOURCE failed.\n+! This version of the test allocates class arrays with MOLD.\n+!\n+! Reported by Tobias Burnus  <burnus@gcc.gnu.org>\n+!\n+module show_producer_class\n+  implicit none\n+  type integrand\n+    integer :: variable = 1\n+  end type integrand\n+\n+  type show_producer\n+  contains\n+    procedure ,nopass :: create_show\n+    procedure ,nopass :: create_show_array\n+  end type\n+contains\n+  function create_show () result(new_integrand)\n+    class(integrand) ,allocatable :: new_integrand\n+    allocate(new_integrand)\n+    new_integrand%variable = -1\n+  end function\n+  function create_show_array (n) result(new_integrand)\n+    class(integrand) ,allocatable :: new_integrand(:)\n+    integer :: n, i\n+    allocate(new_integrand(n))\n+    select type (new_integrand)\n+      type is (integrand); new_integrand%variable = [(i, i= 1, n)]\n+    end select\n+  end function\n+end module\n+\n+program main\n+  use show_producer_class\n+  implicit none\n+  class(integrand) ,allocatable :: kernel1(:), kernel2(:)\n+  type(show_producer) :: executive_producer\n+\n+  allocate(kernel1(5), kernel2(5),mold=executive_producer%create_show_array (5))\n+  select type(kernel1)\n+    type is (integrand);  if (any (kernel1%variable .ne. 1)) call abort\n+  end select\n+\n+  deallocate (kernel1)\n+\n+  allocate(kernel1(3),mold=executive_producer%create_show ())\n+  select type(kernel1)\n+    type is (integrand); if (any (kernel1%variable .ne. 1)) call abort\n+  end select\n+\n+  deallocate (kernel1)\n+\n+  select type(kernel2)\n+    type is (integrand); kernel2%variable = [1,2,3,4,5]\n+  end select\n+\n+  allocate(kernel1(3),source = kernel2(3:5))\n+  select type(kernel1)\n+    type is (integrand); if (any (kernel1%variable .ne. [3,4,5])) call abort\n+  end select\n+end program\n+! { dg-final { cleanup-modules \"show_producer_class\" } }\n+"}, {"sha": "e36e810aba82e7988e3b15cec32cb7c678532d24", "filename": "gcc/testsuite/gfortran.dg/class_allocate_11.f03", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4daa71b06377971c08341ff1664438de55dd5603/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_allocate_11.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4daa71b06377971c08341ff1664438de55dd5603/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_allocate_11.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_allocate_11.f03?ref=4daa71b06377971c08341ff1664438de55dd5603", "patch": "@@ -0,0 +1,62 @@\n+! { dg-do run }\n+! PR48705 - ALLOCATE with class function expression for SOURCE failed.\n+! This is the original test in the PR.\n+!\n+! Reported by Tobias Burnus  <burnus@gcc.gnu.org>\n+!\n+module generic_deferred\n+  implicit none\n+  type, abstract :: addable\n+  contains\n+    private\n+    procedure(add), deferred :: a\n+    generic, public :: operator(+) => a \n+  end type addable\n+  abstract interface\n+    function add(x, y) result(res)\n+      import :: addable\n+      class(addable), intent(in) :: x, y\n+      class(addable), allocatable :: res\n+    end function add\n+  end interface\n+  type, extends(addable) :: vec\n+    integer :: i(2)\n+  contains\n+    procedure :: a => a_vec\n+  end type\n+contains\n+  function a_vec(x, y) result(res)\n+    class(vec), intent(in) :: x\n+    class(addable), intent(in) :: y\n+    class(addable), allocatable :: res\n+    integer :: ii(2)\n+    select type(y)\n+    class is (vec)\n+      ii = y%i\n+    end select \n+    allocate(vec :: res)\n+    select type(res)\n+    type is (vec)\n+       res%i = x%i + ii\n+    end select\n+  end function\n+end module generic_deferred\n+program prog\n+  use generic_deferred\n+  implicit none\n+  type(vec) :: x, y\n+  class(addable), allocatable :: z\n+!  x = vec( (/1,2/) );   y = vec( (/2,-2/) )\n+  x%i = (/1,2/); y%i = (/2,-2/)\n+  allocate(z, source= x + y)\n+  select type(z)\n+  type is(vec)\n+     if (z%i(1) /= 3 .or. z%i(2) /= 0) then\n+        write(*,*) 'FAIL'\n+     else\n+        write(*,*) 'OK'\n+     end if\n+  end select\n+end program prog\n+! { dg-final { cleanup-modules \"generic_deferred\" } }\n+"}, {"sha": "ddab4073dec9be88873e86c59119a5e64985a2e3", "filename": "gcc/testsuite/gfortran.dg/class_allocate_7.f03", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4daa71b06377971c08341ff1664438de55dd5603/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_allocate_7.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4daa71b06377971c08341ff1664438de55dd5603/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_allocate_7.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_allocate_7.f03?ref=4daa71b06377971c08341ff1664438de55dd5603", "patch": "@@ -0,0 +1,35 @@\n+! { dg-do run }\n+! PR51870 - ALLOCATE with class function expression for SOURCE failed.\n+! This is the original test in the PR.\n+!\n+! Reported by Tobias Burnus  <burnus@gcc.gnu.org>\n+!\n+module show_producer_class\n+  implicit none\n+  type integrand\n+    integer :: variable = -1\n+  end type integrand\n+\n+  type show_producer\n+  contains\n+    procedure ,nopass :: create_show\n+  end type\n+contains\n+  function create_show () result(new_integrand)\n+    class(integrand) ,allocatable :: new_integrand\n+    allocate(new_integrand)\n+    new_integrand%variable = 99\n+  end function\n+end module\n+\n+program main\n+  use show_producer_class\n+  implicit none\n+  class(integrand) ,allocatable :: kernel\n+  type(show_producer) :: executive_producer\n+\n+  allocate(kernel,source=executive_producer%create_show ())\n+  if (kernel%variable .ne. 99) call abort\n+end program\n+! { dg-final { cleanup-modules \"show_producer_class\" } }\n+"}, {"sha": "85094ad1fe07e797073fe42440422ab03a9383ae", "filename": "gcc/testsuite/gfortran.dg/class_allocate_8.f03", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4daa71b06377971c08341ff1664438de55dd5603/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_allocate_8.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4daa71b06377971c08341ff1664438de55dd5603/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_allocate_8.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_allocate_8.f03?ref=4daa71b06377971c08341ff1664438de55dd5603", "patch": "@@ -0,0 +1,53 @@\n+! { dg-do run }\n+! PR51870 - ALLOCATE with class function expression for SOURCE failed.\n+! This version of the test allocates class arrays.\n+!\n+! Reported by Tobias Burnus  <burnus@gcc.gnu.org>\n+!\n+module show_producer_class\n+  implicit none\n+  type integrand\n+    integer :: variable = 0\n+  end type integrand\n+\n+  type show_producer\n+  contains\n+    procedure ,nopass :: create_show\n+    procedure ,nopass :: create_show_array\n+  end type\n+contains\n+  function create_show () result(new_integrand)\n+    class(integrand) ,allocatable :: new_integrand\n+    allocate(new_integrand)\n+    new_integrand%variable = -1\n+  end function\n+  function create_show_array (n) result(new_integrand)\n+    class(integrand) ,allocatable :: new_integrand(:)\n+    integer :: n, i\n+    allocate(new_integrand(n))\n+    select type (new_integrand)\n+      type is (integrand); new_integrand%variable = [(i, i= 1, n)]\n+    end select\n+  end function\n+end module\n+\n+program main\n+  use show_producer_class\n+  implicit none\n+  class(integrand) ,allocatable :: kernel(:)\n+  type(show_producer) :: executive_producer\n+\n+  allocate(kernel(5),source=executive_producer%create_show_array (5))\n+  select type(kernel)\n+    type is (integrand);  if (any (kernel%variable .ne. [1,2,3,4,5])) call abort\n+  end select\n+\n+  deallocate (kernel)\n+\n+  allocate(kernel(3),source=executive_producer%create_show ())\n+  select type(kernel)\n+    type is (integrand); if (any (kernel%variable .ne. -1)) call abort\n+  end select\n+end program\n+! { dg-final { cleanup-modules \"show_producer_class\" } }\n+"}, {"sha": "2446ed61413ee44a495e11c79b03cfe9938217a5", "filename": "gcc/testsuite/gfortran.dg/class_allocate_9.f03", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4daa71b06377971c08341ff1664438de55dd5603/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_allocate_9.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4daa71b06377971c08341ff1664438de55dd5603/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_allocate_9.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_allocate_9.f03?ref=4daa71b06377971c08341ff1664438de55dd5603", "patch": "@@ -0,0 +1,36 @@\n+! { dg-do run }\n+! PR51870 - ALLOCATE with class function expression for SOURCE failed.\n+! This is the original test in the PR.\n+!\n+! Reported by Tobias Burnus  <burnus@gcc.gnu.org>\n+!\n+module show_producer_class\n+  implicit none\n+  type integrand\n+    integer :: variable = -1\n+  end type integrand\n+\n+  type show_producer\n+  contains\n+    procedure ,nopass :: create_show\n+  end type\n+contains\n+  function create_show () result(new_integrand)\n+    class(integrand) ,allocatable :: new_integrand\n+    allocate(new_integrand)\n+    new_integrand%variable = 99\n+  end function\n+end module\n+\n+program main\n+  use show_producer_class\n+  implicit none\n+  class(integrand) ,allocatable :: kernel1, kernel2\n+  type(show_producer) :: executive_producer\n+\n+  allocate(kernel1, kernel2,mold=executive_producer%create_show ())\n+  if (kernel1%variable .ne. -1) call abort\n+  if (kernel2%variable .ne. -1) call abort\n+end program\n+! { dg-final { cleanup-modules \"show_producer_class\" } }\n+"}]}