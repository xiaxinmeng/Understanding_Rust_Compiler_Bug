{"sha": "22fb24d53aed6842ccf44df69f772728b655b444", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjJmYjI0ZDUzYWVkNjg0MmNjZjQ0ZGY2OWY3NzI3MjhiNjU1YjQ0NA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernd.schmidt@analog.com", "date": "2008-09-09T12:09:37Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2008-09-09T12:09:37Z"}, "message": "bfin.c (n_regs_to_save): New static variable.\n\n\t* config/bfin/bfin.c (n_regs_to_save): New static variable.\n\t(push_multiple_operation, pop_multiple_operation): Set it.\n\t(workaround_rts_anomaly): New function.\n\t(workaround_speculation): New function, broken out of bfin_reorg.\n\t(bfin_reorg): Call the new functions.\n\nFrom-SVN: r140146", "tree": {"sha": "10a13d861c90978f2a53cd77524cbdfd5ae74b71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/10a13d861c90978f2a53cd77524cbdfd5ae74b71"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/22fb24d53aed6842ccf44df69f772728b655b444", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22fb24d53aed6842ccf44df69f772728b655b444", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22fb24d53aed6842ccf44df69f772728b655b444", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22fb24d53aed6842ccf44df69f772728b655b444/comments", "author": null, "committer": null, "parents": [{"sha": "8b17cc05d37f88ce76e53f22734042f7eed0b332", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b17cc05d37f88ce76e53f22734042f7eed0b332", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b17cc05d37f88ce76e53f22734042f7eed0b332"}], "stats": {"total": 195, "additions": 146, "deletions": 49}, "files": [{"sha": "86087a374cbd391c3c94158b4e366b010c3dbee9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fb24d53aed6842ccf44df69f772728b655b444/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fb24d53aed6842ccf44df69f772728b655b444/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=22fb24d53aed6842ccf44df69f772728b655b444", "patch": "@@ -1,3 +1,11 @@\n+2008-09-09  Bernd Schmidt  <bernd.schmidt@analog.com>\n+\n+\t* config/bfin/bfin.c (n_regs_to_save): New static variable.\n+\t(push_multiple_operation, pop_multiple_operation): Set it.\n+\t(workaround_rts_anomaly): New function.\n+\t(workaround_speculation): New function, broken out of bfin_reorg.\n+\t(bfin_reorg): Call the new functions.\n+\n 2008-09-09  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/37354"}, {"sha": "7ff1379f2c9f4e9a37628a6bd5928525eb97c471", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 138, "deletions": 49, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fb24d53aed6842ccf44df69f772728b655b444/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fb24d53aed6842ccf44df69f772728b655b444/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=22fb24d53aed6842ccf44df69f772728b655b444", "patch": "@@ -3100,6 +3100,7 @@ bfin_rtx_costs (rtx x, int code, int outer_code, int *total, bool speed)\n /* Used for communication between {push,pop}_multiple_operation (which\n    we use not only as a predicate) and the corresponding output functions.  */\n static int first_preg_to_save, first_dreg_to_save;\n+static int n_regs_to_save;\n \n int\n push_multiple_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n@@ -3168,6 +3169,7 @@ push_multiple_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n \t  lastpreg++;\n \t}\n     }\n+  n_regs_to_save = 8 - first_dreg_to_save + 6 - first_preg_to_save;\n   return 1;\n }\n \n@@ -3227,6 +3229,7 @@ pop_multiple_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n     }\n   first_dreg_to_save = lastdreg;\n   first_preg_to_save = lastpreg;\n+  n_regs_to_save = 8 - first_dreg_to_save + 6 - first_preg_to_save;\n   return 1;\n }\n \n@@ -4631,6 +4634,85 @@ reorder_var_tracking_notes (void)\n     }\n }\n \f\n+/* On some silicon revisions, functions shorter than a certain number of cycles\n+   can cause unpredictable behaviour.  Work around this by adding NOPs as\n+   needed.  */\n+static void\n+workaround_rts_anomaly (void)\n+{\n+  rtx insn, first_insn = NULL_RTX;\n+  int cycles = 4;\n+\n+  if (! ENABLE_WA_RETS)\n+    return;\n+\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    {\n+      rtx pat;\n+\n+      if (BARRIER_P (insn))\n+\treturn;\n+      \n+      if (NOTE_P (insn) || LABEL_P (insn))\n+\tcontinue;\n+\n+      if (first_insn == NULL_RTX)\n+\tfirst_insn = insn;\n+      pat = PATTERN (insn);\n+      if (GET_CODE (pat) == USE || GET_CODE (pat) == CLOBBER\n+\t  || GET_CODE (pat) == ASM_INPUT || GET_CODE (pat) == ADDR_VEC\n+\t  || GET_CODE (pat) == ADDR_DIFF_VEC || asm_noperands (pat) >= 0)\n+\tcontinue;\n+\n+      if (CALL_P (insn))\n+\treturn;\n+\n+      if (JUMP_P (insn))\n+\t{\n+\t  if (recog_memoized (insn) == CODE_FOR_return_internal)\n+\t    break;\n+\n+\t  /* Nothing to worry about for direct jumps.  */\n+\t  if (!any_condjump_p (insn))\n+\t    return;\n+\t  if (cycles <= 1)\n+\t    return;\n+\t  cycles--;\n+\t}\n+      else if (INSN_P (insn))\n+\t{\n+\t  rtx pat = PATTERN (insn);\n+\t  int this_cycles = 1;\n+\n+\t  if (GET_CODE (pat) == PARALLEL)\n+\t    {\n+\t      if (push_multiple_operation (pat, VOIDmode)\n+\t\t  || pop_multiple_operation (pat, VOIDmode))\n+\t\tthis_cycles = n_regs_to_save;\n+\t    }\n+\t  else\n+\t    {\n+\t      enum insn_code icode = recog_memoized (insn);\n+\t      if (icode == CODE_FOR_link)\n+\t\tthis_cycles = 4;\n+\t      else if (icode == CODE_FOR_unlink)\n+\t\tthis_cycles = 3;\n+\t      else if (icode == CODE_FOR_mulsi3)\n+\t\tthis_cycles = 5;\n+\t    }\n+\t  if (this_cycles >= cycles)\n+\t    return;\n+\n+\t  cycles -= this_cycles;\n+\t}\n+    }\n+  while (cycles > 0)\n+    {\n+      emit_insn_before (gen_nop (), first_insn);\n+      cycles--;\n+    }\n+}\n+\n /* Return an insn type for INSN that can be used by the caller for anomaly\n    workarounds.  This differs from plain get_attr_type in that it handles\n    SEQUENCEs.  */\n@@ -4711,58 +4793,13 @@ find_load (rtx insn)\n   return NULL_RTX;\n }\n \n-/* We use the machine specific reorg pass for emitting CSYNC instructions\n-   after conditional branches as needed.\n-\n-   The Blackfin is unusual in that a code sequence like\n-     if cc jump label\n-     r0 = (p0)\n-   may speculatively perform the load even if the condition isn't true.  This\n-   happens for a branch that is predicted not taken, because the pipeline\n-   isn't flushed or stalled, so the early stages of the following instructions,\n-   which perform the memory reference, are allowed to execute before the\n-   jump condition is evaluated.\n-   Therefore, we must insert additional instructions in all places where this\n-   could lead to incorrect behavior.  The manual recommends CSYNC, while\n-   VDSP seems to use NOPs (even though its corresponding compiler option is\n-   named CSYNC).\n-\n-   When optimizing for speed, we emit NOPs, which seems faster than a CSYNC.\n-   When optimizing for size, we turn the branch into a predicted taken one.\n-   This may be slower due to mispredicts, but saves code size.  */\n-\n static void\n-bfin_reorg (void)\n+workaround_speculation (void)\n {\n   rtx insn, next;\n   rtx last_condjump = NULL_RTX;\n   int cycles_since_jump = INT_MAX;\n \n-  /* We are freeing block_for_insn in the toplev to keep compatibility\n-     with old MDEP_REORGS that are not CFG based.  Recompute it now.  */\n-  compute_bb_for_insn ();\n-\n-  if (bfin_flag_schedule_insns2)\n-    {\n-      splitting_for_sched = 1;\n-      split_all_insns ();\n-      splitting_for_sched = 0;\n-\n-      timevar_push (TV_SCHED2);\n-      schedule_insns ();\n-      timevar_pop (TV_SCHED2);\n-\n-      /* Examine the schedule and insert nops as necessary for 64-bit parallel\n-\t instructions.  */\n-      bfin_gen_bundles ();\n-    }\n-\n-  df_analyze ();\n-\n-  /* Doloop optimization */\n-  if (cfun->machine->has_hardware_loops)\n-    bfin_reorg_loops (dump_file);\n-\n   if (! ENABLE_WA_SPECULATIVE_LOADS && ! ENABLE_WA_SPECULATIVE_SYNCS)\n     return;\n \n@@ -4841,11 +4878,9 @@ bfin_reorg (void)\n   if (! ENABLE_WA_SPECULATIVE_SYNCS)\n     return;\n \n-  if (! ENABLE_WA_RETS)\n-    return;\n-\n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n+      int cycles_since_jump;\n       if (JUMP_P (insn)\n \t  && any_condjump_p (insn)\n \t  && (INSN_CODE (insn) == CODE_FOR_cbranch_predicted_taken\n@@ -4907,6 +4942,57 @@ bfin_reorg (void)\n \t    }\n \t}\n     }\n+}\n+\n+/* We use the machine specific reorg pass for emitting CSYNC instructions\n+   after conditional branches as needed.\n+\n+   The Blackfin is unusual in that a code sequence like\n+     if cc jump label\n+     r0 = (p0)\n+   may speculatively perform the load even if the condition isn't true.  This\n+   happens for a branch that is predicted not taken, because the pipeline\n+   isn't flushed or stalled, so the early stages of the following instructions,\n+   which perform the memory reference, are allowed to execute before the\n+   jump condition is evaluated.\n+   Therefore, we must insert additional instructions in all places where this\n+   could lead to incorrect behavior.  The manual recommends CSYNC, while\n+   VDSP seems to use NOPs (even though its corresponding compiler option is\n+   named CSYNC).\n+\n+   When optimizing for speed, we emit NOPs, which seems faster than a CSYNC.\n+   When optimizing for size, we turn the branch into a predicted taken one.\n+   This may be slower due to mispredicts, but saves code size.  */\n+\n+static void\n+bfin_reorg (void)\n+{\n+  /* We are freeing block_for_insn in the toplev to keep compatibility\n+     with old MDEP_REORGS that are not CFG based.  Recompute it now.  */\n+  compute_bb_for_insn ();\n+\n+  if (bfin_flag_schedule_insns2)\n+    {\n+      splitting_for_sched = 1;\n+      split_all_insns ();\n+      splitting_for_sched = 0;\n+\n+      timevar_push (TV_SCHED2);\n+      schedule_insns ();\n+      timevar_pop (TV_SCHED2);\n+\n+      /* Examine the schedule and insert nops as necessary for 64-bit parallel\n+\t instructions.  */\n+      bfin_gen_bundles ();\n+    }\n+\n+  df_analyze ();\n+\n+  /* Doloop optimization */\n+  if (cfun->machine->has_hardware_loops)\n+    bfin_reorg_loops (dump_file);\n+\n+  workaround_speculation ();\n \n   if (bfin_flag_var_tracking)\n     {\n@@ -4915,7 +5001,10 @@ bfin_reorg (void)\n       reorder_var_tracking_notes ();\n       timevar_pop (TV_VAR_TRACKING);\n     }\n+\n   df_finish_pass (false);\n+\n+  workaround_rts_anomaly ();\n }\n \f\n /* Handle interrupt_handler, exception_handler and nmi_handler function"}]}