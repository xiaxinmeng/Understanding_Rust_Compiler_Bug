{"sha": "9af35de0bc54295688fba58476b88e86cce8957a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWFmMzVkZTBiYzU0Mjk1Njg4ZmJhNTg0NzZiODhlODZjY2U4OTU3YQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-02-16T12:51:36Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-02-16T12:51:36Z"}, "message": "(mulqihi3): Corrected.\n\n(tst{hf,tqf}): Simplified.\n(movqi): Removed redundant alternative.\n(addqi-3,addqi-2,addqi-1): Set/Reset Bit patterns by C. Nettleton.\n(many patterns): Introduced operand output modifiers d,t,b,B,w.\n\nFrom-SVN: r13656", "tree": {"sha": "dd2c5cdccecdedf970e1a337d4427143c6cd0a06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd2c5cdccecdedf970e1a337d4427143c6cd0a06"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9af35de0bc54295688fba58476b88e86cce8957a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9af35de0bc54295688fba58476b88e86cce8957a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9af35de0bc54295688fba58476b88e86cce8957a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9af35de0bc54295688fba58476b88e86cce8957a/comments", "author": null, "committer": null, "parents": [{"sha": "422c6060b6df8cdf0200cd69c1968ebfff214d3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/422c6060b6df8cdf0200cd69c1968ebfff214d3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/422c6060b6df8cdf0200cd69c1968ebfff214d3e"}], "stats": {"total": 337, "additions": 137, "deletions": 200}, "files": [{"sha": "09b4211ca960f7221fd04b09cf75d72b42961e60", "filename": "gcc/config/1750a/1750a.md", "status": "modified", "additions": 137, "deletions": 200, "changes": 337, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af35de0bc54295688fba58476b88e86cce8957a/gcc%2Fconfig%2F1750a%2F1750a.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af35de0bc54295688fba58476b88e86cce8957a/gcc%2Fconfig%2F1750a%2F1750a.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2F1750a%2F1750a.md?ref=9af35de0bc54295688fba58476b88e86cce8957a", "patch": "@@ -55,49 +55,25 @@\n   [(set (match_operand:QI 0 \"push_operand\" \"=<\")\n         (match_operand:QI 1 \"general_operand\" \"r\"))]\n   \"\"\n-  \"pshm r%1,r%1  ; stackptr = R%0\")\n+  \"pshm r%1,r%1\")\n \n (define_insn \"\"\n   [(set (match_operand:HI 0 \"push_operand\" \"=<\")\n         (match_operand:HI 1 \"general_operand\" \"r\"))]\n   \"\"\n-  \"*\n-   { \n-        rtx new_operands[3];\n-        new_operands[2] = operands[0];\n-        new_operands[0] = operands[1];\n-        new_operands[1] = gen_rtx(CONST_INT,VOIDmode,REGNO(operands[1])+1);\n-        output_asm_insn(\\\"pshm r%0,r%1  ; stackptr = r%2\\\",new_operands);\n-        return \\\";\\\";\n-   } \")\n+  \"pshm r%1,r%d1\")\n \n (define_insn \"\"\n   [(set (match_operand:HF 0 \"push_operand\" \"=<\")\n         (match_operand:HF 1 \"general_operand\" \"r\"))]\n   \"\"\n-  \"*\n-  { \n-        rtx new_operands[3];\n-        new_operands[2] = operands[0];\n-        new_operands[0] = operands[1];\n-        new_operands[1] = gen_rtx(CONST_INT,VOIDmode,REGNO(operands[1])+1);\n-        output_asm_insn(\\\"pshm r%0,r%1  ; stackptr = r%2\\\",new_operands);\n-        return \\\";\\\";\n-   } \")\n+  \"pshm r%1,r%d1\")\n \n (define_insn \"\"\n   [(set (match_operand:TQF 0 \"push_operand\" \"=<\")\n         (match_operand:TQF 1 \"general_operand\" \"r\"))]\n   \"\"\n-  \"*\n-   { \n-        rtx new_operands[3];\n-        new_operands[2] = operands[0];\n-        new_operands[0] = operands[1];\n-        new_operands[1] = gen_rtx(CONST_INT,VOIDmode,REGNO(operands[1])+2);\n-        output_asm_insn(\\\"pshm r%0,r%1  ; stackptr = r%2\\\",new_operands);\n-        return \\\";\\\";\n-   } \")\n+  \"pshm r%1,r%t1\")\n \n ;; stackpop\n (define_insn \"\"\n@@ -110,43 +86,22 @@\n   [(set (match_operand:HI 0 \"general_operand\" \"=r\")\n         (match_operand:HI 1 \"push_operand\" \">\"))]\n   \"\"\n-  \"*\n-   { \n-        rtx new_operands[2];\n-        new_operands[0] = operands[0];\n-        new_operands[1] = gen_rtx(CONST_INT,VOIDmode,REGNO(operands[0])+1);\n-        output_asm_insn(\\\"popm r%0,r%1\\\",new_operands);\n-        return \\\";\\\";\n-   } \")\n+  \"popm r%1,r%d1\")\n \n (define_insn \"\"\n   [(set (match_operand:HF 0 \"general_operand\" \"=r\")\n         (match_operand:HF 1 \"push_operand\" \">\"))]\n   \"\"\n-  \"*\n-   { \n-        rtx new_operands[2];\n-        new_operands[0] = operands[0];\n-        new_operands[1] = gen_rtx(CONST_INT,VOIDmode,REGNO(operands[0])+1);\n-        output_asm_insn(\\\"popm r%0,r%1\\\",new_operands);\n-        return \\\";\\\";\n-   } \")\n-\n+  \"popm r%1,r%d1\")\n+   \n (define_insn \"\"\n   [(set (match_operand:TQF 0 \"general_operand\" \"=r\")\n         (match_operand:TQF 1 \"push_operand\" \">\"))]\n   \"\"\n-  \"*\n-   { \n-        rtx new_operands[2];\n-        new_operands[0] = operands[0];\n-        new_operands[1] = gen_rtx(CONST_INT,VOIDmode,REGNO(operands[0])+2);\n-        output_asm_insn(\\\"popm r%0,r%1\\\",new_operands);\n-        return \\\";\\\";\n-   } \")\n+  \"popm r%1,r%t1\")\n \n-;; Test operations. These shouldn't really occur for 1750:\n-;; all important instructions set the cc's (see NOTICE_UPDATE_CC)\n+\n+;; Test operations.\n \n (define_insn \"tstqi\"\n   [(set (cc0)\n@@ -160,18 +115,19 @@\n   \"\"\n   \"dlr r%0,r%0   ; from tsthi\")\n \n+; With 1750A floats, testing the most significant word suffices.\n+\n (define_insn \"tsthf\"\n   [(set (cc0)\n         (match_operand:HF 0 \"register_operand\" \"r\"))]\n   \"\"\n-  \"dlr r%0,r%0   ; from tsthf\")\n+  \"lr r%0,r%0   ; tsthf\")\n \n-;; This one is happy with \"roughly zero\" :-)  (should be improved)\n (define_insn \"tsttqf\"\n   [(set (cc0)\n         (match_operand:TQF 0 \"register_operand\" \"r\"))]\n   \"\"\n-  \"dlr r%0,r%0   ; from tsttqf\")\n+  \"lr r%0,r%0   ; tsttqf\")\n \n \n ;; block move.\n@@ -267,30 +223,29 @@\n \n (define_insn \"trunchiqi2\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-        (truncate:QI\n-         (match_operand:HI 1 \"register_operand\" \"r\")))]\n+        (truncate:QI (match_operand:HI 1 \"register_operand\" \"r\")))]\n   \"\"\n-  \"*\n-     {\n-\trtx new_operands[2];\n-\tnew_operands[0] = operands[0];\n-\tnew_operands[1] = gen_rtx (REG, QImode, REGNO(operands[1]) + 1);\n-        output_asm_insn(\\\"lr r%0,r%1  ;trunchiqi2\\\",new_operands);\n-        return \\\";\\\";\n-     } \")\n+  \"lr  r%0,r%d1\")\n+\n \n ;; zero extension instructions: not defined, GCC can synthesize\n \n ;; sign extension instructions\n \n (define_insn \"extendqihi2\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r,r,r\")\n-        (sign_extend:HI (match_operand:QI 1 \"general_operand\" \"r,m,i\")) )]\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+        (sign_extend:HI (match_operand:QI 1 \"general_operand\" \"r,m\")) )]\n   \"\"\n-  \"@\n-    lr  r%0,r%1 ;extendqihi2\\;dsra r%0,16\n-    l   r%0,%1  ;extendqihi2\\;dsra r%0,16\n-    lim r%0,%1  ;extendqihi2\\;dsra r%0,16 \")\n+  \"*\n+    if (which_alternative == 0)\n+      {\n+        if (REGNO (operands [0]) != REGNO (operands [1]))\n+          output_asm_insn (\\\"lr r%0,r%1\\\", operands);\n+      }\n+    else\n+      output_asm_insn (\\\"l  r%0,%1\\\", operands);\n+    return \\\"dsra r%0,16  ;extendqihi2\\\";\n+  \")\n \n \n ;; Conversions between float and double.\n@@ -301,16 +256,17 @@\n         (float_extend:TQF (match_operand:HF 1 \"general_operand\" \"r,m\")))]\n   \"\"\n   \"*\n+    output_asm_insn(\\\"xorr r%t0,r%t0   ;extendhftqf2\\\", operands);\n+    if (which_alternative == 0)\n       {\n-\trtx new_opnds[2];\n-\tnew_opnds[0] = gen_rtx (REG, QImode, REGNO(operands[0]) + 2);\n-\tnew_opnds[1] = operands[1];\n-        output_asm_insn(\\\"xorr r%0,r%0   ;extendhftqf2\\\",new_opnds);\n-        if (which_alternative == 0)\n+        if (REGNO (operands[1]) != REGNO (operands[0]))\n           return \\\"dlr r%0,r%1\\\";\n         else\n-          return \\\"dl  r%0,%1\\\";\n-      } \")\n+          return \\\";\\\";\n+      }\n+    else\n+      return \\\"dl  r%0,%1\\\";\n+   \")\n \n ; 1750 TQF-to-HF truncate is a no-op: just leave away the least signif. 16 bits\n (define_insn \"trunctqfhf2\"\n@@ -362,119 +318,65 @@\n ;; 16-bit moves\n \n (define_insn \"movqi\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=r,r,r,r,r,r,r,m,m\")\n-        (match_operand:QI 1 \"general_operand\"  \"O,I,J,M,i,r,m,r,K\"))]\n+  [(set (match_operand:QI 0 \"general_operand\" \"=r,r,r,r,r,r,m,m\")\n+        (match_operand:QI 1 \"general_operand\"  \"O,I,J,i,r,m,r,K\"))]\n   \"\"\n   \"@\n      xorr r%0,r%0\n      lisp r%0,%1\n      lisn r%0,%J1\n-     lim  r%0,%1  ; 'M' constraint\n-     lim  r%0,%1  ; 'i' constraint\n+     lim  r%0,%1\n      lr   r%0,r%1\n      l    r%0,%1\n      st   r%1,%0\n      stc  %1,%0   \")\n \n ;; 32-bit moves\n \n-; Set HIreg to constant\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-        (match_operand:HI 1 \"immediate_operand\" \"i\"))]\n-  \"\"\n-  \"*\n-      {\n-        rtx new_opnds[2];\n-        int val = INTVAL(operands[1]);\n-        if (val >= 0)\n-          {\n-            if (val <= 65535)\n-              {\n-                new_opnds[0] = gen_rtx(REG,QImode,REGNO(operands[0]));\n-                new_opnds[1] = operands[1];\n-                output_asm_insn(\\\"xorr   r%0,r%0 ;movhi cst->reg\\\",new_opnds);\n-                REGNO(new_opnds[0]) += 1;\n-                if (val == 0)\n-                  output_asm_insn(\\\"xorr r%0,r%0\\\",new_opnds);\n-                else if (val <= 16)\n-                  output_asm_insn(\\\"lisp r%0,%1\\\",new_opnds);\n-                else\n-                  output_asm_insn(\\\"lim  r%0,%1\\\",new_opnds);\n-                return \\\";\\\";\n-              }\n-          }\n-        else if (val >= -16)\n-          return \\\"lisn r%0,%J1\\;dsra r%0,16 ;movhi cst\\\";\n-\tnew_opnds[0] = gen_rtx(REG, QImode, REGNO(operands[0]));\n-\tnew_opnds[1] = gen_rtx(CONST_INT,VOIDmode,(INTVAL(operands[1])) >> 16);\n-        output_asm_insn(\\\"lim r%0,%1 ;movhi cst->reg\\\",new_opnds);\n-        INTVAL(new_opnds[1]) = val & 0xFFFF;\n-        REGNO(new_opnds[0]) += 1;\n-        output_asm_insn(\\\"lim r%0,%1\\\",new_opnds);\n-        return \\\";\\\";\n-      }\n-  \")\n-\n-; Move small constant to memory, HImode\n (define_insn \"\"\n-  [(set (match_operand:HI 0 \"memory_operand\" \"=m\")\n-        (match_operand:HI 1 \"small_nonneg_const\" \"K\"))]\n+  [(set (match_operand:HI 0 \"general_operand\" \"=r,r,r,r,r,m,m\")\n+        (match_operand:HI 1 \"general_operand\"  \"O,I,J,r,m,r,K\"))]\n   \"\"\n-  \"*\n-      output_asm_insn (\\\"stc 0,%0 ;movhi cst->mem\\\", operands);\n-      return \\\"stc %1,%A0\\\";\n-  \")\n-\n-;; The movhi pattern.\n-\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=r,r,m\")\n-        (match_operand:HI 1 \"general_operand\"  \"r,m,r\"))]\n-  \"register_operand (operands[0], HImode) ||\n-   register_operand (operands[1], HImode)\"\n   \"@\n+    xorr r%0,r%0\\;xorr r%d0,r%d0\n+    xorr r%0,r%0\\;lisp r%d0,%1\n+    lisn r%0,1  \\;lisn r%d0,%J1\n     dlr  r%0,r%1\n     dl   r%0,%1\n-    dst  r%1,%0 \")\n+    dst  r%1,%0\n+    stc  0,%0   \\;stc  %1,%A0 \")\n \n (define_expand \"movhi\"\n   [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n         (match_operand:HI 1 \"general_operand\"  \"g\"))]\n   \"\"\n   \"\n    {\n-    if (GET_CODE(operands[0]) == MEM)\n-      {\n-\trtx op1 = operands[1];\n-        if (GET_CODE(op1) == MEM\n-\t    || (GET_CODE(op1) == CONST_INT\n-\t\t&& (INTVAL(op1) < 0 || INTVAL(op1) > 15)))\n-\t  operands[1] = force_reg (HImode, operands[1]);\n-      }\n+     rtx op1 = operands[1];\n+     if (GET_CODE (operands[0]) == MEM)\n+       {\n+         if (GET_CODE (op1) == MEM\n+\t     || (GET_CODE (op1) == CONST_INT\n+\t\t && (INTVAL (op1) < 0 || INTVAL (op1) > 15)))\n+\t   operands[1] = force_reg (HImode, operands[1]);\n+       }\n+     else if (GET_CODE (op1) == CONST_INT\n+\t      && (INTVAL (op1) < -16 || INTVAL (op1) > 16))\n+       operands[1] = force_const_mem (HImode, operands[1]);\n    }\")\n \n \n-;; Single-Float moves are similar to HImode moves\n-\n-; Move HFmode zero to memory\n-(define_insn \"\"\n-  [(set (match_operand:HF 0 \"memory_operand\" \"=m\")\n-        (match_operand:HF 1 \"zero_operand\" \"G\"))]\n-  \"\"\n-  \"*\n-      output_asm_insn (\\\"stc 0,%0 ;movhf 0.0->mem\\\", operands);\n-      return \\\"stc 0,%A0\\\";\n-  \")\n+;; Single-Float moves\n \n (define_insn \"movhf\"\n-  [(set (match_operand:HF 0 \"general_operand\" \"=r,r,m\")\n-        (match_operand:HF 1 \"general_operand\"  \"r,m,r\"))]\n+  [(set (match_operand:HF 0 \"general_operand\" \"=r,r,m,m\")\n+        (match_operand:HF 1 \"general_operand\"  \"r,m,r,G\"))]\n   \"\"\n   \"@\n     dlr  r%0,r%1\n     dl   r%0,%1\n-    dst  r%1,%0 \")\n+    dst  r%1,%0\n+    stc  0,%0   \\;stc 0,%A0 \")\n \n \n ;; Longfloat moves\n@@ -611,13 +513,24 @@\n ; 32-bit product\n (define_insn \"mulqihi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r,r,r\")\n-        (mult:HI (match_operand:QI 1 \"register_operand\" \"%0,0,0\")\n-                 (match_operand:QI 2 \"general_operand\" \"M,r,m\")))]\n+    (mult:HI (sign_extend:HI (match_operand:QI 1 \"register_operand\" \"%r,r,r\"))\n+             (sign_extend:HI (match_operand:QI 2 \"general_operand\" \"r,m,i\"))))]\n   \"\"\n-  \"@\n-    mim r%0,%1\n-    mr  r%0,r%2\n-    m   r%0,%2 \")\n+  \"*\n+    if (REGNO (operands[1]) != REGNO (operands[0]))\n+      output_asm_insn (\\\"lr r%0,r%1\\\", operands);\n+\n+    switch (which_alternative)\n+      {\n+      case 0:\n+        return \\\"mr  r%0,r%2\\\";\n+      case 1:\n+        return \\\"m   r%0,%2\\\";\n+      case 2:\n+        return \\\"mim r%0,%2\\\";\n+      }\n+  \")\n+\n \n (define_insn \"mulhi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n@@ -786,6 +699,45 @@\n \n ;; bit-logical instructions\n \n+;; Set Bit\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=r,m\")\n+        (ior:QI  (match_operand:QI 1 \"general_operand\" \"0,0\")\n+                 (match_operand:QI 2 \"const_int_operand\" \"i,i\")))]\n+  \"one_bit_set_p (INTVAL (operands [2]))\"\n+  \"@\n+    sbr    %b2,r%0\n+    sb     %b2,%0\")\n+\n+;; Reset Bit\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=r,m\")\n+        (and:QI  (match_operand:QI 1 \"general_operand\" \"0,0\")\n+                 (match_operand:QI 2 \"const_int_operand\" \"i,i\")))]\n+  \"one_bit_set_p ((~INTVAL (operands [2])) & 0xffff)\"\n+  \"@\n+    rbr    %B2,r%0\n+    rb     %B2,%0\")\n+\n+;; Set Variable Bit\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+        (ior:QI  (match_operand:QI 1 \"register_operand\" \"0\")\n+                 (lshiftrt:QI (const_int 0x8000)\n+                      (match_operand:QI 2 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"svbr   r%2,%r0\")\n+\n+;; Reset Variable Bit\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=r\")\n+        (and:QI  (match_operand:QI 1 \"general_operand\" \"0\")\n+            (not:QI (lshiftrt:QI (const_int 0x8000)\n+                        (match_operand:QI 2 \"register_operand\" \"r\")))))]\n+  \"\"\n+  \"rvbr   r%2,%r0\")\n+\n+\n ;; AND\n \n (define_insn \"andqi3\"\n@@ -900,19 +852,16 @@\n                    (match_operand:QI 2 \"nonmemory_operand\" \"L,r\")))]\n   \"\"                        ; the 'L' constraint is a slight imprecise...\n   \"*\n-  if (which_alternative == 1)\n-    return \\\"dslr r%0,r%2\\\";\n-  else if (INTVAL(operands[2]) <= 16)\n-    return \\\"dsll r%0,%2\\\";\n-  else\n-  {\n-    rtx new_opnds[2];\n-    output_asm_insn(\\\"dsll r%0,16  ; ashlhi3 shiftcount > 16\\\",operands);\n-    new_opnds[0] = operands[0];\n-    new_opnds[1] = gen_rtx (CONST_INT, VOIDmode, INTVAL(operands[2]) - 16);\n-    output_asm_insn(\\\"sll r%0,%1\\\",new_opnds);\n-    return \\\";\\\";\n-  } \")\n+    if (which_alternative == 1)\n+      return \\\"dslr r%0,r%2\\\";\n+    else if (INTVAL(operands[2]) <= 16)\n+      return \\\"dsll r%0,%2\\\";\n+    else\n+      {\n+        output_asm_insn (\\\"dsll r%0,16  ; ashlhi3 shiftcnt > 16\\\", operands);\n+        return \\\"sll r%0,%w2\\\";\n+      }\n+  \")\n \n \n ;; Right shift by a variable shiftcount works by negating the shift count,\n@@ -964,17 +913,11 @@\n \t\t     (match_operand:QI 2 \"immediate_operand\" \"L\")))]\n   \"\"\n   \"*\n-  {\n-    rtx new_opnds[2];\n-    int amount = INTVAL(operands[2]);\n-    if (amount <= 16)\n+    if (INTVAL (operands[2]) <= 16)\n       return \\\"dsrl r%0,%2\\\";\n-    output_asm_insn(\\\"dsrl r%0,16  ; lshrhi3 shiftcount > 16\\\",operands);\n-    new_opnds[0] = gen_rtx (REG, QImode, REGNO(operands[0]) + 1);\n-    new_opnds[1] = gen_rtx (CONST_INT, VOIDmode, amount - 16);\n-    output_asm_insn(\\\"srl  r%0,%1\\\",new_opnds);\n-    return \\\";\\\";\n-  } \")\n+    output_asm_insn (\\\"dsrl r%0,16  ; lshrhi3 shiftcount > 16\\\", operands);\n+    return \\\"srl  r%d0,%w2\\\";\n+  \")\n \n (define_insn \"\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n@@ -1027,17 +970,11 @@\n \t\t     (match_operand:QI 2 \"immediate_operand\" \"L\")))]\n   \"\"\n   \"*\n-  {\n-    rtx new_opnds[2];\n-    int amount = INTVAL(operands[2]);\n-    if (amount <= 16)\n+    if (INTVAL (operands[2]) <= 16)\n       return \\\"dsra r%0,%2\\\";\n-    output_asm_insn(\\\"dsra r%0,16  ; ashrhi3 shiftcount > 16\\\",operands);\n-    new_opnds[0] = gen_rtx (REG, QImode, REGNO(operands[0]) + 1);\n-    new_opnds[1] = gen_rtx (CONST_INT, VOIDmode, amount - 16);\n-    output_asm_insn(\\\"sra  r%0,%1\\\",new_opnds);\n-    return \\\";\\\";\n-  } \")\n+    output_asm_insn (\\\"dsra r%0,16  ; ashrhi3 shiftcount > 16\\\", operands);\n+    return \\\"sra  r%d0,%w2\\\";\n+  \")\n \n (define_insn \"\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")"}]}