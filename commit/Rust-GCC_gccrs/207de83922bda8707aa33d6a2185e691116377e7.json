{"sha": "207de83922bda8707aa33d6a2185e691116377e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjA3ZGU4MzkyMmJkYTg3MDdhYTMzZDZhMjE4NWU2OTExMTYzNzdlNw==", "commit": {"author": {"name": "Monk Chiang", "email": "monk.chiang@sifive.com", "date": "2020-11-14T03:35:11Z"}, "committer": {"name": "Jim Wilson", "email": "jimw@sifive.com", "date": "2020-11-14T04:04:26Z"}, "message": "PR target/97682 - Fix to reuse t1 register between call address and epilogue.\n\n  - When expanding the call pattern, choose t1 register be a jump register.\n    Epilogue also uses a t1 register to adjust Stack point. The call pattern\n    and epilogue will initial t1 twice, if both are generated in the same\n    function. The call pattern will emit 'la t1,symbol' and 'jalr t1'instructions.\n    Epilogue also emits 'li t1,4096' and 'addi sp,sp,t1' instructions.\n    But li and addi instructions will be placed between la and jalr instructions.\n    The la instruction will be removed by some optimizations,\n    because t1 register define twice, the first define instruction look\n    likes duplicate.\n\n  - To resolve this issue, Prologue and Epilogue use the t0 register\n    be a temporary register, the call pattern use the t1 register be\n    a temporary register.\n\ngcc/\n2020-11-13  Monk Chiang  <monk.chiang@sifive.com>\n\n\tPR target/97682\n\t* config/riscv/riscv.h (RISCV_PROLOGUE_TEMP_REGNUM): Change register\n\tto t0.\n\t(RISCV_CALL_ADDRESS_TEMP_REGNUM): New Marco, define t1 register.\n\t(RISCV_CALL_ADDRESS_TEMP): Use it for call instructions.\n\t* config/riscv/riscv.c (riscv_legitimize_call_address): Use\n\tRISCV_CALL_ADDRESS_TEMP.\n\t(riscv_compute_frame_info): Change temporary register to t0 form t1.\n\t(riscv_trampoline_init): Adjust comment.\n\ngcc/testsuite/\n2020-11-13  Monk Chiang  <monk.chiang@sifive.com>\n\n\tPR target/97682\n\t* g++.target/riscv/pr97682.C: New test.\n\t* gcc.target/riscv/interrupt-3.c: Check register for t0.\n\t* gcc.target/riscv/interrupt-4.c: Likewise.", "tree": {"sha": "80ad3d204aed41a3abacc3dceb7c18e20a1fe673", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/80ad3d204aed41a3abacc3dceb7c18e20a1fe673"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/207de83922bda8707aa33d6a2185e691116377e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/207de83922bda8707aa33d6a2185e691116377e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/207de83922bda8707aa33d6a2185e691116377e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/207de83922bda8707aa33d6a2185e691116377e7/comments", "author": {"login": "monkchiang", "id": 62004175, "node_id": "MDQ6VXNlcjYyMDA0MTc1", "avatar_url": "https://avatars.githubusercontent.com/u/62004175?v=4", "gravatar_id": "", "url": "https://api.github.com/users/monkchiang", "html_url": "https://github.com/monkchiang", "followers_url": "https://api.github.com/users/monkchiang/followers", "following_url": "https://api.github.com/users/monkchiang/following{/other_user}", "gists_url": "https://api.github.com/users/monkchiang/gists{/gist_id}", "starred_url": "https://api.github.com/users/monkchiang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/monkchiang/subscriptions", "organizations_url": "https://api.github.com/users/monkchiang/orgs", "repos_url": "https://api.github.com/users/monkchiang/repos", "events_url": "https://api.github.com/users/monkchiang/events{/privacy}", "received_events_url": "https://api.github.com/users/monkchiang/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dcf0dde488b81894124a6bb181c98e215d4dfdeb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcf0dde488b81894124a6bb181c98e215d4dfdeb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dcf0dde488b81894124a6bb181c98e215d4dfdeb"}], "stats": {"total": 197, "additions": 181, "deletions": 16}, "files": [{"sha": "9b83da0472947d9ffc0e0ac2e9a5ba43ac41ff4a", "filename": "gcc/config/riscv/riscv.c", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/207de83922bda8707aa33d6a2185e691116377e7/gcc%2Fconfig%2Friscv%2Friscv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/207de83922bda8707aa33d6a2185e691116377e7/gcc%2Fconfig%2Friscv%2Friscv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.c?ref=207de83922bda8707aa33d6a2185e691116377e7", "patch": "@@ -3110,7 +3110,7 @@ riscv_legitimize_call_address (rtx addr)\n {\n   if (!call_insn_operand (addr, VOIDmode))\n     {\n-      rtx reg = RISCV_PROLOGUE_TEMP (Pmode);\n+      rtx reg = RISCV_CALL_ADDRESS_TEMP (Pmode);\n       riscv_emit_move (reg, addr);\n       return reg;\n     }\n@@ -3707,18 +3707,18 @@ riscv_compute_frame_info (void)\n {\n   struct riscv_frame_info *frame;\n   HOST_WIDE_INT offset;\n-  bool interrupt_save_t1 = false;\n+  bool interrupt_save_prologue_temp = false;\n   unsigned int regno, i, num_x_saved = 0, num_f_saved = 0;\n \n   frame = &cfun->machine->frame;\n \n   /* In an interrupt function, if we have a large frame, then we need to\n-     save/restore t1.  We check for this before clearing the frame struct.  */\n+     save/restore t0.  We check for this before clearing the frame struct.  */\n   if (cfun->machine->interrupt_handler_p)\n     {\n       HOST_WIDE_INT step1 = riscv_first_stack_step (frame);\n       if (! SMALL_OPERAND (frame->total_size - step1))\n-\tinterrupt_save_t1 = true;\n+\tinterrupt_save_prologue_temp = true;\n     }\n \n   memset (frame, 0, sizeof (*frame));\n@@ -3728,7 +3728,8 @@ riscv_compute_frame_info (void)\n       /* Find out which GPRs we need to save.  */\n       for (regno = GP_REG_FIRST; regno <= GP_REG_LAST; regno++)\n \tif (riscv_save_reg_p (regno)\n-\t    || (interrupt_save_t1 && (regno == T1_REGNUM)))\n+\t    || (interrupt_save_prologue_temp\n+\t\t&& (regno == RISCV_PROLOGUE_TEMP_REGNUM)))\n \t  frame->mask |= 1 << (regno - GP_REG_FIRST), num_x_saved++;\n \n       /* If this function calls eh_return, we must also save and restore the\n@@ -4902,9 +4903,9 @@ riscv_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n \n       rtx target_function = force_reg (Pmode, XEXP (DECL_RTL (fndecl), 0));\n       /* lui     t2, hi(chain)\n-\t lui     t1, hi(func)\n+\t lui     t0, hi(func)\n \t addi    t2, t2, lo(chain)\n-\t jr      r1, lo(func)\n+\t jr      t0, lo(func)\n       */\n       unsigned HOST_WIDE_INT lui_hi_chain_code, lui_hi_func_code;\n       unsigned HOST_WIDE_INT lo_chain_code, lo_func_code;\n@@ -4929,7 +4930,7 @@ riscv_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n       mem = adjust_address (m_tramp, SImode, 0);\n       riscv_emit_move (mem, lui_hi_chain);\n \n-      /* Gen lui t1, hi(func).  */\n+      /* Gen lui t0, hi(func).  */\n       rtx hi_func = riscv_force_binary (SImode, PLUS, target_function,\n \t\t\t\t\tfixup_value);\n       hi_func = riscv_force_binary (SImode, AND, hi_func,\n@@ -4956,7 +4957,7 @@ riscv_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n       mem = adjust_address (m_tramp, SImode, 2 * GET_MODE_SIZE (SImode));\n       riscv_emit_move (mem, addi_lo_chain);\n \n-      /* Gen jr r1, lo(func).  */\n+      /* Gen jr t0, lo(func).  */\n       rtx lo_func = riscv_force_binary (SImode, AND, target_function,\n \t\t\t\t\timm12_mask);\n       lo_func = riscv_force_binary (SImode, ASHIFT, lo_func, GEN_INT (20));\n@@ -4975,9 +4976,9 @@ riscv_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n       target_function_offset = static_chain_offset + GET_MODE_SIZE (ptr_mode);\n \n       /* auipc   t2, 0\n-\t l[wd]   t1, target_function_offset(t2)\n+\t l[wd]   t0, target_function_offset(t2)\n \t l[wd]   t2, static_chain_offset(t2)\n-\t jr      t1\n+\t jr      t0\n       */\n       trampoline[0] = OPCODE_AUIPC | (STATIC_CHAIN_REGNUM << SHIFT_RD);\n       trampoline[1] = (Pmode == DImode ? OPCODE_LD : OPCODE_LW)"}, {"sha": "3bd1993c4c9aaef2b2d3154224824753ec410c37", "filename": "gcc/config/riscv/riscv.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/207de83922bda8707aa33d6a2185e691116377e7/gcc%2Fconfig%2Friscv%2Friscv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/207de83922bda8707aa33d6a2185e691116377e7/gcc%2Fconfig%2Friscv%2Friscv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.h?ref=207de83922bda8707aa33d6a2185e691116377e7", "patch": "@@ -342,9 +342,13 @@ extern const char *riscv_default_mtune (int argc, const char **argv);\n    The epilogue temporary mustn't conflict with the return registers,\n    the frame pointer, the EH stack adjustment, or the EH data registers. */\n \n-#define RISCV_PROLOGUE_TEMP_REGNUM (GP_TEMP_FIRST + 1)\n+#define RISCV_PROLOGUE_TEMP_REGNUM (GP_TEMP_FIRST)\n #define RISCV_PROLOGUE_TEMP(MODE) gen_rtx_REG (MODE, RISCV_PROLOGUE_TEMP_REGNUM)\n \n+#define RISCV_CALL_ADDRESS_TEMP_REGNUM (GP_TEMP_FIRST + 1)\n+#define RISCV_CALL_ADDRESS_TEMP(MODE) \\\n+  gen_rtx_REG (MODE, RISCV_CALL_ADDRESS_TEMP_REGNUM)\n+\n #define MCOUNT_NAME \"_mcount\"\n \n #define NO_PROFILE_COUNTERS 1"}, {"sha": "03c7a447de5941d6fee1a4d95ab55f7d911271e3", "filename": "gcc/testsuite/g++.target/riscv/pr97682.C", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/207de83922bda8707aa33d6a2185e691116377e7/gcc%2Ftestsuite%2Fg%2B%2B.target%2Friscv%2Fpr97682.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/207de83922bda8707aa33d6a2185e691116377e7/gcc%2Ftestsuite%2Fg%2B%2B.target%2Friscv%2Fpr97682.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Friscv%2Fpr97682.C?ref=207de83922bda8707aa33d6a2185e691116377e7", "patch": "@@ -0,0 +1,160 @@\n+/* PR target/97682 */\n+/* { dg-do compile } */\n+/* { dg-options \"-fPIC -O2 -march=rv64g -mabi=lp64\" } */\n+\n+template <typename ab, int ac> struct g { ab b[ac]; };\n+long i, m;\n+\n+namespace std\n+{\n+  template <typename c> struct t\n+  {\n+    int a;\n+    c h;\n+  };\n+\n+  struct ad\n+  {\n+    enum { j };\n+  };\n+\n+  template <typename k> k l(k);\n+  struct al {};\n+  template <typename k> k aa(k);\n+\n+  struct v\n+  {\n+    template <typename n, typename q> static q o(n, n, q);\n+  };\n+\n+  template <int, typename n, typename q> void p(n z, n ao, q ap)\n+  {\n+    v::o(z, ao, ap);\n+  }\n+\n+  template <int ae, typename n, typename q> void r(n z, n ao, q ap)\n+  {\n+    p<ae>(z, ao, ap);\n+  }\n+\n+  template <int ae, typename n, typename q> void af(n z, n ao, q)\n+  {\n+    r<ae>(aa(z), aa(ao), 0);\n+  }\n+\n+  template <typename n, typename q> void ag(n z, n ao, q ap)\n+  {\n+    af<ad::j>(l(z), l(ao), ap);\n+  }\n+\n+  template <typename> class allocator;\n+  template <typename ah, typename ai, typename aj> void ak(ah, ai, aj);\n+\n+  template <typename s> class aq\n+  {\n+    template <typename am> struct ar { using f = am *; };\n+  public:\n+    using an = typename ar<s>::f;\n+  };\n+\n+  template <typename s> class as\n+  {\n+  public:\n+    using an = typename aq<s>::an;\n+    an operator->();\n+  };\n+\n+  struct ay\n+  {\n+    int at();\n+  };\n+\n+  template <typename s, typename = allocator<s>> class vector : ay\n+  {\n+  public:\n+    long au();\n+    long x;\n+    void av() { _M_default_append(x); }\n+    void _M_default_append(unsigned long);\n+    void aw();\n+    long ax(int);\n+  };\n+\n+  template <typename s, typename y>\n+  void vector<s, y>::_M_default_append(unsigned long z)\n+  {\n+    long az = au();\n+    int w = at(), bc = at();\n+    i = ax(w);\n+    m = ax(w);\n+    if (i || m)\n+      aw();\n+    ak(az, z, bc);\n+  }\n+}\n+\n+namespace llvm\n+{\n+  template <int bd> class bh\n+  {\n+    enum { bf = bd } * bg[bf];\n+  };\n+\n+  template <class> class bi;\n+\n+  class bm\n+  {\n+    using bj = bi<int>;\n+    std::as<bj> bk;\n+    void bl();\n+  };\n+\n+  template <class> struct bn;\n+\n+  class br\n+  {\n+    bh<8> bo;\n+  };\n+\n+  class ca\n+  {\n+    int *d;\n+    int e;\n+  };\n+\n+  template <class bp> class bv : std::al, br\n+  {\n+    g<std::t<ca>, 8> b;\n+  };\n+\n+  template <class ab> bv<ab> bt(ab);\n+\n+  class BlockFrequencyInfoImplBase\n+  {\n+  public:\n+    struct FrequencyData;\n+    std::vector<FrequencyData> bu;\n+  };\n+\n+  template <class> struct cb { using bw = int; };\n+  template <class bx> class bi : BlockFrequencyInfoImplBase\n+  {\n+    using bw = typename cb<bx>::bw;\n+  public:\n+    void bl();\n+  };\n+\n+  template <class bx> void bi<bx>::bl()\n+  {\n+    const bw *by;\n+    bv<const int *> bz;\n+    ag(bz, bt(by), 0);\n+    bu.av();\n+  }\n+\n+  template <> struct bn<const int *> { using u = ca; };\n+  void bm::bl() { bk->bl(); }\n+}\n+\n+/* The t1 register is to initial symbol reference for call instruction.  */\n+/* { dg-final { scan-assembler \"la\\tt1,.*FrequencyData.*_M_default_append.*\" } } */"}, {"sha": "3d1d44df45e6fd978a036f71e573483b954e4211", "filename": "gcc/testsuite/gcc.target/riscv/interrupt-3.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/207de83922bda8707aa33d6a2185e691116377e7/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Finterrupt-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/207de83922bda8707aa33d6a2185e691116377e7/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Finterrupt-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Finterrupt-3.c?ref=207de83922bda8707aa33d6a2185e691116377e7", "patch": "@@ -1,9 +1,9 @@\n-/* Verify t1 is saved before use.  */\n+/* Verify t0 is saved before use.  */\n /* { dg-do compile } */\n /* { dg-options \"-O0 -fomit-frame-pointer\" } */\n void __attribute__ ((interrupt))\n foo (void)\n {\n   char array[4096];\n }\n-/* { dg-final { scan-assembler \"s\\[wd\\]\\tt1\" } } */\n+/* { dg-final { scan-assembler \"s\\[wd\\]\\tt0\" } } */"}, {"sha": "658aa176e7794d7aaa3fa4133107818c2091ee43", "filename": "gcc/testsuite/gcc.target/riscv/interrupt-4.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/207de83922bda8707aa33d6a2185e691116377e7/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Finterrupt-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/207de83922bda8707aa33d6a2185e691116377e7/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Finterrupt-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Finterrupt-4.c?ref=207de83922bda8707aa33d6a2185e691116377e7", "patch": "@@ -1,4 +1,4 @@\n-/* Verify t1 is saved before use.  */\n+/* Verify t0 is saved before use.  */\n /* { dg-do compile } */\n /* { dg-options \"-O0 -fomit-frame-pointer\" } */\n void __attribute__ ((interrupt))\n@@ -15,4 +15,4 @@ foo2 (void)\n   COUNTER++;\n #endif\n }\n-/* { dg-final { scan-assembler \"s\\[wd\\]\\tt1\" } } */\n+/* { dg-final { scan-assembler \"s\\[wd\\]\\tt0\" } } */"}]}