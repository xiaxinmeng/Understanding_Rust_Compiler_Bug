{"sha": "c99c095f991024052fcf8d32d230ce448edc2d81", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzk5YzA5NWY5OTEwMjQwNTJmY2Y4ZDMyZDIzMGNlNDQ4ZWRjMmQ4MQ==", "commit": {"author": {"name": "Olivier Hainque", "email": "hainque@adacore.com", "date": "2007-04-06T09:15:36Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-04-06T09:15:36Z"}, "message": "adaint.c:\n\n2007-04-06  Olivier Hainque  <hainque@adacore.com>\n\n\t* adaint.c: \n\t(convert_addresses): Adjust prototype and dummy definition to expect an\n\t extra file_name argument.\n\n\t* gmem.c (__gnat_convert_addresses): Wrapper to convert_addresses,\n\tfilling the now expected file_name argument with the appropriate\n\targv[0] expansion.\n\t(__gnat_gmem_a2l_initialize, __gnat_gmem_read_next_frame): Use it.\n\t(tracebk): Array of void * instead of char *, corresponding to what\n\t convert_addresses expects.\n\t(exename): New static global, to hold the executable file name to be\n\tused in all convert_addresses invocations.\n\t(gmem_read_backtrace, __gnat_gmem_symbolic): Account for tracebk type\n\tchange.\n\t(__gnat_gmem_a2l_initialize): Resolve exename.\n\t(__gnat_convert_addresses): Use exename as the convert_addresses\n\tfile_name argument.\n\n\t* g-trasym.adb (Symbolic_Traceback): Adjust signature of imported\n\t\"convert_addresses\", now expecting a filename argument. Import the\n\tnecessary entities to compute the filename to use and pass it to\n\tconvert_addresses.\n\nFrom-SVN: r123544", "tree": {"sha": "cbad8ec2d61270e4c4e4aa20909e6960da5c3d68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cbad8ec2d61270e4c4e4aa20909e6960da5c3d68"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c99c095f991024052fcf8d32d230ce448edc2d81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c99c095f991024052fcf8d32d230ce448edc2d81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c99c095f991024052fcf8d32d230ce448edc2d81", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c99c095f991024052fcf8d32d230ce448edc2d81/comments", "author": {"login": "hainque", "id": 18735142, "node_id": "MDQ6VXNlcjE4NzM1MTQy", "avatar_url": "https://avatars.githubusercontent.com/u/18735142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hainque", "html_url": "https://github.com/hainque", "followers_url": "https://api.github.com/users/hainque/followers", "following_url": "https://api.github.com/users/hainque/following{/other_user}", "gists_url": "https://api.github.com/users/hainque/gists{/gist_id}", "starred_url": "https://api.github.com/users/hainque/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hainque/subscriptions", "organizations_url": "https://api.github.com/users/hainque/orgs", "repos_url": "https://api.github.com/users/hainque/repos", "events_url": "https://api.github.com/users/hainque/events{/privacy}", "received_events_url": "https://api.github.com/users/hainque/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "42907632860e44cc8c8b49a0b74444f62791fb9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42907632860e44cc8c8b49a0b74444f62791fb9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42907632860e44cc8c8b49a0b74444f62791fb9c"}], "stats": {"total": 208, "additions": 159, "deletions": 49}, "files": [{"sha": "9952bc849f752e6060e14643ac53347e8e3e4f10", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 44, "deletions": 22, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c99c095f991024052fcf8d32d230ce448edc2d81/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c99c095f991024052fcf8d32d230ce448edc2d81/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=c99c095f991024052fcf8d32d230ce448edc2d81", "patch": "@@ -324,6 +324,14 @@ to_ptr32 (char **ptr64)\n #define MAYBE_TO_PTR32(argv) argv\n #endif\n \n+OS_Time\n+__gnat_current_time\n+  (void)\n+{\n+  time_t res = time (NULL);\n+  return (OS_Time) res;\n+}\n+\n void\n __gnat_to_gm_time\n   (OS_Time *p_time,\n@@ -418,8 +426,8 @@ __gnat_try_lock (char *dir, char *file)\n   TCHAR wfile[GNAT_MAX_PATH_LEN];\n   TCHAR wdir[GNAT_MAX_PATH_LEN];\n \n-  S2WS (wdir, dir, GNAT_MAX_PATH_LEN);\n-  S2WS (wfile, file, GNAT_MAX_PATH_LEN);\n+  S2WSU (wdir, dir, GNAT_MAX_PATH_LEN);\n+  S2WSU (wfile, file, GNAT_MAX_PATH_LEN);\n \n   _stprintf (wfull_path, _T(\"%s%c%s\"), wdir, _T(DIR_SEPARATOR), wfile);\n   fd = _topen (wfull_path, O_CREAT | O_EXCL, 0600);\n@@ -542,7 +550,7 @@ __gnat_get_current_dir (char *dir, int *length)\n \n   _tgetcwd (wdir, *length);\n \n-  WS2S (dir, wdir, GNAT_MAX_PATH_LEN);\n+  WS2SU (dir, wdir, GNAT_MAX_PATH_LEN);\n \n #elif defined (VMS)\n    /* Force Unix style, which is what GNAT uses internally.  */\n@@ -612,31 +620,44 @@ __gnat_get_debuggable_suffix_ptr (int *len, const char **value)\n }\n \n FILE *\n-__gnat_fopen (char *path, char *mode)\n+__gnat_fopen (char *path, char *mode, int encoding)\n {\n #if defined (_WIN32) && ! defined (__vxworks) && ! defined (CROSS_DIRECTORY_STRUCTURE)\n   TCHAR wpath[GNAT_MAX_PATH_LEN];\n   TCHAR wmode[10];\n \n-  S2WS (wpath, path, GNAT_MAX_PATH_LEN);\n   S2WS (wmode, mode, 10);\n+\n+  if (encoding == Encoding_UTF8)\n+    S2WSU (wpath, path, GNAT_MAX_PATH_LEN);\n+  else\n+    S2WS (wpath, path, GNAT_MAX_PATH_LEN);\n+\n   return _tfopen (wpath, wmode);\n+#elif defined (VMS)\n+  return decc$fopen (path, mode);\n #else\n   return fopen (path, mode);\n #endif\n }\n \n-\n FILE *\n-__gnat_freopen (char *path, char *mode, FILE *stream)\n+__gnat_freopen (char *path, char *mode, FILE *stream, int encoding)\n {\n #if defined (_WIN32) && ! defined (__vxworks) && ! defined (CROSS_DIRECTORY_STRUCTURE)\n   TCHAR wpath[GNAT_MAX_PATH_LEN];\n   TCHAR wmode[10];\n \n-  S2WS (wpath, path, GNAT_MAX_PATH_LEN);\n   S2WS (wmode, mode, 10);\n+\n+  if (encoding == Encoding_UTF8)\n+    S2WSU (wpath, path, GNAT_MAX_PATH_LEN);\n+  else\n+    S2WS (wpath, path, GNAT_MAX_PATH_LEN);\n+\n   return _tfreopen (wpath, wmode, stream);\n+#elif defined (VMS)\n+  return decc$freopen (path, mode, stream);\n #else\n   return freopen (path, mode, stream);\n #endif\n@@ -661,7 +682,7 @@ __gnat_open_read (char *path, int fmode)\n  {\n    TCHAR wpath[GNAT_MAX_PATH_LEN];\n \n-   S2WS (wpath, path, GNAT_MAX_PATH_LEN);\n+   S2WSU (wpath, path, GNAT_MAX_PATH_LEN);\n    fd = _topen (wpath, O_RDONLY | o_fmode, 0444);\n  }\n #else\n@@ -702,7 +723,7 @@ __gnat_open_rw (char *path, int fmode)\n   {\n     TCHAR wpath[GNAT_MAX_PATH_LEN];\n \n-    S2WS (wpath, path, GNAT_MAX_PATH_LEN);\n+    S2WSU (wpath, path, GNAT_MAX_PATH_LEN);\n     fd = _topen (wpath, O_RDWR | o_fmode, PERM);\n   }\n #else\n@@ -728,7 +749,7 @@ __gnat_open_create (char *path, int fmode)\n   {\n     TCHAR wpath[GNAT_MAX_PATH_LEN];\n \n-    S2WS (wpath, path, GNAT_MAX_PATH_LEN);\n+    S2WSU (wpath, path, GNAT_MAX_PATH_LEN);\n     fd = _topen (wpath, O_WRONLY | O_CREAT | O_TRUNC | o_fmode, PERM);\n   }\n #else\n@@ -750,7 +771,7 @@ __gnat_create_output_file (char *path)\n   {\n     TCHAR wpath[GNAT_MAX_PATH_LEN];\n \n-    S2WS (wpath, path, GNAT_MAX_PATH_LEN);\n+    S2WSU (wpath, path, GNAT_MAX_PATH_LEN);\n     fd = _topen (wpath, O_WRONLY | O_CREAT | O_TRUNC | O_TEXT, PERM);\n   }\n #else\n@@ -776,7 +797,7 @@ __gnat_open_append (char *path, int fmode)\n   {\n     TCHAR wpath[GNAT_MAX_PATH_LEN];\n \n-    S2WS (wpath, path, GNAT_MAX_PATH_LEN);\n+    S2WSU (wpath, path, GNAT_MAX_PATH_LEN);\n     fd = _topen (wpath, O_WRONLY | O_CREAT | O_APPEND | o_fmode, PERM);\n   }\n #else\n@@ -804,7 +825,7 @@ __gnat_open_new (char *path, int fmode)\n   {\n     TCHAR wpath[GNAT_MAX_PATH_LEN];\n \n-    S2WS (wpath, path, GNAT_MAX_PATH_LEN);\n+    S2WSU (wpath, path, GNAT_MAX_PATH_LEN);\n     fd = _topen (wpath, O_WRONLY | O_CREAT | O_EXCL | o_fmode, PERM);\n   }\n #else\n@@ -940,7 +961,7 @@ DIR* __gnat_opendir (char *name)\n #ifdef __MINGW32__\n   TCHAR wname[GNAT_MAX_PATH_LEN];\n \n-  S2WS (wname, name, GNAT_MAX_PATH_LEN);\n+  S2WSU (wname, name, GNAT_MAX_PATH_LEN);\n   return (DIR*)_topendir (wname);\n \n #else\n@@ -959,7 +980,7 @@ __gnat_readdir (DIR *dirp, char *buffer, int *len)\n \n   if (dirent != NULL)\n     {\n-      WS2S (buffer, dirent->d_name, GNAT_MAX_PATH_LEN);\n+      WS2SU (buffer, dirent->d_name, GNAT_MAX_PATH_LEN);\n       *len = strlen (buffer);\n \n       return buffer;\n@@ -1058,7 +1079,7 @@ __gnat_file_time_name (char *name)\n   time_t ret = -1;\n   TCHAR wname[GNAT_MAX_PATH_LEN];\n \n-  S2WS (wname, name, GNAT_MAX_PATH_LEN);\n+  S2WSU (wname, name, GNAT_MAX_PATH_LEN);\n \n   HANDLE h = CreateFile\n     (wname, GENERIC_READ, FILE_SHARE_READ, 0,\n@@ -1195,7 +1216,7 @@ __gnat_set_file_time_name (char *name, time_t time_stamp)\n   } t_write;\n   TCHAR wname[GNAT_MAX_PATH_LEN];\n \n-  S2WS (wname, name, GNAT_MAX_PATH_LEN);\n+  S2WSU (wname, name, GNAT_MAX_PATH_LEN);\n \n   HANDLE h  = CreateFile\n     (wname, GENERIC_WRITE, FILE_SHARE_WRITE, NULL,\n@@ -1462,7 +1483,7 @@ __gnat_stat (char *name, struct stat *statbuf)\n   int name_len;\n   TCHAR last_char;\n \n-  S2WS (wname, name, GNAT_MAX_PATH_LEN + 2);\n+  S2WSU (wname, name, GNAT_MAX_PATH_LEN + 2);\n   name_len = _tcslen (wname);\n \n   if (name_len > GNAT_MAX_PATH_LEN)\n@@ -1854,7 +1875,7 @@ win32_no_block_spawn (char *command, char *args[])\n     int wsize = csize * 2;\n     TCHAR *wcommand = (TCHAR *) xmalloc (wsize);\n \n-    S2WS (wcommand, full_command, wsize);\n+    S2WSU (wcommand, full_command, wsize);\n \n     free (full_command);\n \n@@ -2145,7 +2166,7 @@ __gnat_locate_exec_on_path (char *exec_name)\n \n   apath_val = alloca (EXPAND_BUFFER_SIZE);\n \n-  WS2S (apath_val, wapath_val, EXPAND_BUFFER_SIZE);\n+  WS2SU (apath_val, wapath_val, EXPAND_BUFFER_SIZE);\n   return __gnat_locate_exec (exec_name, apath_val);\n \n #else\n@@ -2623,7 +2644,8 @@ _flush_cache()\n    version of this procedure in libaddr2line.a.  */\n \n void\n-convert_addresses (void *addrs ATTRIBUTE_UNUSED,\n+convert_addresses (const char *file_name ATTRIBUTE_UNUSED,\n+\t\t   void *addrs ATTRIBUTE_UNUSED,\n \t\t   int n_addr ATTRIBUTE_UNUSED,\n \t\t   void *buf ATTRIBUTE_UNUSED,\n \t\t   int *len ATTRIBUTE_UNUSED)"}, {"sha": "117dcc2f61eebd531c48fbe7800af21b1b008c9f", "filename": "gcc/ada/g-trasym.adb", "status": "modified", "additions": 78, "deletions": 12, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c99c095f991024052fcf8d32d230ce448edc2d81/gcc%2Fada%2Fg-trasym.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c99c095f991024052fcf8d32d230ce448edc2d81/gcc%2Fada%2Fg-trasym.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-trasym.adb?ref=c99c095f991024052fcf8d32d230ce448edc2d81", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                     Copyright (C) 1999-2005, AdaCore                     --\n+--                     Copyright (C) 1999-2006, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -44,38 +44,104 @@ package body GNAT.Traceback.Symbolic is\n \n    package TSL renames System.Soft_Links;\n \n+   --  To perform the raw addresses to symbolic form translation we rely on a\n+   --  libaddr2line symbolizer which examines debug info from a provided\n+   --  executable file name, and an absolute path is needed to ensure the file\n+   --  is always found. This is \"__gnat_locate_exec_on_path (gnat_argv [0])\"\n+   --  for our executable file, a fairly heavy operation so we cache the\n+   --  result.\n+\n+   Exename : System.Address;\n+   --  Pointer to the name of the executable file to be used on all\n+   --  invocations of the libaddr2line symbolization service.\n+\n+   Exename_Resolved : Boolean := False;\n+   --  Flag to indicate whether we have performed the executable file name\n+   --  resolution already. Relying on a not null Exename for this purpose\n+   --  would be potentially inefficient as this is what we will get if the\n+   --  resolution attempt fails.\n+\n    ------------------------\n    -- Symbolic_Traceback --\n    ------------------------\n \n    function Symbolic_Traceback (Traceback : Tracebacks_Array) return String is\n+\n       procedure convert_addresses\n-        (addrs  : System.Address;\n-         n_addr : Integer;\n-         buf    : System.Address;\n-         len    : System.Address);\n+        (filename : System.Address;\n+         addrs    : System.Address;\n+         n_addrs  : Integer;\n+         buf      : System.Address;\n+         len      : System.Address);\n       pragma Import (C, convert_addresses, \"convert_addresses\");\n-      --  This is the procedure version of the Ada aware addr2line that will\n-      --  use argv[0] as the executable containing the debug information.\n+      --  This is the procedure version of the Ada aware addr2line.  It places\n+      --  in BUF a string representing the symbolic translation of the N_ADDRS\n+      --  raw addresses provided in ADDRS, looked up in debug information from\n+      --  FILENAME.  LEN is filled with the result length.\n+      --\n       --  This procedure is provided by libaddr2line on targets that support\n-      --  it. A dummy version is in a-adaint.c for other targets so that build\n+      --  it. A dummy version is in adaint.c for other targets so that build\n       --  of shared libraries doesn't generate unresolved symbols.\n       --\n       --  Note that this procedure is *not* thread-safe.\n \n+      type Argv_Array is array (0 .. 0) of System.Address;\n+      gnat_argv : access Argv_Array;\n+      pragma Import (C, gnat_argv, \"gnat_argv\");\n+\n+      function locate_exec_on_path\n+        (c_exename : System.Address) return System.Address;\n+      pragma Import (C, locate_exec_on_path, \"__gnat_locate_exec_on_path\");\n+\n       Res : String (1 .. 256 * Traceback'Length);\n       Len : Integer;\n \n+      use type System.Address;\n+\n    begin\n-      if Traceback'Length > 0 then\n-         TSL.Lock_Task.all;\n+      --  The symbolic translation of an empty set of addresses is the\n+      --  the empty string.\n+\n+      if Traceback'Length <= 0 then\n+         return \"\";\n+      end if;\n+\n+      --  If our input set of raw addresses is not empty, resort to the\n+      --  libaddr2line service to symbolize it all.\n+\n+      --  Compute, cache and provide the absolute path to our executable file\n+      --  name as the binary file where the relevant debug information is to\n+      --  be found. If the executable file name resolution fails, we have no\n+      --  sensible basis to invoke the symbolizer at all.\n+\n+      --  Protect all this against concurrent accesses explicitely, as the\n+      --  underlying services are potentially thread unsafe.\n+\n+      TSL.Lock_Task.all;\n+\n+      if not Exename_Resolved then\n+         Exename := locate_exec_on_path (gnat_argv (0));\n+         Exename_Resolved := True;\n+      end if;\n+\n+      if Exename /= System.Null_Address then\n          convert_addresses\n-           (Traceback'Address, Traceback'Length, Res (1)'Address, Len'Address);\n-         TSL.Unlock_Task.all;\n+           (Exename, Traceback'Address, Traceback'Length,\n+            Res (1)'Address, Len'Address);\n+      end if;\n+\n+      TSL.Unlock_Task.all;\n+\n+      --  Return what the addr2line symbolizer has produced if we have called\n+      --  it (the executable name resolution succeeded), or an empty string\n+      --  otherwise.\n+\n+      if Exename /= System.Null_Address then\n          return Res (1 .. Len);\n       else\n          return \"\";\n       end if;\n+\n    end Symbolic_Traceback;\n \n    function Symbolic_Traceback (E : Exception_Occurrence) return String is"}, {"sha": "e45e12c000d4ad5999643ea889b02ed2682bc8c5", "filename": "gcc/ada/gmem.c", "status": "modified", "additions": 37, "deletions": 15, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c99c095f991024052fcf8d32d230ce448edc2d81/gcc%2Fada%2Fgmem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c99c095f991024052fcf8d32d230ce448edc2d81/gcc%2Fada%2Fgmem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgmem.c?ref=c99c095f991024052fcf8d32d230ce448edc2d81", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *         Copyright (C) 2000-2003 Free Software Foundation, Inc.           *\n+ *         Copyright (C) 2000-2006, Free Software Foundation, Inc.          *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -54,7 +54,7 @@ static FILE *gmemfile;\n \n /* tb_len is the number of call level supported by this module */\n #define tb_len 200\n-static char * tracebk [tb_len];\n+static void * tracebk [tb_len];\n static int cur_tb_len, cur_tb_pos;\n \n #define LOG_EOF   '*'\n@@ -67,8 +67,34 @@ struct struct_storage_elmt {\n   size_t Size;\n };\n \n-extern void\n-convert_addresses (char *addrs[], int n_addr, void *buf, int *len);\n+static void\n+__gnat_convert_addresses (void *addrs[], int n_addrs, void *buf, int *len);\n+/* Place in BUF a string representing the symbolic translation of N_ADDRS raw\n+   addresses provided in ADDRS.  LEN is filled with the result length.\n+\n+   This is a GNAT specific interface to the libaddr2line convert_addresses\n+   routine.  The latter examines debug info from a provided executable file\n+   name to perform the translation into symbolic form of an input sequence of\n+   raw binary addresses.  It attempts to open the file from the provided name\n+   \"as is\", so an an absolute path must be provided to ensure the file is\n+   always found.  We compute this name once, at initialization time.  */\n+\n+static const char * exename = 0;\n+\n+extern void convert_addresses (const char * , void *[], int, void *, int *);\n+extern char  *__gnat_locate_exec_on_path (char *);\n+/* ??? Both of these extern functions are prototyped in adaint.h, which\n+   also refers to \"time_t\" hence needs complex extra header inclusions to\n+   be satisfied on every target.  */\n+\n+static void\n+__gnat_convert_addresses (void *addrs[], int n_addrs, void *buf, int *len)\n+{\n+  if (exename != 0)\n+    convert_addresses (exename, addrs, n_addrs, buf, len);\n+  else\n+    *len = 0;\n+}\n \n /* reads backtrace information from gmemfile placing them in tracebk\n    array. cur_tb_len is the size of this array\n@@ -78,7 +104,7 @@ static void\n gmem_read_backtrace (void)\n {\n   fread (&cur_tb_len, sizeof (int), 1, gmemfile);\n-  fread (tracebk, sizeof (char *), cur_tb_len, gmemfile);\n+  fread (tracebk, sizeof (void *), cur_tb_len, gmemfile);\n   cur_tb_pos = 0;\n }\n \n@@ -106,14 +132,11 @@ int __gnat_gmem_initialize (char *dumpname)\n \n /* initialize addr2line library */\n \n-void __gnat_gmem_a2l_initialize (char *exename)\n+void __gnat_gmem_a2l_initialize (char *exearg)\n {\n-  extern char **gnat_argv;\n-  char s [100];\n-  int l;\n-\n-  gnat_argv [0] = exename;\n-  convert_addresses (tracebk, 1, s, &l);\n+  /* Resolve the executable filename to use in later invocations of\n+     the libaddr2line symbolization service.  */\n+  exename = __gnat_locate_exec_on_path (exearg);\n }\n \n /* Read next allocation of deallocation information from the GMEM file and\n@@ -172,8 +195,7 @@ void __gnat_gmem_read_next_frame (void** addr)\n \n void __gnat_gmem_symbolic (void * addr, char* buf, int* length)\n {\n-  char* addresses [] = { (char*)addr };\n-  extern char** gnat_argv;\n+  void * addresses [] = { addr };\n \n-  convert_addresses (addresses, 1, buf, length);\n+  __gnat_convert_addresses (addresses, 1, buf, length);\n }"}]}