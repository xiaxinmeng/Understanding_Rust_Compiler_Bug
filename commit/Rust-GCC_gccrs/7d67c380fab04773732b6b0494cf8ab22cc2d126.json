{"sha": "7d67c380fab04773732b6b0494cf8ab22cc2d126", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Q2N2MzODBmYWIwNDc3MzczMmI2YjA0OTRjZjhhYjIyY2MyZDEyNg==", "commit": {"author": {"name": "Olivier Hainque", "email": "hainque@adacore.com", "date": "2012-05-15T14:03:04Z"}, "committer": {"name": "Olivier Hainque", "email": "hainque@gcc.gnu.org", "date": "2012-05-15T14:03:04Z"}, "message": "aix-unwind.h (*_REGNO): New, set of useful register numbers.\n\n\tlibgcc/\n\t* config/rs6000/aix-unwind.h (*_REGNO): New, set of useful\n\tregister numbers. LR_REGNO replaces R_LR.\n\t(ucontext_for): New, helper for ...\n\t(ppc_aix_fallback_frame_state): New, implementation for aix 5.2\n\tand 5.3 of ...\n\t(MD_FALLBACK_FRAME_STATE_FOR): Define for 32bit configurations.\n\n\ttestsuite/\n\t* g++.dg/eh/sighandle.C: New testcase.\n\nFrom-SVN: r187540", "tree": {"sha": "0575010987982fd59a3c499cb0ae2429400bb409", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0575010987982fd59a3c499cb0ae2429400bb409"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d67c380fab04773732b6b0494cf8ab22cc2d126", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d67c380fab04773732b6b0494cf8ab22cc2d126", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d67c380fab04773732b6b0494cf8ab22cc2d126", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d67c380fab04773732b6b0494cf8ab22cc2d126/comments", "author": {"login": "hainque", "id": 18735142, "node_id": "MDQ6VXNlcjE4NzM1MTQy", "avatar_url": "https://avatars.githubusercontent.com/u/18735142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hainque", "html_url": "https://github.com/hainque", "followers_url": "https://api.github.com/users/hainque/followers", "following_url": "https://api.github.com/users/hainque/following{/other_user}", "gists_url": "https://api.github.com/users/hainque/gists{/gist_id}", "starred_url": "https://api.github.com/users/hainque/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hainque/subscriptions", "organizations_url": "https://api.github.com/users/hainque/orgs", "repos_url": "https://api.github.com/users/hainque/repos", "events_url": "https://api.github.com/users/hainque/events{/privacy}", "received_events_url": "https://api.github.com/users/hainque/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7d80ca1f439cd6be490336659740ca6d8a06db40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d80ca1f439cd6be490336659740ca6d8a06db40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d80ca1f439cd6be490336659740ca6d8a06db40"}], "stats": {"total": 257, "additions": 253, "deletions": 4}, "files": [{"sha": "0c7e44a86881d0b66b52e65c240f2d24520db755", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d67c380fab04773732b6b0494cf8ab22cc2d126/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d67c380fab04773732b6b0494cf8ab22cc2d126/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7d67c380fab04773732b6b0494cf8ab22cc2d126", "patch": "@@ -1,3 +1,7 @@\n+2012-05-15  Olivier Hainque  <hainque@adacore.com>\n+\n+\t* g++.dg/eh/sighandle.C: New testcase.\n+\n 2012-05-15  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/53355"}, {"sha": "e516ad0a48388c0bf50fccad643a538d4933fc61", "filename": "gcc/testsuite/g++.dg/eh/sighandle.C", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d67c380fab04773732b6b0494cf8ab22cc2d126/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fsighandle.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d67c380fab04773732b6b0494cf8ab22cc2d126/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fsighandle.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fsighandle.C?ref=7d67c380fab04773732b6b0494cf8ab22cc2d126", "patch": "@@ -0,0 +1,38 @@\n+// { dg-do run { target { *-*-aix5* i?86-*-linux* x86_64-*-linux* } } }\n+// { dg-options \"-fexceptions -fnon-call-exceptions\" }\n+\n+#include <signal.h>\n+#include <stdlib.h>\n+\n+void sighandler (int signo, siginfo_t * si, void * uc)\n+{\n+  throw (5);\n+}\n+\n+char * dosegv ()\n+{    \n+  * ((volatile int *)0) = 12;\n+}\n+\n+int main ()\n+{\n+  struct sigaction sa;\n+  int status;\n+\n+  sa.sa_sigaction = sighandler;\n+  sa.sa_flags = SA_SIGINFO;\n+    \n+  status = sigaction (SIGSEGV, & sa, NULL);\n+  status = sigaction (SIGBUS, & sa, NULL);\n+\n+  try {\n+    dosegv ();\n+  }\n+  catch (int x) {\n+    return (x != 5);\n+  }\n+\n+  return 1;\n+}\n+\n+"}, {"sha": "c020e8efdb1b7e989a0e0d2ce56aec69bcb8a51d", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d67c380fab04773732b6b0494cf8ab22cc2d126/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d67c380fab04773732b6b0494cf8ab22cc2d126/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=7d67c380fab04773732b6b0494cf8ab22cc2d126", "patch": "@@ -1,3 +1,12 @@\n+2012-05-15  Olivier Hainque  <hainque@adacore.com>\n+\n+\t* config/rs6000/aix-unwind.h (*_REGNO): New, set of useful\n+\tregister numbers. LR_REGNO replaces R_LR.\n+\t(ucontext_for): New, helper for ...\n+\t(ppc_aix_fallback_frame_state): New, implementation for aix 5.2\n+\tand 5.3 of ...\n+\t(MD_FALLBACK_FRAME_STATE_FOR): Define for 32bit configurations.\n+\n 2012-05-10  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* config.host (i[34567]86-*-linux*, x86_64-*-linux*)"}, {"sha": "90431a4e3d762a65f516909ae3f298fd5fc56101", "filename": "libgcc/config/rs6000/aix-unwind.h", "status": "modified", "additions": 202, "deletions": 4, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d67c380fab04773732b6b0494cf8ab22cc2d126/libgcc%2Fconfig%2Frs6000%2Faix-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d67c380fab04773732b6b0494cf8ab22cc2d126/libgcc%2Fconfig%2Frs6000%2Faix-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frs6000%2Faix-unwind.h?ref=7d67c380fab04773732b6b0494cf8ab22cc2d126", "patch": "@@ -22,22 +22,29 @@\n    see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n    <http://www.gnu.org/licenses/>.  */\n \n+/* Useful register numbers.  */\n+\n+#define LR_REGNO             65\n+#define CR2_REGNO            70\n+#define XER_REGNO            76\n+#define FIRST_ALTIVEC_REGNO  77\n+#define VRSAVE_REGNO        109\n+#define VSCR_REGNO          110\n+\n /* If the current unwind info (FS) does not contain explicit info\n    saving R2, then we have to do a minor amount of code reading to\n    figure out if it was saved.  The big problem here is that the\n    code that does the save/restore is generated by the linker, so\n    we have no good way to determine at compile time what to do.  */\n \n-#define R_LR 65\n-\n #ifdef __64BIT__\n #define MD_FROB_UPDATE_CONTEXT(CTX, FS)\t\t\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n     if ((FS)->regs.reg[2].how == REG_UNSAVED)\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n \tunsigned int *insn\t\t\t\t\t\t\\\n \t  = (unsigned int *)\t\t\t\t\t\t\\\n-\t    _Unwind_GetGR ((CTX), R_LR);\t\t\t\t\\\n+\t    _Unwind_GetGR ((CTX), LR_REGNO);\t\t\t\t\\\n \tif (*insn == 0xE8410028)\t\t\t\t\t\\\n \t  _Unwind_SetGRPtr ((CTX), 2, (CTX)->cfa + 40);\t\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n@@ -49,9 +56,200 @@\n       {\t\t\t\t\t\t\t\t\t\\\n \tunsigned int *insn\t\t\t\t\t\t\\\n \t  = (unsigned int *)\t\t\t\t\t\t\\\n-\t    _Unwind_GetGR ((CTX), R_LR);\t\t\t\t\\\n+\t    _Unwind_GetGR ((CTX), LR_REGNO);\t\t\t\t\\\n \tif (*insn == 0x80410014)\t\t\t\t\t\\\n \t  _Unwind_SetGRPtr ((CTX), 2, (CTX)->cfa + 20);\t\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n   } while (0)\n #endif\n+\n+/* Now on to MD_FALLBACK_FRAME_STATE_FOR.\n+   32bit AIX 5.2 and 5.3 only at this stage.  */\n+\n+#include <stdlib.h>\n+#include <stddef.h>\n+#include <signal.h>\n+#include <sys/machine.h>\n+\n+#ifdef __64BIT__\n+\n+/* 64bit fallback not implemented yet, so MD_FALLBACK_FRAME_STATE_FOR not\n+   defined.  Arrange just for the code below to compile.  */\n+typedef struct __context64 mstate_t;\n+\n+#else\n+\n+typedef struct mstsave mstate_t;\n+\n+#define MD_FALLBACK_FRAME_STATE_FOR ppc_aix_fallback_frame_state\n+\n+#endif\n+\n+/* If we are compiling on AIX < 5.3, the VMX related datastructs are not\n+   defined and we take measures to obtain proper runtime behavior if the\n+   compiled code happens to run on a later version with VMX enabled.  */\n+\n+#ifndef MSR_VMX\n+#define MSR_VMX 0x2000000\n+#endif\n+\n+typedef unsigned int uint;\n+typedef struct { uint v[4]; } vreg_t;\n+typedef struct {\n+  vreg_t regs[32];\n+  uint   pad1 [3];\n+  uint   vscr;\n+  uint   vrsave;\n+  uint   pad2 [3];\n+} vstate_t;\n+\n+#define EXT_CONTEXT_MARK 0x45435458\n+#define EXT_CONTEXT_SIZE 4096\n+#define BUMPER_SIZE (EXT_CONTEXT_SIZE - sizeof(vstate_t) - (5 * sizeof(int)))\n+\n+typedef struct {\n+  uint     pad1 [4];\n+  vstate_t vstate;\n+  char     bumper [BUMPER_SIZE];\n+  int      mark; \n+} extended_context_t;\n+\n+typedef struct {\n+  char bumper [offsetof (ucontext_t, uc_stack) + sizeof (stack_t)];\n+  extended_context_t * ectx;\n+  int mark;\n+} vmx_ucontext_t;\n+\n+/* Determine whether CONTEXT designates a signal handler, and return the\n+   associated ucontext_t address if so.  Return NULL otherwise.  */\n+\n+static ucontext_t *\n+ucontext_for (struct _Unwind_Context *context)\n+{\n+  const unsigned int * ra = context->ra;\n+\n+  /* AIX 5.2 and 5.3, threaded or not, share common patterns and feature\n+     variants depending on the configured kernel (unix_mp or unix_64).  */\n+\n+  if (*(ra - 5) == 0x4c00012c     /* isync             */\n+      && *(ra - 4) == 0x80ec0000  /* lwz     r7,0(r12) */\n+      && *(ra - 3) == 0x804c0004  /* lwz     r2,4(r12) */\n+      && *(ra - 2) == 0x7ce903a6  /* mtctr   r7        */\n+      && *(ra - 1) == 0x4e800421  /* bctrl             */\n+      && *(ra - 0) == 0x7dc37378) /* mr      r3,r14   <-- context->ra */\n+    {\n+      /* unix_64 */\n+      if (*(ra - 6) == 0x7d000164)  /* mtmsrd  r8 */\n+\t{\n+\t  switch (*(ra + 18))\n+\t    {\n+\t      /* AIX 5.2 */\n+\t    case 0x835a0520: /* lwz r26,1312(r26) */ \n+\t      return (ucontext_t *)(context->cfa + 0x70);\n+\n+\t      /* AIX 5.3 */\n+\t    case 0x835a0570:  /* lwz r26,1392(r26) */\n+\t      return (ucontext_t *)(context->cfa + 0x40);\n+\t\t\n+\t    default:\n+\t      return 0;\n+\t    }\n+\t}\n+\n+      /* unix_mp */\n+      if (*(ra - 6) == 0x7d000124)  /* mtmsr  r8 */\n+\t{\n+\t  typedef struct {\n+\t    char pad[56];\n+\t    ucontext_t ucontext;\n+\t    siginfo_t siginfo;\n+\t  } aix52_stack_t;\n+\n+\t  aix52_stack_t * frame = (aix52_stack_t *) context->cfa;\n+\t  return &frame->ucontext;\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n+/* The fallback proper.  */\n+\n+#ifdef DWARF_ALT_FRAME_RETURN_COLUMN\n+#define RETURN_COLUMN DWARF_ALT_FRAME_RETURN_COLUMN\n+#else\n+#define RETURN_COLUMN ARG_POINTER_REGNUM\n+#endif\n+\n+#define REGISTER_CFA_OFFSET_FOR(FS,REGNO,ADDR,CFA)\\\n+do { \\\n+(FS)->regs.reg[REGNO].how = REG_SAVED_OFFSET; \\\n+(FS)->regs.reg[REGNO].loc.offset = (long) (ADDR) - (CFA); \\\n+} while (0);\n+\n+static _Unwind_Reason_Code\n+ppc_aix_fallback_frame_state (struct _Unwind_Context *context,\n+\t\t\t      _Unwind_FrameState *fs)\n+{\n+  ucontext_t * uctx = ucontext_for (context);\n+  mstate_t * mctx;\n+\n+  long new_cfa;\n+  int i;\n+\n+  if (uctx == NULL)\n+    return _URC_END_OF_STACK;\n+\n+  mctx = &uctx->uc_mcontext.jmp_context;\n+\n+  /* The \"kernel\" frame cfa is the stack pointer at the signal occurrence\n+     point.  */\n+  new_cfa = mctx->gpr[STACK_POINTER_REGNUM];\n+\n+  fs->regs.cfa_how = CFA_REG_OFFSET;\n+  fs->regs.cfa_reg = STACK_POINTER_REGNUM;\n+  fs->regs.cfa_offset = new_cfa - (long) context->cfa;\n+\n+  /* And we state how to find the various registers it has saved with\n+     relative offset rules from there.  */\n+\n+  for (i = 0; i < 32; i++)\n+    if (i != STACK_POINTER_REGNUM)\n+      REGISTER_CFA_OFFSET_FOR (fs, i, &mctx->gpr[i], new_cfa);\n+\n+  REGISTER_CFA_OFFSET_FOR (fs, CR2_REGNO, &mctx->cr, new_cfa);\n+  REGISTER_CFA_OFFSET_FOR (fs, XER_REGNO, &mctx->xer, new_cfa);\n+  REGISTER_CFA_OFFSET_FOR (fs, LR_REGNO, &mctx->lr, new_cfa);\n+\n+  fs->retaddr_column = RETURN_COLUMN;\n+  REGISTER_CFA_OFFSET_FOR (fs, RETURN_COLUMN, &mctx->iar, new_cfa);\n+  fs->signal_frame = 1;\n+\n+  /* Honor FP Ever Used ...   */\n+  if (mctx->fpeu)\n+    {\n+      for (i = 0; i < 32; i++)\n+\tREGISTER_CFA_OFFSET_FOR (fs, i+32, &mctx->fpr[i], new_cfa);\n+    }\n+\n+  /* Honor VMX context, if any.  We expect the msr bit never to be set in\n+     environments where there is no VMX support, e.g. on AIX < 5.3.  */\n+  if (mctx->msr & MSR_VMX)\n+    {\n+      vmx_ucontext_t * uc = (vmx_ucontext_t *) uctx;\n+\n+      if (uc->mark == EXT_CONTEXT_MARK && uc->ectx->mark == EXT_CONTEXT_MARK)\n+\t{\n+\t  vstate_t * vstate = &uc->ectx->vstate;\n+\n+\t  for (i = 0; i < 32; i++)\n+\t    REGISTER_CFA_OFFSET_FOR\n+\t    (fs, i+FIRST_ALTIVEC_REGNO, &vstate->regs[i], new_cfa);\n+\n+\t  REGISTER_CFA_OFFSET_FOR (fs, VSCR_REGNO, &vstate->vscr, new_cfa);\n+\t  REGISTER_CFA_OFFSET_FOR (fs, VRSAVE_REGNO, &vstate->vrsave, new_cfa);\n+\t}\n+    }\n+\n+  return _URC_NO_REASON;\n+}"}]}