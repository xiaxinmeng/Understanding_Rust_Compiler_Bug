{"sha": "ded6a1953dd7f43229c44e5d0d17c264338a3f4c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGVkNmExOTUzZGQ3ZjQzMjI5YzQ0ZTVkMGQxN2MyNjQzMzhhM2Y0Yw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2021-03-08T18:01:21Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2021-03-08T18:08:51Z"}, "message": "c++: Incorrect specialization hash table [PR 99285]\n\nClass template partial specializations need to be in the\nspecialization hash, but not all of them.  This defers adding\nstreamed-in entities to the hash table, in the same way I deferred\nadding the instantiation and specialization lists for 99170.\n\n\tPR c++/99285\n\tgcc/cp/\n\t* cp-tree.h (match_mergeable_specialization)\n\t(add_mergeable_specialization): Adjust parms.\n\t* module.cc (trees_in::decl_value): Adjust\n\tadd_mergeable_specialization calls.\n\t(trees_out::key_mergeable): Adjust match_mergeable_specialization\n\tcalls.\n\t(specialization_add): Likewise.\n\t* pt.c (match_mergeable_specialization): Do not insert.\n\t(add_mergeable_specialization): Add to hash table here.\n\tgcc/testsuite/\n\t* g++.dg/modules/pr99285_a.H: New.\n\t* g++.dg/modules/pr99285_b.H: New.", "tree": {"sha": "d6152c9982472c8080f11a2ff4337bea81d68295", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d6152c9982472c8080f11a2ff4337bea81d68295"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ded6a1953dd7f43229c44e5d0d17c264338a3f4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ded6a1953dd7f43229c44e5d0d17c264338a3f4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ded6a1953dd7f43229c44e5d0d17c264338a3f4c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ded6a1953dd7f43229c44e5d0d17c264338a3f4c/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d9a70ea3881c284b7689b691d54d047b55b486d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d9a70ea3881c284b7689b691d54d047b55b486d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d9a70ea3881c284b7689b691d54d047b55b486d"}], "stats": {"total": 105, "additions": 71, "deletions": 34}, "files": [{"sha": "81ff375f8a5a93b16bd1ecd16ae27d7004f152fd", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ded6a1953dd7f43229c44e5d0d17c264338a3f4c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ded6a1953dd7f43229c44e5d0d17c264338a3f4c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=ded6a1953dd7f43229c44e5d0d17c264338a3f4c", "patch": "@@ -7239,11 +7239,10 @@ extern void walk_specializations\t\t(bool,\n \t\t\t\t\t\t void (*)(bool, spec_entry *,\n \t\t\t\t\t\t\t  void *),\n \t\t\t\t\t\t void *);\n-extern tree match_mergeable_specialization\t(bool is_decl, spec_entry *,\n-\t\t\t\t\t\t bool insert = true);\n+extern tree match_mergeable_specialization\t(bool is_decl, spec_entry *);\n extern unsigned get_mergeable_specialization_flags (tree tmpl, tree spec);\n-extern void add_mergeable_specialization        (tree tmpl, tree args,\n-\t\t\t\t\t\t tree spec, unsigned);\n+extern void add_mergeable_specialization        (bool is_decl, spec_entry *,\n+\t\t\t\t\t\t tree outer, unsigned);\n extern tree add_outermost_template_args\t\t(tree, tree);\n extern tree add_extra_args\t\t\t(tree, tree);\n extern tree build_extra_args\t\t\t(tree, tree, tsubst_flags_t);"}, {"sha": "2518d73c22067e76e2bf4244d1f7ed92d5926e87", "filename": "gcc/cp/module.cc", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ded6a1953dd7f43229c44e5d0d17c264338a3f4c/gcc%2Fcp%2Fmodule.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ded6a1953dd7f43229c44e5d0d17c264338a3f4c/gcc%2Fcp%2Fmodule.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmodule.cc?ref=ded6a1953dd7f43229c44e5d0d17c264338a3f4c", "patch": "@@ -8059,9 +8059,14 @@ trees_in::decl_value ()\n \tset_constraints (decl, spec.spec);\n       if (mk & MK_template_mask\n \t  || mk == MK_partial)\n-\t/* Add to specialization tables now that constraints etc are\n-\t   added.  */\n-\tadd_mergeable_specialization (spec.tmpl, spec.args, decl, spec_flags);\n+\t{\n+\t  /* Add to specialization tables now that constraints etc are\n+\t     added.  */\n+\t  bool is_decl = (mk & MK_template_mask) && (mk & MK_tmpl_decl_mask);\n+\n+\t  spec.spec = is_decl ? inner : type;\n+\t  add_mergeable_specialization (is_decl, &spec, decl, spec_flags);\n+\t}\n \n       if (TREE_CODE (decl) == INTEGER_CST && !TREE_OVERFLOW (decl))\n \t{\n@@ -8154,7 +8159,10 @@ trees_in::decl_value ()\n     {\n       tree e = match_mergeable_specialization (true, &spec);\n       if (!e)\n-\tadd_mergeable_specialization (spec.tmpl, spec.args, decl, spec_flags);\n+\t{\n+\t  spec.spec = inner;\n+\t  add_mergeable_specialization (true, &spec, decl, spec_flags);\n+\t}\n       else if (e != existing)\n \tset_overrun ();\n     }\n@@ -10344,14 +10352,14 @@ trees_out::key_mergeable (int tag, merge_kind mk, tree decl, tree inner,\n \t{\n \t  /* Make sure we can locate the decl.  */\n \t  tree existing = match_mergeable_specialization\n-\t    (bool (mk & MK_tmpl_decl_mask), entry, false);\n+\t    (bool (mk & MK_tmpl_decl_mask), entry);\n \n \t  gcc_assert (existing);\n \t  if (mk & MK_tmpl_decl_mask)\n \t    {\n \t      if (mk & MK_tmpl_alias_mask)\n \t\t/* It should be in both tables.  */\n-\t\tgcc_assert (match_mergeable_specialization (false, entry, false)\n+\t\tgcc_assert (match_mergeable_specialization (false, entry)\n \t\t\t    == TREE_TYPE (existing));\n \t      else if (mk & MK_tmpl_tmpl_mask)\n \t\tif (tree ti = DECL_TEMPLATE_INFO (existing))\n@@ -10659,6 +10667,7 @@ trees_in::key_mergeable (int tag, merge_kind mk, tree decl, tree inner,\n \n   if (mk & MK_template_mask)\n     {\n+      // FIXME: We could stream the specialization hash?\n       spec_entry spec;\n       spec.tmpl = tree_node ();\n       spec.args = tree_node ();\n@@ -12869,7 +12878,7 @@ specialization_add (bool decl_p, spec_entry *entry, void *data_)\n        /* Only alias templates can appear in both tables (and\n \t  if they're in the type table they must also be in the decl table).  */\n        gcc_checking_assert\n-\t (!match_mergeable_specialization (true, entry, false)\n+\t (!match_mergeable_specialization (true, entry)\n \t  == (decl_p || !DECL_ALIAS_TEMPLATE_P (entry->tmpl)));\n     }\n   else if (VAR_OR_FUNCTION_DECL_P (entry->spec))"}, {"sha": "5e485f10d19f7464330f22f3870bb50027099956", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 34, "deletions": 23, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ded6a1953dd7f43229c44e5d0d17c264338a3f4c/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ded6a1953dd7f43229c44e5d0d17c264338a3f4c/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=ded6a1953dd7f43229c44e5d0d17c264338a3f4c", "patch": "@@ -29955,28 +29955,19 @@ walk_specializations (bool decls_p,\n }\n \n /* Lookup the specialization of *ELT, in the decl or type\n-   specialization table.  Return the SPEC that's already there (NULL if\n-   nothing).  If INSERT is true, and there was nothing, add the new\n-   spec.  */\n+   specialization table.  Return the SPEC that's already there, or\n+   NULL if nothing.  */\n \n tree\n-match_mergeable_specialization (bool decl_p, spec_entry *elt, bool insert)\n+match_mergeable_specialization (bool decl_p, spec_entry *elt)\n {\n   hash_table<spec_hasher> *specializations\n     = decl_p ? decl_specializations : type_specializations;\n   hashval_t hash = spec_hasher::hash (elt);\n-  spec_entry **slot\n-    = specializations->find_slot_with_hash (elt, hash,\n-\t\t\t\t\t    insert ? INSERT : NO_INSERT);\n-  if (slot && *slot)\n-    return (*slot)->spec;\n+  auto *slot = specializations->find_slot_with_hash (elt, hash, NO_INSERT);\n \n-  if (insert)\n-    {\n-      auto entry = ggc_alloc<spec_entry> ();\n-      *entry = *elt;\n-      *slot = entry;\n-    }\n+  if (slot)\n+    return (*slot)->spec;\n \n   return NULL_TREE;\n }\n@@ -30012,23 +30003,43 @@ get_mergeable_specialization_flags (tree tmpl, tree decl)\n   return flags;\n }\n \n-/* Add a new specialization of TMPL.  FLAGS is as returned from\n+/* Add a new specialization described by SPEC.  DECL is the\n+   maybe-template decl and FLAGS is as returned from\n    get_mergeable_specialization_flags.  */\n \n void\n-add_mergeable_specialization (tree tmpl, tree args, tree decl, unsigned flags)\n+add_mergeable_specialization (bool decl_p, spec_entry *elt,\n+\t\t\t      tree decl, unsigned flags)\n {\n+  hash_table<spec_hasher> *specializations\n+    = decl_p ? decl_specializations : type_specializations;\n+\n+  hashval_t hash = spec_hasher::hash (elt);\n+  auto *slot = specializations->find_slot_with_hash (elt, hash, INSERT);\n+\n+  /* We don't distinguish different constrained partial type\n+     specializations, so there could be duplicates.  Everything else\n+     must be new.   */\n+  if (!(flags & 2 && *slot))\n+    {\n+      gcc_checking_assert (!*slot);\n+\n+      auto entry = ggc_alloc<spec_entry> ();\n+      *entry = *elt;\n+      *slot = entry;\n+    }\n+\n   if (flags & 1)\n-    DECL_TEMPLATE_INSTANTIATIONS (tmpl)\n-      = tree_cons (args, decl, DECL_TEMPLATE_INSTANTIATIONS (tmpl));\n+    DECL_TEMPLATE_INSTANTIATIONS (elt->tmpl)\n+      = tree_cons (elt->args, decl, DECL_TEMPLATE_INSTANTIATIONS (elt->tmpl));\n \n   if (flags & 2)\n     {\n       /* A partial specialization.  */\n-      DECL_TEMPLATE_SPECIALIZATIONS (tmpl)\n-\t= tree_cons (args, decl, DECL_TEMPLATE_SPECIALIZATIONS (tmpl));\n-      TREE_TYPE (DECL_TEMPLATE_SPECIALIZATIONS (tmpl))\n-\t= TREE_TYPE (DECL_TEMPLATE_RESULT (decl));\n+      tree cons = tree_cons (elt->args, decl,\n+\t\t\t     DECL_TEMPLATE_SPECIALIZATIONS (elt->tmpl));\n+      TREE_TYPE (cons) = elt->spec;\n+      DECL_TEMPLATE_SPECIALIZATIONS (elt->tmpl) = cons;\n     }\n }\n "}, {"sha": "14d0aa06c0362d4fb650b8518cbd707179e41e45", "filename": "gcc/testsuite/g++.dg/modules/pr99285_a.H", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ded6a1953dd7f43229c44e5d0d17c264338a3f4c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99285_a.H", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ded6a1953dd7f43229c44e5d0d17c264338a3f4c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99285_a.H", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99285_a.H?ref=ded6a1953dd7f43229c44e5d0d17c264338a3f4c", "patch": "@@ -0,0 +1,11 @@\n+// PR 99285 ICE with template-template-parm\n+// { dg-additional-options -fmodule-header }\n+// { dg-module-cmi {} }\n+\n+template<typename... _Tp> struct common_type;\n+\n+template<> struct common_type<> {};\n+\n+template<typename _Tp0> struct common_type<_Tp0> {};\n+\n+template<typename _Tp1, typename _Tp2> struct common_type<_Tp1, _Tp2> {};"}, {"sha": "01a8eaf62286d7828fd0e498a781c00b3a739574", "filename": "gcc/testsuite/g++.dg/modules/pr99285_b.H", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ded6a1953dd7f43229c44e5d0d17c264338a3f4c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99285_b.H", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ded6a1953dd7f43229c44e5d0d17c264338a3f4c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99285_b.H", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99285_b.H?ref=ded6a1953dd7f43229c44e5d0d17c264338a3f4c", "patch": "@@ -0,0 +1,7 @@\n+// { dg-additional-options -fmodule-header }\n+// { dg-module-cmi {} }\n+import  \"pr99285_a.H\";\n+\n+template<typename _Rep1, typename _Rep2,\n+\t typename _CRep = typename common_type<_Rep1, _Rep2>::type>\n+struct X;"}]}