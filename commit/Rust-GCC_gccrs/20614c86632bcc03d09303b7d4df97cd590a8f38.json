{"sha": "20614c86632bcc03d09303b7d4df97cd590a8f38", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjA2MTRjODY2MzJiY2MwM2QwOTMwM2I3ZDRkZjk3Y2Q1OTBhOGYzOA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-09-12T12:15:07Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-09-12T12:15:07Z"}, "message": "name-lookup.c (get_class_binding): Rename TYPE arg to KLASS for consistency.\n\n\t* name-lookup.c (get_class_binding): Rename TYPE arg to KLASS for\n\tconsistency.\n\t(restort_data): Move later.\n\t(method_name_cmp, resort_method_name_cmp): Simplify.\n\t(resort_type_method_vec): Reformat.\n\nFrom-SVN: r252004", "tree": {"sha": "138b70cce478e351777fd086cec18f065a4cb931", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/138b70cce478e351777fd086cec18f065a4cb931"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/20614c86632bcc03d09303b7d4df97cd590a8f38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20614c86632bcc03d09303b7d4df97cd590a8f38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20614c86632bcc03d09303b7d4df97cd590a8f38", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20614c86632bcc03d09303b7d4df97cd590a8f38/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ec33aebb1cd640f0751614ccd1b759d0f41ffb2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec33aebb1cd640f0751614ccd1b759d0f41ffb2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec33aebb1cd640f0751614ccd1b759d0f41ffb2f"}], "stats": {"total": 105, "additions": 58, "deletions": 47}, "files": [{"sha": "1859023c036a0fc29017d4dba5fb50533e35a95c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20614c86632bcc03d09303b7d4df97cd590a8f38/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20614c86632bcc03d09303b7d4df97cd590a8f38/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=20614c86632bcc03d09303b7d4df97cd590a8f38", "patch": "@@ -1,3 +1,11 @@\n+2017-09-12  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* name-lookup.c (get_class_binding): Rename TYPE arg to KLASS for\n+\tconsistency.\n+\t(restort_data): Move later.\n+\t(method_name_cmp, resort_method_name_cmp): Simplify.\n+\t(resort_type_method_vec): Reformat.\n+\n 2017-09-09  Jason Merrill  <jason@redhat.com>\n \n \t* constexpr.c (reduced_constant_expression_p): If"}, {"sha": "a24018d9b6bfd0a922157519066cd87db9b87726", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 50, "deletions": 47, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20614c86632bcc03d09303b7d4df97cd590a8f38/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20614c86632bcc03d09303b7d4df97cd590a8f38/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=20614c86632bcc03d09303b7d4df97cd590a8f38", "patch": "@@ -1311,36 +1311,37 @@ get_class_binding_direct (tree klass, tree name, int type_or_fns)\n    special function creation as necessary.  */\n \n tree\n-get_class_binding (tree type, tree name, int type_or_fns)\n+get_class_binding (tree klass, tree name, int type_or_fns)\n {\n-  type = complete_type (type);\n+  klass = complete_type (klass);\n \n-  if (COMPLETE_TYPE_P (type))\n+  if (COMPLETE_TYPE_P (klass))\n     {\n+      /* Lazily declare functions, if we're going to search these.  */\n       if (IDENTIFIER_CTOR_P (name))\n \t{\n-\t  if (CLASSTYPE_LAZY_DEFAULT_CTOR (type))\n-\t    lazily_declare_fn (sfk_constructor, type);\n-\t  if (CLASSTYPE_LAZY_COPY_CTOR (type))\n-\t    lazily_declare_fn (sfk_copy_constructor, type);\n-\t  if (CLASSTYPE_LAZY_MOVE_CTOR (type))\n-\t    lazily_declare_fn (sfk_move_constructor, type);\n+\t  if (CLASSTYPE_LAZY_DEFAULT_CTOR (klass))\n+\t    lazily_declare_fn (sfk_constructor, klass);\n+\t  if (CLASSTYPE_LAZY_COPY_CTOR (klass))\n+\t    lazily_declare_fn (sfk_copy_constructor, klass);\n+\t  if (CLASSTYPE_LAZY_MOVE_CTOR (klass))\n+\t    lazily_declare_fn (sfk_move_constructor, klass);\n \t}\n-      else if (name == cp_assignment_operator_id (NOP_EXPR))\n+      else if (IDENTIFIER_DTOR_P (name))\n \t{\n-\t  if (CLASSTYPE_LAZY_COPY_ASSIGN (type))\n-\t    lazily_declare_fn (sfk_copy_assignment, type);\n-\t  if (CLASSTYPE_LAZY_MOVE_ASSIGN (type))\n-\t    lazily_declare_fn (sfk_move_assignment, type);\n+\t  if (CLASSTYPE_LAZY_DESTRUCTOR (klass))\n+\t    lazily_declare_fn (sfk_destructor, klass);\n \t}\n-      else if (IDENTIFIER_DTOR_P (name))\n+      else if (name == cp_assignment_operator_id (NOP_EXPR))\n \t{\n-\t  if (CLASSTYPE_LAZY_DESTRUCTOR (type))\n-\t    lazily_declare_fn (sfk_destructor, type);\n+\t  if (CLASSTYPE_LAZY_COPY_ASSIGN (klass))\n+\t    lazily_declare_fn (sfk_copy_assignment, klass);\n+\t  if (CLASSTYPE_LAZY_MOVE_ASSIGN (klass))\n+\t    lazily_declare_fn (sfk_move_assignment, klass);\n \t}\n     }\n \n-  return get_class_binding_direct (type, name, type_or_fns);\n+  return get_class_binding_direct (klass, name, type_or_fns);\n }\n \n /* Find the slot containing overloads called 'NAME'.  If there is no\n@@ -1411,56 +1412,58 @@ get_method_slot (tree klass, tree name)\n   return slot;\n }\n \n-static struct {\n-  gt_pointer_operator new_value;\n-  void *cookie;\n-} resort_data;\n-\n-/* Comparison function to compare two TYPE_METHOD_VEC entries by name.  */\n+/* Comparison function to compare two TYPE_METHOD_VEC entries by\n+   name.  */\n \n static int\n-method_name_cmp (const void* m1_p, const void* m2_p)\n+method_name_cmp (const void *a_p, const void *b_p)\n {\n-  const tree *const m1 = (const tree *) m1_p;\n-  const tree *const m2 = (const tree *) m2_p;\n+  tree a = *(const tree *)a_p;\n+  tree b = *(const tree *)b_p;\n+  tree name_a = DECL_NAME (TREE_CODE (a) == OVERLOAD ? OVL_FUNCTION (a) : a);\n+  tree name_b = DECL_NAME (TREE_CODE (b) == OVERLOAD ? OVL_FUNCTION (b) : b);\n \n-  if (OVL_NAME (*m1) < OVL_NAME (*m2))\n-    return -1;\n-  return 1;\n+  gcc_checking_assert (name_a && name_b && name_a != name_b);\n+  return name_a < name_b ? -1 : +1;\n }\n \n+static struct {\n+  gt_pointer_operator new_value;\n+  void *cookie;\n+} resort_data;\n+\n /* This routine compares two fields like method_name_cmp but using the\n-   pointer operator in resort_field_decl_data.  */\n+   pointer operator in resort_field_decl_data.  We don't have to deal\n+   with duplicates here.  */\n \n static int\n-resort_method_name_cmp (const void* m1_p, const void* m2_p)\n+resort_method_name_cmp (const void *a_p, const void *b_p)\n {\n-  const tree *const m1 = (const tree *) m1_p;\n-  const tree *const m2 = (const tree *) m2_p;\n+  tree a = *(const tree *)a_p;\n+  tree b = *(const tree *)b_p;\n+  tree name_a = OVL_NAME (a);\n+  tree name_b = OVL_NAME (b);\n+\n+  resort_data.new_value (&name_a, resort_data.cookie);\n+  resort_data.new_value (&name_b, resort_data.cookie);\n+\n+  gcc_checking_assert (name_a != name_b);\n \n-  tree n1 = OVL_NAME (*m1);\n-  tree n2 = OVL_NAME (*m2);\n-  resort_data.new_value (&n1, resort_data.cookie);\n-  resort_data.new_value (&n2, resort_data.cookie);\n-  if (n1 < n2)\n-    return -1;\n-  return 1;\n+  return name_a < name_b ? -1 : +1;\n }\n \n /* Resort TYPE_METHOD_VEC because pointers have been reordered.  */\n \n void\n-resort_type_method_vec (void* obj,\n-\t\t\tvoid* /*orig_obj*/,\n-\t\t\tgt_pointer_operator new_value,\n-\t\t\tvoid* cookie)\n+resort_type_method_vec (void *obj, void */*orig_obj*/,\n+\t\t\tgt_pointer_operator new_value, void* cookie)\n {\n   if (vec<tree, va_gc> *method_vec = (vec<tree, va_gc> *) obj)\n     {\n       resort_data.new_value = new_value;\n       resort_data.cookie = cookie;\n-      qsort (method_vec->address (), method_vec->length (), sizeof (tree),\n-\t     resort_method_name_cmp);\n+      qsort (method_vec->address (), method_vec->length (),\n+\t     sizeof (tree), resort_method_name_cmp);\n     }\n }\n "}]}