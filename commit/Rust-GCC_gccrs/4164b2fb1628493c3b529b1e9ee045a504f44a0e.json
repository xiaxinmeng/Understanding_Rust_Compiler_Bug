{"sha": "4164b2fb1628493c3b529b1e9ee045a504f44a0e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDE2NGIyZmIxNjI4NDkzYzNiNTI5YjFlOWVlMDQ1YTUwNGY0NGEwZQ==", "commit": {"author": {"name": "Paul Brook", "email": "paul@codesourcery.com", "date": "2005-08-03T13:07:31Z"}, "committer": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2005-08-03T13:07:31Z"}, "message": "combine.c (can_change_dest_mode): New function.\n\n2005-08-03  Paul Brook  <paul@codesourcery.com>\n\n\t* combine.c (can_change_dest_mode): New function.\n\t(try_combine, simplify_set): Use it.\n\nFrom-SVN: r102686", "tree": {"sha": "d1aef2b428dd98d35f2e112642326ee2c613aac1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d1aef2b428dd98d35f2e112642326ee2c613aac1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4164b2fb1628493c3b529b1e9ee045a504f44a0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4164b2fb1628493c3b529b1e9ee045a504f44a0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4164b2fb1628493c3b529b1e9ee045a504f44a0e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4164b2fb1628493c3b529b1e9ee045a504f44a0e/comments", "author": null, "committer": null, "parents": [{"sha": "4e2b3c877d1882f2df53f6c467628e4887564467", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e2b3c877d1882f2df53f6c467628e4887564467", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e2b3c877d1882f2df53f6c467628e4887564467"}], "stats": {"total": 67, "additions": 43, "deletions": 24}, "files": [{"sha": "fb1cf3fd7cc5d32ce0a237eba2685504746a2d07", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4164b2fb1628493c3b529b1e9ee045a504f44a0e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4164b2fb1628493c3b529b1e9ee045a504f44a0e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4164b2fb1628493c3b529b1e9ee045a504f44a0e", "patch": "@@ -1,3 +1,8 @@\n+2005-08-03  Paul Brook  <paul@codesourcery.com>\n+\n+\t* combine.c (can_change_dest_mode): New function.\n+\t(try_combine, simplify_set): Use it.\n+\n 2005-08-03  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* config/ia64/hpux.h (MEMBER_TYPE_FORCES_BLK): Only force"}, {"sha": "d5be605751ae4e69d84b49e24bcff6e473b2d141", "filename": "gcc/combine.c", "status": "modified", "additions": 38, "deletions": 24, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4164b2fb1628493c3b529b1e9ee045a504f44a0e/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4164b2fb1628493c3b529b1e9ee045a504f44a0e/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=4164b2fb1628493c3b529b1e9ee045a504f44a0e", "patch": "@@ -1666,6 +1666,29 @@ adjust_for_new_dest (rtx insn)\n   distribute_links (gen_rtx_INSN_LIST (VOIDmode, insn, NULL_RTX));\n }\n \n+/* Return TRUE if combine can reuse reg X in mode MODE.\n+   ADDED_SETS is nonzero if the original set is still required.  */\n+static bool\n+can_change_dest_mode (rtx x, int added_sets, enum machine_mode mode)\n+{\n+  unsigned int regno;\n+\n+  if (!REG_P(x))\n+    return false;\n+\n+  regno = REGNO (x);\n+  /* Allow hard registers if the new mode is legal, and occupies no more\n+     registers than the old mode.  */\n+  if (regno < FIRST_PSEUDO_REGISTER)\n+    return (HARD_REGNO_MODE_OK (regno, mode)\n+\t    && (hard_regno_nregs[regno][GET_MODE (x)]\n+\t\t>= hard_regno_nregs[regno][mode]));\n+\n+  /* Or a pseudo that is only used once.  */\n+  return (REG_N_SETS (regno) == 1 && !added_sets\n+\t  && !REG_USERVAR_P (x));\n+}\n+\n /* Try to combine the insns I1 and I2 into I3.\n    Here I1 and I2 appear earlier than I3.\n    I1 can be zero; then we combine just I2 into I3.\n@@ -2117,13 +2140,12 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t\t\t\t\t      i2src, const0_rtx))\n \t      != GET_MODE (SET_DEST (newpat))))\n \t{\n-\t  unsigned int regno = REGNO (SET_DEST (newpat));\n-\t  rtx new_dest = gen_rtx_REG (compare_mode, regno);\n-\n-\t  if (regno < FIRST_PSEUDO_REGISTER\n-\t      || (REG_N_SETS (regno) == 1 && ! added_sets_2\n-\t\t  && ! REG_USERVAR_P (SET_DEST (newpat))))\n+\t  if (can_change_dest_mode(SET_DEST (newpat), added_sets_2,\n+\t\t\t\t   compare_mode))\n \t    {\n+\t      unsigned int regno = REGNO (SET_DEST (newpat));\n+\t      rtx new_dest = gen_rtx_REG (compare_mode, regno);\n+\n \t      if (regno >= FIRST_PSEUDO_REGISTER)\n \t\tSUBST (regno_reg_rtx[regno], new_dest);\n \n@@ -2356,14 +2378,12 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \n       if (m_split == 0 && ! reg_overlap_mentioned_p (ni2dest, newpat))\n \t{\n+ \t  enum machine_mode new_mode = GET_MODE (SET_DEST (newpat));\n \t  /* If I2DEST is a hard register or the only use of a pseudo,\n \t     we can change its mode.  */\n-\t  if (GET_MODE (SET_DEST (newpat)) != GET_MODE (i2dest)\n-\t      && GET_MODE (SET_DEST (newpat)) != VOIDmode\n-\t      && REG_P (i2dest)\n-\t      && (REGNO (i2dest) < FIRST_PSEUDO_REGISTER\n-\t\t  || (REG_N_SETS (REGNO (i2dest)) == 1 && ! added_sets_2\n-\t\t      && ! REG_USERVAR_P (i2dest))))\n+ \t  if (new_mode != GET_MODE (i2dest)\n+ \t      && new_mode != VOIDmode\n+ \t      && can_change_dest_mode (i2dest, added_sets_2, new_mode))\n \t    ni2dest = gen_rtx_REG (GET_MODE (SET_DEST (newpat)),\n \t\t\t\t   REGNO (i2dest));\n \n@@ -2471,13 +2491,8 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t     isn't valid for it, or change the number of registers.  */\n \t  && (GET_MODE (*split) == GET_MODE (i2dest)\n \t      || GET_MODE (*split) == VOIDmode\n-\t      || (REGNO (i2dest) < FIRST_PSEUDO_REGISTER\n-\t\t  && HARD_REGNO_MODE_OK (REGNO (i2dest), GET_MODE (*split))\n-\t\t  && (hard_regno_nregs[REGNO (i2dest)][GET_MODE (i2dest)]\n-\t\t      == hard_regno_nregs[REGNO (i2dest)][GET_MODE (*split)]))\n-\t      || (REGNO (i2dest) >= FIRST_PSEUDO_REGISTER\n-\t\t  && REG_N_SETS (REGNO (i2dest)) == 1 && ! added_sets_2\n-\t\t  && ! REG_USERVAR_P (i2dest)))\n+\t      || can_change_dest_mode (i2dest, added_sets_2,\n+\t\t\t\t       GET_MODE (*split)))\n \t  && (next_real_insn (i2) == i3\n \t      || ! use_crosses_set_p (*split, INSN_CUID (i2)))\n \t  /* We can't overwrite I2DEST if its value is still used by\n@@ -5282,12 +5297,11 @@ simplify_set (rtx x)\n \t which case we can safely change its mode.  */\n       if (compare_mode != GET_MODE (dest))\n \t{\n-\t  unsigned int regno = REGNO (dest);\n-\t  rtx new_dest = gen_rtx_REG (compare_mode, regno);\n-\n-\t  if (regno < FIRST_PSEUDO_REGISTER\n-\t      || (REG_N_SETS (regno) == 1 && ! REG_USERVAR_P (dest)))\n+\t  if (can_change_dest_mode (dest, 0, compare_mode))\n \t    {\n+\t      unsigned int regno = REGNO (dest);\n+\t      rtx new_dest = gen_rtx_REG (compare_mode, regno);\n+\n \t      if (regno >= FIRST_PSEUDO_REGISTER)\n \t\tSUBST (regno_reg_rtx[regno], new_dest);\n "}]}