{"sha": "6c3cb698c53a85548621eeb871011b6d7774051c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmMzY2I2OThjNTNhODU1NDg2MjFlZWI4NzEwMTFiNmQ3Nzc0MDUxYw==", "commit": {"author": {"name": "Kirill Yukhin", "email": "kirill.yukhin@intel.com", "date": "2011-07-08T13:12:03Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2011-07-08T13:12:03Z"}, "message": "re PR middle-end/49519 (Revision 175272 miscompiled 447.dealII in SPEC CPU 2006)\n\nFix PR middle-end/49519.\n\ngcc/\n\n2011-07-08  Kirill Yukhin  <kirill.yukhin@intel.com>\n\n\tPR middle-end/49519\n\t* calls.c (mem_overlaps_already_clobbered_arg_p): Additional\n\tcheck if address is stored in register. If so - give up.\n\t(check_sibcall_argument_overlap_1): Do not perform check of\n\toverlapping when it is call to address.\n\ngcc/tessuite/\n\n2011-07-08  Kirill Yukhin  <kirill.yukhin@intel.com>\n\n\tPR middle-end/49519\n\t* g++.dg/torture/pr49519.C: New test.\n\nFrom-SVN: r176042", "tree": {"sha": "12985c1b71115046191bb5215bc72531f64397e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/12985c1b71115046191bb5215bc72531f64397e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c3cb698c53a85548621eeb871011b6d7774051c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c3cb698c53a85548621eeb871011b6d7774051c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c3cb698c53a85548621eeb871011b6d7774051c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c3cb698c53a85548621eeb871011b6d7774051c/comments", "author": null, "committer": null, "parents": [{"sha": "7d8d6d7359822490c1a14cfcde0c736c4d220d34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d8d6d7359822490c1a14cfcde0c736c4d220d34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d8d6d7359822490c1a14cfcde0c736c4d220d34"}], "stats": {"total": 156, "additions": 156, "deletions": 0}, "files": [{"sha": "8112a8cce285f8ab3e40f97060b442b0412daef1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c3cb698c53a85548621eeb871011b6d7774051c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c3cb698c53a85548621eeb871011b6d7774051c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6c3cb698c53a85548621eeb871011b6d7774051c", "patch": "@@ -1,3 +1,11 @@\n+2011-07-08  Kirill Yukhin  <kirill.yukhin@intel.com>\n+\n+\tPR middle-end/49519\n+\t* calls.c (mem_overlaps_already_clobbered_arg_p): Additional\n+\tcheck if address is stored in register. If so - give up.\n+\t(check_sibcall_argument_overlap_1): Do not perform check of\n+\toverlapping when it is call to address.\n+\n 2011-07-08  Georg-Johann Lay  <avr@gjlay.de>\n \t\n \t* config/avr/avr.c (output_reload_insisf): Use 'REG_Z+1' instead"}, {"sha": "0cd8cc9dbcb9d2e26032461ac18c6137e70c85d5", "filename": "gcc/calls.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c3cb698c53a85548621eeb871011b6d7774051c/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c3cb698c53a85548621eeb871011b6d7774051c/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=6c3cb698c53a85548621eeb871011b6d7774051c", "patch": "@@ -1591,6 +1591,10 @@ mem_overlaps_already_clobbered_arg_p (rtx addr, unsigned HOST_WIDE_INT size)\n \t   && (XEXP (addr, 0) == crtl->args.internal_arg_pointer\n \t       || XEXP (addr, 1) == crtl->args.internal_arg_pointer))\n     return true;\n+  /* If the address comes in a register, we have no idea of its origin so\n+     give up and conservatively return true.  */\n+  else if (REG_P(addr))\n+    return true;\n   else\n     return false;\n \n@@ -1831,6 +1835,10 @@ check_sibcall_argument_overlap_1 (rtx x)\n \n   code = GET_CODE (x);\n \n+  /* We need not check the operands of the CALL expression itself.  */\n+  if (code == CALL)\n+    return 0;\n+\n   if (code == MEM)\n     return mem_overlaps_already_clobbered_arg_p (XEXP (x, 0),\n \t\t\t\t\t\t GET_MODE_SIZE (GET_MODE (x)));"}, {"sha": "360c0aae53d7cbb5ab4b9d623b2ec66e1afe2e5b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c3cb698c53a85548621eeb871011b6d7774051c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c3cb698c53a85548621eeb871011b6d7774051c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6c3cb698c53a85548621eeb871011b6d7774051c", "patch": "@@ -1,3 +1,8 @@\n+2011-07-08  Kirill Yukhin  <kirill.yukhin@intel.com>\n+\n+\tPR middle-end/49519\n+\t* g++.dg/torture/pr49519.C: New test.\n+\n 2011-07-08  Martin Jambor  <mjambor@suse.cz>\n \n \t* gcc.dg/tree-ssa/sra-12.c: Skip dump scan on avr targets."}, {"sha": "2888709d99f5bd20e69103f3fa988768d41a1b8e", "filename": "gcc/testsuite/g++.dg/torture/pr49519.C", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c3cb698c53a85548621eeb871011b6d7774051c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr49519.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c3cb698c53a85548621eeb871011b6d7774051c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr49519.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr49519.C?ref=6c3cb698c53a85548621eeb871011b6d7774051c", "patch": "@@ -0,0 +1,135 @@\n+/* { dg-do run } */\n+\n+#include <stdlib.h>\n+\n+struct null_type {};\n+\n+inline const null_type cnull() { return null_type(); }\n+\n+template <class TT> struct cons;\n+class tuple;\n+\n+template< int N >\n+struct get_class {\n+  template<class TT >\n+  inline static int& get(cons<TT>& t)\n+  {\n+    return get_class<N-1>::template get(t.tail);\n+  }\n+};\n+\n+template<>\n+struct get_class<0> {\n+  template<class TT>\n+  inline static int& get(cons<TT>& t)\n+  {\n+    return t.head;\n+  }\n+};\n+\n+template<int N, class T>\n+struct element\n+{\n+private:\n+  typedef typename T::tail_type Next;\n+public:\n+  typedef typename element<N-1, Next>::type type;\n+};\n+\n+template<class T>\n+struct element<0,T>\n+{\n+  typedef int type;\n+};\n+\n+template<int N, class TT>\n+inline int& get(cons<TT>& c) {\n+  return get_class<N>::template get(c);\n+}\n+\n+template <class TT>\n+struct cons {\n+  typedef TT tail_type;\n+\n+  int head;\n+  tail_type tail;\n+\n+  cons() : head(), tail() {}\n+\n+  template <class T1, class T2, class T3, class T4>\n+  cons( T1& t1, T2& t2, T3& t3, T4& t4 )\n+    : head (t1),\n+      tail (t2, t3, t4, cnull())\n+      {}\n+};\n+\n+template <>\n+struct cons<null_type> {\n+  typedef null_type tail_type;\n+\n+  int head;\n+\n+  cons() : head() {}\n+\n+  template<class T1>\n+  cons(T1& t1, const null_type&, const null_type&, const null_type&)\n+  : head (t1) {}\n+};\n+\n+template <class T0, class T1, class T2, class T3>\n+struct map_tuple_to_cons\n+{\n+  typedef cons<typename map_tuple_to_cons<T1, T2, T3, null_type>::type> type;\n+};\n+\n+template <>\n+struct map_tuple_to_cons<null_type, null_type, null_type, null_type>\n+{\n+  typedef null_type type;\n+};\n+\n+class tuple :\n+  public map_tuple_to_cons<int, int, int, int>::type\n+{\n+public:\n+  typedef typename\n+    map_tuple_to_cons<int, int, int, int>::type inherited;\n+\n+  tuple(const int &t0,\n+        const int &t1,\n+        const int &t2,\n+        const int &t3)\n+    : inherited(t0, t1, t2, t3) {}\n+};\n+\n+void foo(void (*boo)(int, int, int, int), tuple t)\n+{\n+  boo(get<0>(t), get<1>(t), get<2>(t), get<3>(t));\n+}\n+\n+int tailcalled_t1;\n+int tailcalled_t2;\n+int tailcalled_t3;\n+int tailcalled_t4;\n+\n+void print(int t1, int t2, int t3, int t4)\n+{\n+  tailcalled_t1 = t1;\n+  tailcalled_t2 = t2;\n+  tailcalled_t3 = t3;\n+  tailcalled_t4 = t4;\n+}\n+\n+int main ()\n+{\n+  tuple t(1,2,3,4);\n+  foo(print, t);\n+\n+  if( (get<0>(t) != tailcalled_t1)\n+    ||(get<1>(t) != tailcalled_t2)\n+    ||(get<2>(t) != tailcalled_t3)\n+      ||(get<3>(t) != tailcalled_t4))\n+      abort();\n+\n+  return 0;\n+}"}]}