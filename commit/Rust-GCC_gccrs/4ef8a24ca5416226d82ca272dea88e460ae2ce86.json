{"sha": "4ef8a24ca5416226d82ca272dea88e460ae2ce86", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGVmOGEyNGNhNTQxNjIyNmQ4MmNhMjcyZGVhODhlNDYwYWUyY2U4Ng==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-04-26T09:59:31Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-04-26T09:59:31Z"}, "message": "Add commentary to (SET_)TYPE_VECTOR_SUBPARTS\n\n2019-04-26  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree.h (TYPE_VECTOR_SUBPARTS, SET_TYPE_VECTOR_SUBPARTS): Add\n\tcommentary about the encoding of precision.\n\nFrom-SVN: r270593", "tree": {"sha": "e81d8dc1edc113abec32121c11d2f3fa210706f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e81d8dc1edc113abec32121c11d2f3fa210706f8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ef8a24ca5416226d82ca272dea88e460ae2ce86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ef8a24ca5416226d82ca272dea88e460ae2ce86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ef8a24ca5416226d82ca272dea88e460ae2ce86", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ef8a24ca5416226d82ca272dea88e460ae2ce86/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "25efa5fb15e36a1b35f3c9bbe38139d6244a35e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25efa5fb15e36a1b35f3c9bbe38139d6244a35e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25efa5fb15e36a1b35f3c9bbe38139d6244a35e3"}], "stats": {"total": 22, "additions": 22, "deletions": 0}, "files": [{"sha": "3330d1c8905f3521215c49f5aa6885ffe3e93dbd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ef8a24ca5416226d82ca272dea88e460ae2ce86/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ef8a24ca5416226d82ca272dea88e460ae2ce86/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4ef8a24ca5416226d82ca272dea88e460ae2ce86", "patch": "@@ -1,3 +1,8 @@\n+2019-04-26  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree.h (TYPE_VECTOR_SUBPARTS, SET_TYPE_VECTOR_SUBPARTS): Add\n+\tcommentary about the encoding of precision.\n+\n 2019-04-25  Andreas Tobler  <andreast@gcc.gnu.org>\n \n \t* config/i386/freebsd64.h: Add bits for 32-bit multilib support."}, {"sha": "f03008244359295806616c44fc695b766ed6e74a", "filename": "gcc/tree.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ef8a24ca5416226d82ca272dea88e460ae2ce86/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ef8a24ca5416226d82ca272dea88e460ae2ce86/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=4ef8a24ca5416226d82ca272dea88e460ae2ce86", "patch": "@@ -3734,6 +3734,8 @@ TYPE_VECTOR_SUBPARTS (const_tree node)\n   unsigned int precision = VECTOR_TYPE_CHECK (node)->type_common.precision;\n   if (NUM_POLY_INT_COEFFS == 2)\n     {\n+      /* See the corresponding code in SET_TYPE_VECTOR_SUBPARTS for a\n+\t description of the encoding.  */\n       poly_uint64 res = 0;\n       res.coeffs[0] = HOST_WIDE_INT_1U << (precision & 0xff);\n       if (precision & 0x100)\n@@ -3756,6 +3758,21 @@ SET_TYPE_VECTOR_SUBPARTS (tree node, poly_uint64 subparts)\n   gcc_assert (index >= 0);\n   if (NUM_POLY_INT_COEFFS == 2)\n     {\n+      /* We have two coefficients that are each in the range 1 << [0, 63],\n+\t so supporting all combinations would require 6 bits per coefficient\n+\t and 12 bits in total.  Since the precision field is only 10 bits\n+\t in size, we need to be more restrictive than that.\n+\n+\t At present, coeff[1] is always either 0 (meaning that the number\n+\t of units is constant) or equal to coeff[0] (meaning that the number\n+\t of units is N + X * N for some target-dependent zero-based runtime\n+\t parameter X).  We can therefore encode coeff[1] in a single bit.\n+\n+\t The most compact encoding would be to use mask 0x3f for coeff[0]\n+\t and 0x40 for coeff[1], leaving 0x380 unused.  It's possible to\n+\t get slightly more efficient code on some hosts if we instead\n+\t treat the shift amount as an independent byte, so here we use\n+\t 0xff for coeff[0] and 0x100 for coeff[1].  */\n       unsigned HOST_WIDE_INT coeff1 = subparts.coeffs[1];\n       gcc_assert (coeff1 == 0 || coeff1 == coeff0);\n       VECTOR_TYPE_CHECK (node)->type_common.precision"}]}