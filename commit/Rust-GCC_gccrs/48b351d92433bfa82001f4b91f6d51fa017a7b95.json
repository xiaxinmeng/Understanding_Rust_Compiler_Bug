{"sha": "48b351d92433bfa82001f4b91f6d51fa017a7b95", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDhiMzUxZDkyNDMzYmZhODIwMDFmNGI5MWY2ZDUxZmEwMTdhN2I5NQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-18T10:07:36Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-18T10:07:36Z"}, "message": "[multiple changes]\n\n2010-06-18  Thomas Quinot  <quinot@adacore.com>\n\n\t* g-socket.adb, g-socket.ads (Null_Selector): New object.\n\n2010-06-18  Pascal Obry  <obry@adacore.com>\n\n\t* gnat_ugn.texi: Minor clarification.\n\n2010-06-18  Emmanuel Briot  <briot@adacore.com>\n\n\t* prj-nmsc.adb (Find_Source_Dirs): Minor refactoring to avoid duplicate\n\tcode when using the project dir as the source dir.\n\t(Search_Directories): use the normalized name for the source directory,\n\twhere symbolic names have potentially been resolved.\n\n2010-06-18  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_ch4.adb (Expand_N_Conditional_Expression): Clear Actions field\n\twhen we create N_Expression_With_Actions node.\n\t(Expand_Short_Circuit): Ditto.\n\n2010-06-18  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_util.adb: Minor reformatting.\n\nFrom-SVN: r160975", "tree": {"sha": "e9a4f37a8b115f48de6ff824fa48208706259f18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e9a4f37a8b115f48de6ff824fa48208706259f18"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/48b351d92433bfa82001f4b91f6d51fa017a7b95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48b351d92433bfa82001f4b91f6d51fa017a7b95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48b351d92433bfa82001f4b91f6d51fa017a7b95", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48b351d92433bfa82001f4b91f6d51fa017a7b95/comments", "author": null, "committer": null, "parents": [{"sha": "6a497607af0b7e34aad6d6f3cc04d2c8f5ddfe25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a497607af0b7e34aad6d6f3cc04d2c8f5ddfe25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a497607af0b7e34aad6d6f3cc04d2c8f5ddfe25"}], "stats": {"total": 463, "additions": 228, "deletions": 235}, "files": [{"sha": "bb99ab4da7c7eb260656fe51c00f83a0593e4fd2", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48b351d92433bfa82001f4b91f6d51fa017a7b95/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48b351d92433bfa82001f4b91f6d51fa017a7b95/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=48b351d92433bfa82001f4b91f6d51fa017a7b95", "patch": "@@ -1,3 +1,28 @@\n+2010-06-18  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* g-socket.adb, g-socket.ads (Null_Selector): New object.\n+\n+2010-06-18  Pascal Obry  <obry@adacore.com>\n+\n+\t* gnat_ugn.texi: Minor clarification.\n+\n+2010-06-18  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* prj-nmsc.adb (Find_Source_Dirs): Minor refactoring to avoid duplicate\n+\tcode when using the project dir as the source dir.\n+\t(Search_Directories): use the normalized name for the source directory,\n+\twhere symbolic names have potentially been resolved.\n+\n+2010-06-18  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_N_Conditional_Expression): Clear Actions field\n+\twhen we create N_Expression_With_Actions node.\n+\t(Expand_Short_Circuit): Ditto.\n+\n+2010-06-18  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_util.adb: Minor reformatting.\n+\n 2010-06-18  Thomas Quinot  <quinot@adacore.com>\n \n \t* types.ads: Clean up obsolete comments"}, {"sha": "96f3d2709381d38030d8874a88cea2cf28462be1", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48b351d92433bfa82001f4b91f6d51fa017a7b95/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48b351d92433bfa82001f4b91f6d51fa017a7b95/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=48b351d92433bfa82001f4b91f6d51fa017a7b95", "patch": "@@ -4111,6 +4111,7 @@ package body Exp_Ch4 is\n                  Make_Expression_With_Actions (Sloc (Thenx),\n                    Actions    => Then_Actions (N),\n                    Expression => Relocate_Node (Thenx)));\n+               Set_Then_Actions (N, No_List);\n                Analyze_And_Resolve (Thenx, Typ);\n             end if;\n \n@@ -4119,6 +4120,7 @@ package body Exp_Ch4 is\n                  Make_Expression_With_Actions (Sloc (Elsex),\n                    Actions    => Else_Actions (N),\n                    Expression => Relocate_Node (Elsex)));\n+               Set_Else_Actions (N, No_List);\n                Analyze_And_Resolve (Elsex, Typ);\n             end if;\n \n@@ -9044,6 +9046,7 @@ package body Exp_Ch4 is\n               Make_Expression_With_Actions (LocR,\n                 Expression => Relocate_Node (Right),\n                 Actions    => Actlist));\n+            Set_Actions (N, No_List);\n             Analyze_And_Resolve (Right, Standard_Boolean);\n          end if;\n "}, {"sha": "66a1b772de3203c719b550296c59edf3d2c3e2ce", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48b351d92433bfa82001f4b91f6d51fa017a7b95/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48b351d92433bfa82001f4b91f6d51fa017a7b95/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=48b351d92433bfa82001f4b91f6d51fa017a7b95", "patch": "@@ -4685,7 +4685,7 @@ package body Exp_Util is\n \n       --  If it is a scalar type and we need to capture the value, just make\n       --  a copy. Likewise for a function call, an attribute reference, an\n-      --  allocator or an operator. And if we have a volatile reference and\n+      --  allocator, or an operator. And if we have a volatile reference and\n       --  Name_Req is not set (see comments above for Side_Effect_Free).\n \n       if Is_Elementary_Type (Exp_Type)"}, {"sha": "b75c525202f9180bbc0dc26aaee059f54fcd9788", "filename": "gcc/ada/g-socket.adb", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48b351d92433bfa82001f4b91f6d51fa017a7b95/gcc%2Fada%2Fg-socket.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48b351d92433bfa82001f4b91f6d51fa017a7b95/gcc%2Fada%2Fg-socket.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-socket.adb?ref=48b351d92433bfa82001f4b91f6d51fa017a7b95", "patch": "@@ -273,7 +273,8 @@ package body GNAT.Sockets is\n \n    function Is_Open (S : Selector_Type) return Boolean;\n    --  Return True for an \"open\" Selector_Type object, i.e. one for which\n-   --  Create_Selector has been called and Close_Selector has not been called.\n+   --  Create_Selector has been called and Close_Selector has not been called,\n+   --  or the null selector.\n \n    ---------\n    -- \"+\" --\n@@ -294,6 +295,10 @@ package body GNAT.Sockets is\n    begin\n       if not Is_Open (Selector) then\n          raise Program_Error with \"closed selector\";\n+\n+      elsif Selector.Is_Null then\n+         raise Program_Error with \"null selector\";\n+\n       end if;\n \n       --  Send one byte to unblock select system call\n@@ -491,7 +496,7 @@ package body GNAT.Sockets is\n    is\n       Res  : C.int;\n       Last : C.int;\n-      RSig : constant Socket_Type := Selector.R_Sig_Socket;\n+      RSig : Socket_Type := No_Socket;\n       TVal : aliased Timeval;\n       TPtr : Timeval_Access;\n \n@@ -511,9 +516,12 @@ package body GNAT.Sockets is\n          TPtr := TVal'Unchecked_Access;\n       end if;\n \n-      --  Add read signalling socket\n+      --  Add read signalling socket, if present\n \n-      Set (R_Socket_Set, RSig);\n+      if not Selector.Is_Null then\n+         RSig := Selector.R_Sig_Socket;\n+         Set (R_Socket_Set, RSig);\n+      end if;\n \n       Last := C.int'Max (C.int'Max (C.int (R_Socket_Set.Last),\n                                     C.int (W_Socket_Set.Last)),\n@@ -540,7 +548,7 @@ package body GNAT.Sockets is\n       --  If Select was resumed because of read signalling socket, read this\n       --  data and remove socket from set.\n \n-      if Is_Set (R_Socket_Set, RSig) then\n+      if RSig /= No_Socket and then Is_Set (R_Socket_Set, RSig) then\n          Clear (R_Socket_Set, RSig);\n \n          Res := Signalling_Fds.Read (C.int (RSig));\n@@ -585,10 +593,9 @@ package body GNAT.Sockets is\n \n    procedure Close_Selector (Selector : in out Selector_Type) is\n    begin\n-      if not Is_Open (Selector) then\n-\n-         --  Selector already in closed state: nothing to do\n+      --  Nothing to do if selector already in closed state\n \n+      if Selector.Is_Null or else not Is_Open (Selector) then\n          return;\n       end if;\n \n@@ -1425,14 +1432,19 @@ package body GNAT.Sockets is\n \n    function Is_Open (S : Selector_Type) return Boolean is\n    begin\n-      --  Either both controlling socket descriptors are valid (case of an\n-      --  open selector) or neither (case of a closed selector).\n+      if S.Is_Null then\n+         return True;\n+\n+      else\n+         --  Either both controlling socket descriptors are valid (case of an\n+         --  open selector) or neither (case of a closed selector).\n \n-      pragma Assert ((S.R_Sig_Socket /= No_Socket)\n-                       =\n-                     (S.W_Sig_Socket /= No_Socket));\n+         pragma Assert ((S.R_Sig_Socket /= No_Socket)\n+                          =\n+                        (S.W_Sig_Socket /= No_Socket));\n \n-      return S.R_Sig_Socket /= No_Socket;\n+         return S.R_Sig_Socket /= No_Socket;\n+      end if;\n    end Is_Open;\n \n    ------------"}, {"sha": "55330bd784a05110de0fb5b2ee4d88ae8dc9f654", "filename": "gcc/ada/g-socket.ads", "status": "modified", "additions": 26, "deletions": 6, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48b351d92433bfa82001f4b91f6d51fa017a7b95/gcc%2Fada%2Fg-socket.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48b351d92433bfa82001f4b91f6d51fa017a7b95/gcc%2Fada%2Fg-socket.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-socket.ads?ref=48b351d92433bfa82001f4b91f6d51fa017a7b95", "patch": "@@ -422,6 +422,11 @@ package GNAT.Sockets is\n    type Selector_Access is access all Selector_Type;\n    --  Selector objects are used to wait for i/o events to occur on sockets\n \n+   Null_Selector : constant Selector_Type;\n+   --  The Null_Selector can be used in place of a normal selector without\n+   --  having to call Create_Selector if the use of Abort_Selector is not\n+   --  required.\n+\n    --  Timeval_Duration is a subtype of Standard.Duration because the full\n    --  range of Standard.Duration cannot be represented in the equivalent C\n    --  structure. Moreover, negative values are not allowed to avoid system\n@@ -1067,7 +1072,7 @@ package GNAT.Sockets is\n    --  the situation where a change to the monitored sockets set must be made.\n \n    procedure Create_Selector (Selector : out Selector_Type);\n-   --  Create a new selector\n+   --  Initialize (open) a new selector\n \n    procedure Close_Selector (Selector : in out Selector_Type);\n    --  Close Selector and all internal descriptors associated; deallocate any\n@@ -1110,7 +1115,8 @@ package GNAT.Sockets is\n    --  different objects.\n \n    procedure Abort_Selector (Selector : Selector_Type);\n-   --  Send an abort signal to the selector\n+   --  Send an abort signal to the selector. The Selector may not be the\n+   --  Null_Selector.\n \n    type Fd_Set is private;\n    --  ??? This type must not be used directly, it needs to be visible because\n@@ -1126,14 +1132,28 @@ private\n    type Socket_Type is new Integer;\n    No_Socket : constant Socket_Type := -1;\n \n-   type Selector_Type is limited record\n-      R_Sig_Socket : Socket_Type := No_Socket;\n-      W_Sig_Socket : Socket_Type := No_Socket;\n-      --  Signalling sockets used to abort a select operation\n+   --  A selector is either a null selector, which is always \"open\" and can\n+   --  never be aborted, or a regular selector, which is created \"closed\",\n+   --  becomes \"open\" when Create_Selector is called, and \"closed\" again when\n+   --  Close_Selector is called.\n+\n+   type Selector_Type (Is_Null : Boolean := False) is limited record\n+      case Is_Null is\n+         when True =>\n+            null;\n+\n+         when False =>\n+            R_Sig_Socket : Socket_Type := No_Socket;\n+            W_Sig_Socket : Socket_Type := No_Socket;\n+            --  Signalling sockets used to abort a select operation\n+\n+      end case;\n    end record;\n \n    pragma Volatile (Selector_Type);\n \n+   Null_Selector : constant Selector_Type := (Is_Null => True);\n+\n    type Fd_Set is\n      new System.Storage_Elements.Storage_Array (1 .. SOSC.SIZEOF_fd_set);\n    for Fd_Set'Alignment use Interfaces.C.long'Alignment;"}, {"sha": "4e32b1ba271ae5be05d9fa7b670b61052e34ebb0", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48b351d92433bfa82001f4b91f6d51fa017a7b95/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48b351d92433bfa82001f4b91f6d51fa017a7b95/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=48b351d92433bfa82001f4b91f6d51fa017a7b95", "patch": "@@ -11549,7 +11549,8 @@ regular files.\n \n @noindent\n One or several Naming Patterns may be given as arguments to @code{gnatname}.\n-Each Naming Pattern is enclosed between double quotes.\n+Each Naming Pattern is enclosed between double quotes (or single\n+quotes on Windows).\n A Naming Pattern is a regular expression similar to the wildcard patterns\n used in file names by the Unix shells or the DOS prompt.\n "}, {"sha": "a3f64d0654bf0f6a2a5a940bbcf4a846123be8d3", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 145, "deletions": 213, "changes": 358, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48b351d92433bfa82001f4b91f6d51fa017a7b95/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48b351d92433bfa82001f4b91f6d51fa017a7b95/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=48b351d92433bfa82001f4b91f6d51fa017a7b95", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2000-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2000-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -4790,7 +4790,7 @@ package body Prj.Nmsc is\n         (Header_Num => Header_Num,\n          Element    => Boolean,\n          No_Element => False,\n-         Key        => Name_Id,\n+         Key        => Path_Name_Type,\n          Hash       => Hash,\n          Equal      => \"=\");\n       --  Hash table stores recursive source directories, to avoid looking\n@@ -4837,123 +4837,127 @@ package body Prj.Nmsc is\n       --  Find one or several source directories, and add (or remove, if\n       --  Removed is True) them to list of source directories of the project.\n \n-      ----------------------\n-      -- Find_Source_Dirs --\n-      ----------------------\n-\n-      procedure Find_Source_Dirs\n-        (From     : File_Name_Type;\n-         Location : Source_Ptr;\n-         Rank     : Natural;\n-         Removed  : Boolean := False)\n+      procedure Add_To_Or_Remove_From_Source_Dirs\n+        (Path_Id         : Path_Name_Type;\n+         Display_Path_Id : Path_Name_Type;\n+         Rank            : Natural;\n+         Removed         : Boolean);\n+      --  When Removed = False, the directory Path_Id to the list of\n+      --  source_dirs if not already in the list. When Removed = True,\n+      --  removed directory Path_Id if in the list.\n+\n+      ---------------------------------------\n+      -- Add_To_Or_Remove_From_Source_Dirs --\n+      ---------------------------------------\n+\n+      procedure Add_To_Or_Remove_From_Source_Dirs\n+        (Path_Id         : Path_Name_Type;\n+         Display_Path_Id : Path_Name_Type;\n+         Rank            : Natural;\n+         Removed         : Boolean)\n       is\n-         Directory : constant String := Get_Name_String (From);\n+         List       : String_List_Id;\n+         Prev       : String_List_Id;\n+         Rank_List  : Number_List_Index;\n+         Prev_Rank  : Number_List_Index;\n+         Element    : String_Element;\n \n-         procedure Add_To_Or_Remove_From_List\n-           (Path_Id         : Name_Id;\n-            Display_Path_Id : Name_Id);\n-         --  When Removed = False, the directory Path_Id to the list of\n-         --  source_dirs if not already in the list. When Removed = True,\n-         --  removed directory Path_Id if in the list.\n+      begin\n+         Prev      := Nil_String;\n+         Prev_Rank := No_Number_List;\n+         List      := Project.Source_Dirs;\n+         Rank_List := Project.Source_Dir_Ranks;\n+         while List /= Nil_String loop\n+            Element := Data.Tree.String_Elements.Table (List);\n+            exit when Element.Value = Name_Id (Path_Id);\n+            Prev := List;\n+            List := Element.Next;\n+            Prev_Rank := Rank_List;\n+            Rank_List := Data.Tree.Number_Lists.Table (Prev_Rank).Next;\n+         end loop;\n \n-         procedure Recursive_Find_Dirs (Path : Name_Id);\n-         --  Find all the subdirectories (recursively) of Path and add them\n-         --  to the list of source directories of the project.\n+         --  The directory is in the list if List is not Nil_String\n \n-         --------------------------------\n-         -- Add_To_Or_Remove_From_List --\n-         --------------------------------\n-\n-         procedure Add_To_Or_Remove_From_List\n-           (Path_Id         : Name_Id;\n-            Display_Path_Id : Name_Id)\n-         is\n-            List       : String_List_Id;\n-            Prev       : String_List_Id;\n-            Rank_List  : Number_List_Index;\n-            Prev_Rank  : Number_List_Index;\n-            Element    : String_Element;\n+         if not Removed and then List = Nil_String then\n+            if Current_Verbosity = High then\n+               Write_Str  (\"   Adding Source Dir=\");\n+               Write_Line (Get_Name_String (Path_Id));\n+            end if;\n \n-         begin\n-            Prev      := Nil_String;\n-            Prev_Rank := No_Number_List;\n-            List      := Project.Source_Dirs;\n-            Rank_List := Project.Source_Dir_Ranks;\n-            while List /= Nil_String loop\n-               Element := Data.Tree.String_Elements.Table (List);\n-               exit when Element.Value = Path_Id;\n-               Prev := List;\n-               List := Element.Next;\n-               Prev_Rank := Rank_List;\n-               Rank_List := Data.Tree.Number_Lists.Table (Prev_Rank).Next;\n-            end loop;\n+            String_Element_Table.Increment_Last (Data.Tree.String_Elements);\n+            Element :=\n+              (Value         => Name_Id (Path_Id),\n+               Index         => 0,\n+               Display_Value => Name_Id (Display_Path_Id),\n+               Location      => No_Location,\n+               Flag          => False,\n+               Next          => Nil_String);\n \n-            --  The directory is in the list if List is not Nil_String\n+            Number_List_Table.Increment_Last (Data.Tree.Number_Lists);\n \n-            if not Removed and then List = Nil_String then\n-               if Current_Verbosity = High then\n-                  Write_Str  (\"   Adding Source Dir=\");\n-                  Write_Line (Get_Name_String (Path_Id));\n-               end if;\n+            if Last_Source_Dir = Nil_String then\n \n-               String_Element_Table.Increment_Last (Data.Tree.String_Elements);\n-               Element :=\n-                 (Value         => Path_Id,\n-                  Index         => 0,\n-                  Display_Value => Display_Path_Id,\n-                  Location      => No_Location,\n-                  Flag          => False,\n-                  Next          => Nil_String);\n+               --  This is the first source directory\n \n-               Number_List_Table.Increment_Last (Data.Tree.Number_Lists);\n+               Project.Source_Dirs :=\n+                 String_Element_Table.Last (Data.Tree.String_Elements);\n+               Project.Source_Dir_Ranks :=\n+                 Number_List_Table.Last (Data.Tree.Number_Lists);\n \n-               if Last_Source_Dir = Nil_String then\n+            else\n+               --  We already have source directories, link the previous\n+               --  last to the new one.\n \n-                  --  This is the first source directory\n+               Data.Tree.String_Elements.Table (Last_Source_Dir).Next :=\n+                 String_Element_Table.Last (Data.Tree.String_Elements);\n+               Data.Tree.Number_Lists.Table (Last_Src_Dir_Rank).Next :=\n+                 Number_List_Table.Last (Data.Tree.Number_Lists);\n+            end if;\n \n-                  Project.Source_Dirs :=\n-                    String_Element_Table.Last (Data.Tree.String_Elements);\n-                  Project.Source_Dir_Ranks :=\n-                    Number_List_Table.Last (Data.Tree.Number_Lists);\n+            --  And register this source directory as the new last\n \n-               else\n-                  --  We already have source directories, link the previous\n-                  --  last to the new one.\n+            Last_Source_Dir :=\n+              String_Element_Table.Last (Data.Tree.String_Elements);\n+            Data.Tree.String_Elements.Table (Last_Source_Dir) := Element;\n+            Last_Src_Dir_Rank :=\n+              Number_List_Table.Last (Data.Tree.Number_Lists);\n+            Data.Tree.Number_Lists.Table (Last_Src_Dir_Rank) :=\n+              (Number => Rank, Next => No_Number_List);\n \n-                  Data.Tree.String_Elements.Table (Last_Source_Dir).Next :=\n-                    String_Element_Table.Last (Data.Tree.String_Elements);\n-                  Data.Tree.Number_Lists.Table (Last_Src_Dir_Rank).Next :=\n-                    Number_List_Table.Last (Data.Tree.Number_Lists);\n-               end if;\n+         elsif Removed and then List /= Nil_String then\n \n-               --  And register this source directory as the new last\n+            --  Remove source dir, if present\n \n-               Last_Source_Dir :=\n-                 String_Element_Table.Last (Data.Tree.String_Elements);\n-               Data.Tree.String_Elements.Table (Last_Source_Dir) := Element;\n-               Last_Src_Dir_Rank :=\n-                 Number_List_Table.Last (Data.Tree.Number_Lists);\n-               Data.Tree.Number_Lists.Table (Last_Src_Dir_Rank) :=\n-                 (Number => Rank, Next => No_Number_List);\n+            if Prev = Nil_String then\n+               Project.Source_Dirs :=\n+                 Data.Tree.String_Elements.Table (List).Next;\n+               Project.Source_Dir_Ranks :=\n+                 Data.Tree.Number_Lists.Table (Rank_List).Next;\n \n-            elsif Removed and then List /= Nil_String then\n+            else\n+               Data.Tree.String_Elements.Table (Prev).Next :=\n+                 Data.Tree.String_Elements.Table (List).Next;\n+               Data.Tree.Number_Lists.Table (Prev_Rank).Next :=\n+                 Data.Tree.Number_Lists.Table (Rank_List).Next;\n+            end if;\n+         end if;\n+      end Add_To_Or_Remove_From_Source_Dirs;\n \n-               --  Remove source dir, if present\n+      ----------------------\n+      -- Find_Source_Dirs --\n+      ----------------------\n \n-               if Prev = Nil_String then\n-                  Project.Source_Dirs :=\n-                    Data.Tree.String_Elements.Table (List).Next;\n-                  Project.Source_Dir_Ranks :=\n-                    Data.Tree.Number_Lists.Table (Rank_List).Next;\n+      procedure Find_Source_Dirs\n+        (From     : File_Name_Type;\n+         Location : Source_Ptr;\n+         Rank     : Natural;\n+         Removed  : Boolean := False)\n+      is\n+         Directory : constant String := Get_Name_String (From);\n \n-               else\n-                  Data.Tree.String_Elements.Table (Prev).Next :=\n-                    Data.Tree.String_Elements.Table (List).Next;\n-                  Data.Tree.Number_Lists.Table (Prev_Rank).Next :=\n-                    Data.Tree.Number_Lists.Table (Rank_List).Next;\n-               end if;\n-            end if;\n-         end Add_To_Or_Remove_From_List;\n+         procedure Recursive_Find_Dirs (Path : Name_Id);\n+         --  Find all the subdirectories (recursively) of Path and add them\n+         --  to the list of source directories of the project.\n \n          -------------------------\n          -- Recursive_Find_Dirs --\n@@ -4964,8 +4968,8 @@ package body Prj.Nmsc is\n             Name : String (1 .. 250);\n             Last : Natural;\n \n-            Non_Canonical_Path : Name_Id := No_Name;\n-            Canonical_Path     : Name_Id := No_Name;\n+            Non_Canonical_Path : Path_Name_Type := No_Path;\n+            Canonical_Path     : Path_Name_Type := No_Path;\n \n             The_Path : constant String :=\n                          Normalize_Pathname\n@@ -4984,7 +4988,8 @@ package body Prj.Nmsc is\n               The_Path (The_Path'First .. The_Path_Last);\n             Non_Canonical_Path := Name_Find;\n             Canonical_Path :=\n-              Name_Id (Canonical_Case_File_Name (Non_Canonical_Path));\n+              Path_Name_Type\n+                (Canonical_Case_File_Name (Name_Id (Non_Canonical_Path)));\n \n             --  To avoid processing the same directory several times, check\n             --  if the directory is already in Recursive_Dirs. If it is, then\n@@ -4999,9 +5004,11 @@ package body Prj.Nmsc is\n                end if;\n             end if;\n \n-            Add_To_Or_Remove_From_List\n+            Add_To_Or_Remove_From_Source_Dirs\n               (Path_Id         => Canonical_Path,\n-               Display_Path_Id => Non_Canonical_Path);\n+               Display_Path_Id => Non_Canonical_Path,\n+               Rank            => Rank,\n+               Removed         => Removed);\n \n             --  Now look for subdirectories. Do that even when this directory\n             --  is already in the list, because some of its subdirectories may\n@@ -5098,7 +5105,7 @@ package body Prj.Nmsc is\n                Base_Dir : constant File_Name_Type := Name_Find;\n                Root_Dir : constant String :=\n                             Normalize_Pathname\n-                              (Name      => Get_Name_String (Base_Dir),\n+                              (Name      => Name_Buffer (1 .. Name_Len),\n                                Directory =>\n                                  Get_Name_String\n                                    (Project.Directory.Display_Name),\n@@ -5109,18 +5116,9 @@ package body Prj.Nmsc is\n             begin\n                if Root_Dir'Length = 0 then\n                   Err_Vars.Error_Msg_File_1 := Base_Dir;\n-\n-                  if Location = No_Location then\n-                     Error_Msg\n-                       (Data.Flags,\n-                        \"{ is not a valid directory.\",\n-                        Project.Location, Project);\n-                  else\n-                     Error_Msg\n-                       (Data.Flags,\n-                        \"{ is not a valid directory.\",\n-                        Location, Project);\n-                  end if;\n+                  Error_Msg\n+                    (Data.Flags,\n+                     \"{ is not a valid directory.\", Location, Project);\n \n                else\n                   --  We have an existing directory, we register it and all of\n@@ -5158,57 +5156,18 @@ package body Prj.Nmsc is\n \n                if not Dir_Exists then\n                   Err_Vars.Error_Msg_File_1 := From;\n-\n-                  if Location = No_Location then\n-                     Error_Msg\n-                       (Data.Flags,\n-                        \"{ is not a valid directory\",\n-                        Project.Location, Project);\n-                  else\n-                     Error_Msg\n-                       (Data.Flags,\n-                        \"{ is not a valid directory\",\n-                        Location, Project);\n-                  end if;\n+                  Error_Msg\n+                    (Data.Flags,\n+                     \"{ is not a valid directory\", Location, Project);\n \n                else\n-                  declare\n-                     Path : constant String :=\n-                              Normalize_Pathname\n-                                (Name           =>\n-                                   Get_Name_String (Path_Name.Name),\n-                                 Directory      =>\n-                                   Get_Name_String (Project.Directory.Name),\n-                                 Resolve_Links  => Opt.Follow_Links_For_Dirs,\n-                                 Case_Sensitive => True) &\n-                              Directory_Separator;\n-\n-                     Last_Path         : constant Natural :=\n-                                           Compute_Directory_Last (Path);\n-                     Path_Id           : Name_Id;\n-                     Display_Path      : constant String :=\n-                                           Get_Name_String\n-                                             (Path_Name.Display_Name);\n-                     Last_Display_Path : constant Natural :=\n-                                           Compute_Directory_Last\n-                                             (Display_Path);\n-                     Display_Path_Id   : Name_Id;\n-\n-                  begin\n-                     Name_Len := 0;\n-                     Add_Str_To_Name_Buffer (Path (Path'First .. Last_Path));\n-                     Path_Id := Name_Find;\n-\n-                     Name_Len := 0;\n-                     Add_Str_To_Name_Buffer\n-                       (Display_Path\n-                          (Display_Path'First .. Last_Display_Path));\n-                     Display_Path_Id := Name_Find;\n-\n-                     Add_To_Or_Remove_From_List\n-                       (Path_Id         => Path_Id,\n-                        Display_Path_Id => Display_Path_Id);\n-                  end;\n+                  --  links have been resolved if necessary, and Path_Name\n+                  --  always ends with a directory separator\n+                  Add_To_Or_Remove_From_Source_Dirs\n+                    (Path_Id         => Path_Name.Name,\n+                     Display_Path_Id => Path_Name.Display_Name,\n+                     Rank            => Rank,\n+                     Removed         => Removed);\n                end if;\n             end;\n          end if;\n@@ -5378,7 +5337,7 @@ package body Prj.Nmsc is\n \n       pragma Assert (Source_Dirs.Kind = List, \"Source_Dirs is not a list\");\n \n-      if (not Source_Files.Default)\n+      if not Source_Files.Default\n         and then Source_Files.Values = Nil_String\n       then\n          Project.Source_Dirs := Nil_String;\n@@ -5391,43 +5350,14 @@ package body Prj.Nmsc is\n          end if;\n \n       elsif Source_Dirs.Default then\n-\n          --  No Source_Dirs specified: the single source directory is the one\n          --  containing the project file.\n \n-         String_Element_Table.Append (Data.Tree.String_Elements,\n-           (Value         => Name_Id (Project.Directory.Name),\n-            Display_Value => Name_Id (Project.Directory.Display_Name),\n-            Location      => No_Location,\n-            Flag          => False,\n-            Next          => Nil_String,\n-            Index         => 0));\n-\n-         Project.Source_Dirs :=\n-           String_Element_Table.Last (Data.Tree.String_Elements);\n-\n-         Number_List_Table.Append\n-           (Data.Tree.Number_Lists,\n-            (Number => 1, Next => No_Number_List));\n-\n-         Project.Source_Dir_Ranks :=\n-           Number_List_Table.Last (Data.Tree.Number_Lists);\n-\n-         if Current_Verbosity = High then\n-            Write_Attr\n-              (\"Default source directory\",\n-               Get_Name_String (Project.Directory.Display_Name));\n-         end if;\n-\n-      elsif Source_Dirs.Values = Nil_String then\n-         if Project.Qualifier = Standard then\n-            Error_Msg\n-              (Data.Flags,\n-               \"a standard project cannot have no source directories\",\n-               Source_Dirs.Location, Project);\n-         end if;\n-\n-         Project.Source_Dirs := Nil_String;\n+         Add_To_Or_Remove_From_Source_Dirs\n+           (Path_Id         => Project.Directory.Name,\n+            Display_Path_Id => Project.Directory.Display_Name,\n+            Rank            => 1,\n+            Removed         => False);\n \n       else\n          declare\n@@ -5446,6 +5376,15 @@ package body Prj.Nmsc is\n                  (File_Name_Type (Element.Value), Element.Location, Rank);\n                Source_Dir := Element.Next;\n             end loop;\n+\n+            if Project.Source_Dirs = Nil_String\n+              and then Project.Qualifier = Standard\n+            then\n+               Error_Msg\n+                 (Data.Flags,\n+                  \"a standard project cannot have no source directories\",\n+                  Source_Dirs.Location, Project);\n+            end if;\n          end;\n       end if;\n \n@@ -6895,26 +6834,20 @@ package body Prj.Nmsc is\n             Element := Data.Tree.String_Elements.Table (Source_Dir);\n \n             if Element.Value /= No_Name then\n-               Get_Name_String (Element.Display_Value);\n-\n-               if Current_Verbosity = High then\n-                  Write_Str (\"Directory: \");\n-                  Write_Str (Name_Buffer (1 .. Name_Len));\n-                  Write_Line (Num_Nod.Number'Img);\n-               end if;\n-\n                declare\n+                  --  We use Element.Value, not Display_Value, because we want\n+                  --  the symbolic links to be resolved when appropriate.\n                   Source_Directory : constant String :=\n-                                       Name_Buffer (1 .. Name_Len) &\n-                                         Directory_Separator;\n-\n+                                       Get_Name_String (Element.Value)\n+                                         & Directory_Separator;\n                   Dir_Last : constant Natural :=\n                                        Compute_Directory_Last\n                                          (Source_Directory);\n \n                begin\n                   if Current_Verbosity = High then\n                      Write_Attr (\"Source_Dir\", Source_Directory);\n+                     Write_Line (Num_Nod.Number'Img);\n                   end if;\n \n                   --  We look to every entry in the source directory\n@@ -6964,7 +6897,6 @@ package body Prj.Nmsc is\n                                             Resolve_Links   =>\n                                               Opt.Follow_Links_For_Files,\n                                             Case_Sensitive => True);\n-                           --  Case_Sensitive set True (no folding)\n \n                            Path : Path_Name_Type;\n                            FF   : File_Found := Excluded_Sources_Htable.Get"}]}