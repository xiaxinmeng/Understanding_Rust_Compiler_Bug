{"sha": "92e1fe674851eff331db253bcb79199716a341f6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTJlMWZlNjc0ODUxZWZmMzMxZGIyNTNiY2I3OTE5OTcxNmEzNDFmNg==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2004-04-20T15:27:38Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2004-04-20T15:27:38Z"}, "message": "Buffer.java, [...]: Fixed javadocs and jalopied all over java.nio.\n\n2004-04-20  Michael Koch  <konqueror@gmx.de>\n\n\t* java/nio/Buffer.java,\n\tjava/nio/channels/AlreadyConnectedException.java,\n\tjava/nio/channels/AsynchronousCloseException.java,\n\tjava/nio/channels/ByteChannel.java,\n\tjava/nio/channels/CancelledKeyException.java,\n\tjava/nio/channels/Channel.java,\n\tjava/nio/channels/Channels.java,\n\tjava/nio/channels/ClosedByInterruptException.java,\n\tjava/nio/channels/ClosedChannelException.java,\n\tjava/nio/channels/ClosedSelectorException.java,\n\tjava/nio/channels/ConnectionPendingException.java,\n\tjava/nio/channels/DatagramChannel.java,\n\tjava/nio/channels/FileChannel.java,\n\tjava/nio/channels/FileLock.java,\n\tjava/nio/channels/FileLockInterruptionException.java,\n\tjava/nio/channels/GatheringByteChannel.java,\n\tjava/nio/channels/IllegalBlockingModeException.java,\n\tjava/nio/channels/IllegalSelectorException.java,\n\tjava/nio/channels/InterruptibleChannel.java,\n\tjava/nio/channels/NoConnectionPendingException.java,\n\tjava/nio/channels/NonReadableChannelException.java,\n\tjava/nio/channels/NonWritableChannelException.java,\n\tjava/nio/channels/NotYetBoundException.java,\n\tjava/nio/channels/NotYetConnectedException.java,\n\tjava/nio/channels/OverlappingFileLockException.java,\n\tjava/nio/channels/Pipe.java,\n\tjava/nio/channels/ReadableByteChannel.java,\n\tjava/nio/channels/ScatteringByteChannel.java,\n\tjava/nio/channels/SelectableChannel.java,\n\tjava/nio/channels/SelectionKey.java,\n\tjava/nio/channels/Selector.java,\n\tjava/nio/channels/ServerSocketChannel.java,\n\tjava/nio/channels/SocketChannel.java,\n\tjava/nio/channels/UnresolvedAddressException.java,\n\tjava/nio/channels/UnsupportedAddressTypeException.java,\n\tjava/nio/channels/WritableByteChannel.java,\n\tjava/nio/channels/spi/AbstractInterruptibleChannel.java,\n\tjava/nio/channels/spi/AbstractSelectableChannel.java,\n\tjava/nio/channels/spi/AbstractSelectionKey.java,\n\tjava/nio/channels/spi/AbstractSelector.java,\n\tjava/nio/channels/spi/SelectorProvider.java,\n\tjava/nio/charset/spi/CharsetProvider.java:\n\tFixed javadocs and jalopied all over java.nio.\n\nFrom-SVN: r80909", "tree": {"sha": "9914edd6a6325b7030a0b0da34b29e407a5403e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9914edd6a6325b7030a0b0da34b29e407a5403e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/92e1fe674851eff331db253bcb79199716a341f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92e1fe674851eff331db253bcb79199716a341f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92e1fe674851eff331db253bcb79199716a341f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92e1fe674851eff331db253bcb79199716a341f6/comments", "author": null, "committer": null, "parents": [{"sha": "08c5d75719821940cc39591681aaec3c7fdc63ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08c5d75719821940cc39591681aaec3c7fdc63ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08c5d75719821940cc39591681aaec3c7fdc63ce"}], "stats": {"total": 1114, "additions": 656, "deletions": 458}, "files": [{"sha": "d931b32ba1132e670ff1d64f6e77fd25ef48f0a4", "filename": "libjava/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e1fe674851eff331db253bcb79199716a341f6/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e1fe674851eff331db253bcb79199716a341f6/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=92e1fe674851eff331db253bcb79199716a341f6", "patch": "@@ -1,3 +1,49 @@\n+2004-04-20  Michael Koch  <konqueror@gmx.de>\n+\n+\t* java/nio/Buffer.java,\n+\tjava/nio/channels/AlreadyConnectedException.java,\n+\tjava/nio/channels/AsynchronousCloseException.java,\n+\tjava/nio/channels/ByteChannel.java,\n+\tjava/nio/channels/CancelledKeyException.java,\n+\tjava/nio/channels/Channel.java,\n+\tjava/nio/channels/Channels.java,\n+\tjava/nio/channels/ClosedByInterruptException.java,\n+\tjava/nio/channels/ClosedChannelException.java,\n+\tjava/nio/channels/ClosedSelectorException.java,\n+\tjava/nio/channels/ConnectionPendingException.java,\n+\tjava/nio/channels/DatagramChannel.java,\n+\tjava/nio/channels/FileChannel.java,\n+\tjava/nio/channels/FileLock.java,\n+\tjava/nio/channels/FileLockInterruptionException.java,\n+\tjava/nio/channels/GatheringByteChannel.java,\n+\tjava/nio/channels/IllegalBlockingModeException.java,\n+\tjava/nio/channels/IllegalSelectorException.java,\n+\tjava/nio/channels/InterruptibleChannel.java,\n+\tjava/nio/channels/NoConnectionPendingException.java,\n+\tjava/nio/channels/NonReadableChannelException.java,\n+\tjava/nio/channels/NonWritableChannelException.java,\n+\tjava/nio/channels/NotYetBoundException.java,\n+\tjava/nio/channels/NotYetConnectedException.java,\n+\tjava/nio/channels/OverlappingFileLockException.java,\n+\tjava/nio/channels/Pipe.java,\n+\tjava/nio/channels/ReadableByteChannel.java,\n+\tjava/nio/channels/ScatteringByteChannel.java,\n+\tjava/nio/channels/SelectableChannel.java,\n+\tjava/nio/channels/SelectionKey.java,\n+\tjava/nio/channels/Selector.java,\n+\tjava/nio/channels/ServerSocketChannel.java,\n+\tjava/nio/channels/SocketChannel.java,\n+\tjava/nio/channels/UnresolvedAddressException.java,\n+\tjava/nio/channels/UnsupportedAddressTypeException.java,\n+\tjava/nio/channels/WritableByteChannel.java,\n+\tjava/nio/channels/spi/AbstractInterruptibleChannel.java,\n+\tjava/nio/channels/spi/AbstractSelectableChannel.java,\n+\tjava/nio/channels/spi/AbstractSelectionKey.java,\n+\tjava/nio/channels/spi/AbstractSelector.java,\n+\tjava/nio/channels/spi/SelectorProvider.java,\n+\tjava/nio/charset/spi/CharsetProvider.java:\n+\tFixed javadocs and jalopied all over java.nio.\n+\n 2004-04-20  Michael Koch  <konqueror@gmx.de>\n \n \t* java/nio/ByteBufferImpl.java,"}, {"sha": "c24259f71ec2a86ea7b054447d5f53fceded22d8", "filename": "libjava/java/nio/Buffer.java", "status": "modified", "additions": 34, "deletions": 6, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2FBuffer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2FBuffer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2FBuffer.java?ref=92e1fe674851eff331db253bcb79199716a341f6", "patch": "@@ -45,10 +45,11 @@\n   int pos = 0;\n   int mark = -1;\n \n-  // Creates a new Buffer.\n-  //\n-  // Should be package private.\n-  //\n+  /**\n+   * Creates a new Buffer.\n+   *\n+   * Should be package private.\n+   */\n   Buffer (int capacity, int limit, int position, int mark)\n   {\n     if (capacity < 0)\n@@ -69,6 +70,8 @@\n   \n   /**\n    * Retrieves the capacity of the buffer.\n+   *\n+   * @return the capacity of the buffer\n    */\n   public final int capacity ()\n   {\n@@ -77,6 +80,8 @@ public final int capacity ()\n \n   /**\n    * Clears the buffer.\n+   *\n+   * @return this buffer\n    */\n   public final Buffer clear ()\n   {\n@@ -88,6 +93,8 @@ public final Buffer clear ()\n     \n   /**\n    * Flips the buffer.\n+   *\n+   * @return this buffer\n    */\n   public final Buffer flip ()\n   {\n@@ -99,6 +106,9 @@ public final Buffer flip ()\n     \n   /**\n    * Tells whether the buffer has remaining data to read or not.\n+   *\n+   * @return true if the buffer contains remaining data to read,\n+   * false otherwise\n    */\n   public final boolean hasRemaining ()\n   {\n@@ -107,11 +117,15 @@ public final boolean hasRemaining ()\n \n   /**\n    * Tells whether this buffer is read only or not.\n+   *\n+   * @return true if the buffer is read only, false otherwise\n    */\n   public abstract boolean isReadOnly ();\n \n   /**\n    * Retrieves the current limit of the buffer.\n+   *\n+   * @return the limit of the buffer\n    */\n   public final int limit ()\n   {\n@@ -124,6 +138,8 @@ public final int limit ()\n    * @param newLimit The new limit value; must be non-negative and no larger\n    * than this buffer's capacity.\n    *\n+   * @return this buffer\n+   *\n    * @exception IllegalArgumentException If the preconditions on newLimit\n    * do not hold.\n    */\n@@ -144,6 +160,8 @@ public final Buffer limit (int newLimit)\n \n   /**\n    * Sets this buffer's mark at its position.\n+   *\n+   * @return this buffer\n    */\n   public final Buffer mark ()\n   {\n@@ -153,6 +171,8 @@ public final Buffer mark ()\n \n   /**\n    * Retrieves the current position of this buffer.\n+   *\n+   * @return the current position of this buffer\n    */\n   public final int position ()\n   {\n@@ -165,7 +185,9 @@ public final int position ()\n    * \n    * @param newPosition The new position value; must be non-negative and no\n    * larger than the current limit.\n-   * \n+   *\n+   * @return this buffer\n+   *\n    * @exception IllegalArgumentException If the preconditions on newPosition\n    * do not hold\n    */\n@@ -183,6 +205,8 @@ public final Buffer position (int newPosition)\n \n   /**\n    * Returns the number of elements between the current position and the limit.\n+   *\n+   * @return the number of remaining elements\n    */\n   public final int remaining()\n   {\n@@ -191,7 +215,9 @@ public final int remaining()\n \n   /**\n    * Resets this buffer's position to the previously-marked position.\n-   * \n+   *\n+   * @return this buffer\n+   *\n    * @exception InvalidMarkException If the mark has not been set.\n    */\n   public final Buffer reset()\n@@ -206,6 +232,8 @@ public final Buffer reset()\n   /**\n    * Rewinds this buffer. The position is set to zero and the mark\n    * is discarded.\n+   *\n+   * @this buffer\n    */\n   public final Buffer rewind()\n   {"}, {"sha": "775d2894da2f73f4ae1aba8f5c217c14ce92ca68", "filename": "libjava/java/nio/channels/AlreadyConnectedException.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FAlreadyConnectedException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FAlreadyConnectedException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2FAlreadyConnectedException.java?ref=92e1fe674851eff331db253bcb79199716a341f6", "patch": "@@ -1,4 +1,4 @@\n-/* AlreadyConnectedException.java -- \n+/* AlreadyConnectedException.java --\n    Copyright (C) 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath."}, {"sha": "d6cfd48ee307f961cf0491f53a72aed142937a78", "filename": "libjava/java/nio/channels/AsynchronousCloseException.java", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FAsynchronousCloseException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FAsynchronousCloseException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2FAsynchronousCloseException.java?ref=92e1fe674851eff331db253bcb79199716a341f6", "patch": "@@ -1,4 +1,4 @@\n-/* AsynchronousCloseException.java -- \n+/* AsynchronousCloseException.java --\n    Copyright (C) 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -37,6 +37,7 @@\n \n package java.nio.channels;\n \n+\n /**\n  * @author Michael Koch\n  * @since 1.4"}, {"sha": "75dd69f7279fe1ba861abe7e2bd45e8741fca183", "filename": "libjava/java/nio/channels/ByteChannel.java", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FByteChannel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FByteChannel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2FByteChannel.java?ref=92e1fe674851eff331db253bcb79199716a341f6", "patch": "@@ -1,4 +1,4 @@\n-/* ByteChannel.java -- \n+/* ByteChannel.java --\n    Copyright (C) 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -37,7 +37,7 @@\n \n package java.nio.channels;\n \n-public interface ByteChannel\n-  extends ReadableByteChannel, WritableByteChannel\n+public interface ByteChannel extends ReadableByteChannel,\n+                                     WritableByteChannel\n {\n }"}, {"sha": "00fb04c43c12830cac99498a85dd514044734b2c", "filename": "libjava/java/nio/channels/CancelledKeyException.java", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FCancelledKeyException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FCancelledKeyException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2FCancelledKeyException.java?ref=92e1fe674851eff331db253bcb79199716a341f6", "patch": "@@ -1,4 +1,4 @@\n-/* CancelledKeyException.java -- \n+/* CancelledKeyException.java --\n    Copyright (C) 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -37,6 +37,7 @@\n \n package java.nio.channels;\n \n+\n /**\n  * @author Michael Koch\n  * @since 1.4"}, {"sha": "fabe183be1fdba6314d62d5afc4ab3b78866b55a", "filename": "libjava/java/nio/channels/Channel.java", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FChannel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FChannel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2FChannel.java?ref=92e1fe674851eff331db253bcb79199716a341f6", "patch": "@@ -1,4 +1,4 @@\n-/* Channel.java -- \n+/* Channel.java --\n    Copyright (C) 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -39,6 +39,7 @@\n \n import java.io.IOException;\n \n+\n public interface Channel\n {\n   /**"}, {"sha": "20ef50d06782d2606e5782e3e609608e767bb966", "filename": "libjava/java/nio/channels/Channels.java", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FChannels.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FChannels.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2FChannels.java?ref=92e1fe674851eff331db253bcb79199716a341f6", "patch": "@@ -1,4 +1,4 @@\n-/* Channels.java -- \n+/* Channels.java --\n    Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -42,20 +42,21 @@\n import gnu.java.nio.InputStreamChannel;\n import gnu.java.nio.OutputStreamChannel;\n import gnu.java.nio.channels.FileChannelImpl;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n import java.io.FileInputStream;\n import java.io.FileOutputStream;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n import java.io.Reader;\n import java.io.Writer;\n import java.nio.charset.Charset;\n import java.nio.charset.CharsetDecoder;\n import java.nio.charset.CharsetEncoder;\n \n+\n /**\n  * @since 1.4\n  */\n-public final class Channels \n+public final class Channels\n {\n   /**\n    * Constructs a stream that reads bytes from the given channel.\n@@ -70,16 +71,17 @@ public static InputStream newInputStream(ReadableByteChannel ch)\n   /**\n    * Constructs a stream that writes bytes to the given channel.\n    */\n-  public static OutputStream newOutputStream(WritableByteChannel ch) \n+  public static OutputStream newOutputStream(WritableByteChannel ch)\n   {\n     if (ch instanceof FileChannelImpl)\n       return newOutputStream((FileChannelImpl) ch);\n     return new ChannelOutputStream(ch);\n   }\n \n   static native FileInputStream newInputStream(FileChannelImpl ch);\n+\n   static native FileOutputStream newOutputStream(FileChannelImpl ch);\n-  \n+\n   /**\n    * Constructs a channel that reads bytes from the given stream.\n    */\n@@ -93,15 +95,15 @@ public static ReadableByteChannel newChannel(InputStream in)\n    */\n   public static WritableByteChannel newChannel(OutputStream out)\n   {\n-    return new OutputStreamChannel (out);\n+    return new OutputStreamChannel(out);\n   }\n \n   /**\n    * Constructs a reader that decodes bytes from the given channel using the\n    * given decoder.\n    */\n-  public static Reader newReader (ReadableByteChannel ch, CharsetDecoder dec,\n-                                  int minBufferCap)\n+  public static Reader newReader(ReadableByteChannel ch, CharsetDecoder dec,\n+                                 int minBufferCap)\n   {\n     throw new Error (\"not implemented\");\n   }\n@@ -113,17 +115,17 @@ public static Reader newReader (ReadableByteChannel ch, CharsetDecoder dec,\n    * @exception UnsupportedCharsetException If no support for the named charset\n    * is available in this instance of the Java virtual machine.\n    */\n-  public static Reader newReader (ReadableByteChannel ch, String csName)\n+  public static Reader newReader(ReadableByteChannel ch, String csName)\n   {\n-    return newReader (ch, Charset.forName (csName).newDecoder (), -1);\n+    return newReader(ch, Charset.forName(csName).newDecoder(), -1);\n   }\n \n   /**\n    * Constructs a writer that encodes characters using the given encoder and\n    * writes the resulting bytes to the given channel.\n    */\n-  public static Writer newWriter (WritableByteChannel ch, CharsetEncoder enc,\n-                                  int minBufferCap)\n+  public static Writer newWriter(WritableByteChannel ch, CharsetEncoder enc,\n+                                 int minBufferCap)\n   {\n     throw new Error (\"not implemented\");\n   }\n@@ -135,9 +137,8 @@ public static Writer newWriter (WritableByteChannel ch, CharsetEncoder enc,\n    * @exception UnsupportedCharsetException If no support for the named charset\n    * is available in this instance of the Java virtual machine.\n    */\n-  public static Writer newWriter (WritableByteChannel ch,\n-                                  String csName)\n+  public static Writer newWriter(WritableByteChannel ch, String csName)\n   {\n-    return newWriter (ch, Charset.forName (csName).newEncoder (), -1);\n+    return newWriter(ch, Charset.forName(csName).newEncoder(), -1);\n   }\n }"}, {"sha": "7a9e64c4f71a26af1b7b88417b87099dbcf790cd", "filename": "libjava/java/nio/channels/ClosedByInterruptException.java", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FClosedByInterruptException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FClosedByInterruptException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2FClosedByInterruptException.java?ref=92e1fe674851eff331db253bcb79199716a341f6", "patch": "@@ -1,4 +1,4 @@\n-/* ClosedByInterruptException.java -- \n+/* ClosedByInterruptException.java --\n    Copyright (C) 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -37,6 +37,7 @@\n \n package java.nio.channels;\n \n+\n /**\n  * @author Michael Koch\n  * @since 1.4"}, {"sha": "876ad062f1f80625f57c660b4745841dfad61b97", "filename": "libjava/java/nio/channels/ClosedChannelException.java", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FClosedChannelException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FClosedChannelException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2FClosedChannelException.java?ref=92e1fe674851eff331db253bcb79199716a341f6", "patch": "@@ -1,4 +1,4 @@\n-/* ClosedChannelException.java -- \n+/* ClosedChannelException.java --\n    Copyright (C) 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -39,6 +39,7 @@\n \n import java.io.IOException;\n \n+\n /**\n  * @author Michael Koch\n  * @since 1.4"}, {"sha": "ae5421d053d15875e4909933725d300031e5601c", "filename": "libjava/java/nio/channels/ClosedSelectorException.java", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FClosedSelectorException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FClosedSelectorException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2FClosedSelectorException.java?ref=92e1fe674851eff331db253bcb79199716a341f6", "patch": "@@ -1,4 +1,4 @@\n-/* ClosedSelectorException.java -- \n+/* ClosedSelectorException.java --\n    Copyright (C) 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -37,6 +37,7 @@\n \n package java.nio.channels;\n \n+\n /**\n  * @author Michael Koch\n  * @since 1.4"}, {"sha": "c224058f0f7af5aa9f9c4bce1b0571c9a920f41e", "filename": "libjava/java/nio/channels/ConnectionPendingException.java", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FConnectionPendingException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FConnectionPendingException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2FConnectionPendingException.java?ref=92e1fe674851eff331db253bcb79199716a341f6", "patch": "@@ -1,4 +1,4 @@\n-/* ConnectionPendingException.java -- \n+/* ConnectionPendingException.java --\n    Copyright (C) 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -37,6 +37,7 @@\n \n package java.nio.channels;\n \n+\n /**\n  * @author Michael Koch\n  * @since 1.4"}, {"sha": "9760b77123e427f9b94e08248c1a67ad15475c28", "filename": "libjava/java/nio/channels/DatagramChannel.java", "status": "modified", "additions": 39, "deletions": 38, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FDatagramChannel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FDatagramChannel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2FDatagramChannel.java?ref=92e1fe674851eff331db253bcb79199716a341f6", "patch": "@@ -1,4 +1,4 @@\n-/* DatagramChannel.java -- \n+/* DatagramChannel.java --\n    Copyright (C) 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -44,60 +44,60 @@\n import java.nio.channels.spi.AbstractSelectableChannel;\n import java.nio.channels.spi.SelectorProvider;\n \n+\n /**\n  * @since 1.4\n  */\n-public abstract class DatagramChannel\n-  extends AbstractSelectableChannel\n+public abstract class DatagramChannel extends AbstractSelectableChannel\n   implements ByteChannel, ScatteringByteChannel, GatheringByteChannel\n {\n   /**\n    * Initializes the channel.\n    */\n-  protected DatagramChannel (SelectorProvider provider)\n+  protected DatagramChannel(SelectorProvider provider)\n   {\n-    super (provider);\n+    super(provider);\n   }\n \n   /**\n    * Opens a datagram channel.\n    *\n    * @exception IOException If an error occurs\n    */\n-  public static DatagramChannel open () throws IOException\n+  public static DatagramChannel open() throws IOException\n   {\n-    return SelectorProvider.provider ().openDatagramChannel ();\n+    return SelectorProvider.provider().openDatagramChannel();\n   }\n-  \n+\n   /**\n    * Reads data from this channel.\n    */\n-  public final long read (ByteBuffer[] dsts) throws IOException\n+  public final long read(ByteBuffer[] dsts) throws IOException\n   {\n     long b = 0;\n-    \n+\n     for (int i = 0; i < dsts.length; i++)\n-      b += read (dsts[i]);\n-    \n+      b += read(dsts[i]);\n+\n     return b;\n   }\n-  \n+\n   /**\n    * Writes data to this channel.\n    *\n    * @exception IOException If an error occurs\n    * @exception NotYetConnectedException The channel's socket is not connected.\n    */\n-  public final long write (ByteBuffer[] srcs) throws IOException\n+  public final long write(ByteBuffer[] srcs) throws IOException\n   {\n     long b = 0;\n-    \n-    for (int i = 0;i < srcs.length; i++)\n-      b += write (srcs[i]);\n-    \n+\n+    for (int i = 0; i < srcs.length; i++)\n+      b += write(srcs[i]);\n+\n     return b;\n   }\n-    \n+\n   /**\n    * Connects this channel's socket.\n    *\n@@ -111,38 +111,38 @@ public final long write (ByteBuffer[] srcs) throws IOException\n    * @exception SecurityException If a security manager has been installed and\n    * it does not permit datagrams to be sent to the given address.\n    */\n-  public abstract DatagramChannel connect (SocketAddress remote)\n+  public abstract DatagramChannel connect(SocketAddress remote)\n     throws IOException;\n \n   /**\n    * Disonnects this channel's socket.\n    *\n    * @exception IOException If an error occurs\n    */\n-  public abstract DatagramChannel disconnect () throws IOException;\n+  public abstract DatagramChannel disconnect() throws IOException;\n \n   /**\n    * Tells whether or not this channel's socket is connected.\n    *\n    * @exception IOException If an error occurs.\n    * @exception NotYetConnectedException The channel's socket is not connected.\n    */\n-  public abstract boolean isConnected ();\n-  \n+  public abstract boolean isConnected();\n+\n   /**\n    * Reads data from this channel.\n    */\n-  public abstract int read (ByteBuffer dst) throws IOException;\n-  \n+  public abstract int read(ByteBuffer dst) throws IOException;\n+\n   /**\n    * Reads data from this channel.\n    *\n    * @exception IOException If an error occurs.\n    * @exception NotYetConnectedException The channel's socket is not connected.\n    */\n-  public abstract long read (ByteBuffer[] dsts, int offset, int length)\n+  public abstract long read(ByteBuffer[] dsts, int offset, int length)\n     throws IOException;\n- \n+\n   /**\n    * Receives a datagram via this channel.\n    *\n@@ -156,8 +156,9 @@ public abstract long read (ByteBuffer[] dsts, int offset, int length)\n    * @exception SecurityException If a security manager has been installed and\n    * it does not permit datagrams to be sent to the given address.\n    */\n-  public abstract SocketAddress receive (ByteBuffer dst) throws IOException;\n- \n+  public abstract SocketAddress receive(ByteBuffer dst)\n+    throws IOException;\n+\n   /**\n    * Sends a datagram via this channel.\n    *\n@@ -171,29 +172,29 @@ public abstract long read (ByteBuffer[] dsts, int offset, int length)\n    * @exception SecurityException If a security manager has been installed and\n    * it does not permit datagrams to be sent to the given address.\n    */\n-  public abstract int send (ByteBuffer src, SocketAddress target)\n+  public abstract int send(ByteBuffer src, SocketAddress target)\n     throws IOException;\n- \n+\n   /**\n    * Retrieves the channel's socket.\n    */\n-  public abstract DatagramSocket socket ();\n-  \n+  public abstract DatagramSocket socket();\n+\n   /**\n    * Writes data to this channel.\n    *\n    * @exception IOException If an error occurs.\n    * @exception NotYetConnectedException The channel's socket is not connected.\n    */\n-  public abstract int write (ByteBuffer src) throws IOException;\n-  \n+  public abstract int write(ByteBuffer src) throws IOException;\n+\n   /**\n    * Writes data to this channel.\n    *\n    * @exception IOException If an error occurs.\n    * @exception NotYetConnectedException The channel's socket is not connected.\n    */\n-  public abstract long write (ByteBuffer[] srcs, int offset, int length)\n+  public abstract long write(ByteBuffer[] srcs, int offset, int length)\n     throws IOException;\n \n   /**\n@@ -202,8 +203,8 @@ public abstract long write (ByteBuffer[] srcs, int offset, int length)\n    * @exception IOException If an error occurs.\n    * @exception NotYetConnectedException The channel's socket is not connected.\n    */\n-  public final int validOps ()\n+  public final int validOps()\n   {\n     return SelectionKey.OP_READ | SelectionKey.OP_WRITE;\n-  }    \n+  }\n }"}, {"sha": "7e1a33173eb54d4eed57803a1080ce287ee34026", "filename": "libjava/java/nio/channels/FileChannel.java", "status": "modified", "additions": 41, "deletions": 42, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FFileChannel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FFileChannel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2FFileChannel.java?ref=92e1fe674851eff331db253bcb79199716a341f6", "patch": "@@ -1,4 +1,4 @@\n-/* FileChannel.java -- \n+/* FileChannel.java --\n    Copyright (C) 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -42,6 +42,7 @@\n import java.nio.MappedByteBuffer;\n import java.nio.channels.spi.AbstractInterruptibleChannel;\n \n+\n /**\n  * @author Michael Koch\n  * @since 1.4\n@@ -52,10 +53,9 @@ public abstract class FileChannel extends AbstractInterruptibleChannel\n   public static class MapMode\n   {\n     int m;\n-\n-    public static final MapMode READ_ONLY  = new MapMode(0);\n+    public static final MapMode READ_ONLY = new MapMode(0);\n     public static final MapMode READ_WRITE = new MapMode(1);\n-    public static final MapMode PRIVATE    = new MapMode(2);\n+    public static final MapMode PRIVATE = new MapMode(2);\n \n     /**\n      * Initializes the MapMode.\n@@ -68,12 +68,12 @@ public abstract class FileChannel extends AbstractInterruptibleChannel\n     /**\n      * Returns a string representation of the <code>MapMode</code> object.\n      */\n-    public String toString() \n+    public String toString()\n     {\n       if (this == READ_ONLY)\n-        return \"READ_ONLY\";\n+\treturn \"READ_ONLY\";\n       else if (this == READ_WRITE)\n-        return \"READ_WRITE\";\n+\treturn \"READ_WRITE\";\n \n       return \"PRIVATE\";\n     }\n@@ -82,7 +82,7 @@ else if (this == READ_WRITE)\n   /**\n    * Initializes the channel.\n    */\n-  protected FileChannel ()\n+  protected FileChannel()\n   {\n   }\n \n@@ -102,34 +102,32 @@ public abstract MappedByteBuffer map(MapMode mode, long position, long size)\n \n   /**\n    * Return the size of the file thus far\n-   * \n+   *\n    * @exception ClosedChannelException If this channel is closed.\n    */\n   public abstract long size() throws IOException;\n-  \n+\n   /**\n    * Writes data to the channel.\n    *\n    * @exception IOException If an I/O error occurs.\n    */\n-  public final long write (ByteBuffer[] srcs) throws IOException\n+  public final long write(ByteBuffer[] srcs) throws IOException\n   {\n     long result = 0;\n-    \n+\n     for (int i = 0; i < srcs.length; i++)\n-      {\n-        result += write (srcs[i]);\n-      }\n-    \n+      result += write(srcs[i]);\n+\n     return result;\n   }\n-  \n+\n   /**\n    * Writes data to the channel.\n    *\n    * @exception IOException If an I/O error occurs.\n    */\n-  public abstract int write (ByteBuffer src) throws IOException;\n+  public abstract int write(ByteBuffer src) throws IOException;\n \n   /**\n    * Writes data to the channel.\n@@ -145,7 +143,8 @@ public final long write (ByteBuffer[] srcs) throws IOException\n    * @exception NonWritableChannelException If this channel was not opened for\n    * writing.\n    */\n-  public abstract int write (ByteBuffer srcs, long position) throws IOException;\n+  public abstract int write(ByteBuffer srcs, long position)\n+    throws IOException;\n \n   /**\n    * Writes data to the channel.\n@@ -154,28 +153,26 @@ public final long write (ByteBuffer[] srcs) throws IOException\n    */\n   public abstract long write(ByteBuffer[] srcs, int offset, int length)\n     throws IOException;\n-  \n+\n   /**\n    * Reads data from the channel.\n    *\n    * @exception IOException If an I/O error occurs.\n    */\n-  public abstract long read (ByteBuffer[] dsts, int offset, int length)\n+  public abstract long read(ByteBuffer[] dsts, int offset, int length)\n     throws IOException;\n \n   /**\n    * Reads data from the channel.\n    *\n    * @exception IOException If an I/O error occurs.\n    */\n-  public final long read (ByteBuffer[] dsts) throws IOException\n+  public final long read(ByteBuffer[] dsts) throws IOException\n   {\n     long result = 0;\n-    \n+\n     for (int i = 0; i < dsts.length; i++)\n-      {\n-        read (dsts [i]);\n-      }\n+      read(dsts[i]);\n \n     return result;\n   }\n@@ -186,7 +183,7 @@ public final long read (ByteBuffer[] dsts) throws IOException\n    * @exception IOException If an I/O error occurs.\n    */\n   public abstract int read(ByteBuffer dst) throws IOException;\n-  \n+\n   /**\n    * Reads data from the channel.\n    *\n@@ -201,8 +198,9 @@ public final long read (ByteBuffer[] dsts) throws IOException\n    * @exception NonReadableChannelException If this channel was not opened for\n    * reading.\n    */\n-  public abstract int read(ByteBuffer dst, long position) throws IOException;\n-  \n+  public abstract int read(ByteBuffer dst, long position)\n+    throws IOException;\n+\n   /**\n    * Closes the channel.\n    *\n@@ -238,9 +236,9 @@ public final long read (ByteBuffer[] dsts) throws IOException\n    * another thread is already blocked in this method and is attempting to lock\n    * an overlapping region.\n    */\n-  public final FileLock lock () throws IOException\n+  public final FileLock lock() throws IOException\n   {\n-    return lock (0, Long.MAX_VALUE, false);\n+    return lock(0, Long.MAX_VALUE, false);\n   }\n \n   /**\n@@ -263,7 +261,7 @@ public final FileLock lock () throws IOException\n    * @exception NonWritableChannelException If shared is false and this channel\n    * was not opened for writing.\n    */\n-  public abstract FileLock lock (long position, long size, boolean shared)\n+  public abstract FileLock lock(long position, long size, boolean shared)\n     throws IOException;\n \n   /**\n@@ -276,9 +274,9 @@ public abstract FileLock lock (long position, long size, boolean shared)\n    * another thread is already blocked in this method and is attempting to lock\n    * an overlapping region.\n    */\n-  public final FileLock tryLock () throws IOException\n+  public final FileLock tryLock() throws IOException\n   {\n-    return tryLock (0, Long.MAX_VALUE, false);\n+    return tryLock(0, Long.MAX_VALUE, false);\n   }\n \n   /**\n@@ -293,7 +291,7 @@ public final FileLock tryLock () throws IOException\n    * another thread is already blocked in this method and is attempting to lock\n    * an overlapping region.\n    */\n-  public abstract FileLock tryLock (long position, long size, boolean shared)\n+  public abstract FileLock tryLock(long position, long size, boolean shared)\n     throws IOException;\n \n   /**\n@@ -302,7 +300,7 @@ public abstract FileLock tryLock (long position, long size, boolean shared)\n    * @exception ClosedChannelException If this channel is closed.\n    * @exception IOException If an I/O error occurs.\n    */\n-  public abstract long position () throws IOException;\n+  public abstract long position() throws IOException;\n \n   /**\n    * Sets the position of the channel on the assoziated file.\n@@ -311,7 +309,8 @@ public abstract FileLock tryLock (long position, long size, boolean shared)\n    * @exception IllegalArgumentException If newPosition is negative.\n    * @exception IOException If an I/O error occurs.\n    */\n-  public abstract FileChannel position (long newPosition) throws IOException;\n+  public abstract FileChannel position(long newPosition)\n+    throws IOException;\n \n   /**\n    * Transfers bytes from this channel's file to the given writable byte\n@@ -331,8 +330,8 @@ public abstract FileLock tryLock (long position, long size, boolean shared)\n    * @exception NonWritableChannelException If the target channel was not\n    * opened for writing.\n    */\n-  public abstract long transferTo (long position, long count,\n-                                   WritableByteChannel target)\n+  public abstract long transferTo(long position, long count,\n+                                  WritableByteChannel target)\n     throws IOException;\n \n   /**\n@@ -352,8 +351,8 @@ public abstract long transferTo (long position, long count,\n    * @exception NonWritableChannelException If this channel was not opened for\n    * writing.\n    */\n-  public abstract long transferFrom (ReadableByteChannel src, long position,\n-                                     long count) throws IOException;\n+  public abstract long transferFrom(ReadableByteChannel src, long position,\n+                                    long count) throws IOException;\n \n   /**\n    * Truncates the channel's file at <code>size</code>.\n@@ -364,5 +363,5 @@ public abstract long transferFrom (ReadableByteChannel src, long position,\n    * @exception NonWritableChannelException If this channel was not opened for\n    * writing.\n    */\n-  public abstract FileChannel truncate (long size) throws IOException;\n+  public abstract FileChannel truncate(long size) throws IOException;\n }"}, {"sha": "629f5ef79ec8aa513c934d8df729f13ad974236e", "filename": "libjava/java/nio/channels/FileLock.java", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FFileLock.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FFileLock.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2FFileLock.java?ref=92e1fe674851eff331db253bcb79199716a341f6", "patch": "@@ -1,4 +1,4 @@\n-/* FileLock.java -- \n+/* FileLock.java --\n    Copyright (C) 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -39,6 +39,7 @@\n \n import java.io.IOException;\n \n+\n /**\n  * @since 1.4\n  */\n@@ -48,58 +49,57 @@\n   long position;\n   long size;\n   boolean shared;\n-  \n+\n   /**\n    * Initializes the file lock.\n    *\n    * @exception IllegalArgumentException If the preconditions on the parameters do not hold\n    */\n-  protected FileLock (FileChannel channel, long position, long size,\n-                      boolean shared)\n+  protected FileLock(FileChannel channel, long position, long size,\n+                     boolean shared)\n   {\n-    if (position < 0 ||\n-        size < 0)\n-      throw new IllegalArgumentException ();\n+    if (position < 0 || size < 0)\n+      throw new IllegalArgumentException();\n \n     this.channel = channel;\n     this.position = position;\n     this.size = size;\n     this.shared = shared;\n   }\n- \n+\n   /**\n    * Tells whether or not this lock is valid.\n    */\n   public abstract boolean isValid();\n- \n+\n   /**\n    * Releases this lock.\n    *\n    * @exception IOException If an error occurs\n    * @exception ClosedChannelException If the locked channel is no longer open.\n    */\n-  public abstract void release () throws IOException;\n-  \n+  public abstract void release() throws IOException;\n+\n   /**\n    * Returns the file channel upon whose file this lock is held.\n    */\n-  public final FileChannel channel ()\n+  public final FileChannel channel()\n   {\n     return channel;\n   }\n \n   /**\n    * Tells whether this lock is shared.\n    */\n-  public final boolean isShared ()\n+  public final boolean isShared()\n   {\n     return shared;\n-  }    \n+  }\n \n   /**\n    * Tells whether or not this lock overlaps the given lock range.\n    */\n-  public final boolean overlaps (long position, long size)\n+  public final boolean overlaps(long position, long size)\n   {\n     if (position > this.position + this.size)\n       return false;\n@@ -114,23 +114,23 @@ public final boolean overlaps (long position, long size)\n    * Returns the position within the file of the first byte of the\n    * locked region.\n    */\n-  public final long position ()\n+  public final long position()\n   {\n     return position;\n   }\n-    \n+\n   /**\n    * Returns the size of the locked region in bytes.\n    */\n-  public final long size ()\n+  public final long size()\n   {\n     return size;\n   }\n \n   /**\n    * Returns a string describing the range, type, and validity of this lock.\n    */\n-  public final String toString ()\n+  public final String toString()\n   {\n     return \"file-lock:pos=\" + position + \"size=\" + size;\n   }"}, {"sha": "5caff1707432135e16d2afdffc207501b060f753", "filename": "libjava/java/nio/channels/FileLockInterruptionException.java", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FFileLockInterruptionException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FFileLockInterruptionException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2FFileLockInterruptionException.java?ref=92e1fe674851eff331db253bcb79199716a341f6", "patch": "@@ -1,4 +1,4 @@\n-/* FileLockInterruptionException.java -- \n+/* FileLockInterruptionException.java --\n    Copyright (C) 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -39,6 +39,7 @@\n \n import java.io.IOException;\n \n+\n /**\n  * @author Michael Koch\n  * @since 1.4"}, {"sha": "80f50c875fe7f3bc7d9d0176b1a948be4a2257eb", "filename": "libjava/java/nio/channels/GatheringByteChannel.java", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FGatheringByteChannel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FGatheringByteChannel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2FGatheringByteChannel.java?ref=92e1fe674851eff331db253bcb79199716a341f6", "patch": "@@ -1,4 +1,4 @@\n-/* GatheringByteChannel.java -- \n+/* GatheringByteChannel.java --\n    Copyright (C) 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -37,11 +37,11 @@\n \n package java.nio.channels;\n \n-import java.nio.ByteBuffer;\n import java.io.IOException;\n+import java.nio.ByteBuffer;\n \n-public interface GatheringByteChannel\n-  extends WritableByteChannel\n+\n+public interface GatheringByteChannel extends WritableByteChannel\n {\n   /**\n    * Writes a sequence of bytes to this channel from a subsequence of\n@@ -59,9 +59,9 @@\n    * @exception NonWritableChannelException If this channel was not opened for\n    * writing\n    */\n-  long write (ByteBuffer[] srcs, int offset, int length)\n+  long write(ByteBuffer[] srcs, int offset, int length)\n     throws IOException;\n-  \n+\n   /**\n    * Writes a sequence of bytes to this channel from the given buffers\n    *\n@@ -75,5 +75,5 @@ long write (ByteBuffer[] srcs, int offset, int length)\n    * @exception NonWritableChannelException If this channel was not opened for\n    * writing\n    */\n-  long write (ByteBuffer[] srcs) throws IOException;\n+  long write(ByteBuffer[] srcs) throws IOException;\n }"}, {"sha": "5b70c1f5814763c14ccc9777f11fdb065ad66b46", "filename": "libjava/java/nio/channels/IllegalBlockingModeException.java", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FIllegalBlockingModeException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FIllegalBlockingModeException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2FIllegalBlockingModeException.java?ref=92e1fe674851eff331db253bcb79199716a341f6", "patch": "@@ -1,4 +1,4 @@\n-/* IllegalBlockingModeException.java -- \n+/* IllegalBlockingModeException.java --\n    Copyright (C) 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -37,6 +37,7 @@\n \n package java.nio.channels;\n \n+\n /**\n  * @author Michael Koch <konqueror@gmx.de>\n  * @since 1.4"}, {"sha": "d1421e45653cf653340b14776e020a3996e9b0f5", "filename": "libjava/java/nio/channels/IllegalSelectorException.java", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FIllegalSelectorException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FIllegalSelectorException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2FIllegalSelectorException.java?ref=92e1fe674851eff331db253bcb79199716a341f6", "patch": "@@ -1,4 +1,4 @@\n-/* IllegalSelectorException.java -- \n+/* IllegalSelectorException.java --\n    Copyright (C) 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -37,6 +37,7 @@\n \n package java.nio.channels;\n \n+\n /**\n  * @author Michael Koch\n  * @since 1.4"}, {"sha": "ad4195efb0fa263d8fb6553a988938e8868ea20e", "filename": "libjava/java/nio/channels/InterruptibleChannel.java", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FInterruptibleChannel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FInterruptibleChannel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2FInterruptibleChannel.java?ref=92e1fe674851eff331db253bcb79199716a341f6", "patch": "@@ -1,4 +1,4 @@\n-/* InterruptibleChannel.java -- \n+/* InterruptibleChannel.java --\n    Copyright (C) 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -39,6 +39,7 @@\n \n import java.io.IOException;\n \n+\n public interface InterruptibleChannel extends Channel\n {\n   /**"}, {"sha": "4dbe7f96a8559ecb94be2c5b1b51466fa70cf844", "filename": "libjava/java/nio/channels/NoConnectionPendingException.java", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FNoConnectionPendingException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FNoConnectionPendingException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2FNoConnectionPendingException.java?ref=92e1fe674851eff331db253bcb79199716a341f6", "patch": "@@ -1,4 +1,4 @@\n-/* NoConnectionPendingException.java -- \n+/* NoConnectionPendingException.java --\n    Copyright (C) 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -37,6 +37,7 @@\n \n package java.nio.channels;\n \n+\n /**\n  * @author Michael Koch\n  * @since 1.4"}, {"sha": "ff3bd4a9edf06756bc3ca93212dbcb131aa2be68", "filename": "libjava/java/nio/channels/NonReadableChannelException.java", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FNonReadableChannelException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FNonReadableChannelException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2FNonReadableChannelException.java?ref=92e1fe674851eff331db253bcb79199716a341f6", "patch": "@@ -1,4 +1,4 @@\n-/* NonReadableChannelException.java -- \n+/* NonReadableChannelException.java --\n    Copyright (C) 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -37,6 +37,7 @@\n \n package java.nio.channels;\n \n+\n /**\n  * @author Michael Koch\n  * @since 1.4"}, {"sha": "363041ba97a8b998095e9a52c4fac1bc5f72012d", "filename": "libjava/java/nio/channels/NonWritableChannelException.java", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FNonWritableChannelException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FNonWritableChannelException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2FNonWritableChannelException.java?ref=92e1fe674851eff331db253bcb79199716a341f6", "patch": "@@ -1,4 +1,4 @@\n-/* NonWritableChannelException.java -- \n+/* NonWritableChannelException.java --\n    Copyright (C) 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -37,6 +37,7 @@\n \n package java.nio.channels;\n \n+\n /**\n  * @author Michael Koch\n  * @since 1.4"}, {"sha": "167d5b5be64cff4ed646a59fbb6f7b83ce88bd5e", "filename": "libjava/java/nio/channels/NotYetBoundException.java", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FNotYetBoundException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FNotYetBoundException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2FNotYetBoundException.java?ref=92e1fe674851eff331db253bcb79199716a341f6", "patch": "@@ -1,4 +1,4 @@\n-/* NotYetBoundException.java -- \n+/* NotYetBoundException.java --\n    Copyright (C) 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -37,6 +37,7 @@\n \n package java.nio.channels;\n \n+\n /**\n  * @author Michael Koch\n  * @since 1.4"}, {"sha": "671ad1a421ded1e89ac346d33e3bbdddf905aedf", "filename": "libjava/java/nio/channels/NotYetConnectedException.java", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FNotYetConnectedException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FNotYetConnectedException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2FNotYetConnectedException.java?ref=92e1fe674851eff331db253bcb79199716a341f6", "patch": "@@ -1,4 +1,4 @@\n-/* NotYetConnectedException.java -- \n+/* NotYetConnectedException.java --\n    Copyright (C) 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -37,6 +37,7 @@\n \n package java.nio.channels;\n \n+\n /**\n  * @author Michael Koch\n  * @since 1.4"}, {"sha": "d3435264dabb8bf3ad702bb4385bf336a96d3693", "filename": "libjava/java/nio/channels/OverlappingFileLockException.java", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FOverlappingFileLockException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FOverlappingFileLockException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2FOverlappingFileLockException.java?ref=92e1fe674851eff331db253bcb79199716a341f6", "patch": "@@ -1,4 +1,4 @@\n-/* OverlappingFileLockException.java -- \n+/* OverlappingFileLockException.java --\n    Copyright (C) 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -37,6 +37,7 @@\n \n package java.nio.channels;\n \n+\n /**\n  * @author Michael Koch\n  * @since 1.4"}, {"sha": "baee1fa563d1392a6f17e6756e8feea759072458", "filename": "libjava/java/nio/channels/Pipe.java", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FPipe.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FPipe.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2FPipe.java?ref=92e1fe674851eff331db253bcb79199716a341f6", "patch": "@@ -1,4 +1,4 @@\n-/* Pipe.java -- \n+/* Pipe.java --\n    Copyright (C) 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -41,53 +41,52 @@\n import java.nio.channels.spi.AbstractSelectableChannel;\n import java.nio.channels.spi.SelectorProvider;\n \n+\n /**\n  * @author Michael Koch\n  * @since 1.4\n  */\n public abstract class Pipe\n {\n-  public abstract static class SinkChannel\n-    extends AbstractSelectableChannel\n+  public abstract static class SinkChannel extends AbstractSelectableChannel\n     implements WritableByteChannel, GatheringByteChannel\n   {\n     /**\n      * Initializes the channel.\n      */\n-    protected SinkChannel (SelectorProvider provider)\n+    protected SinkChannel(SelectorProvider provider)\n     {\n-      super (provider);\n+      super(provider);\n     }\n \n     /**\n      * Returns an operation set that is valid on this channel.\n      *\n      * The only valid operation on this channel is @see SelectionKey.OP_WRITE.\n      */\n-    public final int validOps ()\n+    public final int validOps()\n     {\n       return SelectionKey.OP_WRITE;\n     }\n   }\n \n-  public abstract static class SourceChannel\n-    extends AbstractSelectableChannel\n+  public abstract static class SourceChannel extends AbstractSelectableChannel\n     implements ReadableByteChannel, ScatteringByteChannel\n   {\n     /**\n      * Initializes the channel.\n      */\n-    protected SourceChannel (SelectorProvider provider)\n+    protected SourceChannel(SelectorProvider provider)\n     {\n-      super (provider);\n+      super(provider);\n     }\n \n     /**\n      * Returns an operation set that is valid on this channel.\n      *\n      * The only valid operation on this channel is @see SelectionKey.OP_READ.\n      */\n-    public final int validOps ()\n+    public final int validOps()\n     {\n       return SelectionKey.OP_READ;\n     }\n@@ -102,12 +101,12 @@ protected Pipe()\n \n   /**\n    * Opens a pipe.\n-   * \n+   *\n    * @exception IOException If an error occurs\n    */\n   public static Pipe open() throws IOException\n   {\n-    return SelectorProvider.provider ().openPipe();\n+    return SelectorProvider.provider().openPipe();\n   }\n \n   /**\n@@ -118,5 +117,5 @@ public static Pipe open() throws IOException\n   /**\n    * Returns a pipe's source channel\n    */\n-  public abstract Pipe.SourceChannel source();   \n+  public abstract Pipe.SourceChannel source();\n }"}, {"sha": "fb39dcb582f80baf13a7b568314845aa1177063a", "filename": "libjava/java/nio/channels/ReadableByteChannel.java", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FReadableByteChannel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FReadableByteChannel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2FReadableByteChannel.java?ref=92e1fe674851eff331db253bcb79199716a341f6", "patch": "@@ -1,5 +1,5 @@\n-/* ReadableByteChannel.java -- \n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+/* ReadableByteChannel.java --\n+   Copyright (C) 2002, 2004  Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -40,11 +40,16 @@\n import java.io.IOException;\n import java.nio.ByteBuffer;\n \n+\n public interface ReadableByteChannel extends Channel\n {\n   /**\n    * Reads a sequence of bytes from this channel into the given buffer\n    *\n+   * @param dst the buffer to put the read data into\n+   *\n+   * @return the numer of bytes read\n+   *\n    * @exception AsynchronousCloseException If another thread closes this\n    * channel while the read operation is in progress\n    * @exception ClosedByInterruptException If another thread interrupts the\n@@ -55,5 +60,5 @@ public interface ReadableByteChannel extends Channel\n    * @exception NonReadableChannelException If this channel was not opened for\n    * reading\n    */\n-  int read (ByteBuffer dst) throws IOException;\n+  int read(ByteBuffer dst) throws IOException;\n }"}, {"sha": "7c754065f97db73e81ec7e723d4664a64b97396e", "filename": "libjava/java/nio/channels/ScatteringByteChannel.java", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FScatteringByteChannel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FScatteringByteChannel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2FScatteringByteChannel.java?ref=92e1fe674851eff331db253bcb79199716a341f6", "patch": "@@ -1,4 +1,4 @@\n-/* ScatteringByteChannel.java -- \n+/* ScatteringByteChannel.java --\n    Copyright (C) 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -37,11 +37,11 @@\n \n package java.nio.channels;\n \n-import java.nio.ByteBuffer;\n import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n \n-public interface ScatteringByteChannel\n-  extends ReadableByteChannel\n+public interface ScatteringByteChannel extends ReadableByteChannel\n {\n   /**\n    * Reads a sequence of bytes from this channel into a subsequence of the\n@@ -59,7 +59,7 @@\n    * @exception NonReadableChannelException If this channel was not opened for\n    * reading\n    */\n-  long read (ByteBuffer[] srcs, int offset, int length)\n+  long read(ByteBuffer[] srcs, int offset, int length)\n     throws IOException;\n \n   /**\n@@ -75,5 +75,5 @@ long read (ByteBuffer[] srcs, int offset, int length)\n    * @exception NonReadableChannelException If this channel was not opened for\n    * reading\n    */\n-  long read (ByteBuffer[] srcs) throws IOException;\n+  long read(ByteBuffer[] srcs) throws IOException;\n }"}, {"sha": "de1e31d076b747e163e9de5727d78baa81d7dc6c", "filename": "libjava/java/nio/channels/SelectableChannel.java", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FSelectableChannel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FSelectableChannel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2FSelectableChannel.java?ref=92e1fe674851eff331db253bcb79199716a341f6", "patch": "@@ -1,4 +1,4 @@\n-/* SelectableChannel.java -- \n+/* SelectableChannel.java --\n    Copyright (C) 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -41,62 +41,62 @@\n import java.nio.channels.spi.AbstractInterruptibleChannel;\n import java.nio.channels.spi.SelectorProvider;\n \n+\n /**\n  * @author Michael Koch\n  * @since 1.4\n  */\n-public abstract class SelectableChannel\n-  extends AbstractInterruptibleChannel\n+public abstract class SelectableChannel extends AbstractInterruptibleChannel\n {\n   /**\n    * Initializes the channel.\n    */\n-  protected SelectableChannel ()\n+  protected SelectableChannel()\n   {\n   }\n- \n+\n   /**\n    * Returns the lock of this channel.\n    */\n-  public abstract Object blockingLock ();\n+  public abstract Object blockingLock();\n \n   /**\n    * Adjusts this channel's blocking mode.\n-   * \n+   *\n    * @exception ClosedChannelException If this channel is closed.\n    * @exception IllegalBlockingModeException If block is true and this channel\n    * is registered with one or more selectors.\n    * @exception IOException If an error occurs.\n    */\n-  public abstract SelectableChannel configureBlocking (boolean block)\n+  public abstract SelectableChannel configureBlocking(boolean block)\n     throws IOException;\n-  \n+\n   /**\n    * Tells whether this channel is blocking or not.\n    */\n-  public abstract boolean isBlocking ();\n-  \n+  public abstract boolean isBlocking();\n+\n   /**\n    * Tells whether or not this channel is currently registered with\n    * any selectors.\n    */\n-  public abstract boolean isRegistered ();\n-  \n+  public abstract boolean isRegistered();\n+\n   /**\n    * Retrieves the key representing the channel's registration with\n    * the given selector.\n    */\n-  public abstract SelectionKey keyFor (Selector sel);\n-  \n+  public abstract SelectionKey keyFor(Selector sel);\n+\n   /**\n    * Returns the provider that created this channel.\n    */\n-  public abstract SelectorProvider provider ();\n-  \n+  public abstract SelectorProvider provider();\n+\n   /**\n    * Registers this channel with the given selector,\n    * returning a selection key.\n-   * \n+   *\n    * @exception CancelledKeyException If this channel is currently registered\n    * with the given selector but the corresponding key has already been cancelled\n    * @exception ClosedChannelException If this channel is closed.\n@@ -108,12 +108,12 @@ public abstract SelectableChannel configureBlocking (boolean block)\n    * @exception IllegalSelectorException If this channel was not created by\n    * the same provider as the given selector.\n    */\n-  public final SelectionKey register (Selector sel, int ops)\n+  public final SelectionKey register(Selector sel, int ops)\n     throws ClosedChannelException\n   {\n-    return register (sel, ops, null);\n+    return register(sel, ops, null);\n   }\n-  \n+\n   /**\n    * Registers this channel with the given selector,\n    * returning a selection key.\n@@ -130,9 +130,9 @@ public final SelectionKey register (Selector sel, int ops)\n    * @exception IllegalSelectorException If this channel was not created by\n    * the same provider as the given selector.\n    */\n-  public abstract SelectionKey register (Selector sel, int ops, Object att)\n+  public abstract SelectionKey register(Selector sel, int ops, Object att)\n     throws ClosedChannelException;\n-  \n+\n   /**\n    * Returns a set of valid operations on this channel.\n    */"}, {"sha": "95e7f26fce470c552f8703e0ac7d5cd6027e8cee", "filename": "libjava/java/nio/channels/SelectionKey.java", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FSelectionKey.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FSelectionKey.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2FSelectionKey.java?ref=92e1fe674851eff331db253bcb79199716a341f6", "patch": "@@ -1,4 +1,4 @@\n-/* SelectionKey.java -- \n+/* SelectionKey.java --\n    Copyright (C) 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -37,128 +37,128 @@\n \n package java.nio.channels;\n \n+\n /**\n  * @author Michael Koch\n  * @since 1.4\n  */\n public abstract class SelectionKey\n {\n-  public static final int OP_ACCEPT  = 16;\n+  public static final int OP_ACCEPT = 16;\n   public static final int OP_CONNECT = 8;\n-  public static final int OP_READ    = 1;\n-  public static final int OP_WRITE   = 4;\n-    \n+  public static final int OP_READ = 1;\n+  public static final int OP_WRITE = 4;\n   Object attached;\n-   \n+\n   /**\n    * Initializes the selection key.\n    */\n-  protected SelectionKey ()\n+  protected SelectionKey()\n   {\n   }\n \n   /**\n    * Attaches obj to the key and returns the old attached object.\n    */\n-  public final Object attach (Object obj)\n+  public final Object attach(Object obj)\n   {\n     Object old = attached;\n     attached = obj;\n     return old;\n   }\n-   \n+\n   /**\n    * Returns the object attached to the key.\n    */\n-  public final Object attachment ()\n+  public final Object attachment()\n   {\n     return attached;\n-  }    \n+  }\n \n   /**\n    * Tests if the channel attached to this key is ready to accept\n    * a new socket connection.\n-   * \n+   *\n    * @exception CancelledKeyException If this key has been cancelled\n    */\n-  public final boolean isAcceptable ()\n-  { \n-    return (readyOps () & OP_ACCEPT) != 0;\n+  public final boolean isAcceptable()\n+  {\n+    return (readyOps() & OP_ACCEPT) != 0;\n   }\n \n   /**\n    * Tests whether this key's channel has either finished,\n    * or failed to finish, its socket-connection operation.\n-   * \n+   *\n    * @exception CancelledKeyException If this key has been cancelled\n    */\n-  public final boolean isConnectable ()\n+  public final boolean isConnectable()\n   {\n-    return (readyOps () & OP_CONNECT) != 0;  \n-  }        \n-  \n+    return (readyOps() & OP_CONNECT) != 0;\n+  }\n+\n   /**\n    * Tests if the channel attached to the key is readable.\n-   * \n+   *\n    * @exception CancelledKeyException If this key has been cancelled\n    */\n-  public final boolean isReadable ()\n+  public final boolean isReadable()\n   {\n-    return (readyOps () & OP_READ) != 0; \n+    return (readyOps() & OP_READ) != 0;\n   }\n-  \n+\n   /**\n    * Tests if the channel attached to the key is writable.\n    *\n    * @exception CancelledKeyException If this key has been cancelled\n    */\n-  public final boolean isWritable ()\n+  public final boolean isWritable()\n   {\n-    return (readyOps () & OP_WRITE) != 0;\n+    return (readyOps() & OP_WRITE) != 0;\n   }\n \n   /**\n    * Requests that the registration of this key's channel with\n    * its selector be cancelled.\n    */\n-  public abstract void cancel (); \n- \n+  public abstract void cancel();\n+\n   /**\n    * return the channel attached to the key.\n    */\n-  public abstract SelectableChannel channel ();\n-  \n+  public abstract SelectableChannel channel();\n+\n   /**\n    * Returns the key's interest set.\n-   * \n+   *\n    * @exception CancelledKeyException If this key has been cancelled\n    */\n-  public abstract int interestOps ();\n-  \n+  public abstract int interestOps();\n+\n   /**\n    * Sets this key's interest set to the given value.\n-   * \n+   *\n    * @exception CancelledKeyException If this key has been cancelled\n    * @exception IllegalArgumentException If a bit in the set does not\n    * correspond to an operation that is supported by this key's channel,\n    * that is, if set &amp; ~(channel().validOps()) != 0\n    */\n-  public abstract SelectionKey interestOps (int ops);\n- \n+  public abstract SelectionKey interestOps(int ops);\n+\n   /**\n    * Tells whether or not this key is valid.\n    */\n-  public abstract boolean isValid ();\n- \n+  public abstract boolean isValid();\n+\n   /**\n    * Retrieves this key's ready-operation set.\n-   * \n+   *\n    * @exception CancelledKeyException If this key has been cancelled\n    */\n-  public abstract int readyOps ();\n-  \n+  public abstract int readyOps();\n+\n   /**\n    * Returns the selector for which this key was created.\n    */\n-  public abstract Selector selector ();\n+  public abstract Selector selector();\n }"}, {"sha": "0eee121e27d5efd4aa2b21e67c849e119176b09c", "filename": "libjava/java/nio/channels/Selector.java", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FSelector.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FSelector.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2FSelector.java?ref=92e1fe674851eff331db253bcb79199716a341f6", "patch": "@@ -1,4 +1,4 @@\n-/* Selector.java -- \n+/* Selector.java --\n    Copyright (C) 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -41,6 +41,7 @@\n import java.nio.channels.spi.SelectorProvider;\n import java.util.Set;\n \n+\n /**\n  * @author Michael Koch\n  * @since 1.4\n@@ -53,81 +54,81 @@\n   protected Selector()\n   {\n   }\n- \n+\n   /**\n    * Opens a selector.\n-   * \n+   *\n    * @exception IOException If an error occurs\n    */\n-  public static Selector open () throws IOException\n+  public static Selector open() throws IOException\n   {\n-    return SelectorProvider.provider ().openSelector ();\n+    return SelectorProvider.provider().openSelector();\n   }\n \n   /**\n    * Closes the selector.\n-   * \n+   *\n    * @exception IOException If an error occurs\n    */\n-  public abstract void close () throws IOException;\n-  \n+  public abstract void close() throws IOException;\n+\n   /**\n    * Tells whether the selector is open or not.\n    */\n-  public abstract boolean isOpen ();\n-  \n+  public abstract boolean isOpen();\n+\n   /**\n    * Returns this selector's key set.\n-   * \n+   *\n    * @exception ClosedSelectorException If this selector is closed.\n    */\n-  public abstract Set keys ();\n- \n+  public abstract Set keys();\n+\n   /**\n    * Returns the SelectorProvider that created the selector.\n    */\n-  public abstract SelectorProvider provider ();\n-  \n+  public abstract SelectorProvider provider();\n+\n   /**\n    * Selects a set of keys whose corresponding channels are ready\n    * for I/O operations.\n-   * \n+   *\n    * @exception ClosedSelectorException If this selector is closed.\n    * @exception IOException If an error occurs\n    */\n-  public abstract int select () throws IOException;\n-  \n+  public abstract int select() throws IOException;\n+\n   /**\n    * Selects a set of keys whose corresponding channels are ready\n    * for I/O operations.\n    *\n    * @param timeout The timeout to use.\n-   * \n+   *\n    * @exception ClosedSelectorException If this selector is closed.\n    * @exception IllegalArgumentException If the timeout value is negative.\n    * @exception IOException If an error occurs\n    */\n-  public abstract int select (long timeout) throws IOException;\n-  \n+  public abstract int select(long timeout) throws IOException;\n+\n   /**\n    * Returns this selector's selected-key set.\n-   * \n+   *\n    * @exception ClosedSelectorException If this selector is closed.\n    */\n-  public abstract Set selectedKeys ();\n-  \n+  public abstract Set selectedKeys();\n+\n   /**\n    * Selects a set of keys whose corresponding channels are ready\n    * for I/O operations.\n-   * \n+   *\n    * @exception ClosedSelectorException If this selector is closed.\n    * @exception IOException If an error occurs\n    */\n-  public abstract int selectNow () throws IOException;\n-  \n+  public abstract int selectNow() throws IOException;\n+\n   /**\n    * Causes the first selection operation that has not yet returned to\n    * return immediately.\n    */\n-  public abstract Selector wakeup ();\n+  public abstract Selector wakeup();\n }"}, {"sha": "4b9db4f631666bcec297a2103f86f352fc05d3d7", "filename": "libjava/java/nio/channels/ServerSocketChannel.java", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FServerSocketChannel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FServerSocketChannel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2FServerSocketChannel.java?ref=92e1fe674851eff331db253bcb79199716a341f6", "patch": "@@ -1,4 +1,4 @@\n-/* ServerSocketChannel.java -- \n+/* ServerSocketChannel.java --\n    Copyright (C) 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -35,29 +35,28 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package java.nio.channels;\n \n-import java.nio.channels.spi.AbstractSelectableChannel;\n-import java.nio.channels.spi.SelectorProvider;\n import java.io.IOException;\n import java.net.ServerSocket;\n+import java.nio.channels.spi.AbstractSelectableChannel;\n+import java.nio.channels.spi.SelectorProvider;\n+\n \n /**\n  * @author Michael Koch\n  * @since 1.4\n  */\n-public abstract class ServerSocketChannel\n-  extends AbstractSelectableChannel\n+public abstract class ServerSocketChannel extends AbstractSelectableChannel\n {\n   /**\n    * Initializes this channel.\n    */\n-  protected ServerSocketChannel (SelectorProvider provider)\n+  protected ServerSocketChannel(SelectorProvider provider)\n   {\n-    super (provider);\n+    super(provider);\n   }\n-  \n+\n   /**\n    * Accepts a connection made to this channel's socket.\n    *\n@@ -72,28 +71,28 @@ protected ServerSocketChannel (SelectorProvider provider)\n    * @exception SecurityException If a security manager has been installed and\n    * it does not permit access to the remote endpoint of the new connection.\n    */\n-  public abstract SocketChannel accept () throws IOException;\n-  \n+  public abstract SocketChannel accept() throws IOException;\n+\n   /**\n    * Retrieves the channels socket.\n    */\n-  public abstract ServerSocket socket ();\n-    \n+  public abstract ServerSocket socket();\n+\n   /**\n    * Opens a server socket channel.\n    *\n    * @exception IOException If an error occurs\n    */\n-  public static ServerSocketChannel open () throws IOException\n+  public static ServerSocketChannel open() throws IOException\n   {\n-    return SelectorProvider.provider ().openServerSocketChannel ();\n+    return SelectorProvider.provider().openServerSocketChannel();\n   }\n \n   /**\n    * Retrieves the valid operations for this channel.\n    */\n-  public final int validOps ()\n+  public final int validOps()\n   {\n     return SelectionKey.OP_ACCEPT;\n-  } \n+  }\n }"}, {"sha": "933f866c9a5b789755407667d0f0a9cdc8bcc4f2", "filename": "libjava/java/nio/channels/SocketChannel.java", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FSocketChannel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FSocketChannel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2FSocketChannel.java?ref=92e1fe674851eff331db253bcb79199716a341f6", "patch": "@@ -1,4 +1,4 @@\n-/* SocketChannel.java -- \n+/* SocketChannel.java --\n    Copyright (C) 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -37,38 +37,39 @@\n \n package java.nio.channels;\n \n-import java.nio.channels.spi.AbstractSelectableChannel;\n-import java.nio.channels.spi.SelectorProvider;\n-import java.nio.ByteBuffer;\n import java.io.IOException;\n import java.net.Socket;\n import java.net.SocketAddress;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.spi.AbstractSelectableChannel;\n+import java.nio.channels.spi.SelectorProvider;\n+\n \n /**\n  * @author Michael Koch\n  * @since 1.4\n  */\n-abstract public class SocketChannel extends AbstractSelectableChannel\n+public abstract class SocketChannel extends AbstractSelectableChannel\n   implements ByteChannel, ScatteringByteChannel, GatheringByteChannel\n {\n   /**\n    * Initializes this socket.\n    */\n-  protected SocketChannel (SelectorProvider provider)\n+  protected SocketChannel(SelectorProvider provider)\n   {\n-    super (provider);\n+    super(provider);\n   }\n- \n+\n   /**\n    * Opens a socket channel.\n    *\n    * @exception IOException If an error occurs\n    */\n-  public static SocketChannel open () throws IOException\n+  public static SocketChannel open() throws IOException\n   {\n-    return SelectorProvider.provider ().openSocketChannel ();\n+    return SelectorProvider.provider().openSocketChannel();\n   }\n-  \n+\n   /**\n    * Opens a channel and connects it to a remote address.\n    *\n@@ -84,55 +85,53 @@ public static SocketChannel open () throws IOException\n    * @exception UnsupportedAddressTypeException If the type of the given remote\n    * address is not supported.\n    */\n-  public static SocketChannel open (SocketAddress remote) throws IOException\n+  public static SocketChannel open(SocketAddress remote)\n+    throws IOException\n   {\n-    SocketChannel ch = open ();\n+    SocketChannel ch = open();\n     ch.connect(remote);\n     return ch;\n   }\n-    \n+\n   /**\n    * Reads data from the channel.\n    *\n    * @exception IOException If an error occurs\n    * @exception NotYetConnectedException If this channel is not yet connected.\n    */\n-  public final long read (ByteBuffer[] dsts) throws IOException\n+  public final long read(ByteBuffer[] dsts) throws IOException\n   {\n     long b = 0;\n-    \n+\n     for (int i = 0; i < dsts.length; i++)\n-      {\n-        b += read (dsts [i]);\n-      }\n-    \n+      b += read(dsts[i]);\n+\n     return b;\n   }\n-    \n+\n   /**\n    * Writes data to the channel.\n    *\n    * @exception IOException If an error occurs\n    * @exception NotYetConnectedException If this channel is not yet connected.\n    */\n-  public final long write (ByteBuffer[] dsts) throws IOException\n+  public final long write(ByteBuffer[] dsts) throws IOException\n   {\n     long b = 0;\n \n-    for (int  i= 0; i < dsts.length; i++)\n-      {\n-        b += write (dsts [i]);\n-      }\n-    \n+    for (int i = 0; i < dsts.length; i++)\n+      b += write(dsts[i]);\n+\n     return b;\n-  }    \n-   \n+  }\n+\n   /**\n    * Retrieves the valid operations for this channel.\n    */\n-  public final int validOps ()\n+  public final int validOps()\n   {\n-    return SelectionKey.OP_CONNECT | SelectionKey.OP_READ | SelectionKey.OP_WRITE;\n+    return SelectionKey.OP_CONNECT | SelectionKey.OP_READ\n+           | SelectionKey.OP_WRITE;\n   }\n \n   /**\n@@ -141,7 +140,7 @@ public final int validOps ()\n    * @exception IOException If an error occurs\n    * @exception NotYetConnectedException If this channel is not yet connected.\n    */\n-  public abstract int read (ByteBuffer dst) throws IOException;\n+  public abstract int read(ByteBuffer dst) throws IOException;\n \n   /**\n    * Connects the channel's socket to the remote address.\n@@ -162,8 +161,9 @@ public final int validOps ()\n    * @exception UnsupportedAddressTypeException If the type of the given remote\n    * address is not supported.\n    */\n-  public abstract boolean connect (SocketAddress remote) throws IOException;\n-  \n+  public abstract boolean connect(SocketAddress remote)\n+    throws IOException;\n+\n   /**\n    * Finishes the process of connecting a socket channel.\n    *\n@@ -176,46 +176,46 @@ public final int validOps ()\n    * @exception NoConnectionPendingException If this channel is not connected\n    * and a connection operation has not been initiated.\n    */\n-  public abstract boolean finishConnect () throws IOException;\n- \n+  public abstract boolean finishConnect() throws IOException;\n+\n   /**\n    * Tells whether or not the channel's socket is connected.\n    */\n-  public abstract boolean isConnected ();\n-  \n+  public abstract boolean isConnected();\n+\n   /**\n    * Tells whether or not a connection operation is in progress on this channel.\n    */\n-  public abstract boolean isConnectionPending ();\n-  \n+  public abstract boolean isConnectionPending();\n+\n   /**\n    * Reads data from the channel.\n    *\n    * @exception IOException If an error occurs\n    * @exception NotYetConnectedException If this channel is not yet connected.\n    */\n-  public abstract long read (ByteBuffer[] dsts, int offset, int length)\n+  public abstract long read(ByteBuffer[] dsts, int offset, int length)\n     throws IOException;\n- \n+\n   /**\n    * Retrieves the channel's socket.\n    */\n-  public abstract Socket socket ();\n-  \n+  public abstract Socket socket();\n+\n   /**\n    * Writes data to the channel.\n    *\n    * @exception IOException If an error occurs\n    * @exception NotYetConnectedException If this channel is not yet connected.\n    */\n-  public abstract int write (ByteBuffer src) throws IOException;\n-  \n+  public abstract int write(ByteBuffer src) throws IOException;\n+\n   /**\n    * Writes data to the channel.\n    *\n    * @exception IOException If an error occurs\n    * @exception NotYetConnectedException If this channel is not yet connected.\n    */\n-  public abstract long write (ByteBuffer[] srcs, int offset, int length)\n+  public abstract long write(ByteBuffer[] srcs, int offset, int length)\n     throws IOException;\n }"}, {"sha": "f8e74a9d2f2a368d4a7fe8c1aceccf841187178c", "filename": "libjava/java/nio/channels/UnresolvedAddressException.java", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FUnresolvedAddressException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FUnresolvedAddressException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2FUnresolvedAddressException.java?ref=92e1fe674851eff331db253bcb79199716a341f6", "patch": "@@ -1,4 +1,4 @@\n-/* UnresolvedAddressException.java -- \n+/* UnresolvedAddressException.java --\n    Copyright (C) 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -37,6 +37,7 @@\n \n package java.nio.channels;\n \n+\n /**\n  * @author Michael Koch\n  * @since 1.4"}, {"sha": "adea4ed7060f78f5ff0e0a2e7d74b6ac7c1bcc85", "filename": "libjava/java/nio/channels/UnsupportedAddressTypeException.java", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FUnsupportedAddressTypeException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FUnsupportedAddressTypeException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2FUnsupportedAddressTypeException.java?ref=92e1fe674851eff331db253bcb79199716a341f6", "patch": "@@ -1,4 +1,4 @@\n-/* UnsupportedAddressTypeException.java -- \n+/* UnsupportedAddressTypeException.java --\n    Copyright (C) 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -37,6 +37,7 @@\n \n package java.nio.channels;\n \n+\n /**\n  * @author Michael Koch\n  * @since 1.4"}, {"sha": "0cc6858a402b90bf214476056f0778df98d054f8", "filename": "libjava/java/nio/channels/WritableByteChannel.java", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FWritableByteChannel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2FWritableByteChannel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2FWritableByteChannel.java?ref=92e1fe674851eff331db253bcb79199716a341f6", "patch": "@@ -1,4 +1,4 @@\n-/* WritableByteChannel.java -- \n+/* WritableByteChannel.java --\n    Copyright (C) 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -40,8 +40,8 @@\n import java.io.IOException;\n import java.nio.ByteBuffer;\n \n-public interface WritableByteChannel\n-  extends Channel\n+\n+public interface WritableByteChannel extends Channel\n {\n   /**\n    * Writes a sequence of bytes to this channel from the given buffer\n@@ -56,5 +56,5 @@\n    * @exception NonWritableChannelException If this channel was not opened for\n    * writing\n    */\n-  int write (ByteBuffer src) throws IOException;\n+  int write(ByteBuffer src) throws IOException;\n }"}, {"sha": "98eaf482a2e9167c274004b695f2519ded51f073", "filename": "libjava/java/nio/channels/spi/AbstractInterruptibleChannel.java", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2Fspi%2FAbstractInterruptibleChannel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2Fspi%2FAbstractInterruptibleChannel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2Fspi%2FAbstractInterruptibleChannel.java?ref=92e1fe674851eff331db253bcb79199716a341f6", "patch": "@@ -1,5 +1,5 @@\n /* AbstractInterruptibleChannel.java -- \n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -42,6 +42,7 @@\n import java.nio.channels.Channel;\n import java.nio.channels.InterruptibleChannel;\n \n+\n /**\n  * @author Michael Koch\n  * @since 1.4\n@@ -54,25 +55,25 @@\n   /**\n    * Initializes the channel.\n    */\n-  protected AbstractInterruptibleChannel ()\n+  protected AbstractInterruptibleChannel()\n   {\n   }\n \n   /**\n    * Marks the beginning of an I/O operation that might block indefinitely.\n    */\n-  protected final void begin ()\n+  protected final void begin()\n   {\n   }\n-    \n+\n   /**\n    * Closes the channel.\n-   * \n+   *\n    * @exception IOException If an error occurs\n    */\n-  public final void close () throws IOException\n+  public final void close() throws IOException\n   {\n-    if (!closed)\n+    if (! closed)\n       {\n \tclosed = true;\n \timplCloseChannel();\n@@ -81,29 +82,38 @@ public final void close () throws IOException\n \n   /**\n    * Marks the end of an I/O operation that might block indefinitely.\n-   * \n+   *\n+   * @param completed true if the task completed successfully,\n+   * false otherwise\n+   *\n+   * @exception IOException if an error occurs\n    * @exception AsynchronousCloseException If the channel was asynchronously\n    * closed.\n    * @exception ClosedByInterruptException If the thread blocked in the\n    * I/O operation was interrupted.\n    */\n-  protected final void end (boolean completed)\n+  protected final void end(boolean completed)\n     throws AsynchronousCloseException\n   {\n-  }   \n+    // FIXME: check more here.\n+    \n+    if (closed) throw new AsynchronousCloseException();\n+  }\n \n   /**\n    * Closes the channel.\n-   * \n+   *\n    * @exception IOException If an error occurs\n    */\n-  protected abstract void implCloseChannel () throws IOException;\n+  protected abstract void implCloseChannel() throws IOException;\n \n   /**\n    * Tells whether or not this channel is open.\n+   * \n+   * @return true if the channel is open, false otherwise \n    */\n-  public final boolean isOpen ()\n+  public final boolean isOpen()\n   {\n-    return !closed;\n+    return ! closed;\n   }\n }"}, {"sha": "ccc48c93c955069b34617fad056e73df8f23c8af", "filename": "libjava/java/nio/channels/spi/AbstractSelectableChannel.java", "status": "modified", "additions": 81, "deletions": 45, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2Fspi%2FAbstractSelectableChannel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2Fspi%2FAbstractSelectableChannel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2Fspi%2FAbstractSelectableChannel.java?ref=92e1fe674851eff331db253bcb79199716a341f6", "patch": "@@ -43,9 +43,9 @@\n import java.nio.channels.SelectionKey;\n import java.nio.channels.Selector;\n import java.util.LinkedList;\n-import java.util.List;\n import java.util.ListIterator;\n \n+\n public abstract class AbstractSelectableChannel extends SelectableChannel\n {\n   private boolean blocking = true;\n@@ -55,36 +55,46 @@ public abstract class AbstractSelectableChannel extends SelectableChannel\n \n   /**\n    * Initializes the channel\n+   *\n+   * @param provider the provider that created this channel\n    */\n-  protected AbstractSelectableChannel (SelectorProvider provider)\n+  protected AbstractSelectableChannel(SelectorProvider provider)\n   {\n     this.provider = provider;\n   }\n \n   /**\n    * Retrieves the object upon which the configureBlocking and register\n    * methods synchronize.\n+   *\n+   * @return the blocking lock\n    */\n-  public final Object blockingLock ()\n+  public final Object blockingLock()\n   {\n     return LOCK;\n   }\n-    \n+\n   /**\n    * Adjusts this channel's blocking mode.\n+   *\n+   * @param blocking true if blocking should be enabled, false otherwise\n+   *\n+   * @return this channel\n+   *\n+   * @exception IOException If an error occurs\n    */\n-  public final SelectableChannel configureBlocking (boolean blocking)\n+  public final SelectableChannel configureBlocking(boolean blocking)\n     throws IOException\n   {\n     synchronized (blockingLock())\n       {\n-        if (this.blocking != blocking)\n-          {\n-            implConfigureBlocking(blocking);\n-            this.blocking = blocking;\n-          }\n+\tif (this.blocking != blocking)\n+\t  {\n+\t    implConfigureBlocking(blocking);\n+\t    this.blocking = blocking;\n+\t  }\n       }\n-    \n+\n     return this;\n   }\n \n@@ -93,25 +103,34 @@ public final SelectableChannel configureBlocking (boolean blocking)\n    *\n    * @exception IOException If an error occurs\n    */\n-  protected final void implCloseChannel () throws IOException\n+  protected final void implCloseChannel() throws IOException\n   {\n-    implCloseSelectableChannel ();\n+    implCloseSelectableChannel();\n   }\n \n   /**\n    * Closes this selectable channel.\n+   *\n+   * @exception IOException If an error occurs\n    */\n-  protected abstract void implCloseSelectableChannel () throws IOException;\n-  \n+  protected abstract void implCloseSelectableChannel()\n+    throws IOException;\n+\n   /**\n    * Adjusts this channel's blocking mode.\n+   *\n+   * @param blocking true if blocking should be enabled, false otherwise\n+   *\n+   * @exception IOException If an error occurs\n    */\n-  protected abstract void implConfigureBlocking (boolean block)\n+  protected abstract void implConfigureBlocking(boolean blocking)\n     throws IOException;\n \n   /**\n    * Tells whether or not every I/O operation on this channel will block\n    * until it completes.\n+   *\n+   * @return true of this channel is blocking, false otherwise\n    */\n   public final boolean isBlocking()\n   {\n@@ -121,87 +140,104 @@ public final boolean isBlocking()\n   /**\n    * Tells whether or not this channel is currently registered with\n    * any selectors.\n+   *\n+   * @return true if this channel is registered, false otherwise\n    */\n   public final boolean isRegistered()\n   {\n-    return !keys.isEmpty();\n+    return ! keys.isEmpty();\n   }\n \n   /**\n    * Retrieves the key representing the channel's registration with the\n    * given selector.\n+   *\n+   * @param selector the selector to get a selection key for\n+   *\n+   * @return the selection key this channel is registered with\n    */\n   public final SelectionKey keyFor(Selector selector)\n   {\n     if (! isOpen())\n       return null;\n-    \n+\n     try\n       {\n-        synchronized(blockingLock())\n+\tsynchronized (blockingLock())\n \t  {\n-\t    return locate (selector);\n+\t    return locate(selector);\n \t  }\n       }\n     catch (Exception e)\n       {\n-        return null;\n+\treturn null;\n       }\n   }\n \n   /**\n    * Returns the provider that created this channel.\n+   *\n+   * @return the selector provider that created this channel\n    */\n-  public final SelectorProvider provider ()\n+  public final SelectorProvider provider()\n   {\n     return provider;\n   }\n \n-  private SelectionKey locate (Selector selector)\n+  private SelectionKey locate(Selector selector)\n   {\n-    ListIterator it = keys.listIterator ();\n-    \n-    while (it.hasNext ())\n+    ListIterator it = keys.listIterator();\n+\n+    while (it.hasNext())\n       {\n-        SelectionKey key = (SelectionKey) it.next();\n-        \n-    \tif (key.selector() == selector)\n-          return key;\n+\tSelectionKey key = (SelectionKey) it.next();\n+\n+\tif (key.selector() == selector)\n+\t  return key;\n       }\n-    \n+\n     return null;\n   }\n \n   /**\n    * Registers this channel with the given selector, returning a selection key.\n    *\n+   * @param selin the seletor to use\n+   * @param ops the interested operations\n+   * @param att an attachment for the returned selection key\n+   *\n+   * @return the registered selection key\n+   * \n    * @exception ClosedChannelException If the channel is already closed.\n    */\n-  public final SelectionKey register (Selector selin, int ops, Object att)\n+  public final SelectionKey register(Selector selin, int ops, Object att)\n     throws ClosedChannelException\n   {\n-    if (!isOpen ())\n+    if (! isOpen())\n       throw new ClosedChannelException();\n \n+    if ((ops & ~validOps()) != 0)\n+      throw new IllegalArgumentException();\n+    \n     SelectionKey key = null;\n     AbstractSelector selector = (AbstractSelector) selin;\n \n     synchronized (blockingLock())\n       {\n-        key = locate (selector);\n+\tkey = locate(selector);\n \n-        if (key != null)\n-          {\n+\tif (key != null)\n+\t  {\n \t    if (att != null)\n-\t      key.attach (att);\n-          }\n-        else\n-          {\n-            key = selector.register (this, ops, att);\n-    \t\t\n-            if (key != null)\n-              addSelectionKey (key);\n-          }\n+\t      key.attach(att);\n+\t  }\n+\telse\n+\t  {\n+\t    key = selector.register(this, ops, att);\n+\n+\t    if (key != null)\n+\t      addSelectionKey(key);\n+\t  }\n       }\n \n     return key;"}, {"sha": "83d6421bcad68d1421a6cb41327364fb982222f0", "filename": "libjava/java/nio/channels/spi/AbstractSelectionKey.java", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2Fspi%2FAbstractSelectionKey.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2Fspi%2FAbstractSelectionKey.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2Fspi%2FAbstractSelectionKey.java?ref=92e1fe674851eff331db253bcb79199716a341f6", "patch": "@@ -1,4 +1,4 @@\n-/* AbstractSelectionKey.java -- \n+/* AbstractSelectionKey.java --\n    Copyright (C) 2002, 2003, 2004  Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -39,38 +39,40 @@\n \n import java.nio.channels.SelectionKey;\n \n+\n /**\n  * @since 1.4\n  */\n-public abstract class AbstractSelectionKey\n-  extends SelectionKey\n+public abstract class AbstractSelectionKey extends SelectionKey\n {\n-  private boolean cancelled = false;\n+  private boolean cancelled;\n \n   /**\n    * Initializes the key.\n    */\n-  protected AbstractSelectionKey ()\n+  protected AbstractSelectionKey()\n   {\n   }\n \n   /**\n    * Cancels this key.\n    */\n-  public final void cancel ()\n+  public final void cancel()\n   {\n     if (isValid())\n       {\n \t((AbstractSelector) selector()).cancelKey(this);\n-        cancelled = true;\n+\tcancelled = true;\n       }\n   }\n \n   /**\n    * Tells whether this key is valid or not.\n+   *\n+   * @return true if this key is valid, false otherwise\n    */\n-  public final boolean isValid ()\n+  public final boolean isValid()\n   {\n-    return !cancelled;\n+    return ! cancelled;\n   }\n }"}, {"sha": "b1e206139d0b35f1b2a20dc715c4ce666aaca05e", "filename": "libjava/java/nio/channels/spi/AbstractSelector.java", "status": "modified", "additions": 43, "deletions": 18, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2Fspi%2FAbstractSelector.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2Fspi%2FAbstractSelector.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2Fspi%2FAbstractSelector.java?ref=92e1fe674851eff331db253bcb79199716a341f6", "patch": "@@ -1,4 +1,4 @@\n-/* AbstractSelector.java -- \n+/* AbstractSelector.java --\n    Copyright (C) 2002, 2003, 2004  Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -35,49 +35,53 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package java.nio.channels.spi;\n \n import java.io.IOException;\n import java.nio.channels.ClosedSelectorException;\n import java.nio.channels.SelectionKey;\n import java.nio.channels.Selector;\n-import java.util.Set;\n import java.util.HashSet;\n+import java.util.Set;\n+\n \n public abstract class AbstractSelector extends Selector\n {\n-  private boolean closed = false;\n+  private boolean closed;\n   private SelectorProvider provider;\n   private HashSet cancelledKeys;\n \n   /**\n    * Initializes the slector.\n+   *\n+   * @param provider the provider that created this selector\n    */\n-  protected AbstractSelector (SelectorProvider provider)\n+  protected AbstractSelector(SelectorProvider provider)\n   {\n     this.provider = provider;\n     this.cancelledKeys = new HashSet();\n   }\n- \n+\n   /**\n    * Closes the channel.\n-   * \n+   *\n    * @exception IOException If an error occurs\n    */\n-  public final synchronized void close () throws IOException\n+  public final synchronized void close() throws IOException\n   {\n     if (closed)\n       return;\n-    \n+\n     implCloseSelector();\n     closed = true;\n   }\n \n   /**\n    * Tells whether this channel is open or not.\n+   *\n+   * @return true if channel is open, false otherwise.\n    */\n-  public final boolean isOpen ()\n+  public final boolean isOpen()\n   {\n     return ! closed;\n   }\n@@ -95,21 +99,25 @@ protected final void begin()\n   protected final void end()\n   {\n   }\n-    \n+\n   /**\n    * Returns the provider for this selector object.\n+   *\n+   * @return the SelectorProvider object that created this seletor\n    */\n-  public final SelectorProvider provider ()\n+  public final SelectorProvider provider()\n   {\n     return provider;\n   }\n \n   /**\n    * Returns the cancelled keys set.\n+   *\n+   * @return the cancelled keys set\n    */\n   protected final Set cancelledKeys()\n   {\n-    if (!isOpen())\n+    if (! isOpen())\n       throw new ClosedSelectorException();\n \n     return cancelledKeys;\n@@ -118,8 +126,9 @@ protected final Set cancelledKeys()\n   /**\n    * Cancels a selection key.\n    */\n+\n   // This method is only called by AbstractSelectionKey.cancel().\n-  final void cancelKey (AbstractSelectionKey key)\n+  final void cancelKey(AbstractSelectionKey key)\n   {\n     synchronized (cancelledKeys)\n       {\n@@ -129,13 +138,29 @@ final void cancelKey (AbstractSelectionKey key)\n \n   /**\n    * Closes the channel.\n+   *\n+   * @exception IOException if an error occurs\n    */\n-  protected abstract void implCloseSelector () throws IOException;\n+  protected abstract void implCloseSelector() throws IOException;\n \n-  protected abstract SelectionKey register (AbstractSelectableChannel ch,\n-                                            int ops, Object att);   \n+  /**\n+   * Registers a channel for the selection process.\n+   *\n+   * @param ch the channel register\n+   * @param ops the interested operations\n+   * @param att an attachement to the selection key\n+   *\n+   * @return the registered selection key\n+   */\n+  protected abstract SelectionKey register(AbstractSelectableChannel ch,\n+                                           int ops, Object att);\n \n-  protected final void deregister (AbstractSelectionKey key)\n+  /**\n+   * Deregisters the given selection key.\n+   *\n+   * @param key the key to deregister\n+   */\n+  protected final void deregister(AbstractSelectionKey key)\n   {\n     ((AbstractSelectableChannel) key.channel()).removeSelectionKey(key);\n   }"}, {"sha": "ac6e124704dd234af607c221c8f760f0f090d549", "filename": "libjava/java/nio/channels/spi/SelectorProvider.java", "status": "modified", "additions": 61, "deletions": 37, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2Fspi%2FSelectorProvider.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fchannels%2Fspi%2FSelectorProvider.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2Fspi%2FSelectorProvider.java?ref=92e1fe674851eff331db253bcb79199716a341f6", "patch": "@@ -44,83 +44,107 @@\n import java.nio.channels.ServerSocketChannel;\n import java.nio.channels.SocketChannel;\n \n+\n /**\n  * @author Michael Koch\n  * @since 1.4\n  */\n public abstract class SelectorProvider\n {\n   private static SelectorProvider systemDefaultProvider;\n-    \n+\n   /**\n    * Initializes the selector provider.\n    *\n    * @exception SecurityException If a security manager has been installed and\n    * it denies @see RuntimePermission (\"selectorProvider\").\n    */\n-  protected SelectorProvider ()\n+  protected SelectorProvider()\n   {\n-    SecurityManager sm = System.getSecurityManager ();\n+    SecurityManager sm = System.getSecurityManager();\n     if (sm != null)\n-      sm.checkPermission (new RuntimePermission (\"selectorProvider\"));\n+      sm.checkPermission(new RuntimePermission(\"selectorProvider\"));\n   }\n-  \n+\n   /**\n    * Opens a datagram channel.\n+   *\n+   * @return a new datagram channel object\n+   * \n+   * @exception IOException if an error occurs\n    */\n-  public abstract DatagramChannel openDatagramChannel () throws IOException;\n-  \n+  public abstract DatagramChannel openDatagramChannel()\n+    throws IOException;\n+\n   /**\n    * Opens a pipe.\n+   *\n+   * @return a new pipe object\n+   * \n+   * @exception IOException if an error occurs\n    */\n-  public abstract Pipe openPipe () throws IOException;\n-  \n+  public abstract Pipe openPipe() throws IOException;\n+\n   /**\n    * Opens a selector.\n+   *\n+   * @return a new selector object\n+   * \n+   * @exception IOException if an error occurs\n    */\n-  public abstract AbstractSelector openSelector () throws IOException;\n-  \n+  public abstract AbstractSelector openSelector() throws IOException;\n+\n   /**\n    * Opens a server socket channel.\n+   *\n+   * @return a new server socket channel object\n+   * \n+   * @exception IOException if an error occurs\n    */\n-  public abstract ServerSocketChannel openServerSocketChannel ()\n+  public abstract ServerSocketChannel openServerSocketChannel()\n     throws IOException;\n-  \n+\n   /**\n    * Opens a socket channel.\n+   *\n+   * @return a new socket channel object\n+   * \n+   * @exception IOException if an error occurs\n    */\n-  public abstract SocketChannel openSocketChannel () throws IOException;\n-    \n+  public abstract SocketChannel openSocketChannel() throws IOException;\n+\n   /**\n    * Returns the system-wide default selector provider for this invocation\n    * of the Java virtual machine.\n+   *\n+   * @return the default seletor provider\n    */\n-  public static synchronized SelectorProvider provider ()\n+  public static synchronized SelectorProvider provider()\n   {\n     if (systemDefaultProvider == null)\n       {\n-        String propertyValue =\n-          System.getProperty (\"java.nio.channels.spi.SelectorProvider\");\n-\n-        if (propertyValue == null\n-            || propertyValue.equals (\"\"))\n-          systemDefaultProvider = new SelectorProviderImpl();\n-        else\n-          {\n-            try\n-              {\n-                systemDefaultProvider = (SelectorProvider) Class.forName\n-                  (propertyValue).newInstance();\n-              }\n-            catch (Exception e)\n-              {\n-                System.err.println (\"Could not instantiate class: \"\n-                                    + propertyValue);\n-                systemDefaultProvider = new SelectorProviderImpl();\n-              }\n-          }\n+\tString propertyValue =\n+\t  System.getProperty(\"java.nio.channels.spi.SelectorProvider\");\n+\n+\tif (propertyValue == null || propertyValue.equals(\"\"))\n+\t  systemDefaultProvider = new SelectorProviderImpl();\n+\telse\n+\t  {\n+\t    try\n+\t      {\n+\t\tsystemDefaultProvider =\n+\t\t  (SelectorProvider) Class.forName(propertyValue)\n+\t\t                          .newInstance();\n+\t      }\n+\t    catch (Exception e)\n+\t      {\n+\t\tSystem.err.println(\"Could not instantiate class: \"\n+\t\t                   + propertyValue);\n+\t\tsystemDefaultProvider = new SelectorProviderImpl();\n+\t      }\n+\t  }\n       }\n-    \n+\n     return systemDefaultProvider;\n   }\n }"}, {"sha": "1af7a8ef314fdef1c80b2a1e7d5c38217d1883f2", "filename": "libjava/java/nio/charset/spi/CharsetProvider.java", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fcharset%2Fspi%2FCharsetProvider.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e1fe674851eff331db253bcb79199716a341f6/libjava%2Fjava%2Fnio%2Fcharset%2Fspi%2FCharsetProvider.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fcharset%2Fspi%2FCharsetProvider.java?ref=92e1fe674851eff331db253bcb79199716a341f6", "patch": "@@ -40,6 +40,7 @@\n import java.nio.charset.Charset;\n import java.util.Iterator;\n \n+\n /**\n  * This class allows an implementor to provide additional character sets. The\n  * subclass must have a nullary constructor, and be attached to charset\n@@ -82,6 +83,8 @@ protected CharsetProvider()\n   /**\n    * Returns the named charset, by canonical name or alias.\n    *\n+   * @param name the name of the character\n+   *\n    * @return the charset, or null if not supported\n    */\n   public abstract Charset charsetForName(String name);"}]}