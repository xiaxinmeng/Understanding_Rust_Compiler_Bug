{"sha": "3ac17160c8033931f3bb04f234968f9b56ea3c64", "node_id": "C_kwDOANBUbNoAKDNhYzE3MTYwYzgwMzM5MzFmM2JiMDRmMjM0OTY4ZjliNTZlYTNjNjQ", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-02-16T12:50:12Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-02-16T13:46:59Z"}, "message": "macromatch: Add location to abstract MacroMatch class", "tree": {"sha": "a2d9e051f38a9dfd6aad0cff2b41007e675d42d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a2d9e051f38a9dfd6aad0cff2b41007e675d42d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ac17160c8033931f3bb04f234968f9b56ea3c64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ac17160c8033931f3bb04f234968f9b56ea3c64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ac17160c8033931f3bb04f234968f9b56ea3c64", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ac17160c8033931f3bb04f234968f9b56ea3c64/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "330b265134afd12e06884205e7b77334393864b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/330b265134afd12e06884205e7b77334393864b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/330b265134afd12e06884205e7b77334393864b8"}], "stats": {"total": 67, "additions": 42, "deletions": 25}, "files": [{"sha": "ba973f11ed27b979aa7e75be8454f468b8470d78", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac17160c8033931f3bb04f234968f9b56ea3c64/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac17160c8033931f3bb04f234968f9b56ea3c64/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=3ac17160c8033931f3bb04f234968f9b56ea3c64", "patch": "@@ -111,6 +111,7 @@ class MacroMatch\n   virtual ~MacroMatch () {}\n \n   virtual std::string as_string () const = 0;\n+  virtual Location get_match_locus () const = 0;\n \n   // Unique pointer custom clone function\n   std::unique_ptr<MacroMatch> clone_macro_match () const\n@@ -217,6 +218,7 @@ class Token : public TokenTree, public MacroMatch\n   }\n \n   std::string as_string () const override;\n+  Location get_match_locus () const override { return tok_ref->get_locus (); };\n \n   void accept_vis (ASTVisitor &vis) override;\n "}, {"sha": "2d59b1852dbdac7200de2060906b678796cd5aaa", "filename": "gcc/rust/ast/rust-macro.h", "status": "modified", "additions": 32, "deletions": 19, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac17160c8033931f3bb04f234968f9b56ea3c64/gcc%2Frust%2Fast%2Frust-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac17160c8033931f3bb04f234968f9b56ea3c64/gcc%2Frust%2Fast%2Frust-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-macro.h?ref=3ac17160c8033931f3bb04f234968f9b56ea3c64", "patch": "@@ -87,24 +87,24 @@ class MacroMatchFragment : public MacroMatch\n {\n   Identifier ident;\n   MacroFragSpec frag_spec;\n-\n-  // TODO: should store location information?\n+  Location locus;\n \n public:\n-  MacroMatchFragment (Identifier ident, MacroFragSpec frag_spec)\n-    : ident (std::move (ident)), frag_spec (frag_spec)\n+  MacroMatchFragment (Identifier ident, MacroFragSpec frag_spec, Location locus)\n+    : ident (std::move (ident)), frag_spec (frag_spec), locus (locus)\n   {}\n \n   // Returns whether macro match fragment is in an error state.\n   bool is_error () const { return frag_spec == INVALID; }\n \n   // Creates an error state macro match fragment.\n-  static MacroMatchFragment create_error ()\n+  static MacroMatchFragment create_error (Location locus)\n   {\n-    return MacroMatchFragment (std::string (\"\"), INVALID);\n+    return MacroMatchFragment (std::string (\"\"), INVALID, locus);\n   }\n \n   std::string as_string () const override;\n+  Location get_match_locus () const override { return locus; };\n \n   void accept_vis (ASTVisitor &vis) override;\n \n@@ -137,20 +137,22 @@ class MacroMatchRepetition : public MacroMatch\n   typedef Token MacroRepSep;\n   // any token except delimiters and repetition operators\n   std::unique_ptr<MacroRepSep> sep;\n-\n-  // TODO: should store location information?\n+  Location locus;\n \n public:\n   // Returns whether macro match repetition has separator token.\n   bool has_sep () const { return sep != nullptr; }\n \n   MacroMatchRepetition (std::vector<std::unique_ptr<MacroMatch> > matches,\n-\t\t\tMacroRepOp op, std::unique_ptr<MacroRepSep> sep)\n-    : matches (std::move (matches)), op (op), sep (std::move (sep))\n+\t\t\tMacroRepOp op, std::unique_ptr<MacroRepSep> sep,\n+\t\t\tLocation locus)\n+    : matches (std::move (matches)), op (op), sep (std::move (sep)),\n+      locus (locus)\n   {}\n \n   // Copy constructor with clone\n-  MacroMatchRepetition (MacroMatchRepetition const &other) : op (other.op)\n+  MacroMatchRepetition (MacroMatchRepetition const &other)\n+    : op (other.op), locus (other.locus)\n   {\n     // guard to protect from null pointer dereference\n     if (other.sep != nullptr)\n@@ -165,6 +167,7 @@ class MacroMatchRepetition : public MacroMatch\n   MacroMatchRepetition &operator= (MacroMatchRepetition const &other)\n   {\n     op = other.op;\n+    locus = other.locus;\n \n     // guard to protect from null pointer dereference\n     if (other.sep != nullptr)\n@@ -184,6 +187,7 @@ class MacroMatchRepetition : public MacroMatch\n   MacroMatchRepetition &operator= (MacroMatchRepetition &&other) = default;\n \n   std::string as_string () const override;\n+  Location get_match_locus () const override { return locus; };\n \n   void accept_vis (ASTVisitor &vis) override;\n \n@@ -201,20 +205,22 @@ class MacroMatcher : public MacroMatch\n {\n   DelimType delim_type;\n   std::vector<std::unique_ptr<MacroMatch> > matches;\n+  Location locus;\n \n   // TODO: think of way to mark invalid that doesn't take up more space\n   bool is_invalid;\n \n-  // TODO: should store location information?\n-\n public:\n   MacroMatcher (DelimType delim_type,\n-\t\tstd::vector<std::unique_ptr<MacroMatch> > matches)\n-    : delim_type (delim_type), matches (std::move (matches)), is_invalid (false)\n+\t\tstd::vector<std::unique_ptr<MacroMatch> > matches,\n+\t\tLocation locus)\n+    : delim_type (delim_type), matches (std::move (matches)), locus (locus),\n+      is_invalid (false)\n   {}\n \n   // copy constructor with vector clone\n-  MacroMatcher (MacroMatcher const &other) : delim_type (other.delim_type)\n+  MacroMatcher (MacroMatcher const &other)\n+    : delim_type (other.delim_type), locus (other.locus)\n   {\n     matches.reserve (other.matches.size ());\n     for (const auto &e : other.matches)\n@@ -225,6 +231,7 @@ class MacroMatcher : public MacroMatch\n   MacroMatcher &operator= (MacroMatcher const &other)\n   {\n     delim_type = other.delim_type;\n+    locus = other.locus;\n \n     matches.reserve (other.matches.size ());\n     for (const auto &e : other.matches)\n@@ -238,10 +245,14 @@ class MacroMatcher : public MacroMatch\n   MacroMatcher &operator= (MacroMatcher &&other) = default;\n \n   // Creates an error state macro matcher.\n-  static MacroMatcher create_error () { return MacroMatcher (true); }\n+  static MacroMatcher create_error (Location locus)\n+  {\n+    return MacroMatcher (true, locus);\n+  }\n \n   // Returns whether MacroMatcher is in an error state.\n   bool is_error () const { return is_invalid; }\n+  Location get_match_locus () const override { return locus; }\n \n   std::string as_string () const override;\n \n@@ -256,7 +267,8 @@ class MacroMatcher : public MacroMatch\n   }\n \n   // constructor only used to create error matcher\n-  MacroMatcher (bool is_invalid) : delim_type (PARENS), is_invalid (is_invalid)\n+  MacroMatcher (bool is_invalid, Location locus)\n+    : delim_type (PARENS), locus (locus), is_invalid (is_invalid)\n   {}\n };\n \n@@ -296,7 +308,8 @@ struct MacroRule\n   // Creates an error state macro rule.\n   static MacroRule create_error ()\n   {\n-    return MacroRule (MacroMatcher::create_error (),\n+    // FIXME: Once #928 is merged, give location to MacroMatcher\n+    return MacroRule (MacroMatcher::create_error (Location ()),\n \t\t      MacroTranscriber (DelimTokenTree::create_empty ()));\n   }\n "}, {"sha": "b500c8717955749d839daa3aaf8af7ac2bab6183", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac17160c8033931f3bb04f234968f9b56ea3c64/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac17160c8033931f3bb04f234968f9b56ea3c64/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=3ac17160c8033931f3bb04f234968f9b56ea3c64", "patch": "@@ -1709,6 +1709,7 @@ Parser<ManagedTokenSource>::parse_macro_matcher ()\n \n   // Map tokens to DelimType\n   const_TokenPtr t = lexer.peek_token ();\n+  Location locus = t->get_locus ();\n   switch (t->get_id ())\n     {\n     case LEFT_PAREN:\n@@ -1726,7 +1727,7 @@ Parser<ManagedTokenSource>::parse_macro_matcher ()\n \t\"unexpected token %qs - expecting delimiters (for a macro matcher)\",\n \tt->get_token_description ()));\n \n-      return AST::MacroMatcher::create_error ();\n+      return AST::MacroMatcher::create_error (t->get_locus ());\n     }\n   lexer.skip_token ();\n \n@@ -1747,7 +1748,7 @@ Parser<ManagedTokenSource>::parse_macro_matcher ()\n \t    t->get_token_description ());\n \t  add_error (std::move (error));\n \n-\t  return AST::MacroMatcher::create_error ();\n+\t  return AST::MacroMatcher::create_error (t->get_locus ());\n \t}\n \n       matches.push_back (std::move (match));\n@@ -1765,7 +1766,7 @@ Parser<ManagedTokenSource>::parse_macro_matcher ()\n       // tokens match opening delimiter, so skip.\n       lexer.skip_token ();\n \n-      return AST::MacroMatcher (delim_type, std::move (matches));\n+      return AST::MacroMatcher (delim_type, std::move (matches), locus);\n     }\n   else\n     {\n@@ -1781,7 +1782,7 @@ Parser<ManagedTokenSource>::parse_macro_matcher ()\n \n       /* return error macro matcher despite possibly parsing mostly correct one?\n        * TODO is this the best idea? */\n-      return AST::MacroMatcher::create_error ();\n+      return AST::MacroMatcher::create_error (t->get_locus ());\n     }\n }\n \n@@ -1857,6 +1858,7 @@ template <typename ManagedTokenSource>\n std::unique_ptr<AST::MacroMatchFragment>\n Parser<ManagedTokenSource>::parse_macro_match_fragment ()\n {\n+  Location fragment_locus = lexer.peek_token ()->get_locus ();\n   skip_token (DOLLAR_SIGN);\n \n   const_TokenPtr ident_tok = expect_token (IDENTIFIER);\n@@ -1893,7 +1895,7 @@ Parser<ManagedTokenSource>::parse_macro_match_fragment ()\n     }\n \n   return std::unique_ptr<AST::MacroMatchFragment> (\n-    new AST::MacroMatchFragment (std::move (ident), frag));\n+    new AST::MacroMatchFragment (std::move (ident), frag, fragment_locus));\n }\n \n // Parses a repetition macro match.\n@@ -2002,7 +2004,7 @@ Parser<ManagedTokenSource>::parse_macro_match_repetition ()\n \n   return std::unique_ptr<AST::MacroMatchRepetition> (\n     new AST::MacroMatchRepetition (std::move (matches), op,\n-\t\t\t\t   std::move (separator)));\n+\t\t\t\t   std::move (separator), t->get_locus ()));\n }\n \n /* Parses a visibility syntactical production (i.e. creating a non-default"}]}