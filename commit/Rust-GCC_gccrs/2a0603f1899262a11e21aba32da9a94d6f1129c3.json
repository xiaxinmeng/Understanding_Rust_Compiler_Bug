{"sha": "2a0603f1899262a11e21aba32da9a94d6f1129c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmEwNjAzZjE4OTkyNjJhMTFlMjFhYmEzMmRhOWE5NGQ2ZjExMjljMw==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2013-11-05T19:26:07Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2013-11-05T19:26:07Z"}, "message": "gimple.h: Move some prototypes to gimple-expr.h and add to include list.\n\n\n\n\t* gimple.h: Move some prototypes to gimple-expr.h and add to include\n\tlist.\n\t(extract_ops_from_tree, gimple_call_addr_fndecl, is_gimple_reg_type):\n\tMove to gimple-expr.h.\n\t* gimple-expr.h: New file.  Relocate some prototypes from gimple.h.\n\t(types_compatible_p, is_gimple_reg_type, is_gimple_variable,\n\tis_gimple_id, virtual_operand_p, is_gimple_addressable,\n\tis_gimple_constant, extract_ops_from_tree, gimple_call_addr_fndecl):\n\tRelocate here.\n\t* gimple.c (extract_ops_from_tree_1, gimple_cond_get_ops_from_tree,\n\tgimple_set_body, gimple_body, gimple_has_body_p, is_gimple_lvalue,\n\tis_gimple_condexpr, is_gimple_addressable, is_gimple_constant,\n\tis_gimple_address, is_gimple_invariant_address,\n\tis_gimple_ip_invariant_address, is_gimple_min_invariant,\n\tis_gimple_ip_invariant, is_gimple_variable, is_gimple_id,\n\tvirtual_operand_p, is_gimple_reg, is_gimple_val, is_gimple_asm_val,\n\tis_gimple_min_lval, is_gimple_call_addr, is_gimple_mem_ref_addr,\n\tgimple_decl_printable_name, useless_type_conversion_p,\n\ttypes_compatible_p, gimple_can_coalesce_p, copy_var_decl): Move to \n\tgimple-expr.[ch].\n\t* gimple-expr.c: New File.\n\t(useless_type_conversion_p, gimple_set_body, gimple_body,\n\tgimple_has_body_p, gimple_decl_printable_name, copy_var_decl,\n\tgimple_can_coalesce_p, extract_ops_from_tree_1, \n\tgimple_cond_get_ops_from_tree, is_gimple_lvalue, is_gimple_condexpr,\n\tis_gimple_address, is_gimple_invariant_address,\n\tis_gimple_ip_invariant_address, is_gimple_min_invariant,\n\tis_gimple_ip_invariant, is_gimple_reg, is_gimple_val,\n\tis_gimple_asm_val, is_gimple_min_lval, is_gimple_call_addr,\n\tis_gimple_mem_ref_addr): Relocate here.\n\t* Makefile.in (OBJS): Add gimple-expr.o.\n\nFrom-SVN: r204412", "tree": {"sha": "37108019bb346797ef0336eb829491d4143b53c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/37108019bb346797ef0336eb829491d4143b53c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a0603f1899262a11e21aba32da9a94d6f1129c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a0603f1899262a11e21aba32da9a94d6f1129c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a0603f1899262a11e21aba32da9a94d6f1129c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a0603f1899262a11e21aba32da9a94d6f1129c3/comments", "author": null, "committer": null, "parents": [{"sha": "c180e49596bb20aef9c887cf9817e21a7f1e0d2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c180e49596bb20aef9c887cf9817e21a7f1e0d2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c180e49596bb20aef9c887cf9817e21a7f1e0d2b"}], "stats": {"total": 1795, "additions": 928, "deletions": 867}, "files": [{"sha": "468b1856c4f883515155df47aa9c2c574b3542ef", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a0603f1899262a11e21aba32da9a94d6f1129c3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a0603f1899262a11e21aba32da9a94d6f1129c3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2a0603f1899262a11e21aba32da9a94d6f1129c3", "patch": "@@ -1,3 +1,37 @@\n+2013-11-05  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\t* gimple.h: Move some prototypes to gimple-expr.h and add to include\n+\tlist.\n+\t(extract_ops_from_tree, gimple_call_addr_fndecl, is_gimple_reg_type):\n+\tMove to gimple-expr.h.\n+\t* gimple-expr.h: New file.  Relocate some prototypes from gimple.h.\n+\t(types_compatible_p, is_gimple_reg_type, is_gimple_variable,\n+\tis_gimple_id, virtual_operand_p, is_gimple_addressable,\n+\tis_gimple_constant, extract_ops_from_tree, gimple_call_addr_fndecl):\n+\tRelocate here.\n+\t* gimple.c (extract_ops_from_tree_1, gimple_cond_get_ops_from_tree,\n+\tgimple_set_body, gimple_body, gimple_has_body_p, is_gimple_lvalue,\n+\tis_gimple_condexpr, is_gimple_addressable, is_gimple_constant,\n+\tis_gimple_address, is_gimple_invariant_address,\n+\tis_gimple_ip_invariant_address, is_gimple_min_invariant,\n+\tis_gimple_ip_invariant, is_gimple_variable, is_gimple_id,\n+\tvirtual_operand_p, is_gimple_reg, is_gimple_val, is_gimple_asm_val,\n+\tis_gimple_min_lval, is_gimple_call_addr, is_gimple_mem_ref_addr,\n+\tgimple_decl_printable_name, useless_type_conversion_p,\n+\ttypes_compatible_p, gimple_can_coalesce_p, copy_var_decl): Move to \n+\tgimple-expr.[ch].\n+\t* gimple-expr.c: New File.\n+\t(useless_type_conversion_p, gimple_set_body, gimple_body,\n+\tgimple_has_body_p, gimple_decl_printable_name, copy_var_decl,\n+\tgimple_can_coalesce_p, extract_ops_from_tree_1, \n+\tgimple_cond_get_ops_from_tree, is_gimple_lvalue, is_gimple_condexpr,\n+\tis_gimple_address, is_gimple_invariant_address,\n+\tis_gimple_ip_invariant_address, is_gimple_min_invariant,\n+\tis_gimple_ip_invariant, is_gimple_reg, is_gimple_val,\n+\tis_gimple_asm_val, is_gimple_min_lval, is_gimple_call_addr,\n+\tis_gimple_mem_ref_addr): Relocate here.\n+\t* Makefile.in (OBJS): Add gimple-expr.o.\n+\n 2013-11-05  David Malcolm  <dmalcolm@redhat.com>\n \n \t* gengtype-parse.c (struct_field_seq): Support empty structs."}, {"sha": "be8aafff7a83f6dcbc9390a0054ea00042b16f85", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a0603f1899262a11e21aba32da9a94d6f1129c3/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a0603f1899262a11e21aba32da9a94d6f1129c3/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=2a0603f1899262a11e21aba32da9a94d6f1129c3", "patch": "@@ -1230,6 +1230,7 @@ OBJS = \\\n \tggc-common.o \\\n \tgimple.o \\\n \tgimple-builder.o \\\n+\tgimple-expr.o \\\n \tgimple-iterator.o \\\n \tgimple-fold.o \\\n \tgimple-low.o \\"}, {"sha": "c74d9295d1dcebafcffab89bf1879f7988674028", "filename": "gcc/gimple-expr.c", "status": "added", "additions": 721, "deletions": 0, "changes": 721, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a0603f1899262a11e21aba32da9a94d6f1129c3/gcc%2Fgimple-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a0603f1899262a11e21aba32da9a94d6f1129c3/gcc%2Fgimple-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-expr.c?ref=2a0603f1899262a11e21aba32da9a94d6f1129c3", "patch": "@@ -0,0 +1,721 @@\n+/* Gimple decl, type, and expression support functions.\n+\n+   Copyright (C) 2007-2013 Free Software Foundation, Inc.\n+   Contributed by Aldy Hernandez <aldyh@redhat.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"demangle.h\"\n+\n+/* ----- Type related -----  */\n+\n+/* Return true if the conversion from INNER_TYPE to OUTER_TYPE is a\n+   useless type conversion, otherwise return false.\n+\n+   This function implicitly defines the middle-end type system.  With\n+   the notion of 'a < b' meaning that useless_type_conversion_p (a, b)\n+   holds and 'a > b' meaning that useless_type_conversion_p (b, a) holds,\n+   the following invariants shall be fulfilled:\n+\n+     1) useless_type_conversion_p is transitive.\n+\tIf a < b and b < c then a < c.\n+\n+     2) useless_type_conversion_p is not symmetric.\n+\tFrom a < b does not follow a > b.\n+\n+     3) Types define the available set of operations applicable to values.\n+\tA type conversion is useless if the operations for the target type\n+\tis a subset of the operations for the source type.  For example\n+\tcasts to void* are useless, casts from void* are not (void* can't\n+\tbe dereferenced or offsetted, but copied, hence its set of operations\n+\tis a strict subset of that of all other data pointer types).  Casts\n+\tto const T* are useless (can't be written to), casts from const T*\n+\tto T* are not.  */\n+\n+bool\n+useless_type_conversion_p (tree outer_type, tree inner_type)\n+{\n+  /* Do the following before stripping toplevel qualifiers.  */\n+  if (POINTER_TYPE_P (inner_type)\n+      && POINTER_TYPE_P (outer_type))\n+    {\n+      /* Do not lose casts between pointers to different address spaces.  */\n+      if (TYPE_ADDR_SPACE (TREE_TYPE (outer_type))\n+\t  != TYPE_ADDR_SPACE (TREE_TYPE (inner_type)))\n+\treturn false;\n+    }\n+\n+  /* From now on qualifiers on value types do not matter.  */\n+  inner_type = TYPE_MAIN_VARIANT (inner_type);\n+  outer_type = TYPE_MAIN_VARIANT (outer_type);\n+\n+  if (inner_type == outer_type)\n+    return true;\n+\n+  /* If we know the canonical types, compare them.  */\n+  if (TYPE_CANONICAL (inner_type)\n+      && TYPE_CANONICAL (inner_type) == TYPE_CANONICAL (outer_type))\n+    return true;\n+\n+  /* Changes in machine mode are never useless conversions unless we\n+     deal with aggregate types in which case we defer to later checks.  */\n+  if (TYPE_MODE (inner_type) != TYPE_MODE (outer_type)\n+      && !AGGREGATE_TYPE_P (inner_type))\n+    return false;\n+\n+  /* If both the inner and outer types are integral types, then the\n+     conversion is not necessary if they have the same mode and\n+     signedness and precision, and both or neither are boolean.  */\n+  if (INTEGRAL_TYPE_P (inner_type)\n+      && INTEGRAL_TYPE_P (outer_type))\n+    {\n+      /* Preserve changes in signedness or precision.  */\n+      if (TYPE_UNSIGNED (inner_type) != TYPE_UNSIGNED (outer_type)\n+\t  || TYPE_PRECISION (inner_type) != TYPE_PRECISION (outer_type))\n+\treturn false;\n+\n+      /* Preserve conversions to/from BOOLEAN_TYPE if types are not\n+\t of precision one.  */\n+      if (((TREE_CODE (inner_type) == BOOLEAN_TYPE)\n+\t   != (TREE_CODE (outer_type) == BOOLEAN_TYPE))\n+\t  && TYPE_PRECISION (outer_type) != 1)\n+\treturn false;\n+\n+      /* We don't need to preserve changes in the types minimum or\n+\t maximum value in general as these do not generate code\n+\t unless the types precisions are different.  */\n+      return true;\n+    }\n+\n+  /* Scalar floating point types with the same mode are compatible.  */\n+  else if (SCALAR_FLOAT_TYPE_P (inner_type)\n+\t   && SCALAR_FLOAT_TYPE_P (outer_type))\n+    return true;\n+\n+  /* Fixed point types with the same mode are compatible.  */\n+  else if (FIXED_POINT_TYPE_P (inner_type)\n+\t   && FIXED_POINT_TYPE_P (outer_type))\n+    return true;\n+\n+  /* We need to take special care recursing to pointed-to types.  */\n+  else if (POINTER_TYPE_P (inner_type)\n+\t   && POINTER_TYPE_P (outer_type))\n+    {\n+      /* Do not lose casts to function pointer types.  */\n+      if ((TREE_CODE (TREE_TYPE (outer_type)) == FUNCTION_TYPE\n+\t   || TREE_CODE (TREE_TYPE (outer_type)) == METHOD_TYPE)\n+\t  && !(TREE_CODE (TREE_TYPE (inner_type)) == FUNCTION_TYPE\n+\t       || TREE_CODE (TREE_TYPE (inner_type)) == METHOD_TYPE))\n+\treturn false;\n+\n+      /* We do not care for const qualification of the pointed-to types\n+\t as const qualification has no semantic value to the middle-end.  */\n+\n+      /* Otherwise pointers/references are equivalent.  */\n+      return true;\n+    }\n+\n+  /* Recurse for complex types.  */\n+  else if (TREE_CODE (inner_type) == COMPLEX_TYPE\n+\t   && TREE_CODE (outer_type) == COMPLEX_TYPE)\n+    return useless_type_conversion_p (TREE_TYPE (outer_type),\n+\t\t\t\t      TREE_TYPE (inner_type));\n+\n+  /* Recurse for vector types with the same number of subparts.  */\n+  else if (TREE_CODE (inner_type) == VECTOR_TYPE\n+\t   && TREE_CODE (outer_type) == VECTOR_TYPE\n+\t   && TYPE_PRECISION (inner_type) == TYPE_PRECISION (outer_type))\n+    return useless_type_conversion_p (TREE_TYPE (outer_type),\n+\t\t\t\t      TREE_TYPE (inner_type));\n+\n+  else if (TREE_CODE (inner_type) == ARRAY_TYPE\n+\t   && TREE_CODE (outer_type) == ARRAY_TYPE)\n+    {\n+      /* Preserve string attributes.  */\n+      if (TYPE_STRING_FLAG (inner_type) != TYPE_STRING_FLAG (outer_type))\n+\treturn false;\n+\n+      /* Conversions from array types with unknown extent to\n+\t array types with known extent are not useless.  */\n+      if (!TYPE_DOMAIN (inner_type)\n+\t  && TYPE_DOMAIN (outer_type))\n+\treturn false;\n+\n+      /* Nor are conversions from array types with non-constant size to\n+         array types with constant size or to different size.  */\n+      if (TYPE_SIZE (outer_type)\n+\t  && TREE_CODE (TYPE_SIZE (outer_type)) == INTEGER_CST\n+\t  && (!TYPE_SIZE (inner_type)\n+\t      || TREE_CODE (TYPE_SIZE (inner_type)) != INTEGER_CST\n+\t      || !tree_int_cst_equal (TYPE_SIZE (outer_type),\n+\t\t\t\t      TYPE_SIZE (inner_type))))\n+\treturn false;\n+\n+      /* Check conversions between arrays with partially known extents.\n+\t If the array min/max values are constant they have to match.\n+\t Otherwise allow conversions to unknown and variable extents.\n+\t In particular this declares conversions that may change the\n+\t mode to BLKmode as useless.  */\n+      if (TYPE_DOMAIN (inner_type)\n+\t  && TYPE_DOMAIN (outer_type)\n+\t  && TYPE_DOMAIN (inner_type) != TYPE_DOMAIN (outer_type))\n+\t{\n+\t  tree inner_min = TYPE_MIN_VALUE (TYPE_DOMAIN (inner_type));\n+\t  tree outer_min = TYPE_MIN_VALUE (TYPE_DOMAIN (outer_type));\n+\t  tree inner_max = TYPE_MAX_VALUE (TYPE_DOMAIN (inner_type));\n+\t  tree outer_max = TYPE_MAX_VALUE (TYPE_DOMAIN (outer_type));\n+\n+\t  /* After gimplification a variable min/max value carries no\n+\t     additional information compared to a NULL value.  All that\n+\t     matters has been lowered to be part of the IL.  */\n+\t  if (inner_min && TREE_CODE (inner_min) != INTEGER_CST)\n+\t    inner_min = NULL_TREE;\n+\t  if (outer_min && TREE_CODE (outer_min) != INTEGER_CST)\n+\t    outer_min = NULL_TREE;\n+\t  if (inner_max && TREE_CODE (inner_max) != INTEGER_CST)\n+\t    inner_max = NULL_TREE;\n+\t  if (outer_max && TREE_CODE (outer_max) != INTEGER_CST)\n+\t    outer_max = NULL_TREE;\n+\n+\t  /* Conversions NULL / variable <- cst are useless, but not\n+\t     the other way around.  */\n+\t  if (outer_min\n+\t      && (!inner_min\n+\t\t  || !tree_int_cst_equal (inner_min, outer_min)))\n+\t    return false;\n+\t  if (outer_max\n+\t      && (!inner_max\n+\t\t  || !tree_int_cst_equal (inner_max, outer_max)))\n+\t    return false;\n+\t}\n+\n+      /* Recurse on the element check.  */\n+      return useless_type_conversion_p (TREE_TYPE (outer_type),\n+\t\t\t\t\tTREE_TYPE (inner_type));\n+    }\n+\n+  else if ((TREE_CODE (inner_type) == FUNCTION_TYPE\n+\t    || TREE_CODE (inner_type) == METHOD_TYPE)\n+\t   && TREE_CODE (inner_type) == TREE_CODE (outer_type))\n+    {\n+      tree outer_parm, inner_parm;\n+\n+      /* If the return types are not compatible bail out.  */\n+      if (!useless_type_conversion_p (TREE_TYPE (outer_type),\n+\t\t\t\t      TREE_TYPE (inner_type)))\n+\treturn false;\n+\n+      /* Method types should belong to a compatible base class.  */\n+      if (TREE_CODE (inner_type) == METHOD_TYPE\n+\t  && !useless_type_conversion_p (TYPE_METHOD_BASETYPE (outer_type),\n+\t\t\t\t\t TYPE_METHOD_BASETYPE (inner_type)))\n+\treturn false;\n+\n+      /* A conversion to an unprototyped argument list is ok.  */\n+      if (!prototype_p (outer_type))\n+\treturn true;\n+\n+      /* If the unqualified argument types are compatible the conversion\n+\t is useless.  */\n+      if (TYPE_ARG_TYPES (outer_type) == TYPE_ARG_TYPES (inner_type))\n+\treturn true;\n+\n+      for (outer_parm = TYPE_ARG_TYPES (outer_type),\n+\t   inner_parm = TYPE_ARG_TYPES (inner_type);\n+\t   outer_parm && inner_parm;\n+\t   outer_parm = TREE_CHAIN (outer_parm),\n+\t   inner_parm = TREE_CHAIN (inner_parm))\n+\tif (!useless_type_conversion_p\n+\t       (TYPE_MAIN_VARIANT (TREE_VALUE (outer_parm)),\n+\t\tTYPE_MAIN_VARIANT (TREE_VALUE (inner_parm))))\n+\t  return false;\n+\n+      /* If there is a mismatch in the number of arguments the functions\n+\t are not compatible.  */\n+      if (outer_parm || inner_parm)\n+\treturn false;\n+\n+      /* Defer to the target if necessary.  */\n+      if (TYPE_ATTRIBUTES (inner_type) || TYPE_ATTRIBUTES (outer_type))\n+\treturn comp_type_attributes (outer_type, inner_type) != 0;\n+\n+      return true;\n+    }\n+\n+  /* For aggregates we rely on TYPE_CANONICAL exclusively and require\n+     explicit conversions for types involving to be structurally\n+     compared types.  */\n+  else if (AGGREGATE_TYPE_P (inner_type)\n+\t   && TREE_CODE (inner_type) == TREE_CODE (outer_type))\n+    return false;\n+\n+  return false;\n+}\n+\n+\n+/* ----- Decl related -----  */\n+\n+/* Set sequence SEQ to be the GIMPLE body for function FN.  */\n+\n+void\n+gimple_set_body (tree fndecl, gimple_seq seq)\n+{\n+  struct function *fn = DECL_STRUCT_FUNCTION (fndecl);\n+  if (fn == NULL)\n+    {\n+      /* If FNDECL still does not have a function structure associated\n+\t with it, then it does not make sense for it to receive a\n+\t GIMPLE body.  */\n+      gcc_assert (seq == NULL);\n+    }\n+  else\n+    fn->gimple_body = seq;\n+}\n+\n+\n+/* Return the body of GIMPLE statements for function FN.  After the\n+   CFG pass, the function body doesn't exist anymore because it has\n+   been split up into basic blocks.  In this case, it returns\n+   NULL.  */\n+\n+gimple_seq\n+gimple_body (tree fndecl)\n+{\n+  struct function *fn = DECL_STRUCT_FUNCTION (fndecl);\n+  return fn ? fn->gimple_body : NULL;\n+}\n+\n+/* Return true when FNDECL has Gimple body either in unlowered\n+   or CFG form.  */\n+bool\n+gimple_has_body_p (tree fndecl)\n+{\n+  struct function *fn = DECL_STRUCT_FUNCTION (fndecl);\n+  return (gimple_body (fndecl) || (fn && fn->cfg));\n+}\n+\n+/* Return a printable name for symbol DECL.  */\n+\n+const char *\n+gimple_decl_printable_name (tree decl, int verbosity)\n+{\n+  if (!DECL_NAME (decl))\n+    return NULL;\n+\n+  if (DECL_ASSEMBLER_NAME_SET_P (decl))\n+    {\n+      const char *str, *mangled_str;\n+      int dmgl_opts = DMGL_NO_OPTS;\n+\n+      if (verbosity >= 2)\n+\t{\n+\t  dmgl_opts = DMGL_VERBOSE\n+\t\t      | DMGL_ANSI\n+\t\t      | DMGL_GNU_V3\n+\t\t      | DMGL_RET_POSTFIX;\n+\t  if (TREE_CODE (decl) == FUNCTION_DECL)\n+\t    dmgl_opts |= DMGL_PARAMS;\n+\t}\n+\n+      mangled_str = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n+      str = cplus_demangle_v3 (mangled_str, dmgl_opts);\n+      return (str) ? str : mangled_str;\n+    }\n+\n+  return IDENTIFIER_POINTER (DECL_NAME (decl));\n+}\n+\n+\n+/* Create a new VAR_DECL and copy information from VAR to it.  */\n+\n+tree\n+copy_var_decl (tree var, tree name, tree type)\n+{\n+  tree copy = build_decl (DECL_SOURCE_LOCATION (var), VAR_DECL, name, type);\n+\n+  TREE_ADDRESSABLE (copy) = TREE_ADDRESSABLE (var);\n+  TREE_THIS_VOLATILE (copy) = TREE_THIS_VOLATILE (var);\n+  DECL_GIMPLE_REG_P (copy) = DECL_GIMPLE_REG_P (var);\n+  DECL_ARTIFICIAL (copy) = DECL_ARTIFICIAL (var);\n+  DECL_IGNORED_P (copy) = DECL_IGNORED_P (var);\n+  DECL_CONTEXT (copy) = DECL_CONTEXT (var);\n+  TREE_NO_WARNING (copy) = TREE_NO_WARNING (var);\n+  TREE_USED (copy) = 1;\n+  DECL_SEEN_IN_BIND_EXPR_P (copy) = 1;\n+  DECL_ATTRIBUTES (copy) = DECL_ATTRIBUTES (var);\n+\n+  return copy;\n+}\n+\n+/* Given SSA_NAMEs NAME1 and NAME2, return true if they are candidates for\n+   coalescing together, false otherwise.\n+\n+   This must stay consistent with var_map_base_init in tree-ssa-live.c.  */\n+\n+bool\n+gimple_can_coalesce_p (tree name1, tree name2)\n+{\n+  /* First check the SSA_NAME's associated DECL.  We only want to\n+     coalesce if they have the same DECL or both have no associated DECL.  */\n+  tree var1 = SSA_NAME_VAR (name1);\n+  tree var2 = SSA_NAME_VAR (name2);\n+  var1 = (var1 && (!VAR_P (var1) || !DECL_IGNORED_P (var1))) ? var1 : NULL_TREE;\n+  var2 = (var2 && (!VAR_P (var2) || !DECL_IGNORED_P (var2))) ? var2 : NULL_TREE;\n+  if (var1 != var2)\n+    return false;\n+\n+  /* Now check the types.  If the types are the same, then we should\n+     try to coalesce V1 and V2.  */\n+  tree t1 = TREE_TYPE (name1);\n+  tree t2 = TREE_TYPE (name2);\n+  if (t1 == t2)\n+    return true;\n+\n+  /* If the types are not the same, check for a canonical type match.  This\n+     (for example) allows coalescing when the types are fundamentally the\n+     same, but just have different names. \n+\n+     Note pointer types with different address spaces may have the same\n+     canonical type.  Those are rejected for coalescing by the\n+     types_compatible_p check.  */\n+  if (TYPE_CANONICAL (t1)\n+      && TYPE_CANONICAL (t1) == TYPE_CANONICAL (t2)\n+      && types_compatible_p (t1, t2))\n+    return true;\n+\n+  return false;\n+}\n+\n+\n+/* ----- Expression related -----  */\n+\n+/* Extract the operands and code for expression EXPR into *SUBCODE_P,\n+   *OP1_P, *OP2_P and *OP3_P respectively.  */\n+\n+void\n+extract_ops_from_tree_1 (tree expr, enum tree_code *subcode_p, tree *op1_p,\n+\t\t\t tree *op2_p, tree *op3_p)\n+{\n+  enum gimple_rhs_class grhs_class;\n+\n+  *subcode_p = TREE_CODE (expr);\n+  grhs_class = get_gimple_rhs_class (*subcode_p);\n+\n+  if (grhs_class == GIMPLE_TERNARY_RHS)\n+    {\n+      *op1_p = TREE_OPERAND (expr, 0);\n+      *op2_p = TREE_OPERAND (expr, 1);\n+      *op3_p = TREE_OPERAND (expr, 2);\n+    }\n+  else if (grhs_class == GIMPLE_BINARY_RHS)\n+    {\n+      *op1_p = TREE_OPERAND (expr, 0);\n+      *op2_p = TREE_OPERAND (expr, 1);\n+      *op3_p = NULL_TREE;\n+    }\n+  else if (grhs_class == GIMPLE_UNARY_RHS)\n+    {\n+      *op1_p = TREE_OPERAND (expr, 0);\n+      *op2_p = NULL_TREE;\n+      *op3_p = NULL_TREE;\n+    }\n+  else if (grhs_class == GIMPLE_SINGLE_RHS)\n+    {\n+      *op1_p = expr;\n+      *op2_p = NULL_TREE;\n+      *op3_p = NULL_TREE;\n+    }\n+  else\n+    gcc_unreachable ();\n+}\n+\n+/* Extract operands for a GIMPLE_COND statement out of COND_EXPR tree COND.  */\n+\n+void\n+gimple_cond_get_ops_from_tree (tree cond, enum tree_code *code_p,\n+                               tree *lhs_p, tree *rhs_p)\n+{\n+  gcc_assert (TREE_CODE_CLASS (TREE_CODE (cond)) == tcc_comparison\n+\t      || TREE_CODE (cond) == TRUTH_NOT_EXPR\n+\t      || is_gimple_min_invariant (cond)\n+\t      || SSA_VAR_P (cond));\n+\n+  extract_ops_from_tree (cond, code_p, lhs_p, rhs_p);\n+\n+  /* Canonicalize conditionals of the form 'if (!VAL)'.  */\n+  if (*code_p == TRUTH_NOT_EXPR)\n+    {\n+      *code_p = EQ_EXPR;\n+      gcc_assert (*lhs_p && *rhs_p == NULL_TREE);\n+      *rhs_p = build_zero_cst (TREE_TYPE (*lhs_p));\n+    }\n+  /* Canonicalize conditionals of the form 'if (VAL)'  */\n+  else if (TREE_CODE_CLASS (*code_p) != tcc_comparison)\n+    {\n+      *code_p = NE_EXPR;\n+      gcc_assert (*lhs_p && *rhs_p == NULL_TREE);\n+      *rhs_p = build_zero_cst (TREE_TYPE (*lhs_p));\n+    }\n+}\n+\n+/*  Return true if T is a valid LHS for a GIMPLE assignment expression.  */\n+\n+bool\n+is_gimple_lvalue (tree t)\n+{\n+  return (is_gimple_addressable (t)\n+\t  || TREE_CODE (t) == WITH_SIZE_EXPR\n+\t  /* These are complex lvalues, but don't have addresses, so they\n+\t     go here.  */\n+\t  || TREE_CODE (t) == BIT_FIELD_REF);\n+}\n+\n+/*  Return true if T is a GIMPLE condition.  */\n+\n+bool\n+is_gimple_condexpr (tree t)\n+{\n+  return (is_gimple_val (t) || (COMPARISON_CLASS_P (t)\n+\t\t\t\t&& !tree_could_throw_p (t)\n+\t\t\t\t&& is_gimple_val (TREE_OPERAND (t, 0))\n+\t\t\t\t&& is_gimple_val (TREE_OPERAND (t, 1))));\n+}\n+\n+/* Return true if T is a gimple address.  */\n+\n+bool\n+is_gimple_address (const_tree t)\n+{\n+  tree op;\n+\n+  if (TREE_CODE (t) != ADDR_EXPR)\n+    return false;\n+\n+  op = TREE_OPERAND (t, 0);\n+  while (handled_component_p (op))\n+    {\n+      if ((TREE_CODE (op) == ARRAY_REF\n+\t   || TREE_CODE (op) == ARRAY_RANGE_REF)\n+\t  && !is_gimple_val (TREE_OPERAND (op, 1)))\n+\t    return false;\n+\n+      op = TREE_OPERAND (op, 0);\n+    }\n+\n+  if (CONSTANT_CLASS_P (op) || TREE_CODE (op) == MEM_REF)\n+    return true;\n+\n+  switch (TREE_CODE (op))\n+    {\n+    case PARM_DECL:\n+    case RESULT_DECL:\n+    case LABEL_DECL:\n+    case FUNCTION_DECL:\n+    case VAR_DECL:\n+    case CONST_DECL:\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Return true if T is a gimple invariant address.  */\n+\n+bool\n+is_gimple_invariant_address (const_tree t)\n+{\n+  const_tree op;\n+\n+  if (TREE_CODE (t) != ADDR_EXPR)\n+    return false;\n+\n+  op = strip_invariant_refs (TREE_OPERAND (t, 0));\n+  if (!op)\n+    return false;\n+\n+  if (TREE_CODE (op) == MEM_REF)\n+    {\n+      const_tree op0 = TREE_OPERAND (op, 0);\n+      return (TREE_CODE (op0) == ADDR_EXPR\n+\t      && (CONSTANT_CLASS_P (TREE_OPERAND (op0, 0))\n+\t\t  || decl_address_invariant_p (TREE_OPERAND (op0, 0))));\n+    }\n+\n+  return CONSTANT_CLASS_P (op) || decl_address_invariant_p (op);\n+}\n+\n+/* Return true if T is a gimple invariant address at IPA level\n+   (so addresses of variables on stack are not allowed).  */\n+\n+bool\n+is_gimple_ip_invariant_address (const_tree t)\n+{\n+  const_tree op;\n+\n+  if (TREE_CODE (t) != ADDR_EXPR)\n+    return false;\n+\n+  op = strip_invariant_refs (TREE_OPERAND (t, 0));\n+  if (!op)\n+    return false;\n+\n+  if (TREE_CODE (op) == MEM_REF)\n+    {\n+      const_tree op0 = TREE_OPERAND (op, 0);\n+      return (TREE_CODE (op0) == ADDR_EXPR\n+\t      && (CONSTANT_CLASS_P (TREE_OPERAND (op0, 0))\n+\t\t  || decl_address_ip_invariant_p (TREE_OPERAND (op0, 0))));\n+    }\n+\n+  return CONSTANT_CLASS_P (op) || decl_address_ip_invariant_p (op);\n+}\n+\n+/* Return true if T is a GIMPLE minimal invariant.  It's a restricted\n+   form of function invariant.  */\n+\n+bool\n+is_gimple_min_invariant (const_tree t)\n+{\n+  if (TREE_CODE (t) == ADDR_EXPR)\n+    return is_gimple_invariant_address (t);\n+\n+  return is_gimple_constant (t);\n+}\n+\n+/* Return true if T is a GIMPLE interprocedural invariant.  It's a restricted\n+   form of gimple minimal invariant.  */\n+\n+bool\n+is_gimple_ip_invariant (const_tree t)\n+{\n+  if (TREE_CODE (t) == ADDR_EXPR)\n+    return is_gimple_ip_invariant_address (t);\n+\n+  return is_gimple_constant (t);\n+}\n+\n+/* Return true if T is a non-aggregate register variable.  */\n+\n+bool\n+is_gimple_reg (tree t)\n+{\n+  if (virtual_operand_p (t))\n+    return false;\n+\n+  if (TREE_CODE (t) == SSA_NAME)\n+    return true;\n+\n+  if (!is_gimple_variable (t))\n+    return false;\n+\n+  if (!is_gimple_reg_type (TREE_TYPE (t)))\n+    return false;\n+\n+  /* A volatile decl is not acceptable because we can't reuse it as\n+     needed.  We need to copy it into a temp first.  */\n+  if (TREE_THIS_VOLATILE (t))\n+    return false;\n+\n+  /* We define \"registers\" as things that can be renamed as needed,\n+     which with our infrastructure does not apply to memory.  */\n+  if (needs_to_live_in_memory (t))\n+    return false;\n+\n+  /* Hard register variables are an interesting case.  For those that\n+     are call-clobbered, we don't know where all the calls are, since\n+     we don't (want to) take into account which operations will turn\n+     into libcalls at the rtl level.  For those that are call-saved,\n+     we don't currently model the fact that calls may in fact change\n+     global hard registers, nor do we examine ASM_CLOBBERS at the tree\n+     level, and so miss variable changes that might imply.  All around,\n+     it seems safest to not do too much optimization with these at the\n+     tree level at all.  We'll have to rely on the rtl optimizers to\n+     clean this up, as there we've got all the appropriate bits exposed.  */\n+  if (TREE_CODE (t) == VAR_DECL && DECL_HARD_REGISTER (t))\n+    return false;\n+\n+  /* Complex and vector values must have been put into SSA-like form.\n+     That is, no assignments to the individual components.  */\n+  if (TREE_CODE (TREE_TYPE (t)) == COMPLEX_TYPE\n+      || TREE_CODE (TREE_TYPE (t)) == VECTOR_TYPE)\n+    return DECL_GIMPLE_REG_P (t);\n+\n+  return true;\n+}\n+\n+\n+/* Return true if T is a GIMPLE rvalue, i.e. an identifier or a constant.  */\n+\n+bool\n+is_gimple_val (tree t)\n+{\n+  /* Make loads from volatiles and memory vars explicit.  */\n+  if (is_gimple_variable (t)\n+      && is_gimple_reg_type (TREE_TYPE (t))\n+      && !is_gimple_reg (t))\n+    return false;\n+\n+  return (is_gimple_variable (t) || is_gimple_min_invariant (t));\n+}\n+\n+/* Similarly, but accept hard registers as inputs to asm statements.  */\n+\n+bool\n+is_gimple_asm_val (tree t)\n+{\n+  if (TREE_CODE (t) == VAR_DECL && DECL_HARD_REGISTER (t))\n+    return true;\n+\n+  return is_gimple_val (t);\n+}\n+\n+/* Return true if T is a GIMPLE minimal lvalue.  */\n+\n+bool\n+is_gimple_min_lval (tree t)\n+{\n+  if (!(t = CONST_CAST_TREE (strip_invariant_refs (t))))\n+    return false;\n+  return (is_gimple_id (t) || TREE_CODE (t) == MEM_REF);\n+}\n+\n+/* Return true if T is a valid function operand of a CALL_EXPR.  */\n+\n+bool\n+is_gimple_call_addr (tree t)\n+{\n+  return (TREE_CODE (t) == OBJ_TYPE_REF || is_gimple_val (t));\n+}\n+\n+/* Return true if T is a valid address operand of a MEM_REF.  */\n+\n+bool\n+is_gimple_mem_ref_addr (tree t)\n+{\n+  return (is_gimple_reg (t)\n+\t  || TREE_CODE (t) == INTEGER_CST\n+\t  || (TREE_CODE (t) == ADDR_EXPR\n+\t      && (CONSTANT_CLASS_P (TREE_OPERAND (t, 0))\n+\t\t  || decl_address_invariant_p (TREE_OPERAND (t, 0)))));\n+}"}, {"sha": "aad558cebb73335776db5c87884900a0825f233e", "filename": "gcc/gimple-expr.h", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a0603f1899262a11e21aba32da9a94d6f1129c3/gcc%2Fgimple-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a0603f1899262a11e21aba32da9a94d6f1129c3/gcc%2Fgimple-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-expr.h?ref=2a0603f1899262a11e21aba32da9a94d6f1129c3", "patch": "@@ -0,0 +1,171 @@\n+/* Header file for gimple decl, type and expressions.\n+   Copyright (C) 2013 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_GIMPLE_EXPR_H\n+#define GCC_GIMPLE_EXPR_H\n+\n+extern bool useless_type_conversion_p (tree, tree);\n+\n+extern void gimple_set_body (tree, gimple_seq);\n+extern gimple_seq gimple_body (tree);\n+extern bool gimple_has_body_p (tree);\n+extern const char *gimple_decl_printable_name (tree, int);\n+extern tree copy_var_decl (tree, tree, tree);\n+extern bool gimple_can_coalesce_p (tree, tree);\n+\n+extern void extract_ops_from_tree_1 (tree, enum tree_code *, tree *, tree *,\n+\t\t\t\t     tree *);\n+extern void gimple_cond_get_ops_from_tree (tree, enum tree_code *, tree *,\n+\t\t\t\t\t   tree *);\n+extern bool is_gimple_lvalue (tree);\n+extern bool is_gimple_condexpr (tree);\n+extern bool is_gimple_address (const_tree);\n+extern bool is_gimple_invariant_address (const_tree);\n+extern bool is_gimple_ip_invariant_address (const_tree);\n+extern bool is_gimple_min_invariant (const_tree);\n+extern bool is_gimple_ip_invariant (const_tree);\n+extern bool is_gimple_reg (tree);\n+extern bool is_gimple_val (tree);\n+extern bool is_gimple_asm_val (tree);\n+extern bool is_gimple_min_lval (tree);\n+extern bool is_gimple_call_addr (tree);\n+extern bool is_gimple_mem_ref_addr (tree);\n+\n+/* Return true if a conversion from either type of TYPE1 and TYPE2\n+   to the other is not required.  Otherwise return false.  */\n+\n+static inline bool\n+types_compatible_p (tree type1, tree type2)\n+{\n+  return (type1 == type2\n+\t  || (useless_type_conversion_p (type1, type2)\n+\t      && useless_type_conversion_p (type2, type1)));\n+}\n+\n+/* Return true if TYPE is a suitable type for a scalar register variable.  */\n+\n+static inline bool\n+is_gimple_reg_type (tree type)\n+{\n+  return !AGGREGATE_TYPE_P (type);\n+}\n+\n+/* Return true if T is a variable.  */\n+\n+static inline bool\n+is_gimple_variable (tree t)\n+{\n+  return (TREE_CODE (t) == VAR_DECL\n+\t  || TREE_CODE (t) == PARM_DECL\n+\t  || TREE_CODE (t) == RESULT_DECL\n+\t  || TREE_CODE (t) == SSA_NAME);\n+}\n+\n+/*  Return true if T is a GIMPLE identifier (something with an address).  */\n+\n+static inline bool\n+is_gimple_id (tree t)\n+{\n+  return (is_gimple_variable (t)\n+\t  || TREE_CODE (t) == FUNCTION_DECL\n+\t  || TREE_CODE (t) == LABEL_DECL\n+\t  || TREE_CODE (t) == CONST_DECL\n+\t  /* Allow string constants, since they are addressable.  */\n+\t  || TREE_CODE (t) == STRING_CST);\n+}\n+\n+/* Return true if OP, an SSA name or a DECL is a virtual operand.  */\n+\n+static inline bool\n+virtual_operand_p (tree op)\n+{\n+  if (TREE_CODE (op) == SSA_NAME)\n+    {\n+      op = SSA_NAME_VAR (op);\n+      if (!op)\n+\treturn false;\n+    }\n+\n+  if (TREE_CODE (op) == VAR_DECL)\n+    return VAR_DECL_IS_VIRTUAL_OPERAND (op);\n+\n+  return false;\n+}\n+\n+/*  Return true if T is something whose address can be taken.  */\n+\n+static inline bool\n+is_gimple_addressable (tree t)\n+{\n+  return (is_gimple_id (t) || handled_component_p (t)\n+\t  || TREE_CODE (t) == MEM_REF);\n+}\n+\n+/* Return true if T is a valid gimple constant.  */\n+\n+static inline bool\n+is_gimple_constant (const_tree t)\n+{\n+  switch (TREE_CODE (t))\n+    {\n+    case INTEGER_CST:\n+    case REAL_CST:\n+    case FIXED_CST:\n+    case STRING_CST:\n+    case COMPLEX_CST:\n+    case VECTOR_CST:\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* A wrapper around extract_ops_from_tree_1, for callers which expect\n+   to see only a maximum of two operands.  */\n+\n+static inline void\n+extract_ops_from_tree (tree expr, enum tree_code *code, tree *op0,\n+\t\t       tree *op1)\n+{\n+  tree op2;\n+  extract_ops_from_tree_1 (expr, code, op0, op1, &op2);\n+  gcc_assert (op2 == NULL_TREE);\n+}\n+\n+/* Given a valid GIMPLE_CALL function address return the FUNCTION_DECL\n+   associated with the callee if known.  Otherwise return NULL_TREE.  */\n+\n+static inline tree\n+gimple_call_addr_fndecl (const_tree fn)\n+{\n+  if (fn && TREE_CODE (fn) == ADDR_EXPR)\n+    {\n+      tree fndecl = TREE_OPERAND (fn, 0);\n+      if (TREE_CODE (fndecl) == MEM_REF\n+\t  && TREE_CODE (TREE_OPERAND (fndecl, 0)) == ADDR_EXPR\n+\t  && integer_zerop (TREE_OPERAND (fndecl, 1)))\n+\tfndecl = TREE_OPERAND (TREE_OPERAND (fndecl, 0), 0);\n+      if (TREE_CODE (fndecl) == FUNCTION_DECL)\n+\treturn fndecl;\n+    }\n+  return NULL_TREE;\n+}\n+\n+#endif /* GCC_GIMPLE_EXPR_H */"}, {"sha": "4839f3edead90494b4cc9aa9bf1403073862e155", "filename": "gcc/gimple.c", "status": "modified", "additions": 0, "deletions": 776, "changes": 776, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a0603f1899262a11e21aba32da9a94d6f1129c3/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a0603f1899262a11e21aba32da9a94d6f1129c3/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=2a0603f1899262a11e21aba32da9a94d6f1129c3", "patch": "@@ -386,47 +386,6 @@ gimple_call_get_nobnd_arg_index (const_gimple gs, unsigned index)\n }\n \n \n-/* Extract the operands and code for expression EXPR into *SUBCODE_P,\n-   *OP1_P, *OP2_P and *OP3_P respectively.  */\n-\n-void\n-extract_ops_from_tree_1 (tree expr, enum tree_code *subcode_p, tree *op1_p,\n-\t\t\t tree *op2_p, tree *op3_p)\n-{\n-  enum gimple_rhs_class grhs_class;\n-\n-  *subcode_p = TREE_CODE (expr);\n-  grhs_class = get_gimple_rhs_class (*subcode_p);\n-\n-  if (grhs_class == GIMPLE_TERNARY_RHS)\n-    {\n-      *op1_p = TREE_OPERAND (expr, 0);\n-      *op2_p = TREE_OPERAND (expr, 1);\n-      *op3_p = TREE_OPERAND (expr, 2);\n-    }\n-  else if (grhs_class == GIMPLE_BINARY_RHS)\n-    {\n-      *op1_p = TREE_OPERAND (expr, 0);\n-      *op2_p = TREE_OPERAND (expr, 1);\n-      *op3_p = NULL_TREE;\n-    }\n-  else if (grhs_class == GIMPLE_UNARY_RHS)\n-    {\n-      *op1_p = TREE_OPERAND (expr, 0);\n-      *op2_p = NULL_TREE;\n-      *op3_p = NULL_TREE;\n-    }\n-  else if (grhs_class == GIMPLE_SINGLE_RHS)\n-    {\n-      *op1_p = expr;\n-      *op2_p = NULL_TREE;\n-      *op3_p = NULL_TREE;\n-    }\n-  else\n-    gcc_unreachable ();\n-}\n-\n-\n /* Build a GIMPLE_ASSIGN statement.\n \n    LHS of the assignment.\n@@ -526,37 +485,6 @@ gimple_build_cond (enum tree_code pred_code, tree lhs, tree rhs,\n   return p;\n }\n \n-\n-/* Extract operands for a GIMPLE_COND statement out of COND_EXPR tree COND.  */\n-\n-void\n-gimple_cond_get_ops_from_tree (tree cond, enum tree_code *code_p,\n-                               tree *lhs_p, tree *rhs_p)\n-{\n-  gcc_assert (TREE_CODE_CLASS (TREE_CODE (cond)) == tcc_comparison\n-\t      || TREE_CODE (cond) == TRUTH_NOT_EXPR\n-\t      || is_gimple_min_invariant (cond)\n-\t      || SSA_VAR_P (cond));\n-\n-  extract_ops_from_tree (cond, code_p, lhs_p, rhs_p);\n-\n-  /* Canonicalize conditionals of the form 'if (!VAL)'.  */\n-  if (*code_p == TRUTH_NOT_EXPR)\n-    {\n-      *code_p = EQ_EXPR;\n-      gcc_assert (*lhs_p && *rhs_p == NULL_TREE);\n-      *rhs_p = build_zero_cst (TREE_TYPE (*lhs_p));\n-    }\n-  /* Canonicalize conditionals of the form 'if (VAL)'  */\n-  else if (TREE_CODE_CLASS (*code_p) != tcc_comparison)\n-    {\n-      *code_p = NE_EXPR;\n-      gcc_assert (*lhs_p && *rhs_p == NULL_TREE);\n-      *rhs_p = build_zero_cst (TREE_TYPE (*lhs_p));\n-    }\n-}\n-\n-\n /* Build a GIMPLE_COND statement from the conditional expression tree\n    COND.  T_LABEL and F_LABEL are as in gimple_build_cond.  */\n \n@@ -1906,45 +1834,6 @@ walk_gimple_stmt (gimple_stmt_iterator *gsi, walk_stmt_fn callback_stmt,\n }\n \n \n-/* Set sequence SEQ to be the GIMPLE body for function FN.  */\n-\n-void\n-gimple_set_body (tree fndecl, gimple_seq seq)\n-{\n-  struct function *fn = DECL_STRUCT_FUNCTION (fndecl);\n-  if (fn == NULL)\n-    {\n-      /* If FNDECL still does not have a function structure associated\n-\t with it, then it does not make sense for it to receive a\n-\t GIMPLE body.  */\n-      gcc_assert (seq == NULL);\n-    }\n-  else\n-    fn->gimple_body = seq;\n-}\n-\n-\n-/* Return the body of GIMPLE statements for function FN.  After the\n-   CFG pass, the function body doesn't exist anymore because it has\n-   been split up into basic blocks.  In this case, it returns\n-   NULL.  */\n-\n-gimple_seq\n-gimple_body (tree fndecl)\n-{\n-  struct function *fn = DECL_STRUCT_FUNCTION (fndecl);\n-  return fn ? fn->gimple_body : NULL;\n-}\n-\n-/* Return true when FNDECL has Gimple body either in unlowered\n-   or CFG form.  */\n-bool\n-gimple_has_body_p (tree fndecl)\n-{\n-  struct function *fn = DECL_STRUCT_FUNCTION (fndecl);\n-  return (gimple_body (fndecl) || (fn && fn->cfg));\n-}\n-\n /* Return true if calls C1 and C2 are known to go to the same function.  */\n \n bool\n@@ -2602,325 +2491,6 @@ const unsigned char gimple_rhs_class_table[] = {\n #undef DEFTREECODE\n #undef END_OF_BASE_TREE_CODES\n \n-/* For the definitive definition of GIMPLE, see doc/tree-ssa.texi.  */\n-\n-/* Validation of GIMPLE expressions.  */\n-\n-/*  Return true if T is a valid LHS for a GIMPLE assignment expression.  */\n-\n-bool\n-is_gimple_lvalue (tree t)\n-{\n-  return (is_gimple_addressable (t)\n-\t  || TREE_CODE (t) == WITH_SIZE_EXPR\n-\t  /* These are complex lvalues, but don't have addresses, so they\n-\t     go here.  */\n-\t  || TREE_CODE (t) == BIT_FIELD_REF);\n-}\n-\n-/*  Return true if T is a GIMPLE condition.  */\n-\n-bool\n-is_gimple_condexpr (tree t)\n-{\n-  return (is_gimple_val (t) || (COMPARISON_CLASS_P (t)\n-\t\t\t\t&& !tree_could_throw_p (t)\n-\t\t\t\t&& is_gimple_val (TREE_OPERAND (t, 0))\n-\t\t\t\t&& is_gimple_val (TREE_OPERAND (t, 1))));\n-}\n-\n-/*  Return true if T is something whose address can be taken.  */\n-\n-bool\n-is_gimple_addressable (tree t)\n-{\n-  return (is_gimple_id (t) || handled_component_p (t)\n-\t  || TREE_CODE (t) == MEM_REF);\n-}\n-\n-/* Return true if T is a valid gimple constant.  */\n-\n-bool\n-is_gimple_constant (const_tree t)\n-{\n-  switch (TREE_CODE (t))\n-    {\n-    case INTEGER_CST:\n-    case REAL_CST:\n-    case FIXED_CST:\n-    case STRING_CST:\n-    case COMPLEX_CST:\n-    case VECTOR_CST:\n-      return true;\n-\n-    default:\n-      return false;\n-    }\n-}\n-\n-/* Return true if T is a gimple address.  */\n-\n-bool\n-is_gimple_address (const_tree t)\n-{\n-  tree op;\n-\n-  if (TREE_CODE (t) != ADDR_EXPR)\n-    return false;\n-\n-  op = TREE_OPERAND (t, 0);\n-  while (handled_component_p (op))\n-    {\n-      if ((TREE_CODE (op) == ARRAY_REF\n-\t   || TREE_CODE (op) == ARRAY_RANGE_REF)\n-\t  && !is_gimple_val (TREE_OPERAND (op, 1)))\n-\t    return false;\n-\n-      op = TREE_OPERAND (op, 0);\n-    }\n-\n-  if (CONSTANT_CLASS_P (op) || TREE_CODE (op) == MEM_REF)\n-    return true;\n-\n-  switch (TREE_CODE (op))\n-    {\n-    case PARM_DECL:\n-    case RESULT_DECL:\n-    case LABEL_DECL:\n-    case FUNCTION_DECL:\n-    case VAR_DECL:\n-    case CONST_DECL:\n-      return true;\n-\n-    default:\n-      return false;\n-    }\n-}\n-\n-/* Return true if T is a gimple invariant address.  */\n-\n-bool\n-is_gimple_invariant_address (const_tree t)\n-{\n-  const_tree op;\n-\n-  if (TREE_CODE (t) != ADDR_EXPR)\n-    return false;\n-\n-  op = strip_invariant_refs (TREE_OPERAND (t, 0));\n-  if (!op)\n-    return false;\n-\n-  if (TREE_CODE (op) == MEM_REF)\n-    {\n-      const_tree op0 = TREE_OPERAND (op, 0);\n-      return (TREE_CODE (op0) == ADDR_EXPR\n-\t      && (CONSTANT_CLASS_P (TREE_OPERAND (op0, 0))\n-\t\t  || decl_address_invariant_p (TREE_OPERAND (op0, 0))));\n-    }\n-\n-  return CONSTANT_CLASS_P (op) || decl_address_invariant_p (op);\n-}\n-\n-/* Return true if T is a gimple invariant address at IPA level\n-   (so addresses of variables on stack are not allowed).  */\n-\n-bool\n-is_gimple_ip_invariant_address (const_tree t)\n-{\n-  const_tree op;\n-\n-  if (TREE_CODE (t) != ADDR_EXPR)\n-    return false;\n-\n-  op = strip_invariant_refs (TREE_OPERAND (t, 0));\n-  if (!op)\n-    return false;\n-\n-  if (TREE_CODE (op) == MEM_REF)\n-    {\n-      const_tree op0 = TREE_OPERAND (op, 0);\n-      return (TREE_CODE (op0) == ADDR_EXPR\n-\t      && (CONSTANT_CLASS_P (TREE_OPERAND (op0, 0))\n-\t\t  || decl_address_ip_invariant_p (TREE_OPERAND (op0, 0))));\n-    }\n-\n-  return CONSTANT_CLASS_P (op) || decl_address_ip_invariant_p (op);\n-}\n-\n-/* Return true if T is a GIMPLE minimal invariant.  It's a restricted\n-   form of function invariant.  */\n-\n-bool\n-is_gimple_min_invariant (const_tree t)\n-{\n-  if (TREE_CODE (t) == ADDR_EXPR)\n-    return is_gimple_invariant_address (t);\n-\n-  return is_gimple_constant (t);\n-}\n-\n-/* Return true if T is a GIMPLE interprocedural invariant.  It's a restricted\n-   form of gimple minimal invariant.  */\n-\n-bool\n-is_gimple_ip_invariant (const_tree t)\n-{\n-  if (TREE_CODE (t) == ADDR_EXPR)\n-    return is_gimple_ip_invariant_address (t);\n-\n-  return is_gimple_constant (t);\n-}\n-\n-/* Return true if T is a variable.  */\n-\n-bool\n-is_gimple_variable (tree t)\n-{\n-  return (TREE_CODE (t) == VAR_DECL\n-\t  || TREE_CODE (t) == PARM_DECL\n-\t  || TREE_CODE (t) == RESULT_DECL\n-\t  || TREE_CODE (t) == SSA_NAME);\n-}\n-\n-/*  Return true if T is a GIMPLE identifier (something with an address).  */\n-\n-bool\n-is_gimple_id (tree t)\n-{\n-  return (is_gimple_variable (t)\n-\t  || TREE_CODE (t) == FUNCTION_DECL\n-\t  || TREE_CODE (t) == LABEL_DECL\n-\t  || TREE_CODE (t) == CONST_DECL\n-\t  /* Allow string constants, since they are addressable.  */\n-\t  || TREE_CODE (t) == STRING_CST);\n-}\n-\n-/* Return true if OP, an SSA name or a DECL is a virtual operand.  */\n-\n-bool\n-virtual_operand_p (tree op)\n-{\n-  if (TREE_CODE (op) == SSA_NAME)\n-    {\n-      op = SSA_NAME_VAR (op);\n-      if (!op)\n-\treturn false;\n-    }\n-\n-  if (TREE_CODE (op) == VAR_DECL)\n-    return VAR_DECL_IS_VIRTUAL_OPERAND (op);\n-\n-  return false;\n-}\n-\n-\n-/* Return true if T is a non-aggregate register variable.  */\n-\n-bool\n-is_gimple_reg (tree t)\n-{\n-  if (virtual_operand_p (t))\n-    return false;\n-\n-  if (TREE_CODE (t) == SSA_NAME)\n-    return true;\n-\n-  if (!is_gimple_variable (t))\n-    return false;\n-\n-  if (!is_gimple_reg_type (TREE_TYPE (t)))\n-    return false;\n-\n-  /* A volatile decl is not acceptable because we can't reuse it as\n-     needed.  We need to copy it into a temp first.  */\n-  if (TREE_THIS_VOLATILE (t))\n-    return false;\n-\n-  /* We define \"registers\" as things that can be renamed as needed,\n-     which with our infrastructure does not apply to memory.  */\n-  if (needs_to_live_in_memory (t))\n-    return false;\n-\n-  /* Hard register variables are an interesting case.  For those that\n-     are call-clobbered, we don't know where all the calls are, since\n-     we don't (want to) take into account which operations will turn\n-     into libcalls at the rtl level.  For those that are call-saved,\n-     we don't currently model the fact that calls may in fact change\n-     global hard registers, nor do we examine ASM_CLOBBERS at the tree\n-     level, and so miss variable changes that might imply.  All around,\n-     it seems safest to not do too much optimization with these at the\n-     tree level at all.  We'll have to rely on the rtl optimizers to\n-     clean this up, as there we've got all the appropriate bits exposed.  */\n-  if (TREE_CODE (t) == VAR_DECL && DECL_HARD_REGISTER (t))\n-    return false;\n-\n-  /* Complex and vector values must have been put into SSA-like form.\n-     That is, no assignments to the individual components.  */\n-  if (TREE_CODE (TREE_TYPE (t)) == COMPLEX_TYPE\n-      || TREE_CODE (TREE_TYPE (t)) == VECTOR_TYPE)\n-    return DECL_GIMPLE_REG_P (t);\n-\n-  return true;\n-}\n-\n-\n-/* Return true if T is a GIMPLE rvalue, i.e. an identifier or a constant.  */\n-\n-bool\n-is_gimple_val (tree t)\n-{\n-  /* Make loads from volatiles and memory vars explicit.  */\n-  if (is_gimple_variable (t)\n-      && is_gimple_reg_type (TREE_TYPE (t))\n-      && !is_gimple_reg (t))\n-    return false;\n-\n-  return (is_gimple_variable (t) || is_gimple_min_invariant (t));\n-}\n-\n-/* Similarly, but accept hard registers as inputs to asm statements.  */\n-\n-bool\n-is_gimple_asm_val (tree t)\n-{\n-  if (TREE_CODE (t) == VAR_DECL && DECL_HARD_REGISTER (t))\n-    return true;\n-\n-  return is_gimple_val (t);\n-}\n-\n-/* Return true if T is a GIMPLE minimal lvalue.  */\n-\n-bool\n-is_gimple_min_lval (tree t)\n-{\n-  if (!(t = CONST_CAST_TREE (strip_invariant_refs (t))))\n-    return false;\n-  return (is_gimple_id (t) || TREE_CODE (t) == MEM_REF);\n-}\n-\n-/* Return true if T is a valid function operand of a CALL_EXPR.  */\n-\n-bool\n-is_gimple_call_addr (tree t)\n-{\n-  return (TREE_CODE (t) == OBJ_TYPE_REF || is_gimple_val (t));\n-}\n-\n-/* Return true if T is a valid address operand of a MEM_REF.  */\n-\n-bool\n-is_gimple_mem_ref_addr (tree t)\n-{\n-  return (is_gimple_reg (t)\n-\t  || TREE_CODE (t) == INTEGER_CST\n-\t  || (TREE_CODE (t) == ADDR_EXPR\n-\t      && (CONSTANT_CLASS_P (TREE_OPERAND (t, 0))\n-\t\t  || decl_address_invariant_p (TREE_OPERAND (t, 0)))));\n-}\n-\n-\n /* Given a memory reference expression T, return its base address.\n    The base address of a memory reference expression is the main\n    object being referenced.  For instance, the base address for\n@@ -3642,37 +3212,6 @@ gimple_ior_addresses_taken (bitmap addresses_taken, gimple stmt)\n }\n \n \n-/* Return a printable name for symbol DECL.  */\n-\n-const char *\n-gimple_decl_printable_name (tree decl, int verbosity)\n-{\n-  if (!DECL_NAME (decl))\n-    return NULL;\n-\n-  if (DECL_ASSEMBLER_NAME_SET_P (decl))\n-    {\n-      const char *str, *mangled_str;\n-      int dmgl_opts = DMGL_NO_OPTS;\n-\n-      if (verbosity >= 2)\n-\t{\n-\t  dmgl_opts = DMGL_VERBOSE\n-\t\t      | DMGL_ANSI\n-\t\t      | DMGL_GNU_V3\n-\t\t      | DMGL_RET_POSTFIX;\n-\t  if (TREE_CODE (decl) == FUNCTION_DECL)\n-\t    dmgl_opts |= DMGL_PARAMS;\n-\t}\n-\n-      mangled_str = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n-      str = cplus_demangle_v3 (mangled_str, dmgl_opts);\n-      return (str) ? str : mangled_str;\n-    }\n-\n-  return IDENTIFIER_POINTER (DECL_NAME (decl));\n-}\n-\n /* Return TRUE iff stmt is a call to a built-in function.  */\n \n bool\n@@ -3763,261 +3302,6 @@ gimple_asm_clobbers_memory_p (const_gimple stmt)\n   return false;\n }\n \n-\n-/* Return true if the conversion from INNER_TYPE to OUTER_TYPE is a\n-   useless type conversion, otherwise return false.\n-\n-   This function implicitly defines the middle-end type system.  With\n-   the notion of 'a < b' meaning that useless_type_conversion_p (a, b)\n-   holds and 'a > b' meaning that useless_type_conversion_p (b, a) holds,\n-   the following invariants shall be fulfilled:\n-\n-     1) useless_type_conversion_p is transitive.\n-\tIf a < b and b < c then a < c.\n-\n-     2) useless_type_conversion_p is not symmetric.\n-\tFrom a < b does not follow a > b.\n-\n-     3) Types define the available set of operations applicable to values.\n-\tA type conversion is useless if the operations for the target type\n-\tis a subset of the operations for the source type.  For example\n-\tcasts to void* are useless, casts from void* are not (void* can't\n-\tbe dereferenced or offsetted, but copied, hence its set of operations\n-\tis a strict subset of that of all other data pointer types).  Casts\n-\tto const T* are useless (can't be written to), casts from const T*\n-\tto T* are not.  */\n-\n-bool\n-useless_type_conversion_p (tree outer_type, tree inner_type)\n-{\n-  /* Do the following before stripping toplevel qualifiers.  */\n-  if (POINTER_TYPE_P (inner_type)\n-      && POINTER_TYPE_P (outer_type))\n-    {\n-      /* Do not lose casts between pointers to different address spaces.  */\n-      if (TYPE_ADDR_SPACE (TREE_TYPE (outer_type))\n-\t  != TYPE_ADDR_SPACE (TREE_TYPE (inner_type)))\n-\treturn false;\n-    }\n-\n-  /* From now on qualifiers on value types do not matter.  */\n-  inner_type = TYPE_MAIN_VARIANT (inner_type);\n-  outer_type = TYPE_MAIN_VARIANT (outer_type);\n-\n-  if (inner_type == outer_type)\n-    return true;\n-\n-  /* If we know the canonical types, compare them.  */\n-  if (TYPE_CANONICAL (inner_type)\n-      && TYPE_CANONICAL (inner_type) == TYPE_CANONICAL (outer_type))\n-    return true;\n-\n-  /* Changes in machine mode are never useless conversions unless we\n-     deal with aggregate types in which case we defer to later checks.  */\n-  if (TYPE_MODE (inner_type) != TYPE_MODE (outer_type)\n-      && !AGGREGATE_TYPE_P (inner_type))\n-    return false;\n-\n-  /* If both the inner and outer types are integral types, then the\n-     conversion is not necessary if they have the same mode and\n-     signedness and precision, and both or neither are boolean.  */\n-  if (INTEGRAL_TYPE_P (inner_type)\n-      && INTEGRAL_TYPE_P (outer_type))\n-    {\n-      /* Preserve changes in signedness or precision.  */\n-      if (TYPE_UNSIGNED (inner_type) != TYPE_UNSIGNED (outer_type)\n-\t  || TYPE_PRECISION (inner_type) != TYPE_PRECISION (outer_type))\n-\treturn false;\n-\n-      /* Preserve conversions to/from BOOLEAN_TYPE if types are not\n-\t of precision one.  */\n-      if (((TREE_CODE (inner_type) == BOOLEAN_TYPE)\n-\t   != (TREE_CODE (outer_type) == BOOLEAN_TYPE))\n-\t  && TYPE_PRECISION (outer_type) != 1)\n-\treturn false;\n-\n-      /* We don't need to preserve changes in the types minimum or\n-\t maximum value in general as these do not generate code\n-\t unless the types precisions are different.  */\n-      return true;\n-    }\n-\n-  /* Scalar floating point types with the same mode are compatible.  */\n-  else if (SCALAR_FLOAT_TYPE_P (inner_type)\n-\t   && SCALAR_FLOAT_TYPE_P (outer_type))\n-    return true;\n-\n-  /* Fixed point types with the same mode are compatible.  */\n-  else if (FIXED_POINT_TYPE_P (inner_type)\n-\t   && FIXED_POINT_TYPE_P (outer_type))\n-    return true;\n-\n-  /* We need to take special care recursing to pointed-to types.  */\n-  else if (POINTER_TYPE_P (inner_type)\n-\t   && POINTER_TYPE_P (outer_type))\n-    {\n-      /* Do not lose casts to function pointer types.  */\n-      if ((TREE_CODE (TREE_TYPE (outer_type)) == FUNCTION_TYPE\n-\t   || TREE_CODE (TREE_TYPE (outer_type)) == METHOD_TYPE)\n-\t  && !(TREE_CODE (TREE_TYPE (inner_type)) == FUNCTION_TYPE\n-\t       || TREE_CODE (TREE_TYPE (inner_type)) == METHOD_TYPE))\n-\treturn false;\n-\n-      /* We do not care for const qualification of the pointed-to types\n-\t as const qualification has no semantic value to the middle-end.  */\n-\n-      /* Otherwise pointers/references are equivalent.  */\n-      return true;\n-    }\n-\n-  /* Recurse for complex types.  */\n-  else if (TREE_CODE (inner_type) == COMPLEX_TYPE\n-\t   && TREE_CODE (outer_type) == COMPLEX_TYPE)\n-    return useless_type_conversion_p (TREE_TYPE (outer_type),\n-\t\t\t\t      TREE_TYPE (inner_type));\n-\n-  /* Recurse for vector types with the same number of subparts.  */\n-  else if (TREE_CODE (inner_type) == VECTOR_TYPE\n-\t   && TREE_CODE (outer_type) == VECTOR_TYPE\n-\t   && TYPE_PRECISION (inner_type) == TYPE_PRECISION (outer_type))\n-    return useless_type_conversion_p (TREE_TYPE (outer_type),\n-\t\t\t\t      TREE_TYPE (inner_type));\n-\n-  else if (TREE_CODE (inner_type) == ARRAY_TYPE\n-\t   && TREE_CODE (outer_type) == ARRAY_TYPE)\n-    {\n-      /* Preserve string attributes.  */\n-      if (TYPE_STRING_FLAG (inner_type) != TYPE_STRING_FLAG (outer_type))\n-\treturn false;\n-\n-      /* Conversions from array types with unknown extent to\n-\t array types with known extent are not useless.  */\n-      if (!TYPE_DOMAIN (inner_type)\n-\t  && TYPE_DOMAIN (outer_type))\n-\treturn false;\n-\n-      /* Nor are conversions from array types with non-constant size to\n-         array types with constant size or to different size.  */\n-      if (TYPE_SIZE (outer_type)\n-\t  && TREE_CODE (TYPE_SIZE (outer_type)) == INTEGER_CST\n-\t  && (!TYPE_SIZE (inner_type)\n-\t      || TREE_CODE (TYPE_SIZE (inner_type)) != INTEGER_CST\n-\t      || !tree_int_cst_equal (TYPE_SIZE (outer_type),\n-\t\t\t\t      TYPE_SIZE (inner_type))))\n-\treturn false;\n-\n-      /* Check conversions between arrays with partially known extents.\n-\t If the array min/max values are constant they have to match.\n-\t Otherwise allow conversions to unknown and variable extents.\n-\t In particular this declares conversions that may change the\n-\t mode to BLKmode as useless.  */\n-      if (TYPE_DOMAIN (inner_type)\n-\t  && TYPE_DOMAIN (outer_type)\n-\t  && TYPE_DOMAIN (inner_type) != TYPE_DOMAIN (outer_type))\n-\t{\n-\t  tree inner_min = TYPE_MIN_VALUE (TYPE_DOMAIN (inner_type));\n-\t  tree outer_min = TYPE_MIN_VALUE (TYPE_DOMAIN (outer_type));\n-\t  tree inner_max = TYPE_MAX_VALUE (TYPE_DOMAIN (inner_type));\n-\t  tree outer_max = TYPE_MAX_VALUE (TYPE_DOMAIN (outer_type));\n-\n-\t  /* After gimplification a variable min/max value carries no\n-\t     additional information compared to a NULL value.  All that\n-\t     matters has been lowered to be part of the IL.  */\n-\t  if (inner_min && TREE_CODE (inner_min) != INTEGER_CST)\n-\t    inner_min = NULL_TREE;\n-\t  if (outer_min && TREE_CODE (outer_min) != INTEGER_CST)\n-\t    outer_min = NULL_TREE;\n-\t  if (inner_max && TREE_CODE (inner_max) != INTEGER_CST)\n-\t    inner_max = NULL_TREE;\n-\t  if (outer_max && TREE_CODE (outer_max) != INTEGER_CST)\n-\t    outer_max = NULL_TREE;\n-\n-\t  /* Conversions NULL / variable <- cst are useless, but not\n-\t     the other way around.  */\n-\t  if (outer_min\n-\t      && (!inner_min\n-\t\t  || !tree_int_cst_equal (inner_min, outer_min)))\n-\t    return false;\n-\t  if (outer_max\n-\t      && (!inner_max\n-\t\t  || !tree_int_cst_equal (inner_max, outer_max)))\n-\t    return false;\n-\t}\n-\n-      /* Recurse on the element check.  */\n-      return useless_type_conversion_p (TREE_TYPE (outer_type),\n-\t\t\t\t\tTREE_TYPE (inner_type));\n-    }\n-\n-  else if ((TREE_CODE (inner_type) == FUNCTION_TYPE\n-\t    || TREE_CODE (inner_type) == METHOD_TYPE)\n-\t   && TREE_CODE (inner_type) == TREE_CODE (outer_type))\n-    {\n-      tree outer_parm, inner_parm;\n-\n-      /* If the return types are not compatible bail out.  */\n-      if (!useless_type_conversion_p (TREE_TYPE (outer_type),\n-\t\t\t\t      TREE_TYPE (inner_type)))\n-\treturn false;\n-\n-      /* Method types should belong to a compatible base class.  */\n-      if (TREE_CODE (inner_type) == METHOD_TYPE\n-\t  && !useless_type_conversion_p (TYPE_METHOD_BASETYPE (outer_type),\n-\t\t\t\t\t TYPE_METHOD_BASETYPE (inner_type)))\n-\treturn false;\n-\n-      /* A conversion to an unprototyped argument list is ok.  */\n-      if (!prototype_p (outer_type))\n-\treturn true;\n-\n-      /* If the unqualified argument types are compatible the conversion\n-\t is useless.  */\n-      if (TYPE_ARG_TYPES (outer_type) == TYPE_ARG_TYPES (inner_type))\n-\treturn true;\n-\n-      for (outer_parm = TYPE_ARG_TYPES (outer_type),\n-\t   inner_parm = TYPE_ARG_TYPES (inner_type);\n-\t   outer_parm && inner_parm;\n-\t   outer_parm = TREE_CHAIN (outer_parm),\n-\t   inner_parm = TREE_CHAIN (inner_parm))\n-\tif (!useless_type_conversion_p\n-\t       (TYPE_MAIN_VARIANT (TREE_VALUE (outer_parm)),\n-\t\tTYPE_MAIN_VARIANT (TREE_VALUE (inner_parm))))\n-\t  return false;\n-\n-      /* If there is a mismatch in the number of arguments the functions\n-\t are not compatible.  */\n-      if (outer_parm || inner_parm)\n-\treturn false;\n-\n-      /* Defer to the target if necessary.  */\n-      if (TYPE_ATTRIBUTES (inner_type) || TYPE_ATTRIBUTES (outer_type))\n-\treturn comp_type_attributes (outer_type, inner_type) != 0;\n-\n-      return true;\n-    }\n-\n-  /* For aggregates we rely on TYPE_CANONICAL exclusively and require\n-     explicit conversions for types involving to be structurally\n-     compared types.  */\n-  else if (AGGREGATE_TYPE_P (inner_type)\n-\t   && TREE_CODE (inner_type) == TREE_CODE (outer_type))\n-    return false;\n-\n-  return false;\n-}\n-\n-/* Return true if a conversion from either type of TYPE1 and TYPE2\n-   to the other is not required.  Otherwise return false.  */\n-\n-bool\n-types_compatible_p (tree type1, tree type2)\n-{\n-  return (type1 == type2\n-\t  || (useless_type_conversion_p (type1, type2)\n-\t      && useless_type_conversion_p (type2, type1)));\n-}\n-\n /* Dump bitmap SET (assumed to contain VAR_DECLs) to FILE.  */\n \n void\n@@ -4042,45 +3326,6 @@ dump_decl_set (FILE *file, bitmap set)\n     fprintf (file, \"NIL\");\n }\n \n-/* Given SSA_NAMEs NAME1 and NAME2, return true if they are candidates for\n-   coalescing together, false otherwise.\n-\n-   This must stay consistent with var_map_base_init in tree-ssa-live.c.  */\n-\n-bool\n-gimple_can_coalesce_p (tree name1, tree name2)\n-{\n-  /* First check the SSA_NAME's associated DECL.  We only want to\n-     coalesce if they have the same DECL or both have no associated DECL.  */\n-  tree var1 = SSA_NAME_VAR (name1);\n-  tree var2 = SSA_NAME_VAR (name2);\n-  var1 = (var1 && (!VAR_P (var1) || !DECL_IGNORED_P (var1))) ? var1 : NULL_TREE;\n-  var2 = (var2 && (!VAR_P (var2) || !DECL_IGNORED_P (var2))) ? var2 : NULL_TREE;\n-  if (var1 != var2)\n-    return false;\n-\n-  /* Now check the types.  If the types are the same, then we should\n-     try to coalesce V1 and V2.  */\n-  tree t1 = TREE_TYPE (name1);\n-  tree t2 = TREE_TYPE (name2);\n-  if (t1 == t2)\n-    return true;\n-\n-  /* If the types are not the same, check for a canonical type match.  This\n-     (for example) allows coalescing when the types are fundamentally the\n-     same, but just have different names. \n-\n-     Note pointer types with different address spaces may have the same\n-     canonical type.  Those are rejected for coalescing by the\n-     types_compatible_p check.  */\n-  if (TYPE_CANONICAL (t1)\n-      && TYPE_CANONICAL (t1) == TYPE_CANONICAL (t2)\n-      && types_compatible_p (t1, t2))\n-    return true;\n-\n-  return false;\n-}\n-\n /* Return true when CALL is a call stmt that definitely doesn't\n    free any memory or makes it unavailable otherwise.  */\n bool\n@@ -4102,24 +3347,3 @@ nonfreeing_call_p (gimple call)\n \n   return false;\n }\n-\n-/* Create a new VAR_DECL and copy information from VAR to it.  */\n-\n-tree\n-copy_var_decl (tree var, tree name, tree type)\n-{\n-  tree copy = build_decl (DECL_SOURCE_LOCATION (var), VAR_DECL, name, type);\n-\n-  TREE_ADDRESSABLE (copy) = TREE_ADDRESSABLE (var);\n-  TREE_THIS_VOLATILE (copy) = TREE_THIS_VOLATILE (var);\n-  DECL_GIMPLE_REG_P (copy) = DECL_GIMPLE_REG_P (var);\n-  DECL_ARTIFICIAL (copy) = DECL_ARTIFICIAL (var);\n-  DECL_IGNORED_P (copy) = DECL_IGNORED_P (var);\n-  DECL_CONTEXT (copy) = DECL_CONTEXT (var);\n-  TREE_NO_WARNING (copy) = TREE_NO_WARNING (var);\n-  TREE_USED (copy) = 1;\n-  DECL_SEEN_IN_BIND_EXPR_P (copy) = 1;\n-  DECL_ATTRIBUTES (copy) = DECL_ATTRIBUTES (var);\n-\n-  return copy;\n-}"}, {"sha": "70a4eb615891b9ee6e8f3fc6fc3432d8b9410041", "filename": "gcc/gimple.h", "status": "modified", "additions": 1, "deletions": 91, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a0603f1899262a11e21aba32da9a94d6f1129c3/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a0603f1899262a11e21aba32da9a94d6f1129c3/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=2a0603f1899262a11e21aba32da9a94d6f1129c3", "patch": "@@ -31,6 +31,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"internal-fn.h\"\n #include \"gimple-fold.h\"\n #include \"tree-eh.h\"\n+#include \"gimple-expr.h\"\n \n typedef gimple gimple_seq_node;\n \n@@ -745,8 +746,6 @@ gimple gimple_build_return (tree);\n gimple gimple_build_assign_stat (tree, tree MEM_STAT_DECL);\n #define gimple_build_assign(l,r) gimple_build_assign_stat (l, r MEM_STAT_INFO)\n \n-void extract_ops_from_tree_1 (tree, enum tree_code *, tree *, tree *, tree *);\n-\n gimple\n gimple_build_assign_with_ops (enum tree_code, tree,\n \t\t\t      tree, tree CXX_MEM_STAT_INFO);\n@@ -809,9 +808,6 @@ gimple gimple_build_predict (enum br_predictor, enum prediction);\n enum gimple_statement_structure_enum gss_for_assign (enum tree_code);\n void sort_case_labels (vec<tree> );\n void preprocess_case_label_vec_for_gimple (vec<tree> , tree, tree *);\n-void gimple_set_body (tree, gimple_seq);\n-gimple_seq gimple_body (tree);\n-bool gimple_has_body_p (tree);\n gimple_seq gimple_seq_alloc (void);\n void gimple_seq_free (gimple_seq);\n void gimple_seq_add_seq (gimple_seq *, gimple_seq);\n@@ -832,7 +828,6 @@ tree gimple_get_lhs (const_gimple);\n void gimple_set_lhs (gimple, tree);\n void gimple_replace_lhs (gimple, tree);\n gimple gimple_copy (gimple);\n-void gimple_cond_get_ops_from_tree (tree, enum tree_code *, tree *, tree *);\n gimple gimple_build_cond_from_tree (tree, tree, tree);\n void gimple_cond_set_condition_from_tree (gimple, tree);\n bool gimple_has_side_effects (const_gimple);\n@@ -844,48 +839,6 @@ bool empty_body_p (gimple_seq);\n unsigned get_gimple_rhs_num_ops (enum tree_code);\n #define gimple_alloc(c, n) gimple_alloc_stat (c, n MEM_STAT_INFO)\n gimple gimple_alloc_stat (enum gimple_code, unsigned MEM_STAT_DECL);\n-const char *gimple_decl_printable_name (tree, int);\n-\n-/* Returns true iff T is a virtual ssa name decl.  */\n-extern bool virtual_operand_p (tree);\n-/* Returns true iff T is a scalar register variable.  */\n-extern bool is_gimple_reg (tree);\n-/* Returns true iff T is any sort of variable.  */\n-extern bool is_gimple_variable (tree);\n-/* Returns true iff T is any sort of symbol.  */\n-extern bool is_gimple_id (tree);\n-/* Returns true iff T is a variable or an INDIRECT_REF (of a variable).  */\n-extern bool is_gimple_min_lval (tree);\n-/* Returns true iff T is something whose address can be taken.  */\n-extern bool is_gimple_addressable (tree);\n-/* Returns true iff T is any valid GIMPLE lvalue.  */\n-extern bool is_gimple_lvalue (tree);\n-\n-/* Returns true iff T is a GIMPLE address.  */\n-bool is_gimple_address (const_tree);\n-/* Returns true iff T is a GIMPLE invariant address.  */\n-bool is_gimple_invariant_address (const_tree);\n-/* Returns true iff T is a GIMPLE invariant address at interprocedural\n-   level.  */\n-bool is_gimple_ip_invariant_address (const_tree);\n-/* Returns true iff T is a valid GIMPLE constant.  */\n-bool is_gimple_constant (const_tree);\n-/* Returns true iff T is a GIMPLE restricted function invariant.  */\n-extern bool is_gimple_min_invariant (const_tree);\n-/* Returns true iff T is a GIMPLE restricted interprecodural invariant.  */\n-extern bool is_gimple_ip_invariant (const_tree);\n-/* Returns true iff T is a GIMPLE rvalue.  */\n-extern bool is_gimple_val (tree);\n-/* Returns true iff T is a GIMPLE asm statement input.  */\n-extern bool is_gimple_asm_val (tree);\n-/* Returns true iff T is a valid address operand of a MEM_REF.  */\n-bool is_gimple_mem_ref_addr (tree);\n-\n-/* Returns true iff T is a valid if-statement condition.  */\n-extern bool is_gimple_condexpr (tree);\n-\n-/* Returns true iff T is a valid call address expression.  */\n-extern bool is_gimple_call_addr (tree);\n \n /* Return TRUE iff stmt is a call to a built-in function.  */\n extern bool is_gimple_builtin_call (gimple stmt);\n@@ -906,8 +859,6 @@ extern bool gimple_ior_addresses_taken (bitmap, gimple);\n extern bool gimple_call_builtin_p (gimple, enum built_in_class);\n extern bool gimple_call_builtin_p (gimple, enum built_in_function);\n extern bool gimple_asm_clobbers_memory_p (const_gimple);\n-extern bool useless_type_conversion_p (tree, tree);\n-extern bool types_compatible_p (tree, tree);\n \n /* In gimplify.c  */\n extern tree create_tmp_var_raw (tree, const char *);\n@@ -1086,9 +1037,7 @@ extern tree gimple_boolify (tree);\n extern gimple_predicate rhs_predicate_for (tree);\n extern tree canonicalize_cond_expr_cond (tree);\n extern void dump_decl_set (FILE *, bitmap);\n-extern bool gimple_can_coalesce_p (tree, tree);\n extern bool nonfreeing_call_p (gimple);\n-extern tree copy_var_decl (tree, tree, tree);\n \n /* In trans-mem.c.  */\n extern void diagnose_tm_safe_errors (tree);\n@@ -2042,18 +1991,6 @@ gimple_assign_set_rhs_with_ops (gimple_stmt_iterator *gsi, enum tree_code code,\n   gimple_assign_set_rhs_with_ops_1 (gsi, code, op1, op2, NULL);\n }\n \n-/* A wrapper around extract_ops_from_tree_1, for callers which expect\n-   to see only a maximum of two operands.  */\n-\n-static inline void\n-extract_ops_from_tree (tree expr, enum tree_code *code, tree *op0,\n-\t\t       tree *op1)\n-{\n-  tree op2;\n-  extract_ops_from_tree_1 (expr, code, op0, op1, &op2);\n-  gcc_assert (op2 == NULL_TREE);\n-}\n-\n /* Returns true if GS is a nontemporal move.  */\n \n static inline bool\n@@ -2316,25 +2253,6 @@ gimple_call_set_internal_fn (gimple gs, enum internal_fn fn)\n }\n \n \n-/* Given a valid GIMPLE_CALL function address return the FUNCTION_DECL\n-   associated with the callee if known.  Otherwise return NULL_TREE.  */\n-\n-static inline tree\n-gimple_call_addr_fndecl (const_tree fn)\n-{\n-  if (fn && TREE_CODE (fn) == ADDR_EXPR)\n-    {\n-      tree fndecl = TREE_OPERAND (fn, 0);\n-      if (TREE_CODE (fndecl) == MEM_REF\n-\t  && TREE_CODE (TREE_OPERAND (fndecl, 0)) == ADDR_EXPR\n-\t  && integer_zerop (TREE_OPERAND (fndecl, 1)))\n-\tfndecl = TREE_OPERAND (TREE_OPERAND (fndecl, 0), 0);\n-      if (TREE_CODE (fndecl) == FUNCTION_DECL)\n-\treturn fndecl;\n-    }\n-  return NULL_TREE;\n-}\n-\n /* If a given GIMPLE_CALL's callee is a FUNCTION_DECL, return it.\n    Otherwise return NULL.  This function is analogous to\n    get_callee_fndecl in tree land.  */\n@@ -5385,14 +5303,6 @@ gimple_expr_type (const_gimple stmt)\n     return void_type_node;\n }\n \n-/* Return true if TYPE is a suitable type for a scalar register variable.  */\n-\n-static inline bool\n-is_gimple_reg_type (tree type)\n-{\n-  return !AGGREGATE_TYPE_P (type);\n-}\n-\n /* Return a new iterator pointing to GIMPLE_SEQ's first statement.  */\n \n static inline gimple_stmt_iterator"}]}