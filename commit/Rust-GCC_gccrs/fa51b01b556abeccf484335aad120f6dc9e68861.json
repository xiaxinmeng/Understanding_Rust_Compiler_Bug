{"sha": "fa51b01b556abeccf484335aad120f6dc9e68861", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmE1MWIwMWI1NTZhYmVjY2Y0ODQzMzVhYWQxMjBmNmRjOWU2ODg2MQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-09-16T01:12:25Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-09-16T01:12:25Z"}, "message": "emit-rtl.c (free_emit_status): Don't check DECL_DEFER_OUTPUT.\n\n        * emit-rtl.c (free_emit_status): Don't check DECL_DEFER_OUTPUT.\n        Free the struct.\n        (mark_emit_status): Renamed from mark_emit_state.\n        * except.c (mark_eh_status): Renamed from mark_eh_state.\n        Check not null before marking.\n        (free_eh_status): New.\n        * expr.c (mark_expr_status, free_expr_status): New.\n        * function.c (free_machine_status): New.\n        (free_after_parsing): New.\n        (free_after_compilation): Move bits to free_after_parsing; call\n        free_eh_status, free_expr_status; zero the marked members of the\n        function state.\n        (prepare_function_start): No can_garbage_collect.\n        Call init_eh_for_function.\n        (expand_dummy_function_end): Free up current_function state.\n        (mark_function_status): Renamed from mark_function_state.\n        (mark_function_chain): No can_garbage_collect.  Call mark_expr_status.\n        * function.h (struct function): No can_garbage_collect.\n        (free_machine_status, free_after_parsing): Declare.\n        (free_eh_status, free_expr_status): Declare.\n        * ggc.h (mark_expr_status): Declare.\n        * stmt.c (free_stmt_status): Free the struct.\n        (mark_stmt_status): Renamed from mark_stmt_state.\n        (init_stmt): Don't call init_eh.\n        (init_stmt_for_function): Don't call init_eh_for_function.\n        * toplev.c (compile_file): Call init_eh.\n        (rest_of_compilation): Free basic block info before ggc_collect.\n        Call free_after_parsing; conditionally call free_after_compilation.\n        * varasm.c (mark_varasm_status): Renamed from mark_varasm_state.\n        Check not null before marking.\n\nFrom-SVN: r29448", "tree": {"sha": "0b720d86986661e0024880e115976d9fa928b8f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b720d86986661e0024880e115976d9fa928b8f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa51b01b556abeccf484335aad120f6dc9e68861", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa51b01b556abeccf484335aad120f6dc9e68861", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa51b01b556abeccf484335aad120f6dc9e68861", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa51b01b556abeccf484335aad120f6dc9e68861/comments", "author": null, "committer": null, "parents": [{"sha": "637194e69a20cab4a299af8c9706e67a6724f215", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/637194e69a20cab4a299af8c9706e67a6724f215", "html_url": "https://github.com/Rust-GCC/gccrs/commit/637194e69a20cab4a299af8c9706e67a6724f215"}], "stats": {"total": 222, "additions": 165, "deletions": 57}, "files": [{"sha": "63a9a6f120ab6aeeff84a64734ea2dc80922012e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa51b01b556abeccf484335aad120f6dc9e68861/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa51b01b556abeccf484335aad120f6dc9e68861/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fa51b01b556abeccf484335aad120f6dc9e68861", "patch": "@@ -1,3 +1,37 @@\n+Wed Sep 15 17:56:00 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* emit-rtl.c (free_emit_status): Don't check DECL_DEFER_OUTPUT.\n+\tFree the struct.\n+\t(mark_emit_status): Renamed from mark_emit_state.\n+\t* except.c (mark_eh_status): Renamed from mark_eh_state.\n+\tCheck not null before marking.\n+\t(free_eh_status): New.\n+\t* expr.c (mark_expr_status, free_expr_status): New.\n+\t* function.c (free_machine_status): New.\n+\t(free_after_parsing): New.\n+\t(free_after_compilation): Move bits to free_after_parsing; call\n+\tfree_eh_status, free_expr_status; zero the marked members of the\n+\tfunction state.\n+\t(prepare_function_start): No can_garbage_collect. \n+\tCall init_eh_for_function.\n+\t(expand_dummy_function_end): Free up current_function state.\n+\t(mark_function_status): Renamed from mark_function_state.\n+\t(mark_function_chain): No can_garbage_collect.  Call mark_expr_status.\n+\t* function.h (struct function): No can_garbage_collect.\n+\t(free_machine_status, free_after_parsing): Declare.\n+\t(free_eh_status, free_expr_status): Declare.\n+\t* ggc.h (mark_expr_status): Declare.\n+\t* stmt.c (free_stmt_status): Free the struct.\n+\t(mark_stmt_status): Renamed from mark_stmt_state.\n+\t(init_stmt): Don't call init_eh.\n+\t(init_stmt_for_function): Don't call init_eh_for_function.\n+\t* toplev.c (compile_file): Call init_eh.\n+\t(rest_of_compilation): Free basic block info before ggc_collect.\n+\tCall free_after_parsing; conditionally call free_after_compilation.\n+\t* varasm.c (mark_varasm_status): Renamed from mark_varasm_state.\n+\tCheck not null before marking.\n+\t(free_varasm_status): Don't check DECL_DEFER_OUTPUT.  Free the struct.\n+\n Wed Sep 15 17:53:16 1999  Richard Henderson  <rth@cygnus.com>\n \n \t* c-lex.c (yylex): Initialize warn."}, {"sha": "08f8c275398c42c0999d0f5e059635a572b91d21", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa51b01b556abeccf484335aad120f6dc9e68861/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa51b01b556abeccf484335aad120f6dc9e68861/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=fa51b01b556abeccf484335aad120f6dc9e68861", "patch": "@@ -1609,13 +1609,11 @@ void\n free_emit_status (f)\n      struct function *f;\n {\n-  if (DECL_DEFER_OUTPUT (f->decl))\n-    return;\n-\n   free (f->emit->x_regno_reg_rtx);\n   free (f->emit->regno_pointer_flag);\n   free (f->emit->regno_pointer_align);\n-  f->emit->x_regno_reg_rtx = 0;\n+  free (f->emit);\n+  f->emit = NULL;\n }\n \f\n /* Go through all the RTL insn bodies and copy any invalid shared structure.\n@@ -3486,7 +3484,7 @@ mark_sequence_stack (ss)\n /* Mark ES for GC.  */\n \n void\n-mark_emit_state (es)\n+mark_emit_status (es)\n      struct emit_status *es;\n {\n   rtx *r;"}, {"sha": "f063c9ab4acc063c17e55a3effd65f52b7e6e4f9", "filename": "gcc/except.c", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa51b01b556abeccf484335aad120f6dc9e68861/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa51b01b556abeccf484335aad120f6dc9e68861/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=fa51b01b556abeccf484335aad120f6dc9e68861", "patch": "@@ -2405,9 +2405,12 @@ mark_tree_label_node (node)\n /* Mark EH for GC.  */\n \n void\n-mark_eh_state (eh)\n+mark_eh_status (eh)\n      struct eh_status *eh;\n {\n+  if (eh == 0)\n+    return;\n+\n   mark_eh_stack (&eh->x_ehstack);\n   mark_eh_stack (&eh->x_catchstack);\n   mark_eh_queue (&eh->x_ehqueue);\n@@ -2479,7 +2482,8 @@ init_eh ()\n void\n init_eh_for_function ()\n {\n-  current_function->eh = (struct eh_status *) xmalloc (sizeof (struct eh_status));\n+  current_function->eh\n+    = (struct eh_status *) xmalloc (sizeof (struct eh_status));\n \n   ehstack.top = 0;\n   catchstack.top = 0;\n@@ -2494,6 +2498,14 @@ init_eh_for_function ()\n   eh_return_handler = NULL_RTX;\n   eh_return_stub_label = NULL_RTX;\n }\n+\n+void\n+free_eh_status (f)\n+     struct function *f;\n+{\n+  free (f->eh);\n+  f->eh = NULL;\n+}\n \f\n /* This section is for the exception handling specific optimization\n    pass.  First are the internal routines, and then the main"}, {"sha": "daa06d0e849eb996273f86e21163a261cf889e31", "filename": "gcc/expr.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa51b01b556abeccf484335aad120f6dc9e68861/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa51b01b556abeccf484335aad120f6dc9e68861/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=fa51b01b556abeccf484335aad120f6dc9e68861", "patch": "@@ -290,6 +290,26 @@ init_expr ()\n   forced_labels = 0;\n }\n \n+void\n+mark_expr_status (p)\n+     struct expr_status *p;\n+{\n+  if (p == NULL)\n+    return;\n+\n+  ggc_mark_rtx (p->x_saveregs_value);\n+  ggc_mark_rtx (p->x_apply_args_value);\n+  ggc_mark_rtx (p->x_forced_labels);\n+}\n+\n+void\n+free_expr_status (f)\n+     struct function *f;\n+{\n+  free (f->expr);\n+  f->expr = NULL;\n+}\n+\n /* Small sanity check that the queue is empty at the end of a function.  */\n void\n finish_expr_for_function ()"}, {"sha": "a6c967995c0c789ad37b5a25f3b8a65e98bbd0e9", "filename": "gcc/function.c", "status": "modified", "additions": 66, "deletions": 23, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa51b01b556abeccf484335aad120f6dc9e68861/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa51b01b556abeccf484335aad120f6dc9e68861/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=fa51b01b556abeccf484335aad120f6dc9e68861", "patch": "@@ -122,6 +122,7 @@ void (*init_machine_status) PROTO((struct function *));\n void (*save_machine_status) PROTO((struct function *));\n void (*restore_machine_status) PROTO((struct function *));\n void (*mark_machine_status) PROTO((struct function *));\n+void (*free_machine_status) PROTO((struct function *));\n \n /* Likewise, but for language-specific data.  */\n void (*init_lang_status) PROTO((struct function *));\n@@ -276,7 +277,7 @@ static boolean insns_for_mem_comp PROTO ((hash_table_key, hash_table_key));\n static int insns_for_mem_walk   PROTO ((rtx *, void *));\n static void compute_insns_for_mem PROTO ((rtx, rtx, struct hash_table *));\n static void mark_temp_slot PROTO ((struct temp_slot *));\n-static void mark_function_state PROTO ((struct function *));\n+static void mark_function_status PROTO ((struct function *));\n static void mark_function_chain PROTO ((void *));\n \n \f\n@@ -389,6 +390,24 @@ pop_function_context ()\n   pop_function_context_from (current_function_decl);\n }\n \n+/* Clear out all parts of the state in F that can safely be discarded\n+   after the function has been parsed, but not compiled, to let\n+   garbage collection reclaim the memory.  */\n+\n+void\n+free_after_parsing (f)\n+     struct function *f;\n+{\n+  /* f->expr->forced_labels is used by code generation.  */\n+  /* f->emit->regno_reg_rtx is used by code generation.  */\n+  /* f->varasm is used by code generation.  */\n+  /* f->eh->eh_return_stub_label is used by code generation.  */\n+\n+  if (free_lang_status)\n+    (*free_lang_status) (f);\n+  free_stmt_status (f);\n+}\n+\n /* Clear out all parts of the state in F that can safely be discarded\n    after the function has been compiled, to let garbage collection\n    reclaim the memory.  */\n@@ -397,18 +416,44 @@ void\n free_after_compilation (f)\n      struct function *f;\n {\n+  free_eh_status (f);\n+  free_expr_status (f);\n   free_emit_status (f);\n   free_varasm_status (f);\n-  free_stmt_status (f);\n-  if (free_lang_status)\n-    (*free_lang_status) (f);\n \n-  if (!DECL_DEFER_OUTPUT (f->decl))\n-    {\n-      free (f->x_parm_reg_stack_loc);\n-      f->can_garbage_collect = 1;\n-    }\n+  if (free_machine_status)\n+    (*free_machine_status) (f);\n+\n+  free (f->x_parm_reg_stack_loc);\n+\n+  f->arg_offset_rtx = NULL;\n+  f->return_rtx = NULL;\n+  f->internal_arg_pointer = NULL;\n+  f->x_nonlocal_labels = NULL;\n+  f->x_nonlocal_goto_handler_slots = NULL;\n+  f->x_nonlocal_goto_handler_labels = NULL;\n+  f->x_nonlocal_goto_stack_level = NULL;\n+  f->x_cleanup_label = NULL;\n+  f->x_return_label = NULL;\n+  f->x_save_expr_regs = NULL;\n+  f->x_stack_slot_list = NULL;\n+  f->x_rtl_expr_chain = NULL;\n+  f->x_tail_recursion_label = NULL;\n+  f->x_tail_recursion_reentry = NULL;\n+  f->x_arg_pointer_save_area = NULL;\n+  f->x_context_display = NULL;\n+  f->x_trampoline_list = NULL;\n+  f->x_parm_birth_insn = NULL;\n+  f->x_last_parm_insn = NULL;\n+  f->x_parm_reg_stack_loc = NULL;\n+  f->x_temp_slots = NULL;\n+  f->fixup_var_refs_queue = NULL;\n+  f->original_arg_vector = NULL;\n+  f->original_decl_initial = NULL;\n+  f->inl_last_parm_insn = NULL;\n+  f->epilogue_delay_list = NULL;\n }\n+\n \f\n /* Allocate fixed slots in the stack frame of the current function.  */\n \n@@ -5495,9 +5540,9 @@ static void\n prepare_function_start ()\n {\n   current_function = (struct function *) xcalloc (1, sizeof (struct function));\n-  current_function->can_garbage_collect = 0;\n \n   init_stmt_for_function ();\n+  init_eh_for_function ();\n \n   cse_not_expected = ! optimize;\n \n@@ -5981,6 +6026,10 @@ expand_dummy_function_end ()\n \n   /* Outside function body, can't compute type's actual size\n      until next function's body starts.  */\n+\n+  free_after_parsing (current_function);\n+  free_after_compilation (current_function);\n+  free (current_function);\n   current_function = 0;\n }\n \n@@ -6664,7 +6713,7 @@ mark_temp_slot (t)\n /* Mark P for GC.  */\n \n static void\n-mark_function_state (p)\n+mark_function_status (p)\n      struct function *p;\n {\n   int i;\n@@ -6724,20 +6773,14 @@ mark_function_chain (arg)\n \n   for (; f; f = f->next_global)\n     {\n-      if (f->can_garbage_collect)\n-\tcontinue;\n-\n       ggc_mark_tree (f->decl);\n \n-      mark_function_state (f);\n-      mark_stmt_state (f->stmt);\n-      mark_eh_state (f->eh);\n-      mark_emit_state (f->emit);\n-      mark_varasm_state (f->varasm);\n-\n-      ggc_mark_rtx (f->expr->x_saveregs_value);\n-      ggc_mark_rtx (f->expr->x_apply_args_value);\n-      ggc_mark_rtx (f->expr->x_forced_labels);\n+      mark_function_status (f);\n+      mark_eh_status (f->eh);\n+      mark_stmt_status (f->stmt);\n+      mark_expr_status (f->expr);\n+      mark_emit_status (f->emit);\n+      mark_varasm_status (f->varasm);\n \n       if (mark_machine_status)\n \t(*mark_machine_status) (f);"}, {"sha": "0d70b7d6aed662f3ee65065ead1756958f5d082f", "filename": "gcc/function.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa51b01b556abeccf484335aad120f6dc9e68861/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa51b01b556abeccf484335aad120f6dc9e68861/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=fa51b01b556abeccf484335aad120f6dc9e68861", "patch": "@@ -184,9 +184,6 @@ struct function\n   struct emit_status *emit;\n   struct varasm_status *varasm;\n \n-  /* Nonzero if we are done compiling this function.  */\n-  int can_garbage_collect;\n-  \n   /* For function.c.  */\n \n   /* Name of this function.  */\n@@ -539,6 +536,7 @@ extern void (*init_machine_status)\tPROTO((struct function *));\n extern void (*mark_machine_status)\tPROTO((struct function *));\n extern void (*save_machine_status)\tPROTO((struct function *));\n extern void (*restore_machine_status)\tPROTO((struct function *));\n+extern void (*free_machine_status)\tPROTO((struct function *));\n \n /* Likewise, but for language-specific data.  */\n extern void (*init_lang_status)         PROTO((struct function *));\n@@ -551,12 +549,16 @@ extern void (*free_lang_status)         PROTO((struct function *));\n extern void save_tree_status\t\tPROTO((struct function *));\n extern void restore_tree_status\t\tPROTO((struct function *));\n extern void restore_emit_status\t\tPROTO((struct function *));\n+extern void free_after_parsing\t\tPROTO((struct function *));\n extern void free_after_compilation\tPROTO((struct function *));\n \n extern void init_varasm_status\t\tPROTO((struct function *));\n extern void free_varasm_status\t\tPROTO((struct function *));\n extern void free_emit_status\t\tPROTO((struct function *));\n extern void free_stmt_status            PROTO((struct function *));\n+extern void free_eh_status\t\tPROTO((struct function *));\n+extern void free_expr_status\t\tPROTO((struct function *));\n+\n extern rtx get_first_block_beg\t\tPROTO((void));\n \n extern void init_virtual_regs\t\tPROTO((struct emit_status *));"}, {"sha": "20b3bb8771dd128f62dc2c2ef9a741e8db55de40", "filename": "gcc/ggc.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa51b01b556abeccf484335aad120f6dc9e68861/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa51b01b556abeccf484335aad120f6dc9e68861/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=fa51b01b556abeccf484335aad120f6dc9e68861", "patch": "@@ -33,6 +33,7 @@ extern int ggc_p;\n    just forward-declare them here.  */\n struct eh_status;\n struct emit_status;\n+struct expr_status;\n struct hash_table;\n struct label_node;\n struct rtvec_def;\n@@ -121,8 +122,9 @@ void lang_mark_false_label_stack PROTO ((struct label_node *));\n \n /* Mark functions for various structs scattered about.  */\n \n-void mark_eh_state PROTO ((struct eh_status *));\n-void mark_stmt_state PROTO ((struct stmt_status *));\n-void mark_emit_state PROTO ((struct emit_status *));\n-void mark_varasm_state PROTO ((struct varasm_status *));\n+void mark_eh_status PROTO ((struct eh_status *));\n+void mark_emit_status PROTO ((struct emit_status *));\n+void mark_expr_status PROTO ((struct expr_status *));\n+void mark_stmt_status PROTO ((struct stmt_status *));\n+void mark_varasm_status PROTO ((struct varasm_status *));\n void mark_optab PROTO ((void *));"}, {"sha": "fcfdb06e4d2daf61f1197f9d739968b028675f23", "filename": "gcc/stmt.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa51b01b556abeccf484335aad120f6dc9e68861/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa51b01b556abeccf484335aad120f6dc9e68861/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=fa51b01b556abeccf484335aad120f6dc9e68861", "patch": "@@ -561,13 +561,15 @@ free_stmt_status (f)\n   /* We're about to free the function obstack.  If we hold pointers to\n      things allocated there, then we'll try to mark them when we do\n      GC.  So, we clear them out here explicitly.  */\n-  f->stmt->x_goto_fixup_chain = 0;\n+\n+  free (f->stmt);\n+  f->stmt = NULL;\n }\n \n /* Mark P for GC.  */\n \n void\n-mark_stmt_state (p)\n+mark_stmt_status (p)\n      struct stmt_status *p;\n {\n   if (p == 0)\n@@ -590,7 +592,6 @@ void\n init_stmt ()\n {\n   gcc_obstack_init (&stmt_obstack);\n-  init_eh ();\n }\n \n void\n@@ -617,8 +618,6 @@ init_stmt_for_function ()\n   expr_stmts_for_value = 0;\n   last_expr_type = 0;\n   last_expr_value = NULL_RTX;\n-\n-  init_eh_for_function ();\n }\n \f\n /* Return nonzero if anything is pushed on the loop, condition, or case"}, {"sha": "aa3d62ed1d8547f7cd22b643b72e5c3ec642f7c9", "filename": "gcc/toplev.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa51b01b556abeccf484335aad120f6dc9e68861/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa51b01b556abeccf484335aad120f6dc9e68861/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=fa51b01b556abeccf484335aad120f6dc9e68861", "patch": "@@ -2862,6 +2862,7 @@ compile_file (name)\n   init_decl_processing ();\n   init_optabs ();\n   init_stmt ();\n+  init_eh ();\n   init_loop ();\n   init_reload ();\n   init_alias_once ();\n@@ -4425,6 +4426,8 @@ rest_of_compilation (decl)\n \n \t      /* Show no temporary slots allocated.  */\n \t      init_temp_slots ();\n+\n+\t      free_basic_block_vars (0);\n \t   });\n \n   /* Make sure volatile mem refs aren't considered valid operands for\n@@ -4439,8 +4442,9 @@ rest_of_compilation (decl)\n   init_recog_no_volatile ();\n \n   /* We're done with this function.  Free up memory if we can.  */\n-  free_after_compilation (current_function);\n-\n+  free_after_parsing (current_function);\n+  if (! DECL_DEFER_OUTPUT (decl))\n+    free_after_compilation (current_function);\n   current_function = 0;\n \n   if (ggc_p)\n@@ -4450,9 +4454,6 @@ rest_of_compilation (decl)\n      *except* what is spent in this function.  */\n \n   parse_time -= get_run_time () - start_time;\n-\n-  /* Reset global variables.  */\n-  free_basic_block_vars (0);\n }\n \f\n static void"}, {"sha": "cf56a09f3ad071978bd22df61f52d06bce880cdd", "filename": "gcc/varasm.c", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa51b01b556abeccf484335aad120f6dc9e68861/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa51b01b556abeccf484335aad120f6dc9e68861/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=fa51b01b556abeccf484335aad120f6dc9e68861", "patch": "@@ -3228,9 +3228,12 @@ mark_pool_sym_hash_table (pps)\n /* Mark P for GC.  */\n \n void\n-mark_varasm_state (p)\n-  struct varasm_status *p;\n+mark_varasm_status (p)\n+     struct varasm_status *p;\n {\n+  if (p == NULL)\n+    return;\n+\n   mark_pool_constant (p->x_first_pool);\n   mark_pool_sym_hash_table (p->x_const_rtx_sym_hash_table);\n   ggc_mark_rtx (p->x_const_double_chain);\n@@ -3246,17 +3249,11 @@ free_varasm_status (f)\n {\n   struct varasm_status *p;\n \n-  if (DECL_DEFER_OUTPUT (f->decl))\n-    return;\n-\n   p = f->varasm;\n   free (p->x_const_rtx_hash_table);\n   free (p->x_const_rtx_sym_hash_table);\n-\n-  p->x_first_pool = p->x_last_pool = 0;\n-  p->x_const_rtx_hash_table = 0;\n-  p->x_const_rtx_sym_hash_table = 0;\n-  p->x_const_double_chain = 0;\n+  free (p);\n+  f->varasm = NULL;\n }\n \f\n enum kind { RTX_DOUBLE, RTX_INT };"}]}