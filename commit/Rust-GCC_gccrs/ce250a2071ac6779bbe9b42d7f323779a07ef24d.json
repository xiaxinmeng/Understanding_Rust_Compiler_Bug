{"sha": "ce250a2071ac6779bbe9b42d7f323779a07ef24d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2UyNTBhMjA3MWFjNjc3OWJiZTliNDJkN2YzMjM3NzlhMDdlZjI0ZA==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2003-05-12T13:14:32Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2003-05-12T13:14:32Z"}, "message": "lib1funcs.asm (LSYM): Define -- on ELF prefix a local symbol with '.'.\n\n* arm/lib1funcs.asm (LSYM): Define -- on ELF prefix a local symbol with\n'.'.  Change all local symbol definitions and references to use LSYM.\n\nFrom-SVN: r66715", "tree": {"sha": "724405ef39fede9c9a317bb747dc0b303b6e7dd6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/724405ef39fede9c9a317bb747dc0b303b6e7dd6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce250a2071ac6779bbe9b42d7f323779a07ef24d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce250a2071ac6779bbe9b42d7f323779a07ef24d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce250a2071ac6779bbe9b42d7f323779a07ef24d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce250a2071ac6779bbe9b42d7f323779a07ef24d/comments", "author": null, "committer": null, "parents": [{"sha": "c349b2a468b9fbaef292b4c5dfac73cf866ad0d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c349b2a468b9fbaef292b4c5dfac73cf866ad0d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c349b2a468b9fbaef292b4c5dfac73cf866ad0d6"}], "stats": {"total": 169, "additions": 88, "deletions": 81}, "files": [{"sha": "4eacd0320f606a736f1e6dc645a4b1dd4f98b0f7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce250a2071ac6779bbe9b42d7f323779a07ef24d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce250a2071ac6779bbe9b42d7f323779a07ef24d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ce250a2071ac6779bbe9b42d7f323779a07ef24d", "patch": "@@ -1,3 +1,8 @@\n+2003-05-12  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* arm/lib1funcs.asm (LSYM): Define -- on ELF prefix a local symbol with\n+\t'.'.  Change all local symbol definitions and references to use LSYM.\n+\n Mon May 12 11:32:53 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \n \t* expr.h (assemble_static_space): Update prototype."}, {"sha": "5d286517aef41a084376d972aee053340ac65a81", "filename": "gcc/config/arm/lib1funcs.asm", "status": "modified", "additions": 83, "deletions": 81, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce250a2071ac6779bbe9b42d7f323779a07ef24d/gcc%2Fconfig%2Farm%2Flib1funcs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce250a2071ac6779bbe9b42d7f323779a07ef24d/gcc%2Fconfig%2Farm%2Flib1funcs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Flib1funcs.asm?ref=ce250a2071ac6779bbe9b42d7f323779a07ef24d", "patch": "@@ -51,10 +51,12 @@ Boston, MA 02111-1307, USA.  */\n #endif\n #define TYPE(x) .type SYM(x),function\n #define SIZE(x) .size SYM(x), . - SYM(x)\n+#define LSYM(x) .x\n #else\n #define __PLT__\n #define TYPE(x)\n #define SIZE(x)\n+#define LSYM(x) x\n #endif\n \n /* Function end macros.  Variants for 26 bit APCS and interworking.  */\n@@ -64,7 +66,7 @@ Boston, MA 02111-1307, USA.  */\n # define RETc(x)\tmov##x##s\tpc, lr\n # define RETCOND \t^\n .macro ARM_LDIV0\n-Ldiv0:\n+LSYM(Ldiv0):\n \tstr\tlr, [sp, #-4]!\n \tbl\tSYM (__div0) __PLT__\n \tmov\tr0, #0\t\t\t@ About as wrong as it could be.\n@@ -75,15 +77,15 @@ Ldiv0:\n #  define RET\t\tbx\tlr\n #  define RETc(x)\tbx##x\tlr\n .macro THUMB_LDIV0\n-Ldiv0:\n+LSYM(Ldiv0):\n \tpush\t{ lr }\n \tbl\tSYM (__div0)\n \tmov\tr0, #0\t\t\t@ About as wrong as it could be.\n \tpop\t{ r1 }\n \tbx\tr1\n .endm\n .macro ARM_LDIV0\n-Ldiv0:\n+LSYM(Ldiv0):\n \tstr\tlr, [sp, #-4]!\n \tbl\tSYM (__div0) __PLT__\n \tmov\tr0, #0\t\t\t@ About as wrong as it could be.\n@@ -94,14 +96,14 @@ Ldiv0:\n #  define RET\t\tmov\tpc, lr\n #  define RETc(x)\tmov##x\tpc, lr\n .macro THUMB_LDIV0\n-Ldiv0:\n+LSYM(Ldiv0):\n \tpush\t{ lr }\n \tbl\tSYM (__div0)\n \tmov\tr0, #0\t\t\t@ About as wrong as it could be.\n \tpop\t{ pc }\n .endm\n .macro ARM_LDIV0\n-Ldiv0:\n+LSYM(Ldiv0):\n \tstr\tlr, [sp, #-4]!\n \tbl\tSYM (__div0) __PLT__\n \tmov\tr0, #0\t\t\t@ About as wrong as it could be.\n@@ -112,7 +114,7 @@ Ldiv0:\n #endif\n \n .macro FUNC_END name\n-Ldiv0:\n+LSYM(Ldiv0):\n #ifdef __thumb__\n \tTHUMB_LDIV0\n #else\n@@ -165,7 +167,7 @@ pc\t\t.req\tr15\n /*\t\tBodies of the divsion and modulo routines.\t\t    */\n /* ------------------------------------------------------------------------ */\t\n .macro ARM_DIV_MOD_BODY modulo\n-Loop1:\n+LSYM(Loop1):\n \t@ Unless the divisor is very big, shift it up in multiples of\n \t@ four bits, since this is the amount of unwinding in the main\n \t@ division loop.  Continue shifting until the divisor is \n@@ -174,18 +176,18 @@ Loop1:\n \tcmplo\tdivisor, dividend\n \tmovlo\tdivisor, divisor, lsl #4\n \tmovlo\tcurbit,  curbit,  lsl #4\n-\tblo\tLoop1\n+\tblo\tLSYM(Loop1)\n \n-Lbignum:\n+LSYM(Lbignum):\n \t@ For very big divisors, we must shift it a bit at a time, or\n \t@ we will be in danger of overflowing.\n \tcmp\tdivisor, #0x80000000\n \tcmplo\tdivisor, dividend\n \tmovlo\tdivisor, divisor, lsl #1\n \tmovlo\tcurbit,  curbit,  lsl #1\n-\tblo\tLbignum\n+\tblo\tLSYM(Lbignum)\n \n-Loop3:\n+LSYM(Loop3):\n \t@ Test for possible subtractions.  On the final pass, this may \n \t@ subtract too much from the dividend ...\n \t\n@@ -226,10 +228,10 @@ Loop3:\n \tcmp\tdividend, #0\t\t\t@ Early termination?\n \tmovnes\tcurbit,   curbit,  lsr #4\t@ No, any more bits to do?\n \tmovne\tdivisor,  divisor, lsr #4\n-\tbne\tLoop3\n+\tbne\tLSYM(Loop3)\n \n   .if \\modulo\n-Lfixup_dividend:\t\n+LSYM(Lfixup_dividend):\t\n \t@ Any subtractions that we should not have done will be recorded in\n \t@ the top three bits of OVERDONE.  Exactly which were not needed\n \t@ are governed by the position of the bit, stored in IP.\n@@ -241,7 +243,7 @@ Lfixup_dividend:\n \t@ the bit in ip could be in the top two bits which might then match\n \t@ with one of the smaller RORs.\n \ttstne\tip, #0x7\n-\tbeq\tLgot_result\n+\tbeq\tLSYM(Lgot_result)\n \ttst\toverdone, ip, ror #3\n \taddne\tdividend, dividend, divisor, lsr #3\n \ttst\toverdone, ip, ror #2\n@@ -250,127 +252,127 @@ Lfixup_dividend:\n \taddne\tdividend, dividend, divisor, lsr #1\n   .endif\n \n-Lgot_result:\n+LSYM(Lgot_result):\n .endm\n /* ------------------------------------------------------------------------ */\n .macro THUMB_DIV_MOD_BODY modulo\n \t@ Load the constant 0x10000000 into our work register.\n \tmov\twork, #1\n \tlsl\twork, #28\n-Loop1:\n+LSYM(Loop1):\n \t@ Unless the divisor is very big, shift it up in multiples of\n \t@ four bits, since this is the amount of unwinding in the main\n \t@ division loop.  Continue shifting until the divisor is \n \t@ larger than the dividend.\n \tcmp\tdivisor, work\n-\tbhs\tLbignum\n+\tbhs\tLSYM(Lbignum)\n \tcmp\tdivisor, dividend\n-\tbhs\tLbignum\n+\tbhs\tLSYM(Lbignum)\n \tlsl\tdivisor, #4\n \tlsl\tcurbit,  #4\n-\tb\tLoop1\n-Lbignum:\n+\tb\tLSYM(Loop1)\n+LSYM(Lbignum):\n \t@ Set work to 0x80000000\n \tlsl\twork, #3\n-Loop2:\n+LSYM(Loop2):\n \t@ For very big divisors, we must shift it a bit at a time, or\n \t@ we will be in danger of overflowing.\n \tcmp\tdivisor, work\n-\tbhs\tLoop3\n+\tbhs\tLSYM(Loop3)\n \tcmp\tdivisor, dividend\n-\tbhs\tLoop3\n+\tbhs\tLSYM(Loop3)\n \tlsl\tdivisor, #1\n \tlsl\tcurbit,  #1\n-\tb\tLoop2\n-Loop3:\n+\tb\tLSYM(Loop2)\n+LSYM(Loop3):\n \t@ Test for possible subtractions ...\n   .if \\modulo\n \t@ ... On the final pass, this may subtract too much from the dividend, \n \t@ so keep track of which subtractions are done, we can fix them up \n \t@ afterwards.\n \tmov\toverdone, #0\n \tcmp\tdividend, divisor\n-\tblo\tLover1\n+\tblo\tLSYM(Lover1)\n \tsub\tdividend, dividend, divisor\n-Lover1:\n+LSYM(Lover1):\n \tlsr\twork, divisor, #1\n \tcmp\tdividend, work\n-\tblo\tLover2\n+\tblo\tLSYM(Lover2)\n \tsub\tdividend, dividend, work\n \tmov\tip, curbit\n \tmov\twork, #1\n \tror\tcurbit, work\n \torr\toverdone, curbit\n \tmov\tcurbit, ip\n-Lover2:\n+LSYM(Lover2):\n \tlsr\twork, divisor, #2\n \tcmp\tdividend, work\n-\tblo\tLover3\n+\tblo\tLSYM(Lover3)\n \tsub\tdividend, dividend, work\n \tmov\tip, curbit\n \tmov\twork, #2\n \tror\tcurbit, work\n \torr\toverdone, curbit\n \tmov\tcurbit, ip\n-Lover3:\n+LSYM(Lover3):\n \tlsr\twork, divisor, #3\n \tcmp\tdividend, work\n-\tblo\tLover4\n+\tblo\tLSYM(Lover4)\n \tsub\tdividend, dividend, work\n \tmov\tip, curbit\n \tmov\twork, #3\n \tror\tcurbit, work\n \torr\toverdone, curbit\n \tmov\tcurbit, ip\n-Lover4:\n+LSYM(Lover4):\n \tmov\tip, curbit\n   .else\n \t@ ... and note which bits are done in the result.  On the final pass,\n \t@ this may subtract too much from the dividend, but the result will be ok,\n \t@ since the \"bit\" will have been shifted out at the bottom.\n \tcmp\tdividend, divisor\n-\tblo\tLover1\n+\tblo\tLSYM(Lover1)\n \tsub\tdividend, dividend, divisor\n \torr\tresult, result, curbit\n-Lover1:\n+LSM(Lover1):\n \tlsr\twork, divisor, #1\n \tcmp\tdividend, work\n-\tblo\tLover2\n+\tblo\tLSYM(Lover2)\n \tsub\tdividend, dividend, work\n \tlsr\twork, curbit, #1\n \torr\tresult, work\n-Lover2:\n+LSYM(Lover2):\n \tlsr\twork, divisor, #2\n \tcmp\tdividend, work\n-\tblo\tLover3\n+\tblo\tLSYM(Lover3)\n \tsub\tdividend, dividend, work\n \tlsr\twork, curbit, #2\n \torr\tresult, work\n-Lover3:\n+LSYM(Lover3):\n \tlsr\twork, divisor, #3\n \tcmp\tdividend, work\n-\tblo\tLover4\n+\tblo\tLSYM(Lover4)\n \tsub\tdividend, dividend, work\n \tlsr\twork, curbit, #3\n \torr\tresult, work\n-Lover4:\n+LSYM(Lover4):\n   .endif\n \t\n \tcmp\tdividend, #0\t\t\t@ Early termination?\n-\tbeq\tLover5\n+\tbeq\tLSYM(Lover5)\n \tlsr\tcurbit,  #4\t\t\t@ No, any more bits to do?\n-\tbeq\tLover5\n+\tbeq\tLSYM(Lover5)\n \tlsr\tdivisor, #4\n-\tb\tLoop3\n-Lover5:\n+\tb\tLSYM(Loop3)\n+LSYM(Lover5):\n   .if \\modulo\n \t@ Any subtractions that we should not have done will be recorded in\n \t@ the top three bits of \"overdone\".  Exactly which were not needed\n \t@ are governed by the position of the bit, stored in ip.\n \tmov\twork, #0xe\n \tlsl\twork, #28\n \tand\toverdone, work\n-\tbeq\tLgot_result\n+\tbeq\tLSYM(Lgot_result)\n \t\n \t@ If we terminated early, because dividend became zero, then the \n \t@ bit in ip will not be in the bottom nibble, and we should not\n@@ -381,33 +383,33 @@ Lover5:\n \tmov\tcurbit, ip\n \tmov\twork, #0x7\n \ttst\tcurbit, work\n-\tbeq\tLgot_result\n+\tbeq\tLSYM(Lgot_result)\n \t\n \tmov\tcurbit, ip\n \tmov\twork, #3\n \tror\tcurbit, work\n \ttst\toverdone, curbit\n-\tbeq\tLover6\n+\tbeq\tLSYM(Lover6)\n \tlsr\twork, divisor, #3\n \tadd\tdividend, work\n-Lover6:\n+LSYM(Lover6):\n \tmov\tcurbit, ip\n \tmov\twork, #2\n \tror\tcurbit, work\n \ttst\toverdone, curbit\n-\tbeq\tLover7\n+\tbeq\tLSYM(Lover7)\n \tlsr\twork, divisor, #2\n \tadd\tdividend, work\n-Lover7:\n+LSYM(Lover7):\n \tmov\tcurbit, ip\n \tmov\twork, #1\n \tror\tcurbit, work\n \ttst\toverdone, curbit\n-\tbeq\tLgot_result\n+\tbeq\tLSYM(Lgot_result)\n \tlsr\twork, divisor, #1\n \tadd\tdividend, work\n   .endif\n-Lgot_result:\n+LSYM(Lgot_result):\n .endm\t\n /* ------------------------------------------------------------------------ */\n /*\t\tStart of the Real Functions\t\t\t\t    */\n@@ -419,13 +421,13 @@ Lgot_result:\n #ifdef __thumb__\n \n \tcmp\tdivisor, #0\n-\tbeq\tLdiv0\n+\tbeq\tLSYM(Ldiv0)\n \tmov\tcurbit, #1\n \tmov\tresult, #0\n \t\n \tpush\t{ work }\n \tcmp\tdividend, divisor\n-\tblo\tLgot_result\n+\tblo\tLSYM(Lgot_result)\n \n \tTHUMB_DIV_MOD_BODY 0\n \t\n@@ -436,11 +438,11 @@ Lgot_result:\n #else /* ARM version.  */\n \t\n \tcmp\tdivisor, #0\n-\tbeq\tLdiv0\n+\tbeq\tLSYM(Ldiv0)\n \tmov\tcurbit, #1\n \tmov\tresult, #0\n \tcmp\tdividend, divisor\n-\tblo\tLgot_result\n+\tblo\tLSYM(Lgot_result)\n \t\n \tARM_DIV_MOD_BODY 0\n \t\n@@ -460,13 +462,13 @@ Lgot_result:\n #ifdef __thumb__\n \n \tcmp\tdivisor, #0\n-\tbeq\tLdiv0\n+\tbeq\tLSYM(Ldiv0)\n \tmov\tcurbit, #1\n \tcmp\tdividend, divisor\n-\tbhs\tLover10\n+\tbhs\tLSYM(Lover10)\n \tRET\t\n \n-Lover10:\n+LSYM(Lover10):\n \tpush\t{ work }\n \n \tTHUMB_DIV_MOD_BODY 1\n@@ -477,7 +479,7 @@ Lover10:\n #else  /* ARM version.  */\n \t\n \tcmp\tdivisor, #0\n-\tbeq\tLdiv0\n+\tbeq\tLSYM(Ldiv0)\n \tcmp     divisor, #1\n \tcmpne\tdividend, divisor\n \tmoveq   dividend, #0\n@@ -500,7 +502,7 @@ Lover10:\n \n #ifdef __thumb__\n \tcmp\tdivisor, #0\n-\tbeq\tLdiv0\n+\tbeq\tLSYM(Ldiv0)\n \t\n \tpush\t{ work }\n \tmov\twork, dividend\n@@ -509,24 +511,24 @@ Lover10:\n \tmov\tcurbit, #1\n \tmov\tresult, #0\n \tcmp\tdivisor, #0\n-\tbpl\tLover10\n+\tbpl\tLSYM(Lover10)\n \tneg\tdivisor, divisor\t@ Loops below use unsigned.\n-Lover10:\n+LSYM(Lover10):\n \tcmp\tdividend, #0\n-\tbpl\tLover11\n+\tbpl\tLSYM(Lover11)\n \tneg\tdividend, dividend\n-Lover11:\n+LSYM(Lover11):\n \tcmp\tdividend, divisor\n-\tblo\tLgot_result\n+\tblo\tLSYM(Lgot_result)\n \n \tTHUMB_DIV_MOD_BODY 0\n \t\n \tmov\tr0, result\n \tmov\twork, ip\n \tcmp\twork, #0\n-\tbpl\tLover12\n+\tbpl\tLSYM(Lover12)\n \tneg\tr0, r0\n-Lover12:\n+LSYM(Lover12):\n \tpop\t{ work }\n \tRET\n \n@@ -537,11 +539,11 @@ Lover12:\n \tmov\tresult, #0\n \tcmp\tdivisor, #0\n \trsbmi\tdivisor, divisor, #0\t\t@ Loops below use unsigned.\n-\tbeq\tLdiv0\n+\tbeq\tLSYM(Ldiv0)\n \tcmp\tdividend, #0\n \trsbmi\tdividend, dividend, #0\n \tcmp\tdividend, divisor\n-\tblo\tLgot_result\n+\tblo\tLSYM(Lgot_result)\n \n \tARM_DIV_MOD_BODY 0\n \t\n@@ -564,44 +566,44 @@ Lover12:\n \n \tmov\tcurbit, #1\n \tcmp\tdivisor, #0\n-\tbeq\tLdiv0\n-\tbpl\tLover10\n+\tbeq\tLSYM(Ldiv0)\n+\tbpl\tLSYM(Lover10)\n \tneg\tdivisor, divisor\t\t@ Loops below use unsigned.\n-Lover10:\n+LSYM(Lover10):\n \tpush\t{ work }\n \t@ Need to save the sign of the dividend, unfortunately, we need\n \t@ work later on.  Must do this after saving the original value of\n \t@ the work register, because we will pop this value off first.\n \tpush\t{ dividend }\n \tcmp\tdividend, #0\n-\tbpl\tLover11\n+\tbpl\tLSYM(Lover11)\n \tneg\tdividend, dividend\n-Lover11:\n+LSYM(Lover11):\n \tcmp\tdividend, divisor\n-\tblo\tLgot_result\n+\tblo\tLSYM(Lgot_result)\n \n \tTHUMB_DIV_MOD_BODY 1\n \t\t\n \tpop\t{ work }\n \tcmp\twork, #0\n-\tbpl\tLover12\n+\tbpl\tLSYM(Lover12)\n \tneg\tdividend, dividend\n-Lover12:\n+LSYM(Lover12):\n \tpop\t{ work }\n \tRET\t\n \n #else /* ARM version.  */\n \t\n \tcmp\tdivisor, #0\n \trsbmi\tdivisor, divisor, #0\t\t@ Loops below use unsigned.\n-\tbeq\tLdiv0\n+\tbeq\tLSYM(Ldiv0)\n \t@ Need to save the sign of the dividend, unfortunately, we need\n \t@ ip later on; this is faster than pushing lr and using that.\n \tstr\tdividend, [sp, #-4]!\n \tcmp\tdividend, #0\t\t\t@ Test dividend against zero\n \trsbmi\tdividend, dividend, #0\t\t@ If negative make positive\n \tcmp\tdividend, divisor\t\t@ else if zero return zero\n-\tblo\tLgot_result\t\t\t@ if smaller return dividend\n+\tblo\tLSYM(Lgot_result)\t\t@ if smaller return dividend\n \tmov\tcurbit, #1\n \n \tARM_DIV_MOD_BODY 1"}]}