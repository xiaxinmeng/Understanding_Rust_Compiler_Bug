{"sha": "be39636d9f68c437c8a2c2e7a225c4aed4663e78", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmUzOTYzNmQ5ZjY4YzQzN2M4YTJjMmU3YTIyNWM0YWVkNDY2M2U3OA==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2020-11-16T23:55:29Z"}, "committer": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2020-11-16T23:56:45Z"}, "message": "Improve code generation for x86_64 [PR 92180]\n\nThis patch catches a missed optimization opportunity where GCC currently\ngenerates worse code than LLVM.  The issue, as nicely analyzed in bugzilla,\nboils down to the following three insns in combine:\n\n(insn 6 5 7 2 (parallel [\n            (set (reg:DI 85)\n                (ashift:DI (reg:DI 85)\n                    (const_int 32 [0x20])))\n            (clobber (reg:CC 17 flags))\n        ]) \"pr92180.c\":4:10 564 {*ashldi3_1}\n     (expr_list:REG_UNUSED (reg:CC 17 flags)\n        (nil)))\n(insn 7 6 14 2 (parallel [\n            (set (reg:DI 84)\n                (ior:DI (reg:DI 84)\n                    (reg:DI 85)))\n            (clobber (reg:CC 17 flags))\n        ]) \"pr92180.c\":4:10 454 {*iordi_1}\n     (expr_list:REG_DEAD (reg:DI 85)\n        (expr_list:REG_UNUSED (reg:CC 17 flags)\n            (nil))))\n(insn 14 7 15 2 (set (reg/i:SI 0 ax)\n        (subreg:SI (reg:DI 84) 0)) \"pr92180.c\":5:1 67 {*movsi_internal}\n     (expr_list:REG_DEAD (reg:DI 84)\n        (nil)))\n\nNormally, combine/simplify-rtx would notice that insns 6 and 7\n(which update highpart bits) are unnecessary as the final insn 14\nonly requires to lowpart bits.  The complication is that insn 14\nsets a hard register in targetm.class_likely_spilled_p which\nprevents combine from performing its simplifications, and removing\nthe redundant instructions.\n\nAt first glance a fix would appear to require changes to combine,\npotentially affecting code generation on all small register class\ntargets...  An alternate (and I think clever) solution is to spot\nthat this problematic situation can be avoided by the backend.\n\nAt RTL expansion time, the middle-end has a clear separation between\npseudos and hard registers, so the RTL initially contains:\n\n(insn 9 8 10 2 (set (reg:SI 86)\n        (subreg:SI (reg:DI 82 [ _1 ]) 0)) \"pr92180.c\":6:10 -1\n     (nil))\n(insn 10 9 14 2 (set (reg:SI 83 [ <retval> ])\n        (reg:SI 86)) \"pr92180.c\":6:10 -1\n     (nil))\n(insn 14 10 15 2 (set (reg/i:SI 0 ax)\n        (reg:SI 83 [ <retval> ])) \"pr92180.c\":7:1 -1\n     (nil))\n\nwhich can be optimized without problems by combine; it is only the\nintervening passes (initially fwprop1) that propagate computations\ninto sets of hard registers, and disable those opportunities.\n\nThe solution proposed here is to have the x86 backend/recog prevent\nearly RTL passes composing instructions (that set likely_spilled hard\nregisters) that they (combine) can't simplify, until after reload.\nWe allow sets from pseudo registers, immediate constants and memory\naccesses, but anything more complicated is performed via a temporary\npseudo.  Not only does this simplify things for the register allocator,\nbut any remaining register-to-register moves are easily cleaned up\nby the late optimization passes after reload, such as peephole2 and\ncprop_hardreg.\n\nThis patch has been tested on x86_64-pc-linux-gnu with a\n\"make bootstrap\" and a \"make -k check\" with no new failures.\nOk for mainline?\n\ngcc\n\tPR rtl-optimization/92180\n\t* config/i386/i386.c (ix86_hardreg_mov_ok): New function to\n\tdetermine whether (set DST SRC) should be allowed at this point.\n\t* config/i386/i386-protos.h (ix86_hardreg_mov_ok): Prototype here.\n\t* config/i386/i386-expand.c (ix86_expand_move): Check whether\n\tthis is a complex set of a likely spilled hard register, and if\n\tso place the value in a pseudo, and load the hard reg from it.\n\t* config/i386/i386.md (*movdi_internal, *movsi_internal)\n\t(*movhi_internal, *movqi_internal): Make these instructions\n\tconditional on ix86_hardreg_mov_ok.\n\t(*lea<mode>): Make this define_insn_and_split conditional on\n\tix86_hardreg_mov_ok.\n\ngcc/testsuite\n\tPR rtl-optimization/92180\n\t* gcc.target/i386/pr92180.c: New test.", "tree": {"sha": "bfeeaf670c92a0c70dd4c13ff9043d47dbba093c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bfeeaf670c92a0c70dd4c13ff9043d47dbba093c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be39636d9f68c437c8a2c2e7a225c4aed4663e78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be39636d9f68c437c8a2c2e7a225c4aed4663e78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be39636d9f68c437c8a2c2e7a225c4aed4663e78", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be39636d9f68c437c8a2c2e7a225c4aed4663e78/comments", "author": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "814e016318646d06b1662219cc716d502b76d8ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/814e016318646d06b1662219cc716d502b76d8ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/814e016318646d06b1662219cc716d502b76d8ce"}], "stats": {"total": 53, "additions": 48, "deletions": 5}, "files": [{"sha": "044faf3423fa05c71b5bb892583c3e6c1b2fb8cb", "filename": "gcc/config/i386/i386-expand.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be39636d9f68c437c8a2c2e7a225c4aed4663e78/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be39636d9f68c437c8a2c2e7a225c4aed4663e78/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-expand.c?ref=be39636d9f68c437c8a2c2e7a225c4aed4663e78", "patch": "@@ -196,6 +196,17 @@ ix86_expand_move (machine_mode mode, rtx operands[])\n   op0 = operands[0];\n   op1 = operands[1];\n \n+  /* Avoid complex sets of likely spilled hard registers before reload.  */\n+  if (!ix86_hardreg_mov_ok (op0, op1))\n+    {\n+      tmp = gen_reg_rtx (mode);\n+      operands[0] = tmp;\n+      ix86_expand_move (mode, operands);\n+      operands[0] = op0;\n+      operands[1] = tmp;\n+      op1 = tmp;\n+    }\n+\n   switch (GET_CODE (op1))\n     {\n     case CONST:"}, {"sha": "a3d9f9eaf148b417fb894396f9e51fe182612f8a", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be39636d9f68c437c8a2c2e7a225c4aed4663e78/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be39636d9f68c437c8a2c2e7a225c4aed4663e78/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=be39636d9f68c437c8a2c2e7a225c4aed4663e78", "patch": "@@ -163,6 +163,7 @@ extern rtx ix86_find_base_term (rtx);\n extern bool ix86_check_movabs (rtx, int);\n extern bool ix86_check_no_addr_space (rtx);\n extern void ix86_split_idivmod (machine_mode, rtx[], bool);\n+extern bool ix86_hardreg_mov_ok (rtx, rtx);\n \n extern rtx assign_386_stack_local (machine_mode, enum ix86_stack_slot);\n extern int ix86_attr_length_immediate_default (rtx_insn *, bool);"}, {"sha": "c5db8c9712e1672f0984148040ddb008319ccb21", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be39636d9f68c437c8a2c2e7a225c4aed4663e78/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be39636d9f68c437c8a2c2e7a225c4aed4663e78/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=be39636d9f68c437c8a2c2e7a225c4aed4663e78", "patch": "@@ -18889,6 +18889,22 @@ ix86_class_likely_spilled_p (reg_class_t rclass)\n   return false;\n }\n \n+/* Return true if a set of DST by the expression SRC should be allowed.\n+   This prevents complex sets of likely_spilled hard regs before reload.  */\n+\n+bool\n+ix86_hardreg_mov_ok (rtx dst, rtx src)\n+{\n+  /* Avoid complex sets of likely_spilled hard registers before reload.  */\n+  if (REG_P (dst) && HARD_REGISTER_P (dst)\n+      && !REG_P (src) && !MEM_P (src)\n+      && !x86_64_immediate_operand (src, GET_MODE (dst))\n+      && ix86_class_likely_spilled_p (REGNO_REG_CLASS (REGNO (dst)))\n+      && !reload_completed)\n+    return false;\n+  return true;\n+}\n+\n /* If we are copying between registers from different register sets\n    (e.g. FP and integer), we may need a memory location.\n "}, {"sha": "52e306de00a40185ac79239b955ae5b4be93ac0b", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be39636d9f68c437c8a2c2e7a225c4aed4663e78/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be39636d9f68c437c8a2c2e7a225c4aed4663e78/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=be39636d9f68c437c8a2c2e7a225c4aed4663e78", "patch": "@@ -2089,7 +2089,8 @@\n     \"=r  ,o  ,r,r  ,r,m ,*y,*y,?*y,?m,?r,?*y,*v,*v,*v,m ,m,?r ,?*Yd,?r,?*v,?*y,?*x,*k,*k ,*r,*m,*k\")\n \t(match_operand:DI 1 \"general_operand\"\n     \"riFo,riF,Z,rem,i,re,C ,*y,m  ,*y,*y,r  ,C ,*v,m ,*v,v,*Yd,r   ,*v,r  ,*x ,*y ,*r,*km,*k,*k,CBC\"))]\n-  \"!(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n+  \"!(MEM_P (operands[0]) && MEM_P (operands[1]))\n+   && ix86_hardreg_mov_ok (operands[0], operands[1])\"\n {\n   switch (get_attr_type (insn))\n     {\n@@ -2309,7 +2310,8 @@\n     \"=r,m ,*y,*y,?*y,?m,?r,?*y,*v,*v,*v,m ,?r,?*v,*k,*k ,*rm,*k\")\n \t(match_operand:SI 1 \"general_operand\"\n     \"g ,re,C ,*y,m  ,*y,*y,r  ,C ,*v,m ,*v,*v,r  ,*r,*km,*k ,CBC\"))]\n-  \"!(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n+  \"!(MEM_P (operands[0]) && MEM_P (operands[1]))\n+   && ix86_hardreg_mov_ok (operands[0], operands[1])\"\n {\n   switch (get_attr_type (insn))\n     {\n@@ -2417,7 +2419,9 @@\n (define_insn \"*movhi_internal\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r ,r ,m ,*k,*k ,*r,*m,*k\")\n \t(match_operand:HI 1 \"general_operand\"      \"r ,rn,rm,rn,*r,*km,*k,*k,CBC\"))]\n-  \"!(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n+  \"!(MEM_P (operands[0]) && MEM_P (operands[1]))\n+   && ix86_hardreg_mov_ok (operands[0], operands[1])\"\n+\n {\n   switch (get_attr_type (insn))\n     {\n@@ -2506,7 +2510,9 @@\n \t\t\t\"=Q,R,r,q,q,r,r ,?r,m ,*k,*k,*r,*m,*k,*k,*k\")\n \t(match_operand:QI 1 \"general_operand\"\n \t\t\t\"Q ,R,r,n,m,q,rn, m,qn,*r,*k,*k,*k,*m,C,BC\"))]\n-  \"!(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n+  \"!(MEM_P (operands[0]) && MEM_P (operands[1]))\n+   && ix86_hardreg_mov_ok (operands[0], operands[1])\"\n+\n {\n   char buf[128];\n   const char *ops;\n@@ -5174,7 +5180,7 @@\n (define_insn_and_split \"*lea<mode>\"\n   [(set (match_operand:SWI48 0 \"register_operand\" \"=r\")\n \t(match_operand:SWI48 1 \"address_no_seg_operand\" \"Ts\"))]\n-  \"\"\n+  \"ix86_hardreg_mov_ok (operands[0], operands[1])\"\n {\n   if (SImode_address_operand (operands[1], VOIDmode))\n     {"}, {"sha": "177af74aa2fc167bfc63a96fa0a002b1d55e7852", "filename": "gcc/testsuite/gcc.target/i386/pr92180.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be39636d9f68c437c8a2c2e7a225c4aed4663e78/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr92180.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be39636d9f68c437c8a2c2e7a225c4aed4663e78/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr92180.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr92180.c?ref=be39636d9f68c437c8a2c2e7a225c4aed4663e78", "patch": "@@ -0,0 +1,9 @@\n+/* PR rtl-optimization/92180 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+unsigned int foo() {\n+  return __builtin_ia32_rdtsc();\n+}\n+\n+/* { dg-final { scan-assembler-not \"sal\" } } */"}]}