{"sha": "33bd39a26a88cbaabb2f85735c1ff1e51f2a7111", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzNiZDM5YTI2YTg4Y2JhYWJiMmY4NTczNWMxZmYxZTUxZjJhNzExMQ==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2001-12-18T03:35:42Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2001-12-18T03:35:42Z"}, "message": "cp-tree.h: Delete #defines for cp_error, cp_warning, cp_pedwarn, and cp_compiler_error.\n\n\t* cp-tree.h: Delete #defines for cp_error, cp_warning,\n\tcp_pedwarn, and cp_compiler_error.\n\t* call.c, class.c, cp-tree.h, cvt.c, decl.c, decl2.c, error.c,\n\texcept.c, friend.c, init.c, lex.c, method.c, parse.y, pt.c,\n\trtti.c, search.c, semantics.c, spew.c, tree.c, typeck.c,\n\ttypeck2.c: Change calls to the above macros to use their\n\tlanguage-independent equivalents: error, warning, pedwarn, and\n\tinternal_error respectively.\n\nFrom-SVN: r48140", "tree": {"sha": "72800408f5ae98cd4d154871cb245cd0b05da133", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/72800408f5ae98cd4d154871cb245cd0b05da133"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/33bd39a26a88cbaabb2f85735c1ff1e51f2a7111", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33bd39a26a88cbaabb2f85735c1ff1e51f2a7111", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33bd39a26a88cbaabb2f85735c1ff1e51f2a7111", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33bd39a26a88cbaabb2f85735c1ff1e51f2a7111/comments", "author": null, "committer": null, "parents": [{"sha": "86460bab0239d2bbcdef1b500dbb9f0d08d40776", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86460bab0239d2bbcdef1b500dbb9f0d08d40776", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86460bab0239d2bbcdef1b500dbb9f0d08d40776"}], "stats": {"total": 1416, "additions": 709, "deletions": 707}, "files": [{"sha": "fc33867690af3d15d9763793130a9b805328f3cf", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33bd39a26a88cbaabb2f85735c1ff1e51f2a7111/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33bd39a26a88cbaabb2f85735c1ff1e51f2a7111/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=33bd39a26a88cbaabb2f85735c1ff1e51f2a7111", "patch": "@@ -1,3 +1,14 @@\n+2001-12-17  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* cp-tree.h: Delete #defines for cp_error, cp_warning,\n+\tcp_pedwarn, and cp_compiler_error.\n+\t* call.c, class.c, cp-tree.h, cvt.c, decl.c, decl2.c, error.c,\n+\texcept.c, friend.c, init.c, lex.c, method.c, parse.y, pt.c,\n+\trtti.c, search.c, semantics.c, spew.c, tree.c, typeck.c,\n+\ttypeck2.c: Change calls to the above macros to use their\n+\tlanguage-independent equivalents: error, warning, pedwarn, and\n+\tinternal_error respectively.\n+\n 2001-12-16  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \t* decl2.c (finish_file): Remove back_end_hook.\n@@ -50,7 +61,7 @@\n \t(ctor_label): Remove.\n \t* semantics.c (finish_return_stmt): Lose ctor_label support.\n \t* decl.c (finish_constructor_body, mark_lang_function): Likewise.\n-\t* typeck.c (check_return_expr): Check DECL_DESTRUCTOR_P, not \n+\t* typeck.c (check_return_expr): Check DECL_DESTRUCTOR_P, not\n \tdtor_label.\n \n \t* call.c (build_new_method_call): Let resolves_to_fixed_type_p\n@@ -125,8 +136,8 @@\n \n 2001-12-08  Aldy Hernandez  <aldyh@redhat.com>\n \n-        * lex.c (rid_to_yy): Add RID_CHOOSE_EXPR and\n-        RID_TYPES_COMPATIBLE_P.\n+\t* lex.c (rid_to_yy): Add RID_CHOOSE_EXPR and\n+\tRID_TYPES_COMPATIBLE_P.\n \n 2001-12-08  John David Anglin  <dave@hiauly1.hia.nrc.ca>\n \n@@ -225,7 +236,7 @@ Wed Dec  5 17:00:49 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \tPR c++/3048\n \t* cp-tree.h (ovl_member): Remove.\n-\t* decl2.c (merge_functions): Handle extern \"C\" functions \n+\t* decl2.c (merge_functions): Handle extern \"C\" functions\n \tspecially.\n \t* tree.c (ovl_member): Remove.\n \n@@ -303,7 +314,7 @@ Tue Nov 27 09:03:47 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* cp/search.c (lookup_base_r): Declare bk in variable declaration\n \tspace.\n-\t\n+\n 2001-11-25  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tPR g++/3145\n@@ -351,9 +362,9 @@ Tue Nov 27 09:03:47 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* cp-tree.h (CP_TYPE_QUALS): Removed.\n \t* decl.c (cxx_init_decl_processing): Don't set lang_dump_tree.\n-\t* cp-lang.c: Set LANG_HOOKS_TREE_DUMP_DUMP_TREE_FN and \n+\t* cp-lang.c: Set LANG_HOOKS_TREE_DUMP_DUMP_TREE_FN and\n \tLANG_HOOKS_TREE_DUMP_TYPE_QUALS_FN.\n-\t* dump.c (cp_dump_tree): Use void* dump_info argument to match \n+\t* dump.c (cp_dump_tree): Use void* dump_info argument to match\n \tlang-hooks prototype.\n \t* call.c, cp-tree.h, cvt.c, decl.c, init.c, mangle.c, method.c, pt.c,\n \trtti.c, semantics.c, tree.c, typeck.c, typeck2.c: All references to\n@@ -371,7 +382,7 @@ Tue Nov 27 09:03:47 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n 2001-11-20  Mark Mitchell  <mark@codesourcery.com>\n \n \t* call.c (non_reference): Add documentation.\n-\t(convert_class_to_reference): Do not strip reference types \n+\t(convert_class_to_reference): Do not strip reference types\n \tfrom conversion operators.\n \t(maybe_handle_ref_bind): Simplify.\n \t(compare_ics): Correct handling of references.\n@@ -382,7 +393,7 @@ Tue Nov 27 09:03:47 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t(cp_dump_tree): Dump CLASSTYPE_TEMPLATE_SPECIALIZATION.  Use\n \tdump_op.  Dump DECL_MUTABLE, access and staticness for VAR_DECLs.\n \tDECL_PURE_VIRTUAL_P, DECL_VIRTUAL_P,\n-\t\n+\n 2001-11-19  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR4629\n@@ -494,7 +505,7 @@ Tue Nov 27 09:03:47 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t(struct lang_hooks): Constify.\n \t* lex.c (cxx_init_options): Update.\n \t(lang_identify): Remove.\n-\t* parse.y (language_string): Remove.\t\n+\t* parse.y (language_string): Remove.\n \n 2001-11-08  Andreas Franck  <afranck@gmx.de>\n "}, {"sha": "cbe4bc664ace80ca876e4519290df098c443166c", "filename": "gcc/cp/call.c", "status": "modified", "additions": 58, "deletions": 58, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33bd39a26a88cbaabb2f85735c1ff1e51f2a7111/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33bd39a26a88cbaabb2f85735c1ff1e51f2a7111/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=33bd39a26a88cbaabb2f85735c1ff1e51f2a7111", "patch": "@@ -265,7 +265,7 @@ build_scoped_method_call (exp, basetype, name, parms)\n \treturn build_method_call (exp, name, parms, NULL_TREE, LOOKUP_NORMAL);\n \n       if (! check_dtor_name (basetype, name))\n-\tcp_error (\"qualified type `%T' does not match destructor name `~%T'\",\n+\terror (\"qualified type `%T' does not match destructor name `~%T'\",\n \t\t  basetype, TREE_OPERAND (name, 0));\n \n       /* Destructors can be \"called\" for simple types; see 5.2.4 and 12.4 Note\n@@ -274,7 +274,7 @@ build_scoped_method_call (exp, basetype, name, parms)\n       if (! IS_AGGR_TYPE (basetype))\n \t{\n \t  if (TYPE_MAIN_VARIANT (type) != TYPE_MAIN_VARIANT (basetype))\n-\t    cp_error (\"type of `%E' does not match destructor type `%T' (type was `%T')\",\n+\t    error (\"type of `%E' does not match destructor type `%T' (type was `%T')\",\n \t\t      exp, basetype, type);\n \n \t  return cp_convert (void_type_node, exp);\n@@ -283,15 +283,15 @@ build_scoped_method_call (exp, basetype, name, parms)\n \n   if (TREE_CODE (basetype) == NAMESPACE_DECL)\n     {\n-      cp_error (\"`%D' is a namespace\", basetype);\n+      error (\"`%D' is a namespace\", basetype);\n       return error_mark_node;\n     }\n   if (! is_aggr_type (basetype, 1))\n     return error_mark_node;\n \n   if (! IS_AGGR_TYPE (type))\n     {\n-      cp_error (\"base object `%E' of scoped method call is of non-aggregate type `%T'\",\n+      error (\"base object `%E' of scoped method call is of non-aggregate type `%T'\",\n \t\texp, type);\n       return error_mark_node;\n     }\n@@ -525,7 +525,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \tbasetype = TREE_TYPE (basetype);\n \n       if (! check_dtor_name (basetype, name))\n-\tcp_error\n+\terror\n \t  (\"destructor name `~%T' does not match type `%T' of expression\",\n \t   TREE_OPERAND (name, 0), basetype);\n \n@@ -2335,20 +2335,20 @@ print_z_candidates (candidates)\n       if (TREE_CODE (candidates->fn) == IDENTIFIER_NODE)\n \t{\n \t  if (TREE_VEC_LENGTH (candidates->convs) == 3)\n-\t    cp_error (\"%s %D(%T, %T, %T) <builtin>\", str, candidates->fn,\n+\t    error (\"%s %D(%T, %T, %T) <builtin>\", str, candidates->fn,\n \t\t      TREE_TYPE (TREE_VEC_ELT (candidates->convs, 0)),\n \t\t      TREE_TYPE (TREE_VEC_ELT (candidates->convs, 1)),\n \t\t      TREE_TYPE (TREE_VEC_ELT (candidates->convs, 2)));\n \t  else if (TREE_VEC_LENGTH (candidates->convs) == 2)\n-\t    cp_error (\"%s %D(%T, %T) <builtin>\", str, candidates->fn,\n+\t    error (\"%s %D(%T, %T) <builtin>\", str, candidates->fn,\n \t\t      TREE_TYPE (TREE_VEC_ELT (candidates->convs, 0)),\n \t\t      TREE_TYPE (TREE_VEC_ELT (candidates->convs, 1)));\n \t  else\n-\t    cp_error (\"%s %D(%T) <builtin>\", str, candidates->fn,\n+\t    error (\"%s %D(%T) <builtin>\", str, candidates->fn,\n \t\t      TREE_TYPE (TREE_VEC_ELT (candidates->convs, 0)));\n \t}\n       else if (TYPE_P (candidates->fn))\n-\tcp_error (\"%s %T <conversion>\", str, candidates->fn);\n+\terror (\"%s %T <conversion>\", str, candidates->fn);\n       else\n \tcp_error_at (\"%s %+#D%s\", str, candidates->fn,\n \t\t     candidates->viable == -1 ? \" <near match>\" : \"\");\n@@ -2508,7 +2508,7 @@ build_user_type_conversion_1 (totype, expr, flags)\n \t  if (candidates && ! candidates->next)\n \t    /* say why this one won't work or try to be loose */;\n \t  else\n-\t    cp_error (\"no viable candidates\");\n+\t    error (\"no viable candidates\");\n \t}\n #endif\n \n@@ -2522,7 +2522,7 @@ build_user_type_conversion_1 (totype, expr, flags)\n     {\n       if (flags & LOOKUP_COMPLAIN)\n \t{\n-\t  cp_error (\"conversion from `%T' to `%T' is ambiguous\",\n+\t  error (\"conversion from `%T' to `%T' is ambiguous\",\n \t\t    fromtype, totype);\n \t  print_z_candidates (candidates);\n \t}\n@@ -2639,7 +2639,7 @@ build_new_function_call (fn, args)\n \t{\n \t  if (candidates && ! candidates->next)\n \t    return build_function_call (candidates->fn, args);\n-\t  cp_error (\"no matching function for call to `%D(%A)'\",\n+\t  error (\"no matching function for call to `%D(%A)'\",\n \t\t    DECL_NAME (OVL_FUNCTION (fn)), args);\n \t  if (candidates)\n \t    print_z_candidates (candidates);\n@@ -2650,7 +2650,7 @@ build_new_function_call (fn, args)\n \n       if (cand == 0)\n \t{\n-\t  cp_error (\"call of overloaded `%D(%A)' is ambiguous\",\n+\t  error (\"call of overloaded `%D(%A)' is ambiguous\",\n \t\t    DECL_NAME (OVL_FUNCTION (fn)), args);\n \t  print_z_candidates (candidates);\n \t  return error_mark_node;\n@@ -2677,7 +2677,7 @@ build_object_call (obj, args)\n     {\n       /* It's no good looking for an overloaded operator() on a\n \t pointer-to-member-function.  */\n-      cp_error (\"pointer-to-member function %E cannot be called without an object; consider using .* or ->*\", obj);\n+      error (\"pointer-to-member function %E cannot be called without an object; consider using .* or ->*\", obj);\n       return error_mark_node;\n     }\n \n@@ -2746,7 +2746,7 @@ build_object_call (obj, args)\n \n   if (! any_viable (candidates))\n     {\n-      cp_error (\"no match for call to `(%T) (%A)'\", TREE_TYPE (obj), args);\n+      error (\"no match for call to `(%T) (%A)'\", TREE_TYPE (obj), args);\n       print_z_candidates (candidates);\n       return error_mark_node;\n     }\n@@ -2756,7 +2756,7 @@ build_object_call (obj, args)\n \n   if (cand == 0)\n     {\n-      cp_error (\"call of `(%T) (%A)' is ambiguous\", TREE_TYPE (obj), args);\n+      error (\"call of `(%T) (%A)' is ambiguous\", TREE_TYPE (obj), args);\n       print_z_candidates (candidates);\n       return error_mark_node;\n     }\n@@ -2791,23 +2791,23 @@ op_error (code, code2, arg1, arg2, arg3, problem)\n   switch (code)\n     {\n     case COND_EXPR:\n-      cp_error (\"%s for `%T ? %T : %T' operator\", problem,\n+      error (\"%s for `%T ? %T : %T' operator\", problem,\n \t\terror_type (arg1), error_type (arg2), error_type (arg3));\n       break;\n     case POSTINCREMENT_EXPR:\n     case POSTDECREMENT_EXPR:\n-      cp_error (\"%s for `%T %s' operator\", problem, error_type (arg1), opname);\n+      error (\"%s for `%T %s' operator\", problem, error_type (arg1), opname);\n       break;\n     case ARRAY_REF:\n-      cp_error (\"%s for `%T [%T]' operator\", problem,\n+      error (\"%s for `%T [%T]' operator\", problem,\n \t\terror_type (arg1), error_type (arg2));\n       break;\n     default:\n       if (arg2)\n-\tcp_error (\"%s for `%T %s %T' operator\", problem,\n+\terror (\"%s for `%T %s %T' operator\", problem,\n \t\t  error_type (arg1), opname, error_type (arg2));\n       else\n-\tcp_error (\"%s for `%s %T' operator\", problem, opname, error_type (arg1));\n+\terror (\"%s for `%s %T' operator\", problem, opname, error_type (arg1));\n     }\n }\n \n@@ -2958,7 +2958,7 @@ build_conditional_expr (arg1, arg2, arg3)\n \tresult_type = void_type_node;\n       else\n \t{\n-\t  cp_error (\"`%E' has type `void' and is not a throw-expression\",\n+\t  error (\"`%E' has type `void' and is not a throw-expression\",\n \t\t    VOID_TYPE_P (arg2_type) ? arg2 : arg3);\n \t  return error_mark_node;\n \t}\n@@ -2991,7 +2991,7 @@ build_conditional_expr (arg1, arg2, arg3)\n \t  || (conv2 && TREE_CODE (conv2) == AMBIG_CONV)\n \t  || (conv3 && TREE_CODE (conv3) == AMBIG_CONV))\n \t{\n-\t  cp_error (\"operands to ?: have different types\");\n+\t  error (\"operands to ?: have different types\");\n \t  return error_mark_node;\n \t}\n       else if (conv2 && !ICS_BAD_FLAG (conv2))\n@@ -3144,14 +3144,14 @@ build_conditional_expr (arg1, arg2, arg3)\n       \n       if (TREE_CODE (arg2_type) == ENUMERAL_TYPE\n           && TREE_CODE (arg3_type) == ENUMERAL_TYPE)\n-         cp_warning (\"enumeral mismatch in conditional expression: `%T' vs `%T'\",\n+         warning (\"enumeral mismatch in conditional expression: `%T' vs `%T'\",\n                    arg2_type, arg3_type);\n       else if (extra_warnings\n                && ((TREE_CODE (arg2_type) == ENUMERAL_TYPE\n                     && !same_type_p (arg3_type, type_promotes_to (arg2_type)))\n                    || (TREE_CODE (arg3_type) == ENUMERAL_TYPE\n                        && !same_type_p (arg2_type, type_promotes_to (arg3_type)))))\n-        cp_warning (\"enumeral and non-enumeral type in conditional expression\");\n+        warning (\"enumeral and non-enumeral type in conditional expression\");\n       \n       arg2 = perform_implicit_conversion (result_type, arg2);\n       arg3 = perform_implicit_conversion (result_type, arg3);\n@@ -3191,7 +3191,7 @@ build_conditional_expr (arg1, arg2, arg3)\n \n   if (!result_type)\n     {\n-      cp_error (\"operands to ?: have different types\");\n+      error (\"operands to ?: have different types\");\n       return error_mark_node;\n     }\n \n@@ -3232,7 +3232,7 @@ build_new_op (code, flags, arg1, arg2, arg3)\n      undeclared_template<1, 5, 72>a;  */\n   if (code == LT_EXPR && TREE_CODE (arg1) == TEMPLATE_DECL)\n     {\n-      cp_error (\"`%D' must be declared before use\", arg1);\n+      error (\"`%D' must be declared before use\", arg1);\n       return error_mark_node;\n     }\n \n@@ -3396,7 +3396,7 @@ build_new_op (code, flags, arg1, arg2, arg3)\n \t  /* Look for an `operator++ (int)'.  If they didn't have\n \t     one, then we fall back to the old way of doing things.  */\n \t  if (flags & LOOKUP_COMPLAIN)\n-\t    cp_pedwarn (\"no `%D(int)' declared for postfix `%s', trying prefix operator instead\",\n+\t    pedwarn (\"no `%D(int)' declared for postfix `%s', trying prefix operator instead\",\n \t\t\tfnname, \n \t\t\toperator_name_info[code].name);\n \t  if (code == POSTINCREMENT_EXPR)\n@@ -3443,7 +3443,7 @@ build_new_op (code, flags, arg1, arg2, arg3)\n \t  && candidates->next\n \t  && ! candidates->next->next)\n \t{\n-\t  cp_warning (\"using synthesized `%#D' for copy assignment\",\n+\t  warning (\"using synthesized `%#D' for copy assignment\",\n \t\t      cand->fn);\n \t  cp_warning_at (\"  where cfront would use `%#D'\",\n \t\t\t cand == candidates\n@@ -3472,7 +3472,7 @@ build_new_op (code, flags, arg1, arg2, arg3)\n \t  && (TYPE_MAIN_VARIANT (TREE_TYPE (arg1))\n \t      != TYPE_MAIN_VARIANT (TREE_TYPE (arg2))))\n \t{\n-\t  cp_warning (\"comparison between `%#T' and `%#T'\", \n+\t  warning (\"comparison between `%#T' and `%#T'\", \n \t\t      TREE_TYPE (arg1), TREE_TYPE (arg2));\n \t}\n       break;\n@@ -3705,7 +3705,7 @@ build_op_delete_call (code, addr, size, flags, placement)\n   if (placement)\n     return NULL_TREE;\n \n-  cp_error (\"no suitable `operator delete' for `%T'\", type);\n+  error (\"no suitable `operator delete' for `%T'\", type);\n   return error_mark_node;\n }\n \n@@ -3729,7 +3729,7 @@ enforce_access (basetype_path, decl)\n \tcp_error_at (\"`%+#D' is protected\", decl);\n       else\n \tcp_error_at (\"`%+#D' is inaccessible\", decl);\n-      cp_error (\"within this context\");\n+      error (\"within this context\");\n       return 0;\n     }\n \n@@ -3771,9 +3771,9 @@ convert_like_real (convs, expr, fn, argnum, inner)\n \t  else if (TREE_CODE (t) == IDENTITY_CONV)\n \t    break;\n \t}\n-      cp_pedwarn (\"invalid conversion from `%T' to `%T'\", TREE_TYPE (expr), totype);\n+      pedwarn (\"invalid conversion from `%T' to `%T'\", TREE_TYPE (expr), totype);\n       if (fn)\n-\tcp_pedwarn (\"  initializing argument %P of `%D'\", argnum, fn);\n+\tpedwarn (\"  initializing argument %P of `%D'\", argnum, fn);\n       return cp_convert (totype, expr);\n     }\n   \n@@ -3835,21 +3835,21 @@ convert_like_real (convs, expr, fn, argnum, inner)\n \t    if (fn)\n \t      {\n \t\tif (warningcount > savew)\n-\t\t  cp_warning\n+\t\t  warning\n \t\t    (\"  initializing argument %P of `%D' from result of `%D'\",\n \t\t     argnum, fn, convfn);\n \t\telse if (errorcount > savee)\n-\t\t  cp_error\n+\t\t  error\n \t\t    (\"  initializing argument %P of `%D' from result of `%D'\",\n \t\t     argnum, fn, convfn);\n \t      }\n \t    else\n \t      {\n \t\tif (warningcount > savew)\n-\t\t  cp_warning (\"  initializing temporary from result of `%D'\",\n+\t\t  warning (\"  initializing temporary from result of `%D'\",\n \t\t\t      convfn);\n \t\telse if (errorcount > savee)\n-\t\t  cp_error (\"  initializing temporary from result of `%D'\",\n+\t\t  error (\"  initializing temporary from result of `%D'\",\n \t\t\t    convfn);\n \t      }\n \t    expr = build_cplus_new (totype, expr);\n@@ -3912,9 +3912,9 @@ convert_like_real (convs, expr, fn, argnum, inner)\n       if (fn)\n \t{\n \t  if (warningcount > savew)\n-\t    cp_warning (\"  initializing argument %P of `%D'\", argnum, fn);\n+\t    warning (\"  initializing argument %P of `%D'\", argnum, fn);\n \t  else if (errorcount > savee)\n-\t    cp_error (\"  initializing argument %P of `%D'\", argnum, fn);\n+\t    error (\"  initializing argument %P of `%D'\", argnum, fn);\n \t}\n       return build_cplus_new (totype, expr);\n \n@@ -3983,7 +3983,7 @@ convert_arg_to_ellipsis (arg)\n   if (arg != error_mark_node && ! pod_type_p (TREE_TYPE (arg)))\n     {\n       /* Undefined behaviour [expr.call] 5.2.2/7.  */\n-      cp_warning (\"cannot pass objects of non-POD type `%#T' through `...'\",\n+      warning (\"cannot pass objects of non-POD type `%#T' through `...'\",\n \t\t  TREE_TYPE (arg));\n     }\n \n@@ -4008,7 +4008,7 @@ build_x_va_arg (expr, type)\n   if (! pod_type_p (type))\n     {\n       /* Undefined behaviour [expr.call] 5.2.2/7.  */\n-      cp_warning (\"cannot receive objects of non-POD type `%#T' through `...'\",\n+      warning (\"cannot receive objects of non-POD type `%#T' through `...'\",\n \t\t  type);\n     }\n   \n@@ -4150,7 +4150,7 @@ build_over_call (cand, args, flags)\n       tree argtype = TREE_TYPE (TREE_VALUE (arg));\n       tree t;\n       if (ICS_BAD_FLAG (TREE_VEC_ELT (convs, i)))\n-\tcp_pedwarn (\"passing `%T' as `this' argument of `%#D' discards qualifiers\",\n+\tpedwarn (\"passing `%T' as `this' argument of `%#D' discards qualifiers\",\n \t\t    TREE_TYPE (argtype), fn);\n \n       /* [class.mfct.nonstatic]: If a nonstatic member function of a class\n@@ -4398,7 +4398,7 @@ build_java_interface_fn_ref (fn, instance)\n   if (!iface_ref || TREE_CODE (iface_ref) != VAR_DECL\n       || DECL_CONTEXT (iface_ref) != iface)\n     {\n-      cp_error (\"could not find class$ field in java interface type `%T'\", \n+      error (\"could not find class$ field in java interface type `%T'\", \n \t\tiface);\n       return error_mark_node;\n     }\n@@ -4499,7 +4499,7 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n       if (! IS_AGGR_TYPE (basetype))\n \t{\n \t  if ((flags & LOOKUP_COMPLAIN) && basetype != error_mark_node)\n-\t    cp_error (\"request for member `%D' in `%E', which is of non-aggregate type `%T'\",\n+\t    error (\"request for member `%D' in `%E', which is of non-aggregate type `%T'\",\n \t\t      name, instance, basetype);\n \n \t  return error_mark_node;\n@@ -4625,7 +4625,7 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n       if (!COMPLETE_TYPE_P (basetype))\n \tincomplete_type_error (instance_ptr, basetype);\n       else\n-\tcp_error (\"no matching function for call to `%T::%D(%A)%V'\",\n+\terror (\"no matching function for call to `%T::%D(%A)%V'\",\n \t\t  basetype, pretty_name, user_args,\n \t\t  TREE_TYPE (TREE_TYPE (instance_ptr)));\n       print_z_candidates (candidates);\n@@ -4636,7 +4636,7 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n \n   if (cand == 0)\n     {\n-      cp_error (\"call of overloaded `%D(%A)' is ambiguous\", pretty_name,\n+      error (\"call of overloaded `%D(%A)' is ambiguous\", pretty_name,\n \t\tuser_args);\n       print_z_candidates (candidates);\n       return error_mark_node;\n@@ -4648,14 +4648,14 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n \t  || DECL_DESTRUCTOR_P (current_function_decl))\n       && ! (flags & LOOKUP_NONVIRTUAL)\n       && value_member (cand->fn, CLASSTYPE_PURE_VIRTUALS (basetype)))\n-    cp_error ((DECL_CONSTRUCTOR_P (current_function_decl) ? \n+    error ((DECL_CONSTRUCTOR_P (current_function_decl) ? \n \t       \"abstract virtual `%#D' called from constructor\"\n \t       : \"abstract virtual `%#D' called from destructor\"),\n \t      cand->fn);\n   if (TREE_CODE (TREE_TYPE (cand->fn)) == METHOD_TYPE\n       && is_dummy_object (instance_ptr))\n     {\n-      cp_error (\"cannot call member function `%D' without object\", cand->fn);\n+      error (\"cannot call member function `%D' without object\", cand->fn);\n       return error_mark_node;\n     }\n \n@@ -5268,9 +5268,9 @@ joust (cand1, cand2, warn)\n \n \t      if (warn)\n \t\t{\n-\t\t  cp_warning (\"passing `%T' chooses `%T' over `%T'\",\n+\t\t  warning (\"passing `%T' chooses `%T' over `%T'\",\n \t\t\t      type, type1, type2);\n-\t\t  cp_warning (\"  in call to `%D'\", w->fn);\n+\t\t  warning (\"  in call to `%D'\", w->fn);\n \t\t}\n \t      else\n \t\tadd_warning (w, l);\n@@ -5319,10 +5319,10 @@ joust (cand1, cand2, warn)\n \t      tree source = source_type (TREE_VEC_ELT (w->convs, 0));\n \t      if (! DECL_CONSTRUCTOR_P (w->fn))\n \t\tsource = TREE_TYPE (source);\n-\t      cp_warning (\"choosing `%D' over `%D'\", w->fn, l->fn);\n-\t      cp_warning (\"  for conversion from `%T' to `%T'\",\n+\t      warning (\"choosing `%D' over `%D'\", w->fn, l->fn);\n+\t      warning (\"  for conversion from `%T' to `%T'\",\n \t\t\t  source, TREE_TYPE (w->second_conv));\n-\t      cp_warning (\"  because conversion sequence for the argument is better\");\n+\t      warning (\"  because conversion sequence for the argument is better\");\n \t    }\n \t  else\n \t    add_warning (w, l);\n@@ -5444,8 +5444,8 @@ joust (cand1, cand2, warn)\n         {\n \t  if (warn)\n \t    {\n-\t      cp_pedwarn (\"choosing `%D' over `%D'\", w->fn, l->fn);\n-\t      cp_pedwarn (\n+\t      pedwarn (\"choosing `%D' over `%D'\", w->fn, l->fn);\n+\t      pedwarn (\n \"  because worst conversion for the former is better than worst conversion for the latter\");\n \t    }\n \t  else\n@@ -5562,7 +5562,7 @@ perform_implicit_conversion (type, expr)\n \t\t\t      LOOKUP_NORMAL);\n   if (!conv)\n     {\n-      cp_error (\"could not convert `%E' to `%T'\", expr, type);\n+      error (\"could not convert `%E' to `%T'\", expr, type);\n       return error_mark_node;\n     }\n \n@@ -5583,7 +5583,7 @@ initialize_reference (type, expr)\n   conv = reference_binding (type, TREE_TYPE (expr), expr, LOOKUP_NORMAL);\n   if (!conv || ICS_BAD_FLAG (conv))\n     {\n-      cp_error (\"could not convert `%E' to `%T'\", expr, type);\n+      error (\"could not convert `%E' to `%T'\", expr, type);\n       return error_mark_node;\n     }\n "}, {"sha": "02cb9dba476b3f8cea0ef836476118411cbe7bf8", "filename": "gcc/cp/class.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33bd39a26a88cbaabb2f85735c1ff1e51f2a7111/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33bd39a26a88cbaabb2f85735c1ff1e51f2a7111/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=33bd39a26a88cbaabb2f85735c1ff1e51f2a7111", "patch": "@@ -281,7 +281,7 @@ build_base_path (code, expr, binfo, nonnull)\n   \n   if (code == MINUS_EXPR && v_binfo)\n     {\n-      cp_error (\"cannot convert from base `%T' to derived type `%T' via virtual base `%T'\",\n+      error (\"cannot convert from base `%T' to derived type `%T' via virtual base `%T'\",\n \t\tBINFO_TYPE (binfo), BINFO_TYPE (t), BINFO_TYPE (v_binfo));\n       return error_mark_node;\n     }\n@@ -991,7 +991,7 @@ add_method (type, method, error_p)\n \t\t\t/* Defer to the local function.  */\n \t\t\treturn;\n \t\t      else\n-\t\t\tcp_error (\"`%#D' and `%#D' cannot be overloaded\",\n+\t\t\terror (\"`%#D' and `%#D' cannot be overloaded\",\n \t\t\t\t  fn, method);\n \t\t    }\n \t\t}\n@@ -1323,7 +1323,7 @@ check_bases (t, cant_have_default_ctor_p, cant_have_const_ctor_p,\n \t dtor is handled in finish_struct_1.  */\n       if (warn_ecpp && ! TYPE_POLYMORPHIC_P (basetype)\n \t  && TYPE_HAS_DESTRUCTOR (basetype))\n-\tcp_warning (\"base class `%#T' has a non-virtual destructor\",\n+\twarning (\"base class `%#T' has a non-virtual destructor\",\n \t\t    basetype);\n \n       /* If the base class doesn't have copy constructors or\n@@ -1343,7 +1343,7 @@ check_bases (t, cant_have_default_ctor_p, cant_have_const_ctor_p,\n \t{\n \t  *cant_have_default_ctor_p = 1;\n \t  if (! TYPE_HAS_CONSTRUCTOR (t))\n-            cp_pedwarn (\"base `%T' with only non-default constructor in class without a constructor\",\n+            pedwarn (\"base `%T' with only non-default constructor in class without a constructor\",\n                         basetype);\n \t}\n \n@@ -1929,7 +1929,7 @@ maybe_warn_about_overly_private_class (t)\n \t  }\n       if (!has_nonprivate_method) \n \t{\n-\t  cp_warning (\"all member functions in class `%T' are private\", t);\n+\t  warning (\"all member functions in class `%T' are private\", t);\n \t  return;\n \t}\n     }\n@@ -1943,7 +1943,7 @@ maybe_warn_about_overly_private_class (t)\n \n       if (TREE_PRIVATE (dtor))\n \t{\n-\t  cp_warning (\"`%#T' only defines a private destructor and has no friends\",\n+\t  warning (\"`%#T' only defines a private destructor and has no friends\",\n \t\t      t);\n \t  return;\n \t}\n@@ -1986,7 +1986,7 @@ maybe_warn_about_overly_private_class (t)\n \n       if (nonprivate_ctor == 0)\n \t{\n-\t  cp_warning (\"`%#T' only defines private constructors and has no friends\",\n+\t  warning (\"`%#T' only defines private constructors and has no friends\",\n \t\t      t);\n \t  return;\n \t}\n@@ -2107,7 +2107,7 @@ void\n duplicate_tag_error (t)\n      tree t;\n {\n-  cp_error (\"redefinition of `%#T'\", t);\n+  error (\"redefinition of `%#T'\", t);\n   cp_error_at (\"previous definition of `%#T'\", t);\n \n   /* Pretend we haven't defined this type.  */\n@@ -2438,7 +2438,7 @@ find_final_overrider (t, binfo, fn)\n   /* If there was no winner, issue an error message.  */\n   if (!ffod.overriding_fn)\n     {\n-      cp_error (\"no unique final overrider for `%D' in `%T'\", fn, t);\n+      error (\"no unique final overrider for `%D' in `%T'\", fn, t);\n       return error_mark_node;\n     }\n \n@@ -3426,16 +3426,16 @@ check_field_decls (t, access_decls, empty_p,\n   if (has_pointers && warn_ecpp && TYPE_HAS_CONSTRUCTOR (t)\n       && ! (TYPE_HAS_INIT_REF (t) && TYPE_HAS_ASSIGN_REF (t)))\n     {\n-      cp_warning (\"`%#T' has pointer data members\", t);\n+      warning (\"`%#T' has pointer data members\", t);\n       \n       if (! TYPE_HAS_INIT_REF (t))\n \t{\n-\t  cp_warning (\"  but does not override `%T(const %T&)'\", t, t);\n+\t  warning (\"  but does not override `%T(const %T&)'\", t, t);\n \t  if (! TYPE_HAS_ASSIGN_REF (t))\n-\t    cp_warning (\"  or `operator=(const %T&)'\", t);\n+\t    warning (\"  or `operator=(const %T&)'\", t);\n \t}\n       else if (! TYPE_HAS_ASSIGN_REF (t))\n-\tcp_warning (\"  but does not override `operator=(const %T&)'\", t);\n+\twarning (\"  but does not override `operator=(const %T&)'\", t);\n     }\n \n \n@@ -4687,7 +4687,7 @@ layout_virtual_bases (t, offsets)\n \ttree basetype = BINFO_TYPE (TREE_VALUE (vbases));\n \t\n \tif (!lookup_base (t, basetype, ba_ignore | ba_quiet, NULL))\n-\t  cp_warning (\"virtual base `%T' inaccessible in `%T' due to ambiguity\",\n+\t  warning (\"virtual base `%T' inaccessible in `%T' due to ambiguity\",\n \t\t      basetype, t);\n       }\n }\n@@ -4757,7 +4757,7 @@ warn_about_ambiguous_direct_bases (t)\n       tree basetype = TYPE_BINFO_BASETYPE (t, i);\n \n       if (!lookup_base (t, basetype, ba_ignore | ba_quiet, NULL))\n-\tcp_warning (\"direct base `%T' inaccessible in `%T' due to ambiguity\",\n+\twarning (\"direct base `%T' inaccessible in `%T' due to ambiguity\",\n \t\t    basetype, t);\n     }\n }\n@@ -5011,7 +5011,7 @@ finish_struct_1 (t)\n   if (COMPLETE_TYPE_P (t))\n     {\n       if (IS_AGGR_TYPE (t))\n-\tcp_error (\"redefinition of `%#T'\", t);\n+\terror (\"redefinition of `%#T'\", t);\n       else\n \tmy_friendly_abort (172);\n       popclass ();\n@@ -5174,7 +5174,7 @@ finish_struct_1 (t)\n \n   if (warn_nonvdtor && TYPE_POLYMORPHIC_P (t) && TYPE_HAS_DESTRUCTOR (t)\n       && DECL_VINDEX (TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (t), 1)) == NULL_TREE)\n-    cp_warning (\"`%#T' has virtual functions but non-virtual destructor\", t);\n+    warning (\"`%#T' has virtual functions but non-virtual destructor\", t);\n \n   hack_incomplete_structures (t);\n \n@@ -5811,7 +5811,7 @@ resolve_address_of_overloaded_function (target_type,\n   else \n     {\n       if (complain)\n-\tcp_error (\"\\\n+\terror (\"\\\n cannot resolve overloaded function `%D' based on conversion to type `%T'\", \n \t\t  DECL_NAME (OVL_FUNCTION (overload)), target_type);\n       return error_mark_node;\n@@ -5932,7 +5932,7 @@ cannot resolve overloaded function `%D' based on conversion to type `%T'\",\n       /* There were *no* matches.  */\n       if (complain)\n \t{\n- \t  cp_error (\"no matches converting function `%D' to type `%#T'\", \n+ \t  error (\"no matches converting function `%D' to type `%#T'\", \n \t\t    DECL_NAME (OVL_FUNCTION (overload)),\n \t\t    target_type);\n \n@@ -5955,7 +5955,7 @@ cannot resolve overloaded function `%D' based on conversion to type `%T'\",\n \t{\n \t  tree match;\n \n- \t  cp_error (\"converting overloaded function `%D' to type `%#T' is ambiguous\", \n+ \t  error (\"converting overloaded function `%D' to type `%#T' is ambiguous\", \n \t\t    DECL_NAME (OVL_FUNCTION (overload)),\n \t\t    target_type);\n \n@@ -5981,10 +5981,10 @@ cannot resolve overloaded function `%D' based on conversion to type `%T'\",\n       if (!complain)\n         return error_mark_node;\n \n-      cp_pedwarn (\"assuming pointer to member `%D'\", fn);\n+      pedwarn (\"assuming pointer to member `%D'\", fn);\n       if (!explained)\n         {\n-          cp_pedwarn (\"(a pointer to member can only be formed with `&%E')\", fn);\n+          pedwarn (\"(a pointer to member can only be formed with `&%E')\", fn);\n           explained = 1;\n         }\n     }\n@@ -6037,7 +6037,7 @@ instantiate_type (lhstype, rhs, flags)\n       if (comptypes (lhstype, TREE_TYPE (rhs), strict))\n \treturn rhs;\n       if (complain)\n-\tcp_error (\"argument of type `%T' does not match `%T'\",\n+\terror (\"argument of type `%T' does not match `%T'\",\n \t\t  TREE_TYPE (rhs), lhstype);\n       return error_mark_node;\n     }\n@@ -6431,7 +6431,7 @@ note_name_declared_in_class (name, decl)\n \t A name N used in a class S shall refer to the same declaration\n \t in its context and when re-evaluated in the completed scope of\n \t S.  */\n-      cp_error (\"declaration of `%#D'\", decl);\n+      error (\"declaration of `%#D'\", decl);\n       cp_error_at (\"changes meaning of `%D' from `%+#D'\", \n \t\t   DECL_NAME (OVL_CURRENT (decl)),\n \t\t   (tree) n->value);"}, {"sha": "5069648752f7b7d106cead6d4442b9dce8cb3521", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33bd39a26a88cbaabb2f85735c1ff1e51f2a7111/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33bd39a26a88cbaabb2f85735c1ff1e51f2a7111/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=33bd39a26a88cbaabb2f85735c1ff1e51f2a7111", "patch": "@@ -3780,23 +3780,15 @@ extern tree set_guard                           PARAMS ((tree));\n /* in parse.y */\n extern void cp_parse_init\t\t\tPARAMS ((void));\n \n-/* Obsolete names, formerly found in errfn.c, which no longer exists.\n-   These are all variadic functions and therefore cannot be defined\n-   as function-like macros.  */\n-#define cp_error\t\terror\n-#define cp_warning\t\twarning\n-#define cp_pedwarn\t\tpedwarn\n-#define cp_compiler_error\tinternal_error\n-\n extern void cp_error_at\t\tPARAMS ((const char *msgid, ...));\n extern void cp_warning_at\tPARAMS ((const char *msgid, ...));\n extern void cp_pedwarn_at\tPARAMS ((const char *msgid, ...));\n \n /* XXX Not i18n clean.  */\n #define cp_deprecated(str) \\\n  do { if (warn_deprecated) \\\n-      cp_warning(\"%s is deprecated, please see the documentation for details\", \\\n-\t\t str); \\\n+        warning(\"%s is deprecated, please see the documentation for details\", \\\n+\t\tstr); \\\n  } while (0)\n \n /* in error.c */"}, {"sha": "3d02456f32c3a00bbfbe94a6991ba9b204389149", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33bd39a26a88cbaabb2f85735c1ff1e51f2a7111/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33bd39a26a88cbaabb2f85735c1ff1e51f2a7111/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=33bd39a26a88cbaabb2f85735c1ff1e51f2a7111", "patch": "@@ -85,7 +85,7 @@ cp_convert_to_pointer (type, expr, force)\n       intype = complete_type (intype);\n       if (!COMPLETE_TYPE_P (intype))\n \t{\n-\t  cp_error (\"can't convert from incomplete type `%T' to `%T'\",\n+\t  error (\"can't convert from incomplete type `%T' to `%T'\",\n \t\t    intype, type);\n \t  return error_mark_node;\n \t}\n@@ -94,7 +94,7 @@ cp_convert_to_pointer (type, expr, force)\n       if (rval)\n \t{\n \t  if (rval == error_mark_node)\n-\t    cp_error (\"conversion of `%E' from `%T' to `%T' is ambiguous\",\n+\t    error (\"conversion of `%E' from `%T' to `%T' is ambiguous\",\n \t\t      expr, intype, type);\n \t  return rval;\n \t}\n@@ -123,7 +123,7 @@ cp_convert_to_pointer (type, expr, force)\n \t{\n \t  if (TREE_CODE (TREE_TYPE (TREE_TYPE (expr))) == METHOD_TYPE)\n \t    if (pedantic || warn_pmf2ptr)\n-\t      cp_pedwarn (\"converting from `%T' to `%T'\", TREE_TYPE (expr),\n+\t      pedwarn (\"converting from `%T' to `%T'\", TREE_TYPE (expr),\n \t\t\t  type);\n \t  return build1 (NOP_EXPR, type, expr);\n \t}\n@@ -195,11 +195,11 @@ cp_convert_to_pointer (type, expr, force)\n           if (bk == bk_via_virtual)\n \t    {\n \t      if (force)\n-\t        cp_warning (\"pointer to member cast from `%T' to `%T' is via virtual base\",\n+\t        warning (\"pointer to member cast from `%T' to `%T' is via virtual base\",\n \t                    TREE_TYPE (intype), TREE_TYPE (type));\n               else\n                 {\n-\t\t  cp_error (\"pointer to member cast from `%T' to `%T' is via virtual base\",\n+\t\t  error (\"pointer to member cast from `%T' to `%T' is via virtual base\",\n \t\t\t    TREE_TYPE (intype), TREE_TYPE (type));\n \t          return error_mark_node;\n \t        }\n@@ -217,7 +217,7 @@ cp_convert_to_pointer (type, expr, force)\n \t}\n       else if (TYPE_PTRMEMFUNC_P (type))\n \t{\n-\t  cp_error (\"cannot convert `%E' from type `%T' to type `%T'\",\n+\t  error (\"cannot convert `%E' from type `%T' to type `%T'\",\n \t\t    expr, intype, type);\n \t  return error_mark_node;\n \t}\n@@ -230,7 +230,7 @@ cp_convert_to_pointer (type, expr, force)\n     return build_ptrmemfunc (TYPE_PTRMEMFUNC_FN_TYPE (type), expr, 0);\n   else if (TYPE_PTRMEMFUNC_P (intype))\n     {\n-      cp_error (\"cannot convert `%E' from type `%T' to type `%T'\",\n+      error (\"cannot convert `%E' from type `%T' to type `%T'\",\n \t\texpr, intype, type);\n       return error_mark_node;\n     }\n@@ -269,7 +269,7 @@ cp_convert_to_pointer (type, expr, force)\n   if (type_unknown_p (expr))\n     return instantiate_type (type, expr, itf_complain);\n \n-  cp_error (\"cannot convert `%E' from type `%T' to type `%T'\",\n+  error (\"cannot convert `%E' from type `%T' to type `%T'\",\n \t    expr, intype, type);\n   return error_mark_node;\n }\n@@ -451,7 +451,7 @@ warn_ref_binding (reftype, intype, decl)\n       else\n \t  msg = \"conversion to non-const reference type `%#T' from rvalue of type `%T'\";\n \n-      cp_pedwarn (msg, reftype, intype);\n+      pedwarn (msg, reftype, intype);\n     }\n }\n \n@@ -523,7 +523,7 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n \t  \n \t  if (! (convtype & CONV_CONST)\n \t\t   && !at_least_as_qualified_p (ttl, ttr))\n-\t    cp_pedwarn (\"conversion from `%T' to `%T' discards qualifiers\",\n+\t    pedwarn (\"conversion from `%T' to `%T' discards qualifiers\",\n \t\t\tttr, reftype);\n \t}\n \n@@ -541,7 +541,7 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n       if (TREE_CODE (intype) == POINTER_TYPE\n \t  && (comptypes (TREE_TYPE (intype), type, \n \t\t\t COMPARE_BASE | COMPARE_RELAXED )))\n-\tcp_warning (\"casting `%T' to `%T' does not dereference pointer\",\n+\twarning (\"casting `%T' to `%T' does not dereference pointer\",\n \t\t    intype, reftype);\n \t  \n       rval = build_unary_op (ADDR_EXPR, expr, 0);\n@@ -570,7 +570,7 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n   my_friendly_assert (TREE_CODE (intype) != OFFSET_TYPE, 189);\n \n   if (flags & LOOKUP_COMPLAIN)\n-    cp_error (\"cannot convert type `%T' to type `%T'\", intype, reftype);\n+    error (\"cannot convert type `%T' to type `%T'\", intype, reftype);\n \n   if (flags & LOOKUP_SPECULATIVELY)\n     return NULL_TREE;\n@@ -687,7 +687,7 @@ ocp_convert (type, expr, convtype, flags)\n \t  && ((ARITHMETIC_TYPE_P (intype) && ! (convtype & CONV_STATIC))\n \t      || (TREE_CODE (intype) == POINTER_TYPE)))\n \t{\n-\t  cp_pedwarn (\"conversion from `%#T' to `%#T'\", intype, type);\n+\t  pedwarn (\"conversion from `%#T' to `%#T'\", intype, type);\n \n \t  if (flag_pedantic_errors)\n \t    return error_mark_node;\n@@ -699,7 +699,7 @@ ocp_convert (type, expr, convtype, flags)\n \t  if (rval)\n \t    return rval;\n \t  if (flags & LOOKUP_COMPLAIN)\n-\t    cp_error (\"`%#T' used where a `%T' was expected\", intype, type);\n+\t    error (\"`%#T' used where a `%T' was expected\", intype, type);\n \t  if (flags & LOOKUP_SPECULATIVELY)\n \t    return NULL_TREE;\n \t  return error_mark_node;\n@@ -716,7 +716,7 @@ ocp_convert (type, expr, convtype, flags)\n \t\t   && TREE_CODE (TREE_OPERAND (expr, 0)) == FUNCTION_DECL)\n \t    fn = TREE_OPERAND (expr, 0);\n \t  if (fn && !DECL_WEAK (fn))\n-\t    cp_warning (\"the address of `%D', will always be `true'\", fn);\n+\t    warning (\"the address of `%D', will always be `true'\", fn);\n \t  return cp_truthvalue_conversion (e);\n \t}\n       return fold (convert_to_integer (type, e));\n@@ -736,7 +736,7 @@ ocp_convert (type, expr, convtype, flags)\n \t    return rval;\n \t  else\n \t    if (flags & LOOKUP_COMPLAIN)\n-\t      cp_error (\"`%#T' used where a floating point value was expected\",\n+\t      error (\"`%#T' used where a floating point value was expected\",\n \t\t\tTREE_TYPE (e));\n \t}\n       if (code == REAL_TYPE)\n@@ -791,7 +791,7 @@ ocp_convert (type, expr, convtype, flags)\n     return e;\n \n   if (flags & LOOKUP_COMPLAIN)\n-    cp_error (\"conversion from `%T' to non-scalar type `%T' requested\",\n+    error (\"conversion from `%T' to non-scalar type `%T' requested\",\n \t      TREE_TYPE (expr), type);\n   if (flags & LOOKUP_SPECULATIVELY)\n     return NULL_TREE;\n@@ -876,10 +876,10 @@ convert_to_void (expr, implicit)\n         int is_complete = COMPLETE_TYPE_P (complete_type (type));\n         \n         if (is_volatile && !is_complete)\n-          cp_warning (\"object of incomplete type `%T' will not be accessed in %s\",\n+          warning (\"object of incomplete type `%T' will not be accessed in %s\",\n                       type, implicit ? implicit : \"void context\");\n         else if (is_reference && is_volatile)\n-          cp_warning (\"object of type `%T' will not be accessed in %s\",\n+          warning (\"object of type `%T' will not be accessed in %s\",\n                       TREE_TYPE (TREE_OPERAND (expr, 0)),\n                       implicit ? implicit : \"void context\");\n         if (is_reference || !is_volatile || !is_complete)\n@@ -895,7 +895,7 @@ convert_to_void (expr, implicit)\n         int is_complete = COMPLETE_TYPE_P (complete_type (type));\n         \n         if (TYPE_VOLATILE (type) && !is_complete)\n-          cp_warning (\"object `%E' of incomplete type `%T' will not be accessed in %s\",\n+          warning (\"object `%E' of incomplete type `%T' will not be accessed in %s\",\n                       expr, type, implicit ? implicit : \"void context\");\n         break;\n       }\n@@ -915,12 +915,12 @@ convert_to_void (expr, implicit)\n       {\n \t/* [over.over] enumerates the places where we can take the address\n \t   of an overloaded function, and this is not one of them.  */\n-\tcp_pedwarn (\"%s cannot resolve address of overloaded function\",\n+\tpedwarn (\"%s cannot resolve address of overloaded function\",\n \t\t    implicit ? implicit : \"void cast\");\n       }\n     else if (implicit && probe == expr && is_overloaded_fn (probe))\n       /* Only warn when there is no &.  */\n-      cp_warning (\"%s is a reference, not call, to function `%E'\",\n+      warning (\"%s is a reference, not call, to function `%E'\",\n \t\t  implicit, expr);\n   }\n   \n@@ -1058,7 +1058,7 @@ build_expr_type_conversion (desires, expr, complain)\n   if (expr == null_node \n       && (desires & WANT_INT) \n       && !(desires & WANT_NULL))\n-    cp_warning (\"converting NULL to non-pointer type\");\n+    warning (\"converting NULL to non-pointer type\");\n     \n   if (TREE_CODE (expr) == OFFSET_REF)\n     expr = resolve_offset_ref (expr);\n@@ -1134,9 +1134,9 @@ build_expr_type_conversion (desires, expr, complain)\n \t    {\n \t      if (complain)\n \t\t{\n-\t\t  cp_error (\"ambiguous default type conversion from `%T'\",\n+\t\t  error (\"ambiguous default type conversion from `%T'\",\n \t\t\t    basetype);\n-\t\t  cp_error (\"  candidate conversions include `%D' and `%D'\",\n+\t\t  error (\"  candidate conversions include `%D' and `%D'\",\n \t\t\t    winner, cand);\n \t\t}\n \t      return error_mark_node;"}, {"sha": "d535097a299e4b5dbd52c3c7497abe81c7e34961", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 222, "deletions": 223, "changes": 445, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33bd39a26a88cbaabb2f85735c1ff1e51f2a7111/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33bd39a26a88cbaabb2f85735c1ff1e51f2a7111/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=33bd39a26a88cbaabb2f85735c1ff1e51f2a7111", "patch": "@@ -1008,7 +1008,7 @@ add_binding (id, decl)\n     }\n   else\n     {\n-      cp_error (\"declaration of `%#D'\", decl);\n+      error (\"declaration of `%#D'\", decl);\n       cp_error_at (\"conflicts with previous declaration `%#D'\",\n \t\t   BINDING_VALUE (binding));\n       ok = 0;\n@@ -2283,7 +2283,7 @@ push_namespace (name)\n           need_new = 0;\n           if (DECL_NAMESPACE_ALIAS (d))\n             {\n-              cp_error (\"namespace alias `%D' not allowed here, assuming `%D'\",\n+              error (\"namespace alias `%D' not allowed here, assuming `%D'\",\n                         d, DECL_NAMESPACE_ALIAS (d));\n               d = DECL_NAMESPACE_ALIAS (d);\n             }\n@@ -3063,7 +3063,7 @@ warn_extern_redeclared_static (newdecl, olddecl)\n     return;\n \n   name = DECL_ASSEMBLER_NAME (newdecl);\n-  cp_pedwarn (IDENTIFIER_IMPLICIT_DECL (name)\n+  pedwarn (IDENTIFIER_IMPLICIT_DECL (name)\n \t      ? implicit_extern_static_warning\n \t      : explicit_extern_static_warning, newdecl);\n   cp_pedwarn_at (\"previous declaration of `%D'\", olddecl);\n@@ -3143,7 +3143,7 @@ duplicate_decls (newdecl, olddecl)\n \t  if (! TREE_PUBLIC (newdecl))\n \t    {\n \t      if (warn_shadow)\n-\t\tcp_warning (\"shadowing %s function `%#D'\",\n+\t\twarning (\"shadowing %s function `%#D'\",\n \t\t\t    DECL_BUILT_IN (olddecl) ? \"built-in\" : \"library\",\n \t\t\t    olddecl);\n \t      /* Discard the old built-in function.  */\n@@ -3152,12 +3152,12 @@ duplicate_decls (newdecl, olddecl)\n \t  /* If the built-in is not ansi, then programs can override\n \t     it even globally without an error.  */\n \t  else if (! DECL_BUILT_IN (olddecl))\n-\t    cp_warning (\"library function `%#D' redeclared as non-function `%#D'\",\n+\t    warning (\"library function `%#D' redeclared as non-function `%#D'\",\n \t\t\tolddecl, newdecl);\n \t  else\n \t    {\n-\t      cp_error (\"declaration of `%#D'\", newdecl);\n-\t      cp_error (\"conflicts with built-in declaration `%#D'\",\n+\t      error (\"declaration of `%#D'\", newdecl);\n+\t      error (\"conflicts with built-in declaration `%#D'\",\n \t\t\tolddecl);\n \t    }\n \t  return 0;\n@@ -3173,12 +3173,12 @@ duplicate_decls (newdecl, olddecl)\n \n \t      if (TREE_PUBLIC (newdecl))\n \t\t{\n-\t\t  cp_warning (\"new declaration `%#D'\", newdecl);\n-\t\t  cp_warning (\"ambiguates built-in declaration `%#D'\",\n+\t\t  warning (\"new declaration `%#D'\", newdecl);\n+\t\t  warning (\"ambiguates built-in declaration `%#D'\",\n \t\t\t      olddecl);\n \t\t}\n \t      else if (warn_shadow)\n-\t\tcp_warning (\"shadowing %s function `%#D'\",\n+\t\twarning (\"shadowing %s function `%#D'\",\n \t\t\t    DECL_BUILT_IN (olddecl) ? \"built-in\" : \"library\",\n \t\t\t    olddecl);\n \t    }\n@@ -3230,7 +3230,7 @@ duplicate_decls (newdecl, olddecl)\n \t      && DECL_FUNCTION_TEMPLATE_P (newdecl)))\n \treturn 0;\n \n-      cp_error (\"`%#D' redeclared as different kind of symbol\", newdecl);\n+      error (\"`%#D' redeclared as different kind of symbol\", newdecl);\n       if (TREE_CODE (olddecl) == TREE_LIST)\n \tolddecl = TREE_VALUE (olddecl);\n       cp_error_at (\"previous declaration of `%#D'\", olddecl);\n@@ -3255,7 +3255,7 @@ duplicate_decls (newdecl, olddecl)\n \t  if (TREE_CODE (DECL_TEMPLATE_RESULT (olddecl)) == TYPE_DECL\n \t      || TREE_CODE (DECL_TEMPLATE_RESULT (newdecl)) == TYPE_DECL)\n \t    {\n-\t      cp_error (\"declaration of template `%#D'\", newdecl);\n+\t      error (\"declaration of template `%#D'\", newdecl);\n \t      cp_error_at (\"conflicts with previous declaration `%#D'\",\n \t\t\t   olddecl);\n \t    }\n@@ -3266,7 +3266,7 @@ duplicate_decls (newdecl, olddecl)\n \t\t   && comp_template_parms (DECL_TEMPLATE_PARMS (newdecl),\n \t\t\t\t\t   DECL_TEMPLATE_PARMS (olddecl)))\n \t    {\n-\t      cp_error (\"new declaration `%#D'\", newdecl);\n+\t      error (\"new declaration `%#D'\", newdecl);\n \t      cp_error_at (\"ambiguates old declaration `%#D'\", olddecl);\n \t    }\n \t  return 0;\n@@ -3275,14 +3275,14 @@ duplicate_decls (newdecl, olddecl)\n \t{\n \t  if (DECL_EXTERN_C_P (newdecl) && DECL_EXTERN_C_P (olddecl))\n \t    {\n-\t      cp_error (\"declaration of C function `%#D' conflicts with\",\n+\t      error (\"declaration of C function `%#D' conflicts with\",\n \t\t\tnewdecl);\n \t      cp_error_at (\"previous declaration `%#D' here\", olddecl);\n \t    }\n \t  else if (compparms (TYPE_ARG_TYPES (TREE_TYPE (newdecl)),\n \t\t\t      TYPE_ARG_TYPES (TREE_TYPE (olddecl))))\n \t    {\n-\t      cp_error (\"new declaration `%#D'\", newdecl);\n+\t      error (\"new declaration `%#D'\", newdecl);\n \t      cp_error_at (\"ambiguates old declaration `%#D'\", olddecl);\n \t    }\n \t  else\n@@ -3293,7 +3293,7 @@ duplicate_decls (newdecl, olddecl)\n       else if (current_class_type == NULL_TREE\n \t  || IDENTIFIER_ERROR_LOCUS (DECL_ASSEMBLER_NAME (newdecl)) != current_class_type)\n \t{\n-\t  cp_error (\"conflicting types for `%#D'\", newdecl);\n+\t  error (\"conflicting types for `%#D'\", newdecl);\n \t  cp_error_at (\"previous declaration as `%#D'\", olddecl);\n \t}\n     }\n@@ -3333,7 +3333,7 @@ duplicate_decls (newdecl, olddecl)\n       const char *errmsg = redeclaration_error_message (newdecl, olddecl);\n       if (errmsg)\n \t{\n-\t  cp_error (errmsg, newdecl);\n+\t  error (errmsg, newdecl);\n \t  if (DECL_NAME (olddecl) != NULL_TREE)\n \t    cp_error_at ((DECL_INITIAL (olddecl)\n \t\t\t  && namespace_bindings_p ())\n@@ -3361,7 +3361,7 @@ duplicate_decls (newdecl, olddecl)\n \t    {\n \t      cp_error_at (\"previous declaration of `%#D' with %L linkage\",\n \t\t\t   olddecl, DECL_LANGUAGE (olddecl));\n-\t      cp_error (\"conflicts with new declaration with %L linkage\",\n+\t      error (\"conflicts with new declaration with %L linkage\",\n \t\t\tDECL_LANGUAGE (newdecl));\n \t    }\n \t}\n@@ -3386,15 +3386,15 @@ duplicate_decls (newdecl, olddecl)\n \t\t  {\n \t\t    if (pedantic)\n \t\t      {\n-\t\t\tcp_pedwarn (\"default argument given for parameter %d of `%#D'\",\n+\t\t\tpedwarn (\"default argument given for parameter %d of `%#D'\",\n \t\t\t\t    i, newdecl);\n \t\t\tcp_pedwarn_at (\"after previous specification in `%#D'\",\n \t\t\t\t       olddecl);\n \t\t      }\n \t\t  }\n \t\telse\n \t\t  {\n-\t\t    cp_error (\"default argument given for parameter %d of `%#D'\",\n+\t\t    error (\"default argument given for parameter %d of `%#D'\",\n \t\t\t      i, newdecl);\n \t\t    cp_error_at (\"after previous specification in `%#D'\",\n \t\t\t\t olddecl);\n@@ -3405,7 +3405,7 @@ duplicate_decls (newdecl, olddecl)\n \t      && ! DECL_DECLARED_INLINE_P (olddecl)\n \t      && TREE_ADDRESSABLE (olddecl) && warn_inline)\n \t    {\n-\t      cp_warning (\"`%#D' was used before it was declared inline\",\n+\t      warning (\"`%#D' was used before it was declared inline\",\n \t\t\t  newdecl);\n \t      cp_warning_at (\"previous non-inline declaration here\",\n \t\t\t     olddecl);\n@@ -3453,7 +3453,7 @@ duplicate_decls (newdecl, olddecl)\n \t  /* Don't warn about friends, let add_friend take care of it. */\n \t  && ! (DECL_FRIEND_P (newdecl) || DECL_FRIEND_P (olddecl)))\n \t{\n-\t  cp_warning (\"redundant redeclaration of `%D' in same scope\", newdecl);\n+\t  warning (\"redundant redeclaration of `%D' in same scope\", newdecl);\n \t  cp_warning_at (\"previous declaration of `%D'\", olddecl);\n \t}\n     }\n@@ -3536,7 +3536,7 @@ duplicate_decls (newdecl, olddecl)\n \t      && !comp_except_specs (TYPE_RAISES_EXCEPTIONS (TREE_TYPE (newdecl)),\n \t                             TYPE_RAISES_EXCEPTIONS (TREE_TYPE (olddecl)), 1))\n \t    {\n-\t      cp_error (\"declaration of `%F' throws different exceptions\",\n+\t      error (\"declaration of `%F' throws different exceptions\",\n \t\t\tnewdecl);\n \t      cp_error_at (\"than previous declaration `%F'\", olddecl);\n \t    }\n@@ -3663,7 +3663,7 @@ duplicate_decls (newdecl, olddecl)\n \t       that specialization that would cause an implicit\n \t       instantiation to take place, in every translation unit in\n \t       which such a use occurs.  */\n-\t    cp_error (\"explicit specialization of %D after first use\",\n+\t    error (\"explicit specialization of %D after first use\",\n \t\t      olddecl);\n \n \t  SET_DECL_TEMPLATE_SPECIALIZATION (olddecl);\n@@ -3939,7 +3939,7 @@ pushdecl (x)\n \t  else if (t == wchar_decl_node)\n \t    {\n \t      if (pedantic && ! DECL_IN_SYSTEM_HEADER (x))\n-\t\tcp_pedwarn (\"redeclaration of `wchar_t' as `%T'\",\n+\t\tpedwarn (\"redeclaration of `wchar_t' as `%T'\",\n \t\t\t    TREE_TYPE (x));\n \n \t      /* Throw away the redeclaration.  */\n@@ -3968,7 +3968,7 @@ pushdecl (x)\n \n \t         This function shall not be overloaded.  */\n \t      cp_error_at (\"invalid redeclaration of `%D'\", t);\n-\t      cp_error (\"as `%D'\", x);\n+\t      error (\"as `%D'\", x);\n \t      /* We don't try to push this declaration since that\n \t\t causes a crash.  */\n \t      return x;\n@@ -4057,7 +4057,7 @@ pushdecl (x)\n \t      && TREE_CODE (decl) == TREE_CODE (x)\n \t      && !same_type_p (TREE_TYPE (x), TREE_TYPE (decl)))\n \t    {\n-\t      cp_pedwarn (\"type mismatch with previous external decl\", x);\n+\t      pedwarn (\"type mismatch with previous external decl\", x);\n \t      cp_pedwarn_at (\"previous external decl of `%#D'\", decl);\n \t    }\n \t}\n@@ -4098,7 +4098,7 @@ pushdecl (x)\n \t      /* If this real decl matches the implicit, don't complain.  */\n \t      && ! (TREE_CODE (x) == FUNCTION_DECL\n \t\t    && TREE_TYPE (TREE_TYPE (x)) == integer_type_node))\n-\t    cp_warning\n+\t    warning\n \t      (\"`%D' was previously implicitly declared to return `int'\", x);\n \n \t  /* If new decl is `static' and an `extern' was seen previously,\n@@ -4159,7 +4159,7 @@ pushdecl (x)\n \t\t/* OK */;\n \t      else\n \t\t{\n-\t\t  cp_warning (\"extern declaration of `%#D' doesn't match\", x);\n+\t\t  warning (\"extern declaration of `%#D' doesn't match\", x);\n \t\t  cp_warning_at (\"global declaration `%#D'\", oldglobal);\n \t\t}\n \t    }\n@@ -4194,7 +4194,7 @@ pushdecl (x)\n \t\t  /* ARM $8.3 */\n \t\t  if (b->parm_flag == 1)\n \t\t    {\n-\t\t      cp_error (\"declaration of `%#D' shadows a parameter\",\n+\t\t      error (\"declaration of `%#D' shadows a parameter\",\n \t\t\t\tname);\n \t\t      err = true;\n \t\t    }\n@@ -4214,7 +4214,7 @@ pushdecl (x)\n \t      if (IDENTIFIER_CLASS_VALUE (name) != NULL_TREE\n \t\t       && current_class_ptr\n \t\t       && !TREE_STATIC (name))\n-\t\tcp_warning (\"declaration of `%s' shadows a member of `this'\",\n+\t\twarning (\"declaration of `%s' shadows a member of `this'\",\n \t\t\t    IDENTIFIER_POINTER (name));\n \t      else if (oldlocal != NULL_TREE\n \t\t       && TREE_CODE (oldlocal) == VAR_DECL)\n@@ -4579,7 +4579,7 @@ push_overloaded_decl (decl, flags)\n \t  if (IS_AGGR_TYPE (t) && warn_shadow\n \t      && (! DECL_IN_SYSTEM_HEADER (decl)\n \t\t  || ! DECL_IN_SYSTEM_HEADER (old)))\n-\t    cp_warning (\"`%#D' hides constructor for `%#T'\", decl, t);\n+\t    warning (\"`%#D' hides constructor for `%#T'\", decl, t);\n \t  old = NULL_TREE;\n \t}\n       else if (is_overloaded_fn (old))\n@@ -4594,7 +4594,7 @@ push_overloaded_decl (decl, flags)\n \t\t  && !(flags & PUSH_USING)\n \t\t  && compparms (TYPE_ARG_TYPES (TREE_TYPE (fn)),\n \t\t\t\tTYPE_ARG_TYPES (TREE_TYPE (decl))))\n-\t\tcp_error (\"`%#D' conflicts with previous using declaration `%#D'\",\n+\t\terror (\"`%#D' conflicts with previous using declaration `%#D'\",\n \t\t\t  decl, fn);\n \n \t      if (duplicate_decls (decl, fn))\n@@ -4607,7 +4607,7 @@ push_overloaded_decl (decl, flags)\n       else\n \t{\n \t  cp_error_at (\"previous non-function declaration `%#D'\", old);\n-\t  cp_error (\"conflicts with function declaration `%#D'\", decl);\n+\t  error (\"conflicts with function declaration `%#D'\", decl);\n \t  return decl;\n \t}\n     }\n@@ -4697,7 +4697,7 @@ implicitly_declare (functionid)\n       /* Only one warning per identifier.  */\n       && IDENTIFIER_IMPLICIT_DECL (functionid) == NULL_TREE)\n     {\n-      cp_pedwarn (\"implicit declaration of function `%#D'\", decl);\n+      pedwarn (\"implicit declaration of function `%#D'\", decl);\n     }\n \n   SET_IDENTIFIER_IMPLICIT_DECL (functionid, decl);\n@@ -4958,7 +4958,7 @@ check_previous_goto_1 (decl, level, names, file, line)\n \t  if (! identified)\n \t    {\n \t      if (decl)\n-\t\tcp_pedwarn (\"jump to label `%D'\", decl);\n+\t\tpedwarn (\"jump to label `%D'\", decl);\n \t      else\n \t\tpedwarn (\"jump to case label\");\n \n@@ -4982,7 +4982,7 @@ check_previous_goto_1 (decl, level, names, file, line)\n \t  if (! identified)\n \t    {\n \t      if (decl)\n-\t\tcp_pedwarn (\"jump to label `%D'\", decl);\n+\t\tpedwarn (\"jump to label `%D'\", decl);\n \t      else\n \t\tpedwarn (\"jump to case label\");\n \n@@ -5124,11 +5124,11 @@ define_label (filename, line, name)\n     p->more_cleanups_ok = 0;\n \n   if (name == get_identifier (\"wchar_t\"))\n-    cp_pedwarn (\"label named wchar_t\");\n+    pedwarn (\"label named wchar_t\");\n \n   if (DECL_INITIAL (decl) != NULL_TREE)\n     {\n-      cp_error (\"duplicate label `%D'\", decl);\n+      error (\"duplicate label `%D'\", decl);\n       return 0;\n     }\n   else\n@@ -5213,7 +5213,7 @@ finish_case_label (low_value, high_value)\n       if (high_value)\n \terror (\"case label not within a switch statement\");\n       else if (low_value)\n-\tcp_error (\"case label `%E' not within a switch statement\",\n+\terror (\"case label `%E' not within a switch statement\",\n \t\t  low_value);\n       else\n \terror (\"`default' label not within a switch statement\");\n@@ -5346,7 +5346,7 @@ lookup_tag (form, name, binding_level, thislevel_only)\n \t    if (old && TREE_CODE (old) != form\n \t\t&& !(form != ENUMERAL_TYPE && TREE_CODE (old) == TEMPLATE_DECL))\n \t      {\n-\t\tcp_error (\"`%#D' redeclared as %C\", old, form);\n+\t\terror (\"`%#D' redeclared as %C\", old, form);\n \t\treturn NULL_TREE;\n \t      }\n \t    if (old)\n@@ -5366,7 +5366,7 @@ lookup_tag (form, name, binding_level, thislevel_only)\n \t\t    && !(form != ENUMERAL_TYPE && code == TEMPLATE_DECL))\n \t\t  {\n \t\t    /* Definition isn't the kind we were looking for.  */\n-\t\t    cp_error (\"`%#D' redeclared as %C\", TREE_VALUE (tail),\n+\t\t    error (\"`%#D' redeclared as %C\", TREE_VALUE (tail),\n \t\t\t      form);\n \t\t    return NULL_TREE;\n \t\t  }\n@@ -5455,7 +5455,7 @@ lookup_namespace_name (namespace, name)\n     {\n       /* This happens for A::B where B is a template, and there are no\n \t template arguments.  */\n-      cp_error (\"invalid use of `%D'\", name);\n+      error (\"invalid use of `%D'\", name);\n       return error_mark_node;\n     }\n \n@@ -5496,7 +5496,7 @@ lookup_namespace_name (namespace, name)\n \t\t\t\t\t    TREE_OPERAND (template_id, 1));\n \t  else\n \t    {\n-\t      cp_error (\"`%D::%D' is not a template\",\n+\t      error (\"`%D::%D' is not a template\",\n \t\t\tnamespace, name);\n \t      return error_mark_node;\n \t    }\n@@ -5508,7 +5508,7 @@ lookup_namespace_name (namespace, name)\n       return val;\n     }\n \n-  cp_error (\"`%D' undeclared in namespace `%D'\", name, namespace);\n+  error (\"`%D' undeclared in namespace `%D'\", name, namespace);\n   return error_mark_node;\n }\n \n@@ -5642,7 +5642,7 @@ make_typename_type (context, name, complain)\n     }\n   if (TREE_CODE (name) == TEMPLATE_DECL)\n     {\n-      cp_error (\"`%D' used without template parameters\", name);\n+      error (\"`%D' used without template parameters\", name);\n       return error_mark_node;\n     }\n   if (TREE_CODE (name) != IDENTIFIER_NODE)\n@@ -5653,7 +5653,7 @@ make_typename_type (context, name, complain)\n       /* We can get here from typename_sub0 in the explicit_template_type\n \t expansion.  Just fail.  */\n       if (complain)\n-\tcp_error (\"no class template named `%#T' in `%#T'\",\n+\terror (\"no class template named `%#T' in `%#T'\",\n \t\t  name, context);\n       return error_mark_node;\n     }\n@@ -5669,7 +5669,7 @@ make_typename_type (context, name, complain)\n \t  if (!tmpl || !DECL_CLASS_TEMPLATE_P (tmpl))\n \t    {\n \t      if (complain)\n-\t\tcp_error (\"no class template named `%#T' in `%#T'\",\n+\t\terror (\"no class template named `%#T' in `%#T'\",\n \t\t\t  name, context);\n \t      return error_mark_node;\n \t    }\n@@ -5687,7 +5687,7 @@ make_typename_type (context, name, complain)\n \t  if (!IS_AGGR_TYPE (context))\n \t    {\n \t      if (complain)\n-\t\tcp_error (\"no type named `%#T' in `%#T'\", name, context);\n+\t\terror (\"no type named `%#T' in `%#T'\", name, context);\n \t      return error_mark_node;\n \t    }\n \n@@ -5702,7 +5702,7 @@ make_typename_type (context, name, complain)\n   if (!uses_template_parms (context))\n     {\n       if (complain)\n-\tcp_error (\"no type named `%#T' in `%#T'\", name, context);\n+\terror (\"no type named `%#T' in `%#T'\", name, context);\n       return error_mark_node;\n     }\n \n@@ -5740,7 +5740,7 @@ make_unbound_class_template (context, name, complain)\n       if (!tmpl || !DECL_CLASS_TEMPLATE_P (tmpl))\n \t{\n \t  if (complain)\n-\t    cp_error (\"no class template named `%#T' in `%#T'\", name, context);\n+\t    error (\"no class template named `%#T' in `%#T'\", name, context);\n \t  return error_mark_node;\n \t}\n       \n@@ -5919,11 +5919,11 @@ warn_about_implicit_typename_lookup (typename, binding)\n       && ! (TREE_CODE (binding) == TYPE_DECL\n \t    && same_type_p (TREE_TYPE (binding), subtype)))\n     {\n-      cp_warning (\"lookup of `%D' finds `%#D'\",\n+      warning (\"lookup of `%D' finds `%#D'\",\n \t\t  name, binding);\n-      cp_warning (\"  instead of `%D' from dependent base class\",\n+      warning (\"  instead of `%D' from dependent base class\",\n \t\t  typename);\n-      cp_warning (\"  (use `typename %T::%D' if that's what you meant)\",\n+      warning (\"  (use `typename %T::%D' if that's what you meant)\",\n \t\t  constructor_name (current_class_type), name);\n     }\n }\n@@ -6096,7 +6096,7 @@ lookup_name_real (name, prefer_type, nonclass, namespaces_only)\n \t  if (looking_for_typename && TREE_CODE (from_obj) == TYPE_DECL\n \t      && TREE_CODE (val) == TYPE_DECL\n \t      && ! same_type_p (TREE_TYPE (from_obj), TREE_TYPE (val)))\n-\t    cp_pedwarn (\"\\\n+\t    pedwarn (\"\\\n lookup of `%D' in the scope of `%#T' (`%#D') \\\n does not match lookup in the current scope (`%#D')\",\n \t\t\tname, got_object, from_obj, val);\n@@ -6980,7 +6980,7 @@ check_tag_decl (declspecs)\n \t  if (found_type == 2 && TREE_CODE (value) == IDENTIFIER_NODE)\n \t    {\n \t      if (! in_system_header)\n-\t\tcp_pedwarn (\"redeclaration of C++ built-in type `%T'\", value);\n+\t\tpedwarn (\"redeclaration of C++ built-in type `%T'\", value);\n \t      return NULL_TREE;\n \t    }\n \n@@ -7056,14 +7056,14 @@ check_tag_decl (declspecs)\n     {\n       if (ob_modifier == ridpointers[(int) RID_INLINE]\n \t  || ob_modifier == ridpointers[(int) RID_VIRTUAL])\n-\tcp_error (\"`%D' can only be specified for functions\", ob_modifier);\n+\terror (\"`%D' can only be specified for functions\", ob_modifier);\n       else if (ob_modifier == ridpointers[(int) RID_FRIEND])\n-\tcp_error (\"`%D' can only be specified inside a class\", ob_modifier);\n+\terror (\"`%D' can only be specified inside a class\", ob_modifier);\n       else if (ob_modifier == ridpointers[(int) RID_EXPLICIT])\n-\tcp_error (\"`%D' can only be specified for constructors\",\n+\terror (\"`%D' can only be specified for constructors\",\n \t\t  ob_modifier);\n       else\n-\tcp_error (\"`%D' can only be specified for objects and functions\",\n+\terror (\"`%D' can only be specified for objects and functions\",\n \t\t  ob_modifier);\n     }\n \n@@ -7200,13 +7200,13 @@ start_decl (declarator, declspecs, initialized, attributes, prefix_attributes)\n \t   Any other case of an initialization in a TYPE_DECL is an error.  */\n \tif (pedantic || list_length (declspecs) > 1)\n \t  {\n-\t    cp_error (\"typedef `%D' is initialized\", decl);\n+\t    error (\"typedef `%D' is initialized\", decl);\n \t    initialized = 0;\n \t  }\n \tbreak;\n \n       case FUNCTION_DECL:\n-\tcp_error (\"function `%#D' is initialized like a variable\", decl);\n+\terror (\"function `%#D' is initialized like a variable\", decl);\n \tinitialized = 0;\n \tbreak;\n \n@@ -7218,7 +7218,7 @@ start_decl (declarator, declspecs, initialized, attributes, prefix_attributes)\n     {\n       if (! toplevel_bindings_p ()\n \t  && DECL_EXTERNAL (decl))\n-\tcp_warning (\"declaration of `%#D' has `extern' and is initialized\",\n+\twarning (\"declaration of `%#D' has `extern' and is initialized\",\n \t\t    decl);\n       DECL_EXTERNAL (decl) = 0;\n       if (toplevel_bindings_p ())\n@@ -7248,12 +7248,12 @@ start_decl (declarator, declspecs, initialized, attributes, prefix_attributes)\n \t{\n \t  tree field = lookup_field (context, DECL_NAME (decl), 0, 0);\n \t  if (field == NULL_TREE || TREE_CODE (field) != VAR_DECL)\n-\t    cp_error (\"`%#D' is not a static member of `%#T'\", decl, context);\n+\t    error (\"`%#D' is not a static member of `%#T'\", decl, context);\n \t  else\n \t    {\n \t      if (DECL_CONTEXT (field) != context)\n \t\t{\n-\t\t  cp_pedwarn (\"ISO C++ does not permit `%T::%D' to be defined as `%T::%D'\",\n+\t\t  pedwarn (\"ISO C++ does not permit `%T::%D' to be defined as `%T::%D'\",\n \t\t\t      DECL_CONTEXT (field), DECL_NAME (decl),\n \t\t\t      context, DECL_NAME (decl));\n \t\t  DECL_CONTEXT (decl) = DECL_CONTEXT (field);\n@@ -7264,7 +7264,7 @@ start_decl (declarator, declspecs, initialized, attributes, prefix_attributes)\n \t\t initialization.  Thus, duplicate_decls won't warn\n \t\t about this situation, and so we check here.  */\n \t      if (DECL_INITIAL (decl) && DECL_INITIAL (field))\n-\t\tcp_error (\"duplicate initialization of %D\", decl);\n+\t\terror (\"duplicate initialization of %D\", decl);\n \t      if (duplicate_decls (decl, field))\n \t\tdecl = field;\n \t    }\n@@ -7293,7 +7293,7 @@ start_decl (declarator, declspecs, initialized, attributes, prefix_attributes)\n \t}\n \n       if (DECL_EXTERNAL (decl) && ! DECL_TEMPLATE_SPECIALIZATION (decl))\n-\tcp_pedwarn (\"declaration of `%#D' outside of class is not definition\",\n+\tpedwarn (\"declaration of `%#D' outside of class is not definition\",\n \t\t    decl);\n     }\n \n@@ -7341,15 +7341,15 @@ start_decl_1 (decl)\n \t;\t\t\t/* A complete type is ok.  */\n       else if (TREE_CODE (type) != ARRAY_TYPE)\n \t{\n-\t  cp_error (\"variable `%#D' has initializer but incomplete type\",\n+\t  error (\"variable `%#D' has initializer but incomplete type\",\n \t\t    decl);\n \t  initialized = 0;\n \t  type = TREE_TYPE (decl) = error_mark_node;\n \t}\n       else if (!COMPLETE_TYPE_P (complete_type (TREE_TYPE (type))))\n \t{\n \t  if (DECL_LANG_SPECIFIC (decl) && DECL_TEMPLATE_INFO (decl))\n-\t    cp_error (\"elements of array `%#D' have incomplete type\", decl);\n+\t    error (\"elements of array `%#D' have incomplete type\", decl);\n \t  /* else we already gave an error in start_decl.  */\n \t  initialized = 0;\n \t}\n@@ -7365,7 +7365,7 @@ start_decl_1 (decl)\n       if ((! processing_template_decl || ! uses_template_parms (type))\n \t  && !COMPLETE_TYPE_P (complete_type (type)))\n \t{\n-\t  cp_error (\"aggregate `%#D' has incomplete type and cannot be initialized\",\n+\t  error (\"aggregate `%#D' has incomplete type and cannot be initialized\",\n \t\t decl);\n \t  /* Change the type so that assemble_variable will give\n \t     DECL an rtl we can live with: (mem (const_int 0)).  */\n@@ -7404,7 +7404,7 @@ grok_reference_init (decl, type, init)\n       if ((DECL_LANG_SPECIFIC (decl) == 0\n \t   || DECL_IN_AGGR_P (decl) == 0)\n \t  && ! DECL_THIS_EXTERN (decl))\n-\tcp_error (\"`%D' declared as reference but not initialized\", decl);\n+\terror (\"`%D' declared as reference but not initialized\", decl);\n       return NULL_TREE;\n     }\n \n@@ -7413,7 +7413,7 @@ grok_reference_init (decl, type, init)\n \n   if (TREE_CODE (init) == CONSTRUCTOR)\n     {\n-      cp_error (\"ISO C++ forbids use of initializer list to initialize reference `%D'\", decl);\n+      error (\"ISO C++ forbids use of initializer list to initialize reference `%D'\", decl);\n       return NULL_TREE;\n     }\n \n@@ -7446,7 +7446,7 @@ grok_reference_init (decl, type, init)\n     return NULL_TREE;\n   else if (tmp == NULL_TREE)\n     {\n-      cp_error (\"cannot initialize `%T' from `%T'\", type, TREE_TYPE (init));\n+      error (\"cannot initialize `%T' from `%T'\", type, TREE_TYPE (init));\n       return NULL_TREE;\n     }\n \n@@ -7507,12 +7507,12 @@ maybe_deduce_size_from_array_init (decl, init)\n       int failure = complete_array_type (type, initializer, do_default);\n \n       if (failure == 1)\n-\tcp_error (\"initializer fails to determine size of `%D'\", decl);\n+\terror (\"initializer fails to determine size of `%D'\", decl);\n \n       if (failure == 2)\n \t{\n \t  if (do_default)\n-\t    cp_error (\"array size missing in `%D'\", decl);\n+\t    error (\"array size missing in `%D'\", decl);\n \t  /* If a `static' var's size isn't known, make it extern as\n \t     well as static, so it does not get allocated.  If it's not\n \t     `static', then don't mark it extern; finish_incomplete_decl\n@@ -7524,7 +7524,7 @@ maybe_deduce_size_from_array_init (decl, init)\n       if (pedantic && TYPE_DOMAIN (type) != NULL_TREE\n \t  && tree_int_cst_lt (TYPE_MAX_VALUE (TYPE_DOMAIN (type)),\n \t\t\t      integer_zero_node))\n-\tcp_error (\"zero-size array `%D'\", decl);\n+\terror (\"zero-size array `%D'\", decl);\n \n       layout_decl (decl, 0);\n     }\n@@ -7557,7 +7557,7 @@ layout_var_decl (decl)\n       /* An automatic variable with an incomplete type: that is an error.\n \t Don't talk about array types here, since we took care of that\n \t message in grokdeclarator.  */\n-      cp_error (\"storage size of `%D' isn't known\", decl);\n+      error (\"storage size of `%D' isn't known\", decl);\n       TREE_TYPE (decl) = error_mark_node;\n     }\n #if 0\n@@ -7579,7 +7579,7 @@ layout_var_decl (decl)\n       if (TREE_CODE (DECL_SIZE (decl)) == INTEGER_CST)\n \tconstant_expression_warning (DECL_SIZE (decl));\n       else\n-\tcp_error (\"storage size of `%D' isn't constant\", decl);\n+\terror (\"storage size of `%D' isn't constant\", decl);\n     }\n \n   if (TREE_STATIC (decl)\n@@ -7659,7 +7659,7 @@ check_for_uninitialized_const_var (decl)\n       && CP_TYPE_CONST_P (type)\n       && !TYPE_NEEDS_CONSTRUCTING (type)\n       && !DECL_INITIAL (decl))\n-    cp_error (\"uninitialized const `%D'\", decl);\n+    error (\"uninitialized const `%D'\", decl);\n }\n \n /* Verify INIT (the initializer for DECL), and record the\n@@ -7694,18 +7694,18 @@ check_initializer (decl, init)\n \tinit = NULL_TREE;\n       else if (COMPLETE_TYPE_P (type) && !TREE_CONSTANT (TYPE_SIZE (type)))\n \t{\n-\t  cp_error (\"variable-sized object `%D' may not be initialized\", decl);\n+\t  error (\"variable-sized object `%D' may not be initialized\", decl);\n \t  init = NULL_TREE;\n \t}\n       else if (TREE_CODE (type) == ARRAY_TYPE\n \t       && !COMPLETE_TYPE_P (complete_type (TREE_TYPE (type))))\n \t{\n-\t  cp_error (\"elements of array `%#D' have incomplete type\", decl);\n+\t  error (\"elements of array `%#D' have incomplete type\", decl);\n \t  init = NULL_TREE;\n \t}\n       else if (TREE_CODE (type) != ARRAY_TYPE && !COMPLETE_TYPE_P (type))\n \t{\n-\t  cp_error (\"`%D' has incomplete type\", decl);\n+\t  error (\"`%D' has incomplete type\", decl);\n \t  TREE_TYPE (decl) = error_mark_node;\n \t  init = NULL_TREE;\n \t}\n@@ -7737,7 +7737,7 @@ check_initializer (decl, init)\n \t    {\n \t      if (TYPE_NON_AGGREGATE_CLASS (type))\n \t\t{\n-\t\t  cp_error (\"`%D' must be initialized by constructor, not by `{...}'\",\n+\t\t  error (\"`%D' must be initialized by constructor, not by `{...}'\",\n \t\t\t    decl);\n \t\t  init = error_mark_node;\n \t\t}\n@@ -7767,9 +7767,9 @@ check_initializer (decl, init)\n       if (! TYPE_NEEDS_CONSTRUCTING (core_type))\n \t{\n \t  if (CLASSTYPE_READONLY_FIELDS_NEED_INIT (core_type))\n-\t    cp_error (\"structure `%D' with uninitialized const members\", decl);\n+\t    error (\"structure `%D' with uninitialized const members\", decl);\n \t  if (CLASSTYPE_REF_FIELDS_NEED_INIT (core_type))\n-\t    cp_error (\"structure `%D' with uninitialized reference members\",\n+\t    error (\"structure `%D' with uninitialized reference members\",\n \t\t      decl);\n \t}\n \n@@ -8044,7 +8044,7 @@ cp_finish_decl (decl, init, asmspec_tree, flags)\n \n   if (init && TREE_CODE (init) == NAMESPACE_DECL)\n     {\n-      cp_error (\"cannot initialize `%D' to namespace `%D'\",\n+      error (\"cannot initialize `%D' to namespace `%D'\",\n \t\tdecl, init);\n       init = NULL_TREE;\n     }\n@@ -8101,7 +8101,7 @@ cp_finish_decl (decl, init, asmspec_tree, flags)\n \t  && IS_AGGR_TYPE (type) && DECL_NAME (decl))\n \t{\n \t  if (TREE_TYPE (DECL_NAME (decl)) && TREE_TYPE (decl) != type)\n-\t    cp_warning (\"shadowing previous type declaration of `%#D'\", decl);\n+\t    warning (\"shadowing previous type declaration of `%#D'\", decl);\n \t  set_identifier_type_value (DECL_NAME (decl), type);\n \t  CLASSTYPE_GOT_SEMICOLON (type) = 1;\n \t}\n@@ -8500,7 +8500,7 @@ expand_static_init (decl, init)\n   if (oldstatic)\n     {\n       if (TREE_PURPOSE (oldstatic) && init != NULL_TREE)\n-\tcp_error (\"multiple initializations given for `%D'\", decl);\n+\terror (\"multiple initializations given for `%D'\", decl);\n     }\n   else if (! toplevel_bindings_p ())\n     {\n@@ -8718,10 +8718,10 @@ member_function_or_else (ctype, cur_type, flags)\n   if (ctype && ctype != cur_type)\n     {\n       if (flags == DTOR_FLAG)\n-\tcp_error (\"destructor for alien class `%T' cannot be a member\",\n+\terror (\"destructor for alien class `%T' cannot be a member\",\n \t          ctype);\n       else\n-\tcp_error (\"constructor for alien class `%T' cannot be a member\",\n+\terror (\"constructor for alien class `%T' cannot be a member\",\n \t          ctype);\n       return 0;\n     }\n@@ -8740,11 +8740,11 @@ bad_specifiers (object, type, virtualp, quals, inlinep, friendp, raises)\n      int virtualp, quals, friendp, raises, inlinep;\n {\n   if (virtualp)\n-    cp_error (\"`%D' declared as a `virtual' %s\", object, type);\n+    error (\"`%D' declared as a `virtual' %s\", object, type);\n   if (inlinep)\n-    cp_error (\"`%D' declared as an `inline' %s\", object, type);\n+    error (\"`%D' declared as an `inline' %s\", object, type);\n   if (quals)\n-    cp_error (\"`const' and `volatile' function specifiers on `%D' invalid in %s declaration\",\n+    error (\"`const' and `volatile' function specifiers on `%D' invalid in %s declaration\",\n \t      object, type);\n   if (friendp)\n     cp_error_at (\"`%D' declared as a friend\", object);\n@@ -8863,7 +8863,7 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n \t\t/* Allow this; it's pretty common in C.  */;\n \t      else\n \t\t{\n-\t\t  cp_pedwarn (\"non-local function `%#D' uses anonymous type\",\n+\t\t  pedwarn (\"non-local function `%#D' uses anonymous type\",\n \t\t\t      decl);\n \t\t  if (DECL_ORIGINAL_TYPE (TYPE_NAME (t)))\n \t\t    cp_pedwarn_at (\"\\\n@@ -8872,7 +8872,7 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n \t\t}\n \t    }\n \t  else\n-\t    cp_pedwarn (\"non-local function `%#D' uses local type `%T'\",\n+\t    pedwarn (\"non-local function `%#D' uses local type `%T'\",\n \t\t\tdecl, t);\n \t}\n     }\n@@ -8895,7 +8895,7 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n   DECL_EXTERNAL (decl) = 1;\n   if (quals != NULL_TREE && TREE_CODE (type) == FUNCTION_TYPE)\n     {\n-      cp_error (\"%smember function `%D' cannot have `%T' method qualifier\",\n+      error (\"%smember function `%D' cannot have `%T' method qualifier\",\n \t\t(ctype ? \"static \" : \"non-\"), decl, TREE_VALUE (quals));\n       quals = NULL_TREE;\n     }\n@@ -8918,7 +8918,7 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n       && TREE_CODE (orig_declarator) == TEMPLATE_ID_EXPR)\n     {\n       if (funcdef_flag)\n-\tcp_error\n+\terror\n \t  (\"defining explicit specialization `%D' in friend declaration\",\n \t   orig_declarator);\n       else\n@@ -8929,7 +8929,7 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n \t  if (PROCESSING_REAL_TEMPLATE_DECL_P ())\n \t    {\n \t      /* Something like `template <class T> friend void f<T>()'.  */\n-\t      cp_error (\"invalid use of template-id `%D' in declaration of primary template\",\n+\t      error (\"invalid use of template-id `%D' in declaration of primary template\",\n \t\t\torig_declarator);\n \t      return NULL_TREE;\n \t    }\n@@ -8957,14 +8957,14 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n \n \t  if (has_default_arg)\n \t    {\n-\t      cp_error (\"default arguments are not allowed in declaration of friend template specialization `%D'\",\n+\t      error (\"default arguments are not allowed in declaration of friend template specialization `%D'\",\n \t\t\tdecl);\n \t      return NULL_TREE;\n \t    }\n \n \t  if (inlinep)\n \t    {\n-\t      cp_error (\"`inline' is not allowed in declaration of friend template specialization `%D'\",\n+\t      error (\"`inline' is not allowed in declaration of friend template specialization `%D'\",\n \t\t\tdecl);\n \t      return NULL_TREE;\n \t    }\n@@ -9026,7 +9026,7 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n \t  last_function_parms = TREE_CHAIN (last_function_parms);\n \t}\n       if (old_decl && DECL_ARTIFICIAL (old_decl))\n-\tcp_error (\"definition of implicitly-declared `%D'\", old_decl);\n+\terror (\"definition of implicitly-declared `%D'\", old_decl);\n \n       if (old_decl)\n \t{\n@@ -9038,7 +9038,7 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n \t  /* Attempt to merge the declarations.  This can fail, in\n \t     the case of some illegal specialization declarations.  */\n \t  if (!duplicate_decls (decl, old_decl))\n-\t    cp_error (\"no `%#D' member function declared in class `%T'\",\n+\t    error (\"no `%#D' member function declared in class `%T'\",\n \t\t      decl, ctype);\n \t  return old_decl;\n \t}\n@@ -9157,7 +9157,7 @@ grokvardecl (type, declarator, specbits_in, initialized, constp, in_namespace)\n \t  if (TYPE_ANONYMOUS_P (t))\n \t    /* Ignore for now; `enum { foo } e' is pretty common.  */;\n \t  else\n-\t    cp_pedwarn (\"non-local variable `%#D' uses local type `%T'\",\n+\t    pedwarn (\"non-local variable `%#D' uses local type `%T'\",\n \t\t\tdecl, t);\n \t}\n     }\n@@ -9247,7 +9247,7 @@ check_static_variable_definition (decl, type)\n      required.  */\n   if (CLASS_TYPE_P (type) || TREE_CODE (type) == REFERENCE_TYPE)\n     {\n-      cp_error (\"invalid in-class initialization of static data member of non-integral type `%T'\",\n+      error (\"invalid in-class initialization of static data member of non-integral type `%T'\",\n \t\ttype);\n       /* If we just return the declaration, crashes will sometimes\n \t occur.  We therefore return void_type_node, as if this was a\n@@ -9256,10 +9256,10 @@ check_static_variable_definition (decl, type)\n       return 1;\n     }\n   else if (!CP_TYPE_CONST_P (type))\n-    cp_error (\"ISO C++ forbids in-class initialization of non-const static member `%D'\",\n+    error (\"ISO C++ forbids in-class initialization of non-const static member `%D'\",\n \t      decl);\n   else if (pedantic && !INTEGRAL_TYPE_P (type))\n-    cp_pedwarn (\"ISO C++ forbids initialization of member constant `%D' of non-integral type `%T'\", decl, type);\n+    pedwarn (\"ISO C++ forbids initialization of member constant `%D' of non-integral type `%T'\", decl, type);\n \n   return 0;\n }\n@@ -9309,9 +9309,9 @@ compute_array_index_type (name, size)\n       && TREE_CODE (TREE_TYPE (size)) != BOOLEAN_TYPE)\n     {\n       if (name)\n-\tcp_error (\"size of array `%D' has non-integer type\", name);\n+\terror (\"size of array `%D' has non-integer type\", name);\n       else\n-\tcp_error (\"size of array has non-integer type\");\n+\terror (\"size of array has non-integer type\");\n       size = integer_one_node;\n     }\n \n@@ -9331,9 +9331,9 @@ compute_array_index_type (name, size)\n       if (INT_CST_LT (size, integer_zero_node))\n \t{\n \t  if (name)\n-\t    cp_error (\"size of array `%D' is negative\", name);\n+\t    error (\"size of array `%D' is negative\", name);\n \t  else\n-\t    cp_error (\"size of array is negative\");\n+\t    error (\"size of array is negative\");\n \t  size = integer_one_node;\n \t}\n       /* Except that an extension we allow zero-sized arrays.  We\n@@ -9342,19 +9342,19 @@ compute_array_index_type (name, size)\n       else if (integer_zerop (size) && pedantic && !in_system_header)\n \t{\n \t  if (name)\n-\t    cp_pedwarn (\"ISO C++ forbids zero-size array `%D'\", name);\n+\t    pedwarn (\"ISO C++ forbids zero-size array `%D'\", name);\n \t  else\n-\t    cp_pedwarn (\"ISO C++ forbids zero-size array\");\n+\t    pedwarn (\"ISO C++ forbids zero-size array\");\n \t}\n     }\n   else if (TREE_CONSTANT (size))\n     {\n       /* `(int) &fn' is not a valid array bound.  */\n       if (name)\n-\tcp_error (\"size of array `%D' is not an integral constant-expression\",\n+\terror (\"size of array `%D' is not an integral constant-expression\",\n \t\t  name);\n       else\n-\tcp_error (\"size of array is not an integral constant-expression\");\n+\terror (\"size of array is not an integral constant-expression\");\n     }\n \n   /* Compute the index of the largest element in the array.  It is\n@@ -9372,10 +9372,10 @@ compute_array_index_type (name, size)\n       if (pedantic)\n \t{\n \t  if (name)\n-\t    cp_pedwarn (\"ISO C++ forbids variable-size array `%D'\",\n+\t    pedwarn (\"ISO C++ forbids variable-size array `%D'\",\n \t\t\tname);\n \t  else\n-\t    cp_pedwarn (\"ISO C++ forbids variable-size array\");\n+\t    pedwarn (\"ISO C++ forbids variable-size array\");\n \t}\n \n       /* Create a variable-sized array index type.  */\n@@ -9445,9 +9445,9 @@ create_array_type_for_decl (name, type, size)\n   if (error_msg)\n     {\n       if (name)\n-\tcp_error (\"declaration of `%D' as %s\", name, error_msg);\n+\terror (\"declaration of `%D' as %s\", name, error_msg);\n       else\n-\tcp_error (\"creating %s\", error_msg);\n+\terror (\"creating %s\", error_msg);\n \n       return error_mark_node;\n     }\n@@ -9459,10 +9459,10 @@ create_array_type_for_decl (name, type, size)\n   if (TREE_CODE (type) == ARRAY_TYPE && !TYPE_DOMAIN (type))\n     {\n       if (name)\n-\tcp_error (\"declaration of `%D' as multidimensional array must have bounds for all dimensions except the first\",\n+\terror (\"declaration of `%D' as multidimensional array must have bounds for all dimensions except the first\",\n \t\t  name);\n       else\n-\tcp_error (\"multidimensional array must have bounds for all dimensions except the first\");\n+\terror (\"multidimensional array must have bounds for all dimensions except the first\");\n \n       return error_mark_node;\n     }\n@@ -9491,22 +9491,22 @@ check_special_function_return_type (sfk, type, optype)\n     {\n     case sfk_constructor:\n       if (type)\n-\tcp_error (\"return type specification for constructor invalid\");\n+\terror (\"return type specification for constructor invalid\");\n \n       type = void_type_node;\n       break;\n \n     case sfk_destructor:\n       if (type)\n-\tcp_error (\"return type specification for destructor invalid\");\n+\terror (\"return type specification for destructor invalid\");\n       type = void_type_node;\n       break;\n \n     case sfk_conversion:\n       if (type && !same_type_p (type, optype))\n-\tcp_error (\"operator `%T' declared to return `%T'\", optype, type);\n+\terror (\"operator `%T' declared to return `%T'\", optype, type);\n       else if (type)\n-\tcp_pedwarn (\"return type specified for `operator %T'\",  optype);\n+\tpedwarn (\"return type specified for `operator %T'\",  optype);\n       type = optype;\n       break;\n \n@@ -9695,7 +9695,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \n \t      if (rename)\n \t\t{\n-\t\t  cp_error (\"destructor `%T' must match class name `%T'\",\n+\t\t  error (\"destructor `%T' must match class name `%T'\",\n \t\t\t    name, rename);\n \t\t  TREE_OPERAND (decl, 0) = rename;\n \t\t}\n@@ -9745,7 +9745,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t    finish_decl (decl, init, NULL_TREE);\n \t\t  }\n \t\telse\n-\t\t  cp_error (\"invalid declarator\");\n+\t\t  error (\"invalid declarator\");\n \t\treturn 0;\n \t      }\n \t    innermost_code = TREE_CODE (decl);\n@@ -9798,7 +9798,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \n \t    if (C_IS_RESERVED_WORD (dname))\n \t      {\n-\t\tcp_error (\"declarator-id missing; using reserved word `%D'\",\n+\t\terror (\"declarator-id missing; using reserved word `%D'\",\n \t\t\t  dname);\n \t\tname = IDENTIFIER_POINTER (dname);\n \t      }\n@@ -9842,9 +9842,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t      else if (TREE_CODE (cname) == TEMPLATE_TYPE_PARM\n \t\t       || TREE_CODE (cname) == BOUND_TEMPLATE_TEMPLATE_PARM)\n \t\t{\n-\t\t  cp_error (\"`%T::%D' is not a valid declarator\", cname,\n+\t\t  error (\"`%T::%D' is not a valid declarator\", cname,\n \t\t\t    TREE_OPERAND (decl, 1));\n-\t\t  cp_error (\"  perhaps you want `typename %T::%D' to make it a type\",\n+\t\t  error (\"  perhaps you want `typename %T::%D' to make it a type\",\n \t\t\t    cname, TREE_OPERAND (decl, 1));\n \t\t  return void_type_node;\n \t\t}\n@@ -9856,7 +9856,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t{\n \t\t  if (! UNIQUELY_DERIVED_FROM_P (cname, ctype))\n \t\t    {\n-\t\t      cp_error (\"type `%T' is not derived from type `%T'\",\n+\t\t      error (\"type `%T' is not derived from type `%T'\",\n \t\t\t\tcname, ctype);\n \t\t      TREE_OPERAND (decl, 0) = NULL_TREE;\n \t\t    }\n@@ -9902,9 +9902,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t  case TYPE_DECL:\n \t    /* Parse error puts this typespec where\n \t       a declarator should go.  */\n-\t    cp_error (\"`%T' specified as declarator-id\", DECL_NAME (decl));\n+\t    error (\"`%T' specified as declarator-id\", DECL_NAME (decl));\n \t    if (TREE_TYPE (decl) == current_class_type)\n-\t      cp_error (\"  perhaps you want `%T' for a constructor\",\n+\t      error (\"  perhaps you want `%T' for a constructor\",\n \t\t\tcurrent_class_name);\n \t    dname = DECL_NAME (decl);\n \t    name = IDENTIFIER_POINTER (dname);\n@@ -9918,8 +9918,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t    break;\n \n \t  default:\n-\t    cp_compiler_error (\"`%D' as declarator\", decl);\n-\t    return 0; /* We used to do a 155 abort here.  */\n+\t    internal_error (\"`%D' as declarator\", decl);\n \t  }\n       }\n   }\n@@ -9934,7 +9933,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n       && innermost_code != CALL_EXPR\n       && ! (ctype && declspecs == NULL_TREE))\n     {\n-      cp_error (\"declaration of `%D' as non-function\", dname);\n+      error (\"declaration of `%D' as non-function\", dname);\n       return void_type_node;\n     }\n \n@@ -10005,7 +10004,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t  if (id == ridpointers[(int) RID_BOOL])\n \t\t    error (\"`bool' is now a keyword\");\n \t\t  else\n-\t\t    cp_error (\"extraneous `%T' ignored\", id);\n+\t\t    error (\"extraneous `%T' ignored\", id);\n \t\t}\n \t      else\n \t\t{\n@@ -10021,7 +10020,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t  if (IDENTIFIER_HAS_TYPE_VALUE (id))\n \t    {\n \t      if (type)\n-\t\tcp_error (\"multiple declarations `%T' and `%T'\", type, id);\n+\t\terror (\"multiple declarations `%T' and `%T'\", type, id);\n \t      else\n \t\ttype = IDENTIFIER_TYPE_VALUE (id);\n \t      goto found;\n@@ -10055,7 +10054,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n       else if (TREE_CODE (id) == TYPE_DECL)\n \t{\n \t  if (type)\n-\t    cp_error (\"multiple declarations `%T' and `%T'\", type,\n+\t    error (\"multiple declarations `%T' and `%T'\", type,\n \t\t      TREE_TYPE (id));\n \t  else\n \t    {\n@@ -10126,10 +10125,10 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n       if (in_system_header || flag_ms_extensions)\n \t/* Allow it, sigh.  */;\n       else if (pedantic || ! is_main)\n-\tcp_pedwarn (\"ISO C++ forbids declaration of `%s' with no type\",\n+\tpedwarn (\"ISO C++ forbids declaration of `%s' with no type\",\n \t\t    name);\n       else if (warn_return_type)\n-\tcp_warning (\"ISO C++ forbids declaration of `%s' with no type\",\n+\twarning (\"ISO C++ forbids declaration of `%s' with no type\",\n \t\t    name);\n \n       type = integer_type_node;\n@@ -10139,7 +10138,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n     {\n       /* The implicit typename extension is deprecated and will be\n \t removed.  Warn about its use now.  */\n-      cp_warning (\"`%T' is implicitly a typename\", type);\n+      warning (\"`%T' is implicitly a typename\", type);\n       cp_deprecated (\"implicit typename\");\n \n       /* Now remove its implicitness, so that we don't warn again.\n@@ -10296,7 +10295,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n       && (RIDBIT_SETP (RID_CONST, specbits)\n \t  || RIDBIT_SETP (RID_VOLATILE, specbits)\n \t  || RIDBIT_SETP (RID_RESTRICT, specbits)))\n-    cp_error (\"qualifiers are not allowed on declaration of `operator %T'\",\n+    error (\"qualifiers are not allowed on declaration of `operator %T'\",\n \t      ctor_return_type);\n \n   /* Set CONSTP if this declaration is `const', whether by\n@@ -10324,7 +10323,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \n   if (virtualp && staticp == 2)\n     {\n-      cp_error (\"member `%D' cannot be declared both virtual and static\",\n+      error (\"member `%D' cannot be declared both virtual and static\",\n \t\tdname);\n       staticp = 0;\n     }\n@@ -10551,7 +10550,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t&& TYPE_DOMAIN (type) != NULL_TREE\n \t\t&& !TREE_CONSTANT (TYPE_MAX_VALUE (TYPE_DOMAIN (type))))\n \t      {\n-\t\tcp_error (\"size of member `%D' is not constant\", dname);\n+\t\terror (\"size of member `%D' is not constant\", dname);\n \t\t/* Proceed with arbitrary constant size, so that offset\n \t\t   computations don't get confused. */\n \t\ttype = create_array_type_for_decl (dname, TREE_TYPE (type),\n@@ -10633,7 +10632,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t      error (\"destructor cannot be static member function\");\n \t\t    if (quals)\n \t\t      {\n-\t\t\tcp_error (\"destructors may not be `%s'\",\n+\t\t\terror (\"destructors may not be `%s'\",\n \t\t\t\t  IDENTIFIER_POINTER (TREE_VALUE (quals)));\n \t\t\tquals = NULL_TREE;\n \t\t      }\n@@ -10662,7 +10661,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t      }\n \t\t    if (quals)\n \t\t      {\n-\t\t\tcp_error (\"constructors may not be `%s'\",\n+\t\t\terror (\"constructors may not be `%s'\",\n \t\t\t\t  IDENTIFIER_POINTER (TREE_VALUE (quals)));\n \t\t\tquals = NULL_TREE;\n \t\t      }\n@@ -10702,7 +10701,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\tif (decl_context == NORMAL)\n \t\t  error (\"friend declaration not in class definition\");\n \t\tif (current_function_decl && funcdef_flag)\n-\t\t  cp_error (\"can't define friend function `%s' in a local class definition\",\n+\t\t  error (\"can't define friend function `%s' in a local class definition\",\n \t\t\t    name);\n \t      }\n \n@@ -10726,7 +10725,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \n                 if (arg_types != void_list_node)\n \t\t  {\n-\t\t    cp_error (\"destructors may not have parameters\");\n+\t\t    error (\"destructors may not have parameters\");\n \t\t    arg_types = void_list_node;\n \t\t    last_function_parms = NULL_TREE;\n \t\t  }\n@@ -10767,7 +10766,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t      && (TREE_CODE (TREE_TYPE (type)) == VOID_TYPE\n \t\t  || TREE_CODE (TREE_TYPE (type)) == REFERENCE_TYPE))\n \t    {\n-\t      cp_error (\"cannot declare pointer to `%#T' member\",\n+\t      error (\"cannot declare pointer to `%#T' member\",\n \t\t\tTREE_TYPE (type));\n \t      type = TREE_TYPE (type);\n \t    }\n@@ -10946,7 +10945,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t       Is this ill-formed?  */\n \n \t\t    if (pedantic)\n-\t\t      cp_pedwarn (\"extra qualification `%T::' on member `%s' ignored\",\n+\t\t      pedwarn (\"extra qualification `%T::' on member `%s' ignored\",\n \t\t\t\t  ctype, name);\n \t\t  }\n \t\telse if (TREE_CODE (type) == FUNCTION_TYPE)\n@@ -10956,7 +10955,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t\t\t\t\t      TYPE_ARG_TYPES (type));\n \t\t    else\n \t\t      {\n-\t\t\tcp_error (\"cannot declare member function `%T::%s' within `%T'\",\n+\t\t\terror (\"cannot declare member function `%T::%s' within `%T'\",\n \t\t\t\t  ctype, name, current_class_type);\n \t\t\treturn void_type_node;\n \t\t      }\n@@ -10971,7 +10970,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \n \t\t    if (current_class_type)\n \t\t      {\n-\t\t\tcp_error (\"cannot declare member `%T::%s' within `%T'\",\n+\t\t\terror (\"cannot declare member `%T::%s' within `%T'\",\n \t\t\t\t  ctype, name, current_class_type);\n \t\t\treturn void_type_node;\n \t\t      }\n@@ -11093,7 +11092,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n     /* OK */;\n   else if (TREE_CODE (declarator) == TEMPLATE_ID_EXPR)\n     {\n-      cp_error (\"template-id `%D' used as a declarator\", declarator);\n+      error (\"template-id `%D' used as a declarator\", declarator);\n       declarator = dname;\n     }\n   else\n@@ -11114,7 +11113,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n       if (decl_context == FIELD)\n \t{\n \t  if (declarator == constructor_name (current_class_type))\n-\t    cp_pedwarn (\"ISO C++ forbids nested type `%D' with same name as enclosing class\",\n+\t    pedwarn (\"ISO C++ forbids nested type `%D' with same name as enclosing class\",\n \t\t\tdeclarator);\n \t  decl = build_lang_decl (TYPE_DECL, declarator, type);\n \t}\n@@ -11238,12 +11237,12 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t{\n \t  if (type_quals != TYPE_UNQUALIFIED)\n \t    {\n-\t      cp_error (\"type qualifiers specified for friend class declaration\");\n+\t      error (\"type qualifiers specified for friend class declaration\");\n \t      type_quals = TYPE_UNQUALIFIED;\n \t    }\n \t  if (inlinep)\n \t    {\n-\t      cp_error (\"`inline' specified for friend class declaration\");\n+\t      error (\"`inline' specified for friend class declaration\");\n \t      inlinep = 0;\n \t    }\n \n@@ -11253,14 +11252,14 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t\t\t|| IMPLICIT_TYPENAME_P (type)))\n \t    {\n \t      if (TREE_CODE (type) == TEMPLATE_TYPE_PARM)\n-\t        cp_pedwarn (\"template parameters cannot be friends\");\n+\t        pedwarn (\"template parameters cannot be friends\");\n \t      else if (TREE_CODE (type) == TYPENAME_TYPE)\n-\t        cp_pedwarn (\"\\\n+\t        pedwarn (\"\\\n friend declaration requires class-key, i.e. `friend class %T::%T'\",\n \t\t\t    constructor_name (current_class_type),\n \t\t\t    TYPE_IDENTIFIER (type));\n \t      else\n-\t        cp_pedwarn (\"\\\n+\t        pedwarn (\"\\\n friend declaration requires class-key, i.e. `friend %#T'\",\n \t\t\t    type);\n \t    }\n@@ -11276,7 +11275,7 @@ friend declaration requires class-key, i.e. `friend %#T'\",\n \t      if (current_class_type)\n \t\tmake_friend_class (current_class_type, TYPE_MAIN_VARIANT (type));\n \t      else\n-\t\tcp_error (\"trying to make class `%T' a friend of global scope\",\n+\t\terror (\"trying to make class `%T' a friend of global scope\",\n \t\t          type);\n \n \t      type = void_type_node;\n@@ -11287,7 +11286,7 @@ friend declaration requires class-key, i.e. `friend %#T'\",\n \t  if (ctype == NULL_TREE)\n \t    {\n \t      if (TREE_CODE (type) != METHOD_TYPE)\n-\t        cp_error (\"invalid qualifiers on non-member function type\");\n+\t        error (\"invalid qualifiers on non-member function type\");\n \t      else\n \t        ctype = TYPE_METHOD_BASETYPE (type);\n \t    }\n@@ -11306,7 +11305,7 @@ friend declaration requires class-key, i.e. `friend %#T'\",\n \t   && TREE_CODE (type) != UNION_TYPE\n \t   && ! bitfield)\n     {\n-      cp_error (\"abstract declarator `%T' used as declaration\", type);\n+      error (\"abstract declarator `%T' used as declaration\", type);\n       declarator = make_anon_name ();\n     }\n \n@@ -11383,7 +11382,7 @@ friend declaration requires class-key, i.e. `friend %#T'\",\n \telse if (in_namespace && !friendp)\n \t  {\n \t    /* Something like struct S { int N::j; };  */\n-\t    cp_error (\"invalid use of `::'\");\n+\t    error (\"invalid use of `::'\");\n \t    decl = NULL_TREE;\n \t  }\n \telse if (TREE_CODE (type) == FUNCTION_TYPE)\n@@ -11395,7 +11394,7 @@ friend declaration requires class-key, i.e. `friend %#T'\",\n \t       typedefs.  */\n \t    if (friendp && declarator == ridpointers[(int) RID_SIGNED])\n \t      {\n-\t\tcp_error (\"function `%D' cannot be declared friend\",\n+\t\terror (\"function `%D' cannot be declared friend\",\n \t\t\t  declarator);\n \t\tfriendp = 0;\n \t      }\n@@ -11407,7 +11406,7 @@ friend declaration requires class-key, i.e. `friend %#T'\",\n \n \t\tif (ctype == NULL_TREE)\n \t\t  {\n-\t\t    cp_error (\"can't make `%D' into a method -- not in a class\",\n+\t\t    error (\"can't make `%D' into a method -- not in a class\",\n \t\t\t      declarator);\n \t\t    return void_type_node;\n \t\t  }\n@@ -11416,7 +11415,7 @@ friend declaration requires class-key, i.e. `friend %#T'\",\n \t\t   ARM 9.5 */\n \t\tif (virtualp && TREE_CODE (ctype) == UNION_TYPE)\n \t\t  {\n-\t\t    cp_error (\"function `%D' declared virtual inside a union\",\n+\t\t    error (\"function `%D' declared virtual inside a union\",\n \t\t\t      declarator);\n \t\t    return void_type_node;\n \t\t  }\n@@ -11428,7 +11427,7 @@ friend declaration requires class-key, i.e. `friend %#T'\",\n \t\t  {\n \t\t    if (virtualp)\n \t\t      {\n-\t\t\tcp_error (\"`%D' cannot be declared virtual, since it is always static\",\n+\t\t\terror (\"`%D' cannot be declared virtual, since it is always static\",\n \t\t\t\t  declarator);\n \t\t\tvirtualp = 0;\n \t\t      }\n@@ -11501,9 +11500,9 @@ friend declaration requires class-key, i.e. `friend %#T'\",\n \t\t && (TREE_CODE (type) != ARRAY_TYPE || initialized == 0))\n \t  {\n \t    if (declarator)\n-\t      cp_error (\"field `%D' has incomplete type\", declarator);\n+\t      error (\"field `%D' has incomplete type\", declarator);\n \t    else\n-\t      cp_error (\"name `%T' has incomplete type\", type);\n+\t      error (\"name `%T' has incomplete type\", type);\n \n \t    /* If we're instantiating a template, tell them which\n \t       instantiation made the field's type be incomplete.  */\n@@ -11512,7 +11511,7 @@ friend declaration requires class-key, i.e. `friend %#T'\",\n \t\t&& IDENTIFIER_TEMPLATE (TYPE_IDENTIFIER (current_class_type))\n \t\t&& declspecs && TREE_VALUE (declspecs)\n \t\t&& TREE_TYPE (TREE_VALUE (declspecs)) == type)\n-\t      cp_error (\"  in instantiation of template `%T'\",\n+\t      error (\"  in instantiation of template `%T'\",\n \t\t\tcurrent_class_type);\n \n \t    type = error_mark_node;\n@@ -11581,9 +11580,9 @@ friend declaration requires class-key, i.e. `friend %#T'\",\n \t\t       the rest of the compiler does not correctly\n \t\t       handle the initialization unless the member is\n \t\t       static so we make it static below.  */\n-\t\t    cp_pedwarn (\"ISO C++ forbids initialization of member `%D'\",\n+\t\t    pedwarn (\"ISO C++ forbids initialization of member `%D'\",\n \t\t\t\tdeclarator);\n-\t\t    cp_pedwarn (\"making `%D' static\", declarator);\n+\t\t    pedwarn (\"making `%D' static\", declarator);\n \t\t    staticp = 1;\n \t\t  }\n \n@@ -11607,7 +11606,7 @@ friend declaration requires class-key, i.e. `friend %#T'\",\n \t\t   to change that in TC 1 so that they are allowed in\n \t\t   classes with no user-defined constructors.  */\n \t\t&& staticp)\n-\t      cp_pedwarn (\"ISO C++ forbids static data member `%D' with same name as enclosing class\",\n+\t      pedwarn (\"ISO C++ forbids static data member `%D' with same name as enclosing class\",\n \t\t\t  declarator);\n \n \t    if (staticp)\n@@ -11699,7 +11698,7 @@ friend declaration requires class-key, i.e. `friend %#T'\",\n \t       declaring main to be static.  */\n \t    if (TREE_CODE (type) == METHOD_TYPE)\n \t      {\n-\t\tcp_pedwarn (\"cannot declare member function `%D' to have static linkage\", decl);\n+\t\tpedwarn (\"cannot declare member function `%D' to have static linkage\", decl);\n \t\tillegal_static = 1;\n \t      }\n \t    else if (current_function_decl)\n@@ -11733,18 +11732,18 @@ friend declaration requires class-key, i.e. `friend %#T'\",\n \t    DECL_CONTEXT (decl) = ctype;\n \t    if (staticp == 1)\n \t      {\n-                cp_pedwarn (\"`static' may not be used when defining (as opposed to declaring) a static data member\");\n+                pedwarn (\"`static' may not be used when defining (as opposed to declaring) a static data member\");\n \t        staticp = 0;\n \t\tRIDBIT_RESET (RID_STATIC, specbits);\n \t      }\n \t    if (RIDBIT_SETP (RID_REGISTER, specbits) && TREE_STATIC (decl))\n \t      {\n-\t\tcp_error (\"static member `%D' declared `register'\", decl);\n+\t\terror (\"static member `%D' declared `register'\", decl);\n \t\tRIDBIT_RESET (RID_REGISTER, specbits);\n \t      }\n \t    if (RIDBIT_SETP (RID_EXTERN, specbits) && pedantic)\n \t      {\n-\t        cp_pedwarn (\"cannot explicitly declare member `%#D' to have extern linkage\",\n+\t        pedwarn (\"cannot explicitly declare member `%#D' to have extern linkage\",\n \t\t\t    decl);\n \t\tRIDBIT_RESET (RID_EXTERN, specbits);\n \t      }\n@@ -11916,10 +11915,10 @@ check_default_argument (decl, arg)\n       || !can_convert_arg (decl_type, TREE_TYPE (arg), arg))\n     {\n       if (decl)\n-\tcp_error (\"default argument for `%#D' has type `%T'\",\n+\terror (\"default argument for `%#D' has type `%T'\",\n \t\t  decl, TREE_TYPE (arg));\n       else\n-\tcp_error (\"default argument for parameter of type `%T' has type `%T'\",\n+\terror (\"default argument for parameter of type `%T' has type `%T'\",\n \t\t  decl_type, TREE_TYPE (arg));\n \n       return error_mark_node;\n@@ -11936,7 +11935,7 @@ check_default_argument (decl, arg)\n \t\t\t\t      NULL);\n   if (var)\n     {\n-      cp_error (\"default argument `%E' uses local variable `%D'\",\n+      error (\"default argument `%E' uses local variable `%D'\",\n \t\targ, var);\n       return error_mark_node;\n     }\n@@ -11980,7 +11979,7 @@ grokparms (first_parm)\n \t{\n \t  /* Give various messages as the need arises.  */\n \t  if (TREE_CODE (decl) == STRING_CST)\n-\t    cp_error (\"invalid string constant `%E'\", decl);\n+\t    error (\"invalid string constant `%E'\", decl);\n \t  else if (TREE_CODE (decl) == INTEGER_CST)\n \t    error (\"invalid integer constant in parameter list, did you forget to give parameter name?\");\n \t  continue;\n@@ -12016,13 +12015,13 @@ grokparms (first_parm)\n \t  type = TYPE_MAIN_VARIANT (type);\n \t  if (TREE_CODE (type) == METHOD_TYPE)\n \t    {\n-\t      cp_error (\"parameter `%D' invalidly declared method type\", decl);\n+\t      error (\"parameter `%D' invalidly declared method type\", decl);\n \t      type = build_pointer_type (type);\n \t      TREE_TYPE (decl) = type;\n \t    }\n \t  else if (TREE_CODE (type) == OFFSET_TYPE)\n \t    {\n-\t      cp_error (\"parameter `%D' invalidly declared offset type\", decl);\n+\t      error (\"parameter `%D' invalidly declared offset type\", decl);\n \t      type = build_pointer_type (type);\n \t      TREE_TYPE (decl) = type;\n \t    }\n@@ -12046,7 +12045,7 @@ grokparms (first_parm)\n \t          t = TREE_TYPE (t);\n \t        }\n \t      if (TREE_CODE (t) == ARRAY_TYPE)\n-\t\tcp_error (\"parameter `%D' includes %s to array of unknown bound `%T'\",\n+\t\terror (\"parameter `%D' includes %s to array of unknown bound `%T'\",\n \t\t\t  decl, ptr ? \"pointer\" : \"reference\", t);\n \t    }\n \n@@ -12213,7 +12212,7 @@ grok_ctor_properties (ctype, decl)\n      \t or implicitly defined), there's no need to worry about their\n      \t existence.  Theoretically, they should never even be\n      \t instantiated, but that's hard to forestall.  */\n-      cp_error (\"invalid constructor; you probably meant `%T (const %T&)'\",\n+      error (\"invalid constructor; you probably meant `%T (const %T&)'\",\n \t\tctype, ctype);\n       SET_IDENTIFIER_ERROR_LOCUS (DECL_NAME (decl), ctype);\n       return 0;\n@@ -12364,13 +12363,13 @@ grok_op_properties (decl, friendp)\n \t      || operator_code == COMPONENT_REF\n \t      || operator_code == ARRAY_REF\n \t      || operator_code == NOP_EXPR)\n-\t    cp_error (\"`%D' must be a nonstatic member function\", decl);\n+\t    error (\"`%D' must be a nonstatic member function\", decl);\n \t  else\n \t    {\n \t      tree p = argtypes;\n \n \t      if (DECL_STATIC_FUNCTION_P (decl))\n-\t\tcp_error (\"`%D' must be either a non-static member function or a non-member function\", decl);\n+\t\terror (\"`%D' must be either a non-static member function or a non-member function\", decl);\n \n \t      if (p)\n \t\tfor (; TREE_CODE (TREE_VALUE (p)) != VOID_TYPE ; p = TREE_CHAIN (p))\n@@ -12386,7 +12385,7 @@ grok_op_properties (decl, friendp)\n \t\t\t|| TREE_CODE (arg) == BOUND_TEMPLATE_TEMPLATE_PARM)\n \t\t      goto foundaggr;\n \t\t  }\n-\t      cp_error\n+\t      error\n \t\t(\"`%D' must have an argument of class or enumerated type\",\n \t\t decl);\n \t    foundaggr:\n@@ -12426,7 +12425,7 @@ grok_op_properties (decl, friendp)\n       if (operator_code == COND_EXPR)\n \t{\n \t  /* 13.4.0.3 */\n-\t  cp_error (\"ISO C++ prohibits overloading operator ?:\");\n+\t  error (\"ISO C++ prohibits overloading operator ?:\");\n \t}\n       else if (ambi_op_p (operator_code))\n \t{\n@@ -12476,20 +12475,20 @@ grok_op_properties (decl, friendp)\n \t\t  && ! same_type_p (TREE_VALUE (TREE_CHAIN (argtypes)), integer_type_node))\n \t\t{\n \t\t  if (methodp)\n-\t\t    cp_error (\"postfix `%D' must take `int' as its argument\",\n+\t\t    error (\"postfix `%D' must take `int' as its argument\",\n \t\t\t      decl);\n \t\t  else\n-\t\t    cp_error\n+\t\t    error\n \t\t      (\"postfix `%D' must take `int' as its second argument\",\n \t\t       decl);\n \t\t}\n \t    }\n \t  else\n \t    {\n \t      if (methodp)\n-\t\tcp_error (\"`%D' must take either zero or one argument\", decl);\n+\t\terror (\"`%D' must take either zero or one argument\", decl);\n \t      else\n-\t\tcp_error (\"`%D' must take either one or two arguments\", decl);\n+\t\terror (\"`%D' must take either one or two arguments\", decl);\n \t    }\n \n \t  /* More Effective C++ rule 6.  */\n@@ -12510,13 +12509,13 @@ grok_op_properties (decl, friendp)\n \t\t  if (TREE_CODE (ret) != REFERENCE_TYPE\n \t\t      || !same_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (ret)),\n \t\t\t\t       arg))\n-\t\t    cp_warning (\"prefix `%D' should return `%T'\", decl,\n+\t\t    warning (\"prefix `%D' should return `%T'\", decl,\n \t\t\t\tbuild_reference_type (arg));\n \t\t}\n \t      else\n \t\t{\n \t\t  if (!same_type_p (TYPE_MAIN_VARIANT (ret), arg))\n-\t\t    cp_warning (\"postfix `%D' should return `%T'\", decl, arg);\n+\t\t    warning (\"postfix `%D' should return `%T'\", decl, arg);\n \t\t}\n \t    }\n \t}\n@@ -12525,27 +12524,27 @@ grok_op_properties (decl, friendp)\n \t  if (arity != 1)\n \t    {\n \t      if (methodp)\n-\t\tcp_error (\"`%D' must take `void'\", decl);\n+\t\terror (\"`%D' must take `void'\", decl);\n \t      else\n-\t\tcp_error (\"`%D' must take exactly one argument\", decl);\n+\t\terror (\"`%D' must take exactly one argument\", decl);\n \t    }\n \t}\n       else /* if (binary_op_p (operator_code)) */\n \t{\n \t  if (arity != 2)\n \t    {\n \t      if (methodp)\n-\t\tcp_error (\"`%D' must take exactly one argument\", decl);\n+\t\terror (\"`%D' must take exactly one argument\", decl);\n \t      else\n-\t\tcp_error (\"`%D' must take exactly two arguments\", decl);\n+\t\terror (\"`%D' must take exactly two arguments\", decl);\n \t    }\n \n \t  /* More Effective C++ rule 7.  */\n \t  if (warn_ecpp\n \t      && (operator_code == TRUTH_ANDIF_EXPR\n \t\t  || operator_code == TRUTH_ORIF_EXPR\n \t\t  || operator_code == COMPOUND_EXPR))\n-\t    cp_warning (\"user-defined `%D' always evaluates both arguments\",\n+\t    warning (\"user-defined `%D' always evaluates both arguments\",\n \t\t\tdecl);\n \t}\n \n@@ -12557,7 +12556,7 @@ grok_op_properties (decl, friendp)\n \t      || operator_code == TRUNC_DIV_EXPR\n \t      || operator_code == MULT_EXPR)\n \t  && TREE_CODE (TREE_TYPE (TREE_TYPE (decl))) == REFERENCE_TYPE)\n-\tcp_warning (\"`%D' should return by value\", decl);\n+\twarning (\"`%D' should return by value\", decl);\n \n       /* [over.oper]/8 */\n       for (; argtypes && argtypes != void_list_node;\n@@ -12569,10 +12568,10 @@ grok_op_properties (decl, friendp)\n \t\t|| operator_code == POSTDECREMENT_EXPR)\n               {\n                 if (pedantic)\n-                  cp_pedwarn (\"`%D' cannot have default arguments\", decl);\n+                  pedwarn (\"`%D' cannot have default arguments\", decl);\n               }\n             else\n-              cp_error (\"`%D' cannot have default arguments\", decl);\n+              error (\"`%D' cannot have default arguments\", decl);\n           }\n \n     }\n@@ -12665,10 +12664,10 @@ xref_tag (code_type_node, name, globalize)\n       static int explained;\n       tree shadowed;\n \n-      cp_warning (\"`%s %T' declares a new type at namespace scope\",\n+      warning (\"`%s %T' declares a new type at namespace scope\",\n \t\t  tag_name (tag_code), name);\n       if (!explained++)\n-\tcp_warning (\"  names from dependent base classes are not visible to unqualified name lookup - to refer to the inherited type, say `%s %T::%T'\",\n+\twarning (\"  names from dependent base classes are not visible to unqualified name lookup - to refer to the inherited type, say `%s %T::%T'\",\n \t\t    tag_name (tag_code),\n \t\t    constructor_name (current_class_type),\n \t\t    TYPE_IDENTIFIER (t));\n@@ -12704,10 +12703,10 @@ xref_tag (code_type_node, name, globalize)\n \t     elaborated-type-specifier is ill-formed.  */\n \t  if (t != TYPE_MAIN_VARIANT (t)\n \t      || (CLASS_TYPE_P (t) && TYPE_WAS_ANONYMOUS (t)))\n-\t    cp_pedwarn (\"using typedef-name `%D' after `%s'\",\n+\t    pedwarn (\"using typedef-name `%D' after `%s'\",\n \t\t\tTYPE_NAME (t), tag_name (tag_code));\n \t  else if (TREE_CODE (t) == TEMPLATE_TYPE_PARM)\n-\t    cp_error (\"using template type parameter `%T' after `%s'\",\n+\t    error (\"using template type parameter `%T' after `%s'\",\n \t\t      t, tag_name (tag_code));\n \n \t  ref = t;\n@@ -12789,7 +12788,7 @@ xref_tag (code_type_node, name, globalize)\n \t the forward-reference will be altered into a real type.  */\n       if (code == ENUMERAL_TYPE)\n \t{\n-\t  cp_error (\"use of enum `%#D' without previous declaration\", name);\n+\t  error (\"use of enum `%#D' without previous declaration\", name);\n \n \t  ref = make_node (ENUMERAL_TYPE);\n \n@@ -12899,7 +12898,7 @@ xref_basetypes (code_type_node, name, ref, binfo)\n \n   if (tag_code == union_type)\n     {\n-      cp_error (\"derived union `%T' invalid\", ref);\n+      error (\"derived union `%T' invalid\", ref);\n       return;\n     }\n \n@@ -12943,7 +12942,7 @@ xref_basetypes (code_type_node, name, ref, binfo)\n \t      && TREE_CODE (basetype) != TEMPLATE_TYPE_PARM\n \t      && TREE_CODE (basetype) != BOUND_TEMPLATE_TEMPLATE_PARM))\n \t{\n-\t  cp_error (\"base type `%T' fails to be a struct or class type\",\n+\t  error (\"base type `%T' fails to be a struct or class type\",\n \t\t    TREE_VALUE (binfo));\n \t  continue;\n \t}\n@@ -12955,17 +12954,17 @@ xref_basetypes (code_type_node, name, ref, binfo)\n       if (!COMPLETE_TYPE_P (basetype)\n \t  && ! (current_template_parms && uses_template_parms (basetype)))\n \t{\n-\t  cp_error (\"base class `%T' has incomplete type\", basetype);\n+\t  error (\"base class `%T' has incomplete type\", basetype);\n \t  continue;\n \t}\n       else\n \t{\n \t  if (CLASSTYPE_MARKED (basetype))\n \t    {\n \t      if (basetype == ref)\n-\t\tcp_error (\"recursive type `%T' undefined\", basetype);\n+\t\terror (\"recursive type `%T' undefined\", basetype);\n \t      else\n-\t\tcp_error (\"duplicate base type `%T' invalid\", basetype);\n+\t\terror (\"duplicate base type `%T' invalid\", basetype);\n \t      continue;\n \t    }\n \n@@ -13076,7 +13075,7 @@ start_enum (name)\n \n   if (enumtype != NULL_TREE && TREE_CODE (enumtype) == ENUMERAL_TYPE)\n     {\n-      cp_error (\"multiple definition of `%#T'\", enumtype);\n+      error (\"multiple definition of `%#T'\", enumtype);\n       cp_error_at (\"previous definition here\", enumtype);\n       /* Clear out TYPE_VALUES, and start again.  */\n       TYPE_VALUES (enumtype) = NULL_TREE;\n@@ -13252,7 +13251,7 @@ build_enumerator (name, value, enumtype)\n \t    }\n \t  else\n \t    {\n-\t      cp_error (\"enumerator value for `%D' not integer constant\", name);\n+\t      error (\"enumerator value for `%D' not integer constant\", name);\n \t      value = NULL_TREE;\n \t    }\n \t}\n@@ -13272,7 +13271,7 @@ build_enumerator (name, value, enumtype)\n \t\t\t\t\t  integer_one_node);\n \n \t      if (tree_int_cst_lt (value, prev_value))\n-\t\tcp_error (\"overflow in enumeration values at `%D'\", name);\n+\t\terror (\"overflow in enumeration values at `%D'\", name);\n \t    }\n \t  else\n \t    value = integer_zero_node;\n@@ -13361,7 +13360,7 @@ check_function_type (decl, current_function_parms)\n \n   if (!COMPLETE_OR_VOID_TYPE_P (return_type))\n     {\n-      cp_error (\"return type `%#T' is incomplete\", TREE_TYPE (fntype));\n+      error (\"return type `%#T' is incomplete\", TREE_TYPE (fntype));\n \n       /* Make it return void instead, but don't change the\n \t type of the DECL_RESULT, in case we have a named return value.  */\n@@ -13470,7 +13469,7 @@ start_function (declspecs, declarator, attrs, flags)\n       restype = TREE_TYPE (fntype);\n       if (CLASS_TYPE_P (restype) && !CLASSTYPE_GOT_SEMICOLON (restype))\n \t{\n-\t  cp_error (\"semicolon missing after declaration of `%#T'\", restype);\n+\t  error (\"semicolon missing after declaration of `%#T'\", restype);\n \t  shadow_tag (build_tree_list (NULL_TREE, restype));\n \t  CLASSTYPE_GOT_SEMICOLON (restype) = 1;\n \t  if (TREE_CODE (fntype) == FUNCTION_TYPE)\n@@ -13544,7 +13543,7 @@ start_function (declspecs, declarator, attrs, flags)\n   if (warn_ecpp\n       && DECL_OVERLOADED_OPERATOR_P (decl1) == NOP_EXPR\n       && TREE_CODE (TREE_TYPE (fntype)) == VOID_TYPE)\n-    cp_warning (\"`operator=' should return a reference to `*this'\");\n+    warning (\"`operator=' should return a reference to `*this'\");\n \n   /* Make the init_value nonzero so pushdecl knows this is not tentative.\n      error_mark_node is replaced below (in poplevel) with the BLOCK.  */\n@@ -13828,7 +13827,7 @@ store_parm_decls (current_function_parms)\n \t\t  || TREE_CODE (parm) != VOID_TYPE)\n \t\tpushdecl (parm);\n \t      else\n-\t\tcp_error (\"parameter `%D' declared void\", parm);\n+\t\terror (\"parameter `%D' declared void\", parm);\n \n \t      cleanup = (processing_template_decl\n \t\t\t ? NULL_TREE\n@@ -14208,7 +14207,7 @@ start_method (declspecs, declarator, attrlist)\n \t{\n \t  if (DECL_CONTEXT (fndecl)\n \t      && TREE_CODE( DECL_CONTEXT (fndecl)) != NAMESPACE_DECL)\n-\t    cp_error (\"`%D' is already defined in class `%T'\", fndecl,\n+\t    error (\"`%D' is already defined in class `%T'\", fndecl,\n \t              DECL_CONTEXT (fndecl));\n \t}\n       return void_type_node;\n@@ -14359,7 +14358,7 @@ hack_incomplete_structures (type)\n \t\t  cleanup = maybe_build_cleanup (decl);\n \t\t  expand_decl_init (decl);\n \t\t  if (! expand_decl_cleanup (decl, cleanup))\n-\t\t    cp_error (\"parser lost in parsing declaration of `%D'\",\n+\t\t    error (\"parser lost in parsing declaration of `%D'\",\n \t\t\t      decl);\n \t\t}\n \t      *list = TREE_CHAIN (*list);\n@@ -14444,7 +14443,7 @@ revert_static_member_fn (decl)\n \n   if (cp_type_quals (TREE_TYPE (TREE_VALUE (args)))\n       != TYPE_UNQUALIFIED)\n-    cp_error (\"static member function `%#D' declared with type qualifiers\",\n+    error (\"static member function `%#D' declared with type qualifiers\",\n \t      decl);\n \n   args = TREE_CHAIN (args);"}, {"sha": "73c934e7aca702856dedc3a7a7bfe1ad12e405ee", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33bd39a26a88cbaabb2f85735c1ff1e51f2a7111/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33bd39a26a88cbaabb2f85735c1ff1e51f2a7111/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=33bd39a26a88cbaabb2f85735c1ff1e51f2a7111", "patch": "@@ -758,7 +758,7 @@ grok_method_quals (ctype, function, quals)\n   while (quals);\n \n   if (dup_quals != TYPE_UNQUALIFIED)\n-    cp_error (\"duplicate type qualifiers in %s declaration\",\n+    error (\"duplicate type qualifiers in %s declaration\",\n \t      TREE_CODE (function) == FUNCTION_DECL \n \t      ? \"member function\" : \"type\");\n \n@@ -797,7 +797,7 @@ warn_if_unknown_interface (decl)\n \t  lineno = TINST_LINE (til);\n \t  input_filename = TINST_FILE (til);\n \t}\n-      cp_warning (\"template `%#D' instantiated in file without #pragma interface\",\n+      warning (\"template `%#D' instantiated in file without #pragma interface\",\n \t\t  decl);\n       lineno = sl;\n       input_filename = sf;\n@@ -1066,7 +1066,7 @@ grok_array_decl (array_expr, index_exp)\n     array_expr = p2, index_exp = i1;\n   else\n     {\n-      cp_error (\"invalid types `%T[%T]' for array subscript\",\n+      error (\"invalid types `%T[%T]' for array subscript\",\n \t\ttype, TREE_TYPE (index_exp));\n       return error_mark_node;\n     }\n@@ -1114,7 +1114,7 @@ delete_sanity (exp, size, doing_vec, use_global_delete)\n \n   if (t == NULL_TREE || t == error_mark_node)\n     {\n-      cp_error (\"type `%#T' argument given to `delete', expected pointer\",\n+      error (\"type `%#T' argument given to `delete', expected pointer\",\n \t\tTREE_TYPE (exp));\n       return error_mark_node;\n     }\n@@ -1139,15 +1139,15 @@ delete_sanity (exp, size, doing_vec, use_global_delete)\n   /* Deleting ptr to void is undefined behaviour [expr.delete/3].  */\n   if (TREE_CODE (TREE_TYPE (type)) == VOID_TYPE)\n     {\n-      cp_warning (\"deleting `%T' is undefined\", type);\n+      warning (\"deleting `%T' is undefined\", type);\n       doing_vec = 0;\n     }\n \n   /* An array can't have been allocated by new, so complain.  */\n   if (TREE_CODE (t) == ADDR_EXPR\n       && TREE_CODE (TREE_OPERAND (t, 0)) == VAR_DECL\n       && TREE_CODE (TREE_TYPE (TREE_OPERAND (t, 0))) == ARRAY_TYPE)\n-    cp_warning (\"deleting array `%#D'\", TREE_OPERAND (t, 0));\n+    warning (\"deleting array `%#D'\", TREE_OPERAND (t, 0));\n \n   /* Deleting a pointer with the value zero is valid and has no effect.  */\n   if (integer_zerop (t))\n@@ -1194,15 +1194,15 @@ check_member_template (tmpl)\n \t/* 14.5.2.2 [temp.mem]\n \t   \n \t   A local class shall not have member templates. */\n-\tcp_error (\"invalid declaration of member template `%#D' in local class\",\n+\terror (\"invalid declaration of member template `%#D' in local class\",\n \t\t  decl);\n       \n       if (TREE_CODE (decl) == FUNCTION_DECL && DECL_VIRTUAL_P (decl))\n \t{\n \t  /* 14.5.2.3 [temp.mem]\n \n \t     A member function template shall not be virtual.  */\n-\t  cp_error \n+\t  error \n \t    (\"invalid use of `virtual' in template declaration of `%#D'\",\n \t     decl);\n \t  DECL_VIRTUAL_P (decl) = 0;\n@@ -1213,7 +1213,7 @@ check_member_template (tmpl)\n       DECL_IGNORED_P (tmpl) = 1;\n     } \n   else\n-    cp_error (\"template declaration of `%#D'\", decl);\n+    error (\"template declaration of `%#D'\", decl);\n }\n \n /* Return true iff TYPE is a valid Java parameter or return type. */\n@@ -1263,7 +1263,7 @@ check_java_method (method)\n   tree ret_type = TREE_TYPE (TREE_TYPE (method));\n   if (! acceptable_java_type (ret_type))\n     {\n-      cp_error (\"Java method '%D' has non-Java return type `%T'\",\n+      error (\"Java method '%D' has non-Java return type `%T'\",\n \t\tmethod, ret_type);\n       jerr++;\n     }\n@@ -1272,7 +1272,7 @@ check_java_method (method)\n       tree type = TREE_VALUE (arg_types);\n       if (! acceptable_java_type (type))\n \t{\n-\t  cp_error (\"Java method '%D' has non-Java parameter type `%T'\",\n+\t  error (\"Java method '%D' has non-Java parameter type `%T'\",\n \t\t    method, type);\n \t  jerr++;\n \t}\n@@ -1368,7 +1368,7 @@ check_classfn (ctype, function)\n   if (methods != end && *methods)\n     {\n       tree fndecl = *methods;\n-      cp_error (\"prototype for `%#D' does not match any in class `%T'\",\n+      error (\"prototype for `%#D' does not match any in class `%T'\",\n \t\tfunction, ctype);\n       cp_error_at (\"candidate%s: %+#D\", OVL_NEXT (fndecl) ? \"s are\" : \" is\",\n \t\t   OVL_CURRENT (fndecl));\n@@ -1381,7 +1381,7 @@ check_classfn (ctype, function)\n       if (!COMPLETE_TYPE_P (ctype))\n         incomplete_type_error (function, ctype);\n       else\n-        cp_error (\"no `%#D' member function declared in class `%T'\",\n+        error (\"no `%#D' member function declared in class `%T'\",\n \t\t  function, ctype);\n     }\n \n@@ -1491,10 +1491,10 @@ grokfield (declarator, declspecs, init, asmspec_tree, attrlist)\n \t Explain that to the user.  */\n       static int explained;\n \n-      cp_error (\"invalid data member initialization\");\n+      error (\"invalid data member initialization\");\n       if (!explained)\n \t{\n-\t  cp_error (\"(use `=' to initialize static data members)\");\n+\t  error (\"(use `=' to initialize static data members)\");\n \t  explained = 1;\n \t}\n \n@@ -1534,7 +1534,7 @@ grokfield (declarator, declspecs, init, asmspec_tree, attrlist)\n   if (DECL_NAME (value) != NULL_TREE\n       && IDENTIFIER_POINTER (DECL_NAME (value))[0] == '_'\n       && ! strcmp (IDENTIFIER_POINTER (DECL_NAME (value)), \"_vptr\"))\n-    cp_error (\"member `%D' conflicts with virtual function table field name\",\n+    error (\"member `%D' conflicts with virtual function table field name\",\n \t      value);\n \n   /* Stash away type declarations.  */\n@@ -1554,7 +1554,7 @@ grokfield (declarator, declspecs, init, asmspec_tree, attrlist)\n \n   if (DECL_IN_AGGR_P (value))\n     {\n-      cp_error (\"`%D' is already defined in `%T'\", value,\n+      error (\"`%D' is already defined in `%T'\", value,\n \t\tDECL_CONTEXT (value));\n       return void_type_node;\n     }\n@@ -1628,7 +1628,7 @@ grokfield (declarator, declspecs, init, asmspec_tree, attrlist)\n   if (TREE_CODE (value) == FIELD_DECL)\n     {\n       if (asmspec)\n-\tcp_error (\"`asm' specifiers are not permitted on non-static data members\");\n+\terror (\"`asm' specifiers are not permitted on non-static data members\");\n       if (DECL_INITIAL (value) == error_mark_node)\n \tinit = error_mark_node;\n       cp_finish_decl (value, init, NULL_TREE, flags);\n@@ -1680,24 +1680,24 @@ grokbitfield (declarator, declspecs, width)\n \n   if (TREE_CODE (value) == TYPE_DECL)\n     {\n-      cp_error (\"cannot declare `%D' to be a bitfield type\", value);\n+      error (\"cannot declare `%D' to be a bitfield type\", value);\n       return NULL_TREE;\n     }\n \n-  /* Usually, finish_struct_1 catches bitifields with invalid types.\n+  /* Usually, finish_struct_1 catches bitfields with invalid types.\n      But, in the case of bitfields with function type, we confuse\n      ourselves into thinking they are member functions, so we must\n      check here.  */\n   if (TREE_CODE (value) == FUNCTION_DECL)\n     {\n-      cp_error (\"cannot declare bitfield `%D' with function type\",\n-\t\tDECL_NAME (value));\n+      error (\"cannot declare bitfield `%D' with function type\",\n+\t     DECL_NAME (value));\n       return NULL_TREE;\n     }\n \n   if (DECL_IN_AGGR_P (value))\n     {\n-      cp_error (\"`%D' is already defined in the class %T\", value,\n+      error (\"`%D' is already defined in the class %T\", value,\n \t\t  DECL_CONTEXT (value));\n       return void_type_node;\n     }\n@@ -1706,7 +1706,7 @@ grokbitfield (declarator, declspecs, width)\n \n   if (TREE_STATIC (value))\n     {\n-      cp_error (\"static member `%D' cannot be a bitfield\", value);\n+      error (\"static member `%D' cannot be a bitfield\", value);\n       return NULL_TREE;\n     }\n   cp_finish_decl (value, NULL_TREE, NULL_TREE, 0);\n@@ -1775,11 +1775,11 @@ grok_function_init (decl, init)\n   tree type = TREE_TYPE (decl);\n \n   if (TREE_CODE (type) == FUNCTION_TYPE)\n-    cp_error (\"initializer specified for non-member function `%D'\", decl);\n+    error (\"initializer specified for non-member function `%D'\", decl);\n   else if (integer_zerop (init))\n     DECL_PURE_VIRTUAL_P (decl) = 1;\n   else\n-    cp_error (\"invalid initializer for virtual method `%D'\", decl);\n+    error (\"invalid initializer for virtual method `%D'\", decl);\n }\n \f\n void\n@@ -2056,15 +2056,15 @@ coerce_new_type (type)\n   my_friendly_assert (TREE_CODE (type) == FUNCTION_TYPE, 20001107);\n   \n   if (!same_type_p (TREE_TYPE (type), ptr_type_node))\n-    e = 1, cp_error (\"`operator new' must return type `%T'\", ptr_type_node);\n+    e = 1, error (\"`operator new' must return type `%T'\", ptr_type_node);\n \n   if (!args || args == void_list_node\n       || !same_type_p (TREE_VALUE (args), c_size_type_node))\n     {\n       e = 2;\n       if (args && args != void_list_node)\n         args = TREE_CHAIN (args);\n-      cp_error (\"`operator new' takes type `size_t' (`%T') as first parameter\", c_size_type_node);\n+      error (\"`operator new' takes type `size_t' (`%T') as first parameter\", c_size_type_node);\n     }\n   switch (e)\n   {\n@@ -2091,15 +2091,15 @@ coerce_delete_type (type)\n   my_friendly_assert (TREE_CODE (type) == FUNCTION_TYPE, 20001107);\n \n   if (!same_type_p (TREE_TYPE (type), void_type_node))\n-    e = 1, cp_error (\"`operator delete' must return type `%T'\", void_type_node);\n+    e = 1, error (\"`operator delete' must return type `%T'\", void_type_node);\n \n   if (!args || args == void_list_node\n       || !same_type_p (TREE_VALUE (args), ptr_type_node))\n     {\n       e = 2;\n       if (args && args != void_list_node)\n         args = TREE_CHAIN (args);\n-      cp_error (\"`operator delete' takes type `%T' as first parameter\", ptr_type_node);\n+      error (\"`operator delete' takes type `%T' as first parameter\", ptr_type_node);\n     }\n   switch (e)\n   {\n@@ -4198,7 +4198,7 @@ ambiguous_decl (name, old, new, flags)\n \t\t repeat ourselves.  */\n \t      if (BINDING_VALUE (old) != error_mark_node)\n \t\t{\n-\t\t  cp_error (\"use of `%D' is ambiguous\", name);\n+\t\t  error (\"use of `%D' is ambiguous\", name);\n \t\t  cp_error_at (\"  first declared as `%#D' here\",\n \t\t\t       BINDING_VALUE (old));\n \t\t}\n@@ -4217,7 +4217,7 @@ ambiguous_decl (name, old, new, flags)\n     {\n       if (flags & LOOKUP_COMPLAIN)\n         {\n-          cp_error (\"`%D' denotes an ambiguous type\",name);\n+          error (\"`%D' denotes an ambiguous type\",name);\n           cp_error_at (\"  first type here\", BINDING_TYPE (old));\n           cp_error_at (\"  other type here\", type);\n         }\n@@ -4316,7 +4316,7 @@ set_decl_namespace (decl, scope, friendp)\n   \n   /* It is ok for friends to be qualified in parallel space.  */\n   if (!friendp && !is_namespace_ancestor (current_namespace, scope))\n-    cp_error (\"declaration of `%D' not in a namespace surrounding `%D'\",\n+    error (\"declaration of `%D' not in a namespace surrounding `%D'\",\n \t      decl, scope);\n   DECL_CONTEXT (decl) = FROB_CONTEXT (scope);\n   if (scope != current_namespace)\n@@ -4350,7 +4350,7 @@ set_decl_namespace (decl, scope, friendp)\n   else\n     return;\n  complain:\n-  cp_error (\"`%D' should have been declared inside `%D'\",\n+  error (\"`%D' should have been declared inside `%D'\",\n \t    decl, scope);\n } \n \n@@ -4486,7 +4486,7 @@ add_function (k, fn)\n \t}\n       cp_error_at (\"`%D' is not a function,\", f1);\n       cp_error_at (\"  conflict with `%D'\", f2);\n-      cp_error (\"  in call to `%D'\", k->name);\n+      error (\"  in call to `%D'\", k->name);\n       return 1;\n     }\n \n@@ -4799,7 +4799,7 @@ do_namespace_alias (alias, namespace)\n   if (TREE_CODE (namespace) != NAMESPACE_DECL)\n     {\n       /* The parser did not find it, so it's not there. */\n-      cp_error (\"unknown namespace `%D'\", namespace);\n+      error (\"unknown namespace `%D'\", namespace);\n       return;\n     }\n \n@@ -4833,9 +4833,9 @@ validate_nonmember_using_decl (decl, scope, name)\n           if(TREE_CODE (*scope) != NAMESPACE_DECL)\n             {\n               if (TYPE_P (*scope))\n-                cp_error (\"`%T' is not a namespace\", *scope);\n+                error (\"`%T' is not a namespace\", *scope);\n               else\n-                cp_error (\"`%D' is not a namespace\", *scope);\n+                error (\"`%D' is not a namespace\", *scope);\n               return NULL_TREE;\n             }\n           \n@@ -4844,7 +4844,7 @@ validate_nonmember_using_decl (decl, scope, name)\n           if (TREE_CODE (*name) == TEMPLATE_ID_EXPR)\n             {\n               *name = TREE_OPERAND (*name, 0);\n-              cp_error (\"a using-declaration cannot specify a template-id.  Try `using %D'\", *name);\n+              error (\"a using-declaration cannot specify a template-id.  Try `using %D'\", *name);\n               return NULL_TREE;\n             }\n         }\n@@ -4858,7 +4858,7 @@ validate_nonmember_using_decl (decl, scope, name)\n     }\n   else if (TREE_CODE (decl) == NAMESPACE_DECL)\n     {\n-      cp_error (\"namespace `%D' not allowed in using-declaration\", decl);\n+      error (\"namespace `%D' not allowed in using-declaration\", decl);\n       return NULL_TREE;\n     }\n   else\n@@ -4887,7 +4887,7 @@ do_nonmember_using_decl (scope, name, oldval, oldtype, newval, newtype)\n \n   if (!BINDING_VALUE (decls) && !BINDING_TYPE (decls))\n     {\n-      cp_error (\"`%D' not declared\", name);\n+      error (\"`%D' not declared\", name);\n       return;\n     }\n \n@@ -4929,7 +4929,7 @@ do_nonmember_using_decl (scope, name, oldval, oldtype, newval, newtype)\n \t\t     this scope with the same parameter types. If both\n \t             are the same extern \"C\" functions, that's ok.  */\n                   if (!decls_match (new_fn, old_fn))\n-    \t            cp_error (\"`%D' is already declared in this scope\", name);\n+    \t            error (\"`%D' is already declared in this scope\", name);\n \t\t  break;\n \t\t}\n \t    }\n@@ -4956,7 +4956,7 @@ do_nonmember_using_decl (scope, name, oldval, oldtype, newval, newtype)\n   *newtype = BINDING_TYPE (decls);\n   if (oldtype && *newtype && oldtype != *newtype)\n     {\n-      cp_error (\"using declaration `%D' introduced ambiguous type `%T'\",\n+      error (\"using declaration `%D' introduced ambiguous type `%T'\",\n \t\tname, oldtype);\n       return;\n     }\n@@ -5047,19 +5047,19 @@ do_class_using_decl (decl)\n   if (TREE_CODE (decl) != SCOPE_REF\n       || !TYPE_P (TREE_OPERAND (decl, 0)))\n     {\n-      cp_error (\"using-declaration for non-member at class scope\");\n+      error (\"using-declaration for non-member at class scope\");\n       return NULL_TREE;\n     }\n   name = TREE_OPERAND (decl, 1);\n   if (TREE_CODE (name) == BIT_NOT_EXPR)\n     {\n-      cp_error (\"using-declaration for destructor\");\n+      error (\"using-declaration for destructor\");\n       return NULL_TREE;\n     }\n   else if (TREE_CODE (name) == TEMPLATE_ID_EXPR)\n     {\n       name = TREE_OPERAND (name, 0);\n-      cp_error (\"a using-declaration cannot specify a template-id.  Try  `using %T::%D'\", TREE_OPERAND (decl, 0), name);\n+      error (\"a using-declaration cannot specify a template-id.  Try  `using %T::%D'\", TREE_OPERAND (decl, 0), name);\n       return NULL_TREE;\n     }\n   if (TREE_CODE (name) == TYPE_DECL || TREE_CODE (name) == TEMPLATE_DECL)\n@@ -5088,13 +5088,13 @@ do_using_directive (namespace)\n     {\n       /* Lookup in lexer did not find a namespace. */\n       if (!processing_template_decl)\n-\tcp_error (\"namespace `%T' undeclared\", namespace);\n+\terror (\"namespace `%T' undeclared\", namespace);\n       return;\n     }\n   if (TREE_CODE (namespace) != NAMESPACE_DECL)\n     {\n       if (!processing_template_decl)\n-\tcp_error (\"`%T' is not a namespace\", namespace);\n+\terror (\"`%T' is not a namespace\", namespace);\n       return;\n     }\n   namespace = ORIGINAL_NAMESPACE (namespace);\n@@ -5198,13 +5198,13 @@ handle_class_head (aggr, scope, id)\n           /* We've been given AGGR SCOPE::ID, when we're already inside SCOPE.\n              Be nice about it.  */\n           if (pedantic)\n-            cp_pedwarn (\"extra qualification `%T::' on member `%D' ignored\",\n+            pedwarn (\"extra qualification `%T::' on member `%D' ignored\",\n                         FROB_CONTEXT (scope), id);\n         }\n       else if (scope != global_namespace)\n-\tcp_error (\"`%T' does not have a nested type named `%D'\", scope, id);\n+\terror (\"`%T' does not have a nested type named `%D'\", scope, id);\n       else\n-\tcp_error (\"no file-scope type named `%D'\", id);\n+\terror (\"no file-scope type named `%D'\", id);\n       \n       /* Inject it at the current scope.  */\n       if (! decl)"}, {"sha": "d1134709d76e4ac8ec978d43c393985fab80281a", "filename": "gcc/cp/error.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33bd39a26a88cbaabb2f85735c1ff1e51f2a7111/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33bd39a26a88cbaabb2f85735c1ff1e51f2a7111/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=33bd39a26a88cbaabb2f85735c1ff1e51f2a7111", "patch": "@@ -939,7 +939,7 @@ dump_decl (t, flags)\n       break;\n \n       /* These special cases are duplicated here so that other functions\n-\t can feed identifiers to cp_error and get them demangled properly.  */\n+\t can feed identifiers to error and get them demangled properly.  */\n     case IDENTIFIER_NODE:\n       if (IDENTIFIER_TYPENAME_P (t))\n \t{\n@@ -1093,7 +1093,7 @@ dump_template_decl (t, flags)\n \n /* Pretty print a function decl. There are several ways we want to print a\n    function declaration. The TFF_ bits in FLAGS tells us how to behave.\n-   As cp_error can only apply the '#' flag once to give 0 and 1 for V, there\n+   As error can only apply the '#' flag once to give 0 and 1 for V, there\n    is %D which doesn't print the throw specs, and %F which does. */\n \n static void\n@@ -2215,7 +2215,7 @@ cp_line_of (t)\n   return line;\n }\n \n-/* Now the interfaces from cp_error et al to dump_type et al. Each takes an\n+/* Now the interfaces from error et al to dump_type et al. Each takes an\n    on/off VERBOSE flag and supply the appropriate TFF_ flags to a dump_\n    function.  */\n "}, {"sha": "3f3cdcfd3be8ae2eb17ceecf0b68e4c37b38c187", "filename": "gcc/cp/except.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33bd39a26a88cbaabb2f85735c1ff1e51f2a7111/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33bd39a26a88cbaabb2f85735c1ff1e51f2a7111/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=33bd39a26a88cbaabb2f85735c1ff1e51f2a7111", "patch": "@@ -242,7 +242,7 @@ decl_is_java_type (decl, err)\n \t  && TYPE_FOR_JAVA (TREE_TYPE (decl)))\n \t{\n \t  /* Can't throw a reference.  */\n-\t  cp_error (\"type `%T' is disallowed in Java `throw' or `catch'\",\n+\t  error (\"type `%T' is disallowed in Java `throw' or `catch'\",\n \t\t    decl);\n \t}\n \n@@ -260,7 +260,7 @@ decl_is_java_type (decl, err)\n \t  if (! DERIVED_FROM_P (jthrow_node, TREE_TYPE (decl)))\n \t    {\n \t      /* Thrown object must be a Throwable.  */\n-\t      cp_error (\"type `%T' is not derived from `java::lang::Throwable'\",\n+\t      error (\"type `%T' is not derived from `java::lang::Throwable'\",\n \t\t\tTREE_TYPE (decl));\n \t    }\n \t}\n@@ -555,7 +555,7 @@ build_throw (exp)\n     return build_min (THROW_EXPR, void_type_node, exp);\n \n   if (exp == null_node)\n-    cp_warning (\"throwing NULL, which has integral, not pointer type\");\n+    warning (\"throwing NULL, which has integral, not pointer type\");\n   \n   if (exp != NULL_TREE)\n     {\n@@ -772,7 +772,7 @@ is_admissible_throw_operand (expr)\n             conversion.  */\n   else if (CLASS_TYPE_P (type) && CLASSTYPE_PURE_VIRTUALS (type))\n     {\n-      cp_error (\"expression '%E' of abstract class type '%T' cannot be used in throw-expression\", expr, type);\n+      error (\"expression '%E' of abstract class type '%T' cannot be used in throw-expression\", expr, type);\n       return false;\n     }\n \n@@ -860,10 +860,10 @@ check_handlers_1 (master, handlers)\n \t&& can_convert_eh (type, TREE_TYPE (handler)))\n       {\n \tlineno = STMT_LINENO (handler);\n-\tcp_warning (\"exception of type `%T' will be caught\",\n+\twarning (\"exception of type `%T' will be caught\",\n \t\t    TREE_TYPE (handler));\n \tlineno = STMT_LINENO (master);\n-\tcp_warning (\"   by earlier handler for `%T'\", type);\n+\twarning (\"   by earlier handler for `%T'\", type);\n \tbreak;\n       }\n }\n@@ -883,7 +883,7 @@ check_handlers (handlers)\n       else if (TREE_TYPE (handler) == NULL_TREE)\n \t{\n \t  lineno = STMT_LINENO (handler);\n-\t  cp_pedwarn\n+\t  pedwarn\n \t    (\"`...' handler must be the last handler for its try block\");\n \t}\n       else"}, {"sha": "c43e0348d29d0622862632001743ffd12621d246", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33bd39a26a88cbaabb2f85735c1ff1e51f2a7111/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33bd39a26a88cbaabb2f85735c1ff1e51f2a7111/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=33bd39a26a88cbaabb2f85735c1ff1e51f2a7111", "patch": "@@ -152,7 +152,7 @@ add_friend (type, decl)\n \t    {\n \t      if (decl == TREE_VALUE (friends))\n \t\t{\n-\t\t  cp_warning (\"`%D' is already a friend of class `%T'\",\n+\t\t  warning (\"`%D' is already a friend of class `%T'\",\n \t\t\t      decl, type);\n \t\t  cp_warning_at (\"previous friend declaration of `%D'\",\n \t\t\t\t TREE_VALUE (friends));\n@@ -194,7 +194,7 @@ make_friend_class (type, friend_type)\n \n   if (! IS_AGGR_TYPE (friend_type))\n     {\n-      cp_error (\"invalid type `%T' declared `friend'\", friend_type);\n+      error (\"invalid type `%T' declared `friend'\", friend_type);\n       return;\n     }\n \n@@ -206,7 +206,7 @@ make_friend_class (type, friend_type)\n \t \n \t Friend declarations shall not declare partial\n \t specializations.  */\n-      cp_error (\"partial specialization `%T' declared `friend'\",\n+      error (\"partial specialization `%T' declared `friend'\",\n \t\tfriend_type);\n       return;\n     }\n@@ -218,7 +218,7 @@ make_friend_class (type, friend_type)\n     is_template_friend = 1;\n   else if (same_type_p (type, friend_type))\n     {\n-      cp_pedwarn (\"class `%T' is implicitly friends with itself\",\n+      pedwarn (\"class `%T' is implicitly friends with itself\",\n \t          type);\n       return;\n     }\n@@ -236,19 +236,19 @@ make_friend_class (type, friend_type)\n   else if (TREE_CODE (friend_type) == TYPENAME_TYPE)\n     {\n       /* template <class T> friend typename S<T>::X; */\n-      cp_error (\"typename type `%#T' declared `friend'\", friend_type);\n+      error (\"typename type `%#T' declared `friend'\", friend_type);\n       return;\n     }\n   else if (TREE_CODE (friend_type) == TEMPLATE_TYPE_PARM)\n     {\n       /* template <class T> friend class T; */\n-      cp_error (\"template parameter type `%T' declared `friend'\", friend_type);\n+      error (\"template parameter type `%T' declared `friend'\", friend_type);\n       return;\n     }\n   else if (!CLASSTYPE_TEMPLATE_INFO (friend_type))\n     {\n       /* template <class T> friend class A; where A is not a template */\n-      cp_error (\"`%#T' is not a template\", friend_type);\n+      error (\"`%#T' is not a template\", friend_type);\n       return;\n     }\n \n@@ -265,7 +265,7 @@ make_friend_class (type, friend_type)\n \t      same_type_p (TREE_VALUE (classes), friend_type)))\n     classes = TREE_CHAIN (classes);\n   if (classes) \n-    cp_warning (\"`%T' is already a friend of `%T'\",\n+    warning (\"`%T' is already a friend of `%T'\",\n \t\tTREE_VALUE (classes), type);\n   else\n     {\n@@ -361,7 +361,7 @@ do_friend (ctype, declarator, decl, parmdecls, attrlist,\n \t    add_friend (current_class_type, decl);\n \t}\n       else\n-\tcp_error (\"member `%D' declared as friend before type `%T' defined\",\n+\terror (\"member `%D' declared as friend before type `%T' defined\",\n \t\t  decl, ctype);\n     }\n   /* A global friend.\n@@ -416,7 +416,7 @@ do_friend (ctype, declarator, decl, parmdecls, attrlist,\n \t  if (warn)\n \t    {\n \t      static int explained;\n-\t      cp_warning (\"friend declaration `%#D' declares a non-template function\", decl);\n+\t      warning (\"friend declaration `%#D' declares a non-template function\", decl);\n \t      if (! explained)\n \t\t{\n \t\t  warning (\"(if this is not what you intended, make sure the function template has already been declared and add <> after the function name here) -Wno-non-template-friend disables this warning\");"}, {"sha": "b97bbbae7ea796132db22ae1f3053922a9be4e3d", "filename": "gcc/cp/init.c", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33bd39a26a88cbaabb2f85735c1ff1e51f2a7111/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33bd39a26a88cbaabb2f85735c1ff1e51f2a7111/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=33bd39a26a88cbaabb2f85735c1ff1e51f2a7111", "patch": "@@ -281,13 +281,13 @@ perform_member_init (member, init, explicit)\n \t    {\n \t      init = build_default_init (type);\n \t      if (TREE_CODE (type) == REFERENCE_TYPE)\n-\t\tcp_warning\n+\t\twarning\n \t\t  (\"default-initialization of `%#D', which has reference type\",\n \t\t   member);\n \t    }\n \t  /* member traversal: note it leaves init NULL */\n \t  else if (TREE_CODE (type) == REFERENCE_TYPE)\n-\t    cp_pedwarn (\"uninitialized reference member `%D'\", member);\n+\t    pedwarn (\"uninitialized reference member `%D'\", member);\n \t}\n       else if (TREE_CODE (init) == TREE_LIST)\n \t{\n@@ -425,7 +425,7 @@ sort_member_init (t, member_init_list)\n       /* If there was already an explicit initializer for this field,\n \t issue an error.  */\n       if (TREE_TYPE (f))\n-\tcp_error (\"multiple initializations given for member `%D'\",\n+\terror (\"multiple initializations given for member `%D'\",\n \t\t  initialized_field);\n       else\n \t{\n@@ -497,7 +497,7 @@ sort_member_init (t, member_init_list)\n \t\t  if (same_type_p (last_field_type, field_type))\n \t\t    {\n \t\t      if (TREE_CODE (field_type) == UNION_TYPE)\n-\t\t\tcp_error (\"initializations for multiple members of `%T'\",\n+\t\t\terror (\"initializations for multiple members of `%T'\",\n \t\t\t\t  last_field_type);\n \t\t      done = 1;\n \t\t      break;\n@@ -628,7 +628,7 @@ sort_base_init (t, base_init_list, rbase_ptr, vbase_ptr)\n \t    }\n \t  else if (binfo == base_binfo)\n \t    {\n-\t      cp_error (\"base class `%T' already initialized\", \n+\t      error (\"base class `%T' already initialized\", \n \t\t\tBINFO_TYPE (binfo));\n \t      break;\n \t    }\n@@ -699,7 +699,7 @@ emit_base_init (mem_init_list, base_init_list)\n \t  init = NULL_TREE;\n \t  if (extra_warnings \n \t      && DECL_COPY_CONSTRUCTOR_P (current_function_decl))\n-\t    cp_warning (\"base class `%#T' should be explicitly initialized in the copy constructor\",\n+\t    warning (\"base class `%#T' should be explicitly initialized in the copy constructor\",\n \t\t\tBINFO_TYPE (base_binfo));\n \t}\n \n@@ -742,7 +742,7 @@ emit_base_init (mem_init_list, base_init_list)\n \t  if (warn_ecpp && init == NULL_TREE\n \t      && !DECL_ARTIFICIAL (member)\n \t      && TREE_CODE (TREE_TYPE (member)) != ARRAY_TYPE)\n-\t    cp_warning (\"`%D' should be initialized in the member initialization list\", member);\t    \n+\t    warning (\"`%D' should be initialized in the member initialization list\", member);\t    \n \t}\n \n       perform_member_init (member, init, from_init_list);\n@@ -984,13 +984,13 @@ member_init_ok_or_else (field, type, member_name)\n     return 0;\n   if (field == NULL_TREE || initializing_context (field) != type)\n     {\n-      cp_error (\"class `%T' does not have any field named `%D'\", type,\n+      error (\"class `%T' does not have any field named `%D'\", type,\n \t\tmember_name);\n       return 0;\n     }\n   if (TREE_STATIC (field))\n     {\n-      cp_error (\"field `%#D' is static; the only point of initialization is its definition\",\n+      error (\"field `%#D' is static; the only point of initialization is its definition\",\n \t\tfield);\n       return 0;\n     }\n@@ -1029,14 +1029,14 @@ expand_member_init (exp, name, init)\n       switch (CLASSTYPE_N_BASECLASSES (type))\n \t{\n \tcase 0:\n-\t  cp_error (\"unnamed initializer for `%T', which has no base classes\",\n+\t  error (\"unnamed initializer for `%T', which has no base classes\",\n \t\t    type);\n \t  return NULL_TREE;\n \tcase 1:\n \t  basetype = TYPE_BINFO_BASETYPE (type, 0);\n \t  break;\n \tdefault:\n-\t  cp_error (\"unnamed initializer for `%T', which uses multiple inheritance\",\n+\t  error (\"unnamed initializer for `%T', which uses multiple inheritance\",\n \t\t    type);\n \t  return NULL_TREE;\n       }\n@@ -1065,10 +1065,10 @@ expand_member_init (exp, name, init)\n       else\n \t{\n \t  if (TYPE_USES_VIRTUAL_BASECLASSES (type))\n-\t    cp_error (\"type `%D' is not a direct or virtual base of `%T'\",\n+\t    error (\"type `%D' is not a direct or virtual base of `%T'\",\n \t\t      name, type);\n \t  else\n-\t    cp_error (\"type `%D' is not a direct base of `%T'\",\n+\t    error (\"type `%D' is not a direct base of `%T'\",\n \t\t      name, type);\n \t  return NULL_TREE;\n \t}\n@@ -1162,7 +1162,7 @@ build_aggr_init (exp, init, flags)\n \t       COMPLEX zees(1.0, 0.0)[10];\n \t     }\n \t  */\n-\t  cp_error (\"bad array initializer\");\n+\t  error (\"bad array initializer\");\n \t  return error_mark_node;\n \t}\n       if (cp_type_quals (type) != TYPE_UNQUALIFIED)\n@@ -1354,7 +1354,7 @@ is_aggr_type (type, or_else)\n       && TREE_CODE (type) != BOUND_TEMPLATE_TEMPLATE_PARM)\n     {\n       if (or_else)\n-\tcp_error (\"`%T' is not an aggregate type\", type);\n+\terror (\"`%T' is not an aggregate type\", type);\n       return 0;\n     }\n   return 1;\n@@ -1377,7 +1377,7 @@ get_aggr_from_typedef (name, or_else)\n   else\n     {\n       if (or_else)\n-\tcp_error (\"`%T' fails to be an aggregate typedef\", name);\n+\terror (\"`%T' fails to be an aggregate typedef\", name);\n       return NULL_TREE;\n     }\n \n@@ -1386,7 +1386,7 @@ get_aggr_from_typedef (name, or_else)\n       && TREE_CODE (type) != BOUND_TEMPLATE_TEMPLATE_PARM)\n     {\n       if (or_else)\n-\tcp_error (\"type `%T' is of non-aggregate type\", type);\n+\terror (\"type `%T' is of non-aggregate type\", type);\n       return NULL_TREE;\n     }\n   return type;\n@@ -1488,7 +1488,7 @@ build_member_call (type, name, parmlist)\n \n   if (dtor)\n     {\n-      cp_error (\"cannot call destructor `%T::~%T' without object\", type,\n+      error (\"cannot call destructor `%T::~%T' without object\", type,\n \t\tmethod_name);\n       return error_mark_node;\n     }\n@@ -1530,7 +1530,7 @@ build_member_call (type, name, parmlist)\n \t{\n \t  if (is_dummy_object (decl))\n \t    {\n-\t      cp_error (\"invalid use of non-static field `%D'\", t);\n+\t      error (\"invalid use of non-static field `%D'\", t);\n \t      return error_mark_node;\n \t    }\n \t  decl = build (COMPONENT_REF, TREE_TYPE (t), decl, t);\n@@ -1539,7 +1539,7 @@ build_member_call (type, name, parmlist)\n \tdecl = t;\n       else\n \t{\n-\t  cp_error (\"invalid use of member `%D'\", t);\n+\t  error (\"invalid use of member `%D'\", t);\n \t  return error_mark_node;\n \t}\n       if (TYPE_LANG_SPECIFIC (TREE_TYPE (decl)))\n@@ -1549,7 +1549,7 @@ build_member_call (type, name, parmlist)\n     }\n   else\n     {\n-      cp_error (\"no method `%T::%D'\", type, name);\n+      error (\"no method `%T::%D'\", type, name);\n       return error_mark_node;\n     }\n }\n@@ -1634,15 +1634,15 @@ build_offset_ref (type, name)\n   if (TREE_CODE (name) == BIT_NOT_EXPR)\n     {\n       if (! check_dtor_name (type, name))\n-\tcp_error (\"qualified type `%T' does not match destructor name `~%T'\",\n+\terror (\"qualified type `%T' does not match destructor name `~%T'\",\n \t\t  type, TREE_OPERAND (name, 0));\n       name = dtor_identifier;\n     }\n \n   if (!COMPLETE_TYPE_P (complete_type (type))\n       && !TYPE_BEING_DEFINED (type))\n     {\n-      cp_error (\"incomplete type `%T' does not have member `%D'\", type,\n+      error (\"incomplete type `%T' does not have member `%D'\", type,\n \t\tname);\n       return error_mark_node;\n     }\n@@ -1711,7 +1711,7 @@ build_offset_ref (type, name)\n \n   if (t == NULL_TREE)\n     {\n-      cp_error (\"`%D' is not a member of type `%T'\", name, type);\n+      error (\"`%D' is not a member of type `%T'\", name, type);\n       return error_mark_node;\n     }\n \n@@ -1730,7 +1730,7 @@ build_offset_ref (type, name)\n \n   if (TREE_CODE (t) == FIELD_DECL && DECL_C_BIT_FIELD (t))\n     {\n-      cp_error (\"illegal pointer to bit field `%D'\", t);\n+      error (\"illegal pointer to bit field `%D'\", t);\n       return error_mark_node;\n     }\n \n@@ -1859,7 +1859,7 @@ resolve_offset_ref (exp)\n     {\n       if (addr == error_mark_node)\n \t{\n-\t  cp_error (\"object missing in `%E'\", exp);\n+\t  error (\"object missing in `%E'\", exp);\n \t  return error_mark_node;\n \t}\n \n@@ -2416,7 +2416,7 @@ build_new_1 (exp)\n       if (init == void_zero_node)\n \tinit = build_default_init (full_type);\n       else if (init && pedantic && has_array)\n-\tcp_pedwarn (\"ISO C++ forbids initialization in array new\");\n+\tpedwarn (\"ISO C++ forbids initialization in array new\");\n \n       if (has_array)\n \tinit_expr = build_vec_init (init_expr, init, 0);\n@@ -2515,7 +2515,7 @@ build_new_1 (exp)\n \t}\n     }\n   else if (CP_TYPE_CONST_P (true_type))\n-    cp_error (\"uninitialized const in `new' of `%#T'\", true_type);\n+    error (\"uninitialized const in `new' of `%#T'\", true_type);\n \n   /* Now build up the return value in reverse order.  */\n "}, {"sha": "82b14ae5623d2f50dc59ebff2e8da7ef41023e5c", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33bd39a26a88cbaabb2f85735c1ff1e51f2a7111/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33bd39a26a88cbaabb2f85735c1ff1e51f2a7111/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=33bd39a26a88cbaabb2f85735c1ff1e51f2a7111", "patch": "@@ -1000,7 +1000,7 @@ check_for_missing_semicolon (type)\n \terror (\"semicolon missing after %s declaration\",\n \t       TREE_CODE (type) == ENUMERAL_TYPE ? \"enum\" : \"struct\");\n       else\n-\tcp_error (\"semicolon missing after declaration of `%T'\", type);\n+\terror (\"semicolon missing after declaration of `%T'\", type);\n       shadow_tag (build_tree_list (0, type));\n     }\n   /* Could probably also hack cases where class { ... } f (); appears.  */\n@@ -1248,12 +1248,12 @@ do_identifier (token, parsing, args)\n       else if (IDENTIFIER_OPNAME_P (token))\n \t{\n \t  if (token != ansi_opname (ERROR_MARK))\n-\t    cp_error (\"`%D' not defined\", token);\n+\t    error (\"`%D' not defined\", token);\n \t  id = error_mark_node;\n \t}\n       else if (current_function_decl == 0)\n \t{\n-\t  cp_error (\"`%D' was not declared in this scope\", token);\n+\t  error (\"`%D' was not declared in this scope\", token);\n \t  id = error_mark_node;\n \t}\n       else\n@@ -1263,7 +1263,7 @@ do_identifier (token, parsing, args)\n \t    {\n \t      static int undeclared_variable_notice;\n \n-\t      cp_error (\"`%D' undeclared (first use this function)\", token);\n+\t      error (\"`%D' undeclared (first use this function)\", token);\n \n \t      if (! undeclared_variable_notice)\n \t\t{\n@@ -1378,7 +1378,7 @@ do_scoped_id (token, parsing)\n \t  return id;\n \t}\n       if (IDENTIFIER_NAMESPACE_VALUE (token) != error_mark_node)\n-        cp_error (\"`::%D' undeclared (first use here)\", token);\n+        error (\"`::%D' undeclared (first use here)\", token);\n       id = error_mark_node;\n       /* Prevent repeated error messages.  */\n       SET_IDENTIFIER_NAMESPACE_VALUE (token, error_mark_node);"}, {"sha": "759bfbebd854cbe19f407ebf931b97642d75991e", "filename": "gcc/cp/method.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33bd39a26a88cbaabb2f85735c1ff1e51f2a7111/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33bd39a26a88cbaabb2f85735c1ff1e51f2a7111/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=33bd39a26a88cbaabb2f85735c1ff1e51f2a7111", "patch": "@@ -185,13 +185,13 @@ hack_identifier (value, name)\n \t{\n \t  if (current_function_decl \n \t      && DECL_STATIC_FUNCTION_P (current_function_decl))\n-\t    cp_error (\"invalid use of member `%D' in static member function\",\n+\t    error (\"invalid use of member `%D' in static member function\",\n \t\t      value);\n \t  else\n \t    /* We can get here when processing a bad default\n \t       argument, like:\n \t         struct S { int a; void f(int i = a); }  */\n-\t    cp_error (\"invalid use of member `%D'\", value);\n+\t    error (\"invalid use of member `%D'\", value);\n \n \t  return error_mark_node;\n \t}\n@@ -233,12 +233,12 @@ hack_identifier (value, name)\n     }\n   else if (TREE_CODE (value) == NAMESPACE_DECL)\n     {\n-      cp_error (\"use of namespace `%D' as expression\", value);\n+      error (\"use of namespace `%D' as expression\", value);\n       return error_mark_node;\n     }\n   else if (DECL_CLASS_TEMPLATE_P (value))\n     {\n-      cp_error (\"use of class template `%T' as expression\", value);\n+      error (\"use of class template `%T' as expression\", value);\n       return error_mark_node;\n     }\n   else\n@@ -251,7 +251,7 @@ hack_identifier (value, name)\n       if (context != NULL_TREE && context != current_function_decl\n \t  && ! TREE_STATIC (value))\n \t{\n-\t  cp_error (\"use of %s from containing function\",\n+\t  error (\"use of %s from containing function\",\n \t\t      (TREE_CODE (value) == VAR_DECL\n \t\t       ? \"`auto' variable\" : \"parameter\"));\n \t  cp_error_at (\"  `%#D' declared here\", value);\n@@ -272,7 +272,7 @@ hack_identifier (value, name)\n   else if (TREE_CODE (value) == TREE_LIST \n \t   && TREE_TYPE (value) == error_mark_node)\n     {\n-      cp_error (\"\\\n+      error (\"\\\n request for member `%D' is ambiguous in multiple inheritance lattice\",\n \t\tname);\n       print_candidates (value);\n@@ -325,7 +325,7 @@ make_thunk (function, delta, vcall_index)\n   thunk = IDENTIFIER_GLOBAL_VALUE (thunk_id);\n   if (thunk && !DECL_THUNK_P (thunk))\n     {\n-      cp_error (\"implementation-reserved name `%D' used\", thunk_id);\n+      error (\"implementation-reserved name `%D' used\", thunk_id);\n       thunk = NULL_TREE;\n       SET_IDENTIFIER_GLOBAL_VALUE (thunk_id, thunk);\n     }\n@@ -445,7 +445,7 @@ use_thunk (thunk_fndecl, emit_p)\n     tree a, t;\n \n     if (varargs_function_p (function))\n-      cp_error (\"generic thunk code fails for method `%#D' which uses `...'\",\n+      error (\"generic thunk code fails for method `%#D' which uses `...'\",\n \t\tfunction);\n \n     /* Set up clone argument trees for the thunk.  */\n@@ -675,12 +675,12 @@ do_build_assign_ref (fndecl)\n \n \t  if (CP_TYPE_CONST_P (TREE_TYPE (field)))\n \t    {\n-              cp_error (\"non-static const member `%#D', can't use default assignment operator\", field);\n+              error (\"non-static const member `%#D', can't use default assignment operator\", field);\n \t      continue;\n \t    }\n \t  else if (TREE_CODE (TREE_TYPE (field)) == REFERENCE_TYPE)\n \t    {\n-\t      cp_error (\"non-static reference member `%#D', can't use default assignment operator\", field);\n+\t      error (\"non-static reference member `%#D', can't use default assignment operator\", field);\n \t      continue;\n \t    }\n "}, {"sha": "ccc3ede819b16c58d64e67e3f7480fabf5847367", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33bd39a26a88cbaabb2f85735c1ff1e51f2a7111/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33bd39a26a88cbaabb2f85735c1ff1e51f2a7111/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=33bd39a26a88cbaabb2f85735c1ff1e51f2a7111", "patch": "@@ -498,7 +498,7 @@ extdef:\n \t\t{ do_pending_inlines (); }\n \n \t| EXPORT\n-\t\t{ cp_warning (\"keyword `export' not implemented, and will be ignored\"); }\n+\t\t{ warning (\"keyword `export' not implemented, and will be ignored\"); }\n \t  template_def\n \t\t{ do_pending_inlines (); }\n \t| template_def\n@@ -602,7 +602,7 @@ extern_lang_string:\n \t\t{ push_lang_context ($1); }\n \t| extern_lang_string EXTERN_LANG_STRING\n \t\t{ if (current_lang_name != $2)\n-\t\t    cp_error (\"use of linkage spec `%D' is different from previous spec `%D'\", $2, current_lang_name);\n+\t\t    error (\"use of linkage spec `%D' is different from previous spec `%D'\", $2, current_lang_name);\n \t\t  pop_lang_context (); push_lang_context ($2); }\n \t;\n \n@@ -1108,7 +1108,7 @@ template_arg:\n \t\t{\n \t\t  if (!processing_template_decl)\n \t\t    {\n-\t\t      cp_error (\"use of template qualifier outside template\");\n+\t\t      error (\"use of template qualifier outside template\");\n \t\t      $$ = error_mark_node;\n \t\t    }\n \t\t  else\n@@ -1169,9 +1169,9 @@ condition:\n \t\t    if (TREE_CODE (d) == TYPE_DECL) {\n \t\t      tree s = TREE_TYPE (d);\n \t\t      if (TREE_CODE (s) == RECORD_TYPE)\n-\t\t\tcp_error (\"definition of class `%T' in condition\", s);\n+\t\t\terror (\"definition of class `%T' in condition\", s);\n \t\t      else if (TREE_CODE (s) == ENUMERAL_TYPE)\n-\t\t\tcp_error (\"definition of enum `%T' in condition\", s);\n+\t\t\terror (\"definition of enum `%T' in condition\", s);\n \t\t    }\n \t\t  }\n \t\t  current_declspecs = $1.t;\n@@ -1182,7 +1182,7 @@ condition:\n \t\t  parse_end_decl ($<ttype>6, $7, $4);\n \t\t  $$ = convert_from_reference ($<ttype>6); \n \t\t  if (TREE_CODE (TREE_TYPE ($$)) == ARRAY_TYPE)\n-\t\t    cp_error (\"definition of array `%#D' in condition\", $$); \n+\t\t    error (\"definition of array `%#D' in condition\", $$); \n \t\t}\n \t| expr\n \t;\n@@ -1291,7 +1291,7 @@ new_placement:\n \t  '(' nonnull_exprlist ')'\n                 { $$ = $2; }\n \t| '{' nonnull_exprlist '}'\n-                { cp_pedwarn (\"old style placement syntax, use () instead\");\n+                { pedwarn (\"old style placement syntax, use () instead\");\n \t\t  $$ = $2; }\n \t;\n \n@@ -1302,7 +1302,7 @@ new_initializer:\n \t\t{ $$ = void_zero_node; }\n \t| '(' typespec ')'\n \t\t{\n-\t\t  cp_error (\"`%T' is not a valid expression\", $2.t);\n+\t\t  error (\"`%T' is not a valid expression\", $2.t);\n \t\t  $$ = error_mark_node;\n \t\t}\n \t/* GNU extension so people can use initializer lists.  Note that\n@@ -2275,7 +2275,7 @@ structsp:\n \t\t{ $$.t = $2;\n \t\t  $$.new_type_flag = 0; \n \t\t  if (!processing_template_decl)\n-\t\t    cp_pedwarn (\"using `typename' outside of template\"); }\n+\t\t    pedwarn (\"using `typename' outside of template\"); }\n \t/* C++ extensions, merged with C to avoid shift/reduce conflicts */\n \t| class_head '{'\n                 { $1.t = begin_class_definition ($1.t); \n@@ -2319,7 +2319,7 @@ structsp:\n \t\t    $$.t = $1.t;\n \t\t  else if (TYPE_BINFO ($1.t) == NULL_TREE)\n \t\t    {\n-\t\t      cp_error (\"%T is not a class type\", $1.t);\n+\t\t      error (\"%T is not a class type\", $1.t);\n \t\t      $$.t = error_mark_node;\n \t\t    } \n \t\t  else\n@@ -2330,7 +2330,7 @@ structsp:\n \t\t\t  && TYPE_BINFO_BASETYPES ($$.t) \n \t\t\t  && !COMPLETE_TYPE_P ($$.t)\n \t\t\t  && ! TYPE_BEING_DEFINED ($$.t))\n-\t\t\tcp_error (\"base clause without member specification for `%#T'\",\n+\t\t\terror (\"base clause without member specification for `%#T'\",\n \t\t\t\t  $$.t);\n \t\t    }\n \t\t}\n@@ -2448,7 +2448,7 @@ named_class_head:\n \t\t      $$.new_type_flag = $1.new_type_flag;\n \t\t      if ((current_aggr == union_type_node)\n \t\t\t  != (TREE_CODE (type) == UNION_TYPE))\n-\t\t\tcp_pedwarn (current_aggr == union_type_node\n+\t\t\tpedwarn (current_aggr == union_type_node\n \t                            ? \"`union' tag used in declaring `%#T'\"\n \t                            : \"non-`union' tag used in declaring `%#T'\", \n \t\t\t\t    type);\n@@ -2524,7 +2524,7 @@ base_class_access_list:\n \t  VISSPEC see_typename\n \t| SCSPEC see_typename\n \t\t{ if ($1 != ridpointers[(int)RID_VIRTUAL])\n-\t\t    cp_error (\"`%D' access\", $1);\n+\t\t    error (\"`%D' access\", $1);\n \t\t  $$ = access_default_virtual_node; }\n \t| base_class_access_list VISSPEC see_typename\n \t\t{\n@@ -2539,7 +2539,7 @@ base_class_access_list:\n \t\t}\n \t| base_class_access_list SCSPEC see_typename\n \t\t{ if ($2 != ridpointers[(int)RID_VIRTUAL])\n-\t\t    cp_error (\"`%D' access\", $2);\n+\t\t    error (\"`%D' access\", $2);\n \t\t  else if ($$ == access_public_node)\n \t\t    $$ = access_public_virtual_node;\n \t\t  else if ($$ == access_protected_node)\n@@ -3085,7 +3085,7 @@ typename_sub0:\n \t\t  if (TYPE_P ($1))\n \t\t    $$ = make_typename_type ($1, $2, /*complain=*/1);\n \t\t  else if (TREE_CODE ($2) == IDENTIFIER_NODE)\n-\t\t    cp_error (\"`%T' is not a class or namespace\", $2);\n+\t\t    error (\"`%T' is not a class or namespace\", $2);\n \t\t  else\n \t\t    {\n \t\t      $$ = $2;\n@@ -3105,7 +3105,7 @@ typename_sub1:\n \t  typename_sub2\n \t\t{\n \t\t  if (TREE_CODE ($1) == IDENTIFIER_NODE)\n-\t\t    cp_error (\"`%T' is not a class or namespace\", $1);\n+\t\t    error (\"`%T' is not a class or namespace\", $1);\n \t\t  else if (TREE_CODE ($1) == TYPE_DECL)\n \t\t    $$ = TREE_TYPE ($1);\n \t\t}\n@@ -3114,7 +3114,7 @@ typename_sub1:\n \t\t  if (TYPE_P ($1))\n \t\t    $$ = make_typename_type ($1, $2, /*complain=*/1);\n \t\t  else if (TREE_CODE ($2) == IDENTIFIER_NODE)\n-\t\t    cp_error (\"`%T' is not a class or namespace\", $2);\n+\t\t    error (\"`%T' is not a class or namespace\", $2);\n \t\t  else\n \t\t    {\n \t\t      $$ = $2;\n@@ -3143,7 +3143,7 @@ typename_sub2:\n \t\t  got_scope = complete_type (TREE_TYPE ($$));\n \n \t\t  if ($$ == error_mark_node)\n-\t\t    cp_error (\"`%T' is not a class or namespace\", $1);\n+\t\t    error (\"`%T' is not a class or namespace\", $1);\n \t\t}\n \t| SELFNAME SCOPE\n \t\t{\n@@ -3770,15 +3770,15 @@ bad_parm:\n \t\t  if (TREE_CODE ($$) == SCOPE_REF\n \t\t      && (TREE_CODE (TREE_OPERAND ($$, 0)) == TEMPLATE_TYPE_PARM\n \t\t\t  || TREE_CODE (TREE_OPERAND ($$, 0)) == BOUND_TEMPLATE_TEMPLATE_PARM))\n-\t\t    cp_error (\"  perhaps you want `typename %E' to make it a type\", $$);\n+\t\t    error (\"  perhaps you want `typename %E' to make it a type\", $$);\n \t\t  $$ = build_tree_list (integer_type_node, $$);\n \t\t}\n \t;\n \n bad_decl:\n           IDENTIFIER template_arg_list_ignore IDENTIFIER arg_list_ignore ';'\n \t\t{\n-                  cp_error(\"'%D' is used as a type, but is not defined as a type.\", $1);\n+                  error(\"'%D' is used as a type, but is not defined as a type.\", $1);\n                   $3 = error_mark_node;\n \t\t}\n         ;"}, {"sha": "61e7186cf9d657a2e6ee9d08d7efa14eb258cee2", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 96, "deletions": 96, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33bd39a26a88cbaabb2f85735c1ff1e51f2a7111/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33bd39a26a88cbaabb2f85735c1ff1e51f2a7111/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=33bd39a26a88cbaabb2f85735c1ff1e51f2a7111", "patch": "@@ -206,7 +206,7 @@ finish_member_template_decl (decl)\n       return NULL_TREE;\n     }\n   else if (TREE_CODE (decl) == FIELD_DECL)\n-    cp_error (\"data member `%D' cannot be a member template\", decl);\n+    error (\"data member `%D' cannot be a member template\", decl);\n   else if (DECL_TEMPLATE_INFO (decl))\n     {\n       if (!DECL_TEMPLATE_SPECIALIZATION (decl))\n@@ -218,7 +218,7 @@ finish_member_template_decl (decl)\n \treturn decl;\n     } \n   else\n-    cp_error (\"invalid member template declaration `%D'\", decl);\n+    error (\"invalid member template declaration `%D'\", decl);\n \n   return error_mark_node;\n }\n@@ -613,7 +613,7 @@ check_specialization_scope ()\n      shall be declared in the namespace of which the class template\n      is a member.  */\n   if (scope && TREE_CODE (scope) != NAMESPACE_DECL)\n-    cp_error (\"explicit specialization in non-namespace scope `%D'\",\n+    error (\"explicit specialization in non-namespace scope `%D'\",\n \t      scope);\n \n   /* [temp.expl.spec] \n@@ -625,7 +625,7 @@ check_specialization_scope ()\n      explicitly specialize a class member template if its enclosing\n      class templates are not explicitly specialized as well.  */\n   if (current_template_parms) \n-    cp_error (\"enclosing class templates are not explicitly specialized\");\n+    error (\"enclosing class templates are not explicitly specialized\");\n }\n \n /* We've just seen template <>. */\n@@ -700,7 +700,7 @@ maybe_process_partial_specialization (type)\n \t  if (current_namespace\n \t      != decl_namespace_context (CLASSTYPE_TI_TEMPLATE (type)))\n \t    {\n-\t      cp_pedwarn (\"specializing `%#T' in different namespace\", type);\n+\t      pedwarn (\"specializing `%#T' in different namespace\", type);\n \t      cp_pedwarn_at (\"  from definition of `%#D'\",\n \t\t\t     CLASSTYPE_TI_TEMPLATE (type));\n \t    }\n@@ -709,10 +709,10 @@ maybe_process_partial_specialization (type)\n \t    push_template_decl (TYPE_MAIN_DECL (type));\n \t}\n       else if (CLASSTYPE_TEMPLATE_INSTANTIATION (type))\n-\tcp_error (\"specialization of `%T' after instantiation\", type);\n+\terror (\"specialization of `%T' after instantiation\", type);\n     }\n   else if (processing_specialization)\n-    cp_error (\"explicit specialization of non-template `%T'\", type);\n+    error (\"explicit specialization of non-template `%T'\", type);\n }\n \n /* Retrieve the specialization (in the sense of [temp.spec] - a\n@@ -844,7 +844,7 @@ register_specialization (spec, tmpl, args)\n \t\t  if (TREE_USED (fn) \n \t\t      || DECL_EXPLICIT_INSTANTIATION (fn))\n \t\t    {\n-\t\t      cp_error (\"specialization of %D after instantiation\",\n+\t\t      error (\"specialization of %D after instantiation\",\n \t\t\t\tfn);\n \t\t      return spec;\n \t\t    }\n@@ -998,7 +998,7 @@ determine_specialization (template_id, decl, targs_out,\n \n   if (!is_overloaded_fn (fns))\n     {\n-      cp_error (\"`%D' is not a function template\", fns);\n+      error (\"`%D' is not a function template\", fns);\n       return error_mark_node;\n     }\n \n@@ -1356,7 +1356,7 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \t      /* This case handles bogus declarations like template <>\n \t\t template <class T> void f<int>(); */\n \n-\t      cp_error (\"template-id `%D' in declaration of primary template\",\n+\t      error (\"template-id `%D' in declaration of primary template\",\n \t\t\tdeclarator);\n \t      return decl;\n \t    }\n@@ -1369,19 +1369,19 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n       return error_mark_node;\n \n     case tsk_invalid_expl_inst:\n-      cp_error (\"template parameter list used in explicit instantiation\");\n+      error (\"template parameter list used in explicit instantiation\");\n \n       /* Fall through.  */\n \n     case tsk_expl_inst:\n       if (have_def)\n-\tcp_error (\"definition provided for explicit instantiation\");\n+\terror (\"definition provided for explicit instantiation\");\n       \n       explicit_instantiation = 1;\n       break;\n \n     case tsk_excessive_parms:\n-      cp_error (\"too many template parameter lists in declaration of `%D'\", \n+      error (\"too many template parameter lists in declaration of `%D'\", \n \t\tdecl);\n       return error_mark_node;\n \n@@ -1397,7 +1397,7 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n     case tsk_insufficient_parms:\n       if (template_header_count)\n \t{\n-\t  cp_error(\"too few template parameter lists in declaration of `%D'\", \n+\t  error(\"too few template parameter lists in declaration of `%D'\", \n \t\t   decl);\n \t  return decl;\n \t}\n@@ -1413,7 +1413,7 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \n \t     That used to be legal C++.  */\n \t  if (pedantic)\n-\t    cp_pedwarn\n+\t    pedwarn\n \t      (\"explicit specialization not preceded by `template <>'\");\n \t  specialization = 1;\n \t  SET_DECL_TEMPLATE_SPECIALIZATION (decl);\n@@ -1427,10 +1427,10 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \t     template <class T> void f<int>(); */\n \n \t  if (uses_template_parms (declarator))\n-\t    cp_error (\"partial specialization `%D' of function template\",\n+\t    error (\"partial specialization `%D' of function template\",\n \t\t      declarator);\n \t  else\n-\t    cp_error (\"template-id `%D' in declaration of primary template\",\n+\t    error (\"template-id `%D' in declaration of primary template\",\n \t\t      declarator);\n \t  return decl;\n \t}\n@@ -1458,12 +1458,12 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n       for (; t; t = TREE_CHAIN (t))\n \tif (TREE_PURPOSE (t))\n \t  {\n-\t    cp_pedwarn\n+\t    pedwarn\n \t      (\"default argument specified in explicit specialization\");\n \t    break;\n \t  }\n       if (current_lang_name == lang_name_c)\n-\tcp_error (\"template specialization with C linkage\");\n+\terror (\"template specialization with C linkage\");\n     }\n \n   if (specialization || member_specialization || explicit_instantiation)\n@@ -1551,7 +1551,7 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \t\t     program is ill-formed.  \n \n \t\t     Similar language is found in [temp.explicit].  */\n-\t\t  cp_error (\"specialization of implicitly-declared special member function\");\n+\t\t  error (\"specialization of implicitly-declared special member function\");\n \t\t  return error_mark_node;\n \t\t}\n \n@@ -1594,7 +1594,7 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \t      \n \t  if (fns == NULL_TREE) \n \t    {\n-\t      cp_error (\"no member function `%D' declared in `%T'\",\n+\t      error (\"no member function `%D' declared in `%T'\",\n \t\t\tname, ctype);\n \t      return error_mark_node;\n \t    }\n@@ -1742,7 +1742,7 @@ maybe_check_template_type (type)\n \t; \n       else if (template_header_count > context_depth + 1)\n \t/* There are two many template parameter lists.  */\n-\tcp_error (\"too many template parameter lists in declaration of `%T'\", type); \n+\terror (\"too many template parameter lists in declaration of `%T'\", type); \n     }\n }\n \n@@ -2241,11 +2241,11 @@ process_partial_specialization (decl)\n \t   specialization.  */\n \tif (!did_error_intro)\n \t  {\n-\t    cp_error (\"template parameters not used in partial specialization:\");\n+\t    error (\"template parameters not used in partial specialization:\");\n \t    did_error_intro = 1;\n \t  }\n \n-\tcp_error (\"        `%D'\", \n+\terror (\"        `%D'\", \n \t\t  TREE_VALUE (TREE_VEC_ELT (inner_parms, i)));\n       }\n \n@@ -2257,7 +2257,7 @@ process_partial_specialization (decl)\n       (inner_args, \n        INNERMOST_TEMPLATE_ARGS (CLASSTYPE_TI_ARGS (TREE_TYPE\n \t\t\t\t\t\t   (maintmpl)))))\n-    cp_error (\"partial specialization `%T' does not specialize any template arguments\", type);\n+    error (\"partial specialization `%T' does not specialize any template arguments\", type);\n \n   /* [temp.class.spec]\n \n@@ -2282,7 +2282,7 @@ process_partial_specialization (decl)\n \t  && TREE_CODE (arg) != TEMPLATE_PARM_INDEX)\n \t{\n \t  if (tpd.arg_uses_template_parms[i])\n-\t    cp_error (\"template argument `%E' involves template parameter(s)\", arg);\n+\t    error (\"template argument `%E' involves template parameter(s)\", arg);\n \t  else \n \t    {\n \t      /* Look at the corresponding template parameter,\n@@ -2325,7 +2325,7 @@ process_partial_specialization (decl)\n \t\t    if (tpd2.parms[j] != 0\n \t\t\t&& tpd.arg_uses_template_parms [j])\n \t\t      {\n-\t\t\tcp_error (\"type `%T' of template argument `%E' depends on template parameter(s)\", \n+\t\t\terror (\"type `%T' of template argument `%E' depends on template parameter(s)\", \n \t\t\t\t  type,\n \t\t\t\t  arg);\n \t\t\tbreak;\n@@ -2413,7 +2413,7 @@ check_default_tmpl_args (decl, parms, is_primary, is_partial)\n \t    seen_def_arg_p = 1;\n \t  else if (seen_def_arg_p)\n \t    {\n-\t      cp_error (\"no default argument for `%D'\", TREE_VALUE (parm));\n+\t      error (\"no default argument for `%D'\", TREE_VALUE (parm));\n \t      /* For better subsequent error-recovery, we indicate that\n \t\t there should have been a default argument.  */\n \t      TREE_PURPOSE (parm) = error_mark_node;\n@@ -2477,7 +2477,7 @@ check_default_tmpl_args (decl, parms, is_primary, is_partial)\n \t  {\n \t    if (msg)\n \t      {\n-\t\tcp_error (msg, decl);\n+\t\terror (msg, decl);\n \t\tmsg = 0;\n \t      }\n \n@@ -2546,17 +2546,17 @@ push_template_decl_real (decl, is_friend)\n   if (primary)\n     {\n       if (current_lang_name == lang_name_c)\n-\tcp_error (\"template with C linkage\");\n+\terror (\"template with C linkage\");\n       else if (TREE_CODE (decl) == TYPE_DECL \n \t       && ANON_AGGRNAME_P (DECL_NAME (decl))) \n-\tcp_error (\"template class without a name\");\n+\terror (\"template class without a name\");\n       else if ((DECL_IMPLICIT_TYPEDEF_P (decl)\n \t\t&& CLASS_TYPE_P (TREE_TYPE (decl)))\n \t       || (TREE_CODE (decl) == VAR_DECL && ctx && CLASS_TYPE_P (ctx))\n \t       || TREE_CODE (decl) == FUNCTION_DECL)\n \t/* OK */;\n       else\n-\tcp_error (\"template declaration of `%#D'\", decl);\n+\terror (\"template declaration of `%#D'\", decl);\n     }\n \n   /* Check to see that the rules regarding the use of default\n@@ -2624,13 +2624,13 @@ push_template_decl_real (decl, is_friend)\n \t    tmpl = TYPE_TI_TEMPLATE (TREE_TYPE (decl));\n \t  else\n \t    {\n-\t      cp_error (\"`%D' does not declare a template type\", decl);\n+\t      error (\"`%D' does not declare a template type\", decl);\n \t      return decl;\n \t    }\n \t}\n       else if (! DECL_TEMPLATE_INFO (decl))\n \t{\n-\t  cp_error (\"template definition of non-template `%#D'\", decl);\n+\t  error (\"template definition of non-template `%#D'\", decl);\n \t  return decl;\n \t}\n       else\n@@ -2671,7 +2671,7 @@ push_template_decl_real (decl, is_friend)\n       i = TMPL_PARMS_DEPTH (parms);\n       if (TMPL_ARGS_DEPTH (args) != i)\n \t{\n-\t  cp_error (\"expected %d levels of template parms for `%#D', got %d\",\n+\t  error (\"expected %d levels of template parms for `%#D', got %d\",\n \t\t    i, decl, TMPL_ARGS_DEPTH (args));\n \t}\n       else\n@@ -2683,12 +2683,12 @@ push_template_decl_real (decl, is_friend)\n \t    if (TREE_VEC_LENGTH (t) != TREE_VEC_LENGTH (a))\n \t      {\n \t\tif (current == decl)\n-\t\t  cp_error (\"got %d template parameters for `%#D'\",\n+\t\t  error (\"got %d template parameters for `%#D'\",\n \t\t\t    TREE_VEC_LENGTH (a), decl);\n \t\telse\n-\t\t  cp_error (\"got %d template parameters for `%#T'\",\n+\t\t  error (\"got %d template parameters for `%#T'\",\n \t\t\t    TREE_VEC_LENGTH (a), current);\n-\t\tcp_error (\"  but %d required\", TREE_VEC_LENGTH (t));\n+\t\terror (\"  but %d required\", TREE_VEC_LENGTH (t));\n \t      }\n \n \t    /* Perhaps we should also check that the parms are used in the\n@@ -2756,7 +2756,7 @@ redeclare_class_template (type, parms)\n \n   if (!TYPE_TEMPLATE_INFO (type))\n     {\n-      cp_error (\"`%T' is not a template type\", type);\n+      error (\"`%T' is not a template type\", type);\n       return;\n     }\n \n@@ -2773,7 +2773,7 @@ redeclare_class_template (type, parms)\n   if (TREE_VEC_LENGTH (parms) != TREE_VEC_LENGTH (tmpl_parms))\n     {\n       cp_error_at (\"previous declaration `%D'\", tmpl);\n-      cp_error (\"used %d template parameter%s instead of %d\",\n+      error (\"used %d template parameter%s instead of %d\",\n \t\tTREE_VEC_LENGTH (tmpl_parms), \n \t\tTREE_VEC_LENGTH (tmpl_parms) == 1 ? \"\" : \"s\",\n \t\tTREE_VEC_LENGTH (parms));\n@@ -2790,7 +2790,7 @@ redeclare_class_template (type, parms)\n       if (TREE_CODE (tmpl_parm) != TREE_CODE (parm))\n \t{\n \t  cp_error_at (\"template parameter `%#D'\", tmpl_parm);\n-\t  cp_error (\"redeclared here as `%#D'\", parm);\n+\t  error (\"redeclared here as `%#D'\", parm);\n \t  return;\n \t}\n \n@@ -2800,7 +2800,7 @@ redeclare_class_template (type, parms)\n \n \t     A template-parameter may not be given default arguments\n \t     by two different declarations in the same scope.  */\n-\t  cp_error (\"redefinition of default argument for `%#D'\", parm);\n+\t  error (\"redefinition of default argument for `%#D'\", parm);\n \t  cp_error_at (\"  original definition appeared here\", tmpl_parm);\n \t  return;\n \t}\n@@ -2894,17 +2894,17 @@ convert_nontype_argument (type, expr)\n \t  if (TREE_CODE (e) != ADDR_EXPR)\n \t    {\n \t    bad_argument:\n-\t      cp_error (\"`%E' is not a valid template argument\", expr);\n+\t      error (\"`%E' is not a valid template argument\", expr);\n \t      if (TYPE_PTR_P (expr_type))\n \t\t{\n \t\t  if (TREE_CODE (TREE_TYPE (expr_type)) == FUNCTION_TYPE)\n-\t\t    cp_error (\"it must be the address of a function with external linkage\");\n+\t\t    error (\"it must be the address of a function with external linkage\");\n \t\t  else\n-\t\t    cp_error (\"it must be the address of an object with external linkage\");\n+\t\t    error (\"it must be the address of an object with external linkage\");\n \t\t}\n \t      else if (TYPE_PTRMEM_P (expr_type)\n \t\t       || TYPE_PTRMEMFUNC_P (expr_type))\n-\t\tcp_error (\"it must be a pointer-to-member of the form `&X::Y'\");\n+\t\terror (\"it must be a pointer-to-member of the form `&X::Y'\");\n \n \t      return NULL_TREE;\n \t    }\n@@ -2915,7 +2915,7 @@ convert_nontype_argument (type, expr)\n \n       if (TREE_CODE (referent) == STRING_CST)\n \t{\n-\t  cp_error (\"string literal %E is not a valid template argument because it is the address of an object with static linkage\", \n+\t  error (\"string literal %E is not a valid template argument because it is the address of an object with static linkage\", \n \t\t    referent);\n \t  return NULL_TREE;\n \t}\n@@ -2927,7 +2927,7 @@ convert_nontype_argument (type, expr)\n \tgoto bad_argument;\n       else if (!DECL_EXTERNAL_LINKAGE_P (referent))\n \t{\n-\t  cp_error (\"address of non-extern `%E' cannot be used as template argument\", referent); \n+\t  error (\"address of non-extern `%E' cannot be used as template argument\", referent); \n \t  return error_mark_node;\n \t}\n     }\n@@ -2938,14 +2938,14 @@ convert_nontype_argument (type, expr)\n       if (! TREE_CONSTANT (expr))\n \t{\n \tnon_constant:\n-\t  cp_error (\"non-constant `%E' cannot be used as template argument\",\n+\t  error (\"non-constant `%E' cannot be used as template argument\",\n \t\t    expr);\n \t  return NULL_TREE;\n \t}\n     }\n   else \n     {\n-      cp_error (\"object `%E' cannot be used as template argument\", expr);\n+      error (\"object `%E' cannot be used as template argument\", expr);\n       return NULL_TREE;\n     }\n \n@@ -3321,7 +3321,7 @@ convert_template_argument (parm, arg, args, complain, i, in_decl)\n   if (requires_type && ! is_type && TREE_CODE (arg) == SCOPE_REF\n       && TREE_CODE (TREE_OPERAND (arg, 0)) == TEMPLATE_TYPE_PARM)\n     {\n-      cp_pedwarn (\"to refer to a type member of a template parameter, use `typename %E'\", arg);\n+      pedwarn (\"to refer to a type member of a template parameter, use `typename %E'\", arg);\n       \n       arg = make_typename_type (TREE_OPERAND (arg, 0),\n \t\t\t\tTREE_OPERAND (arg, 1),\n@@ -3334,14 +3334,14 @@ convert_template_argument (parm, arg, args, complain, i, in_decl)\n \t{\n \t  if (complain)\n \t    {\n-\t      cp_error (\"type/value mismatch at argument %d in template parameter list for `%D'\",\n+\t      error (\"type/value mismatch at argument %d in template parameter list for `%D'\",\n \t\t\ti + 1, in_decl);\n \t      if (is_type)\n-\t\tcp_error (\"  expected a constant of type `%T', got `%T'\",\n+\t\terror (\"  expected a constant of type `%T', got `%T'\",\n \t\t\t  TREE_TYPE (parm),\n \t\t\t  (is_tmpl_type ? DECL_NAME (arg) : arg));\n \t      else\n-\t\tcp_error (\"  expected a type, got `%E'\", arg);\n+\t\terror (\"  expected a type, got `%E'\", arg);\n \t    }\n \t}\n       return error_mark_node;\n@@ -3350,12 +3350,12 @@ convert_template_argument (parm, arg, args, complain, i, in_decl)\n     {\n       if (in_decl && complain)\n \t{\n-\t  cp_error (\"type/value mismatch at argument %d in template parameter list for `%D'\",\n+\t  error (\"type/value mismatch at argument %d in template parameter list for `%D'\",\n \t\t    i + 1, in_decl);\n \t  if (is_tmpl_type)\n-\t    cp_error (\"  expected a type, got `%T'\", DECL_NAME (arg));\n+\t    error (\"  expected a type, got `%T'\", DECL_NAME (arg));\n \t  else\n-\t    cp_error (\"  expected a class template, got `%T'\", arg);\n+\t    error (\"  expected a class template, got `%T'\", arg);\n \t}\n       return error_mark_node;\n     }\n@@ -3389,9 +3389,9 @@ convert_template_argument (parm, arg, args, complain, i, in_decl)\n \t\t{\n \t\t  if (in_decl && complain)\n \t\t    {\n-\t\t      cp_error (\"type/value mismatch at argument %d in template parameter list for `%D'\",\n+\t\t      error (\"type/value mismatch at argument %d in template parameter list for `%D'\",\n \t\t\t\ti + 1, in_decl);\n-\t\t      cp_error (\"  expected a template of type `%D', got `%D'\", parm, arg);\n+\t\t      error (\"  expected a template of type `%D', got `%D'\", parm, arg);\n \t\t    }\n \t\t  \n \t\t  val = error_mark_node;\n@@ -3412,10 +3412,10 @@ convert_template_argument (parm, arg, args, complain, i, in_decl)\n \t      if (t)\n \t\t{\n \t\t  if (TYPE_ANONYMOUS_P (t))\n-\t\t    cp_pedwarn\n+\t\t    pedwarn\n \t\t      (\"template-argument `%T' uses anonymous type\", val);\n \t\t  else\n-\t\t    cp_error\n+\t\t    error\n \t\t      (\"template-argument `%T' uses local type `%T'\",\n \t\t       val, t);\n \t\t  return error_mark_node;\n@@ -3451,7 +3451,7 @@ convert_template_argument (parm, arg, args, complain, i, in_decl)\n       if (val == NULL_TREE)\n \tval = error_mark_node;\n       else if (val == error_mark_node && complain)\n-\tcp_error (\"could not convert template argument `%E' to `%T'\", \n+\terror (\"could not convert template argument `%E' to `%T'\", \n \t\t  arg, t);\n     }\n \n@@ -3495,7 +3495,7 @@ coerce_template_parms (parms, args, in_decl,\n     {\n       if (complain) \n \t{\n-\t  cp_error (\"wrong number of template arguments (%d, should be %d)\",\n+\t  error (\"wrong number of template arguments (%d, should be %d)\",\n \t\t    nargs, nparms);\n \t  \n \t  if (in_decl)\n@@ -3546,7 +3546,7 @@ coerce_template_parms (parms, args, in_decl,\n \t}\n       else if (arg == error_mark_node)\n \t{\n-\t  cp_error (\"template argument %d is invalid\", i + 1);\n+\t  error (\"template argument %d is invalid\", i + 1);\n \t  arg = error_mark_node;\n \t}\n       else \n@@ -3778,7 +3778,7 @@ lookup_template_function (fns, arglist)\n \n   if (fns == NULL_TREE)\n     {\n-      cp_error (\"non-template used as template\");\n+      error (\"non-template used as template\");\n       return error_mark_node;\n     }\n \n@@ -3896,7 +3896,7 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope, complain)\n   if (! template)\n     {\n       if (complain)\n-        cp_error (\"`%T' is not a template\", d1);\n+        error (\"`%T' is not a template\", d1);\n       return error_mark_node;\n     }\n \n@@ -3909,7 +3909,7 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope, complain)\n     {\n       if (complain)\n         {\n-          cp_error (\"non-template type `%T' used as a template\", d1);\n+          error (\"non-template type `%T' used as a template\", d1);\n           if (in_decl)\n \t    cp_error_at (\"for template declaration `%D'\", in_decl);\n \t}\n@@ -4474,7 +4474,7 @@ push_tinst_level (d)\n \treturn 0;\n \n       last_template_error_tick = tinst_level_tick;\n-      cp_error (\"template instantiation depth exceeds maximum of %d (use -ftemplate-depth-NN to increase the maximum) instantiating `%D'\",\n+      error (\"template instantiation depth exceeds maximum of %d (use -ftemplate-depth-NN to increase the maximum) instantiating `%D'\",\n \t     max_tinst_depth, d);\n \n       print_instantiation_context ();\n@@ -4909,7 +4909,7 @@ instantiate_class_template (type)\n       if (t == error_mark_node)\n \t{\n \t  const char *str = \"candidates are:\";\n-\t  cp_error (\"ambiguous class template instantiation for `%#T'\", type);\n+\t  error (\"ambiguous class template instantiation for `%#T'\", type);\n \t  for (t = DECL_TEMPLATE_SPECIALIZATIONS (template); t; \n \t       t = TREE_CHAIN (t))\n \t    {\n@@ -6094,7 +6094,7 @@ tsubst_arg_types (arg_types, args, complain, in_decl)\n     {\n       if (complain)\n         {\n-          cp_error (\"invalid parameter type `%T'\", type);\n+          error (\"invalid parameter type `%T'\", type);\n           if (in_decl)\n             cp_error_at (\"in declaration `%D'\", in_decl);\n         }\n@@ -6171,7 +6171,7 @@ tsubst_function_type (t, args, complain, in_decl)\n \t     -- Attempting to create \"pointer to member of T\" when T\n \t     is not a class type.  */\n \t  if (complain)\n-\t    cp_error (\"creating pointer to member function of non-class type `%T'\",\n+\t    error (\"creating pointer to member function of non-class type `%T'\",\n \t\t      r);\n \t  return error_mark_node;\n \t}\n@@ -6348,7 +6348,7 @@ tsubst (t, args, complain, in_decl)\n \t\t Attempting to create an array with a size that is\n \t\t zero or negative.  */\n \t    if (complain)\n-\t      cp_error (\"creating array with size zero (`%E')\", max);\n+\t      error (\"creating array with size zero (`%E')\", max);\n \n \t    return error_mark_node;\n \t  }\n@@ -6586,9 +6586,9 @@ tsubst (t, args, complain, in_decl)\n \t\t\t     last_file != input_filename))\n \t      {\n \t\tif (TREE_CODE (type) == VOID_TYPE)\n-\t\t  cp_error (\"forming reference to void\");\n+\t\t  error (\"forming reference to void\");\n \t\telse\n-\t\t  cp_error (\"forming %s to reference type `%T'\",\n+\t\t  error (\"forming %s to reference type `%T'\",\n \t\t\t    (code == POINTER_TYPE) ? \"pointer\" : \"reference\",\n \t\t\t    type);\n \t\tlast_line = lineno;\n@@ -6622,7 +6622,7 @@ tsubst (t, args, complain, in_decl)\n \t       -- Attempting to create \"pointer to member of T\" when T\n \t          is not a class type.  */\n \t    if (complain)\n-\t      cp_error (\"creating pointer to member of non-class type `%T'\", \n+\t      error (\"creating pointer to member of non-class type `%T'\", \n \t\t\tr);\n \t    return error_mark_node;\n \t  }\n@@ -6684,7 +6684,7 @@ tsubst (t, args, complain, in_decl)\n \t    || TREE_CODE (type) == REFERENCE_TYPE)\n \t  {\n \t    if (complain)\n-\t      cp_error (\"creating array of `%T'\", type);\n+\t      error (\"creating array of `%T'\", type);\n \t    return error_mark_node;\n \t  }\n \n@@ -6730,7 +6730,7 @@ tsubst (t, args, complain, in_decl)\n \tif (!IS_AGGR_TYPE (ctx))\n \t  {\n \t    if (complain)\n-\t      cp_error (\"`%T' is not a class, struct, or union type\",\n+\t      error (\"`%T' is not a class, struct, or union type\",\n \t\t\tctx);\n \t    return error_mark_node;\n \t  }\n@@ -7624,8 +7624,8 @@ instantiate_template (tmpl, targ_ptr)\n \t  tree nt = target_type (t);\n \t  if (IS_AGGR_TYPE (nt) && decl_function_context (TYPE_MAIN_DECL (nt)))\n \t    {\n-\t      cp_error (\"type `%T' composed from a local class is not a valid template-argument\", t);\n-\t      cp_error (\"  trying to instantiate `%D'\", gen_tmpl);\n+\t      error (\"type `%T' composed from a local class is not a valid template-argument\", t);\n+\t      error (\"  trying to instantiate `%D'\", gen_tmpl);\n \t      return error_mark_node;\n \t    }\n \t}\n@@ -9432,7 +9432,7 @@ do_decl_instantiation (declspecs, declarator, storage)\n     return;\n   else if (! DECL_LANG_SPECIFIC (decl))\n     {\n-      cp_error (\"explicit instantiation of non-template `%#D'\", decl);\n+      error (\"explicit instantiation of non-template `%#D'\", decl);\n       return;\n     }\n   else if (TREE_CODE (decl) == VAR_DECL)\n@@ -9448,13 +9448,13 @@ do_decl_instantiation (declspecs, declarator, storage)\n       result = lookup_field (DECL_CONTEXT (decl), DECL_NAME (decl), 0, 0);\n       if (result && TREE_CODE (result) != VAR_DECL)\n \t{\n-\t  cp_error (\"no matching template for `%D' found\", result);\n+\t  error (\"no matching template for `%D' found\", result);\n \t  return;\n \t}\n     }\n   else if (TREE_CODE (decl) != FUNCTION_DECL)\n     {\n-      cp_error (\"explicit instantiation of `%#D'\", decl);\n+      error (\"explicit instantiation of `%#D'\", decl);\n       return;\n     }\n   else\n@@ -9471,7 +9471,7 @@ do_decl_instantiation (declspecs, declarator, storage)\n \n \t No program shall both explicitly instantiate and explicitly\n \t specialize a template.  */\n-      cp_pedwarn (\"explicit instantiation of `%#D' after\", result);\n+      pedwarn (\"explicit instantiation of `%#D' after\", result);\n       cp_pedwarn_at (\"explicit specialization here\", result);\n       return;\n     }\n@@ -9487,20 +9487,20 @@ do_decl_instantiation (declspecs, declarator, storage)\n \t the opposite case.  If -frepo, chances are we already got marked\n \t as an explicit instantiation because of the repo file.  */\n       if (DECL_INTERFACE_KNOWN (result) && !extern_p && !flag_use_repository)\n-\tcp_pedwarn (\"duplicate explicit instantiation of `%#D'\", result);\n+\tpedwarn (\"duplicate explicit instantiation of `%#D'\", result);\n \n       /* If we've already instantiated the template, just return now.  */\n       if (DECL_INTERFACE_KNOWN (result))\n \treturn;\n     }\n   else if (!DECL_IMPLICIT_INSTANTIATION (result))\n     {\n-      cp_error (\"no matching template for `%D' found\", result);\n+      error (\"no matching template for `%D' found\", result);\n       return;\n     }\n   else if (!DECL_TEMPLATE_INFO (result))\n     {\n-      cp_pedwarn (\"explicit instantiation of non-template `%#D'\", result);\n+      pedwarn (\"explicit instantiation of non-template `%#D'\", result);\n       return;\n     }\n \n@@ -9512,11 +9512,11 @@ do_decl_instantiation (declspecs, declarator, storage)\n   else if (storage == ridpointers[(int) RID_EXTERN])\n     {\n       if (pedantic)\n-\tcp_pedwarn (\"ISO C++ forbids the use of `extern' on explicit instantiations\");\n+\tpedwarn (\"ISO C++ forbids the use of `extern' on explicit instantiations\");\n       extern_p = 1;\n     }\n   else\n-    cp_error (\"storage class `%D' applied to template instantiation\",\n+    error (\"storage class `%D' applied to template instantiation\",\n \t      storage);\n \n   SET_DECL_EXPLICIT_INSTANTIATION (result);\n@@ -9561,7 +9561,7 @@ do_type_instantiation (t, storage, complain)\n \n   if (! CLASS_TYPE_P (t) || ! CLASSTYPE_TEMPLATE_INFO (t))\n     {\n-      cp_error (\"explicit instantiation of non-template type `%T'\", t);\n+      error (\"explicit instantiation of non-template type `%T'\", t);\n       return;\n     }\n \n@@ -9575,15 +9575,15 @@ do_type_instantiation (t, storage, complain)\n   if (!COMPLETE_TYPE_P (t))\n     {\n       if (complain)\n-\tcp_error (\"explicit instantiation of `%#T' before definition of template\",\n+\terror (\"explicit instantiation of `%#T' before definition of template\",\n \t\t  t);\n       return;\n     }\n \n   if (storage != NULL_TREE)\n     {\n       if (pedantic)\n-\tcp_pedwarn(\"ISO C++ forbids the use of `%s' on explicit instantiations\", \n+\tpedwarn(\"ISO C++ forbids the use of `%s' on explicit instantiations\", \n \t\t   IDENTIFIER_POINTER (storage));\n \n       if (storage == ridpointers[(int) RID_INLINE])\n@@ -9594,7 +9594,7 @@ do_type_instantiation (t, storage, complain)\n \tstatic_p = 1;\n       else\n \t{\n-\t  cp_error (\"storage class `%D' applied to template instantiation\",\n+\t  error (\"storage class `%D' applied to template instantiation\",\n \t\t    storage);\n \t  extern_p = 0;\n \t}\n@@ -9608,7 +9608,7 @@ do_type_instantiation (t, storage, complain)\n \t specialize a template.  */\n       if (complain)\n \t{\n-\t  cp_error (\"explicit instantiation of `%#T' after\", t);\n+\t  error (\"explicit instantiation of `%#T' after\", t);\n \t  cp_error_at (\"explicit specialization here\", t);\n \t}\n       return;\n@@ -9626,7 +9626,7 @@ do_type_instantiation (t, storage, complain)\n \t repo file.  All these cases are OK.  */\n       if (!CLASSTYPE_INTERFACE_ONLY (t) && !extern_p && !flag_use_repository\n \t  && complain)\n-\tcp_pedwarn (\"duplicate explicit instantiation of `%#T'\", t);\n+\tpedwarn (\"duplicate explicit instantiation of `%#T'\", t);\n       \n       /* If we've already instantiated the template, just return now.  */\n       if (!CLASSTYPE_INTERFACE_ONLY (t))\n@@ -9966,7 +9966,7 @@ instantiate_decl (d, defer_ok)\n \t   member function or static data member of a class template\n \t   shall be present in every translation unit in which it is\n \t   explicitly instantiated.  */\n-\tcp_pedwarn\n+\tpedwarn\n \t  (\"explicit instantiation of `%D' but no definition available\", d);\n \n       add_pending_template (d);\n@@ -10339,7 +10339,7 @@ invalid_nontype_parm_type_p (type, complain)\n     return 0;\n            \n   if (complain)\n-    cp_error (\"`%#T' is not a valid type for a template constant parameter\",\n+    error (\"`%#T' is not a valid type for a template constant parameter\",\n               type);\n   return 1;\n }"}, {"sha": "af401299adb3de1daf5d7ab25e7032c68d4bada7", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33bd39a26a88cbaabb2f85735c1ff1e51f2a7111/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33bd39a26a88cbaabb2f85735c1ff1e51f2a7111/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=33bd39a26a88cbaabb2f85735c1ff1e51f2a7111", "patch": "@@ -277,7 +277,7 @@ get_tinfo_decl (type)\n   if (COMPLETE_TYPE_P (type) \n       && TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n     {\n-      cp_error (\"cannot create type information for type `%T' because its size is variable\", \n+      error (\"cannot create type information for type `%T' because its size is variable\", \n \t\ttype);\n       return error_mark_node;\n     }\n@@ -522,7 +522,7 @@ build_dynamic_cast_1 (type, expr)\n \t\t  && TREE_CODE (TREE_TYPE (old_expr)) == RECORD_TYPE)\n \t\t{\n \t          tree expr = throw_bad_cast ();\n-\t\t  cp_warning (\"dynamic_cast of `%#D' to `%#T' can never succeed\",\n+\t\t  warning (\"dynamic_cast of `%#D' to `%#T' can never succeed\",\n \t\t\t      old_expr, type);\n \t          /* Bash it to the expected type.  */\n \t          TREE_TYPE (expr) = type;\n@@ -536,7 +536,7 @@ build_dynamic_cast_1 (type, expr)\n \t      if (TREE_CODE (op) == VAR_DECL\n \t\t  && TREE_CODE (TREE_TYPE (op)) == RECORD_TYPE)\n \t\t{\n-\t\t  cp_warning (\"dynamic_cast of `%#D' to `%#T' can never succeed\",\n+\t\t  warning (\"dynamic_cast of `%#D' to `%#T' can never succeed\",\n \t\t\t      op, type);\n \t\t  retval = build_int_2 (0, 0); \n \t\t  TREE_TYPE (retval) = type; \n@@ -611,7 +611,7 @@ build_dynamic_cast_1 (type, expr)\n     errstr = \"source type is not polymorphic\";\n \n  fail:\n-  cp_error (\"cannot dynamic_cast `%E' (of type `%#T') to type `%#T' (%s)\",\n+  error (\"cannot dynamic_cast `%E' (of type `%#T') to type `%#T' (%s)\",\n \t    expr, exprtype, type, errstr);\n   return error_mark_node;\n }"}, {"sha": "a6a9a6d46e9a30c9e6ec64cdc3a1f1e641c81b48", "filename": "gcc/cp/search.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33bd39a26a88cbaabb2f85735c1ff1e51f2a7111/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33bd39a26a88cbaabb2f85735c1ff1e51f2a7111/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=33bd39a26a88cbaabb2f85735c1ff1e51f2a7111", "patch": "@@ -337,7 +337,7 @@ lookup_base (t, base, access, kind_ptr)\n       binfo = NULL_TREE;\n       if (!(access & ba_quiet))\n \t{\n-\t  cp_error (\"`%T' is an inaccessible base of `%T'\", base, t);\n+\t  error (\"`%T' is an inaccessible base of `%T'\", base, t);\n \t  binfo = error_mark_node;\n \t}\n       break;\n@@ -347,7 +347,7 @@ lookup_base (t, base, access, kind_ptr)\n \t  binfo = NULL_TREE;\n \t  if (!(access & ba_quiet))\n \t    {\n-\t      cp_error (\"`%T' is an ambiguous base of `%T'\", base, t);\n+\t      error (\"`%T' is an ambiguous base of `%T'\", base, t);\n \t      binfo = error_mark_node;\n \t    }\n \t}\n@@ -1456,7 +1456,7 @@ lookup_member (xbasetype, name, protect, want_type)\n \n   if (errstr && protect)\n     {\n-      cp_error (errstr, name, type);\n+      error (errstr, name, type);\n       if (lfi.ambiguous)\n         print_candidates (lfi.ambiguous);\n       rval = error_mark_node;\n@@ -2127,7 +2127,7 @@ get_pure_virtuals (type)\n \t{\n \t  tree base_fndecl = BV_FN (virtuals);\n \t  if (DECL_NEEDS_FINAL_OVERRIDER_P (base_fndecl))\n-\t    cp_error (\"`%#D' needs a final overrider\", base_fndecl);\n+\t    error (\"`%#D' needs a final overrider\", base_fndecl);\n \t}\n     }\n }"}, {"sha": "e2081b57a14f06ca2b57edfbaaca648ecb012b04", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33bd39a26a88cbaabb2f85735c1ff1e51f2a7111/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33bd39a26a88cbaabb2f85735c1ff1e51f2a7111/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=33bd39a26a88cbaabb2f85735c1ff1e51f2a7111", "patch": "@@ -878,7 +878,7 @@ finish_asm_stmt (cv_qualifier, string, output_operands,\n   if (cv_qualifier != NULL_TREE\n       && cv_qualifier != ridpointers[(int) RID_VOLATILE])\n     {\n-      cp_warning (\"%s qualifier ignored on asm\",\n+      warning (\"%s qualifier ignored on asm\",\n \t\t  IDENTIFIER_POINTER (cv_qualifier));\n       cv_qualifier = NULL_TREE;\n     }\n@@ -900,7 +900,7 @@ finish_asm_stmt (cv_qualifier, string, output_operands,\n \t     resolve the overloading.  */\n \t  if (TREE_TYPE (converted_operand) == unknown_type_node)\n \t    {\n-\t      cp_error (\"type of asm operand `%E' could not be determined\", \n+\t      error (\"type of asm operand `%E' could not be determined\", \n \t\t\tTREE_VALUE (t));\n \t      converted_operand = error_mark_node;\n \t    }\n@@ -1051,7 +1051,7 @@ finish_named_return_value (return_id, init)\n \tDECL_NAME (decl) = return_id;\n       else\n \t{\n-\t  cp_error (\"return identifier `%D' already in place\", return_id);\n+\t  error (\"return identifier `%D' already in place\", return_id);\n \t  return;\n \t}\n     }\n@@ -1126,7 +1126,7 @@ finish_mem_initializers (init_list)\n \t\t   base != last_base_warned_about; \n \t\t   base = TREE_CHAIN (base))\n \t\t{\n-\t\t  cp_warning (\"base initializer for `%T'\",\n+\t\t  warning (\"base initializer for `%T'\",\n \t\t\t      TREE_PURPOSE (base));\n \t\t  warning (\"   will be re-ordered to precede member initializations\");\n \t\t}\n@@ -1444,7 +1444,7 @@ finish_object_call_expr (fn, object, args)\n \tfn = DECL_NAME (fn);\n       else\n \t{\n-\t  cp_error (\"calling type `%T' like a method\", fn);\n+\t  error (\"calling type `%T' like a method\", fn);\n \t  return error_mark_node;\n \t}\n     }\n@@ -1480,13 +1480,13 @@ finish_pseudo_destructor_call_expr (object, scope, destructor)\n     return build_min_nt (PSEUDO_DTOR_EXPR, object, scope, destructor);\n \n   if (scope && scope != destructor)\n-    cp_error (\"destructor specifier `%T::~%T()' must have matching names\", \n+    error (\"destructor specifier `%T::~%T()' must have matching names\", \n \t      scope, destructor);\n \n   if ((scope == NULL_TREE || IDENTIFIER_GLOBAL_VALUE (destructor))\n       && (TREE_CODE (TREE_TYPE (object)) !=\n \t  TREE_CODE (TREE_TYPE (IDENTIFIER_GLOBAL_VALUE (destructor)))))\n-    cp_error (\"`%E' is not of type `%T'\", object, destructor);\n+    error (\"`%E' is not of type `%T'\", object, destructor);\n \n   return cp_convert (void_type_node, object);\n }\n@@ -1757,7 +1757,7 @@ begin_class_definition (t)\n   \n   if (processing_template_parmlist)\n     {\n-      cp_error (\"definition of `%#T' inside template parameter list\", t);\n+      error (\"definition of `%#T' inside template parameter list\", t);\n       return error_mark_node;\n     }\n \n@@ -1773,7 +1773,7 @@ begin_class_definition (t)\n      This is erroneous.  */\n   else if (TREE_CODE (t) == TYPENAME_TYPE)\n     {\n-      cp_error (\"invalid definition of qualified type `%T'\", t);\n+      error (\"invalid definition of qualified type `%T'\", t);\n       t = error_mark_node;\n     }\n \n@@ -2125,7 +2125,7 @@ finish_base_specifier (access_specifier, base_class)\n     {\n       if (cp_type_quals (base_class) != 0)\n         {\n-          cp_error (\"base class `%T' has cv qualifiers\", base_class);\n+          error (\"base class `%T' has cv qualifiers\", base_class);\n           base_class = TYPE_MAIN_VARIANT (base_class);\n         }\n       result = build_tree_list (access_specifier, base_class);\n@@ -2158,7 +2158,7 @@ check_multiple_declarators ()\n   if (PROCESSING_REAL_TEMPLATE_DECL_P () \n       || processing_explicit_instantiation\n       || processing_specialization)\n-    cp_error (\"multiple declarators in template declaration\");\n+    error (\"multiple declarators in template declaration\");\n }\n \n /* Implement the __typeof keyword: Return the type of EXPR, suitable for"}, {"sha": "138e23e6145c60c9410a71ce9f64fd9b917d9c66", "filename": "gcc/cp/spew.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33bd39a26a88cbaabb2f85735c1ff1e51f2a7111/gcc%2Fcp%2Fspew.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33bd39a26a88cbaabb2f85735c1ff1e51f2a7111/gcc%2Fcp%2Fspew.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fspew.c?ref=33bd39a26a88cbaabb2f85735c1ff1e51f2a7111", "patch": "@@ -1432,7 +1432,7 @@ replace_defarg (arg, init)\n     {\n       if (! processing_template_decl\n           && ! can_convert_arg (TREE_VALUE (arg), TREE_TYPE (init), init))\n-        cp_pedwarn (\"invalid type `%T' for default argument to `%T'\",\n+        pedwarn (\"invalid type `%T' for default argument to `%T'\",\n   \t    \t    TREE_TYPE (init), TREE_VALUE (arg));\n       if (!defarg_depfns)\n         TREE_PURPOSE (arg) = init;"}, {"sha": "b1271442a3628523fb3a3554158269a6a4409276", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33bd39a26a88cbaabb2f85735c1ff1e51f2a7111/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33bd39a26a88cbaabb2f85735c1ff1e51f2a7111/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=33bd39a26a88cbaabb2f85735c1ff1e51f2a7111", "patch": "@@ -533,7 +533,7 @@ cp_build_qualified_type_real (type, type_quals, complain)\n \t  || TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE))\n     {\n       if (complain)\n-\tcp_error (\"`%T' cannot be `restrict'-qualified\", type);\n+\terror (\"`%T' cannot be `restrict'-qualified\", type);\n       else\n \treturn error_mark_node;\n \n@@ -544,7 +544,7 @@ cp_build_qualified_type_real (type, type_quals, complain)\n       && TREE_CODE (type) == FUNCTION_TYPE)\n     {\n       if (complain)\n-\tcp_error (\"`%T' cannot be `const'-, `volatile'-, or `restrict'-qualified\", type);\n+\terror (\"`%T' cannot be `const'-, `volatile'-, or `restrict'-qualified\", type);\n       else\n \treturn error_mark_node;\n       type_quals = TYPE_UNQUALIFIED;"}, {"sha": "d5ba0840f08ec4fabade82c01b169a43b59b47ad", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 69, "deletions": 69, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33bd39a26a88cbaabb2f85735c1ff1e51f2a7111/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33bd39a26a88cbaabb2f85735c1ff1e51f2a7111/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=33bd39a26a88cbaabb2f85735c1ff1e51f2a7111", "patch": "@@ -506,7 +506,7 @@ composite_pointer_type (t1, t2, arg1, arg2, location)\n \tresult_type = full2;\n       else\n \t{\n-\t  cp_pedwarn (\"%s between distinct pointer types `%T' and `%T' lacks a cast\",\n+\t  pedwarn (\"%s between distinct pointer types `%T' and `%T' lacks a cast\",\n \t\t      location, t1, t2);\n \t  result_type = ptr_type_node;\n \t}\n@@ -1490,7 +1490,7 @@ comp_target_parms (parms1, parms2)\n \n   if (t1 == 0 && t2 != 0)\n     {\n-      cp_pedwarn (\"ISO C++ prohibits conversion from `%#T' to `(...)'\",\n+      pedwarn (\"ISO C++ prohibits conversion from `%#T' to `(...)'\",\n \t\t  parms2);\n       return self_promoting_args_p (t2);\n     }\n@@ -1586,12 +1586,12 @@ c_sizeof (type)\n \n       if (code == OFFSET_TYPE)\n \t{\n-\t  cp_error (\"`sizeof' applied to non-static member\");\n+\t  error (\"`sizeof' applied to non-static member\");\n \t  size = size_zero_node;\n \t}\n       else if (!COMPLETE_TYPE_P (complete_type (type)))\n \t{\n-\t  cp_error (\"`sizeof' applied to incomplete type `%T'\", type);\n+\t  error (\"`sizeof' applied to incomplete type `%T'\", type);\n \t  size = size_zero_node;\n \t}\n       else\n@@ -1877,7 +1877,7 @@ string_conv_p (totype, exp, warn)\n \n   /* This warning is not very useful, as it complains about printf.  */\n   if (warn && warn_write_strings)\n-    cp_warning (\"deprecated conversion from string constant to `%T'\", totype);\n+    warning (\"deprecated conversion from string constant to `%T'\", totype);\n \n   return 1;\n }\n@@ -1895,7 +1895,7 @@ build_object_ref (datum, basetype, field)\n     dtype = TREE_TYPE (dtype);\n   if (! IS_AGGR_TYPE_CODE (TREE_CODE (dtype)))\n     {\n-      cp_error (\"request for member `%T::%D' in expression of non-aggregate type `%T'\",\n+      error (\"request for member `%T::%D' in expression of non-aggregate type `%T'\",\n \t\tbasetype, field, dtype);\n       return error_mark_node;\n     }\n@@ -2038,7 +2038,7 @@ build_component_ref (datum, component, basetype_path, protect)\n \t\t\t      basetype_path, protect));\n \n     case TEMPLATE_DECL:\n-      cp_error (\"invalid use of %D\", datum);\n+      error (\"invalid use of %D\", datum);\n       datum = error_mark_node;\n       break;\n \n@@ -2076,7 +2076,7 @@ build_component_ref (datum, component, basetype_path, protect)\n   if (! IS_AGGR_TYPE_CODE (code))\n     {\n       if (code != ERROR_MARK)\n-\tcp_error (\"request for member `%D' in `%E', which is of non-aggregate type `%T'\",\n+\terror (\"request for member `%D' in `%E', which is of non-aggregate type `%T'\",\n \t\t  component, datum, basetype);\n       return error_mark_node;\n     }\n@@ -2088,13 +2088,13 @@ build_component_ref (datum, component, basetype_path, protect)\n     {\n       if (TYPE_IDENTIFIER (basetype) != TREE_OPERAND (component, 0))\n \t{\n-\t  cp_error (\"destructor specifier `%T::~%T' must have matching names\",\n+\t  error (\"destructor specifier `%T::~%T' must have matching names\",\n \t\t    basetype, TREE_OPERAND (component, 0));\n \t  return error_mark_node;\n \t}\n       if (! TYPE_HAS_DESTRUCTOR (basetype))\n \t{\n-\t  cp_error (\"type `%T' has no destructor\", basetype);\n+\t  error (\"type `%T' has no destructor\", basetype);\n \t  return error_mark_node;\n \t}\n       return TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (basetype), 1);\n@@ -2111,12 +2111,12 @@ build_component_ref (datum, component, basetype_path, protect)\n     field = component;\n   else if (TREE_CODE (component) == TYPE_DECL)\n     {\n-      cp_error (\"invalid use of type decl `%#D' as expression\", component);\n+      error (\"invalid use of type decl `%#D' as expression\", component);\n       return error_mark_node;\n     }\n   else if (TREE_CODE (component) == TEMPLATE_DECL)\n     {\n-      cp_error (\"invalid use of template `%#D' as expression\", component);\n+      error (\"invalid use of template `%#D' as expression\", component);\n       return error_mark_node;\n     }\n   else\n@@ -2175,7 +2175,7 @@ build_component_ref (datum, component, basetype_path, protect)\n \t      return ref;\n \t    }\n \n-\t  cp_error (\"`%#T' has no member named `%D'\", basetype, name);\n+\t  error (\"`%#T' has no member named `%D'\", basetype, name);\n \t  return error_mark_node;\n \t}\n       else if (TREE_TYPE (field) == error_mark_node)\n@@ -2184,7 +2184,7 @@ build_component_ref (datum, component, basetype_path, protect)\n       if (TREE_CODE (field) != FIELD_DECL)\n \t{\n \t  if (TREE_CODE (field) == TYPE_DECL)\n-\t    cp_pedwarn (\"invalid use of type decl `%#D' as expression\", field);\n+\t    pedwarn (\"invalid use of type decl `%#D' as expression\", field);\n \t  else if (DECL_RTL (field) != 0)\n \t    mark_used (field);\n \t  else\n@@ -2342,7 +2342,7 @@ build_indirect_ref (ptr, errorstring)\n         {\n           /* A pointer to incomplete type (other than cv void) can be\n              dereferenced [expr.unary.op]/1  */\n-          cp_error (\"`%T' is not a pointer-to-object type\", type);\n+          error (\"`%T' is not a pointer-to-object type\", type);\n           return error_mark_node;\n         }\n       else if (TREE_CODE (pointer) == ADDR_EXPR\n@@ -2688,7 +2688,7 @@ build_x_function_call (function, params, decl)\n \t{\n \t  if (current_class_type == NULL_TREE)\n \t    {\n-\t      cp_error (\"object missing in call to method `%D'\", function);\n+\t      error (\"object missing in call to method `%D'\", function);\n \t      return error_mark_node;\n \t    }\n \t  /* Yow: call from a static member function.  */\n@@ -2722,7 +2722,7 @@ build_x_function_call (function, params, decl)\n     {\n       if (OVL_FUNCTION (function) == NULL_TREE)\n \t{\n-\t  cp_error (\"function `%D' declared overloaded, but no definitions appear with which to resolve it?!?\",\n+\t  error (\"function `%D' declared overloaded, but no definitions appear with which to resolve it?!?\",\n \t\t    TREE_PURPOSE (function));\n \t  return error_mark_node;\n \t}\n@@ -2946,7 +2946,7 @@ get_member_function_from_ptrfunc (instance_ptrptr, function)\n       if (instance_ptr == error_mark_node\n \t  && TREE_CODE (e1) != ADDR_EXPR\n \t  && TREE_CODE (TREE_OPERAND (e1, 0)) != FUNCTION_DECL)\n-\tcp_error (\"object missing in `%E'\", function);\n+\terror (\"object missing in `%E'\", function);\n \n       function = e1;\n     }\n@@ -3010,7 +3010,7 @@ build_function_call_real (function, params, require_complete, flags)\n \n   if (TYPE_PTRMEMFUNC_P (fntype))\n     {\n-      cp_error (\"must use .* or ->* to call pointer-to-member function in `%E (...)'\",\n+      error (\"must use .* or ->* to call pointer-to-member function in `%E (...)'\",\n \t\tfunction);\n       return error_mark_node;\n     }\n@@ -3023,7 +3023,7 @@ build_function_call_real (function, params, require_complete, flags)\n \t|| is_method\n \t|| TREE_CODE (function) == TEMPLATE_ID_EXPR))\n     {\n-      cp_error (\"`%E' cannot be used as a function\", function);\n+      error (\"`%E' cannot be used as a function\", function);\n       return error_mark_node;\n     }\n \n@@ -3384,7 +3384,7 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n       tree t = instantiate_type (TREE_TYPE (op1), op0, itf_none);\n       if (t != error_mark_node)\n \t{\n-\t  cp_pedwarn (\"assuming cast to type `%T' from overloaded function\",\n+\t  pedwarn (\"assuming cast to type `%T' from overloaded function\",\n \t\t      TREE_TYPE (t));\n \t  op0 = t;\n \t}\n@@ -3394,7 +3394,7 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n       tree t = instantiate_type (TREE_TYPE (op0), op1, itf_none);\n       if (t != error_mark_node)\n \t{\n-\t  cp_pedwarn (\"assuming cast to type `%T' from overloaded function\",\n+\t  pedwarn (\"assuming cast to type `%T' from overloaded function\",\n \t\t      TREE_TYPE (t));\n \t  op1 = t;\n \t}\n@@ -3454,9 +3454,9 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t      || code1 == COMPLEX_TYPE))\n \t{\n \t  if (TREE_CODE (op1) == INTEGER_CST && integer_zerop (op1))\n-\t    cp_warning (\"division by zero in `%E / 0'\", op0);\n+\t    warning (\"division by zero in `%E / 0'\", op0);\n \t  else if (TREE_CODE (op1) == REAL_CST && real_zerop (op1))\n-\t    cp_warning (\"division by zero in `%E / 0.'\", op0);\n+\t    warning (\"division by zero in `%E / 0.'\", op0);\n \t      \n \t  if (!(code0 == INTEGER_TYPE && code1 == INTEGER_TYPE))\n \t    resultcode = RDIV_EXPR;\n@@ -3511,9 +3511,9 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n     case TRUNC_MOD_EXPR:\n     case FLOOR_MOD_EXPR:\n       if (code1 == INTEGER_TYPE && integer_zerop (op1))\n-\tcp_warning (\"division by zero in `%E %% 0'\", op0);\n+\twarning (\"division by zero in `%E %% 0'\", op0);\n       else if (code1 == REAL_TYPE && real_zerop (op1))\n-\tcp_warning (\"division by zero in `%E %% 0.'\", op0);\n+\twarning (\"division by zero in `%E %% 0.'\", op0);\n       \n       if (code0 == INTEGER_TYPE && code1 == INTEGER_TYPE)\n \t{\n@@ -3908,7 +3908,7 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t      && TYPE_MAIN_VARIANT (TREE_TYPE (orig_op0))\n \t         != TYPE_MAIN_VARIANT (TREE_TYPE (orig_op1)))\n \t    {\n-\t      cp_warning (\"comparison between types `%#T' and `%#T'\", \n+\t      warning (\"comparison between types `%#T' and `%#T'\", \n \t\t\t  TREE_TYPE (orig_op0), TREE_TYPE (orig_op1));\n \t    }\n \n@@ -4009,7 +4009,7 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \n   if (!result_type)\n     {\n-      cp_error (\"invalid operands of types `%T' and `%T' to binary `%O'\",\n+      error (\"invalid operands of types `%T' and `%T' to binary `%O'\",\n \t\tTREE_TYPE (orig_op0), TREE_TYPE (orig_op1), code);\n       return error_mark_node;\n     }\n@@ -4031,7 +4031,7 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n        performed.  Note that pointer-difference and pointer-addition\n        have already been handled above, and so we don't end up here in\n        that case.  */\n-    cp_warning (\"NULL used in arithmetic\");\n+    warning (\"NULL used in arithmetic\");\n \n   if (! converted)\n     {\n@@ -4227,7 +4227,7 @@ build_component_addr (arg, argtype)\n \n   if (DECL_C_BIT_FIELD (field))\n     {\n-      cp_error (\"attempt to take address of bit-field structure member `%D'\",\n+      error (\"attempt to take address of bit-field structure member `%D'\",\n                 field);\n       return error_mark_node;\n     }\n@@ -4512,14 +4512,14 @@ build_unary_op (code, xarg, noconvert)\n \t    tree type = complete_type (TREE_TYPE (argtype));\n \t    \n \t    if (!COMPLETE_OR_VOID_TYPE_P (type))\n-\t      cp_error (\"cannot %s a pointer to incomplete type `%T'\",\n+\t      error (\"cannot %s a pointer to incomplete type `%T'\",\n \t\t\t((code == PREINCREMENT_EXPR\n \t\t\t  || code == POSTINCREMENT_EXPR)\n \t\t\t ? \"increment\" : \"decrement\"), TREE_TYPE (argtype));\n \t    else if ((pedantic || warn_pointer_arith)\n \t\t     && (tmp == FUNCTION_TYPE || tmp == METHOD_TYPE\n \t\t\t || tmp == VOID_TYPE || tmp == OFFSET_TYPE))\n-\t      cp_pedwarn (\"ISO C++ forbids %sing a pointer of type `%T'\",\n+\t      pedwarn (\"ISO C++ forbids %sing a pointer of type `%T'\",\n \t\t\t  ((code == PREINCREMENT_EXPR\n \t\t\t    || code == POSTINCREMENT_EXPR)\n \t\t\t   ? \"increment\" : \"decrement\"), argtype);\n@@ -4578,7 +4578,7 @@ build_unary_op (code, xarg, noconvert)\n \t  {\n \t    if (code == POSTDECREMENT_EXPR || code == PREDECREMENT_EXPR)\n \t      {\n-\t\tcp_error (\"invalid use of `--' on bool variable `%D'\", arg);\n+\t\terror (\"invalid use of `--' on bool variable `%D'\", arg);\n \t\treturn error_mark_node;\n \t      }\n #if 0\n@@ -4678,9 +4678,9 @@ build_unary_op (code, xarg, noconvert)\n \t      if (current_class_type\n \t\t  && TREE_OPERAND (arg, 0) == current_class_ref)\n \t\t/* An expression like &memfn.  */\n-\t\tcp_pedwarn (\"ISO C++ forbids taking the address of an unqualified non-static member function to form a pointer to member function.  Say `&%T::%D'\", base, name);\n+\t\tpedwarn (\"ISO C++ forbids taking the address of an unqualified non-static member function to form a pointer to member function.  Say `&%T::%D'\", base, name);\n \t      else\n-\t\tcp_pedwarn (\"ISO C++ forbids taking the address of a bound member function to form a pointer to member function.  Say `&%T::%D'\", base, name);\n+\t\tpedwarn (\"ISO C++ forbids taking the address of a bound member function to form a pointer to member function.  Say `&%T::%D'\", base, name);\n \t    }\n \t  arg = build_offset_ref (base, name);\n         }\n@@ -4840,7 +4840,7 @@ unary_complex_lvalue (code, arg)\n       if (TREE_CODE (t) == FUNCTION_DECL)\n \t{\n \t  if (DECL_DESTRUCTOR_P (t))\n-\t    cp_error (\"taking address of destructor\");\n+\t    error (\"taking address of destructor\");\n \t  return build_unary_op (ADDR_EXPR, t, 0);\n \t}\n       if (TREE_CODE (t) == VAR_DECL)\n@@ -4853,7 +4853,7 @@ unary_complex_lvalue (code, arg)\n \t      && ! is_dummy_object (TREE_OPERAND (arg, 0))\n \t      && TREE_CODE (t) != FIELD_DECL)\n \t    {\n-\t      cp_error (\"taking address of bound pointer-to-member expression\");\n+\t      error (\"taking address of bound pointer-to-member expression\");\n \t      return error_mark_node;\n \t    }\n \n@@ -4937,7 +4937,7 @@ mark_addressable (exp)\n       case RESULT_DECL:\n \tif (DECL_REGISTER (x) && !TREE_ADDRESSABLE (x)\n \t    && !DECL_ARTIFICIAL (x) && extra_warnings)\n-\t  cp_warning (\"address requested for `%D', which is declared `register'\",\n+\t  warning (\"address requested for `%D', which is declared `register'\",\n \t\t      x);\n \tTREE_ADDRESSABLE (x) = 1;\n \treturn 1;\n@@ -5141,15 +5141,15 @@ build_static_cast (type, expr)\n      constness.  */\n   if (ok && casts_away_constness (intype, type))\n     {\n-      cp_error (\"static_cast from type `%T' to type `%T' casts away constness\",\n+      error (\"static_cast from type `%T' to type `%T' casts away constness\",\n \t\tintype, type);\n       return error_mark_node;\n     }\n \n   if (ok)\n     return build_c_cast (type, expr);\n \n-  cp_error (\"invalid static_cast from type `%T' to type `%T'\", intype, type);\n+  error (\"invalid static_cast from type `%T' to type `%T'\", intype, type);\n   return error_mark_node;\n }\n \n@@ -5188,7 +5188,7 @@ build_reinterpret_cast (type, expr)\n     {\n       if (! real_lvalue_p (expr))\n \t{\n-\t  cp_error (\"invalid reinterpret_cast of an rvalue expression of type `%T' to type `%T'\", intype, type);\n+\t  error (\"invalid reinterpret_cast of an rvalue expression of type `%T' to type `%T'\", intype, type);\n \t  return error_mark_node;\n \t}\n       expr = build_unary_op (ADDR_EXPR, expr, 0);\n@@ -5208,7 +5208,7 @@ build_reinterpret_cast (type, expr)\n   else if (TREE_CODE (type) == INTEGER_TYPE && TYPE_PTR_P (intype))\n     {\n       if (TYPE_PRECISION (type) < TYPE_PRECISION (intype))\n-\tcp_pedwarn (\"reinterpret_cast from `%T' to `%T' loses precision\",\n+\tpedwarn (\"reinterpret_cast from `%T' to `%T' loses precision\",\n \t\t    intype, type);\n     }\n   else if ((TYPE_PTRFN_P (type) && TYPE_PTRFN_P (intype))\n@@ -5221,7 +5221,7 @@ build_reinterpret_cast (type, expr)\n \t   || (TYPE_PTROBV_P (type) && TYPE_PTROBV_P (intype)))\n     {\n       if (! comp_ptr_ttypes_reinterpret (TREE_TYPE (type), TREE_TYPE (intype)))\n-\tcp_pedwarn (\"reinterpret_cast from `%T' to `%T' casts away const (or volatile)\",\n+\tpedwarn (\"reinterpret_cast from `%T' to `%T' casts away const (or volatile)\",\n \t\t    intype, type);\n \n       expr = decl_constant_value (expr);\n@@ -5236,7 +5236,7 @@ build_reinterpret_cast (type, expr)\n     }\n   else\n     {\n-      cp_error (\"invalid reinterpret_cast from type `%T' to type `%T'\",\n+      error (\"invalid reinterpret_cast from type `%T' to type `%T'\",\n                 intype, type);\n       return error_mark_node;\n     }\n@@ -5263,10 +5263,10 @@ build_const_cast (type, expr)\n     }\n \n   if (!POINTER_TYPE_P (type))\n-    cp_error (\"invalid use of const_cast with type `%T', which is not a pointer, reference, nor a pointer-to-data-member type\", type);\n+    error (\"invalid use of const_cast with type `%T', which is not a pointer, reference, nor a pointer-to-data-member type\", type);\n   else if (TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE)\n     {\n-      cp_error (\"invalid use of const_cast with type `%T', which is a pointer or reference to a function type\", type);\n+      error (\"invalid use of const_cast with type `%T', which is a pointer or reference to a function type\", type);\n       return error_mark_node;\n     }\n \n@@ -5289,7 +5289,7 @@ build_const_cast (type, expr)\n     {\n       if (! real_lvalue_p (expr))\n \t{\n-\t  cp_error (\"invalid const_cast of an rvalue of type `%T' to type `%T'\", intype, type);\n+\t  error (\"invalid const_cast of an rvalue of type `%T' to type `%T'\", intype, type);\n \t  return error_mark_node;\n \t}\n \n@@ -5305,7 +5305,7 @@ build_const_cast (type, expr)\n \t   && comp_ptr_ttypes_const (TREE_TYPE (type), TREE_TYPE (intype)))\n     return cp_convert (type, expr);\n \n-  cp_error (\"invalid const_cast from type `%T' to type `%T'\", intype, type);\n+  error (\"invalid const_cast from type `%T' to type `%T'\", intype, type);\n   return error_mark_node;\n }\n \n@@ -5347,20 +5347,20 @@ build_c_cast (type, expr)\n \t NIHCL uses it. It is not valid ISO C++ however.  */\n       if (TREE_CODE (TREE_TYPE (expr)) == POINTER_TYPE)\n \t{\n-\t  cp_pedwarn (\"ISO C++ forbids casting to an array type `%T'\", type);\n+\t  pedwarn (\"ISO C++ forbids casting to an array type `%T'\", type);\n \t  type = build_pointer_type (TREE_TYPE (type));\n \t}\n       else\n \t{\n-\t  cp_error (\"ISO C++ forbids casting to an array type `%T'\", type);\n+\t  error (\"ISO C++ forbids casting to an array type `%T'\", type);\n \t  return error_mark_node;\n \t}\n     }\n \n   if (TREE_CODE (type) == FUNCTION_TYPE\n       || TREE_CODE (type) == METHOD_TYPE)\n     {\n-      cp_error (\"invalid cast to function type `%T'\", type);\n+      error (\"invalid cast to function type `%T'\", type);\n       return error_mark_node;\n     }\n \n@@ -5412,7 +5412,7 @@ build_c_cast (type, expr)\n       && TREE_CODE (otype) == POINTER_TYPE\n       && !at_least_as_qualified_p (TREE_TYPE (type),\n \t\t\t\t   TREE_TYPE (otype)))\n-    cp_warning (\"cast from `%T' to `%T' discards qualifiers from pointer target type\",\n+    warning (\"cast from `%T' to `%T' discards qualifiers from pointer target type\",\n                 otype, type);\n \n   if (TREE_CODE (type) == INTEGER_TYPE\n@@ -5458,7 +5458,7 @@ build_c_cast (type, expr)\n       && COMPLETE_TYPE_P (TREE_TYPE (otype))\n       && COMPLETE_TYPE_P (TREE_TYPE (type))\n       && TYPE_ALIGN (TREE_TYPE (type)) > TYPE_ALIGN (TREE_TYPE (otype)))\n-    cp_warning (\"cast from `%T' to `%T' increases required alignment of target type\",\n+    warning (\"cast from `%T' to `%T' increases required alignment of target type\",\n                 otype, type);\n \n     /* Always produce some operator for an explicit cast,\n@@ -5646,7 +5646,7 @@ build_modify_expr (lhs, modifycode, rhs)\n       newrhs = cp_build_binary_op (modifycode, lhs, rhs);\n       if (newrhs == error_mark_node)\n \t{\n-\t  cp_error (\"  in evaluation of `%Q(%#T, %#T)'\", modifycode,\n+\t  error (\"  in evaluation of `%Q(%#T, %#T)'\", modifycode,\n \t\t    TREE_TYPE (lhs), TREE_TYPE (rhs));\n \t  return error_mark_node;\n \t}\n@@ -5779,7 +5779,7 @@ build_modify_expr (lhs, modifycode, rhs)\n       \n       if (!same_or_base_type_p (lhstype, TREE_TYPE (rhs)))\n \t{\n-\t  cp_error (\"incompatible types in assignment of `%T' to `%T'\",\n+\t  error (\"incompatible types in assignment of `%T' to `%T'\",\n \t\t    TREE_TYPE (rhs), lhstype);\n \t  return error_mark_node;\n \t}\n@@ -5957,7 +5957,7 @@ get_delta_difference (from, to, force)\n       if (virt_binfo)\n         {\n           /* This is a reinterpret cast, we choose to do nothing. */\n-          cp_warning (\"pointer to member cast via virtual base `%T' of `%T'\",\n+          warning (\"pointer to member cast via virtual base `%T' of `%T'\",\n \t              BINFO_TYPE (virt_binfo),\n \t              BINFO_TYPE (BINFO_INHERITANCE_CHAIN (virt_binfo)));\n           return delta;\n@@ -5976,11 +5976,11 @@ get_delta_difference (from, to, force)\n     {\n       /* This is a reinterpret cast, we choose to do nothing. */\n       if (force)\n-        cp_warning (\"pointer to member cast via virtual base `%T' of `%T'\",\n+        warning (\"pointer to member cast via virtual base `%T' of `%T'\",\n                     BINFO_TYPE (virt_binfo),\n                     BINFO_TYPE (BINFO_INHERITANCE_CHAIN (virt_binfo)));\n       else\n-\tcp_error (\"pointer to member conversion via virtual base `%T' of `%T'\",\n+\terror (\"pointer to member conversion via virtual base `%T' of `%T'\",\n \t\t  BINFO_TYPE (virt_binfo),\n                   BINFO_TYPE (BINFO_INHERITANCE_CHAIN (virt_binfo)));\n       return delta;\n@@ -6050,7 +6050,7 @@ build_ptrmemfunc (type, pfn, force)\n \n       if (!force \n \t  && !can_convert_arg (to_type, TREE_TYPE (pfn), pfn))\n-\tcp_error (\"invalid conversion to type `%T' from type `%T'\", \n+\terror (\"invalid conversion to type `%T' from type `%T'\", \n \t\t  to_type, pfn_type);\n \n       n = get_delta_difference (TYPE_PTRMEMFUNC_OBJECT_TYPE (pfn_type),\n@@ -6215,21 +6215,21 @@ dubious_conversion_warnings (type, expr, errtype, fndecl, parmnum)\n   if (ARITHMETIC_TYPE_P (type) && expr == null_node)\n     {\n       if (fndecl)\n-        cp_warning (\"passing NULL used for non-pointer %s %P of `%D'\",\n+        warning (\"passing NULL used for non-pointer %s %P of `%D'\",\n                     errtype, parmnum, fndecl);\n       else\n-        cp_warning (\"%s to non-pointer type `%T' from NULL\", errtype, type);\n+        warning (\"%s to non-pointer type `%T' from NULL\", errtype, type);\n     }\n   \n   /* Warn about assigning a floating-point type to an integer type.  */\n   if (TREE_CODE (TREE_TYPE (expr)) == REAL_TYPE\n       && TREE_CODE (type) == INTEGER_TYPE)\n     {\n       if (fndecl)\n-\tcp_warning (\"passing `%T' for %s %P of `%D'\",\n+\twarning (\"passing `%T' for %s %P of `%D'\",\n \t\t    TREE_TYPE (expr), errtype, parmnum, fndecl);\n       else\n-\tcp_warning (\"%s to `%T' from `%T'\", errtype, type, TREE_TYPE (expr));\n+\twarning (\"%s to `%T' from `%T'\", errtype, type, TREE_TYPE (expr));\n     }\n   /* And warn about assigning a negative value to an unsigned\n      variable.  */\n@@ -6239,10 +6239,10 @@ dubious_conversion_warnings (type, expr, errtype, fndecl, parmnum)\n \t  && TREE_NEGATED_INT (expr))\n \t{\n \t  if (fndecl)\n-\t    cp_warning (\"passing negative value `%E' for %s %P of `%D'\",\n+\t    warning (\"passing negative value `%E' for %s %P of `%D'\",\n \t\t\texpr, errtype, parmnum, fndecl);\n \t  else\n-\t    cp_warning (\"%s of negative value `%E' to `%T'\",\n+\t    warning (\"%s of negative value `%E' to `%T'\",\n \t\t\terrtype, expr, type);\n \t}\n \n@@ -6329,10 +6329,10 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n \t  if (rhstype == unknown_type_node)\n \t    instantiate_type (type, rhs, itf_complain);\n \t  else if (fndecl)\n-\t    cp_error (\"cannot convert `%T' to `%T' for argument `%P' to `%D'\",\n+\t    error (\"cannot convert `%T' to `%T' for argument `%P' to `%D'\",\n \t\t      rhstype, type, parmnum, fndecl);\n \t  else\n-\t    cp_error (\"cannot convert `%T' to `%T' in %s\", rhstype, type, \n+\t    error (\"cannot convert `%T' to `%T' in %s\", rhstype, type, \n \t\t      errtype);\n \t  return error_mark_node;\n \t}\n@@ -6653,13 +6653,13 @@ check_return_expr (retval)\n       && !TYPE_NOTHROW_P (TREE_TYPE (current_function_decl))\n       && ! flag_check_new\n       && null_ptr_cst_p (retval))\n-    cp_warning (\"`operator new' must not return NULL unless it is declared `throw()' (or -fcheck-new is in effect)\");\n+    warning (\"`operator new' must not return NULL unless it is declared `throw()' (or -fcheck-new is in effect)\");\n \n   /* Effective C++ rule 15.  See also start_function.  */\n   if (warn_ecpp\n       && DECL_NAME (current_function_decl) == ansi_assopname(NOP_EXPR)\n       && retval != current_class_ref)\n-    cp_warning (\"`operator=' should return a reference to `*this'\");\n+    warning (\"`operator=' should return a reference to `*this'\");\n \n   /* The fabled Named Return Value optimization, as per [class.copy]/15:\n "}, {"sha": "2706c13a85c34feeeb684e2875d5455fd6c5f54d", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33bd39a26a88cbaabb2f85735c1ff1e51f2a7111/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33bd39a26a88cbaabb2f85735c1ff1e51f2a7111/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=33bd39a26a88cbaabb2f85735c1ff1e51f2a7111", "patch": "@@ -51,7 +51,7 @@ error_not_base_type (basetype, type)\n {\n   if (TREE_CODE (basetype) == FUNCTION_DECL)\n     basetype = DECL_CONTEXT (basetype);\n-  cp_error (\"type `%T' is not a base type for type `%T'\", basetype, type);\n+  error (\"type `%T' is not a base type for type `%T'\", basetype, type);\n   return error_mark_node;\n }\n \n@@ -83,9 +83,9 @@ readonly_error (arg, string, soft)\n   void (*fn) PARAMS ((const char *, ...));\n \n   if (soft)\n-    fn = cp_pedwarn;\n+    fn = pedwarn;\n   else\n-    fn = cp_error;\n+    fn = error;\n \n   if (TREE_CODE (arg) == COMPONENT_REF)\n     {\n@@ -148,22 +148,22 @@ abstract_virtuals_error (decl, type)\n \treturn 0;\n \n       if (TREE_CODE (decl) == VAR_DECL)\n-\tcp_error (\"cannot declare variable `%D' to be of type `%T'\",\n+\terror (\"cannot declare variable `%D' to be of type `%T'\",\n \t\t    decl, type);\n       else if (TREE_CODE (decl) == PARM_DECL)\n-\tcp_error (\"cannot declare parameter `%D' to be of type `%T'\",\n+\terror (\"cannot declare parameter `%D' to be of type `%T'\",\n \t\t    decl, type);\n       else if (TREE_CODE (decl) == FIELD_DECL)\n-\tcp_error (\"cannot declare field `%D' to be of type `%T'\",\n+\terror (\"cannot declare field `%D' to be of type `%T'\",\n \t\t    decl, type);\n       else if (TREE_CODE (decl) == FUNCTION_DECL\n \t       && TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE)\n-\tcp_error (\"invalid return type for member function `%#D'\", decl);\n+\terror (\"invalid return type for member function `%#D'\", decl);\n       else if (TREE_CODE (decl) == FUNCTION_DECL)\n-\tcp_error (\"invalid return type for function `%#D'\", decl);\n+\terror (\"invalid return type for function `%#D'\", decl);\n     }\n   else\n-    cp_error (\"cannot allocate an object of type `%T'\", type);\n+    error (\"cannot allocate an object of type `%T'\", type);\n \n   /* Only go through this once.  */\n   if (TREE_PURPOSE (u) == NULL_TREE)\n@@ -175,7 +175,7 @@ abstract_virtuals_error (decl, type)\n \tcp_error_at (\"\\t%#D\", TREE_VALUE (tu));\n     }\n   else\n-    cp_error (\"  since type `%T' has abstract virtual functions\", type);\n+    error (\"  since type `%T' has abstract virtual functions\", type);\n \n   return 1;\n }\n@@ -210,12 +210,12 @@ incomplete_type_error (value, type)\n     case UNION_TYPE:\n     case ENUMERAL_TYPE:\n       if (!decl)\n-        cp_error (\"invalid use of undefined type `%#T'\", type);\n+        error (\"invalid use of undefined type `%#T'\", type);\n       cp_error_at (\"forward declaration of `%#T'\", type);\n       break;\n \n     case VOID_TYPE:\n-      cp_error (\"invalid use of `%T'\", type);\n+      error (\"invalid use of `%T'\", type);\n       break;\n \n     case ARRAY_TYPE:\n@@ -224,27 +224,27 @@ incomplete_type_error (value, type)\n           type = TREE_TYPE (type);\n           goto retry;\n         }\n-      cp_error (\"invalid use of array with unspecified bounds\");\n+      error (\"invalid use of array with unspecified bounds\");\n       break;\n \n     case OFFSET_TYPE:\n     bad_member:\n-      cp_error (\"invalid use of member (did you forget the `&' ?)\");\n+      error (\"invalid use of member (did you forget the `&' ?)\");\n       break;\n \n     case TEMPLATE_TYPE_PARM:\n-      cp_error (\"invalid use of template type parameter\");\n+      error (\"invalid use of template type parameter\");\n       break;\n \n     case UNKNOWN_TYPE:\n       if (value && TREE_CODE (value) == COMPONENT_REF)\n         goto bad_member;\n       else if (value && TREE_CODE (value) == ADDR_EXPR)\n-        cp_error (\"address of overloaded function with no contextual type information\");\n+        error (\"address of overloaded function with no contextual type information\");\n       else if (value && TREE_CODE (value) == OVERLOAD)\n-        cp_error (\"overloaded function with no contextual type information\");\n+        error (\"overloaded function with no contextual type information\");\n       else\n-        cp_error (\"insufficient contextual information to determine type\");\n+        error (\"insufficient contextual information to determine type\");\n       break;\n     \n     default:\n@@ -322,7 +322,7 @@ store_init_value (decl, init)\n \n       if (TREE_CODE (init) == TREE_LIST)\n \t{\n-\t  cp_error (\"constructor syntax used, but no constructor declared for type `%T'\", type);\n+\t  error (\"constructor syntax used, but no constructor declared for type `%T'\", type);\n \t  init = build_nt (CONSTRUCTOR, NULL_TREE, nreverse (init));\n \t}\n #if 0\n@@ -576,10 +576,10 @@ digest_init (type, init, tail)\n \t}\n       while (TREE_CODE (init) == CONSTRUCTOR && TREE_HAS_CONSTRUCTOR (init))\n \t{\n-\t  cp_pedwarn (\"braces around scalar initializer for `%T'\", type);\n+\t  pedwarn (\"braces around scalar initializer for `%T'\", type);\n \t  init = CONSTRUCTOR_ELTS (init);\n \t  if (TREE_CHAIN (init))\n-\t    cp_pedwarn (\"ignoring extra initializers for `%T'\", type);\n+\t    pedwarn (\"ignoring extra initializers for `%T'\", type);\n \t  init = TREE_VALUE (init);\n \t}\n \n@@ -591,7 +591,7 @@ digest_init (type, init, tail)\n \n   if (COMPLETE_TYPE_P (type) && ! TREE_CONSTANT (TYPE_SIZE (type)))\n     {\n-      cp_error (\"variable-sized object of type `%T' may not be initialized\",\n+      error (\"variable-sized object of type `%T' may not be initialized\",\n \t\ttype);\n       return error_mark_node;\n     }\n@@ -601,7 +601,7 @@ digest_init (type, init, tail)\n       if (raw_constructor && TYPE_NON_AGGREGATE_CLASS (type)\n \t  && TREE_HAS_CONSTRUCTOR (init))\n \t{\n-\t  cp_error (\"subobject of type `%T' must be initialized by constructor, not by `%E'\",\n+\t  error (\"subobject of type `%T' must be initialized by constructor, not by `%E'\",\n \t\t    type, init);\n \t  return error_mark_node;\n \t}\n@@ -839,24 +839,24 @@ process_init_constructor (type, init, elts)\n \t      /* Warn when some struct elements are implicitly initialized.  */\n \t      if (extra_warnings\n \t          && (!init || TREE_HAS_CONSTRUCTOR (init)))\n-\t\tcp_warning (\"missing initializer for member `%D'\", field);\n+\t\twarning (\"missing initializer for member `%D'\", field);\n \t    }\n \t  else\n \t    {\n \t      if (TREE_READONLY (field))\n-\t\tcp_error (\"uninitialized const member `%D'\", field);\n+\t\terror (\"uninitialized const member `%D'\", field);\n \t      else if (TYPE_LANG_SPECIFIC (TREE_TYPE (field))\n \t\t       && CLASSTYPE_READONLY_FIELDS_NEED_INIT (TREE_TYPE (field)))\n-\t\tcp_error (\"member `%D' with uninitialized const fields\",\n+\t\terror (\"member `%D' with uninitialized const fields\",\n \t\t\t  field);\n \t      else if (TREE_CODE (TREE_TYPE (field)) == REFERENCE_TYPE)\n-\t\tcp_error (\"member `%D' is uninitialized reference\", field);\n+\t\terror (\"member `%D' is uninitialized reference\", field);\n \n \t      /* Warn when some struct elements are implicitly initialized\n \t\t to zero.  */\n \t      if (extra_warnings\n \t          && (!init || TREE_HAS_CONSTRUCTOR (init)))\n-\t\tcp_warning (\"missing initializer for member `%D'\", field);\n+\t\twarning (\"missing initializer for member `%D'\", field);\n \n \t      /* The default zero-initialization is fine for us; don't\n \t\t add anything to the CONSTRUCTOR.  */\n@@ -905,15 +905,15 @@ process_init_constructor (type, init, elts)\n \t      if (temp)\n \t\tfield = temp, win = 1;\n \t      else\n-\t\tcp_error (\"no field `%D' in union being initialized\",\n+\t\terror (\"no field `%D' in union being initialized\",\n \t\t\t  TREE_PURPOSE (tail));\n \t    }\n \t  if (!win)\n \t    TREE_VALUE (tail) = error_mark_node;\n \t}\n       else if (field == 0)\n \t{\n-\t  cp_error (\"union `%T' with no named members cannot be initialized\",\n+\t  error (\"union `%T' with no named members cannot be initialized\",\n \t\t    type);\n \t  TREE_VALUE (tail) = error_mark_node;\n \t}\n@@ -1067,7 +1067,7 @@ build_x_arrow (datum)\n \n       if (last_rval == NULL_TREE)\n \t{\n-\t  cp_error (\"base operand of `->' has non-pointer type `%T'\", type);\n+\t  error (\"base operand of `->' has non-pointer type `%T'\", type);\n \t  return error_mark_node;\n \t}\n \n@@ -1131,23 +1131,23 @@ build_m_component_ref (datum, component)\n     }\n   else\n     {\n-      cp_error (\"`%E' cannot be used as a member pointer, since it is of type `%T'\", \n+      error (\"`%E' cannot be used as a member pointer, since it is of type `%T'\", \n \t\tcomponent, TREE_TYPE (component));\n       return error_mark_node;\n     }\n \n   if (! IS_AGGR_TYPE (objtype))\n     {\n-      cp_error (\"cannot apply member pointer `%E' to `%E'\", component, datum);\n-      cp_error (\"which is of non-aggregate type `%T'\", objtype);\n+      error (\"cannot apply member pointer `%E' to `%E'\", component, datum);\n+      error (\"which is of non-aggregate type `%T'\", objtype);\n       return error_mark_node;\n     }\n \n   binfo = lookup_base (objtype, TYPE_METHOD_BASETYPE (type),\n \t\t       ba_check, NULL);\n   if (!binfo)\n     {\n-      cp_error (\"member type `%T::' incompatible with object type `%T'\",\n+      error (\"member type `%T::' incompatible with object type `%T'\",\n \t\tTYPE_METHOD_BASETYPE (type), objtype);\n       return error_mark_node;\n     }\n@@ -1201,7 +1201,7 @@ build_functional_cast (exp, parms)\n \t  type = lookup_name (exp, 1);\n \t  if (!type || TREE_CODE (type) != TYPE_DECL)\n \t    {\n-\t      cp_error (\"`%T' fails to be a typedef or built-in type\", exp);\n+\t      error (\"`%T' fails to be a typedef or built-in type\", exp);\n \t      return error_mark_node;\n \t    }\n \t  type = TREE_TYPE (type);"}]}