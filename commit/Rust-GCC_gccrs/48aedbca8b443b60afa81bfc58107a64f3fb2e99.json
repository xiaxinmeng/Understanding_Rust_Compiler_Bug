{"sha": "48aedbca8b443b60afa81bfc58107a64f3fb2e99", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDhhZWRiY2E4YjQ0M2I2MGFmYTgxYmZjNTgxMDdhNjRmM2ZiMmU5OQ==", "commit": {"author": {"name": "Anthony Green", "email": "green@cygnus.com", "date": "1999-11-21T23:37:58Z"}, "committer": {"name": "Anthony Green", "email": "green@gcc.gnu.org", "date": "1999-11-21T23:37:58Z"}, "message": "constants.c (find_methodref_index): Unwrap method names before inserting them in the constant pool.\n\n        * constants.c (find_methodref_index): Unwrap method names before\n        inserting them in the constant pool.\n\n        * jcf-parse.c (jcf_parse): Display `interface' when appropriate.\n\n        * class.c (assume_compiled_node): New typedef.\n        (assume_compiled_tree): New static data.\n        (find_assume_compiled_node): New function.\n        (add_assume_compiled): New function.\n        (assume_compiled): New function.\n        * class.c (make_class_data): Use assume_compiled.\n        (is_compiled_class): Use assume_compiled.\n\n        * java-tree.h (add_assume_compiled): Declare.\n\n        * lang.c (lang_decode_option): Parse new options.\n\nFrom-SVN: r30608", "tree": {"sha": "6339330b1e1b16ec9eff2000914b559bac7134bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6339330b1e1b16ec9eff2000914b559bac7134bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/48aedbca8b443b60afa81bfc58107a64f3fb2e99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48aedbca8b443b60afa81bfc58107a64f3fb2e99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48aedbca8b443b60afa81bfc58107a64f3fb2e99", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48aedbca8b443b60afa81bfc58107a64f3fb2e99/comments", "author": null, "committer": null, "parents": [{"sha": "250ba2372cdb135d47cb4a47227d0457fb73ce9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/250ba2372cdb135d47cb4a47227d0457fb73ce9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/250ba2372cdb135d47cb4a47227d0457fb73ce9a"}], "stats": {"total": 210, "additions": 201, "deletions": 9}, "files": [{"sha": "38a7d7d6396ccb69fd066c4dccf462819336b3f6", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48aedbca8b443b60afa81bfc58107a64f3fb2e99/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48aedbca8b443b60afa81bfc58107a64f3fb2e99/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=48aedbca8b443b60afa81bfc58107a64f3fb2e99", "patch": "@@ -1,3 +1,22 @@\n+1999-11-21  Anthony Green  <green@cygnus.com>\n+\n+\t* constants.c (find_methodref_index): Unwrap method names before\n+\tinserting them in the constant pool.\n+\n+\t* jcf-parse.c (jcf_parse): Display `interface' when appropriate.\n+\n+\t* class.c (assume_compiled_node): New typedef.\n+\t(assume_compiled_tree): New static data.\n+\t(find_assume_compiled_node): New function.\n+\t(add_assume_compiled): New function.\n+\t(assume_compiled): New function.\n+\t* class.c (make_class_data): Use assume_compiled.\n+\t(is_compiled_class): Use assume_compiled.\n+\n+\t* java-tree.h (add_assume_compiled): Declare.\n+\n+\t* lang.c (lang_decode_option): Parse new options.\n+\n Wed Nov 17 21:09:28 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n \t* class.c (layout_class): Always convert TYPE_SIZE_UNIT to"}, {"sha": "77e7fce08333a1a4c7920c1f38b12f31b8ca0640", "filename": "gcc/java/class.c", "status": "modified", "additions": 145, "deletions": 4, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48aedbca8b443b60afa81bfc58107a64f3fb2e99/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48aedbca8b443b60afa81bfc58107a64f3fb2e99/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=48aedbca8b443b60afa81bfc58107a64f3fb2e99", "patch": "@@ -53,6 +53,147 @@ static rtx registerClass_libfunc;\n extern struct obstack permanent_obstack;\n extern struct obstack temporary_obstack;\n \n+/* The compiler generates different code depending on whether or not\n+   it can assume certain classes have been compiled down to native\n+   code or not.  The compiler options -fassume-compiled= and\n+   -fno-assume-compiled= are used to create a tree of\n+   assume_compiled_node objects.  This tree is queried to determine if\n+   a class is assume to be compiled or not.  Each node in the tree\n+   represents either a package or a specific class.  */\n+\n+typedef struct assume_compiled_node_struct\n+{\n+  /* The class or package name.  */\n+  const char *ident;\n+\n+  /* Non-zero if this represents an exclusion.  */\n+  int excludep;\n+\n+  /* Pointers to other nodes in the tree.  */\n+  struct assume_compiled_node_struct *parent;\n+  struct assume_compiled_node_struct *sibling;\n+  struct assume_compiled_node_struct *child;\n+} assume_compiled_node;\n+\n+/* This is the root of the include/exclude tree.  */\n+\n+static assume_compiled_node *assume_compiled_tree;\n+\n+/* Return the node that most closely represents the class whose name\n+   is IDENT.  Start the search from NODE.  Return NULL if an\n+   appropriate node does not exist.  */\n+\n+assume_compiled_node *\n+find_assume_compiled_node (node, ident)\n+     assume_compiled_node *node;\n+     const char *ident;\n+{\n+  while (node)\n+    {\n+      size_t node_ident_length = strlen (node->ident);\n+\n+      /* node_ident_length is zero at the root of the tree.  If the\n+\t identifiers are the same length, then we have matching\n+\t classes.  Otherwise check if we've matched an enclosing\n+\t package name.  */\n+\n+      if (node_ident_length == 0\n+\t  || (strncmp (ident, node->ident, node_ident_length) == 0\n+\t      && (strlen (ident) == node_ident_length\n+\t\t  || ident[node_ident_length] == '.')))\n+\t{\n+\t  /* We've found a match, however, there might be a more\n+             specific match.  */\n+\n+\t  assume_compiled_node *found = find_assume_compiled_node (node->child,\n+\t\t\t\t\t\t\t\t   ident);\n+\t  if (found)\n+\t    return found;\n+\t  else\n+\t    return node;\n+\t}\n+\n+      /* No match yet.  Continue through the sibling list.  */\n+      node = node->sibling;\n+    }\n+\n+  /* No match at all in this tree.  */\n+  return NULL;\n+}\n+\n+/* Add a new IDENT to the include/exclude tree.  It's an exclusion\n+   if EXCLUDEP is non-zero.  */\n+\n+void\n+add_assume_compiled (ident, excludep)\n+     const char *ident;\n+     int excludep;\n+{\n+  assume_compiled_node *parent;\n+  assume_compiled_node *node = \n+    (assume_compiled_node *) malloc (sizeof (assume_compiled_node));\n+\n+  node->ident = strdup (ident);\n+  node->excludep = excludep;\n+  node->child = NULL;\n+\n+  /* Create the root of the tree if it doesn't exist yet.  */\n+\n+  if (NULL == assume_compiled_tree)\n+    {\n+      assume_compiled_tree = \n+\t(assume_compiled_node *) malloc (sizeof (assume_compiled_node));\n+      assume_compiled_tree->ident = \"\";\n+      assume_compiled_tree->excludep = 0;\n+      assume_compiled_tree->sibling = NULL;\n+      assume_compiled_tree->child = NULL;\n+      assume_compiled_tree->parent = NULL;\n+    }\n+\n+  /* Calling the function with the empty string means we're setting\n+     excludep for the root of the hierarchy.  */\n+\n+  if (0 == ident[0])\n+    {\n+      assume_compiled_tree->excludep = excludep;\n+      return;\n+    }\n+\n+  /* Find the parent node for this new node.  PARENT will either be a\n+     class or a package name.  Adjust PARENT accordingly.  */\n+\n+  parent = find_assume_compiled_node (assume_compiled_tree, ident);\n+  if (ident[strlen (parent->ident)] != '.')\n+    parent = parent->parent;\n+\n+  /* Insert NODE into the tree.  */\n+\n+  node->parent = parent;\n+  node->sibling = parent->child;\n+  parent->child = node;\n+}\n+\n+/* Returns non-zero if IDENT is the name of a class that the compiler\n+   should assume has been compiled to FIXME  */\n+\n+int\n+assume_compiled (ident)\n+     const char *ident;\n+{\n+  assume_compiled_node *i;\n+  int result;\n+  \n+  if (NULL == assume_compiled_tree)\n+    return 1;\n+\n+  i = find_assume_compiled_node (assume_compiled_tree,\n+\t\t\t\t ident);\n+\n+  result = ! i->excludep;\n+  \n+  return (result);\n+}\n+\n /* Return an IDENTIFIER_NODE the same as (OLD_NAME, OLD_LENGTH).\n    except that characters matching OLD_CHAR are substituted by NEW_CHAR.\n    Also, PREFIX is prepended, and SUFFIX is appended. */\n@@ -1091,7 +1232,7 @@ make_class_data (type)\n   DECL_IGNORED_P (methods_decl) = 1;\n   rest_of_decl_compilation (methods_decl, (char*) 0, 1, 0);\n \n-  if (flag_assume_compiled\n+  if (assume_compiled (IDENTIFIER_POINTER (DECL_NAME (type_decl)))\n       && ! CLASS_ABSTRACT (type_decl) && ! CLASS_INTERFACE (type_decl))\n     {\n       tree dtable = get_dispatch_table (type, this_class_addr);\n@@ -1107,7 +1248,7 @@ make_class_data (type)\n   super = CLASSTYPE_SUPER (type);\n   if (super == NULL_TREE)\n     super = null_pointer_node;\n-  else if (flag_assume_compiled)\n+  else if (assume_compiled (IDENTIFIER_POINTER (DECL_NAME (type_decl))))\n     super = build_class_ref (super);\n   else\n     {\n@@ -1133,7 +1274,7 @@ make_class_data (type)\n \t  tree child = TREE_VEC_ELT (TYPE_BINFO_BASETYPES (type), i);\n \t  tree iclass = BINFO_TYPE (child);\n \t  tree index;\n-\t  if (flag_assume_compiled)\n+\t  if (assume_compiled (IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (iclass)))))\n \t    index = build_class_ref (iclass);\n \t  else\n \t    {\n@@ -1284,7 +1425,7 @@ is_compiled_class (class)\n       return 2;\n     }\n \n-  if (flag_assume_compiled)\n+  if (assume_compiled (IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (class)))))\n     {\n       if (!CLASS_LOADED_P (class))\n \t{"}, {"sha": "462038369433b32950557d05f578f52d36f622dc", "filename": "gcc/java/constants.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48aedbca8b443b60afa81bfc58107a64f3fb2e99/gcc%2Fjava%2Fconstants.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48aedbca8b443b60afa81bfc58107a64f3fb2e99/gcc%2Fjava%2Fconstants.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fconstants.c?ref=48aedbca8b443b60afa81bfc58107a64f3fb2e99", "patch": "@@ -200,8 +200,11 @@ find_methodref_index (cpool, decl)\n   int class_index = find_class_constant (cpool, mclass);\n   tree name = DECL_CONSTRUCTOR_P (decl) ? init_identifier_node\n     : DECL_NAME (decl);\n-  int name_type_index\n-    = find_name_and_type_constant (cpool, name, TREE_TYPE (decl));\n+  int name_type_index;\n+  if (TREE_CODE (name) == EXPR_WITH_FILE_LOCATION)\n+    name = EXPR_WFL_NODE (name);    \n+  name_type_index = \n+      find_name_and_type_constant (cpool, name, TREE_TYPE (decl));\n   return find_constant1 (cpool,\n \t\t\t CLASS_INTERFACE (TYPE_NAME (mclass))\n \t\t\t ? CONSTANT_InterfaceMethodref"}, {"sha": "7c646e6ff88aa6d9791827bda32d92bd2a318637", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48aedbca8b443b60afa81bfc58107a64f3fb2e99/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48aedbca8b443b60afa81bfc58107a64f3fb2e99/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=48aedbca8b443b60afa81bfc58107a64f3fb2e99", "patch": "@@ -479,6 +479,7 @@ struct lang_type\n #define JCF_u4 unsigned long\n #define JCF_u2 unsigned short\n \n+extern void add_assume_compiled PROTO ((const char *, int));\n extern tree lookup_class PROTO ((tree));\n extern tree lookup_java_constructor PROTO ((tree, tree));\n extern tree lookup_java_method PROTO ((tree, tree, tree));"}, {"sha": "ff4ec818bf144f4f467aa3a9ab07acae5d54738d", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48aedbca8b443b60afa81bfc58107a64f3fb2e99/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48aedbca8b443b60afa81bfc58107a64f3fb2e99/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=48aedbca8b443b60afa81bfc58107a64f3fb2e99", "patch": "@@ -612,7 +612,8 @@ jcf_parse (jcf)\n   if (main_class == NULL_TREE)\n     main_class = current_class;\n   if (! quiet_flag && TYPE_NAME (current_class))\n-    fprintf (stderr, \" class %s\",\n+    fprintf (stderr, \" %s %s\",\n+\t     (jcf->access_flags & ACC_INTERFACE) ? \"interface\" : \"class\", \n \t     IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (current_class))));\n   if (CLASS_LOADED_P (current_class))\n     return;"}, {"sha": "11be76d6495d89226b3bc9f6502519f06b01d07b", "filename": "gcc/java/lang.c", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48aedbca8b443b60afa81bfc58107a64f3fb2e99/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48aedbca8b443b60afa81bfc58107a64f3fb2e99/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=48aedbca8b443b60afa81bfc58107a64f3fb2e99", "patch": "@@ -124,7 +124,6 @@ extern int flag_exceptions;\n static struct { const char *string; int *variable; int on_value;}\n lang_f_options[] =\n {\n-  {\"assume-compiled\", &flag_assume_compiled, 1},\n   {\"emit-class-file\", &flag_emit_class_files, 1},\n   {\"emit-class-files\", &flag_emit_class_files, 1},\n   {\"use-divide-subroutine\", &flag_use_divide_subroutine, 1},\n@@ -151,6 +150,34 @@ lang_decode_option (argc, argv)\n {\n   char *p = argv[0];\n \n+#define CLARG \"-fassume-compiled=\"\n+  if (strncmp (p, CLARG, sizeof (CLARG) - 1) == 0)\n+    {\n+      add_assume_compiled (p + sizeof (CLARG) - 1, 0);\n+      return 1;\n+    }\n+#undef CLARG\n+#define CLARG \"-fno-assume-compiled=\"\n+  if (strncmp (p, CLARG, sizeof (CLARG) - 1) == 0)\n+    {\n+      add_assume_compiled (p + sizeof (CLARG) - 1, 1);\n+      return 1;\n+    }\n+#undef CLARG\n+#define CLARG \"-fassume-compiled\"\n+  if (strncmp (p, CLARG, sizeof (CLARG) - 1) == 0)\n+    {\n+      add_assume_compiled (\"\", 0);\n+      return 1;\n+    }\n+#undef CLARG\n+#define CLARG \"-fno-assume-compiled\"\n+  if (strncmp (p, CLARG, sizeof (CLARG) - 1) == 0)\n+    {\n+      add_assume_compiled (\"\", 1);\n+      return 1;\n+    }\n+#undef CLARG\n #define CLARG \"-fclasspath=\"\n   if (strncmp (p, CLARG, sizeof (CLARG) - 1) == 0)\n     {\n@@ -159,7 +186,7 @@ lang_decode_option (argc, argv)\n     }\n #undef CLARG\n #define CLARG \"-fCLASSPATH=\"\n-  else if (strncmp (p, CLARG, sizeof (CLARG) - 1) == 0)\n+  if (strncmp (p, CLARG, sizeof (CLARG) - 1) == 0)\n     {\n       jcf_path_CLASSPATH_arg (p + sizeof (CLARG) - 1);\n       return 1;"}]}