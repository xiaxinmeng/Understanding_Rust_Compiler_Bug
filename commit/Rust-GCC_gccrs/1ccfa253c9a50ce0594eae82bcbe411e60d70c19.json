{"sha": "1ccfa253c9a50ce0594eae82bcbe411e60d70c19", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWNjZmEyNTNjOWE1MGNlMDU5NGVhZTgyYmNiZTQxMWU2MGQ3MGMxOQ==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1997-09-25T01:14:03Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1997-09-25T01:14:03Z"}, "message": "sparc.h (ASM_CPU_SPEC): Pass -Av9a for v8plus, ultrasparc.\n\n\t* sparc/sparc.h (ASM_CPU_SPEC): Pass -Av9a for v8plus, ultrasparc.\n\t(TARGET_OPTIONS): Add -malign-loops=, -malign-jumps=,\n\t-malign-functions=.\n\t(sparc_align_{loops,jumps,funcs}_string): Declare.\n\t(sparc_align_{loops,jumps,funcs}): Declare.\n\t(DEFAULT_SPARC_ALIGN_FUNCS): New macro.\n\t(FUNCTION_BOUNDARY): Use sparc_align_funcs.\n\t(STACK_BIAS): Define.\n\t(SPARC_SIMM*_P): Cast to unsigned HOST_WIDE_INT first, then perform\n\ttest.\n\t(SPARC_SETHI_P): New macro.\n\t(CONST_OK_FOR_LETTER_P): Use it.\n\t(ASM_OUTPUT_ALIGN_CODE): Define.\n\t(ASM_OUTPUT_LOOP_ALIGN): Define.\n\n\t* sparc.h (ASM_COMMENT_START): Define.\n\n\t* sparc/sparc.h (ASM_OUTPUT_{FLOAT,DOUBLE,LONG_DOUBLE}): Print\n\tascii form as well.\n\nFrom-SVN: r15708", "tree": {"sha": "c9bb06b726c135a5a6dd045c743bb37115278584", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c9bb06b726c135a5a6dd045c743bb37115278584"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ccfa253c9a50ce0594eae82bcbe411e60d70c19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ccfa253c9a50ce0594eae82bcbe411e60d70c19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ccfa253c9a50ce0594eae82bcbe411e60d70c19", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ccfa253c9a50ce0594eae82bcbe411e60d70c19/comments", "author": null, "committer": null, "parents": [{"sha": "96987e9648f9ba309a82c8a8daf262645ac8a1f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96987e9648f9ba309a82c8a8daf262645ac8a1f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96987e9648f9ba309a82c8a8daf262645ac8a1f1"}], "stats": {"total": 116, "additions": 82, "deletions": 34}, "files": [{"sha": "b4b12b1dc1679285f837484cc7b1979eb3235877", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 82, "deletions": 34, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ccfa253c9a50ce0594eae82bcbe411e60d70c19/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ccfa253c9a50ce0594eae82bcbe411e60d70c19/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=1ccfa253c9a50ce0594eae82bcbe411e60d70c19", "patch": "@@ -1,6 +1,5 @@\n /* Definitions of target machine for GNU compiler, for Sun SPARC.\n-   Copyright (C) 1987, 88, 89, 92, 94, 95, 96, 1997 Free Software Foundation,\n-   Inc.\n+   Copyright (C) 1987, 88, 89, 92, 94-6, 1997 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com).\n    64 bit SPARC V9 support by Michael Tiemann, Jim Wilson, and Doug Evans,\n    at Cygnus Support.\n@@ -174,9 +173,9 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n %{mf930:-Asparclite} %{mf934:-Asparclite} \\\n %{mcpu=sparclite:-Asparclite} \\\n %{mcpu=f930:-Asparclite} %{mcpu=f934:-Asparclite} \\\n-%{mcpu=v8plus:-Av9} \\\n+%{mcpu=v8plus:-Av9a} \\\n %{mcpu=v9:-Av9} \\\n-%{mcpu=ultrasparc:-Av9} \\\n+%{mcpu=ultrasparc:-Av9a} \\\n %{!mcpu*:%{!mcypress:%{!msparclite:%{!mf930:%{!mf934:%{!mv8:%{!msupersparc:%(asm_default)}}}}}}} \\\n \"\n \n@@ -515,10 +514,13 @@ extern enum processor_type sparc_cpu;\n \t#define TARGET_OPTIONS { { \"short-data-\", &m88k_short_data } }  */\n \n #define TARGET_OPTIONS \\\n-{\t\t\t\t\t\\\n-  {\"cpu=\",  &sparc_select[1].string},\t\\\n-  {\"tune=\", &sparc_select[2].string},\t\\\n-  SUBTARGET_OPTIONS \\\n+{\t\t\t\t\t\t\t\\\n+  {\"cpu=\",  &sparc_select[1].string},\t\t\t\\\n+  {\"tune=\", &sparc_select[2].string},\t\t\t\\\n+  {\"align-loops=\",\t&sparc_align_loops_string },\t\\\n+  {\"align-jumps=\",\t&sparc_align_jumps_string },\t\\\n+  {\"align-functions=\",\t&sparc_align_funcs_string },\t\\\n+  SUBTARGET_OPTIONS \t\t\t\t\t\\\n }\n \n /* This is meant to be redefined in target specific files.  */\n@@ -534,6 +536,18 @@ struct sparc_cpu_select\n };\n \n extern struct sparc_cpu_select sparc_select[];\n+\n+/* Variables to record values the user passes.  */\n+extern char *sparc_align_loops_string;\n+extern char *sparc_align_jumps_string;\n+extern char *sparc_align_funcs_string;\n+/* Parsed values as a power of two.  */\n+extern int sparc_align_loops;\n+extern int sparc_align_jumps;\n+extern int sparc_align_funcs;\n+\n+#define DEFAULT_SPARC_ALIGN_FUNCS \\\n+(sparc_cpu == PROCESSOR_ULTRASPARC ? 5 : 2)\n \f\n /* target machine storage layout */\n \n@@ -610,7 +624,7 @@ extern struct sparc_cpu_select sparc_select[];\n   (TARGET_ARCH64 ? (((LOC)+15) & ~15) : (((LOC)+7) & ~7))\n \n /* Allocation boundary (in *bits*) for the code of a function.  */\n-#define FUNCTION_BOUNDARY 32\n+#define FUNCTION_BOUNDARY (1 << (sparc_align_funcs + 3))\n \n /* Alignment of field after `int : 0' in a structure.  */\n /* ??? Should this be based on TARGET_INT64?  */\n@@ -912,6 +926,9 @@ extern int sparc_mode_class[];\n /* The stack bias (amount by which the hardware register is offset by).  */\n #define SPARC_STACK_BIAS (TARGET_STACK_BIAS ? 2047 : 0)\n \n+/* Is stack biased? */\n+#define STACK_BIAS SPARC_STACK_BIAS\n+\n /* Base register for access to local variables of the function.  */\n #define FRAME_POINTER_REGNUM 30\n \n@@ -1178,17 +1195,19 @@ extern char leaf_reg_remap[];\n    `L' is used for the range of constants supported by the movcc insns.\n    `M' is used for the range of constants supported by the movrcc insns.  */\n \n-#define SPARC_SIMM10_P(X) ((unsigned HOST_WIDE_INT) ((X) + 0x200) < 0x400)\n-#define SPARC_SIMM11_P(X) ((unsigned HOST_WIDE_INT) ((X) + 0x400) < 0x800)\n-#define SPARC_SIMM13_P(X) ((unsigned HOST_WIDE_INT) ((X) + 0x1000) < 0x2000)\n+#define SPARC_SIMM10_P(X) ((unsigned HOST_WIDE_INT) (X) + 0x200 < 0x400)\n+#define SPARC_SIMM11_P(X) ((unsigned HOST_WIDE_INT) (X) + 0x400 < 0x800)\n+#define SPARC_SIMM13_P(X) ((unsigned HOST_WIDE_INT) (X) + 0x1000 < 0x2000)\n /* 10 and 11 bit immediates are only used for a few specific insns.\n    SMALL_INT is used throughout the port so we continue to use it.  */\n #define SMALL_INT(X) (SPARC_SIMM13_P (INTVAL (X)))\n+#define SPARC_SETHI_P(X) \\\n+(((unsigned HOST_WIDE_INT) (X) & ~(unsigned HOST_WIDE_INT) 0xfffffc00) == 0)\n \n #define CONST_OK_FOR_LETTER_P(VALUE, C)  \\\n   ((C) == 'I' ? SPARC_SIMM13_P (VALUE)\t\t\t\\\n    : (C) == 'J' ? (VALUE) == 0\t\t\t\t\\\n-   : (C) == 'K' ? ((VALUE) & 0x3ff) == 0\t\t\\\n+   : (C) == 'K' ? SPARC_SETHI_P (VALUE)\t\t\t\\\n    : (C) == 'L' ? SPARC_SIMM11_P (VALUE)\t\t\\\n    : (C) == 'M' ? SPARC_SIMM10_P (VALUE)\t\t\\\n    : 0)\n@@ -2737,6 +2756,12 @@ extern struct rtx_def *legitimize_pic_address ();\n \n #define ASM_FILE_START(file)\n \n+/* A C string constant describing how to begin a comment in the target\n+   assembler language.  The compiler assumes that the comment will end at\n+   the end of the line.  */\n+\n+#define ASM_COMMENT_START \"!\"\n+\n /* Output to assembler file text saying following lines\n    may contain character constants, extra white space, comments, etc.  */\n \n@@ -2843,34 +2868,51 @@ extern struct rtx_def *legitimize_pic_address ();\n #define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n   sprintf (LABEL, \"*%s%d\", PREFIX, NUM)\n \n-/* This is how to output an assembler line defining a `double' constant.  */\n+/* This is how to output an assembler line defining a `float' constant.\n+   We always have to use a .long pseudo-op to do this because the native\n+   SVR4 ELF assembler is buggy and it generates incorrect values when we\n+   try to use the .float pseudo-op instead.  */\n \n-#define ASM_OUTPUT_DOUBLE(FILE,VALUE)\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    long t[2];\t\t\t\t\t\t\t\t\\\n-    REAL_VALUE_TO_TARGET_DOUBLE ((VALUE), t);\t\t\t\t\\\n-    fprintf (FILE, \"\\t%s\\t0x%lx\\n\\t%s\\t0x%lx\\n\",\t\t\t\\\n-\t     ASM_LONG, t[0], ASM_LONG, t[1]);\t\t\t\t\\\n-  }\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE) \\\n+  {\t\t\t\t\t\t\t\t\\\n+    long t;\t\t\t\t\t\t\t\\\n+    char str[30];\t\t\t\t\t\t\\\n+    REAL_VALUE_TO_TARGET_SINGLE ((VALUE), t);\t\t\t\\\n+    REAL_VALUE_TO_DECIMAL ((VALUE), \"%.20e\", str);\t\t\\\n+    fprintf (FILE, \"\\t%s\\t0x%lx %s ~%s\\n\", ASM_LONG, t,\t\t\\\n+\t     ASM_COMMENT_START, str);\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\\\n \n-/* This is how to output an assembler line defining a `float' constant.  */\n+/* This is how to output an assembler line defining a `double' constant.\n+   We always have to use a .long pseudo-op to do this because the native\n+   SVR4 ELF assembler is buggy and it generates incorrect values when we\n+   try to use the .float pseudo-op instead.  */\n \n-#define ASM_OUTPUT_FLOAT(FILE,VALUE)\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    long t;\t\t\t\t\t\t\t\t\\\n-    REAL_VALUE_TO_TARGET_SINGLE ((VALUE), t);\t\t\t\t\\\n-    fprintf (FILE, \"\\t%s\\t0x%lx\\n\", ASM_LONG, t);\t\t\t\\\n-  }\t\t\t\t\t\t\t\t\t\\\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE) \\\n+  {\t\t\t\t\t\t\t\t\\\n+    long t[2];\t\t\t\t\t\t\t\\\n+    char str[30];\t\t\t\t\t\t\\\n+    REAL_VALUE_TO_TARGET_DOUBLE ((VALUE), t);\t\t\t\\\n+    REAL_VALUE_TO_DECIMAL ((VALUE), \"%.20e\", str);\t\t\\\n+    fprintf (FILE, \"\\t%s\\t0x%lx %s ~%s\\n\", ASM_LONG, t[0],\t\\\n+\t     ASM_COMMENT_START, str);\t\t\t\t\\\n+    fprintf (FILE, \"\\t%s\\t0x%lx\\n\", ASM_LONG, t[1]);\t\t\\\n+  }\n \n /* This is how to output an assembler line defining a `long double'\n    constant.  */\n \n-#define ASM_OUTPUT_LONG_DOUBLE(FILE,VALUE)\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    long t[4];\t\t\t\t\t\t\t\t\\\n-    REAL_VALUE_TO_TARGET_LONG_DOUBLE ((VALUE), t);\t\t\t\\\n-    fprintf (FILE, \"\\t%s\\t0x%lx\\n\\t%s\\t0x%lx\\n\\t%s\\t0x%lx\\n\\t%s\\t0x%lx\\n\", \\\n-      ASM_LONG, t[0], ASM_LONG, t[1], ASM_LONG, t[2], ASM_LONG, t[3]);\t\\\n+#define ASM_OUTPUT_LONG_DOUBLE(FILE,VALUE) \\\n+  {\t\t\t\t\t\t\t\t\\\n+    long t[4];\t\t\t\t\t\t\t\\\n+    char str[30];\t\t\t\t\t\t\\\n+    REAL_VALUE_TO_TARGET_LONG_DOUBLE ((VALUE), t);\t\t\\\n+    REAL_VALUE_TO_DECIMAL ((VALUE), \"%.20e\", str);\t\t\\\n+    fprintf (FILE, \"\\t%s\\t0x%lx %s ~%s\\n\", ASM_LONG, t[0],\t\\\n+\t     ASM_COMMENT_START, str);\t\t\t\t\\\n+    fprintf (FILE, \"\\t%s\\t0x%lx\\n\", ASM_LONG, t[1]);\t\t\\\n+    fprintf (FILE, \"\\t%s\\t0x%lx\\n\", ASM_LONG, t[2]);\t\t\\\n+    fprintf (FILE, \"\\t%s\\t0x%lx\\n\", ASM_LONG, t[3]);\t\t\\\n   }\n \n /* This is how to output an assembler line defining an `int' constant.  */\n@@ -2942,6 +2984,12 @@ do {\t\t\t\t\t\t\t\t\t\\\n   if ((LOG) != 0)\t\t\t\\\n     fprintf (FILE, \"\\t.align %d\\n\", (1<<(LOG)))\n \n+#define ASM_OUTPUT_ALIGN_CODE(FILE) \\\n+  ASM_OUTPUT_ALIGN (FILE, sparc_align_jumps)\n+\n+#define ASM_OUTPUT_LOOP_ALIGN(FILE) \\\n+  ASM_OUTPUT_ALIGN (FILE, sparc_align_loops)\n+\n #define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n   fprintf (FILE, \"\\t.skip %u\\n\", (SIZE))\n "}]}