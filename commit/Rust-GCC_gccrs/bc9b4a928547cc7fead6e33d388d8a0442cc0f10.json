{"sha": "bc9b4a928547cc7fead6e33d388d8a0442cc0f10", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmM5YjRhOTI4NTQ3Y2M3ZmVhZDZlMzNkMzg4ZDhhMDQ0MmNjMGYxMA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-12-30T11:36:00Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-12-30T11:36:00Z"}, "message": "ipa-inline-analysis.c (edge_set_predicate): Reset size/time when target is UNREACHABLE.\n\n\n\t* ipa-inline-analysis.c (edge_set_predicate): Reset size/time when\n\ttarget is UNREACHABLE.\n\t(evaluate_properties_for_edge): If call statemet is available, use it\n\tto determine compile time constants.\n\t(estimate_function_body_sizes): Enable predicates for early inliner.\n\t(estimate_calls_size_and_time): Speedup.\n\t(inline_merge_summary): Evaluate properties for early inliner, too.\n\nFrom-SVN: r219108", "tree": {"sha": "7ff78c50ac4ee43a35521dc67f161dfcffa3b4e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ff78c50ac4ee43a35521dc67f161dfcffa3b4e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc9b4a928547cc7fead6e33d388d8a0442cc0f10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc9b4a928547cc7fead6e33d388d8a0442cc0f10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc9b4a928547cc7fead6e33d388d8a0442cc0f10", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc9b4a928547cc7fead6e33d388d8a0442cc0f10/comments", "author": null, "committer": null, "parents": [{"sha": "6a81690ec81499b14e94646258774d77a12e7589", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a81690ec81499b14e94646258774d77a12e7589", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a81690ec81499b14e94646258774d77a12e7589"}], "stats": {"total": 100, "additions": 94, "deletions": 6}, "files": [{"sha": "3c2ded03a6348014ce8ca3b99b4af472081e7402", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc9b4a928547cc7fead6e33d388d8a0442cc0f10/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc9b4a928547cc7fead6e33d388d8a0442cc0f10/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bc9b4a928547cc7fead6e33d388d8a0442cc0f10", "patch": "@@ -1,3 +1,13 @@\n+2014-12-30  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-inline-analysis.c (edge_set_predicate): Reset size/time when\n+\ttarget is UNREACHABLE.\n+\t(evaluate_properties_for_edge): If call statemet is available, use it\n+\tto determine compile time constants.\n+\t(estimate_function_body_sizes): Enable predicates for early inliner.\n+\t(estimate_calls_size_and_time): Speedup.\n+\t(inline_merge_summary): Evaluate properties for early inliner, too.\n+\n 2014-12-29  Steve Ellcey  <sellcey@mips.com>\n \n \t* config/mips/t-mti-linux (MULTILIB_EXCEPTIONS): Add exceptions"}, {"sha": "5cc0a2500ee57ec0b22fdffb24e051687d55c657", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 55, "deletions": 6, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc9b4a928547cc7fead6e33d388d8a0442cc0f10/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc9b4a928547cc7fead6e33d388d8a0442cc0f10/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=bc9b4a928547cc7fead6e33d388d8a0442cc0f10", "patch": "@@ -770,6 +770,8 @@ edge_set_predicate (struct cgraph_edge *e, struct predicate *predicate)\n       e->redirect_callee (cgraph_node::get_create\n \t\t\t    (builtin_decl_implicit (BUILT_IN_UNREACHABLE)));\n       e->inline_failed = CIF_UNREACHABLE;\n+      es->call_stmt_size = 0;\n+      es->call_stmt_time = 0;\n       if (callee)\n \tcallee->remove_symbol_and_inline_clones ();\n     }\n@@ -940,6 +942,14 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n \t{\n \t  struct ipa_jump_func *jf = ipa_get_ith_jump_func (args, i);\n \t  tree cst = ipa_value_from_jfunc (parms_info, jf);\n+\n+\t  if (!cst && e->call_stmt\n+\t      && i < (int)gimple_call_num_args (e->call_stmt))\n+\t    {\n+\t      cst = gimple_call_arg (e->call_stmt, i);\n+\t      if (!is_gimple_min_invariant (cst))\n+\t\tcst = NULL;\n+\t    }\n \t  if (cst)\n \t    {\n \t      gcc_checking_assert (TREE_CODE (cst) != TREE_BINFO);\n@@ -958,6 +968,22 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n \t  known_aggs[i] = &jf->agg;\n \t}\n     }\n+  else if (e->call_stmt && !e->call_stmt_cannot_inline_p\n+\t   && ((clause_ptr && info->conds) || known_vals_ptr))\n+    {\n+      int i, count = (int)gimple_call_num_args (e->call_stmt);\n+\n+      if (count && (info->conds || known_vals_ptr))\n+\tknown_vals.safe_grow_cleared (count);\n+      for (i = 0; i < count; i++)\n+\t{\n+\t  tree cst = gimple_call_arg (e->call_stmt, i);\n+\t  if (!is_gimple_min_invariant (cst))\n+\t    cst = NULL;\n+\t  if (cst)\n+\t    known_vals[i] = cst;\n+\t}\n+    }\n \n   if (clause_ptr)\n     *clause_ptr = evaluate_conditions_for_known_args (callee, inline_p,\n@@ -2464,10 +2490,22 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n   info->conds = NULL;\n   info->entry = NULL;\n \n-  if (opt_for_fn (node->decl, optimize) && !early)\n+  /* When optimizing and analyzing for IPA inliner, initialize loop optimizer\n+     so we can produce proper inline hints.\n+\n+     When optimizing and analyzing for early inliner, initialize node params\n+     so we can produce correct BB predicates.  */\n+     \n+  if (opt_for_fn (node->decl, optimize))\n     {\n       calculate_dominance_info (CDI_DOMINATORS);\n-      loop_optimizer_init (LOOPS_NORMAL | LOOPS_HAVE_RECORDED_EXITS);\n+      if (!early)\n+        loop_optimizer_init (LOOPS_NORMAL | LOOPS_HAVE_RECORDED_EXITS);\n+      else\n+\t{\n+\t  ipa_check_create_node_params ();\n+\t  ipa_initialize_node_params (node);\n+\t}\n \n       if (ipa_node_params_sum)\n \t{\n@@ -2704,7 +2742,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n     time = MAX_TIME;\n   free (order);\n \n-  if (!early && nonconstant_names.exists ())\n+  if (nonconstant_names.exists () && !early)\n     {\n       struct loop *loop;\n       predicate loop_iterations = true_predicate ();\n@@ -2809,9 +2847,12 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n   inline_summaries->get (node)->self_time = time;\n   inline_summaries->get (node)->self_size = size;\n   nonconstant_names.release ();\n-  if (opt_for_fn (node->decl, optimize) && !early)\n+  if (opt_for_fn (node->decl, optimize))\n     {\n-      loop_optimizer_finalize ();\n+      if (!early)\n+        loop_optimizer_finalize ();\n+      else\n+\tipa_free_all_node_params ();\n       free_dominance_info (CDI_DOMINATORS);\n     }\n   if (dump_file)\n@@ -3062,6 +3103,13 @@ estimate_calls_size_and_time (struct cgraph_node *node, int *size,\n   for (e = node->callees; e; e = e->next_callee)\n     {\n       struct inline_edge_summary *es = inline_edge_summary (e);\n+\n+      /* Do not care about zero sized builtins.  */\n+      if (e->inline_failed && !es->call_stmt_size)\n+\t{\n+\t  gcc_checking_assert (!es->call_stmt_time);\n+\t  continue;\n+\t}\n       if (!es->predicate\n \t  || evaluate_predicate (es->predicate, possible_truths))\n \t{\n@@ -3522,13 +3570,14 @@ inline_merge_summary (struct cgraph_edge *edge)\n   else\n     toplev_predicate = true_predicate ();\n \n+  if (callee_info->conds)\n+    evaluate_properties_for_edge (edge, true, &clause, NULL, NULL, NULL);\n   if (ipa_node_params_sum && callee_info->conds)\n     {\n       struct ipa_edge_args *args = IPA_EDGE_REF (edge);\n       int count = ipa_get_cs_argument_count (args);\n       int i;\n \n-      evaluate_properties_for_edge (edge, true, &clause, NULL, NULL, NULL);\n       if (count)\n \t{\n \t  operand_map.safe_grow_cleared (count);"}, {"sha": "b91ac70f46b1bbdfe555fcf7c07d797cec7bf7db", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc9b4a928547cc7fead6e33d388d8a0442cc0f10/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc9b4a928547cc7fead6e33d388d8a0442cc0f10/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bc9b4a928547cc7fead6e33d388d8a0442cc0f10", "patch": "@@ -1,3 +1,7 @@\n+2014-12-30  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* gcc.dg/ipa/inline-7.c: New testcase.\n+\n 2014-12-29  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/60357"}, {"sha": "b31af6c52624ca9a34d8925c9a749e6528792033", "filename": "gcc/testsuite/gcc.dg/ipa/inline-7.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc9b4a928547cc7fead6e33d388d8a0442cc0f10/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Finline-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc9b4a928547cc7fead6e33d388d8a0442cc0f10/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Finline-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Finline-7.c?ref=bc9b4a928547cc7fead6e33d388d8a0442cc0f10", "patch": "@@ -0,0 +1,25 @@\n+/* Check that early inliner works out that a is empty of parameter 0.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-einline -fno-partial-inlining\"  } */\n+void t(void);\n+int a (int b)\n+{\n+  if (!b)\n+   {\n+\tt();\n+\tt();\n+\tt();\n+\tt();\n+\tt();\n+\tt();\n+\tt();\n+   }\n+}\n+void\n+m()\n+{\n+ a(1);\n+ a(0);\n+}\n+/* { dg-final { scan-tree-dump-times \"Inlining a into m\" 1 \"einline\"  } } */\n+/* { dg-final { cleanup-tree-dump \"einline\" } } */"}]}