{"sha": "fc45c7efec9457a616b27caab813322c93481b9d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmM0NWM3ZWZlYzk0NTdhNjE2YjI3Y2FhYjgxMzMyMmM5MzQ4MWI5ZA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "1998-10-14T12:54:59Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1998-10-14T12:54:59Z"}, "message": "jcf-write.c (write_classfile): Add output class file as target.\n\n\t* jcf-write.c (write_classfile): Add output class file as target.\n\t* lang-options.h: Added -MD, -MMD, -M, and -MM.\n\t* jcf.h: Added declarations for dependency-tracking functions.\n\t* lang-specs.h: Handle -M, -MM, MD, and -MMD.\n\t* lang.c (lang_decode_option): Recognize -MD and -MMD.\n\t(finish_parse): Call jcf_dependency_write.\n\t(dependency_tracking): New global.\n\t(DEPEND_SET_FILE): New define.\n\t(DEPEND_ENABLE): New define.\n\t(init_parse): Enable dependency tracking if required.\n\tInclude \"flags.h\".\n\t* Makefile.in (JAVA_OBJS): Added jcf-depend.o.\n\t(../jcf-dump$(exeext)): Depend on and link with jcf-depend.o.\n\t(../gcjh$(exeext)): Likewise.\n\t(jcf-depend.o): New target.\n\t* Make-lang.in (JAVA_SRCS): Added jcf-depend.c.\n\t(GCJH_SOURCES): Likewise.\n\t* jcf-io.c (open_class): Call jcf_dependency_add_file.  Added\n\tdep_name argument.\n\t(find_classfile): Added dep_name argument.\n\t(find_class): Compute name of dependency.\n\t(open_in_zip): Call jcf_dependency_add_file.\n\t* gjavah.c (output_file): No longer global.\n\t(usage): Don't mention \"gjavah\".\n\t(help): Likewise.\n\t(java_no_argument): Likewise.\n\t(version): Likewise.\n\t(main): Recognize and handle -M family of options.\n\t(print_mangled_classname): Return is void.\n\t(process_file): Handle case where output is suppressed.\n\t(HANDLE_END_FIELD): Likewise.\n\t(HANDLE_METHOD): Likewise.\n\t* jcf-depend.c: New file.\n\nFrom-SVN: r23085", "tree": {"sha": "6c0b69ec67e30f1aa5ef34301b4a5eba2beec889", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c0b69ec67e30f1aa5ef34301b4a5eba2beec889"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc45c7efec9457a616b27caab813322c93481b9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc45c7efec9457a616b27caab813322c93481b9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc45c7efec9457a616b27caab813322c93481b9d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc45c7efec9457a616b27caab813322c93481b9d/comments", "author": null, "committer": null, "parents": [{"sha": "bf94d1ecc773351392f54859e697f557ba097ed8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf94d1ecc773351392f54859e697f557ba097ed8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf94d1ecc773351392f54859e697f557ba097ed8"}], "stats": {"total": 657, "additions": 574, "deletions": 83}, "files": [{"sha": "3e496ae383b74bcce72c11f38ab724655540712d", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc45c7efec9457a616b27caab813322c93481b9d/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc45c7efec9457a616b27caab813322c93481b9d/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=fc45c7efec9457a616b27caab813322c93481b9d", "patch": "@@ -1,3 +1,39 @@\n+1998-10-14  Tom Tromey  <tromey@cygnus.com>\n+\n+\t* jcf-write.c (write_classfile): Add output class file as target.\n+\t* lang-options.h: Added -MD, -MMD, -M, and -MM.\n+\t* jcf.h: Added declarations for dependency-tracking functions.\n+\t* lang-specs.h: Handle -M, -MM, MD, and -MMD.\n+\t* lang.c (lang_decode_option): Recognize -MD and -MMD.\n+\t(finish_parse): Call jcf_dependency_write.\n+\t(dependency_tracking): New global.\n+\t(DEPEND_SET_FILE): New define.\n+\t(DEPEND_ENABLE): New define.\n+\t(init_parse): Enable dependency tracking if required.\n+\tInclude \"flags.h\".\n+\t* Makefile.in (JAVA_OBJS): Added jcf-depend.o.\n+\t(../jcf-dump$(exeext)): Depend on and link with jcf-depend.o.\n+\t(../gcjh$(exeext)): Likewise.\n+\t(jcf-depend.o): New target.\n+\t* Make-lang.in (JAVA_SRCS): Added jcf-depend.c.\n+\t(GCJH_SOURCES): Likewise.\n+\t* jcf-io.c (open_class): Call jcf_dependency_add_file.  Added\n+\tdep_name argument.\n+\t(find_classfile): Added dep_name argument.\n+\t(find_class): Compute name of dependency.\n+\t(open_in_zip): Call jcf_dependency_add_file.\n+\t* gjavah.c (output_file): No longer global.\n+\t(usage): Don't mention \"gjavah\".\n+\t(help): Likewise.\n+\t(java_no_argument): Likewise.\n+\t(version): Likewise.\n+\t(main): Recognize and handle -M family of options.\n+\t(print_mangled_classname): Return is void.\n+\t(process_file): Handle case where output is suppressed.\n+\t(HANDLE_END_FIELD): Likewise.\n+\t(HANDLE_METHOD): Likewise.\n+\t* jcf-depend.c: New file.\n+\n Tue Oct 13 23:34:12 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* java-tree.def: Add missing newline at EOF."}, {"sha": "a7526afb0f10c5b2d104857fbfc4d974689dbc04", "filename": "gcc/java/Make-lang.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc45c7efec9457a616b27caab813322c93481b9d/gcc%2Fjava%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc45c7efec9457a616b27caab813322c93481b9d/gcc%2Fjava%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FMake-lang.in?ref=fc45c7efec9457a616b27caab813322c93481b9d", "patch": "@@ -73,7 +73,8 @@ JAVA_SRCS = $(srcdir)/java/parse.y $(srcdir)/java/class.c \\\n   $(srcdir)/java/lang.c $(srcdir)/java/typeck.c $(srcdir)/java/except.c \\\n   $(srcdir)/java/verify.c $(srcdir)/java/zextract.c $(srcdir)/java/jcf-io.c \\\n   $(srcdir)/java/jcf-parse.c $(srcdir)/java/mangle.c \\\n-  $(srcdir)/java/jcf-write.c $(srcdir)/java/buffer.c\n+  $(srcdir)/java/jcf-write.c $(srcdir)/java/buffer.c \\\n+  $(srcdir)/java/jcf-depend.c \n \n jc1$(exeext): $(P) $(JAVA_SRCS) $(LIBDEPS) stamp-objlist\n \tcd java; $(MAKE) $(FLAGS_TO_PASS) $(JAVA_FLAGS_TO_PASS) ../jc1$(exeext)\n@@ -118,7 +119,7 @@ jvgenmain$(exeext): $(srcdir)/java/jvgenmain.c $(srcdir)/java/mangle.c \\\n GCJH_SOURCES = $(srcdir)/java/gjavah.c $(srcdir)/java/jcf-io.c \\\n \t$(srcdir)/java/zextract.c $(srcdir)/java/jcf-reader.c \\\n \t$(srcdir)/java/jcf.h $(srcdir)/java/javaop.h \\\n-\t$(srcdir)/java/javaop.def\n+\t$(srcdir)/java/javaop.def $(srcdir)/java/jcf-depend.c\n \n gcjh$(exeext): $(GCJH_SOURCES)\n \tcd java && $(MAKE) $(FLAGS_TO_PASS) $(JAVA_FLAGS_TO_PASS) ../gcjh$(exeext)"}, {"sha": "50243d7a6a0221c2dd986234cf35076db2f813dc", "filename": "gcc/java/Makefile.in", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc45c7efec9457a616b27caab813322c93481b9d/gcc%2Fjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc45c7efec9457a616b27caab813322c93481b9d/gcc%2Fjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FMakefile.in?ref=fc45c7efec9457a616b27caab813322c93481b9d", "patch": "@@ -182,7 +182,7 @@ INCLUDES = -I. -I.. -I$(srcdir) -I$(srcdir)/.. -I$(srcdir)/../config -I$(srcdir)\n #\n JAVA_OBJS = parse.o class.o decl.o expr.o constants.o lang.o typeck.o \\\n   except.o verify.o zextract.o jcf-io.o jcf-parse.o mangle.o jcf-write.o \\\n-  buffer.o memmove.o\n+  buffer.o memmove.o jcf-depend.o\n \n JAVA_OBJS_LITE = parse-scan.o jv-scan.o\n \n@@ -200,15 +200,15 @@ compiler: ../jc1$(exeext) ../jv-scan$(exeext)\n \t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ \\\n \t      $(JAVA_OBJS_LITE) $(LIBS)\n \n-../jcf-dump$(exeext): jcf-dump.o jcf-io.o zextract.o memmove.o\n-\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ jcf-dump.o jcf-io.o zextract.o memmove.o\n+../jcf-dump$(exeext): jcf-dump.o jcf-io.o jcf-depend.o zextract.o memmove.o\n+\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ jcf-dump.o jcf-io.o jcf-depend.o zextract.o memmove.o\n \n # Dependencies here must be kept in sync with dependencies in Make-lang.in.\n ../jvgenmain$(exeext):  jvgenmain.o mangle.o\n \t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ jvgenmain.o mangle.o ../obstack.o\n \n-../gcjh$(exeext): gjavah.o jcf-io.o zextract.o memmove.o\n-\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ gjavah.o jcf-io.o zextract.o memmove.o \n+../gcjh$(exeext): gjavah.o jcf-io.o jcf-depend.o zextract.o memmove.o\n+\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ gjavah.o jcf-io.o jcf-depend.o zextract.o memmove.o \n \n Makefile: $(srcdir)/Makefile.in $(srcdir)/../configure\n \tcd ..; $(SHELL) config.status\n@@ -287,6 +287,7 @@ expr.o : expr.c $(CONFIG_H) $(JAVA_TREE_H) jcf.h $(srcdir)/../real.h \\\n   $(RTL_H) $(EXPR_H) javaop.h java-opcodes.h $(srcdir)/../except.h \\\n   java-except.h java-except.h parse.h $(srcdir)/../toplev.h \\\n   $(srcdir)/../system.h\n+jcf-depend.o: jcf-depend.c $(CONFIG_H) $(srcdir)/../system.h\n jcf-io.o: jcf-io.c $(CONFIG_H) $(srcdir)/../system.h\n jcf-parse.o : jcf-parse.c $(CONFIG_H) $(JAVA_TREE_H) $(srcdir)/../flags.h \\\n   $(srcdir)/../input.h java-except.h $(srcdir)/../system.h"}, {"sha": "4ad28db46a86e5bcbb15d5039609ddae97a8945a", "filename": "gcc/java/gjavah.c", "status": "modified", "additions": 115, "deletions": 48, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc45c7efec9457a616b27caab813322c93481b9d/gcc%2Fjava%2Fgjavah.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc45c7efec9457a616b27caab813322c93481b9d/gcc%2Fjava%2Fgjavah.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fgjavah.c?ref=fc45c7efec9457a616b27caab813322c93481b9d", "patch": "@@ -40,8 +40,6 @@ static int found_error = 0;\n /* Directory to place resulting files in. Set by -d option. */\n char *output_directory = \"\";\n \n-char *output_file = NULL;\n-\n /* Directory to place temporary file.  Set by -td option.  Currently unused. */\n char *temp_directory = \"/tmp\";\n \n@@ -115,14 +113,14 @@ JCF_u2 current_field_flags;\n static int field_pass;\n \n #define HANDLE_END_FIELD() \\\n-  if (field_pass) print_field_info (out, jcf, current_field_name, \\\n-\t\t\t\t    current_field_signature, \\\n-\t\t\t\t    current_field_flags);\n+  if (out && field_pass) print_field_info (out, jcf, current_field_name, \\\n+\t\t\t\t\t   current_field_signature, \\\n+\t\t\t\t\t   current_field_flags);\n \n #define HANDLE_CONSTANTVALUE(VALUEINDEX) current_field_value = (VALUEINDEX)\n \n #define HANDLE_METHOD(ACCESS_FLAGS, NAME, SIGNATURE, ATTRIBUTE_COUNT) \\\n-  print_method_info (out, jcf, NAME, SIGNATURE, ACCESS_FLAGS)\n+  if (out) print_method_info (out, jcf, NAME, SIGNATURE, ACCESS_FLAGS)\n \n #include \"jcf-reader.c\"\n \n@@ -175,7 +173,7 @@ print_base_classname (stream, jcf, index)\n      int index;\n {\n   int name_index = JPOOL_USHORT1 (jcf, index);\n-  int i, len;\n+  int len;\n   unsigned char *s, *p, *limit;\n \n   s = JPOOL_UTF_DATA (jcf, name_index);\n@@ -629,7 +627,7 @@ DEFUN(print_c_decl, (stream, jcf, name_index, signature_index, flags, is_init,\n     }\n }\n \n-int\n+void\n DEFUN(print_mangled_classname, (stream, jcf, prefix, index),\n       FILE *stream AND JCF *jcf AND char *prefix AND int index)\n {\n@@ -652,7 +650,7 @@ print_cxx_classname (stream, prefix, jcf, index)\n      int index;\n {\n   int name_index = JPOOL_USHORT1 (jcf, index);\n-  int i, len, c;\n+  int len, c;\n   unsigned char *s, *p, *limit;\n \n   s = JPOOL_UTF_DATA (jcf, name_index);\n@@ -760,17 +758,20 @@ DEFUN(process_file, (jcf, out),\n \n   jcf_parse_class (jcf);\n \n-  if (written_class_count++ == 0)\n+  if (written_class_count++ == 0 && out)\n     fputs (\"// DO NOT EDIT THIS FILE - it is machine generated -*- c++ -*-\\n\\n\",\n \t   out);\n \n-  print_mangled_classname (out, jcf, \"#ifndef __\", jcf->this_class);\n-  fprintf (out, \"__\\n\");\n+  if (out)\n+    {\n+      print_mangled_classname (out, jcf, \"#ifndef __\", jcf->this_class);\n+      fprintf (out, \"__\\n\");\n \n-  print_mangled_classname (out, jcf, \"#define __\", jcf->this_class);\n-  fprintf (out, \"__\\n\\n\");\n+      print_mangled_classname (out, jcf, \"#define __\", jcf->this_class);\n+      fprintf (out, \"__\\n\\n\");\n+    }\n \n-  if (jcf->super_class)\n+  if (jcf->super_class && out)\n     {\n       int super_length;\n       unsigned char *supername = super_class_name (jcf, &super_length);\n@@ -789,20 +790,23 @@ DEFUN(process_file, (jcf, out),\n       fputs (\"\\n\", out);\n     }\n \n-  print_class_decls (out, jcf);\n+  if (out)\n+    {\n+      print_class_decls (out, jcf);\n \n-  for (i = 0; i < prepend_count; ++i)\n-    fprintf (out, \"%s\\n\", prepend_specs[i]);\n-  if (prepend_count > 0)\n-    fputc ('\\n', out);\n+      for (i = 0; i < prepend_count; ++i)\n+\tfprintf (out, \"%s\\n\", prepend_specs[i]);\n+      if (prepend_count > 0)\n+\tfputc ('\\n', out);\n+    }\n \n-  if (! print_cxx_classname (out, \"class \", jcf, jcf->this_class))\n+  if (out && ! print_cxx_classname (out, \"class \", jcf, jcf->this_class))\n     {\n       fprintf (stderr, \"class is of array type\\n\");\n       found_error = 1;\n       return;\n     }\n-  if (jcf->super_class)\n+  if (out && jcf->super_class)\n     {\n       if (! print_cxx_classname (out, \" : public \", jcf, jcf->super_class))\n \t{\n@@ -811,7 +815,8 @@ DEFUN(process_file, (jcf, out),\n \t  return;\n \t}\n     }\n-  fputs (\"\\n{\\n\", out);\n+  if (out)\n+    fputs (\"\\n{\\n\", out);\n \n   /* We make a single pass over the file, printing methods and fields\n      as we see them.  We have to list the methods in the same order\n@@ -835,38 +840,41 @@ DEFUN(process_file, (jcf, out),\n \n   jcf_parse_final_attributes (jcf);\n \n-  /* Generate friend decl if we still must.  */\n-  for (i = 0; i < friend_count; ++i)\n-    fprintf (out, \"  friend %s\\n\", friend_specs[i]);\n+  if (out)\n+    {\n+      /* Generate friend decl if we still must.  */\n+      for (i = 0; i < friend_count; ++i)\n+\tfprintf (out, \"  friend %s\\n\", friend_specs[i]);\n \n-  /* Generate extra declarations.  */\n-  if (add_count > 0)\n-    fputc ('\\n', out);\n-  for (i = 0; i < add_count; ++i)\n-    fprintf (out, \"  %s\\n\", add_specs[i]);\n+      /* Generate extra declarations.  */\n+      if (add_count > 0)\n+\tfputc ('\\n', out);\n+      for (i = 0; i < add_count; ++i)\n+\tfprintf (out, \"  %s\\n\", add_specs[i]);\n \n-  fputs (\"};\\n\", out);\n+      fputs (\"};\\n\", out);\n \n-  if (append_count > 0)\n-    fputc ('\\n', out);\n-  for (i = 0; i < append_count; ++i)\n-    fprintf (out, \"%s\\n\", append_specs[i]);\n+      if (append_count > 0)\n+\tfputc ('\\n', out);\n+      for (i = 0; i < append_count; ++i)\n+\tfprintf (out, \"%s\\n\", append_specs[i]);\n \n-  print_mangled_classname (out, jcf, \"\\n#endif /* __\", jcf->this_class);\n-  fprintf (out, \"__ */\\n\");\n+      print_mangled_classname (out, jcf, \"\\n#endif /* __\", jcf->this_class);\n+      fprintf (out, \"__ */\\n\");\n+    }\n }\n \n static void\n usage ()\n {\n-  fprintf (stderr, \"gjavah: no classes specified\\n\");\n+  fprintf (stderr, \"gcjh: no classes specified\\n\");\n   exit (1);\n }\n \n static void\n help ()\n {\n-  printf (\"Usage: gjavah [OPTION]... CLASS...\\n\\n\");\n+  printf (\"Usage: gcjh [OPTION]... CLASS...\\n\\n\");\n   printf (\"Generate C++ header files from .class files\\n\\n\");\n   printf (\"  --classpath PATH        Set path to find .class files\\n\");\n   printf (\"  -d DIRECTORY            Set output directory name\\n\");\n@@ -883,15 +891,15 @@ static void\n java_no_argument (opt)\n      char *opt;\n {\n-  fprintf (stderr, \"gjavah: no argument given for option `%s'\\n\", opt);\n+  fprintf (stderr, \"gcjh: no argument given for option `%s'\\n\", opt);\n   exit (1);\n }\n \n static void\n version ()\n {\n   /* FIXME: use version.c?  */\n-  printf (\"gjavah (GNU gcc) 0.0\\n\\n\");\n+  printf (\"gcjh (GNU gcc) 0.0\\n\\n\");\n   printf (\"Copyright (C) 1998 Free Software Foundation, Inc.\\n\");\n   printf (\"This is free software; see the source for copying conditions.  There is NO\\n\");\n   printf (\"warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\\n\");\n@@ -904,6 +912,8 @@ DEFUN(main, (argc, argv),\n {\n   JCF jcf;\n   int argi;\n+  char *output_file = NULL;\n+  int emit_dependencies = 0, suppress_output = 0;\n \n   if (argc <= 1)\n     usage ();\n@@ -999,6 +1009,33 @@ DEFUN(main, (argc, argv),\n \thelp ();\n       else if (strcmp (arg, \"-version\") == 0)\n \tversion ();\n+      else if (strcmp (arg, \"-M\") == 0)\n+\t{\n+\t  emit_dependencies = 1;\n+\t  suppress_output = 1;\n+\t  jcf_dependency_init (1);\n+\t}\n+      else if (strcmp (arg, \"-MM\") == 0)\n+\t{\n+\t  emit_dependencies = 1;\n+\t  suppress_output = 1;\n+\t  jcf_dependency_init (0);\n+\t}\n+      else if (strcmp (arg, \"-MG\") == 0)\n+\t{\n+\t  fprintf (stderr, \"gcjh: `%s' option is unimplemented\\n\", argv[argi]);\n+\t  exit (1);\n+\t}\n+      else if (strcmp (arg, \"-MD\") == 0)\n+\t{\n+\t  emit_dependencies = 1;\n+\t  jcf_dependency_init (1);\n+\t}\n+      else if (strcmp (arg, \"-MMD\") == 0)\n+\t{\n+\t  emit_dependencies = 1;\n+\t  jcf_dependency_init (0);\n+\t}\n       else\n \t{\n \t  fprintf (stderr, \"%s: illegal argument\\n\", argv[argi]);\n@@ -1009,6 +1046,12 @@ DEFUN(main, (argc, argv),\n   if (argi == argc)\n     usage ();\n \n+  if (output_file && emit_dependencies)\n+    {\n+      fprintf (stderr, \"gcjh: can't specify both -o and -MD\\n\");\n+      exit (1);\n+    }\n+\n   if (classpath == NULL)\n     {\n       classpath = (char *) getenv (\"CLASSPATH\");\n@@ -1023,6 +1066,8 @@ DEFUN(main, (argc, argv),\n \n       if (verbose)\n \tfprintf (stderr, \"Processing %s\\n\", classname);\n+      if (! output_file)\n+\tjcf_dependency_reset ();\n       classfile_name = find_class (classname, strlen (classname), &jcf, 1);\n       if (classfile_name == NULL)\n \t{\n@@ -1036,7 +1081,9 @@ DEFUN(main, (argc, argv),\n \t  if (strcmp (output_file, \"-\") == 0)\n \t    out = stdout;\n \t  else if (out == NULL)\n-\t    out = fopen (output_file, \"w\");\n+\t    {\n+\t      out = fopen (output_file, \"w\");\n+\t    }\n \t  if (out == NULL)\n \t    {\n \t      perror (output_file);\n@@ -1059,18 +1106,38 @@ DEFUN(main, (argc, argv),\n \t\tch = '/';\n \t      current_output_file[dir_len++] = ch;\n \t    }\n-\t  strcpy (current_output_file+dir_len, \".h\");\n-\t  out = fopen (current_output_file, \"w\");\n-\t  if (out == NULL)\n+\t  if (emit_dependencies)\n \t    {\n-\t      perror (current_output_file);\n-\t      exit (1);\n+\t      if (suppress_output)\n+\t\t{\n+\t\t  jcf_dependency_set_dep_file (\"-\");\n+\t\t  out = NULL;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* We use `.hd' and not `.d' to avoid clashes with\n+\t\t     dependency tracking from straight compilation.  */\n+\t\t  strcpy (current_output_file + dir_len, \".hd\");\n+\t\t  jcf_dependency_set_dep_file (current_output_file);\n+\t\t}\n+\t    }\n+\t  strcpy (current_output_file + dir_len, \".h\");\n+\t  jcf_dependency_set_target (current_output_file);\n+\t  if (! suppress_output)\n+\t    {\n+\t      out = fopen (current_output_file, \"w\");\n+\t      if (out == NULL)\n+\t\t{\n+\t\t  perror (current_output_file);\n+\t\t  exit (1);\n+\t\t}\n \t    }\n \t}\n       process_file (&jcf, out);\n       JCF_FINISH (&jcf);\n       if (current_output_file != output_file)\n \tfree (current_output_file);\n+      jcf_dependency_write ();\n     }\n \n   if (out != NULL && out != stdout)"}, {"sha": "c923a9c806a8c35de408049ceb2bc440e20695a1", "filename": "gcc/java/jcf-depend.c", "status": "added", "additions": 268, "deletions": 0, "changes": 268, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc45c7efec9457a616b27caab813322c93481b9d/gcc%2Fjava%2Fjcf-depend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc45c7efec9457a616b27caab813322c93481b9d/gcc%2Fjava%2Fjcf-depend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-depend.c?ref=fc45c7efec9457a616b27caab813322c93481b9d", "patch": "@@ -0,0 +1,268 @@\n+/* Functions for handling dependency tracking when reading .class files.\n+\n+   Copyright (C) 1998  Free Software Foundation, Inc.\n+\n+This program is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  \n+\n+Java and all Java-based marks are trademarks or registered trademarks\n+of Sun Microsystems, Inc. in the United States and other countries.\n+The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n+\n+/* Written by Tom Tromey <tromey@cygnus.com>, October 1998.  */\n+\n+#include <config.h>\n+#include \"system.h\"\n+\n+#include <assert.h>\n+\n+\f\n+\n+/* We keep a linked list of all the files we've already read.  */\n+struct entry\n+{\n+  char *file;\n+  struct entry *next;\n+};\n+\n+/* List of files.  */\n+static struct entry *dependencies = NULL;\n+\n+/* Name of targets.  We support multiple targets when writing .class\n+   files.  */\n+static struct entry *targets = NULL;\n+\n+/* Number of columns in output.  */\n+#define MAX_OUTPUT_COLUMNS 72\n+\n+/* The output file, or NULL if we aren't doing dependency tracking.  */\n+static FILE *dep_out = NULL;\n+\n+/* Nonzero if system files should be added.  */\n+static int system_files;\n+\n+\f\n+\n+/* Helper to free an entry list.  */\n+static void\n+free_entry (entp)\n+     struct entry **entp;\n+{\n+  struct entry *ent, *next;\n+\n+  for (ent = *entp; ent != NULL; ent = next)\n+    {\n+      next = ent->next;\n+      free (ent->file);\n+      free (ent);\n+    }\n+  *entp = NULL;\n+}\n+\n+/* Helper to add to entry list.  */\n+static void\n+add_entry (entp, name)\n+     struct entry **entp;\n+     char *name;\n+{\n+  struct entry *ent;\n+\n+  for (ent = *entp; ent != NULL; ent = ent->next)\n+    if (! strcmp (ent->file, name))\n+      return;\n+\n+  ent = (struct entry *) malloc (sizeof (struct entry));\n+  ent->file = strdup (name);\n+  ent->next = *entp;\n+  *entp = ent;\n+}\n+\n+/* Call this to reset the dependency module.  This is required if\n+   multiple dependency files are being generated from a single tool\n+   invocation.  */\n+void\n+jcf_dependency_reset ()\n+{\n+  struct entry *ent, *next;\n+\n+  free_entry (&dependencies);\n+  free_entry (&targets);\n+\n+  if (dep_out != NULL)\n+    {\n+      if (dep_out != stdout)\n+\tfclose (dep_out);\n+      dep_out = NULL;\n+    }\n+}\n+\n+void\n+jcf_dependency_set_target (name)\n+     char *name;\n+{\n+  free_entry (&targets);\n+  if (name != NULL)\n+    add_entry (&targets, name);\n+}\n+\n+void\n+jcf_dependency_add_target (name)\n+     char *name;\n+{\n+  add_entry (&targets, name);\n+}\n+\n+void\n+jcf_dependency_set_dep_file (name)\n+     const char *name;\n+{\n+  assert (dep_out != stdout);\n+  if (dep_out)\n+    fclose (dep_out);\n+  if (! strcmp (name, \"-\"))\n+    dep_out = stdout;\n+  else\n+    dep_out = fopen (name, \"w\");\n+}\n+\n+void\n+jcf_dependency_add_file (filename, system_p)\n+     char *filename;\n+     int system_p;\n+{\n+  struct entry *ent;\n+\n+  /* Just omit system files.  */\n+  if (system_p && ! system_files)\n+    return;\n+\n+  add_entry (&dependencies, filename);\n+}\n+\n+void\n+jcf_dependency_init (system_p)\n+     int system_p;\n+{\n+  system_files = system_p;\n+}\n+\n+/* FIXME: this is taken almost directly from cccp.c.  Such duplication\n+   is bad.  */\n+static char *\n+munge (filename)\n+     char *filename;\n+{\n+  static char *buffer = NULL;\n+  static int buflen = 0;\n+\n+  int len = 2 * strlen (filename) + 1;\n+  char *p, *dst;\n+\n+  if (buflen < len)\n+    {\n+      buflen = len;\n+      if (buffer == NULL)\n+\tbuffer = malloc (buflen);\n+      else\n+\tbuffer = realloc (buffer, buflen);\n+    }\n+\n+  dst = buffer;\n+  for (p = filename; *p; ++p)\n+    {\n+      switch (*p)\n+\t{\n+\tcase ' ':\n+\tcase '\\t':\n+\t  {\n+\t    /* GNU make uses a weird quoting scheme for white space.\n+\t       A space or tab preceded by 2N+1 backslashes represents\n+\t       N backslashes followed by space; a space or tab\n+\t       preceded by 2N backslashes represents N backslashes at\n+\t       the end of a file name; and backslashes in other\n+\t       contexts should not be doubled.  */\n+\t    char *q;\n+\t    for (q = p - 1; filename < q && q[-1] == '\\\\';  q--)\n+\t      *dst++ = '\\\\';\n+\t  }\n+\t  *dst++ = '\\\\';\n+\t  goto ordinary_char;\n+\n+\tcase '$':\n+\t  *dst++ = '$';\n+\t  /* Fall through.  This can mishandle things like \"$(\" but\n+\t     there's no easy fix.  */\n+\tdefault:\n+\tordinary_char:\n+\t  /* This can mishandle characters in the string \"\\0\\n%*?[\\\\~\";\n+\t     exactly which chars are mishandled depends on the `make' version.\n+\t     We know of no portable solution for this;\n+\t     even GNU make 3.76.1 doesn't solve the problem entirely.\n+\t     (Also, '\\0' is mishandled due to our calling conventions.)  */\n+\t  *dst++ = *p;\n+\t  break;\n+\t}\n+    }\n+\n+  *dst++ = '\\0';\n+  return buffer;\n+}\n+\n+/* Helper to print list of files.  */\n+static int\n+print_ents (ent, column)\n+     struct entry *ent;\n+     int column;\n+{\n+  int first = 1;\n+\n+  for (; ent != NULL; ent = ent->next)\n+    {\n+      char *depname = munge (ent->file);\n+      int len = strlen (depname);\n+\n+      if (column + len + 2 > MAX_OUTPUT_COLUMNS)\n+\t{\n+\t  fprintf (dep_out, \" \\\\\\n \");\n+\t  column = 1;\n+\t}\n+\n+      if (! first)\n+\tfputs (\" \", dep_out);\n+      fputs (depname, dep_out);\n+      first = 0;\n+      column += len + 1;\n+    }\n+\n+  return column;\n+}\n+\n+void\n+jcf_dependency_write ()\n+{\n+  int column = 0;\n+  struct entry *ent;\n+\n+  if (! dep_out)\n+    return;\n+\n+  assert (targets);\n+  column = print_ents (targets, 0);\n+  fputs (\" : \", dep_out);\n+\n+  print_ents (dependencies, column);\n+  fputs (\"\\n\", dep_out);\n+  fflush (dep_out);\n+}"}, {"sha": "25243228bffb19cd43e007991d29514c867d8bc6", "filename": "gcc/java/jcf-dump.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc45c7efec9457a616b27caab813322c93481b9d/gcc%2Fjava%2Fjcf-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc45c7efec9457a616b27caab813322c93481b9d/gcc%2Fjava%2Fjcf-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-dump.c?ref=fc45c7efec9457a616b27caab813322c93481b9d", "patch": "@@ -793,9 +793,9 @@ DEFUN(main, (argc, argv),\n     {\n       fprintf (out, \"Reading .class from <standard input>.\\n\");\n #if JCF_USE_STDIO\n-      open_class (\"<stdio>\", jcf, stdin);\n+      open_class (\"<stdio>\", jcf, stdin, NULL);\n #else\n-      open_class (\"<stdio>\", jcf, 0);\n+      open_class (\"<stdio>\", jcf, 0, NULL);\n #endif\n       process_class (jcf);\n     }\n@@ -806,7 +806,7 @@ DEFUN(main, (argc, argv),\n \t  char *arg = argv[argi];\n \t  char* class_filename = find_class (arg, strlen (arg), jcf, 1);\n \t  if (class_filename == NULL)\n-\t    class_filename = find_classfile (arg, jcf);\n+\t    class_filename = find_classfile (arg, jcf, NULL);\n \t  if (class_filename == NULL)\n \t    {\n \t      perror (\"Could not find class\");"}, {"sha": "95ddd0d066d0515102977bb7a2e3cae7a2cc7910", "filename": "gcc/java/jcf-io.c", "status": "modified", "additions": 39, "deletions": 12, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc45c7efec9457a616b27caab813322c93481b9d/gcc%2Fjava%2Fjcf-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc45c7efec9457a616b27caab813322c93481b9d/gcc%2Fjava%2Fjcf-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-io.c?ref=fc45c7efec9457a616b27caab813322c93481b9d", "patch": "@@ -1,5 +1,5 @@\n /* Utility routines for finding and reading Java(TM) .class files.\n-   Copyright (C) 1996  Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1998  Free Software Foundation, Inc.\n \n This program is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n@@ -108,6 +108,7 @@ zipfile, zipmember),\n \t{\n \t  char magic [4];\n \t  int fd = open (zipfile, O_RDONLY | O_BINARY);\n+\t  jcf_dependency_add_file (zipfile, 0);\t/* FIXME: system file? */\n \t  if (read (fd, magic, 4) != 4 || GET_u4 (magic) != (JCF_u4)ZIPMAGIC)\n \t    return -1;\n \t  lseek (fd, 0L, SEEK_SET);\n@@ -168,11 +169,13 @@ zipfile, zipmember),\n \n #if JCF_USE_STDIO\n char*\n-DEFUN(open_class, (filename, jcf, stream),\n-      char *filename AND JCF *jcf AND FILE* stream)\n+DEFUN(open_class, (filename, jcf, stream, dep_name),\n+      char *filename AND JCF *jcf AND FILE* stream AND char *dep_name)\n {\n   if (jcf)\n     {\n+      if (dep_name != NULL)\n+\tjcf_dependency_add_file (dep_name, 0);\n       JCF_ZERO (jcf);\n       jcf->buffer = NULL;\n       jcf->buffer_end = NULL;\n@@ -187,8 +190,8 @@ DEFUN(open_class, (filename, jcf, stream),\n }\n #else\n char*\n-DEFUN(open_class, (filename, jcf, fd),\n-      char *filename AND JCF *jcf AND int fd)\n+DEFUN(open_class, (filename, jcf, fd, dep_name),\n+      char *filename AND JCF *jcf AND int fd AND char *dep_name)\n {\n   if (jcf)\n     {\n@@ -199,6 +202,8 @@ DEFUN(open_class, (filename, jcf, fd),\n \t  perror (\"Could not figure length of .class file\");\n \t  return NULL;\n \t}\n+      if (dep_name != NULL)\n+\tjcf_dependency_add_file (dep_name, 0);\n       JCF_ZERO (jcf);\n       jcf->buffer = ALLOC (stat_buf.st_size);\n       jcf->buffer_end = jcf->buffer + stat_buf.st_size;\n@@ -222,19 +227,19 @@ DEFUN(open_class, (filename, jcf, fd),\n \n \n char *\n-DEFUN(find_classfile, (filename, jcf),\n-      char *filename AND JCF *jcf)\n+DEFUN(find_classfile, (filename, jcf, dep_name),\n+      char *filename AND JCF *jcf AND char *dep_name)\n {\n #if JCF_USE_STDIO\n   FILE *stream = fopen (filename, \"rb\");\n   if (stream == NULL)\n     return NULL;\n-  return open_class (arg, jcf, stream);\n+  return open_class (arg, jcf, stream, dep_name);\n #else\n   int fd = open (filename, O_RDONLY | O_BINARY);\n   if (fd < 0)\n     return NULL;\n-  return open_class (filename, jcf, fd);\n+  return open_class (filename, jcf, fd, dep_name);\n #endif\n }\n \n@@ -257,13 +262,28 @@ DEFUN(find_class, (classname, classname_length, jcf, do_class_file),\n #endif\n   int i, j, k, java, class;\n   struct stat java_buf, class_buf;\n+  char *dep_file;\n+\n+  /* A temporary buffer that we grow to be large enough to hold\n+     whatever class name we're working on.  */\n+  static int temp_len = 0;\n+  static char *temp_buffer = NULL;\n \n   /* Allocate and zero out the buffer, since we don't explicitly put a\n      null pointer when we're copying it below.  */\n   int buflen = strlen (classpath) + classname_length + 10;\n   char *buffer = (char *) ALLOC (buflen);\n   bzero (buffer, buflen);\n \n+  if (buflen > temp_len)\n+    {\n+      temp_len = buflen;\n+      if (temp_buffer == NULL)\n+\ttemp_buffer = (char *) ALLOC (temp_len);\n+      else\n+\ttemp_buffer = (char *) REALLOC (temp_buffer, temp_len);\n+    }\n+\n   jcf->java_source = jcf->outofsynch = 0;\n   for (j = 0; classpath[j] != '\\0'; )\n     {\n@@ -331,13 +351,20 @@ DEFUN(find_class, (classname, classname_length, jcf, do_class_file),\n \t\t  goto found;\n \t\t}\n \t    }\n-\t  \n+\n \t  /* Check for out of synch .class/.java files */\n \t  class = stat (buffer, &class_buf);\n \t  strcpy (buffer+i, \".java\");\n+\t  /* Stash the name of the .java file in the temp buffer.  */\n+\t  strcpy (temp_buffer, buffer);\n \t  java = stat (buffer, &java_buf);\n \t  if ((!java && !class) && java_buf.st_mtime >= class_buf.st_mtime)\n \t    jcf->outofsynch = 1;\n+\n+\t  if (! java)\n+\t    dep_file = temp_buffer;\n+\t  else\n+\t    dep_file = buffer;\n #if JCF_USE_STDIO\n \t  if (!class)\n \t    {\n@@ -391,7 +418,7 @@ DEFUN(find_class, (classname, classname_length, jcf, do_class_file),\n   if (jcf->java_source)\n     return NULL;\t\t/* FIXME */\n   else\n-    return open_class (buffer, jcf, stream);\n+    return open_class (buffer, jcf, stream, dep_file);\n #else\n   if (jcf->java_source)\n     {\n@@ -401,7 +428,7 @@ DEFUN(find_class, (classname, classname_length, jcf, do_class_file),\n       close (fd);\t\t/* We use STDIO for source file */\n     }\n   else if (do_class_file)\n-    buffer = open_class (buffer, jcf, fd);\n+    buffer = open_class (buffer, jcf, fd, dep_file);\n   jcf->classname = (char *) ALLOC (classname_length + 1);\n   strncpy (jcf->classname, classname, classname_length + 1);\n   jcf->classname = (char *) strdup (classname);"}, {"sha": "2fb1008fa081d240348d862472c018282737041d", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc45c7efec9457a616b27caab813322c93481b9d/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc45c7efec9457a616b27caab813322c93481b9d/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=fc45c7efec9457a616b27caab813322c93481b9d", "patch": "@@ -1870,6 +1870,7 @@ write_classfile (clas)\n   FILE* stream = fopen (class_file_name, \"wb\");\n   if (stream == NULL)\n     fatal (\"failed to open `%s' for writing\", class_file_name);\n+  jcf_dependency_add_target (class_file_name);\n   init_jcf_state (state, work);\n   chunks = generate_classfile (clas, state);\n   write_chunks (stream, chunks);"}, {"sha": "f88ff1041c7dff94dd701a03976965155dbd00c2", "filename": "gcc/java/jcf.h", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc45c7efec9457a616b27caab813322c93481b9d/gcc%2Fjava%2Fjcf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc45c7efec9457a616b27caab813322c93481b9d/gcc%2Fjava%2Fjcf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf.h?ref=fc45c7efec9457a616b27caab813322c93481b9d", "patch": "@@ -1,6 +1,6 @@\n /* Utility macros to read Java(TM) .class files and byte codes.\n \n-   Copyright (C) 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1998 Free Software Foundation, Inc.\n \n This program is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n@@ -226,7 +226,7 @@ extern char *classpath;\n #define DEFAULT_CLASS_PATH \".\"\n \n extern char *find_class PROTO ((const char *, int, JCF*, int));\n-extern char *find_classfile PROTO ((char *, JCF*));\n+extern char *find_classfile PROTO ((char *, JCF*, char *));\n extern int jcf_filbuf_from_stdio PROTO ((JCF *jcf, int count));\n extern void jcf_out_of_synch PROTO((JCF *));\n extern int jcf_unexpected_eof PROTO ((JCF*, int));\n@@ -257,4 +257,13 @@ extern int quiet_flag;\n #define SOURCE_FRONTEND_DEBUG(X)\n #endif\n \n+/* Declarations for dependency code.  */\n+extern void jcf_dependency_reset PROTO ((void));\n+extern void jcf_dependency_set_target PROTO ((char *));\n+extern void jcf_dependency_add_target PROTO ((char *));\n+extern void jcf_dependency_set_dep_file PROTO ((char *));\n+extern void jcf_dependency_add_file PROTO ((const char *, int));\n+extern void jcf_dependency_write PROTO ((void));\n+extern void jcf_dependency_init PROTO ((int));\n+\n #endif"}, {"sha": "622b3ed6e729d7ee74f785692e83ee35f0befd78", "filename": "gcc/java/lang-options.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc45c7efec9457a616b27caab813322c93481b9d/gcc%2Fjava%2Flang-options.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc45c7efec9457a616b27caab813322c93481b9d/gcc%2Fjava%2Flang-options.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang-options.h?ref=fc45c7efec9457a616b27caab813322c93481b9d", "patch": "@@ -36,3 +36,7 @@ DEFINE_LANG_NAME (\"Java\")\n   { \"-fno-assume-compiled\", \"\" },\n   { \"-femit-class-file\", \"\" },\n   { \"-femit-class-files\", \"Dump class files to <name>.class\" },\n+  { \"-MD\", \"Print dependencies to FILE.d\" },\n+  { \"-MMD\", \"Print dependencies to FILE.d\" },\n+  { \"-M\", \"Print dependencies to stdout\" },\n+  { \"-MM\", \"Print dependencies to stdout\" },"}, {"sha": "6a455dbc9033b549605ac020f93c56ac0c1cb22e", "filename": "gcc/java/lang-specs.h", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc45c7efec9457a616b27caab813322c93481b9d/gcc%2Fjava%2Flang-specs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc45c7efec9457a616b27caab813322c93481b9d/gcc%2Fjava%2Flang-specs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang-specs.h?ref=fc45c7efec9457a616b27caab813322c93481b9d", "patch": "@@ -1,5 +1,5 @@\n /* Definitions for specs for the GNU compiler for the Java(TM) language.\n-   Copyright (C) 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -27,12 +27,13 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n   {\".java\",   \"@java\" },\n   {\".class\",  \"@java\" },\n   {\"@java\",\n-   \"%{!M:%{!MM:%{!E:jc1 %i %1 %2 %{!Q:-quiet} %{d*} %{m*} %{a}\\\n-\t\t\t    %{g*} %{O*} %{W*} %{w} %{pedantic*} %{ansi}\\\n-\t\t\t    %{traditional} %{v:-version} %{pg:-p} %{p}\\\n-\t\t\t    %{f*} %{+e*} %{aux-info*}\\\n-\t\t\t    %{pg:%{fomit-frame-pointer:%e-pg and -fomit-frame-pointer are incompatible}}\\\n-\t\t\t    %{S:%W{o*}%{!o*:-o %b.s}}%{!S:-o %{|!pipe:%g.s}} |\\n\\\n-\t            %{!S:as %a %Y\\\n-\t\t\t    %{c:%W{o*}%{!o*:-o %w%b%O}}%{!c:-o %d%w%u%O}\\\n-\t\t\t    %{!pipe:%g.s} %A\\n }}}}\"},\n+   \"%{!E:jc1 %i %1 %2 %{!Q:-quiet} %{d*} %{m*} %{a}\\\n+\t\t    %{g*} %{O*} %{W*} %{w} %{pedantic*} %{ansi}\\\n+\t\t    %{traditional} %{v:-version} %{pg:-p} %{p}\\\n+\t\t    %{f*} %{+e*} %{aux-info*}\\\n+\t\t    %{MD:-MD} %{MMD:-MMD} %{M:-M} %{MM:-MM}\\\n+\t\t    %{pg:%{fomit-frame-pointer:%e-pg and -fomit-frame-pointer are incompatible}}\\\n+\t\t    %{S:%W{o*}%{!o*:-o %b.s}}%{!S:-o %{|!pipe:%g.s}} |\\n\\\n+            %{!S:as %a %Y\\\n+\t\t    %{c:%W{o*}%{!o*:-o %w%b%O}}%{!c:-o %d%w%u%O}\\\n+\t\t    %{!pipe:%g.s} %A\\n }}\"},"}, {"sha": "3b1593c4b75c629b8ccf55657282dd4fef439f7e", "filename": "gcc/java/lang.c", "status": "modified", "additions": 77, "deletions": 1, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc45c7efec9457a616b27caab813322c93481b9d/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc45c7efec9457a616b27caab813322c93481b9d/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=fc45c7efec9457a616b27caab813322c93481b9d", "patch": "@@ -31,6 +31,7 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"java-tree.h\"\n #include \"jcf.h\"\n #include \"toplev.h\"\n+#include \"flags.h\"\n \n /* Table indexed by tree code giving a string containing a character\n    classifying the tree code.  Possibilities are\n@@ -104,6 +105,14 @@ static struct { char *string; int *variable; int on_value;} lang_f_options[] =\n JCF main_jcf[1];\n JCF *current_jcf;\n \n+/* Variable controlling how dependency tracking is enabled in\n+   init_parse.  */\n+static int dependency_tracking = 0;\n+\n+/* Flag values for DEPENDENCY_TRACKING.  */\n+#define DEPEND_SET_FILE 1\n+#define DEPEND_ENABLE   2\n+\n /*\n  * process java-specific compiler command-line options\n  */\n@@ -140,9 +149,35 @@ lang_decode_option (argc, argv)\n \t      found = 1;\n \t    }\n \t}\n+\n       return found;\n     }\n \n+  if (strcmp (p, \"-MD\") == 0)\n+    {\n+      jcf_dependency_init (1);\n+      dependency_tracking |= DEPEND_SET_FILE | DEPEND_ENABLE;\n+      return 1;\n+    }\n+  else if (strcmp (p, \"-MMD\") == 0)\n+    {\n+      jcf_dependency_init (0);\n+      dependency_tracking |= DEPEND_SET_FILE | DEPEND_ENABLE;\n+      return 1;\n+    }\n+  else if (strcmp (p, \"-M\") == 0)\n+    {\n+      jcf_dependency_init (1);\n+      dependency_tracking |= DEPEND_ENABLE;\n+      return 1;\n+    }\n+  else if (strcmp (p, \"-MM\") == 0)\n+    {\n+      jcf_dependency_init (0);\n+      dependency_tracking |= DEPEND_ENABLE;\n+      return 1;\n+    }\n+\n   return 0;\n }\n \n@@ -157,9 +192,49 @@ init_parse (filename)\n     {\n       finput = stdin;\n       filename = \"stdin\";\n+\n+      if (dependency_tracking)\n+\terror (\"can't do dependency tracking with input from stdin\");\n     }\n   else\n-    finput = fopen (filename, \"r\");\n+    {\n+      if (dependency_tracking)\n+\t{\n+\t  char *dot;\n+\t  dot = strrchr (filename, '.');\n+\t  if (dot == NULL)\n+\t    error (\"couldn't determine target name for dependency tracking\");\n+\t  else\n+\t    {\n+\t      char *buf = (char *) xmalloc (dot - filename + 3);\n+\t      strncpy (buf, filename, dot - filename);\n+\n+\t      /* If emitting class files, we might have multiple\n+\t\t targets.  The class generation code takes care of\n+\t\t registering them.  Otherwise we compute the target\n+\t\t name here.  */\n+\t      if (flag_emit_class_files)\n+\t\tjcf_dependency_set_target (NULL);\n+\t      else\n+\t\t{\n+\t\t  strcpy (buf + (dot - filename), \".o\");\n+\t\t  jcf_dependency_set_target (buf);\n+\t\t}\n+\n+\t      if ((dependency_tracking & DEPEND_SET_FILE))\n+\t\t{\n+\t\t  strcpy (buf + (dot - filename), \".d\");\n+\t\t  jcf_dependency_set_dep_file (buf);\n+\t\t}\n+\t      else\n+\t\tjcf_dependency_set_dep_file (\"-\");\n+\n+\t      free (buf);\n+\t    }\n+\t}\n+\n+      finput = fopen (filename, \"r\");\n+    }\n   if (finput == 0)\n     pfatal_with_name (filename);\n \n@@ -175,6 +250,7 @@ void\n finish_parse ()\n {\n   fclose (finput);\n+  jcf_dependency_write ();\n }\n \n /* Buffer used by lang_printable_name. */"}]}