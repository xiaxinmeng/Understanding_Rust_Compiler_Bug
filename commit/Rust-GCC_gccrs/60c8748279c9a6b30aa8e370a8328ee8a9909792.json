{"sha": "60c8748279c9a6b30aa8e370a8328ee8a9909792", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjBjODc0ODI3OWM5YTZiMzBhYThlMzcwYTgzMjhlZThhOTkwOTc5Mg==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@albatross.co.nz", "date": "2001-03-23T01:49:11Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2001-03-23T01:49:11Z"}, "message": "[multiple changes]\n\n2001-03-23  Bryce McKinlay  <bryce@albatross.co.nz>\n\n\t* extend.texi: Document the \"java_interface\" attribute.\n\njava/:\n2001-03-21  Bryce McKinlay  <bryce@albatross.co.nz>\n\n\t* gjavah.c (process_file): Mark interface definitions with\n\t\"__attribute__ ((java_interface))\".\n\ncp/:\n2001-03-22  Bryce McKinlay  <bryce@albatross.co.nz>\n\n\tAdd support for Java interface method calls.\n\t* cp-tree.h (struct lang_type): Add java_interface flag.\n\t(TYPE_JAVA_INTERFACE): New macro.\n\t* tree.c (cp_valid_lang_attribute): Handle \"java_interface\" attribute\n\tby setting TYPE_JAVA_INTERFACE.\n\t* call.c (java_iface_lookup_fn): New static.\n\t(build_over_call): If calling a method declared in a\n\tTYPE_JAVA_INTERFACE, call build_java_interface_fn_ref to generate the\n\texpression which resolves the function address.\n\t(build_java_interface_fn_ref): New function.\n\nFrom-SVN: r40769", "tree": {"sha": "a8d88ecaa8d7079c04633b077af8f67b170c519a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a8d88ecaa8d7079c04633b077af8f67b170c519a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/60c8748279c9a6b30aa8e370a8328ee8a9909792", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60c8748279c9a6b30aa8e370a8328ee8a9909792", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60c8748279c9a6b30aa8e370a8328ee8a9909792", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60c8748279c9a6b30aa8e370a8328ee8a9909792/comments", "author": null, "committer": null, "parents": [{"sha": "9450a9295bd532eebb8f814a7f9a40f4958ea57a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9450a9295bd532eebb8f814a7f9a40f4958ea57a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9450a9295bd532eebb8f814a7f9a40f4958ea57a"}], "stats": {"total": 129, "additions": 126, "deletions": 3}, "files": [{"sha": "e733bfd5e8c686beaf65f9672c3c095f3bb9c333", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60c8748279c9a6b30aa8e370a8328ee8a9909792/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60c8748279c9a6b30aa8e370a8328ee8a9909792/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=60c8748279c9a6b30aa8e370a8328ee8a9909792", "patch": "@@ -1,3 +1,7 @@\n+2001-03-23  Bryce McKinlay  <bryce@albatross.co.nz>\n+\n+\t* extend.texi: Document the \"java_interface\" attribute.\n+\n 2001-03-22  Zack Weinberg  <zackw@stanford.edu>\n \n \t* mkconfig.sh: Use a subshell with redirected stdout,"}, {"sha": "e85d6b8529025c8bdf62c5552aa1ce94c996d295", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60c8748279c9a6b30aa8e370a8328ee8a9909792/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60c8748279c9a6b30aa8e370a8328ee8a9909792/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=60c8748279c9a6b30aa8e370a8328ee8a9909792", "patch": "@@ -1,3 +1,16 @@\n+2001-03-22  Bryce McKinlay  <bryce@albatross.co.nz>\n+\n+\tAdd support for Java interface method calls.\n+\t* cp-tree.h (struct lang_type): Add java_interface flag.\n+\t(TYPE_JAVA_INTERFACE): New macro.\n+\t* tree.c (cp_valid_lang_attribute): Handle \"java_interface\" attribute\n+\tby setting TYPE_JAVA_INTERFACE.\n+\t* call.c (java_iface_lookup_fn): New static.\n+\t(build_over_call): If calling a method declared in a \n+\tTYPE_JAVA_INTERFACE, call build_java_interface_fn_ref to generate the\n+\texpression which resolves the function address.\n+\t(build_java_interface_fn_ref): New function.\n+\n 2001-03-22  Richard Henderson  <rth@redhat.com>\n \n \t* Make-lang.in (cp/except.o): Don't depend on insn-flags.h."}, {"sha": "0850f9b80488a73f4b8dc194d458841093f60986", "filename": "gcc/cp/call.c", "status": "modified", "additions": 71, "deletions": 1, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60c8748279c9a6b30aa8e370a8328ee8a9909792/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60c8748279c9a6b30aa8e370a8328ee8a9909792/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=60c8748279c9a6b30aa8e370a8328ee8a9909792", "patch": "@@ -45,6 +45,7 @@ static int equal_functions PARAMS ((tree, tree));\n static int joust PARAMS ((struct z_candidate *, struct z_candidate *, int));\n static int compare_ics PARAMS ((tree, tree));\n static tree build_over_call PARAMS ((struct z_candidate *, tree, int));\n+static tree build_java_interface_fn_ref PARAMS ((tree, tree));\n #define convert_like(CONV, EXPR) convert_like_real (CONV, EXPR, NULL_TREE, 0, 0)\n #define convert_like_with_context(CONV, EXPR, FN, ARGNO) convert_like_real (CONV, EXPR, FN, ARGNO, 0)\n static tree convert_like_real PARAMS ((tree, tree, tree, int, int));\n@@ -4271,7 +4272,10 @@ build_over_call (cand, args, flags)\n       if (TREE_SIDE_EFFECTS (*p))\n \t*p = save_expr (*p);\n       t = build_pointer_type (TREE_TYPE (fn));\n-      fn = build_vfn_ref (p, build_indirect_ref (*p, 0), DECL_VINDEX (fn));\n+      if (DECL_CONTEXT (fn) && TYPE_JAVA_INTERFACE (DECL_CONTEXT (fn)))\n+\tfn = build_java_interface_fn_ref (fn, *p);\n+      else\n+\tfn = build_vfn_ref (p, build_indirect_ref (*p, 0), DECL_VINDEX (fn));\n       TREE_TYPE (fn) = t;\n     }\n   else if (DECL_INLINE (fn))\n@@ -4306,6 +4310,72 @@ build_over_call (cand, args, flags)\n   return convert_from_reference (fn);\n }\n \n+static tree java_iface_lookup_fn;\n+\n+/* Make an expression which yields the address of the Java interface\n+   method FN.  This is achieved by generating a call to libjava's\n+   _Jv_LookupInterfaceMethodIdx().  */\n+\n+static tree\n+build_java_interface_fn_ref (fn, instance)\n+    tree fn, instance;\n+{\n+  tree lookup_args, lookup_fn, method, idx;\n+  tree klass_ref, iface, iface_ref;\n+  int i;\n+  \n+  if (!java_iface_lookup_fn)\n+    {\n+      tree endlink = build_void_list_node ();\n+      tree t = tree_cons (NULL_TREE, ptr_type_node,\n+\t\t\t  tree_cons (NULL_TREE, ptr_type_node,\n+\t\t\t\t     tree_cons (NULL_TREE, java_int_type_node,\n+\t\t\t\t\t\tendlink)));\n+      java_iface_lookup_fn \n+\t= builtin_function (\"_Jv_LookupInterfaceMethodIdx\",\n+\t\t\t    build_function_type (ptr_type_node, t),\n+\t\t\t    0, NOT_BUILT_IN, NULL_PTR);\n+      ggc_add_tree_root (&java_iface_lookup_fn, 1);\n+    }\n+\n+  /* Look up the pointer to the runtime java.lang.Class object for `instance'. \n+     This is the first entry in the vtable. */\n+  klass_ref = build_vtbl_ref (build_indirect_ref (instance, 0), \n+\t\t\t      integer_zero_node);\n+\n+  /* Get the java.lang.Class pointer for the interface being called. */\n+  iface = DECL_CONTEXT (fn);\n+  iface_ref = lookup_field (iface, get_identifier (\"class$\"), 0, 0);\n+  if (!iface_ref || TREE_CODE (iface_ref) != VAR_DECL\n+      || DECL_CONTEXT (iface_ref) != iface)\n+    {\n+      cp_error (\"Could not find class$ field in java interface type `%T'\", \n+\t\tiface);\n+      return error_mark_node;\n+    }\n+  iface_ref = build1 (ADDR_EXPR, build_pointer_type (iface), iface_ref);\n+  \n+  /* Determine the itable index of FN. */\n+  i = 1;\n+  for (method = TYPE_METHODS (iface); method; method = TREE_CHAIN (method))\n+    {\n+      if (!DECL_VIRTUAL_P (method))\n+        continue;\n+      if (fn == method)\n+        break;\n+      i++;\n+    }\n+  idx = build_int_2 (i, 0);\n+\n+  lookup_args = tree_cons (NULL_TREE, klass_ref, \n+\t\t\t   tree_cons (NULL_TREE, iface_ref,\n+\t\t\t\t      build_tree_list (NULL_TREE, idx)));\n+  lookup_fn = build1 (ADDR_EXPR, \n+\t\t      build_pointer_type (TREE_TYPE (java_iface_lookup_fn)),\n+\t\t      java_iface_lookup_fn);\n+  return build (CALL_EXPR, ptr_type_node, lookup_fn, lookup_args, NULL_TREE);\n+}\n+\n /* Returns the value to use for the in-charge parameter when making a\n    call to a function with the indicated NAME.  */\n "}, {"sha": "f8dd6928f34b1f42c1996f5c8d9e59512eed4fe8", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60c8748279c9a6b30aa8e370a8328ee8a9909792/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60c8748279c9a6b30aa8e370a8328ee8a9909792/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=60c8748279c9a6b30aa8e370a8328ee8a9909792", "patch": "@@ -1326,6 +1326,7 @@ struct lang_type\n   unsigned has_abstract_assign_ref : 1;\n   unsigned non_aggregate : 1;\n   unsigned is_partial_instantiation : 1;\n+  unsigned java_interface : 1;\n \n   /* When adding a flag here, consider whether or not it ought to\n      apply to a template instance if it applies to the template.  If\n@@ -1334,7 +1335,7 @@ struct lang_type\n   /* There are some bits left to fill out a 32-bit word.  Keep track\n      of this by updating the size of this bitfield whenever you add or\n      remove a flag.  */\n-  unsigned dummy : 9;\n+  unsigned dummy : 8;\n \n   int vsize;\n \n@@ -1556,6 +1557,10 @@ struct lang_type\n #define CLASSTYPE_ALIGN_UNIT(NODE) \\\n   (CLASSTYPE_ALIGN (NODE) / BITS_PER_UNIT)\n \n+/* True if this a Java interface type, declared with \n+   '__attribute__ ((java_interface))'. */\n+#define TYPE_JAVA_INTERFACE(NODE) (TYPE_LANG_SPECIFIC(NODE)->java_interface)\n+\n /* A cons list of virtual functions which cannot be inherited by\n    derived classes.  When deriving from this type, the derived\n    class must provide its own definition for each of these functions.  */"}, {"sha": "3023e8fbf2ffa3ac99a3f1df3d8697b6375ebe0d", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60c8748279c9a6b30aa8e370a8328ee8a9909792/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60c8748279c9a6b30aa8e370a8328ee8a9909792/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=60c8748279c9a6b30aa8e370a8328ee8a9909792", "patch": "@@ -2212,6 +2212,19 @@ cp_valid_lang_attribute (attr_name, attr_args, decl, type)\n   tree decl ATTRIBUTE_UNUSED;\n   tree type ATTRIBUTE_UNUSED;\n {\n+  if (is_attribute_p (\"java_interface\", attr_name))\n+    {\n+      if (attr_args != NULL_TREE\n+\t  || decl != NULL_TREE\n+\t  || ! CLASS_TYPE_P (type)\n+\t  || ! TYPE_FOR_JAVA (type))\n+\t{\n+\t  error (\"`java_interface' attribute can only be applied to Java class definitions\");\n+\t  return 0;\n+\t}\n+      TYPE_JAVA_INTERFACE (type) = 1;\n+      return 1;\n+    }\n   if (is_attribute_p (\"com_interface\", attr_name))\n     {\n       if (! flag_vtable_thunks)"}, {"sha": "49fe3192d5276f186aacebce51b44293d1327801", "filename": "gcc/extend.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60c8748279c9a6b30aa8e370a8328ee8a9909792/gcc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60c8748279c9a6b30aa8e370a8328ee8a9909792/gcc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fextend.texi?ref=60c8748279c9a6b30aa8e370a8328ee8a9909792", "patch": "@@ -4355,6 +4355,14 @@ changed to be COM-compliant.  Also, all classes and structs derived from one\n marked with this attribute are implicitly marked with the same attribute;\n thus, only the base class in a COM hierarchy needs @code{com_interface}.\n \n+@item java_interface\n+@cindex java_interface attribute\n+\n+This type attribute informs C++ that the class is a Java interface.  It may \n+only be applied to classes declared within an @code{extern \"Java\"} block.\n+Calls to methods declared in this interface will be dispatched using GCJ's \n+interface table mechanism, instead of regular virtual table dispatch.  \n+\n @end table\n \n @node Deprecated Features"}, {"sha": "d7d0e77a43c1c29cb0ae1370e21ecce4cf4fbbf5", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60c8748279c9a6b30aa8e370a8328ee8a9909792/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60c8748279c9a6b30aa8e370a8328ee8a9909792/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=60c8748279c9a6b30aa8e370a8328ee8a9909792", "patch": "@@ -1,3 +1,8 @@\n+2001-03-21  Bryce McKinlay  <bryce@albatross.co.nz>\n+\n+\t* gjavah.c (process_file): Mark interface definitions with \n+\t\"__attribute__ ((java_interface))\".\n+\n 2001-03-21  Alexandre Petit-Bianco  <apbianco@redhat.com>\n \n \t* class.c (layout_class): Fixed push_super_field's second"}, {"sha": "7f6084955a129814e7cbcd47b4145e64694dd558", "filename": "gcc/java/gjavah.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60c8748279c9a6b30aa8e370a8328ee8a9909792/gcc%2Fjava%2Fgjavah.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60c8748279c9a6b30aa8e370a8328ee8a9909792/gcc%2Fjava%2Fgjavah.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fgjavah.c?ref=60c8748279c9a6b30aa8e370a8328ee8a9909792", "patch": "@@ -1857,7 +1857,12 @@ DEFUN(process_file, (jcf, out),\n \t  generate_access (out, ACC_PUBLIC);\n \t  fprintf (out, \"\\n  static ::java::lang::Class class$;\\n\");\n \n-\t  fputs (\"};\\n\", out);\n+\t  fputs (\"}\", out);\n+\t  \n+\t  if (jcf->access_flags & ACC_INTERFACE)\n+\t    fputs (\" __attribute__ ((java_interface))\", out);\n+\n+\t  fputs (\";\\n\", out);\n \n \t  if (append_count > 0)\n \t    fputc ('\\n', out);"}]}