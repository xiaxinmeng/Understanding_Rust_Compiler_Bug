{"sha": "9eb1ca69e1ebd98cc8e401b5ae271b988e3ab84a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWViMWNhNjllMWViZDk4Y2M4ZTQwMWI1YWUyNzFiOTg4ZTNhYjg0YQ==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2016-01-29T18:47:17Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2016-01-29T18:47:17Z"}, "message": "re PR target/69299 (-mavx performance degradation with r232088)\n\n2016-01-29  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR target/69299\n\t* config/i386/constraints.md (Bm): Describe as special memory\n\tconstraint.\n\t* doc/md.texi (DEFINE_SPECIAL_MEMORY_CONSTRAINT): Describe it.\n\t* genoutput.c (main): Process DEFINE_SPECIAL_MEMORY_CONSTRAINT.\n\t* genpreds.c (struct constraint_data): Add is_special_memory.\n\t(have_special_memory_constraints, special_memory_start): New\n\tstatic vars.\n\t(special_memory_end): Ditto.\n\t(add_constraint): Add new arg is_special_memory.  Add code to\n\tprocess its true value.  Update have_special_memory_constraints.\n\t(process_define_constraint): Pass the new arg.\n\t(process_define_register_constraint): Ditto.\n\t(choose_enum_order): Process special memory.\n\t(write_tm_preds_h): Generate enum const CT_SPECIAL_MEMORY and\n\tfunction insn_extra_special_memory_constraint.\n\t(main): Process DEFINE_SPECIAL_MEMORY_CONSTRAINT.\n\t* gensupport.c (process_rtx): Process\n\tDEFINE_SPECIAL_MEMORY_CONSTRAINT.\n\t* ira-costs.c (record_reg_classes): Process CT_SPECIAL_MEMORY.\n\t* ira-lives.c (single_reg_class): Use\n\tinsn_extra_special_memory_constraint.\n\t* ira.c (ira_setup_alts): Process CT_SPECIAL_MEMORY.\n\t* lra-constraints.c (process_alt_operands): Ditto.\n\t(curr_insn_transform): Use insn_extra_special_memory_constraint.\n\t* recog.c (asm_operand_ok, preprocess_constraints): Process\n\tCT_SPECIAL_MEMORY.\n\t* reload.c (find_reloads): Ditto.\n\t* rtl.def (DEFINE_SPECIFAL_MEMORY_CONSTRAINT): New.\n\t* stmt.c (parse_input_constraint): Use\n\tinsn_extra_special_memory_constraint.\n\nFrom-SVN: r232993", "tree": {"sha": "f72efae70813e3fdbe36d5a4563ab3bf55869ca0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f72efae70813e3fdbe36d5a4563ab3bf55869ca0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9eb1ca69e1ebd98cc8e401b5ae271b988e3ab84a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9eb1ca69e1ebd98cc8e401b5ae271b988e3ab84a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9eb1ca69e1ebd98cc8e401b5ae271b988e3ab84a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9eb1ca69e1ebd98cc8e401b5ae271b988e3ab84a/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6bbacdb54436ea71d77f70f625c4a97f5c245329", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bbacdb54436ea71d77f70f625c4a97f5c245329", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bbacdb54436ea71d77f70f625c4a97f5c245329"}], "stats": {"total": 170, "additions": 147, "deletions": 23}, "files": [{"sha": "2919b8134ef677eba87a4d295cd09f8313302d43", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb1ca69e1ebd98cc8e401b5ae271b988e3ab84a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb1ca69e1ebd98cc8e401b5ae271b988e3ab84a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9eb1ca69e1ebd98cc8e401b5ae271b988e3ab84a", "patch": "@@ -1,3 +1,37 @@\n+2016-01-29  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR target/69299\n+\t* config/i386/constraints.md (Bm): Describe as special memory\n+\tconstraint.\n+\t* doc/md.texi (DEFINE_SPECIAL_MEMORY_CONSTRAINT): Describe it.\n+\t* genoutput.c (main): Process DEFINE_SPECIAL_MEMORY_CONSTRAINT.\n+\t* genpreds.c (struct constraint_data): Add is_special_memory.\n+\t(have_special_memory_constraints, special_memory_start): New\n+\tstatic vars.\n+\t(special_memory_end): Ditto.\n+\t(add_constraint): Add new arg is_special_memory.  Add code to\n+\tprocess its true value.  Update have_special_memory_constraints.\n+\t(process_define_constraint): Pass the new arg.\n+\t(process_define_register_constraint): Ditto.\n+\t(choose_enum_order): Process special memory.\n+\t(write_tm_preds_h): Generate enum const CT_SPECIAL_MEMORY and\n+\tfunction insn_extra_special_memory_constraint.\n+\t(main): Process DEFINE_SPECIAL_MEMORY_CONSTRAINT.\n+\t* gensupport.c (process_rtx): Process\n+\tDEFINE_SPECIAL_MEMORY_CONSTRAINT.\n+\t* ira-costs.c (record_reg_classes): Process CT_SPECIAL_MEMORY.\n+\t* ira-lives.c (single_reg_class): Use\n+\tinsn_extra_special_memory_constraint.\n+\t* ira.c (ira_setup_alts): Process CT_SPECIAL_MEMORY.\n+\t* lra-constraints.c (process_alt_operands): Ditto.\n+\t(curr_insn_transform): Use insn_extra_special_memory_constraint.\n+\t* recog.c (asm_operand_ok, preprocess_constraints): Process\n+\tCT_SPECIAL_MEMORY.\n+\t* reload.c (find_reloads): Ditto.\n+\t* rtl.def (DEFINE_SPECIFAL_MEMORY_CONSTRAINT): New.\n+\t* stmt.c (parse_input_constraint): Use\n+\tinsn_extra_special_memory_constraint.\n+\n 2016-01-29  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/69530"}, {"sha": "afdc546c065a4a6a03ad537a79c337e13231ebf8", "filename": "gcc/config/i386/constraints.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb1ca69e1ebd98cc8e401b5ae271b988e3ab84a/gcc%2Fconfig%2Fi386%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb1ca69e1ebd98cc8e401b5ae271b988e3ab84a/gcc%2Fconfig%2Fi386%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fconstraints.md?ref=9eb1ca69e1ebd98cc8e401b5ae271b988e3ab84a", "patch": "@@ -162,7 +162,7 @@\n   \"@internal GOT memory operand.\"\n   (match_operand 0 \"GOT_memory_operand\"))\n \n-(define_constraint \"Bm\"\n+(define_special_memory_constraint \"Bm\"\n   \"@internal Vector memory operand.\"\n   (match_operand 0 \"vector_memory_operand\"))\n "}, {"sha": "864824f2f0dbb0440317a81848d9aff0414bc6f2", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb1ca69e1ebd98cc8e401b5ae271b988e3ab84a/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb1ca69e1ebd98cc8e401b5ae271b988e3ab84a/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=9eb1ca69e1ebd98cc8e401b5ae271b988e3ab84a", "patch": "@@ -4424,6 +4424,20 @@ The syntax and semantics are otherwise identical to\n @code{define_constraint}.\n @end deffn\n \n+@deffn {MD Expression} define_special_memory_constraint name docstring exp\n+Use this expression for constraints that match a subset of all memory\n+operands: that is, @code{reload} can not make them match by reloading\n+the address as it is described for @code{define_memory_constraint} or\n+such address reload is undesirable with the performance point of view.\n+\n+For example, @code{define_special_memory_constraint} can be useful if\n+specifically aligned memory is necessary or desirable for some insn\n+operand.\n+\n+The syntax and semantics are otherwise identical to\n+@code{define_constraint}.\n+@end deffn\n+\n @deffn {MD Expression} define_address_constraint name docstring exp\n Use this expression for constraints that match a subset of all address\n operands: that is, @code{reload} can make the constraint match by"}, {"sha": "6ca1bb89cf7209f7decd155fc1890680419cd9b8", "filename": "gcc/genoutput.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb1ca69e1ebd98cc8e401b5ae271b988e3ab84a/gcc%2Fgenoutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb1ca69e1ebd98cc8e401b5ae271b988e3ab84a/gcc%2Fgenoutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenoutput.c?ref=9eb1ca69e1ebd98cc8e401b5ae271b988e3ab84a", "patch": "@@ -1019,6 +1019,7 @@ main (int argc, char **argv)\n       case DEFINE_REGISTER_CONSTRAINT:\n       case DEFINE_ADDRESS_CONSTRAINT:\n       case DEFINE_MEMORY_CONSTRAINT:\n+      case DEFINE_SPECIAL_MEMORY_CONSTRAINT:\n \tnote_constraint (&info);\n \tbreak;\n "}, {"sha": "c0d7ce4146cb49acd1c06fe9aef08b0b11d09665", "filename": "gcc/genpreds.c", "status": "modified", "additions": 55, "deletions": 19, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb1ca69e1ebd98cc8e401b5ae271b988e3ab84a/gcc%2Fgenpreds.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb1ca69e1ebd98cc8e401b5ae271b988e3ab84a/gcc%2Fgenpreds.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpreds.c?ref=9eb1ca69e1ebd98cc8e401b5ae271b988e3ab84a", "patch": "@@ -659,11 +659,11 @@ write_one_predicate_function (struct pred_data *p)\n \f\n /* Constraints fall into two categories: register constraints\n    (define_register_constraint), and others (define_constraint,\n-   define_memory_constraint, define_address_constraint).  We\n-   work out automatically which of the various old-style macros\n-   they correspond to, and produce appropriate code.  They all\n-   go in the same hash table so we can verify that there are no\n-   duplicate names.  */\n+   define_memory_constraint, define_special_memory_constraint,\n+   define_address_constraint).  We work out automatically which of the\n+   various old-style macros they correspond to, and produce\n+   appropriate code.  They all go in the same hash table so we can\n+   verify that there are no duplicate names.  */\n \n /* All data from one constraint definition.  */\n struct constraint_data\n@@ -681,6 +681,7 @@ struct constraint_data\n   unsigned int is_const_dbl\t: 1;\n   unsigned int is_extra\t\t: 1;\n   unsigned int is_memory\t: 1;\n+  unsigned int is_special_memory: 1;\n   unsigned int is_address\t: 1;\n   unsigned int maybe_allows_reg : 1;\n   unsigned int maybe_allows_mem : 1;\n@@ -718,6 +719,7 @@ static const char const_dbl_constraints[] = \"GH\";\n static unsigned int constraint_max_namelen;\n static bool have_register_constraints;\n static bool have_memory_constraints;\n+static bool have_special_memory_constraints;\n static bool have_address_constraints;\n static bool have_extra_constraints;\n static bool have_const_int_constraints;\n@@ -728,6 +730,7 @@ static unsigned int register_start, register_end;\n static unsigned int satisfied_start;\n static unsigned int const_int_start, const_int_end;\n static unsigned int memory_start, memory_end;\n+static unsigned int special_memory_start, special_memory_end;\n static unsigned int address_start, address_end;\n static unsigned int maybe_allows_none_start, maybe_allows_none_end;\n static unsigned int maybe_allows_reg_start, maybe_allows_reg_end;\n@@ -754,20 +757,22 @@ mangle (const char *name)\n \n /* Add one constraint, of any sort, to the tables.  NAME is its name;\n    REGCLASS is the register class, if any; EXP is the expression to\n-   test, if any;  IS_MEMORY and IS_ADDRESS indicate memory and address\n-   constraints, respectively; LOC is the .md file location.\n+   test, if any; IS_MEMORY, IS_SPECIAL_MEMORY and IS_ADDRESS indicate\n+   memory, special memory, and address constraints, respectively; LOC\n+   is the .md file location.\n \n-   Not all combinations of arguments are valid; most importantly, REGCLASS\n-   is mutually exclusive with EXP, and IS_MEMORY/IS_ADDRESS are only\n-   meaningful for constraints with EXP.\n+   Not all combinations of arguments are valid; most importantly,\n+   REGCLASS is mutually exclusive with EXP, and\n+   IS_MEMORY/IS_SPECIAL_MEMORY/IS_ADDRESS are only meaningful for\n+   constraints with EXP.\n \n    This function enforces all syntactic and semantic rules about what\n    constraints can be defined.  */\n \n static void\n add_constraint (const char *name, const char *regclass,\n-\t\trtx exp, bool is_memory, bool is_address,\n-\t\tfile_location loc)\n+\t\trtx exp, bool is_memory, bool is_special_memory,\n+\t\tbool is_address, file_location loc)\n {\n   struct constraint_data *c, **iter, **slot;\n   const char *p;\n@@ -878,6 +883,17 @@ add_constraint (const char *name, const char *regclass,\n \t\t      name, name[0]);\n \t  return;\n \t}\n+      else if (is_special_memory)\n+\t{\n+\t  if (name[1] == '\\0')\n+\t    error_at (loc, \"constraint letter '%c' cannot be a \"\n+\t\t      \"special memory constraint\", name[0]);\n+\t  else\n+\t    error_at (loc, \"constraint name '%s' begins with '%c', \"\n+\t\t      \"and therefore cannot be a special memory constraint\",\n+\t\t      name, name[0]);\n+\t  return;\n+\t}\n       else if (is_address)\n \t{\n \t  if (name[1] == '\\0')\n@@ -904,6 +920,7 @@ add_constraint (const char *name, const char *regclass,\n   c->is_const_dbl = is_const_dbl;\n   c->is_extra = !(regclass || is_const_int || is_const_dbl);\n   c->is_memory = is_memory;\n+  c->is_special_memory = is_special_memory;\n   c->is_address = is_address;\n   c->maybe_allows_reg = true;\n   c->maybe_allows_mem = true;\n@@ -930,17 +947,20 @@ add_constraint (const char *name, const char *regclass,\n   have_const_int_constraints |= c->is_const_int;\n   have_extra_constraints |= c->is_extra;\n   have_memory_constraints |= c->is_memory;\n+  have_special_memory_constraints |= c->is_special_memory;\n   have_address_constraints |= c->is_address;\n   num_constraints += 1;\n }\n \n-/* Process a DEFINE_CONSTRAINT, DEFINE_MEMORY_CONSTRAINT, or\n-   DEFINE_ADDRESS_CONSTRAINT expression, C.  */\n+/* Process a DEFINE_CONSTRAINT, DEFINE_MEMORY_CONSTRAINT,\n+   DEFINE_SPECIAL_MEMORY_CONSTRAINT, or DEFINE_ADDRESS_CONSTRAINT\n+   expression, C.  */\n static void\n process_define_constraint (md_rtx_info *info)\n {\n   add_constraint (XSTR (info->def, 0), 0, XEXP (info->def, 2),\n \t\t  GET_CODE (info->def) == DEFINE_MEMORY_CONSTRAINT,\n+\t\t  GET_CODE (info->def) == DEFINE_SPECIAL_MEMORY_CONSTRAINT,\n \t\t  GET_CODE (info->def) == DEFINE_ADDRESS_CONSTRAINT,\n \t\t  info->loc);\n }\n@@ -950,7 +970,7 @@ static void\n process_define_register_constraint (md_rtx_info *info)\n {\n   add_constraint (XSTR (info->def, 0), XSTR (info->def, 1),\n-\t\t  0, false, false, info->loc);\n+\t\t  0, false, false, false, info->loc);\n }\n \n /* Put the constraints into enum order.  We want to keep constraints\n@@ -984,6 +1004,12 @@ choose_enum_order (void)\n       enum_order[next++] = c;\n   memory_end = next;\n \n+  special_memory_start = next;\n+  FOR_ALL_CONSTRAINTS (c)\n+    if (c->is_special_memory)\n+      enum_order[next++] = c;\n+  special_memory_end = next;\n+\n   address_start = next;\n   FOR_ALL_CONSTRAINTS (c)\n     if (c->is_address)\n@@ -992,27 +1018,31 @@ choose_enum_order (void)\n \n   maybe_allows_none_start = next;\n   FOR_ALL_CONSTRAINTS (c)\n-    if (!c->is_register && !c->is_const_int && !c->is_memory && !c->is_address\n+    if (!c->is_register && !c->is_const_int && !c->is_memory\n+\t&& !c->is_special_memory && !c->is_address\n \t&& !c->maybe_allows_reg && !c->maybe_allows_mem)\n       enum_order[next++] = c;\n   maybe_allows_none_end = next;\n \n   maybe_allows_reg_start = next;\n   FOR_ALL_CONSTRAINTS (c)\n-    if (!c->is_register && !c->is_const_int && !c->is_memory && !c->is_address\n+    if (!c->is_register && !c->is_const_int && !c->is_memory\n+\t&& !c->is_special_memory && !c->is_address\n \t&& c->maybe_allows_reg && !c->maybe_allows_mem)\n       enum_order[next++] = c;\n   maybe_allows_reg_end = next;\n \n   maybe_allows_mem_start = next;\n   FOR_ALL_CONSTRAINTS (c)\n-    if (!c->is_register && !c->is_const_int && !c->is_memory && !c->is_address\n+    if (!c->is_register && !c->is_const_int && !c->is_memory\n+\t&& !c->is_special_memory && !c->is_address\n \t&& !c->maybe_allows_reg && c->maybe_allows_mem)\n       enum_order[next++] = c;\n   maybe_allows_mem_end = next;\n \n   FOR_ALL_CONSTRAINTS (c)\n-    if (!c->is_register && !c->is_const_int && !c->is_memory && !c->is_address\n+    if (!c->is_register && !c->is_const_int && !c->is_memory\n+\t&& !c->is_special_memory && !c->is_address\n \t&& c->maybe_allows_reg && c->maybe_allows_mem)\n       enum_order[next++] = c;\n   gcc_assert (next == num_constraints);\n@@ -1431,6 +1461,8 @@ write_tm_preds_h (void)\n \t\t\t    register_start, register_end);\n       write_range_function (\"insn_extra_memory_constraint\",\n \t\t\t    memory_start, memory_end);\n+      write_range_function (\"insn_extra_special_memory_constraint\",\n+\t\t\t    special_memory_start, special_memory_end);\n       write_range_function (\"insn_extra_address_constraint\",\n \t\t\t    address_start, address_end);\n       write_allows_reg_mem_function ();\n@@ -1479,6 +1511,7 @@ write_tm_preds_h (void)\n \t    \"  CT_REGISTER,\\n\"\n \t    \"  CT_CONST_INT,\\n\"\n \t    \"  CT_MEMORY,\\n\"\n+\t    \"  CT_SPECIAL_MEMORY,\\n\"\n \t    \"  CT_ADDRESS,\\n\"\n \t    \"  CT_FIXED_FORM\\n\"\n \t    \"};\\n\"\n@@ -1491,6 +1524,8 @@ write_tm_preds_h (void)\n \tvalues.safe_push (std::make_pair (const_int_start, \"CT_CONST_INT\"));\n       if (memory_start != memory_end)\n \tvalues.safe_push (std::make_pair (memory_start, \"CT_MEMORY\"));\n+      if (special_memory_start != special_memory_end)\n+\tvalues.safe_push (std::make_pair (special_memory_start, \"CT_SPECIAL_MEMORY\"));\n       if (address_start != address_end)\n \tvalues.safe_push (std::make_pair (address_start, \"CT_ADDRESS\"));\n       if (address_end != num_constraints)\n@@ -1602,6 +1637,7 @@ main (int argc, char **argv)\n \n       case DEFINE_CONSTRAINT:\n       case DEFINE_MEMORY_CONSTRAINT:\n+      case DEFINE_SPECIAL_MEMORY_CONSTRAINT:\n       case DEFINE_ADDRESS_CONSTRAINT:\n \tprocess_define_constraint (&info);\n \tbreak;"}, {"sha": "8c5a1ab86029f44bc00a5b858983c05032013250", "filename": "gcc/gensupport.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb1ca69e1ebd98cc8e401b5ae271b988e3ab84a/gcc%2Fgensupport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb1ca69e1ebd98cc8e401b5ae271b988e3ab84a/gcc%2Fgensupport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.c?ref=9eb1ca69e1ebd98cc8e401b5ae271b988e3ab84a", "patch": "@@ -521,6 +521,7 @@ process_rtx (rtx desc, file_location loc)\n     case DEFINE_CONSTRAINT:\n     case DEFINE_REGISTER_CONSTRAINT:\n     case DEFINE_MEMORY_CONSTRAINT:\n+    case DEFINE_SPECIAL_MEMORY_CONSTRAINT:\n     case DEFINE_ADDRESS_CONSTRAINT:\n       queue_pattern (desc, &define_pred_tail, loc);\n       break;"}, {"sha": "2b736c1ffd3c1aa829e7940908441eb6e0113fac", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb1ca69e1ebd98cc8e401b5ae271b988e3ab84a/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb1ca69e1ebd98cc8e401b5ae271b988e3ab84a/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=9eb1ca69e1ebd98cc8e401b5ae271b988e3ab84a", "patch": "@@ -783,6 +783,12 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t\t\twin = 1;\n \t\t      break;\n \n+\t\t    case CT_SPECIAL_MEMORY:\n+\t\t      insn_allows_mem[i] = allows_mem[i] = 1;\n+\t\t      if (MEM_P (op) && constraint_satisfied_p (op, cn))\n+\t\t\twin = 1;\n+\t\t      break;\n+\n \t\t    case CT_ADDRESS:\n \t\t      /* Every address can be reloaded to fit.  */\n \t\t      allows_addr = 1;"}, {"sha": "6950ffb17b31cd5e52dfd948a00645ae163f9ac9", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb1ca69e1ebd98cc8e401b5ae271b988e3ab84a/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb1ca69e1ebd98cc8e401b5ae271b988e3ab84a/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=9eb1ca69e1ebd98cc8e401b5ae271b988e3ab84a", "patch": "@@ -774,6 +774,7 @@ single_reg_class (const char *constraints, rtx op, rtx equiv_const)\n \t  /* ??? Is this the best way to handle memory constraints?  */\n \t  cn = lookup_constraint (constraints);\n \t  if (insn_extra_memory_constraint (cn)\n+\t      || insn_extra_special_memory_constraint (cn)\n \t      || insn_extra_address_constraint (cn))\n \t    return NO_REGS;\n \t  if (constraint_satisfied_p (op, cn)"}, {"sha": "249e2fffae7213570ba529263c3b65d9bffb6ef5", "filename": "gcc/ira.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb1ca69e1ebd98cc8e401b5ae271b988e3ab84a/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb1ca69e1ebd98cc8e401b5ae271b988e3ab84a/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=9eb1ca69e1ebd98cc8e401b5ae271b988e3ab84a", "patch": "@@ -1868,6 +1868,7 @@ ira_setup_alts (rtx_insn *insn, HARD_REG_SET &alts)\n \n \t\t\tcase CT_ADDRESS:\n \t\t\tcase CT_MEMORY:\n+\t\t\tcase CT_SPECIAL_MEMORY:\n \t\t\t  goto op_success;\n \n \t\t\tcase CT_FIXED_FORM:"}, {"sha": "9a7121fb6afc9b3367ab005fa1e583b3bdfbd43a", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb1ca69e1ebd98cc8e401b5ae271b988e3ab84a/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb1ca69e1ebd98cc8e401b5ae271b988e3ab84a/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=9eb1ca69e1ebd98cc8e401b5ae271b988e3ab84a", "patch": "@@ -400,7 +400,7 @@ valid_address_p (struct address_info *ad)\n }\n \n /* Return true if the eliminated form of memory reference OP satisfies\n-   extra memory constraint CONSTRAINT.  */\n+   extra (special) memory constraint CONSTRAINT.  */\n static bool\n satisfies_memory_constraint_p (rtx op, enum constraint_num constraint)\n {\n@@ -2038,6 +2038,14 @@ process_alt_operands (int only_alternative)\n \t\t      if (constraint_satisfied_p (op, cn))\n \t\t\twin = true;\n \t\t      break;\n+\n+\t\t    case CT_SPECIAL_MEMORY:\n+\t\t      if (MEM_P (op)\n+\t\t\t  && satisfies_memory_constraint_p (op, cn))\n+\t\t\twin = true;\n+\t\t      else if (spilled_pseudo_p (op))\n+\t\t\twin = true;\n+\t\t      break;\n \t\t    }\n \t\t  break;\n \n@@ -3701,7 +3709,8 @@ curr_insn_transform (bool check_only_p)\n \t\t constraint += CONSTRAINT_LEN (c, constraint))\n \t      {\n \t\tenum constraint_num cn = lookup_constraint (constraint);\n-\t\tif (insn_extra_memory_constraint (cn)\n+\t\tif ((insn_extra_memory_constraint (cn)\n+\t\t     || insn_extra_special_memory_constraint (cn))\n \t\t    && satisfies_memory_constraint_p (tem, cn))\n \t\t  break;\n \t      }"}, {"sha": "92b2aa31a777b60bfd2f725d2c5d51006b971fbe", "filename": "gcc/recog.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb1ca69e1ebd98cc8e401b5ae271b988e3ab84a/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb1ca69e1ebd98cc8e401b5ae271b988e3ab84a/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=9eb1ca69e1ebd98cc8e401b5ae271b988e3ab84a", "patch": "@@ -1791,6 +1791,7 @@ asm_operand_ok (rtx op, const char *constraint, const char **constraints)\n \t      break;\n \n \t    case CT_MEMORY:\n+\t    case CT_SPECIAL_MEMORY:\n \t      /* Every memory operand can be reloaded to fit.  */\n \t      result = result || memory_operand (op, VOIDmode);\n \t      break;\n@@ -2403,6 +2404,7 @@ preprocess_constraints (int n_operands, int n_alternatives,\n \t\t      break;\n \n \t\t    case CT_MEMORY:\n+\t\t    case CT_SPECIAL_MEMORY:\n \t\t      op_alt[i].memory_ok = 1;\n \t\t      break;\n "}, {"sha": "6196e63a16c6df367921d17d4d0b6202ecd6b3a8", "filename": "gcc/reload.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb1ca69e1ebd98cc8e401b5ae271b988e3ab84a/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb1ca69e1ebd98cc8e401b5ae271b988e3ab84a/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=9eb1ca69e1ebd98cc8e401b5ae271b988e3ab84a", "patch": "@@ -3471,6 +3471,23 @@ find_reloads (rtx_insn *insn, int replace, int ind_levels, int live_known,\n \t\t\toffmemok = 1;\n \t\t\tbreak;\n \n+\t\t      case CT_SPECIAL_MEMORY:\n+\t\t\tif (force_reload)\n+\t\t\t  break;\n+\t\t\tif (constraint_satisfied_p (operand, cn))\n+\t\t\t  win = 1;\n+\t\t\t/* Likewise if the address will be reloaded because\n+\t\t\t   reg_equiv_address is nonzero.  For reg_equiv_mem\n+\t\t\t   we have to check.  */\n+\t\t\telse if (REG_P (operand)\n+\t\t\t\t && REGNO (operand) >= FIRST_PSEUDO_REGISTER\n+\t\t\t\t && reg_renumber[REGNO (operand)] < 0\n+\t\t\t\t && reg_equiv_mem (REGNO (operand)) != 0\n+\t\t\t\t && (constraint_satisfied_p\n+\t\t\t\t     (reg_equiv_mem (REGNO (operand)), cn)))\n+\t\t\t  win = 1;\n+\t\t\tbreak;\n+\n \t\t      case CT_ADDRESS:\n \t\t\tif (constraint_satisfied_p (operand, cn))\n \t\t\t  win = 1;"}, {"sha": "0b7f894e0d7920f6bef6932ffda66b84b1b986d5", "filename": "gcc/rtl.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb1ca69e1ebd98cc8e401b5ae271b988e3ab84a/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb1ca69e1ebd98cc8e401b5ae271b988e3ab84a/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=9eb1ca69e1ebd98cc8e401b5ae271b988e3ab84a", "patch": "@@ -1035,6 +1035,7 @@ DEF_RTL_EXPR(DEFINE_REGISTER_CONSTRAINT, \"define_register_constraint\", \"sss\", RT\n       RTL object.  */\n DEF_RTL_EXPR(DEFINE_CONSTRAINT, \"define_constraint\", \"sse\", RTX_EXTRA)\n DEF_RTL_EXPR(DEFINE_MEMORY_CONSTRAINT, \"define_memory_constraint\", \"sse\", RTX_EXTRA)\n+DEF_RTL_EXPR(DEFINE_SPECIAL_MEMORY_CONSTRAINT, \"define_special_memory_constraint\", \"sse\", RTX_EXTRA)\n DEF_RTL_EXPR(DEFINE_ADDRESS_CONSTRAINT, \"define_address_constraint\", \"sse\", RTX_EXTRA)\n \n "}, {"sha": "2e9072f4637913dc1a9aff7a2622941b692e951c", "filename": "gcc/stmt.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb1ca69e1ebd98cc8e401b5ae271b988e3ab84a/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb1ca69e1ebd98cc8e401b5ae271b988e3ab84a/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=9eb1ca69e1ebd98cc8e401b5ae271b988e3ab84a", "patch": "@@ -434,7 +434,8 @@ parse_input_constraint (const char **constraint_p, int input_num,\n \tif (reg_class_for_constraint (cn) != NO_REGS\n \t    || insn_extra_address_constraint (cn))\n \t  *allows_reg = true;\n-\telse if (insn_extra_memory_constraint (cn))\n+\telse if (insn_extra_memory_constraint (cn)\n+\t\t || insn_extra_special_memory_constraint (cn))\n \t  *allows_mem = true;\n \telse\n \t  insn_extra_constraint_allows_reg_mem (cn, allows_reg, allows_mem);"}]}