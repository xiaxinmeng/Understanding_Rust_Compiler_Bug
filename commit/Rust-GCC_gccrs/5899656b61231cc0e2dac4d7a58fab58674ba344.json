{"sha": "5899656b61231cc0e2dac4d7a58fab58674ba344", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTg5OTY1NmI2MTIzMWNjMGUyZGFjNGQ3YTU4ZmFiNTg2NzRiYTM0NA==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2019-10-18T19:03:27Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2019-10-18T19:03:27Z"}, "message": "[arm] Early split simple DImode equality comparisons\n\nThis is the first step of early splitting all the DImode comparison\noperations.  We start by factoring the DImode handling out of\narm_gen_compare_reg into its own function.\n\nSimple DImode equality comparisions (such as equality with zero, or\nequality with a constant that is zero in one of the two word values\nthat it comprises) can be done using a single subtract followed by an\nORRS instruction.  This avoids the need for conditional execution.\n\nFor example, (r0 != 5) can be written as\n\n\tSUB\tRt, R0, #5\n\tORRS\tRt, Rt, R1\n\nThe ORRS is now expanded using an SImode pattern that already exists\nin the MD file and this gives the register allocator more freedom to\nselect registers (consecutive pairs are no-longer required).\nFurthermore, we can then delete the arm_cmpdi_zero pattern as it is\nno-longer required.  We use SUB for the value adjustment as this has a\ngenerally more flexible range of immediates than XOR and what's more\nhas the opportunity to be relaxed in thumb2 to a 16-bit SUBS\ninstruction.\n\n\t* config/arm/arm.c (arm_select_cc_mode): For DImode equality tests\n\treturn CC_Zmode if comparing against a constant where one word is\n\tzero.\n\t(arm_gen_compare_reg): Split DImode handling to ...\n\t(arm_gen_dicompare_reg): ... here.  Handle equality comparisons\n\tagainst simple constants.\n\t* config/arm/arm.md (arm_cmpdi_zero): Delete pattern.\n\nFrom-SVN: r277177", "tree": {"sha": "046cab757eff2ab960fd3733a3d1e35630c3bacf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/046cab757eff2ab960fd3733a3d1e35630c3bacf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5899656b61231cc0e2dac4d7a58fab58674ba344", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5899656b61231cc0e2dac4d7a58fab58674ba344", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5899656b61231cc0e2dac4d7a58fab58674ba344", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5899656b61231cc0e2dac4d7a58fab58674ba344/comments", "author": null, "committer": null, "parents": [{"sha": "0b478cddf9e95406cd865c94bf99705ec8acddde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b478cddf9e95406cd865c94bf99705ec8acddde", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b478cddf9e95406cd865c94bf99705ec8acddde"}], "stats": {"total": 108, "additions": 78, "deletions": 30}, "files": [{"sha": "51a2c3f2ed083141761785ca35ffc801202606b1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5899656b61231cc0e2dac4d7a58fab58674ba344/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5899656b61231cc0e2dac4d7a58fab58674ba344/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5899656b61231cc0e2dac4d7a58fab58674ba344", "patch": "@@ -1,3 +1,13 @@\n+2019-10-18  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* config/arm/arm.c (arm_select_cc_mode): For DImode equality tests\n+\treturn CC_Zmode if comparing against a constant where one word is\n+\tzero.\n+\t(arm_gen_compare_reg): Split DImode handling to ...\n+\t(arm_gen_dicompare_reg): ... here.  Handle equality comparisons\n+\tagainst simple constants.\n+\t* config/arm/arm.md (arm_cmpdi_zero): Delete pattern.\n+\n 2019-10-18  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* config/arm/arm.md (subsi3_carryin_shift_alt): New pattern."}, {"sha": "97ebf6389889e8b6484ff66ab391024a869d89f8", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 68, "deletions": 19, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5899656b61231cc0e2dac4d7a58fab58674ba344/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5899656b61231cc0e2dac4d7a58fab58674ba344/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=5899656b61231cc0e2dac4d7a58fab58674ba344", "patch": "@@ -15350,8 +15350,14 @@ arm_select_cc_mode (enum rtx_code op, rtx x, rtx y)\n \tcase EQ:\n \tcase NE:\n \t  /* A DImode comparison against zero can be implemented by\n-\t     or'ing the two halves together.  */\n-\t  if (y == const0_rtx)\n+\t     or'ing the two halves together.  We can also handle\n+\t     immediates where one word of that value is zero by\n+\t     subtracting the non-zero word from the corresponding word\n+\t     in the other register and then ORRing it with the other\n+\t     word.  */\n+\t  if (CONST_INT_P (y)\n+\t      && ((UINTVAL (y) & 0xffffffff) == 0\n+\t\t  || (UINTVAL (y) >> 32) == 0))\n \t    return CC_Zmode;\n \n \t  /* We can do an equality test in three Thumb instructions.  */\n@@ -15393,37 +15399,64 @@ arm_select_cc_mode (enum rtx_code op, rtx x, rtx y)\n   return CCmode;\n }\n \n-/* X and Y are two things to compare using CODE.  Emit the compare insn and\n-   return the rtx for register 0 in the proper mode.  FP means this is a\n-   floating point compare: I don't think that it is needed on the arm.  */\n-rtx\n-arm_gen_compare_reg (enum rtx_code code, rtx x, rtx y, rtx scratch)\n+/* X and Y are two (DImode) things to compare for the condition CODE.  Emit\n+   the sequence of instructions needed to generate a suitable condition\n+   code register.  Return the CC register result.  */\n+static rtx\n+arm_gen_dicompare_reg (rtx_code code, rtx x, rtx y, rtx scratch)\n {\n-  machine_mode mode;\n-  rtx cc_reg;\n-  int dimode_comparison = GET_MODE (x) == DImode || GET_MODE (y) == DImode;\n+  /* We don't currently handle DImode in thumb1, but rely on libgcc.  */\n+  gcc_assert (TARGET_32BIT);\n \n   /* We might have X as a constant, Y as a register because of the predicates\n      used for cmpdi.  If so, force X to a register here.  */\n-  if (dimode_comparison && !REG_P (x))\n+  if (!REG_P (x))\n     x = force_reg (DImode, x);\n \n-  mode = SELECT_CC_MODE (code, x, y);\n-  cc_reg = gen_rtx_REG (mode, CC_REGNUM);\n+  machine_mode mode = SELECT_CC_MODE (code, x, y);\n+  rtx cc_reg = gen_rtx_REG (mode, CC_REGNUM);\n \n-  if (dimode_comparison\n-      && mode != CC_CZmode)\n+  if (mode != CC_CZmode)\n     {\n       rtx clobber, set;\n \n       /* To compare two non-zero values for equality, XOR them and\n \t then compare against zero.  Not used for ARM mode; there\n \t CC_CZmode is cheaper.  */\n-      if (mode == CC_Zmode && y != const0_rtx)\n+      if (mode == CC_Zmode)\n \t{\n-\t  gcc_assert (!reload_completed);\n-\t  x = expand_binop (DImode, xor_optab, x, y, NULL_RTX, 0, OPTAB_WIDEN);\n-\t  y = const0_rtx;\n+\t  mode = CC_NOOVmode;\n+\t  PUT_MODE (cc_reg, mode);\n+\t  if (y != const0_rtx)\n+\t    {\n+\t      gcc_assert (CONST_INT_P (y));\n+\t      rtx xlo, xhi, ylo, yhi;\n+\t      arm_decompose_di_binop (x, y, &xlo, &xhi, &ylo, &yhi);\n+\t      if (!scratch)\n+\t\tscratch = gen_reg_rtx (SImode);\n+\t      if (ylo == const0_rtx)\n+\t\t{\n+\t\t  yhi = GEN_INT (-INTVAL(yhi));\n+\t\t  if (!arm_add_operand (yhi, SImode))\n+\t\t    yhi = force_reg (SImode, yhi);\n+\t\t  emit_insn (gen_addsi3 (scratch, xhi, yhi));\n+\t\t  y = xlo;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  gcc_assert (yhi == const0_rtx);\n+\t\t  ylo = GEN_INT (-INTVAL(ylo));\n+\t\t  if (!arm_add_operand (ylo, SImode))\n+\t\t    ylo = force_reg (SImode, ylo);\n+\t\t  emit_insn (gen_addsi3 (scratch, xlo, ylo));\n+\t\t  y = xhi;\n+\t\t}\n+\t      x = gen_rtx_IOR (SImode, scratch, y);\n+\t      y = const0_rtx;\n+\t    }\n+\t  else\n+\t    x = gen_rtx_IOR (SImode, gen_lowpart (SImode, x),\n+\t\t\t     gen_highpart (SImode, x));\n \t}\n \n       /* A scratch register is required.  */\n@@ -15442,6 +15475,22 @@ arm_gen_compare_reg (enum rtx_code code, rtx x, rtx y, rtx scratch)\n   return cc_reg;\n }\n \n+/* X and Y are two things to compare using CODE.  Emit the compare insn and\n+   return the rtx for register 0 in the proper mode.  */\n+rtx\n+arm_gen_compare_reg (rtx_code code, rtx x, rtx y, rtx scratch)\n+{\n+  if (GET_MODE (x) == DImode || GET_MODE (y) == DImode)\n+    return arm_gen_dicompare_reg (code, x, y, scratch);\n+\n+  machine_mode mode = SELECT_CC_MODE (code, x, y);\n+  rtx cc_reg = gen_rtx_REG (mode, CC_REGNUM);\n+\n+  emit_set_insn (cc_reg, gen_rtx_COMPARE (mode, x, y));\n+\n+  return cc_reg;\n+}\n+\n /* Generate a sequence of insns that will generate the correct return\n    address mask depending on the physical architecture that the program\n    is running on.  */"}, {"sha": "a6b0c196c58ca145b256e20ac233bfa2857401e8", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5899656b61231cc0e2dac4d7a58fab58674ba344/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5899656b61231cc0e2dac4d7a58fab58674ba344/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=5899656b61231cc0e2dac4d7a58fab58674ba344", "patch": "@@ -6518,17 +6518,6 @@\n    (set_attr \"type\" \"multiple\")]\n )\n \n-(define_insn \"*arm_cmpdi_zero\"\n-  [(set (reg:CC_Z CC_REGNUM)\n-\t(compare:CC_Z (match_operand:DI 0 \"s_register_operand\" \"r\")\n-\t\t      (const_int 0)))\n-   (clobber (match_scratch:SI 1 \"=r\"))]\n-  \"TARGET_32BIT\"\n-  \"orrs%?\\\\t%1, %Q0, %R0\"\n-  [(set_attr \"conds\" \"set\")\n-   (set_attr \"type\" \"logics_reg\")]\n-)\n-\n ; This insn allows redundant compares to be removed by cse, nothing should\n ; ever appear in the output file since (set (reg x) (reg x)) is a no-op that\n ; is deleted later on. The match_dup will match the mode here, so that"}]}