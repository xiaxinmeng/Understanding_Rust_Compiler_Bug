{"sha": "8a2b77e7376a10b62a023843a64d4998fde5b5da", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGEyYjc3ZTczNzZhMTBiNjJhMDIzODQzYTY0ZDQ5OThmZGU1YjVkYQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2001-11-15T15:09:43Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2001-11-15T15:09:43Z"}, "message": "parse.y: Add ...\n\n        * parse.y: Add ... IDENTIFIER SCOPE and ... PTYPENAME SCOPE expansions.\n        * decl.c (make_typename_type): Handle getting a class template.\n        * search.c (lookup_field_r): A class template is good enough for\n        want_type.\n\n        * call.c (convert_like_real): Only use cp_convert for the bad part.\n        (standard_conversion): Also allow bad int->enum.\n        * typeck.c (ptr_reasonably_similar): Also allow functions to\n        interconvert.  Pointers to same-size integers are reasonably\n        similar.\n\n        * cvt.c (convert_to_void): If we build a new COND_EXPR, always\n        give it void type.\n\nFrom-SVN: r47060", "tree": {"sha": "3a2e64bbd40a3c54769c05fc7a160ad65a8d29fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a2e64bbd40a3c54769c05fc7a160ad65a8d29fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a2b77e7376a10b62a023843a64d4998fde5b5da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a2b77e7376a10b62a023843a64d4998fde5b5da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a2b77e7376a10b62a023843a64d4998fde5b5da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a2b77e7376a10b62a023843a64d4998fde5b5da/comments", "author": null, "committer": null, "parents": [{"sha": "9bddde52b4cf9c9a4609e2288893c57a1da0abd7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bddde52b4cf9c9a4609e2288893c57a1da0abd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bddde52b4cf9c9a4609e2288893c57a1da0abd7"}], "stats": {"total": 118, "additions": 94, "deletions": 24}, "files": [{"sha": "59cb2af715886a5c59153ac7e60c3b8e5f41ad0f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a2b77e7376a10b62a023843a64d4998fde5b5da/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a2b77e7376a10b62a023843a64d4998fde5b5da/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8a2b77e7376a10b62a023843a64d4998fde5b5da", "patch": "@@ -1,3 +1,19 @@\n+2001-11-15  Jason Merrill  <jason@redhat.com>\n+\n+\t* parse.y: Add ... IDENTIFIER SCOPE and ... PTYPENAME SCOPE expansions.\n+\t* decl.c (make_typename_type): Handle getting a class template.\n+\t* search.c (lookup_field_r): A class template is good enough for\n+\twant_type.\n+\n+\t* call.c (convert_like_real): Only use cp_convert for the bad part.\n+\t(standard_conversion): Also allow bad int->enum.\n+\t* typeck.c (ptr_reasonably_similar): Also allow functions to\n+\tinterconvert.  Pointers to same-size integers are reasonably\n+\tsimilar.\n+\n+\t* cvt.c (convert_to_void): If we build a new COND_EXPR, always\n+\tgive it void type.\n+\n 2001-11-15  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tPR g++/3154\n@@ -17,12 +33,12 @@\n \n 2001-11-14  Richard Sandiford  <rsandifo@redhat.com>\n \n-        * decl.c (check_initializer): Try to complete the type of an\n-        array element before checking whether it's complete.  Don't\n-        complain about arrays with complete element types but an\n-        unknown size.\n-        (cp_finish_decl): Build the hierarchical constructor before\n-        calling maybe_deduce_size_from_array_init.\n+\t* decl.c (check_initializer): Try to complete the type of an\n+\tarray element before checking whether it's complete.  Don't\n+\tcomplain about arrays with complete element types but an\n+\tunknown size.\n+\t(cp_finish_decl): Build the hierarchical constructor before\n+\tcalling maybe_deduce_size_from_array_init.\n \n 2001-11-14  Joseph S. Myers  <jsm28@cam.ac.uk>\n "}, {"sha": "91bc0978ad2c24c090c03354d40a8023e176d765", "filename": "gcc/cp/call.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a2b77e7376a10b62a023843a64d4998fde5b5da/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a2b77e7376a10b62a023843a64d4998fde5b5da/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=8a2b77e7376a10b62a023843a64d4998fde5b5da", "patch": "@@ -753,6 +753,14 @@ standard_conversion (to, from, expr)\n       conv = build_conv (STD_CONV, to, conv);\n       ICS_BAD_FLAG (conv) = 1;\n     }\n+  else if (tcode == ENUMERAL_TYPE && fcode == INTEGER_TYPE\n+\t   && TYPE_PRECISION (to) == TYPE_PRECISION (from))\n+    {\n+      /* For backwards brain damage compatibility, allow interconversion of\n+\t enums and integers with a pedwarn.  */\n+      conv = build_conv (STD_CONV, to, conv);\n+      ICS_BAD_FLAG (conv) = 1;\n+    }\n   else if (tcode == POINTER_TYPE && fcode == POINTER_TYPE)\n     {\n       enum tree_code ufcode = TREE_CODE (TREE_TYPE (from));\n@@ -3748,7 +3756,7 @@ convert_like_real (convs, expr, fn, argnum, inner)\n       tree t = convs; \n       for (; t; t = TREE_OPERAND (t, 0))\n \t{\n-\t  if (TREE_CODE (t) == USER_CONV)\n+\t  if (TREE_CODE (t) == USER_CONV || !ICS_BAD_FLAG (t))\n \t    {\n \t      expr = convert_like_real (t, expr, fn, argnum, 1);\n \t      break;"}, {"sha": "960552c8e6a63bcde5a6577db82c6ddcd90dec50", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a2b77e7376a10b62a023843a64d4998fde5b5da/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a2b77e7376a10b62a023843a64d4998fde5b5da/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=8a2b77e7376a10b62a023843a64d4998fde5b5da", "patch": "@@ -936,10 +936,8 @@ convert_to_void (expr, implicit)\n         tree new_op1 = convert_to_void (op1, implicit);\n         tree new_op2 = convert_to_void (op2, implicit);\n         \n-        if (new_op1 != op1 || new_op2 != op2)\n-          expr = build (COND_EXPR,\n-                        implicit ? TREE_TYPE (expr) : void_type_node,\n-                        TREE_OPERAND (expr, 0), new_op1, new_op2);\n+\texpr = build (COND_EXPR, void_type_node,\n+\t\t      TREE_OPERAND (expr, 0), new_op1, new_op2);\n         break;\n       }\n     "}, {"sha": "ed6b6bf90b5452c0390f456957e46211b0a3e934", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a2b77e7376a10b62a023843a64d4998fde5b5da/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a2b77e7376a10b62a023843a64d4998fde5b5da/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=8a2b77e7376a10b62a023843a64d4998fde5b5da", "patch": "@@ -5652,6 +5652,11 @@ make_typename_type (context, name, complain)\n       if (TREE_CODE (name) == TEMPLATE_DECL)\n \tname = TREE_OPERAND (fullname, 0) = DECL_NAME (name);\n     }\n+  if (TREE_CODE (name) == TEMPLATE_DECL)\n+    {\n+      cp_error (\"`%D' used without template parameters\", name);\n+      return error_mark_node;\n+    }\n   if (TREE_CODE (name) != IDENTIFIER_NODE)\n     my_friendly_abort (2000);\n "}, {"sha": "24fd379933aa6a98f274a048afa1807b9fb0161f", "filename": "gcc/cp/method.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a2b77e7376a10b62a023843a64d4998fde5b5da/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a2b77e7376a10b62a023843a64d4998fde5b5da/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=8a2b77e7376a10b62a023843a64d4998fde5b5da", "patch": "@@ -513,6 +513,9 @@ use_thunk (thunk_fndecl, emit_p)\n        referenced.  */\n     TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (thunk_fndecl)) = 1;\n \n+    /* But we don't want debugging information about it.  */\n+    DECL_IGNORED_P (thunk_fndecl) = 1;\n+\n     expand_body (finish_function (0));\n   }\n "}, {"sha": "449ea9830d0ccb9ed6dddcec365bb43f144016b7", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a2b77e7376a10b62a023843a64d4998fde5b5da/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a2b77e7376a10b62a023843a64d4998fde5b5da/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=8a2b77e7376a10b62a023843a64d4998fde5b5da", "patch": "@@ -3021,6 +3021,13 @@ nested_name_specifier:\n \t| nested_name_specifier TEMPLATE explicit_template_type SCOPE\n                 { got_scope = $$ \n \t\t    = make_typename_type ($1, $3, /*complain=*/1); }\n+\t/* Error handling per Core 125.  */\n+\t| nested_name_specifier IDENTIFIER SCOPE\n+                { got_scope = $$ \n+\t\t    = make_typename_type ($1, $2, /*complain=*/1); }\n+\t| nested_name_specifier PTYPENAME SCOPE\n+                { got_scope = $$ \n+\t\t    = make_typename_type ($1, $2, /*complain=*/1); }\n \t;\n \n /* Why the @#$%^& do type_name and notype_identifier need to be expanded\n@@ -3050,16 +3057,6 @@ nested_name_specifier_1:\n \t\t}\n \t| template_type SCOPE\n \t\t{ got_scope = $$ = complete_type (TREE_TYPE ($1)); }\n-/* \tThese break 'const i;'\n-\t| IDENTIFIER SCOPE\n-\t\t{\n-\t\t failed_scope:\n-\t\t  cp_error (\"`%D' is not an aggregate typedef\", \n-\t\t\t    lastiddecl ? lastiddecl : $$);\n-\t\t  $$ = error_mark_node;\n-\t\t}\n-\t| PTYPENAME SCOPE\n-\t\t{ goto failed_scope; } */\n \t;\n \n typename_sub:"}, {"sha": "e09aa23ff3ba54138e3dbd8a7913dfd14831f8dd", "filename": "gcc/cp/search.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a2b77e7376a10b62a023843a64d4998fde5b5da/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a2b77e7376a10b62a023843a64d4998fde5b5da/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=8a2b77e7376a10b62a023843a64d4998fde5b5da", "patch": "@@ -1367,7 +1367,8 @@ lookup_field_r (binfo, data)\n \n   /* If we're looking up a type (as with an elaborated type specifier)\n      we ignore all non-types we find.  */\n-  if (lfi->want_type && TREE_CODE (nval) != TYPE_DECL)\n+  if (lfi->want_type && TREE_CODE (nval) != TYPE_DECL\n+      && !DECL_CLASS_TEMPLATE_P (nval))\n     {\n       if (lfi->name == TYPE_IDENTIFIER (type))\n \t{\n@@ -1727,9 +1728,9 @@ lookup_fnfields_1 (type, name)\n }\n \f\n /* Walk the class hierarchy dominated by TYPE.  FN is called for each\n-   type in the hierarchy, in a breadth-first preorder traversal.  .\n+   type in the hierarchy, in a breadth-first preorder traversal.\n    If it ever returns a non-NULL value, that value is immediately\n-   returned and the walk is terminated.  At each node FN, is passed a\n+   returned and the walk is terminated.  At each node, FN is passed a\n    BINFO indicating the path from the curently visited base-class to\n    TYPE.  Before each base-class is walked QFN is called.  If the\n    value returned is non-zero, the base-class is walked; otherwise it"}, {"sha": "85dc1d38e14ed1fe188f759b31ab8adc4a569658", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a2b77e7376a10b62a023843a64d4998fde5b5da/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a2b77e7376a10b62a023843a64d4998fde5b5da/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=8a2b77e7376a10b62a023843a64d4998fde5b5da", "patch": "@@ -6822,6 +6822,13 @@ ptr_reasonably_similar (to, from)\n \t\t\tCOMPARE_BASE | COMPARE_RELAXED))\n \tcontinue;\n \n+      if (TREE_CODE (to) == INTEGER_TYPE\n+\t  && TYPE_PRECISION (to) == TYPE_PRECISION (from))\n+\treturn 1;\n+\n+      if (TREE_CODE (to) == FUNCTION_TYPE)\n+\treturn 1;\n+\n       if (TREE_CODE (to) != POINTER_TYPE)\n \treturn comptypes\n \t  (TYPE_MAIN_VARIANT (to), TYPE_MAIN_VARIANT (from), "}, {"sha": "6c16fe484189f097afc149f884d3387b92323ecb", "filename": "gcc/testsuite/g++.dg/ext/conv1.C", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a2b77e7376a10b62a023843a64d4998fde5b5da/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fconv1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a2b77e7376a10b62a023843a64d4998fde5b5da/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fconv1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fconv1.C?ref=8a2b77e7376a10b62a023843a64d4998fde5b5da", "patch": "@@ -13,4 +13,7 @@ int main ()\n   f (i);\n   f (v);\n   g (v);\n+  enum { a } b = i;\n+  void (*p2)(int) = p;\n+  unsigned *ip = &i;\n }"}, {"sha": "74f0f3c49e3a2dd0858040a627050d6b79eff3ef", "filename": "gcc/testsuite/g++.dg/overload/cond1.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a2b77e7376a10b62a023843a64d4998fde5b5da/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Fcond1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a2b77e7376a10b62a023843a64d4998fde5b5da/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Fcond1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Fcond1.C?ref=8a2b77e7376a10b62a023843a64d4998fde5b5da", "patch": "@@ -0,0 +1,24 @@\n+// Test that converting a COND_EXPR to void doesn't result in trying to\n+// bitwise copy a class with a nontrivial copy constructor (and thus a\n+// compiler abort).\n+\n+// { dg-options \"-O\" }\n+\n+struct A {\n+  virtual ~A() { }\n+};\n+\n+A a1, a2;\n+inline A& one () { return a1; }\n+inline A& two () { return a2; }\n+\n+inline void f (int i)\n+{\n+  i ? a1 : a2;\n+  i ? one() : two();\n+}\n+\n+int main ()\n+{\n+  f (1);\n+}"}, {"sha": "cd5cf5f0cd3c3626b618f134cc8001b155d7b768", "filename": "gcc/testsuite/g++.dg/template/type1.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a2b77e7376a10b62a023843a64d4998fde5b5da/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftype1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a2b77e7376a10b62a023843a64d4998fde5b5da/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftype1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftype1.C?ref=8a2b77e7376a10b62a023843a64d4998fde5b5da", "patch": "@@ -0,0 +1,8 @@\n+// Test for helpful error messages on invalid nested-name-specifiers.\n+\n+struct A {\n+  template <class T> struct B { static int c; };\n+};\n+\n+int A::B::c;\t\t\t// { dg-error \"parameters\" }\n+int A::C::d;\t\t\t// { dg-error \"no type\" }"}]}