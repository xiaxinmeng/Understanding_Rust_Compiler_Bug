{"sha": "4f6ebe2a519e26ff881cf0ff26eac4dae807e613", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGY2ZWJlMmE1MTllMjZmZjg4MWNmMGZmMjZlYWM0ZGFlODA3ZTYxMw==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2020-05-31T20:01:41Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-07-15T13:42:35Z"}, "message": "[Ada] Ongoing work for unnamed and named container aggregates\n\ngcc/ada/\n\n\t* sem_aggr.adb (Resolve_Iterated_Component_Association): New\n\tprocedure, internal to Resolve_Container_Aggregate, to complete\n\tsemantic analysis of Iterated_Component_Associations.\n\t* exp_aggr.adb (Expand_Iterated_Component): New procedure,\n\tinternal to Expand_Container_Aggregate, to expand the construct\n\tinto an implicit loop that performs individual insertions into\n\tthe target aggregate.", "tree": {"sha": "bfb8ea39e447998d054f077d6f5024206f172437", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bfb8ea39e447998d054f077d6f5024206f172437"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f6ebe2a519e26ff881cf0ff26eac4dae807e613", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f6ebe2a519e26ff881cf0ff26eac4dae807e613", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f6ebe2a519e26ff881cf0ff26eac4dae807e613", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f6ebe2a519e26ff881cf0ff26eac4dae807e613/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c30eac83cb16fb8085683515a796f22d5e33ef5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c30eac83cb16fb8085683515a796f22d5e33ef5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c30eac83cb16fb8085683515a796f22d5e33ef5"}], "stats": {"total": 326, "additions": 288, "deletions": 38}, "files": [{"sha": "bd3a10b17b045271cb639d71fc78bf144422ebc4", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 114, "deletions": 11, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f6ebe2a519e26ff881cf0ff26eac4dae807e613/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f6ebe2a519e26ff881cf0ff26eac4dae807e613/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=4f6ebe2a519e26ff881cf0ff26eac4dae807e613", "patch": "@@ -6889,12 +6889,69 @@ package body Exp_Aggr is\n       New_Indexed_Subp    : Node_Id := Empty;\n       Assign_Indexed_Subp : Node_Id := Empty;\n \n+      procedure Expand_Iterated_Component (Comp : Node_Id);\n+\n       Aggr_Code : constant List_Id   := New_List;\n       Temp      : constant Entity_Id := Make_Temporary (Loc, 'C', N);\n \n+      Comp      : Node_Id;\n       Decl      : Node_Id;\n       Init_Stat : Node_Id;\n \n+      -------------------------------\n+      -- Expand_Iterated_Component --\n+      -------------------------------\n+\n+      procedure Expand_Iterated_Component (Comp : Node_Id) is\n+         Expr    : constant Node_Id := Expression (Comp);\n+         Loop_Id : constant Entity_Id :=\n+            Make_Defining_Identifier (Loc,\n+              Chars => Chars (Defining_Identifier (Comp)));\n+\n+         L_Range            : Node_Id;\n+         L_Iteration_Scheme : Node_Id;\n+         Loop_Stat          : Node_Id;\n+         Stats              : List_Id;\n+\n+      begin\n+         L_Range := Relocate_Node (First (Discrete_Choices (Comp)));\n+         L_Iteration_Scheme :=\n+           Make_Iteration_Scheme (Loc,\n+             Loop_Parameter_Specification =>\n+               Make_Loop_Parameter_Specification (Loc,\n+                 Defining_Identifier => Loop_Id,\n+                 Discrete_Subtype_Definition => L_Range));\n+\n+         --  Build insertion statement. for a positional aggregate only\n+         --  the expression is needed. For a named aggregate the loop\n+         --  variable, whose type is that of the key, is an additional\n+         --  parameter for the insertion operation.\n+\n+         if Present (Add_Unnamed_Subp) then\n+            Stats := New_List\n+              (Make_Procedure_Call_Statement (Loc,\n+                Name => New_Occurrence_Of (Entity (Add_Unnamed_Subp), Loc),\n+                Parameter_Associations =>\n+                  New_List (New_Occurrence_Of (Temp, Loc),\n+                     New_Copy_Tree (Expr))));\n+         else\n+            Stats := New_List\n+              (Make_Procedure_Call_Statement (Loc,\n+                 Name => New_Occurrence_Of (Entity (Add_Named_Subp), Loc),\n+                 Parameter_Associations =>\n+                   New_List (New_Occurrence_Of (Temp, Loc),\n+                   New_Occurrence_Of (Loop_Id, Loc),\n+                   New_Copy_Tree (Expr))));\n+         end if;\n+\n+         Loop_Stat :=  Make_Implicit_Loop_Statement\n+                         (Node             => N,\n+                          Identifier       => Empty,\n+                          Iteration_Scheme => L_Iteration_Scheme,\n+                          Statements       => Stats);\n+         Append (Loop_Stat, Aggr_Code);\n+      end Expand_Iterated_Component;\n+\n    begin\n       Parse_Aspect_Aggregate (Asp,\n         Empty_Subp, Add_Named_Subp, Add_Unnamed_Subp,\n@@ -6905,7 +6962,7 @@ package body Exp_Aggr is\n           Object_Definition   => New_Occurrence_Of (Typ, Loc));\n \n       Insert_Action (N, Decl);\n-      if Ekind (Entity (Empty_Subp)) = E_Constant then\n+      if Ekind (Entity (Empty_Subp)) = E_Function then\n          Init_Stat := Make_Assignment_Statement (Loc,\n            Name => New_Occurrence_Of (Temp, Loc),\n            Expression => Make_Function_Call (Loc,\n@@ -6919,24 +6976,70 @@ package body Exp_Aggr is\n \n       --  First case: positional aggregate\n \n-      if Present (Expressions (N)) then\n+      if Present (Add_Unnamed_Subp) then\n+         if Present (Expressions (N)) then\n+            declare\n+               Insert : constant Entity_Id := Entity (Add_Unnamed_Subp);\n+               Comp   : Node_Id;\n+               Stat   : Node_Id;\n+\n+            begin\n+               Comp := First (Expressions (N));\n+               while Present (Comp) loop\n+                  Stat := Make_Procedure_Call_Statement (Loc,\n+                    Name => New_Occurrence_Of (Insert, Loc),\n+                    Parameter_Associations =>\n+                      New_List (New_Occurrence_Of (Temp, Loc),\n+                         New_Copy_Tree (Comp)));\n+                  Append (Stat, Aggr_Code);\n+                  Next (Comp);\n+               end loop;\n+            end;\n+         end if;\n+\n+         --  iterated component associations may be present.\n+\n+         Comp := First (Component_Associations (N));\n+         while Present (Comp) loop\n+            Expand_Iterated_Component (Comp);\n+            Next (Comp);\n+         end loop;\n+\n+      elsif Present (Add_Named_Subp) then\n          declare\n-            Insert : constant Entity_Id := Entity (Add_Unnamed_Subp);\n-            Comp   : Node_Id;\n+            Insert : constant Entity_Id := Entity (Add_Named_Subp);\n             Stat   : Node_Id;\n+            Key    : Node_Id;\n          begin\n-            Comp := First (Expressions (N));\n+            Comp := First (Component_Associations (N));\n+\n+            --  Each component association may contain several choices,\n+            --  generate an insertion statement for each.\n+\n             while Present (Comp) loop\n-               Stat := Make_Procedure_Call_Statement (Loc,\n-                 Name => New_Occurrence_Of (Insert, Loc),\n-                 Parameter_Associations =>\n-                   New_List (New_Occurrence_Of (Temp, Loc),\n-                     New_Copy_Tree (Comp)));\n-               Append (Stat, Aggr_Code);\n+               if Nkind (Comp) = N_Iterated_Component_Association then\n+                  Expand_Iterated_Component (Comp);\n+               else\n+                  Key := First (Choices (Comp));\n+\n+                  while Present (Key) loop\n+                     Stat := Make_Procedure_Call_Statement (Loc,\n+                       Name => New_Occurrence_Of (Insert, Loc),\n+                       Parameter_Associations =>\n+                         New_List (New_Occurrence_Of (Temp, Loc),\n+                            New_Copy_Tree (Key),\n+                            New_Copy_Tree (Expression (Comp))));\n+                     Append (Stat, Aggr_Code);\n+\n+                     Next (Key);\n+                  end loop;\n+               end if;\n+\n                Next (Comp);\n             end loop;\n          end;\n       end if;\n+\n       Insert_Actions (N, Aggr_Code);\n       Rewrite (N, New_Occurrence_Of (Temp, Loc));\n       Analyze_And_Resolve (N, Typ);"}, {"sha": "b3c04eb79897b800822252f5f0d5417c2334f05e", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 174, "deletions": 27, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f6ebe2a519e26ff881cf0ff26eac4dae807e613/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f6ebe2a519e26ff881cf0ff26eac4dae807e613/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=4f6ebe2a519e26ff881cf0ff26eac4dae807e613", "patch": "@@ -2644,6 +2644,18 @@ package body Sem_Aggr is\n    ---------------------------------\n \n    procedure Resolve_Container_Aggregate (N : Node_Id; Typ : Entity_Id) is\n+      procedure Resolve_Iterated_Component_Association\n+       (Comp      : Node_Id;\n+        Key_Type  : Entity_Id;\n+        Elmt_Type : Entity_Id);\n+      --  Resolve choices and expression in an iterated component\n+      --  association. This is similar but not identical to the handling\n+      --  of this construct in an array aggregate.\n+      --  For a named container, the type of each choice must be compatible\n+      --  with the key type. For a positional container the choice must be\n+      --  a subtype indication or an iterator specification that determines\n+      --  an element type.\n+\n       Asp   : constant Node_Id := Find_Value_Of_Aspect (Typ, Aspect_Aggregate);\n \n       Empty_Subp          : Node_Id := Empty;\n@@ -2652,41 +2664,176 @@ package body Sem_Aggr is\n       New_Indexed_Subp    : Node_Id := Empty;\n       Assign_Indexed_Subp : Node_Id := Empty;\n \n+      --------------------------------------------\n+      -- Resolve_Iterated_Component_Association --\n+      --------------------------------------------\n+\n+      procedure Resolve_Iterated_Component_Association\n+       (Comp      : Node_Id;\n+        Key_Type  : Entity_Id;\n+        Elmt_Type : Entity_Id)\n+      is\n+         Choice : Node_Id;\n+         Ent    : Entity_Id;\n+         Expr   : Node_Id;\n+         Id     : Entity_Id;\n+         Typ    : Entity_Id;\n+\n+      begin\n+         if Present (Iterator_Specification (Comp)) then\n+            Error_Msg_N (\"element iterator ins aggregate Forthcoming\", N);\n+            return;\n+         end if;\n+\n+         Choice := First (Discrete_Choices (Comp));\n+\n+         while Present (Choice) loop\n+            Analyze (Choice);\n+\n+            --  Choice can be a subtype name, a range, or an expression\n+\n+            if Is_Entity_Name (Choice)\n+              and then Is_Type (Entity (Choice))\n+              and then Base_Type (Entity (Choice)) = Base_Type (Key_Type)\n+            then\n+               null;\n+\n+            elsif Present (Key_Type) then\n+               Analyze_And_Resolve (Choice, Key_Type);\n+\n+            else\n+               Typ := Etype (Choice);  --  assume unique for now\n+            end if;\n+\n+            Next (Choice);\n+         end loop;\n+\n+         --  Create a scope in which to introduce an index, which is usually\n+         --  visible in the expression for the component, and needed for its\n+         --  analysis.\n+\n+         Ent := New_Internal_Entity (E_Loop, Current_Scope, Sloc (Comp), 'L');\n+         Set_Etype  (Ent, Standard_Void_Type);\n+         Set_Parent (Ent, Parent (Comp));\n+         Push_Scope (Ent);\n+         Id :=\n+           Make_Defining_Identifier (Sloc (Comp),\n+             Chars => Chars (Defining_Identifier (Comp)));\n+\n+         --  Insert and decorate the loop variable in the current scope.\n+         --  The expression has to be analyzed once the loop variable is\n+         --  directly visible. Mark the variable as referenced to prevent\n+         --  spurious warnings, given that subsequent uses of its name in the\n+         --  expression will reference the internal (synonym) loop variable.\n+\n+         Enter_Name (Id);\n+         if No (Key_Type) then\n+            Set_Etype (Id, Typ);\n+         else\n+            Set_Etype (Id, Key_Type);\n+         end if;\n+\n+         Set_Ekind (Id, E_Variable);\n+         Set_Scope (Id, Ent);\n+         Set_Referenced (Id);\n+\n+         --  Analyze a copy of the expression, to verify legality. We use\n+         --  a copy because the expression will be analyzed anew when the\n+         --  enclosing aggregate is expanded, and the construct is rewritten\n+         --  as a loop with a new index variable.\n+\n+         Expr := New_Copy_Tree (Expression (Comp));\n+         Preanalyze_And_Resolve (Expr, Elmt_Type);\n+         End_Scope;\n+      end Resolve_Iterated_Component_Association;\n+\n    begin\n-      if Nkind (Asp) /= N_Aggregate then\n-         pragma Assert (False);\n-         return;\n-      else\n-         Set_Etype (N, Typ);\n-         Parse_Aspect_Aggregate (Asp,\n-           Empty_Subp, Add_Named_Subp, Add_Unnamed_Subp,\n-           New_Indexed_Subp, Assign_Indexed_Subp);\n+      pragma Assert (Nkind (Asp) = N_Aggregate);\n \n-         if Present (Add_Unnamed_Subp) then\n-            declare\n-               Elmt_Type : constant Entity_Id :=\n-                 Etype (Next_Formal\n-                   (First_Formal (Entity (Add_Unnamed_Subp))));\n-               Comp : Node_Id;\n-            begin\n-               if Present (Expressions (N)) then\n-                  --  positional aggregate\n+      Set_Etype (N, Typ);\n+      Parse_Aspect_Aggregate (Asp,\n+        Empty_Subp, Add_Named_Subp, Add_Unnamed_Subp,\n+        New_Indexed_Subp, Assign_Indexed_Subp);\n \n-                  Comp := First (Expressions (N));\n+      if Present (Add_Unnamed_Subp) then\n+         declare\n+            Elmt_Type : constant Entity_Id :=\n+              Etype (Next_Formal\n+                (First_Formal (Entity (Add_Unnamed_Subp))));\n+            Comp : Node_Id;\n+\n+         begin\n+            if Present (Expressions (N)) then\n+               --  positional aggregate\n+\n+               Comp := First (Expressions (N));\n+               while Present (Comp) loop\n+                  Analyze_And_Resolve (Comp, Elmt_Type);\n+                  Next (Comp);\n+               end loop;\n+            end if;\n+\n+            --  Empty aggregate, to be replaced by Empty during\n+            --  expansion, or iterated component association.\n+\n+            if Present (Component_Associations (N)) then\n+               declare\n+                  Comp : Node_Id := First (Component_Associations (N));\n+               begin\n                   while Present (Comp) loop\n-                     Analyze_And_Resolve (Comp, Elmt_Type);\n+                     if Nkind (Comp) /=\n+                       N_Iterated_Component_Association\n+                     then\n+                        Error_Msg_N (\"illegal component association \"\n+                          & \"for unnamed container aggregate\", Comp);\n+                        return;\n+                     else\n+                        Resolve_Iterated_Component_Association\n+                          (Comp, Empty, Elmt_Type);\n+                     end if;\n+\n                      Next (Comp);\n                   end loop;\n-               else\n+               end;\n+            end if;\n+         end;\n \n-                  --  Empty aggregate, to be replaced by Empty during\n-                  --  expansion.\n-                  null;\n+      elsif  Present (Add_Named_Subp) then\n+         declare\n+            --  Retrieves types of container, key, and element from the\n+            --  specified insertion procedure.\n+\n+            Container : constant Entity_Id :=\n+              First_Formal (Entity (Add_Named_Subp));\n+            Key_Type  : constant Entity_Id := Etype (Next_Formal (Container));\n+            Elmt_Type : constant Entity_Id :=\n+                                 Etype (Next_Formal (Next_Formal (Container)));\n+            Comp   : Node_Id;\n+            Choice : Node_Id;\n+\n+         begin\n+            Comp := First (Component_Associations (N));\n+            while Present (Comp) loop\n+               if Nkind (Comp) = N_Component_Association then\n+                  Choice := First (Choices (Comp));\n+\n+                  while Present (Choice) loop\n+                     Analyze_And_Resolve (Choice, Key_Type);\n+                     Next (Choice);\n+                  end loop;\n+\n+                  Analyze_And_Resolve (Expression (Comp), Elmt_Type);\n+\n+               elsif Nkind (Comp) = N_Iterated_Component_Association then\n+                  Resolve_Iterated_Component_Association\n+                    (Comp, Key_Type, Elmt_Type);\n                end if;\n-            end;\n-         else\n-            Error_Msg_N (\"indexed aggregates are forthcoming\", N);\n-         end if;\n+\n+               Next (Comp);\n+            end loop;\n+         end;\n+      else\n+         Error_Msg_N (\"indexed aggregates are forthcoming\", N);\n       end if;\n    end Resolve_Container_Aggregate;\n "}]}