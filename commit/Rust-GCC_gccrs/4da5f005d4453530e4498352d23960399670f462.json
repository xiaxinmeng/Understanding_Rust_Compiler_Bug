{"sha": "4da5f005d4453530e4498352d23960399670f462", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGRhNWYwMDVkNDQ1MzUzMGU0NDk4MzUyZDIzOTYwMzk5NjcwZjQ2Mg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2001-05-19T17:56:48Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2001-05-19T17:56:48Z"}, "message": "defaults.h (TARGET_ALLOWS_PROFILING_WITHOUT_FRAME_POINTER): New macro.\n\n\t* defaults.h (TARGET_ALLOWS_PROFILING_WITHOUT_FRAME_POINTER): New\n\tmacro.\n\t* tm.texi (TARGET_ALLOWS_PROFILING_WITHOUT_FRAME_POINTER):\n\tDocument it.\n\t* toplev.c (main): If the target does not allow profiling without\n\ta frame pointer, issue an error message.\n\t* config/i386/linux.h (TARGET_ALLOWS_PROFILING_WITHOUT_FRAME_POINTER):\n\tDefine it to false.\n\nFrom-SVN: r42312", "tree": {"sha": "e681110f1fb97b5f75bd65da47d3451a492fd3b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e681110f1fb97b5f75bd65da47d3451a492fd3b2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4da5f005d4453530e4498352d23960399670f462", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4da5f005d4453530e4498352d23960399670f462", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4da5f005d4453530e4498352d23960399670f462", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4da5f005d4453530e4498352d23960399670f462/comments", "author": null, "committer": null, "parents": [{"sha": "e86f9f3267b0127af29d48afc8e803c8e0028ae2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e86f9f3267b0127af29d48afc8e803c8e0028ae2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e86f9f3267b0127af29d48afc8e803c8e0028ae2"}], "stats": {"total": 62, "additions": 62, "deletions": 0}, "files": [{"sha": "64a0c1457212b833836eb98c305ab4b0c4bd4ece", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4da5f005d4453530e4498352d23960399670f462/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4da5f005d4453530e4498352d23960399670f462/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4da5f005d4453530e4498352d23960399670f462", "patch": "@@ -1,3 +1,14 @@\n+2001-05-19  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* defaults.h (TARGET_ALLOWS_PROFILING_WITHOUT_FRAME_POINTER): New\n+\tmacro.\n+\t* tm.texi (TARGET_ALLOWS_PROFILING_WITHOUT_FRAME_POINTER):\n+\tDocument it.\n+\t* toplev.c (main): If the target does not allow profiling without\n+\ta frame pointer, issue an error message.\n+\t* config/i386/linux.h (TARGET_ALLOWS_PROFILING_WITHOUT_FRAME_POINTER): \n+\tDefine it to false.\n+\t\n Sat May 19 07:53:42 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* recog.c (general_operand): Modify last change to allow it if reload\n@@ -102,6 +113,16 @@ Fri May 18 15:39:16 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \n 2001-05-18  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* basic-block.h (struct basic_block_def): Add documentation about\n+\twhat a basic block is, and what the various fields are used for.\n+\t* flow.c (calculate_globlal_regs_live): Add documentation about\n+\thow the algorithm works, and how we know that it will terminate.\n+\tCheck that the the inductive assumption that guarantees\n+\ttermination actually holds.\n+\t(mark_used_regs): Treat conditionally set registers as used.\n+\t(debug_regset): Add comment.\n+\t* rtl.texi (cond_exec): Add documentation.\n+\n \t* function.c (expand_function_start): Avoid creating BLKmode\n \tpseudos.\n "}, {"sha": "108a6fbaac8f469cb8dbd33b27b2914a57e0e148", "filename": "gcc/config/i386/linux.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4da5f005d4453530e4498352d23960399670f462/gcc%2Fconfig%2Fi386%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4da5f005d4453530e4498352d23960399670f462/gcc%2Fconfig%2Fi386%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Flinux.h?ref=4da5f005d4453530e4498352d23960399670f462", "patch": "@@ -73,6 +73,15 @@ Boston, MA 02111-1307, USA.  */\n     fprintf (FILE, \"\\tcall\\tmcount\\n\");\t\t\t\t\t\\\n }\n \n+/* True if it is possible to profile code that does not have a frame\n+   pointer.  \n+\n+   The GLIBC version of mcount for the x86 assumes that there is a\n+   frame, so we cannot allow profiling without a frame pointer.  */\n+\n+#undef TARGET_ALLOWS_PROFILING_WITHOUT_FRAME_POINTER\n+#define TARGET_ALLOWS_PROFILING_WITHOUT_FRAME_POINTER false\n+\n #undef SIZE_TYPE\n #define SIZE_TYPE \"unsigned int\"\n  "}, {"sha": "452bdfe44cd32982fa98b4caf287b9eadabfa7c1", "filename": "gcc/defaults.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4da5f005d4453530e4498352d23960399670f462/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4da5f005d4453530e4498352d23960399670f462/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=4da5f005d4453530e4498352d23960399670f462", "patch": "@@ -336,5 +336,12 @@ do {\t\t\t\t\t\t\t\t\\\n    ? ptrmemfunc_vbit_in_pfn : ptrmemfunc_vbit_in_delta)\n #endif\n \n+/* True if it is possible to profile code that does not have a frame\n+   pointer.  */\n+\n+#ifndef TARGET_ALLOWS_PROFILING_WITHOUT_FRAME_POINTER\n+#define TARGET_ALLOWS_PROFILING_WITHOUT_FRAME_POINTER true\n+#endif\n+\n #endif  /* GCC_DEFAULTS_H */\n "}, {"sha": "d745902d90ad95cd6ab16a089689279ce984c40c", "filename": "gcc/tm.texi", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4da5f005d4453530e4498352d23960399670f462/gcc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4da5f005d4453530e4498352d23960399670f462/gcc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftm.texi?ref=4da5f005d4453530e4498352d23960399670f462", "patch": "@@ -3992,6 +3992,21 @@ Registers or condition codes clobbered by @code{FUNCTION_PROLOGUE} or\n @item BLOCK_PROFILER_CODE\n A C function or functions which are needed in the library to\n support block profiling.\n+\n+@findex TARGET_ALLOWS_PROFILING_WITHOUT_FRAME_POINTER\n+@item TARGET_ALLOWS_PROFILING_WITHOUT_FRAME_POINTER\n+On some targets, it is impossible to use profiling when the frame\n+pointer has been omitted.  For example, on x86 GNU/Linux systems, \n+the @code{mcount} routine provided by the GNU C Library finds the\n+address of the routine that called the routine that called @code{mcount} \n+by looking in the immediate caller's stack frame.  If the immediate\n+caller has no frame pointer, this lookup will fail.\n+\n+By default, GCC assumes that the target does allow profiling when the\n+frame pointer is omitted.  This macro should be defined to a C\n+expression that evaluates to @code{false} if the target does not allow\n+profiling when the frame pointer is omitted.\n+\n @end table\n \n @node Inlining"}, {"sha": "802446e4bb558f747806fcf4ee9a9aac7a073245", "filename": "gcc/toplev.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4da5f005d4453530e4498352d23960399670f462/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4da5f005d4453530e4498352d23960399670f462/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=4da5f005d4453530e4498352d23960399670f462", "patch": "@@ -4932,6 +4932,16 @@ toplev_main (argc, argv)\n     warning (\"this target machine does not have delayed branches\");\n #endif\n \n+  /* Some operating systems do not allow profiling without a frame\n+     pointer.  */\n+  if (!TARGET_ALLOWS_PROFILING_WITHOUT_FRAME_POINTER\n+      && profile_flag\n+      && flag_omit_frame_pointer)\n+    {\n+      error (\"profiling does not work without a frame pointer\");\n+      flag_omit_frame_pointer = 0;\n+    }\n+    \n   user_label_prefix = USER_LABEL_PREFIX;\n   if (flag_leading_underscore != -1)\n     {"}]}