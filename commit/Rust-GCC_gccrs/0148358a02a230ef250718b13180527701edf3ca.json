{"sha": "0148358a02a230ef250718b13180527701edf3ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDE0ODM1OGEwMmEyMzBlZjI1MDcxOGIxMzE4MDUyNzcwMWVkZjNjYQ==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2018-06-08T12:13:20Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2018-06-08T12:13:20Z"}, "message": "Add {symbol,call}_summary::get method and use it in HSA.\n\n2018-06-08  Martin Liska  <mliska@suse.cz>\n\n\t* hsa-common.h (enum hsa_function_kind): Rename HSA_NONE to\n\tHSA_INVALID.\n\t(hsa_function_summary::hsa_function_summary): Use the new enum\n\tvalue.\n\t(hsa_gpu_implementation_p): Use hsa_summaries::get.\n\t* hsa-gen.c (hsa_get_host_function): Likewise.\n\t(get_brig_function_name): Likewise.\n\t* ipa-hsa.c (process_hsa_functions): Likewise.\n\t(ipa_hsa_write_summary): Likewise.\n\t* symbol-summary.h (symtab_duplication): Use ::get function/\n\t(get): New function.\n\nFrom-SVN: r261310", "tree": {"sha": "c391b8e527f99087eaf0e3f41c22636b16377a53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c391b8e527f99087eaf0e3f41c22636b16377a53"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0148358a02a230ef250718b13180527701edf3ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0148358a02a230ef250718b13180527701edf3ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0148358a02a230ef250718b13180527701edf3ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0148358a02a230ef250718b13180527701edf3ca/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "99353fcfe4f50d131fae9978ce9cd19bcaf243cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99353fcfe4f50d131fae9978ce9cd19bcaf243cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99353fcfe4f50d131fae9978ce9cd19bcaf243cf"}], "stats": {"total": 100, "additions": 62, "deletions": 38}, "files": [{"sha": "c306be8e60bc7d49bcd855d7bedf0622d5f7eea1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0148358a02a230ef250718b13180527701edf3ca/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0148358a02a230ef250718b13180527701edf3ca/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0148358a02a230ef250718b13180527701edf3ca", "patch": "@@ -1,3 +1,17 @@\n+2018-06-08  Martin Liska  <mliska@suse.cz>\n+\n+\t* hsa-common.h (enum hsa_function_kind): Rename HSA_NONE to\n+\tHSA_INVALID.\n+\t(hsa_function_summary::hsa_function_summary): Use the new enum\n+\tvalue.\n+\t(hsa_gpu_implementation_p): Use hsa_summaries::get.\n+\t* hsa-gen.c (hsa_get_host_function): Likewise.\n+\t(get_brig_function_name): Likewise.\n+\t* ipa-hsa.c (process_hsa_functions): Likewise.\n+\t(ipa_hsa_write_summary): Likewise.\n+\t* symbol-summary.h (symtab_duplication): Use ::get function/\n+\t(get): New function.\n+\n 2018-06-08  Martin Liska  <mliska@suse.cz>\n \n \t* config/i386/i386.c (ix86_can_inline_p): Use get_create instead"}, {"sha": "c72343fbdab4dcc7fdca1fb7527b550780cf1b9f", "filename": "gcc/hsa-common.h", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0148358a02a230ef250718b13180527701edf3ca/gcc%2Fhsa-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0148358a02a230ef250718b13180527701edf3ca/gcc%2Fhsa-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-common.h?ref=0148358a02a230ef250718b13180527701edf3ca", "patch": "@@ -1208,7 +1208,7 @@ class hsa_function_representation\n \n enum hsa_function_kind\n {\n-  HSA_NONE,\n+  HSA_INVALID,\n   HSA_KERNEL,\n   HSA_FUNCTION\n };\n@@ -1234,7 +1234,7 @@ struct hsa_function_summary\n };\n \n inline\n-hsa_function_summary::hsa_function_summary (): m_kind (HSA_NONE),\n+hsa_function_summary::hsa_function_summary (): m_kind (HSA_INVALID),\n   m_bound_function (NULL), m_gpu_implementation_p (false)\n {\n }\n@@ -1244,7 +1244,10 @@ class hsa_summary_t: public function_summary <hsa_function_summary *>\n {\n public:\n   hsa_summary_t (symbol_table *table):\n-    function_summary<hsa_function_summary *> (table) { }\n+    function_summary<hsa_function_summary *> (table)\n+  {\n+    disable_insertion_hook ();\n+  }\n \n   /* Couple GPU and HOST as gpu-specific and host-specific implementation of\n      the same function.  KIND determines whether GPU is a host-invokable kernel\n@@ -1407,10 +1410,8 @@ hsa_gpu_implementation_p (tree decl)\n   if (hsa_summaries == NULL)\n     return false;\n \n-  hsa_function_summary *s\n-    = hsa_summaries->get_create (cgraph_node::get_create (decl));\n-\n-  return s->m_gpu_implementation_p;\n+  hsa_function_summary *s = hsa_summaries->get (cgraph_node::get_create (decl));\n+  return s != NULL && s->m_gpu_implementation_p;\n }\n \n #endif /* HSA_H */"}, {"sha": "173707d8b111bf52af450cd9304537cf4a47595a", "filename": "gcc/hsa-gen.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0148358a02a230ef250718b13180527701edf3ca/gcc%2Fhsa-gen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0148358a02a230ef250718b13180527701edf3ca/gcc%2Fhsa-gen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-gen.c?ref=0148358a02a230ef250718b13180527701edf3ca", "patch": "@@ -961,9 +961,7 @@ get_symbol_for_decl (tree decl)\n tree\n hsa_get_host_function (tree decl)\n {\n-  hsa_function_summary *s\n-    = hsa_summaries->get_create (cgraph_node::get_create (decl));\n-  gcc_assert (s->m_kind != HSA_NONE);\n+  hsa_function_summary *s = hsa_summaries->get (cgraph_node::get_create (decl));\n   gcc_assert (s->m_gpu_implementation_p);\n \n   return s->m_bound_function ? s->m_bound_function->decl : NULL;\n@@ -976,9 +974,8 @@ get_brig_function_name (tree decl)\n {\n   tree d = decl;\n \n-  hsa_function_summary *s\n-    = hsa_summaries->get_create (cgraph_node::get_create (d));\n-  if (s->m_kind != HSA_NONE\n+  hsa_function_summary *s = hsa_summaries->get (cgraph_node::get_create (d));\n+  if (s != NULL\n       && s->m_gpu_implementation_p\n       && s->m_bound_function)\n     d = s->m_bound_function->decl;"}, {"sha": "7c6ceaab8fe31caa58f430daa8a66c424d7b5d67", "filename": "gcc/ipa-hsa.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0148358a02a230ef250718b13180527701edf3ca/gcc%2Fipa-hsa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0148358a02a230ef250718b13180527701edf3ca/gcc%2Fipa-hsa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-hsa.c?ref=0148358a02a230ef250718b13180527701edf3ca", "patch": "@@ -76,13 +76,13 @@ process_hsa_functions (void)\n \n   FOR_EACH_DEFINED_FUNCTION (node)\n     {\n-      hsa_function_summary *s = hsa_summaries->get_create (node);\n+      hsa_function_summary *s = hsa_summaries->get (node);\n \n       /* A linked function is skipped.  */\n-      if (s->m_bound_function != NULL)\n+      if (s != NULL && s->m_bound_function != NULL)\n \tcontinue;\n \n-      if (s->m_kind != HSA_NONE)\n+      if (s != NULL)\n \t{\n \t  if (!check_warn_node_versionable (node))\n \t    continue;\n@@ -130,11 +130,11 @@ process_hsa_functions (void)\n \n       while (e)\n \t{\n-\t  hsa_function_summary *src = hsa_summaries->get_create (node);\n-\t  if (src->m_kind != HSA_NONE && src->m_gpu_implementation_p)\n+\t  hsa_function_summary *src = hsa_summaries->get (node);\n+\t  if (src != NULL && src->m_gpu_implementation_p)\n \t    {\n-\t      hsa_function_summary *dst = hsa_summaries->get_create (e->callee);\n-\t      if (dst->m_kind != HSA_NONE && !dst->m_gpu_implementation_p)\n+\t      hsa_function_summary *dst = hsa_summaries->get (e->callee);\n+\t      if (dst != NULL && !dst->m_gpu_implementation_p)\n \t\t{\n \t\t  e->redirect_callee (dst->m_bound_function);\n \t\t  if (dump_file)\n@@ -174,9 +174,9 @@ ipa_hsa_write_summary (void)\n        lsei_next_function_in_partition (&lsei))\n     {\n       node = lsei_cgraph_node (lsei);\n-      hsa_function_summary *s = hsa_summaries->get_create (node);\n+      hsa_function_summary *s = hsa_summaries->get (node);\n \n-      if (s->m_kind != HSA_NONE)\n+      if (s != NULL)\n \tcount++;\n     }\n \n@@ -187,9 +187,9 @@ ipa_hsa_write_summary (void)\n        lsei_next_function_in_partition (&lsei))\n     {\n       node = lsei_cgraph_node (lsei);\n-      hsa_function_summary *s = hsa_summaries->get_create (node);\n+      hsa_function_summary *s = hsa_summaries->get (node);\n \n-      if (s->m_kind != HSA_NONE)\n+      if (s != NULL)\n \t{\n \t  encoder = ob->decl_state->symtab_node_encoder;\n \t  int node_ref = lto_symtab_encoder_encode (encoder, node);"}, {"sha": "8227abbf21027022d5722532a9a99eb3bbd61812", "filename": "gcc/symbol-summary.h", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0148358a02a230ef250718b13180527701edf3ca/gcc%2Fsymbol-summary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0148358a02a230ef250718b13180527701edf3ca/gcc%2Fsymbol-summary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymbol-summary.h?ref=0148358a02a230ef250718b13180527701edf3ca", "patch": "@@ -90,8 +90,13 @@ class GTY((user)) function_summary <T *>\n      does not exist it will be created.  */\n   T* get_create (cgraph_node *node)\n   {\n-    gcc_checking_assert (node->summary_uid);\n-    return get_create (node->summary_uid);\n+    return get (node->summary_uid, true);\n+  }\n+\n+  /* Getter for summary callgraph node pointer.  */\n+  T* get (cgraph_node *node)\n+  {\n+    return get (node->summary_uid, false);\n   }\n \n   /* Return number of elements handled by data structure.  */\n@@ -136,7 +141,7 @@ class GTY((user)) function_summary <T *>\n   typedef int_hash <int, 0, -1> map_hash;\n \n   /* Getter for summary callgraph ID.  */\n-  T* get_create (int uid);\n+  T *get (int uid, bool lazy_insert);\n \n   /* Indicates if insertion hook is enabled.  */\n   bool m_insertion_enabled;\n@@ -245,30 +250,37 @@ function_summary<T *>::symtab_duplication (cgraph_node *node,\n \t\t\t\t\t   cgraph_node *node2, void *data)\n {\n   function_summary *summary = (function_summary <T *> *) (data);\n-  T **v = summary->m_map.get (node->summary_uid);\n-\n-  gcc_checking_assert (node2->summary_uid > 0);\n+  T *v = summary->get (node);\n \n   if (v)\n     {\n       /* This load is necessary, because we insert a new value!  */\n-      T *data = *v;\n       T *duplicate = summary->allocate_new ();\n       summary->m_map.put (node2->summary_uid, duplicate);\n-      summary->duplicate (node, node2, data, duplicate);\n+      summary->duplicate (node, node2, v, duplicate);\n     }\n }\n \n template <typename T>\n T*\n-function_summary<T *>::get_create (int uid)\n+function_summary<T *>::get (int uid, bool lazy_insert)\n {\n-  bool existed;\n-  T **v = &m_map.get_or_insert (uid, &existed);\n-  if (!existed)\n-    *v = allocate_new ();\n+  gcc_checking_assert (uid > 0);\n \n-  return *v;\n+  if (lazy_insert)\n+    {\n+      bool existed;\n+      T **v = &m_map.get_or_insert (uid, &existed);\n+      if (!existed)\n+\t*v = allocate_new ();\n+\n+      return *v;\n+    }\n+  else\n+    {\n+      T **v = m_map.get (uid);\n+      return v == NULL ? NULL : *v;\n+    }\n }\n \n template <typename T>"}]}