{"sha": "dfb636dcd052f5f68ba6abf5b9041c3c63562438", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGZiNjM2ZGNkMDUyZjVmNjhiYTZhYmY1YjkwNDFjM2M2MzU2MjQzOA==", "commit": {"author": {"name": "Richard Sandiford", "email": "r.sandiford@uk.ibm.com", "date": "2009-06-02T19:06:56Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2009-06-02T19:06:56Z"}, "message": "Makefile.in (COLLECT2_OBJS): Add collect2-aix.o.\n\ngcc/\n\t* Makefile.in (COLLECT2_OBJS): Add collect2-aix.o.\n\t(collect2.o): Depend on collect2-aix.h.\n\t(collect2-aix.o): New rule.\n\t* collect2-aix.h: New file.\n\t* collect2-aix.c: Likewise.\n\t* collect2.c: Include collect2-aix.h.  Don't undefine\n\tOBJECT_FORMAT_COFF if CROSS_AIX_SUPPORT is defined.\n\tGuard native includes with #ifndef CROSS_DIRECTORY_STRUCTURE.\n\tUse TARGET_AIX_VERSION instead of _AIX51.\n\t* config/rs6000/aix43.h (TARGET_AIX_VERSION): Define.\n\t* config/rs6000/aix51.h (TARGET_AIX_VERSION): Likewise.\n\t* config/rs6000/aix52.h (TARGET_AIX_VERSION): Likewise.\n\t* config/rs6000/aix53.h (TARGET_AIX_VERSION): Likewise.\n\t* config/rs6000/aix61.h (TARGET_AIX_VERSION): Likewise.\n\nFrom-SVN: r148096", "tree": {"sha": "866fc7cba54f627d859513db2f05cc0ceeb96db2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/866fc7cba54f627d859513db2f05cc0ceeb96db2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dfb636dcd052f5f68ba6abf5b9041c3c63562438", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfb636dcd052f5f68ba6abf5b9041c3c63562438", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfb636dcd052f5f68ba6abf5b9041c3c63562438", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfb636dcd052f5f68ba6abf5b9041c3c63562438/comments", "author": null, "committer": null, "parents": [{"sha": "51136ae8188c4849ae4fb9451c26ef51f9801d7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51136ae8188c4849ae4fb9451c26ef51f9801d7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51136ae8188c4849ae4fb9451c26ef51f9801d7a"}], "stats": {"total": 715, "additions": 711, "deletions": 4}, "files": [{"sha": "06f8e77d3f0e4661c6f305d87ccd2df75f88085a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb636dcd052f5f68ba6abf5b9041c3c63562438/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb636dcd052f5f68ba6abf5b9041c3c63562438/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dfb636dcd052f5f68ba6abf5b9041c3c63562438", "patch": "@@ -1,3 +1,20 @@\n+2009-06-02  Richard Sandiford  <r.sandiford@uk.ibm.com>\n+\n+\t* Makefile.in (COLLECT2_OBJS): Add collect2-aix.o.\n+\t(collect2.o): Depend on collect2-aix.h.\n+\t(collect2-aix.o): New rule.\n+\t* collect2-aix.h: New file.\n+\t* collect2-aix.c: Likewise.\n+\t* collect2.c: Include collect2-aix.h.  Don't undefine\n+\tOBJECT_FORMAT_COFF if CROSS_AIX_SUPPORT is defined.\n+\tGuard native includes with #ifndef CROSS_DIRECTORY_STRUCTURE.\n+\tUse TARGET_AIX_VERSION instead of _AIX51.\n+\t* config/rs6000/aix43.h (TARGET_AIX_VERSION): Define.\n+\t* config/rs6000/aix51.h (TARGET_AIX_VERSION): Likewise.\n+\t* config/rs6000/aix52.h (TARGET_AIX_VERSION): Likewise.\n+\t* config/rs6000/aix53.h (TARGET_AIX_VERSION): Likewise.\n+\t* config/rs6000/aix61.h (TARGET_AIX_VERSION): Likewise.\n+\n 2009-06-02  Richard Sandiford  <r.sandiford@uk.ibm.com>\n \n \t* collect2.c (ignore_library): Avoid premature post-increment"}, {"sha": "381c189960c5107c08c6ee23b94ac347244afa0a", "filename": "gcc/Makefile.in", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb636dcd052f5f68ba6abf5b9041c3c63562438/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb636dcd052f5f68ba6abf5b9041c3c63562438/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=dfb636dcd052f5f68ba6abf5b9041c3c63562438", "patch": "@@ -1897,7 +1897,7 @@ ebitmap.o: ebitmap.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n \t$(EBITMAP_H) $(RTL_H) $(FLAGS_H) $(OBSTACK_H)\n sparseset.o: sparseset.c $(SYSTEM_H) sparseset.h $(CONFIG_H)\n \n-COLLECT2_OBJS = collect2.o tlink.o intl.o version.o\n+COLLECT2_OBJS = collect2.o collect2-aix.o tlink.o intl.o version.o\n COLLECT2_LIBS = @COLLECT2_LIBS@\n collect2$(exeext): $(COLLECT2_OBJS) $(LIBDEPS)\n # Don't try modifying collect2 (aka ld) in place--it might be linking this.\n@@ -1906,10 +1906,13 @@ collect2$(exeext): $(COLLECT2_OBJS) $(LIBDEPS)\n \tmv -f T$@ $@\n \n collect2.o : collect2.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) intl.h \\\n-\t$(OBSTACK_H) $(DEMANGLE_H) collect2.h version.h\n+\t$(OBSTACK_H) $(DEMANGLE_H) collect2.h collect2-aix.h version.h\n \t$(COMPILER) $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS)  \\\n \t-DTARGET_MACHINE=\\\"$(target_noncanonical)\\\" \\\n-\t-c $(srcdir)/collect2.c $(OUTPUT_OPTION)\n+\t-c $(srcdir)/collect2.c $(OUTPUT_OPTION) @TARGET_SYSTEM_ROOT_DEFINE@\n+\n+collect2-aix.o : collect2-aix.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n+    collect2-aix.h\n \n tlink.o: tlink.c $(DEMANGLE_H) $(HASHTAB_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n     $(OBSTACK_H) collect2.h intl.h"}, {"sha": "7d25e7e6b89342a9fc66c3a0c43ace775fded15e", "filename": "gcc/collect2-aix.c", "status": "added", "additions": 371, "deletions": 0, "changes": 371, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb636dcd052f5f68ba6abf5b9041c3c63562438/gcc%2Fcollect2-aix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb636dcd052f5f68ba6abf5b9041c3c63562438/gcc%2Fcollect2-aix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2-aix.c?ref=dfb636dcd052f5f68ba6abf5b9041c3c63562438", "patch": "@@ -0,0 +1,371 @@\n+/* AIX cross support for collect2.\n+   Copyright (C) 2009 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"collect2-aix.h\"\n+\n+#ifdef CROSS_AIX_SUPPORT\n+\n+#include <sys/mman.h>\n+\n+/* Read SIZE bytes starting at DATA as a big-endian value.  */\n+\n+static inline bfd_vma\n+read_value (char *data, unsigned int size)\n+{\n+  bfd_vma value;\n+  unsigned int i;\n+\n+  value = 0;\n+  for (i = 0; i < size; i++)\n+    {\n+      value <<= 8;\n+      value += (unsigned char) data[i];\n+    }\n+  return value;\n+}\n+\n+/* FIELD is a char array.  Read the contents as a big-endian integer.  */\n+#define READ_FIELD(FIELD) \\\n+  read_value (FIELD, sizeof (FIELD))\n+\n+/* OBJECT is a char pointer to an in-file object of type struct TYPE.\n+   Return the address of field FIELD.  */\n+#define OBJECT_FIELD(OBJECT, TYPE, FIELD) \\\n+  (OBJECT) + offsetof (struct TYPE, FIELD)\n+\n+/* Return the size of FIELD, which is a field of struct TYPE.  */\n+#define FIELD_SIZE(TYPE, FIELD) \\\n+  sizeof (((struct TYPE *) (0))->FIELD)\n+\n+/* OBJECT is a char pointer to an in-file object of type struct TYPE.\n+   Read the value of field FIELD as a big-endian integer.  */\n+#define READ_OBJECT(OBJECT, TYPE, FIELD) \\\n+  read_value (OBJECT_FIELD (OBJECT, TYPE, FIELD), FIELD_SIZE (TYPE, FIELD))\n+\n+/* Copy FIELD from an external structure of type TYPE at address FROM\n+   to an internal structure pointed to by TO.  */\n+#define COPY_FIELD(TO, FROM, TYPE, FIELD) \\\n+  ((TO)->FIELD = READ_OBJECT (FROM, TYPE, FIELD))\n+\n+/* Return true if STRING is less than SIZE bytes long.  EXTRA_TERMINATOR\n+   is another character (besides '\\0') that acts as a terminator,\n+   or '\\0' if none.  */\n+\n+static bool\n+string_within_bounds_p (const char *string, size_t size, char extra_terminator)\n+{\n+  const char *p;\n+\n+  for (p = string; p < string + size; p++)\n+    if (*p == '\\0' || *p == extra_terminator)\n+      return true;\n+  return false;\n+}\n+\n+/* STRING is a pointer to a char array.  Try to read its value as an\n+   ASCII-encoded integer.  On success, return true and store the result\n+   in TARGET.  */\n+#define PARSE_INTEGER(TARGET, STRING) \\\n+  (string_within_bounds_p (&(STRING)[0], sizeof (STRING), ' ') \\\n+   && ((TARGET) = strtoul (STRING, NULL, 0), true))\n+\n+/* Check that LDFILE's current object has SIZE bytes starting at OFFSET.  */\n+\n+static inline bool\n+within_object_p (LDFILE *ldfile, size_t offset, size_t size)\n+{\n+  return offset <= ldfile->object_size && offset + size <= ldfile->object_size;\n+}\n+\n+/* Try to read the file header for an XCOFF object at OFFSET bytes into\n+   LDFILE.  The object is expected to be OBJECT_SIZE bytes in size.\n+   If the object is a member of an archive, NEXT_MEMBER is the offset\n+   of the next member, otherwise it is -1.\n+\n+   Return true on success, recording the object information in LDFILE.  */\n+\n+static bool\n+read_xcoff_object (LDFILE *ldfile, size_t offset, size_t object_size,\n+\t\t   off_t next_member)\n+{\n+  struct internal_filehdr *internal;\n+  char *external;\n+  void *map;\n+  size_t page_size;\n+\n+  /* First try to map the file into memory.  */\n+  page_size = getpagesize ();\n+  ldfile->page_offset = offset & (page_size - 1);\n+  map = mmap (NULL, object_size + ldfile->page_offset, PROT_READ,\n+              MAP_SHARED, ldfile->fd, offset - ldfile->page_offset);\n+  if (map == MAP_FAILED)\n+    return false;\n+\n+  /* Record the success.  */\n+  ldfile->object = (char *) map + ldfile->page_offset;\n+  ldfile->object_size = object_size;\n+  ldfile->next_member = next_member;\n+\n+  /* Read the magic value to determine the type of file.  */\n+  if (!within_object_p (ldfile, 0, F_MAGIC_SIZE))\n+    return false;\n+\n+  internal = &ldfile->filehdr;\n+  external = ldfile->object;\n+  internal->f_magic = read_value (external, F_MAGIC_SIZE);\n+  if (internal->f_magic == U802TOCMAGIC)\n+    {\n+      if (!within_object_p (ldfile, 0, sizeof (struct external_filehdr_32)))\n+\treturn false;\n+\n+      COPY_FIELD (internal, external, external_filehdr_32, f_nscns);\n+      COPY_FIELD (internal, external, external_filehdr_32, f_timdat);\n+      COPY_FIELD (internal, external, external_filehdr_32, f_symptr);\n+      COPY_FIELD (internal, external, external_filehdr_32, f_nsyms);\n+      COPY_FIELD (internal, external, external_filehdr_32, f_opthdr);\n+      COPY_FIELD (internal, external, external_filehdr_32, f_flags);\n+      return true;\n+    }\n+  else if (internal->f_magic == U803XTOCMAGIC\n+\t   || internal->f_magic == U64_TOCMAGIC)\n+    {\n+      if (!within_object_p (ldfile, 0, sizeof (struct external_filehdr_64)))\n+\treturn false;\n+\n+      COPY_FIELD (internal, external, external_filehdr_64, f_nscns);\n+      COPY_FIELD (internal, external, external_filehdr_64, f_timdat);\n+      COPY_FIELD (internal, external, external_filehdr_64, f_symptr);\n+      COPY_FIELD (internal, external, external_filehdr_64, f_nsyms);\n+      COPY_FIELD (internal, external, external_filehdr_64, f_opthdr);\n+      COPY_FIELD (internal, external, external_filehdr_64, f_flags);\n+      return true;\n+    }\n+  return false;\n+}\n+\n+/* Try to read an archive member at OFFSET bytes into LDFILE.\n+   Return true on success, recording the member and object\n+   information in LDFILE.  */\n+\n+static bool\n+read_archive_member (LDFILE *ldfile, size_t offset)\n+{\n+  struct external_big_ar_member member;\n+  size_t namlen;\n+  size_t size;\n+  off_t next_member;\n+\n+  if (lseek (ldfile->fd, offset, SEEK_SET) >= 0\n+      && read (ldfile->fd, &member, sizeof (member)) == sizeof (member)\n+      && PARSE_INTEGER (namlen, member.ar_namlen)\n+      /* Stop once we reach the member table entry, which has a name\n+\t of length 0.  */\n+      && namlen > 0\n+      && PARSE_INTEGER (size, member.ar_size)\n+      && PARSE_INTEGER (next_member, member.ar_nextoff))\n+    {\n+      /* The archive is followed by an even-padded name, then by\n+\t a magic string of length SXCOFFARFMAG.  The object itself\n+\t starts after that. */\n+      offset += sizeof (member) + namlen + SXCOFFARFMAG;\n+      offset += offset & 1;\n+      return read_xcoff_object (ldfile, offset, size, next_member);\n+    }\n+  return false;\n+}\n+\n+/* Try to treat LDFILE as a non-empty big archive.  Return true\n+   on success, storing the member and object information for\n+   the first member in LDFILE.  */\n+\n+static bool\n+read_big_archive (LDFILE *ldfile)\n+{\n+  struct external_big_ar_filehdr filehdr;\n+  size_t offset;\n+\n+  return (lseek (ldfile->fd, 0L, SEEK_SET) == 0\n+\t  && read (ldfile->fd, &filehdr, sizeof (filehdr)) == sizeof (filehdr)\n+\t  && memcmp (filehdr.fl_magic, FL_MAGIC_BIG_AR, FL_MAGIC_SIZE) == 0\n+\t  && PARSE_INTEGER (offset, filehdr.fl_firstmemoff)\n+\t  && read_archive_member (ldfile, offset));\n+}\n+\n+/* LDFILE is a zero-initialized structure.  Try to open FILENAME,\n+   returning true on success.  */\n+\n+static bool\n+open_file (LDFILE *ldfile, const char *filename)\n+{\n+  struct stat st;\n+\n+  ldfile->fd = open (filename, O_RDONLY);\n+  if (ldfile->fd < 0)\n+    return false;\n+\n+  if (read_big_archive (ldfile))\n+    return true;\n+\n+  if (fstat (ldfile->fd, &st) < 0)\n+    return false;\n+\n+  return read_xcoff_object (ldfile, 0, st.st_size, -1);\n+}\n+\n+/* Release the memory associated with the current object, if one has\n+   been mapped.  */\n+\n+static void\n+free_object (LDFILE *ldfile)\n+{\n+  if (ldfile->object)\n+    munmap (ldfile->object - ldfile->page_offset,\n+\t    ldfile->object_size + ldfile->page_offset);\n+}\n+\n+/* Free LDFILE and all resources associated with it.  */\n+\n+static void\n+free_ldfile (LDFILE *ldfile)\n+{\n+  if (ldfile->fd >= 0)\n+    close (ldfile->fd);\n+  XDELETE (ldfile);\n+}\n+\n+/* Implement the API-defined ldopen function.  */\n+\n+LDFILE *\n+ldopen (char *filename, LDFILE *ldfile)\n+{\n+  if (ldfile == NULL)\n+    {\n+      ldfile = XCNEW (LDFILE);\n+      if (!open_file (ldfile, filename))\n+\t{\n+\t  free_object (ldfile);\n+\t  free_ldfile (ldfile);\n+\t  return NULL;\n+\t}\n+    }\n+  return ldfile;\n+}\n+\n+/* Implement the API-defined ldtbread function.  */\n+\n+int\n+ldtbread (LDFILE *ldfile, long index, SYMENT *internal)\n+{\n+  size_t offset, name_length;\n+  char *external;\n+\n+  /* Make sure that the symbol index is valid.  */\n+  if (index < 0 || index >= HEADER (ldfile).f_nsyms)\n+    return FAILURE;\n+\n+  /* Work out the offset of the symbol table entry.  */\n+  offset = HEADER (ldfile).f_symptr + index * sizeof (struct external_syment);\n+  if (!within_object_p (ldfile, offset, sizeof (struct external_syment)))\n+    return FAILURE;\n+\n+  /* Read all the fields.  The format differs between 32-bit and\n+     64-bit files.  */\n+  external = ldfile->object + offset;\n+  if (HEADER (ldfile).f_magic == U802TOCMAGIC)\n+    {\n+      /* Copy the n_zeroes/n_offset interpretation.  */\n+      internal->n_zeroes = READ_OBJECT (external, external_syment,\n+\t\t\t\t\tu.xcoff32.u.u.n_zeroes);\n+      internal->n_offset = READ_OBJECT (external, external_syment,\n+\t\t\t\t\tu.xcoff32.u.u.n_offset);\n+\n+      /* Copy the n_name interpretation.  The internal version has room\n+\t for a null terminator.  */\n+      name_length = FIELD_SIZE (external_syment, u.xcoff32.u.n_name);\n+      memcpy (internal->n_name,\n+\t      external + offsetof (struct external_syment, u.xcoff32.u.n_name),\n+\t      name_length);\n+      internal->n_name[name_length] = 0;\n+\n+      internal->n_value = READ_OBJECT (external, external_syment,\n+\t\t\t\t       u.xcoff32.n_value);\n+    }\n+  else\n+    {\n+      internal->n_zeroes = 0;\n+      internal->n_offset = READ_OBJECT (external, external_syment,\n+\t\t\t\t\tu.xcoff64.n_offset);\n+      internal->n_value = READ_OBJECT (external, external_syment,\n+\t\t\t\t       u.xcoff64.n_value);\n+    }\n+  COPY_FIELD (internal, external, external_syment, n_scnum);\n+  COPY_FIELD (internal, external, external_syment, n_type);\n+  COPY_FIELD (internal, external, external_syment, n_sclass);\n+  COPY_FIELD (internal, external, external_syment, n_numaux);\n+  return SUCCESS;\n+}\n+\n+/* Implement the API-defined ldgetname function.  */\n+\n+char *\n+ldgetname (LDFILE *ldfile, SYMENT *symbol)\n+{\n+  char *name;\n+  size_t offset;\n+\n+  /* If the zeroes field is nonzero, the name is in the symbol table\n+     entry itself.  */\n+  if (symbol->n_zeroes != 0)\n+    return symbol->n_name;\n+\n+  /* Otherwise, the symbol table entry contains an offset into the\n+     string table, which starts after the end of the symbol table.  */\n+  offset = (HEADER (ldfile).f_symptr\n+\t    + HEADER (ldfile).f_nsyms * sizeof (struct external_syment)\n+\t    + symbol->n_offset);\n+  if (offset >= ldfile->object_size)\n+    return NULL;\n+\n+  /* Make sure that the name is entirely contained within the object.  */\n+  name = ldfile->object + offset;\n+  if (!string_within_bounds_p (name, ldfile->object_size - offset, '\\0'))\n+    return NULL;\n+\n+  return name;\n+}\n+\n+/* Implement the API-defined ldclose function.  */\n+\n+int\n+ldclose (LDFILE *ldfile)\n+{\n+  free_object (ldfile);\n+  if (ldfile->next_member >= 0\n+      && read_archive_member (ldfile, ldfile->next_member))\n+    return FAILURE;\n+\n+  free_ldfile (ldfile);\n+  return SUCCESS;\n+}\n+\n+#endif"}, {"sha": "1ab313d0f34dcd408b4b5e19da6e3c172f968a08", "filename": "gcc/collect2-aix.h", "status": "added", "additions": 301, "deletions": 0, "changes": 301, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb636dcd052f5f68ba6abf5b9041c3c63562438/gcc%2Fcollect2-aix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb636dcd052f5f68ba6abf5b9041c3c63562438/gcc%2Fcollect2-aix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2-aix.h?ref=dfb636dcd052f5f68ba6abf5b9041c3c63562438", "patch": "@@ -0,0 +1,301 @@\n+/* AIX cross support for collect2.\n+   Copyright (C) 2009 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* collect2-aix.c requires mmap support.  It should otherwise be\n+   fairly portable.  */\n+#if defined(CROSS_DIRECTORY_STRUCTURE) \\\n+    && defined(TARGET_AIX_VERSION) \\\n+    && HAVE_MMAP\n+\n+#define CROSS_AIX_SUPPORT 1\n+\n+/* -------------------------------------------------------------------------\n+   Definitions adapted from bfd.  (Fairly heavily adapted in some cases.)\n+   ------------------------------------------------------------------------- */\n+\n+/* Compatiblity types for bfd.  */\n+typedef unsigned HOST_WIDE_INT bfd_vma;\n+\n+/* The size of an archive's fl_magic field.  */\n+#define FL_MAGIC_SIZE 8\n+\n+/* The expected contents of fl_magic for big archives.  */\n+#define FL_MAGIC_BIG_AR \"<bigaf>\\012\"\n+\n+/* The size of each offset string in the header of a big archive.  */\n+#define AR_BIG_OFFSET_SIZE 20\n+\n+/* The format of the file header in a \"big\" XCOFF archive.  */\n+struct external_big_ar_filehdr\n+{\n+  /* Magic string.  */\n+  char fl_magic[FL_MAGIC_SIZE];\n+\n+  /* Offset of the member table (decimal ASCII string).  */\n+  char fl_memoff[AR_BIG_OFFSET_SIZE];\n+\n+  /* Offset of the global symbol table for 32-bit objects (decimal ASCII\n+     string).  */\n+  char fl_symoff[AR_BIG_OFFSET_SIZE];\n+\n+  /* Offset of the global symbol table for 64-bit objects (decimal ASCII\n+     string).  */\n+  char fl_symoff64[AR_BIG_OFFSET_SIZE];\n+\n+  /* Offset of the first member in the archive (decimal ASCII string).  */\n+  char fl_firstmemoff[AR_BIG_OFFSET_SIZE];\n+\n+  /* Offset of the last member in the archive (decimal ASCII string).  */\n+  char fl_lastmemoff[AR_BIG_OFFSET_SIZE];\n+\n+  /* Offset of the first member on the free list (decimal ASCII\n+     string).  */\n+  char fl_freeoff[AR_BIG_OFFSET_SIZE];\n+};\n+\n+/* Each archive name is followed by this many bytes of magic string.  */\n+#define SXCOFFARFMAG 2\n+\n+/* The format of a member header in a \"big\" XCOFF archive.  */\n+struct external_big_ar_member\n+{\n+  /* File size not including the header (decimal ASCII string).  */\n+  char ar_size[AR_BIG_OFFSET_SIZE];\n+\n+  /* File offset of next archive member (decimal ASCII string).  */\n+  char ar_nextoff[AR_BIG_OFFSET_SIZE];\n+\n+  /* File offset of previous archive member (decimal ASCII string).  */\n+  char ar_prevoff[AR_BIG_OFFSET_SIZE];\n+\n+  /* File mtime (decimal ASCII string).  */\n+  char ar_date[12];\n+\n+  /* File UID (decimal ASCII string).  */\n+  char ar_uid[12];\n+\n+  /* File GID (decimal ASCII string).  */\n+  char ar_gid[12];\n+\n+  /* File mode (octal ASCII string).  */\n+  char ar_mode[12];\n+\n+  /* Length of file name (decimal ASCII string).  */\n+  char ar_namlen[4];\n+\n+  /* This structure is followed by the file name.  The length of the\n+     name is given in the namlen field.  If the length of the name is\n+     odd, the name is followed by a null byte.  The name and optional\n+     null byte are followed by XCOFFARFMAG, which is not included in\n+     namlen.  The contents of the archive member follow; the number of\n+     bytes is given in the size field.  */\n+};\n+\n+/* The known values of f_magic in an XCOFF file header.  */\n+#define U802WRMAGIC 0730\t/* Writeable text segments.  */\n+#define U802ROMAGIC 0735\t/* Readonly sharable text segments.  */\n+#define U802TOCMAGIC 0737\t/* Readonly text segments and TOC.  */\n+#define U803XTOCMAGIC 0757\t/* Aix 4.3 64-bit XCOFF.  */\n+#define U64_TOCMAGIC 0767\t/* AIX 5+ 64-bit XCOFF.  */\n+\n+/* The number of bytes in an XCOFF file's f_magic field.  */\n+#define F_MAGIC_SIZE 2\n+\n+/* The format of a 32-bit XCOFF file header.  */\n+struct external_filehdr_32\n+{\n+  /* The magic number.  */\n+  char f_magic[F_MAGIC_SIZE];\n+\n+  /* The number of sections.  */\n+  char f_nscns[2];\n+\n+  /* Time & date stamp.  */\n+  char f_timdat[4];\n+\n+  /* The offset of the symbol table from the start of the file.  */\n+  char f_symptr[4];\n+\n+  /* The number of entries in the symbol table.  */\n+  char f_nsyms[4];\n+\n+  /* The size of the auxillary header.  */\n+  char f_opthdr[2];\n+\n+  /* Flags.  */\n+  char f_flags[2];\n+};\n+\n+/* The format of a 64-bit XCOFF file header.  */\n+struct external_filehdr_64\n+{\n+  /* The magic number.  */\n+  char f_magic[F_MAGIC_SIZE];\n+\n+  /* The number of sections.  */\n+  char f_nscns[2];\n+\n+  /* Time & date stamp.  */\n+  char f_timdat[4];\n+\n+  /* The offset of the symbol table from the start of the file.  */\n+  char f_symptr[8];\n+\n+  /* The size of the auxillary header.  */\n+  char f_opthdr[2];\n+\n+  /* Flags.  */\n+  char f_flags[2];\n+\n+  /* The number of entries in the symbol table.  */\n+  char f_nsyms[4];\n+};\n+\n+/* An internal representation of the XCOFF file header.  */\n+struct internal_filehdr\n+{\n+  unsigned short f_magic;\n+  unsigned short f_nscns;\n+  long f_timdat;\n+  bfd_vma f_symptr;\n+  long f_nsyms;\n+  unsigned short f_opthdr;\n+  unsigned short f_flags;\n+};\n+\n+/* Symbol classes have their names in the debug section if this flag\n+   is set.  */\n+#define DBXMASK 0x80\n+\n+/* The format of an XCOFF symbol-table entry.  */\n+struct external_syment\n+{\n+  union {\n+    struct {\n+      union {\n+\t/* The name of the symbol.  There is an implicit null character\n+\t   after the end of the array.  */\n+\tchar n_name[8];\n+\tstruct {\n+\t  /* If n_zeroes is zero, n_offset is the offset the name from\n+\t     the start of the string table.  */\n+\t  char n_zeroes[4];\n+\t  char n_offset[4];\n+\t} u;\n+      } u;\n+\n+      /* The symbol's value.  */\n+      char n_value[4];\n+    } xcoff32;\n+    struct {\n+      /* The symbol's value.  */\n+      char n_value[8];\n+\n+      /* The offset of the symbol from the start of the string table.  */\n+      char n_offset[4];\n+    } xcoff64;\n+  } u;\n+\n+  /* The number of the section to which this symbol belongs.  */\n+  char n_scnum[2];\n+\n+  /* The type of symbol.  (It can be interpreted as an n_lang\n+     and an n_cpu byte, but we don't care about that here.)  */\n+  char n_type[2];\n+\n+  /* The class of symbol (a C_* value).  */\n+  char n_sclass[1];\n+\n+  /* The number of auxillary symbols attached to this entry.  */\n+  char n_numaux[1];\n+};\n+\n+/* Definitions required by collect2.  */\n+#define C_EXT 2\n+\n+#define F_SHROBJ 0x2000\n+\n+#define N_UNDEF ((short) 0)\n+#define N_TMASK 060\n+#define N_BTSHFT 4\n+\n+#define DT_NON 0\n+#define DT_FCN 2\n+\n+/* -------------------------------------------------------------------------\n+   Local code.\n+   ------------------------------------------------------------------------- */\n+\n+/* An internal representation of an XCOFF symbol-table entry,\n+   which is associated with the API-defined SYMENT type.  */\n+struct internal_syment\n+{\n+  char n_name[9];\n+  unsigned int n_zeroes;\n+  bfd_vma n_offset;\n+  bfd_vma n_value;\n+  short n_scnum;\n+  unsigned short n_flags;\n+  unsigned short n_type;\n+  unsigned char n_sclass;\n+  unsigned char n_numaux;\n+};\n+typedef struct internal_syment SYMENT;\n+\n+/* The internal representation of the API-defined LDFILE type.  */\n+struct internal_ldfile\n+{\n+  /* The file handle for the associated file, or -1 if it hasn't been\n+     opened yet.  */\n+  int fd;\n+\n+  /* The start of the current XCOFF object, if one has been mapped\n+     into memory.  Null otherwise.  */\n+  char *object;\n+\n+  /* The offset of OBJECT from the start of the containing page.  */\n+  size_t page_offset;\n+\n+  /* The size of the file pointed to by OBJECT.  Valid iff OFFSET\n+     is nonnull.  */\n+  size_t object_size;\n+\n+  /* The offset of the next member in an archive after OBJECT,\n+     or -1 if this isn't an archive.  Valid iff OFFSET is nonnull.  */\n+  off_t next_member;\n+\n+  /* The parsed version of the XCOFF file header.  */\n+  struct internal_filehdr filehdr;\n+};\n+typedef struct internal_ldfile LDFILE;\n+\n+/* The API allows the file header to be directly accessed via this macro.  */\n+#define HEADER(FILE) ((FILE)->filehdr)\n+\n+/* API-defined return codes.  SUCCESS must be > 0 and FAILURE must be <= 0.  */\n+#define SUCCESS 1\n+#define FAILURE 0\n+\n+/* API-defined functions.  */\n+extern LDFILE *ldopen (char *, LDFILE *);\n+extern char *ldgetname (LDFILE *, SYMENT *);\n+extern int ldtbread (LDFILE *, long, SYMENT *);\n+extern int ldclose (LDFILE *);\n+\n+#endif"}, {"sha": "660664dd29a48543405428d851c2d926a2858225", "filename": "gcc/collect2.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb636dcd052f5f68ba6abf5b9041c3c63562438/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb636dcd052f5f68ba6abf5b9041c3c63562438/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=dfb636dcd052f5f68ba6abf5b9041c3c63562438", "patch": "@@ -42,6 +42,7 @@ along with GCC; see the file COPYING3.  If not see\n #define COLLECT\n \n #include \"collect2.h\"\n+#include \"collect2-aix.h\"\n #include \"demangle.h\"\n #include \"obstack.h\"\n #include \"intl.h\"\n@@ -54,7 +55,9 @@ along with GCC; see the file COPYING3.  If not see\n    cross-versions are in the proper directories.  */\n \n #ifdef CROSS_DIRECTORY_STRUCTURE\n+#ifndef CROSS_AIX_SUPPORT\n #undef OBJECT_FORMAT_COFF\n+#endif\n #undef MD_EXEC_PREFIX\n #undef REAL_LD_FILE_NAME\n #undef REAL_NM_FILE_NAME\n@@ -72,6 +75,7 @@ along with GCC; see the file COPYING3.  If not see\n \n #ifdef OBJECT_FORMAT_COFF\n \n+#ifndef CROSS_DIRECTORY_STRUCTURE\n #include <a.out.h>\n #include <ar.h>\n \n@@ -86,6 +90,7 @@ along with GCC; see the file COPYING3.  If not see\n #endif\n \n #include <ldfcn.h>\n+#endif\n \n /* Some systems have an ISCOFF macro, but others do not.  In some cases\n    the macro may be wrong.  MY_ISCOFF is defined in tm.h files for machines\n@@ -2409,7 +2414,7 @@ scan_libraries (const char *prog_name)\n #   define GCC_SYMZERO(X)\t0\n \n /* 0757 = U803XTOCMAGIC (AIX 4.3) and 0767 = U64_TOCMAGIC (AIX V5) */\n-#ifdef _AIX51\n+#if TARGET_AIX_VERSION >= 51\n #   define GCC_CHECK_HDR(X) \\\n      ((HEADER (X).f_magic == U802TOCMAGIC && ! aix64_flag) \\\n       || (HEADER (X).f_magic == 0767 && aix64_flag))"}, {"sha": "bbe23373060645858c2058a5fbad2ce5e94c6e17", "filename": "gcc/config/rs6000/aix43.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb636dcd052f5f68ba6abf5b9041c3c63562438/gcc%2Fconfig%2Frs6000%2Faix43.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb636dcd052f5f68ba6abf5b9041c3c63562438/gcc%2Fconfig%2Frs6000%2Faix43.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faix43.h?ref=dfb636dcd052f5f68ba6abf5b9041c3c63562438", "patch": "@@ -187,3 +187,5 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n /* This target uses the aix64.opt file.  */\n #define TARGET_USES_AIX64_OPT 1\n+\n+#define TARGET_AIX_VERSION 43"}, {"sha": "32bdbb41f283abd4a510edab55fd7e17037fe411", "filename": "gcc/config/rs6000/aix51.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb636dcd052f5f68ba6abf5b9041c3c63562438/gcc%2Fconfig%2Frs6000%2Faix51.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb636dcd052f5f68ba6abf5b9041c3c63562438/gcc%2Fconfig%2Frs6000%2Faix51.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faix51.h?ref=dfb636dcd052f5f68ba6abf5b9041c3c63562438", "patch": "@@ -191,3 +191,5 @@ do {\t\t\t\t\t\t\t\t\t\\\n    but does not have crtbegin/end.  */\n \n #define TARGET_USE_JCR_SECTION 0\n+\n+#define TARGET_AIX_VERSION 51"}, {"sha": "8d6c241162196dd5b842232efaf16fdeb6588c8d", "filename": "gcc/config/rs6000/aix52.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb636dcd052f5f68ba6abf5b9041c3c63562438/gcc%2Fconfig%2Frs6000%2Faix52.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb636dcd052f5f68ba6abf5b9041c3c63562438/gcc%2Fconfig%2Frs6000%2Faix52.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faix52.h?ref=dfb636dcd052f5f68ba6abf5b9041c3c63562438", "patch": "@@ -201,3 +201,5 @@ extern long long int    atoll(const char *);\n    but does not have crtbegin/end.  */\n \n #define TARGET_USE_JCR_SECTION 0\n+\n+#define TARGET_AIX_VERSION 52"}, {"sha": "6172e76aad24d5ef8f2467332da155cb95c42f2a", "filename": "gcc/config/rs6000/aix53.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb636dcd052f5f68ba6abf5b9041c3c63562438/gcc%2Fconfig%2Frs6000%2Faix53.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb636dcd052f5f68ba6abf5b9041c3c63562438/gcc%2Fconfig%2Frs6000%2Faix53.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faix53.h?ref=dfb636dcd052f5f68ba6abf5b9041c3c63562438", "patch": "@@ -197,3 +197,5 @@ extern long long int    atoll(const char *);\n    but does not have crtbegin/end.  */\n \n #define TARGET_USE_JCR_SECTION 0\n+\n+#define TARGET_AIX_VERSION 53"}, {"sha": "c0899d8c5137ff716830caa33025af567c8c7374", "filename": "gcc/config/rs6000/aix61.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb636dcd052f5f68ba6abf5b9041c3c63562438/gcc%2Fconfig%2Frs6000%2Faix61.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb636dcd052f5f68ba6abf5b9041c3c63562438/gcc%2Fconfig%2Frs6000%2Faix61.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faix61.h?ref=dfb636dcd052f5f68ba6abf5b9041c3c63562438", "patch": "@@ -202,3 +202,5 @@ extern long long int    atoll(const char *);\n /* Default to 128 bit long double.  */\n \n #define RS6000_DEFAULT_LONG_DOUBLE_SIZE 128\n+\n+#define TARGET_AIX_VERSION 61"}]}