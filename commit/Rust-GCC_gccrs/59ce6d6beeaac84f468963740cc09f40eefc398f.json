{"sha": "59ce6d6beeaac84f468963740cc09f40eefc398f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTljZTZkNmJlZWFhYzg0ZjQ2ODk2Mzc0MGNjMDlmNDBlZWZjMzk4Zg==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-05-21T00:54:35Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-05-21T00:54:35Z"}, "message": "tree.c (array_type_nelts, [...]): Replace build with build2.\n\n\n\t* tree.c (array_type_nelts, save_expr, substitute_in_expr,\n\tget_unwidened, get_narrower): Replace build with build2.\n\t* fold-const.c (negate_expr, associate_trees, size_binop,\n\tfold_convert, eval_subst, omit_one_operand, invert_truthvalue,\n\tpedantic_omit_one_operand, distribute_bit_expr,\n\tmake_bit_field_ref, optimize_bit_field_compare,\n\tdecode_field_reference, range_binop, make_range,\n\tbuild_range_check, fold_range_test, fold_truthop,\n\toptimize_minmax_comparison, extract_muldiv_1,\n\tfold_binary_op_with_conditional_arg, fold_mathfn_compare,\n\tfold_inf_compare, fold_single_bit_test, fold,\n\tfold_relational_hi_lo, nondestructive_fold_binary_to_constant):\n\tLikewise replace build with either build2 or build3.\n\nFrom-SVN: r82083", "tree": {"sha": "b1c1405f852a8137696a61832bb98c461a7aa0a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b1c1405f852a8137696a61832bb98c461a7aa0a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/59ce6d6beeaac84f468963740cc09f40eefc398f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59ce6d6beeaac84f468963740cc09f40eefc398f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59ce6d6beeaac84f468963740cc09f40eefc398f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59ce6d6beeaac84f468963740cc09f40eefc398f/comments", "author": null, "committer": null, "parents": [{"sha": "8754a0f6a09ab97feffc72de50d1bc462fcc7ec2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8754a0f6a09ab97feffc72de50d1bc462fcc7ec2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8754a0f6a09ab97feffc72de50d1bc462fcc7ec2"}], "stats": {"total": 1114, "additions": 574, "deletions": 540}, "files": [{"sha": "bdbe5fb24d2ee5226261022db4df1e5598cce48c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59ce6d6beeaac84f468963740cc09f40eefc398f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59ce6d6beeaac84f468963740cc09f40eefc398f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=59ce6d6beeaac84f468963740cc09f40eefc398f", "patch": "@@ -1,3 +1,19 @@\n+2004-05-20  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* tree.c (array_type_nelts, save_expr, substitute_in_expr,\n+\tget_unwidened, get_narrower): Replace build with build2.\n+\t* fold-const.c (negate_expr, associate_trees, size_binop,\n+\tfold_convert, eval_subst, omit_one_operand, invert_truthvalue,\n+\tpedantic_omit_one_operand, distribute_bit_expr,\n+\tmake_bit_field_ref, optimize_bit_field_compare,\n+\tdecode_field_reference, range_binop, make_range,\n+\tbuild_range_check, fold_range_test, fold_truthop,\n+\toptimize_minmax_comparison, extract_muldiv_1, \n+\tfold_binary_op_with_conditional_arg, fold_mathfn_compare,\n+\tfold_inf_compare, fold_single_bit_test, fold,\n+\tfold_relational_hi_lo, nondestructive_fold_binary_to_constant):\n+\tLikewise replace build with either build2 or build3.\n+\n 2004-05-20  Paul Brook  <paul@codesourcery.com>\n \n \t* unwind-dw2-fde.c (get_cie_encoding): Handle dwarf3 CIE format."}, {"sha": "c4a53e0d0a3d8f51d89774a09e491bfcd88d7d2f", "filename": "gcc/fold-const.c", "status": "modified", "additions": 550, "deletions": 533, "changes": 1083, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59ce6d6beeaac84f468963740cc09f40eefc398f/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59ce6d6beeaac84f468963740cc09f40eefc398f/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=59ce6d6beeaac84f468963740cc09f40eefc398f", "patch": "@@ -995,16 +995,21 @@ negate_expr (tree t)\n \t  if (negate_expr_p (TREE_OPERAND (t, 1))\n \t      && reorder_operands_p (TREE_OPERAND (t, 0),\n \t\t\t\t     TREE_OPERAND (t, 1)))\n-\t    return fold_convert (type,\n-\t\t\t\t fold (build (MINUS_EXPR, TREE_TYPE (t),\n-\t\t\t\t\t      negate_expr (TREE_OPERAND (t, 1)),\n-\t\t\t\t\t      TREE_OPERAND (t, 0))));\n+\t    {\n+\t      tem = negate_expr (TREE_OPERAND (t, 1));\n+\t      tem = fold (build2 (MINUS_EXPR, TREE_TYPE (t),\n+\t\t\t\t  tem, TREE_OPERAND (t, 0)));\n+\t      return fold_convert (type, tem);\n+\t    }\n+\n \t  /* -(A + B) -> (-A) - B.  */\n \t  if (negate_expr_p (TREE_OPERAND (t, 0)))\n-\t    return fold_convert (type,\n-\t\t\t\t fold (build (MINUS_EXPR, TREE_TYPE (t),\n-\t\t\t\t\t      negate_expr (TREE_OPERAND (t, 0)),\n-\t\t\t\t\t      TREE_OPERAND (t, 1))));\n+\t    {\n+\t      tem = negate_expr (TREE_OPERAND (t, 0));\n+\t      tem = fold (build2 (MINUS_EXPR, TREE_TYPE (t),\n+\t\t\t\t  tem, TREE_OPERAND (t, 1)));\n+\t      return fold_convert (type, tem);\n+\t    }\n \t}\n       break;\n \n@@ -1013,9 +1018,9 @@ negate_expr (tree t)\n       if ((! FLOAT_TYPE_P (type) || flag_unsafe_math_optimizations)\n \t  && reorder_operands_p (TREE_OPERAND (t, 0), TREE_OPERAND (t, 1)))\n \treturn fold_convert (type,\n-\t\t\t     fold (build (MINUS_EXPR, TREE_TYPE (t),\n-\t\t\t\t\t  TREE_OPERAND (t, 1),\n-\t\t\t\t\t  TREE_OPERAND (t, 0))));\n+\t\t\t     fold (build2 (MINUS_EXPR, TREE_TYPE (t),\n+\t\t\t\t\t   TREE_OPERAND (t, 1),\n+\t\t\t\t\t   TREE_OPERAND (t, 0))));\n       break;\n \n     case MULT_EXPR:\n@@ -1030,15 +1035,15 @@ negate_expr (tree t)\n \t  tem = TREE_OPERAND (t, 1);\n \t  if (negate_expr_p (tem))\n \t    return fold_convert (type,\n-\t\t\t\t fold (build (TREE_CODE (t), TREE_TYPE (t),\n-\t\t\t\t\t      TREE_OPERAND (t, 0),\n-\t\t\t\t\t      negate_expr (tem))));\n+\t\t\t\t fold (build2 (TREE_CODE (t), TREE_TYPE (t),\n+\t\t\t\t\t       TREE_OPERAND (t, 0),\n+\t\t\t\t\t       negate_expr (tem))));\n \t  tem = TREE_OPERAND (t, 0);\n \t  if (negate_expr_p (tem))\n \t    return fold_convert (type,\n-\t\t\t\t fold (build (TREE_CODE (t), TREE_TYPE (t),\n-\t\t\t\t\t      negate_expr (tem),\n-\t\t\t\t\t      TREE_OPERAND (t, 1))));\n+\t\t\t\t fold (build2 (TREE_CODE (t), TREE_TYPE (t),\n+\t\t\t\t\t       negate_expr (tem),\n+\t\t\t\t\t       TREE_OPERAND (t, 1))));\n \t}\n       break;\n \n@@ -1209,18 +1214,18 @@ associate_trees (tree t1, tree t2, enum tree_code code, tree type)\n       if (code == PLUS_EXPR)\n \t{\n \t  if (TREE_CODE (t1) == NEGATE_EXPR)\n-\t    return build (MINUS_EXPR, type, fold_convert (type, t2),\n-\t\t\t  fold_convert (type, TREE_OPERAND (t1, 0)));\n+\t    return build2 (MINUS_EXPR, type, fold_convert (type, t2),\n+\t\t\t   fold_convert (type, TREE_OPERAND (t1, 0)));\n \t  else if (TREE_CODE (t2) == NEGATE_EXPR)\n-\t    return build (MINUS_EXPR, type, fold_convert (type, t1),\n-\t\t\t  fold_convert (type, TREE_OPERAND (t2, 0)));\n+\t    return build2 (MINUS_EXPR, type, fold_convert (type, t1),\n+\t\t\t   fold_convert (type, TREE_OPERAND (t2, 0)));\n \t}\n-      return build (code, type, fold_convert (type, t1),\n-\t\t    fold_convert (type, t2));\n+      return build2 (code, type, fold_convert (type, t1),\n+\t\t     fold_convert (type, t2));\n     }\n \n-  return fold (build (code, type, fold_convert (type, t1),\n-\t\t      fold_convert (type, t2)));\n+  return fold (build2 (code, type, fold_convert (type, t1),\n+\t\t       fold_convert (type, t2)));\n }\n \f\n /* Combine two integer constants ARG1 and ARG2 under operation CODE\n@@ -1662,7 +1667,7 @@ size_binop (enum tree_code code, tree arg0, tree arg1)\n   if (arg0 == error_mark_node || arg1 == error_mark_node)\n     return error_mark_node;\n \n-  return fold (build (code, type, arg0, arg1));\n+  return fold (build2 (code, type, arg0, arg1));\n }\n \n /* Given two values, either both of sizetype or both of bitsizetype,\n@@ -1945,9 +1950,9 @@ fold_convert (tree type, tree arg)\n       if (INTEGRAL_TYPE_P (orig)\n \t  || POINTER_TYPE_P (orig)\n \t  || TREE_CODE (orig) == REAL_TYPE)\n-\treturn build (COMPLEX_EXPR, type,\n-\t\t      fold_convert (TREE_TYPE (type), arg),\n-\t\t      fold_convert (TREE_TYPE (type), integer_zero_node));\n+\treturn build2 (COMPLEX_EXPR, type,\n+\t\t       fold_convert (TREE_TYPE (type), arg),\n+\t\t       fold_convert (TREE_TYPE (type), integer_zero_node));\n       if (TREE_CODE (orig) == COMPLEX_TYPE)\n \t{\n \t  tree rpart, ipart;\n@@ -1956,15 +1961,15 @@ fold_convert (tree type, tree arg)\n \t    {\n \t      rpart = fold_convert (TREE_TYPE (type), TREE_OPERAND (arg, 0));\n \t      ipart = fold_convert (TREE_TYPE (type), TREE_OPERAND (arg, 1));\n-\t      return fold (build (COMPLEX_EXPR, type, rpart, ipart));\n+\t      return fold (build2 (COMPLEX_EXPR, type, rpart, ipart));\n \t    }\n \n \t  arg = save_expr (arg);\n \t  rpart = fold (build1 (REALPART_EXPR, TREE_TYPE (orig), arg));\n \t  ipart = fold (build1 (IMAGPART_EXPR, TREE_TYPE (orig), arg));\n \t  rpart = fold_convert (TREE_TYPE (type), rpart);\n \t  ipart = fold_convert (TREE_TYPE (type), ipart);\n-\t  return fold (build (COMPLEX_EXPR, type, rpart, ipart));\n+\t  return fold (build2 (COMPLEX_EXPR, type, rpart, ipart));\n \t}\n     }\n   else if (TREE_CODE (type) == VECTOR_TYPE)\n@@ -2553,11 +2558,11 @@ eval_subst (tree arg, tree old0, tree new0, tree old1, tree new1)\n \t\t\t\t       old0, new0, old1, new1)));\n \n     case '2':\n-      return fold (build (code, type,\n-\t\t\t  eval_subst (TREE_OPERAND (arg, 0),\n-\t\t\t\t      old0, new0, old1, new1),\n-\t\t\t  eval_subst (TREE_OPERAND (arg, 1),\n-\t\t\t\t      old0, new0, old1, new1)));\n+      return fold (build2 (code, type,\n+\t\t\t   eval_subst (TREE_OPERAND (arg, 0),\n+\t\t\t\t       old0, new0, old1, new1),\n+\t\t\t   eval_subst (TREE_OPERAND (arg, 1),\n+\t\t\t\t       old0, new0, old1, new1)));\n \n     case 'e':\n       switch (code)\n@@ -2569,13 +2574,13 @@ eval_subst (tree arg, tree old0, tree new0, tree old1, tree new1)\n \t  return eval_subst (TREE_OPERAND (arg, 1), old0, new0, old1, new1);\n \n \tcase COND_EXPR:\n-\t  return fold (build (code, type,\n-\t\t\t      eval_subst (TREE_OPERAND (arg, 0),\n-\t\t\t\t\t  old0, new0, old1, new1),\n-\t\t\t      eval_subst (TREE_OPERAND (arg, 1),\n-\t\t\t\t\t  old0, new0, old1, new1),\n-\t\t\t      eval_subst (TREE_OPERAND (arg, 2),\n-\t\t\t\t\t  old0, new0, old1, new1)));\n+\t  return fold (build3 (code, type,\n+\t\t\t       eval_subst (TREE_OPERAND (arg, 0),\n+\t\t\t\t\t   old0, new0, old1, new1),\n+\t\t\t       eval_subst (TREE_OPERAND (arg, 1),\n+\t\t\t\t\t   old0, new0, old1, new1),\n+\t\t\t       eval_subst (TREE_OPERAND (arg, 2),\n+\t\t\t\t\t   old0, new0, old1, new1)));\n \tdefault:\n \t  break;\n \t}\n@@ -2600,7 +2605,7 @@ eval_subst (tree arg, tree old0, tree new0, tree old1, tree new1)\n \telse if (arg1 == old1 || operand_equal_p (arg1, old1, 0))\n \t  arg1 = new1;\n \n-\treturn fold (build (code, type, arg0, arg1));\n+\treturn fold (build2 (code, type, arg0, arg1));\n       }\n \n     default:\n@@ -2621,7 +2626,7 @@ omit_one_operand (tree type, tree result, tree omitted)\n   tree t = fold_convert (type, result);\n \n   if (TREE_SIDE_EFFECTS (omitted))\n-    return build (COMPOUND_EXPR, type, omitted, t);\n+    return build2 (COMPOUND_EXPR, type, omitted, t);\n \n   return non_lvalue (t);\n }\n@@ -2634,7 +2639,7 @@ pedantic_omit_one_operand (tree type, tree result, tree omitted)\n   tree t = fold_convert (type, result);\n \n   if (TREE_SIDE_EFFECTS (omitted))\n-    return build (COMPOUND_EXPR, type, omitted, t);\n+    return build2 (COMPOUND_EXPR, type, omitted, t);\n \n   return pedantic_non_lvalue (t);\n }\n@@ -2672,8 +2677,8 @@ invert_truthvalue (tree arg)\n \t       || code == UNGE_EXPR)\n \treturn build1 (TRUTH_NOT_EXPR, type, arg);\n       else\n-\treturn build (invert_tree_comparison (code), type,\n-\t\t      TREE_OPERAND (arg, 0), TREE_OPERAND (arg, 1));\n+\treturn build2 (invert_tree_comparison (code), type,\n+\t\t       TREE_OPERAND (arg, 0), TREE_OPERAND (arg, 1));\n     }\n \n   switch (code)\n@@ -2682,14 +2687,14 @@ invert_truthvalue (tree arg)\n       return fold_convert (type, build_int_2 (integer_zerop (arg), 0));\n \n     case TRUTH_AND_EXPR:\n-      return build (TRUTH_OR_EXPR, type,\n-\t\t    invert_truthvalue (TREE_OPERAND (arg, 0)),\n-\t\t    invert_truthvalue (TREE_OPERAND (arg, 1)));\n+      return build2 (TRUTH_OR_EXPR, type,\n+\t\t     invert_truthvalue (TREE_OPERAND (arg, 0)),\n+\t\t     invert_truthvalue (TREE_OPERAND (arg, 1)));\n \n     case TRUTH_OR_EXPR:\n-      return build (TRUTH_AND_EXPR, type,\n-\t\t    invert_truthvalue (TREE_OPERAND (arg, 0)),\n-\t\t    invert_truthvalue (TREE_OPERAND (arg, 1)));\n+      return build2 (TRUTH_AND_EXPR, type,\n+\t\t     invert_truthvalue (TREE_OPERAND (arg, 0)),\n+\t\t     invert_truthvalue (TREE_OPERAND (arg, 1)));\n \n     case TRUTH_XOR_EXPR:\n       /* Here we can invert either operand.  We invert the first operand\n@@ -2698,34 +2703,34 @@ invert_truthvalue (tree arg)\n \t negation of the second operand.  */\n \n       if (TREE_CODE (TREE_OPERAND (arg, 1)) == TRUTH_NOT_EXPR)\n-\treturn build (TRUTH_XOR_EXPR, type, TREE_OPERAND (arg, 0),\n-\t\t      TREE_OPERAND (TREE_OPERAND (arg, 1), 0));\n+\treturn build2 (TRUTH_XOR_EXPR, type, TREE_OPERAND (arg, 0),\n+\t\t       TREE_OPERAND (TREE_OPERAND (arg, 1), 0));\n       else\n-\treturn build (TRUTH_XOR_EXPR, type,\n-\t\t      invert_truthvalue (TREE_OPERAND (arg, 0)),\n-\t\t      TREE_OPERAND (arg, 1));\n+\treturn build2 (TRUTH_XOR_EXPR, type,\n+\t\t       invert_truthvalue (TREE_OPERAND (arg, 0)),\n+\t\t       TREE_OPERAND (arg, 1));\n \n     case TRUTH_ANDIF_EXPR:\n-      return build (TRUTH_ORIF_EXPR, type,\n-\t\t    invert_truthvalue (TREE_OPERAND (arg, 0)),\n-\t\t    invert_truthvalue (TREE_OPERAND (arg, 1)));\n+      return build2 (TRUTH_ORIF_EXPR, type,\n+\t\t     invert_truthvalue (TREE_OPERAND (arg, 0)),\n+\t\t     invert_truthvalue (TREE_OPERAND (arg, 1)));\n \n     case TRUTH_ORIF_EXPR:\n-      return build (TRUTH_ANDIF_EXPR, type,\n-\t\t    invert_truthvalue (TREE_OPERAND (arg, 0)),\n-\t\t    invert_truthvalue (TREE_OPERAND (arg, 1)));\n+      return build2 (TRUTH_ANDIF_EXPR, type,\n+\t\t     invert_truthvalue (TREE_OPERAND (arg, 0)),\n+\t\t     invert_truthvalue (TREE_OPERAND (arg, 1)));\n \n     case TRUTH_NOT_EXPR:\n       return TREE_OPERAND (arg, 0);\n \n     case COND_EXPR:\n-      return build (COND_EXPR, type, TREE_OPERAND (arg, 0),\n-\t\t    invert_truthvalue (TREE_OPERAND (arg, 1)),\n-\t\t    invert_truthvalue (TREE_OPERAND (arg, 2)));\n+      return build3 (COND_EXPR, type, TREE_OPERAND (arg, 0),\n+\t\t     invert_truthvalue (TREE_OPERAND (arg, 1)),\n+\t\t     invert_truthvalue (TREE_OPERAND (arg, 2)));\n \n     case COMPOUND_EXPR:\n-      return build (COMPOUND_EXPR, type, TREE_OPERAND (arg, 0),\n-\t\t    invert_truthvalue (TREE_OPERAND (arg, 1)));\n+      return build2 (COMPOUND_EXPR, type, TREE_OPERAND (arg, 0),\n+\t\t     invert_truthvalue (TREE_OPERAND (arg, 1)));\n \n     case NON_LVALUE_EXPR:\n       return invert_truthvalue (TREE_OPERAND (arg, 0));\n@@ -2742,8 +2747,8 @@ invert_truthvalue (tree arg)\n     case BIT_AND_EXPR:\n       if (!integer_onep (TREE_OPERAND (arg, 1)))\n \tbreak;\n-      return build (EQ_EXPR, type, arg,\n-\t\t    fold_convert (type, integer_zero_node));\n+      return build2 (EQ_EXPR, type, arg,\n+\t\t     fold_convert (type, integer_zero_node));\n \n     case SAVE_EXPR:\n       return build1 (TRUTH_NOT_EXPR, type, arg);\n@@ -2808,8 +2813,8 @@ distribute_bit_expr (enum tree_code code, tree type, tree arg0, tree arg1)\n   else\n     return 0;\n \n-  return fold (build (TREE_CODE (arg0), type, common,\n-\t\t      fold (build (code, type, left, right))));\n+  return fold (build2 (TREE_CODE (arg0), type, common,\n+\t\t       fold (build2 (code, type, left, right))));\n }\n \f\n /* Return a BIT_FIELD_REF of type TYPE to refer to BITSIZE bits of INNER\n@@ -2819,8 +2824,8 @@ static tree\n make_bit_field_ref (tree inner, tree type, int bitsize, int bitpos,\n \t\t    int unsignedp)\n {\n-  tree result = build (BIT_FIELD_REF, type, inner,\n-\t\t       size_int (bitsize), bitsize_int (bitpos));\n+  tree result = build3 (BIT_FIELD_REF, type, inner,\n+\t\t\tsize_int (bitsize), bitsize_int (bitpos));\n \n   BIT_FIELD_REF_UNSIGNED (result) = unsignedp;\n \n@@ -2925,15 +2930,15 @@ optimize_bit_field_compare (enum tree_code code, tree compare_type,\n   if (! const_p)\n     /* If not comparing with constant, just rework the comparison\n        and return.  */\n-    return build (code, compare_type,\n-\t\t  build (BIT_AND_EXPR, unsigned_type,\n-\t\t\t make_bit_field_ref (linner, unsigned_type,\n-\t\t\t\t\t     nbitsize, nbitpos, 1),\n-\t\t\t mask),\n-\t\t  build (BIT_AND_EXPR, unsigned_type,\n-\t\t\t make_bit_field_ref (rinner, unsigned_type,\n-\t\t\t\t\t     nbitsize, nbitpos, 1),\n-\t\t\t mask));\n+    return build2 (code, compare_type,\n+\t\t   build2 (BIT_AND_EXPR, unsigned_type,\n+\t\t\t   make_bit_field_ref (linner, unsigned_type,\n+\t\t\t\t\t       nbitsize, nbitpos, 1),\n+\t\t\t   mask),\n+\t\t   build2 (BIT_AND_EXPR, unsigned_type,\n+\t\t\t   make_bit_field_ref (rinner, unsigned_type,\n+\t\t\t\t\t       nbitsize, nbitpos, 1),\n+\t\t\t   mask));\n \n   /* Otherwise, we are handling the constant case. See if the constant is too\n      big for the field.  Warn and return a tree of for 0 (false) if so.  We do\n@@ -2994,9 +2999,9 @@ optimize_bit_field_compare (enum tree_code code, tree compare_type,\n \t\t\t\t\tsize_int (lbitpos), 0),\n \t\t\t   mask, 0));\n \n-  return build (code, compare_type,\n-\t\tbuild (BIT_AND_EXPR, unsigned_type, lhs, mask),\n-\t\trhs);\n+  return build2 (code, compare_type,\n+\t\t build2 (BIT_AND_EXPR, unsigned_type, lhs, mask),\n+\t\t rhs);\n }\n \f\n /* Subroutine for fold_truthop: decode a field reference.\n@@ -3083,8 +3088,8 @@ decode_field_reference (tree exp, HOST_WIDE_INT *pbitsize,\n \n   /* Merge it with the mask we found in the BIT_AND_EXPR, if any.  */\n   if (and_mask != 0)\n-    mask = fold (build (BIT_AND_EXPR, unsigned_type,\n-\t\t\tfold_convert (unsigned_type, and_mask), mask));\n+    mask = fold (build2 (BIT_AND_EXPR, unsigned_type,\n+\t\t\t fold_convert (unsigned_type, and_mask), mask));\n \n   *pmask = mask;\n   *pand_mask = and_mask;\n@@ -3249,8 +3254,8 @@ range_binop (enum tree_code code, tree type, tree arg0, int upper0_p,\n \n   if (arg0 != 0 && arg1 != 0)\n     {\n-      tem = fold (build (code, type != 0 ? type : TREE_TYPE (arg0),\n-\t\t\t arg0, fold_convert (TREE_TYPE (arg0), arg1)));\n+      tem = fold (build2 (code, type != 0 ? type : TREE_TYPE (arg0),\n+\t\t\t  arg0, fold_convert (TREE_TYPE (arg0), arg1)));\n       STRIP_NOPS (tem);\n       return TREE_CODE (tem) == INTEGER_CST ? tem : 0;\n     }\n@@ -3425,8 +3430,8 @@ make_range (tree exp, int *pin_p, tree *plow, tree *phigh)\n \n \tcase BIT_NOT_EXPR:\n \t  /* ~ X -> -X - 1  */\n-\t  exp = build (MINUS_EXPR, type, negate_expr (arg0),\n-\t\t       fold_convert (type, integer_one_node));\n+\t  exp = build2 (MINUS_EXPR, type, negate_expr (arg0),\n+\t\t\tfold_convert (type, integer_one_node));\n \t  continue;\n \n \tcase PLUS_EXPR:  case MINUS_EXPR:\n@@ -3507,11 +3512,11 @@ make_range (tree exp, int *pin_p, tree *plow, tree *phigh)\n \t\t  : TYPE_MAX_VALUE (type);\n \n \t      if (TYPE_PRECISION (type) == TYPE_PRECISION (TREE_TYPE (exp)))\n-\t        high_positive = fold (build (RSHIFT_EXPR, type,\n-\t\t\t\t\t     fold_convert (type,\n-\t\t\t\t\t\t\t   high_positive),\n-\t\t\t\t\t     fold_convert (type,\n-\t\t\t\t\t\t\t   integer_one_node)));\n+\t        high_positive = fold (build2 (RSHIFT_EXPR, type,\n+\t\t\t\t\t      fold_convert (type,\n+\t\t\t\t\t\t\t    high_positive),\n+\t\t\t\t\t      fold_convert (type,\n+\t\t\t\t\t\t\t    integer_one_node)));\n \n \t      /* If the low bound is specified, \"and\" the range with the\n \t\t range for which the original unsigned value will be\n@@ -3584,13 +3589,13 @@ build_range_check (tree type, tree exp, int in_p, tree low, tree high)\n     return fold_convert (type, integer_one_node);\n \n   if (low == 0)\n-    return fold (build (LE_EXPR, type, exp, high));\n+    return fold (build2 (LE_EXPR, type, exp, high));\n \n   if (high == 0)\n-    return fold (build (GE_EXPR, type, exp, low));\n+    return fold (build2 (GE_EXPR, type, exp, low));\n \n   if (operand_equal_p (low, high, 0))\n-    return fold (build (EQ_EXPR, type, exp, low));\n+    return fold (build2 (EQ_EXPR, type, exp, low));\n \n   if (integer_zerop (low))\n     {\n@@ -3629,15 +3634,15 @@ build_range_check (tree type, tree exp, int in_p, tree low, tree high)\n \t      etype = lang_hooks.types.signed_type (etype);\n \t      exp = fold_convert (etype, exp);\n \t    }\n-\t  return fold (build (GT_EXPR, type, exp,\n-\t\t\t      fold_convert (etype, integer_zero_node)));\n+\t  return fold (build2 (GT_EXPR, type, exp,\n+\t\t\t       fold_convert (etype, integer_zero_node)));\n \t}\n     }\n \n   if (0 != (value = const_binop (MINUS_EXPR, high, low, 0))\n       && ! TREE_OVERFLOW (value))\n     return build_range_check (type,\n-\t\t\t      fold (build (MINUS_EXPR, etype, exp, low)),\n+\t\t\t      fold (build2 (MINUS_EXPR, etype, exp, low)),\n \t\t\t      1, fold_convert (etype, integer_zero_node),\n \t\t\t      value);\n \n@@ -3826,10 +3831,10 @@ fold_range_test (tree exp)\n \t unless we are at top level or LHS contains a PLACEHOLDER_EXPR, in\n \t which cases we can't do this.  */\n       if (simple_operand_p (lhs))\n-\treturn build (TREE_CODE (exp) == TRUTH_ANDIF_EXPR\n-\t\t      ? TRUTH_AND_EXPR : TRUTH_OR_EXPR,\n-\t\t      TREE_TYPE (exp), TREE_OPERAND (exp, 0),\n-\t\t      TREE_OPERAND (exp, 1));\n+\treturn build2 (TREE_CODE (exp) == TRUTH_ANDIF_EXPR\n+\t\t       ? TRUTH_AND_EXPR : TRUTH_OR_EXPR,\n+\t\t       TREE_TYPE (exp), TREE_OPERAND (exp, 0),\n+\t\t       TREE_OPERAND (exp, 1));\n \n       else if (lang_hooks.decls.global_bindings_p () == 0\n \t       && ! CONTAINS_PLACEHOLDER_P (lhs))\n@@ -3842,9 +3847,9 @@ fold_range_test (tree exp)\n \t      && (0 != (rhs = build_range_check (TREE_TYPE (exp), common,\n \t\t\t\t\t\t or_op ? ! in1_p : in1_p,\n \t\t\t\t\t\t low1, high1))))\n-\t    return build (TREE_CODE (exp) == TRUTH_ANDIF_EXPR\n-\t\t\t  ? TRUTH_AND_EXPR : TRUTH_OR_EXPR,\n-\t\t\t  TREE_TYPE (exp), lhs, rhs);\n+\t    return build2 (TREE_CODE (exp) == TRUTH_ANDIF_EXPR\n+\t\t\t   ? TRUTH_AND_EXPR : TRUTH_OR_EXPR,\n+\t\t\t   TREE_TYPE (exp), lhs, rhs);\n \t}\n     }\n \n@@ -3958,10 +3963,16 @@ fold_truthop (enum tree_code code, tree truth_type, tree lhs, tree rhs)\n   rcode = TREE_CODE (rhs);\n \n   if (lcode == BIT_AND_EXPR && integer_onep (TREE_OPERAND (lhs, 1)))\n-    lcode = NE_EXPR, lhs = build (NE_EXPR, truth_type, lhs, integer_zero_node);\n+    {\n+      lhs = build2 (NE_EXPR, truth_type, lhs, integer_zero_node);\n+      lcode = NE_EXPR;\n+    }\n \n   if (rcode == BIT_AND_EXPR && integer_onep (TREE_OPERAND (rhs, 1)))\n-    rcode = NE_EXPR, rhs = build (NE_EXPR, truth_type, rhs, integer_zero_node);\n+    {\n+      rhs = build2 (NE_EXPR, truth_type, rhs, integer_zero_node);\n+      rcode = NE_EXPR;\n+    }\n \n   if (TREE_CODE_CLASS (lcode) != '<' || TREE_CODE_CLASS (rcode) != '<')\n     return 0;\n@@ -4012,8 +4023,8 @@ fold_truthop (enum tree_code code, tree truth_type, tree lhs, tree rhs)\n       else if (compcode == COMPCODE_FALSE)\n \treturn fold_convert (truth_type, integer_zero_node);\n       else if (compcode != -1)\n-\treturn build (compcode_to_comparison (compcode),\n-\t\t      truth_type, ll_arg, lr_arg);\n+\treturn build2 (compcode_to_comparison (compcode),\n+\t\t       truth_type, ll_arg, lr_arg);\n     }\n \n   /* If the RHS can be evaluated unconditionally and its operands are\n@@ -4032,22 +4043,22 @@ fold_truthop (enum tree_code code, tree truth_type, tree lhs, tree rhs)\n \t  && lcode == NE_EXPR && integer_zerop (lr_arg)\n \t  && rcode == NE_EXPR && integer_zerop (rr_arg)\n \t  && TREE_TYPE (ll_arg) == TREE_TYPE (rl_arg))\n-\treturn build (NE_EXPR, truth_type,\n-\t\t      build (BIT_IOR_EXPR, TREE_TYPE (ll_arg),\n-\t\t\t     ll_arg, rl_arg),\n-\t\t      integer_zero_node);\n+\treturn build2 (NE_EXPR, truth_type,\n+\t\t       build2 (BIT_IOR_EXPR, TREE_TYPE (ll_arg),\n+\t\t\t       ll_arg, rl_arg),\n+\t\t       integer_zero_node);\n \n       /* Convert (a == 0) && (b == 0) into (a | b) == 0.  */\n       if (code == TRUTH_AND_EXPR\n \t  && lcode == EQ_EXPR && integer_zerop (lr_arg)\n \t  && rcode == EQ_EXPR && integer_zerop (rr_arg)\n \t  && TREE_TYPE (ll_arg) == TREE_TYPE (rl_arg))\n-\treturn build (EQ_EXPR, truth_type,\n-\t\t      build (BIT_IOR_EXPR, TREE_TYPE (ll_arg),\n-\t\t\t     ll_arg, rl_arg),\n-\t\t      integer_zero_node);\n+\treturn build2 (EQ_EXPR, truth_type,\n+\t\t       build2 (BIT_IOR_EXPR, TREE_TYPE (ll_arg),\n+\t\t\t       ll_arg, rl_arg),\n+\t\t       integer_zero_node);\n \n-      return build (code, truth_type, lhs, rhs);\n+      return build2 (code, truth_type, lhs, rhs);\n     }\n \n   /* See if the comparisons can be merged.  Then get all the parameters for\n@@ -4238,14 +4249,14 @@ fold_truthop (enum tree_code code, tree truth_type, tree lhs, tree rhs)\n \t  lhs = make_bit_field_ref (ll_inner, lntype, lnbitsize, lnbitpos,\n \t\t\t\t    ll_unsignedp || rl_unsignedp);\n \t  if (! all_ones_mask_p (ll_mask, lnbitsize))\n-\t    lhs = build (BIT_AND_EXPR, lntype, lhs, ll_mask);\n+\t    lhs = build2 (BIT_AND_EXPR, lntype, lhs, ll_mask);\n \n \t  rhs = make_bit_field_ref (lr_inner, rntype, rnbitsize, rnbitpos,\n \t\t\t\t    lr_unsignedp || rr_unsignedp);\n \t  if (! all_ones_mask_p (lr_mask, rnbitsize))\n-\t    rhs = build (BIT_AND_EXPR, rntype, rhs, lr_mask);\n+\t    rhs = build2 (BIT_AND_EXPR, rntype, rhs, lr_mask);\n \n-\t  return build (wanted_code, truth_type, lhs, rhs);\n+\t  return build2 (wanted_code, truth_type, lhs, rhs);\n \t}\n \n       /* There is still another way we can do something:  If both pairs of\n@@ -4291,12 +4302,12 @@ fold_truthop (enum tree_code code, tree truth_type, tree lhs, tree rhs)\n \t    }\n \n \t  if (! all_ones_mask_p (ll_mask, ll_bitsize + rl_bitsize))\n-\t    lhs = build (BIT_AND_EXPR, type, lhs, ll_mask);\n+\t    lhs = build2 (BIT_AND_EXPR, type, lhs, ll_mask);\n \n \t  if (! all_ones_mask_p (lr_mask, lr_bitsize + rr_bitsize))\n-\t    rhs = build (BIT_AND_EXPR, type, rhs, lr_mask);\n+\t    rhs = build2 (BIT_AND_EXPR, type, rhs, lr_mask);\n \n-\t  return build (wanted_code, truth_type, lhs, rhs);\n+\t  return build2 (wanted_code, truth_type, lhs, rhs);\n \t}\n \n       return 0;\n@@ -4332,10 +4343,10 @@ fold_truthop (enum tree_code code, tree truth_type, tree lhs, tree rhs)\n \n   ll_mask = const_binop (BIT_IOR_EXPR, ll_mask, rl_mask, 0);\n   if (! all_ones_mask_p (ll_mask, lnbitsize))\n-    result = build (BIT_AND_EXPR, lntype, result, ll_mask);\n+    result = build2 (BIT_AND_EXPR, lntype, result, ll_mask);\n \n-  return build (wanted_code, truth_type, result,\n-\t\tconst_binop (BIT_IOR_EXPR, l_const, r_const, 0));\n+  return build2 (wanted_code, truth_type, result,\n+\t\t const_binop (BIT_IOR_EXPR, l_const, r_const, 0));\n }\n \f\n /* Optimize T, which is a comparison of a MIN_EXPR or MAX_EXPR with a\n@@ -4379,42 +4390,42 @@ optimize_minmax_comparison (tree t)\n \n     case GE_EXPR:\n       return\n-\tfold (build (TRUTH_ORIF_EXPR, type,\n-\t\t     optimize_minmax_comparison\n-\t\t     (build (EQ_EXPR, type, arg0, comp_const)),\n-\t\t     optimize_minmax_comparison\n-\t\t     (build (GT_EXPR, type, arg0, comp_const))));\n+\tfold (build2 (TRUTH_ORIF_EXPR, type,\n+\t\t      optimize_minmax_comparison\n+\t\t      (build2 (EQ_EXPR, type, arg0, comp_const)),\n+\t\t      optimize_minmax_comparison\n+\t\t      (build2 (GT_EXPR, type, arg0, comp_const))));\n \n     case EQ_EXPR:\n       if (op_code == MAX_EXPR && consts_equal)\n \t/* MAX (X, 0) == 0  ->  X <= 0  */\n-\treturn fold (build (LE_EXPR, type, inner, comp_const));\n+\treturn fold (build2 (LE_EXPR, type, inner, comp_const));\n \n       else if (op_code == MAX_EXPR && consts_lt)\n \t/* MAX (X, 0) == 5  ->  X == 5   */\n-\treturn fold (build (EQ_EXPR, type, inner, comp_const));\n+\treturn fold (build2 (EQ_EXPR, type, inner, comp_const));\n \n       else if (op_code == MAX_EXPR)\n \t/* MAX (X, 0) == -1  ->  false  */\n \treturn omit_one_operand (type, integer_zero_node, inner);\n \n       else if (consts_equal)\n \t/* MIN (X, 0) == 0  ->  X >= 0  */\n-\treturn fold (build (GE_EXPR, type, inner, comp_const));\n+\treturn fold (build2 (GE_EXPR, type, inner, comp_const));\n \n       else if (consts_lt)\n \t/* MIN (X, 0) == 5  ->  false  */\n \treturn omit_one_operand (type, integer_zero_node, inner);\n \n       else\n \t/* MIN (X, 0) == -1  ->  X == -1  */\n-\treturn fold (build (EQ_EXPR, type, inner, comp_const));\n+\treturn fold (build2 (EQ_EXPR, type, inner, comp_const));\n \n     case GT_EXPR:\n       if (op_code == MAX_EXPR && (consts_equal || consts_lt))\n \t/* MAX (X, 0) > 0  ->  X > 0\n \t   MAX (X, 0) > 5  ->  X > 5  */\n-\treturn fold (build (GT_EXPR, type, inner, comp_const));\n+\treturn fold (build2 (GT_EXPR, type, inner, comp_const));\n \n       else if (op_code == MAX_EXPR)\n \t/* MAX (X, 0) > -1  ->  true  */\n@@ -4427,7 +4438,7 @@ optimize_minmax_comparison (tree t)\n \n       else\n \t/* MIN (X, 0) > -1  ->  X > -1  */\n-\treturn fold (build (GT_EXPR, type, inner, comp_const));\n+\treturn fold (build2 (GT_EXPR, type, inner, comp_const));\n \n     default:\n       return t;\n@@ -4562,8 +4573,8 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n \t  if (tree_int_cst_sgn (c) < 0)\n \t    tcode = (tcode == MIN_EXPR ? MAX_EXPR : MIN_EXPR);\n \n-\t  return fold (build (tcode, ctype, fold_convert (ctype, t1),\n-\t\t\t      fold_convert (ctype, t2)));\n+\t  return fold (build2 (tcode, ctype, fold_convert (ctype, t1),\n+\t\t\t       fold_convert (ctype, t2)));\n \t}\n       break;\n \n@@ -4581,9 +4592,9 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n \t\t\t\t\t\t   size_one_node,\n \t\t\t\t\t\t   op1, 0)))\n \t  && ! TREE_OVERFLOW (t1))\n-\treturn extract_muldiv (build (tcode == LSHIFT_EXPR\n-\t\t\t\t      ? MULT_EXPR : FLOOR_DIV_EXPR,\n-\t\t\t\t      ctype, fold_convert (ctype, op0), t1),\n+\treturn extract_muldiv (build2 (tcode == LSHIFT_EXPR\n+\t\t\t\t       ? MULT_EXPR : FLOOR_DIV_EXPR,\n+\t\t\t\t       ctype, fold_convert (ctype, op0), t1),\n \t\t\t       c, code, wide_type);\n       break;\n \n@@ -4600,8 +4611,8 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n \t\t are divisible by c.  */\n \t      || (multiple_of_p (ctype, op0, c)\n \t          && multiple_of_p (ctype, op1, c))))\n-\treturn fold (build (tcode, ctype, fold_convert (ctype, t1),\n-\t\t\t    fold_convert (ctype, t2)));\n+\treturn fold (build2 (tcode, ctype, fold_convert (ctype, t1),\n+\t\t\t     fold_convert (ctype, t2)));\n \n       /* If this was a subtraction, negate OP1 and set it to be an addition.\n \t This simplifies the logic below.  */\n@@ -4651,17 +4662,17 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n       /* If we were able to eliminate our operation from the first side,\n \t apply our operation to the second side and reform the PLUS.  */\n       if (t1 != 0 && (TREE_CODE (t1) != code || code == MULT_EXPR))\n-\treturn fold (build (tcode, ctype, fold_convert (ctype, t1), op1));\n+\treturn fold (build2 (tcode, ctype, fold_convert (ctype, t1), op1));\n \n       /* The last case is if we are a multiply.  In that case, we can\n \t apply the distributive law to commute the multiply and addition\n \t if the multiplication of the constants doesn't overflow.  */\n       if (code == MULT_EXPR)\n-\treturn fold (build (tcode, ctype,\n-\t\t\t    fold (build (code, ctype,\n-\t\t\t\t\t fold_convert (ctype, op0),\n-\t\t\t\t\t fold_convert (ctype, c))),\n-\t\t\t    op1));\n+\treturn fold (build2 (tcode, ctype,\n+\t\t\t     fold (build2 (code, ctype,\n+\t\t\t\t\t   fold_convert (ctype, op0),\n+\t\t\t\t\t   fold_convert (ctype, c))),\n+\t\t\t     op1));\n \n       break;\n \n@@ -4683,12 +4694,12 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n \t do something only if the second operand is a constant.  */\n       if (same_p\n \t  && (t1 = extract_muldiv (op0, c, code, wide_type)) != 0)\n-\treturn fold (build (tcode, ctype, fold_convert (ctype, t1),\n-\t\t\t    fold_convert (ctype, op1)));\n+\treturn fold (build2 (tcode, ctype, fold_convert (ctype, t1),\n+\t\t\t     fold_convert (ctype, op1)));\n       else if (tcode == MULT_EXPR && code == MULT_EXPR\n \t       && (t1 = extract_muldiv (op1, c, code, wide_type)) != 0)\n-\treturn fold (build (tcode, ctype, fold_convert (ctype, op0),\n-\t\t\t    fold_convert (ctype, t1)));\n+\treturn fold (build2 (tcode, ctype, fold_convert (ctype, op0),\n+\t\t\t     fold_convert (ctype, t1)));\n       else if (TREE_CODE (op1) != INTEGER_CST)\n \treturn 0;\n \n@@ -4698,7 +4709,7 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n \t  && 0 != (t1 = const_binop (MULT_EXPR, fold_convert (ctype, op1),\n \t\t\t\t     fold_convert (ctype, c), 0))\n \t  && ! TREE_OVERFLOW (t1))\n-\treturn fold (build (tcode, ctype, fold_convert (ctype, op0), t1));\n+\treturn fold (build2 (tcode, ctype, fold_convert (ctype, op0), t1));\n \n       /* If these operations \"cancel\" each other, we have the main\n \t optimizations of this pass, which occur when either constant is a\n@@ -4717,15 +4728,15 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n \t\t  && code != FLOOR_MOD_EXPR && code != ROUND_MOD_EXPR)))\n \t{\n \t  if (integer_zerop (const_binop (TRUNC_MOD_EXPR, op1, c, 0)))\n-\t    return fold (build (tcode, ctype, fold_convert (ctype, op0),\n-\t\t\t\tfold_convert (ctype,\n-\t\t\t\t\t      const_binop (TRUNC_DIV_EXPR,\n-\t\t\t\t\t\t\t   op1, c, 0))));\n+\t    return fold (build2 (tcode, ctype, fold_convert (ctype, op0),\n+\t\t\t\t fold_convert (ctype,\n+\t\t\t\t\t       const_binop (TRUNC_DIV_EXPR,\n+\t\t\t\t\t\t\t    op1, c, 0))));\n \t  else if (integer_zerop (const_binop (TRUNC_MOD_EXPR, c, op1, 0)))\n-\t    return fold (build (code, ctype, fold_convert (ctype, op0),\n-\t\t\t\tfold_convert (ctype,\n-\t\t\t\t\t      const_binop (TRUNC_DIV_EXPR,\n-\t\t\t\t\t\t\t   c, op1, 0))));\n+\t    return fold (build2 (code, ctype, fold_convert (ctype, op0),\n+\t\t\t\t fold_convert (ctype,\n+\t\t\t\t\t       const_binop (TRUNC_DIV_EXPR,\n+\t\t\t\t\t\t\t    c, op1, 0))));\n \t}\n       break;\n \n@@ -4889,8 +4900,8 @@ fold_mathfn_compare (enum built_in_function fcode, enum tree_code code,\n \t\t\t\t     arg);\n \n \t  /* sqrt(x) > y is the same as x >= 0, if y is negative.  */\n-\t  return fold (build (GE_EXPR, type, arg,\n-\t\t\t      build_real (TREE_TYPE (arg), dconst0)));\n+\t  return fold (build2 (GE_EXPR, type, arg,\n+\t\t\t       build_real (TREE_TYPE (arg), dconst0)));\n \t}\n       else if (code == GT_EXPR || code == GE_EXPR)\n \t{\n@@ -4903,8 +4914,8 @@ fold_mathfn_compare (enum built_in_function fcode, enum tree_code code,\n \t    {\n \t      /* sqrt(x) > y is x == +Inf, when y is very large.  */\n \t      if (HONOR_INFINITIES (mode))\n-\t\treturn fold (build (EQ_EXPR, type, arg,\n-\t\t\t\t    build_real (TREE_TYPE (arg), c2)));\n+\t\treturn fold (build2 (EQ_EXPR, type, arg,\n+\t\t\t\t     build_real (TREE_TYPE (arg), c2)));\n \n \t      /* sqrt(x) > y is always false, when y is very large\n \t\t and we don't care about infinities.  */\n@@ -4914,8 +4925,8 @@ fold_mathfn_compare (enum built_in_function fcode, enum tree_code code,\n \t    }\n \n \t  /* sqrt(x) > c is the same as x > c*c.  */\n-\t  return fold (build (code, type, arg,\n-\t\t\t      build_real (TREE_TYPE (arg), c2)));\n+\t  return fold (build2 (code, type, arg,\n+\t\t\t       build_real (TREE_TYPE (arg), c2)));\n \t}\n       else if (code == LT_EXPR || code == LE_EXPR)\n \t{\n@@ -4936,47 +4947,47 @@ fold_mathfn_compare (enum built_in_function fcode, enum tree_code code,\n \t      /* sqrt(x) < y is x != +Inf when y is very large and we\n \t\t don't care about NaNs.  */\n \t      if (! HONOR_NANS (mode))\n-\t\treturn fold (build (NE_EXPR, type, arg,\n-\t\t\t\t    build_real (TREE_TYPE (arg), c2)));\n+\t\treturn fold (build2 (NE_EXPR, type, arg,\n+\t\t\t\t     build_real (TREE_TYPE (arg), c2)));\n \n \t      /* sqrt(x) < y is x >= 0 when y is very large and we\n \t\t don't care about Infinities.  */\n \t      if (! HONOR_INFINITIES (mode))\n-\t\treturn fold (build (GE_EXPR, type, arg,\n-\t\t\t\t    build_real (TREE_TYPE (arg), dconst0)));\n+\t\treturn fold (build2 (GE_EXPR, type, arg,\n+\t\t\t\t     build_real (TREE_TYPE (arg), dconst0)));\n \n \t      /* sqrt(x) < y is x >= 0 && x != +Inf, when y is large.  */\n \t      if (lang_hooks.decls.global_bindings_p () != 0\n \t\t  || CONTAINS_PLACEHOLDER_P (arg))\n \t\treturn NULL_TREE;\n \n \t      arg = save_expr (arg);\n-\t      return fold (build (TRUTH_ANDIF_EXPR, type,\n-\t\t\t\t  fold (build (GE_EXPR, type, arg,\n-\t\t\t\t\t       build_real (TREE_TYPE (arg),\n-\t\t\t\t\t\t\t   dconst0))),\n-\t\t\t\t  fold (build (NE_EXPR, type, arg,\n-\t\t\t\t\t       build_real (TREE_TYPE (arg),\n-\t\t\t\t\t\t\t   c2)))));\n+\t      return fold (build2 (TRUTH_ANDIF_EXPR, type,\n+\t\t\t\t   fold (build2 (GE_EXPR, type, arg,\n+\t\t\t\t\t\t build_real (TREE_TYPE (arg),\n+\t\t\t\t\t\t\t     dconst0))),\n+\t\t\t\t   fold (build2 (NE_EXPR, type, arg,\n+\t\t\t\t\t\t build_real (TREE_TYPE (arg),\n+\t\t\t\t\t\t\t     c2)))));\n \t    }\n \n \t  /* sqrt(x) < c is the same as x < c*c, if we ignore NaNs.  */\n \t  if (! HONOR_NANS (mode))\n-\t    return fold (build (code, type, arg,\n-\t\t\t\tbuild_real (TREE_TYPE (arg), c2)));\n+\t    return fold (build2 (code, type, arg,\n+\t\t\t\t build_real (TREE_TYPE (arg), c2)));\n \n \t  /* sqrt(x) < c is the same as x >= 0 && x < c*c.  */\n \t  if (lang_hooks.decls.global_bindings_p () == 0\n \t      && ! CONTAINS_PLACEHOLDER_P (arg))\n \t    {\n \t      arg = save_expr (arg);\n-\t      return fold (build (TRUTH_ANDIF_EXPR, type,\n-\t\t\t\t  fold (build (GE_EXPR, type, arg,\n-\t\t\t\t\t       build_real (TREE_TYPE (arg),\n-\t\t\t\t\t\t\t   dconst0))),\n-\t\t\t\t  fold (build (code, type, arg,\n-\t\t\t\t\t       build_real (TREE_TYPE (arg),\n-\t\t\t\t\t\t\t   c2)))));\n+\t      return fold (build2 (TRUTH_ANDIF_EXPR, type,\n+\t\t\t\t   fold (build2 (GE_EXPR, type, arg,\n+\t\t\t\t\t\t build_real (TREE_TYPE (arg),\n+\t\t\t\t\t\t\t     dconst0))),\n+\t\t\t\t   fold (build2 (code, type, arg,\n+\t\t\t\t\t\t build_real (TREE_TYPE (arg),\n+\t\t\t\t\t\t\t     c2)))));\n \t    }\n \t}\n     }\n@@ -5031,31 +5042,31 @@ fold_inf_compare (enum tree_code code, tree type, tree arg0, tree arg1)\n \t  && ! CONTAINS_PLACEHOLDER_P (arg0))\n \t{\n \t  arg0 = save_expr (arg0);\n-\t  return fold (build (EQ_EXPR, type, arg0, arg0));\n+\t  return fold (build2 (EQ_EXPR, type, arg0, arg0));\n \t}\n       break;\n \n     case EQ_EXPR:\n     case GE_EXPR:\n       /* x == +Inf and x >= +Inf are always equal to x > DBL_MAX.  */\n       real_maxval (&max, neg, mode);\n-      return fold (build (neg ? LT_EXPR : GT_EXPR, type,\n-\t\t\t  arg0, build_real (TREE_TYPE (arg0), max)));\n+      return fold (build2 (neg ? LT_EXPR : GT_EXPR, type,\n+\t\t\t   arg0, build_real (TREE_TYPE (arg0), max)));\n \n     case LT_EXPR:\n       /* x < +Inf is always equal to x <= DBL_MAX.  */\n       real_maxval (&max, neg, mode);\n-      return fold (build (neg ? GE_EXPR : LE_EXPR, type,\n-\t\t\t  arg0, build_real (TREE_TYPE (arg0), max)));\n+      return fold (build2 (neg ? GE_EXPR : LE_EXPR, type,\n+\t\t\t   arg0, build_real (TREE_TYPE (arg0), max)));\n \n     case NE_EXPR:\n       /* x != +Inf is always equal to !(x > DBL_MAX).  */\n       real_maxval (&max, neg, mode);\n       if (! HONOR_NANS (mode))\n-\treturn fold (build (neg ? GE_EXPR : LE_EXPR, type,\n-\t\t\t    arg0, build_real (TREE_TYPE (arg0), max)));\n-      temp = fold (build (neg ? LT_EXPR : GT_EXPR, type,\n-\t\t\t  arg0, build_real (TREE_TYPE (arg0), max)));\n+\treturn fold (build2 (neg ? GE_EXPR : LE_EXPR, type,\n+\t\t\t     arg0, build_real (TREE_TYPE (arg0), max)));\n+      temp = fold (build2 (neg ? LT_EXPR : GT_EXPR, type,\n+\t\t\t   arg0, build_real (TREE_TYPE (arg0), max)));\n       return fold (build1 (TRUTH_NOT_EXPR, type, temp));\n \n     default:\n@@ -5259,9 +5270,9 @@ fold_single_bit_test (enum tree_code code, tree arg0, tree arg1,\n       if (arg00 != NULL_TREE)\n \t{\n \t  tree stype = lang_hooks.types.signed_type (TREE_TYPE (arg00));\n-\t  return fold (build (code == EQ_EXPR ? GE_EXPR : LT_EXPR, result_type,\n-\t\t\t      fold_convert (stype, arg00),\n-\t\t\t      fold_convert (stype, integer_zero_node)));\n+\t  return fold (build2 (code == EQ_EXPR ? GE_EXPR : LT_EXPR,\n+\t\t\t       result_type, fold_convert (stype, arg00),\n+\t\t\t       fold_convert (stype, integer_zero_node)));\n \t}\n \n       /* At this point, we know that arg0 is not testing the sign bit.  */\n@@ -5300,16 +5311,16 @@ fold_single_bit_test (enum tree_code code, tree arg0, tree arg1,\n       inner = fold_convert (intermediate_type, inner);\n \n       if (bitnum != 0)\n-\tinner = build (RSHIFT_EXPR, intermediate_type,\n-\t\t       inner, size_int (bitnum));\n+\tinner = build2 (RSHIFT_EXPR, intermediate_type,\n+\t\t\tinner, size_int (bitnum));\n \n       if (code == EQ_EXPR)\n-\tinner = build (BIT_XOR_EXPR, intermediate_type,\n-\t\t       inner, integer_one_node);\n+\tinner = build2 (BIT_XOR_EXPR, intermediate_type,\n+\t\t\tinner, integer_one_node);\n \n       /* Put the AND last so it can combine with more things.  */\n-      inner = build (BIT_AND_EXPR, intermediate_type,\n-\t\t     inner, integer_one_node);\n+      inner = build2 (BIT_AND_EXPR, intermediate_type,\n+\t\t      inner, integer_one_node);\n \n       /* Make sure to return the proper type.  */\n       inner = fold_convert (result_type, inner);\n@@ -5499,8 +5510,8 @@ fold (tree expr)\n      to ARG1 to reduce the number of tests below.  */\n   if (commutative_tree_code (code)\n       && tree_swap_operands_p (arg0, arg1, true))\n-    return fold (build (code, type, TREE_OPERAND (t, 1),\n-\t\t\tTREE_OPERAND (t, 0)));\n+    return fold (build2 (code, type, TREE_OPERAND (t, 1),\n+\t\t\t TREE_OPERAND (t, 0)));\n \n   /* Now WINS is set as described above,\n      ARG0 is the first operand of EXPR,\n@@ -5531,11 +5542,11 @@ fold (tree expr)\n \t\t  || (TREE_CODE (arg0) == BIT_AND_EXPR\n \t\t      && integer_onep (TREE_OPERAND (arg0, 1)))))))\n     {\n-      tem = fold (build (code == BIT_AND_EXPR ? TRUTH_AND_EXPR\n-\t\t       : code == BIT_IOR_EXPR ? TRUTH_OR_EXPR\n-\t\t       : TRUTH_XOR_EXPR,\n-\t\t       type, fold_convert (boolean_type_node, arg0),\n-\t\t       fold_convert (boolean_type_node, arg1)));\n+      tem = fold (build2 (code == BIT_AND_EXPR ? TRUTH_AND_EXPR\n+\t\t\t  : code == BIT_IOR_EXPR ? TRUTH_OR_EXPR\n+\t\t\t  : TRUTH_XOR_EXPR,\n+\t\t\t  type, fold_convert (boolean_type_node, arg0),\n+\t\t\t  fold_convert (boolean_type_node, arg1)));\n \n       if (code == EQ_EXPR)\n \ttem = invert_truthvalue (tem);\n@@ -5546,8 +5557,8 @@ fold (tree expr)\n   if (TREE_CODE_CLASS (code) == '1')\n     {\n       if (TREE_CODE (arg0) == COMPOUND_EXPR)\n-\treturn build (COMPOUND_EXPR, type, TREE_OPERAND (arg0, 0),\n-\t\t      fold (build1 (code, type, TREE_OPERAND (arg0, 1))));\n+\treturn build2 (COMPOUND_EXPR, type, TREE_OPERAND (arg0, 0),\n+\t\t       fold (build1 (code, type, TREE_OPERAND (arg0, 1))));\n       else if (TREE_CODE (arg0) == COND_EXPR)\n \t{\n \t  tree arg01 = TREE_OPERAND (arg0, 1);\n@@ -5556,8 +5567,8 @@ fold (tree expr)\n \t    arg01 = fold (build1 (code, type, arg01));\n \t  if (! VOID_TYPE_P (TREE_TYPE (arg02)))\n \t    arg02 = fold (build1 (code, type, arg02));\n-\t  tem = fold (build (COND_EXPR, type, TREE_OPERAND (arg0, 0),\n-\t\t\t     arg01, arg02));\n+\t  tem = fold (build3 (COND_EXPR, type, TREE_OPERAND (arg0, 0),\n+\t\t\t      arg01, arg02));\n \n \t  /* If this was a conversion, and all we did was to move into\n \t     inside the COND_EXPR, bring it back out.  But leave it if\n@@ -5582,12 +5593,12 @@ fold (tree expr)\n \t\t\t(TREE_TYPE (TREE_OPERAND (TREE_OPERAND (tem, 1), 0))))\n \t\t    && TYPE_PRECISION (TREE_TYPE (tem)) <= BITS_PER_WORD))\n \t    tem = build1 (code, type,\n-\t\t\t  build (COND_EXPR,\n-\t\t\t\t TREE_TYPE (TREE_OPERAND\n-\t\t\t\t\t    (TREE_OPERAND (tem, 1), 0)),\n-\t\t\t\t TREE_OPERAND (tem, 0),\n-\t\t\t\t TREE_OPERAND (TREE_OPERAND (tem, 1), 0),\n-\t\t\t\t TREE_OPERAND (TREE_OPERAND (tem, 2), 0)));\n+\t\t\t  build3 (COND_EXPR,\n+\t\t\t\t  TREE_TYPE (TREE_OPERAND\n+\t\t\t\t\t     (TREE_OPERAND (tem, 1), 0)),\n+\t\t\t\t  TREE_OPERAND (tem, 0),\n+\t\t\t\t  TREE_OPERAND (TREE_OPERAND (tem, 1), 0),\n+\t\t\t\t  TREE_OPERAND (TREE_OPERAND (tem, 2), 0)));\n \t  return tem;\n \t}\n       else if (TREE_CODE_CLASS (TREE_CODE (arg0)) == '<')\n@@ -5599,30 +5610,33 @@ fold (tree expr)\n \t      return arg0;\n \t    }\n \t  else if (TREE_CODE (type) != INTEGER_TYPE)\n-\t    return fold (build (COND_EXPR, type, arg0,\n-\t\t\t\tfold (build1 (code, type, integer_one_node)),\n-\t\t\t\tfold (build1 (code, type, integer_zero_node))));\n+\t    return fold (build3 (COND_EXPR, type, arg0,\n+\t\t\t\t fold (build1 (code, type,\n+\t\t\t\t\t       integer_one_node)),\n+\t\t\t\t fold (build1 (code, type,\n+\t\t\t\t\t       integer_zero_node))));\n \t}\n    }\n   else if (TREE_CODE_CLASS (code) == '<'\n \t   && TREE_CODE (arg0) == COMPOUND_EXPR)\n-    return build (COMPOUND_EXPR, type, TREE_OPERAND (arg0, 0),\n-\t\t  fold (build (code, type, TREE_OPERAND (arg0, 1), arg1)));\n+    return build2 (COMPOUND_EXPR, type, TREE_OPERAND (arg0, 0),\n+\t\t   fold (build2 (code, type, TREE_OPERAND (arg0, 1), arg1)));\n   else if (TREE_CODE_CLASS (code) == '<'\n \t   && TREE_CODE (arg1) == COMPOUND_EXPR)\n-    return build (COMPOUND_EXPR, type, TREE_OPERAND (arg1, 0),\n-\t\t  fold (build (code, type, arg0, TREE_OPERAND (arg1, 1))));\n+    return build2 (COMPOUND_EXPR, type, TREE_OPERAND (arg1, 0),\n+\t\t   fold (build2 (code, type, arg0, TREE_OPERAND (arg1, 1))));\n   else if (TREE_CODE_CLASS (code) == '2'\n \t   || TREE_CODE_CLASS (code) == '<')\n     {\n       if (TREE_CODE (arg0) == COMPOUND_EXPR)\n-\treturn build (COMPOUND_EXPR, type, TREE_OPERAND (arg0, 0),\n-\t\t      fold (build (code, type, TREE_OPERAND (arg0, 1), arg1)));\n+\treturn build2 (COMPOUND_EXPR, type, TREE_OPERAND (arg0, 0),\n+\t\t       fold (build2 (code, type, TREE_OPERAND (arg0, 1),\n+\t\t\t\t     arg1)));\n       if (TREE_CODE (arg1) == COMPOUND_EXPR\n \t  && reorder_operands_p (arg0, TREE_OPERAND (arg1, 0)))\n-\treturn build (COMPOUND_EXPR, type, TREE_OPERAND (arg1, 0),\n-\t\t      fold (build (code, type,\n-\t\t\t\t   arg0, TREE_OPERAND (arg1, 1))));\n+\treturn build2 (COMPOUND_EXPR, type, TREE_OPERAND (arg1, 0),\n+\t\t       fold (build2 (code, type,\n+\t\t\t\t     arg0, TREE_OPERAND (arg1, 1))));\n \n       if (TREE_CODE (arg0) == COND_EXPR\n \t  || TREE_CODE_CLASS (TREE_CODE (arg0)) == '<')\n@@ -5752,7 +5766,7 @@ fold (tree expr)\n \t  tem = copy_node (t);\n \t  TREE_OPERAND (tem, 0) = TREE_OPERAND (prev, 1);\n \t  /* First do the assignment, then return converted constant.  */\n-\t  tem = build (COMPOUND_EXPR, TREE_TYPE (tem), prev, fold (tem));\n+\t  tem = build2 (COMPOUND_EXPR, TREE_TYPE (tem), prev, fold (tem));\n \t  TREE_NO_WARNING (tem) = 1;\n \t  TREE_USED (tem) = 1;\n \t  return tem;\n@@ -5796,9 +5810,9 @@ fold (tree expr)\n #endif\n \t    }\n \t  if (change)\n-\t    return fold (build (BIT_AND_EXPR, type,\n-\t\t\t\tfold_convert (type, and0),\n-\t\t\t\tfold_convert (type, and1)));\n+\t    return fold (build2 (BIT_AND_EXPR, type,\n+\t\t\t\t fold_convert (type, and0),\n+\t\t\t\t fold_convert (type, and1)));\n \t}\n \n       /* Convert (T1)((T2)X op Y) into (T1)X op Y, for pointer types T1 and\n@@ -5817,8 +5831,8 @@ fold (tree expr)\n \t  tree s1 = TYPE_SIZE (tt1);\n \n \t  if (s0 && s1 && operand_equal_p (s0, s1, OEP_ONLY_CONST))\n-\t    return build (TREE_CODE (arg0), t0, convert (t0, arg00),\n-\t\t          TREE_OPERAND (arg0, 1));\n+\t    return build2 (TREE_CODE (arg0), t0, convert (t0, arg00),\n+\t\t\t   TREE_OPERAND (arg0, 1));\n \t}\n \n       tem = fold_convert_const (code, type, arg0);\n@@ -5879,18 +5893,18 @@ fold (tree expr)\n       if (TREE_CODE (TREE_TYPE (arg0)) != COMPLEX_TYPE)\n \treturn fold_convert (type, arg0);\n       else if (TREE_CODE (arg0) == COMPLEX_EXPR)\n-\treturn build (COMPLEX_EXPR, type,\n-\t\t      TREE_OPERAND (arg0, 0),\n-\t\t      negate_expr (TREE_OPERAND (arg0, 1)));\n+\treturn build2 (COMPLEX_EXPR, type,\n+\t\t       TREE_OPERAND (arg0, 0),\n+\t\t       negate_expr (TREE_OPERAND (arg0, 1)));\n       else if (TREE_CODE (arg0) == COMPLEX_CST)\n \treturn build_complex (type, TREE_REALPART (arg0),\n \t\t\t      negate_expr (TREE_IMAGPART (arg0)));\n       else if (TREE_CODE (arg0) == PLUS_EXPR || TREE_CODE (arg0) == MINUS_EXPR)\n-\treturn fold (build (TREE_CODE (arg0), type,\n-\t\t\t    fold (build1 (CONJ_EXPR, type,\n-\t\t\t\t\t  TREE_OPERAND (arg0, 0))),\n-\t\t\t    fold (build1 (CONJ_EXPR,\n-\t\t\t\t\t  type, TREE_OPERAND (arg0, 1)))));\n+\treturn fold (build2 (TREE_CODE (arg0), type,\n+\t\t\t     fold (build1 (CONJ_EXPR, type,\n+\t\t\t\t\t   TREE_OPERAND (arg0, 0))),\n+\t\t\t     fold (build1 (CONJ_EXPR, type,\n+\t\t\t\t\t   TREE_OPERAND (arg0, 1)))));\n       else if (TREE_CODE (arg0) == CONJ_EXPR)\n \treturn TREE_OPERAND (arg0, 0);\n       return t;\n@@ -5913,11 +5927,11 @@ fold (tree expr)\n     case PLUS_EXPR:\n       /* A + (-B) -> A - B */\n       if (TREE_CODE (arg1) == NEGATE_EXPR)\n-\treturn fold (build (MINUS_EXPR, type, arg0, TREE_OPERAND (arg1, 0)));\n+\treturn fold (build2 (MINUS_EXPR, type, arg0, TREE_OPERAND (arg1, 0)));\n       /* (-A) + B -> B - A */\n       if (TREE_CODE (arg0) == NEGATE_EXPR\n \t  && reorder_operands_p (TREE_OPERAND (arg0, 0), arg1))\n-\treturn fold (build (MINUS_EXPR, type, arg1, TREE_OPERAND (arg0, 0)));\n+\treturn fold (build2 (MINUS_EXPR, type, arg1, TREE_OPERAND (arg0, 0)));\n       if (! FLOAT_TYPE_P (type))\n \t{\n \t  if (integer_zerop (arg1))\n@@ -5960,18 +5974,18 @@ fold (tree expr)\n \n \t      if (TREE_CODE (parg0) == MULT_EXPR\n \t\t  && TREE_CODE (parg1) != MULT_EXPR)\n-\t\treturn fold (build (PLUS_EXPR, type,\n-\t\t\t\t    fold (build (PLUS_EXPR, type,\n-\t\t\t\t\t\t fold_convert (type, parg0),\n-\t\t\t\t\t\t fold_convert (type, marg))),\n-\t\t\t\t    fold_convert (type, parg1)));\n+\t\treturn fold (build2 (PLUS_EXPR, type,\n+\t\t\t\t     fold (build2 (PLUS_EXPR, type,\n+\t\t\t\t\t\t   fold_convert (type, parg0),\n+\t\t\t\t\t\t   fold_convert (type, marg))),\n+\t\t\t\t     fold_convert (type, parg1)));\n \t      if (TREE_CODE (parg0) != MULT_EXPR\n \t\t  && TREE_CODE (parg1) == MULT_EXPR)\n-\t\treturn fold (build (PLUS_EXPR, type,\n-\t\t\t\t    fold (build (PLUS_EXPR, type,\n-\t\t\t\t\t\t fold_convert (type, parg1),\n-\t\t\t\t\t\t fold_convert (type, marg))),\n-\t\t\t\t    fold_convert (type, parg0)));\n+\t\treturn fold (build2 (PLUS_EXPR, type,\n+\t\t\t\t     fold (build2 (PLUS_EXPR, type,\n+\t\t\t\t\t\t   fold_convert (type, parg1),\n+\t\t\t\t\t\t   fold_convert (type, marg))),\n+\t\t\t\t     fold_convert (type, parg0)));\n \t    }\n \n \t  if (TREE_CODE (arg0) == MULT_EXPR && TREE_CODE (arg1) == MULT_EXPR)\n@@ -6022,17 +6036,18 @@ fold (tree expr)\n \n \t\t  if (exact_log2 (int11) > 0 && int01 % int11 == 0)\n \t\t    {\n-\t\t      alt0 = fold (build (MULT_EXPR, type, arg00,\n-\t\t\t\t\t  build_int_2 (int01 / int11, 0)));\n+\t\t      alt0 = fold (build2 (MULT_EXPR, type, arg00,\n+\t\t\t\t\t   build_int_2 (int01 / int11, 0)));\n \t\t      alt1 = arg10;\n \t\t      same = arg11;\n \t\t    }\n \t\t}\n \n \t      if (same)\n-\t\treturn fold (build (MULT_EXPR, type,\n-\t\t\t\t    fold (build (PLUS_EXPR, type, alt0, alt1)),\n-\t\t\t\t    same));\n+\t\treturn fold (build2 (MULT_EXPR, type,\n+\t\t\t\t     fold (build2 (PLUS_EXPR, type,\n+\t\t\t\t\t\t   alt0, alt1)),\n+\t\t\t\t     same));\n \t    }\n \t}\n       else\n@@ -6048,8 +6063,8 @@ fold (tree expr)\n \t  /* Convert x+x into x*2.0.  */\n \t  if (operand_equal_p (arg0, arg1, 0)\n \t      && SCALAR_FLOAT_TYPE_P (type))\n-\t    return fold (build (MULT_EXPR, type, arg0,\n-\t\t\t\tbuild_real (type, dconst2)));\n+\t    return fold (build2 (MULT_EXPR, type, arg0,\n+\t\t\t\t build_real (type, dconst2)));\n \n \t  /* Convert x*c+x into x*(c+1).  */\n \t  if (flag_unsafe_math_optimizations\n@@ -6062,8 +6077,8 @@ fold (tree expr)\n \n \t      c = TREE_REAL_CST (TREE_OPERAND (arg0, 1));\n \t      real_arithmetic (&c, PLUS_EXPR, &c, &dconst1);\n-\t      return fold (build (MULT_EXPR, type, arg1,\n-\t\t\t\t  build_real (type, c)));\n+\t      return fold (build2 (MULT_EXPR, type, arg1,\n+\t\t\t\t   build_real (type, c)));\n \t    }\n \n \t  /* Convert x+x*c into x*(c+1).  */\n@@ -6077,8 +6092,8 @@ fold (tree expr)\n \n \t      c = TREE_REAL_CST (TREE_OPERAND (arg1, 1));\n \t      real_arithmetic (&c, PLUS_EXPR, &c, &dconst1);\n-\t      return fold (build (MULT_EXPR, type, arg0,\n-\t\t\t\t  build_real (type, c)));\n+\t      return fold (build2 (MULT_EXPR, type, arg0,\n+\t\t\t\t   build_real (type, c)));\n \t    }\n \n \t  /* Convert x*c1+x*c2 into x*(c1+c2).  */\n@@ -6097,9 +6112,9 @@ fold (tree expr)\n \t      c1 = TREE_REAL_CST (TREE_OPERAND (arg0, 1));\n \t      c2 = TREE_REAL_CST (TREE_OPERAND (arg1, 1));\n \t      real_arithmetic (&c1, PLUS_EXPR, &c1, &c2);\n-\t      return fold (build (MULT_EXPR, type,\n-\t\t\t\t  TREE_OPERAND (arg0, 0),\n-\t\t\t\t  build_real (type, c1)));\n+\t      return fold (build2 (MULT_EXPR, type,\n+\t\t\t\t   TREE_OPERAND (arg0, 0),\n+\t\t\t\t   build_real (type, c1)));\n \t    }\n           /* Convert a + (b*c + d*e) into (a + b*c) + d*e */\n           if (flag_unsafe_math_optimizations\n@@ -6112,8 +6127,8 @@ fold (tree expr)\n \t\t  && TREE_CODE (tree10) == MULT_EXPR)\n                 {\n                   tree tree0;\n-                  tree0 = fold (build (PLUS_EXPR, type, arg0, tree10));\n-                  return fold (build (PLUS_EXPR, type, tree0, tree11));\n+                  tree0 = fold (build2 (PLUS_EXPR, type, arg0, tree10));\n+                  return fold (build2 (PLUS_EXPR, type, tree0, tree11));\n                 }\n             }\n           /* Convert (b*c + d*e) + a into b*c + (d*e +a) */\n@@ -6127,8 +6142,8 @@ fold (tree expr)\n \t\t  && TREE_CODE (tree00) == MULT_EXPR)\n                 {\n                   tree tree0;\n-                  tree0 = fold (build (PLUS_EXPR, type, tree01, arg1));\n-                  return fold (build (PLUS_EXPR, type, tree00, tree0));\n+                  tree0 = fold (build2 (PLUS_EXPR, type, tree01, arg1));\n+                  return fold (build2 (PLUS_EXPR, type, tree00, tree0));\n                 }\n             }\n \t}\n@@ -6163,8 +6178,8 @@ fold (tree expr)\n \t\t&& TREE_INT_CST_HIGH (tree11) == 0\n \t\t&& ((TREE_INT_CST_LOW (tree01) + TREE_INT_CST_LOW (tree11))\n \t\t    == TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (arg0, 0)))))\n-\t      return build (LROTATE_EXPR, type, TREE_OPERAND (arg0, 0),\n-\t\t\t    code0 == LSHIFT_EXPR ? tree01 : tree11);\n+\t      return build2 (LROTATE_EXPR, type, TREE_OPERAND (arg0, 0),\n+\t\t\t     code0 == LSHIFT_EXPR ? tree01 : tree11);\n \t    else if (code11 == MINUS_EXPR)\n \t      {\n \t\ttree tree110, tree111;\n@@ -6178,10 +6193,10 @@ fold (tree expr)\n \t\t\t\t\t      (TREE_TYPE (TREE_OPERAND\n \t\t\t\t\t\t\t  (arg0, 0))))\n \t\t    && operand_equal_p (tree01, tree111, 0))\n-\t\t  return build ((code0 == LSHIFT_EXPR\n-\t\t\t\t ? LROTATE_EXPR\n-\t\t\t\t : RROTATE_EXPR),\n-\t\t\t\ttype, TREE_OPERAND (arg0, 0), tree01);\n+\t\t  return build2 ((code0 == LSHIFT_EXPR\n+\t\t\t\t  ? LROTATE_EXPR\n+\t\t\t\t  : RROTATE_EXPR),\n+\t\t\t\t type, TREE_OPERAND (arg0, 0), tree01);\n \t      }\n \t    else if (code01 == MINUS_EXPR)\n \t      {\n@@ -6196,10 +6211,10 @@ fold (tree expr)\n \t\t\t\t\t      (TREE_TYPE (TREE_OPERAND\n \t\t\t\t\t\t\t  (arg0, 0))))\n \t\t    && operand_equal_p (tree11, tree011, 0))\n-\t\t  return build ((code0 != LSHIFT_EXPR\n-\t\t\t\t ? LROTATE_EXPR\n-\t\t\t\t : RROTATE_EXPR),\n-\t\t\t\ttype, TREE_OPERAND (arg0, 0), tree11);\n+\t\t  return build2 ((code0 != LSHIFT_EXPR\n+\t\t\t\t  ? LROTATE_EXPR\n+\t\t\t\t  : RROTATE_EXPR),\n+\t\t\t\t type, TREE_OPERAND (arg0, 0), tree11);\n \t      }\n \t  }\n       }\n@@ -6302,15 +6317,15 @@ fold (tree expr)\n     case MINUS_EXPR:\n       /* A - (-B) -> A + B */\n       if (TREE_CODE (arg1) == NEGATE_EXPR)\n-\treturn fold (build (PLUS_EXPR, type, arg0, TREE_OPERAND (arg1, 0)));\n+\treturn fold (build2 (PLUS_EXPR, type, arg0, TREE_OPERAND (arg1, 0)));\n       /* (-A) - B -> (-B) - A  where B is easily negated and we can swap.  */\n       if (TREE_CODE (arg0) == NEGATE_EXPR\n \t  && (FLOAT_TYPE_P (type)\n \t      || (INTEGRAL_TYPE_P (type) && flag_wrapv && !flag_trapv))\n \t  && negate_expr_p (arg1)\n \t  && reorder_operands_p (arg0, arg1))\n-\treturn fold (build (MINUS_EXPR, type, negate_expr (arg1),\n-\t\t\t    TREE_OPERAND (arg0, 0)));\n+\treturn fold (build2 (MINUS_EXPR, type, negate_expr (arg1),\n+\t\t\t     TREE_OPERAND (arg0, 0)));\n \n       if (! FLOAT_TYPE_P (type))\n \t{\n@@ -6324,15 +6339,15 @@ fold (tree expr)\n \t      && TREE_CODE (arg1) == BIT_AND_EXPR)\n \t    {\n \t      if (operand_equal_p (arg0, TREE_OPERAND (arg1, 1), 0))\n-\t\treturn fold (build (BIT_AND_EXPR, type,\n-\t\t\t\t    fold (build1 (BIT_NOT_EXPR, type,\n-\t\t\t\t\t\t  TREE_OPERAND (arg1, 0))),\n-\t\t\t\t    arg0));\n+\t\treturn fold (build2 (BIT_AND_EXPR, type,\n+\t\t\t\t     fold (build1 (BIT_NOT_EXPR, type,\n+\t\t\t\t\t\t   TREE_OPERAND (arg1, 0))),\n+\t\t\t\t     arg0));\n \t      if (operand_equal_p (arg0, TREE_OPERAND (arg1, 0), 0))\n-\t\treturn fold (build (BIT_AND_EXPR, type,\n-\t\t\t\t    fold (build1 (BIT_NOT_EXPR, type,\n-\t\t\t\t\t\t  TREE_OPERAND (arg1, 1))),\n-\t\t\t\t    arg0));\n+\t\treturn fold (build2 (BIT_AND_EXPR, type,\n+\t\t\t\t     fold (build1 (BIT_NOT_EXPR, type,\n+\t\t\t\t\t\t   TREE_OPERAND (arg1, 1))),\n+\t\t\t\t     arg0));\n \t    }\n \n \t  /* Fold (A & ~B) - (A & B) into (A ^ B) - B, where B is\n@@ -6348,9 +6363,9 @@ fold (tree expr)\n \t      \n \t      if (operand_equal_p (tem, mask1, 0))\n \t\t{\n-\t\t  tem = fold (build (BIT_XOR_EXPR, type,\n-\t\t\t\t     TREE_OPERAND (arg0, 0), mask1));\n-\t\t  return fold (build (MINUS_EXPR, type, tem, mask1));\n+\t\t  tem = fold (build2 (BIT_XOR_EXPR, type,\n+\t\t\t\t      TREE_OPERAND (arg0, 0), mask1));\n+\t\t  return fold (build2 (MINUS_EXPR, type, tem, mask1));\n \t\t}\n \t    }\n \t}\n@@ -6379,7 +6394,7 @@ fold (tree expr)\n       if (!wins && negate_expr_p (arg1)\n \t  && (FLOAT_TYPE_P (type)\n \t      || (INTEGRAL_TYPE_P (type) && flag_wrapv && !flag_trapv)))\n-\treturn fold (build (PLUS_EXPR, type, arg0, negate_expr (arg1)));\n+\treturn fold (build2 (PLUS_EXPR, type, arg0, negate_expr (arg1)));\n \n       if (TREE_CODE (arg0) == MULT_EXPR\n \t  && TREE_CODE (arg1) == MULT_EXPR\n@@ -6388,33 +6403,33 @@ fold (tree expr)\n           /* (A * C) - (B * C) -> (A-B) * C.  */\n \t  if (operand_equal_p (TREE_OPERAND (arg0, 1),\n \t\t\t       TREE_OPERAND (arg1, 1), 0))\n-\t    return fold (build (MULT_EXPR, type,\n-\t\t\t\tfold (build (MINUS_EXPR, type,\n-\t\t\t\t\t     TREE_OPERAND (arg0, 0),\n-\t\t\t\t\t     TREE_OPERAND (arg1, 0))),\n-\t\t\t\tTREE_OPERAND (arg0, 1)));\n+\t    return fold (build2 (MULT_EXPR, type,\n+\t\t\t\t fold (build2 (MINUS_EXPR, type,\n+\t\t\t\t\t       TREE_OPERAND (arg0, 0),\n+\t\t\t\t\t       TREE_OPERAND (arg1, 0))),\n+\t\t\t\t TREE_OPERAND (arg0, 1)));\n           /* (A * C1) - (A * C2) -> A * (C1-C2).  */\n \t  if (operand_equal_p (TREE_OPERAND (arg0, 0),\n \t\t\t       TREE_OPERAND (arg1, 0), 0))\n-\t    return fold (build (MULT_EXPR, type,\n-\t\t\t\tTREE_OPERAND (arg0, 0),\n-\t\t\t\tfold (build (MINUS_EXPR, type,\n-\t\t\t\t\t     TREE_OPERAND (arg0, 1),\n-\t\t\t\t\t     TREE_OPERAND (arg1, 1)))));\n+\t    return fold (build2 (MULT_EXPR, type,\n+\t\t\t\t TREE_OPERAND (arg0, 0),\n+\t\t\t\t fold (build2 (MINUS_EXPR, type,\n+\t\t\t\t\t       TREE_OPERAND (arg0, 1),\n+\t\t\t\t\t       TREE_OPERAND (arg1, 1)))));\n \t}\n \n       goto associate;\n \n     case MULT_EXPR:\n       /* (-A) * (-B) -> A * B  */\n       if (TREE_CODE (arg0) == NEGATE_EXPR && negate_expr_p (arg1))\n-\treturn fold (build (MULT_EXPR, type,\n-\t\t\t    TREE_OPERAND (arg0, 0),\n-\t\t\t    negate_expr (arg1)));\n+\treturn fold (build2 (MULT_EXPR, type,\n+\t\t\t     TREE_OPERAND (arg0, 0),\n+\t\t\t     negate_expr (arg1)));\n       if (TREE_CODE (arg1) == NEGATE_EXPR && negate_expr_p (arg0))\n-\treturn fold (build (MULT_EXPR, type,\n-\t\t\t    negate_expr (arg0),\n-\t\t\t    TREE_OPERAND (arg1, 0)));\n+\treturn fold (build2 (MULT_EXPR, type,\n+\t\t\t     negate_expr (arg0),\n+\t\t\t     TREE_OPERAND (arg1, 0)));\n \n       if (! FLOAT_TYPE_P (type))\n \t{\n@@ -6426,12 +6441,12 @@ fold (tree expr)\n \t  /* (a * (1 << b)) is (a << b)  */\n \t  if (TREE_CODE (arg1) == LSHIFT_EXPR\n \t      && integer_onep (TREE_OPERAND (arg1, 0)))\n-\t    return fold (build (LSHIFT_EXPR, type, arg0,\n-\t\t\t\tTREE_OPERAND (arg1, 1)));\n+\t    return fold (build2 (LSHIFT_EXPR, type, arg0,\n+\t\t\t\t TREE_OPERAND (arg1, 1)));\n \t  if (TREE_CODE (arg0) == LSHIFT_EXPR\n \t      && integer_onep (TREE_OPERAND (arg0, 0)))\n-\t    return fold (build (LSHIFT_EXPR, type, arg1,\n-\t\t\t\tTREE_OPERAND (arg0, 1)));\n+\t    return fold (build2 (LSHIFT_EXPR, type, arg1,\n+\t\t\t\t TREE_OPERAND (arg0, 1)));\n \n \t  if (TREE_CODE (arg1) == INTEGER_CST\n \t      && 0 != (tem = extract_muldiv (TREE_OPERAND (t, 0),\n@@ -6469,8 +6484,8 @@ fold (tree expr)\n \t      tree tem = const_binop (MULT_EXPR, TREE_OPERAND (arg0, 0),\n \t\t\t\t      arg1, 0);\n \t      if (tem)\n-\t\treturn fold (build (RDIV_EXPR, type, tem,\n-\t\t\t\t    TREE_OPERAND (arg0, 1)));\n+\t\treturn fold (build2 (RDIV_EXPR, type, tem,\n+\t\t\t\t     TREE_OPERAND (arg0, 1)));\n \t    }\n \n \t  if (flag_unsafe_math_optimizations)\n@@ -6493,7 +6508,7 @@ fold (tree expr)\n \n \t          /* Optimize root(x)*root(y) as root(x*y).  */\n \t\t  rootfn = TREE_OPERAND (TREE_OPERAND (arg0, 0), 0);\n-\t\t  arg = fold (build (MULT_EXPR, type, arg00, arg10));\n+\t\t  arg = fold (build2 (MULT_EXPR, type, arg00, arg10));\n \t\t  arglist = build_tree_list (NULL_TREE, arg);\n \t\t  return build_function_call_expr (rootfn, arglist);\n \t\t}\n@@ -6502,9 +6517,9 @@ fold (tree expr)\n \t      if (fcode0 == fcode1 && BUILTIN_EXPONENT_P (fcode0))\n \t\t{\n \t\t  tree expfn = TREE_OPERAND (TREE_OPERAND (arg0, 0), 0);\n-\t\t  tree arg = build (PLUS_EXPR, type,\n-\t\t\t\t    TREE_VALUE (TREE_OPERAND (arg0, 1)),\n-\t\t\t\t    TREE_VALUE (TREE_OPERAND (arg1, 1)));\n+\t\t  tree arg = build2 (PLUS_EXPR, type,\n+\t\t\t\t     TREE_VALUE (TREE_OPERAND (arg0, 1)),\n+\t\t\t\t     TREE_VALUE (TREE_OPERAND (arg1, 1)));\n \t\t  tree arglist = build_tree_list (NULL_TREE, fold (arg));\n \t\t  return build_function_call_expr (expfn, arglist);\n \t\t}\n@@ -6525,7 +6540,7 @@ fold (tree expr)\n \t\t  if (operand_equal_p (arg01, arg11, 0))\n \t\t    {\n \t\t      tree powfn = TREE_OPERAND (TREE_OPERAND (arg0, 0), 0);\n-\t\t      tree arg = build (MULT_EXPR, type, arg00, arg10);\n+\t\t      tree arg = build2 (MULT_EXPR, type, arg00, arg10);\n \t\t      tree arglist = tree_cons (NULL_TREE, fold (arg),\n \t\t\t\t\t\tbuild_tree_list (NULL_TREE,\n \t\t\t\t\t\t\t\t arg01));\n@@ -6536,7 +6551,7 @@ fold (tree expr)\n \t\t  if (operand_equal_p (arg00, arg10, 0))\n \t\t    {\n \t\t      tree powfn = TREE_OPERAND (TREE_OPERAND (arg0, 0), 0);\n-\t\t      tree arg = fold (build (PLUS_EXPR, type, arg01, arg11));\n+\t\t      tree arg = fold (build2 (PLUS_EXPR, type, arg01, arg11));\n \t\t      tree arglist = tree_cons (NULL_TREE, arg00,\n \t\t\t\t\t\tbuild_tree_list (NULL_TREE,\n \t\t\t\t\t\t\t\t arg));\n@@ -6651,9 +6666,9 @@ fold (tree expr)\n \t  && TREE_CODE (arg1) == BIT_NOT_EXPR)\n \t{\n \t  return fold (build1 (BIT_NOT_EXPR, type,\n-\t\t\t       build (BIT_AND_EXPR, type,\n-\t\t\t\t      TREE_OPERAND (arg0, 0),\n-\t\t\t\t      TREE_OPERAND (arg1, 0))));\n+\t\t\t       build2 (BIT_AND_EXPR, type,\n+\t\t\t\t       TREE_OPERAND (arg0, 0),\n+\t\t\t\t       TREE_OPERAND (arg1, 0))));\n \t}\n \n       /* See if this can be simplified into a rotate first.  If that\n@@ -6721,9 +6736,9 @@ fold (tree expr)\n \t  && TREE_CODE (arg1) == BIT_NOT_EXPR)\n \t{\n \t  return fold (build1 (BIT_NOT_EXPR, type,\n-\t\t\t       build (BIT_IOR_EXPR, type,\n-\t\t\t\t      TREE_OPERAND (arg0, 0),\n-\t\t\t\t      TREE_OPERAND (arg1, 0))));\n+\t\t\t       build2 (BIT_IOR_EXPR, type,\n+\t\t\t\t       TREE_OPERAND (arg0, 0),\n+\t\t\t\t       TREE_OPERAND (arg1, 0))));\n \t}\n \n       goto associate;\n@@ -6738,13 +6753,13 @@ fold (tree expr)\n \n       /* (-A) / (-B) -> A / B  */\n       if (TREE_CODE (arg0) == NEGATE_EXPR && negate_expr_p (arg1))\n-\treturn fold (build (RDIV_EXPR, type,\n-\t\t\t    TREE_OPERAND (arg0, 0),\n-\t\t\t    negate_expr (arg1)));\n+\treturn fold (build2 (RDIV_EXPR, type,\n+\t\t\t     TREE_OPERAND (arg0, 0),\n+\t\t\t     negate_expr (arg1)));\n       if (TREE_CODE (arg1) == NEGATE_EXPR && negate_expr_p (arg0))\n-\treturn fold (build (RDIV_EXPR, type,\n-\t\t\t    negate_expr (arg0),\n-\t\t\t    TREE_OPERAND (arg1, 0)));\n+\treturn fold (build2 (RDIV_EXPR, type,\n+\t\t\t     negate_expr (arg0),\n+\t\t\t     TREE_OPERAND (arg1, 0)));\n \n       /* In IEEE floating point, x/1 is not equivalent to x for snans.  */\n       if (!HONOR_SNANS (TYPE_MODE (TREE_TYPE (arg0)))\n@@ -6766,7 +6781,7 @@ fold (tree expr)\n \t  if (flag_unsafe_math_optimizations\n \t      && 0 != (tem = const_binop (code, build_real (type, dconst1),\n \t\t\t\t\t  arg1, 0)))\n-\t    return fold (build (MULT_EXPR, type, arg0, tem));\n+\t    return fold (build2 (MULT_EXPR, type, arg0, tem));\n \t  /* Find the reciprocal if optimizing and the result is exact.  */\n \t  if (optimize)\n \t    {\n@@ -6775,24 +6790,24 @@ fold (tree expr)\n \t      if (exact_real_inverse (TYPE_MODE(TREE_TYPE(arg0)), &r))\n \t\t{\n \t\t  tem = build_real (type, r);\n-\t\t  return fold (build (MULT_EXPR, type, arg0, tem));\n+\t\t  return fold (build2 (MULT_EXPR, type, arg0, tem));\n \t\t}\n \t    }\n \t}\n       /* Convert A/B/C to A/(B*C).  */\n       if (flag_unsafe_math_optimizations\n \t  && TREE_CODE (arg0) == RDIV_EXPR)\n-\treturn fold (build (RDIV_EXPR, type, TREE_OPERAND (arg0, 0),\n-\t\t\t    fold (build (MULT_EXPR, type,\n-\t\t\t\t\t TREE_OPERAND (arg0, 1), arg1))));\n+\treturn fold (build2 (RDIV_EXPR, type, TREE_OPERAND (arg0, 0),\n+\t\t\t     fold (build2 (MULT_EXPR, type,\n+\t\t\t\t\t   TREE_OPERAND (arg0, 1), arg1))));\n \n       /* Convert A/(B/C) to (A/B)*C.  */\n       if (flag_unsafe_math_optimizations\n \t  && TREE_CODE (arg1) == RDIV_EXPR)\n-\treturn fold (build (MULT_EXPR, type,\n-\t\t\t    fold (build (RDIV_EXPR, type, arg0,\n-\t\t\t\t\t TREE_OPERAND (arg1, 0))),\n-\t\t\t    TREE_OPERAND (arg1, 1)));\n+\treturn fold (build2 (MULT_EXPR, type,\n+\t\t\t     fold (build2 (RDIV_EXPR, type, arg0,\n+\t\t\t\t\t   TREE_OPERAND (arg1, 0))),\n+\t\t\t     TREE_OPERAND (arg1, 1)));\n \n       /* Convert C1/(X*C2) into (C1/C2)/X.  */\n       if (flag_unsafe_math_optimizations\n@@ -6803,8 +6818,8 @@ fold (tree expr)\n \t  tree tem = const_binop (RDIV_EXPR, arg0,\n \t\t\t\t  TREE_OPERAND (arg1, 1), 0);\n \t  if (tem)\n-\t    return fold (build (RDIV_EXPR, type, tem,\n-\t\t\t\tTREE_OPERAND (arg1, 0)));\n+\t    return fold (build2 (RDIV_EXPR, type, tem,\n+\t\t\t\t TREE_OPERAND (arg1, 0)));\n \t}\n \n       if (flag_unsafe_math_optimizations)\n@@ -6818,7 +6833,7 @@ fold (tree expr)\n \t      tree arglist = build_tree_list (NULL_TREE,\n \t\t\t\t\t      fold_convert (type, arg));\n \t      arg1 = build_function_call_expr (expfn, arglist);\n-\t      return fold (build (MULT_EXPR, type, arg0, arg1));\n+\t      return fold (build2 (MULT_EXPR, type, arg0, arg1));\n \t    }\n \n \t  /* Optimize x/pow(y,z) into x*pow(y,-z).  */\n@@ -6833,7 +6848,7 @@ fold (tree expr)\n \t      tree arglist = tree_cons(NULL_TREE, arg10,\n \t\t\t\t       build_tree_list (NULL_TREE, neg11));\n \t      arg1 = build_function_call_expr (powfn, arglist);\n-\t      return fold (build (MULT_EXPR, type, arg0, arg1));\n+\t      return fold (build2 (MULT_EXPR, type, arg0, arg1));\n \t    }\n \t}\n \n@@ -6869,9 +6884,8 @@ fold (tree expr)\n \t\t{\n \t\t  tree tmp = TREE_OPERAND (arg0, 1);\n \t\t  tmp = build_function_call_expr (tanfn, tmp);\n-\t\t  return fold (build (RDIV_EXPR, type,\n-\t\t\t\t      build_real (type, dconst1),\n-\t\t\t\t      tmp));\n+\t\t  return fold (build2 (RDIV_EXPR, type,\n+\t\t\t\t       build_real (type, dconst1), tmp));\n \t\t}\n \t    }\n \n@@ -6925,7 +6939,7 @@ fold (tree expr)\n \t after the last round to changes to the DIV code in expmed.c.  */\n       if ((code == CEIL_DIV_EXPR || code == FLOOR_DIV_EXPR)\n \t  && multiple_of_p (type, arg0, arg1))\n-\treturn fold (build (EXACT_DIV_EXPR, type, arg0, arg1));\n+\treturn fold (build2 (EXACT_DIV_EXPR, type, arg0, arg1));\n \n       if (TREE_CODE (arg1) == INTEGER_CST\n \t  && 0 != (tem = extract_muldiv (TREE_OPERAND (t, 0), arg1,\n@@ -6986,7 +7000,7 @@ fold (tree expr)\n \t  tree tem = build_int_2 (GET_MODE_BITSIZE (TYPE_MODE (type)), 0);\n \t  tem = fold_convert (TREE_TYPE (arg1), tem);\n \t  tem = const_binop (MINUS_EXPR, tem, arg1, 0);\n-\t  return fold (build (RROTATE_EXPR, type, arg0, tem));\n+\t  return fold (build2 (RROTATE_EXPR, type, arg0, tem));\n \t}\n \n       /* If we have a rotate of a bit operation with the rotate count and\n@@ -6997,11 +7011,11 @@ fold (tree expr)\n \t      || TREE_CODE (arg0) == BIT_IOR_EXPR\n \t      || TREE_CODE (arg0) == BIT_XOR_EXPR)\n \t  && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST)\n-\treturn fold (build (TREE_CODE (arg0), type,\n-\t\t\t    fold (build (code, type,\n-\t\t\t\t\t TREE_OPERAND (arg0, 0), arg1)),\n-\t\t\t    fold (build (code, type,\n-\t\t\t\t\t TREE_OPERAND (arg0, 1), arg1))));\n+\treturn fold (build2 (TREE_CODE (arg0), type,\n+\t\t\t     fold (build2 (code, type,\n+\t\t\t\t\t   TREE_OPERAND (arg0, 0), arg1)),\n+\t\t\t     fold (build2 (code, type,\n+\t\t\t\t\t   TREE_OPERAND (arg0, 1), arg1))));\n \n       /* Two consecutive rotates adding up to the width of the mode can\n \t be ignored.  */\n@@ -7102,23 +7116,23 @@ fold (tree expr)\n \t\t\t\t || code == TRUTH_OR_EXPR));\n \n \t  if (operand_equal_p (a00, a10, 0))\n-\t    return fold (build (TREE_CODE (arg0), type, a00,\n-\t\t\t\tfold (build (code, type, a01, a11))));\n+\t    return fold (build2 (TREE_CODE (arg0), type, a00,\n+\t\t\t\t fold (build2 (code, type, a01, a11))));\n \t  else if (commutative && operand_equal_p (a00, a11, 0))\n-\t    return fold (build (TREE_CODE (arg0), type, a00,\n-\t\t\t\tfold (build (code, type, a01, a10))));\n+\t    return fold (build2 (TREE_CODE (arg0), type, a00,\n+\t\t\t\t fold (build2 (code, type, a01, a10))));\n \t  else if (commutative && operand_equal_p (a01, a10, 0))\n-\t    return fold (build (TREE_CODE (arg0), type, a01,\n-\t\t\t\tfold (build (code, type, a00, a11))));\n+\t    return fold (build2 (TREE_CODE (arg0), type, a01,\n+\t\t\t\t fold (build2 (code, type, a00, a11))));\n \n \t  /* This case if tricky because we must either have commutative\n \t     operators or else A10 must not have side-effects.  */\n \n \t  else if ((commutative || ! TREE_SIDE_EFFECTS (a10))\n \t\t   && operand_equal_p (a01, a11, 0))\n-\t    return fold (build (TREE_CODE (arg0), type,\n-\t\t\t\tfold (build (code, type, a00, a10)),\n-\t\t\t\ta01));\n+\t    return fold (build2 (TREE_CODE (arg0), type,\n+\t\t\t\t fold (build2 (code, type, a00, a10)),\n+\t\t\t\t a01));\n \t}\n \n       /* See if we can build a range comparison.  */\n@@ -7131,7 +7145,7 @@ fold (tree expr)\n       if (TREE_CODE (arg0) == code\n \t  && 0 != (tem = fold_truthop (code, type,\n \t\t\t\t       TREE_OPERAND (arg0, 1), arg1)))\n-\treturn fold (build (code, type, TREE_OPERAND (arg0, 0), tem));\n+\treturn fold (build2 (code, type, TREE_OPERAND (arg0, 0), tem));\n \n       if ((tem = fold_truthop (code, type, arg0, arg1)) != 0)\n \treturn tem;\n@@ -7187,7 +7201,7 @@ fold (tree expr)\n     case GE_EXPR:\n       /* If one arg is a real or integer constant, put it last.  */\n       if (tree_swap_operands_p (arg0, arg1, true))\n-\treturn fold (build (swap_tree_comparison (code), type, arg1, arg0));\n+\treturn fold (build2 (swap_tree_comparison (code), type, arg1, arg0));\n \n       /* If this is an equality comparison of the address of a non-weak\n \t object against zero, then we know the result.  */\n@@ -7239,14 +7253,14 @@ fold (tree expr)\n \n \t  /* Fold (double)float1 CMP (double)float2 into float1 CMP float2.  */\n \t  if (TYPE_PRECISION (newtype) < TYPE_PRECISION (TREE_TYPE (arg0)))\n-\t    return fold (build (code, type, fold_convert (newtype, targ0),\n-\t\t\t\tfold_convert (newtype, targ1)));\n+\t    return fold (build2 (code, type, fold_convert (newtype, targ0),\n+\t\t\t\t fold_convert (newtype, targ1)));\n \n \t  /* (-a) CMP (-b) -> b CMP a  */\n \t  if (TREE_CODE (arg0) == NEGATE_EXPR\n \t      && TREE_CODE (arg1) == NEGATE_EXPR)\n-\t    return fold (build (code, type, TREE_OPERAND (arg1, 0),\n-\t\t\t\tTREE_OPERAND (arg0, 0)));\n+\t    return fold (build2 (code, type, TREE_OPERAND (arg1, 0),\n+\t\t\t\t TREE_OPERAND (arg0, 0)));\n \n \t  if (TREE_CODE (arg1) == REAL_CST)\n \t  {\n@@ -7256,16 +7270,16 @@ fold (tree expr)\n \t    /* (-a) CMP CST -> a swap(CMP) (-CST)  */\n \t    if (TREE_CODE (arg0) == NEGATE_EXPR)\n \t      return\n-\t\tfold (build (swap_tree_comparison (code), type,\n-\t\t\t     TREE_OPERAND (arg0, 0),\n-\t\t\t     build_real (TREE_TYPE (arg1),\n-\t\t\t\t\t REAL_VALUE_NEGATE (cst))));\n+\t\tfold (build2 (swap_tree_comparison (code), type,\n+\t\t\t      TREE_OPERAND (arg0, 0),\n+\t\t\t      build_real (TREE_TYPE (arg1),\n+\t\t\t\t\t  REAL_VALUE_NEGATE (cst))));\n \n \t    /* IEEE doesn't distinguish +0 and -0 in comparisons.  */\n \t    /* a CMP (-0) -> a CMP 0  */\n \t    if (REAL_VALUE_MINUS_ZERO (cst))\n-\t      return fold (build (code, type, arg0,\n-\t\t\t\t  build_real (TREE_TYPE (arg1), dconst0)));\n+\t      return fold (build2 (code, type, arg0,\n+\t\t\t\t   build_real (TREE_TYPE (arg1), dconst0)));\n \n \t    /* x != NaN is always true, other ops are always false.  */\n \t    if (REAL_VALUE_ISNAN (cst)\n@@ -7297,7 +7311,7 @@ fold (tree expr)\n \t\t\t\t\t  ? MINUS_EXPR : PLUS_EXPR,\n \t\t\t\t\t  arg1, TREE_OPERAND (arg0, 1), 0))\n \t      && ! TREE_CONSTANT_OVERFLOW (tem))\n-\t    return fold (build (code, type, TREE_OPERAND (arg0, 0), tem));\n+\t    return fold (build2 (code, type, TREE_OPERAND (arg0, 0), tem));\n \n \t  /* Likewise, we can simplify a comparison of a real constant with\n \t     a MINUS_EXPR whose first operand is also a real constant, i.e.\n@@ -7309,8 +7323,8 @@ fold (tree expr)\n \t      && 0 != (tem = const_binop (MINUS_EXPR, TREE_OPERAND (arg0, 0),\n \t\t\t\t\t  arg1, 0))\n \t      && ! TREE_CONSTANT_OVERFLOW (tem))\n-\t    return fold (build (swap_tree_comparison (code), type,\n-\t\t\t\tTREE_OPERAND (arg0, 1), tem));\n+\t    return fold (build2 (swap_tree_comparison (code), type,\n+\t\t\t\t TREE_OPERAND (arg0, 1), tem));\n \n \t  /* Fold comparisons against built-in math functions.  */\n \t  if (TREE_CODE (arg1) == REAL_CST\n@@ -7401,11 +7415,11 @@ fold (tree expr)\n \t    {\n \t    case GE_EXPR:\n \t      arg1 = const_binop (MINUS_EXPR, arg1, integer_one_node, 0);\n-\t      return fold (build (GT_EXPR, type, arg0, arg1));\n+\t      return fold (build2 (GT_EXPR, type, arg0, arg1));\n \n \t    case LT_EXPR:\n \t      arg1 = const_binop (MINUS_EXPR, arg1, integer_one_node, 0);\n-\t      return fold (build (LE_EXPR, type, arg0, arg1));\n+\t      return fold (build2 (LE_EXPR, type, arg0, arg1));\n \n \t    default:\n \t      break;\n@@ -7453,15 +7467,15 @@ fold (tree expr)\n \t\t\t\t\t\t\t integer_zero_node),\n \t\t\t\t\t   arg0);\n \t\tcase GE_EXPR:\n-\t\t  return fold (build (EQ_EXPR, type, arg0, arg1));\n+\t\t  return fold (build2 (EQ_EXPR, type, arg0, arg1));\n \n \t\tcase LE_EXPR:\n \t\t  return omit_one_operand (type,\n \t\t\t\t\t   fold_convert (type,\n \t\t\t\t\t\t\t integer_one_node),\n \t\t\t\t\t   arg0);\n \t\tcase LT_EXPR:\n-\t\t  return fold (build (NE_EXPR, type, arg0, arg1));\n+\t\t  return fold (build2 (NE_EXPR, type, arg0, arg1));\n \n \t\t/* The GE_EXPR and LT_EXPR cases above are not normally\n \t\t   reached because of previous transformations.  */\n@@ -7475,10 +7489,10 @@ fold (tree expr)\n \t\t{\n \t\tcase GT_EXPR:\n \t\t  arg1 = const_binop (PLUS_EXPR, arg1, integer_one_node, 0);\n-\t\t  return fold (build (EQ_EXPR, type, arg0, arg1));\n+\t\t  return fold (build2 (EQ_EXPR, type, arg0, arg1));\n \t\tcase LE_EXPR:\n \t\t  arg1 = const_binop (PLUS_EXPR, arg1, integer_one_node, 0);\n-\t\t  return fold (build (NE_EXPR, type, arg0, arg1));\n+\t\t  return fold (build2 (NE_EXPR, type, arg0, arg1));\n \t\tdefault:\n \t\t  break;\n \t\t}\n@@ -7492,15 +7506,15 @@ fold (tree expr)\n \t\t\t\t\t\t\t integer_zero_node),\n \t\t\t\t\t   arg0);\n \t\tcase LE_EXPR:\n-\t\t  return fold (build (EQ_EXPR, type, arg0, arg1));\n+\t\t  return fold (build2 (EQ_EXPR, type, arg0, arg1));\n \n \t\tcase GE_EXPR:\n \t\t  return omit_one_operand (type,\n \t\t\t\t\t   fold_convert (type,\n \t\t\t\t\t\t\t integer_one_node),\n \t\t\t\t\t   arg0);\n \t\tcase GT_EXPR:\n-\t\t  return fold (build (NE_EXPR, type, arg0, arg1));\n+\t\t  return fold (build2 (NE_EXPR, type, arg0, arg1));\n \n \t\tdefault:\n \t\t  break;\n@@ -7511,10 +7525,10 @@ fold (tree expr)\n \t\t{\n \t\tcase GE_EXPR:\n \t\t  arg1 = const_binop (MINUS_EXPR, arg1, integer_one_node, 0);\n-\t\t  return fold (build (NE_EXPR, type, arg0, arg1));\n+\t\t  return fold (build2 (NE_EXPR, type, arg0, arg1));\n \t\tcase LT_EXPR:\n \t\t  arg1 = const_binop (MINUS_EXPR, arg1, integer_one_node, 0);\n-\t\t  return fold (build (EQ_EXPR, type, arg0, arg1));\n+\t\t  return fold (build2 (EQ_EXPR, type, arg0, arg1));\n \t\tdefault:\n \t\t  break;\n \t\t}\n@@ -7534,9 +7548,9 @@ fold (tree expr)\n \t\t    st0 = lang_hooks.types.signed_type (TREE_TYPE (arg0));\n \t\t    st1 = lang_hooks.types.signed_type (TREE_TYPE (arg1));\n \t\t    return fold\n-\t\t      (build (code == LE_EXPR ? GE_EXPR: LT_EXPR,\n-\t\t\t      type, fold_convert (st0, arg0),\n-\t\t\t      fold_convert (st1, integer_zero_node)));\n+\t\t      (build2 (code == LE_EXPR ? GE_EXPR: LT_EXPR,\n+\t\t\t       type, fold_convert (st0, arg0),\n+\t\t\t       fold_convert (st1, integer_zero_node)));\n \t\t  }\n \t      }\n \t  }\n@@ -7554,7 +7568,7 @@ fold (tree expr)\n \t\t\t\t      ? MINUS_EXPR : PLUS_EXPR,\n \t\t\t\t      arg1, TREE_OPERAND (arg0, 1), 0))\n \t  && ! TREE_CONSTANT_OVERFLOW (tem))\n-\treturn fold (build (code, type, TREE_OPERAND (arg0, 0), tem));\n+\treturn fold (build2 (code, type, TREE_OPERAND (arg0, 0), tem));\n \n       /* Similarly for a NEGATE_EXPR.  */\n       else if ((code == EQ_EXPR || code == NE_EXPR)\n@@ -7563,14 +7577,14 @@ fold (tree expr)\n \t       && 0 != (tem = negate_expr (arg1))\n \t       && TREE_CODE (tem) == INTEGER_CST\n \t       && ! TREE_CONSTANT_OVERFLOW (tem))\n-\treturn fold (build (code, type, TREE_OPERAND (arg0, 0), tem));\n+\treturn fold (build2 (code, type, TREE_OPERAND (arg0, 0), tem));\n \n       /* If we have X - Y == 0, we can convert that to X == Y and similarly\n \t for !=.  Don't do this for ordered comparisons due to overflow.  */\n       else if ((code == NE_EXPR || code == EQ_EXPR)\n \t       && integer_zerop (arg1) && TREE_CODE (arg0) == MINUS_EXPR)\n-\treturn fold (build (code, type,\n-\t\t\t    TREE_OPERAND (arg0, 0), TREE_OPERAND (arg0, 1)));\n+\treturn fold (build2 (code, type,\n+\t\t\t     TREE_OPERAND (arg0, 0), TREE_OPERAND (arg0, 1)));\n \n       /* If we are widening one operand of an integer comparison,\n \t see if the other operand is similarly being widened.  Perhaps we\n@@ -7585,8 +7599,8 @@ fold (tree expr)\n \t       && (TREE_TYPE (t1) == TREE_TYPE (tem)\n \t\t   || (TREE_CODE (t1) == INTEGER_CST\n \t\t       && int_fits_type_p (t1, TREE_TYPE (tem)))))\n-\treturn fold (build (code, type, tem,\n-\t\t\t    fold_convert (TREE_TYPE (tem), t1)));\n+\treturn fold (build2 (code, type, tem,\n+\t\t\t     fold_convert (TREE_TYPE (tem), t1)));\n \n       /* If this is comparing a constant with a MIN_EXPR or a MAX_EXPR of a\n \t constant, we can simplify it.  */\n@@ -7607,10 +7621,11 @@ fold (tree expr)\n \t       && (0 != (tem = negate_expr (arg1)))\n \t       && TREE_CODE (tem) == INTEGER_CST\n \t       && ! TREE_CONSTANT_OVERFLOW (tem))\n-\treturn fold (build (TRUTH_ANDIF_EXPR, type,\n-\t\t\t    build (GE_EXPR, type, TREE_OPERAND (arg0, 0), tem),\n-\t\t\t    build (LE_EXPR, type,\n-\t\t\t\t   TREE_OPERAND (arg0, 0), arg1)));\n+\treturn fold (build2 (TRUTH_ANDIF_EXPR, type,\n+\t\t\t     build2 (GE_EXPR, type,\n+\t\t\t\t     TREE_OPERAND (arg0, 0), tem),\n+\t\t\t     build2 (LE_EXPR, type,\n+\t\t\t\t     TREE_OPERAND (arg0, 0), arg1)));\n \n       /* If this is an EQ or NE comparison with zero and ARG0 is\n \t (1 << foo) & bar, convert it to (bar >> foo) & 1.  Both require\n@@ -7620,30 +7635,28 @@ fold (tree expr)\n       if (integer_zerop (arg1) && (code == EQ_EXPR || code == NE_EXPR)\n \t  && TREE_CODE (arg0) == BIT_AND_EXPR)\n \t{\n-\t  if (TREE_CODE (TREE_OPERAND (arg0, 0)) == LSHIFT_EXPR\n-\t      && integer_onep (TREE_OPERAND (TREE_OPERAND (arg0, 0), 0)))\n+\t  tree arg00 = TREE_OPERAND (arg0, 0);\n+\t  tree arg01 = TREE_OPERAND (arg0, 1);\n+\t  if (TREE_CODE (arg00) == LSHIFT_EXPR\n+\t      && integer_onep (TREE_OPERAND (arg00, 0)))\n \t    return\n-\t      fold (build (code, type,\n-\t\t\t   build (BIT_AND_EXPR, TREE_TYPE (arg0),\n-\t\t\t\t  build (RSHIFT_EXPR,\n-\t\t\t\t\t TREE_TYPE (TREE_OPERAND (arg0, 0)),\n-\t\t\t\t\t TREE_OPERAND (arg0, 1),\n-\t\t\t\t\t TREE_OPERAND (TREE_OPERAND (arg0, 0), 1)),\n-\t\t\t\t  fold_convert (TREE_TYPE (arg0),\n-\t\t\t\t\t\tinteger_one_node)),\n-\t\t\t   arg1));\n+\t      fold (build2 (code, type,\n+\t\t\t    build2 (BIT_AND_EXPR, TREE_TYPE (arg0),\n+\t\t\t\t    build2 (RSHIFT_EXPR, TREE_TYPE (arg00),\n+\t\t\t\t\t    arg01, TREE_OPERAND (arg00, 1)),\n+\t\t\t\t    fold_convert (TREE_TYPE (arg0),\n+\t\t\t\t\t\t  integer_one_node)),\n+\t\t\t    arg1));\n \t  else if (TREE_CODE (TREE_OPERAND (arg0, 1)) == LSHIFT_EXPR\n \t\t   && integer_onep (TREE_OPERAND (TREE_OPERAND (arg0, 1), 0)))\n \t    return\n-\t      fold (build (code, type,\n-\t\t\t   build (BIT_AND_EXPR, TREE_TYPE (arg0),\n-\t\t\t\t  build (RSHIFT_EXPR,\n-\t\t\t\t\t TREE_TYPE (TREE_OPERAND (arg0, 1)),\n-\t\t\t\t\t TREE_OPERAND (arg0, 0),\n-\t\t\t\t\t TREE_OPERAND (TREE_OPERAND (arg0, 1), 1)),\n-\t\t\t\t  fold_convert (TREE_TYPE (arg0),\n-\t\t\t\t\t\tinteger_one_node)),\n-\t\t\t   arg1));\n+\t      fold (build2 (code, type,\n+\t\t\t    build2 (BIT_AND_EXPR, TREE_TYPE (arg0),\n+\t\t\t\t    build2 (RSHIFT_EXPR, TREE_TYPE (arg01),\n+\t\t\t\t\t    arg00, TREE_OPERAND (arg01, 1)),\n+\t\t\t\t    fold_convert (TREE_TYPE (arg0),\n+\t\t\t\t\t\t  integer_one_node)),\n+\t\t\t    arg1));\n \t}\n \n       /* If this is an NE or EQ comparison of zero against the result of a\n@@ -7659,13 +7672,13 @@ fold (tree expr)\n \t  && integer_pow2p (TREE_OPERAND (arg0, 1)))\n \t{\n \t  tree newtype = lang_hooks.types.unsigned_type (TREE_TYPE (arg0));\n-\t  tree newmod = build (TREE_CODE (arg0), newtype,\n-\t\t\t       fold_convert (newtype,\n-\t\t\t\t\t     TREE_OPERAND (arg0, 0)),\n-\t\t\t       fold_convert (newtype,\n-\t\t\t\t\t     TREE_OPERAND (arg0, 1)));\n+\t  tree newmod = build2 (TREE_CODE (arg0), newtype,\n+\t\t\t\tfold_convert (newtype,\n+\t\t\t\t\t      TREE_OPERAND (arg0, 0)),\n+\t\t\t\tfold_convert (newtype,\n+\t\t\t\t\t      TREE_OPERAND (arg0, 1)));\n \n-\t  return build (code, type, newmod, fold_convert (newtype, arg1));\n+\t  return build2 (code, type, newmod, fold_convert (newtype, arg1));\n \t}\n \n       /* If this is an NE comparison of zero with an AND of one, remove the\n@@ -7681,8 +7694,8 @@ fold (tree expr)\n \t  && TREE_CODE (arg0) == BIT_AND_EXPR\n \t  && integer_pow2p (TREE_OPERAND (arg0, 1))\n \t  && operand_equal_p (TREE_OPERAND (arg0, 1), arg1, 0))\n-\treturn fold (build (code == EQ_EXPR ? NE_EXPR : EQ_EXPR, type,\n-\t\t\t    arg0, integer_zero_node));\n+\treturn fold (build2 (code == EQ_EXPR ? NE_EXPR : EQ_EXPR, type,\n+\t\t\t     arg0, integer_zero_node));\n \n       /* If we have (A & C) != 0 or (A & C) == 0 and C is a power of\n \t 2, then fold the expression into shifts and logical operations.  */\n@@ -7698,10 +7711,10 @@ fold (tree expr)\n \t  && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST)\n \t{\n \t  tree dandnotc\n-\t    = fold (build (BIT_AND_EXPR, TREE_TYPE (arg0),\n-\t\t\t   arg1, build1 (BIT_NOT_EXPR,\n-\t\t\t\t\t TREE_TYPE (TREE_OPERAND (arg0, 1)),\n-\t\t\t\t\t TREE_OPERAND (arg0, 1))));\n+\t    = fold (build2 (BIT_AND_EXPR, TREE_TYPE (arg0),\n+\t\t\t    arg1, build1 (BIT_NOT_EXPR,\n+\t\t\t\t\t  TREE_TYPE (TREE_OPERAND (arg0, 1)),\n+\t\t\t\t\t  TREE_OPERAND (arg0, 1))));\n \t  tree rslt = code == EQ_EXPR ? integer_zero_node : integer_one_node;\n \t  if (integer_nonzerop (dandnotc))\n \t    return omit_one_operand (type, rslt, arg0);\n@@ -7715,9 +7728,9 @@ fold (tree expr)\n \t  && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST)\n \t{\n \t  tree candnotd\n-\t    = fold (build (BIT_AND_EXPR, TREE_TYPE (arg0),\n-\t\t\t   TREE_OPERAND (arg0, 1),\n-\t\t\t   build1 (BIT_NOT_EXPR, TREE_TYPE (arg1), arg1)));\n+\t    = fold (build2 (BIT_AND_EXPR, TREE_TYPE (arg0),\n+\t\t\t    TREE_OPERAND (arg0, 1),\n+\t\t\t    build1 (BIT_NOT_EXPR, TREE_TYPE (arg1), arg1)));\n \t  tree rslt = code == EQ_EXPR ? integer_zero_node : integer_one_node;\n \t  if (integer_nonzerop (candnotd))\n \t    return omit_one_operand (type, rslt, arg0);\n@@ -7729,10 +7742,10 @@ fold (tree expr)\n \t  && TYPE_UNSIGNED (TREE_TYPE (arg0))\n \t  && TREE_CODE (arg1) == LSHIFT_EXPR\n \t  && integer_onep (TREE_OPERAND (arg1, 0)))\n-\treturn build (code == LT_EXPR ? EQ_EXPR : NE_EXPR, type,\n-\t\t      build (RSHIFT_EXPR, TREE_TYPE (arg0), arg0,\n-\t\t\t     TREE_OPERAND (arg1, 1)),\n-\t\t      fold_convert (TREE_TYPE (arg0), integer_zero_node));\n+\treturn build2 (code == LT_EXPR ? EQ_EXPR : NE_EXPR, type,\n+\t\t       build2 (RSHIFT_EXPR, TREE_TYPE (arg0), arg0,\n+\t\t\t       TREE_OPERAND (arg1, 1)),\n+\t\t       fold_convert (TREE_TYPE (arg0), integer_zero_node));\n \n       else if ((code == LT_EXPR || code == GE_EXPR)\n \t       && TYPE_UNSIGNED (TREE_TYPE (arg0))\n@@ -7741,12 +7754,12 @@ fold (tree expr)\n \t       && TREE_CODE (TREE_OPERAND (arg1, 0)) == LSHIFT_EXPR\n \t       && integer_onep (TREE_OPERAND (TREE_OPERAND (arg1, 0), 0)))\n \treturn\n-\t  build (code == LT_EXPR ? EQ_EXPR : NE_EXPR, type,\n-\t\t fold_convert (TREE_TYPE (arg0),\n-\t\t\t       build (RSHIFT_EXPR, TREE_TYPE (arg0), arg0,\n-\t\t\t\t      TREE_OPERAND (TREE_OPERAND (arg1, 0),\n-\t\t\t\t\t\t    1))),\n-\t\t fold_convert (TREE_TYPE (arg0), integer_zero_node));\n+\t  build2 (code == LT_EXPR ? EQ_EXPR : NE_EXPR, type,\n+\t\t  fold_convert (TREE_TYPE (arg0),\n+\t\t\t\tbuild2 (RSHIFT_EXPR, TREE_TYPE (arg0), arg0,\n+\t\t\t\t\tTREE_OPERAND (TREE_OPERAND (arg1, 0),\n+\t\t\t\t\t\t      1))),\n+\t\t  fold_convert (TREE_TYPE (arg0), integer_zero_node));\n \n       /* Simplify comparison of something with itself.  (For IEEE\n \t floating-point, we can only do some of these simplifications.)  */\n@@ -7765,7 +7778,7 @@ fold (tree expr)\n \t      if (! FLOAT_TYPE_P (TREE_TYPE (arg0))\n \t\t  || ! HONOR_NANS (TYPE_MODE (TREE_TYPE (arg0))))\n \t\treturn constant_boolean_node (1, type);\n-\t      return fold (build (EQ_EXPR, type, arg0, arg1));\n+\t      return fold (build2 (EQ_EXPR, type, arg0, arg1));\n \n \t    case NE_EXPR:\n \t      /* For NE, we can only do this simplification if integer\n@@ -7819,17 +7832,20 @@ fold (tree expr)\n \t\t was the same as ARG1.  */\n \n \t      tree high_result\n-\t\t= fold (build (code, type,\n-\t\t\t       eval_subst (arg0, cval1, maxval, cval2, minval),\n-\t\t\t       arg1));\n+\t\t= fold (build2 (code, type,\n+\t\t\t\teval_subst (arg0, cval1, maxval,\n+\t\t\t\t\t    cval2, minval),\n+\t\t\t\targ1));\n \t      tree equal_result\n-\t\t= fold (build (code, type,\n-\t\t\t       eval_subst (arg0, cval1, maxval, cval2, maxval),\n-\t\t\t       arg1));\n+\t\t= fold (build2 (code, type,\n+\t\t\t\teval_subst (arg0, cval1, maxval,\n+\t\t\t\t\t    cval2, maxval),\n+\t\t\t\targ1));\n \t      tree low_result\n-\t\t= fold (build (code, type,\n-\t\t\t       eval_subst (arg0, cval1, minval, cval2, maxval),\n-\t\t\t       arg1));\n+\t\t= fold (build2 (code, type,\n+\t\t\t\teval_subst (arg0, cval1, minval,\n+\t\t\t\t\t    cval2, maxval),\n+\t\t\t\targ1));\n \n \t      /* All three of these results should be 0 or 1.  Confirm they\n \t\t are.  Then use those values to select the proper code\n@@ -7874,7 +7890,7 @@ fold (tree expr)\n \t\t      return omit_one_operand (type, integer_one_node, arg0);\n \t\t    }\n \n-\t\t  tem = build (code, type, cval1, cval2);\n+\t\t  tem = build2 (code, type, cval1, cval2);\n \t\t  if (save_p)\n \t\t    return save_expr (tem);\n \t\t  else\n@@ -7918,11 +7934,11 @@ fold (tree expr)\n \t  real1 = fold (build1 (REALPART_EXPR, subtype, arg1));\n \t  imag1 = fold (build1 (IMAGPART_EXPR, subtype, arg1));\n \n-\t  return fold (build ((code == EQ_EXPR ? TRUTH_ANDIF_EXPR\n-\t\t\t       : TRUTH_ORIF_EXPR),\n-\t\t\t      type,\n-\t\t\t      fold (build (code, type, real0, real1)),\n-\t\t\t      fold (build (code, type, imag0, imag1))));\n+\t  return fold (build2 ((code == EQ_EXPR ? TRUTH_ANDIF_EXPR\n+\t\t\t\t: TRUTH_ORIF_EXPR),\n+\t\t\t       type,\n+\t\t\t       fold (build2 (code, type, real0, real1)),\n+\t\t\t       fold (build2 (code, type, imag0, imag1))));\n \t}\n \n       /* Optimize comparisons of strlen vs zero to a compare of the\n@@ -7945,10 +7961,10 @@ fold (tree expr)\n \t      && (arglist = TREE_OPERAND (arg0, 1))\n \t      && TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) == POINTER_TYPE\n \t      && ! TREE_CHAIN (arglist))\n-\t    return fold (build (code, type,\n-\t\t\t\tbuild1 (INDIRECT_REF, char_type_node,\n-\t\t\t\t\tTREE_VALUE(arglist)),\n-\t\t\t\tinteger_zero_node));\n+\t    return fold (build2 (code, type,\n+\t\t\t\t build1 (INDIRECT_REF, char_type_node,\n+\t\t\t\t\t TREE_VALUE(arglist)),\n+\t\t\t\t integer_zero_node));\n \t}\n \n       /* We can fold X/C1 op C2 where C1 and C2 are integer constants\n@@ -8120,21 +8136,21 @@ fold (tree expr)\n \t\t     corresponding COND_EXPR.  */\n \t\t  if (!HONOR_NANS (TYPE_MODE (TREE_TYPE (arg1))))\n \t\t    return pedantic_non_lvalue (fold_convert\n-\t\t      (type, fold (build (MIN_EXPR, comp_type,\n-\t\t\t\t\t  (comp_code == LE_EXPR\n-\t\t\t\t\t   ? comp_op0 : comp_op1),\n-\t\t\t\t\t  (comp_code == LE_EXPR\n-\t\t\t\t\t   ? comp_op1 : comp_op0)))));\n+\t\t      (type, fold (build2 (MIN_EXPR, comp_type,\n+\t\t\t\t\t   (comp_code == LE_EXPR\n+\t\t\t\t\t    ? comp_op0 : comp_op1),\n+\t\t\t\t\t   (comp_code == LE_EXPR\n+\t\t\t\t\t    ? comp_op1 : comp_op0)))));\n \t\t  break;\n \t\tcase GE_EXPR:\n \t\tcase GT_EXPR:\n \t\t  if (!HONOR_NANS (TYPE_MODE (TREE_TYPE (arg1))))\n \t\t    return pedantic_non_lvalue (fold_convert\n-\t\t      (type, fold (build (MAX_EXPR, comp_type,\n-\t\t\t\t\t  (comp_code == GE_EXPR\n-\t\t\t\t\t   ? comp_op0 : comp_op1),\n-\t\t\t\t\t  (comp_code == GE_EXPR\n-\t\t\t\t\t   ? comp_op1 : comp_op0)))));\n+\t\t      (type, fold (build2 (MAX_EXPR, comp_type,\n+\t\t\t\t\t   (comp_code == GE_EXPR\n+\t\t\t\t\t    ? comp_op0 : comp_op1),\n+\t\t\t\t\t   (comp_code == GE_EXPR\n+\t\t\t\t\t    ? comp_op1 : comp_op0)))));\n \t\t  break;\n \t\tdefault:\n \t\t  abort ();\n@@ -8155,8 +8171,8 @@ fold (tree expr)\n \t      case EQ_EXPR:\n \t\t/* We can replace A with C1 in this case.  */\n \t\targ1 = fold_convert (type, TREE_OPERAND (arg0, 1));\n-\t\treturn fold (build (code, type, TREE_OPERAND (t, 0), arg1,\n-\t\t\t\t    TREE_OPERAND (t, 2)));\n+\t\treturn fold (build3 (code, type, TREE_OPERAND (t, 0), arg1,\n+\t\t\t\t     TREE_OPERAND (t, 2)));\n \n \t      case LT_EXPR:\n \t\t/* If C1 is C2 + 1, this is min(A, C2).  */\n@@ -8167,7 +8183,7 @@ fold (tree expr)\n \t\t\t\t\t\t     integer_one_node, 0),\n \t\t\t\t\tOEP_ONLY_CONST))\n \t\t  return pedantic_non_lvalue\n-\t\t    (fold (build (MIN_EXPR, type, arg1, arg2)));\n+\t\t    (fold (build2 (MIN_EXPR, type, arg1, arg2)));\n \t\tbreak;\n \n \t      case LE_EXPR:\n@@ -8179,7 +8195,7 @@ fold (tree expr)\n \t\t\t\t\t\t     integer_one_node, 0),\n \t\t\t\t\tOEP_ONLY_CONST))\n \t\t  return pedantic_non_lvalue\n-\t\t    (fold (build (MIN_EXPR, type, arg1, arg2)));\n+\t\t    (fold (build2 (MIN_EXPR, type, arg1, arg2)));\n \t\tbreak;\n \n \t      case GT_EXPR:\n@@ -8191,7 +8207,7 @@ fold (tree expr)\n \t\t\t\t\t\t     integer_one_node, 0),\n \t\t\t\t\tOEP_ONLY_CONST))\n \t\t  return pedantic_non_lvalue\n-\t\t    (fold (build (MAX_EXPR, type, arg1, arg2)));\n+\t\t    (fold (build2 (MAX_EXPR, type, arg1, arg2)));\n \t\tbreak;\n \n \t      case GE_EXPR:\n@@ -8203,7 +8219,7 @@ fold (tree expr)\n \t\t\t\t\t\t     integer_one_node, 0),\n \t\t\t\t\tOEP_ONLY_CONST))\n \t\t  return pedantic_non_lvalue\n-\t\t    (fold (build (MAX_EXPR, type, arg1, arg2)));\n+\t\t    (fold (build2 (MAX_EXPR, type, arg1, arg2)));\n \t\tbreak;\n \t      case NE_EXPR:\n \t\tbreak;\n@@ -8223,8 +8239,8 @@ fold (tree expr)\n \t  tem = invert_truthvalue (arg0);\n \n \t  if (TREE_CODE (tem) != TRUTH_NOT_EXPR)\n-\t    return fold (build (code, type, tem,\n-\t\t\t TREE_OPERAND (t, 2), TREE_OPERAND (t, 1)));\n+\t    return fold (build3 (code, type, tem,\n+\t\t\t\t TREE_OPERAND (t, 2), TREE_OPERAND (t, 1)));\n \t}\n \n       /* Convert A ? 1 : 0 to simply A.  */\n@@ -8262,8 +8278,8 @@ fold (tree expr)\n       if (integer_zerop (TREE_OPERAND (t, 2))\n \t  && truth_value_p (TREE_CODE (arg0))\n \t  && truth_value_p (TREE_CODE (arg1)))\n-\treturn pedantic_non_lvalue (fold (build (TRUTH_ANDIF_EXPR, type,\n-\t\t\t\t\t\t arg0, arg1)));\n+\treturn pedantic_non_lvalue (fold (build2 (TRUTH_ANDIF_EXPR, type,\n+\t\t\t\t\t\t  arg0, arg1)));\n \n       /* Convert A ? B : 1 into !A || B if A and B are truth values.  */\n       if (integer_onep (TREE_OPERAND (t, 2))\n@@ -8273,8 +8289,8 @@ fold (tree expr)\n \t  /* Only perform transformation if ARG0 is easily inverted.  */\n \t  tem = invert_truthvalue (arg0);\n \t  if (TREE_CODE (tem) != TRUTH_NOT_EXPR)\n-\t    return pedantic_non_lvalue (fold (build (TRUTH_ORIF_EXPR, type,\n-\t\t\t\t\t\t     tem, arg1)));\n+\t    return pedantic_non_lvalue (fold (build2 (TRUTH_ORIF_EXPR, type,\n+\t\t\t\t\t\t      tem, arg1)));\n \t}\n \n       return t;\n@@ -8303,11 +8319,11 @@ fold (tree expr)\n       else if (TREE_CODE (arg0) == COMPLEX_CST)\n \treturn TREE_REALPART (arg0);\n       else if (TREE_CODE (arg0) == PLUS_EXPR || TREE_CODE (arg0) == MINUS_EXPR)\n-\treturn fold (build (TREE_CODE (arg0), type,\n-\t\t\t    fold (build1 (REALPART_EXPR, type,\n-\t\t\t\t\t  TREE_OPERAND (arg0, 0))),\n-\t\t\t    fold (build1 (REALPART_EXPR,\n-\t\t\t\t\t  type, TREE_OPERAND (arg0, 1)))));\n+\treturn fold (build2 (TREE_CODE (arg0), type,\n+\t\t\t     fold (build1 (REALPART_EXPR, type,\n+\t\t\t\t\t   TREE_OPERAND (arg0, 0))),\n+\t\t\t     fold (build1 (REALPART_EXPR, type,\n+\t\t\t\t\t   TREE_OPERAND (arg0, 1)))));\n       return t;\n \n     case IMAGPART_EXPR:\n@@ -8319,11 +8335,11 @@ fold (tree expr)\n       else if (TREE_CODE (arg0) == COMPLEX_CST)\n \treturn TREE_IMAGPART (arg0);\n       else if (TREE_CODE (arg0) == PLUS_EXPR || TREE_CODE (arg0) == MINUS_EXPR)\n-\treturn fold (build (TREE_CODE (arg0), type,\n-\t\t\t    fold (build1 (IMAGPART_EXPR, type,\n-\t\t\t\t\t  TREE_OPERAND (arg0, 0))),\n-\t\t\t    fold (build1 (IMAGPART_EXPR, type,\n-\t\t\t\t\t  TREE_OPERAND (arg0, 1)))));\n+\treturn fold (build2 (TREE_CODE (arg0), type,\n+\t\t\t     fold (build1 (IMAGPART_EXPR, type,\n+\t\t\t\t\t   TREE_OPERAND (arg0, 0))),\n+\t\t\t     fold (build1 (IMAGPART_EXPR, type,\n+\t\t\t\t\t   TREE_OPERAND (arg0, 1)))));\n       return t;\n \n       /* Pull arithmetic ops out of the CLEANUP_POINT_EXPR where\n@@ -8353,15 +8369,15 @@ fold (tree expr)\n \t    if (TREE_CONSTANT (arg00)\n \t\t|| ((code0 == TRUTH_ANDIF_EXPR || code0 == TRUTH_ORIF_EXPR)\n \t\t    && ! has_cleanups (arg00)))\n-\t      return fold (build (code0, type, arg00,\n-\t\t\t\t  fold (build1 (CLEANUP_POINT_EXPR,\n-\t\t\t\t\t\tTREE_TYPE (arg01), arg01))));\n+\t      return fold (build2 (code0, type, arg00,\n+\t\t\t\t   fold (build1 (CLEANUP_POINT_EXPR,\n+\t\t\t\t\t\t TREE_TYPE (arg01), arg01))));\n \n \t    if (TREE_CONSTANT (arg01))\n-\t      return fold (build (code0, type,\n-\t\t\t\t  fold (build1 (CLEANUP_POINT_EXPR,\n-\t\t\t\t\t\tTREE_TYPE (arg00), arg00)),\n-\t\t\t\t  arg01));\n+\t      return fold (build2 (code0, type,\n+\t\t\t\t   fold (build1 (CLEANUP_POINT_EXPR,\n+\t\t\t\t\t\t TREE_TYPE (arg00), arg00)),\n+\t\t\t\t   arg01));\n \t  }\n \n \treturn t;\n@@ -9218,10 +9234,10 @@ fold_relational_hi_lo (enum tree_code *code_p, const tree type, tree *op0_p,\n \t      st0 = lang_hooks.types.signed_type (TREE_TYPE (op0));\n \t      st1 = lang_hooks.types.signed_type (TREE_TYPE (op1));\n \n-\t      exp = build (code == LE_EXPR ? GE_EXPR: LT_EXPR,\n-\t\t\t   type,\n-\t\t\t   convert (st0, op0),\n-\t\t\t   convert (st1, integer_zero_node));\n+\t      exp = build2 (code == LE_EXPR ? GE_EXPR: LT_EXPR,\n+\t\t\t    type,\n+\t\t\t    convert (st0, op0),\n+\t\t\t    convert (st1, integer_zero_node));\n \n \t      retval\n \t\t= nondestructive_fold_binary_to_constant (TREE_CODE (exp),\n@@ -9308,8 +9324,9 @@ nondestructive_fold_binary_to_constant (enum tree_code code, tree type,\n \t\t      == ADDR_EXPR)))\n \t  && TREE_CODE (TREE_OPERAND (op0, 1)) == INTEGER_CST)\n \t{\n-          return build (PLUS_EXPR, type, TREE_OPERAND (op0, 0),\n-\t\t\tconst_binop (PLUS_EXPR, op1, TREE_OPERAND (op0, 1), 0));\n+          return build2 (PLUS_EXPR, type, TREE_OPERAND (op0, 0),\n+\t\t\t const_binop (PLUS_EXPR, op1,\n+\t\t\t\t      TREE_OPERAND (op0, 1), 0));\n \t}\n     case BIT_XOR_EXPR:\n "}, {"sha": "f8b677926b5c90a9866d89a31cc58567964ea1df", "filename": "gcc/tree.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59ce6d6beeaac84f468963740cc09f40eefc398f/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59ce6d6beeaac84f468963740cc09f40eefc398f/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=59ce6d6beeaac84f468963740cc09f40eefc398f", "patch": "@@ -1260,7 +1260,7 @@ array_type_nelts (tree type)\n \n   return (integer_zerop (min)\n \t  ? max\n-\t  : fold (build (MINUS_EXPR, TREE_TYPE (max), max, min)));\n+\t  : fold (build2 (MINUS_EXPR, TREE_TYPE (max), max, min)));\n }\n \f\n /* Return nonzero if arg is static -- a reference to an object in\n@@ -1383,7 +1383,8 @@ save_expr (tree expr)\n   if (contains_placeholder_p (inner))\n     return t;\n \n-  t = build (SAVE_EXPR, TREE_TYPE (expr), t, current_function_decl, NULL_TREE);\n+  t = build3 (SAVE_EXPR, TREE_TYPE (expr), t, current_function_decl,\n+\t      NULL_TREE);\n \n   /* This expression might be placed ahead of a jump to ensure that the\n      value was computed on both sides of the jump.  So make sure it isn't\n@@ -1938,7 +1939,7 @@ substitute_in_expr (tree exp, tree f, tree r)\n      if (op0 == TREE_OPERAND (exp, 0))\n        return exp;\n \n-     new = fold (build (code, TREE_TYPE (exp), op0, TREE_OPERAND (exp, 1)));\n+     new = fold (build2 (code, TREE_TYPE (exp), op0, TREE_OPERAND (exp, 1)));\n    }\n   else\n     switch (TREE_CODE_CLASS (code))\n@@ -4458,8 +4459,8 @@ get_unwidened (tree op, tree for_type)\n \t  && (for_type || ! DECL_BIT_FIELD (TREE_OPERAND (op, 1)))\n \t  && (! uns || final_prec <= innerprec || unsignedp))\n \t{\n-\t  win = build (COMPONENT_REF, type, TREE_OPERAND (op, 0),\n-\t\t       TREE_OPERAND (op, 1));\n+\t  win = build2 (COMPONENT_REF, type, TREE_OPERAND (op, 0),\n+\t\t\tTREE_OPERAND (op, 1));\n \t  TREE_SIDE_EFFECTS (win) = TREE_SIDE_EFFECTS (op);\n \t  TREE_THIS_VOLATILE (win) = TREE_THIS_VOLATILE (op);\n \t}\n@@ -4547,8 +4548,8 @@ get_narrower (tree op, int *unsignedp_ptr)\n \t{\n \t  if (first)\n \t    uns = DECL_UNSIGNED (TREE_OPERAND (op, 1));\n-\t  win = build (COMPONENT_REF, type, TREE_OPERAND (op, 0),\n-\t\t       TREE_OPERAND (op, 1));\n+\t  win = build2 (COMPONENT_REF, type, TREE_OPERAND (op, 0),\n+\t\t\tTREE_OPERAND (op, 1));\n \t  TREE_SIDE_EFFECTS (win) = TREE_SIDE_EFFECTS (op);\n \t  TREE_THIS_VOLATILE (win) = TREE_THIS_VOLATILE (op);\n \t}"}]}