{"sha": "711d877c9e4f9b3250bc50e54c672b40840d574a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzExZDg3N2M5ZTRmOWIzMjUwYmM1MGU1NGM2NzJiNDA4NDBkNTc0YQ==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2000-01-14T17:14:43Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2000-01-14T17:14:43Z"}, "message": "eh-common.h: PROTO -> PARAMS.\n\n\t* eh-common.h: PROTO -> PARAMS.\n\t* emit-rtl.c: Likewise.\n\t* errors.c: Likewise.\n\t* errors.h: Likewise.\n\t* except.c: Likewise.\n\t* except.h: Likewise.\n\t* explow.c: Likewise.\n\t* expmed.c: Likewise.\n\t* expr.c: Likewise.\n\t* expr.h: Likewise.\n\t* final.c: Likewise.\n\t* fix-header.c: Likewise.\n\t* flow.c: Likewise.\n\t* fold-const.c: Likewise.\n\t* function.c: Likewise.\n\t* function.h: Likewise.\n\t* gcc.c: Likewise.\n\t* gcov-io.h: Likewise.\n\t* gcov.c: Likewise.\n\t* gcse.c: Likewise.\n\nFrom-SVN: r31419", "tree": {"sha": "c581c8d237ef2fffdfeee6182fd81e25ea6ed527", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c581c8d237ef2fffdfeee6182fd81e25ea6ed527"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/711d877c9e4f9b3250bc50e54c672b40840d574a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/711d877c9e4f9b3250bc50e54c672b40840d574a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/711d877c9e4f9b3250bc50e54c672b40840d574a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/711d877c9e4f9b3250bc50e54c672b40840d574a/comments", "author": null, "committer": null, "parents": [{"sha": "318881c06efdf1bc4039f1bba7eab820d69735a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/318881c06efdf1bc4039f1bba7eab820d69735a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/318881c06efdf1bc4039f1bba7eab820d69735a2"}], "stats": {"total": 1575, "additions": 801, "deletions": 774}, "files": [{"sha": "fecb80c27b8ed17da5c81c4af4081c112efdb205", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711d877c9e4f9b3250bc50e54c672b40840d574a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711d877c9e4f9b3250bc50e54c672b40840d574a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=711d877c9e4f9b3250bc50e54c672b40840d574a", "patch": "@@ -1,3 +1,26 @@\n+2000-01-14  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* eh-common.h: PROTO -> PARAMS.\n+\t* emit-rtl.c: Likewise.\n+\t* errors.c: Likewise.\n+\t* errors.h: Likewise.\n+\t* except.c: Likewise.\n+\t* except.h: Likewise.\n+\t* explow.c: Likewise.\n+\t* expmed.c: Likewise.\n+\t* expr.c: Likewise.\n+\t* expr.h: Likewise.\n+\t* final.c: Likewise.\n+\t* fix-header.c: Likewise.\n+\t* flow.c: Likewise.\n+\t* fold-const.c: Likewise.\n+\t* function.c: Likewise.\n+\t* function.h: Likewise.\n+\t* gcc.c: Likewise.\n+\t* gcov-io.h: Likewise.\n+\t* gcov.c: Likewise.\n+\t* gcse.c: Likewise.\n+\n 2000-01-14  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* sh-protos.h: New file."}, {"sha": "20adfd613f03005f578c66d8e6356246a7d5cba1", "filename": "gcc/eh-common.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711d877c9e4f9b3250bc50e54c672b40840d574a/gcc%2Feh-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711d877c9e4f9b3250bc50e54c672b40840d574a/gcc%2Feh-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Feh-common.h?ref=711d877c9e4f9b3250bc50e54c672b40840d574a", "patch": "@@ -1,5 +1,5 @@\n /* EH stuff\n-   Copyright (C) 1997, 1998, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -102,7 +102,8 @@ struct __eh_info; /* forward declaration */\n     3 - exception table region is in (exception descriptor *)\n */\n \n-typedef void * (*__eh_matcher)          PROTO ((struct __eh_info *, void *, struct exception_descriptor *));\n+typedef void * (*__eh_matcher)\tPARAMS ((struct __eh_info *, void *,\n+\t\t\t\t\t struct exception_descriptor *));\n \n /* This value is to be checked as a 'match all' case in the runtime field. */\n "}, {"sha": "304e6d43f9397dec2c88a2782c0da0e3ba098456", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711d877c9e4f9b3250bc50e54c672b40840d574a/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711d877c9e4f9b3250bc50e54c672b40840d574a/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=711d877c9e4f9b3250bc50e54c672b40840d574a", "patch": "@@ -1,5 +1,5 @@\n /* Emit RTL for the GNU C-Compiler expander.\n-   Copyright (C) 1987, 88, 92-97, 1998, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 92-99, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -166,10 +166,10 @@ static rtx free_insn;\n /* This is where the pointer to the obstack being used for RTL is stored.  */\n extern struct obstack *rtl_obstack;\n \n-static rtx make_jump_insn_raw\t\tPROTO((rtx));\n-static rtx make_call_insn_raw\t\tPROTO((rtx));\n-static rtx find_line_note\t\tPROTO((rtx));\n-static void mark_sequence_stack         PROTO((struct sequence_stack *));\n+static rtx make_jump_insn_raw\t\tPARAMS ((rtx));\n+static rtx make_call_insn_raw\t\tPARAMS ((rtx));\n+static rtx find_line_note\t\tPARAMS ((rtx));\n+static void mark_sequence_stack         PARAMS ((struct sequence_stack *));\n \f\n /* There are some RTL codes that require special attention; the generation\n    functions do the raw handling.  If you add to this list, modify\n@@ -298,7 +298,7 @@ gen_rtx_MEM (mode, addr)\n \n /*VARARGS2*/\n rtx\n-gen_rtx VPROTO((enum rtx_code code, enum machine_mode mode, ...))\n+gen_rtx VPARAMS ((enum rtx_code code, enum machine_mode mode, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   enum rtx_code code;\n@@ -399,7 +399,7 @@ gen_rtx VPROTO((enum rtx_code code, enum machine_mode mode, ...))\n \n /*VARARGS1*/\n rtvec\n-gen_rtvec VPROTO((int n, ...))\n+gen_rtvec VPARAMS ((int n, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   int n;"}, {"sha": "bc3667e92896e7ab926958405a81b271603f4ab5", "filename": "gcc/errors.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711d877c9e4f9b3250bc50e54c672b40840d574a/gcc%2Ferrors.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711d877c9e4f9b3250bc50e54c672b40840d574a/gcc%2Ferrors.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ferrors.c?ref=711d877c9e4f9b3250bc50e54c672b40840d574a", "patch": "@@ -1,5 +1,5 @@\n /* Basic error reporting routines.\n-   Copyright (C) 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -37,7 +37,7 @@ int have_error = 0;\n /* Print a warning message - output produced, but there may be problems.  */\n \n void\n-warning VPROTO ((const char *format, ...))\n+warning VPARAMS ((const char *format, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   const char *format;\n@@ -60,7 +60,7 @@ warning VPROTO ((const char *format, ...))\n /* Print an error message - we keep going but the output is unusable.  */\n \n void\n-error VPROTO ((const char *format, ...))\n+error VPARAMS ((const char *format, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   const char *format;\n@@ -85,7 +85,7 @@ error VPROTO ((const char *format, ...))\n /* Fatal error - terminate execution immediately.  Does not return.  */\n \n void\n-fatal VPROTO ((const char *format, ...))\n+fatal VPARAMS ((const char *format, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   const char *format;"}, {"sha": "843c1c879f6610049073a15565e256687e7bcfff", "filename": "gcc/errors.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711d877c9e4f9b3250bc50e54c672b40840d574a/gcc%2Ferrors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711d877c9e4f9b3250bc50e54c672b40840d574a/gcc%2Ferrors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ferrors.h?ref=711d877c9e4f9b3250bc50e54c672b40840d574a", "patch": "@@ -1,5 +1,5 @@\n /* Basic error reporting routines.\n-   Copyright (C) 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -25,9 +25,9 @@ Boston, MA 02111-1307, USA.  */\n #ifndef __GCC_ERRORS_H__\n #define __GCC_ERRORS_H__\n \n-extern void warning PVPROTO ((const char *format, ...)) ATTRIBUTE_PRINTF_1;\n-extern void error   PVPROTO ((const char *format, ...)) ATTRIBUTE_PRINTF_1;\n-extern void fatal   PVPROTO ((const char *format, ...))\n+extern void warning PARAMS ((const char *format, ...)) ATTRIBUTE_PRINTF_1;\n+extern void error   PARAMS ((const char *format, ...)) ATTRIBUTE_PRINTF_1;\n+extern void fatal   PARAMS ((const char *format, ...))\n     ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n \n extern int have_error;"}, {"sha": "9e27fbab2dbda6b70209e2bad552c3cda1c6ba2d", "filename": "gcc/except.c", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711d877c9e4f9b3250bc50e54c672b40840d574a/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711d877c9e4f9b3250bc50e54c672b40840d574a/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=711d877c9e4f9b3250bc50e54c672b40840d574a", "patch": "@@ -453,39 +453,39 @@ static rtx last_rethrow_symbol = NULL_RTX;\n \n /* Prototypes for local functions.  */\n \n-static void push_eh_entry\tPROTO((struct eh_stack *));\n-static struct eh_entry * pop_eh_entry\t\tPROTO((struct eh_stack *));\n-static void enqueue_eh_entry\tPROTO((struct eh_queue *, struct eh_entry *));\n-static struct eh_entry * dequeue_eh_entry\tPROTO((struct eh_queue *));\n-static rtx call_get_eh_context\tPROTO((void));\n-static void start_dynamic_cleanup\t\tPROTO((tree, tree));\n-static void start_dynamic_handler\t\tPROTO((void));\n-static void expand_rethrow\tPROTO((rtx));\n-static void output_exception_table_entry\tPROTO((FILE *, int));\n-static int can_throw\t\tPROTO((rtx));\n-static rtx scan_region\t\tPROTO((rtx, int, int *));\n-static void eh_regs\t\tPROTO((rtx *, rtx *, rtx *, int));\n-static void set_insn_eh_region\tPROTO((rtx *, int));\n+static void push_eh_entry\tPARAMS ((struct eh_stack *));\n+static struct eh_entry * pop_eh_entry\tPARAMS ((struct eh_stack *));\n+static void enqueue_eh_entry\tPARAMS ((struct eh_queue *, struct eh_entry *));\n+static struct eh_entry * dequeue_eh_entry\tPARAMS ((struct eh_queue *));\n+static rtx call_get_eh_context\tPARAMS ((void));\n+static void start_dynamic_cleanup\tPARAMS ((tree, tree));\n+static void start_dynamic_handler\tPARAMS ((void));\n+static void expand_rethrow\tPARAMS ((rtx));\n+static void output_exception_table_entry\tPARAMS ((FILE *, int));\n+static int can_throw\t\tPARAMS ((rtx));\n+static rtx scan_region\t\tPARAMS ((rtx, int, int *));\n+static void eh_regs\t\tPARAMS ((rtx *, rtx *, rtx *, int));\n+static void set_insn_eh_region\tPARAMS ((rtx *, int));\n #ifdef DONT_USE_BUILTIN_SETJMP\n-static void jumpif_rtx\t\tPROTO((rtx, rtx));\n+static void jumpif_rtx\t\tPARAMS ((rtx, rtx));\n #endif\n-static void mark_eh_node        PROTO((struct eh_node *));\n-static void mark_eh_stack       PROTO((struct eh_stack *));\n-static void mark_eh_queue       PROTO((struct eh_queue *));\n-static void mark_tree_label_node PROTO ((struct label_node *));\n-static void mark_func_eh_entry\tPROTO ((void *));\n-static rtx create_rethrow_ref\tPROTO ((int));\n-static void push_entry\t\tPROTO ((struct eh_stack *, struct eh_entry*));\n-static void receive_exception_label PROTO ((rtx));\n-static int new_eh_region_entry\tPROTO ((int, rtx));\n-static int find_func_region\tPROTO ((int));\n-static int find_func_region_from_symbol PROTO ((rtx));\n-static void clear_function_eh_region PROTO ((void));\n-static void process_nestinfo\tPROTO ((int, eh_nesting_info *, int *));\n-\n-rtx expand_builtin_return_addr\tPROTO((enum built_in_function, int, rtx));\n-static void emit_cleanup_handler PROTO ((struct eh_entry *));\n-static int eh_region_from_symbol PROTO((rtx));\n+static void mark_eh_node        PARAMS ((struct eh_node *));\n+static void mark_eh_stack       PARAMS ((struct eh_stack *));\n+static void mark_eh_queue       PARAMS ((struct eh_queue *));\n+static void mark_tree_label_node PARAMS ((struct label_node *));\n+static void mark_func_eh_entry\tPARAMS ((void *));\n+static rtx create_rethrow_ref\tPARAMS ((int));\n+static void push_entry\t\tPARAMS ((struct eh_stack *, struct eh_entry*));\n+static void receive_exception_label PARAMS ((rtx));\n+static int new_eh_region_entry\tPARAMS ((int, rtx));\n+static int find_func_region\tPARAMS ((int));\n+static int find_func_region_from_symbol PARAMS ((rtx));\n+static void clear_function_eh_region PARAMS ((void));\n+static void process_nestinfo\tPARAMS ((int, eh_nesting_info *, int *));\n+\n+rtx expand_builtin_return_addr\tPARAMS ((enum built_in_function, int, rtx));\n+static void emit_cleanup_handler PARAMS ((struct eh_entry *));\n+static int eh_region_from_symbol PARAMS ((rtx));\n \n \f\n /* Various support routines to manipulate the various data structures"}, {"sha": "414f52ae6da66ef2befc6e1fdf9d60ba9e523dc7", "filename": "gcc/except.h", "status": "modified", "additions": 66, "deletions": 65, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711d877c9e4f9b3250bc50e54c672b40840d574a/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711d877c9e4f9b3250bc50e54c672b40840d574a/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=711d877c9e4f9b3250bc50e54c672b40840d574a", "patch": "@@ -1,5 +1,5 @@\n /* Exception Handling interface routines.\n-   Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 97-99, 2000 Free Software Foundation, Inc.\n    Contributed by Mike Stump <mrs@cygnus.com>.\n \n This file is part of GNU CC.\n@@ -153,14 +153,14 @@ struct eh_status\n    this point are considered to be part of the region until\n    expand_eh_region_end () is invoked.  */\n \n-extern void expand_eh_region_start\t\tPROTO((void));\n+extern void expand_eh_region_start\t\tPARAMS ((void));\n \n /* Just like expand_eh_region_start, except if a cleanup action is\n    entered on the cleanup chain, the TREE_PURPOSE of the element put\n    on the chain is DECL.  DECL should be the associated VAR_DECL, if\n    any, otherwise it should be NULL_TREE.  */\n \n-extern void expand_eh_region_start_for_decl\tPROTO((tree));\n+extern void expand_eh_region_start_for_decl\tPARAMS ((tree));\n \n /* Start an exception handling region for the given cleanup action.\n    All instructions emitted after this point are considered to be part\n@@ -174,7 +174,7 @@ extern void expand_eh_region_start_for_decl\tPROTO((tree));\n    generation, and optimizes it so as to not need the exception\n    region.  */\n \n-extern int expand_eh_region_start_tree\t\tPROTO((tree, tree));\n+extern int expand_eh_region_start_tree\t\tPARAMS ((tree, tree));\n \n /* End an exception handling region.  The information about the region\n    is found on the top of ehstack.\n@@ -185,33 +185,34 @@ extern int expand_eh_region_start_tree\t\tPROTO((tree, tree));\n    HANDLER will be transformed to rtl when expand_leftover_cleanups ()\n    is invoked.  */\n \n-extern void expand_eh_region_end\t\tPROTO((tree));\n+extern void expand_eh_region_end\t\tPARAMS ((tree));\n \n /* Push RLABEL or TLABEL onto LABELSTACK. Only one of RLABEL or TLABEL\n    should be set; the other must be NULL.  */\n \n-extern void push_label_entry\t\t\tPROTO((struct label_node **labelstack, rtx rlabel, tree tlabel));\n+extern void push_label_entry\tPARAMS ((struct label_node **labelstack,\n+\t\t\t\t\t rtx rlabel, tree tlabel));\n \n /* Pop the topmost entry from LABELSTACK and return its value as an\n    rtx node. If LABELSTACK is empty, return NULL.  */\n \n-extern rtx pop_label_entry\t\t\tPROTO((struct label_node **labelstack));\n+extern rtx pop_label_entry\tPARAMS ((struct label_node **labelstack));\n \n /* Return the topmost entry of LABELSTACK as a tree node, or return\n    NULL_TREE if LABELSTACK is empty.  */\n \n-extern tree top_label_entry\t\t\tPROTO((struct label_node **labelstack));\n+extern tree top_label_entry\tPARAMS ((struct label_node **labelstack));\n \n #endif\n \n /* Test: is exception handling turned on? */\n \n-extern int doing_eh\t\t\t\t       PROTO ((int));\n+extern int doing_eh\t\t\t        PARAMS ((int));\n \n /* Toplevel initialization for EH.  */\n \n-void set_exception_lang_code                    PROTO((int));\n-void set_exception_version_code                 PROTO((int));\n+void set_exception_lang_code                    PARAMS ((int));\n+void set_exception_version_code                 PARAMS ((int));\n \n /* A list of handlers asocciated with an exception region. HANDLER_LABEL\n    is the the label that control should be transfered to if the data\n@@ -238,45 +239,45 @@ typedef struct handler_info\n    typeinfo entry. Regardless where it is positioned, a NULL_TREE entry\n    is always output as the LAST handler in the exception table for a region. */\n \n-void add_new_handler                       PROTO((int, struct handler_info *));\n+void add_new_handler\t\t\tPARAMS ((int, struct handler_info *));\n \n /* Remove a handler label. The handler label is being deleted, so all\n    regions which reference this handler should have it removed from their\n    list of possible handlers. Any region which has the final handler\n    removed can be deleted. */\n \n-void remove_handler                        PROTO((rtx));\n+void remove_handler\t\t\tPARAMS ((rtx));\n \n /* Create a new handler structure initialized with the handler label and\n    typeinfo fields passed in. */\n \n-struct handler_info *get_new_handler            PROTO((rtx, void *));\n+struct handler_info *get_new_handler            PARAMS ((rtx, void *));\n \n /* Make a duplicate of an exception region by copying all the handlers\n    for an exception region. Return the new handler index. */\n \n-int duplicate_eh_handlers                       PROTO((int, int, rtx (*)(rtx)));\n+int duplicate_eh_handlers\t\tPARAMS ((int, int, rtx (*)(rtx)));\n \n /* map symbol refs for rethrow */\n \n-rtx rethrow_symbol_map                          PROTO((rtx, rtx (*)(rtx)));\n+rtx rethrow_symbol_map                          PARAMS ((rtx, rtx (*)(rtx)));\n \n /* Is the rethrow label for a region used? */\n \n-int rethrow_used                                PROTO((int));\n+int rethrow_used                                PARAMS ((int));\n \n /* Update the rethrow references to reflect rethrows which have been\n    optimized away.  */\n \n-void update_rethrow_references\t\t\tPROTO((void));\n+void update_rethrow_references\t\t\tPARAMS ((void));\n \n /* Get a pointer to the first handler in an exception region's list. */\n \n-struct handler_info *get_first_handler          PROTO((int));\n+struct handler_info *get_first_handler          PARAMS ((int));\n \n /* Find all the runtime handlers type matches currently referenced */\n \n-int find_all_handler_type_matches               PROTO((void ***));\n+int find_all_handler_type_matches               PARAMS ((void ***));\n \n /* The eh_nesting_info structure is used to find a list of valid handlers\n    for any arbitrary exception region.  When init_eh_nesting_info is called,\n@@ -307,114 +308,114 @@ typedef struct eh_nesting\n \n /* Initialize the eh_nesting_info structure.  */\n \n-eh_nesting_info *init_eh_nesting_info \t\tPROTO((void));\n+eh_nesting_info *init_eh_nesting_info \t\tPARAMS ((void));\n \n /* Get a list of handlers reachable from a an exception region/insn.  */\n \n-int reachable_handlers \t\t\tPROTO((int, eh_nesting_info *, rtx, \n-\t\t\t\t\t       handler_info ***handlers));\n+int reachable_handlers \t\t\tPARAMS ((int, eh_nesting_info *, rtx, \n+\t\t\t\t\t\t handler_info ***handlers));\n \n /* Free the eh_nesting_info structure.  */\n \n-void free_eh_nesting_info \t\t\tPROTO((eh_nesting_info *));\n+void free_eh_nesting_info \t\t\tPARAMS ((eh_nesting_info *));\n \n-extern void init_eh\t\t\t\tPROTO((void));\n+extern void init_eh\t\t\t\tPARAMS ((void));\n \n /* Initialization for the per-function EH data.  */\n \n-extern void init_eh_for_function\t\tPROTO((void));\n+extern void init_eh_for_function\t\tPARAMS ((void));\n \n /* Generate an exception label. Use instead of gen_label_rtx */\n \n-extern rtx gen_exception_label                  PROTO((void));\n+extern rtx gen_exception_label                  PARAMS ((void));\n \n /* Adds an EH table entry for EH entry number N. Called from\n    final_scan_insn for NOTE_INSN_EH_REGION_BEG.  */\n \n-extern void add_eh_table_entry\t\t\tPROTO((int n));\n+extern void add_eh_table_entry\t\t\tPARAMS ((int n));\n \n /* Start a catch clause, triggered by runtime value paramter. */\n \n #ifdef TREE_CODE\n-extern void start_catch_handler                 PROTO((tree));\n+extern void start_catch_handler                 PARAMS ((tree));\n #endif\n \n /* End an individual catch clause. */\n \n-extern void end_catch_handler                   PROTO((void));\n+extern void end_catch_handler                   PARAMS ((void));\n \n /* Returns a non-zero value if we need to output an exception table.  */\n \n-extern int exception_table_p\t\t\tPROTO((void));\n+extern int exception_table_p\t\t\tPARAMS ((void));\n \n /* Outputs the exception table if we have one.  */\n \n-extern void output_exception_table\t\tPROTO((void));\n+extern void output_exception_table\t\tPARAMS ((void));\n \n /* Given a return address in ADDR, determine the address we should use\n    to find the corresponding EH region.  */\n \n-extern rtx eh_outer_context\t\t\tPROTO((rtx addr));\n+extern rtx eh_outer_context\t\t\tPARAMS ((rtx addr));\n \n /* Called at the start of a block of try statements for which there is\n    a supplied catch handler.  */\n \n-extern void expand_start_try_stmts \t\tPROTO((void));\n+extern void expand_start_try_stmts \t\tPARAMS ((void));\n \n /* Called at the start of a block of catch statements. It terminates the\n    previous set of try statements.  */\n \n-extern void expand_start_all_catch\t\tPROTO((void));\n+extern void expand_start_all_catch\t\tPARAMS ((void));\n \n /* Called at the end of a block of catch statements.  */\n \n-extern void expand_end_all_catch\t\tPROTO((void));\n+extern void expand_end_all_catch\t\tPARAMS ((void));\n \n /* Begin a region that will contain entries created with\n    add_partial_entry.  */\n \n-extern void begin_protect_partials              PROTO((void));\n+extern void begin_protect_partials              PARAMS ((void));\n \n #ifdef TREE_CODE\n /* Create a new exception region and add the handler for the region\n    onto a list. These regions will be ended (and their handlers\n    emitted) when end_protect_partials is invoked.  */\n \n-extern void add_partial_entry\t\t\tPROTO((tree handler));\n+extern void add_partial_entry\t\t\tPARAMS ((tree handler));\n #endif\n \n /* End all of the pending exception regions that have handlers added with\n    push_protect_entry ().  */\n \n-extern void end_protect_partials\t\tPROTO((void));\n+extern void end_protect_partials\t\tPARAMS ((void));\n \n /* An internal throw.  */\n \n-extern void expand_internal_throw\t\tPROTO((void));\n+extern void expand_internal_throw\t\tPARAMS ((void));\n \n /* Called from expand_exception_blocks and expand_end_catch_block to\n    expand and pending handlers.  */\n \n-extern void expand_leftover_cleanups\t\tPROTO((void));\n+extern void expand_leftover_cleanups\t\tPARAMS ((void));\n \n /* If necessary, emit insns to get EH context for the current\n    function. */\n \n-extern void emit_eh_context\t\t\tPROTO((void));\n+extern void emit_eh_context\t\t\tPARAMS ((void));\n \n /* Builds a list of handler labels and puts them in the global\n    variable exception_handler_labels.  */\n \n-extern void find_exception_handler_labels\tPROTO((void));\n+extern void find_exception_handler_labels\tPARAMS ((void));\n \n /* Determine if an arbitrary label is an exception label */\n \n-extern int is_exception_handler_label           PROTO((int));\n+extern int is_exception_handler_label           PARAMS ((int));\n \n /* Performs sanity checking on the check_exception_handler_labels\n    list.  */\n \n-extern void check_exception_handler_labels\tPROTO((void));\n+extern void check_exception_handler_labels\tPARAMS ((void));\n \n /* Keeps track of the label used as the context of a throw to rethrow an\n    exception to the outer exception region.  */\n@@ -429,26 +430,26 @@ extern rtx exception_handler_labels;\n /* Performs optimizations for exception handling, such as removing\n    unnecessary exception regions. Invoked from jump_optimize ().  */\n \n-extern void exception_optimize\t\t\tPROTO((void));\n+extern void exception_optimize\t\t\tPARAMS ((void));\n \n /* Return EH context (and set it up once per fn).  */\n-extern rtx get_eh_context\t\t\tPROTO((void));\n+extern rtx get_eh_context\t\t\tPARAMS ((void));\n \n /* Get the dynamic handler chain.  */\n-extern rtx get_dynamic_handler_chain\t\tPROTO((void));\n+extern rtx get_dynamic_handler_chain\t\tPARAMS ((void));\n \n /* Get the dynamic cleanup chain.  */\n-extern rtx get_dynamic_cleanup_chain\t\tPROTO((void));\n+extern rtx get_dynamic_cleanup_chain\t\tPARAMS ((void));\n \n /* Throw an exception.  */\n \n-extern void emit_throw\t\t\t\tPROTO((void));\n+extern void emit_throw\t\t\t\tPARAMS ((void));\n \n /* Save away the current ehqueue.  */\n-extern void push_ehqueue                        PROTO((void));\n+extern void push_ehqueue                        PARAMS ((void));\n \n /* Restore a previously pushed ehqueue.  */\n-extern void pop_ehqueue                         PROTO((void));\n+extern void pop_ehqueue                         PARAMS ((void));\n \n /* One to use setjmp/longjmp method of generating code.  */\n \n@@ -464,32 +465,32 @@ extern int asynchronous_exceptions;\n extern int protect_cleanup_actions_with_terminate;\n \n #ifdef TREE_CODE\n-extern tree protect_with_terminate\t\tPROTO((tree));\n+extern tree protect_with_terminate\t\tPARAMS ((tree));\n #endif\n \n-extern void expand_fixup_region_start\tPROTO((void));\n+extern void expand_fixup_region_start\tPARAMS ((void));\n #ifdef TREE_CODE\n-extern void expand_fixup_region_end\tPROTO((tree));\n+extern void expand_fixup_region_end\tPARAMS ((tree));\n #endif\n \n /* Various hooks for the DWARF 2 __throw routine.  */\n \n-void expand_builtin_unwind_init\t\tPROTO((void));\n-rtx expand_builtin_dwarf_fp_regnum\tPROTO((void));\n+void expand_builtin_unwind_init\t\tPARAMS ((void));\n+rtx expand_builtin_dwarf_fp_regnum\tPARAMS ((void));\n #ifdef TREE_CODE\n-rtx expand_builtin_frob_return_addr\tPROTO((tree));\n-rtx expand_builtin_extract_return_addr\tPROTO((tree));\n-void expand_builtin_init_dwarf_reg_sizes\tPROTO((tree));\n-void expand_builtin_eh_return\t\tPROTO((tree, tree, tree));\n+rtx expand_builtin_frob_return_addr\tPARAMS ((tree));\n+rtx expand_builtin_extract_return_addr\tPARAMS ((tree));\n+void expand_builtin_init_dwarf_reg_sizes\tPARAMS ((tree));\n+void expand_builtin_eh_return\t\tPARAMS ((tree, tree, tree));\n #endif\n-void expand_eh_return\t\t\tPROTO((void));\n+void expand_eh_return\t\t\tPARAMS ((void));\n \n \n /* Checking whether 2 instructions are within the same exception region. */\n \n-int in_same_eh_region                   PROTO((rtx, rtx));\n-void free_insn_eh_region                PROTO((void));\n-void init_insn_eh_region                PROTO((rtx, int));\n+int in_same_eh_region                   PARAMS ((rtx, rtx));\n+void free_insn_eh_region                PARAMS ((void));\n+void init_insn_eh_region                PARAMS ((rtx, int));\n \n #ifdef rtx\n #undef rtx"}, {"sha": "65e43a717477b52637dd9026a91e05784f7d1f6e", "filename": "gcc/explow.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711d877c9e4f9b3250bc50e54c672b40840d574a/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711d877c9e4f9b3250bc50e54c672b40840d574a/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=711d877c9e4f9b3250bc50e54c672b40840d574a", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines for manipulating rtx's in semantically interesting ways.\n-   Copyright (C) 1987, 91, 94-97, 1998, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 91, 94-99, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -38,8 +38,8 @@ Boston, MA 02111-1307, USA.  */\n #define PREFERRED_STACK_BOUNDARY STACK_BOUNDARY\n #endif\n \n-static rtx break_out_memory_refs\tPROTO((rtx));\n-static void emit_stack_probe\t\tPROTO((rtx));\n+static rtx break_out_memory_refs\tPARAMS ((rtx));\n+static void emit_stack_probe\t\tPARAMS ((rtx));\n \n \n /* Truncate and perhaps sign-extend C as appropriate for MODE.  */\n@@ -938,7 +938,7 @@ emit_stack_save (save_level, psave, after)\n {\n   rtx sa = *psave;\n   /* The default is that we use a move insn and save in a Pmode object.  */\n-  rtx (*fcn) PROTO ((rtx, rtx)) = gen_move_insn;\n+  rtx (*fcn) PARAMS ((rtx, rtx)) = gen_move_insn;\n   enum machine_mode mode = STACK_SAVEAREA_MODE (save_level);\n \n   /* See if this machine has anything special to do for this kind of save.  */\n@@ -1020,7 +1020,7 @@ emit_stack_restore (save_level, sa, after)\n      rtx sa;\n {\n   /* The default is that we use a move insn.  */\n-  rtx (*fcn) PROTO ((rtx, rtx)) = gen_move_insn;\n+  rtx (*fcn) PARAMS ((rtx, rtx)) = gen_move_insn;\n \n   /* See if this machine has anything special to do for this kind of save.  */\n   switch (save_level)"}, {"sha": "63441875e9bda5b476c1834bbbeae2f652c1a203", "filename": "gcc/expmed.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711d877c9e4f9b3250bc50e54c672b40840d574a/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711d877c9e4f9b3250bc50e54c672b40840d574a/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=711d877c9e4f9b3250bc50e54c672b40840d574a", "patch": "@@ -34,17 +34,17 @@ Boston, MA 02111-1307, USA.  */\n #include \"real.h\"\n #include \"recog.h\"\n \n-static void store_fixed_bit_field\tPROTO((rtx, int, int, int, rtx, int));\n-static void store_split_bit_field\tPROTO((rtx, int, int, rtx, int));\n-static rtx extract_fixed_bit_field\tPROTO((enum machine_mode, rtx, int,\n-\t\t\t\t\t       int, int, rtx, int, int));\n-static rtx mask_rtx\t\t\tPROTO((enum machine_mode, int,\n-\t\t\t\t\t       int, int));\n-static rtx lshift_value\t\t\tPROTO((enum machine_mode, rtx,\n-\t\t\t\t\t       int, int));\n-static rtx extract_split_bit_field\tPROTO((rtx, int, int, int, int));\n-static void do_cmp_and_jump\t\tPROTO((rtx, rtx, enum rtx_code,\n-\t\t\t\t\t       enum machine_mode, rtx));\n+static void store_fixed_bit_field\tPARAMS ((rtx, int, int, int, rtx, int));\n+static void store_split_bit_field\tPARAMS ((rtx, int, int, rtx, int));\n+static rtx extract_fixed_bit_field\tPARAMS ((enum machine_mode, rtx, int,\n+\t\t\t\t\t\t int, int, rtx, int, int));\n+static rtx mask_rtx\t\t\tPARAMS ((enum machine_mode, int,\n+\t\t\t\t\t\t int, int));\n+static rtx lshift_value\t\t\tPARAMS ((enum machine_mode, rtx,\n+\t\t\t\t\t\t int, int));\n+static rtx extract_split_bit_field\tPARAMS ((rtx, int, int, int, int));\n+static void do_cmp_and_jump\t\tPARAMS ((rtx, rtx, enum rtx_code,\n+\t\t\t\t\t\t enum machine_mode, rtx));\n \n /* Non-zero means divides or modulus operations are relatively cheap for\n    powers of two, so don't use branches; emit the operation instead. \n@@ -2057,15 +2057,15 @@ struct algorithm\n   char log[MAX_BITS_PER_WORD];\n };\n \n-static void synth_mult\t\t\tPROTO((struct algorithm *,\n-\t\t\t\t\t       unsigned HOST_WIDE_INT,\n-\t\t\t\t\t       int));\n-static unsigned HOST_WIDE_INT choose_multiplier PROTO((unsigned HOST_WIDE_INT,\n-\t\t\t\t\t\t       int, int,\n-\t\t\t\t\t\t       unsigned HOST_WIDE_INT *,\n-\t\t\t\t\t\t       int *, int *));\n-static unsigned HOST_WIDE_INT invert_mod2n\tPROTO((unsigned HOST_WIDE_INT,\n-\t\t\t\t\t\t       int));\n+static void synth_mult\t\t\tPARAMS ((struct algorithm *,\n+\t\t\t\t\t\t unsigned HOST_WIDE_INT,\n+\t\t\t\t\t\t int));\n+static unsigned HOST_WIDE_INT choose_multiplier PARAMS ((unsigned HOST_WIDE_INT,\n+\t\t\t\t\t\t\t int, int,\n+\t\t\t\t\t\t\t unsigned HOST_WIDE_INT *,\n+\t\t\t\t\t\t\t int *, int *));\n+static unsigned HOST_WIDE_INT invert_mod2n\tPARAMS ((unsigned HOST_WIDE_INT,\n+\t\t\t\t\t\t\t int));\n /* Compute and return the best algorithm for multiplying by T.\n    The algorithm must cost less than cost_limit\n    If retval.cost >= COST_LIMIT, no algorithm was found and all"}, {"sha": "9e07dafda6abfa18109128544472c083fba3a86c", "filename": "gcc/expr.c", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711d877c9e4f9b3250bc50e54c672b40840d574a/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711d877c9e4f9b3250bc50e54c672b40840d574a/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=711d877c9e4f9b3250bc50e54c672b40840d574a", "patch": "@@ -1,5 +1,5 @@\n /* Convert tree expression to rtl instructions, for GNU compiler.\n-   Copyright (C) 1988, 92-98, 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1988, 92-99, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -129,39 +129,39 @@ struct clear_by_pieces\n \n extern struct obstack permanent_obstack;\n \n-static rtx get_push_address\tPROTO ((int));\n-\n-static rtx enqueue_insn\t\tPROTO((rtx, rtx));\n-static int move_by_pieces_ninsns PROTO((unsigned int, int));\n-static void move_by_pieces_1\tPROTO((rtx (*) (rtx, ...), enum machine_mode,\n-\t\t\t\t       struct move_by_pieces *));\n-static void clear_by_pieces\tPROTO((rtx, int, int));\n-static void clear_by_pieces_1\tPROTO((rtx (*) (rtx, ...),\n-\t\t\t\t       enum machine_mode,\n-\t\t\t\t       struct clear_by_pieces *));\n-static int is_zeros_p\t\tPROTO((tree));\n-static int mostly_zeros_p\tPROTO((tree));\n-static void store_constructor_field PROTO((rtx, int, int, enum machine_mode,\n-\t\t\t\t\t   tree, tree, int, int));\n-static void store_constructor\tPROTO((tree, rtx, int, int, int));\n-static rtx store_field\t\tPROTO((rtx, int, int, enum machine_mode, tree,\n-\t\t\t\t       enum machine_mode, int, int,\n-\t\t\t\t       int, int));\n+static rtx get_push_address\tPARAMS ((int));\n+\n+static rtx enqueue_insn\t\tPARAMS ((rtx, rtx));\n+static int move_by_pieces_ninsns PARAMS ((unsigned int, int));\n+static void move_by_pieces_1\tPARAMS ((rtx (*) (rtx, ...), enum machine_mode,\n+\t\t\t\t\t struct move_by_pieces *));\n+static void clear_by_pieces\tPARAMS ((rtx, int, int));\n+static void clear_by_pieces_1\tPARAMS ((rtx (*) (rtx, ...),\n+\t\t\t\t\t enum machine_mode,\n+\t\t\t\t\t struct clear_by_pieces *));\n+static int is_zeros_p\t\tPARAMS ((tree));\n+static int mostly_zeros_p\tPARAMS ((tree));\n+static void store_constructor_field PARAMS ((rtx, int, int, enum machine_mode,\n+\t\t\t\t\t     tree, tree, int, int));\n+static void store_constructor\tPARAMS ((tree, rtx, int, int, int));\n+static rtx store_field\t\tPARAMS ((rtx, int, int, enum machine_mode,\n+\t\t\t\t\t tree, enum machine_mode, int, int,\n+\t\t\t\t\t int, int));\n static enum memory_use_mode\n-  get_memory_usage_from_modifier PROTO((enum expand_modifier));\n-static tree save_noncopied_parts PROTO((tree, tree));\n-static tree init_noncopied_parts PROTO((tree, tree));\n-static int safe_from_p\t\tPROTO((rtx, tree, int));\n-static int fixed_type_p\t\tPROTO((tree));\n-static rtx var_rtx\t\tPROTO((tree));\n-static int readonly_fields_p\tPROTO((tree));\n-static rtx expand_expr_unaligned PROTO((tree, int *));\n-static rtx expand_increment\tPROTO((tree, int, int));\n-static void preexpand_calls\tPROTO((tree));\n-static void do_jump_by_parts_greater PROTO((tree, int, rtx, rtx));\n-static void do_jump_by_parts_equality PROTO((tree, rtx, rtx));\n-static void do_compare_and_jump\tPROTO((tree, enum rtx_code, enum rtx_code, rtx, rtx));\n-static rtx do_store_flag\tPROTO((tree, rtx, enum machine_mode, int));\n+  get_memory_usage_from_modifier PARAMS ((enum expand_modifier));\n+static tree save_noncopied_parts PARAMS ((tree, tree));\n+static tree init_noncopied_parts PARAMS ((tree, tree));\n+static int safe_from_p\t\tPARAMS ((rtx, tree, int));\n+static int fixed_type_p\t\tPARAMS ((tree));\n+static rtx var_rtx\t\tPARAMS ((tree));\n+static int readonly_fields_p\tPARAMS ((tree));\n+static rtx expand_expr_unaligned PARAMS ((tree, int *));\n+static rtx expand_increment\tPARAMS ((tree, int, int));\n+static void preexpand_calls\tPARAMS ((tree));\n+static void do_jump_by_parts_greater PARAMS ((tree, int, rtx, rtx));\n+static void do_jump_by_parts_equality PARAMS ((tree, rtx, rtx));\n+static void do_compare_and_jump\tPARAMS ((tree, enum rtx_code, enum rtx_code, rtx, rtx));\n+static rtx do_store_flag\tPARAMS ((tree, rtx, enum machine_mode, int));\n \n /* Record for each mode whether we can move a register directly to or\n    from an object of that mode in memory.  If we can't, we won't try\n@@ -1512,7 +1512,7 @@ move_by_pieces_ninsns (l, align)\n \n static void\n move_by_pieces_1 (genfun, mode, data)\n-     rtx (*genfun) PROTO ((rtx, ...));\n+     rtx (*genfun) PARAMS ((rtx, ...));\n      enum machine_mode mode;\n      struct move_by_pieces *data;\n {\n@@ -2320,7 +2320,7 @@ clear_by_pieces (to, len, align)\n \n static void\n clear_by_pieces_1 (genfun, mode, data)\n-     rtx (*genfun) PROTO ((rtx, ...));\n+     rtx (*genfun) PARAMS ((rtx, ...));\n      enum machine_mode mode;\n      struct clear_by_pieces *data;\n {"}, {"sha": "9442f0fabd85ea820f709e877e3394dfd5ae029b", "filename": "gcc/expr.h", "status": "modified", "additions": 162, "deletions": 161, "changes": 323, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711d877c9e4f9b3250bc50e54c672b40840d574a/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711d877c9e4f9b3250bc50e54c672b40840d574a/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=711d877c9e4f9b3250bc50e54c672b40840d574a", "patch": "@@ -1,5 +1,5 @@\n /* Definitions for code generation pass of GNU compiler.\n-   Copyright (C) 1987, 91-98, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 91-99, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -713,7 +713,7 @@ extern rtx libfunc_table[LTI_MAX];\n #define profile_function_entry_libfunc\t(libfunc_table[LTI_profile_function_entry])\n #define profile_function_exit_libfunc\t(libfunc_table[LTI_profile_function_exit])\n \f\n-typedef rtx (*rtxfun) PROTO ((rtx));\n+typedef rtx (*rtxfun) PARAMS ((rtx));\n \n /* Indexed by the rtx-code for a conditional (eg. EQ, LT,...)\n    gives the gen_function to make a branch to test that condition.  */\n@@ -742,50 +742,50 @@ extern enum insn_code clrstr_optab[NUM_MACHINE_MODES];\n /* Define functions given in optabs.c.  */\n \n /* Expand a binary operation given optab and rtx operands.  */\n-extern rtx expand_binop PROTO((enum machine_mode, optab, rtx, rtx, rtx,\n-\t\t\t       int, enum optab_methods));\n+extern rtx expand_binop PARAMS ((enum machine_mode, optab, rtx, rtx, rtx,\n+\t\t\t\t int, enum optab_methods));\n \n /* Expand a binary operation with both signed and unsigned forms.  */\n-extern rtx sign_expand_binop PROTO((enum machine_mode, optab, optab, rtx,\n-\t\t\t\t    rtx, rtx, int, enum optab_methods));\n+extern rtx sign_expand_binop PARAMS ((enum machine_mode, optab, optab, rtx,\n+\t\t\t\t      rtx, rtx, int, enum optab_methods));\n \n /* Generate code to perform an operation on two operands with two results.  */\n-extern int expand_twoval_binop PROTO((optab, rtx, rtx, rtx, rtx, int));\n+extern int expand_twoval_binop PARAMS ((optab, rtx, rtx, rtx, rtx, int));\n \n /* Expand a unary arithmetic operation given optab rtx operand.  */\n-extern rtx expand_unop PROTO((enum machine_mode, optab, rtx, rtx, int));\n+extern rtx expand_unop PARAMS ((enum machine_mode, optab, rtx, rtx, int));\n \n /* Expand the absolute value operation.  */\n-extern rtx expand_abs PROTO((enum machine_mode, rtx, rtx, int));\n+extern rtx expand_abs PARAMS ((enum machine_mode, rtx, rtx, int));\n \n /* Expand the complex absolute value operation.  */\n-extern rtx expand_complex_abs PROTO((enum machine_mode, rtx, rtx, int));\n+extern rtx expand_complex_abs PARAMS ((enum machine_mode, rtx, rtx, int));\n \n /* Generate an instruction with a given INSN_CODE with an output and\n    an input.  */\n-extern void emit_unop_insn PROTO((int, rtx, rtx, enum rtx_code));\n+extern void emit_unop_insn PARAMS ((int, rtx, rtx, enum rtx_code));\n \n /* Emit code to perform a series of operations on a multi-word quantity, one\n    word at a time.  */\n-extern rtx emit_no_conflict_block PROTO((rtx, rtx, rtx, rtx, rtx));\n+extern rtx emit_no_conflict_block PARAMS ((rtx, rtx, rtx, rtx, rtx));\n \n /* Emit code to make a call to a constant function or a library call. */\n-extern void emit_libcall_block PROTO((rtx, rtx, rtx, rtx));\n+extern void emit_libcall_block PARAMS ((rtx, rtx, rtx, rtx));\n \n /* Emit one rtl instruction to store zero in specified rtx.  */\n-extern void emit_clr_insn PROTO((rtx));\n+extern void emit_clr_insn PARAMS ((rtx));\n \n /* Emit one rtl insn to store 1 in specified rtx assuming it contains 0.  */\n-extern void emit_0_to_1_insn PROTO((rtx));\n+extern void emit_0_to_1_insn PARAMS ((rtx));\n \n /* Emit one rtl insn to compare two rtx's.  */\n-extern void emit_cmp_insn PROTO((rtx, rtx, enum rtx_code, rtx,\n-\t\t\t\t enum machine_mode, int, int));\n+extern void emit_cmp_insn PARAMS ((rtx, rtx, enum rtx_code, rtx,\n+\t\t\t\t   enum machine_mode, int, int));\n \n /* Emit a pair of rtl insns to compare two rtx's and to jump \n    to a label if the comparison is true.  */\n-extern void emit_cmp_and_jump_insns PROTO((rtx, rtx, enum rtx_code, rtx,\n-\t\t\t\t\t   enum machine_mode, int, int, rtx));\n+extern void emit_cmp_and_jump_insns PARAMS ((rtx, rtx, enum rtx_code, rtx,\n+\t\t\t\t\t     enum machine_mode, int, int, rtx));\n \n /* The various uses that a comparison can have; used by can_compare_p:\n    jumps, conditional moves, store flag operations.  */\n@@ -797,418 +797,419 @@ enum can_compare_purpose\n };\n /* Nonzero if a compare of mode MODE can be done straightforwardly\n    (without splitting it into pieces).  */\n-extern int can_compare_p PROTO((enum machine_mode, enum can_compare_purpose));\n+extern int can_compare_p PARAMS ((enum machine_mode, enum can_compare_purpose));\n \n-extern void prepare_cmp_insn PROTO((rtx *, rtx *, enum rtx_code *, rtx,\n-\t\t\t\t    enum machine_mode *, int *, int,\n-\t\t\t\t    enum can_compare_purpose));\n+extern void prepare_cmp_insn PARAMS ((rtx *, rtx *, enum rtx_code *, rtx,\n+\t\t\t\t      enum machine_mode *, int *, int,\n+\t\t\t\t      enum can_compare_purpose));\n \n-extern rtx prepare_operand PROTO((int, rtx, int, enum machine_mode,\n-\t\t\t\t  enum machine_mode, int));\n+extern rtx prepare_operand PARAMS ((int, rtx, int, enum machine_mode,\n+\t\t\t\t    enum machine_mode, int));\n \n /* Generate code to indirectly jump to a location given in the rtx LOC.  */\n-extern void emit_indirect_jump PROTO((rtx));\n+extern void emit_indirect_jump PARAMS ((rtx));\n \n #ifdef HAVE_conditional_move\n /* Emit a conditional move operation.  */\n-rtx emit_conditional_move PROTO((rtx, enum rtx_code, rtx, rtx,\n-\t\t\t\t enum machine_mode, rtx, rtx,\n-\t\t\t\t enum machine_mode, int));\n+rtx emit_conditional_move PARAMS ((rtx, enum rtx_code, rtx, rtx,\n+\t\t\t\t   enum machine_mode, rtx, rtx,\n+\t\t\t\t   enum machine_mode, int));\n \n /* Return non-zero if the conditional move is supported.  */\n-int can_conditionally_move_p PROTO((enum machine_mode mode));\n+int can_conditionally_move_p PARAMS ((enum machine_mode mode));\n \n #endif\n \n /* Create but don't emit one rtl instruction to add one rtx into another.\n    Modes must match; operands must meet the operation's predicates.\n    Likewise for subtraction and for just copying.\n    These do not call protect_from_queue; caller must do so.  */\n-extern rtx gen_add2_insn PROTO((rtx, rtx));\n-extern rtx gen_sub2_insn PROTO((rtx, rtx));\n-extern rtx gen_move_insn PROTO((rtx, rtx));\n-extern int have_add2_insn PROTO((enum machine_mode));\n-extern int have_sub2_insn PROTO((enum machine_mode));\n+extern rtx gen_add2_insn PARAMS ((rtx, rtx));\n+extern rtx gen_sub2_insn PARAMS ((rtx, rtx));\n+extern rtx gen_move_insn PARAMS ((rtx, rtx));\n+extern int have_add2_insn PARAMS ((enum machine_mode));\n+extern int have_sub2_insn PARAMS ((enum machine_mode));\n \n /* Return the INSN_CODE to use for an extend operation.  */\n-extern enum insn_code can_extend_p PROTO((enum machine_mode,\n-\t\t\t\t\t  enum machine_mode, int));\n+extern enum insn_code can_extend_p PARAMS ((enum machine_mode,\n+\t\t\t\t\t    enum machine_mode, int));\n \n /* Generate the body of an insn to extend Y (with mode MFROM)\n    into X (with mode MTO).  Do zero-extension if UNSIGNEDP is nonzero.  */\n-extern rtx gen_extend_insn PROTO((rtx, rtx, enum machine_mode,\n-\t\t\t\t  enum machine_mode, int));\n+extern rtx gen_extend_insn PARAMS ((rtx, rtx, enum machine_mode,\n+\t\t\t\t    enum machine_mode, int));\n \n /* Initialize the tables that control conversion between fixed and\n    floating values.  */\n-extern void init_fixtab PROTO((void));\n-extern void init_floattab PROTO((void));\n+extern void init_fixtab PARAMS ((void));\n+extern void init_floattab PARAMS ((void));\n \n /* Generate code for a FLOAT_EXPR.  */\n-extern void expand_float PROTO((rtx, rtx, int));\n+extern void expand_float PARAMS ((rtx, rtx, int));\n \n /* Generate code for a FIX_EXPR.  */\n-extern void expand_fix PROTO((rtx, rtx, int));\n+extern void expand_fix PARAMS ((rtx, rtx, int));\n \n /* Call this to initialize an optab function entry.  */\n-extern rtx init_one_libfunc PROTO ((const char *));\n+extern rtx init_one_libfunc PARAMS ((const char *));\n \n /* Call this once to initialize the contents of the optabs\n    appropriately for the current target machine.  */\n-extern void init_optabs\tPROTO((void));\n+extern void init_optabs\tPARAMS ((void));\n \f\n /* Functions from expmed.c:  */\n \n /* Arguments MODE, RTX: return an rtx for the negation of that value.\n    May emit insns.  */\n-extern rtx negate_rtx PROTO((enum machine_mode, rtx));\n+extern rtx negate_rtx PARAMS ((enum machine_mode, rtx));\n \n /* Expand a logical AND operation.  */\n-extern rtx expand_and PROTO((rtx, rtx, rtx));\n+extern rtx expand_and PARAMS ((rtx, rtx, rtx));\n \n /* Emit a store-flag operation.  */\n-extern rtx emit_store_flag PROTO((rtx, enum rtx_code, rtx, rtx,\n-\t\t\t\t  enum machine_mode, int, int));\n+extern rtx emit_store_flag PARAMS ((rtx, enum rtx_code, rtx, rtx,\n+\t\t\t\t    enum machine_mode, int, int));\n \n /* Like emit_store_flag, but always succeeds.  */\n-extern rtx emit_store_flag_force PROTO((rtx, enum rtx_code, rtx, rtx,\n-\t\t\t\t\tenum machine_mode, int, int));\n+extern rtx emit_store_flag_force PARAMS ((rtx, enum rtx_code, rtx, rtx,\n+\t\t\t\t\t  enum machine_mode, int, int));\n \n /* Functions from loop.c:  */\n \n /* Given a JUMP_INSN, return a description of the test being made.  */\n-extern rtx get_condition PROTO((rtx, rtx *));\n+extern rtx get_condition PARAMS ((rtx, rtx *));\n \n /* Generate a conditional trap instruction.  */\n-extern rtx gen_cond_trap PROTO((enum rtx_code, rtx, rtx, rtx));\n+extern rtx gen_cond_trap PARAMS ((enum rtx_code, rtx, rtx, rtx));\n \f\n /* Functions from builtins.c:  */\n #ifdef TREE_CODE\n-extern rtx expand_builtin PROTO((tree, rtx, rtx, enum machine_mode, int));\n-extern void std_expand_builtin_va_start PROTO((int, tree, rtx));\n-extern rtx std_expand_builtin_va_arg PROTO((tree, tree));\n-extern rtx expand_builtin_va_arg PROTO((tree, tree));\n+extern rtx expand_builtin PARAMS ((tree, rtx, rtx, enum machine_mode, int));\n+extern void std_expand_builtin_va_start PARAMS ((int, tree, rtx));\n+extern rtx std_expand_builtin_va_arg PARAMS ((tree, tree));\n+extern rtx expand_builtin_va_arg PARAMS ((tree, tree));\n #endif\n \n-extern rtx expand_builtin_setjmp PROTO((rtx, rtx, rtx, rtx));\n-extern void expand_builtin_longjmp PROTO ((rtx, rtx));\n-extern rtx expand_builtin_saveregs PROTO((void));\n-extern int get_varargs_alias_set PROTO((void));\n+extern rtx expand_builtin_setjmp PARAMS ((rtx, rtx, rtx, rtx));\n+extern void expand_builtin_longjmp PARAMS ((rtx, rtx));\n+extern rtx expand_builtin_saveregs PARAMS ((void));\n+extern int get_varargs_alias_set PARAMS ((void));\n \f\n /* Functions from expr.c:  */\n \n /* This is run once per compilation to set up which modes can be used\n    directly in memory and to initialize the block move optab.  */\n-extern void init_expr_once PROTO((void));\n+extern void init_expr_once PARAMS ((void));\n \n /* This is run at the start of compiling a function.  */\n-extern void init_expr PROTO((void));\n+extern void init_expr PARAMS ((void));\n \n /* This function is run once to initialize stor-layout.c.  */\n \n-extern void init_stor_layout_once PROTO((void));\n+extern void init_stor_layout_once PARAMS ((void));\n \n /* This is run at the end of compiling a function.  */\n-extern void finish_expr_for_function PROTO((void));\n+extern void finish_expr_for_function PARAMS ((void));\n \n /* Use protect_from_queue to convert a QUEUED expression\n    into something that you can put immediately into an instruction.  */\n-extern rtx protect_from_queue PROTO((rtx, int));\n+extern rtx protect_from_queue PARAMS ((rtx, int));\n \n /* Perform all the pending incrementations.  */\n-extern void emit_queue PROTO((void));\n+extern void emit_queue PARAMS ((void));\n \n /* Tell if something has a queued subexpression.  */\n-extern int queued_subexp_p PROTO((rtx));\n+extern int queued_subexp_p PARAMS ((rtx));\n \n /* Emit some rtl insns to move data between rtx's, converting machine modes.\n    Both modes must be floating or both fixed.  */\n-extern void convert_move PROTO((rtx, rtx, int));\n+extern void convert_move PARAMS ((rtx, rtx, int));\n \n /* Convert an rtx to specified machine mode and return the result.  */\n-extern rtx convert_to_mode PROTO((enum machine_mode, rtx, int));\n+extern rtx convert_to_mode PARAMS ((enum machine_mode, rtx, int));\n \n /* Convert an rtx to MODE from OLDMODE and return the result.  */\n-extern rtx convert_modes PROTO((enum machine_mode, enum machine_mode, rtx, int));\n+extern rtx convert_modes PARAMS ((enum machine_mode, enum machine_mode, rtx, int));\n \n /* Emit code to move a block Y to a block X.  */\n-extern rtx emit_block_move PROTO((rtx, rtx, rtx, int));\n+extern rtx emit_block_move PARAMS ((rtx, rtx, rtx, int));\n \n /* Copy all or part of a value X into registers starting at REGNO.\n    The number of registers to be filled is NREGS.  */\n-extern void move_block_to_reg PROTO((int, rtx, int, enum machine_mode));\n+extern void move_block_to_reg PARAMS ((int, rtx, int, enum machine_mode));\n \n /* Copy all or part of a BLKmode value X out of registers starting at REGNO.\n    The number of registers to be filled is NREGS.  */\n-extern void move_block_from_reg PROTO((int, rtx, int, int));\n+extern void move_block_from_reg PARAMS ((int, rtx, int, int));\n \n /* Load a BLKmode value into non-consecutive registers represented by a\n    PARALLEL.  */\n-extern void emit_group_load PROTO((rtx, rtx, int, int));\n+extern void emit_group_load PARAMS ((rtx, rtx, int, int));\n /* Store a BLKmode value from non-consecutive registers represented by a\n    PARALLEL.  */\n-extern void emit_group_store PROTO((rtx, rtx, int, int));\n+extern void emit_group_store PARAMS ((rtx, rtx, int, int));\n \n #ifdef TREE_CODE\n /* Copy BLKmode object from a set of registers. */\n-extern rtx copy_blkmode_from_reg PROTO((rtx,rtx,tree));\n+extern rtx copy_blkmode_from_reg PARAMS ((rtx,rtx,tree));\n #endif\n \n /* Mark REG as holding a parameter for the next CALL_INSN.  */\n-extern void use_reg PROTO((rtx *, rtx));\n+extern void use_reg PARAMS ((rtx *, rtx));\n /* Mark NREGS consecutive regs, starting at REGNO, as holding parameters\n    for the next CALL_INSN.  */\n-extern void use_regs PROTO((rtx *, int, int));\n+extern void use_regs PARAMS ((rtx *, int, int));\n /* Mark a PARALLEL as holding a parameter for the next CALL_INSN.  */\n-extern void use_group_regs PROTO((rtx *, rtx));\n+extern void use_group_regs PARAMS ((rtx *, rtx));\n \n /* Write zeros through the storage of OBJECT.\n    If OBJECT has BLKmode, SIZE is its length in bytes and ALIGN is its\n    alignment.  */\n-extern rtx clear_storage PROTO((rtx, rtx, int));\n+extern rtx clear_storage PARAMS ((rtx, rtx, int));\n \n /* Emit insns to set X from Y.  */\n-extern rtx emit_move_insn PROTO((rtx, rtx));\n+extern rtx emit_move_insn PARAMS ((rtx, rtx));\n \n /* Emit insns to set X from Y, with no frills.  */\n-extern rtx emit_move_insn_1 PROTO((rtx, rtx));\n+extern rtx emit_move_insn_1 PARAMS ((rtx, rtx));\n \n /* Push a block of length SIZE (perhaps variable)\n    and return an rtx to address the beginning of the block.  */\n-extern rtx push_block PROTO((rtx, int, int));\n+extern rtx push_block PARAMS ((rtx, int, int));\n \n /* Make an operand to push something on the stack.  */\n-extern rtx gen_push_operand PROTO((void));\n+extern rtx gen_push_operand PARAMS ((void));\n \n #ifdef TREE_CODE\n /* Generate code to push something onto the stack, given its mode and type.  */\n-extern void emit_push_insn PROTO((rtx, enum machine_mode, tree, rtx, int,\n-\t\t\t\t  int, rtx, int, rtx, rtx, int, rtx));\n+extern void emit_push_insn PARAMS ((rtx, enum machine_mode, tree, rtx, int,\n+\t\t\t\t    int, rtx, int, rtx, rtx, int, rtx));\n \n /* Emit library call.  */\n-extern void emit_library_call PVPROTO((rtx orgfun, int no_queue,\n+extern void emit_library_call PARAMS ((rtx orgfun, int no_queue,\n   enum machine_mode outmode, int nargs, ...));\n-extern rtx emit_library_call_value PVPROTO((rtx orgfun, rtx value, int no_queue,\n+extern rtx emit_library_call_value PARAMS ((rtx orgfun, rtx value, int no_queue,\n   enum machine_mode outmode, int nargs, ...));\n \n /* Expand an assignment that stores the value of FROM into TO. */\n-extern rtx expand_assignment PROTO((tree, tree, int, int));\n+extern rtx expand_assignment PARAMS ((tree, tree, int, int));\n \n /* Generate code for computing expression EXP,\n    and storing the value into TARGET.\n    If SUGGEST_REG is nonzero, copy the value through a register\n    and return that register, if that is possible.  */\n-extern rtx store_expr PROTO((tree, rtx, int));\n+extern rtx store_expr PARAMS ((tree, rtx, int));\n #endif\n \n /* Given an rtx that may include add and multiply operations,\n    generate them as insns and return a pseudo-reg containing the value.\n    Useful after calling expand_expr with 1 as sum_ok.  */\n-extern rtx force_operand PROTO((rtx, rtx));\n+extern rtx force_operand PARAMS ((rtx, rtx));\n \n #ifdef TREE_CODE\n /* Generate code for computing expression EXP.\n    An rtx for the computed value is returned.  The value is never null.\n    In the case of a void EXP, const0_rtx is returned.  */\n-extern rtx expand_expr PROTO((tree, rtx, enum machine_mode,\n-\t\t\t      enum expand_modifier));\n+extern rtx expand_expr PARAMS ((tree, rtx, enum machine_mode,\n+\t\t\t\tenum expand_modifier));\n #endif\n \n /* At the start of a function, record that we have no previously-pushed\n    arguments waiting to be popped.  */\n-extern void init_pending_stack_adjust PROTO((void));\n+extern void init_pending_stack_adjust PARAMS ((void));\n \n /* When exiting from function, if safe, clear out any pending stack adjust\n    so the adjustment won't get done.  */\n-extern void clear_pending_stack_adjust PROTO((void));\n+extern void clear_pending_stack_adjust PARAMS ((void));\n \n /* Pop any previously-pushed arguments that have not been popped yet.  */\n-extern void do_pending_stack_adjust PROTO((void));\n+extern void do_pending_stack_adjust PARAMS ((void));\n \n #ifdef TREE_CODE\n /* Return the tree node and offset if a given argument corresponds to\n    a string constant.  */\n-extern tree string_constant PROTO((tree, tree *));\n+extern tree string_constant PARAMS ((tree, tree *));\n \n /* Generate code to evaluate EXP and jump to LABEL if the value is zero.  */\n-extern void jumpifnot PROTO((tree, rtx));\n+extern void jumpifnot PARAMS ((tree, rtx));\n \n /* Generate code to evaluate EXP and jump to LABEL if the value is nonzero.  */\n-extern void jumpif PROTO((tree, rtx));\n+extern void jumpif PARAMS ((tree, rtx));\n \n /* Generate code to evaluate EXP and jump to IF_FALSE_LABEL if\n    the result is zero, or IF_TRUE_LABEL if the result is one.  */\n-extern void do_jump PROTO((tree, rtx, rtx));\n+extern void do_jump PARAMS ((tree, rtx, rtx));\n #endif\n \n /* Generate rtl to compare two rtx's, will call emit_cmp_insn.  */\n-extern rtx compare_from_rtx PROTO((rtx, rtx, enum rtx_code, int,\n-\t\t\t\t   enum machine_mode, rtx, int));\n-extern void do_compare_rtx_and_jump PROTO((rtx, rtx, enum rtx_code, int,\n-\t\t\t\t\t   enum machine_mode, rtx, int,\n-\t\t\t\t\t   rtx, rtx));\n+extern rtx compare_from_rtx PARAMS ((rtx, rtx, enum rtx_code, int,\n+\t\t\t\t     enum machine_mode, rtx, int));\n+extern void do_compare_rtx_and_jump PARAMS ((rtx, rtx, enum rtx_code, int,\n+\t\t\t\t\t     enum machine_mode, rtx, int,\n+\t\t\t\t\t     rtx, rtx));\n \n /* Generate a tablejump instruction (used for switch statements).  */\n-extern void do_tablejump PROTO((rtx, enum machine_mode, rtx, rtx, rtx));\n+extern void do_tablejump PARAMS ((rtx, enum machine_mode, rtx, rtx, rtx));\n \f\n #ifdef TREE_CODE\n /* rtl.h and tree.h were included.  */\n /* Return an rtx for the size in bytes of the value of an expr.  */\n-extern rtx expr_size PROTO((tree));\n+extern rtx expr_size PARAMS ((tree));\n \n-extern rtx lookup_static_chain PROTO((tree));\n+extern rtx lookup_static_chain PARAMS ((tree));\n \n /* Convert a stack slot address ADDR valid in function FNDECL\n    into an address valid in this function (using a static chain).  */\n-extern rtx fix_lexical_addr PROTO((rtx, tree));\n+extern rtx fix_lexical_addr PARAMS ((rtx, tree));\n \n /* Return the address of the trampoline for entering nested fn FUNCTION.  */\n-extern rtx trampoline_address PROTO((tree));\n+extern rtx trampoline_address PARAMS ((tree));\n \n /* Return an rtx that refers to the value returned by a function\n    in its original home.  This becomes invalid if any more code is emitted.  */\n-extern rtx hard_function_value PROTO((tree, tree, int));\n+extern rtx hard_function_value PARAMS ((tree, tree, int));\n \n-extern rtx prepare_call_address\tPROTO((rtx, tree, rtx *, int));\n+extern rtx prepare_call_address\tPARAMS ((rtx, tree, rtx *, int));\n \n-extern rtx expand_call PROTO((tree, rtx, int));\n+extern rtx expand_call PARAMS ((tree, rtx, int));\n \n-extern rtx expand_shift PROTO((enum tree_code, enum machine_mode, rtx, tree, rtx, int));\n-extern rtx expand_divmod PROTO((int, enum tree_code, enum machine_mode, rtx, rtx, rtx, int));\n-extern void locate_and_pad_parm PROTO((enum machine_mode, tree, int, tree, struct args_size *, struct args_size *, struct args_size *, struct args_size *));\n-extern rtx expand_inline_function PROTO((tree, tree, rtx, int, tree, rtx));\n+extern rtx expand_shift PARAMS ((enum tree_code, enum machine_mode, rtx, tree, rtx, int));\n+extern rtx expand_divmod PARAMS ((int, enum tree_code, enum machine_mode, rtx, rtx, rtx, int));\n+extern void locate_and_pad_parm PARAMS ((enum machine_mode, tree, int, tree, struct args_size *, struct args_size *, struct args_size *, struct args_size *));\n+extern rtx expand_inline_function PARAMS ((tree, tree, rtx, int, tree, rtx));\n /* Return the CODE_LABEL rtx for a LABEL_DECL, creating it if necessary.  */\n-extern rtx label_rtx PROTO((tree));\n+extern rtx label_rtx PARAMS ((tree));\n #endif\n \n /* Indicate how an input argument register was promoted.  */\n-extern rtx promoted_input_arg PROTO((int, enum machine_mode *, int *));\n+extern rtx promoted_input_arg PARAMS ((int, enum machine_mode *, int *));\n \n /* Return an rtx like arg but sans any constant terms.\n    Returns the original rtx if it has no constant terms.\n    The constant terms are added and stored via a second arg.  */\n-extern rtx eliminate_constant_term PROTO((rtx, rtx *));\n+extern rtx eliminate_constant_term PARAMS ((rtx, rtx *));\n \n /* Convert arg to a valid memory address for specified machine mode,\n    by emitting insns to perform arithmetic if nec.  */\n-extern rtx memory_address PROTO((enum machine_mode, rtx));\n+extern rtx memory_address PARAMS ((enum machine_mode, rtx));\n \n /* Like `memory_address' but pretent `flag_force_addr' is 0.  */\n-extern rtx memory_address_noforce PROTO((enum machine_mode, rtx));\n+extern rtx memory_address_noforce PARAMS ((enum machine_mode, rtx));\n \n /* Return a memory reference like MEMREF, but with its mode changed\n    to MODE and its address changed to ADDR.\n    (VOIDmode means don't change the mode.\n    NULL for ADDR means don't change the address.)  */\n-extern rtx change_address PROTO((rtx, enum machine_mode, rtx));\n+extern rtx change_address PARAMS ((rtx, enum machine_mode, rtx));\n \n /* Return a memory reference like MEMREF, but which is known to have a\n    valid address.  */\n \n-extern rtx validize_mem PROTO((rtx));\n+extern rtx validize_mem PARAMS ((rtx));\n \n /* Assemble the static constant template for function entry trampolines.  */\n-extern rtx assemble_trampoline_template PROTO((void));\n+extern rtx assemble_trampoline_template PARAMS ((void));\n \n /* Return 1 if two rtx's are equivalent in structure and elements.  */\n-extern int rtx_equal_p PROTO((rtx, rtx));\n+extern int rtx_equal_p PARAMS ((rtx, rtx));\n \n /* Given rtx, return new rtx whose address won't be affected by\n    any side effects.  It has been copied to a new temporary reg.  */\n-extern rtx stabilize PROTO((rtx));\n+extern rtx stabilize PARAMS ((rtx));\n \n /* Given an rtx, copy all regs it refers to into new temps\n    and return a modified copy that refers to the new temps.  */\n-extern rtx copy_all_regs PROTO((rtx));\n+extern rtx copy_all_regs PARAMS ((rtx));\n \n /* Copy given rtx to a new temp reg and return that.  */\n-extern rtx copy_to_reg PROTO((rtx));\n+extern rtx copy_to_reg PARAMS ((rtx));\n \n /* Like copy_to_reg but always make the reg Pmode.  */\n-extern rtx copy_addr_to_reg PROTO((rtx));\n+extern rtx copy_addr_to_reg PARAMS ((rtx));\n \n /* Like copy_to_reg but always make the reg the specified mode MODE.  */\n-extern rtx copy_to_mode_reg PROTO((enum machine_mode, rtx));\n+extern rtx copy_to_mode_reg PARAMS ((enum machine_mode, rtx));\n \n /* Copy given rtx to given temp reg and return that.  */\n-extern rtx copy_to_suggested_reg PROTO((rtx, rtx, enum machine_mode));\n+extern rtx copy_to_suggested_reg PARAMS ((rtx, rtx, enum machine_mode));\n \n /* Copy a value to a register if it isn't already a register.\n    Args are mode (in case value is a constant) and the value.  */\n-extern rtx force_reg PROTO((enum machine_mode, rtx));\n+extern rtx force_reg PARAMS ((enum machine_mode, rtx));\n \n /* Return given rtx, copied into a new temp reg if it was in memory.  */\n-extern rtx force_not_mem PROTO((rtx));\n+extern rtx force_not_mem PARAMS ((rtx));\n \n #ifdef TREE_CODE\n /* Return mode and signedness to use when object is promoted.  */\n-extern enum machine_mode promote_mode PROTO((tree, enum machine_mode,\n-\t\t\t\t\t     int *, int));\n+extern enum machine_mode promote_mode PARAMS ((tree, enum machine_mode,\n+\t\t\t\t\t       int *, int));\n #endif\n \n /* Remove some bytes from the stack.  An rtx says how many.  */\n-extern void adjust_stack PROTO((rtx));\n+extern void adjust_stack PARAMS ((rtx));\n \n /* Add some bytes to the stack.  An rtx says how many.  */\n-extern void anti_adjust_stack PROTO((rtx));\n+extern void anti_adjust_stack PARAMS ((rtx));\n \n /* This enum is used for the following two functions.  */\n enum save_level {SAVE_BLOCK, SAVE_FUNCTION, SAVE_NONLOCAL};\n \n /* Save the stack pointer at the specified level.  */\n-extern void emit_stack_save PROTO((enum save_level, rtx *, rtx));\n+extern void emit_stack_save PARAMS ((enum save_level, rtx *, rtx));\n \n /* Restore the stack pointer from a save area of the specified level.  */\n-extern void emit_stack_restore PROTO((enum save_level, rtx, rtx));\n+extern void emit_stack_restore PARAMS ((enum save_level, rtx, rtx));\n \n /* Allocate some space on the stack dynamically and return its address.  An rtx\n    says how many bytes.  */\n-extern rtx allocate_dynamic_stack_space PROTO((rtx, rtx, int));\n+extern rtx allocate_dynamic_stack_space PARAMS ((rtx, rtx, int));\n \n /* Probe a range of stack addresses from FIRST to FIRST+SIZE, inclusive. \n    FIRST is a constant and size is a Pmode RTX.  These are offsets from the\n    current stack pointer.  STACK_GROWS_DOWNWARD says whether to add or\n    subtract from the stack.  If SIZE is constant, this is done\n    with a fixed number of probes.  Otherwise, we must make a loop.  */\n-extern void probe_stack_range PROTO((HOST_WIDE_INT, rtx));\n+extern void probe_stack_range PARAMS ((HOST_WIDE_INT, rtx));\n \n /* Return an rtx that refers to the value returned by a library call\n    in its original home.  This becomes invalid if any more code is emitted.  */\n-extern rtx hard_libcall_value PROTO((enum machine_mode));\n+extern rtx hard_libcall_value PARAMS ((enum machine_mode));\n \n /* Given an rtx, return an rtx for a value rounded up to a multiple\n    of STACK_BOUNDARY / BITS_PER_UNIT.  */\n-extern rtx round_push PROTO((rtx));\n+extern rtx round_push PARAMS ((rtx));\n \n-extern rtx store_bit_field PROTO((rtx, int, int, enum machine_mode, rtx, int, int));\n-extern rtx extract_bit_field PROTO((rtx, int, int, int, rtx, enum machine_mode, enum machine_mode, int, int));\n-extern rtx expand_mult PROTO((enum machine_mode, rtx, rtx, rtx, int));\n-extern rtx expand_mult_add PROTO((rtx, rtx, rtx, rtx,enum machine_mode, int));\n-extern rtx expand_mult_highpart_adjust PROTO((enum machine_mode, rtx, rtx, rtx, rtx, int));\n+extern rtx store_bit_field PARAMS ((rtx, int, int, enum machine_mode, rtx, int, int));\n+extern rtx extract_bit_field PARAMS ((rtx, int, int, int, rtx, enum machine_mode, enum machine_mode, int, int));\n+extern rtx expand_mult PARAMS ((enum machine_mode, rtx, rtx, rtx, int));\n+extern rtx expand_mult_add PARAMS ((rtx, rtx, rtx, rtx,enum machine_mode, int));\n+extern rtx expand_mult_highpart_adjust PARAMS ((enum machine_mode, rtx, rtx, rtx, rtx, int));\n \n-extern rtx assemble_static_space PROTO((int));\n+extern rtx assemble_static_space PARAMS ((int));\n \n /* Hook called by expand_expr for language-specific tree codes.\n    It is up to the language front end to install a hook\n    if it has any such codes that expand_expr needs to know about.  */\n-extern rtx (*lang_expand_expr) PROTO ((union tree_node *, rtx,\n-\t\t\t\t       enum machine_mode,\n-\t\t\t\t       enum expand_modifier modifier));\n+extern rtx (*lang_expand_expr) PARAMS ((union tree_node *, rtx,\n+\t\t\t\t\tenum machine_mode,\n+\t\t\t\t\tenum expand_modifier modifier));\n \n #ifdef TREE_CODE\n /* Hook called by output_constant for language-specific tree codes.\n    It is up to the language front-end to install a hook if it has any\n    such codes that output_constant needs to know about.  Returns a\n    language-independent constant equivalent to its input.  */\n-extern tree (*lang_expand_constant) PROTO((tree));\n+extern tree (*lang_expand_constant) PARAMS ((tree));\n #endif\n \n-extern void init_all_optabs\t\t\tPROTO ((void));\n-extern void do_jump_by_parts_equality_rtx\tPROTO((rtx, rtx, rtx));\n-extern void do_jump_by_parts_greater_rtx\tPROTO ((enum machine_mode, int,\n-\t\t\t\t\t\t\trtx, rtx, rtx, rtx));\n+extern void init_all_optabs\t\t\tPARAMS ((void));\n+extern void do_jump_by_parts_equality_rtx\tPARAMS ((rtx, rtx, rtx));\n+extern void do_jump_by_parts_greater_rtx\tPARAMS ((enum machine_mode,\n+\t\t\t\t\t\t\t int, rtx, rtx, rtx,\n+\t\t\t\t\t\t\t rtx));\n \n #ifdef TREE_CODE   /* Don't lose if tree.h not included.  */\n-extern void mark_seen_cases\t\t\tPROTO ((tree, unsigned char *,\n-\t\t\t\t\t\t\tlong, int));\n+extern void mark_seen_cases\t\t\tPARAMS ((tree, unsigned char *,\n+\t\t\t\t\t\t\t long, int));\n #endif"}, {"sha": "f94a02f4f109d0753c4a2f12ca968ec356e19c67", "filename": "gcc/final.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711d877c9e4f9b3250bc50e54c672b40840d574a/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711d877c9e4f9b3250bc50e54c672b40840d574a/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=711d877c9e4f9b3250bc50e54c672b40840d574a", "patch": "@@ -290,27 +290,27 @@ static struct bb_str **sbb_tail\t= &sbb_head;\t/* Ptr to store next bb str */\n static int sbb_label_num\t= 0;\t\t/* Last label used */\n \n #ifdef HAVE_ATTR_length\n-static int asm_insn_count\tPROTO((rtx));\n-#endif\n-static void profile_function\tPROTO((FILE *));\n-static void profile_after_prologue PROTO((FILE *));\n-static void add_bb\t\tPROTO((FILE *));\n-static int add_bb_string\tPROTO((const char *, int));\n-static void output_source_line\tPROTO((FILE *, rtx));\n-static rtx walk_alter_subreg\tPROTO((rtx));\n-static void output_asm_name\tPROTO((void));\n-static void output_operand\tPROTO((rtx, int));\n+static int asm_insn_count\tPARAMS ((rtx));\n+#endif\n+static void profile_function\tPARAMS ((FILE *));\n+static void profile_after_prologue PARAMS ((FILE *));\n+static void add_bb\t\tPARAMS ((FILE *));\n+static int add_bb_string\tPARAMS ((const char *, int));\n+static void output_source_line\tPARAMS ((FILE *, rtx));\n+static rtx walk_alter_subreg\tPARAMS ((rtx));\n+static void output_asm_name\tPARAMS ((void));\n+static void output_operand\tPARAMS ((rtx, int));\n #ifdef LEAF_REGISTERS\n-static void leaf_renumber_regs\tPROTO((rtx));\n+static void leaf_renumber_regs\tPARAMS ((rtx));\n #endif\n #ifdef HAVE_cc0\n-static int alter_cond\t\tPROTO((rtx));\n+static int alter_cond\t\tPARAMS ((rtx));\n #endif\n #ifndef ADDR_VEC_ALIGN\n-static int final_addr_vec_align PROTO ((rtx));\n+static int final_addr_vec_align PARAMS ((rtx));\n #endif\n #ifdef HAVE_ATTR_length\n-static int align_fuzz\t\tPROTO ((rtx, rtx, int, unsigned));\n+static int align_fuzz\t\tPARAMS ((rtx, rtx, int, unsigned));\n #endif\n \f\n /* Initialize data in final at the beginning of a compilation.  */\n@@ -3726,7 +3726,7 @@ output_addr_const (file, x)\n    We handle alternate assembler dialects here, just like output_asm_insn.  */\n \n void\n-asm_fprintf VPROTO((FILE *file, const char *p, ...))\n+asm_fprintf VPARAMS ((FILE *file, const char *p, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   FILE *file;"}, {"sha": "b01f65605deeebda60271a16d38da3ad9c754f6e", "filename": "gcc/fix-header.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711d877c9e4f9b3250bc50e54c672b40840d574a/gcc%2Ffix-header.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711d877c9e4f9b3250bc50e54c672b40840d574a/gcc%2Ffix-header.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffix-header.c?ref=711d877c9e4f9b3250bc50e54c672b40840d574a", "patch": "@@ -1,5 +1,5 @@\n /* fix-header.c - Make C header file suitable for C++.\n-   Copyright (C) 1993, 94-98, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 94-99, 2000 Free Software Foundation, Inc.\n \n This program is free software; you can redistribute it and/or modify it\n under the terms of the GNU General Public License as published by the\n@@ -77,8 +77,8 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #include \"cpplib.h\"\n #include \"cpphash.h\"\n \n-static void v_fatal PROTO ((const char *, va_list)) ATTRIBUTE_NORETURN;\n-static void fatal PVPROTO ((const char *, ...)) ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n+static void v_fatal PARAMS ((const char *, va_list)) ATTRIBUTE_NORETURN;\n+static void fatal PARAMS ((const char *, ...)) ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n \n sstring buf;\n \n@@ -187,17 +187,17 @@ struct symbol_list {\n struct symbol_list symbol_table[SYMBOL_TABLE_SIZE];\n int cur_symbol_table_size;\n \n-static void add_symbols PROTO ((symbol_flags, namelist));\n-static struct fn_decl *lookup_std_proto PROTO ((const char *, int));\n-static void write_lbrac PROTO ((void));\n-static void recognized_macro PROTO ((const char *));\n-static void check_macro_names PROTO ((cpp_reader *, namelist));\n-static void read_scan_file PROTO ((char *, int, char **));\n-static void write_rbrac PROTO ((void));\n-static int inf_skip_spaces PROTO ((int));\n-static int inf_read_upto PROTO ((sstring *, int));\n-static int inf_scan_ident PROTO ((sstring *, int));\n-static int check_protection PROTO ((int *, int *));\n+static void add_symbols PARAMS ((symbol_flags, namelist));\n+static struct fn_decl *lookup_std_proto PARAMS ((const char *, int));\n+static void write_lbrac PARAMS ((void));\n+static void recognized_macro PARAMS ((const char *));\n+static void check_macro_names PARAMS ((cpp_reader *, namelist));\n+static void read_scan_file PARAMS ((char *, int, char **));\n+static void write_rbrac PARAMS ((void));\n+static int inf_skip_spaces PARAMS ((int));\n+static int inf_read_upto PARAMS ((sstring *, int));\n+static int inf_scan_ident PARAMS ((sstring *, int));\n+static int check_protection PARAMS ((int *, int *));\n \n static void\n add_symbols (flags, names)\n@@ -1062,7 +1062,7 @@ check_protection (ifndef_line, endif_line)\n   return 1;\n }\n \n-extern int main\t\t\tPROTO ((int, char **));\n+extern int main\t\t\tPARAMS ((int, char **));\n \n int\n main (argc, argv)\n@@ -1320,7 +1320,7 @@ v_fatal (str, ap)\n }\n \n static void\n-fatal VPROTO ((const char *str, ...))\n+fatal VPARAMS ((const char *str, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   const char *str;"}, {"sha": "0591b007d9de40a62db397bdff00c6224f91ca0e", "filename": "gcc/flow.c", "status": "modified", "additions": 80, "deletions": 80, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711d877c9e4f9b3250bc50e54c672b40840d574a/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711d877c9e4f9b3250bc50e54c672b40840d574a/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=711d877c9e4f9b3250bc50e54c672b40840d574a", "patch": "@@ -1,5 +1,5 @@\n /* Data flow analysis for GNU compiler.\n-   Copyright (C) 1987, 88, 92-98, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 92-99, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -280,92 +280,92 @@ static rtx label_value_list;\n static bitmap uid_volatile;\n \n /* Forward declarations */\n-static int count_basic_blocks\t\tPROTO((rtx));\n-static rtx find_basic_blocks_1\t\tPROTO((rtx));\n-static void create_basic_block\t\tPROTO((int, rtx, rtx, rtx));\n-static void clear_edges\t\t\tPROTO((void));\n-static void make_edges\t\t\tPROTO((rtx));\n-static void make_edge\t\t\tPROTO((sbitmap *, basic_block,\n-\t\t\t\t\t       basic_block, int));\n-static void make_label_edge\t\tPROTO((sbitmap *, basic_block,\n-\t\t\t\t\t       rtx, int));\n-static void make_eh_edge\t\tPROTO((sbitmap *, eh_nesting_info *,\n-\t\t\t\t\t       basic_block, rtx, int));\n-static void mark_critical_edges\t\tPROTO((void));\n-static void move_stray_eh_region_notes\tPROTO((void));\n-static void record_active_eh_regions\tPROTO((rtx));\n-\n-static void commit_one_edge_insertion\tPROTO((edge));\n-\n-static void delete_unreachable_blocks\tPROTO((void));\n-static void delete_eh_regions\t\tPROTO((void));\n-static int can_delete_note_p\t\tPROTO((rtx));\n-static int delete_block\t\t\tPROTO((basic_block));\n-static void expunge_block\t\tPROTO((basic_block));\n-static rtx flow_delete_insn\t\tPROTO((rtx));\n-static int can_delete_label_p\t\tPROTO((rtx));\n-static int merge_blocks_move_predecessor_nojumps PROTO((basic_block,\n+static int count_basic_blocks\t\tPARAMS ((rtx));\n+static rtx find_basic_blocks_1\t\tPARAMS ((rtx));\n+static void create_basic_block\t\tPARAMS ((int, rtx, rtx, rtx));\n+static void clear_edges\t\t\tPARAMS ((void));\n+static void make_edges\t\t\tPARAMS ((rtx));\n+static void make_edge\t\t\tPARAMS ((sbitmap *, basic_block,\n+\t\t\t\t\t\t basic_block, int));\n+static void make_label_edge\t\tPARAMS ((sbitmap *, basic_block,\n+\t\t\t\t\t\t rtx, int));\n+static void make_eh_edge\t\tPARAMS ((sbitmap *, eh_nesting_info *,\n+\t\t\t\t\t\t basic_block, rtx, int));\n+static void mark_critical_edges\t\tPARAMS ((void));\n+static void move_stray_eh_region_notes\tPARAMS ((void));\n+static void record_active_eh_regions\tPARAMS ((rtx));\n+\n+static void commit_one_edge_insertion\tPARAMS ((edge));\n+\n+static void delete_unreachable_blocks\tPARAMS ((void));\n+static void delete_eh_regions\t\tPARAMS ((void));\n+static int can_delete_note_p\t\tPARAMS ((rtx));\n+static int delete_block\t\t\tPARAMS ((basic_block));\n+static void expunge_block\t\tPARAMS ((basic_block));\n+static rtx flow_delete_insn\t\tPARAMS ((rtx));\n+static int can_delete_label_p\t\tPARAMS ((rtx));\n+static int merge_blocks_move_predecessor_nojumps PARAMS ((basic_block,\n+\t\t\t\t\t\t\t  basic_block));\n+static int merge_blocks_move_successor_nojumps PARAMS ((basic_block,\n \t\t\t\t\t\t\tbasic_block));\n-static int merge_blocks_move_successor_nojumps PROTO((basic_block,\n-\t\t\t\t\t\t      basic_block));\n-static void merge_blocks_nomove\t\tPROTO((basic_block, basic_block));\n-static int merge_blocks\t\t\tPROTO((edge,basic_block,basic_block));\n-static void try_merge_blocks\t\tPROTO((void));\n-static void tidy_fallthru_edge\t\tPROTO((edge,basic_block,basic_block));\n-\n-static int verify_wide_reg_1\t\tPROTO((rtx *, void *));\n-static void verify_wide_reg\t\tPROTO((int, rtx, rtx));\n-static void verify_local_live_at_start\tPROTO((regset, basic_block));\n-static int set_noop_p\t\t\tPROTO((rtx));\n-static int noop_move_p\t\t\tPROTO((rtx));\n-static void notice_stack_pointer_modification PROTO ((rtx, rtx, void *));\n-static void record_volatile_insns\tPROTO((rtx));\n-static void mark_reg\t\t\tPROTO((regset, rtx));\n-static void mark_regs_live_at_end\tPROTO((regset));\n-static void life_analysis_1\t\tPROTO((rtx, int, int));\n-static void calculate_global_regs_live\tPROTO((sbitmap, sbitmap, int));\n-static void propagate_block\t\tPROTO((regset, rtx, rtx,\n-\t\t\t\t\t       regset, int, int));\n-static int insn_dead_p\t\t\tPROTO((rtx, regset, int, rtx));\n-static int libcall_dead_p\t\tPROTO((rtx, regset, rtx, rtx));\n-static void mark_set_regs\t\tPROTO((regset, regset, rtx,\n-\t\t\t\t\t       rtx, regset, int));\n-static void mark_set_1\t\t\tPROTO((regset, regset, rtx,\n-\t\t\t\t\t       rtx, regset, int));\n+static void merge_blocks_nomove\t\tPARAMS ((basic_block, basic_block));\n+static int merge_blocks\t\t\tPARAMS ((edge,basic_block,basic_block));\n+static void try_merge_blocks\t\tPARAMS ((void));\n+static void tidy_fallthru_edge\t\tPARAMS ((edge,basic_block,basic_block));\n+\n+static int verify_wide_reg_1\t\tPARAMS ((rtx *, void *));\n+static void verify_wide_reg\t\tPARAMS ((int, rtx, rtx));\n+static void verify_local_live_at_start\tPARAMS ((regset, basic_block));\n+static int set_noop_p\t\t\tPARAMS ((rtx));\n+static int noop_move_p\t\t\tPARAMS ((rtx));\n+static void notice_stack_pointer_modification PARAMS ((rtx, rtx, void *));\n+static void record_volatile_insns\tPARAMS ((rtx));\n+static void mark_reg\t\t\tPARAMS ((regset, rtx));\n+static void mark_regs_live_at_end\tPARAMS ((regset));\n+static void life_analysis_1\t\tPARAMS ((rtx, int, int));\n+static void calculate_global_regs_live\tPARAMS ((sbitmap, sbitmap, int));\n+static void propagate_block\t\tPARAMS ((regset, rtx, rtx,\n+\t\t\t\t\t\t regset, int, int));\n+static int insn_dead_p\t\t\tPARAMS ((rtx, regset, int, rtx));\n+static int libcall_dead_p\t\tPARAMS ((rtx, regset, rtx, rtx));\n+static void mark_set_regs\t\tPARAMS ((regset, regset, rtx,\n+\t\t\t\t\t\t rtx, regset, int));\n+static void mark_set_1\t\t\tPARAMS ((regset, regset, rtx,\n+\t\t\t\t\t\t rtx, regset, int));\n #ifdef AUTO_INC_DEC\n-static void find_auto_inc\t\tPROTO((regset, rtx, rtx));\n-static int try_pre_increment_1\t\tPROTO((rtx));\n-static int try_pre_increment\t\tPROTO((rtx, rtx, HOST_WIDE_INT));\n+static void find_auto_inc\t\tPARAMS ((regset, rtx, rtx));\n+static int try_pre_increment_1\t\tPARAMS ((rtx));\n+static int try_pre_increment\t\tPARAMS ((rtx, rtx, HOST_WIDE_INT));\n #endif\n-static void mark_used_regs\t\tPROTO((regset, regset, rtx, int, rtx));\n-void dump_flow_info\t\t\tPROTO((FILE *));\n-void debug_flow_info\t\t\tPROTO((void));\n-static void dump_edge_info\t\tPROTO((FILE *, edge, int));\n-\n-static void count_reg_sets_1\t\tPROTO ((rtx));\n-static void count_reg_sets\t\tPROTO ((rtx));\n-static void count_reg_references\tPROTO ((rtx));\n-static void invalidate_mems_from_autoinc\tPROTO ((rtx));\n-static void remove_edge\t\t\tPROTO ((edge));\n-static void remove_fake_successors\tPROTO ((basic_block));\n-static void flow_nodes_print\tPROTO ((const char *, const sbitmap, FILE *));\n-static void flow_exits_print PROTO ((const char *, const edge *, int, FILE *));\n-static void flow_loops_cfg_dump\t\tPROTO ((const struct loops *, FILE *));\n-static int flow_loop_nested_p\t\tPROTO ((struct loop *, struct loop *));\n-static int flow_loop_exits_find\t\tPROTO ((const sbitmap, edge **));\n-static int flow_loop_nodes_find\tPROTO ((basic_block, basic_block, sbitmap));\n-static int flow_depth_first_order_compute PROTO ((int *));\n-static basic_block flow_loop_pre_header_find PROTO ((basic_block, const sbitmap *));\n-static void flow_loop_tree_node_add\tPROTO ((struct loop *, struct loop *));\n-static void flow_loops_tree_build\tPROTO ((struct loops *));\n-static int flow_loop_level_compute\tPROTO ((struct loop *, int));\n-static int flow_loops_level_compute\tPROTO ((struct loops *));\n+static void mark_used_regs\t\tPARAMS ((regset, regset, rtx, int, rtx));\n+void dump_flow_info\t\t\tPARAMS ((FILE *));\n+void debug_flow_info\t\t\tPARAMS ((void));\n+static void dump_edge_info\t\tPARAMS ((FILE *, edge, int));\n+\n+static void count_reg_sets_1\t\tPARAMS ((rtx));\n+static void count_reg_sets\t\tPARAMS ((rtx));\n+static void count_reg_references\tPARAMS ((rtx));\n+static void invalidate_mems_from_autoinc PARAMS ((rtx));\n+static void remove_edge\t\t\tPARAMS ((edge));\n+static void remove_fake_successors\tPARAMS ((basic_block));\n+static void flow_nodes_print\tPARAMS ((const char *, const sbitmap, FILE *));\n+static void flow_exits_print PARAMS ((const char *, const edge *, int, FILE *));\n+static void flow_loops_cfg_dump\t\tPARAMS ((const struct loops *, FILE *));\n+static int flow_loop_nested_p\t\tPARAMS ((struct loop *, struct loop *));\n+static int flow_loop_exits_find\t\tPARAMS ((const sbitmap, edge **));\n+static int flow_loop_nodes_find\tPARAMS ((basic_block, basic_block, sbitmap));\n+static int flow_depth_first_order_compute PARAMS ((int *));\n+static basic_block flow_loop_pre_header_find PARAMS ((basic_block, const sbitmap *));\n+static void flow_loop_tree_node_add\tPARAMS ((struct loop *, struct loop *));\n+static void flow_loops_tree_build\tPARAMS ((struct loops *));\n+static int flow_loop_level_compute\tPARAMS ((struct loop *, int));\n+static int flow_loops_level_compute\tPARAMS ((struct loops *));\n \n /* This function is always defined so it can be called from the\n    debugger, and it is declared extern so we don't get warnings about\n    it being unused. */\n-void verify_flow_info\t\t\tPROTO ((void));\n-int flow_loop_outside_edge_p\t\tPROTO ((const struct loop *, edge));\n+void verify_flow_info\t\t\tPARAMS ((void));\n+int flow_loop_outside_edge_p\t\tPARAMS ((const struct loop *, edge));\n \f\n /* Find basic blocks of the current function.\n    F is the first insn of the function and NREGS the number of register"}, {"sha": "d3efe90928e8d9442c58108b553ca9f5b74bae6e", "filename": "gcc/fold-const.c", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711d877c9e4f9b3250bc50e54c672b40840d574a/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711d877c9e4f9b3250bc50e54c672b40840d574a/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=711d877c9e4f9b3250bc50e54c672b40840d574a", "patch": "@@ -1,5 +1,5 @@\n /* Fold a constant sub-tree into a single node for C-compiler\n-   Copyright (C) 1987, 88, 92-98, 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 92-99, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -52,56 +52,56 @@ Boston, MA 02111-1307, USA.  */\n #include \"toplev.h\"\n #include \"ggc.h\"\n \n-static void encode\t\tPROTO((HOST_WIDE_INT *,\n-\t\t\t\t       HOST_WIDE_INT, HOST_WIDE_INT));\n-static void decode\t\tPROTO((HOST_WIDE_INT *,\n-\t\t\t\t       HOST_WIDE_INT *, HOST_WIDE_INT *));\n-int div_and_round_double\tPROTO((enum tree_code, int, HOST_WIDE_INT,\n-\t\t\t\t       HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t\t       HOST_WIDE_INT, HOST_WIDE_INT *,\n-\t\t\t\t       HOST_WIDE_INT *, HOST_WIDE_INT *,\n-\t\t\t\t       HOST_WIDE_INT *));\n-static tree negate_expr\t\tPROTO((tree));\n-static tree split_tree\t\tPROTO((tree, enum tree_code, tree *, tree *,\n-\t\t\t\t       int));\n-static tree associate_trees\tPROTO((tree, tree, enum tree_code, tree));\n-static tree int_const_binop\tPROTO((enum tree_code, tree, tree, int, int));\n-static void const_binop_1\tPROTO((PTR));\n-static tree const_binop\t\tPROTO((enum tree_code, tree, tree, int));\n-static void fold_convert_1\tPROTO((PTR));\n-static tree fold_convert\tPROTO((tree, tree));\n-static enum tree_code invert_tree_comparison PROTO((enum tree_code));\n-static enum tree_code swap_tree_comparison PROTO((enum tree_code));\n-static int truth_value_p\tPROTO((enum tree_code));\n-static int operand_equal_for_comparison_p PROTO((tree, tree, tree));\n-static int twoval_comparison_p\tPROTO((tree, tree *, tree *, int *));\n-static tree eval_subst\t\tPROTO((tree, tree, tree, tree, tree));\n-static tree omit_one_operand\tPROTO((tree, tree, tree));\n-static tree pedantic_omit_one_operand PROTO((tree, tree, tree));\n-static tree distribute_bit_expr PROTO((enum tree_code, tree, tree, tree));\n-static tree make_bit_field_ref\tPROTO((tree, tree, int, int, int));\n-static tree optimize_bit_field_compare PROTO((enum tree_code, tree,\n-\t\t\t\t\t      tree, tree));\n-static tree decode_field_reference PROTO((tree, int *, int *,\n-\t\t\t\t\t  enum machine_mode *, int *,\n-\t\t\t\t\t  int *, tree *, tree *));\n-static int all_ones_mask_p\tPROTO((tree, int));\n-static int simple_operand_p\tPROTO((tree));\n-static tree range_binop\t\tPROTO((enum tree_code, tree, tree, int,\n-\t\t\t\t       tree, int));\n-static tree make_range\t\tPROTO((tree, int *, tree *, tree *));\n-static tree build_range_check\tPROTO((tree, tree, int, tree, tree));\n-static int merge_ranges\t\tPROTO((int *, tree *, tree *, int, tree, tree,\n+static void encode\t\tPARAMS ((HOST_WIDE_INT *,\n+\t\t\t\t\t HOST_WIDE_INT, HOST_WIDE_INT));\n+static void decode\t\tPARAMS ((HOST_WIDE_INT *,\n+\t\t\t\t\t HOST_WIDE_INT *, HOST_WIDE_INT *));\n+int div_and_round_double\tPARAMS ((enum tree_code, int, HOST_WIDE_INT,\n+\t\t\t\t\t HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t\t HOST_WIDE_INT, HOST_WIDE_INT *,\n+\t\t\t\t\t HOST_WIDE_INT *, HOST_WIDE_INT *,\n+\t\t\t\t\t HOST_WIDE_INT *));\n+static tree negate_expr\t\tPARAMS ((tree));\n+static tree split_tree\t\tPARAMS ((tree, enum tree_code, tree *, tree *,\n+\t\t\t\t\t int));\n+static tree associate_trees\tPARAMS ((tree, tree, enum tree_code, tree));\n+static tree int_const_binop\tPARAMS ((enum tree_code, tree, tree, int, int));\n+static void const_binop_1\tPARAMS ((PTR));\n+static tree const_binop\t\tPARAMS ((enum tree_code, tree, tree, int));\n+static void fold_convert_1\tPARAMS ((PTR));\n+static tree fold_convert\tPARAMS ((tree, tree));\n+static enum tree_code invert_tree_comparison PARAMS ((enum tree_code));\n+static enum tree_code swap_tree_comparison PARAMS ((enum tree_code));\n+static int truth_value_p\tPARAMS ((enum tree_code));\n+static int operand_equal_for_comparison_p PARAMS ((tree, tree, tree));\n+static int twoval_comparison_p\tPARAMS ((tree, tree *, tree *, int *));\n+static tree eval_subst\t\tPARAMS ((tree, tree, tree, tree, tree));\n+static tree omit_one_operand\tPARAMS ((tree, tree, tree));\n+static tree pedantic_omit_one_operand PARAMS ((tree, tree, tree));\n+static tree distribute_bit_expr PARAMS ((enum tree_code, tree, tree, tree));\n+static tree make_bit_field_ref\tPARAMS ((tree, tree, int, int, int));\n+static tree optimize_bit_field_compare PARAMS ((enum tree_code, tree,\n+\t\t\t\t\t\ttree, tree));\n+static tree decode_field_reference PARAMS ((tree, int *, int *,\n+\t\t\t\t\t    enum machine_mode *, int *,\n+\t\t\t\t\t    int *, tree *, tree *));\n+static int all_ones_mask_p\tPARAMS ((tree, int));\n+static int simple_operand_p\tPARAMS ((tree));\n+static tree range_binop\t\tPARAMS ((enum tree_code, tree, tree, int,\n+\t\t\t\t\t tree, int));\n+static tree make_range\t\tPARAMS ((tree, int *, tree *, tree *));\n+static tree build_range_check\tPARAMS ((tree, tree, int, tree, tree));\n+static int merge_ranges\t\tPARAMS ((int *, tree *, tree *, int, tree, tree,\n \t\t\t\t       int, tree, tree));\n-static tree fold_range_test\tPROTO((tree));\n-static tree unextend\t\tPROTO((tree, int, int, tree));\n-static tree fold_truthop\tPROTO((enum tree_code, tree, tree, tree));\n-static tree optimize_minmax_comparison PROTO((tree));\n-static tree extract_muldiv\tPROTO((tree, tree, enum tree_code, tree));\n-static tree strip_compound_expr PROTO((tree, tree));\n-static int multiple_of_p\tPROTO((tree, tree, tree));\n-static tree constant_boolean_node PROTO((int, tree));\n-static int count_cond\t\tPROTO((tree, int));\n+static tree fold_range_test\tPARAMS ((tree));\n+static tree unextend\t\tPARAMS ((tree, int, int, tree));\n+static tree fold_truthop\tPARAMS ((enum tree_code, tree, tree, tree));\n+static tree optimize_minmax_comparison PARAMS ((tree));\n+static tree extract_muldiv\tPARAMS ((tree, tree, enum tree_code, tree));\n+static tree strip_compound_expr PARAMS ((tree, tree));\n+static int multiple_of_p\tPARAMS ((tree, tree, tree));\n+static tree constant_boolean_node PARAMS ((int, tree));\n+static int count_cond\t\tPARAMS ((tree, int));\n \n #ifndef BRANCH_COST\n #define BRANCH_COST 1"}, {"sha": "fffeb73e50f351af049c255160fa14e5b25edfe6", "filename": "gcc/function.c", "status": "modified", "additions": 59, "deletions": 59, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711d877c9e4f9b3250bc50e54c672b40840d574a/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711d877c9e4f9b3250bc50e54c672b40840d574a/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=711d877c9e4f9b3250bc50e54c672b40840d574a", "patch": "@@ -123,18 +123,18 @@ static int virtuals_instantiated;\n /* These variables hold pointers to functions to\n    save and restore machine-specific data,\n    in push_function_context and pop_function_context.  */\n-void (*init_machine_status) PROTO((struct function *));\n-void (*save_machine_status) PROTO((struct function *));\n-void (*restore_machine_status) PROTO((struct function *));\n-void (*mark_machine_status) PROTO((struct function *));\n-void (*free_machine_status) PROTO((struct function *));\n+void (*init_machine_status) PARAMS ((struct function *));\n+void (*save_machine_status) PARAMS ((struct function *));\n+void (*restore_machine_status) PARAMS ((struct function *));\n+void (*mark_machine_status) PARAMS ((struct function *));\n+void (*free_machine_status) PARAMS ((struct function *));\n \n /* Likewise, but for language-specific data.  */\n-void (*init_lang_status) PROTO((struct function *));\n-void (*save_lang_status) PROTO((struct function *));\n-void (*restore_lang_status) PROTO((struct function *));\n-void (*mark_lang_status) PROTO((struct function *));\n-void (*free_lang_status) PROTO((struct function *));\n+void (*init_lang_status) PARAMS ((struct function *));\n+void (*save_lang_status) PARAMS ((struct function *));\n+void (*restore_lang_status) PARAMS ((struct function *));\n+void (*mark_lang_status) PARAMS ((struct function *));\n+void (*free_lang_status) PARAMS ((struct function *));\n \n /* The FUNCTION_DECL for an inline function currently being expanded.  */\n tree inline_function_decl;\n@@ -230,62 +230,62 @@ struct insns_for_mem_entry {\n \n /* Forward declarations.  */\n \n-static rtx assign_stack_local_1 PROTO ((enum machine_mode, HOST_WIDE_INT,\n-\t\t\t\t\t    int, struct function *));\n-static rtx assign_stack_temp_for_type PROTO ((enum machine_mode, HOST_WIDE_INT,\n-\t\t\t\t\t      int, tree));\n-static struct temp_slot *find_temp_slot_from_address  PROTO((rtx));\n-static void put_reg_into_stack\tPROTO((struct function *, rtx, tree,\n-\t\t\t\t       enum machine_mode, enum machine_mode,\n-\t\t\t\t       int, int, int, \n-\t\t\t\t       struct hash_table *));\n-static void fixup_var_refs\tPROTO((rtx, enum machine_mode, int, \n-\t\t\t\t       struct hash_table *));\n+static rtx assign_stack_local_1 PARAMS ((enum machine_mode, HOST_WIDE_INT,\n+\t\t\t\t\t int, struct function *));\n+static rtx assign_stack_temp_for_type PARAMS ((enum machine_mode,\n+\t\t\t\t\t       HOST_WIDE_INT, int, tree));\n+static struct temp_slot *find_temp_slot_from_address  PARAMS ((rtx));\n+static void put_reg_into_stack\tPARAMS ((struct function *, rtx, tree,\n+\t\t\t\t\t enum machine_mode, enum machine_mode,\n+\t\t\t\t\t int, int, int, struct hash_table *));\n+static void fixup_var_refs\tPARAMS ((rtx, enum machine_mode, int, \n+\t\t\t\t\t struct hash_table *));\n static struct fixup_replacement\n-  *find_fixup_replacement\tPROTO((struct fixup_replacement **, rtx));\n-static void fixup_var_refs_insns PROTO((rtx, enum machine_mode, int,\n-\t\t\t\t\trtx, int, struct hash_table *));\n-static void fixup_var_refs_1\tPROTO((rtx, enum machine_mode, rtx *, rtx,\n-\t\t\t\t       struct fixup_replacement **));\n-static rtx fixup_memory_subreg\tPROTO((rtx, rtx, int));\n-static rtx walk_fixup_memory_subreg  PROTO((rtx, rtx, int));\n-static rtx fixup_stack_1\tPROTO((rtx, rtx));\n-static void optimize_bit_field\tPROTO((rtx, rtx, rtx *));\n-static void instantiate_decls\tPROTO((tree, int));\n-static void instantiate_decls_1\tPROTO((tree, int));\n-static void instantiate_decl\tPROTO((rtx, int, int));\n-static int instantiate_virtual_regs_1 PROTO((rtx *, rtx, int));\n-static void delete_handlers\tPROTO((void));\n-static void pad_to_arg_alignment PROTO((struct args_size *, int, struct args_size *));\n+  *find_fixup_replacement\tPARAMS ((struct fixup_replacement **, rtx));\n+static void fixup_var_refs_insns PARAMS ((rtx, enum machine_mode, int,\n+\t\t\t\t\t  rtx, int, struct hash_table *));\n+static void fixup_var_refs_1\tPARAMS ((rtx, enum machine_mode, rtx *, rtx,\n+\t\t\t\t\t struct fixup_replacement **));\n+static rtx fixup_memory_subreg\tPARAMS ((rtx, rtx, int));\n+static rtx walk_fixup_memory_subreg  PARAMS ((rtx, rtx, int));\n+static rtx fixup_stack_1\tPARAMS ((rtx, rtx));\n+static void optimize_bit_field\tPARAMS ((rtx, rtx, rtx *));\n+static void instantiate_decls\tPARAMS ((tree, int));\n+static void instantiate_decls_1\tPARAMS ((tree, int));\n+static void instantiate_decl\tPARAMS ((rtx, int, int));\n+static int instantiate_virtual_regs_1 PARAMS ((rtx *, rtx, int));\n+static void delete_handlers\tPARAMS ((void));\n+static void pad_to_arg_alignment PARAMS ((struct args_size *, int,\n+\t\t\t\t\t  struct args_size *));\n #ifndef ARGS_GROW_DOWNWARD\n-static void pad_below\t\tPROTO((struct args_size *, enum  machine_mode,\n-\t\t\t\t       tree));\n+static void pad_below\t\tPARAMS ((struct args_size *, enum machine_mode,\n+\t\t\t\t\t tree));\n #endif\n #ifdef ARGS_GROW_DOWNWARD\n-static tree round_down\t\tPROTO((tree, int));\n+static tree round_down\t\tPARAMS ((tree, int));\n #endif\n-static rtx round_trampoline_addr PROTO((rtx));\n-static tree blocks_nreverse\tPROTO((tree));\n-static int all_blocks\t\tPROTO((tree, tree *));\n+static rtx round_trampoline_addr PARAMS ((rtx));\n+static tree blocks_nreverse\tPARAMS ((tree));\n+static int all_blocks\t\tPARAMS ((tree, tree *));\n /* We always define `record_insns' even if its not used so that we\n    can always export `prologue_epilogue_contains'.  */\n-static int *record_insns\tPROTO((rtx)) ATTRIBUTE_UNUSED;\n-static int contains\t\tPROTO((rtx, int *));\n-static void put_addressof_into_stack PROTO((rtx, struct hash_table *));\n-static boolean purge_addressof_1 PROTO((rtx *, rtx, int, int, \n-\t\t\t\t       struct hash_table *));\n-static int is_addressof\t\tPROTO ((rtx *, void *));\n-static struct hash_entry *insns_for_mem_newfunc PROTO((struct hash_entry *,\n-\t\t\t\t\t\t       struct hash_table *,\n-\t\t\t\t\t\t       hash_table_key));\n-static unsigned long insns_for_mem_hash PROTO ((hash_table_key));\n-static boolean insns_for_mem_comp PROTO ((hash_table_key, hash_table_key));\n-static int insns_for_mem_walk   PROTO ((rtx *, void *));\n-static void compute_insns_for_mem PROTO ((rtx, rtx, struct hash_table *));\n-static void mark_temp_slot PROTO ((struct temp_slot *));\n-static void mark_function_status PROTO ((struct function *));\n-static void mark_function_chain PROTO ((void *));\n-static void prepare_function_start PROTO ((void));\n+static int *record_insns\tPARAMS ((rtx)) ATTRIBUTE_UNUSED;\n+static int contains\t\tPARAMS ((rtx, int *));\n+static void put_addressof_into_stack PARAMS ((rtx, struct hash_table *));\n+static boolean purge_addressof_1 PARAMS ((rtx *, rtx, int, int, \n+\t\t\t\t\t  struct hash_table *));\n+static int is_addressof\t\tPARAMS ((rtx *, void *));\n+static struct hash_entry *insns_for_mem_newfunc PARAMS ((struct hash_entry *,\n+\t\t\t\t\t\t\t struct hash_table *,\n+\t\t\t\t\t\t\t hash_table_key));\n+static unsigned long insns_for_mem_hash PARAMS ((hash_table_key));\n+static boolean insns_for_mem_comp PARAMS ((hash_table_key, hash_table_key));\n+static int insns_for_mem_walk   PARAMS ((rtx *, void *));\n+static void compute_insns_for_mem PARAMS ((rtx, rtx, struct hash_table *));\n+static void mark_temp_slot PARAMS ((struct temp_slot *));\n+static void mark_function_status PARAMS ((struct function *));\n+static void mark_function_chain PARAMS ((void *));\n+static void prepare_function_start PARAMS ((void));\n \n \f\n /* Pointer to chain of `struct function' for containing functions.  */"}, {"sha": "35d26bdf0d0131b8d0a533193e311e52e5fc9a2a", "filename": "gcc/function.h", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711d877c9e4f9b3250bc50e54c672b40840d574a/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711d877c9e4f9b3250bc50e54c672b40840d574a/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=711d877c9e4f9b3250bc50e54c672b40840d574a", "patch": "@@ -1,5 +1,5 @@\n /* Structure for saving state for a nested function.\n-   Copyright (C) 1989, 92-97, 1998, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1989, 92-99, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -535,63 +535,63 @@ extern tree inline_function_decl;\n \n /* Given a function decl for a containing function,\n    return the `struct function' for it.  */\n-struct function *find_function_data PROTO((tree));\n+struct function *find_function_data PARAMS ((tree));\n \n /* Pointer to chain of `struct function' for containing functions.  */\n extern struct function *outer_function_chain;\n \n /* Put all this function's BLOCK nodes into a vector and return it.\n    Also store in each NOTE for the beginning or end of a block\n    the index of that block in the vector.  */\n-extern void identify_blocks PROTO((tree, rtx));\n+extern void identify_blocks PARAMS ((tree, rtx));\n \n /* Return size needed for stack frame based on slots so far allocated.\n    This size counts from zero.  It is not rounded to STACK_BOUNDARY;\n    the caller may have to do that.  */\n-extern HOST_WIDE_INT get_frame_size\tPROTO((void));\n+extern HOST_WIDE_INT get_frame_size\tPARAMS ((void));\n /* Likewise, but for a different than the current function.  */\n-extern HOST_WIDE_INT get_func_frame_size\tPROTO((struct function *));\n+extern HOST_WIDE_INT get_func_frame_size\tPARAMS ((struct function *));\n \n /* These variables hold pointers to functions to\n    save and restore machine-specific data,\n    in push_function_context and pop_function_context.  */\n-extern void (*init_machine_status)\tPROTO((struct function *));\n-extern void (*mark_machine_status)\tPROTO((struct function *));\n-extern void (*save_machine_status)\tPROTO((struct function *));\n-extern void (*restore_machine_status)\tPROTO((struct function *));\n-extern void (*free_machine_status)\tPROTO((struct function *));\n+extern void (*init_machine_status)\tPARAMS ((struct function *));\n+extern void (*mark_machine_status)\tPARAMS ((struct function *));\n+extern void (*save_machine_status)\tPARAMS ((struct function *));\n+extern void (*restore_machine_status)\tPARAMS ((struct function *));\n+extern void (*free_machine_status)\tPARAMS ((struct function *));\n \n /* Likewise, but for language-specific data.  */\n-extern void (*init_lang_status)         PROTO((struct function *));\n-extern void (*mark_lang_status)\t\tPROTO((struct function *));\n-extern void (*save_lang_status)\t\tPROTO((struct function *));\n-extern void (*restore_lang_status)\tPROTO((struct function *));\n-extern void (*free_lang_status)         PROTO((struct function *));\n+extern void (*init_lang_status)         PARAMS ((struct function *));\n+extern void (*mark_lang_status)\t\tPARAMS ((struct function *));\n+extern void (*save_lang_status)\t\tPARAMS ((struct function *));\n+extern void (*restore_lang_status)\tPARAMS ((struct function *));\n+extern void (*free_lang_status)         PARAMS ((struct function *));\n \n /* Save and restore status information for a nested function.  */\n-extern void save_tree_status\t\tPROTO((struct function *));\n-extern void restore_tree_status\t\tPROTO((struct function *));\n-extern void restore_emit_status\t\tPROTO((struct function *));\n-extern void free_after_parsing\t\tPROTO((struct function *));\n-extern void free_after_compilation\tPROTO((struct function *));\n+extern void save_tree_status\t\tPARAMS ((struct function *));\n+extern void restore_tree_status\t\tPARAMS ((struct function *));\n+extern void restore_emit_status\t\tPARAMS ((struct function *));\n+extern void free_after_parsing\t\tPARAMS ((struct function *));\n+extern void free_after_compilation\tPARAMS ((struct function *));\n \n-extern void init_varasm_status\t\tPROTO((struct function *));\n-extern void free_varasm_status\t\tPROTO((struct function *));\n-extern void free_emit_status\t\tPROTO((struct function *));\n-extern void free_stmt_status            PROTO((struct function *));\n-extern void free_eh_status\t\tPROTO((struct function *));\n-extern void free_expr_status\t\tPROTO((struct function *));\n+extern void init_varasm_status\t\tPARAMS ((struct function *));\n+extern void free_varasm_status\t\tPARAMS ((struct function *));\n+extern void free_emit_status\t\tPARAMS ((struct function *));\n+extern void free_stmt_status            PARAMS ((struct function *));\n+extern void free_eh_status\t\tPARAMS ((struct function *));\n+extern void free_expr_status\t\tPARAMS ((struct function *));\n \n-extern rtx get_first_block_beg\t\tPROTO((void));\n+extern rtx get_first_block_beg\t\tPARAMS ((void));\n \n #ifdef RTX_CODE\n-extern void diddle_return_value\t\tPROTO((enum rtx_code));\n+extern void diddle_return_value\t\tPARAMS ((enum rtx_code));\n #endif\n \n-extern void init_virtual_regs\t\tPROTO((struct emit_status *));\n+extern void init_virtual_regs\t\tPARAMS ((struct emit_status *));\n \n /* Called once, at initialization, to initialize function.c.  */\n-extern void init_function_once          PROTO((void));\n+extern void init_function_once          PARAMS ((void));\n \n #ifdef rtx\n #undef rtx"}, {"sha": "7c77d4620c155d5f7517a73550e8c8a278d53953", "filename": "gcc/gcc.c", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711d877c9e4f9b3250bc50e54c672b40840d574a/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711d877c9e4f9b3250bc50e54c672b40840d574a/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=711d877c9e4f9b3250bc50e54c672b40840d574a", "patch": "@@ -48,7 +48,7 @@ compilation is specified by a string called a \"spec\".  */\n #include <sys/resource.h>\n #endif\n #ifdef NEED_DECLARATION_GETRUSAGE\n-extern int getrusage PROTO ((int, struct rusage *));\n+extern int getrusage PARAMS ((int, struct rusage *));\n #endif\n \n /* By default there is no special suffix for executables.  */\n@@ -194,58 +194,58 @@ extern char *version_string;\n /* Forward declaration for prototypes.  */\n struct path_prefix;\n \n-static void init_spec\t\tPROTO((void));\n+static void init_spec\t\tPARAMS ((void));\n #ifndef VMS\n-static char **split_directories\tPROTO((const char *, int *));\n-static void free_split_directories PROTO((char **));\n-static char *make_relative_prefix PROTO((const char *, const char *, const char *));\n+static char **split_directories\tPARAMS ((const char *, int *));\n+static void free_split_directories PARAMS ((char **));\n+static char *make_relative_prefix PARAMS ((const char *, const char *, const char *));\n #endif /* VMS */\n-static void read_specs\t\tPROTO((const char *, int));\n-static void set_spec\t\tPROTO((const char *, const char *));\n-static struct compiler *lookup_compiler PROTO((const char *, size_t, const char *));\n-static char *build_search_list\tPROTO((struct path_prefix *, const char *, int));\n-static void putenv_from_prefixes PROTO((struct path_prefix *, const char *));\n-static int access_check\t\tPROTO((const char *, int));\n-static char *find_a_file\tPROTO((struct path_prefix *, const char *, int));\n-static void add_prefix\t\tPROTO((struct path_prefix *, const char *,\n-\t\t\t\t       const char *, int, int, int *));\n-static char *skip_whitespace\tPROTO((char *));\n-static void record_temp_file\tPROTO((const char *, int, int));\n-static void delete_if_ordinary\tPROTO((const char *));\n-static void delete_temp_files\tPROTO((void));\n-static void delete_failure_queue PROTO((void));\n-static void clear_failure_queue PROTO((void));\n-static int check_live_switch\tPROTO((int, int));\n-static const char *handle_braces PROTO((const char *));\n-static char *save_string\tPROTO((const char *, int));\n-static int do_spec_1\t\tPROTO((const char *, int, const char *));\n-static const char *find_file\tPROTO((const char *));\n-static int is_directory\t\tPROTO((const char *, const char *, int));\n-static void validate_switches\tPROTO((const char *));\n-static void validate_all_switches PROTO((void));\n-static void give_switch\t\tPROTO((int, int, int));\n-static int used_arg\t\tPROTO((const char *, int));\n-static int default_arg\t\tPROTO((const char *, int));\n-static void set_multilib_dir\tPROTO((void));\n-static void print_multilib_info\tPROTO((void));\n-static void pfatal_with_name\tPROTO((const char *)) ATTRIBUTE_NORETURN;\n-static void perror_with_name\tPROTO((const char *));\n-static void pfatal_pexecute\tPROTO((const char *, const char *))\n+static void read_specs\t\tPARAMS ((const char *, int));\n+static void set_spec\t\tPARAMS ((const char *, const char *));\n+static struct compiler *lookup_compiler PARAMS ((const char *, size_t, const char *));\n+static char *build_search_list\tPARAMS ((struct path_prefix *, const char *, int));\n+static void putenv_from_prefixes PARAMS ((struct path_prefix *, const char *));\n+static int access_check\t\tPARAMS ((const char *, int));\n+static char *find_a_file\tPARAMS ((struct path_prefix *, const char *, int));\n+static void add_prefix\t\tPARAMS ((struct path_prefix *, const char *,\n+\t\t\t\t\t const char *, int, int, int *));\n+static char *skip_whitespace\tPARAMS ((char *));\n+static void record_temp_file\tPARAMS ((const char *, int, int));\n+static void delete_if_ordinary\tPARAMS ((const char *));\n+static void delete_temp_files\tPARAMS ((void));\n+static void delete_failure_queue PARAMS ((void));\n+static void clear_failure_queue PARAMS ((void));\n+static int check_live_switch\tPARAMS ((int, int));\n+static const char *handle_braces PARAMS ((const char *));\n+static char *save_string\tPARAMS ((const char *, int));\n+static int do_spec_1\t\tPARAMS ((const char *, int, const char *));\n+static const char *find_file\tPARAMS ((const char *));\n+static int is_directory\t\tPARAMS ((const char *, const char *, int));\n+static void validate_switches\tPARAMS ((const char *));\n+static void validate_all_switches PARAMS ((void));\n+static void give_switch\t\tPARAMS ((int, int, int));\n+static int used_arg\t\tPARAMS ((const char *, int));\n+static int default_arg\t\tPARAMS ((const char *, int));\n+static void set_multilib_dir\tPARAMS ((void));\n+static void print_multilib_info\tPARAMS ((void));\n+static void pfatal_with_name\tPARAMS ((const char *)) ATTRIBUTE_NORETURN;\n+static void perror_with_name\tPARAMS ((const char *));\n+static void pfatal_pexecute\tPARAMS ((const char *, const char *))\n   ATTRIBUTE_NORETURN;\n-static void error\t\tPVPROTO((const char *, ...))\n+static void error\t\tPARAMS ((const char *, ...))\n   ATTRIBUTE_PRINTF_1;\n-static void notice\t\tPVPROTO((const char *, ...))\n+static void notice\t\tPARAMS ((const char *, ...))\n   ATTRIBUTE_PRINTF_1;\n-static void display_help \tPROTO((void));\n-static void add_preprocessor_option\tPROTO ((const char *, int));\n-static void add_assembler_option\tPROTO ((const char *, int));\n-static void add_linker_option\t\tPROTO ((const char *, int));\n-static void process_command\t\tPROTO ((int, char **));\n-static int execute\t\t\tPROTO ((void));\n-static void unused_prefix_warnings\tPROTO ((struct path_prefix *));\n-static void clear_args\t\t\tPROTO ((void));\n-static void fatal_error\t\t\tPROTO ((int));\n-static void set_input\t\t\tPROTO ((const char *));\n+static void display_help \tPARAMS ((void));\n+static void add_preprocessor_option\tPARAMS ((const char *, int));\n+static void add_assembler_option\tPARAMS ((const char *, int));\n+static void add_linker_option\t\tPARAMS ((const char *, int));\n+static void process_command\t\tPARAMS ((int, char **));\n+static int execute\t\t\tPARAMS ((void));\n+static void unused_prefix_warnings\tPARAMS ((struct path_prefix *));\n+static void clear_args\t\t\tPARAMS ((void));\n+static void fatal_error\t\t\tPARAMS ((int));\n+static void set_input\t\t\tPARAMS ((const char *));\n \f\n /* Specs are strings containing lines, each of which (if not blank)\n is made up of a program name, and arguments separated by spaces.\n@@ -4988,7 +4988,7 @@ fatal_error (signum)\n   kill (getpid (), signum);\n }\n \n-extern int main PROTO ((int, char **));\n+extern int main PARAMS ((int, char **));\n \n int\n main (argc, argv)\n@@ -5635,7 +5635,7 @@ fancy_abort ()\n /* Output an error message and exit */\n \n void\n-fatal VPROTO((const char *msgid, ...))\n+fatal VPARAMS ((const char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   const char *msgid;\n@@ -5657,7 +5657,7 @@ fatal VPROTO((const char *msgid, ...))\n }\n \n static void\n-error VPROTO((const char *msgid, ...))\n+error VPARAMS ((const char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   const char *msgid;\n@@ -5678,7 +5678,7 @@ error VPROTO((const char *msgid, ...))\n }\n \n static void\n-notice VPROTO((const char *msgid, ...))\n+notice VPARAMS ((const char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   const char *msgid;"}, {"sha": "cac495897ff88b637eb3571b2d99576a18460298", "filename": "gcc/gcov-io.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711d877c9e4f9b3250bc50e54c672b40840d574a/gcc%2Fgcov-io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711d877c9e4f9b3250bc50e54c672b40840d574a/gcc%2Fgcov-io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.h?ref=711d877c9e4f9b3250bc50e54c672b40840d574a", "patch": "@@ -1,5 +1,5 @@\n /* Machine-independent I/O routines for gcov.\n-   Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1997, 1998, 2000 Free Software Foundation, Inc.\n    Contributed by Bob Manson <manson@cygnus.com>.\n \n This file is part of GNU CC.\n@@ -24,10 +24,10 @@ Boston, MA 02111-1307, USA.  */\n #include <stdio.h>\n #include <sys/types.h>\n \n-static int __fetch_long\t\tPROTO ((long *, char *, size_t));\n-static int __store_long\t\tPROTO ((long, char *, size_t));\n-static int __read_long\t\tPROTO ((long *, FILE *, size_t));\n-static int __write_long\t\tPROTO ((long, FILE *, size_t));\n+static int __fetch_long\t\tPARAMS ((long *, char *, size_t));\n+static int __store_long\t\tPARAMS ((long, char *, size_t));\n+static int __read_long\t\tPARAMS ((long *, FILE *, size_t));\n+static int __write_long\t\tPARAMS ((long, FILE *, size_t));\n \n /* These routines only work for signed values. */\n "}, {"sha": "974c708d0705d0eb7c9bc296eb9b9c41c9865e11", "filename": "gcc/gcov.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711d877c9e4f9b3250bc50e54c672b40840d574a/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711d877c9e4f9b3250bc50e54c672b40840d574a/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=711d877c9e4f9b3250bc50e54c672b40840d574a", "patch": "@@ -1,6 +1,6 @@\n /* Gcov.c: prepend line execution counts and branch probabilities to a\n    source file.\n-   Copyright (C) 1990, 91-94, 96, 97, 98, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1990, 91-94, 96-99, 2000 Free Software Foundation, Inc.\n    Contributed by James E. Wilson of Cygnus Support.\n    Mangled by Bob Manson of Cygnus Support.\n \n@@ -220,21 +220,21 @@ static char *object_directory = 0;\n static int output_branch_counts = 0;\n \n /* Forward declarations.  */\n-static void process_args PROTO ((int, char **));\n-static void open_files PROTO ((void));\n-static void read_files PROTO ((void));\n-static void scan_for_source_files PROTO ((void));\n-static void output_data PROTO ((void));\n-static void print_usage PROTO ((void)) ATTRIBUTE_NORETURN;\n-static void init_arc PROTO ((struct adj_list *, int, int, struct bb_info *));\n-static struct adj_list *reverse_arcs PROTO ((struct adj_list *));\n-static void create_program_flow_graph PROTO ((struct bb_info_list *));\n-static void solve_program_flow_graph PROTO ((struct bb_info_list *));\n-static void calculate_branch_probs PROTO ((struct bb_info_list *, int,\n-\t\t\t\t\t   struct arcdata **, int));\n-static void function_summary PROTO ((void));\n-\n-extern int main PROTO ((int, char **));\n+static void process_args PARAMS ((int, char **));\n+static void open_files PARAMS ((void));\n+static void read_files PARAMS ((void));\n+static void scan_for_source_files PARAMS ((void));\n+static void output_data PARAMS ((void));\n+static void print_usage PARAMS ((void)) ATTRIBUTE_NORETURN;\n+static void init_arc PARAMS ((struct adj_list *, int, int, struct bb_info *));\n+static struct adj_list *reverse_arcs PARAMS ((struct adj_list *));\n+static void create_program_flow_graph PARAMS ((struct bb_info_list *));\n+static void solve_program_flow_graph PARAMS ((struct bb_info_list *));\n+static void calculate_branch_probs PARAMS ((struct bb_info_list *, int,\n+\t\t\t\t\t    struct arcdata **, int));\n+static void function_summary PARAMS ((void));\n+\n+extern int main PARAMS ((int, char **));\n \n int\n main (argc, argv)\n@@ -260,9 +260,9 @@ main (argc, argv)\n   return 0;\n }\n \n-static void fnotice PVPROTO ((FILE *, const char *, ...)) ATTRIBUTE_PRINTF_2;\n+static void fnotice PARAMS ((FILE *, const char *, ...)) ATTRIBUTE_PRINTF_2;\n static void\n-fnotice VPROTO ((FILE *file, const char *msgid, ...))\n+fnotice VPARAMS ((FILE *file, const char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   FILE *file;\n@@ -283,7 +283,7 @@ fnotice VPROTO ((FILE *file, const char *msgid, ...))\n \n /* More 'friendly' abort that prints the line and file.\n    config.h can #define abort fancy_abort if you like that sort of thing.  */\n-extern void fancy_abort PROTO ((void)) ATTRIBUTE_NORETURN;\n+extern void fancy_abort PARAMS ((void)) ATTRIBUTE_NORETURN;\n \n void\n fancy_abort ()"}, {"sha": "a421d5442e2e0b5ec4340e58b93d78eef39840ea", "filename": "gcc/gcse.c", "status": "modified", "additions": 115, "deletions": 114, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711d877c9e4f9b3250bc50e54c672b40840d574a/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711d877c9e4f9b3250bc50e54c672b40840d574a/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=711d877c9e4f9b3250bc50e54c672b40840d574a", "patch": "@@ -523,123 +523,124 @@ struct null_pointer_info {\n   sbitmap *nonnull_killed;\n };\n \f\n-static void compute_can_copy\t  PROTO ((void));\n-\n-static char *gmalloc\t\t  PROTO ((unsigned int));\n-static char *grealloc\t\t PROTO ((char *, unsigned int));\n-static char *gcse_alloc\t       PROTO ((unsigned long));\n-static void alloc_gcse_mem\t    PROTO ((rtx));\n-static void free_gcse_mem\t     PROTO ((void));\n-static void alloc_reg_set_mem\t PROTO ((int));\n-static void free_reg_set_mem\t  PROTO ((void));\n-static int get_bitmap_width           PROTO ((int, int, int));\n-static void record_one_set\t    PROTO ((int, rtx));\n-static void record_set_info\t   PROTO ((rtx, rtx, void *));\n-static void compute_sets\t      PROTO ((rtx));\n-\n-static void hash_scan_insn\t    PROTO ((rtx, int, int));\n-static void hash_scan_set\t     PROTO ((rtx, rtx, int));\n-static void hash_scan_clobber\t PROTO ((rtx, rtx));\n-static void hash_scan_call\t    PROTO ((rtx, rtx));\n-static int want_to_gcse_p\t     PROTO ((rtx));\n-static int oprs_unchanged_p\t   PROTO ((rtx, rtx, int));\n-static int oprs_anticipatable_p       PROTO ((rtx, rtx));\n-static int oprs_available_p\t   PROTO ((rtx, rtx));\n-static void insert_expr_in_table      PROTO ((rtx, enum machine_mode,\n+static void compute_can_copy\t  PARAMS ((void));\n+\n+static char *gmalloc\t\t  PARAMS ((unsigned int));\n+static char *grealloc\t\t PARAMS ((char *, unsigned int));\n+static char *gcse_alloc\t       PARAMS ((unsigned long));\n+static void alloc_gcse_mem\t    PARAMS ((rtx));\n+static void free_gcse_mem\t     PARAMS ((void));\n+static void alloc_reg_set_mem\t PARAMS ((int));\n+static void free_reg_set_mem\t  PARAMS ((void));\n+static int get_bitmap_width           PARAMS ((int, int, int));\n+static void record_one_set\t    PARAMS ((int, rtx));\n+static void record_set_info\t   PARAMS ((rtx, rtx, void *));\n+static void compute_sets\t      PARAMS ((rtx));\n+\n+static void hash_scan_insn\t    PARAMS ((rtx, int, int));\n+static void hash_scan_set\t     PARAMS ((rtx, rtx, int));\n+static void hash_scan_clobber\t PARAMS ((rtx, rtx));\n+static void hash_scan_call\t    PARAMS ((rtx, rtx));\n+static int want_to_gcse_p\t     PARAMS ((rtx));\n+static int oprs_unchanged_p\t   PARAMS ((rtx, rtx, int));\n+static int oprs_anticipatable_p       PARAMS ((rtx, rtx));\n+static int oprs_available_p\t   PARAMS ((rtx, rtx));\n+static void insert_expr_in_table      PARAMS ((rtx, enum machine_mode,\n \t\t\t\t\t      rtx, int, int));\n-static void insert_set_in_table       PROTO ((rtx, rtx));\n-static unsigned int hash_expr\t PROTO ((rtx, enum machine_mode,\n-\t\t\t\t\t int *, int));\n-static unsigned int hash_expr_1       PROTO ((rtx, enum machine_mode, int *));\n-static unsigned int hash_set\t  PROTO ((int, int));\n-static int expr_equiv_p\t       PROTO ((rtx, rtx));\n-static void record_last_reg_set_info  PROTO ((rtx, int));\n-static void record_last_mem_set_info  PROTO ((rtx));\n-static void record_last_set_info      PROTO ((rtx, rtx, void *));\n-static void compute_hash_table\tPROTO ((int));\n-static void alloc_set_hash_table      PROTO ((int));\n-static void free_set_hash_table       PROTO ((void));\n-static void compute_set_hash_table    PROTO ((void));\n-static void alloc_expr_hash_table     PROTO ((int));\n-static void free_expr_hash_table      PROTO ((void));\n-static void compute_expr_hash_table   PROTO ((void));\n-static void dump_hash_table\t   PROTO ((FILE *, const char *, struct expr **,\n-\t\t\t\t\t   int, int));\n-static struct expr *lookup_expr       PROTO ((rtx));\n-static struct expr *lookup_set\tPROTO ((int, rtx));\n-static struct expr *next_set\t  PROTO ((int, struct expr *));\n-static void reset_opr_set_tables      PROTO ((void));\n-static int oprs_not_set_p\t     PROTO ((rtx, rtx));\n-static void mark_call\t\t PROTO ((rtx));\n-static void mark_set\t\t  PROTO ((rtx, rtx));\n-static void mark_clobber\t      PROTO ((rtx, rtx));\n-static void mark_oprs_set\t     PROTO ((rtx));\n-\n-static void alloc_cprop_mem\t   PROTO ((int, int));\n-static void free_cprop_mem\t    PROTO ((void));\n-static void compute_transp\t    PROTO ((rtx, int, sbitmap *, int));\n-static void compute_transpout\t    PROTO ((void));\n-static void compute_local_properties  PROTO ((sbitmap *, sbitmap *,\n-\t\t\t\t\t      sbitmap *, int));\n-static void compute_cprop_data\tPROTO ((void));\n-static void find_used_regs\t    PROTO ((rtx));\n-static int try_replace_reg\t    PROTO ((rtx, rtx, rtx));\n-static struct expr *find_avail_set    PROTO ((int, rtx));\n-static int cprop_jump\t\t\tPROTO((rtx, rtx, struct reg_use *, rtx));\n+static void insert_set_in_table       PARAMS ((rtx, rtx));\n+static unsigned int hash_expr\t PARAMS ((rtx, enum machine_mode,\n+\t\t\t\t\t  int *, int));\n+static unsigned int hash_expr_1       PARAMS ((rtx, enum machine_mode, int *));\n+static unsigned int hash_set\t  PARAMS ((int, int));\n+static int expr_equiv_p\t       PARAMS ((rtx, rtx));\n+static void record_last_reg_set_info  PARAMS ((rtx, int));\n+static void record_last_mem_set_info  PARAMS ((rtx));\n+static void record_last_set_info      PARAMS ((rtx, rtx, void *));\n+static void compute_hash_table\tPARAMS ((int));\n+static void alloc_set_hash_table      PARAMS ((int));\n+static void free_set_hash_table       PARAMS ((void));\n+static void compute_set_hash_table    PARAMS ((void));\n+static void alloc_expr_hash_table     PARAMS ((int));\n+static void free_expr_hash_table      PARAMS ((void));\n+static void compute_expr_hash_table   PARAMS ((void));\n+static void dump_hash_table\t   PARAMS ((FILE *, const char *,\n+\t\t\t\t\t    struct expr **, int, int));\n+static struct expr *lookup_expr       PARAMS ((rtx));\n+static struct expr *lookup_set\tPARAMS ((int, rtx));\n+static struct expr *next_set\t  PARAMS ((int, struct expr *));\n+static void reset_opr_set_tables      PARAMS ((void));\n+static int oprs_not_set_p\t     PARAMS ((rtx, rtx));\n+static void mark_call\t\t PARAMS ((rtx));\n+static void mark_set\t\t  PARAMS ((rtx, rtx));\n+static void mark_clobber\t      PARAMS ((rtx, rtx));\n+static void mark_oprs_set\t     PARAMS ((rtx));\n+\n+static void alloc_cprop_mem\t   PARAMS ((int, int));\n+static void free_cprop_mem\t    PARAMS ((void));\n+static void compute_transp\t    PARAMS ((rtx, int, sbitmap *, int));\n+static void compute_transpout\t    PARAMS ((void));\n+static void compute_local_properties  PARAMS ((sbitmap *, sbitmap *,\n+\t\t\t\t\t       sbitmap *, int));\n+static void compute_cprop_data\tPARAMS ((void));\n+static void find_used_regs\t    PARAMS ((rtx));\n+static int try_replace_reg\t    PARAMS ((rtx, rtx, rtx));\n+static struct expr *find_avail_set    PARAMS ((int, rtx));\n+static int cprop_jump\t\t\tPARAMS ((rtx, rtx, struct reg_use *, rtx));\n #ifdef HAVE_cc0\n-static int cprop_cc0_jump\t\tPROTO((rtx, struct reg_use *, rtx));\n+static int cprop_cc0_jump\t\tPARAMS ((rtx, struct reg_use *, rtx));\n #endif\n-static int cprop_insn\t\t PROTO ((rtx, int));\n-static int cprop\t\t      PROTO ((int));\n-static int one_cprop_pass\t     PROTO ((int, int));\n-\n-static void alloc_pre_mem\t     PROTO ((int, int));\n-static void free_pre_mem\t      PROTO ((void));\n-static void compute_pre_data\t  PROTO ((void));\n-static int pre_expr_reaches_here_p    PROTO ((int, struct expr *, int));\n-static void insert_insn_end_bb\tPROTO ((struct expr *, int, int));\n-static void pre_insert_copy_insn      PROTO ((struct expr *, rtx));\n-static void pre_insert_copies\t PROTO ((void));\n-static int pre_delete\t\t PROTO ((void));\n-static int pre_gcse\t\t   PROTO ((void));\n-static int one_pre_gcse_pass\t  PROTO ((int));\n-\n-static void add_label_notes\t      PROTO ((rtx, rtx));\n-\n-static void alloc_code_hoist_mem\tPROTO ((int, int));\n-static void free_code_hoist_mem\t\tPROTO ((void));\n-static void compute_code_hoist_vbeinout\tPROTO ((void));\n-static void compute_code_hoist_data\tPROTO ((void));\n-static int hoist_expr_reaches_here_p\tPROTO ((int, int, int, char *));\n-static void hoist_code\t\t\tPROTO ((void));\n-static int one_code_hoisting_pass\tPROTO ((void));\n-\n-static void alloc_rd_mem\t      PROTO ((int, int));\n-static void free_rd_mem\t       PROTO ((void));\n-static void handle_rd_kill_set\tPROTO ((rtx, int, int));\n-static void compute_kill_rd\t   PROTO ((void));\n-static void compute_rd\t\tPROTO ((void));\n-static void alloc_avail_expr_mem      PROTO ((int, int));\n-static void free_avail_expr_mem       PROTO ((void));\n-static void compute_ae_gen\t    PROTO ((void));\n-static int expr_killed_p\t      PROTO ((rtx, int));\n-static void compute_ae_kill\t   PROTO ((sbitmap *, sbitmap *));\n-static int expr_reaches_here_p\tPROTO ((struct occr *, struct expr *,\n-\t\t\t\t\t      int, int));\n-static rtx computing_insn\t     PROTO ((struct expr *, rtx));\n-static int def_reaches_here_p\t PROTO ((rtx, rtx));\n-static int can_disregard_other_sets   PROTO ((struct reg_set **, rtx, int));\n-static int handle_avail_expr\t  PROTO ((rtx, struct expr *));\n-static int classic_gcse\t       PROTO ((void));\n-static int one_classic_gcse_pass      PROTO ((int));\n-static void invalidate_nonnull_info\tPROTO ((rtx, rtx, void *));\n-static void delete_null_pointer_checks_1 PROTO ((int *, sbitmap *, sbitmap *,\n-\t\t\t\t\t\t struct null_pointer_info *));\n-static rtx process_insert_insn\tPROTO ((struct expr *));\n-static int pre_edge_insert\tPROTO ((struct edge_list *, struct expr **));\n-static int expr_reaches_here_p_work\tPROTO ((struct occr *, struct expr *, int, int, char *));\n-static int pre_expr_reaches_here_p_work\tPROTO ((int, struct expr *,\n-\t\t\t\t\t\tint, char *));\n+static int cprop_insn\t\t PARAMS ((rtx, int));\n+static int cprop\t\t      PARAMS ((int));\n+static int one_cprop_pass\t     PARAMS ((int, int));\n+\n+static void alloc_pre_mem\t     PARAMS ((int, int));\n+static void free_pre_mem\t      PARAMS ((void));\n+static void compute_pre_data\t  PARAMS ((void));\n+static int pre_expr_reaches_here_p    PARAMS ((int, struct expr *, int));\n+static void insert_insn_end_bb\tPARAMS ((struct expr *, int, int));\n+static void pre_insert_copy_insn      PARAMS ((struct expr *, rtx));\n+static void pre_insert_copies\t PARAMS ((void));\n+static int pre_delete\t\t PARAMS ((void));\n+static int pre_gcse\t\t   PARAMS ((void));\n+static int one_pre_gcse_pass\t  PARAMS ((int));\n+\n+static void add_label_notes\t      PARAMS ((rtx, rtx));\n+\n+static void alloc_code_hoist_mem\tPARAMS ((int, int));\n+static void free_code_hoist_mem\t\tPARAMS ((void));\n+static void compute_code_hoist_vbeinout\tPARAMS ((void));\n+static void compute_code_hoist_data\tPARAMS ((void));\n+static int hoist_expr_reaches_here_p\tPARAMS ((int, int, int, char *));\n+static void hoist_code\t\t\tPARAMS ((void));\n+static int one_code_hoisting_pass\tPARAMS ((void));\n+\n+static void alloc_rd_mem\t      PARAMS ((int, int));\n+static void free_rd_mem\t       PARAMS ((void));\n+static void handle_rd_kill_set\tPARAMS ((rtx, int, int));\n+static void compute_kill_rd\t   PARAMS ((void));\n+static void compute_rd\t\tPARAMS ((void));\n+static void alloc_avail_expr_mem      PARAMS ((int, int));\n+static void free_avail_expr_mem       PARAMS ((void));\n+static void compute_ae_gen\t    PARAMS ((void));\n+static int expr_killed_p\t      PARAMS ((rtx, int));\n+static void compute_ae_kill\t   PARAMS ((sbitmap *, sbitmap *));\n+static int expr_reaches_here_p\tPARAMS ((struct occr *, struct expr *,\n+\t\t\t\t\t int, int));\n+static rtx computing_insn\t     PARAMS ((struct expr *, rtx));\n+static int def_reaches_here_p\t PARAMS ((rtx, rtx));\n+static int can_disregard_other_sets   PARAMS ((struct reg_set **, rtx, int));\n+static int handle_avail_expr\t  PARAMS ((rtx, struct expr *));\n+static int classic_gcse\t       PARAMS ((void));\n+static int one_classic_gcse_pass      PARAMS ((int));\n+static void invalidate_nonnull_info\tPARAMS ((rtx, rtx, void *));\n+static void delete_null_pointer_checks_1 PARAMS ((int *, sbitmap *, sbitmap *,\n+\t\t\t\t\t\t  struct null_pointer_info *));\n+static rtx process_insert_insn\tPARAMS ((struct expr *));\n+static int pre_edge_insert\tPARAMS ((struct edge_list *, struct expr **));\n+static int expr_reaches_here_p_work\tPARAMS ((struct occr *, struct expr *,\n+\t\t\t\t\t\t int, int, char *));\n+static int pre_expr_reaches_here_p_work\tPARAMS ((int, struct expr *,\n+\t\t\t\t\t\t int, char *));\n \f\n /* Entry point for global common subexpression elimination.\n    F is the first instruction in the function.  */"}]}