{"sha": "9a1b9cb4d6fcf88d68f55b97c7d9d09c5606fed7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWExYjljYjRkNmZjZjg4ZDY4ZjU1Yjk3YzdkOWQwOWM1NjA2ZmVkNw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-02-01T11:02:52Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-02-01T11:02:52Z"}, "message": "[AArch64] Tighten aarch64_secondary_reload condition (PR 83845)\n\naarch64_secondary_reload enforced a secondary reload via\naarch64_sve_reload_be for memory and pseudo registers, but failed\nto do the same for subregs of pseudo registers.  To avoid this and\nany similar problems, the patch instead tests for things that the move\npatterns handle directly; if the operand isn't one of those, we should\nuse the reload pattern instead.\n\nThe patch fixes an ICE in sve/mask_struct_store_3.c for aarch64_be,\nwhere the bogus target description was (rightly) causing LRA to cycle.\n\n2018-02-01  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\tPR tearget/83845\n\t* config/aarch64/aarch64.c (aarch64_secondary_reload): Tighten\n\tcheck for operands that need to go through aarch64_sve_reload_be.\n\nReviewed-by: James Greenhalgh <james.greenhalgh@arm.com>\n\nFrom-SVN: r257285", "tree": {"sha": "e9113a183b853716bdd60e811c85a208236d42c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e9113a183b853716bdd60e811c85a208236d42c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a1b9cb4d6fcf88d68f55b97c7d9d09c5606fed7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a1b9cb4d6fcf88d68f55b97c7d9d09c5606fed7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a1b9cb4d6fcf88d68f55b97c7d9d09c5606fed7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a1b9cb4d6fcf88d68f55b97c7d9d09c5606fed7/comments", "author": null, "committer": null, "parents": [{"sha": "31b6733b1628a861de4c545bff40acc97850dbbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31b6733b1628a861de4c545bff40acc97850dbbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31b6733b1628a861de4c545bff40acc97850dbbf"}], "stats": {"total": 13, "additions": 12, "deletions": 1}, "files": [{"sha": "adaec489e967e14ab8ed1425a75e37e7bb68fe3d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a1b9cb4d6fcf88d68f55b97c7d9d09c5606fed7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a1b9cb4d6fcf88d68f55b97c7d9d09c5606fed7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9a1b9cb4d6fcf88d68f55b97c7d9d09c5606fed7", "patch": "@@ -1,3 +1,9 @@\n+2018-02-01  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\tPR tearget/83845\n+\t* config/aarch64/aarch64.c (aarch64_secondary_reload): Tighten\n+\tcheck for operands that need to go through aarch64_sve_reload_be.\n+\n 2018-02-01  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/81661"}, {"sha": "656dd7614cf8cd36b309f97cdb9782ac8a300134", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a1b9cb4d6fcf88d68f55b97c7d9d09c5606fed7/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a1b9cb4d6fcf88d68f55b97c7d9d09c5606fed7/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=9a1b9cb4d6fcf88d68f55b97c7d9d09c5606fed7", "patch": "@@ -7249,9 +7249,14 @@ aarch64_secondary_reload (bool in_p ATTRIBUTE_UNUSED, rtx x,\n \t\t\t  machine_mode mode,\n \t\t\t  secondary_reload_info *sri)\n {\n+  /* Use aarch64_sve_reload_be for SVE reloads that cannot be handled\n+     directly by the *aarch64_sve_mov<mode>_be move pattern.  See the\n+     comment at the head of aarch64-sve.md for more details about the\n+     big-endian handling.  */\n   if (BYTES_BIG_ENDIAN\n       && reg_class_subset_p (rclass, FP_REGS)\n-      && (MEM_P (x) || (REG_P (x) && !HARD_REGISTER_P (x)))\n+      && !((REG_P (x) && HARD_REGISTER_P (x))\n+\t   || aarch64_simd_valid_immediate (x, NULL))\n       && aarch64_sve_data_mode_p (mode))\n     {\n       sri->icode = CODE_FOR_aarch64_sve_reload_be;"}]}