{"sha": "a08b260482d8972aaaa3eb2a0175f9cc175dbad9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTA4YjI2MDQ4MmQ4OTcyYWFhYTNlYjJhMDE3NWY5Y2MxNzVkYmFkOQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-07-30T20:03:37Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-07-30T20:03:37Z"}, "message": "flow.c (mark_set_1): Use REG_FREQ_FROM_BB.\n\n\t* flow.c (mark_set_1): Use REG_FREQ_FROM_BB.\n\t(attempt_auto_inc): LIkewise.\n\t(mark_used_reg): Likewise.\n\t(try_pre_increment_1): Likewise.\n\t* regclass.c (regclass): Likewise.\n\t* global.c (allocno_compare): Update comment; change scaling factor.\n\t* local-alloc.c (QTY_CMP_PRI): Likewise.\n\t* regs.h (REG_FREQ_FROM_BB): New.\n\t(REG_FREQ_MAX): Likewise.\n\nFrom-SVN: r44483", "tree": {"sha": "aa952727c06ed38ed797f094dd095bd14f5da5f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aa952727c06ed38ed797f094dd095bd14f5da5f4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a08b260482d8972aaaa3eb2a0175f9cc175dbad9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a08b260482d8972aaaa3eb2a0175f9cc175dbad9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a08b260482d8972aaaa3eb2a0175f9cc175dbad9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a08b260482d8972aaaa3eb2a0175f9cc175dbad9/comments", "author": null, "committer": null, "parents": [{"sha": "e5b3941e7e73831e7adecf066ee08461254eaadd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5b3941e7e73831e7adecf066ee08461254eaadd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5b3941e7e73831e7adecf066ee08461254eaadd"}], "stats": {"total": 65, "additions": 45, "deletions": 20}, "files": [{"sha": "67acc96c41a30cf16aa664ae2b5a668b38dfa07f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a08b260482d8972aaaa3eb2a0175f9cc175dbad9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a08b260482d8972aaaa3eb2a0175f9cc175dbad9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a08b260482d8972aaaa3eb2a0175f9cc175dbad9", "patch": "@@ -1,3 +1,15 @@\n+Mon Jul 30 21:54:53 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* flow.c (mark_set_1): Use REG_FREQ_FROM_BB.\n+\t(attempt_auto_inc): LIkewise.\n+\t(mark_used_reg): Likewise.\n+\t(try_pre_increment_1): Likewise.\n+\t* regclass.c (regclass): Likewise.\n+\t* global.c (allocno_compare): Update comment; change scaling factor.\n+\t* local-alloc.c (QTY_CMP_PRI): Likewise.\n+\t* regs.h (REG_FREQ_FROM_BB): New.\n+\t(REG_FREQ_MAX): Likewise.\n+\n 2001-07-30  H.J. Lu <hjl@gnu.org>\n \n \t* config/mips/linux.h (CPLUSPLUS_CPP_SPEC): Add"}, {"sha": "69e7747502d39dcdf5e793ce00e9b60fa48b29e2", "filename": "gcc/flow.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a08b260482d8972aaaa3eb2a0175f9cc175dbad9/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a08b260482d8972aaaa3eb2a0175f9cc175dbad9/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=a08b260482d8972aaaa3eb2a0175f9cc175dbad9", "patch": "@@ -6220,8 +6220,7 @@ mark_set_1 (pbi, code, reg, cond, insn, flags)\n \t\t     register twice if it is modified, but that is correct.  */\n \t\t  REG_N_SETS (i) += 1;\n \t\t  REG_N_REFS (i) += 1;\n-\t\t  REG_FREQ (i) += (optimize_size || !pbi->bb->frequency\n-\t\t\t\t   ? 1 : pbi->bb->frequency);\n+\t\t  REG_FREQ (i) += REG_FREQ_FROM_BB (pbi->bb);\n \n \t          /* The insns where a reg is live are normally counted\n \t\t     elsewhere, but we want the count to include the insn\n@@ -6888,8 +6887,7 @@ attempt_auto_inc (pbi, inc, insn, mem, incr, incr_reg)\n       /* Count an extra reference to the reg.  When a reg is\n \t incremented, spilling it is worse, so we want to make\n \t that less likely.  */\n-      REG_FREQ (regno) += (optimize_size || !pbi->bb->frequency\n-\t\t           ? 1 : pbi->bb->frequency);\n+      REG_FREQ (regno) += REG_FREQ_FROM_BB (pbi->bb);\n \n       /* Count the increment as a setting of the register,\n \t even though it isn't a SET in rtl.  */\n@@ -7054,8 +7052,7 @@ mark_used_reg (pbi, reg, cond, insn)\n \t    REG_BASIC_BLOCK (regno_first) = REG_BLOCK_GLOBAL;\n \n \t  /* Count (weighted) number of uses of each reg.  */\n-\t  REG_FREQ (regno_first)\n-\t    += (optimize_size || !pbi->bb->frequency ? 1 : pbi->bb->frequency);\n+\t  REG_FREQ (regno_first) += REG_FREQ_FROM_BB (pbi->bb);\n \t  REG_N_REFS (regno_first)++;\n \t}\n     }\n@@ -7477,8 +7474,7 @@ try_pre_increment_1 (pbi, insn)\n \t so we want to make that less likely.  */\n       if (regno >= FIRST_PSEUDO_REGISTER)\n \t{\n-\t  REG_FREQ (regno) += (optimize_size || !pbi->bb->frequency\n-\t\t\t       ? 1 : pbi->bb->frequency);\n+\t  REG_FREQ (regno) += REG_FREQ_FROM_BB (pbi->bb);\n \t  REG_N_SETS (regno)++;\n \t}\n "}, {"sha": "6558fac8b89919e7a6f5f722c1c4c3c7ac273f99", "filename": "gcc/global.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a08b260482d8972aaaa3eb2a0175f9cc175dbad9/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a08b260482d8972aaaa3eb2a0175f9cc175dbad9/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=a08b260482d8972aaaa3eb2a0175f9cc175dbad9", "patch": "@@ -611,16 +611,17 @@ allocno_compare (v1p, v2p)\n   int v1 = *(const int *)v1p, v2 = *(const int *)v2p;\n   /* Note that the quotient will never be bigger than\n      the value of floor_log2 times the maximum number of\n-     times a register can occur in one insn (surely less than 100).\n-     Multiplying this by 10000 can't overflow.  */\n+     times a register can occur in one insn (surely less than 100)\n+     weighted by the frequency (maximally REG_FREQ_MAX).\n+     Multiplying this by 10000/REG_FREQ_MAX can't overflow.  */\n   register int pri1\n     = (((double) (floor_log2 (allocno[v1].n_refs) * allocno[v1].freq)\n \t/ allocno[v1].live_length)\n-       * 10000 * allocno[v1].size);\n+       * (10000 / REG_FREQ_MAX) * allocno[v1].size);\n   register int pri2\n     = (((double) (floor_log2 (allocno[v2].n_refs) * allocno[v2].freq)\n \t/ allocno[v2].live_length)\n-       * 10000 * allocno[v2].size);\n+       * (10000 / REG_FREQ_MAX) * allocno[v2].size);\n   if (pri2 - pri1)\n     return pri2 - pri1;\n "}, {"sha": "a068db8385d3964a06516573ea8c0b1542622065", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a08b260482d8972aaaa3eb2a0175f9cc175dbad9/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a08b260482d8972aaaa3eb2a0175f9cc175dbad9/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=a08b260482d8972aaaa3eb2a0175f9cc175dbad9", "patch": "@@ -1698,13 +1698,14 @@ block_alloc (b)\n \n /* Note that the quotient will never be bigger than\n    the value of floor_log2 times the maximum number of\n-   times a register can occur in one insn (surely less than 100).\n-   Multiplying this by 10000 can't overflow.\n+   times a register can occur in one insn (surely less than 100)\n+   weighted by frequency (max REG_FREQ_MAX).\n+   Multiplying this by 10000/REG_FREQ_MAX can't overflow.\n    QTY_CMP_PRI is also used by qty_sugg_compare.  */\n \n #define QTY_CMP_PRI(q)\t\t\\\n   ((int) (((double) (floor_log2 (qty[q].n_refs) * qty[q].freq * qty[q].size) \\\n-\t  / (qty[q].death - qty[q].birth)) * 10000))\n+\t  / (qty[q].death - qty[q].birth)) * (10000 / REG_FREQ_MAX)))\n \n static int\n qty_compare (q1, q2)"}, {"sha": "b16a677d8056648035fd99fa00d13a2c536766fa", "filename": "gcc/regclass.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a08b260482d8972aaaa3eb2a0175f9cc175dbad9/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a08b260482d8972aaaa3eb2a0175f9cc175dbad9/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=a08b260482d8972aaaa3eb2a0175f9cc175dbad9", "patch": "@@ -1233,7 +1233,7 @@ regclass (f, nregs, dump)\n \n       if (!optimize)\n \t{\n-\t  frequency = 1;\n+\t  frequency = REG_FREQ_MAX;\n \t  for (insn = f; insn; insn = NEXT_INSN (insn))\n \t    insn = scan_one_insn (insn, pass);\n \t}\n@@ -1246,10 +1246,7 @@ regclass (f, nregs, dump)\n \t       times more than insns outside a loop.  This is much more\n \t       aggressive than the assumptions made elsewhere and is being\n \t       tried as an experiment.  */\n-\t    if (optimize_size)\n-\t      frequency = 1;\n-\t    else\n-\t      frequency = bb->frequency ? bb->frequency : 1;\n+\t    frequency = REG_FREQ_FROM_BB (bb);\n \t    for (insn = bb->head; ; insn = NEXT_INSN (insn))\n \t      {\n \t\tinsn = scan_one_insn (insn, pass);"}, {"sha": "e852d6d321209da64332d627eb5abc325884f171", "filename": "gcc/regs.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a08b260482d8972aaaa3eb2a0175f9cc175dbad9/gcc%2Fregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a08b260482d8972aaaa3eb2a0175f9cc175dbad9/gcc%2Fregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregs.h?ref=a08b260482d8972aaaa3eb2a0175f9cc175dbad9", "patch": "@@ -86,6 +86,24 @@ extern varray_type reg_n_info;\n \n #define REG_FREQ(N) (VARRAY_REG (reg_n_info, N)->freq)\n \n+/* The weights for each insn varries from 0 to REG_FREQ_BASE. \n+   This constant does not need to be high, as in infrequently executed\n+   regions we want to count instructions equivalently to optimize for\n+   size instead of speed.  */\n+#define REG_FREQ_MAX 1000\n+\n+/* Compute register frequency from the BB frequency.  When optimizing for size,\n+   or profile driven feedback is available and the function is never executed,\n+   frequency is always equivalent.  Otherwise rescale the basic block\n+   frequency.  */\n+#define REG_FREQ_FROM_BB(bb) (optimize_size\t\t\t\t      \\\n+\t\t\t      || (flag_branch_probabilities\t\t      \\\n+\t\t\t\t  && !ENTRY_BLOCK_PTR->count)\t\t      \\\n+\t\t\t      ? REG_FREQ_MAX\t\t\t\t      \\\n+\t\t\t      : ((bb)->frequency * REG_FREQ_MAX / BB_FREQ_MAX)\\\n+\t\t\t      ? ((bb)->frequency * REG_FREQ_MAX / BB_FREQ_MAX)\\\n+\t\t\t      : 1)\n+\n /* Indexed by n, gives number of times (REG n) is set.\n    ??? both regscan and flow allocate space for this.  We should settle\n    on just copy.  */"}]}