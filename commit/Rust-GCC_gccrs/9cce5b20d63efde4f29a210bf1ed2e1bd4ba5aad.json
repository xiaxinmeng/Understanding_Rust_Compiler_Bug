{"sha": "9cce5b20d63efde4f29a210bf1ed2e1bd4ba5aad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWNjZTViMjBkNjNlZmRlNGYyOWEyMTBiZjFlZDJlMWJkNGJhNWFhZA==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@codesourcery.com", "date": "2007-09-03T17:48:44Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2007-09-03T17:48:44Z"}, "message": "optabs.c: Remove unnecessary forward declarations.\n\n\t* optabs.c: Remove unnecessary forward declarations.\n\t(expand_unop_direct): New, broken out of expand_unop.\n\t(expand_doubleword_clz): New.\n\t(expand_ctz): Move above expand_ffs.  Use\n\tstart_sequence, end_sequence, add_equal_note, and\n\texpand_unop_direct.  Add more commentary.\n\t(expand_ffs): Try both ctz optab and expand_ctz.\n\tGenerate a test and branch if the hardware doesn't give us\n\ta useful value for input zero.  Style improvements similar to\n\texpand_ctz.\n\n\t* config/arm/arm.md (ffssi2, ctzsi2): Delete.\n\nFrom-SVN: r128054", "tree": {"sha": "378d848d7c6193dbeae09ac28e3515d1b0713664", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/378d848d7c6193dbeae09ac28e3515d1b0713664"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9cce5b20d63efde4f29a210bf1ed2e1bd4ba5aad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cce5b20d63efde4f29a210bf1ed2e1bd4ba5aad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9cce5b20d63efde4f29a210bf1ed2e1bd4ba5aad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cce5b20d63efde4f29a210bf1ed2e1bd4ba5aad/comments", "author": null, "committer": null, "parents": [{"sha": "d46c958bfa0f730f479c317c0a0403a93ef99923", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d46c958bfa0f730f479c317c0a0403a93ef99923", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d46c958bfa0f730f479c317c0a0403a93ef99923"}], "stats": {"total": 382, "additions": 242, "deletions": 140}, "files": [{"sha": "6bbd703aae487a60e0a30bf7e19981178975d3f8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cce5b20d63efde4f29a210bf1ed2e1bd4ba5aad/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cce5b20d63efde4f29a210bf1ed2e1bd4ba5aad/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9cce5b20d63efde4f29a210bf1ed2e1bd4ba5aad", "patch": "@@ -1,3 +1,18 @@\n+2007-09-03  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* optabs.c: Remove unnecessary forward declarations.\n+\t(expand_unop_direct): New, broken out of expand_unop.\n+\t(expand_doubleword_clz): New.\n+\t(expand_ctz): Move above expand_ffs.  Use\n+\tstart_sequence, end_sequence, add_equal_note, and\n+\texpand_unop_direct.  Add more commentary.\n+\t(expand_ffs): Try both ctz optab and expand_ctz.\n+\tGenerate a test and branch if the hardware doesn't give us\n+\ta useful value for input zero.  Style improvements similar to\n+\texpand_ctz.\n+\n+\t* config/arm/arm.md (ffssi2, ctzsi2): Delete.\n+\n 2007-09-03  Zack Weinberg  <zack@codesourcery.com>\n \n \t* config.gcc: Delete stanza for arm-semi-aof and"}, {"sha": "2c753b48be793b5afd307918edb9f0cfaae5e6f6", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cce5b20d63efde4f29a210bf1ed2e1bd4ba5aad/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cce5b20d63efde4f29a210bf1ed2e1bd4ba5aad/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=9cce5b20d63efde4f29a210bf1ed2e1bd4ba5aad", "patch": "@@ -10747,46 +10747,6 @@\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"insn\" \"clz\")])\n \n-(define_expand \"ffssi2\"\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n-\t(ffs:SI (match_operand:SI 1 \"s_register_operand\" \"\")))]\n-  \"TARGET_32BIT && arm_arch5\"\n-  \"\n-  {\n-    rtx t1, t2, t3;\n-\n-    t1 = gen_reg_rtx (SImode);\n-    t2 = gen_reg_rtx (SImode);\n-    t3 = gen_reg_rtx (SImode);\n-\n-    emit_insn (gen_negsi2 (t1, operands[1]));\n-    emit_insn (gen_andsi3 (t2, operands[1], t1));\n-    emit_insn (gen_clzsi2 (t3, t2));\n-    emit_insn (gen_subsi3 (operands[0], GEN_INT (32), t3));\n-    DONE;\n-  }\"\n-)\n-\n-(define_expand \"ctzsi2\"\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n-\t(ctz:SI (match_operand:SI 1 \"s_register_operand\" \"\")))]\n-  \"TARGET_32BIT && arm_arch5\"\n-  \"\n-  {\n-    rtx t1, t2, t3;\n-\n-    t1 = gen_reg_rtx (SImode);\n-    t2 = gen_reg_rtx (SImode);\n-    t3 = gen_reg_rtx (SImode);\n-\n-    emit_insn (gen_negsi2 (t1, operands[1]));\n-    emit_insn (gen_andsi3 (t2, operands[1], t1));\n-    emit_insn (gen_clzsi2 (t3, t2));\n-    emit_insn (gen_subsi3 (operands[0], GEN_INT (31), t3));\n-    DONE;\n-  }\"\n-)\n-\n ;; V5E instructions.\n \n (define_insn \"prefetch\""}, {"sha": "f35685255bbbe8f193980446102341a8e2b9fa35", "filename": "gcc/optabs.c", "status": "modified", "additions": 227, "deletions": 100, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cce5b20d63efde4f29a210bf1ed2e1bd4ba5aad/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cce5b20d63efde4f29a210bf1ed2e1bd4ba5aad/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=9cce5b20d63efde4f29a210bf1ed2e1bd4ba5aad", "patch": "@@ -95,37 +95,9 @@ enum insn_code vcondu_gen_code[NUM_MACHINE_MODES];\n    the code to be used in the trap insn and all other fields are ignored.  */\n static GTY(()) rtx trap_rtx;\n \n-static int add_equal_note (rtx, rtx, enum rtx_code, rtx, rtx);\n-static rtx widen_operand (rtx, enum machine_mode, enum machine_mode, int,\n-\t\t\t  int);\n-static void prepare_cmp_insn (rtx *, rtx *, enum rtx_code *, rtx,\n-\t\t\t      enum machine_mode *, int *,\n-\t\t\t      enum can_compare_purpose);\n-static enum insn_code can_fix_p (enum machine_mode, enum machine_mode, int,\n-\t\t\t\t int *);\n-static enum insn_code can_float_p (enum machine_mode, enum machine_mode, int);\n-static optab new_optab (void);\n-static convert_optab new_convert_optab (void);\n-static inline optab init_optab (enum rtx_code);\n-static inline optab init_optabv (enum rtx_code);\n-static inline convert_optab init_convert_optab (enum rtx_code);\n-static void init_libfuncs (optab, int, int, const char *, int);\n-static void init_integral_libfuncs (optab, const char *, int);\n-static void init_floating_libfuncs (optab, const char *, int);\n-static void init_interclass_conv_libfuncs (convert_optab, const char *,\n-\t\t\t\t\t   enum mode_class, enum mode_class);\n-static void init_intraclass_conv_libfuncs (convert_optab, const char *,\n-\t\t\t\t\t   enum mode_class, bool);\n-static void emit_cmp_and_jump_insn_1 (rtx, rtx, enum machine_mode,\n-\t\t\t\t      enum rtx_code, int, rtx);\n static void prepare_float_lib_cmp (rtx *, rtx *, enum rtx_code *,\n \t\t\t\t   enum machine_mode *, int *);\n-static rtx widen_clz (enum machine_mode, rtx, rtx);\n-static rtx expand_parity (enum machine_mode, rtx, rtx);\n-static rtx expand_ffs (enum machine_mode, rtx, rtx);\n-static rtx expand_ctz (enum machine_mode, rtx, rtx);\n-static enum rtx_code get_rtx_code (enum tree_code, bool);\n-static rtx vector_compare_rtx (tree, bool, enum insn_code);\n+static rtx expand_unop_direct (enum machine_mode, optab, rtx, rtx, int);\n \n /* Current libcall id.  It doesn't matter what these are, as long\n    as they are unique to each libcall that is emitted.  */\n@@ -2500,6 +2472,76 @@ widen_clz (enum machine_mode mode, rtx op0, rtx target)\n   return 0;\n }\n \n+/* Try calculating clz of a double-word quantity as two clz's of word-sized\n+   quantities, choosing which based on whether the high word is nonzero.  */\n+static rtx\n+expand_doubleword_clz (enum machine_mode mode, rtx op0, rtx target)\n+{\n+  rtx xop0 = force_reg (mode, op0);\n+  rtx subhi = gen_highpart (word_mode, xop0);\n+  rtx sublo = gen_lowpart (word_mode, xop0);\n+  rtx hi0_label = gen_label_rtx ();\n+  rtx after_label = gen_label_rtx ();\n+  rtx seq, temp, result;\n+\n+  /* If we were not given a target, use a word_mode register, not a\n+     'mode' register.  The result will fit, and nobody is expecting\n+     anything bigger (the return type of __builtin_clz* is int).  */\n+  if (!target)\n+    target = gen_reg_rtx (word_mode);\n+\n+  /* In any case, write to a word_mode scratch in both branches of the\n+     conditional, so we can ensure there is a single move insn setting\n+     'target' to tag a REG_EQUAL note on.  */\n+  result = gen_reg_rtx (word_mode);\n+\n+  start_sequence ();\n+\n+  /* If the high word is not equal to zero,\n+     then clz of the full value is clz of the high word.  */\n+  emit_cmp_and_jump_insns (subhi, CONST0_RTX (word_mode), EQ, 0,\n+\t\t\t   word_mode, true, hi0_label);\n+\n+  temp = expand_unop_direct (word_mode, clz_optab, subhi, result, true);\n+  if (!temp)\n+    goto fail;\n+\n+  if (temp != result)\n+    convert_move (result, temp, true);\n+\n+  emit_jump_insn (gen_jump (after_label));\n+  emit_barrier ();\n+\n+  /* Else clz of the full value is clz of the low word plus the number\n+     of bits in the high word.  */\n+  emit_label (hi0_label);\n+\n+  temp = expand_unop_direct (word_mode, clz_optab, sublo, 0, true);\n+  if (!temp)\n+    goto fail;\n+  temp = expand_binop (word_mode, add_optab, temp,\n+\t\t       GEN_INT (GET_MODE_BITSIZE (word_mode)),\n+\t\t       result, true, OPTAB_DIRECT);\n+  if (!temp)\n+    goto fail;\n+  if (temp != result)\n+    convert_move (result, temp, true);\n+\n+  emit_label (after_label);\n+  convert_move (target, result, true);\n+\n+  seq = get_insns ();\n+  end_sequence ();\n+\n+  add_equal_note (seq, target, CLZ, xop0, 0);\n+  emit_insn (seq);\n+  return target;\n+\n+ fail:\n+  end_sequence ();\n+  return 0;\n+}\n+\n /* Try calculating\n \t(bswap:narrow x)\n    as\n@@ -2604,65 +2646,130 @@ expand_parity (enum machine_mode mode, rtx op0, rtx target)\n   return 0;\n }\n \n-/* Try calculating ffs(x) using clz(x).  Since the ffs builtin promises\n-   to return zero for a zero value and clz may have an undefined value\n-   in that case, only do this if we know clz returns the right thing so\n-   that we don't have to generate a test and branch.  */\n+/* Try calculating ctz(x) as K - clz(x & -x) ,\n+   where K is GET_MODE_BITSIZE(mode) - 1.\n+\n+   Both __builtin_ctz and __builtin_clz are undefined at zero, so we\n+   don't have to worry about what the hardware does in that case.  (If\n+   the clz instruction produces the usual value at 0, which is K, the\n+   result of this code sequence will be -1; expand_ffs, below, relies\n+   on this.  It might be nice to have it be K instead, for consistency\n+   with the (very few) processors that provide a ctz with a defined\n+   value, but that would take one more instruction, and it would be\n+   less convenient for expand_ffs anyway.  */\n+\n static rtx\n-expand_ffs (enum machine_mode mode, rtx op0, rtx target)\n+expand_ctz (enum machine_mode mode, rtx op0, rtx target)\n {\n-  HOST_WIDE_INT val;\n-  if (clz_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing\n-      && CLZ_DEFINED_VALUE_AT_ZERO (mode, val) == 2\n-      && val == GET_MODE_BITSIZE (mode))\n-    {\n-      rtx last = get_last_insn ();\n-      rtx temp;\n+  rtx seq, temp;\n+  \n+  if (optab_handler (clz_optab, mode)->insn_code == CODE_FOR_nothing)\n+    return 0;\n+  \n+  start_sequence ();\n \n-      temp = expand_unop (mode, neg_optab, op0, NULL_RTX, true);\n-      if (temp)\n-\ttemp = expand_binop (mode, and_optab, op0, temp, NULL_RTX,\n-\t\t\t     true, OPTAB_DIRECT);\n-      if (temp)\n-\ttemp = expand_unop (mode, clz_optab, temp, NULL_RTX, true);\n-      if (temp)\n-\ttemp = expand_binop (mode, sub_optab,\n-\t\t\t     GEN_INT (GET_MODE_BITSIZE (mode)),\n-\t\t\t     temp,\n-\t\t\t     target, true, OPTAB_DIRECT);\n-      if (temp == 0)\n-\tdelete_insns_since (last);\n-      return temp;\n+  temp = expand_unop_direct (mode, neg_optab, op0, NULL_RTX, true);\n+  if (temp)\n+    temp = expand_binop (mode, and_optab, op0, temp, NULL_RTX,\n+\t\t\t true, OPTAB_DIRECT);\n+  if (temp)\n+    temp = expand_unop_direct (mode, clz_optab, temp, NULL_RTX, true);\n+  if (temp)\n+    temp = expand_binop (mode, sub_optab, GEN_INT (GET_MODE_BITSIZE (mode) - 1),\n+\t\t\t temp, target,\n+\t\t\t true, OPTAB_DIRECT);\n+  if (temp == 0)\n+    {\n+      end_sequence ();\n+      return 0;\n     }\n-  return 0;\n+\n+  seq = get_insns ();\n+  end_sequence ();\n+\n+  add_equal_note (seq, temp, CTZ, op0, 0);\n+  emit_insn (seq);\n+  return temp;\n }\n \n-/* We can compute ctz(x) using clz(x) with a similar recipe.  Here the ctz\n-   builtin has an undefined result on zero, just like clz, so we don't have\n-   to do that check.  */\n+\n+/* Try calculating ffs(x) using ctz(x) if we have that instruction, or\n+   else with the sequence used by expand_clz.\n+   \n+   The ffs builtin promises to return zero for a zero value and ctz/clz\n+   may have an undefined value in that case.  If they do not give us a\n+   convenient value, we have to generate a test and branch.  */\n static rtx\n-expand_ctz (enum machine_mode mode, rtx op0, rtx target)\n+expand_ffs (enum machine_mode mode, rtx op0, rtx target)\n {\n-  if (clz_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n+  HOST_WIDE_INT val;\n+  bool defined_at_zero;\n+  rtx temp, seq;\n+\n+  if (optab_handler (ctz_optab, mode)->insn_code != CODE_FOR_nothing)\n     {\n-      rtx last = get_last_insn ();\n-      rtx temp;\n+      start_sequence ();\n \n-      temp = expand_unop (mode, neg_optab, op0, NULL_RTX, true);\n-      if (temp)\n-\ttemp = expand_binop (mode, and_optab, op0, temp, NULL_RTX,\n-\t\t\t     true, OPTAB_DIRECT);\n-      if (temp)\n-\ttemp = expand_unop (mode, clz_optab, temp, NULL_RTX, true);\n-      if (temp)\n-\ttemp = expand_binop (mode, xor_optab, temp,\n-\t\t\t     GEN_INT (GET_MODE_BITSIZE (mode) - 1),\n-\t\t\t     target,\n-\t\t\t     true, OPTAB_DIRECT);\n-      if (temp == 0)\n-\tdelete_insns_since (last);\n-      return temp;\n+      temp = expand_unop_direct (mode, ctz_optab, op0, 0, true);\n+      if (!temp)\n+\tgoto fail;\n+\n+      defined_at_zero = (CTZ_DEFINED_VALUE_AT_ZERO (mode, val) == 2);\n+    }\n+  else if (optab_handler (clz_optab, mode)->insn_code != CODE_FOR_nothing)\n+    {\n+      start_sequence ();\n+      temp = expand_ctz (mode, op0, 0);\n+      if (!temp)\n+\tgoto fail;\n+\n+      if (CLZ_DEFINED_VALUE_AT_ZERO (mode, val) == 2)\n+\t{\n+\t  defined_at_zero = true;\n+\t  val = (GET_MODE_BITSIZE (mode) - 1) - val;\n+\t}\n+    }\n+  else\n+    return 0;\n+\n+  if (defined_at_zero && val == -1)\n+    /* No correction needed at zero.  */;\n+  else \n+    {\n+      /* We don't try to do anything clever with the situation found\n+\t on some processors (eg Alpha) where ctz(0:mode) ==\n+\t bitsize(mode).  If someone can think of a way to send N to -1\n+\t and leave alone all values in the range 0..N-1 (where N is a\n+\t power of two), cheaper than this test-and-branch, please add it.\n+\n+\t The test-and-branch is done after the operation itself, in case\n+\t the operation sets condition codes that can be recycled for this.\n+\t (This is true on i386, for instance.)  */\n+\n+      rtx nonzero_label = gen_label_rtx ();\n+      emit_cmp_and_jump_insns (op0, CONST0_RTX (mode), NE, 0,\n+\t\t\t       mode, true, nonzero_label);\n+\n+      convert_move (temp, GEN_INT (-1), false);\n+      emit_label (nonzero_label);\n     }\n+\n+  /* temp now has a value in the range -1..bitsize-1.  ffs is supposed\n+     to produce a value in the range 0..bitsize.  */\n+  temp = expand_binop (mode, add_optab, temp, GEN_INT (1),\n+\t\t       target, false, OPTAB_DIRECT);\n+  if (!temp)\n+    goto fail;\n+\n+  seq = get_insns ();\n+  end_sequence ();\n+\n+  add_equal_note (seq, temp, FFS, op0, 0);\n+  emit_insn (seq);\n+  return temp;\n+\n+ fail:\n+  end_sequence ();\n   return 0;\n }\n \n@@ -2791,34 +2898,19 @@ expand_absneg_bit (enum rtx_code code, enum machine_mode mode,\n   return target;\n }\n \n-/* Generate code to perform an operation specified by UNOPTAB\n-   on operand OP0, with result having machine-mode MODE.\n-\n-   UNSIGNEDP is for the case where we have to widen the operands\n-   to perform the operation.  It says to use zero-extension.\n-\n-   If TARGET is nonzero, the value\n-   is generated there, if it is convenient to do so.\n-   In all cases an rtx is returned for the locus of the value;\n-   this may or may not be TARGET.  */\n-\n-rtx\n-expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n+/* As expand_unop, but will fail rather than attempt the operation in a\n+   different mode or with a libcall.  */\n+static rtx\n+expand_unop_direct (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n \t     int unsignedp)\n {\n-  enum mode_class class;\n-  enum machine_mode wider_mode;\n-  rtx temp;\n-  rtx last = get_last_insn ();\n-  rtx pat;\n-\n-  class = GET_MODE_CLASS (mode);\n-\n   if (optab_handler (unoptab, mode)->insn_code != CODE_FOR_nothing)\n     {\n       int icode = (int) optab_handler (unoptab, mode)->insn_code;\n       enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n       rtx xop0 = op0;\n+      rtx last = get_last_insn ();\n+      rtx pat, temp;\n \n       if (target)\n \ttemp = target;\n@@ -2854,16 +2946,49 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n       else\n \tdelete_insns_since (last);\n     }\n+  return 0;\n+}\n+\n+/* Generate code to perform an operation specified by UNOPTAB\n+   on operand OP0, with result having machine-mode MODE.\n+\n+   UNSIGNEDP is for the case where we have to widen the operands\n+   to perform the operation.  It says to use zero-extension.\n+\n+   If TARGET is nonzero, the value\n+   is generated there, if it is convenient to do so.\n+   In all cases an rtx is returned for the locus of the value;\n+   this may or may not be TARGET.  */\n+\n+rtx\n+expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n+\t     int unsignedp)\n+{\n+  enum mode_class class = GET_MODE_CLASS (mode);\n+  enum machine_mode wider_mode;\n+  rtx temp;\n+\n+  temp = expand_unop_direct (mode, unoptab, op0, target, unsignedp);\n+  if (temp)\n+    return temp;\n \n   /* It can't be done in this mode.  Can we open-code it in a wider mode?  */\n \n-  /* Widening clz needs special treatment.  */\n+  /* Widening (or narrowing) clz needs special treatment.  */\n   if (unoptab == clz_optab)\n     {\n       temp = widen_clz (mode, op0, target);\n       if (temp)\n \treturn temp;\n-      else\n+\n+      if (GET_MODE_SIZE (mode) == 2 * UNITS_PER_WORD\n+\t  && optab_handler (unoptab, word_mode)->insn_code != CODE_FOR_nothing)\n+\t{\n+\t  temp = expand_doubleword_clz (mode, op0, target);\n+\t  if (temp)\n+\t    return temp;\n+\t}\n+\n \tgoto try_libcall;\n     }\n \n@@ -2893,6 +3018,7 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n \tif (optab_handler (unoptab, wider_mode)->insn_code != CODE_FOR_nothing)\n \t  {\n \t    rtx xop0 = op0;\n+\t    rtx last = get_last_insn ();\n \n \t    /* For certain operations, we need not actually extend\n \t       the narrow operand, as long as we will truncate the\n@@ -3052,6 +3178,7 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n \t      || optab_handler (unoptab, wider_mode)->libfunc)\n \t    {\n \t      rtx xop0 = op0;\n+\t      rtx last = get_last_insn ();\n \n \t      /* For certain operations, we need not actually extend\n \t\t the narrow operand, as long as we will truncate the"}]}