{"sha": "3c3eeea6b28b3566757556769d3a51eda0d31484", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2MzZWVlYTZiMjhiMzU2Njc1NzU1Njc2OWQzYTUxZWRhMGQzMTQ4NA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-05-27T10:21:59Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-05-27T10:21:59Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1095", "tree": {"sha": "dda5260c22a97cb47b329a993f08548f3a119328", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dda5260c22a97cb47b329a993f08548f3a119328"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c3eeea6b28b3566757556769d3a51eda0d31484", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c3eeea6b28b3566757556769d3a51eda0d31484", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c3eeea6b28b3566757556769d3a51eda0d31484", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c3eeea6b28b3566757556769d3a51eda0d31484/comments", "author": null, "committer": null, "parents": [{"sha": "a28528f2668c014b3a86b813902593647e4833eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a28528f2668c014b3a86b813902593647e4833eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a28528f2668c014b3a86b813902593647e4833eb"}], "stats": {"total": 97, "additions": 37, "deletions": 60}, "files": [{"sha": "b9c271063982fd73fd49c5233396490f779629a1", "filename": "gcc/recog.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c3eeea6b28b3566757556769d3a51eda0d31484/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c3eeea6b28b3566757556769d3a51eda0d31484/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=3c3eeea6b28b3566757556769d3a51eda0d31484", "patch": "@@ -1726,6 +1726,8 @@ constrain_operands (insn_code_num, strict)\n \t\tif (strict < 0\n \t\t    || GENERAL_REGS == ALL_REGS\n \t\t    || GET_CODE (op) != REG\n+\t\t    || (reload_in_progress\n+\t\t\t&& REGNO (op) >= FIRST_PSEUDO_REGISTER)\n \t\t    || reg_fits_class_p (op, GENERAL_REGS, offset, mode))\n \t\t  win = 1;\n \t\tbreak;\n@@ -1752,7 +1754,10 @@ constrain_operands (insn_code_num, strict)\n \t      case 'm':\n \t\tif (GET_CODE (op) == MEM\n \t\t    /* Before reload, accept what reload can turn into mem.  */\n-\t\t    || (strict < 0 && CONSTANT_P (op)))\n+\t\t    || (strict < 0 && CONSTANT_P (op))\n+\t\t    /* During reload, accept a pseudo  */\n+\t\t    || (reload_in_progress && GET_CODE (op) == REG\n+\t\t\t&& REGNO (op) >= FIRST_PSEUDO_REGISTER))\n \t\t  win = 1;\n \t\tbreak;\n \n@@ -1845,7 +1850,10 @@ constrain_operands (insn_code_num, strict)\n \t\t    || (strict == 0 && offsettable_nonstrict_memref_p (op))\n \t\t    /* Before reload, accept what reload can handle.  */\n \t\t    || (strict < 0\n-\t\t\t&& (CONSTANT_P (op) || GET_CODE (op) == MEM)))\n+\t\t\t&& (CONSTANT_P (op) || GET_CODE (op) == MEM))\n+\t\t    /* During reload, accept a pseudo  */\n+\t\t    || (reload_in_progress && GET_CODE (op) == REG\n+\t\t\t&& REGNO (op) >= FIRST_PSEUDO_REGISTER))\n \t\t  win = 1;\n \t\tbreak;\n "}, {"sha": "2c28d4c7e7fd96e6e9dbcf123bd63235aa8c56bb", "filename": "gcc/reload1.c", "status": "modified", "additions": 27, "deletions": 58, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c3eeea6b28b3566757556769d3a51eda0d31484/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c3eeea6b28b3566757556769d3a51eda0d31484/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=3c3eeea6b28b3566757556769d3a51eda0d31484", "patch": "@@ -3323,6 +3323,8 @@ reload_as_needed (first, live_known)\n \n \t  if (n_reloads > 0)\n \t    {\n+\t      rtx prev = PREV_INSN (insn), next = NEXT_INSN (insn);\n+\t      rtx p;\n \t      int class;\n \n \t      /* If this block has not had spilling done for a\n@@ -3358,6 +3360,24 @@ reload_as_needed (first, live_known)\n \t\t load and store insn that we just made for reloading\n \t\t and that we moved the structure into).  */\n \t      subst_reloads ();\n+\n+\t      /* If this was an ASM, make sure that all the reload insns\n+\t\t we have generated are valid.  If not, give an error\n+\t\t and delete them.  */\n+\n+\t      if (asm_noperands (PATTERN (insn)) >= 0)\n+\t\tfor (p = NEXT_INSN (prev); p != next; p = NEXT_INSN (p))\n+\t\t  if (p != insn && GET_RTX_CLASS (GET_CODE (p)) == 'i'\n+\t\t      && (recog_memoized (p) < 0\n+\t\t\t  || (insn_extract (p),\n+\t\t\t      ! constrain_operands (INSN_CODE (p), 1))))\n+\t\t    {\n+\t\t      error_for_asm (insn,\n+\t\t\t\t     \"`asm' operand requires impossible reload\");\n+\t\t      PUT_CODE (p, NOTE);\n+\t\t      NOTE_SOURCE_FILE (p) = 0;\n+\t\t      NOTE_LINE_NUMBER (p) = NOTE_INSN_DELETED;\n+\t\t    }\n \t    }\n \t  /* Any previously reloaded spilled pseudo reg, stored in this insn,\n \t     is no longer validly lying around to save a future reload.\n@@ -4485,7 +4505,6 @@ emit_reload_insns (insn)\n   int special;\n   /* Values to be put in spill_reg_store are put here first.  */\n   rtx new_spill_reg_store[FIRST_PSEUDO_REGISTER];\n-  int is_asm = asm_noperands (PATTERN (insn)) >= 0;\n \n   /* If this is a CALL_INSN preceded by USE insns, any reload insns\n      must go in front of the first USE insn, not in front of INSN.  */\n@@ -4857,15 +4876,7 @@ emit_reload_insns (insn)\n \t\t\t    {\n \t\t\t      reload_insn\n \t\t\t\t= gen_input_reload (second_reload_reg,\n-\t\t\t\t\t\t    oldequiv, where, is_asm);\n-\t\t\t      /* If we can't create the reload insn,\n-\t\t\t\t report an error and give up.  */\n-\t\t\t      if (reload_insn == 0)\n-\t\t\t\t{\n-\t\t\t\t  error_for_asm (insn,\n-\t\t\t\t\t\t \"`asm' operand requires impossible reload\");\n-\t\t\t\t  return;\n-\t\t\t\t}\n+\t\t\t\t\t\t    oldequiv);\n \t\t\t      if (this_reload_insn == 0)\n \t\t\t\tthis_reload_insn = reload_insn;\n \t\t\t      oldequiv = second_reload_reg;\n@@ -4877,16 +4888,7 @@ emit_reload_insns (insn)\n \n \t      if (! special)\n \t\t{\n-\t\t  reload_insn = gen_input_reload (reloadreg,\n-\t\t\t\t\t\t  oldequiv, where, is_asm);\n-\t\t  /* If we can't create the reload insn,\n-\t\t     report an error and give up.  */\n-\t\t  if (reload_insn == 0)\n-\t\t    {\n-\t\t      error_for_asm (insn,\n-\t\t\t\t     \"`asm' operand requires impossible reload\");\n-\t\t      return;\n-\t\t    }\n+\t\t  reload_insn = gen_input_reload (reloadreg, oldequiv, where);\n \t\t  if (this_reload_insn == 0)\n \t\t    this_reload_insn = reload_insn;\n \t\t}\n@@ -5402,17 +5404,13 @@ emit_reload_insns (insn)\n }\n \f\n /* Emit code before BEFORE_INSN to perform an input reload of IN to RELOADREG.\n-   Returns first insn emitted.\n-\n-   If IS_ASM, check the emitted insns for validity.\n-   If they are invalid, delete them and return 0.  */\n+   Returns first insn emitted.  */\n \n rtx\n-gen_input_reload (reloadreg, in, before_insn, is_asm)\n+gen_input_reload (reloadreg, in, before_insn)\n      rtx reloadreg;\n      rtx in;\n      rtx before_insn;\n-     int is_asm;\n {\n   register rtx prev_insn = PREV_INSN (before_insn);\n \n@@ -5520,45 +5518,16 @@ gen_input_reload (reloadreg, in, before_insn, is_asm)\n \n   /* If IN is a simple operand, use gen_move_insn.  */\n   else if (GET_RTX_CLASS (GET_CODE (in)) == 'o' || GET_CODE (in) == SUBREG)\n-    {\n-      rtx x = emit_insn_before (gen_move_insn (reloadreg, in), before_insn);\n-      if (is_asm\n-\t  && (recog_memoized (x) < 0\n-\t      || (insn_extract (x), ! constrain_operands (INSN_CODE (x), 1))))\n-\t{\n-\t  delete_insn (x);\n-\t  return 0;\n-\t}\n-    }\n+    emit_insn_before (gen_move_insn (reloadreg, in), before_insn);\n \n #ifdef HAVE_reload_load_address\n   else if (HAVE_reload_load_address)\n-    {\n-      rtx x = emit_insn_before (gen_reload_load_address (reloadreg, in),\n-\t\t\t\tbefore_insn);\n-      if (is_asm\n-\t  && (recog_memoized (x) < 0\n-\t      || (insn_extract (x), ! constrain_operands (INSN_CODE (x), 1))))\n-\t{\n-\t  delete_insn (x);\n-\t  return 0;\n-\t}\n-    }\n+    emit_insn_before (gen_reload_load_address (reloadreg, in), before_insn);\n #endif\n \n   /* Otherwise, just write (set REGLOADREG IN) and hope for the best.  */\n   else\n-    {\n-      rtx x = emit_insn_before (gen_rtx (SET, VOIDmode, reloadreg, in),\n-\t\t\t\tbefore_insn);\n-      if (is_asm\n-\t  && (recog_memoized (x) < 0\n-\t      || (insn_extract (x), ! constrain_operands (INSN_CODE (x), 1))))\n-\t{\n-\t  delete_insn (x);\n-\t  return 0;\n-\t}\n-    }\n+    emit_insn_before (gen_rtx (SET, VOIDmode, reloadreg, in), before_insn);\n \n   /* Return the first insn emitted.\n      We can not just return PREV_INSN (before_insn), because there may have"}]}