{"sha": "afcea85941826a0b9a7aa561bffffa563d3871c4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWZjZWE4NTk0MTgyNmEwYjlhN2FhNTYxYmZmZmZhNTYzZDM4NzFjNA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2008-10-06T07:09:41Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2008-10-06T07:09:41Z"}, "message": "utils.c (can_fold_for_view_convert_p): New predicate.\n\n2008-10-06  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* gcc-interface/utils.c (can_fold_for_view_convert_p): New predicate.\n\t(unchecked_convert): Use it to disable problematic folding with\n\tVIEW_CONVERT_EXPR in the general case.  Always disable it for the\n\tspecial VIEW_CONVERT_EXPR built for integral types and cope with\n\tits addressability issues by preserving the first conversion.\n\nFrom-SVN: r140902", "tree": {"sha": "4fd62f20d78cc99caedb6b31b232a5c7004f099f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4fd62f20d78cc99caedb6b31b232a5c7004f099f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/afcea85941826a0b9a7aa561bffffa563d3871c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afcea85941826a0b9a7aa561bffffa563d3871c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afcea85941826a0b9a7aa561bffffa563d3871c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afcea85941826a0b9a7aa561bffffa563d3871c4/comments", "author": null, "committer": null, "parents": [{"sha": "de27a12c672ace89eec85d195fb9fb6e34488874", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de27a12c672ace89eec85d195fb9fb6e34488874", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de27a12c672ace89eec85d195fb9fb6e34488874"}], "stats": {"total": 172, "additions": 145, "deletions": 27}, "files": [{"sha": "0a7feb0755a63dea9058f8739756fef6805496c9", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afcea85941826a0b9a7aa561bffffa563d3871c4/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afcea85941826a0b9a7aa561bffffa563d3871c4/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=afcea85941826a0b9a7aa561bffffa563d3871c4", "patch": "@@ -1,3 +1,11 @@\n+2008-10-06  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/utils.c (can_fold_for_view_convert_p): New predicate.\n+\t(unchecked_convert): Use it to disable problematic folding with\n+\tVIEW_CONVERT_EXPR in the general case.  Always disable it for the\n+\tspecial VIEW_CONVERT_EXPR built for integral types and cope with\n+\tits addressability issues by preserving the first conversion.\n+\n 2008-10-01  Andreas Schwab  <schwab@suse.de>\n \n \t* system-linux-ppc64.ads: New file."}, {"sha": "d883d533e4635150fecbf572a5e04583202958aa", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 99, "deletions": 26, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afcea85941826a0b9a7aa561bffffa563d3871c4/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afcea85941826a0b9a7aa561bffffa563d3871c4/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=afcea85941826a0b9a7aa561bffffa563d3871c4", "patch": "@@ -4489,8 +4489,72 @@ maybe_unconstrained_array (tree exp)\n   return exp;\n }\n \f\n+/* Return true if EXPR is an expression that can be folded as an operand\n+   of a VIEW_CONVERT_EXPR.  See the head comment of unchecked_convert for\n+   the rationale.  */\n+\n+static bool\n+can_fold_for_view_convert_p (tree expr)\n+{\n+  tree t1, t2;\n+\n+  /* The folder will fold NOP_EXPRs between integral types with the same\n+     precision (in the middle-end's sense).  We cannot allow it if the\n+     types don't have the same precision in the Ada sense as well.  */\n+  if (TREE_CODE (expr) != NOP_EXPR)\n+    return true;\n+\n+  t1 = TREE_TYPE (expr);\n+  t2 = TREE_TYPE (TREE_OPERAND (expr, 0));\n+\n+  /* Defer to the folder for non-integral conversions.  */\n+  if (!(INTEGRAL_TYPE_P (t1) && INTEGRAL_TYPE_P (t2)))\n+    return true;\n+\n+  /* Only fold conversions that preserve both precisions.  */\n+  if (TYPE_PRECISION (t1) == TYPE_PRECISION (t2)\n+      && operand_equal_p (rm_size (t1), rm_size (t2), 0))\n+    return true;\n+\n+  return false;\n+}\n+\n /* Return an expression that does an unchecked conversion of EXPR to TYPE.\n-   If NOTRUNC_P is true, truncation operations should be suppressed.  */\n+   If NOTRUNC_P is true, truncation operations should be suppressed.\n+\n+   Special care is required with (source or target) integral types whose\n+   precision is not equal to their size, to make sure we fetch or assign\n+   the value bits whose location might depend on the endianness, e.g.\n+\n+     Rmsize : constant := 8;\n+     subtype Int is Integer range 0 .. 2 ** Rmsize - 1;\n+\n+     type Bit_Array is array (1 .. Rmsize) of Boolean;\n+     pragma Pack (Bit_Array);\n+\n+     function To_Bit_Array is new Unchecked_Conversion (Int, Bit_Array);\n+\n+     Value : Int := 2#1000_0001#;\n+     Vbits : Bit_Array := To_Bit_Array (Value);\n+\n+   we expect the 8 bits at Vbits'Address to always contain Value, while\n+   their original location depends on the endianness, at Value'Address\n+   on a little-endian architecture but not on a big-endian one.\n+\n+   ??? There is a problematic discrepancy between what is called precision\n+   here (and more generally throughout gigi) for integral types and what is\n+   called precision in the middle-end.  In the former case it's the RM size\n+   as given by TYPE_RM_SIZE (or rm_size) whereas it's TYPE_PRECISION in the\n+   latter case, the hitch being that they are not equal when they matter,\n+   that is when the number of value bits is not equal to the type's size:\n+   TYPE_RM_SIZE does give the number of value bits but TYPE_PRECISION is set\n+   to the size.  The sole exception are BOOLEAN_TYPEs for which both are 1.\n+\n+   The consequence is that gigi must duplicate code bridging the gap between\n+   the type's size and its precision that exists for TYPE_PRECISION in the\n+   middle-end, because the latter knows nothing about TYPE_RM_SIZE, and be\n+   wary of transformations applied in the middle-end based on TYPE_PRECISION\n+   because this value doesn't reflect the actual precision for Ada.  */\n \n tree\n unchecked_convert (tree type, tree expr, bool notrunc_p)\n@@ -4517,14 +4581,10 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n \t       && TYPE_JUSTIFIED_MODULAR_P (etype))))\n       || TREE_CODE (type) == UNCONSTRAINED_ARRAY_TYPE)\n     {\n-      tree rtype = type;\n-      bool final_unchecked = false;\n-\n       if (TREE_CODE (etype) == INTEGER_TYPE\n \t  && TYPE_BIASED_REPRESENTATION_P (etype))\n \t{\n \t  tree ntype = copy_type (etype);\n-\n \t  TYPE_BIASED_REPRESENTATION_P (ntype) = 0;\n \t  TYPE_MAIN_VARIANT (ntype) = ntype;\n \t  expr = build1 (NOP_EXPR, ntype, expr);\n@@ -4533,15 +4593,18 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n       if (TREE_CODE (type) == INTEGER_TYPE\n \t  && TYPE_BIASED_REPRESENTATION_P (type))\n \t{\n-\t  rtype = copy_type (type);\n+\t  tree rtype = copy_type (type);\n \t  TYPE_BIASED_REPRESENTATION_P (rtype) = 0;\n \t  TYPE_MAIN_VARIANT (rtype) = rtype;\n+\t  expr = convert (rtype, expr);\n+\t  expr = build1 (NOP_EXPR, type, expr);\n \t}\n \n-      /* We have another special case: if we are unchecked converting subtype\n-\t into a base type, we need to ensure that VRP doesn't propagate range\n-\t information since this conversion may be done precisely to validate\n-\t that the object is within the range it is supposed to have.  */\n+      /* We have another special case: if we are unchecked converting either\n+\t a subtype or a type with limited range into a base type, we need to\n+\t ensure that VRP doesn't propagate range information because this\n+\t conversion may be done precisely to validate that the object is\n+\t within the range it is supposed to have.  */\n       else if (TREE_CODE (expr) != INTEGER_CST\n \t       && TREE_CODE (type) == INTEGER_TYPE && !TREE_TYPE (type)\n \t       && ((TREE_CODE (etype) == INTEGER_TYPE && TREE_TYPE (etype))\n@@ -4552,26 +4615,34 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n \t     in order not to be deemed an useless type conversion, it must\n \t     be from subtype to base type.\n \n+\t     Therefore we first do the bulk of the conversion to a subtype of\n+\t     the final type.  And this conversion must itself not be deemed\n+\t     useless if the source type is not a subtype because, otherwise,\n+\t     the final VIEW_CONVERT_EXPR will be deemed so as well.  That's\n+\t     why we toggle the unsigned flag in this conversion, which is\n+\t     harmless since the final conversion is only a reinterpretation\n+\t     of the bit pattern.\n+\n \t     ??? This may raise addressability and/or aliasing issues because\n \t     VIEW_CONVERT_EXPR gets gimplified as an lvalue, thus causing the\n \t     address of its operand to be taken if it is deemed addressable\n \t     and not already in GIMPLE form.  */\n-\t  rtype = gnat_type_for_mode (TYPE_MODE (type), TYPE_UNSIGNED (type));\n+\t  tree rtype\n+\t    = gnat_type_for_mode (TYPE_MODE (type), !TYPE_UNSIGNED (etype));\n \t  rtype = copy_type (rtype);\n \t  TYPE_MAIN_VARIANT (rtype) = rtype;\n \t  TREE_TYPE (rtype) = type;\n-\t  final_unchecked = true;\n+\t  expr = convert (rtype, expr);\n+\t  expr = build1 (VIEW_CONVERT_EXPR, type, expr);\n \t}\n \n-      expr = convert (rtype, expr);\n-      if (type != rtype)\n-\texpr = fold_build1 (final_unchecked ? VIEW_CONVERT_EXPR : NOP_EXPR,\n-\t\t\t    type, expr);\n+      else\n+\texpr = convert (type, expr);\n     }\n \n-  /* If we are converting TO an integral type whose precision is not the\n-     same as its size, first unchecked convert to a record that contains\n-     an object of the output type.  Then extract the field. */\n+  /* If we are converting to an integral type whose precision is not equal\n+     to its size, first unchecked convert to a record that contains an\n+     object of the output type.  Then extract the field. */\n   else if (INTEGRAL_TYPE_P (type) && TYPE_RM_SIZE (type)\n \t   && 0 != compare_tree_int (TYPE_RM_SIZE (type),\n \t\t\t\t     GET_MODE_BITSIZE (TYPE_MODE (type))))\n@@ -4587,8 +4658,8 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n       expr = build_component_ref (expr, NULL_TREE, field, 0);\n     }\n \n-  /* Similarly for integral input type whose precision is not equal to its\n-     size.  */\n+  /* Similarly if we are converting from an integral type whose precision\n+     is not equal to its size.  */\n   else if (INTEGRAL_TYPE_P (etype) && TYPE_RM_SIZE (etype)\n       && 0 != compare_tree_int (TYPE_RM_SIZE (etype),\n \t\t\t\tGET_MODE_BITSIZE (TYPE_MODE (etype))))\n@@ -4618,13 +4689,15 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n     {\n       expr = maybe_unconstrained_array (expr);\n       etype = TREE_TYPE (expr);\n-      expr = fold_build1 (VIEW_CONVERT_EXPR, type, expr);\n+      if (can_fold_for_view_convert_p (expr))\n+\texpr = fold_build1 (VIEW_CONVERT_EXPR, type, expr);\n+      else\n+\texpr = build1 (VIEW_CONVERT_EXPR, type, expr);\n     }\n \n-  /* If the result is an integral type whose size is not equal to\n-     the size of the underlying machine type, sign- or zero-extend\n-     the result.  We need not do this in the case where the input is\n-     an integral type of the same precision and signedness or if the output\n+  /* If the result is an integral type whose precision is not equal to its\n+     size, sign- or zero-extend the result.  We need not do this if the input\n+     is an integral type of the same precision and signedness or if the output\n      is a biased type or if both the input and output are unsigned.  */\n   if (!notrunc_p\n       && INTEGRAL_TYPE_P (type) && TYPE_RM_SIZE (type)"}, {"sha": "04f21713e78c6087568b84fdf94dd5afb14c8be5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afcea85941826a0b9a7aa561bffffa563d3871c4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afcea85941826a0b9a7aa561bffffa563d3871c4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=afcea85941826a0b9a7aa561bffffa563d3871c4", "patch": "@@ -1,5 +1,8 @@\n-2008-10-05  Dodji Seketeli  <dodji@redhat.com>\n+2008-10-06  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/unchecked_convert2.adb: New test.\n \n+2008-10-05  Dodji Seketeli  <dodji@redhat.com>\n \n \tPR c++/37410\n \t* g++.dg/debug/dwarf2/imported-module.C: New test."}, {"sha": "f542af7c343e0c391f83658cbc7dd602557da4b1", "filename": "gcc/testsuite/gnat.dg/unchecked_convert2.adb", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afcea85941826a0b9a7aa561bffffa563d3871c4/gcc%2Ftestsuite%2Fgnat.dg%2Funchecked_convert2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afcea85941826a0b9a7aa561bffffa563d3871c4/gcc%2Ftestsuite%2Fgnat.dg%2Funchecked_convert2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Funchecked_convert2.adb?ref=afcea85941826a0b9a7aa561bffffa563d3871c4", "patch": "@@ -0,0 +1,34 @@\n+-- { dg-do run }\n+\n+with Ada.Unchecked_Conversion;\n+with Ada.Streams; use Ada.Streams;\n+with Ada.Text_IO; use Ada.Text_IO;\n+\n+procedure Unchecked_Convert2 is\n+\n+   subtype Day_Number is Integer range 0 .. 31;\n+\n+   subtype Byte_Array_Of_Integer is Stream_Element_Array\n+     (1 .. Integer'Size / Stream_Element_Array'Component_Size);\n+\n+   function To_Byte_Array is\n+      new Ada.Unchecked_Conversion (Integer, Byte_Array_Of_Integer);\n+\n+   Day_Now : Day_Number;\n+   Pragma Volatile (Day_Now);\n+\n+   Arr : Stream_Element_Array (1 .. 12) := (others => 16#ff#);\n+\n+   procedure Test (Arr : Stream_Element_Array) is\n+   begin\n+      if Arr(5) /= 0 or Arr(6) /= 0 or Arr(7) /= 0 or Arr(8) /= 0 then\n+         raise Program_Error;\n+      end if;\n+   end;\n+\n+begin\n+   Day_Now := 0;\n+   Arr (5 .. 8) := To_Byte_Array (Day_Now);\n+   Test (Arr);\n+   Arr (1) := 16#ff#;\n+end Unchecked_Convert2;"}]}