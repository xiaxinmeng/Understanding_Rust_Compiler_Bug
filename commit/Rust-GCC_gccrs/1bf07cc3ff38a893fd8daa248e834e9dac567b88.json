{"sha": "1bf07cc3ff38a893fd8daa248e834e9dac567b88", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWJmMDdjYzNmZjM4YTg5M2ZkOGRhYTI0OGU4MzRlOWRhYzU2N2I4OA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-05-18T18:18:04Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-05-18T18:18:04Z"}, "message": "cp-tree.h (OVL_ARG_DEPENDENT): Delete.\n\n\t* cp-tree.h (OVL_ARG_DEPENDENT): Delete.\n\t(OVL_USED_P): New.\n\t(lookup_keep): Declare.\n\t* name-lookup.c (add_function): Don't set OVL_ARG_DEPENDENT.\n\t* pt.c (tsubst_copy): Assert lookup is persistent.\n\t* semantics.c (finish_call_expr): Use lkp_iterator, call\n\tlookup_keep.\n\t* tree.c (ovl_copy): New.\n\t(ovl_insert, ovl_iterator::remove_node): Copy immutable nodes.\n\t(lookup_keep): New.\n\nFrom-SVN: r248250", "tree": {"sha": "77b3a653555adf1b37e9c52263d8229454df32f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77b3a653555adf1b37e9c52263d8229454df32f6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1bf07cc3ff38a893fd8daa248e834e9dac567b88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bf07cc3ff38a893fd8daa248e834e9dac567b88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1bf07cc3ff38a893fd8daa248e834e9dac567b88", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bf07cc3ff38a893fd8daa248e834e9dac567b88/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7d2f2a6b73fd5022f9f96ffc9e2806c8d7464112", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d2f2a6b73fd5022f9f96ffc9e2806c8d7464112", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d2f2a6b73fd5022f9f96ffc9e2806c8d7464112"}], "stats": {"total": 147, "additions": 111, "deletions": 36}, "files": [{"sha": "e903bfd1d715566d4d6f9af8decaec7985b0caeb", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bf07cc3ff38a893fd8daa248e834e9dac567b88/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bf07cc3ff38a893fd8daa248e834e9dac567b88/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1bf07cc3ff38a893fd8daa248e834e9dac567b88", "patch": "@@ -1,5 +1,16 @@\n 2017-05-18  Nathan Sidwell  <nathan@acm.org>\n \n+\t* cp-tree.h (OVL_ARG_DEPENDENT): Delete.\n+\t(OVL_USED_P): New.\n+\t(lookup_keep): Declare.\n+\t* name-lookup.c (add_function): Don't set OVL_ARG_DEPENDENT.\n+\t* pt.c (tsubst_copy): Assert lookup is persistent.\n+\t* semantics.c (finish_call_expr): Use lkp_iterator, call\n+\tlookup_keep.\n+\t* tree.c (ovl_copy): New.\n+\t(ovl_insert, ovl_iterator::remove_node): Copy immutable nodes.\n+\t(lookup_keep): New.\n+\n \t* cp-tree.h (OVL_USED): Replace with ...\n \t(OVL_USING_P): ... this.\n \t(ovl_iterator::using_p): Adjust."}, {"sha": "82bb965010682c94c9a57cf50278cac29c6be9f5", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bf07cc3ff38a893fd8daa248e834e9dac567b88/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bf07cc3ff38a893fd8daa248e834e9dac567b88/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=1bf07cc3ff38a893fd8daa248e834e9dac567b88", "patch": "@@ -323,7 +323,6 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n       IMPLICIT_CONV_EXPR_DIRECT_INIT (in IMPLICIT_CONV_EXPR)\n       TRANSACTION_EXPR_IS_STMT (in TRANSACTION_EXPR)\n       CONVERT_EXPR_VBASE_PATH (in CONVERT_EXPR)\n-      OVL_ARG_DEPENDENT (in OVERLOAD)\n       PACK_EXPANSION_LOCAL_P (in *_PACK_EXPANSION)\n       TINFO_HAS_ACCESS_ERRORS (in TEMPLATE_INFO)\n       SIZEOF_EXPR_TYPE_P (in SIZEOF_EXPR)\n@@ -641,16 +640,15 @@ typedef struct ptrmem_cst * ptrmem_cst_t;\n   ((TREE_CODE (NODE) == OVERLOAD) ? OVL_FUNCTION (NODE) : (NODE))\n #define OVL_NEXT(NODE)\t\t\\\n   ((TREE_CODE (NODE) == OVERLOAD) ? TREE_CHAIN (NODE) : NULL_TREE)\n-/* If set, this OVERLOAD was created for argument-dependent lookup\n-   and can be freed afterward.  */\n-#define OVL_ARG_DEPENDENT(NODE) TREE_LANG_FLAG_0 (OVERLOAD_CHECK (NODE))\n \n /* If set, this was imported in a using declaration.   */\n #define OVL_USING_P(NODE)\tTREE_LANG_FLAG_1 (OVERLOAD_CHECK (NODE))\n /* If set, this overload contains a nested overload.  */\n #define OVL_NESTED_P(NODE)\tTREE_LANG_FLAG_3 (OVERLOAD_CHECK (NODE))\n /* If set, this overload was constructed during lookup.  */\n #define OVL_LOOKUP_P(NODE)\tTREE_LANG_FLAG_4 (OVERLOAD_CHECK (NODE))\n+/* If set, this is a persistant lookup. */\n+#define OVL_USED_P(NODE)\tTREE_USED (OVERLOAD_CHECK (NODE))\n \n /* The first decl of an overload.  */\n #define OVL_FIRST(NODE)\tovl_first (NODE)\n@@ -6809,6 +6807,7 @@ extern tree ovl_make\t\t\t\t(tree fn,\n extern tree ovl_insert\t\t\t\t(tree fn, tree maybe_ovl,\n \t\t\t\t\t\t bool using_p = false);\n extern tree lookup_add\t\t\t\t(tree fns, tree lookup);\n+extern void lookup_keep\t\t\t\t(tree lookup, bool keep);\n extern int is_overloaded_fn\t\t\t(tree);\n extern tree dependent_name\t\t\t(tree);\n extern tree get_fns\t\t\t\t(tree) ATTRIBUTE_PURE;"}, {"sha": "88a2ee586c7a5e26cbc9465a88e7aa401ab30623", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bf07cc3ff38a893fd8daa248e834e9dac567b88/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bf07cc3ff38a893fd8daa248e834e9dac567b88/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=1bf07cc3ff38a893fd8daa248e834e9dac567b88", "patch": "@@ -159,11 +159,7 @@ add_function (struct arg_lookup *k, tree fn)\n   else if (fn == k->functions)\n     ;\n   else\n-    {\n-      k->functions = lookup_add (fn, k->functions);\n-      if (TREE_CODE (k->functions) == OVERLOAD)\n-\tOVL_ARG_DEPENDENT (k->functions) = true;\n-    }\n+    k->functions = lookup_add (fn, k->functions);\n \n   return false;\n }"}, {"sha": "eef6c0e72dc00c2f0b43251bdaaf2f21501903b8", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bf07cc3ff38a893fd8daa248e834e9dac567b88/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bf07cc3ff38a893fd8daa248e834e9dac567b88/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=1bf07cc3ff38a893fd8daa248e834e9dac567b88", "patch": "@@ -14565,6 +14565,8 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t overload set from function scope will just be represented with an\n \t IDENTIFIER_NODE, and from class scope with a BASELINK.  */\n       gcc_assert (!uses_template_parms (t));\n+      /* We must have marked any lookups as persistent.  */\n+      gcc_assert (!OVL_LOOKUP_P (t) || OVL_USED_P (t));\n       return t;\n \n     case BASELINK:"}, {"sha": "1ba961ec226c2bc94e7b496b499905a619c1a0c6", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 19, "deletions": 24, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bf07cc3ff38a893fd8daa248e834e9dac567b88/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bf07cc3ff38a893fd8daa248e834e9dac567b88/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=1bf07cc3ff38a893fd8daa248e834e9dac567b88", "patch": "@@ -2304,18 +2304,28 @@ finish_call_expr (tree fn, vec<tree, va_gc> **args, bool disallow_virtual,\n \t  result = build_nt_call_vec (fn, *args);\n \t  SET_EXPR_LOCATION (result, EXPR_LOC_OR_LOC (fn, input_location));\n \t  KOENIG_LOOKUP_P (result) = koenig_p;\n+\t  if (is_overloaded_fn (fn))\n+\t    {\n+\t      fn = get_fns (fn);\n+\t      lookup_keep (fn, true);\n+\t    }\n+\n \t  if (cfun)\n \t    {\n-\t      do\n+\t      bool abnormal = true;\n+\t      for (lkp_iterator iter (fn); abnormal && iter; ++iter)\n \t\t{\n-\t\t  tree fndecl = OVL_CURRENT (fn);\n+\t\t  tree fndecl = *iter;\n \t\t  if (TREE_CODE (fndecl) != FUNCTION_DECL\n \t\t      || !TREE_THIS_VOLATILE (fndecl))\n-\t\t    break;\n-\t\t  fn = OVL_NEXT (fn);\n+\t\t    abnormal = false;\n \t\t}\n-\t      while (fn);\n-\t      if (!fn)\n+\t      /* FIXME: Stop warning about falling off end of non-void\n+\t\t function.   But this is wrong.  Even if we only see\n+\t\t no-return fns at this point, we could select a\n+\t\t future-defined return fn during instantiation.  Or\n+\t\t vice-versa.  */\n+\t      if (abnormal)\n \t\tcurrent_function_returns_abnormally = 1;\n \t    }\n \t  return result;\n@@ -2469,24 +2479,9 @@ finish_call_expr (tree fn, vec<tree, va_gc> **args, bool disallow_virtual,\n       result = convert_from_reference (result);\n     }\n \n-  if (koenig_p)\n-    {\n-      /* Free garbage OVERLOADs from arg-dependent lookup.  */\n-      tree next = NULL_TREE;\n-      for (fn = orig_fn;\n-\t   fn && TREE_CODE (fn) == OVERLOAD && OVL_ARG_DEPENDENT (fn);\n-\t   fn = next)\n-\t{\n-\t  if (processing_template_decl)\n-\t    /* In a template, we'll re-use them at instantiation time.  */\n-\t    OVL_ARG_DEPENDENT (fn) = false;\n-\t  else\n-\t    {\n-\t      next = OVL_CHAIN (fn);\n-\t      ggc_free (fn);\n-\t    }\n-\t}\n-    }\n+  /* Free or retain OVERLOADs from lookup.  */\n+  if (is_overloaded_fn (orig_fn))\n+    lookup_keep (get_fns (orig_fn), processing_template_decl);\n \n   return result;\n }"}, {"sha": "e2d02251aa61b2ddcf8067c6a1bce69f132c82b9", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 75, "deletions": 3, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bf07cc3ff38a893fd8daa248e834e9dac567b88/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bf07cc3ff38a893fd8daa248e834e9dac567b88/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=1bf07cc3ff38a893fd8daa248e834e9dac567b88", "patch": "@@ -2124,13 +2124,38 @@ ovl_make (tree fn, tree next)\n   return result;\n }\n \n+static tree\n+ovl_copy (tree ovl)\n+{\n+  tree result = ovl_cache;\n+\n+  if (result)\n+    {\n+      ovl_cache = OVL_FUNCTION (result);\n+      /* Zap the flags.  */\n+      memset (result, 0, sizeof (tree_base));\n+      TREE_SET_CODE (result, OVERLOAD);\n+    }\n+  else\n+    result = make_node (OVERLOAD);\n+\n+  gcc_assert (!OVL_NESTED_P (ovl) && !OVL_LOOKUP_P (ovl));\n+  TREE_TYPE (result) = TREE_TYPE (ovl);\n+  OVL_FUNCTION (result) = OVL_FUNCTION (ovl);\n+  OVL_CHAIN (result) = OVL_CHAIN (ovl);\n+  OVL_USING_P (ovl) = OVL_USING_P (ovl);\n+\n+  return result;\n+}\n+\n /* Add FN to the (potentially NULL) overload set OVL.  USING_P is\n    true, if FN is via a using declaration.  Overloads are ordered as\n    using, regular.  */\n \n tree\n ovl_insert (tree fn, tree maybe_ovl, bool using_p)\n {\n+  bool copying = false; /* Checking use only.  */\n   int weight = using_p;\n \n   tree result = NULL_TREE;\n@@ -2140,6 +2165,15 @@ ovl_insert (tree fn, tree maybe_ovl, bool using_p)\n   while (maybe_ovl && TREE_CODE (maybe_ovl) == OVERLOAD\n \t && (weight < OVL_USING_P (maybe_ovl)))\n     {\n+      gcc_checking_assert (!OVL_LOOKUP_P (maybe_ovl)\n+\t\t\t   && (!OVL_USED_P (maybe_ovl) || !copying));\n+      if (OVL_USED_P (maybe_ovl))\n+\t{\n+\t  copying = true;\n+\t  maybe_ovl = ovl_copy (maybe_ovl);\n+\t  if (insert_after)\n+\t    OVL_CHAIN (insert_after) = maybe_ovl;\n+\t}\n       if (!result)\n \tresult = maybe_ovl;\n       insert_after = maybe_ovl;\n@@ -2156,7 +2190,7 @@ ovl_insert (tree fn, tree maybe_ovl, bool using_p)\n \n   if (insert_after)\n     {\n-      TREE_CHAIN (insert_after) = trail;\n+      OVL_CHAIN (insert_after) = trail;\n       TREE_TYPE (insert_after) = unknown_type_node;\n     }\n   else\n@@ -2165,14 +2199,32 @@ ovl_insert (tree fn, tree maybe_ovl, bool using_p)\n   return result;\n }\n \n-/* NODE is on the overloads of OVL.  Remove it.  */\n+/* NODE is on the overloads of OVL.  Remove it.  If a predecessor is\n+   OVL_USED_P we must copy OVL nodes, because those are immutable.\n+   The removed node is unaltered and may continue to be iterated\n+   from (i.e. it is safe to remove a node from an overload one is\n+   currently iterating over).  */\n \n tree\n ovl_iterator::remove_node (tree overload, tree node)\n {\n+  bool copying = false; /* Checking use only.  */\n+\n   tree *slot = &overload;\n   while (*slot != node)\n-    slot = &OVL_CHAIN (*slot);\n+    {\n+      tree probe = *slot;\n+      gcc_checking_assert (!OVL_LOOKUP_P (probe)\n+\t\t\t   && (!OVL_USED_P (probe) || !copying));\n+      if (OVL_USED_P (probe))\n+\t{\n+\t  copying = true;\n+\t  probe = ovl_copy (probe);\n+\t  *slot = probe;\n+\t}\n+\n+      slot = &OVL_CHAIN (probe);\n+    }\n \n   /* Stitch out NODE.  We don't have to worry about now making a\n      singleton overload (and consequently maybe setting its type),\n@@ -2199,6 +2251,26 @@ lookup_add (tree fns, tree lookup)\n   return lookup;\n }\n \n+/* If KEEP is true, preserve the contents of a lookup so that it is\n+   available for a later instantiation.  Otherwise release the LOOKUP\n+   nodes for reuse.  */\n+\n+void\n+lookup_keep (tree lookup, bool keep)\n+{\n+  for (;\n+       lookup && TREE_CODE (lookup) == OVERLOAD\n+\t && OVL_LOOKUP_P (lookup) && !OVL_USED_P (lookup);\n+       lookup = OVL_CHAIN (lookup))\n+    if (keep)\n+      OVL_USED_P (lookup) = true;\n+    else\n+      {\n+\tOVL_FUNCTION (lookup) = ovl_cache;\n+\tovl_cache = lookup;\n+      }\n+}\n+\n /* Returns nonzero if X is an expression for a (possibly overloaded)\n    function.  If \"f\" is a function or function template, \"f\", \"c->f\",\n    \"c.f\", \"C::f\", and \"f<int>\" will all be considered possibly"}]}