{"sha": "01ce9e31a02c8039d88e90f983735104417bf034", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDFjZTllMzFhMDJjODAzOWQ4OGU5MGY5ODM3MzUxMDQ0MTdiZjAzNA==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2018-10-28T11:05:05Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2018-10-28T11:05:05Z"}, "message": "re PR fortran/54613 ([F08] Add FINDLOC plus support MAXLOC/MINLOC with KIND=/BACK=)\n\n2017-10-28  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/54613\n\t* gfortran.h (gfc_isym_id): Add GFC_ISYM_FINDLOC.\n\t(gfc_check_f): Add f6fl field.\n\t(gfc_simplify_f): Add f6 field.\n\t(gfc_resolve_f): Likewise.\n\t(gfc_type_letter): Add optional logical_equas_int flag.\n\t* check.c (intrinsic_type_check): New function.\n\t(gfc_check_findloc): New function.\n\t* intrinsics.c (gfc_type_letter): If logical_equals_int is\n\tset, act accordingly.\n\t(add_sym_5ml):  Reformat comment.\n\t(add_sym_6fl): New function.\n\t(add_functions): Add findloc.\n\t(check_arglist): Add sixth argument, handle it.\n\t(resolve_intrinsic): Likewise.\n\t(check_specific): Handle findloc.\n\t* intrinsic.h (gfc_check_findloc): Add prototype.\n\t(gfc_simplify_findloc): Likewise.\n\t(gfc_resolve_findloc): Likewise.\n\t(MAX_INTRINSIC_ARGS): Adjust.\n\t* iresolve.c (gfc_resolve_findloc): New function.\n\t* simplify.c (gfc_simplify_minmaxloc): Make static.\n\t(simplify_findloc_to_scalar): New function.\n\t(simplify_findloc_nodim): New function.\n\t(simplify_findloc_to_array): New function.\n\t(gfc_simplify_findloc): New function.\n\t(gfc_conv_intrinsic_findloc): New function.\n\t(gfc_conv_intrinsic_function): Handle GFC_ISYM_FINDLOC.\n\t(gfc_is_intrinsic_libcall): Likewise.\n\n2017-10-28  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/54613\n\t* Makefile.am: Add files for findloc.\n\t* Makefile.in: Regenerated.\n\t* libgfortran.h (gfc_array_index_type): Add.\n\t(gfc_array_s1): Add using GFC_UINTEGER_1.\n\t(gfc_array_s4): Likewise.\n\tReplace unnecessary comment.\n\t(HAVE_GFC_UINTEGER_1): Define.\n\t(HAVE_GFC_UINTEGER_4): Define.\n\t* m4/findloc0.m4: New file.\n\t* m4/findloc0s.m4: New file.\n\t* m4/findloc1.m4: New file.\n\t* m4/findloc1s.m4: New file.\n\t* m4/findloc2s.m4: New file.\n\t* m4/ifindloc0.m4: New file.\n\t* m4/ifindloc1.m4: New file.\n\t* m4/ifindloc2.m4: New file.\n\t* m4/iparm.m4: Use unsigned integer for characters.\n        * generated/findloc0_c16.c: New file.\n        * generated/findloc0_c4.c: New file.\n        * generated/findloc0_c8.c: New file.\n        * generated/findloc0_i1.c: New file.\n        * generated/findloc0_i16.c: New file.\n        * generated/findloc0_i2.c: New file.\n        * generated/findloc0_i4.c: New file.\n        * generated/findloc0_i8.c: New file.\n        * generated/findloc0_r16.c: New file.\n        * generated/findloc0_r4.c: New file.\n        * generated/findloc0_r8.c: New file.\n        * generated/findloc0_s1.c: New file.\n        * generated/findloc0_s4.c: New file.\n        * generated/findloc1_c16.c: New file.\n        * generated/findloc1_c4.c: New file.\n        * generated/findloc1_c8.c: New file.\n        * generated/findloc1_i1.c: New file.\n        * generated/findloc1_i16.c: New file.\n        * generated/findloc1_i2.c: New file.\n        * generated/findloc1_i4.c: New file.\n        * generated/findloc1_i8.c: New file.\n        * generated/findloc1_r16.c: New file.\n        * generated/findloc1_r4.c: New file.\n        * generated/findloc1_r8.c: New file.\n        * generated/findloc1_s1.c: New file.\n        * generated/findloc1_s4.c: New file.\n        * generated/findloc2_s1.c: New file.\n        * generated/findloc2_s4.c: New file.\n        * generated/maxloc0_16_s1.c: Regenerated.\n        * generated/maxloc0_16_s4.c: Regenerated.\n        * generated/maxloc0_4_s1.c: Regenerated.\n        * generated/maxloc0_4_s4.c: Regenerated.\n        * generated/maxloc0_8_s1.c: Regenerated.\n        * generated/maxloc0_8_s4.c: Regenerated.\n        * generated/maxloc1_16_s1.c: Regenerated.\n        * generated/maxloc1_16_s4.c: Regenerated.\n        * generated/maxloc1_4_s1.c: Regenerated.\n        * generated/maxloc1_4_s4.c: Regenerated.\n        * generated/maxloc1_8_s1.c: Regenerated.\n        * generated/maxloc1_8_s4.c: Regenerated.\n        * generated/maxloc2_16_s1.c: Regenerated.\n        * generated/maxloc2_16_s4.c: Regenerated.\n        * generated/maxloc2_4_s1.c: Regenerated.\n        * generated/maxloc2_4_s4.c: Regenerated.\n        * generated/maxloc2_8_s1.c: Regenerated.\n        * generated/maxloc2_8_s4.c: Regenerated.\n        * generated/maxval0_s1.c: Regenerated.\n        * generated/maxval0_s4.c: Regenerated.\n        * generated/maxval1_s1.c: Regenerated.\n        * generated/maxval1_s4.c: Regenerated.\n        * generated/minloc0_16_s1.c: Regenerated.\n        * generated/minloc0_16_s4.c: Regenerated.\n        * generated/minloc0_4_s1.c: Regenerated.\n        * generated/minloc0_4_s4.c: Regenerated.\n        * generated/minloc0_8_s1.c: Regenerated.\n        * generated/minloc0_8_s4.c: Regenerated.\n        * generated/minloc1_16_s1.c: Regenerated.\n        * generated/minloc1_16_s4.c: Regenerated.\n        * generated/minloc1_4_s1.c: Regenerated.\n        * generated/minloc1_4_s4.c: Regenerated.\n        * generated/minloc1_8_s1.c: Regenerated.\n        * generated/minloc1_8_s4.c: Regenerated.\n        * generated/minloc2_16_s1.c: Regenerated.\n        * generated/minloc2_16_s4.c: Regenerated.\n        * generated/minloc2_4_s1.c: Regenerated.\n        * generated/minloc2_4_s4.c: Regenerated.\n        * generated/minloc2_8_s1.c: Regenerated.\n        * generated/minloc2_8_s4.c: Regenerated.\n        * generated/minval0_s1.c: Regenerated.\n        * generated/minval0_s4.c: Regenerated.\n        * generated/minval1_s1.c: Regenerated.\n        * generated/minval1_s4.c: Regenerated.\n\n2017-10-28  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/54613\n\t* gfortran.dg/findloc_1.f90: New test.\n\t* gfortran.dg/findloc_2.f90: New test.\n\t* gfortran.dg/findloc_3.f90: New test.\n\t* gfortran.dg/findloc_4.f90: New test.\n\t* gfortran.dg/findloc_5.f90: New test.\n\t* gfortran.dg/findloc_6.f90: New test.\n\nFrom-SVN: r265570", "tree": {"sha": "186e264d66218f12fbd3d71ace05c275c82f7518", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/186e264d66218f12fbd3d71ace05c275c82f7518"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01ce9e31a02c8039d88e90f983735104417bf034", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01ce9e31a02c8039d88e90f983735104417bf034", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01ce9e31a02c8039d88e90f983735104417bf034", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01ce9e31a02c8039d88e90f983735104417bf034/comments", "author": null, "committer": null, "parents": [{"sha": "b10fb07830939a34f822008d61ed104be40123e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b10fb07830939a34f822008d61ed104be40123e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b10fb07830939a34f822008d61ed104be40123e0"}], "stats": {"total": 15502, "additions": 15071, "deletions": 431}, "files": [{"sha": "b5675d11fa3b5db62ab56da5ff7639779080a7b3", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -1,3 +1,35 @@\n+2017-10-28  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/54613\n+\t* gfortran.h (gfc_isym_id): Add GFC_ISYM_FINDLOC.\n+\t(gfc_check_f): Add f6fl field.\n+\t(gfc_simplify_f): Add f6 field.\n+\t(gfc_resolve_f): Likewise.\n+\t(gfc_type_letter): Add optional logical_equas_int flag.\n+\t* check.c (intrinsic_type_check): New function.\n+\t(gfc_check_findloc): New function.\n+\t* intrinsics.c (gfc_type_letter): If logical_equals_int is\n+\tset, act accordingly.\n+\t(add_sym_5ml):  Reformat comment.\n+\t(add_sym_6fl): New function.\n+\t(add_functions): Add findloc.\n+\t(check_arglist): Add sixth argument, handle it.\n+\t(resolve_intrinsic): Likewise.\n+\t(check_specific): Handle findloc.\n+\t* intrinsic.h (gfc_check_findloc): Add prototype.\n+\t(gfc_simplify_findloc): Likewise.\n+\t(gfc_resolve_findloc): Likewise.\n+\t(MAX_INTRINSIC_ARGS): Adjust.\n+\t* iresolve.c (gfc_resolve_findloc): New function.\n+\t* simplify.c (gfc_simplify_minmaxloc): Make static.\n+\t(simplify_findloc_to_scalar): New function.\n+\t(simplify_findloc_nodim): New function.\n+\t(simplify_findloc_to_array): New function.\n+\t(gfc_simplify_findloc): New function.\n+\t(gfc_conv_intrinsic_findloc): New function.\n+\t(gfc_conv_intrinsic_function): Handle GFC_ISYM_FINDLOC.\n+\t(gfc_is_intrinsic_libcall): Likewise.\n+\n 2018-10-27  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/86907"}, {"sha": "43b07132e0ed2c132ee6ddc05ec918a5b0f9a5f6", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -148,6 +148,21 @@ int_or_real_or_char_check_f2003 (gfc_expr *e, int n)\n   return true;\n }\n \n+/* Check that an expression is an intrinsic type.  */\n+static bool\n+intrinsic_type_check (gfc_expr *e, int n)\n+{\n+  if (e->ts.type != BT_INTEGER && e->ts.type != BT_REAL\n+      && e->ts.type != BT_COMPLEX && e->ts.type != BT_CHARACTER\n+      && e->ts.type != BT_LOGICAL)\n+    {\n+      gfc_error (\"%qs argument of %qs intrinsic at %L must be of intrinsic type\",\n+\t\t gfc_current_intrinsic_arg[n]->name,\n+\t\t gfc_current_intrinsic, &e->where);\n+      return false;\n+    }\n+  return true;\n+}\n \n /* Check that an expression is real or complex.  */\n \n@@ -3345,6 +3360,82 @@ gfc_check_minloc_maxloc (gfc_actual_arglist *ap)\n   return true;\n }\n \n+/* Check function for findloc.  Mostly like gfc_check_minloc_maxloc\n+   above, with the additional \"value\" argument.  */\n+\n+bool\n+gfc_check_findloc (gfc_actual_arglist *ap)\n+{\n+  gfc_expr *a, *v, *m, *d, *k, *b;\n+\n+  a = ap->expr;\n+  if (!intrinsic_type_check (a, 0) || !array_check (a, 0))\n+    return false;\n+\n+  v = ap->next->expr;\n+  if (!scalar_check (v,1))\n+    return false;\n+\n+  /* Check if the type is compatible.  */\n+\n+  if ((a->ts.type == BT_LOGICAL && v->ts.type != BT_LOGICAL)\n+      || (a->ts.type != BT_LOGICAL && v->ts.type == BT_LOGICAL))\n+    {\n+      gfc_error (\"Argument %qs of %qs intrinsic at %L must be in type \"\n+\t\t \"conformance to argument %qs at %L\",\n+\t\t gfc_current_intrinsic_arg[0]->name,\n+\t\t gfc_current_intrinsic, &a->where,\n+\t\t gfc_current_intrinsic_arg[1]->name, &v->where);\n+    }\n+\t \n+  d = ap->next->next->expr;\n+  m = ap->next->next->next->expr;\n+  k = ap->next->next->next->next->expr;\n+  b = ap->next->next->next->next->next->expr;\n+\n+  if (b)\n+    {\n+      if (!type_check (b, 5, BT_LOGICAL) || !scalar_check (b,4))\n+\treturn false;\n+    }\n+  else\n+    {\n+      b = gfc_get_logical_expr (gfc_logical_4_kind, NULL, 0);\n+      ap->next->next->next->next->next->expr = b;\n+    }\n+\n+  if (m == NULL && d != NULL && d->ts.type == BT_LOGICAL\n+      && ap->next->name == NULL)\n+    {\n+      m = d;\n+      d = NULL;\n+      ap->next->next->expr = NULL;\n+      ap->next->next->next->expr = m;\n+    }\n+\n+  if (!dim_check (d, 2, false))\n+    return false;\n+\n+  if (!dim_rank_check (d, a, 0))\n+    return false;\n+\n+  if (m != NULL && !type_check (m, 3, BT_LOGICAL))\n+    return false;\n+\n+  if (m != NULL\n+      && !gfc_check_conformance (a, m,\n+\t\t\t\t \"arguments '%s' and '%s' for intrinsic %s\",\n+\t\t\t\t gfc_current_intrinsic_arg[0]->name,\n+\t\t\t\t gfc_current_intrinsic_arg[3]->name,\n+\t\t\t\t gfc_current_intrinsic))\n+    return false;\n+\n+  if (!kind_check (k, 1, BT_INTEGER))\n+    return false;\n+\n+  return true;\n+}\n+\n \n /* Similar to minloc/maxloc, the argument list might need to be\n    reordered for the MINVAL, MAXVAL, PRODUCT, and SUM intrinsics.  The"}, {"sha": "f68204f1ed8aee5de1e6aac663c5ea5b2cff95b5", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -2509,6 +2509,13 @@ check_transformational (gfc_expr *e)\n     \"trim\", \"unpack\", NULL\n   };\n \n+  static const char * const trans_func_f2008[] =  {\n+    \"all\", \"any\", \"count\", \"dot_product\", \"matmul\", \"null\", \"pack\",\n+    \"product\", \"repeat\", \"reshape\", \"selected_char_kind\", \"selected_int_kind\",\n+    \"selected_real_kind\", \"spread\", \"sum\", \"transfer\", \"transpose\",\n+    \"trim\", \"unpack\", \"findloc\", NULL\n+  };\n+\n   int i;\n   const char *name;\n   const char *const *functions;\n@@ -2519,8 +2526,12 @@ check_transformational (gfc_expr *e)\n \n   name = e->symtree->n.sym->name;\n \n-  functions = (gfc_option.allow_std & GFC_STD_F2003)\n-\t\t? trans_func_f2003 : trans_func_f95;\n+  if (gfc_option.allow_std & GFC_STD_F2008)\n+    functions = trans_func_f2008;\n+  else if (gfc_option.allow_std & GFC_STD_F2003)\n+    functions = trans_func_f2003;\n+  else\n+    functions = trans_func_f95;\n \n   /* NULL() is dealt with below.  */\n   if (strcmp (\"null\", name) == 0)"}, {"sha": "4a8d3602d72908720c746e88c7b63d4667260c3e", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -437,6 +437,7 @@ enum gfc_isym_id\n   GFC_ISYM_FE_RUNTIME_ERROR,\n   GFC_ISYM_FGET,\n   GFC_ISYM_FGETC,\n+  GFC_ISYM_FINDLOC,\n   GFC_ISYM_FLOOR,\n   GFC_ISYM_FLUSH,\n   GFC_ISYM_FNUM,\n@@ -2001,6 +2002,7 @@ typedef union\n   bool (*f2)(struct gfc_expr *, struct gfc_expr *);\n   bool (*f3)(struct gfc_expr *, struct gfc_expr *, struct gfc_expr *);\n   bool (*f5ml)(gfc_actual_arglist *);\n+  bool (*f6fl)(gfc_actual_arglist *);\n   bool (*f3red)(gfc_actual_arglist *);\n   bool (*f4)(struct gfc_expr *, struct gfc_expr *, struct gfc_expr *,\n \t    struct gfc_expr *);\n@@ -2025,6 +2027,9 @@ typedef union\n   struct gfc_expr *(*f5)(struct gfc_expr *, struct gfc_expr *,\n \t\t\t struct gfc_expr *, struct gfc_expr *,\n \t\t\t struct gfc_expr *);\n+  struct gfc_expr *(*f6)(struct gfc_expr *, struct gfc_expr *,\n+\t\t\t struct gfc_expr *, struct gfc_expr *,\n+\t\t\t struct gfc_expr *, struct gfc_expr *);\n   struct gfc_expr *(*cc)(struct gfc_expr *, bt, int);\n }\n gfc_simplify_f;\n@@ -2045,6 +2050,9 @@ typedef union\n \t     struct gfc_expr *, struct gfc_expr *);\n   void (*f5)(struct gfc_expr *, struct gfc_expr *, struct gfc_expr *,\n \t     struct gfc_expr *, struct gfc_expr *, struct gfc_expr *);\n+  void (*f6)(struct gfc_expr *, struct gfc_expr *, struct gfc_expr *,\n+\t     struct gfc_expr *, struct gfc_expr *, struct gfc_expr *,\n+\t     struct gfc_expr *);\n   void (*s1)(struct gfc_code *);\n }\n gfc_resolve_f;\n@@ -2149,6 +2157,11 @@ typedef struct gfc_expr\n \n   unsigned int external_blas : 1;\n \n+  /* Set this if resolution has already happened. It could be harmful\n+     if done again.  */\n+\n+  unsigned int do_not_resolve_again : 1;\n+\n   /* If an expression comes from a Hollerith constant or compile-time\n      evaluation of a transfer statement, it may have a prescribed target-\n      memory representation, and these cannot always be backformed from\n@@ -3094,7 +3107,7 @@ extern bool gfc_init_expr_flag;\n void gfc_intrinsic_init_1 (void);\n void gfc_intrinsic_done_1 (void);\n \n-char gfc_type_letter (bt);\n+char gfc_type_letter (bt, bool logical_equals_int = false);\n gfc_symbol * gfc_get_intrinsic_sub_symbol (const char *);\n bool gfc_convert_type (gfc_expr *, gfc_typespec *, int);\n bool gfc_convert_type_warn (gfc_expr *, gfc_typespec *, int, int);"}, {"sha": "17978c14d93903b48c2285f4bf12ea2d25dc5d7d", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 81, "deletions": 10, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -60,17 +60,22 @@ enum klass\n \n \n /* Return a letter based on the passed type.  Used to construct the\n-   name of a type-dependent subroutine.  */\n+   name of a type-dependent subroutine.  If logical_equals_int is\n+   true, we can treat a logical like an int.  */\n \n char\n-gfc_type_letter (bt type)\n+gfc_type_letter (bt type, bool logical_equals_int)\n {\n   char c;\n \n   switch (type)\n     {\n     case BT_LOGICAL:\n-      c = 'l';\n+      if (logical_equals_int)\n+\tc = 'i';\n+      else\n+\tc = 'l';\n+\n       break;\n     case BT_CHARACTER:\n       c = 's';\n@@ -683,8 +688,8 @@ add_sym_3 (const char *name, gfc_isym_id id, enum klass cl, int actual_ok, bt ty\n }\n \n \n-/* MINLOC and MAXLOC get special treatment because their argument\n-   might have to be reordered.  */\n+/* MINLOC and MAXLOC get special treatment because their\n+   argument might have to be reordered.  */\n \n static void\n add_sym_5ml (const char *name, gfc_isym_id id, enum klass cl, int actual_ok, bt type,\n@@ -717,6 +722,42 @@ add_sym_5ml (const char *name, gfc_isym_id id, enum klass cl, int actual_ok, bt\n \t   (void *) 0);\n }\n \n+/* Similar for FINDLOC.  */\n+\n+static void\n+add_sym_6fl (const char *name, gfc_isym_id id, enum klass cl, int actual_ok,\n+\t     bt type, int kind, int standard,\n+\t     bool (*check) (gfc_actual_arglist *),\n+\t     gfc_expr *(*simplify) (gfc_expr *, gfc_expr *, gfc_expr *,\n+\t\t\t\t    gfc_expr *, gfc_expr *, gfc_expr *),\n+\t     void (*resolve) (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *,\n+\t\t\t      gfc_expr *, gfc_expr *, gfc_expr *),\n+\t     const char *a1, bt type1, int kind1, int optional1,\n+\t     const char *a2, bt type2, int kind2, int optional2,\n+\t     const char *a3, bt type3, int kind3, int optional3,\n+\t     const char *a4, bt type4, int kind4, int optional4,\n+\t     const char *a5, bt type5, int kind5, int optional5,\n+\t     const char *a6, bt type6, int kind6, int optional6)\n+\n+{\n+  gfc_check_f cf;\n+  gfc_simplify_f sf;\n+  gfc_resolve_f rf;\n+\n+  cf.f6fl = check;\n+  sf.f6 = simplify;\n+  rf.f6 = resolve;\n+\n+  add_sym (name, id, cl, actual_ok, type, kind, standard, cf, sf, rf,\n+\t   a1, type1, kind1, optional1, INTENT_IN,\n+\t   a2, type2, kind2, optional2, INTENT_IN,\n+\t   a3, type3, kind3, optional3, INTENT_IN,\n+\t   a4, type4, kind4, optional4, INTENT_IN,\n+\t   a5, type5, kind5, optional5, INTENT_IN,\n+\t   a6, type6, kind6, optional6, INTENT_IN,\n+\t   (void *) 0);\n+}\n+\n \n /* MINVAL, MAXVAL, PRODUCT, and SUM also get special treatment because\n    their argument also might have to be reordered.  */\n@@ -1248,7 +1289,8 @@ add_functions (void)\n     *sta = \"string_a\", *stb = \"string_b\", *stg = \"string\",\n     *sub = \"sub\", *sz = \"size\", *tg = \"target\", *team = \"team\", *tm = \"time\",\n     *ts = \"tsource\", *ut = \"unit\", *v = \"vector\", *va = \"vector_a\",\n-    *vb = \"vector_b\", *vl = \"values\", *x = \"x\", *y = \"y\", *z = \"z\";\n+    *vb = \"vector_b\", *vl = \"values\", *val = \"value\", *x = \"x\", *y = \"y\",\n+    *z = \"z\";\n \n   int di, dr, dd, dl, dc, dz, ii;\n \n@@ -2476,6 +2518,15 @@ add_functions (void)\n \n   make_generic (\"maxloc\", GFC_ISYM_MAXLOC, GFC_STD_F95);\n \n+  add_sym_6fl (\"findloc\", GFC_ISYM_FINDLOC, CLASS_TRANSFORMATIONAL, ACTUAL_NO,\n+\t       BT_INTEGER, di, GFC_STD_F2008,\n+\t       gfc_check_findloc, gfc_simplify_findloc, gfc_resolve_findloc,\n+\t       ar, BT_REAL, dr, REQUIRED, val, BT_REAL, dr, REQUIRED,\n+\t       dm, BT_INTEGER, ii, OPTIONAL, msk, BT_LOGICAL, dl, OPTIONAL,\n+\t       kind, BT_INTEGER, di, OPTIONAL, bck, BT_LOGICAL, dl, OPTIONAL);\n+\n+  make_generic (\"findloc\", GFC_ISYM_FINDLOC, GFC_STD_F2008);\n+\n   add_sym_3red (\"maxval\", GFC_ISYM_MAXVAL, CLASS_TRANSFORMATIONAL, ACTUAL_NO, BT_REAL, dr, GFC_STD_F95,\n \t\tgfc_check_minval_maxval, gfc_simplify_maxval, gfc_resolve_maxval,\n \t\tar, BT_REAL, dr, REQUIRED, dm, BT_INTEGER, ii, OPTIONAL,\n@@ -4279,7 +4330,7 @@ check_arglist (gfc_actual_arglist **ap, gfc_intrinsic_sym *sym,\n static void\n resolve_intrinsic (gfc_intrinsic_sym *specific, gfc_expr *e)\n {\n-  gfc_expr *a1, *a2, *a3, *a4, *a5;\n+  gfc_expr *a1, *a2, *a3, *a4, *a5, *a6;\n   gfc_actual_arglist *arg;\n \n   if (specific->resolve.f1 == NULL)\n@@ -4353,6 +4404,15 @@ resolve_intrinsic (gfc_intrinsic_sym *specific, gfc_expr *e)\n       return;\n     }\n \n+  a6 = arg->expr;\n+  arg = arg->next;\n+\n+  if (arg == NULL)\n+    {\n+      (*specific->resolve.f6) (e, a1, a2, a3, a4, a5, a6);\n+      return;\n+    }\n+\n   gfc_internal_error (\"resolve_intrinsic(): Too many args for intrinsic\");\n }\n \n@@ -4366,7 +4426,7 @@ resolve_intrinsic (gfc_intrinsic_sym *specific, gfc_expr *e)\n static bool\n do_simplify (gfc_intrinsic_sym *specific, gfc_expr *e)\n {\n-  gfc_expr *result, *a1, *a2, *a3, *a4, *a5;\n+  gfc_expr *result, *a1, *a2, *a3, *a4, *a5, *a6;\n   gfc_actual_arglist *arg;\n \n   /* Max and min require special handling due to the variable number\n@@ -4447,8 +4507,17 @@ do_simplify (gfc_intrinsic_sym *specific, gfc_expr *e)\n \t\t  if (arg == NULL)\n \t\t    result = (*specific->simplify.f5) (a1, a2, a3, a4, a5);\n \t\t  else\n-\t\t    gfc_internal_error\n-\t\t      (\"do_simplify(): Too many args for intrinsic\");\n+\t\t    {\n+\t\t      a6 = arg->expr;\n+\t\t      arg = arg->next;\n+\n+\t\t      if (arg == NULL)\n+\t\t\tresult = (*specific->simplify.f6)\n+\t\t       \t\t\t(a1, a2, a3, a4, a5, a6);\n+\t\t      else\n+\t\t\tgfc_internal_error\n+\t\t\t  (\"do_simplify(): Too many args for intrinsic\");\n+\t\t    }\n \t\t}\n \t    }\n \t}\n@@ -4528,6 +4597,8 @@ check_specific (gfc_intrinsic_sym *specific, gfc_expr *expr, int error_flag)\n   if (specific->check.f5ml == gfc_check_minloc_maxloc)\n     /* This is special because we might have to reorder the argument list.  */\n     t = gfc_check_minloc_maxloc (*ap);\n+  else if (specific->check.f6fl == gfc_check_findloc)\n+    t = gfc_check_findloc (*ap);\n   else if (specific->check.f3red == gfc_check_minval_maxval)\n     /* This is also special because we also might have to reorder the\n        argument list.  */"}, {"sha": "fe30e11c1009931103e152ecb4e8f2e230d644e5", "filename": "gcc/fortran/intrinsic.h", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/gcc%2Ffortran%2Fintrinsic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/gcc%2Ffortran%2Fintrinsic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.h?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -74,6 +74,7 @@ bool gfc_check_event_query (gfc_expr *, gfc_expr *, gfc_expr *);\n bool gfc_check_failed_or_stopped_images (gfc_expr *, gfc_expr *);\n bool gfc_check_fgetputc (gfc_expr *, gfc_expr *);\n bool gfc_check_fgetput (gfc_expr *);\n+bool gfc_check_findloc (gfc_actual_arglist *);\n bool gfc_check_float (gfc_expr *);\n bool gfc_check_fstat (gfc_expr *, gfc_expr *);\n bool gfc_check_ftell (gfc_expr *);\n@@ -299,6 +300,8 @@ gfc_expr *gfc_simplify_exp (gfc_expr *);\n gfc_expr *gfc_simplify_exponent (gfc_expr *);\n gfc_expr *gfc_simplify_extends_type_of (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_failed_or_stopped_images (gfc_expr *, gfc_expr *);\n+gfc_expr *gfc_simplify_findloc (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *,\n+\t\t\t\tgfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_float (gfc_expr *);\n gfc_expr *gfc_simplify_floor (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_fraction (gfc_expr *);\n@@ -488,6 +491,8 @@ void gfc_resolve_exponent (gfc_expr *, gfc_expr *);\n void gfc_resolve_extends_type_of (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_failed_images (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_fdate (gfc_expr *);\n+void gfc_resolve_findloc (gfc_expr *,gfc_expr *, gfc_expr *, gfc_expr *,\n+\t\t\t  gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_floor (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_fnum (gfc_expr *, gfc_expr *);\n void gfc_resolve_fraction (gfc_expr *, gfc_expr *);\n@@ -670,9 +675,9 @@ void gfc_resolve_umask_sub (gfc_code *);\n void gfc_resolve_unlink_sub (gfc_code *);\n \n \n-/* The mvbits() subroutine requires the most arguments: five.  */\n+/* The findloc() subroutine requires the most arguments: six.  */\n \n-#define MAX_INTRINSIC_ARGS 5\n+#define MAX_INTRINSIC_ARGS 6\n \n extern const char *gfc_current_intrinsic;\n extern gfc_intrinsic_arg *gfc_current_intrinsic_arg[MAX_INTRINSIC_ARGS];"}, {"sha": "3331fb7965f75563988a6cc32365ceb6d8170d9b", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -1783,6 +1783,115 @@ gfc_resolve_maxloc (gfc_expr *f, gfc_expr *array, gfc_expr *dim,\n }\n \n \n+void\n+gfc_resolve_findloc (gfc_expr *f, gfc_expr *array, gfc_expr *value,\n+\t\t     gfc_expr *dim, gfc_expr *mask, gfc_expr *kind,\n+\t\t     gfc_expr *back)\n+{\n+  const char *name;\n+  int i, j, idim;\n+  int fkind;\n+  int d_num;\n+\n+  /* See at the end of the function for why this is necessary.  */\n+\n+  if (f->do_not_resolve_again)\n+    return;\n+\n+  f->ts.type = BT_INTEGER;\n+\n+  /* We have a single library version, which uses index_type.  */\n+\n+  if (kind)\n+    fkind = mpz_get_si (kind->value.integer);\n+  else\n+    fkind = gfc_default_integer_kind;\n+\n+  f->ts.kind = gfc_index_integer_kind;\n+\n+  /* Convert value.  If array is not LOGICAL and value is, we already\n+     issued an error earlier.  */\n+\n+  if ((array->ts.type != value->ts.type && value->ts.type != BT_LOGICAL)\n+      || array->ts.kind != value->ts.kind)\n+    gfc_convert_type_warn (value, &array->ts, 2, 0);\n+\n+  if (dim == NULL)\n+    {\n+      f->rank = 1;\n+      f->shape = gfc_get_shape (1);\n+      mpz_init_set_si (f->shape[0], array->rank);\n+    }\n+  else\n+    {\n+      f->rank = array->rank - 1;\n+      gfc_resolve_dim_arg (dim);\n+      if (array->shape && dim->expr_type == EXPR_CONSTANT)\n+\t{\n+\t  idim = (int) mpz_get_si (dim->value.integer);\n+\t  f->shape = gfc_get_shape (f->rank);\n+\t  for (i = 0, j = 0; i < f->rank; i++, j++)\n+\t    {\n+\t      if (i == (idim - 1))\n+\t\tj++;\n+\t      mpz_init_set (f->shape[i], array->shape[j]);\n+\t    }\n+\t}\n+    }\n+\n+  if (mask)\n+    {\n+      if (mask->rank == 0)\n+\tname = \"sfindloc\";\n+      else\n+\tname = \"mfindloc\";\n+\n+      resolve_mask_arg (mask);\n+    }\n+  else\n+    name = \"findloc\";\n+\n+  if (dim)\n+    {\n+      if (f->rank > 0)\n+\td_num = 1;\n+      else\n+\td_num = 2;\n+    }\n+  else\n+    d_num = 0;\n+\n+  if (back->ts.kind != gfc_logical_4_kind)\n+    {\n+      gfc_typespec ts;\n+      gfc_clear_ts (&ts);\n+      ts.type = BT_LOGICAL;\n+      ts.kind = gfc_logical_4_kind;\n+      gfc_convert_type_warn (back, &ts, 2, 0);\n+    }\n+\n+  f->value.function.name\n+    = gfc_get_string (PREFIX (\"%s%d_%c%d\"), name, d_num,\n+\t\t      gfc_type_letter (array->ts.type, true), array->ts.kind);\n+\n+  /* We only have a single library function, so we need to convert\n+     here.  If the function is resolved from within a convert\n+     function generated on a previous round of resolution, endless\n+     recursion could occur.  Guard against that here.  */\n+\n+  if (f->ts.kind != fkind)\n+    {\n+      f->do_not_resolve_again = 1;\n+      gfc_typespec ts;\n+      gfc_clear_ts (&ts);\n+\n+      ts.type = BT_INTEGER;\n+      ts.kind = fkind;\n+      gfc_convert_type_warn (f, &ts, 2, 0);\n+    }\n+\n+}\n+\n void\n gfc_resolve_maxval (gfc_expr *f, gfc_expr *array, gfc_expr *dim,\n \t\t    gfc_expr *mask)"}, {"sha": "3939d26a9a709b9fe39184038a745b23645627b4", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 353, "deletions": 1, "changes": 354, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -5372,7 +5372,7 @@ simplify_minmaxloc_to_array (gfc_expr *result, gfc_expr *array,\n \n /* Simplify minloc and maxloc for constant arrays.  */\n \n-gfc_expr *\n+static gfc_expr *\n gfc_simplify_minmaxloc (gfc_expr *array, gfc_expr *dim, gfc_expr *mask,\n \t\t\tgfc_expr *kind, gfc_expr *back, int sign)\n {\n@@ -5452,6 +5452,358 @@ gfc_simplify_maxloc (gfc_expr *array, gfc_expr *dim, gfc_expr *mask, gfc_expr *k\n   return gfc_simplify_minmaxloc (array, dim, mask, kind, back, 1);\n }\n \n+/* Simplify findloc to scalar.  Similar to\n+   simplify_minmaxloc_to_scalar.  */\n+\n+static gfc_expr *\n+simplify_findloc_to_scalar (gfc_expr *result, gfc_expr *array, gfc_expr *value,\n+\t\t\t    gfc_expr *mask, int back_val)\n+{\n+  gfc_expr *a, *m;\n+  gfc_constructor *array_ctor, *mask_ctor;\n+  mpz_t count;\n+\n+  mpz_set_si (result->value.integer, 0);\n+\n+  /* Shortcut for constant .FALSE. MASK.  */\n+  if (mask\n+      && mask->expr_type == EXPR_CONSTANT\n+      && !mask->value.logical)\n+    return result;\n+\n+  array_ctor = gfc_constructor_first (array->value.constructor);\n+  if (mask && mask->expr_type == EXPR_ARRAY)\n+    mask_ctor = gfc_constructor_first (mask->value.constructor);\n+  else\n+    mask_ctor = NULL;\n+\n+  mpz_init_set_si (count, 0);\n+  while (array_ctor)\n+    {\n+      mpz_add_ui (count, count, 1);\n+      a = array_ctor->expr;\n+      array_ctor = gfc_constructor_next (array_ctor);\n+      /* A constant MASK equals .TRUE. here and can be ignored.  */\n+      if (mask_ctor)\n+\t{\n+\t  m = mask_ctor->expr;\n+\t  mask_ctor = gfc_constructor_next (mask_ctor);\n+\t  if (!m->value.logical)\n+\t    continue;\n+\t}\n+      if (gfc_compare_expr (a, value, INTRINSIC_EQ) == 0)\n+\t{\n+\t  /* We have a match.  If BACK is true, continue so we find\n+\t     the last one.  */\n+\t  mpz_set (result->value.integer, count);\n+\t  if (!back_val)\n+\t    break;\n+\t}\n+    }\n+  mpz_clear (count);\n+  return result;\n+}\n+\n+/* Simplify findloc in the absence of a dim argument.  Similar to\n+   simplify_minmaxloc_nodim.  */\n+\n+static gfc_expr *\n+simplify_findloc_nodim (gfc_expr *result, gfc_expr *value, gfc_expr *array,\n+\t\t\tgfc_expr *mask, bool back_val)\n+{\n+  ssize_t res[GFC_MAX_DIMENSIONS];\n+  int i, n;\n+  gfc_constructor *result_ctor, *array_ctor, *mask_ctor;\n+  ssize_t count[GFC_MAX_DIMENSIONS], extent[GFC_MAX_DIMENSIONS],\n+    sstride[GFC_MAX_DIMENSIONS];\n+  gfc_expr *a, *m;\n+  bool continue_loop;\n+  bool ma;\n+\n+  for (i = 0; i<array->rank; i++)\n+    res[i] = -1;\n+\n+  /* Shortcut for constant .FALSE. MASK.  */\n+  if (mask\n+      && mask->expr_type == EXPR_CONSTANT\n+      && !mask->value.logical)\n+    goto finish;\n+\n+  for (i = 0; i < array->rank; i++)\n+    {\n+      count[i] = 0;\n+      sstride[i] = (i == 0) ? 1 : sstride[i-1] * mpz_get_si (array->shape[i-1]);\n+      extent[i] = mpz_get_si (array->shape[i]);\n+      if (extent[i] <= 0)\n+\tgoto finish;\n+    }\n+\n+  continue_loop = true;\n+  array_ctor = gfc_constructor_first (array->value.constructor);\n+  if (mask && mask->rank > 0)\n+    mask_ctor = gfc_constructor_first (mask->value.constructor);\n+  else\n+    mask_ctor = NULL;\n+\n+  /* Loop over the array elements (and mask), keeping track of\n+     the indices to return.  */\n+  while (continue_loop)\n+    {\n+      do\n+\t{\n+\t  a = array_ctor->expr;\n+\t  if (mask_ctor)\n+\t    {\n+\t      m = mask_ctor->expr;\n+\t      ma = m->value.logical;\n+\t      mask_ctor = gfc_constructor_next (mask_ctor);\n+\t    }\n+\t  else\n+\t    ma = true;\n+\n+\t  if (ma && gfc_compare_expr (a, value, INTRINSIC_EQ) == 0)\n+\t    {\n+\t      for (i = 0; i<array->rank; i++)\n+\t\tres[i] = count[i];\n+\t      if (!back_val)\n+\t\tgoto finish;\n+\t    }\n+\t  array_ctor = gfc_constructor_next (array_ctor);\n+\t  count[0] ++;\n+\t} while (count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  n++;\n+\t  if (n >= array->rank)\n+\t    {\n+\t      continue_loop = false;\n+\t      break;\n+\t    }\n+\t  else\n+\t    count[n] ++;\n+\t} while (count[n] == extent[n]);\n+    }\n+\n+ finish:\n+  result_ctor = gfc_constructor_first (result->value.constructor);\n+  for (i = 0; i<array->rank; i++)\n+    {\n+      gfc_expr *r_expr;\n+      r_expr = result_ctor->expr;\n+      mpz_set_si (r_expr->value.integer, res[i] + 1);\n+      result_ctor = gfc_constructor_next (result_ctor);\n+    }\n+  return result;\n+}\n+\n+\n+/* Simplify findloc to an array.  Similar to\n+   simplify_minmaxloc_to_array.  */\n+\n+static gfc_expr *\n+simplify_findloc_to_array (gfc_expr *result, gfc_expr *array, gfc_expr *value,\n+\t\t\t   gfc_expr *dim, gfc_expr *mask, bool back_val)\n+{\n+  mpz_t size;\n+  int done, i, n, arraysize, resultsize, dim_index, dim_extent, dim_stride;\n+  gfc_expr **arrayvec, **resultvec, **base, **src, **dest;\n+  gfc_constructor *array_ctor, *mask_ctor, *result_ctor;\n+\n+  int count[GFC_MAX_DIMENSIONS], extent[GFC_MAX_DIMENSIONS],\n+      sstride[GFC_MAX_DIMENSIONS], dstride[GFC_MAX_DIMENSIONS],\n+      tmpstride[GFC_MAX_DIMENSIONS];\n+\n+  /* Shortcut for constant .FALSE. MASK.  */\n+  if (mask\n+      && mask->expr_type == EXPR_CONSTANT\n+      && !mask->value.logical)\n+    return result;\n+\n+  /* Build an indexed table for array element expressions to minimize\n+     linked-list traversal. Masked elements are set to NULL.  */\n+  gfc_array_size (array, &size);\n+  arraysize = mpz_get_ui (size);\n+  mpz_clear (size);\n+\n+  arrayvec = XCNEWVEC (gfc_expr*, arraysize);\n+\n+  array_ctor = gfc_constructor_first (array->value.constructor);\n+  mask_ctor = NULL;\n+  if (mask && mask->expr_type == EXPR_ARRAY)\n+    mask_ctor = gfc_constructor_first (mask->value.constructor);\n+\n+  for (i = 0; i < arraysize; ++i)\n+    {\n+      arrayvec[i] = array_ctor->expr;\n+      array_ctor = gfc_constructor_next (array_ctor);\n+\n+      if (mask_ctor)\n+\t{\n+\t  if (!mask_ctor->expr->value.logical)\n+\t    arrayvec[i] = NULL;\n+\n+\t  mask_ctor = gfc_constructor_next (mask_ctor);\n+\t}\n+    }\n+\n+  /* Same for the result expression.  */\n+  gfc_array_size (result, &size);\n+  resultsize = mpz_get_ui (size);\n+  mpz_clear (size);\n+\n+  resultvec = XCNEWVEC (gfc_expr*, resultsize);\n+  result_ctor = gfc_constructor_first (result->value.constructor);\n+  for (i = 0; i < resultsize; ++i)\n+    {\n+      resultvec[i] = result_ctor->expr;\n+      result_ctor = gfc_constructor_next (result_ctor);\n+    }\n+\n+  gfc_extract_int (dim, &dim_index);\n+\n+  dim_index -= 1;\t/* Zero-base index.  */\n+  dim_extent = 0;\n+  dim_stride = 0;\n+\n+  for (i = 0, n = 0; i < array->rank; ++i)\n+    {\n+      count[i] = 0;\n+      tmpstride[i] = (i == 0) ? 1 : tmpstride[i-1] * mpz_get_si (array->shape[i-1]);\n+      if (i == dim_index)\n+\t{\n+\t  dim_extent = mpz_get_si (array->shape[i]);\n+\t  dim_stride = tmpstride[i];\n+\t  continue;\n+\t}\n+\n+      extent[n] = mpz_get_si (array->shape[i]);\n+      sstride[n] = tmpstride[i];\n+      dstride[n] = (n == 0) ? 1 : dstride[n-1] * extent[n-1];\n+      n += 1;\n+    }\n+\n+  done = resultsize <= 0;\n+  base = arrayvec;\n+  dest = resultvec;\n+  while (!done)\n+    {\n+      for (src = base, n = 0; n < dim_extent; src += dim_stride, ++n)\n+\t{\n+\t  if (*src && gfc_compare_expr (*src, value, INTRINSIC_EQ) == 0)\n+\t    {\n+\t      mpz_set_si ((*dest)->value.integer, n + 1);\n+\t      if (!back_val)\n+\t\tbreak;\n+\t    }\n+\t}\n+\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+\n+      n = 0;\n+      while (!done && count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\n+\t  n++;\n+\t  if (n < result->rank)\n+\t    {\n+\t      /* If the nested loop is unrolled GFC_MAX_DIMENSIONS\n+\t\t times, we'd warn for the last iteration, because the\n+\t\t array index will have already been incremented to the\n+\t\t array sizes, and we can't tell that this must make\n+\t\t the test against result->rank false, because ranks\n+\t\t must not exceed GFC_MAX_DIMENSIONS.  */\n+\t      GCC_DIAGNOSTIC_PUSH_IGNORED (-Warray-bounds)\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t      GCC_DIAGNOSTIC_POP\n+\t    }\n+\t  else\n+\t    done = true;\n+       }\n+    }\n+\n+  /* Place updated expression in result constructor.  */\n+  result_ctor = gfc_constructor_first (result->value.constructor);\n+  for (i = 0; i < resultsize; ++i)\n+    {\n+      result_ctor->expr = resultvec[i];\n+      result_ctor = gfc_constructor_next (result_ctor);\n+    }\n+\n+  free (arrayvec);\n+  free (resultvec);\n+  return result;\n+}\n+\n+/* Simplify findloc.  */\n+\n+gfc_expr *\n+gfc_simplify_findloc (gfc_expr *array, gfc_expr *value, gfc_expr *dim,\n+\t\t      gfc_expr *mask, gfc_expr *kind, gfc_expr *back)\n+{\n+  gfc_expr *result;\n+  int ikind;\n+  bool back_val = false;\n+\n+  if (!is_constant_array_expr (array)\n+      || !gfc_is_constant_expr (dim))\n+    return NULL;\n+\n+  if (! gfc_is_constant_expr (value))\n+    return 0;\n+\n+  if (mask\n+      && !is_constant_array_expr (mask)\n+      && mask->expr_type != EXPR_CONSTANT)\n+    return NULL;\n+\n+  if (kind)\n+    {\n+      if (gfc_extract_int (kind, &ikind, -1))\n+\treturn NULL;\n+    }\n+  else\n+    ikind = gfc_default_integer_kind;\n+\n+  if (back)\n+    {\n+      if (back->expr_type != EXPR_CONSTANT)\n+\treturn NULL;\n+\n+      back_val = back->value.logical;\n+    }\n+\n+  if (dim)\n+    {\n+      result = transformational_result (array, dim, BT_INTEGER,\n+\t\t\t\t\tikind, &array->where);\n+      init_result_expr (result, 0, array);\n+\n+      if (array->rank == 1)\n+\treturn simplify_findloc_to_scalar (result, array, value, mask,\n+\t\t\t\t\t   back_val);\n+      else\n+\treturn simplify_findloc_to_array (result, array, value, dim, mask,\n+      \t\t\t\t\t  back_val);\n+    }\n+  else\n+    {\n+      result = new_array (BT_INTEGER, ikind, array->rank, &array->where);\n+      return simplify_findloc_nodim (result, value, array, mask, back_val);\n+    }\n+  return NULL;\n+}\n+\n gfc_expr *\n gfc_simplify_maxexponent (gfc_expr *x)\n {"}, {"sha": "4ae2b3252b55130ce2918945dc8bdeb98c1f5e14", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 222, "deletions": 0, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -5177,6 +5177,219 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, enum tree_code op)\n   se->expr = convert (type, pos);\n }\n \n+/* Emit code for findloc.  */\n+\n+static void\n+gfc_conv_intrinsic_findloc (gfc_se *se, gfc_expr *expr)\n+{\n+  gfc_actual_arglist *array_arg, *value_arg, *dim_arg, *mask_arg,\n+    *kind_arg, *back_arg;\n+  gfc_expr *value_expr;\n+  int ikind;\n+  tree resvar;\n+  stmtblock_t block;\n+  stmtblock_t body;\n+  stmtblock_t loopblock;\n+  tree type;\n+  tree tmp;\n+  tree found;\n+  tree forward_branch;\n+  tree back_branch;\n+  gfc_loopinfo loop;\n+  gfc_ss *arrayss;\n+  gfc_ss *maskss;\n+  gfc_se arrayse;\n+  gfc_se valuese;\n+  gfc_se maskse;\n+  gfc_se backse;\n+  tree exit_label;\n+  gfc_expr *maskexpr;\n+  tree offset;\n+  int i;\n+\n+  array_arg = expr->value.function.actual;\n+  value_arg = array_arg->next;\n+  dim_arg   = value_arg->next;\n+  mask_arg  = dim_arg->next;\n+  kind_arg  = mask_arg->next;\n+  back_arg  = kind_arg->next;\n+\n+  /* Remove kind and set ikind.  */\n+  if (kind_arg->expr)\n+    {\n+      ikind = mpz_get_si (kind_arg->expr->value.integer);\n+      gfc_free_expr (kind_arg->expr);\n+      kind_arg->expr = NULL;\n+    }\n+  else\n+    ikind = gfc_default_integer_kind;\n+\n+  value_expr = value_arg->expr;\n+\n+  /* Unless it's a string, pass VALUE by value.  */\n+  if (value_expr->ts.type != BT_CHARACTER)\n+    value_arg->name = \"%VAL\";\n+\n+  /* Pass BACK argument by value.  */\n+  back_arg->name = \"%VAL\";\n+\n+  /* Call the library if we have a character function or if\n+     rank > 0.  */\n+  if (se->ss || array_arg->expr->ts.type == BT_CHARACTER)\n+    {\n+      se->ignore_optional = 1;\n+      if (expr->rank == 0)\n+\t{\n+\t  /* Remove dim argument.  */\n+\t  gfc_free_expr (dim_arg->expr);\n+\t  dim_arg->expr = NULL;\n+\t}\n+      gfc_conv_intrinsic_funcall (se, expr);\n+      return;\n+    }\n+\n+  type = gfc_get_int_type (ikind);\n+\n+  /* Initialize the result.  */\n+  resvar = gfc_create_var (gfc_array_index_type, \"pos\");\n+  gfc_add_modify (&se->pre, resvar, build_int_cst (gfc_array_index_type, 0));\n+  offset = gfc_create_var (gfc_array_index_type, \"offset\");\n+\n+  maskexpr = mask_arg->expr;\n+\n+  /*  Generate two loops, one for BACK=.true. and one for BACK=.false.  */\n+\n+  for (i = 0 ; i < 2; i++)\n+    {\n+      /* Walk the arguments.  */\n+      arrayss = gfc_walk_expr (array_arg->expr);\n+      gcc_assert (arrayss != gfc_ss_terminator);\n+\n+      if (maskexpr && maskexpr->rank != 0)\n+\t{\n+\t  maskss = gfc_walk_expr (maskexpr);\n+\t  gcc_assert (maskss != gfc_ss_terminator);\n+\t}\n+      else\n+\tmaskss = NULL;\n+\n+      /* Initialize the scalarizer.  */\n+      gfc_init_loopinfo (&loop);\n+      exit_label = gfc_build_label_decl (NULL_TREE);\n+      TREE_USED (exit_label) = 1;\n+      gfc_add_ss_to_loop (&loop, arrayss);\n+      if (maskss)\n+\tgfc_add_ss_to_loop (&loop, maskss);\n+\n+      /* Initialize the loop.  */\n+      gfc_conv_ss_startstride (&loop);\n+      gfc_conv_loop_setup (&loop, &expr->where);\n+\n+      /* Calculate the offset.  */\n+      tmp = fold_build2_loc (input_location, MINUS_EXPR, gfc_array_index_type,\n+\t\t\t     gfc_index_one_node, loop.from[0]);\n+      gfc_add_modify (&loop.pre, offset, tmp);\n+\n+      gfc_mark_ss_chain_used (arrayss, 1);\n+      if (maskss)\n+\tgfc_mark_ss_chain_used (maskss, 1);\n+\n+      /* The first loop is for BACK=.true.  */\n+      if (i == 0)\n+\tloop.reverse[0] = GFC_REVERSE_SET;\n+\n+      /* Generate the loop body.  */\n+      gfc_start_scalarized_body (&loop, &body);\n+\n+      /* If we have an array mask, only add the element if it is\n+\t set.  */\n+      if (maskss)\n+\t{\n+\t  gfc_init_se (&maskse, NULL);\n+\t  gfc_copy_loopinfo_to_se (&maskse, &loop);\n+\t  maskse.ss = maskss;\n+\t  gfc_conv_expr_val (&maskse, maskexpr);\n+\t  gfc_add_block_to_block (&body, &maskse.pre);\n+\t}\n+\n+      /* If the condition matches then set the return value.  */\n+      gfc_start_block (&block);\n+\n+      /* Add the offset.  */\n+      tmp = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t     TREE_TYPE (resvar),\n+\t\t\t     loop.loopvar[0], offset);\n+      gfc_add_modify (&block, resvar, tmp);\n+      /* And break out of the loop.  */\n+      tmp = build1_v (GOTO_EXPR, exit_label);\n+      gfc_add_expr_to_block (&block, tmp);\n+\n+      found = gfc_finish_block (&block);\n+\n+      /* Check this element.  */\n+      gfc_init_se (&arrayse, NULL);\n+      gfc_copy_loopinfo_to_se (&arrayse, &loop);\n+      arrayse.ss = arrayss;\n+      gfc_conv_expr_val (&arrayse, array_arg->expr);\n+      gfc_add_block_to_block (&body, &arrayse.pre);\n+\n+      gfc_init_se (&valuese, NULL);\n+      gfc_conv_expr_val (&valuese, value_arg->expr);\n+      gfc_add_block_to_block (&body, &valuese.pre);\n+\n+      tmp = fold_build2_loc (input_location, EQ_EXPR, logical_type_node,\n+\t\t\t     arrayse.expr, valuese.expr);\n+\n+      tmp = build3_v (COND_EXPR, tmp, found, build_empty_stmt (input_location));\n+      if (maskss)\n+\ttmp = build3_v (COND_EXPR, maskse.expr, tmp,\n+\t\t\tbuild_empty_stmt (input_location));\n+\n+      gfc_add_expr_to_block (&body, tmp);\n+      gfc_add_block_to_block (&body, &arrayse.post);\n+\n+      gfc_trans_scalarizing_loops (&loop, &body);\n+\n+      /* Add the exit label.  */\n+      tmp = build1_v (LABEL_EXPR, exit_label);\n+      gfc_add_expr_to_block (&loop.pre, tmp);\n+      gfc_start_block (&loopblock);\n+      gfc_add_block_to_block (&loopblock, &loop.pre);\n+      gfc_add_block_to_block (&loopblock, &loop.post);\n+      if (i == 0)\n+\tforward_branch = gfc_finish_block (&loopblock);\n+      else\n+\tback_branch = gfc_finish_block (&loopblock);\n+\n+      gfc_cleanup_loop (&loop);\n+    }\n+\n+  /* Enclose the two loops in an IF statement.  */\n+\n+  gfc_init_se (&backse, NULL);\n+  gfc_conv_expr_val (&backse, back_arg->expr);\n+  gfc_add_block_to_block (&se->pre, &backse.pre);\n+  tmp = build3_v (COND_EXPR, backse.expr, forward_branch, back_branch);\n+\n+  /* For a scalar mask, enclose the loop in an if statement.  */\n+  if (maskexpr && maskss == NULL)\n+    {\n+      tree if_stmt;\n+      gfc_init_se (&maskse, NULL);\n+      gfc_conv_expr_val (&maskse, maskexpr);\n+      gfc_init_block (&block);\n+      gfc_add_expr_to_block (&block, maskse.expr);\n+      if_stmt = build3_v (COND_EXPR, maskse.expr, tmp,\n+\t\t\t  build_empty_stmt (input_location));\n+      gfc_add_expr_to_block (&block, if_stmt);\n+      tmp = gfc_finish_block (&block);\n+    }\n+\n+  gfc_add_expr_to_block (&se->pre, tmp);\n+  se->expr = convert (type, resvar);\n+\n+}\n+\n /* Emit code for minval or maxval intrinsic.  There are many different cases\n    we need to handle.  For performance reasons we sometimes create two\n    loops instead of one, where the second one is much simpler.\n@@ -9015,6 +9228,10 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n \t      conv_generic_with_optional_char_arg (se, expr, 1, 3);\n \t      break;\n \n+\t    case GFC_ISYM_FINDLOC:\n+\t      gfc_conv_intrinsic_findloc (se, expr);\n+\t      break;\n+\n \t    case GFC_ISYM_MINLOC:\n \t      gfc_conv_intrinsic_minmaxloc (se, expr, LT_EXPR);\n \t      break;\n@@ -9454,6 +9671,10 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n       gfc_conv_intrinsic_minmaxloc (se, expr, GT_EXPR);\n       break;\n \n+    case GFC_ISYM_FINDLOC:\n+      gfc_conv_intrinsic_findloc (se, expr);\n+      break;\n+\n     case GFC_ISYM_MAXVAL:\n       gfc_conv_intrinsic_minmaxval (se, expr, GT_EXPR);\n       break;\n@@ -9933,6 +10154,7 @@ gfc_is_intrinsic_libcall (gfc_expr * expr)\n     case GFC_ISYM_ALL:\n     case GFC_ISYM_ANY:\n     case GFC_ISYM_COUNT:\n+    case GFC_ISYM_FINDLOC:\n     case GFC_ISYM_JN2:\n     case GFC_ISYM_IANY:\n     case GFC_ISYM_IALL:"}, {"sha": "5188d9bf62a752b6961736bfacd2f7eb277ccccd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -1,3 +1,13 @@\n+2017-10-28  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/54613\n+\t* gfortran.dg/findloc_1.f90: New test.\n+\t* gfortran.dg/findloc_2.f90: New test.\n+\t* gfortran.dg/findloc_3.f90: New test.\n+\t* gfortran.dg/findloc_4.f90: New test.\n+\t* gfortran.dg/findloc_5.f90: New test.\n+\t* gfortran.dg/findloc_6.f90: New test.\n+\n 2018-10-26  Bill Schmidt  <wschmidt@linux.ibm.com>\n             Jinsong Ji  <jji@us.ibm.com>\n "}, {"sha": "9242b7a3a3b6bd5e4ad38ece7c29fb36fbc67aaa", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -1,3 +1,96 @@\n+2017-10-28  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/54613\n+\t* Makefile.am: Add files for findloc.\n+\t* Makefile.in: Regenerated.\n+\t* libgfortran.h (gfc_array_index_type): Add.\n+\t(gfc_array_s1): Add using GFC_UINTEGER_1.\n+\t(gfc_array_s4): Likewise.\n+\tReplace unnecessary comment.\n+\t(HAVE_GFC_UINTEGER_1): Define.\n+\t(HAVE_GFC_UINTEGER_4): Define.\n+\t* m4/findloc0.m4: New file.\n+\t* m4/findloc0s.m4: New file.\n+\t* m4/findloc1.m4: New file.\n+\t* m4/findloc1s.m4: New file.\n+\t* m4/findloc2s.m4: New file.\n+\t* m4/ifindloc0.m4: New file.\n+\t* m4/ifindloc1.m4: New file.\n+\t* m4/ifindloc2.m4: New file.\n+\t* m4/iparm.m4: Use unsigned integer for characters.\n+        * generated/findloc0_c16.c: New file.\n+        * generated/findloc0_c4.c: New file.\n+        * generated/findloc0_c8.c: New file.\n+        * generated/findloc0_i1.c: New file.\n+        * generated/findloc0_i16.c: New file.\n+        * generated/findloc0_i2.c: New file.\n+        * generated/findloc0_i4.c: New file.\n+        * generated/findloc0_i8.c: New file.\n+        * generated/findloc0_r16.c: New file.\n+        * generated/findloc0_r4.c: New file.\n+        * generated/findloc0_r8.c: New file.\n+        * generated/findloc0_s1.c: New file.\n+        * generated/findloc0_s4.c: New file.\n+        * generated/findloc1_c16.c: New file.\n+        * generated/findloc1_c4.c: New file.\n+        * generated/findloc1_c8.c: New file.\n+        * generated/findloc1_i1.c: New file.\n+        * generated/findloc1_i16.c: New file.\n+        * generated/findloc1_i2.c: New file.\n+        * generated/findloc1_i4.c: New file.\n+        * generated/findloc1_i8.c: New file.\n+        * generated/findloc1_r16.c: New file.\n+        * generated/findloc1_r4.c: New file.\n+        * generated/findloc1_r8.c: New file.\n+        * generated/findloc1_s1.c: New file.\n+        * generated/findloc1_s4.c: New file.\n+        * generated/findloc2_s1.c: New file.\n+        * generated/findloc2_s4.c: New file.\n+        * generated/maxloc0_16_s1.c: Regenerated.\n+        * generated/maxloc0_16_s4.c: Regenerated.\n+        * generated/maxloc0_4_s1.c: Regenerated.\n+        * generated/maxloc0_4_s4.c: Regenerated.\n+        * generated/maxloc0_8_s1.c: Regenerated.\n+        * generated/maxloc0_8_s4.c: Regenerated.\n+        * generated/maxloc1_16_s1.c: Regenerated.\n+        * generated/maxloc1_16_s4.c: Regenerated.\n+        * generated/maxloc1_4_s1.c: Regenerated.\n+        * generated/maxloc1_4_s4.c: Regenerated.\n+        * generated/maxloc1_8_s1.c: Regenerated.\n+        * generated/maxloc1_8_s4.c: Regenerated.\n+        * generated/maxloc2_16_s1.c: Regenerated.\n+        * generated/maxloc2_16_s4.c: Regenerated.\n+        * generated/maxloc2_4_s1.c: Regenerated.\n+        * generated/maxloc2_4_s4.c: Regenerated.\n+        * generated/maxloc2_8_s1.c: Regenerated.\n+        * generated/maxloc2_8_s4.c: Regenerated.\n+        * generated/maxval0_s1.c: Regenerated.\n+        * generated/maxval0_s4.c: Regenerated.\n+        * generated/maxval1_s1.c: Regenerated.\n+        * generated/maxval1_s4.c: Regenerated.\n+        * generated/minloc0_16_s1.c: Regenerated.\n+        * generated/minloc0_16_s4.c: Regenerated.\n+        * generated/minloc0_4_s1.c: Regenerated.\n+        * generated/minloc0_4_s4.c: Regenerated.\n+        * generated/minloc0_8_s1.c: Regenerated.\n+        * generated/minloc0_8_s4.c: Regenerated.\n+        * generated/minloc1_16_s1.c: Regenerated.\n+        * generated/minloc1_16_s4.c: Regenerated.\n+        * generated/minloc1_4_s1.c: Regenerated.\n+        * generated/minloc1_4_s4.c: Regenerated.\n+        * generated/minloc1_8_s1.c: Regenerated.\n+        * generated/minloc1_8_s4.c: Regenerated.\n+        * generated/minloc2_16_s1.c: Regenerated.\n+        * generated/minloc2_16_s4.c: Regenerated.\n+        * generated/minloc2_4_s1.c: Regenerated.\n+        * generated/minloc2_4_s4.c: Regenerated.\n+        * generated/minloc2_8_s1.c: Regenerated.\n+        * generated/minloc2_8_s4.c: Regenerated.\n+        * generated/minval0_s1.c: Regenerated.\n+        * generated/minval0_s4.c: Regenerated.\n+        * generated/minval1_s1.c: Regenerated.\n+        * generated/minval1_s4.c: Regenerated.\n+\n 2018-10-06  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \t* io/unix.c (compare_file_filename): Use gfc_charlen_type instead"}, {"sha": "7ade1bb6aa83fae39e5e8a0aa671e1122db858e7", "filename": "libgfortran/Makefile.am", "status": "modified", "additions": 62, "deletions": 2, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.am?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -266,6 +266,44 @@ $(srcdir)/generated/iparity_i4.c \\\n $(srcdir)/generated/iparity_i8.c \\\n $(srcdir)/generated/iparity_i16.c\n \n+i_findloc0_c= \\\n+$(srcdir)/generated/findloc0_i1.c \\\n+$(srcdir)/generated/findloc0_i2.c \\\n+$(srcdir)/generated/findloc0_i4.c \\\n+$(srcdir)/generated/findloc0_i8.c \\\n+$(srcdir)/generated/findloc0_i16.c \\\n+$(srcdir)/generated/findloc0_r4.c \\\n+$(srcdir)/generated/findloc0_r8.c \\\n+$(srcdir)/generated/findloc0_r16.c \\\n+$(srcdir)/generated/findloc0_c4.c \\\n+$(srcdir)/generated/findloc0_c8.c \\\n+$(srcdir)/generated/findloc0_c16.c\n+\n+i_findloc0s_c= \\\n+$(srcdir)/generated/findloc0_s1.c \\\n+$(srcdir)/generated/findloc0_s4.c\n+\n+i_findloc1_c= \\\n+$(srcdir)/generated/findloc1_i1.c \\\n+$(srcdir)/generated/findloc1_i2.c \\\n+$(srcdir)/generated/findloc1_i4.c \\\n+$(srcdir)/generated/findloc1_i8.c \\\n+$(srcdir)/generated/findloc1_i16.c \\\n+$(srcdir)/generated/findloc1_r4.c \\\n+$(srcdir)/generated/findloc1_r8.c \\\n+$(srcdir)/generated/findloc1_r16.c \\\n+$(srcdir)/generated/findloc1_c4.c \\\n+$(srcdir)/generated/findloc1_c8.c \\\n+$(srcdir)/generated/findloc1_c16.c\n+\n+i_findloc1s_c= \\\n+$(srcdir)/generated/findloc1_s1.c \\\n+$(srcdir)/generated/findloc1_s4.c\n+\n+i_findloc2s_c= \\\n+$(srcdir)/generated/findloc2_s1.c \\\n+$(srcdir)/generated/findloc2_s4.c\n+\n i_maxloc0_c= \\\n $(srcdir)/generated/maxloc0_4_i1.c \\\n $(srcdir)/generated/maxloc0_8_i1.c \\\n@@ -754,7 +792,9 @@ m4_files= m4/iparm.m4 m4/ifunction.m4 m4/iforeach.m4 m4/all.m4 \\\n     m4/pow.m4 \\\n     m4/misc_specifics.m4 m4/pack.m4 \\\n     m4/unpack.m4 m4/spread.m4 m4/bessel.m4 m4/norm2.m4 m4/parity.m4 \\\n-    m4/iall.m4 m4/iany.m4 m4/iparity.m4 m4/iforeach-s.m4\n+    m4/iall.m4 m4/iany.m4 m4/iparity.m4 m4/iforeach-s.m4 m4/findloc0.m4 \\\n+    m4/findloc0s.m4 m4/ifindloc0.m4 m4/findloc1.m4 m4/ifindloc1.m4 \\\n+    m4/findloc2s.m4 m4/ifindloc2.m4\n \n gfor_built_src= $(i_all_c) $(i_any_c) $(i_count_c) $(i_maxloc0_c) \\\n     $(i_maxloc1_c) $(i_maxval_c) $(i_minloc0_c) $(i_minloc1_c) $(i_minval_c) \\\n@@ -767,7 +807,9 @@ gfor_built_src= $(i_all_c) $(i_any_c) $(i_count_c) $(i_maxloc0_c) \\\n     $(i_cshift0_c) kinds.inc c99_protos.inc fpu-target.h fpu-target.inc \\\n     $(i_cshift1a_c) $(i_maxloc0s_c) $(i_minloc0s_c) $(i_maxloc1s_c) \\\n     $(i_minloc1s_c) $(i_maxloc2s_c) $(i_minloc2s_c) $(i_maxvals_c) \\\n-    $(i_maxval0s_c) $(i_minval0s_c) $(i_maxval1s_c) $(i_minval1s_c)\n+    $(i_maxval0s_c) $(i_minval0s_c) $(i_maxval1s_c) $(i_minval1s_c) \\\n+    $(i_findloc0_c) $(i_findloc0s_c) $(i_findloc1_c) $(i_findloc1s_c) \\\n+    $(i_findloc2s_c)\n \n # Machine generated specifics\n gfor_built_specific_src= \\\n@@ -995,6 +1037,9 @@ I_M4_DEPS3=$(I_M4_DEPS) m4/iforeach-s.m4\n I_M4_DEPS4=$(I_M4_DEPS) m4/ifunction-s.m4\n I_M4_DEPS5=$(I_M4_DEPS) m4/iforeach-s2.m4\n I_M4_DEPS6=$(I_M4_DEPS) m4/ifunction-s2.m4\n+I_M4_DEPS7=$(I_M4_DEPS) m4/ifindloc0.m4\n+I_M4_DEPS8=$(I_M4_DEPS) m4/ifindloc1.m4\n+I_M4_DEPS9=$(I_M4_DEPS) m4/ifindloc2.m4\n \n kinds.h: $(srcdir)/mk-kinds-h.sh\n \t$(SHELL) $(srcdir)/mk-kinds-h.sh '$(FCCOMPILE)' > $@ || rm $@\n@@ -1034,6 +1079,21 @@ $(i_any_c): m4/any.m4 $(I_M4_DEPS2)\n $(i_count_c): m4/count.m4 $(I_M4_DEPS2)\n \t$(M4) -Dfile=$@ -I$(srcdir)/m4 count.m4 > $@\n \n+$(i_findloc0_c): m4/findloc0.m4 $(I_M4_DEPS7)\n+\t$(M4) -Dfile=$@ -I$(srcdir)/m4 findloc0.m4 > $@\n+\n+$(i_findloc0s_c): m4/findloc0s.m4 $(I_M4_DEPS7)\n+\t$(M4) -Dfile=$@ -I$(srcdir)/m4 findloc0s.m4 > $@\n+\n+$(i_findloc1_c): m4/findloc1.m4 $(I_M4_DEPS8)\n+\t$(M4) -Dfile=$@ -I$(srcdir)/m4 findloc1.m4 > $@\n+\n+$(i_findloc1s_c): m4/findloc1s.m4 $(I_M4_DEPS8)\n+\t$(M4) -Dfile=$@ -I$(srcdir)/m4 findloc1s.m4 > $@\n+\n+$(i_findloc2s_c): m4/findloc2s.m4 $(I_M4_DEPS9)\n+\t$(M4) -Dfile=$@ -I$(srcdir)/m4 findloc2s.m4 > $@\n+\n $(i_iall_c): m4/iall.m4 $(I_M4_DEPS1)\n \t$(M4) -Dfile=$@ -I$(srcdir)/m4 iall.m4 > $@\n "}, {"sha": "da0459367e72bbeff2d357921d0e310d349903e7", "filename": "libgfortran/Makefile.in", "status": "modified", "additions": 314, "deletions": 20, "changes": 334, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.in?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -334,7 +334,16 @@ am__objects_43 = maxval0_s1.lo maxval0_s4.lo\n am__objects_44 = minval0_s1.lo minval0_s4.lo\n am__objects_45 = maxval1_s1.lo maxval1_s4.lo\n am__objects_46 = minval1_s1.lo minval1_s4.lo\n-am__objects_47 = $(am__objects_4) $(am__objects_5) $(am__objects_6) \\\n+am__objects_47 = findloc0_i1.lo findloc0_i2.lo findloc0_i4.lo \\\n+\tfindloc0_i8.lo findloc0_i16.lo findloc0_r4.lo findloc0_r8.lo \\\n+\tfindloc0_r16.lo findloc0_c4.lo findloc0_c8.lo findloc0_c16.lo\n+am__objects_48 = findloc0_s1.lo findloc0_s4.lo\n+am__objects_49 = findloc1_i1.lo findloc1_i2.lo findloc1_i4.lo \\\n+\tfindloc1_i8.lo findloc1_i16.lo findloc1_r4.lo findloc1_r8.lo \\\n+\tfindloc1_r16.lo findloc1_c4.lo findloc1_c8.lo findloc1_c16.lo\n+am__objects_50 = findloc1_s1.lo findloc1_s4.lo\n+am__objects_51 = findloc2_s1.lo findloc2_s4.lo\n+am__objects_52 = $(am__objects_4) $(am__objects_5) $(am__objects_6) \\\n \t$(am__objects_7) $(am__objects_8) $(am__objects_9) \\\n \t$(am__objects_10) $(am__objects_11) $(am__objects_12) \\\n \t$(am__objects_13) $(am__objects_14) $(am__objects_15) \\\n@@ -348,14 +357,15 @@ am__objects_47 = $(am__objects_4) $(am__objects_5) $(am__objects_6) \\\n \t$(am__objects_37) $(am__objects_38) $(am__objects_39) \\\n \t$(am__objects_40) $(am__objects_41) $(am__objects_42) \\\n \t$(am__objects_43) $(am__objects_44) $(am__objects_45) \\\n-\t$(am__objects_46)\n-@LIBGFOR_MINIMAL_FALSE@am__objects_48 = close.lo file_pos.lo format.lo \\\n+\t$(am__objects_46) $(am__objects_47) $(am__objects_48) \\\n+\t$(am__objects_49) $(am__objects_50) $(am__objects_51)\n+@LIBGFOR_MINIMAL_FALSE@am__objects_53 = close.lo file_pos.lo format.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tinquire.lo intrinsics.lo list_read.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tlock.lo open.lo read.lo transfer.lo \\\n @LIBGFOR_MINIMAL_FALSE@\ttransfer128.lo unit.lo unix.lo write.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tfbuf.lo async.lo\n-am__objects_49 = size_from_kind.lo $(am__objects_48)\n-@LIBGFOR_MINIMAL_FALSE@am__objects_50 = access.lo c99_functions.lo \\\n+am__objects_54 = size_from_kind.lo $(am__objects_53)\n+@LIBGFOR_MINIMAL_FALSE@am__objects_55 = access.lo c99_functions.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tchdir.lo chmod.lo clock.lo cpu_time.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tctime.lo date_and_time.lo dtime.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tenv.lo etime.lo execute_command_line.lo \\\n@@ -365,19 +375,19 @@ am__objects_49 = size_from_kind.lo $(am__objects_48)\n @LIBGFOR_MINIMAL_FALSE@\trename.lo stat.lo symlnk.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tsystem_clock.lo time.lo umask.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tunlink.lo\n-@IEEE_SUPPORT_TRUE@am__objects_51 = ieee_helper.lo\n-am__objects_52 = associated.lo abort.lo args.lo cshift0.lo eoshift0.lo \\\n+@IEEE_SUPPORT_TRUE@am__objects_56 = ieee_helper.lo\n+am__objects_57 = associated.lo abort.lo args.lo cshift0.lo eoshift0.lo \\\n \teoshift2.lo erfc_scaled.lo extends_type_of.lo fnum.lo \\\n \tierrno.lo ishftc.lo mvbits.lo move_alloc.lo pack_generic.lo \\\n \tselected_char_kind.lo size.lo spread_generic.lo \\\n \tstring_intrinsics.lo rand.lo random.lo reshape_generic.lo \\\n \treshape_packed.lo selected_int_kind.lo selected_real_kind.lo \\\n \tunpack_generic.lo in_pack_generic.lo in_unpack_generic.lo \\\n-\t$(am__objects_50) $(am__objects_51)\n-@IEEE_SUPPORT_TRUE@am__objects_53 = ieee_arithmetic.lo \\\n+\t$(am__objects_55) $(am__objects_56)\n+@IEEE_SUPPORT_TRUE@am__objects_58 = ieee_arithmetic.lo \\\n @IEEE_SUPPORT_TRUE@\tieee_exceptions.lo ieee_features.lo\n-am__objects_54 =\n-am__objects_55 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \\\n+am__objects_59 =\n+am__objects_60 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \\\n \t_abs_i4.lo _abs_i8.lo _abs_i16.lo _abs_r4.lo _abs_r8.lo \\\n \t_abs_r10.lo _abs_r16.lo _aimag_c4.lo _aimag_c8.lo \\\n \t_aimag_c10.lo _aimag_c16.lo _exp_r4.lo _exp_r8.lo _exp_r10.lo \\\n@@ -401,19 +411,19 @@ am__objects_55 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \\\n \t_conjg_c4.lo _conjg_c8.lo _conjg_c10.lo _conjg_c16.lo \\\n \t_aint_r4.lo _aint_r8.lo _aint_r10.lo _aint_r16.lo _anint_r4.lo \\\n \t_anint_r8.lo _anint_r10.lo _anint_r16.lo\n-am__objects_56 = _sign_i4.lo _sign_i8.lo _sign_i16.lo _sign_r4.lo \\\n+am__objects_61 = _sign_i4.lo _sign_i8.lo _sign_i16.lo _sign_r4.lo \\\n \t_sign_r8.lo _sign_r10.lo _sign_r16.lo _dim_i4.lo _dim_i8.lo \\\n \t_dim_i16.lo _dim_r4.lo _dim_r8.lo _dim_r10.lo _dim_r16.lo \\\n \t_atan2_r4.lo _atan2_r8.lo _atan2_r10.lo _atan2_r16.lo \\\n \t_mod_i4.lo _mod_i8.lo _mod_i16.lo _mod_r4.lo _mod_r8.lo \\\n \t_mod_r10.lo _mod_r16.lo\n-am__objects_57 = misc_specifics.lo\n-am__objects_58 = $(am__objects_55) $(am__objects_56) $(am__objects_57) \\\n+am__objects_62 = misc_specifics.lo\n+am__objects_63 = $(am__objects_60) $(am__objects_61) $(am__objects_62) \\\n \tdprod_r8.lo f2c_specifics.lo random_init.lo\n-am__objects_59 = $(am__objects_3) $(am__objects_47) $(am__objects_49) \\\n-\t$(am__objects_52) $(am__objects_53) $(am__objects_54) \\\n-\t$(am__objects_58)\n-@onestep_FALSE@am_libgfortran_la_OBJECTS = $(am__objects_59)\n+am__objects_64 = $(am__objects_3) $(am__objects_52) $(am__objects_54) \\\n+\t$(am__objects_57) $(am__objects_58) $(am__objects_59) \\\n+\t$(am__objects_63)\n+@onestep_FALSE@am_libgfortran_la_OBJECTS = $(am__objects_64)\n @onestep_TRUE@am_libgfortran_la_OBJECTS = libgfortran_c.lo\n libgfortran_la_OBJECTS = $(am_libgfortran_la_OBJECTS)\n DEFAULT_INCLUDES = -I.@am__isrc@\n@@ -725,6 +735,44 @@ $(srcdir)/generated/iparity_i4.c \\\n $(srcdir)/generated/iparity_i8.c \\\n $(srcdir)/generated/iparity_i16.c\n \n+i_findloc0_c = \\\n+$(srcdir)/generated/findloc0_i1.c \\\n+$(srcdir)/generated/findloc0_i2.c \\\n+$(srcdir)/generated/findloc0_i4.c \\\n+$(srcdir)/generated/findloc0_i8.c \\\n+$(srcdir)/generated/findloc0_i16.c \\\n+$(srcdir)/generated/findloc0_r4.c \\\n+$(srcdir)/generated/findloc0_r8.c \\\n+$(srcdir)/generated/findloc0_r16.c \\\n+$(srcdir)/generated/findloc0_c4.c \\\n+$(srcdir)/generated/findloc0_c8.c \\\n+$(srcdir)/generated/findloc0_c16.c\n+\n+i_findloc0s_c = \\\n+$(srcdir)/generated/findloc0_s1.c \\\n+$(srcdir)/generated/findloc0_s4.c\n+\n+i_findloc1_c = \\\n+$(srcdir)/generated/findloc1_i1.c \\\n+$(srcdir)/generated/findloc1_i2.c \\\n+$(srcdir)/generated/findloc1_i4.c \\\n+$(srcdir)/generated/findloc1_i8.c \\\n+$(srcdir)/generated/findloc1_i16.c \\\n+$(srcdir)/generated/findloc1_r4.c \\\n+$(srcdir)/generated/findloc1_r8.c \\\n+$(srcdir)/generated/findloc1_r16.c \\\n+$(srcdir)/generated/findloc1_c4.c \\\n+$(srcdir)/generated/findloc1_c8.c \\\n+$(srcdir)/generated/findloc1_c16.c\n+\n+i_findloc1s_c = \\\n+$(srcdir)/generated/findloc1_s1.c \\\n+$(srcdir)/generated/findloc1_s4.c\n+\n+i_findloc2s_c = \\\n+$(srcdir)/generated/findloc2_s1.c \\\n+$(srcdir)/generated/findloc2_s4.c\n+\n i_maxloc0_c = \\\n $(srcdir)/generated/maxloc0_4_i1.c \\\n $(srcdir)/generated/maxloc0_8_i1.c \\\n@@ -1213,7 +1261,9 @@ m4_files = m4/iparm.m4 m4/ifunction.m4 m4/iforeach.m4 m4/all.m4 \\\n     m4/pow.m4 \\\n     m4/misc_specifics.m4 m4/pack.m4 \\\n     m4/unpack.m4 m4/spread.m4 m4/bessel.m4 m4/norm2.m4 m4/parity.m4 \\\n-    m4/iall.m4 m4/iany.m4 m4/iparity.m4 m4/iforeach-s.m4\n+    m4/iall.m4 m4/iany.m4 m4/iparity.m4 m4/iforeach-s.m4 m4/findloc0.m4 \\\n+    m4/findloc0s.m4 m4/ifindloc0.m4 m4/findloc1.m4 m4/ifindloc1.m4 \\\n+    m4/findloc2s.m4 m4/ifindloc2.m4\n \n gfor_built_src = $(i_all_c) $(i_any_c) $(i_count_c) $(i_maxloc0_c) \\\n     $(i_maxloc1_c) $(i_maxval_c) $(i_minloc0_c) $(i_minloc1_c) $(i_minval_c) \\\n@@ -1226,7 +1276,9 @@ gfor_built_src = $(i_all_c) $(i_any_c) $(i_count_c) $(i_maxloc0_c) \\\n     $(i_cshift0_c) kinds.inc c99_protos.inc fpu-target.h fpu-target.inc \\\n     $(i_cshift1a_c) $(i_maxloc0s_c) $(i_minloc0s_c) $(i_maxloc1s_c) \\\n     $(i_minloc1s_c) $(i_maxloc2s_c) $(i_minloc2s_c) $(i_maxvals_c) \\\n-    $(i_maxval0s_c) $(i_minval0s_c) $(i_maxval1s_c) $(i_minval1s_c)\n+    $(i_maxval0s_c) $(i_minval0s_c) $(i_maxval1s_c) $(i_minval1s_c) \\\n+    $(i_findloc0_c) $(i_findloc0s_c) $(i_findloc1_c) $(i_findloc1s_c) \\\n+    $(i_findloc2s_c)\n \n \n # Machine generated specifics\n@@ -1407,6 +1459,9 @@ I_M4_DEPS3 = $(I_M4_DEPS) m4/iforeach-s.m4\n I_M4_DEPS4 = $(I_M4_DEPS) m4/ifunction-s.m4\n I_M4_DEPS5 = $(I_M4_DEPS) m4/iforeach-s2.m4\n I_M4_DEPS6 = $(I_M4_DEPS) m4/ifunction-s2.m4\n+I_M4_DEPS7 = $(I_M4_DEPS) m4/ifindloc0.m4\n+I_M4_DEPS8 = $(I_M4_DEPS) m4/ifindloc1.m4\n+I_M4_DEPS9 = $(I_M4_DEPS) m4/ifindloc2.m4\n EXTRA_DIST = $(m4_files)\n all: $(BUILT_SOURCES) config.h\n \t$(MAKE) $(AM_MAKEFLAGS) all-am\n@@ -1650,6 +1705,34 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/extends_type_of.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/fbuf.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/file_pos.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/findloc0_c16.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/findloc0_c4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/findloc0_c8.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/findloc0_i1.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/findloc0_i16.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/findloc0_i2.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/findloc0_i4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/findloc0_i8.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/findloc0_r16.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/findloc0_r4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/findloc0_r8.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/findloc0_s1.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/findloc0_s4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/findloc1_c16.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/findloc1_c4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/findloc1_c8.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/findloc1_i1.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/findloc1_i16.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/findloc1_i2.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/findloc1_i4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/findloc1_i8.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/findloc1_r16.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/findloc1_r4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/findloc1_r8.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/findloc1_s1.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/findloc1_s4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/findloc2_s1.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/findloc2_s4.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/fnum.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/format.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/fpu.Plo@am__quote@\n@@ -5705,6 +5788,202 @@ minval1_s4.lo: $(srcdir)/generated/minval1_s4.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o minval1_s4.lo `test -f '$(srcdir)/generated/minval1_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/minval1_s4.c\n \n+findloc0_i1.lo: $(srcdir)/generated/findloc0_i1.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT findloc0_i1.lo -MD -MP -MF $(DEPDIR)/findloc0_i1.Tpo -c -o findloc0_i1.lo `test -f '$(srcdir)/generated/findloc0_i1.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc0_i1.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/findloc0_i1.Tpo $(DEPDIR)/findloc0_i1.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/findloc0_i1.c' object='findloc0_i1.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o findloc0_i1.lo `test -f '$(srcdir)/generated/findloc0_i1.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc0_i1.c\n+\n+findloc0_i2.lo: $(srcdir)/generated/findloc0_i2.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT findloc0_i2.lo -MD -MP -MF $(DEPDIR)/findloc0_i2.Tpo -c -o findloc0_i2.lo `test -f '$(srcdir)/generated/findloc0_i2.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc0_i2.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/findloc0_i2.Tpo $(DEPDIR)/findloc0_i2.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/findloc0_i2.c' object='findloc0_i2.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o findloc0_i2.lo `test -f '$(srcdir)/generated/findloc0_i2.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc0_i2.c\n+\n+findloc0_i4.lo: $(srcdir)/generated/findloc0_i4.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT findloc0_i4.lo -MD -MP -MF $(DEPDIR)/findloc0_i4.Tpo -c -o findloc0_i4.lo `test -f '$(srcdir)/generated/findloc0_i4.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc0_i4.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/findloc0_i4.Tpo $(DEPDIR)/findloc0_i4.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/findloc0_i4.c' object='findloc0_i4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o findloc0_i4.lo `test -f '$(srcdir)/generated/findloc0_i4.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc0_i4.c\n+\n+findloc0_i8.lo: $(srcdir)/generated/findloc0_i8.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT findloc0_i8.lo -MD -MP -MF $(DEPDIR)/findloc0_i8.Tpo -c -o findloc0_i8.lo `test -f '$(srcdir)/generated/findloc0_i8.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc0_i8.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/findloc0_i8.Tpo $(DEPDIR)/findloc0_i8.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/findloc0_i8.c' object='findloc0_i8.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o findloc0_i8.lo `test -f '$(srcdir)/generated/findloc0_i8.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc0_i8.c\n+\n+findloc0_i16.lo: $(srcdir)/generated/findloc0_i16.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT findloc0_i16.lo -MD -MP -MF $(DEPDIR)/findloc0_i16.Tpo -c -o findloc0_i16.lo `test -f '$(srcdir)/generated/findloc0_i16.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc0_i16.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/findloc0_i16.Tpo $(DEPDIR)/findloc0_i16.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/findloc0_i16.c' object='findloc0_i16.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o findloc0_i16.lo `test -f '$(srcdir)/generated/findloc0_i16.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc0_i16.c\n+\n+findloc0_r4.lo: $(srcdir)/generated/findloc0_r4.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT findloc0_r4.lo -MD -MP -MF $(DEPDIR)/findloc0_r4.Tpo -c -o findloc0_r4.lo `test -f '$(srcdir)/generated/findloc0_r4.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc0_r4.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/findloc0_r4.Tpo $(DEPDIR)/findloc0_r4.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/findloc0_r4.c' object='findloc0_r4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o findloc0_r4.lo `test -f '$(srcdir)/generated/findloc0_r4.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc0_r4.c\n+\n+findloc0_r8.lo: $(srcdir)/generated/findloc0_r8.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT findloc0_r8.lo -MD -MP -MF $(DEPDIR)/findloc0_r8.Tpo -c -o findloc0_r8.lo `test -f '$(srcdir)/generated/findloc0_r8.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc0_r8.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/findloc0_r8.Tpo $(DEPDIR)/findloc0_r8.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/findloc0_r8.c' object='findloc0_r8.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o findloc0_r8.lo `test -f '$(srcdir)/generated/findloc0_r8.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc0_r8.c\n+\n+findloc0_r16.lo: $(srcdir)/generated/findloc0_r16.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT findloc0_r16.lo -MD -MP -MF $(DEPDIR)/findloc0_r16.Tpo -c -o findloc0_r16.lo `test -f '$(srcdir)/generated/findloc0_r16.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc0_r16.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/findloc0_r16.Tpo $(DEPDIR)/findloc0_r16.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/findloc0_r16.c' object='findloc0_r16.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o findloc0_r16.lo `test -f '$(srcdir)/generated/findloc0_r16.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc0_r16.c\n+\n+findloc0_c4.lo: $(srcdir)/generated/findloc0_c4.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT findloc0_c4.lo -MD -MP -MF $(DEPDIR)/findloc0_c4.Tpo -c -o findloc0_c4.lo `test -f '$(srcdir)/generated/findloc0_c4.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc0_c4.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/findloc0_c4.Tpo $(DEPDIR)/findloc0_c4.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/findloc0_c4.c' object='findloc0_c4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o findloc0_c4.lo `test -f '$(srcdir)/generated/findloc0_c4.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc0_c4.c\n+\n+findloc0_c8.lo: $(srcdir)/generated/findloc0_c8.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT findloc0_c8.lo -MD -MP -MF $(DEPDIR)/findloc0_c8.Tpo -c -o findloc0_c8.lo `test -f '$(srcdir)/generated/findloc0_c8.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc0_c8.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/findloc0_c8.Tpo $(DEPDIR)/findloc0_c8.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/findloc0_c8.c' object='findloc0_c8.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o findloc0_c8.lo `test -f '$(srcdir)/generated/findloc0_c8.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc0_c8.c\n+\n+findloc0_c16.lo: $(srcdir)/generated/findloc0_c16.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT findloc0_c16.lo -MD -MP -MF $(DEPDIR)/findloc0_c16.Tpo -c -o findloc0_c16.lo `test -f '$(srcdir)/generated/findloc0_c16.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc0_c16.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/findloc0_c16.Tpo $(DEPDIR)/findloc0_c16.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/findloc0_c16.c' object='findloc0_c16.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o findloc0_c16.lo `test -f '$(srcdir)/generated/findloc0_c16.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc0_c16.c\n+\n+findloc0_s1.lo: $(srcdir)/generated/findloc0_s1.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT findloc0_s1.lo -MD -MP -MF $(DEPDIR)/findloc0_s1.Tpo -c -o findloc0_s1.lo `test -f '$(srcdir)/generated/findloc0_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc0_s1.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/findloc0_s1.Tpo $(DEPDIR)/findloc0_s1.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/findloc0_s1.c' object='findloc0_s1.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o findloc0_s1.lo `test -f '$(srcdir)/generated/findloc0_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc0_s1.c\n+\n+findloc0_s4.lo: $(srcdir)/generated/findloc0_s4.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT findloc0_s4.lo -MD -MP -MF $(DEPDIR)/findloc0_s4.Tpo -c -o findloc0_s4.lo `test -f '$(srcdir)/generated/findloc0_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc0_s4.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/findloc0_s4.Tpo $(DEPDIR)/findloc0_s4.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/findloc0_s4.c' object='findloc0_s4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o findloc0_s4.lo `test -f '$(srcdir)/generated/findloc0_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc0_s4.c\n+\n+findloc1_i1.lo: $(srcdir)/generated/findloc1_i1.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT findloc1_i1.lo -MD -MP -MF $(DEPDIR)/findloc1_i1.Tpo -c -o findloc1_i1.lo `test -f '$(srcdir)/generated/findloc1_i1.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc1_i1.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/findloc1_i1.Tpo $(DEPDIR)/findloc1_i1.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/findloc1_i1.c' object='findloc1_i1.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o findloc1_i1.lo `test -f '$(srcdir)/generated/findloc1_i1.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc1_i1.c\n+\n+findloc1_i2.lo: $(srcdir)/generated/findloc1_i2.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT findloc1_i2.lo -MD -MP -MF $(DEPDIR)/findloc1_i2.Tpo -c -o findloc1_i2.lo `test -f '$(srcdir)/generated/findloc1_i2.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc1_i2.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/findloc1_i2.Tpo $(DEPDIR)/findloc1_i2.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/findloc1_i2.c' object='findloc1_i2.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o findloc1_i2.lo `test -f '$(srcdir)/generated/findloc1_i2.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc1_i2.c\n+\n+findloc1_i4.lo: $(srcdir)/generated/findloc1_i4.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT findloc1_i4.lo -MD -MP -MF $(DEPDIR)/findloc1_i4.Tpo -c -o findloc1_i4.lo `test -f '$(srcdir)/generated/findloc1_i4.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc1_i4.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/findloc1_i4.Tpo $(DEPDIR)/findloc1_i4.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/findloc1_i4.c' object='findloc1_i4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o findloc1_i4.lo `test -f '$(srcdir)/generated/findloc1_i4.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc1_i4.c\n+\n+findloc1_i8.lo: $(srcdir)/generated/findloc1_i8.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT findloc1_i8.lo -MD -MP -MF $(DEPDIR)/findloc1_i8.Tpo -c -o findloc1_i8.lo `test -f '$(srcdir)/generated/findloc1_i8.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc1_i8.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/findloc1_i8.Tpo $(DEPDIR)/findloc1_i8.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/findloc1_i8.c' object='findloc1_i8.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o findloc1_i8.lo `test -f '$(srcdir)/generated/findloc1_i8.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc1_i8.c\n+\n+findloc1_i16.lo: $(srcdir)/generated/findloc1_i16.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT findloc1_i16.lo -MD -MP -MF $(DEPDIR)/findloc1_i16.Tpo -c -o findloc1_i16.lo `test -f '$(srcdir)/generated/findloc1_i16.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc1_i16.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/findloc1_i16.Tpo $(DEPDIR)/findloc1_i16.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/findloc1_i16.c' object='findloc1_i16.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o findloc1_i16.lo `test -f '$(srcdir)/generated/findloc1_i16.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc1_i16.c\n+\n+findloc1_r4.lo: $(srcdir)/generated/findloc1_r4.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT findloc1_r4.lo -MD -MP -MF $(DEPDIR)/findloc1_r4.Tpo -c -o findloc1_r4.lo `test -f '$(srcdir)/generated/findloc1_r4.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc1_r4.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/findloc1_r4.Tpo $(DEPDIR)/findloc1_r4.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/findloc1_r4.c' object='findloc1_r4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o findloc1_r4.lo `test -f '$(srcdir)/generated/findloc1_r4.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc1_r4.c\n+\n+findloc1_r8.lo: $(srcdir)/generated/findloc1_r8.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT findloc1_r8.lo -MD -MP -MF $(DEPDIR)/findloc1_r8.Tpo -c -o findloc1_r8.lo `test -f '$(srcdir)/generated/findloc1_r8.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc1_r8.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/findloc1_r8.Tpo $(DEPDIR)/findloc1_r8.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/findloc1_r8.c' object='findloc1_r8.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o findloc1_r8.lo `test -f '$(srcdir)/generated/findloc1_r8.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc1_r8.c\n+\n+findloc1_r16.lo: $(srcdir)/generated/findloc1_r16.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT findloc1_r16.lo -MD -MP -MF $(DEPDIR)/findloc1_r16.Tpo -c -o findloc1_r16.lo `test -f '$(srcdir)/generated/findloc1_r16.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc1_r16.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/findloc1_r16.Tpo $(DEPDIR)/findloc1_r16.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/findloc1_r16.c' object='findloc1_r16.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o findloc1_r16.lo `test -f '$(srcdir)/generated/findloc1_r16.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc1_r16.c\n+\n+findloc1_c4.lo: $(srcdir)/generated/findloc1_c4.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT findloc1_c4.lo -MD -MP -MF $(DEPDIR)/findloc1_c4.Tpo -c -o findloc1_c4.lo `test -f '$(srcdir)/generated/findloc1_c4.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc1_c4.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/findloc1_c4.Tpo $(DEPDIR)/findloc1_c4.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/findloc1_c4.c' object='findloc1_c4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o findloc1_c4.lo `test -f '$(srcdir)/generated/findloc1_c4.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc1_c4.c\n+\n+findloc1_c8.lo: $(srcdir)/generated/findloc1_c8.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT findloc1_c8.lo -MD -MP -MF $(DEPDIR)/findloc1_c8.Tpo -c -o findloc1_c8.lo `test -f '$(srcdir)/generated/findloc1_c8.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc1_c8.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/findloc1_c8.Tpo $(DEPDIR)/findloc1_c8.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/findloc1_c8.c' object='findloc1_c8.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o findloc1_c8.lo `test -f '$(srcdir)/generated/findloc1_c8.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc1_c8.c\n+\n+findloc1_c16.lo: $(srcdir)/generated/findloc1_c16.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT findloc1_c16.lo -MD -MP -MF $(DEPDIR)/findloc1_c16.Tpo -c -o findloc1_c16.lo `test -f '$(srcdir)/generated/findloc1_c16.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc1_c16.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/findloc1_c16.Tpo $(DEPDIR)/findloc1_c16.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/findloc1_c16.c' object='findloc1_c16.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o findloc1_c16.lo `test -f '$(srcdir)/generated/findloc1_c16.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc1_c16.c\n+\n+findloc1_s1.lo: $(srcdir)/generated/findloc1_s1.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT findloc1_s1.lo -MD -MP -MF $(DEPDIR)/findloc1_s1.Tpo -c -o findloc1_s1.lo `test -f '$(srcdir)/generated/findloc1_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc1_s1.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/findloc1_s1.Tpo $(DEPDIR)/findloc1_s1.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/findloc1_s1.c' object='findloc1_s1.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o findloc1_s1.lo `test -f '$(srcdir)/generated/findloc1_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc1_s1.c\n+\n+findloc1_s4.lo: $(srcdir)/generated/findloc1_s4.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT findloc1_s4.lo -MD -MP -MF $(DEPDIR)/findloc1_s4.Tpo -c -o findloc1_s4.lo `test -f '$(srcdir)/generated/findloc1_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc1_s4.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/findloc1_s4.Tpo $(DEPDIR)/findloc1_s4.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/findloc1_s4.c' object='findloc1_s4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o findloc1_s4.lo `test -f '$(srcdir)/generated/findloc1_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc1_s4.c\n+\n+findloc2_s1.lo: $(srcdir)/generated/findloc2_s1.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT findloc2_s1.lo -MD -MP -MF $(DEPDIR)/findloc2_s1.Tpo -c -o findloc2_s1.lo `test -f '$(srcdir)/generated/findloc2_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc2_s1.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/findloc2_s1.Tpo $(DEPDIR)/findloc2_s1.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/findloc2_s1.c' object='findloc2_s1.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o findloc2_s1.lo `test -f '$(srcdir)/generated/findloc2_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc2_s1.c\n+\n+findloc2_s4.lo: $(srcdir)/generated/findloc2_s4.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT findloc2_s4.lo -MD -MP -MF $(DEPDIR)/findloc2_s4.Tpo -c -o findloc2_s4.lo `test -f '$(srcdir)/generated/findloc2_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc2_s4.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/findloc2_s4.Tpo $(DEPDIR)/findloc2_s4.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/findloc2_s4.c' object='findloc2_s4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o findloc2_s4.lo `test -f '$(srcdir)/generated/findloc2_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc2_s4.c\n+\n size_from_kind.lo: io/size_from_kind.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT size_from_kind.lo -MD -MP -MF $(DEPDIR)/size_from_kind.Tpo -c -o size_from_kind.lo `test -f 'io/size_from_kind.c' || echo '$(srcdir)/'`io/size_from_kind.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/size_from_kind.Tpo $(DEPDIR)/size_from_kind.Plo\n@@ -6583,6 +6862,21 @@ fpu-target.inc: fpu-target.h $(srcdir)/libgfortran.h\n @MAINTAINER_MODE_TRUE@$(i_count_c): m4/count.m4 $(I_M4_DEPS2)\n @MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 count.m4 > $@\n \n+@MAINTAINER_MODE_TRUE@$(i_findloc0_c): m4/findloc0.m4 $(I_M4_DEPS7)\n+@MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 findloc0.m4 > $@\n+\n+@MAINTAINER_MODE_TRUE@$(i_findloc0s_c): m4/findloc0s.m4 $(I_M4_DEPS7)\n+@MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 findloc0s.m4 > $@\n+\n+@MAINTAINER_MODE_TRUE@$(i_findloc1_c): m4/findloc1.m4 $(I_M4_DEPS8)\n+@MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 findloc1.m4 > $@\n+\n+@MAINTAINER_MODE_TRUE@$(i_findloc1s_c): m4/findloc1s.m4 $(I_M4_DEPS8)\n+@MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 findloc1s.m4 > $@\n+\n+@MAINTAINER_MODE_TRUE@$(i_findloc2s_c): m4/findloc2s.m4 $(I_M4_DEPS9)\n+@MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 findloc2s.m4 > $@\n+\n @MAINTAINER_MODE_TRUE@$(i_iall_c): m4/iall.m4 $(I_M4_DEPS1)\n @MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 iall.m4 > $@\n "}, {"sha": "8afb0c553cb138c70a1293a54a672ed6d1261ac4", "filename": "libgfortran/generated/findloc0_c16.c", "status": "added", "additions": 375, "deletions": 0, "changes": 375, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc0_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc0_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ffindloc0_c16.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -0,0 +1,375 @@\n+\n+/* Implementation of the FINDLOC intrinsic\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by Thomas K\u00f6nig <tk@tkoenig.net>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <assert.h>\n+\n+#if defined (HAVE_GFC_COMPLEX_16)\n+extern void findloc0_c16 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_c16 * const restrict array, GFC_COMPLEX_16 value,\n+\t\t\t GFC_LOGICAL_4);\n+export_proto(findloc0_c16);\n+\n+void\n+findloc0_c16 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_c16 * const restrict array, GFC_COMPLEX_16 value,\n+\t    GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_COMPLEX_16 *base;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type sz;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"FINDLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+\n+  /* Set the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+\n+  sz = 1;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      sz *= extent[n];\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+    for (n = 0; n < rank; n++)\n+      count[n] = 0;\n+\n+  if (back)\n+    {\n+      base = array->base_addr + (sz - 1) * 1;\n+\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = extent[n] - count[n];\n+\n+\t\t  return;\n+\t\t}\n+\t      base -= sstride[0] * 1;\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base += sstride[n] * extent[n] * 1;\n+\t      n++;\n+\t      if (n >= rank)\n+\t        return;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base -= sstride[n] * 1;\n+\t\t}\n+\t    } while (count[n] == extent[n]);      \n+\t}\n+    }\n+  else\n+    {\n+      base = array->base_addr;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\n+\t\t  return;\n+\t\t}\n+\t      base += sstride[0] * 1;\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base -= sstride[n] * extent[n] * 1;\n+\t      n++;\n+\t      if (n >= rank)\n+\t        return;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base += sstride[n] * 1;\n+\t\t}\n+\t    } while (count[n] == extent[n]);\n+\t}\n+    }\n+  return;\n+}\n+\n+extern void mfindloc0_c16 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_c16 * const restrict array, GFC_COMPLEX_16 value,\n+\t\t\t gfc_array_l1 *const restrict, GFC_LOGICAL_4);\n+export_proto(mfindloc0_c16);\n+\n+void\n+mfindloc0_c16 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_c16 * const restrict array, GFC_COMPLEX_16 value,\n+\t    gfc_array_l1 *const restrict mask, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_COMPLEX_16 *base;\n+  index_type * restrict dest;\n+  GFC_LOGICAL_1 *mbase;\n+  index_type rank;\n+  index_type n;\n+  int mask_kind;\n+  index_type sz;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"FINDLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t\"MASK argument\", \"FINDLOC\");\n+\t}\n+    }\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+\n+  /* Set the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+\n+  sz = 1;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      sz *= extent[n];\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+    for (n = 0; n < rank; n++)\n+      count[n] = 0;\n+\n+  if (back)\n+    {\n+      base = array->base_addr + (sz - 1) * 1;\n+      mbase = mbase + (sz - 1) * mask_kind;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*mbase && *base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = extent[n] - count[n];\n+\n+\t\t  return;\n+\t\t}\n+\t      base -= sstride[0] * 1;\n+\t      mbase -= mstride[0];\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base += sstride[n] * extent[n] * 1;\n+\t      mbase -= mstride[n] * extent[n];\n+\t      n++;\n+\t      if (n >= rank)\n+\t\treturn;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base -= sstride[n] * 1;\n+\t\t  mbase += mstride[n];\n+\t\t}\n+\t    } while (count[n] == extent[n]);      \n+\t}\n+    }\n+  else\n+    {\n+      base = array->base_addr;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*mbase && *base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\n+\t\t  return;\n+\t\t}\n+\t      base += sstride[0] * 1;\n+\t      mbase += mstride[0];\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base -= sstride[n] * extent[n] * 1;\n+\t      mbase -= mstride[n] * extent[n];\n+\t      n++;\n+\t      if (n >= rank)\n+\t\treturn;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base += sstride[n]* 1;\n+\t\t  mbase += mstride[n];\n+\t\t}\n+\t    } while (count[n] == extent[n]);\n+\t}\n+    }\n+  return;\n+}\n+\n+extern void sfindloc0_c16 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_c16 * const restrict array, GFC_COMPLEX_16 value,\n+\t\t\t GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n+export_proto(sfindloc0_c16);\n+\n+void\n+sfindloc0_c16 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_c16 * const restrict array, GFC_COMPLEX_16 value,\n+\t    GFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type * restrict dest;\n+  index_type n;\n+\n+  if (*mask)\n+    {\n+      findloc0_c16 (retarray, array, value, back);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    internal_error (NULL, \"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"FINDLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n+\n+#endif"}, {"sha": "42f010bb5c1c5d76dd9f76c1ddb302828988f2da", "filename": "libgfortran/generated/findloc0_c4.c", "status": "added", "additions": 375, "deletions": 0, "changes": 375, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc0_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc0_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ffindloc0_c4.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -0,0 +1,375 @@\n+\n+/* Implementation of the FINDLOC intrinsic\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by Thomas K\u00f6nig <tk@tkoenig.net>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <assert.h>\n+\n+#if defined (HAVE_GFC_COMPLEX_4)\n+extern void findloc0_c4 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_c4 * const restrict array, GFC_COMPLEX_4 value,\n+\t\t\t GFC_LOGICAL_4);\n+export_proto(findloc0_c4);\n+\n+void\n+findloc0_c4 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_c4 * const restrict array, GFC_COMPLEX_4 value,\n+\t    GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_COMPLEX_4 *base;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type sz;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"FINDLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+\n+  /* Set the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+\n+  sz = 1;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      sz *= extent[n];\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+    for (n = 0; n < rank; n++)\n+      count[n] = 0;\n+\n+  if (back)\n+    {\n+      base = array->base_addr + (sz - 1) * 1;\n+\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = extent[n] - count[n];\n+\n+\t\t  return;\n+\t\t}\n+\t      base -= sstride[0] * 1;\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base += sstride[n] * extent[n] * 1;\n+\t      n++;\n+\t      if (n >= rank)\n+\t        return;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base -= sstride[n] * 1;\n+\t\t}\n+\t    } while (count[n] == extent[n]);      \n+\t}\n+    }\n+  else\n+    {\n+      base = array->base_addr;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\n+\t\t  return;\n+\t\t}\n+\t      base += sstride[0] * 1;\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base -= sstride[n] * extent[n] * 1;\n+\t      n++;\n+\t      if (n >= rank)\n+\t        return;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base += sstride[n] * 1;\n+\t\t}\n+\t    } while (count[n] == extent[n]);\n+\t}\n+    }\n+  return;\n+}\n+\n+extern void mfindloc0_c4 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_c4 * const restrict array, GFC_COMPLEX_4 value,\n+\t\t\t gfc_array_l1 *const restrict, GFC_LOGICAL_4);\n+export_proto(mfindloc0_c4);\n+\n+void\n+mfindloc0_c4 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_c4 * const restrict array, GFC_COMPLEX_4 value,\n+\t    gfc_array_l1 *const restrict mask, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_COMPLEX_4 *base;\n+  index_type * restrict dest;\n+  GFC_LOGICAL_1 *mbase;\n+  index_type rank;\n+  index_type n;\n+  int mask_kind;\n+  index_type sz;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"FINDLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t\"MASK argument\", \"FINDLOC\");\n+\t}\n+    }\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+\n+  /* Set the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+\n+  sz = 1;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      sz *= extent[n];\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+    for (n = 0; n < rank; n++)\n+      count[n] = 0;\n+\n+  if (back)\n+    {\n+      base = array->base_addr + (sz - 1) * 1;\n+      mbase = mbase + (sz - 1) * mask_kind;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*mbase && *base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = extent[n] - count[n];\n+\n+\t\t  return;\n+\t\t}\n+\t      base -= sstride[0] * 1;\n+\t      mbase -= mstride[0];\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base += sstride[n] * extent[n] * 1;\n+\t      mbase -= mstride[n] * extent[n];\n+\t      n++;\n+\t      if (n >= rank)\n+\t\treturn;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base -= sstride[n] * 1;\n+\t\t  mbase += mstride[n];\n+\t\t}\n+\t    } while (count[n] == extent[n]);      \n+\t}\n+    }\n+  else\n+    {\n+      base = array->base_addr;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*mbase && *base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\n+\t\t  return;\n+\t\t}\n+\t      base += sstride[0] * 1;\n+\t      mbase += mstride[0];\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base -= sstride[n] * extent[n] * 1;\n+\t      mbase -= mstride[n] * extent[n];\n+\t      n++;\n+\t      if (n >= rank)\n+\t\treturn;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base += sstride[n]* 1;\n+\t\t  mbase += mstride[n];\n+\t\t}\n+\t    } while (count[n] == extent[n]);\n+\t}\n+    }\n+  return;\n+}\n+\n+extern void sfindloc0_c4 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_c4 * const restrict array, GFC_COMPLEX_4 value,\n+\t\t\t GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n+export_proto(sfindloc0_c4);\n+\n+void\n+sfindloc0_c4 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_c4 * const restrict array, GFC_COMPLEX_4 value,\n+\t    GFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type * restrict dest;\n+  index_type n;\n+\n+  if (*mask)\n+    {\n+      findloc0_c4 (retarray, array, value, back);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    internal_error (NULL, \"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"FINDLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n+\n+#endif"}, {"sha": "8eb730351408d7b398e6b5d792c06260d6fca052", "filename": "libgfortran/generated/findloc0_c8.c", "status": "added", "additions": 375, "deletions": 0, "changes": 375, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc0_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc0_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ffindloc0_c8.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -0,0 +1,375 @@\n+\n+/* Implementation of the FINDLOC intrinsic\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by Thomas K\u00f6nig <tk@tkoenig.net>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <assert.h>\n+\n+#if defined (HAVE_GFC_COMPLEX_8)\n+extern void findloc0_c8 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_c8 * const restrict array, GFC_COMPLEX_8 value,\n+\t\t\t GFC_LOGICAL_4);\n+export_proto(findloc0_c8);\n+\n+void\n+findloc0_c8 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_c8 * const restrict array, GFC_COMPLEX_8 value,\n+\t    GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_COMPLEX_8 *base;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type sz;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"FINDLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+\n+  /* Set the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+\n+  sz = 1;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      sz *= extent[n];\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+    for (n = 0; n < rank; n++)\n+      count[n] = 0;\n+\n+  if (back)\n+    {\n+      base = array->base_addr + (sz - 1) * 1;\n+\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = extent[n] - count[n];\n+\n+\t\t  return;\n+\t\t}\n+\t      base -= sstride[0] * 1;\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base += sstride[n] * extent[n] * 1;\n+\t      n++;\n+\t      if (n >= rank)\n+\t        return;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base -= sstride[n] * 1;\n+\t\t}\n+\t    } while (count[n] == extent[n]);      \n+\t}\n+    }\n+  else\n+    {\n+      base = array->base_addr;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\n+\t\t  return;\n+\t\t}\n+\t      base += sstride[0] * 1;\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base -= sstride[n] * extent[n] * 1;\n+\t      n++;\n+\t      if (n >= rank)\n+\t        return;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base += sstride[n] * 1;\n+\t\t}\n+\t    } while (count[n] == extent[n]);\n+\t}\n+    }\n+  return;\n+}\n+\n+extern void mfindloc0_c8 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_c8 * const restrict array, GFC_COMPLEX_8 value,\n+\t\t\t gfc_array_l1 *const restrict, GFC_LOGICAL_4);\n+export_proto(mfindloc0_c8);\n+\n+void\n+mfindloc0_c8 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_c8 * const restrict array, GFC_COMPLEX_8 value,\n+\t    gfc_array_l1 *const restrict mask, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_COMPLEX_8 *base;\n+  index_type * restrict dest;\n+  GFC_LOGICAL_1 *mbase;\n+  index_type rank;\n+  index_type n;\n+  int mask_kind;\n+  index_type sz;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"FINDLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t\"MASK argument\", \"FINDLOC\");\n+\t}\n+    }\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+\n+  /* Set the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+\n+  sz = 1;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      sz *= extent[n];\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+    for (n = 0; n < rank; n++)\n+      count[n] = 0;\n+\n+  if (back)\n+    {\n+      base = array->base_addr + (sz - 1) * 1;\n+      mbase = mbase + (sz - 1) * mask_kind;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*mbase && *base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = extent[n] - count[n];\n+\n+\t\t  return;\n+\t\t}\n+\t      base -= sstride[0] * 1;\n+\t      mbase -= mstride[0];\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base += sstride[n] * extent[n] * 1;\n+\t      mbase -= mstride[n] * extent[n];\n+\t      n++;\n+\t      if (n >= rank)\n+\t\treturn;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base -= sstride[n] * 1;\n+\t\t  mbase += mstride[n];\n+\t\t}\n+\t    } while (count[n] == extent[n]);      \n+\t}\n+    }\n+  else\n+    {\n+      base = array->base_addr;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*mbase && *base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\n+\t\t  return;\n+\t\t}\n+\t      base += sstride[0] * 1;\n+\t      mbase += mstride[0];\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base -= sstride[n] * extent[n] * 1;\n+\t      mbase -= mstride[n] * extent[n];\n+\t      n++;\n+\t      if (n >= rank)\n+\t\treturn;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base += sstride[n]* 1;\n+\t\t  mbase += mstride[n];\n+\t\t}\n+\t    } while (count[n] == extent[n]);\n+\t}\n+    }\n+  return;\n+}\n+\n+extern void sfindloc0_c8 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_c8 * const restrict array, GFC_COMPLEX_8 value,\n+\t\t\t GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n+export_proto(sfindloc0_c8);\n+\n+void\n+sfindloc0_c8 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_c8 * const restrict array, GFC_COMPLEX_8 value,\n+\t    GFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type * restrict dest;\n+  index_type n;\n+\n+  if (*mask)\n+    {\n+      findloc0_c8 (retarray, array, value, back);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    internal_error (NULL, \"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"FINDLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n+\n+#endif"}, {"sha": "76b5400a50e6fcc73176bf4b585f7eb154ec327a", "filename": "libgfortran/generated/findloc0_i1.c", "status": "added", "additions": 375, "deletions": 0, "changes": 375, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc0_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc0_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ffindloc0_i1.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -0,0 +1,375 @@\n+\n+/* Implementation of the FINDLOC intrinsic\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by Thomas K\u00f6nig <tk@tkoenig.net>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <assert.h>\n+\n+#if defined (HAVE_GFC_INTEGER_1)\n+extern void findloc0_i1 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_i1 * const restrict array, GFC_INTEGER_1 value,\n+\t\t\t GFC_LOGICAL_4);\n+export_proto(findloc0_i1);\n+\n+void\n+findloc0_i1 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_i1 * const restrict array, GFC_INTEGER_1 value,\n+\t    GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_INTEGER_1 *base;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type sz;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"FINDLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+\n+  /* Set the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+\n+  sz = 1;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      sz *= extent[n];\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+    for (n = 0; n < rank; n++)\n+      count[n] = 0;\n+\n+  if (back)\n+    {\n+      base = array->base_addr + (sz - 1) * 1;\n+\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = extent[n] - count[n];\n+\n+\t\t  return;\n+\t\t}\n+\t      base -= sstride[0] * 1;\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base += sstride[n] * extent[n] * 1;\n+\t      n++;\n+\t      if (n >= rank)\n+\t        return;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base -= sstride[n] * 1;\n+\t\t}\n+\t    } while (count[n] == extent[n]);      \n+\t}\n+    }\n+  else\n+    {\n+      base = array->base_addr;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\n+\t\t  return;\n+\t\t}\n+\t      base += sstride[0] * 1;\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base -= sstride[n] * extent[n] * 1;\n+\t      n++;\n+\t      if (n >= rank)\n+\t        return;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base += sstride[n] * 1;\n+\t\t}\n+\t    } while (count[n] == extent[n]);\n+\t}\n+    }\n+  return;\n+}\n+\n+extern void mfindloc0_i1 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_i1 * const restrict array, GFC_INTEGER_1 value,\n+\t\t\t gfc_array_l1 *const restrict, GFC_LOGICAL_4);\n+export_proto(mfindloc0_i1);\n+\n+void\n+mfindloc0_i1 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_i1 * const restrict array, GFC_INTEGER_1 value,\n+\t    gfc_array_l1 *const restrict mask, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_INTEGER_1 *base;\n+  index_type * restrict dest;\n+  GFC_LOGICAL_1 *mbase;\n+  index_type rank;\n+  index_type n;\n+  int mask_kind;\n+  index_type sz;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"FINDLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t\"MASK argument\", \"FINDLOC\");\n+\t}\n+    }\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+\n+  /* Set the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+\n+  sz = 1;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      sz *= extent[n];\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+    for (n = 0; n < rank; n++)\n+      count[n] = 0;\n+\n+  if (back)\n+    {\n+      base = array->base_addr + (sz - 1) * 1;\n+      mbase = mbase + (sz - 1) * mask_kind;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*mbase && *base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = extent[n] - count[n];\n+\n+\t\t  return;\n+\t\t}\n+\t      base -= sstride[0] * 1;\n+\t      mbase -= mstride[0];\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base += sstride[n] * extent[n] * 1;\n+\t      mbase -= mstride[n] * extent[n];\n+\t      n++;\n+\t      if (n >= rank)\n+\t\treturn;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base -= sstride[n] * 1;\n+\t\t  mbase += mstride[n];\n+\t\t}\n+\t    } while (count[n] == extent[n]);      \n+\t}\n+    }\n+  else\n+    {\n+      base = array->base_addr;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*mbase && *base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\n+\t\t  return;\n+\t\t}\n+\t      base += sstride[0] * 1;\n+\t      mbase += mstride[0];\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base -= sstride[n] * extent[n] * 1;\n+\t      mbase -= mstride[n] * extent[n];\n+\t      n++;\n+\t      if (n >= rank)\n+\t\treturn;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base += sstride[n]* 1;\n+\t\t  mbase += mstride[n];\n+\t\t}\n+\t    } while (count[n] == extent[n]);\n+\t}\n+    }\n+  return;\n+}\n+\n+extern void sfindloc0_i1 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_i1 * const restrict array, GFC_INTEGER_1 value,\n+\t\t\t GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n+export_proto(sfindloc0_i1);\n+\n+void\n+sfindloc0_i1 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_i1 * const restrict array, GFC_INTEGER_1 value,\n+\t    GFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type * restrict dest;\n+  index_type n;\n+\n+  if (*mask)\n+    {\n+      findloc0_i1 (retarray, array, value, back);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    internal_error (NULL, \"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"FINDLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n+\n+#endif"}, {"sha": "bdfd69a6c0b243834f4ddab3a62dbcb406bca6de", "filename": "libgfortran/generated/findloc0_i16.c", "status": "added", "additions": 375, "deletions": 0, "changes": 375, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc0_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc0_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ffindloc0_i16.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -0,0 +1,375 @@\n+\n+/* Implementation of the FINDLOC intrinsic\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by Thomas K\u00f6nig <tk@tkoenig.net>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <assert.h>\n+\n+#if defined (HAVE_GFC_INTEGER_16)\n+extern void findloc0_i16 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_i16 * const restrict array, GFC_INTEGER_16 value,\n+\t\t\t GFC_LOGICAL_4);\n+export_proto(findloc0_i16);\n+\n+void\n+findloc0_i16 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_i16 * const restrict array, GFC_INTEGER_16 value,\n+\t    GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_INTEGER_16 *base;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type sz;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"FINDLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+\n+  /* Set the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+\n+  sz = 1;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      sz *= extent[n];\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+    for (n = 0; n < rank; n++)\n+      count[n] = 0;\n+\n+  if (back)\n+    {\n+      base = array->base_addr + (sz - 1) * 1;\n+\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = extent[n] - count[n];\n+\n+\t\t  return;\n+\t\t}\n+\t      base -= sstride[0] * 1;\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base += sstride[n] * extent[n] * 1;\n+\t      n++;\n+\t      if (n >= rank)\n+\t        return;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base -= sstride[n] * 1;\n+\t\t}\n+\t    } while (count[n] == extent[n]);      \n+\t}\n+    }\n+  else\n+    {\n+      base = array->base_addr;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\n+\t\t  return;\n+\t\t}\n+\t      base += sstride[0] * 1;\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base -= sstride[n] * extent[n] * 1;\n+\t      n++;\n+\t      if (n >= rank)\n+\t        return;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base += sstride[n] * 1;\n+\t\t}\n+\t    } while (count[n] == extent[n]);\n+\t}\n+    }\n+  return;\n+}\n+\n+extern void mfindloc0_i16 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_i16 * const restrict array, GFC_INTEGER_16 value,\n+\t\t\t gfc_array_l1 *const restrict, GFC_LOGICAL_4);\n+export_proto(mfindloc0_i16);\n+\n+void\n+mfindloc0_i16 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_i16 * const restrict array, GFC_INTEGER_16 value,\n+\t    gfc_array_l1 *const restrict mask, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_INTEGER_16 *base;\n+  index_type * restrict dest;\n+  GFC_LOGICAL_1 *mbase;\n+  index_type rank;\n+  index_type n;\n+  int mask_kind;\n+  index_type sz;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"FINDLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t\"MASK argument\", \"FINDLOC\");\n+\t}\n+    }\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+\n+  /* Set the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+\n+  sz = 1;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      sz *= extent[n];\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+    for (n = 0; n < rank; n++)\n+      count[n] = 0;\n+\n+  if (back)\n+    {\n+      base = array->base_addr + (sz - 1) * 1;\n+      mbase = mbase + (sz - 1) * mask_kind;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*mbase && *base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = extent[n] - count[n];\n+\n+\t\t  return;\n+\t\t}\n+\t      base -= sstride[0] * 1;\n+\t      mbase -= mstride[0];\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base += sstride[n] * extent[n] * 1;\n+\t      mbase -= mstride[n] * extent[n];\n+\t      n++;\n+\t      if (n >= rank)\n+\t\treturn;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base -= sstride[n] * 1;\n+\t\t  mbase += mstride[n];\n+\t\t}\n+\t    } while (count[n] == extent[n]);      \n+\t}\n+    }\n+  else\n+    {\n+      base = array->base_addr;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*mbase && *base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\n+\t\t  return;\n+\t\t}\n+\t      base += sstride[0] * 1;\n+\t      mbase += mstride[0];\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base -= sstride[n] * extent[n] * 1;\n+\t      mbase -= mstride[n] * extent[n];\n+\t      n++;\n+\t      if (n >= rank)\n+\t\treturn;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base += sstride[n]* 1;\n+\t\t  mbase += mstride[n];\n+\t\t}\n+\t    } while (count[n] == extent[n]);\n+\t}\n+    }\n+  return;\n+}\n+\n+extern void sfindloc0_i16 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_i16 * const restrict array, GFC_INTEGER_16 value,\n+\t\t\t GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n+export_proto(sfindloc0_i16);\n+\n+void\n+sfindloc0_i16 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_i16 * const restrict array, GFC_INTEGER_16 value,\n+\t    GFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type * restrict dest;\n+  index_type n;\n+\n+  if (*mask)\n+    {\n+      findloc0_i16 (retarray, array, value, back);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    internal_error (NULL, \"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"FINDLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n+\n+#endif"}, {"sha": "712262fc8ba1afa9e3f03ea4e5644c8394122941", "filename": "libgfortran/generated/findloc0_i2.c", "status": "added", "additions": 375, "deletions": 0, "changes": 375, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc0_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc0_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ffindloc0_i2.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -0,0 +1,375 @@\n+\n+/* Implementation of the FINDLOC intrinsic\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by Thomas K\u00f6nig <tk@tkoenig.net>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <assert.h>\n+\n+#if defined (HAVE_GFC_INTEGER_2)\n+extern void findloc0_i2 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_i2 * const restrict array, GFC_INTEGER_2 value,\n+\t\t\t GFC_LOGICAL_4);\n+export_proto(findloc0_i2);\n+\n+void\n+findloc0_i2 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_i2 * const restrict array, GFC_INTEGER_2 value,\n+\t    GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_INTEGER_2 *base;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type sz;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"FINDLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+\n+  /* Set the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+\n+  sz = 1;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      sz *= extent[n];\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+    for (n = 0; n < rank; n++)\n+      count[n] = 0;\n+\n+  if (back)\n+    {\n+      base = array->base_addr + (sz - 1) * 1;\n+\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = extent[n] - count[n];\n+\n+\t\t  return;\n+\t\t}\n+\t      base -= sstride[0] * 1;\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base += sstride[n] * extent[n] * 1;\n+\t      n++;\n+\t      if (n >= rank)\n+\t        return;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base -= sstride[n] * 1;\n+\t\t}\n+\t    } while (count[n] == extent[n]);      \n+\t}\n+    }\n+  else\n+    {\n+      base = array->base_addr;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\n+\t\t  return;\n+\t\t}\n+\t      base += sstride[0] * 1;\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base -= sstride[n] * extent[n] * 1;\n+\t      n++;\n+\t      if (n >= rank)\n+\t        return;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base += sstride[n] * 1;\n+\t\t}\n+\t    } while (count[n] == extent[n]);\n+\t}\n+    }\n+  return;\n+}\n+\n+extern void mfindloc0_i2 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_i2 * const restrict array, GFC_INTEGER_2 value,\n+\t\t\t gfc_array_l1 *const restrict, GFC_LOGICAL_4);\n+export_proto(mfindloc0_i2);\n+\n+void\n+mfindloc0_i2 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_i2 * const restrict array, GFC_INTEGER_2 value,\n+\t    gfc_array_l1 *const restrict mask, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_INTEGER_2 *base;\n+  index_type * restrict dest;\n+  GFC_LOGICAL_1 *mbase;\n+  index_type rank;\n+  index_type n;\n+  int mask_kind;\n+  index_type sz;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"FINDLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t\"MASK argument\", \"FINDLOC\");\n+\t}\n+    }\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+\n+  /* Set the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+\n+  sz = 1;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      sz *= extent[n];\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+    for (n = 0; n < rank; n++)\n+      count[n] = 0;\n+\n+  if (back)\n+    {\n+      base = array->base_addr + (sz - 1) * 1;\n+      mbase = mbase + (sz - 1) * mask_kind;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*mbase && *base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = extent[n] - count[n];\n+\n+\t\t  return;\n+\t\t}\n+\t      base -= sstride[0] * 1;\n+\t      mbase -= mstride[0];\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base += sstride[n] * extent[n] * 1;\n+\t      mbase -= mstride[n] * extent[n];\n+\t      n++;\n+\t      if (n >= rank)\n+\t\treturn;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base -= sstride[n] * 1;\n+\t\t  mbase += mstride[n];\n+\t\t}\n+\t    } while (count[n] == extent[n]);      \n+\t}\n+    }\n+  else\n+    {\n+      base = array->base_addr;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*mbase && *base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\n+\t\t  return;\n+\t\t}\n+\t      base += sstride[0] * 1;\n+\t      mbase += mstride[0];\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base -= sstride[n] * extent[n] * 1;\n+\t      mbase -= mstride[n] * extent[n];\n+\t      n++;\n+\t      if (n >= rank)\n+\t\treturn;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base += sstride[n]* 1;\n+\t\t  mbase += mstride[n];\n+\t\t}\n+\t    } while (count[n] == extent[n]);\n+\t}\n+    }\n+  return;\n+}\n+\n+extern void sfindloc0_i2 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_i2 * const restrict array, GFC_INTEGER_2 value,\n+\t\t\t GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n+export_proto(sfindloc0_i2);\n+\n+void\n+sfindloc0_i2 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_i2 * const restrict array, GFC_INTEGER_2 value,\n+\t    GFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type * restrict dest;\n+  index_type n;\n+\n+  if (*mask)\n+    {\n+      findloc0_i2 (retarray, array, value, back);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    internal_error (NULL, \"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"FINDLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n+\n+#endif"}, {"sha": "db72489d2474cea23535db2fc863f32ab313bb2e", "filename": "libgfortran/generated/findloc0_i4.c", "status": "added", "additions": 375, "deletions": 0, "changes": 375, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc0_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc0_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ffindloc0_i4.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -0,0 +1,375 @@\n+\n+/* Implementation of the FINDLOC intrinsic\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by Thomas K\u00f6nig <tk@tkoenig.net>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <assert.h>\n+\n+#if defined (HAVE_GFC_INTEGER_4)\n+extern void findloc0_i4 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_i4 * const restrict array, GFC_INTEGER_4 value,\n+\t\t\t GFC_LOGICAL_4);\n+export_proto(findloc0_i4);\n+\n+void\n+findloc0_i4 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_i4 * const restrict array, GFC_INTEGER_4 value,\n+\t    GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_INTEGER_4 *base;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type sz;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"FINDLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+\n+  /* Set the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+\n+  sz = 1;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      sz *= extent[n];\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+    for (n = 0; n < rank; n++)\n+      count[n] = 0;\n+\n+  if (back)\n+    {\n+      base = array->base_addr + (sz - 1) * 1;\n+\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = extent[n] - count[n];\n+\n+\t\t  return;\n+\t\t}\n+\t      base -= sstride[0] * 1;\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base += sstride[n] * extent[n] * 1;\n+\t      n++;\n+\t      if (n >= rank)\n+\t        return;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base -= sstride[n] * 1;\n+\t\t}\n+\t    } while (count[n] == extent[n]);      \n+\t}\n+    }\n+  else\n+    {\n+      base = array->base_addr;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\n+\t\t  return;\n+\t\t}\n+\t      base += sstride[0] * 1;\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base -= sstride[n] * extent[n] * 1;\n+\t      n++;\n+\t      if (n >= rank)\n+\t        return;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base += sstride[n] * 1;\n+\t\t}\n+\t    } while (count[n] == extent[n]);\n+\t}\n+    }\n+  return;\n+}\n+\n+extern void mfindloc0_i4 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_i4 * const restrict array, GFC_INTEGER_4 value,\n+\t\t\t gfc_array_l1 *const restrict, GFC_LOGICAL_4);\n+export_proto(mfindloc0_i4);\n+\n+void\n+mfindloc0_i4 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_i4 * const restrict array, GFC_INTEGER_4 value,\n+\t    gfc_array_l1 *const restrict mask, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_INTEGER_4 *base;\n+  index_type * restrict dest;\n+  GFC_LOGICAL_1 *mbase;\n+  index_type rank;\n+  index_type n;\n+  int mask_kind;\n+  index_type sz;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"FINDLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t\"MASK argument\", \"FINDLOC\");\n+\t}\n+    }\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+\n+  /* Set the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+\n+  sz = 1;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      sz *= extent[n];\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+    for (n = 0; n < rank; n++)\n+      count[n] = 0;\n+\n+  if (back)\n+    {\n+      base = array->base_addr + (sz - 1) * 1;\n+      mbase = mbase + (sz - 1) * mask_kind;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*mbase && *base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = extent[n] - count[n];\n+\n+\t\t  return;\n+\t\t}\n+\t      base -= sstride[0] * 1;\n+\t      mbase -= mstride[0];\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base += sstride[n] * extent[n] * 1;\n+\t      mbase -= mstride[n] * extent[n];\n+\t      n++;\n+\t      if (n >= rank)\n+\t\treturn;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base -= sstride[n] * 1;\n+\t\t  mbase += mstride[n];\n+\t\t}\n+\t    } while (count[n] == extent[n]);      \n+\t}\n+    }\n+  else\n+    {\n+      base = array->base_addr;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*mbase && *base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\n+\t\t  return;\n+\t\t}\n+\t      base += sstride[0] * 1;\n+\t      mbase += mstride[0];\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base -= sstride[n] * extent[n] * 1;\n+\t      mbase -= mstride[n] * extent[n];\n+\t      n++;\n+\t      if (n >= rank)\n+\t\treturn;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base += sstride[n]* 1;\n+\t\t  mbase += mstride[n];\n+\t\t}\n+\t    } while (count[n] == extent[n]);\n+\t}\n+    }\n+  return;\n+}\n+\n+extern void sfindloc0_i4 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_i4 * const restrict array, GFC_INTEGER_4 value,\n+\t\t\t GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n+export_proto(sfindloc0_i4);\n+\n+void\n+sfindloc0_i4 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_i4 * const restrict array, GFC_INTEGER_4 value,\n+\t    GFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type * restrict dest;\n+  index_type n;\n+\n+  if (*mask)\n+    {\n+      findloc0_i4 (retarray, array, value, back);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    internal_error (NULL, \"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"FINDLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n+\n+#endif"}, {"sha": "6fb3e2cdbb23b1104f4477ac5006a0773638c2b8", "filename": "libgfortran/generated/findloc0_i8.c", "status": "added", "additions": 375, "deletions": 0, "changes": 375, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc0_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc0_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ffindloc0_i8.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -0,0 +1,375 @@\n+\n+/* Implementation of the FINDLOC intrinsic\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by Thomas K\u00f6nig <tk@tkoenig.net>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <assert.h>\n+\n+#if defined (HAVE_GFC_INTEGER_8)\n+extern void findloc0_i8 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_i8 * const restrict array, GFC_INTEGER_8 value,\n+\t\t\t GFC_LOGICAL_4);\n+export_proto(findloc0_i8);\n+\n+void\n+findloc0_i8 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_i8 * const restrict array, GFC_INTEGER_8 value,\n+\t    GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_INTEGER_8 *base;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type sz;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"FINDLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+\n+  /* Set the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+\n+  sz = 1;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      sz *= extent[n];\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+    for (n = 0; n < rank; n++)\n+      count[n] = 0;\n+\n+  if (back)\n+    {\n+      base = array->base_addr + (sz - 1) * 1;\n+\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = extent[n] - count[n];\n+\n+\t\t  return;\n+\t\t}\n+\t      base -= sstride[0] * 1;\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base += sstride[n] * extent[n] * 1;\n+\t      n++;\n+\t      if (n >= rank)\n+\t        return;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base -= sstride[n] * 1;\n+\t\t}\n+\t    } while (count[n] == extent[n]);      \n+\t}\n+    }\n+  else\n+    {\n+      base = array->base_addr;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\n+\t\t  return;\n+\t\t}\n+\t      base += sstride[0] * 1;\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base -= sstride[n] * extent[n] * 1;\n+\t      n++;\n+\t      if (n >= rank)\n+\t        return;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base += sstride[n] * 1;\n+\t\t}\n+\t    } while (count[n] == extent[n]);\n+\t}\n+    }\n+  return;\n+}\n+\n+extern void mfindloc0_i8 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_i8 * const restrict array, GFC_INTEGER_8 value,\n+\t\t\t gfc_array_l1 *const restrict, GFC_LOGICAL_4);\n+export_proto(mfindloc0_i8);\n+\n+void\n+mfindloc0_i8 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_i8 * const restrict array, GFC_INTEGER_8 value,\n+\t    gfc_array_l1 *const restrict mask, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_INTEGER_8 *base;\n+  index_type * restrict dest;\n+  GFC_LOGICAL_1 *mbase;\n+  index_type rank;\n+  index_type n;\n+  int mask_kind;\n+  index_type sz;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"FINDLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t\"MASK argument\", \"FINDLOC\");\n+\t}\n+    }\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+\n+  /* Set the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+\n+  sz = 1;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      sz *= extent[n];\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+    for (n = 0; n < rank; n++)\n+      count[n] = 0;\n+\n+  if (back)\n+    {\n+      base = array->base_addr + (sz - 1) * 1;\n+      mbase = mbase + (sz - 1) * mask_kind;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*mbase && *base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = extent[n] - count[n];\n+\n+\t\t  return;\n+\t\t}\n+\t      base -= sstride[0] * 1;\n+\t      mbase -= mstride[0];\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base += sstride[n] * extent[n] * 1;\n+\t      mbase -= mstride[n] * extent[n];\n+\t      n++;\n+\t      if (n >= rank)\n+\t\treturn;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base -= sstride[n] * 1;\n+\t\t  mbase += mstride[n];\n+\t\t}\n+\t    } while (count[n] == extent[n]);      \n+\t}\n+    }\n+  else\n+    {\n+      base = array->base_addr;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*mbase && *base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\n+\t\t  return;\n+\t\t}\n+\t      base += sstride[0] * 1;\n+\t      mbase += mstride[0];\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base -= sstride[n] * extent[n] * 1;\n+\t      mbase -= mstride[n] * extent[n];\n+\t      n++;\n+\t      if (n >= rank)\n+\t\treturn;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base += sstride[n]* 1;\n+\t\t  mbase += mstride[n];\n+\t\t}\n+\t    } while (count[n] == extent[n]);\n+\t}\n+    }\n+  return;\n+}\n+\n+extern void sfindloc0_i8 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_i8 * const restrict array, GFC_INTEGER_8 value,\n+\t\t\t GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n+export_proto(sfindloc0_i8);\n+\n+void\n+sfindloc0_i8 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_i8 * const restrict array, GFC_INTEGER_8 value,\n+\t    GFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type * restrict dest;\n+  index_type n;\n+\n+  if (*mask)\n+    {\n+      findloc0_i8 (retarray, array, value, back);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    internal_error (NULL, \"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"FINDLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n+\n+#endif"}, {"sha": "23ecd98a55de9c6cfdce81a3002bd70c9935b046", "filename": "libgfortran/generated/findloc0_r16.c", "status": "added", "additions": 375, "deletions": 0, "changes": 375, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc0_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc0_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ffindloc0_r16.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -0,0 +1,375 @@\n+\n+/* Implementation of the FINDLOC intrinsic\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by Thomas K\u00f6nig <tk@tkoenig.net>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <assert.h>\n+\n+#if defined (HAVE_GFC_REAL_16)\n+extern void findloc0_r16 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_r16 * const restrict array, GFC_REAL_16 value,\n+\t\t\t GFC_LOGICAL_4);\n+export_proto(findloc0_r16);\n+\n+void\n+findloc0_r16 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_r16 * const restrict array, GFC_REAL_16 value,\n+\t    GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_REAL_16 *base;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type sz;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"FINDLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+\n+  /* Set the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+\n+  sz = 1;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      sz *= extent[n];\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+    for (n = 0; n < rank; n++)\n+      count[n] = 0;\n+\n+  if (back)\n+    {\n+      base = array->base_addr + (sz - 1) * 1;\n+\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = extent[n] - count[n];\n+\n+\t\t  return;\n+\t\t}\n+\t      base -= sstride[0] * 1;\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base += sstride[n] * extent[n] * 1;\n+\t      n++;\n+\t      if (n >= rank)\n+\t        return;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base -= sstride[n] * 1;\n+\t\t}\n+\t    } while (count[n] == extent[n]);      \n+\t}\n+    }\n+  else\n+    {\n+      base = array->base_addr;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\n+\t\t  return;\n+\t\t}\n+\t      base += sstride[0] * 1;\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base -= sstride[n] * extent[n] * 1;\n+\t      n++;\n+\t      if (n >= rank)\n+\t        return;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base += sstride[n] * 1;\n+\t\t}\n+\t    } while (count[n] == extent[n]);\n+\t}\n+    }\n+  return;\n+}\n+\n+extern void mfindloc0_r16 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_r16 * const restrict array, GFC_REAL_16 value,\n+\t\t\t gfc_array_l1 *const restrict, GFC_LOGICAL_4);\n+export_proto(mfindloc0_r16);\n+\n+void\n+mfindloc0_r16 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_r16 * const restrict array, GFC_REAL_16 value,\n+\t    gfc_array_l1 *const restrict mask, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_REAL_16 *base;\n+  index_type * restrict dest;\n+  GFC_LOGICAL_1 *mbase;\n+  index_type rank;\n+  index_type n;\n+  int mask_kind;\n+  index_type sz;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"FINDLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t\"MASK argument\", \"FINDLOC\");\n+\t}\n+    }\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+\n+  /* Set the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+\n+  sz = 1;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      sz *= extent[n];\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+    for (n = 0; n < rank; n++)\n+      count[n] = 0;\n+\n+  if (back)\n+    {\n+      base = array->base_addr + (sz - 1) * 1;\n+      mbase = mbase + (sz - 1) * mask_kind;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*mbase && *base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = extent[n] - count[n];\n+\n+\t\t  return;\n+\t\t}\n+\t      base -= sstride[0] * 1;\n+\t      mbase -= mstride[0];\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base += sstride[n] * extent[n] * 1;\n+\t      mbase -= mstride[n] * extent[n];\n+\t      n++;\n+\t      if (n >= rank)\n+\t\treturn;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base -= sstride[n] * 1;\n+\t\t  mbase += mstride[n];\n+\t\t}\n+\t    } while (count[n] == extent[n]);      \n+\t}\n+    }\n+  else\n+    {\n+      base = array->base_addr;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*mbase && *base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\n+\t\t  return;\n+\t\t}\n+\t      base += sstride[0] * 1;\n+\t      mbase += mstride[0];\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base -= sstride[n] * extent[n] * 1;\n+\t      mbase -= mstride[n] * extent[n];\n+\t      n++;\n+\t      if (n >= rank)\n+\t\treturn;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base += sstride[n]* 1;\n+\t\t  mbase += mstride[n];\n+\t\t}\n+\t    } while (count[n] == extent[n]);\n+\t}\n+    }\n+  return;\n+}\n+\n+extern void sfindloc0_r16 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_r16 * const restrict array, GFC_REAL_16 value,\n+\t\t\t GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n+export_proto(sfindloc0_r16);\n+\n+void\n+sfindloc0_r16 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_r16 * const restrict array, GFC_REAL_16 value,\n+\t    GFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type * restrict dest;\n+  index_type n;\n+\n+  if (*mask)\n+    {\n+      findloc0_r16 (retarray, array, value, back);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    internal_error (NULL, \"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"FINDLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n+\n+#endif"}, {"sha": "08d59e956b2fefd18e057884dc0f652cc426d1f1", "filename": "libgfortran/generated/findloc0_r4.c", "status": "added", "additions": 375, "deletions": 0, "changes": 375, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc0_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc0_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ffindloc0_r4.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -0,0 +1,375 @@\n+\n+/* Implementation of the FINDLOC intrinsic\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by Thomas K\u00f6nig <tk@tkoenig.net>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <assert.h>\n+\n+#if defined (HAVE_GFC_REAL_4)\n+extern void findloc0_r4 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_r4 * const restrict array, GFC_REAL_4 value,\n+\t\t\t GFC_LOGICAL_4);\n+export_proto(findloc0_r4);\n+\n+void\n+findloc0_r4 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_r4 * const restrict array, GFC_REAL_4 value,\n+\t    GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_REAL_4 *base;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type sz;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"FINDLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+\n+  /* Set the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+\n+  sz = 1;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      sz *= extent[n];\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+    for (n = 0; n < rank; n++)\n+      count[n] = 0;\n+\n+  if (back)\n+    {\n+      base = array->base_addr + (sz - 1) * 1;\n+\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = extent[n] - count[n];\n+\n+\t\t  return;\n+\t\t}\n+\t      base -= sstride[0] * 1;\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base += sstride[n] * extent[n] * 1;\n+\t      n++;\n+\t      if (n >= rank)\n+\t        return;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base -= sstride[n] * 1;\n+\t\t}\n+\t    } while (count[n] == extent[n]);      \n+\t}\n+    }\n+  else\n+    {\n+      base = array->base_addr;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\n+\t\t  return;\n+\t\t}\n+\t      base += sstride[0] * 1;\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base -= sstride[n] * extent[n] * 1;\n+\t      n++;\n+\t      if (n >= rank)\n+\t        return;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base += sstride[n] * 1;\n+\t\t}\n+\t    } while (count[n] == extent[n]);\n+\t}\n+    }\n+  return;\n+}\n+\n+extern void mfindloc0_r4 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_r4 * const restrict array, GFC_REAL_4 value,\n+\t\t\t gfc_array_l1 *const restrict, GFC_LOGICAL_4);\n+export_proto(mfindloc0_r4);\n+\n+void\n+mfindloc0_r4 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_r4 * const restrict array, GFC_REAL_4 value,\n+\t    gfc_array_l1 *const restrict mask, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_REAL_4 *base;\n+  index_type * restrict dest;\n+  GFC_LOGICAL_1 *mbase;\n+  index_type rank;\n+  index_type n;\n+  int mask_kind;\n+  index_type sz;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"FINDLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t\"MASK argument\", \"FINDLOC\");\n+\t}\n+    }\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+\n+  /* Set the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+\n+  sz = 1;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      sz *= extent[n];\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+    for (n = 0; n < rank; n++)\n+      count[n] = 0;\n+\n+  if (back)\n+    {\n+      base = array->base_addr + (sz - 1) * 1;\n+      mbase = mbase + (sz - 1) * mask_kind;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*mbase && *base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = extent[n] - count[n];\n+\n+\t\t  return;\n+\t\t}\n+\t      base -= sstride[0] * 1;\n+\t      mbase -= mstride[0];\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base += sstride[n] * extent[n] * 1;\n+\t      mbase -= mstride[n] * extent[n];\n+\t      n++;\n+\t      if (n >= rank)\n+\t\treturn;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base -= sstride[n] * 1;\n+\t\t  mbase += mstride[n];\n+\t\t}\n+\t    } while (count[n] == extent[n]);      \n+\t}\n+    }\n+  else\n+    {\n+      base = array->base_addr;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*mbase && *base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\n+\t\t  return;\n+\t\t}\n+\t      base += sstride[0] * 1;\n+\t      mbase += mstride[0];\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base -= sstride[n] * extent[n] * 1;\n+\t      mbase -= mstride[n] * extent[n];\n+\t      n++;\n+\t      if (n >= rank)\n+\t\treturn;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base += sstride[n]* 1;\n+\t\t  mbase += mstride[n];\n+\t\t}\n+\t    } while (count[n] == extent[n]);\n+\t}\n+    }\n+  return;\n+}\n+\n+extern void sfindloc0_r4 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_r4 * const restrict array, GFC_REAL_4 value,\n+\t\t\t GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n+export_proto(sfindloc0_r4);\n+\n+void\n+sfindloc0_r4 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_r4 * const restrict array, GFC_REAL_4 value,\n+\t    GFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type * restrict dest;\n+  index_type n;\n+\n+  if (*mask)\n+    {\n+      findloc0_r4 (retarray, array, value, back);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    internal_error (NULL, \"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"FINDLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n+\n+#endif"}, {"sha": "c7315318b86e951b16200ce0fb1289d601f94322", "filename": "libgfortran/generated/findloc0_r8.c", "status": "added", "additions": 375, "deletions": 0, "changes": 375, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc0_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc0_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ffindloc0_r8.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -0,0 +1,375 @@\n+\n+/* Implementation of the FINDLOC intrinsic\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by Thomas K\u00f6nig <tk@tkoenig.net>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <assert.h>\n+\n+#if defined (HAVE_GFC_REAL_8)\n+extern void findloc0_r8 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_r8 * const restrict array, GFC_REAL_8 value,\n+\t\t\t GFC_LOGICAL_4);\n+export_proto(findloc0_r8);\n+\n+void\n+findloc0_r8 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_r8 * const restrict array, GFC_REAL_8 value,\n+\t    GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_REAL_8 *base;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type sz;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"FINDLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+\n+  /* Set the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+\n+  sz = 1;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      sz *= extent[n];\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+    for (n = 0; n < rank; n++)\n+      count[n] = 0;\n+\n+  if (back)\n+    {\n+      base = array->base_addr + (sz - 1) * 1;\n+\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = extent[n] - count[n];\n+\n+\t\t  return;\n+\t\t}\n+\t      base -= sstride[0] * 1;\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base += sstride[n] * extent[n] * 1;\n+\t      n++;\n+\t      if (n >= rank)\n+\t        return;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base -= sstride[n] * 1;\n+\t\t}\n+\t    } while (count[n] == extent[n]);      \n+\t}\n+    }\n+  else\n+    {\n+      base = array->base_addr;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\n+\t\t  return;\n+\t\t}\n+\t      base += sstride[0] * 1;\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base -= sstride[n] * extent[n] * 1;\n+\t      n++;\n+\t      if (n >= rank)\n+\t        return;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base += sstride[n] * 1;\n+\t\t}\n+\t    } while (count[n] == extent[n]);\n+\t}\n+    }\n+  return;\n+}\n+\n+extern void mfindloc0_r8 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_r8 * const restrict array, GFC_REAL_8 value,\n+\t\t\t gfc_array_l1 *const restrict, GFC_LOGICAL_4);\n+export_proto(mfindloc0_r8);\n+\n+void\n+mfindloc0_r8 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_r8 * const restrict array, GFC_REAL_8 value,\n+\t    gfc_array_l1 *const restrict mask, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_REAL_8 *base;\n+  index_type * restrict dest;\n+  GFC_LOGICAL_1 *mbase;\n+  index_type rank;\n+  index_type n;\n+  int mask_kind;\n+  index_type sz;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"FINDLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t\"MASK argument\", \"FINDLOC\");\n+\t}\n+    }\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+\n+  /* Set the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+\n+  sz = 1;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      sz *= extent[n];\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+    for (n = 0; n < rank; n++)\n+      count[n] = 0;\n+\n+  if (back)\n+    {\n+      base = array->base_addr + (sz - 1) * 1;\n+      mbase = mbase + (sz - 1) * mask_kind;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*mbase && *base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = extent[n] - count[n];\n+\n+\t\t  return;\n+\t\t}\n+\t      base -= sstride[0] * 1;\n+\t      mbase -= mstride[0];\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base += sstride[n] * extent[n] * 1;\n+\t      mbase -= mstride[n] * extent[n];\n+\t      n++;\n+\t      if (n >= rank)\n+\t\treturn;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base -= sstride[n] * 1;\n+\t\t  mbase += mstride[n];\n+\t\t}\n+\t    } while (count[n] == extent[n]);      \n+\t}\n+    }\n+  else\n+    {\n+      base = array->base_addr;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*mbase && *base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\n+\t\t  return;\n+\t\t}\n+\t      base += sstride[0] * 1;\n+\t      mbase += mstride[0];\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base -= sstride[n] * extent[n] * 1;\n+\t      mbase -= mstride[n] * extent[n];\n+\t      n++;\n+\t      if (n >= rank)\n+\t\treturn;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base += sstride[n]* 1;\n+\t\t  mbase += mstride[n];\n+\t\t}\n+\t    } while (count[n] == extent[n]);\n+\t}\n+    }\n+  return;\n+}\n+\n+extern void sfindloc0_r8 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_r8 * const restrict array, GFC_REAL_8 value,\n+\t\t\t GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n+export_proto(sfindloc0_r8);\n+\n+void\n+sfindloc0_r8 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_r8 * const restrict array, GFC_REAL_8 value,\n+\t    GFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type * restrict dest;\n+  index_type n;\n+\n+  if (*mask)\n+    {\n+      findloc0_r8 (retarray, array, value, back);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    internal_error (NULL, \"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"FINDLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n+\n+#endif"}, {"sha": "3b0f9b07349af572d1691579a5bd704a9a7b0659", "filename": "libgfortran/generated/findloc0_s1.c", "status": "added", "additions": 383, "deletions": 0, "changes": 383, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc0_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc0_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ffindloc0_s1.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -0,0 +1,383 @@\n+\n+/* Implementation of the FINDLOC intrinsic\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by Thomas K\u00f6nig <tk@tkoenig.net>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <assert.h>\n+\n+#if defined (HAVE_GFC_UINTEGER_1)\n+extern void findloc0_s1 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_s1 * const restrict array, GFC_UINTEGER_1 *value,\n+\t\t\t GFC_LOGICAL_4 back, gfc_charlen_type len_array, gfc_charlen_type len_value);\n+\n+export_proto(findloc0_s1);\n+\n+void\n+findloc0_s1 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_s1 * const restrict array, GFC_UINTEGER_1 *value,\n+\t    GFC_LOGICAL_4 back, gfc_charlen_type len_array, gfc_charlen_type len_value)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_UINTEGER_1 *base;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type sz;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"FINDLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+\n+  /* Set the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+\n+  sz = 1;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      sz *= extent[n];\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+    for (n = 0; n < rank; n++)\n+      count[n] = 0;\n+\n+  if (back)\n+    {\n+      base = array->base_addr + (sz - 1) * len_array;\n+\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(compare_string (len_array, (char *) base, len_value, (char *) value) == 0))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = extent[n] - count[n];\n+\n+\t\t  return;\n+\t\t}\n+\t      base -= sstride[0] * len_array;\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base += sstride[n] * extent[n] * len_array;\n+\t      n++;\n+\t      if (n >= rank)\n+\t        return;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base -= sstride[n] * len_array;\n+\t\t}\n+\t    } while (count[n] == extent[n]);      \n+\t}\n+    }\n+  else\n+    {\n+      base = array->base_addr;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(compare_string (len_array, (char *) base, len_value, (char *) value) == 0))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\n+\t\t  return;\n+\t\t}\n+\t      base += sstride[0] * len_array;\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base -= sstride[n] * extent[n] * len_array;\n+\t      n++;\n+\t      if (n >= rank)\n+\t        return;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base += sstride[n] * len_array;\n+\t\t}\n+\t    } while (count[n] == extent[n]);\n+\t}\n+    }\n+  return;\n+}\n+\n+extern void mfindloc0_s1 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_s1 * const restrict array, GFC_UINTEGER_1 *value,\n+\t\t\t gfc_array_l1 *const restrict, GFC_LOGICAL_4 back, gfc_charlen_type len_array,\n+\t\t\t gfc_charlen_type len_value);\n+export_proto(mfindloc0_s1);\n+\n+void\n+mfindloc0_s1 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_s1 * const restrict array, GFC_UINTEGER_1 *value,\n+\t    gfc_array_l1 *const restrict mask, GFC_LOGICAL_4 back,\n+\t    gfc_charlen_type len_array, gfc_charlen_type len_value)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_UINTEGER_1 *base;\n+  index_type * restrict dest;\n+  GFC_LOGICAL_1 *mbase;\n+  index_type rank;\n+  index_type n;\n+  int mask_kind;\n+  index_type sz;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"FINDLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t\"MASK argument\", \"FINDLOC\");\n+\t}\n+    }\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+\n+  /* Set the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+\n+  sz = 1;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      sz *= extent[n];\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+    for (n = 0; n < rank; n++)\n+      count[n] = 0;\n+\n+  if (back)\n+    {\n+      base = array->base_addr + (sz - 1) * len_array;\n+      mbase = mbase + (sz - 1) * mask_kind;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*mbase && compare_string (len_array, (char *) base, len_value, (char *) value) == 0))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = extent[n] - count[n];\n+\n+\t\t  return;\n+\t\t}\n+\t      base -= sstride[0] * len_array;\n+\t      mbase -= mstride[0];\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base += sstride[n] * extent[n] * len_array;\n+\t      mbase -= mstride[n] * extent[n];\n+\t      n++;\n+\t      if (n >= rank)\n+\t\treturn;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base -= sstride[n] * len_array;\n+\t\t  mbase += mstride[n];\n+\t\t}\n+\t    } while (count[n] == extent[n]);      \n+\t}\n+    }\n+  else\n+    {\n+      base = array->base_addr;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*mbase && compare_string (len_array, (char *) base, len_value, (char *) value) == 0))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\n+\t\t  return;\n+\t\t}\n+\t      base += sstride[0] * len_array;\n+\t      mbase += mstride[0];\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base -= sstride[n] * extent[n] * len_array;\n+\t      mbase -= mstride[n] * extent[n];\n+\t      n++;\n+\t      if (n >= rank)\n+\t\treturn;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base += sstride[n]* len_array;\n+\t\t  mbase += mstride[n];\n+\t\t}\n+\t    } while (count[n] == extent[n]);\n+\t}\n+    }\n+  return;\n+}\n+\n+extern void sfindloc0_s1 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_s1 * const restrict array, GFC_UINTEGER_1 *value,\n+\t\t\t GFC_LOGICAL_4 *, GFC_LOGICAL_4 back, gfc_charlen_type len_array,\n+\t\t\t gfc_charlen_type len_value);\n+export_proto(sfindloc0_s1);\n+\n+void\n+sfindloc0_s1 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_s1 * const restrict array, GFC_UINTEGER_1 *value,\n+\t    GFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back, gfc_charlen_type len_array,\n+\t    gfc_charlen_type len_value)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type * restrict dest;\n+  index_type n;\n+\n+  if (*mask)\n+    {\n+      findloc0_s1 (retarray, array, value, back, len_array, len_value);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    internal_error (NULL, \"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"FINDLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n+\n+#endif\n+\n+\n+"}, {"sha": "fa23503a894bc15948d2d0d15ec41a4fdd2d9ed1", "filename": "libgfortran/generated/findloc0_s4.c", "status": "added", "additions": 383, "deletions": 0, "changes": 383, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc0_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc0_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ffindloc0_s4.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -0,0 +1,383 @@\n+\n+/* Implementation of the FINDLOC intrinsic\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by Thomas K\u00f6nig <tk@tkoenig.net>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <assert.h>\n+\n+#if defined (HAVE_GFC_UINTEGER_4)\n+extern void findloc0_s4 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_s4 * const restrict array, GFC_UINTEGER_4 *value,\n+\t\t\t GFC_LOGICAL_4 back, gfc_charlen_type len_array, gfc_charlen_type len_value);\n+\n+export_proto(findloc0_s4);\n+\n+void\n+findloc0_s4 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_s4 * const restrict array, GFC_UINTEGER_4 *value,\n+\t    GFC_LOGICAL_4 back, gfc_charlen_type len_array, gfc_charlen_type len_value)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_UINTEGER_4 *base;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type sz;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"FINDLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+\n+  /* Set the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+\n+  sz = 1;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      sz *= extent[n];\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+    for (n = 0; n < rank; n++)\n+      count[n] = 0;\n+\n+  if (back)\n+    {\n+      base = array->base_addr + (sz - 1) * len_array;\n+\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(compare_string_char4 (len_array, base, len_value, value) == 0))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = extent[n] - count[n];\n+\n+\t\t  return;\n+\t\t}\n+\t      base -= sstride[0] * len_array;\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base += sstride[n] * extent[n] * len_array;\n+\t      n++;\n+\t      if (n >= rank)\n+\t        return;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base -= sstride[n] * len_array;\n+\t\t}\n+\t    } while (count[n] == extent[n]);      \n+\t}\n+    }\n+  else\n+    {\n+      base = array->base_addr;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(compare_string_char4 (len_array, base, len_value, value) == 0))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\n+\t\t  return;\n+\t\t}\n+\t      base += sstride[0] * len_array;\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base -= sstride[n] * extent[n] * len_array;\n+\t      n++;\n+\t      if (n >= rank)\n+\t        return;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base += sstride[n] * len_array;\n+\t\t}\n+\t    } while (count[n] == extent[n]);\n+\t}\n+    }\n+  return;\n+}\n+\n+extern void mfindloc0_s4 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_s4 * const restrict array, GFC_UINTEGER_4 *value,\n+\t\t\t gfc_array_l1 *const restrict, GFC_LOGICAL_4 back, gfc_charlen_type len_array,\n+\t\t\t gfc_charlen_type len_value);\n+export_proto(mfindloc0_s4);\n+\n+void\n+mfindloc0_s4 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_s4 * const restrict array, GFC_UINTEGER_4 *value,\n+\t    gfc_array_l1 *const restrict mask, GFC_LOGICAL_4 back,\n+\t    gfc_charlen_type len_array, gfc_charlen_type len_value)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_UINTEGER_4 *base;\n+  index_type * restrict dest;\n+  GFC_LOGICAL_1 *mbase;\n+  index_type rank;\n+  index_type n;\n+  int mask_kind;\n+  index_type sz;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"FINDLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t\"MASK argument\", \"FINDLOC\");\n+\t}\n+    }\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+\n+  /* Set the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+\n+  sz = 1;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      sz *= extent[n];\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+    for (n = 0; n < rank; n++)\n+      count[n] = 0;\n+\n+  if (back)\n+    {\n+      base = array->base_addr + (sz - 1) * len_array;\n+      mbase = mbase + (sz - 1) * mask_kind;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*mbase && compare_string_char4 (len_array, base, len_value, value) == 0))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = extent[n] - count[n];\n+\n+\t\t  return;\n+\t\t}\n+\t      base -= sstride[0] * len_array;\n+\t      mbase -= mstride[0];\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base += sstride[n] * extent[n] * len_array;\n+\t      mbase -= mstride[n] * extent[n];\n+\t      n++;\n+\t      if (n >= rank)\n+\t\treturn;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base -= sstride[n] * len_array;\n+\t\t  mbase += mstride[n];\n+\t\t}\n+\t    } while (count[n] == extent[n]);      \n+\t}\n+    }\n+  else\n+    {\n+      base = array->base_addr;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*mbase && compare_string_char4 (len_array, base, len_value, value) == 0))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\n+\t\t  return;\n+\t\t}\n+\t      base += sstride[0] * len_array;\n+\t      mbase += mstride[0];\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base -= sstride[n] * extent[n] * len_array;\n+\t      mbase -= mstride[n] * extent[n];\n+\t      n++;\n+\t      if (n >= rank)\n+\t\treturn;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base += sstride[n]* len_array;\n+\t\t  mbase += mstride[n];\n+\t\t}\n+\t    } while (count[n] == extent[n]);\n+\t}\n+    }\n+  return;\n+}\n+\n+extern void sfindloc0_s4 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_s4 * const restrict array, GFC_UINTEGER_4 *value,\n+\t\t\t GFC_LOGICAL_4 *, GFC_LOGICAL_4 back, gfc_charlen_type len_array,\n+\t\t\t gfc_charlen_type len_value);\n+export_proto(sfindloc0_s4);\n+\n+void\n+sfindloc0_s4 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_s4 * const restrict array, GFC_UINTEGER_4 *value,\n+\t    GFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back, gfc_charlen_type len_array,\n+\t    gfc_charlen_type len_value)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type * restrict dest;\n+  index_type n;\n+\n+  if (*mask)\n+    {\n+      findloc0_s4 (retarray, array, value, back, len_array, len_value);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    internal_error (NULL, \"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"FINDLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n+\n+#endif\n+\n+\n+"}, {"sha": "3c03c0b85ea77da272238aec53742181a8fe37db", "filename": "libgfortran/generated/findloc1_c16.c", "status": "added", "additions": 523, "deletions": 0, "changes": 523, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc1_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc1_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ffindloc1_c16.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -0,0 +1,523 @@\n+/* Implementation of the FINDLOC intrinsic\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by Thomas K\u00f6nig <tk@tkoenig.net>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <assert.h>\n+\n+#if defined (HAVE_GFC_COMPLEX_16)\n+extern void findloc1_c16 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_c16 * const restrict array, GFC_COMPLEX_16 value,\n+\t\t\t const index_type * restrict pdim, GFC_LOGICAL_4 back);\n+export_proto(findloc1_c16);\n+\n+extern void\n+findloc1_c16 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_c16 * const restrict array, GFC_COMPLEX_16 value,\n+\t    const index_type * restrict pdim, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_COMPLEX_16 * restrict base;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  base = array->base_addr;\n+  while (continue_loop)\n+    {\n+      const GFC_COMPLEX_16 * restrict src;\n+      index_type result;\n+\n+      result = 0;\n+      if (back)\n+\t{\n+\t  src = base + (len - 1) * delta * 1;\n+\t  for (n = len; n > 0; n--, src -= delta * 1)\n+\t    {\n+\t      if (*src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  src = base;\n+\t  for (n = 1; n <= len; n++, src += delta * 1)\n+\t    {\n+\t      if (*src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      *dest = result;\n+\n+      count[0]++;\n+      base += sstride[0] * 1;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  base -= sstride[n] * extent[n] * 1;\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n] * 1;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+extern void mfindloc1_c16 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_c16 * const restrict array, GFC_COMPLEX_16 value,\n+\t\t\t const index_type * restrict pdim, gfc_array_l1 *const restrict mask,\n+\t\t\t GFC_LOGICAL_4 back);\n+export_proto(mfindloc1_c16);\n+\n+extern void\n+mfindloc1_c16 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_c16 * const restrict array, GFC_COMPLEX_16 value,\n+\t    const index_type * restrict pdim, gfc_array_l1 *const restrict mask,\n+\t    GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_COMPLEX_16 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  index_type dim;\n+  int mask_kind;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  mbase = mask->base_addr;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  base = array->base_addr;\n+  while (continue_loop)\n+    {\n+      const GFC_COMPLEX_16 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      index_type result;\n+\n+      result = 0;\n+      if (back)\n+\t{\n+\t  src = base + (len - 1) * delta * 1;\n+\t  msrc = mbase + (len - 1) * mdelta; \n+\t  for (n = len; n > 0; n--, src -= delta * 1, msrc -= mdelta)\n+\t    {\n+\t      if (*msrc && *src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  src = base;\n+\t  msrc = mbase;\n+\t  for (n = 1; n <= len; n++, src += delta * 1, msrc += mdelta)\n+\t    {\n+\t      if (*msrc && *src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      *dest = result;\n+\n+      count[0]++;\n+      base += sstride[0] * 1;\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  base -= sstride[n] * extent[n] * 1;\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n] * 1;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+extern void sfindloc1_c16 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_c16 * const restrict array, GFC_COMPLEX_16 value,\n+\t\t\t const index_type * restrict pdim, GFC_LOGICAL_4 *const restrict mask,\n+\t\t\t GFC_LOGICAL_4 back);\n+export_proto(sfindloc1_c16);\n+\n+extern void\n+sfindloc1_c16 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_c16 * const restrict array, GFC_COMPLEX_16 value,\n+\t    const index_type * restrict pdim, GFC_LOGICAL_4 *const restrict  mask,\n+\t    GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type dim;\n+  bool continue_loop;\n+\n+  if (*mask)\n+    {\n+      findloc1_c16 (retarray, array, value, pdim, back);\n+      return;\n+    }\n+    /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  while (continue_loop)\n+    {\n+      *dest = 0;\n+\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+#endif"}, {"sha": "6355e2b356f25e8ba50385e98d24c1bb5149f700", "filename": "libgfortran/generated/findloc1_c4.c", "status": "added", "additions": 523, "deletions": 0, "changes": 523, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc1_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc1_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ffindloc1_c4.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -0,0 +1,523 @@\n+/* Implementation of the FINDLOC intrinsic\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by Thomas K\u00f6nig <tk@tkoenig.net>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <assert.h>\n+\n+#if defined (HAVE_GFC_COMPLEX_4)\n+extern void findloc1_c4 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_c4 * const restrict array, GFC_COMPLEX_4 value,\n+\t\t\t const index_type * restrict pdim, GFC_LOGICAL_4 back);\n+export_proto(findloc1_c4);\n+\n+extern void\n+findloc1_c4 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_c4 * const restrict array, GFC_COMPLEX_4 value,\n+\t    const index_type * restrict pdim, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_COMPLEX_4 * restrict base;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  base = array->base_addr;\n+  while (continue_loop)\n+    {\n+      const GFC_COMPLEX_4 * restrict src;\n+      index_type result;\n+\n+      result = 0;\n+      if (back)\n+\t{\n+\t  src = base + (len - 1) * delta * 1;\n+\t  for (n = len; n > 0; n--, src -= delta * 1)\n+\t    {\n+\t      if (*src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  src = base;\n+\t  for (n = 1; n <= len; n++, src += delta * 1)\n+\t    {\n+\t      if (*src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      *dest = result;\n+\n+      count[0]++;\n+      base += sstride[0] * 1;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  base -= sstride[n] * extent[n] * 1;\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n] * 1;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+extern void mfindloc1_c4 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_c4 * const restrict array, GFC_COMPLEX_4 value,\n+\t\t\t const index_type * restrict pdim, gfc_array_l1 *const restrict mask,\n+\t\t\t GFC_LOGICAL_4 back);\n+export_proto(mfindloc1_c4);\n+\n+extern void\n+mfindloc1_c4 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_c4 * const restrict array, GFC_COMPLEX_4 value,\n+\t    const index_type * restrict pdim, gfc_array_l1 *const restrict mask,\n+\t    GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_COMPLEX_4 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  index_type dim;\n+  int mask_kind;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  mbase = mask->base_addr;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  base = array->base_addr;\n+  while (continue_loop)\n+    {\n+      const GFC_COMPLEX_4 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      index_type result;\n+\n+      result = 0;\n+      if (back)\n+\t{\n+\t  src = base + (len - 1) * delta * 1;\n+\t  msrc = mbase + (len - 1) * mdelta; \n+\t  for (n = len; n > 0; n--, src -= delta * 1, msrc -= mdelta)\n+\t    {\n+\t      if (*msrc && *src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  src = base;\n+\t  msrc = mbase;\n+\t  for (n = 1; n <= len; n++, src += delta * 1, msrc += mdelta)\n+\t    {\n+\t      if (*msrc && *src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      *dest = result;\n+\n+      count[0]++;\n+      base += sstride[0] * 1;\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  base -= sstride[n] * extent[n] * 1;\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n] * 1;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+extern void sfindloc1_c4 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_c4 * const restrict array, GFC_COMPLEX_4 value,\n+\t\t\t const index_type * restrict pdim, GFC_LOGICAL_4 *const restrict mask,\n+\t\t\t GFC_LOGICAL_4 back);\n+export_proto(sfindloc1_c4);\n+\n+extern void\n+sfindloc1_c4 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_c4 * const restrict array, GFC_COMPLEX_4 value,\n+\t    const index_type * restrict pdim, GFC_LOGICAL_4 *const restrict  mask,\n+\t    GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type dim;\n+  bool continue_loop;\n+\n+  if (*mask)\n+    {\n+      findloc1_c4 (retarray, array, value, pdim, back);\n+      return;\n+    }\n+    /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  while (continue_loop)\n+    {\n+      *dest = 0;\n+\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+#endif"}, {"sha": "dec51727808b7891e7df0a0f78f80cc6600dc0ed", "filename": "libgfortran/generated/findloc1_c8.c", "status": "added", "additions": 523, "deletions": 0, "changes": 523, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc1_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc1_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ffindloc1_c8.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -0,0 +1,523 @@\n+/* Implementation of the FINDLOC intrinsic\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by Thomas K\u00f6nig <tk@tkoenig.net>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <assert.h>\n+\n+#if defined (HAVE_GFC_COMPLEX_8)\n+extern void findloc1_c8 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_c8 * const restrict array, GFC_COMPLEX_8 value,\n+\t\t\t const index_type * restrict pdim, GFC_LOGICAL_4 back);\n+export_proto(findloc1_c8);\n+\n+extern void\n+findloc1_c8 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_c8 * const restrict array, GFC_COMPLEX_8 value,\n+\t    const index_type * restrict pdim, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_COMPLEX_8 * restrict base;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  base = array->base_addr;\n+  while (continue_loop)\n+    {\n+      const GFC_COMPLEX_8 * restrict src;\n+      index_type result;\n+\n+      result = 0;\n+      if (back)\n+\t{\n+\t  src = base + (len - 1) * delta * 1;\n+\t  for (n = len; n > 0; n--, src -= delta * 1)\n+\t    {\n+\t      if (*src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  src = base;\n+\t  for (n = 1; n <= len; n++, src += delta * 1)\n+\t    {\n+\t      if (*src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      *dest = result;\n+\n+      count[0]++;\n+      base += sstride[0] * 1;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  base -= sstride[n] * extent[n] * 1;\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n] * 1;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+extern void mfindloc1_c8 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_c8 * const restrict array, GFC_COMPLEX_8 value,\n+\t\t\t const index_type * restrict pdim, gfc_array_l1 *const restrict mask,\n+\t\t\t GFC_LOGICAL_4 back);\n+export_proto(mfindloc1_c8);\n+\n+extern void\n+mfindloc1_c8 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_c8 * const restrict array, GFC_COMPLEX_8 value,\n+\t    const index_type * restrict pdim, gfc_array_l1 *const restrict mask,\n+\t    GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_COMPLEX_8 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  index_type dim;\n+  int mask_kind;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  mbase = mask->base_addr;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  base = array->base_addr;\n+  while (continue_loop)\n+    {\n+      const GFC_COMPLEX_8 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      index_type result;\n+\n+      result = 0;\n+      if (back)\n+\t{\n+\t  src = base + (len - 1) * delta * 1;\n+\t  msrc = mbase + (len - 1) * mdelta; \n+\t  for (n = len; n > 0; n--, src -= delta * 1, msrc -= mdelta)\n+\t    {\n+\t      if (*msrc && *src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  src = base;\n+\t  msrc = mbase;\n+\t  for (n = 1; n <= len; n++, src += delta * 1, msrc += mdelta)\n+\t    {\n+\t      if (*msrc && *src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      *dest = result;\n+\n+      count[0]++;\n+      base += sstride[0] * 1;\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  base -= sstride[n] * extent[n] * 1;\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n] * 1;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+extern void sfindloc1_c8 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_c8 * const restrict array, GFC_COMPLEX_8 value,\n+\t\t\t const index_type * restrict pdim, GFC_LOGICAL_4 *const restrict mask,\n+\t\t\t GFC_LOGICAL_4 back);\n+export_proto(sfindloc1_c8);\n+\n+extern void\n+sfindloc1_c8 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_c8 * const restrict array, GFC_COMPLEX_8 value,\n+\t    const index_type * restrict pdim, GFC_LOGICAL_4 *const restrict  mask,\n+\t    GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type dim;\n+  bool continue_loop;\n+\n+  if (*mask)\n+    {\n+      findloc1_c8 (retarray, array, value, pdim, back);\n+      return;\n+    }\n+    /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  while (continue_loop)\n+    {\n+      *dest = 0;\n+\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+#endif"}, {"sha": "26b497e9aed7a590d9d7a29dfc29eb31576d9535", "filename": "libgfortran/generated/findloc1_i1.c", "status": "added", "additions": 523, "deletions": 0, "changes": 523, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc1_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc1_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ffindloc1_i1.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -0,0 +1,523 @@\n+/* Implementation of the FINDLOC intrinsic\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by Thomas K\u00f6nig <tk@tkoenig.net>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <assert.h>\n+\n+#if defined (HAVE_GFC_INTEGER_1)\n+extern void findloc1_i1 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_i1 * const restrict array, GFC_INTEGER_1 value,\n+\t\t\t const index_type * restrict pdim, GFC_LOGICAL_4 back);\n+export_proto(findloc1_i1);\n+\n+extern void\n+findloc1_i1 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_i1 * const restrict array, GFC_INTEGER_1 value,\n+\t    const index_type * restrict pdim, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_1 * restrict base;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  base = array->base_addr;\n+  while (continue_loop)\n+    {\n+      const GFC_INTEGER_1 * restrict src;\n+      index_type result;\n+\n+      result = 0;\n+      if (back)\n+\t{\n+\t  src = base + (len - 1) * delta * 1;\n+\t  for (n = len; n > 0; n--, src -= delta * 1)\n+\t    {\n+\t      if (*src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  src = base;\n+\t  for (n = 1; n <= len; n++, src += delta * 1)\n+\t    {\n+\t      if (*src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      *dest = result;\n+\n+      count[0]++;\n+      base += sstride[0] * 1;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  base -= sstride[n] * extent[n] * 1;\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n] * 1;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+extern void mfindloc1_i1 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_i1 * const restrict array, GFC_INTEGER_1 value,\n+\t\t\t const index_type * restrict pdim, gfc_array_l1 *const restrict mask,\n+\t\t\t GFC_LOGICAL_4 back);\n+export_proto(mfindloc1_i1);\n+\n+extern void\n+mfindloc1_i1 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_i1 * const restrict array, GFC_INTEGER_1 value,\n+\t    const index_type * restrict pdim, gfc_array_l1 *const restrict mask,\n+\t    GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_1 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  index_type dim;\n+  int mask_kind;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  mbase = mask->base_addr;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  base = array->base_addr;\n+  while (continue_loop)\n+    {\n+      const GFC_INTEGER_1 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      index_type result;\n+\n+      result = 0;\n+      if (back)\n+\t{\n+\t  src = base + (len - 1) * delta * 1;\n+\t  msrc = mbase + (len - 1) * mdelta; \n+\t  for (n = len; n > 0; n--, src -= delta * 1, msrc -= mdelta)\n+\t    {\n+\t      if (*msrc && *src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  src = base;\n+\t  msrc = mbase;\n+\t  for (n = 1; n <= len; n++, src += delta * 1, msrc += mdelta)\n+\t    {\n+\t      if (*msrc && *src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      *dest = result;\n+\n+      count[0]++;\n+      base += sstride[0] * 1;\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  base -= sstride[n] * extent[n] * 1;\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n] * 1;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+extern void sfindloc1_i1 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_i1 * const restrict array, GFC_INTEGER_1 value,\n+\t\t\t const index_type * restrict pdim, GFC_LOGICAL_4 *const restrict mask,\n+\t\t\t GFC_LOGICAL_4 back);\n+export_proto(sfindloc1_i1);\n+\n+extern void\n+sfindloc1_i1 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_i1 * const restrict array, GFC_INTEGER_1 value,\n+\t    const index_type * restrict pdim, GFC_LOGICAL_4 *const restrict  mask,\n+\t    GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type dim;\n+  bool continue_loop;\n+\n+  if (*mask)\n+    {\n+      findloc1_i1 (retarray, array, value, pdim, back);\n+      return;\n+    }\n+    /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  while (continue_loop)\n+    {\n+      *dest = 0;\n+\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+#endif"}, {"sha": "edb52e2e9ed41d15ea2b6f2535d02d4b58611d19", "filename": "libgfortran/generated/findloc1_i16.c", "status": "added", "additions": 523, "deletions": 0, "changes": 523, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc1_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc1_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ffindloc1_i16.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -0,0 +1,523 @@\n+/* Implementation of the FINDLOC intrinsic\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by Thomas K\u00f6nig <tk@tkoenig.net>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <assert.h>\n+\n+#if defined (HAVE_GFC_INTEGER_16)\n+extern void findloc1_i16 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_i16 * const restrict array, GFC_INTEGER_16 value,\n+\t\t\t const index_type * restrict pdim, GFC_LOGICAL_4 back);\n+export_proto(findloc1_i16);\n+\n+extern void\n+findloc1_i16 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_i16 * const restrict array, GFC_INTEGER_16 value,\n+\t    const index_type * restrict pdim, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_16 * restrict base;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  base = array->base_addr;\n+  while (continue_loop)\n+    {\n+      const GFC_INTEGER_16 * restrict src;\n+      index_type result;\n+\n+      result = 0;\n+      if (back)\n+\t{\n+\t  src = base + (len - 1) * delta * 1;\n+\t  for (n = len; n > 0; n--, src -= delta * 1)\n+\t    {\n+\t      if (*src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  src = base;\n+\t  for (n = 1; n <= len; n++, src += delta * 1)\n+\t    {\n+\t      if (*src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      *dest = result;\n+\n+      count[0]++;\n+      base += sstride[0] * 1;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  base -= sstride[n] * extent[n] * 1;\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n] * 1;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+extern void mfindloc1_i16 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_i16 * const restrict array, GFC_INTEGER_16 value,\n+\t\t\t const index_type * restrict pdim, gfc_array_l1 *const restrict mask,\n+\t\t\t GFC_LOGICAL_4 back);\n+export_proto(mfindloc1_i16);\n+\n+extern void\n+mfindloc1_i16 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_i16 * const restrict array, GFC_INTEGER_16 value,\n+\t    const index_type * restrict pdim, gfc_array_l1 *const restrict mask,\n+\t    GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_16 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  index_type dim;\n+  int mask_kind;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  mbase = mask->base_addr;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  base = array->base_addr;\n+  while (continue_loop)\n+    {\n+      const GFC_INTEGER_16 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      index_type result;\n+\n+      result = 0;\n+      if (back)\n+\t{\n+\t  src = base + (len - 1) * delta * 1;\n+\t  msrc = mbase + (len - 1) * mdelta; \n+\t  for (n = len; n > 0; n--, src -= delta * 1, msrc -= mdelta)\n+\t    {\n+\t      if (*msrc && *src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  src = base;\n+\t  msrc = mbase;\n+\t  for (n = 1; n <= len; n++, src += delta * 1, msrc += mdelta)\n+\t    {\n+\t      if (*msrc && *src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      *dest = result;\n+\n+      count[0]++;\n+      base += sstride[0] * 1;\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  base -= sstride[n] * extent[n] * 1;\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n] * 1;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+extern void sfindloc1_i16 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_i16 * const restrict array, GFC_INTEGER_16 value,\n+\t\t\t const index_type * restrict pdim, GFC_LOGICAL_4 *const restrict mask,\n+\t\t\t GFC_LOGICAL_4 back);\n+export_proto(sfindloc1_i16);\n+\n+extern void\n+sfindloc1_i16 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_i16 * const restrict array, GFC_INTEGER_16 value,\n+\t    const index_type * restrict pdim, GFC_LOGICAL_4 *const restrict  mask,\n+\t    GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type dim;\n+  bool continue_loop;\n+\n+  if (*mask)\n+    {\n+      findloc1_i16 (retarray, array, value, pdim, back);\n+      return;\n+    }\n+    /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  while (continue_loop)\n+    {\n+      *dest = 0;\n+\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+#endif"}, {"sha": "280b7b893a3bc70cf3bedd3defa024603890d54b", "filename": "libgfortran/generated/findloc1_i2.c", "status": "added", "additions": 523, "deletions": 0, "changes": 523, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc1_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc1_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ffindloc1_i2.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -0,0 +1,523 @@\n+/* Implementation of the FINDLOC intrinsic\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by Thomas K\u00f6nig <tk@tkoenig.net>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <assert.h>\n+\n+#if defined (HAVE_GFC_INTEGER_2)\n+extern void findloc1_i2 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_i2 * const restrict array, GFC_INTEGER_2 value,\n+\t\t\t const index_type * restrict pdim, GFC_LOGICAL_4 back);\n+export_proto(findloc1_i2);\n+\n+extern void\n+findloc1_i2 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_i2 * const restrict array, GFC_INTEGER_2 value,\n+\t    const index_type * restrict pdim, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_2 * restrict base;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  base = array->base_addr;\n+  while (continue_loop)\n+    {\n+      const GFC_INTEGER_2 * restrict src;\n+      index_type result;\n+\n+      result = 0;\n+      if (back)\n+\t{\n+\t  src = base + (len - 1) * delta * 1;\n+\t  for (n = len; n > 0; n--, src -= delta * 1)\n+\t    {\n+\t      if (*src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  src = base;\n+\t  for (n = 1; n <= len; n++, src += delta * 1)\n+\t    {\n+\t      if (*src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      *dest = result;\n+\n+      count[0]++;\n+      base += sstride[0] * 1;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  base -= sstride[n] * extent[n] * 1;\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n] * 1;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+extern void mfindloc1_i2 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_i2 * const restrict array, GFC_INTEGER_2 value,\n+\t\t\t const index_type * restrict pdim, gfc_array_l1 *const restrict mask,\n+\t\t\t GFC_LOGICAL_4 back);\n+export_proto(mfindloc1_i2);\n+\n+extern void\n+mfindloc1_i2 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_i2 * const restrict array, GFC_INTEGER_2 value,\n+\t    const index_type * restrict pdim, gfc_array_l1 *const restrict mask,\n+\t    GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_2 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  index_type dim;\n+  int mask_kind;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  mbase = mask->base_addr;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  base = array->base_addr;\n+  while (continue_loop)\n+    {\n+      const GFC_INTEGER_2 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      index_type result;\n+\n+      result = 0;\n+      if (back)\n+\t{\n+\t  src = base + (len - 1) * delta * 1;\n+\t  msrc = mbase + (len - 1) * mdelta; \n+\t  for (n = len; n > 0; n--, src -= delta * 1, msrc -= mdelta)\n+\t    {\n+\t      if (*msrc && *src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  src = base;\n+\t  msrc = mbase;\n+\t  for (n = 1; n <= len; n++, src += delta * 1, msrc += mdelta)\n+\t    {\n+\t      if (*msrc && *src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      *dest = result;\n+\n+      count[0]++;\n+      base += sstride[0] * 1;\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  base -= sstride[n] * extent[n] * 1;\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n] * 1;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+extern void sfindloc1_i2 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_i2 * const restrict array, GFC_INTEGER_2 value,\n+\t\t\t const index_type * restrict pdim, GFC_LOGICAL_4 *const restrict mask,\n+\t\t\t GFC_LOGICAL_4 back);\n+export_proto(sfindloc1_i2);\n+\n+extern void\n+sfindloc1_i2 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_i2 * const restrict array, GFC_INTEGER_2 value,\n+\t    const index_type * restrict pdim, GFC_LOGICAL_4 *const restrict  mask,\n+\t    GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type dim;\n+  bool continue_loop;\n+\n+  if (*mask)\n+    {\n+      findloc1_i2 (retarray, array, value, pdim, back);\n+      return;\n+    }\n+    /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  while (continue_loop)\n+    {\n+      *dest = 0;\n+\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+#endif"}, {"sha": "a9e3abc21de9f01d7901c41863e64d43fbfd46c1", "filename": "libgfortran/generated/findloc1_i4.c", "status": "added", "additions": 523, "deletions": 0, "changes": 523, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc1_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc1_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ffindloc1_i4.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -0,0 +1,523 @@\n+/* Implementation of the FINDLOC intrinsic\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by Thomas K\u00f6nig <tk@tkoenig.net>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <assert.h>\n+\n+#if defined (HAVE_GFC_INTEGER_4)\n+extern void findloc1_i4 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_i4 * const restrict array, GFC_INTEGER_4 value,\n+\t\t\t const index_type * restrict pdim, GFC_LOGICAL_4 back);\n+export_proto(findloc1_i4);\n+\n+extern void\n+findloc1_i4 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_i4 * const restrict array, GFC_INTEGER_4 value,\n+\t    const index_type * restrict pdim, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_4 * restrict base;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  base = array->base_addr;\n+  while (continue_loop)\n+    {\n+      const GFC_INTEGER_4 * restrict src;\n+      index_type result;\n+\n+      result = 0;\n+      if (back)\n+\t{\n+\t  src = base + (len - 1) * delta * 1;\n+\t  for (n = len; n > 0; n--, src -= delta * 1)\n+\t    {\n+\t      if (*src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  src = base;\n+\t  for (n = 1; n <= len; n++, src += delta * 1)\n+\t    {\n+\t      if (*src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      *dest = result;\n+\n+      count[0]++;\n+      base += sstride[0] * 1;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  base -= sstride[n] * extent[n] * 1;\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n] * 1;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+extern void mfindloc1_i4 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_i4 * const restrict array, GFC_INTEGER_4 value,\n+\t\t\t const index_type * restrict pdim, gfc_array_l1 *const restrict mask,\n+\t\t\t GFC_LOGICAL_4 back);\n+export_proto(mfindloc1_i4);\n+\n+extern void\n+mfindloc1_i4 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_i4 * const restrict array, GFC_INTEGER_4 value,\n+\t    const index_type * restrict pdim, gfc_array_l1 *const restrict mask,\n+\t    GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_4 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  index_type dim;\n+  int mask_kind;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  mbase = mask->base_addr;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  base = array->base_addr;\n+  while (continue_loop)\n+    {\n+      const GFC_INTEGER_4 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      index_type result;\n+\n+      result = 0;\n+      if (back)\n+\t{\n+\t  src = base + (len - 1) * delta * 1;\n+\t  msrc = mbase + (len - 1) * mdelta; \n+\t  for (n = len; n > 0; n--, src -= delta * 1, msrc -= mdelta)\n+\t    {\n+\t      if (*msrc && *src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  src = base;\n+\t  msrc = mbase;\n+\t  for (n = 1; n <= len; n++, src += delta * 1, msrc += mdelta)\n+\t    {\n+\t      if (*msrc && *src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      *dest = result;\n+\n+      count[0]++;\n+      base += sstride[0] * 1;\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  base -= sstride[n] * extent[n] * 1;\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n] * 1;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+extern void sfindloc1_i4 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_i4 * const restrict array, GFC_INTEGER_4 value,\n+\t\t\t const index_type * restrict pdim, GFC_LOGICAL_4 *const restrict mask,\n+\t\t\t GFC_LOGICAL_4 back);\n+export_proto(sfindloc1_i4);\n+\n+extern void\n+sfindloc1_i4 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_i4 * const restrict array, GFC_INTEGER_4 value,\n+\t    const index_type * restrict pdim, GFC_LOGICAL_4 *const restrict  mask,\n+\t    GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type dim;\n+  bool continue_loop;\n+\n+  if (*mask)\n+    {\n+      findloc1_i4 (retarray, array, value, pdim, back);\n+      return;\n+    }\n+    /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  while (continue_loop)\n+    {\n+      *dest = 0;\n+\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+#endif"}, {"sha": "79b5a5a35e04891339becf5a2f7c1316e89cd8b1", "filename": "libgfortran/generated/findloc1_i8.c", "status": "added", "additions": 523, "deletions": 0, "changes": 523, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc1_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc1_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ffindloc1_i8.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -0,0 +1,523 @@\n+/* Implementation of the FINDLOC intrinsic\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by Thomas K\u00f6nig <tk@tkoenig.net>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <assert.h>\n+\n+#if defined (HAVE_GFC_INTEGER_8)\n+extern void findloc1_i8 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_i8 * const restrict array, GFC_INTEGER_8 value,\n+\t\t\t const index_type * restrict pdim, GFC_LOGICAL_4 back);\n+export_proto(findloc1_i8);\n+\n+extern void\n+findloc1_i8 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_i8 * const restrict array, GFC_INTEGER_8 value,\n+\t    const index_type * restrict pdim, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_8 * restrict base;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  base = array->base_addr;\n+  while (continue_loop)\n+    {\n+      const GFC_INTEGER_8 * restrict src;\n+      index_type result;\n+\n+      result = 0;\n+      if (back)\n+\t{\n+\t  src = base + (len - 1) * delta * 1;\n+\t  for (n = len; n > 0; n--, src -= delta * 1)\n+\t    {\n+\t      if (*src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  src = base;\n+\t  for (n = 1; n <= len; n++, src += delta * 1)\n+\t    {\n+\t      if (*src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      *dest = result;\n+\n+      count[0]++;\n+      base += sstride[0] * 1;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  base -= sstride[n] * extent[n] * 1;\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n] * 1;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+extern void mfindloc1_i8 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_i8 * const restrict array, GFC_INTEGER_8 value,\n+\t\t\t const index_type * restrict pdim, gfc_array_l1 *const restrict mask,\n+\t\t\t GFC_LOGICAL_4 back);\n+export_proto(mfindloc1_i8);\n+\n+extern void\n+mfindloc1_i8 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_i8 * const restrict array, GFC_INTEGER_8 value,\n+\t    const index_type * restrict pdim, gfc_array_l1 *const restrict mask,\n+\t    GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_8 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  index_type dim;\n+  int mask_kind;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  mbase = mask->base_addr;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  base = array->base_addr;\n+  while (continue_loop)\n+    {\n+      const GFC_INTEGER_8 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      index_type result;\n+\n+      result = 0;\n+      if (back)\n+\t{\n+\t  src = base + (len - 1) * delta * 1;\n+\t  msrc = mbase + (len - 1) * mdelta; \n+\t  for (n = len; n > 0; n--, src -= delta * 1, msrc -= mdelta)\n+\t    {\n+\t      if (*msrc && *src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  src = base;\n+\t  msrc = mbase;\n+\t  for (n = 1; n <= len; n++, src += delta * 1, msrc += mdelta)\n+\t    {\n+\t      if (*msrc && *src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      *dest = result;\n+\n+      count[0]++;\n+      base += sstride[0] * 1;\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  base -= sstride[n] * extent[n] * 1;\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n] * 1;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+extern void sfindloc1_i8 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_i8 * const restrict array, GFC_INTEGER_8 value,\n+\t\t\t const index_type * restrict pdim, GFC_LOGICAL_4 *const restrict mask,\n+\t\t\t GFC_LOGICAL_4 back);\n+export_proto(sfindloc1_i8);\n+\n+extern void\n+sfindloc1_i8 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_i8 * const restrict array, GFC_INTEGER_8 value,\n+\t    const index_type * restrict pdim, GFC_LOGICAL_4 *const restrict  mask,\n+\t    GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type dim;\n+  bool continue_loop;\n+\n+  if (*mask)\n+    {\n+      findloc1_i8 (retarray, array, value, pdim, back);\n+      return;\n+    }\n+    /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  while (continue_loop)\n+    {\n+      *dest = 0;\n+\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+#endif"}, {"sha": "90f3db0ade6d77ac193b658c5aa3df6f2682c6cd", "filename": "libgfortran/generated/findloc1_r16.c", "status": "added", "additions": 523, "deletions": 0, "changes": 523, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc1_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc1_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ffindloc1_r16.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -0,0 +1,523 @@\n+/* Implementation of the FINDLOC intrinsic\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by Thomas K\u00f6nig <tk@tkoenig.net>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <assert.h>\n+\n+#if defined (HAVE_GFC_REAL_16)\n+extern void findloc1_r16 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_r16 * const restrict array, GFC_REAL_16 value,\n+\t\t\t const index_type * restrict pdim, GFC_LOGICAL_4 back);\n+export_proto(findloc1_r16);\n+\n+extern void\n+findloc1_r16 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_r16 * const restrict array, GFC_REAL_16 value,\n+\t    const index_type * restrict pdim, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_REAL_16 * restrict base;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  base = array->base_addr;\n+  while (continue_loop)\n+    {\n+      const GFC_REAL_16 * restrict src;\n+      index_type result;\n+\n+      result = 0;\n+      if (back)\n+\t{\n+\t  src = base + (len - 1) * delta * 1;\n+\t  for (n = len; n > 0; n--, src -= delta * 1)\n+\t    {\n+\t      if (*src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  src = base;\n+\t  for (n = 1; n <= len; n++, src += delta * 1)\n+\t    {\n+\t      if (*src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      *dest = result;\n+\n+      count[0]++;\n+      base += sstride[0] * 1;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  base -= sstride[n] * extent[n] * 1;\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n] * 1;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+extern void mfindloc1_r16 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_r16 * const restrict array, GFC_REAL_16 value,\n+\t\t\t const index_type * restrict pdim, gfc_array_l1 *const restrict mask,\n+\t\t\t GFC_LOGICAL_4 back);\n+export_proto(mfindloc1_r16);\n+\n+extern void\n+mfindloc1_r16 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_r16 * const restrict array, GFC_REAL_16 value,\n+\t    const index_type * restrict pdim, gfc_array_l1 *const restrict mask,\n+\t    GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_REAL_16 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  index_type dim;\n+  int mask_kind;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  mbase = mask->base_addr;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  base = array->base_addr;\n+  while (continue_loop)\n+    {\n+      const GFC_REAL_16 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      index_type result;\n+\n+      result = 0;\n+      if (back)\n+\t{\n+\t  src = base + (len - 1) * delta * 1;\n+\t  msrc = mbase + (len - 1) * mdelta; \n+\t  for (n = len; n > 0; n--, src -= delta * 1, msrc -= mdelta)\n+\t    {\n+\t      if (*msrc && *src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  src = base;\n+\t  msrc = mbase;\n+\t  for (n = 1; n <= len; n++, src += delta * 1, msrc += mdelta)\n+\t    {\n+\t      if (*msrc && *src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      *dest = result;\n+\n+      count[0]++;\n+      base += sstride[0] * 1;\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  base -= sstride[n] * extent[n] * 1;\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n] * 1;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+extern void sfindloc1_r16 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_r16 * const restrict array, GFC_REAL_16 value,\n+\t\t\t const index_type * restrict pdim, GFC_LOGICAL_4 *const restrict mask,\n+\t\t\t GFC_LOGICAL_4 back);\n+export_proto(sfindloc1_r16);\n+\n+extern void\n+sfindloc1_r16 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_r16 * const restrict array, GFC_REAL_16 value,\n+\t    const index_type * restrict pdim, GFC_LOGICAL_4 *const restrict  mask,\n+\t    GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type dim;\n+  bool continue_loop;\n+\n+  if (*mask)\n+    {\n+      findloc1_r16 (retarray, array, value, pdim, back);\n+      return;\n+    }\n+    /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  while (continue_loop)\n+    {\n+      *dest = 0;\n+\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+#endif"}, {"sha": "d573cbb260dfb8f56e48845cf85f00126f0706af", "filename": "libgfortran/generated/findloc1_r4.c", "status": "added", "additions": 523, "deletions": 0, "changes": 523, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc1_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc1_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ffindloc1_r4.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -0,0 +1,523 @@\n+/* Implementation of the FINDLOC intrinsic\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by Thomas K\u00f6nig <tk@tkoenig.net>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <assert.h>\n+\n+#if defined (HAVE_GFC_REAL_4)\n+extern void findloc1_r4 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_r4 * const restrict array, GFC_REAL_4 value,\n+\t\t\t const index_type * restrict pdim, GFC_LOGICAL_4 back);\n+export_proto(findloc1_r4);\n+\n+extern void\n+findloc1_r4 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_r4 * const restrict array, GFC_REAL_4 value,\n+\t    const index_type * restrict pdim, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_REAL_4 * restrict base;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  base = array->base_addr;\n+  while (continue_loop)\n+    {\n+      const GFC_REAL_4 * restrict src;\n+      index_type result;\n+\n+      result = 0;\n+      if (back)\n+\t{\n+\t  src = base + (len - 1) * delta * 1;\n+\t  for (n = len; n > 0; n--, src -= delta * 1)\n+\t    {\n+\t      if (*src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  src = base;\n+\t  for (n = 1; n <= len; n++, src += delta * 1)\n+\t    {\n+\t      if (*src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      *dest = result;\n+\n+      count[0]++;\n+      base += sstride[0] * 1;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  base -= sstride[n] * extent[n] * 1;\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n] * 1;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+extern void mfindloc1_r4 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_r4 * const restrict array, GFC_REAL_4 value,\n+\t\t\t const index_type * restrict pdim, gfc_array_l1 *const restrict mask,\n+\t\t\t GFC_LOGICAL_4 back);\n+export_proto(mfindloc1_r4);\n+\n+extern void\n+mfindloc1_r4 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_r4 * const restrict array, GFC_REAL_4 value,\n+\t    const index_type * restrict pdim, gfc_array_l1 *const restrict mask,\n+\t    GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_REAL_4 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  index_type dim;\n+  int mask_kind;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  mbase = mask->base_addr;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  base = array->base_addr;\n+  while (continue_loop)\n+    {\n+      const GFC_REAL_4 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      index_type result;\n+\n+      result = 0;\n+      if (back)\n+\t{\n+\t  src = base + (len - 1) * delta * 1;\n+\t  msrc = mbase + (len - 1) * mdelta; \n+\t  for (n = len; n > 0; n--, src -= delta * 1, msrc -= mdelta)\n+\t    {\n+\t      if (*msrc && *src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  src = base;\n+\t  msrc = mbase;\n+\t  for (n = 1; n <= len; n++, src += delta * 1, msrc += mdelta)\n+\t    {\n+\t      if (*msrc && *src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      *dest = result;\n+\n+      count[0]++;\n+      base += sstride[0] * 1;\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  base -= sstride[n] * extent[n] * 1;\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n] * 1;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+extern void sfindloc1_r4 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_r4 * const restrict array, GFC_REAL_4 value,\n+\t\t\t const index_type * restrict pdim, GFC_LOGICAL_4 *const restrict mask,\n+\t\t\t GFC_LOGICAL_4 back);\n+export_proto(sfindloc1_r4);\n+\n+extern void\n+sfindloc1_r4 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_r4 * const restrict array, GFC_REAL_4 value,\n+\t    const index_type * restrict pdim, GFC_LOGICAL_4 *const restrict  mask,\n+\t    GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type dim;\n+  bool continue_loop;\n+\n+  if (*mask)\n+    {\n+      findloc1_r4 (retarray, array, value, pdim, back);\n+      return;\n+    }\n+    /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  while (continue_loop)\n+    {\n+      *dest = 0;\n+\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+#endif"}, {"sha": "037993ce5aa6049a6a49673b9eb21d38fa9bd523", "filename": "libgfortran/generated/findloc1_r8.c", "status": "added", "additions": 523, "deletions": 0, "changes": 523, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc1_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc1_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ffindloc1_r8.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -0,0 +1,523 @@\n+/* Implementation of the FINDLOC intrinsic\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by Thomas K\u00f6nig <tk@tkoenig.net>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <assert.h>\n+\n+#if defined (HAVE_GFC_REAL_8)\n+extern void findloc1_r8 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_r8 * const restrict array, GFC_REAL_8 value,\n+\t\t\t const index_type * restrict pdim, GFC_LOGICAL_4 back);\n+export_proto(findloc1_r8);\n+\n+extern void\n+findloc1_r8 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_r8 * const restrict array, GFC_REAL_8 value,\n+\t    const index_type * restrict pdim, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_REAL_8 * restrict base;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  base = array->base_addr;\n+  while (continue_loop)\n+    {\n+      const GFC_REAL_8 * restrict src;\n+      index_type result;\n+\n+      result = 0;\n+      if (back)\n+\t{\n+\t  src = base + (len - 1) * delta * 1;\n+\t  for (n = len; n > 0; n--, src -= delta * 1)\n+\t    {\n+\t      if (*src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  src = base;\n+\t  for (n = 1; n <= len; n++, src += delta * 1)\n+\t    {\n+\t      if (*src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      *dest = result;\n+\n+      count[0]++;\n+      base += sstride[0] * 1;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  base -= sstride[n] * extent[n] * 1;\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n] * 1;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+extern void mfindloc1_r8 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_r8 * const restrict array, GFC_REAL_8 value,\n+\t\t\t const index_type * restrict pdim, gfc_array_l1 *const restrict mask,\n+\t\t\t GFC_LOGICAL_4 back);\n+export_proto(mfindloc1_r8);\n+\n+extern void\n+mfindloc1_r8 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_r8 * const restrict array, GFC_REAL_8 value,\n+\t    const index_type * restrict pdim, gfc_array_l1 *const restrict mask,\n+\t    GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_REAL_8 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  index_type dim;\n+  int mask_kind;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  mbase = mask->base_addr;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  base = array->base_addr;\n+  while (continue_loop)\n+    {\n+      const GFC_REAL_8 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      index_type result;\n+\n+      result = 0;\n+      if (back)\n+\t{\n+\t  src = base + (len - 1) * delta * 1;\n+\t  msrc = mbase + (len - 1) * mdelta; \n+\t  for (n = len; n > 0; n--, src -= delta * 1, msrc -= mdelta)\n+\t    {\n+\t      if (*msrc && *src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  src = base;\n+\t  msrc = mbase;\n+\t  for (n = 1; n <= len; n++, src += delta * 1, msrc += mdelta)\n+\t    {\n+\t      if (*msrc && *src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      *dest = result;\n+\n+      count[0]++;\n+      base += sstride[0] * 1;\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  base -= sstride[n] * extent[n] * 1;\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n] * 1;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+extern void sfindloc1_r8 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_r8 * const restrict array, GFC_REAL_8 value,\n+\t\t\t const index_type * restrict pdim, GFC_LOGICAL_4 *const restrict mask,\n+\t\t\t GFC_LOGICAL_4 back);\n+export_proto(sfindloc1_r8);\n+\n+extern void\n+sfindloc1_r8 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_r8 * const restrict array, GFC_REAL_8 value,\n+\t    const index_type * restrict pdim, GFC_LOGICAL_4 *const restrict  mask,\n+\t    GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type dim;\n+  bool continue_loop;\n+\n+  if (*mask)\n+    {\n+      findloc1_r8 (retarray, array, value, pdim, back);\n+      return;\n+    }\n+    /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  while (continue_loop)\n+    {\n+      *dest = 0;\n+\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+#endif"}, {"sha": "0b331acc140f131d3a766ff5b9f15b85393fe571", "filename": "libgfortran/generated/findloc1_s1.c", "status": "added", "additions": 525, "deletions": 0, "changes": 525, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc1_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc1_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ffindloc1_s1.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -0,0 +1,525 @@\n+/* Implementation of the FINDLOC intrinsic\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by Thomas K\u00f6nig <tk@tkoenig.net>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <assert.h>\n+\n+#if defined (HAVE_GFC_UINTEGER_1)\n+extern void findloc1_s1 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_s1 * const restrict array, GFC_UINTEGER_1 *const restrict value,\n+\t\t\t const index_type * restrict pdim, GFC_LOGICAL_4 back,\n+\t\t\t gfc_charlen_type len_array, gfc_charlen_type len_value);\n+export_proto(findloc1_s1);\n+\n+extern void\n+findloc1_s1 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_s1 * const restrict array, GFC_UINTEGER_1 *const restrict value,\n+\t    const index_type * restrict pdim, GFC_LOGICAL_4 back,\n+\t    gfc_charlen_type len_array, gfc_charlen_type len_value)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_UINTEGER_1 * restrict base;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  base = array->base_addr;\n+  while (continue_loop)\n+    {\n+      const GFC_UINTEGER_1 * restrict src;\n+      index_type result;\n+\n+      result = 0;\n+      if (back)\n+\t{\n+\t  src = base + (len - 1) * delta * len_array;\n+\t  for (n = len; n > 0; n--, src -= delta * len_array)\n+\t    {\n+\t      if (compare_string (len_array, (char *) src, len_value, (char *) value) == 0)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  src = base;\n+\t  for (n = 1; n <= len; n++, src += delta * len_array)\n+\t    {\n+\t      if (compare_string (len_array, (char *) src, len_value, (char *) value) == 0)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      *dest = result;\n+\n+      count[0]++;\n+      base += sstride[0] * len_array;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  base -= sstride[n] * extent[n] * len_array;\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n] * len_array;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+extern void mfindloc1_s1 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_s1 * const restrict array, GFC_UINTEGER_1 *const restrict value,\n+\t\t\t const index_type * restrict pdim, gfc_array_l1 *const restrict mask,\n+\t\t\t GFC_LOGICAL_4 back, gfc_charlen_type len_array, gfc_charlen_type len_value);\n+export_proto(mfindloc1_s1);\n+\n+extern void\n+mfindloc1_s1 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_s1 * const restrict array, GFC_UINTEGER_1 *const restrict value,\n+\t    const index_type * restrict pdim, gfc_array_l1 *const restrict mask,\n+\t    GFC_LOGICAL_4 back, gfc_charlen_type len_array, gfc_charlen_type len_value)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_UINTEGER_1 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  index_type dim;\n+  int mask_kind;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  mbase = mask->base_addr;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  base = array->base_addr;\n+  while (continue_loop)\n+    {\n+      const GFC_UINTEGER_1 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      index_type result;\n+\n+      result = 0;\n+      if (back)\n+\t{\n+\t  src = base + (len - 1) * delta * len_array;\n+\t  msrc = mbase + (len - 1) * mdelta; \n+\t  for (n = len; n > 0; n--, src -= delta * len_array, msrc -= mdelta)\n+\t    {\n+\t      if (*msrc && compare_string (len_array, (char *) src, len_value, (char *) value) == 0)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  src = base;\n+\t  msrc = mbase;\n+\t  for (n = 1; n <= len; n++, src += delta * len_array, msrc += mdelta)\n+\t    {\n+\t      if (*msrc && compare_string (len_array, (char *) src, len_value, (char *) value) == 0)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      *dest = result;\n+\n+      count[0]++;\n+      base += sstride[0] * len_array;\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  base -= sstride[n] * extent[n] * len_array;\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n] * len_array;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+extern void sfindloc1_s1 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_s1 * const restrict array, GFC_UINTEGER_1 *const restrict value,\n+\t\t\t const index_type * restrict pdim, GFC_LOGICAL_4 *const restrict mask,\n+\t\t\t GFC_LOGICAL_4 back, gfc_charlen_type len_array, gfc_charlen_type len_value);\n+export_proto(sfindloc1_s1);\n+\n+extern void\n+sfindloc1_s1 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_s1 * const restrict array, GFC_UINTEGER_1 *const restrict value,\n+\t    const index_type * restrict pdim, GFC_LOGICAL_4 *const restrict  mask,\n+\t    GFC_LOGICAL_4 back, gfc_charlen_type len_array, gfc_charlen_type len_value)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type dim;\n+  bool continue_loop;\n+\n+  if (*mask)\n+    {\n+      findloc1_s1 (retarray, array, value, pdim, back, len_array, len_value);\n+      return;\n+    }\n+    /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  while (continue_loop)\n+    {\n+      *dest = 0;\n+\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+#endif"}, {"sha": "6b42d10ee8ed622a33c23ad0826088cc974e456c", "filename": "libgfortran/generated/findloc1_s4.c", "status": "added", "additions": 525, "deletions": 0, "changes": 525, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc1_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc1_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ffindloc1_s4.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -0,0 +1,525 @@\n+/* Implementation of the FINDLOC intrinsic\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by Thomas K\u00f6nig <tk@tkoenig.net>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <assert.h>\n+\n+#if defined (HAVE_GFC_UINTEGER_4)\n+extern void findloc1_s4 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_s4 * const restrict array, GFC_UINTEGER_4 *const restrict value,\n+\t\t\t const index_type * restrict pdim, GFC_LOGICAL_4 back,\n+\t\t\t gfc_charlen_type len_array, gfc_charlen_type len_value);\n+export_proto(findloc1_s4);\n+\n+extern void\n+findloc1_s4 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_s4 * const restrict array, GFC_UINTEGER_4 *const restrict value,\n+\t    const index_type * restrict pdim, GFC_LOGICAL_4 back,\n+\t    gfc_charlen_type len_array, gfc_charlen_type len_value)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_UINTEGER_4 * restrict base;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  base = array->base_addr;\n+  while (continue_loop)\n+    {\n+      const GFC_UINTEGER_4 * restrict src;\n+      index_type result;\n+\n+      result = 0;\n+      if (back)\n+\t{\n+\t  src = base + (len - 1) * delta * len_array;\n+\t  for (n = len; n > 0; n--, src -= delta * len_array)\n+\t    {\n+\t      if (compare_string_char4 (len_array, src, len_value, value) == 0)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  src = base;\n+\t  for (n = 1; n <= len; n++, src += delta * len_array)\n+\t    {\n+\t      if (compare_string_char4 (len_array, src, len_value, value) == 0)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      *dest = result;\n+\n+      count[0]++;\n+      base += sstride[0] * len_array;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  base -= sstride[n] * extent[n] * len_array;\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n] * len_array;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+extern void mfindloc1_s4 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_s4 * const restrict array, GFC_UINTEGER_4 *const restrict value,\n+\t\t\t const index_type * restrict pdim, gfc_array_l1 *const restrict mask,\n+\t\t\t GFC_LOGICAL_4 back, gfc_charlen_type len_array, gfc_charlen_type len_value);\n+export_proto(mfindloc1_s4);\n+\n+extern void\n+mfindloc1_s4 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_s4 * const restrict array, GFC_UINTEGER_4 *const restrict value,\n+\t    const index_type * restrict pdim, gfc_array_l1 *const restrict mask,\n+\t    GFC_LOGICAL_4 back, gfc_charlen_type len_array, gfc_charlen_type len_value)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_UINTEGER_4 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  index_type dim;\n+  int mask_kind;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  mbase = mask->base_addr;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  base = array->base_addr;\n+  while (continue_loop)\n+    {\n+      const GFC_UINTEGER_4 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      index_type result;\n+\n+      result = 0;\n+      if (back)\n+\t{\n+\t  src = base + (len - 1) * delta * len_array;\n+\t  msrc = mbase + (len - 1) * mdelta; \n+\t  for (n = len; n > 0; n--, src -= delta * len_array, msrc -= mdelta)\n+\t    {\n+\t      if (*msrc && compare_string_char4 (len_array, src, len_value, value) == 0)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  src = base;\n+\t  msrc = mbase;\n+\t  for (n = 1; n <= len; n++, src += delta * len_array, msrc += mdelta)\n+\t    {\n+\t      if (*msrc && compare_string_char4 (len_array, src, len_value, value) == 0)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      *dest = result;\n+\n+      count[0]++;\n+      base += sstride[0] * len_array;\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  base -= sstride[n] * extent[n] * len_array;\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n] * len_array;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+extern void sfindloc1_s4 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_s4 * const restrict array, GFC_UINTEGER_4 *const restrict value,\n+\t\t\t const index_type * restrict pdim, GFC_LOGICAL_4 *const restrict mask,\n+\t\t\t GFC_LOGICAL_4 back, gfc_charlen_type len_array, gfc_charlen_type len_value);\n+export_proto(sfindloc1_s4);\n+\n+extern void\n+sfindloc1_s4 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_s4 * const restrict array, GFC_UINTEGER_4 *const restrict value,\n+\t    const index_type * restrict pdim, GFC_LOGICAL_4 *const restrict  mask,\n+\t    GFC_LOGICAL_4 back, gfc_charlen_type len_array, gfc_charlen_type len_value)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type dim;\n+  bool continue_loop;\n+\n+  if (*mask)\n+    {\n+      findloc1_s4 (retarray, array, value, pdim, back, len_array, len_value);\n+      return;\n+    }\n+    /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  while (continue_loop)\n+    {\n+      *dest = 0;\n+\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+#endif"}, {"sha": "bfeca024b45714cd3c1b8f8610c1da9f4d8b8b47", "filename": "libgfortran/generated/findloc2_s1.c", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc2_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc2_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ffindloc2_s1.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -0,0 +1,154 @@\n+/* Implementation of the FINDLOC intrinsic\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by Thomas K\u00f6nig <tk@tkoenig.net>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+\n+#ifdef HAVE_GFC_UINTEGER_1\n+index_type findloc2_s1 (gfc_array_s1 * const restrict array,\n+\t\t\t   const GFC_UINTEGER_1 * restrict value, GFC_LOGICAL_4 back,\n+\t\t\t   gfc_charlen_type len_array, gfc_charlen_type len_value);\n+export_proto(findloc2_s1);\n+\n+index_type\n+findloc2_s1 (gfc_array_s1 * const restrict array, const GFC_UINTEGER_1 * restrict value,\n+\t\t      GFC_LOGICAL_4 back,\n+\t\t      gfc_charlen_type len_array, gfc_charlen_type len_value)\n+{\n+  index_type i;\n+  index_type sstride;\n+  index_type extent;\n+  const GFC_UINTEGER_1 * restrict src;\n+\n+  extent = GFC_DESCRIPTOR_EXTENT(array,0);\n+  if (extent <= 0)\n+    return 0;\n+\n+  sstride = GFC_DESCRIPTOR_STRIDE(array,0) * len_array;\n+  if (back)\n+    {\n+      src = array->base_addr + (extent - 1) * sstride;\n+      for (i = extent; i >= 0; i--)\n+\t{\n+\t  if (compare_string (len_array, (char *) src, len_value, (char *) value) == 0)\n+\t    return i;\n+\t  src -= sstride;\n+\t}\n+    }\n+  else\n+    {\n+      src = array->base_addr;\n+      for (i = 1; i <= extent; i++)\n+\t{\n+\t  if (compare_string (len_array, (char *) src, len_value, (char *) value) == 0)\n+\t    return i;\n+\t  src += sstride;\n+\t}\n+    }\n+  return 0;\n+}\n+\n+index_type mfindloc2_s1 (gfc_array_s1 * const restrict array,\n+\t\t\t const GFC_UINTEGER_1 * restrict value,\n+\t\t\t gfc_array_l1 *const restrict mask, GFC_LOGICAL_4 back,\n+\t\t\t gfc_charlen_type len_array, gfc_charlen_type len_value);\n+export_proto(mfindloc2_s1);\n+\n+index_type\n+mfindloc2_s1 (gfc_array_s1 * const restrict array,\n+\t\t\t   const GFC_UINTEGER_1 * restrict value, gfc_array_l1 *const restrict mask,\n+\t\t\t   GFC_LOGICAL_4 back, gfc_charlen_type len_array,\n+\t\t\t   gfc_charlen_type len_value)\n+{\n+  index_type i;\n+  index_type sstride;\n+  index_type extent;\n+  const GFC_UINTEGER_1 * restrict src;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  int mask_kind;\n+  index_type mstride;\n+\n+  extent = GFC_DESCRIPTOR_EXTENT(array,0);\n+  if (extent <= 0)\n+    return 0;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  sstride = GFC_DESCRIPTOR_STRIDE(array,0) * len_array;\n+  mstride = GFC_DESCRIPTOR_STRIDE_BYTES(mask,0);\n+\n+  if (back)\n+    {\n+      src = array->base_addr + (extent - 1) * sstride;\n+      mbase += (extent - 1) * mstride;\n+      for (i = extent; i >= 0; i--)\n+\t{\n+\t  if (*mbase && (compare_string (len_array, (char *) src, len_value, (char *) value) == 0))\n+\t    return i;\n+\t  src -= sstride;\n+\t  mbase -= mstride;\n+\t}\n+    }\n+  else\n+    {\n+      src = array->base_addr;\n+      for (i = 1; i <= extent; i++)\n+\t{\n+\t  if (*mbase && (compare_string (len_array, (char *) src, len_value, (char *) value) == 0))\n+\t    return i;\n+\t  src += sstride;\n+\t  mbase += mstride;\n+\t}\n+    }\n+  return 0;\n+}\n+index_type sfindloc2_s1 (gfc_array_s1 * const restrict array,\n+\t\t\t const GFC_UINTEGER_1 * restrict value,\n+\t\t\t GFC_LOGICAL_4 *const restrict mask, GFC_LOGICAL_4 back,\n+\t\t\t gfc_charlen_type len_array, gfc_charlen_type len_value);\n+export_proto(sfindloc2_s1);\n+\n+index_type\n+sfindloc2_s1 (gfc_array_s1 * const restrict array,\n+\t\t\t   const GFC_UINTEGER_1 * restrict value, GFC_LOGICAL_4 *const restrict mask,\n+\t\t\t   GFC_LOGICAL_4 back, gfc_charlen_type len_array,\n+\t\t\t   gfc_charlen_type len_value)\n+{\n+  if (*mask)\n+    {\n+      return findloc2_s1 (array, value, back, len_array, len_value);\n+    }\n+  return 0;\n+}\n+#endif"}, {"sha": "6597b5670fae5264bc574aae8c19b16bb4e8583d", "filename": "libgfortran/generated/findloc2_s4.c", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc2_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Ffindloc2_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ffindloc2_s4.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -0,0 +1,154 @@\n+/* Implementation of the FINDLOC intrinsic\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by Thomas K\u00f6nig <tk@tkoenig.net>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+\n+#ifdef HAVE_GFC_UINTEGER_4\n+index_type findloc2_s4 (gfc_array_s4 * const restrict array,\n+\t\t\t   const GFC_UINTEGER_4 * restrict value, GFC_LOGICAL_4 back,\n+\t\t\t   gfc_charlen_type len_array, gfc_charlen_type len_value);\n+export_proto(findloc2_s4);\n+\n+index_type\n+findloc2_s4 (gfc_array_s4 * const restrict array, const GFC_UINTEGER_4 * restrict value,\n+\t\t      GFC_LOGICAL_4 back,\n+\t\t      gfc_charlen_type len_array, gfc_charlen_type len_value)\n+{\n+  index_type i;\n+  index_type sstride;\n+  index_type extent;\n+  const GFC_UINTEGER_4 * restrict src;\n+\n+  extent = GFC_DESCRIPTOR_EXTENT(array,0);\n+  if (extent <= 0)\n+    return 0;\n+\n+  sstride = GFC_DESCRIPTOR_STRIDE(array,0) * len_array;\n+  if (back)\n+    {\n+      src = array->base_addr + (extent - 1) * sstride;\n+      for (i = extent; i >= 0; i--)\n+\t{\n+\t  if (compare_string_char4 (len_array, src, len_value, value) == 0)\n+\t    return i;\n+\t  src -= sstride;\n+\t}\n+    }\n+  else\n+    {\n+      src = array->base_addr;\n+      for (i = 1; i <= extent; i++)\n+\t{\n+\t  if (compare_string_char4 (len_array, src, len_value, value) == 0)\n+\t    return i;\n+\t  src += sstride;\n+\t}\n+    }\n+  return 0;\n+}\n+\n+index_type mfindloc2_s4 (gfc_array_s4 * const restrict array,\n+\t\t\t const GFC_UINTEGER_4 * restrict value,\n+\t\t\t gfc_array_l1 *const restrict mask, GFC_LOGICAL_4 back,\n+\t\t\t gfc_charlen_type len_array, gfc_charlen_type len_value);\n+export_proto(mfindloc2_s4);\n+\n+index_type\n+mfindloc2_s4 (gfc_array_s4 * const restrict array,\n+\t\t\t   const GFC_UINTEGER_4 * restrict value, gfc_array_l1 *const restrict mask,\n+\t\t\t   GFC_LOGICAL_4 back, gfc_charlen_type len_array,\n+\t\t\t   gfc_charlen_type len_value)\n+{\n+  index_type i;\n+  index_type sstride;\n+  index_type extent;\n+  const GFC_UINTEGER_4 * restrict src;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  int mask_kind;\n+  index_type mstride;\n+\n+  extent = GFC_DESCRIPTOR_EXTENT(array,0);\n+  if (extent <= 0)\n+    return 0;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  sstride = GFC_DESCRIPTOR_STRIDE(array,0) * len_array;\n+  mstride = GFC_DESCRIPTOR_STRIDE_BYTES(mask,0);\n+\n+  if (back)\n+    {\n+      src = array->base_addr + (extent - 1) * sstride;\n+      mbase += (extent - 1) * mstride;\n+      for (i = extent; i >= 0; i--)\n+\t{\n+\t  if (*mbase && (compare_string_char4 (len_array, src, len_value, value) == 0))\n+\t    return i;\n+\t  src -= sstride;\n+\t  mbase -= mstride;\n+\t}\n+    }\n+  else\n+    {\n+      src = array->base_addr;\n+      for (i = 1; i <= extent; i++)\n+\t{\n+\t  if (*mbase && (compare_string_char4 (len_array, src, len_value, value) == 0))\n+\t    return i;\n+\t  src += sstride;\n+\t  mbase += mstride;\n+\t}\n+    }\n+  return 0;\n+}\n+index_type sfindloc2_s4 (gfc_array_s4 * const restrict array,\n+\t\t\t const GFC_UINTEGER_4 * restrict value,\n+\t\t\t GFC_LOGICAL_4 *const restrict mask, GFC_LOGICAL_4 back,\n+\t\t\t gfc_charlen_type len_array, gfc_charlen_type len_value);\n+export_proto(sfindloc2_s4);\n+\n+index_type\n+sfindloc2_s4 (gfc_array_s4 * const restrict array,\n+\t\t\t   const GFC_UINTEGER_4 * restrict value, GFC_LOGICAL_4 *const restrict mask,\n+\t\t\t   GFC_LOGICAL_4 back, gfc_charlen_type len_array,\n+\t\t\t   gfc_charlen_type len_value)\n+{\n+  if (*mask)\n+    {\n+      return findloc2_s4 (array, value, back, len_array, len_value);\n+    }\n+  return 0;\n+}\n+#endif"}, {"sha": "cfe35688302e455166bbd840e71b3eaab6edca36", "filename": "libgfortran/generated/maxloc0_16_s1.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fmaxloc0_16_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fmaxloc0_16_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_s1.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -30,14 +30,14 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <limits.h>\n \n \n-#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_16)\n+#if defined (HAVE_GFC_UINTEGER_1) && defined (HAVE_GFC_INTEGER_16)\n \n #define HAVE_BACK_ARG 1\n \n static inline int\n-compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n+compare_fcn (const GFC_UINTEGER_1 *a, const GFC_UINTEGER_1 *b, gfc_charlen_type n)\n {\n-  if (sizeof (GFC_INTEGER_1) == 1)\n+  if (sizeof (GFC_UINTEGER_1) == 1)\n     return memcmp (a, b, n);\n   else\n     return memcmp_char4 (a, b, n);\n@@ -56,7 +56,7 @@ maxloc0_16_s1 (gfc_array_i16 * const restrict retarray,\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type dstride;\n-  const GFC_INTEGER_1 *base;\n+  const GFC_UINTEGER_1 *base;\n   GFC_INTEGER_16 * restrict dest;\n   index_type rank;\n   index_type n;\n@@ -102,7 +102,7 @@ maxloc0_16_s1 (gfc_array_i16 * const restrict retarray,\n     dest[n * dstride] = 1;\n   {\n \n-  const GFC_INTEGER_1 *maxval;\n+  const GFC_UINTEGER_1 *maxval;\n    maxval = NULL;\n \n   while (base)\n@@ -168,7 +168,7 @@ mmaxloc0_16_s1 (gfc_array_i16 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   index_type dstride;\n   GFC_INTEGER_16 *dest;\n-  const GFC_INTEGER_1 *base;\n+  const GFC_UINTEGER_1 *base;\n   GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n@@ -234,7 +234,7 @@ mmaxloc0_16_s1 (gfc_array_i16 * const restrict retarray,\n     dest[n * dstride] = 0;\n   {\n \n-  const GFC_INTEGER_1 *maxval;\n+  const GFC_UINTEGER_1 *maxval;\n \n   maxval = NULL;\n "}, {"sha": "dc16503aec0dd31026a43ca1dfadc1517218b866", "filename": "libgfortran/generated/maxloc0_16_s4.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fmaxloc0_16_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fmaxloc0_16_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_s4.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -30,14 +30,14 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <limits.h>\n \n \n-#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_16)\n+#if defined (HAVE_GFC_UINTEGER_4) && defined (HAVE_GFC_INTEGER_16)\n \n #define HAVE_BACK_ARG 1\n \n static inline int\n-compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n+compare_fcn (const GFC_UINTEGER_4 *a, const GFC_UINTEGER_4 *b, gfc_charlen_type n)\n {\n-  if (sizeof (GFC_INTEGER_4) == 1)\n+  if (sizeof (GFC_UINTEGER_4) == 1)\n     return memcmp (a, b, n);\n   else\n     return memcmp_char4 (a, b, n);\n@@ -56,7 +56,7 @@ maxloc0_16_s4 (gfc_array_i16 * const restrict retarray,\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type dstride;\n-  const GFC_INTEGER_4 *base;\n+  const GFC_UINTEGER_4 *base;\n   GFC_INTEGER_16 * restrict dest;\n   index_type rank;\n   index_type n;\n@@ -102,7 +102,7 @@ maxloc0_16_s4 (gfc_array_i16 * const restrict retarray,\n     dest[n * dstride] = 1;\n   {\n \n-  const GFC_INTEGER_4 *maxval;\n+  const GFC_UINTEGER_4 *maxval;\n    maxval = NULL;\n \n   while (base)\n@@ -168,7 +168,7 @@ mmaxloc0_16_s4 (gfc_array_i16 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   index_type dstride;\n   GFC_INTEGER_16 *dest;\n-  const GFC_INTEGER_4 *base;\n+  const GFC_UINTEGER_4 *base;\n   GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n@@ -234,7 +234,7 @@ mmaxloc0_16_s4 (gfc_array_i16 * const restrict retarray,\n     dest[n * dstride] = 0;\n   {\n \n-  const GFC_INTEGER_4 *maxval;\n+  const GFC_UINTEGER_4 *maxval;\n \n   maxval = NULL;\n "}, {"sha": "094a5b44b108d7de5f779b07a2ae1ca5804f3d41", "filename": "libgfortran/generated/maxloc0_4_s1.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fmaxloc0_4_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fmaxloc0_4_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_s1.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -30,14 +30,14 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <limits.h>\n \n \n-#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_4)\n+#if defined (HAVE_GFC_UINTEGER_1) && defined (HAVE_GFC_INTEGER_4)\n \n #define HAVE_BACK_ARG 1\n \n static inline int\n-compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n+compare_fcn (const GFC_UINTEGER_1 *a, const GFC_UINTEGER_1 *b, gfc_charlen_type n)\n {\n-  if (sizeof (GFC_INTEGER_1) == 1)\n+  if (sizeof (GFC_UINTEGER_1) == 1)\n     return memcmp (a, b, n);\n   else\n     return memcmp_char4 (a, b, n);\n@@ -56,7 +56,7 @@ maxloc0_4_s1 (gfc_array_i4 * const restrict retarray,\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type dstride;\n-  const GFC_INTEGER_1 *base;\n+  const GFC_UINTEGER_1 *base;\n   GFC_INTEGER_4 * restrict dest;\n   index_type rank;\n   index_type n;\n@@ -102,7 +102,7 @@ maxloc0_4_s1 (gfc_array_i4 * const restrict retarray,\n     dest[n * dstride] = 1;\n   {\n \n-  const GFC_INTEGER_1 *maxval;\n+  const GFC_UINTEGER_1 *maxval;\n    maxval = NULL;\n \n   while (base)\n@@ -168,7 +168,7 @@ mmaxloc0_4_s1 (gfc_array_i4 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   index_type dstride;\n   GFC_INTEGER_4 *dest;\n-  const GFC_INTEGER_1 *base;\n+  const GFC_UINTEGER_1 *base;\n   GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n@@ -234,7 +234,7 @@ mmaxloc0_4_s1 (gfc_array_i4 * const restrict retarray,\n     dest[n * dstride] = 0;\n   {\n \n-  const GFC_INTEGER_1 *maxval;\n+  const GFC_UINTEGER_1 *maxval;\n \n   maxval = NULL;\n "}, {"sha": "b751faa4ec9db90b27001c02a987938c451c58ef", "filename": "libgfortran/generated/maxloc0_4_s4.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fmaxloc0_4_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fmaxloc0_4_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_s4.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -30,14 +30,14 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <limits.h>\n \n \n-#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_4)\n+#if defined (HAVE_GFC_UINTEGER_4) && defined (HAVE_GFC_INTEGER_4)\n \n #define HAVE_BACK_ARG 1\n \n static inline int\n-compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n+compare_fcn (const GFC_UINTEGER_4 *a, const GFC_UINTEGER_4 *b, gfc_charlen_type n)\n {\n-  if (sizeof (GFC_INTEGER_4) == 1)\n+  if (sizeof (GFC_UINTEGER_4) == 1)\n     return memcmp (a, b, n);\n   else\n     return memcmp_char4 (a, b, n);\n@@ -56,7 +56,7 @@ maxloc0_4_s4 (gfc_array_i4 * const restrict retarray,\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type dstride;\n-  const GFC_INTEGER_4 *base;\n+  const GFC_UINTEGER_4 *base;\n   GFC_INTEGER_4 * restrict dest;\n   index_type rank;\n   index_type n;\n@@ -102,7 +102,7 @@ maxloc0_4_s4 (gfc_array_i4 * const restrict retarray,\n     dest[n * dstride] = 1;\n   {\n \n-  const GFC_INTEGER_4 *maxval;\n+  const GFC_UINTEGER_4 *maxval;\n    maxval = NULL;\n \n   while (base)\n@@ -168,7 +168,7 @@ mmaxloc0_4_s4 (gfc_array_i4 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   index_type dstride;\n   GFC_INTEGER_4 *dest;\n-  const GFC_INTEGER_4 *base;\n+  const GFC_UINTEGER_4 *base;\n   GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n@@ -234,7 +234,7 @@ mmaxloc0_4_s4 (gfc_array_i4 * const restrict retarray,\n     dest[n * dstride] = 0;\n   {\n \n-  const GFC_INTEGER_4 *maxval;\n+  const GFC_UINTEGER_4 *maxval;\n \n   maxval = NULL;\n "}, {"sha": "173aa13dc6343effefc25237a412d716888dc2d8", "filename": "libgfortran/generated/maxloc0_8_s1.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fmaxloc0_8_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fmaxloc0_8_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_s1.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -30,14 +30,14 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <limits.h>\n \n \n-#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_8)\n+#if defined (HAVE_GFC_UINTEGER_1) && defined (HAVE_GFC_INTEGER_8)\n \n #define HAVE_BACK_ARG 1\n \n static inline int\n-compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n+compare_fcn (const GFC_UINTEGER_1 *a, const GFC_UINTEGER_1 *b, gfc_charlen_type n)\n {\n-  if (sizeof (GFC_INTEGER_1) == 1)\n+  if (sizeof (GFC_UINTEGER_1) == 1)\n     return memcmp (a, b, n);\n   else\n     return memcmp_char4 (a, b, n);\n@@ -56,7 +56,7 @@ maxloc0_8_s1 (gfc_array_i8 * const restrict retarray,\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type dstride;\n-  const GFC_INTEGER_1 *base;\n+  const GFC_UINTEGER_1 *base;\n   GFC_INTEGER_8 * restrict dest;\n   index_type rank;\n   index_type n;\n@@ -102,7 +102,7 @@ maxloc0_8_s1 (gfc_array_i8 * const restrict retarray,\n     dest[n * dstride] = 1;\n   {\n \n-  const GFC_INTEGER_1 *maxval;\n+  const GFC_UINTEGER_1 *maxval;\n    maxval = NULL;\n \n   while (base)\n@@ -168,7 +168,7 @@ mmaxloc0_8_s1 (gfc_array_i8 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   index_type dstride;\n   GFC_INTEGER_8 *dest;\n-  const GFC_INTEGER_1 *base;\n+  const GFC_UINTEGER_1 *base;\n   GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n@@ -234,7 +234,7 @@ mmaxloc0_8_s1 (gfc_array_i8 * const restrict retarray,\n     dest[n * dstride] = 0;\n   {\n \n-  const GFC_INTEGER_1 *maxval;\n+  const GFC_UINTEGER_1 *maxval;\n \n   maxval = NULL;\n "}, {"sha": "60176b4bbb96a5ab54b8ed1af1a69820d17e8522", "filename": "libgfortran/generated/maxloc0_8_s4.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fmaxloc0_8_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fmaxloc0_8_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_s4.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -30,14 +30,14 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <limits.h>\n \n \n-#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_8)\n+#if defined (HAVE_GFC_UINTEGER_4) && defined (HAVE_GFC_INTEGER_8)\n \n #define HAVE_BACK_ARG 1\n \n static inline int\n-compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n+compare_fcn (const GFC_UINTEGER_4 *a, const GFC_UINTEGER_4 *b, gfc_charlen_type n)\n {\n-  if (sizeof (GFC_INTEGER_4) == 1)\n+  if (sizeof (GFC_UINTEGER_4) == 1)\n     return memcmp (a, b, n);\n   else\n     return memcmp_char4 (a, b, n);\n@@ -56,7 +56,7 @@ maxloc0_8_s4 (gfc_array_i8 * const restrict retarray,\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type dstride;\n-  const GFC_INTEGER_4 *base;\n+  const GFC_UINTEGER_4 *base;\n   GFC_INTEGER_8 * restrict dest;\n   index_type rank;\n   index_type n;\n@@ -102,7 +102,7 @@ maxloc0_8_s4 (gfc_array_i8 * const restrict retarray,\n     dest[n * dstride] = 1;\n   {\n \n-  const GFC_INTEGER_4 *maxval;\n+  const GFC_UINTEGER_4 *maxval;\n    maxval = NULL;\n \n   while (base)\n@@ -168,7 +168,7 @@ mmaxloc0_8_s4 (gfc_array_i8 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   index_type dstride;\n   GFC_INTEGER_8 *dest;\n-  const GFC_INTEGER_4 *base;\n+  const GFC_UINTEGER_4 *base;\n   GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n@@ -234,7 +234,7 @@ mmaxloc0_8_s4 (gfc_array_i8 * const restrict retarray,\n     dest[n * dstride] = 0;\n   {\n \n-  const GFC_INTEGER_4 *maxval;\n+  const GFC_UINTEGER_4 *maxval;\n \n   maxval = NULL;\n "}, {"sha": "538d44c09665e7e065c1ea6461fbedfa7be7ae2c", "filename": "libgfortran/generated/maxloc1_16_s1.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fmaxloc1_16_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fmaxloc1_16_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_s1.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -26,17 +26,17 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"libgfortran.h\"\n \n \n-#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_16)\n+#if defined (HAVE_GFC_UINTEGER_1) && defined (HAVE_GFC_INTEGER_16)\n \n #define HAVE_BACK_ARG 1\n \n #include <string.h>\n #include <assert.h>\n \n static inline int\n-compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n+compare_fcn (const GFC_UINTEGER_1 *a, const GFC_UINTEGER_1 *b, gfc_charlen_type n)\n {\n-  if (sizeof (GFC_INTEGER_1) == 1)\n+  if (sizeof (GFC_UINTEGER_1) == 1)\n     return memcmp (a, b, n);\n   else\n     return memcmp_char4 (a, b, n);\n@@ -57,7 +57,7 @@ maxloc1_16_s1 (gfc_array_i16 * const restrict retarray,\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type dstride[GFC_MAX_DIMENSIONS];\n-  const GFC_INTEGER_1 * restrict base;\n+  const GFC_UINTEGER_1 * restrict base;\n   GFC_INTEGER_16 * restrict dest;\n   index_type rank;\n   index_type n;\n@@ -155,12 +155,12 @@ maxloc1_16_s1 (gfc_array_i16 * const restrict retarray,\n   continue_loop = 1;\n   while (continue_loop)\n     {\n-      const GFC_INTEGER_1 * restrict src;\n+      const GFC_UINTEGER_1 * restrict src;\n       GFC_INTEGER_16 result;\n       src = base;\n       {\n \n-\tconst GFC_INTEGER_1 *maxval;\n+\tconst GFC_UINTEGER_1 *maxval;\n \tmaxval = NULL;\n \tresult = 0;\n \tif (len <= 0)\n@@ -231,7 +231,7 @@ mmaxloc1_16_s1 (gfc_array_i16 * const restrict retarray,\n   index_type dstride[GFC_MAX_DIMENSIONS];\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_16 * restrict dest;\n-  const GFC_INTEGER_1 * restrict base;\n+  const GFC_UINTEGER_1 * restrict base;\n   const GFC_LOGICAL_1 * restrict mbase;\n   index_type rank;\n   index_type dim;\n@@ -349,14 +349,14 @@ mmaxloc1_16_s1 (gfc_array_i16 * const restrict retarray,\n \n   while (base)\n     {\n-      const GFC_INTEGER_1 * restrict src;\n+      const GFC_UINTEGER_1 * restrict src;\n       const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_16 result;\n       src = base;\n       msrc = mbase;\n       {\n \n-\tconst GFC_INTEGER_1 *maxval;\n+\tconst GFC_UINTEGER_1 *maxval;\n \tmaxval = base;\n \tresult = 0;\n \tfor (n = 0; n < len; n++, src += delta, msrc += mdelta)"}, {"sha": "dce5c890376578bdcdc9da0da4604bdc846dbf05", "filename": "libgfortran/generated/maxloc1_16_s4.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fmaxloc1_16_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fmaxloc1_16_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_s4.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -26,17 +26,17 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"libgfortran.h\"\n \n \n-#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_16)\n+#if defined (HAVE_GFC_UINTEGER_4) && defined (HAVE_GFC_INTEGER_16)\n \n #define HAVE_BACK_ARG 1\n \n #include <string.h>\n #include <assert.h>\n \n static inline int\n-compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n+compare_fcn (const GFC_UINTEGER_4 *a, const GFC_UINTEGER_4 *b, gfc_charlen_type n)\n {\n-  if (sizeof (GFC_INTEGER_4) == 1)\n+  if (sizeof (GFC_UINTEGER_4) == 1)\n     return memcmp (a, b, n);\n   else\n     return memcmp_char4 (a, b, n);\n@@ -57,7 +57,7 @@ maxloc1_16_s4 (gfc_array_i16 * const restrict retarray,\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type dstride[GFC_MAX_DIMENSIONS];\n-  const GFC_INTEGER_4 * restrict base;\n+  const GFC_UINTEGER_4 * restrict base;\n   GFC_INTEGER_16 * restrict dest;\n   index_type rank;\n   index_type n;\n@@ -155,12 +155,12 @@ maxloc1_16_s4 (gfc_array_i16 * const restrict retarray,\n   continue_loop = 1;\n   while (continue_loop)\n     {\n-      const GFC_INTEGER_4 * restrict src;\n+      const GFC_UINTEGER_4 * restrict src;\n       GFC_INTEGER_16 result;\n       src = base;\n       {\n \n-\tconst GFC_INTEGER_4 *maxval;\n+\tconst GFC_UINTEGER_4 *maxval;\n \tmaxval = NULL;\n \tresult = 0;\n \tif (len <= 0)\n@@ -231,7 +231,7 @@ mmaxloc1_16_s4 (gfc_array_i16 * const restrict retarray,\n   index_type dstride[GFC_MAX_DIMENSIONS];\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_16 * restrict dest;\n-  const GFC_INTEGER_4 * restrict base;\n+  const GFC_UINTEGER_4 * restrict base;\n   const GFC_LOGICAL_1 * restrict mbase;\n   index_type rank;\n   index_type dim;\n@@ -349,14 +349,14 @@ mmaxloc1_16_s4 (gfc_array_i16 * const restrict retarray,\n \n   while (base)\n     {\n-      const GFC_INTEGER_4 * restrict src;\n+      const GFC_UINTEGER_4 * restrict src;\n       const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_16 result;\n       src = base;\n       msrc = mbase;\n       {\n \n-\tconst GFC_INTEGER_4 *maxval;\n+\tconst GFC_UINTEGER_4 *maxval;\n \tmaxval = base;\n \tresult = 0;\n \tfor (n = 0; n < len; n++, src += delta, msrc += mdelta)"}, {"sha": "d194d70b7d2e618d36cdd4d9f352c9589897b0d9", "filename": "libgfortran/generated/maxloc1_4_s1.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fmaxloc1_4_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fmaxloc1_4_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_s1.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -26,17 +26,17 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"libgfortran.h\"\n \n \n-#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_4)\n+#if defined (HAVE_GFC_UINTEGER_1) && defined (HAVE_GFC_INTEGER_4)\n \n #define HAVE_BACK_ARG 1\n \n #include <string.h>\n #include <assert.h>\n \n static inline int\n-compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n+compare_fcn (const GFC_UINTEGER_1 *a, const GFC_UINTEGER_1 *b, gfc_charlen_type n)\n {\n-  if (sizeof (GFC_INTEGER_1) == 1)\n+  if (sizeof (GFC_UINTEGER_1) == 1)\n     return memcmp (a, b, n);\n   else\n     return memcmp_char4 (a, b, n);\n@@ -57,7 +57,7 @@ maxloc1_4_s1 (gfc_array_i4 * const restrict retarray,\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type dstride[GFC_MAX_DIMENSIONS];\n-  const GFC_INTEGER_1 * restrict base;\n+  const GFC_UINTEGER_1 * restrict base;\n   GFC_INTEGER_4 * restrict dest;\n   index_type rank;\n   index_type n;\n@@ -155,12 +155,12 @@ maxloc1_4_s1 (gfc_array_i4 * const restrict retarray,\n   continue_loop = 1;\n   while (continue_loop)\n     {\n-      const GFC_INTEGER_1 * restrict src;\n+      const GFC_UINTEGER_1 * restrict src;\n       GFC_INTEGER_4 result;\n       src = base;\n       {\n \n-\tconst GFC_INTEGER_1 *maxval;\n+\tconst GFC_UINTEGER_1 *maxval;\n \tmaxval = NULL;\n \tresult = 0;\n \tif (len <= 0)\n@@ -231,7 +231,7 @@ mmaxloc1_4_s1 (gfc_array_i4 * const restrict retarray,\n   index_type dstride[GFC_MAX_DIMENSIONS];\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_4 * restrict dest;\n-  const GFC_INTEGER_1 * restrict base;\n+  const GFC_UINTEGER_1 * restrict base;\n   const GFC_LOGICAL_1 * restrict mbase;\n   index_type rank;\n   index_type dim;\n@@ -349,14 +349,14 @@ mmaxloc1_4_s1 (gfc_array_i4 * const restrict retarray,\n \n   while (base)\n     {\n-      const GFC_INTEGER_1 * restrict src;\n+      const GFC_UINTEGER_1 * restrict src;\n       const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_4 result;\n       src = base;\n       msrc = mbase;\n       {\n \n-\tconst GFC_INTEGER_1 *maxval;\n+\tconst GFC_UINTEGER_1 *maxval;\n \tmaxval = base;\n \tresult = 0;\n \tfor (n = 0; n < len; n++, src += delta, msrc += mdelta)"}, {"sha": "b3e68b5377d6782576fc94131f5266670e475f41", "filename": "libgfortran/generated/maxloc1_4_s4.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fmaxloc1_4_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fmaxloc1_4_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_s4.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -26,17 +26,17 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"libgfortran.h\"\n \n \n-#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_4)\n+#if defined (HAVE_GFC_UINTEGER_4) && defined (HAVE_GFC_INTEGER_4)\n \n #define HAVE_BACK_ARG 1\n \n #include <string.h>\n #include <assert.h>\n \n static inline int\n-compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n+compare_fcn (const GFC_UINTEGER_4 *a, const GFC_UINTEGER_4 *b, gfc_charlen_type n)\n {\n-  if (sizeof (GFC_INTEGER_4) == 1)\n+  if (sizeof (GFC_UINTEGER_4) == 1)\n     return memcmp (a, b, n);\n   else\n     return memcmp_char4 (a, b, n);\n@@ -57,7 +57,7 @@ maxloc1_4_s4 (gfc_array_i4 * const restrict retarray,\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type dstride[GFC_MAX_DIMENSIONS];\n-  const GFC_INTEGER_4 * restrict base;\n+  const GFC_UINTEGER_4 * restrict base;\n   GFC_INTEGER_4 * restrict dest;\n   index_type rank;\n   index_type n;\n@@ -155,12 +155,12 @@ maxloc1_4_s4 (gfc_array_i4 * const restrict retarray,\n   continue_loop = 1;\n   while (continue_loop)\n     {\n-      const GFC_INTEGER_4 * restrict src;\n+      const GFC_UINTEGER_4 * restrict src;\n       GFC_INTEGER_4 result;\n       src = base;\n       {\n \n-\tconst GFC_INTEGER_4 *maxval;\n+\tconst GFC_UINTEGER_4 *maxval;\n \tmaxval = NULL;\n \tresult = 0;\n \tif (len <= 0)\n@@ -231,7 +231,7 @@ mmaxloc1_4_s4 (gfc_array_i4 * const restrict retarray,\n   index_type dstride[GFC_MAX_DIMENSIONS];\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_4 * restrict dest;\n-  const GFC_INTEGER_4 * restrict base;\n+  const GFC_UINTEGER_4 * restrict base;\n   const GFC_LOGICAL_1 * restrict mbase;\n   index_type rank;\n   index_type dim;\n@@ -349,14 +349,14 @@ mmaxloc1_4_s4 (gfc_array_i4 * const restrict retarray,\n \n   while (base)\n     {\n-      const GFC_INTEGER_4 * restrict src;\n+      const GFC_UINTEGER_4 * restrict src;\n       const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_4 result;\n       src = base;\n       msrc = mbase;\n       {\n \n-\tconst GFC_INTEGER_4 *maxval;\n+\tconst GFC_UINTEGER_4 *maxval;\n \tmaxval = base;\n \tresult = 0;\n \tfor (n = 0; n < len; n++, src += delta, msrc += mdelta)"}, {"sha": "0832e7bea85ab36e670885e88835a0796267ca42", "filename": "libgfortran/generated/maxloc1_8_s1.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fmaxloc1_8_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fmaxloc1_8_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_s1.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -26,17 +26,17 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"libgfortran.h\"\n \n \n-#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_8)\n+#if defined (HAVE_GFC_UINTEGER_1) && defined (HAVE_GFC_INTEGER_8)\n \n #define HAVE_BACK_ARG 1\n \n #include <string.h>\n #include <assert.h>\n \n static inline int\n-compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n+compare_fcn (const GFC_UINTEGER_1 *a, const GFC_UINTEGER_1 *b, gfc_charlen_type n)\n {\n-  if (sizeof (GFC_INTEGER_1) == 1)\n+  if (sizeof (GFC_UINTEGER_1) == 1)\n     return memcmp (a, b, n);\n   else\n     return memcmp_char4 (a, b, n);\n@@ -57,7 +57,7 @@ maxloc1_8_s1 (gfc_array_i8 * const restrict retarray,\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type dstride[GFC_MAX_DIMENSIONS];\n-  const GFC_INTEGER_1 * restrict base;\n+  const GFC_UINTEGER_1 * restrict base;\n   GFC_INTEGER_8 * restrict dest;\n   index_type rank;\n   index_type n;\n@@ -155,12 +155,12 @@ maxloc1_8_s1 (gfc_array_i8 * const restrict retarray,\n   continue_loop = 1;\n   while (continue_loop)\n     {\n-      const GFC_INTEGER_1 * restrict src;\n+      const GFC_UINTEGER_1 * restrict src;\n       GFC_INTEGER_8 result;\n       src = base;\n       {\n \n-\tconst GFC_INTEGER_1 *maxval;\n+\tconst GFC_UINTEGER_1 *maxval;\n \tmaxval = NULL;\n \tresult = 0;\n \tif (len <= 0)\n@@ -231,7 +231,7 @@ mmaxloc1_8_s1 (gfc_array_i8 * const restrict retarray,\n   index_type dstride[GFC_MAX_DIMENSIONS];\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_8 * restrict dest;\n-  const GFC_INTEGER_1 * restrict base;\n+  const GFC_UINTEGER_1 * restrict base;\n   const GFC_LOGICAL_1 * restrict mbase;\n   index_type rank;\n   index_type dim;\n@@ -349,14 +349,14 @@ mmaxloc1_8_s1 (gfc_array_i8 * const restrict retarray,\n \n   while (base)\n     {\n-      const GFC_INTEGER_1 * restrict src;\n+      const GFC_UINTEGER_1 * restrict src;\n       const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_8 result;\n       src = base;\n       msrc = mbase;\n       {\n \n-\tconst GFC_INTEGER_1 *maxval;\n+\tconst GFC_UINTEGER_1 *maxval;\n \tmaxval = base;\n \tresult = 0;\n \tfor (n = 0; n < len; n++, src += delta, msrc += mdelta)"}, {"sha": "967f3fdd30ca97c7da5cd568c7e2e49055d44bd3", "filename": "libgfortran/generated/maxloc1_8_s4.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fmaxloc1_8_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fmaxloc1_8_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_s4.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -26,17 +26,17 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"libgfortran.h\"\n \n \n-#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_8)\n+#if defined (HAVE_GFC_UINTEGER_4) && defined (HAVE_GFC_INTEGER_8)\n \n #define HAVE_BACK_ARG 1\n \n #include <string.h>\n #include <assert.h>\n \n static inline int\n-compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n+compare_fcn (const GFC_UINTEGER_4 *a, const GFC_UINTEGER_4 *b, gfc_charlen_type n)\n {\n-  if (sizeof (GFC_INTEGER_4) == 1)\n+  if (sizeof (GFC_UINTEGER_4) == 1)\n     return memcmp (a, b, n);\n   else\n     return memcmp_char4 (a, b, n);\n@@ -57,7 +57,7 @@ maxloc1_8_s4 (gfc_array_i8 * const restrict retarray,\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type dstride[GFC_MAX_DIMENSIONS];\n-  const GFC_INTEGER_4 * restrict base;\n+  const GFC_UINTEGER_4 * restrict base;\n   GFC_INTEGER_8 * restrict dest;\n   index_type rank;\n   index_type n;\n@@ -155,12 +155,12 @@ maxloc1_8_s4 (gfc_array_i8 * const restrict retarray,\n   continue_loop = 1;\n   while (continue_loop)\n     {\n-      const GFC_INTEGER_4 * restrict src;\n+      const GFC_UINTEGER_4 * restrict src;\n       GFC_INTEGER_8 result;\n       src = base;\n       {\n \n-\tconst GFC_INTEGER_4 *maxval;\n+\tconst GFC_UINTEGER_4 *maxval;\n \tmaxval = NULL;\n \tresult = 0;\n \tif (len <= 0)\n@@ -231,7 +231,7 @@ mmaxloc1_8_s4 (gfc_array_i8 * const restrict retarray,\n   index_type dstride[GFC_MAX_DIMENSIONS];\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_8 * restrict dest;\n-  const GFC_INTEGER_4 * restrict base;\n+  const GFC_UINTEGER_4 * restrict base;\n   const GFC_LOGICAL_1 * restrict mbase;\n   index_type rank;\n   index_type dim;\n@@ -349,14 +349,14 @@ mmaxloc1_8_s4 (gfc_array_i8 * const restrict retarray,\n \n   while (base)\n     {\n-      const GFC_INTEGER_4 * restrict src;\n+      const GFC_UINTEGER_4 * restrict src;\n       const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_8 result;\n       src = base;\n       msrc = mbase;\n       {\n \n-\tconst GFC_INTEGER_4 *maxval;\n+\tconst GFC_UINTEGER_4 *maxval;\n \tmaxval = base;\n \tresult = 0;\n \tfor (n = 0; n < len; n++, src += delta, msrc += mdelta)"}, {"sha": "d97fcd01e97aa82f0d1790a98632654978251366", "filename": "libgfortran/generated/maxloc2_16_s1.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fmaxloc2_16_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fmaxloc2_16_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc2_16_s1.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -28,12 +28,12 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <string.h>\n #include <assert.h>\n \n-#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_16)\n+#if defined (HAVE_GFC_UINTEGER_1) && defined (HAVE_GFC_INTEGER_16)\n \n static inline int\n-compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n+compare_fcn (const GFC_UINTEGER_1 *a, const GFC_UINTEGER_1 *b, gfc_charlen_type n)\n {\n-  if (sizeof (GFC_INTEGER_1) == 1)\n+  if (sizeof (GFC_UINTEGER_1) == 1)\n     return memcmp (a, b, n);\n   else\n     return memcmp_char4 (a, b, n);\n@@ -49,8 +49,8 @@ maxloc2_16_s1 (gfc_array_s1 * const restrict array, GFC_LOGICAL_4 back, gfc_char\n   index_type ret;\n   index_type sstride;\n   index_type extent;\n-  const GFC_INTEGER_1 *src;\n-  const GFC_INTEGER_1 *maxval;\n+  const GFC_UINTEGER_1 *src;\n+  const GFC_UINTEGER_1 *maxval;\n   index_type i;\n \n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n@@ -88,8 +88,8 @@ mmaxloc2_16_s1 (gfc_array_s1 * const restrict array,\n   index_type ret;\n   index_type sstride;\n   index_type extent;\n-  const GFC_INTEGER_1 *src;\n-  const GFC_INTEGER_1 *maxval;\n+  const GFC_UINTEGER_1 *src;\n+  const GFC_UINTEGER_1 *maxval;\n   index_type i, j;\n   GFC_LOGICAL_1 *mbase;\n   int mask_kind;"}, {"sha": "995cac911806966ce4795f5042634e70c9fe6cf8", "filename": "libgfortran/generated/maxloc2_16_s4.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fmaxloc2_16_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fmaxloc2_16_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc2_16_s4.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -28,12 +28,12 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <string.h>\n #include <assert.h>\n \n-#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_16)\n+#if defined (HAVE_GFC_UINTEGER_4) && defined (HAVE_GFC_INTEGER_16)\n \n static inline int\n-compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n+compare_fcn (const GFC_UINTEGER_4 *a, const GFC_UINTEGER_4 *b, gfc_charlen_type n)\n {\n-  if (sizeof (GFC_INTEGER_4) == 1)\n+  if (sizeof (GFC_UINTEGER_4) == 1)\n     return memcmp (a, b, n);\n   else\n     return memcmp_char4 (a, b, n);\n@@ -49,8 +49,8 @@ maxloc2_16_s4 (gfc_array_s4 * const restrict array, GFC_LOGICAL_4 back, gfc_char\n   index_type ret;\n   index_type sstride;\n   index_type extent;\n-  const GFC_INTEGER_4 *src;\n-  const GFC_INTEGER_4 *maxval;\n+  const GFC_UINTEGER_4 *src;\n+  const GFC_UINTEGER_4 *maxval;\n   index_type i;\n \n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n@@ -88,8 +88,8 @@ mmaxloc2_16_s4 (gfc_array_s4 * const restrict array,\n   index_type ret;\n   index_type sstride;\n   index_type extent;\n-  const GFC_INTEGER_4 *src;\n-  const GFC_INTEGER_4 *maxval;\n+  const GFC_UINTEGER_4 *src;\n+  const GFC_UINTEGER_4 *maxval;\n   index_type i, j;\n   GFC_LOGICAL_1 *mbase;\n   int mask_kind;"}, {"sha": "932d3d651af1c4fbe79b1e48f2a54eca79e7a058", "filename": "libgfortran/generated/maxloc2_4_s1.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fmaxloc2_4_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fmaxloc2_4_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc2_4_s1.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -28,12 +28,12 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <string.h>\n #include <assert.h>\n \n-#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_4)\n+#if defined (HAVE_GFC_UINTEGER_1) && defined (HAVE_GFC_INTEGER_4)\n \n static inline int\n-compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n+compare_fcn (const GFC_UINTEGER_1 *a, const GFC_UINTEGER_1 *b, gfc_charlen_type n)\n {\n-  if (sizeof (GFC_INTEGER_1) == 1)\n+  if (sizeof (GFC_UINTEGER_1) == 1)\n     return memcmp (a, b, n);\n   else\n     return memcmp_char4 (a, b, n);\n@@ -49,8 +49,8 @@ maxloc2_4_s1 (gfc_array_s1 * const restrict array, GFC_LOGICAL_4 back, gfc_charl\n   index_type ret;\n   index_type sstride;\n   index_type extent;\n-  const GFC_INTEGER_1 *src;\n-  const GFC_INTEGER_1 *maxval;\n+  const GFC_UINTEGER_1 *src;\n+  const GFC_UINTEGER_1 *maxval;\n   index_type i;\n \n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n@@ -88,8 +88,8 @@ mmaxloc2_4_s1 (gfc_array_s1 * const restrict array,\n   index_type ret;\n   index_type sstride;\n   index_type extent;\n-  const GFC_INTEGER_1 *src;\n-  const GFC_INTEGER_1 *maxval;\n+  const GFC_UINTEGER_1 *src;\n+  const GFC_UINTEGER_1 *maxval;\n   index_type i, j;\n   GFC_LOGICAL_1 *mbase;\n   int mask_kind;"}, {"sha": "0242f25f0b15c2d769b80968b489d470dde27d99", "filename": "libgfortran/generated/maxloc2_4_s4.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fmaxloc2_4_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fmaxloc2_4_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc2_4_s4.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -28,12 +28,12 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <string.h>\n #include <assert.h>\n \n-#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_4)\n+#if defined (HAVE_GFC_UINTEGER_4) && defined (HAVE_GFC_INTEGER_4)\n \n static inline int\n-compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n+compare_fcn (const GFC_UINTEGER_4 *a, const GFC_UINTEGER_4 *b, gfc_charlen_type n)\n {\n-  if (sizeof (GFC_INTEGER_4) == 1)\n+  if (sizeof (GFC_UINTEGER_4) == 1)\n     return memcmp (a, b, n);\n   else\n     return memcmp_char4 (a, b, n);\n@@ -49,8 +49,8 @@ maxloc2_4_s4 (gfc_array_s4 * const restrict array, GFC_LOGICAL_4 back, gfc_charl\n   index_type ret;\n   index_type sstride;\n   index_type extent;\n-  const GFC_INTEGER_4 *src;\n-  const GFC_INTEGER_4 *maxval;\n+  const GFC_UINTEGER_4 *src;\n+  const GFC_UINTEGER_4 *maxval;\n   index_type i;\n \n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n@@ -88,8 +88,8 @@ mmaxloc2_4_s4 (gfc_array_s4 * const restrict array,\n   index_type ret;\n   index_type sstride;\n   index_type extent;\n-  const GFC_INTEGER_4 *src;\n-  const GFC_INTEGER_4 *maxval;\n+  const GFC_UINTEGER_4 *src;\n+  const GFC_UINTEGER_4 *maxval;\n   index_type i, j;\n   GFC_LOGICAL_1 *mbase;\n   int mask_kind;"}, {"sha": "e401722feaafa74d89c481f8173a10f3bdaa15f6", "filename": "libgfortran/generated/maxloc2_8_s1.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fmaxloc2_8_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fmaxloc2_8_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc2_8_s1.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -28,12 +28,12 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <string.h>\n #include <assert.h>\n \n-#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_8)\n+#if defined (HAVE_GFC_UINTEGER_1) && defined (HAVE_GFC_INTEGER_8)\n \n static inline int\n-compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n+compare_fcn (const GFC_UINTEGER_1 *a, const GFC_UINTEGER_1 *b, gfc_charlen_type n)\n {\n-  if (sizeof (GFC_INTEGER_1) == 1)\n+  if (sizeof (GFC_UINTEGER_1) == 1)\n     return memcmp (a, b, n);\n   else\n     return memcmp_char4 (a, b, n);\n@@ -49,8 +49,8 @@ maxloc2_8_s1 (gfc_array_s1 * const restrict array, GFC_LOGICAL_4 back, gfc_charl\n   index_type ret;\n   index_type sstride;\n   index_type extent;\n-  const GFC_INTEGER_1 *src;\n-  const GFC_INTEGER_1 *maxval;\n+  const GFC_UINTEGER_1 *src;\n+  const GFC_UINTEGER_1 *maxval;\n   index_type i;\n \n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n@@ -88,8 +88,8 @@ mmaxloc2_8_s1 (gfc_array_s1 * const restrict array,\n   index_type ret;\n   index_type sstride;\n   index_type extent;\n-  const GFC_INTEGER_1 *src;\n-  const GFC_INTEGER_1 *maxval;\n+  const GFC_UINTEGER_1 *src;\n+  const GFC_UINTEGER_1 *maxval;\n   index_type i, j;\n   GFC_LOGICAL_1 *mbase;\n   int mask_kind;"}, {"sha": "dfb4ba553dd8f396400c53c48cdb3e4036abef88", "filename": "libgfortran/generated/maxloc2_8_s4.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fmaxloc2_8_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fmaxloc2_8_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc2_8_s4.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -28,12 +28,12 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <string.h>\n #include <assert.h>\n \n-#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_8)\n+#if defined (HAVE_GFC_UINTEGER_4) && defined (HAVE_GFC_INTEGER_8)\n \n static inline int\n-compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n+compare_fcn (const GFC_UINTEGER_4 *a, const GFC_UINTEGER_4 *b, gfc_charlen_type n)\n {\n-  if (sizeof (GFC_INTEGER_4) == 1)\n+  if (sizeof (GFC_UINTEGER_4) == 1)\n     return memcmp (a, b, n);\n   else\n     return memcmp_char4 (a, b, n);\n@@ -49,8 +49,8 @@ maxloc2_8_s4 (gfc_array_s4 * const restrict array, GFC_LOGICAL_4 back, gfc_charl\n   index_type ret;\n   index_type sstride;\n   index_type extent;\n-  const GFC_INTEGER_4 *src;\n-  const GFC_INTEGER_4 *maxval;\n+  const GFC_UINTEGER_4 *src;\n+  const GFC_UINTEGER_4 *maxval;\n   index_type i;\n \n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n@@ -88,8 +88,8 @@ mmaxloc2_8_s4 (gfc_array_s4 * const restrict array,\n   index_type ret;\n   index_type sstride;\n   index_type extent;\n-  const GFC_INTEGER_4 *src;\n-  const GFC_INTEGER_4 *maxval;\n+  const GFC_UINTEGER_4 *src;\n+  const GFC_UINTEGER_4 *maxval;\n   index_type i, j;\n   GFC_LOGICAL_1 *mbase;\n   int mask_kind;"}, {"sha": "690391866f0216690c9e90d5389ef9df27d2ed33", "filename": "libgfortran/generated/maxval0_s1.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fmaxval0_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fmaxval0_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval0_s1.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -30,12 +30,12 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <limits.h>\n \n \n-#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_1)\n+#if defined (HAVE_GFC_UINTEGER_1) && defined (HAVE_GFC_UINTEGER_1)\n \n static inline int\n-compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n+compare_fcn (const GFC_UINTEGER_1 *a, const GFC_UINTEGER_1 *b, gfc_charlen_type n)\n {\n-  if (sizeof (GFC_INTEGER_1) == 1)\n+  if (sizeof (GFC_UINTEGER_1) == 1)\n     return memcmp (a, b, n);\n   else\n     return memcmp_char4 (a, b, n);\n@@ -44,20 +44,20 @@ compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n \n #define INITVAL 0\n \n-extern void maxval0_s1 (GFC_INTEGER_1 * restrict,\n+extern void maxval0_s1 (GFC_UINTEGER_1 * restrict,\n         gfc_charlen_type,\n \tgfc_array_s1 * const restrict array, gfc_charlen_type);\n export_proto(maxval0_s1);\n \n void\n-maxval0_s1 (GFC_INTEGER_1 * restrict ret,\n+maxval0_s1 (GFC_UINTEGER_1 * restrict ret,\n         gfc_charlen_type xlen,\n \tgfc_array_s1 * const restrict array, gfc_charlen_type len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n-  const GFC_INTEGER_1 *base;\n+  const GFC_UINTEGER_1 *base;\n   index_type rank;\n   index_type n;\n \n@@ -83,7 +83,7 @@ maxval0_s1 (GFC_INTEGER_1 * restrict ret,\n \n   {\n \n-  const GFC_INTEGER_1 *retval;\n+  const GFC_UINTEGER_1 *retval;\n    retval = ret;\n \n   while (base)\n@@ -130,21 +130,21 @@ maxval0_s1 (GFC_INTEGER_1 * restrict ret,\n }\n \n \n-extern void mmaxval0_s1 (GFC_INTEGER_1 * restrict,\n+extern void mmaxval0_s1 (GFC_UINTEGER_1 * restrict,\n        gfc_charlen_type, gfc_array_s1 * const restrict array,\n        gfc_array_l1 * const restrict mask, gfc_charlen_type len);\n export_proto(mmaxval0_s1);\n \n void\n-mmaxval0_s1 (GFC_INTEGER_1 * const restrict ret,\n+mmaxval0_s1 (GFC_UINTEGER_1 * const restrict ret,\n \tgfc_charlen_type xlen, gfc_array_s1 * const restrict array,\n \tgfc_array_l1 * const restrict mask, gfc_charlen_type len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type mstride[GFC_MAX_DIMENSIONS];\n-  const GFC_INTEGER_1 *base;\n+  const GFC_UINTEGER_1 *base;\n   GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n@@ -185,7 +185,7 @@ mmaxval0_s1 (GFC_INTEGER_1 * const restrict ret,\n   base = array->base_addr;\n   {\n \n-  const GFC_INTEGER_1 *retval;\n+  const GFC_UINTEGER_1 *retval;\n \n   retval = ret;\n \n@@ -236,13 +236,13 @@ mmaxval0_s1 (GFC_INTEGER_1 * const restrict ret,\n }\n \n \n-extern void smaxval0_s1 (GFC_INTEGER_1 * restrict,\n+extern void smaxval0_s1 (GFC_UINTEGER_1 * restrict,\n         gfc_charlen_type,\n \tgfc_array_s1 * const restrict array, GFC_LOGICAL_4 *, gfc_charlen_type);\n export_proto(smaxval0_s1);\n \n void\n-smaxval0_s1 (GFC_INTEGER_1 * restrict ret,\n+smaxval0_s1 (GFC_UINTEGER_1 * restrict ret,\n         gfc_charlen_type xlen, gfc_array_s1 * const restrict array,\n \tGFC_LOGICAL_4 *mask, gfc_charlen_type len)\n \t"}, {"sha": "111a5ded268895cc2ddf58f1c107d00ef6242643", "filename": "libgfortran/generated/maxval0_s4.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fmaxval0_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fmaxval0_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval0_s4.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -30,12 +30,12 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <limits.h>\n \n \n-#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_4)\n+#if defined (HAVE_GFC_UINTEGER_4) && defined (HAVE_GFC_UINTEGER_4)\n \n static inline int\n-compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n+compare_fcn (const GFC_UINTEGER_4 *a, const GFC_UINTEGER_4 *b, gfc_charlen_type n)\n {\n-  if (sizeof (GFC_INTEGER_4) == 1)\n+  if (sizeof (GFC_UINTEGER_4) == 1)\n     return memcmp (a, b, n);\n   else\n     return memcmp_char4 (a, b, n);\n@@ -44,20 +44,20 @@ compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n \n #define INITVAL 0\n \n-extern void maxval0_s4 (GFC_INTEGER_4 * restrict,\n+extern void maxval0_s4 (GFC_UINTEGER_4 * restrict,\n         gfc_charlen_type,\n \tgfc_array_s4 * const restrict array, gfc_charlen_type);\n export_proto(maxval0_s4);\n \n void\n-maxval0_s4 (GFC_INTEGER_4 * restrict ret,\n+maxval0_s4 (GFC_UINTEGER_4 * restrict ret,\n         gfc_charlen_type xlen,\n \tgfc_array_s4 * const restrict array, gfc_charlen_type len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n-  const GFC_INTEGER_4 *base;\n+  const GFC_UINTEGER_4 *base;\n   index_type rank;\n   index_type n;\n \n@@ -83,7 +83,7 @@ maxval0_s4 (GFC_INTEGER_4 * restrict ret,\n \n   {\n \n-  const GFC_INTEGER_4 *retval;\n+  const GFC_UINTEGER_4 *retval;\n    retval = ret;\n \n   while (base)\n@@ -130,21 +130,21 @@ maxval0_s4 (GFC_INTEGER_4 * restrict ret,\n }\n \n \n-extern void mmaxval0_s4 (GFC_INTEGER_4 * restrict,\n+extern void mmaxval0_s4 (GFC_UINTEGER_4 * restrict,\n        gfc_charlen_type, gfc_array_s4 * const restrict array,\n        gfc_array_l1 * const restrict mask, gfc_charlen_type len);\n export_proto(mmaxval0_s4);\n \n void\n-mmaxval0_s4 (GFC_INTEGER_4 * const restrict ret,\n+mmaxval0_s4 (GFC_UINTEGER_4 * const restrict ret,\n \tgfc_charlen_type xlen, gfc_array_s4 * const restrict array,\n \tgfc_array_l1 * const restrict mask, gfc_charlen_type len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type mstride[GFC_MAX_DIMENSIONS];\n-  const GFC_INTEGER_4 *base;\n+  const GFC_UINTEGER_4 *base;\n   GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n@@ -185,7 +185,7 @@ mmaxval0_s4 (GFC_INTEGER_4 * const restrict ret,\n   base = array->base_addr;\n   {\n \n-  const GFC_INTEGER_4 *retval;\n+  const GFC_UINTEGER_4 *retval;\n \n   retval = ret;\n \n@@ -236,13 +236,13 @@ mmaxval0_s4 (GFC_INTEGER_4 * const restrict ret,\n }\n \n \n-extern void smaxval0_s4 (GFC_INTEGER_4 * restrict,\n+extern void smaxval0_s4 (GFC_UINTEGER_4 * restrict,\n         gfc_charlen_type,\n \tgfc_array_s4 * const restrict array, GFC_LOGICAL_4 *, gfc_charlen_type);\n export_proto(smaxval0_s4);\n \n void\n-smaxval0_s4 (GFC_INTEGER_4 * restrict ret,\n+smaxval0_s4 (GFC_UINTEGER_4 * restrict ret,\n         gfc_charlen_type xlen, gfc_array_s4 * const restrict array,\n \tGFC_LOGICAL_4 *mask, gfc_charlen_type len)\n \t"}, {"sha": "1cc6483cd6c0ad2a9e5790751edb182b9b7c2c95", "filename": "libgfortran/generated/maxval1_s1.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fmaxval1_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fmaxval1_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval1_s1.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -26,15 +26,15 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"libgfortran.h\"\n \n \n-#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_1)\n+#if defined (HAVE_GFC_UINTEGER_1) && defined (HAVE_GFC_UINTEGER_1)\n \n #include <string.h>\n #include <assert.h>\n \n static inline int\n-compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n+compare_fcn (const GFC_UINTEGER_1 *a, const GFC_UINTEGER_1 *b, gfc_charlen_type n)\n {\n-  if (sizeof (GFC_INTEGER_1) == 1)\n+  if (sizeof (GFC_UINTEGER_1) == 1)\n     return memcmp (a, b, n);\n   else\n     return memcmp_char4 (a, b, n);\n@@ -54,8 +54,8 @@ maxval1_s1 (gfc_array_s1 * const restrict retarray,\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type dstride[GFC_MAX_DIMENSIONS];\n-  const GFC_INTEGER_1 * restrict base;\n-  GFC_INTEGER_1 * restrict dest;\n+  const GFC_UINTEGER_1 * restrict base;\n+  GFC_UINTEGER_1 * restrict dest;\n   index_type rank;\n   index_type n;\n   index_type len;\n@@ -119,7 +119,7 @@ maxval1_s1 (gfc_array_s1 * const restrict retarray,\n       alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1]\n       \t\t * string_len;\n \n-      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_UINTEGER_1));\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -155,11 +155,11 @@ maxval1_s1 (gfc_array_s1 * const restrict retarray,\n   continue_loop = 1;\n   while (continue_loop)\n     {\n-      const GFC_INTEGER_1 * restrict src;\n+      const GFC_UINTEGER_1 * restrict src;\n       src = base;\n       {\n \n-\tconst GFC_INTEGER_1 *retval;\n+\tconst GFC_UINTEGER_1 *retval;\n \tretval = base;\n \tif (len <= 0)\n \t  memset (dest, 0, sizeof (*dest) * string_len);\n@@ -228,8 +228,8 @@ mmaxval1_s1 (gfc_array_s1 * const restrict retarray,\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type dstride[GFC_MAX_DIMENSIONS];\n   index_type mstride[GFC_MAX_DIMENSIONS];\n-  GFC_INTEGER_1 * restrict dest;\n-  const GFC_INTEGER_1 * restrict base;\n+  GFC_UINTEGER_1 * restrict dest;\n+  const GFC_UINTEGER_1 * restrict base;\n   const GFC_LOGICAL_1 * restrict mbase;\n   index_type rank;\n   index_type dim;\n@@ -319,7 +319,7 @@ mmaxval1_s1 (gfc_array_s1 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_UINTEGER_1));\n \n     }\n   else\n@@ -349,14 +349,14 @@ mmaxval1_s1 (gfc_array_s1 * const restrict retarray,\n \n   while (base)\n     {\n-      const GFC_INTEGER_1 * restrict src;\n+      const GFC_UINTEGER_1 * restrict src;\n       const GFC_LOGICAL_1 * restrict msrc;\n \n       src = base;\n       msrc = mbase;\n       {\n \n-\tconst GFC_INTEGER_1 *retval;\n+\tconst GFC_UINTEGER_1 *retval;\n \tmemset (dest, 0, sizeof (*dest) * string_len);\n \tretval = dest;\n \tfor (n = 0; n < len; n++, src += delta, msrc += mdelta)\n@@ -430,7 +430,7 @@ smaxval1_s1 (gfc_array_s1 * const restrict retarray,\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type dstride[GFC_MAX_DIMENSIONS];\n-  GFC_INTEGER_1 * restrict dest;\n+  GFC_UINTEGER_1 * restrict dest;\n   index_type rank;\n   index_type n;\n   index_type dim;\n@@ -497,7 +497,7 @@ smaxval1_s1 (gfc_array_s1 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_UINTEGER_1));\n     }\n   else\n     {"}, {"sha": "6e0e8be2d9ca4f533fdd4dd9360f470fbb52dc73", "filename": "libgfortran/generated/maxval1_s4.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fmaxval1_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fmaxval1_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval1_s4.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -26,15 +26,15 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"libgfortran.h\"\n \n \n-#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_4)\n+#if defined (HAVE_GFC_UINTEGER_4) && defined (HAVE_GFC_UINTEGER_4)\n \n #include <string.h>\n #include <assert.h>\n \n static inline int\n-compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n+compare_fcn (const GFC_UINTEGER_4 *a, const GFC_UINTEGER_4 *b, gfc_charlen_type n)\n {\n-  if (sizeof (GFC_INTEGER_4) == 1)\n+  if (sizeof (GFC_UINTEGER_4) == 1)\n     return memcmp (a, b, n);\n   else\n     return memcmp_char4 (a, b, n);\n@@ -54,8 +54,8 @@ maxval1_s4 (gfc_array_s4 * const restrict retarray,\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type dstride[GFC_MAX_DIMENSIONS];\n-  const GFC_INTEGER_4 * restrict base;\n-  GFC_INTEGER_4 * restrict dest;\n+  const GFC_UINTEGER_4 * restrict base;\n+  GFC_UINTEGER_4 * restrict dest;\n   index_type rank;\n   index_type n;\n   index_type len;\n@@ -119,7 +119,7 @@ maxval1_s4 (gfc_array_s4 * const restrict retarray,\n       alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1]\n       \t\t * string_len;\n \n-      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_UINTEGER_4));\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -155,11 +155,11 @@ maxval1_s4 (gfc_array_s4 * const restrict retarray,\n   continue_loop = 1;\n   while (continue_loop)\n     {\n-      const GFC_INTEGER_4 * restrict src;\n+      const GFC_UINTEGER_4 * restrict src;\n       src = base;\n       {\n \n-\tconst GFC_INTEGER_4 *retval;\n+\tconst GFC_UINTEGER_4 *retval;\n \tretval = base;\n \tif (len <= 0)\n \t  memset (dest, 0, sizeof (*dest) * string_len);\n@@ -228,8 +228,8 @@ mmaxval1_s4 (gfc_array_s4 * const restrict retarray,\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type dstride[GFC_MAX_DIMENSIONS];\n   index_type mstride[GFC_MAX_DIMENSIONS];\n-  GFC_INTEGER_4 * restrict dest;\n-  const GFC_INTEGER_4 * restrict base;\n+  GFC_UINTEGER_4 * restrict dest;\n+  const GFC_UINTEGER_4 * restrict base;\n   const GFC_LOGICAL_1 * restrict mbase;\n   index_type rank;\n   index_type dim;\n@@ -319,7 +319,7 @@ mmaxval1_s4 (gfc_array_s4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_UINTEGER_4));\n \n     }\n   else\n@@ -349,14 +349,14 @@ mmaxval1_s4 (gfc_array_s4 * const restrict retarray,\n \n   while (base)\n     {\n-      const GFC_INTEGER_4 * restrict src;\n+      const GFC_UINTEGER_4 * restrict src;\n       const GFC_LOGICAL_1 * restrict msrc;\n \n       src = base;\n       msrc = mbase;\n       {\n \n-\tconst GFC_INTEGER_4 *retval;\n+\tconst GFC_UINTEGER_4 *retval;\n \tmemset (dest, 0, sizeof (*dest) * string_len);\n \tretval = dest;\n \tfor (n = 0; n < len; n++, src += delta, msrc += mdelta)\n@@ -430,7 +430,7 @@ smaxval1_s4 (gfc_array_s4 * const restrict retarray,\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type dstride[GFC_MAX_DIMENSIONS];\n-  GFC_INTEGER_4 * restrict dest;\n+  GFC_UINTEGER_4 * restrict dest;\n   index_type rank;\n   index_type n;\n   index_type dim;\n@@ -497,7 +497,7 @@ smaxval1_s4 (gfc_array_s4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_UINTEGER_4));\n     }\n   else\n     {"}, {"sha": "66fa30c4c638b055d140ab48b729271bc94ebaef", "filename": "libgfortran/generated/minloc0_16_s1.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fminloc0_16_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fminloc0_16_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_s1.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -30,14 +30,14 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <limits.h>\n \n \n-#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_16)\n+#if defined (HAVE_GFC_UINTEGER_1) && defined (HAVE_GFC_INTEGER_16)\n \n #define HAVE_BACK_ARG 1\n \n static inline int\n-compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n+compare_fcn (const GFC_UINTEGER_1 *a, const GFC_UINTEGER_1 *b, gfc_charlen_type n)\n {\n-  if (sizeof (GFC_INTEGER_1) == 1)\n+  if (sizeof (GFC_UINTEGER_1) == 1)\n     return memcmp (a, b, n);\n   else\n     return memcmp_char4 (a, b, n);\n@@ -56,7 +56,7 @@ minloc0_16_s1 (gfc_array_i16 * const restrict retarray,\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type dstride;\n-  const GFC_INTEGER_1 *base;\n+  const GFC_UINTEGER_1 *base;\n   GFC_INTEGER_16 * restrict dest;\n   index_type rank;\n   index_type n;\n@@ -102,7 +102,7 @@ minloc0_16_s1 (gfc_array_i16 * const restrict retarray,\n     dest[n * dstride] = 1;\n   {\n \n-  const GFC_INTEGER_1 *minval;\n+  const GFC_UINTEGER_1 *minval;\n    minval = NULL;\n \n   while (base)\n@@ -168,7 +168,7 @@ mminloc0_16_s1 (gfc_array_i16 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   index_type dstride;\n   GFC_INTEGER_16 *dest;\n-  const GFC_INTEGER_1 *base;\n+  const GFC_UINTEGER_1 *base;\n   GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n@@ -234,7 +234,7 @@ mminloc0_16_s1 (gfc_array_i16 * const restrict retarray,\n     dest[n * dstride] = 0;\n   {\n \n-  const GFC_INTEGER_1 *minval;\n+  const GFC_UINTEGER_1 *minval;\n \n   minval = NULL;\n "}, {"sha": "378990c45c0dc198a96d9cf040809757c87b073e", "filename": "libgfortran/generated/minloc0_16_s4.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fminloc0_16_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fminloc0_16_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_s4.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -30,14 +30,14 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <limits.h>\n \n \n-#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_16)\n+#if defined (HAVE_GFC_UINTEGER_4) && defined (HAVE_GFC_INTEGER_16)\n \n #define HAVE_BACK_ARG 1\n \n static inline int\n-compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n+compare_fcn (const GFC_UINTEGER_4 *a, const GFC_UINTEGER_4 *b, gfc_charlen_type n)\n {\n-  if (sizeof (GFC_INTEGER_4) == 1)\n+  if (sizeof (GFC_UINTEGER_4) == 1)\n     return memcmp (a, b, n);\n   else\n     return memcmp_char4 (a, b, n);\n@@ -56,7 +56,7 @@ minloc0_16_s4 (gfc_array_i16 * const restrict retarray,\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type dstride;\n-  const GFC_INTEGER_4 *base;\n+  const GFC_UINTEGER_4 *base;\n   GFC_INTEGER_16 * restrict dest;\n   index_type rank;\n   index_type n;\n@@ -102,7 +102,7 @@ minloc0_16_s4 (gfc_array_i16 * const restrict retarray,\n     dest[n * dstride] = 1;\n   {\n \n-  const GFC_INTEGER_4 *minval;\n+  const GFC_UINTEGER_4 *minval;\n    minval = NULL;\n \n   while (base)\n@@ -168,7 +168,7 @@ mminloc0_16_s4 (gfc_array_i16 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   index_type dstride;\n   GFC_INTEGER_16 *dest;\n-  const GFC_INTEGER_4 *base;\n+  const GFC_UINTEGER_4 *base;\n   GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n@@ -234,7 +234,7 @@ mminloc0_16_s4 (gfc_array_i16 * const restrict retarray,\n     dest[n * dstride] = 0;\n   {\n \n-  const GFC_INTEGER_4 *minval;\n+  const GFC_UINTEGER_4 *minval;\n \n   minval = NULL;\n "}, {"sha": "c2615d2829ebda92400efc61224ef3bc101ced71", "filename": "libgfortran/generated/minloc0_4_s1.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fminloc0_4_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fminloc0_4_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_s1.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -30,14 +30,14 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <limits.h>\n \n \n-#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_4)\n+#if defined (HAVE_GFC_UINTEGER_1) && defined (HAVE_GFC_INTEGER_4)\n \n #define HAVE_BACK_ARG 1\n \n static inline int\n-compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n+compare_fcn (const GFC_UINTEGER_1 *a, const GFC_UINTEGER_1 *b, gfc_charlen_type n)\n {\n-  if (sizeof (GFC_INTEGER_1) == 1)\n+  if (sizeof (GFC_UINTEGER_1) == 1)\n     return memcmp (a, b, n);\n   else\n     return memcmp_char4 (a, b, n);\n@@ -56,7 +56,7 @@ minloc0_4_s1 (gfc_array_i4 * const restrict retarray,\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type dstride;\n-  const GFC_INTEGER_1 *base;\n+  const GFC_UINTEGER_1 *base;\n   GFC_INTEGER_4 * restrict dest;\n   index_type rank;\n   index_type n;\n@@ -102,7 +102,7 @@ minloc0_4_s1 (gfc_array_i4 * const restrict retarray,\n     dest[n * dstride] = 1;\n   {\n \n-  const GFC_INTEGER_1 *minval;\n+  const GFC_UINTEGER_1 *minval;\n    minval = NULL;\n \n   while (base)\n@@ -168,7 +168,7 @@ mminloc0_4_s1 (gfc_array_i4 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   index_type dstride;\n   GFC_INTEGER_4 *dest;\n-  const GFC_INTEGER_1 *base;\n+  const GFC_UINTEGER_1 *base;\n   GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n@@ -234,7 +234,7 @@ mminloc0_4_s1 (gfc_array_i4 * const restrict retarray,\n     dest[n * dstride] = 0;\n   {\n \n-  const GFC_INTEGER_1 *minval;\n+  const GFC_UINTEGER_1 *minval;\n \n   minval = NULL;\n "}, {"sha": "5568cdbf4a3acac5ddeba881f3ebe3a8660d6c2e", "filename": "libgfortran/generated/minloc0_4_s4.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fminloc0_4_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fminloc0_4_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_s4.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -30,14 +30,14 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <limits.h>\n \n \n-#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_4)\n+#if defined (HAVE_GFC_UINTEGER_4) && defined (HAVE_GFC_INTEGER_4)\n \n #define HAVE_BACK_ARG 1\n \n static inline int\n-compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n+compare_fcn (const GFC_UINTEGER_4 *a, const GFC_UINTEGER_4 *b, gfc_charlen_type n)\n {\n-  if (sizeof (GFC_INTEGER_4) == 1)\n+  if (sizeof (GFC_UINTEGER_4) == 1)\n     return memcmp (a, b, n);\n   else\n     return memcmp_char4 (a, b, n);\n@@ -56,7 +56,7 @@ minloc0_4_s4 (gfc_array_i4 * const restrict retarray,\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type dstride;\n-  const GFC_INTEGER_4 *base;\n+  const GFC_UINTEGER_4 *base;\n   GFC_INTEGER_4 * restrict dest;\n   index_type rank;\n   index_type n;\n@@ -102,7 +102,7 @@ minloc0_4_s4 (gfc_array_i4 * const restrict retarray,\n     dest[n * dstride] = 1;\n   {\n \n-  const GFC_INTEGER_4 *minval;\n+  const GFC_UINTEGER_4 *minval;\n    minval = NULL;\n \n   while (base)\n@@ -168,7 +168,7 @@ mminloc0_4_s4 (gfc_array_i4 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   index_type dstride;\n   GFC_INTEGER_4 *dest;\n-  const GFC_INTEGER_4 *base;\n+  const GFC_UINTEGER_4 *base;\n   GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n@@ -234,7 +234,7 @@ mminloc0_4_s4 (gfc_array_i4 * const restrict retarray,\n     dest[n * dstride] = 0;\n   {\n \n-  const GFC_INTEGER_4 *minval;\n+  const GFC_UINTEGER_4 *minval;\n \n   minval = NULL;\n "}, {"sha": "e22f4f9fe997368719a7d4416fc0a83a5d23577b", "filename": "libgfortran/generated/minloc0_8_s1.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fminloc0_8_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fminloc0_8_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_s1.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -30,14 +30,14 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <limits.h>\n \n \n-#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_8)\n+#if defined (HAVE_GFC_UINTEGER_1) && defined (HAVE_GFC_INTEGER_8)\n \n #define HAVE_BACK_ARG 1\n \n static inline int\n-compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n+compare_fcn (const GFC_UINTEGER_1 *a, const GFC_UINTEGER_1 *b, gfc_charlen_type n)\n {\n-  if (sizeof (GFC_INTEGER_1) == 1)\n+  if (sizeof (GFC_UINTEGER_1) == 1)\n     return memcmp (a, b, n);\n   else\n     return memcmp_char4 (a, b, n);\n@@ -56,7 +56,7 @@ minloc0_8_s1 (gfc_array_i8 * const restrict retarray,\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type dstride;\n-  const GFC_INTEGER_1 *base;\n+  const GFC_UINTEGER_1 *base;\n   GFC_INTEGER_8 * restrict dest;\n   index_type rank;\n   index_type n;\n@@ -102,7 +102,7 @@ minloc0_8_s1 (gfc_array_i8 * const restrict retarray,\n     dest[n * dstride] = 1;\n   {\n \n-  const GFC_INTEGER_1 *minval;\n+  const GFC_UINTEGER_1 *minval;\n    minval = NULL;\n \n   while (base)\n@@ -168,7 +168,7 @@ mminloc0_8_s1 (gfc_array_i8 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   index_type dstride;\n   GFC_INTEGER_8 *dest;\n-  const GFC_INTEGER_1 *base;\n+  const GFC_UINTEGER_1 *base;\n   GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n@@ -234,7 +234,7 @@ mminloc0_8_s1 (gfc_array_i8 * const restrict retarray,\n     dest[n * dstride] = 0;\n   {\n \n-  const GFC_INTEGER_1 *minval;\n+  const GFC_UINTEGER_1 *minval;\n \n   minval = NULL;\n "}, {"sha": "52ca0571ce371e85ca5d284f2c22b2ad15f7860b", "filename": "libgfortran/generated/minloc0_8_s4.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fminloc0_8_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fminloc0_8_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_s4.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -30,14 +30,14 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <limits.h>\n \n \n-#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_8)\n+#if defined (HAVE_GFC_UINTEGER_4) && defined (HAVE_GFC_INTEGER_8)\n \n #define HAVE_BACK_ARG 1\n \n static inline int\n-compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n+compare_fcn (const GFC_UINTEGER_4 *a, const GFC_UINTEGER_4 *b, gfc_charlen_type n)\n {\n-  if (sizeof (GFC_INTEGER_4) == 1)\n+  if (sizeof (GFC_UINTEGER_4) == 1)\n     return memcmp (a, b, n);\n   else\n     return memcmp_char4 (a, b, n);\n@@ -56,7 +56,7 @@ minloc0_8_s4 (gfc_array_i8 * const restrict retarray,\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type dstride;\n-  const GFC_INTEGER_4 *base;\n+  const GFC_UINTEGER_4 *base;\n   GFC_INTEGER_8 * restrict dest;\n   index_type rank;\n   index_type n;\n@@ -102,7 +102,7 @@ minloc0_8_s4 (gfc_array_i8 * const restrict retarray,\n     dest[n * dstride] = 1;\n   {\n \n-  const GFC_INTEGER_4 *minval;\n+  const GFC_UINTEGER_4 *minval;\n    minval = NULL;\n \n   while (base)\n@@ -168,7 +168,7 @@ mminloc0_8_s4 (gfc_array_i8 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   index_type dstride;\n   GFC_INTEGER_8 *dest;\n-  const GFC_INTEGER_4 *base;\n+  const GFC_UINTEGER_4 *base;\n   GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n@@ -234,7 +234,7 @@ mminloc0_8_s4 (gfc_array_i8 * const restrict retarray,\n     dest[n * dstride] = 0;\n   {\n \n-  const GFC_INTEGER_4 *minval;\n+  const GFC_UINTEGER_4 *minval;\n \n   minval = NULL;\n "}, {"sha": "b0cb8bea16cf95dc195293ed612726e52ab2fc66", "filename": "libgfortran/generated/minloc1_16_s1.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fminloc1_16_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fminloc1_16_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_s1.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -26,17 +26,17 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"libgfortran.h\"\n \n \n-#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_16)\n+#if defined (HAVE_GFC_UINTEGER_1) && defined (HAVE_GFC_INTEGER_16)\n \n #define HAVE_BACK_ARG 1\n \n #include <string.h>\n #include <assert.h>\n \n static inline int\n-compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n+compare_fcn (const GFC_UINTEGER_1 *a, const GFC_UINTEGER_1 *b, gfc_charlen_type n)\n {\n-  if (sizeof (GFC_INTEGER_1) == 1)\n+  if (sizeof (GFC_UINTEGER_1) == 1)\n     return memcmp (a, b, n);\n   else\n     return memcmp_char4 (a, b, n);\n@@ -57,7 +57,7 @@ minloc1_16_s1 (gfc_array_i16 * const restrict retarray,\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type dstride[GFC_MAX_DIMENSIONS];\n-  const GFC_INTEGER_1 * restrict base;\n+  const GFC_UINTEGER_1 * restrict base;\n   GFC_INTEGER_16 * restrict dest;\n   index_type rank;\n   index_type n;\n@@ -155,12 +155,12 @@ minloc1_16_s1 (gfc_array_i16 * const restrict retarray,\n   continue_loop = 1;\n   while (continue_loop)\n     {\n-      const GFC_INTEGER_1 * restrict src;\n+      const GFC_UINTEGER_1 * restrict src;\n       GFC_INTEGER_16 result;\n       src = base;\n       {\n \n-\tconst GFC_INTEGER_1 *minval;\n+\tconst GFC_UINTEGER_1 *minval;\n \tminval = NULL;\n \tresult = 0;\n \tif (len <= 0)\n@@ -231,7 +231,7 @@ mminloc1_16_s1 (gfc_array_i16 * const restrict retarray,\n   index_type dstride[GFC_MAX_DIMENSIONS];\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_16 * restrict dest;\n-  const GFC_INTEGER_1 * restrict base;\n+  const GFC_UINTEGER_1 * restrict base;\n   const GFC_LOGICAL_1 * restrict mbase;\n   index_type rank;\n   index_type dim;\n@@ -349,14 +349,14 @@ mminloc1_16_s1 (gfc_array_i16 * const restrict retarray,\n \n   while (base)\n     {\n-      const GFC_INTEGER_1 * restrict src;\n+      const GFC_UINTEGER_1 * restrict src;\n       const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_16 result;\n       src = base;\n       msrc = mbase;\n       {\n \n-\tconst GFC_INTEGER_1 *minval;\n+\tconst GFC_UINTEGER_1 *minval;\n \tminval = base;\n \tresult = 0;\n \tfor (n = 0; n < len; n++, src += delta, msrc += mdelta)"}, {"sha": "b4222627369020ad3dd55489451c2a909539e288", "filename": "libgfortran/generated/minloc1_16_s4.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fminloc1_16_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fminloc1_16_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_s4.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -26,17 +26,17 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"libgfortran.h\"\n \n \n-#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_16)\n+#if defined (HAVE_GFC_UINTEGER_4) && defined (HAVE_GFC_INTEGER_16)\n \n #define HAVE_BACK_ARG 1\n \n #include <string.h>\n #include <assert.h>\n \n static inline int\n-compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n+compare_fcn (const GFC_UINTEGER_4 *a, const GFC_UINTEGER_4 *b, gfc_charlen_type n)\n {\n-  if (sizeof (GFC_INTEGER_4) == 1)\n+  if (sizeof (GFC_UINTEGER_4) == 1)\n     return memcmp (a, b, n);\n   else\n     return memcmp_char4 (a, b, n);\n@@ -57,7 +57,7 @@ minloc1_16_s4 (gfc_array_i16 * const restrict retarray,\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type dstride[GFC_MAX_DIMENSIONS];\n-  const GFC_INTEGER_4 * restrict base;\n+  const GFC_UINTEGER_4 * restrict base;\n   GFC_INTEGER_16 * restrict dest;\n   index_type rank;\n   index_type n;\n@@ -155,12 +155,12 @@ minloc1_16_s4 (gfc_array_i16 * const restrict retarray,\n   continue_loop = 1;\n   while (continue_loop)\n     {\n-      const GFC_INTEGER_4 * restrict src;\n+      const GFC_UINTEGER_4 * restrict src;\n       GFC_INTEGER_16 result;\n       src = base;\n       {\n \n-\tconst GFC_INTEGER_4 *minval;\n+\tconst GFC_UINTEGER_4 *minval;\n \tminval = NULL;\n \tresult = 0;\n \tif (len <= 0)\n@@ -231,7 +231,7 @@ mminloc1_16_s4 (gfc_array_i16 * const restrict retarray,\n   index_type dstride[GFC_MAX_DIMENSIONS];\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_16 * restrict dest;\n-  const GFC_INTEGER_4 * restrict base;\n+  const GFC_UINTEGER_4 * restrict base;\n   const GFC_LOGICAL_1 * restrict mbase;\n   index_type rank;\n   index_type dim;\n@@ -349,14 +349,14 @@ mminloc1_16_s4 (gfc_array_i16 * const restrict retarray,\n \n   while (base)\n     {\n-      const GFC_INTEGER_4 * restrict src;\n+      const GFC_UINTEGER_4 * restrict src;\n       const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_16 result;\n       src = base;\n       msrc = mbase;\n       {\n \n-\tconst GFC_INTEGER_4 *minval;\n+\tconst GFC_UINTEGER_4 *minval;\n \tminval = base;\n \tresult = 0;\n \tfor (n = 0; n < len; n++, src += delta, msrc += mdelta)"}, {"sha": "0a52c34c259742c3efaacf0974c6b5cb0cdfbde2", "filename": "libgfortran/generated/minloc1_4_s1.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fminloc1_4_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fminloc1_4_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_s1.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -26,17 +26,17 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"libgfortran.h\"\n \n \n-#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_4)\n+#if defined (HAVE_GFC_UINTEGER_1) && defined (HAVE_GFC_INTEGER_4)\n \n #define HAVE_BACK_ARG 1\n \n #include <string.h>\n #include <assert.h>\n \n static inline int\n-compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n+compare_fcn (const GFC_UINTEGER_1 *a, const GFC_UINTEGER_1 *b, gfc_charlen_type n)\n {\n-  if (sizeof (GFC_INTEGER_1) == 1)\n+  if (sizeof (GFC_UINTEGER_1) == 1)\n     return memcmp (a, b, n);\n   else\n     return memcmp_char4 (a, b, n);\n@@ -57,7 +57,7 @@ minloc1_4_s1 (gfc_array_i4 * const restrict retarray,\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type dstride[GFC_MAX_DIMENSIONS];\n-  const GFC_INTEGER_1 * restrict base;\n+  const GFC_UINTEGER_1 * restrict base;\n   GFC_INTEGER_4 * restrict dest;\n   index_type rank;\n   index_type n;\n@@ -155,12 +155,12 @@ minloc1_4_s1 (gfc_array_i4 * const restrict retarray,\n   continue_loop = 1;\n   while (continue_loop)\n     {\n-      const GFC_INTEGER_1 * restrict src;\n+      const GFC_UINTEGER_1 * restrict src;\n       GFC_INTEGER_4 result;\n       src = base;\n       {\n \n-\tconst GFC_INTEGER_1 *minval;\n+\tconst GFC_UINTEGER_1 *minval;\n \tminval = NULL;\n \tresult = 0;\n \tif (len <= 0)\n@@ -231,7 +231,7 @@ mminloc1_4_s1 (gfc_array_i4 * const restrict retarray,\n   index_type dstride[GFC_MAX_DIMENSIONS];\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_4 * restrict dest;\n-  const GFC_INTEGER_1 * restrict base;\n+  const GFC_UINTEGER_1 * restrict base;\n   const GFC_LOGICAL_1 * restrict mbase;\n   index_type rank;\n   index_type dim;\n@@ -349,14 +349,14 @@ mminloc1_4_s1 (gfc_array_i4 * const restrict retarray,\n \n   while (base)\n     {\n-      const GFC_INTEGER_1 * restrict src;\n+      const GFC_UINTEGER_1 * restrict src;\n       const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_4 result;\n       src = base;\n       msrc = mbase;\n       {\n \n-\tconst GFC_INTEGER_1 *minval;\n+\tconst GFC_UINTEGER_1 *minval;\n \tminval = base;\n \tresult = 0;\n \tfor (n = 0; n < len; n++, src += delta, msrc += mdelta)"}, {"sha": "0338f6ae5473d6ddf9f519747bffe0774996d41f", "filename": "libgfortran/generated/minloc1_4_s4.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fminloc1_4_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fminloc1_4_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_s4.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -26,17 +26,17 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"libgfortran.h\"\n \n \n-#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_4)\n+#if defined (HAVE_GFC_UINTEGER_4) && defined (HAVE_GFC_INTEGER_4)\n \n #define HAVE_BACK_ARG 1\n \n #include <string.h>\n #include <assert.h>\n \n static inline int\n-compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n+compare_fcn (const GFC_UINTEGER_4 *a, const GFC_UINTEGER_4 *b, gfc_charlen_type n)\n {\n-  if (sizeof (GFC_INTEGER_4) == 1)\n+  if (sizeof (GFC_UINTEGER_4) == 1)\n     return memcmp (a, b, n);\n   else\n     return memcmp_char4 (a, b, n);\n@@ -57,7 +57,7 @@ minloc1_4_s4 (gfc_array_i4 * const restrict retarray,\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type dstride[GFC_MAX_DIMENSIONS];\n-  const GFC_INTEGER_4 * restrict base;\n+  const GFC_UINTEGER_4 * restrict base;\n   GFC_INTEGER_4 * restrict dest;\n   index_type rank;\n   index_type n;\n@@ -155,12 +155,12 @@ minloc1_4_s4 (gfc_array_i4 * const restrict retarray,\n   continue_loop = 1;\n   while (continue_loop)\n     {\n-      const GFC_INTEGER_4 * restrict src;\n+      const GFC_UINTEGER_4 * restrict src;\n       GFC_INTEGER_4 result;\n       src = base;\n       {\n \n-\tconst GFC_INTEGER_4 *minval;\n+\tconst GFC_UINTEGER_4 *minval;\n \tminval = NULL;\n \tresult = 0;\n \tif (len <= 0)\n@@ -231,7 +231,7 @@ mminloc1_4_s4 (gfc_array_i4 * const restrict retarray,\n   index_type dstride[GFC_MAX_DIMENSIONS];\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_4 * restrict dest;\n-  const GFC_INTEGER_4 * restrict base;\n+  const GFC_UINTEGER_4 * restrict base;\n   const GFC_LOGICAL_1 * restrict mbase;\n   index_type rank;\n   index_type dim;\n@@ -349,14 +349,14 @@ mminloc1_4_s4 (gfc_array_i4 * const restrict retarray,\n \n   while (base)\n     {\n-      const GFC_INTEGER_4 * restrict src;\n+      const GFC_UINTEGER_4 * restrict src;\n       const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_4 result;\n       src = base;\n       msrc = mbase;\n       {\n \n-\tconst GFC_INTEGER_4 *minval;\n+\tconst GFC_UINTEGER_4 *minval;\n \tminval = base;\n \tresult = 0;\n \tfor (n = 0; n < len; n++, src += delta, msrc += mdelta)"}, {"sha": "2c387902ab966b460d86945f44d43f839b8e045d", "filename": "libgfortran/generated/minloc1_8_s1.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fminloc1_8_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fminloc1_8_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_s1.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -26,17 +26,17 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"libgfortran.h\"\n \n \n-#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_8)\n+#if defined (HAVE_GFC_UINTEGER_1) && defined (HAVE_GFC_INTEGER_8)\n \n #define HAVE_BACK_ARG 1\n \n #include <string.h>\n #include <assert.h>\n \n static inline int\n-compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n+compare_fcn (const GFC_UINTEGER_1 *a, const GFC_UINTEGER_1 *b, gfc_charlen_type n)\n {\n-  if (sizeof (GFC_INTEGER_1) == 1)\n+  if (sizeof (GFC_UINTEGER_1) == 1)\n     return memcmp (a, b, n);\n   else\n     return memcmp_char4 (a, b, n);\n@@ -57,7 +57,7 @@ minloc1_8_s1 (gfc_array_i8 * const restrict retarray,\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type dstride[GFC_MAX_DIMENSIONS];\n-  const GFC_INTEGER_1 * restrict base;\n+  const GFC_UINTEGER_1 * restrict base;\n   GFC_INTEGER_8 * restrict dest;\n   index_type rank;\n   index_type n;\n@@ -155,12 +155,12 @@ minloc1_8_s1 (gfc_array_i8 * const restrict retarray,\n   continue_loop = 1;\n   while (continue_loop)\n     {\n-      const GFC_INTEGER_1 * restrict src;\n+      const GFC_UINTEGER_1 * restrict src;\n       GFC_INTEGER_8 result;\n       src = base;\n       {\n \n-\tconst GFC_INTEGER_1 *minval;\n+\tconst GFC_UINTEGER_1 *minval;\n \tminval = NULL;\n \tresult = 0;\n \tif (len <= 0)\n@@ -231,7 +231,7 @@ mminloc1_8_s1 (gfc_array_i8 * const restrict retarray,\n   index_type dstride[GFC_MAX_DIMENSIONS];\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_8 * restrict dest;\n-  const GFC_INTEGER_1 * restrict base;\n+  const GFC_UINTEGER_1 * restrict base;\n   const GFC_LOGICAL_1 * restrict mbase;\n   index_type rank;\n   index_type dim;\n@@ -349,14 +349,14 @@ mminloc1_8_s1 (gfc_array_i8 * const restrict retarray,\n \n   while (base)\n     {\n-      const GFC_INTEGER_1 * restrict src;\n+      const GFC_UINTEGER_1 * restrict src;\n       const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_8 result;\n       src = base;\n       msrc = mbase;\n       {\n \n-\tconst GFC_INTEGER_1 *minval;\n+\tconst GFC_UINTEGER_1 *minval;\n \tminval = base;\n \tresult = 0;\n \tfor (n = 0; n < len; n++, src += delta, msrc += mdelta)"}, {"sha": "59d2d6f11418e903035662426287263f73332c38", "filename": "libgfortran/generated/minloc1_8_s4.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fminloc1_8_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fminloc1_8_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_s4.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -26,17 +26,17 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"libgfortran.h\"\n \n \n-#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_8)\n+#if defined (HAVE_GFC_UINTEGER_4) && defined (HAVE_GFC_INTEGER_8)\n \n #define HAVE_BACK_ARG 1\n \n #include <string.h>\n #include <assert.h>\n \n static inline int\n-compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n+compare_fcn (const GFC_UINTEGER_4 *a, const GFC_UINTEGER_4 *b, gfc_charlen_type n)\n {\n-  if (sizeof (GFC_INTEGER_4) == 1)\n+  if (sizeof (GFC_UINTEGER_4) == 1)\n     return memcmp (a, b, n);\n   else\n     return memcmp_char4 (a, b, n);\n@@ -57,7 +57,7 @@ minloc1_8_s4 (gfc_array_i8 * const restrict retarray,\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type dstride[GFC_MAX_DIMENSIONS];\n-  const GFC_INTEGER_4 * restrict base;\n+  const GFC_UINTEGER_4 * restrict base;\n   GFC_INTEGER_8 * restrict dest;\n   index_type rank;\n   index_type n;\n@@ -155,12 +155,12 @@ minloc1_8_s4 (gfc_array_i8 * const restrict retarray,\n   continue_loop = 1;\n   while (continue_loop)\n     {\n-      const GFC_INTEGER_4 * restrict src;\n+      const GFC_UINTEGER_4 * restrict src;\n       GFC_INTEGER_8 result;\n       src = base;\n       {\n \n-\tconst GFC_INTEGER_4 *minval;\n+\tconst GFC_UINTEGER_4 *minval;\n \tminval = NULL;\n \tresult = 0;\n \tif (len <= 0)\n@@ -231,7 +231,7 @@ mminloc1_8_s4 (gfc_array_i8 * const restrict retarray,\n   index_type dstride[GFC_MAX_DIMENSIONS];\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_8 * restrict dest;\n-  const GFC_INTEGER_4 * restrict base;\n+  const GFC_UINTEGER_4 * restrict base;\n   const GFC_LOGICAL_1 * restrict mbase;\n   index_type rank;\n   index_type dim;\n@@ -349,14 +349,14 @@ mminloc1_8_s4 (gfc_array_i8 * const restrict retarray,\n \n   while (base)\n     {\n-      const GFC_INTEGER_4 * restrict src;\n+      const GFC_UINTEGER_4 * restrict src;\n       const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_8 result;\n       src = base;\n       msrc = mbase;\n       {\n \n-\tconst GFC_INTEGER_4 *minval;\n+\tconst GFC_UINTEGER_4 *minval;\n \tminval = base;\n \tresult = 0;\n \tfor (n = 0; n < len; n++, src += delta, msrc += mdelta)"}, {"sha": "823c8d205debd972b9998ab05131c6e19a2962d4", "filename": "libgfortran/generated/minloc2_16_s1.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fminloc2_16_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fminloc2_16_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc2_16_s1.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -28,12 +28,12 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <string.h>\n #include <assert.h>\n \n-#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_16)\n+#if defined (HAVE_GFC_UINTEGER_1) && defined (HAVE_GFC_INTEGER_16)\n \n static inline int\n-compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n+compare_fcn (const GFC_UINTEGER_1 *a, const GFC_UINTEGER_1 *b, gfc_charlen_type n)\n {\n-  if (sizeof (GFC_INTEGER_1) == 1)\n+  if (sizeof (GFC_UINTEGER_1) == 1)\n     return memcmp (a, b, n);\n   else\n     return memcmp_char4 (a, b, n);\n@@ -50,8 +50,8 @@ minloc2_16_s1 (gfc_array_s1 * const restrict array, GFC_LOGICAL_4 back,\n   index_type ret;\n   index_type sstride;\n   index_type extent;\n-  const GFC_INTEGER_1 *src;\n-  const GFC_INTEGER_1 *minval;\n+  const GFC_UINTEGER_1 *src;\n+  const GFC_UINTEGER_1 *minval;\n   index_type i;\n \n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n@@ -89,8 +89,8 @@ mminloc2_16_s1 (gfc_array_s1 * const restrict array,\n   index_type ret;\n   index_type sstride;\n   index_type extent;\n-  const GFC_INTEGER_1 *src;\n-  const GFC_INTEGER_1 *maxval;\n+  const GFC_UINTEGER_1 *src;\n+  const GFC_UINTEGER_1 *maxval;\n   index_type i, j;\n   GFC_LOGICAL_1 *mbase;\n   int mask_kind;"}, {"sha": "6f98369d2258655ceeedaef5775a2f65084097f8", "filename": "libgfortran/generated/minloc2_16_s4.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fminloc2_16_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fminloc2_16_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc2_16_s4.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -28,12 +28,12 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <string.h>\n #include <assert.h>\n \n-#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_16)\n+#if defined (HAVE_GFC_UINTEGER_4) && defined (HAVE_GFC_INTEGER_16)\n \n static inline int\n-compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n+compare_fcn (const GFC_UINTEGER_4 *a, const GFC_UINTEGER_4 *b, gfc_charlen_type n)\n {\n-  if (sizeof (GFC_INTEGER_4) == 1)\n+  if (sizeof (GFC_UINTEGER_4) == 1)\n     return memcmp (a, b, n);\n   else\n     return memcmp_char4 (a, b, n);\n@@ -50,8 +50,8 @@ minloc2_16_s4 (gfc_array_s4 * const restrict array, GFC_LOGICAL_4 back,\n   index_type ret;\n   index_type sstride;\n   index_type extent;\n-  const GFC_INTEGER_4 *src;\n-  const GFC_INTEGER_4 *minval;\n+  const GFC_UINTEGER_4 *src;\n+  const GFC_UINTEGER_4 *minval;\n   index_type i;\n \n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n@@ -89,8 +89,8 @@ mminloc2_16_s4 (gfc_array_s4 * const restrict array,\n   index_type ret;\n   index_type sstride;\n   index_type extent;\n-  const GFC_INTEGER_4 *src;\n-  const GFC_INTEGER_4 *maxval;\n+  const GFC_UINTEGER_4 *src;\n+  const GFC_UINTEGER_4 *maxval;\n   index_type i, j;\n   GFC_LOGICAL_1 *mbase;\n   int mask_kind;"}, {"sha": "854aba4f04a7032493f130b69276623d8a855ce7", "filename": "libgfortran/generated/minloc2_4_s1.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fminloc2_4_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fminloc2_4_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc2_4_s1.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -28,12 +28,12 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <string.h>\n #include <assert.h>\n \n-#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_4)\n+#if defined (HAVE_GFC_UINTEGER_1) && defined (HAVE_GFC_INTEGER_4)\n \n static inline int\n-compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n+compare_fcn (const GFC_UINTEGER_1 *a, const GFC_UINTEGER_1 *b, gfc_charlen_type n)\n {\n-  if (sizeof (GFC_INTEGER_1) == 1)\n+  if (sizeof (GFC_UINTEGER_1) == 1)\n     return memcmp (a, b, n);\n   else\n     return memcmp_char4 (a, b, n);\n@@ -50,8 +50,8 @@ minloc2_4_s1 (gfc_array_s1 * const restrict array, GFC_LOGICAL_4 back,\n   index_type ret;\n   index_type sstride;\n   index_type extent;\n-  const GFC_INTEGER_1 *src;\n-  const GFC_INTEGER_1 *minval;\n+  const GFC_UINTEGER_1 *src;\n+  const GFC_UINTEGER_1 *minval;\n   index_type i;\n \n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n@@ -89,8 +89,8 @@ mminloc2_4_s1 (gfc_array_s1 * const restrict array,\n   index_type ret;\n   index_type sstride;\n   index_type extent;\n-  const GFC_INTEGER_1 *src;\n-  const GFC_INTEGER_1 *maxval;\n+  const GFC_UINTEGER_1 *src;\n+  const GFC_UINTEGER_1 *maxval;\n   index_type i, j;\n   GFC_LOGICAL_1 *mbase;\n   int mask_kind;"}, {"sha": "9a1b1c8f7c5d6fdfa59eb73e5fb55948dfb54193", "filename": "libgfortran/generated/minloc2_4_s4.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fminloc2_4_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fminloc2_4_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc2_4_s4.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -28,12 +28,12 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <string.h>\n #include <assert.h>\n \n-#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_4)\n+#if defined (HAVE_GFC_UINTEGER_4) && defined (HAVE_GFC_INTEGER_4)\n \n static inline int\n-compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n+compare_fcn (const GFC_UINTEGER_4 *a, const GFC_UINTEGER_4 *b, gfc_charlen_type n)\n {\n-  if (sizeof (GFC_INTEGER_4) == 1)\n+  if (sizeof (GFC_UINTEGER_4) == 1)\n     return memcmp (a, b, n);\n   else\n     return memcmp_char4 (a, b, n);\n@@ -50,8 +50,8 @@ minloc2_4_s4 (gfc_array_s4 * const restrict array, GFC_LOGICAL_4 back,\n   index_type ret;\n   index_type sstride;\n   index_type extent;\n-  const GFC_INTEGER_4 *src;\n-  const GFC_INTEGER_4 *minval;\n+  const GFC_UINTEGER_4 *src;\n+  const GFC_UINTEGER_4 *minval;\n   index_type i;\n \n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n@@ -89,8 +89,8 @@ mminloc2_4_s4 (gfc_array_s4 * const restrict array,\n   index_type ret;\n   index_type sstride;\n   index_type extent;\n-  const GFC_INTEGER_4 *src;\n-  const GFC_INTEGER_4 *maxval;\n+  const GFC_UINTEGER_4 *src;\n+  const GFC_UINTEGER_4 *maxval;\n   index_type i, j;\n   GFC_LOGICAL_1 *mbase;\n   int mask_kind;"}, {"sha": "7ee25ce7bfa37400dad036cbe2e705fb92da614d", "filename": "libgfortran/generated/minloc2_8_s1.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fminloc2_8_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fminloc2_8_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc2_8_s1.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -28,12 +28,12 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <string.h>\n #include <assert.h>\n \n-#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_8)\n+#if defined (HAVE_GFC_UINTEGER_1) && defined (HAVE_GFC_INTEGER_8)\n \n static inline int\n-compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n+compare_fcn (const GFC_UINTEGER_1 *a, const GFC_UINTEGER_1 *b, gfc_charlen_type n)\n {\n-  if (sizeof (GFC_INTEGER_1) == 1)\n+  if (sizeof (GFC_UINTEGER_1) == 1)\n     return memcmp (a, b, n);\n   else\n     return memcmp_char4 (a, b, n);\n@@ -50,8 +50,8 @@ minloc2_8_s1 (gfc_array_s1 * const restrict array, GFC_LOGICAL_4 back,\n   index_type ret;\n   index_type sstride;\n   index_type extent;\n-  const GFC_INTEGER_1 *src;\n-  const GFC_INTEGER_1 *minval;\n+  const GFC_UINTEGER_1 *src;\n+  const GFC_UINTEGER_1 *minval;\n   index_type i;\n \n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n@@ -89,8 +89,8 @@ mminloc2_8_s1 (gfc_array_s1 * const restrict array,\n   index_type ret;\n   index_type sstride;\n   index_type extent;\n-  const GFC_INTEGER_1 *src;\n-  const GFC_INTEGER_1 *maxval;\n+  const GFC_UINTEGER_1 *src;\n+  const GFC_UINTEGER_1 *maxval;\n   index_type i, j;\n   GFC_LOGICAL_1 *mbase;\n   int mask_kind;"}, {"sha": "7b0cfd3d5efc817ab976f792b6b92927dbee0f59", "filename": "libgfortran/generated/minloc2_8_s4.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fminloc2_8_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fminloc2_8_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc2_8_s4.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -28,12 +28,12 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <string.h>\n #include <assert.h>\n \n-#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_8)\n+#if defined (HAVE_GFC_UINTEGER_4) && defined (HAVE_GFC_INTEGER_8)\n \n static inline int\n-compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n+compare_fcn (const GFC_UINTEGER_4 *a, const GFC_UINTEGER_4 *b, gfc_charlen_type n)\n {\n-  if (sizeof (GFC_INTEGER_4) == 1)\n+  if (sizeof (GFC_UINTEGER_4) == 1)\n     return memcmp (a, b, n);\n   else\n     return memcmp_char4 (a, b, n);\n@@ -50,8 +50,8 @@ minloc2_8_s4 (gfc_array_s4 * const restrict array, GFC_LOGICAL_4 back,\n   index_type ret;\n   index_type sstride;\n   index_type extent;\n-  const GFC_INTEGER_4 *src;\n-  const GFC_INTEGER_4 *minval;\n+  const GFC_UINTEGER_4 *src;\n+  const GFC_UINTEGER_4 *minval;\n   index_type i;\n \n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n@@ -89,8 +89,8 @@ mminloc2_8_s4 (gfc_array_s4 * const restrict array,\n   index_type ret;\n   index_type sstride;\n   index_type extent;\n-  const GFC_INTEGER_4 *src;\n-  const GFC_INTEGER_4 *maxval;\n+  const GFC_UINTEGER_4 *src;\n+  const GFC_UINTEGER_4 *maxval;\n   index_type i, j;\n   GFC_LOGICAL_1 *mbase;\n   int mask_kind;"}, {"sha": "a15b8357d851d2142681ab9e70ac8760410f0c55", "filename": "libgfortran/generated/minval0_s1.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fminval0_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fminval0_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval0_s1.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -30,12 +30,12 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <limits.h>\n \n \n-#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_1)\n+#if defined (HAVE_GFC_UINTEGER_1) && defined (HAVE_GFC_UINTEGER_1)\n \n static inline int\n-compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n+compare_fcn (const GFC_UINTEGER_1 *a, const GFC_UINTEGER_1 *b, gfc_charlen_type n)\n {\n-  if (sizeof (GFC_INTEGER_1) == 1)\n+  if (sizeof (GFC_UINTEGER_1) == 1)\n     return memcmp (a, b, n);\n   else\n     return memcmp_char4 (a, b, n);\n@@ -44,20 +44,20 @@ compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n \n #define INITVAL 255\n \n-extern void minval0_s1 (GFC_INTEGER_1 * restrict,\n+extern void minval0_s1 (GFC_UINTEGER_1 * restrict,\n         gfc_charlen_type,\n \tgfc_array_s1 * const restrict array, gfc_charlen_type);\n export_proto(minval0_s1);\n \n void\n-minval0_s1 (GFC_INTEGER_1 * restrict ret,\n+minval0_s1 (GFC_UINTEGER_1 * restrict ret,\n         gfc_charlen_type xlen,\n \tgfc_array_s1 * const restrict array, gfc_charlen_type len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n-  const GFC_INTEGER_1 *base;\n+  const GFC_UINTEGER_1 *base;\n   index_type rank;\n   index_type n;\n \n@@ -83,7 +83,7 @@ minval0_s1 (GFC_INTEGER_1 * restrict ret,\n \n   {\n \n-  const GFC_INTEGER_1 *retval;\n+  const GFC_UINTEGER_1 *retval;\n    retval = ret;\n \n   while (base)\n@@ -130,21 +130,21 @@ minval0_s1 (GFC_INTEGER_1 * restrict ret,\n }\n \n \n-extern void mminval0_s1 (GFC_INTEGER_1 * restrict,\n+extern void mminval0_s1 (GFC_UINTEGER_1 * restrict,\n        gfc_charlen_type, gfc_array_s1 * const restrict array,\n        gfc_array_l1 * const restrict mask, gfc_charlen_type len);\n export_proto(mminval0_s1);\n \n void\n-mminval0_s1 (GFC_INTEGER_1 * const restrict ret,\n+mminval0_s1 (GFC_UINTEGER_1 * const restrict ret,\n \tgfc_charlen_type xlen, gfc_array_s1 * const restrict array,\n \tgfc_array_l1 * const restrict mask, gfc_charlen_type len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type mstride[GFC_MAX_DIMENSIONS];\n-  const GFC_INTEGER_1 *base;\n+  const GFC_UINTEGER_1 *base;\n   GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n@@ -185,7 +185,7 @@ mminval0_s1 (GFC_INTEGER_1 * const restrict ret,\n   base = array->base_addr;\n   {\n \n-  const GFC_INTEGER_1 *retval;\n+  const GFC_UINTEGER_1 *retval;\n \n   retval = ret;\n \n@@ -236,13 +236,13 @@ mminval0_s1 (GFC_INTEGER_1 * const restrict ret,\n }\n \n \n-extern void sminval0_s1 (GFC_INTEGER_1 * restrict,\n+extern void sminval0_s1 (GFC_UINTEGER_1 * restrict,\n         gfc_charlen_type,\n \tgfc_array_s1 * const restrict array, GFC_LOGICAL_4 *, gfc_charlen_type);\n export_proto(sminval0_s1);\n \n void\n-sminval0_s1 (GFC_INTEGER_1 * restrict ret,\n+sminval0_s1 (GFC_UINTEGER_1 * restrict ret,\n         gfc_charlen_type xlen, gfc_array_s1 * const restrict array,\n \tGFC_LOGICAL_4 *mask, gfc_charlen_type len)\n \t"}, {"sha": "2b3c332edd2f8721a783bcaf43272975aed44e92", "filename": "libgfortran/generated/minval0_s4.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fminval0_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fminval0_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval0_s4.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -30,12 +30,12 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <limits.h>\n \n \n-#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_4)\n+#if defined (HAVE_GFC_UINTEGER_4) && defined (HAVE_GFC_UINTEGER_4)\n \n static inline int\n-compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n+compare_fcn (const GFC_UINTEGER_4 *a, const GFC_UINTEGER_4 *b, gfc_charlen_type n)\n {\n-  if (sizeof (GFC_INTEGER_4) == 1)\n+  if (sizeof (GFC_UINTEGER_4) == 1)\n     return memcmp (a, b, n);\n   else\n     return memcmp_char4 (a, b, n);\n@@ -44,20 +44,20 @@ compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n \n #define INITVAL 255\n \n-extern void minval0_s4 (GFC_INTEGER_4 * restrict,\n+extern void minval0_s4 (GFC_UINTEGER_4 * restrict,\n         gfc_charlen_type,\n \tgfc_array_s4 * const restrict array, gfc_charlen_type);\n export_proto(minval0_s4);\n \n void\n-minval0_s4 (GFC_INTEGER_4 * restrict ret,\n+minval0_s4 (GFC_UINTEGER_4 * restrict ret,\n         gfc_charlen_type xlen,\n \tgfc_array_s4 * const restrict array, gfc_charlen_type len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n-  const GFC_INTEGER_4 *base;\n+  const GFC_UINTEGER_4 *base;\n   index_type rank;\n   index_type n;\n \n@@ -83,7 +83,7 @@ minval0_s4 (GFC_INTEGER_4 * restrict ret,\n \n   {\n \n-  const GFC_INTEGER_4 *retval;\n+  const GFC_UINTEGER_4 *retval;\n    retval = ret;\n \n   while (base)\n@@ -130,21 +130,21 @@ minval0_s4 (GFC_INTEGER_4 * restrict ret,\n }\n \n \n-extern void mminval0_s4 (GFC_INTEGER_4 * restrict,\n+extern void mminval0_s4 (GFC_UINTEGER_4 * restrict,\n        gfc_charlen_type, gfc_array_s4 * const restrict array,\n        gfc_array_l1 * const restrict mask, gfc_charlen_type len);\n export_proto(mminval0_s4);\n \n void\n-mminval0_s4 (GFC_INTEGER_4 * const restrict ret,\n+mminval0_s4 (GFC_UINTEGER_4 * const restrict ret,\n \tgfc_charlen_type xlen, gfc_array_s4 * const restrict array,\n \tgfc_array_l1 * const restrict mask, gfc_charlen_type len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type mstride[GFC_MAX_DIMENSIONS];\n-  const GFC_INTEGER_4 *base;\n+  const GFC_UINTEGER_4 *base;\n   GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n@@ -185,7 +185,7 @@ mminval0_s4 (GFC_INTEGER_4 * const restrict ret,\n   base = array->base_addr;\n   {\n \n-  const GFC_INTEGER_4 *retval;\n+  const GFC_UINTEGER_4 *retval;\n \n   retval = ret;\n \n@@ -236,13 +236,13 @@ mminval0_s4 (GFC_INTEGER_4 * const restrict ret,\n }\n \n \n-extern void sminval0_s4 (GFC_INTEGER_4 * restrict,\n+extern void sminval0_s4 (GFC_UINTEGER_4 * restrict,\n         gfc_charlen_type,\n \tgfc_array_s4 * const restrict array, GFC_LOGICAL_4 *, gfc_charlen_type);\n export_proto(sminval0_s4);\n \n void\n-sminval0_s4 (GFC_INTEGER_4 * restrict ret,\n+sminval0_s4 (GFC_UINTEGER_4 * restrict ret,\n         gfc_charlen_type xlen, gfc_array_s4 * const restrict array,\n \tGFC_LOGICAL_4 *mask, gfc_charlen_type len)\n \t"}, {"sha": "be747be30e143eef382d5686e9c8d34bd24c8bc4", "filename": "libgfortran/generated/minval1_s1.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fminval1_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fminval1_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval1_s1.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -26,15 +26,15 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"libgfortran.h\"\n \n \n-#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_1)\n+#if defined (HAVE_GFC_UINTEGER_1) && defined (HAVE_GFC_UINTEGER_1)\n \n #include <string.h>\n #include <assert.h>\n \n static inline int\n-compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n+compare_fcn (const GFC_UINTEGER_1 *a, const GFC_UINTEGER_1 *b, gfc_charlen_type n)\n {\n-  if (sizeof (GFC_INTEGER_1) == 1)\n+  if (sizeof (GFC_UINTEGER_1) == 1)\n     return memcmp (a, b, n);\n   else\n     return memcmp_char4 (a, b, n);\n@@ -54,8 +54,8 @@ minval1_s1 (gfc_array_s1 * const restrict retarray,\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type dstride[GFC_MAX_DIMENSIONS];\n-  const GFC_INTEGER_1 * restrict base;\n-  GFC_INTEGER_1 * restrict dest;\n+  const GFC_UINTEGER_1 * restrict base;\n+  GFC_UINTEGER_1 * restrict dest;\n   index_type rank;\n   index_type n;\n   index_type len;\n@@ -119,7 +119,7 @@ minval1_s1 (gfc_array_s1 * const restrict retarray,\n       alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1]\n       \t\t * string_len;\n \n-      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_UINTEGER_1));\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -155,11 +155,11 @@ minval1_s1 (gfc_array_s1 * const restrict retarray,\n   continue_loop = 1;\n   while (continue_loop)\n     {\n-      const GFC_INTEGER_1 * restrict src;\n+      const GFC_UINTEGER_1 * restrict src;\n       src = base;\n       {\n \n-\tconst GFC_INTEGER_1 *retval;\n+\tconst GFC_UINTEGER_1 *retval;\n \tretval = base;\n \tif (len <= 0)\n \t  memset (dest, 255, sizeof (*dest) * string_len);\n@@ -228,8 +228,8 @@ mminval1_s1 (gfc_array_s1 * const restrict retarray,\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type dstride[GFC_MAX_DIMENSIONS];\n   index_type mstride[GFC_MAX_DIMENSIONS];\n-  GFC_INTEGER_1 * restrict dest;\n-  const GFC_INTEGER_1 * restrict base;\n+  GFC_UINTEGER_1 * restrict dest;\n+  const GFC_UINTEGER_1 * restrict base;\n   const GFC_LOGICAL_1 * restrict mbase;\n   index_type rank;\n   index_type dim;\n@@ -319,7 +319,7 @@ mminval1_s1 (gfc_array_s1 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_UINTEGER_1));\n \n     }\n   else\n@@ -349,14 +349,14 @@ mminval1_s1 (gfc_array_s1 * const restrict retarray,\n \n   while (base)\n     {\n-      const GFC_INTEGER_1 * restrict src;\n+      const GFC_UINTEGER_1 * restrict src;\n       const GFC_LOGICAL_1 * restrict msrc;\n \n       src = base;\n       msrc = mbase;\n       {\n \n-\tconst GFC_INTEGER_1 *retval;\n+\tconst GFC_UINTEGER_1 *retval;\n \tmemset (dest, 255, sizeof (*dest) * string_len);\n \tretval = dest;\n \tfor (n = 0; n < len; n++, src += delta, msrc += mdelta)\n@@ -430,7 +430,7 @@ sminval1_s1 (gfc_array_s1 * const restrict retarray,\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type dstride[GFC_MAX_DIMENSIONS];\n-  GFC_INTEGER_1 * restrict dest;\n+  GFC_UINTEGER_1 * restrict dest;\n   index_type rank;\n   index_type n;\n   index_type dim;\n@@ -497,7 +497,7 @@ sminval1_s1 (gfc_array_s1 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_UINTEGER_1));\n     }\n   else\n     {"}, {"sha": "abd449e5ec0941f99f87fd7225e7086214af2960", "filename": "libgfortran/generated/minval1_s4.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fminval1_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgenerated%2Fminval1_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval1_s4.c?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -26,15 +26,15 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"libgfortran.h\"\n \n \n-#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_4)\n+#if defined (HAVE_GFC_UINTEGER_4) && defined (HAVE_GFC_UINTEGER_4)\n \n #include <string.h>\n #include <assert.h>\n \n static inline int\n-compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n+compare_fcn (const GFC_UINTEGER_4 *a, const GFC_UINTEGER_4 *b, gfc_charlen_type n)\n {\n-  if (sizeof (GFC_INTEGER_4) == 1)\n+  if (sizeof (GFC_UINTEGER_4) == 1)\n     return memcmp (a, b, n);\n   else\n     return memcmp_char4 (a, b, n);\n@@ -54,8 +54,8 @@ minval1_s4 (gfc_array_s4 * const restrict retarray,\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type dstride[GFC_MAX_DIMENSIONS];\n-  const GFC_INTEGER_4 * restrict base;\n-  GFC_INTEGER_4 * restrict dest;\n+  const GFC_UINTEGER_4 * restrict base;\n+  GFC_UINTEGER_4 * restrict dest;\n   index_type rank;\n   index_type n;\n   index_type len;\n@@ -119,7 +119,7 @@ minval1_s4 (gfc_array_s4 * const restrict retarray,\n       alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1]\n       \t\t * string_len;\n \n-      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_UINTEGER_4));\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n@@ -155,11 +155,11 @@ minval1_s4 (gfc_array_s4 * const restrict retarray,\n   continue_loop = 1;\n   while (continue_loop)\n     {\n-      const GFC_INTEGER_4 * restrict src;\n+      const GFC_UINTEGER_4 * restrict src;\n       src = base;\n       {\n \n-\tconst GFC_INTEGER_4 *retval;\n+\tconst GFC_UINTEGER_4 *retval;\n \tretval = base;\n \tif (len <= 0)\n \t  memset (dest, 255, sizeof (*dest) * string_len);\n@@ -228,8 +228,8 @@ mminval1_s4 (gfc_array_s4 * const restrict retarray,\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type dstride[GFC_MAX_DIMENSIONS];\n   index_type mstride[GFC_MAX_DIMENSIONS];\n-  GFC_INTEGER_4 * restrict dest;\n-  const GFC_INTEGER_4 * restrict base;\n+  GFC_UINTEGER_4 * restrict dest;\n+  const GFC_UINTEGER_4 * restrict base;\n   const GFC_LOGICAL_1 * restrict mbase;\n   index_type rank;\n   index_type dim;\n@@ -319,7 +319,7 @@ mminval1_s4 (gfc_array_s4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_UINTEGER_4));\n \n     }\n   else\n@@ -349,14 +349,14 @@ mminval1_s4 (gfc_array_s4 * const restrict retarray,\n \n   while (base)\n     {\n-      const GFC_INTEGER_4 * restrict src;\n+      const GFC_UINTEGER_4 * restrict src;\n       const GFC_LOGICAL_1 * restrict msrc;\n \n       src = base;\n       msrc = mbase;\n       {\n \n-\tconst GFC_INTEGER_4 *retval;\n+\tconst GFC_UINTEGER_4 *retval;\n \tmemset (dest, 255, sizeof (*dest) * string_len);\n \tretval = dest;\n \tfor (n = 0; n < len; n++, src += delta, msrc += mdelta)\n@@ -430,7 +430,7 @@ sminval1_s4 (gfc_array_s4 * const restrict retarray,\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type dstride[GFC_MAX_DIMENSIONS];\n-  GFC_INTEGER_4 * restrict dest;\n+  GFC_UINTEGER_4 * restrict dest;\n   index_type rank;\n   index_type n;\n   index_type dim;\n@@ -497,7 +497,7 @@ sminval1_s4 (gfc_array_s4 * const restrict retarray,\n \t  return;\n \t}\n       else\n-\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_UINTEGER_4));\n     }\n   else\n     {"}, {"sha": "8dcb3295b20cc746c3510807ce98515554a3c567", "filename": "libgfortran/gfortran.map", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgfortran.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fgfortran.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgfortran.map?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -1486,5 +1486,91 @@ GFORTRAN_C99_8 {\n \n GFORTRAN_9 {\n   global:\n+  _gfortran_findloc0_c16;\n+  _gfortran_findloc0_c4;\n+  _gfortran_findloc0_c8;\n+  _gfortran_findloc0_i1;\n+  _gfortran_findloc0_i16;\n+  _gfortran_findloc0_i4;\n+  _gfortran_findloc0_i8;\n+  _gfortran_findloc0_l1;\n+  _gfortran_findloc0_l16;\n+  _gfortran_findloc0_l2;\n+  _gfortran_findloc0_l4;\n+  _gfortran_findloc0_l8;\n+  _gfortran_findloc0_r16;\n+  _gfortran_findloc0_r4;\n+  _gfortran_findloc0_r8;\n+  _gfortran_findloc0_s1;\n+  _gfortran_findloc0_s4;\n+  _gfortran_findloc1_c16;\n+  _gfortran_findloc1_c4;\n+  _gfortran_findloc1_c8;\n+  _gfortran_findloc1_i1;\n+  _gfortran_findloc1_i16;\n+  _gfortran_findloc1_i2;\n+  _gfortran_findloc1_i4;\n+  _gfortran_findloc1_i8;\n+  _gfortran_findloc1_r16;\n+  _gfortran_findloc1_r4;\n+  _gfortran_findloc1_r8;\n+  _gfortran_findloc1_s1;\n+  _gfortran_findloc1_s4;\n+  _gfortran_findloc2_s1;\n+  _gfortran_findloc2_s4;\n+  _gfortran_mfindloc0_c16;\n+  _gfortran_mfindloc0_c4;\n+  _gfortran_mfindloc0_c8;\n+  _gfortran_mfindloc0_i1;\n+  _gfortran_mfindloc0_i16;\n+  _gfortran_mfindloc0_i4;\n+  _gfortran_mfindloc0_i8;\n+  _gfortran_mfindloc0_r16;\n+  _gfortran_mfindloc0_r4;\n+  _gfortran_mfindloc0_r8;\n+  _gfortran_mfindloc0_s1;\n+  _gfortran_mfindloc0_s4;\n+  _gfortran_mfindloc1_c16;\n+  _gfortran_mfindloc1_c4;\n+  _gfortran_mfindloc1_c8;\n+  _gfortran_mfindloc1_i1;\n+  _gfortran_mfindloc1_i16;\n+  _gfortran_mfindloc1_i2;\n+  _gfortran_mfindloc1_i4;\n+  _gfortran_mfindloc1_i8;\n+  _gfortran_mfindloc1_r16;\n+  _gfortran_mfindloc1_r4;\n+  _gfortran_mfindloc1_r8;\n+  _gfortran_mfindloc1_s1;\n+  _gfortran_mfindloc1_s4;\n+  _gfortran_mfindloc2_s1;\n+  _gfortran_mfindloc2_s4;\n+  _gfortran_sfindloc0_c16;\n+  _gfortran_sfindloc0_c4;\n+  _gfortran_sfindloc0_c8;\n+  _gfortran_sfindloc0_i1;\n+  _gfortran_sfindloc0_i16;\n+  _gfortran_sfindloc0_i4;\n+  _gfortran_sfindloc0_i8;\n+  _gfortran_sfindloc0_r16;\n+  _gfortran_sfindloc0_r4;\n+  _gfortran_sfindloc0_r8;\n+  _gfortran_sfindloc0_s1;\n+  _gfortran_sfindloc0_s4;\n+  _gfortran_sfindloc1_c16;\n+  _gfortran_sfindloc1_c4;\n+  _gfortran_sfindloc1_c8;\n+  _gfortran_sfindloc1_i1;\n+  _gfortran_sfindloc1_i16;\n+  _gfortran_sfindloc1_i2;\n+  _gfortran_sfindloc1_i4;\n+  _gfortran_sfindloc1_i8;\n+  _gfortran_sfindloc1_r16;\n+  _gfortran_sfindloc1_r4;\n+  _gfortran_sfindloc1_r8;\n+  _gfortran_sfindloc1_s1;\n+  _gfortran_sfindloc1_s4;\n+  _gfortran_sfindloc2_s1;\n+  _gfortran_sfindloc2_s4;\n   _gfortran_st_wait_async;\n };"}, {"sha": "bea83f385618cfecc40b7e3a492312de92e3616f", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -359,6 +359,7 @@ typedef GFC_ARRAY_DESCRIPTOR (GFC_INTEGER_1) gfc_array_i1;\n typedef GFC_ARRAY_DESCRIPTOR (GFC_INTEGER_2) gfc_array_i2;\n typedef GFC_ARRAY_DESCRIPTOR (GFC_INTEGER_4) gfc_array_i4;\n typedef GFC_ARRAY_DESCRIPTOR (GFC_INTEGER_8) gfc_array_i8;\n+typedef GFC_ARRAY_DESCRIPTOR (index_type) gfc_array_index_type;\n #ifdef HAVE_GFC_INTEGER_16\n typedef GFC_ARRAY_DESCRIPTOR (GFC_INTEGER_16) gfc_array_i16;\n #endif\n@@ -385,8 +386,9 @@ typedef GFC_ARRAY_DESCRIPTOR (GFC_LOGICAL_8) gfc_array_l8;\n #ifdef HAVE_GFC_LOGICAL_16\n typedef GFC_ARRAY_DESCRIPTOR (GFC_LOGICAL_16) gfc_array_l16;\n #endif\n-typedef gfc_array_i1 gfc_array_s1;\n-typedef gfc_array_i4 gfc_array_s4;\n+\n+typedef GFC_ARRAY_DESCRIPTOR (GFC_UINTEGER_1) gfc_array_s1;\n+typedef GFC_ARRAY_DESCRIPTOR (GFC_UINTEGER_4) gfc_array_s4;\n \n /* These are for when you actually want to declare a descriptor, as\n    opposed to a pointer to it.  */\n@@ -1757,7 +1759,9 @@ void cshift1_16_c16 (gfc_array_c16 * const restrict,\n internal_proto(cshift1_16_c16);\n #endif\n \n-/* Define this if we support asynchronous I/O on this platform.  This\n-   currently requires weak symbols.  */\n+/* We always have these.  */\n+\n+#define HAVE_GFC_UINTEGER_1 1\n+#define HAVE_GFC_UINTEGER_4 1\n \n #endif  /* LIBGFOR_H  */"}, {"sha": "c64e527632b73bf5e0193a01397f34881c55137c", "filename": "libgfortran/m4/findloc0.m4", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fm4%2Ffindloc0.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fm4%2Ffindloc0.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Ffindloc0.m4?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -0,0 +1,38 @@\n+dnl Support macros for findloc.\n+dnl This file is part of the GNU Fortran Runtime Library (libgfortran)\n+dnl Distributed under the GNU GPL with exception.  See COPYING for details.\n+include(iparm.m4)dnl\n+define(header1,`extern void findloc0_'atype_code` (gfc_array_index_type * const restrict retarray,\n+       \t    \t\t'atype` * const restrict array, 'atype_name` value,\n+\t\t\t GFC_LOGICAL_4);\n+export_proto(findloc0_'atype_code`);\n+\n+void\n+findloc0_'atype_code` (gfc_array_index_type * const restrict retarray,\n+    \t    'atype` * const restrict array, 'atype_name` value,\n+\t    GFC_LOGICAL_4 back)')dnl\n+dnl\n+define(header2,`extern void mfindloc0_'atype_code` (gfc_array_index_type * const restrict retarray,\n+       \t    \t\t'atype` * const restrict array, 'atype_name` value,\n+\t\t\t gfc_array_l1 *const restrict, GFC_LOGICAL_4);\n+export_proto(mfindloc0_'atype_code`);\n+\n+void\n+mfindloc0_'atype_code` (gfc_array_index_type * const restrict retarray,\n+    \t    'atype` * const restrict array, 'atype_name` value,\n+\t    gfc_array_l1 *const restrict mask, GFC_LOGICAL_4 back)')\n+dnl\n+define(header3,`extern void sfindloc0_'atype_code` (gfc_array_index_type * const restrict retarray,\n+       \t    \t\t'atype` * const restrict array, 'atype_name` value,\n+\t\t\t GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n+export_proto(sfindloc0_'atype_code`);\n+\n+void\n+sfindloc0_'atype_code` (gfc_array_index_type * const restrict retarray,\n+    \t    'atype` * const restrict array, 'atype_name` value,\n+\t    GFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)')dnl\n+dnl\n+define(comparison,`*base == value')dnl\n+define(len_arg,`')dnl\n+define(base_mult,1)dnl\n+include(ifindloc0.m4)dnl"}, {"sha": "18be2c124ed8596f1d132927659ed647ef7432e5", "filename": "libgfortran/m4/findloc0s.m4", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fm4%2Ffindloc0s.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fm4%2Ffindloc0s.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Ffindloc0s.m4?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -0,0 +1,48 @@\n+dnl Support macros for findloc.\n+dnl This file is part of the GNU Fortran Runtime Library (libgfortran)\n+dnl Distributed under the GNU GPL with exception.  See COPYING for details.\n+include(iparm.m4)dnl\n+define(header1,`extern void findloc0_'atype_code` (gfc_array_index_type * const restrict retarray,\n+       \t    \t\t'atype` * const restrict array, 'atype_name` *value,\n+\t\t\t GFC_LOGICAL_4 back, gfc_charlen_type len_array, gfc_charlen_type len_value);\n+\n+export_proto(findloc0_'atype_code`);\n+\n+void\n+findloc0_'atype_code` (gfc_array_index_type * const restrict retarray,\n+    \t    'atype` * const restrict array, 'atype_name` *value,\n+\t    GFC_LOGICAL_4 back, gfc_charlen_type len_array, gfc_charlen_type len_value)')dnl\n+dnl\n+define(header2,`extern void mfindloc0_'atype_code` (gfc_array_index_type * const restrict retarray,\n+       \t    \t\t'atype` * const restrict array, 'atype_name` *value,\n+\t\t\t gfc_array_l1 *const restrict, GFC_LOGICAL_4 back, gfc_charlen_type len_array,\n+\t\t\t gfc_charlen_type len_value);\n+export_proto(mfindloc0_'atype_code`);\n+\n+void\n+mfindloc0_'atype_code` (gfc_array_index_type * const restrict retarray,\n+    \t    'atype` * const restrict array, 'atype_name` *value,\n+\t    gfc_array_l1 *const restrict mask, GFC_LOGICAL_4 back,\n+\t    gfc_charlen_type len_array, gfc_charlen_type len_value)')\n+dnl\n+define(header3,`extern void sfindloc0_'atype_code` (gfc_array_index_type * const restrict retarray,\n+       \t    \t\t'atype` * const restrict array, 'atype_name` *value,\n+\t\t\t GFC_LOGICAL_4 *, GFC_LOGICAL_4 back, gfc_charlen_type len_array,\n+\t\t\t gfc_charlen_type len_value);\n+export_proto(sfindloc0_'atype_code`);\n+\n+void\n+sfindloc0_'atype_code` (gfc_array_index_type * const restrict retarray,\n+    \t    'atype` * const restrict array, 'atype_name` *value,\n+\t    GFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back, gfc_charlen_type len_array,\n+\t    gfc_charlen_type len_value)')dnl\n+dnl\n+define(comparison,ifelse(atype_kind,4,dnl\n+`compare_string_char4 (len_array, base, len_value, value) == 0',dnl\n+`compare_string (len_array, (char *) base, len_value, (char *) value) == 0'))dnl\n+define(len_arg,`, len_array, len_value')dnl\n+define(base_mult,`len_array')dnl\n+include(ifindloc0.m4)dnl\n+\n+\n+"}, {"sha": "1623355b228808587805625e296c3a063949c1e7", "filename": "libgfortran/m4/findloc1.m4", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fm4%2Ffindloc1.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fm4%2Ffindloc1.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Ffindloc1.m4?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -0,0 +1,40 @@\n+dnl Support macros for findloc.\n+dnl This file is part of the GNU Fortran Runtime Library (libgfortran)\n+dnl Distributed under the GNU GPL with exception.  See COPYING for details.\n+include(iparm.m4)dnl\n+define(header1,`extern void findloc1_'atype_code` (gfc_array_index_type * const restrict retarray,\n+\t\t         'atype` * const restrict array, 'atype_name` value,\n+\t\t\t const 'index_type` * restrict pdim, GFC_LOGICAL_4 back);\n+export_proto(findloc1_'atype_code`);\n+\n+extern void\n+findloc1_'atype_code` (gfc_array_index_type * const restrict retarray,\n+\t    'atype` * const restrict array, 'atype_name` value,\n+\t    const 'index_type` * restrict pdim, GFC_LOGICAL_4 back)')dnl\n+dnl\n+define(header2,`extern void mfindloc1_'atype_code` (gfc_array_index_type * const restrict retarray,\n+\t\t         'atype` * const restrict array, 'atype_name` value,\n+\t\t\t const 'index_type` * restrict pdim, gfc_array_l1 *const restrict mask,\n+\t\t\t GFC_LOGICAL_4 back);\n+export_proto(mfindloc1_'atype_code`);\n+\n+extern void\n+mfindloc1_'atype_code` (gfc_array_index_type * const restrict retarray,\n+\t    'atype` * const restrict array, 'atype_name` value,\n+\t    const 'index_type` * restrict pdim, gfc_array_l1 *const restrict mask,\n+\t    GFC_LOGICAL_4 back)')dnl\n+define(header3,`extern void sfindloc1_'atype_code` (gfc_array_index_type * const restrict retarray,\n+\t\t         'atype` * const restrict array, 'atype_name` value,\n+\t\t\t const 'index_type` * restrict pdim, GFC_LOGICAL_4 *const restrict mask,\n+\t\t\t GFC_LOGICAL_4 back);\n+export_proto(sfindloc1_'atype_code`);\n+\n+extern void\n+sfindloc1_'atype_code` (gfc_array_index_type * const restrict retarray,\n+\t    'atype` * const restrict array, 'atype_name` value,\n+\t    const 'index_type` * restrict pdim, GFC_LOGICAL_4 *const restrict  mask,\n+\t    GFC_LOGICAL_4 back)')dnl\n+define(comparison,`*src == value')dnl\n+define(len_arg,`')dnl\n+define(base_mult,1)dnl\n+include(ifindloc1.m4)dnl"}, {"sha": "439617c6c9909a5b41c7e74704c33f363bf66866", "filename": "libgfortran/m4/findloc1s.m4", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fm4%2Ffindloc1s.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fm4%2Ffindloc1s.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Ffindloc1s.m4?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -0,0 +1,44 @@\n+dnl Support macros for findloc.\n+dnl This file is part of the GNU Fortran Runtime Library (libgfortran)\n+dnl Distributed under the GNU GPL with exception.  See COPYING for details.\n+include(iparm.m4)dnl\n+define(header1,`extern void findloc1_'atype_code` (gfc_array_index_type * const restrict retarray,\n+\t\t         'atype` * const restrict array, 'atype_name` *const restrict value,\n+\t\t\t const 'index_type` * restrict pdim, GFC_LOGICAL_4 back,\n+\t\t\t gfc_charlen_type len_array, gfc_charlen_type len_value);\n+export_proto(findloc1_'atype_code`);\n+\n+extern void\n+findloc1_'atype_code` (gfc_array_index_type * const restrict retarray,\n+\t    'atype` * const restrict array, 'atype_name` *const restrict value,\n+\t    const 'index_type` * restrict pdim, GFC_LOGICAL_4 back,\n+\t    gfc_charlen_type len_array, gfc_charlen_type len_value)')dnl\n+dnl\n+define(header2,`extern void mfindloc1_'atype_code` (gfc_array_index_type * const restrict retarray,\n+\t\t         'atype` * const restrict array, 'atype_name` *const restrict value,\n+\t\t\t const 'index_type` * restrict pdim, gfc_array_l1 *const restrict mask,\n+\t\t\t GFC_LOGICAL_4 back, gfc_charlen_type len_array, gfc_charlen_type len_value);\n+export_proto(mfindloc1_'atype_code`);\n+\n+extern void\n+mfindloc1_'atype_code` (gfc_array_index_type * const restrict retarray,\n+\t    'atype` * const restrict array, 'atype_name` *const restrict value,\n+\t    const 'index_type` * restrict pdim, gfc_array_l1 *const restrict mask,\n+\t    GFC_LOGICAL_4 back, gfc_charlen_type len_array, gfc_charlen_type len_value)')dnl\n+define(header3,`extern void sfindloc1_'atype_code` (gfc_array_index_type * const restrict retarray,\n+\t\t         'atype` * const restrict array, 'atype_name` *const restrict value,\n+\t\t\t const 'index_type` * restrict pdim, GFC_LOGICAL_4 *const restrict mask,\n+\t\t\t GFC_LOGICAL_4 back, gfc_charlen_type len_array, gfc_charlen_type len_value);\n+export_proto(sfindloc1_'atype_code`);\n+\n+extern void\n+sfindloc1_'atype_code` (gfc_array_index_type * const restrict retarray,\n+\t    'atype` * const restrict array, 'atype_name` *const restrict value,\n+\t    const 'index_type` * restrict pdim, GFC_LOGICAL_4 *const restrict  mask,\n+\t    GFC_LOGICAL_4 back, gfc_charlen_type len_array, gfc_charlen_type len_value)')dnl\n+define(comparison,ifelse(atype_kind,4,dnl\n+`compare_string_char4 (len_array, src, len_value, value) == 0',dnl\n+`compare_string (len_array, (char *) src, len_value, (char *) value) == 0'))dnl\n+define(len_arg,`, len_array, len_value')dnl\n+define(base_mult,`len_array')dnl\n+include(ifindloc1.m4)dnl"}, {"sha": "a0f13f8cadb29d6f69e553a1a1e3fe2ea13c0f3a", "filename": "libgfortran/m4/findloc2s.m4", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fm4%2Ffindloc2s.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fm4%2Ffindloc2s.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Ffindloc2s.m4?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -0,0 +1,44 @@\n+dnl Support macros for findloc.\n+dnl This file is part of the GNU Fortran Runtime Library (libgfortran)\n+dnl Distributed under the GNU GPL with exception.  See COPYING for details.\n+include(iparm.m4)dnl\n+define(header1,`index_type findloc2_'atype_code` ('atype` * const restrict array,\n+\t\t\t   const 'atype_name` * restrict value, GFC_LOGICAL_4 back,\n+\t\t\t   gfc_charlen_type len_array, gfc_charlen_type len_value);\n+export_proto(findloc2_'atype_code`);\n+\n+index_type\n+findloc2_'atype_code` ('atype` * const restrict array, const 'atype_name` * restrict value,\n+\t\t      GFC_LOGICAL_4 back,\n+\t\t      gfc_charlen_type len_array, gfc_charlen_type len_value)')dnl\n+dnl\n+define(header2,`index_type mfindloc2_'atype_code` ('atype` * const restrict array,\n+\t\t\t const 'atype_name` * restrict value,\n+\t\t\t gfc_array_l1 *const restrict mask, GFC_LOGICAL_4 back,\n+\t\t\t gfc_charlen_type len_array, gfc_charlen_type len_value);\n+export_proto(mfindloc2_'atype_code`);\n+\n+index_type\n+mfindloc2_'atype_code` ('atype` * const restrict array,\n+\t\t\t   const 'atype_name` * restrict value, gfc_array_l1 *const restrict mask,\n+\t\t\t   GFC_LOGICAL_4 back, gfc_charlen_type len_array,\n+\t\t\t   gfc_charlen_type len_value)')dnl\n+dnl\n+define(header3,`index_type sfindloc2_'atype_code` ('atype` * const restrict array,\n+\t\t\t const 'atype_name` * restrict value,\n+\t\t\t GFC_LOGICAL_4 *const restrict mask, GFC_LOGICAL_4 back,\n+\t\t\t gfc_charlen_type len_array, gfc_charlen_type len_value);\n+export_proto(sfindloc2_'atype_code`);\n+\n+index_type\n+sfindloc2_'atype_code` ('atype` * const restrict array,\n+\t\t\t   const 'atype_name` * restrict value, GFC_LOGICAL_4 *const restrict mask,\n+\t\t\t   GFC_LOGICAL_4 back, gfc_charlen_type len_array,\n+\t\t\t   gfc_charlen_type len_value)')dnl\n+dnl\n+define(comparison,ifelse(atype_kind,4,dnl\n+`compare_string_char4 (len_array, src, len_value, value) == 0',dnl\n+`compare_string (len_array, (char *) src, len_value, (char *) value) == 0'))dnl\n+define(len_arg,`len_array, len_value')dnl\n+define(base_mult,`len_array')dnl\n+include(ifindloc2.m4)dnl"}, {"sha": "94937f1ed208c5a3f45abc65c1eeb4e42f3c8554", "filename": "libgfortran/m4/ifindloc0.m4", "status": "added", "additions": 350, "deletions": 0, "changes": 350, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fm4%2Fifindloc0.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fm4%2Fifindloc0.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fifindloc0.m4?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -0,0 +1,350 @@\n+`/* Implementation of the FINDLOC intrinsic\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by Thomas K\u00f6nig <tk@tkoenig.net>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <assert.h>\n+\n+#if defined (HAVE_'atype_name`)\n+'header1`\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const 'atype_name` *base;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type sz;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"FINDLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+\n+  /* Set the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+\n+  sz = 1;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      sz *= extent[n];\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+    for (n = 0; n < rank; n++)\n+      count[n] = 0;\n+\n+  if (back)\n+    {\n+      base = array->base_addr + (sz - 1) * 'base_mult`'`;\n+\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely('comparison`))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = extent[n] - count[n];\n+\n+\t\t  return;\n+\t\t}\n+\t      base -= sstride[0] * 'base_mult`'`;\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base += sstride[n] * extent[n] * 'base_mult`'`;\n+\t      n++;\n+\t      if (n >= rank)\n+\t        return;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base -= sstride[n] * 'base_mult`'`;\n+\t\t}\n+\t    } while (count[n] == extent[n]);      \n+\t}\n+    }\n+  else\n+    {\n+      base = array->base_addr;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely('comparison`))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\n+\t\t  return;\n+\t\t}\n+\t      base += sstride[0] * 'base_mult`'`;\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base -= sstride[n] * extent[n] * 'base_mult`'`;\n+\t      n++;\n+\t      if (n >= rank)\n+\t        return;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base += sstride[n] * 'base_mult`'`;\n+\t\t}\n+\t    } while (count[n] == extent[n]);\n+\t}\n+    }\n+  return;\n+}\n+\n+'header2`\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const 'atype_name` *base;\n+  index_type * restrict dest;\n+  GFC_LOGICAL_1 *mbase;\n+  index_type rank;\n+  index_type n;\n+  int mask_kind;\n+  index_type sz;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"FINDLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t\"MASK argument\", \"FINDLOC\");\n+\t}\n+    }\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+\n+  /* Set the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+\n+  sz = 1;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      sz *= extent[n];\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+    for (n = 0; n < rank; n++)\n+      count[n] = 0;\n+\n+  if (back)\n+    {\n+      base = array->base_addr + (sz - 1) * 'base_mult`'`;\n+      mbase = mbase + (sz - 1) * mask_kind;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*mbase && 'comparison`))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = extent[n] - count[n];\n+\n+\t\t  return;\n+\t\t}\n+\t      base -= sstride[0] * 'base_mult`'`;\n+\t      mbase -= mstride[0];\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base += sstride[n] * extent[n] * 'base_mult`'`;\n+\t      mbase -= mstride[n] * extent[n];\n+\t      n++;\n+\t      if (n >= rank)\n+\t\treturn;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base -= sstride[n] * 'base_mult`'`;\n+\t\t  mbase += mstride[n];\n+\t\t}\n+\t    } while (count[n] == extent[n]);      \n+\t}\n+    }\n+  else\n+    {\n+      base = array->base_addr;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*mbase && 'comparison`))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\n+\t\t  return;\n+\t\t}\n+\t      base += sstride[0] * 'base_mult`'`;\n+\t      mbase += mstride[0];\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base -= sstride[n] * extent[n] * 'base_mult`'`;\n+\t      mbase -= mstride[n] * extent[n];\n+\t      n++;\n+\t      if (n >= rank)\n+\t\treturn;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base += sstride[n]* 'base_mult`'`;\n+\t\t  mbase += mstride[n];\n+\t\t}\n+\t    } while (count[n] == extent[n]);\n+\t}\n+    }\n+  return;\n+}\n+\n+'header3`\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type * restrict dest;\n+  index_type n;\n+\n+  if (*mask)\n+    {\n+      findloc0_'atype_code` (retarray, array, value, back'len_arg`);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    internal_error (NULL, \"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"FINDLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n+\n+#endif'"}, {"sha": "70638be793b669a44fd3289f465e4c3bc3df32f9", "filename": "libgfortran/m4/ifindloc1.m4", "status": "added", "additions": 495, "deletions": 0, "changes": 495, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fm4%2Fifindloc1.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fm4%2Fifindloc1.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fifindloc1.m4?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -0,0 +1,495 @@\n+`/* Implementation of the FINDLOC intrinsic\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by Thomas K\u00f6nig <tk@tkoenig.net>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <assert.h>\n+\n+#if defined (HAVE_'atype_name`)\n+'header1`\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const 'atype_name`'` * restrict base;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  base = array->base_addr;\n+  while (continue_loop)\n+    {\n+      const 'atype_name`'` * restrict src;\n+      index_type result;\n+\n+      result = 0;\n+      if (back)\n+\t{\n+\t  src = base + (len - 1) * delta * 'base_mult`;\n+\t  for (n = len; n > 0; n--, src -= delta * 'base_mult`)\n+\t    {\n+\t      if ('comparison`'`)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  src = base;\n+\t  for (n = 1; n <= len; n++, src += delta * 'base_mult`)\n+\t    {\n+\t      if ('comparison`'`)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      *dest = result;\n+\n+      count[0]++;\n+      base += sstride[0] * 'base_mult`;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  base -= sstride[n] * extent[n] * 'base_mult`;\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n] * 'base_mult`;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+'header2`'`\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const 'atype_name`'` * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  index_type dim;\n+  int mask_kind;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  mbase = mask->base_addr;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  base = array->base_addr;\n+  while (continue_loop)\n+    {\n+      const 'atype_name`'` * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      index_type result;\n+\n+      result = 0;\n+      if (back)\n+\t{\n+\t  src = base + (len - 1) * delta * 'base_mult`;\n+\t  msrc = mbase + (len - 1) * mdelta; \n+\t  for (n = len; n > 0; n--, src -= delta * 'base_mult`, msrc -= mdelta)\n+\t    {\n+\t      if (*msrc && 'comparison`'`)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  src = base;\n+\t  msrc = mbase;\n+\t  for (n = 1; n <= len; n++, src += delta * 'base_mult`, msrc += mdelta)\n+\t    {\n+\t      if (*msrc && 'comparison`'`)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      *dest = result;\n+\n+      count[0]++;\n+      base += sstride[0] * 'base_mult`;\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  base -= sstride[n] * extent[n] * 'base_mult`;\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n] * 'base_mult`;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+'header3`'`\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type dim;\n+  bool continue_loop;\n+\n+  if (*mask)\n+    {\n+      findloc1_'atype_code`'` (retarray, array, value, pdim, back'len_arg`'`);\n+      return;\n+    }\n+    /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  while (continue_loop)\n+    {\n+      *dest = 0;\n+\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+#endif'"}, {"sha": "ede704132af295ad3987577d431e2c81ee08c0de", "filename": "libgfortran/m4/ifindloc2.m4", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fm4%2Fifindloc2.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fm4%2Fifindloc2.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fifindloc2.m4?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -0,0 +1,126 @@\n+`/* Implementation of the FINDLOC intrinsic\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by Thomas K\u00f6nig <tk@tkoenig.net>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+\n+#ifdef HAVE_'atype_name`'`\n+'header1`'`\n+{\n+  index_type i;\n+  index_type sstride;\n+  index_type extent;\n+  const 'atype_name`'` * restrict src;\n+\n+  extent = GFC_DESCRIPTOR_EXTENT(array,0);\n+  if (extent <= 0)\n+    return 0;\n+\n+  sstride = GFC_DESCRIPTOR_STRIDE(array,0) * 'base_mult`'`;\n+  if (back)\n+    {\n+      src = array->base_addr + (extent - 1) * sstride;\n+      for (i = extent; i >= 0; i--)\n+\t{\n+\t  if ('comparison`'`)\n+\t    return i;\n+\t  src -= sstride;\n+\t}\n+    }\n+  else\n+    {\n+      src = array->base_addr;\n+      for (i = 1; i <= extent; i++)\n+\t{\n+\t  if ('comparison`'`)\n+\t    return i;\n+\t  src += sstride;\n+\t}\n+    }\n+  return 0;\n+}\n+\n+'header2`'`\n+{\n+  index_type i;\n+  index_type sstride;\n+  index_type extent;\n+  const 'atype_name`'` * restrict src;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  int mask_kind;\n+  index_type mstride;\n+\n+  extent = GFC_DESCRIPTOR_EXTENT(array,0);\n+  if (extent <= 0)\n+    return 0;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  sstride = GFC_DESCRIPTOR_STRIDE(array,0) * 'base_mult`'`;\n+  mstride = GFC_DESCRIPTOR_STRIDE_BYTES(mask,0);\n+\n+  if (back)\n+    {\n+      src = array->base_addr + (extent - 1) * sstride;\n+      mbase += (extent - 1) * mstride;\n+      for (i = extent; i >= 0; i--)\n+\t{\n+\t  if (*mbase && ('comparison`'`))\n+\t    return i;\n+\t  src -= sstride;\n+\t  mbase -= mstride;\n+\t}\n+    }\n+  else\n+    {\n+      src = array->base_addr;\n+      for (i = 1; i <= extent; i++)\n+\t{\n+\t  if (*mbase && ('comparison`'`))\n+\t    return i;\n+\t  src += sstride;\n+\t  mbase += mstride;\n+\t}\n+    }\n+  return 0;\n+}\n+'header3`'`\n+{\n+  if (*mask)\n+    {\n+      return findloc2_'atype_code` (array, value, back, len_array, len_value);\n+    }\n+  return 0;\n+}\n+#endif'"}, {"sha": "b474620424b78d5f57635d42af940c2df6d50850", "filename": "libgfortran/m4/iparm.m4", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fm4%2Fiparm.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce9e31a02c8039d88e90f983735104417bf034/libgfortran%2Fm4%2Fiparm.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fiparm.m4?ref=01ce9e31a02c8039d88e90f983735104417bf034", "patch": "@@ -4,7 +4,7 @@ dnl This file is part of the GNU Fortran 95 Runtime Library (libgfortran)\n dnl Distributed under the GNU GPL with exception.  See COPYING for details.\n dnl M4 macro file to get type names from filenames\n define(get_typename2, `GFC_$1_$2')dnl\n-define(get_typename, `get_typename2(ifelse($1,i,INTEGER,ifelse($1,r,REAL,ifelse($1,l,LOGICAL,ifelse($1,c,COMPLEX,ifelse($1,s,INTEGER,unknown))))),`$2')')dnl\n+define(get_typename, `get_typename2(ifelse($1,i,INTEGER,ifelse($1,r,REAL,ifelse($1,l,LOGICAL,ifelse($1,c,COMPLEX,ifelse($1,s,UINTEGER,unknown))))),`$2')')dnl\n define(get_arraytype, `gfc_array_$1$2')dnl\n define(define_type, `dnl\n ifelse(regexp($2,`^[0-9]'),-1,`dnl"}]}