{"sha": "6a9d31a7d48bbae78a24a1395199d5c4c048d642", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmE5ZDMxYTdkNDhiYmFlNzhhMjRhMTM5NTE5OWQ1YzRjMDQ4ZDY0Mg==", "commit": {"author": {"name": "Anthony Green", "email": "green@redhat.com", "date": "2001-01-08T00:27:51Z"}, "committer": {"name": "Anthony Green", "email": "green@gcc.gnu.org", "date": "2001-01-08T00:27:51Z"}, "message": "001-01-07  Anthony Green  <green@redhat.com>\n\n\t* Makefile.am (texinfo): Add texinfo target for generating texinfo\n        documentation.\n\t* Makefile.in: Rebuilt.\n\n\t* scripts/TexinfoDoclet.java: New file.\n\n\t* doc/java-applet.texi, doc/java-lang-reflect.texi,\n\tdoc/java-awt-color.texi, doc/java-lang.texi,\n\tdoc/java-awt-datatransfer.texi, doc/java-math.texi,\n        doc/java-awt-event.texi, doc/java-net.texi,\n\tdoc/java-awt-geom.texi, doc/java-security-spec.texi,\n\tdoc/java-awt-image.texi, doc/java-security.texi,\n\tdoc/java-awt-peer.texi, doc/java-sql.texi, doc/java-awt.texi,\n\tdoc/java-text.texi, doc/java-beans-beancontext.texi,\n        doc/java-util-jar.texi, doc/java-beans.texi,\n\tdoc/java-util-zip.texi, doc/java-io.texi, doc/java-util.texi,\n\tdoc/java-lang-ref.texi: New files.\n\nFrom-SVN: r38789", "tree": {"sha": "e6058c157f2a58ea1d1cadda719e0332b688b0ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e6058c157f2a58ea1d1cadda719e0332b688b0ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a9d31a7d48bbae78a24a1395199d5c4c048d642", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a9d31a7d48bbae78a24a1395199d5c4c048d642", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a9d31a7d48bbae78a24a1395199d5c4c048d642", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a9d31a7d48bbae78a24a1395199d5c4c048d642/comments", "author": {"login": "atgreen", "id": 89993, "node_id": "MDQ6VXNlcjg5OTkz", "avatar_url": "https://avatars.githubusercontent.com/u/89993?v=4", "gravatar_id": "", "url": "https://api.github.com/users/atgreen", "html_url": "https://github.com/atgreen", "followers_url": "https://api.github.com/users/atgreen/followers", "following_url": "https://api.github.com/users/atgreen/following{/other_user}", "gists_url": "https://api.github.com/users/atgreen/gists{/gist_id}", "starred_url": "https://api.github.com/users/atgreen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/atgreen/subscriptions", "organizations_url": "https://api.github.com/users/atgreen/orgs", "repos_url": "https://api.github.com/users/atgreen/repos", "events_url": "https://api.github.com/users/atgreen/events{/privacy}", "received_events_url": "https://api.github.com/users/atgreen/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "18f988a06bd585a53af224091ef2e6a29074a511", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18f988a06bd585a53af224091ef2e6a29074a511", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18f988a06bd585a53af224091ef2e6a29074a511"}], "stats": {"total": 18489, "additions": 18487, "deletions": 2}, "files": [{"sha": "dbcccecafff6b7bf7c40401886c33f8caebb4031", "filename": "libjava/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=6a9d31a7d48bbae78a24a1395199d5c4c048d642", "patch": "@@ -1,3 +1,23 @@\n+2001-01-07  Anthony Green  <green@redhat.com>\n+\n+\t* Makefile.am (texinfo): Add texinfo target for generating texinfo\n+\tdocumentation.\n+\t* Makefile.in: Rebuilt.\n+\n+\t* scripts/TexinfoDoclet.java: New file.\n+\n+\t* doc/java-applet.texi, doc/java-lang-reflect.texi,\n+\tdoc/java-awt-color.texi, doc/java-lang.texi,\n+\tdoc/java-awt-datatransfer.texi, doc/java-math.texi,\n+\tdoc/java-awt-event.texi, doc/java-net.texi,\n+\tdoc/java-awt-geom.texi, doc/java-security-spec.texi,\n+\tdoc/java-awt-image.texi, doc/java-security.texi,\n+\tdoc/java-awt-peer.texi, doc/java-sql.texi, doc/java-awt.texi,\n+\tdoc/java-text.texi, doc/java-beans-beancontext.texi,\n+\tdoc/java-util-jar.texi, doc/java-beans.texi,\n+\tdoc/java-util-zip.texi, doc/java-io.texi, doc/java-util.texi,\n+\tdoc/java-lang-ref.texi: New files.\n+\n 2001-01-07  Anthony Green  <green@redhat.com>\n \n \t* java/net/URLConnection.java (setDoOutput): URLConnection's may"}, {"sha": "414ae2caade383aeb724ae387a3b6e29c7a3c24c", "filename": "libjava/Makefile.am", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=6a9d31a7d48bbae78a24a1395199d5c4c048d642", "patch": "@@ -135,7 +135,7 @@ EXTRA_libgcj_la_SOURCES = boehm.cc nogc.cc posix-threads.cc no-threads.cc \\\n \t$(c_source_files) $(java_source_files) $(built_java_source_files)\n libgcj_la_DEPENDENCIES = libgcj.jar $(javao_files) \\\n \t$(c_files) $(GCOBJS) $(THREADOBJS) $(LIBLTDL)\n-\t\n+\n # Include THREADLIBS here to ensure that the correct version of\n # certain linuxthread functions get linked:\n libgcj_la_LIBADD = $(javao_files) $(c_files) $(GCOBJS) \\\n@@ -1322,6 +1322,44 @@ gnu/gcj/xlib/natXUnmapEvent.cc\n \n ## ################################################################\n \n+##\n+## javadoc to texinfo conversion\n+##\n+\n+TexinfoDoclet.class: $(srcdir)/scripts/TexinfoDoclet.java\n+\tjavac -d . $(srcdir)/scripts/TexinfoDoclet.java\n+\n+texinfo: TexinfoDoclet.class\n+\tlangsource=`ls $(srcdir)/java/lang/*.java`; \\\n+\tlang=`echo $$langsource | sed -e 's/[^ ].*EcosProcess.java//g' | sed -e 's/[^ ].*PosixProcess.java//g'`; \\\n+\tjavadoc -outfile $(srcdir)/doc/java-lang.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $$lang\n+\tjavadoc -outfile $(srcdir)/doc/java-lang-ref.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $(srcdir)/java/lang/ref/*.java\n+\tjavadoc -outfile $(srcdir)/doc/java-lang-reflect.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $(srcdir)/java/lang/reflect/*.java\n+\tjavadoc -outfile $(srcdir)/doc/java-applet.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $(srcdir)/java/applet/*.java\n+\tjavadoc -outfile $(srcdir)/doc/java-awt.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $(srcdir)/java/awt/*.java\n+\tjavadoc -outfile $(srcdir)/doc/java-awt-color.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $(srcdir)/java/awt/color/*.java\n+\tjavadoc -outfile $(srcdir)/doc/java-awt-datatransfer.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $(srcdir)/java/awt/datatransfer/*.java\n+\tjavadoc -outfile $(srcdir)/doc/java-awt-event.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $(srcdir)/java/awt/event/*.java\n+\tjavadoc -outfile $(srcdir)/doc/java-awt-geom.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $(srcdir)/java/awt/geom/*.java\n+\tjavadoc -outfile $(srcdir)/doc/java-awt-image.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $(srcdir)/java/awt/image/*.java\n+\tjavadoc -outfile $(srcdir)/doc/java-awt-peer.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $(srcdir)/java/awt/peer/*.java\n+\tjavadoc -outfile $(srcdir)/doc/java-beans.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $(srcdir)/java/beans/*.java\n+\tjavadoc -outfile $(srcdir)/doc/java-beans-beancontext.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $(srcdir)/java/beans/beancontext/*.java\n+\tjavadoc -outfile $(srcdir)/doc/java-io.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $(srcdir)/java/io/*.java\n+\tjavadoc -outfile $(srcdir)/doc/java-math.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $(srcdir)/java/math/*.java\n+\tjavadoc -outfile $(srcdir)/doc/java-net.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $(srcdir)/java/net/*.java\n+\tjavadoc -outfile $(srcdir)/doc/java-security.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $(srcdir)/java/security/*.java\n+\tjavadoc -outfile $(srcdir)/doc/java-security-cert.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $(srcdir)/java/security-cert/*.java\n+\tjavadoc -outfile $(srcdir)/doc/java-security-spec.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $(srcdir)/java/security/spec/*.java\n+\tjavadoc -outfile $(srcdir)/doc/java-security-interfaces.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $(srcdir)/java/security/spec/interfaces/*.java\n+\tjavadoc -outfile $(srcdir)/doc/java-sql.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $(srcdir)/java/sql/*.java\n+\tjavadoc -outfile $(srcdir)/doc/java-text.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $(srcdir)/java/text/*.java\n+\tjavadoc -outfile $(srcdir)/doc/java-util.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $(srcdir)/java/util/*.java\n+\tjavadoc -outfile $(srcdir)/doc/java-util-jar.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $(srcdir)/java/util/jar/*.java\n+\tjavadoc -outfile $(srcdir)/doc/java-util-zip.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $(srcdir)/java/util/zip/*.java\n+\n+## ################################################################\n+\n ##\n ## Dependency tracking madness.\n ##"}, {"sha": "ac5e493444689a7f4cdfdbab4ba0318817992654", "filename": "libjava/Makefile.in", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=6a9d31a7d48bbae78a24a1395199d5c4c048d642", "patch": "@@ -1198,7 +1198,7 @@ libgcj-test.spec.in libgcj.spec.in\n \n DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)\n \n-TAR = tar\n+TAR = gtar\n GZIP_ENV = --best\n DIST_SUBDIRS =  @DIRLTDL@ testsuite gcj include @DIRLTDL@ gcj include\n DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n@@ -2494,6 +2494,38 @@ $(CONVERT_DIR)/make-trie.o: $(srcdir)/$(CONVERT_DIR)/make-trie.c\n @NATIVE_TRUE@@MAINTAINER_MODE_TRUE@$(srcdir)/$(CONVERT_DIR)/Unicode_to_JIS.cc: ./gen-from-JIS$(EXEEXT)\n @NATIVE_TRUE@@MAINTAINER_MODE_TRUE@\t ./gen-from-JIS toJIS>$(srcdir)/$(CONVERT_DIR)/Unicode_to_JIS.cc\n \n+TexinfoDoclet.class: $(srcdir)/scripts/TexinfoDoclet.java\n+\tjavac -d . $(srcdir)/scripts/TexinfoDoclet.java\n+\n+texinfo: TexinfoDoclet.class\n+\tlangsource=`ls $(srcdir)/java/lang/*.java`; \\\n+\tlang=`echo $$langsource | sed -e 's/[^ ].*EcosProcess.java//g' | sed -e 's/[^ ].*PosixProcess.java//g'`; \\\n+\tjavadoc -outfile $(srcdir)/doc/java-lang.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $$lang\n+\tjavadoc -outfile $(srcdir)/doc/java-lang-ref.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $(srcdir)/java/lang/ref/*.java\n+\tjavadoc -outfile $(srcdir)/doc/java-lang-reflect.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $(srcdir)/java/lang/reflect/*.java\n+\tjavadoc -outfile $(srcdir)/doc/java-applet.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $(srcdir)/java/applet/*.java\n+\tjavadoc -outfile $(srcdir)/doc/java-awt.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $(srcdir)/java/awt/*.java\n+\tjavadoc -outfile $(srcdir)/doc/java-awt-color.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $(srcdir)/java/awt/color/*.java\n+\tjavadoc -outfile $(srcdir)/doc/java-awt-datatransfer.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $(srcdir)/java/awt/datatransfer/*.java\n+\tjavadoc -outfile $(srcdir)/doc/java-awt-event.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $(srcdir)/java/awt/event/*.java\n+\tjavadoc -outfile $(srcdir)/doc/java-awt-geom.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $(srcdir)/java/awt/geom/*.java\n+\tjavadoc -outfile $(srcdir)/doc/java-awt-image.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $(srcdir)/java/awt/image/*.java\n+\tjavadoc -outfile $(srcdir)/doc/java-awt-peer.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $(srcdir)/java/awt/peer/*.java\n+\tjavadoc -outfile $(srcdir)/doc/java-beans.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $(srcdir)/java/beans/*.java\n+\tjavadoc -outfile $(srcdir)/doc/java-beans-beancontext.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $(srcdir)/java/beans/beancontext/*.java\n+\tjavadoc -outfile $(srcdir)/doc/java-io.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $(srcdir)/java/io/*.java\n+\tjavadoc -outfile $(srcdir)/doc/java-math.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $(srcdir)/java/math/*.java\n+\tjavadoc -outfile $(srcdir)/doc/java-net.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $(srcdir)/java/net/*.java\n+\tjavadoc -outfile $(srcdir)/doc/java-security.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $(srcdir)/java/security/*.java\n+\tjavadoc -outfile $(srcdir)/doc/java-security-cert.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $(srcdir)/java/security-cert/*.java\n+\tjavadoc -outfile $(srcdir)/doc/java-security-spec.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $(srcdir)/java/security/spec/*.java\n+\tjavadoc -outfile $(srcdir)/doc/java-security-interfaces.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $(srcdir)/java/security/spec/interfaces/*.java\n+\tjavadoc -outfile $(srcdir)/doc/java-sql.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $(srcdir)/java/sql/*.java\n+\tjavadoc -outfile $(srcdir)/doc/java-text.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $(srcdir)/java/text/*.java\n+\tjavadoc -outfile $(srcdir)/doc/java-util.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $(srcdir)/java/util/*.java\n+\tjavadoc -outfile $(srcdir)/doc/java-util-jar.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $(srcdir)/java/util/jar/*.java\n+\tjavadoc -outfile $(srcdir)/doc/java-util-zip.texi -doclet TexinfoDoclet -sourcepath .:$(srcdir) $(srcdir)/java/util/zip/*.java\n+\n -include deps.mk\n \n all-recursive: $(nat_headers) $(x_nat_headers)"}, {"sha": "bcd4637d233b84bf21def8db83eb36d538b32385", "filename": "libjava/doc/java-applet.texi", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2Fdoc%2Fjava-applet.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2Fdoc%2Fjava-applet.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fdoc%2Fjava-applet.texi?ref=6a9d31a7d48bbae78a24a1395199d5c4c048d642", "patch": "@@ -0,0 +1,141 @@\n+@deftypemethod AppletContext {public AudioClip} getAudioClip (java.net.URL@w{ }@var{url}) \n+Returns an audio clip from the specified URL.\n+@end deftypemethod\n+@deftypemethod AppletContext {public Image} getImage (java.net.URL@w{ }@var{url}) \n+Returns an image from the specified URL.  Note that the image is not\n+ actually retrieved until the applet attempts to display it, so this\n+ method returns immediately.\n+@end deftypemethod\n+@deftypemethod AppletContext {public Applet} getApplet (java.lang.String@w{ }@var{name}) \n+Returns the applet in the document for this object that has the\n+ specified name.\n+@end deftypemethod\n+@deftypemethod AppletContext {public Enumeration} getApplets () \n+Returns a list of all the applets in the document for this object.\n+@end deftypemethod\n+@deftypemethod AppletContext {public void} showDocument (java.net.URL@w{ }@var{url}) \n+Displays the web page pointed to by the specified URL in the window\n+ for this object.  This page replaces the document that is currently\n+ there.\n+@end deftypemethod\n+@deftypemethod AppletContext {public void} showDocument (java.net.URL@w{ }@var{url}, java.lang.String@w{ }@var{target}) \n+Displays the web page pointed to be the sepcified URL in the window\n+ with the specified name.  The standard names \"_top\", \"_blank\",\n+ \"_parent\", and \"_self\" are allowed.\n+@end deftypemethod\n+@deftypemethod AppletContext {public void} showStatus (java.lang.String@w{ }@var{message}) \n+Displays the specified message in the status window if that window\n+ exists.\n+@end deftypemethod\n+@deftypemethod Applet {public URL} getDocumentBase () \n+Returns the URL of the document this applet is embedded in.\n+@end deftypemethod\n+@deftypemethod Applet {public URL} getCodeBase () \n+Returns the URL of the code base for this applet.\n+@end deftypemethod\n+@deftypemethod Applet {public String} getParameter (java.lang.String@w{ }@var{name}) \n+Returns the value of the specified parameter that was specified in \n+ the &lt;APPLET&gt; tag for this applet.\n+@end deftypemethod\n+@deftypemethod Applet {public AppletContext} getAppletContext () \n+Returns the applet context for this applet.\n+@end deftypemethod\n+@deftypemethod Applet {public boolean} isActive () \n+Tests whether or not this applet is currently active.\n+@end deftypemethod\n+@deftypemethod Applet {public void} resize (int@w{ }@var{width}, int@w{ }@var{height}) \n+Requests that the applet window for this applet be resized.\n+@end deftypemethod\n+@deftypemethod Applet {public void} resize (java.awt.Dimension@w{ }@var{dim}) \n+Requests that the applet window for this applet be resized.\n+@end deftypemethod\n+@deftypemethod Applet {public AudioClip} getAudioClip (java.net.URL@w{ }@var{url}) \n+Returns an audio clip from the specified URL.\n+@end deftypemethod\n+@deftypemethod Applet {public AudioClip} getAudioClip (java.net.URL@w{ }@var{url}, java.lang.String@w{ }@var{name}) \n+Returns an audio clip from the specified URL and name\n+@end deftypemethod\n+@deftypemethod Applet {public void} play (java.net.URL@w{ }@var{url}) \n+Loads and plays the audio clip pointed to by the specified URL.\n+@end deftypemethod\n+@deftypemethod Applet {public void} play (java.net.URL@w{ }@var{url}, java.lang.String@w{ }@var{name}) \n+Loads and plays the audio clip pointed to by the specified URL.\n+@end deftypemethod\n+@deftypemethod Applet {public Image} getImage (java.net.URL@w{ }@var{url}) \n+Returns an image from the specified URL.  Note that the image is not\n+ actually retrieved until the applet attempts to display it, so this\n+ method returns immediately.\n+@end deftypemethod\n+@deftypemethod Applet {public Image} getImage (java.net.URL@w{ }@var{url}, java.lang.String@w{ }@var{name}) \n+Returns an image from the specified URL.  Note that the image is not\n+ actually retrieved until the applet attempts to display it, so this\n+ method returns immediately.\n+@end deftypemethod\n+@deftypemethod Applet {public Locale} getLocale () \n+Returns the locale for this applet, if it has been set.  If no applet\n+ specific locale has been set, the default locale is returned.\n+@end deftypemethod\n+@deftypemethod Applet {public String} getAppletInfo () \n+Returns a descriptive string with applet defined information.  The\n+ implementation in this class returns @code{null}.  Applets who\n+ wish to return this information should override.\n+@end deftypemethod\n+@deftypemethod Applet {public String} getParameterInfo () \n+Returns a list of parameters this applet supports.  Each element of\n+ the array is a list of three strings with the name of the parameter,\n+ the data type or valid values, and a description.  This method is\n+ optional and the default implementation returns @code{null}.\n+@end deftypemethod\n+@deftypemethod Applet {public void} init () \n+This method is called when the applet is first loaded.  The default\n+ implementation does nothing.  Applets that wish to do one time\n+ initialization should override.\n+@end deftypemethod\n+@deftypemethod Applet {public void} destroy () \n+This method is called when the applet is being unloaded.  The default\n+ implementation does nothing.  Applets that need to clean up resources\n+ on exit should override.\n+@end deftypemethod\n+@deftypemethod Applet {public void} start () \n+This method is called when the applet should start running.  This is\n+ normally each time a web page containing it is loaded.  The default\n+ implemention does nothing.  Subclasses should override.\n+@end deftypemethod\n+@deftypemethod Applet {public void} stop () \n+This method is called when the applet should stop running.  This is\n+ normally when the next web page is loaded.  The default implementation\n+ does nothing.\n+@end deftypemethod\n+@deftypemethod Applet {public final void} setStub (java.applet.AppletStub@w{ }@var{stub}) \n+The browser calls this method to set the applet's stub, which is the\n+ low level interface to the browser.\n+@end deftypemethod\n+@deftypemethod AppletStub {public URL} getDocumentBase () \n+Returns the URL of the document this applet is embedded in.\n+@end deftypemethod\n+@deftypemethod AppletStub {public URL} getCodeBase () \n+Returns the URL of the code base for this applet.\n+@end deftypemethod\n+@deftypemethod AppletStub {public String} getParameter (java.lang.String@w{ }@var{name}) \n+Returns the value of the specified parameter that was specified in \n+ the &lt;APPLET&gt; tag for this applet.\n+@end deftypemethod\n+@deftypemethod AppletStub {public AppletContext} getAppletContext () \n+Returns the applet context for this applet.\n+@end deftypemethod\n+@deftypemethod AppletStub {public boolean} isActive () \n+Tests whether or not this applet is currently active.\n+@end deftypemethod\n+@deftypemethod AppletStub {public void} appletResize (int@w{ }@var{width}, int@w{ }@var{height}) \n+Requests that the applet window for this applet be resized.\n+@end deftypemethod\n+@deftypemethod AudioClip {public void} play () \n+Plays the audio clip starting from the beginning.\n+@end deftypemethod\n+@deftypemethod AudioClip {public void} stop () \n+Stops playing this audio clip.  There is no mechanism for restarting\n+ at the point where the clip is stopped.\n+@end deftypemethod\n+@deftypemethod AudioClip {public void} loop () \n+Plays this audio clip in a continuous loop.\n+@end deftypemethod"}, {"sha": "266810784af27938a19899c4d9a474ab489fab92", "filename": "libjava/doc/java-awt-color.texi", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2Fdoc%2Fjava-awt-color.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2Fdoc%2Fjava-awt-color.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fdoc%2Fjava-awt-color.texi?ref=6a9d31a7d48bbae78a24a1395199d5c4c048d642", "patch": "@@ -0,0 +1,48 @@\n+@deftypemethod ColorSpace {public static ColorSpace} getInstance (int@w{ }@var{colorspace}) \n+\n+@end deftypemethod\n+@deftypemethod ColorSpace {public boolean} isCS_sRGB () \n+\n+@end deftypemethod\n+@deftypemethod ColorSpace {public abstract float} toRGB (float[]@w{ }@var{colorvalue}) \n+\n+@end deftypemethod\n+@deftypemethod ColorSpace {public abstract float} fromRGB (float[]@w{ }@var{rgbvalue}) \n+\n+@end deftypemethod\n+@deftypemethod ColorSpace {public abstract float} toCIEXYZ (float[]@w{ }@var{colorvalue}) \n+\n+@end deftypemethod\n+@deftypemethod ColorSpace {public abstract float} fromCIEXYZ (float[]@w{ }@var{colorvalue}) \n+\n+@end deftypemethod\n+@deftypemethod ColorSpace {public int} getType () \n+\n+@end deftypemethod\n+@deftypemethod ColorSpace {public int} getNumComponents () \n+\n+@end deftypemethod\n+@deftypemethod ColorSpace {public String} getName (int@w{ }@var{idx}) \n+\n+@end deftypemethod\n+@deftypemethod ColorSpace {public String} toString () \n+\n+@end deftypemethod\n+@deftypemethod ICC_ColorSpace {public ICC_Profile} getProfile () \n+\n+@end deftypemethod\n+@deftypemethod ICC_ColorSpace {public float} toRGB (float[]@w{ }@var{colorvalue}) \n+\n+@end deftypemethod\n+@deftypemethod ICC_ColorSpace {public float} fromRGB (float[]@w{ }@var{rgbvalue}) \n+\n+@end deftypemethod\n+@deftypemethod ICC_ColorSpace {public float} toCIEXYZ (float[]@w{ }@var{colorvalue}) \n+\n+@end deftypemethod\n+@deftypemethod ICC_ColorSpace {public float} fromCIEXYZ (float[]@w{ }@var{colorvalue}) \n+\n+@end deftypemethod\n+@deftypemethod ICC_Profile {public int} getNumComponents () \n+\n+@end deftypemethod"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "libjava/doc/java-awt-datatransfer.texi", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2Fdoc%2Fjava-awt-datatransfer.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2Fdoc%2Fjava-awt-datatransfer.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fdoc%2Fjava-awt-datatransfer.texi?ref=6a9d31a7d48bbae78a24a1395199d5c4c048d642"}, {"sha": "e1acf0d3d861638824040c26d31878e521e8ebab", "filename": "libjava/doc/java-awt-event.texi", "status": "added", "additions": 357, "deletions": 0, "changes": 357, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2Fdoc%2Fjava-awt-event.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2Fdoc%2Fjava-awt-event.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fdoc%2Fjava-awt-event.texi?ref=6a9d31a7d48bbae78a24a1395199d5c4c048d642", "patch": "@@ -0,0 +1,357 @@\n+@deftypemethod ActionEvent {public String} getActionCommand () \n+\n+@end deftypemethod\n+@deftypemethod ActionEvent {public int} getModifiers () \n+\n+@end deftypemethod\n+@deftypemethod ActionEvent {public String} paramString () \n+\n+@end deftypemethod\n+@deftypemethod ActionListener {public void} actionPerformed (java.awt.event.ActionEvent@w{ }@var{e}) \n+\n+@end deftypemethod\n+@deftypemethod AdjustmentEvent {public Adjustable} getAdjustable () \n+\n+@end deftypemethod\n+@deftypemethod AdjustmentEvent {public int} getAdjustmentType () \n+\n+@end deftypemethod\n+@deftypemethod AdjustmentEvent {public int} getValue () \n+\n+@end deftypemethod\n+@deftypemethod AdjustmentEvent {public String} paramString () \n+\n+@end deftypemethod\n+@deftypemethod AdjustmentListener {public void} adjustmentValueChanged (java.awt.event.AdjustmentEvent@w{ }@var{e}) \n+\n+@end deftypemethod\n+@deftypemethod AWTEventListener {public void} eventDispatched (java.awt.AWTEvent@w{ }@var{e}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentAdapter {public void} componentHidden (java.awt.event.ComponentEvent@w{ }@var{e}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentAdapter {public void} componentMoved (java.awt.event.ComponentEvent@w{ }@var{e}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentAdapter {public void} componentResized (java.awt.event.ComponentEvent@w{ }@var{e}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentAdapter {public void} componentShown (java.awt.event.ComponentEvent@w{ }@var{e}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentEvent {public Component} getComponent () \n+\n+@end deftypemethod\n+@deftypemethod ComponentEvent {public String} paramString () \n+\n+@end deftypemethod\n+@deftypemethod ComponentListener {public void} componentHidden (java.awt.event.ComponentEvent@w{ }@var{e}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentListener {public void} componentMoved (java.awt.event.ComponentEvent@w{ }@var{e}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentListener {public void} componentResized (java.awt.event.ComponentEvent@w{ }@var{e}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentListener {public void} componentShown (java.awt.event.ComponentEvent@w{ }@var{e}) \n+\n+@end deftypemethod\n+@deftypemethod ContainerAdapter {public void} componentAdded (java.awt.event.ContainerEvent@w{ }@var{e}) \n+\n+@end deftypemethod\n+@deftypemethod ContainerAdapter {public void} componentRemoved (java.awt.event.ContainerEvent@w{ }@var{e}) \n+\n+@end deftypemethod\n+@deftypemethod ContainerEvent {public Component} getChild () \n+\n+@end deftypemethod\n+@deftypemethod ContainerEvent {public Component} getContainer () \n+\n+@end deftypemethod\n+@deftypemethod ContainerEvent {public String} paramString () \n+\n+@end deftypemethod\n+@deftypemethod ContainerListener {public void} componentAdded (java.awt.event.ContainerEvent@w{ }@var{e}) \n+\n+@end deftypemethod\n+@deftypemethod ContainerListener {public void} componentRemoved (java.awt.event.ContainerEvent@w{ }@var{e}) \n+\n+@end deftypemethod\n+@deftypemethod FocusAdapter {public void} focusGained (java.awt.event.FocusEvent@w{ }@var{e}) \n+\n+@end deftypemethod\n+@deftypemethod FocusAdapter {public void} focusLost (java.awt.event.FocusEvent@w{ }@var{e}) \n+\n+@end deftypemethod\n+@deftypemethod FocusEvent {public boolean} isTemporary () \n+\n+@end deftypemethod\n+@deftypemethod FocusEvent {public String} paramString () \n+\n+@end deftypemethod\n+@deftypemethod FocusListener {public void} focusGained (java.awt.event.FocusEvent@w{ }@var{e}) \n+\n+@end deftypemethod\n+@deftypemethod FocusListener {public void} focusLost (java.awt.event.FocusEvent@w{ }@var{e}) \n+\n+@end deftypemethod\n+@deftypemethod HierarchyBoundsAdapter {public void} ancestorMoved (java.awt.event.HierarchyEvent@w{ }@var{e}) \n+\n+@end deftypemethod\n+@deftypemethod HierarchyBoundsAdapter {public void} ancestorResized (java.awt.event.HierarchyEvent@w{ }@var{e}) \n+\n+@end deftypemethod\n+@deftypemethod HierarchyBoundsListener {public void} ancestorMoved (java.awt.event.HierarchyEvent@w{ }@var{e}) \n+\n+@end deftypemethod\n+@deftypemethod HierarchyBoundsListener {public void} ancestorResized (java.awt.event.HierarchyEvent@w{ }@var{e}) \n+\n+@end deftypemethod\n+@deftypemethod HierarchyEvent {public Component} getComponent () \n+\n+@end deftypemethod\n+@deftypemethod HierarchyEvent {public Component} getChanged () \n+\n+@end deftypemethod\n+@deftypemethod HierarchyEvent {public Container} getChangedParent () \n+\n+@end deftypemethod\n+@deftypemethod HierarchyEvent {public long} getChangeFlags () \n+\n+@end deftypemethod\n+@deftypemethod HierarchyEvent {public String} paramString () \n+\n+@end deftypemethod\n+@deftypemethod HierarchyListener {public void} hierarchyChanged (java.awt.event.HierarchyEvent@w{ }@var{e}) \n+\n+@end deftypemethod\n+@deftypemethod InputEvent {public boolean} isShiftDown () \n+\n+@end deftypemethod\n+@deftypemethod InputEvent {public boolean} isControlDown () \n+\n+@end deftypemethod\n+@deftypemethod InputEvent {public boolean} isMetaDown () \n+\n+@end deftypemethod\n+@deftypemethod InputEvent {public boolean} isAltDown () \n+\n+@end deftypemethod\n+@deftypemethod InputEvent {public boolean} isAltGraphDown () \n+\n+@end deftypemethod\n+@deftypemethod InputEvent {public long} getWhen () \n+\n+@end deftypemethod\n+@deftypemethod InputEvent {public int} getModifiers () \n+\n+@end deftypemethod\n+@deftypemethod InputEvent {public boolean} isConsumed () \n+\n+@end deftypemethod\n+@deftypemethod InputEvent {public void} consume () \n+\n+@end deftypemethod\n+@deftypemethod InputMethodListener {public void} caretPositionChanged (java.awt.event.InputMethodEvent@w{ }@var{e}) \n+\n+@end deftypemethod\n+@deftypemethod InputMethodListener {public void} inputMethodTextChanged (java.awt.event.InputMethodEvent@w{ }@var{e}) \n+\n+@end deftypemethod\n+@deftypemethod InvocationEvent {public void} dispatch () \n+\n+@end deftypemethod\n+@deftypemethod InvocationEvent {public Exception} getException () \n+\n+@end deftypemethod\n+@deftypemethod InvocationEvent {public String} paramString () \n+\n+@end deftypemethod\n+@deftypemethod ItemEvent {public Object} getItem () \n+\n+@end deftypemethod\n+@deftypemethod ItemEvent {public ItemSelectable} getItemSelectable () \n+\n+@end deftypemethod\n+@deftypemethod ItemEvent {public int} getStateChange () \n+\n+@end deftypemethod\n+@deftypemethod ItemEvent {public String} paramString () \n+\n+@end deftypemethod\n+@deftypemethod ItemListener {public void} itemStateChanged (java.awt.event.ItemEvent@w{ }@var{e}) \n+\n+@end deftypemethod\n+@deftypemethod KeyAdapter {public void} keyPressed (java.awt.event.KeyEvent@w{ }@var{w}) \n+\n+@end deftypemethod\n+@deftypemethod KeyAdapter {public void} keyReleased (java.awt.event.KeyEvent@w{ }@var{w}) \n+\n+@end deftypemethod\n+@deftypemethod KeyAdapter {public void} keyTyped (java.awt.event.KeyEvent@w{ }@var{w}) \n+\n+@end deftypemethod\n+@deftypemethod KeyEvent {public int} getKeyCode () \n+\n+@end deftypemethod\n+@deftypemethod KeyEvent {public char} getKeyChar () \n+\n+@end deftypemethod\n+@deftypemethod KeyEvent {public void} setKeyCode (int@w{ }@var{keyCode}) \n+\n+@end deftypemethod\n+@deftypemethod KeyEvent {public void} setKeyChar (char@w{ }@var{keyChar}) \n+\n+@end deftypemethod\n+@deftypemethod KeyEvent {public void} setModifiers (int@w{ }@var{modifiers}) \n+\n+@end deftypemethod\n+@deftypemethod KeyEvent {public static String} getKeyText (int@w{ }@var{keyCode}) \n+\n+@end deftypemethod\n+@deftypemethod KeyEvent {public static String} getKeyModifiersText (int@w{ }@var{modifiers}) \n+\n+@end deftypemethod\n+@deftypemethod KeyEvent {public boolean} isActionKey () \n+\n+@end deftypemethod\n+@deftypemethod KeyEvent {public String} paramString () \n+\n+@end deftypemethod\n+@deftypemethod KeyListener {public void} keyPressed (java.awt.event.KeyEvent@w{ }@var{w}) \n+\n+@end deftypemethod\n+@deftypemethod KeyListener {public void} keyReleased (java.awt.event.KeyEvent@w{ }@var{w}) \n+\n+@end deftypemethod\n+@deftypemethod KeyListener {public void} keyTyped (java.awt.event.KeyEvent@w{ }@var{w}) \n+\n+@end deftypemethod\n+@deftypemethod MouseAdapter {public void} mouseClicked (java.awt.event.MouseEvent@w{ }@var{e}) \n+\n+@end deftypemethod\n+@deftypemethod MouseAdapter {public void} mouseEntered (java.awt.event.MouseEvent@w{ }@var{e}) \n+\n+@end deftypemethod\n+@deftypemethod MouseAdapter {public void} mouseExited (java.awt.event.MouseEvent@w{ }@var{e}) \n+\n+@end deftypemethod\n+@deftypemethod MouseAdapter {public void} mousePressed (java.awt.event.MouseEvent@w{ }@var{e}) \n+\n+@end deftypemethod\n+@deftypemethod MouseAdapter {public void} mouseReleased (java.awt.event.MouseEvent@w{ }@var{e}) \n+\n+@end deftypemethod\n+@deftypemethod MouseEvent {public int} getClickCount () \n+\n+@end deftypemethod\n+@deftypemethod MouseEvent {public Point} getPoint () \n+\n+@end deftypemethod\n+@deftypemethod MouseEvent {public int} getX () \n+\n+@end deftypemethod\n+@deftypemethod MouseEvent {public int} getY () \n+\n+@end deftypemethod\n+@deftypemethod MouseEvent {public boolean} isPopupTrigger () \n+\n+@end deftypemethod\n+@deftypemethod MouseEvent {public String} paramString () \n+\n+@end deftypemethod\n+@deftypemethod MouseEvent {public void} translatePoint (int@w{ }@var{x}, int@w{ }@var{y}) \n+\n+@end deftypemethod\n+@deftypemethod MouseListener {public void} mouseClicked (java.awt.event.MouseEvent@w{ }@var{e}) \n+\n+@end deftypemethod\n+@deftypemethod MouseListener {public void} mouseEntered (java.awt.event.MouseEvent@w{ }@var{e}) \n+\n+@end deftypemethod\n+@deftypemethod MouseListener {public void} mouseExited (java.awt.event.MouseEvent@w{ }@var{e}) \n+\n+@end deftypemethod\n+@deftypemethod MouseListener {public void} mousePressed (java.awt.event.MouseEvent@w{ }@var{e}) \n+\n+@end deftypemethod\n+@deftypemethod MouseListener {public void} mouseReleased (java.awt.event.MouseEvent@w{ }@var{e}) \n+\n+@end deftypemethod\n+@deftypemethod MouseMotionAdapter {public void} mouseDragged (java.awt.event.MouseEvent@w{ }@var{e}) \n+\n+@end deftypemethod\n+@deftypemethod MouseMotionAdapter {public void} mouseMoved (java.awt.event.MouseEvent@w{ }@var{e}) \n+\n+@end deftypemethod\n+@deftypemethod MouseMotionListener {public void} mouseDragged (java.awt.event.MouseEvent@w{ }@var{e}) \n+\n+@end deftypemethod\n+@deftypemethod MouseMotionListener {public void} mouseMoved (java.awt.event.MouseEvent@w{ }@var{e}) \n+\n+@end deftypemethod\n+@deftypemethod PaintEvent {public Rectangle} getUpdateRect () \n+\n+@end deftypemethod\n+@deftypemethod PaintEvent {public String} paramString () \n+\n+@end deftypemethod\n+@deftypemethod PaintEvent {public void} setUpdateRect (java.awt.Rectangle@w{ }@var{updateRect}) \n+\n+@end deftypemethod\n+@deftypemethod TextEvent {public String} paramString () \n+\n+@end deftypemethod\n+@deftypemethod TextListener {public void} textValueChanged (java.awt.event.TextEvent@w{ }@var{w}) \n+\n+@end deftypemethod\n+@deftypemethod WindowAdapter {public void} windowActivated (java.awt.event.WindowEvent@w{ }@var{w}) \n+\n+@end deftypemethod\n+@deftypemethod WindowAdapter {public void} windowClosed (java.awt.event.WindowEvent@w{ }@var{w}) \n+\n+@end deftypemethod\n+@deftypemethod WindowAdapter {public void} windowClosing (java.awt.event.WindowEvent@w{ }@var{w}) \n+\n+@end deftypemethod\n+@deftypemethod WindowAdapter {public void} windowDeactivated (java.awt.event.WindowEvent@w{ }@var{w}) \n+\n+@end deftypemethod\n+@deftypemethod WindowAdapter {public void} windowDeiconified (java.awt.event.WindowEvent@w{ }@var{w}) \n+\n+@end deftypemethod\n+@deftypemethod WindowAdapter {public void} windowIconified (java.awt.event.WindowEvent@w{ }@var{w}) \n+\n+@end deftypemethod\n+@deftypemethod WindowAdapter {public void} windowOpened (java.awt.event.WindowEvent@w{ }@var{w}) \n+\n+@end deftypemethod\n+@deftypemethod WindowEvent {public Window} getWindow () \n+\n+@end deftypemethod\n+@deftypemethod WindowEvent {public String} paramString () \n+\n+@end deftypemethod\n+@deftypemethod WindowListener {public void} windowActivated (java.awt.event.WindowEvent@w{ }@var{w}) \n+\n+@end deftypemethod\n+@deftypemethod WindowListener {public void} windowClosed (java.awt.event.WindowEvent@w{ }@var{w}) \n+\n+@end deftypemethod\n+@deftypemethod WindowListener {public void} windowClosing (java.awt.event.WindowEvent@w{ }@var{w}) \n+\n+@end deftypemethod\n+@deftypemethod WindowListener {public void} windowDeactivated (java.awt.event.WindowEvent@w{ }@var{w}) \n+\n+@end deftypemethod\n+@deftypemethod WindowListener {public void} windowDeiconified (java.awt.event.WindowEvent@w{ }@var{w}) \n+\n+@end deftypemethod\n+@deftypemethod WindowListener {public void} windowIconified (java.awt.event.WindowEvent@w{ }@var{w}) \n+\n+@end deftypemethod\n+@deftypemethod WindowListener {public void} windowOpened (java.awt.event.WindowEvent@w{ }@var{w}) \n+\n+@end deftypemethod"}, {"sha": "1913fd0accd6e4d8d2c8f5179327d98ad0a7428d", "filename": "libjava/doc/java-awt-geom.texi", "status": "added", "additions": 576, "deletions": 0, "changes": 576, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2Fdoc%2Fjava-awt-geom.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2Fdoc%2Fjava-awt-geom.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fdoc%2Fjava-awt-geom.texi?ref=6a9d31a7d48bbae78a24a1395199d5c4c048d642", "patch": "@@ -0,0 +1,576 @@\n+@deftypemethod AffineTransform {public static AffineTransform} getTranslateInstance (double@w{ }@var{tx}, double@w{ }@var{ty}) \n+\n+@end deftypemethod\n+@deftypemethod AffineTransform {public static AffineTransform} getRotateInstance (double@w{ }@var{theta}) \n+\n+@end deftypemethod\n+@deftypemethod AffineTransform {public static AffineTransform} getRotateInstance (double@w{ }@var{theta}, double@w{ }@var{x}, double@w{ }@var{y}) \n+\n+@end deftypemethod\n+@deftypemethod AffineTransform {public static AffineTransform} getScaleInstance (double@w{ }@var{sx}, double@w{ }@var{sy}) \n+\n+@end deftypemethod\n+@deftypemethod AffineTransform {public static AffineTransform} getShearInstance (double@w{ }@var{shx}, double@w{ }@var{shy}) \n+\n+@end deftypemethod\n+@deftypemethod AffineTransform {public int} getType () \n+\n+@end deftypemethod\n+@deftypemethod AffineTransform {public double} getDeterminant () \n+\n+@end deftypemethod\n+@deftypemethod AffineTransform {public void} getMatrix (double[]@w{ }@var{flatmatrix}) \n+\n+@end deftypemethod\n+@deftypemethod AffineTransform {public double} getScaleX () \n+\n+@end deftypemethod\n+@deftypemethod AffineTransform {public double} getScaleY () \n+\n+@end deftypemethod\n+@deftypemethod AffineTransform {public double} getShearX () \n+\n+@end deftypemethod\n+@deftypemethod AffineTransform {public double} getShearY () \n+\n+@end deftypemethod\n+@deftypemethod AffineTransform {public double} getTranslateX () \n+\n+@end deftypemethod\n+@deftypemethod AffineTransform {public double} getTranslateY () \n+\n+@end deftypemethod\n+@deftypemethod AffineTransform {public void} translate (double@w{ }@var{tx}, double@w{ }@var{ty}) \n+\n+@end deftypemethod\n+@deftypemethod AffineTransform {public void} rotate (double@w{ }@var{theta}) \n+\n+@end deftypemethod\n+@deftypemethod AffineTransform {public void} rotate (double@w{ }@var{theta}, double@w{ }@var{x}, double@w{ }@var{y}) \n+\n+@end deftypemethod\n+@deftypemethod AffineTransform {public void} scale (double@w{ }@var{sx}, double@w{ }@var{sy}) \n+\n+@end deftypemethod\n+@deftypemethod AffineTransform {public void} shear (double@w{ }@var{shx}, double@w{ }@var{shy}) \n+\n+@end deftypemethod\n+@deftypemethod AffineTransform {public void} setToIdentity () \n+\n+@end deftypemethod\n+@deftypemethod AffineTransform {public void} setToTranslation (double@w{ }@var{tx}, double@w{ }@var{ty}) \n+\n+@end deftypemethod\n+@deftypemethod AffineTransform {public void} setToRotation (double@w{ }@var{theta}) \n+\n+@end deftypemethod\n+@deftypemethod AffineTransform {public void} setToScale (double@w{ }@var{sx}, double@w{ }@var{sy}) \n+\n+@end deftypemethod\n+@deftypemethod AffineTransform {public void} setToShear (double@w{ }@var{shx}, double@w{ }@var{shy}) \n+\n+@end deftypemethod\n+@deftypemethod AffineTransform {public void} setTransform (java.awt.geom.AffineTransform@w{ }@var{tx}) \n+\n+@end deftypemethod\n+@deftypemethod AffineTransform {public void} setTransform (double@w{ }@var{m00}, double@w{ }@var{m10}, double@w{ }@var{m01}, double@w{ }@var{m11}, double@w{ }@var{m02}, double@w{ }@var{m12}) \n+\n+@end deftypemethod\n+@deftypemethod AffineTransform {public void} concatenate (java.awt.geom.AffineTransform@w{ }@var{tx}) \n+\n+@end deftypemethod\n+@deftypemethod AffineTransform {public void} preConcatenate (java.awt.geom.AffineTransform@w{ }@var{tx}) \n+\n+@end deftypemethod\n+@deftypemethod AffineTransform {public AffineTransform} createInverse () @*throws NoninvertibleTransformException\n+\n+@end deftypemethod\n+@deftypemethod AffineTransform {public Point2D} transform (java.awt.geom.Point2D@w{ }@var{src}, java.awt.geom.Point2D@w{ }@var{dst}) \n+\n+@end deftypemethod\n+@deftypemethod AffineTransform {public void} transform (java.awt.geom.Point2D[]@w{ }@var{src}, int@w{ }@var{srcOff}, java.awt.geom.Point2D[]@w{ }@var{dst}, int@w{ }@var{dstOff}, int@w{ }@var{num}) \n+\n+@end deftypemethod\n+@deftypemethod AffineTransform {public void} transform (float[]@w{ }@var{srcPts}, int@w{ }@var{srcOff}, float[]@w{ }@var{dstPts}, int@w{ }@var{dstOff}, int@w{ }@var{num}) \n+\n+@end deftypemethod\n+@deftypemethod AffineTransform {public void} transform (double[]@w{ }@var{srcPts}, int@w{ }@var{srcOff}, double[]@w{ }@var{dstPts}, int@w{ }@var{dstOff}, int@w{ }@var{num}) \n+\n+@end deftypemethod\n+@deftypemethod AffineTransform {public void} transform (float[]@w{ }@var{srcPts}, int@w{ }@var{srcOff}, double[]@w{ }@var{dstPts}, int@w{ }@var{dstOff}, int@w{ }@var{num}) \n+\n+@end deftypemethod\n+@deftypemethod AffineTransform {public void} transform (double[]@w{ }@var{srcPts}, int@w{ }@var{srcOff}, float[]@w{ }@var{dstPts}, int@w{ }@var{dstOff}, int@w{ }@var{num}) \n+\n+@end deftypemethod\n+@deftypemethod AffineTransform {public Point2D} inverseTransform (java.awt.geom.Point2D@w{ }@var{src}, java.awt.geom.Point2D@w{ }@var{dst}) @*throws NoninvertibleTransformException\n+\n+@end deftypemethod\n+@deftypemethod AffineTransform {public void} inverseTransform (double[]@w{ }@var{srcPts}, int@w{ }@var{srcOff}, double[]@w{ }@var{dstPts}, int@w{ }@var{dstOff}, int@w{ }@var{num}) @*throws NoninvertibleTransformException\n+\n+@end deftypemethod\n+@deftypemethod AffineTransform {public Point2D} deltaTransform (java.awt.geom.Point2D@w{ }@var{src}, java.awt.geom.Point2D@w{ }@var{dst}) \n+\n+@end deftypemethod\n+@deftypemethod AffineTransform {public void} deltaTransform (double[]@w{ }@var{srcPts}, int@w{ }@var{srcOff}, double[]@w{ }@var{dstPts}, int@w{ }@var{dstOff}, int@w{ }@var{num}) \n+\n+@end deftypemethod\n+@deftypemethod AffineTransform {public Shape} createTransformedShape (java.awt.Shape@w{ }@var{pSrc}) \n+\n+@end deftypemethod\n+@deftypemethod AffineTransform {public String} toString () \n+\n+@end deftypemethod\n+@deftypemethod AffineTransform {public boolean} isIdentity () \n+\n+@end deftypemethod\n+@deftypemethod AffineTransform {public Object} clone () \n+\n+@end deftypemethod\n+@deftypemethod AffineTransform {public int} hashCode () \n+\n+@end deftypemethod\n+@deftypemethod AffineTransform {public boolean} equals (java.lang.Object@w{ }@var{obj}) \n+\n+@end deftypemethod\n+@deftypemethod Dimension2D {public abstract double} getWidth () \n+\n+@end deftypemethod\n+@deftypemethod Dimension2D {public abstract double} getHeight () \n+\n+@end deftypemethod\n+@deftypemethod Dimension2D {public abstract void} setSize (double@w{ }@var{width}, double@w{ }@var{height}) \n+\n+@end deftypemethod\n+@deftypemethod Dimension2D {public void} setSize (java.awt.geom.Dimension2D@w{ }@var{dim}) \n+\n+@end deftypemethod\n+@deftypemethod Dimension2D {public Object} clone () \n+\n+@end deftypemethod\n+@deftypemethod Ellipse2D {public boolean} contains (double@w{ }@var{x}, double@w{ }@var{y}) \n+\n+@end deftypemethod\n+@deftypemethod Ellipse2D {public boolean} contains (double@w{ }@var{x}, double@w{ }@var{y}, double@w{ }@var{w}, double@w{ }@var{h}) \n+\n+@end deftypemethod\n+@deftypemethod Ellipse2D {public PathIterator} getPathIterator (java.awt.geom.AffineTransform@w{ }@var{at}) \n+\n+@end deftypemethod\n+@deftypemethod Ellipse2D {public boolean} intersects (double@w{ }@var{x}, double@w{ }@var{y}, double@w{ }@var{w}, double@w{ }@var{h}) \n+\n+@end deftypemethod\n+@deftypemethod Ellipse2D.Double {public Rectangle2D} getBounds2D () \n+\n+@end deftypemethod\n+@deftypemethod Ellipse2D.Double {public double} getHeight () \n+\n+@end deftypemethod\n+@deftypemethod Ellipse2D.Double {public double} getWidth () \n+\n+@end deftypemethod\n+@deftypemethod Ellipse2D.Double {public double} getX () \n+\n+@end deftypemethod\n+@deftypemethod Ellipse2D.Double {public double} getY () \n+\n+@end deftypemethod\n+@deftypemethod Ellipse2D.Double {public boolean} isEmpty () \n+\n+@end deftypemethod\n+@deftypemethod Ellipse2D.Double {public void} setFrame (double@w{ }@var{x}, double@w{ }@var{y}, double@w{ }@var{w}, double@w{ }@var{h}) \n+\n+@end deftypemethod\n+@deftypemethod Ellipse2D.Float {public Rectangle2D} getBounds2D () \n+\n+@end deftypemethod\n+@deftypemethod Ellipse2D.Float {public double} getHeight () \n+\n+@end deftypemethod\n+@deftypemethod Ellipse2D.Float {public double} getWidth () \n+\n+@end deftypemethod\n+@deftypemethod Ellipse2D.Float {public double} getX () \n+\n+@end deftypemethod\n+@deftypemethod Ellipse2D.Float {public double} getY () \n+\n+@end deftypemethod\n+@deftypemethod Ellipse2D.Float {public boolean} isEmpty () \n+\n+@end deftypemethod\n+@deftypemethod Ellipse2D.Float {public void} setFrame (float@w{ }@var{x}, float@w{ }@var{y}, float@w{ }@var{w}, float@w{ }@var{h}) \n+\n+@end deftypemethod\n+@deftypemethod Ellipse2D.Float {public void} setFrame (double@w{ }@var{x}, double@w{ }@var{y}, double@w{ }@var{w}, double@w{ }@var{h}) \n+\n+@end deftypemethod\n+@deftypemethod PathIterator {public int} currentSegment (double[]@w{ }@var{coords}) \n+\n+@end deftypemethod\n+@deftypemethod PathIterator {public int} currentSegment (float[]@w{ }@var{coords}) \n+\n+@end deftypemethod\n+@deftypemethod PathIterator {public int} getWindingRule () \n+\n+@end deftypemethod\n+@deftypemethod PathIterator {public boolean} isDone () \n+\n+@end deftypemethod\n+@deftypemethod PathIterator {public void} next () \n+\n+@end deftypemethod\n+@deftypemethod Point2D {public abstract double} getX () \n+\n+@end deftypemethod\n+@deftypemethod Point2D {public abstract double} getY () \n+\n+@end deftypemethod\n+@deftypemethod Point2D {public abstract void} setLocation (double@w{ }@var{x}, double@w{ }@var{y}) \n+\n+@end deftypemethod\n+@deftypemethod Point2D {public void} setLocation (java.awt.geom.Point2D@w{ }@var{pt}) \n+\n+@end deftypemethod\n+@deftypemethod Point2D {public static double} distanceSq (double@w{ }@var{X1}, double@w{ }@var{Y1}, double@w{ }@var{X2}, double@w{ }@var{Y2}) \n+\n+@end deftypemethod\n+@deftypemethod Point2D {public static double} distance (double@w{ }@var{X1}, double@w{ }@var{Y1}, double@w{ }@var{X2}, double@w{ }@var{Y2}) \n+\n+@end deftypemethod\n+@deftypemethod Point2D {public double} distanceSq (double@w{ }@var{PX}, double@w{ }@var{PY}) \n+\n+@end deftypemethod\n+@deftypemethod Point2D {public double} distance (double@w{ }@var{PX}, double@w{ }@var{PY}) \n+\n+@end deftypemethod\n+@deftypemethod Point2D {public double} distanceSq (java.awt.geom.Point2D@w{ }@var{pt}) \n+\n+@end deftypemethod\n+@deftypemethod Point2D {public double} distance (java.awt.geom.Point2D@w{ }@var{pt}) \n+\n+@end deftypemethod\n+@deftypemethod Point2D {public int} hashCode () \n+\n+@end deftypemethod\n+@deftypemethod Point2D {public Object} clone () \n+\n+@end deftypemethod\n+@deftypemethod Point2D {public boolean} equals (java.lang.Object@w{ }@var{o}) \n+\n+@end deftypemethod\n+@deftypemethod Point2D.Double {public double} getX () \n+\n+@end deftypemethod\n+@deftypemethod Point2D.Double {public double} getY () \n+\n+@end deftypemethod\n+@deftypemethod Point2D.Double {public void} setLocation (double@w{ }@var{x}, double@w{ }@var{y}) \n+\n+@end deftypemethod\n+@deftypemethod Point2D.Double {public String} toString () \n+\n+@end deftypemethod\n+@deftypemethod Point2D.Float {public double} getX () \n+\n+@end deftypemethod\n+@deftypemethod Point2D.Float {public double} getY () \n+\n+@end deftypemethod\n+@deftypemethod Point2D.Float {public void} setLocation (double@w{ }@var{x}, double@w{ }@var{y}) \n+\n+@end deftypemethod\n+@deftypemethod Point2D.Float {public void} setLocation (float@w{ }@var{x}, float@w{ }@var{y}) \n+\n+@end deftypemethod\n+@deftypemethod Point2D.Float {public String} toString () \n+\n+@end deftypemethod\n+@deftypemethod Rectangle2D {public abstract void} setRect (double@w{ }@var{x}, double@w{ }@var{y}, double@w{ }@var{w}, double@w{ }@var{h}) \n+Set the bounding box of this rectangle.\n+@end deftypemethod\n+@deftypemethod Rectangle2D {public void} setRect (java.awt.geom.Rectangle2D@w{ }@var{r}) \n+Set the bounding box of this rectangle.\n+@end deftypemethod\n+@deftypemethod Rectangle2D {public boolean} intersectsLine (double@w{ }@var{x1}, double@w{ }@var{y1}, double@w{ }@var{x2}, double@w{ }@var{y2}) \n+Returns true if line segment intersects interior of this\n+ rectangle.\n+@end deftypemethod\n+@deftypemethod Rectangle2D {public abstract int} outcode (double@w{ }@var{x}, double@w{ }@var{y}) \n+Return true if line segment intersects interior of this\n+ rectangle.\n+@end deftypemethod\n+@deftypemethod Rectangle2D {public int} outcode (java.awt.geom.Point2D@w{ }@var{p}) \n+\n+@end deftypemethod\n+@deftypemethod Rectangle2D {public void} setFrame (double@w{ }@var{x}, double@w{ }@var{y}, double@w{ }@var{w}, double@w{ }@var{h}) \n+Set bounding frame for this rectangle.\n+@end deftypemethod\n+@deftypemethod Rectangle2D {public Rectangle2D} getBounds2D () \n+\n+@end deftypemethod\n+@deftypemethod Rectangle2D {public boolean} contains (double@w{ }@var{x}, double@w{ }@var{y}) \n+\n+@end deftypemethod\n+@deftypemethod Rectangle2D {public boolean} intersects (double@w{ }@var{x}, double@w{ }@var{y}, double@w{ }@var{w}, double@w{ }@var{h}) \n+\n+@end deftypemethod\n+@deftypemethod Rectangle2D {public boolean} contains (double@w{ }@var{x}, double@w{ }@var{y}, double@w{ }@var{w}, double@w{ }@var{h}) \n+\n+@end deftypemethod\n+@deftypemethod Rectangle2D {public abstract Rectangle2D} createIntersection (java.awt.geom.Rectangle2D@w{ }@var{r}) \n+\n+@end deftypemethod\n+@deftypemethod Rectangle2D {public static void} intersect (java.awt.geom.Rectangle2D@w{ }@var{src1}, java.awt.geom.Rectangle2D@w{ }@var{src2}, java.awt.geom.Rectangle2D@w{ }@var{dest}) \n+\n+@end deftypemethod\n+@deftypemethod Rectangle2D {public abstract Rectangle2D} createUnion (java.awt.geom.Rectangle2D@w{ }@var{r}) \n+\n+@end deftypemethod\n+@deftypemethod Rectangle2D {public static void} union (java.awt.geom.Rectangle2D@w{ }@var{src1}, java.awt.geom.Rectangle2D@w{ }@var{src2}, java.awt.geom.Rectangle2D@w{ }@var{dest}) \n+\n+@end deftypemethod\n+@deftypemethod Rectangle2D {public void} add (double@w{ }@var{newx}, double@w{ }@var{newy}) \n+\n+@end deftypemethod\n+@deftypemethod Rectangle2D {public void} add (java.awt.geom.Point2D@w{ }@var{p}) \n+\n+@end deftypemethod\n+@deftypemethod Rectangle2D {public void} add (java.awt.geom.Rectangle2D@w{ }@var{r}) \n+\n+@end deftypemethod\n+@deftypemethod Rectangle2D {public PathIterator} getPathIterator (java.awt.geom.AffineTransform@w{ }@var{at}) \n+\n+@end deftypemethod\n+@deftypemethod Rectangle2D.Double {public double} getX () \n+\n+@end deftypemethod\n+@deftypemethod Rectangle2D.Double {public double} getY () \n+\n+@end deftypemethod\n+@deftypemethod Rectangle2D.Double {public double} getWidth () \n+\n+@end deftypemethod\n+@deftypemethod Rectangle2D.Double {public double} getHeight () \n+\n+@end deftypemethod\n+@deftypemethod Rectangle2D.Double {public boolean} isEmpty () \n+\n+@end deftypemethod\n+@deftypemethod Rectangle2D.Double {public void} setRect (double@w{ }@var{x}, double@w{ }@var{y}, double@w{ }@var{w}, double@w{ }@var{h}) \n+\n+@end deftypemethod\n+@deftypemethod Rectangle2D.Double {public void} setRect (java.awt.geom.Rectangle2D@w{ }@var{r}) \n+\n+@end deftypemethod\n+@deftypemethod Rectangle2D.Double {public int} outcode (double@w{ }@var{x}, double@w{ }@var{y}) \n+\n+@end deftypemethod\n+@deftypemethod Rectangle2D.Double {public Rectangle2D} getBounds2D () \n+\n+@end deftypemethod\n+@deftypemethod Rectangle2D.Double {public Rectangle2D} createIntersection (java.awt.geom.Rectangle2D@w{ }@var{r}) \n+\n+@end deftypemethod\n+@deftypemethod Rectangle2D.Double {public Rectangle2D} createUnion (java.awt.geom.Rectangle2D@w{ }@var{r}) \n+\n+@end deftypemethod\n+@deftypemethod Rectangle2D.Double {public String} toString () \n+\n+@end deftypemethod\n+@deftypemethod Rectangle2D.Float {public double} getX () \n+\n+@end deftypemethod\n+@deftypemethod Rectangle2D.Float {public double} getY () \n+\n+@end deftypemethod\n+@deftypemethod Rectangle2D.Float {public double} getWidth () \n+\n+@end deftypemethod\n+@deftypemethod Rectangle2D.Float {public double} getHeight () \n+\n+@end deftypemethod\n+@deftypemethod Rectangle2D.Float {public boolean} isEmpty () \n+\n+@end deftypemethod\n+@deftypemethod Rectangle2D.Float {public void} setRect (double@w{ }@var{x}, double@w{ }@var{y}, double@w{ }@var{w}, double@w{ }@var{h}) \n+\n+@end deftypemethod\n+@deftypemethod Rectangle2D.Float {public void} setRect (java.awt.geom.Rectangle2D@w{ }@var{r}) \n+\n+@end deftypemethod\n+@deftypemethod Rectangle2D.Float {public int} outcode (double@w{ }@var{x}, double@w{ }@var{y}) \n+\n+@end deftypemethod\n+@deftypemethod Rectangle2D.Float {public Rectangle2D} getBounds2D () \n+\n+@end deftypemethod\n+@deftypemethod Rectangle2D.Float {public Rectangle2D} createIntersection (java.awt.geom.Rectangle2D@w{ }@var{r}) \n+\n+@end deftypemethod\n+@deftypemethod Rectangle2D.Float {public Rectangle2D} createUnion (java.awt.geom.Rectangle2D@w{ }@var{r}) \n+\n+@end deftypemethod\n+@deftypemethod Rectangle2D.Float {public String} toString () \n+\n+@end deftypemethod\n+@deftypemethod RectangularShape {public abstract double} getX () \n+\n+@end deftypemethod\n+@deftypemethod RectangularShape {public abstract double} getY () \n+\n+@end deftypemethod\n+@deftypemethod RectangularShape {public abstract double} getWidth () \n+\n+@end deftypemethod\n+@deftypemethod RectangularShape {public abstract double} getHeight () \n+\n+@end deftypemethod\n+@deftypemethod RectangularShape {public double} getMinX () \n+\n+@end deftypemethod\n+@deftypemethod RectangularShape {public double} getMinY () \n+\n+@end deftypemethod\n+@deftypemethod RectangularShape {public double} getMaxX () \n+\n+@end deftypemethod\n+@deftypemethod RectangularShape {public double} getMaxY () \n+\n+@end deftypemethod\n+@deftypemethod RectangularShape {public double} getCenterX () \n+\n+@end deftypemethod\n+@deftypemethod RectangularShape {public double} getCenterY () \n+\n+@end deftypemethod\n+@deftypemethod RectangularShape {public Rectangle2D} getFrame () \n+\n+@end deftypemethod\n+@deftypemethod RectangularShape {public abstract boolean} isEmpty () \n+\n+@end deftypemethod\n+@deftypemethod RectangularShape {public abstract void} setFrame (double@w{ }@var{x}, double@w{ }@var{y}, double@w{ }@var{w}, double@w{ }@var{h}) \n+\n+@end deftypemethod\n+@deftypemethod RectangularShape {public void} setFrame (java.awt.geom.Point2D@w{ }@var{loc}, java.awt.geom.Dimension2D@w{ }@var{size}) \n+\n+@end deftypemethod\n+@deftypemethod RectangularShape {public void} setFrame (java.awt.geom.Rectangle2D@w{ }@var{r}) \n+\n+@end deftypemethod\n+@deftypemethod RectangularShape {public void} setFrameFromDiagonal (double@w{ }@var{x1}, double@w{ }@var{y1}, double@w{ }@var{x2}, double@w{ }@var{y2}) \n+\n+@end deftypemethod\n+@deftypemethod RectangularShape {public void} setFrameFromDiagonal (java.awt.geom.Point2D@w{ }@var{p1}, java.awt.geom.Point2D@w{ }@var{p2}) \n+\n+@end deftypemethod\n+@deftypemethod RectangularShape {public void} setFrameFromCenter (double@w{ }@var{centerX}, double@w{ }@var{centerY}, double@w{ }@var{cornerX}, double@w{ }@var{cornerY}) \n+\n+@end deftypemethod\n+@deftypemethod RectangularShape {public void} setFrameFromCenter (java.awt.geom.Point2D@w{ }@var{center}, java.awt.geom.Point2D@w{ }@var{corner}) \n+\n+@end deftypemethod\n+@deftypemethod RectangularShape {public boolean} contains (java.awt.geom.Point2D@w{ }@var{p}) \n+\n+@end deftypemethod\n+@deftypemethod RectangularShape {public boolean} intersects (java.awt.geom.Rectangle2D@w{ }@var{r}) \n+\n+@end deftypemethod\n+@deftypemethod RectangularShape {public boolean} contains (java.awt.geom.Rectangle2D@w{ }@var{r}) \n+\n+@end deftypemethod\n+@deftypemethod RectangularShape {public Rectangle} getBounds () \n+\n+@end deftypemethod\n+@deftypemethod RectangularShape {public PathIterator} getPathIterator (java.awt.geom.AffineTransform@w{ }@var{at}, double@w{ }@var{flatness}) \n+\n+@end deftypemethod\n+@deftypemethod RectangularShape {public Object} clone () \n+\n+@end deftypemethod\n+@deftypemethod RoundRectangle2D {public abstract double} getArcHeight () \n+Return the arc height of this round rectangle.\n+@end deftypemethod\n+@deftypemethod RoundRectangle2D {public abstract double} getArcWidth () \n+Return the arc width of this round rectangle.\n+@end deftypemethod\n+@deftypemethod RoundRectangle2D {public abstract void} setRoundRect (double@w{ }@var{x}, double@w{ }@var{y}, double@w{ }@var{w}, double@w{ }@var{h}, double@w{ }@var{arcWidth}, double@w{ }@var{arcHeight}) \n+Set the values of this round rectangle\n+@end deftypemethod\n+@deftypemethod RoundRectangle2D {public boolean} contains (double@w{ }@var{x}, double@w{ }@var{y}) \n+Return true if this object contains the specified point.\n+@end deftypemethod\n+@deftypemethod RoundRectangle2D {public boolean} contains (double@w{ }@var{x}, double@w{ }@var{y}, double@w{ }@var{w}, double@w{ }@var{h}) \n+Return true if this object contains the specified rectangle\n+@end deftypemethod\n+@deftypemethod RoundRectangle2D {public PathIterator} getPathIterator (java.awt.geom.AffineTransform@w{ }@var{at}) \n+Return a new path iterator which iterates over this rectangle.\n+@end deftypemethod\n+@deftypemethod RoundRectangle2D {public boolean} intersects (double@w{ }@var{x}, double@w{ }@var{y}, double@w{ }@var{w}, double@w{ }@var{h}) \n+Return true if the given rectangle intersects this shape.\n+@end deftypemethod\n+@deftypemethod RoundRectangle2D {public void} setFrame (double@w{ }@var{x}, double@w{ }@var{y}, double@w{ }@var{w}, double@w{ }@var{h}) \n+Set the boundary of this round rectangle.\n+@end deftypemethod\n+@deftypemethod RoundRectangle2D {public void} setRoundRect (java.awt.geom.RoundRectangle2D@w{ }@var{rr}) \n+Set the values of this round rectangle to be the same as those\n+ of the argument.\n+@end deftypemethod\n+@deftypemethod RoundRectangle2D.Float {public double} getArcHeight () \n+\n+@end deftypemethod\n+@deftypemethod RoundRectangle2D.Float {public double} getArcWidth () \n+\n+@end deftypemethod\n+@deftypemethod RoundRectangle2D.Float {public Rectangle2D} getBounds2D () \n+\n+@end deftypemethod\n+@deftypemethod RoundRectangle2D.Float {public double} getX () \n+\n+@end deftypemethod\n+@deftypemethod RoundRectangle2D.Float {public double} getY () \n+\n+@end deftypemethod\n+@deftypemethod RoundRectangle2D.Float {public double} getWidth () \n+\n+@end deftypemethod\n+@deftypemethod RoundRectangle2D.Float {public double} getHeight () \n+\n+@end deftypemethod\n+@deftypemethod RoundRectangle2D.Float {public boolean} isEmpty () \n+\n+@end deftypemethod\n+@deftypemethod RoundRectangle2D.Float {public void} setRoundRect (float@w{ }@var{x}, float@w{ }@var{y}, float@w{ }@var{w}, float@w{ }@var{h}, float@w{ }@var{arcWidth}, float@w{ }@var{arcHeight}) \n+\n+@end deftypemethod\n+@deftypemethod RoundRectangle2D.Float {public void} setRoundRect (double@w{ }@var{x}, double@w{ }@var{y}, double@w{ }@var{w}, double@w{ }@var{h}, double@w{ }@var{arcWidth}, double@w{ }@var{arcHeight}) \n+\n+@end deftypemethod\n+@deftypemethod RoundRectangle2D.Double {public double} getArcHeight () \n+\n+@end deftypemethod\n+@deftypemethod RoundRectangle2D.Double {public double} getArcWidth () \n+\n+@end deftypemethod\n+@deftypemethod RoundRectangle2D.Double {public Rectangle2D} getBounds2D () \n+\n+@end deftypemethod\n+@deftypemethod RoundRectangle2D.Double {public double} getX () \n+\n+@end deftypemethod\n+@deftypemethod RoundRectangle2D.Double {public double} getY () \n+\n+@end deftypemethod\n+@deftypemethod RoundRectangle2D.Double {public double} getWidth () \n+\n+@end deftypemethod\n+@deftypemethod RoundRectangle2D.Double {public double} getHeight () \n+\n+@end deftypemethod\n+@deftypemethod RoundRectangle2D.Double {public boolean} isEmpty () \n+\n+@end deftypemethod\n+@deftypemethod RoundRectangle2D.Double {public void} setRoundRect (double@w{ }@var{x}, double@w{ }@var{y}, double@w{ }@var{w}, double@w{ }@var{h}, double@w{ }@var{arcWidth}, double@w{ }@var{arcHeight}) \n+\n+@end deftypemethod"}, {"sha": "a658628376c2ec24bbabf407e8f2cce90f2b9fa6", "filename": "libjava/doc/java-awt-image.texi", "status": "added", "additions": 1149, "deletions": 0, "changes": 1149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2Fdoc%2Fjava-awt-image.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2Fdoc%2Fjava-awt-image.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fdoc%2Fjava-awt-image.texi?ref=6a9d31a7d48bbae78a24a1395199d5c4c048d642", "patch": "@@ -0,0 +1,1149 @@\n+@deftypemethod BufferedImage {public void} coerceData (boolean@w{ }@var{premultiplied}) \n+\n+@end deftypemethod\n+@deftypemethod BufferedImage {public WritableRaster} copyData (java.awt.image.WritableRaster@w{ }@var{dest}) \n+\n+@end deftypemethod\n+@deftypemethod BufferedImage {public Graphics2D} createGraphics () \n+\n+@end deftypemethod\n+@deftypemethod BufferedImage {public void} flush () \n+\n+@end deftypemethod\n+@deftypemethod BufferedImage {public WritableRaster} getAlphaRaster () \n+\n+@end deftypemethod\n+@deftypemethod BufferedImage {public ColorModel} getColorModel () \n+\n+@end deftypemethod\n+@deftypemethod BufferedImage {public Raster} getData () \n+\n+@end deftypemethod\n+@deftypemethod BufferedImage {public Raster} getData (java.awt.Rectangle@w{ }@var{rectangle}) \n+\n+@end deftypemethod\n+@deftypemethod BufferedImage {public Graphics} getGraphics () \n+\n+@end deftypemethod\n+@deftypemethod BufferedImage {public int} getHeight () \n+\n+@end deftypemethod\n+@deftypemethod BufferedImage {public int} getHeight (java.awt.image.ImageObserver@w{ }@var{imageobserver}) \n+\n+@end deftypemethod\n+@deftypemethod BufferedImage {public int} getMinTileX () \n+\n+@end deftypemethod\n+@deftypemethod BufferedImage {public int} getMinTileY () \n+\n+@end deftypemethod\n+@deftypemethod BufferedImage {public int} getMinX () \n+\n+@end deftypemethod\n+@deftypemethod BufferedImage {public int} getMinY () \n+\n+@end deftypemethod\n+@deftypemethod BufferedImage {public int} getNumXTiles () \n+\n+@end deftypemethod\n+@deftypemethod BufferedImage {public int} getNumYTiles () \n+\n+@end deftypemethod\n+@deftypemethod BufferedImage {public Object} getProperty (java.lang.String@w{ }@var{string}) \n+\n+@end deftypemethod\n+@deftypemethod BufferedImage {public Object} getProperty (java.lang.String@w{ }@var{string}, java.awt.image.ImageObserver@w{ }@var{imageobserver}) \n+\n+@end deftypemethod\n+@deftypemethod BufferedImage {public String} getPropertyNames () \n+\n+@end deftypemethod\n+@deftypemethod BufferedImage {public int} getRGB (int@w{ }@var{x}, int@w{ }@var{y}) \n+\n+@end deftypemethod\n+@deftypemethod BufferedImage {public int} getRGB (int@w{ }@var{startX}, int@w{ }@var{startY}, int@w{ }@var{w}, int@w{ }@var{h}, int[]@w{ }@var{rgbArray}, int@w{ }@var{offset}, int@w{ }@var{scanlineStride}) \n+\n+@end deftypemethod\n+@deftypemethod BufferedImage {public WritableRaster} getRaster () \n+\n+@end deftypemethod\n+@deftypemethod BufferedImage {public SampleModel} getSampleModel () \n+\n+@end deftypemethod\n+@deftypemethod BufferedImage {public ImageProducer} getSource () \n+\n+@end deftypemethod\n+@deftypemethod BufferedImage {public Vector} getSources () \n+\n+@end deftypemethod\n+@deftypemethod BufferedImage {public BufferedImage} getSubimage (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{w}, int@w{ }@var{h}) \n+\n+@end deftypemethod\n+@deftypemethod BufferedImage {public Raster} getTile (int@w{ }@var{tileX}, int@w{ }@var{tileY}) \n+\n+@end deftypemethod\n+@deftypemethod BufferedImage {public int} getTileGridXOffset () \n+\n+@end deftypemethod\n+@deftypemethod BufferedImage {public int} getTileGridYOffset () \n+\n+@end deftypemethod\n+@deftypemethod BufferedImage {public int} getTileHeight () \n+\n+@end deftypemethod\n+@deftypemethod BufferedImage {public int} getTileWidth () \n+\n+@end deftypemethod\n+@deftypemethod BufferedImage {public int} getType () \n+\n+@end deftypemethod\n+@deftypemethod BufferedImage {public int} getWidth () \n+\n+@end deftypemethod\n+@deftypemethod BufferedImage {public int} getWidth (java.awt.image.ImageObserver@w{ }@var{imageobserver}) \n+\n+@end deftypemethod\n+@deftypemethod BufferedImage {public WritableRaster} getWritableTile (int@w{ }@var{tileX}, int@w{ }@var{tileY}) \n+\n+@end deftypemethod\n+@deftypemethod BufferedImage {public Point} getWritableTileIndices () \n+\n+@end deftypemethod\n+@deftypemethod BufferedImage {public boolean} hasTileWriters () \n+\n+@end deftypemethod\n+@deftypemethod BufferedImage {public boolean} isAlphaPremultiplied () \n+\n+@end deftypemethod\n+@deftypemethod BufferedImage {public boolean} isTileWritable (int@w{ }@var{tileX}, int@w{ }@var{tileY}) \n+\n+@end deftypemethod\n+@deftypemethod BufferedImage {public void} releaseWritableTile (int@w{ }@var{tileX}, int@w{ }@var{tileY}) \n+\n+@end deftypemethod\n+@deftypemethod BufferedImage {public void} setData (java.awt.image.Raster@w{ }@var{src}) \n+\n+@end deftypemethod\n+@deftypemethod BufferedImage {public void} setRGB (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{argb}) \n+\n+@end deftypemethod\n+@deftypemethod BufferedImage {public void} setRGB (int@w{ }@var{startX}, int@w{ }@var{startY}, int@w{ }@var{w}, int@w{ }@var{h}, int[]@w{ }@var{argbArray}, int@w{ }@var{offset}, int@w{ }@var{scanlineStride}) \n+\n+@end deftypemethod\n+@deftypemethod BufferedImage {public String} toString () \n+\n+@end deftypemethod\n+@deftypemethod ColorModel {public static ColorModel} getRGBdefault () \n+\n+@end deftypemethod\n+@deftypemethod ColorModel {public final boolean} hasAlpha () \n+\n+@end deftypemethod\n+@deftypemethod ColorModel {public final boolean} isAlphaPremultiplied () \n+\n+@end deftypemethod\n+@deftypemethod ColorModel {public int} getPixelSize () \n+\n+@end deftypemethod\n+@deftypemethod ColorModel {public int} getComponentSize (int@w{ }@var{componentIdx}) \n+\n+@end deftypemethod\n+@deftypemethod ColorModel {public int} getComponentSize () \n+\n+@end deftypemethod\n+@deftypemethod ColorModel {public int} getTransparency () \n+\n+@end deftypemethod\n+@deftypemethod ColorModel {public int} getNumComponents () \n+\n+@end deftypemethod\n+@deftypemethod ColorModel {public int} getNumColorComponents () \n+\n+@end deftypemethod\n+@deftypemethod ColorModel {public abstract int} getRed (int@w{ }@var{pixel}) \n+Converts pixel value to sRGB and extract red int sample scaled\n+ to range [0, 255].\n+@end deftypemethod\n+@deftypemethod ColorModel {public abstract int} getGreen (int@w{ }@var{pixel}) \n+Converts pixel value to sRGB and extract green int sample\n+ scaled to range [0, 255].\n+@end deftypemethod\n+@deftypemethod ColorModel {public abstract int} getBlue (int@w{ }@var{pixel}) \n+Converts pixel value to sRGB and extract blue int sample\n+ scaled to range [0, 255].\n+@end deftypemethod\n+@deftypemethod ColorModel {public abstract int} getAlpha (int@w{ }@var{pixel}) \n+Extract alpha int sample from pixel value, scaled to [0, 255].\n+@end deftypemethod\n+@deftypemethod ColorModel {public int} getRGB (int@w{ }@var{pixel}) \n+Converts a pixel int value of the color space of the color\n+ model to a sRGB pixel int value.\n+\n+ This method is typically overriden in subclasses to provide a\n+ more efficient implementation.\n+@end deftypemethod\n+@deftypemethod ColorModel {public int} getRed (java.lang.Object@w{ }@var{inData}) \n+Converts pixel in the given array to sRGB and extract blue int\n+ sample scaled to range [0-255].\n+\n+ This method is typically overriden in subclasses to provide a\n+ more efficient implementation.\n+@end deftypemethod\n+@deftypemethod ColorModel {public int} getGreen (java.lang.Object@w{ }@var{inData}) \n+\n+@end deftypemethod\n+@deftypemethod ColorModel {public int} getBlue (java.lang.Object@w{ }@var{inData}) \n+\n+@end deftypemethod\n+@deftypemethod ColorModel {public int} getAlpha (java.lang.Object@w{ }@var{inData}) \n+\n+@end deftypemethod\n+@deftypemethod ColorModel {public int} getRGB (java.lang.Object@w{ }@var{inData}) \n+Converts a pixel in the given array of the color space of the\n+ color model to an sRGB pixel int value.\n+\n+ \n+\n+This method performs the inverse function of\n+ @code{getDataElements(int rgb, Object pixel)}.\n+ I.e. @code{(rgb == cm.getRGB(cm.getDataElements(rgb,\n+ null)))}.\n+@end deftypemethod\n+@deftypemethod ColorModel {public Object} getDataElements (int@w{ }@var{rgb}, java.lang.Object@w{ }@var{pixel}) \n+Converts an sRGB pixel int value to an array containing a\n+ single pixel of the color space of the color model.\n+ \n+ \n+\n+This method performs the inverse function of\n+ @code{getRGB(Object inData)}.\n+\n+ Outline of conversion process:\n+\n+ \n+@itemize @bullet\n+\n+\n+ \n+@item\n+Convert rgb to normalized [0.0, 1.0] sRGB values.\n+\n+\n+ \n+@item\n+Convert to color space components using fromRGB in\n+ ColorSpace.\n+\n+\n+ \n+@item\n+If color model has alpha and should be premultiplied,\n+ multiply color space components with alpha value\n+\n+\n+ \n+@item\n+Scale the components to the correct number of bits.\n+\n+\n+ \n+@item\n+Arrange the components in the output array\n+\n+ \n+ \n+@end itemize\n+\n+@end deftypemethod\n+@deftypemethod ColorModel {public int} getComponents (int@w{ }@var{pixel}, int[]@w{ }@var{components}, int@w{ }@var{offset}) \n+Fills an array with the unnormalized component samples from a\n+ pixel value. I.e. decompose the pixel, but not perform any\n+ color conversion. \n+\n+ This method is typically overriden in subclasses to provide a\n+ more efficient implementation.\n+@end deftypemethod\n+@deftypemethod ColorModel {public int} getComponents (java.lang.Object@w{ }@var{pixel}, int[]@w{ }@var{components}, int@w{ }@var{offset}) \n+Fills an array with the unnormalized component samples from an\n+ array of transferType containing a single pixel. I.e. decompose\n+ the pixel, but not perform any color conversion.\n+\n+ This method is typically overriden in subclasses to provide a\n+ more efficient implementation.\n+@end deftypemethod\n+@deftypemethod ColorModel {public int} getUnnormalizedComponents (float[]@w{ }@var{normComponents}, int@w{ }@var{normOffset}, int[]@w{ }@var{components}, int@w{ }@var{offset}) \n+Convert normalized components to unnormalized components.\n+@end deftypemethod\n+@deftypemethod ColorModel {public float} getNormalizedComponents (int[]@w{ }@var{components}, int@w{ }@var{offset}, float[]@w{ }@var{normComponents}, int@w{ }@var{normOffset}) \n+Convert unnormalized components to normalized components.\n+@end deftypemethod\n+@deftypemethod ColorModel {public int} getDataElement (int[]@w{ }@var{components}, int@w{ }@var{offset}) \n+Converts the unnormalized component samples from an array to a\n+ pixel value. I.e. composes the pixel from component samples, but\n+ does not perform any color conversion or scaling of the samples.\n+ \n+ This method performs the inverse function of\n+ @code{getComponents(int pixel, int[] components,\n+\t\t\t       int offset)}. I.e.\n+\n+ @code{(pixel == cm.getDataElement(cm.getComponents(pixel, null,\n+ 0), 0))}.\n+\n+ This method is typically overriden in subclasses to provide a\n+ more efficient implementation.\n+@end deftypemethod\n+@deftypemethod ColorModel {public Object} getDataElements (int[]@w{ }@var{components}, int@w{ }@var{offset}, java.lang.Object@w{ }@var{obj}) \n+\n+@end deftypemethod\n+@deftypemethod ColorModel {public boolean} equals (java.lang.Object@w{ }@var{obj}) \n+\n+@end deftypemethod\n+@deftypemethod ColorModel {public final ColorSpace} getColorSpace () \n+\n+@end deftypemethod\n+@deftypemethod ColorModel {public ColorModel} coerceData (java.awt.image.WritableRaster@w{ }@var{raster}, boolean@w{ }@var{isAlphaPremultiplied}) \n+\n+@end deftypemethod\n+@deftypemethod ColorModel {public boolean} isCompatibleRaster (java.awt.image.Raster@w{ }@var{raster}) \n+\n+@end deftypemethod\n+@deftypemethod ColorModel {public WritableRaster} createCompatibleWritableRaster (int@w{ }@var{w}, int@w{ }@var{h}) \n+\n+@end deftypemethod\n+@deftypemethod ColorModel {public SampleModel} createCompatibleSampleModel (int@w{ }@var{w}, int@w{ }@var{h}) \n+\n+@end deftypemethod\n+@deftypemethod ColorModel {public boolean} isCompatibleSampleModel (java.awt.image.SampleModel@w{ }@var{sm}) \n+\n+@end deftypemethod\n+@deftypemethod ColorModel {public void} finalize () \n+\n+@end deftypemethod\n+@deftypemethod ColorModel {public WritableRaster} getAlphaRaster (java.awt.image.WritableRaster@w{ }@var{raster}) \n+Subclasses must override this method if it is possible for the\n+ color model to have an alpha channel.\n+@end deftypemethod\n+@deftypemethod ColorModel {public String} toString () \n+\n+@end deftypemethod\n+@deftypemethod ComponentColorModel {public int} getRed (int@w{ }@var{pixel}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentColorModel {public int} getGreen (int@w{ }@var{pixel}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentColorModel {public int} getBlue (int@w{ }@var{pixel}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentColorModel {public int} getAlpha (int@w{ }@var{pixel}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentColorModel {public int} getRGB (int@w{ }@var{pixel}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentColorModel {public int} getRed (java.lang.Object@w{ }@var{inData}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentColorModel {public int} getGreen (java.lang.Object@w{ }@var{inData}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentColorModel {public int} getBlue (java.lang.Object@w{ }@var{inData}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentColorModel {public int} getAlpha (java.lang.Object@w{ }@var{inData}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentColorModel {public int} getRGB (java.lang.Object@w{ }@var{inData}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentColorModel {public Object} getDataElements (int@w{ }@var{rgb}, java.lang.Object@w{ }@var{pixel}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentColorModel {public int} getComponents (int@w{ }@var{pixel}, int[]@w{ }@var{components}, int@w{ }@var{offset}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentColorModel {public int} getComponents (java.lang.Object@w{ }@var{pixel}, int[]@w{ }@var{components}, int@w{ }@var{offset}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentColorModel {public int} getDataElement (int[]@w{ }@var{components}, int@w{ }@var{offset}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentColorModel {public Object} getDataElements (int[]@w{ }@var{components}, int@w{ }@var{offset}, java.lang.Object@w{ }@var{obj}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentColorModel {public ColorModel} coerceData (java.awt.image.WritableRaster@w{ }@var{raster}, boolean@w{ }@var{isAlphaPremultiplied}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentColorModel {public boolean} isCompatibleRaster (java.awt.image.Raster@w{ }@var{raster}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentColorModel {public WritableRaster} createCompatibleWritableRaster (int@w{ }@var{w}, int@w{ }@var{h}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentColorModel {public SampleModel} createCompatibleSampleModel (int@w{ }@var{w}, int@w{ }@var{h}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentColorModel {public boolean} isCompatibleSampleModel (java.awt.image.SampleModel@w{ }@var{sm}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentColorModel {public WritableRaster} getAlphaRaster (java.awt.image.WritableRaster@w{ }@var{raster}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentColorModel {public boolean} equals (java.lang.Object@w{ }@var{obj}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentSampleModel {public SampleModel} createCompatibleSampleModel (int@w{ }@var{w}, int@w{ }@var{h}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentSampleModel {public SampleModel} createSubsetSampleModel (int[]@w{ }@var{bands}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentSampleModel {public DataBuffer} createDataBuffer () \n+\n+@end deftypemethod\n+@deftypemethod ComponentSampleModel {public int} getOffset (int@w{ }@var{x}, int@w{ }@var{y}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentSampleModel {public int} getOffset (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{b}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentSampleModel {public final int} getSampleSize () \n+\n+@end deftypemethod\n+@deftypemethod ComponentSampleModel {public final int} getSampleSize (int@w{ }@var{band}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentSampleModel {public final int} getBankIndices () \n+\n+@end deftypemethod\n+@deftypemethod ComponentSampleModel {public final int} getBandOffsets () \n+\n+@end deftypemethod\n+@deftypemethod ComponentSampleModel {public final int} getScanlineStride () \n+\n+@end deftypemethod\n+@deftypemethod ComponentSampleModel {public final int} getPixelStride () \n+\n+@end deftypemethod\n+@deftypemethod ComponentSampleModel {public final int} getNumDataElements () \n+\n+@end deftypemethod\n+@deftypemethod ComponentSampleModel {public Object} getDataElements (int@w{ }@var{x}, int@w{ }@var{y}, java.lang.Object@w{ }@var{obj}, java.awt.image.DataBuffer@w{ }@var{data}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentSampleModel {public Object} getDataElements (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{w}, int@w{ }@var{h}, java.lang.Object@w{ }@var{obj}, java.awt.image.DataBuffer@w{ }@var{data}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentSampleModel {public void} setDataElements (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{w}, int@w{ }@var{h}, java.lang.Object@w{ }@var{obj}, java.awt.image.DataBuffer@w{ }@var{data}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentSampleModel {public int} getPixel (int@w{ }@var{x}, int@w{ }@var{y}, int[]@w{ }@var{iArray}, java.awt.image.DataBuffer@w{ }@var{data}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentSampleModel {public int} getPixels (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{w}, int@w{ }@var{h}, int[]@w{ }@var{iArray}, java.awt.image.DataBuffer@w{ }@var{data}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentSampleModel {public int} getSample (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{b}, java.awt.image.DataBuffer@w{ }@var{data}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentSampleModel {public void} setDataElements (int@w{ }@var{x}, int@w{ }@var{y}, java.lang.Object@w{ }@var{obj}, java.awt.image.DataBuffer@w{ }@var{data}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentSampleModel {public void} setPixel (int@w{ }@var{x}, int@w{ }@var{y}, int[]@w{ }@var{iArray}, java.awt.image.DataBuffer@w{ }@var{data}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentSampleModel {public void} setSample (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{b}, int@w{ }@var{s}, java.awt.image.DataBuffer@w{ }@var{data}) \n+\n+@end deftypemethod\n+@deftypemethod DataBufferByte {public byte} getData () \n+\n+@end deftypemethod\n+@deftypemethod DataBufferByte {public byte} getData (int@w{ }@var{bank}) \n+\n+@end deftypemethod\n+@deftypemethod DataBufferByte {public byte} getBankData () \n+\n+@end deftypemethod\n+@deftypemethod DataBufferByte {public int} getElem (int@w{ }@var{i}) \n+\n+@end deftypemethod\n+@deftypemethod DataBufferByte {public int} getElem (int@w{ }@var{bank}, int@w{ }@var{i}) \n+\n+@end deftypemethod\n+@deftypemethod DataBufferByte {public void} setElem (int@w{ }@var{i}, int@w{ }@var{val}) \n+\n+@end deftypemethod\n+@deftypemethod DataBufferByte {public void} setElem (int@w{ }@var{bank}, int@w{ }@var{i}, int@w{ }@var{val}) \n+\n+@end deftypemethod\n+@deftypemethod DataBufferInt {public int} getData () \n+\n+@end deftypemethod\n+@deftypemethod DataBufferInt {public int} getData (int@w{ }@var{bank}) \n+\n+@end deftypemethod\n+@deftypemethod DataBufferInt {public int} getBankData () \n+\n+@end deftypemethod\n+@deftypemethod DataBufferInt {public int} getElem (int@w{ }@var{i}) \n+\n+@end deftypemethod\n+@deftypemethod DataBufferInt {public int} getElem (int@w{ }@var{bank}, int@w{ }@var{i}) \n+\n+@end deftypemethod\n+@deftypemethod DataBufferInt {public void} setElem (int@w{ }@var{i}, int@w{ }@var{val}) \n+\n+@end deftypemethod\n+@deftypemethod DataBufferInt {public void} setElem (int@w{ }@var{bank}, int@w{ }@var{i}, int@w{ }@var{val}) \n+\n+@end deftypemethod\n+@deftypemethod DataBuffer {public static int} getDataTypeSize (int@w{ }@var{dataType}) \n+\n+@end deftypemethod\n+@deftypemethod DataBuffer {public int} getDataType () \n+\n+@end deftypemethod\n+@deftypemethod DataBuffer {public int} getSize () \n+\n+@end deftypemethod\n+@deftypemethod DataBuffer {public int} getOffset () \n+\n+@end deftypemethod\n+@deftypemethod DataBuffer {public int} getOffsets () \n+\n+@end deftypemethod\n+@deftypemethod DataBuffer {public int} getNumBanks () \n+\n+@end deftypemethod\n+@deftypemethod DataBuffer {public int} getElem (int@w{ }@var{i}) \n+\n+@end deftypemethod\n+@deftypemethod DataBuffer {public abstract int} getElem (int@w{ }@var{bank}, int@w{ }@var{i}) \n+\n+@end deftypemethod\n+@deftypemethod DataBuffer {public void} setElem (int@w{ }@var{i}, int@w{ }@var{val}) \n+\n+@end deftypemethod\n+@deftypemethod DataBuffer {public abstract void} setElem (int@w{ }@var{bank}, int@w{ }@var{i}, int@w{ }@var{val}) \n+\n+@end deftypemethod\n+@deftypemethod DataBuffer {public float} getElemFloat (int@w{ }@var{i}) \n+\n+@end deftypemethod\n+@deftypemethod DataBuffer {public float} getElemFloat (int@w{ }@var{bank}, int@w{ }@var{i}) \n+\n+@end deftypemethod\n+@deftypemethod DataBuffer {public void} setElemFloat (int@w{ }@var{i}, float@w{ }@var{val}) \n+\n+@end deftypemethod\n+@deftypemethod DataBuffer {public void} setElemFloat (int@w{ }@var{bank}, int@w{ }@var{i}, float@w{ }@var{val}) \n+\n+@end deftypemethod\n+@deftypemethod DataBuffer {public double} getElemDouble (int@w{ }@var{i}) \n+\n+@end deftypemethod\n+@deftypemethod DataBuffer {public double} getElemDouble (int@w{ }@var{bank}, int@w{ }@var{i}) \n+\n+@end deftypemethod\n+@deftypemethod DataBuffer {public void} setElemDouble (int@w{ }@var{i}, double@w{ }@var{val}) \n+\n+@end deftypemethod\n+@deftypemethod DataBuffer {public void} setElemDouble (int@w{ }@var{bank}, int@w{ }@var{i}, double@w{ }@var{val}) \n+\n+@end deftypemethod\n+@deftypemethod DataBufferUShort {public short} getData () \n+\n+@end deftypemethod\n+@deftypemethod DataBufferUShort {public short} getData (int@w{ }@var{bank}) \n+\n+@end deftypemethod\n+@deftypemethod DataBufferUShort {public short} getBankData () \n+\n+@end deftypemethod\n+@deftypemethod DataBufferUShort {public int} getElem (int@w{ }@var{i}) \n+\n+@end deftypemethod\n+@deftypemethod DataBufferUShort {public int} getElem (int@w{ }@var{bank}, int@w{ }@var{i}) \n+\n+@end deftypemethod\n+@deftypemethod DataBufferUShort {public void} setElem (int@w{ }@var{i}, int@w{ }@var{val}) \n+\n+@end deftypemethod\n+@deftypemethod DataBufferUShort {public void} setElem (int@w{ }@var{bank}, int@w{ }@var{i}, int@w{ }@var{val}) \n+\n+@end deftypemethod\n+@deftypemethod DirectColorModel {public final int} getRedMask () \n+\n+@end deftypemethod\n+@deftypemethod DirectColorModel {public final int} getGreenMask () \n+\n+@end deftypemethod\n+@deftypemethod DirectColorModel {public final int} getBlueMask () \n+\n+@end deftypemethod\n+@deftypemethod DirectColorModel {public final int} getAlphaMask () \n+\n+@end deftypemethod\n+@deftypemethod DirectColorModel {public final int} getRed (int@w{ }@var{pixel}) \n+\n+@end deftypemethod\n+@deftypemethod DirectColorModel {public final int} getGreen (int@w{ }@var{pixel}) \n+\n+@end deftypemethod\n+@deftypemethod DirectColorModel {public final int} getBlue (int@w{ }@var{pixel}) \n+\n+@end deftypemethod\n+@deftypemethod DirectColorModel {public final int} getAlpha (int@w{ }@var{pixel}) \n+\n+@end deftypemethod\n+@deftypemethod DirectColorModel {public final int} getRGB (int@w{ }@var{pixel}) \n+\n+@end deftypemethod\n+@deftypemethod DirectColorModel {public int} getRed (java.lang.Object@w{ }@var{inData}) \n+\n+@end deftypemethod\n+@deftypemethod DirectColorModel {public int} getGreen (java.lang.Object@w{ }@var{inData}) \n+\n+@end deftypemethod\n+@deftypemethod DirectColorModel {public int} getBlue (java.lang.Object@w{ }@var{inData}) \n+\n+@end deftypemethod\n+@deftypemethod DirectColorModel {public int} getAlpha (java.lang.Object@w{ }@var{inData}) \n+\n+@end deftypemethod\n+@deftypemethod DirectColorModel {public int} getRGB (java.lang.Object@w{ }@var{inData}) \n+\n+@end deftypemethod\n+@deftypemethod DirectColorModel {public Object} getDataElements (int@w{ }@var{rgb}, java.lang.Object@w{ }@var{pixel}) \n+Converts a normalized pixel int value in the sRGB color\n+ space to an array containing a single pixel of the color space\n+ of the color model.\n+\n+ \n+\n+This method performs the inverse function of\n+ @code{getRGB(Object inData)}.\n+@end deftypemethod\n+@deftypemethod DirectColorModel {public final int} getComponents (int@w{ }@var{pixel}, int[]@w{ }@var{components}, int@w{ }@var{offset}) \n+Fills an array with the unnormalized component samples from a\n+ pixel value. I.e. decompose the pixel, but not perform any\n+ color conversion.\n+@end deftypemethod\n+@deftypemethod DirectColorModel {public final int} getComponents (java.lang.Object@w{ }@var{pixel}, int[]@w{ }@var{components}, int@w{ }@var{offset}) \n+\n+@end deftypemethod\n+@deftypemethod DirectColorModel {public final WritableRaster} createCompatibleWritableRaster (int@w{ }@var{w}, int@w{ }@var{h}) \n+\n+@end deftypemethod\n+@deftypemethod DirectColorModel {public int} getDataElement (int[]@w{ }@var{components}, int@w{ }@var{offset}) \n+\n+@end deftypemethod\n+@deftypemethod DirectColorModel {public Object} getDataElements (int[]@w{ }@var{components}, int@w{ }@var{offset}, java.lang.Object@w{ }@var{obj}) \n+\n+@end deftypemethod\n+@deftypemethod DirectColorModel {public ColorModel} coerceData (java.awt.image.WritableRaster@w{ }@var{raster}, boolean@w{ }@var{isAlphaPremultiplied}) \n+\n+@end deftypemethod\n+@deftypemethod DirectColorModel {public boolean} isCompatibleRaster (java.awt.image.Raster@w{ }@var{raster}) \n+\n+@end deftypemethod\n+@deftypemethod DirectColorModel {public String} toString () \n+\n+@end deftypemethod\n+@deftypemethod ImageConsumer {public void} setDimensions (int@w{ }@var{width}, int@w{ }@var{height}) \n+\n+@end deftypemethod\n+@deftypemethod ImageConsumer {public void} setProperties (java.util.Hashtable@w{ }@var{props}) \n+\n+@end deftypemethod\n+@deftypemethod ImageConsumer {public void} setColorModel (java.awt.image.ColorModel@w{ }@var{model}) \n+\n+@end deftypemethod\n+@deftypemethod ImageConsumer {public void} setHints (int@w{ }@var{hintflags}) \n+\n+@end deftypemethod\n+@deftypemethod ImageConsumer {public void} setPixels (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{w}, int@w{ }@var{h}, java.awt.image.ColorModel@w{ }@var{model}, byte[]@w{ }@var{pixels}, int@w{ }@var{off}, int@w{ }@var{scansize}) \n+\n+@end deftypemethod\n+@deftypemethod ImageConsumer {public void} setPixels (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{w}, int@w{ }@var{h}, java.awt.image.ColorModel@w{ }@var{model}, int[]@w{ }@var{pixels}, int@w{ }@var{off}, int@w{ }@var{scansize}) \n+\n+@end deftypemethod\n+@deftypemethod ImageConsumer {public void} imageComplete (int@w{ }@var{status}) \n+\n+@end deftypemethod\n+@deftypemethod ImageObserver {public boolean} imageUpdate (java.awt.Image@w{ }@var{image}, int@w{ }@var{infoFlags}, int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{width}, int@w{ }@var{height}) \n+\n+@end deftypemethod\n+@deftypemethod ImageProducer {public void} addConsumer (java.awt.image.ImageConsumer@w{ }@var{ic}) \n+\n+@end deftypemethod\n+@deftypemethod ImageProducer {public boolean} isConsumer (java.awt.image.ImageConsumer@w{ }@var{ic}) \n+\n+@end deftypemethod\n+@deftypemethod ImageProducer {public void} removeConsumer (java.awt.image.ImageConsumer@w{ }@var{ic}) \n+\n+@end deftypemethod\n+@deftypemethod ImageProducer {public void} startProduction (java.awt.image.ImageConsumer@w{ }@var{ic}) \n+\n+@end deftypemethod\n+@deftypemethod ImageProducer {public void} requestTopDownLeftRightResend (java.awt.image.ImageConsumer@w{ }@var{ic}) \n+\n+@end deftypemethod\n+@deftypemethod IndexColorModel {public final int} getMapSize () \n+\n+@end deftypemethod\n+@deftypemethod IndexColorModel {public final int} getTransparentPixel () \n+\n+@end deftypemethod\n+@deftypemethod IndexColorModel {public final void} getReds (byte[]@w{ }@var{r}) \n+\n+@end deftypemethod\n+@deftypemethod IndexColorModel {public final void} getGreens (byte[]@w{ }@var{g}) \n+\n+@end deftypemethod\n+@deftypemethod IndexColorModel {public final void} getBlues (byte[]@w{ }@var{b}) \n+\n+@end deftypemethod\n+@deftypemethod IndexColorModel {public final void} getAlphas (byte[]@w{ }@var{a}) \n+\n+@end deftypemethod\n+@deftypemethod IndexColorModel {public final void} getRGBs (int[]@w{ }@var{rgb}) \n+\n+@end deftypemethod\n+@deftypemethod IndexColorModel {public int} getRed (int@w{ }@var{pixel}) \n+\n+@end deftypemethod\n+@deftypemethod IndexColorModel {public int} getGreen (int@w{ }@var{pixel}) \n+\n+@end deftypemethod\n+@deftypemethod IndexColorModel {public int} getBlue (int@w{ }@var{pixel}) \n+\n+@end deftypemethod\n+@deftypemethod IndexColorModel {public int} getAlpha (int@w{ }@var{pixel}) \n+\n+@end deftypemethod\n+@deftypemethod IndexColorModel {public int} getRed (java.lang.Object@w{ }@var{inData}) \n+\n+@end deftypemethod\n+@deftypemethod IndexColorModel {public int} getGreen (java.lang.Object@w{ }@var{inData}) \n+\n+@end deftypemethod\n+@deftypemethod IndexColorModel {public int} getBlue (java.lang.Object@w{ }@var{inData}) \n+\n+@end deftypemethod\n+@deftypemethod IndexColorModel {public int} getAlpha (java.lang.Object@w{ }@var{inData}) \n+\n+@end deftypemethod\n+@deftypemethod IndexColorModel {public int} getRGB (java.lang.Object@w{ }@var{inData}) \n+\n+@end deftypemethod\n+@deftypemethod IndexColorModel {public Object} getDataElements (int@w{ }@var{rgb}, java.lang.Object@w{ }@var{pixel}) \n+\n+@end deftypemethod\n+@deftypemethod IndexColorModel {public int} getComponents (int@w{ }@var{pixel}, int[]@w{ }@var{components}, int@w{ }@var{offset}) \n+\n+@end deftypemethod\n+@deftypemethod IndexColorModel {public final int} getComponents (java.lang.Object@w{ }@var{pixel}, int[]@w{ }@var{components}, int@w{ }@var{offset}) \n+\n+@end deftypemethod\n+@deftypemethod IndexColorModel {public int} getDataElement (int[]@w{ }@var{components}, int@w{ }@var{offset}) \n+\n+@end deftypemethod\n+@deftypemethod IndexColorModel {public Object} getDataElements (int[]@w{ }@var{components}, int@w{ }@var{offset}, java.lang.Object@w{ }@var{pixel}) \n+\n+@end deftypemethod\n+@deftypemethod IndexColorModel {public SampleModel} createCompatibleSampleModel (int@w{ }@var{w}, int@w{ }@var{h}) \n+\n+@end deftypemethod\n+@deftypemethod PackedColorModel {public final int} getMask (int@w{ }@var{index}) \n+\n+@end deftypemethod\n+@deftypemethod PackedColorModel {public final int} getMasks () \n+\n+@end deftypemethod\n+@deftypemethod PackedColorModel {public SampleModel} createCompatibleSampleModel (int@w{ }@var{w}, int@w{ }@var{h}) \n+\n+@end deftypemethod\n+@deftypemethod PackedColorModel {public boolean} isCompatibleSampleModel (java.awt.image.SampleModel@w{ }@var{sm}) \n+\n+@end deftypemethod\n+@deftypemethod PackedColorModel {public WritableRaster} getAlphaRaster (java.awt.image.WritableRaster@w{ }@var{raster}) \n+\n+@end deftypemethod\n+@deftypemethod PackedColorModel {public boolean} equals (java.lang.Object@w{ }@var{obj}) \n+\n+@end deftypemethod\n+@deftypemethod Raster {public static WritableRaster} createInterleavedRaster (int@w{ }@var{dataType}, int@w{ }@var{w}, int@w{ }@var{h}, int@w{ }@var{bands}, java.awt.Point@w{ }@var{location}) \n+\n+@end deftypemethod\n+@deftypemethod Raster {public static WritableRaster} createInterleavedRaster (int@w{ }@var{dataType}, int@w{ }@var{w}, int@w{ }@var{h}, int@w{ }@var{scanlineStride}, int@w{ }@var{pixelStride}, int[]@w{ }@var{bandOffsets}, java.awt.Point@w{ }@var{location}) \n+\n+@end deftypemethod\n+@deftypemethod Raster {public static WritableRaster} createBandedRaster (int@w{ }@var{dataType}, int@w{ }@var{w}, int@w{ }@var{h}, int@w{ }@var{bands}, java.awt.Point@w{ }@var{location}) \n+\n+@end deftypemethod\n+@deftypemethod Raster {public static WritableRaster} createBandedRaster (int@w{ }@var{dataType}, int@w{ }@var{w}, int@w{ }@var{h}, int@w{ }@var{scanlineStride}, int[]@w{ }@var{bankIndices}, int[]@w{ }@var{bandOffsets}, java.awt.Point@w{ }@var{location}) \n+\n+@end deftypemethod\n+@deftypemethod Raster {public static WritableRaster} createPackedRaster (int@w{ }@var{dataType}, int@w{ }@var{w}, int@w{ }@var{h}, int[]@w{ }@var{bandMasks}, java.awt.Point@w{ }@var{location}) \n+\n+@end deftypemethod\n+@deftypemethod Raster {public static WritableRaster} createInterleavedRaster (java.awt.image.DataBuffer@w{ }@var{dataBuffer}, int@w{ }@var{w}, int@w{ }@var{h}, int@w{ }@var{scanlineStride}, int@w{ }@var{pixelStride}, int[]@w{ }@var{bandOffsets}, java.awt.Point@w{ }@var{location}) \n+\n+@end deftypemethod\n+@deftypemethod Raster {public static WritableRaster} createBandedRaster (java.awt.image.DataBuffer@w{ }@var{dataBuffer}, int@w{ }@var{w}, int@w{ }@var{h}, int@w{ }@var{scanlineStride}, int[]@w{ }@var{bankIndices}, int[]@w{ }@var{bandOffsets}, java.awt.Point@w{ }@var{location}) \n+\n+@end deftypemethod\n+@deftypemethod Raster {public static WritableRaster} createPackedRaster (java.awt.image.DataBuffer@w{ }@var{dataBuffer}, int@w{ }@var{w}, int@w{ }@var{h}, int@w{ }@var{scanlineStride}, int[]@w{ }@var{bandMasks}, java.awt.Point@w{ }@var{location}) \n+\n+@end deftypemethod\n+@deftypemethod Raster {public static Raster} createRaster (java.awt.image.SampleModel@w{ }@var{sm}, java.awt.image.DataBuffer@w{ }@var{db}, java.awt.Point@w{ }@var{location}) \n+\n+@end deftypemethod\n+@deftypemethod Raster {public static WritableRaster} createWritableRaster (java.awt.image.SampleModel@w{ }@var{sm}, java.awt.Point@w{ }@var{location}) \n+\n+@end deftypemethod\n+@deftypemethod Raster {public static WritableRaster} createWritableRaster (java.awt.image.SampleModel@w{ }@var{sm}, java.awt.image.DataBuffer@w{ }@var{db}, java.awt.Point@w{ }@var{location}) \n+\n+@end deftypemethod\n+@deftypemethod Raster {public Raster} getParent () \n+\n+@end deftypemethod\n+@deftypemethod Raster {public final int} getSampleModelTranslateX () \n+\n+@end deftypemethod\n+@deftypemethod Raster {public final int} getSampleModelTranslateY () \n+\n+@end deftypemethod\n+@deftypemethod Raster {public WritableRaster} createCompatibleWritableRaster () \n+\n+@end deftypemethod\n+@deftypemethod Raster {public WritableRaster} createCompatibleWritableRaster (int@w{ }@var{w}, int@w{ }@var{h}) \n+\n+@end deftypemethod\n+@deftypemethod Raster {public WritableRaster} createCompatibleWritableRaster (java.awt.Rectangle@w{ }@var{rect}) \n+\n+@end deftypemethod\n+@deftypemethod Raster {public WritableRaster} createCompatibleWritableRaster (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{w}, int@w{ }@var{h}) \n+\n+@end deftypemethod\n+@deftypemethod Raster {public Raster} createTranslatedChild (int@w{ }@var{childMinX}, int@w{ }@var{childMinY}) \n+\n+@end deftypemethod\n+@deftypemethod Raster {public Raster} createChild (int@w{ }@var{parentX}, int@w{ }@var{parentY}, int@w{ }@var{width}, int@w{ }@var{height}, int@w{ }@var{childMinX}, int@w{ }@var{childMinY}, int[]@w{ }@var{bandList}) \n+\n+@end deftypemethod\n+@deftypemethod Raster {public Rectangle} getBounds () \n+\n+@end deftypemethod\n+@deftypemethod Raster {public final int} getMinX () \n+\n+@end deftypemethod\n+@deftypemethod Raster {public final int} getMinY () \n+\n+@end deftypemethod\n+@deftypemethod Raster {public final int} getWidth () \n+\n+@end deftypemethod\n+@deftypemethod Raster {public final int} getHeight () \n+\n+@end deftypemethod\n+@deftypemethod Raster {public final int} getNumDataElements () \n+\n+@end deftypemethod\n+@deftypemethod Raster {public final int} getTransferType () \n+\n+@end deftypemethod\n+@deftypemethod Raster {public DataBuffer} getDataBuffer () \n+\n+@end deftypemethod\n+@deftypemethod Raster {public SampleModel} getSampleModel () \n+\n+@end deftypemethod\n+@deftypemethod Raster {public Object} getDataElements (int@w{ }@var{x}, int@w{ }@var{y}, java.lang.Object@w{ }@var{outData}) \n+\n+@end deftypemethod\n+@deftypemethod Raster {public Object} getDataElements (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{w}, int@w{ }@var{h}, java.lang.Object@w{ }@var{outData}) \n+\n+@end deftypemethod\n+@deftypemethod Raster {public int} getPixel (int@w{ }@var{x}, int@w{ }@var{y}, int[]@w{ }@var{iArray}) \n+\n+@end deftypemethod\n+@deftypemethod Raster {public float} getPixel (int@w{ }@var{x}, int@w{ }@var{y}, float[]@w{ }@var{fArray}) \n+\n+@end deftypemethod\n+@deftypemethod Raster {public double} getPixel (int@w{ }@var{x}, int@w{ }@var{y}, double[]@w{ }@var{dArray}) \n+\n+@end deftypemethod\n+@deftypemethod Raster {public int} getPixels (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{w}, int@w{ }@var{h}, int[]@w{ }@var{iArray}) \n+\n+@end deftypemethod\n+@deftypemethod Raster {public float} getPixels (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{w}, int@w{ }@var{h}, float[]@w{ }@var{fArray}) \n+\n+@end deftypemethod\n+@deftypemethod Raster {public double} getPixels (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{w}, int@w{ }@var{h}, double[]@w{ }@var{dArray}) \n+\n+@end deftypemethod\n+@deftypemethod Raster {public int} getSample (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{b}) \n+\n+@end deftypemethod\n+@deftypemethod Raster {public float} getSampleFloat (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{b}) \n+\n+@end deftypemethod\n+@deftypemethod Raster {public double} getSampleDouble (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{b}) \n+\n+@end deftypemethod\n+@deftypemethod Raster {public int} getSamples (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{w}, int@w{ }@var{h}, int@w{ }@var{b}, int[]@w{ }@var{iArray}) \n+\n+@end deftypemethod\n+@deftypemethod Raster {public float} getSamples (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{w}, int@w{ }@var{h}, int@w{ }@var{b}, float[]@w{ }@var{fArray}) \n+\n+@end deftypemethod\n+@deftypemethod Raster {public double} getSamples (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{w}, int@w{ }@var{h}, int@w{ }@var{b}, double[]@w{ }@var{dArray}) \n+\n+@end deftypemethod\n+@deftypemethod RasterOp {public WritableRaster} filter (java.awt.image.Raster@w{ }@var{src}, java.awt.image.WritableRaster@w{ }@var{dest}) \n+\n+@end deftypemethod\n+@deftypemethod RasterOp {public Rectangle2D} getBounds2D (java.awt.image.Raster@w{ }@var{src}) \n+\n+@end deftypemethod\n+@deftypemethod RasterOp {public WritableRaster} createCompatibleDestRaster (java.awt.image.Raster@w{ }@var{src}) \n+\n+@end deftypemethod\n+@deftypemethod RasterOp {public Point2D} getPoint2D (java.awt.geom.Point2D@w{ }@var{srcPoint}, java.awt.geom.Point2D@w{ }@var{destPoint}) \n+\n+@end deftypemethod\n+@deftypemethod RasterOp {public RenderingHints} getRenderingHints () \n+\n+@end deftypemethod\n+@deftypemethod SampleModel {public final int} getWidth () \n+\n+@end deftypemethod\n+@deftypemethod SampleModel {public final int} getHeight () \n+\n+@end deftypemethod\n+@deftypemethod SampleModel {public final int} getNumBands () \n+\n+@end deftypemethod\n+@deftypemethod SampleModel {public abstract int} getNumDataElements () \n+\n+@end deftypemethod\n+@deftypemethod SampleModel {public final int} getDataType () \n+\n+@end deftypemethod\n+@deftypemethod SampleModel {public int} getTransferType () \n+\n+@end deftypemethod\n+@deftypemethod SampleModel {public int} getPixel (int@w{ }@var{x}, int@w{ }@var{y}, int[]@w{ }@var{iArray}, java.awt.image.DataBuffer@w{ }@var{data}) \n+\n+@end deftypemethod\n+@deftypemethod SampleModel {public abstract Object} getDataElements (int@w{ }@var{x}, int@w{ }@var{y}, java.lang.Object@w{ }@var{obj}, java.awt.image.DataBuffer@w{ }@var{data}) \n+This method is provided as a faster alternative to getPixel(),\n+ that can be used when there is no need to decode the pixel into\n+ seperate sample values.\n+@end deftypemethod\n+@deftypemethod SampleModel {public Object} getDataElements (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{w}, int@w{ }@var{h}, java.lang.Object@w{ }@var{obj}, java.awt.image.DataBuffer@w{ }@var{data}) \n+\n+@end deftypemethod\n+@deftypemethod SampleModel {public abstract void} setDataElements (int@w{ }@var{x}, int@w{ }@var{y}, java.lang.Object@w{ }@var{obj}, java.awt.image.DataBuffer@w{ }@var{data}) \n+\n+@end deftypemethod\n+@deftypemethod SampleModel {public void} setDataElements (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{w}, int@w{ }@var{h}, java.lang.Object@w{ }@var{obj}, java.awt.image.DataBuffer@w{ }@var{data}) \n+\n+@end deftypemethod\n+@deftypemethod SampleModel {public float} getPixel (int@w{ }@var{x}, int@w{ }@var{y}, float[]@w{ }@var{fArray}, java.awt.image.DataBuffer@w{ }@var{data}) \n+\n+@end deftypemethod\n+@deftypemethod SampleModel {public double} getPixel (int@w{ }@var{x}, int@w{ }@var{y}, double[]@w{ }@var{dArray}, java.awt.image.DataBuffer@w{ }@var{data}) \n+\n+@end deftypemethod\n+@deftypemethod SampleModel {public int} getPixels (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{w}, int@w{ }@var{h}, int[]@w{ }@var{iArray}, java.awt.image.DataBuffer@w{ }@var{data}) \n+\n+@end deftypemethod\n+@deftypemethod SampleModel {public float} getPixels (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{w}, int@w{ }@var{h}, float[]@w{ }@var{fArray}, java.awt.image.DataBuffer@w{ }@var{data}) \n+\n+@end deftypemethod\n+@deftypemethod SampleModel {public double} getPixels (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{w}, int@w{ }@var{h}, double[]@w{ }@var{dArray}, java.awt.image.DataBuffer@w{ }@var{data}) \n+\n+@end deftypemethod\n+@deftypemethod SampleModel {public abstract int} getSample (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{b}, java.awt.image.DataBuffer@w{ }@var{data}) \n+\n+@end deftypemethod\n+@deftypemethod SampleModel {public float} getSampleFloat (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{b}, java.awt.image.DataBuffer@w{ }@var{data}) \n+\n+@end deftypemethod\n+@deftypemethod SampleModel {public double} getSampleDouble (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{b}, java.awt.image.DataBuffer@w{ }@var{data}) \n+\n+@end deftypemethod\n+@deftypemethod SampleModel {public int} getSamples (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{w}, int@w{ }@var{h}, int@w{ }@var{b}, int[]@w{ }@var{iArray}, java.awt.image.DataBuffer@w{ }@var{data}) \n+\n+@end deftypemethod\n+@deftypemethod SampleModel {public float} getSamples (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{w}, int@w{ }@var{h}, int@w{ }@var{b}, float[]@w{ }@var{fArray}, java.awt.image.DataBuffer@w{ }@var{data}) \n+\n+@end deftypemethod\n+@deftypemethod SampleModel {public double} getSamples (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{w}, int@w{ }@var{h}, int@w{ }@var{b}, double[]@w{ }@var{dArray}, java.awt.image.DataBuffer@w{ }@var{data}) \n+\n+@end deftypemethod\n+@deftypemethod SampleModel {public void} setPixel (int@w{ }@var{x}, int@w{ }@var{y}, int[]@w{ }@var{iArray}, java.awt.image.DataBuffer@w{ }@var{data}) \n+\n+@end deftypemethod\n+@deftypemethod SampleModel {public void} setPixel (int@w{ }@var{x}, int@w{ }@var{y}, float[]@w{ }@var{fArray}, java.awt.image.DataBuffer@w{ }@var{data}) \n+\n+@end deftypemethod\n+@deftypemethod SampleModel {public void} setPixel (int@w{ }@var{x}, int@w{ }@var{y}, double[]@w{ }@var{dArray}, java.awt.image.DataBuffer@w{ }@var{data}) \n+\n+@end deftypemethod\n+@deftypemethod SampleModel {public void} setPixels (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{w}, int@w{ }@var{h}, int[]@w{ }@var{iArray}, java.awt.image.DataBuffer@w{ }@var{data}) \n+\n+@end deftypemethod\n+@deftypemethod SampleModel {public void} setPixels (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{w}, int@w{ }@var{h}, float[]@w{ }@var{fArray}, java.awt.image.DataBuffer@w{ }@var{data}) \n+\n+@end deftypemethod\n+@deftypemethod SampleModel {public void} setPixels (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{w}, int@w{ }@var{h}, double[]@w{ }@var{dArray}, java.awt.image.DataBuffer@w{ }@var{data}) \n+\n+@end deftypemethod\n+@deftypemethod SampleModel {public abstract void} setSample (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{b}, int@w{ }@var{s}, java.awt.image.DataBuffer@w{ }@var{data}) \n+\n+@end deftypemethod\n+@deftypemethod SampleModel {public void} setSample (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{b}, float@w{ }@var{s}, java.awt.image.DataBuffer@w{ }@var{data}) \n+\n+@end deftypemethod\n+@deftypemethod SampleModel {public void} setSample (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{b}, double@w{ }@var{s}, java.awt.image.DataBuffer@w{ }@var{data}) \n+\n+@end deftypemethod\n+@deftypemethod SampleModel {public void} setSamples (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{w}, int@w{ }@var{h}, int@w{ }@var{b}, int[]@w{ }@var{iArray}, java.awt.image.DataBuffer@w{ }@var{data}) \n+\n+@end deftypemethod\n+@deftypemethod SampleModel {public void} setSamples (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{w}, int@w{ }@var{h}, int@w{ }@var{b}, float[]@w{ }@var{fArray}, java.awt.image.DataBuffer@w{ }@var{data}) \n+\n+@end deftypemethod\n+@deftypemethod SampleModel {public void} setSamples (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{w}, int@w{ }@var{h}, int@w{ }@var{b}, double[]@w{ }@var{dArray}, java.awt.image.DataBuffer@w{ }@var{data}) \n+\n+@end deftypemethod\n+@deftypemethod SampleModel {public abstract SampleModel} createCompatibleSampleModel (int@w{ }@var{w}, int@w{ }@var{h}) \n+\n+@end deftypemethod\n+@deftypemethod SampleModel {public abstract SampleModel} createSubsetSampleModel (int[]@w{ }@var{bands}) \n+\n+@end deftypemethod\n+@deftypemethod SampleModel {public abstract DataBuffer} createDataBuffer () \n+\n+@end deftypemethod\n+@deftypemethod SampleModel {public abstract int} getSampleSize () \n+\n+@end deftypemethod\n+@deftypemethod SampleModel {public abstract int} getSampleSize (int@w{ }@var{band}) \n+\n+@end deftypemethod\n+@deftypemethod SinglePixelPackedSampleModel {public int} getNumDataElements () \n+\n+@end deftypemethod\n+@deftypemethod SinglePixelPackedSampleModel {public SampleModel} createCompatibleSampleModel (int@w{ }@var{w}, int@w{ }@var{h}) \n+\n+@end deftypemethod\n+@deftypemethod SinglePixelPackedSampleModel {public DataBuffer} createDataBuffer () \n+\n+@end deftypemethod\n+@deftypemethod SinglePixelPackedSampleModel {public int} getSampleSize () \n+\n+@end deftypemethod\n+@deftypemethod SinglePixelPackedSampleModel {public int} getSampleSize (int@w{ }@var{band}) \n+\n+@end deftypemethod\n+@deftypemethod SinglePixelPackedSampleModel {public int} getOffset (int@w{ }@var{x}, int@w{ }@var{y}) \n+\n+@end deftypemethod\n+@deftypemethod SinglePixelPackedSampleModel {public int} getBitOffsets () \n+\n+@end deftypemethod\n+@deftypemethod SinglePixelPackedSampleModel {public int} getBitMasks () \n+\n+@end deftypemethod\n+@deftypemethod SinglePixelPackedSampleModel {public int} getScanlineStride () \n+\n+@end deftypemethod\n+@deftypemethod SinglePixelPackedSampleModel {public SampleModel} createSubsetSampleModel (int[]@w{ }@var{bands}) \n+\n+@end deftypemethod\n+@deftypemethod SinglePixelPackedSampleModel {public Object} getDataElements (int@w{ }@var{x}, int@w{ }@var{y}, java.lang.Object@w{ }@var{obj}, java.awt.image.DataBuffer@w{ }@var{data}) \n+\n+@end deftypemethod\n+@deftypemethod SinglePixelPackedSampleModel {public int} getPixel (int@w{ }@var{x}, int@w{ }@var{y}, int[]@w{ }@var{iArray}, java.awt.image.DataBuffer@w{ }@var{data}) \n+\n+@end deftypemethod\n+@deftypemethod SinglePixelPackedSampleModel {public int} getPixels (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{w}, int@w{ }@var{h}, int[]@w{ }@var{iArray}, java.awt.image.DataBuffer@w{ }@var{data}) \n+\n+@end deftypemethod\n+@deftypemethod SinglePixelPackedSampleModel {public int} getSample (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{b}, java.awt.image.DataBuffer@w{ }@var{data}) \n+\n+@end deftypemethod\n+@deftypemethod SinglePixelPackedSampleModel {public void} setDataElements (int@w{ }@var{x}, int@w{ }@var{y}, java.lang.Object@w{ }@var{obj}, java.awt.image.DataBuffer@w{ }@var{data}) \n+\n+@end deftypemethod\n+@deftypemethod SinglePixelPackedSampleModel {public void} setPixel (int@w{ }@var{x}, int@w{ }@var{y}, int[]@w{ }@var{iArray}, java.awt.image.DataBuffer@w{ }@var{data}) \n+\n+@end deftypemethod\n+@deftypemethod SinglePixelPackedSampleModel {public void} setSample (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{b}, int@w{ }@var{s}, java.awt.image.DataBuffer@w{ }@var{data}) \n+\n+@end deftypemethod\n+@deftypemethod WritableRaster {public WritableRaster} getWritableParent () \n+\n+@end deftypemethod\n+@deftypemethod WritableRaster {public WritableRaster} createWritableTranslatedChild (int@w{ }@var{childMinX}, int@w{ }@var{childMinY}) \n+\n+@end deftypemethod\n+@deftypemethod WritableRaster {public WritableRaster} createWritableChild (int@w{ }@var{parentX}, int@w{ }@var{parentY}, int@w{ }@var{w}, int@w{ }@var{h}, int@w{ }@var{childMinX}, int@w{ }@var{childMinY}, int[]@w{ }@var{bandList}) \n+\n+@end deftypemethod\n+@deftypemethod WritableRaster {public void} setDataElements (int@w{ }@var{x}, int@w{ }@var{y}, java.lang.Object@w{ }@var{inData}) \n+\n+@end deftypemethod\n+@deftypemethod WritableRaster {public void} setDataElements (int@w{ }@var{x}, int@w{ }@var{y}, java.awt.image.Raster@w{ }@var{inRaster}) \n+\n+@end deftypemethod\n+@deftypemethod WritableRaster {public void} setDataElements (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{w}, int@w{ }@var{h}, java.lang.Object@w{ }@var{inData}) \n+\n+@end deftypemethod\n+@deftypemethod WritableRaster {public void} setRect (java.awt.image.Raster@w{ }@var{srcRaster}) \n+\n+@end deftypemethod\n+@deftypemethod WritableRaster {public void} setRect (java.awt.image.Raster@w{ }@var{srcRaster}, int@w{ }@var{dx}, int@w{ }@var{dy}) \n+\n+@end deftypemethod\n+@deftypemethod WritableRaster {public void} setPixel (int@w{ }@var{x}, int@w{ }@var{y}, int[]@w{ }@var{iArray}) \n+\n+@end deftypemethod\n+@deftypemethod WritableRaster {public void} setPixel (int@w{ }@var{x}, int@w{ }@var{y}, float[]@w{ }@var{fArray}) \n+\n+@end deftypemethod\n+@deftypemethod WritableRaster {public void} setPixel (int@w{ }@var{x}, int@w{ }@var{y}, double[]@w{ }@var{dArray}) \n+\n+@end deftypemethod\n+@deftypemethod WritableRaster {public void} setPixels (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{w}, int@w{ }@var{h}, int[]@w{ }@var{iArray}) \n+\n+@end deftypemethod\n+@deftypemethod WritableRaster {public void} setPixels (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{w}, int@w{ }@var{h}, float[]@w{ }@var{fArray}) \n+\n+@end deftypemethod\n+@deftypemethod WritableRaster {public void} setPixels (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{w}, int@w{ }@var{h}, double[]@w{ }@var{dArray}) \n+\n+@end deftypemethod\n+@deftypemethod WritableRaster {public void} setSample (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{b}, int@w{ }@var{s}) \n+\n+@end deftypemethod\n+@deftypemethod WritableRaster {public void} setSample (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{b}, float@w{ }@var{s}) \n+\n+@end deftypemethod\n+@deftypemethod WritableRaster {public void} setSample (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{b}, double@w{ }@var{s}) \n+\n+@end deftypemethod\n+@deftypemethod WritableRaster {public void} setSamples (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{w}, int@w{ }@var{h}, int@w{ }@var{b}, int[]@w{ }@var{iArray}) \n+\n+@end deftypemethod\n+@deftypemethod WritableRaster {public void} setSamples (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{w}, int@w{ }@var{h}, int@w{ }@var{b}, float[]@w{ }@var{fArray}) \n+\n+@end deftypemethod\n+@deftypemethod WritableRaster {public void} setSamples (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{w}, int@w{ }@var{h}, int@w{ }@var{b}, double[]@w{ }@var{dArray}) \n+\n+@end deftypemethod"}, {"sha": "c065026213f782f459b0e6128790910fd1e7bfe4", "filename": "libjava/doc/java-awt-peer.texi", "status": "added", "additions": 265, "deletions": 0, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2Fdoc%2Fjava-awt-peer.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2Fdoc%2Fjava-awt-peer.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fdoc%2Fjava-awt-peer.texi?ref=6a9d31a7d48bbae78a24a1395199d5c4c048d642", "patch": "@@ -0,0 +1,265 @@\n+@deftypemethod ButtonPeer {public void} setLabel (java.lang.String@w{ }@var{label}) \n+\n+@end deftypemethod\n+@deftypemethod CheckboxMenuItemPeer {public void} setState (boolean@w{ }@var{state}) \n+\n+@end deftypemethod\n+@deftypemethod CheckboxPeer {public void} setCheckboxGroup (java.awt.CheckboxGroup@w{ }@var{group}) \n+\n+@end deftypemethod\n+@deftypemethod CheckboxPeer {public void} setLabel (java.lang.String@w{ }@var{label}) \n+\n+@end deftypemethod\n+@deftypemethod CheckboxPeer {public void} setState (boolean@w{ }@var{state}) \n+\n+@end deftypemethod\n+@deftypemethod ChoicePeer {public void} add (java.lang.String@w{ }@var{item}, int@w{ }@var{index}) \n+\n+@end deftypemethod\n+@deftypemethod ChoicePeer {public void} remove (int@w{ }@var{index}) \n+\n+@end deftypemethod\n+@deftypemethod ChoicePeer {public void} select (int@w{ }@var{index}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentPeer {public int} checkImage (java.awt.Image@w{ }@var{img}, int@w{ }@var{width}, int@w{ }@var{height}, java.awt.image.ImageObserver@w{ }@var{o}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentPeer {public Image} createImage (java.awt.image.ImageProducer@w{ }@var{prod}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentPeer {public Image} createImage (int@w{ }@var{width}, int@w{ }@var{height}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentPeer {public void} dispose () \n+\n+@end deftypemethod\n+@deftypemethod ComponentPeer {public GraphicsConfiguration} getGraphicsConfiguration () \n+Get the graphics configuration of the component. The color model\n+ of the component can be derived from the configuration.\n+@end deftypemethod\n+@deftypemethod ComponentPeer {public FontMetrics} getFontMetrics (java.awt.Font@w{ }@var{f}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentPeer {public Graphics} getGraphics () \n+\n+@end deftypemethod\n+@deftypemethod ComponentPeer {public Point} getLocationOnScreen () \n+\n+@end deftypemethod\n+@deftypemethod ComponentPeer {public Dimension} getMinimumSize () \n+\n+@end deftypemethod\n+@deftypemethod ComponentPeer {public Dimension} getPreferredSize () \n+\n+@end deftypemethod\n+@deftypemethod ComponentPeer {public Toolkit} getToolkit () \n+\n+@end deftypemethod\n+@deftypemethod ComponentPeer {public void} handleEvent (java.awt.AWTEvent@w{ }@var{e}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentPeer {public boolean} isFocusTraversable () \n+\n+@end deftypemethod\n+@deftypemethod ComponentPeer {public void} paint (java.awt.Graphics@w{ }@var{graphics}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentPeer {public boolean} prepareImage (java.awt.Image@w{ }@var{img}, int@w{ }@var{width}, int@w{ }@var{height}, java.awt.image.ImageObserver@w{ }@var{o}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentPeer {public void} print (java.awt.Graphics@w{ }@var{graphics}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentPeer {public void} repaint (long@w{ }@var{tm}, int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{width}, int@w{ }@var{height}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentPeer {public void} requestFocus () \n+\n+@end deftypemethod\n+@deftypemethod ComponentPeer {public void} setBackground (java.awt.Color@w{ }@var{color}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentPeer {public void} setBounds (int@w{ }@var{x}, int@w{ }@var{y}, int@w{ }@var{width}, int@w{ }@var{height}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentPeer {public void} setCursor (java.awt.Cursor@w{ }@var{cursor}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentPeer {public void} setEnabled (boolean@w{ }@var{enabled}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentPeer {public void} setEventMask (long@w{ }@var{eventMask}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentPeer {public void} setFont (java.awt.Font@w{ }@var{font}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentPeer {public void} setForeground (java.awt.Color@w{ }@var{color}) \n+\n+@end deftypemethod\n+@deftypemethod ComponentPeer {public void} setVisible (boolean@w{ }@var{visible}) \n+\n+@end deftypemethod\n+@deftypemethod ContainerPeer {public Insets} getInsets () \n+\n+@end deftypemethod\n+@deftypemethod ContainerPeer {public void} beginValidate () \n+\n+@end deftypemethod\n+@deftypemethod ContainerPeer {public void} endValidate () \n+\n+@end deftypemethod\n+@deftypemethod DialogPeer {public void} setResizable (boolean@w{ }@var{resizeable}) \n+\n+@end deftypemethod\n+@deftypemethod DialogPeer {public void} setTitle (java.lang.String@w{ }@var{title}) \n+\n+@end deftypemethod\n+@deftypemethod FileDialogPeer {public void} setDirectory (java.lang.String@w{ }@var{dir}) \n+\n+@end deftypemethod\n+@deftypemethod FileDialogPeer {public void} setFile (java.lang.String@w{ }@var{file}) \n+\n+@end deftypemethod\n+@deftypemethod FileDialogPeer {public void} setFilenameFilter (java.io.FilenameFilter@w{ }@var{filter}) \n+\n+@end deftypemethod\n+@deftypemethod FramePeer {public void} setIconImage (java.awt.Image@w{ }@var{image}) \n+\n+@end deftypemethod\n+@deftypemethod FramePeer {public void} setMenuBar (java.awt.MenuBar@w{ }@var{mb}) \n+\n+@end deftypemethod\n+@deftypemethod FramePeer {public void} setResizable (boolean@w{ }@var{resizable}) \n+\n+@end deftypemethod\n+@deftypemethod FramePeer {public void} setTitle (java.lang.String@w{ }@var{title}) \n+\n+@end deftypemethod\n+@deftypemethod LabelPeer {public void} setAlignment (int@w{ }@var{alignment}) \n+\n+@end deftypemethod\n+@deftypemethod LabelPeer {public void} setText (java.lang.String@w{ }@var{text}) \n+\n+@end deftypemethod\n+@deftypemethod ListPeer {public void} add (java.lang.String@w{ }@var{item}, int@w{ }@var{index}) \n+\n+@end deftypemethod\n+@deftypemethod ListPeer {public void} delItems (int@w{ }@var{start_index}, int@w{ }@var{end_index}) \n+\n+@end deftypemethod\n+@deftypemethod ListPeer {public void} deselect (int@w{ }@var{index}) \n+\n+@end deftypemethod\n+@deftypemethod ListPeer {public int} getSelectedIndexes () \n+\n+@end deftypemethod\n+@deftypemethod ListPeer {public void} makeVisible (int@w{ }@var{index}) \n+\n+@end deftypemethod\n+@deftypemethod ListPeer {public void} removeAll () \n+\n+@end deftypemethod\n+@deftypemethod ListPeer {public void} select (int@w{ }@var{index}) \n+\n+@end deftypemethod\n+@deftypemethod ListPeer {public void} setMultipleMode (boolean@w{ }@var{multipleMode}) \n+\n+@end deftypemethod\n+@deftypemethod MenuBarPeer {public void} addHelpMenu (java.awt.Menu@w{ }@var{menu}) \n+\n+@end deftypemethod\n+@deftypemethod MenuBarPeer {public void} add (java.awt.Menu@w{ }@var{menu}) \n+\n+@end deftypemethod\n+@deftypemethod MenuBarPeer {public void} remove (int@w{ }@var{index}) \n+\n+@end deftypemethod\n+@deftypemethod MenuComponentPeer {public void} dispose () \n+\n+@end deftypemethod\n+@deftypemethod MenuItemPeer {public void} setEnabled (boolean@w{ }@var{enabled}) \n+\n+@end deftypemethod\n+@deftypemethod MenuItemPeer {public void} setLabel (java.lang.String@w{ }@var{text}) \n+\n+@end deftypemethod\n+@deftypemethod MenuPeer {public void} add (java.awt.MenuItem@w{ }@var{item}) \n+\n+@end deftypemethod\n+@deftypemethod MenuPeer {public void} addSeparator () \n+\n+@end deftypemethod\n+@deftypemethod MenuPeer {public void} remove (int@w{ }@var{index}) \n+\n+@end deftypemethod\n+@deftypemethod PopupMenuPeer {public void} show (java.awt.Event@w{ }@var{e}) \n+\n+@end deftypemethod\n+@deftypemethod ScrollbarPeer {public void} setLineIncrement (int@w{ }@var{increment}) \n+\n+@end deftypemethod\n+@deftypemethod ScrollbarPeer {public void} setPageIncrement (int@w{ }@var{increment}) \n+\n+@end deftypemethod\n+@deftypemethod ScrollbarPeer {public void} setValues (int@w{ }@var{value}, int@w{ }@var{visible}, int@w{ }@var{minimum}, int@w{ }@var{maximum}) \n+\n+@end deftypemethod\n+@deftypemethod ScrollPanePeer {public void} childResized (int@w{ }@var{width}, int@w{ }@var{height}) \n+\n+@end deftypemethod\n+@deftypemethod ScrollPanePeer {public int} getHScrollbarHeight () \n+\n+@end deftypemethod\n+@deftypemethod ScrollPanePeer {public int} getVScrollbarWidth () \n+\n+@end deftypemethod\n+@deftypemethod ScrollPanePeer {public void} setScrollPosition (int@w{ }@var{x}, int@w{ }@var{y}) \n+\n+@end deftypemethod\n+@deftypemethod ScrollPanePeer {public void} setUnitIncrement (java.awt.Adjustable@w{ }@var{adj}, int@w{ }@var{increment}) \n+\n+@end deftypemethod\n+@deftypemethod ScrollPanePeer {public void} setValue (java.awt.Adjustable@w{ }@var{adj}, int@w{ }@var{value}) \n+\n+@end deftypemethod\n+@deftypemethod TextAreaPeer {public void} insert (java.lang.String@w{ }@var{text}, int@w{ }@var{pos}) \n+\n+@end deftypemethod\n+@deftypemethod TextAreaPeer {public void} replaceRange (java.lang.String@w{ }@var{text}, int@w{ }@var{start}, int@w{ }@var{end}) \n+\n+@end deftypemethod\n+@deftypemethod TextComponentPeer {public int} getCaretPosition () \n+\n+@end deftypemethod\n+@deftypemethod TextComponentPeer {public int} getSelectionEnd () \n+\n+@end deftypemethod\n+@deftypemethod TextComponentPeer {public int} getSelectionStart () \n+\n+@end deftypemethod\n+@deftypemethod TextComponentPeer {public String} getText () \n+\n+@end deftypemethod\n+@deftypemethod TextComponentPeer {public void} select (int@w{ }@var{start}, int@w{ }@var{end}) \n+\n+@end deftypemethod\n+@deftypemethod TextComponentPeer {public void} setCaretPosition (int@w{ }@var{pos}) \n+\n+@end deftypemethod\n+@deftypemethod TextComponentPeer {public void} setEditable (boolean@w{ }@var{editable}) \n+\n+@end deftypemethod\n+@deftypemethod TextComponentPeer {public void} setText (java.lang.String@w{ }@var{text}) \n+\n+@end deftypemethod\n+@deftypemethod TextFieldPeer {public void} setEchoChar (char@w{ }@var{echo}) \n+\n+@end deftypemethod\n+@deftypemethod WindowPeer {public void} toBack () \n+\n+@end deftypemethod\n+@deftypemethod WindowPeer {public void} toFront () \n+\n+@end deftypemethod"}, {"sha": "071cd4144c531254039d466fe9ebf510286885f5", "filename": "libjava/doc/java-awt.texi", "status": "added", "additions": 2757, "deletions": 0, "changes": 2757, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2Fdoc%2Fjava-awt.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2Fdoc%2Fjava-awt.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fdoc%2Fjava-awt.texi?ref=6a9d31a7d48bbae78a24a1395199d5c4c048d642"}, {"sha": "f67328600aaa2ba9f524c59b727bb388447a4707", "filename": "libjava/doc/java-beans-beancontext.texi", "status": "added", "additions": 543, "deletions": 0, "changes": 543, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2Fdoc%2Fjava-beans-beancontext.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2Fdoc%2Fjava-beans-beancontext.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fdoc%2Fjava-beans-beancontext.texi?ref=6a9d31a7d48bbae78a24a1395199d5c4c048d642", "patch": "@@ -0,0 +1,543 @@\n+@deftypemethod BeanContextChildComponentProxy {public Component} getComponent () \n+Get the @code{Component} associated with this @code{BeanContextChild}.\n+@end deftypemethod\n+@deftypemethod BeanContextChild {public void} setBeanContext (java.beans.beancontext.BeanContext@w{ }@var{parent}) @*throws PropertyVetoException\n+Set the parent @code{BeanContext}.\n+ \n+\n+\n+\n+ This method is called from @code{BeanContext.add()} and\n+ should not be called directly.\n+ \n+\n+\n+\n+ When this Object is being added to a new BeanContext or moved\n+ from an old one, a non-null value will be passed in.\n+ \n+\n+\n+\n+ When this Object is being removed from the current\n+ @code{BeanContext}, @code{setBeanContext()} will\n+ receive the parameter @code{null}.\n+ \n+\n+\n+\n+ When being removed from the current @code{BeanContext},\n+ it is the @code{BeanContextChild}'s responsibility to\n+ release all services it has obtained.\n+ \n+\n+\n+\n+ This change should generate @code{PropertyChangeEvent}\n+ and @code{VetoableChangeEvent}s with the property name\n+ \"beanContext\".  If the change is vetoed, it must re-throw the\n+ exception and not change anything.  In this way, the parent\n+ @code{BeanContextChild}, who has registered himself with\n+ you, will have a chance to remove this child from its\n+ collection.\n+ \n+\n+\n+\n+ If the Bean does not wish to change the parent or be removed\n+ from one, it may throw the @code{PropertyVetoException}.\n+ If you veto a @code{setBeanContext(null)} call, then you\n+ should try your hardest to remedy whatever problem is keeping\n+ you from being removed from the @code{BeanContext} so\n+ that you can <em>not</em> veto it the next time.\n+ Otherwise, nasty pathological recursion stuff could occur in\n+ certain situations.\n+ \n+\n+\n+\n+ If you do veto the change, you must first back out any changes\n+ you made prior to the veto.  Best not to make any such changes\n+ prior to the veto in the first place.\n+ \n+\n+\n+\n+ This method is called from @code{BeanContext.add()} and\n+ should not be called directly.\n+@end deftypemethod\n+@deftypemethod BeanContextChild {public BeanContext} getBeanContext () \n+Get the parent @code{BeanContext}.\n+@end deftypemethod\n+@deftypemethod BeanContextChild {public void} addPropertyChangeListener (java.lang.String@w{ }@var{prop}, java.beans.PropertyChangeListener@w{ }@var{listener}) \n+Add a listener that will be notified when a specific property changes.\n+@end deftypemethod\n+@deftypemethod BeanContextChild {public void} removePropertyChangeListener (java.lang.String@w{ }@var{prop}, java.beans.PropertyChangeListener@w{ }@var{listener}) \n+Remove a listener to a certain property.\n+@end deftypemethod\n+@deftypemethod BeanContextChild {public void} addVetoableChangeListener (java.lang.String@w{ }@var{prop}, java.beans.VetoableChangeListener@w{ }@var{listener}) \n+Add a listener that will be notified when a specific property\n+ change is requested (a PropertyVetoException may be thrown) as\n+ well as after the change is successfully made.\n+@end deftypemethod\n+@deftypemethod BeanContextChild {public void} removeVetoableChangeListener (java.lang.String@w{ }@var{prop}, java.beans.VetoableChangeListener@w{ }@var{listener}) \n+Remove a listener to a certain property.\n+@end deftypemethod\n+@deftypemethod BeanContextChildSupport {public void} setBeanContext (java.beans.beancontext.BeanContext@w{ }@var{newBeanContext}) @*throws PropertyVetoException\n+Set the parent @code{BeanContext}.\n+ \n+\n+\n+\n+ When this Object is being added to a new BeanContext or moved\n+ from an old one, a non-null value will be passed in.\n+ \n+\n+\n+\n+ When this Object is being removed from the current\n+ @code{BeanContext}, @code{setBeanContext()} will\n+ receive the parameter @code{null}.\n+ \n+\n+\n+\n+ Order of events:\n+ \n+@itemize @bullet\n+\n+   \n+@item\n+\n+     If the new @code{BeanContext} is the same as the old\n+     one, nothing happens.\n+   \n+\n+   \n+@item\n+\n+     If the change has not been rejected or vetoed before, call\n+     @code{validatePendingSetBeanContext()}.  If this call\n+     returns @code{false}, the change is rejected and a\n+     @code{PropertyVetoException} is thrown.\n+   \n+\n+   \n+@item\n+\n+     If the change has not been rejected or vetoed before,\n+     @code{VetoableChangeEvent}s are fired with the name\n+     @code{\"beanContext\"}, using the\n+     @code{fireVetoableChange()} method.  If a veto\n+     occurs, reversion events are fired using the same method,\n+     the change is rejected, and the veto is rethrown.\n+   \n+\n+   \n+@item\n+\n+     @code{releaseBeanContextResources()} is called.\n+   \n+\n+   \n+@item\n+\n+     The change is made.\n+   \n+\n+   \n+@item\n+\n+     @code{PropertyChangeEvent}s are fired using the\n+     @code{firePropertyChange()} method.\n+   \n+\n+   \n+@item\n+\n+     @code{initializeBeanContextResources()} is called.\n+   \n+\n+ \n+@end itemize\n+\n+ \n+\n+\n+@end deftypemethod\n+@deftypemethod BeanContextChildSupport {public BeanContext} getBeanContext () \n+Get the parent @code{BeanContext}.\n+@end deftypemethod\n+@deftypemethod BeanContextChildSupport {public BeanContextChild} getBeanContextChildPeer () \n+Get the peer (or @code{this} if there is no peer).\n+@end deftypemethod\n+@deftypemethod BeanContextChildSupport {public boolean} isDelegated () \n+Determine whether there is a peer.\n+ This is true iff @code{getBeanContextChildPeer() == this}.\n+@end deftypemethod\n+@deftypemethod BeanContextChildSupport {public void} addPropertyChangeListener (java.lang.String@w{ }@var{propertyName}, java.beans.PropertyChangeListener@w{ }@var{listener}) \n+Add a listener that will be notified when a specific property changes.\n+@end deftypemethod\n+@deftypemethod BeanContextChildSupport {public void} removePropertyChangeListener (java.lang.String@w{ }@var{propertyName}, java.beans.PropertyChangeListener@w{ }@var{listener}) \n+Remove a listener to a certain property.\n+@end deftypemethod\n+@deftypemethod BeanContextChildSupport {public void} addVetoableChangeListener (java.lang.String@w{ }@var{propertyName}, java.beans.VetoableChangeListener@w{ }@var{listener}) \n+Add a listener that will be notified when a specific property\n+ change is requested (a PropertyVetoException may be thrown) as\n+ well as after the change is successfully made.\n+@end deftypemethod\n+@deftypemethod BeanContextChildSupport {public void} removeVetoableChangeListener (java.lang.String@w{ }@var{propertyName}, java.beans.VetoableChangeListener@w{ }@var{listener}) \n+Remove a listener to a certain property.\n+@end deftypemethod\n+@deftypemethod BeanContextChildSupport {public void} firePropertyChange (java.lang.String@w{ }@var{propertyName}, java.lang.Object@w{ }@var{oldVal}, java.lang.Object@w{ }@var{newVal}) \n+Fire a property change.\n+@end deftypemethod\n+@deftypemethod BeanContextChildSupport {public void} fireVetoableChange (java.lang.String@w{ }@var{propertyName}, java.lang.Object@w{ }@var{oldVal}, java.lang.Object@w{ }@var{newVal}) @*throws PropertyVetoException\n+Fire a vetoable property change.\n+@end deftypemethod\n+@deftypemethod BeanContextChildSupport {public void} serviceRevoked (java.beans.beancontext.BeanContextServiceRevokedEvent@w{ }@var{event}) \n+Called by @code{BeanContextServices.revokeService()} to indicate that a service has been revoked.\n+ If you have a reference to such a service, it should be\n+ discarded and may no longer function properly.\n+ @code{getService()} will no longer work on the specified\n+ service class after this event has been fired.\n+ \n+\n+\n+\n+ <EM>This method is meant to be overriden.</EM>\n+ @code{BeanContextChildSupport}'s implementation does\n+ nothing.\n+@end deftypemethod\n+@deftypemethod BeanContextChildSupport {public void} serviceAvailable (java.beans.beancontext.BeanContextServiceAvailableEvent@w{ }@var{event}) \n+Called by @code{BeanContextServices} whenever a service is made available.\n+ \n+\n+\n+\n+ <EM>This method is meant to be overriden.</EM>\n+ @code{BeanContextChildSupport}'s implementation does\n+ nothing.\n+@end deftypemethod\n+@deftypemethod BeanContextChildSupport {public boolean} validatePendingSetBeanContext (java.beans.beancontext.BeanContext@w{ }@var{newBeanContext}) \n+Called by @code{setBeanContext()} to determine whether the set should be rejected.\n+ \n+\n+\n+\n+ <EM>This method is meant to be overriden.</EM>\n+ @code{BeanContextChildSupport}'s implementation simply\n+ returns @code{true}.\n+@end deftypemethod\n+@deftypemethod BeanContextChildSupport {protected void} releaseBeanContextResources () \n+Called by @code{setBeanContext()} to release resources of a what will soon no longer be the parent.\n+ \n+\n+\n+\n+ <EM>This method is meant to be overriden.</EM>\n+ @code{BeanContextChildSupport}'s implementation does\n+ nothing.\n+@end deftypemethod\n+@deftypemethod BeanContextChildSupport {protected void} initializeBeanContextResources () \n+Called by @code{setBeanContext()} to grab resources when the parent has been set.\n+ \n+\n+\n+\n+ <EM>This method is meant to be overriden.</EM>\n+ @code{BeanContextChildSupport}'s implementation does\n+ nothing.\n+@end deftypemethod\n+@deftypemethod BeanContextContainerProxy {public Container} getContainer () \n+Get the @code{Container} associated with this @code{BeanContext}.\n+@end deftypemethod\n+@deftypemethod BeanContextEvent {public BeanContext} getBeanContext () \n+Get the @code{BeanContext} that originated this event.\n+@end deftypemethod\n+@deftypemethod BeanContextEvent {public BeanContext} getPropagatedFrom () \n+Get the most recent propagator of this event.\n+ If this value is @code{null}, you have received the event\n+ straight from the source.\n+@end deftypemethod\n+@deftypemethod BeanContextEvent {public boolean} isPropagated () \n+Tell whether this event has been propagated.\n+@end deftypemethod\n+@deftypemethod BeanContextEvent {public void} setPropagatedFrom (java.beans.beancontext.BeanContext@w{ }@var{propagator}) \n+Set the most recent propagator of this event.\n+@end deftypemethod\n+@deftypemethod BeanContext {public Object} instantiateChild (java.lang.String@w{ }@var{beanName}) @*throws IOException, ClassNotFoundException\n+Instantiate a Bean using this Bean's @code{ClassLoader}\n+ and this @code{BeanContext} as the parent.\n+ \n+\n+\n+\n+ This method exists mainly so that @code{BeanContext}\n+ implementations can perform extra actions on Beans that are\n+ created within them.\n+@end deftypemethod\n+@deftypemethod BeanContext {public URL} getResource (java.lang.String@w{ }@var{resourceName}, java.beans.beancontext.BeanContextChild@w{ }@var{requestor}) \n+Get a resource.  The @code{BeanContext} will typically\n+ call @code{ClassLoader.getResource()}, but may do it any\n+ way it wants to.  This allows a @code{BeanContext} to\n+ have its own set of resources separate from the rest of the\n+ system.\n+ \n+\n+\n+\n+ Beans should call this method on their parent rather than the\n+ associated @code{ClassLoader} method.\n+ \n+\n+\n+\n+ I am assuming, but am not entirely sure, that if a\n+ @code{BeanContext} cannot find a resource, its\n+ responsibility is to call the @code{getResource} method\n+ of its parent @code{BeanContext}.\n+@end deftypemethod\n+@deftypemethod BeanContext {public InputStream} getResourceAsStream (java.lang.String@w{ }@var{resourceName}, java.beans.beancontext.BeanContextChild@w{ }@var{requestor}) \n+Get a resource as a stream.  The @code{BeanContext} will\n+ typically call @code{ClassLoader.getResourceAsStream()},\n+ but may do it any way it wants to.  This allows a\n+ @code{BeanContext}'s children to have their own set of\n+ resources separate from the rest of the system.\n+ \n+\n+\n+\n+ Beans should call this method on their parent rather than the\n+ associated @code{ClassLoader} method.\n+ \n+\n+\n+\n+ I am assuming, but am not entirely sure, that if a\n+ @code{BeanContext} cannot find a resource, its\n+ responsibility is to call the @code{getResourceAsStream}\n+ method of its parent @code{BeanContext}.\n+@end deftypemethod\n+@deftypemethod BeanContext {public void} addBeanContextMembershipListener (java.beans.beancontext.BeanContextMembershipListener@w{ }@var{listener}) \n+Add a listener on changes to the membership of this\n+ @code{BeanContext} object.\n+@end deftypemethod\n+@deftypemethod BeanContext {public void} removeBeanContextMembershipListener (java.beans.beancontext.BeanContextMembershipListener@w{ }@var{listener}) \n+Remove a listener on changes to the membership of this\n+ @code{BeanContext} object.\n+@end deftypemethod\n+@deftypemethod BeanContextMembershipEvent {public int} size () \n+The number of children removed or added.\n+@end deftypemethod\n+@deftypemethod BeanContextMembershipEvent {public Iterator} iterator () \n+An iterator that will step through all the children.\n+@end deftypemethod\n+@deftypemethod BeanContextMembershipEvent {public Object} toArray () \n+An array of the children.\n+@end deftypemethod\n+@deftypemethod BeanContextMembershipEvent {public boolean} contains (java.lang.Object@w{ }@var{child}) \n+Tell whether the @code{Object} is one of the children added or removed.\n+@end deftypemethod\n+@deftypemethod BeanContextMembershipListener {public void} childrenAdded (java.beans.beancontext.BeanContextMembershipEvent@w{ }@var{event}) \n+When beans are added to a @code{BeanContext},\n+ this method is called to fire the event.\n+@end deftypemethod\n+@deftypemethod BeanContextMembershipListener {public void} childrenRemoved (java.beans.beancontext.BeanContextMembershipEvent@w{ }@var{event}) \n+When beans are removed from a @code{BeanContext},\n+ this method is called to fire the event.\n+@end deftypemethod\n+@deftypemethod BeanContextProxy {public BeanContextChild} getBeanContextProxy () \n+Return the @code{BeanContextChild} associated with this\n+ @code{Object}.\n+@end deftypemethod\n+@deftypemethod BeanContextServiceAvailableEvent {public Iterator} getCurrentServiceSelectors () \n+Get the current service selectors of the service class.\n+ This is identical to @code{getSourceAsBeanContextServices().getCurrentServiceSelectors(getServiceClass())}\n+@end deftypemethod\n+@deftypemethod BeanContextServiceAvailableEvent {public Class} getServiceClass () \n+Get the newly available service class.\n+@end deftypemethod\n+@deftypemethod BeanContextServiceAvailableEvent {public BeanContextServices} getSourceAsBeanContextServices () \n+Get the @code{BeanContextServices} through which the new service is available.\n+@end deftypemethod\n+@deftypemethod BeanContextServiceProviderBeanInfo {public BeanInfo} getServicesBeanInfo () \n+Get @code{BeanInfo}s for all of the service classes of this @code{BeanInfoServiceProvider}.\n+@end deftypemethod\n+@deftypemethod BeanContextServiceProvider {public Object} getService (java.beans.beancontext.BeanContextServices@w{ }@var{services}, java.lang.Object@w{ }@var{requestor}, java.lang.Class@w{ }@var{serviceClass}, java.lang.Object@w{ }@var{serviceSelector}) \n+Get a service.\n+ Called from @code{BeanContextServices.getService().\n+ \n+\n+\n+\n+ If the requested service class is not available, or if this\n+ @code{BeanContextServiceProvider} chooses not honor the\n+ request for some reason, then this method will return\n+ @code{null}.\n+ \n+\n+\n+\n+ This method may throw unchecked exceptions, so watch out.\n+@end deftypemethod\n+@deftypemethod BeanContextServiceProvider {public void} releaseService (java.beans.beancontext.BeanContextServices@w{ }@var{services}, java.lang.Object@w{ }@var{requestor}, java.lang.Object@w{ }@var{service}) \n+Release the service.\n+ \n+\n+\n+\n+ Called by @code{BeanContextServices.releaseService()}.\n+ \n+\n+\n+\n+ Most @code{BeanContextServiceProvider}s won't have to do\n+ anything here.\n+@end deftypemethod\n+@deftypemethod BeanContextServiceProvider {public Iterator} getCurrentServiceSelectors (java.beans.beancontext.BeanContextServices@w{ }@var{services}, java.lang.Class@w{ }@var{serviceClass}) \n+Get a list of valid service selectors for the specified service class.\n+ This method is called from\n+ @code{BeanContextServices.getCurrentServiceSelectors()}.\n+ \n+\n+\n+\n+ If the specified service class does not have a finite number of\n+ valid service selectors, it should return @code{null}.\n+ If it takes a general @code{Integer} parameter, for\n+ example, you may as well return @code{null} or the poor\n+ soul who called this method will be iterating all day.\n+ \n+\n+\n+\n+ If it has no valid service selectors, it should still return an empty\n+ @code{Iterator}.\n+@end deftypemethod\n+@deftypemethod BeanContextServiceRevokedEvent {public Class} getServiceClass () \n+Get the revoked service class.\n+@end deftypemethod\n+@deftypemethod BeanContextServiceRevokedEvent {public boolean} isServiceClass (java.lang.Class@w{ }@var{c}) \n+Tell whether the revoked service class is the same as the specified class.\n+ Identical to @code{getServiceClass().equals(c)}.\n+@end deftypemethod\n+@deftypemethod BeanContextServiceRevokedEvent {public BeanContextServices} getSourceAsBeanContextServices () \n+Get the @code{BeanContextServices} through which the service was available.\n+@end deftypemethod\n+@deftypemethod BeanContextServiceRevokedEvent {public boolean} isCurrentServiceInvalidNow () \n+Tell whether current instances of the revoked service are usable or not.\n+ This is determined by whether the service was revoked\n+ immediately.\n+@end deftypemethod\n+@deftypemethod BeanContextServiceRevokedListener {public void} serviceRevoked (java.beans.beancontext.BeanContextServiceRevokedEvent@w{ }@var{event}) \n+Called by @code{BeanContextServices.revokeService()} to indicate that a service has been revoked.\n+ If you have a reference to such a service, it should be\n+ discarded and may no longer function properly.\n+ @code{getService()} will no longer work on the specified\n+ service class after this event has been fired.\n+@end deftypemethod\n+@deftypemethod BeanContextServices {public boolean} addService (java.lang.Class@w{ }@var{serviceClass}, java.beans.beancontext.BeanContextServiceProvider@w{ }@var{provider}) \n+Register a service to make it available to others.\n+ This class may refuse to add the service based on whatever\n+ information it can gather, including whether the service\n+ provider is trusted.\n+@end deftypemethod\n+@deftypemethod BeanContextServices {public void} revokeService (java.lang.Class@w{ }@var{serviceClass}, java.beans.beancontext.BeanContextServiceProvider@w{ }@var{provider}, boolean@w{ }@var{revokeNow}) \n+Make it so that no one else can use this service.\n+ \n+\n+\n+\n+ If @code{revokeNow} is @code{false}, the only\n+ effect of this method is to make all subsequent calls to\n+ @code{getService()} on this service class fail.\n+ \n+\n+\n+\n+ If it is @code{true}, a message is also sent out to all\n+ listeners on the service and all references to it are released.\n+@end deftypemethod\n+@deftypemethod BeanContextServices {public void} releaseService (java.beans.beancontext.BeanContextChild@w{ }@var{requestorChild}, java.lang.Object@w{ }@var{requestor}, java.lang.Object@w{ }@var{service}) \n+Release your copy of this service.\n+ \n+\n+\n+\n+ If all copies of the service's class have been relinquished by\n+ the requestor, the @code{BeanContextServiceRevokedListener}\n+ previously registered by @code{getService()} will be\n+ unregistered.\n+@end deftypemethod\n+@deftypemethod BeanContextServices {public Object} getService (java.beans.beancontext.BeanContextChild@w{ }@var{requestorChild}, java.lang.Object@w{ }@var{requestor}, java.lang.Class@w{ }@var{serviceClass}, java.lang.Object@w{ }@var{serviceSelector}, java.beans.beancontext.BeanContextServiceRevokedListener@w{ }@var{listener}) \n+Get a service from this @code{BeanContextServices}.\n+ \n+\n+\n+\n+ The specified listener will be registered to receive a\n+ revocation notice for the specified serviceClass.  One\n+ notification per service class per requestor object will be\n+ sent.\n+ \n+\n+\n+\n+ The listener will be unregistered when all services that were\n+ obtained by that requestor for that service class are released.\n+ \n+\n+\n+\n+ If the requested service class is not available, or if this\n+ @code{BeanContextServices} object chooses not honor the\n+ request because the service class has been revoked or for some\n+ other reason, then this method will return @code{null}.\n+ \n+\n+\n+\n+ This method may throw unchecked exceptions, so watch out.\n+@end deftypemethod\n+@deftypemethod BeanContextServices {public Iterator} getCurrentServiceClasses () \n+Get a list of all service classes supported.\n+ \n+\n+\n+\n+ This method must synchronize on\n+ @code{BeanContext.globalHierarchyLock}.\n+@end deftypemethod\n+@deftypemethod BeanContextServices {public Iterator} getCurrentServiceSelectors (java.lang.Class@w{ }@var{serviceClass}) \n+Get a list of valid service selectors for the specified service class.\n+ \n+\n+\n+\n+ If the specified service class does not have a finite number of\n+ valid service selectors, it should return @code{null}.\n+ If it takes a general @code{Integer} parameter, for\n+ example, you may as well return @code{null} or the poor\n+ soul who called this method will be iterating all day.\n+ \n+\n+\n+\n+ If it has no valid service selectors, it should still return an empty\n+ @code{Iterator}.\n+@end deftypemethod\n+@deftypemethod BeanContextServices {public boolean} hasService (java.lang.Class@w{ }@var{serviceClass}) \n+Tell whether the specified service class is available.\n+ Iff getService() could return a non-null value for the\n+ specified service, this method will return @code{true}.\n+@end deftypemethod\n+@deftypemethod BeanContextServices {public void} addBeanContextServicesListener (java.beans.beancontext.BeanContextServicesListener@w{ }@var{listener}) \n+Add a listener on all adds and removes of services.\n+@end deftypemethod\n+@deftypemethod BeanContextServices {public void} removeBeanContextServicesListener (java.beans.beancontext.BeanContextServicesListener@w{ }@var{listener}) \n+Remove a listener on all adds and removes of services.\n+@end deftypemethod\n+@deftypemethod BeanContextServicesListener {public void} serviceAvailable (java.beans.beancontext.BeanContextServiceAvailableEvent@w{ }@var{event}) \n+Called by @code{BeanContextServices} whenever a service is made available.\n+@end deftypemethod"}, {"sha": "2b8887181eedbf0b85298a06dc28b6a7c8ef3c41", "filename": "libjava/doc/java-beans.texi", "status": "added", "additions": 810, "deletions": 0, "changes": 810, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2Fdoc%2Fjava-beans.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2Fdoc%2Fjava-beans.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fdoc%2Fjava-beans.texi?ref=6a9d31a7d48bbae78a24a1395199d5c4c048d642", "patch": "@@ -0,0 +1,810 @@\n+@deftypemethod BeanDescriptor {public Class} getBeanClass () \n+Get the Bean's class.\n+@end deftypemethod\n+@deftypemethod BeanDescriptor {public Class} getCustomizerClass () \n+Get the Bean's customizer's class.\n+@end deftypemethod\n+@deftypemethod BeanInfo {public BeanDescriptor} getBeanDescriptor () \n+Get the general description of this Bean type.\n+@end deftypemethod\n+@deftypemethod BeanInfo {public EventSetDescriptor} getEventSetDescriptors () \n+Get the events this Bean type fires.\n+@end deftypemethod\n+@deftypemethod BeanInfo {public int} getDefaultEventIndex () \n+Get the \"default\" event, basically the one a RAD tool\n+ user is most likely to select.\n+@end deftypemethod\n+@deftypemethod BeanInfo {public PropertyDescriptor} getPropertyDescriptors () \n+Get the properties (get/set method pairs) this Bean\n+ type supports.\n+@end deftypemethod\n+@deftypemethod BeanInfo {public int} getDefaultPropertyIndex () \n+Get the \"default\" property, basically the one a RAD\n+ tool user is most likely to select.\n+@end deftypemethod\n+@deftypemethod BeanInfo {public MethodDescriptor} getMethodDescriptors () \n+Get the methods this Bean type supports.\n+@end deftypemethod\n+@deftypemethod BeanInfo {public BeanInfo} getAdditionalBeanInfo () \n+Get additional BeanInfos representing this Bean.\n+ In this version of JavaBeans, this method is used so\n+ that space and time can be saved by reading a BeanInfo\n+ for each class in the hierarchy (super, super(super),\n+ and so on).\n+\n+\n+\n+ The order of precedence when two pieces of BeanInfo\n+ conflict (such as two PropertyDescriptors that have\n+ the same name), in order from highest precedence to\n+ lowest, is:\n+ \n+@itemize @bullet\n+\n+ \n+@item\n+This BeanInfo object.\n+\n+ \n+@item\n+@code{getAdditionalBeanInfo()[getAdditionalBeanInfo().length]}\n+\n+ \n+@item\n+ ... \n+\n+ \n+@item\n+@code{getAdditionalBeanInfo()[1]}\n+\n+ \n+@item\n+@code{getAdditionalBeanInfo()[0]}\n+\n+ \n+@end itemize\n+\n+\n+\n+\n+ <STRONG>Spec Note:</STRONG> It is possible that\n+ returning @code{null} from this method could\n+ stop Introspection in its tracks, but it is unclear\n+ from the spec whether this is the case.\n+@end deftypemethod\n+@deftypemethod BeanInfo {public Image} getIcon (int@w{ }@var{iconType}) \n+Get a visual icon for this Bean.\n+ A Bean does not have to support icons, and if it does\n+ support icons, it does not have to support every single\n+ type.  Sun recommends that if you only support one\n+ type, you support 16x16 color.  Sun also notes that you\n+ should try to use a type (like GIF) that allows for\n+ transparent pixels, so that the background of the RAD\n+ tool can show through.\n+\n+\n+\n+ <STRONG>Spec Note:</STRONG> If you do not support the\n+ type of icon that is being asked for, but you do\n+ support another type, it is unclear whether you should\n+ return the other type or not.  I would presume not.\n+@end deftypemethod\n+@deftypemethod Beans {public static Object} instantiate (java.lang.ClassLoader@w{ }@var{cl}, java.lang.String@w{ }@var{beanName}) @*throws IOException, ClassNotFoundException\n+Allows you to instantiate a Bean.  This method takes\n+ a ClassLoader from which to read the Bean and the\n+ name of the Bean.\n+\n+\n+\n+ The Bean name should be a dotted name, like a class.\n+ It can represent several things.  Beans will search\n+ for the Bean using the name like this:\n+\n+\n+ \n+@itemize @bullet\n+\n+ \n+@item\n+Searches for a serialized instance of the Bean\n+ using getResource(), mangling the Bean name by\n+ replacing the dots with slashes and appending .ser\n+ (for example, gnu.beans.BlahDeBlah would cause\n+ Beans to search for gnu/beans/BlahDeBlah.ser using\n+ getResource()).\n+\n+ \n+@item\n+Searches for the Bean class using the beanName,\n+ and then instantiates it with the no-arg constructor.\n+ At that point, if it is an Applet, it provides it\n+ with AppletContext and AppletStub, and then calls\n+ init().\n+\n+ \n+@end itemize\n+\n+@end deftypemethod\n+@deftypemethod Beans {public static Object} getInstanceOf (java.lang.Object@w{ }@var{bean}, java.lang.Class@w{ }@var{newClass}) \n+Get the Bean as a different class type.\n+ This should be used instead of casting to get a new\n+ type view of a Bean, because in the future there may\n+ be new types of Bean, even Beans spanning multiple\n+ Objects.\n+@end deftypemethod\n+@deftypemethod Beans {public static boolean} isInstanceOf (java.lang.Object@w{ }@var{bean}, java.lang.Class@w{ }@var{newBeanClass}) \n+Determine whether the Bean can be cast to a different\n+ class type.\n+ This should be used instead of instanceof to determine\n+ a Bean's castability, because in the future there may\n+ be new types of Bean, even Beans spanning multiple\n+ Objects.\n+@end deftypemethod\n+@deftypemethod Beans {public static boolean} isGuiAvailable () \n+Find out whether the GUI is available to use.\n+ Defaults to true.\n+@end deftypemethod\n+@deftypemethod Beans {public static boolean} isDesignTime () \n+Find out whether it is design time.  Design time means\n+ we are in a RAD tool.\n+ Defaults to false.\n+@end deftypemethod\n+@deftypemethod Beans {public static void} setGuiAvailable (boolean@w{ }@var{guiAvailable}) @*throws SecurityException\n+Set whether the GUI is available to use.\n+@end deftypemethod\n+@deftypemethod Beans {public static void} setDesignTime (boolean@w{ }@var{designTime}) @*throws SecurityException\n+Set whether it is design time.  Design time means we\n+ are in a RAD tool.\n+@end deftypemethod\n+@deftypemethod Customizer {public void} setObject (java.lang.Object@w{ }@var{bean}) \n+Set the object to Customize.  This will always be a\n+ Bean that had a BeanDescriptor indicating this\n+ Customizer.\n+@end deftypemethod\n+@deftypemethod Customizer {public void} addPropertyChangeListener (java.beans.PropertyChangeListener@w{ }@var{l}) \n+Add a PropertyChangeListener.\n+@end deftypemethod\n+@deftypemethod Customizer {public void} removePropertyChangeListener (java.beans.PropertyChangeListener@w{ }@var{l}) \n+Remove a PropertyChangeListener.\n+@end deftypemethod\n+@deftypemethod DesignMode {public void} setDesignTime (boolean@w{ }@var{designTime}) \n+The environment will call this method on your\n+ @code{BeanContextChild} when it is registered in a parent\n+ @code{BeanContext} or when behavior needs to switch from\n+ design time to runtime behavior (or vice versa).\n+ \n+\n+\n+\n+ @code{BeanContext}s are required to fire\n+ @code{PropertyChangeEvent}s when properties change.\n+ @code{designTime} is a property, and therefore when you\n+ implement @code{setDesignTime()}, you need to fire a\n+ @code{PropertyChangeEvent} with the old value, the new\n+ value and using @code{PROPERTYNAME} as the property name.\n+@end deftypemethod\n+@deftypemethod DesignMode {public boolean} isDesignTime () \n+This method should tell whether it is design time or runtime.\n+@end deftypemethod\n+@deftypemethod EventSetDescriptor {public Class} getListenerType () \n+Get the class that contains the event firing methods.\n+@end deftypemethod\n+@deftypemethod EventSetDescriptor {public Method} getListenerMethods () \n+Get the event firing methods.\n+@end deftypemethod\n+@deftypemethod EventSetDescriptor {public MethodDescriptor} getListenerMethodDescriptors () \n+Get the event firing methods as MethodDescriptors.\n+@end deftypemethod\n+@deftypemethod EventSetDescriptor {public Method} getAddListenerMethod () \n+Get the add listener method.\n+@end deftypemethod\n+@deftypemethod EventSetDescriptor {public Method} getRemoveListenerMethod () \n+Get the remove listener method.\n+@end deftypemethod\n+@deftypemethod EventSetDescriptor {public void} setUnicast (boolean@w{ }@var{unicast}) \n+Set whether or not multiple listeners may be added.\n+@end deftypemethod\n+@deftypemethod EventSetDescriptor {public boolean} isUnicast () \n+Get whether or not multiple listeners may be added.  (Defaults to false.)\n+@end deftypemethod\n+@deftypemethod EventSetDescriptor {public void} setInDefaultEventSet (boolean@w{ }@var{inDefaultEventSet}) \n+Set whether or not this is in the default event set.\n+@end deftypemethod\n+@deftypemethod EventSetDescriptor {public boolean} isInDefaultEventSet () \n+Get whether or not this is in the default event set.  (Defaults to true.)\n+@end deftypemethod\n+@deftypemethod FeatureDescriptor {public String} getName () \n+Get the programmatic name of this feature.\n+@end deftypemethod\n+@deftypemethod FeatureDescriptor {public void} setName (java.lang.String@w{ }@var{name}) \n+Set the programmatic name of this feature.\n+@end deftypemethod\n+@deftypemethod FeatureDescriptor {public String} getDisplayName () \n+Get the localized (display) name of this feature.\n+@end deftypemethod\n+@deftypemethod FeatureDescriptor {public void} setDisplayName (java.lang.String@w{ }@var{displayName}) \n+Set the localized (display) name of this feature.\n+@end deftypemethod\n+@deftypemethod FeatureDescriptor {public String} getShortDescription () \n+Get the localized short description for this feature.\n+@end deftypemethod\n+@deftypemethod FeatureDescriptor {public void} setShortDescription (java.lang.String@w{ }@var{shortDescription}) \n+Set the localized short description for this feature.\n+@end deftypemethod\n+@deftypemethod FeatureDescriptor {public boolean} isExpert () \n+Indicates whether this feature is for expert use only.\n+@end deftypemethod\n+@deftypemethod FeatureDescriptor {public void} setExpert (boolean@w{ }@var{expert}) \n+Set whether this feature is for expert use only.\n+@end deftypemethod\n+@deftypemethod FeatureDescriptor {public boolean} isHidden () \n+Indicates whether this feature is for use by tools only.\n+ If it is for use by tools only, then it should not be displayed.\n+@end deftypemethod\n+@deftypemethod FeatureDescriptor {public void} setHidden (boolean@w{ }@var{hidden}) \n+Set whether this feature is for use by tools only.\n+ If it is for use by tools only, then it should not be displayed.\n+@end deftypemethod\n+@deftypemethod FeatureDescriptor {public Object} getValue (java.lang.String@w{ }@var{name}) \n+Get an arbitrary value set with setValue().\n+@end deftypemethod\n+@deftypemethod FeatureDescriptor {public void} setValue (java.lang.String@w{ }@var{name}, java.lang.Object@w{ }@var{value}) \n+Set an arbitrary string-value pair with this feature.\n+@end deftypemethod\n+@deftypemethod FeatureDescriptor {public Enumeration} attributeNames () \n+Get a list of the programmatic key names set with setValue().\n+@end deftypemethod\n+@deftypemethod IndexedPropertyDescriptor {public Class} getIndexedPropertyType () \n+\n+@end deftypemethod\n+@deftypemethod IndexedPropertyDescriptor {public Method} getIndexedReadMethod () \n+\n+@end deftypemethod\n+@deftypemethod IndexedPropertyDescriptor {public Method} getIndexedWriteMethod () \n+\n+@end deftypemethod\n+@deftypemethod Introspector {public static BeanInfo} getBeanInfo (java.lang.Class@w{ }@var{beanClass}) @*throws IntrospectionException\n+Get the BeanInfo for class @code{beanClass},\n+ first by looking for explicit information, next by\n+ using standard design patterns to determine\n+ information about the class.\n+@end deftypemethod\n+@deftypemethod Introspector {public static BeanInfo} getBeanInfo (java.lang.Class@w{ }@var{beanClass}, java.lang.Class@w{ }@var{stopClass}) @*throws IntrospectionException\n+Get the BeanInfo for class @code{beanClass},\n+ first by looking for explicit information, next by\n+ using standard design patterns to determine\n+ information about the class.  It crawls up the\n+ inheritance tree until it hits @code{topClass}.\n+@end deftypemethod\n+@deftypemethod Introspector {public static String} getBeanInfoSearchPath () \n+Get the search path for BeanInfo classes.\n+@end deftypemethod\n+@deftypemethod Introspector {public static void} setBeanInfoSearchPath (java.lang.String[]@w{ }@var{beanInfoSearchPath}) \n+Set the search path for BeanInfo classes.\n+@end deftypemethod\n+@deftypemethod Introspector {public static String} decapitalize (java.lang.String@w{ }@var{name}) \n+A helper method to convert a name to standard Java\n+ naming conventions: anything with two capitals as the\n+ first two letters remains the same, otherwise the\n+ first letter is decapitalized.  URL = URL, I = i,\n+ MyMethod = myMethod.\n+@end deftypemethod\n+@deftypemethod MethodDescriptor {public ParameterDescriptor} getParameterDescriptors () \n+Get the parameter descriptors from this method.\n+ Since MethodDescriptor has no way of determining what\n+ the parameter names were, this defaults to null.\n+@end deftypemethod\n+@deftypemethod MethodDescriptor {public Method} getMethod () \n+Get the method this MethodDescriptor represents.\n+@end deftypemethod\n+@deftypemethod PropertyChangeEvent {public String} getPropertyName () \n+Get the property name.\n+@end deftypemethod\n+@deftypemethod PropertyChangeEvent {public Object} getOldValue () \n+Get the property's old value.\n+@end deftypemethod\n+@deftypemethod PropertyChangeEvent {public Object} getNewValue () \n+Get the property's new value.\n+@end deftypemethod\n+@deftypemethod PropertyChangeEvent {public void} setPropagationId (java.lang.Object@w{ }@var{propagationId}) \n+Set the propagation ID.  This is a way for the event\n+ to be passed from hand to hand and retain a little\n+ extra state.  Right now it is unused, but it should\n+ be propagated anyway so that future versions of\n+ JavaBeans can use it, for God knows what.\n+@end deftypemethod\n+@deftypemethod PropertyChangeEvent {public Object} getPropagationId () \n+Get the propagation ID.\n+@end deftypemethod\n+@deftypemethod PropertyChangeListener {public void} propertyChange (java.beans.PropertyChangeEvent@w{ }@var{e}) \n+Fired after a Bean's property has changed.\n+@end deftypemethod\n+@deftypemethod PropertyChangeSupport {public void} addPropertyChangeListener (java.beans.PropertyChangeListener@w{ }@var{l}) \n+Adds a PropertyChangeListener to the list of listeners.\n+ All property change events will be sent to this listener.\n+ \n+\n+\n+\n+ The listener add is not unique: that is, <em>n</em> adds with\n+ the same listener will result in <em>n</em> events being sent\n+ to that listener for every property change.\n+ \n+\n+\n+\n+ Adding a null listener will cause undefined behavior.\n+@end deftypemethod\n+@deftypemethod PropertyChangeSupport {public void} addPropertyChangeListener (java.lang.String@w{ }@var{propertyName}, java.beans.PropertyChangeListener@w{ }@var{l}) \n+Adds a PropertyChangeListener listening on the specified property.\n+ Events will be sent to the listener for that particular property.\n+ \n+\n+\n+\n+ The listener add is not unique; that is, <em>n</em> adds on a\n+ particular property for a particular listener will result in\n+ <em>n</em> events being sent to that listener when that\n+ property is changed.\n+ \n+\n+\n+\n+ The effect is cumulative, too; if you are registered to listen\n+ to receive events on all property changes, and then you\n+ register on a particular property, you will receive change\n+ events for that property twice.\n+ \n+\n+\n+\n+ Adding a null listener will cause undefined behavior.\n+@end deftypemethod\n+@deftypemethod PropertyChangeSupport {public void} removePropertyChangeListener (java.beans.PropertyChangeListener@w{ }@var{l}) \n+Removes a PropertyChangeListener from the list of listeners.\n+ If any specific properties are being listened on, they must\n+ be deregistered by themselves; this will only remove the\n+ general listener to all properties.\n+ \n+\n+\n+\n+ If @code{add()} has been called multiple times for a\n+ particular listener, @code{remove()} will have to be\n+ called the same number of times to deregister it.\n+@end deftypemethod\n+@deftypemethod PropertyChangeSupport {public void} removePropertyChangeListener (java.lang.String@w{ }@var{propertyName}, java.beans.PropertyChangeListener@w{ }@var{l}) \n+Removes a PropertyChangeListener from listening to a specific property.\n+ \n+\n+\n+\n+ If @code{add()} has been called multiple times for a\n+ particular listener on a property, @code{remove()} will\n+ have to be called the same number of times to deregister it.\n+@end deftypemethod\n+@deftypemethod PropertyChangeSupport {public void} firePropertyChange (java.beans.PropertyChangeEvent@w{ }@var{event}) \n+Fire a PropertyChangeEvent to all the listeners.\n+@end deftypemethod\n+@deftypemethod PropertyChangeSupport {public void} firePropertyChange (java.lang.String@w{ }@var{propertyName}, java.lang.Object@w{ }@var{oldVal}, java.lang.Object@w{ }@var{newVal}) \n+Fire a PropertyChangeEvent containing the old and new values of the property to all the listeners.\n+@end deftypemethod\n+@deftypemethod PropertyChangeSupport {public void} firePropertyChange (java.lang.String@w{ }@var{propertyName}, boolean@w{ }@var{oldVal}, boolean@w{ }@var{newVal}) \n+Fire a PropertyChangeEvent containing the old and new values of the property to all the listeners.\n+@end deftypemethod\n+@deftypemethod PropertyChangeSupport {public void} firePropertyChange (java.lang.String@w{ }@var{propertyName}, int@w{ }@var{oldVal}, int@w{ }@var{newVal}) \n+Fire a PropertyChangeEvent containing the old and new values of the property to all the listeners.\n+@end deftypemethod\n+@deftypemethod PropertyChangeSupport {public boolean} hasListeners (java.lang.String@w{ }@var{propertyName}) \n+Tell whether the specified property is being listened on or not.\n+ This will only return @code{true} if there are listeners\n+ on all properties or if there is a listener specifically on this\n+ property.\n+@end deftypemethod\n+@deftypemethod PropertyDescriptor {public Class} getPropertyType () \n+Get the property type.\n+ This is the type the get method returns and the set method\n+ takes in.\n+@end deftypemethod\n+@deftypemethod PropertyDescriptor {public Method} getReadMethod () \n+Get the get method.  Why they call it readMethod here and\n+ get everywhere else is beyond me.\n+@end deftypemethod\n+@deftypemethod PropertyDescriptor {public Method} getWriteMethod () \n+Get the set method.  Why they call it writeMethod here and\n+ set everywhere else is beyond me.\n+@end deftypemethod\n+@deftypemethod PropertyDescriptor {public boolean} isBound () \n+Get whether the property is bound.  Defaults to false.\n+@end deftypemethod\n+@deftypemethod PropertyDescriptor {public void} setBound (boolean@w{ }@var{bound}) \n+Set whether the property is bound.\n+ As long as the the bean implements addPropertyChangeListener() and\n+ removePropertyChangeListener(), setBound(true) may safely be called.\n+\n+\n+ If these things are not true, then the behavior of the system\n+ will be undefined.\n+\n+\n+\n+ When a property is bound, its set method is required to fire the\n+ @code{PropertyChangeListener.propertyChange())} event\n+ after the value has changed.\n+@end deftypemethod\n+@deftypemethod PropertyDescriptor {public boolean} isConstrained () \n+Get whether the property is constrained.  Defaults to false.\n+@end deftypemethod\n+@deftypemethod PropertyDescriptor {public void} setConstrained (boolean@w{ }@var{constrained}) \n+Set whether the property is constrained.\n+ If the set method throws @code{java.beans.PropertyVetoException}\n+ (or subclass thereof) and the bean implements addVetoableChangeListener()\n+ and removeVetoableChangeListener(), then setConstrained(true) may safely\n+ be called.  Otherwise, the system behavior is undefined.\n+ <B>Spec note:</B> given those strict parameters, it would be nice if it\n+ got set automatically by detection, but oh well.\n+\n+\n+ When a property is constrained, its set method is required to:\n+\n+\n+ \n+@itemize @bullet\n+\n+ \n+@item\n+Fire the @code{VetoableChangeListener.vetoableChange()}\n+     event notifying others of the change and allowing them a chance to\n+     say it is a bad thing.\n+\n+ \n+@item\n+If any of the listeners throws a PropertyVetoException, then\n+     it must fire another vetoableChange() event notifying the others\n+     of a reversion to the old value (though, of course, the change\n+     was never made).  Then it rethrows the PropertyVetoException and\n+     exits.\n+\n+ \n+@item\n+If all has gone well to this point, the value may be changed.\n+\n+ \n+@end itemize\n+\n+@end deftypemethod\n+@deftypemethod PropertyDescriptor {public Class} getPropertyEditorClass () \n+Get the PropertyEditor class.  Defaults to null.\n+@end deftypemethod\n+@deftypemethod PropertyDescriptor {public void} setPropertyEditorClass (java.lang.Class@w{ }@var{propertyEditorClass}) \n+Set the PropertyEditor class.  If the class does not implement\n+ the PropertyEditor interface, you will likely get an exception\n+ late in the game.\n+@end deftypemethod\n+@deftypemethod PropertyEditor {public void} setValue (java.lang.Object@w{ }@var{value}) \n+Called by the RAD tool to set the value of this property for the PropertyEditor.\n+ If the property type is native, it should be wrapped in the appropriate\n+ wrapper type.\n+@end deftypemethod\n+@deftypemethod PropertyEditor {public Object} getValue () \n+Accessor method to get the current value the PropertyEditor is working with.\n+ If the property type is native, it will be wrapped in the appropriate\n+ wrapper type.\n+@end deftypemethod\n+@deftypemethod PropertyEditor {public void} setAsText (java.lang.String@w{ }@var{text}) @*throws IllegalArgumentException\n+Set the value of this property using a String.\n+ Whether or not this PropertyEditor is editing a String type, this converts\n+ the String into the type of the PropertyEditor.\n+@end deftypemethod\n+@deftypemethod PropertyEditor {public String} getAsText () \n+Get the value of this property in String format.\n+ Many times this can simply use Object.toString().\n+\n+\n+ Return null if you do not support getAsText()/setAsText().\n+ @code{setAsText(getAsText())} should be valid; i.e. the stuff you spit out in\n+ getAsText() should be able to go into setAsText().\n+@end deftypemethod\n+@deftypemethod PropertyEditor {public String} getTags () \n+Get a list of possible Strings which this property type can have.\n+ The value of these will be used by the RAD tool to construct some sort\n+ of list box or to check text box input, and the resulting String passed\n+ to setAsText() should be one of these.  Note, however, that like most things\n+ with this mammoth, unwieldy interface, this is not guaranteed.  Thus, you\n+ must check the value in setAsText() anyway.\n+@end deftypemethod\n+@deftypemethod PropertyEditor {public boolean} isPaintable () \n+The RAD tool calls this to find out whether the PropertyEditor can paint itself.\n+@end deftypemethod\n+@deftypemethod PropertyEditor {public void} paintValue (java.awt.Graphics@w{ }@var{g}, java.awt.Rectangle@w{ }@var{bounds}) \n+The RAD tool calls this to paint the actual value of the property.\n+ The Graphics context will have the same current font, color, etc. as the\n+ parent Container.  You may safely change the font, color, etc. and not\n+ change them back.\n+\n+\n+ This method should do a silent no-op if isPaintable() is false.\n+@end deftypemethod\n+@deftypemethod PropertyEditor {public boolean} supportsCustomEditor () \n+The RAD tool calls this to find out whether the PropertyEditor supports a custom component to edit and display itself.\n+@end deftypemethod\n+@deftypemethod PropertyEditor {public Component} getCustomEditor () \n+The RAD tool calls this to grab the component that can edit this type.\n+ The component may be painted anywhere the RAD tool wants to paint it--\n+ even in its own window.\n+\n+\n+ The component must hook up with the PropertyEditor and, whenever a\n+ change to the value is made, fire a PropertyChangeEvent to the source.\n+\n+\n+@end deftypemethod\n+@deftypemethod PropertyEditor {public void} addPropertyChangeListener (java.beans.PropertyChangeListener@w{ }@var{listener}) \n+Adds a property change listener to this PropertyEditor.\n+@end deftypemethod\n+@deftypemethod PropertyEditor {public void} removePropertyChangeListener (java.beans.PropertyChangeListener@w{ }@var{listener}) \n+Removes a property change listener from this PropertyEditor.\n+@end deftypemethod\n+@deftypemethod PropertyEditor {public String} getJavaInitializationString () \n+Get a Java language-specific String which could be used to create an Object\n+ of the specified type.  Every PropertyEditor must support this.\n+\n+\n+ The reason for this is that while most RAD tools will serialize the Beans\n+ and deserialize them at runtime, some RAD tools will generate code that\n+ creates the Beans.  Examples of Java initialization strings would be:\n+\n+\n+ \n+@itemize @bullet\n+\n+     \n+@item\n+@code{2}\n+\n+     \n+@item\n+@code{\"I am a String\"}\n+\n+     \n+@item\n+@code{new MyObject(2, \"String\", new StringBuffer())}\n+\n+ \n+@end itemize\n+\n+@end deftypemethod\n+@deftypemethod PropertyEditorManager {public static void} registerEditor (java.lang.Class@w{ }@var{editedClass}, java.lang.Class@w{ }@var{editorClass}) \n+Register an editor for a class.  Replaces old editor\n+ if there was one registered before.\n+@end deftypemethod\n+@deftypemethod PropertyEditorManager {public static PropertyEditor} findEditor (java.lang.Class@w{ }@var{editedClass}) \n+Returns a new instance of the property editor for the\n+ specified class.\n+@end deftypemethod\n+@deftypemethod PropertyEditorManager {public static String} getEditorSearchPath () \n+Get the editor search path.\n+ As a minor departure from the spec, the default value\n+ for the editor search path is \"gnu.java.beans.editors\",\n+ \"sun.beans.editors\".\n+@end deftypemethod\n+@deftypemethod PropertyEditorManager {public static void} setEditorSearchPath (java.lang.String[]@w{ }@var{editorSearchPath}) \n+Set the editor search path.\n+@end deftypemethod\n+@deftypemethod PropertyEditorSupport {public void} setValue (java.lang.Object@w{ }@var{val}) \n+Set the current value of the property.\n+ <STRONG>Implementation Note</STRONG> Sun does not\n+ state what exactly this version of the method does.\n+ Thus, in this implementation, it sets the value, and\n+ then if the old and new values are different, it\n+ fires a property change event with no property name\n+ and the old and new values.\n+@end deftypemethod\n+@deftypemethod PropertyEditorSupport {public Object} getValue () \n+Get the current value of the property.\n+@end deftypemethod\n+@deftypemethod PropertyEditorSupport {public boolean} isPaintable () \n+Get whether this object is paintable or not.\n+@end deftypemethod\n+@deftypemethod PropertyEditorSupport {public void} paintValue (java.awt.Graphics@w{ }@var{g}, java.awt.Rectangle@w{ }@var{r}) \n+Paint this object.  This class does nothing in\n+ this method.\n+@end deftypemethod\n+@deftypemethod PropertyEditorSupport {public String} getJavaInitializationString () \n+Get the Java initialization String for the current\n+ value of the Object.  This class returns gibberish or\n+ null (though the spec does not say which).\n+\n+\n+ <STRONG>Implementation Note:</STRONG> This class\n+ returns the string \"@$#^\" to make sure the code will\n+ be broken, so that you will know to override it when\n+ you create your own property editor.\n+@end deftypemethod\n+@deftypemethod PropertyEditorSupport {public String} getAsText () \n+Get the value as text.\n+ In this class, you cannot count on getAsText() doing\n+ anything useful, although in this implementation I\n+ do toString().\n+@end deftypemethod\n+@deftypemethod PropertyEditorSupport {public void} setAsText (java.lang.String@w{ }@var{s}) @*throws IllegalArgumentException\n+Set the value as text.\n+ In this class, you cannot count on setAsText() doing\n+ anything useful across implementations.\n+ <STRONG>Implementation Note:</STRONG> In this\n+ implementation it checks if the String is \"null\", and\n+ if it is, sets the value to null, otherwise it throws\n+ an IllegalArgumentException.\n+@end deftypemethod\n+@deftypemethod PropertyEditorSupport {public String} getTags () \n+Returns a list of possible choices for the value.\n+@end deftypemethod\n+@deftypemethod PropertyEditorSupport {public Component} getCustomEditor () \n+Return a custom component to edit the value.\n+@end deftypemethod\n+@deftypemethod PropertyEditorSupport {public boolean} supportsCustomEditor () \n+Find out whether this property editor supports a\n+ custom component to edit its value.\n+@end deftypemethod\n+@deftypemethod PropertyEditorSupport {public void} addPropertyChangeListener (java.beans.PropertyChangeListener@w{ }@var{l}) \n+Add a property change listener to this property editor.\n+@end deftypemethod\n+@deftypemethod PropertyEditorSupport {public void} removePropertyChangeListener (java.beans.PropertyChangeListener@w{ }@var{l}) \n+Remove a property change listener from this property editor.\n+@end deftypemethod\n+@deftypemethod PropertyEditorSupport {public void} firePropertyChange () \n+Notify people that we've changed, although we don't\n+ tell them just how.  The only thing I can think of to\n+ send in the event is the new value (since the old value\n+ is unavailable and there is no property name).\n+ I confess I do not understand the point of this method.\n+@end deftypemethod\n+@deftypemethod PropertyVetoException {public PropertyChangeEvent} getPropertyChangeEvent () \n+Get the PropertyChange event that was vetoed.\n+@end deftypemethod\n+@deftypemethod SimpleBeanInfo {public BeanDescriptor} getBeanDescriptor () \n+Force Introspection of the general bean info.\n+@end deftypemethod\n+@deftypemethod SimpleBeanInfo {public EventSetDescriptor} getEventSetDescriptors () \n+Force Introspection of the events this Bean type\n+ fires.\n+@end deftypemethod\n+@deftypemethod SimpleBeanInfo {public int} getDefaultEventIndex () \n+Say that there is no \"default\" event set.\n+@end deftypemethod\n+@deftypemethod SimpleBeanInfo {public PropertyDescriptor} getPropertyDescriptors () \n+Force Introspection of the Bean properties.\n+@end deftypemethod\n+@deftypemethod SimpleBeanInfo {public int} getDefaultPropertyIndex () \n+Say that there is no \"default\" property.\n+@end deftypemethod\n+@deftypemethod SimpleBeanInfo {public MethodDescriptor} getMethodDescriptors () \n+Force Introspection of the Bean's methods.\n+@end deftypemethod\n+@deftypemethod SimpleBeanInfo {public BeanInfo} getAdditionalBeanInfo () \n+Tell the Introspector to go look for other BeanInfo\n+ itself.\n+@end deftypemethod\n+@deftypemethod SimpleBeanInfo {public Image} getIcon (int@w{ }@var{iconType}) \n+Say that this Bean has no icons.\n+@end deftypemethod\n+@deftypemethod SimpleBeanInfo {public Image} loadImage (java.lang.String@w{ }@var{location}) \n+Helper method to load an image using the Bean class\n+ getResource() method on the BeanInfo class (using\n+ getClass(), since you'll extend this class to get\n+ the BeanInfo).  Basically it's assumed that the Bean\n+ and its BeanInfo are both loaded by the same\n+ ClassLoader, generally a reasonable assumption.\n+@end deftypemethod\n+@deftypemethod VetoableChangeListener {public void} vetoableChange (java.beans.PropertyChangeEvent@w{ }@var{e}) @*throws PropertyVetoException\n+Fired before a Bean's property changes.\n+@end deftypemethod\n+@deftypemethod VetoableChangeSupport {public void} addVetoableChangeListener (java.beans.VetoableChangeListener@w{ }@var{l}) \n+Adds a VetoableChangeListener to the list of listeners.\n+ All property change events will be sent to this listener.\n+ \n+\n+\n+\n+ The listener add is not unique: that is, <em>n</em> adds with\n+ the same listener will result in <em>n</em> events being sent\n+ to that listener for every property change.\n+ \n+\n+\n+\n+ Adding a null listener will cause undefined behavior.\n+@end deftypemethod\n+@deftypemethod VetoableChangeSupport {public void} addVetoableChangeListener (java.lang.String@w{ }@var{propertyName}, java.beans.VetoableChangeListener@w{ }@var{l}) \n+Adds a VetoableChangeListener listening on the specified property.\n+ Events will be sent to the listener for that particular property.\n+ \n+\n+\n+\n+ The listener add is not unique; that is, <em>n</em> adds on a\n+ particular property for a particular listener will result in\n+ <em>n</em> events being sent to that listener when that\n+ property is changed.\n+ \n+\n+\n+\n+ The effect is cumulative, too; if you are registered to listen\n+ to receive events on all property changes, and then you\n+ register on a particular property, you will receive change\n+ events for that property twice.\n+ \n+\n+\n+\n+ Adding a null listener will cause undefined behavior.\n+@end deftypemethod\n+@deftypemethod VetoableChangeSupport {public void} removeVetoableChangeListener (java.beans.VetoableChangeListener@w{ }@var{l}) \n+Removes a VetoableChangeListener from the list of listeners.\n+ If any specific properties are being listened on, they must\n+ be deregistered by themselves; this will only remove the\n+ general listener to all properties.\n+ \n+\n+\n+\n+ If @code{add()} has been called multiple times for a\n+ particular listener, @code{remove()} will have to be\n+ called the same number of times to deregister it.\n+@end deftypemethod\n+@deftypemethod VetoableChangeSupport {public void} removeVetoableChangeListener (java.lang.String@w{ }@var{propertyName}, java.beans.VetoableChangeListener@w{ }@var{l}) \n+Removes a VetoableChangeListener from listening to a specific property.\n+ \n+\n+\n+\n+ If @code{add()} has been called multiple times for a\n+ particular listener on a property, @code{remove()} will\n+ have to be called the same number of times to deregister it.\n+@end deftypemethod\n+@deftypemethod VetoableChangeSupport {public void} fireVetoableChange (java.beans.PropertyChangeEvent@w{ }@var{proposedChange}) @*throws PropertyVetoException\n+Fire a VetoableChangeEvent to all the listeners.\n+ If any listener objects, a reversion event will be sent to\n+ those listeners who received the initial event.\n+@end deftypemethod\n+@deftypemethod VetoableChangeSupport {public void} fireVetoableChange (java.lang.String@w{ }@var{propertyName}, java.lang.Object@w{ }@var{oldVal}, java.lang.Object@w{ }@var{newVal}) @*throws PropertyVetoException\n+Fire a VetoableChangeEvent containing the old and new values of the property to all the listeners.\n+ If any listener objects, a reversion event will be sent to\n+ those listeners who received the initial event.\n+@end deftypemethod\n+@deftypemethod VetoableChangeSupport {public void} fireVetoableChange (java.lang.String@w{ }@var{propertyName}, boolean@w{ }@var{oldVal}, boolean@w{ }@var{newVal}) @*throws PropertyVetoException\n+Fire a VetoableChangeEvent containing the old and new values of the property to all the listeners.\n+ If any listener objects, a reversion event will be sent to\n+ those listeners who received the initial event.\n+@end deftypemethod\n+@deftypemethod VetoableChangeSupport {public void} fireVetoableChange (java.lang.String@w{ }@var{propertyName}, int@w{ }@var{oldVal}, int@w{ }@var{newVal}) @*throws PropertyVetoException\n+Fire a VetoableChangeEvent containing the old and new values of the property to all the listeners.\n+ If any listener objects, a reversion event will be sent to\n+ those listeners who received the initial event.\n+@end deftypemethod\n+@deftypemethod VetoableChangeSupport {public boolean} hasListeners (java.lang.String@w{ }@var{propertyName}) \n+Tell whether the specified property is being listened on or not.\n+ This will only return @code{true} if there are listeners\n+ on all properties or if there is a listener specifically on this\n+ property.\n+@end deftypemethod\n+@deftypemethod Visibility {public boolean} needsGui () \n+Tells whether the Bean can run without a GUI or not.\n+@end deftypemethod\n+@deftypemethod Visibility {public boolean} avoidingGui () \n+Tells whether Bean is trying not to use the GUI.\n+ If needsGui() is true, this method should always return false.\n+@end deftypemethod\n+@deftypemethod Visibility {public void} dontUseGui () \n+Tells the Bean not to use GUI methods.\n+ If needsGUI() is false, then after this method is called,\n+ avoidingGui() should return true.\n+@end deftypemethod\n+@deftypemethod Visibility {public void} okToUseGui () \n+Tells the Bean it may use the GUI.\n+ The Bean is not required to use the GUI in this case, it is\n+ merely being <EM>permitted</EM> to use it.  If needsGui() is\n+ false, avoidingGui() may return true or false after this method\n+ is called.\n+@end deftypemethod"}, {"sha": "753bf96639e2dc20effffe6026fcf664ec31885f", "filename": "libjava/doc/java-io.texi", "status": "added", "additions": 2592, "deletions": 0, "changes": 2592, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2Fdoc%2Fjava-io.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2Fdoc%2Fjava-io.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fdoc%2Fjava-io.texi?ref=6a9d31a7d48bbae78a24a1395199d5c4c048d642"}, {"sha": "4b9d78795385c98a50427924406693cb4e7f7212", "filename": "libjava/doc/java-lang-ref.texi", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2Fdoc%2Fjava-lang-ref.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2Fdoc%2Fjava-lang-ref.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fdoc%2Fjava-lang-ref.texi?ref=6a9d31a7d48bbae78a24a1395199d5c4c048d642", "patch": "@@ -0,0 +1,34 @@\n+@deftypemethod PhantomReference {public Object} get () \n+Returns the object, this reference refers to.\n+@end deftypemethod\n+@deftypemethod Reference {public Object} get () \n+Returns the object, this reference refers to.\n+@end deftypemethod\n+@deftypemethod Reference {public void} clear () \n+Clears the reference, so that it doesn't refer to its object\n+ anymore.  For soft and weak references this is called by the\n+ garbage collection.  For phantom references you should call \n+ this when enqueuing the reference.\n+@end deftypemethod\n+@deftypemethod Reference {public boolean} isEnqueued () \n+Tells if the object is enqueued on a reference queue.\n+@end deftypemethod\n+@deftypemethod Reference {public boolean} enqueue () \n+Enqueue an object on a reference queue.  This is normally executed\n+ by the garbage collection.\n+@end deftypemethod\n+@deftypemethod ReferenceQueue {public synchronized Reference} poll () \n+Checks if there is a reference on the queue, returning it\n+ immediately.  The reference will be dequeued.\n+@end deftypemethod\n+@deftypemethod ReferenceQueue {public synchronized Reference} remove (long@w{ }@var{timeout}) @*throws InterruptedException\n+Removes a reference from the queue, blocking for @code{timeout}\n+ until a reference is enqueued.\n+@end deftypemethod\n+@deftypemethod ReferenceQueue {public Reference} remove () @*throws InterruptedException\n+Removes a reference from the queue, blocking until a reference is\n+ enqueued.\n+@end deftypemethod\n+@deftypemethod SoftReference {public Object} get () \n+Returns the object, this reference refers to.\n+@end deftypemethod"}, {"sha": "3712047747ddb2378a0b3b6949cb81e72c120ed5", "filename": "libjava/doc/java-lang-reflect.texi", "status": "added", "additions": 294, "deletions": 0, "changes": 294, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2Fdoc%2Fjava-lang-reflect.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2Fdoc%2Fjava-lang-reflect.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fdoc%2Fjava-lang-reflect.texi?ref=6a9d31a7d48bbae78a24a1395199d5c4c048d642", "patch": "@@ -0,0 +1,294 @@\n+@deftypemethod AccessibleObject {public boolean} isAccessible () \n+\n+@end deftypemethod\n+@deftypemethod AccessibleObject {public static void} setAccessible (java.lang.reflect.AccessibleObject[]@w{ }@var{array}, boolean@w{ }@var{flag}) \n+\n+@end deftypemethod\n+@deftypemethod AccessibleObject {public void} setAccessible (boolean@w{ }@var{flag}) \n+\n+@end deftypemethod\n+@deftypemethod Array {public static native Object} newInstance (java.lang.Class@w{ }@var{componentType}, int@w{ }@var{length}) \n+\n+@end deftypemethod\n+@deftypemethod Array {public static native Object} newInstance (java.lang.Class@w{ }@var{elementType}, int[]@w{ }@var{dimensions}) \n+\n+@end deftypemethod\n+@deftypemethod Array {public static native int} getLength (java.lang.Object@w{ }@var{array}) \n+\n+@end deftypemethod\n+@deftypemethod Array {public static native Object} get (java.lang.Object@w{ }@var{array}, int@w{ }@var{index}) \n+\n+@end deftypemethod\n+@deftypemethod Array {public static native char} getChar (java.lang.Object@w{ }@var{array}, int@w{ }@var{index}) \n+\n+@end deftypemethod\n+@deftypemethod Array {public static native byte} getByte (java.lang.Object@w{ }@var{array}, int@w{ }@var{index}) \n+\n+@end deftypemethod\n+@deftypemethod Array {public static native short} getShort (java.lang.Object@w{ }@var{array}, int@w{ }@var{index}) \n+\n+@end deftypemethod\n+@deftypemethod Array {public static native int} getInt (java.lang.Object@w{ }@var{array}, int@w{ }@var{index}) \n+\n+@end deftypemethod\n+@deftypemethod Array {public static native long} getLong (java.lang.Object@w{ }@var{array}, int@w{ }@var{index}) \n+\n+@end deftypemethod\n+@deftypemethod Array {public static native float} getFloat (java.lang.Object@w{ }@var{array}, int@w{ }@var{index}) \n+\n+@end deftypemethod\n+@deftypemethod Array {public static native double} getDouble (java.lang.Object@w{ }@var{array}, int@w{ }@var{index}) \n+\n+@end deftypemethod\n+@deftypemethod Array {public static native boolean} getBoolean (java.lang.Object@w{ }@var{array}, int@w{ }@var{index}) \n+\n+@end deftypemethod\n+@deftypemethod Array {public static void} set (java.lang.Object@w{ }@var{array}, int@w{ }@var{index}, java.lang.Object@w{ }@var{value}) \n+\n+@end deftypemethod\n+@deftypemethod Array {public static native void} setByte (java.lang.Object@w{ }@var{array}, int@w{ }@var{index}, byte@w{ }@var{value}) \n+\n+@end deftypemethod\n+@deftypemethod Array {public static native void} setShort (java.lang.Object@w{ }@var{array}, int@w{ }@var{index}, short@w{ }@var{value}) \n+\n+@end deftypemethod\n+@deftypemethod Array {public static native void} setInt (java.lang.Object@w{ }@var{array}, int@w{ }@var{index}, int@w{ }@var{value}) \n+\n+@end deftypemethod\n+@deftypemethod Array {public static native void} setLong (java.lang.Object@w{ }@var{array}, int@w{ }@var{index}, long@w{ }@var{value}) \n+\n+@end deftypemethod\n+@deftypemethod Array {public static native void} setFloat (java.lang.Object@w{ }@var{array}, int@w{ }@var{index}, float@w{ }@var{value}) \n+\n+@end deftypemethod\n+@deftypemethod Array {public static native void} setDouble (java.lang.Object@w{ }@var{array}, int@w{ }@var{index}, double@w{ }@var{value}) \n+\n+@end deftypemethod\n+@deftypemethod Array {public static native void} setChar (java.lang.Object@w{ }@var{array}, int@w{ }@var{index}, char@w{ }@var{value}) \n+\n+@end deftypemethod\n+@deftypemethod Array {public static native void} setBoolean (java.lang.Object@w{ }@var{array}, int@w{ }@var{index}, boolean@w{ }@var{value}) \n+\n+@end deftypemethod\n+@deftypemethod Constructor {public boolean} equals (java.lang.Object@w{ }@var{obj}) \n+\n+@end deftypemethod\n+@deftypemethod Constructor {public Class} getDeclaringClass () \n+\n+@end deftypemethod\n+@deftypemethod Constructor {public Class} getExceptionTypes () \n+\n+@end deftypemethod\n+@deftypemethod Constructor {public native int} getModifiers () \n+\n+@end deftypemethod\n+@deftypemethod Constructor {public String} getName () \n+\n+@end deftypemethod\n+@deftypemethod Constructor {public Class} getParameterTypes () \n+\n+@end deftypemethod\n+@deftypemethod Constructor {public int} hashCode () \n+\n+@end deftypemethod\n+@deftypemethod Constructor {public native Object} newInstance (java.lang.Object[]@w{ }@var{args}) @*throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException\n+\n+@end deftypemethod\n+@deftypemethod Constructor {public String} toString () \n+\n+@end deftypemethod\n+@deftypemethod Field {public boolean} equals (java.lang.Object@w{ }@var{fld}) \n+\n+@end deftypemethod\n+@deftypemethod Field {public Class} getDeclaringClass () \n+\n+@end deftypemethod\n+@deftypemethod Field {public native String} getName () \n+\n+@end deftypemethod\n+@deftypemethod Field {public native Class} getType () \n+\n+@end deftypemethod\n+@deftypemethod Field {public native int} getModifiers () \n+\n+@end deftypemethod\n+@deftypemethod Field {public int} hashCode () \n+\n+@end deftypemethod\n+@deftypemethod Field {public boolean} getBoolean (java.lang.Object@w{ }@var{obj}) @*throws IllegalArgumentException, IllegalAccessException\n+\n+@end deftypemethod\n+@deftypemethod Field {public char} getChar (java.lang.Object@w{ }@var{obj}) @*throws IllegalArgumentException, IllegalAccessException\n+\n+@end deftypemethod\n+@deftypemethod Field {public byte} getByte (java.lang.Object@w{ }@var{obj}) @*throws IllegalArgumentException, IllegalAccessException\n+\n+@end deftypemethod\n+@deftypemethod Field {public short} getShort (java.lang.Object@w{ }@var{obj}) @*throws IllegalArgumentException, IllegalAccessException\n+\n+@end deftypemethod\n+@deftypemethod Field {public int} getInt (java.lang.Object@w{ }@var{obj}) @*throws IllegalArgumentException, IllegalAccessException\n+\n+@end deftypemethod\n+@deftypemethod Field {public long} getLong (java.lang.Object@w{ }@var{obj}) @*throws IllegalArgumentException, IllegalAccessException\n+\n+@end deftypemethod\n+@deftypemethod Field {public float} getFloat (java.lang.Object@w{ }@var{obj}) @*throws IllegalArgumentException, IllegalAccessException\n+\n+@end deftypemethod\n+@deftypemethod Field {public double} getDouble (java.lang.Object@w{ }@var{obj}) @*throws IllegalArgumentException, IllegalAccessException\n+\n+@end deftypemethod\n+@deftypemethod Field {public Object} get (java.lang.Object@w{ }@var{obj}) @*throws IllegalArgumentException, IllegalAccessException\n+\n+@end deftypemethod\n+@deftypemethod Field {public native Object} get (java.lang.Class@w{ }@var{caller}, java.lang.Object@w{ }@var{obj}) @*throws IllegalArgumentException, IllegalAccessException\n+\n+@end deftypemethod\n+@deftypemethod Field {public void} setByte (java.lang.Object@w{ }@var{obj}, byte@w{ }@var{b}) @*throws IllegalArgumentException, IllegalAccessException\n+\n+@end deftypemethod\n+@deftypemethod Field {public void} setShort (java.lang.Object@w{ }@var{obj}, short@w{ }@var{s}) @*throws IllegalArgumentException, IllegalAccessException\n+\n+@end deftypemethod\n+@deftypemethod Field {public void} setInt (java.lang.Object@w{ }@var{obj}, int@w{ }@var{i}) @*throws IllegalArgumentException, IllegalAccessException\n+\n+@end deftypemethod\n+@deftypemethod Field {public void} setLong (java.lang.Object@w{ }@var{obj}, long@w{ }@var{l}) @*throws IllegalArgumentException, IllegalAccessException\n+\n+@end deftypemethod\n+@deftypemethod Field {public void} setFloat (java.lang.Object@w{ }@var{obj}, float@w{ }@var{f}) @*throws IllegalArgumentException, IllegalAccessException\n+\n+@end deftypemethod\n+@deftypemethod Field {public void} setDouble (java.lang.Object@w{ }@var{obj}, double@w{ }@var{d}) @*throws IllegalArgumentException, IllegalAccessException\n+\n+@end deftypemethod\n+@deftypemethod Field {public void} setChar (java.lang.Object@w{ }@var{obj}, char@w{ }@var{c}) @*throws IllegalArgumentException, IllegalAccessException\n+\n+@end deftypemethod\n+@deftypemethod Field {public void} setBoolean (java.lang.Object@w{ }@var{obj}, boolean@w{ }@var{b}) @*throws IllegalArgumentException, IllegalAccessException\n+\n+@end deftypemethod\n+@deftypemethod Field {public native void} setByte (java.lang.Class@w{ }@var{caller}, java.lang.Object@w{ }@var{obj}, byte@w{ }@var{b}) @*throws IllegalArgumentException, IllegalAccessException\n+\n+@end deftypemethod\n+@deftypemethod Field {public native void} setShort (java.lang.Class@w{ }@var{caller}, java.lang.Object@w{ }@var{obj}, short@w{ }@var{s}) @*throws IllegalArgumentException, IllegalAccessException\n+\n+@end deftypemethod\n+@deftypemethod Field {public native void} setInt (java.lang.Class@w{ }@var{caller}, java.lang.Object@w{ }@var{obj}, int@w{ }@var{i}) @*throws IllegalArgumentException, IllegalAccessException\n+\n+@end deftypemethod\n+@deftypemethod Field {public native void} setLong (java.lang.Class@w{ }@var{caller}, java.lang.Object@w{ }@var{obj}, long@w{ }@var{l}) @*throws IllegalArgumentException, IllegalAccessException\n+\n+@end deftypemethod\n+@deftypemethod Field {public native void} setFloat (java.lang.Class@w{ }@var{caller}, java.lang.Object@w{ }@var{obj}, float@w{ }@var{f}) @*throws IllegalArgumentException, IllegalAccessException\n+\n+@end deftypemethod\n+@deftypemethod Field {public native void} setDouble (java.lang.Class@w{ }@var{caller}, java.lang.Object@w{ }@var{obj}, double@w{ }@var{d}) @*throws IllegalArgumentException, IllegalAccessException\n+\n+@end deftypemethod\n+@deftypemethod Field {public native void} setChar (java.lang.Class@w{ }@var{caller}, java.lang.Object@w{ }@var{obj}, char@w{ }@var{c}) @*throws IllegalArgumentException, IllegalAccessException\n+\n+@end deftypemethod\n+@deftypemethod Field {public native void} setBoolean (java.lang.Class@w{ }@var{caller}, java.lang.Object@w{ }@var{obj}, boolean@w{ }@var{b}) @*throws IllegalArgumentException, IllegalAccessException\n+\n+@end deftypemethod\n+@deftypemethod Field {public void} set (java.lang.Object@w{ }@var{object}, java.lang.Object@w{ }@var{value}) @*throws IllegalArgumentException, IllegalAccessException\n+\n+@end deftypemethod\n+@deftypemethod Field {public void} set (java.lang.Class@w{ }@var{caller}, java.lang.Object@w{ }@var{object}, java.lang.Object@w{ }@var{value}) @*throws IllegalArgumentException, IllegalAccessException\n+\n+@end deftypemethod\n+@deftypemethod Field {public String} toString () \n+\n+@end deftypemethod\n+@deftypemethod InvocationTargetException {public Throwable} getTargetException () \n+\n+@end deftypemethod\n+@deftypemethod InvocationTargetException {public void} printStackTrace () \n+\n+@end deftypemethod\n+@deftypemethod InvocationTargetException {public void} printStackTrace (java.io.PrintStream@w{ }@var{s}) \n+\n+@end deftypemethod\n+@deftypemethod InvocationTargetException {public void} printStackTrace (java.io.PrintWriter@w{ }@var{wr}) \n+\n+@end deftypemethod\n+@deftypemethod Member {public Class} getDeclaringClass () \n+\n+@end deftypemethod\n+@deftypemethod Member {public int} getModifiers () \n+\n+@end deftypemethod\n+@deftypemethod Member {public String} getName () \n+\n+@end deftypemethod\n+@deftypemethod Method {public boolean} equals (java.lang.Object@w{ }@var{obj}) \n+\n+@end deftypemethod\n+@deftypemethod Method {public Class} getDeclaringClass () \n+\n+@end deftypemethod\n+@deftypemethod Method {public Class} getExceptionTypes () \n+\n+@end deftypemethod\n+@deftypemethod Method {public native int} getModifiers () \n+\n+@end deftypemethod\n+@deftypemethod Method {public native String} getName () \n+\n+@end deftypemethod\n+@deftypemethod Method {public Class} getParameterTypes () \n+\n+@end deftypemethod\n+@deftypemethod Method {public Class} getReturnType () \n+\n+@end deftypemethod\n+@deftypemethod Method {public int} hashCode () \n+\n+@end deftypemethod\n+@deftypemethod Method {public native Object} invoke (java.lang.Object@w{ }@var{obj}, java.lang.Object[]@w{ }@var{args}) @*throws IllegalAccessException, IllegalArgumentException, InvocationTargetException\n+\n+@end deftypemethod\n+@deftypemethod Method {public String} toString () \n+\n+@end deftypemethod\n+@deftypemethod Modifier {public static boolean} isAbstract (int@w{ }@var{mod}) \n+\n+@end deftypemethod\n+@deftypemethod Modifier {public static boolean} isFinal (int@w{ }@var{mod}) \n+\n+@end deftypemethod\n+@deftypemethod Modifier {public static boolean} isInterface (int@w{ }@var{mod}) \n+\n+@end deftypemethod\n+@deftypemethod Modifier {public static boolean} isNative (int@w{ }@var{mod}) \n+\n+@end deftypemethod\n+@deftypemethod Modifier {public static boolean} isPrivate (int@w{ }@var{mod}) \n+\n+@end deftypemethod\n+@deftypemethod Modifier {public static boolean} isProtected (int@w{ }@var{mod}) \n+\n+@end deftypemethod\n+@deftypemethod Modifier {public static boolean} isPublic (int@w{ }@var{mod}) \n+\n+@end deftypemethod\n+@deftypemethod Modifier {public static boolean} isStatic (int@w{ }@var{mod}) \n+\n+@end deftypemethod\n+@deftypemethod Modifier {public static boolean} isStrict (int@w{ }@var{mod}) \n+\n+@end deftypemethod\n+@deftypemethod Modifier {public static boolean} isSynchronized (int@w{ }@var{mod}) \n+\n+@end deftypemethod\n+@deftypemethod Modifier {public static boolean} isTransient (int@w{ }@var{mod}) \n+\n+@end deftypemethod\n+@deftypemethod Modifier {public static boolean} isVolatile (int@w{ }@var{mod}) \n+\n+@end deftypemethod\n+@deftypemethod Modifier {public static String} toString (int@w{ }@var{mod}) \n+\n+@end deftypemethod"}, {"sha": "086e7e1b38609c6f223a3ef09948d50a6c944f4c", "filename": "libjava/doc/java-lang.texi", "status": "added", "additions": 855, "deletions": 0, "changes": 855, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2Fdoc%2Fjava-lang.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2Fdoc%2Fjava-lang.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fdoc%2Fjava-lang.texi?ref=6a9d31a7d48bbae78a24a1395199d5c4c048d642", "patch": "@@ -0,0 +1,855 @@\n+@deftypemethod Process {public abstract void} destroy () \n+\n+@end deftypemethod\n+@deftypemethod Process {public abstract int} exitValue () \n+\n+@end deftypemethod\n+@deftypemethod Process {public abstract InputStream} getErrorStream () \n+\n+@end deftypemethod\n+@deftypemethod Process {public abstract InputStream} getInputStream () \n+\n+@end deftypemethod\n+@deftypemethod Process {public abstract OutputStream} getOutputStream () \n+\n+@end deftypemethod\n+@deftypemethod Process {public abstract int} waitFor () @*throws InterruptedException\n+\n+@end deftypemethod\n+@deftypemethod Runnable {public void} run () \n+\n+@end deftypemethod\n+@deftypemethod Runtime {public Process} exec (java.lang.String@w{ }@var{prog}) @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod Runtime {public Process} exec (java.lang.String@w{ }@var{prog}, java.lang.String[]@w{ }@var{envp}) @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod Runtime {public Process} exec (java.lang.String[]@w{ }@var{progarray}) @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod Runtime {public Process} exec (java.lang.String[]@w{ }@var{progarray}, java.lang.String[]@w{ }@var{envp}) @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod Runtime {public native void} exit (int@w{ }@var{status}) \n+\n+@end deftypemethod\n+@deftypemethod Runtime {public native long} freeMemory () \n+\n+@end deftypemethod\n+@deftypemethod Runtime {public native void} gc () \n+\n+@end deftypemethod\n+@deftypemethod Runtime {public InputStream} getLocalizedInputStream (java.io.InputStream@w{ }@var{in}) \n+\n+@end deftypemethod\n+@deftypemethod Runtime {public OutputStream} getLocalizedOutputStream (java.io.OutputStream@w{ }@var{out}) \n+\n+@end deftypemethod\n+@deftypemethod Runtime {public static Runtime} getRuntime () \n+\n+@end deftypemethod\n+@deftypemethod Runtime {public void} load (java.lang.String@w{ }@var{pathname}) \n+\n+@end deftypemethod\n+@deftypemethod Runtime {public void} loadLibrary (java.lang.String@w{ }@var{libname}) \n+\n+@end deftypemethod\n+@deftypemethod Runtime {public native void} runFinalization () \n+\n+@end deftypemethod\n+@deftypemethod Runtime {public static void} runFinalizersOnExit (boolean@w{ }@var{run}) \n+\n+@end deftypemethod\n+@deftypemethod Runtime {public native long} totalMemory () \n+\n+@end deftypemethod\n+@deftypemethod Runtime {public native void} traceInstructions (boolean@w{ }@var{on}) \n+\n+@end deftypemethod\n+@deftypemethod Runtime {public native void} traceMethodCalls (boolean@w{ }@var{on}) \n+\n+@end deftypemethod\n+@deftypemethod SecurityManager {public void} checkAccept (java.lang.String@w{ }@var{host}, int@w{ }@var{port}) \n+\n+@end deftypemethod\n+@deftypemethod SecurityManager {public void} checkAccess (java.lang.Thread@w{ }@var{thrd}) \n+\n+@end deftypemethod\n+@deftypemethod SecurityManager {public void} checkAccess (java.lang.ThreadGroup@w{ }@var{thrdGroup}) \n+\n+@end deftypemethod\n+@deftypemethod SecurityManager {public void} checkAwtEventQueueAccess () \n+\n+@end deftypemethod\n+@deftypemethod SecurityManager {public void} checkConnect (java.lang.String@w{ }@var{host}, int@w{ }@var{prt}) \n+\n+@end deftypemethod\n+@deftypemethod SecurityManager {public void} checkConnect (java.lang.String@w{ }@var{host}, int@w{ }@var{prt}, java.lang.Object@w{ }@var{ctx}) \n+\n+@end deftypemethod\n+@deftypemethod SecurityManager {public void} checkCreateClassLoader () \n+\n+@end deftypemethod\n+@deftypemethod SecurityManager {public void} checkDelete (java.lang.String@w{ }@var{fileName}) \n+\n+@end deftypemethod\n+@deftypemethod SecurityManager {public void} checkExec (java.lang.String@w{ }@var{prog}) \n+\n+@end deftypemethod\n+@deftypemethod SecurityManager {public void} checkExit (int@w{ }@var{stat}) \n+\n+@end deftypemethod\n+@deftypemethod SecurityManager {public void} checkLink (java.lang.String@w{ }@var{lib}) \n+\n+@end deftypemethod\n+@deftypemethod SecurityManager {public void} checkListen (int@w{ }@var{lport}) \n+\n+@end deftypemethod\n+@deftypemethod SecurityManager {public void} checkMemberAccess (java.lang.Class@w{ }@var{cl}, int@w{ }@var{mtype}) \n+\n+@end deftypemethod\n+@deftypemethod SecurityManager {public void} checkMulticast (java.net.InetAddress@w{ }@var{maddr}) \n+\n+@end deftypemethod\n+@deftypemethod SecurityManager {public void} checkMulticast (java.net.InetAddress@w{ }@var{maddr}, byte@w{ }@var{ttl}) \n+\n+@end deftypemethod\n+@deftypemethod SecurityManager {public void} checkPackageAccess (java.lang.String@w{ }@var{pkg}) \n+\n+@end deftypemethod\n+@deftypemethod SecurityManager {public void} checkPackageDefinition (java.lang.String@w{ }@var{pkg}) \n+\n+@end deftypemethod\n+@deftypemethod SecurityManager {public void} checkPermission (java.security.Permission@w{ }@var{perm}) \n+\n+@end deftypemethod\n+@deftypemethod SecurityManager {public void} checkPrintJobAccess () \n+\n+@end deftypemethod\n+@deftypemethod SecurityManager {public void} checkPropertiesAccess () \n+\n+@end deftypemethod\n+@deftypemethod SecurityManager {public void} checkPropertyAccess (java.lang.String@w{ }@var{prop}) \n+\n+@end deftypemethod\n+@deftypemethod SecurityManager {public void} checkPropertyAccess (java.lang.String@w{ }@var{prop}, java.lang.String@w{ }@var{defval}) \n+\n+@end deftypemethod\n+@deftypemethod SecurityManager {public void} checkRead (java.io.FileDescriptor@w{ }@var{fd}) \n+\n+@end deftypemethod\n+@deftypemethod SecurityManager {public void} checkRead (java.lang.String@w{ }@var{fileName}) \n+\n+@end deftypemethod\n+@deftypemethod SecurityManager {public void} checkRead (java.lang.String@w{ }@var{fileName}, java.lang.Object@w{ }@var{ctx}) \n+\n+@end deftypemethod\n+@deftypemethod SecurityManager {public void} checkSecurityAccess (java.lang.String@w{ }@var{action}) \n+\n+@end deftypemethod\n+@deftypemethod SecurityManager {public void} checkSetFactory () \n+\n+@end deftypemethod\n+@deftypemethod SecurityManager {public void} checkSystemClipboardAccess () \n+\n+@end deftypemethod\n+@deftypemethod SecurityManager {public boolean} checkTopLevelWindow (java.lang.Object@w{ }@var{window}) \n+\n+@end deftypemethod\n+@deftypemethod SecurityManager {public void} checkWrite (java.io.FileDescriptor@w{ }@var{fd}) \n+\n+@end deftypemethod\n+@deftypemethod SecurityManager {public void} checkWrite (java.lang.String@w{ }@var{fileName}) \n+\n+@end deftypemethod\n+@deftypemethod SecurityManager {protected int} classDepth (java.lang.String@w{ }@var{className}) \n+\n+@end deftypemethod\n+@deftypemethod SecurityManager {protected int} classLoaderDepth () \n+\n+@end deftypemethod\n+@deftypemethod SecurityManager {protected ClassLoader} currentClassLoader () \n+\n+@end deftypemethod\n+@deftypemethod SecurityManager {protected Class} currentLoadedClass () \n+\n+@end deftypemethod\n+@deftypemethod SecurityManager {protected Class} getClassContext () \n+\n+@end deftypemethod\n+@deftypemethod SecurityManager {public boolean} getInCheck () \n+\n+@end deftypemethod\n+@deftypemethod SecurityManager {public Object} getSecurityContext () \n+\n+@end deftypemethod\n+@deftypemethod SecurityManager {public ThreadGroup} getThreadGroup () \n+\n+@end deftypemethod\n+@deftypemethod SecurityManager {protected boolean} inClass (java.lang.String@w{ }@var{className}) \n+\n+@end deftypemethod\n+@deftypemethod SecurityManager {protected boolean} inClassLoader () \n+\n+@end deftypemethod\n+@deftypemethod Short {public byte} byteValue () \n+\n+@end deftypemethod\n+@deftypemethod Short {public short} shortValue () \n+\n+@end deftypemethod\n+@deftypemethod Short {public int} intValue () \n+\n+@end deftypemethod\n+@deftypemethod Short {public long} longValue () \n+\n+@end deftypemethod\n+@deftypemethod Short {public float} floatValue () \n+\n+@end deftypemethod\n+@deftypemethod Short {public double} doubleValue () \n+\n+@end deftypemethod\n+@deftypemethod Short {public static Short} decode (java.lang.String@w{ }@var{str}) @*throws NumberFormatException\n+\n+@end deftypemethod\n+@deftypemethod Short {public static short} parseShort (java.lang.String@w{ }@var{str}, int@w{ }@var{radix}) @*throws NumberFormatException\n+\n+@end deftypemethod\n+@deftypemethod Short {public static short} parseShort (java.lang.String@w{ }@var{str}) @*throws NumberFormatException\n+\n+@end deftypemethod\n+@deftypemethod Short {public static Short} valueOf (java.lang.String@w{ }@var{str}, int@w{ }@var{radix}) @*throws NumberFormatException\n+\n+@end deftypemethod\n+@deftypemethod Short {public static Short} valueOf (java.lang.String@w{ }@var{str}) @*throws NumberFormatException\n+\n+@end deftypemethod\n+@deftypemethod Short {public int} compareTo (java.lang.Short@w{ }@var{anotherShort}) \n+\n+@end deftypemethod\n+@deftypemethod Short {public int} compareTo (java.lang.Object@w{ }@var{o}) @*throws ClassCastException\n+\n+@end deftypemethod\n+@deftypemethod Short {public boolean} equals (java.lang.Object@w{ }@var{obj}) \n+\n+@end deftypemethod\n+@deftypemethod Short {public int} hashCode () \n+\n+@end deftypemethod\n+@deftypemethod Short {public String} toString () \n+\n+@end deftypemethod\n+@deftypemethod Short {public static String} toString (short@w{ }@var{value}) \n+\n+@end deftypemethod\n+@deftypemethod String {public static String} copyValueOf (char[]@w{ }@var{data}) \n+\n+@end deftypemethod\n+@deftypemethod String {public static String} copyValueOf (char[]@w{ }@var{data}, int@w{ }@var{offset}, int@w{ }@var{count}) \n+\n+@end deftypemethod\n+@deftypemethod String {public String} toString () \n+\n+@end deftypemethod\n+@deftypemethod String {public native boolean} equals (java.lang.Object@w{ }@var{anObject}) \n+\n+@end deftypemethod\n+@deftypemethod String {public native int} hashCode () \n+\n+@end deftypemethod\n+@deftypemethod String {public int} length () \n+\n+@end deftypemethod\n+@deftypemethod String {public native char} charAt (int@w{ }@var{index}) \n+\n+@end deftypemethod\n+@deftypemethod String {public native void} getChars (int@w{ }@var{srcBegin}, int@w{ }@var{srcEnd}, char[]@w{ }@var{dst}, int@w{ }@var{dstBegin}) \n+\n+@end deftypemethod\n+@deftypemethod String {public byte} getBytes () \n+\n+@end deftypemethod\n+@deftypemethod String {public native byte} getBytes (java.lang.String@w{ }@var{enc}) @*throws UnsupportedEncodingException\n+\n+@end deftypemethod\n+@deftypemethod String {public native void} getBytes (int@w{ }@var{srcBegin}, int@w{ }@var{srcEnd}, byte[]@w{ }@var{dst}, int@w{ }@var{dstBegin}) \n+\n+@end deftypemethod\n+@deftypemethod String {public native char} toCharArray () \n+\n+@end deftypemethod\n+@deftypemethod String {public native boolean} equalsIgnoreCase (java.lang.String@w{ }@var{anotherString}) \n+\n+@end deftypemethod\n+@deftypemethod String {public native int} compareTo (java.lang.String@w{ }@var{anotherString}) \n+\n+@end deftypemethod\n+@deftypemethod String {public int} compareTo (java.lang.Object@w{ }@var{obj}) \n+\n+@end deftypemethod\n+@deftypemethod String {public int} compareToIgnoreCase (java.lang.String@w{ }@var{str}) \n+\n+@end deftypemethod\n+@deftypemethod String {public native boolean} regionMatches (int@w{ }@var{toffset}, java.lang.String@w{ }@var{other}, int@w{ }@var{ooffset}, int@w{ }@var{len}) \n+\n+@end deftypemethod\n+@deftypemethod String {public native boolean} regionMatches (boolean@w{ }@var{ignoreCase}, int@w{ }@var{toffset}, java.lang.String@w{ }@var{other}, int@w{ }@var{ooffset}, int@w{ }@var{len}) \n+\n+@end deftypemethod\n+@deftypemethod String {public boolean} startsWith (java.lang.String@w{ }@var{prefix}) \n+\n+@end deftypemethod\n+@deftypemethod String {public native boolean} startsWith (java.lang.String@w{ }@var{prefix}, int@w{ }@var{toffset}) \n+\n+@end deftypemethod\n+@deftypemethod String {public boolean} endsWith (java.lang.String@w{ }@var{suffix}) \n+\n+@end deftypemethod\n+@deftypemethod String {public int} indexOf (int@w{ }@var{ch}) \n+\n+@end deftypemethod\n+@deftypemethod String {public native int} indexOf (int@w{ }@var{ch}, int@w{ }@var{fromIndex}) \n+\n+@end deftypemethod\n+@deftypemethod String {public int} indexOf (java.lang.String@w{ }@var{str}) \n+\n+@end deftypemethod\n+@deftypemethod String {public native int} indexOf (java.lang.String@w{ }@var{str}, int@w{ }@var{fromIndex}) \n+\n+@end deftypemethod\n+@deftypemethod String {public int} lastIndexOf (int@w{ }@var{ch}) \n+\n+@end deftypemethod\n+@deftypemethod String {public native int} lastIndexOf (int@w{ }@var{ch}, int@w{ }@var{fromIndex}) \n+\n+@end deftypemethod\n+@deftypemethod String {public int} lastIndexOf (java.lang.String@w{ }@var{str}) \n+\n+@end deftypemethod\n+@deftypemethod String {public int} lastIndexOf (java.lang.String@w{ }@var{str}, int@w{ }@var{fromIndex}) \n+\n+@end deftypemethod\n+@deftypemethod String {public String} substring (int@w{ }@var{beginIndex}) \n+\n+@end deftypemethod\n+@deftypemethod String {public native String} substring (int@w{ }@var{beginIndex}, int@w{ }@var{endIndex}) \n+\n+@end deftypemethod\n+@deftypemethod String {public native String} concat (java.lang.String@w{ }@var{str}) \n+\n+@end deftypemethod\n+@deftypemethod String {public native String} replace (char@w{ }@var{oldChar}, char@w{ }@var{newChar}) \n+\n+@end deftypemethod\n+@deftypemethod String {public native String} toLowerCase (java.util.Locale@w{ }@var{locale}) \n+\n+@end deftypemethod\n+@deftypemethod String {public native String} toUpperCase (java.util.Locale@w{ }@var{locale}) \n+\n+@end deftypemethod\n+@deftypemethod String {public String} toLowerCase () \n+\n+@end deftypemethod\n+@deftypemethod String {public String} toUpperCase () \n+\n+@end deftypemethod\n+@deftypemethod String {public native String} trim () \n+\n+@end deftypemethod\n+@deftypemethod String {public static String} valueOf (java.lang.Object@w{ }@var{obj}) \n+\n+@end deftypemethod\n+@deftypemethod String {public static String} valueOf (char[]@w{ }@var{data}) \n+\n+@end deftypemethod\n+@deftypemethod String {public static native String} valueOf (char[]@w{ }@var{data}, int@w{ }@var{offset}, int@w{ }@var{count}) \n+\n+@end deftypemethod\n+@deftypemethod String {public static String} valueOf (boolean@w{ }@var{b}) \n+\n+@end deftypemethod\n+@deftypemethod String {public static native String} valueOf (char@w{ }@var{c}) \n+\n+@end deftypemethod\n+@deftypemethod String {public static String} valueOf (int@w{ }@var{i}) \n+\n+@end deftypemethod\n+@deftypemethod String {public static String} valueOf (long@w{ }@var{l}) \n+\n+@end deftypemethod\n+@deftypemethod String {public static String} valueOf (float@w{ }@var{f}) \n+\n+@end deftypemethod\n+@deftypemethod String {public static String} valueOf (double@w{ }@var{d}) \n+\n+@end deftypemethod\n+@deftypemethod String {public native String} intern () \n+\n+@end deftypemethod\n+@deftypemethod StringBuffer {public StringBuffer} append (boolean@w{ }@var{bool}) \n+Append the @code{String} value of the argument to this @code{StringBuffer}.\n+  Uses @code{String.valueOf()} to convert to\n+  @code{String}.\n+@end deftypemethod\n+@deftypemethod StringBuffer {public synchronized StringBuffer} append (char@w{ }@var{ch}) \n+Append the @code{char} to this @code{StringBuffer}.\n+@end deftypemethod\n+@deftypemethod StringBuffer {public StringBuffer} append (int@w{ }@var{inum}) \n+Append the @code{String} value of the argument to this @code{StringBuffer}.\n+  Uses @code{String.valueOf()} to convert to\n+  @code{String}.\n+@end deftypemethod\n+@deftypemethod StringBuffer {public StringBuffer} append (long@w{ }@var{lnum}) \n+Append the @code{String} value of the argument to this @code{StringBuffer}.\n+  Uses @code{String.valueOf()} to convert to\n+  @code{String}.\n+@end deftypemethod\n+@deftypemethod StringBuffer {public StringBuffer} append (float@w{ }@var{fnum}) \n+Append the @code{String} value of the argument to this @code{StringBuffer}.\n+  Uses @code{String.valueOf()} to convert to\n+  @code{String}.\n+@end deftypemethod\n+@deftypemethod StringBuffer {public StringBuffer} append (double@w{ }@var{dnum}) \n+Append the @code{String} value of the argument to this @code{StringBuffer}.\n+  Uses @code{String.valueOf()} to convert to\n+  @code{String}.\n+@end deftypemethod\n+@deftypemethod StringBuffer {public StringBuffer} append (java.lang.Object@w{ }@var{obj}) \n+Append the @code{String} value of the argument to this @code{StringBuffer}.\n+  Uses @code{String.valueOf()} to convert to\n+  @code{String}.\n+@end deftypemethod\n+@deftypemethod StringBuffer {public synchronized StringBuffer} append (java.lang.String@w{ }@var{str}) \n+Append the @code{String} to this @code{StringBuffer}.\n+@end deftypemethod\n+@deftypemethod StringBuffer {public StringBuffer} append (char[]@w{ }@var{data}) \n+Append the @code{char} array to this @code{StringBuffer}.\n+@end deftypemethod\n+@deftypemethod StringBuffer {public synchronized StringBuffer} append (char[]@w{ }@var{data}, int@w{ }@var{offset}, int@w{ }@var{count}) \n+Append the @code{char} array to this @code{StringBuffer}.\n+@end deftypemethod\n+@deftypemethod StringBuffer {public int} capacity () \n+Get the total number of characters this @code{StringBuffer}\n+  can support before it must be grown.  Not to be confused with\n+  <em>length</em>.\n+@end deftypemethod\n+@deftypemethod StringBuffer {public synchronized char} charAt (int@w{ }@var{index}) \n+Get the character at the specified index.\n+@end deftypemethod\n+@deftypemethod StringBuffer {public synchronized StringBuffer} delete (int@w{ }@var{start}, int@w{ }@var{end}) \n+Delete characters from this @code{StringBuffer}.\n+  @code{delete(10, 12)} will delete 10 and 11, but not 12.\n+@end deftypemethod\n+@deftypemethod StringBuffer {public StringBuffer} deleteCharAt (int@w{ }@var{index}) \n+Delete a character from this @code{StringBuffer}.\n+@end deftypemethod\n+@deftypemethod StringBuffer {public synchronized void} ensureCapacity (int@w{ }@var{minimumCapacity}) \n+Increase the capacity of this @code{StringBuffer}.\n+  This will ensure that an expensive growing operation will not occur\n+  until @code{minimumCapacity} is reached.\n+  If the capacity is actually already greater than @code{minimumCapacity}\n+@end deftypemethod\n+@deftypemethod StringBuffer {public synchronized void} getChars (int@w{ }@var{srcOffset}, int@w{ }@var{srcEnd}, char[]@w{ }@var{dst}, int@w{ }@var{dstOffset}) \n+Get the specified array of characters.\n+  The characters will be copied into the array you pass in.\n+@end deftypemethod\n+@deftypemethod StringBuffer {public StringBuffer} insert (int@w{ }@var{offset}, boolean@w{ }@var{bool}) \n+Insert the @code{String} value of the argument into this @code{StringBuffer}.\n+  Uses @code{String.valueOf()} to convert to\n+  @code{String}.\n+@end deftypemethod\n+@deftypemethod StringBuffer {public synchronized StringBuffer} insert (int@w{ }@var{offset}, char@w{ }@var{ch}) \n+Insert the @code{char} argument into this @code{StringBuffer}.\n+@end deftypemethod\n+@deftypemethod StringBuffer {public StringBuffer} insert (int@w{ }@var{offset}, int@w{ }@var{inum}) \n+Insert the @code{String} value of the argument into this @code{StringBuffer}.\n+  Uses @code{String.valueOf()} to convert to\n+  @code{String}.\n+@end deftypemethod\n+@deftypemethod StringBuffer {public StringBuffer} insert (int@w{ }@var{offset}, long@w{ }@var{lnum}) \n+Insert the @code{String} value of the argument into this @code{StringBuffer}.\n+  Uses @code{String.valueOf()} to convert to\n+  @code{String}.\n+@end deftypemethod\n+@deftypemethod StringBuffer {public StringBuffer} insert (int@w{ }@var{offset}, float@w{ }@var{fnum}) \n+Insert the @code{String} value of the argument into this @code{StringBuffer}.\n+  Uses @code{String.valueOf()} to convert to\n+  @code{String}.\n+@end deftypemethod\n+@deftypemethod StringBuffer {public StringBuffer} insert (int@w{ }@var{offset}, double@w{ }@var{dnum}) \n+Insert the @code{String} value of the argument into this @code{StringBuffer}.\n+  Uses @code{String.valueOf()} to convert to\n+  @code{String}.\n+@end deftypemethod\n+@deftypemethod StringBuffer {public StringBuffer} insert (int@w{ }@var{offset}, java.lang.Object@w{ }@var{obj}) \n+Insert the @code{String} value of the argument into this @code{StringBuffer}.\n+  Uses @code{String.valueOf()} to convert to\n+  @code{String}.\n+@end deftypemethod\n+@deftypemethod StringBuffer {public synchronized StringBuffer} insert (int@w{ }@var{offset}, java.lang.String@w{ }@var{str}) \n+Insert the @code{String} argument into this @code{StringBuffer}.\n+@end deftypemethod\n+@deftypemethod StringBuffer {public StringBuffer} insert (int@w{ }@var{offset}, char[]@w{ }@var{data}) \n+Insert the @code{char[]} argument into this\n+  @code{StringBuffer}.\n+@end deftypemethod\n+@deftypemethod StringBuffer {public synchronized StringBuffer} insert (int@w{ }@var{offset}, char[]@w{ }@var{str}, int@w{ }@var{str_offset}, int@w{ }@var{len}) \n+Insert the @code{char[]} argument into this\n+  @code{StringBuffer}.\n+@end deftypemethod\n+@deftypemethod StringBuffer {public int} length () \n+Get the length of the @code{String} this\n+  @code{StringBuffer} would create.  Not to be confused with the\n+  <em>capacity</em> of the @code{StringBuffer}.\n+@end deftypemethod\n+@deftypemethod StringBuffer {public synchronized StringBuffer} replace (int@w{ }@var{start}, int@w{ }@var{end}, java.lang.String@w{ }@var{str}) \n+Replace characters between index @code{start} (inclusive) and \n+  @code{end} (exclusive) with @code{str}. If @code{end} \n+  is larger than the size of this StringBuffer, all characters after\n+  @code{start} are replaced.\n+@end deftypemethod\n+@deftypemethod StringBuffer {public synchronized StringBuffer} reverse () \n+Reverse the characters in this StringBuffer.\n+@end deftypemethod\n+@deftypemethod StringBuffer {public synchronized void} setCharAt (int@w{ }@var{index}, char@w{ }@var{ch}) \n+Set the character at the specified index.\n+@end deftypemethod\n+@deftypemethod StringBuffer {public synchronized void} setLength (int@w{ }@var{newLength}) \n+Set the length of this StringBuffer.\n+  \n+\n+\n+  If the new length is greater than the current length, all the new\n+  characters are set to '\\0'.\n+  \n+\n+\n+  If the new length is less than the current length, the first\n+  @code{newLength} characters of the old array will be\n+@end deftypemethod\n+@deftypemethod StringBuffer {public String} substring (int@w{ }@var{beginIndex}) \n+Creates a substring of this StringBuffer, starting at a specified index\n+ and ending at the end of this StringBuffer.\n+@end deftypemethod\n+@deftypemethod StringBuffer {public synchronized String} substring (int@w{ }@var{beginIndex}, int@w{ }@var{endIndex}) \n+Creates a substring of this StringBuffer, starting at a specified index\n+ and ending at one character before a specified index.\n+@end deftypemethod\n+@deftypemethod StringBuffer {public String} toString () \n+Convert this @code{StringBuffer} to a @code{String}.\n+@end deftypemethod\n+@deftypemethod System {public static native void} arraycopy (java.lang.Object@w{ }@var{src}, int@w{ }@var{srcOffset}, java.lang.Object@w{ }@var{dst}, int@w{ }@var{dstOffset}, int@w{ }@var{count}) \n+\n+@end deftypemethod\n+@deftypemethod System {public static native long} currentTimeMillis () \n+\n+@end deftypemethod\n+@deftypemethod System {public static void} exit (int@w{ }@var{status}) \n+\n+@end deftypemethod\n+@deftypemethod System {public static void} gc () \n+\n+@end deftypemethod\n+@deftypemethod System {public static String} getenv (java.lang.String@w{ }@var{name}) \n+\n+@end deftypemethod\n+@deftypemethod System {public static Properties} getProperties () \n+\n+@end deftypemethod\n+@deftypemethod System {public static String} getProperty (java.lang.String@w{ }@var{property}) \n+\n+@end deftypemethod\n+@deftypemethod System {public static String} getProperty (java.lang.String@w{ }@var{property}, java.lang.String@w{ }@var{defval}) \n+\n+@end deftypemethod\n+@deftypemethod System {public static SecurityManager} getSecurityManager () \n+\n+@end deftypemethod\n+@deftypemethod System {public static native int} identityHashCode (java.lang.Object@w{ }@var{obj}) \n+\n+@end deftypemethod\n+@deftypemethod System {public static void} load (java.lang.String@w{ }@var{pathname}) \n+\n+@end deftypemethod\n+@deftypemethod System {public static void} loadLibrary (java.lang.String@w{ }@var{libname}) \n+\n+@end deftypemethod\n+@deftypemethod System {public static void} runFinalization () \n+\n+@end deftypemethod\n+@deftypemethod System {public static void} runFinalizersOnExit (boolean@w{ }@var{run}) \n+\n+@end deftypemethod\n+@deftypemethod System {public static native void} setErr (java.io.PrintStream@w{ }@var{newErr}) \n+\n+@end deftypemethod\n+@deftypemethod System {public static native void} setIn (java.io.InputStream@w{ }@var{newIn}) \n+\n+@end deftypemethod\n+@deftypemethod System {public static native void} setOut (java.io.PrintStream@w{ }@var{newOut}) \n+\n+@end deftypemethod\n+@deftypemethod System {public static void} setProperties (java.util.Properties@w{ }@var{props}) \n+\n+@end deftypemethod\n+@deftypemethod System {public static String} setProperty (java.lang.String@w{ }@var{key}, java.lang.String@w{ }@var{value}) \n+\n+@end deftypemethod\n+@deftypemethod System {public static void} setSecurityManager (java.lang.SecurityManager@w{ }@var{s}) \n+\n+@end deftypemethod\n+@deftypemethod Thread {public static int} activeCount () \n+\n+@end deftypemethod\n+@deftypemethod Thread {public final void} checkAccess () \n+\n+@end deftypemethod\n+@deftypemethod Thread {public native int} countStackFrames () \n+\n+@end deftypemethod\n+@deftypemethod Thread {public static native Thread} currentThread () \n+\n+@end deftypemethod\n+@deftypemethod Thread {public native void} destroy () \n+\n+@end deftypemethod\n+@deftypemethod Thread {public static void} dumpStack () \n+\n+@end deftypemethod\n+@deftypemethod Thread {public static int} enumerate (java.lang.Thread[]@w{ }@var{threads}) \n+\n+@end deftypemethod\n+@deftypemethod Thread {public final String} getName () \n+\n+@end deftypemethod\n+@deftypemethod Thread {public final int} getPriority () \n+\n+@end deftypemethod\n+@deftypemethod Thread {public final ThreadGroup} getThreadGroup () \n+\n+@end deftypemethod\n+@deftypemethod Thread {public native void} interrupt () \n+\n+@end deftypemethod\n+@deftypemethod Thread {public static boolean} interrupted () \n+\n+@end deftypemethod\n+@deftypemethod Thread {public boolean} isInterrupted () \n+\n+@end deftypemethod\n+@deftypemethod Thread {public final boolean} isAlive () \n+\n+@end deftypemethod\n+@deftypemethod Thread {public final boolean} isDaemon () \n+\n+@end deftypemethod\n+@deftypemethod Thread {public final void} join () @*throws InterruptedException\n+\n+@end deftypemethod\n+@deftypemethod Thread {public final void} join (long@w{ }@var{timeout}) @*throws InterruptedException\n+\n+@end deftypemethod\n+@deftypemethod Thread {public final native void} join (long@w{ }@var{timeout}, int@w{ }@var{nanos}) @*throws InterruptedException\n+\n+@end deftypemethod\n+@deftypemethod Thread {public final native void} resume () \n+\n+@end deftypemethod\n+@deftypemethod Thread {public void} run () \n+\n+@end deftypemethod\n+@deftypemethod Thread {public final void} setDaemon (boolean@w{ }@var{status}) \n+\n+@end deftypemethod\n+@deftypemethod Thread {public synchronized ClassLoader} getContextClassLoader () \n+\n+@end deftypemethod\n+@deftypemethod Thread {public synchronized void} setContextClassLoader (java.lang.ClassLoader@w{ }@var{cl}) \n+\n+@end deftypemethod\n+@deftypemethod Thread {public final void} setName (java.lang.String@w{ }@var{n}) \n+\n+@end deftypemethod\n+@deftypemethod Thread {public final native void} setPriority (int@w{ }@var{newPriority}) \n+\n+@end deftypemethod\n+@deftypemethod Thread {public static void} sleep (long@w{ }@var{timeout}) @*throws InterruptedException\n+\n+@end deftypemethod\n+@deftypemethod Thread {public static native void} sleep (long@w{ }@var{timeout}, int@w{ }@var{nanos}) @*throws InterruptedException\n+\n+@end deftypemethod\n+@deftypemethod Thread {public native synchronized void} start () \n+\n+@end deftypemethod\n+@deftypemethod Thread {public final void} stop () \n+\n+@end deftypemethod\n+@deftypemethod Thread {public final native synchronized void} stop (java.lang.Throwable@w{ }@var{e}) \n+\n+@end deftypemethod\n+@deftypemethod Thread {public final native void} suspend () \n+\n+@end deftypemethod\n+@deftypemethod Thread {public String} toString () \n+\n+@end deftypemethod\n+@deftypemethod Thread {public static native void} yield () \n+\n+@end deftypemethod\n+@deftypemethod ThreadGroup {public final String} getName () \n+Get the name of this ThreadGroup.\n+@end deftypemethod\n+@deftypemethod ThreadGroup {public final ThreadGroup} getParent () \n+Get the parent of this ThreadGroup.\n+@end deftypemethod\n+@deftypemethod ThreadGroup {public final synchronized void} setMaxPriority (int@w{ }@var{maxpri}) \n+Set the maximum priority for Threads in this ThreadGroup. setMaxPriority\n+  can only be used to reduce the current maximum. If maxpri\n+  is greater than the current Maximum, the current value is not changed.\n+  Calling this does not effect threads already in this ThreadGroup.\n+@end deftypemethod\n+@deftypemethod ThreadGroup {public final int} getMaxPriority () \n+Get the maximum priority of Threads in this ThreadGroup.\n+@end deftypemethod\n+@deftypemethod ThreadGroup {public final void} setDaemon (boolean@w{ }@var{daemon}) \n+Set whether this ThreadGroup is a daemon group.  A daemon\n+  group will be destroyed when its last thread is stopped and\n+  its last thread group is destroyed.\n+@end deftypemethod\n+@deftypemethod ThreadGroup {public final boolean} isDaemon () \n+Tell whether this ThreadGroup is a daemon group.  A daemon\n+ group will be destroyed when its last thread is stopped and\n+ its last thread group is destroyed.\n+@end deftypemethod\n+@deftypemethod ThreadGroup {public synchronized boolean} isDestroyed () \n+Tell whether this ThreadGroup has been destroyed or not.\n+@end deftypemethod\n+@deftypemethod ThreadGroup {public final boolean} parentOf (java.lang.ThreadGroup@w{ }@var{tg}) \n+Check whether this ThreadGroup is an ancestor of the\n+ specified ThreadGroup, or if they are the same.\n+@end deftypemethod\n+@deftypemethod ThreadGroup {public synchronized int} activeCount () \n+Return the total number of active threads in this ThreadGroup\n+ and all its descendants.\n+\n+\n+\n+ This cannot return an exact number, since the status of threads\n+ may change after they were counted.  But it should be pretty\n+ close.\n+\n+\n+@end deftypemethod\n+@deftypemethod ThreadGroup {public synchronized int} activeGroupCount () \n+Get the number of active groups in this ThreadGroup.  This group\n+ itself is not included in the count.\n+@end deftypemethod\n+@deftypemethod ThreadGroup {public int} enumerate (java.lang.Thread[]@w{ }@var{threads}) \n+Copy all of the active Threads from this ThreadGroup and\n+ its descendants into the specified array.  If the array is\n+ not big enough to hold all the Threads, extra Threads will\n+ simply not be copied.\n+@end deftypemethod\n+@deftypemethod ThreadGroup {public int} enumerate (java.lang.Thread[]@w{ }@var{threads}, boolean@w{ }@var{useDescendants}) \n+Copy all of the active Threads from this ThreadGroup and,\n+ if desired, from its descendants, into the specified array.\n+ If the array is not big enough to hold all the Threads,\n+ extra Threads will simply not be copied.\n+@end deftypemethod\n+@deftypemethod ThreadGroup {public int} enumerate (java.lang.ThreadGroup[]@w{ }@var{groups}) \n+Copy all active ThreadGroups that are descendants of this\n+ ThreadGroup into the specified array.  If the array is not\n+ large enough to hold all active ThreadGroups, extra\n+ ThreadGroups simply will not be copied.\n+@end deftypemethod\n+@deftypemethod ThreadGroup {public int} enumerate (java.lang.ThreadGroup[]@w{ }@var{groups}, boolean@w{ }@var{recurse}) \n+Copy all active ThreadGroups that are children of this\n+ ThreadGroup into the specified array, and if desired, also\n+ copy all active descendants into the array.  If the array\n+ is not large enough to hold all active ThreadGroups, extra\n+ ThreadGroups simply will not be copied.\n+@end deftypemethod\n+@deftypemethod ThreadGroup {public final synchronized void} interrupt () \n+Interrupt all Threads in this ThreadGroup and its sub-groups.\n+@end deftypemethod\n+@deftypemethod ThreadGroup {public final synchronized void} stop () \n+Stop all Threads in this ThreadGroup and its descendants.\n+@end deftypemethod\n+@deftypemethod ThreadGroup {public final synchronized void} suspend () \n+Suspend all Threads in this ThreadGroup and its descendants.\n+@end deftypemethod\n+@deftypemethod ThreadGroup {public final synchronized void} resume () \n+Resume all Threads in this ThreadGroup and its descendants.\n+@end deftypemethod\n+@deftypemethod ThreadGroup {public final synchronized void} destroy () \n+Destroy this ThreadGroup.  There can be no Threads in it,\n+ and none of its descendants (sub-groups) may have Threads in them.\n+ All its descendants will be destroyed as well.\n+@end deftypemethod\n+@deftypemethod ThreadGroup {public void} list () \n+Print out information about this ThreadGroup to System.out.\n+@end deftypemethod\n+@deftypemethod ThreadGroup {public void} uncaughtException (java.lang.Thread@w{ }@var{thread}, java.lang.Throwable@w{ }@var{t}) \n+When a Thread in this ThreadGroup does not catch an exception,\n+ this method of the ThreadGroup is called.\n+\n+\n+\n+ ThreadGroup's implementation does the following:<BR>\n+ \n+@itemize @bullet\n+\n+ \n+@item\n+If there is a parent ThreadGroup, call uncaughtException()\n+\t  in the parent.\n+\n+ \n+@item\n+If the Throwable passed is a ThreadDeath, don't do\n+\t  anything.\n+\n+ \n+@item\n+Otherwise, call @code{exception.printStackTrace().}\n+\n+ \n+@end itemize\n+\n+@end deftypemethod\n+@deftypemethod ThreadGroup {public boolean} allowThreadSuspension (boolean@w{ }@var{allow}) \n+Tell the VM whether it may suspend Threads in low memory\n+ situations.\n+@end deftypemethod\n+@deftypemethod ThreadGroup {public String} toString () \n+Get a human-readable representation of this ThreadGroup.\n+@end deftypemethod\n+@deftypemethod ThreadGroup {public final void} checkAccess () \n+Find out if the current Thread can modify this ThreadGroup.\n+ Calls the current SecurityManager's checkAccess() method to\n+ find out.  If there is none, it assumes everything's OK.\n+@end deftypemethod\n+@deftypemethod Throwable {public native Throwable} fillInStackTrace () \n+\n+@end deftypemethod\n+@deftypemethod Throwable {public String} getLocalizedMessage () \n+\n+@end deftypemethod\n+@deftypemethod Throwable {public String} getMessage () \n+\n+@end deftypemethod\n+@deftypemethod Throwable {public void} printStackTrace () \n+\n+@end deftypemethod\n+@deftypemethod Throwable {public void} printStackTrace (java.io.PrintStream@w{ }@var{ps}) \n+\n+@end deftypemethod\n+@deftypemethod Throwable {public void} printStackTrace (java.io.PrintWriter@w{ }@var{wr}) \n+\n+@end deftypemethod\n+@deftypemethod Throwable {public String} toString () \n+\n+@end deftypemethod"}, {"sha": "0b2c4e29a8bf68fcb10100c5fa96228351b9e40e", "filename": "libjava/doc/java-math.texi", "status": "added", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2Fdoc%2Fjava-math.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2Fdoc%2Fjava-math.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fdoc%2Fjava-math.texi?ref=6a9d31a7d48bbae78a24a1395199d5c4c048d642", "patch": "@@ -0,0 +1,206 @@\n+@deftypemethod BigDecimal {public static BigDecimal} valueOf (long@w{ }@var{val}) \n+\n+@end deftypemethod\n+@deftypemethod BigDecimal {public static BigDecimal} valueOf (long@w{ }@var{val}, int@w{ }@var{scale}) @*throws NumberFormatException\n+\n+@end deftypemethod\n+@deftypemethod BigDecimal {public BigDecimal} add (java.math.BigDecimal@w{ }@var{val}) \n+\n+@end deftypemethod\n+@deftypemethod BigDecimal {public BigDecimal} subtract (java.math.BigDecimal@w{ }@var{val}) \n+\n+@end deftypemethod\n+@deftypemethod BigDecimal {public BigDecimal} multiply (java.math.BigDecimal@w{ }@var{val}) \n+\n+@end deftypemethod\n+@deftypemethod BigDecimal {public BigDecimal} divide (java.math.BigDecimal@w{ }@var{val}, int@w{ }@var{roundingMode}) @*throws ArithmeticException, IllegalArgumentException\n+\n+@end deftypemethod\n+@deftypemethod BigDecimal {public BigDecimal} divide (java.math.BigDecimal@w{ }@var{val}, int@w{ }@var{newScale}, int@w{ }@var{roundingMode}) @*throws ArithmeticException, IllegalArgumentException\n+\n+@end deftypemethod\n+@deftypemethod BigDecimal {public int} compareTo (java.math.BigDecimal@w{ }@var{val}) \n+\n+@end deftypemethod\n+@deftypemethod BigDecimal {public int} compareTo (java.lang.Object@w{ }@var{val}) \n+\n+@end deftypemethod\n+@deftypemethod BigDecimal {public boolean} equals (java.lang.Object@w{ }@var{o}) \n+\n+@end deftypemethod\n+@deftypemethod BigDecimal {public int} hashCode () \n+\n+@end deftypemethod\n+@deftypemethod BigDecimal {public BigDecimal} max (java.math.BigDecimal@w{ }@var{val}) \n+\n+@end deftypemethod\n+@deftypemethod BigDecimal {public BigDecimal} min (java.math.BigDecimal@w{ }@var{val}) \n+\n+@end deftypemethod\n+@deftypemethod BigDecimal {public BigDecimal} movePointLeft (int@w{ }@var{n}) \n+\n+@end deftypemethod\n+@deftypemethod BigDecimal {public BigDecimal} movePointRight (int@w{ }@var{n}) \n+\n+@end deftypemethod\n+@deftypemethod BigDecimal {public int} signum () \n+\n+@end deftypemethod\n+@deftypemethod BigDecimal {public int} scale () \n+\n+@end deftypemethod\n+@deftypemethod BigDecimal {public BigDecimal} abs () \n+\n+@end deftypemethod\n+@deftypemethod BigDecimal {public BigDecimal} negate () \n+\n+@end deftypemethod\n+@deftypemethod BigDecimal {public String} toString () \n+\n+@end deftypemethod\n+@deftypemethod BigDecimal {public BigInteger} toBigInteger () \n+\n+@end deftypemethod\n+@deftypemethod BigDecimal {public int} intValue () \n+\n+@end deftypemethod\n+@deftypemethod BigDecimal {public long} longValue () \n+\n+@end deftypemethod\n+@deftypemethod BigDecimal {public float} floatValue () \n+\n+@end deftypemethod\n+@deftypemethod BigDecimal {public double} doubleValue () \n+\n+@end deftypemethod\n+@deftypemethod BigInteger {public static BigInteger} valueOf (long@w{ }@var{val}) \n+\n+@end deftypemethod\n+@deftypemethod BigInteger {public int} signum () \n+\n+@end deftypemethod\n+@deftypemethod BigInteger {public int} compareTo (java.lang.Object@w{ }@var{obj}) \n+\n+@end deftypemethod\n+@deftypemethod BigInteger {public int} compareTo (java.math.BigInteger@w{ }@var{val}) \n+\n+@end deftypemethod\n+@deftypemethod BigInteger {public BigInteger} min (java.math.BigInteger@w{ }@var{val}) \n+\n+@end deftypemethod\n+@deftypemethod BigInteger {public BigInteger} max (java.math.BigInteger@w{ }@var{val}) \n+\n+@end deftypemethod\n+@deftypemethod BigInteger {public BigInteger} add (java.math.BigInteger@w{ }@var{val}) \n+\n+@end deftypemethod\n+@deftypemethod BigInteger {public BigInteger} subtract (java.math.BigInteger@w{ }@var{val}) \n+\n+@end deftypemethod\n+@deftypemethod BigInteger {public BigInteger} multiply (java.math.BigInteger@w{ }@var{y}) \n+\n+@end deftypemethod\n+@deftypemethod BigInteger {public BigInteger} divide (java.math.BigInteger@w{ }@var{val}) \n+\n+@end deftypemethod\n+@deftypemethod BigInteger {public BigInteger} remainder (java.math.BigInteger@w{ }@var{val}) \n+\n+@end deftypemethod\n+@deftypemethod BigInteger {public BigInteger} divideAndRemainder (java.math.BigInteger@w{ }@var{val}) \n+\n+@end deftypemethod\n+@deftypemethod BigInteger {public BigInteger} mod (java.math.BigInteger@w{ }@var{m}) \n+\n+@end deftypemethod\n+@deftypemethod BigInteger {public BigInteger} pow (int@w{ }@var{exponent}) \n+Calculate the integral power of a BigInteger.\n+@end deftypemethod\n+@deftypemethod BigInteger {public BigInteger} modInverse (java.math.BigInteger@w{ }@var{y}) \n+\n+@end deftypemethod\n+@deftypemethod BigInteger {public BigInteger} modPow (java.math.BigInteger@w{ }@var{exponent}, java.math.BigInteger@w{ }@var{m}) \n+\n+@end deftypemethod\n+@deftypemethod BigInteger {public BigInteger} gcd (java.math.BigInteger@w{ }@var{y}) \n+\n+@end deftypemethod\n+@deftypemethod BigInteger {public boolean} isProbablePrime (int@w{ }@var{certainty}) \n+\n+@end deftypemethod\n+@deftypemethod BigInteger {public BigInteger} shiftLeft (int@w{ }@var{n}) \n+\n+@end deftypemethod\n+@deftypemethod BigInteger {public BigInteger} shiftRight (int@w{ }@var{n}) \n+\n+@end deftypemethod\n+@deftypemethod BigInteger {public String} toString () \n+\n+@end deftypemethod\n+@deftypemethod BigInteger {public String} toString (int@w{ }@var{radix}) \n+\n+@end deftypemethod\n+@deftypemethod BigInteger {public int} intValue () \n+\n+@end deftypemethod\n+@deftypemethod BigInteger {public long} longValue () \n+\n+@end deftypemethod\n+@deftypemethod BigInteger {public int} hashCode () \n+\n+@end deftypemethod\n+@deftypemethod BigInteger {public boolean} equals (java.lang.Object@w{ }@var{obj}) \n+\n+@end deftypemethod\n+@deftypemethod BigInteger {public double} doubleValue () \n+\n+@end deftypemethod\n+@deftypemethod BigInteger {public float} floatValue () \n+\n+@end deftypemethod\n+@deftypemethod BigInteger {public BigInteger} abs () \n+\n+@end deftypemethod\n+@deftypemethod BigInteger {public BigInteger} negate () \n+\n+@end deftypemethod\n+@deftypemethod BigInteger {public int} bitLength () \n+Calculates ceiling(log2(this < 0 ? -this : this+1))\n+ See Common Lisp: the Language, 2nd ed, p. 361.\n+@end deftypemethod\n+@deftypemethod BigInteger {public byte} toByteArray () \n+\n+@end deftypemethod\n+@deftypemethod BigInteger {public BigInteger} and (java.math.BigInteger@w{ }@var{y}) \n+Return the logical (bit-wise) \"and\" of two BigIntegers.\n+@end deftypemethod\n+@deftypemethod BigInteger {public BigInteger} or (java.math.BigInteger@w{ }@var{y}) \n+Return the logical (bit-wise) \"(inclusive) or\" of two BigIntegers.\n+@end deftypemethod\n+@deftypemethod BigInteger {public BigInteger} xor (java.math.BigInteger@w{ }@var{y}) \n+Return the logical (bit-wise) \"exclusive or\" of two BigIntegers.\n+@end deftypemethod\n+@deftypemethod BigInteger {public BigInteger} not () \n+Return the logical (bit-wise) negation of a BigInteger.\n+@end deftypemethod\n+@deftypemethod BigInteger {public BigInteger} andNot (java.math.BigInteger@w{ }@var{val}) \n+\n+@end deftypemethod\n+@deftypemethod BigInteger {public BigInteger} clearBit (int@w{ }@var{n}) \n+\n+@end deftypemethod\n+@deftypemethod BigInteger {public BigInteger} setBit (int@w{ }@var{n}) \n+\n+@end deftypemethod\n+@deftypemethod BigInteger {public boolean} testBit (int@w{ }@var{n}) \n+\n+@end deftypemethod\n+@deftypemethod BigInteger {public BigInteger} flipBit (int@w{ }@var{n}) \n+\n+@end deftypemethod\n+@deftypemethod BigInteger {public int} getLowestSetBit () \n+\n+@end deftypemethod\n+@deftypemethod BigInteger {public int} bitCount () \n+Count one bits in a BigInteger.\n+ If argument is negative, count zero bits instead.\n+@end deftypemethod"}, {"sha": "0d172b9c690c1c0f6bb83667bc266cda7768f434", "filename": "libjava/doc/java-net.texi", "status": "added", "additions": 558, "deletions": 0, "changes": 558, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2Fdoc%2Fjava-net.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2Fdoc%2Fjava-net.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fdoc%2Fjava-net.texi?ref=6a9d31a7d48bbae78a24a1395199d5c4c048d642", "patch": "@@ -0,0 +1,558 @@\n+@deftypemethod ContentHandlerFactory {public ContentHandler} createContentHandler (java.lang.String@w{ }@var{mimetype}) \n+\n+@end deftypemethod\n+@deftypemethod ContentHandler {public abstract Object} getContent (java.net.URLConnection@w{ }@var{urlc}) @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod DatagramPacket {public synchronized InetAddress} getAddress () \n+\n+@end deftypemethod\n+@deftypemethod DatagramPacket {public synchronized int} getPort () \n+\n+@end deftypemethod\n+@deftypemethod DatagramPacket {public synchronized byte} getData () \n+\n+@end deftypemethod\n+@deftypemethod DatagramPacket {public synchronized int} getOffset () \n+\n+@end deftypemethod\n+@deftypemethod DatagramPacket {public synchronized int} getLength () \n+\n+@end deftypemethod\n+@deftypemethod DatagramPacket {public synchronized void} setAddress (java.net.InetAddress@w{ }@var{iaddr}) \n+\n+@end deftypemethod\n+@deftypemethod DatagramPacket {public synchronized void} setPort (int@w{ }@var{iport}) \n+\n+@end deftypemethod\n+@deftypemethod DatagramPacket {public synchronized void} setData (byte[]@w{ }@var{buf}) \n+\n+@end deftypemethod\n+@deftypemethod DatagramPacket {public synchronized void} setData (byte[]@w{ }@var{buf}, int@w{ }@var{offset}, int@w{ }@var{length}) \n+\n+@end deftypemethod\n+@deftypemethod DatagramPacket {public synchronized void} setLength (int@w{ }@var{length}) \n+\n+@end deftypemethod\n+@deftypemethod DatagramSocketImpl {protected abstract void} bind (int@w{ }@var{lport}, java.net.InetAddress@w{ }@var{laddr}) @*throws SocketException\n+\n+@end deftypemethod\n+@deftypemethod DatagramSocketImpl {protected abstract void} close () \n+\n+@end deftypemethod\n+@deftypemethod DatagramSocketImpl {protected abstract void} create () @*throws SocketException\n+\n+@end deftypemethod\n+@deftypemethod DatagramSocketImpl {protected abstract int} peek (java.net.InetAddress@w{ }@var{i}) @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod DatagramSocketImpl {protected abstract void} send (java.net.DatagramPacket@w{ }@var{p}) @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod DatagramSocketImpl {protected abstract void} receive (java.net.DatagramPacket@w{ }@var{p}) @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod DatagramSocketImpl {protected abstract void} setTTL (byte@w{ }@var{ttl}) @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod DatagramSocketImpl {protected abstract byte} getTTL () @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod DatagramSocketImpl {protected abstract void} setTimeToLive (int@w{ }@var{ttl}) @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod DatagramSocketImpl {protected abstract int} getTimeToLive () @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod DatagramSocketImpl {protected abstract void} join (java.net.InetAddress@w{ }@var{inetaddr}) @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod DatagramSocketImpl {protected abstract void} leave (java.net.InetAddress@w{ }@var{inetaddr}) @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod DatagramSocketImpl {public abstract Object} getOption (int@w{ }@var{optID}) @*throws SocketException\n+\n+@end deftypemethod\n+@deftypemethod DatagramSocketImpl {public abstract void} setOption (int@w{ }@var{optID}, java.lang.Object@w{ }@var{value}) @*throws SocketException\n+\n+@end deftypemethod\n+@deftypemethod DatagramSocketImpl {protected FileDescriptor} getFileDescriptor () \n+\n+@end deftypemethod\n+@deftypemethod DatagramSocketImpl {protected int} getLocalPort () \n+\n+@end deftypemethod\n+@deftypemethod DatagramSocket {public void} close () \n+\n+@end deftypemethod\n+@deftypemethod DatagramSocket {public InetAddress} getLocalAddress () \n+\n+@end deftypemethod\n+@deftypemethod DatagramSocket {public int} getLocalPort () \n+\n+@end deftypemethod\n+@deftypemethod DatagramSocket {public synchronized int} getSoTimeout () @*throws SocketException\n+\n+@end deftypemethod\n+@deftypemethod DatagramSocket {public synchronized void} receive (java.net.DatagramPacket@w{ }@var{p}) @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod DatagramSocket {public void} send (java.net.DatagramPacket@w{ }@var{p}) @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod DatagramSocket {public synchronized void} setSoTimeout (int@w{ }@var{timeout}) @*throws SocketException\n+\n+@end deftypemethod\n+@deftypemethod FileNameMap {public String} getContentTypeFor (java.lang.String@w{ }@var{fileName}) \n+\n+@end deftypemethod\n+@deftypemethod HttpURLConnection {public abstract void} disconnect () \n+\n+@end deftypemethod\n+@deftypemethod HttpURLConnection {public abstract boolean} usingProxy () \n+\n+@end deftypemethod\n+@deftypemethod HttpURLConnection {public static void} setFollowRedirects (boolean@w{ }@var{set}) \n+\n+@end deftypemethod\n+@deftypemethod HttpURLConnection {public static boolean} getFollowRedirects () \n+\n+@end deftypemethod\n+@deftypemethod HttpURLConnection {public void} setRequestMethod (java.lang.String@w{ }@var{method}) @*throws ProtocolException\n+\n+@end deftypemethod\n+@deftypemethod HttpURLConnection {public String} getRequestMethod () \n+\n+@end deftypemethod\n+@deftypemethod HttpURLConnection {public int} getResponseCode () @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod HttpURLConnection {public String} getResponseMessage () @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod InetAddress {public boolean} isMulticastAddress () \n+\n+@end deftypemethod\n+@deftypemethod InetAddress {public String} getHostName () \n+\n+@end deftypemethod\n+@deftypemethod InetAddress {public byte} getAddress () \n+\n+@end deftypemethod\n+@deftypemethod InetAddress {public String} getHostAddress () \n+\n+@end deftypemethod\n+@deftypemethod InetAddress {public int} hashCode () \n+\n+@end deftypemethod\n+@deftypemethod InetAddress {public boolean} equals (java.lang.Object@w{ }@var{obj}) \n+\n+@end deftypemethod\n+@deftypemethod InetAddress {public String} toString () \n+\n+@end deftypemethod\n+@deftypemethod InetAddress {public static InetAddress} getByName (java.lang.String@w{ }@var{host}) @*throws UnknownHostException\n+\n+@end deftypemethod\n+@deftypemethod InetAddress {public static InetAddress} getAllByName (java.lang.String@w{ }@var{host}) @*throws UnknownHostException\n+\n+@end deftypemethod\n+@deftypemethod InetAddress {public static InetAddress} getLocalHost () @*throws UnknownHostException\n+\n+@end deftypemethod\n+@deftypemethod JarURLConnection {public URL} getJarFileURL () \n+\n+@end deftypemethod\n+@deftypemethod JarURLConnection {public String} getEntryName () \n+\n+@end deftypemethod\n+@deftypemethod JarURLConnection {public synchronized void} connect () @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod JarURLConnection {public InputStream} getInputStream () @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod JarURLConnection {public JarEntry} getJarEntry () @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod JarURLConnection {public abstract JarFile} getJarFile () @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod JarURLConnection {public String} getHeaderField (java.lang.String@w{ }@var{name}) \n+\n+@end deftypemethod\n+@deftypemethod JarURLConnection {public String} getHeaderField (int@w{ }@var{n}) \n+\n+@end deftypemethod\n+@deftypemethod JarURLConnection {public String} getHeaderFieldKey (int@w{ }@var{n}) \n+\n+@end deftypemethod\n+@deftypemethod MulticastSocket {public InetAddress} getInterface () @*throws SocketException\n+\n+@end deftypemethod\n+@deftypemethod MulticastSocket {public byte} getTTL () @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod MulticastSocket {public int} getTimeToLive () @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod MulticastSocket {public void} setInterface (java.net.InetAddress@w{ }@var{inf}) @*throws SocketException\n+\n+@end deftypemethod\n+@deftypemethod MulticastSocket {public void} setTTL (byte@w{ }@var{ttl}) @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod MulticastSocket {public void} setTimeToLive (int@w{ }@var{ttl}) @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod MulticastSocket {public void} joinGroup (java.net.InetAddress@w{ }@var{mcastaddr}) @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod MulticastSocket {public void} leaveGroup (java.net.InetAddress@w{ }@var{mcastaddr}) @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod MulticastSocket {public synchronized void} send (java.net.DatagramPacket@w{ }@var{p}, byte@w{ }@var{ttl}) @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod ServerSocket {public InetAddress} getInetAddress () \n+\n+@end deftypemethod\n+@deftypemethod ServerSocket {public int} getLocalPort () \n+\n+@end deftypemethod\n+@deftypemethod ServerSocket {public Socket} accept () @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod ServerSocket {protected final void} implAccept (java.net.Socket@w{ }@var{s}) @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod ServerSocket {public void} close () @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod ServerSocket {public synchronized void} setSoTimeout (int@w{ }@var{timeout}) @*throws SocketException\n+\n+@end deftypemethod\n+@deftypemethod ServerSocket {public synchronized int} getSoTimeout () @*throws SocketException\n+\n+@end deftypemethod\n+@deftypemethod ServerSocket {public String} toString () \n+\n+@end deftypemethod\n+@deftypemethod ServerSocket {public static synchronized void} setSocketFactory (java.net.SocketImplFactory@w{ }@var{fac}) @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod SocketImplFactory {public SocketImpl} createSocketImpl () \n+\n+@end deftypemethod\n+@deftypemethod SocketImpl {protected abstract void} create (boolean@w{ }@var{stream}) @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod SocketImpl {protected abstract void} connect (java.lang.String@w{ }@var{host}, int@w{ }@var{port}) @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod SocketImpl {protected abstract void} connect (java.net.InetAddress@w{ }@var{host}, int@w{ }@var{port}) @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod SocketImpl {protected abstract void} bind (java.net.InetAddress@w{ }@var{host}, int@w{ }@var{port}) @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod SocketImpl {protected abstract void} listen (int@w{ }@var{backlog}) @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod SocketImpl {protected abstract void} accept (java.net.SocketImpl@w{ }@var{s}) @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod SocketImpl {protected abstract InputStream} getInputStream () @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod SocketImpl {protected abstract OutputStream} getOutputStream () @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod SocketImpl {protected abstract int} available () @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod SocketImpl {protected abstract void} close () @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod SocketImpl {protected FileDescriptor} getFileDescriptor () \n+\n+@end deftypemethod\n+@deftypemethod SocketImpl {protected InetAddress} getInetAddress () \n+\n+@end deftypemethod\n+@deftypemethod SocketImpl {protected int} getPort () \n+\n+@end deftypemethod\n+@deftypemethod SocketImpl {protected int} getLocalPort () \n+\n+@end deftypemethod\n+@deftypemethod SocketImpl {public abstract Object} getOption (int@w{ }@var{optID}) @*throws SocketException\n+\n+@end deftypemethod\n+@deftypemethod SocketImpl {public abstract void} setOption (int@w{ }@var{optID}, java.lang.Object@w{ }@var{value}) @*throws SocketException\n+\n+@end deftypemethod\n+@deftypemethod SocketImpl {public String} toString () \n+\n+@end deftypemethod\n+@deftypemethod Socket {public InetAddress} getInetAddress () \n+\n+@end deftypemethod\n+@deftypemethod Socket {public InetAddress} getLocalAddress () \n+\n+@end deftypemethod\n+@deftypemethod Socket {public int} getPort () \n+\n+@end deftypemethod\n+@deftypemethod Socket {public int} getLocalPort () \n+\n+@end deftypemethod\n+@deftypemethod Socket {public InputStream} getInputStream () @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod Socket {public OutputStream} getOutputStream () @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod Socket {public void} setTcpNoDelay (boolean@w{ }@var{on}) @*throws SocketException\n+\n+@end deftypemethod\n+@deftypemethod Socket {public boolean} getTcpNoDelay () @*throws SocketException\n+\n+@end deftypemethod\n+@deftypemethod Socket {public void} setSoLinger (boolean@w{ }@var{on}, int@w{ }@var{linger}) @*throws SocketException\n+\n+@end deftypemethod\n+@deftypemethod Socket {public int} getSoLinger () @*throws SocketException\n+\n+@end deftypemethod\n+@deftypemethod Socket {public synchronized void} setSoTimeout (int@w{ }@var{timeout}) @*throws SocketException\n+\n+@end deftypemethod\n+@deftypemethod Socket {public synchronized int} getSoTimeout () @*throws SocketException\n+\n+@end deftypemethod\n+@deftypemethod Socket {public void} setSendBufferSize (int@w{ }@var{size}) @*throws SocketException\n+\n+@end deftypemethod\n+@deftypemethod Socket {public int} getSendBufferSize () @*throws SocketException\n+\n+@end deftypemethod\n+@deftypemethod Socket {public void} setReceiveBufferSize (int@w{ }@var{size}) @*throws SocketException\n+\n+@end deftypemethod\n+@deftypemethod Socket {public int} getReceiveBufferSize () @*throws SocketException\n+\n+@end deftypemethod\n+@deftypemethod Socket {public synchronized void} close () @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod Socket {public String} toString () \n+\n+@end deftypemethod\n+@deftypemethod Socket {public static synchronized void} setSocketImplFactory (java.net.SocketImplFactory@w{ }@var{fac}) @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod SocketOptions {public void} setOption (int@w{ }@var{optID}, java.lang.Object@w{ }@var{value}) @*throws SocketException\n+\n+@end deftypemethod\n+@deftypemethod SocketOptions {public Object} getOption (int@w{ }@var{optID}) @*throws SocketException\n+\n+@end deftypemethod\n+@deftypemethod URLClassLoader {protected void} addURL (java.net.URL@w{ }@var{url}) \n+\n+@end deftypemethod\n+@deftypemethod URLClassLoader {public URL} getURLs () \n+\n+@end deftypemethod\n+@deftypemethod URLClassLoader {public Enumeration} findResources (java.lang.String@w{ }@var{name}) \n+\n+@end deftypemethod\n+@deftypemethod URLClassLoader {public URL} findResource (java.lang.String@w{ }@var{name}) \n+\n+@end deftypemethod\n+@deftypemethod URLClassLoader {protected Class} findClass (java.lang.String@w{ }@var{name}) @*throws ClassNotFoundException\n+\n+@end deftypemethod\n+@deftypemethod URLConnection {public abstract void} connect () @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod URLConnection {public URL} getURL () \n+\n+@end deftypemethod\n+@deftypemethod URLConnection {public int} getContentLength () \n+\n+@end deftypemethod\n+@deftypemethod URLConnection {public String} getContentType () \n+\n+@end deftypemethod\n+@deftypemethod URLConnection {public String} getContentEncoding () \n+\n+@end deftypemethod\n+@deftypemethod URLConnection {public long} getExpiration () \n+\n+@end deftypemethod\n+@deftypemethod URLConnection {public long} getDate () \n+\n+@end deftypemethod\n+@deftypemethod URLConnection {public long} getLastModified () \n+\n+@end deftypemethod\n+@deftypemethod URLConnection {public String} getHeaderField (int@w{ }@var{n}) \n+\n+@end deftypemethod\n+@deftypemethod URLConnection {public String} getHeaderField (java.lang.String@w{ }@var{name}) \n+\n+@end deftypemethod\n+@deftypemethod URLConnection {public int} getHeaderFieldInt (java.lang.String@w{ }@var{name}, int@w{ }@var{val}) \n+\n+@end deftypemethod\n+@deftypemethod URLConnection {public long} getHeaderFieldDate (java.lang.String@w{ }@var{name}, long@w{ }@var{val}) \n+\n+@end deftypemethod\n+@deftypemethod URLConnection {public String} getHeaderFieldKey (int@w{ }@var{n}) \n+\n+@end deftypemethod\n+@deftypemethod URLConnection {public Object} getContent () @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod URLConnection {public InputStream} getInputStream () @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod URLConnection {public OutputStream} getOutputStream () @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod URLConnection {public String} toString () \n+\n+@end deftypemethod\n+@deftypemethod URLConnection {public void} setDoInput (boolean@w{ }@var{doinput}) \n+\n+@end deftypemethod\n+@deftypemethod URLConnection {public boolean} getDoInput () \n+\n+@end deftypemethod\n+@deftypemethod URLConnection {public void} setDoOutput (boolean@w{ }@var{dooutput}) \n+\n+@end deftypemethod\n+@deftypemethod URLConnection {public boolean} getDoOutput () \n+\n+@end deftypemethod\n+@deftypemethod URLConnection {public void} setAllowUserInteraction (boolean@w{ }@var{allowuserinteraction}) \n+\n+@end deftypemethod\n+@deftypemethod URLConnection {public boolean} getAllowUserInteraction () \n+\n+@end deftypemethod\n+@deftypemethod URLConnection {public static void} setDefaultAllowUserInteraction (boolean@w{ }@var{defaultallowuserinteraction}) \n+\n+@end deftypemethod\n+@deftypemethod URLConnection {public static boolean} getDefaultAllowUserInteraction () \n+\n+@end deftypemethod\n+@deftypemethod URLConnection {public void} setUseCaches (boolean@w{ }@var{usecaches}) \n+\n+@end deftypemethod\n+@deftypemethod URLConnection {public boolean} getUseCaches () \n+\n+@end deftypemethod\n+@deftypemethod URLConnection {public void} setIfModifiedSince (long@w{ }@var{ifmodifiedsince}) \n+\n+@end deftypemethod\n+@deftypemethod URLConnection {public long} getIfModifiedSince () \n+\n+@end deftypemethod\n+@deftypemethod URLConnection {public boolean} getDefaultUseCaches () \n+\n+@end deftypemethod\n+@deftypemethod URLConnection {public void} setDefaultUseCaches (boolean@w{ }@var{defaultusecaches}) \n+\n+@end deftypemethod\n+@deftypemethod URLConnection {public void} setRequestProperty (java.lang.String@w{ }@var{key}, java.lang.String@w{ }@var{value}) \n+\n+@end deftypemethod\n+@deftypemethod URLConnection {public String} getRequestProperty (java.lang.String@w{ }@var{key}) \n+\n+@end deftypemethod\n+@deftypemethod URLConnection {public static void} setDefaultRequestProperty (java.lang.String@w{ }@var{key}, java.lang.String@w{ }@var{value}) \n+\n+@end deftypemethod\n+@deftypemethod URLConnection {public static String} getDefaultRequestProperty (java.lang.String@w{ }@var{key}) \n+\n+@end deftypemethod\n+@deftypemethod URLConnection {public static void} setContentHandlerFactory (java.net.ContentHandlerFactory@w{ }@var{fac}) \n+\n+@end deftypemethod\n+@deftypemethod URLConnection {protected static String} guessContentTypeFromName (java.lang.String@w{ }@var{fname}) \n+\n+@end deftypemethod\n+@deftypemethod URLConnection {public static FileNameMap} getFileNameMap () \n+\n+@end deftypemethod\n+@deftypemethod URLConnection {public static void} setFileNameMap (java.net.FileNameMap@w{ }@var{map}) \n+\n+@end deftypemethod\n+@deftypemethod URLDecoder {public static String} decode (java.lang.String@w{ }@var{s}) @*throws Exception\n+\n+@end deftypemethod\n+@deftypemethod URLEncoder {public static String} encode (java.lang.String@w{ }@var{s}) \n+\n+@end deftypemethod\n+@deftypemethod URL {public boolean} equals (java.lang.Object@w{ }@var{obj}) \n+\n+@end deftypemethod\n+@deftypemethod URL {public final Object} getContent () @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod URL {public String} getFile () \n+\n+@end deftypemethod\n+@deftypemethod URL {public String} getHost () \n+\n+@end deftypemethod\n+@deftypemethod URL {public int} getPort () \n+\n+@end deftypemethod\n+@deftypemethod URL {public String} getProtocol () \n+\n+@end deftypemethod\n+@deftypemethod URL {public String} getRef () \n+\n+@end deftypemethod\n+@deftypemethod URL {public int} hashCode () \n+\n+@end deftypemethod\n+@deftypemethod URL {public URLConnection} openConnection () @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod URL {public final InputStream} openStream () @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod URL {public boolean} sameFile (java.net.URL@w{ }@var{other}) \n+\n+@end deftypemethod\n+@deftypemethod URL {protected void} set (java.lang.String@w{ }@var{protocol}, java.lang.String@w{ }@var{host}, int@w{ }@var{port}, java.lang.String@w{ }@var{file}, java.lang.String@w{ }@var{ref}) \n+\n+@end deftypemethod\n+@deftypemethod URL {public static synchronized void} setURLStreamHandlerFactory (java.net.URLStreamHandlerFactory@w{ }@var{fac}) \n+\n+@end deftypemethod\n+@deftypemethod URL {public String} toExternalForm () \n+\n+@end deftypemethod\n+@deftypemethod URL {public String} toString () \n+\n+@end deftypemethod\n+@deftypemethod URLStreamHandlerFactory {public URLStreamHandler} createURLStreamHandler (java.lang.String@w{ }@var{protocol}) \n+\n+@end deftypemethod\n+@deftypemethod URLStreamHandler {protected abstract URLConnection} openConnection (java.net.URL@w{ }@var{u}) @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod URLStreamHandler {protected void} parseURL (java.net.URL@w{ }@var{u}, java.lang.String@w{ }@var{spec}, int@w{ }@var{start}, int@w{ }@var{limit}) \n+\n+@end deftypemethod\n+@deftypemethod URLStreamHandler {protected void} setURL (java.net.URL@w{ }@var{u}, java.lang.String@w{ }@var{protocol}, java.lang.String@w{ }@var{host}, int@w{ }@var{port}, java.lang.String@w{ }@var{file}, java.lang.String@w{ }@var{ref}) \n+\n+@end deftypemethod\n+@deftypemethod URLStreamHandler {protected String} toExternalForm (java.net.URL@w{ }@var{u}) \n+\n+@end deftypemethod"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "libjava/doc/java-security-spec.texi", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2Fdoc%2Fjava-security-spec.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2Fdoc%2Fjava-security-spec.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fdoc%2Fjava-security-spec.texi?ref=6a9d31a7d48bbae78a24a1395199d5c4c048d642"}, {"sha": "c1a5da87fe1abe18e6466a3c154999544344f13e", "filename": "libjava/doc/java-security.texi", "status": "added", "additions": 354, "deletions": 0, "changes": 354, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2Fdoc%2Fjava-security.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2Fdoc%2Fjava-security.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fdoc%2Fjava-security.texi?ref=6a9d31a7d48bbae78a24a1395199d5c4c048d642", "patch": "@@ -0,0 +1,354 @@\n+@deftypemethod BasicPermission {public boolean} implies (java.security.Permission@w{ }@var{perm}) \n+This method tests to see if the specified permission is implied by \n+ this permission.  This will be true if the following conditions are met:\n+ \n+\n+\n+ \n+@itemize @bullet\n+\n+ \n+@item\n+The specified object is an instance of @code{BasicPermission}, \n+ or a subclass.\n+ \n+@item\n+The name of the specified permission is identical to this permission's\n+ name or the name of the specified permission satisfies a wildcard match \n+ on this permission.\n+ \n+@end itemize\n+\n+@end deftypemethod\n+@deftypemethod BasicPermission {public boolean} equals (java.lang.Object@w{ }@var{obj}) \n+This method tests to see if this object is equal to the specified\n+ @code{Object}.  This will be true if and only if the specified\n+ object meets the following conditions:\n+ \n+\n+\n+ \n+@itemize @bullet\n+\n+ \n+@item\n+It is an instance of @code{BasicPermission}, or a subclass.\n+ \n+@item\n+It has the same name as this permission.\n+ \n+@end itemize\n+\n+@end deftypemethod\n+@deftypemethod BasicPermission {public int} hashCode () \n+This method returns a hash code for this permission object.  The hash\n+ code returned is the value returned by calling the @code{hashCode}\n+ method on the @code{String} that is the name of this permission.\n+@end deftypemethod\n+@deftypemethod BasicPermission {public String} getActions () \n+This method returns a list of the actions associated with this \n+ permission.  This method always returns the empty string (\"\") since\n+ this class ignores actions.\n+@end deftypemethod\n+@deftypemethod BasicPermission {public PermissionCollection} newPermissionCollection () \n+This method returns an instance of @code{PermissionCollection}\n+ suitable for storing @code{BasicPermission} objects.  This returns\n+ be a sub class of @code{PermissionCollection}\n+ that allows for an efficient and consistent implementation of\n+ the @code{implies} method.  The collection doesn't handle subclasses\n+ of BasicPermission correctly; they must override this method.\n+@end deftypemethod\n+@deftypemethod DigestOutputStream {public MessageDigest} getMessageDigest () \n+Returns the MessageDigest associated with this DigestOutputStream\n+@end deftypemethod\n+@deftypemethod DigestOutputStream {public void} setMessageDigest (java.security.MessageDigest@w{ }@var{digest}) \n+Sets the current MessageDigest to current parameter\n+@end deftypemethod\n+@deftypemethod DigestOutputStream {public void} write (int@w{ }@var{b}) @*throws IOException\n+Updates the hash if the on flag is true and then writes a byte to\n+the underlying output stream.\n+@end deftypemethod\n+@deftypemethod DigestOutputStream {public void} write (byte[]@w{ }@var{b}, int@w{ }@var{off}, int@w{ }@var{len}) @*throws IOException\n+Updates the hash if the on flag is true and then writes the bytes\n+to the underlying output stream.\n+@end deftypemethod\n+@deftypemethod DigestOutputStream {public void} on (boolean@w{ }@var{on}) \n+Sets the flag specifying if this DigestOutputStream updates the\n+digest in the write() methods. The default is on;\n+@end deftypemethod\n+@deftypemethod DigestOutputStream {public String} toString () \n+Converts the output stream and underlying message digest to a string.\n+@end deftypemethod\n+@deftypemethod Guard {public void} checkGuard (java.lang.Object@w{ }@var{obj}) @*throws SecurityException\n+This method tests whether or not access is allowed to the specified\n+ guarded object.  Access is allowed if this method returns silently.  If\n+ access is denied, an exception is generated.\n+@end deftypemethod\n+@deftypemethod Key {public String} getAlgorithm () \n+\n+@end deftypemethod\n+@deftypemethod Key {public String} getFormat () \n+\n+@end deftypemethod\n+@deftypemethod Key {public byte} getEncoded () \n+\n+@end deftypemethod\n+@deftypemethod KeyPairGenerator {public static KeyPairGenerator} getInstance (java.lang.String@w{ }@var{algorithm}) @*throws NoSuchAlgorithmException\n+\n+@end deftypemethod\n+@deftypemethod KeyPairGenerator {public static KeyPairGenerator} getInstance (java.lang.String@w{ }@var{algorithm}, java.lang.String@w{ }@var{provider}) @*throws NoSuchAlgorithmException, NoSuchProviderException\n+\n+@end deftypemethod\n+@deftypemethod KeyPairGenerator {public String} getAlgorithm () \n+\n+@end deftypemethod\n+@deftypemethod KeyPairGenerator {public abstract void} initialize (int@w{ }@var{strength}, java.security.SecureRandom@w{ }@var{random}) \n+\n+@end deftypemethod\n+@deftypemethod KeyPairGenerator {public abstract KeyPair} generateKeyPair () \n+\n+@end deftypemethod\n+@deftypemethod KeyPairGeneratorSpi {public abstract void} initialize (int@w{ }@var{keysize}, java.security.SecureRandom@w{ }@var{random}) \n+\n+@end deftypemethod\n+@deftypemethod KeyPairGeneratorSpi {public abstract KeyPair} generateKeyPair () \n+\n+@end deftypemethod\n+@deftypemethod KeyPair {public PublicKey} getPublic () \n+\n+@end deftypemethod\n+@deftypemethod KeyPair {public PrivateKey} getPrivate () \n+\n+@end deftypemethod\n+@deftypemethod MessageDigest {public static MessageDigest} getInstance (java.lang.String@w{ }@var{algorithm}) @*throws NoSuchAlgorithmException\n+\n+@end deftypemethod\n+@deftypemethod MessageDigest {public static MessageDigest} getInstance (java.lang.String@w{ }@var{algorithm}, java.lang.String@w{ }@var{provider}) @*throws NoSuchAlgorithmException, NoSuchProviderException\n+\n+@end deftypemethod\n+@deftypemethod MessageDigest {public void} update (byte@w{ }@var{input}) \n+\n+@end deftypemethod\n+@deftypemethod MessageDigest {public void} update (byte[]@w{ }@var{input}, int@w{ }@var{offset}, int@w{ }@var{len}) \n+\n+@end deftypemethod\n+@deftypemethod MessageDigest {public void} update (byte[]@w{ }@var{input}) \n+\n+@end deftypemethod\n+@deftypemethod MessageDigest {public byte} digest () \n+\n+@end deftypemethod\n+@deftypemethod MessageDigest {public byte} digest (byte[]@w{ }@var{input}) \n+\n+@end deftypemethod\n+@deftypemethod MessageDigest {public String} toString () \n+\n+@end deftypemethod\n+@deftypemethod MessageDigest {public static boolean} isEqual (byte[]@w{ }@var{digesta}, byte[]@w{ }@var{digestb}) \n+\n+@end deftypemethod\n+@deftypemethod MessageDigest {public void} reset () \n+\n+@end deftypemethod\n+@deftypemethod MessageDigest {public final String} getAlgorithm () \n+\n+@end deftypemethod\n+@deftypemethod MessageDigest {protected abstract void} engineUpdate (byte@w{ }@var{input}) \n+\n+@end deftypemethod\n+@deftypemethod MessageDigest {protected abstract void} engineUpdate (byte[]@w{ }@var{input}, int@w{ }@var{offset}, int@w{ }@var{len}) \n+\n+@end deftypemethod\n+@deftypemethod MessageDigest {protected abstract byte} engineDigest () \n+\n+@end deftypemethod\n+@deftypemethod MessageDigest {protected abstract void} engineReset () \n+\n+@end deftypemethod\n+@deftypemethod MessageDigest {public Object} clone () @*throws CloneNotSupportedException\n+\n+@end deftypemethod\n+@deftypemethod PermissionCollection {public boolean} isReadOnly () \n+This method tests whether or not this @code{PermissionCollection}\n+ object is read only.\n+@end deftypemethod\n+@deftypemethod PermissionCollection {public void} setReadOnly () \n+This method sets this @code{PermissionCollection} object to be\n+ read only.  No further permissions can be added to it after calling this\n+ method.\n+@end deftypemethod\n+@deftypemethod PermissionCollection {public abstract void} add (java.security.Permission@w{ }@var{perm}) @*throws SecurityException, IllegalArgumentException\n+This method adds a new @code{Permission} object to the collection.\n+@end deftypemethod\n+@deftypemethod PermissionCollection {public abstract Enumeration} elements () \n+This method returns an @code{Enumeration} of all the objects in\n+ this collection.\n+@end deftypemethod\n+@deftypemethod PermissionCollection {public abstract boolean} implies (java.security.Permission@w{ }@var{perm}) \n+This method tests whether the specified @code{Permission} object is\n+ implied by this collection of @code{Permission} objects.\n+@end deftypemethod\n+@deftypemethod PermissionCollection {public String} toString () \n+This method returns a @code{String} representation of this\n+ collection.  It will print the class name and has code in the same\n+ manner as @code{Object.toString()} then print a listing of all\n+ the @code{Permission} objects contained.\n+@end deftypemethod\n+@deftypemethod Permission {public String} getName () \n+This method returns the name of this @code{Permission}\n+@end deftypemethod\n+@deftypemethod Permission {public abstract String} getActions () \n+This method returns the list of actions for this @code{Permission}\n+ as a @code{String}.\n+@end deftypemethod\n+@deftypemethod Permission {public void} checkGuard (java.lang.Object@w{ }@var{obj}) @*throws SecurityException\n+This method implements the @code{Guard} interface for this class.\n+ It calls the @code{checkPermission} method in \n+ @code{SecurityManager} with this @code{Permission} as its\n+ argument.  This method returns silently if the security check succeeds\n+ or throws an exception if it fails.\n+@end deftypemethod\n+@deftypemethod Permission {public abstract boolean} implies (java.security.Permission@w{ }@var{perm}) \n+This method tests whether this @code{Permission} implies that the\n+ specified @code{Permission} is also granted.\n+@end deftypemethod\n+@deftypemethod Permission {public abstract int} hashCode () \n+This method returns a hash code for this @code{Permission}.\n+@end deftypemethod\n+@deftypemethod Permission {public String} toString () \n+This method returns a @code{String} representation of this\n+ @code{Permission} object.\n+@end deftypemethod\n+@deftypemethod Permission {public PermissionCollection} newPermissionCollection () \n+This method returns an empty @code{PermissionCollection} object\n+ that can store permissions of this type, or @code{null} if no\n+ such collection is defined.\n+@end deftypemethod\n+@deftypemethod Principal {public String} getName () \n+This method returns a @code{String} that names this \n+ @code{Principal}.\n+@end deftypemethod\n+@deftypemethod Principal {public boolean} equals (java.lang.Object@w{ }@var{obj}) \n+This method tests another @code{Principal} object for equality\n+ with this one.\n+@end deftypemethod\n+@deftypemethod Principal {public int} hashCode () \n+This method returns a hash code value for this @code{Principal}.\n+@end deftypemethod\n+@deftypemethod Principal {public String} toString () \n+This method returns a @code{String} representation of this\n+ @code{Principal}.\n+@end deftypemethod\n+@deftypemethod Provider {public String} getName () \n+This method returns the name assigned to this @code{Provider}.\n+@end deftypemethod\n+@deftypemethod Provider {public double} getVersion () \n+This method retunrs the version number of this @code{Provider}.\n+@end deftypemethod\n+@deftypemethod Provider {public String} getInfo () \n+This method returns a textual description of the @code{Provider}.\n+@end deftypemethod\n+@deftypemethod Provider {public Object} put (java.lang.Object@w{ }@var{key}, java.lang.Object@w{ }@var{value}) \n+This method sets the specified key to have the specified value.\n+@end deftypemethod\n+@deftypemethod Provider {public Object} remove (java.lang.Object@w{ }@var{key}) \n+This method removes the specified key entry (and its associated value)\n+ from the property mapping list.\n+@end deftypemethod\n+@deftypemethod Provider {public void} clear () \n+This method clears the entire property list such that it no longer\n+ contains the properties used to look up the services provided by\n+ the @code{Provider}.\n+@end deftypemethod\n+@deftypemethod Provider {public String} toString () \n+This method returns a @code{String} representation of this\n+ object.  This will include the @code{Provider} name and\n+ version number.\n+@end deftypemethod\n+@deftypemethod Security {public static int} insertProviderAt (java.security.Provider@w{ }@var{provider}, int@w{ }@var{position}) \n+\n+@end deftypemethod\n+@deftypemethod Security {public static int} addProvider (java.security.Provider@w{ }@var{provider}) \n+\n+@end deftypemethod\n+@deftypemethod Security {public static void} removeProvider (java.lang.String@w{ }@var{name}) \n+\n+@end deftypemethod\n+@deftypemethod Security {public static Provider} getProviders () \n+\n+@end deftypemethod\n+@deftypemethod Security {public static Provider} getProvider (java.lang.String@w{ }@var{name}) \n+\n+@end deftypemethod\n+@deftypemethod Security {public static String} getProperty (java.lang.String@w{ }@var{key}) \n+\n+@end deftypemethod\n+@deftypemethod Security {public static void} setProperty (java.lang.String@w{ }@var{key}, java.lang.String@w{ }@var{value}) \n+\n+@end deftypemethod\n+@deftypemethod Signature {public static Signature} getInstance (java.lang.String@w{ }@var{algorithm}) @*throws NoSuchAlgorithmException\n+\n+@end deftypemethod\n+@deftypemethod Signature {public static Signature} getInstance (java.lang.String@w{ }@var{algorithm}, java.lang.String@w{ }@var{provider}) @*throws NoSuchAlgorithmException, NoSuchProviderException\n+\n+@end deftypemethod\n+@deftypemethod Signature {public final void} initVerify (java.security.PublicKey@w{ }@var{publicKey}) @*throws InvalidKeyException\n+\n+@end deftypemethod\n+@deftypemethod Signature {public final void} initSign (java.security.PrivateKey@w{ }@var{privateKey}) @*throws InvalidKeyException\n+\n+@end deftypemethod\n+@deftypemethod Signature {public final byte} sign () @*throws SignatureException\n+\n+@end deftypemethod\n+@deftypemethod Signature {public final boolean} verify (byte[]@w{ }@var{signature}) @*throws SignatureException\n+\n+@end deftypemethod\n+@deftypemethod Signature {public final void} update (byte@w{ }@var{b}) @*throws SignatureException\n+\n+@end deftypemethod\n+@deftypemethod Signature {public final void} update (byte[]@w{ }@var{data}) @*throws SignatureException\n+\n+@end deftypemethod\n+@deftypemethod Signature {public final void} update (byte[]@w{ }@var{data}, int@w{ }@var{off}, int@w{ }@var{len}) @*throws SignatureException\n+\n+@end deftypemethod\n+@deftypemethod Signature {public final String} getAlgorithm () \n+\n+@end deftypemethod\n+@deftypemethod Signature {public String} toString () \n+\n+@end deftypemethod\n+@deftypemethod Signature {public final void} setParameter (java.lang.String@w{ }@var{param}, java.lang.Object@w{ }@var{value}) @*throws InvalidParameterException\n+\n+@end deftypemethod\n+@deftypemethod Signature {public final Object} getParameter (java.lang.String@w{ }@var{param}) @*throws InvalidParameterException\n+\n+@end deftypemethod\n+@deftypemethod Signature {protected abstract void} engineInitVerify (java.security.PublicKey@w{ }@var{publicKey}) @*throws InvalidKeyException\n+\n+@end deftypemethod\n+@deftypemethod Signature {protected abstract void} engineInitSign (java.security.PrivateKey@w{ }@var{privateKey}) @*throws InvalidKeyException\n+\n+@end deftypemethod\n+@deftypemethod Signature {protected abstract void} engineUpdate (byte@w{ }@var{b}) @*throws SignatureException\n+\n+@end deftypemethod\n+@deftypemethod Signature {protected abstract void} engineUpdate (byte[]@w{ }@var{b}, int@w{ }@var{off}, int@w{ }@var{len}) @*throws SignatureException\n+\n+@end deftypemethod\n+@deftypemethod Signature {protected abstract byte} engineSign () @*throws SignatureException\n+\n+@end deftypemethod\n+@deftypemethod Signature {protected abstract boolean} engineVerify (byte[]@w{ }@var{sigBytes}) @*throws SignatureException\n+\n+@end deftypemethod\n+@deftypemethod Signature {protected abstract void} engineSetParameter (java.lang.String@w{ }@var{param}, java.lang.Object@w{ }@var{value}) @*throws InvalidParameterException\n+\n+@end deftypemethod\n+@deftypemethod Signature {protected abstract Object} engineGetParameter (java.lang.String@w{ }@var{param}) @*throws InvalidParameterException\n+\n+@end deftypemethod\n+@deftypemethod Signature {public Object} clone () @*throws CloneNotSupportedException\n+\n+@end deftypemethod"}, {"sha": "b522ff7127c5b3606dba5fd3e0760239fc3c1187", "filename": "libjava/doc/java-sql.texi", "status": "added", "additions": 2892, "deletions": 0, "changes": 2892, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2Fdoc%2Fjava-sql.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2Fdoc%2Fjava-sql.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fdoc%2Fjava-sql.texi?ref=6a9d31a7d48bbae78a24a1395199d5c4c048d642"}, {"sha": "fd6cecc46382559195befa9b2e6dcfee37af9097", "filename": "libjava/doc/java-text.texi", "status": "added", "additions": 859, "deletions": 0, "changes": 859, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2Fdoc%2Fjava-text.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2Fdoc%2Fjava-text.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fdoc%2Fjava-text.texi?ref=6a9d31a7d48bbae78a24a1395199d5c4c048d642", "patch": "@@ -0,0 +1,859 @@\n+@deftypemethod BreakIterator {public abstract int} current () \n+\n+@end deftypemethod\n+@deftypemethod BreakIterator {public abstract int} first () \n+\n+@end deftypemethod\n+@deftypemethod BreakIterator {public abstract int} following (int@w{ }@var{pos}) \n+\n+@end deftypemethod\n+@deftypemethod BreakIterator {public static synchronized Locale} getAvailableLocales () \n+\n+@end deftypemethod\n+@deftypemethod BreakIterator {public static BreakIterator} getCharacterInstance () \n+\n+@end deftypemethod\n+@deftypemethod BreakIterator {public static BreakIterator} getCharacterInstance (java.util.Locale@w{ }@var{loc}) \n+\n+@end deftypemethod\n+@deftypemethod BreakIterator {public static BreakIterator} getLineInstance () \n+\n+@end deftypemethod\n+@deftypemethod BreakIterator {public static BreakIterator} getLineInstance (java.util.Locale@w{ }@var{loc}) \n+\n+@end deftypemethod\n+@deftypemethod BreakIterator {public static BreakIterator} getSentenceInstance () \n+\n+@end deftypemethod\n+@deftypemethod BreakIterator {public static BreakIterator} getSentenceInstance (java.util.Locale@w{ }@var{loc}) \n+\n+@end deftypemethod\n+@deftypemethod BreakIterator {public abstract CharacterIterator} getText () \n+\n+@end deftypemethod\n+@deftypemethod BreakIterator {public static BreakIterator} getWordInstance () \n+\n+@end deftypemethod\n+@deftypemethod BreakIterator {public static BreakIterator} getWordInstance (java.util.Locale@w{ }@var{loc}) \n+\n+@end deftypemethod\n+@deftypemethod BreakIterator {public boolean} isBoundary (int@w{ }@var{pos}) \n+\n+@end deftypemethod\n+@deftypemethod BreakIterator {public abstract int} last () \n+\n+@end deftypemethod\n+@deftypemethod BreakIterator {public abstract int} next () \n+\n+@end deftypemethod\n+@deftypemethod BreakIterator {public abstract int} next (int@w{ }@var{n}) \n+\n+@end deftypemethod\n+@deftypemethod BreakIterator {public int} preceding (int@w{ }@var{pos}) \n+\n+@end deftypemethod\n+@deftypemethod BreakIterator {public abstract int} previous () \n+\n+@end deftypemethod\n+@deftypemethod BreakIterator {public void} setText (java.lang.String@w{ }@var{newText}) \n+\n+@end deftypemethod\n+@deftypemethod BreakIterator {public abstract void} setText (java.text.CharacterIterator@w{ }@var{newText}) \n+\n+@end deftypemethod\n+@deftypemethod CharacterIterator {public Object} clone () \n+\n+@end deftypemethod\n+@deftypemethod CharacterIterator {public char} current () \n+\n+@end deftypemethod\n+@deftypemethod CharacterIterator {public char} first () \n+\n+@end deftypemethod\n+@deftypemethod CharacterIterator {public int} getBeginIndex () \n+\n+@end deftypemethod\n+@deftypemethod CharacterIterator {public int} getEndIndex () \n+\n+@end deftypemethod\n+@deftypemethod CharacterIterator {public int} getIndex () \n+\n+@end deftypemethod\n+@deftypemethod CharacterIterator {public char} last () \n+\n+@end deftypemethod\n+@deftypemethod CharacterIterator {public char} next () \n+\n+@end deftypemethod\n+@deftypemethod CharacterIterator {public char} previous () \n+\n+@end deftypemethod\n+@deftypemethod CharacterIterator {public char} setIndex (int@w{ }@var{idx}) \n+\n+@end deftypemethod\n+@deftypemethod ChoiceFormat {public void} applyPattern (java.lang.String@w{ }@var{newPattern}) \n+\n+@end deftypemethod\n+@deftypemethod ChoiceFormat {public Object} clone () \n+\n+@end deftypemethod\n+@deftypemethod ChoiceFormat {public boolean} equals (java.lang.Object@w{ }@var{obj}) \n+\n+@end deftypemethod\n+@deftypemethod ChoiceFormat {public StringBuffer} format (long@w{ }@var{num}, java.lang.StringBuffer@w{ }@var{appendBuf}, java.text.FieldPosition@w{ }@var{pos}) \n+\n+@end deftypemethod\n+@deftypemethod ChoiceFormat {public StringBuffer} format (double@w{ }@var{num}, java.lang.StringBuffer@w{ }@var{appendBuf}, java.text.FieldPosition@w{ }@var{pos}) \n+\n+@end deftypemethod\n+@deftypemethod ChoiceFormat {public Object} getFormats () \n+\n+@end deftypemethod\n+@deftypemethod ChoiceFormat {public double} getLimits () \n+\n+@end deftypemethod\n+@deftypemethod ChoiceFormat {public int} hashCode () \n+\n+@end deftypemethod\n+@deftypemethod ChoiceFormat {public static final double} nextDouble (double@w{ }@var{d}) \n+\n+@end deftypemethod\n+@deftypemethod ChoiceFormat {public static double} nextDouble (double@w{ }@var{d}, boolean@w{ }@var{next}) \n+\n+@end deftypemethod\n+@deftypemethod ChoiceFormat {public Number} parse (java.lang.String@w{ }@var{sourceStr}, java.text.ParsePosition@w{ }@var{pos}) \n+\n+@end deftypemethod\n+@deftypemethod ChoiceFormat {public static final double} previousDouble (double@w{ }@var{d}) \n+\n+@end deftypemethod\n+@deftypemethod ChoiceFormat {public void} setChoices (double[]@w{ }@var{choiceLimits}, java.lang.String[]@w{ }@var{choiceFormats}) \n+\n+@end deftypemethod\n+@deftypemethod ChoiceFormat {public String} toPattern () \n+\n+@end deftypemethod\n+@deftypemethod CollationElementIterator {public int} next () \n+\n+@end deftypemethod\n+@deftypemethod CollationElementIterator {public static final int} primaryOrder (int@w{ }@var{order}) \n+\n+@end deftypemethod\n+@deftypemethod CollationElementIterator {public void} reset () \n+\n+@end deftypemethod\n+@deftypemethod CollationElementIterator {public static final short} secondaryOrder (int@w{ }@var{order}) \n+\n+@end deftypemethod\n+@deftypemethod CollationElementIterator {public static final short} tertiaryOrder (int@w{ }@var{order}) \n+\n+@end deftypemethod\n+@deftypemethod CollationKey {public int} compareTo (java.text.CollationKey@w{ }@var{target}) \n+\n+@end deftypemethod\n+@deftypemethod CollationKey {public int} compareTo (java.lang.Object@w{ }@var{o}) \n+\n+@end deftypemethod\n+@deftypemethod CollationKey {public boolean} equals (java.lang.Object@w{ }@var{obj}) \n+\n+@end deftypemethod\n+@deftypemethod CollationKey {public String} getSourceString () \n+\n+@end deftypemethod\n+@deftypemethod CollationKey {public int} hashCode () \n+\n+@end deftypemethod\n+@deftypemethod CollationKey {public byte} toByteArray () \n+\n+@end deftypemethod\n+@deftypemethod Collator {public abstract int} compare (java.lang.String@w{ }@var{source}, java.lang.String@w{ }@var{target}) \n+\n+@end deftypemethod\n+@deftypemethod Collator {public int} compare (java.lang.Object@w{ }@var{o1}, java.lang.Object@w{ }@var{o2}) \n+\n+@end deftypemethod\n+@deftypemethod Collator {public boolean} equals (java.lang.Object@w{ }@var{obj}) \n+\n+@end deftypemethod\n+@deftypemethod Collator {public boolean} equals (java.lang.String@w{ }@var{source}, java.lang.String@w{ }@var{target}) \n+\n+@end deftypemethod\n+@deftypemethod Collator {public Object} clone () \n+\n+@end deftypemethod\n+@deftypemethod Collator {public static synchronized Locale} getAvailableLocales () \n+\n+@end deftypemethod\n+@deftypemethod Collator {public abstract CollationKey} getCollationKey (java.lang.String@w{ }@var{source}) \n+\n+@end deftypemethod\n+@deftypemethod Collator {public synchronized int} getDecomposition () \n+\n+@end deftypemethod\n+@deftypemethod Collator {public static Collator} getInstance () \n+\n+@end deftypemethod\n+@deftypemethod Collator {public static Collator} getInstance (java.util.Locale@w{ }@var{loc}) \n+\n+@end deftypemethod\n+@deftypemethod Collator {public synchronized int} getStrength () \n+\n+@end deftypemethod\n+@deftypemethod Collator {public abstract int} hashCode () \n+\n+@end deftypemethod\n+@deftypemethod Collator {public synchronized void} setDecomposition (int@w{ }@var{mode}) \n+\n+@end deftypemethod\n+@deftypemethod Collator {public synchronized void} setStrength (int@w{ }@var{strength}) \n+\n+@end deftypemethod\n+@deftypemethod DateFormat {public boolean} equals (java.lang.Object@w{ }@var{obj}) \n+\n+@end deftypemethod\n+@deftypemethod DateFormat {public Object} clone () \n+\n+@end deftypemethod\n+@deftypemethod DateFormat {public final StringBuffer} format (java.lang.Object@w{ }@var{obj}, java.lang.StringBuffer@w{ }@var{buf}, java.text.FieldPosition@w{ }@var{pos}) \n+\n+@end deftypemethod\n+@deftypemethod DateFormat {public final String} format (java.util.Date@w{ }@var{date}) \n+\n+@end deftypemethod\n+@deftypemethod DateFormat {public abstract StringBuffer} format (java.util.Date@w{ }@var{date}, java.lang.StringBuffer@w{ }@var{buf}, java.text.FieldPosition@w{ }@var{pos}) \n+\n+@end deftypemethod\n+@deftypemethod DateFormat {public static Locale} getAvailableLocales () \n+\n+@end deftypemethod\n+@deftypemethod DateFormat {public Calendar} getCalendar () \n+\n+@end deftypemethod\n+@deftypemethod DateFormat {public static final DateFormat} getDateInstance () \n+\n+@end deftypemethod\n+@deftypemethod DateFormat {public static final DateFormat} getDateInstance (int@w{ }@var{style}) \n+\n+@end deftypemethod\n+@deftypemethod DateFormat {public static final DateFormat} getDateInstance (int@w{ }@var{style}, java.util.Locale@w{ }@var{loc}) \n+\n+@end deftypemethod\n+@deftypemethod DateFormat {public static final DateFormat} getDateTimeInstance () \n+\n+@end deftypemethod\n+@deftypemethod DateFormat {public static final DateFormat} getDateTimeInstance (int@w{ }@var{dateStyle}, int@w{ }@var{timeStyle}) \n+\n+@end deftypemethod\n+@deftypemethod DateFormat {public static final DateFormat} getDateTimeInstance (int@w{ }@var{dateStyle}, int@w{ }@var{timeStyle}, java.util.Locale@w{ }@var{loc}) \n+\n+@end deftypemethod\n+@deftypemethod DateFormat {public static final DateFormat} getInstance () \n+\n+@end deftypemethod\n+@deftypemethod DateFormat {public NumberFormat} getNumberFormat () \n+\n+@end deftypemethod\n+@deftypemethod DateFormat {public static final DateFormat} getTimeInstance () \n+\n+@end deftypemethod\n+@deftypemethod DateFormat {public static final DateFormat} getTimeInstance (int@w{ }@var{style}) \n+\n+@end deftypemethod\n+@deftypemethod DateFormat {public static final DateFormat} getTimeInstance (int@w{ }@var{style}, java.util.Locale@w{ }@var{loc}) \n+\n+@end deftypemethod\n+@deftypemethod DateFormat {public TimeZone} getTimeZone () \n+\n+@end deftypemethod\n+@deftypemethod DateFormat {public int} hashCode () \n+\n+@end deftypemethod\n+@deftypemethod DateFormat {public boolean} isLenient () \n+\n+@end deftypemethod\n+@deftypemethod DateFormat {public Date} parse (java.lang.String@w{ }@var{source}) @*throws ParseException\n+\n+@end deftypemethod\n+@deftypemethod DateFormat {public abstract Date} parse (java.lang.String@w{ }@var{source}, java.text.ParsePosition@w{ }@var{pos}) \n+\n+@end deftypemethod\n+@deftypemethod DateFormat {public Object} parseObject (java.lang.String@w{ }@var{source}, java.text.ParsePosition@w{ }@var{pos}) \n+\n+@end deftypemethod\n+@deftypemethod DateFormat {public void} setCalendar (java.util.Calendar@w{ }@var{calendar}) \n+\n+@end deftypemethod\n+@deftypemethod DateFormat {public void} setLenient (boolean@w{ }@var{lenient}) \n+\n+@end deftypemethod\n+@deftypemethod DateFormat {public void} setNumberFormat (java.text.NumberFormat@w{ }@var{numberFormat}) \n+\n+@end deftypemethod\n+@deftypemethod DateFormat {public void} setTimeZone (java.util.TimeZone@w{ }@var{timeZone}) \n+\n+@end deftypemethod\n+@deftypemethod DateFormatSymbols {public String} getAmPmStrings () \n+\n+@end deftypemethod\n+@deftypemethod DateFormatSymbols {public String} getEras () \n+\n+@end deftypemethod\n+@deftypemethod DateFormatSymbols {public String} getLocalPatternChars () \n+\n+@end deftypemethod\n+@deftypemethod DateFormatSymbols {public String} getMonths () \n+\n+@end deftypemethod\n+@deftypemethod DateFormatSymbols {public String} getShortMonths () \n+\n+@end deftypemethod\n+@deftypemethod DateFormatSymbols {public String} getShortWeekdays () \n+\n+@end deftypemethod\n+@deftypemethod DateFormatSymbols {public String} getWeekdays () \n+\n+@end deftypemethod\n+@deftypemethod DateFormatSymbols {public String} getZoneStrings () \n+\n+@end deftypemethod\n+@deftypemethod DateFormatSymbols {public void} setAmPmStrings (java.lang.String[]@w{ }@var{value}) \n+\n+@end deftypemethod\n+@deftypemethod DateFormatSymbols {public void} setEras (java.lang.String[]@w{ }@var{value}) \n+\n+@end deftypemethod\n+@deftypemethod DateFormatSymbols {public void} setLocalPatternChars (java.lang.String@w{ }@var{value}) \n+\n+@end deftypemethod\n+@deftypemethod DateFormatSymbols {public void} setMonths (java.lang.String[]@w{ }@var{value}) \n+\n+@end deftypemethod\n+@deftypemethod DateFormatSymbols {public void} setShortMonths (java.lang.String[]@w{ }@var{value}) \n+\n+@end deftypemethod\n+@deftypemethod DateFormatSymbols {public void} setShortWeekdays (java.lang.String[]@w{ }@var{value}) \n+\n+@end deftypemethod\n+@deftypemethod DateFormatSymbols {public void} setWeekdays (java.lang.String[]@w{ }@var{value}) \n+\n+@end deftypemethod\n+@deftypemethod DateFormatSymbols {public void} setZoneStrings (java.lang.String[][]@w{ }@var{value}) \n+\n+@end deftypemethod\n+@deftypemethod DateFormatSymbols {public boolean} equals (java.lang.Object@w{ }@var{obj}) \n+\n+@end deftypemethod\n+@deftypemethod DateFormatSymbols {public Object} clone () \n+\n+@end deftypemethod\n+@deftypemethod DateFormatSymbols {public int} hashCode () \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormat {public void} applyLocalizedPattern (java.lang.String@w{ }@var{pattern}) \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormat {public void} applyPattern (java.lang.String@w{ }@var{pattern}) \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormat {public Object} clone () \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormat {public boolean} equals (java.lang.Object@w{ }@var{obj}) \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormat {public StringBuffer} format (double@w{ }@var{number}, java.lang.StringBuffer@w{ }@var{dest}, java.text.FieldPosition@w{ }@var{fieldPos}) \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormat {public StringBuffer} format (long@w{ }@var{number}, java.lang.StringBuffer@w{ }@var{dest}, java.text.FieldPosition@w{ }@var{fieldPos}) \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormat {public DecimalFormatSymbols} getDecimalFormatSymbols () \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormat {public int} getGroupingSize () \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormat {public int} getMultiplier () \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormat {public String} getNegativePrefix () \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormat {public String} getNegativeSuffix () \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormat {public String} getPositivePrefix () \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormat {public String} getPositiveSuffix () \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormat {public int} hashCode () \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormat {public boolean} isDecimalSeparatorAlwaysShown () \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormat {public Number} parse (java.lang.String@w{ }@var{str}, java.text.ParsePosition@w{ }@var{pos}) \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormat {public void} setDecimalFormatSymbols (java.text.DecimalFormatSymbols@w{ }@var{newSymbols}) \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormat {public void} setDecimalSeparatorAlwaysShown (boolean@w{ }@var{newValue}) \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormat {public void} setGroupingSize (int@w{ }@var{groupSize}) \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormat {public void} setMaximumFractionDigits (int@w{ }@var{newValue}) \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormat {public void} setMaximumIntegerDigits (int@w{ }@var{newValue}) \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormat {public void} setMinimumFractionDigits (int@w{ }@var{newValue}) \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormat {public void} setMinimumIntegerDigits (int@w{ }@var{newValue}) \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormat {public void} setMultiplier (int@w{ }@var{newValue}) \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormat {public void} setNegativePrefix (java.lang.String@w{ }@var{newValue}) \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormat {public void} setNegativeSuffix (java.lang.String@w{ }@var{newValue}) \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormat {public void} setPositivePrefix (java.lang.String@w{ }@var{newValue}) \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormat {public void} setPositiveSuffix (java.lang.String@w{ }@var{newValue}) \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormat {public String} toLocalizedPattern () \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormat {public String} toPattern () \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormatSymbols {public Object} clone () \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormatSymbols {public boolean} equals (java.lang.Object@w{ }@var{obj}) \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormatSymbols {public String} getCurrencySymbol () \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormatSymbols {public char} getDecimalSeparator () \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormatSymbols {public char} getDigit () \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormatSymbols {public char} getGroupingSeparator () \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormatSymbols {public String} getInfinity () \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormatSymbols {public String} getInternationalCurrencySymbol () \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormatSymbols {public char} getMinusSign () \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormatSymbols {public char} getMonetaryDecimalSeparator () \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormatSymbols {public String} getNaN () \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormatSymbols {public char} getPatternSeparator () \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormatSymbols {public char} getPercent () \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormatSymbols {public char} getPerMill () \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormatSymbols {public char} getZeroDigit () \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormatSymbols {public int} hashCode () \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormatSymbols {public void} setCurrencySymbol (java.lang.String@w{ }@var{currency}) \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormatSymbols {public void} setDecimalSeparator (char@w{ }@var{decimalSep}) \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormatSymbols {public void} setDigit (char@w{ }@var{digit}) \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormatSymbols {public void} setGroupingSeparator (char@w{ }@var{groupSep}) \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormatSymbols {public void} setInfinity (java.lang.String@w{ }@var{infinity}) \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormatSymbols {public void} setInternationalCurrencySymbol (java.lang.String@w{ }@var{currency}) \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormatSymbols {public void} setMinusSign (char@w{ }@var{minusSign}) \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormatSymbols {public void} setMonetaryDecimalSeparator (char@w{ }@var{decimalSep}) \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormatSymbols {public void} setNaN (java.lang.String@w{ }@var{nan}) \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormatSymbols {public void} setPatternSeparator (char@w{ }@var{patternSep}) \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormatSymbols {public void} setPercent (char@w{ }@var{percent}) \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormatSymbols {public void} setPerMill (char@w{ }@var{perMill}) \n+\n+@end deftypemethod\n+@deftypemethod DecimalFormatSymbols {public void} setZeroDigit (char@w{ }@var{zeroDigit}) \n+\n+@end deftypemethod\n+@deftypemethod FieldPosition {public int} getField () \n+\n+@end deftypemethod\n+@deftypemethod FieldPosition {public int} getBeginIndex () \n+\n+@end deftypemethod\n+@deftypemethod FieldPosition {public int} getEndIndex () \n+\n+@end deftypemethod\n+@deftypemethod FieldPosition {public void} setBeginIndex (int@w{ }@var{index}) \n+\n+@end deftypemethod\n+@deftypemethod FieldPosition {public void} setEndIndex (int@w{ }@var{index}) \n+\n+@end deftypemethod\n+@deftypemethod FieldPosition {public boolean} equals (java.lang.Object@w{ }@var{obj}) \n+\n+@end deftypemethod\n+@deftypemethod Format {public abstract StringBuffer} format (java.lang.Object@w{ }@var{obj}, java.lang.StringBuffer@w{ }@var{sbuf}, java.text.FieldPosition@w{ }@var{pos}) \n+\n+@end deftypemethod\n+@deftypemethod Format {public final String} format (java.lang.Object@w{ }@var{obj}) \n+\n+@end deftypemethod\n+@deftypemethod Format {public abstract Object} parseObject (java.lang.String@w{ }@var{source}, java.text.ParsePosition@w{ }@var{pos}) \n+\n+@end deftypemethod\n+@deftypemethod Format {public Object} parseObject (java.lang.String@w{ }@var{source}) @*throws ParseException\n+\n+@end deftypemethod\n+@deftypemethod Format {public Object} clone () \n+\n+@end deftypemethod\n+@deftypemethod MessageFormat {public void} applyPattern (java.lang.String@w{ }@var{newPattern}) \n+\n+@end deftypemethod\n+@deftypemethod MessageFormat {public Object} clone () \n+\n+@end deftypemethod\n+@deftypemethod MessageFormat {public boolean} equals (java.lang.Object@w{ }@var{obj}) \n+\n+@end deftypemethod\n+@deftypemethod MessageFormat {public static String} format (java.lang.String@w{ }@var{pattern}, java.lang.Object[]@w{ }@var{arguments}) \n+\n+@end deftypemethod\n+@deftypemethod MessageFormat {public final StringBuffer} format (java.lang.Object[]@w{ }@var{arguments}, java.lang.StringBuffer@w{ }@var{appendBuf}, java.text.FieldPosition@w{ }@var{ignore}) \n+\n+@end deftypemethod\n+@deftypemethod MessageFormat {public final StringBuffer} format (java.lang.Object@w{ }@var{singleArg}, java.lang.StringBuffer@w{ }@var{appendBuf}, java.text.FieldPosition@w{ }@var{ignore}) \n+\n+@end deftypemethod\n+@deftypemethod MessageFormat {public Format} getFormats () \n+\n+@end deftypemethod\n+@deftypemethod MessageFormat {public Locale} getLocale () \n+\n+@end deftypemethod\n+@deftypemethod MessageFormat {public int} hashCode () \n+\n+@end deftypemethod\n+@deftypemethod MessageFormat {public Object} parse (java.lang.String@w{ }@var{sourceStr}, java.text.ParsePosition@w{ }@var{pos}) \n+\n+@end deftypemethod\n+@deftypemethod MessageFormat {public Object} parse (java.lang.String@w{ }@var{sourceStr}) @*throws ParseException\n+\n+@end deftypemethod\n+@deftypemethod MessageFormat {public Object} parseObject (java.lang.String@w{ }@var{sourceStr}, java.text.ParsePosition@w{ }@var{pos}) \n+\n+@end deftypemethod\n+@deftypemethod MessageFormat {public void} setFormat (int@w{ }@var{variableNum}, java.text.Format@w{ }@var{newFormat}) \n+\n+@end deftypemethod\n+@deftypemethod MessageFormat {public void} setFormats (java.text.Format[]@w{ }@var{newFormats}) \n+\n+@end deftypemethod\n+@deftypemethod MessageFormat {public void} setLocale (java.util.Locale@w{ }@var{loc}) \n+\n+@end deftypemethod\n+@deftypemethod MessageFormat {public String} toPattern () \n+\n+@end deftypemethod\n+@deftypemethod NumberFormat {public final String} format (long@w{ }@var{number}) \n+\n+@end deftypemethod\n+@deftypemethod NumberFormat {public final StringBuffer} format (java.lang.Object@w{ }@var{obj}, java.lang.StringBuffer@w{ }@var{sbuf}, java.text.FieldPosition@w{ }@var{pos}) \n+\n+@end deftypemethod\n+@deftypemethod NumberFormat {public abstract StringBuffer} format (double@w{ }@var{number}, java.lang.StringBuffer@w{ }@var{sbuf}, java.text.FieldPosition@w{ }@var{pos}) \n+\n+@end deftypemethod\n+@deftypemethod NumberFormat {public abstract StringBuffer} format (long@w{ }@var{number}, java.lang.StringBuffer@w{ }@var{sbuf}, java.text.FieldPosition@w{ }@var{pos}) \n+\n+@end deftypemethod\n+@deftypemethod NumberFormat {public Object} clone () \n+\n+@end deftypemethod\n+@deftypemethod NumberFormat {public boolean} equals (java.lang.Object@w{ }@var{obj}) \n+\n+@end deftypemethod\n+@deftypemethod NumberFormat {public static Locale} getAvailableLocales () \n+\n+@end deftypemethod\n+@deftypemethod NumberFormat {public static final NumberFormat} getCurrencyInstance () \n+\n+@end deftypemethod\n+@deftypemethod NumberFormat {public static NumberFormat} getCurrencyInstance (java.util.Locale@w{ }@var{loc}) \n+\n+@end deftypemethod\n+@deftypemethod NumberFormat {public static final NumberFormat} getInstance () \n+\n+@end deftypemethod\n+@deftypemethod NumberFormat {public static NumberFormat} getInstance (java.util.Locale@w{ }@var{loc}) \n+\n+@end deftypemethod\n+@deftypemethod NumberFormat {public int} getMaximumFractionDigits () \n+\n+@end deftypemethod\n+@deftypemethod NumberFormat {public int} getMaximumIntegerDigits () \n+\n+@end deftypemethod\n+@deftypemethod NumberFormat {public int} getMinimumFractionDigits () \n+\n+@end deftypemethod\n+@deftypemethod NumberFormat {public int} getMinimumIntegerDigits () \n+\n+@end deftypemethod\n+@deftypemethod NumberFormat {public static final NumberFormat} getNumberInstance () \n+\n+@end deftypemethod\n+@deftypemethod NumberFormat {public static NumberFormat} getNumberInstance (java.util.Locale@w{ }@var{loc}) \n+\n+@end deftypemethod\n+@deftypemethod NumberFormat {public static final NumberFormat} getPercentInstance () \n+\n+@end deftypemethod\n+@deftypemethod NumberFormat {public static NumberFormat} getPercentInstance (java.util.Locale@w{ }@var{loc}) \n+\n+@end deftypemethod\n+@deftypemethod NumberFormat {public int} hashCode () \n+\n+@end deftypemethod\n+@deftypemethod NumberFormat {public boolean} isGroupingUsed () \n+\n+@end deftypemethod\n+@deftypemethod NumberFormat {public boolean} isParseIntegerOnly () \n+\n+@end deftypemethod\n+@deftypemethod NumberFormat {public abstract Number} parse (java.lang.String@w{ }@var{sourceStr}, java.text.ParsePosition@w{ }@var{pos}) \n+\n+@end deftypemethod\n+@deftypemethod NumberFormat {public Number} parse (java.lang.String@w{ }@var{sourceStr}) @*throws ParseException\n+\n+@end deftypemethod\n+@deftypemethod NumberFormat {public final Object} parseObject (java.lang.String@w{ }@var{sourceStr}, java.text.ParsePosition@w{ }@var{pos}) \n+\n+@end deftypemethod\n+@deftypemethod NumberFormat {public void} setGroupingUsed (boolean@w{ }@var{newValue}) \n+\n+@end deftypemethod\n+@deftypemethod NumberFormat {public void} setMaximumFractionDigits (int@w{ }@var{newValue}) \n+\n+@end deftypemethod\n+@deftypemethod NumberFormat {public void} setMaximumIntegerDigits (int@w{ }@var{newValue}) \n+\n+@end deftypemethod\n+@deftypemethod NumberFormat {public void} setMinimumFractionDigits (int@w{ }@var{newValue}) \n+\n+@end deftypemethod\n+@deftypemethod NumberFormat {public void} setMinimumIntegerDigits (int@w{ }@var{newValue}) \n+\n+@end deftypemethod\n+@deftypemethod NumberFormat {public void} setParseIntegerOnly (boolean@w{ }@var{value}) \n+\n+@end deftypemethod\n+@deftypemethod NumberFormat {public final String} format (double@w{ }@var{number}) \n+\n+@end deftypemethod\n+@deftypemethod ParseException {public int} getErrorOffset () \n+\n+@end deftypemethod\n+@deftypemethod ParsePosition {public int} getIndex () \n+\n+@end deftypemethod\n+@deftypemethod ParsePosition {public void} setIndex (int@w{ }@var{index}) \n+\n+@end deftypemethod\n+@deftypemethod ParsePosition {public int} getErrorIndex () \n+\n+@end deftypemethod\n+@deftypemethod ParsePosition {public void} setErrorIndex (int@w{ }@var{ei}) \n+\n+@end deftypemethod\n+@deftypemethod ParsePosition {public boolean} equals (java.lang.Object@w{ }@var{obj}) \n+\n+@end deftypemethod\n+@deftypemethod RuleBasedCollator {public Object} clone () \n+\n+@end deftypemethod\n+@deftypemethod RuleBasedCollator {public int} compare (java.lang.String@w{ }@var{source}, java.lang.String@w{ }@var{target}) \n+\n+@end deftypemethod\n+@deftypemethod RuleBasedCollator {public boolean} equals (java.lang.Object@w{ }@var{obj}) \n+\n+@end deftypemethod\n+@deftypemethod RuleBasedCollator {public CollationElementIterator} getCollationElementIterator (java.lang.String@w{ }@var{source}) \n+\n+@end deftypemethod\n+@deftypemethod RuleBasedCollator {public CollationElementIterator} getCollationElementIterator (java.text.CharacterIterator@w{ }@var{source}) \n+\n+@end deftypemethod\n+@deftypemethod RuleBasedCollator {public CollationKey} getCollationKey (java.lang.String@w{ }@var{source}) \n+\n+@end deftypemethod\n+@deftypemethod RuleBasedCollator {public String} getRules () \n+\n+@end deftypemethod\n+@deftypemethod RuleBasedCollator {public int} hashCode () \n+\n+@end deftypemethod\n+@deftypemethod SimpleDateFormat {public String} toString () \n+\n+@end deftypemethod\n+@deftypemethod SimpleDateFormat {public String} toPattern () \n+This method returns a string with the formatting pattern being used\n+ by this object.  This string is unlocalized.\n+@end deftypemethod\n+@deftypemethod SimpleDateFormat {public String} toLocalizedPattern () \n+This method returns a string with the formatting pattern being used\n+ by this object.  This string is localized.\n+@end deftypemethod\n+@deftypemethod SimpleDateFormat {public void} applyPattern (java.lang.String@w{ }@var{pattern}) \n+This method sets the formatting pattern that should be used by this\n+ object.  This string is not localized.\n+@end deftypemethod\n+@deftypemethod SimpleDateFormat {public void} applyLocalizedPattern (java.lang.String@w{ }@var{pattern}) \n+This method sets the formatting pattern that should be used by this\n+ object.  This string is localized.\n+@end deftypemethod\n+@deftypemethod SimpleDateFormat {public Date} get2DigitYearStart () \n+Returns the start of the century used for two digit years.\n+@end deftypemethod\n+@deftypemethod SimpleDateFormat {public void} set2DigitYearStart (java.util.Date@w{ }@var{date}) \n+Sets the start of the century used for two digit years.\n+@end deftypemethod\n+@deftypemethod SimpleDateFormat {public DateFormatSymbols} getDateFormatSymbols () \n+This method returns the format symbol information used for parsing\n+ and formatting dates.\n+@end deftypemethod\n+@deftypemethod SimpleDateFormat {public void} setDateFormatSymbols (java.text.DateFormatSymbols@w{ }@var{formatData}) \n+This method sets the format symbols information used for parsing\n+ and formatting dates.\n+@end deftypemethod\n+@deftypemethod SimpleDateFormat {public boolean} equals (java.lang.Object@w{ }@var{o}) \n+This methods tests whether the specified object is equal to this\n+ object.  This will be true if and only if the specified object:\n+ \n+\n+\n+ \n+@itemize @bullet\n+\n+ \n+@item\n+Is not @code{null}.\n+ \n+@item\n+Is an instance of @code{SimpleDateFormat}.\n+ \n+@item\n+Is equal to this object at the superclass (i.e., @code{DateFormat})\n+     level.\n+ \n+@item\n+Has the same formatting pattern.\n+ \n+@item\n+Is using the same formatting symbols.\n+ \n+@item\n+Is using the same century for two digit years.\n+ \n+@end itemize\n+\n+@end deftypemethod\n+@deftypemethod SimpleDateFormat {public StringBuffer} format (java.util.Date@w{ }@var{date}, java.lang.StringBuffer@w{ }@var{buffer}, java.text.FieldPosition@w{ }@var{pos}) \n+Formats the date input according to the format string in use,\n+ appending to the specified StringBuffer.  The input StringBuffer\n+ is returned as output for convenience.\n+@end deftypemethod\n+@deftypemethod SimpleDateFormat {public Date} parse (java.lang.String@w{ }@var{dateStr}, java.text.ParsePosition@w{ }@var{pos}) \n+This method parses the specified string into a date.\n+@end deftypemethod\n+@deftypemethod StringCharacterIterator {public Object} clone () \n+\n+@end deftypemethod\n+@deftypemethod StringCharacterIterator {public char} current () \n+\n+@end deftypemethod\n+@deftypemethod StringCharacterIterator {public boolean} equals (java.lang.Object@w{ }@var{obj}) \n+\n+@end deftypemethod\n+@deftypemethod StringCharacterIterator {public char} first () \n+\n+@end deftypemethod\n+@deftypemethod StringCharacterIterator {public int} getBeginIndex () \n+\n+@end deftypemethod\n+@deftypemethod StringCharacterIterator {public int} getEndIndex () \n+\n+@end deftypemethod\n+@deftypemethod StringCharacterIterator {public int} getIndex () \n+\n+@end deftypemethod\n+@deftypemethod StringCharacterIterator {public int} hashCode () \n+\n+@end deftypemethod\n+@deftypemethod StringCharacterIterator {public char} last () \n+\n+@end deftypemethod\n+@deftypemethod StringCharacterIterator {public char} next () \n+\n+@end deftypemethod\n+@deftypemethod StringCharacterIterator {public char} previous () \n+\n+@end deftypemethod\n+@deftypemethod StringCharacterIterator {public char} setIndex (int@w{ }@var{idx}) \n+\n+@end deftypemethod\n+@deftypemethod StringCharacterIterator {public void} setText (java.lang.String@w{ }@var{text}) \n+\n+@end deftypemethod"}, {"sha": "7a36859f45c1ebc2aa3f17ecbc5cab5d8da75b60", "filename": "libjava/doc/java-util-jar.texi", "status": "added", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2Fdoc%2Fjava-util-jar.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2Fdoc%2Fjava-util-jar.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fdoc%2Fjava-util-jar.texi?ref=6a9d31a7d48bbae78a24a1395199d5c4c048d642", "patch": "@@ -0,0 +1,188 @@\n+@deftypemethod Attributes {public String} getValue (java.lang.String@w{ }@var{name}) \n+Gets the value of an attribute name given as a String.\n+@end deftypemethod\n+@deftypemethod Attributes {public String} getValue (java.util.jar.Attributes.Name@w{ }@var{name}) \n+Gets the value of the given attribute name.\n+@end deftypemethod\n+@deftypemethod Attributes {public String} putValue (java.lang.String@w{ }@var{name}, java.lang.String@w{ }@var{value}) \n+Stores an attribute name (represented by a String) and value in this\n+ Attributes map.\n+ When the (case insensitive string) name already exists the value is\n+ replaced and the old value is returned.\n+@end deftypemethod\n+@deftypemethod Attributes {public Object} clone () \n+Return a clone of this attribute map.\n+@end deftypemethod\n+@deftypemethod Attributes {public void} clear () \n+Removes all attributes.\n+@end deftypemethod\n+@deftypemethod Attributes {public boolean} containsKey (java.lang.Object@w{ }@var{attrName}) \n+Checks to see if there is an attribute with the specified name.\n+ XXX - what if the object is a String?\n+@end deftypemethod\n+@deftypemethod Attributes {public boolean} containsValue (java.lang.Object@w{ }@var{attrValue}) \n+Checks to see if there is an attribute name with the specified value.\n+@end deftypemethod\n+@deftypemethod Attributes {public Set} entrySet () \n+Gives a Set of attribute name and values pairs as MapEntries.\n+@end deftypemethod\n+@deftypemethod Attributes {public boolean} equals (java.lang.Object@w{ }@var{o}) \n+Checks to see if two Attributes are equal. The supplied object must be\n+ a real instance of Attributes and contain the same attribute name/value\n+ pairs.\n+@end deftypemethod\n+@deftypemethod Attributes {public Object} get (java.lang.Object@w{ }@var{attrName}) \n+Gets the value of a specified attribute name.\n+ XXX - what if the object is a String?\n+@end deftypemethod\n+@deftypemethod Attributes {public int} hashCode () \n+Returns the hashcode of the attribute name/value map.\n+@end deftypemethod\n+@deftypemethod Attributes {public boolean} isEmpty () \n+Returns true if there are no attributes set, false otherwise.\n+@end deftypemethod\n+@deftypemethod Attributes {public Set} keySet () \n+Gives a Set of all the values of defined attribute names.\n+@end deftypemethod\n+@deftypemethod Attributes {public Object} put (java.lang.Object@w{ }@var{name}, java.lang.Object@w{ }@var{value}) \n+Adds or replaces a attribute name/value pair.\n+ XXX - What if the name is a string? What if the name is neither a Name\n+ nor a String? What if the value is not a string?\n+@end deftypemethod\n+@deftypemethod Attributes {public void} putAll (java.util.Map@w{ }@var{attr}) \n+Adds or replaces all attribute name/value pairs from another\n+ Attributes object to this one. The supplied Map must be an instance of\n+ Attributes.\n+@end deftypemethod\n+@deftypemethod Attributes {public Object} remove (java.lang.Object@w{ }@var{name}) \n+Remove a attribute name/value pair.\n+ XXX - What if the name is a String?\n+@end deftypemethod\n+@deftypemethod Attributes {public int} size () \n+Returns the number of defined attribute name/value pairs.\n+@end deftypemethod\n+@deftypemethod Attributes {public Collection} values () \n+Returns all the values of the defined attribute name/value pairs as a\n+ Collection.\n+@end deftypemethod\n+@deftypemethod Attributes.Name {public int} hashCode () \n+Returns the hash code of the (lowercase) String representation of\n+ this Name.\n+@end deftypemethod\n+@deftypemethod Attributes.Name {public boolean} equals (java.lang.Object@w{ }@var{o}) \n+Checks if another object is equal to this Name object.\n+ Another object is equal to this Name object if it is an instance of\n+ Name and the (lowercase) string representation of the name is equal.\n+@end deftypemethod\n+@deftypemethod Attributes.Name {public String} toString () \n+Returns the string representation of this Name as given to the\n+ constructor (not neccesarily the lower case representation).\n+@end deftypemethod\n+@deftypemethod JarEntry {public Attributes} getAttributes () @*throws IOException\n+Returns a copy of the Attributes set for this entry.\n+ When no Attributes are set in the manifest null is returned.\n+@end deftypemethod\n+@deftypemethod JarEntry {public Certificate} getCertificates () \n+Returns a copy of the certificates set for this entry.\n+ When no certificates are set or when not all data of this entry has\n+ been read null is returned.\n+ \n+\n+\n+ To make sure that this call returns a valid value you must read all\n+ data from the JarInputStream for this entry.\n+ When you don't need the data for an entry but want to know the\n+ certificates that are set for the entry then you can skip all data by\n+ calling @code{skip(entry.getSize())} on the JarInputStream for\n+ the entry.\n+@end deftypemethod\n+@deftypemethod JarFile {public Enumeration} entries () @*throws IllegalStateException\n+Returns a enumeration of all the entries in the JarFile.\n+ Note that also the Jar META-INF entries are returned.\n+@end deftypemethod\n+@deftypemethod JarFile {public ZipEntry} getEntry (java.lang.String@w{ }@var{name}) \n+XXX\n+ It actually returns a JarEntry not a zipEntry\n+@end deftypemethod\n+@deftypemethod JarFile {public synchronized InputStream} getInputStream (java.util.zip.ZipEntry@w{ }@var{entry}) @*throws ZipException, IOException\n+XXX should verify the inputstream\n+@end deftypemethod\n+@deftypemethod JarFile {public JarEntry} getJarEntry (java.lang.String@w{ }@var{name}) \n+Returns the JarEntry that belongs to the name if such an entry\n+ exists in the JarFile. Returns null otherwise\n+ Convenience method that just casts the result from @code{getEntry}\n+ to a JarEntry.\n+@end deftypemethod\n+@deftypemethod JarFile {public Manifest} getManifest () \n+Returns the manifest for this JarFile or null when the JarFile does not\n+ contain a manifest file.\n+@end deftypemethod\n+@deftypemethod JarInputStream {protected ZipEntry} createZipEntry (java.lang.String@w{ }@var{name}) \n+Creates a JarEntry for a particular name and consults the manifest\n+ for the Attributes of the entry.\n+ Used by @code{ZipEntry.getNextEntry()}\n+@end deftypemethod\n+@deftypemethod JarInputStream {public Manifest} getManifest () \n+Returns the Manifest for the jar file or null if there was no Manifest.\n+@end deftypemethod\n+@deftypemethod JarInputStream {public ZipEntry} getNextEntry () @*throws IOException\n+Returns the next entry or null when there are no more entries.\n+ Does actually return a JarEntry, if you don't want to cast it yourself\n+ use @code{getNextJarEntry()}. Does not return any entries found\n+ at the beginning of the ZipFile that are special\n+ (those that start with \"META-INF/\").\n+@end deftypemethod\n+@deftypemethod JarInputStream {public JarEntry} getNextJarEntry () @*throws IOException\n+Returns the next jar entry or null when there are no more entries.\n+@end deftypemethod\n+@deftypemethod JarInputStream {public int} read (byte[]@w{ }@var{buf}, int@w{ }@var{off}, int@w{ }@var{len}) @*throws IOException\n+XXX\n+@end deftypemethod\n+@deftypemethod JarOutputStream {public void} putNextEntry (java.util.zip.ZipEntry@w{ }@var{entry}) @*throws IOException\n+Prepares the JarOutputStream for writing the next entry. \n+ This implementation just calls @code{super.putNextEntre()}.\n+@end deftypemethod\n+@deftypemethod Manifest {public Attributes} getMainAttributes () \n+Gets the main attributes of this Manifest.\n+@end deftypemethod\n+@deftypemethod Manifest {public Map} getEntries () \n+Gets a map of entry Strings to Attributes for all the entries described\n+ in this manifest. Adding, changing or removing from this entries map\n+ changes the entries of this manifest.\n+@end deftypemethod\n+@deftypemethod Manifest {public Attributes} getAttributes (java.lang.String@w{ }@var{entryName}) \n+Returns the Attributes associated with the Entry.\n+ \n+\n+\n+ Implemented as:\n+ @code{return (Attributes)getEntries().get(entryName)}\n+@end deftypemethod\n+@deftypemethod Manifest {public void} clear () \n+Clears the main attributes and removes all the entries from the\n+ manifest.\n+@end deftypemethod\n+@deftypemethod Manifest {public void} read (java.io.InputStream@w{ }@var{in}) @*throws IOException\n+XXX\n+@end deftypemethod\n+@deftypemethod Manifest {public void} write (java.io.OutputStream@w{ }@var{out}) @*throws IOException\n+XXX\n+@end deftypemethod\n+@deftypemethod Manifest {public Object} clone () \n+Makes a deep copy of the main attributes, but a shallow copy of\n+ the other entries. This means that you can freely add, change or remove\n+ the main attributes or the entries of the new manifest without effecting\n+ the original manifest, but adding, changing or removing attributes from\n+ a particular entry also changes the attributes of that entry in the\n+ original manifest. Calls @code{new Manifest(this)}.\n+@end deftypemethod\n+@deftypemethod Manifest {public boolean} equals (java.lang.Object@w{ }@var{o}) \n+Checks if another object is equal to this Manifest object.\n+ Another Object is equal to this Manifest object if it is an instance of\n+ Manifest and the main attributes and the entries of the other manifest\n+ are equal to this one.\n+@end deftypemethod\n+@deftypemethod Manifest {public int} hashCode () \n+Calculates the hash code of the manifest. Implemented by a xor of the\n+ hash code of the main attributes with the hash code of the entries map.\n+@end deftypemethod"}, {"sha": "d084b69a00bd87d87c0c63256c7f2ddf96e6a733", "filename": "libjava/doc/java-util-zip.texi", "status": "added", "additions": 352, "deletions": 0, "changes": 352, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2Fdoc%2Fjava-util-zip.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2Fdoc%2Fjava-util-zip.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fdoc%2Fjava-util-zip.texi?ref=6a9d31a7d48bbae78a24a1395199d5c4c048d642", "patch": "@@ -0,0 +1,352 @@\n+@deftypemethod Adler32 {public void} reset () \n+Resets the Adler32 data checksum as if no update was ever called.\n+@end deftypemethod\n+@deftypemethod Adler32 {public void} update (int@w{ }@var{bval}) \n+Adds one byte to the data checksum.\n+@end deftypemethod\n+@deftypemethod Adler32 {public void} update (byte[]@w{ }@var{buffer}) \n+Adds the complete byte array to the data checksum.\n+@end deftypemethod\n+@deftypemethod Adler32 {public void} update (byte[]@w{ }@var{buf}, int@w{ }@var{off}, int@w{ }@var{len}) \n+Adds the byte array to the data checksum.\n+@end deftypemethod\n+@deftypemethod Adler32 {public long} getValue () \n+Returns the Adler32 data checksum computed so far.\n+@end deftypemethod\n+@deftypemethod CheckedInputStream {public Checksum} getChecksum () \n+Returns the Checksum object used. To get the data checksum computed so\n+ far call @code{getChecksum.getValue()}.\n+@end deftypemethod\n+@deftypemethod CheckedInputStream {public int} read () @*throws IOException\n+Reads one byte, updates the checksum and returns the read byte\n+ (or -1 when the end of file was reached).\n+@end deftypemethod\n+@deftypemethod CheckedInputStream {public int} read (byte[]@w{ }@var{buf}, int@w{ }@var{off}, int@w{ }@var{len}) @*throws IOException\n+Reads at most len bytes in the supplied buffer and updates the checksum\n+ with it. Returns the number of bytes actually read or -1 when the end\n+ of file was reached.\n+@end deftypemethod\n+@deftypemethod CheckedInputStream {public long} skip (long@w{ }@var{n}) @*throws IOException\n+Skips n bytes by reading them in a temporary buffer and updating the\n+ the checksum with that buffer. Returns the actual number of bytes skiped\n+ which can be less then requested when the end of file is reached.\n+@end deftypemethod\n+@deftypemethod CheckedOutputStream {public Checksum} getChecksum () \n+Returns the Checksum object used. To get the data checksum computed so\n+ far call @code{getChecksum.getValue()}.\n+@end deftypemethod\n+@deftypemethod CheckedOutputStream {public void} write (int@w{ }@var{bval}) @*throws IOException\n+Writes one byte to the OutputStream and updates the Checksum.\n+@end deftypemethod\n+@deftypemethod CheckedOutputStream {public void} write (byte[]@w{ }@var{buf}, int@w{ }@var{off}, int@w{ }@var{len}) @*throws IOException\n+Writes the byte array to the OutputStream and updates the Checksum.\n+@end deftypemethod\n+@deftypemethod Checksum {public long} getValue () \n+Returns the data checksum computed so far.\n+@end deftypemethod\n+@deftypemethod Checksum {public void} reset () \n+Resets the data checksum as if no update was ever called.\n+@end deftypemethod\n+@deftypemethod Checksum {public void} update (int@w{ }@var{bval}) \n+Adds one byte to the data checksum.\n+@end deftypemethod\n+@deftypemethod Checksum {public void} update (byte[]@w{ }@var{buf}, int@w{ }@var{off}, int@w{ }@var{len}) \n+Adds the byte array to the data checksum.\n+@end deftypemethod\n+@deftypemethod CRC32 {public long} getValue () \n+Returns the CRC32 data checksum computed so far.\n+@end deftypemethod\n+@deftypemethod CRC32 {public void} reset () \n+Resets the CRC32 data checksum as if no update was ever called.\n+@end deftypemethod\n+@deftypemethod CRC32 {public void} update (int@w{ }@var{bval}) \n+\n+@end deftypemethod\n+@deftypemethod CRC32 {public void} update (byte[]@w{ }@var{buf}, int@w{ }@var{off}, int@w{ }@var{len}) \n+Adds the byte array to the data checksum.\n+@end deftypemethod\n+@deftypemethod CRC32 {public void} update (byte[]@w{ }@var{buf}) \n+Adds the complete byte array to the data checksum.\n+@end deftypemethod\n+@deftypemethod Deflater {public int} deflate (byte[]@w{ }@var{buf}) \n+\n+@end deftypemethod\n+@deftypemethod Deflater {public native int} deflate (byte[]@w{ }@var{buf}, int@w{ }@var{off}, int@w{ }@var{len}) \n+\n+@end deftypemethod\n+@deftypemethod Deflater {public native void} end () \n+\n+@end deftypemethod\n+@deftypemethod Deflater {protected void} finalize () \n+\n+@end deftypemethod\n+@deftypemethod Deflater {public native void} finish () \n+\n+@end deftypemethod\n+@deftypemethod Deflater {public synchronized boolean} finished () \n+\n+@end deftypemethod\n+@deftypemethod Deflater {public native int} getAdler () \n+\n+@end deftypemethod\n+@deftypemethod Deflater {public native int} getTotalIn () \n+\n+@end deftypemethod\n+@deftypemethod Deflater {public native int} getTotalOut () \n+\n+@end deftypemethod\n+@deftypemethod Deflater {public native boolean} needsInput () \n+\n+@end deftypemethod\n+@deftypemethod Deflater {public native void} reset () \n+\n+@end deftypemethod\n+@deftypemethod Deflater {public void} setDictionary (byte[]@w{ }@var{buf}) \n+\n+@end deftypemethod\n+@deftypemethod Deflater {public native void} setDictionary (byte[]@w{ }@var{buf}, int@w{ }@var{off}, int@w{ }@var{len}) \n+\n+@end deftypemethod\n+@deftypemethod Deflater {public void} setInput (byte[]@w{ }@var{buf}) \n+\n+@end deftypemethod\n+@deftypemethod Deflater {public native void} setInput (byte[]@w{ }@var{buf}, int@w{ }@var{off}, int@w{ }@var{len}) \n+\n+@end deftypemethod\n+@deftypemethod Deflater {public synchronized void} setLevel (int@w{ }@var{lvl}) \n+\n+@end deftypemethod\n+@deftypemethod Deflater {public synchronized void} setStrategy (int@w{ }@var{stgy}) \n+\n+@end deftypemethod\n+@deftypemethod DeflaterOutputStream {public void} close () @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod DeflaterOutputStream {protected void} deflate () @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod DeflaterOutputStream {public void} finish () @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod DeflaterOutputStream {public void} write (int@w{ }@var{bval}) @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod DeflaterOutputStream {public void} write (byte[]@w{ }@var{buf}, int@w{ }@var{off}, int@w{ }@var{len}) @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod GZIPInputStream {public void} close () @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod GZIPInputStream {public int} read (byte[]@w{ }@var{buf}, int@w{ }@var{off}, int@w{ }@var{len}) @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod GZIPOutputStream {public void} close () @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod GZIPOutputStream {public void} finish () @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod GZIPOutputStream {public synchronized void} write (byte[]@w{ }@var{buf}) @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod GZIPOutputStream {public synchronized void} write (byte[]@w{ }@var{buf}, int@w{ }@var{off}, int@w{ }@var{len}) @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod InflaterInputStream {protected void} fill () @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod InflaterInputStream {public int} read () @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod InflaterInputStream {public int} read (byte[]@w{ }@var{buf}, int@w{ }@var{off}, int@w{ }@var{len}) @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod InflaterInputStream {public void} close () @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod InflaterInputStream {public int} available () @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod InflaterInputStream {public long} skip (long@w{ }@var{n}) @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod Inflater {public native void} end () \n+\n+@end deftypemethod\n+@deftypemethod Inflater {protected void} finalize () \n+\n+@end deftypemethod\n+@deftypemethod Inflater {public synchronized boolean} finished () \n+\n+@end deftypemethod\n+@deftypemethod Inflater {public native int} getAdler () \n+\n+@end deftypemethod\n+@deftypemethod Inflater {public native int} getRemaining () \n+\n+@end deftypemethod\n+@deftypemethod Inflater {public native int} getTotalIn () \n+\n+@end deftypemethod\n+@deftypemethod Inflater {public native int} getTotalOut () \n+\n+@end deftypemethod\n+@deftypemethod Inflater {public int} inflate (byte[]@w{ }@var{buf}) @*throws DataFormatException\n+\n+@end deftypemethod\n+@deftypemethod Inflater {public native int} inflate (byte[]@w{ }@var{buf}, int@w{ }@var{off}, int@w{ }@var{len}) @*throws DataFormatException\n+\n+@end deftypemethod\n+@deftypemethod Inflater {public synchronized boolean} needsDictionary () \n+\n+@end deftypemethod\n+@deftypemethod Inflater {public synchronized boolean} needsInput () \n+\n+@end deftypemethod\n+@deftypemethod Inflater {public native void} reset () \n+\n+@end deftypemethod\n+@deftypemethod Inflater {public void} setDictionary (byte[]@w{ }@var{buf}) \n+\n+@end deftypemethod\n+@deftypemethod Inflater {public native void} setDictionary (byte[]@w{ }@var{buf}, int@w{ }@var{off}, int@w{ }@var{len}) \n+\n+@end deftypemethod\n+@deftypemethod Inflater {public void} setInput (byte[]@w{ }@var{buf}) \n+\n+@end deftypemethod\n+@deftypemethod Inflater {public native void} setInput (byte[]@w{ }@var{buf}, int@w{ }@var{off}, int@w{ }@var{len}) \n+\n+@end deftypemethod\n+@deftypemethod ZipEntry {public Object} clone () \n+Creates a clone of this ZipEntry. Calls @code{new ZipEntry (this)}\n+ and creates a clone of the contents of the extra byte array field.\n+@end deftypemethod\n+@deftypemethod ZipEntry {public String} getComment () \n+\n+@end deftypemethod\n+@deftypemethod ZipEntry {public long} getCompressedSize () \n+\n+@end deftypemethod\n+@deftypemethod ZipEntry {public long} getCrc () \n+\n+@end deftypemethod\n+@deftypemethod ZipEntry {public byte} getExtra () \n+\n+@end deftypemethod\n+@deftypemethod ZipEntry {public int} getMethod () \n+\n+@end deftypemethod\n+@deftypemethod ZipEntry {public String} getName () \n+\n+@end deftypemethod\n+@deftypemethod ZipEntry {public long} getSize () \n+\n+@end deftypemethod\n+@deftypemethod ZipEntry {public long} getTime () \n+\n+@end deftypemethod\n+@deftypemethod ZipEntry {public boolean} isDirectory () \n+\n+@end deftypemethod\n+@deftypemethod ZipEntry {public void} setComment (java.lang.String@w{ }@var{comment}) \n+\n+@end deftypemethod\n+@deftypemethod ZipEntry {public void} setCompressedSize (long@w{ }@var{compressedSize}) \n+Sets the compressedSize of this ZipEntry.\n+ The new size must be between 0 and 0xffffffffL.\n+@end deftypemethod\n+@deftypemethod ZipEntry {public void} setCrc (long@w{ }@var{crc}) \n+\n+@end deftypemethod\n+@deftypemethod ZipEntry {public void} setExtra (byte[]@w{ }@var{extra}) \n+\n+@end deftypemethod\n+@deftypemethod ZipEntry {public void} setMethod (int@w{ }@var{method}) \n+\n+@end deftypemethod\n+@deftypemethod ZipEntry {public void} setSize (long@w{ }@var{size}) \n+\n+@end deftypemethod\n+@deftypemethod ZipEntry {public void} setTime (long@w{ }@var{time}) \n+\n+@end deftypemethod\n+@deftypemethod ZipEntry {public String} toString () \n+\n+@end deftypemethod\n+@deftypemethod ZipEntry {public int} hashCode () \n+Returns the hashcode of the name of this ZipEntry.\n+@end deftypemethod\n+@deftypemethod ZipFile {public Enumeration} entries () \n+\n+@end deftypemethod\n+@deftypemethod ZipFile {public void} close () @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod ZipFile {public ZipEntry} getEntry (java.lang.String@w{ }@var{name}) \n+\n+@end deftypemethod\n+@deftypemethod ZipFile {public InputStream} getInputStream (java.util.zip.ZipEntry@w{ }@var{ze}) @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod ZipFile {public String} getName () \n+\n+@end deftypemethod\n+@deftypemethod ZipFile {public int} size () \n+Returns the number of entries in this ZipFile.\n+@end deftypemethod\n+@deftypemethod ZipFile {protected void} finalize () @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod ZipInputStream {public ZipEntry} getNextEntry () @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod ZipInputStream {protected void} fill () @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod ZipInputStream {protected ZipEntry} createZipEntry (java.lang.String@w{ }@var{name}) \n+Creates a new ZipEntry with the given name.\n+ Used by ZipInputStream when normally @code{new ZipEntry (name)}\n+ would be called. This gives subclasses such as JarInputStream a change\n+ to override this method and add aditional information to the ZipEntry\n+ (subclass).\n+@end deftypemethod\n+@deftypemethod ZipInputStream {public int} read (byte[]@w{ }@var{b}, int@w{ }@var{off}, int@w{ }@var{len}) @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod ZipInputStream {public long} skip (long@w{ }@var{n}) @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod ZipInputStream {public int} available () \n+Returns 0 if the ZipInputStream is closed and 1 otherwise.\n+@end deftypemethod\n+@deftypemethod ZipInputStream {public void} closeEntry () @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod ZipInputStream {public void} close () @*throws IOException\n+Closes this InflaterInputStream.\n+@end deftypemethod\n+@deftypemethod ZipOutputStream {public void} close () @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod ZipOutputStream {public void} closeEntry () @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod ZipOutputStream {public void} finish () @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod ZipOutputStream {public void} putNextEntry (java.util.zip.ZipEntry@w{ }@var{entry}) @*throws IOException\n+\n+@end deftypemethod\n+@deftypemethod ZipOutputStream {public void} setLevel (int@w{ }@var{level}) \n+\n+@end deftypemethod\n+@deftypemethod ZipOutputStream {public void} setMethod (int@w{ }@var{method}) \n+\n+@end deftypemethod\n+@deftypemethod ZipOutputStream {public void} setComment (java.lang.String@w{ }@var{comment}) \n+\n+@end deftypemethod\n+@deftypemethod ZipOutputStream {public synchronized void} write (byte[]@w{ }@var{buf}, int@w{ }@var{off}, int@w{ }@var{len}) @*throws IOException\n+\n+@end deftypemethod"}, {"sha": "c2c18a4eefa7e2ccfc5bdc9b0f73f192507a16da", "filename": "libjava/doc/java-util.texi", "status": "added", "additions": 2425, "deletions": 0, "changes": 2425, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2Fdoc%2Fjava-util.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2Fdoc%2Fjava-util.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fdoc%2Fjava-util.texi?ref=6a9d31a7d48bbae78a24a1395199d5c4c048d642"}, {"sha": "aadc21786f342b9bc3fc7c55ed621ba5adb9982e", "filename": "libjava/scripts/TexinfoDoclet.java", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2Fscripts%2FTexinfoDoclet.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a9d31a7d48bbae78a24a1395199d5c4c048d642/libjava%2Fscripts%2FTexinfoDoclet.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fscripts%2FTexinfoDoclet.java?ref=6a9d31a7d48bbae78a24a1395199d5c4c048d642", "patch": "@@ -0,0 +1,140 @@\n+/* Copyright (C) 2001  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+import java.io.*;\n+import com.sun.javadoc.*;\n+\n+public class TexinfoDoclet\n+{\n+  static PrintStream outfile;\n+  \n+  public static int optionLength(String option) \n+  {\n+    if (option.equals(\"-outfile\")) \n+      return 2;\n+    return 0;\n+  }\n+\n+  private static String replace (String s, String text, String replacement)\n+  {\n+    int i = s.indexOf (text);\n+    while (i != -1)\n+      {\n+\ts = s.substring(0, i) + replacement + s.substring(i+text.length());\n+\ti = s.indexOf (text);\n+      }\n+    \n+    return s;\n+  }\n+  \n+  private static String texify (String s)\n+  {\n+    if (s.indexOf('<') == -1)\n+      return s;\n+    \n+    s = replace (s, \"<code>\", \"@code{\");\n+    s = replace (s, \"</code>\", \"}\");\n+    s = replace (s, \"<ol>\", \"\\n@itemize @bullet\\n\");\n+    s = replace (s, \"</ol>\", \"\\n@end itemize\\n\");\n+    s = replace (s, \"<ul>\", \"\\n@itemize @bullet\\n\");\n+    s = replace (s, \"</ul>\", \"\\n@end itemize\\n\");\n+    s = replace (s, \"<li>\", \"\\n@item\\n\");\n+    s = replace (s, \"</li>\", \"\\n\");\n+    s = replace (s, \"<p>\", \"\\n\\n\");\n+    \n+    s = replace (s, \"<CODE>\", \"@code{\");\n+    s = replace (s, \"</CODE>\", \"}\");\n+    s = replace (s, \"<OL>\", \"\\n@itemize @bullet\\n\");\n+    s = replace (s, \"</OL>\", \"\\n@end itemize\\n\");\n+    s = replace (s, \"<UL>\", \"\\n@itemize @bullet\\n\");\n+    s = replace (s, \"</UL>\", \"\\n@end itemize\\n\");\n+    s = replace (s, \"<LI>\", \"\\n@item\\n\");\n+    s = replace (s, \"</LI>\", \"\\n\");\n+    s = replace (s, \"<P>\", \"\\n\\n\");\n+    \n+    return s;\n+  }\n+  \n+  private static void emitMethod (ClassDoc c, MethodDoc m)\n+  {\n+    outfile.print (\"@deftypemethod \" + c.typeName()\n+\t\t   + \" {\" + m.modifiers()\n+\t\t   + \" \" + m.returnType().typeName()\n+\t\t   + \"} \" + m.name());\n+    \n+    outfile.print (\" (\");\n+    Parameter p[] = m.parameters();\n+    boolean first = true;\n+    \n+    for (int i = 0; i < p.length; i++)\n+      {\n+\tif (!first)\n+\t  outfile.print (\", \");\n+\toutfile.print (p[i].typeName() \n+\t\t       + \"@w{ }@var{\"\n+\t\t       + p[i].name()\n+\t\t       + \"}\");\n+\tfirst = false;\n+      }\n+    outfile.print (\") \");\n+    \n+    ClassDoc exceptions[] = m.thrownExceptions();\n+    if (exceptions.length > 0)\n+      {\n+\toutfile.print (\"@*throws \");\n+\tfirst = true;\n+\tfor (int i = 0; i < exceptions.length; i++)\n+\t  {\n+\t    if (!first)\n+\t      outfile.print (\", \");\n+\t    outfile.print (exceptions[i].typeName());\n+\t    first = false;\n+\t  }\n+      }\n+    outfile.println (\"\");\n+    \n+    outfile.println (texify (m.commentText()));\n+    \n+    outfile.println (\"@end deftypemethod\");\n+  }\n+  \n+  private static void emitClass (ClassDoc c)\n+  {\n+    MethodDoc[] methods = c.methods();\n+    for (int i = 0; i < methods.length; i++)\n+      {\n+\temitMethod (c, methods[i]);\n+      }\n+  }\n+  \n+  public static boolean start (RootDoc root)\n+  {\n+    String options[][] = root.options ();\n+    \n+    for (int i = 0; i < options.length; i++)\n+      {\n+\ttry \n+\t  {\n+\t    if (options[i][0].equals (\"-outfile\"))\n+\t      {\n+\t\toutfile = new PrintStream (new FileOutputStream (options[i][1]));\n+\t      }\n+\t  } catch (java.io.IOException e) {\n+\t    System.err.println (\"Can't write to file \" + options[i][1]);\n+\t    return false;\n+\t  }\n+      }\n+    \n+    ClassDoc[] classes = root.classes();\n+    for (int i = 0; i < classes.length; i++)\n+      {\n+\temitClass (classes[i]);\n+      }\n+    return true;\n+  }\n+}"}]}