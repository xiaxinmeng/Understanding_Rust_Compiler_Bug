{"sha": "62a4a967a9ec706432d076cd352b64ca07b8445d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjJhNGE5NjdhOWVjNzA2NDMyZDA3NmNkMzUyYjY0Y2EwN2I4NDQ1ZA==", "commit": {"author": {"name": "Laurynas Biveinis", "email": "laurynas.biveinis@gmail.com", "date": "2007-09-07T02:58:06Z"}, "committer": {"name": "Laurynas Biveinis", "email": "lauras@gcc.gnu.org", "date": "2007-09-07T02:58:06Z"}, "message": "regrename.c (copyprop_hardreg_forward_1): New variable next.\n\n2007-09-05  Laurynas Biveinis  <laurynas.biveinis@gmail.com>\n\n\t* regrename.c (copyprop_hardreg_forward_1): New variable next. Use\n\tFOR_BB_INSNS_SAFE instead of for loop.\n\t* cse.c (cse_extended_basic_block): Likewise.\n\t* postreload.c (reload_cse_regs_1): New variable next. Make sure\n\tthat the for loop does not invoke NEXT_INSN on a deleted insn.\n\t* function.c (instantiate_virtual_regs): Likewise.\n\t* lower-subreg.c (remove_retval_note): Likewise.\n\t(decompose_multiword_subregs): Use FOR_BB_INSNS_SAFE instead of\n\tFOR_BB_INSNS.\n\t* emit-rtl.c (remove_insn): Set NEXT_INSN and PREV_INSN to NULL on\n\ta deleted insn.\n\t* cfgrtl.c (delete_insn): Set JUMP_LABEL to NULL on a deleted\n\tinsn, if it's a jump.\n\t(try_redirect_by_replacing_jump): New variable jump_p. Call\n\ttablejump_p before delete_insn_chain.\n\t* reload1.c (reload): New variable next. Make sure that the for\n\tloop does not invoke NEXT_INSN on a deleted insn.\n\t(fixup_eh_region_note): Make the loop terminate if i becomes NULL.\n\t(delete_output_reload): New variable prev. Make sure the the for\n\tloops do not invoke PREV_INSN on a deleted insn.\n\nFrom-SVN: r128224", "tree": {"sha": "7ccd90b156ce32fb4c8f8191c5876483c41c14e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ccd90b156ce32fb4c8f8191c5876483c41c14e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/62a4a967a9ec706432d076cd352b64ca07b8445d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62a4a967a9ec706432d076cd352b64ca07b8445d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62a4a967a9ec706432d076cd352b64ca07b8445d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62a4a967a9ec706432d076cd352b64ca07b8445d/comments", "author": {"login": "laurynas-biveinis", "id": 58894, "node_id": "MDQ6VXNlcjU4ODk0", "avatar_url": "https://avatars.githubusercontent.com/u/58894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/laurynas-biveinis", "html_url": "https://github.com/laurynas-biveinis", "followers_url": "https://api.github.com/users/laurynas-biveinis/followers", "following_url": "https://api.github.com/users/laurynas-biveinis/following{/other_user}", "gists_url": "https://api.github.com/users/laurynas-biveinis/gists{/gist_id}", "starred_url": "https://api.github.com/users/laurynas-biveinis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/laurynas-biveinis/subscriptions", "organizations_url": "https://api.github.com/users/laurynas-biveinis/orgs", "repos_url": "https://api.github.com/users/laurynas-biveinis/repos", "events_url": "https://api.github.com/users/laurynas-biveinis/events{/privacy}", "received_events_url": "https://api.github.com/users/laurynas-biveinis/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "917948d364025c5cc418cd6486dc75b43fa12015", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/917948d364025c5cc418cd6486dc75b43fa12015", "html_url": "https://github.com/Rust-GCC/gccrs/commit/917948d364025c5cc418cd6486dc75b43fa12015"}], "stats": {"total": 293, "additions": 169, "deletions": 124}, "files": [{"sha": "14f77c9e0e89686576c42ab20f183b5cb0a2a9ed", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62a4a967a9ec706432d076cd352b64ca07b8445d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62a4a967a9ec706432d076cd352b64ca07b8445d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=62a4a967a9ec706432d076cd352b64ca07b8445d", "patch": "@@ -1,3 +1,26 @@\n+2007-09-05  Laurynas Biveinis  <laurynas.biveinis@gmail.com>\n+\n+\t* regrename.c (copyprop_hardreg_forward_1): New variable next. Use\n+\tFOR_BB_INSNS_SAFE instead of for loop.\n+\t* cse.c (cse_extended_basic_block): Likewise.\n+\t* postreload.c (reload_cse_regs_1): New variable next. Make sure\n+\tthat the for loop does not invoke NEXT_INSN on a deleted insn.\n+\t* function.c (instantiate_virtual_regs): Likewise.\n+\t* lower-subreg.c (remove_retval_note): Likewise.\n+\t(decompose_multiword_subregs): Use FOR_BB_INSNS_SAFE instead of\n+\tFOR_BB_INSNS.\n+\t* emit-rtl.c (remove_insn): Set NEXT_INSN and PREV_INSN to NULL on\n+\ta deleted insn.\n+\t* cfgrtl.c (delete_insn): Set JUMP_LABEL to NULL on a deleted\n+\tinsn, if it's a jump.\n+\t(try_redirect_by_replacing_jump): New variable jump_p. Call\n+\ttablejump_p before delete_insn_chain.\n+\t* reload1.c (reload): New variable next. Make sure that the for\n+\tloop does not invoke NEXT_INSN on a deleted insn.\n+\t(fixup_eh_region_note): Make the loop terminate if i becomes NULL.\n+\t(delete_output_reload): New variable prev. Make sure the the for\n+\tloops do not invoke PREV_INSN on a deleted insn.\n+\n 2007-09-06  Zdenek Dvorak  <ook@ucw.cz>\n \n \t* cgraphbuild.c (rebuild_cgraph_edges): Export."}, {"sha": "a31488ef7d51d58ebfcb8a7a118bf849b048d65d", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62a4a967a9ec706432d076cd352b64ca07b8445d/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62a4a967a9ec706432d076cd352b64ca07b8445d/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=62a4a967a9ec706432d076cd352b64ca07b8445d", "patch": "@@ -141,7 +141,10 @@ delete_insn (rtx insn)\n   if (JUMP_P (insn)\n       && JUMP_LABEL (insn)\n       && LABEL_P (JUMP_LABEL (insn)))\n-    LABEL_NUSES (JUMP_LABEL (insn))--;\n+    {\n+      LABEL_NUSES (JUMP_LABEL (insn))--;\n+      JUMP_LABEL (insn) = NULL;\n+    }\n \n   /* Also if deleting an insn that references a label.  */\n   else\n@@ -790,6 +793,7 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n     {\n       rtx target_label = block_label (target);\n       rtx barrier, label, table;\n+      bool jump_p;\n \n       emit_jump_insn_after_noloc (gen_jump (target_label), insn);\n       JUMP_LABEL (BB_END (src)) = target_label;\n@@ -799,13 +803,14 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n \t\t INSN_UID (insn), INSN_UID (BB_END (src)));\n \n \n-      delete_insn_chain (kill_from, insn, false);\n-\n       /* Recognize a tablejump that we are converting to a\n \t simple jump and remove its associated CODE_LABEL\n \t and ADDR_VEC or ADDR_DIFF_VEC.  */\n-      if (tablejump_p (insn, &label, &table))\n-\tdelete_insn_chain (label, table, false);\n+      jump_p = tablejump_p (insn, &label, &table);\n+\n+      delete_insn_chain (kill_from, insn, false);\n+      if (jump_p)\n+        delete_insn_chain (label, table, false);\n \n       barrier = next_nonnote_insn (BB_END (src));\n       if (!barrier || !BARRIER_P (barrier))"}, {"sha": "f3395e8c33dae8811e6fdabb58fdd7cde0ba7d2c", "filename": "gcc/cse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62a4a967a9ec706432d076cd352b64ca07b8445d/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62a4a967a9ec706432d076cd352b64ca07b8445d/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=62a4a967a9ec706432d076cd352b64ca07b8445d", "patch": "@@ -6018,12 +6018,12 @@ cse_extended_basic_block (struct cse_basic_block_data *ebb_data)\n   for (path_entry = 0; path_entry < path_size; path_entry++)\n     {\n       basic_block bb;\n-      rtx insn;\n+      rtx insn, next;\n       rtx libcall_insn = NULL_RTX;\n       int no_conflict = 0;\n \n       bb = ebb_data->path[path_entry].bb;\n-      FOR_BB_INSNS (bb, insn)\n+      FOR_BB_INSNS_SAFE (bb, insn, next)\n \t{\n \t  /* If we have processed 1,000 insns, flush the hash table to\n \t     avoid extreme quadratic behavior.  We must not include NOTEs"}, {"sha": "77a394cb04e23a01f37c86b5961c2958e1667ddc", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62a4a967a9ec706432d076cd352b64ca07b8445d/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62a4a967a9ec706432d076cd352b64ca07b8445d/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=62a4a967a9ec706432d076cd352b64ca07b8445d", "patch": "@@ -3688,6 +3688,8 @@ remove_insn (rtx insn)\n       if (BB_END (bb) == insn)\n \tBB_END (bb) = prev;\n     }\n+  NEXT_INSN (insn) = NULL;\n+  PREV_INSN (insn) = NULL;\n }\n \n /* Append CALL_FUSAGE to the CALL_INSN_FUNCTION_USAGE for CALL_INSN.  */"}, {"sha": "23c53665a5ba2c61c7cff9a7836f5eb762ac8ccc", "filename": "gcc/function.c", "status": "modified", "additions": 29, "deletions": 25, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62a4a967a9ec706432d076cd352b64ca07b8445d/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62a4a967a9ec706432d076cd352b64ca07b8445d/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=62a4a967a9ec706432d076cd352b64ca07b8445d", "patch": "@@ -1666,7 +1666,7 @@ instantiate_decls (tree fndecl)\n static unsigned int\n instantiate_virtual_regs (void)\n {\n-  rtx insn;\n+  rtx insn, next;\n \n   /* Compute the offsets to use for this function.  */\n   in_arg_offset = FIRST_PARM_OFFSET (current_function_decl);\n@@ -1684,30 +1684,34 @@ instantiate_virtual_regs (void)\n \n   /* Scan through all the insns, instantiating every virtual register still\n      present.  */\n-  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-    if (INSN_P (insn))\n-      {\n-\t/* These patterns in the instruction stream can never be recognized.\n-\t   Fortunately, they shouldn't contain virtual registers either.  */\n-\tif (GET_CODE (PATTERN (insn)) == USE\n-\t    || GET_CODE (PATTERN (insn)) == CLOBBER\n-\t    || GET_CODE (PATTERN (insn)) == ADDR_VEC\n-\t    || GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC\n-\t    || GET_CODE (PATTERN (insn)) == ASM_INPUT)\n-\t  continue;\n-\n-\tinstantiate_virtual_regs_in_insn (insn);\n-\n-\tif (INSN_DELETED_P (insn))\n-\t  continue;\n-\n-\tfor_each_rtx (&REG_NOTES (insn), instantiate_virtual_regs_in_rtx, NULL);\n-\n-\t/* Instantiate any virtual registers in CALL_INSN_FUNCTION_USAGE.  */\n-\tif (GET_CODE (insn) == CALL_INSN)\n-\t  for_each_rtx (&CALL_INSN_FUNCTION_USAGE (insn),\n-\t\t\tinstantiate_virtual_regs_in_rtx, NULL);\n-      }\n+  for (insn = get_insns (); insn; insn = next)\n+    {\n+      next = NEXT_INSN (insn);\n+      if (INSN_P (insn))\n+        {\n+          /* These patterns in the instruction stream can never be recognized.\n+             Fortunately, they shouldn't contain virtual registers either.  */\n+          if (GET_CODE (PATTERN (insn)) == USE\n+              || GET_CODE (PATTERN (insn)) == CLOBBER\n+              || GET_CODE (PATTERN (insn)) == ADDR_VEC\n+              || GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC\n+              || GET_CODE (PATTERN (insn)) == ASM_INPUT)\n+            continue;\n+\n+          instantiate_virtual_regs_in_insn (insn);\n+\n+          if (INSN_DELETED_P (insn))\n+            continue;\n+\n+          for_each_rtx (&REG_NOTES (insn), instantiate_virtual_regs_in_rtx,\n+                        NULL);\n+\n+          /* Instantiate any virtual registers in CALL_INSN_FUNCTION_USAGE.  */\n+          if (GET_CODE (insn) == CALL_INSN)\n+            for_each_rtx (&CALL_INSN_FUNCTION_USAGE (insn),\n+                          instantiate_virtual_regs_in_rtx, NULL);\n+        }\n+    }\n \n   /* Instantiate the virtual registers in the DECLs for debugging purposes.  */\n   instantiate_decls (current_function_decl);"}, {"sha": "e5e76b0b7191d4e57201e3d2c469a5e72c4e0dcd", "filename": "gcc/lower-subreg.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62a4a967a9ec706432d076cd352b64ca07b8445d/gcc%2Flower-subreg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62a4a967a9ec706432d076cd352b64ca07b8445d/gcc%2Flower-subreg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flower-subreg.c?ref=62a4a967a9ec706432d076cd352b64ca07b8445d", "patch": "@@ -586,7 +586,7 @@ move_libcall_note (rtx old_start, rtx new_start)\n static void\n remove_retval_note (rtx insn1)\n {\n-  rtx note0, insn0, note1, insn;\n+  rtx note0, insn0, note1, insn, next;\n \n   note1 = find_reg_note (insn1, REG_RETVAL, NULL);\n   if (note1 == NULL_RTX)\n@@ -598,8 +598,9 @@ remove_retval_note (rtx insn1)\n   remove_note (insn0, note0);\n   remove_note (insn1, note1);\n \n-  for (insn = insn0; insn != insn1; insn = NEXT_INSN (insn))\n+  for (insn = insn0; (insn != insn1) && insn; insn = next)\n     {\n+      next = NEXT_INSN (insn);\n       while (1)\n \t{\n \t  rtx note;\n@@ -1254,9 +1255,9 @@ decompose_multiword_subregs (void)\n \n       FOR_EACH_BB (bb)\n \t{\n-\t  rtx insn;\n+          rtx insn, next;\n \n-\t  FOR_BB_INSNS (bb, insn)\n+          FOR_BB_INSNS_SAFE (bb, insn, next)\n \t    {\n \t      rtx next, pat;\n "}, {"sha": "2fd34e80c9aa406a439ce3da6b179f6ef5454508", "filename": "gcc/postreload.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62a4a967a9ec706432d076cd352b64ca07b8445d/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62a4a967a9ec706432d076cd352b64ca07b8445d/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=62a4a967a9ec706432d076cd352b64ca07b8445d", "patch": "@@ -195,14 +195,15 @@ reload_cse_simplify (rtx insn, rtx testreg)\n static void\n reload_cse_regs_1 (rtx first)\n {\n-  rtx insn;\n+  rtx insn, next;\n   rtx testreg = gen_rtx_REG (VOIDmode, -1);\n \n   cselib_init (true);\n   init_alias_analysis ();\n \n-  for (insn = first; insn; insn = NEXT_INSN (insn))\n+  for (insn = first; insn; insn = next)\n     {\n+      next = NEXT_INSN (insn);\n       if (INSN_P (insn))\n \treload_cse_simplify (insn, testreg);\n "}, {"sha": "934df394aaa65ac4f7157fa07b34dc5dd69d88f5", "filename": "gcc/regrename.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62a4a967a9ec706432d076cd352b64ca07b8445d/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62a4a967a9ec706432d076cd352b64ca07b8445d/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=62a4a967a9ec706432d076cd352b64ca07b8445d", "patch": "@@ -1567,9 +1567,9 @@ static bool\n copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n {\n   bool changed = false;\n-  rtx insn;\n+  rtx insn, next;\n \n-  for (insn = BB_HEAD (bb); ; insn = NEXT_INSN (insn))\n+  FOR_BB_INSNS_SAFE (bb, insn, next)\n     {\n       int n_ops, i, alt, predicated;\n       bool is_asm, any_replacements;"}, {"sha": "dada892171656194dd97cca18a1f347ec1f647be", "filename": "gcc/reload1.c", "status": "modified", "additions": 93, "deletions": 84, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62a4a967a9ec706432d076cd352b64ca07b8445d/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62a4a967a9ec706432d076cd352b64ca07b8445d/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=62a4a967a9ec706432d076cd352b64ca07b8445d", "patch": "@@ -702,7 +702,7 @@ int\n reload (rtx first, int global)\n {\n   int i;\n-  rtx insn;\n+  rtx insn, next;\n   struct elim_table *ep;\n   basic_block bb;\n \n@@ -1225,87 +1225,91 @@ reload (rtx first, int global)\n      are no longer useful or accurate.  Strip and regenerate REG_INC notes\n      that may have been moved around.  */\n \n-  for (insn = first; insn; insn = NEXT_INSN (insn))\n-    if (INSN_P (insn))\n-      {\n-\trtx *pnote;\n-\n-\tif (CALL_P (insn))\n-\t  replace_pseudos_in (& CALL_INSN_FUNCTION_USAGE (insn),\n-\t\t\t      VOIDmode, CALL_INSN_FUNCTION_USAGE (insn));\n-\n-\tif ((GET_CODE (PATTERN (insn)) == USE\n-\t     /* We mark with QImode USEs introduced by reload itself.  */\n-\t     && (GET_MODE (insn) == QImode\n-\t\t || find_reg_note (insn, REG_EQUAL, NULL_RTX)))\n-\t    || (GET_CODE (PATTERN (insn)) == CLOBBER\n-\t\t&& (!MEM_P (XEXP (PATTERN (insn), 0))\n-\t\t    || GET_MODE (XEXP (PATTERN (insn), 0)) != BLKmode\n-\t\t    || (GET_CODE (XEXP (XEXP (PATTERN (insn), 0), 0)) != SCRATCH\n-\t\t\t&& XEXP (XEXP (PATTERN (insn), 0), 0)\n-\t\t\t\t!= stack_pointer_rtx))\n-\t\t&& (!REG_P (XEXP (PATTERN (insn), 0))\n-\t\t    || ! REG_FUNCTION_VALUE_P (XEXP (PATTERN (insn), 0)))))\n-\t  {\n-\t    delete_insn (insn);\n-\t    continue;\n-\t  }\n-\n-\t/* Some CLOBBERs may survive until here and still reference unassigned\n-\t   pseudos with const equivalent, which may in turn cause ICE in later\n-\t   passes if the reference remains in place.  */\n-\tif (GET_CODE (PATTERN (insn)) == CLOBBER)\n-\t  replace_pseudos_in (& XEXP (PATTERN (insn), 0),\n-\t\t\t      VOIDmode, PATTERN (insn));\n-\n-\t/* Discard obvious no-ops, even without -O.  This optimization\n-\t   is fast and doesn't interfere with debugging.  */\n-\tif (NONJUMP_INSN_P (insn)\n-\t    && GET_CODE (PATTERN (insn)) == SET\n-\t    && REG_P (SET_SRC (PATTERN (insn)))\n-\t    && REG_P (SET_DEST (PATTERN (insn)))\n-\t    && (REGNO (SET_SRC (PATTERN (insn)))\n-\t\t== REGNO (SET_DEST (PATTERN (insn)))))\n-\t  {\n-\t    delete_insn (insn);\n-\t    continue;\n-\t  }\n-\n-\tpnote = &REG_NOTES (insn);\n-\twhile (*pnote != 0)\n-\t  {\n-\t    if (REG_NOTE_KIND (*pnote) == REG_DEAD\n-\t\t|| REG_NOTE_KIND (*pnote) == REG_UNUSED\n-\t\t|| REG_NOTE_KIND (*pnote) == REG_INC\n-\t\t|| REG_NOTE_KIND (*pnote) == REG_RETVAL\n-\t\t|| REG_NOTE_KIND (*pnote) == REG_LIBCALL_ID\n-\t\t|| REG_NOTE_KIND (*pnote) == REG_LIBCALL)\n-\t      *pnote = XEXP (*pnote, 1);\n-\t    else\n-\t      pnote = &XEXP (*pnote, 1);\n-\t  }\n+  for (insn = first; insn; insn = next)\n+    {\n+      next = NEXT_INSN (insn);\n+      if (INSN_P (insn))\n+        {\n+          rtx *pnote;\n+\n+          if (CALL_P (insn))\n+            replace_pseudos_in (& CALL_INSN_FUNCTION_USAGE (insn),\n+                                VOIDmode, CALL_INSN_FUNCTION_USAGE (insn));\n+\n+          if ((GET_CODE (PATTERN (insn)) == USE\n+               /* We mark with QImode USEs introduced by reload itself.  */\n+               && (GET_MODE (insn) == QImode\n+                   || find_reg_note (insn, REG_EQUAL, NULL_RTX)))\n+              || (GET_CODE (PATTERN (insn)) == CLOBBER\n+                  && (!MEM_P (XEXP (PATTERN (insn), 0))\n+                      || GET_MODE (XEXP (PATTERN (insn), 0)) != BLKmode\n+                      || (GET_CODE (XEXP (XEXP (PATTERN (insn), 0), 0))\n+                          != SCRATCH\n+                          && XEXP (XEXP (PATTERN (insn), 0), 0)\n+                          != stack_pointer_rtx))\n+                  && (!REG_P (XEXP (PATTERN (insn), 0))\n+                      || ! REG_FUNCTION_VALUE_P (XEXP (PATTERN (insn), 0)))))\n+            {\n+              delete_insn (insn);\n+              continue;\n+            }\n+\n+          /* Some CLOBBERs may survive until here and still reference\n+             unassigned pseudos with const equivalent, which may in turn cause\n+             ICE in later passes if the reference remains in place.  */\n+          if (GET_CODE (PATTERN (insn)) == CLOBBER)\n+            replace_pseudos_in (& XEXP (PATTERN (insn), 0),\n+                                VOIDmode, PATTERN (insn));\n+\n+          /* Discard obvious no-ops, even without -O.  This optimization\n+             is fast and doesn't interfere with debugging.  */\n+          if (NONJUMP_INSN_P (insn)\n+              && GET_CODE (PATTERN (insn)) == SET\n+              && REG_P (SET_SRC (PATTERN (insn)))\n+              && REG_P (SET_DEST (PATTERN (insn)))\n+              && (REGNO (SET_SRC (PATTERN (insn)))\n+                  == REGNO (SET_DEST (PATTERN (insn)))))\n+            {\n+              delete_insn (insn);\n+              continue;\n+            }\n+\n+          pnote = &REG_NOTES (insn);\n+          while (*pnote != 0)\n+            {\n+              if (REG_NOTE_KIND (*pnote) == REG_DEAD\n+                  || REG_NOTE_KIND (*pnote) == REG_UNUSED\n+                  || REG_NOTE_KIND (*pnote) == REG_INC\n+                  || REG_NOTE_KIND (*pnote) == REG_RETVAL\n+                  || REG_NOTE_KIND (*pnote) == REG_LIBCALL_ID\n+                  || REG_NOTE_KIND (*pnote) == REG_LIBCALL)\n+                *pnote = XEXP (*pnote, 1);\n+              else\n+                pnote = &XEXP (*pnote, 1);\n+            }\n \n #ifdef AUTO_INC_DEC\n-\tadd_auto_inc_notes (insn, PATTERN (insn));\n+          add_auto_inc_notes (insn, PATTERN (insn));\n #endif\n \n-\t/* Simplify (subreg (reg)) if it appears as an operand.  */\n-\tcleanup_subreg_operands (insn);\n-\n-\t/* Clean up invalid ASMs so that they don't confuse later passes.\n-\t   See PR 21299.  */\n-\tif (asm_noperands (PATTERN (insn)) >= 0)\n-\t  {\n-\t    extract_insn (insn);\n-\t    if (!constrain_operands (1))\n-\t      {\n-\t\terror_for_asm (insn,\n-\t\t\t       \"%<asm%> operand has impossible constraints\");\n-\t\tdelete_insn (insn);\n-\t\tcontinue;\n-\t      }\n-\t  }\n-      }\n+          /* Simplify (subreg (reg)) if it appears as an operand.  */\n+          cleanup_subreg_operands (insn);\n+\n+          /* Clean up invalid ASMs so that they don't confuse later passes.\n+             See PR 21299.  */\n+          if (asm_noperands (PATTERN (insn)) >= 0)\n+            {\n+              extract_insn (insn);\n+              if (!constrain_operands (1))\n+\t        {\n+                  error_for_asm (insn,\n+                                 \"%<asm%> operand has impossible constraints\");\n+                  delete_insn (insn);\n+                  continue;\n+                }\n+            }\n+        }\n+    }\n \n   /* If we are doing stack checking, give a warning if this function's\n      frame size is larger than we expect.  */\n@@ -4014,7 +4018,7 @@ fixup_eh_region_note (rtx insn, rtx prev, rtx next)\n       trap_count = 0;\n     }\n \n-  for (i = NEXT_INSN (prev); i != next; i = NEXT_INSN (i))\n+  for (i = NEXT_INSN (prev); i && (i != next); i = NEXT_INSN (i))\n     if (INSN_P (i) && i != insn && may_trap_p (PATTERN (i)))\n       {\n \ttrap_count++;\n@@ -8186,15 +8190,18 @@ delete_output_reload (rtx insn, int j, int last_reload_reg)\n       && REG_BASIC_BLOCK (REGNO (reg)) >= NUM_FIXED_BLOCKS\n       && find_regno_note (insn, REG_DEAD, REGNO (reg)))\n     {\n-      rtx i2;\n+      rtx i2, prev;\n \n       /* We know that it was used only between here and the beginning of\n \t the current basic block.  (We also know that the last use before\n \t INSN was the output reload we are thinking of deleting, but never\n \t mind that.)  Search that range; see if any ref remains.  */\n-      for (i2 = PREV_INSN (insn); i2; i2 = PREV_INSN (i2))\n+      for (i2 = PREV_INSN (insn); i2; i2 = prev)\n \t{\n-\t  rtx set = single_set (i2);\n+          rtx set;\n+\n+          prev = PREV_INSN (i2);\n+          set = single_set (i2);\n \n \t  /* Uses which just store in the pseudo don't count,\n \t     since if they are the only uses, they are dead.  */\n@@ -8216,9 +8223,11 @@ delete_output_reload (rtx insn, int j, int last_reload_reg)\n \n       /* Delete the now-dead stores into this pseudo.  Note that this\n \t loop also takes care of deleting output_reload_insn.  */\n-      for (i2 = PREV_INSN (insn); i2; i2 = PREV_INSN (i2))\n+      for (i2 = PREV_INSN (insn); i2; i2 = prev)\n \t{\n-\t  rtx set = single_set (i2);\n+          rtx set;\n+          prev = PREV_INSN (i2);\n+          set = single_set (i2);\n \n \t  if (set != 0 && SET_DEST (set) == reg)\n \t    {"}]}