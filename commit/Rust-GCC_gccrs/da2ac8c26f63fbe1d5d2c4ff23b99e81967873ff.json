{"sha": "da2ac8c26f63fbe1d5d2c4ff23b99e81967873ff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGEyYWM4YzI2ZjYzZmJlMWQ1ZDJjNGZmMjNiOTllODE5Njc4NzNmZg==", "commit": {"author": {"name": "Emmanuel Briot", "email": "briot@adacore.com", "date": "2007-09-26T10:44:07Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-09-26T10:44:07Z"}, "message": "g-comlin.ads, [...] (Command_Line_Configuration, [...]): New types\n\n2007-09-26  Emmanuel Briot  <briot@adacore.com>\n\n\t* g-comlin.ads, g-comlin.adb (Command_Line_Configuration,\n\tCommand_Line): New types\n\t(Define_Alias, Define_Prefix, Free): New subprograms. These provide\n\tsupport for defining how switches can be grouped on a command line (as\n\tis the case for -gnatw... for GNAT), and how simple switches can be\n\tused as aliases for more complex switches (-gnatwa is same as\n\t-gnatwbcef...)\n\t(Set_Command_Line, Add_Switch, Remove_Switch): New subprogram\n\t(Start, Current_*): New subprograms\n\tAdded support for parsing an array of strings in addition to the real\n\tcommand line.\n\t(Opt_Parser, Opt_Parser_Data): New type. As a result, some types had to\n\t be moved from the body to the private part of the spec.\n\t(*): All subprograms now have an extra parameter with default value to\n\tspecify which parser should be used. For backward compatibility, it\n\tdefaults to parsing the command line of the application. They were also\n\tmodified to properly handle cases where each of the argument does not\n\tstart at index 1 (which is always true for Ada.Command_Line, but not\n\twhen processing any Argument_List).\n\t(Free): New subprogram\n\t(Internal_Initialize_Option_Scan, Find_Longuest_Matching_Switch,\n\tArgument): New subprograms\n\t(Switch_Parameter_Type): New enum, which clarifies the code. The extra\n\tspecial characters like ':', '=',... are now handled in a single place,\n\twhich makes the code more extensible eventually.\n\t(Getopt, Full_Switch): When the switch was returned as part of the\n\tspecial character '*', make sure it is prepended by the switch character\n\t('-' in general), so that the application knows whether \"foo\" or \"-foo\"\n\twas specified on the command line.\n\nFrom-SVN: r128791", "tree": {"sha": "f89a3bd22b0a3109cfe01d8c2a977f4780d8bb4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f89a3bd22b0a3109cfe01d8c2a977f4780d8bb4a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/da2ac8c26f63fbe1d5d2c4ff23b99e81967873ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da2ac8c26f63fbe1d5d2c4ff23b99e81967873ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da2ac8c26f63fbe1d5d2c4ff23b99e81967873ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da2ac8c26f63fbe1d5d2c4ff23b99e81967873ff/comments", "author": {"login": "briot", "id": 42402, "node_id": "MDQ6VXNlcjQyNDAy", "avatar_url": "https://avatars.githubusercontent.com/u/42402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/briot", "html_url": "https://github.com/briot", "followers_url": "https://api.github.com/users/briot/followers", "following_url": "https://api.github.com/users/briot/following{/other_user}", "gists_url": "https://api.github.com/users/briot/gists{/gist_id}", "starred_url": "https://api.github.com/users/briot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/briot/subscriptions", "organizations_url": "https://api.github.com/users/briot/orgs", "repos_url": "https://api.github.com/users/briot/repos", "events_url": "https://api.github.com/users/briot/events{/privacy}", "received_events_url": "https://api.github.com/users/briot/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dd05ba2754e8bf033ce3258f0bc64fd7b2220ed9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd05ba2754e8bf033ce3258f0bc64fd7b2220ed9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd05ba2754e8bf033ce3258f0bc64fd7b2220ed9"}], "stats": {"total": 2121, "additions": 1725, "deletions": 396}, "files": [{"sha": "61a0d87da2778dd32e8af040c01b825895a18439", "filename": "gcc/ada/g-comlin.adb", "status": "modified", "additions": 1256, "deletions": 370, "changes": 1626, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da2ac8c26f63fbe1d5d2c4ff23b99e81967873ff/gcc%2Fada%2Fg-comlin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da2ac8c26f63fbe1d5d2c4ff23b99e81967873ff/gcc%2Fada%2Fg-comlin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-comlin.adb?ref=da2ac8c26f63fbe1d5d2c4ff23b99e81967873ff", "patch": "@@ -31,73 +31,33 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Ada.Command_Line;\n+with Ada.Unchecked_Deallocation;\n with GNAT.OS_Lib;      use GNAT.OS_Lib;\n \n package body GNAT.Command_Line is\n \n    package CL renames Ada.Command_Line;\n \n-   type Section_Number is new Natural range 0 .. 65534;\n-   for Section_Number'Size use 16;\n-\n-   type Parameter_Type is record\n-      Arg_Num : Positive;\n-      First   : Positive;\n-      Last    : Positive;\n-   end record;\n-   The_Parameter : Parameter_Type;\n-   The_Switch    : Parameter_Type;\n-   --  This type and this variable are provided to store the current switch\n-   --  and parameter.\n-\n-   type Is_Switch_Type is array (1 .. CL.Argument_Count) of Boolean;\n-   pragma Pack (Is_Switch_Type);\n-\n-   Is_Switch : Is_Switch_Type := (others => False);\n-   --  Indicates wich arguments on the command line are considered not be\n-   --  switches or parameters to switches (this leaves e.g. the filenames...).\n-\n-   type Section_Type is array (1 .. CL.Argument_Count + 1) of Section_Number;\n-   pragma Pack (Section_Type);\n-   Section : Section_Type := (others => 1);\n-   --  Contains the number of the section associated with the current switch.\n-   --  If this number is 0, then it is a section delimiter, which is never\n-   --  returns by GetOpt. The last element of this array is set to 0 to avoid\n-   --  the need to test for reaching the end of the command line in loops.\n-\n-   Current_Argument : Natural := 1;\n-   --  Number of the current argument parsed on the command line\n-\n-   Current_Index : Natural := 1;\n-   --  Index in the current argument of the character to be processed\n-\n-   Current_Section : Section_Number := 1;\n-\n-   Expansion_It : aliased Expansion_Iterator;\n-   --  When Get_Argument is expanding a file name, this is the iterator used\n-\n-   In_Expansion : Boolean := False;\n-   --  True if we are expanding a file\n-\n-   Switch_Character : Character := '-';\n-   --  The character at the beginning of the command line arguments, indicating\n-   --  the beginning of a switch.\n-\n-   Stop_At_First : Boolean := False;\n-   --  If it is True then Getopt stops at the first non-switch argument\n+   type Switch_Parameter_Type is\n+     (Parameter_None,\n+      Parameter_With_Optional_Space,  --  ':' in getopt\n+      Parameter_With_Space_Or_Equal,  --  '=' in getopt\n+      Parameter_No_Space,             --  '!' in getopt\n+      Parameter_Optional);            --  '?' in getop\n \n    procedure Set_Parameter\n      (Variable : out Parameter_Type;\n       Arg_Num  : Positive;\n       First    : Positive;\n-      Last     : Positive);\n+      Last     : Positive;\n+      Extra    : Character := ASCII.NUL);\n    pragma Inline (Set_Parameter);\n    --  Set the parameter that will be returned by Parameter below\n+   --  Parameters need to be defined ???\n \n-   function Goto_Next_Argument_In_Section return Boolean;\n-   --  Go to the next argument on the command line. If we are at the end of the\n-   --  current section, we want to make sure there is no other identical\n+   function Goto_Next_Argument_In_Section (Parser : Opt_Parser) return Boolean;\n+   --  Go to the next argument on the command line. If we are at the end of\n+   --  the current section, we want to make sure there is no other identical\n    --  section on the command line (there might be multiple instances of\n    --  -largs). Returns True iff there is another argument.\n \n@@ -116,6 +76,87 @@ package body GNAT.Command_Line is\n    --  converts the given string to canonical all lower case form, so that two\n    --  file names compare equal if they refer to the same file.\n \n+   procedure Internal_Initialize_Option_Scan\n+     (Parser                   : Opt_Parser;\n+      Switch_Char              : Character;\n+      Stop_At_First_Non_Switch : Boolean;\n+      Section_Delimiters       : String);\n+   --  Initialize Parser, which must have been allocated already\n+\n+   function Argument (Parser : Opt_Parser; Index : Integer) return String;\n+   --  Return the index-th command line argument\n+\n+   procedure Find_Longest_Matching_Switch\n+     (Switches          : String;\n+      Arg               : String;\n+      Index_In_Switches : out Integer;\n+      Switch_Length     : out Integer;\n+      Param             : out Switch_Parameter_Type);\n+   --  return the Longest switch from Switches that matches at least\n+   --  partially Arg. Index_In_Switches is set to 0 if none matches\n+\n+   procedure Unchecked_Free is new Ada.Unchecked_Deallocation\n+     (Argument_List, Argument_List_Access);\n+\n+   procedure Unchecked_Free is new Ada.Unchecked_Deallocation\n+     (Command_Line_Configuration_Record, Command_Line_Configuration);\n+\n+   type Boolean_Chars is array (Character) of Boolean;\n+\n+   procedure Remove (Line : in out Argument_List_Access; Index : Integer);\n+   --  Remove a specific element from Line\n+\n+   procedure Append\n+     (Line : in out Argument_List_Access;\n+      Str  : String_Access);\n+   --  Append a new element to Line\n+\n+   function Args_From_Expanded (Args : Boolean_Chars) return String;\n+   --  Return the string made of all characters with True in Args\n+\n+   type Callback_Procedure is access procedure (Simple_Switch : String);\n+   procedure For_Each_Simple_Switch\n+     (Cmd      : Command_Line;\n+      Switch   : String;\n+      Callback : Callback_Procedure);\n+   --  Breaks Switch into as simple switches as possible (expanding aliases and\n+   --  ungrouping common prefixes when possible), and call Callback for each of\n+   --  these.\n+\n+   procedure Group_Switches\n+     (Cmd    : Command_Line;\n+      Result : Argument_List_Access;\n+      Params : Argument_List_Access);\n+   --  Group switches with common prefixes whenever possible.\n+   --  Once they have been grouped, we also check items for possible aliasing\n+\n+   procedure Alias_Switches\n+     (Cmd    : Command_Line;\n+      Result : Argument_List_Access;\n+      Params : Argument_List_Access);\n+   --  When possible, replace or more switches by an alias, ie a shorter\n+   --  version.\n+\n+   function Looking_At\n+     (Type_Str  : String;\n+      Index     : Natural;\n+      Substring : String) return Boolean;\n+   --  Return True if the characters starting at Index in Type_Str are\n+   --  equivalent to Substring.\n+\n+   --------------\n+   -- Argument --\n+   --------------\n+\n+   function Argument (Parser : Opt_Parser; Index : Integer) return String is\n+   begin\n+      if Parser.Arguments /= null then\n+         return Parser.Arguments (Index + Parser.Arguments'First - 1).all;\n+      else\n+         return CL.Argument (Index);\n+      end if;\n+   end Argument;\n+\n    ------------------------------\n    -- Canonical_Case_File_Name --\n    ------------------------------\n@@ -125,8 +166,8 @@ package body GNAT.Command_Line is\n       if not File_Names_Case_Sensitive then\n          for J in S'Range loop\n             if S (J) in 'A' .. 'Z' then\n-               S (J) := Character'Val (\n-                          Character'Pos (S (J)) +\n+               S (J) := Character'Val\n+                         (Character'Pos (S (J)) +\n                           Character'Pos ('a')   -\n                           Character'Pos ('A'));\n             end if;\n@@ -167,7 +208,7 @@ package body GNAT.Command_Line is\n             if Current = 1 then\n                return String'(1 .. 0 => ' ');\n             else\n-               --  Otherwise, continue with the directory at the previous level\n+               --  Otherwise continue with the directory at the previous level\n \n                Current := Current - 1;\n                It.Current_Depth := Current;\n@@ -210,19 +251,18 @@ package body GNAT.Command_Line is\n          else\n             declare\n                Name : String :=\n-                 It.Dir_Name (It.Start .. It.Levels (Current).Name_Last) &\n-                 S (1 .. Last);\n+                        It.Dir_Name (It.Start .. It.Levels (Current).Name_Last)\n+                          & S (1 .. Last);\n             begin\n                Canonical_Case_File_Name (Name);\n \n-               --  If it matches, return the relative path\n+               --  If it matches return the relative path\n \n                if GNAT.Regexp.Match (Name, Iterator.Regexp) then\n                   return Name;\n                end if;\n             end;\n          end if;\n-\n       end loop;\n \n       return String'(1 .. 0 => ' ');\n@@ -232,90 +272,99 @@ package body GNAT.Command_Line is\n    -- Full_Switch --\n    -----------------\n \n-   function Full_Switch return String is\n+   function Full_Switch\n+     (Parser : Opt_Parser := Command_Line_Parser) return String\n+   is\n    begin\n-      return CL.Argument (The_Switch.Arg_Num)\n-        (The_Switch.First .. The_Switch.Last);\n+      if Parser.The_Switch.Extra = ASCII.NUL then\n+         return Argument (Parser, Parser.The_Switch.Arg_Num)\n+           (Parser.The_Switch.First .. Parser.The_Switch.Last);\n+      else\n+         return Parser.The_Switch.Extra\n+           & Argument (Parser, Parser.The_Switch.Arg_Num)\n+           (Parser.The_Switch.First .. Parser.The_Switch.Last);\n+      end if;\n    end Full_Switch;\n \n    ------------------\n    -- Get_Argument --\n    ------------------\n \n-   function Get_Argument (Do_Expansion : Boolean := False) return String is\n-      Total : constant Natural := CL.Argument_Count;\n-\n+   function Get_Argument\n+     (Do_Expansion : Boolean    := False;\n+      Parser       : Opt_Parser := Command_Line_Parser) return String\n+   is\n    begin\n-      if In_Expansion then\n+      if Parser.In_Expansion then\n          declare\n-            S : constant String := Expansion (Expansion_It);\n-\n+            S : constant String := Expansion (Parser.Expansion_It);\n          begin\n             if S'Length /= 0 then\n                return S;\n             else\n-               In_Expansion := False;\n+               Parser.In_Expansion := False;\n             end if;\n          end;\n       end if;\n \n-      if Current_Argument > Total then\n+      if Parser.Current_Argument > Parser.Arg_Count then\n \n          --  If this is the first time this function is called\n \n-         if Current_Index = 1 then\n-            Current_Argument := 1;\n-            while Current_Argument <= CL.Argument_Count\n-              and then Section (Current_Argument) /= Current_Section\n+         if Parser.Current_Index = 1 then\n+            Parser.Current_Argument := 1;\n+            while Parser.Current_Argument <= Parser.Arg_Count\n+              and then Parser.Section (Parser.Current_Argument) /=\n+                Parser.Current_Section\n             loop\n-               Current_Argument := Current_Argument + 1;\n+               Parser.Current_Argument := Parser.Current_Argument + 1;\n             end loop;\n          else\n             return String'(1 .. 0 => ' ');\n          end if;\n \n-      elsif Section (Current_Argument) = 0 then\n-         while Current_Argument <= CL.Argument_Count\n-           and then Section (Current_Argument) /= Current_Section\n+      elsif Parser.Section (Parser.Current_Argument) = 0 then\n+         while Parser.Current_Argument <= Parser.Arg_Count\n+           and then Parser.Section (Parser.Current_Argument) /=\n+             Parser.Current_Section\n          loop\n-            Current_Argument := Current_Argument + 1;\n+            Parser.Current_Argument := Parser.Current_Argument + 1;\n          end loop;\n       end if;\n \n-      Current_Index := 2;\n+      Parser.Current_Index := Integer'Last;\n \n-      while Current_Argument <= Total\n-        and then Is_Switch (Current_Argument)\n+      while Parser.Current_Argument <= Parser.Arg_Count\n+        and then Parser.Is_Switch (Parser.Current_Argument)\n       loop\n-         Current_Argument := Current_Argument + 1;\n+         Parser.Current_Argument := Parser.Current_Argument + 1;\n       end loop;\n \n-      if Current_Argument > Total then\n+      if Parser.Current_Argument > Parser.Arg_Count then\n          return String'(1 .. 0 => ' ');\n-      end if;\n-\n-      if Section (Current_Argument) = 0 then\n+      elsif Parser.Section (Parser.Current_Argument) = 0 then\n          return Get_Argument (Do_Expansion);\n       end if;\n \n-      Current_Argument := Current_Argument + 1;\n+      Parser.Current_Argument := Parser.Current_Argument + 1;\n \n       --  Could it be a file name with wild cards to expand?\n \n       if Do_Expansion then\n          declare\n-            Arg   : constant String := CL.Argument (Current_Argument - 1);\n-            Index : Positive := Arg'First;\n+            Arg   : constant String :=\n+                      Argument (Parser, Parser.Current_Argument - 1);\n+            Index : Positive;\n \n          begin\n+            Index := Arg'First;\n             while Index <= Arg'Last loop\n-\n                if Arg (Index) = '*'\n                  or else Arg (Index) = '?'\n                  or else Arg (Index) = '['\n                then\n-                  In_Expansion := True;\n-                  Start_Expansion (Expansion_It, Arg);\n+                  Parser.In_Expansion := True;\n+                  Start_Expansion (Parser.Expansion_It, Arg);\n                   return Get_Argument (Do_Expansion);\n                end if;\n \n@@ -324,308 +373,354 @@ package body GNAT.Command_Line is\n          end;\n       end if;\n \n-      return CL.Argument (Current_Argument - 1);\n+      return Argument (Parser, Parser.Current_Argument - 1);\n    end Get_Argument;\n \n+   ----------------------------------\n+   -- Find_Longest_Matching_Switch --\n+   ----------------------------------\n+\n+   procedure Find_Longest_Matching_Switch\n+     (Switches          : String;\n+      Arg               : String;\n+      Index_In_Switches : out Integer;\n+      Switch_Length     : out Integer;\n+      Param             : out Switch_Parameter_Type)\n+   is\n+      Index  : Natural;\n+      Length : Natural := 1;\n+      P      : Switch_Parameter_Type;\n+\n+   begin\n+      Index_In_Switches := 0;\n+      Switch_Length     := 0;\n+\n+      --  Remove all leading spaces first to make sure that Index points\n+      --  at the start of the first switch.\n+\n+      Index := Switches'First;\n+      while Index <= Switches'Last and then Switches (Index) = ' ' loop\n+         Index := Index + 1;\n+      end loop;\n+\n+      while Index <= Switches'Last loop\n+\n+         --  Search the length of the parameter at this position in Switches\n+\n+         Length := Index;\n+         while Length <= Switches'Last\n+           and then Switches (Length) /= ' '\n+         loop\n+            Length := Length + 1;\n+         end loop;\n+\n+         if Length = Index + 1 then\n+            P := Parameter_None;\n+         else\n+            case Switches (Length - 1) is\n+               when ':'    =>\n+                  P      := Parameter_With_Optional_Space;\n+                  Length := Length - 1;\n+               when '='    =>\n+                  P      := Parameter_With_Space_Or_Equal;\n+                  Length := Length - 1;\n+               when '!'    =>\n+                  P      := Parameter_No_Space;\n+                  Length := Length - 1;\n+               when '?'    =>\n+                  P      := Parameter_Optional;\n+                  Length := Length - 1;\n+               when others =>\n+                  P      := Parameter_None;\n+            end case;\n+         end if;\n+\n+         --  If it is the one we searched, it may be a candidate\n+\n+         if Arg'First + Length - 1 - Index <= Arg'Last\n+           and then Switches (Index .. Length - 1) =\n+                      Arg (Arg'First .. Arg'First + Length - 1 - Index)\n+           and then Length - Index > Switch_Length\n+         then\n+            Param             := P;\n+            Index_In_Switches := Index;\n+            Switch_Length     := Length - Index;\n+         end if;\n+\n+         --  Look for the next switch in Switches\n+\n+         while Index <= Switches'Last\n+           and then Switches (Index) /= ' '\n+         loop\n+            Index := Index + 1;\n+         end loop;\n+\n+         Index := Index + 1;\n+      end loop;\n+   end Find_Longest_Matching_Switch;\n+\n    ------------\n    -- Getopt --\n    ------------\n \n    function Getopt\n      (Switches    : String;\n-      Concatenate : Boolean := True) return Character\n+      Concatenate : Boolean := True;\n+      Parser      : Opt_Parser := Command_Line_Parser) return Character\n    is\n       Dummy : Boolean;\n       pragma Unreferenced (Dummy);\n \n    begin\n+      <<Restart>>\n+\n       --  If we have finished parsing the current command line item (there\n       --  might be multiple switches in a single item), then go to the next\n       --  element\n \n-      if Current_Argument > CL.Argument_Count\n-        or else (Current_Index > CL.Argument (Current_Argument)'Last\n-                   and then not Goto_Next_Argument_In_Section)\n+      if Parser.Current_Argument > Parser.Arg_Count\n+        or else (Parser.Current_Index >\n+                   Argument (Parser, Parser.Current_Argument)'Last\n+                 and then not Goto_Next_Argument_In_Section (Parser))\n       then\n          return ASCII.NUL;\n       end if;\n \n-      --  If we are on a new item, test if this might be a switch\n-\n-      if Current_Index = 1 then\n-         if CL.Argument (Current_Argument)(1) /= Switch_Character then\n-            if Switches (Switches'First) = '*' then\n-               Set_Parameter (The_Switch,\n-                              Arg_Num => Current_Argument,\n-                              First   => 1,\n-                              Last    => CL.Argument (Current_Argument)'Last);\n-               Is_Switch (Current_Argument) := True;\n-               Dummy := Goto_Next_Argument_In_Section;\n-               return '*';\n-            end if;\n-\n-            if Stop_At_First then\n-               Current_Argument := Positive'Last;\n-               return ASCII.NUL;\n-\n-            elsif not Goto_Next_Argument_In_Section then\n-               return ASCII.NUL;\n+      --  By default, the switch will not have a parameter\n \n-            else\n-               return Getopt (Switches);\n-            end if;\n-         end if;\n-\n-         Current_Index := 2;\n-         Is_Switch (Current_Argument) := True;\n-      end if;\n+      Parser.The_Parameter :=\n+        (Integer'Last, Integer'Last, Integer'Last - 1, ASCII.NUL);\n+      Parser.The_Separator := ASCII.NUL;\n \n       declare\n-         Arg            : constant String := CL.Argument (Current_Argument);\n+         Arg            : constant String :=\n+                            Argument (Parser, Parser.Current_Argument);\n          Index_Switches : Natural := 0;\n          Max_Length     : Natural := 0;\n-         Index          : Natural;\n-         Length         : Natural := 1;\n          End_Index      : Natural;\n-\n+         Param          : Switch_Parameter_Type;\n       begin\n-         --  Remove all leading spaces first to make sure that Index points\n-         --  at the start of the first switch.\n-\n-         Index := Switches'First;\n-         while Index <= Switches'Last and then Switches (Index) = ' ' loop\n-            Index := Index + 1;\n-         end loop;\n+         --  If we are on a new item, test if this might be a switch\n+\n+         if Parser.Current_Index = Arg'First then\n+            if Arg (Arg'First) /= Parser.Switch_Character then\n+\n+               --  If it isn't a switch, return it immediately. We also know it\n+               --  isn't the parameter to a previous switch, since that has\n+               --  already been handled\n+\n+               if Switches (Switches'First) = '*' then\n+                  Set_Parameter\n+                    (Parser.The_Switch,\n+                     Arg_Num => Parser.Current_Argument,\n+                     First   => Arg'First,\n+                     Last    => Arg'Last);\n+                  Parser.Is_Switch (Parser.Current_Argument) := True;\n+                  Dummy := Goto_Next_Argument_In_Section (Parser);\n+                  return '*';\n+               end if;\n \n-         while Index <= Switches'Last loop\n+               if Parser.Stop_At_First then\n+                  Parser.Current_Argument := Positive'Last;\n+                  return ASCII.NUL;\n \n-            --  Search the length of the parameter at this position in Switches\n+               elsif not Goto_Next_Argument_In_Section (Parser) then\n+                  return ASCII.NUL;\n \n-            Length := Index;\n-            while Length <= Switches'Last\n-              and then Switches (Length) /= ' '\n-            loop\n-               Length := Length + 1;\n-            end loop;\n+               else\n+                  --  Recurse to get the next switch on the command line\n \n-            if (Switches (Length - 1) = ':'  or else\n-                Switches (Length - 1) = '='  or else\n-                Switches (Length - 1) = '?'  or else\n-                Switches (Length - 1) = '!')\n-              and then Length > Index + 1\n-            then\n-               Length := Length - 1;\n-            end if;\n-\n-            --  If it is the one we searched, it may be a candidate\n-\n-            if Current_Index + Length - 1 - Index <= Arg'Last\n-              and then\n-                Switches (Index .. Length - 1) =\n-                  Arg (Current_Index .. Current_Index + Length - 1 - Index)\n-              and then Length - Index > Max_Length\n-            then\n-               Index_Switches := Index;\n-               Max_Length     := Length - Index;\n+                  goto Restart;\n+               end if;\n             end if;\n \n-            --  Look for the next switch in Switches\n-\n-            while Index <= Switches'Last\n-              and then Switches (Index) /= ' ' loop\n-               Index := Index + 1;\n-            end loop;\n+            --  We are on the first character of a new command line argument,\n+            --  which starts with Switch_Character. Further analysis is needed.\n \n-            Index := Index + 1;\n-         end loop;\n+            Parser.Current_Index := Parser.Current_Index + 1;\n+            Parser.Is_Switch (Parser.Current_Argument) := True;\n+         end if;\n \n-         End_Index := Current_Index + Max_Length - 1;\n+         Find_Longest_Matching_Switch\n+           (Switches          => Switches,\n+            Arg               => Arg (Parser.Current_Index .. Arg'Last),\n+            Index_In_Switches => Index_Switches,\n+            Switch_Length     => Max_Length,\n+            Param             => Param);\n \n-         --  If switch is not accepted, skip it, unless we had '*' in Switches\n+         --  If switch is not accepted, it is either invalid or is returned\n+         --  in the context of '*'.\n \n          if Index_Switches = 0 then\n-            if Switches (Switches'First) = '*' then\n-               Set_Parameter (The_Switch,\n-                              Arg_Num => Current_Argument,\n-                              First   => 1,\n-                              Last    => CL.Argument (Current_Argument)'Last);\n-               Is_Switch (Current_Argument) := True;\n-               Dummy := Goto_Next_Argument_In_Section;\n-               return '*';\n-            end if;\n \n             --  Depending on the value of Concatenate, the full switch is\n-            --  a single character (True) or the rest of the argument (False).\n+            --  a single character or the rest of the argument.\n \n             if Concatenate then\n-               End_Index := Current_Index;\n+               End_Index := Parser.Current_Index;\n             else\n                End_Index := Arg'Last;\n             end if;\n \n-            Set_Parameter (The_Switch,\n-                           Arg_Num => Current_Argument,\n-                           First   => Current_Index,\n-                           Last    => End_Index);\n-            Current_Index := End_Index + 1;\n-            raise Invalid_Switch;\n-         end if;\n+            if Switches (Switches'First) = '*' then\n \n-         Set_Parameter (The_Switch,\n-                        Arg_Num => Current_Argument,\n-                        First   => Current_Index,\n-                        Last    => End_Index);\n+               --  Always prepend the switch character, so that users know that\n+               --  this comes from a switch on the command line. This is\n+               --  especially important when Concatenate is False, since\n+               --  otherwise the currrent argument first character is lost.\n \n-         --  Case of switch needs an argument\n+               Set_Parameter\n+                 (Parser.The_Switch,\n+                  Arg_Num => Parser.Current_Argument,\n+                  First   => Parser.Current_Index,\n+                  Last    => Arg'Last,\n+                  Extra   => Parser.Switch_Character);\n+               Parser.Is_Switch (Parser.Current_Argument) := True;\n+               Dummy := Goto_Next_Argument_In_Section (Parser);\n+               return '*';\n+            end if;\n \n-         if Index_Switches + Max_Length <= Switches'Last then\n+            Set_Parameter\n+              (Parser.The_Switch,\n+               Arg_Num => Parser.Current_Argument,\n+               First   => Parser.Current_Index,\n+               Last    => End_Index);\n+            Parser.Current_Index := End_Index + 1;\n+            raise Invalid_Switch;\n+         end if;\n \n-            case Switches (Index_Switches + Max_Length) is\n+         End_Index := Parser.Current_Index + Max_Length - 1;\n+         Set_Parameter\n+           (Parser.The_Switch,\n+            Arg_Num => Parser.Current_Argument,\n+            First   => Parser.Current_Index,\n+            Last    => End_Index);\n+\n+         case Param is\n+            when Parameter_With_Optional_Space =>\n+               if End_Index < Arg'Last then\n+                  Set_Parameter\n+                    (Parser.The_Parameter,\n+                     Arg_Num => Parser.Current_Argument,\n+                     First   => End_Index + 1,\n+                     Last    => Arg'Last);\n+                  Dummy := Goto_Next_Argument_In_Section (Parser);\n+\n+               elsif Parser.Current_Argument < Parser.Arg_Count\n+                 and then Parser.Section (Parser.Current_Argument + 1) /= 0\n+               then\n+                  Parser.Current_Argument := Parser.Current_Argument + 1;\n+                  Parser.The_Separator := ' ';\n+                  Set_Parameter\n+                    (Parser.The_Parameter,\n+                     Arg_Num => Parser.Current_Argument,\n+                     First => Argument (Parser, Parser.Current_Argument)'First,\n+                     Last  => Argument (Parser, Parser.Current_Argument)'Last);\n+                  Parser.Is_Switch (Parser.Current_Argument) := True;\n+                  Dummy := Goto_Next_Argument_In_Section (Parser);\n+\n+               else\n+                  Parser.Current_Index := End_Index + 1;\n+                  raise Invalid_Parameter;\n+               end if;\n \n-               when ':' =>\n+            when Parameter_With_Space_Or_Equal =>\n \n-                  if End_Index < Arg'Last then\n-                     Set_Parameter (The_Parameter,\n-                                    Arg_Num => Current_Argument,\n-                                    First   => End_Index + 1,\n-                                    Last    => Arg'Last);\n-                     Dummy := Goto_Next_Argument_In_Section;\n+               --  If the switch is of the form <switch>=xxx\n \n-                  elsif Section (Current_Argument + 1) /= 0 then\n-                     Set_Parameter\n-                       (The_Parameter,\n-                        Arg_Num => Current_Argument + 1,\n-                        First   => 1,\n-                        Last    => CL.Argument (Current_Argument + 1)'Last);\n-                     Current_Argument := Current_Argument + 1;\n-                     Is_Switch (Current_Argument) := True;\n-                     Dummy := Goto_Next_Argument_In_Section;\n+               if End_Index < Arg'Last then\n \n+                  if Arg (End_Index + 1) = '='\n+                    and then End_Index + 1 < Arg'Last\n+                  then\n+                     Parser.The_Separator := '=';\n+                     Set_Parameter\n+                       (Parser.The_Parameter,\n+                        Arg_Num => Parser.Current_Argument,\n+                        First   => End_Index + 2,\n+                        Last    => Arg'Last);\n+                     Dummy := Goto_Next_Argument_In_Section (Parser);\n                   else\n-                     Current_Index := End_Index + 1;\n+                     Parser.Current_Index := End_Index + 1;\n                      raise Invalid_Parameter;\n                   end if;\n \n-               when '=' =>\n-\n-                  --  If the switch is of the form <switch>=xxx\n-\n-                  if End_Index < Arg'Last then\n-\n-                     if Arg (End_Index + 1) = '='\n-                       and then End_Index + 1 < Arg'Last\n-                     then\n-                        Set_Parameter (The_Parameter,\n-                                       Arg_Num => Current_Argument,\n-                                       First   => End_Index + 2,\n-                                       Last    => Arg'Last);\n-                        Dummy := Goto_Next_Argument_In_Section;\n-\n-                     else\n-                        Current_Index := End_Index + 1;\n-                        raise Invalid_Parameter;\n-                     end if;\n+               --  If the switch is of the form <switch> xxx\n \n-                  --  If the switch is of the form <switch> xxx\n+               elsif Parser.Current_Argument < Parser.Arg_Count\n+                 and then Parser.Section (Parser.Current_Argument + 1) /= 0\n+               then\n+                  Parser.Current_Argument := Parser.Current_Argument + 1;\n+                  Parser.The_Separator := ' ';\n+                  Set_Parameter\n+                    (Parser.The_Parameter,\n+                     Arg_Num => Parser.Current_Argument,\n+                     First => Argument (Parser, Parser.Current_Argument)'First,\n+                     Last  => Argument (Parser, Parser.Current_Argument)'Last);\n+                  Parser.Is_Switch (Parser.Current_Argument) := True;\n+                  Dummy := Goto_Next_Argument_In_Section (Parser);\n+\n+               else\n+                  Parser.Current_Index := End_Index + 1;\n+                  raise Invalid_Parameter;\n+               end if;\n \n-                  elsif Section (Current_Argument + 1) /= 0 then\n-                     Set_Parameter\n-                       (The_Parameter,\n-                        Arg_Num => Current_Argument + 1,\n-                        First   => 1,\n-                        Last    => CL.Argument (Current_Argument + 1)'Last);\n-                     Current_Argument := Current_Argument + 1;\n-                     Is_Switch (Current_Argument) := True;\n-                     Dummy := Goto_Next_Argument_In_Section;\n+            when Parameter_No_Space =>\n \n-                  else\n-                     Current_Index := End_Index + 1;\n-                     raise Invalid_Parameter;\n-                  end if;\n+               if End_Index < Arg'Last then\n+                  Set_Parameter\n+                    (Parser.The_Parameter,\n+                     Arg_Num => Parser.Current_Argument,\n+                     First   => End_Index + 1,\n+                     Last    => Arg'Last);\n+                  Dummy := Goto_Next_Argument_In_Section (Parser);\n \n-               when '!' =>\n+               else\n+                  Parser.Current_Index := End_Index + 1;\n+                  raise Invalid_Parameter;\n+               end if;\n \n-                  if End_Index < Arg'Last then\n-                     Set_Parameter (The_Parameter,\n-                                    Arg_Num => Current_Argument,\n-                                    First   => End_Index + 1,\n-                                    Last    => Arg'Last);\n-                     Dummy := Goto_Next_Argument_In_Section;\n+            when Parameter_Optional =>\n \n-                  else\n-                     Current_Index := End_Index + 1;\n-                     raise Invalid_Parameter;\n-                  end if;\n+               if End_Index < Arg'Last then\n+                  Set_Parameter\n+                    (Parser.The_Parameter,\n+                     Arg_Num => Parser.Current_Argument,\n+                     First   => End_Index + 1,\n+                     Last    => Arg'Last);\n+               end if;\n \n-               when '?' =>\n+               Dummy := Goto_Next_Argument_In_Section (Parser);\n \n-                  if End_Index < Arg'Last then\n-                     Set_Parameter (The_Parameter,\n-                                    Arg_Num => Current_Argument,\n-                                    First   => End_Index + 1,\n-                                    Last    => Arg'Last);\n+            when Parameter_None =>\n \n-                  else\n-                     Set_Parameter (The_Parameter,\n-                                    Arg_Num => Current_Argument,\n-                                    First   => 2,\n-                                    Last    => 1);\n-                  end if;\n-                  Dummy := Goto_Next_Argument_In_Section;\n+               if Concatenate or else End_Index = Arg'Last then\n+                  Parser.Current_Index := End_Index + 1;\n \n-               when others =>\n-                  if Concatenate or else End_Index = Arg'Last then\n-                     Current_Index := End_Index + 1;\n+               else\n+                  --  If Concatenate is False and the full argument is not\n+                  --  recognized as a switch, this is an invalid switch.\n \n-                  else\n-                     --  If Concatenate is False and the full argument is not\n-                     --  recognized as a switch, this is an invalid switch.\n-\n-                     if Switches (Switches'First) = '*' then\n-                        Set_Parameter\n-                           (The_Switch,\n-                            Arg_Num => Current_Argument,\n-                            First   => 1,\n-                            Last    => CL.Argument (Current_Argument)'Last);\n-                        Is_Switch (Current_Argument) := True;\n-                        Dummy := Goto_Next_Argument_In_Section;\n-                        return '*';\n-                     end if;\n-\n-                     Set_Parameter (The_Switch,\n-                                    Arg_Num => Current_Argument,\n-                                    First   => Current_Index,\n-                                    Last    => Arg'Last);\n-                     Current_Index := Arg'Last + 1;\n-                     raise Invalid_Switch;\n+                  if Switches (Switches'First) = '*' then\n+                     Set_Parameter\n+                       (Parser.The_Switch,\n+                        Arg_Num => Parser.Current_Argument,\n+                        First   => Arg'First,\n+                        Last    => Arg'Last);\n+                     Parser.Is_Switch (Parser.Current_Argument) := True;\n+                     Dummy := Goto_Next_Argument_In_Section (Parser);\n+                     return '*';\n                   end if;\n-            end case;\n-\n-         elsif Concatenate or else End_Index = Arg'Last then\n-            Current_Index := End_Index + 1;\n \n-         else\n-            --  If Concatenate is False and the full argument is not\n-            --  recognized as a switch, this is an invalid switch.\n-\n-            if Switches (Switches'First) = '*' then\n-               Set_Parameter\n-                  (The_Switch,\n-                   Arg_Num => Current_Argument,\n-                   First   => 1,\n-                   Last    => CL.Argument (Current_Argument)'Last);\n-               Is_Switch (Current_Argument) := True;\n-               Dummy := Goto_Next_Argument_In_Section;\n-               return '*';\n-            end if;\n-\n-            Set_Parameter (The_Switch,\n-                           Arg_Num => Current_Argument,\n-                           First   => Current_Index,\n-                           Last    => Arg'Last);\n-            Current_Index := Arg'Last + 1;\n-            raise Invalid_Switch;\n-         end if;\n+                  Set_Parameter\n+                    (Parser.The_Switch,\n+                     Arg_Num => Parser.Current_Argument,\n+                     First   => Parser.Current_Index,\n+                     Last    => Arg'Last);\n+                  Parser.Current_Index := Arg'Last + 1;\n+                  raise Invalid_Switch;\n+               end if;\n+         end case;\n \n          return Switches (Index_Switches);\n       end;\n@@ -635,60 +730,74 @@ package body GNAT.Command_Line is\n    -- Goto_Next_Argument_In_Section --\n    -----------------------------------\n \n-   function Goto_Next_Argument_In_Section return Boolean is\n+   function Goto_Next_Argument_In_Section\n+     (Parser : Opt_Parser) return Boolean\n+   is\n    begin\n-      Current_Index := 1;\n-      Current_Argument := Current_Argument + 1;\n+      Parser.Current_Argument := Parser.Current_Argument + 1;\n \n-      if Section (Current_Argument) = 0 then\n+      if Parser.Current_Argument > Parser.Arg_Count\n+        or else Parser.Section (Parser.Current_Argument) = 0\n+      then\n          loop\n-            if Current_Argument > CL.Argument_Count then\n+            Parser.Current_Argument := Parser.Current_Argument + 1;\n+\n+            if Parser.Current_Argument > Parser.Arg_Count then\n+               Parser.Current_Index := 1;\n                return False;\n             end if;\n \n-            Current_Argument := Current_Argument + 1;\n-            exit when Section (Current_Argument) = Current_Section;\n+            exit when Parser.Section (Parser.Current_Argument) =\n+                                                  Parser.Current_Section;\n          end loop;\n       end if;\n+\n+      Parser.Current_Index :=\n+        Argument (Parser, Parser.Current_Argument)'First;\n+\n       return True;\n    end Goto_Next_Argument_In_Section;\n \n    ------------------\n    -- Goto_Section --\n    ------------------\n \n-   procedure Goto_Section (Name : String := \"\") is\n-      Index : Integer := 1;\n+   procedure Goto_Section\n+     (Name   : String := \"\";\n+      Parser : Opt_Parser := Command_Line_Parser)\n+   is\n+      Index : Integer;\n \n    begin\n-      In_Expansion := False;\n+      Parser.In_Expansion := False;\n \n       if Name = \"\" then\n-         Current_Argument := 1;\n-         Current_Index    := 1;\n-         Current_Section  := 1;\n+         Parser.Current_Argument := 1;\n+         Parser.Current_Index    := 1;\n+         Parser.Current_Section  := 1;\n          return;\n       end if;\n \n-      while Index <= CL.Argument_Count loop\n-\n-         if Section (Index) = 0\n-           and then CL.Argument (Index) = Switch_Character & Name\n+      Index := 1;\n+      while Index <= Parser.Arg_Count loop\n+         if Parser.Section (Index) = 0\n+           and then Argument (Parser, Index) = Parser.Switch_Character & Name\n          then\n-            Current_Argument := Index + 1;\n-            Current_Index    := 1;\n+            Parser.Current_Argument := Index + 1;\n+            Parser.Current_Index    := 1;\n \n-            if Current_Argument <= CL.Argument_Count then\n-               Current_Section := Section (Current_Argument);\n+            if Parser.Current_Argument <= Parser.Arg_Count then\n+               Parser.Current_Section :=\n+                 Parser.Section (Parser.Current_Argument);\n             end if;\n             return;\n          end if;\n \n          Index := Index + 1;\n       end loop;\n \n-      Current_Argument := Positive'Last;\n-      Current_Index := 2;   --  so that Get_Argument returns nothing\n+      Parser.Current_Argument := Positive'Last;\n+      Parser.Current_Index := 2;   --  so that Get_Argument returns nothing\n    end Goto_Section;\n \n    ----------------------------\n@@ -697,30 +806,80 @@ package body GNAT.Command_Line is\n \n    procedure Initialize_Option_Scan\n      (Switch_Char              : Character := '-';\n+      Stop_At_First_Non_Switch : Boolean   := False;\n+      Section_Delimiters       : String    := \"\")\n+   is\n+   begin\n+      Internal_Initialize_Option_Scan\n+        (Parser                   => Command_Line_Parser,\n+         Switch_Char              => Switch_Char,\n+         Stop_At_First_Non_Switch => Stop_At_First_Non_Switch,\n+         Section_Delimiters       => Section_Delimiters);\n+   end Initialize_Option_Scan;\n+\n+   ----------------------------\n+   -- Initialize_Option_Scan --\n+   ----------------------------\n+\n+   procedure Initialize_Option_Scan\n+     (Parser                   : out Opt_Parser;\n+      Command_Line             : GNAT.OS_Lib.Argument_List_Access;\n+      Switch_Char              : Character := '-';\n       Stop_At_First_Non_Switch : Boolean := False;\n       Section_Delimiters       : String := \"\")\n    is\n-      Section_Num     : Section_Number := 1;\n-      Section_Index   : Integer        := Section_Delimiters'First;\n+   begin\n+      Free (Parser);\n+\n+      if Command_Line = null then\n+         Parser := new Opt_Parser_Data (CL.Argument_Count);\n+         Initialize_Option_Scan\n+           (Switch_Char              => Switch_Char,\n+            Stop_At_First_Non_Switch => Stop_At_First_Non_Switch,\n+            Section_Delimiters       => Section_Delimiters);\n+      else\n+         Parser := new Opt_Parser_Data (Command_Line'Length);\n+         Parser.Arguments := Command_Line;\n+         Internal_Initialize_Option_Scan\n+           (Parser                   => Parser,\n+            Switch_Char              => Switch_Char,\n+            Stop_At_First_Non_Switch => Stop_At_First_Non_Switch,\n+            Section_Delimiters       => Section_Delimiters);\n+      end if;\n+   end Initialize_Option_Scan;\n+\n+   -------------------------------------\n+   -- Internal_Initialize_Option_Scan --\n+   -------------------------------------\n+\n+   procedure Internal_Initialize_Option_Scan\n+     (Parser                   : Opt_Parser;\n+      Switch_Char              : Character;\n+      Stop_At_First_Non_Switch : Boolean;\n+      Section_Delimiters       : String)\n+   is\n+      Section_Num     : Section_Number;\n+      Section_Index   : Integer;\n       Last            : Integer;\n       Delimiter_Found : Boolean;\n \n       Discard : Boolean;\n       pragma Warnings (Off, Discard);\n \n    begin\n-      Current_Argument := 0;\n-      Current_Index := 0;\n-      In_Expansion := False;\n-      Switch_Character := Switch_Char;\n-      Stop_At_First := Stop_At_First_Non_Switch;\n+      Parser.Current_Argument := 0;\n+      Parser.Current_Index    := 0;\n+      Parser.In_Expansion     := False;\n+      Parser.Switch_Character := Switch_Char;\n+      Parser.Stop_At_First    := Stop_At_First_Non_Switch;\n \n       --  If we are using sections, we have to preprocess the command line\n       --  to delimit them. A section can be repeated, so we just give each\n       --  item on the command line a section number\n \n+      Section_Num   := 1;\n+      Section_Index := Section_Delimiters'First;\n       while Section_Index <= Section_Delimiters'Last loop\n-\n          Last := Section_Index;\n          while Last <= Section_Delimiters'Last\n            and then Section_Delimiters (Last) /= ' '\n@@ -731,21 +890,21 @@ package body GNAT.Command_Line is\n          Delimiter_Found := False;\n          Section_Num := Section_Num + 1;\n \n-         for Index in 1 .. CL.Argument_Count loop\n-            if CL.Argument (Index)(1) = Switch_Character\n+         for Index in 1 .. Parser.Arg_Count loop\n+            if Argument (Parser, Index)(1) = Parser.Switch_Character\n               and then\n-                CL.Argument (Index) = Switch_Character &\n+                Argument (Parser, Index) = Parser.Switch_Character &\n                                         Section_Delimiters\n                                           (Section_Index .. Last - 1)\n             then\n-               Section (Index) := 0;\n+               Parser.Section (Index) := 0;\n                Delimiter_Found := True;\n \n-            elsif Section (Index) = 0 then\n+            elsif Parser.Section (Index) = 0 then\n                Delimiter_Found := False;\n \n             elsif Delimiter_Found then\n-               Section (Index) := Section_Num;\n+               Parser.Section (Index) := Section_Num;\n             end if;\n          end loop;\n \n@@ -757,23 +916,36 @@ package body GNAT.Command_Line is\n          end loop;\n       end loop;\n \n-      Discard := Goto_Next_Argument_In_Section;\n-   end Initialize_Option_Scan;\n+      Discard := Goto_Next_Argument_In_Section (Parser);\n+   end Internal_Initialize_Option_Scan;\n \n    ---------------\n    -- Parameter --\n    ---------------\n \n-   function Parameter return String is\n+   function Parameter\n+     (Parser : Opt_Parser := Command_Line_Parser) return String\n+   is\n    begin\n-      if The_Parameter.First > The_Parameter.Last then\n+      if Parser.The_Parameter.First > Parser.The_Parameter.Last then\n          return String'(1 .. 0 => ' ');\n       else\n-         return CL.Argument (The_Parameter.Arg_Num)\n-           (The_Parameter.First .. The_Parameter.Last);\n+         return Argument (Parser, Parser.The_Parameter.Arg_Num)\n+           (Parser.The_Parameter.First .. Parser.The_Parameter.Last);\n       end if;\n    end Parameter;\n \n+   ---------------\n+   -- Separator --\n+   ---------------\n+\n+   function Separator\n+     (Parser : Opt_Parser := Command_Line_Parser) return Character\n+   is\n+   begin\n+      return Parser.The_Separator;\n+   end Separator;\n+\n    -------------------\n    -- Set_Parameter --\n    -------------------\n@@ -782,12 +954,14 @@ package body GNAT.Command_Line is\n      (Variable : out Parameter_Type;\n       Arg_Num  : Positive;\n       First    : Positive;\n-      Last     : Positive)\n+      Last     : Positive;\n+      Extra    : Character := ASCII.NUL)\n    is\n    begin\n       Variable.Arg_Num := Arg_Num;\n       Variable.First   := First;\n       Variable.Last    := Last;\n+      Variable.Extra   := Extra;\n    end Set_Parameter;\n \n    ---------------------\n@@ -862,6 +1036,718 @@ package body GNAT.Command_Line is\n       end loop;\n    end Start_Expansion;\n \n-begin\n-   Section (CL.Argument_Count + 1) := 0;\n+   ----------\n+   -- Free --\n+   ----------\n+\n+   procedure Free (Parser : in out Opt_Parser) is\n+      procedure Unchecked_Free is new Ada.Unchecked_Deallocation\n+        (Opt_Parser_Data, Opt_Parser);\n+   begin\n+      if Parser /= null\n+        and then Parser /= Command_Line_Parser\n+      then\n+         Free (Parser.Arguments);\n+         Unchecked_Free (Parser);\n+      end if;\n+   end Free;\n+\n+   ------------------------\n+   -- Args_From_Expanded --\n+   ------------------------\n+\n+   function Args_From_Expanded (Args : Boolean_Chars) return String is\n+      Result : String (1 .. Args'Length);\n+      Index  : Natural := Result'First;\n+\n+   begin\n+      for A in Args'Range loop\n+         if Args (A) then\n+            Result (Index) := A;\n+            Index := Index + 1;\n+         end if;\n+      end loop;\n+\n+      return Result (1 .. Index - 1);\n+   end Args_From_Expanded;\n+\n+   ------------------\n+   -- Define_Alias --\n+   ------------------\n+\n+   procedure Define_Alias\n+     (Config   : in out Command_Line_Configuration;\n+      Switch   : String;\n+      Expanded : String)\n+   is\n+   begin\n+      if Config = null then\n+         Config := new Command_Line_Configuration_Record;\n+      end if;\n+\n+      Append (Config.Aliases,    new String'(Switch));\n+      Append (Config.Expansions, new String'(Expanded));\n+   end Define_Alias;\n+\n+   -------------------\n+   -- Define_Prefix --\n+   -------------------\n+\n+   procedure Define_Prefix\n+     (Config : in out Command_Line_Configuration;\n+      Prefix : String)\n+   is\n+   begin\n+      if Config = null then\n+         Config := new Command_Line_Configuration_Record;\n+      end if;\n+\n+      Append (Config.Prefixes, new String'(Prefix));\n+   end Define_Prefix;\n+\n+   -----------------------\n+   -- Set_Configuration --\n+   -----------------------\n+\n+   procedure Set_Configuration\n+     (Cmd      : in out Command_Line;\n+      Config   : Command_Line_Configuration)\n+   is\n+   begin\n+      Cmd.Config := Config;\n+   end Set_Configuration;\n+\n+   ----------------------\n+   -- Set_Command_Line --\n+   ----------------------\n+\n+   procedure Set_Command_Line\n+     (Cmd                : in out Command_Line;\n+      Switches           : String;\n+      Getopt_Description : String := \"\";\n+      Switch_Char        : Character := '-')\n+   is\n+      Tmp    : Argument_List_Access;\n+      Parser : Opt_Parser;\n+      S      : Character;\n+\n+   begin\n+      Free (Cmd.Expanded);\n+      Free (Cmd.Params);\n+\n+      if Switches /= \"\" then\n+         Tmp := Argument_String_To_List (Switches);\n+         Initialize_Option_Scan (Parser, Tmp, Switch_Char);\n+\n+         loop\n+            begin\n+               S := Getopt (Switches    => \"* \" & Getopt_Description,\n+                            Concatenate => False,\n+                            Parser      => Parser);\n+               exit when S = ASCII.NUL;\n+\n+               if S = '*' then\n+                  Add_Switch (Cmd, Full_Switch (Parser), Parameter (Parser),\n+                              Separator (Parser));\n+               else\n+                  Add_Switch\n+                    (Cmd, Switch_Char & Full_Switch (Parser),\n+                     Parameter (Parser), Separator (Parser));\n+               end if;\n+\n+            exception\n+               when Invalid_Parameter =>\n+                  --  Add it with no parameter, if that's the way the user\n+                  --  wants it\n+                  Add_Switch (Cmd, Switch_Char & Full_Switch (Parser));\n+            end;\n+         end loop;\n+\n+         Free (Parser);\n+      end if;\n+   end Set_Command_Line;\n+\n+   ----------------\n+   -- Looking_At --\n+   ----------------\n+\n+   function Looking_At\n+     (Type_Str  : String;\n+      Index     : Natural;\n+      Substring : String) return Boolean is\n+   begin\n+      return Index + Substring'Length - 1 <= Type_Str'Last\n+        and then Type_Str (Index .. Index + Substring'Length - 1) = Substring;\n+   end Looking_At;\n+\n+   ----------------------------\n+   -- For_Each_Simple_Switch --\n+   ----------------------------\n+\n+   procedure For_Each_Simple_Switch\n+     (Cmd      : Command_Line;\n+      Switch   : String;\n+      Callback : Callback_Procedure)\n+   is\n+   begin\n+      --  Are we adding a switch that can in fact be expanded through aliases ?\n+      --  If yes, we add separately each of its expansion.\n+\n+      --  This takes care of expansions like \"-T\" -> \"-gnatwrs\", where the\n+      --  alias and its expansion do not have the same prefix. Given the order\n+      --  in which we do things here, the expansion of the alias will itself\n+      --  be checked for a common prefix and further split into simple switches\n+\n+      if Cmd.Config /= null\n+        and then Cmd.Config.Aliases /= null\n+      then\n+         for A in Cmd.Config.Aliases'Range loop\n+            if Cmd.Config.Aliases (A).all = Switch then\n+               For_Each_Simple_Switch\n+                 (Cmd, Cmd.Config.Expansions (A).all, Callback);\n+               return;\n+            end if;\n+         end loop;\n+      end if;\n+\n+      --  Are we adding a switch grouping several switches ? If yes, add each\n+      --  of the simple switches instead.\n+\n+      if Cmd.Config /= null\n+        and then Cmd.Config.Prefixes /= null\n+      then\n+         for P in Cmd.Config.Prefixes'Range loop\n+            if Switch'Length > Cmd.Config.Prefixes (P)'Length + 1\n+              and then Looking_At\n+                (Switch, Switch'First, Cmd.Config.Prefixes (P).all)\n+            then\n+               --  Alias expansion will be done recursively\n+\n+               for S in Switch'First + Cmd.Config.Prefixes (P)'Length\n+                          .. Switch'Last\n+               loop\n+                  For_Each_Simple_Switch\n+                    (Cmd, Cmd.Config.Prefixes (P).all & Switch (S), Callback);\n+               end loop;\n+               return;\n+            end if;\n+         end loop;\n+      end if;\n+\n+      Callback (Switch);\n+   end For_Each_Simple_Switch;\n+\n+   ----------------\n+   -- Add_Switch --\n+   ----------------\n+\n+   procedure Add_Switch\n+     (Cmd       : in out Command_Line;\n+      Switch    : String;\n+      Parameter : String := \"\";\n+      Separator : Character := ' ')\n+   is\n+      procedure Add_Simple_Switch (Simple : String);\n+      --  Add a new switch that has had all its aliases expanded, and switches\n+      --  ungrouped. We know there is no more aliases in Switches\n+\n+      -----------------------\n+      -- Add_Simple_Switch --\n+      -----------------------\n+\n+      procedure Add_Simple_Switch (Simple : String) is\n+      begin\n+         if Cmd.Expanded = null then\n+            Cmd.Expanded := new Argument_List'(1 .. 1 => new String'(Simple));\n+            if Parameter = \"\" then\n+               Cmd.Params := new Argument_List'(1 .. 1 => null);\n+            else\n+               Cmd.Params := new Argument_List'\n+                 (1 .. 1 => new String'(Separator & Parameter));\n+            end if;\n+\n+         else\n+            --  Do we already have this switch ?\n+\n+            for C in Cmd.Expanded'Range loop\n+               if Cmd.Expanded (C).all = Simple\n+                 and then\n+                   ((Cmd.Params (C) = null and then Parameter = \"\")\n+                    or else\n+                      (Cmd.Params (C) /= null\n+                       and then Cmd.Params (C).all = Separator & Parameter))\n+               then\n+                  return;\n+               end if;\n+            end loop;\n+\n+            Append (Cmd.Expanded, new String'(Simple));\n+\n+            if Parameter = \"\" then\n+               Append (Cmd.Params, null);\n+            else\n+               Append (Cmd.Params, new String'(Separator & Parameter));\n+            end if;\n+         end if;\n+      end Add_Simple_Switch;\n+\n+   --  Start of processing for Add_Switch\n+\n+   begin\n+      For_Each_Simple_Switch\n+        (Cmd, Switch, Add_Simple_Switch'Unrestricted_Access);\n+      Free (Cmd.Coalesce);\n+   end Add_Switch;\n+\n+   ------------\n+   -- Remove --\n+   ------------\n+\n+   procedure Remove (Line : in out Argument_List_Access; Index : Integer) is\n+      Tmp : Argument_List_Access := Line;\n+\n+   begin\n+      Line := new Argument_List (Tmp'First .. Tmp'Last - 1);\n+\n+      if Index /= Tmp'First then\n+         Line (Tmp'First .. Index - 1) := Tmp (Tmp'First .. Index - 1);\n+      end if;\n+\n+      Free (Tmp (Index));\n+\n+      if Index /= Tmp'Last then\n+         Line (Index .. Tmp'Last - 1) := Tmp (Index + 1 .. Tmp'Last);\n+      end if;\n+\n+      Unchecked_Free (Tmp);\n+   end Remove;\n+\n+   ------------\n+   -- Append --\n+   ------------\n+\n+   procedure Append\n+     (Line : in out Argument_List_Access;\n+      Str  : String_Access)\n+   is\n+      Tmp : Argument_List_Access := Line;\n+   begin\n+      if Tmp /= null then\n+         Line := new Argument_List (Tmp'First .. Tmp'Last + 1);\n+         Line (Tmp'Range) := Tmp.all;\n+         Unchecked_Free (Tmp);\n+      else\n+         Line := new Argument_List (1 .. 1);\n+      end if;\n+\n+      Line (Line'Last) := Str;\n+   end Append;\n+\n+   -------------------\n+   -- Remove_Switch --\n+   -------------------\n+\n+   procedure Remove_Switch\n+     (Cmd        : in out Command_Line;\n+      Switch     : String;\n+      Remove_All : Boolean := False)\n+   is\n+      procedure Remove_Simple_Switch (Simple : String);\n+      --  Removes a simple switch, with no aliasing or grouping\n+\n+      --------------------------\n+      -- Remove_Simple_Switch --\n+      --------------------------\n+\n+      procedure Remove_Simple_Switch (Simple : String) is\n+         C : Integer;\n+\n+      begin\n+         if Cmd.Expanded /= null then\n+            C := Cmd.Expanded'First;\n+            while C <= Cmd.Expanded'Last loop\n+               if Cmd.Expanded (C).all = Simple then\n+                  Remove (Cmd.Expanded, C);\n+                  Remove (Cmd.Params, C);\n+\n+                  if not Remove_All then\n+                     return;\n+                  end if;\n+\n+               else\n+                  C := C + 1;\n+               end if;\n+            end loop;\n+         end if;\n+      end Remove_Simple_Switch;\n+\n+   --  Start of processing for Remove_Switch\n+\n+   begin\n+      For_Each_Simple_Switch\n+        (Cmd, Switch, Remove_Simple_Switch'Unrestricted_Access);\n+      Free (Cmd.Coalesce);\n+   end Remove_Switch;\n+\n+   -------------------\n+   -- Remove_Switch --\n+   -------------------\n+\n+   procedure Remove_Switch\n+     (Cmd       : in out Command_Line;\n+      Switch    : String;\n+      Parameter : String)\n+   is\n+      procedure Remove_Simple_Switch (Simple : String);\n+      --  Removes a simple switch, with no aliasing or grouping\n+\n+      --------------------------\n+      -- Remove_Simple_Switch --\n+      --------------------------\n+\n+      procedure Remove_Simple_Switch (Simple : String) is\n+         C : Integer;\n+\n+      begin\n+         if Cmd.Expanded /= null then\n+            C := Cmd.Expanded'First;\n+            while C <= Cmd.Expanded'Last loop\n+               if Cmd.Expanded (C).all = Simple\n+                 and then\n+                   ((Cmd.Params (C) = null and then Parameter = \"\")\n+                      or else\n+                        (Cmd.Params (C) /= null\n+                           and then\n+\n+                           --  Ignore the separator stored in Parameter\n+\n+                             Cmd.Params (C) (Cmd.Params (C)'First + 1\n+                                             .. Cmd.Params (C)'Last) =\n+                         Parameter))\n+               then\n+                  Remove (Cmd.Expanded, C);\n+                  Remove (Cmd.Params, C);\n+\n+                  --  The switch is necessarily unique by construction of\n+                  --  Add_Switch\n+\n+                  return;\n+\n+               else\n+                  C := C + 1;\n+               end if;\n+            end loop;\n+         end if;\n+      end Remove_Simple_Switch;\n+\n+   --  Start of processing for Remove_Switch\n+\n+   begin\n+      For_Each_Simple_Switch\n+        (Cmd, Switch, Remove_Simple_Switch'Unrestricted_Access);\n+      Free (Cmd.Coalesce);\n+   end Remove_Switch;\n+\n+   --------------------\n+   -- Group_Switches --\n+   --------------------\n+\n+   procedure Group_Switches\n+     (Cmd    : Command_Line;\n+      Result : Argument_List_Access;\n+      Params : Argument_List_Access)\n+   is\n+      type Boolean_Array is array (Result'Range) of Boolean;\n+\n+      Matched   : Boolean_Array;\n+      Count     : Natural;\n+      First     : Natural;\n+      From_Args : Boolean_Chars;\n+\n+   begin\n+      if Cmd.Config = null\n+        or else Cmd.Config.Prefixes = null\n+      then\n+         return;\n+      end if;\n+\n+      for P in Cmd.Config.Prefixes'Range loop\n+         Matched := (others => False);\n+         Count   := 0;\n+\n+         for C in Result'Range loop\n+            if Result (C) /= null\n+              and then Params (C) = null  --  ignored if has a parameter\n+              and then Looking_At\n+                (Result (C).all, Result (C)'First, Cmd.Config.Prefixes (P).all)\n+            then\n+               Matched (C) := True;\n+               Count := Count + 1;\n+            end if;\n+         end loop;\n+\n+         if Count > 1 then\n+            From_Args := (others => False);\n+            First   := 0;\n+\n+            for M in Matched'Range loop\n+               if Matched (M) then\n+                  if First = 0 then\n+                     First := M;\n+                  end if;\n+\n+                  for A in Result (M)'First + Cmd.Config.Prefixes (P)'Length\n+                    .. Result (M)'Last\n+                  loop\n+                     From_Args (Result (M)(A)) := True;\n+                  end loop;\n+                  Free (Result (M));\n+               end if;\n+            end loop;\n+\n+            Result (First) := new String'\n+              (Cmd.Config.Prefixes (P).all & Args_From_Expanded (From_Args));\n+         end if;\n+      end loop;\n+   end Group_Switches;\n+\n+   --------------------\n+   -- Alias_Switches --\n+   --------------------\n+\n+   procedure Alias_Switches\n+     (Cmd    : Command_Line;\n+      Result : Argument_List_Access;\n+      Params : Argument_List_Access)\n+   is\n+      Found : Boolean;\n+      First : Natural;\n+\n+      procedure Check_Cb (Switch : String);\n+      --  Comment required ???\n+\n+      procedure Remove_Cb (Switch : String);\n+      --  Comment required ???\n+\n+      --------------\n+      -- Check_Cb --\n+      --------------\n+\n+      procedure Check_Cb (Switch : String) is\n+      begin\n+         if Found then\n+            for E in Result'Range loop\n+               if Result (E) /= null\n+                 and then Params (E) = null    --  Ignore if has a param\n+                 and then Result (E).all = Switch\n+               then\n+                  return;\n+               end if;\n+            end loop;\n+\n+            Found := False;\n+         end if;\n+      end Check_Cb;\n+\n+      ---------------\n+      -- Remove_Cb --\n+      ---------------\n+\n+      procedure Remove_Cb (Switch : String) is\n+      begin\n+         for E in Result'Range loop\n+            if Result (E) /= null and then Result (E).all = Switch then\n+               if First > E then\n+                  First := E;\n+               end if;\n+               Free (Result (E));\n+               return;\n+            end if;\n+         end loop;\n+      end Remove_Cb;\n+\n+   --  Start of processing for Alias_Switches\n+\n+   begin\n+      if Cmd.Config = null\n+        or else Cmd.Config.Aliases = null\n+      then\n+         return;\n+      end if;\n+\n+      for A in Cmd.Config.Aliases'Range loop\n+\n+         --  Compute the various simple switches that make up the alias. We\n+         --  split the expansion into as many simple switches as possible, and\n+         --  then check whether the expanded command line has all of them.\n+\n+         Found := True;\n+         For_Each_Simple_Switch\n+           (Cmd, Cmd.Config.Expansions (A).all,\n+            Check_Cb'Unrestricted_Access);\n+\n+         if Found then\n+            First := Integer'Last;\n+            For_Each_Simple_Switch\n+              (Cmd, Cmd.Config.Expansions (A).all,\n+               Remove_Cb'Unrestricted_Access);\n+            Result (First) := new String'(Cmd.Config.Aliases (A).all);\n+         end if;\n+      end loop;\n+   end Alias_Switches;\n+\n+   -----------\n+   -- Start --\n+   -----------\n+\n+   procedure Start\n+     (Cmd      : in out Command_Line;\n+      Iter     : in out Command_Line_Iterator;\n+      Expanded : Boolean)\n+   is\n+   begin\n+      --  Coalesce the switches as much as possible\n+\n+      if not Expanded\n+        and then Cmd.Coalesce = null\n+      then\n+         Cmd.Coalesce := new Argument_List (Cmd.Expanded'Range);\n+         for E in Cmd.Expanded'Range loop\n+            Cmd.Coalesce (E) := new String'(Cmd.Expanded (E).all);\n+         end loop;\n+\n+         --  Not a clone, since we will not modify the parameters anyway\n+\n+         Cmd.Coalesce_Params := Cmd.Params;\n+         Alias_Switches (Cmd, Cmd.Coalesce, Cmd.Params);\n+         Group_Switches (Cmd, Cmd.Coalesce, Cmd.Params);\n+      end if;\n+\n+      if Expanded then\n+         Iter.List   := Cmd.Expanded;\n+         Iter.Params := Cmd.Params;\n+      else\n+         Iter.List   := Cmd.Coalesce;\n+         Iter.Params := Cmd.Coalesce_Params;\n+      end if;\n+\n+      if Iter.List = null then\n+         Iter.Current := Integer'Last;\n+      else\n+         Iter.Current := Iter.List'First;\n+         while Iter.Current <= Iter.List'Last\n+           and then Iter.List (Iter.Current) = null\n+         loop\n+            Iter.Current := Iter.Current + 1;\n+         end loop;\n+      end if;\n+   end Start;\n+\n+   --------------------\n+   -- Current_Switch --\n+   --------------------\n+\n+   function Current_Switch (Iter : Command_Line_Iterator) return String is\n+   begin\n+      return Iter.List (Iter.Current).all;\n+   end Current_Switch;\n+\n+   -----------------------\n+   -- Current_Separator --\n+   -----------------------\n+\n+   function Current_Separator (Iter : Command_Line_Iterator) return String is\n+   begin\n+      if Iter.Params = null\n+        or else Iter.Current > Iter.Params'Last\n+        or else Iter.Params (Iter.Current) = null\n+      then\n+         return \"\";\n+\n+      else\n+         declare\n+            Sep : constant Character :=\n+              Iter.Params (Iter.Current) (Iter.Params (Iter.Current)'First);\n+         begin\n+            if Sep = ASCII.NUL then\n+               return \"\";\n+            else\n+               return \"\" & Sep;\n+            end if;\n+         end;\n+      end if;\n+   end Current_Separator;\n+\n+   -----------------------\n+   -- Current_Parameter --\n+   -----------------------\n+\n+   function Current_Parameter (Iter : Command_Line_Iterator) return String is\n+   begin\n+      if Iter.Params = null\n+        or else Iter.Current > Iter.Params'Last\n+        or else Iter.Params (Iter.Current) = null\n+      then\n+         return \"\";\n+\n+      else\n+         declare\n+            P : constant String := Iter.Params (Iter.Current).all;\n+\n+         begin\n+            --  Skip separator\n+\n+            return P (P'First + 1 .. P'Last);\n+         end;\n+      end if;\n+   end Current_Parameter;\n+\n+   --------------\n+   -- Has_More --\n+   --------------\n+\n+   function Has_More (Iter : Command_Line_Iterator) return Boolean is\n+   begin\n+      return Iter.List /= null and then Iter.Current <= Iter.List'Last;\n+   end Has_More;\n+\n+   ----------\n+   -- Next --\n+   ----------\n+\n+   procedure Next (Iter : in out Command_Line_Iterator) is\n+   begin\n+      Iter.Current := Iter.Current + 1;\n+      while Iter.Current <= Iter.List'Last\n+        and then Iter.List (Iter.Current) = null\n+      loop\n+         Iter.Current := Iter.Current + 1;\n+      end loop;\n+   end Next;\n+\n+   ----------\n+   -- Free --\n+   ----------\n+\n+   procedure Free (Config : in out Command_Line_Configuration) is\n+   begin\n+      if Config /= null then\n+         Free (Config.Aliases);\n+         Free (Config.Expansions);\n+         Free (Config.Prefixes);\n+         Unchecked_Free (Config);\n+      end if;\n+   end Free;\n+\n+   ----------\n+   -- Free --\n+   ----------\n+\n+   procedure Free (Cmd : in out Command_Line) is\n+   begin\n+      Free (Cmd.Expanded);\n+      Free (Cmd.Coalesce);\n+      Free (Cmd.Params);\n+   end Free;\n+\n end GNAT.Command_Line;"}, {"sha": "6da8237f826db842ff70e17d3591eff84b66e406", "filename": "gcc/ada/g-comlin.ads", "status": "modified", "additions": 469, "deletions": 26, "changes": 495, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da2ac8c26f63fbe1d5d2c4ff23b99e81967873ff/gcc%2Fada%2Fg-comlin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da2ac8c26f63fbe1d5d2c4ff23b99e81967873ff/gcc%2Fada%2Fg-comlin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-comlin.ads?ref=da2ac8c26f63fbe1d5d2c4ff23b99e81967873ff", "patch": "@@ -31,10 +31,21 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  High level package for command line parsing\n+--  High level package for command line parsing and manipulation\n \n---  This package provides an interface to Ada.Command_Line, to do the\n---  parsing of command line arguments. Here is a small usage example:\n+--  Parsing the command line\n+--  ========================\n+\n+--  This package provides an interface for parsing command line arguments,\n+--  when they are either read from Ada.Command_Line or read from a string list.\n+--  As shown in the example below, one should first retrieve the switches\n+--  (special command line arguments starting with '-' by default) and their\n+--  parameters, and then the rest of the command line arguments.\n+\n+--  This package is flexible enough to accomodate various needs: optional\n+--  switch parameters, various characters to separate a switch and its\n+--  parameter, whether to stop the parsing at the first non-switch argument\n+--  encountered, etc.\n \n --  begin\n --     loop\n@@ -50,7 +61,7 @@\n \n --           when 'b' =>\n --              Put_Line (\"Got b + \" & Parameter);\n---\n+\n --           when others =>\n --              raise Program_Error;         -- cannot occur!\n --        end case;\n@@ -64,16 +75,17 @@\n --           Put_Line (\"Got \" & S);\n --        end;\n --     end loop;\n---\n+\n --  exception\n --     when Invalid_Switch    => Put_Line (\"Invalid Switch \" & Full_Switch);\n --     when Invalid_Parameter => Put_Line (\"No parameter for \" & Full_Switch);\n --  end;\n \n --  A more complicated example would involve the use of sections for the\n---  switches, as for instance in gnatmake. These sections are separated by\n---  special switches chosen by the programer. Each section acts as a\n---  command line of its own.\n+--  switches, as for instance in gnatmake. The same command line is used to\n+--  provide switches for several tools. Each tool recognizes its switches by\n+--  separating them with special switches, chosen by the programer.\n+--  Each section acts as a command line of its own.\n \n --  begin\n --     Initialize_Option_Scan ('-', False, \"largs bargs cargs\");\n@@ -84,34 +96,198 @@\n --     Goto_Section (\"bargs\");\n --     loop\n --        --  Same loop as above to get switches and arguments\n---        --  The supports switches in Get_Opt might be different\n+--        --  The supported switches in Get_Opt might be different\n --     end loop;\n \n --     Goto_Section (\"cargs\");\n --     loop\n --        --  Same loop as above to get switches and arguments\n---        --  The supports switches in Get_Opt might be different\n+--        --  The supported switches in Get_Opt might be different\n+--     end loop;\n+--  end;\n+\n+--  The example above have shown how to parse the command line when the\n+--  arguments are read directly from Ada.Command_Line. However, these arguments\n+--  can also be read from a list of strings. This can be useful in several\n+--  contexts, either because your system does not support Ada.Command_Line, or\n+--  because you are manipulating other tools and creating their command line by\n+--  hand, or for any other reason.\n+--  To create the list of strings, it is recommended to use\n+--  GNAT.OS_Lib.Argument_String_To_List.\n+\n+--  The example below shows how to get the parameters from such a list. Note\n+--  also the use of '*' to get all the switches, and not report errors when an\n+--  unexpected switch was used by the user\n+\n+--  declare\n+--     Parser : Opt_Parser;\n+--     Args : constant Argument_List_Access :=\n+--        GNAT.OS_Lib.Argument_String_To_List (\"-g -O1 -Ipath\");\n+--  begin\n+--     Initialize_Option_Scan (Parser, Args);\n+--     while Get_Opt (\"* g O! I=\", Parser) /= ASCII.NUL loop\n+--        Put_Line (\"Switch \" & Full_Switch (Parser)\n+--                  & \" param=\" & Parameter (Parser));\n --     end loop;\n+--     Free (Parser);\n --  end;\n+--\n+--  Creating and manipulating the command line\n+--  ===========================================\n+\n+--  This package provides handling of command line by providing methods to\n+--  add or remove arguments from it. The resulting command line is kept as\n+--  short as possible by coalescing arguments whenever possible.\n+\n+--  This package can be used to construct complex command lines for instance\n+--  from an GUI interface (although the package itself does not depend on a\n+--  specific GUI toolkit). For instance, if you are configuring the command\n+--  line to use when spawning a tool with the following characteristics:\n+\n+--    * Specifying -gnatwa is the same as specifying -gnatwu -gnatwv, but\n+--      shorter and more readable\n+\n+--    * All switches starting with -gnatw can be grouped, for instance one\n+--      can write -gnatwcd instead of -gnatwc -gnatwd.\n+--      Of course, this can be combined with the above and -gnatwacd is the\n+--      same as -gnatwc -gnatwd -gnatwu -gnatwv\n+\n+--    * The switch -T is the same as -gnatwAB\n+\n+--    * A switch -foo takes one mandatory parameter\n+\n+--  These attributes can be configured through this package with the following\n+--  calls:\n+\n+--     Config : Command_Line_Configuration;\n+--     Define_Prefix (Config, \"-gnatw\");\n+--     Define_Alias  (Config, \"-gnatwa\", \"-gnatwuv\");\n+--     Define_Alias  (Config, \"-T\",      \"-gnatwAB\");\n+\n+--  Using this configuration, one can then construct a command line for the\n+--  tool with:\n \n+--     Cmd : Command_Line;\n+--     Set_Configuration (Cmd, Config);\n+--     Add_Switch (Cmd, \"-bar\");\n+--     Add_Switch (Cmd, \"-gnatwu\");\n+--     Add_Switch (Cmd, \"-gnatwv\");  --  will be grouped with the above\n+--     Add_Switch (Cmd, \"-T\");\n+\n+--  The resulting command line can be iterated over to get all its switches,\n+--  There are two modes for this iteration: either you want to get the\n+--  shortest possible command line, which would be:\n+\n+--      -bar -gnatwaAB\n+\n+--  or on the other hand you want each individual switch (so that your own\n+--  tool does not have to do further complex processing), which would be:\n+\n+--      -bar -gnatwu -gnatwv -gnatwA -gnatwB\n+\n+--  Of course, we can assume that the tool you want to spawn would understand\n+--  both of these, since they are both compatible with the description we gave\n+--  above. However, the first result is useful if you want to show the user\n+--  what you are spawning (since that keeps the output shorter), and the second\n+--  output is more useful for a tool that would check whether -gnatwu was\n+--  passed (which isn't obvious in the first output). Likewise, the second\n+--  output is more useful if you have a graphical interface since each switch\n+--  can be associated with a widget, and you immediately know whether -gnatwu\n+--  was selected.\n+--\n+--  Some command line arguments can have parameters, which on a command line\n+--  appear as a separate argument that must immediately follow the switch.\n+--  Since the subprograms in this package will reorganize the switches to group\n+--  them, you need to indicate what is a command line\n+--  parameter, and what is a switch argument.\n+\n+--  This is done by passing an extra argument to Add_Switch, as in:\n+\n+--     Add_Switch (Cmd, \"-foo\", \"arg1\");\n+\n+--  This ensures that \"arg1\" will always be treated as the argument to -foo,\n+--  and will not be grouped with other parts of the command line.\n+\n+--  Parsing the command line with grouped arguments\n+--  ===============================================\n+\n+--  This package also works great in collaboration with GNAT.Command_Line, to\n+--  parse the input to your tools. If you are writing the tool we described\n+--  above, you would do a first loop with Getopt to pass the switches and\n+--  their arguments, and create a temporary representation of the command line\n+--  as a Command_Line object. Finally, you can ask each individual switch to\n+--  that object. For instance:\n+\n+--    declare\n+--      Cmd  : Command_Line;\n+--      Iter : Command_Line_Iterator;\n+\n+--    begin\n+--      while Getopt (\"foo: gnatw! T bar\") /= ASCII.NUL loop\n+--         Add_Switch (Cmd, Full_Switch, Parameter);\n+--      end loop;\n+\n+--      Start (Cmd, Iter, Expanded => True);\n+--      while Has_More (Iter) loop\n+--        if Current_Switch (Iter) = \"-gnatwu\" then ..\n+--        elsif Current_Switch (Iter) = \"-gnatwv\" then ...\n+--        end if;\n+--        Next (Iter);\n+--      end loop;\n+\n+--  The above means that your tool does not have to handle on its own whether\n+--  the user passed -gnatwa (in which case -gnatwu was indeed selected), or\n+--  just -gnatwu, or a combination of -gnatw switches as in -gnatwuv.\n+\n+with Ada.Command_Line;\n with GNAT.Directory_Operations;\n+with GNAT.OS_Lib;\n with GNAT.Regexp;\n \n package GNAT.Command_Line is\n \n+   -------------\n+   -- Parsing --\n+   -------------\n+\n+   type Opt_Parser is private;\n+   Command_Line_Parser : constant Opt_Parser;\n+   --  This object is responsible for parsing a list of arguments, which by\n+   --  default are the standard command line arguments from Ada.Command_Line.\n+   --  This is really a pointer to actual data, which must therefore be\n+   --  initialized through a call to Initialize_Option_Scan, and must be freed\n+   --  with a call to Free.\n+   --\n+   --  As a special case, Command_Line_Parser does not need to be either\n+   --  initialized or free-ed.\n+\n    procedure Initialize_Option_Scan\n      (Switch_Char              : Character := '-';\n       Stop_At_First_Non_Switch : Boolean := False;\n       Section_Delimiters       : String := \"\");\n-   --  This procedure resets the internal state of the package to prepare\n-   --  to rescan the parameters. It does not need to be called before the\n-   --  first use of Getopt (but it could be), but it must be called if you want\n-   --  to start rescanning the command line parameters from the start. The\n+   procedure Initialize_Option_Scan\n+     (Parser                   : out Opt_Parser;\n+      Command_Line             : GNAT.OS_Lib.Argument_List_Access;\n+      Switch_Char              : Character := '-';\n+      Stop_At_First_Non_Switch : Boolean := False;\n+      Section_Delimiters       : String := \"\");\n+   --  The first procedure resets the internal state of the package to prepare\n+   --  to rescan the parameters. It does not need to be called before the first\n+   --  use of Getopt (but it could be), but it must be called if you want to\n+   --  start rescanning the command line parameters from the start. The\n    --  optional parameter Switch_Char can be used to reset the switch\n-   --  character, e.g. to '/' for use in DOS-like systems. The optional\n-   --  parameter Stop_At_First_Non_Switch indicates if Getopt is to look for\n-   --  switches on the whole command line, or if it has to stop as soon as a\n-   --  non-switch argument is found.\n+   --  character, e.g. to '/' for use in DOS-like systems.\n+   --\n+   --  The second subprogram initializes a parser that takes its arguments from\n+   --  an array of strings rather than directly from the command line. In this\n+   --  case, the parser is responsible for freeing the strings stored in\n+   --  Command_Line. If you pass null to Command_Line, this will in fact create\n+   --  a second parser for Ada.Command_Line, which doesn't share any data with\n+   --  the default parser. This parser must be free-ed.\n+   --\n+   --  The optional parameter Stop_At_First_Non_Switch indicates if Getopt is\n+   --  to look for switches on the whole command line, or if it has to stop as\n+   --  soon as a non-switch argument is found.\n    --\n    --  Example:\n    --\n@@ -126,27 +302,35 @@ package GNAT.Command_Line is\n    --  is delimited by any of these delimiters or the end of the command line.\n    --\n    --  Example:\n-   --      Initialize_Option_Scan (\"largs bargs cargs\");\n+   --      Initialize_Option_Scan (Section_Delimiters => \"largs bargs cargs\");\n    --\n    --      Arguments on command line : my_application -c -bargs -d -e -largs -f\n    --      This line is made of three section, the first one is the default one\n    --      and includes only the '-c' switch, the second one is between -bargs\n    --      and -largs and includes '-d -e' and the last one includes '-f'\n \n-   procedure Goto_Section (Name : String := \"\");\n+   procedure Free (Parser : in out Opt_Parser);\n+   --  Free the memory used by the parser. Calling this is not mandatory for\n+   --  the Command_Line_Parser\n+\n+   procedure Goto_Section\n+     (Name   : String := \"\";\n+      Parser : Opt_Parser := Command_Line_Parser);\n    --  Change the current section. The next Getopt of Get_Argument will start\n    --  looking at the beginning of the section. An empty name (\"\") refers to\n    --  the first section between the program name and the first section\n    --  delimiter. If the section does not exist, then Invalid_Section is\n    --  raised.\n \n-   function Full_Switch return String;\n+   function Full_Switch\n+     (Parser : Opt_Parser := Command_Line_Parser) return String;\n    --  Returns the full name of the last switch found (Getopt only returns\n    --  the first character)\n \n    function Getopt\n      (Switches    : String;\n-      Concatenate : Boolean := True) return Character;\n+      Concatenate : Boolean := True;\n+      Parser      : Opt_Parser := Command_Line_Parser) return Character;\n    --  This function moves to the next switch on the command line (defined as\n    --  switch character followed by a character within Switches, casing being\n    --  significant). The result returned is the first character of the switch\n@@ -196,15 +380,17 @@ package GNAT.Command_Line is\n    --\n    --  If the first item in switches is '*', then Getopt will catch\n    --  every element on the command line that was not caught by any other\n-   --  switch. The character returned by GetOpt is '*'\n+   --  switch. The character returned by GetOpt is '*', but Full_Switch\n+   --  contains the full command line argument, including leading '-' if there\n+   --  is one. If this character was not returned, there would be no way of\n+   --  knowing whether it is there or not.\n    --\n    --    Example\n    --       Getopt (\"* a b\")\n    --       If the command line is '-a -c toto.o -b', Getopt will return\n    --       successively 'a', '*', '*' and 'b'. When '*' is returned,\n    --       Full_Switch returns the corresponding item on the command line.\n    --\n-   --\n    --  When Getopt encounters an invalid switch, it raises the exception\n    --  Invalid_Switch and sets Full_Switch to return the invalid switch.\n    --  When Getopt cannot find the parameter associated with a switch, it\n@@ -226,7 +412,9 @@ package GNAT.Command_Line is\n    --       If the command line is '-ab', exception Invalid_Switch will be\n    --       raised and Full_Switch will return \"ab\".\n \n-   function Get_Argument (Do_Expansion : Boolean := False) return String;\n+   function Get_Argument\n+     (Do_Expansion : Boolean := False;\n+      Parser       : Opt_Parser := Command_Line_Parser) return String;\n    --  Returns the next element on the command line which is not a switch.\n    --  This function should not be called before Getopt has returned\n    --  ASCII.NUL.\n@@ -238,14 +426,23 @@ package GNAT.Command_Line is\n    --  string. This is useful in non-Unix systems for obtaining normal\n    --  expansion of wild card references.\n \n-   function Parameter return String;\n+   function Parameter\n+     (Parser : Opt_Parser := Command_Line_Parser) return String;\n    --  Returns the parameter associated with the last switch returned by\n    --  Getopt. If no parameter was associated with the last switch, or no\n    --  previous call has been made to Get_Argument, raises Invalid_Parameter.\n    --  If the last switch was associated with an optional argument and this\n    --  argument was not found on the command line, Parameter returns an empty\n    --  string.\n \n+   function Separator\n+     (Parser : Opt_Parser := Command_Line_Parser) return Character;\n+   --  The separator that was between the switch and its parameter. This is\n+   --  of little use in general, only if you want to know exactly what was on\n+   --  the command line. This is in general a single character, set to\n+   --  ASCII.NUL if the switch and the parameter were concatenated. A space is\n+   --  returned if the switch and its argument were in two separate arguments.\n+\n    type Expansion_Iterator is limited private;\n    --  Type used during expansion of file names\n \n@@ -288,6 +485,154 @@ package GNAT.Command_Line is\n    --  Raised when a parameter is missing, or an attempt is made to obtain a\n    --  parameter for a switch that does not allow a parameter\n \n+   -----------------\n+   -- Configuring --\n+   -----------------\n+\n+   type Command_Line_Configuration is private;\n+\n+   procedure Define_Alias\n+     (Config   : in out Command_Line_Configuration;\n+      Switch   : String;\n+      Expanded : String);\n+   --  Indicates that whenever Switch appears on the command line, it should\n+   --  be expanded as Expanded. For instance, for the GNAT compiler switches,\n+   --  we would define \"-gnatwa\" as an alias for \"-gnatwcfijkmopruvz\", ie some\n+   --  default warnings to be activated.\n+   --\n+   --  Likewise, in some context you could define \"--verbose\" as an alias for\n+   --  (\"-v\", \"--full\"), ie two switches.\n+\n+   procedure Define_Prefix\n+     (Config   : in out Command_Line_Configuration;\n+      Prefix   : String);\n+   --  Indicates that all switches starting with the given prefix should be\n+   --  grouped. For instance, for the GNAT compiler we would define \"-gnatw\"\n+   --  as a prefix, so that \"-gnatwu -gnatwv\" can be grouped into \"-gnatwuv\"\n+   --  It is assume that the remaining of the switch (\"uv\") is a set of\n+   --  characters whose order is irrelevant. In fact, this package will sort\n+   --  them alphabetically.\n+\n+   procedure Free (Config : in out Command_Line_Configuration);\n+   --  Free the memory used by Config\n+\n+   -------------\n+   -- Editing --\n+   -------------\n+\n+   type Command_Line is private;\n+\n+   procedure Set_Configuration\n+     (Cmd      : in out Command_Line;\n+      Config   : Command_Line_Configuration);\n+   --  Set the configuration for this command line\n+\n+   procedure Set_Command_Line\n+     (Cmd                : in out Command_Line;\n+      Switches           : String;\n+      Getopt_Description : String    := \"\";\n+      Switch_Char        : Character := '-');\n+   --  Set the new content of the command line, by replacing the current\n+   --  version with Switches.\n+   --\n+   --  The parsing of Switches is done through calls to Getopt, by passing\n+   --  Getopt_Description as an argument. (a \"*\" is automatically prepended so\n+   --  that all switches and command line arguments are accepted).\n+   --\n+   --  To properly handle switches that take parameters, you should document\n+   --  them in Getopt_Description. Otherwise, the switch and its parameter will\n+   --  be recorded as two separate command line arguments as returned by a\n+   --  Command_Line_Iterator (which might be fine depending on your\n+   --  application).\n+   --\n+   --  This function can be used to reset Cmd by passing an empty string.\n+\n+   procedure Add_Switch\n+     (Cmd       : in out Command_Line;\n+      Switch    : String;\n+      Parameter : String    := \"\";\n+      Separator : Character := ' ');\n+   --  Add a new switch to the command line, and combine/group it with existing\n+   --  switches if possible. Nothing is done if the switch already exists with\n+   --  the same parameter.\n+   --\n+   --  If the Switch takes a parameter, the latter should be specified\n+   --  separately, so that the association between the two is always correctly\n+   --  recognized even if the order of switches on the command line changes.\n+   --  For instance, you should pass \"--check=full\" as (\"--check\", \"full\") so\n+   --  that Remove_Switch below can simply take \"--check\" in parameter. That\n+   --  will automatically remove \"full\" as well. The value of the parameter is\n+   --  never modified by this package.\n+   --\n+   --  On the other hand, you could decide to simply pass \"--check=full\" as\n+   --  the Switch above, and then pass no parameter. This means that you need\n+   --  to pass \"--check=full\" to Remove_Switch as well.\n+   --\n+   --  A Switch with a parameter will never be grouped with another switch to\n+   --  avoid ambiguities as to who the parameter applies to.\n+   --\n+   --  Separator is the character that goes between the switches and its\n+   --  parameter on the command line. If it is set to ASCII.NUL, then no\n+   --  separator is applied, and they are concatenated\n+\n+   procedure Remove_Switch\n+     (Cmd        : in out Command_Line;\n+      Switch     : String;\n+      Remove_All : Boolean := False);\n+   --  Remove Switch from the command line, and ungroup existing switches if\n+   --  necessary.\n+   --\n+   --  The actual parameter to the switches are ignored. If for instance\n+   --  you are removing \"-foo\", then \"-foo param1\" and \"-foo param2\" can\n+   --  be removed.\n+   --\n+   --  If Remove_All is True, then all matching switches are removed, otherwise\n+   --  only the first matching one is removed.\n+\n+   procedure Remove_Switch\n+     (Cmd       : in out Command_Line;\n+      Switch    : String;\n+      Parameter : String);\n+   --  Remove a switch with a specific parameter. If Parameter is the empty\n+   --  string, then only a switch with no parameter will be removed.\n+\n+   ---------------\n+   -- Iterating --\n+   ---------------\n+\n+   type Command_Line_Iterator is private;\n+\n+   procedure Start\n+     (Cmd      : in out Command_Line;\n+      Iter     : in out Command_Line_Iterator;\n+      Expanded : Boolean);\n+   --  Start iterating over the command line arguments. If Expanded is true,\n+   --  then the arguments are not grouped and no alias is used. For instance,\n+   --  \"-gnatwv\" and \"-gnatwu\" would be returned instead of \"-gnatwuv\".\n+   --\n+   --  The iterator becomes invalid if the command line is changed through a\n+   --  call to Add_Switch, Remove_Switch or Set_Command_Line.\n+\n+   function Current_Switch    (Iter : Command_Line_Iterator) return String;\n+   function Current_Separator (Iter : Command_Line_Iterator) return String;\n+   function Current_Parameter (Iter : Command_Line_Iterator) return String;\n+   --  Return the current switch and its parameter (or the empty string if\n+   --  there is no parameter or the switch was added through Add_Switch\n+   --  without specifying the parameter.\n+   --\n+   --  Separator is the string that goes between the switch and its separator.\n+   --  It could be the empty string if they should be concatenated, or a space\n+   --  for instance. When printing, you should not add any other character.\n+\n+   function Has_More (Iter : Command_Line_Iterator) return Boolean;\n+   --  Return True if there are more switches to be returned\n+\n+   procedure Next (Iter : in out Command_Line_Iterator);\n+   --  Move to the next switch\n+\n+   procedure Free (Cmd : in out Command_Line);\n+   --  Free the memory used by Cmd\n+\n private\n \n    Max_Depth : constant := 100;\n@@ -305,6 +650,22 @@ private\n \n    type Level_Array is array (Depth) of Level;\n \n+   type Section_Number is new Natural range 0 .. 65534;\n+   for Section_Number'Size use 16;\n+\n+   type Parameter_Type is record\n+      Arg_Num : Positive;\n+      First   : Positive;\n+      Last    : Positive;\n+      Extra   : Character;\n+   end record;\n+\n+   type Is_Switch_Type is array (Natural range <>) of Boolean;\n+   pragma Pack (Is_Switch_Type);\n+\n+   type Section_Type is array (Natural range <>) of Section_Number;\n+   pragma Pack (Section_Type);\n+\n    type Expansion_Iterator is limited record\n       Start : Positive := 1;\n       --  Position of the first character of the relative path to check against\n@@ -324,4 +685,86 @@ private\n       --  separators in the pattern.\n    end record;\n \n+   type Opt_Parser_Data (Arg_Count : Natural) is record\n+      Arguments : GNAT.OS_Lib.Argument_List_Access;\n+      --  null if reading from the command line\n+\n+      The_Parameter : Parameter_Type;\n+      The_Separator : Character;\n+      The_Switch    : Parameter_Type;\n+      --  This type and this variable are provided to store the current switch\n+      --  and parameter.\n+\n+      Is_Switch : Is_Switch_Type (1 .. Arg_Count) := (others => False);\n+      --  Indicates wich arguments on the command line are considered not be\n+      --  switches or parameters to switches (leaving e.g. filenames,...)\n+\n+      Section : Section_Type (1 .. Arg_Count) := (others => 1);\n+      --  Contains the number of the section associated with the current\n+      --  switch. If this number is 0, then it is a section delimiter, which is\n+      --  never returned by GetOpt.\n+\n+      Current_Argument : Natural := 1;\n+      --  Number of the current argument parsed on the command line\n+\n+      Current_Index : Natural := 1;\n+      --  Index in the current argument of the character to be processed\n+\n+      Current_Section : Section_Number := 1;\n+\n+      Expansion_It : aliased Expansion_Iterator;\n+      --  When Get_Argument is expanding a file name, this is the iterator used\n+\n+      In_Expansion : Boolean := False;\n+      --  True if we are expanding a file\n+\n+      Switch_Character : Character := '-';\n+      --  The character at the beginning of the command line arguments,\n+      --  indicating the beginning of a switch.\n+\n+      Stop_At_First : Boolean := False;\n+      --  If it is True then Getopt stops at the first non-switch argument\n+   end record;\n+\n+   Command_Line_Parser_Data : aliased Opt_Parser_Data\n+     (Ada.Command_Line.Argument_Count);\n+   --  The internal data used when parsing the command line\n+\n+   type Opt_Parser is access all Opt_Parser_Data;\n+   Command_Line_Parser : constant Opt_Parser :=\n+                           Command_Line_Parser_Data'Access;\n+\n+   type Command_Line_Configuration_Record is record\n+      Prefixes : GNAT.OS_Lib.Argument_List_Access;\n+      --  The list of prefixes\n+\n+      Aliases    : GNAT.OS_Lib.Argument_List_Access;\n+      Expansions : GNAT.OS_Lib.Argument_List_Access;\n+      --  The aliases. Both arrays have the same indices\n+   end record;\n+   type Command_Line_Configuration is access Command_Line_Configuration_Record;\n+\n+   type Command_Line is record\n+      Config   : Command_Line_Configuration;\n+      Expanded : GNAT.OS_Lib.Argument_List_Access;\n+\n+      Params : GNAT.OS_Lib.Argument_List_Access;\n+      --  Parameter for the corresponding switch in Expanded. The first\n+      --  character is the separator (or ASCII.NUL if there is no separator)\n+\n+      Coalesce        : GNAT.OS_Lib.Argument_List_Access;\n+      Coalesce_Params : GNAT.OS_Lib.Argument_List_Access;\n+      --  Cached version of the command line. This is recomputed every time the\n+      --  command line changes. Switches are grouped as much as possible, and\n+      --  aliases are used to reduce the length of the command line.\n+      --  The parameters are not allocated, they point into Params, so must not\n+      --  be freed.\n+   end record;\n+\n+   type Command_Line_Iterator is record\n+      List     : GNAT.OS_Lib.Argument_List_Access;\n+      Params   : GNAT.OS_Lib.Argument_List_Access;\n+      Current  : Natural;\n+   end record;\n+\n end GNAT.Command_Line;"}]}