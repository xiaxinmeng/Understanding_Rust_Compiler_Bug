{"sha": "3b2a6901f931591e664bea4ec8a3922524fd8af8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2IyYTY5MDFmOTMxNTkxZTY2NGJlYTRlYzhhMzkyMjUyNGZkOGFmOA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2018-01-05T15:57:04Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2018-01-05T15:57:04Z"}, "message": "ipa-fnsummary.c (record_modified_bb_info): Add OP.\n\n\n\t* ipa-fnsummary.c (record_modified_bb_info): Add OP.\n\t(record_modified): Skip clobbers; add debug output.\n\t(param_change_prob): Use sreal frequencies.\n\nFrom-SVN: r256279", "tree": {"sha": "5c36d92fba3168216f0a6983e5496135b84ec43f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c36d92fba3168216f0a6983e5496135b84ec43f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b2a6901f931591e664bea4ec8a3922524fd8af8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b2a6901f931591e664bea4ec8a3922524fd8af8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b2a6901f931591e664bea4ec8a3922524fd8af8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b2a6901f931591e664bea4ec8a3922524fd8af8/comments", "author": null, "committer": null, "parents": [{"sha": "ccf206491752abc05c608c8475bd925d3969adde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccf206491752abc05c608c8475bd925d3969adde", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ccf206491752abc05c608c8475bd925d3969adde"}], "stats": {"total": 89, "additions": 59, "deletions": 30}, "files": [{"sha": "3e48f38d073b476abb6aba971bac0516c92ca787", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2a6901f931591e664bea4ec8a3922524fd8af8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2a6901f931591e664bea4ec8a3922524fd8af8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3b2a6901f931591e664bea4ec8a3922524fd8af8", "patch": "@@ -1,3 +1,9 @@\n+2018-01-05  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-fnsummary.c (record_modified_bb_info): Add OP.\n+\t(record_modified): Skip clobbers; add debug output.\n+\t(param_change_prob): Use sreal frequencies.\n+\n 2018-01-05  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* tree-vect-data-refs.c (vect_compute_data_ref_alignment): Don't"}, {"sha": "d45efafd389d70b34c04f70c4fc78da670830cca", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 53, "deletions": 30, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2a6901f931591e664bea4ec8a3922524fd8af8/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2a6901f931591e664bea4ec8a3922524fd8af8/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=3b2a6901f931591e664bea4ec8a3922524fd8af8", "patch": "@@ -1591,13 +1591,14 @@ will_be_nonconstant_predicate (struct ipa_func_body_info *fbi,\n \n struct record_modified_bb_info\n {\n+  tree op;\n   bitmap bb_set;\n   gimple *stmt;\n };\n \n /* Value is initialized in INIT_BB and used in USE_BB.  We want to copute\n    probability how often it changes between USE_BB.\n-   INIT_BB->frequency/USE_BB->frequency is an estimate, but if INIT_BB\n+   INIT_BB->count/USE_BB->count is an estimate, but if INIT_BB\n    is in different loop nest, we can do better.\n    This is all just estimate.  In theory we look for minimal cut separating\n    INIT_BB and USE_BB, but we only want to anticipate loop invariant motion\n@@ -1622,12 +1623,25 @@ record_modified (ao_ref *ao ATTRIBUTE_UNUSED, tree vdef, void *data)\n     (struct record_modified_bb_info *) data;\n   if (SSA_NAME_DEF_STMT (vdef) == info->stmt)\n     return false;\n+  if (gimple_clobber_p (SSA_NAME_DEF_STMT (vdef)))\n+    return false;\n   bitmap_set_bit (info->bb_set,\n \t\t  SSA_NAME_IS_DEFAULT_DEF (vdef)\n \t\t  ? ENTRY_BLOCK_PTR_FOR_FN (cfun)->index\n \t\t  : get_minimal_bb\n \t\t\t (gimple_bb (SSA_NAME_DEF_STMT (vdef)),\n \t\t\t  gimple_bb (info->stmt))->index);\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"     Param \");\n+      print_generic_expr (dump_file, info->op, TDF_SLIM);\n+      fprintf (dump_file, \" changed at bb %i, minimal: %i stmt: \",\n+\t       gimple_bb (SSA_NAME_DEF_STMT (vdef))->index,\n+\t       get_minimal_bb\n+\t\t\t (gimple_bb (SSA_NAME_DEF_STMT (vdef)),\n+\t\t\t  gimple_bb (info->stmt))->index);\n+      print_gimple_stmt (dump_file, SSA_NAME_DEF_STMT (vdef), 0);\n+    }\n   return false;\n }\n \n@@ -1661,66 +1675,75 @@ param_change_prob (gimple *stmt, int i)\n      than the statement defining value, we take the frequency 1/N.  */\n   if (TREE_CODE (base) == SSA_NAME)\n     {\n-      int init_freq;\n+      profile_count init_count;\n \n-      if (!bb->count.to_frequency (cfun))\n+      if (!bb->count.nonzero_p ())\n \treturn REG_BR_PROB_BASE;\n \n       if (SSA_NAME_IS_DEFAULT_DEF (base))\n-\tinit_freq = ENTRY_BLOCK_PTR_FOR_FN (cfun)->count.to_frequency (cfun);\n+\tinit_count = ENTRY_BLOCK_PTR_FOR_FN (cfun)->count;\n       else\n-\tinit_freq = get_minimal_bb\n+\tinit_count = get_minimal_bb\n \t\t      (gimple_bb (SSA_NAME_DEF_STMT (base)),\n-\t\t       gimple_bb (stmt))->count.to_frequency (cfun);\n+\t\t       gimple_bb (stmt))->count;\n \n-      if (!init_freq)\n-\tinit_freq = 1;\n-      if (init_freq < bb->count.to_frequency (cfun))\n-\treturn MAX (GCOV_COMPUTE_SCALE (init_freq,\n-\t\t\t\t\tbb->count.to_frequency (cfun)), 1);\n-      else\n-\treturn REG_BR_PROB_BASE;\n+      if (init_count < bb->count)\n+        return MAX ((init_count.to_sreal_scale (bb->count)\n+\t\t     * REG_BR_PROB_BASE).to_int (), 1);\n+      return REG_BR_PROB_BASE;\n     }\n   else\n     {\n       ao_ref refd;\n-      int max;\n+      profile_count max = ENTRY_BLOCK_PTR_FOR_FN (cfun)->count;\n       struct record_modified_bb_info info;\n-      bitmap_iterator bi;\n-      unsigned index;\n       tree init = ctor_for_folding (base);\n \n       if (init != error_mark_node)\n \treturn 0;\n-      if (!bb->count.to_frequency (cfun))\n+      if (!bb->count.nonzero_p ())\n \treturn REG_BR_PROB_BASE;\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"     Analyzing param change probablity of \");\n+          print_generic_expr (dump_file, op, TDF_SLIM);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n       ao_ref_init (&refd, op);\n+      info.op = op;\n       info.stmt = stmt;\n       info.bb_set = BITMAP_ALLOC (NULL);\n       walk_aliased_vdefs (&refd, gimple_vuse (stmt), record_modified, &info,\n \t\t\t  NULL);\n       if (bitmap_bit_p (info.bb_set, bb->index))\n \t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"     Set in same BB as used.\\n\");\n \t  BITMAP_FREE (info.bb_set);\n \t  return REG_BR_PROB_BASE;\n \t}\n \n-      /* Assume that every memory is initialized at entry.\n-         TODO: Can we easilly determine if value is always defined\n-         and thus we may skip entry block?  */\n-      if (ENTRY_BLOCK_PTR_FOR_FN (cfun)->count.to_frequency (cfun))\n-\tmax = ENTRY_BLOCK_PTR_FOR_FN (cfun)->count.to_frequency (cfun);\n-      else\n-\tmax = 1;\n-\n+      bitmap_iterator bi;\n+      unsigned index;\n+      /* Lookup the most frequent update of the value and believe that\n+\t it dominates all the other; precise analysis here is difficult.  */\n       EXECUTE_IF_SET_IN_BITMAP (info.bb_set, 0, index, bi)\n-\tmax = MIN (max, BASIC_BLOCK_FOR_FN (cfun, index)->count.to_frequency (cfun));\n+\tmax = max.max (BASIC_BLOCK_FOR_FN (cfun, index)->count);\n+      if (dump_file)\n+\t{\n+          fprintf (dump_file, \"     Set with count \");\t\n+\t  max.dump (dump_file);\n+          fprintf (dump_file, \" and used with count \");\t\n+\t  bb->count.dump (dump_file);\n+          fprintf (dump_file, \" freq %f\\n\",\n+\t\t   max.to_sreal_scale (bb->count).to_double ());\t\n+\t}\n \n       BITMAP_FREE (info.bb_set);\n-      if (max < bb->count.to_frequency (cfun))\n-\treturn MAX (GCOV_COMPUTE_SCALE (max, bb->count.to_frequency (cfun)), 1);\n-      else\n-\treturn REG_BR_PROB_BASE;\n+      if (max < bb->count)\n+        return MAX ((max.to_sreal_scale (bb->count)\n+\t\t     * REG_BR_PROB_BASE).to_int (), 1);\n+      return REG_BR_PROB_BASE;\n     }\n }\n "}]}