{"sha": "4670abb087ca8bb5e8fc75652648c99c90f48ab0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDY3MGFiYjA4N2NhOGJiNWU4ZmM3NTY1MjY0OGM5OWM5MGY0OGFiMA==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2012-10-07T08:45:23Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2012-10-07T08:45:23Z"}, "message": "mips-protos.h (mips_split_type): New enum.\n\ngcc/\n\t* config/mips/mips-protos.h (mips_split_type): New enum.\n\t(mips_split_64bit_move_p, mips_split_doubleword_move): Delete.\n\t(mips_split_move_p, mips_split_move, mips_split_move_insn_p)\n\t(mips_split_move_insn): Declare.\n\t* config/mips/mips.c (mips_tuning_info): New variable.\n\t(mips_load_store_insns): Use mips_split_move_insn_p instead of\n\tmips_split_64bit_move_p.\n\t(mips_emit_move_or_split, mips_mult_move_p): New functions.\n\t(mips_split_64bit_move_p): Rename to...\n\t(mips_split_move_p): ...this and take a mips_split_type argument.\n\tGeneralize to all moves.  Call mips_mult_move_p.\n\t(mips_split_doubleword_move): Rename to...\n\t(mips_split_move): ...this and take a mips_split_type argument.\n\tAssert that mips_split_move_p holds.\n\t(mips_insn_split_type, mips_split_move_insn_p, mips_split_move_insn):\n\tNew functions.\n\t(mips_output_move): Use mips_split_move_p instead of\n\tmips_split_64bit_move_p.  Handle MULT $0, $0 moves.\n\t(mips_save_reg): Use mips_emit_move_or_split.\n\t(mips_sim_reset): Assign to curr_state.  Call targetm.sched.init\n\tand advance_state.\n\t(mips_sim_init): Call targetm.sched.init_dfa_pre_cycle_insn and\n\ttargetm.sched.init_dfa_post_cycle_insn, if defined.\n\t(mips_sim_next_cycle): Assign to curr_state.  Use advance_state\n\tinstead of state_transition.\n\t(mips_sim_issue_insn): Assign to curr_state.  Use\n\ttargetm.sched.variable_issue to see how many more insns\n\tcan be issued.\n\t(mips_seq_time, mips_mult_zero_zero_cost)\n\t(mips_set_fast_mult_zero_zero_p, mips_set_tuning_info)\n\t(mips_expand_to_rtl_hook): New functions.\n\t(TARGET_EXPAND_TO_RTL_HOOK): Define.\n\t* config/mips/mips.md (move_type): Add imul.\n\t(type): Map imul move_types to imul.\n\t(*movdi_32bit, *movti): Add imul alternatives.\n\tUse mips_split_move_insn_p and mips_split_move_insn instead of\n\tmips_split_64bit_move_p and mips_split_doubleword_move in move\n\tsplitters.\n\ngcc/testsuite/\n2012-10-07  Richard Sandiford  <rdsandiford@googlemail.com>\n\t    Sandra Loosemore  <sandra@codesourcery.com>\n\n\t* gcc.target/mips/madd-9.c: Force code to be tuned for the 4kc\n\tand test that the accumulator is initialized using MULT.\n\t* gcc.target/mips/mips32-dsp-accinit-1.c: New test.\n\t* gcc.target/mips/mips32-dsp-accinit-2.c: Likewise.\n\nCo-Authored-By: Sandra Loosemore <sandra@codesourcery.com>\n\nFrom-SVN: r192179", "tree": {"sha": "da614f2b3b52b842acda0fd89ea489cd90d3610b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da614f2b3b52b842acda0fd89ea489cd90d3610b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4670abb087ca8bb5e8fc75652648c99c90f48ab0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4670abb087ca8bb5e8fc75652648c99c90f48ab0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4670abb087ca8bb5e8fc75652648c99c90f48ab0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4670abb087ca8bb5e8fc75652648c99c90f48ab0/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "03d15315a12d900f4047866330e18c7d84d69745", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03d15315a12d900f4047866330e18c7d84d69745", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03d15315a12d900f4047866330e18c7d84d69745"}], "stats": {"total": 420, "additions": 379, "deletions": 41}, "files": [{"sha": "204fed8e77692947e5ec2fc73e7122e8f4a19f60", "filename": "gcc/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4670abb087ca8bb5e8fc75652648c99c90f48ab0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4670abb087ca8bb5e8fc75652648c99c90f48ab0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4670abb087ca8bb5e8fc75652648c99c90f48ab0", "patch": "@@ -1,3 +1,44 @@\n+2012-10-07  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* config/mips/mips-protos.h (mips_split_type): New enum.\n+\t(mips_split_64bit_move_p, mips_split_doubleword_move): Delete.\n+\t(mips_split_move_p, mips_split_move, mips_split_move_insn_p)\n+\t(mips_split_move_insn): Declare.\n+\t* config/mips/mips.c (mips_tuning_info): New variable.\n+\t(mips_load_store_insns): Use mips_split_move_insn_p instead of\n+\tmips_split_64bit_move_p.\n+\t(mips_emit_move_or_split, mips_mult_move_p): New functions.\n+\t(mips_split_64bit_move_p): Rename to...\n+\t(mips_split_move_p): ...this and take a mips_split_type argument.\n+\tGeneralize to all moves.  Call mips_mult_move_p.\n+\t(mips_split_doubleword_move): Rename to...\n+\t(mips_split_move): ...this and take a mips_split_type argument.\n+\tAssert that mips_split_move_p holds.\n+\t(mips_insn_split_type, mips_split_move_insn_p, mips_split_move_insn):\n+\tNew functions.\n+\t(mips_output_move): Use mips_split_move_p instead of\n+\tmips_split_64bit_move_p.  Handle MULT $0, $0 moves.\n+\t(mips_save_reg): Use mips_emit_move_or_split.\n+\t(mips_sim_reset): Assign to curr_state.  Call targetm.sched.init\n+\tand advance_state.\n+\t(mips_sim_init): Call targetm.sched.init_dfa_pre_cycle_insn and\n+\ttargetm.sched.init_dfa_post_cycle_insn, if defined.\n+\t(mips_sim_next_cycle): Assign to curr_state.  Use advance_state\n+\tinstead of state_transition.\n+\t(mips_sim_issue_insn): Assign to curr_state.  Use\n+\ttargetm.sched.variable_issue to see how many more insns\n+\tcan be issued.\n+\t(mips_seq_time, mips_mult_zero_zero_cost)\n+\t(mips_set_fast_mult_zero_zero_p, mips_set_tuning_info)\n+\t(mips_expand_to_rtl_hook): New functions.\n+\t(TARGET_EXPAND_TO_RTL_HOOK): Define.\n+\t* config/mips/mips.md (move_type): Add imul.\n+\t(type): Map imul move_types to imul.\n+\t(*movdi_32bit, *movti): Add imul alternatives.\n+\tUse mips_split_move_insn_p and mips_split_move_insn instead of\n+\tmips_split_64bit_move_p and mips_split_doubleword_move in move\n+\tsplitters.\n+\n 2012-10-06  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \t* config/rs6000/rs6000.c (print_operand) ['A']: Delete."}, {"sha": "708d6bb9402f8bfea62f7982c3047df2f5a26a93", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4670abb087ca8bb5e8fc75652648c99c90f48ab0/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4670abb087ca8bb5e8fc75652648c99c90f48ab0/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=4670abb087ca8bb5e8fc75652648c99c90f48ab0", "patch": "@@ -173,6 +173,25 @@ enum mips_call_type {\n   MIPS_CALL_EPILOGUE\n };\n \n+/* Controls the conditions under which certain instructions are split.\n+\n+   SPLIT_IF_NECESSARY\n+\tOnly perform splits that are necessary for correctness\n+\t(because no unsplit version exists).\n+\n+   SPLIT_FOR_SPEED\n+\tPerform splits that are necessary for correctness or\n+\tbeneficial for code speed.\n+\n+   SPLIT_FOR_SIZE\n+\tPerform splits that are necessary for correctness or\n+\tbeneficial for code size.  */\n+enum mips_split_type {\n+  SPLIT_IF_NECESSARY,\n+  SPLIT_FOR_SPEED,\n+  SPLIT_FOR_SIZE\n+};\n+\n extern bool mips_symbolic_constant_p (rtx, enum mips_symbol_context,\n \t\t\t\t      enum mips_symbol_type *);\n extern int mips_regno_mode_ok_for_base_p (int, enum machine_mode, bool);\n@@ -212,8 +231,10 @@ extern int m16_simm8_8 (rtx, enum machine_mode);\n extern int m16_nsimm8_8 (rtx, enum machine_mode);\n \n extern rtx mips_subword (rtx, bool);\n-extern bool mips_split_64bit_move_p (rtx, rtx);\n-extern void mips_split_doubleword_move (rtx, rtx);\n+extern bool mips_split_move_p (rtx, rtx, enum mips_split_type);\n+extern void mips_split_move (rtx, rtx, enum mips_split_type);\n+extern bool mips_split_move_insn_p (rtx, rtx, rtx);\n+extern void mips_split_move_insn (rtx, rtx, rtx);\n extern const char *mips_output_move (rtx, rtx);\n extern bool mips_cfun_has_cprestore_slot_p (void);\n extern bool mips_cprestore_address_p (rtx, bool);"}, {"sha": "dd76ec621a59d51f5572456b9d6812959779767e", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 234, "deletions": 22, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4670abb087ca8bb5e8fc75652648c99c90f48ab0/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4670abb087ca8bb5e8fc75652648c99c90f48ab0/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=4670abb087ca8bb5e8fc75652648c99c90f48ab0", "patch": "@@ -265,6 +265,24 @@ static const char *const mips_fp_conditions[] = {\n   MIPS_FP_CONDITIONS (STRINGIFY)\n };\n \n+/* Tuning information that is automatically derived from other sources\n+   (such as the scheduler).  */\n+static struct {\n+  /* The architecture and tuning settings that this structure describes.  */\n+  enum processor arch;\n+  enum processor tune;\n+\n+  /* True if this structure describes MIPS16 settings.  */\n+  bool mips16_p;\n+\n+  /* True if the structure has been initialized.  */\n+  bool initialized_p;\n+\n+  /* True if \"MULT $0, $0\" is preferable to \"MTLO $0; MTHI $0\"\n+     when optimizing for speed.  */\n+  bool fast_mult_zero_zero_p;\n+} mips_tuning_info;\n+\n /* Information about a function's frame layout.  */\n struct GTY(())  mips_frame_info {\n   /* The size of the frame in bytes.  */\n@@ -2395,11 +2413,11 @@ mips_load_store_insns (rtx mem, rtx insn)\n   mode = GET_MODE (mem);\n \n   /* Try to prove that INSN does not need to be split.  */\n-  might_split_p = true;\n-  if (GET_MODE_BITSIZE (mode) == 64)\n+  might_split_p = GET_MODE_SIZE (mode) > UNITS_PER_WORD;\n+  if (might_split_p)\n     {\n       set = single_set (insn);\n-      if (set && !mips_split_64bit_move_p (SET_DEST (set), SET_SRC (set)))\n+      if (set && !mips_split_move_insn_p (SET_DEST (set), SET_SRC (set), insn))\n \tmight_split_p = false;\n     }\n \n@@ -2441,6 +2459,18 @@ mips_emit_move (rtx dest, rtx src)\n \t  : emit_move_insn_1 (dest, src));\n }\n \n+/* Emit a move from SRC to DEST, splitting compound moves into individual\n+   instructions.  SPLIT_TYPE is the type of split to perform.  */\n+\n+static void\n+mips_emit_move_or_split (rtx dest, rtx src, enum mips_split_type split_type)\n+{\n+  if (mips_split_move_p (dest, src, split_type))\n+    mips_split_move (dest, src, split_type);\n+  else\n+    mips_emit_move (dest, src);\n+}\n+\n /* Emit an instruction of the form (set TARGET (CODE OP0)).  */\n \n static void\n@@ -4107,39 +4137,60 @@ mips_subword (rtx op, bool high_p)\n   return simplify_gen_subreg (word_mode, op, mode, byte);\n }\n \n-/* Return true if a 64-bit move from SRC to DEST should be split into two.  */\n+/* Return true if SRC should be moved into DEST using \"MULT $0, $0\".\n+   SPLIT_TYPE is the condition under which moves should be split.  */\n+\n+static bool\n+mips_mult_move_p (rtx dest, rtx src, enum mips_split_type split_type)\n+{\n+  return ((split_type != SPLIT_FOR_SPEED\n+\t   || mips_tuning_info.fast_mult_zero_zero_p)\n+\t  && src == const0_rtx\n+\t  && REG_P (dest)\n+\t  && GET_MODE_SIZE (GET_MODE (dest)) == 2 * UNITS_PER_WORD\n+\t  && (ISA_HAS_DSP_MULT\n+\t      ? ACC_REG_P (REGNO (dest))\n+\t      : MD_REG_P (REGNO (dest))));\n+}\n+\n+/* Return true if a move from SRC to DEST should be split into two.\n+   SPLIT_TYPE describes the split condition.  */\n \n bool\n-mips_split_64bit_move_p (rtx dest, rtx src)\n+mips_split_move_p (rtx dest, rtx src, enum mips_split_type split_type)\n {\n-  if (TARGET_64BIT)\n+  /* Check whether the move can be done using some variant of MULT $0,$0.  */\n+  if (mips_mult_move_p (dest, src, split_type))\n     return false;\n \n   /* FPR-to-FPR moves can be done in a single instruction, if they're\n      allowed at all.  */\n-  if (FP_REG_RTX_P (src) && FP_REG_RTX_P (dest))\n+  unsigned int size = GET_MODE_SIZE (GET_MODE (dest));\n+  if (size == 8 && FP_REG_RTX_P (src) && FP_REG_RTX_P (dest))\n     return false;\n \n   /* Check for floating-point loads and stores.  */\n-  if (ISA_HAS_LDC1_SDC1)\n+  if (size == 8 && ISA_HAS_LDC1_SDC1)\n     {\n       if (FP_REG_RTX_P (dest) && MEM_P (src))\n \treturn false;\n       if (FP_REG_RTX_P (src) && MEM_P (dest))\n \treturn false;\n     }\n-  return true;\n+\n+  /* Otherwise split all multiword moves.  */\n+  return size > UNITS_PER_WORD;\n }\n \n-/* Split a doubleword move from SRC to DEST.  On 32-bit targets,\n-   this function handles 64-bit moves for which mips_split_64bit_move_p\n-   holds.  For 64-bit targets, this function handles 128-bit moves.  */\n+/* Split a move from SRC to DEST, given that mips_split_move_p holds.\n+   SPLIT_TYPE describes the split condition.  */\n \n void\n-mips_split_doubleword_move (rtx dest, rtx src)\n+mips_split_move (rtx dest, rtx src, enum mips_split_type split_type)\n {\n   rtx low_dest;\n \n+  gcc_checking_assert (mips_split_move_p (dest, src, split_type));\n   if (FP_REG_RTX_P (dest) || FP_REG_RTX_P (src))\n     {\n       if (!TARGET_64BIT && GET_MODE (dest) == DImode)\n@@ -4194,6 +4245,41 @@ mips_split_doubleword_move (rtx dest, rtx src)\n \t}\n     }\n }\n+\n+/* Return the split type for instruction INSN.  */\n+\n+static enum mips_split_type\n+mips_insn_split_type (rtx insn)\n+{\n+  basic_block bb = BLOCK_FOR_INSN (insn);\n+  if (bb)\n+    {\n+      if (optimize_bb_for_speed_p (bb))\n+\treturn SPLIT_FOR_SPEED;\n+      else\n+\treturn SPLIT_FOR_SIZE;\n+    }\n+  /* Once CFG information has been removed, we should trust the optimization\n+     decisions made by previous passes and only split where necessary.  */\n+  return SPLIT_IF_NECESSARY;\n+}\n+\n+/* Return true if a move from SRC to DEST in INSN should be split.  */\n+\n+bool\n+mips_split_move_insn_p (rtx dest, rtx src, rtx insn)\n+{\n+  return mips_split_move_p (dest, src, mips_insn_split_type (insn));\n+}\n+\n+/* Split a move from SRC to DEST in INSN, given that mips_split_move_insn_p\n+   holds.  */\n+\n+void\n+mips_split_move_insn (rtx dest, rtx src, rtx insn)\n+{\n+  mips_split_move (dest, src, mips_insn_split_type (insn));\n+}\n \f\n /* Return the appropriate instructions to move SRC into DEST.  Assume\n    that SRC is operand 1 and DEST is operand 0.  */\n@@ -4211,7 +4297,7 @@ mips_output_move (rtx dest, rtx src)\n   mode = GET_MODE (dest);\n   dbl_p = (GET_MODE_SIZE (mode) == 8);\n \n-  if (dbl_p && mips_split_64bit_move_p (dest, src))\n+  if (mips_split_move_p (dest, src, SPLIT_IF_NECESSARY))\n     return \"#\";\n \n   if ((src_code == REG && GP_REG_P (REGNO (src)))\n@@ -4222,6 +4308,14 @@ mips_output_move (rtx dest, rtx src)\n \t  if (GP_REG_P (REGNO (dest)))\n \t    return \"move\\t%0,%z1\";\n \n+\t  if (mips_mult_move_p (dest, src, SPLIT_IF_NECESSARY))\n+\t    {\n+\t      if (ISA_HAS_DSP_MULT)\n+\t\treturn \"mult\\t%q0,%.,%.\";\n+\t      else\n+\t\treturn \"mult\\t%.,%.\";\n+\t    }\n+\n \t  /* Moves to HI are handled by special .md insns.  */\n \t  if (REGNO (dest) == LO_REGNUM)\n \t    return \"mtlo\\t%z1\";\n@@ -10432,10 +10526,7 @@ mips_save_reg (rtx reg, rtx mem)\n     {\n       rtx x1, x2;\n \n-      if (mips_split_64bit_move_p (mem, reg))\n-\tmips_split_doubleword_move (mem, reg);\n-      else\n-\tmips_emit_move (mem, reg);\n+      mips_emit_move_or_split (mem, reg, SPLIT_IF_NECESSARY);\n \n       x1 = mips_frame_set (mips_subword (mem, false),\n \t\t\t   mips_subword (reg, false));\n@@ -14895,10 +14986,15 @@ struct mips_sim {\n static void\n mips_sim_reset (struct mips_sim *state)\n {\n+  curr_state = state->dfa_state;\n+\n   state->time = 0;\n   state->insns_left = state->issue_rate;\n   memset (&state->last_set, 0, sizeof (state->last_set));\n-  state_reset (state->dfa_state);\n+  state_reset (curr_state);\n+\n+  targetm.sched.init (0, false, 0);\n+  advance_state (curr_state);\n }\n \n /* Initialize STATE before its first use.  DFA_STATE points to an\n@@ -14907,6 +15003,12 @@ mips_sim_reset (struct mips_sim *state)\n static void\n mips_sim_init (struct mips_sim *state, state_t dfa_state)\n {\n+  if (targetm.sched.init_dfa_pre_cycle_insn)\n+    targetm.sched.init_dfa_pre_cycle_insn ();\n+\n+  if (targetm.sched.init_dfa_post_cycle_insn)\n+    targetm.sched.init_dfa_post_cycle_insn ();\n+\n   state->issue_rate = mips_issue_rate ();\n   state->dfa_state = dfa_state;\n   mips_sim_reset (state);\n@@ -14917,9 +15019,11 @@ mips_sim_init (struct mips_sim *state, state_t dfa_state)\n static void\n mips_sim_next_cycle (struct mips_sim *state)\n {\n+  curr_state = state->dfa_state;\n+\n   state->time++;\n   state->insns_left = state->issue_rate;\n-  state_transition (state->dfa_state, 0);\n+  advance_state (curr_state);\n }\n \n /* Advance simulation state STATE until instruction INSN can read\n@@ -15025,8 +15129,11 @@ mips_sim_record_set (rtx x, const_rtx pat ATTRIBUTE_UNUSED, void *data)\n static void\n mips_sim_issue_insn (struct mips_sim *state, rtx insn)\n {\n-  state_transition (state->dfa_state, insn);\n-  state->insns_left--;\n+  curr_state = state->dfa_state;\n+\n+  state_transition (curr_state, insn);\n+  state->insns_left = targetm.sched.variable_issue (0, false, insn,\n+\t\t\t\t\t\t    state->insns_left);\n \n   mips_sim_insn = insn;\n   note_stores (PATTERN (insn), mips_sim_record_set, state);\n@@ -15077,6 +15184,109 @@ mips_sim_finish_insn (struct mips_sim *state, rtx insn)\n       break;\n     }\n }\n+\n+/* Use simulator state STATE to calculate the execution time of\n+   instruction sequence SEQ.  */\n+\n+static unsigned int\n+mips_seq_time (struct mips_sim *state, rtx seq)\n+{\n+  mips_sim_reset (state);\n+  for (rtx insn = seq; insn; insn = NEXT_INSN (insn))\n+    {\n+      mips_sim_wait_insn (state, insn);\n+      mips_sim_issue_insn (state, insn);\n+    }\n+  return state->time;\n+}\n+\f\n+/* Return the execution-time cost of mips_tuning_info.fast_mult_zero_zero_p\n+   setting SETTING, using STATE to simulate instruction sequences.  */\n+\n+static unsigned int\n+mips_mult_zero_zero_cost (struct mips_sim *state, bool setting)\n+{\n+  mips_tuning_info.fast_mult_zero_zero_p = setting;\n+  start_sequence ();\n+\n+  enum machine_mode dword_mode = TARGET_64BIT ? TImode : DImode;\n+  rtx hilo = gen_rtx_REG (dword_mode, MD_REG_FIRST);\n+  mips_emit_move_or_split (hilo, const0_rtx, SPLIT_FOR_SPEED);\n+\n+  /* If the target provides mulsidi3_32bit then that's the most likely\n+     consumer of the result.  Test for bypasses.  */\n+  if (dword_mode == DImode && HAVE_maddsidi4)\n+    {\n+      rtx gpr = gen_rtx_REG (SImode, GP_REG_FIRST + 4);\n+      emit_insn (gen_maddsidi4 (hilo, gpr, gpr, hilo));\n+    }\n+\n+  unsigned int time = mips_seq_time (state, get_insns ());\n+  end_sequence ();\n+  return time;\n+}\n+\n+/* Check the relative speeds of \"MULT $0,$0\" and \"MTLO $0; MTHI $0\"\n+   and set up mips_tuning_info.fast_mult_zero_zero_p accordingly.\n+   Prefer MULT -- which is shorter -- in the event of a tie.  */\n+\n+static void\n+mips_set_fast_mult_zero_zero_p (struct mips_sim *state)\n+{\n+  if (TARGET_MIPS16)\n+    /* No MTLO or MTHI available.  */\n+    mips_tuning_info.fast_mult_zero_zero_p = true;\n+  else\n+    {\n+      unsigned int true_time = mips_mult_zero_zero_cost (state, true);\n+      unsigned int false_time = mips_mult_zero_zero_cost (state, false);\n+      mips_tuning_info.fast_mult_zero_zero_p = (true_time <= false_time);\n+    }\n+}\n+\n+/* Set up costs based on the current architecture and tuning settings.  */\n+\n+static void\n+mips_set_tuning_info (void)\n+{\n+  if (mips_tuning_info.initialized_p\n+      && mips_tuning_info.arch == mips_arch\n+      && mips_tuning_info.tune == mips_tune\n+      && mips_tuning_info.mips16_p == TARGET_MIPS16)\n+    return;\n+\n+  mips_tuning_info.arch = mips_arch;\n+  mips_tuning_info.tune = mips_tune;\n+  mips_tuning_info.mips16_p = TARGET_MIPS16;\n+  mips_tuning_info.initialized_p = true;\n+\n+  dfa_start ();\n+\n+  struct mips_sim state;\n+  mips_sim_init (&state, alloca (state_size ()));\n+\n+  mips_set_fast_mult_zero_zero_p (&state);\n+\n+  dfa_finish ();\n+}\n+\n+/* Implement TARGET_EXPAND_TO_RTL_HOOK.  */\n+\n+static void\n+mips_expand_to_rtl_hook (void)\n+{\n+  /* We need to call this at a point where we can safely create sequences\n+     of instructions, so TARGET_OVERRIDE_OPTIONS is too early.  We also\n+     need to call it at a point where the DFA infrastructure is not\n+     already in use, so we can't just call it lazily on demand.\n+\n+     At present, mips_tuning_info is only needed during post-expand\n+     RTL passes such as split_insns, so this hook should be early enough.\n+     We may need to move the call elsewhere if mips_tuning_info starts\n+     to be used for other things (such as rtx_costs, or expanders that\n+     could be called during gimple optimization).  */\n+  mips_set_tuning_info ();\n+}\n \f\n /* The VR4130 pipeline issues aligned pairs of instructions together,\n    but it stalls the second instruction if it depends on the first.\n@@ -17748,6 +17958,8 @@ mips_expand_vec_minmax (rtx target, rtx op0, rtx op1,\n #undef  TARGET_PREFERRED_RELOAD_CLASS\n #define TARGET_PREFERRED_RELOAD_CLASS mips_preferred_reload_class\n \n+#undef TARGET_EXPAND_TO_RTL_HOOK\n+#define TARGET_EXPAND_TO_RTL_HOOK mips_expand_to_rtl_hook\n #undef TARGET_ASM_FILE_START\n #define TARGET_ASM_FILE_START mips_file_start\n #undef TARGET_ASM_FILE_START_FILE_DIRECTIVE"}, {"sha": "70455ee04828701f32a2d9ab7bc2a98492edf997", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4670abb087ca8bb5e8fc75652648c99c90f48ab0/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4670abb087ca8bb5e8fc75652648c99c90f48ab0/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=4670abb087ca8bb5e8fc75652648c99c90f48ab0", "patch": "@@ -204,7 +204,7 @@\n ;; the split instructions; in some cases, it is more appropriate for the\n ;; scheduling type to be \"multi\" instead.\n (define_attr \"move_type\"\n-  \"unknown,load,fpload,store,fpstore,mtc,mfc,mtlo,mflo,move,fmove,\n+  \"unknown,load,fpload,store,fpstore,mtc,mfc,mtlo,mflo,imul,move,fmove,\n    const,constN,signext,ext_ins,logical,arith,sll0,andi,loadpool,\n    shift_shift\"\n   (const_string \"unknown\"))\n@@ -369,6 +369,7 @@\n \t (eq_attr \"move_type\" \"mflo\") (const_string \"mflo\")\n \n \t ;; These types of move are always single insns.\n+\t (eq_attr \"move_type\" \"imul\") (const_string \"imul\")\n \t (eq_attr \"move_type\" \"fmove\") (const_string \"fmove\")\n \t (eq_attr \"move_type\" \"loadpool\") (const_string \"load\")\n \t (eq_attr \"move_type\" \"signext\") (const_string \"signext\")\n@@ -4243,14 +4244,17 @@\n    (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn \"*movdi_32bit\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,d,d,m,*a,*d,*f,*f,*d,*m,*B*C*D,*B*C*D,*d,*m\")\n-\t(match_operand:DI 1 \"move_operand\" \"d,i,m,d,*J*d,*a,*J*d,*m,*f,*f,*d,*m,*B*C*D,*B*C*D\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,d,d,m,*a,*a,*d,*f,*f,*d,*m,*B*C*D,*B*C*D,*d,*m\")\n+\t(match_operand:DI 1 \"move_operand\" \"d,i,m,d,*J,*d,*a,*J*d,*m,*f,*f,*d,*m,*B*C*D,*B*C*D\"))]\n   \"!TARGET_64BIT && !TARGET_MIPS16\n    && (register_operand (operands[0], DImode)\n        || reg_or_0_operand (operands[1], DImode))\"\n   { return mips_output_move (operands[0], operands[1]); }\n-  [(set_attr \"move_type\" \"move,const,load,store,mtlo,mflo,mtc,fpload,mfc,fpstore,mtc,fpload,mfc,fpstore\")\n-   (set_attr \"mode\" \"DI\")])\n+  [(set_attr \"move_type\" \"move,const,load,store,imul,mtlo,mflo,mtc,fpload,mfc,fpstore,mtc,fpload,mfc,fpstore\")\n+   (set (attr \"mode\")\n+   \t(if_then_else (eq_attr \"move_type\" \"imul\")\n+\t\t      (const_string \"SI\")\n+\t\t      (const_string \"DI\")))])\n \n (define_insn \"*movdi_32bit_mips16\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,y,d,d,d,d,m,*d\")\n@@ -4696,15 +4700,18 @@\n })\n \n (define_insn \"*movti\"\n-  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=d,d,d,m,*a,*d\")\n-\t(match_operand:TI 1 \"move_operand\" \"d,i,m,dJ,*d*J,*a\"))]\n+  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=d,d,d,m,*a,*a,*d\")\n+\t(match_operand:TI 1 \"move_operand\" \"d,i,m,dJ,*J,*d,*a\"))]\n   \"TARGET_64BIT\n    && !TARGET_MIPS16\n    && (register_operand (operands[0], TImode)\n        || reg_or_0_operand (operands[1], TImode))\"\n-  \"#\"\n-  [(set_attr \"move_type\" \"move,const,load,store,mtlo,mflo\")\n-   (set_attr \"mode\" \"TI\")])\n+  { return mips_output_move (operands[0], operands[1]); }\n+  [(set_attr \"move_type\" \"move,const,load,store,imul,mtlo,mflo\")\n+   (set (attr \"mode\")\n+   \t(if_then_else (eq_attr \"move_type\" \"imul\")\n+\t\t      (const_string \"SI\")\n+\t\t      (const_string \"TI\")))])\n \n (define_insn \"*movti_mips16\"\n   [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=d,y,d,d,d,d,m,*d\")\n@@ -4754,21 +4761,20 @@\n (define_split\n   [(set (match_operand:MOVE64 0 \"nonimmediate_operand\")\n \t(match_operand:MOVE64 1 \"move_operand\"))]\n-  \"reload_completed && !TARGET_64BIT\n-   && mips_split_64bit_move_p (operands[0], operands[1])\"\n+  \"reload_completed && mips_split_move_insn_p (operands[0], operands[1], insn)\"\n   [(const_int 0)]\n {\n-  mips_split_doubleword_move (operands[0], operands[1]);\n+  mips_split_move_insn (operands[0], operands[1], curr_insn);\n   DONE;\n })\n \n (define_split\n   [(set (match_operand:MOVE128 0 \"nonimmediate_operand\")\n \t(match_operand:MOVE128 1 \"move_operand\"))]\n-  \"TARGET_64BIT && reload_completed\"\n+  \"reload_completed && mips_split_move_insn_p (operands[0], operands[1], insn)\"\n   [(const_int 0)]\n {\n-  mips_split_doubleword_move (operands[0], operands[1]);\n+  mips_split_move_insn (operands[0], operands[1], curr_insn);\n   DONE;\n })\n "}, {"sha": "32576db57bc986892b2cecb0248540fb89330abc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4670abb087ca8bb5e8fc75652648c99c90f48ab0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4670abb087ca8bb5e8fc75652648c99c90f48ab0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4670abb087ca8bb5e8fc75652648c99c90f48ab0", "patch": "@@ -1,3 +1,11 @@\n+2012-10-07  Richard Sandiford  <rdsandiford@googlemail.com>\n+\t    Sandra Loosemore  <sandra@codesourcery.com>\n+\n+\t* gcc.target/mips/madd-9.c: Force code to be tuned for the 4kc\n+\tand test that the accumulator is initialized using MULT.\n+\t* gcc.target/mips/mips32-dsp-accinit-1.c: New test.\n+\t* gcc.target/mips/mips32-dsp-accinit-2.c: Likewise.\n+\n 2012-10-06  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/52764"}, {"sha": "28681a910029839f5b4449821be5edd00268e3a1", "filename": "gcc/testsuite/gcc.target/mips/madd-9.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4670abb087ca8bb5e8fc75652648c99c90f48ab0/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmadd-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4670abb087ca8bb5e8fc75652648c99c90f48ab0/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmadd-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmadd-9.c?ref=4670abb087ca8bb5e8fc75652648c99c90f48ab0", "patch": "@@ -1,7 +1,13 @@\n /* { dg-do compile } */\n-/* { dg-options \"isa_rev>=1 -mgp32\" } */\n-/* { dg-skip-if \"code quality test\" { *-*-* } { \"-O0\" } { \"\" } } */\n+/* { dg-options \"isa_rev>=1 -mgp32 -mtune=4kc\" } */\n+/* References to X within the loop need to have a higher frequency than\n+   references to X outside the loop, otherwise there is no reason\n+   to prefer multiply/accumulator registers over GPRs.  */\n+/* { dg-skip-if \"requires register frequencies\" { *-*-* } { \"-O0\" \"-Os\" } { \"\" } } */\n /* { dg-final { scan-assembler-not \"\\tmul\\t\" } } */\n+/* { dg-final { scan-assembler-not \"\\tmthi\" } } */\n+/* { dg-final { scan-assembler-not \"\\tmtlo\" } } */\n+/* { dg-final { scan-assembler \"\\tmult\\t\" } } */\n /* { dg-final { scan-assembler \"\\tmadd\\t\" } } */\n \n NOMIPS16 long long"}, {"sha": "d26f998407dd1166118347f41875f29c8668b7e1", "filename": "gcc/testsuite/gcc.target/mips/mips32-dsp-accinit-1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4670abb087ca8bb5e8fc75652648c99c90f48ab0/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips32-dsp-accinit-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4670abb087ca8bb5e8fc75652648c99c90f48ab0/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips32-dsp-accinit-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips32-dsp-accinit-1.c?ref=4670abb087ca8bb5e8fc75652648c99c90f48ab0", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-options \"-mdspr2 -mgp32 -mtune=74kc\" } */\n+/* References to RESULT within the loop need to have a higher frequency than\n+   references to RESULT outside the loop, otherwise there is no reason\n+   to prefer multiply/accumulator registers over GPRs.  */\n+/* { dg-skip-if \"requires register frequencies\" { *-*-* } { \"-O0\" \"-Os\" } { \"\" } } */\n+\n+/* Check that the zero-initialization of the accumulator feeding into\n+   the madd is done by means of a mult instruction instead of mthi/mtlo.  */\n+\n+NOMIPS16 long long f (int n, int *v, int m)\n+{\n+  long long result = 0;\n+  int i;\n+\n+  for (i = 0; i < n; i++)\n+    result = __builtin_mips_madd (result, v[i], m);\n+  return result;\n+}\n+\n+/* { dg-final { scan-assembler \"\\tmult\\t\\\\\\$ac.,\\\\\\$0,\\\\\\$0\" } } */\n+/* { dg-final { scan-assembler-not \"mthi\\t\" } } */\n+/* { dg-final { scan-assembler-not \"mtlo\\t\" } } */"}, {"sha": "8d06a8039a1b26f7a28eda05e5b639bfe65a2459", "filename": "gcc/testsuite/gcc.target/mips/mips32-dsp-accinit-2.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4670abb087ca8bb5e8fc75652648c99c90f48ab0/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips32-dsp-accinit-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4670abb087ca8bb5e8fc75652648c99c90f48ab0/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips32-dsp-accinit-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips32-dsp-accinit-2.c?ref=4670abb087ca8bb5e8fc75652648c99c90f48ab0", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-options \"-mdspr2 -mgp32 -mtune=4kp\" } */\n+/* References to RESULT within the loop need to have a higher frequency than\n+   references to RESULT outside the loop, otherwise there is no reason\n+   to prefer multiply/accumulator registers over GPRs.  */\n+/* { dg-skip-if \"requires register frequencies\" { *-*-* } { \"-O0\" \"-Os\" } { \"\" } } */\n+\n+/* Check that the zero-initialization of the accumulator feeding into\n+   the madd is done by means of a mult instruction instead of mthi/mtlo.  */\n+\n+NOMIPS16 long long f (int n, int *v, int m)\n+{\n+  long long result = 0;\n+  int i;\n+\n+  for (i = 0; i < n; i++)\n+    result = __builtin_mips_madd (result, v[i], m);\n+  return result;\n+}\n+\n+/* { dg-final { scan-assembler-not \"mult\\t\\[^\\n\\]*\\\\\\$0\" } } */\n+/* { dg-final { scan-assembler \"\\tmthi\\t\" } } */\n+/* { dg-final { scan-assembler \"\\tmtlo\\t\" } } */"}]}