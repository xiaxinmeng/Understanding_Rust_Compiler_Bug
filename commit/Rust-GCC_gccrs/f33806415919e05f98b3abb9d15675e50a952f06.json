{"sha": "f33806415919e05f98b3abb9d15675e50a952f06", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjMzODA2NDE1OTE5ZTA1Zjk4YjNhYmI5ZDE1Njc1ZTUwYTk1MmYwNg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-05-15T16:57:35Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-05-15T16:57:35Z"}, "message": "ipa-reference.c: Include toplev.h\n\n\t* ipa-reference.c: Include toplev.h\n\t(is_proper_for_analysis): Only add to all_module_statics\n\tif it is allocated.\n\t(write_node_summary_p, stream_out_bitmap,\n\tipa_reference_write_optimization_summary,\n\tipa_reference_read_optimization_summary): New.\n\t(struct ipa_opt_pass_d pass_ipa_reference): Add\n\toptimization summary streaming.\n\t* lto-cgraph.c (referenced_from_this_partition_p, \n\treachable_from_this_partition_p): New functions.\n\t* tree-ssa-alias.c (ref_maybe_used_by_call_p_1,\n\tcall_may_clobber_ref_p_1): Ask ipa-reference even for public vars.\n\t* opts.c (decode_options): Enable ipa_reference.\n\t* Makefile.in (ipa-reference.o): Add toplev.h dependency.\n\t* lto-streamer.h (referenced_from_this_partition_p,\n\treachable_from_this_partition_p): Declare.\n\n\t* gcc.dg/lto/ipareference_1.c: New file.\n\t* gcc.dg/lto/ipareference_2.c: New file.\n\nFrom-SVN: r159435", "tree": {"sha": "e23962de964283fea3e75b010a09768f298bb93b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e23962de964283fea3e75b010a09768f298bb93b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f33806415919e05f98b3abb9d15675e50a952f06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f33806415919e05f98b3abb9d15675e50a952f06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f33806415919e05f98b3abb9d15675e50a952f06", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f33806415919e05f98b3abb9d15675e50a952f06/comments", "author": null, "committer": null, "parents": [{"sha": "9d0baae10e10d02ba0f09215f7b70461bd21ebb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d0baae10e10d02ba0f09215f7b70461bd21ebb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d0baae10e10d02ba0f09215f7b70461bd21ebb0"}], "stats": {"total": 400, "additions": 364, "deletions": 36}, "files": [{"sha": "9971c4d91b1894157e26f3663ed8aca3a600fe90", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f33806415919e05f98b3abb9d15675e50a952f06/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f33806415919e05f98b3abb9d15675e50a952f06/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f33806415919e05f98b3abb9d15675e50a952f06", "patch": "@@ -1,3 +1,22 @@\n+2010-05-15  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-reference.c: Include toplev.h\n+\t(is_proper_for_analysis): Only add to all_module_statics\n+\tif it is allocated.\n+\t(write_node_summary_p, stream_out_bitmap,\n+\tipa_reference_write_optimization_summary,\n+\tipa_reference_read_optimization_summary): New.\n+\t(struct ipa_opt_pass_d pass_ipa_reference): Add\n+\toptimization summary streaming.\n+\t* lto-cgraph.c (referenced_from_this_partition_p, \n+\treachable_from_this_partition_p): New functions.\n+\t* tree-ssa-alias.c (ref_maybe_used_by_call_p_1,\n+\tcall_may_clobber_ref_p_1): Ask ipa-reference even for public vars.\n+\t* opts.c (decode_options): Enable ipa_reference.\n+\t* Makefile.in (ipa-reference.o): Add toplev.h dependency.\n+\t* lto-streamer.h (referenced_from_this_partition_p,\n+\treachable_from_this_partition_p): Declare.\n+\n 2010-05-15  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/44038"}, {"sha": "d3f450f1e12cfb78913e22df678330d65c9cbc88", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f33806415919e05f98b3abb9d15675e50a952f06/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f33806415919e05f98b3abb9d15675e50a952f06/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=f33806415919e05f98b3abb9d15675e50a952f06", "patch": "@@ -2929,7 +2929,7 @@ ipa-reference.o : ipa-reference.c $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TM_H) $(TREE_H) $(TREE_FLOW_H) $(TREE_INLINE_H) langhooks.h \\\n    pointer-set.h $(GGC_H) $(IPA_REFERENCE_H) $(IPA_UTILS_H) $(SPLAY_TREE_H) \\\n    $(GIMPLE_H) $(CGRAPH_H) output.h $(FLAGS_H) $(TREE_PASS_H) \\\n-   $(TIMEVAR_H) $(DIAGNOSTIC_H) $(FUNCTION_H) $(LTO_STREAMER_H)\n+   $(TIMEVAR_H) $(DIAGNOSTIC_H) $(FUNCTION_H) $(LTO_STREAMER_H) $(TOPLEV_H)\n ipa-pure-const.o : ipa-pure-const.c $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TM_H) $(TREE_H) $(TREE_FLOW_H) $(TREE_INLINE_H) langhooks.h \\\n    pointer-set.h $(GGC_H) $(IPA_UTILS_H) $(TARGET_H) \\"}, {"sha": "0b04a6655098493d41cf4a0288765c6354c9bf69", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 207, "deletions": 3, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f33806415919e05f98b3abb9d15675e50a952f06/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f33806415919e05f98b3abb9d15675e50a952f06/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=f33806415919e05f98b3abb9d15675e50a952f06", "patch": "@@ -59,6 +59,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic.h\"\n #include \"langhooks.h\"\n #include \"lto-streamer.h\"\n+#include \"toplev.h\"\n \n static void remove_node_data (struct cgraph_node *node,\n \t\t\t      void *data ATTRIBUTE_UNUSED);\n@@ -272,7 +273,8 @@ is_proper_for_analysis (tree t)\n \n   /* This is a variable we care about.  Check if we have seen it\n      before, and if not add it the set of variables we care about.  */\n-  if (!bitmap_bit_p (all_module_statics, DECL_UID (t)))\n+  if (all_module_statics\n+      && !bitmap_bit_p (all_module_statics, DECL_UID (t)))\n     add_static_var (t);\n \n   return true;\n@@ -884,6 +886,208 @@ propagate (void)\n   return 0;\n }\n \n+/* Return true if we need to write summary of NODE. */\n+\n+static bool\n+write_node_summary_p (struct cgraph_node *node,\n+\t\t      cgraph_node_set set,\n+\t\t      varpool_node_set vset,\n+\t\t      bitmap ltrans_statics)\n+{\n+  ipa_reference_optimization_summary_t info;\n+\n+  /* See if we have (non-empty) info.  */\n+  if (!node->analyzed || node->global.inlined_to)\n+    return false;\n+  info = get_reference_optimization_summary (node);\n+  if (!info || (bitmap_empty_p (info->statics_not_read)\n+\t\t&& bitmap_empty_p (info->statics_not_written)))\n+    return false;\n+\n+  /* See if we want to encode it.\n+     Encode also referenced functions since constant folding might turn it into\n+     a direct call.\n+\n+     In future we might also want to include summaries of functions references\n+     by initializers of constant variables references in current unit.  */\n+  if (!reachable_from_this_partition_p (node, set)\n+      && !referenced_from_this_partition_p (&node->ref_list, set, vset))\n+    return false;\n+\n+  /* See if the info has non-empty intersections with vars we want to encode.  */\n+  if (!bitmap_intersect_p (info->statics_not_read, ltrans_statics)\n+      && !bitmap_intersect_p (info->statics_not_written, ltrans_statics))\n+    return false;\n+  return true;\n+}\n+\n+/* Stream out BITS&LTRANS_STATICS as list of decls to OB.  */\n+\n+static void\n+stream_out_bitmap (struct lto_simple_output_block *ob,\n+\t\t   bitmap bits, bitmap ltrans_statics)\n+{\n+  unsigned int count = 0;\n+  unsigned int index;\n+  bitmap_iterator bi;\n+  EXECUTE_IF_AND_IN_BITMAP (bits, ltrans_statics, 0, index, bi)\n+    count ++;\n+  lto_output_uleb128_stream (ob->main_stream, count);\n+  if (!count)\n+    return;\n+  EXECUTE_IF_AND_IN_BITMAP (bits, ltrans_statics, 0, index, bi)\n+    {\n+      tree decl = (tree)splay_tree_lookup (reference_vars_to_consider, index)->value;\n+      lto_output_var_decl_index(ob->decl_state, ob->main_stream, decl);\n+    }\n+}\n+\n+/* Serialize the ipa info for lto.  */\n+\n+static void\n+ipa_reference_write_optimization_summary (cgraph_node_set set,\n+\t\t\t\t\t  varpool_node_set vset)\n+{\n+  struct cgraph_node *node;\n+  struct varpool_node *vnode;\n+  struct lto_simple_output_block *ob\n+    = lto_create_simple_output_block (LTO_section_ipa_reference);\n+  unsigned int count = 0;\n+  lto_cgraph_encoder_t encoder = ob->decl_state->cgraph_node_encoder;\n+  bitmap ltrans_statics = BITMAP_ALLOC (NULL);\n+\n+  reference_vars_to_consider = splay_tree_new (splay_tree_compare_ints, 0, 0);\n+\n+  /* See what variables we are interested in.  */\n+  for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n+    if (referenced_from_this_partition_p (&vnode->ref_list, set, vset))\n+      {\n+\ttree decl = vnode->decl;\n+\tif (is_proper_for_analysis (decl))\n+\t  {\n+\t    bitmap_set_bit (ltrans_statics, DECL_UID (decl));\n+\t    splay_tree_insert (reference_vars_to_consider,\n+\t\t\t       DECL_UID (decl), (splay_tree_value)decl);\n+\t  }\n+      }\n+\n+  for (node = cgraph_nodes; node; node = node->next)\n+    if (write_node_summary_p (node, set, vset, ltrans_statics))\n+\tcount++;\n+\n+  lto_output_uleb128_stream (ob->main_stream, count);\n+\n+  /* Process all of the functions.  */\n+  for (node = cgraph_nodes; node; node = node->next)\n+    if (write_node_summary_p (node, set, vset, ltrans_statics))\n+      {\n+\tipa_reference_optimization_summary_t info;\n+\tint node_ref;\n+\n+\tinfo = get_reference_optimization_summary (node);\n+\tnode_ref = lto_cgraph_encoder_encode (encoder, node);\n+\tlto_output_uleb128_stream (ob->main_stream, node_ref);\n+\n+\tstream_out_bitmap (ob, info->statics_not_read, ltrans_statics);\n+\tstream_out_bitmap (ob, info->statics_not_written, ltrans_statics);\n+      }\n+  BITMAP_FREE (ltrans_statics);\n+  lto_destroy_simple_output_block (ob);\n+  splay_tree_delete (reference_vars_to_consider);\n+}\n+\n+/* Deserialize the ipa info for lto.  */\n+\n+static void\n+ipa_reference_read_optimization_summary (void)\n+{\n+  struct lto_file_decl_data ** file_data_vec\n+    = lto_get_file_decl_data ();\n+  struct lto_file_decl_data * file_data;\n+  unsigned int j = 0;\n+  bitmap_obstack_initialize (&optimization_summary_obstack);\n+\n+  node_removal_hook_holder =\n+      cgraph_add_node_removal_hook (&remove_node_data, NULL);\n+  node_duplication_hook_holder =\n+      cgraph_add_node_duplication_hook (&duplicate_node_data, NULL);\n+\n+  while ((file_data = file_data_vec[j++]))\n+    {\n+      const char *data;\n+      size_t len;\n+      struct lto_input_block *ib\n+\t= lto_create_simple_input_block (file_data,\n+\t\t\t\t\t LTO_section_ipa_reference,\n+\t\t\t\t\t &data, &len);\n+      if (ib)\n+\t{\n+\t  unsigned int i;\n+\t  unsigned int f_count = lto_input_uleb128 (ib);\n+\n+\t  for (i = 0; i < f_count; i++)\n+\t    {\n+\t      unsigned int j, index;\n+\t      struct cgraph_node *node;\n+\t      ipa_reference_optimization_summary_t info;\n+\t      int v_count;\n+\t      lto_cgraph_encoder_t encoder;\n+\n+\t      index = lto_input_uleb128 (ib);\n+\t      encoder = file_data->cgraph_node_encoder;\n+\t      node = lto_cgraph_encoder_deref (encoder, index);\n+\t      info = XCNEW (struct ipa_reference_optimization_summary_d);\n+\t      set_reference_optimization_summary (node, info);\n+\t      info->statics_not_read = BITMAP_ALLOC (&optimization_summary_obstack);\n+\t      info->statics_not_written = BITMAP_ALLOC (&optimization_summary_obstack);\n+\t      if (dump_file)\n+\t\tfprintf (dump_file,\n+\t\t\t \"\\nFunction name:%s/%i:\\n  static not read:\",\n+\t\t\t cgraph_node_name (node), node->uid);\n+\n+\t      /* Set the statics not read.  */\n+\t      v_count = lto_input_uleb128 (ib);\n+\t      for (j = 0; j < (unsigned int)v_count; j++)\n+\t\t{\n+\t\t  unsigned int var_index = lto_input_uleb128 (ib);\n+\t\t  tree v_decl = lto_file_decl_data_get_var_decl (file_data,\n+\t\t\t\t\t\t\t\t var_index);\n+\t\t  bitmap_set_bit (info->statics_not_read, DECL_UID (v_decl));\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file, \" %s\",\n+\t\t\t     lang_hooks.decl_printable_name (v_decl, 2));\n+\t\t}\n+\n+\t      if (dump_file)\n+\t\tfprintf (dump_file,\n+\t\t\t \"\\n  static not written:\");\n+\t      /* Set the statics not written.  */\n+\t      v_count = lto_input_uleb128 (ib);\n+\t      for (j = 0; j < (unsigned int)v_count; j++)\n+\t\t{\n+\t\t  unsigned int var_index = lto_input_uleb128 (ib);\n+\t\t  tree v_decl = lto_file_decl_data_get_var_decl (file_data,\n+\t\t\t\t\t\t\t\t var_index);\n+\t\t  bitmap_set_bit (info->statics_not_written, DECL_UID (v_decl));\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file, \" %s\",\n+\t\t\t     lang_hooks.decl_printable_name (v_decl, 2));\n+\t\t}\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"\\n\");\n+\t    }\n+\n+\t  lto_destroy_simple_input_block (file_data,\n+\t\t\t\t\t  LTO_section_ipa_reference,\n+\t\t\t\t\t  ib, data, len);\n+\t}\n+      else\n+\t/* Fatal error here.  We do not want to support compiling ltrans units with\n+\t   different version of compiler or different flags than the WPA unit, so\n+\t   this should never happen.  */\n+\tfatal_error (\"ipa reference summary is missing in ltrans unit\");\n+    }\n+}\n \n static bool\n gate_reference (void)\n@@ -913,8 +1117,8 @@ struct ipa_opt_pass_d pass_ipa_reference =\n  NULL,\t\t\t\t        /* generate_summary */\n  NULL,\t\t\t\t\t/* write_summary */\n  NULL,\t\t\t\t \t/* read_summary */\n- NULL,\t\t\t\t\t/* write_optimization_summary */\n- NULL,\t\t\t\t\t/* read_optimization_summary */\n+ ipa_reference_write_optimization_summary,/* write_optimization_summary */\n+ ipa_reference_read_optimization_summary,/* read_optimization_summary */\n  NULL,\t\t\t\t\t/* stmt_fixup */\n  0,\t\t\t\t\t/* TODOs */\n  NULL,\t\t\t                /* function_transform */"}, {"sha": "acac0e03d131aba213f04f21d175966f8d4499a3", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 80, "deletions": 23, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f33806415919e05f98b3abb9d15675e50a952f06/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f33806415919e05f98b3abb9d15675e50a952f06/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=f33806415919e05f98b3abb9d15675e50a952f06", "patch": "@@ -302,6 +302,7 @@ lto_output_edge (struct lto_simple_output_block *ob, struct cgraph_edge *edge,\n }\n \n /* Return if LIST contain references from other partitions.  */\n+\n bool\n referenced_from_other_partition_p (struct ipa_ref_list *list, cgraph_node_set set,\n \t\t\t\t   varpool_node_set vset)\n@@ -341,6 +342,47 @@ reachable_from_other_partition_p (struct cgraph_node *node, cgraph_node_set set)\n   return false;\n }\n \n+/* Return if LIST contain references from other partitions.  */\n+\n+bool\n+referenced_from_this_partition_p (struct ipa_ref_list *list, cgraph_node_set set,\n+\t\t\t\t  varpool_node_set vset)\n+{\n+  int i;\n+  struct ipa_ref *ref;\n+  for (i = 0; ipa_ref_list_refering_iterate (list, i, ref); i++)\n+    {\n+      if (ref->refering_type == IPA_REF_CGRAPH)\n+\t{\n+\t  if (cgraph_node_in_set_p (ipa_ref_refering_node (ref), set))\n+\t    return true;\n+\t}\n+      else\n+\t{\n+\t  if (varpool_node_in_set_p (ipa_ref_refering_varpool_node (ref),\n+\t\t\t\t     vset))\n+\t    return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n+/* Return true when node is reachable from other partition.  */\n+\n+bool\n+reachable_from_this_partition_p (struct cgraph_node *node, cgraph_node_set set)\n+{\n+  struct cgraph_edge *e;\n+  if (!node->analyzed)\n+    return false;\n+  if (node->global.inlined_to)\n+    return false;\n+  for (e = node->callers; e; e = e->next_caller)\n+    if (cgraph_node_in_set_p (e->caller, set))\n+      return true;\n+  return false;\n+}\n+\n /* Output the cgraph NODE to OB.  ENCODER is used to find the\n    reference number of NODE->inlined_to.  SET is the set of nodes we\n    are writing to the current file.  If NODE is not in SET, then NODE\n@@ -694,38 +736,22 @@ output_refs (cgraph_node_set set, varpool_node_set vset,\n   lto_destroy_simple_output_block (ob);\n }\n \n-\n-/* Output the part of the cgraph in SET.  */\n-\n+/* Find out all cgraph and varpool nodes we want to encode in current unit\n+   and insert them to encoders.  */\n void\n-output_cgraph (cgraph_node_set set, varpool_node_set vset)\n+compute_ltrans_boundary (struct lto_out_decl_state *state,\n+\t\t\t cgraph_node_set set, varpool_node_set vset)\n {\n   struct cgraph_node *node;\n-  struct lto_simple_output_block *ob;\n   cgraph_node_set_iterator csi;\n   varpool_node_set_iterator vsi;\n   struct cgraph_edge *edge;\n-  int i, n_nodes;\n-  bitmap written_decls;\n+  int i;\n   lto_cgraph_encoder_t encoder;\n   lto_varpool_encoder_t varpool_encoder;\n-  struct cgraph_asm_node *can;\n-\n-  ob = lto_create_simple_output_block (LTO_section_cgraph);\n-\n-  output_profile_summary (ob);\n \n-  /* An encoder for cgraph nodes should have been created by\n-     ipa_write_summaries_1.  */\n-  gcc_assert (ob->decl_state->cgraph_node_encoder);\n-  gcc_assert (ob->decl_state->varpool_node_encoder);\n-  encoder = ob->decl_state->cgraph_node_encoder;\n-  varpool_encoder = ob->decl_state->varpool_node_encoder;\n-\n-  /* The FUNCTION_DECLs for which we have written a node.  The first\n-     node found is written as the \"original\" node, the remaining nodes\n-     are considered its clones.  */\n-  written_decls = lto_bitmap_alloc ();\n+  encoder = state->cgraph_node_encoder = lto_cgraph_encoder_new ();\n+  varpool_encoder = state->varpool_node_encoder = lto_varpool_encoder_new ();\n \n   /* Go over all the nodes in SET and assign references.  */\n   for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n@@ -775,6 +801,37 @@ output_cgraph (cgraph_node_set set, varpool_node_set vset)\n \t    }\n \t}\n     }\n+}\n+\n+/* Output the part of the cgraph in SET.  */\n+\n+void\n+output_cgraph (cgraph_node_set set, varpool_node_set vset)\n+{\n+  struct cgraph_node *node;\n+  struct lto_simple_output_block *ob;\n+  cgraph_node_set_iterator csi;\n+  int i, n_nodes;\n+  bitmap written_decls;\n+  lto_cgraph_encoder_t encoder;\n+  lto_varpool_encoder_t varpool_encoder;\n+  struct cgraph_asm_node *can;\n+\n+  ob = lto_create_simple_output_block (LTO_section_cgraph);\n+\n+  output_profile_summary (ob);\n+\n+  /* An encoder for cgraph nodes should have been created by\n+     ipa_write_summaries_1.  */\n+  gcc_assert (ob->decl_state->cgraph_node_encoder);\n+  gcc_assert (ob->decl_state->varpool_node_encoder);\n+  encoder = ob->decl_state->cgraph_node_encoder;\n+  varpool_encoder = ob->decl_state->varpool_node_encoder;\n+\n+  /* The FUNCTION_DECLs for which we have written a node.  The first\n+     node found is written as the \"original\" node, the remaining nodes\n+     are considered its clones.  */\n+  written_decls = lto_bitmap_alloc ();\n \n   /* Write out the nodes.  We must first output a node and then its clones,\n      otherwise at a time reading back the node there would be nothing to clone"}, {"sha": "a0747dde5609f41610c619038743f9090ad45544", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f33806415919e05f98b3abb9d15675e50a952f06/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f33806415919e05f98b3abb9d15675e50a952f06/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=f33806415919e05f98b3abb9d15675e50a952f06", "patch": "@@ -865,6 +865,13 @@ bool referenced_from_other_partition_p (struct ipa_ref_list *,\n \t\t\t\t        varpool_node_set vset);\n bool reachable_from_other_partition_p (struct cgraph_node *,\n \t\t\t\t       cgraph_node_set);\n+bool referenced_from_this_partition_p (struct ipa_ref_list *,\n+\t\t\t\t        cgraph_node_set,\n+\t\t\t\t        varpool_node_set vset);\n+bool reachable_from_this_partition_p (struct cgraph_node *,\n+\t\t\t\t       cgraph_node_set);\n+void compute_ltrans_boundary (struct lto_out_decl_state *state,\n+\t\t\t      cgraph_node_set, varpool_node_set);\n \n \n /* In lto-symtab.c.  */"}, {"sha": "80dda3037d771aa6504eca2d81feb6dec739119f", "filename": "gcc/opts.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f33806415919e05f98b3abb9d15675e50a952f06/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f33806415919e05f98b3abb9d15675e50a952f06/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=f33806415919e05f98b3abb9d15675e50a952f06", "patch": "@@ -1143,7 +1143,6 @@ decode_options (unsigned int argc, const char **argv)\n     {\n       /* These passes are not WHOPR compatible yet.  */\n       flag_ipa_cp = 0;\n-      flag_ipa_reference = 0;\n       flag_ipa_type_escape = 0;\n       flag_ipa_pta = 0;\n       flag_ipa_struct_reorg = 0;"}, {"sha": "85bd33bfadfda75fcb36a9e21d87568405c16907", "filename": "gcc/passes.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f33806415919e05f98b3abb9d15675e50a952f06/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f33806415919e05f98b3abb9d15675e50a952f06/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=f33806415919e05f98b3abb9d15675e50a952f06", "patch": "@@ -1695,8 +1695,7 @@ static void\n ipa_write_summaries_1 (cgraph_node_set set, varpool_node_set vset)\n {\n   struct lto_out_decl_state *state = lto_new_out_decl_state ();\n-  state->cgraph_node_encoder = lto_cgraph_encoder_new ();\n-  state->varpool_node_encoder = lto_varpool_encoder_new ();\n+  compute_ltrans_boundary (state, set, vset);\n \n   lto_push_out_decl_state (state);\n \n@@ -1809,8 +1808,8 @@ void\n ipa_write_optimization_summaries (cgraph_node_set set, varpool_node_set vset)\n {\n   struct lto_out_decl_state *state = lto_new_out_decl_state ();\n-  state->cgraph_node_encoder = lto_cgraph_encoder_new ();\n-  state->varpool_node_encoder = lto_varpool_encoder_new ();\n+  compute_ltrans_boundary (state, set, vset);\n+\n   lto_push_out_decl_state (state);\n \n   gcc_assert (flag_wpa);"}, {"sha": "890409be2764431e65e4e74f4fadccefeb1c68bd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f33806415919e05f98b3abb9d15675e50a952f06/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f33806415919e05f98b3abb9d15675e50a952f06/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f33806415919e05f98b3abb9d15675e50a952f06", "patch": "@@ -1,3 +1,8 @@\n+2010-05-15  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.dg/lto/ipareference_1.c: New file.\n+\t* gcc.dg/lto/ipareference_2.c: New file.\n+\n 2010-05-15  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/44038"}, {"sha": "f2aad7627b65b2b11bef7f88d7c6a8e96b3e085c", "filename": "gcc/testsuite/gcc.dg/lto/ipareference_1.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f33806415919e05f98b3abb9d15675e50a952f06/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fipareference_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f33806415919e05f98b3abb9d15675e50a952f06/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fipareference_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fipareference_1.c?ref=f33806415919e05f98b3abb9d15675e50a952f06", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-lto-options {{ -O1 -fwhopr }} } */\n+/* { dg-lto-do run } */\n+\n+/* Test that ipa-reference notice that get_val will not change since do_nothing does not\n+   modify anything.  This needs streaming cross file boundary summaries.  */\n+extern int get_val (void);\n+extern int set_val (void);\n+extern do_nothing (void);\n+void abort (void);\n+main()\n+{\n+  int a;\n+  int b;\n+  set_val ();\n+  a = get_val ();\n+  do_nothing();\n+  b = get_val ();\n+  if (a==b)\n+    {\n+      if (!,__builtin_constant_p (a==b))\n+\tabort ();\n+      return 0;\n+    }\n+  else\n+    abort ();\n+}"}, {"sha": "c5d72faafb8365432e0cdf104fab09340d2677bd", "filename": "gcc/testsuite/gcc.dg/lto/ipareference_2.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f33806415919e05f98b3abb9d15675e50a952f06/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fipareference_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f33806415919e05f98b3abb9d15675e50a952f06/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fipareference_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fipareference_2.c?ref=f33806415919e05f98b3abb9d15675e50a952f06", "patch": "@@ -0,0 +1,14 @@\n+static int val;\n+int set_val (void)\n+{\n+  val = 5;\n+}\n+int get_val (void)\n+{\n+  return val;\n+}\n+__attribute__ ((__noinline__))\n+do_nothing ()\n+{\n+  asm volatile (\"\":::\"memory\");\n+}"}, {"sha": "ed9b7c59f01ee47274143eaf2112ad6ea8270e55", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f33806415919e05f98b3abb9d15675e50a952f06/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f33806415919e05f98b3abb9d15675e50a952f06/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=f33806415919e05f98b3abb9d15675e50a952f06", "patch": "@@ -1061,8 +1061,7 @@ ref_maybe_used_by_call_p_1 (gimple call, ao_ref *ref)\n   /* Check if base is a global static variable that is not read\n      by the function.  */\n   if (TREE_CODE (base) == VAR_DECL\n-      && TREE_STATIC (base)\n-      && !TREE_PUBLIC (base))\n+      && TREE_STATIC (base))\n     {\n       bitmap not_read;\n \n@@ -1316,8 +1315,7 @@ call_may_clobber_ref_p_1 (gimple call, ao_ref *ref)\n      by the function.  */\n   if (callee != NULL_TREE\n       && TREE_CODE (base) == VAR_DECL\n-      && TREE_STATIC (base)\n-      && !TREE_PUBLIC (base))\n+      && TREE_STATIC (base))\n     {\n       bitmap not_written;\n "}]}