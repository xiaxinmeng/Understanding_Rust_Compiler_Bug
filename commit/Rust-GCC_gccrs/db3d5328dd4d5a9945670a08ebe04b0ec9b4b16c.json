{"sha": "db3d5328dd4d5a9945670a08ebe04b0ec9b4b16c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGIzZDUzMjhkZDRkNWE5OTQ1NjcwYTA4ZWJlMDRiMGVjOWI0YjE2Yw==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@redhat.com", "date": "2005-11-06T14:51:16Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2005-11-06T14:51:16Z"}, "message": "re PR tree-optimization/24670 (VRP ICE in compare_name_with_value)\n\n\n\tPR 24670\n\t* tree-vrp.c (fix_equivalence_set): New.\n\t(extract_range_from_assert): Call it.\n\n\ntestsuite/\n\n\tPR 24670\n\t* gcc.dg/tree-ssa/pr24670.c: New test.\n\nFrom-SVN: r106562", "tree": {"sha": "9040a86d0a4d70ad51416593d2352fe4dbcadec0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9040a86d0a4d70ad51416593d2352fe4dbcadec0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/db3d5328dd4d5a9945670a08ebe04b0ec9b4b16c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db3d5328dd4d5a9945670a08ebe04b0ec9b4b16c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db3d5328dd4d5a9945670a08ebe04b0ec9b4b16c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db3d5328dd4d5a9945670a08ebe04b0ec9b4b16c/comments", "author": null, "committer": null, "parents": [{"sha": "3a4983938c7257386f0579f8b55f3ab616c52242", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a4983938c7257386f0579f8b55f3ab616c52242", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a4983938c7257386f0579f8b55f3ab616c52242"}], "stats": {"total": 122, "additions": 120, "deletions": 2}, "files": [{"sha": "dbe9c080c941bbf6cfe473a1f5aff79b916f10d3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3d5328dd4d5a9945670a08ebe04b0ec9b4b16c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3d5328dd4d5a9945670a08ebe04b0ec9b4b16c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=db3d5328dd4d5a9945670a08ebe04b0ec9b4b16c", "patch": "@@ -1,3 +1,9 @@\n+2005-11-06  Diego Novillo  <dnovillo@redhat.com>\n+\n+\tPR 24670\n+\t* tree-vrp.c (fix_equivalence_set): New.\n+\t(extract_range_from_assert): Call it.\n+\n 2005-11-05  Ian Lance Taylor  <ian@airs.com>\n \n \tPR target/22432"}, {"sha": "79c7ac7d032302214ab861fac169d9fab20d7811", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3d5328dd4d5a9945670a08ebe04b0ec9b4b16c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3d5328dd4d5a9945670a08ebe04b0ec9b4b16c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=db3d5328dd4d5a9945670a08ebe04b0ec9b4b16c", "patch": "@@ -1,3 +1,8 @@\n+2005-11-06  Diego Novillo  <dnovillo@redhat.com>\n+\n+\tPR 24670\n+\t* gcc.dg/tree-ssa/pr24670.c: New test.\n+\n 2005-11-05  Ian Lance Taylor  <ian@airs.com>\n \n \tPR target/22432"}, {"sha": "a5ff800d925a8e190e9d4405f0f9e9e867ce2f27", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr24670.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3d5328dd4d5a9945670a08ebe04b0ec9b4b16c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr24670.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3d5328dd4d5a9945670a08ebe04b0ec9b4b16c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr24670.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr24670.c?ref=db3d5328dd4d5a9945670a08ebe04b0ec9b4b16c", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+__inline__ void\n+shift128Right (int count, long long int *z1Ptr)\n+{\n+  long long int z1;\n+  if (count == 0);\n+  else if (count < 64);\n+  else\n+    z1 = (count < 64) ? count : 0;\n+  *z1Ptr = z1;\n+}\n+\n+float128_rem ()\n+{\n+  signed int expDiff;\n+  long long int aSig1;\n+  long long int sigMean1;\n+  if (-64 < expDiff)\n+    shift128Right (-expDiff, &aSig1);\n+  add128 (&sigMean1);\n+}"}, {"sha": "929908bf4735692ae80f48b30a0dfa6e219bc891", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 86, "deletions": 2, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3d5328dd4d5a9945670a08ebe04b0ec9b4b16c/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3d5328dd4d5a9945670a08ebe04b0ec9b4b16c/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=db3d5328dd4d5a9945670a08ebe04b0ec9b4b16c", "patch": "@@ -632,6 +632,81 @@ range_includes_zero_p (value_range_t *vr)\n }\n \n \n+/* When extracting ranges from X_i = ASSERT_EXPR <Y_j, pred>, we will\n+   initially consider X_i and Y_j equivalent, so the equivalence set\n+   of Y_j is added to the equivalence set of X_i.  However, it is\n+   possible to have a chain of ASSERT_EXPRs whose predicates are\n+   actually incompatible.  This is usually the result of nesting of\n+   contradictory if-then-else statements.  For instance, in PR 24670:\n+\n+   \tcount_4 has range [-INF, 63]\n+\n+   \tif (count_4 != 0)\n+\t  {\n+\t    count_19 = ASSERT_EXPR <count_4, count_4 != 0>\n+\t    if (count_19 > 63)\n+\t      {\n+\t        count_18 = ASSERT_EXPR <count_19, count_19 > 63>\n+\t\tif (count_18 <= 63)\n+\t\t  ...\n+\t      }\n+\t  }\n+\n+   Notice that 'if (count_19 > 63)' is trivially false and will be\n+   folded out at the end.  However, during propagation, the flowgraph\n+   is not cleaned up and so, VRP will evaluate predicates more\n+   predicates than necessary, so it must support these\n+   inconsistencies.  The problem here is that because of the chaining\n+   of ASSERT_EXPRs, the equivalency set for count_18 includes count_4.\n+   Since count_4 has an incompatible range, we ICE when evaluating the\n+   ranges in the equivalency set.  So, we need to remove count_4 from\n+   it.  */\n+\n+static void\n+fix_equivalence_set (value_range_t *vr_p)\n+{\n+  bitmap_iterator bi;\n+  unsigned i;\n+  bitmap e = vr_p->equiv;\n+  bitmap to_remove = BITMAP_ALLOC (NULL);\n+\n+  /* Only detect inconsistencies on numeric ranges.  */\n+  if (vr_p->type == VR_VARYING\n+      || vr_p->type == VR_UNDEFINED\n+      || symbolic_range_p (vr_p))\n+    return;\n+\n+  EXECUTE_IF_SET_IN_BITMAP (e, 0, i, bi)\n+    {\n+      value_range_t *equiv_vr = vr_value[i];\n+\n+      if (equiv_vr->type == VR_VARYING\n+\t  || equiv_vr->type == VR_UNDEFINED\n+\t  || symbolic_range_p (equiv_vr))\n+\tcontinue;\n+\n+      if (equiv_vr->type == VR_RANGE\n+\t  && vr_p->type == VR_RANGE\n+\t  && !value_ranges_intersect_p (vr_p, equiv_vr))\n+\tbitmap_set_bit (to_remove, i);\n+      else if ((equiv_vr->type == VR_RANGE && vr_p->type == VR_ANTI_RANGE)\n+\t       || (equiv_vr->type == VR_ANTI_RANGE && vr_p->type == VR_RANGE))\n+\t{\n+\t  /* A range and an anti-range have an empty intersection if\n+\t     their end points are the same.  FIXME,\n+\t     value_ranges_intersect_p should handle this\n+\t     automatically.  */\n+\t  if (compare_values (equiv_vr->min, vr_p->min) == 0\n+\t      && compare_values (equiv_vr->max, vr_p->max) == 0)\n+\t    bitmap_set_bit (to_remove, i);\n+\t}\n+    }\n+\n+  bitmap_and_compl_into (vr_p->equiv, to_remove);\n+  BITMAP_FREE (to_remove);\n+}\n+\n+\n /* Extract value range information from an ASSERT_EXPR EXPR and store\n    it in *VR_P.  */\n \n@@ -747,7 +822,11 @@ extract_range_from_assert (value_range_t *vr_p, tree expr)\n \t}\n     }\n \n-  /* The new range has the same set of equivalences of VAR's range.  */\n+  /* Initially, the new range has the same set of equivalences of\n+     VAR's range.  This will be revised before returning the final\n+     value.  Since assertions may be chained via mutually exclusive\n+     predicates, we will need to trim the set of equivalences before\n+     we are done.  */\n   gcc_assert (vr_p->equiv == NULL);\n   vr_p->equiv = BITMAP_ALLOC (NULL);\n   add_equivalence (vr_p->equiv, var);\n@@ -924,7 +1003,7 @@ extract_range_from_assert (value_range_t *vr_p, tree expr)\n       || var_vr->type == VR_UNDEFINED\n       || symbolic_range_p (vr_p)\n       || symbolic_range_p (var_vr))\n-    return;\n+    goto done;\n \n   if (var_vr->type == VR_RANGE && vr_p->type == VR_RANGE)\n     {\n@@ -968,6 +1047,11 @@ extract_range_from_assert (value_range_t *vr_p, tree expr)\n \t  && compare_values (var_vr->max, vr_p->max) == 0)\n \tset_value_range_to_varying (vr_p);\n     }\n+\n+  /* Remove names from the equivalence set that have ranges\n+     incompatible with VR_P.  */\n+done:\n+  fix_equivalence_set (vr_p);\n }\n \n "}]}