{"sha": "17c7e33e8c288eda8ec9316dad5daea43299f584", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTdjN2UzM2U4YzI4OGVkYThlYzkzMTZkYWQ1ZGFlYTQzMjk5ZjU4NA==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@redhat.com", "date": "2005-07-22T13:39:18Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2005-07-22T13:39:18Z"}, "message": "tree-ssa-alias.c (count_ptr_derefs): Do not consider &PTR->FLD a dereference of PTR.\n\n\n        * tree-ssa-alias.c (count_ptr_derefs): Do not consider\n        &PTR->FLD a dereference of PTR.\n        * tree-ssa-structalias.c (update_alias_info): Consider &PTR->FLD\n        a potential dereference of PTR.\n\ntestsuite/ChangeLog\n\n        * gcc.dg/tree-ssa/20050719-1.c: New test.\n\nFrom-SVN: r102283", "tree": {"sha": "a90ff2874706640af3b68570fabd2d4bcd045798", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a90ff2874706640af3b68570fabd2d4bcd045798"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/17c7e33e8c288eda8ec9316dad5daea43299f584", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17c7e33e8c288eda8ec9316dad5daea43299f584", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17c7e33e8c288eda8ec9316dad5daea43299f584", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17c7e33e8c288eda8ec9316dad5daea43299f584/comments", "author": null, "committer": null, "parents": [{"sha": "191e1ff2f56a8b5148ccca1e3c30283af9905cee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/191e1ff2f56a8b5148ccca1e3c30283af9905cee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/191e1ff2f56a8b5148ccca1e3c30283af9905cee"}], "stats": {"total": 99, "additions": 95, "deletions": 4}, "files": [{"sha": "e93626f4008d44e5730455c62e5a8968a0887f33", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17c7e33e8c288eda8ec9316dad5daea43299f584/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17c7e33e8c288eda8ec9316dad5daea43299f584/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=17c7e33e8c288eda8ec9316dad5daea43299f584", "patch": "@@ -1,3 +1,10 @@\n+2005-07-22  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* tree-ssa-alias.c (count_ptr_derefs): Do not consider\n+\t&PTR->FLD a dereference of PTR.\n+\t* tree-ssa-structalias.c (update_alias_info): Consider &PTR->FLD\n+\ta potential dereference of PTR.\n+\n 2005-07-22  J\"orn Rennecke <joern.rennecke@st.com>\n \n \tPR rtl-optimization/20370"}, {"sha": "25db24b931a885f2228bf5acf99ac1024974b2c7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17c7e33e8c288eda8ec9316dad5daea43299f584/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17c7e33e8c288eda8ec9316dad5daea43299f584/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=17c7e33e8c288eda8ec9316dad5daea43299f584", "patch": "@@ -1,3 +1,7 @@\n+2005-07-22  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* gcc.dg/tree-ssa/20050719-1.c: New test.\n+\n 2005-07-22  Bernd Schmidt  <bernd.schmidt@analog.com>\n \n \t* gcc.dg/bfin-longcall-1.c: New file."}, {"sha": "a1c08e34d293f35954cef989bc657e9af4dc0607", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20050719-1.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17c7e33e8c288eda8ec9316dad5daea43299f584/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20050719-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17c7e33e8c288eda8ec9316dad5daea43299f584/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20050719-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20050719-1.c?ref=17c7e33e8c288eda8ec9316dad5daea43299f584", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+\n+extern void abort (void) __attribute__ ((__nothrow__)) __attribute__\n+((__noreturn__));\n+extern void exit (int __status) __attribute__ ((__nothrow__))\n+__attribute__ ((__noreturn__));\n+\n+struct bootLoader {\n+  int x;\n+};\n+\n+void\n+zap(struct bootLoader *bootLoader)\n+{\n+  /* The expression on the RHS of the assignment is *not* a\n+     dereference of pointer 'bootLoader'.  It is merely used as an\n+     offset calculation.  VRP was erroneously removing the if()\n+     because it thought that 'bootLoader' was always dereferenced.  */\n+  int *boot = &bootLoader->x;\n+\n+  if (bootLoader)\n+    {\n+      useboot (boot);\n+    }\n+}\n+\n+int\n+useboot (void *boot)\n+{\n+  abort ();\n+}\n+\n+main()\n+{\n+  zap (0);\n+}"}, {"sha": "76d883ab64ca3e6bc997811a1debf956b4ebdbe7", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17c7e33e8c288eda8ec9316dad5daea43299f584/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17c7e33e8c288eda8ec9316dad5daea43299f584/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=17c7e33e8c288eda8ec9316dad5daea43299f584", "patch": "@@ -344,12 +344,20 @@ struct count_ptr_d\n    (ALIGN/MISALIGNED_)INDIRECT_REF nodes for the pointer passed in DATA.  */\n \n static tree\n-count_ptr_derefs (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED, void *data)\n+count_ptr_derefs (tree *tp, int *walk_subtrees, void *data)\n {\n   struct count_ptr_d *count_p = (struct count_ptr_d *) data;\n \n+  /* Do not walk inside ADDR_EXPR nodes.  In the expression &ptr->fld,\n+     pointer 'ptr' is *not* dereferenced, it is simply used to compute\n+     the address of 'fld' as 'ptr + offsetof(fld)'.  */\n+  if (TREE_CODE (*tp) == ADDR_EXPR)\n+    {\n+      *walk_subtrees = 0;\n+      return NULL_TREE;\n+    }\n+\n   if (INDIRECT_REF_P (*tp) && TREE_OPERAND (*tp, 0) == count_p->ptr)\n-/*       || (TREE_CODE (*tp) == MEM_REF && MEM_REF_SYMBOL (*tp) == count_p->ptr)) */\n     count_p->count++;\n \n   return NULL_TREE;"}, {"sha": "2a10a8d3d118388f7aa233ace3b74408e3f016aa", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 37, "deletions": 2, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17c7e33e8c288eda8ec9316dad5daea43299f584/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17c7e33e8c288eda8ec9316dad5daea43299f584/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=17c7e33e8c288eda8ec9316dad5daea43299f584", "patch": "@@ -2555,7 +2555,7 @@ update_alias_info (tree stmt, struct alias_info *ai)\n       tree op, var;\n       var_ann_t v_ann;\n       struct ptr_info_def *pi;\n-      bool is_store;\n+      bool is_store, is_potential_deref;\n       unsigned num_uses, num_derefs;\n \n       op = USE_FROM_PTR (use_p);\n@@ -2612,7 +2612,42 @@ update_alias_info (tree stmt, struct alias_info *ai)\n \t is an escape point, whether OP escapes.  */\n       count_uses_and_derefs (op, stmt, &num_uses, &num_derefs, &is_store);\n \n-      if (num_derefs > 0)\n+      /* Handle a corner case involving address expressions of the\n+\t form '&PTR->FLD'.  The problem with these expressions is that\n+\t they do not represent a dereference of PTR.  However, if some\n+\t other transformation propagates them into an INDIRECT_REF\n+\t expression, we end up with '*(&PTR->FLD)' which is folded\n+\t into 'PTR->FLD'.\n+\n+\t So, if the original code had no other dereferences of PTR,\n+\t the aliaser will not create memory tags for it, and when\n+\t &PTR->FLD gets propagated to INDIRECT_REF expressions, the\n+\t memory operations will receive no V_MAY_DEF/VUSE operands.\n+\n+\t One solution would be to have count_uses_and_derefs consider\n+\t &PTR->FLD a dereference of PTR.  But that is wrong, since it\n+\t is not really a dereference but an offset calculation.\n+\n+\t What we do here is to recognize these special ADDR_EXPR\n+\t nodes.  Since these expressions are never GIMPLE values (they\n+\t are not GIMPLE invariants), they can only appear on the RHS\n+\t of an assignment and their base address is always an\n+\t INDIRECT_REF expression.  */\n+      is_potential_deref = false;\n+      if (TREE_CODE (stmt) == MODIFY_EXPR\n+\t  && TREE_CODE (TREE_OPERAND (stmt, 1)) == ADDR_EXPR\n+\t  && !is_gimple_val (TREE_OPERAND (stmt, 1)))\n+\t{\n+\t  /* If the RHS if of the form &PTR->FLD and PTR == OP, then\n+\t     this represents a potential dereference of PTR.  */\n+\t  tree rhs = TREE_OPERAND (stmt, 1);\n+\t  tree base = get_base_address (TREE_OPERAND (rhs, 0));\n+\t  if (TREE_CODE (base) == INDIRECT_REF\n+\t      && TREE_OPERAND (base, 0) == op)\n+\t    is_potential_deref = true;\n+\t}\n+\n+      if (num_derefs > 0 || is_potential_deref)\n \t{\n \t  /* Mark OP as dereferenced.  In a subsequent pass,\n \t     dereferenced pointers that point to a set of"}]}