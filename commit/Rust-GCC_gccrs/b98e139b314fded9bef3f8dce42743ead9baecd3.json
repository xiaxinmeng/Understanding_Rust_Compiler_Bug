{"sha": "b98e139b314fded9bef3f8dce42743ead9baecd3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjk4ZTEzOWIzMTRmZGVkOWJlZjNmOGRjZTQyNzQzZWFkOWJhZWNkMw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-08-03T23:07:43Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-08-03T23:07:43Z"}, "message": "ChangeLog\n\nFrom-SVN: r35463", "tree": {"sha": "d52d0d24a56ac71f5c913dcfebee9f4622a244a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d52d0d24a56ac71f5c913dcfebee9f4622a244a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b98e139b314fded9bef3f8dce42743ead9baecd3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b98e139b314fded9bef3f8dce42743ead9baecd3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b98e139b314fded9bef3f8dce42743ead9baecd3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b98e139b314fded9bef3f8dce42743ead9baecd3/comments", "author": null, "committer": null, "parents": [{"sha": "9897911d4575deb2b33ce8a1d0d4cbac98b61731", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9897911d4575deb2b33ce8a1d0d4cbac98b61731", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9897911d4575deb2b33ce8a1d0d4cbac98b61731"}], "stats": {"total": 43, "additions": 43, "deletions": 0}, "files": [{"sha": "ed4e75f9bfbcb5bb1febcb86af25f0ab9df9d014", "filename": "gcc/extend.texi", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b98e139b314fded9bef3f8dce42743ead9baecd3/gcc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b98e139b314fded9bef3f8dce42743ead9baecd3/gcc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fextend.texi?ref=b98e139b314fded9bef3f8dce42743ead9baecd3", "patch": "@@ -184,6 +184,49 @@ If you don't know the type of the operand, you can still do this, but you\n must use @code{typeof} (@pxref{Typeof}) or type naming (@pxref{Naming\n Types}).\n \n+Statement expressions are not supported fully in G++, and their fate\n+there is unclear.  (It is possible that they will become fully supported\n+at some point, or that they will be deprecated, or that the bugs that\n+are present will continue to exist indefinitely.)  Presently, statement\n+expressions do not work well as default arguments. \n+\n+In addition, there are semantic issues with statement-expressions in\n+C++.  If you try to use statement-expressions instead of inline\n+functions in C++, you may be surprised at the way object destruction is\n+handled.  For example:\n+\n+@example\n+#define foo(a)  (@{int b = (a); b + 3; @})\n+@end example\n+\n+@noindent\n+does not work the same way as:\n+\n+@example\n+inline int foo(a) @{ int b = a; return b + 3; @}\n+@end example\n+\n+@noindent\n+In particular, if the expression passed into @code{foo} involves the\n+creation of temporaries, the destructors for those temporaries will be\n+run earlier in the case of the macro than in the case of the function.\n+\n+These considerations mean that it is probably a bad idea to use\n+statement-expressions of this form in header files that are designed to\n+work with C++.  Note that the GNU C Library does contain header files\n+using statement-expressions, and that these definitions make the library\n+technically non-conforming.  For example, when optimization is turned\n+on,\n+\n+@example\n+string a, b;\n+printf(\"%s\", toupper((a+b).c_str()[0]));\n+@end example\n+\n+@noindent\n+will result in the destructor for the temporary created for @code{a+b}\n+being run earlier than it should be.\n+\n @node Local Labels\n @section Locally Declared Labels\n @cindex local labels"}]}