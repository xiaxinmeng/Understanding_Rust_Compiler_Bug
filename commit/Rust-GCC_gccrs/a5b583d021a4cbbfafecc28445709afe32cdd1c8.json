{"sha": "a5b583d021a4cbbfafecc28445709afe32cdd1c8", "node_id": "C_kwDOANBUbNoAKGE1YjU4M2QwMjFhNGNiYmZhZmVjYzI4NDQ1NzA5YWZlMzJjZGQxYzg", "commit": {"author": {"name": "Faisal Abbas", "email": "90.abbasfaisal@gmail.com", "date": "2022-07-11T14:59:56Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-25T11:40:24Z"}, "message": "gccrs const folding port: continue porting potential_constant_expression_1()\n\nFollowing functions are ported in this changeset:\n - next_initializable_field\n - sufficient_parms_p\n - default_ctor_p\n - user_provided_p\n - type_has_non_user_provided_default_constructor\n - default_init_uninitialized_part\n - extract_conversion_operator\n - get_class_binding_direct\n - lang_check_failed\n - skip_artificial_parms_for\n - in_class_defaulted_default_constructor\n - is_instantiation_of_constexpr\n - check_for_uninitialized_const_var\n\nSigned-off-by: Faisal Abbas <90.abbasfaisal@gmail.com>", "tree": {"sha": "4eb31564b06a0ea1a9ff677fc2a5d8fe7ee57782", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4eb31564b06a0ea1a9ff677fc2a5d8fe7ee57782"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a5b583d021a4cbbfafecc28445709afe32cdd1c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5b583d021a4cbbfafecc28445709afe32cdd1c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5b583d021a4cbbfafecc28445709afe32cdd1c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5b583d021a4cbbfafecc28445709afe32cdd1c8/comments", "author": {"login": "abbasfaisal", "id": 9428333, "node_id": "MDQ6VXNlcjk0MjgzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/9428333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abbasfaisal", "html_url": "https://github.com/abbasfaisal", "followers_url": "https://api.github.com/users/abbasfaisal/followers", "following_url": "https://api.github.com/users/abbasfaisal/following{/other_user}", "gists_url": "https://api.github.com/users/abbasfaisal/gists{/gist_id}", "starred_url": "https://api.github.com/users/abbasfaisal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abbasfaisal/subscriptions", "organizations_url": "https://api.github.com/users/abbasfaisal/orgs", "repos_url": "https://api.github.com/users/abbasfaisal/repos", "events_url": "https://api.github.com/users/abbasfaisal/events{/privacy}", "received_events_url": "https://api.github.com/users/abbasfaisal/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3343535fdb7fc36e68949a8642d7e67668b67f6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3343535fdb7fc36e68949a8642d7e67668b67f6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3343535fdb7fc36e68949a8642d7e67668b67f6c"}], "stats": {"total": 523, "additions": 506, "deletions": 17}, "files": [{"sha": "52dae395973851020678e6e67c82b7b9b4e077d2", "filename": "gcc/rust/backend/rust-tree.cc", "status": "modified", "additions": 347, "deletions": 15, "changes": 362, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5b583d021a4cbbfafecc28445709afe32cdd1c8/gcc%2Frust%2Fbackend%2Frust-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5b583d021a4cbbfafecc28445709afe32cdd1c8/gcc%2Frust%2Fbackend%2Frust-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.cc?ref=a5b583d021a4cbbfafecc28445709afe32cdd1c8", "patch": "@@ -23,6 +23,9 @@\n #include \"escaped_string.h\"\n #include \"libiberty.h\"\n #include \"stor-layout.h\"\n+#include \"hash-map.h\"\n+#include \"diagnostic.h\"\n+#include \"timevar.h\"\n \n namespace Rust {\n \n@@ -1134,9 +1137,7 @@ ovl_make (tree fn, tree next)\n   if (TREE_CODE (fn) == OVERLOAD)\n     OVL_NESTED_P (result) = true;\n \n-  TREE_TYPE (result)\n-    = (next || TREE_CODE (fn) == TEMPLATE_DECL ? unknown_type_node\n-\t\t\t\t\t       : TREE_TYPE (fn));\n+  TREE_TYPE (result) = (next ? unknown_type_node : TREE_TYPE (fn));\n   if (next && TREE_CODE (next) == OVERLOAD && OVL_DEDUP_P (next))\n     OVL_DEDUP_P (result) = true;\n   OVL_FUNCTION (result) = fn;\n@@ -1154,13 +1155,7 @@ lookup_add (tree fns, tree lookup)\n   if (fns == error_mark_node || lookup == error_mark_node)\n     return error_mark_node;\n \n-  if (lookup || TREE_CODE (fns) == TEMPLATE_DECL)\n-    {\n-      lookup = ovl_make (fns, lookup);\n-      OVL_LOOKUP_P (lookup) = true;\n-    }\n-  else\n-    lookup = fns;\n+  lookup = fns;\n \n   return lookup;\n }\n@@ -1655,10 +1650,6 @@ called_fns_equal (tree t1, tree t2)\n \t      != DECL_CONTEXT (get_first_fn (t2))))\n \treturn false;\n \n-      if (TREE_CODE (t1) == TEMPLATE_ID_EXPR)\n-\ttargs1 = TREE_OPERAND (t1, 1);\n-      if (TREE_CODE (t2) == TEMPLATE_ID_EXPR)\n-\ttargs2 = TREE_OPERAND (t2, 1);\n       return rs_tree_equal (targs1, targs2);\n     }\n   else\n@@ -2421,7 +2412,6 @@ rs_build_qualified_type_real (tree type, int type_quals,\n   /* A restrict-qualified type must be a pointer (or reference)\n      to object or incomplete type. */\n   if ((type_quals & TYPE_QUAL_RESTRICT)\n-      && TREE_CODE (type) != TEMPLATE_TYPE_PARM\n       && TREE_CODE (type) != TYPENAME_TYPE && !INDIRECT_TYPE_P (type))\n     {\n       bad_quals |= TYPE_QUAL_RESTRICT;\n@@ -2822,4 +2812,346 @@ comptypes (tree t1, tree t2, int strict)\n     return structural_comptypes (t1, t2, strict);\n }\n \n+// forked from gcc/cp/decl.cc next_initializable_field\n+\n+/* FIELD is an element of TYPE_FIELDS or NULL.  In the former case, the value\n+   returned is the next FIELD_DECL (possibly FIELD itself) that can be\n+   initialized.  If there are no more such fields, the return value\n+   will be NULL.  */\n+\n+tree\n+next_initializable_field (tree field)\n+{\n+  while (field\n+\t && (TREE_CODE (field) != FIELD_DECL || DECL_UNNAMED_BIT_FIELD (field)\n+\t     || (DECL_ARTIFICIAL (field)\n+\t\t /* Don't skip vptr fields.  We might see them when we're\n+\t\t    called from reduced_constant_expression_p.  */\n+\t\t && !DECL_VIRTUAL_P (field))))\n+    field = DECL_CHAIN (field);\n+\n+  return field;\n+}\n+\n+// forked from gcc/cp/call.cc sufficient_parms_p\n+\n+/* Returns nonzero if PARMLIST consists of only default parms,\n+   ellipsis, and/or undeduced parameter packs.  */\n+\n+bool\n+sufficient_parms_p (const_tree parmlist)\n+{\n+  for (; parmlist && parmlist != void_list_node;\n+       parmlist = TREE_CHAIN (parmlist))\n+    if (!TREE_PURPOSE (parmlist))\n+      return false;\n+  return true;\n+}\n+\n+// forked from gcc/cp/class.cc default_ctor_p\n+\n+/* Returns true if FN is a default constructor.  */\n+\n+bool\n+default_ctor_p (const_tree fn)\n+{\n+  return (DECL_CONSTRUCTOR_P (fn)\n+\t  && sufficient_parms_p (FUNCTION_FIRST_USER_PARMTYPE (fn)));\n+}\n+\n+// forked from gcc/cp/class.cc user_provided_p\n+\n+/* Returns true iff FN is a user-provided function, i.e. user-declared\n+   and not defaulted at its first declaration.  */\n+\n+bool\n+user_provided_p (tree fn)\n+{\n+  return (!DECL_ARTIFICIAL (fn)\n+\t  && !(DECL_INITIALIZED_IN_CLASS_P (fn)\n+\t       && (DECL_DEFAULTED_FN (fn) || DECL_DELETED_FN (fn))));\n+}\n+\n+// forked from gcc/cp/class.cc type_has_non_user_provided_default_constructor\n+\n+/* Returns true iff class T has a non-user-provided (i.e. implicitly\n+   declared or explicitly defaulted in the class body) default\n+   constructor.  */\n+\n+bool\n+type_has_non_user_provided_default_constructor (tree t)\n+{\n+  if (!TYPE_HAS_DEFAULT_CONSTRUCTOR (t))\n+    return false;\n+  if (CLASSTYPE_LAZY_DEFAULT_CTOR (t))\n+    return true;\n+\n+  for (ovl_iterator iter (CLASSTYPE_CONSTRUCTORS (t)); iter; ++iter)\n+    {\n+      tree fn = *iter;\n+      if (TREE_CODE (fn) == FUNCTION_DECL && default_ctor_p (fn)\n+\t  && !user_provided_p (fn))\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n+// forked from gcc/cp/class.cc default_init_uninitialized_part\n+\n+/* If default-initialization leaves part of TYPE uninitialized, returns\n+   a DECL for the field or TYPE itself (DR 253).  */\n+\n+tree\n+default_init_uninitialized_part (tree type)\n+{\n+  tree t, r, binfo;\n+  int i;\n+\n+  type = strip_array_types (type);\n+  if (!CLASS_TYPE_P (type))\n+    return type;\n+  if (!type_has_non_user_provided_default_constructor (type))\n+    return NULL_TREE;\n+  for (binfo = TYPE_BINFO (type), i = 0; BINFO_BASE_ITERATE (binfo, i, t); ++i)\n+    {\n+      r = default_init_uninitialized_part (BINFO_TYPE (t));\n+      if (r)\n+\treturn r;\n+    }\n+  for (t = next_initializable_field (TYPE_FIELDS (type)); t;\n+       t = next_initializable_field (DECL_CHAIN (t)))\n+    if (!DECL_INITIAL (t) && !DECL_ARTIFICIAL (t))\n+      {\n+\tr = default_init_uninitialized_part (TREE_TYPE (t));\n+\tif (r)\n+\t  return DECL_P (r) ? r : t;\n+      }\n+\n+  return NULL_TREE;\n+}\n+\n+// forked from gcc/cp/name-lookup.cc extract_conversion_operator\n+\n+/* FNS is an overload set of conversion functions.  Return the\n+   overloads converting to TYPE.  */\n+\n+static tree\n+extract_conversion_operator (tree fns, tree type)\n+{\n+  tree convs = NULL_TREE;\n+  tree tpls = NULL_TREE;\n+\n+  for (ovl_iterator iter (fns); iter; ++iter)\n+    {\n+      if (same_type_p (DECL_CONV_FN_TYPE (*iter), type))\n+\tconvs = lookup_add (*iter, convs);\n+    }\n+\n+  if (!convs)\n+    convs = tpls;\n+\n+  return convs;\n+}\n+\n+// forked from gcc/cp/name-lookup.cc\n+\n+/* Look for NAME as an immediate member of KLASS (including\n+   anon-members or unscoped enum member).  TYPE_OR_FNS is zero for\n+   regular search.  >0 to get a type binding (if there is one) and <0\n+   if you want (just) the member function binding.\n+\n+   Use this if you do not want lazy member creation.  */\n+\n+tree\n+get_class_binding_direct (tree klass, tree name, bool want_type)\n+{\n+  gcc_checking_assert (RECORD_OR_UNION_TYPE_P (klass));\n+\n+  /* Conversion operators can only be found by the marker conversion\n+     operator name.  */\n+  bool conv_op = IDENTIFIER_CONV_OP_P (name);\n+  tree lookup = conv_op ? conv_op_identifier : name;\n+  tree val = NULL_TREE;\n+  vec<tree, va_gc> *member_vec = CLASSTYPE_MEMBER_VEC (klass);\n+\n+  if (COMPLETE_TYPE_P (klass) && member_vec)\n+    {\n+      val = member_vec_binary_search (member_vec, lookup);\n+      if (!val)\n+\t;\n+      else if (STAT_HACK_P (val))\n+\tval = want_type ? STAT_TYPE (val) : STAT_DECL (val);\n+      else if (want_type && !DECL_DECLARES_TYPE_P (val))\n+\tval = NULL_TREE;\n+    }\n+  else\n+    {\n+      if (member_vec && !want_type)\n+\tval = member_vec_linear_search (member_vec, lookup);\n+\n+      if (!val || (TREE_CODE (val) == OVERLOAD && OVL_DEDUP_P (val)))\n+\t/* Dependent using declarations are a 'field', make sure we\n+\t   return that even if we saw an overload already.  */\n+\tif (tree field_val = fields_linear_search (klass, lookup, want_type))\n+\t  {\n+\t    if (!val)\n+\t      val = field_val;\n+\t    else if (TREE_CODE (field_val) == USING_DECL)\n+\t      val = ovl_make (field_val, val);\n+\t  }\n+    }\n+\n+  /* Extract the conversion operators asked for, unless the general\n+     conversion operator was requested.   */\n+  if (val && conv_op)\n+    {\n+      gcc_checking_assert (OVL_FUNCTION (val) == conv_op_marker);\n+      val = OVL_CHAIN (val);\n+      if (tree type = TREE_TYPE (name))\n+\tval = extract_conversion_operator (val, type);\n+    }\n+\n+  return val;\n+}\n+\n+#if defined ENABLE_TREE_CHECKING\n+\n+// forked from gcc/cp/tree.cc lang_check_failed\n+\n+/* Complain that some language-specific thing hanging off a tree\n+   node has been accessed improperly.  */\n+\n+void\n+lang_check_failed (const char *file, int line, const char *function)\n+{\n+  internal_error (\"%<lang_*%> check: failed in %s, at %s:%d\", function,\n+\t\t  trim_filename (file), line);\n+}\n+#endif /* ENABLE_TREE_CHECKING */\n+\n+// forked from gcc/cp/tree.cc skip_artificial_parms_for\n+\n+/* Given a FUNCTION_DECL FN and a chain LIST, skip as many elements of LIST\n+   as there are artificial parms in FN.  */\n+\n+tree\n+skip_artificial_parms_for (const_tree fn, tree list)\n+{\n+  if (DECL_NONSTATIC_MEMBER_FUNCTION_P (fn))\n+    list = TREE_CHAIN (list);\n+  else\n+    return list;\n+\n+  if (DECL_HAS_IN_CHARGE_PARM_P (fn))\n+    list = TREE_CHAIN (list);\n+  if (DECL_HAS_VTT_PARM_P (fn))\n+    list = TREE_CHAIN (list);\n+  return list;\n+}\n+\n+// forked from gcc/cp/class.cc in_class_defaulted_default_constructor\n+\n+/* Returns the defaulted constructor if T has one. Otherwise, returns\n+   NULL_TREE.  */\n+\n+tree\n+in_class_defaulted_default_constructor (tree t)\n+{\n+  if (!TYPE_HAS_USER_CONSTRUCTOR (t))\n+    return NULL_TREE;\n+\n+  for (ovl_iterator iter (CLASSTYPE_CONSTRUCTORS (t)); iter; ++iter)\n+    {\n+      tree fn = *iter;\n+\n+      if (DECL_DEFAULTED_IN_CLASS_P (fn) && default_ctor_p (fn))\n+\treturn fn;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+// forked from gcc/cp/constexpr.cc\n+\n+/* Returns true iff FUN is an instantiation of a constexpr function\n+   template or a defaulted constexpr function.  */\n+\n+bool\n+is_instantiation_of_constexpr (tree fun)\n+{\n+  return ((DECL_DEFAULTED_FN (fun) && DECL_DECLARED_CONSTEXPR_P (fun)));\n+}\n+\n+// forked from gcc/cp/decl.cc check_for_uninitialized_const_var\n+\n+/* Issue an error message if DECL is an uninitialized const variable.\n+   CONSTEXPR_CONTEXT_P is true when the function is called in a constexpr\n+   context from potential_constant_expression.  Returns true if all is well,\n+   false otherwise.  */\n+\n+bool\n+check_for_uninitialized_const_var (tree decl, bool constexpr_context_p,\n+\t\t\t\t   tsubst_flags_t complain)\n+{\n+  tree type = strip_array_types (TREE_TYPE (decl));\n+\n+  /* ``Unless explicitly declared extern, a const object does not have\n+     external linkage and must be initialized. ($8.4; $12.1)'' ARM\n+     7.1.6 */\n+  if (VAR_P (decl) && !TYPE_REF_P (type) && (RS_TYPE_CONST_P (type))\n+      && !DECL_NONTRIVIALLY_INITIALIZED_P (decl))\n+    {\n+      tree field = default_init_uninitialized_part (type);\n+      if (!field)\n+\treturn true;\n+\n+      bool show_notes = true;\n+\n+      if (!constexpr_context_p)\n+\t{\n+\t  if (RS_TYPE_CONST_P (type))\n+\t    {\n+\t      if (complain & tf_error)\n+\t\tshow_notes = permerror (DECL_SOURCE_LOCATION (decl),\n+\t\t\t\t\t\"uninitialized %<const %D%>\", decl);\n+\t    }\n+\t  else\n+\t    {\n+\t      if (!is_instantiation_of_constexpr (current_function_decl)\n+\t\t  && (complain & tf_error))\n+\t\terror_at (DECL_SOURCE_LOCATION (decl),\n+\t\t\t  \"uninitialized variable %qD in %<constexpr%> \"\n+\t\t\t  \"function\",\n+\t\t\t  decl);\n+\t      else\n+\t\tshow_notes = false;\n+\t    }\n+\t}\n+      else if (complain & tf_error)\n+\terror_at (DECL_SOURCE_LOCATION (decl),\n+\t\t  \"uninitialized variable %qD in %<constexpr%> context\", decl);\n+\n+      if (show_notes && CLASS_TYPE_P (type) && (complain & tf_error))\n+\t{\n+\t  tree defaulted_ctor;\n+\n+\t  inform (DECL_SOURCE_LOCATION (TYPE_MAIN_DECL (type)),\n+\t\t  \"%q#T has no user-provided default constructor\", type);\n+\t  defaulted_ctor = in_class_defaulted_default_constructor (type);\n+\t  if (defaulted_ctor)\n+\t    inform (DECL_SOURCE_LOCATION (defaulted_ctor),\n+\t\t    \"constructor is not user-provided because it is \"\n+\t\t    \"explicitly defaulted in the class body\");\n+\t  inform (DECL_SOURCE_LOCATION (field),\n+\t\t  \"and the implicitly-defined constructor does not \"\n+\t\t  \"initialize %q#D\",\n+\t\t  field);\n+\t}\n+\n+      return false;\n+    }\n+\n+  return true;\n+}\n } // namespace Rust"}, {"sha": "b838e402c32c0637f716713b1705edd50ba3a2c2", "filename": "gcc/rust/backend/rust-tree.h", "status": "modified", "additions": 159, "deletions": 2, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5b583d021a4cbbfafecc28445709afe32cdd1c8/gcc%2Frust%2Fbackend%2Frust-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5b583d021a4cbbfafecc28445709afe32cdd1c8/gcc%2Frust%2Fbackend%2Frust-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.h?ref=a5b583d021a4cbbfafecc28445709afe32cdd1c8", "patch": "@@ -763,8 +763,6 @@ extern GTY (()) tree cp_global_trees[CPTI_MAX];\n    level 2.  */\n #define DECL_PARM_LEVEL(NODE) (LANG_DECL_PARM_CHECK (NODE)->level)\n \n-#define LANG_DECL_PARM_CHECK(NODE) (&DECL_LANG_SPECIFIC (NODE)->u.parm)\n-\n /* These flags are used by the conversion code.\n    CONV_IMPLICIT   :  Perform implicit conversions (standard and user-defined).\n    CONV_STATIC     :  Perform the explicit conversions for static_cast.\n@@ -845,6 +843,133 @@ extern GTY (()) tree cp_global_trees[CPTI_MAX];\n /* Returns true if NODE is a pointer-to-data-member.  */\n #define TYPE_PTRDATAMEM_P(NODE) (TREE_CODE (NODE) == OFFSET_TYPE)\n \n+/* Nonzero if this type is const-qualified.  */\n+#define RS_TYPE_CONST_P(NODE) ((rs_type_quals (NODE) & TYPE_QUAL_CONST) != 0)\n+\n+/* The _DECL for this _TYPE.  */\n+#define TYPE_MAIN_DECL(NODE) (TYPE_STUB_DECL (TYPE_MAIN_VARIANT (NODE)))\n+\n+/* Nonzero for a VAR_DECL iff an explicit initializer was provided\n+   or a non-trivial constructor is called.  */\n+#define DECL_NONTRIVIALLY_INITIALIZED_P(NODE)                                  \\\n+  (TREE_LANG_FLAG_6 (VAR_DECL_CHECK (NODE)))\n+\n+/* Nonzero if DECL was declared with '= default' (maybe implicitly).  */\n+#define DECL_DEFAULTED_FN(DECL) (LANG_DECL_FN_CHECK (DECL)->defaulted_p)\n+\n+/* Nonzero for a class type means that the class type has a\n+   user-declared constructor.  */\n+#define TYPE_HAS_USER_CONSTRUCTOR(NODE) (TYPE_LANG_FLAG_1 (NODE))\n+\n+/* A FUNCTION_DECL or OVERLOAD for the constructors for NODE.  These\n+   are the constructors that take an in-charge parameter.  */\n+#define CLASSTYPE_CONSTRUCTORS(NODE)                                           \\\n+  (get_class_binding_direct (NODE, ctor_identifier))\n+\n+/* Nonzero if the DECL was initialized in the class definition itself,\n+   rather than outside the class.  This is used for both static member\n+   VAR_DECLS, and FUNCTION_DECLS that are defined in the class.  */\n+#define DECL_INITIALIZED_IN_CLASS_P(DECL)                                      \\\n+  (DECL_LANG_SPECIFIC (VAR_OR_FUNCTION_DECL_CHECK (DECL))                      \\\n+     ->u.base.initialized_in_class)\n+\n+/* Nonzero if DECL is explicitly defaulted in the class body.  */\n+#define DECL_DEFAULTED_IN_CLASS_P(DECL)                                        \\\n+  (DECL_DEFAULTED_FN (DECL) && DECL_INITIALIZED_IN_CLASS_P (DECL))\n+\n+/* Nonzero for FUNCTION_DECL means that this decl is a non-static\n+   member function.  */\n+#define DECL_NONSTATIC_MEMBER_FUNCTION_P(NODE)                                 \\\n+  (TREE_CODE (TREE_TYPE (NODE)) == METHOD_TYPE)\n+\n+/* For FUNCTION_DECLs: nonzero means that this function is a\n+   constructor or a destructor with an extra in-charge parameter to\n+   control whether or not virtual bases are constructed.  */\n+#define DECL_HAS_IN_CHARGE_PARM_P(NODE)                                        \\\n+  (LANG_DECL_FN_CHECK (NODE)->has_in_charge_parm_p)\n+\n+/* Nonzero if the VTT parm has been added to NODE.  */\n+#define DECL_HAS_VTT_PARM_P(NODE) (LANG_DECL_FN_CHECK (NODE)->has_vtt_parm_p)\n+\n+/* Given a FUNCTION_DECL, returns the first TREE_LIST out of TYPE_ARG_TYPES\n+   which refers to a user-written parameter.  */\n+#define FUNCTION_FIRST_USER_PARMTYPE(NODE)                                     \\\n+  skip_artificial_parms_for ((NODE), TYPE_ARG_TYPES (TREE_TYPE (NODE)))\n+\n+/* Similarly, but for DECL_ARGUMENTS.  */\n+#define FUNCTION_FIRST_USER_PARM(NODE)                                         \\\n+  skip_artificial_parms_for ((NODE), DECL_ARGUMENTS (NODE))\n+\n+/* For FUNCTION_DECLs and TEMPLATE_DECLs: nonzero means that this function\n+   is a constructor.  */\n+#define DECL_CONSTRUCTOR_P(NODE) DECL_CXX_CONSTRUCTOR_P (NODE)\n+\n+/* Nonzero if DECL was declared with '= delete'.  */\n+#define DECL_DELETED_FN(DECL)                                                  \\\n+  (LANG_DECL_FN_CHECK (DECL)->min.base.threadprivate_or_deleted_p)\n+\n+/* Nonzero if DECL was declared with '= default' (maybe implicitly).  */\n+#define DECL_DEFAULTED_FN(DECL) (LANG_DECL_FN_CHECK (DECL)->defaulted_p)\n+\n+#if defined ENABLE_TREE_CHECKING\n+\n+#define LANG_DECL_MIN_CHECK(NODE)                                              \\\n+  __extension__({                                                              \\\n+    struct lang_decl *lt = DECL_LANG_SPECIFIC (NODE);                          \\\n+    if (!LANG_DECL_HAS_MIN (NODE))                                             \\\n+      lang_check_failed (__FILE__, __LINE__, __FUNCTION__);                    \\\n+    &lt->u.min;                                                                \\\n+  })\n+\n+/* We want to be able to check DECL_CONSTRUCTOR_P and such on a function\n+   template, not just on a FUNCTION_DECL.  So when looking for things in\n+   lang_decl_fn, look down through a TEMPLATE_DECL into its result.  */\n+#define LANG_DECL_FN_CHECK(NODE)                                               \\\n+  __extension__({                                                              \\\n+    struct lang_decl *lt = DECL_LANG_SPECIFIC (NODE);                          \\\n+    if (!DECL_DECLARES_FUNCTION_P (NODE) || lt->u.base.selector != lds_fn)     \\\n+      lang_check_failed (__FILE__, __LINE__, __FUNCTION__);                    \\\n+    &lt->u.fn;                                                                 \\\n+  })\n+\n+#define LANG_DECL_NS_CHECK(NODE)                                               \\\n+  __extension__({                                                              \\\n+    struct lang_decl *lt = DECL_LANG_SPECIFIC (NODE);                          \\\n+    if (TREE_CODE (NODE) != NAMESPACE_DECL || lt->u.base.selector != lds_ns)   \\\n+      lang_check_failed (__FILE__, __LINE__, __FUNCTION__);                    \\\n+    &lt->u.ns;                                                                 \\\n+  })\n+\n+#define LANG_DECL_PARM_CHECK(NODE)                                             \\\n+  __extension__({                                                              \\\n+    struct lang_decl *lt = DECL_LANG_SPECIFIC (NODE);                          \\\n+    if (TREE_CODE (NODE) != PARM_DECL || lt->u.base.selector != lds_parm)      \\\n+      lang_check_failed (__FILE__, __LINE__, __FUNCTION__);                    \\\n+    &lt->u.parm;                                                               \\\n+  })\n+\n+#define LANG_DECL_DECOMP_CHECK(NODE)                                           \\\n+  __extension__({                                                              \\\n+    struct lang_decl *lt = DECL_LANG_SPECIFIC (NODE);                          \\\n+    if (!VAR_P (NODE) || lt->u.base.selector != lds_decomp)                    \\\n+      lang_check_failed (__FILE__, __LINE__, __FUNCTION__);                    \\\n+    &lt->u.decomp;                                                             \\\n+  })\n+\n+#else\n+\n+#define LANG_DECL_MIN_CHECK(NODE) (&DECL_LANG_SPECIFIC (NODE)->u.min)\n+\n+#define LANG_DECL_FN_CHECK(NODE) (&DECL_LANG_SPECIFIC (NODE)->u.fn)\n+\n+#define LANG_DECL_NS_CHECK(NODE) (&DECL_LANG_SPECIFIC (NODE)->u.ns)\n+\n+#define LANG_DECL_PARM_CHECK(NODE) (&DECL_LANG_SPECIFIC (NODE)->u.parm)\n+\n+#define LANG_DECL_DECOMP_CHECK(NODE) (&DECL_LANG_SPECIFIC (NODE)->u.decomp)\n+\n+#endif /* ENABLE_TREE_CHECKING */\n+\n // Below macros are copied from gcc/c-family/c-common.h\n \n /* In a FIELD_DECL, nonzero if the decl was originally a bitfield.  */\n@@ -1744,6 +1869,38 @@ extern bool same_type_ignoring_top_level_qualifiers_p (tree, tree);\n \n extern bool comp_ptr_ttypes_const\t\t(tree, tree, compare_bounds_t);\n \n+extern tree\n+get_class_binding_direct (tree, tree, bool want_type = false);\n+\n+extern tree skip_artificial_parms_for (const_tree, tree);\n+\n+extern void\n+lang_check_failed (const char *, int,\n+\t\t   const char *) ATTRIBUTE_NORETURN ATTRIBUTE_COLD;\n+\n+extern tree default_init_uninitialized_part (tree);\n+\n+extern bool type_has_non_user_provided_default_constructor (tree);\n+\n+extern bool default_ctor_p (const_tree);\n+\n+extern bool user_provided_p (tree);\n+\n+extern bool sufficient_parms_p (const_tree);\n+\n+extern tree next_initializable_field (tree);\n+\n+extern tree in_class_defaulted_default_constructor (tree);\n+\n+extern bool is_instantiation_of_constexpr (tree);\n+\n+extern bool\n+check_for_uninitialized_const_var (tree, bool, tsubst_flags_t);\n+\n+extern bool reduced_constant_expression_p (tree);\n+\n+extern tree cv_unqualified (tree);\n+\n // forked from gcc/cp/cp-tree.h\n \n enum"}]}