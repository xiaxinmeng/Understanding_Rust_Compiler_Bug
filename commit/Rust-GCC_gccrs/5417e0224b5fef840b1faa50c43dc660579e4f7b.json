{"sha": "5417e0224b5fef840b1faa50c43dc660579e4f7b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQxN2UwMjI0YjVmZWY4NDBiMWZhYTUwYzQzZGM2NjA1NzllNGY3Yg==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2007-05-29T21:55:47Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2007-05-29T21:55:47Z"}, "message": "tree-vectorizer.h (DR_MISALIGNMENT): Cast aux to integer.\n\n\t* tree-vectorizer.h (DR_MISALIGNMENT): Cast aux to integer.\n\t(SET_DR_MISALIGNMENT): New.\n\t* tree-vect-analyze.c (vect_compute_data_ref_alignment,\n\tvect_update_misalignment_for_peel, vect_enhance_data_refs_alignment):\n\tUse SET_DR_MISALIGNMENT.\n\t* tree-predcom.c (split_data_refs_to_components): Cast dr->aux from\n\tpointer.\n\t* tree-data-ref.c (create_data_ref, compute_all_dependences,\n\tfind_loop_nest): Export.\n\t* tree-data-ref.h (struct data_reference): Change aux field to pointer.\n\t(create_data_ref, compute_all_dependences, find_loop_nest): Declare.\n\t* tree-ssa-loop-prefetch.c: Include tree-data-ref.h.\n\t(L1_CACHE_SIZE_BYTES, L2_CACHE_SIZE_BYTES, NONTEMPORAL_FRACTION):\n\tNew macros.\n\t(struct mem_ref): Add field reuse_distance.\n\t(find_or_create_group, record_ref): Use XNEW instead of xcalloc.\n\tInitialize reuse_distance field.\n\t(issue_prefetch_ref): Select temporality of prefetch according to\n\treuse_distance.\n\t(volume_of_references, volume_of_dist_vector, add_subscript_strides,\n\tself_reuse_distance, determine_loop_nest_reuse): New functions.\n\t(loop_prefetch_arrays): Call determine_loop_nest_reuse.\n\t(tree_ssa_prefetch_arrays): Dump L2 cache size.\n\t* Makefile.in (tree-ssa-loop-prefetch.o): Add TREE_DATA_REF_H\n\tdependency.\n\n\t* gcc.dg/tree-ssa/prefetch-6.c: New test.\n\nFrom-SVN: r125172", "tree": {"sha": "e755e23b8c84859e189788b0f53371eb79533cf9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e755e23b8c84859e189788b0f53371eb79533cf9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5417e0224b5fef840b1faa50c43dc660579e4f7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5417e0224b5fef840b1faa50c43dc660579e4f7b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5417e0224b5fef840b1faa50c43dc660579e4f7b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5417e0224b5fef840b1faa50c43dc660579e4f7b/comments", "author": null, "committer": null, "parents": [{"sha": "cd5ecab6a73af62791d39b85db942600ccc37dad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd5ecab6a73af62791d39b85db942600ccc37dad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd5ecab6a73af62791d39b85db942600ccc37dad"}], "stats": {"total": 483, "additions": 453, "deletions": 30}, "files": [{"sha": "9c7429514dfe21b1b785f5a98aeda3a44a157300", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5417e0224b5fef840b1faa50c43dc660579e4f7b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5417e0224b5fef840b1faa50c43dc660579e4f7b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5417e0224b5fef840b1faa50c43dc660579e4f7b", "patch": "@@ -1,9 +1,37 @@\n+2007-05-29  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* tree-vectorizer.h (DR_MISALIGNMENT): Cast aux to integer.\n+\t(SET_DR_MISALIGNMENT): New.\n+\t* tree-vect-analyze.c (vect_compute_data_ref_alignment,\n+\tvect_update_misalignment_for_peel, vect_enhance_data_refs_alignment):\n+\tUse SET_DR_MISALIGNMENT.\n+\t* tree-predcom.c (split_data_refs_to_components): Cast dr->aux from\n+\tpointer.\n+\t* tree-data-ref.c (create_data_ref, compute_all_dependences,\n+\tfind_loop_nest): Export.\n+\t* tree-data-ref.h (struct data_reference): Change aux field to pointer.\n+\t(create_data_ref, compute_all_dependences, find_loop_nest): Declare.\n+\t* tree-ssa-loop-prefetch.c: Include tree-data-ref.h.\n+\t(L1_CACHE_SIZE_BYTES, L2_CACHE_SIZE_BYTES, NONTEMPORAL_FRACTION):\n+\tNew macros.\n+\t(struct mem_ref): Add field reuse_distance.\n+\t(find_or_create_group, record_ref): Use XNEW instead of xcalloc.\n+\tInitialize reuse_distance field.\n+\t(issue_prefetch_ref): Select temporality of prefetch according to\n+\treuse_distance.\n+\t(volume_of_references, volume_of_dist_vector, add_subscript_strides,\n+\tself_reuse_distance, determine_loop_nest_reuse): New functions.\n+\t(loop_prefetch_arrays): Call determine_loop_nest_reuse.\n+\t(tree_ssa_prefetch_arrays): Dump L2 cache size.\n+\t* Makefile.in (tree-ssa-loop-prefetch.o): Add TREE_DATA_REF_H\n+\tdependency.\n+\n 2007-05-29  Daniel Berlin  <dberlin@dberlin.org>\n \n \t* tree-ssa-alias.c: Add aliasing overview.\n \n 2007-05-29  Zuxy Meng  <zuxy.meng@gmail.com>\n-            Danny Smith  <dannysmith@users.sourceforge.net>\n+\t    Danny Smith  <dannysmith@users.sourceforge.net>\n \n \tPR target/29498\n \t* config/i386/t-crtfm: Compile crtfastmath.o with"}, {"sha": "605a0bdff4de5c982ddc8551a5a7cfa6ad7b1211", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5417e0224b5fef840b1faa50c43dc660579e4f7b/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5417e0224b5fef840b1faa50c43dc660579e4f7b/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=5417e0224b5fef840b1faa50c43dc660579e4f7b", "patch": "@@ -2084,7 +2084,7 @@ tree-ssa-loop-prefetch.o: tree-ssa-loop-prefetch.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    output.h $(DIAGNOSTIC_H) $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n    tree-pass.h $(GGC_H) $(RECOG_H) insn-config.h $(HASHTAB_H) $(SCEV_H) \\\n    $(CFGLOOP_H) $(PARAMS_H) langhooks.h $(BASIC_BLOCK_H) hard-reg-set.h \\\n-   tree-chrec.h toplev.h langhooks.h $(TREE_INLINE_H)\n+   tree-chrec.h toplev.h langhooks.h $(TREE_INLINE_H) $(TREE_DATA_REF_H)\n tree-predcom.o: tree-predcom.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(TM_P_H) \\\n    $(CFGLOOP_H) $(TREE_FLOW_H) $(GGC_H) $(TREE_DATA_REF_H) $(SCEV_H) \\\n    $(PARAMS_H) $(DIAGNOSTIC_H) tree-pass.h $(TM_H) coretypes.h tree-affine.h \\"}, {"sha": "6340ca4036eea8f3fa9a00bcabc385e3aa2d3dfb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5417e0224b5fef840b1faa50c43dc660579e4f7b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5417e0224b5fef840b1faa50c43dc660579e4f7b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5417e0224b5fef840b1faa50c43dc660579e4f7b", "patch": "@@ -1,3 +1,7 @@\n+2007-05-29  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* gcc.dg/tree-ssa/prefetch-6.c: New test.\n+\n 2007-05-29  Tobias Schl\ufffdter  <tobi@gcc.gnu.org>\n \n \t* gfortran.dg/sizeof.f90: New."}, {"sha": "44f65bffb20c4f2c6fd8ca3286fb6444da94cfbc", "filename": "gcc/testsuite/gcc.dg/tree-ssa/prefetch-6.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5417e0224b5fef840b1faa50c43dc660579e4f7b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fprefetch-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5417e0224b5fef840b1faa50c43dc660579e4f7b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fprefetch-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fprefetch-6.c?ref=5417e0224b5fef840b1faa50c43dc660579e4f7b", "patch": "@@ -0,0 +1,54 @@\n+/* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n+/* { dg-require-effective-target ilp32 } */\n+/* { dg-options \"-O2 -fprefetch-loop-arrays -march=athlon -msse2 -mfpmath=sse --param simultaneous-prefetches=100 -fdump-tree-aprefetch-details\" } */\n+\n+#define N 1000\n+#define K 900\n+\n+double a[N][N];\n+\n+double test(void)\n+{\n+  unsigned i, j;\n+  double sum = 0;\n+\n+  /* Here, we should use non-temporal prefetch instruction.  */\n+  for (i = 0; i < K; i++)\n+    for (j = 0; j < K; j++)\n+      sum += a[i][j];\n+\n+  /* Here, we should not use non-temporal prefetch instruction, since the\n+     value of a[i+10][j] is reused in L2 cache.  */\n+  for (i = 0; i < K; i++)\n+    for (j = 0; j < K; j++)\n+      sum += a[i][j] * a[i + 10][j];\n+\n+  /* Here, we should use non-temporal prefetch instruction, since the\n+     value of a[i+100][j] is too far to be reused in L2 cache.  */\n+  for (i = 0; i < K; i++)\n+    for (j = 0; j < K; j++)\n+      sum += a[i][j] * a[i + 100][j];\n+\n+  /* Here, temporal prefetches should be used, since the volume of the\n+     memory accesses is smaller than L2 cache.  */\n+  for (i = 0; i < 100; i++)\n+    for (j = 0; j < 100; j++)\n+      sum += a[i][j] * a[i + 100][j];\n+\n+  /* Temporal prefetches should be used here (even though the accesses to\n+     a[j][i] are independent, the same cache line is almost always hit\n+     every N iterations).  */\n+  for (i = 0; i < N; i++)\n+    for (j = 0; j < N; j++)\n+      sum += a[j][i];\n+\n+  return sum;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Issued prefetch\" 5 \"aprefetch\" } } */\n+/* { dg-final { scan-tree-dump-times \"Issued nontemporal prefetch\" 3 \"aprefetch\" } } */\n+\n+/* { dg-final { scan-assembler-times \"prefetcht\" 5 } } */\n+/* { dg-final { scan-assembler-times \"prefetchnta\" 3 } } */\n+\n+/* { dg-final { cleanup-tree-dump \"aprefetch\" } } */"}, {"sha": "99f8fd2b91f8083a7bb4839fb102f19f61453423", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5417e0224b5fef840b1faa50c43dc660579e4f7b/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5417e0224b5fef840b1faa50c43dc660579e4f7b/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=5417e0224b5fef840b1faa50c43dc660579e4f7b", "patch": "@@ -771,7 +771,7 @@ free_data_ref (data_reference_p dr)\n    data_reference description of MEMREF.  NEST is the outermost loop of the\n    loop nest in that the reference should be analysed.  */\n \n-static struct data_reference *\n+struct data_reference *\n create_data_ref (struct loop *nest, tree memref, tree stmt, bool is_read)\n {\n   struct data_reference *dr;\n@@ -3843,7 +3843,7 @@ compute_self_dependence (struct data_dependence_relation *ddr)\n    COMPUTE_SELF_AND_RR is FALSE, don't compute read-read and self\n    relations.  */\n \n-static void \n+void \n compute_all_dependences (VEC (data_reference_p, heap) *datarefs,\n \t\t\t VEC (ddr_p, heap) **dependence_relations,\n \t\t\t VEC (loop_p, heap) *loop_nest,\n@@ -4055,7 +4055,7 @@ find_loop_nest_1 (struct loop *loop, VEC (loop_p, heap) **loop_nest)\n    contain the loops from the outermost to the innermost, as they will\n    appear in the classic distance vector.  */\n \n-static bool\n+bool\n find_loop_nest (struct loop *loop, VEC (loop_p, heap) **loop_nest)\n {\n   VEC_safe_push (loop_p, heap, *loop_nest, loop);"}, {"sha": "ddff36a0ec0f7365d8bb4e8e6b2b2b3c8d58fda4", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5417e0224b5fef840b1faa50c43dc660579e4f7b/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5417e0224b5fef840b1faa50c43dc660579e4f7b/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=5417e0224b5fef840b1faa50c43dc660579e4f7b", "patch": "@@ -104,7 +104,7 @@ struct data_reference\n   tree ref;\n \n   /* Auxiliary info specific to a pass.  */\n-  int aux;\n+  void *aux;\n \n   /* True when the data reference is in RHS of a stmt.  */\n   bool is_read;\n@@ -320,7 +320,10 @@ extern void dump_data_dependence_direction (FILE *,\n extern void free_dependence_relation (struct data_dependence_relation *);\n extern void free_dependence_relations (VEC (ddr_p, heap) *);\n extern void free_data_refs (VEC (data_reference_p, heap) *);\n-\n+struct data_reference *create_data_ref (struct loop *, tree, tree, bool);\n+bool find_loop_nest (struct loop *, VEC (loop_p, heap) **);\n+void compute_all_dependences (VEC (data_reference_p, heap) *,\n+\t\t\t      VEC (ddr_p, heap) **, VEC (loop_p, heap) *, bool);\n \n /* Return the index of the variable VAR in the LOOP_NEST array.  */\n "}, {"sha": "a3a137f7d28541e1355f287b0d86920d3ccface7", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5417e0224b5fef840b1faa50c43dc660579e4f7b/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5417e0224b5fef840b1faa50c43dc660579e4f7b/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=5417e0224b5fef840b1faa50c43dc660579e4f7b", "patch": "@@ -700,7 +700,7 @@ split_data_refs_to_components (struct loop *loop,\n \t     just fail.  */\n \t  goto end;\n \t}\n-      dr->aux = i;\n+      dr->aux = (void *) (size_t) i;\n       comp_father[i] = i;\n       comp_size[i] = 1;\n     }\n@@ -715,7 +715,7 @@ split_data_refs_to_components (struct loop *loop,\n \n       if (!suitable_reference_p (dr, &dummy))\n \t{\n-\t  ia = dr->aux;\n+\t  ia = (unsigned) (size_t) dr->aux;\n \t  merge_comps (comp_father, comp_size, n, ia);\n \t}\n     }\n@@ -729,8 +729,8 @@ split_data_refs_to_components (struct loop *loop,\n \n       dra = DDR_A (ddr);\n       drb = DDR_B (ddr);\n-      ia = component_of (comp_father, dra->aux);\n-      ib = component_of (comp_father, drb->aux);\n+      ia = component_of (comp_father, (unsigned) (size_t) dra->aux);\n+      ib = component_of (comp_father, (unsigned) (size_t) drb->aux);\n       if (ia == ib)\n \tcontinue;\n \n@@ -749,7 +749,7 @@ split_data_refs_to_components (struct loop *loop,\n   bad = component_of (comp_father, n);\n   for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n     {\n-      ia = dr->aux;\n+      ia = (unsigned) (size_t) dr->aux;\n       ca = component_of (comp_father, ia);\n       if (ca == bad)\n \tcontinue;"}, {"sha": "3159748c672588be34feb0fd92f84141cc91e6be", "filename": "gcc/tree-ssa-loop-prefetch.c", "status": "modified", "additions": 339, "deletions": 8, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5417e0224b5fef840b1faa50c43dc660579e4f7b/gcc%2Ftree-ssa-loop-prefetch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5417e0224b5fef840b1faa50c43dc660579e4f7b/gcc%2Ftree-ssa-loop-prefetch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-prefetch.c?ref=5417e0224b5fef840b1faa50c43dc660579e4f7b", "patch": "@@ -46,6 +46,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"params.h\"\n #include \"langhooks.h\"\n #include \"tree-inline.h\"\n+#include \"tree-data-ref.h\"\n \n /* This pass inserts prefetch instructions to optimize cache usage during\n    accesses to arrays in loops.  It processes loops sequentially and:\n@@ -82,6 +83,10 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \t   7/32.\n        (5) has PREFETCH_MOD 1 as well.\n \n+      Additionally, we use data dependence analysis to determine for each\n+      reference the distance till the first reuse; this information is used\n+      to determine the temporality of the issued prefetch instruction.\n+\n    3) We determine how much ahead we need to prefetch.  The number of\n       iterations needed is time to fetch / time spent in one iteration of\n       the loop.  The problem is that we do not know either of these values,\n@@ -161,6 +166,17 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define HAVE_prefetch 0\n #endif\n \n+#define L1_CACHE_SIZE_BYTES ((unsigned) (L1_CACHE_SIZE * L1_CACHE_LINE_SIZE))\n+/* TODO:  Add parameter to specify L2 cache size.  */\n+#define L2_CACHE_SIZE_BYTES (8 * L1_CACHE_SIZE_BYTES)\n+\n+/* We consider a memory access nontemporal if it is not reused sooner than\n+   after L2_CACHE_SIZE_BYTES of memory are accessed.  However, we ignore\n+   accesses closer than L1_CACHE_SIZE_BYTES / NONTEMPORAL_FRACTION,\n+   so that we use nontemporal prefetches e.g. if single memory location\n+   is accessed several times in a single iteration of the loop.  */\n+#define NONTEMPORAL_FRACTION 16\n+\n /* The group of references between that reuse may occur.  */\n \n struct mem_ref_group\n@@ -190,6 +206,8 @@ struct mem_ref\n   unsigned HOST_WIDE_INT prefetch_before;\n \t\t\t\t/* Prefetch only first PREFETCH_BEFORE\n \t\t\t\t   iterations.  */\n+  unsigned reuse_distance;\t/* The amount of data accessed before the first\n+\t\t\t\t   reuse of this value.  */\n   bool issue_prefetch_p;\t/* Should we really issue the prefetch?  */\n   struct mem_ref *next;\t\t/* The next reference in the group.  */\n };\n@@ -236,7 +254,7 @@ find_or_create_group (struct mem_ref_group **groups, tree base,\n \tbreak;\n     }\n \n-  group = xcalloc (1, sizeof (struct mem_ref_group));\n+  group = XNEW (struct mem_ref_group);\n   group->base = base;\n   group->step = step;\n   group->refs = NULL;\n@@ -273,13 +291,14 @@ record_ref (struct mem_ref_group *group, tree stmt, tree mem,\n \treturn;\n     }\n \n-  (*aref) = xcalloc (1, sizeof (struct mem_ref));\n+  (*aref) = XNEW (struct mem_ref);\n   (*aref)->stmt = stmt;\n   (*aref)->mem = mem;\n   (*aref)->delta = delta;\n   (*aref)->write_p = write_p;\n   (*aref)->prefetch_before = PREFETCH_ALL;\n   (*aref)->prefetch_mod = 1;\n+  (*aref)->reuse_distance = 0;\n   (*aref)->issue_prefetch_p = false;\n   (*aref)->group = group;\n   (*aref)->next = NULL;\n@@ -815,12 +834,15 @@ static void\n issue_prefetch_ref (struct mem_ref *ref, unsigned unroll_factor, unsigned ahead)\n {\n   HOST_WIDE_INT delta;\n-  tree addr, addr_base, prefetch, write_p;\n+  tree addr, addr_base, prefetch, write_p, local;\n   block_stmt_iterator bsi;\n   unsigned n_prefetches, ap;\n+  bool nontemporal = ref->reuse_distance >= L2_CACHE_SIZE_BYTES;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"Issued prefetch for %p.\\n\", (void *) ref);\n+    fprintf (dump_file, \"Issued%s prefetch for %p.\\n\",\n+\t     nontemporal ? \" nontemporal\" : \"\",\n+\t     (void *) ref);\n \n   bsi = bsi_for_stmt (ref->stmt);\n \n@@ -829,6 +851,7 @@ issue_prefetch_ref (struct mem_ref *ref, unsigned unroll_factor, unsigned ahead)\n   addr_base = build_fold_addr_expr_with_type (ref->mem, ptr_type_node);\n   addr_base = force_gimple_operand_bsi (&bsi, unshare_expr (addr_base), true, NULL);\n   write_p = ref->write_p ? integer_one_node : integer_zero_node;\n+  local = build_int_cst (integer_type_node, nontemporal ? 0 : 3);\n \n   for (ap = 0; ap < n_prefetches; ap++)\n     {\n@@ -840,7 +863,7 @@ issue_prefetch_ref (struct mem_ref *ref, unsigned unroll_factor, unsigned ahead)\n \n       /* Create the prefetch instruction.  */\n       prefetch = build_call_expr (built_in_decls[BUILT_IN_PREFETCH],\n-\t\t\t\t  2, addr, write_p);\n+\t\t\t\t  3, addr, write_p, local);\n       bsi_insert_before (&bsi, prefetch, BSI_SAME_STMT);\n     }\n }\n@@ -935,6 +958,311 @@ determine_unroll_factor (struct loop *loop, struct mem_ref_group *refs,\n   return factor;\n }\n \n+/* Returns the total volume of the memory references REFS, taking into account\n+   reuses in the innermost loop and cache line size.  TODO -- we should also\n+   take into account reuses across the iterations of the loops in the loop\n+   nest.  */\n+\n+static unsigned\n+volume_of_references (struct mem_ref_group *refs)\n+{\n+  unsigned volume = 0;\n+  struct mem_ref_group *gr;\n+  struct mem_ref *ref;\n+\n+  for (gr = refs; gr; gr = gr->next)\n+    for (ref = gr->refs; ref; ref = ref->next)\n+      {\n+\t/* Almost always reuses another value?  */\n+\tif (ref->prefetch_before != PREFETCH_ALL)\n+\t  continue;\n+\n+\t/* If several iterations access the same cache line, use the size of\n+\t   the line divided by this number.  Otherwise, a cache line is\n+\t   accessed in each iteration.  TODO -- in the latter case, we should\n+\t   take the size of the reference into account, rounding it up on cache\n+\t   line size multiple.  */\n+\tvolume += L1_CACHE_LINE_SIZE / ref->prefetch_mod;\n+      }\n+  return volume;\n+}\n+\n+/* Returns the volume of memory references accessed across VEC iterations of\n+   loops, whose sizes are described in the LOOP_SIZES array.  N is the number\n+   of the loops in the nest (length of VEC and LOOP_SIZES vectors).  */\n+\n+static unsigned\n+volume_of_dist_vector (lambda_vector vec, unsigned *loop_sizes, unsigned n)\n+{\n+  unsigned i;\n+\n+  for (i = 0; i < n; i++)\n+    if (vec[i] != 0)\n+      break;\n+\n+  if (i == n)\n+    return 0;\n+\n+  gcc_assert (vec[i] > 0);\n+\n+  /* We ignore the parts of the distance vector in subloops, since usually\n+     the numbers of iterations are much smaller.  */\n+  return loop_sizes[i] * vec[i];\n+}\n+\n+/* Add the steps of ACCESS_FN multiplied by STRIDE to the array STRIDE\n+   at the position corresponding to the loop of the step.  N is the depth\n+   of the considered loop nest, and, LOOP is its innermost loop.  */\n+\n+static void\n+add_subscript_strides (tree access_fn, unsigned stride,\n+\t\t       HOST_WIDE_INT *strides, unsigned n, struct loop *loop)\n+{\n+  struct loop *aloop;\n+  tree step;\n+  HOST_WIDE_INT astep;\n+  unsigned min_depth = loop_depth (loop) - n;\n+\n+  while (TREE_CODE (access_fn) == POLYNOMIAL_CHREC)\n+    {\n+      aloop = get_chrec_loop (access_fn);\n+      step = CHREC_RIGHT (access_fn);\n+      access_fn = CHREC_LEFT (access_fn);\n+\n+      if ((unsigned) loop_depth (aloop) <= min_depth)\n+\tcontinue;\n+\n+      if (host_integerp (step, 0))\n+\tastep = tree_low_cst (step, 0);\n+      else\n+\tastep = L1_CACHE_LINE_SIZE;\n+\n+      strides[n - 1 - loop_depth (loop) + loop_depth (aloop)] += astep * stride;\n+\n+    }\n+}\n+\n+/* Returns the volume of memory references accessed between two consecutive\n+   self-reuses of the reference DR.  We consider the subscripts of DR in N\n+   loops, and LOOP_SIZES contains the volumes of accesses in each of the\n+   loops.  LOOP is the innermost loop of the current loop nest.  */\n+\n+static unsigned\n+self_reuse_distance (data_reference_p dr, unsigned *loop_sizes, unsigned n,\n+\t\t     struct loop *loop)\n+{\n+  tree stride, access_fn;\n+  HOST_WIDE_INT *strides, astride;\n+  VEC (tree, heap) *access_fns;\n+  tree ref = DR_REF (dr);\n+  unsigned i, ret = ~0u;\n+\n+  /* In the following example:\n+\n+     for (i = 0; i < N; i++)\n+       for (j = 0; j < N; j++)\n+         use (a[j][i]);\n+     the same cache line is accessed each N steps (except if the change from\n+     i to i + 1 crosses the boundary of the cache line).  Thus, for self-reuse,\n+     we cannot rely purely on the results of the data dependence analysis.\n+\n+     Instead, we compute the stride of the reference in each loop, and consider\n+     the innermost loop in that the stride is less than cache size.  */\n+\n+  strides = XCNEWVEC (HOST_WIDE_INT, n);\n+  access_fns = DR_ACCESS_FNS (dr);\n+\n+  for (i = 0; VEC_iterate (tree, access_fns, i, access_fn); i++)\n+    {\n+      /* Keep track of the reference corresponding to the subscript, so that we\n+\t know its stride.  */\n+      while (handled_component_p (ref) && TREE_CODE (ref) != ARRAY_REF)\n+\tref = TREE_OPERAND (ref, 0);\n+      \n+      if (TREE_CODE (ref) == ARRAY_REF)\n+\t{\n+\t  stride = TYPE_SIZE_UNIT (TREE_TYPE (ref));\n+\t  if (host_integerp (stride, 1))\n+\t    astride = tree_low_cst (stride, 1);\n+\t  else\n+\t    astride = L1_CACHE_LINE_SIZE;\n+\n+\t  ref = TREE_OPERAND (ref, 0);\n+\t}\n+      else\n+\tastride = 1;\n+\n+      add_subscript_strides (access_fn, astride, strides, n, loop);\n+    }\n+\n+  for (i = n; i-- > 0; )\n+    {\n+      unsigned HOST_WIDE_INT s;\n+\n+      s = strides[i] < 0 ?  -strides[i] : strides[i];\n+\n+      if (s < (unsigned) L1_CACHE_LINE_SIZE\n+\t  && (loop_sizes[i]\n+\t      > (unsigned) (L1_CACHE_SIZE_BYTES / NONTEMPORAL_FRACTION)))\n+\t{\n+\t  ret = loop_sizes[i];\n+\t  break;\n+\t}\n+    }\n+\n+  free (strides);\n+  return ret;\n+}\n+\n+/* Determines the distance till the first reuse of each reference in REFS\n+   in the loop nest of LOOP.  */\n+\n+static void\n+determine_loop_nest_reuse (struct loop *loop, struct mem_ref_group *refs)\n+{\n+  struct loop *nest, *aloop;\n+  VEC (data_reference_p, heap) *datarefs = NULL;\n+  VEC (ddr_p, heap) *dependences = NULL;\n+  struct mem_ref_group *gr;\n+  struct mem_ref *ref;\n+  VEC (loop_p, heap) *vloops = NULL;\n+  unsigned *loop_data_size;\n+  unsigned i, j, n;\n+  unsigned volume, dist, adist;\n+  HOST_WIDE_INT vol;\n+  data_reference_p dr;\n+  ddr_p dep;\n+\n+  if (loop->inner)\n+    return;\n+\n+  /* Find the outermost loop of the loop nest of loop (we require that\n+     there are no sibling loops inside the nest).  */\n+  nest = loop;\n+  while (1)\n+    {\n+      aloop = loop_outer (nest);\n+\n+      if (aloop == current_loops->tree_root\n+\t  || aloop->inner->next)\n+\tbreak;\n+\n+      nest = aloop;\n+    }\n+\n+  /* For each loop, determine the amount of data accessed in each iteration.\n+     We use this to estimate whether the reference is evicted from the\n+     cache before its reuse.  */\n+  find_loop_nest (nest, &vloops);\n+  n = VEC_length (loop_p, vloops);\n+  loop_data_size = XNEWVEC (unsigned, n);\n+  volume = volume_of_references (refs);\n+  i = n;\n+  while (i-- != 0)\n+    {\n+      loop_data_size[i] = volume;\n+      /* Bound the volume by the L2 cache size, since above this bound,\n+\t all dependence distances are equivalent.  */\n+      if (volume > L2_CACHE_SIZE_BYTES)\n+\tcontinue;\n+\n+      aloop = VEC_index (loop_p, vloops, i);\n+      vol = estimated_loop_iterations_int (aloop, false);\n+      if (vol < 0)\n+\tvol = expected_loop_iterations (aloop);\n+      volume *= vol;\n+    }\n+\n+  /* Prepare the references in the form suitable for data dependence\n+     analysis.  We ignore unanalysable data references (the results\n+     are used just as a heuristics to estimate temporality of the\n+     references, hence we do not need to worry about correctness).  */\n+  for (gr = refs; gr; gr = gr->next)\n+    for (ref = gr->refs; ref; ref = ref->next)\n+      {\n+\tdr = create_data_ref (nest, ref->mem, ref->stmt, !ref->write_p);\n+\n+\tif (dr)\n+\t  {\n+\t    ref->reuse_distance = volume;\n+\t    dr->aux = ref;\n+\t    VEC_safe_push (data_reference_p, heap, datarefs, dr);\n+\t  }\n+      }\n+\n+  for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n+    {\n+      dist = self_reuse_distance (dr, loop_data_size, n, loop);\n+      ref = dr->aux;\n+      if (ref->reuse_distance > dist)\n+\tref->reuse_distance = dist;\n+    }\n+\n+  compute_all_dependences (datarefs, &dependences, vloops, true);\n+\n+  for (i = 0; VEC_iterate (ddr_p, dependences, i, dep); i++)\n+    {\n+      if (DDR_ARE_DEPENDENT (dep) == chrec_known)\n+\tcontinue;\n+\n+      if (DDR_ARE_DEPENDENT (dep) == chrec_dont_know\n+\t  || DDR_NUM_DIST_VECTS (dep) == 0)\n+\t{\n+\t  /* If the dependence cannot be analysed, assume that there might be\n+\t     a reuse.  */\n+\t  dist = 0;\n+\t}\n+      else\n+\t{\n+\t  /* The distance vectors are normalised to be always lexicographically\n+\t     positive, hence we cannot tell just from them whether DDR_A comes\n+\t     before DDR_B or vice versa.  However, it is not important,\n+\t     anyway -- if DDR_A is close to DDR_B, then it is either reused in\n+\t     DDR_B (and it is not nontemporal), or it reuses the value of DDR_B\n+\t     in cache (and marking it as nontemporal would not affect\n+\t     anything).  */\n+\n+\t  dist = volume;\n+\t  for (j = 0; j < DDR_NUM_DIST_VECTS (dep); j++)\n+\t    {\n+\t      adist = volume_of_dist_vector (DDR_DIST_VECT (dep, j),\n+\t\t\t\t\t     loop_data_size, n);\n+\n+\t      /* Ignore accesses closer than\n+\t\t L1_CACHE_SIZE_BYTES / NONTEMPORAL_FRACTION,\n+\t      \t so that we use nontemporal prefetches e.g. if single memory\n+\t\t location is accessed several times in a single iteration of\n+\t\t the loop.  */\n+\t      if (adist < L1_CACHE_SIZE_BYTES / NONTEMPORAL_FRACTION)\n+\t\tcontinue;\n+\n+\t      if (adist < dist)\n+\t\tdist = adist;\n+\t    }\n+\t}\n+\n+      ref = DDR_A (dep)->aux;\n+      if (ref->reuse_distance > dist)\n+\tref->reuse_distance = dist;\n+      ref = DDR_B (dep)->aux;\n+      if (ref->reuse_distance > dist)\n+\tref->reuse_distance = dist;\n+    }\n+\n+  free_dependence_relations (dependences);\n+  free_data_refs (datarefs);\n+  free (loop_data_size);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Reuse distances:\\n\");\n+      for (gr = refs; gr; gr = gr->next)\n+\tfor (ref = gr->refs; ref; ref = ref->next)\n+\t  fprintf (dump_file, \" ref %p distance %u\\n\",\n+\t\t   (void *) ref, ref->reuse_distance);\n+    }\n+}\n+\n /* Issue prefetch instructions for array references in LOOP.  Returns\n    true if the LOOP was unrolled.  */\n \n@@ -963,6 +1291,8 @@ loop_prefetch_arrays (struct loop *loop)\n   if (!anything_to_prefetch_p (refs))\n     goto fail;\n \n+  determine_loop_nest_reuse (loop, refs);\n+\n   /* Step 3: determine the ahead and unroll factor.  */\n \n   /* FIXME: the time should be weighted by the probabilities of the blocks in\n@@ -1034,10 +1364,11 @@ tree_ssa_prefetch_arrays (void)\n       fprintf (dump_file, \"    simultaneous prefetches: %d\\n\",\n \t       SIMULTANEOUS_PREFETCHES);\n       fprintf (dump_file, \"    prefetch latency: %d\\n\", PREFETCH_LATENCY);\n-      fprintf (dump_file, \"    L1 cache size: %d (%d bytes)\\n\",\n-\t       L1_CACHE_SIZE, L1_CACHE_SIZE * L1_CACHE_LINE_SIZE);\n-      fprintf (dump_file, \"    L1 cache line size: %d\\n\", L1_CACHE_LINE_SIZE);\n       fprintf (dump_file, \"    prefetch block size: %d\\n\", PREFETCH_BLOCK);\n+      fprintf (dump_file, \"    L1 cache size: %d lines, %d bytes\\n\",\n+\t       L1_CACHE_SIZE, L1_CACHE_SIZE_BYTES);\n+      fprintf (dump_file, \"    L1 cache line size: %d\\n\", L1_CACHE_LINE_SIZE);\n+      fprintf (dump_file, \"    L2 cache size: %d bytes\\n\", L2_CACHE_SIZE_BYTES);\n       fprintf (dump_file, \"\\n\");\n     }\n "}, {"sha": "647d98f82a60bb72cf187ebc7e0fbb7489109cf3", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5417e0224b5fef840b1faa50c43dc660579e4f7b/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5417e0224b5fef840b1faa50c43dc660579e4f7b/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=5417e0224b5fef840b1faa50c43dc660579e4f7b", "patch": "@@ -1128,7 +1128,7 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n     fprintf (vect_dump, \"vect_compute_data_ref_alignment:\");\n \n   /* Initialize misalignment to unknown.  */\n-  DR_MISALIGNMENT (dr) = -1;\n+  SET_DR_MISALIGNMENT (dr, -1);\n \n   misalign = DR_INIT (dr);\n   aligned_to = DR_ALIGNED_TO (dr);\n@@ -1198,7 +1198,7 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n       return false;\n     }\n \n-  DR_MISALIGNMENT (dr) = TREE_INT_CST_LOW (misalign);\n+  SET_DR_MISALIGNMENT (dr, TREE_INT_CST_LOW (misalign));\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     {\n@@ -1267,21 +1267,23 @@ vect_update_misalignment_for_peel (struct data_reference *dr,\n         continue;\n       gcc_assert (DR_MISALIGNMENT (dr) / dr_size ==\n                   DR_MISALIGNMENT (dr_peel) / dr_peel_size);\n-      DR_MISALIGNMENT (dr) = 0;\n+      SET_DR_MISALIGNMENT (dr, 0);\n       return;\n     }\n \n   if (known_alignment_for_access_p (dr)\n       && known_alignment_for_access_p (dr_peel))\n     {\n-      DR_MISALIGNMENT (dr) += npeel * dr_size;\n-      DR_MISALIGNMENT (dr) %= UNITS_PER_SIMD_WORD;\n+      int misal = DR_MISALIGNMENT (dr);\n+      misal += npeel * dr_size;\n+      misal %= UNITS_PER_SIMD_WORD;\n+      SET_DR_MISALIGNMENT (dr, misal);\n       return;\n     }\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"Setting misalignment to -1.\");\n-  DR_MISALIGNMENT (dr) = -1;\n+  SET_DR_MISALIGNMENT (dr, -1);\n }\n \n \n@@ -1577,7 +1579,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t  save_misalignment = DR_MISALIGNMENT (dr);\n \t  vect_update_misalignment_for_peel (dr, dr0, npeel);\n \t  supportable_dr_alignment = vect_supportable_dr_alignment (dr);\n-\t  DR_MISALIGNMENT (dr) = save_misalignment;\n+\t  SET_DR_MISALIGNMENT (dr, save_misalignment);\n \t  \n \t  if (!supportable_dr_alignment)\n \t    {\n@@ -1601,7 +1603,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \n           LOOP_VINFO_UNALIGNED_DR (loop_vinfo) = dr0;\n           LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo) = DR_MISALIGNMENT (dr0);\n-          DR_MISALIGNMENT (dr0) = 0;\n+\t  SET_DR_MISALIGNMENT (dr0, 0);\n \t  if (vect_print_dump_info (REPORT_ALIGNMENT))\n             fprintf (vect_dump, \"Alignment of access forced using peeling.\");\n \n@@ -1702,7 +1704,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n         {\n           stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n           dr = STMT_VINFO_DATA_REF (stmt_info);\n-          DR_MISALIGNMENT (dr) = 0;\n+\t  SET_DR_MISALIGNMENT (dr, 0);\n \t  if (vect_print_dump_info (REPORT_ALIGNMENT))\n             fprintf (vect_dump, \"Alignment of access forced using versioning.\");\n         }"}, {"sha": "6e20652d7bad4e0f01a9ea27d460c5bf44cae1fb", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5417e0224b5fef840b1faa50c43dc660579e4f7b/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5417e0224b5fef840b1faa50c43dc660579e4f7b/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=5417e0224b5fef840b1faa50c43dc660579e4f7b", "patch": "@@ -339,7 +339,8 @@ is_pattern_stmt_p (stmt_vec_info stmt_info)\n \n /* Reflects actual alignment of first access in the vectorized loop,\n    taking into account peeling/versioning if applied.  */\n-#define DR_MISALIGNMENT(DR)   (DR)->aux\n+#define DR_MISALIGNMENT(DR)   ((int) (size_t) (DR)->aux)\n+#define SET_DR_MISALIGNMENT(DR, VAL)   ((DR)->aux = (void *) (size_t) (VAL))\n \n static inline bool\n aligned_access_p (struct data_reference *data_ref_info)"}]}