{"sha": "01b0d4b85a401d257d9fe091e6647800b2ccbf00", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDFiMGQ0Yjg1YTQwMWQyNTdkOWZlMDkxZTY2NDc4MDBiMmNjYmYwMA==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@unitus.it", "date": "2002-01-03T19:02:18Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2002-01-03T19:02:18Z"}, "message": "stl_numeric.h (power + helpers, iota): Move to...\n\n2002-01-02  Paolo Carlini  <pcarlini@unitus.it>\n\n\t* include/bits/stl_numeric.h (power + helpers, iota):  Move to...\n\t* include/ext/numeric:  ...here, new file.\n        * include/bits/stl_function.h (identity_element, unary_compose,\n\tbinary_compose, compose1, compose2, identity, select1st,\n\tselect2nd, project1st + helper, project2nd + helper,\n\tconstant_void_fun + helper, constant_unary_fun + helper,\n\tcostant_binary_fun + helper, constant0, constant1, constant2,\n\tsubtractive_rng, mem_fun1, mem_fun1_ref):  Move to...\n        * include/ext/functional:  ...here, new file.\n        * include/Makefile.am (ext_headers):  Add new files.\n        * include/Makefile.in:  Regenerate.\n        * testsuite/ext/headers.cc:  Include <ext/numeric> and\n\t<ext/functional>.\n\t* include/backward/algo.h:  Include <ext/numeric>, tweak.\n\t* include/backward/function.h:  Include <ext/functional>, tweak.\n        * include/ext/ropeimpl.h:  Include <ext/numeric>.\n\nFrom-SVN: r48519", "tree": {"sha": "d1fbf8608dda85b1377e0f10776e1c4d0872cd4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d1fbf8608dda85b1377e0f10776e1c4d0872cd4c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01b0d4b85a401d257d9fe091e6647800b2ccbf00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01b0d4b85a401d257d9fe091e6647800b2ccbf00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01b0d4b85a401d257d9fe091e6647800b2ccbf00", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01b0d4b85a401d257d9fe091e6647800b2ccbf00/comments", "author": null, "committer": null, "parents": [{"sha": "d15a58c0f10fda3353686841a055dea7d2674d86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d15a58c0f10fda3353686841a055dea7d2674d86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d15a58c0f10fda3353686841a055dea7d2674d86"}], "stats": {"total": 971, "additions": 573, "deletions": 398}, "files": [{"sha": "bead9f702cff90d25a4c99b8643a827b8e7d36b3", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01b0d4b85a401d257d9fe091e6647800b2ccbf00/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01b0d4b85a401d257d9fe091e6647800b2ccbf00/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=01b0d4b85a401d257d9fe091e6647800b2ccbf00", "patch": "@@ -1,3 +1,22 @@\n+2002-01-03  Paolo Carlini  <pcarlini@unitus.it>\n+\n+\t* include/bits/stl_numeric.h (power + helpers, iota):  Move to...\n+\t* include/ext/numeric:  ...here, new file.\n+        * include/bits/stl_function.h (identity_element, unary_compose,\n+\tbinary_compose, compose1, compose2, identity, select1st,\n+\tselect2nd, project1st + helper, project2nd + helper,\n+\tconstant_void_fun + helper, constant_unary_fun + helper,\n+\tcostant_binary_fun + helper, constant0, constant1, constant2,\n+\tsubtractive_rng, mem_fun1, mem_fun1_ref):  Move to...\n+        * include/ext/functional:  ...here, new file.\n+        * include/Makefile.am (ext_headers):  Add new files.\n+        * include/Makefile.in:  Regenerate.\n+        * testsuite/ext/headers.cc:  Include <ext/numeric> and\n+\t<ext/functional>.\n+\t* include/backward/algo.h:  Include <ext/numeric>, tweak.\n+\t* include/backward/function.h:  Include <ext/functional>, tweak.\n+        * include/ext/ropeimpl.h:  Include <ext/numeric>.\n+\n Thu Jan  3 11:05:41 2002  Jeffrey A Law  (law@redhat.com)\n \n         * config/os/hpux/bits/os_defines.h: Prefix __strtoll and"}, {"sha": "a4a4e44c87e70a996f59f0e603b29a4e0452a1ad", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01b0d4b85a401d257d9fe091e6647800b2ccbf00/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01b0d4b85a401d257d9fe091e6647800b2ccbf00/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=01b0d4b85a401d257d9fe091e6647800b2ccbf00", "patch": "@@ -173,10 +173,12 @@ ext_srcdir = ${glibcpp_srcdir}/include/ext\n ext_builddir = ./ext\n ext_headers = \\\n \t${ext_srcdir}/algorithm \\\n+\t${ext_srcdir}/functional \\\n \t${ext_srcdir}/hash_map \\\n \t${ext_srcdir}/hash_set \\\n \t${ext_srcdir}/iterator \\\n \t${ext_srcdir}/memory \\\n+\t${ext_srcdir}/numeric \\\n \t${ext_srcdir}/rope \\\n \t${ext_srcdir}/ropeimpl.h \\\n \t${ext_srcdir}/slist \\"}, {"sha": "46d1093e67a130b66ace27648d557050cdb3232e", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01b0d4b85a401d257d9fe091e6647800b2ccbf00/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01b0d4b85a401d257d9fe091e6647800b2ccbf00/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=01b0d4b85a401d257d9fe091e6647800b2ccbf00", "patch": "@@ -303,10 +303,12 @@ ext_srcdir = ${glibcpp_srcdir}/include/ext\n ext_builddir = ./ext\n ext_headers = \\\n \t${ext_srcdir}/algorithm \\\n+\t${ext_srcdir}/functional \\\n \t${ext_srcdir}/hash_map \\\n \t${ext_srcdir}/hash_set \\\n \t${ext_srcdir}/iterator \\\n \t${ext_srcdir}/memory \\\n+\t${ext_srcdir}/numeric \\\n \t${ext_srcdir}/rope \\\n \t${ext_srcdir}/ropeimpl.h \\\n \t${ext_srcdir}/slist \\"}, {"sha": "a3554a8f8d060e967dd0f99d39389c3e0d89afda", "filename": "libstdc++-v3/include/backward/algo.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01b0d4b85a401d257d9fe091e6647800b2ccbf00/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Falgo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01b0d4b85a401d257d9fe091e6647800b2ccbf00/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Falgo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Falgo.h?ref=01b0d4b85a401d257d9fe091e6647800b2ccbf00", "patch": "@@ -63,6 +63,7 @@\n #include <bits/stl_algo.h>\n #include <bits/stl_numeric.h>\n #include <ext/algorithm>\n+#include <ext/numeric>\n \n // Names from <stl_algo.h>\n using std::for_each; \n@@ -128,8 +129,6 @@ using std::accumulate;\n using std::inner_product; \n using std::partial_sum; \n using std::adjacent_difference; \n-using std::power; \n-using std::iota; \n \n // Names from ext/algorithm\n using __gnu_cxx::random_sample; \n@@ -139,6 +138,10 @@ using __gnu_cxx::is_heap;\n using __gnu_cxx::count;   // Extension returning void\n using __gnu_cxx::count_if;   // Extension returning void\n \n+// Names from ext/numeric\n+using __gnu_cxx::power; \n+using __gnu_cxx::iota; \n+\n #endif /* _CPP_BACKWARD_ALGO_H */\n \n // Local Variables:"}, {"sha": "bc96f49ffabd10d731791662de663d38e25dd568", "filename": "libstdc++-v3/include/backward/function.h", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01b0d4b85a401d257d9fe091e6647800b2ccbf00/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01b0d4b85a401d257d9fe091e6647800b2ccbf00/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Ffunction.h?ref=01b0d4b85a401d257d9fe091e6647800b2ccbf00", "patch": "@@ -60,6 +60,7 @@\n #include <bits/c++config.h>\n #include <stddef.h>\n #include <bits/stl_function.h>\n+#include <ext/functional>\n \n // Names from stl_function.h\n using std::unary_function; \n@@ -68,7 +69,6 @@ using std::plus;\n using std::minus; \n using std::multiplies; \n using std::divides; \n-using std::identity_element; \n using std::modulus; \n using std::negate; \n using std::equal_to; \n@@ -88,25 +88,9 @@ using std::binder1st;\n using std::binder2nd; \n using std::bind1st; \n using std::bind2nd; \n-using std::unary_compose; \n-using std::binary_compose; \n-using std::compose1; \n-using std::compose2; \n using std::pointer_to_unary_function; \n using std::pointer_to_binary_function; \n using std::ptr_fun; \n-using std::identity; \n-using std::select1st; \n-using std::select2nd; \n-using std::project1st; \n-using std::project2nd; \n-using std::constant_void_fun; \n-using std::constant_unary_fun; \n-using std::constant_binary_fun; \n-using std::constant0; \n-using std::constant1; \n-using std::constant2; \n-using std::subtractive_rng; \n using std::mem_fun_t; \n using std::const_mem_fun_t; \n using std::mem_fun_ref_t; \n@@ -117,8 +101,27 @@ using std::mem_fun1_ref_t;\n using std::const_mem_fun1_ref_t; \n using std::mem_fun; \n using std::mem_fun_ref; \n-using std::mem_fun1; \n-using std::mem_fun1_ref; \n+\n+// Names from ext/functional\n+using __gnu_cxx::identity_element; \n+using __gnu_cxx::unary_compose; \n+using __gnu_cxx::binary_compose; \n+using __gnu_cxx::compose1; \n+using __gnu_cxx::compose2; \n+using __gnu_cxx::identity; \n+using __gnu_cxx::select1st; \n+using __gnu_cxx::select2nd; \n+using __gnu_cxx::project1st; \n+using __gnu_cxx::project2nd; \n+using __gnu_cxx::constant_void_fun; \n+using __gnu_cxx::constant_unary_fun; \n+using __gnu_cxx::constant_binary_fun; \n+using __gnu_cxx::constant0; \n+using __gnu_cxx::constant1; \n+using __gnu_cxx::constant2; \n+using __gnu_cxx::subtractive_rng; \n+using __gnu_cxx::mem_fun1; \n+using __gnu_cxx::mem_fun1_ref; \n \n #endif /* _CPP_BACKWARD_FUNCTION_H */\n "}, {"sha": "a017189d4938c527a924928b59075c36f89dfcd7", "filename": "libstdc++-v3/include/bits/stl_function.h", "status": "modified", "additions": 1, "deletions": 316, "changes": 317, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01b0d4b85a401d257d9fe091e6647800b2ccbf00/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_function.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01b0d4b85a401d257d9fe091e6647800b2ccbf00/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_function.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_function.h?ref=01b0d4b85a401d257d9fe091e6647800b2ccbf00", "patch": "@@ -162,25 +162,6 @@ struct negate : public unary_function<_Tp,_Tp>\n };\n /** @}  */\n \n-/** The @c identity_element functions are not part of the C++ standard; SGI\n- *  provided them as an extension.  Its argument is an operation, and its\n- *  return value is the identity element for that operation.  It is overloaded\n- *  for addition and multiplication, and you can overload it for your own\n- *  nefarious operations.\n- *\n- *  @addtogroup SGIextensions\n- *  @{\n-*/\n-/// An \\link SGIextensions SGI extension \\endlink.\n-template <class _Tp> inline _Tp identity_element(plus<_Tp>) {\n-  return _Tp(0);\n-}\n-/// An \\link SGIextensions SGI extension \\endlink.\n-template <class _Tp> inline _Tp identity_element(multiplies<_Tp>) {\n-  return _Tp(1);\n-}\n-/** @}  */\n-\n // 20.3.3 comparisons\n /** @defgroup s20_3_3_comparisons Comparison Classes\n  *  The library provides six wrapper functors for all the basic comparisons\n@@ -433,88 +414,6 @@ bind2nd(const _Operation& __fn, const _Tp& __x)\n }\n /** @}  */\n \n-/** As an extension to the binders, SGI provided composition functors and\n- *  wrapper functions to aid in their creation.  The @c unary_compose\n- *  functor is constructed from two functions/functors, @c f and @c g.\n- *  Calling @c operator() with a single argument @c x returns @c f(g(x)).\n- *  The function @c compose1 takes the two functions and constructs a\n- *  @c unary_compose variable for you.\n- *  \n- *  @c binary_compose is constructed from three functors, @c f, @c g1,\n- *  and @c g2.  Its @c operator() returns @c f(g1(x),g2(x)).  The function\n- *  @compose2 takes f, g1, and g2, and constructs the @c binary_compose\n- *  instance for you.  For example, if @c f returns an int, then\n- *  \\code\n- *  int answer = (compose2(f,g1,g2))(x);\n- *  \\endcode\n- *  is equivalent to\n- *  \\code\n- *  int temp1 = g1(x);\n- *  int temp2 = g2(x);\n- *  int answer = f(temp1,temp2);\n- *  \\endcode\n- *  But the first form is more compact, and can be passed around as a\n- *  functor to other algorithms.\n- *\n- *  @addtogroup SGIextensions\n- *  @{\n-*/\n-/// An \\link SGIextensions SGI extension \\endlink.\n-template <class _Operation1, class _Operation2>\n-class unary_compose\n-  : public unary_function<typename _Operation2::argument_type,\n-                          typename _Operation1::result_type> \n-{\n-protected:\n-  _Operation1 _M_fn1;\n-  _Operation2 _M_fn2;\n-public:\n-  unary_compose(const _Operation1& __x, const _Operation2& __y) \n-    : _M_fn1(__x), _M_fn2(__y) {}\n-  typename _Operation1::result_type\n-  operator()(const typename _Operation2::argument_type& __x) const {\n-    return _M_fn1(_M_fn2(__x));\n-  }\n-};\n-\n-/// An \\link SGIextensions SGI extension \\endlink.\n-template <class _Operation1, class _Operation2>\n-inline unary_compose<_Operation1,_Operation2> \n-compose1(const _Operation1& __fn1, const _Operation2& __fn2)\n-{\n-  return unary_compose<_Operation1,_Operation2>(__fn1, __fn2);\n-}\n-\n-/// An \\link SGIextensions SGI extension \\endlink.\n-template <class _Operation1, class _Operation2, class _Operation3>\n-class binary_compose\n-  : public unary_function<typename _Operation2::argument_type,\n-                          typename _Operation1::result_type> {\n-protected:\n-  _Operation1 _M_fn1;\n-  _Operation2 _M_fn2;\n-  _Operation3 _M_fn3;\n-public:\n-  binary_compose(const _Operation1& __x, const _Operation2& __y, \n-                 const _Operation3& __z) \n-    : _M_fn1(__x), _M_fn2(__y), _M_fn3(__z) { }\n-  typename _Operation1::result_type\n-  operator()(const typename _Operation2::argument_type& __x) const {\n-    return _M_fn1(_M_fn2(__x), _M_fn3(__x));\n-  }\n-};\n-\n-/// An \\link SGIextensions SGI extension \\endlink.\n-template <class _Operation1, class _Operation2, class _Operation3>\n-inline binary_compose<_Operation1, _Operation2, _Operation3> \n-compose2(const _Operation1& __fn1, const _Operation2& __fn2, \n-         const _Operation3& __fn3)\n-{\n-  return binary_compose<_Operation1,_Operation2,_Operation3>\n-    (__fn1, __fn2, __fn3);\n-}\n-/** @}  */\n-\n // 20.3.7 adaptors pointers functions\n /** @defgroup s20_3_7_adaptors Adaptors for pointers to functions\n  *  The advantage of function objects over pointers to functions is that\n@@ -576,23 +475,12 @@ ptr_fun(_Result (*__x)(_Arg1, _Arg2)) {\n }\n /** @}  */\n \n-\n-// extension documented next\n template <class _Tp>\n struct _Identity : public unary_function<_Tp,_Tp> {\n   _Tp& operator()(_Tp& __x) const { return __x; }\n   const _Tp& operator()(const _Tp& __x) const { return __x; }\n };\n \n-/** As an extension, SGI provided a functor called @c identity.  When a\n- *  functor is required but no operations are desired, this can be used as a\n- *  pass-through.  Its @c operator() returns its argument unchanged.\n- *\n- *  @addtogroup SGIextensions\n-*/\n-template <class _Tp> struct identity : public _Identity<_Tp> {};\n-\n-// extension documented next\n template <class _Pair>\n struct _Select1st : public unary_function<_Pair, typename _Pair::first_type> {\n   typename _Pair::first_type& operator()(_Pair& __x) const {\n@@ -614,191 +502,6 @@ struct _Select2nd : public unary_function<_Pair, typename _Pair::second_type>\n   }\n };\n \n-/** @c select1st and @c select2nd are extensions provided by SGI.  Their\n- *  @c operator()s\n- *  take a @c std::pair as an argument, and return either the first member\n- *  or the second member, respectively.  They can be used (especially with\n- *  the composition functors) to \"strip\" data from a sequence before\n- *  performing the remainder of an algorithm.\n- *\n- *  @addtogroup SGIextensions\n- *  @{\n-*/\n-/// An \\link SGIextensions SGI extension \\endlink.\n-template <class _Pair> struct select1st : public _Select1st<_Pair> {};\n-/// An \\link SGIextensions SGI extension \\endlink.\n-template <class _Pair> struct select2nd : public _Select2nd<_Pair> {};\n-/** @}  */\n-\n-// extension documented next\n-template <class _Arg1, class _Arg2>\n-struct _Project1st : public binary_function<_Arg1, _Arg2, _Arg1> {\n-  _Arg1 operator()(const _Arg1& __x, const _Arg2&) const { return __x; }\n-};\n-\n-template <class _Arg1, class _Arg2>\n-struct _Project2nd : public binary_function<_Arg1, _Arg2, _Arg2> {\n-  _Arg2 operator()(const _Arg1&, const _Arg2& __y) const { return __y; }\n-};\n-\n-/** The @c operator() of the @c project1st functor takes two arbitrary\n- *  arguments and returns the first one, while @c project2nd returns the\n- *  second one.  They are extensions provided by SGI.\n- *\n- *  @addtogroup SGIextensions\n- *  @{\n-*/\n-/// An \\link SGIextensions SGI extension \\endlink.\n-template <class _Arg1, class _Arg2> \n-struct project1st : public _Project1st<_Arg1, _Arg2> {};\n-\n-/// An \\link SGIextensions SGI extension \\endlink.\n-template <class _Arg1, class _Arg2>\n-struct project2nd : public _Project2nd<_Arg1, _Arg2> {};\n-/** @}  */\n-\n-// extension documented next\n-template <class _Result>\n-struct _Constant_void_fun {\n-  typedef _Result result_type;\n-  result_type _M_val;\n-\n-  _Constant_void_fun(const result_type& __v) : _M_val(__v) {}\n-  const result_type& operator()() const { return _M_val; }\n-};  \n-\n-template <class _Result, class _Argument>\n-struct _Constant_unary_fun {\n-  typedef _Argument argument_type;\n-  typedef  _Result  result_type;\n-  result_type _M_val;\n-\n-  _Constant_unary_fun(const result_type& __v) : _M_val(__v) {}\n-  const result_type& operator()(const _Argument&) const { return _M_val; }\n-};\n-\n-template <class _Result, class _Arg1, class _Arg2>\n-struct _Constant_binary_fun {\n-  typedef  _Arg1   first_argument_type;\n-  typedef  _Arg2   second_argument_type;\n-  typedef  _Result result_type;\n-  _Result _M_val;\n-\n-  _Constant_binary_fun(const _Result& __v) : _M_val(__v) {}\n-  const result_type& operator()(const _Arg1&, const _Arg2&) const {\n-    return _M_val;\n-  }\n-};\n-\n-/** These three functors are each constructed from a single arbitrary\n- *  variable/value.  Later, their @c operator()s completely ignore any\n- *  arguments passed, and return the stored value.\n- *  - @c constant_void_fun's @c operator() takes no arguments\n- *  - @c constant_unary_fun's @c operator() takes one argument (ignored)\n- *  - @c constant_binary_fun's @c operator() takes two arguments (ignored)\n- *\n- *  The helper creator functions @c constant0, @c constant1, and\n- *  @c constant2 each take a \"result\" argument and construct variables of\n- *  the appropriate functor type.\n- *\n- *  @addtogroup SGIextensions\n- *  @{\n-*/\n-/// An \\link SGIextensions SGI extension \\endlink.\n-template <class _Result>\n-struct constant_void_fun : public _Constant_void_fun<_Result> {\n-  constant_void_fun(const _Result& __v) : _Constant_void_fun<_Result>(__v) {}\n-};  \n-\n-/// An \\link SGIextensions SGI extension \\endlink.\n-template <class _Result,\n-          class _Argument = _Result>\n-struct constant_unary_fun : public _Constant_unary_fun<_Result, _Argument>\n-{\n-  constant_unary_fun(const _Result& __v)\n-    : _Constant_unary_fun<_Result, _Argument>(__v) {}\n-};\n-\n-/// An \\link SGIextensions SGI extension \\endlink.\n-template <class _Result,\n-          class _Arg1 = _Result,\n-          class _Arg2 = _Arg1>\n-struct constant_binary_fun\n-  : public _Constant_binary_fun<_Result, _Arg1, _Arg2>\n-{\n-  constant_binary_fun(const _Result& __v)\n-    : _Constant_binary_fun<_Result, _Arg1, _Arg2>(__v) {}\n-};\n-\n-/// An \\link SGIextensions SGI extension \\endlink.\n-template <class _Result>\n-inline constant_void_fun<_Result> constant0(const _Result& __val)\n-{\n-  return constant_void_fun<_Result>(__val);\n-}\n-\n-/// An \\link SGIextensions SGI extension \\endlink.\n-template <class _Result>\n-inline constant_unary_fun<_Result,_Result> constant1(const _Result& __val)\n-{\n-  return constant_unary_fun<_Result,_Result>(__val);\n-}\n-\n-/// An \\link SGIextensions SGI extension \\endlink.\n-template <class _Result>\n-inline constant_binary_fun<_Result,_Result,_Result> \n-constant2(const _Result& __val)\n-{\n-  return constant_binary_fun<_Result,_Result,_Result>(__val);\n-}\n-/** @}  */\n-\n-/** The @c subtractive_rng class is documented on\n- *  <a href=\"http://www.sgi.com/tech/stl/\">SGI's site</a>.\n- *  Note that this code assumes that @c int is 32 bits.\n- *\n- *  @ingroup SGIextensions\n-*/\n-class subtractive_rng : public unary_function<unsigned int, unsigned int> {\n-private:\n-  unsigned int _M_table[55];\n-  size_t _M_index1;\n-  size_t _M_index2;\n-public:\n-  /// Returns a number less than the argument.\n-  unsigned int operator()(unsigned int __limit) {\n-    _M_index1 = (_M_index1 + 1) % 55;\n-    _M_index2 = (_M_index2 + 1) % 55;\n-    _M_table[_M_index1] = _M_table[_M_index1] - _M_table[_M_index2];\n-    return _M_table[_M_index1] % __limit;\n-  }\n-\n-  void _M_initialize(unsigned int __seed)\n-  {\n-    unsigned int __k = 1;\n-    _M_table[54] = __seed;\n-    size_t __i;\n-    for (__i = 0; __i < 54; __i++) {\n-        size_t __ii = (21 * (__i + 1) % 55) - 1;\n-        _M_table[__ii] = __k;\n-        __k = __seed - __k;\n-        __seed = _M_table[__ii];\n-    }\n-    for (int __loop = 0; __loop < 4; __loop++) {\n-        for (__i = 0; __i < 55; __i++)\n-            _M_table[__i] = _M_table[__i] - _M_table[(1 + __i + 30) % 55];\n-    }\n-    _M_index1 = 0;\n-    _M_index2 = 31;\n-  }\n-\n-  /// Ctor allowing you to initialize the seed.\n-  subtractive_rng(unsigned int __seed) { _M_initialize(__seed); }\n-  /// Default ctor; initializes its state with some number you don't see.\n-  subtractive_rng() { _M_initialize(161803398u); }\n-};\n-\n-\n // 20.3.8 adaptors pointers members\n /** @defgroup s20_3_8_memadaptors Adaptors for pointers to members\n  *  There are a total of 16 = 2^4 function objects in this family.\n@@ -989,9 +692,7 @@ class const_mem_fun1_ref_t<void, _Tp, _Arg>\n \n \n // Mem_fun adaptor helper functions.  There are only two:\n-//  mem_fun and mem_fun_ref.  (mem_fun1 and mem_fun1_ref \n-//  are provided for backward compatibility, but they are no longer\n-//  part of the C++ standard.)\n+// mem_fun and mem_fun_ref.\n \n template <class _Ret, class _Tp>\n inline mem_fun_t<_Ret,_Tp> mem_fun(_Ret (_Tp::*__f)())\n@@ -1026,22 +727,6 @@ inline const_mem_fun1_ref_t<_Ret,_Tp,_Arg>\n mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)\n   { return const_mem_fun1_ref_t<_Ret,_Tp,_Arg>(__f); }\n \n-template <class _Ret, class _Tp, class _Arg>\n-inline mem_fun1_t<_Ret,_Tp,_Arg> mem_fun1(_Ret (_Tp::*__f)(_Arg))\n-  { return mem_fun1_t<_Ret,_Tp,_Arg>(__f); }\n-\n-template <class _Ret, class _Tp, class _Arg>\n-inline const_mem_fun1_t<_Ret,_Tp,_Arg> mem_fun1(_Ret (_Tp::*__f)(_Arg) const)\n-  { return const_mem_fun1_t<_Ret,_Tp,_Arg>(__f); }\n-\n-template <class _Ret, class _Tp, class _Arg>\n-inline mem_fun1_ref_t<_Ret,_Tp,_Arg> mem_fun1_ref(_Ret (_Tp::*__f)(_Arg))\n-  { return mem_fun1_ref_t<_Ret,_Tp,_Arg>(__f); }\n-\n-template <class _Ret, class _Tp, class _Arg>\n-inline const_mem_fun1_ref_t<_Ret,_Tp,_Arg>\n-mem_fun1_ref(_Ret (_Tp::*__f)(_Arg) const)\n-  { return const_mem_fun1_ref_t<_Ret,_Tp,_Arg>(__f); }\n /** @}  */\n \n } // namespace std"}, {"sha": "23f2bcc4512c5e6c13a1385285b4027bdb095cbd", "filename": "libstdc++-v3/include/bits/stl_numeric.h", "status": "modified", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01b0d4b85a401d257d9fe091e6647800b2ccbf00/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_numeric.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01b0d4b85a401d257d9fe091e6647800b2ccbf00/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_numeric.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_numeric.h?ref=01b0d4b85a401d257d9fe091e6647800b2ccbf00", "patch": "@@ -206,67 +206,6 @@ namespace std\n       return ++__result;\n     }\n \n-  // Returns __x ** __n, where __n >= 0.  _Note that \"multiplication\"\n-  // is required to be associative, but not necessarily commutative.\n-\n-   \n-  template<typename _Tp, typename _Integer, typename _MonoidOperation>\n-    _Tp\n-    __power(_Tp __x, _Integer __n, _MonoidOperation __monoid_op)\n-    {\n-      if (__n == 0)\n-\treturn identity_element(__monoid_op);\n-      else {\n-\twhile ((__n & 1) == 0) {\n-\t  __n >>= 1;\n-\t  __x = __monoid_op(__x, __x);\n-\t}\n-\n-\t_Tp __result = __x;\n-\t__n >>= 1;\n-\twhile (__n != 0) {\n-\t  __x = __monoid_op(__x, __x);\n-\t  if ((__n & 1) != 0)\n-\t    __result = __monoid_op(__result, __x);\n-\t  __n >>= 1;\n-\t}\n-\treturn __result;\n-      }\n-    }\n-\n-  template<typename _Tp, typename _Integer>\n-    inline _Tp\n-    __power(_Tp __x, _Integer __n)\n-    { return __power(__x, __n, multiplies<_Tp>()); }\n-\n-  // Alias for the internal name __power.  Note that power is an extension,\n-  // not part of the C++ standard.\n-\n-  template<typename _Tp, typename _Integer, typename _MonoidOperation>\n-    inline _Tp\n-    power(_Tp __x, _Integer __n, _MonoidOperation __monoid_op)\n-    { return __power(__x, __n, __monoid_op); }\n-\n-  template<typename _Tp, typename _Integer>\n-    inline _Tp\n-    power(_Tp __x, _Integer __n)\n-    { return __power(__x, __n); }\n-\n-  // iota is not part of the C++ standard.  It is an extension.\n-\n-  template<typename _ForwardIter, typename _Tp>\n-    void \n-    iota(_ForwardIter __first, _ForwardIter __last, _Tp __value)\n-    {\n-      // concept requirements\n-      __glibcpp_function_requires(_Mutable_ForwardIteratorConcept<_ForwardIter>)\n-      __glibcpp_function_requires(_ConvertibleConcept<_Tp,\n-\t    typename iterator_traits<_ForwardIter>::value_type>)\n-\n-      while (__first != __last)\n-\t*__first++ = __value++;\n-    }\n-\n } // namespace std\n \n #endif /* _CPP_BITS_STL_NUMERIC_H */"}, {"sha": "8a17161555353ee5ce50fd7b53228d9ec8508b97", "filename": "libstdc++-v3/include/ext/functional", "status": "added", "additions": 389, "deletions": 0, "changes": 389, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01b0d4b85a401d257d9fe091e6647800b2ccbf00/libstdc%2B%2B-v3%2Finclude%2Fext%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01b0d4b85a401d257d9fe091e6647800b2ccbf00/libstdc%2B%2B-v3%2Finclude%2Fext%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Ffunctional?ref=01b0d4b85a401d257d9fe091e6647800b2ccbf00", "patch": "@@ -0,0 +1,389 @@\n+// Functional extensions -*- C++ -*-\n+\n+// Copyright (C) 2002 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1996\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef _EXT_FUNCTIONAL\n+#define _EXT_FUNCTIONAL\n+\n+#pragma GCC system_header\n+#include <bits/std_functional.h>\n+\n+namespace __gnu_cxx\n+{\n+using std::unary_function;\n+using std::binary_function;\n+using std::mem_fun1_t;\n+using std::const_mem_fun1_t;\n+using std::mem_fun1_ref_t;\n+using std::const_mem_fun1_ref_t;\n+\n+/** The @c identity_element functions are not part of the C++ standard; SGI\n+ *  provided them as an extension.  Its argument is an operation, and its\n+ *  return value is the identity element for that operation.  It is overloaded\n+ *  for addition and multiplication, and you can overload it for your own\n+ *  nefarious operations.\n+ *\n+ *  @addtogroup SGIextensions\n+ *  @{\n+*/\n+/// An \\link SGIextensions SGI extension \\endlink.\n+template <class _Tp> inline _Tp identity_element(std::plus<_Tp>) {\n+  return _Tp(0);\n+}\n+/// An \\link SGIextensions SGI extension \\endlink.\n+template <class _Tp> inline _Tp identity_element(std::multiplies<_Tp>) {\n+  return _Tp(1);\n+}\n+/** @}  */\n+\n+/** As an extension to the binders, SGI provided composition functors and\n+ *  wrapper functions to aid in their creation.  The @c unary_compose\n+ *  functor is constructed from two functions/functors, @c f and @c g.\n+ *  Calling @c operator() with a single argument @c x returns @c f(g(x)).\n+ *  The function @c compose1 takes the two functions and constructs a\n+ *  @c unary_compose variable for you.\n+ *  \n+ *  @c binary_compose is constructed from three functors, @c f, @c g1,\n+ *  and @c g2.  Its @c operator() returns @c f(g1(x),g2(x)).  The function\n+ *  @compose2 takes f, g1, and g2, and constructs the @c binary_compose\n+ *  instance for you.  For example, if @c f returns an int, then\n+ *  \\code\n+ *  int answer = (compose2(f,g1,g2))(x);\n+ *  \\endcode\n+ *  is equivalent to\n+ *  \\code\n+ *  int temp1 = g1(x);\n+ *  int temp2 = g2(x);\n+ *  int answer = f(temp1,temp2);\n+ *  \\endcode\n+ *  But the first form is more compact, and can be passed around as a\n+ *  functor to other algorithms.\n+ *\n+ *  @addtogroup SGIextensions\n+ *  @{\n+*/\n+/// An \\link SGIextensions SGI extension \\endlink.\n+template <class _Operation1, class _Operation2>\n+class unary_compose\n+  : public unary_function<typename _Operation2::argument_type,\n+\t\t       typename _Operation1::result_type> \n+{\n+protected:\n+  _Operation1 _M_fn1;\n+  _Operation2 _M_fn2;\n+public:\n+  unary_compose(const _Operation1& __x, const _Operation2& __y) \n+    : _M_fn1(__x), _M_fn2(__y) {}\n+  typename _Operation1::result_type\n+  operator()(const typename _Operation2::argument_type& __x) const {\n+    return _M_fn1(_M_fn2(__x));\n+  }\n+};\n+\n+/// An \\link SGIextensions SGI extension \\endlink.\n+template <class _Operation1, class _Operation2>\n+inline unary_compose<_Operation1,_Operation2> \n+compose1(const _Operation1& __fn1, const _Operation2& __fn2)\n+{\n+  return unary_compose<_Operation1,_Operation2>(__fn1, __fn2);\n+}\n+\n+/// An \\link SGIextensions SGI extension \\endlink.\n+template <class _Operation1, class _Operation2, class _Operation3>\n+class binary_compose\n+  : public unary_function<typename _Operation2::argument_type,\n+                          typename _Operation1::result_type> {\n+protected:\n+  _Operation1 _M_fn1;\n+  _Operation2 _M_fn2;\n+  _Operation3 _M_fn3;\n+public:\n+  binary_compose(const _Operation1& __x, const _Operation2& __y, \n+                 const _Operation3& __z) \n+    : _M_fn1(__x), _M_fn2(__y), _M_fn3(__z) { }\n+  typename _Operation1::result_type\n+  operator()(const typename _Operation2::argument_type& __x) const {\n+    return _M_fn1(_M_fn2(__x), _M_fn3(__x));\n+  }\n+};\n+\n+/// An \\link SGIextensions SGI extension \\endlink.\n+template <class _Operation1, class _Operation2, class _Operation3>\n+inline binary_compose<_Operation1, _Operation2, _Operation3> \n+compose2(const _Operation1& __fn1, const _Operation2& __fn2, \n+         const _Operation3& __fn3)\n+{\n+  return binary_compose<_Operation1,_Operation2,_Operation3>\n+    (__fn1, __fn2, __fn3);\n+}\n+/** @}  */\n+\n+/** As an extension, SGI provided a functor called @c identity.  When a\n+ *  functor is required but no operations are desired, this can be used as a\n+ *  pass-through.  Its @c operator() returns its argument unchanged.\n+ *\n+ *  @addtogroup SGIextensions\n+*/\n+template <class _Tp> struct identity : public std::_Identity<_Tp> {};\n+\n+/** @c select1st and @c select2nd are extensions provided by SGI.  Their\n+ *  @c operator()s\n+ *  take a @c std::pair as an argument, and return either the first member\n+ *  or the second member, respectively.  They can be used (especially with\n+ *  the composition functors) to \"strip\" data from a sequence before\n+ *  performing the remainder of an algorithm.\n+ *\n+ *  @addtogroup SGIextensions\n+ *  @{\n+*/\n+/// An \\link SGIextensions SGI extension \\endlink.\n+template <class _Pair> struct select1st : public std::_Select1st<_Pair> {};\n+/// An \\link SGIextensions SGI extension \\endlink.\n+template <class _Pair> struct select2nd : public std::_Select2nd<_Pair> {};\n+/** @}  */\n+\n+// extension documented next\n+template <class _Arg1, class _Arg2>\n+struct _Project1st : public binary_function<_Arg1, _Arg2, _Arg1> {\n+  _Arg1 operator()(const _Arg1& __x, const _Arg2&) const { return __x; }\n+};\n+\n+template <class _Arg1, class _Arg2>\n+struct _Project2nd : public binary_function<_Arg1, _Arg2, _Arg2> {\n+  _Arg2 operator()(const _Arg1&, const _Arg2& __y) const { return __y; }\n+};\n+\n+/** The @c operator() of the @c project1st functor takes two arbitrary\n+ *  arguments and returns the first one, while @c project2nd returns the\n+ *  second one.  They are extensions provided by SGI.\n+ *\n+ *  @addtogroup SGIextensions\n+ *  @{\n+*/\n+\n+/// An \\link SGIextensions SGI extension \\endlink.\n+template <class _Arg1, class _Arg2> \n+struct project1st : public _Project1st<_Arg1, _Arg2> {};\n+\n+/// An \\link SGIextensions SGI extension \\endlink.\n+template <class _Arg1, class _Arg2>\n+struct project2nd : public _Project2nd<_Arg1, _Arg2> {};\n+/** @}  */\n+\n+// extension documented next\n+template <class _Result>\n+struct _Constant_void_fun {\n+  typedef _Result result_type;\n+  result_type _M_val;\n+\n+  _Constant_void_fun(const result_type& __v) : _M_val(__v) {}\n+  const result_type& operator()() const { return _M_val; }\n+};  \n+\n+template <class _Result, class _Argument>\n+struct _Constant_unary_fun {\n+  typedef _Argument argument_type;\n+  typedef  _Result  result_type;\n+  result_type _M_val;\n+\n+  _Constant_unary_fun(const result_type& __v) : _M_val(__v) {}\n+  const result_type& operator()(const _Argument&) const { return _M_val; }\n+};\n+\n+template <class _Result, class _Arg1, class _Arg2>\n+struct _Constant_binary_fun {\n+  typedef  _Arg1   first_argument_type;\n+  typedef  _Arg2   second_argument_type;\n+  typedef  _Result result_type;\n+  _Result _M_val;\n+\n+  _Constant_binary_fun(const _Result& __v) : _M_val(__v) {}\n+  const result_type& operator()(const _Arg1&, const _Arg2&) const {\n+    return _M_val;\n+  }\n+};\n+\n+/** These three functors are each constructed from a single arbitrary\n+ *  variable/value.  Later, their @c operator()s completely ignore any\n+ *  arguments passed, and return the stored value.\n+ *  - @c constant_void_fun's @c operator() takes no arguments\n+ *  - @c constant_unary_fun's @c operator() takes one argument (ignored)\n+ *  - @c constant_binary_fun's @c operator() takes two arguments (ignored)\n+ *\n+ *  The helper creator functions @c constant0, @c constant1, and\n+ *  @c constant2 each take a \"result\" argument and construct variables of\n+ *  the appropriate functor type.\n+ *\n+ *  @addtogroup SGIextensions\n+ *  @{\n+*/\n+/// An \\link SGIextensions SGI extension \\endlink.\n+template <class _Result>\n+struct constant_void_fun : public _Constant_void_fun<_Result> {\n+  constant_void_fun(const _Result& __v) : _Constant_void_fun<_Result>(__v) {}\n+};  \n+\n+/// An \\link SGIextensions SGI extension \\endlink.\n+template <class _Result,\n+          class _Argument = _Result>\n+struct constant_unary_fun : public _Constant_unary_fun<_Result, _Argument>\n+{\n+  constant_unary_fun(const _Result& __v)\n+    : _Constant_unary_fun<_Result, _Argument>(__v) {}\n+};\n+\n+/// An \\link SGIextensions SGI extension \\endlink.\n+template <class _Result,\n+          class _Arg1 = _Result,\n+          class _Arg2 = _Arg1>\n+struct constant_binary_fun\n+  : public _Constant_binary_fun<_Result, _Arg1, _Arg2>\n+{\n+  constant_binary_fun(const _Result& __v)\n+    : _Constant_binary_fun<_Result, _Arg1, _Arg2>(__v) {}\n+};\n+\n+/// An \\link SGIextensions SGI extension \\endlink.\n+template <class _Result>\n+inline constant_void_fun<_Result> constant0(const _Result& __val)\n+{\n+  return constant_void_fun<_Result>(__val);\n+}\n+\n+/// An \\link SGIextensions SGI extension \\endlink.\n+template <class _Result>\n+inline constant_unary_fun<_Result,_Result> constant1(const _Result& __val)\n+{\n+  return constant_unary_fun<_Result,_Result>(__val);\n+}\n+\n+/// An \\link SGIextensions SGI extension \\endlink.\n+template <class _Result>\n+inline constant_binary_fun<_Result,_Result,_Result> \n+constant2(const _Result& __val)\n+{\n+  return constant_binary_fun<_Result,_Result,_Result>(__val);\n+}\n+/** @}  */\n+\n+/** The @c subtractive_rng class is documented on\n+ *  <a href=\"http://www.sgi.com/tech/stl/\">SGI's site</a>.\n+ *  Note that this code assumes that @c int is 32 bits.\n+ *\n+ *  @ingroup SGIextensions\n+*/\n+class subtractive_rng : public unary_function<unsigned int, unsigned int> {\n+private:\n+  unsigned int _M_table[55];\n+  size_t _M_index1;\n+  size_t _M_index2;\n+public:\n+  /// Returns a number less than the argument.\n+  unsigned int operator()(unsigned int __limit) {\n+    _M_index1 = (_M_index1 + 1) % 55;\n+    _M_index2 = (_M_index2 + 1) % 55;\n+    _M_table[_M_index1] = _M_table[_M_index1] - _M_table[_M_index2];\n+    return _M_table[_M_index1] % __limit;\n+  }\n+\n+  void _M_initialize(unsigned int __seed)\n+  {\n+    unsigned int __k = 1;\n+    _M_table[54] = __seed;\n+    size_t __i;\n+    for (__i = 0; __i < 54; __i++) {\n+        size_t __ii = (21 * (__i + 1) % 55) - 1;\n+        _M_table[__ii] = __k;\n+        __k = __seed - __k;\n+        __seed = _M_table[__ii];\n+    }\n+    for (int __loop = 0; __loop < 4; __loop++) {\n+        for (__i = 0; __i < 55; __i++)\n+            _M_table[__i] = _M_table[__i] - _M_table[(1 + __i + 30) % 55];\n+    }\n+    _M_index1 = 0;\n+    _M_index2 = 31;\n+  }\n+\n+  /// Ctor allowing you to initialize the seed.\n+  subtractive_rng(unsigned int __seed) { _M_initialize(__seed); }\n+  /// Default ctor; initializes its state with some number you don't see.\n+  subtractive_rng() { _M_initialize(161803398u); }\n+};\n+\n+// Mem_fun adaptor helper functions mem_fun1 and mem_fun1_ref, \n+// provided for backward compatibility, they are no longer part of\n+// the C++ standard.\n+\n+template <class _Ret, class _Tp, class _Arg>\n+inline mem_fun1_t<_Ret,_Tp,_Arg> mem_fun1(_Ret (_Tp::*__f)(_Arg))\n+  { return mem_fun1_t<_Ret,_Tp,_Arg>(__f); }\n+\n+template <class _Ret, class _Tp, class _Arg>\n+inline const_mem_fun1_t<_Ret,_Tp,_Arg> mem_fun1(_Ret (_Tp::*__f)(_Arg) const)\n+  { return const_mem_fun1_t<_Ret,_Tp,_Arg>(__f); }\n+\n+template <class _Ret, class _Tp, class _Arg>\n+inline mem_fun1_ref_t<_Ret,_Tp,_Arg> mem_fun1_ref(_Ret (_Tp::*__f)(_Arg))\n+  { return mem_fun1_ref_t<_Ret,_Tp,_Arg>(__f); }\n+\n+template <class _Ret, class _Tp, class _Arg>\n+inline const_mem_fun1_ref_t<_Ret,_Tp,_Arg>\n+mem_fun1_ref(_Ret (_Tp::*__f)(_Arg) const)\n+  { return const_mem_fun1_ref_t<_Ret,_Tp,_Arg>(__f); }\n+\n+} // namespace __gnu_cxx\n+\n+#endif /* _EXT_FUNCTIONAL */\n+"}, {"sha": "93364678d48496d3525c7abfe43fff874fa36d05", "filename": "libstdc++-v3/include/ext/numeric", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01b0d4b85a401d257d9fe091e6647800b2ccbf00/libstdc%2B%2B-v3%2Finclude%2Fext%2Fnumeric", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01b0d4b85a401d257d9fe091e6647800b2ccbf00/libstdc%2B%2B-v3%2Finclude%2Fext%2Fnumeric", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fnumeric?ref=01b0d4b85a401d257d9fe091e6647800b2ccbf00", "patch": "@@ -0,0 +1,130 @@\n+// Numeric extensions -*- C++ -*-\n+\n+// Copyright (C) 2002 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1996\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef _EXT_NUMERIC\n+#define _EXT_NUMERIC\n+\n+#pragma GCC system_header\n+#include <bits/concept_check.h>\n+#include <bits/std_numeric.h>\n+\n+#include <ext/functional> // For identity_element\n+\n+namespace __gnu_cxx\n+{\n+  // Returns __x ** __n, where __n >= 0.  _Note that \"multiplication\"\n+  // is required to be associative, but not necessarily commutative.\n+   \n+  template<typename _Tp, typename _Integer, typename _MonoidOperation>\n+    _Tp\n+    __power(_Tp __x, _Integer __n, _MonoidOperation __monoid_op)\n+    {\n+      if (__n == 0)\n+\treturn identity_element(__monoid_op);\n+      else {\n+\twhile ((__n & 1) == 0) {\n+\t  __n >>= 1;\n+\t  __x = __monoid_op(__x, __x);\n+\t}\n+\n+\t_Tp __result = __x;\n+\t__n >>= 1;\n+\twhile (__n != 0) {\n+\t  __x = __monoid_op(__x, __x);\n+\t  if ((__n & 1) != 0)\n+\t    __result = __monoid_op(__result, __x);\n+\t  __n >>= 1;\n+\t}\n+\treturn __result;\n+      }\n+    }\n+\n+  template<typename _Tp, typename _Integer>\n+    inline _Tp\n+    __power(_Tp __x, _Integer __n)\n+    { return __power(__x, __n, std::multiplies<_Tp>()); }\n+\n+  // Alias for the internal name __power.  Note that power is an extension,\n+  // not part of the C++ standard.\n+\n+  template<typename _Tp, typename _Integer, typename _MonoidOperation>\n+    inline _Tp\n+    power(_Tp __x, _Integer __n, _MonoidOperation __monoid_op)\n+    { return __power(__x, __n, __monoid_op); }\n+\n+  template<typename _Tp, typename _Integer>\n+    inline _Tp\n+    power(_Tp __x, _Integer __n)\n+    { return __power(__x, __n); }\n+\n+  // iota is not part of the C++ standard.  It is an extension.\n+\n+  template<typename _ForwardIter, typename _Tp>\n+    void \n+    iota(_ForwardIter __first, _ForwardIter __last, _Tp __value)\n+    {\n+      // concept requirements\n+      __glibcpp_function_requires(_Mutable_ForwardIteratorConcept<_ForwardIter>)\n+      __glibcpp_function_requires(_ConvertibleConcept<_Tp,\n+\t    typename std::iterator_traits<_ForwardIter>::value_type>)\n+\n+      while (__first != __last)\n+\t*__first++ = __value++;\n+    }\n+\n+} // namespace __gnu_cxx\n+\n+#endif /* _EXT_NUMERIC */\n+"}, {"sha": "b3e694cf15a0c7a608c3b31bf7ee651d44242d41", "filename": "libstdc++-v3/include/ext/ropeimpl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01b0d4b85a401d257d9fe091e6647800b2ccbf00/libstdc%2B%2B-v3%2Finclude%2Fext%2Fropeimpl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01b0d4b85a401d257d9fe091e6647800b2ccbf00/libstdc%2B%2B-v3%2Finclude%2Fext%2Fropeimpl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fropeimpl.h?ref=01b0d4b85a401d257d9fe091e6647800b2ccbf00", "patch": "@@ -51,6 +51,7 @@\n \n #include <ext/algorithm> // For copy_n and lexicographical_compare_3way\n #include <ext/memory> // For uninitialized_copy_n\n+#include <ext/numeric> // For power\n \n namespace __gnu_cxx\n {"}, {"sha": "f63b4ab11f6789b8000f57a76db417af60d50655", "filename": "libstdc++-v3/testsuite/ext/headers.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01b0d4b85a401d257d9fe091e6647800b2ccbf00/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fheaders.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01b0d4b85a401d257d9fe091e6647800b2ccbf00/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fheaders.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fheaders.cc?ref=01b0d4b85a401d257d9fe091e6647800b2ccbf00", "patch": "@@ -24,10 +24,12 @@\n // subdirectory that are meant to be directly included.\n \n #include <ext/algorithm>\n+#include <ext/functional>\n #include <ext/hash_map>\n #include <ext/hash_set>\n #include <ext/iterator>\n #include <ext/memory>\n+#include <ext/numeric>\n #include <ext/rope>\n #include <ext/slist>\n "}]}