{"sha": "cceb575c43dd2f2eebd51c31aefeecfac6529675", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2NlYjU3NWM0M2RkMmYyZWViZDUxYzMxYWVmZWVjZmFjNjUyOTY3NQ==", "commit": {"author": {"name": "Anthony Green", "email": "green@moxielogic.com", "date": "2009-06-10T05:23:39Z"}, "committer": {"name": "Anthony Green", "email": "green@gcc.gnu.org", "date": "2009-06-10T05:23:39Z"}, "message": "Commit moxie port.\n\nFrom-SVN: r148339", "tree": {"sha": "817deda1611364058ed97a5e53175eb97a859752", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/817deda1611364058ed97a5e53175eb97a859752"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cceb575c43dd2f2eebd51c31aefeecfac6529675", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cceb575c43dd2f2eebd51c31aefeecfac6529675", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cceb575c43dd2f2eebd51c31aefeecfac6529675", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cceb575c43dd2f2eebd51c31aefeecfac6529675/comments", "author": {"login": "atgreen", "id": 89993, "node_id": "MDQ6VXNlcjg5OTkz", "avatar_url": "https://avatars.githubusercontent.com/u/89993?v=4", "gravatar_id": "", "url": "https://api.github.com/users/atgreen", "html_url": "https://github.com/atgreen", "followers_url": "https://api.github.com/users/atgreen/followers", "following_url": "https://api.github.com/users/atgreen/following{/other_user}", "gists_url": "https://api.github.com/users/atgreen/gists{/gist_id}", "starred_url": "https://api.github.com/users/atgreen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/atgreen/subscriptions", "organizations_url": "https://api.github.com/users/atgreen/orgs", "repos_url": "https://api.github.com/users/atgreen/repos", "events_url": "https://api.github.com/users/atgreen/events{/privacy}", "received_events_url": "https://api.github.com/users/atgreen/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fd9380a6cd5157954fa95ffd8ba9924fea42b744", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd9380a6cd5157954fa95ffd8ba9924fea42b744", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd9380a6cd5157954fa95ffd8ba9924fea42b744"}], "stats": {"total": 1838, "additions": 1837, "deletions": 1}, "files": [{"sha": "9860e31300011c54032ce9f80ce436926061ea9f", "filename": "MAINTAINERS", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cceb575c43dd2f2eebd51c31aefeecfac6529675/MAINTAINERS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cceb575c43dd2f2eebd51c31aefeecfac6529675/MAINTAINERS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/MAINTAINERS?ref=cceb575c43dd2f2eebd51c31aefeecfac6529675", "patch": "@@ -74,6 +74,7 @@ mips port\t\tRichard Sandiford\trdsandiford@googlemail.com\n mmix port\t\tHans-Peter Nilsson\thp@bitrange.com\n mn10300 port\t\tJeff Law\t\tlaw@redhat.com\n mn10300 port\t\tAlexandre Oliva\t\taoliva@redhat.com\n+moxie port\t\tAnthony Green\t\tgreen@moxielogic.com\n pdp11 port\t\tPaul Koning\t\tni1d@arrl.net\n picochip port\t\tHariharan Sandanagobalane\thariharan@picochip.com\n picochip port\t\tDaniel Towner\t\tdant@picochip.com"}, {"sha": "adc88567464ed9c1ec6aafb6f5958ea5fd5b254d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cceb575c43dd2f2eebd51c31aefeecfac6529675/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cceb575c43dd2f2eebd51c31aefeecfac6529675/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cceb575c43dd2f2eebd51c31aefeecfac6529675", "patch": "@@ -1,3 +1,20 @@\n+2009-06-10  Anthony Green  <green@moxielogic.com>\n+\n+\t* config/moxie/crti.asm: New file.\n+\t* config/moxie/crtn.asm: New file.\n+\t* config/moxie/moxie.c: New file.\n+\t* config/moxie/moxie.h: New file.\n+\t* config/moxie/sfp-machine.h: New file.\n+\t* config/moxie/moxie-protos.h: New file.\n+\t* config/moxie/t-moxie: Created.\n+\t* config/moxie/t-moxie-softfp: Created.\n+\t* config/moxie/moxie.md: Created.\n+\t* config/moxie/constraints.md: Created.\n+\t* config.gcc: Add moxie support.\n+\t* doc/md.texi (Machine Constraints): Add moxie constraints.\n+\t* doc/contrib.texi (Contributors): Mention moxie port.\n+\t* doc/install.texi (Specific): Mention the moxie port.\n+\n 2009-06-09  Ian Lance Taylor  <iant@google.com>\n \n \t* system.h (HAVE_DESIGNATED_INITIALIZERS): Don't define if"}, {"sha": "ceb911abf636d17bcd5ac4c1b7398811bf9044c3", "filename": "gcc/config.gcc", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cceb575c43dd2f2eebd51c31aefeecfac6529675/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cceb575c43dd2f2eebd51c31aefeecfac6529675/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=cceb575c43dd2f2eebd51c31aefeecfac6529675", "patch": "@@ -274,6 +274,8 @@ crisv32-*)\n \t;;\n frv*)\tcpu_type=frv\n \t;;\n+moxie*)\tcpu_type=moxie\n+\t;;\n fido-*-*)\n \tcpu_type=m68k\n \textra_headers=math-68881.h\n@@ -881,6 +883,13 @@ frv-*-*linux*)\n \t         linux.h glibc-stdint.h frv/linux.h frv/frv-abi.h\"\n \ttmake_file=\"${tmake_file} frv/t-frv frv/t-linux\"\n \t;;\n+moxie-*-elf)\n+\tgas=yes\n+\tgnu_ld=yes\n+\ttm_file=\"dbxelf.h elfos.h svr4.h ${tm_file}\"\n+\textra_parts=\"crti.o crtn.o crtbegin.o crtend.o\"\n+\ttmake_file=\"${tmake_file} moxie/t-moxie moxie/t-moxie-softfp soft-fp/t-softfp\"\n+\t;;\n h8300-*-rtems*)\n \ttmake_file=\"h8300/t-h8300 h8300/t-elf t-rtems h8300/t-rtems\"\n \ttm_file=\"h8300/h8300.h dbxelf.h elfos.h h8300/elf.h h8300/rtems.h rtems.h newlib-stdint.h\""}, {"sha": "038be5d4c6e79464c7fceee92021d9806a4be41d", "filename": "gcc/config/moxie/constraints.md", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cceb575c43dd2f2eebd51c31aefeecfac6529675/gcc%2Fconfig%2Fmoxie%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cceb575c43dd2f2eebd51c31aefeecfac6529675/gcc%2Fconfig%2Fmoxie%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmoxie%2Fconstraints.md?ref=cceb575c43dd2f2eebd51c31aefeecfac6529675", "patch": "@@ -0,0 +1,52 @@\n+;; Constraint definitions for Moxie\n+;; Copyright (C) 2009 Free Software Foundation, Inc.\n+;; Contributed by Anthony Green <green@moxielogic.com>\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 3, or (at your\n+;; option) any later version.\n+\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+;; -------------------------------------------------------------------------\n+;; Constraints\n+;; -------------------------------------------------------------------------\n+\n+(define_constraint \"A\"\n+  \"An absolute address.\"\n+  (and (match_code \"mem\")\n+       (ior (match_test \"GET_CODE (XEXP (op, 0)) == SYMBOL_REF\")\n+\t    (match_test \"GET_CODE (XEXP (op, 0)) == LABEL_REF\")\n+\t    (match_test \"GET_CODE (XEXP (op, 0)) == CONST\"))))\n+\n+(define_constraint \"B\"\n+  \"An offset address.\"\n+  (and (match_code \"mem\")\n+       (match_test \"GET_CODE (XEXP (op, 0)) == PLUS\")))\n+\n+(define_constraint \"W\"\n+  \"A register indirect memory operand.\"\n+  (and (match_code \"mem\")\n+       (match_test \"REG_P (XEXP (op, 0))\n+\t\t    && REGNO_OK_FOR_BASE_P (REGNO (XEXP (op, 0)))\")))\n+\n+(define_constraint \"I\"\n+  \"An 8-bit constant (0..255)\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= 0 && ival <= 255\")))\n+\n+(define_constraint \"N\"\n+  \"A constant -(0..255)\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= -255 && ival <= 0\")))\n+"}, {"sha": "f44582799a3421df1e072a00896ae7469f1f2ef1", "filename": "gcc/config/moxie/crti.asm", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cceb575c43dd2f2eebd51c31aefeecfac6529675/gcc%2Fconfig%2Fmoxie%2Fcrti.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cceb575c43dd2f2eebd51c31aefeecfac6529675/gcc%2Fconfig%2Fmoxie%2Fcrti.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmoxie%2Fcrti.asm?ref=cceb575c43dd2f2eebd51c31aefeecfac6529675", "patch": "@@ -0,0 +1,40 @@\n+# crti.asm for moxie\n+#\n+#   Copyright (C) 2009 Free Software Foundation\n+# \n+# This file is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published by the\n+# Free Software Foundation; either version 3, or (at your option) any\n+# later version.\n+# \n+# This file is distributed in the hope that it will be useful, but\n+# WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+# General Public License for more details.\n+# \n+# Under Section 7 of GPL version 3, you are granted additional\n+# permissions described in the GCC Runtime Library Exception, version\n+# 3.1, as published by the Free Software Foundation.\n+#\n+# You should have received a copy of the GNU General Public License and\n+# a copy of the GCC Runtime Library Exception along with this program;\n+# see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+# <http://www.gnu.org/licenses/>.\n+\n+# This file just make a stack frame for the contents of the .fini and\n+# .init sections.  Users may put any desired instructions in those\n+# sections.\n+\n+\t.file\t\t\"crti.asm\"\n+\n+\t.section\t\".init\"\n+\t.global\t_init\n+\t.type\t_init, @function\t\n+\t.p2align\t1\n+_init:\n+\n+\t.section\t\".fini\"\n+\t.global\t_fini\n+\t.type\t_fini,@function\n+\t.p2align\t1\n+_fini:"}, {"sha": "3ac9d31eed88514f8d0974e7eb7139f05b002eb3", "filename": "gcc/config/moxie/crtn.asm", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cceb575c43dd2f2eebd51c31aefeecfac6529675/gcc%2Fconfig%2Fmoxie%2Fcrtn.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cceb575c43dd2f2eebd51c31aefeecfac6529675/gcc%2Fconfig%2Fmoxie%2Fcrtn.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmoxie%2Fcrtn.asm?ref=cceb575c43dd2f2eebd51c31aefeecfac6529675", "patch": "@@ -0,0 +1,34 @@\n+# crtn.asm for moxie\n+# \n+#   Copyright (C) 2009 Free Software Foundation\n+# \n+# This file is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published by the\n+# Free Software Foundation; either version 3, or (at your option) any\n+# later version.\n+# \n+# This file is distributed in the hope that it will be useful, but\n+# WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+# General Public License for more details.\n+# \n+# Under Section 7 of GPL version 3, you are granted additional\n+# permissions described in the GCC Runtime Library Exception, version\n+# 3.1, as published by the Free Software Foundation.\n+#\n+# You should have received a copy of the GNU General Public License and\n+# a copy of the GCC Runtime Library Exception along with this program;\n+# see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+# <http://www.gnu.org/licenses/>.\n+\n+# This file just makes sure that the .fini and .init sections do in\n+# fact return.  Users may put any desired instructions in those sections.\n+# This file is the last thing linked into any executable.\n+\n+\t.file\t\t\"crtn.asm\"\n+\n+\t.section\t\".init\"\n+\tret\n+\t\n+\t.section\t\".fini\"\n+\tret"}, {"sha": "d475aac6a6968ffd2af4a76f8733183e341f3426", "filename": "gcc/config/moxie/moxie-protos.h", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cceb575c43dd2f2eebd51c31aefeecfac6529675/gcc%2Fconfig%2Fmoxie%2Fmoxie-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cceb575c43dd2f2eebd51c31aefeecfac6529675/gcc%2Fconfig%2Fmoxie%2Fmoxie-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmoxie%2Fmoxie-protos.h?ref=cceb575c43dd2f2eebd51c31aefeecfac6529675", "patch": "@@ -0,0 +1,28 @@\n+/* Prototypes for moxie.c functions used in the md file & elsewhere.\n+   Copyright (C) 2009 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+extern void  moxie_expand_prologue (void);\n+extern void  moxie_expand_epilogue (void);\n+extern int   moxie_initial_elimination_offset (int, int);\n+extern rtx   moxie_function_value (tree, tree, bool ATTRIBUTE_UNUSED);\n+extern void  moxie_print_operand (FILE *, rtx, int);\n+extern void  moxie_print_operand_address (FILE *, rtx);\n+#ifdef RTX_CODE\n+extern rtx   moxie_function_arg (CUMULATIVE_ARGS, enum machine_mode, tree, int);\n+#endif /* RTX_CODE */"}, {"sha": "03e9f3f2485a5fef4bdb0d28d6b2a71a800eece8", "filename": "gcc/config/moxie/moxie.c", "status": "added", "additions": 480, "deletions": 0, "changes": 480, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cceb575c43dd2f2eebd51c31aefeecfac6529675/gcc%2Fconfig%2Fmoxie%2Fmoxie.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cceb575c43dd2f2eebd51c31aefeecfac6529675/gcc%2Fconfig%2Fmoxie%2Fmoxie.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmoxie%2Fmoxie.c?ref=cceb575c43dd2f2eebd51c31aefeecfac6529675", "patch": "@@ -0,0 +1,480 @@\n+/* Target Code for moxie\n+   Copyright (C) 2008, 2009  Free Software Foundation\n+   Contributed by Anthony Green.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"insn-flags.h\"\n+#include \"output.h\"\n+#include \"insn-attr.h\"\n+#include \"flags.h\"\n+#include \"recog.h\"\n+#include \"reload.h\"\n+#include \"toplev.h\"\n+#include \"obstack.h\"\n+#include \"tree.h\"\n+#include \"expr.h\"\n+#include \"optabs.h\"\n+#include \"except.h\"\n+#include \"function.h\"\n+#include \"ggc.h\"\n+#include \"target.h\"\n+#include \"target-def.h\"\n+#include \"tm_p.h\"\n+#include \"langhooks.h\"\n+#include \"df.h\"\n+\n+#define LOSE_AND_RETURN(msgid, x)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      moxie_operand_lossage (msgid, x);\t\t\\\n+      return;\t\t\t\t\t\\\n+    } while (0)\n+\n+/* Worker function for TARGET_RETURN_IN_MEMORY.  */\n+\n+static bool\n+moxie_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n+{\n+  const HOST_WIDE_INT size = int_size_in_bytes (type);\n+  return (size == -1 || size > 2 * UNITS_PER_WORD);\n+}\n+\n+/* Define how to find the value returned by a function.\n+   VALTYPE is the data type of the value (as a tree).\n+   If the precise function being called is known, FUNC is its\n+   FUNCTION_DECL; otherwise, FUNC is 0.  \n+\n+   We always return values in register $r0 for moxie.  */\n+\n+rtx\n+moxie_function_value (tree valtype, \n+\t\t      tree fntype_or_decl ATTRIBUTE_UNUSED,\n+\t\t      bool outgoing ATTRIBUTE_UNUSED)\n+{\n+  return gen_rtx_REG (TYPE_MODE (valtype), MOXIE_R0);\n+}\n+\n+/* Emit an error message when we're in an asm, and a fatal error for\n+   \"normal\" insns.  Formatted output isn't easily implemented, since we\n+   use output_operand_lossage to output the actual message and handle the\n+   categorization of the error.  */\n+\n+static void\n+moxie_operand_lossage (const char *msgid, rtx op)\n+{\n+  debug_rtx (op);\n+  output_operand_lossage (\"%s\", msgid);\n+}\n+\n+/* The PRINT_OPERAND_ADDRESS worker.  */\n+\n+void\n+moxie_print_operand_address (FILE *file, rtx x)\n+{\n+  switch (GET_CODE (x))\n+    {\n+    case REG:\n+      fprintf (file, \"(%s)\", reg_names[REGNO (x)]);\n+      break;\n+      \n+    case PLUS:\n+      switch (GET_CODE (XEXP (x, 1)))\n+\t{\n+\tcase CONST_INT:\n+\t  fprintf (file, \"%ld(%s)\", \n+\t\t   INTVAL(XEXP (x, 1)), reg_names[REGNO (XEXP (x, 0))]);\n+\t  break;\n+\tcase SYMBOL_REF:\n+\t  output_addr_const (file, XEXP (x, 1));\n+\t  fprintf (file, \"(%s)\", reg_names[REGNO (XEXP (x, 0))]);\n+\t  break;\n+\tcase CONST:\n+\t  {\n+\t    rtx plus = XEXP (XEXP (x, 1), 0);\n+\t    if (GET_CODE (XEXP (plus, 0)) == SYMBOL_REF \n+\t\t&& CONST_INT_P (XEXP (plus, 1)))\n+\t      {\n+\t\toutput_addr_const(file, XEXP (plus, 0));\n+\t\tfprintf (file,\"+%ld(%s)\", INTVAL (XEXP (plus, 1)),\n+\t\t\t reg_names[REGNO (XEXP (x, 0))]);\n+\t      }\n+\t    else\n+\t      abort();\n+\t  }\n+\t  break;\n+\tdefault:\n+\t  abort();\n+\t}\n+      break;\n+\n+    default:\n+      output_addr_const (file, x);\n+      break;\n+    }\n+}\n+\n+/* The PRINT_OPERAND worker.  */\n+\n+void\n+moxie_print_operand (FILE *file, rtx x, int code)\n+{\n+  rtx operand = x;\n+\n+  /* New code entries should just be added to the switch below.  If\n+     handling is finished, just return.  If handling was just a\n+     modification of the operand, the modified operand should be put in\n+     \"operand\", and then do a break to let default handling\n+     (zero-modifier) output the operand.  */\n+\n+  switch (code)\n+    {\n+    case 0:\n+      /* No code, print as usual.  */\n+      break;\n+\n+    default:\n+      LOSE_AND_RETURN (\"invalid operand modifier letter\", x);\n+    }\n+\n+  /* Print an operand as without a modifier letter.  */\n+  switch (GET_CODE (operand))\n+    {\n+    case REG:\n+      if (REGNO (operand) > MOXIE_R13)\n+\tinternal_error (\"internal error: bad register: %d\", REGNO (operand));\n+      fprintf (file, \"%s\", reg_names[REGNO (operand)]);\n+      return;\n+\n+    case MEM:\n+      output_address (XEXP (operand, 0));\n+      return;\n+\n+    default:\n+      /* No need to handle all strange variants, let output_addr_const\n+\t do it for us.  */\n+      if (CONSTANT_P (operand))\n+\t{\n+\t  output_addr_const (file, operand);\n+\t  return;\n+\t}\n+\n+      LOSE_AND_RETURN (\"unexpected operand\", x);\n+    }\n+}\n+\n+/* Per-function machine data.  */\n+struct GTY(()) machine_function\n+ {\n+   /* Number of bytes saved on the stack for callee saved registers.  */\n+   int callee_saved_reg_size;\n+\n+   /* Number of bytes saved on the stack for local variables.  */\n+   int local_vars_size;\n+\n+   /* The sum of 2 sizes: locals vars and padding byte for saving the\n+    * registers.  Used in expand_prologue () and expand_epilogue().  */\n+   int size_for_adjusting_sp;\n+ };\n+\n+/* Zero initialization is OK for all current fields.  */\n+\n+static struct machine_function *\n+moxie_init_machine_status (void)\n+{\n+  return GGC_CNEW (struct machine_function);\n+}\n+\n+\n+/* The OVERRIDE_OPTIONS worker.\n+   All this curently does is set init_machine_status.  */\n+void\n+moxie_override_options (void)\n+{\n+  /* Set the per-function-data initializer.  */\n+  init_machine_status = moxie_init_machine_status;\n+}\n+\n+/* Compute the size of the local area and the size to be adjusted by the\n+ * prologue and epilogue.  */\n+\n+static void\n+moxie_compute_frame (void)\n+{\n+  /* For aligning the local variables.  */\n+  int stack_alignment = STACK_BOUNDARY / BITS_PER_UNIT;\n+  int padding_locals;\n+  int regno;\n+\n+  /* Padding needed for each element of the frame.  */\n+  cfun->machine->local_vars_size = get_frame_size ();\n+\n+  /* Align to the stack alignment.  */\n+  padding_locals = cfun->machine->local_vars_size % stack_alignment;\n+  if (padding_locals)\n+    padding_locals = stack_alignment - padding_locals;\n+\n+  cfun->machine->local_vars_size += padding_locals;\n+\n+  cfun->machine->callee_saved_reg_size = 0;\n+\n+  /* Save callee-saved registers.  */\n+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+    if (df_regs_ever_live_p (regno) && (! call_used_regs[regno]))\n+      cfun->machine->callee_saved_reg_size += 4;\n+\n+  cfun->machine->size_for_adjusting_sp = \n+    crtl->args.pretend_args_size\n+    + cfun->machine->local_vars_size \n+    + (ACCUMULATE_OUTGOING_ARGS ? crtl->outgoing_args_size : 0);\n+}\n+\n+void\n+moxie_expand_prologue (void)\n+{\n+  int regno;\n+  rtx insn;\n+\n+  moxie_compute_frame ();\n+\n+  /* Save callee-saved registers.  */\n+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+    {\n+      if (!fixed_regs[regno] && df_regs_ever_live_p (regno) && !call_used_regs[regno])\n+\t{\n+\t  insn = emit_insn (gen_movsi_push (gen_rtx_REG (Pmode, regno)));\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t}\n+    }\n+\n+  if (cfun->machine->size_for_adjusting_sp > 0)\n+    {\n+      insn = \n+\temit_insn (gen_movsi (gen_rtx_REG (Pmode, MOXIE_R12), \n+\t\t\t      GEN_INT (-cfun->machine->size_for_adjusting_sp)));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+      insn = emit_insn (gen_addsi3 (stack_pointer_rtx, \n+\t\t\t\t    stack_pointer_rtx, \n+\t\t\t\t    gen_rtx_REG (Pmode, MOXIE_R12)));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+}\n+\n+void\n+moxie_expand_epilogue (void)\n+{\n+  int regno;\n+  rtx insn, reg, cfa_restores = NULL;\n+\n+  if (cfun->machine->callee_saved_reg_size != 0)\n+    {\n+      reg = gen_rtx_REG (Pmode, MOXIE_R12);\n+      emit_move_insn (reg,\n+\t\t      GEN_INT (-cfun->machine->callee_saved_reg_size));\n+      emit_insn (gen_addsi3 (reg, reg, hard_frame_pointer_rtx));\n+      insn = emit_move_insn (stack_pointer_rtx, reg);\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+      add_reg_note (insn, REG_CFA_DEF_CFA,\n+\t\t    plus_constant (stack_pointer_rtx,\n+\t\t\t\t   cfun->machine->callee_saved_reg_size));\n+      for (regno = FIRST_PSEUDO_REGISTER; regno-- > 0; )\n+\tif (!fixed_regs[regno] && !call_used_regs[regno]\n+\t    && df_regs_ever_live_p (regno))\n+\t  {\n+\t    reg = gen_rtx_REG (Pmode, regno);\n+\t    insn = emit_insn (gen_movsi_pop (reg));\n+\t    RTX_FRAME_RELATED_P (insn) = 1;\n+\t    add_reg_note (insn, REG_CFA_ADJUST_CFA,\n+\t\t\t  gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n+\t\t\t\t       plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\t      UNITS_PER_WORD)));\n+\t    add_reg_note (insn, REG_CFA_RESTORE, reg);\n+\t  }\n+    }\n+\n+  emit_jump_insn (gen_returner ());\n+}\n+\n+/* Implements the macro INITIAL_ELIMINATION_OFFSET, return the OFFSET.  */\n+\n+int\n+moxie_initial_elimination_offset (int from, int to)\n+{\n+  int ret;\n+  \n+  if ((from) == FRAME_POINTER_REGNUM && (to) == HARD_FRAME_POINTER_REGNUM)\n+    {\n+      /* Compute this since we need to use cfun->machine->local_vars_size.  */\n+      moxie_compute_frame ();\n+      ret = -cfun->machine->callee_saved_reg_size;\n+    }\n+  else if ((from) == ARG_POINTER_REGNUM && (to) == HARD_FRAME_POINTER_REGNUM)\n+    ret = 0x00;\n+  else\n+    abort ();\n+\n+  return ret;\n+}\n+\n+/* Worker function for TARGET_SETUP_INCOMING_VARARGS.  */\n+\n+static void\n+moxie_setup_incoming_varargs (CUMULATIVE_ARGS *cum,\n+\t\t\t      enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t      tree type ATTRIBUTE_UNUSED,\n+\t\t\t      int *pretend_size, int no_rtl)\n+{\n+  int regno;\n+  int regs = 4 - *cum;\n+  \n+  *pretend_size = regs < 0 ? 0 : GET_MODE_SIZE (SImode) * regs;\n+  \n+  if (no_rtl)\n+    return;\n+  \n+  for (regno = *cum; regno < 4; regno++)\n+    {\n+      rtx reg = gen_rtx_REG (SImode, regno);\n+      rtx slot = gen_rtx_PLUS (Pmode,\n+\t\t\t       gen_rtx_REG (SImode, ARG_POINTER_REGNUM),\n+\t\t\t       GEN_INT (UNITS_PER_WORD * (3 + (regno-2))));\n+      \n+      emit_move_insn (gen_rtx_MEM (SImode, slot), reg);\n+    }\n+}\n+\n+\n+/* Return the fixed registers used for condition codes.  */\n+\n+static bool\n+moxie_fixed_condition_code_regs (unsigned int *p1, unsigned int *p2)\n+{\n+  *p1 = CC_REG;\n+  *p2 = INVALID_REGNUM;\n+  return true;\n+}\n+\n+/* Return the next register to be used to hold a function argument or\n+   NULL_RTX if there's no more space.  */\n+\n+rtx\n+moxie_function_arg (CUMULATIVE_ARGS cum, enum machine_mode mode,\n+\t\t    tree type ATTRIBUTE_UNUSED, int named ATTRIBUTE_UNUSED)\n+{\n+  if (cum < 4)\n+    return gen_rtx_REG (mode, cum);\n+  else \n+    return NULL_RTX;\n+}\n+\n+/* Return non-zero if the function argument described by TYPE is to be\n+   passed by reference.  */\n+\n+static bool\n+moxie_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n+\t\t\t enum machine_mode mode, const_tree type,\n+\t\t\t bool named ATTRIBUTE_UNUSED)\n+{\n+  unsigned HOST_WIDE_INT size;\n+\n+  if (type)\n+    {\n+      if (AGGREGATE_TYPE_P (type))\n+\treturn true;\n+      size = int_size_in_bytes (type);\n+    }\n+  else\n+    size = GET_MODE_SIZE (mode);\n+\n+  return size > 8;\n+}\n+\n+/* Some function arguments will only partially fit in the registers\n+   that hold arguments.  Given a new arg, return the number of bytes\n+   that fit in argument passing registers.  */\n+\n+static int\n+moxie_arg_partial_bytes (CUMULATIVE_ARGS *cum,\n+\t\t\t enum machine_mode mode,\n+\t\t\t tree type, bool named)\n+{\n+  int bytes_left, size;\n+\n+  if (*cum >= 4)\n+    return 0;\n+\n+  if (moxie_pass_by_reference (cum, mode, type, named))\n+    size = 4;\n+  else if (type)\n+    {\n+      if (AGGREGATE_TYPE_P (type))\n+\treturn 0;\n+      size = int_size_in_bytes (type);\n+    }\n+  else\n+    size = GET_MODE_SIZE (mode);\n+\n+  bytes_left = 8 - ((*cum - 2) * 4);\n+\n+  if (size > bytes_left)\n+    return bytes_left;\n+  else\n+    return 0;\n+}\n+\n+/* The Global `targetm' Variable.  */\n+\n+/* Initialize the GCC target structure.  */\n+\n+#undef  TARGET_PROMOTE_PROTOTYPES\n+#define TARGET_PROMOTE_PROTOTYPES\thook_bool_const_tree_true\n+\n+#undef  TARGET_RETURN_IN_MEMORY\n+#define TARGET_RETURN_IN_MEMORY\t\tmoxie_return_in_memory\n+#undef  TARGET_MUST_PASS_IN_STACK\n+#define TARGET_MUST_PASS_IN_STACK\tmust_pass_in_stack_var_size\n+#undef  TARGET_PASS_BY_REFERENCE\n+#define TARGET_PASS_BY_REFERENCE        moxie_pass_by_reference\n+#undef  TARGET_ARG_PARTIAL_BYTES\n+#define TARGET_ARG_PARTIAL_BYTES        moxie_arg_partial_bytes\n+\n+\n+#undef  TARGET_SETUP_INCOMING_VARARGS\n+#define TARGET_SETUP_INCOMING_VARARGS \tmoxie_setup_incoming_varargs\n+\n+#undef\tTARGET_FIXED_CONDITION_CODE_REGS\n+#define\tTARGET_FIXED_CONDITION_CODE_REGS moxie_fixed_condition_code_regs\n+\n+/* Define this to return an RTX representing the place where a\n+   function returns or receives a value of data type RET_TYPE, a tree\n+   node node representing a data type.  */\n+#undef TARGET_FUNCTION_VALUE\n+#define TARGET_FUNCTION_VALUE moxie_function_value\n+\n+struct gcc_target targetm = TARGET_INITIALIZER;\n+\n+#include \"gt-moxie.h\""}, {"sha": "6685b0941eabbab5c34797939728138e2cd569fb", "filename": "gcc/config/moxie/moxie.h", "status": "added", "additions": 574, "deletions": 0, "changes": 574, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cceb575c43dd2f2eebd51c31aefeecfac6529675/gcc%2Fconfig%2Fmoxie%2Fmoxie.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cceb575c43dd2f2eebd51c31aefeecfac6529675/gcc%2Fconfig%2Fmoxie%2Fmoxie.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmoxie%2Fmoxie.h?ref=cceb575c43dd2f2eebd51c31aefeecfac6529675", "patch": "@@ -0,0 +1,574 @@\n+/* Target Definitions for moxie.\n+   Copyright (C) 2008, 2009  Free Software Foundation, Inc.\n+   Contributed by Anthony Green.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_MOXIE_H\n+#define GCC_MOXIE_H\n+\n+/* This is defined by svr4.h, which is included prior to this file.\n+   However, we should undefine it for moxie-elf, since we don't provide\n+   functions like access() and mkdir() in newlib.  This will have to\n+   be defined again for a Linux port.  */\n+#undef TARGET_POSIX_IO\n+\n+/* Another C string constant used much like `LINK_SPEC'.  The difference\n+   between the two is that `STARTFILE_SPEC' is used at the very beginning of\n+   the command given to the linker.\n+\n+   If this macro is not defined, a default is provided that loads the standard\n+   C startup file from the usual place.  See `gcc.c'.\n+\n+   Defined in svr4.h.  */\n+#undef  STARTFILE_SPEC\n+#define STARTFILE_SPEC \"crt0%O%s crti.o%s crtbegin.o%s\"\n+\n+/* Provide an ENDFILE_SPEC appropriate for svr4.  Here we tack on our own\n+   magical crtend.o file (see crtstuff.c) which provides part of the\n+   support for getting C++ file-scope static object constructed before\n+   entering `main', followed by the normal svr3/svr4 \"finalizer\" file,\n+   which is either `gcrtn.o' or `crtn.o'.  */\n+\n+#undef  ENDFILE_SPEC\n+#define ENDFILE_SPEC \"crtend.o%s crtn.o%s\"\n+\n+/* Provide a LIB_SPEC appropriate for svr4.  Here we tack on the default\n+   standard C library (unless we are building a shared library) and\n+   the simulator BSP code.  */\n+\n+#undef LIB_SPEC\n+#define LIB_SPEC \"%{!shared:%{!symbolic:-lc}}\"\n+\n+/* Layout of Source Language Data Types */\n+\n+#define INT_TYPE_SIZE 32\n+#define SHORT_TYPE_SIZE 16\n+#define LONG_TYPE_SIZE 32\n+#define LONG_LONG_TYPE_SIZE 64\n+\n+#define FLOAT_TYPE_SIZE 32\n+#define DOUBLE_TYPE_SIZE 64\n+#define LONG_DOUBLE_TYPE_SIZE 64\n+\n+#define DEFAULT_SIGNED_CHAR 1\n+\n+/* Registers...\n+\n+   $fp  - frame pointer\n+   $sp  - stack pointer\n+   $r0  - general purpose 32-bit register.\n+   $r1  - general purpose 32-bit register.\n+   $r2  - general purpose 32-bit register.\n+   $r3  - general purpose 32-bit register.\n+   $r4  - general purpose 32-bit register.\n+   $r5  - general purpose 32-bit register.\n+   $r6  - general purpose 32-bit register.\n+   $r7  - general purpose 32-bit register.\n+   $r8  - general purpose 32-bit register.\n+   $r9  - general purpose 32-bit register.\n+   $r10 - general purpose 32-bit register.\n+   $r11 - general purpose 32-bit register.\n+   $r12 - general purpose 32-bit register.\n+   $r13 - reserved for execution environment.\n+\n+   Special Registers...\n+\n+   $pc - 32-bit program counter.\n+   \n+*/\n+\n+#define REGISTER_NAMES {\t\\\n+  \"$fp\", \"$sp\", \"$r0\", \"$r1\",   \\\n+  \"$r2\", \"$r3\", \"$r4\", \"$r5\",   \\\n+  \"$r6\", \"$r7\", \"$r8\", \"$r9\",   \\\n+  \"$r10\", \"$r11\", \"$r12\", \"$r13\",   \\\n+  \"?fp\", \"?ap\", \"$pc\", \"?cc\" }\n+\n+#define MOXIE_FP     0\n+#define MOXIE_SP     1\n+#define MOXIE_R0     2\n+#define MOXIE_R1     3 \n+#define MOXIE_R2     4\n+#define MOXIE_R3     5\n+#define MOXIE_R4     6\n+#define MOXIE_R5     7\n+#define MOXIE_R6     8\n+#define MOXIE_R7     9\n+#define MOXIE_R8     10\n+#define MOXIE_R9     11\n+#define MOXIE_R10    12\n+#define MOXIE_R11    13\n+#define MOXIE_R12    14\n+#define MOXIE_R13    15\n+#define MOXIE_QFP    16\n+#define MOXIE_QAP    17\n+#define MOXIE_PC     18\n+#define MOXIE_CC     19\n+\n+#define FIRST_PSEUDO_REGISTER 20\n+\n+enum reg_class\n+{\n+  NO_REGS,\n+  GENERAL_REGS,\n+  SPECIAL_REGS,\n+  CC_REG,\n+  ALL_REGS,\n+  LIM_REG_CLASSES\n+};\n+\n+\n+/* The following macro defines cover classes for Integrated Register\n+   Allocator.  Cover classes is a set of non-intersected register\n+   classes covering all hard registers used for register allocation\n+   purpose.  Any move between two registers of a cover class should be\n+   cheaper than load or store of the registers.  The macro value is\n+   array of register classes with LIM_REG_CLASSES used as the end\n+   marker.  */\n+#define IRA_COVER_CLASSES { GENERAL_REGS, LIM_REG_CLASSES }\n+\n+#define REG_CLASS_CONTENTS \\\n+{ { 0x00000000 }, /* Empty */\t\t\t   \\\n+  { 0x0003FFFF }, /* $fp, $sp, $r0 to $r5, ?fp */  \\\n+  { 0x00040000 }, /* $pc */\t                   \\\n+  { 0x00080000 }, /* ?cc */                        \\\n+  { 0x000FFFFF }  /* All registers */              \\\n+}\n+\n+#define N_REG_CLASSES LIM_REG_CLASSES\n+\n+#define REG_CLASS_NAMES {\\\n+    \"NO_REGS\", \\\n+    \"GENERAL_REGS\", \\\n+    \"SPECIAL_REGS\", \\\n+    \"CC_REG\", \\\n+    \"ALL_REGS\" }\n+\n+#define FIXED_REGISTERS     { 1, 1, 0, 0, \\\n+\t\t\t      0, 0, 0, 0, \\\n+\t\t\t      0, 0, 0, 0, \\\n+\t\t\t      0, 0, 0, 1, \\\n+                              1, 1, 1, 1 }\n+\n+#define CALL_USED_REGISTERS { 1, 1, 1, 1, \\\n+\t\t\t      0, 0, 0, 0, \\\n+\t\t\t      0, 0, 0, 0, \\\n+\t\t\t      0, 0, 1, 1, \\\n+                              1, 1, 1, 1 }\n+\n+/* We can't copy to or from our CC register. */\n+#define AVOID_CCMODE_COPIES 1\n+\n+/* A C expression that is nonzero if it is permissible to store a\n+   value of mode MODE in hard register number REGNO (or in several\n+   registers starting with that one).  All gstore registers are \n+   equivalent, so we can set this to 1.  */\n+#define HARD_REGNO_MODE_OK(R,M) 1\n+\n+/* A C expression whose value is a register class containing hard\n+   register REGNO.  */\n+#define REGNO_REG_CLASS(R) ((R < MOXIE_PC) ? GENERAL_REGS : \\\n+                            (R == MOXIE_CC ? CC_REG : SPECIAL_REGS))\n+\n+/* A C expression for the number of consecutive hard registers,\n+   starting at register number REGNO, required to hold a value of mode\n+   MODE.  */\n+#define HARD_REGNO_NREGS(REGNO, MODE)\t\t\t   \\\n+  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1)\t\t   \\\n+   / UNITS_PER_WORD)\n+\n+/* A C expression that is nonzero if a value of mode MODE1 is\n+   accessible in mode MODE2 without copying.  */\n+#define MODES_TIEABLE_P(MODE1, MODE2) 1\n+\n+/* A C expression for the maximum number of consecutive registers of\n+   class CLASS needed to hold a value of mode MODE.  */\n+#define CLASS_MAX_NREGS(CLASS, MODE) \\\n+  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* A C expression that places additional restrictions on the register\n+   class to use when it is necessary to copy value X into a register\n+   in class CLASS.  */\n+#define PREFERRED_RELOAD_CLASS(X,CLASS) CLASS\n+\n+/* The Overall Framework of an Assembler File */\n+\n+#undef  ASM_SPEC\n+#define ASM_COMMENT_START \"#\"\n+#define ASM_APP_ON \"\"\n+#define ASM_APP_OFF \"\"\n+\n+#define FILE_ASM_OP     \"\\t.file\\n\"\n+\n+/* Switch to the text or data segment.  */\n+#define TEXT_SECTION_ASM_OP  \"\\t.text\"\n+#define DATA_SECTION_ASM_OP  \"\\t.data\"\n+\n+/* Assembler Commands for Alignment */\n+\n+#define ASM_OUTPUT_ALIGN(STREAM,POWER) \\\n+\tfprintf (STREAM, \"\\t.p2align\\t%d\\n\", POWER);\n+\n+/* A C compound statement to output to stdio stream STREAM the\n+   assembler syntax for an instruction operand X.  */\n+#define PRINT_OPERAND(STREAM, X, CODE) moxie_print_operand (STREAM, X, CODE)\n+\n+#define PRINT_OPERAND_ADDRESS(STREAM ,X) moxie_print_operand_address (STREAM, X)\n+\n+/* Output and Generation of Labels */\n+\n+#define GLOBAL_ASM_OP \"\\t.global\\t\"\n+\n+/* Passing Arguments in Registers */\n+\n+/* A C expression that controls whether a function argument is passed\n+   in a register, and which register.  */\n+#define FUNCTION_ARG(CUM,MODE,TYPE,NAMED) \\\n+  moxie_function_arg(CUM,MODE,TYPE,NAMED)\n+\n+/* A C type for declaring a variable that is used as the first\n+   argument of `FUNCTION_ARG' and other related values.  */\n+#define CUMULATIVE_ARGS unsigned int\n+\n+/* If defined, the maximum amount of space required for outgoing arguments\n+   will be computed and placed into the variable\n+   `current_function_outgoing_args_size'.  No space will be pushed\n+   onto the stack for each call; instead, the function prologue should\n+   increase the stack frame size by this amount.  */\n+#define ACCUMULATE_OUTGOING_ARGS 1\n+\n+/* A C statement (sans semicolon) for initializing the variable CUM\n+   for the state at the beginning of the argument list.  \n+   For moxie, the first arg is passed in register 2 (aka $r0).  */\n+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,FNDECL,N_NAMED_ARGS) \\\n+  (CUM = MOXIE_R0)\n+\n+#define MOXIE_FUNCTION_ARG_SIZE(MODE, TYPE)\t\\\n+  ((MODE) != BLKmode ? GET_MODE_SIZE (MODE)\t\\\n+   : (unsigned) int_size_in_bytes (TYPE))\n+\n+#define FUNCTION_ARG_ADVANCE(CUM,MODE,TYPE,NAMED) \\\n+  (CUM = (CUM < MOXIE_R2 ?                        \\\n+          CUM + ((3 + MOXIE_FUNCTION_ARG_SIZE(MODE,TYPE))/4) : CUM ))\n+\n+/* How Scalar Function Values Are Returned */\n+\n+/* These macros are deprecated, but we still need them for now since\n+   the version of gcc we're using doesn't fully support\n+   TARGET_FUNCTION_VALUE.  */\n+#define FUNCTION_VALUE(VALTYPE, FUNC) \\\n+  moxie_function_value (VALTYPE, FUNC, 0)\n+#define FUNCTION_OUTGOING_VALUE(VALTYPE, FUNC) \\\n+  moxie_function_value (VALTYPE, FUNC, 1)\n+\n+/* A C expression to create an RTX representing the place where a\n+   library function returns a value of mode MODE.  */\n+#define LIBCALL_VALUE(MODE) gen_rtx_REG (MODE, 2)\n+\n+/* STACK AND CALLING */\n+\n+/* Define this macro if pushing a word onto the stack moves the stack\n+   pointer to a smaller address.  */\n+#define STACK_GROWS_DOWNWARD\n+\n+#define INITIAL_FRAME_POINTER_OFFSET(DEPTH) (DEPTH) = 0\n+\n+/* Offset from the frame pointer to the first local variable slot to\n+   be allocated.  */\n+#define STARTING_FRAME_OFFSET 0\n+\n+/* Define this if the above stack space is to be considered part of the\n+   space allocated by the caller.  */\n+#define OUTGOING_REG_PARM_STACK_SPACE(FNTYPE) 1\n+#define STACK_PARMS_IN_REG_PARM_AREA\n+\n+/* Define this if it is the responsibility of the caller to allocate\n+   the area reserved for arguments passed in registers.  */\n+#define REG_PARM_STACK_SPACE(FNDECL) (2 * UNITS_PER_WORD)\n+\n+/* Offset from the argument pointer register to the first argument's\n+   address.  On some machines it may depend on the data type of the\n+   function.  */\n+#define FIRST_PARM_OFFSET(F) 12\n+\n+/* Define this macro to nonzero value if the addresses of local variable slots\n+   are at negative offsets from the frame pointer.  */\n+#define FRAME_GROWS_DOWNWARD 1\n+\n+/* Define this macro as a C expression that is nonzero for registers that are\n+   used by the epilogue or the return pattern.  The stack and frame\n+   pointer registers are already assumed to be used as needed.  */\n+#define EPILOGUE_USES(R) (R == MOXIE_R5)\n+\n+#define OVERRIDE_OPTIONS moxie_override_options ()\n+\n+/* Storage Layout */\n+\n+#define BITS_BIG_ENDIAN 0\n+#define BYTES_BIG_ENDIAN 1\n+#define WORDS_BIG_ENDIAN 1\n+\n+/* Alignment required for a function entry point, in bits.  */\n+#define FUNCTION_BOUNDARY 16\n+\n+/* Define this macro as a C expression which is nonzero if accessing\n+   less than a word of memory (i.e. a `char' or a `short') is no\n+   faster than accessing a word of memory.  */\n+#define SLOW_BYTE_ACCESS 1\n+\n+/* Number of storage units in a word; normally the size of a\n+   general-purpose register, a power of two from 1 or 8.  */\n+#define UNITS_PER_WORD 4\n+\n+/* Define this macro to the minimum alignment enforced by hardware\n+   for the stack pointer on this machine.  The definition is a C\n+   expression for the desired alignment (measured in bits).  */\n+#define STACK_BOUNDARY 32\n+\n+/* Normal alignment required for function parameters on the stack, in\n+   bits.  All stack parameters receive at least this much alignment\n+   regardless of data type.  */\n+#define PARM_BOUNDARY 32\n+\n+/* Alignment of field after `int : 0' in a structure.  */\n+#define EMPTY_FIELD_BOUNDARY  32\n+\n+/* No data type wants to be aligned rounder than this.  */\n+#define BIGGEST_ALIGNMENT 32\n+\n+/* The best alignment to use in cases where we have a choice.  */\n+#define FASTEST_ALIGNMENT 32\n+\n+/* Every structures size must be a multiple of 8 bits.  */\n+#define STRUCTURE_SIZE_BOUNDARY 8\n+\n+/* Look at the fundamental type that is used for a bit-field and use \n+   that to impose alignment on the enclosing structure.\n+   struct s {int a:8}; should have same alignment as \"int\", not \"char\".  */\n+#define\tPCC_BITFIELD_TYPE_MATTERS\t1\n+\n+/* Largest integer machine mode for structures.  If undefined, the default\n+   is GET_MODE_SIZE(DImode).  */\n+#define MAX_FIXED_MODE_SIZE 32\n+\n+/* Make strings word-aligned so strcpy from constants will be faster.  */\n+#define CONSTANT_ALIGNMENT(EXP, ALIGN)  \\\n+  ((TREE_CODE (EXP) == STRING_CST\t\\\n+    && (ALIGN) < FASTEST_ALIGNMENT)\t\\\n+   ? FASTEST_ALIGNMENT : (ALIGN))\n+\n+/* Make arrays of chars word-aligned for the same reasons.  */\n+#define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\\\n+  (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\\\n+   && TYPE_MODE (TREE_TYPE (TYPE)) == QImode\t\\\n+   && (ALIGN) < FASTEST_ALIGNMENT ? FASTEST_ALIGNMENT : (ALIGN))\n+     \n+/* Set this nonzero if move instructions will actually fail to work\n+   when given unaligned data.  */\n+#define STRICT_ALIGNMENT 1\n+\n+/* Generating Code for Profiling */\n+#define FUNCTION_PROFILER(FILE,LABELNO) (abort (), 0)\n+\n+/* Trampolines for Nested Functions.  */\n+#define TRAMPOLINE_SIZE (2 + 6 + 6 + 2 + 6)\n+\n+/* Alignment required for trampolines, in bits.  */\n+#define TRAMPOLINE_ALIGNMENT 16\n+\n+/* A C statement to initialize the variable parts of a trampoline.  ADDR is an\n+   RTX for the address of the trampoline; FNADDR is an RTX for the address of\n+   the nested function; STATIC_CHAIN is an RTX for the static chain value that\n+   should be passed to the function when it is called.  */\n+#define INITIALIZE_TRAMPOLINE(ADDR, FNADDR, STATIC_CHAIN)\t\t      \\\n+do\t\t\t\t\t\t\t\t\t      \\\n+{\t\t\t\t\t\t\t\t\t      \\\n+  emit_move_insn (gen_rtx_MEM (SImode,                                        \\\n+                               plus_constant (ADDR, 4)), STATIC_CHAIN);       \\\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (ADDR, 18)), FNADDR);    \\\n+} while (0);\n+\n+/* A C statement to output, on the stream FILE, assembler code for a\n+   block of data that contains the constant parts of a trampoline.\n+   This code should not include a label--the label is taken care of\n+   automatically.  */\n+#define TRAMPOLINE_TEMPLATE(FILE)\t       \t\\\n+{\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tpush  $sp, $r0\\n\");         \\\n+  fprintf (FILE, \"\\tldi.l $r0, 0x0\\n\"); \t\\\n+  fprintf (FILE, \"\\tsto.l 0x8($fp), $r0\\n\");\t\\\n+  fprintf (FILE, \"\\tpop   $sp, $r0\\n\");\t\t\\\n+  fprintf (FILE, \"\\tjmpa  0x0\\n\");\t        \\\n+}\n+\n+/* An alias for the machine mode for pointers.  */\n+#define Pmode         SImode\n+\n+/* An alias for the machine mode used for memory references to\n+   functions being called, in `call' RTL expressions.  */\n+#define FUNCTION_MODE QImode\n+\n+/* The register number of the stack pointer register, which must also\n+   be a fixed register according to `FIXED_REGISTERS'.  */\n+#define STACK_POINTER_REGNUM 1\n+\n+/* The register number of the frame pointer register, which is used to\n+   access automatic variables in the stack frame.  */\n+#define FRAME_POINTER_REGNUM MOXIE_QFP\n+\n+/* The register number of the arg pointer register, which is used to\n+   access the function's argument list.  */\n+#define ARG_POINTER_REGNUM MOXIE_QAP\n+\n+/* If the static chain is passed in memory, these macros provide rtx\n+   giving 'mem' expressions that denote where they are stored.\n+   'STATIC_CHAIN' and 'STATIC_CHAIN_INCOMING' give the locations as\n+   seen by the calling and called functions, respectively.  */\n+\n+#define STATIC_CHAIN\t\t\t\t\t\t\t\\\n+  gen_rtx_MEM (Pmode, plus_constant (stack_pointer_rtx, -UNITS_PER_WORD))\n+\n+#define STATIC_CHAIN_INCOMING\t\t\t\t\t\t\\\n+  gen_rtx_MEM (Pmode, plus_constant (arg_pointer_rtx, 2 * UNITS_PER_WORD))\n+\n+#define HARD_FRAME_POINTER_REGNUM MOXIE_FP\n+\n+#if 0\n+#define ELIMINABLE_REGS\t\t\t\t\t\t\t\\\n+{{ FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM },\t\t\t\\\n+ { FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM },\t\t\t\\\n+ { ARG_POINTER_REGNUM,\t STACK_POINTER_REGNUM },\t\t\t\\\n+ { ARG_POINTER_REGNUM,   HARD_FRAME_POINTER_REGNUM }}\t\t\t\n+#else\n+#define ELIMINABLE_REGS\t\t\t\t\t\t\t\\\n+{{ FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM },\t\t\t\\\n+ { ARG_POINTER_REGNUM,   HARD_FRAME_POINTER_REGNUM }}\t\t\t\n+#endif\n+\n+/* A C expression that returns nonzero if the compiler is allowed to\n+   try to replace register number FROM-REG with register number\n+   TO-REG.  This macro need only be defined if `ELIMINABLE_REGS' is\n+   defined, and will usually be the constant 1, since most of the\n+   cases preventing register elimination are things that the compiler\n+   already knows about.  */\n+#define CAN_ELIMINATE(FROM, TO) 1\n+\n+/* This macro is similar to `INITIAL_FRAME_POINTER_OFFSET'.  It\n+   specifies the initial difference between the specified pair of\n+   registers.  This macro must be defined if `ELIMINABLE_REGS' is\n+   defined.  */\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    (OFFSET) = moxie_initial_elimination_offset ((FROM), (TO));\t\t\\\n+  } while (0)\n+\n+/* A C expression that is nonzero if REGNO is the number of a hard\n+   register in which function arguments are sometimes passed.  */\n+#define FUNCTION_ARG_REGNO_P(r) (r == MOXIE_R0 || r == MOXIE_R1)\n+\n+/* A C expression that is nonzero if REGNO is the number of a hard\n+   register in which the values of called function may come back.  */\n+#define FUNCTION_VALUE_REGNO_P(r) (r == MOXIE_R0)\n+\n+/* A macro whose definition is the name of the class to which a valid\n+   base register must belong.  A base register is one used in an\n+   address which is the register value plus a displacement.  */\n+#define BASE_REG_CLASS GENERAL_REGS\n+\n+#define INDEX_REG_CLASS NO_REGS\n+\n+#define HARD_REGNO_OK_FOR_BASE_P(NUM) \\\n+  ((NUM) >= 0 && (NUM) < FIRST_PSEUDO_REGISTER \\\n+   && (REGNO_REG_CLASS(NUM) == GENERAL_REGS \\\n+       || (NUM) == HARD_FRAME_POINTER_REGNUM))\n+\n+/* A C expression which is nonzero if register number NUM is suitable\n+   for use as a base register in operand addresses.  */\n+#ifdef REG_OK_STRICT\n+#define REGNO_OK_FOR_BASE_P(NUM)\t\t \\\n+  (HARD_REGNO_OK_FOR_BASE_P(NUM) \t\t \\\n+   || HARD_REGNO_OK_FOR_BASE_P(reg_renumber[(NUM)]))\n+#else\n+#define REGNO_OK_FOR_BASE_P(NUM)\t\t \\\n+  ((NUM) >= FIRST_PSEUDO_REGISTER || HARD_REGNO_OK_FOR_BASE_P(NUM))\n+#endif\n+\n+/* A C expression which is nonzero if register number NUM is suitable\n+   for use as an index register in operand addresses.  */\n+#define REGNO_OK_FOR_INDEX_P(NUM) MOXIE_FP\n+\n+/* The maximum number of bytes that a single instruction can move\n+   quickly between memory and registers or between two memory\n+   locations.  */\n+#define MOVE_MAX 4\n+#define TRULY_NOOP_TRUNCATION(op,ip) 1\n+\n+#define RETURN_POPS_ARGS(FUNDECL, FUNTYPE, STACK_SIZE) 0\n+\n+/* A C expression that is nonzero if X is a legitimate constant for\n+   an immediate operand on the target machine.  */\n+#define LEGITIMATE_CONSTANT_P(X) 1\n+\n+#define FRAME_POINTER_REQUIRED 1\n+\n+/* A C expression that is 1 if the RTX X is a constant which is a\n+   valid address.  */\n+#define CONSTANT_ADDRESS_P(X) CONSTANT_P(X)\n+\n+/* A number, the maximum number of registers that can appear in a\n+   valid memory address.  */\n+#define MAX_REGS_PER_ADDRESS 1\n+\n+#define TRULY_NOOP_TRUNCATION(op,ip) 1\n+\n+/* An alias for a machine mode name.  This is the machine mode that\n+   elements of a jump-table should have.  */\n+#define CASE_VECTOR_MODE SImode\n+\n+/* A C compound statement with a conditional `goto LABEL;' executed\n+   if X (an RTX) is a legitimate memory address on the target machine\n+   for a memory operand of mode MODE.  */\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE,X,LABEL)\t\t\\\n+  do {                                                  \\\n+    if (GET_CODE(X) == PLUS)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\trtx op1,op2;\t\t\t\t\t\\\n+\top1 = XEXP(X,0);\t\t\t\t\\\n+\top2 = XEXP(X,1);\t\t\t\t\\\n+\tif (GET_CODE(op1) == REG\t\t\t\\\n+\t    && CONSTANT_ADDRESS_P(op2)\t\t\t\\\n+\t    && REGNO_OK_FOR_BASE_P(REGNO(op1)))\t\t\\\n+\t  goto LABEL;\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+    if (REG_P (X) && REGNO_OK_FOR_BASE_P (REGNO (X)))\t\\\n+      goto LABEL;\t\t\t\t\t\\\n+    if (GET_CODE (X) == SYMBOL_REF\t\t\t\\\n+\t|| GET_CODE (X) == LABEL_REF\t\t\t\\\n+\t|| GET_CODE (X) == CONST)\t\t\t\\\n+      goto LABEL;\t\t\t\t\t\\\n+  } while (0)\n+\n+/* Run-time Target Specification */\n+\n+#define TARGET_CPU_CPP_BUILTINS() \\\n+  { \\\n+    builtin_define_std (\"moxie\");\t\t\\\n+    builtin_define_std (\"MOXIE\");\t\t\\\n+  }\n+\n+#endif /* GCC_MOXIE_H */"}, {"sha": "713bd4523d099ae22419e33b7441a959a386f6d0", "filename": "gcc/config/moxie/moxie.md", "status": "added", "additions": 421, "deletions": 0, "changes": 421, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cceb575c43dd2f2eebd51c31aefeecfac6529675/gcc%2Fconfig%2Fmoxie%2Fmoxie.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cceb575c43dd2f2eebd51c31aefeecfac6529675/gcc%2Fconfig%2Fmoxie%2Fmoxie.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmoxie%2Fmoxie.md?ref=cceb575c43dd2f2eebd51c31aefeecfac6529675", "patch": "@@ -0,0 +1,421 @@\n+;; Machine description for Moxie\n+;; Copyright (C) 2009 Free Software Foundation, Inc.\n+;; Contributed by Anthony Green <green@moxielogic.com>\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 3, or (at your\n+;; option) any later version.\n+\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+;; -------------------------------------------------------------------------\n+;; Moxie specific constraints\n+;; -------------------------------------------------------------------------\n+\n+(include \"constraints.md\")\n+(include \"predicates.md\")\n+\n+;; -------------------------------------------------------------------------\n+;; nop instruction\n+;; -------------------------------------------------------------------------\n+\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"nop\")\n+\n+;; -------------------------------------------------------------------------\n+;; Arithmetic instructions\n+;; -------------------------------------------------------------------------\n+\n+(define_insn \"addsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n+\t  (plus:SI\n+\t   (match_operand:SI 1 \"register_operand\" \"0,0,0\")\n+\t   (match_operand:SI 2 \"moxie_add_operand\" \"I,N,r\")))]\n+  \"\"\n+  \"@\n+  inc    %0, %2\n+  dec\t %0, -%2\n+  add.l  %0, %2\")\n+\n+(define_insn \"subsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t  (minus:SI\n+\t   (match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t   (match_operand:SI 2 \"moxie_sub_operand\" \"I,r\")))]\n+  \"\"\n+  \"@\n+  dec    %0, %2\n+  sub.l  %0, %2\")\n+\n+(define_insn \"mulsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t  (mult:SI\n+\t   (match_operand:SI 1 \"register_operand\" \"0\")\n+\t   (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"mul.l  %0, %2\")\n+\n+(define_insn \"divsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t  (div:SI\n+\t   (match_operand:SI 1 \"register_operand\" \"0\")\n+\t   (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"div.l  %0, %2\")\n+\n+(define_insn \"udivsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t  (udiv:SI\n+\t   (match_operand:SI 1 \"register_operand\" \"0\")\n+\t   (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"udiv.l %0, %2\")\n+\n+(define_insn \"modsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t  (mod:SI\n+\t   (match_operand:SI 1 \"register_operand\" \"0\")\n+\t   (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"mod.l  %0, %2\")\n+\n+(define_insn \"umodsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t  (umod:SI\n+\t   (match_operand:SI 1 \"register_operand\" \"0\")\n+\t   (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"umod.l %0, %2\")\n+\n+;; -------------------------------------------------------------------------\n+;; Unary arithmetic instructions\n+;; -------------------------------------------------------------------------\n+\n+(define_insn \"negsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t  (neg:SI (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"neg    %0, %1\")\n+\n+(define_insn \"one_cmplsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(not:SI (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"not    %0, %1\")\n+\n+;; -------------------------------------------------------------------------\n+;; Logical operators\n+;; -------------------------------------------------------------------------\n+\n+(define_insn \"andsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(and:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t(match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+{\n+  return \"and    %0, %2\";\n+})\n+\n+(define_insn \"xorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(xor:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t(match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+{\n+  return \"xor    %0, %2\";\n+})\n+\n+(define_insn \"iorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ior:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t(match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+{\n+  return \"or     %0, %2\";\n+})\n+\n+;; -------------------------------------------------------------------------\n+;; Shifters\n+;; -------------------------------------------------------------------------\n+\n+(define_insn \"ashlsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t   (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+{\n+  return \"ashl   %0, %2\";\n+})\n+\n+(define_insn \"ashrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t     (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+{\n+  return \"ashr   %0, %2\";\n+})\n+\n+(define_insn \"lshrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t     (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+{\n+  return \"lshr   %0, %2\";\n+})\n+\n+;; -------------------------------------------------------------------------\n+;; Move instructions\n+;; -------------------------------------------------------------------------\n+\n+;; SImode\n+\n+;; Push a register onto the stack\n+(define_insn \"movsi_push\"\n+  [(set:SI (mem:SI (pre_dec:SI (reg:SI 1)))\n+\t(match_operand:SI 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"push   $sp, %0\")\n+\n+;; Pop a register from the stack\n+(define_insn \"movsi_pop\"\n+  [(set:SI (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(mem:SI (post_inc:SI (reg:SI 1))))]\n+  \"\"\n+  \"pop    $sp, %0\")\n+\n+(define_expand \"movsi\"\n+   [(set (match_operand:SI 0 \"general_operand\" \"\")\n+ \t(match_operand:SI 1 \"general_operand\" \"\"))]\n+   \"\"\n+  \"\n+{\n+  /* If this is a store, force the value into a register.  */\n+  if (! (reload_in_progress || reload_completed))\n+  {\n+    if (MEM_P (operands[0]))\n+    {\n+      operands[1] = force_reg (SImode, operands[1]);\n+      if (MEM_P (XEXP (operands[0], 0)))\n+        operands[0] = gen_rtx_MEM (SImode, force_reg (SImode, XEXP (operands[0], 0)));\n+    }\n+    else \n+      if (MEM_P (operands[1])\n+          && MEM_P (XEXP (operands[1], 0)))\n+        operands[1] = gen_rtx_MEM (SImode, force_reg (SImode, XEXP (operands[1], 0)));\n+  }\n+}\")\n+\n+(define_insn \"*movsi\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=r,r,W,A,r,r,B,r\")\n+\t(match_operand:SI 1 \"moxie_general_movsrc_operand\" \"r,i,r,r,W,A,r,B\"))]\n+  \"register_operand (operands[0], SImode)\n+   || register_operand (operands[1], SImode)\"\n+  \"@\n+   mov    %0, %1\n+   ldi.l  %0, %1\n+   st.l   %0, %1\n+   sta.l  %0, %1\n+   ld.l   %0, %1\n+   lda.l  %0, %1\n+   sto.l  %0, %1\n+   ldo.l  %0, %1\")\n+\n+(define_expand \"movqi\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"\")\n+\t(match_operand:QI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  /* If this is a store, force the value into a register.  */\n+  if (MEM_P (operands[0]))\n+    operands[1] = force_reg (QImode, operands[1]);\n+}\")\n+\n+(define_insn \"*movqi\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=r,r,W,A,r,r,B,r\")\n+\t(match_operand:QI 1 \"moxie_general_movsrc_operand\" \"r,i,r,r,W,A,r,B\"))]\n+  \"register_operand (operands[0], QImode)\n+   || register_operand (operands[1], QImode)\"\n+  \"@\n+   mov    %0, %1\n+   ldi.b  %0, %1\n+   st.b   %0, %1\n+   sta.b  %0, %1\n+   ld.b   %0, %1\n+   lda.b  %0, %1\n+   sto.b  %0, %1\n+   ldo.b  %0, %1\")\n+\n+(define_expand \"movhi\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"\")\n+\t(match_operand:HI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  /* If this is a store, force the value into a register.  */\n+  if (MEM_P (operands[0]))\n+    operands[1] = force_reg (HImode, operands[1]);\n+}\")\n+\n+(define_insn \"*movhi\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=r,r,W,A,r,r,B,r\")\n+\t(match_operand:HI 1 \"moxie_general_movsrc_operand\" \"r,i,r,r,W,A,r,B\"))]\n+  \"(register_operand (operands[0], HImode)\n+    || register_operand (operands[1], HImode))\"\n+  \"@\n+   mov    %0, %1\n+   ldi.s  %0, %1\n+   st.s   %0, %1\n+   sta.s  %0, %1\n+   ld.s   %0, %1\n+   lda.s  %0, %1\n+   sto.s  %0, %1\n+   ldo.s  %0, %1\")\n+\n+;; -------------------------------------------------------------------------\n+;; Compare instructions\n+;; -------------------------------------------------------------------------\n+\n+(define_constants\n+  [(CC_REG 11)])\n+\n+(define_expand \"cbranchsi4\"\n+  [(set (reg:CC CC_REG)\n+        (compare:CC\n+         (match_operand:SI 1 \"register_operand\" \"\")\n+         (match_operand:SI 2 \"register_operand\" \"\")))\n+   (set (pc)\n+        (if_then_else (match_operator:CC 0 \"comparison_operator\"\n+                       [(reg:CC CC_REG) (const_int 0)])\n+                      (label_ref (match_operand 3 \"\" \"\"))\n+                      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*cmpsi\"\n+  [(set (reg:CC CC_REG)\n+\t(compare\n+\t (match_operand:SI 0 \"register_operand\" \"r\")\n+\t (match_operand:SI 1 \"register_operand\"\t\"r\")))]\n+  \"\"\n+  \"cmp    %0, %1\")\n+\n+\n+;; -------------------------------------------------------------------------\n+;; Branch instructions\n+;; -------------------------------------------------------------------------\n+\n+(define_code_iterator cond [ne eq lt ltu gt gtu ge le geu leu])\n+(define_code_attr CC [(ne \"ne\") (eq \"eq\") (lt \"lt\") (ltu \"ltu\") \n+\t\t      (gt \"gt\") (gtu \"gtu\") (ge \"ge\") (le \"le\") \n+\t\t      (geu \"geu\") (leu \"leu\") ])\n+\n+(define_insn \"*b<cond:code>\"\n+  [(set (pc)\n+\t(if_then_else (cond (reg:CC CC_REG)\n+\t\t\t    (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"b<CC>   %l0\")\n+\n+;; -------------------------------------------------------------------------\n+;; Call and Jump instructions\n+;; -------------------------------------------------------------------------\n+\n+(define_expand \"call\"\n+  [(call (match_operand:QI 0 \"memory_operand\" \"\")\n+\t\t(match_operand 1 \"general_operand\" \"\"))]\n+  \"\"\n+{\n+  gcc_assert (MEM_P (operands[0]));\n+})\n+\n+(define_insn \"*call\"\n+  [(call (mem:QI (match_operand:SI\n+\t\t  0 \"nonmemory_operand\" \"i,r\"))\n+\t (match_operand 1 \"\" \"\"))]\n+  \"\"\n+  \"@\n+   jsra   %0\n+   jsr    %0\")\n+\n+(define_expand \"call_value\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t\t(call (match_operand:QI 1 \"memory_operand\" \"\")\n+\t\t (match_operand 2 \"\" \"\")))]\n+  \"\"\n+{\n+  gcc_assert (MEM_P (operands[1]));\n+})\n+\n+(define_insn \"*call_value\"\n+  [(set (match_operand 0 \"register_operand\" \"=r\")\n+\t(call (mem:QI (match_operand:SI\n+\t\t       1 \"immediate_operand\" \"i\"))\n+\t      (match_operand 2 \"\" \"\")))]\n+  \"\"\n+  \"jsra   %1\")\n+\n+(define_insn \"*call_value_indirect\"\n+  [(set (match_operand 0 \"register_operand\" \"=r\")\n+\t(call (mem:QI (match_operand:SI\n+\t\t       1 \"register_operand\" \"r\"))\n+\t      (match_operand 2 \"\" \"\")))]\n+  \"\"\n+  \"jsr    %1\")\n+\n+(define_insn \"indirect_jump\"\n+  [(set (pc) (match_operand:SI 0 \"nonimmediate_operand\" \"r\"))]\n+  \"\"\n+  \"jmp    %0\")\n+\n+(define_insn \"jump\"\n+  [(set (pc)\n+\t(label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"jmpa   %l0\")\n+\n+\n+;; -------------------------------------------------------------------------\n+;; Prologue & Epilogue\n+;; -------------------------------------------------------------------------\n+\n+(define_expand \"prologue\"\n+  [(clobber (const_int 0))]\n+  \"\"\n+  \"\n+{\n+  moxie_expand_prologue ();\n+  DONE;\n+}\n+\")\n+\n+(define_expand \"epilogue\"\n+  [(return)]\n+  \"\"\n+  \"\n+{\n+  moxie_expand_epilogue ();\n+  DONE;\n+}\n+\")\n+\n+(define_insn \"returner\"\n+  [(return)]\n+  \"reload_completed\"\n+  \"ret\")"}, {"sha": "f0595c011791c06935c791728b104262a4c9438f", "filename": "gcc/config/moxie/predicates.md", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cceb575c43dd2f2eebd51c31aefeecfac6529675/gcc%2Fconfig%2Fmoxie%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cceb575c43dd2f2eebd51c31aefeecfac6529675/gcc%2Fconfig%2Fmoxie%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmoxie%2Fpredicates.md?ref=cceb575c43dd2f2eebd51c31aefeecfac6529675", "patch": "@@ -0,0 +1,55 @@\n+;; Predicate definitions for Moxie\n+;; Copyright (C) 2009 Free Software Foundation, Inc.\n+;; Contributed by Anthony Green <green@moxielogic.com>\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 3, or (at your\n+;; option) any later version.\n+\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+;; -------------------------------------------------------------------------\n+;; Predicates\n+;; -------------------------------------------------------------------------\n+\n+;; Nonzero if OP can be source of a simple move operation.\n+\n+(define_predicate \"moxie_general_movsrc_operand\"\n+  (match_code \"mem,const_int,reg,subreg,symbol_ref,label_ref,const\")\n+{\n+  /* Any (MEM LABEL_REF) is OK.  That is a pc-relative load.  */\n+  if (MEM_P (op) && GET_CODE (XEXP (op, 0)) == LABEL_REF)\n+    return 1;\n+\n+  if (MEM_P (op)\n+      && GET_CODE (XEXP (op, 0)) == PLUS\n+      && GET_CODE (XEXP (XEXP (op, 0), 0)) == REG\n+      && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST)\n+    return 1;\n+\n+  return general_operand (op, mode);\n+})\n+\n+;; Nonzero if OP can be an operand to an add/inc/dec instruction.\n+\n+(define_predicate \"moxie_add_operand\"\n+  (ior (match_code \"reg\")\n+       (and (match_code \"const_int\")\n+\t    (match_test \"IN_RANGE (INTVAL (op), -255, 255)\"))))\n+\n+;; Nonzero if OP can be an operand to an sub/dec instruction.\n+\n+(define_predicate \"moxie_sub_operand\"\n+  (ior (match_code \"reg\")\n+       (and (match_code \"const_int\")\n+\t    (match_test \"IN_RANGE (INTVAL (op), 0, 255)\"))))\n\\ No newline at end of file"}, {"sha": "57f515e9fc6c180a80d91e067c0ec4977e57fb3b", "filename": "gcc/config/moxie/sfp-machine.h", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cceb575c43dd2f2eebd51c31aefeecfac6529675/gcc%2Fconfig%2Fmoxie%2Fsfp-machine.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cceb575c43dd2f2eebd51c31aefeecfac6529675/gcc%2Fconfig%2Fmoxie%2Fsfp-machine.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmoxie%2Fsfp-machine.h?ref=cceb575c43dd2f2eebd51c31aefeecfac6529675", "patch": "@@ -0,0 +1,52 @@\n+#define _FP_W_TYPE_SIZE\t\t32\n+#define _FP_W_TYPE\t\tunsigned long\n+#define _FP_WS_TYPE\t\tsigned long\n+#define _FP_I_TYPE\t\tlong\n+\n+#define _FP_MUL_MEAT_S(R,X,Y)\t\t\t\t\\\n+  _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S,R,X,Y,umul_ppmm)\n+#define _FP_MUL_MEAT_D(R,X,Y)\t\t\t\t\\\n+  _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D,R,X,Y,umul_ppmm)\n+#define _FP_MUL_MEAT_Q(R,X,Y)\t\t\t\t\\\n+  _FP_MUL_MEAT_4_wide(_FP_WFRACBITS_Q,R,X,Y,umul_ppmm)\n+\n+#define _FP_DIV_MEAT_S(R,X,Y)\t_FP_DIV_MEAT_1_loop(S,R,X,Y)\n+#define _FP_DIV_MEAT_D(R,X,Y)\t_FP_DIV_MEAT_2_udiv(D,R,X,Y)\n+#define _FP_DIV_MEAT_Q(R,X,Y)\t_FP_DIV_MEAT_4_udiv(Q,R,X,Y)\n+\n+#define _FP_NANFRAC_S\t\t((_FP_QNANBIT_S << 1) - 1)\n+#define _FP_NANFRAC_D\t\t((_FP_QNANBIT_D << 1) - 1), -1\n+#define _FP_NANFRAC_Q\t\t((_FP_QNANBIT_Q << 1) - 1), -1, -1, -1\n+#define _FP_NANSIGN_S\t\t0\n+#define _FP_NANSIGN_D\t\t0\n+#define _FP_NANSIGN_Q\t\t0\n+\n+#define _FP_KEEPNANFRACP 1\n+\n+/* Someone please check this.  */\n+#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    if ((_FP_FRAC_HIGH_RAW_##fs(X) & _FP_QNANBIT_##fs)\t\t\\\n+\t&& !(_FP_FRAC_HIGH_RAW_##fs(Y) & _FP_QNANBIT_##fs))\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tR##_s = Y##_s;\t\t\t\t\t\t\\\n+\t_FP_FRAC_COPY_##wc(R,Y);\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tR##_s = X##_s;\t\t\t\t\t\t\\\n+\t_FP_FRAC_COPY_##wc(R,X);\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    R##_c = FP_CLS_NAN;\t\t\t\t\t\t\\\n+  } while (0)\n+\n+#define\t__LITTLE_ENDIAN\t1234\n+#define\t__BIG_ENDIAN\t4321\n+\n+# define __BYTE_ORDER __BIG_ENDIAN\n+\n+/* Define ALIASNAME as a strong alias for NAME.  */\n+# define strong_alias(name, aliasname) _strong_alias(name, aliasname)\n+# define _strong_alias(name, aliasname) \\\n+  extern __typeof (name) aliasname __attribute__ ((alias (#name)));\n+"}, {"sha": "5498ecbb3543bba8407efda0c10788325006685f", "filename": "gcc/config/moxie/t-moxie", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cceb575c43dd2f2eebd51c31aefeecfac6529675/gcc%2Fconfig%2Fmoxie%2Ft-moxie", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cceb575c43dd2f2eebd51c31aefeecfac6529675/gcc%2Fconfig%2Fmoxie%2Ft-moxie", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmoxie%2Ft-moxie?ref=cceb575c43dd2f2eebd51c31aefeecfac6529675", "patch": "@@ -0,0 +1,20 @@\n+# Target Makefile Fragment for moxie\n+# Copyright (C) 2008  Free Software Foundation, Inc.\n+# Contributed by Anthony Green.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published\n+# by the Free Software Foundation; either version 3, or (at your\n+# option) any later version.\n+#\n+# GCC is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+# License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+"}, {"sha": "61c575132e9affe66ed4494eb58c7b3e22becb1d", "filename": "gcc/config/moxie/t-moxie-softfp", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cceb575c43dd2f2eebd51c31aefeecfac6529675/gcc%2Fconfig%2Fmoxie%2Ft-moxie-softfp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cceb575c43dd2f2eebd51c31aefeecfac6529675/gcc%2Fconfig%2Fmoxie%2Ft-moxie-softfp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmoxie%2Ft-moxie-softfp?ref=cceb575c43dd2f2eebd51c31aefeecfac6529675", "patch": "@@ -0,0 +1,9 @@\n+softfp_float_modes := sf df\n+softfp_int_modes := si di\n+softfp_extensions := sfdf\n+softfp_truncations := dfsf\n+softfp_machine_header := moxie/sfp-machine.h\n+softfp_exclude_libgcc2 := y\n+\n+# softfp seems to be missing a whole bunch of prototypes.\n+TARGET_LIBGCC2_CFLAGS += -Wno-missing-prototypes"}, {"sha": "1545bcbcd60d757136c732061af7f157b100ccba", "filename": "gcc/doc/contrib.texi", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cceb575c43dd2f2eebd51c31aefeecfac6529675/gcc%2Fdoc%2Fcontrib.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cceb575c43dd2f2eebd51c31aefeecfac6529675/gcc%2Fdoc%2Fcontrib.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fcontrib.texi?ref=cceb575c43dd2f2eebd51c31aefeecfac6529675", "patch": "@@ -316,7 +316,8 @@ support, improved leaf function register allocation, and his direction\n via the steering committee.\n \n @item\n-Anthony Green for his @option{-Os} contributions and Java front end work.\n+Anthony Green for his @option{-Os} contributions, the moxie port, and\n+Java front end work.\n \n @item\n Stu Grossman for gdb hacking, allowing GCJ developers to debug Java code."}, {"sha": "0804ae3201fdf747a5f7084583cf61b809d16a26", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cceb575c43dd2f2eebd51c31aefeecfac6529675/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cceb575c43dd2f2eebd51c31aefeecfac6529675/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=cceb575c43dd2f2eebd51c31aefeecfac6529675", "patch": "@@ -3759,6 +3759,13 @@ and in order to build GCC for such targets you need to configure with\n See @uref{http://freeware.sgi.com/} for more\n information about using GCC on IRIX platforms.\n \n+@html\n+<hr />\n+@end html\n+@heading @anchor{moxie-x-elf}moxie-*-elf\n+The moxie processor.  See @uref{http://moxielogic.org/} for more\n+information about this processor.\n+\n @html\n <hr />\n @end html"}, {"sha": "065529fdf038b91709fcc4c900760f9fc5109216", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cceb575c43dd2f2eebd51c31aefeecfac6529675/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cceb575c43dd2f2eebd51c31aefeecfac6529675/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=cceb575c43dd2f2eebd51c31aefeecfac6529675", "patch": "@@ -2730,6 +2730,25 @@ Constants in the range @minus{}8 to 2\n \n @end table\n \n+@item Moxie---@file{config/moxie/constraints.md}\n+@table @code\n+@item A\n+An absolute address\n+\n+@item B\n+An offset address\n+\n+@item W\n+A register indirect memory operand\n+\n+@item I\n+A constant in the range of 0 to 255.\n+\n+@item N\n+A constant in the range of 0 to -255.\n+\n+@end table\n+\n @need 1000\n @item SPARC---@file{config/sparc/sparc.h}\n @table @code"}, {"sha": "d23e58e60097e640cf79cc28d818bbd902d71f30", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cceb575c43dd2f2eebd51c31aefeecfac6529675/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cceb575c43dd2f2eebd51c31aefeecfac6529675/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cceb575c43dd2f2eebd51c31aefeecfac6529675", "patch": "@@ -1,3 +1,8 @@\n+2009-06-10  Anthony Green  <green@moxielogic.com>\n+\n+\t* testsuite/lib/target-supports.exp (check_profiling_available):\n+\tProfiling is not available for testing purposes on moxie.\n+\n 2009-06-09  Ian Lance Taylor  <iant@google.com>\n \n \t* gcc.dg/Wcxx-compat-12.c: New testcase."}, {"sha": "24d814894095b6853175d8d315a03d1a719f997b", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cceb575c43dd2f2eebd51c31aefeecfac6529675/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cceb575c43dd2f2eebd51c31aefeecfac6529675/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=cceb575c43dd2f2eebd51c31aefeecfac6529675", "patch": "@@ -499,6 +499,7 @@ proc check_profiling_available { test_what } {\n \t     || [istarget m68k-*-elf]\n \t     || [istarget m68k-*-uclinux*]\n \t     || [istarget mips*-*-elf*]\n+\t     || [istarget moxie-*-elf*]\n \t     || [istarget xstormy16-*]\n \t     || [istarget xtensa*-*-elf]\n \t     || [istarget *-*-rtems*]"}, {"sha": "48053b36a7bf0c6e58315b1df07ea2ff125164e4", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cceb575c43dd2f2eebd51c31aefeecfac6529675/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cceb575c43dd2f2eebd51c31aefeecfac6529675/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=cceb575c43dd2f2eebd51c31aefeecfac6529675", "patch": "@@ -1,3 +1,8 @@\n+2009-05-31  Anthony Green  <green@moxielogic.com>\n+\n+\t* config.host: Add moxie support.\n+\t* config/moxie/t-moxie: New file.\n+\n 2009-05-29  David Billinghurst <billingd@gcc.gnu.org>\n \n \t* config.host: Add i386/${host_address}/t-fprules-softfp and"}, {"sha": "cdb274e4216acaa6d4e891883f4f30c27caac2c2", "filename": "libgcc/config.host", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cceb575c43dd2f2eebd51c31aefeecfac6529675/libgcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cceb575c43dd2f2eebd51c31aefeecfac6529675/libgcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig.host?ref=cceb575c43dd2f2eebd51c31aefeecfac6529675", "patch": "@@ -84,6 +84,8 @@ fido-*-*)\n \t;;\n frv*)\tcpu_type=frv\n \t;;\n+moxie*)\tcpu_type=moxie\n+\t;;\n i[34567]86-*-*)\n \tcpu_type=i386\n \t;;\n@@ -415,6 +417,10 @@ mmix-knuth-mmixware)\n \t;;\n mn10300-*-*)\n \t;;\n+moxie-*-*)\n+\ttmake_file=${cpu_type}/t-moxie\n+\textra_parts=\"crtbegin.o crtend.o crti.o crtn.o\"\n+\t;;\n pdp11-*-*)\n \t;;\n picochip-*-*)"}]}