{"sha": "f379eac3fa35f6f4c35940b543fd67fe22a16a54", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjM3OWVhYzNmYTM1ZjZmNGMzNTk0MGI1NDNmZDY3ZmUyMmExNmE1NA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-08-22T01:56:34Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-08-22T01:56:34Z"}, "message": "Makefile.in (fibheap.o): Depend on config.h.\n\n        * Makefile.in (fibheap.o): Depend on config.h.\n        * fibheap.c: Tidy formatting.  Use config.h.` Rearrange some\n        functions for inlining.\n\nFrom-SVN: r45089", "tree": {"sha": "b93b40ad16af1680b63ced9d5bc34c787134d0bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b93b40ad16af1680b63ced9d5bc34c787134d0bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f379eac3fa35f6f4c35940b543fd67fe22a16a54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f379eac3fa35f6f4c35940b543fd67fe22a16a54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f379eac3fa35f6f4c35940b543fd67fe22a16a54", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f379eac3fa35f6f4c35940b543fd67fe22a16a54/comments", "author": null, "committer": null, "parents": [{"sha": "d7a0e799d357c10f8fb0312c34b9176c026ca7d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7a0e799d357c10f8fb0312c34b9176c026ca7d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7a0e799d357c10f8fb0312c34b9176c026ca7d9"}], "stats": {"total": 262, "additions": 137, "deletions": 125}, "files": [{"sha": "0eaa8fe49093e3a9611dc9f4d2c35e2929c94231", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f379eac3fa35f6f4c35940b543fd67fe22a16a54/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f379eac3fa35f6f4c35940b543fd67fe22a16a54/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=f379eac3fa35f6f4c35940b543fd67fe22a16a54", "patch": "@@ -1,3 +1,9 @@\n+2001-08-21  Richard Henderson  <rth@redhat.com>\n+\n+\t* Makefile.in (fibheap.o): Depend on config.h.\n+\t* fibheap.c: Tidy formatting.  Use config.h.` Rearrange some\n+\tfunctions for inlining.\n+\n Tue Aug 21 12:35:04 2001  Christopher Faylor <cgf@cygnus.com>\n \n \t* configure.in: Need to set HAVE_SYS_ERRLIST and HAVE_SYS_NERR whenever"}, {"sha": "5786f99e022329a9d6149708a455cc6d0140231c", "filename": "libiberty/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f379eac3fa35f6f4c35940b543fd67fe22a16a54/libiberty%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f379eac3fa35f6f4c35940b543fd67fe22a16a54/libiberty%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FMakefile.in?ref=f379eac3fa35f6f4c35940b543fd67fe22a16a54", "patch": "@@ -265,7 +265,7 @@ cplus-dem.o: config.h $(INCDIR)/demangle.h\n cp-demangle.o: config.h $(INCDIR)/dyn-string.h $(INCDIR)/demangle.h\n dyn-string.o: config.h $(INCDIR)/dyn-string.h\n fdmatch.o: $(INCDIR)/libiberty.h\n-fibheap.o: $(INCDIR)/libiberty.h $(INCDIR)/fibheap.h\n+fibheap.o: config.h $(INCDIR)/libiberty.h $(INCDIR)/fibheap.h\n fnmatch.o: config.h $(INCDIR)/fnmatch.h\n getcwd.o: config.h\n getopt.o: config.h $(INCDIR)/getopt.h"}, {"sha": "7431e11a6c4ab5be26a7d2c82f3b6823fc95e5c3", "filename": "libiberty/fibheap.c", "status": "modified", "additions": 130, "deletions": 124, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f379eac3fa35f6f4c35940b543fd67fe22a16a54/libiberty%2Ffibheap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f379eac3fa35f6f4c35940b543fd67fe22a16a54/libiberty%2Ffibheap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ffibheap.c?ref=f379eac3fa35f6f4c35940b543fd67fe22a16a54", "patch": "@@ -1,4 +1,3 @@\n-\n /* A Fibonacci heap datatype.\n    Copyright 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n    Contributed by Daniel Berlin (dan@cgsoftware.com).\n@@ -20,13 +19,24 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-/* Fibonacci heaps */\n+#ifdef HAVE_CONFIG_H\n+#include \"config.h\"\n+#endif\n+#ifdef HAVE_LIMITS_H\n #include <limits.h>\n+#endif\n+#ifdef HAVE_STDLIB_H\n #include <stdlib.h>\n+#endif\n+#ifdef HAVE_STRING_H\n+#include <string.h>\n+#endif\n #include \"libiberty.h\"\n #include \"fibheap.h\"\n \n \n+#define FIBHEAPKEY_MIN\tLONG_MIN\n+\n static void fibheap_init PARAMS ((fibheap_t));\n static void fibheap_ins_root PARAMS ((fibheap_t, fibnode_t));\n static void fibheap_rem_root PARAMS ((fibheap_t, fibnode_t));\n@@ -36,13 +46,25 @@ static void fibheap_cut PARAMS ((fibheap_t, fibnode_t, fibnode_t));\n static void fibheap_cascading_cut PARAMS ((fibheap_t, fibnode_t));\n static fibnode_t fibheap_extr_min_node PARAMS ((fibheap_t));\n static int fibheap_compare PARAMS ((fibheap_t, fibnode_t, fibnode_t));\n-static int fibheap_comp_data PARAMS ((fibheap_t, fibheapkey_t, void *, fibnode_t));\n+static int fibheap_comp_data PARAMS ((fibheap_t, fibheapkey_t, void *,\n+\t\t\t\t      fibnode_t));\n static fibnode_t fibnode_new PARAMS ((void));\n static void fibnode_init PARAMS ((fibnode_t));\n static void fibnode_insert_after PARAMS ((fibnode_t, fibnode_t));\n #define fibnode_insert_before(a, b) fibnode_insert_after (a->left, b)\n static fibnode_t fibnode_remove PARAMS ((fibnode_t));\n \n+\f\n+/* Initialize the passed in fibonacci heap.  */\n+static inline void\n+fibheap_init (heap)\n+     fibheap_t heap;\n+{\n+  heap->nodes = 0;\n+  heap->min = NULL;\n+  heap->root = NULL;\n+}\n+\n /* Create a new fibonacci heap.  */\n fibheap_t\n fibheap_new ()\n@@ -57,14 +79,60 @@ fibheap_new ()\n   return result;\n }\n \n-/* Initialize the passed in fibonacci heap.  */\n-static void\n-fibheap_init (heap)\n+/* Initialize the passed in fibonacci heap node.  */\n+static inline void\n+fibnode_init (node)\n+     fibnode_t node;\n+{\n+  node->degree = 0;\n+  node->mark = 0;\n+  node->parent = NULL;\n+  node->child = NULL;\n+  node->left = node;\n+  node->right = node;\n+  node->data = NULL;\n+}\n+\n+/* Create a new fibonacci heap node.  */\n+static inline fibnode_t\n+fibnode_new ()\n+{\n+  fibnode_t e;\n+\n+  if ((e = xmalloc (sizeof *e)) == NULL)\n+    return NULL;\n+\n+  fibnode_init (e);\n+\n+  return e;\n+}\n+\n+static inline int\n+fibheap_compare (heap, a, b)\n+     fibheap_t heap ATTRIBUTE_UNUSED;\n+     fibnode_t a;\n+     fibnode_t b;\n+{\n+  if (a->key < b->key)\n+    return -1;\n+  if (a->key > b->key)\n+    return 1;\n+  return 0;\n+}\n+\n+static inline int\n+fibheap_comp_data (heap, key, data, b)\n      fibheap_t heap;\n+     fibheapkey_t key;\n+     void *data;\n+     fibnode_t b;\n {\n-  heap->nodes = 0;\n-  heap->min = NULL;\n-  heap->root = NULL;\n+  struct fibnode a;\n+\n+  a.key = key;\n+  a.data = data;\n+\n+  return fibheap_compare (heap, &a, b);\n }\n \n /* Insert DATA, with priority KEY, into HEAP.  */\n@@ -75,18 +143,20 @@ fibheap_insert (heap, key, data)\n      void *data;\n {\n   fibnode_t node;\n+\n   /* Create the new node, if we fail, return NULL.  */\n   if ((node = fibnode_new ()) == NULL)\n     return NULL;\n+\n   /* Set the node's data.  */\n   node->data = data;\n   node->key = key;\n \n   /* Insert it into the root list.  */\n   fibheap_ins_root (heap, node);\n \n-  /* If their was no minimum, or this key is less than the min, it's the new\n-     min.  */\n+  /* If their was no minimum, or this key is less than the min,\n+     it's the new min.  */\n   if (heap->min == NULL || node->key < heap->min->key)\n     heap->min = node;\n \n@@ -123,28 +193,26 @@ fibheap_union (heapa, heapb)\n      fibheap_t heapa;\n      fibheap_t heapb;\n {\n-  fibnode_t temp;\n+  fibnode_t a_root, b_root, temp;\n \n   /* If one of the heaps is empty, the union is just the other heap.  */\n-  if (heapa->root == NULL || heapb->root == NULL)\n+  if ((a_root = heapa->root) == NULL)\n     {\n-      if (heapa->root == NULL)\n-\t{\n-\t  free (heapa);\n-\t  return heapb;\n-\t}\n-      else\n-\t{\n-\t  free (heapb);\n-\t  return heapa;\n-\t}\n+      free (heapa);\n+      return heapb;\n+    }\n+  if ((b_root = heapb->root) == NULL)\n+    {\n+      free (heapb);\n+      return heapa;\n     }\n+\n   /* Merge them to the next nodes on the opposite chain.  */\n-  heapa->root->left->right = heapb->root;\n-  heapb->root->left->right = heapa->root;\n-  temp = heapa->root->left;\n-  heapa->root->left = heapb->root->left;\n-  heapb->root->left = temp;\n+  a_root->left->right = b_root;\n+  b_root->left->right = a_root;\n+  temp = a_root->left;\n+  a_root->left = b_root->left;\n+  b_root->left = temp;\n   heapa->nodes += heapb->nodes;\n \n   /* And set the new minimum, if it's changed.  */\n@@ -161,9 +229,8 @@ fibheap_extract_min (heap)\n      fibheap_t heap;\n {\n   fibnode_t z;\n-  void *ret;\n+  void *ret = NULL;\n \n-  ret = NULL;\n   /* If we don't have a min set, it means we have no nodes.  */\n   if (heap->min != NULL)\n     {\n@@ -177,31 +244,6 @@ fibheap_extract_min (heap)\n   return ret;\n }\n \n-/* Replace the DATA associated with NODE.  */\n-void *\n-fibheap_replace_data (heap, node, data)\n-     fibheap_t heap;\n-     fibnode_t node;\n-     void *data;\n-{\n-  return fibheap_replace_key_data (heap, node, node->key, data);\n-}\n-\n-/* Replace the KEY associated with NODE.  */\n-fibheapkey_t\n-fibheap_replace_key (heap, node, key)\n-     fibheap_t heap;\n-     fibnode_t node;\n-     fibheapkey_t key;\n-{\n-  int ret;\n-\n-  ret = node->key;\n-  (void) fibheap_replace_key_data (heap, node, key, node->data);\n-\n-  return ret;\n-}\n-\n /* Replace both the KEY and the DATA associated with NODE.  */\n void *\n fibheap_replace_key_data (heap, node, key, data)\n@@ -244,19 +286,41 @@ fibheap_replace_key_data (heap, node, key, data)\n   return odata;\n }\n \n+/* Replace the DATA associated with NODE.  */\n+void *\n+fibheap_replace_data (heap, node, data)\n+     fibheap_t heap;\n+     fibnode_t node;\n+     void *data;\n+{\n+  return fibheap_replace_key_data (heap, node, node->key, data);\n+}\n+\n+/* Replace the KEY associated with NODE.  */\n+fibheapkey_t\n+fibheap_replace_key (heap, node, key)\n+     fibheap_t heap;\n+     fibnode_t node;\n+     fibheapkey_t key;\n+{\n+  int okey = node->key;\n+  fibheap_replace_key_data (heap, node, key, node->data);\n+  return okey;\n+}\n+\n /* Delete NODE from HEAP.  */\n void *\n fibheap_delete_node (heap, node)\n      fibheap_t heap;\n      fibnode_t node;\n {\n-  void *k;\n+  void *ret = node->data;\n+\n   /* To perform delete, we just make it the min key, and extract.  */\n-  k = node->data;\n-  fibheap_replace_key (heap, node, LONG_MIN);\n+  fibheap_replace_key (heap, node, FIBHEAPKEY_MIN);\n   fibheap_extract_min (heap);\n \n-  return k;\n+  return ret;\n }\n \n /* Delete HEAP.  */\n@@ -278,32 +342,29 @@ fibheap_empty (heap)\n   return heap->nodes == 0;\n }\n \n-\n /* Extract the minimum node of the heap.  */\n static fibnode_t\n fibheap_extr_min_node (heap)\n      fibheap_t heap;\n {\n-  fibnode_t ret;\n+  fibnode_t ret = heap->min;\n   fibnode_t x, y, orig;\n \n-  ret = heap->min;\n-\n-  orig = NULL;\n   /* Attach the child list of the minimum node to the root list of the heap.\n      If there is no child list, we don't do squat.  */\n-  for (x = ret->child; x != orig && x != NULL;)\n+  for (x = ret->child, orig = NULL; x != orig && x != NULL; x = y)\n     {\n       if (orig == NULL)\n \torig = x;\n       y = x->right;\n       x->parent = NULL;\n       fibheap_ins_root (heap, x);\n-      x = y;\n     }\n+\n   /* Remove the old root.  */\n   fibheap_rem_root (heap, ret);\n   heap->nodes--;\n+\n   /* If we are left with no nodes, then the min is NULL.  */\n   if (heap->nodes == 0)\n     heap->min = NULL;\n@@ -333,8 +394,9 @@ fibheap_ins_root (heap, node)\n       node->right = node;\n       return;\n     }\n-  /* Otherwise, insert it in the circular root list between the root and it's \n-     right node.  */\n+\n+  /* Otherwise, insert it in the circular root list between the root\n+     and it's right node.  */\n   fibnode_insert_after (heap->root, node);\n }\n \n@@ -450,33 +512,6 @@ fibheap_cascading_cut (heap, y)\n     }\n }\n \n-\n-static fibnode_t\n-fibnode_new ()\n-{\n-  fibnode_t e;\n-\n-  if ((e = xmalloc (sizeof *e)) == NULL)\n-    return NULL;\n-\n-  fibnode_init (e);\n-\n-  return e;\n-}\n-\n-static void\n-fibnode_init (node)\n-     fibnode_t node;\n-{\n-  node->degree = 0;\n-  node->mark = 0;\n-  node->parent = NULL;\n-  node->child = NULL;\n-  node->left = node;\n-  node->right = node;\n-  node->data = NULL;\n-}\n-\n static void\n fibnode_insert_after (a, b)\n      fibnode_t a;\n@@ -498,7 +533,6 @@ fibnode_insert_after (a, b)\n     }\n }\n \n-\n static fibnode_t\n fibnode_remove (node)\n      fibnode_t node;\n@@ -522,31 +556,3 @@ fibnode_remove (node)\n \n   return ret;\n }\n-\n-static int\n-fibheap_compare (heap, a, b)\n-     fibheap_t heap ATTRIBUTE_UNUSED;\n-     fibnode_t a;\n-     fibnode_t b;\n-{\n-  if (a->key < b->key)\n-    return -1;\n-  if (a->key > b->key)\n-    return 1;\n-  return 0;\n-}\n-\n-static int\n-fibheap_comp_data (heap, key, data, b)\n-     fibheap_t heap;\n-     fibheapkey_t key;\n-     void *data;\n-     fibnode_t b;\n-{\n-  struct fibnode a;\n-\n-  a.key = key;\n-  a.data = data;\n-\n-  return fibheap_compare (heap, &a, b);\n-}"}]}