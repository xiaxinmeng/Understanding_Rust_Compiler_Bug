{"sha": "fe86867f07504f643ab9bf1147bac785222cadb0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmU4Njg2N2YwNzUwNGY2NDNhYjliZjExNDdiYWM3ODUyMjJjYWRiMA==", "commit": {"author": {"name": "Bernd Edlinger", "email": "bernd.edlinger@hotmail.de", "date": "2015-01-02T22:16:59Z"}, "committer": {"name": "Bernd Edlinger", "email": "edlinger@gcc.gnu.org", "date": "2015-01-02T22:16:59Z"}, "message": "Instrument bit field and unaligned accesses for TSAN.\n\ngcc/ChangeLog:\n2015-01-02  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n\n        Instrument bit field and unaligned accesses for TSAN.\n        * sanitizer.def (BUILT_IN_TSAN_READ_RANGE): New built-in function.\n        (BUILT_IN_TSAN_WRITE_RANGE): New built-in function.\n        * tsan.c (instrument_expr): Handle COMPONENT_REF and BIT_FIELD_REF.\n        Use BUILT_IN_TSAN_READ_RANGE and BUILT_IN_TSAN_WRITE_RANGE for\n        unaligned memory regions.\n\ntestsuite/ChangeLog:\n2015-01-02  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n\n        * c-c++-common/tsan/bitfield_race.c: New testcase.\n        * g++.dg/tsan/aligned_vs_unaligned_race.C: Fixed.\n\nFrom-SVN: r219150", "tree": {"sha": "2e150e026804c390ac9333406e3d7552c6a62711", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e150e026804c390ac9333406e3d7552c6a62711"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe86867f07504f643ab9bf1147bac785222cadb0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe86867f07504f643ab9bf1147bac785222cadb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe86867f07504f643ab9bf1147bac785222cadb0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe86867f07504f643ab9bf1147bac785222cadb0/comments", "author": {"login": "bernd-edlinger", "id": 17638929, "node_id": "MDQ6VXNlcjE3NjM4OTI5", "avatar_url": "https://avatars.githubusercontent.com/u/17638929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bernd-edlinger", "html_url": "https://github.com/bernd-edlinger", "followers_url": "https://api.github.com/users/bernd-edlinger/followers", "following_url": "https://api.github.com/users/bernd-edlinger/following{/other_user}", "gists_url": "https://api.github.com/users/bernd-edlinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/bernd-edlinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bernd-edlinger/subscriptions", "organizations_url": "https://api.github.com/users/bernd-edlinger/orgs", "repos_url": "https://api.github.com/users/bernd-edlinger/repos", "events_url": "https://api.github.com/users/bernd-edlinger/events{/privacy}", "received_events_url": "https://api.github.com/users/bernd-edlinger/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e4dd5b691d56f11c225e1e1847be3800854634b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4dd5b691d56f11c225e1e1847be3800854634b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4dd5b691d56f11c225e1e1847be3800854634b6"}], "stats": {"total": 136, "additions": 122, "deletions": 14}, "files": [{"sha": "3957600745c5c432b1bc3ac6afa93659877a58bb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe86867f07504f643ab9bf1147bac785222cadb0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe86867f07504f643ab9bf1147bac785222cadb0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fe86867f07504f643ab9bf1147bac785222cadb0", "patch": "@@ -1,3 +1,12 @@\n+2015-01-02  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n+\n+\tInstrument bit field and unaligned accesses for TSAN.\n+\t* sanitizer.def (BUILT_IN_TSAN_READ_RANGE): New built-in function.\n+\t(BUILT_IN_TSAN_WRITE_RANGE): New built-in function.\n+\t* tsan.c (instrument_expr): Handle COMPONENT_REF and BIT_FIELD_REF.\n+\tUse BUILT_IN_TSAN_READ_RANGE and BUILT_IN_TSAN_WRITE_RANGE for\n+\tunaligned memory regions.\n+\n 2015-01-01  Anthony Green  <green@moxielogic.com>\n \n \t* config/moxie/predicates.md (moxie_general_movsrc_operand):"}, {"sha": "723348e9e1aaab90877e78b0d1eabbe1628a0e9a", "filename": "gcc/sanitizer.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe86867f07504f643ab9bf1147bac785222cadb0/gcc%2Fsanitizer.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe86867f07504f643ab9bf1147bac785222cadb0/gcc%2Fsanitizer.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsanitizer.def?ref=fe86867f07504f643ab9bf1147bac785222cadb0", "patch": "@@ -188,6 +188,10 @@ DEF_SANITIZER_BUILTIN(BUILT_IN_TSAN_WRITE8, \"__tsan_write8\",\n \t\t      BT_FN_VOID_PTR, ATTR_NOTHROW_LEAF_LIST)\n DEF_SANITIZER_BUILTIN(BUILT_IN_TSAN_WRITE16, \"__tsan_write16\",\n \t\t      BT_FN_VOID_PTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_TSAN_READ_RANGE, \"__tsan_read_range\",\n+\t\t      BT_FN_VOID_PTR_PTRMODE, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_TSAN_WRITE_RANGE, \"__tsan_write_range\",\n+\t\t      BT_FN_VOID_PTR_PTRMODE, ATTR_NOTHROW_LEAF_LIST)\n \n DEF_SANITIZER_BUILTIN(BUILT_IN_TSAN_ATOMIC8_LOAD,\n \t\t      \"__tsan_atomic8_load\","}, {"sha": "cb1ba6834d0c8870ded03d08572c79f3d8e1ea54", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe86867f07504f643ab9bf1147bac785222cadb0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe86867f07504f643ab9bf1147bac785222cadb0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fe86867f07504f643ab9bf1147bac785222cadb0", "patch": "@@ -1,3 +1,8 @@\n+2015-01-02  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n+\n+\t* c-c++-common/tsan/bitfield_race.c: New testcase.\n+\t* g++.dg/tsan/aligned_vs_unaligned_race.C: Fixed.\n+\n 2015-01-02  Tobias Burnus  <burnus@net-b.de>\n \n \t* gfortran.dg/coarray/collectives_4.f90: New."}, {"sha": "e8de09727a93995ceef22117aca3610831f9e912", "filename": "gcc/testsuite/c-c++-common/tsan/bitfield_race.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe86867f07504f643ab9bf1147bac785222cadb0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftsan%2Fbitfield_race.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe86867f07504f643ab9bf1147bac785222cadb0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftsan%2Fbitfield_race.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftsan%2Fbitfield_race.c?ref=fe86867f07504f643ab9bf1147bac785222cadb0", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-shouldfail \"tsan\" } */\n+\n+#include <pthread.h>\n+#include <unistd.h>\n+\n+struct bitfield\n+{\n+  int a:10;\n+  int b:10;\n+} Global;\n+\n+void *Thread1(void *x) {\n+  sleep(1);\n+  Global.a = 42;\n+  return x;\n+}\n+\n+int main() {\n+  pthread_t t;\n+  pthread_create(&t, 0, Thread1, 0);\n+  Global.b = 43;\n+  pthread_join(t, 0);\n+  return Global.a;\n+}\n+\n+/* { dg-output \"WARNING: ThreadSanitizer: data race.*(\\n|\\r\\n|\\r)\" } */"}, {"sha": "e547e0ce2d2d9169f42335515df7811e3c8364d0", "filename": "gcc/testsuite/g++.dg/tsan/aligned_vs_unaligned_race.C", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe86867f07504f643ab9bf1147bac785222cadb0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftsan%2Faligned_vs_unaligned_race.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe86867f07504f643ab9bf1147bac785222cadb0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftsan%2Faligned_vs_unaligned_race.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftsan%2Faligned_vs_unaligned_race.C?ref=fe86867f07504f643ab9bf1147bac785222cadb0", "patch": "@@ -1,3 +1,4 @@\n+/* { dg-shouldfail \"tsan\" } */\n #include <pthread.h>\n #include <stdio.h>\n #include <stdint.h>\n@@ -11,8 +12,9 @@ void *Thread1(void *x) {\n \n void *Thread2(void *x) {\n   char *p1 = reinterpret_cast<char *>(&Global[0]);\n-  uint64_t *p4 = reinterpret_cast<uint64_t *>(p1 + 1);\n-  (*p4)++;\n+  struct __attribute__((packed, aligned(1))) u_uint64_t { uint64_t val; };\n+  u_uint64_t *p4 = reinterpret_cast<u_uint64_t *>(p1 + 1);\n+  (*p4).val++;\n   return NULL;\n }\n \n@@ -23,7 +25,7 @@ int main() {\n   pthread_join(t[0], NULL);\n   pthread_join(t[1], NULL);\n   printf(\"Pass\\n\");\n-  /* { dg-prune-output \"ThreadSanitizer: data race.*(\\n|\\r\\n|\\r)\" } */\n+  /* { dg-output \"WARNING: ThreadSanitizer: data race.*(\\n|\\r\\n|\\r)\" } */\n   /* { dg-output \"Pass.*\" } */\n   return 0;\n }"}, {"sha": "7992a449508c5e7a99bfd2943db5166fe220f0c7", "filename": "gcc/tsan.c", "status": "modified", "additions": 73, "deletions": 11, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe86867f07504f643ab9bf1147bac785222cadb0/gcc%2Ftsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe86867f07504f643ab9bf1147bac785222cadb0/gcc%2Ftsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftsan.c?ref=fe86867f07504f643ab9bf1147bac785222cadb0", "patch": "@@ -62,6 +62,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa-propagate.h\"\n #include \"tsan.h\"\n #include \"asan.h\"\n+#include \"builtins.h\"\n \n /* Number of instrumented memory accesses in the current function.  */\n \n@@ -121,13 +122,12 @@ instrument_expr (gimple_stmt_iterator gsi, tree expr, bool is_write)\n   gimple stmt, g;\n   gimple_seq seq;\n   location_t loc;\n+  unsigned int align;\n \n   size = int_size_in_bytes (TREE_TYPE (expr));\n-  if (size == -1)\n+  if (size <= 0)\n     return false;\n \n-  /* For now just avoid instrumenting bit field acceses.\n-     TODO: handle bit-fields as if touching the whole field.  */\n   HOST_WIDE_INT bitsize, bitpos;\n   tree offset;\n   machine_mode mode;\n@@ -155,25 +155,87 @@ instrument_expr (gimple_stmt_iterator gsi, tree expr, bool is_write)\n \t  && DECL_HARD_REGISTER (base)))\n     return false;\n \n-  if (size == 0\n-      || bitpos % (size * BITS_PER_UNIT)\n-      || bitsize != size * BITS_PER_UNIT)\n-    return false;\n-\n   stmt = gsi_stmt (gsi);\n   loc = gimple_location (stmt);\n   rhs = is_vptr_store (stmt, expr, is_write);\n-  gcc_checking_assert (rhs != NULL || is_gimple_addressable (expr));\n-  expr_ptr = build_fold_addr_expr (unshare_expr (expr));\n   seq = NULL;\n+\n+  if ((TREE_CODE (expr) == COMPONENT_REF\n+       && DECL_BIT_FIELD_TYPE (TREE_OPERAND (expr, 1)))\n+      || TREE_CODE (expr) == BIT_FIELD_REF)\n+    {\n+      base = TREE_OPERAND (expr, 0);\n+      if (TREE_CODE (expr) == COMPONENT_REF)\n+\t{\n+\t  expr = TREE_OPERAND (expr, 1);\n+\t  if (is_write && DECL_BIT_FIELD_REPRESENTATIVE (expr))\n+\t    expr = DECL_BIT_FIELD_REPRESENTATIVE (expr);\n+\t  if (!tree_fits_uhwi_p (DECL_FIELD_OFFSET (expr))\n+\t      || !tree_fits_uhwi_p (DECL_FIELD_BIT_OFFSET (expr))\n+\t      || !tree_fits_uhwi_p (DECL_SIZE (expr)))\n+\t    return false;\n+\t  bitpos = tree_to_uhwi (DECL_FIELD_OFFSET (expr)) * BITS_PER_UNIT\n+\t\t   + tree_to_uhwi (DECL_FIELD_BIT_OFFSET (expr));\n+\t  bitsize = tree_to_uhwi (DECL_SIZE (expr));\n+\t}\n+      else\n+\t{\n+\t  if (!tree_fits_uhwi_p (TREE_OPERAND (expr, 2))\n+\t      || !tree_fits_uhwi_p (TREE_OPERAND (expr, 1)))\n+\t    return false;\n+\t  bitpos = tree_to_uhwi (TREE_OPERAND (expr, 2));\n+\t  bitsize = tree_to_uhwi (TREE_OPERAND (expr, 1));\n+\t}\n+      if (bitpos < 0 || bitsize <= 0)\n+\treturn false;\n+      size = (bitpos % BITS_PER_UNIT + bitsize + BITS_PER_UNIT - 1)\n+\t     / BITS_PER_UNIT;\n+      align = get_object_alignment (base);\n+      if (align < BITS_PER_UNIT)\n+\treturn false;\n+      bitpos = bitpos & ~(BITS_PER_UNIT - 1);\n+      if ((align - 1) & bitpos)\n+\t{\n+\t  align = (align - 1) & bitpos;\n+\t  align = align & -align;\n+\t}\n+      gcc_checking_assert (is_gimple_addressable (base));\n+      expr = build_fold_addr_expr (unshare_expr (base));\n+      if (!is_gimple_mem_ref_addr (expr))\n+\t{\n+\t  g = gimple_build_assign (make_ssa_name (TREE_TYPE (expr)), expr);\n+\t  expr = gimple_assign_lhs (g);\n+\t  gimple_set_location (g, loc);\n+\t  gimple_seq_add_stmt_without_update (&seq, g);\n+\t}\n+      expr = build2 (MEM_REF, char_type_node, expr,\n+\t\t     build_int_cst (TREE_TYPE (expr), bitpos / BITS_PER_UNIT));\n+      expr_ptr = build_fold_addr_expr (expr);\n+    }\n+  else\n+    {\n+      align = get_object_alignment (expr);\n+      if (align < BITS_PER_UNIT)\n+\treturn false;\n+      gcc_checking_assert (is_gimple_addressable (expr));\n+      expr_ptr = build_fold_addr_expr (unshare_expr (expr));\n+    }\n   if (!is_gimple_val (expr_ptr))\n     {\n       g = gimple_build_assign (make_ssa_name (TREE_TYPE (expr_ptr)), expr_ptr);\n       expr_ptr = gimple_assign_lhs (g);\n       gimple_set_location (g, loc);\n       gimple_seq_add_stmt_without_update (&seq, g);\n     }\n-  if (rhs == NULL)\n+  if ((size & (size - 1)) == 0 || size > 16\n+      || align < MIN (size, 8) * BITS_PER_UNIT)\n+    {\n+      builtin_decl = builtin_decl_implicit (is_write\n+\t\t\t\t\t    ? BUILT_IN_TSAN_WRITE_RANGE\n+\t\t\t\t\t    : BUILT_IN_TSAN_READ_RANGE);\n+      g = gimple_build_call (builtin_decl, 2, expr_ptr, size_int (size));\n+    }\n+  else if (rhs == NULL)\n     g = gimple_build_call (get_memory_access_decl (is_write, size),\n \t\t\t   1, expr_ptr);\n   else"}]}