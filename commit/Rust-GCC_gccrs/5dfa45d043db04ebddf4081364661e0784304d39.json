{"sha": "5dfa45d043db04ebddf4081364661e0784304d39", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWRmYTQ1ZDA0M2RiMDRlYmRkZjQwODEzNjQ2NjFlMDc4NDMwNGQzOQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2003-07-28T15:42:24Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2003-07-28T15:42:24Z"}, "message": "configure.in (--enable-checking): Add fold category.\n\n\t* configure.in (--enable-checking): Add fold category.\n\t(ENABLE_FOLD_CHECKING): Define if requested.\n\t* configure: Rebuilt.\n\t* config.in: Rebuilt.\n\t* doc/install.texi: Document it.\n\t* fold-const.c: Include md5.h.\n\t[ENABLE_FOLD_CHECKING] (fold): Define to fold_1.\n\t[ENABLE_FOLD_CHECKING] (fold, fold_checksum_tree, fold_check_failed,\n\tprint_fold_checksum): New functions.\n\n\t* fold-const.c (fold): Never modify argument passed to fold, instead\n\tchange a copy and return it.\n\t* convert.c (convert_to_integer): Likewise.\ntestsuite/\n\t* gcc.c-torture/compile/20030725-1.c: New test.\n\nFrom-SVN: r69886", "tree": {"sha": "171abb9dcfe266e6906e8910ab7d2a2a3a72cce0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/171abb9dcfe266e6906e8910ab7d2a2a3a72cce0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5dfa45d043db04ebddf4081364661e0784304d39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5dfa45d043db04ebddf4081364661e0784304d39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5dfa45d043db04ebddf4081364661e0784304d39", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5dfa45d043db04ebddf4081364661e0784304d39/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "66584e64179362cd8d96b676ea793e9fee38788d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66584e64179362cd8d96b676ea793e9fee38788d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66584e64179362cd8d96b676ea793e9fee38788d"}], "stats": {"total": 304, "additions": 292, "deletions": 12}, "files": [{"sha": "1bdd3fc1e94032d122689e43d7809f5b74a25077", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dfa45d043db04ebddf4081364661e0784304d39/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dfa45d043db04ebddf4081364661e0784304d39/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5dfa45d043db04ebddf4081364661e0784304d39", "patch": "@@ -1,3 +1,19 @@\n+2003-07-28  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* configure.in (--enable-checking): Add fold category.\n+\t(ENABLE_FOLD_CHECKING): Define if requested.\n+\t* configure: Rebuilt.\n+\t* config.in: Rebuilt.\n+\t* doc/install.texi: Document it.\n+\t* fold-const.c: Include md5.h.\n+\t[ENABLE_FOLD_CHECKING] (fold): Define to fold_1.\n+\t[ENABLE_FOLD_CHECKING] (fold, fold_checksum_tree, fold_check_failed,\n+\tprint_fold_checksum): New functions.\n+\n+\t* fold-const.c (fold): Never modify argument passed to fold, instead\n+\tchange a copy and return it.\n+\t* convert.c (convert_to_integer): Likewise.\n+\n 2003-07-27  Nathanael Nerode  <neroden@gcc.gnu.org>\n \n \t* fixinc/fixinc.svr4: Remove dead code.  Remove now-unnecessary "}, {"sha": "e1feb70cb30a89709245be7ea01893fd39cc9c02", "filename": "gcc/config.in", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dfa45d043db04ebddf4081364661e0784304d39/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dfa45d043db04ebddf4081364661e0784304d39/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=5dfa45d043db04ebddf4081364661e0784304d39", "patch": "@@ -1,4 +1,4 @@\n-/* config.in.  Generated automatically from configure.in by autoheader 2.13.  */\n+/* config.in.  Generated automatically from configure.in by autoheader.  */\n \n /* Define to the type of elements in the array set by `getgroups'.\n    Usually this is either `int' or `gid_t'.  */\n@@ -236,6 +236,10 @@\n    every opportunity.  This is extremely expensive. */\n #undef ENABLE_GC_ALWAYS_COLLECT\n \n+/* Define if you want fold checked that it never destructs its argument.\n+   This is quite expensive. */\n+#undef ENABLE_FOLD_CHECKING\n+\n /* Define if you want to run subprograms and generated programs\n    through valgrind (a memory checker).  This is extremely expensive. */\n #undef ENABLE_VALGRIND_CHECKING"}, {"sha": "c102e87ba1ac20d468f2b20f76e493f0ec371665", "filename": "gcc/configure", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dfa45d043db04ebddf4081364661e0784304d39/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dfa45d043db04ebddf4081364661e0784304d39/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=5dfa45d043db04ebddf4081364661e0784304d39", "patch": "@@ -34,7 +34,7 @@ ac_help=\"$ac_help\n   --enable-checking[=LIST]\n \t\t\t  enable expensive run-time checks.  With LIST,\n \t\t\t  enable only specific categories of checks.\n-\t\t\t  Categories are: misc,tree,rtl,rtlflag,gc,gcac;\n+\t\t\t  Categories are: misc,tree,rtl,rtlflag,gc,gcac,fold;\n \t\t\t  default is misc,tree,gc,rtlflag\"\n ac_help=\"$ac_help\n   --enable-coverage[=LEVEL]\n@@ -1933,6 +1933,7 @@ ac_rtl_checking=\n ac_rtlflag_checking=\n ac_gc_checking=\n ac_gc_always_collect=\n+ac_fold_checking=\n case \"${enableval}\" in\n yes)\tac_checking=1 ; ac_tree_checking=1 ; ac_gc_checking=1 ;\n \tac_rtlflag_checking=1 ;;\n@@ -1949,6 +1950,7 @@ no)\t;;\n \t\trtl)\tac_rtl_checking=1 ;;\n \t\tgc)\tac_gc_checking=1 ;;\n \t\tgcac)\tac_gc_always_collect=1 ;;\n+\t\tfold)\tac_fold_checking=1 ;;\n \t\tvalgrind)\tac_checking_valgrind=1 ;;\n \t\t*)\t{ echo \"configure: error: unknown check category $check\" 1>&2; exit 1; } ;;\n \t\tesac\n@@ -1999,6 +2001,12 @@ if test x$ac_gc_always_collect != x ; then\n #define ENABLE_GC_ALWAYS_COLLECT 1\n EOF\n \n+fi\n+if test x$ac_fold_checking != x ; then\n+  cat >> confdefs.h <<\\EOF\n+#define ENABLE_FOLD_CHECKING 1\n+EOF\n+\n fi\n valgrind_path_defines=\n valgrind_command="}, {"sha": "5f031236a30c4f648d297dacfeeda89d2e49d59f", "filename": "gcc/configure.in", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dfa45d043db04ebddf4081364661e0784304d39/gcc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dfa45d043db04ebddf4081364661e0784304d39/gcc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.in?ref=5dfa45d043db04ebddf4081364661e0784304d39", "patch": "@@ -318,14 +318,15 @@ AC_ARG_ENABLE(checking,\n [  --enable-checking[=LIST]\n \t\t\t  enable expensive run-time checks.  With LIST,\n \t\t\t  enable only specific categories of checks.\n-\t\t\t  Categories are: misc,tree,rtl,rtlflag,gc,gcac;\n+\t\t\t  Categories are: misc,tree,rtl,rtlflag,gc,gcac,fold;\n \t\t\t  default is misc,tree,gc,rtlflag],\n [ac_checking=\n ac_tree_checking=\n ac_rtl_checking=\n ac_rtlflag_checking=\n ac_gc_checking=\n ac_gc_always_collect=\n+ac_fold_checking=\n case \"${enableval}\" in\n yes)\tac_checking=1 ; ac_tree_checking=1 ; ac_gc_checking=1 ;\n \tac_rtlflag_checking=1 ;;\n@@ -342,6 +343,7 @@ no)\t;;\n \t\trtl)\tac_rtl_checking=1 ;;\n \t\tgc)\tac_gc_checking=1 ;;\n \t\tgcac)\tac_gc_always_collect=1 ;;\n+\t\tfold)\tac_fold_checking=1 ;;\n \t\tvalgrind)\tac_checking_valgrind=1 ;;\n \t\t*)\tAC_MSG_ERROR(unknown check category $check) ;;\n \t\tesac\n@@ -388,6 +390,11 @@ if test x$ac_gc_always_collect != x ; then\n    paranoid mode, validating the entire heap and collecting garbage at\n    every opportunity.  This is extremely expensive.])\n fi\n+if test x$ac_fold_checking != x ; then\n+  AC_DEFINE(ENABLE_FOLD_CHECKING, 1,\n+[Define if you want fold checked that it never destructs its argument.\n+   This is quite expensive.])\n+fi\n valgrind_path_defines=\n valgrind_command=\n if test x$ac_checking_valgrind != x ; then"}, {"sha": "5bab1c19d3561b0224bfcf46a51946bd205cd660", "filename": "gcc/convert.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dfa45d043db04ebddf4081364661e0784304d39/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dfa45d043db04ebddf4081364661e0784304d39/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=5dfa45d043db04ebddf4081364661e0784304d39", "patch": "@@ -320,6 +320,7 @@ convert_to_integer (tree type, tree expr)\n \n       if (TREE_CODE_CLASS (ex_form) == '<')\n \t{\n+\t  expr = copy_node (expr);\n \t  TREE_TYPE (expr) = type;\n \t  return expr;\n \t}\n@@ -328,6 +329,7 @@ convert_to_integer (tree type, tree expr)\n \t       || ex_form == TRUTH_OR_EXPR || ex_form == TRUTH_ORIF_EXPR\n \t       || ex_form == TRUTH_XOR_EXPR)\n \t{\n+\t  expr = copy_node (expr);\n \t  TREE_OPERAND (expr, 0) = convert (type, TREE_OPERAND (expr, 0));\n \t  TREE_OPERAND (expr, 1) = convert (type, TREE_OPERAND (expr, 1));\n \t  TREE_TYPE (expr) = type;\n@@ -336,6 +338,7 @@ convert_to_integer (tree type, tree expr)\n \n       else if (ex_form == TRUTH_NOT_EXPR)\n \t{\n+\t  expr = copy_node (expr);\n \t  TREE_OPERAND (expr, 0) = convert (type, TREE_OPERAND (expr, 0));\n \t  TREE_TYPE (expr) = type;\n \t  return expr;"}, {"sha": "6f3fbf1dbcb9ee83e88eea6c80ea42d2c07f211f", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dfa45d043db04ebddf4081364661e0784304d39/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dfa45d043db04ebddf4081364661e0784304d39/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=5dfa45d043db04ebddf4081364661e0784304d39", "patch": "@@ -1038,8 +1038,8 @@ with GCC@.  This is on by default when building from CVS or snapshots,\n but off for releases.  More control over the checks may be had by\n specifying @var{list}; the categories of checks available are\n @samp{misc}, @samp{tree}, @samp{gc}, @samp{rtl}, @samp{rtlflag},\n-@samp{gcac} and @samp{valgrind}.  The check @samp{valgrind} requires the\n-external @command{valgrind} simulator, available from\n+@samp{fold}, @samp{gcac} and @samp{valgrind}.  The check @samp{valgrind}\n+requires the external @command{valgrind} simulator, available from\n @uref{http://developer.kde.org/~sewardj/}.  The default when @var{list} is\n not specified is @samp{misc,tree,gc,rtlflag}; the checks @samp{rtl},\n @samp{gcac} and @samp{valgrind} are very expensive."}, {"sha": "58cec23773b90b304ace3587340ba202cb516200", "filename": "gcc/fold-const.c", "status": "modified", "additions": 236, "deletions": 7, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dfa45d043db04ebddf4081364661e0784304d39/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dfa45d043db04ebddf4081364661e0784304d39/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=5dfa45d043db04ebddf4081364661e0784304d39", "patch": "@@ -56,6 +56,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"ggc.h\"\n #include \"hashtab.h\"\n #include \"langhooks.h\"\n+#include \"md5.h\"\n \n static void encode (HOST_WIDE_INT *, unsigned HOST_WIDE_INT, HOST_WIDE_INT);\n static void decode (HOST_WIDE_INT *, unsigned HOST_WIDE_INT *, HOST_WIDE_INT *);\n@@ -4921,7 +4922,7 @@ fold_single_bit_test (enum tree_code code, tree arg0, tree arg1,\n     }\n   return NULL_TREE;\n }\n- \n+\n /* Perform constant folding and related simplification of EXPR.\n    The related simplifications include x*1 => x, x*0 => 0, etc.,\n    and application of the associative law.\n@@ -4930,10 +4931,15 @@ fold_single_bit_test (enum tree_code code, tree arg0, tree arg1,\n    We cannot simplify through a CONVERT_EXPR, FIX_EXPR or FLOAT_EXPR,\n    but we can constant-fold them if they have constant operands.  */\n \n+#ifdef ENABLE_FOLD_CHECKING\n+# define fold(x) fold_1 (x)\n+static tree fold_1 (tree);\n+static\n+#endif\n tree\n fold (tree expr)\n {\n-  tree t = expr;\n+  tree t = expr, orig_t;\n   tree t1 = NULL_TREE;\n   tree tem;\n   tree type = TREE_TYPE (expr);\n@@ -4957,6 +4963,7 @@ fold (tree expr)\n #ifdef MAX_INTEGER_COMPUTATION_MODE\n   check_max_integer_computation_mode (expr);\n #endif\n+  orig_t = t;\n \n   if (code == NOP_EXPR || code == FLOAT_EXPR || code == CONVERT_EXPR)\n     {\n@@ -5028,12 +5035,15 @@ fold (tree expr)\n   if ((code == PLUS_EXPR || code == MULT_EXPR || code == MIN_EXPR\n        || code == MAX_EXPR || code == BIT_IOR_EXPR || code == BIT_XOR_EXPR\n        || code == BIT_AND_EXPR)\n-      && (TREE_CODE (arg0) == INTEGER_CST || TREE_CODE (arg0) == REAL_CST))\n+      && ((TREE_CODE (arg0) == INTEGER_CST && TREE_CODE (arg1) != INTEGER_CST)\n+\t  || (TREE_CODE (arg0) == REAL_CST && TREE_CODE (arg1) != REAL_CST)))\n     {\n       tem = arg0; arg0 = arg1; arg1 = tem;\n \n-      tem = TREE_OPERAND (t, 0); TREE_OPERAND (t, 0) = TREE_OPERAND (t, 1);\n-      TREE_OPERAND (t, 1) = tem;\n+      if (t == orig_t)\n+\tt = copy_node (t);\n+      TREE_OPERAND (t, 0) = arg0;\n+      TREE_OPERAND (t, 1) = arg1;\n     }\n \n   /* Now WINS is set as described above,\n@@ -5282,6 +5292,8 @@ fold (tree expr)\n \t  /* Don't leave an assignment inside a conversion\n \t     unless assigning a bitfield.  */\n \t  tree prev = TREE_OPERAND (t, 0);\n+\t  if (t == orig_t)\n+\t    t = copy_node (t);\n \t  TREE_OPERAND (t, 0) = TREE_OPERAND (prev, 1);\n \t  /* First do the assignment, then return converted constant.  */\n \t  t = build (COMPOUND_EXPR, TREE_TYPE (t), prev, fold (t));\n@@ -5334,7 +5346,12 @@ fold (tree expr)\n \n       if (!wins)\n \t{\n-\t  TREE_CONSTANT (t) = TREE_CONSTANT (arg0);\n+\t  if (TREE_CONSTANT (t) != TREE_CONSTANT (arg0))\n+\t    {\n+\t      if (t == orig_t)\n+\t\tt = copy_node (t);\n+\t      TREE_CONSTANT (t) = TREE_CONSTANT (arg0);\n+\t    }\n \t  return t;\n \t}\n       return fold_convert (t, arg0);\n@@ -5356,7 +5373,12 @@ fold (tree expr)\n       return t;\n \n     case RANGE_EXPR:\n-      TREE_CONSTANT (t) = wins;\n+      if (TREE_CONSTANT (t) != wins)\n+\t{\n+\t  if (t == orig_t)\n+\t    t = copy_node (t);\n+\t  TREE_CONSTANT (t) = wins;\n+\t}\n       return t;\n \n     case NEGATE_EXPR:\n@@ -6379,6 +6401,8 @@ fold (tree expr)\n \t RROTATE_EXPR by a new constant.  */\n       if (code == LROTATE_EXPR && TREE_CODE (arg1) == INTEGER_CST)\n \t{\n+\t  if (t == orig_t)\n+\t    t = copy_node (t);\n \t  TREE_SET_CODE (t, RROTATE_EXPR);\n \t  code = RROTATE_EXPR;\n \t  TREE_OPERAND (t, 1) = arg1\n@@ -6591,6 +6615,8 @@ fold (tree expr)\n \t  || (TREE_CODE (arg0) == REAL_CST\n \t      && TREE_CODE (arg0) != REAL_CST))\n \t{\n+\t  if (t == orig_t)\n+\t    t = copy_node (t);\n \t  TREE_OPERAND (t, 0) = arg1;\n \t  TREE_OPERAND (t, 1) = arg0;\n \t  arg0 = TREE_OPERAND (t, 0);\n@@ -6907,6 +6933,8 @@ fold (tree expr)\n \t\t\t\t\t   arg0);\n \t\tcase GE_EXPR:\n \t\t  code = EQ_EXPR;\n+\t\t  if (t == orig_t)\n+\t\t    t = copy_node (t);\n \t\t  TREE_SET_CODE (t, EQ_EXPR);\n \t\t  break;\n \t\tcase LE_EXPR:\n@@ -6915,6 +6943,8 @@ fold (tree expr)\n \t\t\t\t\t   arg0);\n \t\tcase LT_EXPR:\n \t\t  code = NE_EXPR;\n+\t\t  if (t == orig_t)\n+\t\t    t = copy_node (t);\n \t\t  TREE_SET_CODE (t, NE_EXPR);\n \t\t  break;\n \n@@ -6951,6 +6981,8 @@ fold (tree expr)\n \t\t\t\t\t   arg0);\n \t\tcase LE_EXPR:\n \t\t  code = EQ_EXPR;\n+\t\t  if (t == orig_t)\n+\t\t    t = copy_node (t);\n \t\t  TREE_SET_CODE (t, EQ_EXPR);\n \t\t  break;\n \n@@ -6960,6 +6992,8 @@ fold (tree expr)\n \t\t\t\t\t   arg0);\n \t\tcase GT_EXPR:\n \t\t  code = NE_EXPR;\n+\t\t  if (t == orig_t)\n+\t\t    t = copy_node (t);\n \t\t  TREE_SET_CODE (t, NE_EXPR);\n \t\t  break;\n \n@@ -7185,6 +7219,8 @@ fold (tree expr)\n \t\t  || ! HONOR_NANS (TYPE_MODE (TREE_TYPE (arg0))))\n \t\treturn constant_boolean_node (1, type);\n \t      code = EQ_EXPR;\n+\t      if (t == orig_t)\n+\t\tt = copy_node (t);\n \t      TREE_SET_CODE (t, code);\n \t      break;\n \n@@ -7902,6 +7938,199 @@ fold (tree expr)\n     } /* switch (code) */\n }\n \n+#ifdef ENABLE_FOLD_CHECKING\n+#undef fold\n+\n+static void fold_checksum_tree (tree, struct md5_ctx *, htab_t);\n+static void fold_check_failed (tree, tree);\n+void print_fold_checksum (tree);\n+\n+/* When --enable-checking=fold, compute a digest of expr before\n+   and after actual fold call to see if fold did not accidentally\n+   change original expr.  */\n+\n+tree\n+fold (tree expr)\n+{\n+  tree ret;\n+  struct md5_ctx ctx;\n+  unsigned char checksum_before[16], checksum_after[16];\n+  htab_t ht;\n+\n+  ht = htab_create (32, htab_hash_pointer, htab_eq_pointer, NULL);\n+  md5_init_ctx (&ctx);\n+  fold_checksum_tree (expr, &ctx, ht);\n+  md5_finish_ctx (&ctx, checksum_before);\n+  htab_empty (ht);\n+\n+  ret = fold_1 (expr);\n+\n+  md5_init_ctx (&ctx);\n+  fold_checksum_tree (expr, &ctx, ht);\n+  md5_finish_ctx (&ctx, checksum_after);\n+  htab_delete (ht);\n+\n+  if (memcmp (checksum_before, checksum_after, 16))\n+    fold_check_failed (expr, ret);\n+\n+  return ret;\n+}\n+\n+void\n+print_fold_checksum (tree expr)\n+{\n+  struct md5_ctx ctx;\n+  unsigned char checksum[16], cnt;\n+  htab_t ht;\n+\n+  ht = htab_create (32, htab_hash_pointer, htab_eq_pointer, NULL);\n+  md5_init_ctx (&ctx);\n+  fold_checksum_tree (expr, &ctx, ht);\n+  md5_finish_ctx (&ctx, checksum);\n+  htab_delete (ht);\n+  for (cnt = 0; cnt < 16; ++cnt)\n+    fprintf (stderr, \"%02x\", checksum[cnt]);\n+  putc ('\\n', stderr);\n+}\n+\n+static void\n+fold_check_failed (tree expr ATTRIBUTE_UNUSED, tree ret ATTRIBUTE_UNUSED)\n+{\n+  internal_error (\"fold check: original tree changed by fold\");\n+}\n+\n+static void\n+fold_checksum_tree (tree expr, struct md5_ctx *ctx, htab_t ht)\n+{\n+  void **slot;\n+  enum tree_code code;\n+  char buf[sizeof (struct tree_decl)];\n+  int i, len;\n+\n+  if (sizeof (struct tree_exp) + 5 * sizeof (tree)\n+      > sizeof (struct tree_decl)\n+      || sizeof (struct tree_type) > sizeof (struct tree_decl))\n+    abort ();\n+  if (expr == NULL)\n+    return;\n+  slot = htab_find_slot (ht, expr, INSERT);\n+  if (*slot != NULL)\n+    return;\n+  *slot = expr;\n+  code = TREE_CODE (expr);\n+  if (code == SAVE_EXPR && SAVE_EXPR_NOPLACEHOLDER (expr))\n+    {\n+      /* Allow SAVE_EXPR_NOPLACEHOLDER flag to be modified.  */\n+      memcpy (buf, expr, tree_size (expr));\n+      expr = (tree) buf;\n+      SAVE_EXPR_NOPLACEHOLDER (expr) = 0;\n+    }\n+  else if (TREE_CODE_CLASS (code) == 'd' && DECL_ASSEMBLER_NAME_SET_P (expr))\n+    {\n+      /* Allow DECL_ASSEMBLER_NAME to be modified.  */\n+      memcpy (buf, expr, tree_size (expr));\n+      expr = (tree) buf;\n+      SET_DECL_ASSEMBLER_NAME (expr, NULL);\n+    }\n+  else if (TREE_CODE_CLASS (code) == 't'\n+\t   && (TYPE_POINTER_TO (expr) || TYPE_REFERENCE_TO (expr)))\n+    {\n+      /* Allow TYPE_POINTER_TO and TYPE_REFERENCE_TO to be modified.  */\n+      memcpy (buf, expr, tree_size (expr));\n+      expr = (tree) buf;\n+      TYPE_POINTER_TO (expr) = NULL;\n+      TYPE_REFERENCE_TO (expr) = NULL;\n+    }\n+  md5_process_bytes (expr, tree_size (expr), ctx);\n+  fold_checksum_tree (TREE_TYPE (expr), ctx, ht);\n+  if (TREE_CODE_CLASS (code) != 't' && TREE_CODE_CLASS (code) != 'd')\n+    fold_checksum_tree (TREE_CHAIN (expr), ctx, ht);\n+  len = TREE_CODE_LENGTH (code);\n+  switch (TREE_CODE_CLASS (code))\n+    {\n+    case 'c':\n+      switch (code)\n+\t{\n+\tcase STRING_CST:\n+\t  md5_process_bytes (TREE_STRING_POINTER (expr),\n+\t\t\t     TREE_STRING_LENGTH (expr), ctx);\n+\t  break;\n+\tcase COMPLEX_CST:\n+\t  fold_checksum_tree (TREE_REALPART (expr), ctx, ht);\n+\t  fold_checksum_tree (TREE_IMAGPART (expr), ctx, ht);\n+\t  break;\n+\tcase VECTOR_CST:\n+\t  fold_checksum_tree (TREE_VECTOR_CST_ELTS (expr), ctx, ht);\n+\t  break;\n+\tdefault:\n+\t  break;\n+\t}\n+      break;\n+    case 'x':\n+      switch (code)\n+\t{\n+\tcase TREE_LIST:\n+\t  fold_checksum_tree (TREE_PURPOSE (expr), ctx, ht);\n+\t  fold_checksum_tree (TREE_VALUE (expr), ctx, ht);\n+\t  break;\n+\tcase TREE_VEC:\n+\t  for (i = 0; i < TREE_VEC_LENGTH (expr); ++i)\n+\t    fold_checksum_tree (TREE_VEC_ELT (expr, i), ctx, ht);\n+\t  break;\n+\tdefault:\n+\t  break;\n+\t}\n+      break;\n+    case 'e':\n+      switch (code)\n+\t{\n+\tcase SAVE_EXPR: len = 2; break;\n+\tcase GOTO_SUBROUTINE_EXPR: len = 0; break;\n+\tcase RTL_EXPR: len = 0; break;\n+\tcase WITH_CLEANUP_EXPR: len = 2; break;\n+\tdefault: break;\n+\t}\n+      /* FALLTHROUGH */\n+    case 'r':\n+    case '<':\n+    case '1':\n+    case '2':\n+    case 's':\n+      for (i = 0; i < len; ++i)\n+\tfold_checksum_tree (TREE_OPERAND (expr, i), ctx, ht);\n+      break;\n+    case 'd':\n+      fold_checksum_tree (DECL_SIZE (expr), ctx, ht);\n+      fold_checksum_tree (DECL_SIZE_UNIT (expr), ctx, ht);\n+      fold_checksum_tree (DECL_NAME (expr), ctx, ht);\n+      fold_checksum_tree (DECL_CONTEXT (expr), ctx, ht);\n+      fold_checksum_tree (DECL_ARGUMENTS (expr), ctx, ht);\n+      fold_checksum_tree (DECL_RESULT_FLD (expr), ctx, ht);\n+      fold_checksum_tree (DECL_INITIAL (expr), ctx, ht);\n+      fold_checksum_tree (DECL_ABSTRACT_ORIGIN (expr), ctx, ht);\n+      fold_checksum_tree (DECL_SECTION_NAME (expr), ctx, ht);\n+      fold_checksum_tree (DECL_ATTRIBUTES (expr), ctx, ht);\n+      fold_checksum_tree (DECL_VINDEX (expr), ctx, ht);\n+      break;\n+    case 't':\n+      fold_checksum_tree (TYPE_VALUES (expr), ctx, ht);\n+      fold_checksum_tree (TYPE_SIZE (expr), ctx, ht);\n+      fold_checksum_tree (TYPE_SIZE_UNIT (expr), ctx, ht);\n+      fold_checksum_tree (TYPE_ATTRIBUTES (expr), ctx, ht);\n+      fold_checksum_tree (TYPE_NAME (expr), ctx, ht);\n+      fold_checksum_tree (TYPE_MIN_VALUE (expr), ctx, ht);\n+      fold_checksum_tree (TYPE_MAX_VALUE (expr), ctx, ht);\n+      fold_checksum_tree (TYPE_MAIN_VARIANT (expr), ctx, ht);\n+      fold_checksum_tree (TYPE_BINFO (expr), ctx, ht);\n+      fold_checksum_tree (TYPE_CONTEXT (expr), ctx, ht);\n+      break;\n+    default:\n+      break;\n+    }\n+}\n+\n+#endif\n+\n /* Perform constant folding and related simplification of intializer\n    expression EXPR.  This behaves identically to \"fold\" but ignores\n    potential run-time traps and exceptions that fold must preserve.  */"}, {"sha": "cd4eb7dc0e2eb15b45b7a441ed752af71f66bb3e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dfa45d043db04ebddf4081364661e0784304d39/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dfa45d043db04ebddf4081364661e0784304d39/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5dfa45d043db04ebddf4081364661e0784304d39", "patch": "@@ -1,3 +1,7 @@\n+2003-07-28  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gcc.c-torture/compile/20030725-1.c: New test.\n+\n 2003-07-28  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* gcc.dg/20030505.c: Only run for SPE."}, {"sha": "26f2714010e4c7cc806fda033323adec109f0997", "filename": "gcc/testsuite/gcc.c-torture/compile/20030725-1.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dfa45d043db04ebddf4081364661e0784304d39/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20030725-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dfa45d043db04ebddf4081364661e0784304d39/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20030725-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20030725-1.c?ref=5dfa45d043db04ebddf4081364661e0784304d39", "patch": "@@ -0,0 +1,9 @@\n+/* This testcase caused ICE on any 64-bit arch at -O2/-O3 due to\n+   fold/extract_muldiv/convert destroying its argument.  */\n+int x, *y, z, *p;\n+\n+void\n+foo (void)\n+{\n+  p = y + (8 * (x == 1 || x == 3) + z);\n+}"}]}