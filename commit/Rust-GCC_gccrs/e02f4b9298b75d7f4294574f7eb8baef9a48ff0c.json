{"sha": "e02f4b9298b75d7f4294574f7eb8baef9a48ff0c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTAyZjRiOTI5OGI3NWQ3ZjQyOTQ1NzRmN2ViOGJhZWY5YTQ4ZmYwYw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2018-02-28T13:53:54Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2018-02-28T13:53:54Z"}, "message": "c-ada-spec.c (dump_ada_import): Use boolean and fix formatting.\n\n\t* c-ada-spec.c (dump_ada_import): Use boolean and fix formatting.\n\t(is_char_array): Fix formatting.\n\t(dump_template_types): Likewise.\n\t(dump_generic_ada_node): Rename into...\n\t(dump_ada_node): ...this.\n\t<POINTER_TYPE>: Remove superfluous space.  Use generic address for\n\tincomplete structures and not for empty structures.  Do not use it\n\twhen forward declarations are needed.\n\t(dump_forward_type): New function.\n\t(dump_nested_types): Remove FORWARD parameter.  Do not consider\n\tTREE_VISITED and do not generate a forward declaration.  Only dump\n\toriginal nested types for nested declaration.\n\t(dump_nested_type) <POINTER_TYPE>: Call dump_forward_type.\n\t<ARRAY_TYPE>: Likewise if the component type is an anonymous pointer.\n\t<RECORD_TYPE>: Do not consider TREE_VISITED.\n\t(dump_ada_declaration): Use booleans and fix formatting throughout.\n\t<TYPE_DECL>: Skip incomplete structures and not empty structures.\n\tCall dump_forward_type instead of dump_nested_types for a typedef.\n\tRemove superfluous check and adjust call to dump_nested_types.\n\t<POINTER_TYPE>: Call dump_forward_type and fall through.\n\t(dump_ada_struct_decl): Rename into...\n\t(dump_ada_structure): ...this.  Do not special-case empty structures.\n\nFrom-SVN: r258064", "tree": {"sha": "f6d91ad34f7bb4eb16250bc46ba08d752c4853fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f6d91ad34f7bb4eb16250bc46ba08d752c4853fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e02f4b9298b75d7f4294574f7eb8baef9a48ff0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e02f4b9298b75d7f4294574f7eb8baef9a48ff0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e02f4b9298b75d7f4294574f7eb8baef9a48ff0c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e02f4b9298b75d7f4294574f7eb8baef9a48ff0c/comments", "author": null, "committer": null, "parents": [{"sha": "4830cfc0a0cffb1c6f3ab9ec08b9b43681e7868c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4830cfc0a0cffb1c6f3ab9ec08b9b43681e7868c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4830cfc0a0cffb1c6f3ab9ec08b9b43681e7868c"}], "stats": {"total": 164, "additions": 79, "deletions": 85}, "files": [{"sha": "fbe654dc104c825bac9200d5d66290100d9ea85f", "filename": "gcc/c-family/c-ada-spec.c", "status": "modified", "additions": 79, "deletions": 85, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e02f4b9298b75d7f4294574f7eb8baef9a48ff0c/gcc%2Fc-family%2Fc-ada-spec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e02f4b9298b75d7f4294574f7eb8baef9a48ff0c/gcc%2Fc-family%2Fc-ada-spec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-ada-spec.c?ref=e02f4b9298b75d7f4294574f7eb8baef9a48ff0c", "patch": "@@ -32,10 +32,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"attribs.h\"\n \n /* Local functions, macros and variables.  */\n-static int  dump_generic_ada_node (pretty_printer *, tree, tree, int, bool,\n-\t\t\t\t   bool);\n+static int  dump_ada_node (pretty_printer *, tree, tree, int, bool, bool);\n static int  dump_ada_declaration (pretty_printer *, tree, tree, int);\n-static void dump_ada_struct_decl (pretty_printer *, tree, tree, int, bool);\n+static void dump_ada_structure (pretty_printer *, tree, tree, int, bool);\n static char *to_ada_name (const char *, unsigned int, bool *);\n \n #define INDENT(SPACE) \\\n@@ -1725,13 +1724,13 @@ dump_ada_function_declaration (pretty_printer *buffer, tree func,\n \t      pp_string (buffer, buf);\n \t    }\n \n-\t  dump_generic_ada_node (buffer, TREE_TYPE (arg), node, spc, 0, true);\n+\t  dump_ada_node (buffer, TREE_TYPE (arg), node, spc, false, true);\n \t}\n       else\n \t{\n \t  sprintf (buf, \"arg%d : \", num);\n \t  pp_string (buffer, buf);\n-\t  dump_generic_ada_node (buffer, TREE_VALUE (arg), node, spc, 0, true);\n+\t  dump_ada_node (buffer, TREE_VALUE (arg), node, spc, false, true);\n \t}\n \n       /* If the type is a pointer to a tagged type, we need to differentiate\n@@ -1773,7 +1772,7 @@ dump_ada_function_declaration (pretty_printer *buffer, tree func,\n     {\n       pp_string (buffer, \" return \");\n       tree type = is_constructor ? DECL_CONTEXT (func) : TREE_TYPE (node);\n-      dump_generic_ada_node (buffer, type, type, spc, false, true);\n+      dump_ada_node (buffer, type, type, spc, false, true);\n     }\n }\n \n@@ -1800,13 +1799,13 @@ dump_ada_array_domains (pretty_printer *buffer, tree node, int spc)\n \t  first = 0;\n \n \t  if (min)\n-\t    dump_generic_ada_node (buffer, min, NULL_TREE, spc, 0, true);\n+\t    dump_ada_node (buffer, min, NULL_TREE, spc, false, true);\n \t  pp_string (buffer, \" .. \");\n \n \t  /* If the upper bound is zero, gcc may generate a NULL_TREE\n \t     for TYPE_MAX_VALUE rather than an integer_cst.  */\n \t  if (max)\n-\t    dump_generic_ada_node (buffer, max, NULL_TREE, spc, 0, true);\n+\t    dump_ada_node (buffer, max, NULL_TREE, spc, false, true);\n \t  else\n \t    pp_string (buffer, \"0\");\n \t}\n@@ -1855,8 +1854,9 @@ is_char_array (tree t)\n     }\n \n   tmp = TREE_TYPE (tmp);\n-  return num_dim == 1 && TREE_CODE (tmp) == INTEGER_TYPE\n-    && id_equal (DECL_NAME (TYPE_NAME (tmp)), \"char\");\n+  return num_dim == 1\n+\t && TREE_CODE (tmp) == INTEGER_TYPE\n+\t && id_equal (DECL_NAME (TYPE_NAME (tmp)), \"char\");\n }\n \n /* Dump in BUFFER an array type T in Ada syntax.  Assume that the \"type\"\n@@ -1894,7 +1894,7 @@ dump_ada_array_type (pretty_printer *buffer, tree t, tree parent, int spc)\n \tpp_string (buffer, \"aliased \");\n \n       if (TYPE_NAME (tmp) || !RECORD_OR_UNION_TYPE_P (tmp))\n-\tdump_generic_ada_node (buffer, tmp, TREE_TYPE (t), spc, false, true);\n+\tdump_ada_node (buffer, tmp, TREE_TYPE (t), spc, false, true);\n       else\n \tdump_ada_double_name (buffer, parent, get_underlying_decl (tmp));\n     }\n@@ -1907,14 +1907,12 @@ dump_ada_array_type (pretty_printer *buffer, tree t, tree parent, int spc)\n static void\n dump_template_types (pretty_printer *buffer, tree types, int spc)\n {\n-  size_t i;\n-  size_t len = TREE_VEC_LENGTH (types);\n-\n-  for (i = 0; i < len; i++)\n+  for (int i = 0; i < TREE_VEC_LENGTH (types); i++)\n     {\n       tree elem = TREE_VEC_ELT (types, i);\n       pp_underscore (buffer);\n-      if (!dump_generic_ada_node (buffer, elem, 0, spc, false, true))\n+\n+      if (!dump_ada_node (buffer, elem, NULL_TREE, spc, false, true))\n \t{\n \t  pp_string (buffer, \"unknown\");\n \t  pp_scalar (buffer, \"%lu\", (unsigned long) TREE_HASH (elem));\n@@ -1967,23 +1965,23 @@ dump_ada_template (pretty_printer *buffer, tree t, int spc)\n       INDENT (spc);\n       pp_string (buffer, \"package \");\n       package_prefix = false;\n-      dump_generic_ada_node (buffer, instance, t, spc, false, true);\n+      dump_ada_node (buffer, instance, t, spc, false, true);\n       dump_template_types (buffer, types, spc);\n       pp_string (buffer, \" is\");\n       spc += INDENT_INCR;\n       newline_and_indent (buffer, spc);\n \n       TREE_VISITED (get_underlying_decl (instance)) = 1;\n       pp_string (buffer, \"type \");\n-      dump_generic_ada_node (buffer, instance, t, spc, false, true);\n+      dump_ada_node (buffer, instance, t, spc, false, true);\n       package_prefix = true;\n \n       if (is_tagged_type (instance))\n \tpp_string (buffer, \" is tagged limited \");\n       else\n \tpp_string (buffer, \" is limited \");\n \n-      dump_generic_ada_node (buffer, instance, t, spc, false, false);\n+      dump_ada_node (buffer, instance, t, spc, false, false);\n       pp_newline (buffer);\n       spc -= INDENT_INCR;\n       newline_and_indent (buffer, spc);\n@@ -1992,7 +1990,7 @@ dump_ada_template (pretty_printer *buffer, tree t, int spc)\n       newline_and_indent (buffer, spc);\n       pp_string (buffer, \"use \");\n       package_prefix = false;\n-      dump_generic_ada_node (buffer, instance, t, spc, false, true);\n+      dump_ada_node (buffer, instance, t, spc, false, true);\n       dump_template_types (buffer, types, spc);\n       package_prefix = true;\n       pp_semicolon (buffer);\n@@ -2038,8 +2036,8 @@ static bool bitfield_used = false;\n    we should only dump the name of NODE, instead of its full declaration.  */\n \n static int\n-dump_generic_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n-\t\t       bool limited_access, bool name_only)\n+dump_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n+\t       bool limited_access, bool name_only)\n {\n   if (node == NULL_TREE)\n     return 0;\n@@ -2059,8 +2057,8 @@ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n       return 0;\n \n     case TREE_BINFO:\n-      dump_generic_ada_node\n-\t(buffer, BINFO_TYPE (node), type, spc, limited_access, name_only);\n+      dump_ada_node (buffer, BINFO_TYPE (node), type, spc, limited_access,\n+\t\t     name_only);\n       return 0;\n \n     case TREE_VEC:\n@@ -2087,7 +2085,7 @@ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n \n     case ENUMERAL_TYPE:\n       if (name_only)\n-\tdump_generic_ada_node (buffer, TYPE_NAME (node), node, spc, 0, true);\n+\tdump_ada_node (buffer, TYPE_NAME (node), node, spc, false, true);\n       else\n \t{\n \t  tree value = TYPE_VALUES (node);\n@@ -2115,9 +2113,9 @@ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n \t      spc -= INDENT_INCR;\n \t      newline_and_indent (buffer, spc);\n \t      pp_string (buffer, \"pragma Convention (C, \");\n-\t      dump_generic_ada_node\n-\t\t(buffer, DECL_NAME (type) ? type : TYPE_NAME (node), type,\n-\t\t spc, 0, true);\n+\t      dump_ada_node (buffer,\n+\t\t\t     DECL_NAME (type) ? type : TYPE_NAME (node),\n+\t\t\t     type, spc, false, true);\n \t      pp_right_paren (buffer);\n \t    }\n \t  else\n@@ -2135,16 +2133,16 @@ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n \t\t\t\t\t  0, false);\n \t\t  pp_string (buffer, \" : constant \");\n \n-\t\t  dump_generic_ada_node\n-\t\t    (buffer, DECL_NAME (type) ? type : TYPE_NAME (node), type,\n-\t\t     spc, 0, true);\n+\t\t  dump_ada_node (buffer,\n+\t\t\t\t DECL_NAME (type) ? type : TYPE_NAME (node),\n+\t\t\t\t type, spc, false, true);\n \n \t\t  pp_string (buffer, \" := \");\n-\t\t  dump_generic_ada_node\n-\t\t    (buffer,\n-\t\t     TREE_CODE (TREE_VALUE (value)) == INTEGER_CST ?\n-\t\t       TREE_VALUE (value) : DECL_INITIAL (TREE_VALUE (value)),\n-\t\t     node, spc, false, true);\n+\t\t  dump_ada_node (buffer,\n+\t\t\t\t TREE_CODE (TREE_VALUE (value)) == INTEGER_CST\n+\t\t\t\t ? TREE_VALUE (value)\n+\t\t\t\t : DECL_INITIAL (TREE_VALUE (value)),\n+\t\t\t\t node, spc, false, true);\n \t\t}\n \t    }\n \t}\n@@ -2204,8 +2202,8 @@ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n     case POINTER_TYPE:\n     case REFERENCE_TYPE:\n       if (name_only && TYPE_NAME (node))\n-\tdump_generic_ada_node\n-\t  (buffer, TYPE_NAME (node), node, spc, limited_access, true);\n+\tdump_ada_node (buffer, TYPE_NAME (node), node, spc, limited_access,\n+\t\t       true);\n \n       else if (TREE_CODE (TREE_TYPE (node)) == FUNCTION_TYPE)\n \t{\n@@ -2224,7 +2222,7 @@ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n \t      pp_semicolon (buffer);\n \t      newline_and_indent (buffer, spc);\n \t      pp_string (buffer, \"pragma Convention (C, \");\n-\t      dump_generic_ada_node (buffer, type, 0, spc, false, true);\n+\t      dump_ada_node (buffer, type, NULL_TREE, spc, false, true);\n \t      pp_right_paren (buffer);\n \t    }\n \t}\n@@ -2319,20 +2317,20 @@ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n \t\t    }\n \n \t\t  if (RECORD_OR_UNION_TYPE_P (TREE_TYPE (node)) && type_name)\n-\t\t    dump_generic_ada_node (buffer, type_name, TREE_TYPE (node),\n-\t\t\t\t\t   spc, is_access, true);\n+\t\t    dump_ada_node (buffer, type_name, TREE_TYPE (node), spc,\n+\t\t\t\t   is_access, true);\n \t\t  else\n-\t\t    dump_generic_ada_node (buffer, TREE_TYPE (node),\n-\t\t\t\t\t   TREE_TYPE (node), spc, 0, true);\n+\t\t    dump_ada_node (buffer, TREE_TYPE (node), TREE_TYPE (node),\n+\t\t\t\t   spc, false, true);\n \t\t}\n \t    }\n \t}\n       break;\n \n     case ARRAY_TYPE:\n       if (name_only)\n-\tdump_generic_ada_node\n-\t  (buffer, TYPE_NAME (node), node, spc, limited_access, true);\n+\tdump_ada_node (buffer, TYPE_NAME (node), node, spc, limited_access,\n+\t\t       true);\n       else\n \tdump_ada_array_type (buffer, node, type, spc);\n       break;\n@@ -2342,16 +2340,16 @@ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n       if (name_only)\n \t{\n \t  if (TYPE_NAME (node))\n-\t    dump_generic_ada_node\n-\t      (buffer, TYPE_NAME (node), node, spc, limited_access, true);\n+\t    dump_ada_node (buffer, TYPE_NAME (node), node, spc, limited_access,\n+\t\t\t   true);\n \t  else\n \t    {\n \t      pp_string (buffer, \"anon_\");\n \t      pp_scalar (buffer, \"%d\", TYPE_UID (node));\n \t    }\n \t}\n       else\n-\tdump_ada_struct_decl (buffer, node, type, spc, true);\n+\tdump_ada_structure (buffer, node, type, spc, true);\n       break;\n \n     case INTEGER_CST:\n@@ -2442,8 +2440,7 @@ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n \t  else if (has_nontrivial_methods (TREE_TYPE (node)))\n \t    pp_string (buffer, \"limited \");\n \n-\t  dump_generic_ada_node\n-\t    (buffer, TREE_TYPE (node), type, spc, false, false);\n+\t  dump_ada_node (buffer, TREE_TYPE (node), type, spc, false, false);\n \t}\n       break;\n \n@@ -2529,7 +2526,7 @@ dump_forward_type (pretty_printer *buffer, tree type, tree t, int spc)\n \n   /* Generate an incomplete type declaration.  */\n   pp_string (buffer, \"type \");\n-  dump_generic_ada_node (buffer, decl, 0, spc, false, true);\n+  dump_ada_node (buffer, decl, NULL_TREE, spc, false, true);\n   pp_semicolon (buffer);\n   newline_and_indent (buffer, spc);\n \n@@ -2624,21 +2621,21 @@ dump_nested_type (pretty_printer *buffer, tree field, tree t, tree parent,\n \n       if (TYPE_NAME (field_type))\n \t{\n-\t  dump_generic_ada_node (buffer, field_type, 0, spc, false, true);\n+\t  dump_ada_node (buffer, field_type, NULL_TREE, spc, false, true);\n \t  if (TREE_CODE (field_type) == UNION_TYPE)\n \t    pp_string (buffer, \" (discr : unsigned := 0)\");\n \t  pp_string (buffer, \" is \");\n-\t  dump_ada_struct_decl (buffer, field_type, t, spc, false);\n+\t  dump_ada_structure (buffer, field_type, t, spc, false);\n \n \t  pp_string (buffer, \"pragma Convention (C_Pass_By_Copy, \");\n-\t  dump_generic_ada_node (buffer, field_type, 0, spc, false, true);\n+\t  dump_ada_node (buffer, field_type, NULL_TREE, spc, false, true);\n \t  pp_string (buffer, \");\");\n \t  newline_and_indent (buffer, spc);\n \n \t  if (TREE_CODE (field_type) == UNION_TYPE)\n \t    {\n \t      pp_string (buffer, \"pragma Unchecked_Union (\");\n-\t      dump_generic_ada_node (buffer, field_type, 0, spc, false, true);\n+\t      dump_ada_node (buffer, field_type, NULL_TREE, spc, false, true);\n \t      pp_string (buffer, \");\");\n \t    }\n \t}\n@@ -2648,7 +2645,7 @@ dump_nested_type (pretty_printer *buffer, tree field, tree t, tree parent,\n \t  if (TREE_CODE (field_type) == UNION_TYPE)\n \t    pp_string (buffer, \" (discr : unsigned := 0)\");\n \t  pp_string (buffer, \" is \");\n-\t  dump_ada_struct_decl (buffer, field_type, t, spc, false);\n+\t  dump_ada_structure (buffer, field_type, t, spc, false);\n \n \t  pp_string (buffer, \"pragma Convention (C_Pass_By_Copy, \");\n \t  dump_ada_double_name (buffer, parent, field);\n@@ -2749,17 +2746,17 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \t      if (RECORD_OR_UNION_TYPE_P (typ) && !COMPLETE_TYPE_P (typ))\n \t\t{\n \t\t  pp_string (buffer, \"--  skipped incomplete struct \");\n-\t\t  dump_generic_ada_node (buffer, t, type, spc, false, true);\n+\t\t  dump_ada_node (buffer, t, type, spc, false, true);\n \t\t}\n \t      else\n \t\t{\n \t\t  if (RECORD_OR_UNION_TYPE_P (typ))\n \t\t    dump_forward_type (buffer, stub, t, spc);\n \n \t\t  pp_string (buffer, \"subtype \");\n-\t\t  dump_generic_ada_node (buffer, t, type, spc, false, true);\n+\t\t  dump_ada_node (buffer, t, type, spc, false, true);\n \t\t  pp_string (buffer, \" is \");\n-\t\t  dump_generic_ada_node (buffer, typ, type, spc, false, true);\n+\t\t  dump_ada_node (buffer, typ, type, spc, false, true);\n \t\t  pp_string (buffer, \";  -- \");\n \t\t  dump_sloc (buffer, t);\n \t\t}\n@@ -2792,7 +2789,7 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \t    if (!COMPLETE_TYPE_P (TREE_TYPE (t)))\n \t      {\n \t\tpp_string (buffer, \"--  skipped incomplete struct \");\n-\t\tdump_generic_ada_node (buffer, t, type, spc, false, true);\n+\t\tdump_ada_node (buffer, t, type, spc, false, true);\n \t\treturn 1;\n \t      }\n \n@@ -2801,7 +2798,7 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \t\t    || *IDENTIFIER_POINTER (decl_name) == '$'))\n \t      {\n \t\tpp_string (buffer, \"--  skipped anonymous struct \");\n-\t\tdump_generic_ada_node (buffer, t, type, spc, false, true);\n+\t\tdump_ada_node (buffer, t, type, spc, false, true);\n \t\tTREE_VISITED (t) = 1;\n \t\treturn 1;\n \t      }\n@@ -2816,7 +2813,7 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \t\t  {\n \t\t    is_class = true;\n \t\t    pp_string (buffer, \"package Class_\");\n-\t\t    dump_generic_ada_node (buffer, t, type, spc, false, true);\n+\t\t    dump_ada_node (buffer, t, type, spc, false, true);\n \t\t    pp_string (buffer, \" is\");\n \t\t    spc += INDENT_INCR;\n \t\t    newline_and_indent (buffer, spc);\n@@ -2840,7 +2837,7 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \n \t  case FUNCTION_TYPE:\n \t    pp_string (buffer, \"--  skipped function type \");\n-\t    dump_generic_ada_node (buffer, t, type, spc, false, true);\n+\t    dump_ada_node (buffer, t, type, spc, false, true);\n \t    return 1;\n \n \t  case ENUMERAL_TYPE:\n@@ -2873,15 +2870,14 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \tINDENT (spc);\n \n       /* Print variable's name.  */\n-      dump_generic_ada_node (buffer, t, type, spc, false, true);\n+      dump_ada_node (buffer, t, type, spc, false, true);\n \n       if (TREE_CODE (t) == TYPE_DECL)\n \t{\n \t  pp_string (buffer, \" is \");\n \n \t  if (orig && TYPE_NAME (orig))\n-\t    dump_generic_ada_node\n-\t      (buffer, TYPE_NAME (orig), type, spc, false, true);\n+\t    dump_ada_node (buffer, TYPE_NAME (orig), type, spc, false, true);\n \t  else\n \t    dump_ada_array_type (buffer, t, type, spc);\n \t}\n@@ -2898,7 +2894,7 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \t    pp_string (buffer, \"aliased \");\n \n \t  if (tmp)\n-\t    dump_generic_ada_node (buffer, tmp, type, spc, false, true);\n+\t    dump_ada_node (buffer, tmp, type, spc, false, true);\n \t  else if (type)\n \t    dump_ada_double_name (buffer, type, t);\n \t  else\n@@ -3022,7 +3018,7 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \tINDENT (spc);\n \n       /* Anonymous structs/unions.  */\n-      dump_generic_ada_node (buffer, TREE_TYPE (t), t, spc, false, true);\n+      dump_ada_node (buffer, TREE_TYPE (t), t, spc, false, true);\n \n       if (TREE_CODE (TREE_TYPE (t)) == UNION_TYPE)\n \tpp_string (buffer, \" (discr : unsigned := 0)\");\n@@ -3068,17 +3064,17 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \t  dump_sloc (buffer, t);\n \t  newline_and_indent (buffer, spc);\n \t  pp_string (buffer, \"pragma Import (CPP, \");\n- \t  dump_generic_ada_node\n-\t    (buffer, TYPE_NAME (TREE_TYPE (t)), type, spc, false, true);\n-  \t  pp_right_paren (buffer);\n+\t  dump_ada_node (buffer, TYPE_NAME (TREE_TYPE (t)), type, spc, false,\n+\t\t\t true);\n+\t  pp_right_paren (buffer);\n \n \t  dump_ada_methods (buffer, TREE_TYPE (t), spc);\n \t}\n       else\n \t{\n \t  if (is_abstract_record)\n \t    pp_string (buffer, \"abstract \");\n-\t  dump_generic_ada_node (buffer, t, t, spc, false, false);\n+\t  dump_ada_node (buffer, t, t, spc, false, false);\n \t}\n     }\n   else\n@@ -3090,7 +3086,7 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \tcheck_name (buffer, t);\n \n       /* Print variable/type's name.  */\n-      dump_generic_ada_node (buffer, t, t, spc, false, true);\n+      dump_ada_node (buffer, t, t, spc, false, true);\n \n       if (TREE_CODE (t) == TYPE_DECL)\n \t{\n@@ -3101,7 +3097,7 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \n \t  pp_string (buffer, \" is \");\n \n-\t  dump_generic_ada_node (buffer, orig, t, spc, false, is_subtype);\n+\t  dump_ada_node (buffer, orig, t, spc, false, is_subtype);\n \t}\n       else\n \t{\n@@ -3118,8 +3114,7 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \t\tpp_string (buffer, \"constant \");\n \n \t      if (TYPE_NAME (TREE_TYPE (t)))\n-\t\tdump_generic_ada_node\n-\t\t  (buffer, TREE_TYPE (t), t, spc, false, true);\n+\t\tdump_ada_node (buffer, TREE_TYPE (t), t, spc, false, true);\n \t      else if (type)\n \t\tdump_ada_double_name (buffer, type, t);\n \t    }\n@@ -3133,8 +3128,8 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \t      if (TREE_READONLY (t) && TREE_CODE (t) != FIELD_DECL)\n \t\tpp_string (buffer, \"constant \");\n \n-\t      dump_generic_ada_node\n-\t\t(buffer, TREE_TYPE (t), TREE_TYPE (t), spc, false, true);\n+\t      dump_ada_node (buffer, TREE_TYPE (t), TREE_TYPE (t), spc, false,\n+\t\t\t     true);\n \t    }\n \t}\n     }\n@@ -3146,7 +3141,7 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n       pp_string (buffer, \"end;\");\n       newline_and_indent (buffer, spc);\n       pp_string (buffer, \"use Class_\");\n-      dump_generic_ada_node (buffer, t, type, spc, false, true);\n+      dump_ada_node (buffer, t, type, spc, false, true);\n       pp_semicolon (buffer);\n       pp_newline (buffer);\n \n@@ -3173,8 +3168,8 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n    true, also print the pragma Convention for NODE.  */\n \n static void\n-dump_ada_struct_decl (pretty_printer *buffer, tree node, tree type, int spc,\n-\t\t       bool display_convention)\n+dump_ada_structure (pretty_printer *buffer, tree node, tree type, int spc,\n+\t\t    bool display_convention)\n {\n   tree tmp;\n   const bool is_union = (TREE_CODE (node) == UNION_TYPE);\n@@ -3288,7 +3283,7 @@ dump_ada_struct_decl (pretty_printer *buffer, tree node, tree type, int spc,\n     pp_string (buffer, \"pragma Convention (C, \");\n \n   package_prefix = false;\n-  dump_generic_ada_node (buffer, TREE_TYPE (type), type, spc, false, true);\n+  dump_ada_node (buffer, TREE_TYPE (type), type, spc, false, true);\n   package_prefix = true;\n   pp_right_paren (buffer);\n \n@@ -3298,7 +3293,7 @@ dump_ada_struct_decl (pretty_printer *buffer, tree node, tree type, int spc,\n       newline_and_indent (buffer, spc);\n       pp_string (buffer, \"pragma Unchecked_Union (\");\n \n-      dump_generic_ada_node (buffer, TREE_TYPE (type), type, spc, false, true);\n+      dump_ada_node (buffer, TREE_TYPE (type), type, spc, false, true);\n       pp_right_paren (buffer);\n     }\n \n@@ -3307,8 +3302,7 @@ dump_ada_struct_decl (pretty_printer *buffer, tree node, tree type, int spc,\n       pp_semicolon (buffer);\n       newline_and_indent (buffer, spc);\n       pp_string (buffer, \"pragma Pack (\");\n-      dump_generic_ada_node\n-\t(buffer, TREE_TYPE (type), type, spc, false, true);\n+      dump_ada_node (buffer, TREE_TYPE (type), type, spc, false, true);\n       pp_right_paren (buffer);\n       bitfield_used = false;\n     }"}]}