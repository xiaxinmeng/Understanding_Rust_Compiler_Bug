{"sha": "1c8bcdf715b0475effdd0cc2c27d461c3ce5540f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWM4YmNkZjcxNWIwNDc1ZWZmZGQwY2MyYzI3ZDQ2MWMzY2U1NTQwZg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2008-01-17T07:19:04Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2008-01-17T07:19:04Z"}, "message": "re PR fortran/34429 (Fails: character(len=use_associated_const) function foo())\n\n2008-01-17  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/34429\n\tPR fortran/34431\n\tPR fortran/34471\n\t* decl.c : Remove gfc_function_kind_locus and\n\tgfc_function_type_locus. Add gfc_matching_function.\n\t(match_char_length): If matching a function and the length\n\tdoes not match, return MATCH_YES and try again later.\n\t(gfc_match_kind_spec): The same.\n\t(match_char_kind): The same.\n\t(gfc_match_type_spec): The same for numeric and derived types.\n\t(match_prefix): Rename as gfc_match_prefix.\n\t(gfc_match_function_decl): Except for function valued character\n\tlengths, defer applying kind, type and charlen info until the\n\tend of specification block.\n\tgfortran.h (gfc_statement): Add ST_GET_FCN_CHARACTERISTICS.\n\tparse.c (decode_specification_statement): New function.\n\t(decode_statement): Call it when a function has kind = -1. Set\n\tand reset gfc_matching function, as function statement is being\n\tmatched.\n\t(match_deferred_characteristics): Simplify with a single call\n\tto gfc_match_prefix. Do appropriate error handling. In any\n\tcase, make sure that kind = -1 is reset or corrected.\n\t(parse_spec): Call above on seeing ST_GET_FCN_CHARACTERISTICS.\n\tThrow an error if kind = -1 after last specification statement.\n\tparse.h : Prototype for gfc_match_prefix.\n\n2008-01-17  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/34429\n\t* gfortran.dg/function_charlen_1.f90: New test.\n\n\tPR fortran/34431\n\t* gfortran.dg/function_types_1.f90: New test.\n\t* gfortran.dg/function_types_2.f90: New test.\n\n\tPR fortran/34471\n\t* gfortran.dg/function_kinds_4.f90: New test.\n\t* gfortran.dg/function_kinds_5.f90: New test.\n\n\t* gfortran.dg/defined_operators_1.f90: Errors now at function\n\tdeclarations.\n\t* gfortran.dg/private_type_4.f90: The same.\n\t* gfortran.dg/interface_15.f90: The same.\n\t* gfortran.dg/elemental_args_check_2.f90: The same.\n\t* gfortran.dg/auto_internal_assumed.f90: The same.\n\nFrom-SVN: r131592", "tree": {"sha": "054213ac5d3f5eac30ee27cfdf5a1a02e096965b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/054213ac5d3f5eac30ee27cfdf5a1a02e096965b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1c8bcdf715b0475effdd0cc2c27d461c3ce5540f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c8bcdf715b0475effdd0cc2c27d461c3ce5540f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c8bcdf715b0475effdd0cc2c27d461c3ce5540f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c8bcdf715b0475effdd0cc2c27d461c3ce5540f/comments", "author": null, "committer": null, "parents": [{"sha": "e7ce29e776d8309ac625863aa8eb781599ef43c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7ce29e776d8309ac625863aa8eb781599ef43c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7ce29e776d8309ac625863aa8eb781599ef43c6"}], "stats": {"total": 637, "additions": 554, "deletions": 83}, "files": [{"sha": "dccfcdf7939acd588dc0547189bb8df39a55b6d1", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c8bcdf715b0475effdd0cc2c27d461c3ce5540f/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c8bcdf715b0475effdd0cc2c27d461c3ce5540f/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=1c8bcdf715b0475effdd0cc2c27d461c3ce5540f", "patch": "@@ -1,3 +1,31 @@\n+2008-01-17  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/34429\n+\tPR fortran/34431\n+\tPR fortran/34471\n+\t* decl.c : Remove gfc_function_kind_locus and\n+\tgfc_function_type_locus. Add gfc_matching_function.\n+\t(match_char_length): If matching a function and the length\n+\tdoes not match, return MATCH_YES and try again later.\n+\t(gfc_match_kind_spec): The same.\n+\t(match_char_kind): The same.\n+\t(gfc_match_type_spec): The same for numeric and derived types.\n+\t(match_prefix): Rename as gfc_match_prefix.\n+\t(gfc_match_function_decl): Except for function valued character\n+\tlengths, defer applying kind, type and charlen info until the\n+\tend of specification block.\n+\tgfortran.h (gfc_statement): Add ST_GET_FCN_CHARACTERISTICS.\n+\tparse.c (decode_specification_statement): New function.\n+\t(decode_statement): Call it when a function has kind = -1. Set\n+\tand reset gfc_matching function, as function statement is being\n+\tmatched.\n+\t(match_deferred_characteristics): Simplify with a single call\n+\tto gfc_match_prefix. Do appropriate error handling. In any\n+\tcase, make sure that kind = -1 is reset or corrected.\n+\t(parse_spec): Call above on seeing ST_GET_FCN_CHARACTERISTICS.\n+\tThrow an error if kind = -1 after last specification statement.\n+\tparse.h : Prototype for gfc_match_prefix.\n+\n 2008-01-16  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/34796"}, {"sha": "115b30ebb754f2c4ea7628a31abff2c0140c1dc8", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 79, "deletions": 34, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c8bcdf715b0475effdd0cc2c27d461c3ce5540f/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c8bcdf715b0475effdd0cc2c27d461c3ce5540f/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=1c8bcdf715b0475effdd0cc2c27d461c3ce5540f", "patch": "@@ -86,8 +86,7 @@ static enumerator_history *max_enum = NULL;\n \n gfc_symbol *gfc_new_block;\n \n-locus gfc_function_kind_locus;\n-locus gfc_function_type_locus;\n+bool gfc_matching_function;\n \n \n /********************* DATA statement subroutines *********************/\n@@ -653,6 +652,12 @@ match_char_length (gfc_expr **expr)\n     goto syntax;\n \n   m = char_len_param_value (expr);\n+  if (m != MATCH_YES && gfc_matching_function)\n+    {\n+      gfc_undo_symbols ();\n+      m = MATCH_YES;\n+    }\n+\n   if (m == MATCH_ERROR)\n     return m;\n   if (m == MATCH_NO)\n@@ -1869,13 +1874,11 @@ gfc_match_kind_spec (gfc_typespec *ts, bool kind_expr_only)\n \n   if (n != MATCH_YES)\n     {\n-      if (gfc_current_state () == COMP_INTERFACE\n-            || gfc_current_state () == COMP_NONE\n-            || gfc_current_state () == COMP_CONTAINS)\n+      if (gfc_matching_function)\n \t{\n-\t  /* Signal using kind = -1 that the expression might include\n-\t     use associated or imported parameters and try again after\n-\t     the specification expressions.....  */\n+\t  /* The function kind expression might include use associated or \n+\t     imported parameters and try again after the specification\n+\t     expressions.....  */\n \t  if (gfc_match_char (')') != MATCH_YES)\n \t    {\n \t      gfc_error (\"Missing right parenthesis at %C\");\n@@ -1884,8 +1887,6 @@ gfc_match_kind_spec (gfc_typespec *ts, bool kind_expr_only)\n \t    }\n \n \t  gfc_free_expr (e);\n-\t  ts->kind = -1;\n-\t  gfc_function_kind_locus = loc;\n \t  gfc_undo_symbols ();\n \t  return MATCH_YES;\n \t}\n@@ -1907,6 +1908,7 @@ gfc_match_kind_spec (gfc_typespec *ts, bool kind_expr_only)\n     }\n \n   msg = gfc_extract_int (e, &ts->kind);\n+\n   if (msg != NULL)\n     {\n       gfc_error (msg);\n@@ -1977,17 +1979,12 @@ match_char_kind (int * kind, int * is_iso_c)\n \n   n = gfc_match_init_expr (&e);\n \n-  if (n != MATCH_YES\n-      && (gfc_current_state () == COMP_INTERFACE\n-\t  || gfc_current_state () == COMP_NONE\n-\t  || gfc_current_state () == COMP_CONTAINS))\n+  if (n != MATCH_YES && gfc_matching_function)\n     {\n-      /* Signal using kind = -1 that the expression might include\n-\t use-associated or imported parameters and try again after\n-\t the specification expressions.  */\n+      /* The expression might include use-associated or imported\n+\t parameters and try again after the specification \n+\t expressions.  */\n       gfc_free_expr (e);\n-      *kind = -1;\n-      gfc_function_kind_locus = where;\n       gfc_undo_symbols ();\n       return MATCH_YES;\n     }\n@@ -2154,6 +2151,17 @@ match_char_spec (gfc_typespec *ts)\n   return m;\n \n done:\n+  /* Except in the case of the length being a function, where symbol\n+     association looks after itself, deal with character functions\n+     after the specification statements.  */\n+  if (gfc_matching_function\n+\t&& !(len && len->expr_type != EXPR_VARIABLE\n+\t\t && len->expr_type != EXPR_OP))\n+    {\n+      gfc_undo_symbols ();\n+      return MATCH_YES;\n+    }\n+\n   if (m != MATCH_YES)\n     {\n       gfc_free_expr (len);\n@@ -2209,9 +2217,16 @@ gfc_match_type_spec (gfc_typespec *ts, int implicit_flag)\n   gfc_symbol *sym;\n   match m;\n   int c;\n-  locus loc = gfc_current_locus;\n+  bool seen_deferred_kind;\n \n+  /* A belt and braces check that the typespec is correctly being treated\n+     as a deferred characteristic association.  */\n+  seen_deferred_kind = (gfc_current_state () == COMP_FUNCTION)\n+\t\t\t\t\t&& (gfc_current_block ()->result->ts.kind == -1)\n+\t\t\t\t\t&& (ts->kind == -1);\n   gfc_clear_ts (ts);\n+  if (seen_deferred_kind)\n+    ts->kind = -1;\n \n   /* Clear the current binding label, in case one is given.  */\n   curr_binding_label[0] = '\\0';\n@@ -2293,31 +2308,40 @@ gfc_match_type_spec (gfc_typespec *ts, int implicit_flag)\n   if (m != MATCH_YES)\n     return m;\n \n-  if (gfc_current_state () == COMP_INTERFACE\n-\t|| gfc_current_state () == COMP_NONE)\n+  ts->type = BT_DERIVED;\n+\n+  /* Defer association of the derived type until the end of the\n+     specification block.  However, if the derived type can be\n+     found, add it to the typespec.  */  \n+  if (gfc_matching_function)\n     {\n-      gfc_function_type_locus = loc;\n-      ts->type = BT_UNKNOWN;\n-      ts->kind = -1;\n+      ts->derived = NULL;\n+      if (gfc_current_state () != COMP_INTERFACE\n+\t    && !gfc_find_symbol (name, NULL, 1, &sym) && sym)\n+\tts->derived = sym;\n       return MATCH_YES;\n     }\n \n   /* Search for the name but allow the components to be defined later.  If\n      type = -1, this typespec has been seen in a function declaration but\n-     the type could not legally be accessed at that point.  */\n+     the type could not be accessed at that point.  */\n+  sym = NULL;\n   if (ts->kind != -1 && gfc_get_ha_symbol (name, &sym))\n     {\n       gfc_error (\"Type name '%s' at %C is ambiguous\", name);\n       return MATCH_ERROR;\n     }\n   else if (ts->kind == -1)\n     {\n-      if (gfc_find_symbol (name, NULL, 0, &sym))\n+      int iface = gfc_state_stack->previous->state != COMP_INTERFACE\n+\t\t    || gfc_current_ns->has_import_set;\n+      if (gfc_find_symbol (name, NULL, iface, &sym))\n \t{       \n \t  gfc_error (\"Type name '%s' at %C is ambiguous\", name);\n \t  return MATCH_ERROR;\n \t}\n \n+      ts->kind = 0;\n       if (sym == NULL)\n \treturn MATCH_NO;\n     }\n@@ -2326,8 +2350,7 @@ gfc_match_type_spec (gfc_typespec *ts, int implicit_flag)\n       && gfc_add_flavor (&sym->attr, FL_DERIVED, sym->name, NULL) == FAILURE)\n     return MATCH_ERROR;\n \n-  ts->type = BT_DERIVED;\n-  ts->kind = 0;\n+  gfc_set_sym_referenced (sym);\n   ts->derived = sym;\n \n   return MATCH_YES;\n@@ -2350,6 +2373,12 @@ gfc_match_type_spec (gfc_typespec *ts, int implicit_flag)\n   if (m == MATCH_NO && ts->type != BT_CHARACTER)\n     m = gfc_match_old_kind_spec (ts);\n \n+  /* Defer association of the KIND expression of function results\n+     until after USE and IMPORT statements.  */\n+  if ((gfc_current_state () == COMP_NONE && gfc_error_flag_test ())\n+\t || gfc_matching_function)\n+    return MATCH_YES;\n+\n   if (m == MATCH_NO)\n     m = MATCH_YES;\t\t/* No kind specifier found.  */\n \n@@ -3673,8 +3702,8 @@ gfc_match_data_decl (void)\n    can be matched.  Note that if nothing matches, MATCH_YES is\n    returned (the null string was matched).  */\n \n-static match\n-match_prefix (gfc_typespec *ts)\n+match\n+gfc_match_prefix (gfc_typespec *ts)\n {\n   bool seen_type;\n \n@@ -3720,7 +3749,7 @@ match_prefix (gfc_typespec *ts)\n }\n \n \n-/* Copy attributes matched by match_prefix() to attributes on a symbol.  */\n+/* Copy attributes matched by gfc_match_prefix() to attributes on a symbol.  */\n \n static try\n copy_prefix (symbol_attribute *dest, locus *where)\n@@ -4245,7 +4274,7 @@ gfc_match_function_decl (void)\n \n   old_loc = gfc_current_locus;\n \n-  m = match_prefix (&current_ts);\n+  m = gfc_match_prefix (&current_ts);\n   if (m != MATCH_YES)\n     {\n       gfc_current_locus = old_loc;\n@@ -4329,6 +4358,22 @@ gfc_match_function_decl (void)\n \t  goto cleanup;\n \t}\n \n+      /* Except in the case of a function valued character length,\n+\t delay matching the function characteristics until after the\n+\t specification block by signalling kind=-1.  */\n+      if (!(current_ts.type == BT_CHARACTER\n+\t      && current_ts.cl\n+\t      && current_ts.cl->length\n+\t      && current_ts.cl->length->expr_type != EXPR_OP\n+\t      && current_ts.cl->length->expr_type != EXPR_VARIABLE))\n+\t{\n+\t  sym->declared_at = old_loc;\n+\t  if (current_ts.type != BT_UNKNOWN)\n+\t    current_ts.kind = -1;\n+\t  else\n+\t    current_ts.kind = 0;\n+\t}\n+\n       if (result == NULL)\n \t{\n \t  sym->ts = current_ts;\n@@ -4635,7 +4680,7 @@ gfc_match_subroutine (void)\n       && gfc_current_state () != COMP_CONTAINS)\n     return MATCH_NO;\n \n-  m = match_prefix (NULL);\n+  m = gfc_match_prefix (NULL);\n   if (m != MATCH_YES)\n     return m;\n "}, {"sha": "aac1f821334c0f184350c6cfa1d7e761eb3b01aa", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c8bcdf715b0475effdd0cc2c27d461c3ce5540f/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c8bcdf715b0475effdd0cc2c27d461c3ce5540f/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=1c8bcdf715b0475effdd0cc2c27d461c3ce5540f", "patch": "@@ -223,7 +223,7 @@ typedef enum\n   ST_OMP_PARALLEL, ST_OMP_PARALLEL_DO, ST_OMP_PARALLEL_SECTIONS,\n   ST_OMP_PARALLEL_WORKSHARE, ST_OMP_SECTIONS, ST_OMP_SECTION, ST_OMP_SINGLE,\n   ST_OMP_THREADPRIVATE, ST_OMP_WORKSHARE, ST_PROCEDURE,\n-  ST_NONE\n+  ST_GET_FCN_CHARACTERISTICS, ST_NONE\n }\n gfc_statement;\n "}, {"sha": "5ee5434baeee3cdc558e13647764a0b4a046200a", "filename": "gcc/fortran/misc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c8bcdf715b0475effdd0cc2c27d461c3ce5540f/gcc%2Ffortran%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c8bcdf715b0475effdd0cc2c27d461c3ce5540f/gcc%2Ffortran%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmisc.c?ref=1c8bcdf715b0475effdd0cc2c27d461c3ce5540f", "patch": "@@ -74,8 +74,8 @@ void\n gfc_clear_ts (gfc_typespec *ts)\n {\n   ts->type = BT_UNKNOWN;\n-  ts->kind = 0;\n   ts->derived = NULL;\n+  ts->kind = 0;\n   ts->cl = NULL;\n   /* flag that says if the type is C interoperable */\n   ts->is_c_interop = 0;"}, {"sha": "e57e10df51df1ac341fd3fca25a9b355b0890081", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 202, "deletions": 28, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c8bcdf715b0475effdd0cc2c27d461c3ce5540f/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c8bcdf715b0475effdd0cc2c27d461c3ce5540f/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=1c8bcdf715b0475effdd0cc2c27d461c3ce5540f", "patch": "@@ -85,6 +85,144 @@ match_word (const char *str, match (*subr) (void), locus *old_locus)\n \tundo_new_statement ();\t\t\t\t  \\\n     } while (0);\n \n+\n+/* This is a specialist version of decode_statement that is used\n+   for the specification statements in a function, whose\n+   characteristics are deferred into the specification statements.\n+   eg.:  INTEGER (king = mykind) foo ()\n+\t USE mymodule, ONLY mykind..... \n+   The KIND parameter needs a return after USE or IMPORT, whereas\n+   derived type declarations can occur anywhere, up the executable\n+   block.  ST_GET_FCN_CHARACTERISTICS is returned when we have run\n+   out of the correct kind of specification statements.  */\n+static gfc_statement\n+decode_specification_statement (void)\n+{\n+  gfc_statement st;\n+  locus old_locus;\n+  int c;\n+\n+  if (gfc_match_eos () == MATCH_YES)\n+    return ST_NONE;\n+\n+  old_locus = gfc_current_locus;\n+\n+  match (\"import\", gfc_match_import, ST_IMPORT);\n+  match (\"use\", gfc_match_use, ST_USE);\n+\n+  if (gfc_numeric_ts (&gfc_current_block ()->ts))\n+    goto end_of_block;\n+\n+  match (NULL, gfc_match_st_function, ST_STATEMENT_FUNCTION);\n+  match (NULL, gfc_match_data_decl, ST_DATA_DECL);\n+  match (NULL, gfc_match_enumerator_def, ST_ENUMERATOR);\n+\n+  /* General statement matching: Instead of testing every possible\n+     statement, we eliminate most possibilities by peeking at the\n+     first character.  */\n+\n+  c = gfc_peek_char ();\n+\n+  switch (c)\n+    {\n+    case 'a':\n+      match (\"abstract% interface\", gfc_match_abstract_interface,\n+\t     ST_INTERFACE);\n+      break;\n+\n+    case 'b':\n+      match (NULL, gfc_match_bind_c_stmt, ST_ATTR_DECL);\n+      break;\n+\n+    case 'c':\n+      break;\n+\n+    case 'd':\n+      match (\"data\", gfc_match_data, ST_DATA);\n+      match (\"dimension\", gfc_match_dimension, ST_ATTR_DECL);\n+      break;\n+\n+    case 'e':\n+      match (\"enum , bind ( c )\", gfc_match_enum, ST_ENUM);\n+      match (\"entry% \", gfc_match_entry, ST_ENTRY);\n+      match (\"equivalence\", gfc_match_equivalence, ST_EQUIVALENCE);\n+      match (\"external\", gfc_match_external, ST_ATTR_DECL);\n+      break;\n+\n+    case 'f':\n+      match (\"format\", gfc_match_format, ST_FORMAT);\n+      break;\n+\n+    case 'g':\n+      break;\n+\n+    case 'i':\n+      match (\"implicit\", gfc_match_implicit, ST_IMPLICIT);\n+      match (\"implicit% none\", gfc_match_implicit_none, ST_IMPLICIT_NONE);\n+      match (\"interface\", gfc_match_interface, ST_INTERFACE);\n+      match (\"intent\", gfc_match_intent, ST_ATTR_DECL);\n+      match (\"intrinsic\", gfc_match_intrinsic, ST_ATTR_DECL);\n+      break;\n+\n+    case 'm':\n+      break;\n+\n+    case 'n':\n+      match (\"namelist\", gfc_match_namelist, ST_NAMELIST);\n+      break;\n+\n+    case 'o':\n+      match (\"optional\", gfc_match_optional, ST_ATTR_DECL);\n+      break;\n+\n+    case 'p':\n+      match (\"parameter\", gfc_match_parameter, ST_PARAMETER);\n+      match (\"pointer\", gfc_match_pointer, ST_ATTR_DECL);\n+      if (gfc_match_private (&st) == MATCH_YES)\n+\treturn st;\n+      match (\"procedure\", gfc_match_procedure, ST_PROCEDURE);\n+      if (gfc_match_public (&st) == MATCH_YES)\n+\treturn st;\n+      match (\"protected\", gfc_match_protected, ST_ATTR_DECL);\n+      break;\n+\n+    case 'r':\n+      break;\n+\n+    case 's':\n+      match (\"save\", gfc_match_save, ST_ATTR_DECL);\n+      break;\n+\n+    case 't':\n+      match (\"target\", gfc_match_target, ST_ATTR_DECL);\n+      match (\"type\", gfc_match_derived_decl, ST_DERIVED_DECL);\n+      break;\n+\n+    case 'u':\n+      break;\n+\n+    case 'v':\n+      match (\"value\", gfc_match_value, ST_ATTR_DECL);\n+      match (\"volatile\", gfc_match_volatile, ST_ATTR_DECL);\n+      break;\n+\n+    case 'w':\n+      break;\n+    }\n+\n+  /* This is not a specification statement.  See if any of the matchers\n+     has stored an error message of some sort.  */\n+\n+end_of_block:\n+  gfc_clear_error ();\n+  gfc_buffer_error (0);\n+  gfc_current_locus = old_locus;\n+\n+  return ST_GET_FCN_CHARACTERISTICS;\n+}\n+\n+\n+/* This is the primary 'decode_statement'.  */\n static gfc_statement\n decode_statement (void)\n {\n@@ -100,9 +238,15 @@ decode_statement (void)\n   gfc_clear_error ();\t/* Clear any pending errors.  */\n   gfc_clear_warning ();\t/* Clear any pending warnings.  */\n \n+  gfc_matching_function = false;\n+\n   if (gfc_match_eos () == MATCH_YES)\n     return ST_NONE;\n \n+  if (gfc_current_state () == COMP_FUNCTION\n+\t&& gfc_current_block ()->result->ts.kind == -1)\n+    return decode_specification_statement ();\n+\n   old_locus = gfc_current_locus;\n \n   /* Try matching a data declaration or function declaration. The\n@@ -113,6 +257,7 @@ decode_statement (void)\n       || gfc_current_state () == COMP_INTERFACE\n       || gfc_current_state () == COMP_CONTAINS)\n     {\n+      gfc_matching_function = true;\n       m = gfc_match_function_decl ();\n       if (m == MATCH_YES)\n \treturn ST_FUNCTION;\n@@ -122,6 +267,8 @@ decode_statement (void)\n \tgfc_undo_symbols ();\n       gfc_current_locus = old_locus;\n     }\n+  gfc_matching_function = false;\n+\n \n   /* Match statements whose error messages are meant to be overwritten\n      by something better.  */\n@@ -1870,30 +2017,48 @@ parse_interface (void)\n }\n \n \n-/* Recover use associated or imported function characteristics.  */\n+/* Associate function characteristics by going back to the function\n+   declaration and rematching the prefix.  */\n \n-static try\n+static match\n match_deferred_characteristics (gfc_typespec * ts)\n {\n   locus loc;\n-  match m;\n+  match m = MATCH_ERROR;\n+  char name[GFC_MAX_SYMBOL_LEN + 1];\n \n   loc = gfc_current_locus;\n \n-  if (gfc_current_block ()->ts.type != BT_UNKNOWN)\n+  gfc_current_locus = gfc_current_block ()->declared_at;\n+\n+  gfc_clear_error ();\n+  gfc_buffer_error (1);\n+  m = gfc_match_prefix (ts);\n+  gfc_buffer_error (0);\n+\n+  if (ts->type == BT_DERIVED)\n     {\n-      /* Kind expression for an intrinsic type.  */\n-      gfc_current_locus = gfc_function_kind_locus;\n-      m = gfc_match_kind_spec (ts, true);\n+      ts->kind = 0;\n+\n+      if (!ts->derived || !ts->derived->components)\n+\tm = MATCH_ERROR;\n     }\n-  else\n+\n+  /* Only permit one go at the characteristic association.  */\n+  if (ts->kind == -1)\n+    ts->kind = 0;\n+\n+  /* Set the function locus correctly.  If we have not found the\n+     function name, there is an error.  */\n+  gfc_match (\"function% %n\", name);\n+  if (m == MATCH_YES && strcmp (name, gfc_current_block ()->name) == 0)\n     {\n-      /* A derived type.  */\n-      gfc_current_locus = gfc_function_type_locus;\n-      m = gfc_match_type_spec (ts, 0);\n+      gfc_current_block ()->declared_at = gfc_current_locus;\n+      gfc_commit_symbols ();\n     }\n+  else\n+    gfc_error_check ();\n \n-  gfc_current_ns->proc_name->result->ts = *ts;\n   gfc_current_locus =loc;\n   return m;\n }\n@@ -1906,6 +2071,8 @@ static gfc_statement\n parse_spec (gfc_statement st)\n {\n   st_state ss;\n+  bool bad_characteristic = false;\n+  gfc_typespec *ts;\n \n   verify_st_order (&ss, ST_NONE);\n   if (st == ST_NONE)\n@@ -1984,15 +2151,6 @@ parse_spec (gfc_statement st)\n \t}\n \n       accept_statement (st);\n-\n-      /* Look out for function kind/type information that used\n-\t use associated or imported parameter.  This is signalled\n-\t by kind = -1.  */\n-      if (gfc_current_state () == COMP_FUNCTION\n-\t    && (st == ST_USE || st == ST_IMPORT || st == ST_DERIVED_DECL)\n-\t    && gfc_current_block ()->ts.kind == -1)\n-\tmatch_deferred_characteristics (&gfc_current_block ()->ts);\n-\n       st = next_statement ();\n       goto loop;\n \n@@ -2002,21 +2160,37 @@ parse_spec (gfc_statement st)\n       st = next_statement ();\n       goto loop;\n \n+    case ST_GET_FCN_CHARACTERISTICS:\n+      /* This statement triggers the association of a function's result\n+\t characteristics.  */\n+      ts = &gfc_current_block ()->result->ts;\n+      if (match_deferred_characteristics (ts) != MATCH_YES)\n+\tbad_characteristic = true;\n+\n+      st = next_statement ();\n+      goto loop;\n+\n     default:\n       break;\n     }\n \n-  /* If we still have kind = -1 at the end of the specification block,\n-     then there is an error. */\n-  if (gfc_current_state () == COMP_FUNCTION\n-\t&& gfc_current_block ()->ts.kind == -1)\n+  /* If match_deferred_characteristics failed, then there is an error. */\n+  if (bad_characteristic)\n     {\n-      if (gfc_current_block ()->ts.type != BT_UNKNOWN)\n+      ts = &gfc_current_block ()->result->ts;\n+      if (ts->type != BT_DERIVED)\n \tgfc_error (\"Bad kind expression for function '%s' at %L\",\n-\t\t   gfc_current_block ()->name, &gfc_function_kind_locus);\n+\t\t   gfc_current_block ()->name,\n+\t\t   &gfc_current_block ()->declared_at);\n       else\n \tgfc_error (\"The type for function '%s' at %L is not accessible\",\n-\t\t   gfc_current_block ()->name, &gfc_function_type_locus);\n+\t\t   gfc_current_block ()->name,\n+\t\t   &gfc_current_block ()->declared_at);\n+\n+      gfc_current_block ()->ts.kind = 0;\n+      /* Keep the derived type; if it's bad, it will be discovered later.  */\n+      if (!(ts->type = BT_DERIVED && ts->derived))\n+        ts->type = BT_UNKNOWN;\n     }\n \n   return st;"}, {"sha": "be885bb013b44c93694150c8167d1ad2817d1369", "filename": "gcc/fortran/parse.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c8bcdf715b0475effdd0cc2c27d461c3ce5540f/gcc%2Ffortran%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c8bcdf715b0475effdd0cc2c27d461c3ce5540f/gcc%2Ffortran%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.h?ref=1c8bcdf715b0475effdd0cc2c27d461c3ce5540f", "patch": "@@ -66,7 +66,6 @@ const char *gfc_ascii_statement (gfc_statement);\n match gfc_match_enum (void);\n match gfc_match_enumerator_def (void);\n void gfc_free_enum_history (void);\n-extern locus gfc_function_kind_locus;\n-extern locus gfc_function_type_locus;\n-\n+extern bool gfc_matching_function;\n+match gfc_match_prefix (gfc_typespec *);\n #endif  /* GFC_PARSE_H  */"}, {"sha": "c86bb458da5ab52804a726a35617e3718209b710", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c8bcdf715b0475effdd0cc2c27d461c3ce5540f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c8bcdf715b0475effdd0cc2c27d461c3ce5540f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1c8bcdf715b0475effdd0cc2c27d461c3ce5540f", "patch": "@@ -1,3 +1,23 @@\n+2008-01-17  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/34429\n+\t* gfortran.dg/function_charlen_1.f90: New test.\n+\n+\tPR fortran/34431\n+\t* gfortran.dg/function_types_1.f90: New test.\n+\t* gfortran.dg/function_types_2.f90: New test.\n+\n+\tPR fortran/34471\n+\t* gfortran.dg/function_kinds_4.f90: New test.\n+\t* gfortran.dg/function_kinds_5.f90: New test.\n+\n+\t* gfortran.dg/defined_operators_1.f90: Errors now at function\n+\tdeclarations.\n+\t* gfortran.dg/private_type_4.f90: The same.\n+\t* gfortran.dg/interface_15.f90: The same.\n+\t* gfortran.dg/elemental_args_check_2.f90: The same.\n+\t* gfortran.dg/auto_internal_assumed.f90: The same.\n+\n 2008-01-16  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/sizetype.adb: New test."}, {"sha": "ec0ea7f1510a63cfc6eacd0c96db7bfd99877b8d", "filename": "gcc/testsuite/gfortran.dg/auto_internal_assumed.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c8bcdf715b0475effdd0cc2c27d461c3ce5540f/gcc%2Ftestsuite%2Fgfortran.dg%2Fauto_internal_assumed.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c8bcdf715b0475effdd0cc2c27d461c3ce5540f/gcc%2Ftestsuite%2Fgfortran.dg%2Fauto_internal_assumed.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fauto_internal_assumed.f90?ref=1c8bcdf715b0475effdd0cc2c27d461c3ce5540f", "patch": "@@ -3,10 +3,10 @@\n ! internal function.\n !\n character (6) :: c\n-  c = f1 ()        ! { dg-error \"must not be assumed length\" }\n+  c = f1 ()\n   if (c .ne. 'abcdef') call abort\n contains\n-  function f1 ()\n+  function f1 () ! { dg-error \"must not be assumed length\" }\n     character (*) :: f1\n     f1 = 'abcdef'\n   end function f1"}, {"sha": "bd25021604be999a5c7ccd8c4c849ba838bdf966", "filename": "gcc/testsuite/gfortran.dg/defined_operators_1.f90", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c8bcdf715b0475effdd0cc2c27d461c3ce5540f/gcc%2Ftestsuite%2Fgfortran.dg%2Fdefined_operators_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c8bcdf715b0475effdd0cc2c27d461c3ce5540f/gcc%2Ftestsuite%2Fgfortran.dg%2Fdefined_operators_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdefined_operators_1.f90?ref=1c8bcdf715b0475effdd0cc2c27d461c3ce5540f", "patch": "@@ -7,10 +7,10 @@\n !\n module mymod\n   interface operator (.foo.)\n-     module procedure foo_0 ! { dg-error \"must have at least one argument\" }\n-     module procedure foo_1 ! { dg-error \"must be INTENT\" }\n-     module procedure foo_2 ! { dg-error \"cannot be optional\" }\n-     module procedure foo_3 ! { dg-error \"must have, at most, two arguments\" }\n+     module procedure foo_0\n+     module procedure foo_1\n+     module procedure foo_2\n+     module procedure foo_3\n      module procedure foo_1_OK  ! { dg-error \"Ambiguous interfaces\" }\n      module procedure foo_2_OK\n      function foo_chr (chr) ! { dg-error \"cannot be assumed character length\" }\n@@ -22,11 +22,11 @@ subroutine bad_foo (chr) ! { dg-error \"must be a FUNCTION\" }\n      end subroutine bad_foo\n   end interface\n contains\n-  function foo_0 ()\n+  function foo_0 () ! { dg-error \"must have at least one argument\" }\n     integer :: foo_1\n     foo_0 = 1\n   end function foo_0\n-  function foo_1 (a)\n+  function foo_1 (a) ! { dg-error \"must be INTENT\" }\n     integer :: foo_1\n     integer :: a\n     foo_1 = 1\n@@ -36,7 +36,7 @@ function foo_1_OK (a)\n     integer, intent (in) :: a\n     foo_1_OK = 1\n   end function foo_1_OK\n-  function foo_2 (a, b)\n+  function foo_2 (a, b) ! { dg-error \"cannot be optional\" }\n     integer :: foo_2\n     integer, intent(in) :: a\n     integer, intent(in), optional :: b\n@@ -48,7 +48,7 @@ function foo_2_OK (a, b)\n     real, intent(in) :: b\n     foo_2_OK = 2.0 * a + b\n   end function foo_2_OK\n-  function foo_3 (a, b, c)\n+  function foo_3 (a, b, c) ! { dg-error \"must have, at most, two arguments\" }\n     integer :: foo_3\n     integer, intent(in) :: a, b, c\n     foo_3 = a + 3 * b - c"}, {"sha": "51e69a49ee463b139fda386c3e4e99b9dc1bf94b", "filename": "gcc/testsuite/gfortran.dg/elemental_args_check_2.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c8bcdf715b0475effdd0cc2c27d461c3ce5540f/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_args_check_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c8bcdf715b0475effdd0cc2c27d461c3ce5540f/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_args_check_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_args_check_2.f90?ref=1c8bcdf715b0475effdd0cc2c27d461c3ce5540f", "patch": "@@ -8,10 +8,10 @@\n MODULE M1\n IMPLICIT NONE\n CONTAINS\n- PURE ELEMENTAL SUBROUTINE S1(I,F) ! { dg-error \"Dummy procedure 'f' not allowed in elemental procedure\" }\n+ PURE ELEMENTAL SUBROUTINE S1(I,F)\n    INTEGER, INTENT(IN) :: I\n    INTERFACE\n-     PURE INTEGER FUNCTION F(I)\n+     PURE INTEGER FUNCTION F(I) ! { dg-error \"Dummy procedure 'f' not allowed in elemental procedure\" }\n       INTEGER, INTENT(IN) :: I\n      END FUNCTION F\n    END INTERFACE"}, {"sha": "e0ecc63b89f60973b5a72f8a3433b628f262fefd", "filename": "gcc/testsuite/gfortran.dg/function_charlen_1.f90", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c8bcdf715b0475effdd0cc2c27d461c3ce5540f/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_charlen_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c8bcdf715b0475effdd0cc2c27d461c3ce5540f/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_charlen_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_charlen_1.f90?ref=1c8bcdf715b0475effdd0cc2c27d461c3ce5540f", "patch": "@@ -0,0 +1,23 @@\n+! { dg-do compile }\n+! Tests the fix for PR34429 in which function charlens that were\n+! USE associated would cause an error.\n+!\n+! Contributed by Tobias Burnus <burnus@gcc.gnu.org>\n+!\n+module m\n+  integer, parameter :: strlen = 5\n+end module m\n+\n+character(strlen) function test()\n+  use m\n+  test = 'A'\n+end function test\n+\n+  interface\n+    character(strlen) function test()\n+      use m\n+    end function test\n+  end interface\n+  print *, test()\n+end\n+! { dg-final { cleanup-modules \"m\" } }"}, {"sha": "bcde1e4478e2d85d13f118141cb96deb02866d06", "filename": "gcc/testsuite/gfortran.dg/function_kinds_4.f90", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c8bcdf715b0475effdd0cc2c27d461c3ce5540f/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_kinds_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c8bcdf715b0475effdd0cc2c27d461c3ce5540f/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_kinds_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_kinds_4.f90?ref=1c8bcdf715b0475effdd0cc2c27d461c3ce5540f", "patch": "@@ -0,0 +1,56 @@\n+! { dg-do run }\n+! Tests the fix for PR34471 in which function KINDs that were\n+! USE associated would cause an error.\n+!\n+! This only needs to be run once.\n+! { dg-options \"-O2\" }\n+!\n+! Contributed by Tobias Burnus <burnus@gcc.gnu.org>\n+!\n+module m1\n+  integer, parameter :: i1 = 1, i2 = 2\n+end module m1\n+\n+module m2\n+  integer, parameter :: i1 = 8\n+end module m2\n+\n+integer(i1) function three()\n+  use m1, only: i2\n+  use m2                ! This provides the function kind\n+  three = i1\n+  if(three /= kind(three)) call abort()\n+end function three\n+\n+! At one stage during the development of the patch, this started failing\n+! but was not tested in gfortran.dg.  */\n+real (kind(0d0)) function foo ()\n+  foo = real (kind (foo))\n+end function\n+\n+program main\n+implicit none\n+ interface\n+    integer(8) function three()\n+    end function three\n+ end interface\n+ integer, parameter :: i1 = 4\n+ integer :: i\n+ real (kind(0d0)) foo\n+ i = one()\n+ i = two()\n+ if(three() /= 8) call abort()\n+ if (int(foo()) /= 8) call abort ()\n+contains\n+ integer(i1) function one()  ! Host associated kind\n+   if (kind(one) /= 4) call abort()\n+   one = 1\n+ end function one\n+ integer(i1) function two()  ! Use associated kind\n+   use m1, only: i2\n+   use m2\n+   if (kind(two) /= 8) call abort()\n+   two = 1\n+ end function two\n+end program main\n+! { dg-final { cleanup-modules \"m1 m2\" } }"}, {"sha": "fde5bef12f8d213b96255c554580eb7f0611e7a9", "filename": "gcc/testsuite/gfortran.dg/function_kinds_5.f90", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c8bcdf715b0475effdd0cc2c27d461c3ce5540f/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_kinds_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c8bcdf715b0475effdd0cc2c27d461c3ce5540f/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_kinds_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_kinds_5.f90?ref=1c8bcdf715b0475effdd0cc2c27d461c3ce5540f", "patch": "@@ -0,0 +1,10 @@\n+! { dg-do compile }\n+! Tests the fix for PR34471 in which function KINDs that were\n+! USE associated would cause an error.  This checks a regression\n+! caused by an intermediate version of the patch.\n+!\n+! Contributed by Tobias Burnus <burnus@gcc.gnu.org>\n+!\n+real (bad_kind(0d0)) function foo () ! { dg-error \"must be an intrinsic or\" }\n+  foo = real (kind (foo))\n+end function"}, {"sha": "fb18d2f0e5051e76b861d9249ab5a7522441fc7a", "filename": "gcc/testsuite/gfortran.dg/function_types_1.f90", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c8bcdf715b0475effdd0cc2c27d461c3ce5540f/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_types_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c8bcdf715b0475effdd0cc2c27d461c3ce5540f/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_types_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_types_1.f90?ref=1c8bcdf715b0475effdd0cc2c27d461c3ce5540f", "patch": "@@ -0,0 +1,12 @@\n+! { dg-do compile }\n+! Tests the fix for PR34431 in which function TYPEs that were\n+! USE associated would cause an error.\n+!\n+! Contributed by Tobias Burnus <burnus@gcc.gnu.org>\n+!\n+module bar\n+contains\n+  type(non_exist) function func2() ! { dg-error \"not accessible\" }\n+  end function func2\n+end module bar\n+! { dg-final { cleanup-modules \"bar\" } }"}, {"sha": "b3b5a0aee9c66010fd2eed1df3bbbc465ecb7209", "filename": "gcc/testsuite/gfortran.dg/function_types_2.f90", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c8bcdf715b0475effdd0cc2c27d461c3ce5540f/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_types_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c8bcdf715b0475effdd0cc2c27d461c3ce5540f/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_types_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_types_2.f90?ref=1c8bcdf715b0475effdd0cc2c27d461c3ce5540f", "patch": "@@ -0,0 +1,104 @@\n+! { dg-do compile }\n+! Tests the fix for PR34431 in which function TYPEs that were\n+! USE associated would cause an error.\n+!\n+! Contributed by Tobias Burnus <burnus@gcc.gnu.org>\n+!\n+module m1\n+  integer :: hh\n+  type t\n+    real :: r\n+  end type t\n+end module m1\n+\n+module m2\n+  type t\n+    integer :: k\n+  end type t\n+end module m2\n+\n+module m3\n+contains\n+  type(t) function func()\n+    use m2\n+    func%k = 77\n+  end function func\n+end module m3\n+\n+type(t) function a()\n+  use m1, only: hh\n+  type t2\n+    integer :: j\n+  end type t2\n+  type t\n+    logical :: b\n+  end type t\n+\n+  a%b = .true.\n+end function a\n+\n+type(t) function b()\n+  use m1, only: hh\n+  use m2\n+  use m3\n+  b = func ()\n+  b%k = 5\n+end function b\n+\n+type(t) function c()\n+  use m1, only: hh\n+  type t2\n+    integer :: j\n+  end type t2\n+  type t\n+    logical :: b\n+  end type t\n+\n+  c%b = .true.\n+end function c\n+\n+program main\n+  type t\n+    integer :: m\n+  end type t\n+contains\n+  type(t) function a1()\n+    use m1, only: hh\n+    type t2\n+      integer :: j\n+    end type t2\n+    type t\n+      logical :: b\n+    end type t\n+\n+    a1%b = .true.\n+  end function a1\n+\n+  type(t) function b1()\n+    use m1, only: hh\n+    use m2, only: t\n+! NAG f95 believes that the host-associated type(t)\n+! should be used:\n+!   b1%m = 5\n+! However, I (Tobias Burnus) believe that the use-associated one should\n+! be used:\n+    b1%k = 5\n+  end function b1\n+\n+  type(t) function c1()\n+    use m1, only: hh\n+    type t2\n+      integer :: j\n+    end type t2\n+    type t\n+      logical :: b\n+    end type t\n+\n+    c1%b = .true.\n+  end function c1\n+\n+  type(t) function d1()\n+    d1%m = 55\n+  end function d1\n+end program main\n+! { dg-final { cleanup-modules \"m1 m2 m3\" } }"}, {"sha": "2186061586f5b229906a12d7454f75a9ed23c7b1", "filename": "gcc/testsuite/gfortran.dg/interface_15.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c8bcdf715b0475effdd0cc2c27d461c3ce5540f/gcc%2Ftestsuite%2Fgfortran.dg%2Finterface_15.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c8bcdf715b0475effdd0cc2c27d461c3ce5540f/gcc%2Ftestsuite%2Fgfortran.dg%2Finterface_15.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finterface_15.f90?ref=1c8bcdf715b0475effdd0cc2c27d461c3ce5540f", "patch": "@@ -8,12 +8,12 @@ MODULE M1\n     INTEGER :: I\n   END TYPE T1\n   INTERFACE I\n-    MODULE PROCEDURE F1        ! { dg-error \"PUBLIC interface\" }\n+    MODULE PROCEDURE F1\n   END INTERFACE\n   PRIVATE ! :: T1,F1\n   PUBLIC  :: I\n CONTAINS\n-  INTEGER FUNCTION F1(D)\n+  INTEGER FUNCTION F1(D)  ! { dg-error \"PUBLIC interface\" }\n     TYPE(T1) :: D\n     F1 = D%I\n   END FUNCTION"}, {"sha": "9ff39b267cdd17f77627b5176e151e3c947ec3a8", "filename": "gcc/testsuite/gfortran.dg/private_type_4.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c8bcdf715b0475effdd0cc2c27d461c3ce5540f/gcc%2Ftestsuite%2Fgfortran.dg%2Fprivate_type_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c8bcdf715b0475effdd0cc2c27d461c3ce5540f/gcc%2Ftestsuite%2Fgfortran.dg%2Fprivate_type_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fprivate_type_4.f90?ref=1c8bcdf715b0475effdd0cc2c27d461c3ce5540f", "patch": "@@ -7,11 +7,11 @@ module m1\n     end type t1\n \n     private :: t1\n-    public :: f1     ! { dg-error \"cannot be of PRIVATE type\" }\n+    public :: f1\n \n contains\n \n-    type(t1) function f1()\n+    type(t1) function f1() ! { dg-error \"cannot be of PRIVATE type\" }\n     end function\n \n end module"}]}