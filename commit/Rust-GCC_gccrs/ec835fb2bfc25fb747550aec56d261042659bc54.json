{"sha": "ec835fb2bfc25fb747550aec56d261042659bc54", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWM4MzVmYjJiZmMyNWZiNzQ3NTUwYWVjNTZkMjYxMDQyNjU5YmM1NA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2004-03-16T22:18:11Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2004-03-16T22:18:11Z"}, "message": "re PR c++/14586 (Bogus warning in templates about taking address of a temporary in a template)\n\n\tPR c++/14586\n\t* cp-tree.h (build_new_op): Change prototype.\n\t(build_x_binary_op): Likewise.\n\t* call.c (build_new_op): Add overloaded_p parameter.\n\t* decl2.c (grok_array_decl): Adjust call to build_new_op.\n\t* parser.c (cp_parser_binary_expression): Note that uses of\n\toverloaded operators prevents an expression from being considered\n\tan integral constant.\n\t* pt.c (tsubst_copy_and_build): Adjust calls to build_new_op and/or\n\tbuild_x_binary_op.\n\t* semantics.c (finish_call_expr): Likewise.\n\t* typeck.c (rationalize_conditional_expr): Likewise.\n\t(build_x_indirect_ref): Likewise.\n\t(build_x_binary_op): Likewise.\n\t(build_x_unary_op): Likewise.\n\t(build_x_compound_expr): Likewise.\n\t(build_modify_expr): Likewise.\n\t* typeck2.c (build_x_arrow): Likewise.\n\n\tPR c++/14586\n\t* g++.dg/parse/non-dependent3.C: New test.\n\nFrom-SVN: r79553", "tree": {"sha": "c0d3485bbb98b41f57f677cc06f2b3179fd1f192", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c0d3485bbb98b41f57f677cc06f2b3179fd1f192"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec835fb2bfc25fb747550aec56d261042659bc54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec835fb2bfc25fb747550aec56d261042659bc54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec835fb2bfc25fb747550aec56d261042659bc54", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec835fb2bfc25fb747550aec56d261042659bc54/comments", "author": null, "committer": null, "parents": [{"sha": "1e0f07d3952be55a453ad3ac7c326481b82f0d59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e0f07d3952be55a453ad3ac7c326481b82f0d59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e0f07d3952be55a453ad3ac7c326481b82f0d59"}], "stats": {"total": 108, "additions": 91, "deletions": 17}, "files": [{"sha": "408fa1ce7dc091bd3a6baae534b32600a0731d89", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec835fb2bfc25fb747550aec56d261042659bc54/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec835fb2bfc25fb747550aec56d261042659bc54/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ec835fb2bfc25fb747550aec56d261042659bc54", "patch": "@@ -1,3 +1,24 @@\n+2004-03-16  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/14586\n+\t* cp-tree.h (build_new_op): Change prototype.\n+\t(build_x_binary_op): Likewise.\n+\t* call.c (build_new_op): Add overloaded_p parameter.\n+\t* decl2.c (grok_array_decl): Adjust call to build_new_op.\n+\t* parser.c (cp_parser_binary_expression): Note that uses of\n+\toverloaded operators prevents an expression from being considered\n+\tan integral constant.\n+\t* pt.c (tsubst_copy_and_build): Adjust calls to build_new_op and/or\n+\tbuild_x_binary_op.\n+\t* semantics.c (finish_call_expr): Likewise.\n+\t* typeck.c (rationalize_conditional_expr): Likewise.\n+\t(build_x_indirect_ref): Likewise.\n+\t(build_x_binary_op): Likewise.\n+\t(build_x_unary_op): Likewise.\n+\t(build_x_compound_expr): Likewise.\n+\t(build_modify_expr): Likewise.\n+\t* typeck2.c (build_x_arrow): Likewise.\n+\n 2004-03-15  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* cp-lang.c, ptree.c: Update copyright."}, {"sha": "62182f3950ceee74737a90497a78dc42def09103", "filename": "gcc/cp/call.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec835fb2bfc25fb747550aec56d261042659bc54/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec835fb2bfc25fb747550aec56d261042659bc54/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=ec835fb2bfc25fb747550aec56d261042659bc54", "patch": "@@ -3555,7 +3555,8 @@ add_candidates (tree fns, tree args,\n }\n \n tree\n-build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3)\n+build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n+\t      bool *overloaded_p)\n {\n   struct z_candidate *candidates = 0, *cand;\n   tree arglist, fnname;\n@@ -3707,7 +3708,8 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3)\n \t    code = PREINCREMENT_EXPR;\n \t  else\n \t    code = PREDECREMENT_EXPR;\t\n-\t  result = build_new_op (code, flags, arg1, NULL_TREE, NULL_TREE);\n+\t  result = build_new_op (code, flags, arg1, NULL_TREE, NULL_TREE,\n+\t\t\t\t overloaded_p);\n \t  break;\n \n \t  /* The caller will deal with these.  */\n@@ -3742,6 +3744,9 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3)\n \t}\n       else if (TREE_CODE (cand->fn) == FUNCTION_DECL)\n \t{\n+\t  if (overloaded_p)\n+\t    *overloaded_p = true;\n+\n \t  if (warn_synth\n \t      && fnname == ansi_assopname (NOP_EXPR)\n \t      && DECL_ARTIFICIAL (cand->fn)"}, {"sha": "16e0abee7de8590697eed4505ebbd66aeb3450ab", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec835fb2bfc25fb747550aec56d261042659bc54/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec835fb2bfc25fb747550aec56d261042659bc54/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=ec835fb2bfc25fb747550aec56d261042659bc54", "patch": "@@ -3491,7 +3491,7 @@ extern tree build_new_function_call (tree, tree);\n extern tree build_operator_new_call (tree, tree, tree *, tree *);\n extern tree build_new_method_call (tree, tree, tree, tree, int);\n extern tree build_special_member_call (tree, tree, tree, tree, int);\n-extern tree build_new_op (enum tree_code, int, tree, tree, tree);\n+extern tree build_new_op (enum tree_code, int, tree, tree, tree, bool *);\n extern tree build_op_delete_call (enum tree_code, tree, tree, bool, tree);\n extern bool can_convert (tree, tree);\n extern bool can_convert_arg (tree, tree, tree);\n@@ -4177,7 +4177,8 @@ extern tree build_indirect_ref\t\t\t(tree, const char *);\n extern tree build_array_ref\t\t\t(tree, tree);\n extern tree get_member_function_from_ptrfunc\t(tree *, tree);\n extern tree convert_arguments\t\t\t(tree, tree, tree, int);\n-extern tree build_x_binary_op\t\t\t(enum tree_code, tree, tree);\n+extern tree build_x_binary_op\t\t\t(enum tree_code, tree, tree, \n+\t\t\t\t\t\t bool *);\n extern tree build_x_unary_op\t\t\t(enum tree_code, tree);\n extern tree unary_complex_lvalue\t\t(enum tree_code, tree);\n extern tree build_x_conditional_expr\t\t(tree, tree, tree);"}, {"sha": "baf1adf9ed5faec98e7d14880e6cd5cc759a58e9", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec835fb2bfc25fb747550aec56d261042659bc54/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec835fb2bfc25fb747550aec56d261042659bc54/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=ec835fb2bfc25fb747550aec56d261042659bc54", "patch": "@@ -380,7 +380,8 @@ grok_array_decl (tree array_expr, tree index_exp)\n   /* If they have an `operator[]', use that.  */\n   if (IS_AGGR_TYPE (type) || IS_AGGR_TYPE (TREE_TYPE (index_exp)))\n     expr = build_new_op (ARRAY_REF, LOOKUP_NORMAL,\n-\t\t\t array_expr, index_exp, NULL_TREE);\n+\t\t\t array_expr, index_exp, NULL_TREE,\n+\t\t\t /*overloaded_p=*/NULL);\n   else\n     {\n       tree p1, p2, i1, i2;"}, {"sha": "db4025251f4d779874ba8cc6ad227c3901eb861a", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec835fb2bfc25fb747550aec56d261042659bc54/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec835fb2bfc25fb747550aec56d261042659bc54/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=ec835fb2bfc25fb747550aec56d261042659bc54", "patch": "@@ -13975,12 +13975,26 @@ cp_parser_binary_expression (cp_parser* parser,\n \t   ++map_node)\n \tif (map_node->token_type == token->type)\n \t  {\n+\t    /* Assume that an overloaded operator will not be used.  */\n+\t    bool overloaded_p = false;\n+\n \t    /* Consume the operator token.  */\n \t    cp_lexer_consume_token (parser->lexer);\n \t    /* Parse the right-hand side of the expression.  */\n \t    rhs = (*fn) (parser);\n \t    /* Build the binary tree node.  */\n-\t    lhs = build_x_binary_op (map_node->tree_type, lhs, rhs);\n+\t    lhs = build_x_binary_op (map_node->tree_type, lhs, rhs, \n+\t\t\t\t     &overloaded_p);\n+\t    /* If the binary operator required the use of an\n+\t       overloaded operator, then this expression cannot be an\n+\t       integral constant-expression.  An overloaded operator\n+\t       can be used even if both operands are otherwise\n+\t       permissible in an integral constant-expression if at\n+\t       least one of the operands is of enumeration type.  */\n+\t    if (overloaded_p\n+\t\t&& (cp_parser_non_integral_constant_expression \n+\t\t    (parser, \"calls to overloaded operators\")))\n+\t      lhs = error_mark_node;\n \t    break;\n \t  }\n "}, {"sha": "6001b1c027dd56791fabc11a829a0f9781076115", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec835fb2bfc25fb747550aec56d261042659bc54/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec835fb2bfc25fb747550aec56d261042659bc54/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=ec835fb2bfc25fb747550aec56d261042659bc54", "patch": "@@ -8271,7 +8271,8 @@ tsubst_copy_and_build (tree t,\n       return build_x_binary_op\n \t(TREE_CODE (t), \n \t RECUR (TREE_OPERAND (t, 0)),\n-\t RECUR (TREE_OPERAND (t, 1)));\n+\t RECUR (TREE_OPERAND (t, 1)),\n+\t /*overloaded_p=*/NULL);\n \n     case SCOPE_REF:\n       return tsubst_qualified_id (t, args, complain, in_decl, /*done=*/true,"}, {"sha": "9142a2c1218682bc84462d8ae7d1cf70dc7f2edf", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec835fb2bfc25fb747550aec56d261042659bc54/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec835fb2bfc25fb747550aec56d261042659bc54/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=ec835fb2bfc25fb747550aec56d261042659bc54", "patch": "@@ -1729,7 +1729,8 @@ finish_call_expr (tree fn, tree args, bool disallow_virtual, bool koenig_p)\n   else if (CLASS_TYPE_P (TREE_TYPE (fn)))\n     /* If the \"function\" is really an object of class type, it might\n        have an overloaded `operator ()'.  */\n-    result = build_new_op (CALL_EXPR, LOOKUP_NORMAL, fn, args, NULL_TREE);\n+    result = build_new_op (CALL_EXPR, LOOKUP_NORMAL, fn, args, NULL_TREE,\n+\t\t\t   /*overloaded_p=*/NULL);\n   if (!result)\n     /* A call where the function is unknown.  */\n     result = build_function_call (fn, args);"}, {"sha": "31ca3e0ce001b414f21b240f6506327cd6d91276", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec835fb2bfc25fb747550aec56d261042659bc54/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec835fb2bfc25fb747550aec56d261042659bc54/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=ec835fb2bfc25fb747550aec56d261042659bc54", "patch": "@@ -1493,7 +1493,8 @@ rationalize_conditional_expr (enum tree_code code, tree t)\n \tbuild_conditional_expr (build_x_binary_op ((TREE_CODE (t) == MIN_EXPR\n \t\t\t\t\t\t    ? LE_EXPR : GE_EXPR),\n \t\t\t\t\t\t   TREE_OPERAND (t, 0),\n-\t\t\t\t\t\t   TREE_OPERAND (t, 1)),\n+\t\t\t\t\t\t   TREE_OPERAND (t, 1),\n+\t\t\t\t\t\t   /*overloaded_p=*/NULL),\n \t\t\t    build_unary_op (code, TREE_OPERAND (t, 0), 0),\n \t\t\t    build_unary_op (code, TREE_OPERAND (t, 1), 0));\n     }\n@@ -2026,7 +2027,7 @@ build_x_indirect_ref (tree expr, const char *errorstring)\n     }\n \n   rval = build_new_op (INDIRECT_REF, LOOKUP_NORMAL, expr, NULL_TREE,\n-\t\t       NULL_TREE);\n+\t\t       NULL_TREE, /*overloaded_p=*/NULL);\n   if (!rval)\n     rval = build_indirect_ref (expr, errorstring);\n \n@@ -2653,7 +2654,8 @@ convert_arguments (tree typelist, tree values, tree fndecl, int flags)\n    conversions on the operands.  CODE is the kind of expression to build.  */\n \n tree\n-build_x_binary_op (enum tree_code code, tree arg1, tree arg2)\n+build_x_binary_op (enum tree_code code, tree arg1, tree arg2, \n+\t\t   bool *overloaded_p)\n {\n   tree orig_arg1;\n   tree orig_arg2;\n@@ -2674,7 +2676,8 @@ build_x_binary_op (enum tree_code code, tree arg1, tree arg2)\n   if (code == DOTSTAR_EXPR)\n     expr = build_m_component_ref (arg1, arg2);\n   else\n-    expr = build_new_op (code, LOOKUP_NORMAL, arg1, arg2, NULL_TREE);\n+    expr = build_new_op (code, LOOKUP_NORMAL, arg1, arg2, NULL_TREE, \n+\t\t\t overloaded_p);\n \n   if (processing_template_decl && expr != error_mark_node)\n     return build_min_non_dep (code, expr, orig_arg1, orig_arg2);\n@@ -3531,7 +3534,8 @@ build_x_unary_op (enum tree_code code, tree xarg)\n \t  || (TREE_CODE (xarg) == OFFSET_REF)))\n     /* Don't look for a function.  */;\n   else\n-    exp = build_new_op (code, LOOKUP_NORMAL, xarg, NULL_TREE, NULL_TREE);\n+    exp = build_new_op (code, LOOKUP_NORMAL, xarg, NULL_TREE, NULL_TREE,\n+\t\t\t/*overloaded_p=*/NULL);\n   if (!exp && code == ADDR_EXPR)\n     {\n       /*  A pointer to member-function can be formed only by saying\n@@ -4371,7 +4375,8 @@ build_x_compound_expr (tree op1, tree op2)\n       op2 = build_non_dependent_expr (op2);\n     }\n \n-  result = build_new_op (COMPOUND_EXPR, LOOKUP_NORMAL, op1, op2, NULL_TREE);\n+  result = build_new_op (COMPOUND_EXPR, LOOKUP_NORMAL, op1, op2, NULL_TREE,\n+\t\t\t /*overloaded_p=*/NULL);\n   if (!result)\n     result = build_compound_expr (op1, op2);\n \n@@ -5065,7 +5070,8 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n \t  else\n \t    {\n \t      result = build_new_op (MODIFY_EXPR, LOOKUP_NORMAL,\n-\t\t\t\t     lhs, rhs, make_node (NOP_EXPR));\n+\t\t\t\t     lhs, rhs, make_node (NOP_EXPR),\n+\t\t\t\t     /*overloaded_p=*/NULL);\n \t      if (result == NULL_TREE)\n \t\treturn error_mark_node;\n \t      return result;\n@@ -5232,7 +5238,8 @@ build_x_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n   if (modifycode != NOP_EXPR)\n     {\n       tree rval = build_new_op (MODIFY_EXPR, LOOKUP_NORMAL, lhs, rhs,\n-\t\t\t\tmake_node (modifycode));\n+\t\t\t\tmake_node (modifycode),\n+\t\t\t\t/*overloaded_p=*/NULL);\n       if (rval)\n \treturn rval;\n     }"}, {"sha": "63144565e48b84c962ce9cbd3adc469b1b9795e9", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec835fb2bfc25fb747550aec56d261042659bc54/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec835fb2bfc25fb747550aec56d261042659bc54/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=ec835fb2bfc25fb747550aec56d261042659bc54", "patch": "@@ -1091,7 +1091,8 @@ build_x_arrow (tree expr)\n   if (IS_AGGR_TYPE (type))\n     {\n       while ((expr = build_new_op (COMPONENT_REF, LOOKUP_NORMAL, expr,\n-\t\t\t\t   NULL_TREE, NULL_TREE)))\n+\t\t\t\t   NULL_TREE, NULL_TREE,\n+\t\t\t\t   /*overloaded_p=*/NULL)))\n \t{\n \t  if (expr == error_mark_node)\n \t    return error_mark_node;"}, {"sha": "09f98bf3829b9589ae0c8724cff1dd444fbe3981", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec835fb2bfc25fb747550aec56d261042659bc54/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec835fb2bfc25fb747550aec56d261042659bc54/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ec835fb2bfc25fb747550aec56d261042659bc54", "patch": "@@ -1,3 +1,8 @@\n+2004-03-16  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/14586\n+\t* g++.dg/parse/non-dependent3.C: New test.\n+\n 2004-03-16  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* g++.dg/eh/simd-1.C: Use vector_size attribute, not mode."}, {"sha": "9dfb99636a88c43441721be2ace3b3c745d4d107", "filename": "gcc/testsuite/g++.dg/parse/non-dependent3.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec835fb2bfc25fb747550aec56d261042659bc54/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fnon-dependent3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec835fb2bfc25fb747550aec56d261042659bc54/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fnon-dependent3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fnon-dependent3.C?ref=ec835fb2bfc25fb747550aec56d261042659bc54", "patch": "@@ -0,0 +1,17 @@\n+// PR c++/14586\n+\n+enum E { e }; \n+ \n+E & operator |= (E &f1, const E &f2); \n+ \n+E operator | (const E &f1, const E &f2) { \n+  E result = f1; \n+  result |= f2; \n+  return result; \n+} \n+ \n+template <typename> void foo () { \n+  const E flags = e | e; \n+} \n+ \n+template void foo<double> ();"}]}