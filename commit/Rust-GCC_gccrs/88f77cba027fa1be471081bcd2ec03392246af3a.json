{"sha": "88f77cba027fa1be471081bcd2ec03392246af3a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODhmNzdjYmEwMjdmYTFiZTQ3MTA4MWJjZDJlYzAzMzkyMjQ2YWYzYQ==", "commit": {"author": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2007-07-25T12:28:31Z"}, "committer": {"name": "Julian Brown", "email": "jules@gcc.gnu.org", "date": "2007-07-25T12:28:31Z"}, "message": "Makefile.in (TEXI_GCC_FILES): Add arm-neon-intrinsics.texi.\n\n    gcc/\n    * Makefile.in (TEXI_GCC_FILES): Add arm-neon-intrinsics.texi.\n    * config.gcc (arm*-*-*): Add arm_neon.h to extra headers.\n    (with_fpu): Allow --with-fpu=neon.\n    * config/arm/aof.h (ADDITIONAL_REGISTER_NAMES): Add Q0-Q15.\n    * config/arm/aout.h (ADDITIONAL_REGISTER_NAMES): Add Q0-Q15.\n    * config/arm/arm-modes.def (EI, OI, CI, XI): New modes.\n    * config/arm/arm-protos.h (neon_immediate_valid_for_move)\n    (neon_immediate_valid_for_logic, neon_output_logic_immediate)\n    (neon_pairwise_reduce, neon_expand_vector_init, neon_reinterpret)\n    (neon_emit_pair_result_insn, neon_disambiguate_copy)\n    (neon_vector_mem_operand, neon_struct_mem_operand, output_move_quad)\n    (output_move_neon): Add prototypes.\n    * config/arm/arm.c (FL_NEON): New flag for NEON processor capability.\n    (all_fpus): Add FPUTYPE_NEON.\n    (fp_model_for_fpu): Add NEON field.\n    (arm_return_in_memory): Return vectors <= 16 bytes in ARM registers.\n    (arm_arg_partial_bytes): Allow NEON vectors to be passed partially\n    in registers.\n    (arm_legitimate_address_p): Don't support fancy addressing for NEON\n    structure moves.\n    (thumb2_legitimate_address_p): Likewise.\n    (neon_valid_immediate): Recognize and prepare constants suitable for\n    NEON instructions.\n    (neon_immediate_valid_for_move): New function. Recognize and prepare\n    immediates for NEON move instructions.\n    (neon_immediate_valid_for_logic): New function. Recognize and\n    prepare immediates for NEON logic instructions.\n    (neon_output_logic_immediate): New function. Create asm string\n    suitable for outputting immediate logic instructions.\n    (neon_pairwise_reduce): New function. Implement reduction using\n    pairwise operations.\n    (neon_expand_vector_init): New function. Expand a (possibly\n    non-constant) vector initialization.\n    (neon_vector_mem_operand): New function. Memory operands supported\n    for quad-word loads/stores to/from ARM or NEON registers. Don't\n    allow base+offset addressing for core regs.\n    (neon_struct_mem_operand): New function. Valid mems for NEON\n    structure moves.\n    (coproc_secondary_reload_class): Enable NEON registers to be loaded\n    from neon_vector_mem_operand addresses without a secondary register.\n    (add_minipool_forward_ref): Handle >8-byte minipool entries.\n    (add_minipool_backward_ref): Likewise.\n    (dump_minipool): Likewise.\n    (push_minipool_fix): Likewise.\n    (output_move_quad): New function. Output quad-word moves, loads and\n    stores using ARM registers.\n    (output_move_vfp): Add support for vectors in VFP (NEON) D\n    registers.\n    (output_move_neon): Output a NEON load/store to/from a quadword\n    register.\n    (arm_print_operand): Implement new codes:\n    - 'c' for unadorned integers (without a # sign).\n    - 'J', 'K' for reg+2/reg+3, reg+3/reg+2 in little/big-endian\n    mode.\n    - 'e', 'f' for the low and high D parts of a NEON Q register.\n    - 'q' outputs a NEON Q register.\n    - 'h' outputs ranges of D registers for VLDM/VSTM etc.\n    - 'T' prints NEON opcode features from a coded bitmask.\n    - 'F' is similar to T, but signed/unsigned codes both print as\n    'i'.\n    - 't' is similar to T, but 'u' is printed instead of 'p'.\n    - 'O' prints 'r' if NEON instruction should perform rounding (as\n    specified by bitmask), else prints nothing.\n    - '#' is a punctuation character to stop operand numbers from\n    running together with following digits in the assembler\n    strings for instructions (when using mode attributes).\n    (arm_assemble_integer): Handle extra NEON vector modes. Permute\n    constant vectors in big-endian mode, where necessary.\n    (arm_hard_regno_mode_ok): Allow vectors in VFP/NEON registers.\n    Handle EI, OI, CI, XI modes.\n    (ashlv4hi3, ashlv2si3, lshrv4hi3, lshrv2si3, ashrv4hi3)\n    (ashrv2si3): Rename IWMMXT2_BUILTINs to...\n    (ashlv4hi3_iwmmxt, ashlv2si3_iwmmxt, lshrv4hi3_iwmmxt)\n    (lshrv2si3_iwmmxt, ashrv4hi3_iwmmxt, ashrv2si3_iwmmxt): New names.\n    (neon_builtin_type_bits): Add enumeration, one bit for each vector\n    type.\n    (v8qi_UP, v4hi_UP, v2si_UP, v2sf_UP, di_UP, v16qi_UP, v8hi_UP)\n    (v4si_UP, v4sf_UP, v2di_UP, ti_UP, ei_UP, oi_UP, UP): Define macros\n    to turn v8qi, etc. into bits defined above.\n    (neon_itype): New enumeration. Classifications of NEON builtins.\n    (neon_builtin_datum): Define struct. Contains information about\n    a single builtin (with multiple modes).\n    (CF): Define helper macro for...\n    (VAR1...VAR10): Define builtins with a type, name and 1-10 different\n    modes.\n    (neon_builtin_data): New array. Define information about builtins\n    for use during initialization/expansion.\n    (arm_init_neon_builtins): New function.\n    (arm_init_builtins): Call arm_init_neon_builtins if TARGET_NEON is\n    true.\n    (neon_builtin_compare): New function.\n    (locate_neon_builtin_icode): New function. Find an insn code for a\n    builtin given a function code for that builtin. Also return type of\n    builtin (NEON_BINOP, NEON_UNOP etc.).\n    (builtin_arg): New enumeration. Types of arguments for builtins.\n    (arm_expand_neon_args): New function. Expand a generic NEON builtin.\n    Takes a variable argument list of builtin_arg types, terminated by\n    NEON_ARG_STOP.\n    (arm_expand_neon_builtin): New function. Expand a NEON builtin.\n    (neon_reinterpret): New function. Expand NEON reinterpret intrinsic.\n    (neon_emit_pair_result_insn): New function. Support returning pairs\n    of vectors via a pointer.\n    (neon_disambiguate_copy): New function. Set up operands for a\n    multi-word copy such that registers do not get clobbered.\n    (arm_expand_builtin): Call arm_expand_neon_builtin if fcode >=\n    ARM_BUILTIN_NEON_BASE.\n    (arm_file_start): Set float-abi attribute for NEON.\n    (arm_vector_mode_supported_p): Enable NEON vector modes.\n    (arm_mangle_map_entry): New.\n    (arm_mangle_map): New.\n    (arm_mangle_vector_type): New.\n    * config/arm/arm.h (TARGET_CPU_CPP_BUILTINS): Define __ARM_NEON__\n    when appropriate.\n    (TARGET_NEON): New macro. Target supports NEON.\n    (fputype): Add FPUTYPE_NEON.\n    (UNITS_PER_SIMD_WORD): Define. Allow quad-word registers to be used\n    for vectorization based on command-line arg.\n    (NEON_REGNO_OK_FOR_NREGS): Define.\n    (VALID_NEON_DREG_MODE, VALID_NEON_QREG_MODE)\n    (VALID_NEON_STRUCT_MODE): Define.\n    (PRINT_OPERAND_PUNCT_VALID_P): '#' is valid punctuation.\n    (arm_builtins): Add ARM_BUILTIN_NEON_BASE.\n    * config/arm/arm.md (VUNSPEC_POOL_16): Insert constant for unspec.\n    (consttable_16): Add pattern for outputting 16-byte minipool\n    entries.\n    (movv2si, movv4hi, movv8qi): Remove blank expanders (redefined in\n    vec-common.md).\n    (vec-common.md, neon.md): Include md files.\n    * config/arm/arm.opt (mvectorize-with-neon-quad): Add option.\n    * config/arm/constraints.md (constraint \"Dn\", \"Dl\", \"DL\"): Define.\n    (memory_constraint \"Ut\", \"Un\", \"Us\"): Define.\n    * config/arm/iwmmxt.md (VMMX, VSHFT): New mode macros.\n    (MMX_char): New mode attribute.\n    (addv8qi3, addv4hi3, addv2si3): Remove. Replace with...\n    (*add<mode>3_iwmmxt): New insn pattern.\n    (subv8qi3, subv4hi3, subv2si3): Remove. Replace with...\n    (*sub<mode>3_iwmmxt): New insn pattern.\n    (mulv4hi3): Rename to...\n    (*mulv4hi3_iwmmxt): This.\n    (smaxv8qi3, smaxv4hi3, smaxv2si3, umaxv8qi3, umaxv4hi3)\n    (umaxv2si3, sminv8qi3, sminv4hi3, sminv2si3, uminv8qi3)\n    (uminv4hi3, uminv2si3): Remove. Replace with...\n    (*smax<mode>3_iwmmxt, *umax<mode>3_iwmmxt, *smin<mode>3_iwmmxt)\n    (*umin<mode>3_iwmmxt): These.\n    (ashrv4hi3, ashrv2si3, ashrdi3_iwmmxt): Replace with...\n    (ashr<mode>3_iwmmxt): This new pattern.\n    (lshrv4hi3, lshrv2si3, lshrdi3_iwmmxt): Replace with...\n    (lshr<mode>3_iwmmxt): This new pattern.\n    (ashlv4hi3, ashlv2si3, ashldi3_iwmmxt): Replace with...\n    (ashl<mode>3_iwmmxt): This new pattern.\n    * config/arm/neon-docgen.ml: New file. Generate documentation for\n    intrinsics.\n    * config/arm/neon-gen.ml: New file. Generate arm_neon.h header.\n    * config/arm/arm_neon.h: New (autogenerated).\n    * config/arm/neon-testgen.ml: New file. Generate NEON tests\n    automatically.\n    * config/arm/neon.md: New file. Define NEON instructions.\n    * config/arm/neon.ml: New file. Abstract description of NEON\n    instructions, used to generate arm_neon.h header, documentation and tests.\n    * config/arm/t-arm (MD_INCLUDES): Add vec-common.md, neon.md.\n    * vec-common.md: New file. Shared parts for iWMMXt and NEON vector\n    support.\n    * doc/extend.texi (ARM Built-in Functions): Rename and remove\n    extraneous comma.\n    (ARM NEON Intrinsics): New subsection.\n    * doc/arm-neon-intrinsics.texi: New (autogenerated).\n\n    gcc/testsuite/\n    * gcc.dg/vect/vect.exp: Check is-effective-target arm_neon_hw.\n    * gcc.dg/vect/tree-vect.h: Check for NEON SIMD support.\n    * lib/gcc-dg.exp (cleanup-saved-temps): Fix comment.\n    * lib/target-supports.exp (check_effective_target_arm_neon_ok)\n    (check_effective_target_arm_neon_hw): New.\n    * gcc.target/arm/neon/neon.exp: New file.\n    * gcc.target/arm/neon/polytypes.c: New file.\n    * gcc.target/arm/neon/v*.c (1870 files): New (autogenerated).\n\n\nCo-Authored-By: Joseph Myers <joseph@codesourcery.com>\nCo-Authored-By: Mark Shinwell <shinwell@codesourcery.com>\nCo-Authored-By: Paul Brook <paul@codesourcery.com>\n\nFrom-SVN: r126911", "tree": {"sha": "3d9e535e4852684293654d9dcacf4334f53ce19c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d9e535e4852684293654d9dcacf4334f53ce19c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88f77cba027fa1be471081bcd2ec03392246af3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88f77cba027fa1be471081bcd2ec03392246af3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88f77cba027fa1be471081bcd2ec03392246af3a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88f77cba027fa1be471081bcd2ec03392246af3a/comments", "author": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "15d92b36a1cc26f5eda0c09f3fa1c369d0a36260", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15d92b36a1cc26f5eda0c09f3fa1c369d0a36260", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15d92b36a1cc26f5eda0c09f3fa1c369d0a36260"}], "stats": {"total": 69720, "additions": 69397, "deletions": 323}, "files": [{"sha": "f4bfff8c503377559ee80b0d34a9e467b8e7e99a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -1,3 +1,176 @@\n+2007-07-25  Julian Brown  <julian@codesourcery.com>\n+\t    Paul Brook  <paul@codesourcery.com>\n+\t    Joseph Myers  <joseph@codesourcery.com>\n+\t    Mark Shinwell  <shinwell@codesourcery.com>\n+\n+\t* Makefile.in (TEXI_GCC_FILES): Add arm-neon-intrinsics.texi.\n+\t* config.gcc (arm*-*-*): Add arm_neon.h to extra headers.\n+\t(with_fpu): Allow --with-fpu=neon.\n+\t* config/arm/aof.h (ADDITIONAL_REGISTER_NAMES): Add Q0-Q15.\n+\t* config/arm/aout.h (ADDITIONAL_REGISTER_NAMES): Add Q0-Q15.\n+\t* config/arm/arm-modes.def (EI, OI, CI, XI): New modes.\n+\t* config/arm/arm-protos.h (neon_immediate_valid_for_move)\n+\t(neon_immediate_valid_for_logic, neon_output_logic_immediate)\n+\t(neon_pairwise_reduce, neon_expand_vector_init, neon_reinterpret)\n+\t(neon_emit_pair_result_insn, neon_disambiguate_copy)\n+\t(neon_vector_mem_operand, neon_struct_mem_operand, output_move_quad)\n+\t(output_move_neon): Add prototypes.\n+\t* config/arm/arm.c (FL_NEON): New flag for NEON processor capability.\n+\t(all_fpus): Add FPUTYPE_NEON.\n+\t(fp_model_for_fpu): Add NEON field.\n+\t(arm_return_in_memory): Return vectors <= 16 bytes in ARM registers.\n+\t(arm_arg_partial_bytes): Allow NEON vectors to be passed partially\n+\tin registers.\n+\t(arm_legitimate_address_p): Don't support fancy addressing for NEON\n+\tstructure moves.\n+\t(thumb2_legitimate_address_p): Likewise.\n+\t(neon_valid_immediate): Recognize and prepare constants suitable for\n+\tNEON instructions.\n+\t(neon_immediate_valid_for_move): New function. Recognize and prepare\n+\timmediates for NEON move instructions.\n+\t(neon_immediate_valid_for_logic): New function. Recognize and\n+\tprepare immediates for NEON logic instructions.\n+\t(neon_output_logic_immediate): New function. Create asm string\n+\tsuitable for outputting immediate logic instructions.\n+\t(neon_pairwise_reduce): New function. Implement reduction using\n+\tpairwise operations.\n+\t(neon_expand_vector_init): New function. Expand a (possibly\n+\tnon-constant) vector initialization.\n+\t(neon_vector_mem_operand): New function. Memory operands supported\n+\tfor quad-word loads/stores to/from ARM or NEON registers. Don't\n+\tallow base+offset addressing for core regs.\n+\t(neon_struct_mem_operand): New function. Valid mems for NEON\n+\tstructure moves.\n+\t(coproc_secondary_reload_class): Enable NEON registers to be loaded\n+\tfrom neon_vector_mem_operand addresses without a secondary register.\n+\t(add_minipool_forward_ref): Handle >8-byte minipool entries.\n+\t(add_minipool_backward_ref): Likewise.\n+\t(dump_minipool): Likewise.\n+\t(push_minipool_fix): Likewise.\n+\t(output_move_quad): New function. Output quad-word moves, loads and\n+\tstores using ARM registers.\n+\t(output_move_vfp): Add support for vectors in VFP (NEON) D\n+\tregisters.\n+\t(output_move_neon): Output a NEON load/store to/from a quadword\n+\tregister.\n+\t(arm_print_operand): Implement new codes:\n+\t- 'c' for unadorned integers (without a # sign).\n+\t- 'J', 'K' for reg+2/reg+3, reg+3/reg+2 in little/big-endian\n+\tmode.\n+\t- 'e', 'f' for the low and high D parts of a NEON Q register.\n+\t- 'q' outputs a NEON Q register.\n+\t- 'h' outputs ranges of D registers for VLDM/VSTM etc.\n+\t- 'T' prints NEON opcode features from a coded bitmask.\n+\t- 'F' is similar to T, but signed/unsigned codes both print as\n+\t'i'.\n+\t- 't' is similar to T, but 'u' is printed instead of 'p'.\n+\t- 'O' prints 'r' if NEON instruction should perform rounding (as\n+\tspecified by bitmask), else prints nothing.\n+\t- '#' is a punctuation character to stop operand numbers from\n+\trunning together with following digits in the assembler\n+\tstrings for instructions (when using mode attributes).\n+\t(arm_assemble_integer): Handle extra NEON vector modes. Permute\n+\tconstant vectors in big-endian mode, where necessary.\n+\t(arm_hard_regno_mode_ok): Allow vectors in VFP/NEON registers.\n+\tHandle EI, OI, CI, XI modes.\n+\t(ashlv4hi3, ashlv2si3, lshrv4hi3, lshrv2si3, ashrv4hi3)\n+\t(ashrv2si3): Rename IWMMXT2_BUILTINs to...\n+\t(ashlv4hi3_iwmmxt, ashlv2si3_iwmmxt, lshrv4hi3_iwmmxt)\n+\t(lshrv2si3_iwmmxt, ashrv4hi3_iwmmxt, ashrv2si3_iwmmxt): New names.\n+\t(neon_builtin_type_bits): Add enumeration, one bit for each vector\n+\ttype.\n+\t(v8qi_UP, v4hi_UP, v2si_UP, v2sf_UP, di_UP, v16qi_UP, v8hi_UP)\n+\t(v4si_UP, v4sf_UP, v2di_UP, ti_UP, ei_UP, oi_UP, UP): Define macros\n+\tto turn v8qi, etc. into bits defined above.\n+\t(neon_itype): New enumeration. Classifications of NEON builtins.\n+\t(neon_builtin_datum): Define struct. Contains information about\n+\ta single builtin (with multiple modes).\n+\t(CF): Define helper macro for...\n+\t(VAR1...VAR10): Define builtins with a type, name and 1-10 different\n+\tmodes.\n+\t(neon_builtin_data): New array. Define information about builtins\n+\tfor use during initialization/expansion.\n+\t(arm_init_neon_builtins): New function.\n+\t(arm_init_builtins): Call arm_init_neon_builtins if TARGET_NEON is\n+\ttrue.\n+\t(neon_builtin_compare): New function.\n+\t(locate_neon_builtin_icode): New function. Find an insn code for a\n+\tbuiltin given a function code for that builtin. Also return type of\n+\tbuiltin (NEON_BINOP, NEON_UNOP etc.).\n+\t(builtin_arg): New enumeration. Types of arguments for builtins.\n+\t(arm_expand_neon_args): New function. Expand a generic NEON builtin.\n+\tTakes a variable argument list of builtin_arg types, terminated by\n+\tNEON_ARG_STOP.\n+\t(arm_expand_neon_builtin): New function. Expand a NEON builtin.\n+\t(neon_reinterpret): New function. Expand NEON reinterpret intrinsic.\n+\t(neon_emit_pair_result_insn): New function. Support returning pairs\n+\tof vectors via a pointer.\n+\t(neon_disambiguate_copy): New function. Set up operands for a\n+\tmulti-word copy such that registers do not get clobbered.\n+\t(arm_expand_builtin): Call arm_expand_neon_builtin if fcode >=\n+\tARM_BUILTIN_NEON_BASE.\n+\t(arm_file_start): Set float-abi attribute for NEON.\n+\t(arm_vector_mode_supported_p): Enable NEON vector modes.\n+\t(arm_mangle_map_entry): New.\n+\t(arm_mangle_map): New.\n+\t(arm_mangle_vector_type): New.\n+\t* config/arm/arm.h (TARGET_CPU_CPP_BUILTINS): Define __ARM_NEON__\n+\twhen appropriate.\n+\t(TARGET_NEON): New macro. Target supports NEON.\n+\t(fputype): Add FPUTYPE_NEON.\n+\t(UNITS_PER_SIMD_WORD): Define. Allow quad-word registers to be used\n+\tfor vectorization based on command-line arg.\n+\t(NEON_REGNO_OK_FOR_NREGS): Define.\n+\t(VALID_NEON_DREG_MODE, VALID_NEON_QREG_MODE)\n+\t(VALID_NEON_STRUCT_MODE): Define.\n+\t(PRINT_OPERAND_PUNCT_VALID_P): '#' is valid punctuation.\n+\t(arm_builtins): Add ARM_BUILTIN_NEON_BASE.\n+\t* config/arm/arm.md (VUNSPEC_POOL_16): Insert constant for unspec.\n+\t(consttable_16): Add pattern for outputting 16-byte minipool\n+\tentries.\n+\t(movv2si, movv4hi, movv8qi): Remove blank expanders (redefined in\n+\tvec-common.md).\n+\t(vec-common.md, neon.md): Include md files.\n+\t* config/arm/arm.opt (mvectorize-with-neon-quad): Add option.\n+\t* config/arm/constraints.md (constraint \"Dn\", \"Dl\", \"DL\"): Define.\n+\t(memory_constraint \"Ut\", \"Un\", \"Us\"): Define.\n+\t* config/arm/iwmmxt.md (VMMX, VSHFT): New mode macros.\n+\t(MMX_char): New mode attribute.\n+\t(addv8qi3, addv4hi3, addv2si3): Remove. Replace with...\n+\t(*add<mode>3_iwmmxt): New insn pattern.\n+\t(subv8qi3, subv4hi3, subv2si3): Remove. Replace with...\n+\t(*sub<mode>3_iwmmxt): New insn pattern.\n+\t(mulv4hi3): Rename to...\n+\t(*mulv4hi3_iwmmxt): This.\n+\t(smaxv8qi3, smaxv4hi3, smaxv2si3, umaxv8qi3, umaxv4hi3)\n+\t(umaxv2si3, sminv8qi3, sminv4hi3, sminv2si3, uminv8qi3)\n+\t(uminv4hi3, uminv2si3): Remove. Replace with...\n+\t(*smax<mode>3_iwmmxt, *umax<mode>3_iwmmxt, *smin<mode>3_iwmmxt)\n+\t(*umin<mode>3_iwmmxt): These.\n+\t(ashrv4hi3, ashrv2si3, ashrdi3_iwmmxt): Replace with...\n+\t(ashr<mode>3_iwmmxt): This new pattern.\n+\t(lshrv4hi3, lshrv2si3, lshrdi3_iwmmxt): Replace with...\n+\t(lshr<mode>3_iwmmxt): This new pattern.\n+\t(ashlv4hi3, ashlv2si3, ashldi3_iwmmxt): Replace with...\n+\t(ashl<mode>3_iwmmxt): This new pattern.\n+\t* config/arm/neon-docgen.ml: New file. Generate documentation for\n+\tintrinsics.\n+\t* config/arm/neon-gen.ml: New file. Generate arm_neon.h header.\n+\t* config/arm/arm_neon.h: New (autogenerated).\n+\t* config/arm/neon-testgen.ml: New file. Generate NEON tests\n+\tautomatically.\n+\t* config/arm/neon.md: New file. Define NEON instructions.\n+\t* config/arm/neon.ml: New file. Abstract description of NEON\n+\tinstructions, used to generate arm_neon.h header, documentation and\n+\ttests.\n+\t* config/arm/t-arm (MD_INCLUDES): Add vec-common.md, neon.md.\n+\t* vec-common.md: New file. Shared parts for iWMMXt and NEON vector\n+\tsupport.\n+\t* doc/extend.texi (ARM Built-in Functions): Rename and remove\n+\textraneous comma.\n+\t(ARM NEON Intrinsics): New subsection.\n+\t* doc/arm-neon-intrinsics.texi: New (autogenerated).\n+\n 2007-07-25  Danny Smith   <dannysmith@users.sourceforge.net>\n \n \t* config/i386/i386-protos.h (i386_pe_asm_file_end): Remove"}, {"sha": "51261dbabb760018f748dcdcb916ffdadd836e15", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -3581,7 +3581,7 @@ TEXI_GCC_FILES = gcc.texi gcc-common.texi gcc-vers.texi frontends.texi\t\\\n \t gcov.texi trouble.texi bugreport.texi service.texi\t\t\\\n \t contribute.texi compat.texi funding.texi gnu.texi gpl.texi\t\\\n \t fdl.texi contrib.texi cppenv.texi cppopts.texi\t\t\t\\\n-\t implement-c.texi\n+\t implement-c.texi arm-neon-intrinsics.texi\n \n TEXI_GCCINT_FILES = gccint.texi gcc-common.texi gcc-vers.texi\t\t\\\n \t contribute.texi makefile.texi configterms.texi options.texi\t\\"}, {"sha": "ccf302f8b3a57a1b6840a917c7555bb5368ba418", "filename": "gcc/config.gcc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -259,7 +259,7 @@ strongarm*-*-*)\n \t;;\n arm*-*-*)\n \tcpu_type=arm\n-\textra_headers=\"mmintrin.h\"\n+\textra_headers=\"mmintrin.h arm_neon.h\"\n \t;;\n bfin*-*)\n \tcpu_type=bfin\n@@ -2841,7 +2841,7 @@ case \"${target}\" in\n \n \t\tcase \"$with_fpu\" in\n \t\t\"\" \\\n-\t\t| fpa | fpe2 | fpe3 | maverick | vfp | vfp3 )\n+\t\t| fpa | fpe2 | fpe3 | maverick | vfp | vfp3 | neon )\n \t\t\t# OK\n \t\t\t;;\n \t\t*)"}, {"sha": "eeb06fd8bfac74aa060366b7565a4ef25d630e1c", "filename": "gcc/config/arm/aof.h", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Fconfig%2Farm%2Faof.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Fconfig%2Farm%2Faof.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faof.h?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -239,22 +239,30 @@ do {\t\t\t\t\t\\\n   {\"r13\", 13}, {\"sp\", 13}, \t\t\t\\\n   {\"r14\", 14}, {\"lr\", 14},\t\t\t\\\n   {\"r15\", 15}, {\"pc\", 15},\t\t\t\\\n-  {\"d0\", 63},\t\t\t\t\t\\\n+  {\"d0\", 63}, {\"q0\", 63},\t\t\t\\\n   {\"d1\", 65},\t\t\t\t\t\\\n-  {\"d2\", 67},\t\t\t\t\t\\\n+  {\"d2\", 67}, {\"q1\", 67},\t\t\t\\\n   {\"d3\", 69},\t\t\t\t\t\\\n-  {\"d4\", 71},\t\t\t\t\t\\\n+  {\"d4\", 71}, {\"q2\", 71},\t\t\t\\\n   {\"d5\", 73},\t\t\t\t\t\\\n-  {\"d6\", 75},\t\t\t\t\t\\\n+  {\"d6\", 75}, {\"q3\", 75},\t\t\t\\\n   {\"d7\", 77},\t\t\t\t\t\\\n-  {\"d8\", 79},\t\t\t\t\t\\\n+  {\"d8\", 79}, {\"q4\", 79},\t\t\t\\\n   {\"d9\", 81},\t\t\t\t\t\\\n-  {\"d10\", 83},\t\t\t\t\t\\\n+  {\"d10\", 83}, {\"q5\", 83},\t\t\t\\\n   {\"d11\", 85},\t\t\t\t\t\\\n-  {\"d12\", 87},\t\t\t\t\t\\\n+  {\"d12\", 87}, {\"q6\", 87},\t\t\t\\\n   {\"d13\", 89},\t\t\t\t\t\\\n-  {\"d14\", 91},\t\t\t\t\t\\\n-  {\"d15\", 93}\t\t\t\t\t\\\n+  {\"d14\", 91}, {\"q7\", 91},\t\t\t\\\n+  {\"d15\", 93},\t\t\t\t\t\\\n+  {\"q8\", 95},\t\t\t\t\t\\\n+  {\"q9\", 99},\t\t\t\t\t\\\n+  {\"q10\", 103},\t\t\t\t\t\\\n+  {\"q11\", 107},\t\t\t\t\t\\\n+  {\"q12\", 111},\t\t\t\t\t\\\n+  {\"q13\", 115},\t\t\t\t\t\\\n+  {\"q14\", 119},\t\t\t\t\t\\\n+  {\"q15\", 123}\t\t\t\t\t\\\n }\n \n #define REGISTER_PREFIX \"__\""}, {"sha": "460338d98c322b3256bb1a2454c9013577bcdf13", "filename": "gcc/config/arm/aout.h", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Fconfig%2Farm%2Faout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Fconfig%2Farm%2Faout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faout.h?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -165,22 +165,30 @@\n   {\"mvdx13\", 40},\t\t\t\t\\\n   {\"mvdx14\", 41},\t\t\t\t\\\n   {\"mvdx15\", 42},\t\t\t\t\\\n-  {\"d0\", 63},\t\t\t\t\t\\\n+  {\"d0\", 63}, {\"q0\", 63},\t\t\t\\\n   {\"d1\", 65},\t\t\t\t\t\\\n-  {\"d2\", 67},\t\t\t\t\t\\\n+  {\"d2\", 67}, {\"q1\", 67},\t\t\t\\\n   {\"d3\", 69},\t\t\t\t\t\\\n-  {\"d4\", 71},\t\t\t\t\t\\\n+  {\"d4\", 71}, {\"q2\", 71},\t\t\t\\\n   {\"d5\", 73},\t\t\t\t\t\\\n-  {\"d6\", 75},\t\t\t\t\t\\\n+  {\"d6\", 75}, {\"q3\", 75},\t\t\t\\\n   {\"d7\", 77},\t\t\t\t\t\\\n-  {\"d8\", 79},\t\t\t\t\t\\\n+  {\"d8\", 79}, {\"q4\", 79},\t\t\t\\\n   {\"d9\", 81},\t\t\t\t\t\\\n-  {\"d10\", 83},\t\t\t\t\t\\\n+  {\"d10\", 83}, {\"q5\", 83},\t\t\t\\\n   {\"d11\", 85},\t\t\t\t\t\\\n-  {\"d12\", 87},\t\t\t\t\t\\\n+  {\"d12\", 87}, {\"q6\", 87},\t\t\t\\\n   {\"d13\", 89},\t\t\t\t\t\\\n-  {\"d14\", 91},\t\t\t\t\t\\\n+  {\"d14\", 91}, {\"q7\", 91},\t\t\t\\\n   {\"d15\", 93},\t\t\t\t\t\\\n+  {\"q8\", 95},\t\t\t\t\t\\\n+  {\"q9\", 99},\t\t\t\t\t\\\n+  {\"q10\", 103},\t\t\t\t\t\\\n+  {\"q11\", 107},\t\t\t\t\t\\\n+  {\"q12\", 111},\t\t\t\t\t\\\n+  {\"q13\", 115},\t\t\t\t\t\\\n+  {\"q14\", 119},\t\t\t\t\t\\\n+  {\"q15\", 123}\t\t\t\t\t\\\n }\n #endif\n "}, {"sha": "6f36e03965c36d1b85558264e868679ecae9900d", "filename": "gcc/config/arm/arm-modes.def", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Fconfig%2Farm%2Farm-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Fconfig%2Farm%2Farm-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-modes.def?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -58,3 +58,11 @@ VECTOR_MODES (INT, 16);       /* V16QI V8HI V4SI V2DI */\n VECTOR_MODES (FLOAT, 8);      /*            V4HF V2SF */\n VECTOR_MODES (FLOAT, 16);     /*       V8HF V4SF V2DF */\n \n+/* Opaque integer modes for 3, 4, 6 or 8 Neon double registers (2 is\n+   TImode).  */\n+INT_MODE (EI, 24);\n+INT_MODE (OI, 32);\n+INT_MODE (CI, 48);\n+/* ??? This should actually have 512 bits but the precision only has 9\n+   bits.  */\n+FRACTIONAL_INT_MODE (XI, 511, 64);"}, {"sha": "a877c6df19a796587db1772c1b7f9178afc6b091", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -68,13 +68,28 @@ extern rtx thumb_legitimize_reload_address (rtx *, enum machine_mode, int, int,\n extern int arm_const_double_rtx (rtx);\n extern int neg_const_double_rtx_ok_for_fpa (rtx);\n extern int vfp3_const_double_rtx (rtx);\n+extern int neon_immediate_valid_for_move (rtx, enum machine_mode, rtx *, int *);\n+extern int neon_immediate_valid_for_logic (rtx, enum machine_mode, int, rtx *,\n+\t\t\t\t\t   int *);\n+extern char *neon_output_logic_immediate (const char *, rtx *,\n+\t\t\t\t\t  enum machine_mode, int, int);\n+extern void neon_pairwise_reduce (rtx, rtx, enum machine_mode,\n+\t\t\t\t  rtx (*) (rtx, rtx, rtx));\n+extern void neon_expand_vector_init (rtx, rtx);\n+extern void neon_reinterpret (rtx, rtx);\n+extern void neon_emit_pair_result_insn (enum machine_mode,\n+\t\t\t\t\trtx (*) (rtx, rtx, rtx, rtx),\n+\t\t\t\t\trtx, rtx, rtx);\n+extern void neon_disambiguate_copy (rtx *, rtx *, rtx *, unsigned int);\n extern enum reg_class coproc_secondary_reload_class (enum machine_mode, rtx,\n \t\t\t\t\t\t     bool);\n extern bool arm_tls_referenced_p (rtx);\n extern bool arm_cannot_force_const_mem (rtx);\n \n extern int cirrus_memory_offset (rtx);\n extern int arm_coproc_mem_operand (rtx, bool);\n+extern int neon_vector_mem_operand (rtx, bool);\n+extern int neon_struct_mem_operand (rtx);\n extern int arm_no_early_store_addr_dep (rtx, rtx);\n extern int arm_no_early_alu_shift_dep (rtx, rtx);\n extern int arm_no_early_alu_shift_value_dep (rtx, rtx);\n@@ -113,7 +128,9 @@ extern const char *output_mov_long_double_arm_from_arm (rtx *);\n extern const char *output_mov_double_fpa_from_arm (rtx *);\n extern const char *output_mov_double_arm_from_fpa (rtx *);\n extern const char *output_move_double (rtx *);\n+extern const char *output_move_quad (rtx *);\n extern const char *output_move_vfp (rtx *operands);\n+extern const char *output_move_neon (rtx *operands);\n extern const char *output_add_immediate (rtx *);\n extern const char *arithmetic_instr (rtx, int);\n extern void output_ascii_pseudo_op (FILE *, const unsigned char *, int);"}, {"sha": "94926d8b554d185aedf850bc9a977e75fc9dc093", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 2024, "deletions": 74, "changes": 2098, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -461,6 +461,7 @@ static int thumb_call_reg_needed;\n \t\t\t\t\t profile.  */\n #define FL_DIV\t      (1 << 18)\t      /* Hardware divide.  */\n #define FL_VFPV3      (1 << 19)       /* Vector Floating Point V3.  */\n+#define FL_NEON       (1 << 20)       /* Neon instructions.  */\n \n #define FL_IWMMXT     (1 << 29)\t      /* XScale v2 or \"Intel Wireless MMX technology\".  */\n \n@@ -706,6 +707,7 @@ static const struct fpu_desc all_fpus[] =\n   {\"maverick\",\tFPUTYPE_MAVERICK},\n   {\"vfp\",\tFPUTYPE_VFP},\n   {\"vfp3\",\tFPUTYPE_VFP3},\n+  {\"neon\",\tFPUTYPE_NEON}\n };\n \n \n@@ -721,7 +723,8 @@ static const enum fputype fp_model_for_fpu[] =\n   ARM_FP_MODEL_FPA,\t\t/* FPUTYPE_FPA_EMU3  */\n   ARM_FP_MODEL_MAVERICK,\t/* FPUTYPE_MAVERICK  */\n   ARM_FP_MODEL_VFP,\t\t/* FPUTYPE_VFP  */\n-  ARM_FP_MODEL_VFP\t\t/* FPUTYPE_VFP3  */\n+  ARM_FP_MODEL_VFP,\t\t/* FPUTYPE_VFP3  */\n+  ARM_FP_MODEL_VFP\t\t/* FPUTYPE_NEON  */\n };\n \n \n@@ -2754,27 +2757,27 @@ arm_return_in_memory (tree type)\n {\n   HOST_WIDE_INT size;\n \n+  size = int_size_in_bytes (type);\n+\n+  /* Vector values should be returned using ARM registers, not memory (unless\n+     they're over 16 bytes, which will break since we only have four\n+     call-clobbered registers to play with).  */\n+  if (TREE_CODE (type) == VECTOR_TYPE)\n+    return (size < 0 || size > (4 * UNITS_PER_WORD));\n+\n   if (!AGGREGATE_TYPE_P (type) &&\n-      (TREE_CODE (type) != VECTOR_TYPE) &&\n       !(TARGET_AAPCS_BASED && TREE_CODE (type) == COMPLEX_TYPE))\n     /* All simple types are returned in registers.\n        For AAPCS, complex types are treated the same as aggregates.  */\n     return 0;\n \n-  size = int_size_in_bytes (type);\n-\n   if (arm_abi != ARM_ABI_APCS)\n     {\n       /* ATPCS and later return aggregate types in memory only if they are\n \t larger than a word (or are variable size).  */\n       return (size < 0 || size > UNITS_PER_WORD);\n     }\n \n-  /* To maximize backwards compatibility with previous versions of gcc,\n-     return vectors up to 4 words in registers.  */\n-  if (TREE_CODE (type) == VECTOR_TYPE)\n-    return (size < 0 || size > (4 * UNITS_PER_WORD));\n-\n   /* For the arm-wince targets we choose to be compatible with Microsoft's\n      ARM and Thumb compilers, which always return aggregates in memory.  */\n #ifndef ARM_WINCE\n@@ -2988,7 +2991,7 @@ arm_arg_partial_bytes (CUMULATIVE_ARGS *pcum, enum machine_mode mode,\n {\n   int nregs = pcum->nregs;\n \n-  if (arm_vector_mode_supported_p (mode))\n+  if (TARGET_IWMMXT_ABI && arm_vector_mode_supported_p (mode))\n     return 0;\n \n   if (NUM_ARG_REGS > nregs\n@@ -3787,7 +3790,7 @@ arm_legitimate_address_p (enum machine_mode mode, rtx x, RTX_CODE outer,\n \t\t   && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT)))\n     return 1;\n \n-  else if (mode == TImode)\n+  else if (mode == TImode || (TARGET_NEON && VALID_NEON_STRUCT_MODE (mode)))\n     return 0;\n \n   else if (code == PLUS)\n@@ -3873,7 +3876,7 @@ thumb2_legitimate_address_p (enum machine_mode mode, rtx x, int strict_p)\n \t\t   && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT)))\n     return 1;\n \n-  else if (mode == TImode)\n+  else if (mode == TImode || (TARGET_NEON && VALID_NEON_STRUCT_MODE (mode)))\n     return 0;\n \n   else if (code == PLUS)\n@@ -3916,6 +3919,13 @@ arm_legitimate_index_p (enum machine_mode mode, rtx index, RTX_CODE outer,\n \t    && INTVAL (index) > -1024\n \t    && (INTVAL (index) & 3) == 0);\n \n+  if (TARGET_NEON\n+      && (VALID_NEON_DREG_MODE (mode) || VALID_NEON_QREG_MODE (mode)))\n+    return (code == CONST_INT\n+\t    && INTVAL (index) < 1016\n+\t    && INTVAL (index) > -1024\n+\t    && (INTVAL (index) & 3) == 0);\n+\n   if (TARGET_REALLY_IWMMXT && VALID_IWMMXT_REG_MODE (mode))\n     return (code == CONST_INT\n \t    && INTVAL (index) < 1024\n@@ -4026,6 +4036,13 @@ thumb2_legitimate_index_p (enum machine_mode mode, rtx index, int strict_p)\n \t\t&& (INTVAL (index) & 3) == 0);\n     }\n \n+  if (TARGET_NEON\n+      && (VALID_NEON_DREG_MODE (mode) || VALID_NEON_QREG_MODE (mode)))\n+    return (code == CONST_INT\n+\t    && INTVAL (index) < 1016\n+\t    && INTVAL (index) > -1024\n+\t    && (INTVAL (index) & 3) == 0);\n+\n   if (arm_address_register_rtx_p (index, strict_p)\n       && (GET_MODE_SIZE (mode) <= 4))\n     return 1;\n@@ -5863,6 +5880,357 @@ vfp3_const_double_rtx (rtx x)\n   return vfp3_const_double_index (x) != -1;\n }\n \n+/* Recognize immediates which can be used in various Neon instructions. Legal\n+   immediates are described by the following table (for VMVN variants, the\n+   bitwise inverse of the constant shown is recognized. In either case, VMOV\n+   is output and the correct instruction to use for a given constant is chosen\n+   by the assembler). The constant shown is replicated across all elements of\n+   the destination vector.\n+\n+   insn elems variant constant (binary)\n+   ---- ----- ------- -----------------\n+   vmov  i32     0    00000000 00000000 00000000 abcdefgh\n+   vmov  i32     1    00000000 00000000 abcdefgh 00000000\n+   vmov  i32     2    00000000 abcdefgh 00000000 00000000\n+   vmov  i32     3    abcdefgh 00000000 00000000 00000000\n+   vmov  i16     4    00000000 abcdefgh\n+   vmov  i16     5    abcdefgh 00000000\n+   vmvn  i32     6    00000000 00000000 00000000 abcdefgh\n+   vmvn  i32     7    00000000 00000000 abcdefgh 00000000\n+   vmvn  i32     8    00000000 abcdefgh 00000000 00000000\n+   vmvn  i32     9    abcdefgh 00000000 00000000 00000000\n+   vmvn  i16    10    00000000 abcdefgh\n+   vmvn  i16    11    abcdefgh 00000000\n+   vmov  i32    12    00000000 00000000 abcdefgh 11111111\n+   vmvn  i32    13    00000000 00000000 abcdefgh 11111111\n+   vmov  i32    14    00000000 abcdefgh 11111111 11111111\n+   vmvn  i32    15    00000000 abcdefgh 11111111 11111111\n+   vmov   i8    16    abcdefgh\n+   vmov  i64    17    aaaaaaaa bbbbbbbb cccccccc dddddddd\n+                      eeeeeeee ffffffff gggggggg hhhhhhhh\n+   vmov  f32    18    aBbbbbbc defgh000 00000000 00000000\n+\n+   For case 18, B = !b. Representable values are exactly those accepted by\n+   vfp3_const_double_index, but are output as floating-point numbers rather\n+   than indices.\n+\n+   Variants 0-5 (inclusive) may also be used as immediates for the second\n+   operand of VORR/VBIC instructions.\n+\n+   The INVERSE argument causes the bitwise inverse of the given operand to be\n+   recognized instead (used for recognizing legal immediates for the VAND/VORN\n+   pseudo-instructions). If INVERSE is true, the value placed in *MODCONST is\n+   *not* inverted (i.e. the pseudo-instruction forms vand/vorn should still be\n+   output, rather than the real insns vbic/vorr).\n+\n+   INVERSE makes no difference to the recognition of float vectors.\n+\n+   The return value is the variant of immediate as shown in the above table, or\n+   -1 if the given value doesn't match any of the listed patterns.\n+*/\n+static int\n+neon_valid_immediate (rtx op, enum machine_mode mode, int inverse,\n+\t\t      rtx *modconst, int *elementwidth)\n+{\n+#define CHECK(STRIDE, ELSIZE, CLASS, TEST)\t\\\n+  matches = 1;\t\t\t\t\t\\\n+  for (i = 0; i < idx; i += (STRIDE))\t\t\\\n+    if (!(TEST))\t\t\t\t\\\n+      matches = 0;\t\t\t\t\\\n+  if (matches)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      immtype = (CLASS);\t\t\t\\\n+      elsize = (ELSIZE);\t\t\t\\\n+      break;\t\t\t\t\t\\\n+    }\n+\n+  unsigned int i, elsize, idx = 0, n_elts = CONST_VECTOR_NUNITS (op);\n+  unsigned int innersize = GET_MODE_SIZE (GET_MODE_INNER (mode));\n+  unsigned char bytes[16];\n+  int immtype = -1, matches;\n+  unsigned int invmask = inverse ? 0xff : 0;\n+\n+  /* Vectors of float constants.  */\n+  if (GET_MODE_CLASS (mode) == MODE_VECTOR_FLOAT)\n+    {\n+      rtx el0 = CONST_VECTOR_ELT (op, 0);\n+      REAL_VALUE_TYPE r0;\n+\n+      if (!vfp3_const_double_rtx (el0))\n+        return -1;\n+\n+      REAL_VALUE_FROM_CONST_DOUBLE (r0, el0);\n+\n+      for (i = 1; i < n_elts; i++)\n+        {\n+          rtx elt = CONST_VECTOR_ELT (op, i);\n+          REAL_VALUE_TYPE re;\n+\n+          REAL_VALUE_FROM_CONST_DOUBLE (re, elt);\n+\n+          if (!REAL_VALUES_EQUAL (r0, re))\n+            return -1;\n+        }\n+\n+      if (modconst)\n+        *modconst = CONST_VECTOR_ELT (op, 0);\n+\n+      if (elementwidth)\n+        *elementwidth = 0;\n+\n+      return 18;\n+    }\n+\n+  /* Splat vector constant out into a byte vector.  */\n+  for (i = 0; i < n_elts; i++)\n+    {\n+      rtx el = CONST_VECTOR_ELT (op, i);\n+      unsigned HOST_WIDE_INT elpart;\n+      unsigned int part, parts;\n+\n+      if (GET_CODE (el) == CONST_INT)\n+        {\n+          elpart = INTVAL (el);\n+          parts = 1;\n+        }\n+      else if (GET_CODE (el) == CONST_DOUBLE)\n+        {\n+          elpart = CONST_DOUBLE_LOW (el);\n+          parts = 2;\n+        }\n+      else\n+        gcc_unreachable ();\n+\n+      for (part = 0; part < parts; part++)\n+        {\n+          unsigned int byte;\n+          for (byte = 0; byte < innersize; byte++)\n+            {\n+              bytes[idx++] = (elpart & 0xff) ^ invmask;\n+              elpart >>= BITS_PER_UNIT;\n+            }\n+          if (GET_CODE (el) == CONST_DOUBLE)\n+            elpart = CONST_DOUBLE_HIGH (el);\n+        }\n+    }\n+\n+  /* Sanity check.  */\n+  gcc_assert (idx == GET_MODE_SIZE (mode));\n+\n+  do\n+    {\n+      CHECK (4, 32, 0, bytes[i] == bytes[0] && bytes[i + 1] == 0\n+\t\t       && bytes[i + 2] == 0 && bytes[i + 3] == 0);\n+\n+      CHECK (4, 32, 1, bytes[i] == 0 && bytes[i + 1] == bytes[1]\n+\t\t       && bytes[i + 2] == 0 && bytes[i + 3] == 0);\n+\n+      CHECK (4, 32, 2, bytes[i] == 0 && bytes[i + 1] == 0\n+\t\t       && bytes[i + 2] == bytes[2] && bytes[i + 3] == 0);\n+\n+      CHECK (4, 32, 3, bytes[i] == 0 && bytes[i + 1] == 0\n+\t\t       && bytes[i + 2] == 0 && bytes[i + 3] == bytes[3]);\n+\n+      CHECK (2, 16, 4, bytes[i] == bytes[0] && bytes[i + 1] == 0);\n+\n+      CHECK (2, 16, 5, bytes[i] == 0 && bytes[i + 1] == bytes[1]);\n+\n+      CHECK (4, 32, 6, bytes[i] == bytes[0] && bytes[i + 1] == 0xff\n+\t\t       && bytes[i + 2] == 0xff && bytes[i + 3] == 0xff);\n+\n+      CHECK (4, 32, 7, bytes[i] == 0xff && bytes[i + 1] == bytes[1]\n+\t\t       && bytes[i + 2] == 0xff && bytes[i + 3] == 0xff);\n+\n+      CHECK (4, 32, 8, bytes[i] == 0xff && bytes[i + 1] == 0xff\n+\t\t       && bytes[i + 2] == bytes[2] && bytes[i + 3] == 0xff);\n+\n+      CHECK (4, 32, 9, bytes[i] == 0xff && bytes[i + 1] == 0xff\n+\t\t       && bytes[i + 2] == 0xff && bytes[i + 3] == bytes[3]);\n+\n+      CHECK (2, 16, 10, bytes[i] == bytes[0] && bytes[i + 1] == 0xff);\n+\n+      CHECK (2, 16, 11, bytes[i] == 0xff && bytes[i + 1] == bytes[1]);\n+\n+      CHECK (4, 32, 12, bytes[i] == 0xff && bytes[i + 1] == bytes[1]\n+\t\t\t&& bytes[i + 2] == 0 && bytes[i + 3] == 0);\n+\n+      CHECK (4, 32, 13, bytes[i] == 0 && bytes[i + 1] == bytes[1]\n+\t\t\t&& bytes[i + 2] == 0xff && bytes[i + 3] == 0xff);\n+\n+      CHECK (4, 32, 14, bytes[i] == 0xff && bytes[i + 1] == 0xff\n+\t\t\t&& bytes[i + 2] == bytes[2] && bytes[i + 3] == 0);\n+\n+      CHECK (4, 32, 15, bytes[i] == 0 && bytes[i + 1] == 0\n+\t\t\t&& bytes[i + 2] == bytes[2] && bytes[i + 3] == 0xff);\n+\n+      CHECK (1, 8, 16, bytes[i] == bytes[0]);\n+\n+      CHECK (1, 64, 17, (bytes[i] == 0 || bytes[i] == 0xff)\n+\t\t\t&& bytes[i] == bytes[(i + 8) % idx]);\n+    }\n+  while (0);\n+\n+  if (immtype == -1)\n+    return -1;\n+\n+  if (elementwidth)\n+    *elementwidth = elsize;\n+\n+  if (modconst)\n+    {\n+      unsigned HOST_WIDE_INT imm = 0;\n+\n+      /* Un-invert bytes of recognized vector, if neccessary.  */\n+      if (invmask != 0)\n+        for (i = 0; i < idx; i++)\n+          bytes[i] ^= invmask;\n+\n+      if (immtype == 17)\n+        {\n+          /* FIXME: Broken on 32-bit H_W_I hosts.  */\n+          gcc_assert (sizeof (HOST_WIDE_INT) == 8);\n+\n+          for (i = 0; i < 8; i++)\n+            imm |= (unsigned HOST_WIDE_INT) (bytes[i] ? 0xff : 0)\n+                   << (i * BITS_PER_UNIT);\n+\n+          *modconst = GEN_INT (imm);\n+        }\n+      else\n+        {\n+          unsigned HOST_WIDE_INT imm = 0;\n+\n+          for (i = 0; i < elsize / BITS_PER_UNIT; i++)\n+            imm |= (unsigned HOST_WIDE_INT) bytes[i] << (i * BITS_PER_UNIT);\n+\n+          *modconst = GEN_INT (imm);\n+        }\n+    }\n+\n+  return immtype;\n+#undef CHECK\n+}\n+\n+/* Return TRUE if rtx X is legal for use as either a Neon VMOV (or, implicitly,\n+   VMVN) immediate. Write back width per element to *ELEMENTWIDTH (or zero for\n+   float elements), and a modified constant (whatever should be output for a\n+   VMOV) in *MODCONST.  */\n+\n+int\n+neon_immediate_valid_for_move (rtx op, enum machine_mode mode,\n+\t\t\t       rtx *modconst, int *elementwidth)\n+{\n+  rtx tmpconst;\n+  int tmpwidth;\n+  int retval = neon_valid_immediate (op, mode, 0, &tmpconst, &tmpwidth);\n+\n+  if (retval == -1)\n+    return 0;\n+\n+  if (modconst)\n+    *modconst = tmpconst;\n+\n+  if (elementwidth)\n+    *elementwidth = tmpwidth;\n+\n+  return 1;\n+}\n+\n+/* Return TRUE if rtx X is legal for use in a VORR or VBIC instruction.  If\n+   the immediate is valid, write a constant suitable for using as an operand\n+   to VORR/VBIC/VAND/VORN to *MODCONST and the corresponding element width to\n+   *ELEMENTWIDTH. See neon_valid_immediate for description of INVERSE.  */\n+\n+int\n+neon_immediate_valid_for_logic (rtx op, enum machine_mode mode, int inverse,\n+\t\t\t\trtx *modconst, int *elementwidth)\n+{\n+  rtx tmpconst;\n+  int tmpwidth;\n+  int retval = neon_valid_immediate (op, mode, inverse, &tmpconst, &tmpwidth);\n+\n+  if (retval < 0 || retval > 5)\n+    return 0;\n+\n+  if (modconst)\n+    *modconst = tmpconst;\n+\n+  if (elementwidth)\n+    *elementwidth = tmpwidth;\n+\n+  return 1;\n+}\n+\n+/* Return a string suitable for output of Neon immediate logic operation\n+   MNEM.  */\n+\n+char *\n+neon_output_logic_immediate (const char *mnem, rtx *op2, enum machine_mode mode,\n+\t\t\t     int inverse, int quad)\n+{\n+  int width, is_valid;\n+  static char templ[40];\n+\n+  is_valid = neon_immediate_valid_for_logic (*op2, mode, inverse, op2, &width);\n+\n+  gcc_assert (is_valid != 0);\n+\n+  if (quad)\n+    sprintf (templ, \"%s.i%d\\t%%q0, %%2\", mnem, width);\n+  else\n+    sprintf (templ, \"%s.i%d\\t%%P0, %%2\", mnem, width);\n+\n+  return templ;\n+}\n+\n+/* Output a sequence of pairwise operations to implement a reduction.\n+   NOTE: We do \"too much work\" here, because pairwise operations work on two\n+   registers-worth of operands in one go. Unfortunately we can't exploit those\n+   extra calculations to do the full operation in fewer steps, I don't think.\n+   Although all vector elements of the result but the first are ignored, we\n+   actually calculate the same result in each of the elements. An alternative\n+   such as initially loading a vector with zero to use as each of the second\n+   operands would use up an additional register and take an extra instruction,\n+   for no particular gain.  */\n+\n+void\n+neon_pairwise_reduce (rtx op0, rtx op1, enum machine_mode mode,\n+\t\t      rtx (*reduc) (rtx, rtx, rtx))\n+{\n+  enum machine_mode inner = GET_MODE_INNER (mode);\n+  unsigned int i, parts = GET_MODE_SIZE (mode) / GET_MODE_SIZE (inner);\n+  rtx tmpsum = op1;\n+\n+  for (i = parts / 2; i >= 1; i /= 2)\n+    {\n+      rtx dest = (i == 1) ? op0 : gen_reg_rtx (mode);\n+      emit_insn (reduc (dest, tmpsum, tmpsum));\n+      tmpsum = dest;\n+    }\n+}\n+\n+/* Initialise a vector with non-constant elements.  FIXME: We can do better\n+   than the current implementation (building a vector on the stack and then\n+   loading it) in many cases.  See rs6000.c.  */\n+\n+void\n+neon_expand_vector_init (rtx target, rtx vals)\n+{\n+  enum machine_mode mode = GET_MODE (target);\n+  enum machine_mode inner = GET_MODE_INNER (mode);\n+  unsigned int i, n_elts = GET_MODE_NUNITS (mode);\n+  rtx mem;\n+\n+  gcc_assert (VECTOR_MODE_P (mode));\n+\n+  mem = assign_stack_temp (mode, GET_MODE_SIZE (mode), 0);\n+  for (i = 0; i < n_elts; i++)\n+    emit_move_insn (adjust_address_nv (mem, inner, i * GET_MODE_SIZE (inner)),\n+                   XVECEXP (vals, 0, i));\n+\n+  emit_move_insn (target, mem);\n+}\n+\n \f\n /* Predicates for `match_operand' and `match_operator'.  */\n \n@@ -5974,6 +6342,110 @@ arm_coproc_mem_operand (rtx op, bool wb)\n   return FALSE;\n }\n \n+/* Return TRUE if OP is a memory operand which we can load or store a vector\n+   to/from. If CORE is true, we're moving from ARM registers not Neon\n+   registers.  */\n+int\n+neon_vector_mem_operand (rtx op, bool core)\n+{\n+  rtx ind;\n+\n+  /* Reject eliminable registers.  */\n+  if (! (reload_in_progress || reload_completed)\n+      && (   reg_mentioned_p (frame_pointer_rtx, op)\n+\t  || reg_mentioned_p (arg_pointer_rtx, op)\n+\t  || reg_mentioned_p (virtual_incoming_args_rtx, op)\n+\t  || reg_mentioned_p (virtual_outgoing_args_rtx, op)\n+\t  || reg_mentioned_p (virtual_stack_dynamic_rtx, op)\n+\t  || reg_mentioned_p (virtual_stack_vars_rtx, op)))\n+    return FALSE;\n+\n+  /* Constants are converted into offsets from labels.  */\n+  if (GET_CODE (op) != MEM)\n+    return FALSE;\n+\n+  ind = XEXP (op, 0);\n+\n+  if (reload_completed\n+      && (GET_CODE (ind) == LABEL_REF\n+\t  || (GET_CODE (ind) == CONST\n+\t      && GET_CODE (XEXP (ind, 0)) == PLUS\n+\t      && GET_CODE (XEXP (XEXP (ind, 0), 0)) == LABEL_REF\n+\t      && GET_CODE (XEXP (XEXP (ind, 0), 1)) == CONST_INT)))\n+    return TRUE;\n+\n+  /* Match: (mem (reg)).  */\n+  if (GET_CODE (ind) == REG)\n+    return arm_address_register_rtx_p (ind, 0);\n+\n+  /* Allow post-increment with Neon registers.  */\n+  if (!core && GET_CODE (ind) == POST_INC)\n+    return arm_address_register_rtx_p (XEXP (ind, 0), 0);\n+\n+#if 0\n+  /* FIXME: We can support this too if we use VLD1/VST1.  */\n+  if (!core\n+      && GET_CODE (ind) == POST_MODIFY\n+      && arm_address_register_rtx_p (XEXP (ind, 0), 0)\n+      && GET_CODE (XEXP (ind, 1)) == PLUS\n+      && rtx_equal_p (XEXP (XEXP (ind, 1), 0), XEXP (ind, 0)))\n+    ind = XEXP (ind, 1);\n+#endif\n+\n+  /* Match:\n+     (plus (reg)\n+          (const)).  */\n+  if (!core\n+      && GET_CODE (ind) == PLUS\n+      && GET_CODE (XEXP (ind, 0)) == REG\n+      && REG_MODE_OK_FOR_BASE_P (XEXP (ind, 0), VOIDmode)\n+      && GET_CODE (XEXP (ind, 1)) == CONST_INT\n+      && INTVAL (XEXP (ind, 1)) > -1024\n+      && INTVAL (XEXP (ind, 1)) < 1016\n+      && (INTVAL (XEXP (ind, 1)) & 3) == 0)\n+    return TRUE;\n+\n+  return FALSE;\n+}\n+\n+/* Return TRUE if OP is a mem suitable for loading/storing a Neon struct\n+   type.  */\n+int\n+neon_struct_mem_operand (rtx op)\n+{\n+  rtx ind;\n+\n+  /* Reject eliminable registers.  */\n+  if (! (reload_in_progress || reload_completed)\n+      && (   reg_mentioned_p (frame_pointer_rtx, op)\n+\t  || reg_mentioned_p (arg_pointer_rtx, op)\n+\t  || reg_mentioned_p (virtual_incoming_args_rtx, op)\n+\t  || reg_mentioned_p (virtual_outgoing_args_rtx, op)\n+\t  || reg_mentioned_p (virtual_stack_dynamic_rtx, op)\n+\t  || reg_mentioned_p (virtual_stack_vars_rtx, op)))\n+    return FALSE;\n+\n+  /* Constants are converted into offsets from labels.  */\n+  if (GET_CODE (op) != MEM)\n+    return FALSE;\n+\n+  ind = XEXP (op, 0);\n+\n+  if (reload_completed\n+      && (GET_CODE (ind) == LABEL_REF\n+\t  || (GET_CODE (ind) == CONST\n+\t      && GET_CODE (XEXP (ind, 0)) == PLUS\n+\t      && GET_CODE (XEXP (XEXP (ind, 0), 0)) == LABEL_REF\n+\t      && GET_CODE (XEXP (XEXP (ind, 0), 1)) == CONST_INT)))\n+    return TRUE;\n+\n+  /* Match: (mem (reg)).  */\n+  if (GET_CODE (ind) == REG)\n+    return arm_address_register_rtx_p (ind, 0);\n+\n+  return FALSE;\n+}\n+\n /* Return true if X is a register that will be eliminated later on.  */\n int\n arm_eliminable_register (rtx x)\n@@ -5990,6 +6462,12 @@ arm_eliminable_register (rtx x)\n enum reg_class\n coproc_secondary_reload_class (enum machine_mode mode, rtx x, bool wb)\n {\n+  if (TARGET_NEON\n+      && (GET_MODE_CLASS (mode) == MODE_VECTOR_INT\n+          || GET_MODE_CLASS (mode) == MODE_VECTOR_FLOAT)\n+      && neon_vector_mem_operand (x, FALSE))\n+     return NO_REGS;\n+\n   if (arm_coproc_mem_operand (x, wb) || s_register_operand (x, mode))\n     return NO_REGS;\n \n@@ -8055,8 +8533,8 @@ add_minipool_forward_ref (Mfix *fix)\n \t placed at the start of the pool.  */\n       if (ARM_DOUBLEWORD_ALIGN\n \t  && max_mp == NULL\n-\t  && fix->fix_size == 8\n-\t  && mp->fix_size != 8)\n+\t  && fix->fix_size >= 8\n+\t  && mp->fix_size < 8)\n \t{\n \t  max_mp = mp;\n \t  max_address = mp->max_address;\n@@ -8236,7 +8714,7 @@ add_minipool_backward_ref (Mfix *fix)\n \t      /* For now, we do not allow the insertion of 8-byte alignment\n \t\t requiring nodes anywhere but at the start of the pool.  */\n \t      if (ARM_DOUBLEWORD_ALIGN\n-\t\t  && fix->fix_size == 8 && mp->fix_size != 8)\n+\t\t  && fix->fix_size >= 8 && mp->fix_size < 8)\n \t\treturn NULL;\n \t      else\n \t\tmin_mp = mp;\n@@ -8257,7 +8735,7 @@ add_minipool_backward_ref (Mfix *fix)\n \t     placed at the start of the pool.  */\n \t  else if (ARM_DOUBLEWORD_ALIGN\n \t\t   && min_mp == NULL\n-\t\t   && fix->fix_size == 8\n+\t\t   && fix->fix_size >= 8\n \t\t   && mp->fix_size < 8)\n \t    {\n \t      min_mp = mp;\n@@ -8355,7 +8833,7 @@ dump_minipool (rtx scan)\n \n   if (ARM_DOUBLEWORD_ALIGN)\n     for (mp = minipool_vector_head; mp != NULL; mp = mp->next)\n-      if (mp->refcount > 0 && mp->fix_size == 8)\n+      if (mp->refcount > 0 && mp->fix_size >= 8)\n \t{\n \t  align64 = 1;\n \t  break;\n@@ -8409,6 +8887,12 @@ dump_minipool (rtx scan)\n \t      scan = emit_insn_after (gen_consttable_8 (mp->value), scan);\n \t      break;\n \n+#endif\n+#ifdef HAVE_consttable_16\n+\t    case 16:\n+              scan = emit_insn_after (gen_consttable_16 (mp->value), scan);\n+              break;\n+\n #endif\n \t    default:\n \t      gcc_unreachable ();\n@@ -8602,7 +9086,7 @@ push_minipool_fix (rtx insn, HOST_WIDE_INT address, rtx *loc,\n   /* If an entry requires 8-byte alignment then assume all constant pools\n      require 4 bytes of padding.  Trying to do this later on a per-pool\n      basis is awkward because existing pool entries have to be modified.  */\n-  if (ARM_DOUBLEWORD_ALIGN && fix->fix_size == 8)\n+  if (ARM_DOUBLEWORD_ALIGN && fix->fix_size >= 8)\n     minipool_pad = 4;\n \n   if (dump_file)\n@@ -9655,37 +10139,117 @@ output_move_double (rtx *operands)\n   return \"\";\n }\n \n-/* Output a VFP load or store instruction.  */\n+/* Output a move, load or store for quad-word vectors in ARM registers.  Only\n+   handles MEMs accepted by neon_vector_mem_operand with CORE=true.  */\n \n const char *\n-output_move_vfp (rtx *operands)\n+output_move_quad (rtx *operands)\n {\n-  rtx reg, mem, addr, ops[2];\n-  int load = REG_P (operands[0]);\n-  int dp = GET_MODE_SIZE (GET_MODE (operands[0])) == 8;\n-  int integer_p = GET_MODE_CLASS (GET_MODE (operands[0])) == MODE_INT;\n-  const char *template;\n-  char buff[50];\n+  if (REG_P (operands[0]))\n+    {\n+      /* Load, or reg->reg move.  */\n \n-  reg = operands[!load];\n-  mem = operands[load];\n+      if (MEM_P (operands[1]))\n+        {\n+          switch (GET_CODE (XEXP (operands[1], 0)))\n+            {\n+            case REG:\n+              output_asm_insn (\"ldm%(ia%)\\t%m1, %M0\", operands);\n+              break;\n+\n+            case LABEL_REF:\n+            case CONST:\n+              output_asm_insn (\"adr%?\\t%0, %1\", operands);\n+              output_asm_insn (\"ldm%(ia%)\\t%0, %M0\", operands);\n+              break;\n+\n+            default:\n+              gcc_unreachable ();\n+            }\n+        }\n+      else\n+        {\n+          rtx ops[2];\n+          int dest, src, i;\n \n-  gcc_assert (REG_P (reg));\n-  gcc_assert (IS_VFP_REGNUM (REGNO (reg)));\n-  gcc_assert (GET_MODE (reg) == SFmode\n-\t      || GET_MODE (reg) == DFmode\n-\t      || GET_MODE (reg) == SImode\n-\t      || GET_MODE (reg) == DImode);\n-  gcc_assert (MEM_P (mem));\n+          gcc_assert (REG_P (operands[1]));\n \n-  addr = XEXP (mem, 0);\n+          dest = REGNO (operands[0]);\n+          src = REGNO (operands[1]);\n \n-  switch (GET_CODE (addr))\n-    {\n-    case PRE_DEC:\n-      template = \"f%smdb%c%%?\\t%%0!, {%%%s1}%s\";\n-      ops[0] = XEXP (addr, 0);\n-      ops[1] = reg;\n+          /* This seems pretty dumb, but hopefully GCC won't try to do it\n+             very often.  */\n+          if (dest < src)\n+            for (i = 0; i < 4; i++)\n+              {\n+                ops[0] = gen_rtx_REG (SImode, dest + i);\n+                ops[1] = gen_rtx_REG (SImode, src + i);\n+                output_asm_insn (\"mov%?\\t%0, %1\", ops);\n+              }\n+          else\n+            for (i = 3; i >= 0; i--)\n+              {\n+                ops[0] = gen_rtx_REG (SImode, dest + i);\n+                ops[1] = gen_rtx_REG (SImode, src + i);\n+                output_asm_insn (\"mov%?\\t%0, %1\", ops);\n+              }\n+        }\n+    }\n+  else\n+    {\n+      gcc_assert (MEM_P (operands[0]));\n+      gcc_assert (REG_P (operands[1]));\n+      gcc_assert (!reg_overlap_mentioned_p (operands[1], operands[0]));\n+\n+      switch (GET_CODE (XEXP (operands[0], 0)))\n+        {\n+        case REG:\n+          output_asm_insn (\"stm%(ia%)\\t%m0, %M1\", operands);\n+          break;\n+\n+        default:\n+          gcc_unreachable ();\n+        }\n+    }\n+\n+  return \"\";\n+}\n+\n+/* Output a VFP load or store instruction.  */\n+\n+const char *\n+output_move_vfp (rtx *operands)\n+{\n+  rtx reg, mem, addr, ops[2];\n+  int load = REG_P (operands[0]);\n+  int dp = GET_MODE_SIZE (GET_MODE (operands[0])) == 8;\n+  int integer_p = GET_MODE_CLASS (GET_MODE (operands[0])) == MODE_INT;\n+  const char *template;\n+  char buff[50];\n+  enum machine_mode mode;\n+\n+  reg = operands[!load];\n+  mem = operands[load];\n+\n+  mode = GET_MODE (reg);\n+\n+  gcc_assert (REG_P (reg));\n+  gcc_assert (IS_VFP_REGNUM (REGNO (reg)));\n+  gcc_assert (mode == SFmode\n+\t      || mode == DFmode\n+\t      || mode == SImode\n+\t      || mode == DImode\n+              || (TARGET_NEON && VALID_NEON_DREG_MODE (mode)));\n+  gcc_assert (MEM_P (mem));\n+\n+  addr = XEXP (mem, 0);\n+\n+  switch (GET_CODE (addr))\n+    {\n+    case PRE_DEC:\n+      template = \"f%smdb%c%%?\\t%%0!, {%%%s1}%s\";\n+      ops[0] = XEXP (addr, 0);\n+      ops[1] = reg;\n       break;\n \n     case POST_INC:\n@@ -9711,6 +10275,118 @@ output_move_vfp (rtx *operands)\n   return \"\";\n }\n \n+/* Output a Neon quad-word load or store, or a load or store for\n+   larger structure modes. We could also support post-modify forms using\n+   VLD1/VST1 (for the vectorizer, and perhaps otherwise), but we don't do that\n+   yet.\n+   WARNING: The ordering of elements in memory is weird in big-endian mode,\n+   because we use VSTM instead of VST1, to make it easy to make vector stores\n+   via ARM registers write values in the same order as stores direct from Neon\n+   registers.  For example, the byte ordering of a quadword vector with 16-byte\n+   elements like this:\n+\n+     [e7:e6:e5:e4:e3:e2:e1:e0]  (highest-numbered element first)\n+\n+   will be (with lowest address first, h = most-significant byte,\n+   l = least-significant byte of element):\n+\n+     [e3h, e3l, e2h, e2l, e1h, e1l, e0h, e0l,\n+      e7h, e7l, e6h, e6l, e5h, e5l, e4h, e4l]\n+\n+   When necessary, quadword registers (dN, dN+1) are moved to ARM registers from\n+   rN in the order:\n+\n+     dN -> (rN+1, rN), dN+1 -> (rN+3, rN+2)\n+\n+   So that STM/LDM can be used on vectors in ARM registers, and the same memory\n+   layout will result as if VSTM/VLDM were used.  */\n+\n+const char *\n+output_move_neon (rtx *operands)\n+{\n+  rtx reg, mem, addr, ops[2];\n+  int regno, load = REG_P (operands[0]);\n+  const char *template;\n+  char buff[50];\n+  enum machine_mode mode;\n+\n+  reg = operands[!load];\n+  mem = operands[load];\n+\n+  mode = GET_MODE (reg);\n+\n+  gcc_assert (REG_P (reg));\n+  regno = REGNO (reg);\n+  gcc_assert (VFP_REGNO_OK_FOR_DOUBLE (regno)\n+\t      || NEON_REGNO_OK_FOR_QUAD (regno));\n+  gcc_assert (VALID_NEON_DREG_MODE (mode)\n+\t      || VALID_NEON_QREG_MODE (mode)\n+\t      || VALID_NEON_STRUCT_MODE (mode));\n+  gcc_assert (MEM_P (mem));\n+\n+  addr = XEXP (mem, 0);\n+\n+  /* Strip off const from addresses like (const (plus (...))).  */\n+  if (GET_CODE (addr) == CONST && GET_CODE (XEXP (addr, 0)) == PLUS)\n+    addr = XEXP (addr, 0);\n+\n+  switch (GET_CODE (addr))\n+    {\n+    case POST_INC:\n+      template = \"v%smia%%?\\t%%0!, %%h1\";\n+      ops[0] = XEXP (addr, 0);\n+      ops[1] = reg;\n+      break;\n+\n+    case POST_MODIFY:\n+      /* FIXME: Not currently enabled in neon_vector_mem_operand.  */\n+      gcc_unreachable ();\n+\n+    case LABEL_REF:\n+    case PLUS:\n+      {\n+\tint nregs = HARD_REGNO_NREGS (REGNO (reg), mode) / 2;\n+\tint i;\n+\tint overlap = -1;\n+\tfor (i = 0; i < nregs; i++)\n+\t  {\n+\t    /* We're only using DImode here because it's a convenient size.  */\n+\t    ops[0] = gen_rtx_REG (DImode, REGNO (reg) + 2 * i);\n+\t    ops[1] = adjust_address (mem, SImode, 8 * i);\n+\t    if (reg_overlap_mentioned_p (ops[0], mem))\n+\t      {\n+\t\tgcc_assert (overlap == -1);\n+\t\toverlap = i;\n+\t      }\n+\t    else\n+\t      {\n+\t\tsprintf (buff, \"v%sr%%?\\t%%P0, %%1\", load ? \"ld\" : \"st\");\n+\t\toutput_asm_insn (buff, ops);\n+\t      }\n+\t  }\n+\tif (overlap != -1)\n+\t  {\n+\t    ops[0] = gen_rtx_REG (DImode, REGNO (reg) + 2 * overlap);\n+\t    ops[1] = adjust_address (mem, SImode, 8 * overlap);\n+\t    sprintf (buff, \"v%sr%%?\\t%%P0, %%1\", load ? \"ld\" : \"st\");\n+\t    output_asm_insn (buff, ops);\n+\t  }\n+\n+        return \"\";\n+      }\n+\n+    default:\n+      template = \"v%smia%%?\\t%%m0, %%h1\";\n+      ops[0] = mem;\n+      ops[1] = reg;\n+    }\n+\n+  sprintf (buff, template, load ? \"ld\" : \"st\");\n+  output_asm_insn (buff, ops);\n+\n+  return \"\";\n+}\n+\n /* Output an ADD r, s, #n where n may be too big for one instruction.\n    If adding zero to one register, output nothing.  */\n const char *\n@@ -11941,6 +12617,13 @@ arm_print_operand (FILE *stream, rtx x, int code)\n \tfputc('s', stream);\n       break;\n \n+    /* %# is a \"break\" sequence. It doesn't output anything, but is used to\n+       seperate e.g. operand numbers from following text, if that text consists\n+       of further digits which we don't want to be part of the operand\n+       number.  */\n+    case '#':\n+      return;\n+\n     case 'N':\n       {\n \tREAL_VALUE_TYPE r;\n@@ -11950,6 +12633,12 @@ arm_print_operand (FILE *stream, rtx x, int code)\n       }\n       return;\n \n+    /* An integer without a preceding # sign.  */\n+    case 'c':\n+      gcc_assert (GET_CODE (x) == CONST_INT);\n+      fprintf (stream, HOST_WIDE_INT_PRINT_DEC, INTVAL (x));\n+      return;\n+\n     case 'B':\n       if (GET_CODE (x) == CONST_INT)\n \t{\n@@ -12068,6 +12757,26 @@ arm_print_operand (FILE *stream, rtx x, int code)\n       asm_fprintf (stream, \"%r\", REGNO (x) + 1);\n       return;\n \n+    case 'J':\n+      if (GET_CODE (x) != REG || REGNO (x) > LAST_ARM_REGNUM)\n+\t{\n+\t  output_operand_lossage (\"invalid operand for code '%c'\", code);\n+\t  return;\n+\t}\n+\n+      asm_fprintf (stream, \"%r\", REGNO (x) + (WORDS_BIG_ENDIAN ? 3 : 2));\n+      return;\n+\n+    case 'K':\n+      if (GET_CODE (x) != REG || REGNO (x) > LAST_ARM_REGNUM)\n+\t{\n+\t  output_operand_lossage (\"invalid operand for code '%c'\", code);\n+\t  return;\n+\t}\n+\n+      asm_fprintf (stream, \"%r\", REGNO (x) + (WORDS_BIG_ENDIAN ? 2 : 3));\n+      return;\n+\n     case 'm':\n       asm_fprintf (stream, \"%r\",\n \t\t   GET_CODE (XEXP (x, 0)) == REG\n@@ -12080,6 +12789,19 @@ arm_print_operand (FILE *stream, rtx x, int code)\n \t\t   REGNO (x) + ARM_NUM_REGS (GET_MODE (x)) - 1);\n       return;\n \n+    /* Like 'M', but writing doubleword vector registers, for use by Neon\n+       insns.  */\n+    case 'h':\n+      {\n+        int regno = (REGNO (x) - FIRST_VFP_REGNUM) / 2;\n+        int numregs = ARM_NUM_REGS (GET_MODE (x)) / 2;\n+        if (numregs == 1)\n+          asm_fprintf (stream, \"{d%d}\", regno);\n+        else\n+          asm_fprintf (stream, \"{d%d-d%d}\", regno, regno + numregs - 1);\n+      }\n+      return;\n+\n     case 'd':\n       /* CONST_TRUE_RTX means always -- that's the default.  */\n       if (x == const_true_rtx)\n@@ -12192,13 +12914,15 @@ arm_print_operand (FILE *stream, rtx x, int code)\n \t}\n       return;\n \n-      /* Print a VFP double precision register name.  */\n+    /* Print a VFP/Neon double precision or quad precision register name.  */\n     case 'P':\n+    case 'q':\n       {\n \tint mode = GET_MODE (x);\n-\tint num;\n+\tint is_quad = (code == 'q');\n+\tint regno;\n \n-\tif (mode != DImode && mode != DFmode)\n+\tif (GET_MODE_SIZE (mode) != (is_quad ? 16 : 8))\n \t  {\n \t    output_operand_lossage (\"invalid operand for code '%c'\", code);\n \t    return;\n@@ -12211,14 +12935,48 @@ arm_print_operand (FILE *stream, rtx x, int code)\n \t    return;\n \t  }\n \n-\tnum = REGNO(x) - FIRST_VFP_REGNUM;\n-\tif (num & 1)\n+\tregno = REGNO (x);\n+\tif ((is_quad && !NEON_REGNO_OK_FOR_QUAD (regno))\n+            || (!is_quad && !VFP_REGNO_OK_FOR_DOUBLE (regno)))\n \t  {\n \t    output_operand_lossage (\"invalid operand for code '%c'\", code);\n \t    return;\n \t  }\n \n-\tfprintf (stream, \"d%d\", num >> 1);\n+\tfprintf (stream, \"%c%d\", is_quad ? 'q' : 'd',\n+\t  (regno - FIRST_VFP_REGNUM) >> (is_quad ? 2 : 1));\n+      }\n+      return;\n+\n+    /* These two codes print the low/high doubleword register of a Neon quad\n+       register, respectively.  For pair-structure types, can also print\n+       low/high quadword registers.  */\n+    case 'e':\n+    case 'f':\n+      {\n+        int mode = GET_MODE (x);\n+        int regno;\n+\n+        if ((GET_MODE_SIZE (mode) != 16\n+\t     && GET_MODE_SIZE (mode) != 32) || GET_CODE (x) != REG)\n+          {\n+\t    output_operand_lossage (\"invalid operand for code '%c'\", code);\n+\t    return;\n+          }\n+\n+        regno = REGNO (x);\n+        if (!NEON_REGNO_OK_FOR_QUAD (regno))\n+          {\n+\t    output_operand_lossage (\"invalid operand for code '%c'\", code);\n+\t    return;\n+          }\n+\n+        if (GET_MODE_SIZE (mode) == 16)\n+          fprintf (stream, \"d%d\", ((regno - FIRST_VFP_REGNUM) >> 1)\n+\t\t\t\t  + (code == 'f' ? 1 : 0));\n+        else\n+          fprintf (stream, \"q%d\", ((regno - FIRST_VFP_REGNUM) >> 2)\n+\t\t\t\t  + (code == 'f' ? 1 : 0));\n       }\n       return;\n \n@@ -12232,6 +12990,47 @@ arm_print_operand (FILE *stream, rtx x, int code)\n       }\n       return;\n \n+    /* Print bits representing opcode features for Neon.\n+\n+       Bit 0 is 1 for signed, 0 for unsigned.  Floats count as signed\n+       and polynomials as unsigned.\n+\n+       Bit 1 is 1 for floats and polynomials, 0 for ordinary integers.\n+\n+       Bit 2 is 1 for rounding functions, 0 otherwise.  */\n+\n+    /* Identify the type as 's', 'u', 'p' or 'f'.  */\n+    case 'T':\n+      {\n+        HOST_WIDE_INT bits = INTVAL (x);\n+        fputc (\"uspf\"[bits & 3], stream);\n+      }\n+      return;\n+\n+    /* Likewise, but signed and unsigned integers are both 'i'.  */\n+    case 'F':\n+      {\n+        HOST_WIDE_INT bits = INTVAL (x);\n+        fputc (\"iipf\"[bits & 3], stream);\n+      }\n+      return;\n+\n+    /* As for 'T', but emit 'u' instead of 'p'.  */\n+    case 't':\n+      {\n+        HOST_WIDE_INT bits = INTVAL (x);\n+        fputc (\"usuf\"[bits & 3], stream);\n+      }\n+      return;\n+\n+    /* Bit 2: rounding (vs none).  */\n+    case 'O':\n+      {\n+        HOST_WIDE_INT bits = INTVAL (x);\n+        fputs ((bits & 4) != 0 ? \"r\" : \"\", stream);\n+      }\n+      return;\n+\n     default:\n       if (x == 0)\n \t{\n@@ -12251,7 +13050,15 @@ arm_print_operand (FILE *stream, rtx x, int code)\n \t  break;\n \n \tcase CONST_DOUBLE:\n-\t  fprintf (stream, \"#%s\", fp_immediate_constant (x));\n+          if (TARGET_NEON)\n+            {\n+              char fpstr[20];\n+              real_to_decimal (fpstr, CONST_DOUBLE_REAL_VALUE (x),\n+\t\t\t       sizeof (fpstr), 0, 1);\n+              fprintf (stream, \"#%s\", fpstr);\n+            }\n+          else\n+\t    fprintf (stream, \"#%s\", fp_immediate_constant (x));\n \t  break;\n \n \tdefault:\n@@ -12269,6 +13076,8 @@ arm_print_operand (FILE *stream, rtx x, int code)\n static bool\n arm_assemble_integer (rtx x, unsigned int size, int aligned_p)\n {\n+  enum machine_mode mode;\n+\n   if (size == UNITS_PER_WORD && aligned_p)\n     {\n       fputs (\"\\t.word\\t\", asm_out_file);\n@@ -12291,31 +13100,48 @@ arm_assemble_integer (rtx x, unsigned int size, int aligned_p)\n       return true;\n     }\n \n-  if (arm_vector_mode_supported_p (GET_MODE (x)))\n+  mode = GET_MODE (x);\n+\n+  if (arm_vector_mode_supported_p (mode))\n     {\n       int i, units;\n+      unsigned int invmask = 0, parts_per_word;\n \n       gcc_assert (GET_CODE (x) == CONST_VECTOR);\n \n       units = CONST_VECTOR_NUNITS (x);\n+      size = GET_MODE_SIZE (GET_MODE_INNER (mode));\n \n-      switch (GET_MODE (x))\n-\t{\n-\tcase V2SImode: size = 4; break;\n-\tcase V4HImode: size = 2; break;\n-\tcase V8QImode: size = 1; break;\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n+      /* For big-endian Neon vectors, we must permute the vector to the form\n+         which, when loaded by a VLDR or VLDM instruction, will give a vector\n+         with the elements in the right order.  */\n+      if (TARGET_NEON && WORDS_BIG_ENDIAN)\n+        {\n+          parts_per_word = UNITS_PER_WORD / size;\n+          /* FIXME: This might be wrong for 64-bit vector elements, but we don't\n+             support those anywhere yet.  */\n+          invmask = (parts_per_word == 0) ? 0 : (1 << (parts_per_word - 1)) - 1;\n+        }\n \n-      for (i = 0; i < units; i++)\n-\t{\n-\t  rtx elt;\n+      if (GET_MODE_CLASS (mode) == MODE_VECTOR_INT)\n+        for (i = 0; i < units; i++)\n+\t  {\n+\t    rtx elt = CONST_VECTOR_ELT (x, i ^ invmask);\n+\t    assemble_integer\n+\t      (elt, size, i == 0 ? BIGGEST_ALIGNMENT : size * BITS_PER_UNIT, 1);\n+\t  }\n+      else\n+        for (i = 0; i < units; i++)\n+          {\n+            rtx elt = CONST_VECTOR_ELT (x, i);\n+            REAL_VALUE_TYPE rval;\n \n-\t  elt = CONST_VECTOR_ELT (x, i);\n-\t  assemble_integer\n-\t    (elt, size, i == 0 ? BIGGEST_ALIGNMENT : size * BITS_PER_UNIT, 1);\n-\t}\n+            REAL_VALUE_FROM_CONST_DOUBLE (rval, elt);\n+\n+            assemble_real\n+              (rval, GET_MODE_INNER (mode),\n+              i == 0 ? BIGGEST_ALIGNMENT : size * BITS_PER_UNIT);\n+          }\n \n       return true;\n     }\n@@ -13015,6 +13841,17 @@ arm_hard_regno_mode_ok (unsigned int regno, enum machine_mode mode)\n \n       if (mode == DFmode)\n \treturn VFP_REGNO_OK_FOR_DOUBLE (regno);\n+\n+      if (TARGET_NEON)\n+        return (VALID_NEON_DREG_MODE (mode) && VFP_REGNO_OK_FOR_DOUBLE (regno))\n+               || (VALID_NEON_QREG_MODE (mode)\n+                   && NEON_REGNO_OK_FOR_QUAD (regno))\n+\t       || (mode == TImode && NEON_REGNO_OK_FOR_NREGS (regno, 2))\n+\t       || (mode == EImode && NEON_REGNO_OK_FOR_NREGS (regno, 3))\n+\t       || (mode == OImode && NEON_REGNO_OK_FOR_NREGS (regno, 4))\n+\t       || (mode == CImode && NEON_REGNO_OK_FOR_NREGS (regno, 6))\n+\t       || (mode == XImode && NEON_REGNO_OK_FOR_NREGS (regno, 8));\n+\n       return FALSE;\n     }\n \n@@ -13029,9 +13866,11 @@ arm_hard_regno_mode_ok (unsigned int regno, enum machine_mode mode)\n   \n   /* We allow any value to be stored in the general registers.\n      Restrict doubleword quantities to even register pairs so that we can\n-     use ldrd.  */\n+     use ldrd.  Do not allow Neon structure opaque modes in general registers;\n+     they would use too many.  */\n   if (regno <= LAST_ARM_REGNUM)\n-    return !(TARGET_LDRD && GET_MODE_SIZE (mode) > 4 && (regno & 1) != 0);\n+    return !(TARGET_LDRD && GET_MODE_SIZE (mode) > 4 && (regno & 1) != 0)\n+      && !VALID_NEON_STRUCT_MODE (mode);\n \n   if (regno == FRAME_POINTER_REGNUM\n       || regno == ARG_POINTER_REGNUM)\n@@ -13273,21 +14112,21 @@ static const struct builtin_description bdesc_2arg[] =\n   IWMMXT_BUILTIN2 (iwmmxt_wpackwus, WPACKWUS)\n   IWMMXT_BUILTIN2 (iwmmxt_wpackdus, WPACKDUS)\n   IWMMXT_BUILTIN2 (ashlv4hi3_di,    WSLLH)\n-  IWMMXT_BUILTIN2 (ashlv4hi3,       WSLLHI)\n+  IWMMXT_BUILTIN2 (ashlv4hi3_iwmmxt, WSLLHI)\n   IWMMXT_BUILTIN2 (ashlv2si3_di,    WSLLW)\n-  IWMMXT_BUILTIN2 (ashlv2si3,       WSLLWI)\n+  IWMMXT_BUILTIN2 (ashlv2si3_iwmmxt, WSLLWI)\n   IWMMXT_BUILTIN2 (ashldi3_di,      WSLLD)\n   IWMMXT_BUILTIN2 (ashldi3_iwmmxt,  WSLLDI)\n   IWMMXT_BUILTIN2 (lshrv4hi3_di,    WSRLH)\n-  IWMMXT_BUILTIN2 (lshrv4hi3,       WSRLHI)\n+  IWMMXT_BUILTIN2 (lshrv4hi3_iwmmxt, WSRLHI)\n   IWMMXT_BUILTIN2 (lshrv2si3_di,    WSRLW)\n-  IWMMXT_BUILTIN2 (lshrv2si3,       WSRLWI)\n+  IWMMXT_BUILTIN2 (lshrv2si3_iwmmxt, WSRLWI)\n   IWMMXT_BUILTIN2 (lshrdi3_di,      WSRLD)\n   IWMMXT_BUILTIN2 (lshrdi3_iwmmxt,  WSRLDI)\n   IWMMXT_BUILTIN2 (ashrv4hi3_di,    WSRAH)\n-  IWMMXT_BUILTIN2 (ashrv4hi3,       WSRAHI)\n+  IWMMXT_BUILTIN2 (ashrv4hi3_iwmmxt, WSRAHI)\n   IWMMXT_BUILTIN2 (ashrv2si3_di,    WSRAW)\n-  IWMMXT_BUILTIN2 (ashrv2si3,       WSRAWI)\n+  IWMMXT_BUILTIN2 (ashrv2si3_iwmmxt, WSRAWI)\n   IWMMXT_BUILTIN2 (ashrdi3_di,      WSRAD)\n   IWMMXT_BUILTIN2 (ashrdi3_iwmmxt,  WSRADI)\n   IWMMXT_BUILTIN2 (rorv4hi3_di,     WRORH)\n@@ -13661,13 +14500,776 @@ arm_init_tls_builtins (void)\n \t\t\tNULL, const_nothrow);\n }\n \n+typedef enum {\n+  T_V8QI  = 0x0001,\n+  T_V4HI  = 0x0002,\n+  T_V2SI  = 0x0004,\n+  T_V2SF  = 0x0008,\n+  T_DI    = 0x0010,\n+  T_V16QI = 0x0020,\n+  T_V8HI  = 0x0040,\n+  T_V4SI  = 0x0080,\n+  T_V4SF  = 0x0100,\n+  T_V2DI  = 0x0200,\n+  T_TI\t  = 0x0400,\n+  T_EI\t  = 0x0800,\n+  T_OI\t  = 0x1000\n+} neon_builtin_type_bits;\n+\n+#define v8qi_UP  T_V8QI\n+#define v4hi_UP  T_V4HI\n+#define v2si_UP  T_V2SI\n+#define v2sf_UP  T_V2SF\n+#define di_UP    T_DI\n+#define v16qi_UP T_V16QI\n+#define v8hi_UP  T_V8HI\n+#define v4si_UP  T_V4SI\n+#define v4sf_UP  T_V4SF\n+#define v2di_UP  T_V2DI\n+#define ti_UP\t T_TI\n+#define ei_UP\t T_EI\n+#define oi_UP\t T_OI\n+\n+#define UP(X) X##_UP\n+\n+#define T_MAX 13\n+\n+typedef enum {\n+  NEON_BINOP,\n+  NEON_TERNOP,\n+  NEON_UNOP,\n+  NEON_GETLANE,\n+  NEON_SETLANE,\n+  NEON_CREATE,\n+  NEON_DUP,\n+  NEON_DUPLANE,\n+  NEON_COMBINE,\n+  NEON_SPLIT,\n+  NEON_LANEMUL,\n+  NEON_LANEMULL,\n+  NEON_LANEMULH,\n+  NEON_LANEMAC,\n+  NEON_SCALARMUL,\n+  NEON_SCALARMULL,\n+  NEON_SCALARMULH,\n+  NEON_SCALARMAC,\n+  NEON_CONVERT,\n+  NEON_FIXCONV,\n+  NEON_SELECT,\n+  NEON_RESULTPAIR,\n+  NEON_REINTERP,\n+  NEON_VTBL,\n+  NEON_VTBX,\n+  NEON_LOAD1,\n+  NEON_LOAD1LANE,\n+  NEON_STORE1,\n+  NEON_STORE1LANE,\n+  NEON_LOADSTRUCT,\n+  NEON_LOADSTRUCTLANE,\n+  NEON_STORESTRUCT,\n+  NEON_STORESTRUCTLANE,\n+  NEON_LOGICBINOP,\n+  NEON_SHIFTINSERT,\n+  NEON_SHIFTIMM,\n+  NEON_SHIFTACC\n+} neon_itype;\n+\n+typedef struct {\n+  const char *name;\n+  const neon_itype itype;\n+  const neon_builtin_type_bits bits;\n+  const enum insn_code codes[T_MAX];\n+  const unsigned int num_vars;\n+  unsigned int base_fcode;\n+} neon_builtin_datum;\n+\n+#define CF(N,X) CODE_FOR_neon_##N##X\n+\n+#define VAR1(T, N, A) \\\n+  #N, NEON_##T, UP (A), { CF (N, A) }, 1, 0\n+#define VAR2(T, N, A, B) \\\n+  #N, NEON_##T, UP (A) | UP (B), { CF (N, A), CF (N, B) }, 2, 0\n+#define VAR3(T, N, A, B, C) \\\n+  #N, NEON_##T, UP (A) | UP (B) | UP (C), \\\n+  { CF (N, A), CF (N, B), CF (N, C) }, 3, 0\n+#define VAR4(T, N, A, B, C, D) \\\n+  #N, NEON_##T, UP (A) | UP (B) | UP (C) | UP (D), \\\n+  { CF (N, A), CF (N, B), CF (N, C), CF (N, D) }, 4, 0\n+#define VAR5(T, N, A, B, C, D, E) \\\n+  #N, NEON_##T, UP (A) | UP (B) | UP (C) | UP (D) | UP (E), \\\n+  { CF (N, A), CF (N, B), CF (N, C), CF (N, D), CF (N, E) }, 5, 0\n+#define VAR6(T, N, A, B, C, D, E, F) \\\n+  #N, NEON_##T, UP (A) | UP (B) | UP (C) | UP (D) | UP (E) | UP (F), \\\n+  { CF (N, A), CF (N, B), CF (N, C), CF (N, D), CF (N, E), CF (N, F) }, 6, 0\n+#define VAR7(T, N, A, B, C, D, E, F, G) \\\n+  #N, NEON_##T, UP (A) | UP (B) | UP (C) | UP (D) | UP (E) | UP (F) | UP (G), \\\n+  { CF (N, A), CF (N, B), CF (N, C), CF (N, D), CF (N, E), CF (N, F), \\\n+    CF (N, G) }, 7, 0\n+#define VAR8(T, N, A, B, C, D, E, F, G, H) \\\n+  #N, NEON_##T, UP (A) | UP (B) | UP (C) | UP (D) | UP (E) | UP (F) | UP (G) \\\n+                | UP (H), \\\n+  { CF (N, A), CF (N, B), CF (N, C), CF (N, D), CF (N, E), CF (N, F), \\\n+    CF (N, G), CF (N, H) }, 8, 0\n+#define VAR9(T, N, A, B, C, D, E, F, G, H, I) \\\n+  #N, NEON_##T, UP (A) | UP (B) | UP (C) | UP (D) | UP (E) | UP (F) | UP (G) \\\n+                | UP (H) | UP (I), \\\n+  { CF (N, A), CF (N, B), CF (N, C), CF (N, D), CF (N, E), CF (N, F), \\\n+    CF (N, G), CF (N, H), CF (N, I) }, 9, 0\n+#define VAR10(T, N, A, B, C, D, E, F, G, H, I, J) \\\n+  #N, NEON_##T, UP (A) | UP (B) | UP (C) | UP (D) | UP (E) | UP (F) | UP (G) \\\n+                | UP (H) | UP (I) | UP (J), \\\n+  { CF (N, A), CF (N, B), CF (N, C), CF (N, D), CF (N, E), CF (N, F), \\\n+    CF (N, G), CF (N, H), CF (N, I), CF (N, J) }, 10, 0\n+\n+/* The mode entries in the following table correspond to the \"key\" type of the\n+   instruction variant, i.e. equivalent to that which would be specified after\n+   the assembler mnemonic, which usually refers to the last vector operand.\n+   (Signed/unsigned/polynomial types are not differentiated between though, and\n+   are all mapped onto the same mode for a given element size.) The modes\n+   listed per instruction should be the same as those defined for that\n+   instruction's pattern in neon.md.\n+   WARNING: Variants should be listed in the same increasing order as\n+   neon_builtin_type_bits.  */\n+\n+static neon_builtin_datum neon_builtin_data[] =\n+{\n+  { VAR10 (BINOP, vadd,\n+\t   v8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf, v2di) },\n+  { VAR3 (BINOP, vaddl, v8qi, v4hi, v2si) },\n+  { VAR3 (BINOP, vaddw, v8qi, v4hi, v2si) },\n+  { VAR6 (BINOP, vhadd, v8qi, v4hi, v2si, v16qi, v8hi, v4si) },\n+  { VAR8 (BINOP, vqadd, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di) },\n+  { VAR3 (BINOP, vaddhn, v8hi, v4si, v2di) },\n+  { VAR8 (BINOP, vmul, v8qi, v4hi, v2si, v2sf, v16qi, v8hi, v4si, v4sf) },\n+  { VAR8 (TERNOP, vmla, v8qi, v4hi, v2si, v2sf, v16qi, v8hi, v4si, v4sf) },\n+  { VAR3 (TERNOP, vmlal, v8qi, v4hi, v2si) },\n+  { VAR8 (TERNOP, vmls, v8qi, v4hi, v2si, v2sf, v16qi, v8hi, v4si, v4sf) },\n+  { VAR3 (TERNOP, vmlsl, v8qi, v4hi, v2si) },\n+  { VAR4 (BINOP, vqdmulh, v4hi, v2si, v8hi, v4si) },\n+  { VAR2 (TERNOP, vqdmlal, v4hi, v2si) },\n+  { VAR2 (TERNOP, vqdmlsl, v4hi, v2si) },\n+  { VAR3 (BINOP, vmull, v8qi, v4hi, v2si) },\n+  { VAR2 (SCALARMULL, vmull_n, v4hi, v2si) },\n+  { VAR2 (LANEMULL, vmull_lane, v4hi, v2si) },\n+  { VAR2 (SCALARMULL, vqdmull_n, v4hi, v2si) },\n+  { VAR2 (LANEMULL, vqdmull_lane, v4hi, v2si) },\n+  { VAR4 (SCALARMULH, vqdmulh_n, v4hi, v2si, v8hi, v4si) },\n+  { VAR4 (LANEMULH, vqdmulh_lane, v4hi, v2si, v8hi, v4si) },\n+  { VAR2 (BINOP, vqdmull, v4hi, v2si) },\n+  { VAR8 (BINOP, vshl, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di) },\n+  { VAR8 (BINOP, vqshl, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di) },\n+  { VAR8 (SHIFTIMM, vshr_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di) },\n+  { VAR3 (SHIFTIMM, vshrn_n, v8hi, v4si, v2di) },\n+  { VAR3 (SHIFTIMM, vqshrn_n, v8hi, v4si, v2di) },\n+  { VAR3 (SHIFTIMM, vqshrun_n, v8hi, v4si, v2di) },\n+  { VAR8 (SHIFTIMM, vshl_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di) },\n+  { VAR8 (SHIFTIMM, vqshl_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di) },\n+  { VAR8 (SHIFTIMM, vqshlu_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di) },\n+  { VAR3 (SHIFTIMM, vshll_n, v8qi, v4hi, v2si) },\n+  { VAR8 (SHIFTACC, vsra_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di) },\n+  { VAR10 (BINOP, vsub,\n+\t   v8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf, v2di) },\n+  { VAR3 (BINOP, vsubl, v8qi, v4hi, v2si) },\n+  { VAR3 (BINOP, vsubw, v8qi, v4hi, v2si) },\n+  { VAR8 (BINOP, vqsub, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di) },\n+  { VAR6 (BINOP, vhsub, v8qi, v4hi, v2si, v16qi, v8hi, v4si) },\n+  { VAR3 (BINOP, vsubhn, v8hi, v4si, v2di) },\n+  { VAR8 (BINOP, vceq, v8qi, v4hi, v2si, v2sf, v16qi, v8hi, v4si, v4sf) },\n+  { VAR8 (BINOP, vcge, v8qi, v4hi, v2si, v2sf, v16qi, v8hi, v4si, v4sf) },\n+  { VAR8 (BINOP, vcgt, v8qi, v4hi, v2si, v2sf, v16qi, v8hi, v4si, v4sf) },\n+  { VAR2 (BINOP, vcage, v2sf, v4sf) },\n+  { VAR2 (BINOP, vcagt, v2sf, v4sf) },\n+  { VAR6 (BINOP, vtst, v8qi, v4hi, v2si, v16qi, v8hi, v4si) },\n+  { VAR8 (BINOP, vabd, v8qi, v4hi, v2si, v2sf, v16qi, v8hi, v4si, v4sf) },\n+  { VAR3 (BINOP, vabdl, v8qi, v4hi, v2si) },\n+  { VAR6 (TERNOP, vaba, v8qi, v4hi, v2si, v16qi, v8hi, v4si) },\n+  { VAR3 (TERNOP, vabal, v8qi, v4hi, v2si) },\n+  { VAR8 (BINOP, vmax, v8qi, v4hi, v2si, v2sf, v16qi, v8hi, v4si, v4sf) },\n+  { VAR8 (BINOP, vmin, v8qi, v4hi, v2si, v2sf, v16qi, v8hi, v4si, v4sf) },\n+  { VAR4 (BINOP, vpadd, v8qi, v4hi, v2si, v2sf) },\n+  { VAR6 (UNOP, vpaddl, v8qi, v4hi, v2si, v16qi, v8hi, v4si) },\n+  { VAR6 (BINOP, vpadal, v8qi, v4hi, v2si, v16qi, v8hi, v4si) },\n+  { VAR4 (BINOP, vpmax, v8qi, v4hi, v2si, v2sf) },\n+  { VAR4 (BINOP, vpmin, v8qi, v4hi, v2si, v2sf) },\n+  { VAR2 (BINOP, vrecps, v2sf, v4sf) },\n+  { VAR2 (BINOP, vrsqrts, v2sf, v4sf) },\n+  { VAR8 (SHIFTINSERT, vsri_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di) },\n+  { VAR8 (SHIFTINSERT, vsli_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di) },\n+  { VAR8 (UNOP, vabs, v8qi, v4hi, v2si, v2sf, v16qi, v8hi, v4si, v4sf) },\n+  { VAR6 (UNOP, vqabs, v8qi, v4hi, v2si, v16qi, v8hi, v4si) },\n+  { VAR8 (UNOP, vneg, v8qi, v4hi, v2si, v2sf, v16qi, v8hi, v4si, v4sf) },\n+  { VAR6 (UNOP, vqneg, v8qi, v4hi, v2si, v16qi, v8hi, v4si) },\n+  { VAR6 (UNOP, vcls, v8qi, v4hi, v2si, v16qi, v8hi, v4si) },\n+  { VAR6 (UNOP, vclz, v8qi, v4hi, v2si, v16qi, v8hi, v4si) },\n+  { VAR2 (UNOP, vcnt, v8qi, v16qi) },\n+  { VAR4 (UNOP, vrecpe, v2si, v2sf, v4si, v4sf) },\n+  { VAR4 (UNOP, vrsqrte, v2si, v2sf, v4si, v4sf) },\n+  { VAR6 (UNOP, vmvn, v8qi, v4hi, v2si, v16qi, v8hi, v4si) },\n+  /* FIXME: vget_lane supports more variants than this!  */\n+  { VAR10 (GETLANE, vget_lane,\n+\t   v8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf, v2di) },\n+  { VAR10 (SETLANE, vset_lane,\n+\t   v8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf, v2di) },\n+  { VAR5 (CREATE, vcreate, v8qi, v4hi, v2si, v2sf, di) },\n+  { VAR10 (DUP, vdup_n,\n+\t   v8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf, v2di) },\n+  { VAR10 (DUPLANE, vdup_lane,\n+\t   v8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf, v2di) },\n+  { VAR5 (COMBINE, vcombine, v8qi, v4hi, v2si, v2sf, di) },\n+  { VAR5 (SPLIT, vget_high, v16qi, v8hi, v4si, v4sf, v2di) },\n+  { VAR5 (SPLIT, vget_low, v16qi, v8hi, v4si, v4sf, v2di) },\n+  { VAR3 (UNOP, vmovn, v8hi, v4si, v2di) },\n+  { VAR3 (UNOP, vqmovn, v8hi, v4si, v2di) },\n+  { VAR3 (UNOP, vqmovun, v8hi, v4si, v2di) },\n+  { VAR3 (UNOP, vmovl, v8qi, v4hi, v2si) },\n+  { VAR6 (LANEMUL, vmul_lane, v4hi, v2si, v2sf, v8hi, v4si, v4sf) },\n+  { VAR6 (LANEMAC, vmla_lane, v4hi, v2si, v2sf, v8hi, v4si, v4sf) },\n+  { VAR2 (LANEMAC, vmlal_lane, v4hi, v2si) },\n+  { VAR2 (LANEMAC, vqdmlal_lane, v4hi, v2si) },\n+  { VAR6 (LANEMAC, vmls_lane, v4hi, v2si, v2sf, v8hi, v4si, v4sf) },\n+  { VAR2 (LANEMAC, vmlsl_lane, v4hi, v2si) },\n+  { VAR2 (LANEMAC, vqdmlsl_lane, v4hi, v2si) },\n+  { VAR6 (SCALARMUL, vmul_n, v4hi, v2si, v2sf, v8hi, v4si, v4sf) },\n+  { VAR6 (SCALARMAC, vmla_n, v4hi, v2si, v2sf, v8hi, v4si, v4sf) },\n+  { VAR2 (SCALARMAC, vmlal_n, v4hi, v2si) },\n+  { VAR2 (SCALARMAC, vqdmlal_n, v4hi, v2si) },\n+  { VAR6 (SCALARMAC, vmls_n, v4hi, v2si, v2sf, v8hi, v4si, v4sf) },\n+  { VAR2 (SCALARMAC, vmlsl_n, v4hi, v2si) },\n+  { VAR2 (SCALARMAC, vqdmlsl_n, v4hi, v2si) },\n+  { VAR10 (BINOP, vext,\n+\t   v8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf, v2di) },\n+  { VAR8 (UNOP, vrev64, v8qi, v4hi, v2si, v2sf, v16qi, v8hi, v4si, v4sf) },\n+  { VAR4 (UNOP, vrev32, v8qi, v4hi, v16qi, v8hi) },\n+  { VAR2 (UNOP, vrev16, v8qi, v16qi) },\n+  { VAR4 (CONVERT, vcvt, v2si, v2sf, v4si, v4sf) },\n+  { VAR4 (FIXCONV, vcvt_n, v2si, v2sf, v4si, v4sf) },\n+  { VAR10 (SELECT, vbsl,\n+\t   v8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf, v2di) },\n+  { VAR1 (VTBL, vtbl1, v8qi) },\n+  { VAR1 (VTBL, vtbl2, v8qi) },\n+  { VAR1 (VTBL, vtbl3, v8qi) },\n+  { VAR1 (VTBL, vtbl4, v8qi) },\n+  { VAR1 (VTBX, vtbx1, v8qi) },\n+  { VAR1 (VTBX, vtbx2, v8qi) },\n+  { VAR1 (VTBX, vtbx3, v8qi) },\n+  { VAR1 (VTBX, vtbx4, v8qi) },\n+  { VAR8 (RESULTPAIR, vtrn, v8qi, v4hi, v2si, v2sf, v16qi, v8hi, v4si, v4sf) },\n+  { VAR8 (RESULTPAIR, vzip, v8qi, v4hi, v2si, v2sf, v16qi, v8hi, v4si, v4sf) },\n+  { VAR8 (RESULTPAIR, vuzp, v8qi, v4hi, v2si, v2sf, v16qi, v8hi, v4si, v4sf) },\n+  { VAR5 (REINTERP, vreinterpretv8qi, v8qi, v4hi, v2si, v2sf, di) },\n+  { VAR5 (REINTERP, vreinterpretv4hi, v8qi, v4hi, v2si, v2sf, di) },\n+  { VAR5 (REINTERP, vreinterpretv2si, v8qi, v4hi, v2si, v2sf, di) },\n+  { VAR5 (REINTERP, vreinterpretv2sf, v8qi, v4hi, v2si, v2sf, di) },\n+  { VAR5 (REINTERP, vreinterpretdi, v8qi, v4hi, v2si, v2sf, di) },\n+  { VAR5 (REINTERP, vreinterpretv16qi, v16qi, v8hi, v4si, v4sf, v2di) },\n+  { VAR5 (REINTERP, vreinterpretv8hi, v16qi, v8hi, v4si, v4sf, v2di) },\n+  { VAR5 (REINTERP, vreinterpretv4si, v16qi, v8hi, v4si, v4sf, v2di) },\n+  { VAR5 (REINTERP, vreinterpretv4sf, v16qi, v8hi, v4si, v4sf, v2di) },\n+  { VAR5 (REINTERP, vreinterpretv2di, v16qi, v8hi, v4si, v4sf, v2di) },\n+  { VAR10 (LOAD1, vld1,\n+           v8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf, v2di) },\n+  { VAR10 (LOAD1LANE, vld1_lane,\n+\t   v8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf, v2di) },\n+  { VAR10 (LOAD1, vld1_dup,\n+\t   v8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf, v2di) },\n+  { VAR10 (STORE1, vst1,\n+\t   v8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf, v2di) },\n+  { VAR10 (STORE1LANE, vst1_lane,\n+\t   v8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf, v2di) },\n+  { VAR9 (LOADSTRUCT,\n+\t  vld2, v8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf) },\n+  { VAR7 (LOADSTRUCTLANE, vld2_lane,\n+\t  v8qi, v4hi, v2si, v2sf, v8hi, v4si, v4sf) },\n+  { VAR5 (LOADSTRUCT, vld2_dup, v8qi, v4hi, v2si, v2sf, di) },\n+  { VAR9 (STORESTRUCT, vst2,\n+\t  v8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf) },\n+  { VAR7 (STORESTRUCTLANE, vst2_lane,\n+\t  v8qi, v4hi, v2si, v2sf, v8hi, v4si, v4sf) },\n+  { VAR9 (LOADSTRUCT,\n+\t  vld3, v8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf) },\n+  { VAR7 (LOADSTRUCTLANE, vld3_lane,\n+\t  v8qi, v4hi, v2si, v2sf, v8hi, v4si, v4sf) },\n+  { VAR5 (LOADSTRUCT, vld3_dup, v8qi, v4hi, v2si, v2sf, di) },\n+  { VAR9 (STORESTRUCT, vst3,\n+\t  v8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf) },\n+  { VAR7 (STORESTRUCTLANE, vst3_lane,\n+\t  v8qi, v4hi, v2si, v2sf, v8hi, v4si, v4sf) },\n+  { VAR9 (LOADSTRUCT, vld4,\n+\t  v8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf) },\n+  { VAR7 (LOADSTRUCTLANE, vld4_lane,\n+\t  v8qi, v4hi, v2si, v2sf, v8hi, v4si, v4sf) },\n+  { VAR5 (LOADSTRUCT, vld4_dup, v8qi, v4hi, v2si, v2sf, di) },\n+  { VAR9 (STORESTRUCT, vst4,\n+\t  v8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf) },\n+  { VAR7 (STORESTRUCTLANE, vst4_lane,\n+\t  v8qi, v4hi, v2si, v2sf, v8hi, v4si, v4sf) },\n+  { VAR10 (LOGICBINOP, vand,\n+\t   v8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf, v2di) },\n+  { VAR10 (LOGICBINOP, vorr,\n+\t   v8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf, v2di) },\n+  { VAR10 (BINOP, veor,\n+\t   v8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf, v2di) },\n+  { VAR10 (LOGICBINOP, vbic,\n+\t   v8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf, v2di) },\n+  { VAR10 (LOGICBINOP, vorn,\n+\t   v8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf, v2di) }\n+};\n+\n+#undef CF\n+#undef VAR1\n+#undef VAR2\n+#undef VAR3\n+#undef VAR4\n+#undef VAR5\n+#undef VAR6\n+#undef VAR7\n+#undef VAR8\n+#undef VAR9\n+#undef VAR10\n+\n+static void\n+arm_init_neon_builtins (void)\n+{\n+  unsigned int i, fcode = ARM_BUILTIN_NEON_BASE;\n+\n+  /* Create distinguished type nodes for NEON vector element types,\n+     and pointers to values of such types, so we can detect them later.  */\n+  tree neon_intQI_type_node = make_signed_type (GET_MODE_PRECISION (QImode));\n+  tree neon_intHI_type_node = make_signed_type (GET_MODE_PRECISION (HImode));\n+  tree neon_polyQI_type_node = make_signed_type (GET_MODE_PRECISION (QImode));\n+  tree neon_polyHI_type_node = make_signed_type (GET_MODE_PRECISION (HImode));\n+  tree neon_intSI_type_node = make_signed_type (GET_MODE_PRECISION (SImode));\n+  tree neon_intDI_type_node = make_signed_type (GET_MODE_PRECISION (DImode));\n+  tree neon_float_type_node = make_node (REAL_TYPE);\n+  TYPE_PRECISION (neon_float_type_node) = FLOAT_TYPE_SIZE;\n+  layout_type (neon_float_type_node);\n+\n+  /* Define typedefs which exactly correspond to the modes we are basing vector\n+     types on.  If you change these names you'll need to change\n+     the table used by arm_mangle_vector_type too.  */\n+  (*lang_hooks.types.register_builtin_type) (neon_intQI_type_node,\n+\t\t\t\t\t     \"__builtin_neon_qi\");\n+  (*lang_hooks.types.register_builtin_type) (neon_intHI_type_node,\n+\t\t\t\t\t     \"__builtin_neon_hi\");\n+  (*lang_hooks.types.register_builtin_type) (neon_intSI_type_node,\n+\t\t\t\t\t     \"__builtin_neon_si\");\n+  (*lang_hooks.types.register_builtin_type) (neon_float_type_node,\n+\t\t\t\t\t     \"__builtin_neon_sf\");\n+  (*lang_hooks.types.register_builtin_type) (neon_intDI_type_node,\n+\t\t\t\t\t     \"__builtin_neon_di\");\n+\n+  (*lang_hooks.types.register_builtin_type) (neon_polyQI_type_node,\n+\t\t\t\t\t     \"__builtin_neon_poly8\");\n+  (*lang_hooks.types.register_builtin_type) (neon_polyHI_type_node,\n+\t\t\t\t\t     \"__builtin_neon_poly16\");\n+\n+  tree intQI_pointer_node = build_pointer_type (neon_intQI_type_node);\n+  tree intHI_pointer_node = build_pointer_type (neon_intHI_type_node);\n+  tree intSI_pointer_node = build_pointer_type (neon_intSI_type_node);\n+  tree intDI_pointer_node = build_pointer_type (neon_intDI_type_node);\n+  tree float_pointer_node = build_pointer_type (neon_float_type_node);\n+\n+  /* Next create constant-qualified versions of the above types.  */\n+  tree const_intQI_node = build_qualified_type (neon_intQI_type_node,\n+\t\t\t\t\t\tTYPE_QUAL_CONST);\n+  tree const_intHI_node = build_qualified_type (neon_intHI_type_node,\n+\t\t\t\t\t\tTYPE_QUAL_CONST);\n+  tree const_intSI_node = build_qualified_type (neon_intSI_type_node,\n+\t\t\t\t\t\tTYPE_QUAL_CONST);\n+  tree const_intDI_node = build_qualified_type (neon_intDI_type_node,\n+\t\t\t\t\t\tTYPE_QUAL_CONST);\n+  tree const_float_node = build_qualified_type (neon_float_type_node,\n+\t\t\t\t\t\tTYPE_QUAL_CONST);\n+\n+  tree const_intQI_pointer_node = build_pointer_type (const_intQI_node);\n+  tree const_intHI_pointer_node = build_pointer_type (const_intHI_node);\n+  tree const_intSI_pointer_node = build_pointer_type (const_intSI_node);\n+  tree const_intDI_pointer_node = build_pointer_type (const_intDI_node);\n+  tree const_float_pointer_node = build_pointer_type (const_float_node);\n+\n+  /* Now create vector types based on our NEON element types.  */\n+  /* 64-bit vectors.  */\n+  tree V8QI_type_node =\n+    build_vector_type_for_mode (neon_intQI_type_node, V8QImode);\n+  tree V4HI_type_node =\n+    build_vector_type_for_mode (neon_intHI_type_node, V4HImode);\n+  tree V2SI_type_node =\n+    build_vector_type_for_mode (neon_intSI_type_node, V2SImode);\n+  tree V2SF_type_node =\n+    build_vector_type_for_mode (neon_float_type_node, V2SFmode);\n+  /* 128-bit vectors.  */\n+  tree V16QI_type_node =\n+    build_vector_type_for_mode (neon_intQI_type_node, V16QImode);\n+  tree V8HI_type_node =\n+    build_vector_type_for_mode (neon_intHI_type_node, V8HImode);\n+  tree V4SI_type_node =\n+    build_vector_type_for_mode (neon_intSI_type_node, V4SImode);\n+  tree V4SF_type_node =\n+    build_vector_type_for_mode (neon_float_type_node, V4SFmode);\n+  tree V2DI_type_node =\n+    build_vector_type_for_mode (neon_intDI_type_node, V2DImode);\n+\n+  /* Unsigned integer types for various mode sizes.  */\n+  tree intUQI_type_node = make_unsigned_type (GET_MODE_PRECISION (QImode));\n+  tree intUHI_type_node = make_unsigned_type (GET_MODE_PRECISION (HImode));\n+  tree intUSI_type_node = make_unsigned_type (GET_MODE_PRECISION (SImode));\n+  tree intUDI_type_node = make_unsigned_type (GET_MODE_PRECISION (DImode));\n+\n+  (*lang_hooks.types.register_builtin_type) (intUQI_type_node,\n+\t\t\t\t\t     \"__builtin_neon_uqi\");\n+  (*lang_hooks.types.register_builtin_type) (intUHI_type_node,\n+\t\t\t\t\t     \"__builtin_neon_uhi\");\n+  (*lang_hooks.types.register_builtin_type) (intUSI_type_node,\n+\t\t\t\t\t     \"__builtin_neon_usi\");\n+  (*lang_hooks.types.register_builtin_type) (intUDI_type_node,\n+\t\t\t\t\t     \"__builtin_neon_udi\");\n+\n+  /* Opaque integer types for structures of vectors.  */\n+  tree intEI_type_node = make_signed_type (GET_MODE_PRECISION (EImode));\n+  tree intOI_type_node = make_signed_type (GET_MODE_PRECISION (OImode));\n+  tree intCI_type_node = make_signed_type (GET_MODE_PRECISION (CImode));\n+  tree intXI_type_node = make_signed_type (GET_MODE_PRECISION (XImode));\n+\n+  (*lang_hooks.types.register_builtin_type) (intTI_type_node,\n+\t\t\t\t\t     \"__builtin_neon_ti\");\n+  (*lang_hooks.types.register_builtin_type) (intEI_type_node,\n+\t\t\t\t\t     \"__builtin_neon_ei\");\n+  (*lang_hooks.types.register_builtin_type) (intOI_type_node,\n+\t\t\t\t\t     \"__builtin_neon_oi\");\n+  (*lang_hooks.types.register_builtin_type) (intCI_type_node,\n+\t\t\t\t\t     \"__builtin_neon_ci\");\n+  (*lang_hooks.types.register_builtin_type) (intXI_type_node,\n+\t\t\t\t\t     \"__builtin_neon_xi\");\n+\n+  /* Pointers to vector types.  */\n+  tree V8QI_pointer_node = build_pointer_type (V8QI_type_node);\n+  tree V4HI_pointer_node = build_pointer_type (V4HI_type_node);\n+  tree V2SI_pointer_node = build_pointer_type (V2SI_type_node);\n+  tree V2SF_pointer_node = build_pointer_type (V2SF_type_node);\n+  tree V16QI_pointer_node = build_pointer_type (V16QI_type_node);\n+  tree V8HI_pointer_node = build_pointer_type (V8HI_type_node);\n+  tree V4SI_pointer_node = build_pointer_type (V4SI_type_node);\n+  tree V4SF_pointer_node = build_pointer_type (V4SF_type_node);\n+  tree V2DI_pointer_node = build_pointer_type (V2DI_type_node);\n+\n+  /* Operations which return results as pairs.  */\n+  tree void_ftype_pv8qi_v8qi_v8qi =\n+    build_function_type_list (void_type_node, V8QI_pointer_node, V8QI_type_node,\n+  \t\t\t      V8QI_type_node, NULL);\n+  tree void_ftype_pv4hi_v4hi_v4hi =\n+    build_function_type_list (void_type_node, V4HI_pointer_node, V4HI_type_node,\n+  \t\t\t      V4HI_type_node, NULL);\n+  tree void_ftype_pv2si_v2si_v2si =\n+    build_function_type_list (void_type_node, V2SI_pointer_node, V2SI_type_node,\n+  \t\t\t      V2SI_type_node, NULL);\n+  tree void_ftype_pv2sf_v2sf_v2sf =\n+    build_function_type_list (void_type_node, V2SF_pointer_node, V2SF_type_node,\n+  \t\t\t      V2SF_type_node, NULL);\n+  tree void_ftype_pdi_di_di =\n+    build_function_type_list (void_type_node, intDI_pointer_node,\n+\t\t\t      neon_intDI_type_node, neon_intDI_type_node, NULL);\n+  tree void_ftype_pv16qi_v16qi_v16qi =\n+    build_function_type_list (void_type_node, V16QI_pointer_node,\n+\t\t\t      V16QI_type_node, V16QI_type_node, NULL);\n+  tree void_ftype_pv8hi_v8hi_v8hi =\n+    build_function_type_list (void_type_node, V8HI_pointer_node, V8HI_type_node,\n+  \t\t\t      V8HI_type_node, NULL);\n+  tree void_ftype_pv4si_v4si_v4si =\n+    build_function_type_list (void_type_node, V4SI_pointer_node, V4SI_type_node,\n+  \t\t\t      V4SI_type_node, NULL);\n+  tree void_ftype_pv4sf_v4sf_v4sf =\n+    build_function_type_list (void_type_node, V4SF_pointer_node, V4SF_type_node,\n+  \t\t\t      V4SF_type_node, NULL);\n+  tree void_ftype_pv2di_v2di_v2di =\n+    build_function_type_list (void_type_node, V2DI_pointer_node, V2DI_type_node,\n+\t\t\t      V2DI_type_node, NULL);\n+\n+  tree reinterp_ftype_dreg[5][5];\n+  tree reinterp_ftype_qreg[5][5];\n+  tree dreg_types[5], qreg_types[5];\n+\n+  dreg_types[0] = V8QI_type_node;\n+  dreg_types[1] = V4HI_type_node;\n+  dreg_types[2] = V2SI_type_node;\n+  dreg_types[3] = V2SF_type_node;\n+  dreg_types[4] = neon_intDI_type_node;\n+\n+  qreg_types[0] = V16QI_type_node;\n+  qreg_types[1] = V8HI_type_node;\n+  qreg_types[2] = V4SI_type_node;\n+  qreg_types[3] = V4SF_type_node;\n+  qreg_types[4] = V2DI_type_node;\n+\n+  for (i = 0; i < 5; i++)\n+    {\n+      int j;\n+      for (j = 0; j < 5; j++)\n+        {\n+          reinterp_ftype_dreg[i][j]\n+            = build_function_type_list (dreg_types[i], dreg_types[j], NULL);\n+          reinterp_ftype_qreg[i][j]\n+            = build_function_type_list (qreg_types[i], qreg_types[j], NULL);\n+        }\n+    }\n+\n+  for (i = 0; i < ARRAY_SIZE (neon_builtin_data); i++)\n+    {\n+      neon_builtin_datum *d = &neon_builtin_data[i];\n+      unsigned int j, codeidx = 0;\n+\n+      d->base_fcode = fcode;\n+\n+      for (j = 0; j < T_MAX; j++)\n+\t{\n+\t  const char* const modenames[] = {\n+\t    \"v8qi\", \"v4hi\", \"v2si\", \"v2sf\", \"di\",\n+\t    \"v16qi\", \"v8hi\", \"v4si\", \"v4sf\", \"v2di\"\n+\t  };\n+\t  char namebuf[60];\n+\t  tree ftype = NULL;\n+\t  enum insn_code icode;\n+\t  int is_load = 0, is_store = 0;\n+\n+          if ((d->bits & (1 << j)) == 0)\n+            continue;\n+\n+          icode = d->codes[codeidx++];\n+\n+          switch (d->itype)\n+            {\n+\t    case NEON_LOAD1:\n+\t    case NEON_LOAD1LANE:\n+\t    case NEON_LOADSTRUCT:\n+\t    case NEON_LOADSTRUCTLANE:\n+\t      is_load = 1;\n+\t      /* Fall through.  */\n+\t    case NEON_STORE1:\n+\t    case NEON_STORE1LANE:\n+\t    case NEON_STORESTRUCT:\n+\t    case NEON_STORESTRUCTLANE:\n+\t      if (!is_load)\n+\t        is_store = 1;\n+\t      /* Fall through.  */\n+            case NEON_UNOP:\n+\t    case NEON_BINOP:\n+\t    case NEON_LOGICBINOP:\n+\t    case NEON_SHIFTINSERT:\n+\t    case NEON_TERNOP:\n+\t    case NEON_GETLANE:\n+\t    case NEON_SETLANE:\n+\t    case NEON_CREATE:\n+\t    case NEON_DUP:\n+\t    case NEON_DUPLANE:\n+\t    case NEON_SHIFTIMM:\n+\t    case NEON_SHIFTACC:\n+\t    case NEON_COMBINE:\n+\t    case NEON_SPLIT:\n+\t    case NEON_CONVERT:\n+\t    case NEON_FIXCONV:\n+\t    case NEON_LANEMUL:\n+\t    case NEON_LANEMULL:\n+\t    case NEON_LANEMULH:\n+\t    case NEON_LANEMAC:\n+\t    case NEON_SCALARMUL:\n+\t    case NEON_SCALARMULL:\n+\t    case NEON_SCALARMULH:\n+\t    case NEON_SCALARMAC:\n+\t    case NEON_SELECT:\n+\t    case NEON_VTBL:\n+\t    case NEON_VTBX:\n+\t      {\n+\t\tint k;\n+\t\ttree return_type = void_type_node, args = void_list_node;\n+\n+\t\t/* Build a function type directly from the insn_data for this\n+\t\t   builtin.  The build_function_type() function takes care of\n+\t\t   removing duplicates for us.  */\n+\t\tfor (k = insn_data[icode].n_operands - 1; k >= 0; k--)\n+\t\t  {\n+\t\t    tree eltype;\n+\n+\t\t    if (is_load && k == 1)\n+\t\t      {\n+\t\t        /* Neon load patterns always have the memory operand\n+\t\t\t   (a SImode pointer) in the operand 1 position.  We\n+\t\t\t   want a const pointer to the element type in that\n+\t\t\t   position.  */\n+\t\t        gcc_assert (insn_data[icode].operand[k].mode == SImode);\n+\n+\t\t\tswitch (1 << j)\n+\t\t\t  {\n+\t\t\t  case T_V8QI:\n+\t\t\t  case T_V16QI:\n+\t\t\t    eltype = const_intQI_pointer_node;\n+\t\t\t    break;\n+\n+\t\t\t  case T_V4HI:\n+\t\t\t  case T_V8HI:\n+\t\t\t    eltype = const_intHI_pointer_node;\n+\t\t\t    break;\n+\n+\t\t\t  case T_V2SI:\n+\t\t\t  case T_V4SI:\n+\t\t\t    eltype = const_intSI_pointer_node;\n+\t\t\t    break;\n+\n+\t\t\t  case T_V2SF:\n+\t\t\t  case T_V4SF:\n+\t\t\t    eltype = const_float_pointer_node;\n+\t\t\t    break;\n+\n+\t\t\t  case T_DI:\n+\t\t\t  case T_V2DI:\n+\t\t\t    eltype = const_intDI_pointer_node;\n+\t\t\t    break;\n+\n+\t\t\t  default: gcc_unreachable ();\n+\t\t\t  }\n+  \t\t      }\n+\t\t    else if (is_store && k == 0)\n+\t\t      {\n+\t\t        /* Similarly, Neon store patterns use operand 0 as\n+\t\t\t   the memory location to store to (a SImode pointer).\n+\t\t\t   Use a pointer to the element type of the store in\n+\t\t\t   that position.  */\n+\t\t\tgcc_assert (insn_data[icode].operand[k].mode == SImode);\n+\n+\t\t\tswitch (1 << j)\n+\t\t\t  {\n+\t\t\t  case T_V8QI:\n+\t\t\t  case T_V16QI:\n+\t\t\t    eltype = intQI_pointer_node;\n+\t\t\t    break;\n+\n+\t\t\t  case T_V4HI:\n+\t\t\t  case T_V8HI:\n+\t\t\t    eltype = intHI_pointer_node;\n+\t\t\t    break;\n+\n+\t\t\t  case T_V2SI:\n+\t\t\t  case T_V4SI:\n+\t\t\t    eltype = intSI_pointer_node;\n+\t\t\t    break;\n+\n+\t\t\t  case T_V2SF:\n+\t\t\t  case T_V4SF:\n+\t\t\t    eltype = float_pointer_node;\n+\t\t\t    break;\n+\n+\t\t\t  case T_DI:\n+\t\t\t  case T_V2DI:\n+\t\t\t    eltype = intDI_pointer_node;\n+\t\t\t    break;\n+\n+\t\t\t  default: gcc_unreachable ();\n+\t\t\t  }\n+\t\t      }\n+\t\t    else\n+\t\t      {\n+\t\t\tswitch (insn_data[icode].operand[k].mode)\n+\t        \t  {\n+\t\t\t  case VOIDmode: eltype = void_type_node; break;\n+\t\t\t  /* Scalars.  */\n+\t\t\t  case QImode: eltype = neon_intQI_type_node; break;\n+\t\t\t  case HImode: eltype = neon_intHI_type_node; break;\n+\t\t\t  case SImode: eltype = neon_intSI_type_node; break;\n+\t\t\t  case SFmode: eltype = neon_float_type_node; break;\n+\t\t\t  case DImode: eltype = neon_intDI_type_node; break;\n+\t\t\t  case TImode: eltype = intTI_type_node; break;\n+\t\t\t  case EImode: eltype = intEI_type_node; break;\n+\t\t\t  case OImode: eltype = intOI_type_node; break;\n+\t\t\t  case CImode: eltype = intCI_type_node; break;\n+\t\t\t  case XImode: eltype = intXI_type_node; break;\n+\t\t\t  /* 64-bit vectors.  */\n+\t\t\t  case V8QImode: eltype = V8QI_type_node; break;\n+\t\t\t  case V4HImode: eltype = V4HI_type_node; break;\n+\t\t\t  case V2SImode: eltype = V2SI_type_node; break;\n+\t\t\t  case V2SFmode: eltype = V2SF_type_node; break;\n+\t\t\t  /* 128-bit vectors.  */\n+\t\t\t  case V16QImode: eltype = V16QI_type_node; break;\n+\t\t\t  case V8HImode: eltype = V8HI_type_node; break;\n+\t\t\t  case V4SImode: eltype = V4SI_type_node; break;\n+\t\t\t  case V4SFmode: eltype = V4SF_type_node; break;\n+\t\t\t  case V2DImode: eltype = V2DI_type_node; break;\n+\t\t\t  default: gcc_unreachable ();\n+\t\t\t  }\n+\t\t      }\n+\n+\t\t    if (k == 0 && !is_store)\n+\t              return_type = eltype;\n+\t\t    else\n+\t\t      args = tree_cons (NULL_TREE, eltype, args);\n+\t\t  }\n+\n+\t\tftype = build_function_type (return_type, args);\n+\t      }\n+\t      break;\n+\n+\t    case NEON_RESULTPAIR:\n+              {\n+                switch (insn_data[icode].operand[1].mode)\n+                  {\n+\t\t  case V8QImode: ftype = void_ftype_pv8qi_v8qi_v8qi; break;\n+                  case V4HImode: ftype = void_ftype_pv4hi_v4hi_v4hi; break;\n+                  case V2SImode: ftype = void_ftype_pv2si_v2si_v2si; break;\n+                  case V2SFmode: ftype = void_ftype_pv2sf_v2sf_v2sf; break;\n+                  case DImode: ftype = void_ftype_pdi_di_di; break;\n+                  case V16QImode: ftype = void_ftype_pv16qi_v16qi_v16qi; break;\n+                  case V8HImode: ftype = void_ftype_pv8hi_v8hi_v8hi; break;\n+                  case V4SImode: ftype = void_ftype_pv4si_v4si_v4si; break;\n+                  case V4SFmode: ftype = void_ftype_pv4sf_v4sf_v4sf; break;\n+                  case V2DImode: ftype = void_ftype_pv2di_v2di_v2di; break;\n+                  default: gcc_unreachable ();\n+                  }\n+              }\n+              break;\n+\n+\t    case NEON_REINTERP:\n+              {\n+                /* We iterate over 5 doubleword types, then 5 quadword\n+                   types.  */\n+                int rhs = j % 5;\n+                switch (insn_data[icode].operand[0].mode)\n+                  {\n+                  case V8QImode: ftype = reinterp_ftype_dreg[0][rhs]; break;\n+                  case V4HImode: ftype = reinterp_ftype_dreg[1][rhs]; break;\n+                  case V2SImode: ftype = reinterp_ftype_dreg[2][rhs]; break;\n+                  case V2SFmode: ftype = reinterp_ftype_dreg[3][rhs]; break;\n+                  case DImode: ftype = reinterp_ftype_dreg[4][rhs]; break;\n+                  case V16QImode: ftype = reinterp_ftype_qreg[0][rhs]; break;\n+                  case V8HImode: ftype = reinterp_ftype_qreg[1][rhs]; break;\n+                  case V4SImode: ftype = reinterp_ftype_qreg[2][rhs]; break;\n+\t\t  case V4SFmode: ftype = reinterp_ftype_qreg[3][rhs]; break;\n+                  case V2DImode: ftype = reinterp_ftype_qreg[4][rhs]; break;\n+                  default: gcc_unreachable ();\n+                  }\n+              }\n+              break;\n+\n+            default:\n+              gcc_unreachable ();\n+            }\n+\n+          gcc_assert (ftype != NULL);\n+\n+          sprintf (namebuf, \"__builtin_neon_%s%s\", d->name, modenames[j]);\n+\n+          add_builtin_function (namebuf, ftype, fcode++, BUILT_IN_MD, NULL,\n+\t\t\t\tNULL_TREE);\n+        }\n+    }\n+}\n+\n static void\n arm_init_builtins (void)\n {\n   arm_init_tls_builtins ();\n \n   if (TARGET_REALLY_IWMMXT)\n     arm_init_iwmmxt_builtins ();\n+\n+  if (TARGET_NEON)\n+    arm_init_neon_builtins ();\n }\n \n /* Errors in the source file can cause expand_expr to return const0_rtx\n@@ -13759,6 +15361,343 @@ arm_expand_unop_builtin (enum insn_code icode,\n   return target;\n }\n \n+static int\n+neon_builtin_compare (const void *a, const void *b)\n+{\n+  const neon_builtin_datum *key = a;\n+  const neon_builtin_datum *memb = b;\n+  unsigned int soughtcode = key->base_fcode;\n+\n+  if (soughtcode >= memb->base_fcode\n+      && soughtcode < memb->base_fcode + memb->num_vars)\n+    return 0;\n+  else if (soughtcode < memb->base_fcode)\n+    return -1;\n+  else\n+    return 1;\n+}\n+\n+static enum insn_code\n+locate_neon_builtin_icode (int fcode, neon_itype *itype)\n+{\n+  neon_builtin_datum key, *found;\n+  int idx;\n+\n+  key.base_fcode = fcode;\n+  found = bsearch (&key, &neon_builtin_data[0], ARRAY_SIZE (neon_builtin_data),\n+\t\t   sizeof (neon_builtin_data[0]), neon_builtin_compare);\n+  gcc_assert (found);\n+  idx = fcode - (int) found->base_fcode;\n+  gcc_assert (idx >= 0 && idx < T_MAX && idx < (int)found->num_vars);\n+\n+  if (itype)\n+    *itype = found->itype;\n+\n+  return found->codes[idx];\n+}\n+\n+typedef enum {\n+  NEON_ARG_COPY_TO_REG,\n+  NEON_ARG_CONSTANT,\n+  NEON_ARG_STOP\n+} builtin_arg;\n+\n+#define NEON_MAX_BUILTIN_ARGS 5\n+\n+/* Expand a Neon builtin.  */\n+static rtx\n+arm_expand_neon_args (rtx target, int icode, int have_retval,\n+\t\t      tree exp, ...)\n+{\n+  va_list ap;\n+  rtx pat;\n+  tree arg[NEON_MAX_BUILTIN_ARGS];\n+  rtx op[NEON_MAX_BUILTIN_ARGS];\n+  enum machine_mode tmode = insn_data[icode].operand[0].mode;\n+  enum machine_mode mode[NEON_MAX_BUILTIN_ARGS];\n+  int argc = 0;\n+\n+  if (have_retval\n+      && (!target\n+\t  || GET_MODE (target) != tmode\n+\t  || !(*insn_data[icode].operand[0].predicate) (target, tmode)))\n+    target = gen_reg_rtx (tmode);\n+\n+  va_start (ap, exp);\n+\n+  for (;;)\n+    {\n+      builtin_arg thisarg = va_arg (ap, int);\n+\n+      if (thisarg == NEON_ARG_STOP)\n+        break;\n+      else\n+        {\n+          arg[argc] = CALL_EXPR_ARG (exp, argc);\n+          op[argc] = expand_normal (arg[argc]);\n+          mode[argc] = insn_data[icode].operand[argc + have_retval].mode;\n+\n+          switch (thisarg)\n+            {\n+            case NEON_ARG_COPY_TO_REG:\n+              /*gcc_assert (GET_MODE (op[argc]) == mode[argc]);*/\n+              if (!(*insn_data[icode].operand[argc + have_retval].predicate)\n+                     (op[argc], mode[argc]))\n+                op[argc] = copy_to_mode_reg (mode[argc], op[argc]);\n+              break;\n+\n+            case NEON_ARG_CONSTANT:\n+              /* FIXME: This error message is somewhat unhelpful.  */\n+              if (!(*insn_data[icode].operand[argc + have_retval].predicate)\n+                    (op[argc], mode[argc]))\n+\t\terror (\"argument must be a constant\");\n+              break;\n+\n+            case NEON_ARG_STOP:\n+              gcc_unreachable ();\n+            }\n+\n+          argc++;\n+        }\n+    }\n+\n+  va_end (ap);\n+\n+  if (have_retval)\n+    switch (argc)\n+      {\n+      case 1:\n+\tpat = GEN_FCN (icode) (target, op[0]);\n+\tbreak;\n+\n+      case 2:\n+\tpat = GEN_FCN (icode) (target, op[0], op[1]);\n+\tbreak;\n+\n+      case 3:\n+\tpat = GEN_FCN (icode) (target, op[0], op[1], op[2]);\n+\tbreak;\n+\n+      case 4:\n+\tpat = GEN_FCN (icode) (target, op[0], op[1], op[2], op[3]);\n+\tbreak;\n+\n+      case 5:\n+\tpat = GEN_FCN (icode) (target, op[0], op[1], op[2], op[3], op[4]);\n+\tbreak;\n+\n+      default:\n+\tgcc_unreachable ();\n+      }\n+  else\n+    switch (argc)\n+      {\n+      case 1:\n+\tpat = GEN_FCN (icode) (op[0]);\n+\tbreak;\n+\n+      case 2:\n+\tpat = GEN_FCN (icode) (op[0], op[1]);\n+\tbreak;\n+\n+      case 3:\n+\tpat = GEN_FCN (icode) (op[0], op[1], op[2]);\n+\tbreak;\n+\n+      case 4:\n+\tpat = GEN_FCN (icode) (op[0], op[1], op[2], op[3]);\n+\tbreak;\n+\n+      case 5:\n+\tpat = GEN_FCN (icode) (op[0], op[1], op[2], op[3], op[4]);\n+        break;\n+\n+      default:\n+\tgcc_unreachable ();\n+      }\n+\n+  if (!pat)\n+    return 0;\n+\n+  emit_insn (pat);\n+\n+  return target;\n+}\n+\n+/* Expand a Neon builtin. These are \"special\" because they don't have symbolic\n+   constants defined per-instruction or per instruction-variant. Instead, the\n+   required info is looked up in the table neon_builtin_data.  */\n+static rtx\n+arm_expand_neon_builtin (int fcode, tree exp, rtx target)\n+{\n+  neon_itype itype;\n+  enum insn_code icode = locate_neon_builtin_icode (fcode, &itype);\n+\n+  switch (itype)\n+    {\n+    case NEON_UNOP:\n+    case NEON_CONVERT:\n+    case NEON_DUPLANE:\n+      return arm_expand_neon_args (target, icode, 1, exp,\n+        NEON_ARG_COPY_TO_REG, NEON_ARG_CONSTANT, NEON_ARG_STOP);\n+\n+    case NEON_BINOP:\n+    case NEON_SETLANE:\n+    case NEON_SCALARMUL:\n+    case NEON_SCALARMULL:\n+    case NEON_SCALARMULH:\n+    case NEON_SHIFTINSERT:\n+    case NEON_LOGICBINOP:\n+      return arm_expand_neon_args (target, icode, 1, exp,\n+        NEON_ARG_COPY_TO_REG, NEON_ARG_COPY_TO_REG, NEON_ARG_CONSTANT,\n+        NEON_ARG_STOP);\n+\n+    case NEON_TERNOP:\n+      return arm_expand_neon_args (target, icode, 1, exp,\n+        NEON_ARG_COPY_TO_REG, NEON_ARG_COPY_TO_REG, NEON_ARG_COPY_TO_REG,\n+        NEON_ARG_CONSTANT, NEON_ARG_STOP);\n+\n+    case NEON_GETLANE:\n+    case NEON_FIXCONV:\n+    case NEON_SHIFTIMM:\n+      return arm_expand_neon_args (target, icode, 1, exp,\n+        NEON_ARG_COPY_TO_REG, NEON_ARG_CONSTANT, NEON_ARG_CONSTANT,\n+        NEON_ARG_STOP);\n+\n+    case NEON_CREATE:\n+      return arm_expand_neon_args (target, icode, 1, exp,\n+        NEON_ARG_COPY_TO_REG, NEON_ARG_STOP);\n+\n+    case NEON_DUP:\n+    case NEON_SPLIT:\n+    case NEON_REINTERP:\n+      return arm_expand_neon_args (target, icode, 1, exp,\n+        NEON_ARG_COPY_TO_REG, NEON_ARG_STOP);\n+\n+    case NEON_COMBINE:\n+    case NEON_VTBL:\n+      return arm_expand_neon_args (target, icode, 1, exp,\n+        NEON_ARG_COPY_TO_REG, NEON_ARG_COPY_TO_REG, NEON_ARG_STOP);\n+\n+    case NEON_RESULTPAIR:\n+      return arm_expand_neon_args (target, icode, 0, exp,\n+        NEON_ARG_COPY_TO_REG, NEON_ARG_COPY_TO_REG, NEON_ARG_COPY_TO_REG,\n+        NEON_ARG_STOP);\n+\n+    case NEON_LANEMUL:\n+    case NEON_LANEMULL:\n+    case NEON_LANEMULH:\n+      return arm_expand_neon_args (target, icode, 1, exp,\n+        NEON_ARG_COPY_TO_REG, NEON_ARG_COPY_TO_REG, NEON_ARG_CONSTANT,\n+        NEON_ARG_CONSTANT, NEON_ARG_STOP);\n+\n+    case NEON_LANEMAC:\n+      return arm_expand_neon_args (target, icode, 1, exp,\n+        NEON_ARG_COPY_TO_REG, NEON_ARG_COPY_TO_REG, NEON_ARG_COPY_TO_REG,\n+        NEON_ARG_CONSTANT, NEON_ARG_CONSTANT, NEON_ARG_STOP);\n+\n+    case NEON_SHIFTACC:\n+      return arm_expand_neon_args (target, icode, 1, exp,\n+        NEON_ARG_COPY_TO_REG, NEON_ARG_COPY_TO_REG, NEON_ARG_CONSTANT,\n+        NEON_ARG_CONSTANT, NEON_ARG_STOP);\n+\n+    case NEON_SCALARMAC:\n+      return arm_expand_neon_args (target, icode, 1, exp,\n+\tNEON_ARG_COPY_TO_REG, NEON_ARG_COPY_TO_REG, NEON_ARG_COPY_TO_REG,\n+        NEON_ARG_CONSTANT, NEON_ARG_STOP);\n+\n+    case NEON_SELECT:\n+    case NEON_VTBX:\n+      return arm_expand_neon_args (target, icode, 1, exp,\n+\tNEON_ARG_COPY_TO_REG, NEON_ARG_COPY_TO_REG, NEON_ARG_COPY_TO_REG,\n+        NEON_ARG_STOP);\n+\n+    case NEON_LOAD1:\n+    case NEON_LOADSTRUCT:\n+      return arm_expand_neon_args (target, icode, 1, exp,\n+\tNEON_ARG_COPY_TO_REG, NEON_ARG_STOP);\n+\n+    case NEON_LOAD1LANE:\n+    case NEON_LOADSTRUCTLANE:\n+      return arm_expand_neon_args (target, icode, 1, exp,\n+\tNEON_ARG_COPY_TO_REG, NEON_ARG_COPY_TO_REG, NEON_ARG_CONSTANT,\n+\tNEON_ARG_STOP);\n+\n+    case NEON_STORE1:\n+    case NEON_STORESTRUCT:\n+      return arm_expand_neon_args (target, icode, 0, exp,\n+\tNEON_ARG_COPY_TO_REG, NEON_ARG_COPY_TO_REG, NEON_ARG_STOP);\n+\n+    case NEON_STORE1LANE:\n+    case NEON_STORESTRUCTLANE:\n+      return arm_expand_neon_args (target, icode, 0, exp,\n+\tNEON_ARG_COPY_TO_REG, NEON_ARG_COPY_TO_REG, NEON_ARG_CONSTANT,\n+\tNEON_ARG_STOP);\n+    }\n+\n+  gcc_unreachable ();\n+}\n+\n+/* Emit code to reinterpret one Neon type as another, without altering bits.  */\n+void\n+neon_reinterpret (rtx dest, rtx src)\n+{\n+  emit_move_insn (dest, gen_lowpart (GET_MODE (dest), src));\n+}\n+\n+/* Emit code to place a Neon pair result in memory locations (with equal\n+   registers).  */\n+void\n+neon_emit_pair_result_insn (enum machine_mode mode,\n+\t\t\t    rtx (*intfn) (rtx, rtx, rtx, rtx), rtx destaddr,\n+                            rtx op1, rtx op2)\n+{\n+  rtx mem = gen_rtx_MEM (mode, destaddr);\n+  rtx tmp1 = gen_reg_rtx (mode);\n+  rtx tmp2 = gen_reg_rtx (mode);\n+\n+  emit_insn (intfn (tmp1, op1, tmp2, op2));\n+\n+  emit_move_insn (mem, tmp1);\n+  mem = adjust_address (mem, mode, GET_MODE_SIZE (mode));\n+  emit_move_insn (mem, tmp2);\n+}\n+\n+/* Set up operands for a register copy from src to dest, taking care not to\n+   clobber registers in the process.\n+   FIXME: This has rather high polynomial complexity (O(n^3)?) but shouldn't\n+   be called with a large N, so that should be OK.  */\n+\n+void\n+neon_disambiguate_copy (rtx *operands, rtx *dest, rtx *src, unsigned int count)\n+{\n+  unsigned int copied = 0, opctr = 0;\n+  unsigned int done = (1 << count) - 1;\n+  unsigned int i, j;\n+\n+  while (copied != done)\n+    {\n+      for (i = 0; i < count; i++)\n+        {\n+          int good = 1;\n+\n+          for (j = 0; good && j < count; j++)\n+            if (i != j && (copied & (1 << j)) == 0\n+                && reg_overlap_mentioned_p (src[j], dest[i]))\n+              good = 0;\n+\n+          if (good)\n+            {\n+              operands[opctr++] = dest[i];\n+              operands[opctr++] = src[i];\n+              copied |= 1 << i;\n+            }\n+        }\n+    }\n+\n+  gcc_assert (opctr == count * 2);\n+}\n+\n /* Expand an expression EXP that calls a built-in function,\n    with result going to TARGET if that's convenient\n    (and in mode MODE if that's convenient).\n@@ -13789,6 +15728,9 @@ arm_expand_builtin (tree exp,\n   enum machine_mode mode1;\n   enum machine_mode mode2;\n \n+  if (fcode >= ARM_BUILTIN_NEON_BASE)\n+    return arm_expand_neon_builtin (fcode, exp, target);\n+\n   switch (fcode)\n     {\n     case ARM_BUILTIN_TEXTRMSB:\n@@ -15549,6 +17491,10 @@ arm_file_start (void)\n \t      fpu_name = \"vfp3\";\n \t      set_float_abi_attributes = 1;\n \t      break;\n+\t    case FPUTYPE_NEON:\n+\t      fpu_name = \"neon\";\n+\t      set_float_abi_attributes = 1;\n+\t      break;\n \t    default:\n \t      abort();\n \t    }\n@@ -16182,7 +18128,6 @@ arm_no_early_mul_dep (rtx producer, rtx consumer)\n \t  && !reg_overlap_mentioned_p (value, XEXP (op, 0)));\n }\n \n-\n /* We can't rely on the caller doing the proper promotion when\n    using APCS or ATPCS.  */\n \n@@ -16404,6 +18349,11 @@ thumb_set_return_address (rtx source, rtx scratch)\n bool\n arm_vector_mode_supported_p (enum machine_mode mode)\n {\n+  /* Neon also supports V2SImode, etc. listed in the clause below.  */\n+  if (TARGET_NEON && (mode == V2SFmode || mode == V4SImode || mode == V8HImode\n+      || mode == V16QImode || mode == V4SFmode || mode == V2DImode))\n+    return true;\n+\n   if ((mode == V2SImode)\n       || (mode == V4HImode)\n       || (mode == V8QImode))"}, {"sha": "6c4d95edaf46b042083eb06dda624733783cf1d1", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 60, "deletions": 4, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -65,6 +65,9 @@ extern char arm_arch_name[];\n \tif (TARGET_VFP)\t\t\t\t\t\\\n \t  builtin_define (\"__VFP_FP__\");\t\t\\\n \t\t\t\t\t\t\t\\\n+\tif (TARGET_NEON)\t\t\t\t\\\n+\t  builtin_define (\"__ARM_NEON__\");\t\t\\\n+\t\t\t\t\t\t\t\\\n \t/* Add a define for interworking.\t\t\\\n \t   Needed when building libgcc.a.  */\t\t\\\n \tif (arm_cpp_interwork)\t\t\t\t\\\n@@ -206,10 +209,23 @@ extern GTY(()) rtx aof_pic_label;\n /* 32-bit Thumb-2 code.  */\n #define TARGET_THUMB2\t\t\t(TARGET_THUMB && arm_arch_thumb2)\n \n+/* The following two macros concern the ability to execute coprocessor\n+   instructions for VFPv3 or NEON.  TARGET_VFP3 is currently only ever\n+   tested when we know we are generating for VFP hardware; we need to\n+   be more careful with TARGET_NEON as noted below.  */\n+\n /* FPU is VFPv3 (with twice the number of D registers).  Setting the FPU to\n    Neon automatically enables VFPv3 too.  */\n #define TARGET_VFP3 (arm_fp_model == ARM_FP_MODEL_VFP \\\n-\t\t     && (arm_fpu_arch == FPUTYPE_VFP3))\n+\t\t     && (arm_fpu_arch == FPUTYPE_VFP3 \\\n+\t\t\t || arm_fpu_arch == FPUTYPE_NEON))\n+/* FPU supports Neon instructions.  The setting of this macro gets\n+   revealed via __ARM_NEON__ so we add extra guards upon TARGET_32BIT\n+   and TARGET_HARD_FLOAT to ensure that NEON instructions are\n+   available.  */\n+#define TARGET_NEON (TARGET_32BIT && TARGET_HARD_FLOAT \\\n+\t\t     && arm_fp_model == ARM_FP_MODEL_VFP \\\n+\t\t     && arm_fpu_arch == FPUTYPE_NEON)\n \n /* \"DSP\" multiply instructions, eg. SMULxy.  */\n #define TARGET_DSP_MULTIPLY \\\n@@ -282,7 +298,9 @@ enum fputype\n   /* VFP.  */\n   FPUTYPE_VFP,\n   /* VFPv3.  */\n-  FPUTYPE_VFP3\n+  FPUTYPE_VFP3,\n+  /* Neon.  */\n+  FPUTYPE_NEON\n };\n \n /* Recast the floating point class to be the floating point attribute.  */\n@@ -483,6 +501,12 @@ extern int arm_arch_hwdiv;\n \n #define UNITS_PER_WORD\t4\n \n+/* Use the option -mvectorize-with-neon-quad to override the use of doubleword\n+   registers when autovectorizing for Neon, at least until multiple vector\n+   widths are supported properly by the middle-end.  */\n+#define UNITS_PER_SIMD_WORD \\\n+  (TARGET_NEON ? (TARGET_NEON_VECTORIZE_QUAD ? 16 : 8) : UNITS_PER_WORD)\n+\n /* True if natural alignment is used for doubleword types.  */\n #define ARM_DOUBLEWORD_ALIGN\tTARGET_AAPCS_BASED\n \n@@ -941,6 +965,18 @@ extern int arm_structure_size_boundary;\n #define VFP_REGNO_OK_FOR_DOUBLE(REGNUM) \\\n   ((((REGNUM) - FIRST_VFP_REGNUM) & 1) == 0)\n \n+/* Neon Quad values must start at a multiple of four registers.  */\n+#define NEON_REGNO_OK_FOR_QUAD(REGNUM) \\\n+  ((((REGNUM) - FIRST_VFP_REGNUM) & 3) == 0)\n+\n+/* Neon structures of vectors must be in even register pairs and there\n+   must be enough registers available.  Because of various patterns\n+   requiring quad registers, we require them to start at a multiple of\n+   four.  */\n+#define NEON_REGNO_OK_FOR_NREGS(REGNUM, N) \\\n+  ((((REGNUM) - FIRST_VFP_REGNUM) & 3) == 0 \\\n+   && (LAST_VFP_REGNUM - (REGNUM) >= 2 * (N) - 1))\n+\n /* The number of hard registers is 16 ARM + 8 FPA + 1 CC + 1 SFP + 1 AFP.  */\n /* + 16 Cirrus registers take us up to 43.  */\n /* Intel Wireless MMX Technology registers add 16 + 4 more.  */\n@@ -994,6 +1030,21 @@ extern int arm_structure_size_boundary;\n #define VALID_IWMMXT_REG_MODE(MODE) \\\n  (arm_vector_mode_supported_p (MODE) || (MODE) == DImode)\n \n+/* Modes valid for Neon D registers.  */\n+#define VALID_NEON_DREG_MODE(MODE) \\\n+  ((MODE) == V2SImode || (MODE) == V4HImode || (MODE) == V8QImode \\\n+   || (MODE) == V2SFmode || (MODE) == DImode)\n+\n+/* Modes valid for Neon Q registers.  */\n+#define VALID_NEON_QREG_MODE(MODE) \\\n+  ((MODE) == V4SImode || (MODE) == V8HImode || (MODE) == V16QImode \\\n+   || (MODE) == V4SFmode || (MODE) == V2DImode)\n+\n+/* Structure modes valid for Neon registers.  */\n+#define VALID_NEON_STRUCT_MODE(MODE) \\\n+  ((MODE) == TImode || (MODE) == EImode || (MODE) == OImode \\\n+   || (MODE) == CImode || (MODE) == XImode)\n+\n /* The order in which register should be allocated.  It is good to use ip\n    since no saving is required (though calls clobber it) and it never contains\n    function parameters.  It is quite good to use lr since other calls may\n@@ -2409,7 +2460,7 @@ extern int making_const_table;\n \n #define PRINT_OPERAND_PUNCT_VALID_P(CODE)\t\\\n   (CODE == '@' || CODE == '|' || CODE == '.'\t\\\n-   || CODE == '(' || CODE == ')'\t\t\\\n+   || CODE == '(' || CODE == ')' || CODE == '#'\t\\\n    || (TARGET_32BIT && (CODE == '?'))\t\t\\\n    || (TARGET_THUMB2 && (CODE == '!'))\t\t\\\n    || (TARGET_THUMB && (CODE == '_')))\n@@ -2581,6 +2632,9 @@ extern int making_const_table;\n    : arm_gen_return_addr_mask ())\n \n \f\n+/* Neon defines builtins from ARM_BUILTIN_MAX upwards, though they don't have\n+   symbolic names defined here (which would require too much duplication).\n+   FIXME?  */\n enum arm_builtins\n {\n   ARM_BUILTIN_GETWCX,\n@@ -2745,7 +2799,9 @@ enum arm_builtins\n \n   ARM_BUILTIN_THREAD_POINTER,\n \n-  ARM_BUILTIN_MAX\n+  ARM_BUILTIN_NEON_BASE,\n+\n+  ARM_BUILTIN_MAX = ARM_BUILTIN_NEON_BASE  /* FIXME: Wrong!  */\n };\n \n /* Do not emit .note.GNU-stack by default.  */"}, {"sha": "ddc8bed28587e69dccc0d8c7162148acf2e2fb7e", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 37, "deletions": 27, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -51,6 +51,7 @@\n \n ;; UNSPEC Usage:\n ;; Note: sin and cos are no-longer used.\n+;; Unspec constants for Neon are defined in neon.md.\n \n (define_constants\n   [(UNSPEC_SIN       0)\t; `sin' operation (MODE_FLOAT):\n@@ -121,12 +122,14 @@\n \t\t\t;   a 32-bit object.\n    (VUNSPEC_POOL_8   7) ; `pool-entry(8)'.  An entry in the constant pool for\n \t\t\t;   a 64-bit object.\n-   (VUNSPEC_TMRC     8) ; Used by the iWMMXt TMRC instruction.\n-   (VUNSPEC_TMCR     9) ; Used by the iWMMXt TMCR instruction.\n-   (VUNSPEC_ALIGN8   10) ; 8-byte alignment version of VUNSPEC_ALIGN\n-   (VUNSPEC_WCMP_EQ  11) ; Used by the iWMMXt WCMPEQ instructions\n-   (VUNSPEC_WCMP_GTU 12) ; Used by the iWMMXt WCMPGTU instructions\n-   (VUNSPEC_WCMP_GT  13) ; Used by the iwMMXT WCMPGT instructions\n+   (VUNSPEC_POOL_16  8) ; `pool-entry(16)'.  An entry in the constant pool for\n+\t\t\t;   a 128-bit object.\n+   (VUNSPEC_TMRC     9) ; Used by the iWMMXt TMRC instruction.\n+   (VUNSPEC_TMCR     10) ; Used by the iWMMXt TMCR instruction.\n+   (VUNSPEC_ALIGN8   11) ; 8-byte alignment version of VUNSPEC_ALIGN\n+   (VUNSPEC_WCMP_EQ  12) ; Used by the iWMMXt WCMPEQ instructions\n+   (VUNSPEC_WCMP_GTU 13) ; Used by the iWMMXt WCMPGTU instructions\n+   (VUNSPEC_WCMP_GT  14) ; Used by the iwMMXT WCMPGT instructions\n    (VUNSPEC_EH_RETURN 20); Use to override the return address for exception\n \t\t\t ; handling.\n   ]\n@@ -5768,27 +5771,6 @@\n   \"\n )\n \n-;; Vector Moves\n-(define_expand \"movv2si\"\n-  [(set (match_operand:V2SI 0 \"nonimmediate_operand\" \"\")\n-\t(match_operand:V2SI 1 \"general_operand\" \"\"))]\n-  \"TARGET_REALLY_IWMMXT\"\n-{\n-})\n-\n-(define_expand \"movv4hi\"\n-  [(set (match_operand:V4HI 0 \"nonimmediate_operand\" \"\")\n-\t(match_operand:V4HI 1 \"general_operand\" \"\"))]\n-  \"TARGET_REALLY_IWMMXT\"\n-{\n-})\n-\n-(define_expand \"movv8qi\"\n-  [(set (match_operand:V8QI 0 \"nonimmediate_operand\" \"\")\n-\t(match_operand:V8QI 1 \"general_operand\" \"\"))]\n-  \"TARGET_REALLY_IWMMXT\"\n-{\n-})\n \f\n \n ;; load- and store-multiple insns\n@@ -10731,6 +10713,30 @@\n   [(set_attr \"length\" \"8\")]\n )\n \n+(define_insn \"consttable_16\"\n+  [(unspec_volatile [(match_operand 0 \"\" \"\")] VUNSPEC_POOL_16)]\n+  \"TARGET_EITHER\"\n+  \"*\n+  {\n+    making_const_table = TRUE;\n+    switch (GET_MODE_CLASS (GET_MODE (operands[0])))\n+      {\n+       case MODE_FLOAT:\n+        {\n+          REAL_VALUE_TYPE r;\n+          REAL_VALUE_FROM_CONST_DOUBLE (r, operands[0]);\n+          assemble_real (r, GET_MODE (operands[0]), BITS_PER_WORD);\n+          break;\n+        }\n+      default:\n+        assemble_integer (operands[0], 16, BITS_PER_WORD, 1);\n+        break;\n+      }\n+    return \\\"\\\";\n+  }\"\n+  [(set_attr \"length\" \"16\")]\n+)\n+\n ;; Miscellaneous Thumb patterns\n \n (define_expand \"tablejump\"\n@@ -10906,10 +10912,14 @@\n (include \"fpa.md\")\n ;; Load the Maverick co-processor patterns\n (include \"cirrus.md\")\n+;; Vector bits common to IWMMXT and Neon\n+(include \"vec-common.md\")\n ;; Load the Intel Wireless Multimedia Extension patterns\n (include \"iwmmxt.md\")\n ;; Load the VFP co-processor patterns\n (include \"vfp.md\")\n ;; Thumb-2 patterns\n (include \"thumb2.md\")\n+;; Neon patterns\n+(include \"neon.md\")\n "}, {"sha": "63717422a115887a2eee37028f7376fcac001a85", "filename": "gcc/config/arm/arm.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Fconfig%2Farm%2Farm.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Fconfig%2Farm%2Farm.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.opt?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -153,3 +153,7 @@ Tune code for the given processor\n mwords-little-endian\n Target Report RejectNegative Mask(LITTLE_WORDS)\n Assume big endian bytes, little endian words\n+\n+mvectorize-with-neon-quad\n+Target Report Mask(NEON_VECTORIZE_QUAD)\n+Use Neon quad-word (rather than double-word) registers for vectorization"}, {"sha": "e013e1714ec2ae5f0053151702a4f3299371ee6f", "filename": "gcc/config/arm/arm_neon.h", "status": "added", "additions": 12179, "deletions": 0, "changes": 12179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Fconfig%2Farm%2Farm_neon.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Fconfig%2Farm%2Farm_neon.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm_neon.h?ref=88f77cba027fa1be471081bcd2ec03392246af3a"}, {"sha": "ae5429c87b9d04c903abaa23b3eba6dbeac30b69", "filename": "gcc/config/arm/constraints.md", "status": "modified", "additions": 47, "deletions": 2, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Fconfig%2Farm%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Fconfig%2Farm%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fconstraints.md?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -30,10 +30,10 @@\n ;; in Thumb-1 state: I, J, K, L, M, N, O\n \n ;; The following multi-letter normal constraints have been used:\n-;; in ARM/Thumb-2 state: Da, Db, Dc, Dv\n+;; in ARM/Thumb-2 state: Da, Db, Dc, Dn, Dl, DL, Dv\n \n ;; The following memory constraints have been used:\n-;; in ARM/Thumb-2 state: Q, Uv, Uy\n+;; in ARM/Thumb-2 state: Q, Ut, Uv, Uy, Un, Us\n ;; in ARM state: Uq\n \n \n@@ -164,13 +164,44 @@\n       (match_test \"TARGET_32BIT && arm_const_double_inline_cost (op) == 4\n \t\t   && !(optimize_size || arm_ld_sched)\")))\n \n+(define_constraint \"Dn\"\n+ \"@internal\n+  In ARM/Thumb-2 state a const_vector which can be loaded with a Neon vmov\n+  immediate instruction.\"\n+ (and (match_code \"const_vector\")\n+      (match_test \"TARGET_32BIT\n+\t\t   && imm_for_neon_mov_operand (op, GET_MODE (op))\")))\n+\n+(define_constraint \"Dl\"\n+ \"@internal\n+  In ARM/Thumb-2 state a const_vector which can be used with a Neon vorr or\n+  vbic instruction.\"\n+ (and (match_code \"const_vector\")\n+      (match_test \"TARGET_32BIT\n+\t\t   && imm_for_neon_logic_operand (op, GET_MODE (op))\")))\n+\n+(define_constraint \"DL\"\n+ \"@internal\n+  In ARM/Thumb-2 state a const_vector which can be used with a Neon vorn or\n+  vand instruction.\"\n+ (and (match_code \"const_vector\")\n+      (match_test \"TARGET_32BIT\n+\t\t   && imm_for_neon_inv_logic_operand (op, GET_MODE (op))\")))\n+\n (define_constraint \"Dv\"\n  \"@internal\n   In ARM/Thumb-2 state a const_double which can be used with a VFP fconsts\n   or fconstd instruction.\"\n  (and (match_code \"const_double\")\n       (match_test \"TARGET_32BIT && vfp3_const_double_rtx (op)\")))\n \n+(define_memory_constraint \"Ut\"\n+ \"@internal\n+  In ARM/Thumb-2 state an address valid for loading/storing opaque structure\n+  types wider than TImode.\"\n+ (and (match_code \"mem\")\n+      (match_test \"TARGET_32BIT && neon_struct_mem_operand (op)\")))\n+\n (define_memory_constraint \"Uv\"\n  \"@internal\n   In ARM/Thumb-2 state a valid VFP load/store address.\"\n@@ -183,6 +214,20 @@\n  (and (match_code \"mem\")\n       (match_test \"TARGET_32BIT && arm_coproc_mem_operand (op, TRUE)\")))\n \n+(define_memory_constraint \"Un\"\n+ \"@internal\n+  In ARM/Thumb-2 state a valid address for Neon element and structure\n+  load/store instructions.\"\n+ (and (match_code \"mem\")\n+      (match_test \"TARGET_32BIT && neon_vector_mem_operand (op, FALSE)\")))\n+\n+(define_memory_constraint \"Us\"\n+ \"@internal\n+  In ARM/Thumb-2 state a valid address for non-offset loads/stores of\n+  quad-word values in four ARM registers.\"\n+ (and (match_code \"mem\")\n+      (match_test \"TARGET_32BIT && neon_vector_mem_operand (op, TRUE)\")))\n+\n (define_memory_constraint \"Uq\"\n  \"@internal\n   In ARM state an address valid in ldrsb instructions.\""}, {"sha": "a7278bf2db6e3fc13bb1de333ad662b8ddccef2d", "filename": "gcc/config/arm/iwmmxt.md", "status": "modified", "additions": 55, "deletions": 190, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Fconfig%2Farm%2Fiwmmxt.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Fconfig%2Farm%2Fiwmmxt.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fiwmmxt.md?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -20,6 +20,15 @@\n ;; the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n ;; Boston, MA 02110-1301, USA.\n \n+;; Integer element sizes implemented by IWMMXT.\n+(define_mode_macro VMMX [V2SI V4HI V8QI])\n+\n+;; Integer element sizes for shifts.\n+(define_mode_macro VSHFT [V4HI V2SI DI])\n+\n+;; Determine element size suffix from vector mode.\n+(define_mode_attr MMX_char [(V8QI \"b\") (V4HI \"h\") (V2SI \"w\") (DI \"d\")])\n+\n (define_insn \"iwmmxt_iordi3\"\n   [(set (match_operand:DI         0 \"register_operand\" \"=y,?&r,?&r\")\n         (ior:DI (match_operand:DI 1 \"register_operand\" \"%y,0,r\")\n@@ -239,28 +248,12 @@\n \n ;; Vector add/subtract\n \n-(define_insn \"addv8qi3\"\n-  [(set (match_operand:V8QI            0 \"register_operand\" \"=y\")\n-        (plus:V8QI (match_operand:V8QI 1 \"register_operand\"  \"y\")\n-\t           (match_operand:V8QI 2 \"register_operand\"  \"y\")))]\n-  \"TARGET_REALLY_IWMMXT\"\n-  \"waddb%?\\\\t%0, %1, %2\"\n-  [(set_attr \"predicable\" \"yes\")])\n-\n-(define_insn \"addv4hi3\"\n-  [(set (match_operand:V4HI            0 \"register_operand\" \"=y\")\n-        (plus:V4HI (match_operand:V4HI 1 \"register_operand\"  \"y\")\n-\t           (match_operand:V4HI 2 \"register_operand\"  \"y\")))]\n-  \"TARGET_REALLY_IWMMXT\"\n-  \"waddh%?\\\\t%0, %1, %2\"\n-  [(set_attr \"predicable\" \"yes\")])\n-\n-(define_insn \"addv2si3\"\n-  [(set (match_operand:V2SI            0 \"register_operand\" \"=y\")\n-        (plus:V2SI (match_operand:V2SI 1 \"register_operand\"  \"y\")\n-\t           (match_operand:V2SI 2 \"register_operand\"  \"y\")))]\n+(define_insn \"*add<mode>3_iwmmxt\"\n+  [(set (match_operand:VMMX            0 \"register_operand\" \"=y\")\n+        (plus:VMMX (match_operand:VMMX 1 \"register_operand\"  \"y\")\n+\t           (match_operand:VMMX 2 \"register_operand\"  \"y\")))]\n   \"TARGET_REALLY_IWMMXT\"\n-  \"waddw%?\\\\t%0, %1, %2\"\n+  \"wadd<MMX_char>%?\\\\t%0, %1, %2\"\n   [(set_attr \"predicable\" \"yes\")])\n \n (define_insn \"ssaddv8qi3\"\n@@ -311,28 +304,12 @@\n   \"waddwus%?\\\\t%0, %1, %2\"\n   [(set_attr \"predicable\" \"yes\")])\n \n-(define_insn \"subv8qi3\"\n-  [(set (match_operand:V8QI             0 \"register_operand\" \"=y\")\n-        (minus:V8QI (match_operand:V8QI 1 \"register_operand\"  \"y\")\n-\t\t    (match_operand:V8QI 2 \"register_operand\"  \"y\")))]\n+(define_insn \"*sub<mode>3_iwmmxt\"\n+  [(set (match_operand:VMMX             0 \"register_operand\" \"=y\")\n+        (minus:VMMX (match_operand:VMMX 1 \"register_operand\"  \"y\")\n+\t\t    (match_operand:VMMX 2 \"register_operand\"  \"y\")))]\n   \"TARGET_REALLY_IWMMXT\"\n-  \"wsubb%?\\\\t%0, %1, %2\"\n-  [(set_attr \"predicable\" \"yes\")])\n-\n-(define_insn \"subv4hi3\"\n-  [(set (match_operand:V4HI             0 \"register_operand\" \"=y\")\n-        (minus:V4HI (match_operand:V4HI 1 \"register_operand\"  \"y\")\n-\t\t    (match_operand:V4HI 2 \"register_operand\"  \"y\")))]\n-  \"TARGET_REALLY_IWMMXT\"\n-  \"wsubh%?\\\\t%0, %1, %2\"\n-  [(set_attr \"predicable\" \"yes\")])\n-\n-(define_insn \"subv2si3\"\n-  [(set (match_operand:V2SI             0 \"register_operand\" \"=y\")\n-        (minus:V2SI (match_operand:V2SI 1 \"register_operand\"  \"y\")\n-\t\t    (match_operand:V2SI 2 \"register_operand\"  \"y\")))]\n-  \"TARGET_REALLY_IWMMXT\"\n-  \"wsubw%?\\\\t%0, %1, %2\"\n+  \"wsub<MMX_char>%?\\\\t%0, %1, %2\"\n   [(set_attr \"predicable\" \"yes\")])\n \n (define_insn \"sssubv8qi3\"\n@@ -383,7 +360,7 @@\n   \"wsubwus%?\\\\t%0, %1, %2\"\n   [(set_attr \"predicable\" \"yes\")])\n \n-(define_insn \"mulv4hi3\"\n+(define_insn \"*mulv4hi3_iwmmxt\"\n   [(set (match_operand:V4HI            0 \"register_operand\" \"=y\")\n         (mult:V4HI (match_operand:V4HI 1 \"register_operand\" \"y\")\n \t\t   (match_operand:V4HI 2 \"register_operand\" \"y\")))]\n@@ -734,100 +711,36 @@\n \n ;; Max/min insns\n \n-(define_insn \"smaxv8qi3\"\n-  [(set (match_operand:V8QI            0 \"register_operand\" \"=y\")\n-        (smax:V8QI (match_operand:V8QI 1 \"register_operand\" \"y\")\n-\t\t   (match_operand:V8QI 2 \"register_operand\" \"y\")))]\n+(define_insn \"*smax<mode>3_iwmmxt\"\n+  [(set (match_operand:VMMX            0 \"register_operand\" \"=y\")\n+        (smax:VMMX (match_operand:VMMX 1 \"register_operand\" \"y\")\n+\t\t   (match_operand:VMMX 2 \"register_operand\" \"y\")))]\n   \"TARGET_REALLY_IWMMXT\"\n-  \"wmaxsb%?\\\\t%0, %1, %2\"\n+  \"wmaxs<MMX_char>%?\\\\t%0, %1, %2\"\n   [(set_attr \"predicable\" \"yes\")])\n \n-(define_insn \"umaxv8qi3\"\n-  [(set (match_operand:V8QI            0 \"register_operand\" \"=y\")\n-        (umax:V8QI (match_operand:V8QI 1 \"register_operand\" \"y\")\n-\t\t   (match_operand:V8QI 2 \"register_operand\" \"y\")))]\n+(define_insn \"*umax<mode>3_iwmmxt\"\n+  [(set (match_operand:VMMX            0 \"register_operand\" \"=y\")\n+        (umax:VMMX (match_operand:VMMX 1 \"register_operand\" \"y\")\n+\t\t   (match_operand:VMMX 2 \"register_operand\" \"y\")))]\n   \"TARGET_REALLY_IWMMXT\"\n-  \"wmaxub%?\\\\t%0, %1, %2\"\n+  \"wmaxu<MMX_char>%?\\\\t%0, %1, %2\"\n   [(set_attr \"predicable\" \"yes\")])\n \n-(define_insn \"smaxv4hi3\"\n-  [(set (match_operand:V4HI            0 \"register_operand\" \"=y\")\n-        (smax:V4HI (match_operand:V4HI 1 \"register_operand\" \"y\")\n-\t\t   (match_operand:V4HI 2 \"register_operand\" \"y\")))]\n-  \"TARGET_REALLY_IWMMXT\"\n-  \"wmaxsh%?\\\\t%0, %1, %2\"\n-  [(set_attr \"predicable\" \"yes\")])\n-\n-(define_insn \"umaxv4hi3\"\n-  [(set (match_operand:V4HI            0 \"register_operand\" \"=y\")\n-        (umax:V4HI (match_operand:V4HI 1 \"register_operand\" \"y\")\n-\t\t   (match_operand:V4HI 2 \"register_operand\" \"y\")))]\n-  \"TARGET_REALLY_IWMMXT\"\n-  \"wmaxuh%?\\\\t%0, %1, %2\"\n-  [(set_attr \"predicable\" \"yes\")])\n-\n-(define_insn \"smaxv2si3\"\n-  [(set (match_operand:V2SI            0 \"register_operand\" \"=y\")\n-        (smax:V2SI (match_operand:V2SI 1 \"register_operand\" \"y\")\n-\t\t   (match_operand:V2SI 2 \"register_operand\" \"y\")))]\n-  \"TARGET_REALLY_IWMMXT\"\n-  \"wmaxsw%?\\\\t%0, %1, %2\"\n-  [(set_attr \"predicable\" \"yes\")])\n-\n-(define_insn \"umaxv2si3\"\n-  [(set (match_operand:V2SI            0 \"register_operand\" \"=y\")\n-        (umax:V2SI (match_operand:V2SI 1 \"register_operand\" \"y\")\n-\t\t   (match_operand:V2SI 2 \"register_operand\" \"y\")))]\n-  \"TARGET_REALLY_IWMMXT\"\n-  \"wmaxuw%?\\\\t%0, %1, %2\"\n-  [(set_attr \"predicable\" \"yes\")])\n-\n-(define_insn \"sminv8qi3\"\n-  [(set (match_operand:V8QI            0 \"register_operand\" \"=y\")\n-        (smin:V8QI (match_operand:V8QI 1 \"register_operand\" \"y\")\n-\t\t   (match_operand:V8QI 2 \"register_operand\" \"y\")))]\n-  \"TARGET_REALLY_IWMMXT\"\n-  \"wminsb%?\\\\t%0, %1, %2\"\n-  [(set_attr \"predicable\" \"yes\")])\n-\n-(define_insn \"uminv8qi3\"\n-  [(set (match_operand:V8QI            0 \"register_operand\" \"=y\")\n-        (umin:V8QI (match_operand:V8QI 1 \"register_operand\" \"y\")\n-\t\t   (match_operand:V8QI 2 \"register_operand\" \"y\")))]\n-  \"TARGET_REALLY_IWMMXT\"\n-  \"wminub%?\\\\t%0, %1, %2\"\n-  [(set_attr \"predicable\" \"yes\")])\n-\n-(define_insn \"sminv4hi3\"\n-  [(set (match_operand:V4HI            0 \"register_operand\" \"=y\")\n-        (smin:V4HI (match_operand:V4HI 1 \"register_operand\" \"y\")\n-\t\t   (match_operand:V4HI 2 \"register_operand\" \"y\")))]\n-  \"TARGET_REALLY_IWMMXT\"\n-  \"wminsh%?\\\\t%0, %1, %2\"\n-  [(set_attr \"predicable\" \"yes\")])\n-\n-(define_insn \"uminv4hi3\"\n-  [(set (match_operand:V4HI            0 \"register_operand\" \"=y\")\n-        (umin:V4HI (match_operand:V4HI 1 \"register_operand\" \"y\")\n-\t\t   (match_operand:V4HI 2 \"register_operand\" \"y\")))]\n+(define_insn \"*smin<mode>3_iwmmxt\"\n+  [(set (match_operand:VMMX            0 \"register_operand\" \"=y\")\n+        (smin:VMMX (match_operand:VMMX 1 \"register_operand\" \"y\")\n+\t\t   (match_operand:VMMX 2 \"register_operand\" \"y\")))]\n   \"TARGET_REALLY_IWMMXT\"\n-  \"wminuh%?\\\\t%0, %1, %2\"\n+  \"wmins<MMX_char>%?\\\\t%0, %1, %2\"\n   [(set_attr \"predicable\" \"yes\")])\n \n-(define_insn \"sminv2si3\"\n-  [(set (match_operand:V2SI            0 \"register_operand\" \"=y\")\n-        (smin:V2SI (match_operand:V2SI 1 \"register_operand\" \"y\")\n-\t\t   (match_operand:V2SI 2 \"register_operand\" \"y\")))]\n+(define_insn \"*umin<mode>3_iwmmxt\"\n+  [(set (match_operand:VMMX            0 \"register_operand\" \"=y\")\n+        (umin:VMMX (match_operand:VMMX 1 \"register_operand\" \"y\")\n+\t\t   (match_operand:VMMX 2 \"register_operand\" \"y\")))]\n   \"TARGET_REALLY_IWMMXT\"\n-  \"wminsw%?\\\\t%0, %1, %2\"\n-  [(set_attr \"predicable\" \"yes\")])\n-\n-(define_insn \"uminv2si3\"\n-  [(set (match_operand:V2SI            0 \"register_operand\" \"=y\")\n-        (umin:V2SI (match_operand:V2SI 1 \"register_operand\" \"y\")\n-\t\t   (match_operand:V2SI 2 \"register_operand\" \"y\")))]\n-  \"TARGET_REALLY_IWMMXT\"\n-  \"wminuw%?\\\\t%0, %1, %2\"\n+  \"wminu<MMX_char>%?\\\\t%0, %1, %2\"\n   [(set_attr \"predicable\" \"yes\")])\n \n ;; Pack/unpack insns.\n@@ -1141,76 +1054,28 @@\n   \"wrordg%?\\\\t%0, %1, %2\"\n   [(set_attr \"predicable\" \"yes\")])\n \n-(define_insn \"ashrv4hi3\"\n-  [(set (match_operand:V4HI                0 \"register_operand\" \"=y\")\n-        (ashiftrt:V4HI (match_operand:V4HI 1 \"register_operand\" \"y\")\n-\t\t       (match_operand:SI   2 \"register_operand\" \"z\")))]\n-  \"TARGET_REALLY_IWMMXT\"\n-  \"wsrahg%?\\\\t%0, %1, %2\"\n-  [(set_attr \"predicable\" \"yes\")])\n-\n-(define_insn \"ashrv2si3\"\n-  [(set (match_operand:V2SI                0 \"register_operand\" \"=y\")\n-        (ashiftrt:V2SI (match_operand:V2SI 1 \"register_operand\" \"y\")\n-\t\t       (match_operand:SI   2 \"register_operand\" \"z\")))]\n-  \"TARGET_REALLY_IWMMXT\"\n-  \"wsrawg%?\\\\t%0, %1, %2\"\n-  [(set_attr \"predicable\" \"yes\")])\n-\n-(define_insn \"ashrdi3_iwmmxt\"\n-  [(set (match_operand:DI              0 \"register_operand\" \"=y\")\n-\t(ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"y\")\n-\t\t   (match_operand:SI   2 \"register_operand\" \"z\")))]\n-  \"TARGET_REALLY_IWMMXT\"\n-  \"wsradg%?\\\\t%0, %1, %2\"\n-  [(set_attr \"predicable\" \"yes\")])\n-\n-(define_insn \"lshrv4hi3\"\n-  [(set (match_operand:V4HI                0 \"register_operand\" \"=y\")\n-        (lshiftrt:V4HI (match_operand:V4HI 1 \"register_operand\" \"y\")\n-\t\t       (match_operand:SI   2 \"register_operand\" \"z\")))]\n-  \"TARGET_REALLY_IWMMXT\"\n-  \"wsrlhg%?\\\\t%0, %1, %2\"\n-  [(set_attr \"predicable\" \"yes\")])\n-\n-(define_insn \"lshrv2si3\"\n-  [(set (match_operand:V2SI                0 \"register_operand\" \"=y\")\n-        (lshiftrt:V2SI (match_operand:V2SI 1 \"register_operand\" \"y\")\n-\t\t       (match_operand:SI   2 \"register_operand\" \"z\")))]\n-  \"TARGET_REALLY_IWMMXT\"\n-  \"wsrlwg%?\\\\t%0, %1, %2\"\n-  [(set_attr \"predicable\" \"yes\")])\n-\n-(define_insn \"lshrdi3_iwmmxt\"\n-  [(set (match_operand:DI              0 \"register_operand\" \"=y\")\n-\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"y\")\n-\t\t     (match_operand:SI 2 \"register_operand\" \"z\")))]\n+(define_insn \"ashr<mode>3_iwmmxt\"\n+  [(set (match_operand:VSHFT                 0 \"register_operand\" \"=y\")\n+        (ashiftrt:VSHFT (match_operand:VSHFT 1 \"register_operand\" \"y\")\n+\t\t\t(match_operand:SI    2 \"register_operand\" \"z\")))]\n   \"TARGET_REALLY_IWMMXT\"\n-  \"wsrldg%?\\\\t%0, %1, %2\"\n+  \"wsra<MMX_char>g%?\\\\t%0, %1, %2\"\n   [(set_attr \"predicable\" \"yes\")])\n \n-(define_insn \"ashlv4hi3\"\n-  [(set (match_operand:V4HI              0 \"register_operand\" \"=y\")\n-        (ashift:V4HI (match_operand:V4HI 1 \"register_operand\" \"y\")\n-\t\t     (match_operand:SI   2 \"register_operand\" \"z\")))]\n+(define_insn \"lshr<mode>3_iwmmxt\"\n+  [(set (match_operand:VSHFT                 0 \"register_operand\" \"=y\")\n+        (lshiftrt:VSHFT (match_operand:VSHFT 1 \"register_operand\" \"y\")\n+\t\t\t(match_operand:SI    2 \"register_operand\" \"z\")))]\n   \"TARGET_REALLY_IWMMXT\"\n-  \"wsllhg%?\\\\t%0, %1, %2\"\n+  \"wsrl<MMX_char>g%?\\\\t%0, %1, %2\"\n   [(set_attr \"predicable\" \"yes\")])\n \n-(define_insn \"ashlv2si3\"\n-  [(set (match_operand:V2SI              0 \"register_operand\" \"=y\")\n-        (ashift:V2SI (match_operand:V2SI 1 \"register_operand\" \"y\")\n-\t\t       (match_operand:SI 2 \"register_operand\" \"z\")))]\n-  \"TARGET_REALLY_IWMMXT\"\n-  \"wsllwg%?\\\\t%0, %1, %2\"\n-  [(set_attr \"predicable\" \"yes\")])\n-\n-(define_insn \"ashldi3_iwmmxt\"\n-  [(set (match_operand:DI            0 \"register_operand\" \"=y\")\n-\t(ashift:DI (match_operand:DI 1 \"register_operand\" \"y\")\n-\t\t   (match_operand:SI 2 \"register_operand\" \"z\")))]\n+(define_insn \"ashl<mode>3_iwmmxt\"\n+  [(set (match_operand:VSHFT               0 \"register_operand\" \"=y\")\n+        (ashift:VSHFT (match_operand:VSHFT 1 \"register_operand\" \"y\")\n+\t\t      (match_operand:SI    2 \"register_operand\" \"z\")))]\n   \"TARGET_REALLY_IWMMXT\"\n-  \"wslldg%?\\\\t%0, %1, %2\"\n+  \"wsll<MMX_char>g%?\\\\t%0, %1, %2\"\n   [(set_attr \"predicable\" \"yes\")])\n \n (define_insn \"rorv4hi3_di\""}, {"sha": "47d404ecf99e692a461dbd758ed4b2578189badc", "filename": "gcc/config/arm/neon-docgen.ml", "status": "added", "additions": 337, "deletions": 0, "changes": 337, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Fconfig%2Farm%2Fneon-docgen.ml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Fconfig%2Farm%2Fneon-docgen.ml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon-docgen.ml?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,337 @@\n+(* ARM NEON documentation generator.\n+\n+   Copyright (C) 2006 Free Software Foundation, Inc.\n+   Contributed by CodeSourcery.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 2, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+   02110-1301, USA.\n+\n+   This is an O'Caml program.  The O'Caml compiler is available from:\n+\n+     http://caml.inria.fr/\n+\n+   Or from your favourite OS's friendly packaging system. Tested with version\n+   3.09.2, though other versions will probably work too.\n+\n+   Compile with:\n+     ocamlc -c neon.ml\n+     ocamlc -o neon-docgen neon.cmo neon-docgen.ml\n+\n+   Run with:\n+     /path/to/neon-docgen /path/to/gcc/doc/arm-neon-intrinsics.texi\n+*)\n+\n+open Neon\n+\n+(* The combined \"ops\" and \"reinterp\" table.  *)\n+let ops_reinterp = reinterp @ ops\n+\n+(* Helper functions for extracting things from the \"ops\" table.  *)\n+let single_opcode desired_opcode () =\n+  List.fold_left (fun got_so_far ->\n+                  fun row ->\n+                    match row with\n+                      (opcode, _, _, _, _, _) ->\n+                        if opcode = desired_opcode then row :: got_so_far\n+                                                   else got_so_far\n+                 ) [] ops_reinterp\n+\n+let multiple_opcodes desired_opcodes () =\n+  List.fold_left (fun got_so_far ->\n+                  fun desired_opcode ->\n+                    (single_opcode desired_opcode ()) @ got_so_far)\n+                 [] desired_opcodes\n+\n+let ldx_opcode number () =\n+  List.fold_left (fun got_so_far ->\n+                  fun row ->\n+                    match row with\n+                      (opcode, _, _, _, _, _) ->\n+                        match opcode with\n+                          Vldx n | Vldx_lane n | Vldx_dup n when n = number ->\n+                            row :: got_so_far\n+                          | _ -> got_so_far\n+                 ) [] ops_reinterp\n+\n+let stx_opcode number () =\n+  List.fold_left (fun got_so_far ->\n+                  fun row ->\n+                    match row with\n+                      (opcode, _, _, _, _, _) ->\n+                        match opcode with\n+                          Vstx n | Vstx_lane n when n = number ->\n+                            row :: got_so_far\n+                          | _ -> got_so_far\n+                 ) [] ops_reinterp\n+\n+let tbl_opcode () =\n+  List.fold_left (fun got_so_far ->\n+                  fun row ->\n+                    match row with\n+                      (opcode, _, _, _, _, _) ->\n+                        match opcode with\n+                          Vtbl _ -> row :: got_so_far\n+                          | _ -> got_so_far\n+                 ) [] ops_reinterp\n+\n+let tbx_opcode () =\n+  List.fold_left (fun got_so_far ->\n+                  fun row ->\n+                    match row with\n+                      (opcode, _, _, _, _, _) ->\n+                        match opcode with\n+                          Vtbx _ -> row :: got_so_far\n+                          | _ -> got_so_far\n+                 ) [] ops_reinterp\n+\n+(* The groups of intrinsics.  *)\n+let intrinsic_groups =\n+  [ \"Addition\", single_opcode Vadd;\n+    \"Multiplication\", single_opcode Vmul;\n+    \"Multiply-accumulate\", single_opcode Vmla;\n+    \"Multiply-subtract\", single_opcode Vmls;\n+    \"Subtraction\", single_opcode Vsub;\n+    \"Comparison (equal-to)\", single_opcode Vceq;\n+    \"Comparison (greater-than-or-equal-to)\", single_opcode Vcge;\n+    \"Comparison (less-than-or-equal-to)\", single_opcode Vcle;\n+    \"Comparison (greater-than)\", single_opcode Vcgt;\n+    \"Comparison (less-than)\", single_opcode Vclt;\n+    \"Comparison (absolute greater-than-or-equal-to)\", single_opcode Vcage;\n+    \"Comparison (absolute less-than-or-equal-to)\", single_opcode Vcale;\n+    \"Comparison (absolute greater-than)\", single_opcode Vcagt;\n+    \"Comparison (absolute less-than)\", single_opcode Vcalt;\n+    \"Test bits\", single_opcode Vtst;\n+    \"Absolute difference\", single_opcode Vabd;\n+    \"Absolute difference and accumulate\", single_opcode Vaba;\n+    \"Maximum\", single_opcode Vmax;\n+    \"Minimum\", single_opcode Vmin;\n+    \"Pairwise add\", single_opcode Vpadd;\n+    \"Pairwise add, single_opcode widen and accumulate\", single_opcode Vpada;\n+    \"Folding maximum\", single_opcode Vpmax;\n+    \"Folding minimum\", single_opcode Vpmin;\n+    \"Reciprocal step\", multiple_opcodes [Vrecps; Vrsqrts];\n+    \"Vector shift left\", single_opcode Vshl;\n+    \"Vector shift left by constant\", single_opcode Vshl_n;\n+    \"Vector shift right by constant\", single_opcode Vshr_n;\n+    \"Vector shift right by constant and accumulate\", single_opcode Vsra_n;\n+    \"Vector shift right and insert\", single_opcode Vsri;\n+    \"Vector shift left and insert\", single_opcode Vsli;\n+    \"Absolute value\", single_opcode Vabs;\n+    \"Negation\", single_opcode Vneg;\n+    \"Bitwise not\", single_opcode Vmvn;\n+    \"Count leading sign bits\", single_opcode Vcls;\n+    \"Count leading zeros\", single_opcode Vclz;\n+    \"Count number of set bits\", single_opcode Vcnt;\n+    \"Reciprocal estimate\", single_opcode Vrecpe;\n+    \"Reciprocal square-root estimate\", single_opcode Vrsqrte;\n+    \"Get lanes from a vector\", single_opcode Vget_lane;\n+    \"Set lanes in a vector\", single_opcode Vset_lane;\n+    \"Create vector from literal bit pattern\", single_opcode Vcreate;\n+    \"Set all lanes to the same value\",\n+      multiple_opcodes [Vdup_n; Vmov_n; Vdup_lane];\n+    \"Combining vectors\", single_opcode Vcombine;\n+    \"Splitting vectors\", multiple_opcodes [Vget_high; Vget_low];\n+    \"Conversions\", multiple_opcodes [Vcvt; Vcvt_n];\n+    \"Move, single_opcode narrowing\", single_opcode Vmovn;\n+    \"Move, single_opcode long\", single_opcode Vmovl;\n+    \"Table lookup\", tbl_opcode;\n+    \"Extended table lookup\", tbx_opcode;\n+    \"Multiply, lane\", single_opcode Vmul_lane;\n+    \"Long multiply, lane\", single_opcode Vmull_lane;\n+    \"Saturating doubling long multiply, lane\", single_opcode Vqdmull_lane;\n+    \"Saturating doubling multiply high, lane\", single_opcode Vqdmulh_lane;\n+    \"Multiply-accumulate, lane\", single_opcode Vmla_lane;\n+    \"Multiply-subtract, lane\", single_opcode Vmls_lane;\n+    \"Vector multiply by scalar\", single_opcode Vmul_n;\n+    \"Vector long multiply by scalar\", single_opcode Vmull_n;\n+    \"Vector saturating doubling long multiply by scalar\",\n+      single_opcode Vqdmull_n;\n+    \"Vector saturating doubling multiply high by scalar\",\n+      single_opcode Vqdmulh_n;\n+    \"Vector multiply-accumulate by scalar\", single_opcode Vmla_n;\n+    \"Vector multiply-subtract by scalar\", single_opcode Vmls_n;\n+    \"Vector extract\", single_opcode Vext;\n+    \"Reverse elements\", multiple_opcodes [Vrev64; Vrev32; Vrev16];\n+    \"Bit selection\", single_opcode Vbsl;\n+    \"Transpose elements\", single_opcode Vtrn;\n+    \"Zip elements\", single_opcode Vzip;\n+    \"Unzip elements\", single_opcode Vuzp;\n+    \"Element/structure loads, VLD1 variants\", ldx_opcode 1;\n+    \"Element/structure stores, VST1 variants\", stx_opcode 1;\n+    \"Element/structure loads, VLD2 variants\", ldx_opcode 2;\n+    \"Element/structure stores, VST2 variants\", stx_opcode 2;\n+    \"Element/structure loads, VLD3 variants\", ldx_opcode 3;\n+    \"Element/structure stores, VST3 variants\", stx_opcode 3;\n+    \"Element/structure loads, VLD4 variants\", ldx_opcode 4;\n+    \"Element/structure stores, VST4 variants\", stx_opcode 4;\n+    \"Logical operations (AND)\", single_opcode Vand;\n+    \"Logical operations (OR)\", single_opcode Vorr;\n+    \"Logical operations (exclusive OR)\", single_opcode Veor;\n+    \"Logical operations (AND-NOT)\", single_opcode Vbic;\n+    \"Logical operations (OR-NOT)\", single_opcode Vorn;\n+    \"Reinterpret casts\", single_opcode Vreinterp ]\n+\n+(* Given an intrinsic shape, produce a string to document the corresponding\n+   operand shapes.  *)\n+let rec analyze_shape shape =\n+  let rec n_things n thing =\n+    match n with\n+      0 -> []\n+    | n -> thing :: (n_things (n - 1) thing)\n+  in\n+  let rec analyze_shape_elt reg_no elt =\n+    match elt with\n+      Dreg -> \"@var{d\" ^ (string_of_int reg_no) ^ \"}\"\n+    | Qreg -> \"@var{q\" ^ (string_of_int reg_no) ^ \"}\"\n+    | Corereg -> \"@var{r\" ^ (string_of_int reg_no) ^ \"}\"\n+    | Immed -> \"#@var{0}\"\n+    | VecArray (1, elt) ->\n+        let elt_regexp = analyze_shape_elt 0 elt in\n+          \"@{\" ^ elt_regexp ^ \"@}\"\n+    | VecArray (n, elt) ->\n+      let rec f m =\n+        match m with\n+          0 -> []\n+        | m -> (analyze_shape_elt (m - 1) elt) :: (f (m - 1))\n+      in\n+      let ops = List.rev (f n) in\n+        \"@{\" ^ (commas (fun x -> x) ops \"\") ^ \"@}\"\n+    | (PtrTo elt | CstPtrTo elt) ->\n+      \"[\" ^ (analyze_shape_elt reg_no elt) ^ \"]\"\n+    | Element_of_dreg -> (analyze_shape_elt reg_no Dreg) ^ \"[@var{0}]\"\n+    | Element_of_qreg -> (analyze_shape_elt reg_no Qreg) ^ \"[@var{0}]\"\n+    | All_elements_of_dreg -> (analyze_shape_elt reg_no Dreg) ^ \"[]\"\n+  in\n+    match shape with\n+      All (n, elt) -> commas (analyze_shape_elt 0) (n_things n elt) \"\"\n+    | Long -> (analyze_shape_elt 0 Qreg) ^ \", \" ^ (analyze_shape_elt 0 Dreg) ^\n+              \", \" ^ (analyze_shape_elt 0 Dreg)\n+    | Long_noreg elt -> (analyze_shape_elt 0 elt) ^ \", \" ^\n+              (analyze_shape_elt 0 elt)\n+    | Wide -> (analyze_shape_elt 0 Qreg) ^ \", \" ^ (analyze_shape_elt 0 Qreg) ^\n+              \", \" ^ (analyze_shape_elt 0 Dreg)\n+    | Wide_noreg elt -> analyze_shape (Long_noreg elt)\n+    | Narrow -> (analyze_shape_elt 0 Dreg) ^ \", \" ^ (analyze_shape_elt 0 Qreg) ^\n+                \", \" ^ (analyze_shape_elt 0 Qreg)\n+    | Use_operands elts -> commas (analyze_shape_elt 0) (Array.to_list elts) \"\"\n+    | By_scalar Dreg ->\n+        analyze_shape (Use_operands [| Dreg; Dreg; Element_of_dreg |])\n+    | By_scalar Qreg ->\n+        analyze_shape (Use_operands [| Qreg; Qreg; Element_of_dreg |])\n+    | By_scalar _ -> assert false\n+    | Wide_lane ->\n+        analyze_shape (Use_operands [| Qreg; Dreg; Element_of_dreg |])\n+    | Wide_scalar ->\n+        analyze_shape (Use_operands [| Qreg; Dreg; Element_of_dreg |])\n+    | Pair_result elt ->\n+      let elt_regexp = analyze_shape_elt 0 elt in\n+      let elt_regexp' = analyze_shape_elt 1 elt in\n+        elt_regexp ^ \", \" ^ elt_regexp'\n+    | Unary_scalar _ -> \"FIXME Unary_scalar\"\n+    | Binary_imm elt -> analyze_shape (Use_operands [| elt; elt; Immed |])\n+    | Narrow_imm -> analyze_shape (Use_operands [| Dreg; Qreg; Immed |])\n+    | Long_imm -> analyze_shape (Use_operands [| Qreg; Dreg; Immed |])\n+\n+(* Document a single intrinsic.  *)\n+let describe_intrinsic first chan\n+                       (elt_ty, (_, features, shape, name, munge, _)) =\n+  let c_arity, new_elt_ty = munge shape elt_ty in\n+  let c_types = strings_of_arity c_arity in\n+  Printf.fprintf chan \"@itemize @bullet\\n\";\n+  let item_code = if first then \"@item\" else \"@itemx\" in\n+    Printf.fprintf chan \"%s %s %s_%s (\" item_code (List.hd c_types)\n+                   (intrinsic_name name) (string_of_elt elt_ty);\n+    Printf.fprintf chan \"%s)\\n\" (commas (fun ty -> ty) (List.tl c_types) \"\");\n+    if not (List.exists (fun feature -> feature = No_op) features) then\n+    begin\n+      let print_one_insn name =\n+        Printf.fprintf chan \"@code{\";\n+        let no_suffix = (new_elt_ty = NoElts) in\n+        let name_with_suffix =\n+          if no_suffix then name\n+          else name ^ \".\" ^ (string_of_elt_dots new_elt_ty)\n+        in\n+        let possible_operands = analyze_all_shapes features shape\n+                                                   analyze_shape\n+        in\n+\tlet rec print_one_possible_operand op =\n+\t  Printf.fprintf chan \"%s %s}\" name_with_suffix op\n+        in\n+          (* If the intrinsic expands to multiple instructions, we assume\n+             they are all of the same form.  *)\n+          print_one_possible_operand (List.hd possible_operands)\n+      in\n+      let rec print_insns names =\n+        match names with\n+          [] -> ()\n+        | [name] -> print_one_insn name\n+        | name::names -> (print_one_insn name;\n+                          Printf.fprintf chan \" @emph{or} \";\n+                          print_insns names)\n+      in\n+      let insn_names = get_insn_names features name in\n+        Printf.fprintf chan \"@*@emph{Form of expected instruction(s):} \";\n+        print_insns insn_names;\n+        Printf.fprintf chan \"\\n\"\n+    end;\n+    Printf.fprintf chan \"@end itemize\\n\";\n+    Printf.fprintf chan \"\\n\\n\"\n+\n+(* Document a group of intrinsics.  *)\n+let document_group chan (group_title, group_extractor) =\n+  (* Extract the rows in question from the ops table and then turn them\n+     into a list of intrinsics.  *)\n+  let intrinsics =\n+    List.fold_left (fun got_so_far ->\n+                    fun row ->\n+                      match row with\n+                        (_, _, _, _, _, elt_tys) ->\n+                          List.fold_left (fun got_so_far' ->\n+                                          fun elt_ty ->\n+                                            (elt_ty, row) :: got_so_far')\n+                                         got_so_far elt_tys\n+                   ) [] (group_extractor ())\n+  in\n+    (* Emit the title for this group.  *)\n+    Printf.fprintf chan \"@subsubsection %s\\n\\n\" group_title;\n+    (* Emit a description of each intrinsic.  *)\n+    List.iter (describe_intrinsic true chan) intrinsics;\n+    (* Close this group.  *)\n+    Printf.fprintf chan \"\\n\\n\"\n+\n+let gnu_header chan =\n+  List.iter (fun s -> Printf.fprintf chan \"%s\\n\" s) [\n+  \"@c Copyright (C) 2006 Free Software Foundation, Inc.\";\n+  \"@c This is part of the GCC manual.\";\n+  \"@c For copying conditions, see the file gcc.texi.\";\n+  \"\";\n+  \"@c This file is generated automatically using gcc/config/arm/neon-docgen.ml\";\n+  \"@c Please do not edit manually.\"]\n+\n+(* Program entry point.  *)\n+let _ =\n+  if Array.length Sys.argv <> 2 then\n+    failwith \"Usage: neon-docgen <output filename>\"\n+  else\n+  let file = Sys.argv.(1) in\n+    try\n+      let chan = open_out file in\n+        gnu_header chan;\n+        List.iter (document_group chan) intrinsic_groups;\n+        close_out chan\n+    with Sys_error sys ->\n+      failwith (\"Could not create output file \" ^ file ^ \": \" ^ sys)"}, {"sha": "1f26fcbb357258e561aa96aa4f1e34b3b7ee07a9", "filename": "gcc/config/arm/neon-gen.ml", "status": "added", "additions": 419, "deletions": 0, "changes": 419, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Fconfig%2Farm%2Fneon-gen.ml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Fconfig%2Farm%2Fneon-gen.ml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon-gen.ml?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,419 @@\n+(* Auto-generate ARM Neon intrinsics header file.\n+   Copyright (C) 2006, 2007 Free Software Foundation, Inc.\n+   Contributed by CodeSourcery.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 2, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+   02110-1301, USA.\n+\n+   This is an O'Caml program.  The O'Caml compiler is available from:\n+\n+     http://caml.inria.fr/\n+\n+   Or from your favourite OS's friendly packaging system. Tested with version\n+   3.09.2, though other versions will probably work too.\n+\n+   Compile with:\n+     ocamlc -c neon.ml\n+     ocamlc -o neon-gen neon.cmo neon-gen.ml\n+\n+   Run with:\n+     ./neon-gen > arm_neon.h\n+*)\n+\n+open Neon\n+\n+(* The format codes used in the following functions are documented at:\n+     http://caml.inria.fr/pub/docs/manual-ocaml/libref/Format.html\\\n+     #6_printflikefunctionsforprettyprinting\n+   (one line, remove the backslash.)\n+*)\n+\n+(* Following functions can be used to approximate GNU indentation style.  *)\n+let start_function () =\n+  Format.printf \"@[<v 0>\";\n+  ref 0\n+\n+let end_function nesting =\n+  match !nesting with\n+    0 -> Format.printf \"@;@;@]\"\n+  | _ -> failwith (\"Bad nesting (ending function at level \"\n+                   ^ (string_of_int !nesting) ^ \")\")\n+\n+let open_braceblock nesting =\n+  begin match !nesting with\n+    0 -> Format.printf \"@,@<0>{@[<v 2>@,\"\n+  | _ -> Format.printf \"@,@[<v 2>  @<0>{@[<v 2>@,\"\n+  end;\n+  incr nesting\n+\n+let close_braceblock nesting =\n+  decr nesting;\n+  match !nesting with\n+    0 -> Format.printf \"@]@,@<0>}\"\n+  | _ -> Format.printf \"@]@,@<0>}@]\"\n+\n+let print_function arity fnname body =\n+  let ffmt = start_function () in\n+  Format.printf \"__extension__ static __inline \";\n+  let inl = \"__attribute__ ((__always_inline__))\" in\n+  begin match arity with\n+    Arity0 ret ->\n+      Format.printf \"%s %s@,%s (void)\" (string_of_vectype ret) inl fnname\n+  | Arity1 (ret, arg0) ->\n+      Format.printf \"%s %s@,%s (%s __a)\" (string_of_vectype ret) inl fnname\n+                                        (string_of_vectype arg0)\n+  | Arity2 (ret, arg0, arg1) ->\n+      Format.printf \"%s %s@,%s (%s __a, %s __b)\"\n+        (string_of_vectype ret) inl fnname (string_of_vectype arg0)\n+\t(string_of_vectype arg1)\n+  | Arity3 (ret, arg0, arg1, arg2) ->\n+      Format.printf \"%s %s@,%s (%s __a, %s __b, %s __c)\"\n+        (string_of_vectype ret) inl fnname (string_of_vectype arg0)\n+\t(string_of_vectype arg1) (string_of_vectype arg2)\n+  | Arity4 (ret, arg0, arg1, arg2, arg3) ->\n+      Format.printf \"%s %s@,%s (%s __a, %s __b, %s __c, %s __d)\"\n+        (string_of_vectype ret) inl fnname (string_of_vectype arg0)\n+\t(string_of_vectype arg1) (string_of_vectype arg2)\n+        (string_of_vectype arg3)\n+  end;\n+  open_braceblock ffmt;\n+  let rec print_lines = function\n+    [] -> ()\n+  | [line] -> Format.printf \"%s\" line\n+  | line::lines -> Format.printf \"%s@,\" line; print_lines lines in\n+  print_lines body;\n+  close_braceblock ffmt;\n+  end_function ffmt\n+\n+let return_by_ptr features = List.mem ReturnPtr features\n+\n+let union_string num elts base =\n+  let itype = inttype_for_array num elts in\n+  let iname = string_of_inttype itype\n+  and sname = string_of_vectype (T_arrayof (num, elts)) in\n+  Printf.sprintf \"union { %s __i; %s __o; } %s\" sname iname base\n+\n+let rec signed_ctype = function\n+    T_uint8x8 | T_poly8x8 -> T_int8x8\n+  | T_uint8x16 | T_poly8x16 -> T_int8x16\n+  | T_uint16x4 | T_poly16x4 -> T_int16x4\n+  | T_uint16x8 | T_poly16x8 -> T_int16x8\n+  | T_uint32x2 -> T_int32x2\n+  | T_uint32x4 -> T_int32x4\n+  | T_uint64x1 -> T_int64x1\n+  | T_uint64x2 -> T_int64x2\n+  (* Cast to types defined by mode in arm.c, not random types pulled in from\n+     the <stdint.h> header in use. This fixes incompatible pointer errors when\n+     compiling with C++.  *)\n+  | T_uint8 | T_int8 -> T_intQI\n+  | T_uint16 | T_int16 -> T_intHI\n+  | T_uint32 | T_int32 -> T_intSI\n+  | T_uint64 | T_int64 -> T_intDI\n+  | T_poly8 -> T_intQI\n+  | T_poly16 -> T_intHI\n+  | T_arrayof (n, elt) -> T_arrayof (n, signed_ctype elt)\n+  | T_ptrto elt -> T_ptrto (signed_ctype elt)\n+  | T_const elt -> T_const (signed_ctype elt)\n+  | x -> x\n+\n+let add_cast ctype cval =\n+  let stype = signed_ctype ctype in\n+  if ctype <> stype then\n+    Printf.sprintf \"(%s) %s\" (string_of_vectype stype) cval\n+  else\n+    cval\n+\n+let cast_for_return to_ty = \"(\" ^ (string_of_vectype to_ty) ^ \")\"\n+\n+(* Return a tuple of a list of declarations to go at the start of the function,\n+   and a list of statements needed to return THING.  *)\n+let return arity return_by_ptr thing =\n+  match arity with\n+    Arity0 (ret) | Arity1 (ret, _) | Arity2 (ret, _, _) | Arity3 (ret, _, _, _)\n+  | Arity4 (ret, _, _, _, _) ->\n+    match ret with\n+      T_arrayof (num, vec) ->\n+        if return_by_ptr then\n+          let sname = string_of_vectype ret in\n+          [Printf.sprintf \"%s __rv;\" sname],\n+          [thing ^ \";\"; \"return __rv;\"]\n+        else\n+          let uname = union_string num vec \"__rv\" in\n+          [uname ^ \";\"], [\"__rv.__o = \" ^ thing ^ \";\"; \"return __rv.__i;\"]\n+    | T_void -> [], [thing ^ \";\"]\n+    | _ ->\n+        [], [\"return \" ^ (cast_for_return ret) ^ thing ^ \";\"]\n+\n+let rec element_type ctype =\n+  match ctype with\n+    T_arrayof (_, v) -> element_type v\n+  | _ -> ctype\n+\n+let params return_by_ptr ps =\n+  let pdecls = ref [] in\n+  let ptype t p =\n+    match t with\n+      T_arrayof (num, elts) ->\n+        let uname = union_string num elts (p ^ \"u\") in\n+        let decl = Printf.sprintf \"%s = { %s };\" uname p in\n+        pdecls := decl :: !pdecls;\n+        p ^ \"u.__o\"\n+    | _ -> add_cast t p in\n+  let plist = match ps with\n+    Arity0 _ -> []\n+  | Arity1 (_, t1) -> [ptype t1 \"__a\"]\n+  | Arity2 (_, t1, t2) -> [ptype t1 \"__a\"; ptype t2 \"__b\"]\n+  | Arity3 (_, t1, t2, t3) -> [ptype t1 \"__a\"; ptype t2 \"__b\"; ptype t3 \"__c\"]\n+  | Arity4 (_, t1, t2, t3, t4) ->\n+      [ptype t1 \"__a\"; ptype t2 \"__b\"; ptype t3 \"__c\"; ptype t4 \"__d\"] in\n+  match ps with\n+    Arity0 ret | Arity1 (ret, _) | Arity2 (ret, _, _) | Arity3 (ret, _, _, _)\n+  | Arity4 (ret, _, _, _, _) ->\n+      if return_by_ptr then\n+        !pdecls, add_cast (T_ptrto (element_type ret)) \"&__rv.val[0]\" :: plist\n+      else\n+        !pdecls, plist\n+\n+let modify_params features plist =\n+  let is_flipped =\n+    List.exists (function Flipped _ -> true | _ -> false) features in\n+  if is_flipped then\n+    match plist with\n+      [ a; b ] -> [ b; a ]\n+    | _ ->\n+      failwith (\"Don't know how to flip args \" ^ (String.concat \", \" plist))\n+  else\n+    plist\n+\n+(* !!! Decide whether to add an extra information word based on the shape\n+   form.  *)\n+let extra_word shape features paramlist bits =\n+  let use_word =\n+    match shape with\n+      All _ | Long | Long_noreg _ | Wide | Wide_noreg _ | Narrow\n+    | By_scalar _ | Wide_scalar | Wide_lane | Binary_imm _ | Long_imm\n+    | Narrow_imm -> true\n+    | _ -> List.mem InfoWord features\n+  in\n+    if use_word then\n+      paramlist @ [string_of_int bits]\n+    else\n+      paramlist\n+\n+(* Bit 0 represents signed (1) vs unsigned (0), or float (1) vs poly (0).\n+   Bit 1 represents floats & polynomials (1), or ordinary integers (0).\n+   Bit 2 represents rounding (1) vs none (0).  *)\n+let infoword_value elttype features =\n+  let bits01 =\n+    match elt_class elttype with\n+      Signed | ConvClass (Signed, _) | ConvClass (_, Signed) -> 0b001\n+    | Poly -> 0b010\n+    | Float -> 0b011\n+    | _ -> 0b000\n+  and rounding_bit = if List.mem Rounding features then 0b100 else 0b000 in\n+  bits01 lor rounding_bit\n+\n+(* \"Cast\" type operations will throw an exception in mode_of_elt (actually in\n+   elt_width, called from there). Deal with that here, and generate a suffix\n+   with multiple modes (<to><from>).  *)\n+let rec mode_suffix elttype shape =\n+  try\n+    let mode = mode_of_elt elttype shape in\n+    string_of_mode mode\n+  with MixedMode (dst, src) ->\n+    let dstmode = mode_of_elt dst shape\n+    and srcmode = mode_of_elt src shape in\n+    string_of_mode dstmode ^ string_of_mode srcmode\n+\n+let print_variant opcode features shape name (ctype, asmtype, elttype) =\n+  let bits = infoword_value elttype features in\n+  let modesuf = mode_suffix elttype shape in\n+  let return_by_ptr = return_by_ptr features in\n+  let pdecls, paramlist = params return_by_ptr ctype in\n+  let paramlist' = modify_params features paramlist in\n+  let paramlist'' = extra_word shape features paramlist' bits in\n+  let parstr = String.concat \", \" paramlist'' in\n+  let builtin = Printf.sprintf \"__builtin_neon_%s%s (%s)\"\n+                  (builtin_name features name) modesuf parstr in\n+  let rdecls, stmts = return ctype return_by_ptr builtin in\n+  let body = pdecls @ rdecls @ stmts\n+  and fnname = (intrinsic_name name) ^ \"_\" ^ (string_of_elt elttype) in\n+  print_function ctype fnname body\n+\n+(* When this function processes the element types in the ops table, it rewrites\n+   them in a list of tuples (a,b,c):\n+     a : C type as an \"arity\", e.g. Arity1 (T_poly8x8, T_poly8x8)\n+     b : Asm type : a single, processed element type, e.g. P16. This is the\n+         type which should be attached to the asm opcode.\n+     c : Variant type : the unprocessed type for this variant (e.g. in add\n+         instructions which don't care about the sign, b might be i16 and c\n+         might be s16.)\n+*)\n+\n+let print_op (opcode, features, shape, name, munge, types) =\n+  let sorted_types = List.sort compare types in\n+  let munged_types = List.map\n+    (fun elt -> let c, asm = munge shape elt in c, asm, elt) sorted_types in\n+  List.iter\n+    (fun variant -> print_variant opcode features shape name variant)\n+    munged_types\n+\n+let print_ops ops =\n+  List.iter print_op ops\n+\n+(* Output type definitions. Table entries are:\n+     cbase : \"C\" name for the type.\n+     abase : \"ARM\" base name for the type (i.e. int in int8x8_t).\n+     esize : element size.\n+     enum : element count.\n+*)\n+\n+let deftypes () =\n+  let typeinfo = [\n+    (* Doubleword vector types.  *)\n+    \"__builtin_neon_qi\", \"int\", 8, 8;\n+    \"__builtin_neon_hi\", \"int\", 16, 4;\n+    \"__builtin_neon_si\", \"int\", 32, 2;\n+    \"__builtin_neon_di\", \"int\", 64, 1;\n+    \"__builtin_neon_sf\", \"float\", 32, 2;\n+    \"__builtin_neon_poly8\", \"poly\", 8, 8;\n+    \"__builtin_neon_poly16\", \"poly\", 16, 4;\n+    \"__builtin_neon_uqi\", \"uint\", 8, 8;\n+    \"__builtin_neon_uhi\", \"uint\", 16, 4;\n+    \"__builtin_neon_usi\", \"uint\", 32, 2;\n+    \"__builtin_neon_udi\", \"uint\", 64, 1;\n+\n+    (* Quadword vector types.  *)\n+    \"__builtin_neon_qi\", \"int\", 8, 16;\n+    \"__builtin_neon_hi\", \"int\", 16, 8;\n+    \"__builtin_neon_si\", \"int\", 32, 4;\n+    \"__builtin_neon_di\", \"int\", 64, 2;\n+    \"__builtin_neon_sf\", \"float\", 32, 4;\n+    \"__builtin_neon_poly8\", \"poly\", 8, 16;\n+    \"__builtin_neon_poly16\", \"poly\", 16, 8;\n+    \"__builtin_neon_uqi\", \"uint\", 8, 16;\n+    \"__builtin_neon_uhi\", \"uint\", 16, 8;\n+    \"__builtin_neon_usi\", \"uint\", 32, 4;\n+    \"__builtin_neon_udi\", \"uint\", 64, 2\n+  ] in\n+  List.iter\n+    (fun (cbase, abase, esize, enum) ->\n+      let attr =\n+        match enum with\n+          1 -> \"\"\n+        | _ -> Printf.sprintf \"\\t__attribute__ ((__vector_size__ (%d)))\"\n+                              (esize * enum / 8) in\n+      Format.printf \"typedef %s %s%dx%d_t%s;@\\n\" cbase abase esize enum attr)\n+    typeinfo;\n+  Format.print_newline ();\n+  (* Extra types not in <stdint.h>.  *)\n+  Format.printf \"typedef __builtin_neon_sf float32_t;\\n\";\n+  Format.printf \"typedef __builtin_neon_poly8 poly8_t;\\n\";\n+  Format.printf \"typedef __builtin_neon_poly16 poly16_t;\\n\"\n+\n+(* Output structs containing arrays, for load & store instructions etc.  *)\n+\n+let arrtypes () =\n+  let typeinfo = [\n+    \"int\", 8;    \"int\", 16;\n+    \"int\", 32;   \"int\", 64;\n+    \"uint\", 8;   \"uint\", 16;\n+    \"uint\", 32;  \"uint\", 64;\n+    \"float\", 32; \"poly\", 8;\n+    \"poly\", 16\n+  ] in\n+  let writestruct elname elsize regsize arrsize =\n+    let elnum = regsize / elsize in\n+    let structname =\n+      Printf.sprintf \"%s%dx%dx%d_t\" elname elsize elnum arrsize in\n+    let sfmt = start_function () in\n+    Format.printf \"typedef struct %s\" structname;\n+    open_braceblock sfmt;\n+    Format.printf \"%s%dx%d_t val[%d];\" elname elsize elnum arrsize;\n+    close_braceblock sfmt;\n+    Format.printf \" %s;\" structname;\n+    end_function sfmt;\n+  in\n+    for n = 2 to 4 do\n+      List.iter\n+        (fun (elname, elsize) ->\n+          writestruct elname elsize 64 n;\n+          writestruct elname elsize 128 n)\n+        typeinfo\n+    done\n+\n+let print_lines = List.iter (fun s -> Format.printf \"%s@\\n\" s)\n+\n+(* Do it.  *)\n+\n+let _ =\n+  print_lines [\n+\"/* ARM NEON intrinsics include file. This file is generated automatically\";\n+\"   using neon-gen.ml.  Please do not edit manually.\";\n+\"\";\n+\"   Copyright (C) 2006, 2007 Free Software Foundation, Inc.\";\n+\"   Contributed by CodeSourcery.\";\n+\"\";\n+\"   This file is part of GCC.\";\n+\"\";\n+\"   GCC is free software; you can redistribute it and/or modify it\";\n+\"   under the terms of the GNU General Public License as published\";\n+\"   by the Free Software Foundation; either version 2, or (at your\";\n+\"   option) any later version.\";\n+\"\";\n+\"   GCC is distributed in the hope that it will be useful, but WITHOUT\";\n+\"   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\";\n+\"   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\";\n+\"   License for more details.\";\n+\"\";\n+\"   You should have received a copy of the GNU General Public License\";\n+\"   along with GCC; see the file COPYING.  If not, write to the\";\n+\"   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\";\n+\"   MA 02110-1301, USA.  */\";\n+\"\";\n+\"/* As a special exception, if you include this header file into source\";\n+\"   files compiled by GCC, this header file does not by itself cause\";\n+\"   the resulting executable to be covered by the GNU General Public\";\n+\"   License.  This exception does not however invalidate any other\";\n+\"   reasons why the executable file might be covered by the GNU General\";\n+\"   Public License.  */\";\n+\"\";\n+\"#ifndef _GCC_ARM_NEON_H\";\n+\"#define _GCC_ARM_NEON_H 1\";\n+\"\";\n+\"#ifndef __ARM_NEON__\";\n+\"#error You must enable NEON instructions (e.g. -mfloat-abi=softfp -mfpu=neon) to use arm_neon.h\";\n+\"#else\";\n+\"\";\n+\"#ifdef __cplusplus\";\n+\"extern \\\"C\\\" {\";\n+\"#endif\";\n+\"\";\n+\"#include <stdint.h>\";\n+\"\"];\n+  deftypes ();\n+  arrtypes ();\n+  Format.print_newline ();\n+  print_ops ops;\n+  Format.print_newline ();\n+  print_ops reinterp;\n+  print_lines [\n+\"#ifdef __cplusplus\";\n+\"}\";\n+\"#endif\";\n+\"#endif\";\n+\"#endif\"]"}, {"sha": "56e11d413e090afdb674754291000e111e0a37a2", "filename": "gcc/config/arm/neon-testgen.ml", "status": "added", "additions": 277, "deletions": 0, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Fconfig%2Farm%2Fneon-testgen.ml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Fconfig%2Farm%2Fneon-testgen.ml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon-testgen.ml?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,277 @@\n+(* Auto-generate ARM Neon intrinsics tests.\n+   Copyright (C) 2006 Free Software Foundation, Inc.\n+   Contributed by CodeSourcery.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 2, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+   02110-1301, USA.\n+\n+   This is an O'Caml program.  The O'Caml compiler is available from:\n+\n+     http://caml.inria.fr/\n+\n+   Or from your favourite OS's friendly packaging system. Tested with version\n+   3.09.2, though other versions will probably work too.\n+\n+   Compile with:\n+     ocamlc -c neon.ml\n+     ocamlc -o neon-testgen neon.cmo neon-testgen.ml\n+\n+   Run with:\n+     cd /path/to/gcc/testsuite/gcc.target/arm/neon\n+     /path/to/neon-testgen\n+*)\n+\n+open Neon\n+\n+type c_type_flags = Pointer | Const\n+\n+(* Open a test source file.  *)\n+let open_test_file dir name =\n+  try\n+    open_out (dir ^ \"/\" ^ name ^ \".c\")\n+  with Sys_error str ->\n+    failwith (\"Could not create test source file \" ^ name ^ \": \" ^ str)\n+\n+(* Emit prologue code to a test source file.  *)\n+let emit_prologue chan test_name =\n+  Printf.fprintf chan \"/* Test the `%s' ARM Neon intrinsic.  */\\n\" test_name;\n+  Printf.fprintf chan \"/* This file was autogenerated by neon-testgen.  */\\n\\n\";\n+  Printf.fprintf chan \"/* { dg-do assemble } */\\n\";\n+  Printf.fprintf chan \"/* { dg-require-effective-target arm_neon_ok } */\\n\";\n+  Printf.fprintf chan\n+                 \"/* { dg-options \\\"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\\\" } */\\n\";\n+  Printf.fprintf chan \"\\n#include \\\"arm_neon.h\\\"\\n\\n\";\n+  Printf.fprintf chan \"void test_%s (void)\\n{\\n\" test_name\n+\n+(* Emit declarations of local variables that are going to be passed\n+   to an intrinsic, together with one to take a returned value if needed.  *)\n+let emit_automatics chan c_types =\n+  let emit () =\n+    ignore (\n+      List.fold_left (fun arg_number -> fun (flags, ty) ->\n+                        let pointer_bit =\n+                          if List.mem Pointer flags then \"*\" else \"\"\n+                        in\n+                          (* Const arguments to builtins are directly\n+                             written in as constants.  *)\n+                          if not (List.mem Const flags) then\n+                            Printf.fprintf chan \"  %s %sarg%d_%s;\\n\"\n+                                           ty pointer_bit arg_number ty;\n+                        arg_number + 1)\n+                     0 (List.tl c_types))\n+  in\n+    match c_types with\n+      (_, return_ty) :: tys ->\n+        if return_ty <> \"void\" then\n+          (* The intrinsic returns a value.  *)\n+          (Printf.fprintf chan \"  %s out_%s;\\n\" return_ty return_ty;\n+           emit ())\n+        else\n+          (* The intrinsic does not return a value.  *)\n+          emit ()\n+    | _ -> assert false\n+\n+(* Emit code to call an intrinsic.  *)\n+let emit_call chan const_valuator c_types name elt_ty =\n+  (if snd (List.hd c_types) <> \"void\" then\n+     Printf.fprintf chan \"  out_%s = \" (snd (List.hd c_types))\n+   else\n+     Printf.fprintf chan \"  \");\n+  Printf.fprintf chan \"%s_%s (\" (intrinsic_name name) (string_of_elt elt_ty);\n+  let print_arg chan arg_number (flags, ty) =\n+    (* If the argument is of const type, then directly write in the\n+       constant now.  *)\n+    if List.mem Const flags then\n+      match const_valuator with\n+        None ->\n+          if List.mem Pointer flags then\n+            Printf.fprintf chan \"0\"\n+          else\n+            Printf.fprintf chan \"1\"\n+      | Some f -> Printf.fprintf chan \"%s\" (string_of_int (f arg_number))\n+    else\n+      Printf.fprintf chan \"arg%d_%s\" arg_number ty\n+  in\n+  let rec print_args arg_number tys =\n+    match tys with\n+      [] -> ()\n+    | [ty] -> print_arg chan arg_number ty\n+    | ty::tys ->\n+      print_arg chan arg_number ty;\n+      Printf.fprintf chan \", \";\n+      print_args (arg_number + 1) tys\n+  in\n+    print_args 0 (List.tl c_types);\n+    Printf.fprintf chan \");\\n\"\n+\n+(* Emit epilogue code to a test source file.  *)\n+let emit_epilogue chan features regexps =\n+  let no_op = List.exists (fun feature -> feature = No_op) features in\n+    Printf.fprintf chan \"}\\n\\n\";\n+    (if not no_op then\n+       List.iter (fun regexp ->\n+                   Printf.fprintf chan\n+                     \"/* { dg-final { scan-assembler \\\"%s\\\" } } */\\n\" regexp)\n+                regexps\n+     else\n+       ()\n+    );\n+    Printf.fprintf chan \"/* { dg-final { cleanup-saved-temps } } */\\n\"\n+\n+(* Check a list of C types to determine which ones are pointers and which\n+   ones are const.  *)\n+let check_types tys =\n+  let tys' =\n+    List.map (fun ty ->\n+                let len = String.length ty in\n+                  if len > 2 && String.get ty (len - 2) = ' '\n+                             && String.get ty (len - 1) = '*'\n+                  then ([Pointer], String.sub ty 0 (len - 2))\n+                  else ([], ty)) tys\n+  in\n+    List.map (fun (flags, ty) ->\n+                if String.length ty > 6 && String.sub ty 0 6 = \"const \"\n+                then (Const :: flags, String.sub ty 6 ((String.length ty) - 6))\n+                else (flags, ty)) tys'\n+\n+(* Given an intrinsic shape, produce a regexp that will match\n+   the right-hand sides of instructions generated by an intrinsic of\n+   that shape.  *)\n+let rec analyze_shape shape =\n+  let rec n_things n thing =\n+    match n with\n+      0 -> []\n+    | n -> thing :: (n_things (n - 1) thing)\n+  in\n+  let rec analyze_shape_elt elt =\n+    match elt with\n+      Dreg -> \"\\\\[dD\\\\]\\\\[0-9\\\\]+\"\n+    | Qreg -> \"\\\\[qQ\\\\]\\\\[0-9\\\\]+\"\n+    | Corereg -> \"\\\\[rR\\\\]\\\\[0-9\\\\]+\"\n+    | Immed -> \"#\\\\[0-9\\\\]+\"\n+    | VecArray (1, elt) ->\n+        let elt_regexp = analyze_shape_elt elt in\n+          \"((\\\\\\\\\\\\{\" ^ elt_regexp ^ \"\\\\\\\\\\\\})|(\" ^ elt_regexp ^ \"))\"\n+    | VecArray (n, elt) ->\n+      let elt_regexp = analyze_shape_elt elt in\n+      let alt1 = elt_regexp ^ \"-\" ^ elt_regexp in\n+      let alt2 = commas (fun x -> x) (n_things n elt_regexp) \"\" in\n+        \"\\\\\\\\\\\\{((\" ^ alt1 ^ \")|(\" ^ alt2 ^ \"))\\\\\\\\\\\\}\"\n+    | (PtrTo elt | CstPtrTo elt) ->\n+      \"\\\\\\\\\\\\[\" ^ (analyze_shape_elt elt) ^ \"\\\\\\\\\\\\]\"\n+    | Element_of_dreg -> (analyze_shape_elt Dreg) ^ \"\\\\\\\\\\\\[\\\\[0-9\\\\]+\\\\\\\\\\\\]\"\n+    | Element_of_qreg -> (analyze_shape_elt Qreg) ^ \"\\\\\\\\\\\\[\\\\[0-9\\\\]+\\\\\\\\\\\\]\"\n+    | All_elements_of_dreg -> (analyze_shape_elt Dreg) ^ \"\\\\\\\\\\\\[\\\\\\\\\\\\]\"\n+  in\n+    match shape with\n+      All (n, elt) -> commas analyze_shape_elt (n_things n elt) \"\"\n+    | Long -> (analyze_shape_elt Qreg) ^ \", \" ^ (analyze_shape_elt Dreg) ^\n+              \", \" ^ (analyze_shape_elt Dreg)\n+    | Long_noreg elt -> (analyze_shape_elt elt) ^ \", \" ^ (analyze_shape_elt elt)\n+    | Wide -> (analyze_shape_elt Qreg) ^ \", \" ^ (analyze_shape_elt Qreg) ^\n+              \", \" ^ (analyze_shape_elt Dreg)\n+    | Wide_noreg elt -> analyze_shape (Long_noreg elt)\n+    | Narrow -> (analyze_shape_elt Dreg) ^ \", \" ^ (analyze_shape_elt Qreg) ^\n+                \", \" ^ (analyze_shape_elt Qreg)\n+    | Use_operands elts -> commas analyze_shape_elt (Array.to_list elts) \"\"\n+    | By_scalar Dreg ->\n+        analyze_shape (Use_operands [| Dreg; Dreg; Element_of_dreg |])\n+    | By_scalar Qreg ->\n+        analyze_shape (Use_operands [| Qreg; Qreg; Element_of_dreg |])\n+    | By_scalar _ -> assert false\n+    | Wide_lane ->\n+        analyze_shape (Use_operands [| Qreg; Dreg; Element_of_dreg |])\n+    | Wide_scalar ->\n+        analyze_shape (Use_operands [| Qreg; Dreg; Element_of_dreg |])\n+    | Pair_result elt ->\n+      let elt_regexp = analyze_shape_elt elt in\n+        elt_regexp ^ \", \" ^ elt_regexp\n+    | Unary_scalar _ -> \"FIXME Unary_scalar\"\n+    | Binary_imm elt -> analyze_shape (Use_operands [| elt; elt; Immed |])\n+    | Narrow_imm -> analyze_shape (Use_operands [| Dreg; Qreg; Immed |])\n+    | Long_imm -> analyze_shape (Use_operands [| Qreg; Dreg; Immed |])\n+\n+(* Generate tests for one intrinsic.  *)\n+let test_intrinsic dir opcode features shape name munge elt_ty =\n+  (* Open the test source file.  *)\n+  let test_name = name ^ (string_of_elt elt_ty) in\n+  let chan = open_test_file dir test_name in\n+  (* Work out what argument and return types the intrinsic has.  *)\n+  let c_arity, new_elt_ty = munge shape elt_ty in\n+  let c_types = check_types (strings_of_arity c_arity) in\n+  (* Extract any constant valuator (a function specifying what constant\n+     values are to be written into the intrinsic call) from the features\n+     list.  *)\n+  let const_valuator =\n+    try\n+      match (List.find (fun feature -> match feature with\n+                                         Const_valuator _ -> true\n+\t\t\t\t       | _ -> false) features) with\n+        Const_valuator f -> Some f\n+      | _ -> assert false\n+    with Not_found -> None\n+  in\n+  (* Work out what instruction name(s) to expect.  *)\n+  let insns = get_insn_names features name in\n+  let no_suffix = (new_elt_ty = NoElts) in\n+  let insns =\n+    if no_suffix then insns\n+                 else List.map (fun insn ->\n+                                  let suffix = string_of_elt_dots new_elt_ty in\n+                                    insn ^ \"\\\\.\" ^ suffix) insns\n+  in\n+  (* Construct a regexp to match against the expected instruction name(s).  *)\n+  let insn_regexp =\n+    match insns with\n+      [] -> assert false\n+    | [insn] -> insn\n+    | _ ->\n+      let rec calc_regexp insns cur_regexp =\n+        match insns with\n+          [] -> cur_regexp\n+        | [insn] -> cur_regexp ^ \"(\" ^ insn ^ \"))\"\n+        | insn::insns -> calc_regexp insns (cur_regexp ^ \"(\" ^ insn ^ \")|\")\n+      in calc_regexp insns \"(\"\n+  in\n+  (* Construct regexps to match against the instructions that this\n+     intrinsic expands to.  Watch out for any writeback character and\n+     comments after the instruction.  *)\n+  let regexps = List.map (fun regexp -> insn_regexp ^ \"\\\\[ \\t\\\\]+\" ^ regexp ^\n+\t\t\t  \"!?\\\\(\\\\[ \\t\\\\]+@\\\\[a-zA-Z0-9 \\\\]+\\\\)?\\\\n\")\n+                         (analyze_all_shapes features shape analyze_shape)\n+  in\n+    (* Emit file and function prologues.  *)\n+    emit_prologue chan test_name;\n+    (* Emit local variable declarations.  *)\n+    emit_automatics chan c_types;\n+    Printf.fprintf chan \"\\n\";\n+    (* Emit the call to the intrinsic.  *)\n+    emit_call chan const_valuator c_types name elt_ty;\n+    (* Emit the function epilogue and the DejaGNU scan-assembler directives.  *)\n+    emit_epilogue chan features regexps;\n+    (* Close the test file.  *)\n+    close_out chan\n+\n+(* Generate tests for one element of the \"ops\" table.  *)\n+let test_intrinsic_group dir (opcode, features, shape, name, munge, types) =\n+  List.iter (test_intrinsic dir opcode features shape name munge) types\n+\n+(* Program entry point.  *)\n+let _ =\n+  let directory = if Array.length Sys.argv <> 1 then Sys.argv.(1) else \".\" in\n+    List.iter (test_intrinsic_group directory) (reinterp @ ops)\n+"}, {"sha": "48b4e2a2c94c2d13b89f024ee8435a606162c7dd", "filename": "gcc/config/arm/neon.md", "status": "added", "additions": 3948, "deletions": 0, "changes": 3948, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Fconfig%2Farm%2Fneon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Fconfig%2Farm%2Fneon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.md?ref=88f77cba027fa1be471081bcd2ec03392246af3a"}, {"sha": "59f6cc98579a5bae220b7f87bf50272027ed59a2", "filename": "gcc/config/arm/neon.ml", "status": "added", "additions": 1826, "deletions": 0, "changes": 1826, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Fconfig%2Farm%2Fneon.ml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Fconfig%2Farm%2Fneon.ml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.ml?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,1826 @@\n+(* Common code for ARM NEON header file, documentation and test case\n+   generators.\n+\n+   Copyright (C) 2006 Free Software Foundation, Inc.\n+   Contributed by CodeSourcery.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 2, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+   02110-1301, USA.  *)\n+\n+(* Shorthand types for vector elements.  *)\n+type elts = S8 | S16 | S32 | S64 | F32 | U8 | U16 | U32 | U64 | P8 | P16\n+          | I8 | I16 | I32 | I64 | B8 | B16 | B32 | B64 | Conv of elts * elts\n+          | Cast of elts * elts | NoElts\n+\n+type eltclass = Signed | Unsigned | Float | Poly | Int | Bits\n+\t      | ConvClass of eltclass * eltclass | NoType\n+\n+(* These vector types correspond directly to C types.  *)\n+type vectype = T_int8x8    | T_int8x16\n+             | T_int16x4   | T_int16x8\n+\t     | T_int32x2   | T_int32x4\n+\t     | T_int64x1   | T_int64x2\n+\t     | T_uint8x8   | T_uint8x16\n+\t     | T_uint16x4  | T_uint16x8\n+\t     | T_uint32x2  | T_uint32x4\n+\t     | T_uint64x1  | T_uint64x2\n+\t     | T_float32x2 | T_float32x4\n+\t     | T_poly8x8   | T_poly8x16\n+\t     | T_poly16x4  | T_poly16x8\n+\t     | T_immediate of int * int\n+             | T_int8      | T_int16\n+             | T_int32     | T_int64\n+             | T_uint8     | T_uint16\n+             | T_uint32    | T_uint64\n+             | T_poly8     | T_poly16\n+             | T_float32   | T_arrayof of int * vectype\n+             | T_ptrto of vectype | T_const of vectype\n+             | T_void      | T_intQI\n+             | T_intHI     | T_intSI\n+             | T_intDI\n+\n+(* The meanings of the following are:\n+     TImode : \"Tetra\", two registers (four words).\n+     EImode : \"hExa\", three registers (six words).\n+     OImode : \"Octa\", four registers (eight words).\n+     CImode : \"dodeCa\", six registers (twelve words).\n+     XImode : \"heXadeca\", eight registers (sixteen words).\n+*)\n+\n+type inttype = B_TImode | B_EImode | B_OImode | B_CImode | B_XImode\n+\n+type shape_elt = Dreg | Qreg | Corereg | Immed | VecArray of int * shape_elt\n+               | PtrTo of shape_elt | CstPtrTo of shape_elt\n+\t       (* These next ones are used only in the test generator.  *)\n+\t       | Element_of_dreg\t(* Used for \"lane\" variants.  *)\n+\t       | Element_of_qreg\t(* Likewise.  *)\n+\t       | All_elements_of_dreg\t(* Used for \"dup\" variants.  *)\n+\n+type shape_form = All of int * shape_elt\n+                | Long\n+\t\t| Long_noreg of shape_elt\n+\t\t| Wide\n+\t\t| Wide_noreg of shape_elt\n+\t\t| Narrow\n+                | Long_imm\n+                | Narrow_imm\n+                | Binary_imm of shape_elt\n+                | Use_operands of shape_elt array\n+                | By_scalar of shape_elt\n+                | Unary_scalar of shape_elt\n+                | Wide_lane\n+                | Wide_scalar\n+                | Pair_result of shape_elt\n+\n+type arity = Arity0 of vectype\n+           | Arity1 of vectype * vectype\n+\t   | Arity2 of vectype * vectype * vectype\n+\t   | Arity3 of vectype * vectype * vectype * vectype\n+           | Arity4 of vectype * vectype * vectype * vectype * vectype\n+\n+type vecmode = V8QI | V4HI | V2SI | V2SF | DI\n+             | V16QI | V8HI | V4SI | V4SF | V2DI\n+             | QI | HI | SI | SF\n+\n+type opcode =\n+  (* Binary ops.  *)\n+    Vadd\n+  | Vmul\n+  | Vmla\n+  | Vmls\n+  | Vsub\n+  | Vceq\n+  | Vcge\n+  | Vcgt\n+  | Vcle\n+  | Vclt\n+  | Vcage\n+  | Vcagt\n+  | Vcale\n+  | Vcalt\n+  | Vtst\n+  | Vabd\n+  | Vaba\n+  | Vmax\n+  | Vmin\n+  | Vpadd\n+  | Vpada\n+  | Vpmax\n+  | Vpmin\n+  | Vrecps\n+  | Vrsqrts\n+  | Vshl\n+  | Vshr_n\n+  | Vshl_n\n+  | Vsra_n\n+  | Vsri\n+  | Vsli\n+  (* Logic binops.  *)\n+  | Vand\n+  | Vorr\n+  | Veor\n+  | Vbic\n+  | Vorn\n+  | Vbsl\n+  (* Ops with scalar.  *)\n+  | Vmul_lane\n+  | Vmla_lane\n+  | Vmls_lane\n+  | Vmul_n\n+  | Vmla_n\n+  | Vmls_n\n+  | Vmull_n\n+  | Vmull_lane\n+  | Vqdmull_n\n+  | Vqdmull_lane\n+  | Vqdmulh_n\n+  | Vqdmulh_lane\n+  (* Unary ops.  *)\n+  | Vabs\n+  | Vneg\n+  | Vcls\n+  | Vclz\n+  | Vcnt\n+  | Vrecpe\n+  | Vrsqrte\n+  | Vmvn\n+  (* Vector extract.  *)\n+  | Vext\n+  (* Reverse elements.  *)\n+  | Vrev64\n+  | Vrev32\n+  | Vrev16\n+  (* Transposition ops.  *)\n+  | Vtrn\n+  | Vzip\n+  | Vuzp\n+  (* Loads and stores (VLD1/VST1/VLD2...), elements and structures.  *)\n+  | Vldx of int\n+  | Vstx of int\n+  | Vldx_lane of int\n+  | Vldx_dup of int\n+  | Vstx_lane of int\n+  (* Set/extract lanes from a vector.  *)\n+  | Vget_lane\n+  | Vset_lane\n+  (* Initialise vector from bit pattern.  *)\n+  | Vcreate\n+  (* Set all lanes to same value.  *)\n+  | Vdup_n\n+  | Vmov_n  (* Is this the same?  *)\n+  (* Duplicate scalar to all lanes of vector.  *)\n+  | Vdup_lane\n+  (* Combine vectors.  *)\n+  | Vcombine\n+  (* Get quadword high/low parts.  *)\n+  | Vget_high\n+  | Vget_low\n+  (* Convert vectors.  *)\n+  | Vcvt\n+  | Vcvt_n\n+  (* Narrow/lengthen vectors.  *)\n+  | Vmovn\n+  | Vmovl\n+  (* Table lookup.  *)\n+  | Vtbl of int\n+  | Vtbx of int\n+  (* Reinterpret casts.  *)\n+  | Vreinterp\n+\n+(* Features used for documentation, to distinguish between some instruction\n+   variants, and to signal special requirements (e.g. swapping arguments).  *)\n+\n+type features =\n+    Halving\n+  | Rounding\n+  | Saturating\n+  | Dst_unsign\n+  | High_half\n+  | Doubling\n+  | Flipped of string  (* Builtin name to use with flipped arguments.  *)\n+  | InfoWord  (* Pass an extra word for signage/rounding etc. (always passed\n+                 for All _, Long, Wide, Narrow shape_forms.  *)\n+  | ReturnPtr  (* Pass explicit pointer to return value as first argument.  *)\n+    (* A specification as to the shape of instruction expected upon\n+       disassembly, used if it differs from the shape used to build the\n+       intrinsic prototype.  Multiple entries in the constructor's argument\n+       indicate that the intrinsic expands to more than one assembly\n+       instruction, each with a corresponding shape specified here.  *)\n+  | Disassembles_as of shape_form list\n+  | Builtin_name of string  (* Override the name of the builtin.  *)\n+    (* Override the name of the instruction.  If more than one name\n+       is specified, it means that the instruction can have any of those\n+       names.  *)\n+  | Instruction_name of string list\n+    (* Mark that the intrinsic yields no instructions, or expands to yield\n+       behaviour that the test generator cannot test.  *)\n+  | No_op\n+    (* Mark that the intrinsic has constant arguments that cannot be set\n+       to the defaults (zero for pointers and one otherwise) in the test\n+       cases.  The function supplied must return the integer to be written\n+       into the testcase for the argument number (0-based) supplied to it.  *)\n+  | Const_valuator of (int -> int)\n+\n+exception MixedMode of elts * elts\n+\n+let rec elt_width = function\n+    S8 | U8 | P8 | I8 | B8 -> 8\n+  | S16 | U16 | P16 | I16 | B16 -> 16\n+  | S32 | F32 | U32 | I32 | B32 -> 32\n+  | S64 | U64 | I64 | B64 -> 64\n+  | Conv (a, b) ->\n+      let wa = elt_width a and wb = elt_width b in\n+      if wa = wb then wa else failwith \"element width?\"\n+  | Cast (a, b) -> raise (MixedMode (a, b))\n+  | NoElts -> failwith \"No elts\"\n+\n+let rec elt_class = function\n+    S8 | S16 | S32 | S64 -> Signed\n+  | U8 | U16 | U32 | U64 -> Unsigned\n+  | P8 | P16 -> Poly\n+  | F32 -> Float\n+  | I8 | I16 | I32 | I64 -> Int\n+  | B8 | B16 | B32 | B64 -> Bits\n+  | Conv (a, b) | Cast (a, b) -> ConvClass (elt_class a, elt_class b)\n+  | NoElts -> NoType\n+\n+let elt_of_class_width c w =\n+  match c, w with\n+    Signed, 8 -> S8\n+  | Signed, 16 -> S16\n+  | Signed, 32 -> S32\n+  | Signed, 64 -> S64\n+  | Float, 32 -> F32\n+  | Unsigned, 8 -> U8\n+  | Unsigned, 16 -> U16\n+  | Unsigned, 32 -> U32\n+  | Unsigned, 64 -> U64\n+  | Poly, 8 -> P8\n+  | Poly, 16 -> P16\n+  | Int, 8 -> I8\n+  | Int, 16 -> I16\n+  | Int, 32 -> I32\n+  | Int, 64 -> I64\n+  | Bits, 8 -> B8\n+  | Bits, 16 -> B16\n+  | Bits, 32 -> B32\n+  | Bits, 64 -> B64\n+  | _ -> failwith \"Bad element type\"\n+\n+(* Return unsigned integer element the same width as argument.  *)\n+let unsigned_of_elt elt =\n+  elt_of_class_width Unsigned (elt_width elt)\n+\n+let signed_of_elt elt =\n+  elt_of_class_width Signed (elt_width elt)\n+\n+(* Return untyped bits element the same width as argument.  *)\n+let bits_of_elt elt =\n+  elt_of_class_width Bits (elt_width elt)\n+\n+let non_signed_variant = function\n+    S8 -> I8\n+  | S16 -> I16\n+  | S32 -> I32\n+  | S64 -> I64\n+  | U8 -> I8\n+  | U16 -> I16\n+  | U32 -> I32\n+  | U64 -> I64\n+  | x -> x\n+\n+let poly_unsigned_variant v =\n+  let elclass = match elt_class v with\n+    Poly -> Unsigned\n+  | x -> x in\n+  elt_of_class_width elclass (elt_width v)\n+\n+let widen_elt elt =\n+  let w = elt_width elt\n+  and c = elt_class elt in\n+  elt_of_class_width c (w * 2)\n+\n+let narrow_elt elt =\n+  let w = elt_width elt\n+  and c = elt_class elt in\n+  elt_of_class_width c (w / 2)\n+\n+(* If we're trying to find a mode from a \"Use_operands\" instruction, use the\n+   last vector operand as the dominant mode used to invoke the correct builtin.\n+   We must stick to this rule in neon.md.  *)\n+let find_key_operand operands =\n+  let rec scan opno =\n+    match operands.(opno) with\n+      Qreg -> Qreg\n+    | Dreg -> Dreg\n+    | VecArray (_, Qreg) -> Qreg\n+    | VecArray (_, Dreg) -> Dreg\n+    | _ -> scan (opno-1)\n+  in\n+    scan ((Array.length operands) - 1)\n+\n+let rec mode_of_elt elt shape =\n+  let flt = match elt_class elt with\n+    Float | ConvClass(_, Float) -> true | _ -> false in\n+  let idx =\n+    match elt_width elt with\n+      8 -> 0 | 16 -> 1 | 32 -> 2 | 64 -> 3\n+    | _ -> failwith \"Bad element width\"\n+  in match shape with\n+    All (_, Dreg) | By_scalar Dreg | Pair_result Dreg | Unary_scalar Dreg\n+  | Binary_imm Dreg | Long_noreg Dreg | Wide_noreg Dreg ->\n+      [| V8QI; V4HI; if flt then V2SF else V2SI; DI |].(idx)\n+  | All (_, Qreg) | By_scalar Qreg | Pair_result Qreg | Unary_scalar Qreg\n+  | Binary_imm Qreg | Long_noreg Qreg | Wide_noreg Qreg ->\n+      [| V16QI; V8HI; if flt then V4SF else V4SI; V2DI |].(idx)\n+  | All (_, (Corereg | PtrTo _ | CstPtrTo _)) ->\n+      [| QI; HI; if flt then SF else SI; DI |].(idx)\n+  | Long | Wide | Wide_lane | Wide_scalar\n+  | Long_imm ->\n+      [| V8QI; V4HI; V2SI; DI |].(idx)\n+  | Narrow | Narrow_imm -> [| V16QI; V8HI; V4SI; V2DI |].(idx)\n+  | Use_operands ops -> mode_of_elt elt (All (0, (find_key_operand ops)))\n+  | _ -> failwith \"invalid shape\"\n+\n+(* Modify an element type dependent on the shape of the instruction and the\n+   operand number.  *)\n+\n+let shapemap shape no =\n+  let ident = fun x -> x in\n+  match shape with\n+    All _ | Use_operands _ | By_scalar _ | Pair_result _ | Unary_scalar _\n+  | Binary_imm _ -> ident\n+  | Long | Long_noreg _ | Wide_scalar | Long_imm ->\n+      [| widen_elt; ident; ident |].(no)\n+  | Wide | Wide_noreg _ -> [| widen_elt; widen_elt; ident |].(no)\n+  | Wide_lane -> [| widen_elt; ident; ident; ident |].(no)\n+  | Narrow | Narrow_imm -> [| narrow_elt; ident; ident |].(no)\n+\n+(* Register type (D/Q) of an operand, based on shape and operand number.  *)\n+\n+let regmap shape no =\n+  match shape with\n+    All (_, reg) | Long_noreg reg | Wide_noreg reg -> reg\n+  | Long -> [| Qreg; Dreg; Dreg |].(no)\n+  | Wide -> [| Qreg; Qreg; Dreg |].(no)\n+  | Narrow -> [| Dreg; Qreg; Qreg |].(no)\n+  | Wide_lane -> [| Qreg; Dreg; Dreg; Immed |].(no)\n+  | Wide_scalar -> [| Qreg; Dreg; Corereg |].(no)\n+  | By_scalar reg -> [| reg; reg; Dreg; Immed |].(no)\n+  | Unary_scalar reg -> [| reg; Dreg; Immed |].(no)\n+  | Pair_result reg -> [| VecArray (2, reg); reg; reg |].(no)\n+  | Binary_imm reg -> [| reg; reg; Immed |].(no)\n+  | Long_imm -> [| Qreg; Dreg; Immed |].(no)\n+  | Narrow_imm -> [| Dreg; Qreg; Immed |].(no)\n+  | Use_operands these -> these.(no)\n+\n+let type_for_elt shape elt no =\n+  let elt = (shapemap shape no) elt in\n+  let reg = regmap shape no in\n+  let rec type_for_reg_elt reg elt =\n+    match reg with\n+      Dreg ->\n+        begin match elt with\n+          S8 -> T_int8x8\n+        | S16 -> T_int16x4\n+        | S32 -> T_int32x2\n+        | S64 -> T_int64x1\n+        | U8 -> T_uint8x8\n+        | U16 -> T_uint16x4\n+        | U32 -> T_uint32x2\n+        | U64 -> T_uint64x1\n+        | F32 -> T_float32x2\n+        | P8 -> T_poly8x8\n+        | P16 -> T_poly16x4\n+        | _ -> failwith \"Bad elt type\"\n+        end\n+    | Qreg ->\n+        begin match elt with\n+          S8 -> T_int8x16\n+        | S16 -> T_int16x8\n+        | S32 -> T_int32x4\n+        | S64 -> T_int64x2\n+        | U8 -> T_uint8x16\n+        | U16 -> T_uint16x8\n+        | U32 -> T_uint32x4\n+        | U64 -> T_uint64x2\n+        | F32 -> T_float32x4\n+        | P8 -> T_poly8x16\n+        | P16 -> T_poly16x8\n+        | _ -> failwith \"Bad elt type\"\n+        end\n+    | Corereg ->\n+        begin match elt with\n+          S8 -> T_int8\n+        | S16 -> T_int16\n+        | S32 -> T_int32\n+        | S64 -> T_int64\n+        | U8 -> T_uint8\n+        | U16 -> T_uint16\n+        | U32 -> T_uint32\n+        | U64 -> T_uint64\n+        | P8 -> T_poly8\n+        | P16 -> T_poly16\n+        | F32 -> T_float32\n+        | _ -> failwith \"Bad elt type\"\n+        end\n+    | Immed ->\n+        T_immediate (0, 0)\n+    | VecArray (num, sub) ->\n+        T_arrayof (num, type_for_reg_elt sub elt)\n+    | PtrTo x ->\n+        T_ptrto (type_for_reg_elt x elt)\n+    | CstPtrTo x ->\n+        T_ptrto (T_const (type_for_reg_elt x elt))\n+    (* Anything else is solely for the use of the test generator.  *)\n+    | _ -> assert false\n+  in\n+    type_for_reg_elt reg elt\n+\n+(* Return size of a vector type, in bits.  *)\n+let vectype_size = function\n+    T_int8x8 | T_int16x4 | T_int32x2 | T_int64x1\n+  | T_uint8x8 | T_uint16x4 | T_uint32x2 | T_uint64x1\n+  | T_float32x2 | T_poly8x8 | T_poly16x4 -> 64\n+  | T_int8x16 | T_int16x8 | T_int32x4 | T_int64x2\n+  | T_uint8x16 | T_uint16x8  | T_uint32x4  | T_uint64x2\n+  | T_float32x4 | T_poly8x16 | T_poly16x8 -> 128\n+  | _ -> raise Not_found\n+\n+let inttype_for_array num elttype =\n+  let eltsize = vectype_size elttype in\n+  let numwords = (num * eltsize) / 32 in\n+  match numwords with\n+    4 -> B_TImode\n+  | 6 -> B_EImode\n+  | 8 -> B_OImode\n+  | 12 -> B_CImode\n+  | 16 -> B_XImode\n+  | _ -> failwith (\"no int type for size \" ^ string_of_int numwords)\n+\n+(* These functions return pairs of (internal, external) types, where \"internal\"\n+   types are those seen by GCC, and \"external\" are those seen by the assembler.\n+   These types aren't necessarily the same, since the intrinsics can munge more\n+   than one C type into each assembler opcode.  *)\n+\n+let make_sign_invariant func shape elt =\n+  let arity, elt' = func shape elt in\n+  arity, non_signed_variant elt'\n+\n+(* Don't restrict any types.  *)\n+\n+let elts_same make_arity shape elt =\n+  let vtype = type_for_elt shape elt in\n+  make_arity vtype, elt\n+\n+(* As sign_invar_*, but when sign matters.  *)\n+let elts_same_io_lane =\n+  elts_same (fun vtype -> Arity4 (vtype 0, vtype 0, vtype 1, vtype 2, vtype 3))\n+\n+let elts_same_io =\n+  elts_same (fun vtype -> Arity3 (vtype 0, vtype 0, vtype 1, vtype 2))\n+\n+let elts_same_2_lane =\n+  elts_same (fun vtype -> Arity3 (vtype 0, vtype 1, vtype 2, vtype 3))\n+\n+let elts_same_3 = elts_same_2_lane\n+\n+let elts_same_2 =\n+  elts_same (fun vtype -> Arity2 (vtype 0, vtype 1, vtype 2))\n+\n+let elts_same_1 =\n+  elts_same (fun vtype -> Arity1 (vtype 0, vtype 1))\n+\n+(* Use for signed/unsigned invariant operations (i.e. where the operation\n+   doesn't depend on the sign of the data.  *)\n+\n+let sign_invar_io_lane = make_sign_invariant elts_same_io_lane\n+let sign_invar_io = make_sign_invariant elts_same_io\n+let sign_invar_2_lane = make_sign_invariant elts_same_2_lane\n+let sign_invar_2 = make_sign_invariant elts_same_2\n+let sign_invar_1 = make_sign_invariant elts_same_1\n+\n+(* Sign-sensitive comparison.  *)\n+\n+let cmp_sign_matters shape elt =\n+  let vtype = type_for_elt shape elt\n+  and rtype = type_for_elt shape (unsigned_of_elt elt) 0 in\n+  Arity2 (rtype, vtype 1, vtype 2), elt\n+\n+(* Signed/unsigned invariant comparison.  *)\n+\n+let cmp_sign_invar shape elt =\n+  let shape', elt' = cmp_sign_matters shape elt in\n+  let elt'' =\n+    match non_signed_variant elt' with\n+      P8 -> I8\n+    | x -> x\n+  in\n+    shape', elt''\n+\n+(* Comparison (VTST) where only the element width matters.  *)\n+\n+let cmp_bits shape elt =\n+  let vtype = type_for_elt shape elt\n+  and rtype = type_for_elt shape (unsigned_of_elt elt) 0\n+  and bits_only = bits_of_elt elt in\n+  Arity2 (rtype, vtype 1, vtype 2), bits_only\n+\n+let reg_shift shape elt =\n+  let vtype = type_for_elt shape elt\n+  and op2type = type_for_elt shape (signed_of_elt elt) 2 in\n+  Arity2 (vtype 0, vtype 1, op2type), elt\n+\n+(* Genericised constant-shift type-generating function.  *)\n+\n+let const_shift mkimm ?arity ?result shape elt =\n+  let op2type = (shapemap shape 2) elt in\n+  let op2width = elt_width op2type in\n+  let op2 = mkimm op2width\n+  and op1 = type_for_elt shape elt 1\n+  and r_elt =\n+    match result with\n+      None -> elt\n+    | Some restriction -> restriction elt in\n+  let rtype = type_for_elt shape r_elt 0 in\n+  match arity with\n+    None -> Arity2 (rtype, op1, op2), elt\n+  | Some mkarity -> mkarity rtype op1 op2, elt\n+\n+(* Use for immediate right-shifts.  *)\n+\n+let shift_right shape elt =\n+  const_shift (fun imm -> T_immediate (1, imm)) shape elt\n+\n+let shift_right_acc shape elt =\n+  const_shift (fun imm -> T_immediate (1, imm))\n+    ~arity:(fun dst op1 op2 -> Arity3 (dst, dst, op1, op2)) shape elt\n+\n+(* Use for immediate right-shifts when the operation doesn't care about\n+   signedness.  *)\n+\n+let shift_right_sign_invar =\n+  make_sign_invariant shift_right\n+\n+(* Immediate right-shift; result is unsigned even when operand is signed.  *)\n+\n+let shift_right_to_uns shape elt =\n+  const_shift (fun imm -> T_immediate (1, imm)) ~result:unsigned_of_elt\n+    shape elt\n+\n+(* Immediate left-shift.  *)\n+\n+let shift_left shape elt =\n+  const_shift (fun imm -> T_immediate (0, imm - 1)) shape elt\n+\n+(* Immediate left-shift, unsigned result.  *)\n+\n+let shift_left_to_uns shape elt =\n+  const_shift (fun imm -> T_immediate (0, imm - 1)) ~result:unsigned_of_elt\n+    shape elt\n+\n+(* Immediate left-shift, don't care about signs.  *)\n+\n+let shift_left_sign_invar =\n+  make_sign_invariant shift_left\n+\n+(* Shift left/right and insert: only element size matters.  *)\n+\n+let shift_insert shape elt =\n+  let arity, elt =\n+    const_shift (fun imm -> T_immediate (1, imm))\n+    ~arity:(fun dst op1 op2 -> Arity3 (dst, dst, op1, op2)) shape elt in\n+  arity, bits_of_elt elt\n+\n+(* Get/set lane.  *)\n+\n+let get_lane shape elt =\n+  let vtype = type_for_elt shape elt in\n+  Arity2 (vtype 0, vtype 1, vtype 2),\n+    (match elt with P8 -> U8 | P16 -> U16 | x -> x)\n+\n+let set_lane shape elt =\n+  let vtype = type_for_elt shape elt in\n+  Arity3 (vtype 0, vtype 1, vtype 2, vtype 3), bits_of_elt elt\n+\n+let set_lane_notype shape elt =\n+  let vtype = type_for_elt shape elt in\n+  Arity3 (vtype 0, vtype 1, vtype 2, vtype 3), NoElts\n+\n+let create_vector shape elt =\n+  let vtype = type_for_elt shape U64 1\n+  and rtype = type_for_elt shape elt 0 in\n+  Arity1 (rtype, vtype), elt\n+\n+let conv make_arity shape elt =\n+  let edest, esrc = match elt with\n+    Conv (edest, esrc) | Cast (edest, esrc) -> edest, esrc\n+  | _ -> failwith \"Non-conversion element in conversion\" in\n+  let vtype = type_for_elt shape esrc\n+  and rtype = type_for_elt shape edest 0 in\n+  make_arity rtype vtype, elt\n+\n+let conv_1 = conv (fun rtype vtype -> Arity1 (rtype, vtype 1))\n+let conv_2 = conv (fun rtype vtype -> Arity2 (rtype, vtype 1, vtype 2))\n+\n+(* Operation has an unsigned result even if operands are signed.  *)\n+\n+let dst_unsign make_arity shape elt =\n+  let vtype = type_for_elt shape elt\n+  and rtype = type_for_elt shape (unsigned_of_elt elt) 0 in\n+  make_arity rtype vtype, elt\n+\n+let dst_unsign_1 = dst_unsign (fun rtype vtype -> Arity1 (rtype, vtype 1))\n+\n+let make_bits_only func shape elt =\n+  let arity, elt' = func shape elt in\n+  arity, bits_of_elt elt'\n+\n+(* Extend operation.  *)\n+\n+let extend shape elt =\n+  let vtype = type_for_elt shape elt in\n+  Arity3 (vtype 0, vtype 1, vtype 2, vtype 3), bits_of_elt elt\n+\n+(* Table look-up operations. Operand 2 is signed/unsigned for signed/unsigned\n+   integer ops respectively, or unsigned for polynomial ops.  *)\n+\n+let table mkarity shape elt =\n+  let vtype = type_for_elt shape elt in\n+  let op2 = type_for_elt shape (poly_unsigned_variant elt) 2 in\n+  mkarity vtype op2, bits_of_elt elt\n+\n+let table_2 = table (fun vtype op2 -> Arity2 (vtype 0, vtype 1, op2))\n+let table_io = table (fun vtype op2 -> Arity3 (vtype 0, vtype 0, vtype 1, op2))\n+\n+(* Operations where only bits matter.  *)\n+\n+let bits_1 = make_bits_only elts_same_1\n+let bits_2 = make_bits_only elts_same_2\n+let bits_3 = make_bits_only elts_same_3\n+\n+(* Store insns.  *)\n+let store_1 shape elt =\n+  let vtype = type_for_elt shape elt in\n+  Arity2 (T_void, vtype 0, vtype 1), bits_of_elt elt\n+\n+let store_3 shape elt =\n+  let vtype = type_for_elt shape elt in\n+  Arity3 (T_void, vtype 0, vtype 1, vtype 2), bits_of_elt elt\n+\n+let make_notype func shape elt =\n+  let arity, _ = func shape elt in\n+  arity, NoElts\n+\n+let notype_1 = make_notype elts_same_1\n+let notype_2 = make_notype elts_same_2\n+let notype_3 = make_notype elts_same_3\n+\n+(* Bit-select operations (first operand is unsigned int).  *)\n+\n+let bit_select shape elt =\n+  let vtype = type_for_elt shape elt\n+  and itype = type_for_elt shape (unsigned_of_elt elt) in\n+  Arity3 (vtype 0, itype 1, vtype 2, vtype 3), NoElts\n+\n+(* Common lists of supported element types.  *)\n+\n+let su_8_32 = [S8; S16; S32; U8; U16; U32]\n+let su_8_64 = S64 :: U64 :: su_8_32\n+let su_16_64 = [S16; S32; S64; U16; U32; U64]\n+let pf_su_8_32 = P8 :: P16 :: F32 :: su_8_32\n+let pf_su_8_64 = P8 :: P16 :: F32 :: su_8_64\n+\n+let ops =\n+  [\n+    (* Addition.  *)\n+    Vadd, [], All (3, Dreg), \"vadd\", sign_invar_2, F32 :: su_8_64;\n+    Vadd, [], All (3, Qreg), \"vaddQ\", sign_invar_2, F32 :: su_8_64;\n+    Vadd, [], Long, \"vaddl\", elts_same_2, su_8_32;\n+    Vadd, [], Wide, \"vaddw\", elts_same_2, su_8_32;\n+    Vadd, [Halving], All (3, Dreg), \"vhadd\", elts_same_2, su_8_32;\n+    Vadd, [Halving], All (3, Qreg), \"vhaddQ\", elts_same_2, su_8_32;\n+    Vadd, [Instruction_name [\"vrhadd\"]; Rounding; Halving],\n+      All (3, Dreg), \"vRhadd\", elts_same_2, su_8_32;\n+    Vadd, [Instruction_name [\"vrhadd\"]; Rounding; Halving],\n+      All (3, Qreg), \"vRhaddQ\", elts_same_2, su_8_32;\n+    Vadd, [Saturating], All (3, Dreg), \"vqadd\", elts_same_2, su_8_64;\n+    Vadd, [Saturating], All (3, Qreg), \"vqaddQ\", elts_same_2, su_8_64;\n+    Vadd, [High_half], Narrow, \"vaddhn\", sign_invar_2, su_16_64;\n+    Vadd, [Instruction_name [\"vraddhn\"]; Rounding; High_half],\n+      Narrow, \"vRaddhn\", sign_invar_2, su_16_64;\n+\n+    (* Multiplication.  *)\n+    Vmul, [], All (3, Dreg), \"vmul\", sign_invar_2, P8 :: F32 :: su_8_32;\n+    Vmul, [], All (3, Qreg), \"vmulQ\", sign_invar_2, P8 :: F32 :: su_8_32;\n+    Vmul, [Saturating; Doubling; High_half], All (3, Dreg), \"vqdmulh\",\n+      elts_same_2, [S16; S32];\n+    Vmul, [Saturating; Doubling; High_half], All (3, Qreg), \"vqdmulhQ\",\n+      elts_same_2, [S16; S32];\n+    Vmul,\n+      [Saturating; Rounding; Doubling; High_half;\n+       Instruction_name [\"vqrdmulh\"]],\n+      All (3, Dreg), \"vqRdmulh\",\n+      elts_same_2, [S16; S32];\n+    Vmul,\n+      [Saturating; Rounding; Doubling; High_half;\n+       Instruction_name [\"vqrdmulh\"]],\n+      All (3, Qreg), \"vqRdmulhQ\",\n+      elts_same_2, [S16; S32];\n+    Vmul, [], Long, \"vmull\", elts_same_2, P8 :: su_8_32;\n+    Vmul, [Saturating; Doubling], Long, \"vqdmull\", elts_same_2, [S16; S32];\n+\n+    (* Multiply-accumulate. *)\n+    Vmla, [], All (3, Dreg), \"vmla\", sign_invar_io, F32 :: su_8_32;\n+    Vmla, [], All (3, Qreg), \"vmlaQ\", sign_invar_io, F32 :: su_8_32;\n+    Vmla, [], Long, \"vmlal\", elts_same_io, su_8_32;\n+    Vmla, [Saturating; Doubling], Long, \"vqdmlal\", elts_same_io, [S16; S32];\n+\n+    (* Multiply-subtract.  *)\n+    Vmls, [], All (3, Dreg), \"vmls\", sign_invar_io, F32 :: su_8_32;\n+    Vmls, [], All (3, Qreg), \"vmlsQ\", sign_invar_io, F32 :: su_8_32;\n+    Vmls, [], Long, \"vmlsl\", elts_same_io, su_8_32;\n+    Vmls, [Saturating; Doubling], Long, \"vqdmlsl\", elts_same_io, [S16; S32];\n+\n+    (* Subtraction.  *)\n+    Vsub, [], All (3, Dreg), \"vsub\", sign_invar_2, F32 :: su_8_64;\n+    Vsub, [], All (3, Qreg), \"vsubQ\", sign_invar_2, F32 :: su_8_64;\n+    Vsub, [], Long, \"vsubl\", elts_same_2, su_8_32;\n+    Vsub, [], Wide, \"vsubw\", elts_same_2, su_8_32;\n+    Vsub, [Halving], All (3, Dreg), \"vhsub\", elts_same_2, su_8_32;\n+    Vsub, [Halving], All (3, Qreg), \"vhsubQ\", elts_same_2, su_8_32;\n+    Vsub, [Saturating], All (3, Dreg), \"vqsub\", elts_same_2, su_8_64;\n+    Vsub, [Saturating], All (3, Qreg), \"vqsubQ\", elts_same_2, su_8_64;\n+    Vsub, [High_half], Narrow, \"vsubhn\", sign_invar_2, su_16_64;\n+    Vsub, [Instruction_name [\"vrsubhn\"]; Rounding; High_half],\n+      Narrow, \"vRsubhn\", sign_invar_2, su_16_64;\n+\n+    (* Comparison, equal.  *)\n+    Vceq, [], All (3, Dreg), \"vceq\", cmp_sign_invar, P8 :: F32 :: su_8_32;\n+    Vceq, [], All (3, Qreg), \"vceqQ\", cmp_sign_invar, P8 :: F32 :: su_8_32;\n+\n+    (* Comparison, greater-than or equal.  *)\n+    Vcge, [], All (3, Dreg), \"vcge\", cmp_sign_matters, F32 :: su_8_32;\n+    Vcge, [], All (3, Qreg), \"vcgeQ\", cmp_sign_matters, F32 :: su_8_32;\n+\n+    (* Comparison, less-than or equal.  *)\n+    Vcle, [Flipped \"vcge\"], All (3, Dreg), \"vcle\", cmp_sign_matters,\n+      F32 :: su_8_32;\n+    Vcle, [Instruction_name [\"vcge\"]; Flipped \"vcgeQ\"],\n+      All (3, Qreg), \"vcleQ\", cmp_sign_matters,\n+      F32 :: su_8_32;\n+\n+    (* Comparison, greater-than.  *)\n+    Vcgt, [], All (3, Dreg), \"vcgt\", cmp_sign_matters, F32 :: su_8_32;\n+    Vcgt, [], All (3, Qreg), \"vcgtQ\", cmp_sign_matters, F32 :: su_8_32;\n+\n+    (* Comparison, less-than.  *)\n+    Vclt, [Flipped \"vcgt\"], All (3, Dreg), \"vclt\", cmp_sign_matters,\n+      F32 :: su_8_32;\n+    Vclt, [Instruction_name [\"vcgt\"]; Flipped \"vcgtQ\"],\n+      All (3, Qreg), \"vcltQ\", cmp_sign_matters,\n+      F32 :: su_8_32;\n+\n+    (* Compare absolute greater-than or equal.  *)\n+    Vcage, [Instruction_name [\"vacge\"]],\n+      All (3, Dreg), \"vcage\", cmp_sign_matters, [F32];\n+    Vcage, [Instruction_name [\"vacge\"]],\n+      All (3, Qreg), \"vcageQ\", cmp_sign_matters, [F32];\n+\n+    (* Compare absolute less-than or equal.  *)\n+    Vcale, [Instruction_name [\"vacge\"]; Flipped \"vcage\"],\n+      All (3, Dreg), \"vcale\", cmp_sign_matters, [F32];\n+    Vcale, [Instruction_name [\"vacge\"]; Flipped \"vcageQ\"],\n+      All (3, Qreg), \"vcaleQ\", cmp_sign_matters, [F32];\n+\n+    (* Compare absolute greater-than or equal.  *)\n+    Vcagt, [Instruction_name [\"vacgt\"]],\n+      All (3, Dreg), \"vcagt\", cmp_sign_matters, [F32];\n+    Vcagt, [Instruction_name [\"vacgt\"]],\n+      All (3, Qreg), \"vcagtQ\", cmp_sign_matters, [F32];\n+\n+    (* Compare absolute less-than or equal.  *)\n+    Vcalt, [Instruction_name [\"vacgt\"]; Flipped \"vcagt\"],\n+      All (3, Dreg), \"vcalt\", cmp_sign_matters, [F32];\n+    Vcalt, [Instruction_name [\"vacgt\"]; Flipped \"vcagtQ\"],\n+      All (3, Qreg), \"vcaltQ\", cmp_sign_matters, [F32];\n+\n+    (* Test bits.  *)\n+    Vtst, [], All (3, Dreg), \"vtst\", cmp_bits, P8 :: su_8_32;\n+    Vtst, [], All (3, Qreg), \"vtstQ\", cmp_bits, P8 :: su_8_32;\n+\n+    (* Absolute difference.  *)\n+    Vabd, [], All (3, Dreg), \"vabd\", elts_same_2, F32 :: su_8_32;\n+    Vabd, [], All (3, Qreg), \"vabdQ\", elts_same_2, F32 :: su_8_32;\n+    Vabd, [], Long, \"vabdl\", elts_same_2, su_8_32;\n+\n+    (* Absolute difference and accumulate.  *)\n+    Vaba, [], All (3, Dreg), \"vaba\", elts_same_io, su_8_32;\n+    Vaba, [], All (3, Qreg), \"vabaQ\", elts_same_io, su_8_32;\n+    Vaba, [], Long, \"vabal\", elts_same_io, su_8_32;\n+\n+    (* Max.  *)\n+    Vmax, [], All (3, Dreg), \"vmax\", elts_same_2, F32 :: su_8_32;\n+    Vmax, [], All (3, Qreg), \"vmaxQ\", elts_same_2, F32 :: su_8_32;\n+\n+    (* Min.  *)\n+    Vmin, [], All (3, Dreg), \"vmin\", elts_same_2, F32 :: su_8_32;\n+    Vmin, [], All (3, Qreg), \"vminQ\", elts_same_2, F32 :: su_8_32;\n+\n+    (* Pairwise add.  *)\n+    Vpadd, [], All (3, Dreg), \"vpadd\", sign_invar_2, F32 :: su_8_32;\n+    Vpadd, [], Long_noreg Dreg, \"vpaddl\", elts_same_1, su_8_32;\n+    Vpadd, [], Long_noreg Qreg, \"vpaddlQ\", elts_same_1, su_8_32;\n+\n+    (* Pairwise add, widen and accumulate.  *)\n+    Vpada, [], Wide_noreg Dreg, \"vpadal\", elts_same_2, su_8_32;\n+    Vpada, [], Wide_noreg Qreg, \"vpadalQ\", elts_same_2, su_8_32;\n+\n+    (* Folding maximum, minimum.  *)\n+    Vpmax, [], All (3, Dreg), \"vpmax\", elts_same_2, F32 :: su_8_32;\n+    Vpmin, [], All (3, Dreg), \"vpmin\", elts_same_2, F32 :: su_8_32;\n+\n+    (* Reciprocal step.  *)\n+    Vrecps, [], All (3, Dreg), \"vrecps\", elts_same_2, [F32];\n+    Vrecps, [], All (3, Qreg), \"vrecpsQ\", elts_same_2, [F32];\n+    Vrsqrts, [], All (3, Dreg), \"vrsqrts\", elts_same_2, [F32];\n+    Vrsqrts, [], All (3, Qreg), \"vrsqrtsQ\", elts_same_2, [F32];\n+\n+    (* Vector shift left.  *)\n+    Vshl, [], All (3, Dreg), \"vshl\", reg_shift, su_8_64;\n+    Vshl, [], All (3, Qreg), \"vshlQ\", reg_shift, su_8_64;\n+    Vshl, [Instruction_name [\"vrshl\"]; Rounding],\n+      All (3, Dreg), \"vRshl\", reg_shift, su_8_64;\n+    Vshl, [Instruction_name [\"vrshl\"]; Rounding],\n+      All (3, Qreg), \"vRshlQ\", reg_shift, su_8_64;\n+    Vshl, [Saturating], All (3, Dreg), \"vqshl\", reg_shift, su_8_64;\n+    Vshl, [Saturating], All (3, Qreg), \"vqshlQ\", reg_shift, su_8_64;\n+    Vshl, [Instruction_name [\"vqrshl\"]; Saturating; Rounding],\n+      All (3, Dreg), \"vqRshl\", reg_shift, su_8_64;\n+    Vshl, [Instruction_name [\"vqrshl\"]; Saturating; Rounding],\n+      All (3, Qreg), \"vqRshlQ\", reg_shift, su_8_64;\n+\n+    (* Vector shift right by constant.  *)\n+    Vshr_n, [], Binary_imm Dreg, \"vshr_n\", shift_right, su_8_64;\n+    Vshr_n, [], Binary_imm Qreg, \"vshrQ_n\", shift_right, su_8_64;\n+    Vshr_n, [Instruction_name [\"vrshr\"]; Rounding], Binary_imm Dreg,\n+      \"vRshr_n\", shift_right, su_8_64;\n+    Vshr_n, [Instruction_name [\"vrshr\"]; Rounding], Binary_imm Qreg,\n+      \"vRshrQ_n\", shift_right, su_8_64;\n+    Vshr_n, [], Narrow_imm, \"vshrn_n\", shift_right_sign_invar, su_16_64;\n+    Vshr_n, [Instruction_name [\"vrshrn\"]; Rounding], Narrow_imm, \"vRshrn_n\",\n+      shift_right_sign_invar, su_16_64;\n+    Vshr_n, [Saturating], Narrow_imm, \"vqshrn_n\", shift_right, su_16_64;\n+    Vshr_n, [Instruction_name [\"vqrshrn\"]; Saturating; Rounding], Narrow_imm,\n+      \"vqRshrn_n\", shift_right, su_16_64;\n+    Vshr_n, [Saturating; Dst_unsign], Narrow_imm, \"vqshrun_n\",\n+      shift_right_to_uns, [S16; S32; S64];\n+    Vshr_n, [Instruction_name [\"vqrshrun\"]; Saturating; Dst_unsign; Rounding],\n+      Narrow_imm, \"vqRshrun_n\", shift_right_to_uns, [S16; S32; S64];\n+\n+    (* Vector shift left by constant.  *)\n+    Vshl_n, [], Binary_imm Dreg, \"vshl_n\", shift_left_sign_invar, su_8_64;\n+    Vshl_n, [], Binary_imm Qreg, \"vshlQ_n\", shift_left_sign_invar, su_8_64;\n+    Vshl_n, [Saturating], Binary_imm Dreg, \"vqshl_n\", shift_left, su_8_64;\n+    Vshl_n, [Saturating], Binary_imm Qreg, \"vqshlQ_n\", shift_left, su_8_64;\n+    Vshl_n, [Saturating; Dst_unsign], Binary_imm Dreg, \"vqshlu_n\",\n+      shift_left_to_uns, [S8; S16; S32; S64];\n+    Vshl_n, [Saturating; Dst_unsign], Binary_imm Qreg, \"vqshluQ_n\",\n+      shift_left_to_uns, [S8; S16; S32; S64];\n+    Vshl_n, [], Long_imm, \"vshll_n\", shift_left, su_8_32;\n+\n+    (* Vector shift right by constant and accumulate.  *)\n+    Vsra_n, [], Binary_imm Dreg, \"vsra_n\", shift_right_acc, su_8_64;\n+    Vsra_n, [], Binary_imm Qreg, \"vsraQ_n\", shift_right_acc, su_8_64;\n+    Vsra_n, [Instruction_name [\"vrsra\"]; Rounding], Binary_imm Dreg,\n+      \"vRsra_n\", shift_right_acc, su_8_64;\n+    Vsra_n, [Instruction_name [\"vrsra\"]; Rounding], Binary_imm Qreg,\n+      \"vRsraQ_n\", shift_right_acc, su_8_64;\n+\n+    (* Vector shift right and insert.  *)\n+    Vsri, [], Use_operands [| Dreg; Dreg; Immed |], \"vsri_n\", shift_insert,\n+      P8 :: P16 :: su_8_64;\n+    Vsri, [], Use_operands [| Qreg; Qreg; Immed |], \"vsriQ_n\", shift_insert,\n+      P8 :: P16 :: su_8_64;\n+\n+    (* Vector shift left and insert.  *)\n+    Vsli, [], Use_operands [| Dreg; Dreg; Immed |], \"vsli_n\", shift_insert,\n+      P8 :: P16 :: su_8_64;\n+    Vsli, [], Use_operands [| Qreg; Qreg; Immed |], \"vsliQ_n\", shift_insert,\n+      P8 :: P16 :: su_8_64;\n+\n+    (* Absolute value.  *)\n+    Vabs, [], All (2, Dreg), \"vabs\", elts_same_1, [S8; S16; S32; F32];\n+    Vabs, [], All (2, Qreg), \"vabsQ\", elts_same_1, [S8; S16; S32; F32];\n+    Vabs, [Saturating], All (2, Dreg), \"vqabs\", elts_same_1, [S8; S16; S32];\n+    Vabs, [Saturating], All (2, Qreg), \"vqabsQ\", elts_same_1, [S8; S16; S32];\n+\n+    (* Negate.  *)\n+    Vneg, [], All (2, Dreg), \"vneg\", elts_same_1, [S8; S16; S32; F32];\n+    Vneg, [], All (2, Qreg), \"vnegQ\", elts_same_1, [S8; S16; S32; F32];\n+    Vneg, [Saturating], All (2, Dreg), \"vqneg\", elts_same_1, [S8; S16; S32];\n+    Vneg, [Saturating], All (2, Qreg), \"vqnegQ\", elts_same_1, [S8; S16; S32];\n+\n+    (* Bitwise not.  *)\n+    Vmvn, [], All (2, Dreg), \"vmvn\", notype_1, P8 :: su_8_32;\n+    Vmvn, [], All (2, Qreg), \"vmvnQ\", notype_1, P8 :: su_8_32;\n+\n+    (* Count leading sign bits.  *)\n+    Vcls, [], All (2, Dreg), \"vcls\", elts_same_1, [S8; S16; S32];\n+    Vcls, [], All (2, Qreg), \"vclsQ\", elts_same_1, [S8; S16; S32];\n+\n+    (* Count leading zeros.  *)\n+    Vclz, [], All (2, Dreg), \"vclz\", sign_invar_1, su_8_32;\n+    Vclz, [], All (2, Qreg), \"vclzQ\", sign_invar_1, su_8_32;\n+\n+    (* Count number of set bits.  *)\n+    Vcnt, [], All (2, Dreg), \"vcnt\", bits_1, [P8; S8; U8];\n+    Vcnt, [], All (2, Qreg), \"vcntQ\", bits_1, [P8; S8; U8];\n+\n+    (* Reciprocal estimate.  *)\n+    Vrecpe, [], All (2, Dreg), \"vrecpe\", elts_same_1, [U32; F32];\n+    Vrecpe, [], All (2, Qreg), \"vrecpeQ\", elts_same_1, [U32; F32];\n+\n+    (* Reciprocal square-root estimate.  *)\n+    Vrsqrte, [], All (2, Dreg), \"vrsqrte\", elts_same_1, [U32; F32];\n+    Vrsqrte, [], All (2, Qreg), \"vrsqrteQ\", elts_same_1, [U32; F32];\n+\n+    (* Get lanes from a vector.  *)\n+    Vget_lane,\n+      [InfoWord; Disassembles_as [Use_operands [| Corereg; Element_of_dreg |]];\n+       Instruction_name [\"vmov\"]],\n+      Use_operands [| Corereg; Dreg; Immed |],\n+      \"vget_lane\", get_lane, pf_su_8_32;\n+    Vget_lane,\n+      [InfoWord;\n+       Disassembles_as [Use_operands [| Corereg; Corereg; Dreg |]];\n+       Instruction_name [\"vmov\"]; Const_valuator (fun _ -> 0)],\n+      Use_operands [| Corereg; Dreg; Immed |],\n+      \"vget_lane\", notype_2, [S64; U64];\n+    Vget_lane,\n+      [InfoWord; Disassembles_as [Use_operands [| Corereg; Element_of_dreg |]];\n+       Instruction_name [\"vmov\"]],\n+      Use_operands [| Corereg; Qreg; Immed |],\n+      \"vgetQ_lane\", get_lane, pf_su_8_32;\n+    Vget_lane,\n+      [InfoWord;\n+       Disassembles_as [Use_operands [| Corereg; Corereg; Dreg |]];\n+       Instruction_name [\"vmov\"]; Const_valuator (fun _ -> 0)],\n+      Use_operands [| Corereg; Qreg; Immed |],\n+      \"vgetQ_lane\", notype_2, [S64; U64];\n+\n+    (* Set lanes in a vector.  *)\n+    Vset_lane, [Disassembles_as [Use_operands [| Element_of_dreg; Corereg |]];\n+                Instruction_name [\"vmov\"]],\n+      Use_operands [| Dreg; Corereg; Dreg; Immed |], \"vset_lane\",\n+      set_lane, pf_su_8_32;\n+    Vset_lane, [Disassembles_as [Use_operands [| Dreg; Corereg; Corereg |]];\n+                Instruction_name [\"vmov\"]; Const_valuator (fun _ -> 0)],\n+      Use_operands [| Dreg; Corereg; Dreg; Immed |], \"vset_lane\",\n+      set_lane_notype, [S64; U64];\n+    Vset_lane, [Disassembles_as [Use_operands [| Element_of_dreg; Corereg |]];\n+                Instruction_name [\"vmov\"]],\n+      Use_operands [| Qreg; Corereg; Qreg; Immed |], \"vsetQ_lane\",\n+      set_lane, pf_su_8_32;\n+    Vset_lane, [Disassembles_as [Use_operands [| Dreg; Corereg; Corereg |]];\n+                Instruction_name [\"vmov\"]; Const_valuator (fun _ -> 0)],\n+      Use_operands [| Qreg; Corereg; Qreg; Immed |], \"vsetQ_lane\",\n+      set_lane_notype, [S64; U64];\n+\n+    (* Create vector from literal bit pattern.  *)\n+    Vcreate,\n+      [No_op], (* Not really, but it can yield various things that are too\n+                  hard for the test generator at this time.  *)\n+      Use_operands [| Dreg; Corereg |], \"vcreate\", create_vector,\n+      pf_su_8_64;\n+\n+    (* Set all lanes to the same value.  *)\n+    Vdup_n, [],\n+      Use_operands [| Dreg; Corereg |], \"vdup_n\", bits_1,\n+      pf_su_8_32;\n+    Vdup_n,\n+      [Instruction_name [\"vmov\"];\n+       Disassembles_as [Use_operands [| Dreg; Corereg; Corereg |]]],\n+      Use_operands [| Dreg; Corereg |], \"vdup_n\", notype_1,\n+      [S64; U64];\n+    Vdup_n, [],\n+      Use_operands [| Qreg; Corereg |], \"vdupQ_n\", bits_1,\n+      pf_su_8_32;\n+    Vdup_n,\n+      [Instruction_name [\"vmov\"];\n+       Disassembles_as [Use_operands [| Dreg; Corereg; Corereg |];\n+                        Use_operands [| Dreg; Corereg; Corereg |]]],\n+      Use_operands [| Qreg; Corereg |], \"vdupQ_n\", notype_1,\n+      [S64; U64];\n+\n+    (* These are just aliases for the above.  *)\n+    Vmov_n,\n+      [Builtin_name \"vdup_n\"],\n+      Use_operands [| Dreg; Corereg |],\n+      \"vmov_n\", bits_1, pf_su_8_32;\n+    Vmov_n,\n+      [Builtin_name \"vdup_n\";\n+       Instruction_name [\"vmov\"];\n+       Disassembles_as [Use_operands [| Dreg; Corereg; Corereg |]]],\n+      Use_operands [| Dreg; Corereg |],\n+      \"vmov_n\", notype_1, [S64; U64];\n+    Vmov_n,\n+      [Builtin_name \"vdupQ_n\"],\n+      Use_operands [| Qreg; Corereg |],\n+      \"vmovQ_n\", bits_1, pf_su_8_32;\n+    Vmov_n,\n+      [Builtin_name \"vdupQ_n\";\n+       Instruction_name [\"vmov\"];\n+       Disassembles_as [Use_operands [| Dreg; Corereg; Corereg |];\n+                        Use_operands [| Dreg; Corereg; Corereg |]]],\n+      Use_operands [| Qreg; Corereg |],\n+      \"vmovQ_n\", notype_1, [S64; U64];\n+\n+    (* Duplicate, lane version.  We can't use Use_operands here because the\n+       rightmost register (always Dreg) would be picked up by find_key_operand,\n+       when we want the leftmost register to be used in this case (otherwise\n+       the modes are indistinguishable in neon.md, etc.  *)\n+    Vdup_lane,\n+      [Disassembles_as [Use_operands [| Dreg; Element_of_dreg |]]],\n+      Unary_scalar Dreg, \"vdup_lane\", bits_2, pf_su_8_32;\n+    Vdup_lane,\n+      [No_op; Const_valuator (fun _ -> 0)],\n+      Unary_scalar Dreg, \"vdup_lane\", bits_2, [S64; U64];\n+    Vdup_lane,\n+      [Disassembles_as [Use_operands [| Qreg; Element_of_dreg |]]],\n+      Unary_scalar Qreg, \"vdupQ_lane\", bits_2, pf_su_8_32;\n+    Vdup_lane,\n+      [No_op; Const_valuator (fun _ -> 0)],\n+      Unary_scalar Qreg, \"vdupQ_lane\", bits_2, [S64; U64];\n+\n+    (* Combining vectors.  *)\n+    Vcombine, [No_op],\n+      Use_operands [| Qreg; Dreg; Dreg |], \"vcombine\", notype_2,\n+      pf_su_8_64;\n+\n+    (* Splitting vectors.  *)\n+    Vget_high, [No_op],\n+      Use_operands [| Dreg; Qreg |], \"vget_high\",\n+      notype_1, pf_su_8_64;\n+    Vget_low, [Instruction_name [\"vmov\"];\n+               Disassembles_as [Use_operands [| Dreg; Dreg |]]],\n+      Use_operands [| Dreg; Qreg |], \"vget_low\",\n+      notype_1, pf_su_8_64;\n+\n+    (* Conversions.  *)\n+    Vcvt, [InfoWord], All (2, Dreg), \"vcvt\", conv_1,\n+      [Conv (S32, F32); Conv (U32, F32); Conv (F32, S32); Conv (F32, U32)];\n+    Vcvt, [InfoWord], All (2, Qreg), \"vcvtQ\", conv_1,\n+      [Conv (S32, F32); Conv (U32, F32); Conv (F32, S32); Conv (F32, U32)];\n+    Vcvt_n, [InfoWord], Use_operands [| Dreg; Dreg; Immed |], \"vcvt_n\", conv_2,\n+      [Conv (S32, F32); Conv (U32, F32); Conv (F32, S32); Conv (F32, U32)];\n+    Vcvt_n, [InfoWord], Use_operands [| Qreg; Qreg; Immed |], \"vcvtQ_n\", conv_2,\n+      [Conv (S32, F32); Conv (U32, F32); Conv (F32, S32); Conv (F32, U32)];\n+\n+    (* Move, narrowing.  *)\n+    Vmovn, [Disassembles_as [Use_operands [| Dreg; Qreg |]]],\n+      Narrow, \"vmovn\", sign_invar_1, su_16_64;\n+    Vmovn, [Disassembles_as [Use_operands [| Dreg; Qreg |]]; Saturating],\n+      Narrow, \"vqmovn\", elts_same_1, su_16_64;\n+    Vmovn,\n+      [Disassembles_as [Use_operands [| Dreg; Qreg |]]; Saturating; Dst_unsign],\n+      Narrow, \"vqmovun\", dst_unsign_1,\n+      [S16; S32; S64];\n+\n+    (* Move, long.  *)\n+    Vmovl, [Disassembles_as [Use_operands [| Qreg; Dreg |]]],\n+      Long, \"vmovl\", elts_same_1, su_8_32;\n+\n+    (* Table lookup.  *)\n+    Vtbl 1,\n+      [Instruction_name [\"vtbl\"];\n+       Disassembles_as [Use_operands [| Dreg; VecArray (1, Dreg); Dreg |]]],\n+      Use_operands [| Dreg; Dreg; Dreg |], \"vtbl1\", table_2, [U8; S8; P8];\n+    Vtbl 2, [Instruction_name [\"vtbl\"]],\n+      Use_operands [| Dreg; VecArray (2, Dreg); Dreg |], \"vtbl2\", table_2,\n+      [U8; S8; P8];\n+    Vtbl 3, [Instruction_name [\"vtbl\"]],\n+      Use_operands [| Dreg; VecArray (3, Dreg); Dreg |], \"vtbl3\", table_2,\n+      [U8; S8; P8];\n+    Vtbl 4, [Instruction_name [\"vtbl\"]],\n+      Use_operands [| Dreg; VecArray (4, Dreg); Dreg |], \"vtbl4\", table_2,\n+      [U8; S8; P8];\n+\n+    (* Extended table lookup.  *)\n+    Vtbx 1,\n+      [Instruction_name [\"vtbx\"];\n+       Disassembles_as [Use_operands [| Dreg; VecArray (1, Dreg); Dreg |]]],\n+      Use_operands [| Dreg; Dreg; Dreg |], \"vtbx1\", table_io, [U8; S8; P8];\n+    Vtbx 2, [Instruction_name [\"vtbx\"]],\n+      Use_operands [| Dreg; VecArray (2, Dreg); Dreg |], \"vtbx2\", table_io,\n+      [U8; S8; P8];\n+    Vtbx 3, [Instruction_name [\"vtbx\"]],\n+      Use_operands [| Dreg; VecArray (3, Dreg); Dreg |], \"vtbx3\", table_io,\n+      [U8; S8; P8];\n+    Vtbx 4, [Instruction_name [\"vtbx\"]],\n+      Use_operands [| Dreg; VecArray (4, Dreg); Dreg |], \"vtbx4\", table_io,\n+      [U8; S8; P8];\n+\n+    (* Multiply, lane.  (note: these were undocumented at the time of\n+       writing).  *)\n+    Vmul_lane, [], By_scalar Dreg, \"vmul_lane\", sign_invar_2_lane,\n+      [S16; S32; U16; U32; F32];\n+    Vmul_lane, [], By_scalar Qreg, \"vmulQ_lane\", sign_invar_2_lane,\n+      [S16; S32; U16; U32; F32];\n+\n+    (* Multiply-accumulate, lane.  *)\n+    Vmla_lane, [], By_scalar Dreg, \"vmla_lane\", sign_invar_io_lane,\n+      [S16; S32; U16; U32; F32];\n+    Vmla_lane, [], By_scalar Qreg, \"vmlaQ_lane\", sign_invar_io_lane,\n+      [S16; S32; U16; U32; F32];\n+    Vmla_lane, [], Wide_lane, \"vmlal_lane\", elts_same_io_lane,\n+      [S16; S32; U16; U32];\n+    Vmla_lane, [Saturating; Doubling], Wide_lane, \"vqdmlal_lane\",\n+      elts_same_io_lane, [S16; S32];\n+\n+    (* Multiply-subtract, lane.  *)\n+    Vmls_lane, [], By_scalar Dreg, \"vmls_lane\", sign_invar_io_lane,\n+      [S16; S32; U16; U32; F32];\n+    Vmls_lane, [], By_scalar Qreg, \"vmlsQ_lane\", sign_invar_io_lane,\n+      [S16; S32; U16; U32; F32];\n+    Vmls_lane, [], Wide_lane, \"vmlsl_lane\", elts_same_io_lane,\n+      [S16; S32; U16; U32];\n+    Vmls_lane, [Saturating; Doubling], Wide_lane, \"vqdmlsl_lane\",\n+      elts_same_io_lane, [S16; S32];\n+\n+    (* Long multiply, lane.  *)\n+    Vmull_lane, [],\n+      Wide_lane, \"vmull_lane\", elts_same_2_lane, [S16; S32; U16; U32];\n+\n+    (* Saturating doubling long multiply, lane.  *)\n+    Vqdmull_lane, [Saturating; Doubling],\n+      Wide_lane, \"vqdmull_lane\", elts_same_2_lane, [S16; S32];\n+\n+    (* Saturating doubling long multiply high, lane.  *)\n+    Vqdmulh_lane, [Saturating; Halving],\n+      By_scalar Qreg, \"vqdmulhQ_lane\", elts_same_2_lane, [S16; S32];\n+    Vqdmulh_lane, [Saturating; Halving],\n+      By_scalar Dreg, \"vqdmulh_lane\", elts_same_2_lane, [S16; S32];\n+    Vqdmulh_lane, [Saturating; Halving; Rounding;\n+\t\t   Instruction_name [\"vqrdmulh\"]],\n+      By_scalar Qreg, \"vqRdmulhQ_lane\", elts_same_2_lane, [S16; S32];\n+    Vqdmulh_lane, [Saturating; Halving; Rounding;\n+\t\t   Instruction_name [\"vqrdmulh\"]],\n+      By_scalar Dreg, \"vqRdmulh_lane\", elts_same_2_lane, [S16; S32];\n+\n+    (* Vector multiply by scalar.  *)\n+    Vmul_n, [InfoWord;\n+             Disassembles_as [Use_operands [| Dreg; Dreg; Element_of_dreg |]]],\n+             Use_operands [| Dreg; Dreg; Corereg |], \"vmul_n\",\n+      sign_invar_2, [S16; S32; U16; U32; F32];\n+    Vmul_n, [InfoWord;\n+             Disassembles_as [Use_operands [| Qreg; Qreg; Element_of_dreg |]]],\n+             Use_operands [| Qreg; Qreg; Corereg |], \"vmulQ_n\",\n+      sign_invar_2, [S16; S32; U16; U32; F32];\n+\n+    (* Vector long multiply by scalar.  *)\n+    Vmull_n, [Instruction_name [\"vmull\"];\n+              Disassembles_as [Use_operands [| Qreg; Dreg; Element_of_dreg |]]],\n+              Wide_scalar, \"vmull_n\",\n+      elts_same_2, [S16; S32; U16; U32];\n+\n+    (* Vector saturating doubling long multiply by scalar.  *)\n+    Vqdmull_n, [Saturating; Doubling;\n+\t        Disassembles_as [Use_operands [| Qreg; Dreg;\n+\t\t\t\t\t\t Element_of_dreg |]]],\n+                Wide_scalar, \"vqdmull_n\",\n+      elts_same_2, [S16; S32];\n+\n+    (* Vector saturating doubling long multiply high by scalar.  *)\n+    Vqdmulh_n,\n+      [Saturating; Halving; InfoWord;\n+       Disassembles_as [Use_operands [| Qreg; Qreg; Element_of_dreg |]]],\n+      Use_operands [| Qreg; Qreg; Corereg |],\n+      \"vqdmulhQ_n\", elts_same_2, [S16; S32];\n+    Vqdmulh_n,\n+      [Saturating; Halving; InfoWord;\n+       Disassembles_as [Use_operands [| Dreg; Dreg; Element_of_dreg |]]],\n+      Use_operands [| Dreg; Dreg; Corereg |],\n+      \"vqdmulh_n\", elts_same_2, [S16; S32];\n+    Vqdmulh_n,\n+      [Saturating; Halving; Rounding; InfoWord;\n+       Instruction_name [\"vqrdmulh\"];\n+       Disassembles_as [Use_operands [| Qreg; Qreg; Element_of_dreg |]]],\n+      Use_operands [| Qreg; Qreg; Corereg |],\n+      \"vqRdmulhQ_n\", elts_same_2, [S16; S32];\n+    Vqdmulh_n,\n+      [Saturating; Halving; Rounding; InfoWord;\n+       Instruction_name [\"vqrdmulh\"];\n+       Disassembles_as [Use_operands [| Dreg; Dreg; Element_of_dreg |]]],\n+      Use_operands [| Dreg; Dreg; Corereg |],\n+      \"vqRdmulh_n\", elts_same_2, [S16; S32];\n+\n+    (* Vector multiply-accumulate by scalar.  *)\n+    Vmla_n, [InfoWord;\n+             Disassembles_as [Use_operands [| Dreg; Dreg; Element_of_dreg |]]],\n+      Use_operands [| Dreg; Dreg; Corereg |], \"vmla_n\",\n+      sign_invar_io, [S16; S32; U16; U32; F32];\n+    Vmla_n, [InfoWord;\n+             Disassembles_as [Use_operands [| Qreg; Qreg; Element_of_dreg |]]],\n+      Use_operands [| Qreg; Qreg; Corereg |], \"vmlaQ_n\",\n+      sign_invar_io, [S16; S32; U16; U32; F32];\n+    Vmla_n, [], Wide_scalar, \"vmlal_n\", elts_same_io, [S16; S32; U16; U32];\n+    Vmla_n, [Saturating; Doubling], Wide_scalar, \"vqdmlal_n\", elts_same_io,\n+      [S16; S32];\n+\n+    (* Vector multiply subtract by scalar.  *)\n+    Vmls_n, [InfoWord;\n+             Disassembles_as [Use_operands [| Dreg; Dreg; Element_of_dreg |]]],\n+      Use_operands [| Dreg; Dreg; Corereg |], \"vmls_n\",\n+      sign_invar_io, [S16; S32; U16; U32; F32];\n+    Vmls_n, [InfoWord;\n+             Disassembles_as [Use_operands [| Qreg; Qreg; Element_of_dreg |]]],\n+      Use_operands [| Qreg; Qreg; Corereg |], \"vmlsQ_n\",\n+      sign_invar_io, [S16; S32; U16; U32; F32];\n+    Vmls_n, [], Wide_scalar, \"vmlsl_n\", elts_same_io, [S16; S32; U16; U32];\n+    Vmls_n, [Saturating; Doubling], Wide_scalar, \"vqdmlsl_n\", elts_same_io,\n+      [S16; S32];\n+\n+    (* Vector extract.  *)\n+    Vext, [Const_valuator (fun _ -> 0)],\n+      Use_operands [| Dreg; Dreg; Dreg; Immed |], \"vext\", extend,\n+      pf_su_8_64;\n+    Vext, [Const_valuator (fun _ -> 0)],\n+      Use_operands [| Qreg; Qreg; Qreg; Immed |], \"vextQ\", extend,\n+      pf_su_8_64;\n+\n+    (* Reverse elements.  *)\n+    Vrev64, [], All (2, Dreg), \"vrev64\", bits_1, P8 :: P16 :: F32 :: su_8_32;\n+    Vrev64, [], All (2, Qreg), \"vrev64Q\", bits_1, P8 :: P16 :: F32 :: su_8_32;\n+    Vrev32, [], All (2, Dreg), \"vrev32\", bits_1, [P8; P16; S8; U8; S16; U16];\n+    Vrev32, [], All (2, Qreg), \"vrev32Q\", bits_1, [P8; P16; S8; U8; S16; U16];\n+    Vrev16, [], All (2, Dreg), \"vrev16\", bits_1, [P8; S8; U8];\n+    Vrev16, [], All (2, Qreg), \"vrev16Q\", bits_1, [P8; S8; U8];\n+\n+    (* Bit selection.  *)\n+    Vbsl,\n+      [Instruction_name [\"vbsl\"; \"vbit\"; \"vbif\"];\n+       Disassembles_as [Use_operands [| Dreg; Dreg; Dreg |]]],\n+      Use_operands [| Dreg; Dreg; Dreg; Dreg |], \"vbsl\", bit_select,\n+      pf_su_8_64;\n+    Vbsl,\n+      [Instruction_name [\"vbsl\"; \"vbit\"; \"vbif\"];\n+       Disassembles_as [Use_operands [| Qreg; Qreg; Qreg |]]],\n+      Use_operands [| Qreg; Qreg; Qreg; Qreg |], \"vbslQ\", bit_select,\n+      pf_su_8_64;\n+\n+    (* Transpose elements.  **NOTE** ReturnPtr goes some of the way towards\n+       generating good code for intrinsics which return structure types --\n+       builtins work well by themselves (and understand that the values being\n+       stored on e.g. the stack also reside in registers, so can optimise the\n+       stores away entirely if the results are used immediately), but\n+       intrinsics are very much less efficient. Maybe something can be improved\n+       re: inlining, or tweaking the ABI used for intrinsics (a special call\n+       attribute?).\n+    *)\n+    Vtrn, [ReturnPtr], Pair_result Dreg, \"vtrn\", bits_2, pf_su_8_32;\n+    Vtrn, [ReturnPtr], Pair_result Qreg, \"vtrnQ\", bits_2, pf_su_8_32;\n+\n+    (* Zip elements.  *)\n+    Vzip, [ReturnPtr], Pair_result Dreg, \"vzip\", bits_2, pf_su_8_32;\n+    Vzip, [ReturnPtr], Pair_result Qreg, \"vzipQ\", bits_2, pf_su_8_32;\n+\n+    (* Unzip elements.  *)\n+    Vuzp, [ReturnPtr], Pair_result Dreg, \"vuzp\", bits_2, pf_su_8_32;\n+    Vuzp, [ReturnPtr], Pair_result Qreg, \"vuzpQ\", bits_2, pf_su_8_32;\n+\n+    (* Element/structure loads.  VLD1 variants.  *)\n+    Vldx 1,\n+      [Disassembles_as [Use_operands [| VecArray (1, Dreg);\n+                                        CstPtrTo Corereg |]]],\n+      Use_operands [| Dreg; CstPtrTo Corereg |], \"vld1\", bits_1,\n+      pf_su_8_64;\n+    Vldx 1, [Disassembles_as [Use_operands [| VecArray (2, Dreg);\n+\t\t\t\t\t      CstPtrTo Corereg |]]],\n+      Use_operands [| Qreg; CstPtrTo Corereg |], \"vld1Q\", bits_1,\n+      pf_su_8_64;\n+\n+    Vldx_lane 1,\n+      [Disassembles_as [Use_operands [| VecArray (1, Element_of_dreg);\n+                                        CstPtrTo Corereg |]]],\n+      Use_operands [| Dreg; CstPtrTo Corereg; Dreg; Immed |],\n+      \"vld1_lane\", bits_3, pf_su_8_32;\n+    Vldx_lane 1,\n+      [Disassembles_as [Use_operands [| VecArray (1, Dreg);\n+                                        CstPtrTo Corereg |]];\n+       Const_valuator (fun _ -> 0)],\n+      Use_operands [| Dreg; CstPtrTo Corereg; Dreg; Immed |],\n+      \"vld1_lane\", bits_3, [S64; U64];\n+    Vldx_lane 1,\n+      [Disassembles_as [Use_operands [| VecArray (1, Element_of_dreg);\n+                                        CstPtrTo Corereg |]]],\n+      Use_operands [| Qreg; CstPtrTo Corereg; Qreg; Immed |],\n+      \"vld1Q_lane\", bits_3, pf_su_8_32;\n+    Vldx_lane 1,\n+      [Disassembles_as [Use_operands [| VecArray (1, Dreg);\n+                                        CstPtrTo Corereg |]]],\n+      Use_operands [| Qreg; CstPtrTo Corereg; Qreg; Immed |],\n+      \"vld1Q_lane\", bits_3, [S64; U64];\n+\n+    Vldx_dup 1,\n+      [Disassembles_as [Use_operands [| VecArray (1, All_elements_of_dreg);\n+                                        CstPtrTo Corereg |]]],\n+      Use_operands [| Dreg; CstPtrTo Corereg |], \"vld1_dup\",\n+      bits_1, pf_su_8_32;\n+    Vldx_dup 1,\n+      [Disassembles_as [Use_operands [| VecArray (1, Dreg);\n+                                        CstPtrTo Corereg |]]],\n+      Use_operands [| Dreg; CstPtrTo Corereg |], \"vld1_dup\",\n+      bits_1, [S64; U64];\n+    Vldx_dup 1,\n+      [Disassembles_as [Use_operands [| VecArray (2, All_elements_of_dreg);\n+                                        CstPtrTo Corereg |]]],\n+      Use_operands [| Qreg; CstPtrTo Corereg |], \"vld1Q_dup\",\n+      bits_1, pf_su_8_32;\n+    Vldx_dup 1,\n+      [Disassembles_as [Use_operands [| VecArray (2, Dreg);\n+                                        CstPtrTo Corereg |]]],\n+      Use_operands [| Qreg; CstPtrTo Corereg |], \"vld1Q_dup\",\n+      bits_1, [S64; U64];\n+\n+    (* VST1 variants.  *)\n+    Vstx 1, [Disassembles_as [Use_operands [| VecArray (1, Dreg);\n+                                              PtrTo Corereg |]]],\n+      Use_operands [| PtrTo Corereg; Dreg |], \"vst1\",\n+      store_1, pf_su_8_64;\n+    Vstx 1, [Disassembles_as [Use_operands [| VecArray (2, Dreg);\n+\t\t\t\t\t      PtrTo Corereg |]]],\n+      Use_operands [| PtrTo Corereg; Qreg |], \"vst1Q\",\n+      store_1, pf_su_8_64;\n+\n+    Vstx_lane 1,\n+      [Disassembles_as [Use_operands [| VecArray (1, Element_of_dreg);\n+                                        CstPtrTo Corereg |]]],\n+      Use_operands [| PtrTo Corereg; Dreg; Immed |],\n+      \"vst1_lane\", store_3, pf_su_8_32;\n+    Vstx_lane 1,\n+      [Disassembles_as [Use_operands [| VecArray (1, Dreg);\n+                                        CstPtrTo Corereg |]];\n+       Const_valuator (fun _ -> 0)],\n+      Use_operands [| PtrTo Corereg; Dreg; Immed |],\n+      \"vst1_lane\", store_3, [U64; S64];\n+    Vstx_lane 1,\n+      [Disassembles_as [Use_operands [| VecArray (1, Element_of_dreg);\n+                                        CstPtrTo Corereg |]]],\n+      Use_operands [| PtrTo Corereg; Qreg; Immed |],\n+      \"vst1Q_lane\", store_3, pf_su_8_32;\n+    Vstx_lane 1,\n+      [Disassembles_as [Use_operands [| VecArray (1, Dreg);\n+                                        CstPtrTo Corereg |]]],\n+      Use_operands [| PtrTo Corereg; Qreg; Immed |],\n+      \"vst1Q_lane\", store_3, [U64; S64];\n+\n+    (* VLD2 variants.  *)\n+    Vldx 2, [], Use_operands [| VecArray (2, Dreg); CstPtrTo Corereg |],\n+      \"vld2\", bits_1, pf_su_8_32;\n+    Vldx 2, [Instruction_name [\"vld1\"]],\n+       Use_operands [| VecArray (2, Dreg); CstPtrTo Corereg |],\n+      \"vld2\", bits_1, [S64; U64];\n+    Vldx 2, [Disassembles_as [Use_operands [| VecArray (2, Dreg);\n+                                              CstPtrTo Corereg |];\n+                              Use_operands [| VecArray (2, Dreg);\n+\t\t\t\t\t      CstPtrTo Corereg |]]],\n+      Use_operands [| VecArray (2, Qreg); CstPtrTo Corereg |],\n+      \"vld2Q\", bits_1, pf_su_8_32;\n+\n+    Vldx_lane 2,\n+      [Disassembles_as [Use_operands\n+        [| VecArray (2, Element_of_dreg);\n+           CstPtrTo Corereg |]]],\n+      Use_operands [| VecArray (2, Dreg); CstPtrTo Corereg;\n+                      VecArray (2, Dreg); Immed |],\n+      \"vld2_lane\", bits_3, P8 :: P16 :: F32 :: su_8_32;\n+    Vldx_lane 2,\n+      [Disassembles_as [Use_operands\n+        [| VecArray (2, Element_of_dreg);\n+           CstPtrTo Corereg |]]],\n+      Use_operands [| VecArray (2, Qreg); CstPtrTo Corereg;\n+ \t              VecArray (2, Qreg); Immed |],\n+      \"vld2Q_lane\", bits_3, [P16; F32; U16; U32; S16; S32];\n+\n+    Vldx_dup 2,\n+      [Disassembles_as [Use_operands\n+        [| VecArray (2, All_elements_of_dreg); CstPtrTo Corereg |]]],\n+      Use_operands [| VecArray (2, Dreg); CstPtrTo Corereg |],\n+      \"vld2_dup\", bits_1, pf_su_8_32;\n+    Vldx_dup 2,\n+      [Instruction_name [\"vld1\"]; Disassembles_as [Use_operands\n+        [| VecArray (2, Dreg); CstPtrTo Corereg |]]],\n+      Use_operands [| VecArray (2, Dreg); CstPtrTo Corereg |],\n+      \"vld2_dup\", bits_1, [S64; U64];\n+\n+    (* VST2 variants.  *)\n+    Vstx 2, [Disassembles_as [Use_operands [| VecArray (2, Dreg);\n+                                              PtrTo Corereg |]]],\n+      Use_operands [| PtrTo Corereg; VecArray (2, Dreg) |], \"vst2\",\n+      store_1, pf_su_8_32;\n+    Vstx 2, [Disassembles_as [Use_operands [| VecArray (2, Dreg);\n+                                              PtrTo Corereg |]];\n+             Instruction_name [\"vst1\"]],\n+      Use_operands [| PtrTo Corereg; VecArray (2, Dreg) |], \"vst2\",\n+      store_1, [S64; U64];\n+    Vstx 2, [Disassembles_as [Use_operands [| VecArray (2, Dreg);\n+\t\t\t\t\t      PtrTo Corereg |];\n+                              Use_operands [| VecArray (2, Dreg);\n+\t\t\t\t              PtrTo Corereg |]]],\n+      Use_operands [| PtrTo Corereg; VecArray (2, Qreg) |], \"vst2Q\",\n+      store_1, pf_su_8_32;\n+\n+    Vstx_lane 2,\n+      [Disassembles_as [Use_operands\n+        [| VecArray (2, Element_of_dreg);\n+           CstPtrTo Corereg |]]],\n+      Use_operands [| PtrTo Corereg; VecArray (2, Dreg); Immed |], \"vst2_lane\",\n+      store_3, P8 :: P16 :: F32 :: su_8_32;\n+    Vstx_lane 2,\n+      [Disassembles_as [Use_operands\n+        [| VecArray (2, Element_of_dreg);\n+           CstPtrTo Corereg |]]],\n+      Use_operands [| PtrTo Corereg; VecArray (2, Qreg); Immed |], \"vst2Q_lane\",\n+      store_3, [P16; F32; U16; U32; S16; S32];\n+\n+    (* VLD3 variants.  *)\n+    Vldx 3, [], Use_operands [| VecArray (3, Dreg); CstPtrTo Corereg |],\n+      \"vld3\", bits_1, pf_su_8_32;\n+    Vldx 3, [Instruction_name [\"vld1\"]],\n+      Use_operands [| VecArray (3, Dreg); CstPtrTo Corereg |],\n+      \"vld3\", bits_1, [S64; U64];\n+    Vldx 3, [Disassembles_as [Use_operands [| VecArray (3, Dreg);\n+\t\t\t\t\t      CstPtrTo Corereg |];\n+                              Use_operands [| VecArray (3, Dreg);\n+\t\t\t\t\t      CstPtrTo Corereg |]]],\n+      Use_operands [| VecArray (3, Qreg); CstPtrTo Corereg |],\n+      \"vld3Q\", bits_1, P8 :: P16 :: F32 :: su_8_32;\n+\n+    Vldx_lane 3,\n+      [Disassembles_as [Use_operands\n+        [| VecArray (3, Element_of_dreg);\n+           CstPtrTo Corereg |]]],\n+      Use_operands [| VecArray (3, Dreg); CstPtrTo Corereg;\n+                                     VecArray (3, Dreg); Immed |],\n+      \"vld3_lane\", bits_3, P8 :: P16 :: F32 :: su_8_32;\n+    Vldx_lane 3,\n+      [Disassembles_as [Use_operands\n+        [| VecArray (3, Element_of_dreg);\n+           CstPtrTo Corereg |]]],\n+      Use_operands [| VecArray (3, Qreg); CstPtrTo Corereg;\n+\t\t\t\t     VecArray (3, Qreg); Immed |],\n+      \"vld3Q_lane\", bits_3, [P16; F32; U16; U32; S16; S32];\n+\n+    Vldx_dup 3,\n+      [Disassembles_as [Use_operands\n+        [| VecArray (3, All_elements_of_dreg); CstPtrTo Corereg |]]],\n+      Use_operands [| VecArray (3, Dreg); CstPtrTo Corereg |],\n+      \"vld3_dup\", bits_1, pf_su_8_32;\n+    Vldx_dup 3,\n+      [Instruction_name [\"vld1\"]; Disassembles_as [Use_operands\n+        [| VecArray (3, Dreg); CstPtrTo Corereg |]]],\n+      Use_operands [| VecArray (3, Dreg); CstPtrTo Corereg |],\n+      \"vld3_dup\", bits_1, [S64; U64];\n+\n+    (* VST3 variants.  *)\n+    Vstx 3, [Disassembles_as [Use_operands [| VecArray (4, Dreg);\n+                                              PtrTo Corereg |]]],\n+      Use_operands [| PtrTo Corereg; VecArray (3, Dreg) |], \"vst3\",\n+      store_1, pf_su_8_32;\n+    Vstx 3, [Disassembles_as [Use_operands [| VecArray (4, Dreg);\n+                                              PtrTo Corereg |]];\n+             Instruction_name [\"vst1\"]],\n+      Use_operands [| PtrTo Corereg; VecArray (3, Dreg) |], \"vst3\",\n+      store_1, [S64; U64];\n+    Vstx 3, [Disassembles_as [Use_operands [| VecArray (3, Dreg);\n+\t\t\t\t\t      PtrTo Corereg |];\n+                              Use_operands [| VecArray (3, Dreg);\n+\t\t\t\t\t      PtrTo Corereg |]]],\n+      Use_operands [| PtrTo Corereg; VecArray (3, Qreg) |], \"vst3Q\",\n+      store_1, pf_su_8_32;\n+\n+    Vstx_lane 3,\n+      [Disassembles_as [Use_operands\n+        [| VecArray (3, Element_of_dreg);\n+           CstPtrTo Corereg |]]],\n+      Use_operands [| PtrTo Corereg; VecArray (3, Dreg); Immed |], \"vst3_lane\",\n+      store_3, P8 :: P16 :: F32 :: su_8_32;\n+    Vstx_lane 3,\n+      [Disassembles_as [Use_operands\n+        [| VecArray (3, Element_of_dreg);\n+           CstPtrTo Corereg |]]],\n+      Use_operands [| PtrTo Corereg; VecArray (3, Qreg); Immed |], \"vst3Q_lane\",\n+      store_3, [P16; F32; U16; U32; S16; S32];\n+\n+    (* VLD4/VST4 variants.  *)\n+    Vldx 4, [], Use_operands [| VecArray (4, Dreg); CstPtrTo Corereg |],\n+      \"vld4\", bits_1, pf_su_8_32;\n+    Vldx 4, [Instruction_name [\"vld1\"]],\n+      Use_operands [| VecArray (4, Dreg); CstPtrTo Corereg |],\n+      \"vld4\", bits_1, [S64; U64];\n+    Vldx 4, [Disassembles_as [Use_operands [| VecArray (4, Dreg);\n+\t\t\t\t\t      CstPtrTo Corereg |];\n+                              Use_operands [| VecArray (4, Dreg);\n+\t\t\t\t\t      CstPtrTo Corereg |]]],\n+      Use_operands [| VecArray (4, Qreg); CstPtrTo Corereg |],\n+      \"vld4Q\", bits_1, P8 :: P16 :: F32 :: su_8_32;\n+\n+    Vldx_lane 4,\n+      [Disassembles_as [Use_operands\n+        [| VecArray (4, Element_of_dreg);\n+           CstPtrTo Corereg |]]],\n+      Use_operands [| VecArray (4, Dreg); CstPtrTo Corereg;\n+                                     VecArray (4, Dreg); Immed |],\n+      \"vld4_lane\", bits_3, P8 :: P16 :: F32 :: su_8_32;\n+    Vldx_lane 4,\n+      [Disassembles_as [Use_operands\n+        [| VecArray (4, Element_of_dreg);\n+           CstPtrTo Corereg |]]],\n+      Use_operands [| VecArray (4, Qreg); CstPtrTo Corereg;\n+   \t              VecArray (4, Qreg); Immed |],\n+      \"vld4Q_lane\", bits_3, [P16; F32; U16; U32; S16; S32];\n+\n+    Vldx_dup 4,\n+      [Disassembles_as [Use_operands\n+        [| VecArray (4, All_elements_of_dreg); CstPtrTo Corereg |]]],\n+      Use_operands [| VecArray (4, Dreg); CstPtrTo Corereg |],\n+      \"vld4_dup\", bits_1, pf_su_8_32;\n+    Vldx_dup 4,\n+      [Instruction_name [\"vld1\"]; Disassembles_as [Use_operands\n+        [| VecArray (4, Dreg); CstPtrTo Corereg |]]],\n+      Use_operands [| VecArray (4, Dreg); CstPtrTo Corereg |],\n+      \"vld4_dup\", bits_1, [S64; U64];\n+\n+    Vstx 4, [Disassembles_as [Use_operands [| VecArray (4, Dreg);\n+                                              PtrTo Corereg |]]],\n+      Use_operands [| PtrTo Corereg; VecArray (4, Dreg) |], \"vst4\",\n+      store_1, pf_su_8_32;\n+    Vstx 4, [Disassembles_as [Use_operands [| VecArray (4, Dreg);\n+                                              PtrTo Corereg |]];\n+             Instruction_name [\"vst1\"]],\n+      Use_operands [| PtrTo Corereg; VecArray (4, Dreg) |], \"vst4\",\n+      store_1, [S64; U64];\n+    Vstx 4, [Disassembles_as [Use_operands [| VecArray (4, Dreg);\n+\t\t\t\t\t      PtrTo Corereg |];\n+                              Use_operands [| VecArray (4, Dreg);\n+\t\t\t\t\t      PtrTo Corereg |]]],\n+     Use_operands [| PtrTo Corereg; VecArray (4, Qreg) |], \"vst4Q\",\n+      store_1, pf_su_8_32;\n+\n+    Vstx_lane 4,\n+      [Disassembles_as [Use_operands\n+        [| VecArray (4, Element_of_dreg);\n+           CstPtrTo Corereg |]]],\n+      Use_operands [| PtrTo Corereg; VecArray (4, Dreg); Immed |], \"vst4_lane\",\n+      store_3, P8 :: P16 :: F32 :: su_8_32;\n+    Vstx_lane 4,\n+      [Disassembles_as [Use_operands\n+        [| VecArray (4, Element_of_dreg);\n+           CstPtrTo Corereg |]]],\n+      Use_operands [| PtrTo Corereg; VecArray (4, Qreg); Immed |], \"vst4Q_lane\",\n+      store_3, [P16; F32; U16; U32; S16; S32];\n+\n+    (* Logical operations. And.  *)\n+    Vand, [], All (3, Dreg), \"vand\", notype_2, su_8_64;\n+    Vand, [], All (3, Qreg), \"vandQ\", notype_2, su_8_64;\n+\n+    (* Or.  *)\n+    Vorr, [], All (3, Dreg), \"vorr\", notype_2, su_8_64;\n+    Vorr, [], All (3, Qreg), \"vorrQ\", notype_2, su_8_64;\n+\n+    (* Eor.  *)\n+    Veor, [], All (3, Dreg), \"veor\", notype_2, su_8_64;\n+    Veor, [], All (3, Qreg), \"veorQ\", notype_2, su_8_64;\n+\n+    (* Bic (And-not).  *)\n+    Vbic, [], All (3, Dreg), \"vbic\", notype_2, su_8_64;\n+    Vbic, [], All (3, Qreg), \"vbicQ\", notype_2, su_8_64;\n+\n+    (* Or-not.  *)\n+    Vorn, [], All (3, Dreg), \"vorn\", notype_2, su_8_64;\n+    Vorn, [], All (3, Qreg), \"vornQ\", notype_2, su_8_64;\n+  ]\n+\n+let reinterp =\n+  let elems = P8 :: P16 :: F32 :: su_8_64 in\n+  List.fold_right\n+    (fun convto acc ->\n+      let types = List.fold_right\n+        (fun convfrom acc ->\n+          if convfrom <> convto then\n+            Cast (convto, convfrom) :: acc\n+          else\n+            acc)\n+        elems\n+        []\n+      in\n+        let dconv = Vreinterp, [No_op], Use_operands [| Dreg; Dreg |],\n+                      \"vreinterpret\", conv_1, types\n+        and qconv = Vreinterp, [No_op], Use_operands [| Qreg; Qreg |],\n+\t\t      \"vreinterpretQ\", conv_1, types in\n+        dconv :: qconv :: acc)\n+    elems\n+    []\n+\n+(* Output routines.  *)\n+\n+let rec string_of_elt = function\n+    S8 -> \"s8\" | S16 -> \"s16\" | S32 -> \"s32\" | S64 -> \"s64\"\n+  | U8 -> \"u8\" | U16 -> \"u16\" | U32 -> \"u32\" | U64 -> \"u64\"\n+  | I8 -> \"i8\" | I16 -> \"i16\" | I32 -> \"i32\" | I64 -> \"i64\"\n+  | B8 -> \"8\" | B16 -> \"16\" | B32 -> \"32\" | B64 -> \"64\"\n+  | F32 -> \"f32\" | P8 -> \"p8\" | P16 -> \"p16\"\n+  | Conv (a, b) | Cast (a, b) -> string_of_elt a ^ \"_\" ^ string_of_elt b\n+  | NoElts -> failwith \"No elts\"\n+\n+let string_of_elt_dots elt =\n+  match elt with\n+    Conv (a, b) | Cast (a, b) -> string_of_elt a ^ \".\" ^ string_of_elt b\n+  | _ -> string_of_elt elt\n+\n+let string_of_vectype vt =\n+  let rec name affix = function\n+    T_int8x8 -> affix \"int8x8\"\n+  | T_int8x16 -> affix \"int8x16\"\n+  | T_int16x4 -> affix \"int16x4\"\n+  | T_int16x8 -> affix \"int16x8\"\n+  | T_int32x2 -> affix \"int32x2\"\n+  | T_int32x4 -> affix \"int32x4\"\n+  | T_int64x1 -> affix \"int64x1\"\n+  | T_int64x2 -> affix \"int64x2\"\n+  | T_uint8x8 -> affix \"uint8x8\"\n+  | T_uint8x16 -> affix \"uint8x16\"\n+  | T_uint16x4 -> affix \"uint16x4\"\n+  | T_uint16x8 -> affix \"uint16x8\"\n+  | T_uint32x2 -> affix \"uint32x2\"\n+  | T_uint32x4 -> affix \"uint32x4\"\n+  | T_uint64x1 -> affix \"uint64x1\"\n+  | T_uint64x2 -> affix \"uint64x2\"\n+  | T_float32x2 -> affix \"float32x2\"\n+  | T_float32x4 -> affix \"float32x4\"\n+  | T_poly8x8 -> affix \"poly8x8\"\n+  | T_poly8x16 -> affix \"poly8x16\"\n+  | T_poly16x4 -> affix \"poly16x4\"\n+  | T_poly16x8 -> affix \"poly16x8\"\n+  | T_int8 -> affix \"int8\"\n+  | T_int16 -> affix \"int16\"\n+  | T_int32 -> affix \"int32\"\n+  | T_int64 -> affix \"int64\"\n+  | T_uint8 -> affix \"uint8\"\n+  | T_uint16 -> affix \"uint16\"\n+  | T_uint32 -> affix \"uint32\"\n+  | T_uint64 -> affix \"uint64\"\n+  | T_poly8 -> affix \"poly8\"\n+  | T_poly16 -> affix \"poly16\"\n+  | T_float32 -> affix \"float32\"\n+  | T_immediate _ -> \"const int\"\n+  | T_void -> \"void\"\n+  | T_intQI -> \"__builtin_neon_qi\"\n+  | T_intHI -> \"__builtin_neon_hi\"\n+  | T_intSI -> \"__builtin_neon_si\"\n+  | T_intDI -> \"__builtin_neon_di\"\n+  | T_arrayof (num, base) ->\n+      let basename = name (fun x -> x) base in\n+      affix (Printf.sprintf \"%sx%d\" basename num)\n+  | T_ptrto x ->\n+      let basename = name affix x in\n+      Printf.sprintf \"%s *\" basename\n+  | T_const x ->\n+      let basename = name affix x in\n+      Printf.sprintf \"const %s\" basename\n+  in\n+    name (fun x -> x ^ \"_t\") vt\n+\n+let string_of_inttype = function\n+    B_TImode -> \"__builtin_neon_ti\"\n+  | B_EImode -> \"__builtin_neon_ei\"\n+  | B_OImode -> \"__builtin_neon_oi\"\n+  | B_CImode -> \"__builtin_neon_ci\"\n+  | B_XImode -> \"__builtin_neon_xi\"\n+\n+let string_of_mode = function\n+    V8QI -> \"v8qi\" | V4HI  -> \"v4hi\"  | V2SI -> \"v2si\" | V2SF -> \"v2sf\"\n+  | DI   -> \"di\"   | V16QI -> \"v16qi\" | V8HI -> \"v8hi\" | V4SI -> \"v4si\"\n+  | V4SF -> \"v4sf\" | V2DI  -> \"v2di\"  | QI -> \"qi\" | HI -> \"hi\" | SI -> \"si\"\n+  | SF -> \"sf\"\n+\n+(* Use uppercase chars for letters which form part of the intrinsic name, but\n+   should be omitted from the builtin name (the info is passed in an extra\n+   argument, instead).  *)\n+let intrinsic_name name = String.lowercase name\n+\n+(* Allow the name of the builtin to be overridden by things (e.g. Flipped)\n+   found in the features list.  *)\n+let builtin_name features name =\n+  let name = List.fold_right\n+               (fun el name ->\n+                 match el with\n+                   Flipped x | Builtin_name x -> x\n+                 | _ -> name)\n+               features name in\n+  let islower x = let str = String.make 1 x in (String.lowercase str) = str\n+  and buf = Buffer.create (String.length name) in\n+  String.iter (fun c -> if islower c then Buffer.add_char buf c) name;\n+  Buffer.contents buf\n+\n+(* Transform an arity into a list of strings.  *)\n+let strings_of_arity a =\n+  match a with\n+  | Arity0 vt -> [string_of_vectype vt]\n+  | Arity1 (vt1, vt2) -> [string_of_vectype vt1; string_of_vectype vt2]\n+  | Arity2 (vt1, vt2, vt3) -> [string_of_vectype vt1;\n+\t\t\t       string_of_vectype vt2;\n+                               string_of_vectype vt3]\n+  | Arity3 (vt1, vt2, vt3, vt4) -> [string_of_vectype vt1;\n+                                    string_of_vectype vt2;\n+                                    string_of_vectype vt3;\n+                                    string_of_vectype vt4]\n+  | Arity4 (vt1, vt2, vt3, vt4, vt5) -> [string_of_vectype vt1;\n+                                         string_of_vectype vt2;\n+                                         string_of_vectype vt3;\n+                                         string_of_vectype vt4;\n+                                         string_of_vectype vt5]\n+\n+(* Suffixes on the end of builtin names that are to be stripped in order\n+   to obtain the name used as an instruction.  They are only stripped if\n+   preceded immediately by an underscore.  *)\n+let suffixes_to_strip = [ \"n\"; \"lane\"; \"dup\" ]\n+\n+(* Get the possible names of an instruction corresponding to a \"name\" from the\n+   ops table.  This is done by getting the equivalent builtin name and\n+   stripping any suffixes from the list at the top of this file, unless\n+   the features list presents with an Instruction_name entry, in which\n+   case that is used; or unless the features list presents with a Flipped\n+   entry, in which case that is used.  If both such entries are present,\n+   the first in the list will be chosen.  *)\n+let get_insn_names features name =\n+  let names = try\n+  begin\n+    match List.find (fun feature -> match feature with\n+                                      Instruction_name _ -> true\n+\t\t\t\t    | Flipped _ -> true\n+\t\t\t\t    | _ -> false) features\n+    with\n+      Instruction_name names -> names\n+    | Flipped name -> [name]\n+    | _ -> assert false\n+  end\n+  with Not_found -> [builtin_name features name]\n+  in\n+  begin\n+    List.map (fun name' ->\n+      try\n+        let underscore = String.rindex name' '_' in\n+        let our_suffix = String.sub name' (underscore + 1)\n+                                    ((String.length name') - underscore - 1)\n+        in\n+          let rec strip remaining_suffixes =\n+            match remaining_suffixes with\n+              [] -> name'\n+            | s::ss when our_suffix = s -> String.sub name' 0 underscore\n+            | _::ss -> strip ss\n+          in\n+            strip suffixes_to_strip\n+      with (Not_found | Invalid_argument _) -> name') names\n+  end\n+\n+(* Apply a function to each element of a list and then comma-separate\n+   the resulting strings.  *)\n+let rec commas f elts acc =\n+  match elts with\n+    [] -> acc\n+  | [elt] -> acc ^ (f elt)\n+  | elt::elts ->\n+    commas f elts (acc ^ (f elt) ^ \", \")\n+\n+(* Given a list of features and the shape specified in the \"ops\" table, apply\n+   a function to each possible shape that the instruction may have.\n+   By default, this is the \"shape\" entry in \"ops\".  If the features list\n+   contains a Disassembles_as entry, the shapes contained in that entry are\n+   mapped to corresponding outputs and returned in a list.  If there is more\n+   than one Disassembles_as entry, only the first is used.  *)\n+let analyze_all_shapes features shape f =\n+  try\n+    match List.find (fun feature ->\n+                       match feature with Disassembles_as _ -> true\n+                                        | _ -> false)\n+                    features with\n+      Disassembles_as shapes -> List.map f shapes\n+    | _ -> assert false\n+  with Not_found -> [f shape]\n+"}, {"sha": "b8d154d2ce10a1ca8f7cd05771eaa2155d140f0e", "filename": "gcc/config/arm/predicates.md", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Fconfig%2Farm%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Fconfig%2Farm%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fpredicates.md?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -470,3 +470,43 @@\n        (match_test \"((unsigned HOST_WIDE_INT) INTVAL (op)) < 64\")))\n \n \n+;; Neon predicates\n+\n+(define_predicate \"const_multiple_of_8_operand\"\n+  (match_code \"const_int\")\n+{\n+  unsigned HOST_WIDE_INT val = INTVAL (op);\n+  return (val & 7) == 0;\n+})\n+\n+(define_predicate \"imm_for_neon_mov_operand\"\n+  (match_code \"const_vector\")\n+{\n+  return neon_immediate_valid_for_move (op, mode, NULL, NULL);\n+})\n+\n+(define_predicate \"imm_for_neon_logic_operand\"\n+  (match_code \"const_vector\")\n+{\n+  return neon_immediate_valid_for_logic (op, mode, 0, NULL, NULL);\n+})\n+\n+(define_predicate \"imm_for_neon_inv_logic_operand\"\n+  (match_code \"const_vector\")\n+{\n+  return neon_immediate_valid_for_logic (op, mode, 1, NULL, NULL);\n+})\n+\n+(define_predicate \"neon_logic_op2\"\n+  (ior (match_operand 0 \"imm_for_neon_logic_operand\")\n+       (match_operand 0 \"s_register_operand\")))\n+\n+(define_predicate \"neon_inv_logic_op2\"\n+  (ior (match_operand 0 \"imm_for_neon_inv_logic_operand\")\n+       (match_operand 0 \"s_register_operand\")))\n+\n+;; TODO: We could check lane numbers more precisely based on the mode.\n+(define_predicate \"neon_lane_number\"\n+  (and (match_code \"const_int\")\n+       (match_test \"INTVAL (op) >= 0 && INTVAL (op) <= 7\")))\n+"}, {"sha": "cde00ee3407cecdb1e9d54d4d8bf160059194fc4", "filename": "gcc/config/arm/t-arm", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Fconfig%2Farm%2Ft-arm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Fconfig%2Farm%2Ft-arm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-arm?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -9,8 +9,10 @@ MD_INCLUDES= \t$(srcdir)/config/arm/arm-tune.md \\\n \t\t$(srcdir)/config/arm/arm926ejs.md \\\n \t\t$(srcdir)/config/arm/cirrus.md \\\n \t\t$(srcdir)/config/arm/fpa.md \\\n+\t\t$(srcdir)/config/arm/vec-common.md \\\n \t\t$(srcdir)/config/arm/iwmmxt.md \\\n \t\t$(srcdir)/config/arm/vfp.md \\\n+\t\t$(srcdir)/config/arm/neon.md \\\n \t\t$(srcdir)/config/arm/thumb2.md\n \n s-config s-conditions s-flags s-codes s-constants s-emit s-recog s-preds \\"}, {"sha": "0514b81e55cc86c75e8cb14ae5ae8e3bbd467267", "filename": "gcc/config/arm/vec-common.md", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Fconfig%2Farm%2Fvec-common.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Fconfig%2Farm%2Fvec-common.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvec-common.md?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,107 @@\n+;; Machine Description for shared bits common to IWMMXT and Neon.\n+;; Copyright (C) 2006 Free Software Foundation, Inc.\n+;; Written by CodeSourcery.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but\n+;; WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+;; General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to the Free\n+;; Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+;; 02110-1301, USA.\n+\n+;; Vector Moves\n+\n+;; All integer and float modes supported by Neon and IWMMXT.\n+(define_mode_macro VALL [V2DI V2SI V4HI V8QI V2SF V4SI V8HI V16QI V4SF])\n+\n+;; All integer and float modes supported by Neon and IWMMXT, except V2DI.\n+(define_mode_macro VALLW [V2SI V4HI V8QI V2SF V4SI V8HI V16QI V4SF])\n+\n+;; All integer modes supported by Neon and IWMMXT\n+(define_mode_macro VINT [V2DI V2SI V4HI V8QI V4SI V8HI V16QI])\n+\n+;; All integer modes supported by Neon and IWMMXT, except V2DI\n+(define_mode_macro VINTW [V2SI V4HI V8QI V4SI V8HI V16QI])\n+\n+(define_expand \"mov<mode>\"\n+  [(set (match_operand:VALL 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:VALL 1 \"general_operand\" \"\"))]\n+  \"TARGET_NEON\n+   || (TARGET_REALLY_IWMMXT && VALID_IWMMXT_REG_MODE (<MODE>mode))\"\n+{\n+})\n+\n+;; Vector arithmetic. Expanders are blank, then unnamed insns implement\n+;; patterns seperately for IWMMXT and Neon.\n+\n+(define_expand \"add<mode>3\"\n+  [(set (match_operand:VALL 0 \"s_register_operand\" \"\")\n+        (plus:VALL (match_operand:VALL 1 \"s_register_operand\" \"\")\n+                   (match_operand:VALL 2 \"s_register_operand\" \"\")))]\n+  \"TARGET_NEON\n+   || (TARGET_REALLY_IWMMXT && VALID_IWMMXT_REG_MODE (<MODE>mode))\"\n+{\n+})\n+\n+(define_expand \"sub<mode>3\"\n+  [(set (match_operand:VALL 0 \"s_register_operand\" \"\")\n+        (minus:VALL (match_operand:VALL 1 \"s_register_operand\" \"\")\n+                    (match_operand:VALL 2 \"s_register_operand\" \"\")))]\n+  \"TARGET_NEON\n+   || (TARGET_REALLY_IWMMXT && VALID_IWMMXT_REG_MODE (<MODE>mode))\"\n+{\n+})\n+\n+(define_expand \"mul<mode>3\"\n+  [(set (match_operand:VALLW 0 \"s_register_operand\" \"\")\n+        (mult:VALLW (match_operand:VALLW 1 \"s_register_operand\" \"\")\n+\t\t    (match_operand:VALLW 2 \"s_register_operand\" \"\")))]\n+  \"TARGET_NEON || (<MODE>mode == V4HImode && TARGET_REALLY_IWMMXT)\"\n+{\n+})\n+\n+(define_expand \"smin<mode>3\"\n+  [(set (match_operand:VALLW 0 \"s_register_operand\" \"\")\n+\t(smin:VALLW (match_operand:VALLW 1 \"s_register_operand\" \"\")\n+\t\t    (match_operand:VALLW 2 \"s_register_operand\" \"\")))]\n+  \"TARGET_NEON\n+   || (TARGET_REALLY_IWMMXT && VALID_IWMMXT_REG_MODE (<MODE>mode))\"\n+{\n+})\n+\n+(define_expand \"umin<mode>3\"\n+  [(set (match_operand:VINTW 0 \"s_register_operand\" \"\")\n+\t(umin:VINTW (match_operand:VINTW 1 \"s_register_operand\" \"\")\n+\t\t    (match_operand:VINTW 2 \"s_register_operand\" \"\")))]\n+  \"TARGET_NEON\n+   || (TARGET_REALLY_IWMMXT && VALID_IWMMXT_REG_MODE (<MODE>mode))\"\n+{\n+})\n+\n+(define_expand \"smax<mode>3\"\n+  [(set (match_operand:VALLW 0 \"s_register_operand\" \"\")\n+\t(smax:VALLW (match_operand:VALLW 1 \"s_register_operand\" \"\")\n+\t\t    (match_operand:VALLW 2 \"s_register_operand\" \"\")))]\n+  \"TARGET_NEON\n+   || (TARGET_REALLY_IWMMXT && VALID_IWMMXT_REG_MODE (<MODE>mode))\"\n+{\n+})\n+\n+(define_expand \"umax<mode>3\"\n+  [(set (match_operand:VINTW 0 \"s_register_operand\" \"\")\n+\t(umax:VINTW (match_operand:VINTW 1 \"s_register_operand\" \"\")\n+\t\t    (match_operand:VINTW 2 \"s_register_operand\" \"\")))]\n+  \"TARGET_NEON\n+   || (TARGET_REALLY_IWMMXT && VALID_IWMMXT_REG_MODE (<MODE>mode))\"\n+{\n+})"}, {"sha": "c35662c01e98f0b1e808f5a2e34bd18789f4cd24", "filename": "gcc/doc/arm-neon-intrinsics.texi", "status": "added", "additions": 11293, "deletions": 0, "changes": 11293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Fdoc%2Farm-neon-intrinsics.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Fdoc%2Farm-neon-intrinsics.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Farm-neon-intrinsics.texi?ref=88f77cba027fa1be471081bcd2ec03392246af3a"}, {"sha": "95d25caa2350cecc3250cebc553c0bd92df5fed2", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -6404,7 +6404,8 @@ instructions, but allow the compiler to schedule those calls.\n \n @menu\n * Alpha Built-in Functions::\n-* ARM Built-in Functions::\n+* ARM iWMMXt Built-in Functions::\n+* ARM NEON Intrinsics::\n * Blackfin Built-in Functions::\n * FR-V Built-in Functions::\n * X86 Built-in Functions::\n@@ -6497,11 +6498,11 @@ void *__builtin_thread_pointer (void)\n void __builtin_set_thread_pointer (void *)\n @end smallexample\n \n-@node ARM Built-in Functions\n-@subsection ARM Built-in Functions\n+@node ARM iWMMXt Built-in Functions\n+@subsection ARM iWMMXt Built-in Functions\n \n These built-in functions are available for the ARM family of\n-processors, when the @option{-mcpu=iwmmxt} switch is used:\n+processors when the @option{-mcpu=iwmmxt} switch is used:\n \n @smallexample\n typedef int v2si __attribute__ ((vector_size (8)));\n@@ -6644,6 +6645,14 @@ long long __builtin_arm_wxor (long long, long long)\n long long __builtin_arm_wzero ()\n @end smallexample\n \n+@node ARM NEON Intrinsics\n+@subsection ARM NEON Intrinsics\n+\n+These built-in intrinsics for the ARM Advanced SIMD extension are available\n+when the @option{-mfpu=neon} switch is used:\n+\n+@include arm-neon-intrinsics.texi\n+\n @node Blackfin Built-in Functions\n @subsection Blackfin Built-in Functions\n "}, {"sha": "80fe92f6e0b4858648074278d858c71aca978f6a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -1,3 +1,17 @@\n+2007-07-25  Julian Brown  <julian@codesourcery.com>\n+\t    Paul Brook  <paul@codesourcery.com>\n+\t    Joseph Myers  <joseph@codesourcery.com>\n+\t    Mark Shinwell  <shinwell@codesourcery.com>\n+\n+\t* gcc.dg/vect/vect.exp: Check is-effective-target arm_neon_hw.\n+\t* gcc.dg/vect/tree-vect.h: Check for NEON SIMD support.\n+\t* lib/gcc-dg.exp (cleanup-saved-temps): Fix comment.\n+\t* lib/target-supports.exp (check_effective_target_arm_neon_ok)\n+\t(check_effective_target_arm_neon_hw): New.\n+\t* gcc.target/arm/neon/neon.exp: New file.\n+\t* gcc.target/arm/neon/polytypes.c: New file.\n+\t* gcc.target/arm/neon/v*.c (1870 files): New (autogenerated).\n+\n 2007-07-25  Janis Johnson  <janis187@us.ibm.com>\n \n \t* gcc.c-torture/unsorted/dump-noaddr.c: Reduce string length for"}, {"sha": "9f88f8baba389ee6783331473758c17633a301cc", "filename": "gcc/testsuite/g++.dg/abi/mangle-neon.C", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle-neon.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle-neon.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle-neon.C?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,47 @@\n+// Test that ARM NEON vector types have their names mangled correctly. \n+\n+// { dg-do compile }\n+// { dg-require-effective-target arm_neon_ok }\n+// { dg-options \"-mfpu=neon -mfloat-abi=softfp\" }\n+\n+#include <arm_neon.h>\n+\n+void f0 (int8x8_t a) {}\n+void f1 (int16x4_t a) {}\n+void f2 (int32x2_t a) {}\n+void f3 (uint8x8_t a) {}\n+void f4 (uint16x4_t a) {}\n+void f5 (uint32x2_t a) {}\n+void f6 (float32x2_t a) {}\n+void f7 (poly8x8_t a) {}\n+void f8 (poly16x4_t a) {}\n+\n+void f9 (int8x16_t a) {}\n+void f10 (int16x8_t a) {}\n+void f11 (int32x4_t a) {}\n+void f12 (uint8x16_t a) {}\n+void f13 (uint16x8_t a) {}\n+void f14 (uint32x4_t a) {}\n+void f15 (float32x4_t a) {}\n+void f16 (poly8x16_t a) {}\n+void f17 (poly16x8_t a) {}\n+\n+// { dg-final { scan-assembler \"_Z2f015__simd64_int8_t:\" } }\n+// { dg-final { scan-assembler \"_Z2f116__simd64_int16_t:\" } }\n+// { dg-final { scan-assembler \"_Z2f216__simd64_int32_t:\" } }\n+// { dg-final { scan-assembler \"_Z2f316__simd64_uint8_t:\" } }\n+// { dg-final { scan-assembler \"_Z2f417__simd64_uint16_t:\" } }\n+// { dg-final { scan-assembler \"_Z2f517__simd64_uint32_t:\" } }\n+// { dg-final { scan-assembler \"_Z2f618__simd64_float32_t:\" } }\n+// { dg-final { scan-assembler \"_Z2f716__simd64_poly8_t:\" } }\n+// { dg-final { scan-assembler \"_Z2f817__simd64_poly16_t:\" } }\n+// { dg-final { scan-assembler \"_Z2f916__simd128_int8_t:\" } }\n+// { dg-final { scan-assembler \"_Z3f1017__simd128_int16_t:\" } }\n+// { dg-final { scan-assembler \"_Z3f1117__simd128_int32_t:\" } }\n+// { dg-final { scan-assembler \"_Z3f1217__simd128_uint8_t:\" } }\n+// { dg-final { scan-assembler \"_Z3f1318__simd128_uint16_t:\" } }\n+// { dg-final { scan-assembler \"_Z3f1418__simd128_uint32_t:\" } }\n+// { dg-final { scan-assembler \"_Z3f1519__simd128_float32_t:\" } }\n+// { dg-final { scan-assembler \"_Z3f1617__simd128_poly8_t:\" } }\n+// { dg-final { scan-assembler \"_Z3f1718__simd128_poly16_t:\" } }\n+"}, {"sha": "76e7ff4557ddaa1b21bab8515afa24e741ff4ede", "filename": "gcc/testsuite/gcc.dg/vect/tree-vect.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ftree-vect.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ftree-vect.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ftree-vect.h?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -21,6 +21,18 @@ void check_vect (void)\n   asm volatile (\".byte 0xf2,0x0f,0x10,0xc0\");\n #elif defined(__sparc__)\n   asm volatile (\".word\\t0x81b007c0\");\n+#elif defined(__arm__)\n+  {\n+    /* On some processors without NEON support, this instruction may\n+       be a no-op, on others it may trap, so check that it executes\n+       correctly.  */\n+    long long a = 0, b = 1;\n+    asm (\"vorr %P0, %P1, %P2\"\n+\t : \"=w\" (a)\n+\t : \"0\" (a), \"w\" (b));\n+    if (a != 1)\n+      exit (0);\n+  }\n #endif\n   signal (SIGILL, SIG_DFL);\n }"}, {"sha": "0a9ce6b880e86eef76b0394091eb5c5bc1ff0610", "filename": "gcc/testsuite/gcc.dg/vect/vect.exp", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -83,6 +83,13 @@ if [istarget \"powerpc*-*-*\"] {\n     }\n } elseif [istarget \"ia64-*-*\"] {\n     set dg-do-what-default run\n+} elseif [is-effective-target arm_neon_ok] {\n+    lappend DEFAULT_VECTCFLAGS \"-mfpu=neon\" \"-mfloat-abi=softfp\"\n+    if [is-effective-target arm_neon_hw] {\n+      set dg-do-what-default run\n+    } else {\n+      set dg-do-what-default compile\n+    }\n } else {\n     return\n }"}, {"sha": "9d7fd2d5bb729c825c3d4e1da6661b5fa03b0328", "filename": "gcc/testsuite/gcc.target/arm/neon/neon.exp", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fneon.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fneon.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fneon.exp?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,35 @@\n+# Copyright (C) 1997, 2004, 2006 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, write to the Free Software\n+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n+\n+# GCC testsuite that uses the `dg.exp' driver.\n+\n+# Exit immediately if this isn't an ARM target.\n+if ![istarget arm*-*-*] then {\n+  return\n+}\n+\n+# Load support procs.\n+load_lib gcc-dg.exp\n+\n+# Initialize `dg'.\n+dg-init\n+\n+# Main loop.\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.\\[cCS\\]]] \\\n+\t\"\" \"\"\n+\n+# All done.\n+dg-finish"}, {"sha": "9aca6671ae0ef637fe3184e9e994dd7bdaf26af6", "filename": "gcc/testsuite/gcc.target/arm/neon/polytypes.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fpolytypes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fpolytypes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fpolytypes.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,47 @@\n+/* Check that NEON polynomial vector types are suitably incompatible with\n+   integer vector types of the same layout.  */\n+\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include <arm_neon.h>\n+\n+void s64_8 (int8x8_t a) {}\n+void u64_8 (uint8x8_t a) {}\n+void p64_8 (poly8x8_t a) {}\n+void s64_16 (int16x4_t a) {}\n+void u64_16 (uint16x4_t a) {}\n+void p64_16 (poly16x4_t a) {}\n+\n+void s128_8 (int8x16_t a) {}\n+void u128_8 (uint8x16_t a) {}\n+void p128_8 (poly8x16_t a) {}\n+void s128_16 (int16x8_t a) {}\n+void u128_16 (uint16x8_t a) {}\n+void p128_16 (poly16x8_t a) {}\n+\n+void foo ()\n+{\n+  poly8x8_t v64_8;\n+  poly16x4_t v64_16;\n+  poly8x16_t v128_8;\n+  poly16x8_t v128_16;\n+\n+  s64_8 (v64_8); /* { dg-error \"use -flax-vector-conversions.*incompatible type for argument 1 of 's64_8'\" } */\n+  u64_8 (v64_8); /* { dg-error \"incompatible type for argument 1 of 'u64_8'\" } */\n+  p64_8 (v64_8);\n+\n+  s64_16 (v64_16); /* { dg-error \"incompatible type for argument 1 of 's64_16'\" } */\n+  u64_16 (v64_16); /* { dg-error \"incompatible type for argument 1 of 'u64_16'\" } */\n+  p64_16 (v64_16);\n+\n+  s128_8 (v128_8); /* { dg-error \"incompatible type for argument 1 of 's128_8'\" } */\n+  u128_8 (v128_8); /* { dg-error \"incompatible type for argument 1 of 'u128_8'\" } */\n+  p128_8 (v128_8);\n+\n+  s128_16 (v128_16); /* { dg-error \"incompatible type for argument 1 of 's128_16'\" } */\n+  u128_16 (v128_16); /* { dg-error \"incompatible type for argument 1 of 'u128_16'\" } */\n+  p128_16 (v128_16);\n+}\n+"}, {"sha": "68834af066f9433c4209e333cbf64a3c51a15928", "filename": "gcc/testsuite/gcc.target/arm/neon/vRaddhns16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRaddhns16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRaddhns16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRaddhns16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRaddhns16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRaddhns16 (void)\n+{\n+  int8x8_t out_int8x8_t;\n+  int16x8_t arg0_int16x8_t;\n+  int16x8_t arg1_int16x8_t;\n+\n+  out_int8x8_t = vraddhn_s16 (arg0_int16x8_t, arg1_int16x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vraddhn\\.i16\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "afa4307f35ae486f5b36ef84efbcf9b9c7462b90", "filename": "gcc/testsuite/gcc.target/arm/neon/vRaddhns32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRaddhns32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRaddhns32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRaddhns32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRaddhns32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRaddhns32 (void)\n+{\n+  int16x4_t out_int16x4_t;\n+  int32x4_t arg0_int32x4_t;\n+  int32x4_t arg1_int32x4_t;\n+\n+  out_int16x4_t = vraddhn_s32 (arg0_int32x4_t, arg1_int32x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vraddhn\\.i32\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "efa777cd0070aab44a4d3f4f174d8965312d40eb", "filename": "gcc/testsuite/gcc.target/arm/neon/vRaddhns64.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRaddhns64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRaddhns64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRaddhns64.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRaddhns64' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRaddhns64 (void)\n+{\n+  int32x2_t out_int32x2_t;\n+  int64x2_t arg0_int64x2_t;\n+  int64x2_t arg1_int64x2_t;\n+\n+  out_int32x2_t = vraddhn_s64 (arg0_int64x2_t, arg1_int64x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vraddhn\\.i64\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "2406ba6142c7985eacd57ac03058e0d4ea30735e", "filename": "gcc/testsuite/gcc.target/arm/neon/vRaddhnu16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRaddhnu16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRaddhnu16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRaddhnu16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRaddhnu16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRaddhnu16 (void)\n+{\n+  uint8x8_t out_uint8x8_t;\n+  uint16x8_t arg0_uint16x8_t;\n+  uint16x8_t arg1_uint16x8_t;\n+\n+  out_uint8x8_t = vraddhn_u16 (arg0_uint16x8_t, arg1_uint16x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vraddhn\\.i16\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "3266f8b162bd582d9a68958c81e09041642acfe5", "filename": "gcc/testsuite/gcc.target/arm/neon/vRaddhnu32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRaddhnu32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRaddhnu32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRaddhnu32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRaddhnu32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRaddhnu32 (void)\n+{\n+  uint16x4_t out_uint16x4_t;\n+  uint32x4_t arg0_uint32x4_t;\n+  uint32x4_t arg1_uint32x4_t;\n+\n+  out_uint16x4_t = vraddhn_u32 (arg0_uint32x4_t, arg1_uint32x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vraddhn\\.i32\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "e77356f2720347562a236894c55575bb4384ce89", "filename": "gcc/testsuite/gcc.target/arm/neon/vRaddhnu64.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRaddhnu64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRaddhnu64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRaddhnu64.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRaddhnu64' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRaddhnu64 (void)\n+{\n+  uint32x2_t out_uint32x2_t;\n+  uint64x2_t arg0_uint64x2_t;\n+  uint64x2_t arg1_uint64x2_t;\n+\n+  out_uint32x2_t = vraddhn_u64 (arg0_uint64x2_t, arg1_uint64x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vraddhn\\.i64\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "dae4fe9b69be285b9ecf67b85f43d592ce5fb0ff", "filename": "gcc/testsuite/gcc.target/arm/neon/vRhaddQs16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRhaddQs16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRhaddQs16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRhaddQs16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRhaddQs16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRhaddQs16 (void)\n+{\n+  int16x8_t out_int16x8_t;\n+  int16x8_t arg0_int16x8_t;\n+  int16x8_t arg1_int16x8_t;\n+\n+  out_int16x8_t = vrhaddq_s16 (arg0_int16x8_t, arg1_int16x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vrhadd\\.s16\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "bcd72ab60f8e9076d4c71414e3bf15c2a7fe6a4d", "filename": "gcc/testsuite/gcc.target/arm/neon/vRhaddQs32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRhaddQs32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRhaddQs32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRhaddQs32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRhaddQs32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRhaddQs32 (void)\n+{\n+  int32x4_t out_int32x4_t;\n+  int32x4_t arg0_int32x4_t;\n+  int32x4_t arg1_int32x4_t;\n+\n+  out_int32x4_t = vrhaddq_s32 (arg0_int32x4_t, arg1_int32x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vrhadd\\.s32\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "0c5874e131f88e2333348025fa4db1a256babd2c", "filename": "gcc/testsuite/gcc.target/arm/neon/vRhaddQs8.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRhaddQs8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRhaddQs8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRhaddQs8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRhaddQs8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRhaddQs8 (void)\n+{\n+  int8x16_t out_int8x16_t;\n+  int8x16_t arg0_int8x16_t;\n+  int8x16_t arg1_int8x16_t;\n+\n+  out_int8x16_t = vrhaddq_s8 (arg0_int8x16_t, arg1_int8x16_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vrhadd\\.s8\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "1752110915ffc23f9a813a567e9610ed95c359be", "filename": "gcc/testsuite/gcc.target/arm/neon/vRhaddQu16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRhaddQu16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRhaddQu16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRhaddQu16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRhaddQu16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRhaddQu16 (void)\n+{\n+  uint16x8_t out_uint16x8_t;\n+  uint16x8_t arg0_uint16x8_t;\n+  uint16x8_t arg1_uint16x8_t;\n+\n+  out_uint16x8_t = vrhaddq_u16 (arg0_uint16x8_t, arg1_uint16x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vrhadd\\.u16\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "92fb399116f586030978099f1c0a0d1b25bc268c", "filename": "gcc/testsuite/gcc.target/arm/neon/vRhaddQu32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRhaddQu32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRhaddQu32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRhaddQu32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRhaddQu32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRhaddQu32 (void)\n+{\n+  uint32x4_t out_uint32x4_t;\n+  uint32x4_t arg0_uint32x4_t;\n+  uint32x4_t arg1_uint32x4_t;\n+\n+  out_uint32x4_t = vrhaddq_u32 (arg0_uint32x4_t, arg1_uint32x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vrhadd\\.u32\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "39a8e0106ceea81f4814b8b391e64170aac941de", "filename": "gcc/testsuite/gcc.target/arm/neon/vRhaddQu8.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRhaddQu8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRhaddQu8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRhaddQu8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRhaddQu8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRhaddQu8 (void)\n+{\n+  uint8x16_t out_uint8x16_t;\n+  uint8x16_t arg0_uint8x16_t;\n+  uint8x16_t arg1_uint8x16_t;\n+\n+  out_uint8x16_t = vrhaddq_u8 (arg0_uint8x16_t, arg1_uint8x16_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vrhadd\\.u8\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "2a301d482d4d0fe70a619da17c8f823c4fe0f280", "filename": "gcc/testsuite/gcc.target/arm/neon/vRhadds16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRhadds16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRhadds16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRhadds16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRhadds16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRhadds16 (void)\n+{\n+  int16x4_t out_int16x4_t;\n+  int16x4_t arg0_int16x4_t;\n+  int16x4_t arg1_int16x4_t;\n+\n+  out_int16x4_t = vrhadd_s16 (arg0_int16x4_t, arg1_int16x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vrhadd\\.s16\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "91d6494e9372b82535883e83e72777fc33393b9d", "filename": "gcc/testsuite/gcc.target/arm/neon/vRhadds32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRhadds32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRhadds32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRhadds32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRhadds32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRhadds32 (void)\n+{\n+  int32x2_t out_int32x2_t;\n+  int32x2_t arg0_int32x2_t;\n+  int32x2_t arg1_int32x2_t;\n+\n+  out_int32x2_t = vrhadd_s32 (arg0_int32x2_t, arg1_int32x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vrhadd\\.s32\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "25703e55b93f4c8b2f39ae961c4452ad13b1220d", "filename": "gcc/testsuite/gcc.target/arm/neon/vRhadds8.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRhadds8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRhadds8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRhadds8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRhadds8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRhadds8 (void)\n+{\n+  int8x8_t out_int8x8_t;\n+  int8x8_t arg0_int8x8_t;\n+  int8x8_t arg1_int8x8_t;\n+\n+  out_int8x8_t = vrhadd_s8 (arg0_int8x8_t, arg1_int8x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vrhadd\\.s8\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "b655963d0785c9c9d387fc11bcf16c600b99e8be", "filename": "gcc/testsuite/gcc.target/arm/neon/vRhaddu16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRhaddu16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRhaddu16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRhaddu16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRhaddu16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRhaddu16 (void)\n+{\n+  uint16x4_t out_uint16x4_t;\n+  uint16x4_t arg0_uint16x4_t;\n+  uint16x4_t arg1_uint16x4_t;\n+\n+  out_uint16x4_t = vrhadd_u16 (arg0_uint16x4_t, arg1_uint16x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vrhadd\\.u16\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "7ab8d5b501755c8731d65f27b511030e3803b65b", "filename": "gcc/testsuite/gcc.target/arm/neon/vRhaddu32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRhaddu32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRhaddu32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRhaddu32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRhaddu32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRhaddu32 (void)\n+{\n+  uint32x2_t out_uint32x2_t;\n+  uint32x2_t arg0_uint32x2_t;\n+  uint32x2_t arg1_uint32x2_t;\n+\n+  out_uint32x2_t = vrhadd_u32 (arg0_uint32x2_t, arg1_uint32x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vrhadd\\.u32\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "8f1cae990648e52bde399b0806a5c9222a9e6747", "filename": "gcc/testsuite/gcc.target/arm/neon/vRhaddu8.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRhaddu8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRhaddu8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRhaddu8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRhaddu8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRhaddu8 (void)\n+{\n+  uint8x8_t out_uint8x8_t;\n+  uint8x8_t arg0_uint8x8_t;\n+  uint8x8_t arg1_uint8x8_t;\n+\n+  out_uint8x8_t = vrhadd_u8 (arg0_uint8x8_t, arg1_uint8x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vrhadd\\.u8\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "81c79b16f8f8410549d6b820bce70512a8bb97c4", "filename": "gcc/testsuite/gcc.target/arm/neon/vRshlQs16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshlQs16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshlQs16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshlQs16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRshlQs16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRshlQs16 (void)\n+{\n+  int16x8_t out_int16x8_t;\n+  int16x8_t arg0_int16x8_t;\n+  int16x8_t arg1_int16x8_t;\n+\n+  out_int16x8_t = vrshlq_s16 (arg0_int16x8_t, arg1_int16x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vrshl\\.s16\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "a91618cc082a580ab68c906478e1cdc01356120e", "filename": "gcc/testsuite/gcc.target/arm/neon/vRshlQs32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshlQs32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshlQs32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshlQs32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRshlQs32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRshlQs32 (void)\n+{\n+  int32x4_t out_int32x4_t;\n+  int32x4_t arg0_int32x4_t;\n+  int32x4_t arg1_int32x4_t;\n+\n+  out_int32x4_t = vrshlq_s32 (arg0_int32x4_t, arg1_int32x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vrshl\\.s32\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "f20de10fdf839722b7728078cf3facf92087ca7c", "filename": "gcc/testsuite/gcc.target/arm/neon/vRshlQs64.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshlQs64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshlQs64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshlQs64.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRshlQs64' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRshlQs64 (void)\n+{\n+  int64x2_t out_int64x2_t;\n+  int64x2_t arg0_int64x2_t;\n+  int64x2_t arg1_int64x2_t;\n+\n+  out_int64x2_t = vrshlq_s64 (arg0_int64x2_t, arg1_int64x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vrshl\\.s64\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "4c63dc470192be4f10e02168f84d4ca7684e1192", "filename": "gcc/testsuite/gcc.target/arm/neon/vRshlQs8.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshlQs8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshlQs8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshlQs8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRshlQs8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRshlQs8 (void)\n+{\n+  int8x16_t out_int8x16_t;\n+  int8x16_t arg0_int8x16_t;\n+  int8x16_t arg1_int8x16_t;\n+\n+  out_int8x16_t = vrshlq_s8 (arg0_int8x16_t, arg1_int8x16_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vrshl\\.s8\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "fe8981e1bf68201a1b503c7b35c36404a876ee1d", "filename": "gcc/testsuite/gcc.target/arm/neon/vRshlQu16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshlQu16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshlQu16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshlQu16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRshlQu16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRshlQu16 (void)\n+{\n+  uint16x8_t out_uint16x8_t;\n+  uint16x8_t arg0_uint16x8_t;\n+  int16x8_t arg1_int16x8_t;\n+\n+  out_uint16x8_t = vrshlq_u16 (arg0_uint16x8_t, arg1_int16x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vrshl\\.u16\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "cdb4c323f6d00257033e23329ce21d4467b37db4", "filename": "gcc/testsuite/gcc.target/arm/neon/vRshlQu32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshlQu32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshlQu32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshlQu32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRshlQu32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRshlQu32 (void)\n+{\n+  uint32x4_t out_uint32x4_t;\n+  uint32x4_t arg0_uint32x4_t;\n+  int32x4_t arg1_int32x4_t;\n+\n+  out_uint32x4_t = vrshlq_u32 (arg0_uint32x4_t, arg1_int32x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vrshl\\.u32\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "87715041566ff852276e7b08953415550bdf1808", "filename": "gcc/testsuite/gcc.target/arm/neon/vRshlQu64.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshlQu64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshlQu64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshlQu64.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRshlQu64' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRshlQu64 (void)\n+{\n+  uint64x2_t out_uint64x2_t;\n+  uint64x2_t arg0_uint64x2_t;\n+  int64x2_t arg1_int64x2_t;\n+\n+  out_uint64x2_t = vrshlq_u64 (arg0_uint64x2_t, arg1_int64x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vrshl\\.u64\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "6ab254e609c5055f783ccd05322cdc9650723d3b", "filename": "gcc/testsuite/gcc.target/arm/neon/vRshlQu8.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshlQu8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshlQu8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshlQu8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRshlQu8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRshlQu8 (void)\n+{\n+  uint8x16_t out_uint8x16_t;\n+  uint8x16_t arg0_uint8x16_t;\n+  int8x16_t arg1_int8x16_t;\n+\n+  out_uint8x16_t = vrshlq_u8 (arg0_uint8x16_t, arg1_int8x16_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vrshl\\.u8\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "e33198833ec8007767043c59d88344037faaa23a", "filename": "gcc/testsuite/gcc.target/arm/neon/vRshls16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshls16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshls16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshls16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRshls16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRshls16 (void)\n+{\n+  int16x4_t out_int16x4_t;\n+  int16x4_t arg0_int16x4_t;\n+  int16x4_t arg1_int16x4_t;\n+\n+  out_int16x4_t = vrshl_s16 (arg0_int16x4_t, arg1_int16x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vrshl\\.s16\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "2ba12c4aba76fea00c610df4fe831fae8e584700", "filename": "gcc/testsuite/gcc.target/arm/neon/vRshls32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshls32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshls32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshls32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRshls32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRshls32 (void)\n+{\n+  int32x2_t out_int32x2_t;\n+  int32x2_t arg0_int32x2_t;\n+  int32x2_t arg1_int32x2_t;\n+\n+  out_int32x2_t = vrshl_s32 (arg0_int32x2_t, arg1_int32x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vrshl\\.s32\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "360c0c1d1c37a5087730881da21f077a8afb8fe8", "filename": "gcc/testsuite/gcc.target/arm/neon/vRshls64.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshls64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshls64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshls64.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRshls64' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRshls64 (void)\n+{\n+  int64x1_t out_int64x1_t;\n+  int64x1_t arg0_int64x1_t;\n+  int64x1_t arg1_int64x1_t;\n+\n+  out_int64x1_t = vrshl_s64 (arg0_int64x1_t, arg1_int64x1_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vrshl\\.s64\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "a9b68eba4df4b3a4137ce7372ea2cae7b31ee2a0", "filename": "gcc/testsuite/gcc.target/arm/neon/vRshls8.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshls8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshls8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshls8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRshls8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRshls8 (void)\n+{\n+  int8x8_t out_int8x8_t;\n+  int8x8_t arg0_int8x8_t;\n+  int8x8_t arg1_int8x8_t;\n+\n+  out_int8x8_t = vrshl_s8 (arg0_int8x8_t, arg1_int8x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vrshl\\.s8\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "d493b441a77e0f7a5ee3d2317ce638fab39d9c1f", "filename": "gcc/testsuite/gcc.target/arm/neon/vRshlu16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshlu16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshlu16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshlu16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRshlu16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRshlu16 (void)\n+{\n+  uint16x4_t out_uint16x4_t;\n+  uint16x4_t arg0_uint16x4_t;\n+  int16x4_t arg1_int16x4_t;\n+\n+  out_uint16x4_t = vrshl_u16 (arg0_uint16x4_t, arg1_int16x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vrshl\\.u16\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "82edc7eed06e37ccf241157d54ca19b47ee626b1", "filename": "gcc/testsuite/gcc.target/arm/neon/vRshlu32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshlu32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshlu32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshlu32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRshlu32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRshlu32 (void)\n+{\n+  uint32x2_t out_uint32x2_t;\n+  uint32x2_t arg0_uint32x2_t;\n+  int32x2_t arg1_int32x2_t;\n+\n+  out_uint32x2_t = vrshl_u32 (arg0_uint32x2_t, arg1_int32x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vrshl\\.u32\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "b821e2c27153d59c707b059b69eeb7fe796ffaf4", "filename": "gcc/testsuite/gcc.target/arm/neon/vRshlu64.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshlu64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshlu64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshlu64.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRshlu64' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRshlu64 (void)\n+{\n+  uint64x1_t out_uint64x1_t;\n+  uint64x1_t arg0_uint64x1_t;\n+  int64x1_t arg1_int64x1_t;\n+\n+  out_uint64x1_t = vrshl_u64 (arg0_uint64x1_t, arg1_int64x1_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vrshl\\.u64\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "f609ce00ec4cbfc7eab062536f403258243c20d8", "filename": "gcc/testsuite/gcc.target/arm/neon/vRshlu8.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshlu8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshlu8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshlu8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRshlu8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRshlu8 (void)\n+{\n+  uint8x8_t out_uint8x8_t;\n+  uint8x8_t arg0_uint8x8_t;\n+  int8x8_t arg1_int8x8_t;\n+\n+  out_uint8x8_t = vrshl_u8 (arg0_uint8x8_t, arg1_int8x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vrshl\\.u8\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "3ea1a5f4bb4537084a4dc906a081ad31e6317b71", "filename": "gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns16.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshrQ_ns16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshrQ_ns16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshrQ_ns16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,19 @@\n+/* Test the `vRshrQ_ns16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRshrQ_ns16 (void)\n+{\n+  int16x8_t out_int16x8_t;\n+  int16x8_t arg0_int16x8_t;\n+\n+  out_int16x8_t = vrshrq_n_s16 (arg0_int16x8_t, 1);\n+}\n+\n+/* { dg-final { scan-assembler \"vrshr\\.s16\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, #\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "e66dec53fd67d7bfa3e996bade2b06b387c1315d", "filename": "gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns32.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshrQ_ns32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshrQ_ns32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshrQ_ns32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,19 @@\n+/* Test the `vRshrQ_ns32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRshrQ_ns32 (void)\n+{\n+  int32x4_t out_int32x4_t;\n+  int32x4_t arg0_int32x4_t;\n+\n+  out_int32x4_t = vrshrq_n_s32 (arg0_int32x4_t, 1);\n+}\n+\n+/* { dg-final { scan-assembler \"vrshr\\.s32\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, #\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "8d4d23c55790b051bfb6b5b22fc28cc33eb30f80", "filename": "gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns64.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshrQ_ns64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshrQ_ns64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshrQ_ns64.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,19 @@\n+/* Test the `vRshrQ_ns64' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRshrQ_ns64 (void)\n+{\n+  int64x2_t out_int64x2_t;\n+  int64x2_t arg0_int64x2_t;\n+\n+  out_int64x2_t = vrshrq_n_s64 (arg0_int64x2_t, 1);\n+}\n+\n+/* { dg-final { scan-assembler \"vrshr\\.s64\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, #\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "3ac4b093b7a0d7d250d9c6d00e66611416426b46", "filename": "gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns8.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshrQ_ns8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshrQ_ns8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshrQ_ns8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,19 @@\n+/* Test the `vRshrQ_ns8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRshrQ_ns8 (void)\n+{\n+  int8x16_t out_int8x16_t;\n+  int8x16_t arg0_int8x16_t;\n+\n+  out_int8x16_t = vrshrq_n_s8 (arg0_int8x16_t, 1);\n+}\n+\n+/* { dg-final { scan-assembler \"vrshr\\.s8\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, #\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "2454b80ebc5ab5e3d41f83047a57dcf1b012d37b", "filename": "gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu16.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshrQ_nu16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshrQ_nu16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshrQ_nu16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,19 @@\n+/* Test the `vRshrQ_nu16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRshrQ_nu16 (void)\n+{\n+  uint16x8_t out_uint16x8_t;\n+  uint16x8_t arg0_uint16x8_t;\n+\n+  out_uint16x8_t = vrshrq_n_u16 (arg0_uint16x8_t, 1);\n+}\n+\n+/* { dg-final { scan-assembler \"vrshr\\.u16\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, #\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "8a8b35129c229e9212135c43121933e7dc221889", "filename": "gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu32.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshrQ_nu32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshrQ_nu32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshrQ_nu32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,19 @@\n+/* Test the `vRshrQ_nu32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRshrQ_nu32 (void)\n+{\n+  uint32x4_t out_uint32x4_t;\n+  uint32x4_t arg0_uint32x4_t;\n+\n+  out_uint32x4_t = vrshrq_n_u32 (arg0_uint32x4_t, 1);\n+}\n+\n+/* { dg-final { scan-assembler \"vrshr\\.u32\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, #\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "1388e75aa7861bf5d5403fdba808ef0098386ad0", "filename": "gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu64.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshrQ_nu64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshrQ_nu64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshrQ_nu64.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,19 @@\n+/* Test the `vRshrQ_nu64' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRshrQ_nu64 (void)\n+{\n+  uint64x2_t out_uint64x2_t;\n+  uint64x2_t arg0_uint64x2_t;\n+\n+  out_uint64x2_t = vrshrq_n_u64 (arg0_uint64x2_t, 1);\n+}\n+\n+/* { dg-final { scan-assembler \"vrshr\\.u64\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, #\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "0218268b2aa2f15ed463414cfa96c517c371f56e", "filename": "gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu8.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshrQ_nu8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshrQ_nu8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshrQ_nu8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,19 @@\n+/* Test the `vRshrQ_nu8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRshrQ_nu8 (void)\n+{\n+  uint8x16_t out_uint8x16_t;\n+  uint8x16_t arg0_uint8x16_t;\n+\n+  out_uint8x16_t = vrshrq_n_u8 (arg0_uint8x16_t, 1);\n+}\n+\n+/* { dg-final { scan-assembler \"vrshr\\.u8\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, #\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "45be077f0d371289397624b1552570036d909de4", "filename": "gcc/testsuite/gcc.target/arm/neon/vRshr_ns16.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshr_ns16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshr_ns16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshr_ns16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,19 @@\n+/* Test the `vRshr_ns16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRshr_ns16 (void)\n+{\n+  int16x4_t out_int16x4_t;\n+  int16x4_t arg0_int16x4_t;\n+\n+  out_int16x4_t = vrshr_n_s16 (arg0_int16x4_t, 1);\n+}\n+\n+/* { dg-final { scan-assembler \"vrshr\\.s16\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, #\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "1921daa9c4a0140258bd5b65cecc8eda66e11079", "filename": "gcc/testsuite/gcc.target/arm/neon/vRshr_ns32.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshr_ns32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshr_ns32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshr_ns32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,19 @@\n+/* Test the `vRshr_ns32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRshr_ns32 (void)\n+{\n+  int32x2_t out_int32x2_t;\n+  int32x2_t arg0_int32x2_t;\n+\n+  out_int32x2_t = vrshr_n_s32 (arg0_int32x2_t, 1);\n+}\n+\n+/* { dg-final { scan-assembler \"vrshr\\.s32\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, #\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "8369afb68ae023864a1caaf284e832f278971dc4", "filename": "gcc/testsuite/gcc.target/arm/neon/vRshr_ns64.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshr_ns64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshr_ns64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshr_ns64.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,19 @@\n+/* Test the `vRshr_ns64' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRshr_ns64 (void)\n+{\n+  int64x1_t out_int64x1_t;\n+  int64x1_t arg0_int64x1_t;\n+\n+  out_int64x1_t = vrshr_n_s64 (arg0_int64x1_t, 1);\n+}\n+\n+/* { dg-final { scan-assembler \"vrshr\\.s64\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, #\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "3632be0f336732e1e0b0485ee4d77ae0bbb4224e", "filename": "gcc/testsuite/gcc.target/arm/neon/vRshr_ns8.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshr_ns8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshr_ns8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshr_ns8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,19 @@\n+/* Test the `vRshr_ns8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRshr_ns8 (void)\n+{\n+  int8x8_t out_int8x8_t;\n+  int8x8_t arg0_int8x8_t;\n+\n+  out_int8x8_t = vrshr_n_s8 (arg0_int8x8_t, 1);\n+}\n+\n+/* { dg-final { scan-assembler \"vrshr\\.s8\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, #\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "262783de530df4d2b04036c5efef35c55d52c484", "filename": "gcc/testsuite/gcc.target/arm/neon/vRshr_nu16.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshr_nu16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshr_nu16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshr_nu16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,19 @@\n+/* Test the `vRshr_nu16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRshr_nu16 (void)\n+{\n+  uint16x4_t out_uint16x4_t;\n+  uint16x4_t arg0_uint16x4_t;\n+\n+  out_uint16x4_t = vrshr_n_u16 (arg0_uint16x4_t, 1);\n+}\n+\n+/* { dg-final { scan-assembler \"vrshr\\.u16\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, #\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "ed480252b8333e04490e362829df2ffa3294dafd", "filename": "gcc/testsuite/gcc.target/arm/neon/vRshr_nu32.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshr_nu32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshr_nu32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshr_nu32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,19 @@\n+/* Test the `vRshr_nu32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRshr_nu32 (void)\n+{\n+  uint32x2_t out_uint32x2_t;\n+  uint32x2_t arg0_uint32x2_t;\n+\n+  out_uint32x2_t = vrshr_n_u32 (arg0_uint32x2_t, 1);\n+}\n+\n+/* { dg-final { scan-assembler \"vrshr\\.u32\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, #\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "5e66caa4c342263191a79170ff1425c57973d5ad", "filename": "gcc/testsuite/gcc.target/arm/neon/vRshr_nu64.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshr_nu64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshr_nu64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshr_nu64.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,19 @@\n+/* Test the `vRshr_nu64' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRshr_nu64 (void)\n+{\n+  uint64x1_t out_uint64x1_t;\n+  uint64x1_t arg0_uint64x1_t;\n+\n+  out_uint64x1_t = vrshr_n_u64 (arg0_uint64x1_t, 1);\n+}\n+\n+/* { dg-final { scan-assembler \"vrshr\\.u64\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, #\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "720f9cab63a5d8eb6331015f5be3a30cd8a361ad", "filename": "gcc/testsuite/gcc.target/arm/neon/vRshr_nu8.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshr_nu8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshr_nu8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshr_nu8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,19 @@\n+/* Test the `vRshr_nu8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRshr_nu8 (void)\n+{\n+  uint8x8_t out_uint8x8_t;\n+  uint8x8_t arg0_uint8x8_t;\n+\n+  out_uint8x8_t = vrshr_n_u8 (arg0_uint8x8_t, 1);\n+}\n+\n+/* { dg-final { scan-assembler \"vrshr\\.u8\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, #\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "864aa5e6f2d6d629b08255d18c618ff53f0cd139", "filename": "gcc/testsuite/gcc.target/arm/neon/vRshrn_ns16.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshrn_ns16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshrn_ns16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshrn_ns16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,19 @@\n+/* Test the `vRshrn_ns16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRshrn_ns16 (void)\n+{\n+  int8x8_t out_int8x8_t;\n+  int16x8_t arg0_int16x8_t;\n+\n+  out_int8x8_t = vrshrn_n_s16 (arg0_int16x8_t, 1);\n+}\n+\n+/* { dg-final { scan-assembler \"vrshrn\\.i16\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, #\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "a313892e7d17814e3104dcb4675036e2d2567cf0", "filename": "gcc/testsuite/gcc.target/arm/neon/vRshrn_ns32.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshrn_ns32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshrn_ns32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshrn_ns32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,19 @@\n+/* Test the `vRshrn_ns32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRshrn_ns32 (void)\n+{\n+  int16x4_t out_int16x4_t;\n+  int32x4_t arg0_int32x4_t;\n+\n+  out_int16x4_t = vrshrn_n_s32 (arg0_int32x4_t, 1);\n+}\n+\n+/* { dg-final { scan-assembler \"vrshrn\\.i32\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, #\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "e95ef923046b437ccdba982d87ceb07ff286b4cc", "filename": "gcc/testsuite/gcc.target/arm/neon/vRshrn_ns64.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshrn_ns64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshrn_ns64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshrn_ns64.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,19 @@\n+/* Test the `vRshrn_ns64' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRshrn_ns64 (void)\n+{\n+  int32x2_t out_int32x2_t;\n+  int64x2_t arg0_int64x2_t;\n+\n+  out_int32x2_t = vrshrn_n_s64 (arg0_int64x2_t, 1);\n+}\n+\n+/* { dg-final { scan-assembler \"vrshrn\\.i64\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, #\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "09e3299b66084929835e0fea5ffb3cfcb1b73a6a", "filename": "gcc/testsuite/gcc.target/arm/neon/vRshrn_nu16.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshrn_nu16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshrn_nu16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshrn_nu16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,19 @@\n+/* Test the `vRshrn_nu16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRshrn_nu16 (void)\n+{\n+  uint8x8_t out_uint8x8_t;\n+  uint16x8_t arg0_uint16x8_t;\n+\n+  out_uint8x8_t = vrshrn_n_u16 (arg0_uint16x8_t, 1);\n+}\n+\n+/* { dg-final { scan-assembler \"vrshrn\\.i16\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, #\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "548d89e93410d1acc752f8ebb34c6dff17d5f26d", "filename": "gcc/testsuite/gcc.target/arm/neon/vRshrn_nu32.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshrn_nu32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshrn_nu32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshrn_nu32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,19 @@\n+/* Test the `vRshrn_nu32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRshrn_nu32 (void)\n+{\n+  uint16x4_t out_uint16x4_t;\n+  uint32x4_t arg0_uint32x4_t;\n+\n+  out_uint16x4_t = vrshrn_n_u32 (arg0_uint32x4_t, 1);\n+}\n+\n+/* { dg-final { scan-assembler \"vrshrn\\.i32\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, #\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "9a67f2d8edaed93ebda6d168a32501e27b280e3e", "filename": "gcc/testsuite/gcc.target/arm/neon/vRshrn_nu64.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshrn_nu64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshrn_nu64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRshrn_nu64.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,19 @@\n+/* Test the `vRshrn_nu64' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRshrn_nu64 (void)\n+{\n+  uint32x2_t out_uint32x2_t;\n+  uint64x2_t arg0_uint64x2_t;\n+\n+  out_uint32x2_t = vrshrn_n_u64 (arg0_uint64x2_t, 1);\n+}\n+\n+/* { dg-final { scan-assembler \"vrshrn\\.i64\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, #\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "803eab09d633789db0e16c54adb6c629eaa6639a", "filename": "gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsraQ_ns16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsraQ_ns16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsraQ_ns16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRsraQ_ns16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRsraQ_ns16 (void)\n+{\n+  int16x8_t out_int16x8_t;\n+  int16x8_t arg0_int16x8_t;\n+  int16x8_t arg1_int16x8_t;\n+\n+  out_int16x8_t = vrsraq_n_s16 (arg0_int16x8_t, arg1_int16x8_t, 1);\n+}\n+\n+/* { dg-final { scan-assembler \"vrsra\\.s16\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, #\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "541528fe535883375a70553f64cda54d24e11eb5", "filename": "gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsraQ_ns32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsraQ_ns32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsraQ_ns32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRsraQ_ns32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRsraQ_ns32 (void)\n+{\n+  int32x4_t out_int32x4_t;\n+  int32x4_t arg0_int32x4_t;\n+  int32x4_t arg1_int32x4_t;\n+\n+  out_int32x4_t = vrsraq_n_s32 (arg0_int32x4_t, arg1_int32x4_t, 1);\n+}\n+\n+/* { dg-final { scan-assembler \"vrsra\\.s32\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, #\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "26f404982286444bf436189de26c20574194d7a4", "filename": "gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns64.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsraQ_ns64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsraQ_ns64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsraQ_ns64.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRsraQ_ns64' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRsraQ_ns64 (void)\n+{\n+  int64x2_t out_int64x2_t;\n+  int64x2_t arg0_int64x2_t;\n+  int64x2_t arg1_int64x2_t;\n+\n+  out_int64x2_t = vrsraq_n_s64 (arg0_int64x2_t, arg1_int64x2_t, 1);\n+}\n+\n+/* { dg-final { scan-assembler \"vrsra\\.s64\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, #\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "9d701f3f124a2ada1e88649cb428f1103b5d0d0f", "filename": "gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns8.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsraQ_ns8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsraQ_ns8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsraQ_ns8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRsraQ_ns8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRsraQ_ns8 (void)\n+{\n+  int8x16_t out_int8x16_t;\n+  int8x16_t arg0_int8x16_t;\n+  int8x16_t arg1_int8x16_t;\n+\n+  out_int8x16_t = vrsraq_n_s8 (arg0_int8x16_t, arg1_int8x16_t, 1);\n+}\n+\n+/* { dg-final { scan-assembler \"vrsra\\.s8\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, #\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "a3ff5f0353ade68fa93ca18f65eb54832a8d069f", "filename": "gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsraQ_nu16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsraQ_nu16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsraQ_nu16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRsraQ_nu16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRsraQ_nu16 (void)\n+{\n+  uint16x8_t out_uint16x8_t;\n+  uint16x8_t arg0_uint16x8_t;\n+  uint16x8_t arg1_uint16x8_t;\n+\n+  out_uint16x8_t = vrsraq_n_u16 (arg0_uint16x8_t, arg1_uint16x8_t, 1);\n+}\n+\n+/* { dg-final { scan-assembler \"vrsra\\.u16\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, #\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "7830c435a452898e91c04021713a6f0528cb5d5e", "filename": "gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsraQ_nu32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsraQ_nu32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsraQ_nu32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRsraQ_nu32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRsraQ_nu32 (void)\n+{\n+  uint32x4_t out_uint32x4_t;\n+  uint32x4_t arg0_uint32x4_t;\n+  uint32x4_t arg1_uint32x4_t;\n+\n+  out_uint32x4_t = vrsraq_n_u32 (arg0_uint32x4_t, arg1_uint32x4_t, 1);\n+}\n+\n+/* { dg-final { scan-assembler \"vrsra\\.u32\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, #\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "bd12da1491271cbdd4d9ef482aa4e39badfaf1ed", "filename": "gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu64.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsraQ_nu64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsraQ_nu64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsraQ_nu64.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRsraQ_nu64' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRsraQ_nu64 (void)\n+{\n+  uint64x2_t out_uint64x2_t;\n+  uint64x2_t arg0_uint64x2_t;\n+  uint64x2_t arg1_uint64x2_t;\n+\n+  out_uint64x2_t = vrsraq_n_u64 (arg0_uint64x2_t, arg1_uint64x2_t, 1);\n+}\n+\n+/* { dg-final { scan-assembler \"vrsra\\.u64\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, #\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "928dcd8a33e5af0fab277ff8df41cabde3e2409d", "filename": "gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu8.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsraQ_nu8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsraQ_nu8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsraQ_nu8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRsraQ_nu8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRsraQ_nu8 (void)\n+{\n+  uint8x16_t out_uint8x16_t;\n+  uint8x16_t arg0_uint8x16_t;\n+  uint8x16_t arg1_uint8x16_t;\n+\n+  out_uint8x16_t = vrsraq_n_u8 (arg0_uint8x16_t, arg1_uint8x16_t, 1);\n+}\n+\n+/* { dg-final { scan-assembler \"vrsra\\.u8\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, #\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "e7b2d1a1f4cce40125143d75837e6f5419ac9cab", "filename": "gcc/testsuite/gcc.target/arm/neon/vRsra_ns16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsra_ns16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsra_ns16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsra_ns16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRsra_ns16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRsra_ns16 (void)\n+{\n+  int16x4_t out_int16x4_t;\n+  int16x4_t arg0_int16x4_t;\n+  int16x4_t arg1_int16x4_t;\n+\n+  out_int16x4_t = vrsra_n_s16 (arg0_int16x4_t, arg1_int16x4_t, 1);\n+}\n+\n+/* { dg-final { scan-assembler \"vrsra\\.s16\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, #\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "dd3c1153613395767aeb7f4cb8a0f078195c2616", "filename": "gcc/testsuite/gcc.target/arm/neon/vRsra_ns32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsra_ns32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsra_ns32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsra_ns32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRsra_ns32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRsra_ns32 (void)\n+{\n+  int32x2_t out_int32x2_t;\n+  int32x2_t arg0_int32x2_t;\n+  int32x2_t arg1_int32x2_t;\n+\n+  out_int32x2_t = vrsra_n_s32 (arg0_int32x2_t, arg1_int32x2_t, 1);\n+}\n+\n+/* { dg-final { scan-assembler \"vrsra\\.s32\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, #\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "98944d675558d5f9aa7150d1c3a721e58635aee7", "filename": "gcc/testsuite/gcc.target/arm/neon/vRsra_ns64.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsra_ns64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsra_ns64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsra_ns64.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRsra_ns64' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRsra_ns64 (void)\n+{\n+  int64x1_t out_int64x1_t;\n+  int64x1_t arg0_int64x1_t;\n+  int64x1_t arg1_int64x1_t;\n+\n+  out_int64x1_t = vrsra_n_s64 (arg0_int64x1_t, arg1_int64x1_t, 1);\n+}\n+\n+/* { dg-final { scan-assembler \"vrsra\\.s64\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, #\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "187bbc015b250126c1528a77b1c6cac5ccae2350", "filename": "gcc/testsuite/gcc.target/arm/neon/vRsra_ns8.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsra_ns8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsra_ns8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsra_ns8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRsra_ns8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRsra_ns8 (void)\n+{\n+  int8x8_t out_int8x8_t;\n+  int8x8_t arg0_int8x8_t;\n+  int8x8_t arg1_int8x8_t;\n+\n+  out_int8x8_t = vrsra_n_s8 (arg0_int8x8_t, arg1_int8x8_t, 1);\n+}\n+\n+/* { dg-final { scan-assembler \"vrsra\\.s8\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, #\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "56009bb29cac0becb1af403c69a208a0c981ed7f", "filename": "gcc/testsuite/gcc.target/arm/neon/vRsra_nu16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsra_nu16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsra_nu16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsra_nu16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRsra_nu16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRsra_nu16 (void)\n+{\n+  uint16x4_t out_uint16x4_t;\n+  uint16x4_t arg0_uint16x4_t;\n+  uint16x4_t arg1_uint16x4_t;\n+\n+  out_uint16x4_t = vrsra_n_u16 (arg0_uint16x4_t, arg1_uint16x4_t, 1);\n+}\n+\n+/* { dg-final { scan-assembler \"vrsra\\.u16\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, #\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "f7879dbcd62bd47c1611423a7870fe945dec0337", "filename": "gcc/testsuite/gcc.target/arm/neon/vRsra_nu32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsra_nu32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsra_nu32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsra_nu32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRsra_nu32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRsra_nu32 (void)\n+{\n+  uint32x2_t out_uint32x2_t;\n+  uint32x2_t arg0_uint32x2_t;\n+  uint32x2_t arg1_uint32x2_t;\n+\n+  out_uint32x2_t = vrsra_n_u32 (arg0_uint32x2_t, arg1_uint32x2_t, 1);\n+}\n+\n+/* { dg-final { scan-assembler \"vrsra\\.u32\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, #\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "25d25d55cfda0b54f8f9336f08032d79952d5b31", "filename": "gcc/testsuite/gcc.target/arm/neon/vRsra_nu64.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsra_nu64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsra_nu64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsra_nu64.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRsra_nu64' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRsra_nu64 (void)\n+{\n+  uint64x1_t out_uint64x1_t;\n+  uint64x1_t arg0_uint64x1_t;\n+  uint64x1_t arg1_uint64x1_t;\n+\n+  out_uint64x1_t = vrsra_n_u64 (arg0_uint64x1_t, arg1_uint64x1_t, 1);\n+}\n+\n+/* { dg-final { scan-assembler \"vrsra\\.u64\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, #\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "07f587a5564cbc6a7cab6cd1aa618a4211ea32a8", "filename": "gcc/testsuite/gcc.target/arm/neon/vRsra_nu8.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsra_nu8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsra_nu8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsra_nu8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRsra_nu8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRsra_nu8 (void)\n+{\n+  uint8x8_t out_uint8x8_t;\n+  uint8x8_t arg0_uint8x8_t;\n+  uint8x8_t arg1_uint8x8_t;\n+\n+  out_uint8x8_t = vrsra_n_u8 (arg0_uint8x8_t, arg1_uint8x8_t, 1);\n+}\n+\n+/* { dg-final { scan-assembler \"vrsra\\.u8\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, #\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "ec62a28f473fac572344684a125c2dddbb4117b6", "filename": "gcc/testsuite/gcc.target/arm/neon/vRsubhns16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsubhns16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsubhns16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsubhns16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRsubhns16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRsubhns16 (void)\n+{\n+  int8x8_t out_int8x8_t;\n+  int16x8_t arg0_int16x8_t;\n+  int16x8_t arg1_int16x8_t;\n+\n+  out_int8x8_t = vrsubhn_s16 (arg0_int16x8_t, arg1_int16x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vrsubhn\\.i16\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "a049aab22f95109360deba545d8feb78edcd89ed", "filename": "gcc/testsuite/gcc.target/arm/neon/vRsubhns32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsubhns32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsubhns32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsubhns32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRsubhns32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRsubhns32 (void)\n+{\n+  int16x4_t out_int16x4_t;\n+  int32x4_t arg0_int32x4_t;\n+  int32x4_t arg1_int32x4_t;\n+\n+  out_int16x4_t = vrsubhn_s32 (arg0_int32x4_t, arg1_int32x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vrsubhn\\.i32\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "515bac135bd7f1cabb2b9566e93409607b0cd9c0", "filename": "gcc/testsuite/gcc.target/arm/neon/vRsubhns64.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsubhns64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsubhns64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsubhns64.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRsubhns64' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRsubhns64 (void)\n+{\n+  int32x2_t out_int32x2_t;\n+  int64x2_t arg0_int64x2_t;\n+  int64x2_t arg1_int64x2_t;\n+\n+  out_int32x2_t = vrsubhn_s64 (arg0_int64x2_t, arg1_int64x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vrsubhn\\.i64\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "0e52946018a47b57718cb621fdf6d85e7843f0ab", "filename": "gcc/testsuite/gcc.target/arm/neon/vRsubhnu16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsubhnu16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsubhnu16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsubhnu16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRsubhnu16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRsubhnu16 (void)\n+{\n+  uint8x8_t out_uint8x8_t;\n+  uint16x8_t arg0_uint16x8_t;\n+  uint16x8_t arg1_uint16x8_t;\n+\n+  out_uint8x8_t = vrsubhn_u16 (arg0_uint16x8_t, arg1_uint16x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vrsubhn\\.i16\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "f4ec7888787e020aa5ef4d3da37a9499ec1f2f4d", "filename": "gcc/testsuite/gcc.target/arm/neon/vRsubhnu32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsubhnu32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsubhnu32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsubhnu32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRsubhnu32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRsubhnu32 (void)\n+{\n+  uint16x4_t out_uint16x4_t;\n+  uint32x4_t arg0_uint32x4_t;\n+  uint32x4_t arg1_uint32x4_t;\n+\n+  out_uint16x4_t = vrsubhn_u32 (arg0_uint32x4_t, arg1_uint32x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vrsubhn\\.i32\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "1b41a20ad9000ac353906475ef261ebdf4104d0c", "filename": "gcc/testsuite/gcc.target/arm/neon/vRsubhnu64.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsubhnu64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsubhnu64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvRsubhnu64.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vRsubhnu64' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vRsubhnu64 (void)\n+{\n+  uint32x2_t out_uint32x2_t;\n+  uint64x2_t arg0_uint64x2_t;\n+  uint64x2_t arg1_uint64x2_t;\n+\n+  out_uint32x2_t = vrsubhn_u64 (arg0_uint64x2_t, arg1_uint64x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vrsubhn\\.i64\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "e15a611df13026424d6f4f1545f9e9847e279ab5", "filename": "gcc/testsuite/gcc.target/arm/neon/vabaQs16.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabaQs16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabaQs16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabaQs16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,21 @@\n+/* Test the `vabaQs16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vabaQs16 (void)\n+{\n+  int16x8_t out_int16x8_t;\n+  int16x8_t arg0_int16x8_t;\n+  int16x8_t arg1_int16x8_t;\n+  int16x8_t arg2_int16x8_t;\n+\n+  out_int16x8_t = vabaq_s16 (arg0_int16x8_t, arg1_int16x8_t, arg2_int16x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vaba\\.s16\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "b14068ab5d96935798c631b21ac84786b5756518", "filename": "gcc/testsuite/gcc.target/arm/neon/vabaQs32.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabaQs32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabaQs32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabaQs32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,21 @@\n+/* Test the `vabaQs32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vabaQs32 (void)\n+{\n+  int32x4_t out_int32x4_t;\n+  int32x4_t arg0_int32x4_t;\n+  int32x4_t arg1_int32x4_t;\n+  int32x4_t arg2_int32x4_t;\n+\n+  out_int32x4_t = vabaq_s32 (arg0_int32x4_t, arg1_int32x4_t, arg2_int32x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vaba\\.s32\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "91a1582ff13ba336f15b75303b4815980365926d", "filename": "gcc/testsuite/gcc.target/arm/neon/vabaQs8.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabaQs8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabaQs8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabaQs8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,21 @@\n+/* Test the `vabaQs8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vabaQs8 (void)\n+{\n+  int8x16_t out_int8x16_t;\n+  int8x16_t arg0_int8x16_t;\n+  int8x16_t arg1_int8x16_t;\n+  int8x16_t arg2_int8x16_t;\n+\n+  out_int8x16_t = vabaq_s8 (arg0_int8x16_t, arg1_int8x16_t, arg2_int8x16_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vaba\\.s8\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "61642ac1e1e4966ee74bdd07bd959c86f6952c79", "filename": "gcc/testsuite/gcc.target/arm/neon/vabaQu16.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabaQu16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabaQu16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabaQu16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,21 @@\n+/* Test the `vabaQu16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vabaQu16 (void)\n+{\n+  uint16x8_t out_uint16x8_t;\n+  uint16x8_t arg0_uint16x8_t;\n+  uint16x8_t arg1_uint16x8_t;\n+  uint16x8_t arg2_uint16x8_t;\n+\n+  out_uint16x8_t = vabaq_u16 (arg0_uint16x8_t, arg1_uint16x8_t, arg2_uint16x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vaba\\.u16\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "2227524cde599b8a2836ed8f5acc8a88ff9d0b68", "filename": "gcc/testsuite/gcc.target/arm/neon/vabaQu32.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabaQu32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabaQu32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabaQu32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,21 @@\n+/* Test the `vabaQu32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vabaQu32 (void)\n+{\n+  uint32x4_t out_uint32x4_t;\n+  uint32x4_t arg0_uint32x4_t;\n+  uint32x4_t arg1_uint32x4_t;\n+  uint32x4_t arg2_uint32x4_t;\n+\n+  out_uint32x4_t = vabaq_u32 (arg0_uint32x4_t, arg1_uint32x4_t, arg2_uint32x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vaba\\.u32\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "4e92d034555bb60640232dd1d638b08b7add60d8", "filename": "gcc/testsuite/gcc.target/arm/neon/vabaQu8.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabaQu8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabaQu8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabaQu8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,21 @@\n+/* Test the `vabaQu8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vabaQu8 (void)\n+{\n+  uint8x16_t out_uint8x16_t;\n+  uint8x16_t arg0_uint8x16_t;\n+  uint8x16_t arg1_uint8x16_t;\n+  uint8x16_t arg2_uint8x16_t;\n+\n+  out_uint8x16_t = vabaq_u8 (arg0_uint8x16_t, arg1_uint8x16_t, arg2_uint8x16_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vaba\\.u8\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "65f1b9d41844e2e1fd5c53eaefae5e33bd770e1e", "filename": "gcc/testsuite/gcc.target/arm/neon/vabals16.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabals16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabals16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabals16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,21 @@\n+/* Test the `vabals16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vabals16 (void)\n+{\n+  int32x4_t out_int32x4_t;\n+  int32x4_t arg0_int32x4_t;\n+  int16x4_t arg1_int16x4_t;\n+  int16x4_t arg2_int16x4_t;\n+\n+  out_int32x4_t = vabal_s16 (arg0_int32x4_t, arg1_int16x4_t, arg2_int16x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vabal\\.s16\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "13a696b1343324249312fb5187c6880f8ea55e01", "filename": "gcc/testsuite/gcc.target/arm/neon/vabals32.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabals32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabals32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabals32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,21 @@\n+/* Test the `vabals32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vabals32 (void)\n+{\n+  int64x2_t out_int64x2_t;\n+  int64x2_t arg0_int64x2_t;\n+  int32x2_t arg1_int32x2_t;\n+  int32x2_t arg2_int32x2_t;\n+\n+  out_int64x2_t = vabal_s32 (arg0_int64x2_t, arg1_int32x2_t, arg2_int32x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vabal\\.s32\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "c7275b357221a9bbf2f5e322279ec2edd9447fa3", "filename": "gcc/testsuite/gcc.target/arm/neon/vabals8.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabals8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabals8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabals8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,21 @@\n+/* Test the `vabals8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vabals8 (void)\n+{\n+  int16x8_t out_int16x8_t;\n+  int16x8_t arg0_int16x8_t;\n+  int8x8_t arg1_int8x8_t;\n+  int8x8_t arg2_int8x8_t;\n+\n+  out_int16x8_t = vabal_s8 (arg0_int16x8_t, arg1_int8x8_t, arg2_int8x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vabal\\.s8\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "0be2473dc69e58924abd20e9fc2693dace160794", "filename": "gcc/testsuite/gcc.target/arm/neon/vabalu16.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabalu16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabalu16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabalu16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,21 @@\n+/* Test the `vabalu16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vabalu16 (void)\n+{\n+  uint32x4_t out_uint32x4_t;\n+  uint32x4_t arg0_uint32x4_t;\n+  uint16x4_t arg1_uint16x4_t;\n+  uint16x4_t arg2_uint16x4_t;\n+\n+  out_uint32x4_t = vabal_u16 (arg0_uint32x4_t, arg1_uint16x4_t, arg2_uint16x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vabal\\.u16\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "508420b4b30acbb29d7f0cf1de4685a453ae9795", "filename": "gcc/testsuite/gcc.target/arm/neon/vabalu32.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabalu32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabalu32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabalu32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,21 @@\n+/* Test the `vabalu32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vabalu32 (void)\n+{\n+  uint64x2_t out_uint64x2_t;\n+  uint64x2_t arg0_uint64x2_t;\n+  uint32x2_t arg1_uint32x2_t;\n+  uint32x2_t arg2_uint32x2_t;\n+\n+  out_uint64x2_t = vabal_u32 (arg0_uint64x2_t, arg1_uint32x2_t, arg2_uint32x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vabal\\.u32\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "0580eb3df6aeedb0c800c700373707dfcfbd0539", "filename": "gcc/testsuite/gcc.target/arm/neon/vabalu8.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabalu8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabalu8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabalu8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,21 @@\n+/* Test the `vabalu8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vabalu8 (void)\n+{\n+  uint16x8_t out_uint16x8_t;\n+  uint16x8_t arg0_uint16x8_t;\n+  uint8x8_t arg1_uint8x8_t;\n+  uint8x8_t arg2_uint8x8_t;\n+\n+  out_uint16x8_t = vabal_u8 (arg0_uint16x8_t, arg1_uint8x8_t, arg2_uint8x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vabal\\.u8\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "4122be9a13568e1e41750f5b62890f0289581f30", "filename": "gcc/testsuite/gcc.target/arm/neon/vabas16.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabas16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabas16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabas16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,21 @@\n+/* Test the `vabas16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vabas16 (void)\n+{\n+  int16x4_t out_int16x4_t;\n+  int16x4_t arg0_int16x4_t;\n+  int16x4_t arg1_int16x4_t;\n+  int16x4_t arg2_int16x4_t;\n+\n+  out_int16x4_t = vaba_s16 (arg0_int16x4_t, arg1_int16x4_t, arg2_int16x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vaba\\.s16\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "ca089864f15b2d55bf20b029310387bd4df467c3", "filename": "gcc/testsuite/gcc.target/arm/neon/vabas32.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabas32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabas32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabas32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,21 @@\n+/* Test the `vabas32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vabas32 (void)\n+{\n+  int32x2_t out_int32x2_t;\n+  int32x2_t arg0_int32x2_t;\n+  int32x2_t arg1_int32x2_t;\n+  int32x2_t arg2_int32x2_t;\n+\n+  out_int32x2_t = vaba_s32 (arg0_int32x2_t, arg1_int32x2_t, arg2_int32x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vaba\\.s32\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "e03f2285ad2b6d54744151d79217327779a5bb5c", "filename": "gcc/testsuite/gcc.target/arm/neon/vabas8.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabas8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabas8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabas8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,21 @@\n+/* Test the `vabas8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vabas8 (void)\n+{\n+  int8x8_t out_int8x8_t;\n+  int8x8_t arg0_int8x8_t;\n+  int8x8_t arg1_int8x8_t;\n+  int8x8_t arg2_int8x8_t;\n+\n+  out_int8x8_t = vaba_s8 (arg0_int8x8_t, arg1_int8x8_t, arg2_int8x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vaba\\.s8\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "f67beca5381af3c387b8e574634155569ce1d87c", "filename": "gcc/testsuite/gcc.target/arm/neon/vabau16.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabau16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabau16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabau16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,21 @@\n+/* Test the `vabau16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vabau16 (void)\n+{\n+  uint16x4_t out_uint16x4_t;\n+  uint16x4_t arg0_uint16x4_t;\n+  uint16x4_t arg1_uint16x4_t;\n+  uint16x4_t arg2_uint16x4_t;\n+\n+  out_uint16x4_t = vaba_u16 (arg0_uint16x4_t, arg1_uint16x4_t, arg2_uint16x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vaba\\.u16\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "b57d1cf3924860fd6785545ba45e74a1b7fd7f7d", "filename": "gcc/testsuite/gcc.target/arm/neon/vabau32.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabau32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabau32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabau32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,21 @@\n+/* Test the `vabau32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vabau32 (void)\n+{\n+  uint32x2_t out_uint32x2_t;\n+  uint32x2_t arg0_uint32x2_t;\n+  uint32x2_t arg1_uint32x2_t;\n+  uint32x2_t arg2_uint32x2_t;\n+\n+  out_uint32x2_t = vaba_u32 (arg0_uint32x2_t, arg1_uint32x2_t, arg2_uint32x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vaba\\.u32\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "03ce6665b397c2f484c21ae12ff80028e21b0429", "filename": "gcc/testsuite/gcc.target/arm/neon/vabau8.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabau8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabau8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabau8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,21 @@\n+/* Test the `vabau8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vabau8 (void)\n+{\n+  uint8x8_t out_uint8x8_t;\n+  uint8x8_t arg0_uint8x8_t;\n+  uint8x8_t arg1_uint8x8_t;\n+  uint8x8_t arg2_uint8x8_t;\n+\n+  out_uint8x8_t = vaba_u8 (arg0_uint8x8_t, arg1_uint8x8_t, arg2_uint8x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vaba\\.u8\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "0cec3095b25f3d54f1ad7bb3e1db24169d4f629a", "filename": "gcc/testsuite/gcc.target/arm/neon/vabdQf32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabdQf32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabdQf32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabdQf32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vabdQf32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vabdQf32 (void)\n+{\n+  float32x4_t out_float32x4_t;\n+  float32x4_t arg0_float32x4_t;\n+  float32x4_t arg1_float32x4_t;\n+\n+  out_float32x4_t = vabdq_f32 (arg0_float32x4_t, arg1_float32x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vabd\\.f32\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "cd7cedbdeb4ab6131a6b2932fe862ae19606e00a", "filename": "gcc/testsuite/gcc.target/arm/neon/vabdQs16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabdQs16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabdQs16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabdQs16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vabdQs16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vabdQs16 (void)\n+{\n+  int16x8_t out_int16x8_t;\n+  int16x8_t arg0_int16x8_t;\n+  int16x8_t arg1_int16x8_t;\n+\n+  out_int16x8_t = vabdq_s16 (arg0_int16x8_t, arg1_int16x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vabd\\.s16\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "06a2d6a818649abf071e0d06f3b0ebeea321a0ad", "filename": "gcc/testsuite/gcc.target/arm/neon/vabdQs32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabdQs32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabdQs32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabdQs32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vabdQs32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vabdQs32 (void)\n+{\n+  int32x4_t out_int32x4_t;\n+  int32x4_t arg0_int32x4_t;\n+  int32x4_t arg1_int32x4_t;\n+\n+  out_int32x4_t = vabdq_s32 (arg0_int32x4_t, arg1_int32x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vabd\\.s32\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "dc52032a72173e83804ac7b2e451001c2da8aa61", "filename": "gcc/testsuite/gcc.target/arm/neon/vabdQs8.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabdQs8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabdQs8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabdQs8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vabdQs8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vabdQs8 (void)\n+{\n+  int8x16_t out_int8x16_t;\n+  int8x16_t arg0_int8x16_t;\n+  int8x16_t arg1_int8x16_t;\n+\n+  out_int8x16_t = vabdq_s8 (arg0_int8x16_t, arg1_int8x16_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vabd\\.s8\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "72cfd3a32b1267e041b242240763d28dc81e7703", "filename": "gcc/testsuite/gcc.target/arm/neon/vabdQu16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabdQu16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabdQu16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabdQu16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vabdQu16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vabdQu16 (void)\n+{\n+  uint16x8_t out_uint16x8_t;\n+  uint16x8_t arg0_uint16x8_t;\n+  uint16x8_t arg1_uint16x8_t;\n+\n+  out_uint16x8_t = vabdq_u16 (arg0_uint16x8_t, arg1_uint16x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vabd\\.u16\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "cd0c36193b8d90e2ae4ed77f037e14341094dff0", "filename": "gcc/testsuite/gcc.target/arm/neon/vabdQu32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabdQu32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabdQu32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabdQu32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vabdQu32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vabdQu32 (void)\n+{\n+  uint32x4_t out_uint32x4_t;\n+  uint32x4_t arg0_uint32x4_t;\n+  uint32x4_t arg1_uint32x4_t;\n+\n+  out_uint32x4_t = vabdq_u32 (arg0_uint32x4_t, arg1_uint32x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vabd\\.u32\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "15afaa9e625d6b107494b4b3891303ecbf771ce1", "filename": "gcc/testsuite/gcc.target/arm/neon/vabdQu8.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabdQu8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabdQu8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabdQu8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vabdQu8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vabdQu8 (void)\n+{\n+  uint8x16_t out_uint8x16_t;\n+  uint8x16_t arg0_uint8x16_t;\n+  uint8x16_t arg1_uint8x16_t;\n+\n+  out_uint8x16_t = vabdq_u8 (arg0_uint8x16_t, arg1_uint8x16_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vabd\\.u8\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "58465a61797083ad44d7c0876984ea6deb4cb752", "filename": "gcc/testsuite/gcc.target/arm/neon/vabdf32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabdf32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabdf32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabdf32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vabdf32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vabdf32 (void)\n+{\n+  float32x2_t out_float32x2_t;\n+  float32x2_t arg0_float32x2_t;\n+  float32x2_t arg1_float32x2_t;\n+\n+  out_float32x2_t = vabd_f32 (arg0_float32x2_t, arg1_float32x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vabd\\.f32\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "a9c495df997b0167dcada02cb90936534f837922", "filename": "gcc/testsuite/gcc.target/arm/neon/vabdls16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabdls16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabdls16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabdls16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vabdls16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vabdls16 (void)\n+{\n+  int32x4_t out_int32x4_t;\n+  int16x4_t arg0_int16x4_t;\n+  int16x4_t arg1_int16x4_t;\n+\n+  out_int32x4_t = vabdl_s16 (arg0_int16x4_t, arg1_int16x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vabdl\\.s16\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "8f189479efa338d037cae8d7f4864f8302cfae2c", "filename": "gcc/testsuite/gcc.target/arm/neon/vabdls32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabdls32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabdls32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabdls32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vabdls32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vabdls32 (void)\n+{\n+  int64x2_t out_int64x2_t;\n+  int32x2_t arg0_int32x2_t;\n+  int32x2_t arg1_int32x2_t;\n+\n+  out_int64x2_t = vabdl_s32 (arg0_int32x2_t, arg1_int32x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vabdl\\.s32\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "1696bbca094148edfb4f89fd4f2489db495386e5", "filename": "gcc/testsuite/gcc.target/arm/neon/vabdls8.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabdls8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabdls8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabdls8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vabdls8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vabdls8 (void)\n+{\n+  int16x8_t out_int16x8_t;\n+  int8x8_t arg0_int8x8_t;\n+  int8x8_t arg1_int8x8_t;\n+\n+  out_int16x8_t = vabdl_s8 (arg0_int8x8_t, arg1_int8x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vabdl\\.s8\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "cb26a67ad4c7fd231f3db678e66f6444439e72fe", "filename": "gcc/testsuite/gcc.target/arm/neon/vabdlu16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabdlu16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabdlu16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabdlu16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vabdlu16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vabdlu16 (void)\n+{\n+  uint32x4_t out_uint32x4_t;\n+  uint16x4_t arg0_uint16x4_t;\n+  uint16x4_t arg1_uint16x4_t;\n+\n+  out_uint32x4_t = vabdl_u16 (arg0_uint16x4_t, arg1_uint16x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vabdl\\.u16\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "34541ee54e5e75533db038113958312e3362ea0e", "filename": "gcc/testsuite/gcc.target/arm/neon/vabdlu32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabdlu32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabdlu32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabdlu32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vabdlu32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vabdlu32 (void)\n+{\n+  uint64x2_t out_uint64x2_t;\n+  uint32x2_t arg0_uint32x2_t;\n+  uint32x2_t arg1_uint32x2_t;\n+\n+  out_uint64x2_t = vabdl_u32 (arg0_uint32x2_t, arg1_uint32x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vabdl\\.u32\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "b84a0457a0450f2cb0ce548692007cf17c210bcf", "filename": "gcc/testsuite/gcc.target/arm/neon/vabdlu8.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabdlu8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabdlu8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabdlu8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vabdlu8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vabdlu8 (void)\n+{\n+  uint16x8_t out_uint16x8_t;\n+  uint8x8_t arg0_uint8x8_t;\n+  uint8x8_t arg1_uint8x8_t;\n+\n+  out_uint16x8_t = vabdl_u8 (arg0_uint8x8_t, arg1_uint8x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vabdl\\.u8\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "209b6daebad0078d6db5dd3ec0df10a0143f46ec", "filename": "gcc/testsuite/gcc.target/arm/neon/vabds16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabds16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabds16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabds16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vabds16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vabds16 (void)\n+{\n+  int16x4_t out_int16x4_t;\n+  int16x4_t arg0_int16x4_t;\n+  int16x4_t arg1_int16x4_t;\n+\n+  out_int16x4_t = vabd_s16 (arg0_int16x4_t, arg1_int16x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vabd\\.s16\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "e7d5d40236179e472b803e60d1d62ebbad711fa2", "filename": "gcc/testsuite/gcc.target/arm/neon/vabds32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabds32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabds32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabds32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vabds32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vabds32 (void)\n+{\n+  int32x2_t out_int32x2_t;\n+  int32x2_t arg0_int32x2_t;\n+  int32x2_t arg1_int32x2_t;\n+\n+  out_int32x2_t = vabd_s32 (arg0_int32x2_t, arg1_int32x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vabd\\.s32\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "aba2178820cdcb28f23db96dcf7ea1d1764346fb", "filename": "gcc/testsuite/gcc.target/arm/neon/vabds8.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabds8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabds8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabds8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vabds8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vabds8 (void)\n+{\n+  int8x8_t out_int8x8_t;\n+  int8x8_t arg0_int8x8_t;\n+  int8x8_t arg1_int8x8_t;\n+\n+  out_int8x8_t = vabd_s8 (arg0_int8x8_t, arg1_int8x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vabd\\.s8\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "bbb779ad83907193e69d97ce92bf99746d5341f1", "filename": "gcc/testsuite/gcc.target/arm/neon/vabdu16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabdu16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabdu16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabdu16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vabdu16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vabdu16 (void)\n+{\n+  uint16x4_t out_uint16x4_t;\n+  uint16x4_t arg0_uint16x4_t;\n+  uint16x4_t arg1_uint16x4_t;\n+\n+  out_uint16x4_t = vabd_u16 (arg0_uint16x4_t, arg1_uint16x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vabd\\.u16\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "d51068cb6466429760c38398d3a52019dbb063ef", "filename": "gcc/testsuite/gcc.target/arm/neon/vabdu32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabdu32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabdu32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabdu32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vabdu32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vabdu32 (void)\n+{\n+  uint32x2_t out_uint32x2_t;\n+  uint32x2_t arg0_uint32x2_t;\n+  uint32x2_t arg1_uint32x2_t;\n+\n+  out_uint32x2_t = vabd_u32 (arg0_uint32x2_t, arg1_uint32x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vabd\\.u32\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "066c6555ff690a9fb5d732811770d0b777c64d40", "filename": "gcc/testsuite/gcc.target/arm/neon/vabdu8.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabdu8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabdu8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabdu8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vabdu8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vabdu8 (void)\n+{\n+  uint8x8_t out_uint8x8_t;\n+  uint8x8_t arg0_uint8x8_t;\n+  uint8x8_t arg1_uint8x8_t;\n+\n+  out_uint8x8_t = vabd_u8 (arg0_uint8x8_t, arg1_uint8x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vabd\\.u8\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "137a568fde7c7eb130415f3ef5642554500b8f94", "filename": "gcc/testsuite/gcc.target/arm/neon/vabsQf32.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabsQf32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabsQf32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabsQf32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,19 @@\n+/* Test the `vabsQf32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vabsQf32 (void)\n+{\n+  float32x4_t out_float32x4_t;\n+  float32x4_t arg0_float32x4_t;\n+\n+  out_float32x4_t = vabsq_f32 (arg0_float32x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vabs\\.f32\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "47cf5a66f107f51eb6aa98168cf7d9da45c0743c", "filename": "gcc/testsuite/gcc.target/arm/neon/vabsQs16.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabsQs16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabsQs16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabsQs16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,19 @@\n+/* Test the `vabsQs16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vabsQs16 (void)\n+{\n+  int16x8_t out_int16x8_t;\n+  int16x8_t arg0_int16x8_t;\n+\n+  out_int16x8_t = vabsq_s16 (arg0_int16x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vabs\\.s16\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "f775b5a24e9dc9a8b3c5429c6e9b8e50e6df81de", "filename": "gcc/testsuite/gcc.target/arm/neon/vabsQs32.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabsQs32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabsQs32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabsQs32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,19 @@\n+/* Test the `vabsQs32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vabsQs32 (void)\n+{\n+  int32x4_t out_int32x4_t;\n+  int32x4_t arg0_int32x4_t;\n+\n+  out_int32x4_t = vabsq_s32 (arg0_int32x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vabs\\.s32\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "131244923090faa80255cc69ac8b6accd615578f", "filename": "gcc/testsuite/gcc.target/arm/neon/vabsQs8.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabsQs8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabsQs8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvabsQs8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,19 @@\n+/* Test the `vabsQs8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vabsQs8 (void)\n+{\n+  int8x16_t out_int8x16_t;\n+  int8x16_t arg0_int8x16_t;\n+\n+  out_int8x16_t = vabsq_s8 (arg0_int8x16_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vabs\\.s8\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "53d6c0c5d24657301d5f4dbece201c36fc19f888", "filename": "gcc/testsuite/gcc.target/arm/neon/vabsf32.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabsf32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabsf32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabsf32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,19 @@\n+/* Test the `vabsf32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vabsf32 (void)\n+{\n+  float32x2_t out_float32x2_t;\n+  float32x2_t arg0_float32x2_t;\n+\n+  out_float32x2_t = vabs_f32 (arg0_float32x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vabs\\.f32\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "8f91a70c6b8259407c796e626fa585e8f6e86343", "filename": "gcc/testsuite/gcc.target/arm/neon/vabss16.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabss16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabss16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabss16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,19 @@\n+/* Test the `vabss16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vabss16 (void)\n+{\n+  int16x4_t out_int16x4_t;\n+  int16x4_t arg0_int16x4_t;\n+\n+  out_int16x4_t = vabs_s16 (arg0_int16x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vabs\\.s16\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "75033665aecf39400ddc4e4f293480effab01660", "filename": "gcc/testsuite/gcc.target/arm/neon/vabss32.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabss32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabss32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabss32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,19 @@\n+/* Test the `vabss32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vabss32 (void)\n+{\n+  int32x2_t out_int32x2_t;\n+  int32x2_t arg0_int32x2_t;\n+\n+  out_int32x2_t = vabs_s32 (arg0_int32x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vabs\\.s32\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "c7e77f6653eafce3f23a20ef4415e255ea7445d2", "filename": "gcc/testsuite/gcc.target/arm/neon/vabss8.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabss8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabss8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvabss8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,19 @@\n+/* Test the `vabss8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vabss8 (void)\n+{\n+  int8x8_t out_int8x8_t;\n+  int8x8_t arg0_int8x8_t;\n+\n+  out_int8x8_t = vabs_s8 (arg0_int8x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vabs\\.s8\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "7a232f85eb8e97a2a9225c6d6a52588e1f1d0564", "filename": "gcc/testsuite/gcc.target/arm/neon/vaddQf32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvaddQf32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvaddQf32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvaddQf32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vaddQf32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vaddQf32 (void)\n+{\n+  float32x4_t out_float32x4_t;\n+  float32x4_t arg0_float32x4_t;\n+  float32x4_t arg1_float32x4_t;\n+\n+  out_float32x4_t = vaddq_f32 (arg0_float32x4_t, arg1_float32x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vadd\\.f32\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "a034cfcb1d52a3dd5a0268ece580ed2184bd5beb", "filename": "gcc/testsuite/gcc.target/arm/neon/vaddQs16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvaddQs16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvaddQs16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvaddQs16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vaddQs16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vaddQs16 (void)\n+{\n+  int16x8_t out_int16x8_t;\n+  int16x8_t arg0_int16x8_t;\n+  int16x8_t arg1_int16x8_t;\n+\n+  out_int16x8_t = vaddq_s16 (arg0_int16x8_t, arg1_int16x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vadd\\.i16\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "e99ddb58911417301c3bd758c899d3959840cc80", "filename": "gcc/testsuite/gcc.target/arm/neon/vaddQs32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvaddQs32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvaddQs32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvaddQs32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vaddQs32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vaddQs32 (void)\n+{\n+  int32x4_t out_int32x4_t;\n+  int32x4_t arg0_int32x4_t;\n+  int32x4_t arg1_int32x4_t;\n+\n+  out_int32x4_t = vaddq_s32 (arg0_int32x4_t, arg1_int32x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vadd\\.i32\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "381ce4d74fbca7cef5c768dfb730d86bd9f8fa40", "filename": "gcc/testsuite/gcc.target/arm/neon/vaddQs64.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvaddQs64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvaddQs64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvaddQs64.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vaddQs64' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vaddQs64 (void)\n+{\n+  int64x2_t out_int64x2_t;\n+  int64x2_t arg0_int64x2_t;\n+  int64x2_t arg1_int64x2_t;\n+\n+  out_int64x2_t = vaddq_s64 (arg0_int64x2_t, arg1_int64x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vadd\\.i64\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "28a26765f583a548d86db1e2e8d349af520d5184", "filename": "gcc/testsuite/gcc.target/arm/neon/vaddQs8.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvaddQs8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvaddQs8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvaddQs8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vaddQs8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vaddQs8 (void)\n+{\n+  int8x16_t out_int8x16_t;\n+  int8x16_t arg0_int8x16_t;\n+  int8x16_t arg1_int8x16_t;\n+\n+  out_int8x16_t = vaddq_s8 (arg0_int8x16_t, arg1_int8x16_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vadd\\.i8\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "dd860af23013a8d355b6f2710485f0116afec44f", "filename": "gcc/testsuite/gcc.target/arm/neon/vaddQu16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvaddQu16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvaddQu16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvaddQu16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vaddQu16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vaddQu16 (void)\n+{\n+  uint16x8_t out_uint16x8_t;\n+  uint16x8_t arg0_uint16x8_t;\n+  uint16x8_t arg1_uint16x8_t;\n+\n+  out_uint16x8_t = vaddq_u16 (arg0_uint16x8_t, arg1_uint16x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vadd\\.i16\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "d04f6066379ab69f27eed5b5c164b6b0d7bdcd21", "filename": "gcc/testsuite/gcc.target/arm/neon/vaddQu32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvaddQu32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvaddQu32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvaddQu32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vaddQu32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vaddQu32 (void)\n+{\n+  uint32x4_t out_uint32x4_t;\n+  uint32x4_t arg0_uint32x4_t;\n+  uint32x4_t arg1_uint32x4_t;\n+\n+  out_uint32x4_t = vaddq_u32 (arg0_uint32x4_t, arg1_uint32x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vadd\\.i32\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "ed5b54a710b09281514b6276dcf7d3e583d81471", "filename": "gcc/testsuite/gcc.target/arm/neon/vaddQu64.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvaddQu64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvaddQu64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvaddQu64.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vaddQu64' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vaddQu64 (void)\n+{\n+  uint64x2_t out_uint64x2_t;\n+  uint64x2_t arg0_uint64x2_t;\n+  uint64x2_t arg1_uint64x2_t;\n+\n+  out_uint64x2_t = vaddq_u64 (arg0_uint64x2_t, arg1_uint64x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vadd\\.i64\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "94c27aa81d25ce5ff2f3c7e97d04e0da202f967f", "filename": "gcc/testsuite/gcc.target/arm/neon/vaddQu8.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvaddQu8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvaddQu8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvaddQu8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vaddQu8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vaddQu8 (void)\n+{\n+  uint8x16_t out_uint8x16_t;\n+  uint8x16_t arg0_uint8x16_t;\n+  uint8x16_t arg1_uint8x16_t;\n+\n+  out_uint8x16_t = vaddq_u8 (arg0_uint8x16_t, arg1_uint8x16_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vadd\\.i8\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "646674ed92d074b5838111b5cc4ca3b16a8eea99", "filename": "gcc/testsuite/gcc.target/arm/neon/vaddf32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddf32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddf32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddf32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vaddf32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vaddf32 (void)\n+{\n+  float32x2_t out_float32x2_t;\n+  float32x2_t arg0_float32x2_t;\n+  float32x2_t arg1_float32x2_t;\n+\n+  out_float32x2_t = vadd_f32 (arg0_float32x2_t, arg1_float32x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vadd\\.f32\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "1328a850fefdfeba5cdf8ac5b2a637a11e117465", "filename": "gcc/testsuite/gcc.target/arm/neon/vaddhns16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddhns16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddhns16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddhns16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vaddhns16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vaddhns16 (void)\n+{\n+  int8x8_t out_int8x8_t;\n+  int16x8_t arg0_int16x8_t;\n+  int16x8_t arg1_int16x8_t;\n+\n+  out_int8x8_t = vaddhn_s16 (arg0_int16x8_t, arg1_int16x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vaddhn\\.i16\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "7b54f150061ebeb2642e6cd6f9a3d76022593626", "filename": "gcc/testsuite/gcc.target/arm/neon/vaddhns32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddhns32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddhns32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddhns32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vaddhns32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vaddhns32 (void)\n+{\n+  int16x4_t out_int16x4_t;\n+  int32x4_t arg0_int32x4_t;\n+  int32x4_t arg1_int32x4_t;\n+\n+  out_int16x4_t = vaddhn_s32 (arg0_int32x4_t, arg1_int32x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vaddhn\\.i32\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "5bd6cc02d3c1fd1284ad94ea9d64f31d8b5c7aba", "filename": "gcc/testsuite/gcc.target/arm/neon/vaddhns64.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddhns64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddhns64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddhns64.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vaddhns64' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vaddhns64 (void)\n+{\n+  int32x2_t out_int32x2_t;\n+  int64x2_t arg0_int64x2_t;\n+  int64x2_t arg1_int64x2_t;\n+\n+  out_int32x2_t = vaddhn_s64 (arg0_int64x2_t, arg1_int64x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vaddhn\\.i64\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "87661d8219025f3851c1a53c1d31c7de3a59e4fe", "filename": "gcc/testsuite/gcc.target/arm/neon/vaddhnu16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddhnu16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddhnu16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddhnu16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vaddhnu16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vaddhnu16 (void)\n+{\n+  uint8x8_t out_uint8x8_t;\n+  uint16x8_t arg0_uint16x8_t;\n+  uint16x8_t arg1_uint16x8_t;\n+\n+  out_uint8x8_t = vaddhn_u16 (arg0_uint16x8_t, arg1_uint16x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vaddhn\\.i16\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "db1860df0b9801f70d2b3152ca3d8a5615d8075b", "filename": "gcc/testsuite/gcc.target/arm/neon/vaddhnu32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddhnu32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddhnu32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddhnu32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vaddhnu32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vaddhnu32 (void)\n+{\n+  uint16x4_t out_uint16x4_t;\n+  uint32x4_t arg0_uint32x4_t;\n+  uint32x4_t arg1_uint32x4_t;\n+\n+  out_uint16x4_t = vaddhn_u32 (arg0_uint32x4_t, arg1_uint32x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vaddhn\\.i32\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "461d4ba94781e5889c2610d3265588d5308057ec", "filename": "gcc/testsuite/gcc.target/arm/neon/vaddhnu64.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddhnu64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddhnu64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddhnu64.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vaddhnu64' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vaddhnu64 (void)\n+{\n+  uint32x2_t out_uint32x2_t;\n+  uint64x2_t arg0_uint64x2_t;\n+  uint64x2_t arg1_uint64x2_t;\n+\n+  out_uint32x2_t = vaddhn_u64 (arg0_uint64x2_t, arg1_uint64x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vaddhn\\.i64\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "042eb51eb6ab47353ca8ca126422a1a8b842180a", "filename": "gcc/testsuite/gcc.target/arm/neon/vaddls16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddls16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddls16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddls16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vaddls16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vaddls16 (void)\n+{\n+  int32x4_t out_int32x4_t;\n+  int16x4_t arg0_int16x4_t;\n+  int16x4_t arg1_int16x4_t;\n+\n+  out_int32x4_t = vaddl_s16 (arg0_int16x4_t, arg1_int16x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vaddl\\.s16\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "b2364250ee6ee13f44ebf9de79fee1a505bdac00", "filename": "gcc/testsuite/gcc.target/arm/neon/vaddls32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddls32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddls32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddls32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vaddls32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vaddls32 (void)\n+{\n+  int64x2_t out_int64x2_t;\n+  int32x2_t arg0_int32x2_t;\n+  int32x2_t arg1_int32x2_t;\n+\n+  out_int64x2_t = vaddl_s32 (arg0_int32x2_t, arg1_int32x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vaddl\\.s32\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "b04da8a985e726e09708cac07fd25898e16266cf", "filename": "gcc/testsuite/gcc.target/arm/neon/vaddls8.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddls8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddls8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddls8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vaddls8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vaddls8 (void)\n+{\n+  int16x8_t out_int16x8_t;\n+  int8x8_t arg0_int8x8_t;\n+  int8x8_t arg1_int8x8_t;\n+\n+  out_int16x8_t = vaddl_s8 (arg0_int8x8_t, arg1_int8x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vaddl\\.s8\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "813a8714f801d3dbcd7b878c36eda4b745acdcc8", "filename": "gcc/testsuite/gcc.target/arm/neon/vaddlu16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddlu16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddlu16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddlu16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vaddlu16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vaddlu16 (void)\n+{\n+  uint32x4_t out_uint32x4_t;\n+  uint16x4_t arg0_uint16x4_t;\n+  uint16x4_t arg1_uint16x4_t;\n+\n+  out_uint32x4_t = vaddl_u16 (arg0_uint16x4_t, arg1_uint16x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vaddl\\.u16\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "9815f81ca8113bf73f97c658ed6bfaad4be99fc8", "filename": "gcc/testsuite/gcc.target/arm/neon/vaddlu32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddlu32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddlu32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddlu32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vaddlu32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vaddlu32 (void)\n+{\n+  uint64x2_t out_uint64x2_t;\n+  uint32x2_t arg0_uint32x2_t;\n+  uint32x2_t arg1_uint32x2_t;\n+\n+  out_uint64x2_t = vaddl_u32 (arg0_uint32x2_t, arg1_uint32x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vaddl\\.u32\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "269f1c2c5c6b3a20b0d55bddd9c4c80e39309b9d", "filename": "gcc/testsuite/gcc.target/arm/neon/vaddlu8.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddlu8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddlu8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddlu8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vaddlu8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vaddlu8 (void)\n+{\n+  uint16x8_t out_uint16x8_t;\n+  uint8x8_t arg0_uint8x8_t;\n+  uint8x8_t arg1_uint8x8_t;\n+\n+  out_uint16x8_t = vaddl_u8 (arg0_uint8x8_t, arg1_uint8x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vaddl\\.u8\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "2cf2e53aa3ed84d142893b60eab6be8b88781bed", "filename": "gcc/testsuite/gcc.target/arm/neon/vadds16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvadds16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvadds16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvadds16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vadds16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vadds16 (void)\n+{\n+  int16x4_t out_int16x4_t;\n+  int16x4_t arg0_int16x4_t;\n+  int16x4_t arg1_int16x4_t;\n+\n+  out_int16x4_t = vadd_s16 (arg0_int16x4_t, arg1_int16x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vadd\\.i16\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "a2ec12196405c80b451243ed3b5f08391fd0f9bb", "filename": "gcc/testsuite/gcc.target/arm/neon/vadds32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvadds32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvadds32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvadds32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vadds32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vadds32 (void)\n+{\n+  int32x2_t out_int32x2_t;\n+  int32x2_t arg0_int32x2_t;\n+  int32x2_t arg1_int32x2_t;\n+\n+  out_int32x2_t = vadd_s32 (arg0_int32x2_t, arg1_int32x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vadd\\.i32\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "21a917dae1ff1aa5f6b90d8cc798964efe9874a3", "filename": "gcc/testsuite/gcc.target/arm/neon/vadds64.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvadds64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvadds64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvadds64.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vadds64' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vadds64 (void)\n+{\n+  int64x1_t out_int64x1_t;\n+  int64x1_t arg0_int64x1_t;\n+  int64x1_t arg1_int64x1_t;\n+\n+  out_int64x1_t = vadd_s64 (arg0_int64x1_t, arg1_int64x1_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vadd\\.i64\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "a14e94b6fbdde7cb705f95573bdaf035bd49ab82", "filename": "gcc/testsuite/gcc.target/arm/neon/vadds8.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvadds8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvadds8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvadds8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vadds8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vadds8 (void)\n+{\n+  int8x8_t out_int8x8_t;\n+  int8x8_t arg0_int8x8_t;\n+  int8x8_t arg1_int8x8_t;\n+\n+  out_int8x8_t = vadd_s8 (arg0_int8x8_t, arg1_int8x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vadd\\.i8\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "bcf484eaea50595ac90617ec2446983b126d61e8", "filename": "gcc/testsuite/gcc.target/arm/neon/vaddu16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddu16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddu16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddu16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vaddu16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vaddu16 (void)\n+{\n+  uint16x4_t out_uint16x4_t;\n+  uint16x4_t arg0_uint16x4_t;\n+  uint16x4_t arg1_uint16x4_t;\n+\n+  out_uint16x4_t = vadd_u16 (arg0_uint16x4_t, arg1_uint16x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vadd\\.i16\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "d921476665ca37681d2f5b3e9676b1d2c2530241", "filename": "gcc/testsuite/gcc.target/arm/neon/vaddu32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddu32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddu32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddu32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vaddu32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vaddu32 (void)\n+{\n+  uint32x2_t out_uint32x2_t;\n+  uint32x2_t arg0_uint32x2_t;\n+  uint32x2_t arg1_uint32x2_t;\n+\n+  out_uint32x2_t = vadd_u32 (arg0_uint32x2_t, arg1_uint32x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vadd\\.i32\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "6684785d34cd8be7fceac1bb92b59f00a6c0381f", "filename": "gcc/testsuite/gcc.target/arm/neon/vaddu64.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddu64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddu64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddu64.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vaddu64' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vaddu64 (void)\n+{\n+  uint64x1_t out_uint64x1_t;\n+  uint64x1_t arg0_uint64x1_t;\n+  uint64x1_t arg1_uint64x1_t;\n+\n+  out_uint64x1_t = vadd_u64 (arg0_uint64x1_t, arg1_uint64x1_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vadd\\.i64\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "c06ea4bc3daea63e48822f7996873679cfb6018a", "filename": "gcc/testsuite/gcc.target/arm/neon/vaddu8.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddu8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddu8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddu8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vaddu8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vaddu8 (void)\n+{\n+  uint8x8_t out_uint8x8_t;\n+  uint8x8_t arg0_uint8x8_t;\n+  uint8x8_t arg1_uint8x8_t;\n+\n+  out_uint8x8_t = vadd_u8 (arg0_uint8x8_t, arg1_uint8x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vadd\\.i8\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "2ca47d0de15a030e8586b3d934ba08c071843947", "filename": "gcc/testsuite/gcc.target/arm/neon/vaddws16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddws16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddws16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddws16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vaddws16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vaddws16 (void)\n+{\n+  int32x4_t out_int32x4_t;\n+  int32x4_t arg0_int32x4_t;\n+  int16x4_t arg1_int16x4_t;\n+\n+  out_int32x4_t = vaddw_s16 (arg0_int32x4_t, arg1_int16x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vaddw\\.s16\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "87a8090b3320cfc9d0d778527a22ebe9941e8f99", "filename": "gcc/testsuite/gcc.target/arm/neon/vaddws32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddws32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddws32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddws32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vaddws32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vaddws32 (void)\n+{\n+  int64x2_t out_int64x2_t;\n+  int64x2_t arg0_int64x2_t;\n+  int32x2_t arg1_int32x2_t;\n+\n+  out_int64x2_t = vaddw_s32 (arg0_int64x2_t, arg1_int32x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vaddw\\.s32\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "1ebe6a856284c334e75269e44b0ce7955661c6e1", "filename": "gcc/testsuite/gcc.target/arm/neon/vaddws8.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddws8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddws8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddws8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vaddws8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vaddws8 (void)\n+{\n+  int16x8_t out_int16x8_t;\n+  int16x8_t arg0_int16x8_t;\n+  int8x8_t arg1_int8x8_t;\n+\n+  out_int16x8_t = vaddw_s8 (arg0_int16x8_t, arg1_int8x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vaddw\\.s8\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "bfea209aabf3c2b1babf71f0baaa4526b2d97e6c", "filename": "gcc/testsuite/gcc.target/arm/neon/vaddwu16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddwu16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddwu16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddwu16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vaddwu16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vaddwu16 (void)\n+{\n+  uint32x4_t out_uint32x4_t;\n+  uint32x4_t arg0_uint32x4_t;\n+  uint16x4_t arg1_uint16x4_t;\n+\n+  out_uint32x4_t = vaddw_u16 (arg0_uint32x4_t, arg1_uint16x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vaddw\\.u16\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "738171969577cb4e026bab6857a758fe01bbb462", "filename": "gcc/testsuite/gcc.target/arm/neon/vaddwu32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddwu32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddwu32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddwu32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vaddwu32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vaddwu32 (void)\n+{\n+  uint64x2_t out_uint64x2_t;\n+  uint64x2_t arg0_uint64x2_t;\n+  uint32x2_t arg1_uint32x2_t;\n+\n+  out_uint64x2_t = vaddw_u32 (arg0_uint64x2_t, arg1_uint32x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vaddw\\.u32\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "f87802bee5c24967f1ae5afd477dd095ca8e5f02", "filename": "gcc/testsuite/gcc.target/arm/neon/vaddwu8.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddwu8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddwu8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvaddwu8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vaddwu8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vaddwu8 (void)\n+{\n+  uint16x8_t out_uint16x8_t;\n+  uint16x8_t arg0_uint16x8_t;\n+  uint8x8_t arg1_uint8x8_t;\n+\n+  out_uint16x8_t = vaddw_u8 (arg0_uint16x8_t, arg1_uint8x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vaddw\\.u8\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "b3778cf52ffc6491768950310d4807ea0af56d29", "filename": "gcc/testsuite/gcc.target/arm/neon/vandQs16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvandQs16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvandQs16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvandQs16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vandQs16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vandQs16 (void)\n+{\n+  int16x8_t out_int16x8_t;\n+  int16x8_t arg0_int16x8_t;\n+  int16x8_t arg1_int16x8_t;\n+\n+  out_int16x8_t = vandq_s16 (arg0_int16x8_t, arg1_int16x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vand\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "b153d2cd699cdfda639843ae4a1c7bfb9ff6df45", "filename": "gcc/testsuite/gcc.target/arm/neon/vandQs32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvandQs32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvandQs32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvandQs32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vandQs32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vandQs32 (void)\n+{\n+  int32x4_t out_int32x4_t;\n+  int32x4_t arg0_int32x4_t;\n+  int32x4_t arg1_int32x4_t;\n+\n+  out_int32x4_t = vandq_s32 (arg0_int32x4_t, arg1_int32x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vand\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "6a804e5e7ced5f1db85bb08221fcc3ec963915b9", "filename": "gcc/testsuite/gcc.target/arm/neon/vandQs64.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvandQs64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvandQs64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvandQs64.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vandQs64' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vandQs64 (void)\n+{\n+  int64x2_t out_int64x2_t;\n+  int64x2_t arg0_int64x2_t;\n+  int64x2_t arg1_int64x2_t;\n+\n+  out_int64x2_t = vandq_s64 (arg0_int64x2_t, arg1_int64x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vand\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "bcc3c6fa4ad094c8831722c1f6b898089bd8adcb", "filename": "gcc/testsuite/gcc.target/arm/neon/vandQs8.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvandQs8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvandQs8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvandQs8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vandQs8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vandQs8 (void)\n+{\n+  int8x16_t out_int8x16_t;\n+  int8x16_t arg0_int8x16_t;\n+  int8x16_t arg1_int8x16_t;\n+\n+  out_int8x16_t = vandq_s8 (arg0_int8x16_t, arg1_int8x16_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vand\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "4f1b03c77ae89983c084e9da968ece225b27aab1", "filename": "gcc/testsuite/gcc.target/arm/neon/vandQu16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvandQu16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvandQu16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvandQu16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vandQu16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vandQu16 (void)\n+{\n+  uint16x8_t out_uint16x8_t;\n+  uint16x8_t arg0_uint16x8_t;\n+  uint16x8_t arg1_uint16x8_t;\n+\n+  out_uint16x8_t = vandq_u16 (arg0_uint16x8_t, arg1_uint16x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vand\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "3979f264c86245ddcba103c96af59d1c4d274ac6", "filename": "gcc/testsuite/gcc.target/arm/neon/vandQu32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvandQu32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvandQu32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvandQu32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vandQu32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vandQu32 (void)\n+{\n+  uint32x4_t out_uint32x4_t;\n+  uint32x4_t arg0_uint32x4_t;\n+  uint32x4_t arg1_uint32x4_t;\n+\n+  out_uint32x4_t = vandq_u32 (arg0_uint32x4_t, arg1_uint32x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vand\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "cc523d80975a784083b800d13edd29646af46d0b", "filename": "gcc/testsuite/gcc.target/arm/neon/vandQu64.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvandQu64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvandQu64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvandQu64.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vandQu64' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vandQu64 (void)\n+{\n+  uint64x2_t out_uint64x2_t;\n+  uint64x2_t arg0_uint64x2_t;\n+  uint64x2_t arg1_uint64x2_t;\n+\n+  out_uint64x2_t = vandq_u64 (arg0_uint64x2_t, arg1_uint64x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vand\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "84f0985245e1511ed41406fce5078c8d08766962", "filename": "gcc/testsuite/gcc.target/arm/neon/vandQu8.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvandQu8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvandQu8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvandQu8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vandQu8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vandQu8 (void)\n+{\n+  uint8x16_t out_uint8x16_t;\n+  uint8x16_t arg0_uint8x16_t;\n+  uint8x16_t arg1_uint8x16_t;\n+\n+  out_uint8x16_t = vandq_u8 (arg0_uint8x16_t, arg1_uint8x16_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vand\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "ee77d193b8ea66f91ed46d3840f60c095bcae0d1", "filename": "gcc/testsuite/gcc.target/arm/neon/vands16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvands16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvands16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvands16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vands16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vands16 (void)\n+{\n+  int16x4_t out_int16x4_t;\n+  int16x4_t arg0_int16x4_t;\n+  int16x4_t arg1_int16x4_t;\n+\n+  out_int16x4_t = vand_s16 (arg0_int16x4_t, arg1_int16x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vand\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "26abfdff63a4505cb06db410341aa8cc63873f1e", "filename": "gcc/testsuite/gcc.target/arm/neon/vands32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvands32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvands32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvands32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vands32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vands32 (void)\n+{\n+  int32x2_t out_int32x2_t;\n+  int32x2_t arg0_int32x2_t;\n+  int32x2_t arg1_int32x2_t;\n+\n+  out_int32x2_t = vand_s32 (arg0_int32x2_t, arg1_int32x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vand\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "5a680a897ff0741c323b9dcc741a8cf6bfa0cff1", "filename": "gcc/testsuite/gcc.target/arm/neon/vands64.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvands64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvands64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvands64.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vands64' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vands64 (void)\n+{\n+  int64x1_t out_int64x1_t;\n+  int64x1_t arg0_int64x1_t;\n+  int64x1_t arg1_int64x1_t;\n+\n+  out_int64x1_t = vand_s64 (arg0_int64x1_t, arg1_int64x1_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vand\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "6404bf51517c5854e6ec6c7837511aa8e7e0714f", "filename": "gcc/testsuite/gcc.target/arm/neon/vands8.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvands8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvands8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvands8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vands8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vands8 (void)\n+{\n+  int8x8_t out_int8x8_t;\n+  int8x8_t arg0_int8x8_t;\n+  int8x8_t arg1_int8x8_t;\n+\n+  out_int8x8_t = vand_s8 (arg0_int8x8_t, arg1_int8x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vand\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "470c90fa0ae01c1d73d2db8d7714660fca2003fc", "filename": "gcc/testsuite/gcc.target/arm/neon/vandu16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvandu16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvandu16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvandu16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vandu16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vandu16 (void)\n+{\n+  uint16x4_t out_uint16x4_t;\n+  uint16x4_t arg0_uint16x4_t;\n+  uint16x4_t arg1_uint16x4_t;\n+\n+  out_uint16x4_t = vand_u16 (arg0_uint16x4_t, arg1_uint16x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vand\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "f8369cf38479b027ef20dfe09e053939ed20f465", "filename": "gcc/testsuite/gcc.target/arm/neon/vandu32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvandu32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvandu32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvandu32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vandu32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vandu32 (void)\n+{\n+  uint32x2_t out_uint32x2_t;\n+  uint32x2_t arg0_uint32x2_t;\n+  uint32x2_t arg1_uint32x2_t;\n+\n+  out_uint32x2_t = vand_u32 (arg0_uint32x2_t, arg1_uint32x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vand\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "6c1c0ee1072d3f4176c90275a0c85f980b08f061", "filename": "gcc/testsuite/gcc.target/arm/neon/vandu64.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvandu64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvandu64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvandu64.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vandu64' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vandu64 (void)\n+{\n+  uint64x1_t out_uint64x1_t;\n+  uint64x1_t arg0_uint64x1_t;\n+  uint64x1_t arg1_uint64x1_t;\n+\n+  out_uint64x1_t = vand_u64 (arg0_uint64x1_t, arg1_uint64x1_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vand\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "fa4cfb6b655f56e45175751811eaef8c25aec008", "filename": "gcc/testsuite/gcc.target/arm/neon/vandu8.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvandu8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvandu8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvandu8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vandu8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vandu8 (void)\n+{\n+  uint8x8_t out_uint8x8_t;\n+  uint8x8_t arg0_uint8x8_t;\n+  uint8x8_t arg1_uint8x8_t;\n+\n+  out_uint8x8_t = vand_u8 (arg0_uint8x8_t, arg1_uint8x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vand\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "2da6e98e2fe1eb12c54ffccbe3f799ecec7cace6", "filename": "gcc/testsuite/gcc.target/arm/neon/vbicQs16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbicQs16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbicQs16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbicQs16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vbicQs16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vbicQs16 (void)\n+{\n+  int16x8_t out_int16x8_t;\n+  int16x8_t arg0_int16x8_t;\n+  int16x8_t arg1_int16x8_t;\n+\n+  out_int16x8_t = vbicq_s16 (arg0_int16x8_t, arg1_int16x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vbic\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "0457f40196d46d5ed7aa232339c0bae4c8ec19de", "filename": "gcc/testsuite/gcc.target/arm/neon/vbicQs32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbicQs32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbicQs32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbicQs32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vbicQs32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vbicQs32 (void)\n+{\n+  int32x4_t out_int32x4_t;\n+  int32x4_t arg0_int32x4_t;\n+  int32x4_t arg1_int32x4_t;\n+\n+  out_int32x4_t = vbicq_s32 (arg0_int32x4_t, arg1_int32x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vbic\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "22095ccb382f7b85a9fb8d1c6bf625a63cfd848b", "filename": "gcc/testsuite/gcc.target/arm/neon/vbicQs64.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbicQs64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbicQs64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbicQs64.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vbicQs64' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vbicQs64 (void)\n+{\n+  int64x2_t out_int64x2_t;\n+  int64x2_t arg0_int64x2_t;\n+  int64x2_t arg1_int64x2_t;\n+\n+  out_int64x2_t = vbicq_s64 (arg0_int64x2_t, arg1_int64x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vbic\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "4baa0e2be1dd7dd07d0462205c77a67d0daf88d9", "filename": "gcc/testsuite/gcc.target/arm/neon/vbicQs8.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbicQs8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbicQs8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbicQs8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vbicQs8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vbicQs8 (void)\n+{\n+  int8x16_t out_int8x16_t;\n+  int8x16_t arg0_int8x16_t;\n+  int8x16_t arg1_int8x16_t;\n+\n+  out_int8x16_t = vbicq_s8 (arg0_int8x16_t, arg1_int8x16_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vbic\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "4ae91ea487964782b0d6fade25c8958b8aa0083f", "filename": "gcc/testsuite/gcc.target/arm/neon/vbicQu16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbicQu16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbicQu16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbicQu16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vbicQu16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vbicQu16 (void)\n+{\n+  uint16x8_t out_uint16x8_t;\n+  uint16x8_t arg0_uint16x8_t;\n+  uint16x8_t arg1_uint16x8_t;\n+\n+  out_uint16x8_t = vbicq_u16 (arg0_uint16x8_t, arg1_uint16x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vbic\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "2c74f88e591a2bd21637bb286ee4aa9d3872bdf0", "filename": "gcc/testsuite/gcc.target/arm/neon/vbicQu32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbicQu32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbicQu32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbicQu32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vbicQu32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vbicQu32 (void)\n+{\n+  uint32x4_t out_uint32x4_t;\n+  uint32x4_t arg0_uint32x4_t;\n+  uint32x4_t arg1_uint32x4_t;\n+\n+  out_uint32x4_t = vbicq_u32 (arg0_uint32x4_t, arg1_uint32x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vbic\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "61839b92a93f273957e995b381f399a4f47ec953", "filename": "gcc/testsuite/gcc.target/arm/neon/vbicQu64.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbicQu64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbicQu64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbicQu64.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vbicQu64' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vbicQu64 (void)\n+{\n+  uint64x2_t out_uint64x2_t;\n+  uint64x2_t arg0_uint64x2_t;\n+  uint64x2_t arg1_uint64x2_t;\n+\n+  out_uint64x2_t = vbicq_u64 (arg0_uint64x2_t, arg1_uint64x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vbic\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "b39f91cafb59ee9c5ae6236ff79cb99ef9313c7e", "filename": "gcc/testsuite/gcc.target/arm/neon/vbicQu8.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbicQu8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbicQu8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbicQu8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vbicQu8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vbicQu8 (void)\n+{\n+  uint8x16_t out_uint8x16_t;\n+  uint8x16_t arg0_uint8x16_t;\n+  uint8x16_t arg1_uint8x16_t;\n+\n+  out_uint8x16_t = vbicq_u8 (arg0_uint8x16_t, arg1_uint8x16_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vbic\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "f8b5cb13f5e844e632389a91ee49bcfb7f2e5c9f", "filename": "gcc/testsuite/gcc.target/arm/neon/vbics16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbics16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbics16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbics16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vbics16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vbics16 (void)\n+{\n+  int16x4_t out_int16x4_t;\n+  int16x4_t arg0_int16x4_t;\n+  int16x4_t arg1_int16x4_t;\n+\n+  out_int16x4_t = vbic_s16 (arg0_int16x4_t, arg1_int16x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vbic\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "63e854cee37735e458012760b8dff19c2e63dada", "filename": "gcc/testsuite/gcc.target/arm/neon/vbics32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbics32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbics32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbics32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vbics32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vbics32 (void)\n+{\n+  int32x2_t out_int32x2_t;\n+  int32x2_t arg0_int32x2_t;\n+  int32x2_t arg1_int32x2_t;\n+\n+  out_int32x2_t = vbic_s32 (arg0_int32x2_t, arg1_int32x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vbic\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "10a0b5a114769f1614e845b1e75881d595507c27", "filename": "gcc/testsuite/gcc.target/arm/neon/vbics64.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbics64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbics64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbics64.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vbics64' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vbics64 (void)\n+{\n+  int64x1_t out_int64x1_t;\n+  int64x1_t arg0_int64x1_t;\n+  int64x1_t arg1_int64x1_t;\n+\n+  out_int64x1_t = vbic_s64 (arg0_int64x1_t, arg1_int64x1_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vbic\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "d1e6db56b16b9b024789e8ed1f8be154606e2c3f", "filename": "gcc/testsuite/gcc.target/arm/neon/vbics8.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbics8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbics8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbics8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vbics8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vbics8 (void)\n+{\n+  int8x8_t out_int8x8_t;\n+  int8x8_t arg0_int8x8_t;\n+  int8x8_t arg1_int8x8_t;\n+\n+  out_int8x8_t = vbic_s8 (arg0_int8x8_t, arg1_int8x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vbic\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "c961e8026f9f02e2b36ef8a7af4aee923ef6a57b", "filename": "gcc/testsuite/gcc.target/arm/neon/vbicu16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbicu16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbicu16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbicu16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vbicu16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vbicu16 (void)\n+{\n+  uint16x4_t out_uint16x4_t;\n+  uint16x4_t arg0_uint16x4_t;\n+  uint16x4_t arg1_uint16x4_t;\n+\n+  out_uint16x4_t = vbic_u16 (arg0_uint16x4_t, arg1_uint16x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vbic\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "8c95eb4e1cd5414b6496d3ee964a02387dd3990b", "filename": "gcc/testsuite/gcc.target/arm/neon/vbicu32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbicu32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbicu32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbicu32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vbicu32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vbicu32 (void)\n+{\n+  uint32x2_t out_uint32x2_t;\n+  uint32x2_t arg0_uint32x2_t;\n+  uint32x2_t arg1_uint32x2_t;\n+\n+  out_uint32x2_t = vbic_u32 (arg0_uint32x2_t, arg1_uint32x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vbic\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "e7770168094aca4d884d73125b2ae7704d3ff932", "filename": "gcc/testsuite/gcc.target/arm/neon/vbicu64.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbicu64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbicu64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbicu64.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vbicu64' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vbicu64 (void)\n+{\n+  uint64x1_t out_uint64x1_t;\n+  uint64x1_t arg0_uint64x1_t;\n+  uint64x1_t arg1_uint64x1_t;\n+\n+  out_uint64x1_t = vbic_u64 (arg0_uint64x1_t, arg1_uint64x1_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vbic\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "c121432a90a71617f9c4d5eb4dea0fad6dcd4d5c", "filename": "gcc/testsuite/gcc.target/arm/neon/vbicu8.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbicu8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbicu8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbicu8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vbicu8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vbicu8 (void)\n+{\n+  uint8x8_t out_uint8x8_t;\n+  uint8x8_t arg0_uint8x8_t;\n+  uint8x8_t arg1_uint8x8_t;\n+\n+  out_uint8x8_t = vbic_u8 (arg0_uint8x8_t, arg1_uint8x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vbic\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "76e50053eacaa1b8bbf217e3fa72f5283d2ddb8f", "filename": "gcc/testsuite/gcc.target/arm/neon/vbslQf32.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbslQf32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbslQf32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbslQf32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,21 @@\n+/* Test the `vbslQf32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vbslQf32 (void)\n+{\n+  float32x4_t out_float32x4_t;\n+  uint32x4_t arg0_uint32x4_t;\n+  float32x4_t arg1_float32x4_t;\n+  float32x4_t arg2_float32x4_t;\n+\n+  out_float32x4_t = vbslq_f32 (arg0_uint32x4_t, arg1_float32x4_t, arg2_float32x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"((vbsl)|(vbit)|(vbif))\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "ba97cbe61f8bb39e45c4c0815e0cd49509124139", "filename": "gcc/testsuite/gcc.target/arm/neon/vbslQp16.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbslQp16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbslQp16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbslQp16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,21 @@\n+/* Test the `vbslQp16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vbslQp16 (void)\n+{\n+  poly16x8_t out_poly16x8_t;\n+  uint16x8_t arg0_uint16x8_t;\n+  poly16x8_t arg1_poly16x8_t;\n+  poly16x8_t arg2_poly16x8_t;\n+\n+  out_poly16x8_t = vbslq_p16 (arg0_uint16x8_t, arg1_poly16x8_t, arg2_poly16x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"((vbsl)|(vbit)|(vbif))\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "475739a6d9a1a3a86303ac4328ccf5c47a25b56e", "filename": "gcc/testsuite/gcc.target/arm/neon/vbslQp8.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbslQp8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbslQp8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbslQp8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,21 @@\n+/* Test the `vbslQp8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vbslQp8 (void)\n+{\n+  poly8x16_t out_poly8x16_t;\n+  uint8x16_t arg0_uint8x16_t;\n+  poly8x16_t arg1_poly8x16_t;\n+  poly8x16_t arg2_poly8x16_t;\n+\n+  out_poly8x16_t = vbslq_p8 (arg0_uint8x16_t, arg1_poly8x16_t, arg2_poly8x16_t);\n+}\n+\n+/* { dg-final { scan-assembler \"((vbsl)|(vbit)|(vbif))\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "6780fdad086cb3e24ebc40946b899f1fd077311d", "filename": "gcc/testsuite/gcc.target/arm/neon/vbslQs16.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbslQs16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbslQs16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbslQs16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,21 @@\n+/* Test the `vbslQs16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vbslQs16 (void)\n+{\n+  int16x8_t out_int16x8_t;\n+  uint16x8_t arg0_uint16x8_t;\n+  int16x8_t arg1_int16x8_t;\n+  int16x8_t arg2_int16x8_t;\n+\n+  out_int16x8_t = vbslq_s16 (arg0_uint16x8_t, arg1_int16x8_t, arg2_int16x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"((vbsl)|(vbit)|(vbif))\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "6f2835caaa53f7b0f7b4756c990df3ce125c2223", "filename": "gcc/testsuite/gcc.target/arm/neon/vbslQs32.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbslQs32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbslQs32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbslQs32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,21 @@\n+/* Test the `vbslQs32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vbslQs32 (void)\n+{\n+  int32x4_t out_int32x4_t;\n+  uint32x4_t arg0_uint32x4_t;\n+  int32x4_t arg1_int32x4_t;\n+  int32x4_t arg2_int32x4_t;\n+\n+  out_int32x4_t = vbslq_s32 (arg0_uint32x4_t, arg1_int32x4_t, arg2_int32x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"((vbsl)|(vbit)|(vbif))\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "017f07370a556efcbbd8f40a4683d3cb2781afcd", "filename": "gcc/testsuite/gcc.target/arm/neon/vbslQs64.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbslQs64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbslQs64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbslQs64.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,21 @@\n+/* Test the `vbslQs64' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vbslQs64 (void)\n+{\n+  int64x2_t out_int64x2_t;\n+  uint64x2_t arg0_uint64x2_t;\n+  int64x2_t arg1_int64x2_t;\n+  int64x2_t arg2_int64x2_t;\n+\n+  out_int64x2_t = vbslq_s64 (arg0_uint64x2_t, arg1_int64x2_t, arg2_int64x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"((vbsl)|(vbit)|(vbif))\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "e2ed4021933fb60b8580702bb284441bec636ba4", "filename": "gcc/testsuite/gcc.target/arm/neon/vbslQs8.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbslQs8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbslQs8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbslQs8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,21 @@\n+/* Test the `vbslQs8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vbslQs8 (void)\n+{\n+  int8x16_t out_int8x16_t;\n+  uint8x16_t arg0_uint8x16_t;\n+  int8x16_t arg1_int8x16_t;\n+  int8x16_t arg2_int8x16_t;\n+\n+  out_int8x16_t = vbslq_s8 (arg0_uint8x16_t, arg1_int8x16_t, arg2_int8x16_t);\n+}\n+\n+/* { dg-final { scan-assembler \"((vbsl)|(vbit)|(vbif))\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "99d379c30782e008d560bf46023af82deb0a4c63", "filename": "gcc/testsuite/gcc.target/arm/neon/vbslQu16.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbslQu16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbslQu16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbslQu16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,21 @@\n+/* Test the `vbslQu16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vbslQu16 (void)\n+{\n+  uint16x8_t out_uint16x8_t;\n+  uint16x8_t arg0_uint16x8_t;\n+  uint16x8_t arg1_uint16x8_t;\n+  uint16x8_t arg2_uint16x8_t;\n+\n+  out_uint16x8_t = vbslq_u16 (arg0_uint16x8_t, arg1_uint16x8_t, arg2_uint16x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"((vbsl)|(vbit)|(vbif))\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "7fc71bd76b9e36da11b2b2a1145332d6926e532c", "filename": "gcc/testsuite/gcc.target/arm/neon/vbslQu32.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbslQu32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbslQu32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbslQu32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,21 @@\n+/* Test the `vbslQu32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vbslQu32 (void)\n+{\n+  uint32x4_t out_uint32x4_t;\n+  uint32x4_t arg0_uint32x4_t;\n+  uint32x4_t arg1_uint32x4_t;\n+  uint32x4_t arg2_uint32x4_t;\n+\n+  out_uint32x4_t = vbslq_u32 (arg0_uint32x4_t, arg1_uint32x4_t, arg2_uint32x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"((vbsl)|(vbit)|(vbif))\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "89e19ea70b062fb99f874078515c46b74939b29d", "filename": "gcc/testsuite/gcc.target/arm/neon/vbslQu64.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbslQu64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbslQu64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbslQu64.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,21 @@\n+/* Test the `vbslQu64' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vbslQu64 (void)\n+{\n+  uint64x2_t out_uint64x2_t;\n+  uint64x2_t arg0_uint64x2_t;\n+  uint64x2_t arg1_uint64x2_t;\n+  uint64x2_t arg2_uint64x2_t;\n+\n+  out_uint64x2_t = vbslq_u64 (arg0_uint64x2_t, arg1_uint64x2_t, arg2_uint64x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"((vbsl)|(vbit)|(vbif))\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "c2ea8dd96c6812d0e8ee32283b14b1f13090c34b", "filename": "gcc/testsuite/gcc.target/arm/neon/vbslQu8.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbslQu8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbslQu8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvbslQu8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,21 @@\n+/* Test the `vbslQu8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vbslQu8 (void)\n+{\n+  uint8x16_t out_uint8x16_t;\n+  uint8x16_t arg0_uint8x16_t;\n+  uint8x16_t arg1_uint8x16_t;\n+  uint8x16_t arg2_uint8x16_t;\n+\n+  out_uint8x16_t = vbslq_u8 (arg0_uint8x16_t, arg1_uint8x16_t, arg2_uint8x16_t);\n+}\n+\n+/* { dg-final { scan-assembler \"((vbsl)|(vbit)|(vbif))\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "edbe7dfc1cdd5a9cae218d5fe0c2dc56537af49a", "filename": "gcc/testsuite/gcc.target/arm/neon/vbslf32.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbslf32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbslf32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbslf32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,21 @@\n+/* Test the `vbslf32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vbslf32 (void)\n+{\n+  float32x2_t out_float32x2_t;\n+  uint32x2_t arg0_uint32x2_t;\n+  float32x2_t arg1_float32x2_t;\n+  float32x2_t arg2_float32x2_t;\n+\n+  out_float32x2_t = vbsl_f32 (arg0_uint32x2_t, arg1_float32x2_t, arg2_float32x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"((vbsl)|(vbit)|(vbif))\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "bd02dac04c7ac8bf340d6fb1a503ad71140a2c04", "filename": "gcc/testsuite/gcc.target/arm/neon/vbslp16.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbslp16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbslp16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbslp16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,21 @@\n+/* Test the `vbslp16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vbslp16 (void)\n+{\n+  poly16x4_t out_poly16x4_t;\n+  uint16x4_t arg0_uint16x4_t;\n+  poly16x4_t arg1_poly16x4_t;\n+  poly16x4_t arg2_poly16x4_t;\n+\n+  out_poly16x4_t = vbsl_p16 (arg0_uint16x4_t, arg1_poly16x4_t, arg2_poly16x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"((vbsl)|(vbit)|(vbif))\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "2456c53d25804d2ae5e34ce1c56596d9a4127fb8", "filename": "gcc/testsuite/gcc.target/arm/neon/vbslp8.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbslp8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbslp8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbslp8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,21 @@\n+/* Test the `vbslp8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vbslp8 (void)\n+{\n+  poly8x8_t out_poly8x8_t;\n+  uint8x8_t arg0_uint8x8_t;\n+  poly8x8_t arg1_poly8x8_t;\n+  poly8x8_t arg2_poly8x8_t;\n+\n+  out_poly8x8_t = vbsl_p8 (arg0_uint8x8_t, arg1_poly8x8_t, arg2_poly8x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"((vbsl)|(vbit)|(vbif))\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "f21d509b1cd78377c25cbfef5422ded44d8670f5", "filename": "gcc/testsuite/gcc.target/arm/neon/vbsls16.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbsls16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbsls16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbsls16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,21 @@\n+/* Test the `vbsls16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vbsls16 (void)\n+{\n+  int16x4_t out_int16x4_t;\n+  uint16x4_t arg0_uint16x4_t;\n+  int16x4_t arg1_int16x4_t;\n+  int16x4_t arg2_int16x4_t;\n+\n+  out_int16x4_t = vbsl_s16 (arg0_uint16x4_t, arg1_int16x4_t, arg2_int16x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"((vbsl)|(vbit)|(vbif))\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "81a7975258e632d83fdd50bd7bc81e74b4bdc7a5", "filename": "gcc/testsuite/gcc.target/arm/neon/vbsls32.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbsls32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbsls32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbsls32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,21 @@\n+/* Test the `vbsls32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vbsls32 (void)\n+{\n+  int32x2_t out_int32x2_t;\n+  uint32x2_t arg0_uint32x2_t;\n+  int32x2_t arg1_int32x2_t;\n+  int32x2_t arg2_int32x2_t;\n+\n+  out_int32x2_t = vbsl_s32 (arg0_uint32x2_t, arg1_int32x2_t, arg2_int32x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"((vbsl)|(vbit)|(vbif))\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "fd5e6842a62278bf59c77d70640511107a50df8e", "filename": "gcc/testsuite/gcc.target/arm/neon/vbsls64.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbsls64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbsls64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbsls64.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,21 @@\n+/* Test the `vbsls64' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vbsls64 (void)\n+{\n+  int64x1_t out_int64x1_t;\n+  uint64x1_t arg0_uint64x1_t;\n+  int64x1_t arg1_int64x1_t;\n+  int64x1_t arg2_int64x1_t;\n+\n+  out_int64x1_t = vbsl_s64 (arg0_uint64x1_t, arg1_int64x1_t, arg2_int64x1_t);\n+}\n+\n+/* { dg-final { scan-assembler \"((vbsl)|(vbit)|(vbif))\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "1e7b39a361c84c0827eb2a61b21992232171d1eb", "filename": "gcc/testsuite/gcc.target/arm/neon/vbsls8.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbsls8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbsls8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbsls8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,21 @@\n+/* Test the `vbsls8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vbsls8 (void)\n+{\n+  int8x8_t out_int8x8_t;\n+  uint8x8_t arg0_uint8x8_t;\n+  int8x8_t arg1_int8x8_t;\n+  int8x8_t arg2_int8x8_t;\n+\n+  out_int8x8_t = vbsl_s8 (arg0_uint8x8_t, arg1_int8x8_t, arg2_int8x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"((vbsl)|(vbit)|(vbif))\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "8c6480f321b1b4fac7b0f5f012a7a50cb509c68e", "filename": "gcc/testsuite/gcc.target/arm/neon/vbslu16.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbslu16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbslu16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbslu16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,21 @@\n+/* Test the `vbslu16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vbslu16 (void)\n+{\n+  uint16x4_t out_uint16x4_t;\n+  uint16x4_t arg0_uint16x4_t;\n+  uint16x4_t arg1_uint16x4_t;\n+  uint16x4_t arg2_uint16x4_t;\n+\n+  out_uint16x4_t = vbsl_u16 (arg0_uint16x4_t, arg1_uint16x4_t, arg2_uint16x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"((vbsl)|(vbit)|(vbif))\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "16938cd37fdc1a35a1d28b8b944b8996c423bd92", "filename": "gcc/testsuite/gcc.target/arm/neon/vbslu32.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbslu32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbslu32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbslu32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,21 @@\n+/* Test the `vbslu32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vbslu32 (void)\n+{\n+  uint32x2_t out_uint32x2_t;\n+  uint32x2_t arg0_uint32x2_t;\n+  uint32x2_t arg1_uint32x2_t;\n+  uint32x2_t arg2_uint32x2_t;\n+\n+  out_uint32x2_t = vbsl_u32 (arg0_uint32x2_t, arg1_uint32x2_t, arg2_uint32x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"((vbsl)|(vbit)|(vbif))\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "1370691f62001fb60d6082a1d42a23745bf1fcb7", "filename": "gcc/testsuite/gcc.target/arm/neon/vbslu64.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbslu64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbslu64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbslu64.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,21 @@\n+/* Test the `vbslu64' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vbslu64 (void)\n+{\n+  uint64x1_t out_uint64x1_t;\n+  uint64x1_t arg0_uint64x1_t;\n+  uint64x1_t arg1_uint64x1_t;\n+  uint64x1_t arg2_uint64x1_t;\n+\n+  out_uint64x1_t = vbsl_u64 (arg0_uint64x1_t, arg1_uint64x1_t, arg2_uint64x1_t);\n+}\n+\n+/* { dg-final { scan-assembler \"((vbsl)|(vbit)|(vbif))\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "a3ab7662c3899ee4f4dc7e2e562b358b98c66ee9", "filename": "gcc/testsuite/gcc.target/arm/neon/vbslu8.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbslu8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbslu8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvbslu8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,21 @@\n+/* Test the `vbslu8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vbslu8 (void)\n+{\n+  uint8x8_t out_uint8x8_t;\n+  uint8x8_t arg0_uint8x8_t;\n+  uint8x8_t arg1_uint8x8_t;\n+  uint8x8_t arg2_uint8x8_t;\n+\n+  out_uint8x8_t = vbsl_u8 (arg0_uint8x8_t, arg1_uint8x8_t, arg2_uint8x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"((vbsl)|(vbit)|(vbif))\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "667f0c4ffe8029bb8a454683e17ae460ce06eb50", "filename": "gcc/testsuite/gcc.target/arm/neon/vcageQf32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcageQf32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcageQf32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcageQf32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vcageQf32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vcageQf32 (void)\n+{\n+  uint32x4_t out_uint32x4_t;\n+  float32x4_t arg0_float32x4_t;\n+  float32x4_t arg1_float32x4_t;\n+\n+  out_uint32x4_t = vcageq_f32 (arg0_float32x4_t, arg1_float32x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vacge\\.f32\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "58feeadc325826439364f673ff285e9f66b10861", "filename": "gcc/testsuite/gcc.target/arm/neon/vcagef32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcagef32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcagef32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcagef32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vcagef32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vcagef32 (void)\n+{\n+  uint32x2_t out_uint32x2_t;\n+  float32x2_t arg0_float32x2_t;\n+  float32x2_t arg1_float32x2_t;\n+\n+  out_uint32x2_t = vcage_f32 (arg0_float32x2_t, arg1_float32x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vacge\\.f32\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "6ef7e145011d727160445759278fce6e169f4bf5", "filename": "gcc/testsuite/gcc.target/arm/neon/vcagtQf32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcagtQf32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcagtQf32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcagtQf32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vcagtQf32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vcagtQf32 (void)\n+{\n+  uint32x4_t out_uint32x4_t;\n+  float32x4_t arg0_float32x4_t;\n+  float32x4_t arg1_float32x4_t;\n+\n+  out_uint32x4_t = vcagtq_f32 (arg0_float32x4_t, arg1_float32x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vacgt\\.f32\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "a6bc406cda42c81548c12d95a6e6cd8c6c1d1e52", "filename": "gcc/testsuite/gcc.target/arm/neon/vcagtf32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcagtf32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcagtf32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcagtf32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vcagtf32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vcagtf32 (void)\n+{\n+  uint32x2_t out_uint32x2_t;\n+  float32x2_t arg0_float32x2_t;\n+  float32x2_t arg1_float32x2_t;\n+\n+  out_uint32x2_t = vcagt_f32 (arg0_float32x2_t, arg1_float32x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vacgt\\.f32\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "b26f68d4cb9814291c96ea8b2e5273094509b924", "filename": "gcc/testsuite/gcc.target/arm/neon/vcaleQf32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcaleQf32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcaleQf32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcaleQf32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vcaleQf32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vcaleQf32 (void)\n+{\n+  uint32x4_t out_uint32x4_t;\n+  float32x4_t arg0_float32x4_t;\n+  float32x4_t arg1_float32x4_t;\n+\n+  out_uint32x4_t = vcaleq_f32 (arg0_float32x4_t, arg1_float32x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vacge\\.f32\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "8a3b87db148f4ba58c2097faaec69f8acd4438f6", "filename": "gcc/testsuite/gcc.target/arm/neon/vcalef32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcalef32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcalef32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcalef32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vcalef32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vcalef32 (void)\n+{\n+  uint32x2_t out_uint32x2_t;\n+  float32x2_t arg0_float32x2_t;\n+  float32x2_t arg1_float32x2_t;\n+\n+  out_uint32x2_t = vcale_f32 (arg0_float32x2_t, arg1_float32x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vacge\\.f32\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "6bab9d7c8049d23ef782fbc88e332b43d1826444", "filename": "gcc/testsuite/gcc.target/arm/neon/vcaltQf32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcaltQf32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcaltQf32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcaltQf32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vcaltQf32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vcaltQf32 (void)\n+{\n+  uint32x4_t out_uint32x4_t;\n+  float32x4_t arg0_float32x4_t;\n+  float32x4_t arg1_float32x4_t;\n+\n+  out_uint32x4_t = vcaltq_f32 (arg0_float32x4_t, arg1_float32x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vacgt\\.f32\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "7862aa485fbb2820c2565369ceae0ef7d5f594fe", "filename": "gcc/testsuite/gcc.target/arm/neon/vcaltf32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcaltf32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcaltf32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcaltf32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vcaltf32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vcaltf32 (void)\n+{\n+  uint32x2_t out_uint32x2_t;\n+  float32x2_t arg0_float32x2_t;\n+  float32x2_t arg1_float32x2_t;\n+\n+  out_uint32x2_t = vcalt_f32 (arg0_float32x2_t, arg1_float32x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vacgt\\.f32\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "f8666c29780376ed11d35774db0d62ed3c8ae8ed", "filename": "gcc/testsuite/gcc.target/arm/neon/vceqQf32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvceqQf32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvceqQf32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvceqQf32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vceqQf32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vceqQf32 (void)\n+{\n+  uint32x4_t out_uint32x4_t;\n+  float32x4_t arg0_float32x4_t;\n+  float32x4_t arg1_float32x4_t;\n+\n+  out_uint32x4_t = vceqq_f32 (arg0_float32x4_t, arg1_float32x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vceq\\.f32\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "5c7976c5c22ad1a10b0ed8354b55eb655ffb60a9", "filename": "gcc/testsuite/gcc.target/arm/neon/vceqQp8.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvceqQp8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvceqQp8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvceqQp8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vceqQp8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vceqQp8 (void)\n+{\n+  uint8x16_t out_uint8x16_t;\n+  poly8x16_t arg0_poly8x16_t;\n+  poly8x16_t arg1_poly8x16_t;\n+\n+  out_uint8x16_t = vceqq_p8 (arg0_poly8x16_t, arg1_poly8x16_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vceq\\.i8\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "d072120d37e21b73d9c90631880f68ab39e735e1", "filename": "gcc/testsuite/gcc.target/arm/neon/vceqQs16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvceqQs16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvceqQs16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvceqQs16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vceqQs16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vceqQs16 (void)\n+{\n+  uint16x8_t out_uint16x8_t;\n+  int16x8_t arg0_int16x8_t;\n+  int16x8_t arg1_int16x8_t;\n+\n+  out_uint16x8_t = vceqq_s16 (arg0_int16x8_t, arg1_int16x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vceq\\.i16\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "5e6e2a5f964e044d0e8ccff29e8923754c019f54", "filename": "gcc/testsuite/gcc.target/arm/neon/vceqQs32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvceqQs32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvceqQs32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvceqQs32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vceqQs32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vceqQs32 (void)\n+{\n+  uint32x4_t out_uint32x4_t;\n+  int32x4_t arg0_int32x4_t;\n+  int32x4_t arg1_int32x4_t;\n+\n+  out_uint32x4_t = vceqq_s32 (arg0_int32x4_t, arg1_int32x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vceq\\.i32\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "3b141ec2e670bd19d6d4987ecdbc15668ec37428", "filename": "gcc/testsuite/gcc.target/arm/neon/vceqQs8.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvceqQs8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvceqQs8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvceqQs8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vceqQs8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vceqQs8 (void)\n+{\n+  uint8x16_t out_uint8x16_t;\n+  int8x16_t arg0_int8x16_t;\n+  int8x16_t arg1_int8x16_t;\n+\n+  out_uint8x16_t = vceqq_s8 (arg0_int8x16_t, arg1_int8x16_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vceq\\.i8\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "85a0d890df5c83533347dbf7de80ce12a85e8ec3", "filename": "gcc/testsuite/gcc.target/arm/neon/vceqQu16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvceqQu16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvceqQu16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvceqQu16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vceqQu16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vceqQu16 (void)\n+{\n+  uint16x8_t out_uint16x8_t;\n+  uint16x8_t arg0_uint16x8_t;\n+  uint16x8_t arg1_uint16x8_t;\n+\n+  out_uint16x8_t = vceqq_u16 (arg0_uint16x8_t, arg1_uint16x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vceq\\.i16\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "20824d43ebc252946ff33366aa28dce6a0e65476", "filename": "gcc/testsuite/gcc.target/arm/neon/vceqQu32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvceqQu32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvceqQu32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvceqQu32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vceqQu32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vceqQu32 (void)\n+{\n+  uint32x4_t out_uint32x4_t;\n+  uint32x4_t arg0_uint32x4_t;\n+  uint32x4_t arg1_uint32x4_t;\n+\n+  out_uint32x4_t = vceqq_u32 (arg0_uint32x4_t, arg1_uint32x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vceq\\.i32\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "7a1bb259221396436a99b13e387e1d44845b8ba9", "filename": "gcc/testsuite/gcc.target/arm/neon/vceqQu8.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvceqQu8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvceqQu8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvceqQu8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vceqQu8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vceqQu8 (void)\n+{\n+  uint8x16_t out_uint8x16_t;\n+  uint8x16_t arg0_uint8x16_t;\n+  uint8x16_t arg1_uint8x16_t;\n+\n+  out_uint8x16_t = vceqq_u8 (arg0_uint8x16_t, arg1_uint8x16_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vceq\\.i8\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "5f341e6ff75de2db62f727a7300e15f9c74f4cd0", "filename": "gcc/testsuite/gcc.target/arm/neon/vceqf32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvceqf32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvceqf32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvceqf32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vceqf32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vceqf32 (void)\n+{\n+  uint32x2_t out_uint32x2_t;\n+  float32x2_t arg0_float32x2_t;\n+  float32x2_t arg1_float32x2_t;\n+\n+  out_uint32x2_t = vceq_f32 (arg0_float32x2_t, arg1_float32x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vceq\\.f32\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "8a9496041404ad828121c7e4b8512013af187aca", "filename": "gcc/testsuite/gcc.target/arm/neon/vceqp8.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvceqp8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvceqp8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvceqp8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vceqp8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vceqp8 (void)\n+{\n+  uint8x8_t out_uint8x8_t;\n+  poly8x8_t arg0_poly8x8_t;\n+  poly8x8_t arg1_poly8x8_t;\n+\n+  out_uint8x8_t = vceq_p8 (arg0_poly8x8_t, arg1_poly8x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vceq\\.i8\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "6bb327628575f1537542564af4867c542f3f7405", "filename": "gcc/testsuite/gcc.target/arm/neon/vceqs16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvceqs16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvceqs16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvceqs16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vceqs16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vceqs16 (void)\n+{\n+  uint16x4_t out_uint16x4_t;\n+  int16x4_t arg0_int16x4_t;\n+  int16x4_t arg1_int16x4_t;\n+\n+  out_uint16x4_t = vceq_s16 (arg0_int16x4_t, arg1_int16x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vceq\\.i16\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "254cb073707a826e5a9a22fd3b6bfea89d692218", "filename": "gcc/testsuite/gcc.target/arm/neon/vceqs32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvceqs32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvceqs32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvceqs32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vceqs32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vceqs32 (void)\n+{\n+  uint32x2_t out_uint32x2_t;\n+  int32x2_t arg0_int32x2_t;\n+  int32x2_t arg1_int32x2_t;\n+\n+  out_uint32x2_t = vceq_s32 (arg0_int32x2_t, arg1_int32x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vceq\\.i32\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "f54eb7703bccaf03ee3e2bfeae9b91f2b60c7109", "filename": "gcc/testsuite/gcc.target/arm/neon/vceqs8.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvceqs8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvceqs8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvceqs8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vceqs8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vceqs8 (void)\n+{\n+  uint8x8_t out_uint8x8_t;\n+  int8x8_t arg0_int8x8_t;\n+  int8x8_t arg1_int8x8_t;\n+\n+  out_uint8x8_t = vceq_s8 (arg0_int8x8_t, arg1_int8x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vceq\\.i8\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "f183aa5627b5fbe5bc36cb5df9847911e7ca68fc", "filename": "gcc/testsuite/gcc.target/arm/neon/vcequ16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcequ16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcequ16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcequ16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vcequ16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vcequ16 (void)\n+{\n+  uint16x4_t out_uint16x4_t;\n+  uint16x4_t arg0_uint16x4_t;\n+  uint16x4_t arg1_uint16x4_t;\n+\n+  out_uint16x4_t = vceq_u16 (arg0_uint16x4_t, arg1_uint16x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vceq\\.i16\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "2c15f6fb530a04ea8bfbb6d398293129c4805430", "filename": "gcc/testsuite/gcc.target/arm/neon/vcequ32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcequ32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcequ32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcequ32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vcequ32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vcequ32 (void)\n+{\n+  uint32x2_t out_uint32x2_t;\n+  uint32x2_t arg0_uint32x2_t;\n+  uint32x2_t arg1_uint32x2_t;\n+\n+  out_uint32x2_t = vceq_u32 (arg0_uint32x2_t, arg1_uint32x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vceq\\.i32\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "049158578087f918f604c9f65eb53bbe3a3c89d5", "filename": "gcc/testsuite/gcc.target/arm/neon/vcequ8.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcequ8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcequ8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcequ8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vcequ8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vcequ8 (void)\n+{\n+  uint8x8_t out_uint8x8_t;\n+  uint8x8_t arg0_uint8x8_t;\n+  uint8x8_t arg1_uint8x8_t;\n+\n+  out_uint8x8_t = vceq_u8 (arg0_uint8x8_t, arg1_uint8x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vceq\\.i8\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "52d77b3e8cf6c1d43bf2acecdaaddaa82666a7c9", "filename": "gcc/testsuite/gcc.target/arm/neon/vcgeQf32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcgeQf32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcgeQf32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcgeQf32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vcgeQf32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vcgeQf32 (void)\n+{\n+  uint32x4_t out_uint32x4_t;\n+  float32x4_t arg0_float32x4_t;\n+  float32x4_t arg1_float32x4_t;\n+\n+  out_uint32x4_t = vcgeq_f32 (arg0_float32x4_t, arg1_float32x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vcge\\.f32\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "97c6ba820f9b69e1282dc8f4b095d3cbe5b2985e", "filename": "gcc/testsuite/gcc.target/arm/neon/vcgeQs16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcgeQs16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcgeQs16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcgeQs16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vcgeQs16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vcgeQs16 (void)\n+{\n+  uint16x8_t out_uint16x8_t;\n+  int16x8_t arg0_int16x8_t;\n+  int16x8_t arg1_int16x8_t;\n+\n+  out_uint16x8_t = vcgeq_s16 (arg0_int16x8_t, arg1_int16x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vcge\\.s16\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "e0d33743e0af6aa8a2c3b7ba48d475f64677849b", "filename": "gcc/testsuite/gcc.target/arm/neon/vcgeQs32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcgeQs32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcgeQs32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcgeQs32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vcgeQs32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vcgeQs32 (void)\n+{\n+  uint32x4_t out_uint32x4_t;\n+  int32x4_t arg0_int32x4_t;\n+  int32x4_t arg1_int32x4_t;\n+\n+  out_uint32x4_t = vcgeq_s32 (arg0_int32x4_t, arg1_int32x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vcge\\.s32\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "d655943d528922be9df167b1a2b1e71d09758ebf", "filename": "gcc/testsuite/gcc.target/arm/neon/vcgeQs8.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcgeQs8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcgeQs8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcgeQs8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vcgeQs8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vcgeQs8 (void)\n+{\n+  uint8x16_t out_uint8x16_t;\n+  int8x16_t arg0_int8x16_t;\n+  int8x16_t arg1_int8x16_t;\n+\n+  out_uint8x16_t = vcgeq_s8 (arg0_int8x16_t, arg1_int8x16_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vcge\\.s8\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "58887c8bb8772d786ee5f8c2df78cfc4c12a4b3b", "filename": "gcc/testsuite/gcc.target/arm/neon/vcgeQu16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcgeQu16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcgeQu16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcgeQu16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vcgeQu16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vcgeQu16 (void)\n+{\n+  uint16x8_t out_uint16x8_t;\n+  uint16x8_t arg0_uint16x8_t;\n+  uint16x8_t arg1_uint16x8_t;\n+\n+  out_uint16x8_t = vcgeq_u16 (arg0_uint16x8_t, arg1_uint16x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vcge\\.u16\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "af891ba4880a8c040ed2df8b6ebfedaf9dc9d69f", "filename": "gcc/testsuite/gcc.target/arm/neon/vcgeQu32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcgeQu32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcgeQu32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcgeQu32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vcgeQu32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vcgeQu32 (void)\n+{\n+  uint32x4_t out_uint32x4_t;\n+  uint32x4_t arg0_uint32x4_t;\n+  uint32x4_t arg1_uint32x4_t;\n+\n+  out_uint32x4_t = vcgeq_u32 (arg0_uint32x4_t, arg1_uint32x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vcge\\.u32\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "a42747c466bebc11db4ed4ed48822af383910adc", "filename": "gcc/testsuite/gcc.target/arm/neon/vcgeQu8.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcgeQu8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcgeQu8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcgeQu8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vcgeQu8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vcgeQu8 (void)\n+{\n+  uint8x16_t out_uint8x16_t;\n+  uint8x16_t arg0_uint8x16_t;\n+  uint8x16_t arg1_uint8x16_t;\n+\n+  out_uint8x16_t = vcgeq_u8 (arg0_uint8x16_t, arg1_uint8x16_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vcge\\.u8\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "6b3e502c62f0312527eea80932b7a1b7b24b20ac", "filename": "gcc/testsuite/gcc.target/arm/neon/vcgef32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcgef32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcgef32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcgef32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vcgef32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vcgef32 (void)\n+{\n+  uint32x2_t out_uint32x2_t;\n+  float32x2_t arg0_float32x2_t;\n+  float32x2_t arg1_float32x2_t;\n+\n+  out_uint32x2_t = vcge_f32 (arg0_float32x2_t, arg1_float32x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vcge\\.f32\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "7294f37abf4a95e719c2631093be776678738245", "filename": "gcc/testsuite/gcc.target/arm/neon/vcges16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcges16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcges16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcges16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vcges16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vcges16 (void)\n+{\n+  uint16x4_t out_uint16x4_t;\n+  int16x4_t arg0_int16x4_t;\n+  int16x4_t arg1_int16x4_t;\n+\n+  out_uint16x4_t = vcge_s16 (arg0_int16x4_t, arg1_int16x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vcge\\.s16\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "3310b9e8c0e2da36f931b0ed1c3e1f0009e4a602", "filename": "gcc/testsuite/gcc.target/arm/neon/vcges32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcges32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcges32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcges32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vcges32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vcges32 (void)\n+{\n+  uint32x2_t out_uint32x2_t;\n+  int32x2_t arg0_int32x2_t;\n+  int32x2_t arg1_int32x2_t;\n+\n+  out_uint32x2_t = vcge_s32 (arg0_int32x2_t, arg1_int32x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vcge\\.s32\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "d4f2b4e8bb56a4ff022f47b94c678273e296fbff", "filename": "gcc/testsuite/gcc.target/arm/neon/vcges8.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcges8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcges8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcges8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vcges8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vcges8 (void)\n+{\n+  uint8x8_t out_uint8x8_t;\n+  int8x8_t arg0_int8x8_t;\n+  int8x8_t arg1_int8x8_t;\n+\n+  out_uint8x8_t = vcge_s8 (arg0_int8x8_t, arg1_int8x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vcge\\.s8\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "1ddc763f38d293cc40ccdd03e695532b73dac69c", "filename": "gcc/testsuite/gcc.target/arm/neon/vcgeu16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcgeu16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcgeu16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcgeu16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vcgeu16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vcgeu16 (void)\n+{\n+  uint16x4_t out_uint16x4_t;\n+  uint16x4_t arg0_uint16x4_t;\n+  uint16x4_t arg1_uint16x4_t;\n+\n+  out_uint16x4_t = vcge_u16 (arg0_uint16x4_t, arg1_uint16x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vcge\\.u16\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "dd18404c374eb43685fd9915d413be6d0f36163e", "filename": "gcc/testsuite/gcc.target/arm/neon/vcgeu32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcgeu32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcgeu32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcgeu32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vcgeu32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vcgeu32 (void)\n+{\n+  uint32x2_t out_uint32x2_t;\n+  uint32x2_t arg0_uint32x2_t;\n+  uint32x2_t arg1_uint32x2_t;\n+\n+  out_uint32x2_t = vcge_u32 (arg0_uint32x2_t, arg1_uint32x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vcge\\.u32\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "38484e16ba086a8b11d047c9d0465432c6510e7c", "filename": "gcc/testsuite/gcc.target/arm/neon/vcgeu8.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcgeu8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcgeu8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcgeu8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vcgeu8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vcgeu8 (void)\n+{\n+  uint8x8_t out_uint8x8_t;\n+  uint8x8_t arg0_uint8x8_t;\n+  uint8x8_t arg1_uint8x8_t;\n+\n+  out_uint8x8_t = vcge_u8 (arg0_uint8x8_t, arg1_uint8x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vcge\\.u8\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "2fecd4f6af852b1817a3426d7d10b6b870e005ca", "filename": "gcc/testsuite/gcc.target/arm/neon/vcgtQf32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcgtQf32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcgtQf32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcgtQf32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vcgtQf32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vcgtQf32 (void)\n+{\n+  uint32x4_t out_uint32x4_t;\n+  float32x4_t arg0_float32x4_t;\n+  float32x4_t arg1_float32x4_t;\n+\n+  out_uint32x4_t = vcgtq_f32 (arg0_float32x4_t, arg1_float32x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vcgt\\.f32\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "d6830cb5267d12ee4e45b1e73c63d1552a763ff5", "filename": "gcc/testsuite/gcc.target/arm/neon/vcgtQs16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcgtQs16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcgtQs16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcgtQs16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vcgtQs16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vcgtQs16 (void)\n+{\n+  uint16x8_t out_uint16x8_t;\n+  int16x8_t arg0_int16x8_t;\n+  int16x8_t arg1_int16x8_t;\n+\n+  out_uint16x8_t = vcgtq_s16 (arg0_int16x8_t, arg1_int16x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vcgt\\.s16\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "b6ad60d4fbf41058c3311bd0b75dd43766848432", "filename": "gcc/testsuite/gcc.target/arm/neon/vcgtQs32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcgtQs32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcgtQs32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcgtQs32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vcgtQs32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vcgtQs32 (void)\n+{\n+  uint32x4_t out_uint32x4_t;\n+  int32x4_t arg0_int32x4_t;\n+  int32x4_t arg1_int32x4_t;\n+\n+  out_uint32x4_t = vcgtq_s32 (arg0_int32x4_t, arg1_int32x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vcgt\\.s32\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "357e33ee2f8687bbad11e4b82b596030484e82aa", "filename": "gcc/testsuite/gcc.target/arm/neon/vcgtQs8.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcgtQs8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcgtQs8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcgtQs8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vcgtQs8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vcgtQs8 (void)\n+{\n+  uint8x16_t out_uint8x16_t;\n+  int8x16_t arg0_int8x16_t;\n+  int8x16_t arg1_int8x16_t;\n+\n+  out_uint8x16_t = vcgtq_s8 (arg0_int8x16_t, arg1_int8x16_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vcgt\\.s8\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "875e30ffb4057f1cef150c9a397e01f74c82ec14", "filename": "gcc/testsuite/gcc.target/arm/neon/vcgtQu16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcgtQu16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcgtQu16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcgtQu16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vcgtQu16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vcgtQu16 (void)\n+{\n+  uint16x8_t out_uint16x8_t;\n+  uint16x8_t arg0_uint16x8_t;\n+  uint16x8_t arg1_uint16x8_t;\n+\n+  out_uint16x8_t = vcgtq_u16 (arg0_uint16x8_t, arg1_uint16x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vcgt\\.u16\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "691a65dc690c5ef3ff04c25482a6952296b38e95", "filename": "gcc/testsuite/gcc.target/arm/neon/vcgtQu32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcgtQu32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcgtQu32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcgtQu32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vcgtQu32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vcgtQu32 (void)\n+{\n+  uint32x4_t out_uint32x4_t;\n+  uint32x4_t arg0_uint32x4_t;\n+  uint32x4_t arg1_uint32x4_t;\n+\n+  out_uint32x4_t = vcgtq_u32 (arg0_uint32x4_t, arg1_uint32x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vcgt\\.u32\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "d5148f77605b5ea1bd41e60fadcc160a81f41055", "filename": "gcc/testsuite/gcc.target/arm/neon/vcgtQu8.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcgtQu8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcgtQu8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcgtQu8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vcgtQu8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vcgtQu8 (void)\n+{\n+  uint8x16_t out_uint8x16_t;\n+  uint8x16_t arg0_uint8x16_t;\n+  uint8x16_t arg1_uint8x16_t;\n+\n+  out_uint8x16_t = vcgtq_u8 (arg0_uint8x16_t, arg1_uint8x16_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vcgt\\.u8\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "ea5a97d7267799f6acedb68dfd55cee1e8c7fa14", "filename": "gcc/testsuite/gcc.target/arm/neon/vcgtf32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcgtf32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcgtf32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcgtf32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vcgtf32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vcgtf32 (void)\n+{\n+  uint32x2_t out_uint32x2_t;\n+  float32x2_t arg0_float32x2_t;\n+  float32x2_t arg1_float32x2_t;\n+\n+  out_uint32x2_t = vcgt_f32 (arg0_float32x2_t, arg1_float32x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vcgt\\.f32\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "24ae89b5dfb650d9018d73450d2eebbb196470ae", "filename": "gcc/testsuite/gcc.target/arm/neon/vcgts16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcgts16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcgts16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcgts16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vcgts16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vcgts16 (void)\n+{\n+  uint16x4_t out_uint16x4_t;\n+  int16x4_t arg0_int16x4_t;\n+  int16x4_t arg1_int16x4_t;\n+\n+  out_uint16x4_t = vcgt_s16 (arg0_int16x4_t, arg1_int16x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vcgt\\.s16\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "b724e66697b5f6a2387012f6a57fad6b77075273", "filename": "gcc/testsuite/gcc.target/arm/neon/vcgts32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcgts32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcgts32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcgts32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vcgts32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vcgts32 (void)\n+{\n+  uint32x2_t out_uint32x2_t;\n+  int32x2_t arg0_int32x2_t;\n+  int32x2_t arg1_int32x2_t;\n+\n+  out_uint32x2_t = vcgt_s32 (arg0_int32x2_t, arg1_int32x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vcgt\\.s32\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "9ab5955b8905b6ef7b8053e46ebf0ccffde42fd7", "filename": "gcc/testsuite/gcc.target/arm/neon/vcgts8.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcgts8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcgts8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcgts8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vcgts8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vcgts8 (void)\n+{\n+  uint8x8_t out_uint8x8_t;\n+  int8x8_t arg0_int8x8_t;\n+  int8x8_t arg1_int8x8_t;\n+\n+  out_uint8x8_t = vcgt_s8 (arg0_int8x8_t, arg1_int8x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vcgt\\.s8\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "c13c5cb29b76f7e99356d35f0f3449b17d6449c6", "filename": "gcc/testsuite/gcc.target/arm/neon/vcgtu16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcgtu16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcgtu16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcgtu16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vcgtu16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vcgtu16 (void)\n+{\n+  uint16x4_t out_uint16x4_t;\n+  uint16x4_t arg0_uint16x4_t;\n+  uint16x4_t arg1_uint16x4_t;\n+\n+  out_uint16x4_t = vcgt_u16 (arg0_uint16x4_t, arg1_uint16x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vcgt\\.u16\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "a9e709d0ca5ea7fbbdb766b9f07a3ab5f9734130", "filename": "gcc/testsuite/gcc.target/arm/neon/vcgtu32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcgtu32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcgtu32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcgtu32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vcgtu32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vcgtu32 (void)\n+{\n+  uint32x2_t out_uint32x2_t;\n+  uint32x2_t arg0_uint32x2_t;\n+  uint32x2_t arg1_uint32x2_t;\n+\n+  out_uint32x2_t = vcgt_u32 (arg0_uint32x2_t, arg1_uint32x2_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vcgt\\.u32\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "0c4a6aa590390108c4ec5e5010b4f861a71a1d62", "filename": "gcc/testsuite/gcc.target/arm/neon/vcgtu8.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcgtu8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcgtu8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcgtu8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vcgtu8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vcgtu8 (void)\n+{\n+  uint8x8_t out_uint8x8_t;\n+  uint8x8_t arg0_uint8x8_t;\n+  uint8x8_t arg1_uint8x8_t;\n+\n+  out_uint8x8_t = vcgt_u8 (arg0_uint8x8_t, arg1_uint8x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vcgt\\.u8\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "6adad811d0c37df2c0b278fbe1e8de09b7f4bd97", "filename": "gcc/testsuite/gcc.target/arm/neon/vcleQf32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcleQf32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcleQf32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcleQf32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vcleQf32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vcleQf32 (void)\n+{\n+  uint32x4_t out_uint32x4_t;\n+  float32x4_t arg0_float32x4_t;\n+  float32x4_t arg1_float32x4_t;\n+\n+  out_uint32x4_t = vcleq_f32 (arg0_float32x4_t, arg1_float32x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vcge\\.f32\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "076ae2de1c9d1866409c4180c08f119157c7b97d", "filename": "gcc/testsuite/gcc.target/arm/neon/vcleQs16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcleQs16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcleQs16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcleQs16.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vcleQs16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vcleQs16 (void)\n+{\n+  uint16x8_t out_uint16x8_t;\n+  int16x8_t arg0_int16x8_t;\n+  int16x8_t arg1_int16x8_t;\n+\n+  out_uint16x8_t = vcleq_s16 (arg0_int16x8_t, arg1_int16x8_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vcge\\.s16\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "e0ac8587471a094d0543a9f2b22ca3d877dcc10d", "filename": "gcc/testsuite/gcc.target/arm/neon/vcleQs32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcleQs32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcleQs32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcleQs32.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vcleQs32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vcleQs32 (void)\n+{\n+  uint32x4_t out_uint32x4_t;\n+  int32x4_t arg0_int32x4_t;\n+  int32x4_t arg1_int32x4_t;\n+\n+  out_uint32x4_t = vcleq_s32 (arg0_int32x4_t, arg1_int32x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vcge\\.s32\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "20fe30c78b41bd9467073df16b53a5a66b8095a9", "filename": "gcc/testsuite/gcc.target/arm/neon/vcleQs8.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcleQs8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f77cba027fa1be471081bcd2ec03392246af3a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcleQs8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvcleQs8.c?ref=88f77cba027fa1be471081bcd2ec03392246af3a", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vcleQs8' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vcleQs8 (void)\n+{\n+  uint8x16_t out_uint8x16_t;\n+  int8x16_t arg0_int8x16_t;\n+  int8x16_t arg1_int8x16_t;\n+\n+  out_uint8x16_t = vcleq_s8 (arg0_int8x16_t, arg1_int8x16_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vcge\\.s8\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}]}