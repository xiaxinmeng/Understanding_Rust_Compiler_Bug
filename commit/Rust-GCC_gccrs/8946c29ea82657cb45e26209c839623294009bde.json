{"sha": "8946c29ea82657cb45e26209c839623294009bde", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODk0NmMyOWVhODI2NTdjYjQ1ZTI2MjA5YzgzOTYyMzI5NDAwOWJkZQ==", "commit": {"author": {"name": "Yury Gribov", "email": "y.gribov@samsung.com", "date": "2014-06-16T08:43:47Z"}, "committer": {"name": "Yury Gribov", "email": "ygribov@gcc.gnu.org", "date": "2014-06-16T08:43:47Z"}, "message": "New asan-instrumentation-with-call-threshold parameter.\n\n2014-06-16  Yury Gribov  <y.gribov@samsung.com>\n\n\tNew asan-instrumentation-with-call-threshold parameter.\n\n\tgcc/\n\t* asan.c (check_func): New function.\n\t(maybe_create_ssa_name): Likewise.\n\t(build_check_stmt_with_calls): Likewise.\n\t(use_calls_p): Likewise.\n\t(report_error_func): Change interface.\n\t(build_check_stmt): Allow non-integer lengths; add support\n\tfor new parameter.\n\t(asan_instrument): Likewise.\n\t(instrument_mem_region_access): Moved code to\n\tbuild_check_stmt.\n\t(instrument_derefs): Likewise.\n\t(instrument_strlen_call): Likewise.\n\t* cfgcleanup.c (old_insns_match_p): Add support for new\n\tfunctions.\n\t* doc/invoke.texi: Describe new parameter.\n\t* params.def: Define new parameter.\n\t* params.h: Likewise.\n\t* sanitizer.def: Describe new builtins.\n\n\tgcc/testsuite/\n\t* c-c++-common/asan/instrument-with-calls-1.c: New test.\n\t* c-c++-common/asan/instrument-with-calls-2.c: Likewise.\n\t* c-c++-common/asan/instrument-with-calls-3.c: Likewise.\n\t* c-c++-common/asan/no-redundant-instrumentation-1.c: Update\n\ttest patterns.\n\t* c-c++-common/asan/no-redundant-instrumentation-2.c:\n\tLikewise.\n\t* c-c++-common/asan/no-redundant-instrumentation-4.c:\n\tLikewise.\n\t* c-c++-common/asan/no-redundant-instrumentation-5.c:\n\tLikewise.\n\t* c-c++-common/asan/no-redundant-instrumentation-6.c:\n\tLikewise.\n\t* c-c++-common/asan/no-redundant-instrumentation-7.c:\n\tLikewise.\n\t* c-c++-common/asan/no-redundant-instrumentation-8.c:\n\tLikewise.\n\nFrom-SVN: r211699", "tree": {"sha": "12171e966089acbfa2ba25f2dad65f1ce1ae09e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/12171e966089acbfa2ba25f2dad65f1ce1ae09e5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8946c29ea82657cb45e26209c839623294009bde", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8946c29ea82657cb45e26209c839623294009bde", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8946c29ea82657cb45e26209c839623294009bde", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8946c29ea82657cb45e26209c839623294009bde/comments", "author": null, "committer": null, "parents": [{"sha": "5d5cb4d4c12b658375e64c9854b87fb3c3870d36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d5cb4d4c12b658375e64c9854b87fb3c3870d36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d5cb4d4c12b658375e64c9854b87fb3c3870d36"}], "stats": {"total": 764, "additions": 478, "deletions": 286}, "files": [{"sha": "d5f6f89088f9e5da61ce04b7b0b386159d6794d5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8946c29ea82657cb45e26209c839623294009bde/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8946c29ea82657cb45e26209c839623294009bde/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8946c29ea82657cb45e26209c839623294009bde", "patch": "@@ -1,3 +1,24 @@\n+2014-06-16  Yury Gribov  <y.gribov@samsung.com>\n+\n+\t* asan.c (check_func): New function.\n+\t(maybe_create_ssa_name): Likewise.\n+\t(build_check_stmt_with_calls): Likewise.\n+\t(use_calls_p): Likewise.\n+\t(report_error_func): Change interface.\n+\t(build_check_stmt): Allow non-integer lengths; add support\n+\tfor new parameter.\n+\t(asan_instrument): Likewise.\n+\t(instrument_mem_region_access): Moved code to\n+\tbuild_check_stmt.\n+\t(instrument_derefs): Likewise.\n+\t(instrument_strlen_call): Likewise.\n+\t* cfgcleanup.c (old_insns_match_p): Add support for new\n+\tfunctions.\n+\t* doc/invoke.texi: Describe new parameter.\n+\t* params.def: Define new parameter.\n+\t* params.h: Likewise.\n+\t* sanitizer.def: Describe new builtins.\n+\n 2014-06-16  Richard Biener  <rguenther@suse.de>\n \n \t* tree-ssa-pre.c (eliminate_dom_walker::before_dom_children):"}, {"sha": "19e15247766de6bc1d3f56b1d11ea3dec3fe44ed", "filename": "gcc/asan.c", "status": "modified", "additions": 309, "deletions": 263, "changes": 572, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8946c29ea82657cb45e26209c839623294009bde/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8946c29ea82657cb45e26209c839623294009bde/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=8946c29ea82657cb45e26209c839623294009bde", "patch": "@@ -243,6 +243,19 @@ static GTY(()) tree shadow_ptr_types[2];\n /* Decl for __asan_option_detect_stack_use_after_return.  */\n static GTY(()) tree asan_detect_stack_use_after_return;\n \n+/* Number of instrumentations in current function so far.  */\n+\n+static int asan_num_accesses;\n+\n+/* Check whether we should replace inline instrumentation with calls.  */\n+\n+static inline bool\n+use_calls_p ()\n+{\n+  return ASAN_INSTRUMENTATION_WITH_CALL_THRESHOLD < INT_MAX\n+    && asan_num_accesses >= ASAN_INSTRUMENTATION_WITH_CALL_THRESHOLD;\n+}\n+\n /* Hashtable support for memory references used by gimple\n    statements.  */\n \n@@ -1320,7 +1333,7 @@ asan_protect_global (tree decl)\n    IS_STORE is either 1 (for a store) or 0 (for a load).  */\n \n static tree\n-report_error_func (bool is_store, HOST_WIDE_INT size_in_bytes, bool slow_p)\n+report_error_func (bool is_store, HOST_WIDE_INT size_in_bytes, int *nargs)\n {\n   static enum built_in_function report[2][6]\n     = { { BUILT_IN_ASAN_REPORT_LOAD1, BUILT_IN_ASAN_REPORT_LOAD2,\n@@ -1329,13 +1342,37 @@ report_error_func (bool is_store, HOST_WIDE_INT size_in_bytes, bool slow_p)\n \t{ BUILT_IN_ASAN_REPORT_STORE1, BUILT_IN_ASAN_REPORT_STORE2,\n \t  BUILT_IN_ASAN_REPORT_STORE4, BUILT_IN_ASAN_REPORT_STORE8,\n \t  BUILT_IN_ASAN_REPORT_STORE16, BUILT_IN_ASAN_REPORT_STORE_N } };\n-  if ((size_in_bytes & (size_in_bytes - 1)) != 0\n-      || size_in_bytes > 16\n-      || slow_p)\n-    return builtin_decl_implicit (report[is_store][5]);\n+  if (size_in_bytes == -1)\n+    {\n+      *nargs = 2;\n+      return builtin_decl_implicit (report[is_store][5]);\n+    }\n+  *nargs = 1;\n   return builtin_decl_implicit (report[is_store][exact_log2 (size_in_bytes)]);\n }\n \n+/* Construct a function tree for __asan_{load,store}{1,2,4,8,16,_n}.\n+   IS_STORE is either 1 (for a store) or 0 (for a load).  */\n+\n+static tree\n+check_func (bool is_store, int size_in_bytes, int *nargs)\n+{\n+  static enum built_in_function check[2][6]\n+    = { { BUILT_IN_ASAN_LOAD1, BUILT_IN_ASAN_LOAD2,\n+      BUILT_IN_ASAN_LOAD4, BUILT_IN_ASAN_LOAD8,\n+      BUILT_IN_ASAN_LOAD16, BUILT_IN_ASAN_LOADN },\n+\t{ BUILT_IN_ASAN_STORE1, BUILT_IN_ASAN_STORE2,\n+      BUILT_IN_ASAN_STORE4, BUILT_IN_ASAN_STORE8,\n+      BUILT_IN_ASAN_STORE16, BUILT_IN_ASAN_STOREN } };\n+  if (size_in_bytes == -1)\n+    {\n+      *nargs = 2;\n+      return builtin_decl_implicit (check[is_store][5]);\n+    }\n+  *nargs = 1;\n+  return builtin_decl_implicit (check[is_store][exact_log2 (size_in_bytes)]);\n+}\n+\n /* Split the current basic block and create a condition statement\n    insertion point right before or after the statement pointed to by\n    ITER.  Return an iterator to the point at which the caller might\n@@ -1495,118 +1532,269 @@ build_shadow_mem_access (gimple_stmt_iterator *gsi, location_t location,\n   return gimple_assign_lhs (g);\n }\n \n+/* BASE can already be an SSA_NAME; in that case, do not create a\n+   new SSA_NAME for it.  */\n+\n+static tree\n+maybe_create_ssa_name (location_t loc, tree base, gimple_stmt_iterator *iter,\n+\t\t       bool before_p)\n+{\n+  if (TREE_CODE (base) == SSA_NAME)\n+    return base;\n+  gimple g\n+    = gimple_build_assign_with_ops (TREE_CODE (base),\n+\t\t\t\t    make_ssa_name (TREE_TYPE (base), NULL),\n+\t\t\t\t    base, NULL_TREE);\n+  gimple_set_location (g, loc);\n+  if (before_p)\n+    gsi_insert_before (iter, g, GSI_SAME_STMT);\n+  else\n+    gsi_insert_after (iter, g, GSI_NEW_STMT);\n+  return gimple_assign_lhs (g);\n+}\n+\n+/* Instrument the memory access instruction using callbacks.\n+   Parameters are similar to BUILD_CHECK_STMT.  */\n+\n+static void\n+build_check_stmt_with_calls (location_t loc, tree base, tree len,\n+\t\t\t     HOST_WIDE_INT size_in_bytes, gimple_stmt_iterator *iter,\n+\t\t\t     bool before_p, bool is_store, bool is_scalar_access)\n+{\n+  gimple_stmt_iterator gsi = *iter;\n+  tree base_ssa = maybe_create_ssa_name (loc, base, &gsi, before_p);\n+\n+  gimple g\n+    = gimple_build_assign_with_ops (NOP_EXPR,\n+\t\t\t\t    make_ssa_name (pointer_sized_int_node, NULL),\n+\t\t\t\t    base_ssa, NULL_TREE);\n+  gimple_set_location (g, loc);\n+  if (before_p)\n+    gsi_insert_before (&gsi, g, GSI_NEW_STMT);\n+  else\n+    gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n+  tree base_addr = gimple_assign_lhs (g);\n+\n+  int nargs;\n+  tree fun\n+    = check_func (is_store, is_scalar_access ? size_in_bytes : -1, &nargs);\n+  if (nargs == 1)\n+    g = gimple_build_call (fun, 1, base_addr);\n+  else\n+    {\n+      gcc_assert (nargs == 2);\n+      g = gimple_build_assign_with_ops (NOP_EXPR,\n+\t\t\t\t\tmake_ssa_name (pointer_sized_int_node,\n+\t\t\t\t\t\t       NULL),\n+\t\t\t\t\tlen, NULL_TREE);\n+      gimple_set_location (g, loc);\n+      gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n+      tree sz_arg = gimple_assign_lhs (g);\n+      g = gimple_build_call (fun, nargs, base_addr, sz_arg);\n+    }\n+  gimple_set_location (g, loc);\n+  gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n+\n+  if (!before_p)\n+    {\n+      gsi_next (&gsi);\n+      *iter = gsi;\n+    }\n+}\n+\n /* Instrument the memory access instruction BASE.  Insert new\n    statements before or after ITER.\n \n    Note that the memory access represented by BASE can be either an\n    SSA_NAME, or a non-SSA expression.  LOCATION is the source code\n    location.  IS_STORE is TRUE for a store, FALSE for a load.\n    BEFORE_P is TRUE for inserting the instrumentation code before\n-   ITER, FALSE for inserting it after ITER.\n+   ITER, FALSE for inserting it after ITER.  IS_SCALAR_ACCESS is TRUE\n+   for a scalar memory access and FALSE for memory region access.\n+   NON_ZERO_P is TRUE if memory region is guaranteed to have non-zero\n+   length.  ALIGN tells alignment of accessed memory object.\n+\n+   START_INSTRUMENTED and END_INSTRUMENTED are TRUE if start/end of\n+   memory region have already been instrumented.\n \n    If BEFORE_P is TRUE, *ITER is arranged to still point to the\n    statement it was pointing to prior to calling this function,\n    otherwise, it points to the statement logically following it.  */\n \n static void\n-build_check_stmt (location_t location, tree base, gimple_stmt_iterator *iter,\n-\t\t  bool before_p, bool is_store, HOST_WIDE_INT size_in_bytes,\n-\t\t  bool slow_p = false)\n+build_check_stmt (location_t location, tree base, tree len,\n+\t\t  HOST_WIDE_INT size_in_bytes, gimple_stmt_iterator *iter,\n+\t\t  bool non_zero_len_p, bool before_p, bool is_store,\n+\t\t  bool is_scalar_access, unsigned int align = 0,\n+\t\t  bool start_instrumented = false,\n+\t\t  bool end_instrumented = false)\n {\n-  gimple_stmt_iterator gsi;\n-  basic_block then_bb, else_bb;\n-  tree t, base_addr, shadow;\n+  gimple_stmt_iterator gsi = *iter;\n   gimple g;\n-  tree shadow_ptr_type = shadow_ptr_types[size_in_bytes == 16 ? 1 : 0];\n-  tree shadow_type = TREE_TYPE (shadow_ptr_type);\n   tree uintptr_type\n     = build_nonstandard_integer_type (TYPE_PRECISION (TREE_TYPE (base)), 1);\n-  tree base_ssa = base;\n-  HOST_WIDE_INT real_size_in_bytes = size_in_bytes;\n-  tree sz_arg = NULL_TREE;\n-\n-  if (size_in_bytes == 1)\n-    slow_p = false;\n-  else if ((size_in_bytes & (size_in_bytes - 1)) != 0\n-\t   || size_in_bytes > 16\n-\t   || slow_p)\n+\n+  gcc_assert (!(size_in_bytes > 0 && !non_zero_len_p));\n+\n+  if (len)\n+    len = unshare_expr (len);\n+  else\n+    {\n+      gcc_assert (size_in_bytes != -1);\n+      len = build_int_cst (pointer_sized_int_node, size_in_bytes);\n+    }\n+\n+  if (size_in_bytes > 1)\n     {\n-      real_size_in_bytes = 1;\n-      slow_p = true;\n+      if ((size_in_bytes & (size_in_bytes - 1)) != 0\n+\t  || size_in_bytes > 16)\n+\tsize_in_bytes = -1;\n+      else if (align && align < size_in_bytes * BITS_PER_UNIT)\n+\t{\n+\t  /* On non-strict alignment targets, if\n+\t     16-byte access is just 8-byte aligned,\n+\t     this will result in misaligned shadow\n+\t     memory 2 byte load, but otherwise can\n+\t     be handled using one read.  */\n+\t  if (size_in_bytes != 16\n+\t      || STRICT_ALIGNMENT\n+\t      || align < 8 * BITS_PER_UNIT)\n+\t    size_in_bytes = -1;\n+\t}\n+    }\n+\n+  HOST_WIDE_INT real_size_in_bytes = size_in_bytes == -1 ? 1 : size_in_bytes;\n+\n+  tree shadow_ptr_type = shadow_ptr_types[real_size_in_bytes == 16 ? 1 : 0];\n+  tree shadow_type = TREE_TYPE (shadow_ptr_type);\n+\n+  base = unshare_expr (base);\n+\n+  if (use_calls_p ())\n+    {\n+      gsi = *iter;\n+      build_check_stmt_with_calls (location, base, len, size_in_bytes, iter,\n+\t\t\t\t   before_p, is_store, is_scalar_access);\n+      return;\n+    }\n+\n+  ++asan_num_accesses;\n+\n+  if (!non_zero_len_p)\n+    {\n+      gcc_assert (before_p);\n+\n+      /* So, the length of the memory area to asan-protect is\n+\t non-constant.  Let's guard the generated instrumentation code\n+\t like:\n+\n+\t if (len != 0)\n+\t   {\n+\t     //asan instrumentation code goes here.\n+\t   }\n+\t // falltrough instructions, starting with *ITER.  */\n+\n+      g = gimple_build_cond (NE_EXPR,\n+\t\t\t     len,\n+\t\t\t     build_int_cst (TREE_TYPE (len), 0),\n+\t\t\t     NULL_TREE, NULL_TREE);\n+      gimple_set_location (g, location);\n+\n+      basic_block then_bb, fallthrough_bb;\n+      insert_if_then_before_iter (g, iter, /*then_more_likely_p=*/true,\n+\t\t\t\t  &then_bb, &fallthrough_bb);\n+      /* Note that fallthrough_bb starts with the statement that was\n+\t pointed to by ITER.  */\n+\n+      /* The 'then block' of the 'if (len != 0) condition is where\n+\t we'll generate the asan instrumentation code now.  */\n+      gsi = gsi_last_bb (then_bb);\n+      build_check_stmt (location, base, len, size_in_bytes, &gsi,\n+\t\t\t/*non_zero_len_p*/true, /*before_p*/true, is_store,\n+\t\t\tis_scalar_access, align,\n+\t\t\tstart_instrumented, end_instrumented);\n+      return;\n     }\n \n   /* Get an iterator on the point where we can add the condition\n      statement for the instrumentation.  */\n-  gsi = create_cond_insert_point (iter, before_p,\n+  basic_block then_bb, else_bb;\n+  gsi = create_cond_insert_point (&gsi, before_p,\n \t\t\t\t  /*then_more_likely_p=*/false,\n \t\t\t\t  /*create_then_fallthru_edge=*/false,\n \t\t\t\t  &then_bb,\n \t\t\t\t  &else_bb);\n \n-  base = unshare_expr (base);\n-\n-  /* BASE can already be an SSA_NAME; in that case, do not create a\n-     new SSA_NAME for it.  */\n-  if (TREE_CODE (base) != SSA_NAME)\n-    {\n-      g = gimple_build_assign_with_ops (TREE_CODE (base),\n-\t\t\t\t\tmake_ssa_name (TREE_TYPE (base), NULL),\n-\t\t\t\t\tbase, NULL_TREE);\n-      gimple_set_location (g, location);\n-      gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n-      base_ssa = gimple_assign_lhs (g);\n-    }\n+  tree base_ssa = maybe_create_ssa_name (location, base, &gsi,\n+\t\t\t\t\t /*before_p*/false);\n \n   g = gimple_build_assign_with_ops (NOP_EXPR,\n \t\t\t\t    make_ssa_name (uintptr_type, NULL),\n \t\t\t\t    base_ssa, NULL_TREE);\n   gimple_set_location (g, location);\n   gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n-  base_addr = gimple_assign_lhs (g);\n-\n-  /* Build\n-     (base_addr >> ASAN_SHADOW_SHIFT) + targetm.asan_shadow_offset ().  */\n-  shadow = build_shadow_mem_access (&gsi, location, base_addr,\n-\t\t\t\t    shadow_ptr_type);\n+  tree base_addr = gimple_assign_lhs (g);\n \n-  if (real_size_in_bytes < 8)\n+  tree t;\n+  if (real_size_in_bytes >= 8)\n+    {\n+      tree shadow = build_shadow_mem_access (&gsi, location, base_addr,\n+\t\t\t\t\t     shadow_ptr_type);\n+      t = shadow;\n+    }\n+  else\n     {\n-      /* Slow path for 1, 2 and 4 byte accesses.\n-\t Test (shadow != 0)\n-\t      & ((base_addr & 7) + (real_size_in_bytes - 1)) >= shadow).  */\n-      gimple_seq seq = NULL;\n-      gimple shadow_test = build_assign (NE_EXPR, shadow, 0);\n-      gimple_seq_add_stmt (&seq, shadow_test);\n-      gimple_seq_add_stmt (&seq, build_assign (BIT_AND_EXPR, base_addr, 7));\n-      gimple_seq_add_stmt (&seq, build_type_cast (shadow_type,\n-                                                  gimple_seq_last (seq)));\n-      if (real_size_in_bytes > 1)\n-        gimple_seq_add_stmt (&seq,\n-                             build_assign (PLUS_EXPR, gimple_seq_last (seq),\n-\t\t\t\t\t   real_size_in_bytes - 1));\n-      gimple_seq_add_stmt (&seq, build_assign (GE_EXPR, gimple_seq_last (seq),\n-                                               shadow));\n-      gimple_seq_add_stmt (&seq, build_assign (BIT_AND_EXPR, shadow_test,\n-                                               gimple_seq_last (seq)));\n-      t = gimple_assign_lhs (gimple_seq_last (seq));\n-      gimple_seq_set_location (seq, location);\n-      gsi_insert_seq_after (&gsi, seq, GSI_CONTINUE_LINKING);\n-      /* For weird access sizes or misaligned, check first and last byte.  */\n-      if (slow_p)\n+      /* Slow path for 1, 2 and 4 byte accesses.  */\n+\n+      if (!start_instrumented)\n \t{\n+\t  /* Test (shadow != 0)\n+\t\t  & ((base_addr & 7) + (real_size_in_bytes - 1)) >= shadow).  */\n+\t  tree shadow = build_shadow_mem_access (&gsi, location, base_addr,\n+\t\t\t\t\t\t shadow_ptr_type);\n+\t  gimple shadow_test = build_assign (NE_EXPR, shadow, 0);\n+\t  gimple_seq seq = NULL;\n+\t  gimple_seq_add_stmt (&seq, shadow_test);\n+\t  gimple_seq_add_stmt (&seq, build_assign (BIT_AND_EXPR, base_addr, 7));\n+\t  gimple_seq_add_stmt (&seq, build_type_cast (shadow_type,\n+\t\t\t\t\t\t      gimple_seq_last (seq)));\n+\t  if (real_size_in_bytes > 1)\n+\t    gimple_seq_add_stmt (&seq,\n+\t\t\t\t build_assign (PLUS_EXPR, gimple_seq_last (seq),\n+\t\t\t\t\t       real_size_in_bytes - 1));\n+\t  gimple_seq_add_stmt (&seq, build_assign (GE_EXPR,\n+\t\t\t\t\t\t   gimple_seq_last (seq),\n+\t\t\t\t\t\t   shadow));\n+\t  gimple_seq_add_stmt (&seq, build_assign (BIT_AND_EXPR, shadow_test,\n+\t\t\t\t\t\t   gimple_seq_last (seq)));\n+\t  t = gimple_assign_lhs (gimple_seq_last (seq));\n+\t  gimple_seq_set_location (seq, location);\n+\t  gsi_insert_seq_after (&gsi, seq, GSI_CONTINUE_LINKING);\n+\t}\n+\n+      /* For non-constant, misaligned or otherwise weird access sizes,\n+\t check first and last byte.  */\n+      if (size_in_bytes == -1 && !end_instrumented)\n+\t{\n+\t  g = gimple_build_assign_with_ops (MINUS_EXPR,\n+\t\t\t\t\t    make_ssa_name (uintptr_type, NULL),\n+\t\t\t\t\t    len,\n+\t\t\t\t\t    build_int_cst (uintptr_type, 1));\n+\t  gimple_set_location (g, location);\n+\t  gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n+\t  tree last = gimple_assign_lhs (g);\n \t  g = gimple_build_assign_with_ops (PLUS_EXPR,\n \t\t\t\t\t    make_ssa_name (uintptr_type, NULL),\n \t\t\t\t\t    base_addr,\n-\t\t\t\t\t    build_int_cst (uintptr_type,\n-\t\t\t\t\t\t\t   size_in_bytes - 1));\n+\t\t\t\t\t    last);\n \t  gimple_set_location (g, location);\n \t  gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n \t  tree base_end_addr = gimple_assign_lhs (g);\n \n-\t  shadow = build_shadow_mem_access (&gsi, location, base_end_addr,\n-\t\t\t\t\t    shadow_ptr_type);\n-\t  seq = NULL;\n-\t  shadow_test = build_assign (NE_EXPR, shadow, 0);\n+\t  tree shadow = build_shadow_mem_access (&gsi, location, base_end_addr,\n+\t\t\t\t\t\t shadow_ptr_type);\n+\t  gimple shadow_test = build_assign (NE_EXPR, shadow, 0);\n+\t  gimple_seq seq = NULL;\n \t  gimple_seq_add_stmt (&seq, shadow_test);\n \t  gimple_seq_add_stmt (&seq, build_assign (BIT_AND_EXPR,\n \t\t\t\t\t\t   base_end_addr, 7));\n@@ -1617,16 +1805,14 @@ build_check_stmt (location_t location, tree base, gimple_stmt_iterator *iter,\n \t\t\t\t\t\t   shadow));\n \t  gimple_seq_add_stmt (&seq, build_assign (BIT_AND_EXPR, shadow_test,\n \t\t\t\t\t\t   gimple_seq_last (seq)));\n-\t  gimple_seq_add_stmt (&seq, build_assign (BIT_IOR_EXPR, t,\n-\t\t\t\t\t\t   gimple_seq_last (seq)));\n+\t  if (!start_instrumented)\n+\t    gimple_seq_add_stmt (&seq, build_assign (BIT_IOR_EXPR, t,\n+\t\t\t\t\t\t     gimple_seq_last (seq)));\n \t  t = gimple_assign_lhs (gimple_seq_last (seq));\n \t  gimple_seq_set_location (seq, location);\n \t  gsi_insert_seq_after (&gsi, seq, GSI_CONTINUE_LINKING);\n-\t  sz_arg = build_int_cst (pointer_sized_int_node, size_in_bytes);\n \t}\n     }\n-  else\n-    t = shadow;\n \n   g = gimple_build_cond (NE_EXPR, t, build_int_cst (TREE_TYPE (t), 0),\n \t\t\t NULL_TREE, NULL_TREE);\n@@ -1635,8 +1821,23 @@ build_check_stmt (location_t location, tree base, gimple_stmt_iterator *iter,\n \n   /* Generate call to the run-time library (e.g. __asan_report_load8).  */\n   gsi = gsi_start_bb (then_bb);\n-  g = gimple_build_call (report_error_func (is_store, size_in_bytes, slow_p),\n-\t\t\t sz_arg ? 2 : 1, base_addr, sz_arg);\n+  int nargs;\n+  tree fun = report_error_func (is_store, is_scalar_access ? size_in_bytes : -1,\n+\t\t\t\t&nargs);\n+  if (nargs == 1)\n+      g = gimple_build_call (fun, 1, base_addr);\n+  else\n+    {\n+      gcc_assert (nargs == 2);\n+      g = gimple_build_assign_with_ops (NOP_EXPR,\n+\t\t\t\t\tmake_ssa_name (pointer_sized_int_node,\n+\t\t\t\t\t\t       NULL),\n+\t\t\t\t\tlen, NULL_TREE);\n+      gimple_set_location (g, location);\n+      gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n+      tree sz_arg = gimple_assign_lhs (g);\n+      g = gimple_build_call (fun, nargs, base_addr, sz_arg);\n+    }\n   gimple_set_location (g, location);\n   gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n \n@@ -1731,31 +1932,10 @@ instrument_derefs (gimple_stmt_iterator *iter, tree t,\n   base = build_fold_addr_expr (t);\n   if (!has_mem_ref_been_instrumented (base, size_in_bytes))\n     {\n-      bool slow_p = false;\n-      if (size_in_bytes > 1)\n-\t{\n-\t  if ((size_in_bytes & (size_in_bytes - 1)) != 0\n-\t      || size_in_bytes > 16)\n-\t    slow_p = true;\n-\t  else\n-\t    {\n-\t      unsigned int align = get_object_alignment (t);\n-\t      if (align < size_in_bytes * BITS_PER_UNIT)\n-\t\t{\n-\t\t  /* On non-strict alignment targets, if\n-\t\t     16-byte access is just 8-byte aligned,\n-\t\t     this will result in misaligned shadow\n-\t\t     memory 2 byte load, but otherwise can\n-\t\t     be handled using one read.  */\n-\t\t  if (size_in_bytes != 16\n-\t\t      || STRICT_ALIGNMENT\n-\t\t      || align < 8 * BITS_PER_UNIT)\n-\t\t    slow_p = true;\n-\t\t}\n-\t    }\n-\t}\n-      build_check_stmt (location, base, iter, /*before_p=*/true,\n-\t\t\tis_store, size_in_bytes, slow_p);\n+      unsigned int align = get_object_alignment (t);\n+      build_check_stmt (location, base, NULL_TREE, size_in_bytes, iter,\n+\t\t\t/*non_zero_len_p*/size_in_bytes > 0, /*before_p=*/true,\n+\t\t\tis_store, /*is_scalar_access*/true, align);\n       update_mem_ref_hash_table (base, size_in_bytes);\n       update_mem_ref_hash_table (t, size_in_bytes);\n     }\n@@ -1780,142 +1960,24 @@ instrument_mem_region_access (tree base, tree len,\n       || integer_zerop (len))\n     return;\n \n-  gimple_stmt_iterator gsi = *iter;\n-\n-  basic_block fallthrough_bb = NULL, then_bb = NULL;\n-\n   /* If the beginning of the memory region has already been\n      instrumented, do not instrument it.  */\n   bool start_instrumented = has_mem_ref_been_instrumented (base, 1);\n \n   /* If the end of the memory region has already been instrumented, do\n-     not instrument it. */\n+     not instrument it.  */\n   tree end = asan_mem_ref_get_end (base, len);\n   bool end_instrumented = has_mem_ref_been_instrumented (end, 1);\n \n-  if (start_instrumented && end_instrumented)\n-    return;\n-\n-  if (!is_gimple_constant (len))\n-    {\n-      /* So, the length of the memory area to asan-protect is\n-\t non-constant.  Let's guard the generated instrumentation code\n-\t like:\n-\n-\t if (len != 0)\n-\t   {\n-\t     //asan instrumentation code goes here.\n-\t   }\n-\t   // falltrough instructions, starting with *ITER.  */\n-\n-      gimple g = gimple_build_cond (NE_EXPR,\n-\t\t\t\t    len,\n-\t\t\t\t    build_int_cst (TREE_TYPE (len), 0),\n-\t\t\t\t    NULL_TREE, NULL_TREE);\n-      gimple_set_location (g, location);\n-      insert_if_then_before_iter (g, iter, /*then_more_likely_p=*/true,\n-\t\t\t\t  &then_bb, &fallthrough_bb);\n-      /* Note that fallthrough_bb starts with the statement that was\n-\t pointed to by ITER.  */\n-\n-      /* The 'then block' of the 'if (len != 0) condition is where\n-\t we'll generate the asan instrumentation code now.  */\n-      gsi = gsi_last_bb (then_bb);\n-    }\n-\n-  if (!start_instrumented)\n-    {\n-      /* Instrument the beginning of the memory region to be accessed,\n-\t and arrange for the rest of the intrumentation code to be\n-\t inserted in the then block *after* the current gsi.  */\n-      build_check_stmt (location, base, &gsi, /*before_p=*/true, is_store, 1);\n-\n-      if (then_bb)\n-\t/* We are in the case where the length of the region is not\n-\t   constant; so instrumentation code is being generated in the\n-\t   'then block' of the 'if (len != 0) condition.  Let's arrange\n-\t   for the subsequent instrumentation statements to go in the\n-\t   'then block'.  */\n-\tgsi = gsi_last_bb (then_bb);\n-      else\n-        {\n-          *iter = gsi;\n-\t  /* Don't remember this access as instrumented, if length\n-\t     is unknown.  It might be zero and not being actually\n-\t     instrumented, so we can't rely on it being instrumented.  */\n-          update_mem_ref_hash_table (base, 1);\n-\t}\n-    }\n-\n-  if (end_instrumented)\n-    return;\n+  HOST_WIDE_INT size_in_bytes = tree_fits_shwi_p (len) ? tree_to_shwi (len) : -1;\n \n-  /* We want to instrument the access at the end of the memory region,\n-     which is at (base + len - 1).  */\n+  build_check_stmt (location, base, len, size_in_bytes, iter,\n+\t\t    /*non_zero_len_p*/size_in_bytes > 0, /*before_p*/true,\n+\t\t    is_store, /*is_scalar_access*/false, /*align*/0,\n+\t\t    start_instrumented, end_instrumented);\n \n-  /* offset = len - 1;  */\n-  len = unshare_expr (len);\n-  tree offset;\n-  gimple_seq seq = NULL;\n-  if (TREE_CODE (len) == INTEGER_CST)\n-    offset = fold_build2 (MINUS_EXPR, size_type_node,\n-\t\t\t  fold_convert (size_type_node, len),\n-\t\t\t  build_int_cst (size_type_node, 1));\n-  else\n-    {\n-      gimple g;\n-      tree t;\n-\n-      if (TREE_CODE (len) != SSA_NAME)\n-\t{\n-\t  t = make_ssa_name (TREE_TYPE (len), NULL);\n-\t  g = gimple_build_assign_with_ops (TREE_CODE (len), t, len, NULL);\n-\t  gimple_set_location (g, location);\n-\t  gimple_seq_add_stmt_without_update (&seq, g);\n-\t  len = t;\n-\t}\n-      if (!useless_type_conversion_p (size_type_node, TREE_TYPE (len)))\n-\t{\n-\t  t = make_ssa_name (size_type_node, NULL);\n-\t  g = gimple_build_assign_with_ops (NOP_EXPR, t, len, NULL);\n-\t  gimple_set_location (g, location);\n-\t  gimple_seq_add_stmt_without_update (&seq, g);\n-\t  len = t;\n-\t}\n-\n-      t = make_ssa_name (size_type_node, NULL);\n-      g = gimple_build_assign_with_ops (MINUS_EXPR, t, len,\n-\t\t\t\t\tbuild_int_cst (size_type_node, 1));\n-      gimple_set_location (g, location);\n-      gimple_seq_add_stmt_without_update (&seq, g);\n-      offset = gimple_assign_lhs (g);\n-    }\n-\n-  /* _1 = base;  */\n-  base = unshare_expr (base);\n-  gimple region_end =\n-    gimple_build_assign_with_ops (TREE_CODE (base),\n-\t\t\t\t  make_ssa_name (TREE_TYPE (base), NULL),\n-\t\t\t\t  base, NULL);\n-  gimple_set_location (region_end, location);\n-  gimple_seq_add_stmt_without_update (&seq, region_end);\n-\n-  /* _2 = _1 + offset;  */\n-  region_end =\n-    gimple_build_assign_with_ops (POINTER_PLUS_EXPR,\n-\t\t\t\t  make_ssa_name (TREE_TYPE (base), NULL),\n-\t\t\t\t  gimple_assign_lhs (region_end),\n-\t\t\t\t  offset);\n-  gimple_set_location (region_end, location);\n-  gimple_seq_add_stmt_without_update (&seq, region_end);\n-  gsi_insert_seq_before (&gsi, seq, GSI_SAME_STMT);\n-\n-  /* instrument access at _2;  */\n-  gsi = gsi_for_stmt (region_end);\n-  build_check_stmt (location, gimple_assign_lhs (region_end),\n-\t\t    &gsi, /*before_p=*/false, is_store, 1);\n-\n-  if (then_bb == NULL)\n+  update_mem_ref_hash_table (base, 1);\n+  if (size_in_bytes != -1)\n     update_mem_ref_hash_table (end, 1);\n \n   *iter = gsi_for_stmt (gsi_stmt (*iter));\n@@ -1957,47 +2019,30 @@ instrument_strlen_call (gimple_stmt_iterator *iter)\n   location_t loc = gimple_location (call);\n   tree str_arg = gimple_call_arg (call, 0);\n \n-  /* Instrument the access to the first byte of str_arg.  i.e:\n-\n-     _1 = str_arg; instrument (_1); */\n   tree cptr_type = build_pointer_type (char_type_node);\n   gimple str_arg_ssa =\n     gimple_build_assign_with_ops (NOP_EXPR,\n \t\t\t\t  make_ssa_name (cptr_type, NULL),\n \t\t\t\t  str_arg, NULL);\n   gimple_set_location (str_arg_ssa, loc);\n-  gimple_stmt_iterator gsi = *iter;\n-  gsi_insert_before (&gsi, str_arg_ssa, GSI_NEW_STMT);\n-  build_check_stmt (loc, gimple_assign_lhs (str_arg_ssa), &gsi,\n-\t\t    /*before_p=*/false, /*is_store=*/false, 1);\n+  gsi_insert_before (iter, str_arg_ssa, GSI_SAME_STMT);\n \n-  /* If we initially had an instruction like:\n+  build_check_stmt (loc, gimple_assign_lhs (str_arg_ssa), NULL_TREE, 1, iter,\n+\t\t    /*non_zero_len_p*/true, /*before_p=*/true,\n+\t\t    /*is_store=*/false, /*is_scalar_access*/false, /*align*/0);\n \n-\t int n = strlen (str)\n-\n-     we now want to instrument the access to str[n], after the\n-     instruction above.*/\n-\n-  /* So let's build the access to str[n] that is, access through the\n-     pointer_plus expr: (_1 + len).  */\n   gimple stmt =\n-    gimple_build_assign_with_ops (POINTER_PLUS_EXPR,\n-\t\t\t\t  make_ssa_name (cptr_type, NULL),\n-\t\t\t\t  gimple_assign_lhs (str_arg_ssa),\n-\t\t\t\t  len);\n+    gimple_build_assign_with_ops (PLUS_EXPR,\n+\t\t\t\t  make_ssa_name (TREE_TYPE (len), NULL),\n+\t\t\t\t  len,\n+\t\t\t\t  build_int_cst (TREE_TYPE (len), 1));\n   gimple_set_location (stmt, loc);\n-  gsi_insert_after (&gsi, stmt, GSI_NEW_STMT);\n-\n-  build_check_stmt (loc, gimple_assign_lhs (stmt), &gsi,\n-\t\t    /*before_p=*/false, /*is_store=*/false, 1);\n-\n-  /* Ensure that iter points to the statement logically following the\n-     one it was initially pointing to.  */\n-  *iter = gsi;\n-  /* As *ITER has been advanced to point to the next statement, let's\n-     return true to inform transform_statements that it shouldn't\n-     advance *ITER anymore; otherwises it will skip that next\n-     statement, which wouldn't be instrumented.  */\n+  gsi_insert_after (iter, stmt, GSI_NEW_STMT);\n+\n+  build_check_stmt (loc, gimple_assign_lhs (stmt), len, 1, iter,\n+\t\t    /*non_zero_len_p*/true, /*before_p=*/false,\n+\t\t    /*is_store=*/false, /*is_scalar_access*/false, /*align*/0);\n+\n   return true;\n }\n \n@@ -2569,6 +2614,7 @@ asan_instrument (void)\n {\n   if (shadow_ptr_types[0] == NULL_TREE)\n     asan_init_shadow_ptr_types ();\n+  asan_num_accesses = 0;\n   transform_statements ();\n   return 0;\n }"}, {"sha": "10688bcca5cf68f7812783aa6a10d477f7e47b84", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8946c29ea82657cb45e26209c839623294009bde/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8946c29ea82657cb45e26209c839623294009bde/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=8946c29ea82657cb45e26209c839623294009bde", "patch": "@@ -1174,7 +1174,7 @@ old_insns_match_p (int mode ATTRIBUTE_UNUSED, rtx i1, rtx i2)\n \t\t      && DECL_FUNCTION_CODE (SYMBOL_REF_DECL (symbol))\n \t\t\t >= BUILT_IN_ASAN_REPORT_LOAD1\n \t\t      && DECL_FUNCTION_CODE (SYMBOL_REF_DECL (symbol))\n-\t\t\t <= BUILT_IN_ASAN_REPORT_STORE16)\n+\t\t\t <= BUILT_IN_ASAN_STOREN)\n \t\t    return dir_none;\n \t\t}\n \t    }"}, {"sha": "9a34f1cb9776db7b2fa212debeb4a706785a7a15", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8946c29ea82657cb45e26209c839623294009bde/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8946c29ea82657cb45e26209c839623294009bde/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=8946c29ea82657cb45e26209c839623294009bde", "patch": "@@ -10244,6 +10244,12 @@ is enabled by default when using @option{-fsanitize=address} option.\n To disable use-after-return detection use \n @option{--param asan-use-after-return=0}.\n \n+@item asan-instrumentation-with-call-threshold\n+Once number of memory accesses  in function becomes greater\n+or equal than this number, use callbacks instead of\n+generating inline code.  E.g. to disable inline code use\n+@option{--param asan-instrumentation-with-call-threshold=0}.\n+\n @end table\n @end table\n "}, {"sha": "28ef79a0650aa3712b8ef06c61c0874973bcde42", "filename": "gcc/params.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8946c29ea82657cb45e26209c839623294009bde/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8946c29ea82657cb45e26209c839623294009bde/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=8946c29ea82657cb45e26209c839623294009bde", "patch": "@@ -1090,6 +1090,12 @@ DEFPARAM (PARAM_ASAN_USE_AFTER_RETURN,\n          \"Enable asan builtin functions protection\",\n          1, 0, 1)\n \n+DEFPARAM (PARAM_ASAN_INSTRUMENTATION_WITH_CALL_THRESHOLD,\n+         \"asan-instrumentation-with-call-threshold\",\n+         \"Use callbacks instead of inline code once number of accesses \"\n+         \" in function becomes greater or equal than this threshold\",\n+         10000, 0, INT_MAX)\n+\n DEFPARAM (PARAM_UNINIT_CONTROL_DEP_ATTEMPTS,\n \t  \"uninit-control-dep-attempts\",\n \t  \"Maximum number of nested calls to search for control dependencies \""}, {"sha": "d488e32ebfe453951f02ef839104e2f0ff967187", "filename": "gcc/params.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8946c29ea82657cb45e26209c839623294009bde/gcc%2Fparams.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8946c29ea82657cb45e26209c839623294009bde/gcc%2Fparams.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.h?ref=8946c29ea82657cb45e26209c839623294009bde", "patch": "@@ -232,5 +232,7 @@ extern void init_param_values (int *params);\n   PARAM_VALUE (PARAM_ASAN_MEMINTRIN)\n #define ASAN_USE_AFTER_RETURN \\\n   PARAM_VALUE (PARAM_ASAN_USE_AFTER_RETURN)\n+#define ASAN_INSTRUMENTATION_WITH_CALL_THRESHOLD \\\n+  PARAM_VALUE (PARAM_ASAN_INSTRUMENTATION_WITH_CALL_THRESHOLD)\n \n #endif /* ! GCC_PARAMS_H */"}, {"sha": "b4af1649258fc9adab3c9c0b22c968ebe50c6117", "filename": "gcc/sanitizer.def", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8946c29ea82657cb45e26209c839623294009bde/gcc%2Fsanitizer.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8946c29ea82657cb45e26209c839623294009bde/gcc%2Fsanitizer.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsanitizer.def?ref=8946c29ea82657cb45e26209c839623294009bde", "patch": "@@ -29,7 +29,7 @@ along with GCC; see the file COPYING3.  If not see\n /* Address Sanitizer */\n DEF_SANITIZER_BUILTIN(BUILT_IN_ASAN_INIT, \"__asan_init_v3\",\n \t\t      BT_FN_VOID, ATTR_NOTHROW_LEAF_LIST)\n-/* Do not reorder the BUILT_IN_ASAN_REPORT* builtins, e.g. cfgcleanup.c\n+/* Do not reorder the BUILT_IN_ASAN_{REPORT,CHECK}* builtins, e.g. cfgcleanup.c\n    relies on this order.  */\n DEF_SANITIZER_BUILTIN(BUILT_IN_ASAN_REPORT_LOAD1, \"__asan_report_load1\",\n \t\t      BT_FN_VOID_PTR, ATTR_TMPURE_NORETURN_NOTHROW_LEAF_LIST)\n@@ -57,6 +57,30 @@ DEF_SANITIZER_BUILTIN(BUILT_IN_ASAN_REPORT_STORE16, \"__asan_report_store16\",\n DEF_SANITIZER_BUILTIN(BUILT_IN_ASAN_REPORT_STORE_N, \"__asan_report_store_n\",\n \t\t      BT_FN_VOID_PTR_PTRMODE,\n \t\t      ATTR_TMPURE_NORETURN_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_ASAN_LOAD1, \"__asan_load1\",\n+\t\t      BT_FN_VOID_PTR, ATTR_TMPURE_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_ASAN_LOAD2, \"__asan_load2\",\n+\t\t      BT_FN_VOID_PTR, ATTR_TMPURE_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_ASAN_LOAD4, \"__asan_load4\",\n+\t\t      BT_FN_VOID_PTR, ATTR_TMPURE_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_ASAN_LOAD8, \"__asan_load8\",\n+\t\t      BT_FN_VOID_PTR, ATTR_TMPURE_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_ASAN_LOAD16, \"__asan_load16\",\n+\t\t      BT_FN_VOID_PTR, ATTR_TMPURE_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_ASAN_LOADN, \"__asan_loadN\",\n+\t\t      BT_FN_VOID_PTR_PTRMODE, ATTR_TMPURE_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_ASAN_STORE1, \"__asan_store1\",\n+\t\t      BT_FN_VOID_PTR, ATTR_TMPURE_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_ASAN_STORE2, \"__asan_store2\",\n+\t\t      BT_FN_VOID_PTR, ATTR_TMPURE_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_ASAN_STORE4, \"__asan_store4\",\n+\t\t      BT_FN_VOID_PTR, ATTR_TMPURE_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_ASAN_STORE8, \"__asan_store8\",\n+\t\t      BT_FN_VOID_PTR, ATTR_TMPURE_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_ASAN_STORE16, \"__asan_store16\",\n+\t\t      BT_FN_VOID_PTR, ATTR_TMPURE_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_ASAN_STOREN, \"__asan_storeN\",\n+\t\t      BT_FN_VOID_PTR_PTRMODE, ATTR_TMPURE_NOTHROW_LEAF_LIST)\n DEF_SANITIZER_BUILTIN(BUILT_IN_ASAN_REGISTER_GLOBALS,\n \t\t      \"__asan_register_globals\",\n \t\t      BT_FN_VOID_PTR_PTRMODE, ATTR_NOTHROW_LEAF_LIST)"}, {"sha": "684eb7b669d9cc96a9871b6ba89226516f7eb2b8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8946c29ea82657cb45e26209c839623294009bde/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8946c29ea82657cb45e26209c839623294009bde/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8946c29ea82657cb45e26209c839623294009bde", "patch": "@@ -1,3 +1,23 @@\n+2014-06-16  Yury Gribov  <y.gribov@samsung.com>\n+\n+\t* c-c++-common/asan/instrument-with-calls-1.c: New test.\n+\t* c-c++-common/asan/instrument-with-calls-2.c: Likewise.\n+\t* c-c++-common/asan/instrument-with-calls-3.c: Likewise.\n+\t* c-c++-common/asan/no-redundant-instrumentation-1.c: Update\n+\ttest patterns.\n+\t* c-c++-common/asan/no-redundant-instrumentation-2.c:\n+\tLikewise.\n+\t* c-c++-common/asan/no-redundant-instrumentation-4.c:\n+\tLikewise.\n+\t* c-c++-common/asan/no-redundant-instrumentation-5.c:\n+\tLikewise.\n+\t* c-c++-common/asan/no-redundant-instrumentation-6.c:\n+\tLikewise.\n+\t* c-c++-common/asan/no-redundant-instrumentation-7.c:\n+\tLikewise.\n+\t* c-c++-common/asan/no-redundant-instrumentation-8.c:\n+\tLikewise.\n+\n 2014-06-15  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \tPR fortran/28484"}, {"sha": "80f762057603d4cfe7574cdb14c1e58d6f8c8b6c", "filename": "gcc/testsuite/c-c++-common/asan/instrument-with-calls-1.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8946c29ea82657cb45e26209c839623294009bde/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Finstrument-with-calls-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8946c29ea82657cb45e26209c839623294009bde/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Finstrument-with-calls-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Finstrument-with-calls-1.c?ref=8946c29ea82657cb45e26209c839623294009bde", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do assemble } */\n+/* { dg-options \"--param asan-instrumentation-with-call-threshold=0 -save-temps\" } */\n+\n+void f(char *a, int *b) {\n+  *b = *a;\n+}\n+\n+/* { dg-final { scan-assembler \"__asan_load1\" } } */\n+/* { dg-final { scan-assembler \"__asan_store4\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "570f796ea6fcfcff878fdc29c87689bc689800a2", "filename": "gcc/testsuite/c-c++-common/asan/instrument-with-calls-2.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8946c29ea82657cb45e26209c839623294009bde/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Finstrument-with-calls-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8946c29ea82657cb45e26209c839623294009bde/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Finstrument-with-calls-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Finstrument-with-calls-2.c?ref=8946c29ea82657cb45e26209c839623294009bde", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do assemble } */\n+/* { dg-options \"--param asan-instrumentation-with-call-threshold=1 -save-temps\" } */\n+\n+int x;\n+\n+void f(int *a, int *b) {\n+  *a = 0;\n+  asm volatile (\"\" ::: \"memory\");\n+  x = *b;\n+}\n+\n+/* { dg-final { scan-assembler-not \"__asan_store4\" } } */\n+/* { dg-final { scan-assembler \"__asan_report_store4\" } } */\n+/* { dg-final { scan-assembler \"__asan_load4\" } } */\n+/* { dg-final { scan-assembler-not \"__asan_report_load4\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "3712c7a56aa30420044690789489384b63ce676b", "filename": "gcc/testsuite/c-c++-common/asan/instrument-with-calls-3.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8946c29ea82657cb45e26209c839623294009bde/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Finstrument-with-calls-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8946c29ea82657cb45e26209c839623294009bde/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Finstrument-with-calls-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Finstrument-with-calls-3.c?ref=8946c29ea82657cb45e26209c839623294009bde", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do assemble } */\n+/* { dg-options \"--param asan-instrumentation-with-call-threshold=0 -save-temps\" } */\n+\n+struct A {\n+  char x[7];\n+};\n+\n+void f(struct A *x, struct A *y) {\n+  *x = *y;\n+}\n+\n+/* { dg-final { scan-assembler \"__asan_loadN\" } } */\n+/* { dg-final { scan-assembler \"__asan_storeN\" } } */\n+/* { dg-final { cleanup-saved-temps } } */\n+"}, {"sha": "c7c594ea070afe3b522c02738cc6da1a87a534e4", "filename": "gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-1.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8946c29ea82657cb45e26209c839623294009bde/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8946c29ea82657cb45e26209c839623294009bde/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-1.c?ref=8946c29ea82657cb45e26209c839623294009bde", "patch": "@@ -16,12 +16,11 @@ test0 ()\n   tab[0] = 1;\n   tab[1] = 2;\n \n-  /* __builtin___asan_report_load1 called 1 time for the store\n-     below.  */\n-  char t0 = tab[1];\n-\n   /* This load should not be instrumented because it is to the same\n      memory location as above.  */\n+  char t0 = tab[1];\n+\n+  /* Likewise.  */\n   char t1 = tab[1];\n \n   return t0 + t1;\n@@ -36,24 +35,24 @@ test1 (int i)\n     the initialization.  */\n   foo[i] = 1;\n \n-  /*__builtin___asan_report_store1 called 2 times here to instrument\n+  /*__builtin___asan_report_store_n called once here to instrument\n     the store to the memory region of tab.  */\n   __builtin_memset (tab, 3, sizeof (tab));\n \n   /* There is no instrumentation for the two memset calls below.  */\n   __builtin_memset (tab, 4, sizeof (tab));\n   __builtin_memset (tab, 5, sizeof (tab));\n \n-  /* There are 2 calls to __builtin___asan_report_store1 and 2 calls\n-     to __builtin___asan_report_load1 to instrument the store to\n+  /* There is a call to __builtin___asan_report_store_n and a call\n+     to __builtin___asan_report_load_n to instrument the store to\n      (subset of) the memory region of tab.  */\n   __builtin_memcpy (&tab[1], foo + i, 3);\n \n   /* This should not generate a __builtin___asan_report_load1 because\n      the reference to tab[1] has been already instrumented above.  */\n   return tab[1];\n \n-  /* So for these function, there should be 7 calls to\n+  /* So for these functions, there should be 3 calls to\n      __builtin___asan_report_store1.  */\n }\n \n@@ -63,6 +62,7 @@ main ()\n   return test0 () && test1 (0);\n }\n \n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_store1\" 7 \"asan0\" } } */\n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load\" 2 \"asan0\" }  } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_store1\" 3 \"asan0\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_store_n\" 2 \"asan0\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load\" 1 \"asan0\" }  } */\n /* { dg-final { cleanup-tree-dump \"asan0\" } } */"}, {"sha": "143312fb2f67b50041efae61014bd9329a79101b", "filename": "gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-2.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8946c29ea82657cb45e26209c839623294009bde/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8946c29ea82657cb45e26209c839623294009bde/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-2.c?ref=8946c29ea82657cb45e26209c839623294009bde", "patch": "@@ -20,6 +20,7 @@ main ()\n   __builtin_memset (tab, 1, 3);\n }\n \n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_store1\" 3 \"asan0\" } } */\n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report\" 3 \"asan0\" }  } */\n+/* { dg-final { scan-tree-dump-times \"& 7\" 3 \"asan0\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_store_n\" 2 \"asan0\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report\" 2 \"asan0\" }  } */\n /* { dg-final { cleanup-tree-dump \"asan0\" } } */"}, {"sha": "da91cd53ff467e78fd340077eca2273c1b1b29d6", "filename": "gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-4.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8946c29ea82657cb45e26209c839623294009bde/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8946c29ea82657cb45e26209c839623294009bde/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-4.c?ref=8946c29ea82657cb45e26209c839623294009bde", "patch": "@@ -5,9 +5,13 @@\n void\n foo  (int *a, char *b, char *c)\n {\n+  /* One check for c[0], one check for a[], one check for c, two checks for b.  */\n   __builtin_memmove (c, b, a[c[0]]);\n+  /* For a total of 5 checks.  */\n }\n \n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load1\" 3 \"asan0\" } } */\n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_store1\" 1 \"asan0\" } } */\n+/* { dg-final { scan-tree-dump-times \"& 7\" 5 \"asan0\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load1\" 1 \"asan0\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load_n\" 1 \"asan0\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_store_n\" 1 \"asan0\" } } */\n /* { dg-final { cleanup-tree-dump \"asan0\" } } */"}, {"sha": "134be664a8c1362549607290b18b1f559ef4b886", "filename": "gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-5.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8946c29ea82657cb45e26209c839623294009bde/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8946c29ea82657cb45e26209c839623294009bde/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-5.c?ref=8946c29ea82657cb45e26209c839623294009bde", "patch": "@@ -5,9 +5,14 @@\n void\n foo  (int *a, char *b, char *c)\n {\n+  /* One check for b[0], one check for a[], 2 checks for c and one checks for b.  */\n   __builtin_memmove (c, b, a[b[0]]);\n+  /* For a total of 5 checks.  */\n }\n \n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load1\" 2 \"asan0\" } } */\n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_store1\" 2 \"asan0\" } } */\n+/* { dg-final { scan-tree-dump-times \"& 7\" 5 \"asan0\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load1\" 1 \"asan0\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load4\" 1 \"asan0\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load_n\" 1 \"asan0\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_store_n\" 1 \"asan0\" } } */\n /* { dg-final { cleanup-tree-dump \"asan0\" } } */"}, {"sha": "55c8ee376b525c3e554ef6f4b3e50e03ed9368c5", "filename": "gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-6.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8946c29ea82657cb45e26209c839623294009bde/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8946c29ea82657cb45e26209c839623294009bde/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-6.c?ref=8946c29ea82657cb45e26209c839623294009bde", "patch": "@@ -5,10 +5,16 @@\n void\n foo  (int *a, char *b, char *c)\n {\n+  /* One check for c[0], one check for a[], one check for c and 2 checks for b.  */\n   __builtin_memmove (c, b, a[c[0]]);\n+  /* One check for a[], one check for c and one check for b.  */\n   __builtin_memmove (c, b, a[b[0]]);\n+  /* For a total of 8 checks.  */\n }\n \n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load1\" 5 \"asan0\" } } */\n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_store1\" 2 \"asan0\" } } */\n+/* { dg-final { scan-tree-dump-times \"& 7\" 8 \"asan0\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load1\" 1 \"asan0\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load4\" 2 \"asan0\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load_n\" 2 \"asan0\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_store_n\" 2 \"asan0\" } } */\n /* { dg-final { cleanup-tree-dump \"asan0\" } } */"}, {"sha": "a04956d7cebf7e3ae68654911dc57d560c82e9c5", "filename": "gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-7.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8946c29ea82657cb45e26209c839623294009bde/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8946c29ea82657cb45e26209c839623294009bde/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-7.c?ref=8946c29ea82657cb45e26209c839623294009bde", "patch": "@@ -13,11 +13,15 @@ struct S\n int\n foo  (int *a, char *b, char *c)\n {\n+  /* 2 checks for s.a, 2 checks for e.  */\n   int d = __builtin_memcmp (s.a, e, 100);\n+  /* One check for s.a and one check for e.  */\n   d += __builtin_memcmp (s.a, e, 200);\n+  /* For a total of 6 checks.  */\n   return d;\n }\n \n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load\" 6 \"asan0\" } } */\n+/* { dg-final { scan-tree-dump-times \"& 7\" 6 \"asan0\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load_n\" 4 \"asan0\" } } */\n /* { dg-final { scan-tree-dump-not \"__builtin___asan_report_store\" \"asan0\" } } */\n /* { dg-final { cleanup-tree-dump \"asan0\" } } */"}, {"sha": "308a133dbf915f0bef5404dfce7d11581bd14677", "filename": "gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-8.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8946c29ea82657cb45e26209c839623294009bde/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8946c29ea82657cb45e26209c839623294009bde/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-8.c?ref=8946c29ea82657cb45e26209c839623294009bde", "patch": "@@ -5,10 +5,16 @@\n char\n foo  (int *a, char *b, char *c)\n {\n+  /* One check for b[0], one check for a[], two checks for c and one check for b.  */\n   __builtin_memmove (c, b, a[b[0]]);\n+  /* No checks here.  */\n   return c[0] + b[0];\n+  /* For a total of 5 checks.  */\n }\n \n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load1\" 3 \"asan0\" } } */\n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_store1\" 2 \"asan0\" } } */\n+/* { dg-final { scan-tree-dump-times \"& 7\" 5 \"asan0\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load1\" 1 \"asan0\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load4\" 1 \"asan0\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load_n\" 1 \"asan0\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_store_n\" 1 \"asan0\" } } */\n /* { dg-final { cleanup-tree-dump \"asan0\" } } */"}]}