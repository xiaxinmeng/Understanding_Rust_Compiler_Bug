{"sha": "3ef328c293a336df0aead2d72c0c5ed9781a9861", "node_id": "C_kwDOANBUbNoAKDNlZjMyOGMyOTNhMzM2ZGYwYWVhZDJkNzJjMGM1ZWQ5NzgxYTk4NjE", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-02-02T21:39:12Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-02-03T22:46:41Z"}, "message": "analyzer: fixes to realloc-handling [PR104369]\n\nThis patch fixes various issues with how -fanalyzer handles \"realloc\"\nseen when debugging PR analyzer/104369.\n\nPreviously it wasn't correctly copying over the contents of the old\nbuffer for the success-with-move case, leading to false\n-Wanalyzer-use-of-uninitialized-value diagnostics.\n\nI also noticed that -fanalyzer failed to properly handle \"realloc\" for\ncases where the ptr's region had unknown dynamic extents, and an ICE\nfor the case where a tainted value is used as a realloc size argument.\n\nThis patch fixes these issues, including the false uninit diagnostics\nseen in PR analyzer/104369.\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/104369\n\t* engine.cc (exploded_graph::process_node): Use the node for any\n\tdiagnostics, avoiding ICE if a bifurcation update adds a\n\tsaved_diagnostic, such as for a tainted realloc size.\n\t* region-model-impl-calls.cc\n\t(region_model::impl_call_realloc::success_no_move::update_model):\n\tRequire the old pointer to be non-NULL to be able successfully\n\tgrow in place.  Use model->deref_rvalue rather than maybe_get_region\n\tto support the old pointer being symbolic.\n\t(region_model::impl_call_realloc::success_with_move::update_model):\n\tLikewise.  Add a constraint that the new pointer != the old pointer.\n\tUse a sized_region when setting the value of the new region.\n\tHandle the case where we don't know the dynamic size of the old\n\tregion by marking the new region as unknown.\n\t* sm-taint.cc (tainted_allocation_size::tainted_allocation_size):\n\tUpdate assertion to also allow for MEMSPACE_UNKNOWN.\n\t(tainted_allocation_size::emit): Likewise.\n\t(region_model::check_dynamic_size_for_taint): Likewise.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/104369\n\t* gcc.dg/analyzer/pr104369-1.c: New test.\n\t* gcc.dg/analyzer/pr104369-2.c: New test.\n\t* gcc.dg/analyzer/realloc-3.c: New test.\n\t* gcc.dg/analyzer/realloc-4.c: New test.\n\t* gcc.dg/analyzer/taint-realloc.c: New test.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "9aec619b5ff3e6277bda1b5d67f7143a5296dcfa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9aec619b5ff3e6277bda1b5d67f7143a5296dcfa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ef328c293a336df0aead2d72c0c5ed9781a9861", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ef328c293a336df0aead2d72c0c5ed9781a9861", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ef328c293a336df0aead2d72c0c5ed9781a9861", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ef328c293a336df0aead2d72c0c5ed9781a9861/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23b2cb628e5da84ad9c5422d5b2b6b2d36318ece", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23b2cb628e5da84ad9c5422d5b2b6b2d36318ece", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23b2cb628e5da84ad9c5422d5b2b6b2d36318ece"}], "stats": {"total": 399, "additions": 392, "deletions": 7}, "files": [{"sha": "bff37798a392d4bfb487b50ee255b31fe57c6afc", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ef328c293a336df0aead2d72c0c5ed9781a9861/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ef328c293a336df0aead2d72c0c5ed9781a9861/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=3ef328c293a336df0aead2d72c0c5ed9781a9861", "patch": "@@ -3799,7 +3799,7 @@ exploded_graph::process_node (exploded_node *node)\n \t    /* Apply edge_info to state.  */\n \t    impl_region_model_context\n \t      bifurcation_ctxt (*this,\n-\t\t\t\tNULL, // enode_for_diag\n+\t\t\t\tnode, // enode_for_diag\n \t\t\t\t&path_ctxt.get_state_at_bifurcation (),\n \t\t\t\t&bifurcated_new_state,\n \t\t\t\tNULL, // uncertainty_t *uncertainty"}, {"sha": "e9592975332ee88a45a256fa4d8e4d2abfdc8319", "filename": "gcc/analyzer/region-model-impl-calls.cc", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ef328c293a336df0aead2d72c0c5ed9781a9861/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ef328c293a336df0aead2d72c0c5ed9781a9861/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc?ref=3ef328c293a336df0aead2d72c0c5ed9781a9861", "patch": "@@ -651,7 +651,18 @@ region_model::impl_call_realloc (const call_details &cd)\n       const call_details cd (get_call_details (model, ctxt));\n       const svalue *ptr_sval = cd.get_arg_svalue (0);\n       const svalue *size_sval = cd.get_arg_svalue (1);\n-      if (const region *buffer_reg = ptr_sval->maybe_get_region ())\n+\n+      /* We can only grow in place with a non-NULL pointer.  */\n+      {\n+\tconst svalue *null_ptr\n+\t  = model->m_mgr->get_or_create_int_cst (ptr_sval->get_type (), 0);\n+\tif (!model->add_constraint (ptr_sval, NE_EXPR, null_ptr,\n+\t\t\t\t    cd.get_ctxt ()))\n+\t  return false;\n+      }\n+\n+      if (const region *buffer_reg = model->deref_rvalue (ptr_sval, NULL_TREE,\n+\t\t\t\t\t\t\t  ctxt))\n \tif (compat_types_p (size_sval->get_type (), size_type_node))\n \t  model->set_dynamic_extents (buffer_reg, size_sval, ctxt);\n       if (cd.get_lhs_region ())\n@@ -696,10 +707,15 @@ region_model::impl_call_realloc (const call_details &cd)\n \t= model->create_region_for_heap_alloc (new_size_sval, ctxt);\n       const svalue *new_ptr_sval\n \t= model->m_mgr->get_ptr_svalue (cd.get_lhs_type (), new_reg);\n+      if (!model->add_constraint (new_ptr_sval, NE_EXPR, old_ptr_sval,\n+\t\t\t\t  cd.get_ctxt ()))\n+\treturn false;\n+\n       if (cd.get_lhs_type ())\n \tcd.maybe_set_lhs (new_ptr_sval);\n \n-      if (const region *freed_reg = old_ptr_sval->maybe_get_region ())\n+      if (const region *freed_reg = model->deref_rvalue (old_ptr_sval,\n+\t\t\t\t\t\t\t NULL_TREE, ctxt))\n \t{\n \t  /* Copy the data.  */\n \t  const svalue *old_size_sval = model->get_dynamic_extents (freed_reg);\n@@ -710,7 +726,18 @@ region_model::impl_call_realloc (const call_details &cd)\n \t\t\t\t\t\t  old_size_sval);\n \t      const svalue *buffer_content_sval\n \t\t= model->get_store_value (sized_old_reg, cd.get_ctxt ());\n-\t      model->set_value (new_reg, buffer_content_sval, cd.get_ctxt ());\n+\t      const region *sized_new_reg\n+\t\t= model->m_mgr->get_sized_region (new_reg, NULL,\n+\t\t\t\t\t\t  old_size_sval);\n+\t      model->set_value (sized_new_reg, buffer_content_sval,\n+\t\t\t\tcd.get_ctxt ());\n+\t    }\n+\t  else\n+\t    {\n+\t      /* We don't know how big the old region was;\n+\t\t mark the new region as having been touched to avoid uninit\n+\t\t issues.  */\n+\t      model->mark_region_as_unknown (new_reg, cd.get_uncertainty ());\n \t    }\n \n \t  /* Free the old region, so that pointers to the old buffer become"}, {"sha": "573a9124286eb1022afb6c571107489935c9b0d2", "filename": "gcc/analyzer/sm-taint.cc", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ef328c293a336df0aead2d72c0c5ed9781a9861/gcc%2Fanalyzer%2Fsm-taint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ef328c293a336df0aead2d72c0c5ed9781a9861/gcc%2Fanalyzer%2Fsm-taint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-taint.cc?ref=3ef328c293a336df0aead2d72c0c5ed9781a9861", "patch": "@@ -496,7 +496,9 @@ class tainted_allocation_size : public taint_diagnostic\n   : taint_diagnostic (sm, arg, has_bounds),\n     m_mem_space (mem_space)\n   {\n-    gcc_assert (mem_space == MEMSPACE_STACK || mem_space == MEMSPACE_HEAP);\n+    gcc_assert (mem_space == MEMSPACE_STACK\n+\t\t|| mem_space == MEMSPACE_HEAP\n+\t\t|| mem_space == MEMSPACE_UNKNOWN);\n   }\n \n   const char *get_kind () const FINAL OVERRIDE\n@@ -509,7 +511,9 @@ class tainted_allocation_size : public taint_diagnostic\n     diagnostic_metadata m;\n     /* \"CWE-789: Memory Allocation with Excessive Size Value\".  */\n     m.add_cwe (789);\n-    gcc_assert (m_mem_space == MEMSPACE_STACK || m_mem_space == MEMSPACE_HEAP);\n+    gcc_assert (m_mem_space == MEMSPACE_STACK\n+\t\t|| m_mem_space == MEMSPACE_HEAP\n+\t\t|| m_mem_space == MEMSPACE_UNKNOWN);\n     // TODO: make use of m_mem_space\n     if (m_arg)\n       switch (m_has_bounds)\n@@ -1051,7 +1055,9 @@ region_model::check_dynamic_size_for_taint (enum memory_space mem_space,\n \t\t\t\t\t    const svalue *size_in_bytes,\n \t\t\t\t\t    region_model_context *ctxt) const\n {\n-  gcc_assert (mem_space == MEMSPACE_STACK || mem_space == MEMSPACE_HEAP);\n+  gcc_assert (mem_space == MEMSPACE_STACK\n+\t      || mem_space == MEMSPACE_HEAP\n+\t      || mem_space == MEMSPACE_UNKNOWN);\n   gcc_assert (size_in_bytes);\n   gcc_assert (ctxt);\n "}, {"sha": "d3b32418a9e1252c6abee4535647ee7a05012717", "filename": "gcc/testsuite/gcc.dg/analyzer/pr104369-1.c", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ef328c293a336df0aead2d72c0c5ed9781a9861/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr104369-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ef328c293a336df0aead2d72c0c5ed9781a9861/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr104369-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr104369-1.c?ref=3ef328c293a336df0aead2d72c0c5ed9781a9861", "patch": "@@ -0,0 +1,86 @@\n+/* { dg-additional-options \"--param analyzer-max-enodes-per-program-point=10\" } */\n+// TODO: remove need for this option\n+\n+typedef __SIZE_TYPE__ size_t;\n+#define NULL ((void *)0)\n+#define POLLIN 0x001\n+\n+typedef struct {\n+  unsigned long int __val[(1024 / (8 * sizeof(unsigned long int)))];\n+} __sigset_t;\n+\n+typedef unsigned int socklen_t;\n+\n+struct timespec {\n+  /* [...snip...] */\n+};\n+\n+typedef unsigned long int nfds_t;\n+\n+struct pollfd {\n+  int fd;\n+  short int events;\n+  short int revents;\n+};\n+\n+extern int ppoll(struct pollfd *__fds, nfds_t __nfds,\n+                 const struct timespec *__timeout, const __sigset_t *__ss);\n+\n+struct sockaddr_un {\n+  /* [...snip...] */\n+  char sun_path[108];\n+};\n+\n+typedef union {\n+  /* [...snip...] */\n+  struct sockaddr_un *__restrict __sockaddr_un__;\n+  /* [...snip...] */\n+} __SOCKADDR_ARG __attribute__((transparent_union));\n+\n+extern int accept(int __fd, __SOCKADDR_ARG __addr,\n+                  socklen_t *__restrict __addr_len);\n+\n+extern void *calloc(size_t __nmemb, size_t __size)\n+  __attribute__((__nothrow__, __leaf__))\n+  __attribute__((__malloc__))\n+  __attribute__((__alloc_size__(1, 2)));\n+\n+extern void *realloc(void *__ptr, size_t __size)\n+  __attribute__((__nothrow__, __leaf__))\n+  __attribute__((__warn_unused_result__))\n+  __attribute__((__alloc_size__(2)));\n+\n+extern void exit(int __status)\n+  __attribute__((__nothrow__, __leaf__))\n+  __attribute__((__noreturn__));\n+\n+int main() {\n+  int rc;\n+  int nsockets = 1;\n+  struct pollfd *pollfds, *newpollfds;\n+  struct sockaddr_un remote;\n+  socklen_t len = sizeof(remote);\n+\n+  pollfds = calloc(1, sizeof(struct pollfd));\n+  if (!pollfds) {\n+    exit(1);\n+  }\n+\n+  while (1) {\n+    rc = ppoll(pollfds, nsockets, NULL, NULL);\n+    if (rc < 0) {\n+      continue;\n+    }\n+\n+    if (pollfds[0].revents & POLLIN) {\n+      nsockets++;\n+      newpollfds = realloc(pollfds, nsockets * sizeof(*pollfds));\n+      if (!newpollfds) {\n+        exit(1);\n+      }\n+      pollfds = newpollfds;\n+      pollfds[nsockets - 1].fd = accept(pollfds[0].fd, &remote, &len);\n+    }\n+  }\n+  return 0;\n+}"}, {"sha": "57dc9caf3e9fc6f94ba7024880e70bd68452c2a6", "filename": "gcc/testsuite/gcc.dg/analyzer/pr104369-2.c", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ef328c293a336df0aead2d72c0c5ed9781a9861/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr104369-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ef328c293a336df0aead2d72c0c5ed9781a9861/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr104369-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr104369-2.c?ref=3ef328c293a336df0aead2d72c0c5ed9781a9861", "patch": "@@ -0,0 +1,79 @@\n+typedef __SIZE_TYPE__ size_t;\n+#define NULL ((void *)0)\n+#define POLLIN 0x001\n+\n+typedef struct {\n+  unsigned long int __val[(1024 / (8 * sizeof(unsigned long int)))];\n+} __sigset_t;\n+\n+typedef unsigned int socklen_t;\n+\n+struct timespec {\n+  /* [...snip...] */\n+};\n+\n+typedef unsigned long int nfds_t;\n+\n+struct pollfd {\n+  int fd;\n+  short int events;\n+  short int revents;\n+};\n+\n+extern int ppoll(struct pollfd *__fds, nfds_t __nfds,\n+                 const struct timespec *__timeout, const __sigset_t *__ss);\n+\n+struct sockaddr_un {\n+  /* [...snip...] */\n+  char sun_path[108];\n+};\n+\n+typedef union {\n+  /* [...snip...] */\n+  struct sockaddr_un *__restrict __sockaddr_un__;\n+  /* [...snip...] */\n+} __SOCKADDR_ARG __attribute__((transparent_union));\n+\n+extern int accept(int __fd, __SOCKADDR_ARG __addr,\n+                  socklen_t *__restrict __addr_len);\n+\n+extern void *calloc(size_t __nmemb, size_t __size)\n+  __attribute__((__nothrow__, __leaf__))\n+  __attribute__((__malloc__))\n+  __attribute__((__alloc_size__(1, 2)));\n+\n+extern void *realloc(void *__ptr, size_t __size)\n+  __attribute__((__nothrow__, __leaf__))\n+  __attribute__((__warn_unused_result__))\n+  __attribute__((__alloc_size__(2)));\n+\n+extern void exit(int __status)\n+  __attribute__((__nothrow__, __leaf__))\n+  __attribute__((__noreturn__));\n+\n+int main() {\n+  int rc;\n+  int nsockets = 1;\n+  struct pollfd *pollfds, *newpollfds;\n+  struct sockaddr_un remote;\n+  socklen_t len = sizeof(remote);\n+\n+  pollfds = calloc(1, sizeof(struct pollfd));\n+  if (!pollfds) {\n+    exit(1);\n+  }\n+\n+  rc = ppoll(pollfds, nsockets, NULL, NULL);\n+  if (rc < 0) {\n+    exit(2);\n+  }\n+\n+  nsockets++;\n+  newpollfds = realloc(pollfds, nsockets * sizeof(*pollfds));\n+  if (!newpollfds) {\n+    exit(3);\n+  }\n+  pollfds = newpollfds;\n+  pollfds[nsockets - 1].fd = accept(pollfds[0].fd, &remote, &len);\n+  exit(4);\n+}"}, {"sha": "89676e1ca0d4f458e020cdc7e2e042d293c4f288", "filename": "gcc/testsuite/gcc.dg/analyzer/realloc-3.c", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ef328c293a336df0aead2d72c0c5ed9781a9861/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Frealloc-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ef328c293a336df0aead2d72c0c5ed9781a9861/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Frealloc-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Frealloc-3.c?ref=3ef328c293a336df0aead2d72c0c5ed9781a9861", "patch": "@@ -0,0 +1,81 @@\n+#include \"analyzer-decls.h\"\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+#define NULL ((void *)0)\n+\n+extern void *calloc (size_t __nmemb, size_t __size)\n+  __attribute__ ((__nothrow__ , __leaf__))\n+  __attribute__ ((__malloc__))\n+  __attribute__ ((__alloc_size__ (1, 2))) ;\n+extern void *malloc (size_t __size)\n+  __attribute__ ((__nothrow__ , __leaf__))\n+  __attribute__ ((__malloc__))\n+  __attribute__ ((__alloc_size__ (1)));\n+extern void *realloc (void *__ptr, size_t __size)\n+  __attribute__ ((__nothrow__ , __leaf__))\n+  __attribute__ ((__warn_unused_result__))\n+  __attribute__ ((__alloc_size__ (2)));\n+extern void free (void *__ptr)\n+  __attribute__ ((__nothrow__ , __leaf__));\n+\n+/* realloc of calloc buffer.  */\n+\n+char *test_8 (size_t sz)\n+{\n+  char *p, *q;\n+\n+  p = calloc (1, 3);\n+  if (!p)\n+    return NULL;\n+\n+  __analyzer_dump_capacity (p); /* { dg-warning \"capacity: '\\\\(\\[^\\n\\r\\]*\\\\)3'\" } */\n+\n+  __analyzer_eval (p[0] == 0); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (p[1] == 0); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (p[2] == 0); /* { dg-warning \"TRUE\" } */\n+\n+  q = realloc (p, 6);\n+\n+  /* We should have 3 nodes, corresponding to \"failure\",\n+     \"success without moving\", and \"success with moving\".  */\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"3 processed enodes\" } */\n+  \n+  if (q)\n+    {\n+      __analyzer_dump_capacity (q); /* { dg-warning \"capacity: '\\\\(\\[^\\n\\r\\]*\\\\)6'\" } */\n+      q[3] = 'd';\n+      q[4] = 'e';\n+      q[5] = 'f';\n+      if (q == p)\n+\t{\n+\t  /* \"realloc\" success, growing the buffer in-place.  */\n+\t  __analyzer_eval (p[0] == 0); /* { dg-warning \"TRUE\" } */\n+\t  __analyzer_eval (p[1] == 0); /* { dg-warning \"TRUE\" } */\n+\t  __analyzer_eval (p[2] == 0); /* { dg-warning \"TRUE\" } */\n+\t}\n+      else\n+\t{\n+\t  /* \"realloc\" success, moving the buffer (and thus freeing \"p\").  */\n+\t  __analyzer_eval (q[0] == 0); /* { dg-warning \"TRUE\" } */\n+\t  __analyzer_eval (q[1] == 0); /* { dg-warning \"TRUE\" } */\n+\t  __analyzer_eval (q[2] == 0); /* { dg-warning \"TRUE\" } */\n+\t  __analyzer_eval (p[0] == 'a'); /* { dg-warning \"UNKNOWN\" \"unknown\" } */\n+\t  /* { dg-warning \"use after 'free' of 'p'\" \"use after free\" { target *-*-* } .-1 } */\n+\t}\n+      __analyzer_eval (q[3] == 'd'); /* { dg-warning \"TRUE\" } */\n+      __analyzer_eval (q[4] == 'e'); /* { dg-warning \"TRUE\" } */\n+      __analyzer_eval (q[5] == 'f'); /* { dg-warning \"TRUE\" } */\n+    }\n+  else\n+    {\n+      /* \"realloc\" failure.  p should be unchanged.  */\n+      __analyzer_dump_capacity (p); /* { dg-warning \"capacity: '\\\\(\\[^\\n\\r\\]*\\\\)3'\" } */\n+      __analyzer_eval (p[0] == 0); /* { dg-warning \"TRUE\" } */\n+      __analyzer_eval (p[1] == 0); /* { dg-warning \"TRUE\" } */\n+      __analyzer_eval (p[2] == 0); /* { dg-warning \"TRUE\" } */\n+      return p;\n+    }\n+\n+  return q;\n+}"}, {"sha": "ac338ec0497376a7e2604b7f63d9db42a7d9588f", "filename": "gcc/testsuite/gcc.dg/analyzer/realloc-4.c", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ef328c293a336df0aead2d72c0c5ed9781a9861/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Frealloc-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ef328c293a336df0aead2d72c0c5ed9781a9861/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Frealloc-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Frealloc-4.c?ref=3ef328c293a336df0aead2d72c0c5ed9781a9861", "patch": "@@ -0,0 +1,85 @@\n+#include \"analyzer-decls.h\"\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+#define NULL ((void *)0)\n+\n+extern void *calloc (size_t __nmemb, size_t __size)\n+  __attribute__ ((__nothrow__ , __leaf__))\n+  __attribute__ ((__malloc__))\n+  __attribute__ ((__alloc_size__ (1, 2))) ;\n+extern void *malloc (size_t __size)\n+  __attribute__ ((__nothrow__ , __leaf__))\n+  __attribute__ ((__malloc__))\n+  __attribute__ ((__alloc_size__ (1)));\n+extern void *realloc (void *__ptr, size_t __size)\n+  __attribute__ ((__nothrow__ , __leaf__))\n+  __attribute__ ((__warn_unused_result__))\n+  __attribute__ ((__alloc_size__ (2)));\n+extern void free (void *__ptr)\n+  __attribute__ ((__nothrow__ , __leaf__));\n+\n+/* realloc where we don't know the original size of the region.  */\n+\n+char *test_8 (char *p, size_t sz)\n+{\n+  char *q;\n+\n+  __analyzer_dump_capacity (p); /* { dg-warning \"capacity: 'UNKNOWN\\\\(\\[^\\n\\r\\]*\\\\)'\" } */\n+\n+  p[0] = 'a';\n+  p[1] = 'b';\n+  p[2] = 'c';\n+  __analyzer_eval (p[0] == 'a'); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (p[1] == 'b'); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (p[2] == 'c'); /* { dg-warning \"TRUE\" } */\n+\n+  q = realloc (p, 6);\n+\n+  /* We should have 3 nodes, corresponding to \"failure\",\n+     \"success without moving\", and \"success with moving\".  */\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"3 processed enodes\" } */\n+  \n+  if (q)\n+    {\n+      q[3] = 'd';\n+      q[4] = 'e';\n+      q[5] = 'f';\n+      if (q == p)\n+\t{\n+\t  /* \"realloc\" success, growing the buffer in-place.  */\n+\t  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n+\t  __analyzer_dump_capacity (q); /* { dg-warning \"capacity: '\\\\(\\[^\\n\\r\\]*\\\\)6'\" } */\n+\t  __analyzer_eval (q[0] == 'a'); /* { dg-warning \"TRUE\" } */\n+\t  __analyzer_eval (q[1] == 'b'); /* { dg-warning \"TRUE\" } */\n+\t  __analyzer_eval (q[2] == 'c'); /* { dg-warning \"TRUE\" } */\n+\t}\n+      else\n+\t{\n+\t  /* \"realloc\" success, moving the buffer (and thus freeing \"p\").  */\n+\t  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n+\t  __analyzer_dump_capacity (q); /* { dg-warning \"capacity: '\\\\(\\[^\\n\\r\\]*\\\\)6'\" } */\n+\t  /* We don't know how much of the buffer is copied.  */\n+\t  __analyzer_eval (q[0] == 'a'); /* { dg-warning \"UNKNOWN\" } */\n+\t  __analyzer_eval (q[1] == 'b'); /* { dg-warning \"UNKNOWN\" } */\n+\t  __analyzer_eval (q[2] == 'c'); /* { dg-warning \"UNKNOWN\" } */\n+\t  __analyzer_eval (p[0] == 'a'); /* { dg-warning \"UNKNOWN\" \"unknown\" } */\n+\t  /* { dg-warning \"use after 'free' of 'p'\" \"use after free\" { target *-*-* } .-1 } */\n+\t}\n+      __analyzer_eval (q[3] == 'd'); /* { dg-warning \"TRUE\" } */\n+      __analyzer_eval (q[4] == 'e'); /* { dg-warning \"TRUE\" } */\n+      __analyzer_eval (q[5] == 'f'); /* { dg-warning \"TRUE\" } */\n+    }\n+  else\n+    {\n+      /* \"realloc\" failure.  p should be unchanged.  */\n+      __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n+      __analyzer_dump_capacity (q); /* { dg-warning \"capacity: 'UNKNOWN\\\\(\\[^\\n\\r\\]*\\\\)'\" } */\n+      __analyzer_eval (p[0] == 'a'); /* { dg-warning \"TRUE\" } */\n+      __analyzer_eval (p[1] == 'b'); /* { dg-warning \"TRUE\" } */\n+      __analyzer_eval (p[2] == 'c'); /* { dg-warning \"TRUE\" } */\n+      return p;\n+    }\n+\n+  return q;\n+}"}, {"sha": "bd0ed0010fbb6dcd2cfe3a46a92b4591f0d3f147", "filename": "gcc/testsuite/gcc.dg/analyzer/taint-realloc.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ef328c293a336df0aead2d72c0c5ed9781a9861/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-realloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ef328c293a336df0aead2d72c0c5ed9781a9861/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-realloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-realloc.c?ref=3ef328c293a336df0aead2d72c0c5ed9781a9861", "patch": "@@ -0,0 +1,21 @@\n+// TODO: remove need for this option:\n+/* { dg-additional-options \"-fanalyzer-checker=taint\" } */\n+\n+#include \"analyzer-decls.h\"\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+/* realloc with tainted size.  */\n+\n+void *p;\n+\n+void __attribute__((tainted_args))\n+test_1 (size_t sz) /* { dg-message \"\\\\(1\\\\) function 'test_1' marked with '__attribute__\\\\(\\\\(tainted_args\\\\)\\\\)'\" } */\n+{\n+  void *q;\n+  \n+  __analyzer_dump_state (\"taint\", sz); /* { dg-warning \"state: 'tainted'\" } */\n+\n+  q = realloc (p, sz);  /* { dg-warning \"use of attacker-controlled value 'sz' as allocation size without upper-bounds checking\" } */\n+}"}]}