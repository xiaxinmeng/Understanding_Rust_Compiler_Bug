{"sha": "db9be04ed89e3aa82d113775d7a12699904d9735", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGI5YmUwNGVkODllM2FhODJkMTEzNzc1ZDdhMTI2OTk5MDRkOTczNQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-12-09T08:32:49Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-12-09T08:32:49Z"}, "message": "re PR tree-optimization/68583 (Missed if-conversion)\n\n2015-12-09  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/68583\n\t* tree-if-conv.c (ifc_dr): Make flags bool, add w_unconditionally\n\tflag and rename predicates to w_predicate, rw_predicate and\n\tbase_w_predicate.\n\t(DR_WRITTEN_AT_LEAST_ONCE): Rename to ...\n\t(DR_BASE_W_UNCONDITIONALLY): ... this.\n\t(DR_W_UNCONDITIONALLY): Add.\n\t(hash_memrefs_baserefs_and_store_DRs_read): Adjust.  Compute\n\tunconditionally written separately from read or written.\n\t(ifcvt_memrefs_wont_trap): Properly treat reads.\n\t(ifcvt_could_trap_p): Inline ...\n\t(if_convertible_gimple_assign_stmt_p): ... here.  Refactor\n\tto avoid code duplication.\n\t(if_convertible_loop_p_1): Adjust and properly initialize\n\tpredicates.\n\nFrom-SVN: r231444", "tree": {"sha": "e5404c7d5206af518d41f5c3d3d2c1e369241ab7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e5404c7d5206af518d41f5c3d3d2c1e369241ab7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/db9be04ed89e3aa82d113775d7a12699904d9735", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db9be04ed89e3aa82d113775d7a12699904d9735", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db9be04ed89e3aa82d113775d7a12699904d9735", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db9be04ed89e3aa82d113775d7a12699904d9735/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "34cd48e5d56b95f149e1c7e294f522bd3c93c94f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34cd48e5d56b95f149e1c7e294f522bd3c93c94f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34cd48e5d56b95f149e1c7e294f522bd3c93c94f"}], "stats": {"total": 144, "additions": 73, "deletions": 71}, "files": [{"sha": "a3813b7cd01b71c2067eedc6706471f3ded98695", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db9be04ed89e3aa82d113775d7a12699904d9735/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db9be04ed89e3aa82d113775d7a12699904d9735/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=db9be04ed89e3aa82d113775d7a12699904d9735", "patch": "@@ -1,3 +1,21 @@\n+2015-12-09  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/68583\n+\t* tree-if-conv.c (ifc_dr): Make flags bool, add w_unconditionally\n+\tflag and rename predicates to w_predicate, rw_predicate and\n+\tbase_w_predicate.\n+\t(DR_WRITTEN_AT_LEAST_ONCE): Rename to ...\n+\t(DR_BASE_W_UNCONDITIONALLY): ... this.\n+\t(DR_W_UNCONDITIONALLY): Add.\n+\t(hash_memrefs_baserefs_and_store_DRs_read): Adjust.  Compute\n+\tunconditionally written separately from read or written.\n+\t(ifcvt_memrefs_wont_trap): Properly treat reads.\n+\t(ifcvt_could_trap_p): Inline ...\n+\t(if_convertible_gimple_assign_stmt_p): ... here.  Refactor\n+\tto avoid code duplication.\n+\t(if_convertible_loop_p_1): Adjust and properly initialize\n+\tpredicates.\n+\n 2015-12-09  Richard Biener  <rguenther@suse.de>\n \n \t* tree-vect-stmts.c (vectorizable_load): Set new vinfo only"}, {"sha": "573937bf714f89f5d21c04489110326331ecb558", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 55, "deletions": 71, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db9be04ed89e3aa82d113775d7a12699904d9735/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db9be04ed89e3aa82d113775d7a12699904d9735/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=db9be04ed89e3aa82d113775d7a12699904d9735", "patch": "@@ -582,20 +582,19 @@ if_convertible_phi_p (struct loop *loop, basic_block bb, gphi *phi,\n    each DR->aux field.  */\n \n struct ifc_dr {\n-  /* -1 when not initialized, 0 when false, 1 when true.  */\n-  int written_at_least_once;\n+  bool rw_unconditionally;\n+  bool w_unconditionally;\n+  bool written_at_least_once;\n \n-  /* -1 when not initialized, 0 when false, 1 when true.  */\n-  int rw_unconditionally;\n-\n-  tree predicate;\n-\n-  tree base_predicate;\n+  tree rw_predicate;\n+  tree w_predicate;\n+  tree base_w_predicate;\n };\n \n #define IFC_DR(DR) ((struct ifc_dr *) (DR)->aux)\n-#define DR_WRITTEN_AT_LEAST_ONCE(DR) (IFC_DR (DR)->written_at_least_once)\n+#define DR_BASE_W_UNCONDITIONALLY(DR) (IFC_DR (DR)->written_at_least_once)\n #define DR_RW_UNCONDITIONALLY(DR) (IFC_DR (DR)->rw_unconditionally)\n+#define DR_W_UNCONDITIONALLY(DR) (IFC_DR (DR)->w_unconditionally)\n \n /* Iterates over DR's and stores refs, DR and base refs, DR pairs in\n    HASH tables.  While storing them in HASH table, it checks if the\n@@ -623,38 +622,33 @@ hash_memrefs_baserefs_and_store_DRs_read_written_info (data_reference_p a)\n     ref = TREE_OPERAND (ref, 0);\n \n   master_dr = &ref_DR_map->get_or_insert (ref, &exist1);\n-\n   if (!exist1)\n+    *master_dr = a;\n+\n+  if (DR_IS_WRITE (a))\n     {\n-      IFC_DR (a)->predicate = ca;\n-      *master_dr = a;\n+      IFC_DR (*master_dr)->w_predicate\n+\t= fold_or_predicates (UNKNOWN_LOCATION, ca,\n+\t\t\t      IFC_DR (*master_dr)->w_predicate);\n+      if (is_true_predicate (IFC_DR (*master_dr)->w_predicate))\n+\tDR_W_UNCONDITIONALLY (*master_dr) = true;\n     }\n-  else\n-    IFC_DR (*master_dr)->predicate\n-\t= fold_or_predicates\n-\t\t(EXPR_LOCATION (IFC_DR (*master_dr)->predicate),\n-\t\t ca, IFC_DR (*master_dr)->predicate);\n-\n-  if (is_true_predicate (IFC_DR (*master_dr)->predicate))\n-    DR_RW_UNCONDITIONALLY (*master_dr) = 1;\n+  IFC_DR (*master_dr)->rw_predicate\n+    = fold_or_predicates (UNKNOWN_LOCATION, ca,\n+\t\t\t  IFC_DR (*master_dr)->rw_predicate);\n+  if (is_true_predicate (IFC_DR (*master_dr)->rw_predicate))\n+    DR_RW_UNCONDITIONALLY (*master_dr) = true;\n \n   if (DR_IS_WRITE (a))\n     {\n       base_master_dr = &baseref_DR_map->get_or_insert (base_ref, &exist2);\n-\n       if (!exist2)\n-\t{\n-\t  IFC_DR (a)->base_predicate = ca;\n-\t  *base_master_dr = a;\n-\t}\n-      else\n-\tIFC_DR (*base_master_dr)->base_predicate\n-\t  = fold_or_predicates\n-\t      (EXPR_LOCATION (IFC_DR (*base_master_dr)->base_predicate),\n-\t       ca, IFC_DR (*base_master_dr)->base_predicate);\n-\n-      if (is_true_predicate (IFC_DR (*base_master_dr)->base_predicate))\n-\tDR_WRITTEN_AT_LEAST_ONCE (*base_master_dr) = 1;\n+\t*base_master_dr = a;\n+      IFC_DR (*base_master_dr)->base_w_predicate\n+\t= fold_or_predicates (UNKNOWN_LOCATION, ca,\n+\t\t\t      IFC_DR (*base_master_dr)->base_w_predicate);\n+      if (is_true_predicate (IFC_DR (*base_master_dr)->base_w_predicate))\n+\tDR_BASE_W_UNCONDITIONALLY (*base_master_dr) = true;\n     }\n }\n \n@@ -704,39 +698,36 @@ ifcvt_memrefs_wont_trap (gimple *stmt, vec<data_reference_p> drs)\n \n   gcc_assert (master_dr != NULL);\n \n-  if (DR_RW_UNCONDITIONALLY (*master_dr) == 1)\n+  /* If a is unconditionally written to it doesn't trap.  */\n+  if (DR_W_UNCONDITIONALLY (*master_dr))\n+    return true;\n+\n+  /* If a is unconditionally accessed then ... */\n+  if (DR_RW_UNCONDITIONALLY (*master_dr))\n     {\n+      /* an unconditional read won't trap.  */\n+      if (DR_IS_READ (a))\n+\treturn true;\n+\n+      /* an unconditionaly write won't trap if the base is written\n+         to unconditionally.  */\n       if (base_master_dr\n-\t  && DR_WRITTEN_AT_LEAST_ONCE (*base_master_dr) == 1)\n+\t  && DR_BASE_W_UNCONDITIONALLY (*base_master_dr))\n \treturn true;\n       else\n \t{\n+\t  /* or the base is know to be not readonly.  */\n \t  tree base_tree = get_base_address (DR_REF (a));\n \t  if (DECL_P (base_tree)\n \t      && decl_binds_to_current_def_p (base_tree)\n \t      && flag_tree_loop_if_convert_stores\n \t      && !TREE_READONLY (base_tree))\n-\t  return true;\n+\t    return true;\n \t}\n     }\n   return false;\n }\n \n-/* Wrapper around gimple_could_trap_p refined for the needs of the\n-   if-conversion.  Try to prove that the memory accesses of STMT could\n-   not trap in the innermost loop containing STMT.  */\n-\n-static bool\n-ifcvt_could_trap_p (gimple *stmt, vec<data_reference_p> refs)\n-{\n-  if (gimple_vuse (stmt)\n-      && !gimple_could_trap_p_1 (stmt, false, false)\n-      && ifcvt_memrefs_wont_trap (stmt, refs))\n-    return false;\n-\n-  return gimple_could_trap_p (stmt);\n-}\n-\n /* Return true if STMT could be converted into a masked load or store\n    (conditional load or store based on a mask computed from bb predicate).  */\n \n@@ -828,24 +819,10 @@ if_convertible_gimple_assign_stmt_p (gimple *stmt,\n      we can perform loop versioning.  */\n   gimple_set_plf (stmt, GF_PLF_2, false);\n \n-  if (flag_tree_loop_if_convert_stores)\n-    {\n-      if (ifcvt_could_trap_p (stmt, refs))\n-\t{\n-\t  if (ifcvt_can_use_mask_load_store (stmt))\n-\t    {\n-\t      gimple_set_plf (stmt, GF_PLF_2, true);\n-\t      *any_mask_load_store = true;\n-\t      return true;\n-\t    }\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"tree could trap...\\n\");\n-\t  return false;\n-\t}\n-      return true;\n-    }\n-\n-  if (ifcvt_could_trap_p (stmt, refs))\n+  if ((! gimple_vuse (stmt)\n+       || gimple_could_trap_p_1 (stmt, false, false)\n+       || ! ifcvt_memrefs_wont_trap (stmt, refs))\n+      && gimple_could_trap_p (stmt))\n     {\n       if (ifcvt_can_use_mask_load_store (stmt))\n \t{\n@@ -858,6 +835,9 @@ if_convertible_gimple_assign_stmt_p (gimple *stmt,\n       return false;\n     }\n \n+  if (flag_tree_loop_if_convert_stores)\n+    return true;\n+\n   bb = gimple_bb (stmt);\n \n   if (TREE_CODE (lhs) != SSA_NAME\n@@ -1279,8 +1259,12 @@ if_convertible_loop_p_1 (struct loop *loop,\n   for (i = 0; refs->iterate (i, &dr); i++)\n     {\n       dr->aux = XNEW (struct ifc_dr);\n-      DR_WRITTEN_AT_LEAST_ONCE (dr) = -1;\n-      DR_RW_UNCONDITIONALLY (dr) = -1;\n+      DR_BASE_W_UNCONDITIONALLY (dr) = false;\n+      DR_RW_UNCONDITIONALLY (dr) = false;\n+      DR_W_UNCONDITIONALLY (dr) = false;\n+      IFC_DR (dr)->rw_predicate = boolean_false_node;\n+      IFC_DR (dr)->w_predicate = boolean_false_node;\n+      IFC_DR (dr)->base_w_predicate = boolean_false_node;\n       if (gimple_uid (DR_STMT (dr)) == 0)\n \tgimple_set_uid (DR_STMT (dr), i + 1);\n       hash_memrefs_baserefs_and_store_DRs_read_written_info (dr);"}]}