{"sha": "91b004e5ec3518a97640b7dda5340dc52473d2f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTFiMDA0ZTVlYzM1MThhOTc2NDBiN2RkYTUzNDBkYzUyNDczZDJmNw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2004-03-01T06:23:38Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2004-03-01T06:23:38Z"}, "message": "re PR c++/14138 (100x -O0 C++ Compile Time Regression {3.2,3.3} -> {3.4,4.0})\n\n\tPR c++/14138\n\t* name-lookup.h (push_scope): Change prototype.\n\t* name-lookup.c (push_scope): Do not reenter the current class\n\tscope.\n\t* decl.c (grokfndecl): Check return code from push_scope before\n\tcalling pop_scope.\n\t* decl2.c (check_classfn): Likewise.\n\t* parser.c (cp_parser_conversion_function_id): Likewise.\n\t(cp_parser_init_declarator): Likewise.\n\t(cp_parser_direct_declarator): Likewise.\n\t(cp_parser_class_specifier): Likewise.\n\t(cp_parser_class_head): Likewise.\n\t(cp_parser_lookup_name): Likewise.\n\t(cp_parser_constructor_declarator_p): Likewise.\n\t* pt.c (instantiate_class_template): Likewise.\n\t(resolve_typename_type): Likewise.\n\nFrom-SVN: r78696", "tree": {"sha": "e77274084c964b945be48b1aca9470d858e2f686", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e77274084c964b945be48b1aca9470d858e2f686"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91b004e5ec3518a97640b7dda5340dc52473d2f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91b004e5ec3518a97640b7dda5340dc52473d2f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91b004e5ec3518a97640b7dda5340dc52473d2f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91b004e5ec3518a97640b7dda5340dc52473d2f7/comments", "author": null, "committer": null, "parents": [{"sha": "1152b861f705c8a27743f1622b310eb317ba13ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1152b861f705c8a27743f1622b310eb317ba13ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1152b861f705c8a27743f1622b310eb317ba13ef"}], "stats": {"total": 114, "additions": 83, "deletions": 31}, "files": [{"sha": "da4618abdc5b567155603e8fd4e676d483bc184c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91b004e5ec3518a97640b7dda5340dc52473d2f7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91b004e5ec3518a97640b7dda5340dc52473d2f7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=91b004e5ec3518a97640b7dda5340dc52473d2f7", "patch": "@@ -1,3 +1,22 @@\n+2004-02-29  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/14138\n+\t* name-lookup.h (push_scope): Change prototype.\n+\t* name-lookup.c (push_scope): Do not reenter the current class\n+\tscope.\n+\t* decl.c (grokfndecl): Check return code from push_scope before\n+\tcalling pop_scope.\n+\t* decl2.c (check_classfn): Likewise.\n+\t* parser.c (cp_parser_conversion_function_id): Likewise.\n+\t(cp_parser_init_declarator): Likewise.\n+\t(cp_parser_direct_declarator): Likewise.\n+\t(cp_parser_class_specifier): Likewise.\n+\t(cp_parser_class_head): Likewise.\n+\t(cp_parser_lookup_name): Likewise.\n+\t(cp_parser_constructor_declarator_p): Likewise.\n+\t* pt.c (instantiate_class_template): Likewise.\n+\t(resolve_typename_type): Likewise.\n+\n 2004-02-29  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/14267"}, {"sha": "64aad7207a039938a8017e6f4dbac0516f6b8f50", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91b004e5ec3518a97640b7dda5340dc52473d2f7/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91b004e5ec3518a97640b7dda5340dc52473d2f7/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=91b004e5ec3518a97640b7dda5340dc52473d2f7", "patch": "@@ -5733,6 +5733,7 @@ grokfndecl (tree ctype,\n       if (old_decl)\n \t{\n \t  tree ok;\n+\t  bool pop_p;\n \n \t  /* Since we've smashed OLD_DECL to its\n \t     DECL_TEMPLATE_RESULT, we must do the same to DECL.  */\n@@ -5741,9 +5742,10 @@ grokfndecl (tree ctype,\n \n \t  /* Attempt to merge the declarations.  This can fail, in\n \t     the case of some invalid specialization declarations.  */\n-\t  push_scope (ctype);\n+\t  pop_p = push_scope (ctype);\n \t  ok = duplicate_decls (decl, old_decl);\n-\t  pop_scope (ctype);\n+\t  if (pop_p)\n+\t    pop_scope (ctype);\n \t  if (!ok)\n \t    {\n \t      error (\"no `%#D' member function declared in class `%T'\","}, {"sha": "9d8043a2f46d4548508fa9adba5bc498bb4fe258", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91b004e5ec3518a97640b7dda5340dc52473d2f7/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91b004e5ec3518a97640b7dda5340dc52473d2f7/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=91b004e5ec3518a97640b7dda5340dc52473d2f7", "patch": "@@ -652,9 +652,10 @@ check_classfn (tree ctype, tree function, bool template_header_p)\n       tree methods = CLASSTYPE_METHOD_VEC (ctype);\n       tree fndecls, fndecl = 0;\n       bool is_conv_op;\n+      bool pop_p;\n       const char *format = NULL;\n       \n-      push_scope (ctype);\n+      pop_p = push_scope (ctype);\n       for (fndecls = TREE_VEC_ELT (methods, ix);\n \t   fndecls; fndecls = OVL_NEXT (fndecls))\n \t{\n@@ -690,7 +691,8 @@ check_classfn (tree ctype, tree function, bool template_header_p)\n \t\t      == DECL_TI_TEMPLATE (fndecl))))\n \t    break;\n \t}\n-      pop_scope (ctype);\n+      if (pop_p)\n+\tpop_scope (ctype);\n       if (fndecls)\n \treturn OVL_CURRENT (fndecls);\n       error (\"prototype for `%#D' does not match any in class `%T'\","}, {"sha": "7d6239b67ed76f4abe6c456a3d4440e56eeb7aee", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91b004e5ec3518a97640b7dda5340dc52473d2f7/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91b004e5ec3518a97640b7dda5340dc52473d2f7/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=91b004e5ec3518a97640b7dda5340dc52473d2f7", "patch": "@@ -2494,15 +2494,30 @@ is_ancestor (tree root, tree child)\n     }\n }\n \n-/* Enter a class or namespace scope.  */\n+/* Enter the class or namespace scope indicated by T.  Returns TRUE iff\n+   pop_scope should be called later to exit this scope.  */\n \n-void\n+bool\n push_scope (tree t)\n {\n+  bool pop = true;\n+\n   if (TREE_CODE (t) == NAMESPACE_DECL)\n     push_decl_namespace (t);\n-  else if CLASS_TYPE_P (t)\n-    push_nested_class (t);\n+  else if (CLASS_TYPE_P (t))\n+    {\n+      if (!at_class_scope_p ()\n+\t  || !same_type_p (current_class_type, t))\n+\tpush_nested_class (t);\n+      else\n+\t/* T is the same as the current scope.  There is therefore no\n+\t   need to re-enter the scope.  Since we are not actually\n+\t   pushing a new scope, our caller should not call\n+\t   pop_scope.  */\n+\tpop = false;\n+    }\n+\n+  return pop;\n }\n \n /* Leave scope pushed by push_scope.  */"}, {"sha": "8377575205315fb8ca9a39499bad59db9f35174c", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91b004e5ec3518a97640b7dda5340dc52473d2f7/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91b004e5ec3518a97640b7dda5340dc52473d2f7/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=91b004e5ec3518a97640b7dda5340dc52473d2f7", "patch": "@@ -267,7 +267,7 @@ extern void pop_from_top_level (void);\n extern void pop_everything (void);\n extern void keep_next_level (bool);\n extern bool is_ancestor (tree, tree);\n-extern void push_scope (tree);\n+extern bool push_scope (tree);\n extern void pop_scope (tree);\n \f\n extern void push_namespace (tree);"}, {"sha": "bc887f89bf93fb4557e056dbada1969b88a97468", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91b004e5ec3518a97640b7dda5340dc52473d2f7/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91b004e5ec3518a97640b7dda5340dc52473d2f7/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=91b004e5ec3518a97640b7dda5340dc52473d2f7", "patch": "@@ -7035,6 +7035,7 @@ cp_parser_conversion_function_id (cp_parser* parser)\n   tree saved_scope;\n   tree saved_qualifying_scope;\n   tree saved_object_scope;\n+  bool pop_p = false;\n \n   /* Look for the `operator' token.  */\n   if (!cp_parser_require_keyword (parser, RID_OPERATOR, \"`operator'\"))\n@@ -7059,11 +7060,11 @@ cp_parser_conversion_function_id (cp_parser* parser)\n      In order to see that `I' is a type-name in the definition, we\n      must be in the scope of `S'.  */\n   if (saved_scope)\n-    push_scope (saved_scope);\n+    pop_p = push_scope (saved_scope);\n   /* Parse the conversion-type-id.  */\n   type = cp_parser_conversion_type_id (parser);\n   /* Leave the scope of the class, if any.  */\n-  if (saved_scope)\n+  if (pop_p)\n     pop_scope (saved_scope);\n   /* Restore the saved scope.  */\n   parser->scope = saved_scope;\n@@ -9935,6 +9936,7 @@ cp_parser_init_declarator (cp_parser* parser,\n   bool is_non_constant_init;\n   int ctor_dtor_or_conv_p;\n   bool friend_p;\n+  bool pop_p = false;\n \n   /* Assume that this is not the declarator for a function\n      definition.  */\n@@ -10092,7 +10094,7 @@ cp_parser_init_declarator (cp_parser* parser,\n   /* Enter the SCOPE.  That way unqualified names appearing in the\n      initializer will be looked up in SCOPE.  */\n   if (scope)\n-    push_scope (scope);\n+    pop_p = push_scope (scope);\n \n   /* Perform deferred access control checks, now that we know in which\n      SCOPE the declared entity resides.  */\n@@ -10142,7 +10144,7 @@ cp_parser_init_declarator (cp_parser* parser,\n      is important to do this before calling cp_finish_decl because it\n      makes decisions about whether to create DECL_STMTs or not based\n      on the current scope.  */\n-  if (scope)\n+  if (pop_p)\n     pop_scope (scope);\n \n   /* For an in-class declaration, use `grokfield' to create the\n@@ -10362,6 +10364,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n   bool saved_default_arg_ok_p = parser->default_arg_ok_p;\n   bool saved_in_declarator_p = parser->in_declarator_p;\n   bool first = true;\n+  bool pop_p = false;\n \n   while (true)\n     {\n@@ -10632,9 +10635,9 @@ cp_parser_direct_declarator (cp_parser* parser,\n \thandle_declarator:;\n \t  scope = get_scope_of_declarator (declarator);\n \t  if (scope)\n-\t    /* Any names that appear after the declarator-id for a member\n-       \t       are looked up in the containing scope.  */\n-\t    push_scope (scope);\n+\t    /* Any names that appear after the declarator-id for a\n+\t       member are looked up in the containing scope.  */\n+\t    pop_p = push_scope (scope);\n \t  parser->in_declarator_p = true;\n \t  if ((ctor_dtor_or_conv_p && *ctor_dtor_or_conv_p)\n \t      || (declarator\n@@ -10659,7 +10662,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n     cp_parser_error (parser, \"expected declarator\");\n \n   /* If we entered a scope, we must exit it now.  */\n-  if (scope)\n+  if (pop_p)\n     pop_scope (scope);\n \n   parser->default_arg_ok_p = saved_default_arg_ok_p;\n@@ -11782,6 +11785,7 @@ cp_parser_class_specifier (cp_parser* parser)\n   int has_trailing_semicolon;\n   bool nested_name_specifier_p;\n   unsigned saved_num_template_parameter_lists;\n+  bool pop_p = false;\n \n   push_deferring_access_checks (dk_no_deferred);\n \n@@ -11816,7 +11820,7 @@ cp_parser_class_specifier (cp_parser* parser)\n \n   /* Start the class.  */\n   if (nested_name_specifier_p)\n-    push_scope (CP_DECL_CONTEXT (TYPE_MAIN_DECL (type)));\n+    pop_p = push_scope (CP_DECL_CONTEXT (TYPE_MAIN_DECL (type)));\n   type = begin_class_definition (type);\n   if (type == error_mark_node)\n     /* If the type is erroneous, skip the entire body of the class.  */\n@@ -11841,7 +11845,7 @@ cp_parser_class_specifier (cp_parser* parser)\n       TYPE_ATTRIBUTES (type) = NULL_TREE;\n       type = finish_struct (type, attributes);\n     }\n-  if (nested_name_specifier_p)\n+  if (pop_p)\n     pop_scope (CP_DECL_CONTEXT (TYPE_MAIN_DECL (type)));\n   /* If this class is not itself within the scope of another class,\n      then we need to parse the bodies of all of the queued function\n@@ -11959,6 +11963,7 @@ cp_parser_class_head (cp_parser* parser,\n   bool qualified_p = false;\n   bool invalid_nested_name_p = false;\n   bool invalid_explicit_specialization_p = false;\n+  bool pop_p = false;\n   unsigned num_templates;\n \n   /* Assume no nested-name-specifier will be present.  */\n@@ -12179,6 +12184,7 @@ cp_parser_class_head (cp_parser* parser,\n   else\n     {\n       tree class_type;\n+      bool pop_p = false;\n \n       /* Given:\n \n@@ -12205,7 +12211,7 @@ cp_parser_class_head (cp_parser* parser,\n       class_type = current_class_type;\n       /* Enter the scope indicated by the nested-name-specifier.  */\n       if (nested_name_specifier)\n-\tpush_scope (nested_name_specifier);\n+\tpop_p = push_scope (nested_name_specifier);\n       /* Get the canonical version of this type.  */\n       type = TYPE_MAIN_DECL (TREE_TYPE (type));\n       if (PROCESSING_REAL_TEMPLATE_DECL_P ()\n@@ -12215,7 +12221,8 @@ cp_parser_class_head (cp_parser* parser,\n       if (nested_name_specifier)\n \t{\n \t  *nested_name_specifier_p = true;\n-\t  pop_scope (nested_name_specifier);\n+\t  if (pop_p)\n+\t    pop_scope (nested_name_specifier);\n \t}\n     }\n   /* Indicate whether this class was declared as a `class' or as a\n@@ -12232,7 +12239,7 @@ cp_parser_class_head (cp_parser* parser,\n \n      is valid.  */\n   if (nested_name_specifier)\n-    push_scope (nested_name_specifier);\n+    pop_p = push_scope (nested_name_specifier);\n   /* Now, look for the base-clause.  */\n   token = cp_lexer_peek_token (parser->lexer);\n   if (token->type == CPP_COLON)\n@@ -12246,7 +12253,7 @@ cp_parser_class_head (cp_parser* parser,\n     }\n   /* Leave the scope given by the nested-name-specifier.  We will\n      enter the class scope itself while processing the members.  */\n-  if (nested_name_specifier)\n+  if (pop_p)\n     pop_scope (nested_name_specifier);\n \n  done:\n@@ -13677,20 +13684,22 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n \t}\n       else\n \t{\n+\t  bool pop_p = false;\n+\n \t  /* If PARSER->SCOPE is a dependent type, then it must be a\n \t     class type, and we must not be checking dependencies;\n \t     otherwise, we would have processed this lookup above.  So\n \t     that PARSER->SCOPE is not considered a dependent base by\n \t     lookup_member, we must enter the scope here.  */\n \t  if (dependent_p)\n-\t    push_scope (parser->scope);\n+\t    pop_p = push_scope (parser->scope);\n \t  /* If the PARSER->SCOPE is a a template specialization, it\n \t     may be instantiated during name lookup.  In that case,\n \t     errors may be issued.  Even if we rollback the current\n \t     tentative parse, those errors are valid.  */\n \t  decl = lookup_qualified_name (parser->scope, name, is_type,\n \t\t\t\t\t/*complain=*/true);\n-\t  if (dependent_p)\n+\t  if (pop_p)\n \t    pop_scope (parser->scope);\n \t}\n       parser->qualifying_scope = parser->scope;\n@@ -14122,6 +14131,7 @@ cp_parser_constructor_declarator_p (cp_parser *parser, bool friend_p)\n \t  && !cp_parser_storage_class_specifier_opt (parser))\n \t{\n \t  tree type;\n+\t  bool pop_p = false;\n \t  unsigned saved_num_template_parameter_lists;\n \n \t  /* Names appearing in the type-specifier should be looked up\n@@ -14141,7 +14151,7 @@ cp_parser_constructor_declarator_p (cp_parser *parser, bool friend_p)\n \t\t      return false;\n \t\t    }\n \t\t}\n-\t      push_scope (type);\n+\t      pop_p = push_scope (type);\n \t    }\n \n \t  /* Inside the constructor parameter list, surrounding\n@@ -14162,7 +14172,7 @@ cp_parser_constructor_declarator_p (cp_parser *parser, bool friend_p)\n \t    = saved_num_template_parameter_lists;\n \n \t  /* Leave the scope of the class.  */\n-\t  if (type)\n+\t  if (pop_p)\n \t    pop_scope (type);\n \n \t  constructor_p = !cp_parser_error_occurred (parser);"}, {"sha": "3fa25768d9456e4ea0f2bf4d5e976a3049615e67", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91b004e5ec3518a97640b7dda5340dc52473d2f7/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91b004e5ec3518a97640b7dda5340dc52473d2f7/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=91b004e5ec3518a97640b7dda5340dc52473d2f7", "patch": "@@ -5408,12 +5408,13 @@ instantiate_class_template (tree type)\n       tree pbases = BINFO_BASETYPES (pbinfo);\n       tree paccesses = BINFO_BASEACCESSES (pbinfo);\n       tree context = TYPE_CONTEXT (type);\n+      bool pop_p;\n       int i;\n \n       /* We must enter the scope containing the type, as that is where\n \t the accessibility of types named in dependent bases are\n \t looked up from.  */\n-      push_scope (context ? context : global_namespace);\n+      pop_p = push_scope (context ? context : global_namespace);\n   \n       /* Substitute into each of the bases to determine the actual\n \t basetypes.  */\n@@ -5442,7 +5443,8 @@ instantiate_class_template (tree type)\n \t information.  */\n       xref_basetypes (type, base_list);\n \n-      pop_scope (context ? context : global_namespace);\n+      if (pop_p)\n+\tpop_scope (context ? context : global_namespace);\n     }\n \n   /* Now that our base classes are set up, enter the scope of the\n@@ -12019,6 +12021,7 @@ resolve_typename_type (tree type, bool only_current_p)\n   tree name;\n   tree decl;\n   int quals;\n+  bool pop_p;\n \n   my_friendly_assert (TREE_CODE (type) == TYPENAME_TYPE,\n \t\t      20010702);\n@@ -12048,7 +12051,7 @@ resolve_typename_type (tree type, bool only_current_p)\n   /* Enter the SCOPE so that name lookup will be resolved as if we\n      were in the class definition.  In particular, SCOPE will no\n      longer be considered a dependent type.  */\n-  push_scope (scope);\n+  pop_p = push_scope (scope);\n   /* Look up the declaration.  */\n   decl = lookup_member (scope, name, /*protect=*/0, /*want_type=*/true);\n   /* Obtain the set of qualifiers applied to the TYPE.  */\n@@ -12078,7 +12081,8 @@ resolve_typename_type (tree type, bool only_current_p)\n   if (type != error_mark_node && quals)\n     type = cp_build_qualified_type (type, quals);\n   /* Leave the SCOPE.  */\n-  pop_scope (scope);\n+  if (pop_p)\n+    pop_scope (scope);\n \n   return type;\n }"}]}