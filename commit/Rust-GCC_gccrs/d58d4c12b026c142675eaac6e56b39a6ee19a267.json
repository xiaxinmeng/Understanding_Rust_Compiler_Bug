{"sha": "d58d4c12b026c142675eaac6e56b39a6ee19a267", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDU4ZDRjMTJiMDI2YzE0MjY3NWVhYWM2ZTU2YjM5YTZlZTE5YTI2Nw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-06-08T12:19:12Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-06-08T12:19:12Z"}, "message": "recog.c (split_insn): Break out from ...\n\n\t* recog.c (split_insn): Break out from ...\n\t(split_all_insns): ... here; do not use basic block information\n\twhen it is broken.\n\nFrom-SVN: r43009", "tree": {"sha": "dd3d17787755b51a8bbd76a528913f61c00e6586", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd3d17787755b51a8bbd76a528913f61c00e6586"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d58d4c12b026c142675eaac6e56b39a6ee19a267", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d58d4c12b026c142675eaac6e56b39a6ee19a267", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d58d4c12b026c142675eaac6e56b39a6ee19a267", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d58d4c12b026c142675eaac6e56b39a6ee19a267/comments", "author": null, "committer": null, "parents": [{"sha": "2fe7bb353a00133df8adf8bb525f37b6c3f1d4af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fe7bb353a00133df8adf8bb525f37b6c3f1d4af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fe7bb353a00133df8adf8bb525f37b6c3f1d4af"}], "stats": {"total": 157, "additions": 92, "deletions": 65}, "files": [{"sha": "45f1eb206b43543cf073f7efaa271844c406a191", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d58d4c12b026c142675eaac6e56b39a6ee19a267/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d58d4c12b026c142675eaac6e56b39a6ee19a267/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d58d4c12b026c142675eaac6e56b39a6ee19a267", "patch": "@@ -1,3 +1,9 @@\n+Fri Jun  8 14:16:33 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* recog.c (split_insn): Break out from ...\n+\t(split_all_insns): ... here; do not use basic block information\n+\twhen it is broken.\n+\n Thu Jun  7 18:27:53 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* simplify-rtx.c (simplify_subreg):  Fix verification of"}, {"sha": "c823ea1f0d29455fb8f6be2e3c27e2551ae35447", "filename": "gcc/recog.c", "status": "modified", "additions": 86, "deletions": 65, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d58d4c12b026c142675eaac6e56b39a6ee19a267/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d58d4c12b026c142675eaac6e56b39a6ee19a267/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=d58d4c12b026c142675eaac6e56b39a6ee19a267", "patch": "@@ -57,6 +57,7 @@ static void validate_replace_rtx_1\tPARAMS ((rtx *, rtx, rtx, rtx));\n static rtx *find_single_use_1\t\tPARAMS ((rtx, rtx *));\n static rtx *find_constant_term_loc\tPARAMS ((rtx *));\n static void validate_replace_src_1 \tPARAMS ((rtx *, void *));\n+static rtx split_insn\t\t\tPARAMS ((rtx));\n \n /* Nonzero means allow operands to be volatile.\n    This should be 0 if you are generating rtl, such as if you are calling\n@@ -2700,6 +2701,66 @@ reg_fits_class_p (operand, class, offset, mode)\n   return 0;\n }\n \f\n+/* Split single instruction.  Helper function for split_all_insns.\n+   Return last insn in the sequence if succesfull, or NULL if unsuccesfull.  */\n+static rtx\n+split_insn (insn)\n+     rtx insn;\n+{\n+  rtx set;\n+  if (!INSN_P (insn))\n+    ;\n+  /* Don't split no-op move insns.  These should silently\n+     disappear later in final.  Splitting such insns would\n+     break the code that handles REG_NO_CONFLICT blocks.  */\n+\n+  else if ((set = single_set (insn)) != NULL && set_noop_p (set))\n+    {\n+      /* Nops get in the way while scheduling, so delete them\n+         now if register allocation has already been done.  It\n+         is too risky to try to do this before register\n+         allocation, and there are unlikely to be very many\n+         nops then anyways.  */\n+      if (reload_completed)\n+\t{\n+\t  PUT_CODE (insn, NOTE);\n+\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n+\t  NOTE_SOURCE_FILE (insn) = 0;\n+\t}\n+    }\n+  else\n+    {\n+      /* Split insns here to get max fine-grain parallelism.  */\n+      rtx first = PREV_INSN (insn);\n+      rtx last = try_split (PATTERN (insn), insn, 1);\n+\n+      if (last != insn)\n+\t{\n+\t  /* try_split returns the NOTE that INSN became.  */\n+\t  PUT_CODE (insn, NOTE);\n+\t  NOTE_SOURCE_FILE (insn) = 0;\n+\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n+\n+\t  /* ??? Coddle to md files that generate subregs in post-\n+\t     reload splitters instead of computing the proper \n+\t     hard register.  */\n+\t  if (reload_completed && first != last)\n+\t    {\n+\t      first = NEXT_INSN (first);\n+\t      while (1)\n+\t\t{\n+\t\t  if (INSN_P (first))\n+\t\t    cleanup_subreg_operands (first);\n+\t\t  if (first == last)\n+\t\t    break;\n+\t\t  first = NEXT_INSN (first);\n+\t\t}\n+\t    }\n+\t  return last;\n+\t}\n+    }\n+  return NULL_RTX;\n+}\n /* Split all insns in the function.  If UPD_LIFE, update life info after.  */\n \n void\n@@ -2710,6 +2771,22 @@ split_all_insns (upd_life)\n   int changed;\n   int i;\n \n+  if (!upd_life)\n+    {\n+      rtx next, insn;\n+\n+      for (insn = get_insns (); insn ; insn = next)\n+\t{\n+\t  rtx last;\n+\n+\t  /* Can't use `next_real_insn' because that might go across\n+\t     CODE_LABELS and short-out basic blocks.  */\n+\t  next = NEXT_INSN (insn);\n+\t  last = split_insn (insn);\n+\t}\n+      return;\n+    }\n+\n   blocks = sbitmap_alloc (n_basic_blocks);\n   sbitmap_zero (blocks);\n   changed = 0;\n@@ -2721,82 +2798,26 @@ split_all_insns (upd_life)\n \n       for (insn = bb->head; insn ; insn = next)\n \t{\n-\t  rtx set;\n+\t  rtx last;\n \n \t  /* Can't use `next_real_insn' because that might go across\n \t     CODE_LABELS and short-out basic blocks.  */\n \t  next = NEXT_INSN (insn);\n-\t  if (! INSN_P (insn))\n-\t    ;\n-\n-\t  /* Don't split no-op move insns.  These should silently\n-\t     disappear later in final.  Splitting such insns would\n-\t     break the code that handles REG_NO_CONFLICT blocks.  */\n-\n-\t  else if ((set = single_set (insn)) != NULL\n-\t\t   && set_noop_p (set))\n+\t  last = split_insn (insn);\n+\t  if (last)\n \t    {\n-\t      /* Nops get in the way while scheduling, so delete them\n-\t\t now if register allocation has already been done.  It\n-\t\t is too risky to try to do this before register\n-\t\t allocation, and there are unlikely to be very many\n-\t\t nops then anyways.  */\n-\t      if (reload_completed)\n-\t\t{\n-\t\t  PUT_CODE (insn, NOTE);\n-\t\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\t\t  NOTE_SOURCE_FILE (insn) = 0;\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Split insns here to get max fine-grain parallelism.  */\n-\t      rtx first = PREV_INSN (insn);\n-\t      rtx last = try_split (PATTERN (insn), insn, 1);\n-\n-\t      if (last != insn)\n-\t\t{\n-\t\t  SET_BIT (blocks, i);\n-\t\t  changed = 1;\n-\n-\t\t  /* try_split returns the NOTE that INSN became.  */\n-\t\t  PUT_CODE (insn, NOTE);\n-\t\t  NOTE_SOURCE_FILE (insn) = 0;\n-\t\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\n-\t\t  /* ??? Coddle to md files that generate subregs in post-\n-\t\t     reload splitters instead of computing the proper \n-\t\t     hard register.  */\n-\t\t  if (reload_completed && first != last)\n-\t\t    {\n-\t\t      first = NEXT_INSN (first);\n-\t\t      while (1)\n-\t\t\t{\n-\t\t\t  if (INSN_P (first))\n-\t\t\t    cleanup_subreg_operands (first);\n-\t\t\t  if (first == last)\n-\t\t\t    break;\n-\t\t\t  first = NEXT_INSN (first);\n-\t\t\t}\n-\t\t    }\n-\n-\t\t  if (insn == bb->end)\n-\t\t    {\n-\t\t      bb->end = last;\n-\t\t      break;\n-\t\t    }\n-\t\t}\n+\t      SET_BIT (blocks, i);\n+\t      changed = 1;\n+\t      if (insn == bb->end)\n+\t\tbb->end = last;\n+\t      insn = last;\n \t    }\n \n \t  if (insn == bb->end)\n \t    break;\n \t}\n \n-      /* ??? When we're called from just after reload, the CFG is in bad\n-\t shape, and we may have fallen off the end.  This could be fixed\n-\t by having reload not try to delete unreachable code.  Otherwise\n-\t assert we found the end insn.  */\n-      if (insn == NULL && upd_life)\n+      if (insn == NULL)\n \tabort ();\n     }\n "}]}